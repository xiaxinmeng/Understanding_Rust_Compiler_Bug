{"sha": "32c3a75390623a0470df52af13f78baddd562981", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJjM2E3NTM5MDYyM2EwNDcwZGY1MmFmMTNmNzhiYWRkZDU2Mjk4MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-08-17T19:06:39Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-08-17T19:18:29Z"}, "message": "c++: Implement P0466R5 __cpp_lib_is_layout_compatible compiler helpers [PR101539]\n\nThe following patch implements __is_layout_compatible trait and\n__builtin_is_corresponding_member helper function for the\nstd::is_corresponding_member template function.\n\nAs the current definition of layout compatible type has various problems,\nwhich result e.g. in corresponding members in layout compatible types having\ndifferent member offsets, the patch anticipates some changes to the C++\nstandard:\n1) class or enumeral types aren't layout compatible if they have different\n   alignment or size\n2) if two members have different offsets, they can't be corresponding members\n   ([[no_unique_address]] with empty types can change that, or alignas\n   on the member decls)\n3) in unions, bitfields can't correspond to non-unions, or bitfields can't\n   correspond to bitfields with different widths, or members with\n   [[no_unique_address]] can't correspond to members without that attribute\n\n__builtin_is_corresponding_member for anonymous structs (GCC extension) will\nrecurse into the anonymous structs.  For anonymous unions it will emit\na sorry if it can't prove such member types can't appear in the\nanonymous unions or anonymous aggregates in that union, because\ncorresponding member is defined only using common initial sequence which is\nonly defined for std-layout non-union class types and so I have no idea what\nto do otherwise in that case.\n\n2021-08-17  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/101539\ngcc/c-family/\n\t* c-common.h (enum rid): Add RID_IS_LAYOUT_COMPATIBLE.\n\t* c-common.c (c_common_reswords): Add __is_layout_compatible.\ngcc/cp/\n\t* cp-tree.h (enum cp_trait_kind): Add CPTK_IS_LAYOUT_COMPATIBLE.\n\t(enum cp_built_in_function): Add CP_BUILT_IN_IS_CORRESPONDING_MEMBER.\n\t(fold_builtin_is_corresponding_member, next_common_initial_seqence,\n\tlayout_compatible_type_p): Declare.\n\t* parser.c (cp_parser_primary_expression): Handle\n\tRID_IS_LAYOUT_COMPATIBLE.\n\t(cp_parser_trait_expr): Likewise.\n\t* cp-objcp-common.c (names_builtin_p): Likewise.\n\t* constraint.cc (diagnose_trait_expr): Handle\n\tCPTK_IS_LAYOUT_COMPATIBLE.\n\t* decl.c (cxx_init_decl_processing): Register\n\t__builtin_is_corresponding_member builtin.\n\t* constexpr.c (cxx_eval_builtin_function_call): Handle\n\tCP_BUILT_IN_IS_CORRESPONDING_MEMBER builtin.\n\t* semantics.c (is_corresponding_member_union,\n\tis_corresponding_member_aggr, fold_builtin_is_corresponding_member):\n\tNew functions.\n\t(trait_expr_value): Handle CPTK_IS_LAYOUT_COMPATIBLE.\n\t(finish_trait_expr): Likewise.\n\t* typeck.c (next_common_initial_seqence, layout_compatible_type_p):\n\tNew functions.\n\t* cp-gimplify.c (cp_gimplify_expr): Fold\n\tCP_BUILT_IN_IS_CORRESPONDING_MEMBER.\n\t(cp_fold): Likewise.\n\t* tree.c (builtin_valid_in_constant_expr_p): Handle\n\tCP_BUILT_IN_IS_CORRESPONDING_MEMBER.\n\t* cxx-pretty-print.c (pp_cxx_trait_expression): Handle\n\tCPTK_IS_LAYOUT_COMPATIBLE.\n\t* class.c (remove_zero_width_bit_fields): Remove.\n\t(layout_class_type): Don't call it.\ngcc/testsuite/\n\t* g++.dg/cpp2a/is-corresponding-member1.C: New test.\n\t* g++.dg/cpp2a/is-corresponding-member2.C: New test.\n\t* g++.dg/cpp2a/is-corresponding-member3.C: New test.\n\t* g++.dg/cpp2a/is-corresponding-member4.C: New test.\n\t* g++.dg/cpp2a/is-corresponding-member5.C: New test.\n\t* g++.dg/cpp2a/is-corresponding-member6.C: New test.\n\t* g++.dg/cpp2a/is-corresponding-member7.C: New test.\n\t* g++.dg/cpp2a/is-corresponding-member8.C: New test.\n\t* g++.dg/cpp2a/is-layout-compatible1.C: New test.\n\t* g++.dg/cpp2a/is-layout-compatible2.C: New test.\n\t* g++.dg/cpp2a/is-layout-compatible3.C: New test.", "tree": {"sha": "355341d9af7a9a5254daaebedabba684d33c457e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/355341d9af7a9a5254daaebedabba684d33c457e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32c3a75390623a0470df52af13f78baddd562981", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32c3a75390623a0470df52af13f78baddd562981", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32c3a75390623a0470df52af13f78baddd562981", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32c3a75390623a0470df52af13f78baddd562981/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "798666392b512a585f0de2983a5d3423e960959e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/798666392b512a585f0de2983a5d3423e960959e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/798666392b512a585f0de2983a5d3423e960959e"}], "stats": {"total": 1186, "additions": 1155, "deletions": 31}, "files": [{"sha": "017e41537acc0bd757e73ee262f589af704e1c20", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -420,6 +420,7 @@ const struct c_common_resword c_common_reswords[] =\n   { \"__is_empty\",\tRID_IS_EMPTY,\tD_CXXONLY },\n   { \"__is_enum\",\tRID_IS_ENUM,\tD_CXXONLY },\n   { \"__is_final\",\tRID_IS_FINAL,\tD_CXXONLY },\n+  { \"__is_layout_compatible\", RID_IS_LAYOUT_COMPATIBLE, D_CXXONLY },\n   { \"__is_literal_type\", RID_IS_LITERAL_TYPE, D_CXXONLY },\n   { \"__is_pointer_interconvertible_base_of\",\n \t\t\tRID_IS_POINTER_INTERCONVERTIBLE_BASE_OF, D_CXXONLY },"}, {"sha": "d66bf158d1ebf780117a4d72e41cd04469ba1753", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -173,7 +173,8 @@ enum rid\n   RID_IS_ABSTRACT,             RID_IS_AGGREGATE,\n   RID_IS_BASE_OF,              RID_IS_CLASS,\n   RID_IS_EMPTY,                RID_IS_ENUM,\n-  RID_IS_FINAL,                RID_IS_LITERAL_TYPE,\n+  RID_IS_FINAL,                RID_IS_LAYOUT_COMPATIBLE,\n+  RID_IS_LITERAL_TYPE,\n   RID_IS_POINTER_INTERCONVERTIBLE_BASE_OF,\n   RID_IS_POD,                  RID_IS_POLYMORPHIC,\n   RID_IS_SAME_AS,"}, {"sha": "7138e304937631c5b858066d5b88e0f87ea1eeb6", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -136,7 +136,6 @@ static bool check_field_decl (tree, tree, int *, int *);\n static void check_field_decls (tree, tree *, int *, int *);\n static void build_base_fields (record_layout_info, splay_tree, tree *);\n static void check_methods (tree);\n-static void remove_zero_width_bit_fields (tree);\n static bool accessible_nvdtor_p (tree);\n \n /* Used by find_flexarrays and related functions.  */\n@@ -5754,31 +5753,6 @@ type_build_dtor_call (tree t)\n   return false;\n }\n \n-/* Remove all zero-width bit-fields from T.  */\n-\n-static void\n-remove_zero_width_bit_fields (tree t)\n-{\n-  tree *fieldsp;\n-\n-  fieldsp = &TYPE_FIELDS (t);\n-  while (*fieldsp)\n-    {\n-      if (TREE_CODE (*fieldsp) == FIELD_DECL\n-\t  && DECL_C_BIT_FIELD (*fieldsp)\n-\t  /* We should not be confused by the fact that grokbitfield\n-\t     temporarily sets the width of the bit field into\n-\t     DECL_BIT_FIELD_REPRESENTATIVE (*fieldsp).\n-\t     check_bitfield_decl eventually sets DECL_SIZE (*fieldsp)\n-\t     to that width.  */\n-\t  && (DECL_SIZE (*fieldsp) == NULL_TREE\n-\t      || integer_zerop (DECL_SIZE (*fieldsp))))\n-\t*fieldsp = DECL_CHAIN (*fieldsp);\n-      else\n-\tfieldsp = &DECL_CHAIN (*fieldsp);\n-    }\n-}\n-\n /* Returns TRUE iff we need a cookie when dynamically allocating an\n    array whose elements have the indicated class TYPE.  */\n \n@@ -6770,10 +6744,6 @@ layout_class_type (tree t, tree *virtuals_p)\n       normalize_rli (rli);\n     }\n \n-  /* Delete all zero-width bit-fields from the list of fields.  Now\n-     that the type is laid out they are no longer important.  */\n-  remove_zero_width_bit_fields (t);\n-\n   if (CLASSTYPE_NON_LAYOUT_POD_P (t) || CLASSTYPE_EMPTY_P (t))\n     {\n       /* T needs a different layout as a base (eliding virtual bases"}, {"sha": "b9c006217be867d376f442f5aa36c5fdb0cbcfe8", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -1438,6 +1438,18 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n \t= fold_builtin_is_pointer_inverconvertible_with_class (loc, nargs,\n \t\t\t\t\t\t\t       args);\n     }\n+  else if (fndecl_built_in_p (fun,\n+\t\t\t      CP_BUILT_IN_IS_CORRESPONDING_MEMBER,\n+\t\t\t      BUILT_IN_FRONTEND))\n+    {\n+      location_t loc = EXPR_LOCATION (t);\n+      if (nargs >= 2)\n+\t{\n+\t  VERIFY_CONSTANT (args[0]);\n+\t  VERIFY_CONSTANT (args[1]);\n+\t}\n+      new_call = fold_builtin_is_corresponding_member (loc, nargs, args);\n+    }\n   else\n     new_call = fold_builtin_call_array (EXPR_LOCATION (t), TREE_TYPE (t),\n \t\t\t\t\tCALL_EXPR_FN (t), nargs, args);"}, {"sha": "1aaf1e2788633f6485a31e735acc3260edd6b259", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -3628,6 +3628,9 @@ diagnose_trait_expr (tree expr, tree args)\n     case CPTK_IS_FINAL:\n       inform (loc, \"  %qT is not a final class\", t1);\n       break;\n+    case CPTK_IS_LAYOUT_COMPATIBLE:\n+      inform (loc, \"  %qT is not layout compatible with %qT\", t1, t2);\n+      break;\n     case CPTK_IS_LITERAL_TYPE:\n       inform (loc, \"  %qT is not a literal type\", t1);\n       break;"}, {"sha": "bf928a82ce990d9f397c35dc2920ba7405538250", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -658,12 +658,20 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t\t*expr_p\n \t\t  = fold_builtin_source_location (EXPR_LOCATION (*expr_p));\n \t\tbreak;\n+\t      case CP_BUILT_IN_IS_CORRESPONDING_MEMBER:\n+\t\t*expr_p\n+\t\t  = fold_builtin_is_corresponding_member\n+\t\t\t(EXPR_LOCATION (*expr_p), call_expr_nargs (*expr_p),\n+\t\t\t &CALL_EXPR_ARG (*expr_p, 0));\n+\t\tbreak;\n \t      case CP_BUILT_IN_IS_POINTER_INTERCONVERTIBLE_WITH_CLASS:\n \t\t*expr_p\n \t\t  = fold_builtin_is_pointer_inverconvertible_with_class\n \t\t\t(EXPR_LOCATION (*expr_p), call_expr_nargs (*expr_p),\n \t\t\t &CALL_EXPR_ARG (*expr_p, 0));\n \t\tbreak;\n+\t      default:\n+\t\tbreak;\n \t      }\n \t}\n       break;\n@@ -2579,6 +2587,11 @@ cp_fold (tree x)\n \t      case CP_BUILT_IN_SOURCE_LOCATION:\n \t\tx = fold_builtin_source_location (EXPR_LOCATION (x));\n \t\tbreak;\n+\t      case CP_BUILT_IN_IS_CORRESPONDING_MEMBER:\n+\t        x = fold_builtin_is_corresponding_member\n+\t\t\t(EXPR_LOCATION (x), call_expr_nargs (x),\n+\t\t\t &CALL_EXPR_ARG (x, 0));\n+\t\tbreak;\n \t      case CP_BUILT_IN_IS_POINTER_INTERCONVERTIBLE_WITH_CLASS:\n                 x = fold_builtin_is_pointer_inverconvertible_with_class\n \t\t\t(EXPR_LOCATION (x), call_expr_nargs (x),"}, {"sha": "98fd96227c44ba1dd17ca5333483fa264a586c5d", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -413,6 +413,7 @@ names_builtin_p (const char *name)\n     case RID_IS_EMPTY:\n     case RID_IS_ENUM:\n     case RID_IS_FINAL:\n+    case RID_IS_LAYOUT_COMPATIBLE:\n     case RID_IS_LITERAL_TYPE:\n     case RID_IS_POINTER_INTERCONVERTIBLE_BASE_OF:\n     case RID_IS_POD:"}, {"sha": "14e2db26f776ab0aa251bacbb74f3bb5943625e3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -1365,6 +1365,7 @@ enum cp_trait_kind\n   CPTK_IS_EMPTY,\n   CPTK_IS_ENUM,\n   CPTK_IS_FINAL,\n+  CPTK_IS_LAYOUT_COMPATIBLE,\n   CPTK_IS_LITERAL_TYPE,\n   CPTK_IS_POINTER_INTERCONVERTIBLE_BASE_OF,\n   CPTK_IS_POD,\n@@ -6358,6 +6359,7 @@ struct GTY((chain_next (\"%h.next\"))) tinst_level {\n enum cp_built_in_function {\n   CP_BUILT_IN_IS_CONSTANT_EVALUATED,\n   CP_BUILT_IN_INTEGER_PACK,\n+  CP_BUILT_IN_IS_CORRESPONDING_MEMBER,\n   CP_BUILT_IN_IS_POINTER_INTERCONVERTIBLE_WITH_CLASS,\n   CP_BUILT_IN_SOURCE_LOCATION,\n   CP_BUILT_IN_LAST\n@@ -7574,6 +7576,7 @@ extern tree baselink_for_fns                    (tree);\n extern void finish_static_assert                (tree, tree, location_t,\n \t\t\t\t\t\t bool, bool);\n extern tree finish_decltype_type                (tree, bool, tsubst_flags_t);\n+extern tree fold_builtin_is_corresponding_member (location_t, int, tree *);\n extern tree fold_builtin_is_pointer_inverconvertible_with_class (location_t, int, tree *);\n extern tree finish_trait_expr\t\t\t(location_t, enum cp_trait_kind, tree, tree);\n extern tree build_lambda_expr                   (void);\n@@ -7800,6 +7803,8 @@ extern bool comp_except_specs\t\t\t(const_tree, const_tree, int);\n extern bool comptypes\t\t\t\t(tree, tree, int);\n extern bool same_type_ignoring_top_level_qualifiers_p (tree, tree);\n extern bool similar_type_p\t\t\t(tree, tree);\n+extern bool next_common_initial_seqence\t\t(tree &, tree &);\n+extern bool layout_compatible_type_p\t\t(tree, tree);\n extern bool compparms\t\t\t\t(const_tree, const_tree);\n extern int comp_cv_qualification\t\t(const_tree, const_tree);\n extern int comp_cv_qualification\t\t(int, int);"}, {"sha": "25cabfee39fca6f7a5ac90502fdf9612c1506559", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -2645,6 +2645,9 @@ pp_cxx_trait_expression (cxx_pretty_printer *pp, tree t)\n     case CPTK_IS_FINAL:\n       pp_cxx_ws_string (pp, \"__is_final\");\n       break;\n+    case CPTK_IS_LAYOUT_COMPATIBLE:\n+      pp_cxx_ws_string (pp, \"__is_layout_compatible\");\n+      break;\n     case CPTK_IS_POINTER_INTERCONVERTIBLE_BASE_OF:\n       pp_cxx_ws_string (pp, \"__is_pointer_interconvertible_base_of\");\n       break;\n@@ -2700,6 +2703,7 @@ pp_cxx_trait_expression (cxx_pretty_printer *pp, tree t)\n \n   if (kind == CPTK_IS_BASE_OF\n       || kind == CPTK_IS_SAME_AS\n+      || kind == CPTK_IS_LAYOUT_COMPATIBLE\n       || kind == CPTK_IS_POINTER_INTERCONVERTIBLE_BASE_OF)\n     {\n       pp_cxx_separate_with (pp, ',');"}, {"sha": "32d07babf43bc821ccfe2a270dfed56ca5ae2f05", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -4469,6 +4469,13 @@ cxx_init_decl_processing (void)\n \n   tree bool_vaftype = build_varargs_function_type_list (boolean_type_node,\n \t\t\t\t\t\t\tNULL_TREE);\n+  decl\n+    = add_builtin_function (\"__builtin_is_corresponding_member\",\n+\t\t\t    bool_vaftype,\n+\t\t\t    CP_BUILT_IN_IS_CORRESPONDING_MEMBER,\n+\t\t\t    BUILT_IN_FRONTEND, NULL, NULL_TREE);\n+  set_call_expr_flags (decl, ECF_CONST | ECF_NOTHROW | ECF_LEAF);\n+\n   decl\n     = add_builtin_function (\"__builtin_is_pointer_interconvertible_with_class\",\n \t\t\t    bool_vaftype,"}, {"sha": "9de72f8db51373f5e25128a1cad1b89c89f28a9c", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -5816,6 +5816,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \tcase RID_IS_EMPTY:\n \tcase RID_IS_ENUM:\n \tcase RID_IS_FINAL:\n+\tcase RID_IS_LAYOUT_COMPATIBLE:\n \tcase RID_IS_LITERAL_TYPE:\n \tcase RID_IS_POINTER_INTERCONVERTIBLE_BASE_OF:\n \tcase RID_IS_POD:\n@@ -10707,6 +10708,10 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n     case RID_IS_FINAL:\n       kind = CPTK_IS_FINAL;\n       break;\n+    case RID_IS_LAYOUT_COMPATIBLE:\n+      kind = CPTK_IS_LAYOUT_COMPATIBLE;\n+      binary = true;\n+      break;\n     case RID_IS_LITERAL_TYPE:\n       kind = CPTK_IS_LITERAL_TYPE;\n       break;"}, {"sha": "e191aa36c98fa4ea88bfb88bd3f94fa31e2c0bc8", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -10693,6 +10693,258 @@ fold_builtin_is_pointer_inverconvertible_with_class (location_t loc, int nargs,\n \t\t      build_zero_cst (TREE_TYPE (arg)));\n }\n \n+/* Helper function for is_corresponding_member_aggr.  Return true if\n+   MEMBERTYPE pointer-to-data-member ARG can be found in anonymous\n+   union or structure BASETYPE.  */\n+\n+static bool\n+is_corresponding_member_union (tree basetype, tree membertype, tree arg)\n+{\n+  for (tree field = TYPE_FIELDS (basetype); field; field = DECL_CHAIN (field))\n+    if (TREE_CODE (field) != FIELD_DECL || DECL_BIT_FIELD_TYPE (field))\n+      continue;\n+    else if (same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (field),\n+\t\t\t\t\t\t\tmembertype))\n+      {\n+\tif (TREE_CODE (arg) != INTEGER_CST\n+\t    || tree_int_cst_equal (arg, byte_position (field)))\n+\t  return true;\n+      }\n+    else if (ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n+      {\n+\ttree narg = arg;\n+\tif (TREE_CODE (basetype) != UNION_TYPE\n+\t    && TREE_CODE (narg) == INTEGER_CST)\n+\t  narg = size_binop (MINUS_EXPR, arg, byte_position (field));\n+\tif (is_corresponding_member_union (TREE_TYPE (field),\n+\t\t\t\t\t   membertype, narg))\n+\t  return true;\n+      }\n+  return false;\n+}\n+\n+/* Helper function for fold_builtin_is_corresponding_member call.\n+   Return boolean_false_node if MEMBERTYPE1 BASETYPE1::*ARG1 and\n+   MEMBERTYPE2 BASETYPE2::*ARG2 aren't corresponding members,\n+   boolean_true_node if they are corresponding members, or for\n+   non-constant ARG2 the highest member offset for corresponding\n+   members.  */\n+\n+static tree\n+is_corresponding_member_aggr (location_t loc, tree basetype1, tree membertype1,\n+\t\t\t      tree arg1, tree basetype2, tree membertype2,\n+\t\t\t      tree arg2)\n+{\n+  tree field1 = TYPE_FIELDS (basetype1);\n+  tree field2 = TYPE_FIELDS (basetype2);\n+  tree ret = boolean_false_node;\n+  while (1)\n+    {\n+      bool r = next_common_initial_seqence (field1, field2);\n+      if (field1 == NULL_TREE || field2 == NULL_TREE)\n+\tbreak;\n+      if (r\n+\t  && same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (field1),\n+\t\t\t\t\t\t\tmembertype1)\n+\t  && same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (field2),\n+\t\t\t\t\t\t\tmembertype2))\n+\t{\n+\t  tree pos = byte_position (field1);\n+\t  if (TREE_CODE (arg1) == INTEGER_CST\n+\t      && tree_int_cst_equal (arg1, pos))\n+\t    {\n+\t      if (TREE_CODE (arg2) == INTEGER_CST)\n+\t\treturn boolean_true_node;\n+\t      return pos;\n+\t    }\n+\t  else if (TREE_CODE (arg1) != INTEGER_CST)\n+\t    ret = pos;\n+\t}\n+      else if (ANON_AGGR_TYPE_P (TREE_TYPE (field1))\n+\t       && ANON_AGGR_TYPE_P (TREE_TYPE (field2)))\n+\t{\n+\t  if ((!lookup_attribute (\"no_unique_address\",\n+\t\t\t\t  DECL_ATTRIBUTES (field1)))\n+\t      != !lookup_attribute (\"no_unique_address\",\n+\t\t\t\t    DECL_ATTRIBUTES (field2)))\n+\t    break;\n+\t  if (!tree_int_cst_equal (bit_position (field1),\n+\t\t\t\t   bit_position (field2)))\n+\t    break;\n+\t  bool overlap = true;\n+\t  tree pos = byte_position (field1);\n+\t  if (TREE_CODE (arg1) == INTEGER_CST)\n+\t    {\n+\t      tree off1 = fold_convert (sizetype, arg1);\n+\t      tree sz1 = TYPE_SIZE_UNIT (TREE_TYPE (field1));\n+\t      if (tree_int_cst_lt (off1, pos)\n+\t\t  || tree_int_cst_le (size_binop (PLUS_EXPR, pos, sz1), off1))\n+\t\toverlap = false;\n+\t    }\n+\t  if (TREE_CODE (arg2) == INTEGER_CST)\n+\t    {\n+\t      tree off2 = fold_convert (sizetype, arg2);\n+\t      tree sz2 = TYPE_SIZE_UNIT (TREE_TYPE (field2));\n+\t      if (tree_int_cst_lt (off2, pos)\n+\t\t  || tree_int_cst_le (size_binop (PLUS_EXPR, pos, sz2), off2))\n+\t\toverlap = false;\n+\t    }\n+\t  if (overlap\n+\t      && NON_UNION_CLASS_TYPE_P (TREE_TYPE (field1))\n+\t      && NON_UNION_CLASS_TYPE_P (TREE_TYPE (field2)))\n+\t    {\n+\t      tree narg1 = arg1;\n+\t      if (TREE_CODE (arg1) == INTEGER_CST)\n+\t\tnarg1 = size_binop (MINUS_EXPR,\n+\t\t\t\t    fold_convert (sizetype, arg1), pos);\n+\t      tree narg2 = arg2;\n+\t      if (TREE_CODE (arg2) == INTEGER_CST)\n+\t\tnarg2 = size_binop (MINUS_EXPR,\n+\t\t\t\t    fold_convert (sizetype, arg2), pos);\n+\t      tree t1 = TREE_TYPE (field1);\n+\t      tree t2 = TREE_TYPE (field2);\n+\t      tree nret = is_corresponding_member_aggr (loc, t1, membertype1,\n+\t\t\t\t\t\t\tnarg1, t2, membertype2,\n+\t\t\t\t\t\t\tnarg2);\n+\t      if (nret != boolean_false_node)\n+\t\t{\n+\t\t  if (nret == boolean_true_node)\n+\t\t    return nret;\n+\t\t  if (TREE_CODE (arg1) == INTEGER_CST)\n+\t\t    return size_binop (PLUS_EXPR, nret, pos);\n+\t\t  ret = size_binop (PLUS_EXPR, nret, pos);\n+\t\t}\n+\t    }\n+\t  else if (overlap\n+\t\t   && TREE_CODE (TREE_TYPE (field1)) == UNION_TYPE\n+\t\t   && TREE_CODE (TREE_TYPE (field2)) == UNION_TYPE)\n+\t    {\n+\t      tree narg1 = arg1;\n+\t      if (TREE_CODE (arg1) == INTEGER_CST)\n+\t\tnarg1 = size_binop (MINUS_EXPR,\n+\t\t\t\t    fold_convert (sizetype, arg1), pos);\n+\t      tree narg2 = arg2;\n+\t      if (TREE_CODE (arg2) == INTEGER_CST)\n+\t\tnarg2 = size_binop (MINUS_EXPR,\n+\t\t\t\t    fold_convert (sizetype, arg2), pos);\n+\t      if (is_corresponding_member_union (TREE_TYPE (field1),\n+\t\t\t\t\t\t membertype1, narg1)\n+\t\t  && is_corresponding_member_union (TREE_TYPE (field2),\n+\t\t\t\t\t\t    membertype2, narg2))\n+\t\t{\n+\t\t  sorry_at (loc, \"%<__builtin_is_corresponding_member%> \"\n+\t\t\t\t \"not well defined for anonymous unions\");\n+\t\t  return boolean_false_node;\n+\t\t}\n+\t    }\n+\t}\n+      if (!r)\n+\tbreak;\n+      field1 = DECL_CHAIN (field1);\n+      field2 = DECL_CHAIN (field2);\n+    }\n+  return ret;\n+}\n+\n+/* Fold __builtin_is_corresponding_member call.  */\n+\n+tree\n+fold_builtin_is_corresponding_member (location_t loc, int nargs,\n+\t\t\t\t      tree *args)\n+{\n+  /* Unless users call the builtin directly, the following 3 checks should be\n+     ensured from std::is_corresponding_member function template.  */\n+  if (nargs != 2)\n+    {\n+      error_at (loc, \"%<__builtin_is_corresponding_member%> \"\n+\t\t     \"needs two arguments\");\n+      return boolean_false_node;\n+    }\n+  tree arg1 = args[0];\n+  tree arg2 = args[1];\n+  if (error_operand_p (arg1) || error_operand_p (arg2))\n+    return boolean_false_node;\n+  if (!TYPE_PTRMEM_P (TREE_TYPE (arg1))\n+      || !TYPE_PTRMEM_P (TREE_TYPE (arg2)))\n+    {\n+      error_at (loc, \"%<__builtin_is_corresponding_member%> \"\n+\t\t     \"argument is not pointer to member\");\n+      return boolean_false_node;\n+    }\n+\n+  if (!TYPE_PTRDATAMEM_P (TREE_TYPE (arg1))\n+      || !TYPE_PTRDATAMEM_P (TREE_TYPE (arg2)))\n+    return boolean_false_node;\n+\n+  tree membertype1 = TREE_TYPE (TREE_TYPE (arg1));\n+  tree basetype1 = TYPE_OFFSET_BASETYPE (TREE_TYPE (arg1));\n+  if (!complete_type_or_else (basetype1, NULL_TREE))\n+    return boolean_false_node;\n+\n+  tree membertype2 = TREE_TYPE (TREE_TYPE (arg2));\n+  tree basetype2 = TYPE_OFFSET_BASETYPE (TREE_TYPE (arg2));\n+  if (!complete_type_or_else (basetype2, NULL_TREE))\n+    return boolean_false_node;\n+\n+  if (!NON_UNION_CLASS_TYPE_P (basetype1)\n+      || !NON_UNION_CLASS_TYPE_P (basetype2)\n+      || !std_layout_type_p (basetype1)\n+      || !std_layout_type_p (basetype2))\n+    return boolean_false_node;\n+\n+  /* If the member types aren't layout compatible, then they\n+     can't be corresponding members.  */\n+  if (!layout_compatible_type_p (membertype1, membertype2))\n+    return boolean_false_node;\n+\n+  if (TREE_CODE (arg1) == PTRMEM_CST)\n+    arg1 = cplus_expand_constant (arg1);\n+  if (TREE_CODE (arg2) == PTRMEM_CST)\n+    arg2 = cplus_expand_constant (arg2);\n+\n+  if (null_member_pointer_value_p (arg1)\n+      || null_member_pointer_value_p (arg2))\n+    return boolean_false_node;\n+\n+  if (TREE_CODE (arg1) == INTEGER_CST\n+      && TREE_CODE (arg2) == INTEGER_CST\n+      && !tree_int_cst_equal (arg1, arg2))\n+    return boolean_false_node;\n+\n+  if (TREE_CODE (arg2) == INTEGER_CST\n+      && TREE_CODE (arg1) != INTEGER_CST)\n+    {\n+      std::swap (arg1, arg2);\n+      std::swap (membertype1, membertype2);\n+      std::swap (basetype1, basetype2);\n+    }\n+\n+  tree ret = is_corresponding_member_aggr (loc, basetype1, membertype1, arg1,\n+\t\t\t\t\t   basetype2, membertype2, arg2);\n+  if (TREE_TYPE (ret) == boolean_type_node)\n+    return ret;\n+  /* If both arg1 and arg2 are INTEGER_CSTs, is_corresponding_member_aggr\n+     already returns boolean_{true,false}_node whether those particular\n+     members are corresponding members or not.  Otherwise, if only\n+     one of them is INTEGER_CST (canonicalized to first being INTEGER_CST\n+     above), it returns boolean_false_node if it is certainly not a\n+     corresponding member and otherwise we need to do a runtime check that\n+     those two OFFSET_TYPE offsets are equal.\n+     If neither of the operands is INTEGER_CST, is_corresponding_member_aggr\n+     returns the largest offset at which the members would be corresponding\n+     members, so perform arg1 <= ret && arg1 == arg2 runtime check.  */\n+  gcc_assert (TREE_CODE (arg2) != INTEGER_CST);\n+  if (TREE_CODE (arg1) == INTEGER_CST)\n+    return fold_build2 (EQ_EXPR, boolean_type_node, arg1,\n+\t\t\tfold_convert (TREE_TYPE (arg1), arg2));\n+  ret = fold_build2 (LE_EXPR, boolean_type_node,\n+\t\t     fold_convert (pointer_sized_int_node, arg1),\n+\t\t     fold_convert (pointer_sized_int_node, ret));\n+  return fold_build2 (TRUTH_AND_EXPR, boolean_type_node, ret,\n+\t\t      fold_build2 (EQ_EXPR, boolean_type_node, arg1,\n+\t\t\t\t   fold_convert (TREE_TYPE (arg1), arg2)));\n+}\n+\n /* Actually evaluates the trait.  */\n \n static bool\n@@ -10783,6 +11035,9 @@ trait_expr_value (cp_trait_kind kind, tree type1, tree type2)\n     case CPTK_IS_FINAL:\n       return CLASS_TYPE_P (type1) && CLASSTYPE_FINAL (type1);\n \n+    case CPTK_IS_LAYOUT_COMPATIBLE:\n+      return layout_compatible_type_p (type1, type2);\n+\n     case CPTK_IS_LITERAL_TYPE:\n       return literal_type_p (type1);\n \n@@ -10930,6 +11185,19 @@ finish_trait_expr (location_t loc, cp_trait_kind kind, tree type1, tree type2)\n     case CPTK_IS_SAME_AS:\n       break;\n \n+    case CPTK_IS_LAYOUT_COMPATIBLE:\n+      if (!array_of_unknown_bound_p (type1)\n+\t  && TREE_CODE (type1) != VOID_TYPE\n+\t  && !complete_type_or_else (type1, NULL_TREE))\n+\t/* We already issued an error.  */\n+\treturn error_mark_node;\n+      if (!array_of_unknown_bound_p (type2)\n+\t  && TREE_CODE (type2) != VOID_TYPE\n+\t  && !complete_type_or_else (type2, NULL_TREE))\n+\t/* We already issued an error.  */\n+\treturn error_mark_node;\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "3c62dd74380146ee7ec045f1bca04bfd5e310c34", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -455,6 +455,7 @@ builtin_valid_in_constant_expr_p (const_tree decl)\n \t  {\n \t  case CP_BUILT_IN_IS_CONSTANT_EVALUATED:\n \t  case CP_BUILT_IN_SOURCE_LOCATION:\n+\t  case CP_BUILT_IN_IS_CORRESPONDING_MEMBER:\n \t  case CP_BUILT_IN_IS_POINTER_INTERCONVERTIBLE_WITH_CLASS:\n \t    return true;\n \t  default:"}, {"sha": "a46c6d2340dd67556699c6db3b2e8f0c94e62016", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -1621,6 +1621,176 @@ similar_type_p (tree type1, tree type2)\n   return false;\n }\n \n+/* Helper function for layout_compatible_type_p and\n+   is_corresponding_member_aggr.  Advance to next members (NULL if\n+   no further ones) and return true if those members are still part of\n+   the common initial sequence.  */\n+\n+bool\n+next_common_initial_seqence (tree &memb1, tree &memb2)\n+{\n+  while (memb1)\n+    {\n+      if (TREE_CODE (memb1) != FIELD_DECL\n+\t  || (DECL_FIELD_IS_BASE (memb1) && is_empty_field (memb1)))\n+\t{\n+\t  memb1 = DECL_CHAIN (memb1);\n+\t  continue;\n+\t}\n+      if (DECL_FIELD_IS_BASE (memb1))\n+\t{\n+\t  memb1 = TYPE_FIELDS (TREE_TYPE (memb1));\n+\t  continue;\n+\t}\n+      break;\n+    }\n+  while (memb2)\n+    {\n+      if (TREE_CODE (memb2) != FIELD_DECL\n+\t  || (DECL_FIELD_IS_BASE (memb2) && is_empty_field (memb2)))\n+\t{\n+\t  memb2 = DECL_CHAIN (memb2);\n+\t  continue;\n+\t}\n+      if (DECL_FIELD_IS_BASE (memb2))\n+\t{\n+\t  memb2 = TYPE_FIELDS (TREE_TYPE (memb2));\n+\t  continue;\n+\t}\n+      break;\n+    }\n+  if (memb1 == NULL_TREE && memb2 == NULL_TREE)\n+    return true;\n+  if (memb1 == NULL_TREE || memb2 == NULL_TREE)\n+    return false;\n+  if (DECL_BIT_FIELD_TYPE (memb1))\n+    {\n+      if (!DECL_BIT_FIELD_TYPE (memb2))\n+\treturn false;\n+      if (!layout_compatible_type_p (DECL_BIT_FIELD_TYPE (memb1),\n+\t\t\t\t     DECL_BIT_FIELD_TYPE (memb2)))\n+\treturn false;\n+      if (TYPE_PRECISION (TREE_TYPE (memb1))\n+\t  != TYPE_PRECISION (TREE_TYPE (memb2)))\n+\treturn false;\n+    }\n+  else if (DECL_BIT_FIELD_TYPE (memb2))\n+    return false;\n+  else if (!layout_compatible_type_p (TREE_TYPE (memb1), TREE_TYPE (memb2)))\n+    return false;\n+  if ((!lookup_attribute (\"no_unique_address\", DECL_ATTRIBUTES (memb1)))\n+      != !lookup_attribute (\"no_unique_address\", DECL_ATTRIBUTES (memb2)))\n+    return false;\n+  if (!tree_int_cst_equal (bit_position (memb1), bit_position (memb2)))\n+    return false;\n+  return true;\n+}\n+\n+/* Return true if TYPE1 and TYPE2 are layout-compatible types.  */\n+\n+bool\n+layout_compatible_type_p (tree type1, tree type2)\n+{\n+  if (type1 == error_mark_node || type2 == error_mark_node)\n+    return false;\n+  if (type1 == type2)\n+    return true;\n+  if (TREE_CODE (type1) != TREE_CODE (type2))\n+    return false;\n+\n+  type1 = cp_build_qualified_type (type1, TYPE_UNQUALIFIED);\n+  type2 = cp_build_qualified_type (type2, TYPE_UNQUALIFIED);\n+\n+  if (TREE_CODE (type1) == ENUMERAL_TYPE)\n+    return (TYPE_ALIGN (type1) == TYPE_ALIGN (type2)\n+\t    && tree_int_cst_equal (TYPE_SIZE (type1), TYPE_SIZE (type2))\n+\t    && same_type_p (finish_underlying_type (type1),\n+\t\t\t    finish_underlying_type (type2)));\n+\n+  if (CLASS_TYPE_P (type1)\n+      && std_layout_type_p (type1)\n+      && std_layout_type_p (type2)\n+      && TYPE_ALIGN (type1) == TYPE_ALIGN (type2)\n+      && tree_int_cst_equal (TYPE_SIZE (type1), TYPE_SIZE (type2)))\n+    {\n+      tree field1 = TYPE_FIELDS (type1);\n+      tree field2 = TYPE_FIELDS (type2);\n+      if (TREE_CODE (type1) == RECORD_TYPE)\n+\t{\n+\t  while (1)\n+\t    {\n+\t      if (!next_common_initial_seqence (field1, field2))\n+\t\treturn false;\n+\t      if (field1 == NULL_TREE)\n+\t\treturn true;\n+\t      field1 = DECL_CHAIN (field1);\n+\t      field2 = DECL_CHAIN (field2);\n+\t    }\n+\t}\n+      /* Otherwise both types must be union types.\n+\t The standard says:\n+\t \"Two standard-layout unions are layout-compatible if they have\n+\t the same number of non-static data members and corresponding\n+\t non-static data members (in any order) have layout-compatible\n+\t types.\"\n+\t but the code anticipates that bitfield vs. non-bitfield,\n+\t different bitfield widths or presence/absence of\n+\t [[no_unique_address]] should be checked as well.  */\n+      auto_vec<tree, 16> vec;\n+      unsigned int count = 0;\n+      for (; field1; field1 = DECL_CHAIN (field1))\n+\tif (TREE_CODE (field1) == FIELD_DECL)\n+\t  count++;\n+      for (; field2; field2 = DECL_CHAIN (field2))\n+\tif (TREE_CODE (field2) == FIELD_DECL)\n+\t  vec.safe_push (field2);\n+      /* Discussions on core lean towards treating multiple union fields\n+\t of the same type as the same field, so this might need changing\n+\t in the future.  */\n+      if (count != vec.length ())\n+\treturn false;\n+      for (field1 = TYPE_FIELDS (type1); field1; field1 = DECL_CHAIN (field1))\n+\t{\n+\t  if (TREE_CODE (field1) != FIELD_DECL)\n+\t    continue;\n+\t  unsigned int j;\n+\t  tree t1 = DECL_BIT_FIELD_TYPE (field1);\n+\t  if (t1 == NULL_TREE)\n+\t    t1 = TREE_TYPE (field1);\n+\t  FOR_EACH_VEC_ELT (vec, j, field2)\n+\t    {\n+\t      tree t2 = DECL_BIT_FIELD_TYPE (field2);\n+\t      if (t2 == NULL_TREE)\n+\t\tt2 = TREE_TYPE (field2);\n+\t      if (DECL_BIT_FIELD_TYPE (field1))\n+\t\t{\n+\t\t  if (!DECL_BIT_FIELD_TYPE (field2))\n+\t\t    continue;\n+\t\t  if (TYPE_PRECISION (TREE_TYPE (field1))\n+\t\t      != TYPE_PRECISION (TREE_TYPE (field2)))\n+\t\t    continue;\n+\t\t}\n+\t      else if (DECL_BIT_FIELD_TYPE (field2))\n+\t\tcontinue;\n+\t      if (!layout_compatible_type_p (t1, t2))\n+\t\tcontinue;\n+\t      if ((!lookup_attribute (\"no_unique_address\",\n+\t\t\t\t      DECL_ATTRIBUTES (field1)))\n+\t\t  != !lookup_attribute (\"no_unique_address\",\n+\t\t\t\t\tDECL_ATTRIBUTES (field2)))\n+\t\tcontinue;\n+\t      break;\n+\t    }\n+\t  if (j == vec.length ())\n+\t    return false;\n+\t  vec.unordered_remove (j);\n+\t}\n+      return true;\n+    }\n+\n+  return same_type_p (type1, type2);\n+}\n+\n /* Returns 1 if TYPE1 is at least as qualified as TYPE2.  */\n \n bool"}, {"sha": "dd14c44e73d624dfa1162ec42e7c725cd1c78eee", "filename": "gcc/testsuite/g++.dg/cpp2a/is-corresponding-member1.C", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member1.C?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -0,0 +1,61 @@\n+// P0466R5\n+// { dg-do compile { target c++20 } }\n+\n+namespace std\n+{\n+template <class S1, class S2, class M1, class M2>\n+constexpr bool\n+is_corresponding_member (M1 S1::*m1, M2 S2::*m2) noexcept\n+{\n+  return __builtin_is_corresponding_member (m1, m2);\n+}\n+}\n+\n+struct A { int a; };\n+struct B { const int b; };\n+struct C { int a; unsigned int b; int f; A c; int : 0; int d; double e; };\n+struct D { const int x; unsigned int y; int g; B z; int u; double w; };\n+struct E { int a; [[no_unique_address]] int b; };\n+struct F { int c; const int d; };\n+struct G { double a; int b; double c; };\n+struct H { const volatile double d; int e : 16; double f; };\n+struct I { const double g; int h : 15; const double i; };\n+struct J : public A {};\n+struct K {};\n+struct L : public K, public B {};\n+union U { int a; };\n+struct V { void foo () {}; };\n+struct W { int a; private: int b; public: int c; };\n+struct Z : public A, public B {};\n+\n+static_assert (std::is_corresponding_member (&A::a, &A::a));\n+static_assert (std::is_corresponding_member (&A::a, &B::b));\n+static_assert (std::is_corresponding_member (&C::a, &D::x));\n+static_assert (std::is_corresponding_member (&C::b, &D::y));\n+static_assert (std::is_corresponding_member (&C::f, &D::g));\n+static_assert (std::is_corresponding_member (&C::c, &D::z));\n+static_assert (!std::is_corresponding_member (&C::d, &D::u));\n+static_assert (!std::is_corresponding_member (&C::e, &D::w));\n+static_assert (!std::is_corresponding_member (&C::f, &D::x));\n+static_assert (!std::is_corresponding_member (&C::a, &D::g));\n+static_assert (std::is_corresponding_member (&E::a, &F::c));\n+static_assert (!std::is_corresponding_member (&E::b, &F::d));\n+static_assert (std::is_corresponding_member (&G::a, &H::d));\n+static_assert (!std::is_corresponding_member (&G::c, &H::f));\n+static_assert (std::is_corresponding_member (&H::d, &I::g));\n+static_assert (!std::is_corresponding_member (&H::f, &I::i));\n+static_assert (std::is_corresponding_member (&J::a, &B::b));\n+static_assert (std::is_corresponding_member<J, B, int, const int> (&J::a, &B::b));\n+static_assert (std::is_corresponding_member (&J::a, &L::b));\n+static_assert (std::is_corresponding_member<J, L, int, const int> (&J::a, &L::b));\n+static_assert (std::is_corresponding_member (&L::b, &B::b));\n+static_assert (std::is_corresponding_member<L, B, const int, const int> (&L::b, &B::b));\n+static_assert (!std::is_corresponding_member (&U::a, &U::a));\n+static_assert (!std::is_corresponding_member (&A::a, (int A::*) nullptr));\n+static_assert (!std::is_corresponding_member ((int A::*) nullptr, &A::a));\n+static_assert (!std::is_corresponding_member ((int A::*) nullptr, (int A::*) nullptr));\n+static_assert (!std::is_corresponding_member (&V::foo, &V::foo));\n+static_assert (!std::is_corresponding_member (&W::a, &W::a));\n+static_assert (!std::is_corresponding_member (&W::c, &W::c));\n+static_assert (std::is_corresponding_member (&Z::a, &Z::b));\n+static_assert (!std::is_corresponding_member<Z, Z, int, const int> (&Z::a, &Z::b));"}, {"sha": "1cedbcb7dc45e3582a515703d525f50fac44d903", "filename": "gcc/testsuite/g++.dg/cpp2a/is-corresponding-member2.C", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member2.C?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -0,0 +1,158 @@\n+// P0466R5\n+// { dg-do run { target c++20 } }\n+\n+namespace std\n+{\n+template <class S1, class S2, class M1, class M2>\n+constexpr bool\n+is_corresponding_member (M1 S1::*m1, M2 S2::*m2) noexcept\n+{\n+  return __builtin_is_corresponding_member (m1, m2);\n+}\n+}\n+\n+struct A { int a; };\n+struct B { const int b; };\n+struct C { int a; unsigned int b; int f; A c; int : 0; int d; double e; };\n+struct D { const int x; unsigned int y; int g; B z; int u; double w; };\n+struct E { int a; [[no_unique_address]] int b; };\n+struct F { int c; const int d; };\n+struct G { double a; int b; double c; };\n+struct H { const volatile double d; int e : 16; double f; };\n+struct I { const double g; int h : 15; const double i; };\n+struct J : public A {};\n+struct K {};\n+struct L : public K, public B {};\n+union U { int a; };\n+struct V { void foo () {}; };\n+struct W { int a; private: int b; public: int c; };\n+struct Z : public A, public B {};\n+\n+int\n+main ()\n+{\n+  auto t1 = &A::a;\n+  auto t2 = &A::a;\n+  if (!std::is_corresponding_member (t1, t2))\n+    __builtin_abort ();\n+  auto t3 = &A::a;\n+  auto t4 = &B::b;\n+  if (!std::is_corresponding_member (t3, t4))\n+    __builtin_abort ();\n+  auto t5 = &C::a;\n+  auto t6 = &D::x;\n+  if (!std::is_corresponding_member (t5, t6))\n+    __builtin_abort ();\n+  auto t9 = &C::b;\n+  auto t10 = &D::y;\n+  if (!std::is_corresponding_member (t9, t10))\n+    __builtin_abort ();\n+  auto t11 = &C::f;\n+  auto t12 = &D::g;\n+  if (!std::is_corresponding_member (t11, t12))\n+    __builtin_abort ();\n+  auto t13 = &C::c;\n+  auto t14 = &D::z;\n+  if (!std::is_corresponding_member (t13, t14))\n+    __builtin_abort ();\n+  auto t15 = &C::d;\n+  auto t16 = &D::u;\n+  if (std::is_corresponding_member (t15, t16))\n+    __builtin_abort ();\n+  auto t17 = &C::e;\n+  auto t18 = &D::w;\n+  if (std::is_corresponding_member (t17, t18))\n+    __builtin_abort ();\n+  auto t19 = &C::f;\n+  auto t20 = &D::x;\n+  if (std::is_corresponding_member (t19, t20))\n+    __builtin_abort ();\n+  auto t21 = &C::a;\n+  auto t22 = &D::g;\n+  if (std::is_corresponding_member (t21, t22))\n+    __builtin_abort ();\n+  auto t23 = &E::a;\n+  auto t24 = &F::c;\n+  if (!std::is_corresponding_member (t23, t24))\n+    __builtin_abort ();\n+  auto t25 = &E::b;\n+  auto t26 = &F::d;\n+  if (std::is_corresponding_member (t25, t26))\n+    __builtin_abort ();\n+  auto t27 = &G::a;\n+  auto t28 = &H::d;\n+  if (!std::is_corresponding_member (t27, t28))\n+    __builtin_abort ();\n+  auto t29 = &G::c;\n+  auto t30 = &H::f;\n+  if (std::is_corresponding_member (t29, t30))\n+    __builtin_abort ();\n+  auto t31 = &H::d;\n+  auto t32 = &I::g;\n+  if (!std::is_corresponding_member (t31, t32))\n+    __builtin_abort ();\n+  auto t33 = &H::f;\n+  auto t34 = &I::i;\n+  if (std::is_corresponding_member (t33, t34))\n+    __builtin_abort ();\n+  auto t35 = &J::a;\n+  auto t36 = &B::b;\n+  if (!std::is_corresponding_member (t35, t36))\n+    __builtin_abort ();\n+  int J::*t37 = &J::a;\n+  const int B::*t38 = &B::b;\n+  if (!std::is_corresponding_member (t37, t38))\n+    __builtin_abort ();\n+  auto t39 = &J::a;\n+  auto t40 = &L::b;\n+  if (!std::is_corresponding_member (t39, t40))\n+    __builtin_abort ();\n+  int J::*t41 = &J::a;\n+  const int L::*t42 = &L::b;\n+  if (!std::is_corresponding_member (t41, t42))\n+    __builtin_abort ();\n+  auto t43 = &L::b;\n+  auto t44 = &B::b;\n+  if (!std::is_corresponding_member (t43, t44))\n+    __builtin_abort ();\n+  const int L::*t45 = &L::b;\n+  const int B::*t46 = &B::b;\n+  if (!std::is_corresponding_member (t45, t46))\n+    __builtin_abort ();\n+  auto t47 = &U::a;\n+  auto t48 = &U::a;\n+  if (std::is_corresponding_member (t47, t48))\n+    __builtin_abort ();\n+  auto t49 = &A::a;\n+  auto t50 = (int A::*) nullptr;\n+  if (std::is_corresponding_member (t49, t50))\n+    __builtin_abort ();\n+  auto t51 = (int A::*) nullptr;\n+  auto t52 = &A::a;\n+  if (std::is_corresponding_member (t51, t52))\n+    __builtin_abort ();\n+  auto t53 = (int A::*) nullptr;\n+  auto t54 = (int A::*) nullptr;\n+  if (std::is_corresponding_member (t53, t54))\n+    __builtin_abort ();\n+  auto t55 = &V::foo;\n+  auto t56 = &V::foo;\n+  if (std::is_corresponding_member (t55, t56))\n+    __builtin_abort ();\n+  auto t57 = &W::a;\n+  auto t58 = &W::a;\n+  if (std::is_corresponding_member (t57, t58))\n+    __builtin_abort ();\n+  auto t59 = &W::c;\n+  auto t60 = &W::c;\n+  if (std::is_corresponding_member (t59, t60))\n+    __builtin_abort ();\n+  auto t61 = &Z::a;\n+  auto t62 = &Z::b;\n+  if (!std::is_corresponding_member (t61, t62))\n+    __builtin_abort ();\n+  int Z::*t63 = &Z::a;\n+  const int Z::*t64 = &Z::b;\n+  if (std::is_corresponding_member (t63, t64))\n+    __builtin_abort ();\n+}"}, {"sha": "1ff510c8146b2bdd80963173035d998017ef0610", "filename": "gcc/testsuite/g++.dg/cpp2a/is-corresponding-member3.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member3.C?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -0,0 +1,14 @@\n+// P0466R5\n+// { dg-do compile { target c++20 } }\n+\n+struct A { int a; };\n+struct B;\n+\n+bool a = __builtin_is_corresponding_member ();\t\t\t// { dg-error \"needs two arguments\" }\n+bool b = __builtin_is_corresponding_member (&A::a);\t\t// { dg-error \"needs two arguments\" }\n+bool c = __builtin_is_corresponding_member (&A::a, &A::a, &A::a);\t// { dg-error \"needs two arguments\" }\n+bool d = __builtin_is_corresponding_member (&A::a, 1);\t\t\t// { dg-error \"argument is not pointer to member\" }\n+bool e = __builtin_is_corresponding_member (1.0, &A::a);\t\t// { dg-error \"argument is not pointer to member\" }\n+bool f = __builtin_is_corresponding_member (1, A{});\t\t// { dg-error \"argument is not pointer to member\" }\n+bool g = __builtin_is_corresponding_member (&A::a, (int B::*) nullptr);\t// { dg-error \"invalid use of incomplete type\" }\n+bool h = __builtin_is_corresponding_member ((int B::*) nullptr, &A::a);\t// { dg-error \"invalid use of incomplete type\" }"}, {"sha": "6b74090306b301b530085abbca371c7615236b0f", "filename": "gcc/testsuite/g++.dg/cpp2a/is-corresponding-member4.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member4.C?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -0,0 +1,25 @@\n+// P0466R5\n+// { dg-do compile { target c++20 } }\n+\n+namespace std\n+{\n+template <class S1, class S2, class M1, class M2>\n+constexpr bool\n+is_corresponding_member (M1 S1::*m1, M2 S2::*m2) noexcept\n+{\n+  return __builtin_is_corresponding_member (m1, m2);\t// { dg-error \"invalid use of incomplete type 'struct B'\" }\n+}\n+}\n+\n+struct A { int a; };\n+struct B;\n+constexpr int B::*n = nullptr;\n+constexpr auto a = std::is_corresponding_member (&A::a, n);\t// { dg-error \"invalid use of incomplete type 'struct B'\" }\n+constexpr auto b = std::is_corresponding_member (n, &A::a);\t// { dg-error \"invalid use of incomplete type 'struct B'\" }\n+\n+void\n+foo (int B::*m)\n+{\n+  std::is_corresponding_member (&A::a, m);\n+  std::is_corresponding_member (m, &A::a);\n+}"}, {"sha": "b95630959b23c3f6c841c488d852d741687e92d3", "filename": "gcc/testsuite/g++.dg/cpp2a/is-corresponding-member5.C", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member5.C?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -0,0 +1,95 @@\n+// P0466R5\n+// { dg-do run { target c++20 } }\n+\n+namespace std\n+{\n+template <class S1, class S2, class M1, class M2>\n+constexpr bool\n+is_corresponding_member (M1 S1::*m1, M2 S2::*m2) noexcept\n+{\n+  return __builtin_is_corresponding_member (m1, m2);\n+}\n+}\n+\n+struct S {};\n+struct T {};\n+struct I { int a; };\n+struct alignas(16) J { const int b; };\n+struct K { char b; char s[15]; I c; short d; };\n+struct L { char d; char t[15]; J e; short f; };\n+struct U { int a0; [[no_unique_address]] S a1; [[no_unique_address]] S a2; [[no_unique_address]] S a3; short a4; };\n+struct V { int b0; [[no_unique_address]] S b1; [[no_unique_address]] T b2; [[no_unique_address]] S b3; short b4; };\n+struct U1 { int a0; [[no_unique_address]] S a1; [[no_unique_address]] S a2; [[no_unique_address]] S a3; short a4; };\n+struct V1 { int b0; [[no_unique_address]] S b1; [[no_unique_address]] T b2; [[no_unique_address]] S b3; short b4; };\n+struct A { int a; union { short b; long c; }; int d; signed char e; int f; };\n+struct B { const int a; union { signed long b; short c; }; volatile int d; unsigned char e; int f; };\n+struct A1 { int a; union { short b; long c; }; int d; short e; int f; };\n+struct B1 { const int a; union { signed long b; short c; }; volatile int d; unsigned short e; int f; };\n+\n+static_assert (std::is_corresponding_member (&I::a, &J::b));\n+static_assert (std::is_corresponding_member (&K::b, &L::d));\n+static_assert (!std::is_corresponding_member (&K::c, &L::e));\n+static_assert (std::is_corresponding_member (&U::a0, &V::b0));\n+static_assert (!std::is_corresponding_member (&U::a4, &V::b4));\n+static_assert (std::is_corresponding_member (&A::a, &B::a));\n+static_assert (std::is_corresponding_member (&A::d, &B::d));\n+static_assert (!std::is_corresponding_member (&A::e, &B::e));\n+static_assert (!std::is_corresponding_member (&A::f, &B::f));\n+static_assert (!std::is_corresponding_member (&A::a, &B::f));\n+static_assert (!std::is_corresponding_member (&A::d, &B::a));\n+static_assert (!std::is_corresponding_member (&A::a, &B::d));\n+static_assert (!std::is_corresponding_member (&A::f, &B::a));\n+static_assert (!std::is_corresponding_member (&A1::e, &B1::e));\n+\n+int\n+main ()\n+{\n+  auto t1 = &I::a;\n+  auto t2 = &J::b;\n+  if (!std::is_corresponding_member (t1, t2))\n+    __builtin_abort ();\n+  auto t3 = &K::b;\n+  auto t4 = &L::d;\n+  if (!std::is_corresponding_member (t3, t4))\n+    __builtin_abort ();\n+  auto t5 = &K::c;\n+  auto t6 = &L::e;\n+  if (std::is_corresponding_member (t5, t6))\n+    __builtin_abort ();\n+  auto t7 = &U::a0;\n+  auto t8 = &V::b0;\n+  if (!std::is_corresponding_member (t7, t8))\n+    __builtin_abort ();\n+  auto t9 = &U::a4;\n+  auto t10 = &V::b4;\n+  if (std::is_corresponding_member (t9, t10))\n+    __builtin_abort ();\n+  auto t11 = &A::a;\n+  auto t12 = &B::a;\n+  auto t13 = &A::d;\n+  auto t14 = &B::d;\n+  auto t15 = &A::e;\n+  auto t16 = &B::e;\n+  auto t17 = &A::f;\n+  auto t18 = &B::f;\n+  if (!std::is_corresponding_member (t11, t12))\n+    __builtin_abort ();\n+  if (!std::is_corresponding_member (t13, t14))\n+    __builtin_abort ();\n+  if (std::is_corresponding_member (t15, t16))\n+    __builtin_abort ();\n+  if (std::is_corresponding_member (t17, t18))\n+    __builtin_abort ();\n+  if (std::is_corresponding_member (t11, t18))\n+    __builtin_abort ();\n+  if (std::is_corresponding_member (t13, t12))\n+    __builtin_abort ();\n+  if (std::is_corresponding_member (t11, t14))\n+    __builtin_abort ();\n+  if (std::is_corresponding_member (t17, t12))\n+    __builtin_abort ();\n+  auto t19 = &A1::e;\n+  auto t20 = &B1::e;\n+  if (std::is_corresponding_member (t19, t20))\n+    __builtin_abort ();\n+}"}, {"sha": "e4f53bbe5ca0ce5d012c2a22c9523db1dfb2dc5a", "filename": "gcc/testsuite/g++.dg/cpp2a/is-corresponding-member6.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member6.C?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -0,0 +1,34 @@\n+// P0466R5\n+// { dg-do compile { target c++20 } }\n+\n+namespace std\n+{\n+template <class S1, class S2, class M1, class M2>\n+constexpr bool\n+is_corresponding_member (M1 S1::*m1, M2 S2::*m2) noexcept\n+{\n+  return __builtin_is_corresponding_member (m1, m2);\n+}\n+// { dg-message \"'__builtin_is_corresponding_member' not well defined for anonymous unions\" \"\" { target *-*-* } .-2 }\n+}\n+\n+struct S {};\n+struct T {};\n+struct I { int a; };\n+struct alignas(16) J { const int b; };\n+struct K { char b; char s[15]; alignas(16) I c; short d; };\n+struct L { char d; char t[15]; J e; short f; };\n+struct U { int a0; [[no_unique_address]] S a1; [[no_unique_address]] S a2; [[no_unique_address]] S a3; short a4; };\n+struct V { int b0; [[no_unique_address]] S b1; [[no_unique_address]] T b2; [[no_unique_address]] S b3; short b4; };\n+struct U1 { int a0; [[no_unique_address]] S a1; [[no_unique_address]] S a2; [[no_unique_address]] S a3; short a4; };\n+struct V1 { int b0; [[no_unique_address]] S b1; [[no_unique_address]] T b2; [[no_unique_address]] S b3; short b4; };\n+struct A { int a; union { short b; long c; }; int d; signed char e; int f; };\n+struct B { const int a; union { signed long b; short c; }; volatile int d; unsigned char e; int f; };\n+\n+static_assert (!std::is_corresponding_member (&K::d, &L::f));\n+static_assert (std::is_corresponding_member (&U::a1, &V::b1));\n+static_assert (!std::is_corresponding_member (&U::a2, &V::b2));\n+static_assert (!std::is_corresponding_member (&U::a3, &V::b3));\n+static_assert (!std::is_corresponding_member (&U1::a3, &V1::b3));\n+static_assert (!std::is_corresponding_member (&A::b, &B::c));\n+constexpr auto a = std::is_corresponding_member (&A::c, &B::b);\t\t// { dg-message \"required from here\" }"}, {"sha": "602ca012775c8dbea1b4e40f9d24d01ad3fb1f70", "filename": "gcc/testsuite/g++.dg/cpp2a/is-corresponding-member7.C", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member7.C?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -0,0 +1,71 @@\n+// P0466R5\n+// { dg-do run { target c++20 } }\n+// { dg-options \"\" }\n+\n+namespace std\n+{\n+template <class S1, class S2, class M1, class M2>\n+constexpr bool\n+is_corresponding_member (M1 S1::*m1, M2 S2::*m2) noexcept\n+{\n+  return __builtin_is_corresponding_member (m1, m2);\n+}\n+}\n+\n+struct A { int a; struct { int b; short c; long d; }; int : 0; int e; };\n+struct B { const signed int a; struct { int b; signed short c; signed long d; }; volatile int e; };\n+struct C { int a; union { struct { short b; long c; }; long d; short e; }; signed int f; };\n+struct D { int a; union { long b; short c; struct { short d; signed long e; }; }; int f; };\n+\n+static_assert (std::is_corresponding_member (&A::a, &B::a));\n+static_assert (std::is_corresponding_member (&A::b, &B::b));\n+static_assert (std::is_corresponding_member (&A::c, &B::c));\n+static_assert (std::is_corresponding_member (&A::d, &B::d));\n+static_assert (!std::is_corresponding_member (&A::e, &B::e));\n+static_assert (!std::is_corresponding_member (&A::a, &B::b));\n+static_assert (!std::is_corresponding_member (&A::b, &B::a));\n+static_assert (std::is_corresponding_member (&C::a, &D::a));\n+static_assert (std::is_corresponding_member (&C::f, &D::f));\n+static_assert (!std::is_corresponding_member (&C::a, &D::f));\n+static_assert (!std::is_corresponding_member (&C::f, &D::a));\n+\n+int\n+main ()\n+{\n+  auto t1 = &A::a;\n+  auto t2 = &B::a;\n+  auto t3 = &A::b;\n+  auto t4 = &B::b;\n+  auto t5 = &A::c;\n+  auto t6 = &B::c;\n+  auto t7 = &A::d;\n+  auto t8 = &B::d;\n+  auto t9 = &A::e;\n+  auto t10 = &B::e;\n+  if (!std::is_corresponding_member (t1, t2))\n+    __builtin_abort ();\n+  if (!std::is_corresponding_member (t3, t4))\n+    __builtin_abort ();\n+  if (!std::is_corresponding_member (t5, t6))\n+    __builtin_abort ();\n+  if (!std::is_corresponding_member (t7, t8))\n+    __builtin_abort ();\n+  if (std::is_corresponding_member (t9, t10))\n+    __builtin_abort ();\n+  if (std::is_corresponding_member (t1, t4))\n+    __builtin_abort ();\n+  if (std::is_corresponding_member (t3, t2))\n+    __builtin_abort ();\n+  auto t11 = &C::a;\n+  auto t12 = &D::a;\n+  auto t13 = &C::f;\n+  auto t14 = &D::f;\n+  if (!std::is_corresponding_member (t11, t12))\n+    __builtin_abort ();\n+  if (!std::is_corresponding_member (t13, t14))\n+    __builtin_abort ();\n+  if (std::is_corresponding_member (t11, t14))\n+    __builtin_abort ();\n+  if (std::is_corresponding_member (t13, t12))\n+    __builtin_abort ();\n+}"}, {"sha": "1a33908627dd1d63517191aec1bc5f05aed05958", "filename": "gcc/testsuite/g++.dg/cpp2a/is-corresponding-member8.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-corresponding-member8.C?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -0,0 +1,25 @@\n+// P0466R5\n+// { dg-do compile { target c++20 } }\n+// { dg-options \"\" }\n+\n+namespace std\n+{\n+template <class S1, class S2, class M1, class M2>\n+constexpr bool\n+is_corresponding_member (M1 S1::*m1, M2 S2::*m2) noexcept\n+{\n+  return __builtin_is_corresponding_member (m1, m2);\n+}\n+// { dg-message \"'__builtin_is_corresponding_member' not well defined for anonymous unions\" \"\" { target *-*-* } .-2 }\n+}\n+\n+struct A { int a; struct { short b; short c; long d; }; int : 0; int e; };\n+struct B { const signed int a; struct alignas(16) { short b; signed short c; signed long d; }; volatile int e; };\n+struct C { int a; union { struct { int b; long c; }; long d; short e; }; signed int f; };\n+struct D { int a; union { long b; short c; struct { int d; signed long e; }; }; int f; };\n+\n+static_assert (std::is_corresponding_member (&A::a, &B::a));\n+static_assert (!std::is_corresponding_member (&A::b, &B::b));\n+static_assert (!std::is_corresponding_member (&A::c, &B::c));\n+static_assert (!std::is_corresponding_member (&A::d, &B::d));\n+auto a = std::is_corresponding_member (&C::a, &D::a);\t\t// { dg-message \"required from here\" }"}, {"sha": "dbc2a9a93eb2e901b7f702d3793f533fb4b12556", "filename": "gcc/testsuite/g++.dg/cpp2a/is-layout-compatible1.C", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-layout-compatible1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-layout-compatible1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-layout-compatible1.C?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -0,0 +1,80 @@\n+// P0466R5\n+// { dg-do compile { target c++20 } }\n+\n+namespace std\n+{\n+template <typename T, T v>\n+struct integral_constant\n+{\n+  static constexpr T value = v;\n+};\n+\n+template <typename, typename>\n+struct is_layout_compatible;\n+\n+template<typename T, typename U>\n+struct is_layout_compatible\n+  : public integral_constant <bool, __is_layout_compatible (T, U)>\n+{\n+};\n+\n+template <typename T, typename U>\n+inline constexpr bool is_layout_compatible_v = __is_layout_compatible (T, U);\n+}\n+\n+struct A { int a; char b; };\n+struct B { const int c; volatile char d; };\n+struct C { int a : 1; int : 7; int : 0; int b : 2; };\n+struct D { int : 1; int c : 7; int : 0; int : 2; };\n+struct E { int f : 1; int : 7; int g : 2; };\n+struct F { int a; signed char b; };\n+union G { int a; long long b; signed char c; unsigned char d; int e; };\n+union H { long long f; unsigned char g; int h; int i; signed char j; };\n+struct I : public A {};\n+struct J {};\n+struct K : public J {};\n+struct L {};\n+struct M : public K, L { const int a; volatile char b; };\n+struct N {};\n+struct O : public N, M {};\n+struct P { int a; private: int b; public: int c; };\n+struct Q { int a; private: int b; public: int c; };\n+union U1 { int a; private: int b; public: int c; };\n+union U2 { int a; private: int b; public: int c; };\n+struct S {};\n+struct T {};\n+struct W;\n+struct X;\n+enum E1 : int { E11, E12 };\n+enum E2 : int { E21, E22 };\n+enum E3 : long { E31, E32 };\n+enum E4 { E41, E42 };\n+enum E5 { E51, E52 };\n+\n+static_assert (std::is_layout_compatible<int, const int>::value);\n+static_assert (std::is_layout_compatible_v<double, volatile double>);\n+static_assert (std::is_layout_compatible_v<A, B>);\n+static_assert (std::is_layout_compatible_v<C, D>);\n+static_assert (!std::is_layout_compatible_v<int, unsigned int>);\n+static_assert (!std::is_layout_compatible_v<A, F>);\n+static_assert (std::is_layout_compatible_v<G, H>);\n+static_assert (std::is_layout_compatible_v<S, T>);\n+static_assert (std::is_layout_compatible_v<A[3], A[3]>);\n+static_assert (std::is_layout_compatible_v<A[], A[]>);\n+static_assert (!std::is_layout_compatible_v<S[1], T[1]>);\n+static_assert (std::is_layout_compatible_v<W[], W[]>);\n+static_assert (!std::is_layout_compatible_v<W[], X[]>);\n+static_assert (!std::is_layout_compatible_v<D, E>);\n+static_assert (std::is_layout_compatible_v<void, const void>);\n+static_assert (std::is_layout_compatible_v<I, const A>);\n+static_assert (std::is_layout_compatible_v<volatile A, const I>);\n+static_assert (std::is_layout_compatible_v<M, A>);\n+static_assert (std::is_layout_compatible_v<O, M>);\n+static_assert (std::is_layout_compatible_v<A, O>);\n+static_assert (std::is_layout_compatible_v<P, P>);\n+static_assert (!std::is_layout_compatible_v<P, Q>);\n+static_assert (std::is_layout_compatible_v<U1, U1>);\n+static_assert (!std::is_layout_compatible_v<U1, U2>);\n+static_assert (std::is_layout_compatible_v<E1, E2>);\n+static_assert (!std::is_layout_compatible_v<E1, E3>);\n+static_assert (std::is_layout_compatible_v<E4, E5>);"}, {"sha": "bf902f385a500417591b04b2fddc6b515df780a7", "filename": "gcc/testsuite/g++.dg/cpp2a/is-layout-compatible2.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-layout-compatible2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-layout-compatible2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-layout-compatible2.C?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -0,0 +1,36 @@\n+// P0466R5\n+// { dg-do compile { target c++20 } }\n+\n+namespace std\n+{\n+template <typename T, T v>\n+struct integral_constant\n+{\n+  static constexpr T value = v;\n+};\n+\n+template <typename, typename>\n+struct is_layout_compatible;\n+\n+template<typename T, typename U>\n+struct is_layout_compatible\n+  : public integral_constant <bool, __is_layout_compatible (T, U)>\n+{\n+};\n+\n+template <typename T, typename U>\n+inline constexpr bool is_layout_compatible_v = __is_layout_compatible (T, U);\n+}\n+// { dg-error \"invalid use of incomplete type 'struct W'\" \"\" { target *-*-* } .-2 }\n+// { dg-error \"invalid use of incomplete type 'struct \\[XY]'\" \"\" { target *-*-* } .-3 }\n+// { dg-error \"invalid use of incomplete type 'struct Z'\" \"\" { target *-*-* } .-4 }\n+\n+struct W;\n+struct X;\n+struct Y;\n+struct Z;\n+struct A {};\n+\n+auto a = std::is_layout_compatible_v<W, W>;\n+auto b = std::is_layout_compatible_v<X, Y>;\n+auto c = std::is_layout_compatible_v<A, Z>;"}, {"sha": "c54858746606cf61671d204779637d4a43e34f22", "filename": "gcc/testsuite/g++.dg/cpp2a/is-layout-compatible3.C", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-layout-compatible3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c3a75390623a0470df52af13f78baddd562981/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-layout-compatible3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-layout-compatible3.C?ref=32c3a75390623a0470df52af13f78baddd562981", "patch": "@@ -0,0 +1,64 @@\n+// P0466R5\n+// { dg-do compile { target c++20 } }\n+\n+namespace std\n+{\n+template <typename T, T v>\n+struct integral_constant\n+{\n+  static constexpr T value = v;\n+};\n+\n+template <typename, typename>\n+struct is_layout_compatible;\n+\n+template<typename T, typename U>\n+struct is_layout_compatible\n+  : public integral_constant <bool, __is_layout_compatible (T, U)>\n+{\n+};\n+\n+template <typename T, typename U>\n+inline constexpr bool is_layout_compatible_v = __is_layout_compatible (T, U);\n+}\n+\n+// Weird cases.\n+struct S {};\n+struct T {};\n+struct I { int a; };\n+struct alignas(16) J { const int b; };\n+struct K { I c; int d; };\n+struct L { J e; int f; };\n+union M { I u; };\n+union N { J v; };\n+union O { int a; int b; };\n+union P { int a : 1; int b : 12; };\n+enum Q : int { Q1, Q2 };\n+enum alignas(16) R : int { R1, R2 };\n+struct U { [[no_unique_address]] S a1; [[no_unique_address]] S a2; [[no_unique_address]] S a3; };\n+struct V { [[no_unique_address]] S b1; [[no_unique_address]] T b2; [[no_unique_address]] S b3; };\n+struct alignas(16) A : public I {};\n+struct alignas(16) B {};\n+struct C : public B, public I {};\n+union D { int a : 3; int b : 9; };\n+struct alignas(16) E { alignas(16) int a; alignas(16) int b; };\n+struct alignas(16) F { int c; alignas(16) int d; };\n+union alignas(16) G { int a; alignas(16) short b; };\n+union alignas(16) H { short c; int d; };\n+struct A1 { int a; };\n+struct B1 { signed int b; };\n+struct alignas (16) C1 : public A1 {};\n+struct alignas (16) D1 : public B1 {};\n+\n+static_assert (!std::is_layout_compatible_v<I, J>);\n+static_assert (!std::is_layout_compatible_v<K, L>);\n+static_assert (!std::is_layout_compatible_v<M, N>);\n+static_assert (!std::is_layout_compatible_v<O, P>);\n+static_assert (!std::is_layout_compatible_v<P, D>);\n+static_assert (!std::is_layout_compatible_v<Q, R>);\n+static_assert (!std::is_layout_compatible_v<U, V>);\n+static_assert (!std::is_layout_compatible_v<A, I>);\n+static_assert (!std::is_layout_compatible_v<C, I>);\n+static_assert (std::is_layout_compatible_v<E, F>);\n+static_assert (std::is_layout_compatible_v<G, H>);\n+static_assert (std::is_layout_compatible_v<C1, D1>);"}]}