{"sha": "5f1ec3e625e734ce2d9f8d9f91c458c7766102eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYxZWMzZTYyNWU3MzRjZTJkOWY4ZDlmOTFjNDU4Yzc3NjYxMDJlYg==", "commit": {"author": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1993-10-03T23:54:14Z"}, "committer": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1993-10-03T23:54:14Z"}, "message": "(output_op_from_reg):  Handle 3-word XFmode values.\n\n(output_to_reg): Likewise.\n(output_move_double): Handle XFmode operands.\n(output_move_const_single): Use REAL_VALUE_TO_TARGET_SINGLE.\n(print_operand): Add letter `T', size `12'.  Use REAL_VALUE macros\n to convert floating point operands.\n(convert_387_op):  Add XFmode to case FLOAT_EXTEND.\n\nFrom-SVN: r5571", "tree": {"sha": "6ad12370d336626c36767ac879adfbc218ac7ad8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ad12370d336626c36767ac879adfbc218ac7ad8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f1ec3e625e734ce2d9f8d9f91c458c7766102eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f1ec3e625e734ce2d9f8d9f91c458c7766102eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f1ec3e625e734ce2d9f8d9f91c458c7766102eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f1ec3e625e734ce2d9f8d9f91c458c7766102eb/comments", "author": null, "committer": null, "parents": [{"sha": "357a98f13e96ef395f01ba95aac94c7e3fbd5d6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/357a98f13e96ef395f01ba95aac94c7e3fbd5d6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/357a98f13e96ef395f01ba95aac94c7e3fbd5d6d"}], "stats": {"total": 276, "additions": 221, "deletions": 55}, "files": [{"sha": "a05ca94d07cd39ae05f7e2d08cf741bd2c51e6a2", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 221, "deletions": 55, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f1ec3e625e734ce2d9f8d9f91c458c7766102eb/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f1ec3e625e734ce2d9f8d9f91c458c7766102eb/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5f1ec3e625e734ce2d9f8d9f91c458c7766102eb", "patch": "@@ -98,15 +98,22 @@ output_op_from_reg (src, template)\n      char *template;\n {\n   rtx xops[4];\n+  int size = GET_MODE_SIZE (GET_MODE (src));\n \n   xops[0] = src;\n   xops[1] = AT_SP (Pmode);\n-  xops[2] = GEN_INT (GET_MODE_SIZE (GET_MODE (src)));\n+  xops[2] = GEN_INT (size);\n   xops[3] = stack_pointer_rtx;\n \n-  if (GET_MODE_SIZE (GET_MODE (src)) > UNITS_PER_WORD)\n+  if (size > UNITS_PER_WORD)\n     {\n-      rtx high = gen_rtx (REG, SImode, REGNO (src) + 1);\n+      rtx high;\n+      if (size > 2 * UNITS_PER_WORD)\n+\t{\n+\t  high = gen_rtx (REG, SImode, REGNO (src) + 2);\n+\t  output_asm_insn (AS1 (push%L0,%0), &high);\n+\t}\n+      high = gen_rtx (REG, SImode, REGNO (src) + 1);\n       output_asm_insn (AS1 (push%L0,%0), &high);\n     }\n   output_asm_insn (AS1 (push%L0,%0), &src);\n@@ -127,10 +134,11 @@ output_to_reg (dest, dies)\n      int dies;\n {\n   rtx xops[4];\n+  int size = GET_MODE_SIZE (GET_MODE (dest));\n \n   xops[0] = AT_SP (Pmode);\n   xops[1] = stack_pointer_rtx;\n-  xops[2] = GEN_INT (GET_MODE_SIZE (GET_MODE (dest)));\n+  xops[2] = GEN_INT (size);\n   xops[3] = dest;\n \n   output_asm_insn (AS2 (sub%L1,%2,%1), xops);\n@@ -147,17 +155,27 @@ output_to_reg (dest, dies)\n       if (dies)\n \toutput_asm_insn (AS1 (fstp%z3,%y0), xops);\n       else\n-\toutput_asm_insn (AS1 (fst%z3,%y0), xops);\n+\t{\n+\t  if (GET_MODE (dest) == XFmode)\n+\t    abort ();\n+\t  else\n+\t    output_asm_insn (AS1 (fst%z3,%y0), xops);\n+\t}\n     }\n   else\n     abort ();\n \n   output_asm_insn (AS1 (pop%L0,%0), &dest);\n \n-  if (GET_MODE_SIZE (GET_MODE (dest)) > UNITS_PER_WORD)\n+  if (size > UNITS_PER_WORD)\n     {\n       dest = gen_rtx (REG, SImode, REGNO (dest) + 1);\n       output_asm_insn (AS1 (pop%L0,%0), &dest);\n+      if (size > 2 * UNITS_PER_WORD)\n+\t{\n+\t  dest = gen_rtx (REG, SImode, REGNO (dest) + 1);\n+\t  output_asm_insn (AS1 (pop%L0,%0), &dest);\n+\t}\n     }\n }\n \f\n@@ -243,8 +261,14 @@ output_move_double (operands)\n {\n   enum {REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype0, optype1;\n   rtx latehalf[2];\n+  rtx middlehalf[2];\n+  rtx xops[2];\n   rtx addreg0 = 0, addreg1 = 0;\n   int dest_overlapped_low = 0;\n+  int size = GET_MODE_SIZE (GET_MODE (operands[1]));\n+\n+  middlehalf[0] = 0;\n+  middlehalf[1] = 0;\n \n   /* First classify both operands.  */\n \n@@ -289,16 +313,29 @@ output_move_double (operands)\n \n   if (optype0 == PUSHOP && optype1 == POPOP)\n     {\n+      /* ??? Can this ever happen on i386? */\n       operands[0] = XEXP (XEXP (operands[0], 0), 0);\n-      asm_add (-8, operands[0]);\n-      operands[0] = gen_rtx (MEM, DImode, operands[0]);\n+      asm_add (-size, operands[0]);\n+      if (GET_MODE (operands[1]) == XFmode)\n+        operands[0] = gen_rtx (MEM, XFmode, operands[0]);\n+      else if (GET_MODE (operands[0]) == DFmode)\n+        operands[0] = gen_rtx (MEM, DFmode, operands[0]);\n+      else\n+        operands[0] = gen_rtx (MEM, DImode, operands[0]);\n       optype0 = OFFSOP;\n     }\n+\n   if (optype0 == POPOP && optype1 == PUSHOP)\n     {\n+      /* ??? Can this ever happen on i386? */\n       operands[1] = XEXP (XEXP (operands[1], 0), 0);\n-      asm_add (-8, operands[1]);\n-      operands[1] = gen_rtx (MEM, DImode, operands[1]);\n+      asm_add (-size, operands[1]);\n+      if (GET_MODE (operands[1]) == XFmode)\n+        operands[1] = gen_rtx (MEM, XFmode, operands[1]);\n+      else if (GET_MODE (operands[1]) == DFmode)\n+        operands[1] = gen_rtx (MEM, DFmode, operands[1]);\n+      else\n+        operands[1] = gen_rtx (MEM, DImode, operands[1]);\n       optype1 = OFFSOP;\n     }\n \n@@ -320,31 +357,87 @@ output_move_double (operands)\n      for the high-numbered word and in some cases alter the\n      operands in OPERANDS to be suitable for the low-numbered word.  */\n \n-  if (optype0 == REGOP)\n-    latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n-  else if (optype0 == OFFSOP)\n-    latehalf[0] = adj_offsettable_operand (operands[0], 4);\n-  else\n-    latehalf[0] = operands[0];\n+  if (size == 12)\n+    {\n+      if (optype0 == REGOP)\n+\t{\n+\t  middlehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\t  latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 2);\n+\t}\n+      else if (optype0 == OFFSOP)\n+\t{\n+\t  middlehalf[0] = adj_offsettable_operand (operands[0], 4);\n+\t  latehalf[0] = adj_offsettable_operand (operands[0], 8);\n+\t}\n+      else\n+\t{\n+         middlehalf[0] = operands[0];\n+         latehalf[0] = operands[0];\n+\t}\n+    \n+      if (optype1 == REGOP)\n+\t{\n+          middlehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+          latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 2);\n+\t}\n+      else if (optype1 == OFFSOP)\n+\t{\n+          middlehalf[1] = adj_offsettable_operand (operands[1], 4);\n+          latehalf[1] = adj_offsettable_operand (operands[1], 8);\n+\t}\n+      else if (optype1 == CNSTOP)\n+\t{\n+\t  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    {\n+\t      REAL_VALUE_TYPE r; long l[3];\n \n-  if (optype1 == REGOP)\n-    latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n-  else if (optype1 == OFFSOP)\n-    latehalf[1] = adj_offsettable_operand (operands[1], 4);\n-  else if (optype1 == CNSTOP)\n+\t      REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+\t      REAL_VALUE_TO_TARGET_LONG_DOUBLE (r, l);\n+\t      operands[1] = GEN_INT (l[0]);\n+\t      middlehalf[1] = GEN_INT (l[1]);\n+\t      latehalf[1] = GEN_INT (l[2]);\n+\t    }\n+\t  else if (CONSTANT_P (operands[1]))\n+\t    /* No non-CONST_DOUBLE constant should ever appear here.  */\n+\t    abort ();\n+        }\n+      else\n+\t{\n+\t  middlehalf[1] = operands[1];\n+\t  latehalf[1] = operands[1];\n+\t}\n+    }\n+  else /* size is not 12: */\n     {\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\tsplit_double (operands[1], &operands[1], &latehalf[1]);\n-      else if (CONSTANT_P (operands[1]))\n+      if (optype0 == REGOP)\n+\tlatehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+      else if (optype0 == OFFSOP)\n+\tlatehalf[0] = adj_offsettable_operand (operands[0], 4);\n+      else\n+\tlatehalf[0] = operands[0];\n+\n+      if (optype1 == REGOP)\n+\tlatehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+      else if (optype1 == OFFSOP)\n+\tlatehalf[1] = adj_offsettable_operand (operands[1], 4);\n+      else if (optype1 == CNSTOP)\n \t{\n-\t  if (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) < 0)\n-\t    latehalf[1] = constm1_rtx;\n-\t  else\n-\t    latehalf[1] = const0_rtx;\n+\t  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    split_double (operands[1], &operands[1], &latehalf[1]);\n+\t  else if (CONSTANT_P (operands[1]))\n+\t    {\n+\t      /* ??? jrv: Can this really happen?  A DImode constant\n+\t\t that isn't a CONST_DOUBLE? */\n+\t      if (GET_CODE (operands[1]) == CONST_INT\n+\t\t  && INTVAL (operands[1]) < 0)\n+\t        latehalf[1] = constm1_rtx;\n+\t      else\n+\t        latehalf[1] = const0_rtx;\n+\t    }\n \t}\n+      else\n+\tlatehalf[1] = operands[1];\n     }\n-  else\n-    latehalf[1] = operands[1];\n \n   /* If insn is effectively movd N (sp),-(sp) then we will do the\n      high word first.  We should use the adjusted operand 1 (which is N+4 (sp))\n@@ -367,12 +460,40 @@ output_move_double (operands)\n \t{\n \t  /* If both halves of dest are used in the src memory address,\n \t     compute the address into latehalf of dest.  */\n-\t  rtx xops[2];\n+compadr:\n \t  xops[0] = latehalf[0];\n \t  xops[1] = XEXP (operands[1], 0);\n \t  output_asm_insn (AS2 (lea%L0,%a1,%0), xops);\n-\t  operands[1] = gen_rtx (MEM, DImode, latehalf[0]);\n-\t  latehalf[1] = adj_offsettable_operand (operands[1], 4);\n+\t  if( GET_MODE (operands[1]) == XFmode )\n+\t    {\n+/*\t    abort (); */\n+\t      operands[1] = gen_rtx (MEM, XFmode, latehalf[0]);\n+\t      middlehalf[1] = adj_offsettable_operand (operands[1], size-8);\n+\t      latehalf[1] = adj_offsettable_operand (operands[1], size-4);\n+\t    }\n+\t  else\n+\t    {\n+\t      operands[1] = gen_rtx (MEM, DImode, latehalf[0]);\n+\t      latehalf[1] = adj_offsettable_operand (operands[1], size-4);\n+\t    }\n+\t}\n+      else if (size == 12\n+\t\t && reg_mentioned_p (middlehalf[0], XEXP (operands[1], 0)))\n+\t{\n+\t  /* Check for two regs used by both source and dest. */\n+\t  if (reg_mentioned_p (operands[0], XEXP (operands[1], 0))\n+\t\t|| reg_mentioned_p (latehalf[0], XEXP (operands[1], 0)))\n+\t\tgoto compadr;\n+\n+\t  /* JRV says this can't happen: */\n+\t  if (addreg0 || addreg1)\n+\t      abort();\n+\n+\t  /* Only the middle reg conflicts; simply put it last. */\n+\t  output_asm_insn (singlemove_string (operands), operands);\n+\t  output_asm_insn (singlemove_string (latehalf), latehalf);\n+\t  output_asm_insn (singlemove_string (middlehalf), middlehalf);\n+\t  return \"\";\n \t}\n       else if (reg_mentioned_p (operands[0], XEXP (operands[1], 0)))\n \t/* If the low half of dest is mentioned in the source memory\n@@ -388,16 +509,23 @@ output_move_double (operands)\n      such overlap can't happen in memory unless the user explicitly\n      sets it up, and that is an undefined circumstance.  */\n \n+/*\n   if (optype0 == PUSHOP || optype1 == PUSHOP\n       || (optype0 == REGOP && optype1 == REGOP\n \t  && REGNO (operands[0]) == REGNO (latehalf[1]))\n       || dest_overlapped_low)\n+*/\n+  if (optype0 == PUSHOP || optype1 == PUSHOP\n+      || (optype0 == REGOP && optype1 == REGOP\n+\t  && ((middlehalf[1] && REGNO (operands[0]) == REGNO (middlehalf[1]))\n+\t      || REGNO (operands[0]) == REGNO (latehalf[1])))\n+      || dest_overlapped_low)\n     {\n       /* Make any unoffsettable addresses point at high-numbered word.  */\n       if (addreg0)\n-\tasm_add (4, addreg0);\n+\tasm_add (size-4, addreg0);\n       if (addreg1)\n-\tasm_add (4, addreg1);\n+\tasm_add (size-4, addreg1);\n \n       /* Do that word.  */\n       output_asm_insn (singlemove_string (latehalf), latehalf);\n@@ -408,6 +536,15 @@ output_move_double (operands)\n       if (addreg1)\n \tasm_add (-4, addreg1);\n \n+      if (size == 12)\n+        {\n+        output_asm_insn (singlemove_string (middlehalf), middlehalf);\n+        if (addreg0)\n+           asm_add (-4, addreg0);\n+        if (addreg1)\n+\t   asm_add (-4, addreg1);\n+\t}\n+\n       /* Do low-numbered word.  */\n       return singlemove_string (operands);\n     }\n@@ -416,6 +553,17 @@ output_move_double (operands)\n \n   output_asm_insn (singlemove_string (operands), operands);\n \n+  /* Do the middle one of the three words for long double */\n+  if (size == 12)\n+    {\n+      if (addreg0)\n+        asm_add (4, addreg0);\n+      if (addreg1)\n+        asm_add (4, addreg1);\n+\n+      output_asm_insn (singlemove_string (middlehalf), middlehalf);\n+    }\n+\n   /* Make any unoffsettable addresses point at high-numbered word.  */\n   if (addreg0)\n     asm_add (4, addreg0);\n@@ -427,9 +575,9 @@ output_move_double (operands)\n \n   /* Undo the adds we just did.  */\n   if (addreg0)\n-    asm_add (-4, addreg0);\n+    asm_add (4-size, addreg0);\n   if (addreg1)\n-    asm_add (-4, addreg1);\n+    asm_add (4-size, addreg1);\n \n   return \"\";\n }\n@@ -482,12 +630,14 @@ output_move_const_single (operands)\n     }\n   if (GET_CODE (operands[1]) == CONST_DOUBLE)\n     {\n-      union { int i[2]; double d;} u1;\n-      union { int i; float f;} u2;\n-      u1.i[0] = CONST_DOUBLE_LOW (operands[1]);\n-      u1.i[1] = CONST_DOUBLE_HIGH (operands[1]);\n-      u2.f = u1.d;\n-      operands[1] = GEN_INT (u2.i);\n+      REAL_VALUE_TYPE r; long l;\n+\n+      if (GET_MODE (operands[1]) == XFmode)\n+\tabort ();\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+      REAL_VALUE_TO_TARGET_SINGLE (r, l);\n+      operands[1] = GEN_INT (l);\n     }\n   return singlemove_string (operands);\n }\n@@ -1045,6 +1195,10 @@ print_operand (file, x, code)\n \t  PUT_OP_SIZE (code, 's', file);\n \t  return;\n \n+\tcase 'T':\n+\t  PUT_OP_SIZE (code, 't', file);\n+\t  return;\n+\n \tcase 'z':\n \t  /* 387 opcodes don't get size suffixes if the operands are\n \t     registers. */\n@@ -1073,6 +1227,10 @@ print_operand (file, x, code)\n \t\tPUT_OP_SIZE ('L', 'l', file);\n \t      return;\n \n+\t    case 12:\n+\t\t  PUT_OP_SIZE ('T', 't', file);\n+\t\t  return;\n+\n \t    case 8:\n \t      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n \t\t{\n@@ -1124,20 +1282,26 @@ print_operand (file, x, code)\n     }\n   else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == SFmode)\n     {\n-      union { double d; int i[2]; } u;\n-      union { float f; int i; } u1;\n-      u.i[0] = CONST_DOUBLE_LOW (x);\n-      u.i[1] = CONST_DOUBLE_HIGH (x);\n-      u1.f = u.d;\n+      REAL_VALUE_TYPE r; long l;\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+      REAL_VALUE_TO_TARGET_SINGLE (r, l);\n       PRINT_IMMED_PREFIX (file);\n-      fprintf (file, \"0x%x\", u1.i);\n+      fprintf (file, \"0x%x\", l);\n+    }\n+ /* These float cases don't actually occur as immediate operands. */\n+ else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == DFmode)\n+    {\n+      REAL_VALUE_TYPE r; char dstr[30];\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+      REAL_VALUE_TO_DECIMAL (r, \"%.22e\", dstr);\n+      fprintf (file, \"%s\", dstr);\n     }\n-  else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == DFmode)\n+  else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == XFmode)\n     {\n-      union { double d; int i[2]; } u;\n-      u.i[0] = CONST_DOUBLE_LOW (x);\n-      u.i[1] = CONST_DOUBLE_HIGH (x);\n-      fprintf (file, \"%.22e\", u.d);\n+      REAL_VALUE_TYPE r; char dstr[30];\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+      REAL_VALUE_TO_DECIMAL (r, \"%.22e\", dstr);\n+      fprintf (file, \"%s\", dstr);\n     }\n   else \n     {\n@@ -1500,7 +1664,9 @@ convert_387_op (op, mode)\n       return GET_MODE (XEXP (op, 0)) == SImode;\n \n     case FLOAT_EXTEND:\n-      return mode == DFmode && GET_MODE (XEXP (op, 0)) == SFmode;\n+      return ((mode == DFmode && GET_MODE (XEXP (op, 0)) == SFmode)\n+\t      || (mode == XFmode && GET_MODE (XEXP (op, 0)) == DFmode)\n+\t      || (mode == XFmode && GET_MODE (XEXP (op, 0)) == SFmode));\n \n     default:\n       return 0;"}]}