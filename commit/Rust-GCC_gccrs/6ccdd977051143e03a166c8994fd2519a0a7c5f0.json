{"sha": "6ccdd977051143e03a166c8994fd2519a0a7c5f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNjZGQ5NzcwNTExNDNlMDNhMTY2Yzg5OTRmZDI1MTlhMGE3YzVmMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-17T07:06:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-17T07:06:05Z"}, "message": "[multiple changes]\n\n2014-07-17  Bob Duff  <duff@adacore.com>\n\n\t* gnat_ugn.texi: Improve documentation of Unrestricted_Access.\n\n2014-07-17  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch13.adb (Build_Invariant_Procedure): Add variable Nam\n\t(Add_Invariants): Set Nam to Name_Type_Invariant if from aspect.\n\n2014-07-17  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_pakd.adb (Create_Packed_Array_Type.Install_PAT): For a\n\tnon-bit-packed array, propagate Reverse_Storage_Order to the\n\tpacked array type.\n\n2014-07-17  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_disp.adb: Fix comment.\n\t* exp_pakd.adb: Minor reformatting.\n\nFrom-SVN: r212736", "tree": {"sha": "dd35b52cbac27c89ca657433aaa69fd67c3ae3ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd35b52cbac27c89ca657433aaa69fd67c3ae3ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ccdd977051143e03a166c8994fd2519a0a7c5f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ccdd977051143e03a166c8994fd2519a0a7c5f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ccdd977051143e03a166c8994fd2519a0a7c5f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ccdd977051143e03a166c8994fd2519a0a7c5f0/comments", "author": null, "committer": null, "parents": [{"sha": "d8941160a5f0af2e44cb349af43aed8c795b91ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8941160a5f0af2e44cb349af43aed8c795b91ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8941160a5f0af2e44cb349af43aed8c795b91ea"}], "stats": {"total": 178, "additions": 130, "deletions": 48}, "files": [{"sha": "3102148e4af7e24c095deb3a7839b1ca6c7ea319", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ccdd977051143e03a166c8994fd2519a0a7c5f0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ccdd977051143e03a166c8994fd2519a0a7c5f0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6ccdd977051143e03a166c8994fd2519a0a7c5f0", "patch": "@@ -1,3 +1,23 @@\n+2014-07-17  Bob Duff  <duff@adacore.com>\n+\n+\t* gnat_ugn.texi: Improve documentation of Unrestricted_Access.\n+\n+2014-07-17  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch13.adb (Build_Invariant_Procedure): Add variable Nam\n+\t(Add_Invariants): Set Nam to Name_Type_Invariant if from aspect.\n+\n+2014-07-17  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_pakd.adb (Create_Packed_Array_Type.Install_PAT): For a\n+\tnon-bit-packed array, propagate Reverse_Storage_Order to the\n+\tpacked array type.\n+\n+2014-07-17  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_disp.adb: Fix comment.\n+\t* exp_pakd.adb: Minor reformatting.\n+\n 2014-07-17  Robert Dewar  <dewar@adacore.com>\n \n \t* bindgen.adb (Gen_Elab_Calls): Skip reference to elab"}, {"sha": "34db31231207dc14a1650a2e11ee78d3f1b28683", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ccdd977051143e03a166c8994fd2519a0a7c5f0/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ccdd977051143e03a166c8994fd2519a0a7c5f0/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=6ccdd977051143e03a166c8994fd2519a0a7c5f0", "patch": "@@ -7171,11 +7171,8 @@ package body Exp_Disp is\n       Set_Ekind        (DT_Ptr, E_Variable);\n       Set_Related_Type (DT_Ptr, Typ);\n \n-      --  Ensure that entities Prim_Ptr and Predef_Prims_Table_Ptr have\n-      --  the decoration required by the backend.\n-\n-      --  Odd comment, the back end cannot require anything not properly\n-      --  documented in einfo. ???\n+      --  Notify the back end that the types are associated with a dispatch\n+      --  table\n \n       Set_Is_Dispatch_Table_Entity (RTE (RE_Prim_Ptr));\n       Set_Is_Dispatch_Table_Entity (RTE (RE_Predef_Prims_Table_Ptr));"}, {"sha": "35d310be0f204d09b0cf5072131807e1b48c2e16", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ccdd977051143e03a166c8994fd2519a0a7c5f0/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ccdd977051143e03a166c8994fd2519a0a7c5f0/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=6ccdd977051143e03a166c8994fd2519a0a7c5f0", "patch": "@@ -846,13 +846,12 @@ package body Exp_Pakd is\n          --  the resulting type as an Itype in the packed array type field of\n          --  the original type, so that no explicit declaration is required.\n \n-         --  Note: the packed type is created in the scope of its parent\n-         --  type. There are at least some cases where the current scope\n-         --  is deeper, and so when this is the case, we temporarily reset\n-         --  the scope for the definition. This is clearly safe, since the\n-         --  first use of the packed array type will be the implicit\n-         --  reference from the corresponding unpacked type when it is\n-         --  elaborated.\n+         --  Note: the packed type is created in the scope of its parent type.\n+         --  There are at least some cases where the current scope is deeper,\n+         --  and so when this is the case, we temporarily reset the scope\n+         --  for the definition. This is clearly safe, since the first use\n+         --  of the packed array type will be the implicit reference from\n+         --  the corresponding unpacked type when it is elaborated.\n \n          if Is_Itype (Typ) then\n             Set_Parent (Decl, Associated_Node_For_Itype (Typ));\n@@ -895,10 +894,18 @@ package body Exp_Pakd is\n          Set_Is_Packed_Array_Type      (PAT, True);\n          Set_Original_Array_Type       (PAT, Typ);\n \n+         --  For a non-bit-packed array, propagate reverse storage order\n+         --  flag from original base type to packed array base type.\n+\n+         if not Is_Bit_Packed_Array (Typ) then\n+            Set_Reverse_Storage_Order\n+              (Etype (PAT), Reverse_Storage_Order (Base_Type (Typ)));\n+         end if;\n+\n          --  We definitely do not want to delay freezing for packed array\n-         --  types. This is of particular importance for the itypes that\n-         --  are generated for record components depending on discriminants\n-         --  where there is no place to put the freeze node.\n+         --  types. This is of particular importance for the itypes that are\n+         --  generated for record components depending on discriminants where\n+         --  there is no place to put the freeze node.\n \n          Set_Has_Delayed_Freeze (PAT, False);\n          Set_Has_Delayed_Freeze (Etype (PAT), False);\n@@ -1000,6 +1007,10 @@ package body Exp_Pakd is\n          --    Natural range Enum_Type'Pos (Enum_Type'First) ..\n          --                  Enum_Type'Pos (Enum_Type'Last);\n \n+         --  Note that tttP is created even if no index subtype is a non\n+         --  standard enumeration, because we still need to remove padding\n+         --  normally inserted for component alignment.\n+\n          PAT :=\n            Make_Defining_Identifier (Loc,\n              Chars => New_External_Name (Chars (Typ), 'P'));\n@@ -1098,7 +1109,7 @@ package body Exp_Pakd is\n             Decl :=\n               Make_Full_Type_Declaration (Loc,\n                 Defining_Identifier => PAT,\n-                Type_Definition => Typedef);\n+                Type_Definition     => Typedef);\n          end;\n \n          --  Set type as packed array type and install it"}, {"sha": "b0b3907cc388c37b5e4020f54eff779f198ce31f", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 62, "deletions": 26, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ccdd977051143e03a166c8994fd2519a0a7c5f0/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ccdd977051143e03a166c8994fd2519a0a7c5f0/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=6ccdd977051143e03a166c8994fd2519a0a7c5f0", "patch": "@@ -9588,28 +9588,64 @@ end;\n @noindent\n The @code{Unrestricted_Access} attribute is similar to @code{Access}\n except that all accessibility and aliased view checks are omitted.  This\n-is a user-beware attribute.  It is similar to\n-@code{Address}, for which it is a desirable replacement where the value\n-desired is an access type.  In other words, its effect is similar to\n-first applying the @code{Address} attribute and then doing an unchecked\n-conversion to a desired access type.  In GNAT, but not necessarily in\n-other implementations, the use of static chains for inner level\n-subprograms means that @code{Unrestricted_Access} applied to a\n-subprogram yields a value that can be called as long as the subprogram\n-is in scope (normal Ada accessibility rules restrict this usage).\n-\n-It is possible to use @code{Unrestricted_Access} for any type, but care\n-must be exercised if it is used to create pointers to unconstrained array\n-objects.  In this case, the resulting pointer has the same scope as the\n-context of the attribute, and may not be returned to some enclosing\n-scope.  For instance, a function cannot use @code{Unrestricted_Access}\n-to create a unconstrained pointer and then return that value to the\n-caller.  In addition, it is only valid to create pointers to unconstrained\n-arrays using this attribute if the pointer has the normal default ``fat''\n-representation where a pointer has two components, one points to the array\n-and one points to the bounds.  If a size clause is used to force ``thin''\n-representation for a pointer to unconstrained where there is only space for\n-a single pointer, then the resulting pointer is not usable.\n+is a user-beware attribute.\n+\n+For objects, it is similar to @code{Address}, for which it is a\n+desirable replacement where the value desired is an access type.\n+In other words, its effect is similar to first applying the\n+@code{Address} attribute and then doing an unchecked conversion to a\n+desired access type.\n+\n+For subprograms, @code{P'Unrestricted_Access} may be used where\n+@code{P'Access} would be illegal, to construct a value of a\n+less-nested named access type that designates a more-nested\n+subprogram. This value may be used in indirect calls, so long as the\n+more-nested subprogram still exists; once the subprogram containing it\n+has returned, such calls are erroneous. For example:\n+\n+@smallexample @c ada\n+package body P is\n+\n+   type Less_Nested is not null access procedure;\n+   Global : Less_Nested;\n+\n+   procedure P1 is\n+   begin\n+      Global.all;\n+   end P1;\n+\n+   procedure P2 is\n+      Local_Var : Integer;\n+\n+      procedure More_Nested is\n+      begin\n+         ... Local_Var ...\n+      end More_Nested;\n+   begin\n+      Global := More_Nested'Unrestricted_Access;\n+      P1;\n+   end P2;\n+\n+end P;\n+@end smallexample\n+\n+When P1 is called from P2, the call via Global is OK, but if P1 were\n+called after P2 returns, it would be an erroneous use of a dangling\n+pointer.\n+\n+For objects, it is possible to use @code{Unrestricted_Access} for any\n+type, but care must be exercised if it is used to create pointers to\n+unconstrained array objects.  In this case, the resulting pointer has\n+the same scope as the context of the attribute, and may not be\n+returned to some enclosing scope.  For instance, a function cannot use\n+@code{Unrestricted_Access} to create a pointer to unconstrained and\n+then return that value to the caller.  In addition, it is only valid\n+to create pointers to unconstrained arrays using this attribute if the\n+pointer has the normal default ``fat'' representation where a pointer\n+has two components, one points to the array and one points to the\n+bounds.  If a size clause is used to force ``thin'' representation for\n+a pointer to unconstrained where there is only space for a single\n+pointer, then the resulting pointer is not usable.\n \n In the simple case where a direct use of Unrestricted_Access attempts\n to make a thin pointer for a non-aliased object, the compiler will\n@@ -9686,17 +9722,17 @@ bounds before the string.  If the size clause for type @code{A}\n were not present, then the pointer\n would be a fat pointer, where one component is a pointer to the bounds,\n and all would be well.  But with the size clause present, the conversion from\n-fat pointer to thin pointer in the call looses the bounds, and so this\n-program raises a @code{Program_Error} exception if executed.\n+fat pointer to thin pointer in the call loses the bounds, and so this\n+is erroneous, and the program likely raises a @code{Program_Error} exception.\n \n In general, it is advisable to completely\n avoid mixing the use of thin pointers and the use of\n @code{Unrestricted_Access} where the designated type is an\n unconstrained array.  The use of thin pointers should be restricted to\n-cases of porting legacy code which implicitly assumes the size of pointers,\n+cases of porting legacy code that implicitly assumes the size of pointers,\n and such code should not in any case be using this attribute.\n \n-Another erroroneous situation arises if the attribute is\n+Another erroneous situation arises if the attribute is\n applied to a constant. The resulting pointer can be used to access the\n constant, but the effect of trying to modify a constant in this manner\n is not well-defined. Consider this example:"}, {"sha": "be28f94a1d83a940bd64420cc0614f12862a25d4", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ccdd977051143e03a166c8994fd2519a0a7c5f0/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ccdd977051143e03a166c8994fd2519a0a7c5f0/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=6ccdd977051143e03a166c8994fd2519a0a7c5f0", "patch": "@@ -6218,6 +6218,11 @@ package body Sem_Ch13 is\n       PDecl : Node_Id;\n       PBody : Node_Id;\n \n+      Nam : Name_Id;\n+      --  Name for Check pragma, usually Invariant, but might be Type_Invariant\n+      --  if we come from a Type_Invariant aspect, we make sure to build the\n+      --  Check pragma with the right name, so that Check_Policy works right.\n+\n       Visible_Decls : constant List_Id := Visible_Declarations (N);\n       Private_Decls : constant List_Id := Private_Declarations (N);\n \n@@ -6372,6 +6377,10 @@ package body Sem_Ch13 is\n                      --  Loop to find corresponding aspect, note that this\n                      --  must be present given the pragma is marked delayed.\n \n+                     --  Note: in practice Next_Rep_Item (Ritem) is Empty so\n+                     --  this loop does nothing. Furthermore, why isn't this\n+                     --  simply Corresponding_Aspect ???\n+\n                      Aitem := Next_Rep_Item (Ritem);\n                      while Present (Aitem) loop\n                         if Nkind (Aitem) = N_Aspect_Specification\n@@ -6399,7 +6408,7 @@ package body Sem_Ch13 is\n                --  analyze the original expression in the aspect specification\n                --  because it is part of the original tree.\n \n-               if ASIS_Mode then\n+               if ASIS_Mode and then From_Aspect_Specification (Ritem) then\n                   declare\n                      Inv : constant Node_Id :=\n                              Expression (Corresponding_Aspect (Ritem));\n@@ -6409,13 +6418,22 @@ package body Sem_Ch13 is\n                   end;\n                end if;\n \n+               --  Get name to be used for Check pragma\n+\n+               if not From_Aspect_Specification (Ritem) then\n+                  Nam := Name_Invariant;\n+               else\n+                  Nam := Chars (Identifier (Corresponding_Aspect (Ritem)));\n+               end if;\n+\n                --  Build first two arguments for Check pragma\n \n-               Assoc := New_List (\n-                 Make_Pragma_Argument_Association (Loc,\n-                   Expression => Make_Identifier (Loc, Name_Invariant)),\n-                 Make_Pragma_Argument_Association (Loc,\n-                   Expression => Exp));\n+               Assoc :=\n+                 New_List (\n+                   Make_Pragma_Argument_Association (Loc,\n+                     Expression => Make_Identifier (Loc, Chars => Nam)),\n+                   Make_Pragma_Argument_Association (Loc,\n+                     Expression => Exp));\n \n                --  Add message if present in Invariant pragma\n "}]}