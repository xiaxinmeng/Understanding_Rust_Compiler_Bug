{"sha": "7b4bf3453d0ade248e783eb510b294ca7d72039e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I0YmYzNDUzZDBhZGUyNDhlNzgzZWI1MTBiMjk0Y2E3ZDcyMDM5ZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-16T23:17:54Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-16T23:17:54Z"}, "message": "(FUNCTION_ARG_PADDING, FUNCTION_PROLOGUE): Deleted.\n\n(FUNCTION_EPILOGUE, PRINT_OPERAND, PRINT_OPERAND_ADDRESS): Deleted.\n(SGS_SWITCH_TABLES, ASM_OUTPUT_CASE_END): Deleted.\n(ASM_OUTPUT_FLOAT_OPERAND, ASM_OUTPUT_DOUBLE_OPERAND): Deleted.\n(SGS_NO_LI, ASM_OUTPUT_CASE_FETCH, ASM_RETURN_CASE_JUMP): Defined.\n\nFrom-SVN: r7052", "tree": {"sha": "b2a754310b809396aac4ca91141859c39d0f2461", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2a754310b809396aac4ca91141859c39d0f2461"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b4bf3453d0ade248e783eb510b294ca7d72039e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b4bf3453d0ade248e783eb510b294ca7d72039e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b4bf3453d0ade248e783eb510b294ca7d72039e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b4bf3453d0ade248e783eb510b294ca7d72039e/comments", "author": null, "committer": null, "parents": [{"sha": "f4a6e73be91dc7caa9f74b017640612ea6bf2cb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4a6e73be91dc7caa9f74b017640612ea6bf2cb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4a6e73be91dc7caa9f74b017640612ea6bf2cb8"}], "stats": {"total": 358, "additions": 30, "deletions": 328}, "files": [{"sha": "e0be06f30d7b0a5a7ba204016a9bdbf60340d939", "filename": "gcc/config/m68k/mot3300.h", "status": "modified", "additions": 30, "deletions": 328, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b4bf3453d0ade248e783eb510b294ca7d72039e/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b4bf3453d0ade248e783eb510b294ca7d72039e/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fmot3300.h?ref=7b4bf3453d0ade248e783eb510b294ca7d72039e", "patch": "@@ -25,7 +25,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define SGS\t\t\t/* Uses SGS assembler */\n #define SGS_CMP_ORDER\t\t/* Takes cmp operands in reverse order */\n #define SGS_SWAP_W\t\t/* Use swap.w rather than just plain swap */\n-#define SGS_SWITCH_TABLES\t/* Different switch table handling */\n \n #define NO_DOLLAR_IN_LABEL\n #define NO_DOT_IN_LABEL\n@@ -90,6 +89,11 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #undef REGISTER_PREFIX\n #define REGISTER_PREFIX \"%\"\n \n+#if 0\n+#undef LOCAL_LABEL_PREFIX\n+#define LOCAL_LABEL_PREFIX \"~\"\n+#endif\n+\n #undef IMMEDIATE_PREFIX\n #define IMMEDIATE_PREFIX \"&\"\n \n@@ -99,99 +103,10 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n  \"%a0\", \"%a1\", \"%a2\", \"%a3\", \"%a4\", \"%a5\", \"%fp\", \"%sp\",\t\\\n  \"%fp0\", \"%fp1\", \"%fp2\", \"%fp3\", \"%fp4\", \"%fp5\", \"%fp6\", \"%fp7\"}\n \n-#if 0 /* phdm@info.ucl.ac.be says the standard ones work.  */\n-#undef FUNCTION_PROLOGUE\n-#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n-{ register int regno;\t\t\t\t\t\t\\\n-  register int mask = 0;\t\t\t\t\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\\\n-  int fsize = (SIZE);\t\t\t\t\t\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\\\n-    { if (fsize < 0x8000)\t\t\t\t\t\\\n-        fprintf (FILE, \"\\tlink.w %%fp,&%d\\n\", -fsize);\t\t\\\n-      else if (TARGET_68020)\t\t\t\t\t\\\n-        fprintf (FILE, \"\\tlink.l %%fp,&%d\\n\", -fsize);\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tlink.w %%fp,&0\\n\\tsub.l &%d,%%sp\\n\", fsize); }  \\\n-  for (regno = 16; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-       mask |= 1 << (regno - 16);\t\t\t\t\\\n-  if (mask != 0)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tfmovem &0x%x,-(%%sp)\\n\", mask & 0xff);\t\\\n-  mask = 0;\t\t\t\t\t\t\t\\\n-  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-       mask |= 1 << (15 - regno);\t\t\t\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\\\n-    mask &= ~ (1 << (15-FRAME_POINTER_REGNUM));\t\t\t\\\n-  if (exact_log2 (mask) >= 0)\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tmov.l %s,-(%%sp)\\n\", reg_names[15 - exact_log2 (mask)]);  \\\n-  else if (mask) fprintf (FILE, \"\\tmovm.l &0x%x,-(%%sp)\\n\", mask); }\n-#endif /* 0 */\n-\n #undef FUNCTION_PROFILER\n #define FUNCTION_PROFILER(FILE, LABEL_NO)\t\\\n     fprintf (FILE, \"\\tmov.l &LP%%%d,%%a0\\n\\tjsr mcount%%\\n\", (LABEL_NO))\n \n-#if 0 /* phdm@info.ucl.ac.be says the standard ones work.  */\n-#undef FUNCTION_EPILOGUE\n-#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n-{ register int regno;\t\t\t\t\t\t\\\n-  register int mask, fmask;\t\t\t\t\t\\\n-  register int nregs;\t\t\t\t\t\t\\\n-  int offset, foffset;\t\t\t\t\t\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\\\n-  int fsize = (SIZE);\t\t\t\t\t\t\\\n-  int big = 0;\t\t\t\t\t\t\t\\\n-  nregs = 0;  fmask = 0;\t\t\t\t\t\\\n-  for (regno = 16; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-      { nregs++; fmask |= 1 << (23 - regno); }\t\t\t\\\n-  foffset = nregs * 12;\t\t\t\t\t\t\\\n-  nregs = 0;  mask = 0;\t\t\t\t\t\t\\\n-  if (frame_pointer_needed) regs_ever_live[FRAME_POINTER_REGNUM] = 0; \\\n-  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-      { nregs++; mask |= 1 << regno; }\t\t\t\t\\\n-  offset = foffset + nregs * 4;\t\t\t\t\t\\\n-  if (offset + fsize >= 0x8000 && frame_pointer_needed)\t\t\\\n-    { fprintf (FILE, \"\\tmov.l &%d,%%a0\\n\", -fsize);\t\t\\\n-      fsize = 0, big = 1; }\t\t\t\t\t\\\n-  if (exact_log2 (mask) >= 0) {\t\t\t\t\t\\\n-    if (big)\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tmov.l -%d(%%fp,%%a0.l),%s\\n\",\t\t\\\n-\t       offset + fsize, reg_names[exact_log2 (mask)]);\t\\\n-    else if (! frame_pointer_needed)\t\t\t\t\\\n-      fprintf (FILE, \"\\tmov.l (%%sp)+,%s\\n\",\t\t\t\\\n-\t       reg_names[exact_log2 (mask)]);\t\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tmov.l -%d(%%fp),%s\\n\",\t\t\t\\\n-\t       offset + fsize, reg_names[exact_log2 (mask)]); }\t\\\n-  else if (mask) {\t\t\t\t\t\t\\\n-    if (big)\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tmovm.l -%d(%%fp,%%a0.l),&0x%x\\n\",\t\\\n-\t       offset + fsize, mask);\t\t\t\t\\\n-    else if (! frame_pointer_needed)\t\t\t\t\\\n-      fprintf (FILE, \"\\tmovm.l (%%sp)+,&0x%x\\n\", mask);\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tmovm.l -%d(%%fp),&0x%x\\n\",\t\t\\\n-\t       offset + fsize, mask); }\t\t\t\t\\\n-  if (fmask) {\t\t\t\t\t\t\t\\\n-    if (big)\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tfmovem -%d(%%fp,%%a0.l),&0x%x\\n\",\t\\\n-\t       foffset + fsize, fmask);\t\t\t\t\\\n-    else if (! frame_pointer_needed)\t\t\t\t\\\n-      fprintf (FILE, \"\\tfmovem (%%sp)+,&0x%x\\n\", fmask);\t\\\n-    else\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tfmovem -%d(%%fp),&0x%x\\n\",\t\t\\\n-\t       foffset + fsize, fmask); }\t\t\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tunlk %%fp\\n\");\t\t\t\t\\\n-  if (current_function_pops_args)\t\t\t\t\\\n-    fprintf (FILE, \"\\trtd &%d\\n\", current_function_pops_args);\t\\\n-  else fprintf (FILE, \"\\trts\\n\"); }\n-#endif /* 0 */\n-\n /* This is how to output an insn to push a register on the stack.\n    It need not be very fast code.  */\n \n@@ -237,19 +152,6 @@ output_file_directive ((FILE), main_input_filename)\n #undef CPP_PREDEFINES\n #define CPP_PREDEFINES \"-Dm68k -Dunix -DsysV68 -D__motorola__ -Asystem(unix) -Asystem(svr3) -Acpu(m68k) -Amachine(m68k)\"\n \n-#if 0 /* phdm@info.ucl.ac.be says the right way is with PARM_BOUNDARY.  */\n-/* Specify how to pad function arguments.\n-   Value should be `upward', `downward' or `none'.\n-   Same as the default, except no padding for large or variable-size args.  */\n-\n-#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\t\\\n-  (((MODE) == BLKmode\t\t\t\t\t\t\t\\\n-    ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE))\t== INTEGER_CST\t\t\\\n-       && int_size_in_bytes (TYPE) < PARM_BOUNDARY / BITS_PER_UNIT)\t\\\n-    : GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY)\t\t\t\t\\\n-   ? downward : none)\n-#endif /* 0 */\n-\n /* Override part of the obstack macros.  */\n \n #define __PTR_TO_INT(P) ((int)(P))\n@@ -272,17 +174,12 @@ output_file_directive ((FILE), main_input_filename)\n \n #undef FUNCTION_VALUE\n /* sysV68 (brain damaged) cc convention support. */\n-/* Commented out until we find a safe way to make it optional.  */\n-#if 1\n #define FUNCTION_VALUE(VALTYPE,FUNC) \\\n   (TREE_CODE (VALTYPE) == REAL_TYPE && TARGET_68881 \t\\\n    ? gen_rtx (REG, TYPE_MODE (VALTYPE), 16)\t\t\\\n    : (TREE_CODE (VALTYPE) == POINTER_TYPE \t\t\\\n       ? gen_rtx (REG, TYPE_MODE (VALTYPE), 8)\t\t\\\n       : gen_rtx (REG, TYPE_MODE (VALTYPE), 0)))\n-#else\n-#define FUNCTION_VALUE(VALTYPE,FUNC) LIBCALL_VALUE (TYPE_MODE (VALTYPE))\n-#endif\n \n /* If TARGET_68881, SF and DF values are returned in fp0 instead of d0.  */\n \n@@ -299,14 +196,8 @@ output_file_directive ((FILE), main_input_filename)\n \n #undef FUNCTION_VALUE_REGNO_P\n /* sysV68 (brain damaged) cc convention support. */\n-/* Commented out until we find a safe way to make it optional.  */\n-#if 1\n #define FUNCTION_VALUE_REGNO_P(N) \\\n  ((N) == 0 || (N) == 8 || (TARGET_68881 && (N) == 16))\n-#else\n-#define FUNCTION_VALUE_REGNO_P(N) \\\n- ((N) == 0 || (TARGET_68881 && (N) == 16))\n-#endif \n \n /* Define this to be true when FUNCTION_VALUE_REGNO_P is true for\n    more than one register.  */\n@@ -439,205 +330,25 @@ do { long l;\t\t\t\t\t\\\n \tgoto loop; }\t\t\t\t\t\t\\\n     putc ('\\n', (FILE)); } while (0)\n \n-/* Print operand X (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and X is null.\n-\n-   On the 68000, we use several CODE characters:\n-   '.' for dot needed in Motorola-style opcode names.\n-   '-' for an operand pushing on the stack:\n-       sp@-, -(sp) or -(%sp) depending on the style of syntax.\n-   '+' for an operand pushing on the stack:\n-       sp@+, (sp)+ or (%sp)+ depending on the style of syntax.\n-   '@' for a reference to the top word on the stack:\n-       sp@, (sp) or (%sp) depending on the style of syntax.\n-   '#' for an immediate operand prefix (# in MIT and Motorola syntax\n-       but & in SGS syntax).\n-   '!' for the fpcr register (used in some float-to-fixed conversions).\n-   '$' for the letter `s' in an op code, but only on the 68040.\n-   '&' for the letter `d' in an op code, but only on the 68040.\n-\n-   'b' for byte insn (no effect, on the Sun; this is for the ISI).\n-   'd' to force memory addressing to be absolute, not relative.\n-   'f' for float insn (print a CONST_DOUBLE as a float rather than in hex)\n-   'w' for FPA insn (print a CONST_DOUBLE as a SunFPA constant rather\n-       than directly).  Second part of 'y' below.\n-   'x' for float insn (print a CONST_DOUBLE as a float rather than in hex),\n-       or print pair of registers as rx:ry.\n-   'y' for a FPA insn (print pair of registers as rx:ry).  This also outputs\n-       CONST_DOUBLE's as SunFPA constant RAM registers if\n-       possible, so it should not be used except for the SunFPA.  */\n-\n-#undef PRINT_OPERAND\n-#define PRINT_OPERAND(FILE, X, CODE)  \\\n-{ if (CODE == '.') fprintf (FILE, \".\");\t\t\t\t\t\\\n-  else if (CODE == '#') fprintf (FILE, \"&\");\t\t\t\t\\\n-  else if (CODE == '-') fprintf (FILE, \"-(%%sp)\");\t\t\t\\\n-  else if (CODE == '+') fprintf (FILE, \"(%%sp)+\");\t\t\t\\\n-  else if (CODE == '@') fprintf (FILE, \"(%%sp)\");\t\t\t\\\n-  else if (CODE == '!') fprintf (FILE, \"%%fpcr\");\t\t\t\\\n-  else if (CODE == '$') { if (TARGET_68040_ONLY) fprintf (FILE, \"s\"); }\t\\\n-  else if (CODE == '&') { if (TARGET_68040_ONLY) fprintf (FILE, \"d\"); }\t\\\n-  else if (CODE == '/')\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"%%\");\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n-  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n-    output_address (XEXP (X, 0));\t\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == SFmode)\t\\\n-    { REAL_VALUE_TYPE r; long l;\t\t\t\t\t\\\n-      REAL_VALUE_FROM_CONST_DOUBLE (r, X);\t\t\t\t\\\n+/* Output a float value (represented as a C double) as an immediate operand.\n+   This macro is a 68k-specific macro.  */\n+\n+#undef ASM_OUTPUT_FLOAT_OPERAND\n+#define ASM_OUTPUT_FLOAT_OPERAND(CODE,FILE,VALUE)\t\t\t\\\n+ do { long l;\t\t\t\t\t\t\t\t\\\n       REAL_VALUE_TO_TARGET_SINGLE (r, l);\t\t\t\t\\\n       /* Use hex representation even if CODE is f.  as needs it.  */\t\\\n-      fprintf (FILE, \"&0x%x\", l); }\t\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == DFmode)\t\\\n-    { REAL_VALUE_TYPE r; int i[2];\t\t\t\t\t\\\n-      REAL_VALUE_FROM_CONST_DOUBLE (r, X);\t\t\t\t\\\n-      REAL_VALUE_TO_TARGET_DOUBLE (r, i);\t\t\t\t\\\n-      fprintf (FILE, \"&0x%08x%08x\", i[0], i[1]); }\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == XFmode)\t\\\n-    { REAL_VALUE_TYPE r;\t\t\t\t\t\t\\\n-      REAL_VALUE_FROM_CONST_DOUBLE (r, X);\t\t\t\t\\\n-      ASM_OUTPUT_LONG_DOUBLE_OPERAND (FILE, r); }\t\t\t\\\n-  else { putc ('&', FILE); output_addr_const (FILE, X); }}\n-\n-#undef PRINT_OPERAND_ADDRESS\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n-{ register rtx reg1, reg2, breg, ireg;\t\t\t\t\t\\\n-  register rtx addr = ADDR;\t\t\t\t\t\t\\\n-  rtx offset;\t\t\t\t\t\t\t\t\\\n-  switch (GET_CODE (addr))\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-    case REG:\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"(%s)\", reg_names[REGNO (addr)]);\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    case PRE_DEC:\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"-(%s)\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    case POST_INC:\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"(%s)+\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    case PLUS:\t\t\t\t\t\t\t\t\\\n-      reg1 = 0;\treg2 = 0;\t\t\t\t\t\t\\\n-      ireg = 0;\tbreg = 0;\t\t\t\t\t\t\\\n-      offset = 0;\t\t\t\t\t\t\t\\\n-      if (CONSTANT_ADDRESS_P (XEXP (addr, 0)))\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  offset = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1)))\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  offset = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (addr) != PLUS) ;\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 0)) == SIGN_EXTEND)\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 1)) == SIGN_EXTEND)\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 0)) == MULT)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 1)) == MULT)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT\t\t\\\n-\t  || GET_CODE (addr) == SIGN_EXTEND)\t\t\t\t\\\n-\t{ if (reg1 == 0) reg1 = addr; else reg2 = addr; addr = 0; }\t\\\n-/*  for OLD_INDEXING\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (addr) == PLUS)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      reg2 = XEXP (addr, 0);\t\t\t\t\t\\\n-\t      addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      reg2 = XEXP (addr, 1);\t\t\t\t\t\\\n-\t      addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-  */\t\t\t\t\t\t\t\t\t\\\n-      if (offset != 0) { if (addr != 0) abort (); addr = offset; }\t\\\n-      if ((reg1 && (GET_CODE (reg1) == SIGN_EXTEND\t\t\t\\\n-\t\t    || GET_CODE (reg1) == MULT))\t\t\t\\\n-\t  || (reg2 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg2))))\t\t\\\n-\t{ breg = reg2; ireg = reg1; }\t\t\t\t\t\\\n-      else if (reg1 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg1)))\t\t\\\n-\t{ breg = reg1; ireg = reg2; }\t\t\t\t\t\\\n-      if (ireg != 0 && breg == 0 && GET_CODE (addr) == LABEL_REF)\t\\\n-        { int scale = 1;\t\t\t\t\t\t\\\n-\t  if (GET_CODE (ireg) == MULT)\t\t\t\t\t\\\n-\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n-\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n-\t  if (GET_CODE (ireg) == SIGN_EXTEND)\t\t\t\t\\\n-\t    fprintf (FILE, \"12(%%pc,%s.w\",\t\t\t\t\\\n-\t\t     reg_names[REGNO (XEXP (ireg, 0))]); \t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"12(%%pc,%s.l\",\t\t\t\t\\\n-\t\t     reg_names[REGNO (ireg)]);\t\t\t\t\\\n-\t  if (scale != 1) fprintf (FILE, \"*%d\", scale);\t\t\t\\\n-\t  fprintf (FILE, \")\");\t\t\t\t\t\t\\\n-\t  break; }\t\t\t\t\t\t\t\\\n-      if (breg != 0 && ireg == 0 && GET_CODE (addr) == LABEL_REF)\t\\\n-        { fprintf (FILE, \"12(%%pc,%s.l\",\t\t\t\t\\\n-\t\t   reg_names[REGNO (breg)]);\t\t\t\t\\\n-\t  putc (')', FILE);\t\t\t\t\t\t\\\n-\t  break; }\t\t\t\t\t\t\t\\\n-      if (ireg != 0 || breg != 0)\t\t\t\t\t\\\n-\t{ int scale = 1;\t\t\t\t\t\t\\\n-\t  if (breg == 0)\t\t\t\t\t\t\\\n-\t    abort ();\t\t\t\t\t\t\t\\\n-\t  if (addr != 0)\t\t\t\t\t\t\\\n-\t    output_addr_const (FILE, addr);\t\t\t\t\\\n-\t  fprintf (FILE, \"(%s\", reg_names[REGNO (breg)]);\t\t\\\n-\t  if (ireg != 0)\t\t\t\t\t        \\\n-\t    putc (',', FILE);\t\t\t\t\t\t\\\n-\t  if (ireg != 0 && GET_CODE (ireg) == MULT)\t\t\t\\\n-\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n-\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n-\t  if (ireg != 0 && GET_CODE (ireg) == SIGN_EXTEND)\t\t\\\n-\t    fprintf (FILE, \"%s.w\", reg_names[REGNO (XEXP (ireg, 0))]);\t\\\n-\t  else if (ireg != 0)\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"%s.l\", reg_names[REGNO (ireg)]);\t\t\\\n-\t  if (scale != 1) fprintf (FILE, \"*%d\", scale);\t\t\t\\\n-\t  putc (')', FILE);\t\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (reg1 != 0 && GET_CODE (addr) == LABEL_REF)\t\t\\\n-\t{ fprintf (FILE, \"12(%%pc,%s.w)\",\t\t\t\t\\\n-\t\t   reg_names[REGNO (reg1)]);\t\t\t\t\\\n-\t  break; }\t\t\t\t\t\t\t\\\n-    default:\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (addr) == CONST_INT\t\t\t\t\t\\\n-\t  && INTVAL (addr) < 0x8000\t\t\t\t\t\\\n-\t  && INTVAL (addr) >= -0x8000)\t\t\t\t\t\\\n-\tfprintf (FILE, \"%d\", INTVAL (addr));\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-        output_addr_const (FILE, addr);\t\t\t\t\t\\\n-    }}\n+      fprintf ((FILE), \"&0x%lx\", l);\t\t\t\t\t\\\n+    } while (0)\n+\n+/* Output a double value (represented as a C double) as an immediate operand.\n+   This macro is a 68k-specific macro.  */\n+#undef ASM_OUTPUT_DOUBLE_OPERAND\n+#define ASM_OUTPUT_DOUBLE_OPERAND(FILE,VALUE)\t\t\t\t\\\n+ do { long l[2];\t\t\t\t\t\t\t\\\n+      REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\t\t\\\n+      fprintf ((FILE), \"&0x%lx%08lx\", l[0], l[1]);\t\t\t\\\n+    } while (0)\n \n /* This is how to store into the string LABEL\n    the symbol_ref name of an internal numbered label where\n@@ -679,24 +390,19 @@ do { long l;\t\t\t\t\t\\\n #define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLE)\t\t\t\\\n     fprintf (FILE, \"\\tswbeg &%d\\n%s%%%d:\\n\",\t\t\t\t\\\n \t     XVECLEN (PATTERN (TABLE), 1), (PREFIX), (NUM))\n-\t     \n-#if 0\n-/* At end of a switch table, define LD%n iff the symbol LI%n was defined.  */\n-#define ASM_OUTPUT_CASE_END(FILE,NUM,TABLE)\t\t\\\n-{ if (switch_table_difference_label_flag)\t\t\\\n-    asm_fprintf (FILE, \"\\t%s %LLD%d,%LL%d-%LLI%d-2.b\\n\",\\\n-\t\t SET_ASM_OP, (NUM), (NUM), (NUM))\t\\\n-  switch_table_difference_label_flag = 0; }\n-#endif\n \n-/* We have to define this to avoid errors.  */\n-int switch_table_difference_label_flag;\n+/* sysV68 as cannot handle LD%n(%pc,%reg) */ \n+#define SGS_NO_LI\n+\n+/* labelno is not used here */\n+#define ASM_OUTPUT_CASE_FETCH(file, labelno, regname)\\\n+\tasm_fprintf (file, \"12(%Rpc,%s.\", regname)\n \n+#define ASM_RETURN_CASE_JUMP   return \"jmp 8(%%pc,%0.w)\"\n+\t     \n /* Translate some opcodes to fit the sysV68 assembler syntax.  */\n /* The opcodes fdmov and fsmov are guesses.  */\n \n-#define SWITCH_JUMP_MATCH   \"jmp 6(%%pc,\"\n-\n /* cliffm@netcom.com says no need for .w suffix on jumps.  */\n #undef ASM_OUTPUT_OPCODE\n #define ASM_OUTPUT_OPCODE(FILE, PTR)\t\t\t\\\n@@ -749,10 +455,6 @@ int switch_table_difference_label_flag;\n     { fprintf ((FILE), \"cmp\"); (PTR) += 3;\t\t\\\n        if ((PTR)[0] == 'a' || (PTR)[0] == 'i'\t \t\\\n \t   || (PTR)[0] == 'm') (PTR)++; }\t\t\\\n-/* JMP to switch label */\t\t\t\t\\\n-  else if (!strncmp((PTR), (SWITCH_JUMP_MATCH), sizeof(SWITCH_JUMP_MATCH) - 1)) \\\n-    { while (*(PTR)++ != '(');\t\t\t\t\\\n-      fprintf ((FILE), \"jmp 8(\"); }\t\t\t\\\n }\n \n /* phdm@info.ucl.ac.be says to pass SIZE, not ROUNDED.  */"}]}