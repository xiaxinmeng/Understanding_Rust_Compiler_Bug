{"sha": "4a5ba3ed87794d7ea5ab54d0c89cf6cedd0e6c9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE1YmEzZWQ4Nzc5NGQ3ZWE1YWI1NGQwYzg5Y2Y2Y2VkZDBlNmM5Zg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-04-14T13:38:33Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-04-14T13:38:33Z"}, "message": "tree-ssa-dse.c (struct dse_global_data, [...]): Remove.\n\n2011-04-14  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-dse.c (struct dse_global_data, struct dse_block_local_data):\n\tRemove.\n\t(dse_initialize_block_local_data, dse_leave_block,\n\trecord_voperand_set, get_stmt_uid): Likewise.\n\t(dse_possible_dead_store_p): Allow any kind of killing stmt.\n\t(dse_optimize_stmt): Remove voperand set handling code.\n\tSimplify and improve to handle any kind of killing stmt.\n\t(dse_record_phi): Remove.\n\t(dse_enter_block): Simplify.\n\t(tree_ssa_dse): Likewise.\n\t* tree-ssa-alias.c (stmt_kills_ref_p_1): Handle some builtins.\n\n\t* gcc.dg/tree-ssa/ssa-dse-14.c: New testcase.\n\nFrom-SVN: r172431", "tree": {"sha": "63beaf8039be953cc4acc9dc13786c2c6a7879d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63beaf8039be953cc4acc9dc13786c2c6a7879d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a5ba3ed87794d7ea5ab54d0c89cf6cedd0e6c9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a5ba3ed87794d7ea5ab54d0c89cf6cedd0e6c9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a5ba3ed87794d7ea5ab54d0c89cf6cedd0e6c9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a5ba3ed87794d7ea5ab54d0c89cf6cedd0e6c9f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10a5dd5d3d4cc53613b8e44b78e99b7d61f85d77"}], "stats": {"total": 243, "additions": 99, "deletions": 144}, "files": [{"sha": "bf936e8178e5da7f306908b1322c35ab6d5b827c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a5ba3ed87794d7ea5ab54d0c89cf6cedd0e6c9f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a5ba3ed87794d7ea5ab54d0c89cf6cedd0e6c9f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a5ba3ed87794d7ea5ab54d0c89cf6cedd0e6c9f", "patch": "@@ -1,3 +1,17 @@\n+2011-04-14  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-dse.c (struct dse_global_data, struct dse_block_local_data):\n+\tRemove.\n+\t(dse_initialize_block_local_data, dse_leave_block,\n+\trecord_voperand_set, get_stmt_uid): Likewise.\n+\t(dse_possible_dead_store_p): Allow any kind of killing stmt.\n+\t(dse_optimize_stmt): Remove voperand set handling code.\n+\tSimplify and improve to handle any kind of killing stmt.\n+\t(dse_record_phi): Remove.\n+\t(dse_enter_block): Simplify.\n+\t(tree_ssa_dse): Likewise.\n+\t* tree-ssa-alias.c (stmt_kills_ref_p_1): Handle some builtins.\n+\n 2011-04-14  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.c (dump_cgraph_node): Do not dump inline summaries."}, {"sha": "ffca004140f85b0c25bbe6223677c74d4eb30291", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a5ba3ed87794d7ea5ab54d0c89cf6cedd0e6c9f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a5ba3ed87794d7ea5ab54d0c89cf6cedd0e6c9f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4a5ba3ed87794d7ea5ab54d0c89cf6cedd0e6c9f", "patch": "@@ -1,3 +1,7 @@\n+2011-04-14  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/ssa-dse-14.c: New testcase.\n+\n 2011-04-14  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/fold-bitand-4.c: Move ..."}, {"sha": "1c74596adbab87ce616e10e87269d7f67befec25", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-14.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a5ba3ed87794d7ea5ab54d0c89cf6cedd0e6c9f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a5ba3ed87794d7ea5ab54d0c89cf6cedd0e6c9f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-14.c?ref=4a5ba3ed87794d7ea5ab54d0c89cf6cedd0e6c9f", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-dse1-details\" } */\n+\n+struct A { char c[4]; } a, b;\n+\n+void\n+f1 (void)\n+{\n+  a.c[2] = '\\0';\n+  __builtin_memset (&a.c[1], 1, 2);\n+}\n+\n+void\n+f2 (void)\n+{\n+  __builtin_memcpy (&a.c[0], \"a\", 1);\n+  __builtin_memcpy (&a, &b, 3);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Deleted dead store\" 2 \"dse1\" } } */\n+/* { dg-final { cleanup-tree-dump \"dse1\" } } */"}, {"sha": "67ba8f1323cbed25b97a38ea580cf769e517128a", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 47, "deletions": 4, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a5ba3ed87794d7ea5ab54d0c89cf6cedd0e6c9f/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a5ba3ed87794d7ea5ab54d0c89cf6cedd0e6c9f/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=4a5ba3ed87794d7ea5ab54d0c89cf6cedd0e6c9f", "patch": "@@ -1616,28 +1616,71 @@ stmt_may_clobber_ref_p (gimple stmt, tree ref)\n static bool\n stmt_kills_ref_p_1 (gimple stmt, ao_ref *ref)\n {\n+  /* For a must-alias check we need to be able to constrain\n+     the access properly.  */\n+  ao_ref_base (ref);\n+  if (ref->max_size == -1)\n+    return false;\n+\n   if (gimple_has_lhs (stmt)\n       && TREE_CODE (gimple_get_lhs (stmt)) != SSA_NAME)\n     {\n       tree base, lhs = gimple_get_lhs (stmt);\n       HOST_WIDE_INT size, offset, max_size;\n-      ao_ref_base (ref);\n       base = get_ref_base_and_extent (lhs, &offset, &size, &max_size);\n       /* We can get MEM[symbol: sZ, index: D.8862_1] here,\n \t so base == ref->base does not always hold.  */\n       if (base == ref->base)\n \t{\n \t  /* For a must-alias check we need to be able to constrain\n-\t     the accesses properly.  */\n-\t  if (size != -1 && size == max_size\n-\t      && ref->max_size != -1)\n+\t     the access properly.  */\n+\t  if (size != -1 && size == max_size)\n \t    {\n \t      if (offset <= ref->offset\n \t\t  && offset + size >= ref->offset + ref->max_size)\n \t\treturn true;\n \t    }\n \t}\n     }\n+\n+  if (is_gimple_call (stmt))\n+    {\n+      tree callee = gimple_call_fndecl (stmt);\n+      if (callee != NULL_TREE\n+\t  && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL)\n+\tswitch (DECL_FUNCTION_CODE (callee))\n+\t  {\n+\t  case BUILT_IN_MEMCPY:\n+\t  case BUILT_IN_MEMPCPY:\n+\t  case BUILT_IN_MEMMOVE:\n+\t  case BUILT_IN_MEMSET:\n+\t    {\n+\t      tree dest = gimple_call_arg (stmt, 0);\n+\t      tree len = gimple_call_arg (stmt, 2);\n+\t      tree base = NULL_TREE;\n+\t      HOST_WIDE_INT offset = 0;\n+\t      if (!host_integerp (len, 0))\n+\t\treturn false;\n+\t      if (TREE_CODE (dest) == ADDR_EXPR)\n+\t\tbase = get_addr_base_and_unit_offset (TREE_OPERAND (dest, 0),\n+\t\t\t\t\t\t      &offset);\n+\t      else if (TREE_CODE (dest) == SSA_NAME)\n+\t\tbase = dest;\n+\t      if (base\n+\t\t  && base == ao_ref_base (ref))\n+\t\t{\n+\t\t  HOST_WIDE_INT size = TREE_INT_CST_LOW (len);\n+\t\t  if (offset <= ref->offset / BITS_PER_UNIT\n+\t\t      && (offset + size\n+\t\t          >= ((ref->offset + ref->max_size + BITS_PER_UNIT - 1)\n+\t\t\t      / BITS_PER_UNIT)))\n+\t\t    return true;\n+\t\t}\n+\t    }\n+\t  default:;\n+\t  }\n+\n+    }\n   return false;\n }\n "}, {"sha": "6d51dabced63aeeea66bf560b24f55759338fd88", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 13, "deletions": 140, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a5ba3ed87794d7ea5ab54d0c89cf6cedd0e6c9f/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a5ba3ed87794d7ea5ab54d0c89cf6cedd0e6c9f/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=4a5ba3ed87794d7ea5ab54d0c89cf6cedd0e6c9f", "patch": "@@ -65,84 +65,14 @@ along with GCC; see the file COPYING3.  If not see\n    the CFG.  */\n \n \n-struct dse_global_data\n-{\n-  /* This is the global bitmap for store statements.\n-\n-     Each statement has a unique ID.  When we encounter a store statement\n-     that we want to record, set the bit corresponding to the statement's\n-     unique ID in this bitmap.  */\n-  bitmap stores;\n-};\n-\n-/* We allocate a bitmap-per-block for stores which are encountered\n-   during the scan of that block.  This allows us to restore the\n-   global bitmap of stores when we finish processing a block.  */\n-struct dse_block_local_data\n-{\n-  bitmap stores;\n-};\n-\n /* Bitmap of blocks that have had EH statements cleaned.  We should\n    remove their dead edges eventually.  */\n static bitmap need_eh_cleanup;\n \n static bool gate_dse (void);\n static unsigned int tree_ssa_dse (void);\n-static void dse_initialize_block_local_data (struct dom_walk_data *,\n-\t\t\t\t\t     basic_block,\n-\t\t\t\t\t     bool);\n static void dse_enter_block (struct dom_walk_data *, basic_block);\n-static void dse_leave_block (struct dom_walk_data *, basic_block);\n-static void record_voperand_set (bitmap, bitmap *, unsigned int);\n-\n-/* Returns uid of statement STMT.  */\n-\n-static unsigned\n-get_stmt_uid (gimple stmt)\n-{\n-  if (gimple_code (stmt) == GIMPLE_PHI)\n-    return SSA_NAME_VERSION (gimple_phi_result (stmt))\n-           + gimple_stmt_max_uid (cfun);\n-\n-  return gimple_uid (stmt);\n-}\n-\n-/* Set bit UID in bitmaps GLOBAL and *LOCAL, creating *LOCAL as needed.  */\n-\n-static void\n-record_voperand_set (bitmap global, bitmap *local, unsigned int uid)\n-{\n-  /* Lazily allocate the bitmap.  Note that we do not get a notification\n-     when the block local data structures die, so we allocate the local\n-     bitmap backed by the GC system.  */\n-  if (*local == NULL)\n-    *local = BITMAP_GGC_ALLOC ();\n-\n-  /* Set the bit in the local and global bitmaps.  */\n-  bitmap_set_bit (*local, uid);\n-  bitmap_set_bit (global, uid);\n-}\n-\n-/* Initialize block local data structures.  */\n \n-static void\n-dse_initialize_block_local_data (struct dom_walk_data *walk_data,\n-\t\t\t\t basic_block bb ATTRIBUTE_UNUSED,\n-\t\t\t\t bool recycled)\n-{\n-  struct dse_block_local_data *bd\n-    = (struct dse_block_local_data *)\n-\tVEC_last (void_p, walk_data->block_data_stack);\n-\n-  /* If we are given a recycled block local data structure, ensure any\n-     bitmap associated with the block is cleared.  */\n-  if (recycled)\n-    {\n-      if (bd->stores)\n-\tbitmap_clear (bd->stores);\n-    }\n-}\n \n /* A helper of dse_optimize_stmt.\n    Given a GIMPLE_ASSIGN in STMT, find a candidate statement *USE_STMT that\n@@ -251,9 +181,6 @@ dse_possible_dead_store_p (gimple stmt, gimple *use_stmt)\n      continue walking until both stores have equal reference trees.  */\n   while (!stmt_may_clobber_ref_p (temp, gimple_assign_lhs (stmt)));\n \n-  if (!is_gimple_assign (temp))\n-    return false;\n-\n   *use_stmt = temp;\n \n   return true;\n@@ -272,9 +199,7 @@ dse_possible_dead_store_p (gimple stmt, gimple *use_stmt)\n    post dominates the first store, then the first store is dead.  */\n \n static void\n-dse_optimize_stmt (struct dse_global_data *dse_gd,\n-\t\t   struct dse_block_local_data *bd,\n-\t\t   gimple_stmt_iterator gsi)\n+dse_optimize_stmt (gimple_stmt_iterator gsi)\n {\n   gimple stmt = gsi_stmt (gsi);\n \n@@ -295,19 +220,17 @@ dse_optimize_stmt (struct dse_global_data *dse_gd,\n     {\n       gimple use_stmt;\n \n-      record_voperand_set (dse_gd->stores, &bd->stores, gimple_uid (stmt));\n-\n       if (!dse_possible_dead_store_p (stmt, &use_stmt))\n \treturn;\n \n       /* If we have precisely one immediate use at this point and the\n \t stores are to the same memory location or there is a chain of\n \t virtual uses from stmt and the stmt which stores to that same\n \t memory location, then we may have found redundant store.  */\n-      if (bitmap_bit_p (dse_gd->stores, get_stmt_uid (use_stmt))\n-\t  && (operand_equal_p (gimple_assign_lhs (stmt),\n-\t\t\t       gimple_assign_lhs (use_stmt), 0)\n-\t      || stmt_kills_ref_p (use_stmt, gimple_assign_lhs (stmt))))\n+      if ((gimple_has_lhs (use_stmt)\n+\t   && (operand_equal_p (gimple_assign_lhs (stmt),\n+\t\t\t\tgimple_get_lhs (use_stmt), 0)))\n+\t  || stmt_kills_ref_p (use_stmt, gimple_assign_lhs (stmt)))\n \t{\n \t  /* If use_stmt is or might be a nop assignment, e.g. for\n \t     struct { ... } S a, b, *p; ...\n@@ -321,12 +244,7 @@ dse_optimize_stmt (struct dse_global_data *dse_gd,\n \t     acts as a use as well as definition, so store in STMT\n \t     is not dead.  */\n \t  if (stmt != use_stmt\n-\t      && !is_gimple_reg (gimple_assign_rhs1 (use_stmt))\n-\t      && !is_gimple_min_invariant (gimple_assign_rhs1 (use_stmt))\n-\t      /* ???  Should {} be invariant?  */\n-\t      && gimple_assign_rhs_code (use_stmt) != CONSTRUCTOR\n-\t      && refs_may_alias_p (gimple_assign_lhs (use_stmt),\n-\t\t\t\t   gimple_assign_rhs1 (use_stmt)))\n+\t      && ref_maybe_used_by_stmt_p (use_stmt, gimple_assign_lhs (stmt)))\n \t    return;\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -351,52 +269,14 @@ dse_optimize_stmt (struct dse_global_data *dse_gd,\n     }\n }\n \n-/* Record that we have seen the PHIs at the start of BB which correspond\n-   to virtual operands.  */\n-static void\n-dse_record_phi (struct dse_global_data *dse_gd,\n-\t\tstruct dse_block_local_data *bd,\n-\t\tgimple phi)\n-{\n-  if (!is_gimple_reg (gimple_phi_result (phi)))\n-    record_voperand_set (dse_gd->stores, &bd->stores, get_stmt_uid (phi));\n-}\n-\n static void\n-dse_enter_block (struct dom_walk_data *walk_data, basic_block bb)\n+dse_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t basic_block bb)\n {\n-  struct dse_block_local_data *bd\n-    = (struct dse_block_local_data *)\n-\tVEC_last (void_p, walk_data->block_data_stack);\n-  struct dse_global_data *dse_gd\n-    = (struct dse_global_data *) walk_data->global_data;\n   gimple_stmt_iterator gsi;\n \n   for (gsi = gsi_last (bb_seq (bb)); !gsi_end_p (gsi); gsi_prev (&gsi))\n-    dse_optimize_stmt (dse_gd, bd, gsi);\n-  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    dse_record_phi (dse_gd, bd, gsi_stmt (gsi));\n-}\n-\n-static void\n-dse_leave_block (struct dom_walk_data *walk_data,\n-\t\t basic_block bb ATTRIBUTE_UNUSED)\n-{\n-  struct dse_block_local_data *bd\n-    = (struct dse_block_local_data *)\n-\tVEC_last (void_p, walk_data->block_data_stack);\n-  struct dse_global_data *dse_gd\n-    = (struct dse_global_data *) walk_data->global_data;\n-  bitmap stores = dse_gd->stores;\n-  unsigned int i;\n-  bitmap_iterator bi;\n-\n-  /* Unwind the stores noted in this basic block.  */\n-  if (bd->stores)\n-    EXECUTE_IF_SET_IN_BITMAP (bd->stores, 0, i, bi)\n-      {\n-\tbitmap_clear_bit (stores, i);\n-      }\n+    dse_optimize_stmt (gsi);\n }\n \n /* Main entry point.  */\n@@ -405,7 +285,6 @@ static unsigned int\n tree_ssa_dse (void)\n {\n   struct dom_walk_data walk_data;\n-  struct dse_global_data dse_gd;\n \n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n \n@@ -421,15 +300,12 @@ tree_ssa_dse (void)\n   /* Dead store elimination is fundamentally a walk of the post-dominator\n      tree and a backwards walk of statements within each block.  */\n   walk_data.dom_direction = CDI_POST_DOMINATORS;\n-  walk_data.initialize_block_local_data = dse_initialize_block_local_data;\n+  walk_data.initialize_block_local_data = NULL;\n   walk_data.before_dom_children = dse_enter_block;\n-  walk_data.after_dom_children = dse_leave_block;\n+  walk_data.after_dom_children = NULL;\n \n-  walk_data.block_local_data_size = sizeof (struct dse_block_local_data);\n-\n-  /* This is the main hash table for the dead store elimination pass.  */\n-  dse_gd.stores = BITMAP_ALLOC (NULL);\n-  walk_data.global_data = &dse_gd;\n+  walk_data.block_local_data_size = 0;\n+  walk_data.global_data = NULL;\n \n   /* Initialize the dominator walker.  */\n   init_walk_dominator_tree (&walk_data);\n@@ -440,9 +316,6 @@ tree_ssa_dse (void)\n   /* Finalize the dominator walker.  */\n   fini_walk_dominator_tree (&walk_data);\n \n-  /* Release the main bitmap.  */\n-  BITMAP_FREE (dse_gd.stores);\n-\n   /* Removal of stores may make some EH edges dead.  Purge such edges from\n      the CFG as needed.  */\n   if (!bitmap_empty_p (need_eh_cleanup))"}]}