{"sha": "6489924b1237f0cc4c0df6de68467813f0f14b82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ4OTkyNGIxMjM3ZjBjYzRjMGRmNmRlNjg0Njc4MTNmMGYxNGI4Mg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-07T01:39:11Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-07T01:39:11Z"}, "message": "(main): Clear first_bracket_include for -I-.\n\nSet first_system_include for first system header directory.\n(is_system_include): Start search at first_system_include.\n\n(INCLUDE_LEN_FUDGE): Defined.\n(append_include_chain): New function.  Adds directory(ies)\nto include chain and updates value of max_include_len.\n(main, path_include): Use append_include_chain.\n(do_include): Use INCLUDE_LEN_FUDGE.\n\nFrom-SVN: r1488", "tree": {"sha": "3e4bba7ba0758d9f896e9f118a3d7f59e7fff88a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e4bba7ba0758d9f896e9f118a3d7f59e7fff88a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6489924b1237f0cc4c0df6de68467813f0f14b82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6489924b1237f0cc4c0df6de68467813f0f14b82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6489924b1237f0cc4c0df6de68467813f0f14b82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6489924b1237f0cc4c0df6de68467813f0f14b82/comments", "author": null, "committer": null, "parents": [{"sha": "47877ade8c7803b333ba24bc43a73f9f12932fbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47877ade8c7803b333ba24bc43a73f9f12932fbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47877ade8c7803b333ba24bc43a73f9f12932fbc"}], "stats": {"total": 144, "additions": 70, "deletions": 74}, "files": [{"sha": "58805a4972bda8cf8946447223d77b4e6cab76bf", "filename": "gcc/cccp.c", "status": "modified", "additions": 70, "deletions": 74, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6489924b1237f0cc4c0df6de68467813f0f14b82/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6489924b1237f0cc4c0df6de68467813f0f14b82/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=6489924b1237f0cc4c0df6de68467813f0f14b82", "patch": "@@ -102,6 +102,7 @@ static FILE * VMS_freopen ();\n static void hack_vms_include_specification ();\n typedef struct { unsigned :16, :16, :16; } vms_ino_t;\n #define ino_t vms_ino_t\n+#define INCLUDE_LEN_FUDGE 10\t/* leave room for VMS syntax conversion */\n #ifdef __GNUC__\n #define BSTRING\t\t\t/* VMS/GCC supplies the bstring routines */\n #endif /* __GNUC__ */\n@@ -128,6 +129,10 @@ typedef struct { unsigned :16, :16, :16; } vms_ino_t;\n #define NULL_PTR (char *) NULL\n #endif\n \n+#ifndef INCLUDE_LEN_FUDGE\n+#define INCLUDE_LEN_FUDGE 0\n+#endif\n+\n /* Exported declarations.  */\n \n char *xmalloc ();\n@@ -185,6 +190,7 @@ static int do_unassert ();\n static int do_warning ();\n \n static void add_import ();\n+static void append_include_chain ();\n static void deps_output ();\n static void make_undef ();\n static void make_definition ();\n@@ -515,7 +521,12 @@ static struct default_include *include_defaults = include_defaults_array;\n \n static struct file_name_list *include = 0;\t/* First dir to search */\n \t/* First dir to search for <file> */\n+/* This is the first element to use for #include <...>.\n+   If it is 0, use the entire chain for such includes.  */\n static struct file_name_list *first_bracket_include = 0;\n+/* This is the first element in the chain that corresponds to\n+   a directory of system header files.  */\n+static struct file_name_list *first_system_include = 0;\n static struct file_name_list *last_include = 0;\t/* Last in chain */\n \n /* Chain of include directories to put at the end of the other chain.  */\n@@ -957,14 +968,6 @@ main (argc, argv)\n   no_output = 0;\n   cplusplus = 0;\n \n-  for (i = 0; include_defaults[i].fname; i++)\n-    max_include_len = MAX (max_include_len,\n-\t\t\t   strlen (include_defaults[i].fname));\n-  /* Leave room for making file name longer when converting to VMS syntax.  */\n-#ifdef VMS\n-  max_include_len += 10;\n-#endif\n-\n   bzero (pend_files, argc * sizeof (char *));\n   bzero (pend_defs, argc * sizeof (char *));\n   bzero (pend_undefs, argc * sizeof (char *));\n@@ -1011,19 +1014,16 @@ main (argc, argv)\n \t    xmalloc (sizeof (struct file_name_list));\n \t  dirtmp->next = 0;\t/* New one goes on the end */\n \t  dirtmp->control_macro = 0;\n-\t  if (after_include == 0)\n-\t    after_include = dirtmp;\n-\t  else\n-\t    last_after_include->next = dirtmp;\n-\t  last_after_include = dirtmp; /* Tail follows the last one */\n-\n \t  if (i + 1 == argc)\n \t    fatal (\"Directory name missing after -idirafter option\");\n \t  else\n \t    dirtmp->fname = argv[++i];\n \n-\t  if (strlen (dirtmp->fname) > max_include_len)\n-\t    max_include_len = strlen (dirtmp->fname);\n+\t  if (after_include == 0)\n+\t    after_include = dirtmp;\n+\t  else\n+\t    last_after_include->next = dirtmp;\n+\t  last_after_include = dirtmp; /* Tail follows the last one */\n \t}\n \tbreak;\n \n@@ -1251,29 +1251,24 @@ main (argc, argv)\n \t{\n \t  struct file_name_list *dirtmp;\n \n-\t  if (! ignore_srcdir && !strcmp (argv[i] + 2, \"-\"))\n+\t  if (! ignore_srcdir && !strcmp (argv[i] + 2, \"-\")) {\n \t    ignore_srcdir = 1;\n+\t    /* Don't use any preceding -I directories for #include <...>.  */\n+\t    first_bracket_include = 0;\n+\t  }\n \t  else {\n \t    dirtmp = (struct file_name_list *)\n \t      xmalloc (sizeof (struct file_name_list));\n \t    dirtmp->next = 0;\t\t/* New one goes on the end */\n \t    dirtmp->control_macro = 0;\n-\t    if (include == 0)\n-\t      include = dirtmp;\n-\t    else\n-\t      last_include->next = dirtmp;\n-\t    last_include = dirtmp;\t/* Tail follows the last one */\n \t    if (argv[i][2] != 0)\n \t      dirtmp->fname = argv[i] + 2;\n \t    else if (i + 1 == argc)\n \t      fatal (\"Directory name missing after -I option\");\n \t    else\n \t      dirtmp->fname = argv[++i];\n-\t    if (strlen (dirtmp->fname) > max_include_len)\n-\t      max_include_len = strlen (dirtmp->fname);\n-\t    if (ignore_srcdir && first_bracket_include == 0)\n-\t      first_bracket_include = dirtmp;\n-\t    }\n+\t    append_include_chain (dirtmp, dirtmp);\n+\t  }\n \t}\n \tbreak;\n \n@@ -1478,7 +1473,7 @@ main (argc, argv)\n         if ((*endp == PATH_SEPARATOR\n #if 0 /* Obsolete, now that we use semicolons as the path separator.  */\n #ifdef __MSDOS__\n-\t     && (endp-startp != 1 || !isalpha (*startp)))\n+\t     && (endp-startp != 1 || !isalpha (*startp))\n #endif\n #endif\n \t     )\n@@ -1489,7 +1484,6 @@ main (argc, argv)\n \t  else\n \t    nstore[endp-startp] = '\\0';\n \n-\t  max_include_len = MAX (max_include_len, endp-startp+2);\n \t  include_defaults[num_dirs].fname = savestring (nstore);\n \t  include_defaults[num_dirs].cplusplus = cplusplus;\n \t  num_dirs++;\n@@ -1505,6 +1499,7 @@ main (argc, argv)\n     }\n   }\n \n+  first_system_include = 0;\n   /* Unless -fnostdinc,\n      tack on the standard include file dirs to the specified list */\n   if (!no_standard_includes) {\n@@ -1534,20 +1529,9 @@ main (argc, argv)\n \t    strcat (str, p->fname + default_len);\n \t    new->fname = str;\n \t    new->control_macro = 0;\n-\n-\t    /* Add elt to tail of list.  */\n-\t    if (include == 0)\n-\t      include = new;\n-\t    else\n-\t      last_include->next = new;\n-\t    /* Make sure list for #include <...> also has the standard dirs.  */\n-\t    if (ignore_srcdir && first_bracket_include == 0)\n-\t      first_bracket_include = new;\n-\t    /* Record new tail.  */\n-\t    last_include = new;\n-\t    /* Update max_include_len if necessary.  */\n-\t    if (this_len > max_include_len)\n-\t      max_include_len = this_len;\n+\t    append_include_chain (new, new);\n+\t    if (first_system_include == 0)\n+\t      first_system_include = new;\n \t  }\n \t}\n       }\n@@ -1558,32 +1542,18 @@ main (argc, argv)\n \tstruct file_name_list *new\n \t  = (struct file_name_list *) xmalloc (sizeof (struct file_name_list));\n \tnew->control_macro = 0;\n-\t/* Add elt to tail of list.  */\n-\tif (include == 0)\n-\t  include = new;\n-\telse\n-\t  last_include->next = new;\n-\t/* Make sure list for #include <...> also has the standard dirs.  */\n-\tif (ignore_srcdir && first_bracket_include == 0)\n-\t  first_bracket_include = new;\n-\t/* Record new tail.  */\n-\tlast_include = new;\n \tnew->fname = p->fname;\n+\tappend_include_chain (new, new);\n+\tif (first_system_include == 0)\n+\t  first_system_include = new;\n       }\n     }\n   }\n \n   /* Tack the after_include chain at the end of the include chain.  */\n-  if (last_include)\n-    last_include->next = after_include;\n-  else\n-    include = after_include;\n-  if (ignore_srcdir && first_bracket_include == 0)\n-    first_bracket_include = after_include;\n-\n-  /* Terminate the after_include chain.  */\n-  if (last_after_include)\n-    last_after_include->next = 0;\n+  append_include_chain (after_include, last_after_include);\n+  if (first_system_include == 0)\n+    first_system_include = after_include;\n \n   /* Scan the -imacros files before the main input.\n      Much like #including them, but with no_output set\n@@ -1861,16 +1831,8 @@ path_include (path)\n \txmalloc (sizeof (struct file_name_list));\n       dirtmp->next = 0;\t\t/* New one goes on the end */\n       dirtmp->control_macro = 0;\n-      if (include == 0)\n-\tinclude = dirtmp;\n-      else\n-\tlast_include->next = dirtmp;\n-      last_include = dirtmp;\t/* Tail follows the last one */\n       dirtmp->fname = name;\n-      if (strlen (dirtmp->fname) > max_include_len)\n-\tmax_include_len = strlen (dirtmp->fname);\n-      if (ignore_srcdir && first_bracket_include == 0)\n-\tfirst_bracket_include = dirtmp;\n+      append_include_chain (dirtmp, dirtmp);\n \n       /* Advance past this name.  */\n       p = q;\n@@ -3698,7 +3660,8 @@ do_include (buf, limit, op, keyword)\n \t      dsp[0].fname = (char *) alloca (n + 1);\n \t      strncpy (dsp[0].fname, nam, n);\n \t      dsp[0].fname[n] = '\\0';\n-\t      if (n > max_include_len) max_include_len = n;\n+\t      if (n + INCLUDE_LEN_FUDGE > max_include_len)\n+\t\tmax_include_len = n + INCLUDE_LEN_FUDGE;\n \t    } else {\n \t      dsp[0].fname = 0; /* Current directory */\n \t    }\n@@ -3974,7 +3937,7 @@ is_system_include (filename)\n {\n   struct file_name_list *searchptr;\n \n-  for (searchptr = first_bracket_include; searchptr;\n+  for (searchptr = first_system_include; searchptr;\n        searchptr = searchptr->next)\n     if (searchptr->fname) {\n       register char *sys_dir = searchptr->fname;\n@@ -8334,6 +8297,39 @@ make_assertion (option, str)\n   --indepth;\n }\n \f\n+/* Append a chain of `struct file_name_list's\n+   to the end of the main include chain.\n+   FIRST is the beginning of the chain to append, and LAST is the end.  */\n+\n+static void\n+append_include_chain (first, last)\n+     struct file_name_list *first, *last;\n+{\n+  struct file_name_list *dir;\n+\n+  if (!first || !last)\n+    return;\n+\n+  if (include == 0)\n+    include = first;\n+  else\n+    last_include->next = first;\n+\n+  if (first_bracket_include == 0)\n+    first_bracket_include = dir;\n+\n+  for (dir = first; ; dir = dir->next) {\n+    size_t len = strlen (dir->fname) + INCLUDE_LEN_FUDGE;\n+    if (len > max_include_len)\n+      max_include_len = len;\n+    if (dir == last)\n+      break;\n+  }\n+\n+  last->next = NULL;\n+  last_include = last;\n+}\n+\f\n /* Add output to `deps_buffer' for the -M switch.\n    STRING points to the text to be output.\n    SIZE is the number of bytes, or 0 meaning output until a null."}]}