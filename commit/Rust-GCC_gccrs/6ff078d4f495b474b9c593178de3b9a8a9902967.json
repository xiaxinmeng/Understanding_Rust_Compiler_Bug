{"sha": "6ff078d4f495b474b9c593178de3b9a8a9902967", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZmMDc4ZDRmNDk1YjQ3NGI5YzU5MzE3OGRlM2I5YThhOTkwMjk2Nw==", "commit": {"author": {"name": "Joey Ye", "email": "joey.ye@intel.com", "date": "2009-04-20T17:09:25Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2009-04-20T17:09:25Z"}, "message": "atom.md: Add bypasses with ix86_dep_by_shift_count.\n\n2009-04-20  Joey Ye  <joey.ye@intel.com>\n\t    Xuepeng Guo <xuepeng.guo@intel.com>\n\t    H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* config/i386/atom.md: Add bypasses with ix86_dep_by_shift_count.\n\n\t* config/i386/i386.c (LEA_SEARCH_THRESHOLD): New macro.\n\t(IX86_LEA_PRIORITY): Likewise.\n\t(distance_non_agu_define): New function.\n\t(distance_agu_use): Likewise.\n\t(ix86_lea_for_add_ok): Likewise.\n\t(ix86_dep_by_shift_count): Likewise.\n\n\t* config/i386/i386.md: Call ix86_lea_for_add_ok to decide we\n\tshould split for LEA.\n\n\t* config/i386/i386-protos.h (ix86_lea_for_add_ok): Declare new\n\tfunction.\n\t(ix86_dep_by_shift_count): Likewise.\n\nCo-Authored-By: H.J. Lu <hongjiu.lu@intel.com>\nCo-Authored-By: Xuepeng Guo <xuepeng.guo@intel.com>\n\nFrom-SVN: r146443", "tree": {"sha": "f3793a3a93ef77fcf4a477a298ef27298d1edd4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3793a3a93ef77fcf4a477a298ef27298d1edd4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ff078d4f495b474b9c593178de3b9a8a9902967", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ff078d4f495b474b9c593178de3b9a8a9902967", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ff078d4f495b474b9c593178de3b9a8a9902967", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ff078d4f495b474b9c593178de3b9a8a9902967/comments", "author": {"login": "npg-joey", "id": 81339828, "node_id": "MDQ6VXNlcjgxMzM5ODI4", "avatar_url": "https://avatars.githubusercontent.com/u/81339828?v=4", "gravatar_id": "", "url": "https://api.github.com/users/npg-joey", "html_url": "https://github.com/npg-joey", "followers_url": "https://api.github.com/users/npg-joey/followers", "following_url": "https://api.github.com/users/npg-joey/following{/other_user}", "gists_url": "https://api.github.com/users/npg-joey/gists{/gist_id}", "starred_url": "https://api.github.com/users/npg-joey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/npg-joey/subscriptions", "organizations_url": "https://api.github.com/users/npg-joey/orgs", "repos_url": "https://api.github.com/users/npg-joey/repos", "events_url": "https://api.github.com/users/npg-joey/events{/privacy}", "received_events_url": "https://api.github.com/users/npg-joey/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "87a5b4cc3c685ec64acccc0f9fa25b6a51f60f66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87a5b4cc3c685ec64acccc0f9fa25b6a51f60f66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87a5b4cc3c685ec64acccc0f9fa25b6a51f60f66"}], "stats": {"total": 364, "additions": 360, "deletions": 4}, "files": [{"sha": "64139976679603b745ac9865930bc2f55aa77d8a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff078d4f495b474b9c593178de3b9a8a9902967/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff078d4f495b474b9c593178de3b9a8a9902967/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ff078d4f495b474b9c593178de3b9a8a9902967", "patch": "@@ -1,3 +1,23 @@\n+2009-04-20  Joey Ye  <joey.ye@intel.com>\n+\t    Xuepeng Guo <xuepeng.guo@intel.com>\n+\t    H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* config/i386/atom.md: Add bypasses with ix86_dep_by_shift_count.\n+\n+\t* config/i386/i386.c (LEA_SEARCH_THRESHOLD): New macro.\n+\t(IX86_LEA_PRIORITY): Likewise.\n+\t(distance_non_agu_define): New function.\n+\t(distance_agu_use): Likewise.\n+\t(ix86_lea_for_add_ok): Likewise.\n+\t(ix86_dep_by_shift_count): Likewise.\n+\n+\t* config/i386/i386.md: Call ix86_lea_for_add_ok to decide we\n+\tshould split for LEA.\n+\n+\t* config/i386/i386-protos.h (ix86_lea_for_add_ok): Declare new\n+\tfunction.\n+\t(ix86_dep_by_shift_count): Likewise.\n+\n 2009-04-20  Richard Guenther  <rguenther@suse.de>\n \n \t* expr.c (handled_component_p): Move ..."}, {"sha": "a9c4c5d0576d7e3d5f40195164c1541aa02c3f71", "filename": "gcc/config/i386/atom.md", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff078d4f495b474b9c593178de3b9a8a9902967/gcc%2Fconfig%2Fi386%2Fatom.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff078d4f495b474b9c593178de3b9a8a9902967/gcc%2Fconfig%2Fi386%2Fatom.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fatom.md?ref=6ff078d4f495b474b9c593178de3b9a8a9902967", "patch": "@@ -768,3 +768,28 @@\n                   atom_alu1, atom_negnot, atom_incdec, atom_ishift,\n                   atom_ishift1, atom_rotate, atom_rotate1\"\n                  \"atom_icmov, atom_alu_carry\")\n+\n+;; lea to shift count stall is 2 cycles\n+(define_bypass 3 \"atom_lea\"\n+                 \"atom_ishift, atom_ishift1, atom_rotate, atom_rotate1,\n+                  atom_ishift_mem, atom_ishift1_mem, \n+                  atom_rotate_mem, atom_rotate1_mem\"\n+                 \"ix86_dep_by_shift_count\")\n+\n+;; lea to shift source stall is 1 cycle\n+(define_bypass 2 \"atom_lea\"\n+                 \"atom_ishift, atom_ishift1, atom_rotate, atom_rotate1\"\n+                 \"!ix86_dep_by_shift_count\")\n+\n+;; non-lea to shift count stall is 1 cycle\n+(define_bypass 2 \"atom_alu_carry,\n+                  atom_alu,atom_alu1,atom_negnot,atom_imov,atom_imovx,\n+                  atom_incdec,atom_ishift,atom_ishift1,atom_rotate,\n+                  atom_rotate1, atom_setcc, atom_icmov, atom_pop,\n+                  atom_alu_mem, atom_alu_carry_mem, atom_alu1_mem,\n+                  atom_imovx_mem, atom_imovx_2_mem,\n+                  atom_imov_mem, atom_icmov_mem, atom_fmov_mem\"\n+                 \"atom_ishift, atom_ishift1, atom_rotate, atom_rotate1,\n+                  atom_ishift_mem, atom_ishift1_mem, \n+                  atom_rotate_mem, atom_rotate1_mem\"\n+                 \"ix86_dep_by_shift_count\")"}, {"sha": "5d92ec79f601d740ca2bfcb720a949f2e751908f", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff078d4f495b474b9c593178de3b9a8a9902967/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff078d4f495b474b9c593178de3b9a8a9902967/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=6ff078d4f495b474b9c593178de3b9a8a9902967", "patch": "@@ -85,6 +85,8 @@ extern void ix86_fixup_binary_operands_no_copy (enum rtx_code,\n extern void ix86_expand_binary_operator (enum rtx_code,\n \t\t\t\t\t enum machine_mode, rtx[]);\n extern int ix86_binary_operator_ok (enum rtx_code, enum machine_mode, rtx[]);\n+extern bool ix86_lea_for_add_ok (enum rtx_code, rtx, rtx[]);\n+extern bool ix86_dep_by_shift_count (const_rtx set_insn, const_rtx use_insn);\n extern bool ix86_agi_dependent (rtx set_insn, rtx use_insn);\n extern void ix86_expand_unary_operator (enum rtx_code, enum machine_mode,\n \t\t\t\t\trtx[]);"}, {"sha": "5af19514f908b63f1c0789178c27d2d08a081da3", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff078d4f495b474b9c593178de3b9a8a9902967/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff078d4f495b474b9c593178de3b9a8a9902967/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6ff078d4f495b474b9c593178de3b9a8a9902967", "patch": "@@ -13012,6 +13012,316 @@ ix86_expand_unary_operator (enum rtx_code code, enum machine_mode mode,\n     emit_move_insn (operands[0], dst);\n }\n \n+#define LEA_SEARCH_THRESHOLD 12\n+\n+/* Search backward for non-agu definition of register number REGNO1\n+   or register number REGNO2 in INSN's basic block until \n+   1. Pass LEA_SEARCH_THRESHOLD instructions, or\n+   2. Reach BB boundary, or\n+   3. Reach agu definition.\n+   Returns the distance between the non-agu definition point and INSN.\n+   If no definition point, returns -1.  */\n+\n+static int\n+distance_non_agu_define (unsigned int regno1, unsigned int regno2,\n+\t\t\t rtx insn)\n+{\n+  basic_block bb = BLOCK_FOR_INSN (insn);\n+  int distance = 0;\n+  df_ref *def_rec;\n+  enum attr_type insn_type;\n+\n+  if (insn != BB_HEAD (bb))\n+    {\n+      rtx prev = PREV_INSN (insn);\n+      while (prev && distance < LEA_SEARCH_THRESHOLD)\n+\t{\n+\t  if (INSN_P (prev))\n+\t    {\n+\t      distance++;\n+              for (def_rec = DF_INSN_DEFS (prev); *def_rec; def_rec++)\n+                if (DF_REF_TYPE (*def_rec) == DF_REF_REG_DEF\n+                    && !DF_REF_IS_ARTIFICIAL (*def_rec)\n+                    && (regno1 == DF_REF_REGNO (*def_rec)\n+\t\t\t|| regno2 == DF_REF_REGNO (*def_rec)))\n+\t\t  {\n+\t\t    insn_type = get_attr_type (prev);\n+\t\t    if (insn_type != TYPE_LEA)\n+\t\t      goto done;\n+\t\t  }\n+\t    }\n+\t  if (prev == BB_HEAD (bb))\n+\t    break;\n+\t  prev = PREV_INSN (prev);\n+\t}\n+    }\n+  \n+  if (distance < LEA_SEARCH_THRESHOLD)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      bool simple_loop = false;\n+  \n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tif (e->src == bb)\n+\t  {\n+\t    simple_loop = true;\n+\t    break;\n+\t  }\n+  \n+      if (simple_loop)\n+\t{\n+\t  rtx prev = BB_END (bb);\n+\t  while (prev\n+\t\t && prev != insn\n+\t\t && distance < LEA_SEARCH_THRESHOLD)\n+\t    {\n+\t      if (INSN_P (prev))\n+\t\t{\n+\t\t  distance++;\n+\t\t  for (def_rec = DF_INSN_DEFS (prev); *def_rec; def_rec++)\n+\t\t    if (DF_REF_TYPE (*def_rec) == DF_REF_REG_DEF\n+\t\t\t&& !DF_REF_IS_ARTIFICIAL (*def_rec)\n+\t\t\t&& (regno1 == DF_REF_REGNO (*def_rec)\n+\t\t\t    || regno2 == DF_REF_REGNO (*def_rec)))\n+\t\t      {\n+\t\t\tinsn_type = get_attr_type (prev);\n+\t\t\tif (insn_type != TYPE_LEA)\n+\t\t\t  goto done;\n+\t\t      }\n+\t\t}\n+\t      prev = PREV_INSN (prev);\n+\t    }\n+\t}\n+    }\n+\n+  distance = -1;\n+\n+done:\n+  /* get_attr_type may modify recog data.  We want to make sure\n+     that recog data is valid for instruction INSN, on which\n+     distance_non_agu_define is called.  INSN is unchanged here.  */\n+  extract_insn_cached (insn);\n+  return distance;\n+}\n+\n+/* Return the distance between INSN and the next insn that uses \n+   register number REGNO0 in memory address.  Return -1 if no such\n+   a use is found within LEA_SEARCH_THRESHOLD or REGNO0 is set.  */\n+\n+static int\n+distance_agu_use (unsigned int regno0, rtx insn)\n+{\n+  basic_block bb = BLOCK_FOR_INSN (insn);\n+  int distance = 0;\n+  df_ref *def_rec;\n+  df_ref *use_rec;\n+\n+  if (insn != BB_END (bb))\n+    {\n+      rtx next = NEXT_INSN (insn);\n+      while (next && distance < LEA_SEARCH_THRESHOLD)\n+\t{\n+\t  if (INSN_P (next))\n+\t    {\n+\t      distance++;\n+\n+\t      for (use_rec = DF_INSN_USES (next); *use_rec; use_rec++)\n+\t\tif ((DF_REF_TYPE (*use_rec) == DF_REF_REG_MEM_LOAD\n+\t\t     || DF_REF_TYPE (*use_rec) == DF_REF_REG_MEM_STORE)\n+\t\t    && regno0 == DF_REF_REGNO (*use_rec))\n+\t\t  {\n+\t\t    /* Return DISTANCE if OP0 is used in memory\n+\t\t       address in NEXT.  */\n+\t\t    return distance;\n+\t\t  }\n+\n+\t      for (def_rec = DF_INSN_DEFS (next); *def_rec; def_rec++)\n+\t\tif (DF_REF_TYPE (*def_rec) == DF_REF_REG_DEF\n+\t\t    && !DF_REF_IS_ARTIFICIAL (*def_rec)\n+\t\t    && regno0 == DF_REF_REGNO (*def_rec))\n+\t\t  {\n+\t\t    /* Return -1 if OP0 is set in NEXT.  */\n+\t\t    return -1;\n+\t\t  }\n+\t    }\n+\t  if (next == BB_END (bb))\n+\t    break;\n+\t  next = NEXT_INSN (next);\n+\t}\n+    }\n+\n+  if (distance < LEA_SEARCH_THRESHOLD)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      bool simple_loop = false;\n+  \n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+        if (e->dest == bb)\n+\t  {\n+\t    simple_loop = true;\n+\t    break;\n+\t  }\n+  \n+      if (simple_loop)\n+\t{\n+\t  rtx next = BB_HEAD (bb);\n+\t  while (next\n+\t\t && next != insn\n+\t\t && distance < LEA_SEARCH_THRESHOLD)\n+\t    {\n+\t      if (INSN_P (next))\n+\t\t{\n+\t\t  distance++;\n+\n+\t\t  for (use_rec = DF_INSN_USES (next); *use_rec; use_rec++)\n+\t\t    if ((DF_REF_TYPE (*use_rec) == DF_REF_REG_MEM_LOAD\n+\t\t\t || DF_REF_TYPE (*use_rec) == DF_REF_REG_MEM_STORE)\n+\t\t\t&& regno0 == DF_REF_REGNO (*use_rec))\n+\t\t      {\n+\t\t\t/* Return DISTANCE if OP0 is used in memory\n+\t\t\t   address in NEXT.  */\n+\t\t\treturn distance;\n+\t\t      }\n+\n+\t\t  for (def_rec = DF_INSN_DEFS (next); *def_rec; def_rec++)\n+\t\t    if (DF_REF_TYPE (*def_rec) == DF_REF_REG_DEF\n+\t\t\t&& !DF_REF_IS_ARTIFICIAL (*def_rec)\n+\t\t\t&& regno0 == DF_REF_REGNO (*def_rec))\n+\t\t      {\n+\t\t\t/* Return -1 if OP0 is set in NEXT.  */\n+\t\t\treturn -1;\n+\t\t      }\n+\n+\t\t}\n+\t      next = NEXT_INSN (next);\n+\t    }\n+\t}\n+    }  \n+\n+  return -1;\n+}\n+\n+/* Define this macro to tune LEA priority vs ADD, it take effect when\n+   there is a dilemma of choicing LEA or ADD\n+   Negative value: ADD is more preferred than LEA\n+   Zero: Netrual\n+   Positive value: LEA is more preferred than ADD*/\n+#define IX86_LEA_PRIORITY 2\n+\n+/* Return true if it is ok to optimize an ADD operation to LEA\n+   operation to avoid flag register consumation.  For the processors\n+   like ATOM, if the destination register of LEA holds an actual\n+   address which will be used soon, LEA is better and otherwise ADD\n+   is better.  */\n+\n+bool\n+ix86_lea_for_add_ok (enum rtx_code code ATTRIBUTE_UNUSED,\n+                     rtx insn, rtx operands[])\n+{\n+  unsigned int regno0 = true_regnum (operands[0]);\n+  unsigned int regno1 = true_regnum (operands[1]);\n+  unsigned int regno2;\n+\n+  if (!TARGET_OPT_AGU || optimize_function_for_size_p (cfun))\n+    return regno0 != regno1;\n+\n+  regno2 = true_regnum (operands[2]);\n+\n+  /* If a = b + c, (a!=b && a!=c), must use lea form. */\n+  if (regno0 != regno1 && regno0 != regno2)\n+    return true;\n+  else    \n+    {\n+      int dist_define, dist_use;\n+      dist_define = distance_non_agu_define (regno1, regno2, insn);\n+      if (dist_define <= 0)\n+        return true;\n+\n+      /* If this insn has both backward non-agu dependence and forward\n+         agu dependence, the one with short distance take effect. */\n+      dist_use = distance_agu_use (regno0, insn);\n+      if (dist_use <= 0\n+\t  || (dist_define + IX86_LEA_PRIORITY) < dist_use)\n+        return false;\n+\n+      return true;\n+    }\n+}\n+\n+/* Return true if destination reg of SET_BODY is shift count of\n+   USE_BODY.  */\n+\n+static bool\n+ix86_dep_by_shift_count_body (const_rtx set_body, const_rtx use_body)\n+{\n+  rtx set_dest;\n+  rtx shift_rtx;\n+  int i;\n+\n+  /* Retrieve destination of SET_BODY.  */\n+  switch (GET_CODE (set_body))\n+    {\n+    case SET:\n+      set_dest = SET_DEST (set_body);\n+      if (!set_dest || !REG_P (set_dest))\n+\treturn false;\n+      break;\n+    case PARALLEL:\n+      for (i = XVECLEN (set_body, 0) - 1; i >= 0; i--)\n+\tif (ix86_dep_by_shift_count_body (XVECEXP (set_body, 0, i),\n+\t\t\t\t\t  use_body))\n+\t  return true;\n+    default:\n+      return false;\n+      break;\n+    }\n+\n+  /* Retrieve shift count of USE_BODY.  */\n+  switch (GET_CODE (use_body))\n+    {\n+    case SET:\n+      shift_rtx = XEXP (use_body, 1);\n+      break;\n+    case PARALLEL:\n+      for (i = XVECLEN (use_body, 0) - 1; i >= 0; i--)\n+\tif (ix86_dep_by_shift_count_body (set_body,\n+\t\t\t\t\t  XVECEXP (use_body, 0, i)))\n+\t  return true;\n+    default:\n+      return false;\n+      break;\n+    }\n+\n+  if (shift_rtx \n+      && (GET_CODE (shift_rtx) == ASHIFT\n+\t  || GET_CODE (shift_rtx) == LSHIFTRT\n+\t  || GET_CODE (shift_rtx) == ASHIFTRT\n+\t  || GET_CODE (shift_rtx) == ROTATE\n+\t  || GET_CODE (shift_rtx) == ROTATERT))\n+    {\n+      rtx shift_count = XEXP (shift_rtx, 1);\n+\n+      /* Return true if shift count is dest of SET_BODY.  */\n+      if (REG_P (shift_count)\n+\t  && true_regnum (set_dest) == true_regnum (shift_count))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Return true if destination reg of SET_INSN is shift count of\n+   USE_INSN.  */\n+\n+bool\n+ix86_dep_by_shift_count (const_rtx set_insn, const_rtx use_insn)\n+{\n+  return ix86_dep_by_shift_count_body (PATTERN (set_insn),\n+\t\t\t\t       PATTERN (use_insn));\n+}\n+\n /* Return TRUE or FALSE depending on whether the unary operator meets the\n    appropriate constraints.  */\n "}, {"sha": "679d38a8a8961f2ce56f0c71159f6b25d6ef5d28", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff078d4f495b474b9c593178de3b9a8a9902967/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff078d4f495b474b9c593178de3b9a8a9902967/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=6ff078d4f495b474b9c593178de3b9a8a9902967", "patch": "@@ -6245,8 +6245,8 @@\n \t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n \t\t (match_operand:DI 2 \"x86_64_nonmemory_operand\" \"\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && reload_completed\n-   && true_regnum (operands[0]) != true_regnum (operands[1])\"\n+  \"TARGET_64BIT && reload_completed \n+   && ix86_lea_for_add_ok (PLUS, insn, operands)\"\n   [(set (match_dup 0)\n \t(plus:DI (match_dup 1)\n \t\t (match_dup 2)))]\n@@ -6514,8 +6514,7 @@\n \t(plus (match_operand 1 \"register_operand\" \"\")\n               (match_operand 2 \"nonmemory_operand\" \"\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed\n-   && true_regnum (operands[0]) != true_regnum (operands[1])\"\n+  \"reload_completed && ix86_lea_for_add_ok (PLUS, insn, operands)\" \n   [(const_int 0)]\n {\n   rtx pat;"}]}