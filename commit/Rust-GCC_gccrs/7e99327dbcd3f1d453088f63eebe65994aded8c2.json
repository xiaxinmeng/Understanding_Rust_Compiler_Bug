{"sha": "7e99327dbcd3f1d453088f63eebe65994aded8c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U5OTMyN2RiY2QzZjFkNDUzMDg4ZjYzZWViZTY1OTk0YWRlZDhjMg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-09-01T19:18:03Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-09-01T19:18:03Z"}, "message": "re PR c++/12114 ([3.3.2] Uninitialized memory accessed in dtor)\n\n\tPR c++/12114\n\t* g++.dg/init/ref9.C: New test.\n\n\tPR c++/11972\n\t* g++.dg/template/nested4.C: New test.\n\n\tPR c++/12114\n\t* cp-tree.h (initialize_reference): Change prototype.\n\t* call.c (initialize_reference): Add cleanup parameter.\n\t* decl.c (grok_reference_init): Likewise.\n\t(check_initializer): Likewise.\n\t(cp_finish_decl): Insert a CLEANUP_STMT if necessary.\n\t(duplicate_decls): When replacing an anticipated builtin, do not\n\thonor TREE_NOTHROW.\n\t* typeck.c (convert_for_initialization): Correct call to\n\tinitialize_reference.\n\n\tPR c++/11972\n\t* pt.c (dependent_type_p_r): Pass only the innermost template\n\targuments to any_dependent_template_arguments_p.\n\nFrom-SVN: r70981", "tree": {"sha": "3ba8f4e6715b6c18572eca713097806119e13254", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ba8f4e6715b6c18572eca713097806119e13254"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e99327dbcd3f1d453088f63eebe65994aded8c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e99327dbcd3f1d453088f63eebe65994aded8c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e99327dbcd3f1d453088f63eebe65994aded8c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e99327dbcd3f1d453088f63eebe65994aded8c2/comments", "author": null, "committer": null, "parents": [{"sha": "4b09846beff900c43203222269e235d3b6d56a47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b09846beff900c43203222269e235d3b6d56a47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b09846beff900c43203222269e235d3b6d56a47"}], "stats": {"total": 167, "additions": 140, "deletions": 27}, "files": [{"sha": "326da4ba433ae7cd9f7ec101d3a5b165999a13fc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e99327dbcd3f1d453088f63eebe65994aded8c2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e99327dbcd3f1d453088f63eebe65994aded8c2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7e99327dbcd3f1d453088f63eebe65994aded8c2", "patch": "@@ -1,3 +1,20 @@\n+2003-09-01  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/12114\n+\t* cp-tree.h (initialize_reference): Change prototype.\n+\t* call.c (initialize_reference): Add cleanup parameter.\n+\t* decl.c (grok_reference_init): Likewise.\n+\t(check_initializer): Likewise.\n+\t(cp_finish_decl): Insert a CLEANUP_STMT if necessary.\n+\t(duplicate_decls): When replacing an anticipated builtin, do not\n+\thonor TREE_NOTHROW.\n+\t* typeck.c (convert_for_initialization): Correct call to\n+\tinitialize_reference.\n+\n+\tPR c++/11972\n+\t* pt.c (dependent_type_p_r): Pass only the innermost template\n+\targuments to any_dependent_template_arguments_p.\n+\n 2003-09-01  Josef Zlomek  <zlomekj@suse.cz>\n \n \t* error.c (dump_expr): Kill BIT_ANDTC_EXPR."}, {"sha": "9e46282abd0a62b9a2f8a5a8b9dee17fc9c8322a", "filename": "gcc/cp/call.c", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e99327dbcd3f1d453088f63eebe65994aded8c2/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e99327dbcd3f1d453088f63eebe65994aded8c2/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=7e99327dbcd3f1d453088f63eebe65994aded8c2", "patch": "@@ -6005,14 +6005,18 @@ make_temporary_var_for_ref_to_temp (tree decl, tree type)\n }\n \n /* Convert EXPR to the indicated reference TYPE, in a way suitable for\n-   initializing a variable of that TYPE.   If DECL is non-NULL, it is\n+   initializing a variable of that TYPE.  If DECL is non-NULL, it is\n    the VAR_DECL being initialized with the EXPR.  (In that case, the\n-   type of DECL will be TYPE.)\n+   type of DECL will be TYPE.)  If DECL is non-NULL, then CLEANUP must\n+   also be non-NULL, and with *CLEANUP initialized to NULL.  Upon\n+   return, if *CLEANUP is no longer NULL, it will be a CLEANUP_STMT\n+   that should be inserted after the returned expression is used to\n+   initialize DECL.\n \n    Return the converted expression.  */\n \n tree\n-initialize_reference (tree type, tree expr, tree decl)\n+initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n {\n   tree conv;\n \n@@ -6094,14 +6098,33 @@ initialize_reference (tree type, tree expr, tree decl)\n \t  type = TREE_TYPE (expr);\n \t  var = make_temporary_var_for_ref_to_temp (decl, type);\n \t  layout_decl (var, 0);\n+\t  /* Create the INIT_EXPR that will initialize the temporary\n+\t     variable.  */\n+\t  init = build (INIT_EXPR, type, var, expr);\n \t  if (at_function_scope_p ())\n \t    {\n-\t      tree cleanup;\n-\n \t      add_decl_stmt (var);\n-\t      cleanup = cxx_maybe_build_cleanup (var);\n-\t      if (cleanup)\n-\t\tfinish_decl_cleanup (var, cleanup);\n+\t      *cleanup = cxx_maybe_build_cleanup (var);\n+\t      if (*cleanup)\n+\t\t/* We must be careful to destroy the temporary only\n+\t\t   after its initialization has taken place.  If the\n+\t\t   initialization throws an exception, then the\n+\t\t   destructor should not be run.  We cannot simply\n+\t\t   transform INIT into something like:\n+\t     \n+\t\t     (INIT, ({ CLEANUP_STMT; }))\n+\n+\t\t   because emit_local_var always treats the\n+\t\t   initializer as a full-expression.  Thus, the\n+\t\t   destructor would run too early; it would run at the\n+\t\t   end of initializing the reference variable, rather\n+\t\t   than at the end of the block enclosing the\n+\t\t   reference variable.\n+\n+\t\t   The solution is to pass back a CLEANUP_STMT which\n+\t\t   the caller is responsible for attaching to the\n+\t\t   statement tree.  */\n+\t\t*cleanup = build_stmt (CLEANUP_STMT, var, *cleanup);\n \t    }\n \t  else\n \t    {\n@@ -6110,7 +6133,6 @@ initialize_reference (tree type, tree expr, tree decl)\n \t\tstatic_aggregates = tree_cons (NULL_TREE, var,\n \t\t\t\t\t       static_aggregates);\n \t    }\n-\t  init = build (INIT_EXPR, type, var, expr);\n \t  /* Use its address to initialize the reference variable.  */\n \t  expr = build_address (var);\n \t  expr = build (COMPOUND_EXPR, TREE_TYPE (expr), init, expr);"}, {"sha": "f17b67c2d0071dbec57f07e765852ba2b21e77ce", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e99327dbcd3f1d453088f63eebe65994aded8c2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e99327dbcd3f1d453088f63eebe65994aded8c2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7e99327dbcd3f1d453088f63eebe65994aded8c2", "patch": "@@ -3524,7 +3524,7 @@ extern tree type_passed_as (tree);\n extern tree convert_for_arg_passing (tree, tree);\n extern tree cp_convert_parm_for_inlining        (tree, tree, tree);\n extern bool is_properly_derived_from (tree, tree);\n-extern tree initialize_reference (tree, tree, tree);\n+extern tree initialize_reference (tree, tree, tree, tree *);\n extern tree make_temporary_var_for_ref_to_temp (tree, tree);\n extern tree strip_top_quals (tree);\n extern tree perform_implicit_conversion (tree, tree);"}, {"sha": "4c287ea7158be7e5405be9ba17df18344d89d97c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e99327dbcd3f1d453088f63eebe65994aded8c2/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e99327dbcd3f1d453088f63eebe65994aded8c2/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=7e99327dbcd3f1d453088f63eebe65994aded8c2", "patch": "@@ -68,7 +68,7 @@ static cxx_saved_binding *store_bindings (tree, cxx_saved_binding *);\n static tree lookup_tag_reverse (tree, tree);\n static void push_local_name (tree);\n static void warn_extern_redeclared_static (tree, tree);\n-static tree grok_reference_init (tree, tree, tree);\n+static tree grok_reference_init (tree, tree, tree, tree *);\n static tree grokfndecl (tree, tree, tree, tree, int,\n \t\t\tenum overload_flags, tree,\n \t\t\ttree, int, int, int, int, int, int, tree);\n@@ -117,7 +117,7 @@ static void pop_labels (tree);\n static void maybe_deduce_size_from_array_init (tree, tree);\n static void layout_var_decl (tree);\n static void maybe_commonize_var (tree);\n-static tree check_initializer (tree, tree, int);\n+static tree check_initializer (tree, tree, int, tree *);\n static void make_rtl_for_nonlocal_decl (tree, tree, const char *);\n static void save_function_data (tree);\n static void check_function_type (tree, tree);\n@@ -2940,9 +2940,9 @@ duplicate_decls (tree newdecl, tree olddecl)\n           if (DECL_ANTICIPATED (olddecl))\n             ;  /* Do nothing yet.  */\n \t  else if ((DECL_EXTERN_C_P (newdecl)\n-\t       && DECL_EXTERN_C_P (olddecl))\n-\t      || compparms (TYPE_ARG_TYPES (TREE_TYPE (newdecl)),\n-\t\t\t    TYPE_ARG_TYPES (TREE_TYPE (olddecl))))\n+\t\t    && DECL_EXTERN_C_P (olddecl))\n+\t\t   || compparms (TYPE_ARG_TYPES (TREE_TYPE (newdecl)),\n+\t\t\t\t TYPE_ARG_TYPES (TREE_TYPE (olddecl))))\n \t    {\n \t      /* A near match; override the builtin.  */\n \n@@ -2969,6 +2969,10 @@ duplicate_decls (tree newdecl, tree olddecl)\n       else if (DECL_ANTICIPATED (olddecl))\n \tTREE_TYPE (olddecl) = TREE_TYPE (newdecl);\n \n+      /* Whether or not the builtin can throw exceptions has no\n+\t bearing on this declarator.  */\n+      TREE_NOTHROW (olddecl) = 0;\n+\n       if (DECL_THIS_STATIC (newdecl) && !DECL_THIS_STATIC (olddecl))\n \t{\n \t  /* If a builtin function is redeclared as `static', merge\n@@ -7174,14 +7178,18 @@ start_decl_1 (tree decl)\n     DECL_INITIAL (decl) = NULL_TREE;\n }\n \n-/* Handle initialization of references.\n-   These three arguments are from `cp_finish_decl', and have the\n-   same meaning here that they do there.\n+/* Handle initialization of references.  DECL, TYPE, and INIT have the\n+   same meaning as in cp_finish_decl.  *CLEANUP must be NULL on entry,\n+   but will be set to a new CLEANUP_STMT if a temporary is created\n+   that must be destroeyd subsequently.\n+\n+   Returns an initializer expression to use to initialize DECL, or\n+   NULL if the initialization can be performed statically.\n \n    Quotes on semantics can be found in ARM 8.4.3.  */\n \n static tree\n-grok_reference_init (tree decl, tree type, tree init)\n+grok_reference_init (tree decl, tree type, tree init, tree *cleanup)\n {\n   tree tmp;\n \n@@ -7218,7 +7226,7 @@ grok_reference_init (tree decl, tree type, tree init)\n      DECL_INITIAL for local references (instead assigning to them\n      explicitly); we need to allow the temporary to be initialized\n      first.  */\n-  tmp = initialize_reference (type, init, decl);\n+  tmp = initialize_reference (type, init, decl, cleanup);\n \n   if (tmp == error_mark_node)\n     return NULL_TREE;\n@@ -7638,13 +7646,14 @@ reshape_init (tree type, tree *initp)\n }\n \n /* Verify INIT (the initializer for DECL), and record the\n-   initialization in DECL_INITIAL, if appropriate.  \n+   initialization in DECL_INITIAL, if appropriate.  CLEANUP is as for\n+   grok_reference_init.\n \n    If the return value is non-NULL, it is an expression that must be\n    evaluated dynamically to initialize DECL.  */\n \n static tree\n-check_initializer (tree decl, tree init, int flags)\n+check_initializer (tree decl, tree init, int flags, tree *cleanup)\n {\n   tree type = TREE_TYPE (decl);\n \n@@ -7694,7 +7703,7 @@ check_initializer (tree decl, tree init, int flags)\n       init = NULL_TREE;\n     }\n   else if (!DECL_EXTERNAL (decl) && TREE_CODE (type) == REFERENCE_TYPE)\n-    init = grok_reference_init (decl, type, init);\n+    init = grok_reference_init (decl, type, init, cleanup);\n   else if (init)\n     {\n       if (TREE_CODE (init) == CONSTRUCTOR && TREE_HAS_CONSTRUCTOR (init))\n@@ -8001,8 +8010,9 @@ initialize_local_var (tree decl, tree init)\n void\n cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n {\n-  register tree type;\n+  tree type;\n   tree ttype = NULL_TREE;\n+  tree cleanup;\n   const char *asmspec = NULL;\n   int was_readonly = 0;\n \n@@ -8015,6 +8025,9 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \n   my_friendly_assert (TREE_CODE (decl) != RESULT_DECL, 20030619);\n \n+  /* Assume no cleanup is required.  */\n+  cleanup = NULL_TREE;\n+\n   /* If a name was specified, get the string.  */\n   if (global_scope_p (current_binding_level))\n     asmspec_tree = maybe_apply_renaming_pragma (decl, asmspec_tree);\n@@ -8128,7 +8141,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \t     is *not* defined.  */\n \t  && (!DECL_EXTERNAL (decl) || init))\n \t{\n-\t  init = check_initializer (decl, init, flags);\n+\t  init = check_initializer (decl, init, flags, &cleanup);\n \t  /* Thread-local storage cannot be dynamically initialized.  */\n \t  if (DECL_THREAD_LOCAL (decl) && init)\n \t    {\n@@ -8244,6 +8257,11 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n       }\n     }\n \n+  /* If a CLEANUP_STMT was created to destroy a temporary bound to a\n+     reference, insert it in the statement-tree now.  */\n+  if (cleanup)\n+    add_stmt (cleanup);\n+\n  finish_end:\n \n   if (was_readonly)"}, {"sha": "8cf8d15ff8499baa0882413f33fa439ea008e5ad", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e99327dbcd3f1d453088f63eebe65994aded8c2/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e99327dbcd3f1d453088f63eebe65994aded8c2/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=7e99327dbcd3f1d453088f63eebe65994aded8c2", "patch": "@@ -11332,7 +11332,8 @@ dependent_type_p_r (tree type)\n   /* ... or any of the template arguments is a dependent type or\n \tan expression that is type-dependent or value-dependent.   */\n   else if (CLASS_TYPE_P (type) && CLASSTYPE_TEMPLATE_INFO (type)\n-      && any_dependent_template_arguments_p (CLASSTYPE_TI_ARGS (type)))\n+\t   && (any_dependent_template_arguments_p \n+\t       (INNERMOST_TEMPLATE_ARGS (CLASSTYPE_TI_ARGS (type)))))\n     return true;\n   \n   /* All TYPEOF_TYPEs are dependent; if the argument of the `typeof'"}, {"sha": "564b3373aecc69f4a6117bcab15653cd8e9115df", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e99327dbcd3f1d453088f63eebe65994aded8c2/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e99327dbcd3f1d453088f63eebe65994aded8c2/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=7e99327dbcd3f1d453088f63eebe65994aded8c2", "patch": "@@ -5657,7 +5657,8 @@ convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n \n       if (fndecl)\n \tsavew = warningcount, savee = errorcount;\n-      rhs = initialize_reference (type, rhs, /*decl=*/NULL_TREE);\n+      rhs = initialize_reference (type, rhs, /*decl=*/NULL_TREE,\n+\t\t\t\t  /*cleanup=*/NULL);\n       if (fndecl)\n \t{\n \t  if (warningcount > savew)"}, {"sha": "b62f69c9ffc879c26d407afdcdcacb9cc8ca4cff", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e99327dbcd3f1d453088f63eebe65994aded8c2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e99327dbcd3f1d453088f63eebe65994aded8c2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7e99327dbcd3f1d453088f63eebe65994aded8c2", "patch": "@@ -1,3 +1,11 @@\n+2003-09-01  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/12114\n+\t* g++.dg/init/ref9.C: New test.\n+\n+\tPR c++/11972\n+\t* g++.dg/template/nested4.C: New test.\n+\n 2003-08-29  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/12093"}, {"sha": "127b7d8e1fd327ae96d4cea4d51a918c92c1647b", "filename": "gcc/testsuite/g++.dg/init/ref9.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e99327dbcd3f1d453088f63eebe65994aded8c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fref9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e99327dbcd3f1d453088f63eebe65994aded8c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fref9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fref9.C?ref=7e99327dbcd3f1d453088f63eebe65994aded8c2", "patch": "@@ -0,0 +1,36 @@\n+// { dg-do run }\n+\n+struct ex;\n+struct basic {\n+  int refcount;\n+  ex eval() const;\n+  basic() : refcount(0) {}\n+};\n+\n+struct ex {\n+  basic *bp;\n+  ex() : bp(0) { }\n+  ex(const basic &);\n+  virtual ~ex();\n+  void construct_from_basic(const basic &);\n+};\n+\n+ex basic::eval() const {\n+  throw 1;\n+}\n+\n+inline ex::ex(const basic &b) { construct_from_basic (b); }\n+inline ex::~ex() { if (--bp->refcount == 0) delete bp; }\n+void ex::construct_from_basic(const basic &b) {\n+  const ex & tmpex = b.eval();\n+  bp = tmpex.bp;\n+  bp->refcount++;\n+}\n+\n+ex pow() { return basic(); }\n+\n+int main()\n+{\n+  try { pow (); } catch (int) {}\n+  return 0;\n+}"}, {"sha": "6e5b99b46c2330988bbcc645ef4bc78118165d6f", "filename": "gcc/testsuite/g++.dg/template/nested4.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e99327dbcd3f1d453088f63eebe65994aded8c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnested4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e99327dbcd3f1d453088f63eebe65994aded8c2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnested4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnested4.C?ref=7e99327dbcd3f1d453088f63eebe65994aded8c2", "patch": "@@ -0,0 +1,10 @@\n+template <typename T> struct A { \n+    template<typename S> struct B { typedef A<S> X; }; \n+ \n+}; \n+ \n+template<typename> void f() { \n+    typedef A<int>::B<double>::X X; \n+} \n+ \n+template void f<int> ();"}]}