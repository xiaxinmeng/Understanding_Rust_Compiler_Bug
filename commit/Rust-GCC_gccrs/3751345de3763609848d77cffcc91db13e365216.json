{"sha": "3751345de3763609848d77cffcc91db13e365216", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzc1MTM0NWRlMzc2MzYwOTg0OGQ3N2NmZmNjOTFkYjEzZTM2NTIxNg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2018-07-31T17:36:18Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2018-07-31T17:36:18Z"}, "message": "AArch64 - new pass to add conditional-branch speculation tracking\n\nThis patch is the main part of the speculation tracking code.  It adds\na new target-specific pass that is run just before the final branch\nreorg pass (so that it can clean up any new edge insertions we make).\nThe pass is only run with -mtrack-speculation is passed on the command\nline.\n\nOne thing that did come to light as part of this was that the stack pointer\nregister was not being permitted in comparision instructions.  We rely on\nthat for moving the tracking state between SP and the scratch register at\nfunction call boundaries.\n\n\t* config/aarch64/aarch64-speculation.cc: New file.\n\t* config/aarch64/aarch64-passes.def (pass_track_speculation): Add before\n\tpass_reorder_blocks.\n\t* config/aarch64/aarch64-protos.h (make_pass_track_speculation): Add\n\tprototype.\n\t* config/aarch64/aarch64.c (aarch64_conditional_register_usage): Fix\n\tX14 and X15 when tracking speculation.\n\t* config/aarch64/aarch64.md (register name constants): Add\n\tSPECULATION_TRACKER_REGNUM and SPECULATION_SCRATCH_REGNUM.\n\t(unspec): Add UNSPEC_SPECULATION_TRACKER.\n\t(speculation_barrier): New insn attribute.\n\t(cmp<mode>): Allow SP in comparisons.\n\t(speculation_tracker): New insn.\n\t(speculation_barrier): Add speculation_barrier attribute.\n\t* config/aarch64/t-aarch64: Add make rule for aarch64-speculation.o.\n\t* config.gcc (aarch64*-*-*): Add aarch64-speculation.o to extra_objs.\n\t* doc/invoke.texi (AArch64 Options): Document -mtrack-speculation.\n\nFrom-SVN: r263173", "tree": {"sha": "21b864feeb84786ba57c8b1c8d577ca04d5700ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21b864feeb84786ba57c8b1c8d577ca04d5700ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3751345de3763609848d77cffcc91db13e365216", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3751345de3763609848d77cffcc91db13e365216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3751345de3763609848d77cffcc91db13e365216", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3751345de3763609848d77cffcc91db13e365216/comments", "author": null, "committer": null, "parents": [{"sha": "6e1eaca96f745be9d40672c29cd2355c8b17b674", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e1eaca96f745be9d40672c29cd2355c8b17b674", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e1eaca96f745be9d40672c29cd2355c8b17b674"}], "stats": {"total": 583, "additions": 578, "deletions": 5}, "files": [{"sha": "c21608a178e67fe40104e7a2bbb168949a07fa49", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3751345de3763609848d77cffcc91db13e365216/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3751345de3763609848d77cffcc91db13e365216/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3751345de3763609848d77cffcc91db13e365216", "patch": "@@ -1,3 +1,23 @@\n+2018-07-31  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/aarch64/aarch64-speculation.cc: New file.\n+\t* config/aarch64/aarch64-passes.def (pass_track_speculation): Add\n+\tbefore pass_reorder_blocks.\n+\t* config/aarch64/aarch64-protos.h (make_pass_track_speculation): Add\n+\tprototype.\n+\t* config/aarch64/aarch64.c (aarch64_conditional_register_usage): Fix\n+\tX14 and X15 when tracking speculation.\n+\t* config/aarch64/aarch64.md (register name constants): Add\n+\tSPECULATION_TRACKER_REGNUM and SPECULATION_SCRATCH_REGNUM.\n+\t(unspec): Add UNSPEC_SPECULATION_TRACKER.\n+\t(speculation_barrier): New insn attribute.\n+\t(cmp<mode>): Allow SP in comparisons.\n+\t(speculation_tracker): New insn.\n+\t(speculation_barrier): Add speculation_barrier attribute.\n+\t* config/aarch64/t-aarch64: Add make rule for aarch64-speculation.o.\n+\t* config.gcc (aarch64*-*-*): Add aarch64-speculation.o to extra_objs.\n+\t* doc/invoke.texi (AArch64 Options): Document -mtrack-speculation.\n+\n 2018-07-31  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/aarch64/aarch64.md (cb<optab><mode>1): Disable when"}, {"sha": "b17fdbad1e5d6bf7871a6ace66c70e4dd6c8f95f", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3751345de3763609848d77cffcc91db13e365216/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3751345de3763609848d77cffcc91db13e365216/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=3751345de3763609848d77cffcc91db13e365216", "patch": "@@ -304,7 +304,7 @@ aarch64*-*-*)\n \textra_headers=\"arm_fp16.h arm_neon.h arm_acle.h\"\n \tc_target_objs=\"aarch64-c.o\"\n \tcxx_target_objs=\"aarch64-c.o\"\n-\textra_objs=\"aarch64-builtins.o aarch-common.o cortex-a57-fma-steering.o\"\n+\textra_objs=\"aarch64-builtins.o aarch-common.o cortex-a57-fma-steering.o aarch64-speculation.o\"\n \ttarget_gtfiles=\"\\$(srcdir)/config/aarch64/aarch64-builtins.c\"\n \ttarget_has_targetm_common=yes\n \t;;"}, {"sha": "3d6a254196ce17a3e8b62b8f8bbf7fe9e9dbebbd", "filename": "gcc/config/aarch64/aarch64-passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3751345de3763609848d77cffcc91db13e365216/gcc%2Fconfig%2Faarch64%2Faarch64-passes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3751345de3763609848d77cffcc91db13e365216/gcc%2Fconfig%2Faarch64%2Faarch64-passes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-passes.def?ref=3751345de3763609848d77cffcc91db13e365216", "patch": "@@ -19,3 +19,4 @@\n    <http://www.gnu.org/licenses/>.  */\n \n INSERT_PASS_AFTER (pass_regrename, 1, pass_fma_steering);\n+INSERT_PASS_BEFORE (pass_reorder_blocks, 1, pass_track_speculation);"}, {"sha": "ef95fc829b83886e2ff00e4664e31af916e99b0c", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3751345de3763609848d77cffcc91db13e365216/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3751345de3763609848d77cffcc91db13e365216/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=3751345de3763609848d77cffcc91db13e365216", "patch": "@@ -570,7 +570,8 @@ enum aarch64_parse_opt_result aarch64_parse_extension (const char *,\n std::string aarch64_get_extension_string_for_isa_flags (unsigned long,\n \t\t\t\t\t\t\tunsigned long);\n \n-rtl_opt_pass *make_pass_fma_steering (gcc::context *ctxt);\n+rtl_opt_pass *make_pass_fma_steering (gcc::context *);\n+rtl_opt_pass *make_pass_track_speculation (gcc::context *);\n \n poly_uint64 aarch64_regmode_natural_size (machine_mode);\n "}, {"sha": "2dd06ae24dd276eba3e85059ac22f493531671ca", "filename": "gcc/config/aarch64/aarch64-speculation.cc", "status": "added", "additions": 494, "deletions": 0, "changes": 494, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3751345de3763609848d77cffcc91db13e365216/gcc%2Fconfig%2Faarch64%2Faarch64-speculation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3751345de3763609848d77cffcc91db13e365216/gcc%2Fconfig%2Faarch64%2Faarch64-speculation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-speculation.cc?ref=3751345de3763609848d77cffcc91db13e365216", "patch": "@@ -0,0 +1,494 @@\n+/* Speculation tracking and mitigation (e.g. CVE 2017-5753) for AArch64.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by ARM Ltd.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"target.h\"\n+#include \"rtl.h\"\n+#include \"tree-pass.h\"\n+#include \"profile-count.h\"\n+#include \"cfg.h\"\n+#include \"cfgbuild.h\"\n+#include \"print-rtl.h\"\n+#include \"cfgrtl.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"memmodel.h\"\n+#include \"emit-rtl.h\"\n+#include \"insn-attr.h\"\n+#include \"df.h\"\n+#include \"tm_p.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+\n+/* This pass scans the RTL just before the final branch\n+   re-organisation pass.  The aim is to identify all places where\n+   there is conditional control flow and to insert code that tracks\n+   any speculative execution of a conditional branch.\n+\n+   To do this we reserve a call-clobbered register (so that it can be\n+   initialized very early in the function prologue) that can then be\n+   updated each time there is a conditional branch.  At each such\n+   branch we then generate a code sequence that uses conditional\n+   select operations that are not subject to speculation themselves\n+   (we ignore for the moment situations where that might not always be\n+   strictly true).  For example, a branch sequence such as:\n+\n+\tB.EQ\t<dst>\n+\t...\n+   <dst>:\n+\n+   is transformed to:\n+\n+\tB.EQ\t<dst>\n+\tCSEL\ttracker, tracker, XZr, ne\n+\t...\n+   <dst>:\n+\tCSEL\ttracker, tracker, XZr, eq\n+\n+   Since we start with the tracker initialized to all bits one, if at any\n+   time the predicted control flow diverges from the architectural program\n+   behavior, then the tracker will become zero (but not otherwise).\n+\n+   The tracker value can be used at any time at which a value needs\n+   guarding against incorrect speculation.  This can be done in\n+   several ways, but they all amount to the same thing.  For an\n+   untrusted address, or an untrusted offset to a trusted address, we\n+   can simply mask the address with the tracker with the untrusted\n+   value.  If the CPU is not speculating, or speculating correctly,\n+   then the value will remain unchanged, otherwise it will be clamped\n+   to zero.  For more complex scenarios we can compare the tracker\n+   against zero and use the flags to form a new selection with an\n+   alternate safe value.\n+\n+   On implementations where the data processing instructions may\n+   themselves produce speculative values, the architecture requires\n+   that a CSDB instruction will resolve such data speculation, so each\n+   time we use the tracker for protecting a vulnerable value we also\n+   emit a CSDB: we do not need to do that each time the tracker itself\n+   is updated.\n+\n+   At function boundaries, we need to communicate the speculation\n+   tracking state with the caller or the callee.  This is tricky\n+   because there is no register available for such a purpose without\n+   creating a new ABI.  We deal with this by relying on the principle\n+   that in all real programs the stack pointer, SP will never be NULL\n+   at a function boundary; we can thus encode the speculation state in\n+   SP by clearing SP if the speculation tracker itself is NULL.  After\n+   the call we recover the tracking state back from SP into the\n+   tracker register.  The results is that a function call sequence is\n+   transformed to\n+\n+\tMOV\ttmp, SP\n+\tAND\ttmp, tmp, tracker\n+\tMOV\tSP, tmp\n+\tBL\t<callee>\n+\tCMP\tSP, #0\n+\tCSETM\ttracker, ne\n+\n+   The additional MOV instructions in the pre-call sequence are needed\n+   because SP cannot be used directly with the AND instruction.\n+\n+   The code inside a function body uses the post-call sequence in the\n+   prologue to establish the tracker and the pre-call sequence in the\n+   epilogue to re-encode the state for the return.\n+\n+   The code sequences have the nice property that if called from, or\n+   calling a function that does not track speculation then the stack pointer\n+   will always be non-NULL and hence the tracker will be initialized to all\n+   bits one as we need: we lose the ability to fully track speculation in that\n+   case, but we are still architecturally safe.\n+\n+   Tracking speculation in this way is quite expensive, both in code\n+   size and execution time.  We employ a number of tricks to try to\n+   limit this:\n+\n+   1) Simple leaf functions with no conditional branches (or use of\n+   the tracker) do not need to establish a new tracker: they simply\n+   carry the tracking state through SP for the duration of the call.\n+   The same is also true for leaf functions that end in a tail-call.\n+\n+   2) Back-to-back function calls in a single basic block also do not\n+   need to re-establish the tracker between the calls.  Again, we can\n+   carry the tracking state in SP for this period of time unless the\n+   tracker value is needed at that point in time.\n+\n+   We run the pass just before the final branch reorganization pass so\n+   that we can handle most of the conditional branch cases using the\n+   standard edge insertion code.  The reorg pass will hopefully clean\n+   things up for afterwards so that the results aren't too\n+   horrible.  */\n+\n+/* Generate a code sequence to clobber SP if speculating incorreclty.  */\n+static rtx_insn *\n+aarch64_speculation_clobber_sp ()\n+{\n+  rtx sp = gen_rtx_REG (DImode, SP_REGNUM);\n+  rtx tracker = gen_rtx_REG (DImode, SPECULATION_TRACKER_REGNUM);\n+  rtx scratch = gen_rtx_REG (DImode, SPECULATION_SCRATCH_REGNUM);\n+\n+  start_sequence ();\n+  emit_insn (gen_rtx_SET (scratch, sp));\n+  emit_insn (gen_anddi3 (scratch, scratch, tracker));\n+  emit_insn (gen_rtx_SET (sp, scratch));\n+  rtx_insn *seq = get_insns ();\n+  end_sequence ();\n+  return seq;\n+}\n+\n+/* Generate a code sequence to establish the tracker variable from the\n+   contents of SP.  */\n+static rtx_insn *\n+aarch64_speculation_establish_tracker ()\n+{\n+  rtx sp = gen_rtx_REG (DImode, SP_REGNUM);\n+  rtx tracker = gen_rtx_REG (DImode, SPECULATION_TRACKER_REGNUM);\n+  start_sequence ();\n+  rtx cc = aarch64_gen_compare_reg (EQ, sp, const0_rtx);\n+  emit_insn (gen_cstoredi_neg (tracker,\n+\t\t\t       gen_rtx_NE (CCmode, cc, const0_rtx), cc));\n+  rtx_insn *seq = get_insns ();\n+  end_sequence ();\n+  return seq;\n+}\n+\n+/* Main speculation tracking pass.  */\n+unsigned int\n+aarch64_do_track_speculation ()\n+{\n+  basic_block bb;\n+  bool needs_tracking = false;\n+  bool need_second_pass = false;\n+  rtx_insn *insn;\n+  int fixups_pending = 0;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      insn = BB_END (bb);\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"Basic block %d:\\n\", bb->index);\n+\n+      while (insn != BB_HEAD (bb)\n+\t     && NOTE_P (insn))\n+\tinsn = PREV_INSN (insn);\n+\n+      if (control_flow_insn_p (insn))\n+\t{\n+\t  if (any_condjump_p (insn))\n+\t    {\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"  condjump\\n\");\n+\t\t  dump_insn_slim (dump_file, insn);\n+\t\t}\n+\n+\t      rtx src = SET_SRC (pc_set (insn));\n+\n+\t      /* Check for an inverted jump, where the fall-through edge\n+\t\t appears first.  */\n+\t      bool inverted = GET_CODE (XEXP (src, 2)) != PC;\n+\t      /* The other edge must be the PC (we assume that we don't\n+\t\t have conditional return instructions).  */\n+\t      gcc_assert (GET_CODE (XEXP (src, 1 + !inverted)) == PC);\n+\n+\t      rtx cond = copy_rtx (XEXP (src, 0));\n+\t      gcc_assert (COMPARISON_P (cond)\n+\t\t\t  && REG_P (XEXP (cond, 0))\n+\t\t\t  && REGNO (XEXP (cond, 0)) == CC_REGNUM\n+\t\t\t  && XEXP (cond, 1) == const0_rtx);\n+\t      enum rtx_code inv_cond_code\n+\t\t= reversed_comparison_code (cond, insn);\n+\t      /* We should be able to reverse all conditions.  */\n+\t      gcc_assert (inv_cond_code != UNKNOWN);\n+\t      rtx inv_cond = gen_rtx_fmt_ee (inv_cond_code, GET_MODE (cond),\n+\t\t\t\t\t     copy_rtx (XEXP (cond, 0)),\n+\t\t\t\t\t     copy_rtx (XEXP (cond, 1)));\n+\t      if (inverted)\n+\t\tstd::swap (cond, inv_cond);\n+\n+\t      insert_insn_on_edge (gen_speculation_tracker (cond),\n+\t\t\t\t   BRANCH_EDGE (bb));\n+\t      insert_insn_on_edge (gen_speculation_tracker (inv_cond),\n+\t\t\t\t   FALLTHRU_EDGE (bb));\n+\t      needs_tracking = true;\n+\t    }\n+\t  else if (GET_CODE (PATTERN (insn)) == RETURN)\n+\t    {\n+\t      /* If we already know we'll need a second pass, don't put\n+\t\t out the return sequence now, or we might end up with\n+\t\t two copies.  Instead, we'll do all return statements\n+\t\t during the second pass.  However, if this is the\n+\t\t first return insn we've found and we already\n+\t\t know that we'll need to emit the code, we can save a\n+\t\t second pass by emitting the code now.  */\n+\t      if (needs_tracking && ! need_second_pass)\n+\t\t{\n+\t\t  rtx_insn *seq = aarch64_speculation_clobber_sp ();\n+\t\t  emit_insn_before (seq, insn);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  fixups_pending++;\n+\t\t  need_second_pass = true;\n+\t\t}\n+\t    }\n+\t  else if (find_reg_note (insn, REG_NON_LOCAL_GOTO, NULL_RTX))\n+\t    {\n+\t      rtx_insn *seq = aarch64_speculation_clobber_sp ();\n+\t      emit_insn_before (seq, insn);\n+\t      needs_tracking = true;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"  other\\n\");\n+\t      dump_insn_slim (dump_file, insn);\n+\t    }\n+\t}\n+    }\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      rtx_insn *end = BB_END (bb);\n+      rtx_insn *call_insn = NULL;\n+\n+      if (bb->flags & BB_NON_LOCAL_GOTO_TARGET)\n+\t{\n+\t  rtx_insn *label = NULL;\n+\t  /* For non-local goto targets we have to recover the\n+\t     speculation state from SP.  Find the last code label at\n+\t     the head of the block and place the fixup sequence after\n+\t     that.  */\n+\t  for (insn = BB_HEAD (bb); insn != end; insn = NEXT_INSN (insn))\n+\t    {\n+\t      if (LABEL_P (insn))\n+\t\tlabel = insn;\n+\t      /* Never put anything before the basic block note.  */\n+\t      if (NOTE_INSN_BASIC_BLOCK_P (insn))\n+\t\tlabel = insn;\n+\t      if (INSN_P (insn))\n+\t\tbreak;\n+\t    }\n+\n+\t  gcc_assert (label);\n+\t  emit_insn_after (aarch64_speculation_establish_tracker (), label);\n+\t}\n+\n+      /* Scan the insns looking for calls.  We need to pass the\n+\t speculation tracking state encoded in to SP.  After a call we\n+\t restore the speculation tracking into the tracker register.\n+\t To avoid unnecessary transfers we look for two or more calls\n+\t within a single basic block and eliminate, where possible,\n+\t any redundant operations.  */\n+      for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n+\t{\n+\t  if (NONDEBUG_INSN_P (insn)\n+\t      && recog_memoized (insn) >= 0\n+\t      && (get_attr_speculation_barrier (insn)\n+\t\t  == SPECULATION_BARRIER_TRUE))\n+\t    {\n+\t      if (call_insn)\n+\t\t{\n+\t\t  /* This instruction requires the speculation\n+\t\t     tracking to be in the tracker register.  If there\n+\t\t     was an earlier call in this block, we need to\n+\t\t     copy the speculation tracking back there.  */\n+\t\t  emit_insn_after (aarch64_speculation_establish_tracker (),\n+\t\t\t\t   call_insn);\n+\t\t  call_insn = NULL;\n+\t\t}\n+\n+\t      needs_tracking = true;\n+\t    }\n+\n+\t  if (CALL_P (insn))\n+\t    {\n+\t      bool tailcall\n+\t\t= (SIBLING_CALL_P (insn)\n+\t\t   || find_reg_note (insn, REG_NORETURN, NULL_RTX));\n+\n+\t      /* Tailcalls are like returns, we can eliminate the\n+\t\t transfer between the tracker register and SP if we\n+\t\t know that this function does not itself need\n+\t\t tracking.  */\n+\t      if (tailcall && (need_second_pass || !needs_tracking))\n+\t\t{\n+\t\t  /* Don't clear call_insn if it is set - needs_tracking\n+\t\t     will be true in that case and so we will end\n+\t\t     up putting out mitigation sequences.  */\n+\t\t  fixups_pending++;\n+\t\t  need_second_pass = true;\n+\t\t  break;\n+\t\t}\n+\n+\t      needs_tracking = true;\n+\n+\t      /* We always need a transfer before the first call in a BB.  */\n+\t      if (!call_insn)\n+\t\temit_insn_before (aarch64_speculation_clobber_sp (), insn);\n+\n+\t      /* Tail-calls and no-return calls don't need any post-call\n+\t\t reestablishment of the tracker.  */\n+\t      if (! tailcall)\n+\t\tcall_insn = insn;\n+\t      else\n+\t\tcall_insn = NULL;\n+\t    }\n+\n+\t  if (insn == end)\n+\t    break;\n+\t}\n+\n+      if (call_insn)\n+\t{\n+\t  rtx_insn *seq = aarch64_speculation_establish_tracker ();\n+\n+\t  /* Handle debug insns at the end of the BB.  Put the extra\n+\t     insns after them.  This ensures that we have consistent\n+\t     behaviour for the placement of the extra insns between\n+\t     debug and non-debug builds.  */\n+\t  for (insn = call_insn;\n+\t       insn != end && DEBUG_INSN_P (NEXT_INSN (insn));\n+\t       insn = NEXT_INSN (insn))\n+\t    ;\n+\n+\t  if (insn == end)\n+\t    {\n+\t      edge e = find_fallthru_edge (bb->succs);\n+\t      /* We need to be very careful about some calls that\n+\t\t appear at the end of a basic block.  If the call\n+\t\t involves exceptions, then the compiler may depend on\n+\t\t this being the last instruction in the block.  The\n+\t\t easiest way to handle this is to commit the new\n+\t\t instructions on the fall-through edge and to let\n+\t\t commit_edge_insertions clean things up for us.\n+\n+\t\t Sometimes, eg with OMP, there may not even be an\n+\t\t outgoing edge after the call.  In that case, there's\n+\t\t not much we can do, presumably the compiler has\n+\t\t decided that the call can never return in this\n+\t\t context.  */\n+\t      if (e)\n+\t\t{\n+\t\t  /* We need to set the location lists explicitly in\n+\t\t     this case.  */\n+\t\t  if (! INSN_P (seq))\n+\t\t    {\n+\t\t      start_sequence ();\n+\t\t      emit_insn (seq);\n+\t\t      seq = get_insns ();\n+\t\t      end_sequence ();\n+\t\t    }\n+\n+\t\t  for (rtx_insn *list = seq; list; list = NEXT_INSN (list))\n+\t\t    INSN_LOCATION (list) = INSN_LOCATION (call_insn);\n+\n+\t\t  insert_insn_on_edge (seq, e);\n+\t\t}\n+\t    }\n+\t  else\n+\t    emit_insn_after (seq, call_insn);\n+\t}\n+    }\n+\n+  if (needs_tracking)\n+    {\n+      if (need_second_pass)\n+\t{\n+\t  /* We found a return instruction before we found out whether\n+\t     or not we need to emit the tracking code, but we now\n+\t     know we do.  Run quickly over the basic blocks and\n+\t     fix up the return insns.  */\n+\t  FOR_EACH_BB_FN (bb, cfun)\n+\t    {\n+\t      insn = BB_END (bb);\n+\n+\t      while (insn != BB_HEAD (bb)\n+\t\t     && NOTE_P (insn))\n+\t\tinsn = PREV_INSN (insn);\n+\n+\t      if ((control_flow_insn_p (insn)\n+\t\t   && GET_CODE (PATTERN (insn)) == RETURN)\n+\t\t  || (CALL_P (insn)\n+\t\t      && (SIBLING_CALL_P (insn)\n+\t\t\t  || find_reg_note (insn, REG_NORETURN, NULL_RTX))))\n+\t\t{\n+\t\t  rtx_insn *seq = aarch64_speculation_clobber_sp ();\n+\t\t  emit_insn_before (seq, insn);\n+\t\t  fixups_pending--;\n+\t\t}\n+\t    }\n+\t  gcc_assert (fixups_pending == 0);\n+\t}\n+\n+      /* Set up the initial value of the tracker, using the incoming SP.  */\n+      insert_insn_on_edge (aarch64_speculation_establish_tracker (),\n+\t\t\t   single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n+      commit_edge_insertions ();\n+    }\n+\n+  return 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_aarch64_track_speculation =\n+{\n+  RTL_PASS,\t\t/* type.  */\n+  \"speculation\",\t/* name.  */\n+  OPTGROUP_NONE,\t/* optinfo_flags.  */\n+  TV_MACH_DEP,\t\t/* tv_id.  */\n+  0,\t\t\t/* properties_required.  */\n+  0,\t\t\t/* properties_provided.  */\n+  0,\t\t\t/* properties_destroyed.  */\n+  0,\t\t\t/* todo_flags_start.  */\n+  0\t\t\t/* todo_flags_finish.  */\n+};\n+\n+class pass_track_speculation : public rtl_opt_pass\n+{\n+ public:\n+  pass_track_speculation(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_aarch64_track_speculation, ctxt)\n+    {}\n+\n+  /* opt_pass methods:  */\n+  virtual bool gate (function *)\n+    {\n+      return aarch64_track_speculation;\n+    }\n+\n+  virtual unsigned int execute (function *)\n+    {\n+      return aarch64_do_track_speculation ();\n+    }\n+}; // class pass_track_speculation.\n+} // anon namespace.\n+\n+/* Create a new pass instance.  */\n+rtl_opt_pass *\n+make_pass_track_speculation (gcc::context *ctxt)\n+{\n+  return new pass_track_speculation (ctxt);\n+}"}, {"sha": "dc8cd2bd6881d0e28b57049b639ee8899cade286", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3751345de3763609848d77cffcc91db13e365216/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3751345de3763609848d77cffcc91db13e365216/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=3751345de3763609848d77cffcc91db13e365216", "patch": "@@ -12602,6 +12602,19 @@ aarch64_conditional_register_usage (void)\n \tfixed_regs[i] = 1;\n \tcall_used_regs[i] = 1;\n       }\n+\n+  /* When tracking speculation, we need a couple of call-clobbered registers\n+     to track the speculation state.  It would be nice to just use\n+     IP0 and IP1, but currently there are numerous places that just\n+     assume these registers are free for other uses (eg pointer\n+     authentication).  */\n+  if (aarch64_track_speculation)\n+    {\n+      fixed_regs[SPECULATION_TRACKER_REGNUM] = 1;\n+      call_used_regs[SPECULATION_TRACKER_REGNUM] = 1;\n+      fixed_regs[SPECULATION_SCRATCH_REGNUM] = 1;\n+      call_used_regs[SPECULATION_SCRATCH_REGNUM] = 1;\n+    }\n }\n \n /* Walk down the type tree of TYPE counting consecutive base elements."}, {"sha": "3dcc054a15a615d97ccd51ae3b6f0306a4c7fcbe", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3751345de3763609848d77cffcc91db13e365216/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3751345de3763609848d77cffcc91db13e365216/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=3751345de3763609848d77cffcc91db13e365216", "patch": "@@ -88,6 +88,10 @@\n     (P13_REGNUM\t\t81)\n     (P14_REGNUM\t\t82)\n     (P15_REGNUM\t\t83)\n+    ;; A couple of call-clobbered registers that we need to reserve when\n+    ;; tracking speculation this is not ABI, so is subject to change.\n+    (SPECULATION_TRACKER_REGNUM 15)\n+    (SPECULATION_SCRATCH_REGNUM 14)\n   ]\n )\n \n@@ -195,6 +199,7 @@\n     UNSPEC_CLASTB\n     UNSPEC_FADDA\n     UNSPEC_REV_SUBREG\n+    UNSPEC_SPECULATION_TRACKER\n ])\n \n (define_c_enum \"unspecv\" [\n@@ -287,6 +292,11 @@\n ;; no predicated insns.\n (define_attr \"predicated\" \"yes,no\" (const_string \"no\"))\n \n+;; Set to true on an insn that requires the speculation tracking state to be\n+;; in the tracking register before the insn issues.  Otherwise the compiler\n+;; may chose to hold the tracking state encoded in SP.\n+(define_attr \"speculation_barrier\" \"true,false\" (const_string \"false\"))\n+\n ;; -------------------------------------------------------------------\n ;; Pipeline descriptions and scheduling\n ;; -------------------------------------------------------------------\n@@ -3540,7 +3550,7 @@\n \n (define_insn \"cmp<mode>\"\n   [(set (reg:CC CC_REGNUM)\n-\t(compare:CC (match_operand:GPI 0 \"register_operand\" \"r,r,r\")\n+\t(compare:CC (match_operand:GPI 0 \"register_operand\" \"rk,rk,rk\")\n \t\t    (match_operand:GPI 1 \"aarch64_plus_operand\" \"r,I,J\")))]\n   \"\"\n   \"@\n@@ -6549,6 +6559,21 @@\n   DONE;\n })\n \n+;; Track speculation through conditional branches.  We assume that\n+;; SPECULATION_TRACKER_REGNUM is reserved for this purpose when necessary.\n+(define_insn \"speculation_tracker\"\n+  [(set (reg:DI SPECULATION_TRACKER_REGNUM)\n+\t(unspec [(reg:DI SPECULATION_TRACKER_REGNUM) (match_operand 0)]\n+\t UNSPEC_SPECULATION_TRACKER))]\n+  \"\"\n+  {\n+    operands[1] = gen_rtx_REG (DImode, SPECULATION_TRACKER_REGNUM);\n+    output_asm_insn (\"csel\\\\t%1, %1, xzr, %m0\", operands);\n+    return \"\";\n+  }\n+  [(set_attr \"type\" \"csel\")]\n+)\n+\n ;; Helper for aarch64.c code.\n (define_expand \"set_clobber_cc\"\n   [(parallel [(set (match_operand 0)\n@@ -6561,7 +6586,8 @@\n   \"\"\n   \"isb\\;dsb\\\\tsy\"\n   [(set_attr \"length\" \"8\")\n-   (set_attr \"type\" \"block\")]\n+   (set_attr \"type\" \"block\")\n+   (set_attr \"speculation_barrier\" \"true\")]\n )\n \n ;; AdvSIMD Stuff"}, {"sha": "5d54853c20fd975b8584bb448818f13b3bc49050", "filename": "gcc/config/aarch64/t-aarch64", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3751345de3763609848d77cffcc91db13e365216/gcc%2Fconfig%2Faarch64%2Ft-aarch64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3751345de3763609848d77cffcc91db13e365216/gcc%2Fconfig%2Faarch64%2Ft-aarch64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Ft-aarch64?ref=3751345de3763609848d77cffcc91db13e365216", "patch": "@@ -67,6 +67,16 @@ cortex-a57-fma-steering.o: $(srcdir)/config/aarch64/cortex-a57-fma-steering.c \\\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t\t$(srcdir)/config/aarch64/cortex-a57-fma-steering.c\n \n+aarch64-speculation.o: $(srcdir)/config/aarch64/aarch64-speculation.cc \\\n+    $(CONFIG_H) \\\n+    $(SYSTEM_H) \\\n+    $(TM_H) \\\n+    $(TARGET_H) \\\n+    $(RTL_BASE_H) \\\n+    $(TREE_PASS_H)\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_SPPFLAGS) $(INCLUDES) \\\n+\t  $(srcdir)/config/aarch64/aarch64-speculation.cc\n+\n comma=,\n MULTILIB_OPTIONS    = $(subst $(comma),/, $(patsubst %, mabi=%, $(subst $(comma),$(comma)mabi=,$(TM_MULTILIB_CONFIG))))\n MULTILIB_DIRNAMES   = $(subst $(comma), ,$(TM_MULTILIB_CONFIG))"}, {"sha": "6047d82065a4983ec828c55e55c86b96a827224a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3751345de3763609848d77cffcc91db13e365216/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3751345de3763609848d77cffcc91db13e365216/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3751345de3763609848d77cffcc91db13e365216", "patch": "@@ -617,7 +617,7 @@ Objective-C and Objective-C++ Dialects}.\n -mpc-relative-literal-loads @gol\n -msign-return-address=@var{scope} @gol\n -march=@var{name}  -mcpu=@var{name}  -mtune=@var{name}  @gol\n--moverride=@var{string}  -mverbose-cost-dump}\n+-moverride=@var{string}  -mverbose-cost-dump -mtrack-speculation} \n \n @emph{Adapteva Epiphany Options}\n @gccoptlist{-mhalf-reg-file  -mprefer-short-insn-regs @gol\n@@ -14786,6 +14786,14 @@ This option only has an effect if @option{-ffast-math} or\n precision of division results to about 16 bits for\n single precision and to 32 bits for double precision.\n \n+@item -mtrack-speculation\n+@itemx -mno-track-speculation\n+Enable or disable generation of additional code to track speculative\n+execution through conditional branches.  The tracking state can then\n+be used by the compiler when expanding calls to\n+@code{__builtin_speculation_safe_copy} to permit a more efficient code\n+sequence to be generated.\n+\n @item -march=@var{name}\n @opindex march\n Specify the name of the target architecture and, optionally, one or"}]}