{"sha": "bc5e3b54eb248f59e2bde5d84219d1c99bf99603", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM1ZTNiNTRlYjI0OGY1OWUyYmRlNWQ4NDIxOWQxYzk5YmY5OTYwMw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-02-01T00:14:47Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-02-01T00:14:47Z"}, "message": "cse.c (cse_reg_info): Remove hash_next, next, regno.\n\n\t* cse.c (cse_reg_info): Remove hash_next, next, regno.  Add\n\ttimestamp.\n\t(cse_reg_info_list, cse_reg_info_list_free, REGHASH_SHIFT,\n\tREGHASH_SIZE, REGHASH_MASK, reg_hash, REGHASH_FN,\n\tcached_cse_reg_info, GET_CSE_REG_INFO): Remove.\n\t(cached_regno): Initialize to INVALID_REGNUM.\n\t(cse_reg_info_table_size,\n\tcse_reg_info_table_first_uninitialized,\n\tcse_reg_info_timestamp): New.\n\t(REG_TICK, REG_IN_TABLE, SUBREG_TICKED, REG_QTY): Use\n\tget_cse_reg_info.\n\t(init_cse_reg_info, get_cse_reg_info_1): New.\n\t(get_cse_reg_info): Cache the last look-up.\n\t(new_basic_block): Update the code to clear mappings from\n\tregisters to cse_reg_info entries.\n\t(cse_main): Call init_cse_reg_info.\n\nFrom-SVN: r94506", "tree": {"sha": "6fadc397d766090c518112d19a13a4fc1e03c5c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fadc397d766090c518112d19a13a4fc1e03c5c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc5e3b54eb248f59e2bde5d84219d1c99bf99603", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc5e3b54eb248f59e2bde5d84219d1c99bf99603", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc5e3b54eb248f59e2bde5d84219d1c99bf99603", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc5e3b54eb248f59e2bde5d84219d1c99bf99603/comments", "author": null, "committer": null, "parents": [{"sha": "b4519d39bc85072ea1ec7b4ad254481d387a695c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4519d39bc85072ea1ec7b4ad254481d387a695c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4519d39bc85072ea1ec7b4ad254481d387a695c"}], "stats": {"total": 201, "additions": 115, "deletions": 86}, "files": [{"sha": "c9b19570aca902ebc3401134ce4f7c64ef4b23cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5e3b54eb248f59e2bde5d84219d1c99bf99603/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5e3b54eb248f59e2bde5d84219d1c99bf99603/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc5e3b54eb248f59e2bde5d84219d1c99bf99603", "patch": "@@ -1,3 +1,22 @@\n+2005-02-01  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* cse.c (cse_reg_info): Remove hash_next, next, regno.  Add\n+\ttimestamp.\n+\t(cse_reg_info_list, cse_reg_info_list_free, REGHASH_SHIFT,\n+\tREGHASH_SIZE, REGHASH_MASK, reg_hash, REGHASH_FN,\n+\tcached_cse_reg_info, GET_CSE_REG_INFO): Remove.\n+\t(cached_regno): Initialize to INVALID_REGNUM.\n+\t(cse_reg_info_table_size,\n+\tcse_reg_info_table_first_uninitialized,\n+\tcse_reg_info_timestamp): New.\n+\t(REG_TICK, REG_IN_TABLE, SUBREG_TICKED, REG_QTY): Use\n+\tget_cse_reg_info.\n+\t(init_cse_reg_info, get_cse_reg_info_1): New.\n+\t(get_cse_reg_info): Cache the last look-up.\n+\t(new_basic_block): Update the code to clear mappings from\n+\tregisters to cse_reg_info entries.\n+\t(cse_main): Call init_cse_reg_info.\n+\n 2005-01-31  Steven Bosscher  <stevenb@suse.de>\n \n \tPR c/19333"}, {"sha": "2c909b73b054ceedd3381e04a02bcc5ef2e82400", "filename": "gcc/cse.c", "status": "modified", "additions": 96, "deletions": 86, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5e3b54eb248f59e2bde5d84219d1c99bf99603/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5e3b54eb248f59e2bde5d84219d1c99bf99603/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=bc5e3b54eb248f59e2bde5d84219d1c99bf99603", "patch": "@@ -302,14 +302,8 @@ static struct reg_eqv_elem *reg_eqv_table;\n \n struct cse_reg_info\n {\n-  /* Next in hash chain.  */\n-  struct cse_reg_info *hash_next;\n-\n-  /* The next cse_reg_info structure in the free or used list.  */\n-  struct cse_reg_info *next;\n-\n-  /* Search key */\n-  unsigned int regno;\n+  /* The timestamp at which this register is initialized.  */\n+  unsigned int timestamp;\n \n   /* The quantity number of the register's current contents.  */\n   int reg_qty;\n@@ -329,39 +323,22 @@ struct cse_reg_info\n   unsigned int subreg_ticked;\n };\n \n-/* We maintain a linked list of cse_reg_info instances, which is\n-   partitioned into two pieces.  The first part, pointed to by\n-   cse_reg_info_list, is a list of those entries that are in use.  The\n-   second part, pointed to by cse_reg_info_list_free, is a list of\n-   those entries that are not in use.\n-\n-   We combine these two parts into one linked list for efficiency.\n-   Specifically, when we take an element from the second part and want\n-   to move it to the first part, all we have to do is move the pointer\n-   cse_reg_info_list_free to the next element.  Also, if we wish to\n-   move all elements into the second part, we just have to move the\n-   pointer to the first element of the list.  */\n-\n-/* A linked list of cse_reg_info entries that have been allocated so\n-   far.  */\n-static struct cse_reg_info *cse_reg_info_list;\n-\n-/* A pointer to the first unused entry in the above linked list.  */\n-static struct cse_reg_info *cse_reg_info_list_free;\n+/* A table of cse_reg_info indexed by register numbers.  */\n+struct cse_reg_info *cse_reg_info_table;\n \n-/* A mapping from registers to cse_reg_info data structures.  */\n-#define REGHASH_SHIFT\t7\n-#define REGHASH_SIZE\t(1 << REGHASH_SHIFT)\n-#define REGHASH_MASK\t(REGHASH_SIZE - 1)\n-static struct cse_reg_info *reg_hash[REGHASH_SIZE];\n+/* The size of the above table.  */\n+static unsigned int cse_reg_info_table_size;\n \n-#define REGHASH_FN(REGNO)\t\\\n-\t(((REGNO) ^ ((REGNO) >> REGHASH_SHIFT)) & REGHASH_MASK)\n+/* The index of the first entry that has not been initialized.  */\n+static unsigned int cse_reg_info_table_first_uninitialized;\n \n-/* The last lookup we did into the cse_reg_info_tree.  This allows us\n-   to cache repeated lookups.  */\n-static unsigned int cached_regno;\n-static struct cse_reg_info *cached_cse_reg_info;\n+/* The timestamp at the beginning of the current run of\n+   cse_basic_block.  We increment this variable at at the beginning of\n+   the current run of cse_basic_block.  The timestamp field of a\n+   cse_reg_info entry matches the value of this variable if and only\n+   if the entry has been initialized during the current run of\n+   cse_basic_block.  */\n+static unsigned int cse_reg_info_timestamp;\n \n /* A HARD_REG_SET containing all the hard registers for which there is\n    currently a REG expression in the hash table.  Note the difference\n@@ -523,29 +500,23 @@ struct table_elt\n #define COST(X) (REG_P (X) ? 0 : notreg_cost (X, SET))\n #define COST_IN(X,OUTER) (REG_P (X) ? 0 : notreg_cost (X, OUTER))\n \n-/* Get the info associated with register N.  */\n-\n-#define GET_CSE_REG_INFO(N)\t\t\t\\\n-  (((N) == cached_regno && cached_cse_reg_info)\t\\\n-   ? cached_cse_reg_info : get_cse_reg_info ((N)))\n-\n /* Get the number of times this register has been updated in this\n    basic block.  */\n \n-#define REG_TICK(N) ((GET_CSE_REG_INFO (N))->reg_tick)\n+#define REG_TICK(N) (get_cse_reg_info (N)->reg_tick)\n \n /* Get the point at which REG was recorded in the table.  */\n \n-#define REG_IN_TABLE(N) ((GET_CSE_REG_INFO (N))->reg_in_table)\n+#define REG_IN_TABLE(N) (get_cse_reg_info (N)->reg_in_table)\n \n /* Get the SUBREG set at the last increment to REG_TICK (-1 if not a\n    SUBREG).  */\n \n-#define SUBREG_TICKED(N) ((GET_CSE_REG_INFO (N))->subreg_ticked)\n+#define SUBREG_TICKED(N) (get_cse_reg_info (N)->subreg_ticked)\n \n /* Get the quantity number for REG.  */\n \n-#define REG_QTY(N) ((GET_CSE_REG_INFO (N))->reg_qty)\n+#define REG_QTY(N) (get_cse_reg_info (N)->reg_qty)\n \n /* Determine if the quantity number for register X represents a valid index\n    into the qty_table.  */\n@@ -647,7 +618,8 @@ static rtx cse_basic_block (rtx, rtx, struct branch_path *);\n static void count_reg_usage (rtx, int *, int);\n static int check_for_label_ref (rtx *, void *);\n extern void dump_class (struct table_elt*);\n-static struct cse_reg_info * get_cse_reg_info (unsigned int);\n+static void get_cse_reg_info_1 (unsigned int regno);\n+static struct cse_reg_info * get_cse_reg_info (unsigned int regno);\n static int check_dependence (rtx *, void *);\n \n static void flush_hash_table (void);\n@@ -862,47 +834,87 @@ notreg_cost (rtx x, enum rtx_code outer)\n }\n \n \f\n-static struct cse_reg_info *\n-get_cse_reg_info (unsigned int regno)\n-{\n-  struct cse_reg_info **hash_head = &reg_hash[REGHASH_FN (regno)];\n-  struct cse_reg_info *p;\n+/* Initialize CSE_REG_INFO_TABLE.  */\n \n-  for (p = *hash_head; p != NULL; p = p->hash_next)\n-    if (p->regno == regno)\n-      break;\n-\n-  if (p == NULL)\n+static void\n+init_cse_reg_info (unsigned int nregs)\n+{\n+  /* Do we need to grow the table?  */\n+  if (nregs > cse_reg_info_table_size)\n     {\n-      /* Get a new cse_reg_info structure.  */\n-      if (cse_reg_info_list_free)\n+      unsigned int new_size;\n+\n+      if (cse_reg_info_table_size < 2048)\n \t{\n-\t  p = cse_reg_info_list_free;\n-\t  cse_reg_info_list_free = p->next;\n+\t  /* Compute a new size that is a power of 2 and no smaller\n+\t     than the large of NREGS and 64.  */\n+\t  new_size = (cse_reg_info_table_size\n+\t\t      ? cse_reg_info_table_size : 64);\n+\n+\t  while (new_size < nregs)\n+\t    new_size *= 2;\n \t}\n       else\n \t{\n-\t  p = xmalloc (sizeof (struct cse_reg_info));\n-\t  p->next = cse_reg_info_list;\n-\t  cse_reg_info_list = p;\n+\t  /* If we need a big table, allocate just enough to hold\n+\t     NREGS registers.  */\n+\t  new_size = nregs;\n \t}\n \n-      /* Insert into hash table.  */\n-      p->hash_next = *hash_head;\n-      *hash_head = p;\n+      /* Reallocate the table with NEW_SIZE entries.  */\n+      cse_reg_info_table = xrealloc (cse_reg_info_table,\n+\t\t\t\t     (sizeof (struct cse_reg_info)\n+\t\t\t\t      * new_size));\n+      cse_reg_info_table_size = new_size;\n+    }\n+\n+  /* Do we have all of the first NREGS entries initialized?  */\n+  if (cse_reg_info_table_first_uninitialized < nregs)\n+    {\n+      unsigned int old_timestamp = cse_reg_info_timestamp - 1;\n+      unsigned int i;\n+\n+      /* Put the old timestamp on newly allocated entries so that they\n+\t will all be considered out of date.  We do not touch those\n+\t entries beyond the first NREGS entries to be nice to the\n+\t virtual memory.  */\n+      for (i = cse_reg_info_table_first_uninitialized; i < nregs; i++)\n+\tcse_reg_info_table[i].timestamp = old_timestamp;\n \n-      /* Initialize it.  */\n-      p->reg_tick = 1;\n-      p->reg_in_table = -1;\n-      p->subreg_ticked = -1;\n-      p->reg_qty = -regno - 1;\n-      p->regno = regno;\n+      cse_reg_info_table_first_uninitialized = nregs;\n     }\n+}\n+\n+/* Given REGNO, ensure that a cse_reg_info entry exists for REGNO by\n+   growing the cse_reg_info_table and/or initializing the entry for\n+   REGNO.  */\n+\n+static void\n+get_cse_reg_info_1 (unsigned int regno)\n+{\n+  /* Set TIMESTAMP field to CSE_REG_INFO_TIMESTAMP so that this\n+     entry will be considered to have been initialized.  */\n+  cse_reg_info_table[regno].timestamp = cse_reg_info_timestamp;\n+\n+  /* Initialize the rest of the entry.  */\n+  cse_reg_info_table[regno].reg_tick = 1;\n+  cse_reg_info_table[regno].reg_in_table = -1;\n+  cse_reg_info_table[regno].subreg_ticked = -1;\n+  cse_reg_info_table[regno].reg_qty = -regno - 1;\n+}\n+\n+/* Find a cse_reg_info entry for REGNO.  */\n \n-  /* Cache this lookup; we tend to be looking up information about the\n-     same register several times in a row.  */\n-  cached_regno = regno;\n-  cached_cse_reg_info = p;\n+static inline struct cse_reg_info *\n+get_cse_reg_info (unsigned int regno)\n+{\n+  struct cse_reg_info *p = &cse_reg_info_table[regno];\n+\n+  /* If we are looking for REGNO that is different from the last\n+     look-up, make sure the entry for REGNO exists and has been\n+     initialized.  */\n+  if (p->timestamp != cse_reg_info_timestamp)\n+    get_cse_reg_info_1 (regno);\n \n   return p;\n }\n@@ -917,14 +929,10 @@ new_basic_block (void)\n \n   next_qty = 0;\n \n-  /* Clear out hash table state for this pass.  */\n-\n-  memset (reg_hash, 0, sizeof reg_hash);\n-\n-  cse_reg_info_list_free = cse_reg_info_list;\n-\n-  cached_cse_reg_info = 0;\n+  /* Invalidate cse_reg_info_table and its cache.  */\n+  cse_reg_info_timestamp++;\n \n+  /* Clear out hash table state for this pass.  */\n   CLEAR_HARD_REG_SET (hard_regs_in_table);\n \n   /* The per-quantity values used to be initialized here, but it is\n@@ -6698,6 +6706,8 @@ cse_main (rtx f, int nregs, FILE *file)\n   rtx insn = f;\n   int i;\n \n+  init_cse_reg_info (nregs);\n+\n   val.path = xmalloc (sizeof (struct branch_path)\n \t\t      * PARAM_VALUE (PARAM_MAX_CSE_PATH_LENGTH));\n "}]}