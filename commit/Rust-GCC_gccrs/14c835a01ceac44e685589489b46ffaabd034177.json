{"sha": "14c835a01ceac44e685589489b46ffaabd034177", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRjODM1YTAxY2VhYzQ0ZTY4NTU4OTQ4OWI0NmZmYWFiZDAzNDE3Nw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2019-10-28T12:35:39Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2019-10-28T12:35:39Z"}, "message": "[C++ PATCH] simplify deferred parsing lexer\n\nhttps://gcc.gnu.org/ml/gcc-patches/2019-10/msg01962.html\n\nWe use an eof_token global variable as a sentinel on a deferred parse\n(such as in-class function definitions, or default args). This\ncomplicates retrieving the next token in certain places.\n\nAs such deferred parses always nest properly and completely before\nresuming the outer lexer, we can simply morph the token after the\ndeferred buffer into a CPP_EOF token and restore it afterwards. I\nfinally got around to implementing it with this patch.\n\nOne complication is that we have to change the discriminator for when\nthe token's value is a tree. We can't look at the token's type because\nit might have been overwritten. I add a bool flag to the token\n(there's several spare bits), and use that. This does simplify the\ndiscriminator because we just check a single bit, rather than a set of\ntoken types.\n\n\t* parser.h (struct cp_token): Drop {ENUM,BOOL}_BITFIELD C-ism.\n\tAdd tree_check_p flag, use as nested union discriminator.\n\t(struct cp_lexer): Add saved_type & saved_keyword fields.\n\t* parser.c (eof_token): Delete.\n\t(cp_lexer_new_main): Always init last_token to last token of\n\tbuffer.\n\t(cp_lexer_new_from_tokens): Overlay EOF token at end of range.\n\t(cp_lexer_destroy): Restore token under the EOF.\n\t(cp_lexer_previous_token_position): No check for eof_token here.\n\t(cp_lexer_get_preprocessor_token): Clear tree_check_p.\n\t(cp_lexer_peek_nth_token): Check CPP_EOF not eof_token.\n\t(cp_lexer_consume_token): Assert not CPP_EOF, no check for\n\teof_token.\n\t(cp_lexer_purge_token): Likewise.\n\t(cp_lexer_purge_tokens_after): No check for EOF token.\n\t(cp_parser_nested_name_specifier, cp_parser_decltype)\n\t(cp_parser_template_id): Set tree_check_p.\n\nFrom-SVN: r277514", "tree": {"sha": "339afa25409f96fdb4e6a816e1ceb19b7817c2ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/339afa25409f96fdb4e6a816e1ceb19b7817c2ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14c835a01ceac44e685589489b46ffaabd034177", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14c835a01ceac44e685589489b46ffaabd034177", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14c835a01ceac44e685589489b46ffaabd034177", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14c835a01ceac44e685589489b46ffaabd034177/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e0c4f7fbd6a4ee8e3a1468514044bd941fa28522", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0c4f7fbd6a4ee8e3a1468514044bd941fa28522", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0c4f7fbd6a4ee8e3a1468514044bd941fa28522"}], "stats": {"total": 119, "additions": 63, "deletions": 56}, "files": [{"sha": "44c07f148cadc34a35c33568f894ecb7da420371", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14c835a01ceac44e685589489b46ffaabd034177/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14c835a01ceac44e685589489b46ffaabd034177/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=14c835a01ceac44e685589489b46ffaabd034177", "patch": "@@ -1,3 +1,23 @@\n+2019-10-28  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* parser.h (struct cp_token): Drop {ENUM,BOOL}_BITFIELD C-ism.\n+\tAdd tree_check_p flag, use as nested union discriminator.\n+\t(struct cp_lexer): Add saved_type & saved_keyword fields.\n+\t* parser.c (eof_token): Delete.\n+\t(cp_lexer_new_main): Always init last_token to last token of\n+\tbuffer.\n+\t(cp_lexer_new_from_tokens): Overlay EOF token at end of range.\n+\t(cp_lexer_destroy): Restore token under the EOF.\n+\t(cp_lexer_previous_token_position): No check for eof_token here.\n+\t(cp_lexer_get_preprocessor_token): Clear tree_check_p.\n+\t(cp_lexer_peek_nth_token): Check CPP_EOF not eof_token.\n+\t(cp_lexer_consume_token): Assert not CPP_EOF, no check for\n+\teof_token.\n+\t(cp_lexer_purge_token): Likewise.\n+\t(cp_lexer_purge_tokens_after): No check for EOF token.\n+\t(cp_parser_nested_name_specifier, cp_parser_decltype)\n+\t(cp_parser_template_id): Set tree_check_p.\n+\n 2019-10-24  Jakub Jelinek  <jakub@redhat.com>\n \n \t* decl2.c (cplus_decl_attributes): Add \"omp declare target block\""}, {"sha": "b394e2e1467b0e2627a43ddde711d799713681fc", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 28, "deletions": 45, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14c835a01ceac44e685589489b46ffaabd034177/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14c835a01ceac44e685589489b46ffaabd034177/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=14c835a01ceac44e685589489b46ffaabd034177", "patch": "@@ -52,11 +52,6 @@ along with GCC; see the file COPYING3.  If not see\n /* The cp_lexer_* routines mediate between the lexer proper (in libcpp\n    and c-lex.c) and the C++ parser.  */\n \n-static cp_token eof_token =\n-{\n-  CPP_EOF, RID_MAX, 0, false, false, false, 0, { NULL }\n-};\n-\n /* The various kinds of non integral constant we encounter. */\n enum non_integral_constant {\n   NIC_NONE,\n@@ -660,12 +655,10 @@ cp_lexer_new_main (void)\n       vec_safe_push (lexer->buffer, token);\n     }\n \n-  lexer->last_token = lexer->buffer->address ()\n+  lexer->next_token = lexer->buffer->address ();\n+  lexer->last_token = lexer->next_token\n                       + lexer->buffer->length ()\n \t\t      - 1;\n-  lexer->next_token = lexer->buffer->length ()\n-\t\t      ? lexer->buffer->address ()\n-\t\t      : &eof_token;\n \n   /* Subsequent preprocessor diagnostics should use compiler\n      diagnostic functions to get the compiler source location.  */\n@@ -687,7 +680,14 @@ cp_lexer_new_from_tokens (cp_token_cache *cache)\n \n   /* We do not own the buffer.  */\n   lexer->buffer = NULL;\n-  lexer->next_token = first == last ? &eof_token : first;\n+\n+  /* Insert an EOF token.  */\n+  lexer->saved_type = last->type;\n+  lexer->saved_keyword = last->keyword;\n+  last->type = CPP_EOF;\n+  last->keyword = RID_MAX;\n+\n+  lexer->next_token = first;\n   lexer->last_token = last;\n \n   lexer->saved_tokens.create (CP_SAVED_TOKEN_STACK);\n@@ -704,7 +704,14 @@ cp_lexer_new_from_tokens (cp_token_cache *cache)\n static void\n cp_lexer_destroy (cp_lexer *lexer)\n {\n-  vec_free (lexer->buffer);\n+  if (lexer->buffer)\n+    vec_free (lexer->buffer);\n+  else\n+    {\n+      /* Restore the token we overwrite with EOF.  */\n+      lexer->last_token->type = lexer->saved_type;\n+      lexer->last_token->keyword = lexer->saved_keyword;\n+    }\n   lexer->saved_tokens.release ();\n   ggc_free (lexer);\n }\n@@ -731,8 +738,6 @@ cp_lexer_debugging_p (cp_lexer *lexer)\n static inline cp_token_position\n cp_lexer_token_position (cp_lexer *lexer, bool previous_p)\n {\n-  gcc_assert (!previous_p || lexer->next_token != &eof_token);\n-\n   return lexer->next_token - previous_p;\n }\n \n@@ -751,10 +756,7 @@ cp_lexer_set_token_position (cp_lexer *lexer, cp_token_position pos)\n static inline cp_token_position\n cp_lexer_previous_token_position (cp_lexer *lexer)\n {\n-  if (lexer->next_token == &eof_token)\n-    return lexer->last_token - 1;\n-  else\n-    return cp_lexer_token_position (lexer, true);\n+  return cp_lexer_token_position (lexer, true);\n }\n \n static inline cp_token *\n@@ -807,6 +809,7 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer, cp_token *token)\n   token->keyword = RID_MAX;\n   token->purged_p = false;\n   token->error_reported = false;\n+  token->tree_check_p = false;\n \n   /* On some systems, some header files are surrounded by an\n      implicit extern \"C\" block.  Set a flag in the token if it\n@@ -1082,16 +1085,9 @@ cp_lexer_peek_nth_token (cp_lexer* lexer, size_t n)\n \n   --n;\n   token = lexer->next_token;\n-  gcc_assert (!n || token != &eof_token);\n-  while (n != 0)\n+  while (n && token->type != CPP_EOF)\n     {\n       ++token;\n-      if (token == lexer->last_token)\n-\t{\n-\t  token = &eof_token;\n-\t  break;\n-\t}\n-\n       if (!token->purged_p)\n \t--n;\n     }\n@@ -1113,18 +1109,12 @@ cp_lexer_consume_token (cp_lexer* lexer)\n {\n   cp_token *token = lexer->next_token;\n \n-  gcc_assert (token != &eof_token);\n   gcc_assert (!lexer->in_pragma || token->type != CPP_PRAGMA_EOL);\n \n   do\n     {\n+      gcc_assert (token->type != CPP_EOF);\n       lexer->next_token++;\n-      if (lexer->next_token == lexer->last_token)\n-\t{\n-\t  lexer->next_token = &eof_token;\n-\t  break;\n-\t}\n-\n     }\n   while (lexer->next_token->purged_p);\n \n@@ -1150,21 +1140,14 @@ cp_lexer_purge_token (cp_lexer *lexer)\n {\n   cp_token *tok = lexer->next_token;\n \n-  gcc_assert (tok != &eof_token);\n+  gcc_assert (tok->type != CPP_EOF);\n   tok->purged_p = true;\n   tok->location = UNKNOWN_LOCATION;\n   tok->u.value = NULL_TREE;\n   tok->keyword = RID_MAX;\n \n   do\n-    {\n-      tok++;\n-      if (tok == lexer->last_token)\n-\t{\n-\t  tok = &eof_token;\n-\t  break;\n-\t}\n-    }\n+    tok++;\n   while (tok->purged_p);\n   lexer->next_token = tok;\n }\n@@ -1178,12 +1161,9 @@ cp_lexer_purge_tokens_after (cp_lexer *lexer, cp_token *tok)\n {\n   cp_token *peek = lexer->next_token;\n \n-  if (peek == &eof_token)\n-    peek = lexer->last_token;\n-\n   gcc_assert (tok < peek);\n \n-  for ( tok += 1; tok != peek; tok += 1)\n+  for (tok++; tok != peek; tok++)\n     {\n       tok->purged_p = true;\n       tok->location = UNKNOWN_LOCATION;\n@@ -6616,6 +6596,7 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n       /* Retrieve any deferred checks.  Do not pop this access checks yet\n \t so the memory will not be reclaimed during token replacing below.  */\n       token->u.tree_check_value = ggc_cleared_alloc<struct tree_check> ();\n+      token->tree_check_p = true;\n       token->u.tree_check_value->value = parser->scope;\n       token->u.tree_check_value->checks = get_deferred_access_checks ();\n       token->u.tree_check_value->qualifying_scope =\n@@ -14801,6 +14782,7 @@ cp_parser_decltype (cp_parser *parser)\n      it again.  */\n   start_token->type = CPP_DECLTYPE;\n   start_token->u.tree_check_value = ggc_cleared_alloc<struct tree_check> ();\n+  start_token->tree_check_p = true;\n   start_token->u.tree_check_value->value = expr;\n   start_token->u.tree_check_value->checks = get_deferred_access_checks ();\n   start_token->keyword = RID_MAX;\n@@ -16588,6 +16570,7 @@ cp_parser_template_id (cp_parser *parser,\n       /* Retrieve any deferred checks.  Do not pop this access checks yet\n \t so the memory will not be reclaimed during token replacing below.  */\n       token->u.tree_check_value = ggc_cleared_alloc<struct tree_check> ();\n+      token->tree_check_p = true;\n       token->u.tree_check_value->value = template_id;\n       token->u.tree_check_value->checks = get_deferred_access_checks ();\n       token->keyword = RID_MAX;"}, {"sha": "7fee244d651cce4e9fbd9d59a737272b5d704edd", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14c835a01ceac44e685589489b46ffaabd034177/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14c835a01ceac44e685589489b46ffaabd034177/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=14c835a01ceac44e685589489b46ffaabd034177", "patch": "@@ -41,34 +41,34 @@ struct GTY(()) tree_check {\n \n struct GTY (()) cp_token {\n   /* The kind of token.  */\n-  ENUM_BITFIELD (cpp_ttype) type : 8;\n+  enum cpp_ttype type : 8;\n   /* If this token is a keyword, this value indicates which keyword.\n      Otherwise, this value is RID_MAX.  */\n-  ENUM_BITFIELD (rid) keyword : 8;\n+  enum rid keyword : 8;\n   /* Token flags.  */\n   unsigned char flags;\n   /* True if this token is from a context where it is implicitly extern \"C\" */\n-  BOOL_BITFIELD implicit_extern_c : 1;\n+  bool implicit_extern_c : 1;\n   /* True if an error has already been reported for this token, such as a\n      CPP_NAME token that is not a keyword (i.e., for which KEYWORD is\n      RID_MAX) iff this name was looked up and found to be ambiguous.  */\n-  BOOL_BITFIELD error_reported : 1;\n+  bool error_reported : 1;\n   /* True for a token that has been purged.  If a token is purged,\n      it is no longer a valid token and it should be considered\n      deleted.  */\n-  BOOL_BITFIELD purged_p : 1;\n-  /* 5 unused bits.  */\n+  bool purged_p : 1;\n+  bool tree_check_p : 1;\n+  /* 4 unused bits.  */\n+\n   /* The location at which this token was found.  */\n   location_t location;\n   /* The value associated with this token, if any.  */\n   union cp_token_value {\n     /* Used for compound tokens such as CPP_NESTED_NAME_SPECIFIER.  */\n-    struct tree_check* GTY((tag (\"1\"))) tree_check_value;\n+    struct tree_check* GTY((tag (\"true\"))) tree_check_value;\n     /* Use for all other tokens.  */\n-    tree GTY((tag (\"0\"))) value;\n-  } GTY((desc (\"(%1.type == CPP_TEMPLATE_ID)\"\n-\t       \"|| (%1.type == CPP_NESTED_NAME_SPECIFIER)\"\n-\t       \"|| (%1.type == CPP_DECLTYPE)\"))) u;\n+    tree GTY((tag (\"false\"))) value;\n+  } GTY((desc (\"%1.tree_check_p\"))) u;\n };\n \n \n@@ -99,6 +99,10 @@ struct GTY (()) cp_lexer {\n      tokens.  */\n   vec<cp_token_position> GTY ((skip)) saved_tokens;\n \n+  /* Saved pieces of end token we replaced with the eof token.  */\n+  enum cpp_ttype saved_type : 8;\n+  enum rid saved_keyword : 8;\n+\n   /* The next lexer in a linked list of lexers.  */\n   struct cp_lexer *next;\n "}]}