{"sha": "6362627b27f395b054f359244fcfcb15ac0ac2ab", "node_id": "C_kwDOANBUbNoAKDYzNjI2MjdiMjdmMzk1YjA1NGYzNTkyNDRmY2ZjYjE1YWMwYWMyYWI", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-01-03T13:02:23Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-01-03T13:17:26Z"}, "message": "i386, fab: Optimize __atomic_{add,sub,and,or,xor}_fetch (x, y, z) {==,!=,<,<=,>,>=} 0 [PR98737]\n\nOn Wed, Jan 27, 2021 at 12:27:13PM +0100, Ulrich Drepper via Gcc-patches wrote:\n> On 1/27/21 11:37 AM, Jakub Jelinek wrote:\n> > Would equality comparison against 0 handle the most common cases.\n> >\n> > The user can write it as\n> > __atomic_sub_fetch (x, y, z) == 0\n> > or\n> > __atomic_fetch_sub (x, y, z) - y == 0\n> > thouch, so the expansion code would need to be able to cope with both.\n>\n> Please also keep !=0, <0, <=0, >0, and >=0 in mind.  They all can be\n> useful and can be handled with the flags.\n\n<= 0 and > 0 don't really work well with lock {add,sub,inc,dec}, x86 doesn't\nhave comparisons that would look solely at both SF and ZF and not at other\nflags (and emitting two separate conditional jumps or two setcc insns and\noring them together looks awful).\n\nBut the rest can work.\n\nHere is a patch that adds internal functions and optabs for these,\nrecognizes them at the same spot as e.g. .ATOMIC_BIT_TEST_AND* internal\nfunctions (fold all builtins pass) and expands them appropriately (or for\nthe <= 0 and > 0 cases of +/- FAILs and let's middle-end fall back).\n\nSo far I have handled just the op_fetch builtins, IMHO instead of handling\nalso __atomic_fetch_sub (x, y, z) - y == 0 etc. we should canonicalize\n__atomic_fetch_sub (x, y, z) - y to __atomic_sub_fetch (x, y, z) (and vice\nversa).\n\n2022-01-03  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/98737\n\t* internal-fn.def (ATOMIC_ADD_FETCH_CMP_0, ATOMIC_SUB_FETCH_CMP_0,\n\tATOMIC_AND_FETCH_CMP_0, ATOMIC_OR_FETCH_CMP_0, ATOMIC_XOR_FETCH_CMP_0):\n\tNew internal fns.\n\t* internal-fn.h (ATOMIC_OP_FETCH_CMP_0_EQ, ATOMIC_OP_FETCH_CMP_0_NE,\n\tATOMIC_OP_FETCH_CMP_0_LT, ATOMIC_OP_FETCH_CMP_0_LE,\n\tATOMIC_OP_FETCH_CMP_0_GT, ATOMIC_OP_FETCH_CMP_0_GE): New enumerators.\n\t* internal-fn.c (expand_ATOMIC_ADD_FETCH_CMP_0,\n\texpand_ATOMIC_SUB_FETCH_CMP_0, expand_ATOMIC_AND_FETCH_CMP_0,\n\texpand_ATOMIC_OR_FETCH_CMP_0, expand_ATOMIC_XOR_FETCH_CMP_0): New\n\tfunctions.\n\t* optabs.def (atomic_add_fetch_cmp_0_optab,\n\tatomic_sub_fetch_cmp_0_optab, atomic_and_fetch_cmp_0_optab,\n\tatomic_or_fetch_cmp_0_optab, atomic_xor_fetch_cmp_0_optab): New\n\tdirect optabs.\n\t* builtins.h (expand_ifn_atomic_op_fetch_cmp_0): Declare.\n\t* builtins.c (expand_ifn_atomic_op_fetch_cmp_0): New function.\n\t* tree-ssa-ccp.c: Include internal-fn.h.\n\t(optimize_atomic_bit_test_and): Add . before internal fn call\n\tin function comment.  Change return type from void to bool and\n\treturn true only if successfully replaced.\n\t(optimize_atomic_op_fetch_cmp_0): New function.\n\t(pass_fold_builtins::execute): Use optimize_atomic_op_fetch_cmp_0\n\tfor BUILT_IN_ATOMIC_{ADD,SUB,AND,OR,XOR}_FETCH_{1,2,4,8,16} and\n\tBUILT_IN_SYNC_{ADD,SUB,AND,OR,XOR}_AND_FETCH_{1,2,4,8,16},\n\tfor *XOR* ones only if optimize_atomic_bit_test_and failed.\n\t* config/i386/sync.md (atomic_<plusminus_mnemonic>_fetch_cmp_0<mode>,\n\tatomic_<logic>_fetch_cmp_0<mode>): New define_expand patterns.\n\t(atomic_add_fetch_cmp_0<mode>_1, atomic_sub_fetch_cmp_0<mode>_1,\n\tatomic_<logic>_fetch_cmp_0<mode>_1): New define_insn patterns.\n\t* doc/md.texi (atomic_add_fetch_cmp_0<mode>,\n\tatomic_sub_fetch_cmp_0<mode>, atomic_and_fetch_cmp_0<mode>,\n\tatomic_or_fetch_cmp_0<mode>, atomic_xor_fetch_cmp_0<mode>): Document\n\tnew named patterns.\n\n\t* gcc.target/i386/pr98737-1.c: New test.\n\t* gcc.target/i386/pr98737-2.c: New test.\n\t* gcc.target/i386/pr98737-3.c: New test.\n\t* gcc.target/i386/pr98737-4.c: New test.\n\t* gcc.target/i386/pr98737-5.c: New test.\n\t* gcc.target/i386/pr98737-6.c: New test.\n\t* gcc.target/i386/pr98737-7.c: New test.", "tree": {"sha": "9fdac8e071aec28629541896854d11c29c2f8540", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fdac8e071aec28629541896854d11c29c2f8540"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6362627b27f395b054f359244fcfcb15ac0ac2ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6362627b27f395b054f359244fcfcb15ac0ac2ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6362627b27f395b054f359244fcfcb15ac0ac2ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6362627b27f395b054f359244fcfcb15ac0ac2ab/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4911609fbe47d3e4d2765cd67031a7e0ee9f5af0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4911609fbe47d3e4d2765cd67031a7e0ee9f5af0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4911609fbe47d3e4d2765cd67031a7e0ee9f5af0"}], "stats": {"total": 2169, "additions": 2133, "deletions": 36}, "files": [{"sha": "39b08af5aa61495c462d78f01de9b024e1eb2d26", "filename": "gcc/builtins.c", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=6362627b27f395b054f359244fcfcb15ac0ac2ab", "patch": "@@ -6276,6 +6276,93 @@ expand_ifn_atomic_bit_test_and (gcall *call)\n     emit_move_insn (target, result);\n }\n \n+/* Expand IFN_ATOMIC_*_FETCH_CMP_0 internal function.  */\n+\n+void\n+expand_ifn_atomic_op_fetch_cmp_0 (gcall *call)\n+{\n+  tree cmp = gimple_call_arg (call, 0);\n+  tree ptr = gimple_call_arg (call, 1);\n+  tree arg = gimple_call_arg (call, 2);\n+  tree lhs = gimple_call_lhs (call);\n+  enum memmodel model = MEMMODEL_SYNC_SEQ_CST;\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (cmp));\n+  optab optab;\n+  rtx_code code;\n+  class expand_operand ops[5];\n+\n+  gcc_assert (flag_inline_atomics);\n+\n+  if (gimple_call_num_args (call) == 4)\n+    model = get_memmodel (gimple_call_arg (call, 3));\n+\n+  rtx mem = get_builtin_sync_mem (ptr, mode);\n+  rtx op = expand_expr_force_mode (arg, mode);\n+\n+  switch (gimple_call_internal_fn (call))\n+    {\n+    case IFN_ATOMIC_ADD_FETCH_CMP_0:\n+      code = PLUS;\n+      optab = atomic_add_fetch_cmp_0_optab;\n+      break;\n+    case IFN_ATOMIC_SUB_FETCH_CMP_0:\n+      code = MINUS;\n+      optab = atomic_sub_fetch_cmp_0_optab;\n+      break;\n+    case IFN_ATOMIC_AND_FETCH_CMP_0:\n+      code = AND;\n+      optab = atomic_and_fetch_cmp_0_optab;\n+      break;\n+    case IFN_ATOMIC_OR_FETCH_CMP_0:\n+      code = IOR;\n+      optab = atomic_or_fetch_cmp_0_optab;\n+      break;\n+    case IFN_ATOMIC_XOR_FETCH_CMP_0:\n+      code = XOR;\n+      optab = atomic_xor_fetch_cmp_0_optab;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  enum rtx_code comp = UNKNOWN;\n+  switch (tree_to_uhwi (cmp))\n+    {\n+    case ATOMIC_OP_FETCH_CMP_0_EQ: comp = EQ; break;\n+    case ATOMIC_OP_FETCH_CMP_0_NE: comp = NE; break;\n+    case ATOMIC_OP_FETCH_CMP_0_GT: comp = GT; break;\n+    case ATOMIC_OP_FETCH_CMP_0_GE: comp = GE; break;\n+    case ATOMIC_OP_FETCH_CMP_0_LT: comp = LT; break;\n+    case ATOMIC_OP_FETCH_CMP_0_LE: comp = LE; break;\n+    default: gcc_unreachable ();\n+    }\n+\n+  rtx target;\n+  if (lhs == NULL_TREE)\n+    target = gen_reg_rtx (TYPE_MODE (boolean_type_node));\n+  else\n+    target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  enum insn_code icode = direct_optab_handler (optab, mode);\n+  gcc_assert (icode != CODE_FOR_nothing);\n+  create_output_operand (&ops[0], target, TYPE_MODE (boolean_type_node));\n+  create_fixed_operand (&ops[1], mem);\n+  create_convert_operand_to (&ops[2], op, mode, true);\n+  create_integer_operand (&ops[3], model);\n+  create_integer_operand (&ops[4], comp);\n+  if (maybe_expand_insn (icode, 5, ops))\n+    return;\n+\n+  rtx result = expand_atomic_fetch_op (gen_reg_rtx (mode), mem, op,\n+\t\t\t\t       code, model, true);\n+  if (lhs)\n+    {\n+      result = emit_store_flag_force (target, comp, result, const0_rtx, mode,\n+\t\t\t\t      0, 1);\n+      if (result != target)\n+\temit_move_insn (target, result);\n+    }\n+}\n+\n /* Expand an atomic clear operation.\n \tvoid _atomic_clear (BOOL *obj, enum memmodel)\n    EXP is the call expression.  */"}, {"sha": "ea10b4b097cde0603ed8cdd65f476c920274b8fd", "filename": "gcc/builtins.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=6362627b27f395b054f359244fcfcb15ac0ac2ab", "patch": "@@ -123,6 +123,7 @@ extern void std_expand_builtin_va_start (tree, rtx);\n extern void expand_builtin_trap (void);\n extern void expand_ifn_atomic_bit_test_and (gcall *);\n extern void expand_ifn_atomic_compare_exchange (gcall *);\n+extern void expand_ifn_atomic_op_fetch_cmp_0 (gcall *);\n extern rtx expand_builtin (tree, rtx, rtx, machine_mode, int);\n extern enum built_in_function builtin_mathfn_code (const_tree);\n extern tree fold_builtin_expect (location_t, tree, tree, tree, tree);"}, {"sha": "36417c54c11a5f1878a7a398acc81afde22bcd58", "filename": "gcc/config/i386/sync.md", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Fconfig%2Fi386%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Fconfig%2Fi386%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsync.md?ref=6362627b27f395b054f359244fcfcb15ac0ac2ab", "patch": "@@ -938,3 +938,107 @@\n \t(const_int 0))]\n   \"\"\n   \"lock{%;} %K2btr{<imodesuffix>}\\t{%1, %0|%0, %1}\")\n+\n+(define_expand \"atomic_<plusminus_mnemonic>_fetch_cmp_0<mode>\"\n+  [(match_operand:QI 0 \"register_operand\")\n+   (plusminus:SWI (match_operand:SWI 1 \"memory_operand\")\n+\t\t  (match_operand:SWI 2 \"nonmemory_operand\"))\n+   (match_operand:SI 3 \"const_int_operand\") ;; model\n+   (match_operand:SI 4 \"const_int_operand\")]\n+  \"\"\n+{\n+  if (INTVAL (operands[4]) == GT || INTVAL (operands[4]) == LE)\n+    FAIL;\n+  emit_insn (gen_atomic_<plusminus_mnemonic>_fetch_cmp_0<mode>_1 (operands[1],\n+\t\t\t\t\t\t\t\t  operands[2],\n+\t\t\t\t\t\t\t\t  operands[3]));\n+  ix86_expand_setcc (operands[0], (enum rtx_code) INTVAL (operands[4]),\n+\t\t     gen_rtx_REG (CCGOCmode, FLAGS_REG), const0_rtx);\n+  DONE;\n+})\n+\n+(define_insn \"atomic_add_fetch_cmp_0<mode>_1\"\n+  [(set (reg:CCGOC FLAGS_REG)\n+\t(compare:CCGOC\n+\t  (plus:SWI\n+\t    (unspec_volatile:SWI\n+\t      [(match_operand:SWI 0 \"memory_operand\" \"+m\")\n+\t       (match_operand:SI 2 \"const_int_operand\")]\t\t;; model\n+\t      UNSPECV_XCHG)\n+\t    (match_operand:SWI 1 \"nonmemory_operand\" \"<r><i>\"))\n+\t  (const_int 0)))\n+   (set (match_dup 0)\n+\t(plus:SWI (match_dup 0) (match_dup 1)))]\n+  \"\"\n+{\n+  if (incdec_operand (operands[1], <MODE>mode))\n+    {\n+      if (operands[1] == const1_rtx)\n+\treturn \"lock{%;} %K2inc{<imodesuffix>}\\t%0\";\n+      else\n+\treturn \"lock{%;} %K2dec{<imodesuffix>}\\t%0\";\n+    }\n+\n+  if (x86_maybe_negate_const_int (&operands[1], <MODE>mode))\n+    return \"lock{%;} %K2sub{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n+\n+  return \"lock{%;} %K2add{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n+})\n+\n+(define_insn \"atomic_sub_fetch_cmp_0<mode>_1\"\n+  [(set (reg:CCGOC FLAGS_REG)\n+\t(compare:CCGOC\n+\t  (minus:SWI\n+\t    (unspec_volatile:SWI\n+\t      [(match_operand:SWI 0 \"memory_operand\" \"+m\")\n+\t       (match_operand:SI 2 \"const_int_operand\")]\t\t;; model\n+\t      UNSPECV_XCHG)\n+\t    (match_operand:SWI 1 \"nonmemory_operand\" \"<r><i>\"))\n+\t  (const_int 0)))\n+   (set (match_dup 0)\n+\t(minus:SWI (match_dup 0) (match_dup 1)))]\n+  \"\"\n+{\n+  if (incdec_operand (operands[1], <MODE>mode))\n+    {\n+      if (operands[1] != const1_rtx)\n+\treturn \"lock{%;} %K2inc{<imodesuffix>}\\t%0\";\n+      else\n+\treturn \"lock{%;} %K2dec{<imodesuffix>}\\t%0\";\n+    }\n+\n+  if (x86_maybe_negate_const_int (&operands[1], <MODE>mode))\n+    return \"lock{%;} %K2add{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n+\n+  return \"lock{%;} %K2sub{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n+})\n+\n+(define_expand \"atomic_<logic>_fetch_cmp_0<mode>\"\n+  [(match_operand:QI 0 \"register_operand\")\n+   (any_logic:SWI (match_operand:SWI 1 \"memory_operand\")\n+\t\t  (match_operand:SWI 2 \"nonmemory_operand\"))\n+   (match_operand:SI 3 \"const_int_operand\") ;; model\n+   (match_operand:SI 4 \"const_int_operand\")]\n+  \"\"\n+{\n+  emit_insn (gen_atomic_<logic>_fetch_cmp_0<mode>_1 (operands[1], operands[2],\n+\t\t\t\t\t\t     operands[3]));\n+  ix86_expand_setcc (operands[0], (enum rtx_code) INTVAL (operands[4]),\n+\t\t     gen_rtx_REG (CCNOmode, FLAGS_REG), const0_rtx);\n+  DONE;\n+})\n+\n+(define_insn \"atomic_<logic>_fetch_cmp_0<mode>_1\"\n+  [(set (reg:CCNO FLAGS_REG)\n+\t(compare:CCNO\n+\t  (any_logic:SWI\n+\t    (unspec_volatile:SWI\n+\t      [(match_operand:SWI 0 \"memory_operand\" \"+m\")\n+\t       (match_operand:SI 2 \"const_int_operand\")]\t\t;; model\n+\t      UNSPECV_XCHG)\n+\t    (match_operand:SWI 1 \"nonmemory_operand\" \"<r><i>\"))\n+\t  (const_int 0)))\n+   (set (match_dup 0)\n+\t(any_logic:SWI (match_dup 0) (match_dup 1)))]\n+  \"\"\n+  \"lock{%;} %K2<logic>{<imodesuffix>}\\t{%1, %0|%0, %1}\")"}, {"sha": "19e89ae502bc2f51db64667b236c1cb669718b02", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=6362627b27f395b054f359244fcfcb15ac0ac2ab", "patch": "@@ -7918,6 +7918,30 @@ If these patterns are not defined, attempts will be made to use\n counterparts.  If none of these are available a compare-and-swap\n loop will be used.\n \n+@cindex @code{atomic_add_fetch_cmp_0@var{mode}} instruction pattern\n+@cindex @code{atomic_sub_fetch_cmp_0@var{mode}} instruction pattern\n+@cindex @code{atomic_and_fetch_cmp_0@var{mode}} instruction pattern\n+@cindex @code{atomic_or_fetch_cmp_0@var{mode}} instruction pattern\n+@cindex @code{atomic_xor_fetch_cmp_0@var{mode}} instruction pattern\n+@item @samp{atomic_add_fetch_cmp_0@var{mode}}\n+@itemx @samp{atomic_sub_fetch_cmp_0@var{mode}}\n+@itemx @samp{atomic_and_fetch_cmp_0@var{mode}}\n+@itemx @samp{atomic_or_fetch_cmp_0@var{mode}}\n+@itemx @samp{atomic_xor_fetch_cmp_0@var{mode}}\n+These patterns emit code for an atomic operation on memory with memory\n+model semantics if the fetch result is used only in a comparison against\n+zero.\n+Operand 0 is an output operand which contains a boolean result of comparison\n+of the value after the operation against zero.  Operand 1 is the memory on\n+which the atomic operation is performed.  Operand 2 is the second operand\n+to the binary operator.  Operand 3 is the memory model to be used by the\n+operation.  Operand 4 is an integer holding the comparison code, one of\n+@code{EQ}, @code{NE}, @code{LT}, @code{GT}, @code{LE} or @code{GE}.\n+\n+If these patterns are not defined, attempts will be made to use separate\n+atomic operation and fetch pattern followed by comparison of the result\n+against zero.\n+\n @cindex @code{mem_thread_fence} instruction pattern\n @item @samp{mem_thread_fence}\n This pattern emits code required to implement a thread fence with"}, {"sha": "b24102a5990bea4cbb102069f7a6df497fc81ebf", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=6362627b27f395b054f359244fcfcb15ac0ac2ab", "patch": "@@ -3238,6 +3238,46 @@ expand_ATOMIC_COMPARE_EXCHANGE (internal_fn, gcall *call)\n   expand_ifn_atomic_compare_exchange (call);\n }\n \n+/* Expand atomic add fetch and cmp with 0.  */\n+\n+static void\n+expand_ATOMIC_ADD_FETCH_CMP_0 (internal_fn, gcall *call)\n+{\n+  expand_ifn_atomic_op_fetch_cmp_0 (call);\n+}\n+\n+/* Expand atomic sub fetch and cmp with 0.  */\n+\n+static void\n+expand_ATOMIC_SUB_FETCH_CMP_0 (internal_fn, gcall *call)\n+{\n+  expand_ifn_atomic_op_fetch_cmp_0 (call);\n+}\n+\n+/* Expand atomic and fetch and cmp with 0.  */\n+\n+static void\n+expand_ATOMIC_AND_FETCH_CMP_0 (internal_fn, gcall *call)\n+{\n+  expand_ifn_atomic_op_fetch_cmp_0 (call);\n+}\n+\n+/* Expand atomic or fetch and cmp with 0.  */\n+\n+static void\n+expand_ATOMIC_OR_FETCH_CMP_0 (internal_fn, gcall *call)\n+{\n+  expand_ifn_atomic_op_fetch_cmp_0 (call);\n+}\n+\n+/* Expand atomic xor fetch and cmp with 0.  */\n+\n+static void\n+expand_ATOMIC_XOR_FETCH_CMP_0 (internal_fn, gcall *call)\n+{\n+  expand_ifn_atomic_op_fetch_cmp_0 (call);\n+}\n+\n /* Expand LAUNDER to assignment, lhs = arg0.  */\n \n static void"}, {"sha": "8891071a6a360961643731094379b607f317af17", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=6362627b27f395b054f359244fcfcb15ac0ac2ab", "patch": "@@ -403,6 +403,11 @@ DEF_INTERNAL_FN (ATOMIC_BIT_TEST_AND_SET, ECF_LEAF, NULL)\n DEF_INTERNAL_FN (ATOMIC_BIT_TEST_AND_COMPLEMENT, ECF_LEAF, NULL)\n DEF_INTERNAL_FN (ATOMIC_BIT_TEST_AND_RESET, ECF_LEAF, NULL)\n DEF_INTERNAL_FN (ATOMIC_COMPARE_EXCHANGE, ECF_LEAF, NULL)\n+DEF_INTERNAL_FN (ATOMIC_ADD_FETCH_CMP_0, ECF_LEAF, NULL)\n+DEF_INTERNAL_FN (ATOMIC_SUB_FETCH_CMP_0, ECF_LEAF, NULL)\n+DEF_INTERNAL_FN (ATOMIC_AND_FETCH_CMP_0, ECF_LEAF, NULL)\n+DEF_INTERNAL_FN (ATOMIC_OR_FETCH_CMP_0, ECF_LEAF, NULL)\n+DEF_INTERNAL_FN (ATOMIC_XOR_FETCH_CMP_0, ECF_LEAF, NULL)\n \n /* To implement [[fallthrough]].  */\n DEF_INTERNAL_FN (FALLTHROUGH, ECF_LEAF | ECF_NOTHROW, NULL)"}, {"sha": "743888b9638c39e9575b87544499843f5fcdac39", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=6362627b27f395b054f359244fcfcb15ac0ac2ab", "patch": "@@ -240,4 +240,13 @@ extern void expand_SHUFFLEVECTOR (internal_fn, gcall *);\n \n extern bool vectorized_internal_fn_supported_p (internal_fn, tree);\n \n+enum {\n+  ATOMIC_OP_FETCH_CMP_0_EQ = 0,\n+  ATOMIC_OP_FETCH_CMP_0_NE = 1,\n+  ATOMIC_OP_FETCH_CMP_0_LT = 2,\n+  ATOMIC_OP_FETCH_CMP_0_LE = 3,\n+  ATOMIC_OP_FETCH_CMP_0_GT = 4,\n+  ATOMIC_OP_FETCH_CMP_0_GE = 5\n+};\n+\n #endif"}, {"sha": "5fcf5386a0b3112ef9004055c82e15fe47668970", "filename": "gcc/optabs.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=6362627b27f395b054f359244fcfcb15ac0ac2ab", "patch": "@@ -451,6 +451,11 @@ OPTAB_D (atomic_sub_fetch_optab, \"atomic_sub_fetch$I$a\")\n OPTAB_D (atomic_sub_optab, \"atomic_sub$I$a\")\n OPTAB_D (atomic_xor_fetch_optab, \"atomic_xor_fetch$I$a\")\n OPTAB_D (atomic_xor_optab, \"atomic_xor$I$a\")\n+OPTAB_D (atomic_add_fetch_cmp_0_optab, \"atomic_add_fetch_cmp_0$I$a\")\n+OPTAB_D (atomic_sub_fetch_cmp_0_optab, \"atomic_sub_fetch_cmp_0$I$a\")\n+OPTAB_D (atomic_and_fetch_cmp_0_optab, \"atomic_and_fetch_cmp_0$I$a\")\n+OPTAB_D (atomic_or_fetch_cmp_0_optab, \"atomic_or_fetch_cmp_0$I$a\")\n+OPTAB_D (atomic_xor_fetch_cmp_0_optab, \"atomic_xor_fetch_cmp_0$I$a\")\n \n OPTAB_D (get_thread_pointer_optab, \"get_thread_pointer$I$a\")\n OPTAB_D (set_thread_pointer_optab, \"set_thread_pointer$I$a\")"}, {"sha": "33c84da51bb54e4cc292ee6d7932c1a5fec593a8", "filename": "gcc/testsuite/gcc.target/i386/pr98737-1.c", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98737-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98737-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98737-1.c?ref=6362627b27f395b054f359244fcfcb15ac0ac2ab", "patch": "@@ -0,0 +1,207 @@\n+/* PR target/98737 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -masm=att\" } */\n+/* { dg-additional-options \"-march=i686\" { target ia32 } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*subq\\t\" { target lp64 } } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*subl\\t\" } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*subw\\t\" } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*subb\\t\" } } */\n+/* { dg-final { scan-assembler-not \"lock\\[^\\n\\r]\\*xadd\" } } */\n+/* { dg-final { scan-assembler-not \"lock\\[^\\n\\r]\\*cmpxchg\" } } */\n+\n+long a;\n+int b;\n+short c;\n+char d;\n+\n+int\n+f1 (long x)\n+{\n+  return __atomic_sub_fetch (&a, x, __ATOMIC_RELEASE) == 0;\n+}\n+\n+int\n+f2 (int x)\n+{\n+  return __atomic_sub_fetch (&b, x, __ATOMIC_RELEASE) == 0;\n+}\n+\n+int\n+f3 (short x)\n+{\n+  return __atomic_sub_fetch (&c, x, __ATOMIC_RELEASE) == 0;\n+}\n+\n+int\n+f4 (char x)\n+{\n+  return __atomic_sub_fetch (&d, x, __ATOMIC_RELEASE) == 0;\n+}\n+\n+int\n+f5 (long x)\n+{\n+  return __atomic_sub_fetch (&a, x, __ATOMIC_RELEASE) != 0;\n+}\n+\n+int\n+f6 (int x)\n+{\n+  return __atomic_sub_fetch (&b, x, __ATOMIC_RELEASE) != 0;\n+}\n+\n+int\n+f7 (short x)\n+{\n+  return __atomic_sub_fetch (&c, x, __ATOMIC_RELEASE) != 0;\n+}\n+\n+int\n+f8 (char x)\n+{\n+  return __atomic_sub_fetch (&d, x, __ATOMIC_RELEASE) != 0;\n+}\n+\n+int\n+f9 (long x)\n+{\n+  return __atomic_sub_fetch (&a, x, __ATOMIC_RELEASE) < 0;\n+}\n+\n+int\n+f10 (int x)\n+{\n+  return __atomic_sub_fetch (&b, x, __ATOMIC_RELEASE) < 0;\n+}\n+\n+int\n+f11 (short x)\n+{\n+  return __atomic_sub_fetch (&c, x, __ATOMIC_RELEASE) < 0;\n+}\n+\n+int\n+f12 (char x)\n+{\n+  return __atomic_sub_fetch (&d, x, __ATOMIC_RELEASE) < 0;\n+}\n+\n+int\n+f13 (long x)\n+{\n+  return __atomic_sub_fetch (&a, x, __ATOMIC_RELEASE) >= 0;\n+}\n+\n+int\n+f14 (int x)\n+{\n+  return __atomic_sub_fetch (&b, x, __ATOMIC_RELEASE) >= 0;\n+}\n+\n+int\n+f15 (short x)\n+{\n+  return __atomic_sub_fetch (&c, x, __ATOMIC_RELEASE) >= 0;\n+}\n+\n+int\n+f16 (char x)\n+{\n+  return __atomic_sub_fetch (&d, x, __ATOMIC_RELEASE) >= 0;\n+}\n+\n+int\n+f17 (long x)\n+{\n+  return __sync_sub_and_fetch (&a, x) == 0;\n+}\n+\n+int\n+f18 (int x)\n+{\n+  return __sync_sub_and_fetch (&b, x) == 0;\n+}\n+\n+int\n+f19 (short x)\n+{\n+  return __sync_sub_and_fetch (&c, x) == 0;\n+}\n+\n+int\n+f20 (char x)\n+{\n+  return __sync_sub_and_fetch (&d, x) == 0;\n+}\n+\n+int\n+f21 (long x)\n+{\n+  return __sync_sub_and_fetch (&a, x) != 0;\n+}\n+\n+int\n+f22 (int x)\n+{\n+  return __sync_sub_and_fetch (&b, x) != 0;\n+}\n+\n+int\n+f23 (short x)\n+{\n+  return __sync_sub_and_fetch (&c, x) != 0;\n+}\n+\n+int\n+f24 (char x)\n+{\n+  return __sync_sub_and_fetch (&d, x) != 0;\n+}\n+\n+int\n+f25 (long x)\n+{\n+  return __sync_sub_and_fetch (&a, x) < 0;\n+}\n+\n+int\n+f26 (int x)\n+{\n+  return __sync_sub_and_fetch (&b, x) < 0;\n+}\n+\n+int\n+f27 (short x)\n+{\n+  return __sync_sub_and_fetch (&c, x) < 0;\n+}\n+\n+int\n+f28 (char x)\n+{\n+  return __sync_sub_and_fetch (&d, x) < 0;\n+}\n+\n+int\n+f29 (long x)\n+{\n+  return __sync_sub_and_fetch (&a, x) >= 0;\n+}\n+\n+int\n+f30 (int x)\n+{\n+  return __sync_sub_and_fetch (&b, x) >= 0;\n+}\n+\n+int\n+f31 (short x)\n+{\n+  return __sync_sub_and_fetch (&c, x) >= 0;\n+}\n+\n+int\n+f32 (char x)\n+{\n+  return __sync_sub_and_fetch (&d, x) >= 0;\n+}"}, {"sha": "53b674e90f52e9f3fb44cce2eed8e5838d7e5737", "filename": "gcc/testsuite/gcc.target/i386/pr98737-2.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98737-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98737-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98737-2.c?ref=6362627b27f395b054f359244fcfcb15ac0ac2ab", "patch": "@@ -0,0 +1,111 @@\n+/* PR target/98737 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -masm=att\" } */\n+/* { dg-additional-options \"-march=i686\" { target ia32 } } */\n+/* { dg-final { scan-assembler-not \"lock\\[^\\n\\r]\\*subq\\t\" } } */\n+/* { dg-final { scan-assembler-not \"lock\\[^\\n\\r]\\*subl\\t\" } } */\n+/* { dg-final { scan-assembler-not \"lock\\[^\\n\\r]\\*subw\\t\" } } */\n+/* { dg-final { scan-assembler-not \"lock\\[^\\n\\r]\\*subb\\t\" } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*xadd\" } } */\n+/* { dg-final { scan-assembler-not \"lock\\[^\\n\\r]\\*cmpxchg\" } } */\n+\n+long a;\n+int b;\n+short c;\n+char d;\n+\n+int\n+f1 (long x)\n+{\n+  return __atomic_sub_fetch (&a, x, __ATOMIC_RELEASE) <= 0;\n+}\n+\n+int\n+f2 (int x)\n+{\n+  return __atomic_sub_fetch (&b, x, __ATOMIC_RELEASE) <= 0;\n+}\n+\n+int\n+f3 (short x)\n+{\n+  return __atomic_sub_fetch (&c, x, __ATOMIC_RELEASE) <= 0;\n+}\n+\n+int\n+f4 (char x)\n+{\n+  return __atomic_sub_fetch (&d, x, __ATOMIC_RELEASE) <= 0;\n+}\n+\n+int\n+f5 (long x)\n+{\n+  return __atomic_sub_fetch (&a, x, __ATOMIC_RELEASE) > 0;\n+}\n+\n+int\n+f6 (int x)\n+{\n+  return __atomic_sub_fetch (&b, x, __ATOMIC_RELEASE) > 0;\n+}\n+\n+int\n+f7 (short x)\n+{\n+  return __atomic_sub_fetch (&c, x, __ATOMIC_RELEASE) > 0;\n+}\n+\n+int\n+f8 (char x)\n+{\n+  return __atomic_sub_fetch (&d, x, __ATOMIC_RELEASE) > 0;\n+}\n+\n+int\n+f9 (long x)\n+{\n+  return __sync_sub_and_fetch (&a, x) <= 0;\n+}\n+\n+int\n+f10 (int x)\n+{\n+  return __sync_sub_and_fetch (&b, x) <= 0;\n+}\n+\n+int\n+f11 (short x)\n+{\n+  return __sync_sub_and_fetch (&c, x) <= 0;\n+}\n+\n+int\n+f12 (char x)\n+{\n+  return __sync_sub_and_fetch (&d, x) <= 0;\n+}\n+\n+int\n+f13 (long x)\n+{\n+  return __sync_sub_and_fetch (&a, x) > 0;\n+}\n+\n+int\n+f14 (int x)\n+{\n+  return __sync_sub_and_fetch (&b, x) > 0;\n+}\n+\n+int\n+f15 (short x)\n+{\n+  return __sync_sub_and_fetch (&c, x) > 0;\n+}\n+\n+int\n+f16 (char x)\n+{\n+  return __sync_sub_and_fetch (&d, x) > 0;\n+}"}, {"sha": "0e7108ac5fb5a2ade59aba82c3452433f126841b", "filename": "gcc/testsuite/gcc.target/i386/pr98737-3.c", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98737-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98737-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98737-3.c?ref=6362627b27f395b054f359244fcfcb15ac0ac2ab", "patch": "@@ -0,0 +1,207 @@\n+/* PR target/98737 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -masm=att\" } */\n+/* { dg-additional-options \"-march=i686\" { target ia32 } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*addq\\t\" { target lp64 } } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*addl\\t\" } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*addw\\t\" } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*addb\\t\" } } */\n+/* { dg-final { scan-assembler-not \"lock\\[^\\n\\r]\\*xadd\" } } */\n+/* { dg-final { scan-assembler-not \"lock\\[^\\n\\r]\\*cmpxchg\" } } */\n+\n+long a;\n+int b;\n+short c;\n+char d;\n+\n+int\n+f1 (long x)\n+{\n+  return __atomic_add_fetch (&a, x, __ATOMIC_RELEASE) == 0;\n+}\n+\n+int\n+f2 (int x)\n+{\n+  return __atomic_add_fetch (&b, x, __ATOMIC_RELEASE) == 0;\n+}\n+\n+int\n+f3 (short x)\n+{\n+  return __atomic_add_fetch (&c, x, __ATOMIC_RELEASE) == 0;\n+}\n+\n+int\n+f4 (char x)\n+{\n+  return __atomic_add_fetch (&d, x, __ATOMIC_RELEASE) == 0;\n+}\n+\n+int\n+f5 (long x)\n+{\n+  return __atomic_add_fetch (&a, x, __ATOMIC_RELEASE) != 0;\n+}\n+\n+int\n+f6 (int x)\n+{\n+  return __atomic_add_fetch (&b, x, __ATOMIC_RELEASE) != 0;\n+}\n+\n+int\n+f7 (short x)\n+{\n+  return __atomic_add_fetch (&c, x, __ATOMIC_RELEASE) != 0;\n+}\n+\n+int\n+f8 (char x)\n+{\n+  return __atomic_add_fetch (&d, x, __ATOMIC_RELEASE) != 0;\n+}\n+\n+int\n+f9 (long x)\n+{\n+  return __atomic_add_fetch (&a, x, __ATOMIC_RELEASE) < 0;\n+}\n+\n+int\n+f10 (int x)\n+{\n+  return __atomic_add_fetch (&b, x, __ATOMIC_RELEASE) < 0;\n+}\n+\n+int\n+f11 (short x)\n+{\n+  return __atomic_add_fetch (&c, x, __ATOMIC_RELEASE) < 0;\n+}\n+\n+int\n+f12 (char x)\n+{\n+  return __atomic_add_fetch (&d, x, __ATOMIC_RELEASE) < 0;\n+}\n+\n+int\n+f13 (long x)\n+{\n+  return __atomic_add_fetch (&a, x, __ATOMIC_RELEASE) >= 0;\n+}\n+\n+int\n+f14 (int x)\n+{\n+  return __atomic_add_fetch (&b, x, __ATOMIC_RELEASE) >= 0;\n+}\n+\n+int\n+f15 (short x)\n+{\n+  return __atomic_add_fetch (&c, x, __ATOMIC_RELEASE) >= 0;\n+}\n+\n+int\n+f16 (char x)\n+{\n+  return __atomic_add_fetch (&d, x, __ATOMIC_RELEASE) >= 0;\n+}\n+\n+int\n+f17 (long x)\n+{\n+  return __sync_add_and_fetch (&a, x) == 0;\n+}\n+\n+int\n+f18 (int x)\n+{\n+  return __sync_add_and_fetch (&b, x) == 0;\n+}\n+\n+int\n+f19 (short x)\n+{\n+  return __sync_add_and_fetch (&c, x) == 0;\n+}\n+\n+int\n+f20 (char x)\n+{\n+  return __sync_add_and_fetch (&d, x) == 0;\n+}\n+\n+int\n+f21 (long x)\n+{\n+  return __sync_add_and_fetch (&a, x) != 0;\n+}\n+\n+int\n+f22 (int x)\n+{\n+  return __sync_add_and_fetch (&b, x) != 0;\n+}\n+\n+int\n+f23 (short x)\n+{\n+  return __sync_add_and_fetch (&c, x) != 0;\n+}\n+\n+int\n+f24 (char x)\n+{\n+  return __sync_add_and_fetch (&d, x) != 0;\n+}\n+\n+int\n+f25 (long x)\n+{\n+  return __sync_add_and_fetch (&a, x) < 0;\n+}\n+\n+int\n+f26 (int x)\n+{\n+  return __sync_add_and_fetch (&b, x) < 0;\n+}\n+\n+int\n+f27 (short x)\n+{\n+  return __sync_add_and_fetch (&c, x) < 0;\n+}\n+\n+int\n+f28 (char x)\n+{\n+  return __sync_add_and_fetch (&d, x) < 0;\n+}\n+\n+int\n+f29 (long x)\n+{\n+  return __sync_add_and_fetch (&a, x) >= 0;\n+}\n+\n+int\n+f30 (int x)\n+{\n+  return __sync_add_and_fetch (&b, x) >= 0;\n+}\n+\n+int\n+f31 (short x)\n+{\n+  return __sync_add_and_fetch (&c, x) >= 0;\n+}\n+\n+int\n+f32 (char x)\n+{\n+  return __sync_add_and_fetch (&d, x) >= 0;\n+}"}, {"sha": "8228d527d2bc20545279a9b9d4ee0093632810c2", "filename": "gcc/testsuite/gcc.target/i386/pr98737-4.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98737-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98737-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98737-4.c?ref=6362627b27f395b054f359244fcfcb15ac0ac2ab", "patch": "@@ -0,0 +1,111 @@\n+/* PR target/98737 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -masm=att\" } */\n+/* { dg-additional-options \"-march=i686\" { target ia32 } } */\n+/* { dg-final { scan-assembler-not \"lock\\[^\\n\\rx]\\*addq\\t\" } } */\n+/* { dg-final { scan-assembler-not \"lock\\[^\\n\\rx]\\*addl\\t\" } } */\n+/* { dg-final { scan-assembler-not \"lock\\[^\\n\\rx]\\*addw\\t\" } } */\n+/* { dg-final { scan-assembler-not \"lock\\[^\\n\\rx]\\*addb\\t\" } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*xadd\" } } */\n+/* { dg-final { scan-assembler-not \"lock\\[^\\n\\r]\\*cmpxchg\" } } */\n+\n+long a;\n+int b;\n+short c;\n+char d;\n+\n+int\n+f1 (long x)\n+{\n+  return __atomic_add_fetch (&a, x, __ATOMIC_RELEASE) <= 0;\n+}\n+\n+int\n+f2 (int x)\n+{\n+  return __atomic_add_fetch (&b, x, __ATOMIC_RELEASE) <= 0;\n+}\n+\n+int\n+f3 (short x)\n+{\n+  return __atomic_add_fetch (&c, x, __ATOMIC_RELEASE) <= 0;\n+}\n+\n+int\n+f4 (char x)\n+{\n+  return __atomic_add_fetch (&d, x, __ATOMIC_RELEASE) <= 0;\n+}\n+\n+int\n+f5 (long x)\n+{\n+  return __atomic_add_fetch (&a, x, __ATOMIC_RELEASE) > 0;\n+}\n+\n+int\n+f6 (int x)\n+{\n+  return __atomic_add_fetch (&b, x, __ATOMIC_RELEASE) > 0;\n+}\n+\n+int\n+f7 (short x)\n+{\n+  return __atomic_add_fetch (&c, x, __ATOMIC_RELEASE) > 0;\n+}\n+\n+int\n+f8 (char x)\n+{\n+  return __atomic_add_fetch (&d, x, __ATOMIC_RELEASE) > 0;\n+}\n+\n+int\n+f9 (long x)\n+{\n+  return __sync_add_and_fetch (&a, x) <= 0;\n+}\n+\n+int\n+f10 (int x)\n+{\n+  return __sync_add_and_fetch (&b, x) <= 0;\n+}\n+\n+int\n+f11 (short x)\n+{\n+  return __sync_add_and_fetch (&c, x) <= 0;\n+}\n+\n+int\n+f12 (char x)\n+{\n+  return __sync_add_and_fetch (&d, x) <= 0;\n+}\n+\n+int\n+f13 (long x)\n+{\n+  return __sync_add_and_fetch (&a, x) > 0;\n+}\n+\n+int\n+f14 (int x)\n+{\n+  return __sync_add_and_fetch (&b, x) > 0;\n+}\n+\n+int\n+f15 (short x)\n+{\n+  return __sync_add_and_fetch (&c, x) > 0;\n+}\n+\n+int\n+f16 (char x)\n+{\n+  return __sync_add_and_fetch (&d, x) > 0;\n+}"}, {"sha": "6d3e0638590ac2f7f68ebdf28bbdd173845cb551", "filename": "gcc/testsuite/gcc.target/i386/pr98737-5.c", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98737-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98737-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98737-5.c?ref=6362627b27f395b054f359244fcfcb15ac0ac2ab", "patch": "@@ -0,0 +1,303 @@\n+/* PR target/98737 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -masm=att\" } */\n+/* { dg-additional-options \"-march=i686\" { target ia32 } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*andq\\t\" { target lp64 } } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*andl\\t\" } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*andw\\t\" } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*andb\\t\" } } */\n+/* { dg-final { scan-assembler-not \"lock\\[^\\n\\r]\\*xadd\" } } */\n+/* { dg-final { scan-assembler-not \"lock\\[^\\n\\r]\\*cmpxchg\" } } */\n+\n+long a;\n+int b;\n+short c;\n+char d;\n+\n+int\n+f1 (long x)\n+{\n+  return __atomic_and_fetch (&a, x, __ATOMIC_RELEASE) == 0;\n+}\n+\n+int\n+f2 (int x)\n+{\n+  return __atomic_and_fetch (&b, x, __ATOMIC_RELEASE) == 0;\n+}\n+\n+int\n+f3 (short x)\n+{\n+  return __atomic_and_fetch (&c, x, __ATOMIC_RELEASE) == 0;\n+}\n+\n+int\n+f4 (char x)\n+{\n+  return __atomic_and_fetch (&d, x, __ATOMIC_RELEASE) == 0;\n+}\n+\n+int\n+f5 (long x)\n+{\n+  return __atomic_and_fetch (&a, x, __ATOMIC_RELEASE) != 0;\n+}\n+\n+int\n+f6 (int x)\n+{\n+  return __atomic_and_fetch (&b, x, __ATOMIC_RELEASE) != 0;\n+}\n+\n+int\n+f7 (short x)\n+{\n+  return __atomic_and_fetch (&c, x, __ATOMIC_RELEASE) != 0;\n+}\n+\n+int\n+f8 (char x)\n+{\n+  return __atomic_and_fetch (&d, x, __ATOMIC_RELEASE) != 0;\n+}\n+\n+int\n+f9 (long x)\n+{\n+  return __atomic_and_fetch (&a, x, __ATOMIC_RELEASE) < 0;\n+}\n+\n+int\n+f10 (int x)\n+{\n+  return __atomic_and_fetch (&b, x, __ATOMIC_RELEASE) < 0;\n+}\n+\n+int\n+f11 (short x)\n+{\n+  return __atomic_and_fetch (&c, x, __ATOMIC_RELEASE) < 0;\n+}\n+\n+int\n+f12 (char x)\n+{\n+  return __atomic_and_fetch (&d, x, __ATOMIC_RELEASE) < 0;\n+}\n+\n+int\n+f13 (long x)\n+{\n+  return __atomic_and_fetch (&a, x, __ATOMIC_RELEASE) >= 0;\n+}\n+\n+int\n+f14 (int x)\n+{\n+  return __atomic_and_fetch (&b, x, __ATOMIC_RELEASE) >= 0;\n+}\n+\n+int\n+f15 (short x)\n+{\n+  return __atomic_and_fetch (&c, x, __ATOMIC_RELEASE) >= 0;\n+}\n+\n+int\n+f16 (char x)\n+{\n+  return __atomic_and_fetch (&d, x, __ATOMIC_RELEASE) >= 0;\n+}\n+\n+int\n+f17 (long x)\n+{\n+  return __sync_and_and_fetch (&a, x) == 0;\n+}\n+\n+int\n+f18 (int x)\n+{\n+  return __sync_and_and_fetch (&b, x) == 0;\n+}\n+\n+int\n+f19 (short x)\n+{\n+  return __sync_and_and_fetch (&c, x) == 0;\n+}\n+\n+int\n+f20 (char x)\n+{\n+  return __sync_and_and_fetch (&d, x) == 0;\n+}\n+\n+int\n+f21 (long x)\n+{\n+  return __sync_and_and_fetch (&a, x) != 0;\n+}\n+\n+int\n+f22 (int x)\n+{\n+  return __sync_and_and_fetch (&b, x) != 0;\n+}\n+\n+int\n+f23 (short x)\n+{\n+  return __sync_and_and_fetch (&c, x) != 0;\n+}\n+\n+int\n+f24 (char x)\n+{\n+  return __sync_and_and_fetch (&d, x) != 0;\n+}\n+\n+int\n+f25 (long x)\n+{\n+  return __sync_and_and_fetch (&a, x) < 0;\n+}\n+\n+int\n+f26 (int x)\n+{\n+  return __sync_and_and_fetch (&b, x) < 0;\n+}\n+\n+int\n+f27 (short x)\n+{\n+  return __sync_and_and_fetch (&c, x) < 0;\n+}\n+\n+int\n+f28 (char x)\n+{\n+  return __sync_and_and_fetch (&d, x) < 0;\n+}\n+\n+int\n+f29 (long x)\n+{\n+  return __sync_and_and_fetch (&a, x) >= 0;\n+}\n+\n+int\n+f30 (int x)\n+{\n+  return __sync_and_and_fetch (&b, x) >= 0;\n+}\n+\n+int\n+f31 (short x)\n+{\n+  return __sync_and_and_fetch (&c, x) >= 0;\n+}\n+\n+int\n+f32 (char x)\n+{\n+  return __sync_and_and_fetch (&d, x) >= 0;\n+}\n+\n+int\n+f33 (long x)\n+{\n+  return __atomic_and_fetch (&a, x, __ATOMIC_RELEASE) <= 0;\n+}\n+\n+int\n+f34 (int x)\n+{\n+  return __atomic_and_fetch (&b, x, __ATOMIC_RELEASE) <= 0;\n+}\n+\n+int\n+f35 (short x)\n+{\n+  return __atomic_and_fetch (&c, x, __ATOMIC_RELEASE) <= 0;\n+}\n+\n+int\n+f36 (char x)\n+{\n+  return __atomic_and_fetch (&d, x, __ATOMIC_RELEASE) <= 0;\n+}\n+\n+int\n+f37 (long x)\n+{\n+  return __atomic_and_fetch (&a, x, __ATOMIC_RELEASE) > 0;\n+}\n+\n+int\n+f38 (int x)\n+{\n+  return __atomic_and_fetch (&b, x, __ATOMIC_RELEASE) > 0;\n+}\n+\n+int\n+f39 (short x)\n+{\n+  return __atomic_and_fetch (&c, x, __ATOMIC_RELEASE) > 0;\n+}\n+\n+int\n+f40 (char x)\n+{\n+  return __atomic_and_fetch (&d, x, __ATOMIC_RELEASE) > 0;\n+}\n+\n+int\n+f41 (long x)\n+{\n+  return __sync_and_and_fetch (&a, x) <= 0;\n+}\n+\n+int\n+f42 (int x)\n+{\n+  return __sync_and_and_fetch (&b, x) <= 0;\n+}\n+\n+int\n+f43 (short x)\n+{\n+  return __sync_and_and_fetch (&c, x) <= 0;\n+}\n+\n+int\n+f44 (char x)\n+{\n+  return __sync_and_and_fetch (&d, x) <= 0;\n+}\n+\n+int\n+f45 (long x)\n+{\n+  return __sync_and_and_fetch (&a, x) > 0;\n+}\n+\n+int\n+f46 (int x)\n+{\n+  return __sync_and_and_fetch (&b, x) > 0;\n+}\n+\n+int\n+f47 (short x)\n+{\n+  return __sync_and_and_fetch (&c, x) > 0;\n+}\n+\n+int\n+f48 (char x)\n+{\n+  return __sync_and_and_fetch (&d, x) > 0;\n+}"}, {"sha": "6cc1c3ae17f0f74e52710010f9a391c0fa494f54", "filename": "gcc/testsuite/gcc.target/i386/pr98737-6.c", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98737-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98737-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98737-6.c?ref=6362627b27f395b054f359244fcfcb15ac0ac2ab", "patch": "@@ -0,0 +1,303 @@\n+/* PR target/98737 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -masm=att\" } */\n+/* { dg-additional-options \"-march=i686\" { target ia32 } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*orq\\t\" { target lp64 } } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*orl\\t\" } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*orw\\t\" } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*orb\\t\" } } */\n+/* { dg-final { scan-assembler-not \"lock\\[^\\n\\r]\\*xadd\" } } */\n+/* { dg-final { scan-assembler-not \"lock\\[^\\n\\r]\\*cmpxchg\" } } */\n+\n+long a;\n+int b;\n+short c;\n+char d;\n+\n+int\n+f1 (long x)\n+{\n+  return __atomic_or_fetch (&a, x, __ATOMIC_RELEASE) == 0;\n+}\n+\n+int\n+f2 (int x)\n+{\n+  return __atomic_or_fetch (&b, x, __ATOMIC_RELEASE) == 0;\n+}\n+\n+int\n+f3 (short x)\n+{\n+  return __atomic_or_fetch (&c, x, __ATOMIC_RELEASE) == 0;\n+}\n+\n+int\n+f4 (char x)\n+{\n+  return __atomic_or_fetch (&d, x, __ATOMIC_RELEASE) == 0;\n+}\n+\n+int\n+f5 (long x)\n+{\n+  return __atomic_or_fetch (&a, x, __ATOMIC_RELEASE) != 0;\n+}\n+\n+int\n+f6 (int x)\n+{\n+  return __atomic_or_fetch (&b, x, __ATOMIC_RELEASE) != 0;\n+}\n+\n+int\n+f7 (short x)\n+{\n+  return __atomic_or_fetch (&c, x, __ATOMIC_RELEASE) != 0;\n+}\n+\n+int\n+f8 (char x)\n+{\n+  return __atomic_or_fetch (&d, x, __ATOMIC_RELEASE) != 0;\n+}\n+\n+int\n+f9 (long x)\n+{\n+  return __atomic_or_fetch (&a, x, __ATOMIC_RELEASE) < 0;\n+}\n+\n+int\n+f10 (int x)\n+{\n+  return __atomic_or_fetch (&b, x, __ATOMIC_RELEASE) < 0;\n+}\n+\n+int\n+f11 (short x)\n+{\n+  return __atomic_or_fetch (&c, x, __ATOMIC_RELEASE) < 0;\n+}\n+\n+int\n+f12 (char x)\n+{\n+  return __atomic_or_fetch (&d, x, __ATOMIC_RELEASE) < 0;\n+}\n+\n+int\n+f13 (long x)\n+{\n+  return __atomic_or_fetch (&a, x, __ATOMIC_RELEASE) >= 0;\n+}\n+\n+int\n+f14 (int x)\n+{\n+  return __atomic_or_fetch (&b, x, __ATOMIC_RELEASE) >= 0;\n+}\n+\n+int\n+f15 (short x)\n+{\n+  return __atomic_or_fetch (&c, x, __ATOMIC_RELEASE) >= 0;\n+}\n+\n+int\n+f16 (char x)\n+{\n+  return __atomic_or_fetch (&d, x, __ATOMIC_RELEASE) >= 0;\n+}\n+\n+int\n+f17 (long x)\n+{\n+  return __sync_or_and_fetch (&a, x) == 0;\n+}\n+\n+int\n+f18 (int x)\n+{\n+  return __sync_or_and_fetch (&b, x) == 0;\n+}\n+\n+int\n+f19 (short x)\n+{\n+  return __sync_or_and_fetch (&c, x) == 0;\n+}\n+\n+int\n+f20 (char x)\n+{\n+  return __sync_or_and_fetch (&d, x) == 0;\n+}\n+\n+int\n+f21 (long x)\n+{\n+  return __sync_or_and_fetch (&a, x) != 0;\n+}\n+\n+int\n+f22 (int x)\n+{\n+  return __sync_or_and_fetch (&b, x) != 0;\n+}\n+\n+int\n+f23 (short x)\n+{\n+  return __sync_or_and_fetch (&c, x) != 0;\n+}\n+\n+int\n+f24 (char x)\n+{\n+  return __sync_or_and_fetch (&d, x) != 0;\n+}\n+\n+int\n+f25 (long x)\n+{\n+  return __sync_or_and_fetch (&a, x) < 0;\n+}\n+\n+int\n+f26 (int x)\n+{\n+  return __sync_or_and_fetch (&b, x) < 0;\n+}\n+\n+int\n+f27 (short x)\n+{\n+  return __sync_or_and_fetch (&c, x) < 0;\n+}\n+\n+int\n+f28 (char x)\n+{\n+  return __sync_or_and_fetch (&d, x) < 0;\n+}\n+\n+int\n+f29 (long x)\n+{\n+  return __sync_or_and_fetch (&a, x) >= 0;\n+}\n+\n+int\n+f30 (int x)\n+{\n+  return __sync_or_and_fetch (&b, x) >= 0;\n+}\n+\n+int\n+f31 (short x)\n+{\n+  return __sync_or_and_fetch (&c, x) >= 0;\n+}\n+\n+int\n+f32 (char x)\n+{\n+  return __sync_or_and_fetch (&d, x) >= 0;\n+}\n+\n+int\n+f33 (long x)\n+{\n+  return __atomic_or_fetch (&a, x, __ATOMIC_RELEASE) <= 0;\n+}\n+\n+int\n+f34 (int x)\n+{\n+  return __atomic_or_fetch (&b, x, __ATOMIC_RELEASE) <= 0;\n+}\n+\n+int\n+f35 (short x)\n+{\n+  return __atomic_or_fetch (&c, x, __ATOMIC_RELEASE) <= 0;\n+}\n+\n+int\n+f36 (char x)\n+{\n+  return __atomic_or_fetch (&d, x, __ATOMIC_RELEASE) <= 0;\n+}\n+\n+int\n+f37 (long x)\n+{\n+  return __atomic_or_fetch (&a, x, __ATOMIC_RELEASE) > 0;\n+}\n+\n+int\n+f38 (int x)\n+{\n+  return __atomic_or_fetch (&b, x, __ATOMIC_RELEASE) > 0;\n+}\n+\n+int\n+f39 (short x)\n+{\n+  return __atomic_or_fetch (&c, x, __ATOMIC_RELEASE) > 0;\n+}\n+\n+int\n+f40 (char x)\n+{\n+  return __atomic_or_fetch (&d, x, __ATOMIC_RELEASE) > 0;\n+}\n+\n+int\n+f41 (long x)\n+{\n+  return __sync_or_and_fetch (&a, x) <= 0;\n+}\n+\n+int\n+f42 (int x)\n+{\n+  return __sync_or_and_fetch (&b, x) <= 0;\n+}\n+\n+int\n+f43 (short x)\n+{\n+  return __sync_or_and_fetch (&c, x) <= 0;\n+}\n+\n+int\n+f44 (char x)\n+{\n+  return __sync_or_and_fetch (&d, x) <= 0;\n+}\n+\n+int\n+f45 (long x)\n+{\n+  return __sync_or_and_fetch (&a, x) > 0;\n+}\n+\n+int\n+f46 (int x)\n+{\n+  return __sync_or_and_fetch (&b, x) > 0;\n+}\n+\n+int\n+f47 (short x)\n+{\n+  return __sync_or_and_fetch (&c, x) > 0;\n+}\n+\n+int\n+f48 (char x)\n+{\n+  return __sync_or_and_fetch (&d, x) > 0;\n+}"}, {"sha": "2da23c44650a2562b202cff004a0eec9666deca4", "filename": "gcc/testsuite/gcc.target/i386/pr98737-7.c", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98737-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98737-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98737-7.c?ref=6362627b27f395b054f359244fcfcb15ac0ac2ab", "patch": "@@ -0,0 +1,303 @@\n+/* PR target/98737 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -masm=att\" } */\n+/* { dg-additional-options \"-march=i686\" { target ia32 } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*xorq\\t\" { target lp64 } } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*xorl\\t\" } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*xorw\\t\" } } */\n+/* { dg-final { scan-assembler \"lock\\[^\\n\\r]\\*xorb\\t\" } } */\n+/* { dg-final { scan-assembler-not \"lock\\[^\\n\\r]\\*xadd\" } } */\n+/* { dg-final { scan-assembler-not \"lock\\[^\\n\\r]\\*cmpxchg\" } } */\n+\n+long a;\n+int b;\n+short c;\n+char d;\n+\n+int\n+f1 (long x)\n+{\n+  return __atomic_xor_fetch (&a, x, __ATOMIC_RELEASE) == 0;\n+}\n+\n+int\n+f2 (int x)\n+{\n+  return __atomic_xor_fetch (&b, x, __ATOMIC_RELEASE) == 0;\n+}\n+\n+int\n+f3 (short x)\n+{\n+  return __atomic_xor_fetch (&c, x, __ATOMIC_RELEASE) == 0;\n+}\n+\n+int\n+f4 (char x)\n+{\n+  return __atomic_xor_fetch (&d, x, __ATOMIC_RELEASE) == 0;\n+}\n+\n+int\n+f5 (long x)\n+{\n+  return __atomic_xor_fetch (&a, x, __ATOMIC_RELEASE) != 0;\n+}\n+\n+int\n+f6 (int x)\n+{\n+  return __atomic_xor_fetch (&b, x, __ATOMIC_RELEASE) != 0;\n+}\n+\n+int\n+f7 (short x)\n+{\n+  return __atomic_xor_fetch (&c, x, __ATOMIC_RELEASE) != 0;\n+}\n+\n+int\n+f8 (char x)\n+{\n+  return __atomic_xor_fetch (&d, x, __ATOMIC_RELEASE) != 0;\n+}\n+\n+int\n+f9 (long x)\n+{\n+  return __atomic_xor_fetch (&a, x, __ATOMIC_RELEASE) < 0;\n+}\n+\n+int\n+f10 (int x)\n+{\n+  return __atomic_xor_fetch (&b, x, __ATOMIC_RELEASE) < 0;\n+}\n+\n+int\n+f11 (short x)\n+{\n+  return __atomic_xor_fetch (&c, x, __ATOMIC_RELEASE) < 0;\n+}\n+\n+int\n+f12 (char x)\n+{\n+  return __atomic_xor_fetch (&d, x, __ATOMIC_RELEASE) < 0;\n+}\n+\n+int\n+f13 (long x)\n+{\n+  return __atomic_xor_fetch (&a, x, __ATOMIC_RELEASE) >= 0;\n+}\n+\n+int\n+f14 (int x)\n+{\n+  return __atomic_xor_fetch (&b, x, __ATOMIC_RELEASE) >= 0;\n+}\n+\n+int\n+f15 (short x)\n+{\n+  return __atomic_xor_fetch (&c, x, __ATOMIC_RELEASE) >= 0;\n+}\n+\n+int\n+f16 (char x)\n+{\n+  return __atomic_xor_fetch (&d, x, __ATOMIC_RELEASE) >= 0;\n+}\n+\n+int\n+f17 (long x)\n+{\n+  return __sync_xor_and_fetch (&a, x) == 0;\n+}\n+\n+int\n+f18 (int x)\n+{\n+  return __sync_xor_and_fetch (&b, x) == 0;\n+}\n+\n+int\n+f19 (short x)\n+{\n+  return __sync_xor_and_fetch (&c, x) == 0;\n+}\n+\n+int\n+f20 (char x)\n+{\n+  return __sync_xor_and_fetch (&d, x) == 0;\n+}\n+\n+int\n+f21 (long x)\n+{\n+  return __sync_xor_and_fetch (&a, x) != 0;\n+}\n+\n+int\n+f22 (int x)\n+{\n+  return __sync_xor_and_fetch (&b, x) != 0;\n+}\n+\n+int\n+f23 (short x)\n+{\n+  return __sync_xor_and_fetch (&c, x) != 0;\n+}\n+\n+int\n+f24 (char x)\n+{\n+  return __sync_xor_and_fetch (&d, x) != 0;\n+}\n+\n+int\n+f25 (long x)\n+{\n+  return __sync_xor_and_fetch (&a, x) < 0;\n+}\n+\n+int\n+f26 (int x)\n+{\n+  return __sync_xor_and_fetch (&b, x) < 0;\n+}\n+\n+int\n+f27 (short x)\n+{\n+  return __sync_xor_and_fetch (&c, x) < 0;\n+}\n+\n+int\n+f28 (char x)\n+{\n+  return __sync_xor_and_fetch (&d, x) < 0;\n+}\n+\n+int\n+f29 (long x)\n+{\n+  return __sync_xor_and_fetch (&a, x) >= 0;\n+}\n+\n+int\n+f30 (int x)\n+{\n+  return __sync_xor_and_fetch (&b, x) >= 0;\n+}\n+\n+int\n+f31 (short x)\n+{\n+  return __sync_xor_and_fetch (&c, x) >= 0;\n+}\n+\n+int\n+f32 (char x)\n+{\n+  return __sync_xor_and_fetch (&d, x) >= 0;\n+}\n+\n+int\n+f33 (long x)\n+{\n+  return __atomic_xor_fetch (&a, x, __ATOMIC_RELEASE) <= 0;\n+}\n+\n+int\n+f34 (int x)\n+{\n+  return __atomic_xor_fetch (&b, x, __ATOMIC_RELEASE) <= 0;\n+}\n+\n+int\n+f35 (short x)\n+{\n+  return __atomic_xor_fetch (&c, x, __ATOMIC_RELEASE) <= 0;\n+}\n+\n+int\n+f36 (char x)\n+{\n+  return __atomic_xor_fetch (&d, x, __ATOMIC_RELEASE) <= 0;\n+}\n+\n+int\n+f37 (long x)\n+{\n+  return __atomic_xor_fetch (&a, x, __ATOMIC_RELEASE) > 0;\n+}\n+\n+int\n+f38 (int x)\n+{\n+  return __atomic_xor_fetch (&b, x, __ATOMIC_RELEASE) > 0;\n+}\n+\n+int\n+f39 (short x)\n+{\n+  return __atomic_xor_fetch (&c, x, __ATOMIC_RELEASE) > 0;\n+}\n+\n+int\n+f40 (char x)\n+{\n+  return __atomic_xor_fetch (&d, x, __ATOMIC_RELEASE) > 0;\n+}\n+\n+int\n+f41 (long x)\n+{\n+  return __sync_xor_and_fetch (&a, x) <= 0;\n+}\n+\n+int\n+f42 (int x)\n+{\n+  return __sync_xor_and_fetch (&b, x) <= 0;\n+}\n+\n+int\n+f43 (short x)\n+{\n+  return __sync_xor_and_fetch (&c, x) <= 0;\n+}\n+\n+int\n+f44 (char x)\n+{\n+  return __sync_xor_and_fetch (&d, x) <= 0;\n+}\n+\n+int\n+f45 (long x)\n+{\n+  return __sync_xor_and_fetch (&a, x) > 0;\n+}\n+\n+int\n+f46 (int x)\n+{\n+  return __sync_xor_and_fetch (&b, x) > 0;\n+}\n+\n+int\n+f47 (short x)\n+{\n+  return __sync_xor_and_fetch (&c, x) > 0;\n+}\n+\n+int\n+f48 (char x)\n+{\n+  return __sync_xor_and_fetch (&d, x) > 0;\n+}"}, {"sha": "93fa5367fb500689553e037bcdaacc3c39e2169d", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 313, "deletions": 36, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6362627b27f395b054f359244fcfcb15ac0ac2ab/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=6362627b27f395b054f359244fcfcb15ac0ac2ab", "patch": "@@ -151,6 +151,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"symbol-summary.h\"\n #include \"ipa-utils.h\"\n #include \"ipa-prop.h\"\n+#include \"internal-fn.h\"\n \n /* Possible lattice values.  */\n typedef enum\n@@ -3333,7 +3334,7 @@ extern bool gimple_nop_convert (tree, tree*, tree (*) (tree));\n      _4 = __atomic_fetch_or_* (ptr_6, mask_2, _3);\n      _5 = _4 & mask_2;\n    to\n-     _4 = ATOMIC_BIT_TEST_AND_SET (ptr_6, cnt_1, 0, _3);\n+     _4 = .ATOMIC_BIT_TEST_AND_SET (ptr_6, cnt_1, 0, _3);\n      _5 = _4;\n    If _5 is only used in _5 != 0 or _5 == 0 comparisons, 1\n    is passed instead of 0, and the builtin just returns a zero\n@@ -3345,7 +3346,7 @@ extern bool gimple_nop_convert (tree, tree*, tree (*) (tree));\n    the second argument to the builtin needs to be one's complement\n    of the mask instead of mask.  */\n \n-static void\n+static bool\n optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n \t\t\t      enum internal_fn fn, bool has_model_arg,\n \t\t\t      bool after)\n@@ -3365,7 +3366,7 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n       || !single_imm_use (lhs, &use_p, &use_stmt)\n       || !is_gimple_assign (use_stmt)\n       || !gimple_vdef (call))\n-    return;\n+    return false;\n \n   switch (fn)\n     {\n@@ -3379,7 +3380,7 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n       optab = atomic_bit_test_and_reset_optab;\n       break;\n     default:\n-      return;\n+      return false;\n     }\n \n   tree bit = nullptr;\n@@ -3389,20 +3390,20 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n   if (rhs_code != BIT_AND_EXPR)\n     {\n       if (rhs_code != NOP_EXPR && rhs_code != BIT_NOT_EXPR)\n-\treturn;\n+\treturn false;\n \n       tree use_lhs = gimple_assign_lhs (use_stmt);\n       if (TREE_CODE (use_lhs) == SSA_NAME\n \t  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (use_lhs))\n-\treturn;\n+\treturn false;\n \n       tree use_rhs = gimple_assign_rhs1 (use_stmt);\n       if (lhs != use_rhs)\n-\treturn;\n+\treturn false;\n \n       if (optab_handler (optab, TYPE_MODE (TREE_TYPE (lhs)))\n \t  == CODE_FOR_nothing)\n-\treturn;\n+\treturn false;\n \n       gimple *g;\n       gimple_stmt_iterator gsi;\n@@ -3413,7 +3414,7 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n \t{\n \t  g = convert_atomic_bit_not (fn, use_stmt, lhs, mask);\n \t  if (!g)\n-\t    return;\n+\t    return false;\n \t  use_stmt = g;\n \t  ibit = 0;\n \t}\n@@ -3426,7 +3427,7 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n \t      if (!operand_equal_p (build_int_cst (TREE_TYPE (lhs),\n \t\t\t\t\t\t   ~HOST_WIDE_INT_1),\n \t\t\t\t    mask, 0))\n-\t\treturn;\n+\t\treturn false;\n \n \t      /* Convert\n \t\t _1 = __atomic_fetch_and_* (ptr_6, ~1, _3);\n@@ -3442,7 +3443,7 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n \t    {\n \t      and_mask = build_int_cst (TREE_TYPE (lhs), 1);\n \t      if (!operand_equal_p (and_mask, mask, 0))\n-\t\treturn;\n+\t\treturn false;\n \n \t      /* Convert\n \t\t _1 = __atomic_fetch_or_* (ptr_6, 1, _3);\n@@ -3468,20 +3469,20 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n \t  gimple *use_nop_stmt;\n \t  if (!single_imm_use (use_lhs, &use_p, &use_nop_stmt)\n \t      || !is_gimple_assign (use_nop_stmt))\n-\t    return;\n+\t    return false;\n \t  tree use_nop_lhs = gimple_assign_lhs (use_nop_stmt);\n \t  rhs_code = gimple_assign_rhs_code (use_nop_stmt);\n \t  if (rhs_code != BIT_AND_EXPR)\n \t    {\n \t      if (TREE_CODE (use_nop_lhs) == SSA_NAME\n \t\t  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (use_nop_lhs))\n-\t\treturn;\n+\t\treturn false;\n \t      if (rhs_code == BIT_NOT_EXPR)\n \t\t{\n \t\t  g = convert_atomic_bit_not (fn, use_nop_stmt, lhs,\n \t\t\t\t\t      mask);\n \t\t  if (!g)\n-\t\t    return;\n+\t\t    return false;\n \t\t  /* Convert\n \t\t     _1 = __atomic_fetch_or_4 (ptr_6, 1, _3);\n \t\t     _2 = (int) _1;\n@@ -3509,15 +3510,15 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n \t      else\n \t\t{\n \t\t  if (TREE_CODE (TREE_TYPE (use_nop_lhs)) != BOOLEAN_TYPE)\n-\t\t    return;\n+\t\t    return false;\n \t\t  if (rhs_code != GE_EXPR && rhs_code != LT_EXPR)\n-\t\t    return;\n+\t\t    return false;\n \t\t  tree cmp_rhs1 = gimple_assign_rhs1 (use_nop_stmt);\n \t\t  if (use_lhs != cmp_rhs1)\n-\t\t    return;\n+\t\t    return false;\n \t\t  tree cmp_rhs2 = gimple_assign_rhs2 (use_nop_stmt);\n \t\t  if (!integer_zerop (cmp_rhs2))\n-\t\t    return;\n+\t\t    return false;\n \n \t\t  tree and_mask;\n \n@@ -3533,7 +3534,7 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n \t\t      and_mask = build_int_cst (TREE_TYPE (use_rhs),\n \t\t\t\t\t\thighest - 1);\n \t\t      if (!operand_equal_p (and_mask, mask, 0))\n-\t\t\treturn;\n+\t\t\treturn false;\n \n \t\t      /* Convert\n \t\t\t _1 = __atomic_fetch_and_4 (ptr_6, 0x7fffffff, _3);\n@@ -3553,7 +3554,7 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n \t\t      and_mask = build_int_cst (TREE_TYPE (use_rhs),\n \t\t\t\t\t\thighest);\n \t\t      if (!operand_equal_p (and_mask, mask, 0))\n-\t\t\treturn;\n+\t\t\treturn false;\n \n \t\t      /* Convert\n \t\t\t _1 = __atomic_fetch_or_4 (ptr_6, 0x80000000, _3);\n@@ -3592,7 +3593,7 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n \t\t  || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (match_op[2])\n \t\t  || !single_imm_use (match_op[2], &use_p, &g)\n \t\t  || !is_gimple_assign (g))\n-\t\treturn;\n+\t\treturn false;\n \t      mask = match_op[0];\n \t      if (TREE_CODE (match_op[1]) == INTEGER_CST)\n \t\t{\n@@ -3650,7 +3651,7 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n \t    }\n \t}\n       else\n-\treturn;\n+\treturn false;\n \n       if (!bit)\n \t{\n@@ -3661,11 +3662,11 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n     }\n   else if (optab_handler (optab, TYPE_MODE (TREE_TYPE (lhs)))\n \t   == CODE_FOR_nothing)\n-    return;\n+    return false;\n \n   tree use_lhs = gimple_assign_lhs (use_stmt);\n   if (!use_lhs)\n-    return;\n+    return false;\n \n   if (!bit)\n     {\n@@ -3676,7 +3677,7 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n \t  mask = fold_convert (TREE_TYPE (lhs), mask);\n \t  int ibit = tree_log2 (mask);\n \t  if (ibit < 0)\n-\t    return;\n+\t    return false;\n \t  bit = build_int_cst (TREE_TYPE (lhs), ibit);\n \t}\n       else if (TREE_CODE (mask) == SSA_NAME)\n@@ -3687,30 +3688,30 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n \t    {\n \t      mask = match_op;\n \t      if (TREE_CODE (mask) != SSA_NAME)\n-\t\treturn;\n+\t\treturn false;\n \t      g = SSA_NAME_DEF_STMT (mask);\n \t    }\n \t  if (!is_gimple_assign (g))\n-\t    return;\n+\t    return false;\n \n \t  if (fn == IFN_ATOMIC_BIT_TEST_AND_RESET)\n \t    {\n \t      if (gimple_assign_rhs_code (g) != BIT_NOT_EXPR)\n-\t\treturn;\n+\t\treturn false;\n \t      mask = gimple_assign_rhs1 (g);\n \t      if (TREE_CODE (mask) != SSA_NAME)\n-\t\treturn;\n+\t\treturn false;\n \t      g = SSA_NAME_DEF_STMT (mask);\n \t    }\n \n \t  if (!is_gimple_assign (g)\n \t      || gimple_assign_rhs_code (g) != LSHIFT_EXPR\n \t      || !integer_onep (gimple_assign_rhs1 (g)))\n-\t    return;\n+\t    return false;\n \t  bit = gimple_assign_rhs2 (g);\n \t}\n       else\n-\treturn;\n+\treturn false;\n \n       tree cmp_mask;\n       if (gimple_assign_rhs1 (use_stmt) == lhs)\n@@ -3723,7 +3724,7 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n \tcmp_mask = match_op;\n \n       if (!operand_equal_p (cmp_mask, mask, 0))\n-\treturn;\n+\treturn false;\n     }\n \n   bool use_bool = true;\n@@ -3748,6 +3749,8 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n \t  case COND_EXPR:\n \t    op1 = gimple_assign_rhs1 (g);\n \t    code = TREE_CODE (op1);\n+\t    if (TREE_CODE_CLASS (code) != tcc_comparison)\n+\t      break;\n \t    op0 = TREE_OPERAND (op1, 0);\n \t    op1 = TREE_OPERAND (op1, 1);\n \t    break;\n@@ -3864,6 +3867,196 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n   release_defs (use_stmt);\n   gsi_remove (gsip, true);\n   release_ssa_name (lhs);\n+  return true;\n+}\n+\n+/* Optimize\n+     _4 = __atomic_add_fetch_* (ptr_6, arg_2, _3);\n+     _5 = _4 == 0;\n+   to\n+     _4 = .ATOMIC_ADD_FETCH_CMP_0 (EQ_EXPR, ptr_6, arg_2, _3);\n+     _5 = _4;\n+   Similarly for __sync_add_and_fetch_* (without the \", _3\" part\n+   in there).  */\n+\n+static bool\n+optimize_atomic_op_fetch_cmp_0 (gimple_stmt_iterator *gsip,\n+\t\t\t\tenum internal_fn fn, bool has_model_arg)\n+{\n+  gimple *call = gsi_stmt (*gsip);\n+  tree lhs = gimple_call_lhs (call);\n+  use_operand_p use_p;\n+  gimple *use_stmt;\n+\n+  if (!flag_inline_atomics\n+      || optimize_debug\n+      || !gimple_call_builtin_p (call, BUILT_IN_NORMAL)\n+      || !lhs\n+      || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs)\n+      || !single_imm_use (lhs, &use_p, &use_stmt)\n+      || !gimple_vdef (call))\n+    return false;\n+\n+  optab optab;\n+  switch (fn)\n+    {\n+    case IFN_ATOMIC_ADD_FETCH_CMP_0:\n+      optab = atomic_add_fetch_cmp_0_optab;\n+      break;\n+    case IFN_ATOMIC_SUB_FETCH_CMP_0:\n+      optab = atomic_sub_fetch_cmp_0_optab;\n+      break;\n+    case IFN_ATOMIC_AND_FETCH_CMP_0:\n+      optab = atomic_and_fetch_cmp_0_optab;\n+      break;\n+    case IFN_ATOMIC_OR_FETCH_CMP_0:\n+      optab = atomic_or_fetch_cmp_0_optab;\n+      break;\n+    case IFN_ATOMIC_XOR_FETCH_CMP_0:\n+      optab = atomic_xor_fetch_cmp_0_optab;\n+      break;\n+    default:\n+      return false;\n+    }\n+\n+  if (optab_handler (optab, TYPE_MODE (TREE_TYPE (lhs)))\n+      == CODE_FOR_nothing)\n+    return false;\n+\n+  tree use_lhs = lhs;\n+  if (gimple_assign_cast_p (use_stmt))\n+    {\n+      use_lhs = gimple_assign_lhs (use_stmt);\n+      if (!tree_nop_conversion_p (TREE_TYPE (use_lhs), TREE_TYPE (lhs))\n+\t  || (!INTEGRAL_TYPE_P (TREE_TYPE (use_lhs))\n+\t      && !POINTER_TYPE_P (TREE_TYPE (use_lhs)))\n+\t  || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (use_lhs)\n+\t  || !single_imm_use (use_lhs, &use_p, &use_stmt))\n+\treturn false;\n+    }\n+  enum tree_code code = ERROR_MARK;\n+  tree op0 = NULL_TREE, op1 = NULL_TREE;\n+  if (is_gimple_assign (use_stmt))\n+    switch (gimple_assign_rhs_code (use_stmt))\n+      {\n+      case COND_EXPR:\n+\top1 = gimple_assign_rhs1 (use_stmt);\n+\tcode = TREE_CODE (op1);\n+\tif (TREE_CODE_CLASS (code) == tcc_comparison)\n+\t  {\n+\t    op0 = TREE_OPERAND (op1, 0);\n+\t    op1 = TREE_OPERAND (op1, 1);\n+\t  }\n+\tbreak;\n+      default:\n+\tcode = gimple_assign_rhs_code (use_stmt);\n+\tif (TREE_CODE_CLASS (code) == tcc_comparison)\n+\t  {\n+\t    op0 = gimple_assign_rhs1 (use_stmt);\n+\t    op1 = gimple_assign_rhs2 (use_stmt);\n+\t  }\n+\tbreak;\n+      }\n+  else if (gimple_code (use_stmt) == GIMPLE_COND)\n+    {\n+      code = gimple_cond_code (use_stmt);\n+      op0 = gimple_cond_lhs (use_stmt);\n+      op1 = gimple_cond_rhs (use_stmt);\n+    }\n+\n+  switch (code)\n+    {\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (use_lhs))\n+\t  || TREE_CODE (TREE_TYPE (use_lhs)) == BOOLEAN_TYPE\n+\t  || TYPE_UNSIGNED (TREE_TYPE (use_lhs)))\n+\treturn false;\n+      /* FALLTHRU */\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+      if (op0 == use_lhs && integer_zerop (op1))\n+\tbreak;\n+      return false;\n+    default:\n+      return false;\n+    }\n+\n+  int encoded;\n+  switch (code)\n+    {\n+    /* Use special encoding of the operation.  We want to also\n+       encode the mode in the first argument and for neither EQ_EXPR\n+       etc. nor EQ etc. we can rely it will fit into QImode.  */\n+    case EQ_EXPR: encoded = ATOMIC_OP_FETCH_CMP_0_EQ; break;\n+    case NE_EXPR: encoded = ATOMIC_OP_FETCH_CMP_0_NE; break;\n+    case LT_EXPR: encoded = ATOMIC_OP_FETCH_CMP_0_LT; break;\n+    case LE_EXPR: encoded = ATOMIC_OP_FETCH_CMP_0_LE; break;\n+    case GT_EXPR: encoded = ATOMIC_OP_FETCH_CMP_0_GT; break;\n+    case GE_EXPR: encoded = ATOMIC_OP_FETCH_CMP_0_GE; break;\n+    default: gcc_unreachable ();\n+    }\n+\n+  tree new_lhs = make_ssa_name (boolean_type_node);\n+  gimple *g;\n+  tree flag = build_int_cst (TREE_TYPE (lhs), encoded);\n+  if (has_model_arg)\n+    g = gimple_build_call_internal (fn, 4, flag,\n+\t\t\t\t    gimple_call_arg (call, 0),\n+\t\t\t\t    gimple_call_arg (call, 1),\n+\t\t\t\t    gimple_call_arg (call, 2));\n+  else\n+    g = gimple_build_call_internal (fn, 3, flag,\n+\t\t\t\t    gimple_call_arg (call, 0),\n+\t\t\t\t    gimple_call_arg (call, 1));\n+  gimple_call_set_lhs (g, new_lhs);\n+  gimple_set_location (g, gimple_location (call));\n+  gimple_move_vops (g, call);\n+  bool throws = stmt_can_throw_internal (cfun, call);\n+  gimple_call_set_nothrow (as_a <gcall *> (g),\n+\t\t\t   gimple_call_nothrow_p (as_a <gcall *> (call)));\n+  gimple_stmt_iterator gsi = *gsip;\n+  gsi_insert_after (&gsi, g, GSI_SAME_STMT);\n+  if (throws)\n+    maybe_clean_or_replace_eh_stmt (call, g);\n+  if (is_gimple_assign (use_stmt))\n+    switch (gimple_assign_rhs_code (use_stmt))\n+      {\n+      case COND_EXPR:\n+\tgimple_assign_set_rhs1 (use_stmt, new_lhs);\n+\tbreak;\n+      default:\n+\tgsi = gsi_for_stmt (use_stmt);\n+\tif (tree ulhs = gimple_assign_lhs (use_stmt))\n+\t  if (useless_type_conversion_p (TREE_TYPE (ulhs),\n+\t\t\t\t\t boolean_type_node))\n+\t    {\n+\t      gimple_assign_set_rhs_with_ops (&gsi, SSA_NAME, new_lhs);\n+\t      break;\n+\t    }\n+\tgimple_assign_set_rhs_with_ops (&gsi, NOP_EXPR, new_lhs);\n+\tbreak;\n+      }\n+  else if (gimple_code (use_stmt) == GIMPLE_COND)\n+    {\n+      gcond *use_cond = as_a <gcond *> (use_stmt);\n+      gimple_cond_set_code (use_cond, NE_EXPR);\n+      gimple_cond_set_lhs (use_cond, new_lhs);\n+      gimple_cond_set_rhs (use_cond, boolean_false_node);\n+    }\n+\n+  update_stmt (use_stmt);\n+  if (use_lhs != lhs)\n+    {\n+      gsi = gsi_for_stmt (SSA_NAME_DEF_STMT (use_lhs));\n+      gsi_remove (&gsi, true);\n+      release_ssa_name (use_lhs);\n+    }\n+  gsi_remove (gsip, true);\n+  release_ssa_name (lhs);\n+  return true;\n }\n \n /* Optimize\n@@ -4092,6 +4285,44 @@ pass_fold_builtins::execute (function *fun)\n \t\t    cfg_changed = true;\n \t\t  break;\n \n+\t\tcase BUILT_IN_ATOMIC_ADD_FETCH_1:\n+\t\tcase BUILT_IN_ATOMIC_ADD_FETCH_2:\n+\t\tcase BUILT_IN_ATOMIC_ADD_FETCH_4:\n+\t\tcase BUILT_IN_ATOMIC_ADD_FETCH_8:\n+\t\tcase BUILT_IN_ATOMIC_ADD_FETCH_16:\n+\t\t  optimize_atomic_op_fetch_cmp_0 (&i,\n+\t\t\t\t\t\t  IFN_ATOMIC_ADD_FETCH_CMP_0,\n+\t\t\t\t\t\t  true);\n+\t\t  break;\n+\t\tcase BUILT_IN_SYNC_ADD_AND_FETCH_1:\n+\t\tcase BUILT_IN_SYNC_ADD_AND_FETCH_2:\n+\t\tcase BUILT_IN_SYNC_ADD_AND_FETCH_4:\n+\t\tcase BUILT_IN_SYNC_ADD_AND_FETCH_8:\n+\t\tcase BUILT_IN_SYNC_ADD_AND_FETCH_16:\n+\t\t  optimize_atomic_op_fetch_cmp_0 (&i,\n+\t\t\t\t\t\t  IFN_ATOMIC_ADD_FETCH_CMP_0,\n+\t\t\t\t\t\t  false);\n+\t\t  break;\n+\n+\t\tcase BUILT_IN_ATOMIC_SUB_FETCH_1:\n+\t\tcase BUILT_IN_ATOMIC_SUB_FETCH_2:\n+\t\tcase BUILT_IN_ATOMIC_SUB_FETCH_4:\n+\t\tcase BUILT_IN_ATOMIC_SUB_FETCH_8:\n+\t\tcase BUILT_IN_ATOMIC_SUB_FETCH_16:\n+\t\t  optimize_atomic_op_fetch_cmp_0 (&i,\n+\t\t\t\t\t\t  IFN_ATOMIC_SUB_FETCH_CMP_0,\n+\t\t\t\t\t\t  true);\n+\t\t  break;\n+\t\tcase BUILT_IN_SYNC_SUB_AND_FETCH_1:\n+\t\tcase BUILT_IN_SYNC_SUB_AND_FETCH_2:\n+\t\tcase BUILT_IN_SYNC_SUB_AND_FETCH_4:\n+\t\tcase BUILT_IN_SYNC_SUB_AND_FETCH_8:\n+\t\tcase BUILT_IN_SYNC_SUB_AND_FETCH_16:\n+\t\t  optimize_atomic_op_fetch_cmp_0 (&i,\n+\t\t\t\t\t\t  IFN_ATOMIC_SUB_FETCH_CMP_0,\n+\t\t\t\t\t\t  false);\n+\t\t  break;\n+\n \t\tcase BUILT_IN_ATOMIC_FETCH_OR_1:\n \t\tcase BUILT_IN_ATOMIC_FETCH_OR_2:\n \t\tcase BUILT_IN_ATOMIC_FETCH_OR_4:\n@@ -4133,16 +4364,24 @@ pass_fold_builtins::execute (function *fun)\n \t\tcase BUILT_IN_ATOMIC_XOR_FETCH_4:\n \t\tcase BUILT_IN_ATOMIC_XOR_FETCH_8:\n \t\tcase BUILT_IN_ATOMIC_XOR_FETCH_16:\n-\t\t  optimize_atomic_bit_test_and\n-\t\t\t(&i, IFN_ATOMIC_BIT_TEST_AND_COMPLEMENT, true, true);\n+\t\t  if (optimize_atomic_bit_test_and\n+\t\t\t(&i, IFN_ATOMIC_BIT_TEST_AND_COMPLEMENT, true, true))\n+\t\t    break;\n+\t\t  optimize_atomic_op_fetch_cmp_0 (&i,\n+\t\t\t\t\t\t  IFN_ATOMIC_XOR_FETCH_CMP_0,\n+\t\t\t\t\t\t  true);\n \t\t  break;\n \t\tcase BUILT_IN_SYNC_XOR_AND_FETCH_1:\n \t\tcase BUILT_IN_SYNC_XOR_AND_FETCH_2:\n \t\tcase BUILT_IN_SYNC_XOR_AND_FETCH_4:\n \t\tcase BUILT_IN_SYNC_XOR_AND_FETCH_8:\n \t\tcase BUILT_IN_SYNC_XOR_AND_FETCH_16:\n-\t\t  optimize_atomic_bit_test_and\n-\t\t\t(&i, IFN_ATOMIC_BIT_TEST_AND_COMPLEMENT, false, true);\n+\t\t  if (optimize_atomic_bit_test_and\n+\t\t\t(&i, IFN_ATOMIC_BIT_TEST_AND_COMPLEMENT, false, true))\n+\t\t    break;\n+\t\t  optimize_atomic_op_fetch_cmp_0 (&i,\n+\t\t\t\t\t\t  IFN_ATOMIC_XOR_FETCH_CMP_0,\n+\t\t\t\t\t\t  false);\n \t\t  break;\n \n \t\tcase BUILT_IN_ATOMIC_FETCH_AND_1:\n@@ -4164,6 +4403,44 @@ pass_fold_builtins::execute (function *fun)\n \t\t\t\t\t\tfalse, false);\n \t\t  break;\n \n+\t\tcase BUILT_IN_ATOMIC_AND_FETCH_1:\n+\t\tcase BUILT_IN_ATOMIC_AND_FETCH_2:\n+\t\tcase BUILT_IN_ATOMIC_AND_FETCH_4:\n+\t\tcase BUILT_IN_ATOMIC_AND_FETCH_8:\n+\t\tcase BUILT_IN_ATOMIC_AND_FETCH_16:\n+\t\t  optimize_atomic_op_fetch_cmp_0 (&i,\n+\t\t\t\t\t\t  IFN_ATOMIC_AND_FETCH_CMP_0,\n+\t\t\t\t\t\t  true);\n+\t\t  break;\n+\t\tcase BUILT_IN_SYNC_AND_AND_FETCH_1:\n+\t\tcase BUILT_IN_SYNC_AND_AND_FETCH_2:\n+\t\tcase BUILT_IN_SYNC_AND_AND_FETCH_4:\n+\t\tcase BUILT_IN_SYNC_AND_AND_FETCH_8:\n+\t\tcase BUILT_IN_SYNC_AND_AND_FETCH_16:\n+\t\t  optimize_atomic_op_fetch_cmp_0 (&i,\n+\t\t\t\t\t\t  IFN_ATOMIC_AND_FETCH_CMP_0,\n+\t\t\t\t\t\t  false);\n+\t\t  break;\n+\n+\t\tcase BUILT_IN_ATOMIC_OR_FETCH_1:\n+\t\tcase BUILT_IN_ATOMIC_OR_FETCH_2:\n+\t\tcase BUILT_IN_ATOMIC_OR_FETCH_4:\n+\t\tcase BUILT_IN_ATOMIC_OR_FETCH_8:\n+\t\tcase BUILT_IN_ATOMIC_OR_FETCH_16:\n+\t\t  optimize_atomic_op_fetch_cmp_0 (&i,\n+\t\t\t\t\t\t  IFN_ATOMIC_OR_FETCH_CMP_0,\n+\t\t\t\t\t\t  true);\n+\t\t  break;\n+\t\tcase BUILT_IN_SYNC_OR_AND_FETCH_1:\n+\t\tcase BUILT_IN_SYNC_OR_AND_FETCH_2:\n+\t\tcase BUILT_IN_SYNC_OR_AND_FETCH_4:\n+\t\tcase BUILT_IN_SYNC_OR_AND_FETCH_8:\n+\t\tcase BUILT_IN_SYNC_OR_AND_FETCH_16:\n+\t\t  optimize_atomic_op_fetch_cmp_0 (&i,\n+\t\t\t\t\t\t  IFN_ATOMIC_OR_FETCH_CMP_0,\n+\t\t\t\t\t\t  false);\n+\t\t  break;\n+\n \t\tcase BUILT_IN_MEMCPY:\n \t\t  if (gimple_call_builtin_p (stmt, BUILT_IN_NORMAL)\n \t\t      && TREE_CODE (gimple_call_arg (stmt, 0)) == ADDR_EXPR"}]}