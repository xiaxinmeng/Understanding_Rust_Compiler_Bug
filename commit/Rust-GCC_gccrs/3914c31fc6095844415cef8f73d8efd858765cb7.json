{"sha": "3914c31fc6095844415cef8f73d8efd858765cb7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkxNGMzMWZjNjA5NTg0NDQxNWNlZjhmNzNkOGVmZDg1ODc2NWNiNw==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2003-12-20T17:24:15Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2003-12-20T17:24:15Z"}, "message": "pa.h (TRAMPOLINE_TEMPLATE): Shorten sequence when generating PA 2.0 code.\n\n\t* pa.h (TRAMPOLINE_TEMPLATE): Shorten sequence when generating PA\n\t2.0 code.\n\t(TRAMPOLINE_CODE_SIZE, MIN_CACHELINE_SIZE): New defines.\n\t(INITIALIZE_TRAMPOLINE): Rework to pass line length, and aligned start\n\tand end addresses to I and D cache instruction patterns.\n\t* pa.md (anddi3, iordi3): Change predicates of operands 1 and 2 to\n\tand_operand and ior_operand, respectively.  When generating 64-bit\n\tcode, only one operand needs to be a register operand.\n\t(xordi3): Change predicates of operands 1 and 2 to register_operand.\n\t(one_cmpldi2): Change predicate of operand 1 to register_operand.\n\t(dcacheflush, icacheflush): Revise to flush an arbitrary number of\n\tcache lines.\n\nFrom-SVN: r74888", "tree": {"sha": "ad63993b40749ecdb0b5c476c3c3a8a3d6c0edf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad63993b40749ecdb0b5c476c3c3a8a3d6c0edf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3914c31fc6095844415cef8f73d8efd858765cb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3914c31fc6095844415cef8f73d8efd858765cb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3914c31fc6095844415cef8f73d8efd858765cb7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3914c31fc6095844415cef8f73d8efd858765cb7/comments", "author": null, "committer": null, "parents": [{"sha": "6ae533cf8947fe7f6e536adf5431b13e28f844f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ae533cf8947fe7f6e536adf5431b13e28f844f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ae533cf8947fe7f6e536adf5431b13e28f844f3"}], "stats": {"total": 261, "additions": 183, "deletions": 78}, "files": [{"sha": "6e4bac81ce3e8c752d2c431f3aeb716ec83c31fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3914c31fc6095844415cef8f73d8efd858765cb7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3914c31fc6095844415cef8f73d8efd858765cb7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3914c31fc6095844415cef8f73d8efd858765cb7", "patch": "@@ -1,3 +1,18 @@\n+2003-12-20  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\t* pa.h (TRAMPOLINE_TEMPLATE): Shorten sequence when generating PA\n+\t2.0 code.\n+\t(TRAMPOLINE_CODE_SIZE, MIN_CACHELINE_SIZE): New defines.\n+\t(INITIALIZE_TRAMPOLINE): Rework to pass line length, and aligned start\n+\tand end addresses to I and D cache instruction patterns.\n+\t* pa.md (anddi3, iordi3): Change predicates of operands 1 and 2 to\n+\tand_operand and ior_operand, respectively.  When generating 64-bit\n+\tcode, only one operand needs to be a register operand.\n+\t(xordi3): Change predicates of operands 1 and 2 to register_operand.\n+\t(one_cmpldi2): Change predicate of operand 1 to register_operand.\n+\t(dcacheflush, icacheflush): Revise to flush an arbitrary number of\n+\tcache lines.\n+\n 2003-12-20  Josef Zlomek  <zlomekj@suse.cz>\n \n \tPR optimization/13430, PR optimization/12322"}, {"sha": "312d58c4213462a2591fcc4aa84d1078707d2175", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 89, "deletions": 43, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3914c31fc6095844415cef8f73d8efd858765cb7/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3914c31fc6095844415cef8f73d8efd858765cb7/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=3914c31fc6095844415cef8f73d8efd858765cb7", "patch": "@@ -1003,10 +1003,20 @@ extern int may_call_alloca;\n \t  fputs (\"\\tdepwi\t0,31,2,%r21\\n\", FILE);\t\t\t\\\n \tfputs (\"\\tldw\t4(%r21),%r19\\n\", FILE);\t\t\t\t\\\n \tfputs (\"\\tldw\t0(%r21),%r21\\n\", FILE);\t\t\t\t\\\n-\tfputs (\"\\tldsid\t(%r21),%r1\\n\", FILE);\t\t\t\t\\\n-\tfputs (\"\\tmtsp\t%r1,%sr0\\n\", FILE);\t\t\t\t\\\n-\tfputs (\"\\tbe\t0(%sr0,%r21)\\n\", FILE);\t\t\t\t\\\n-\tfputs (\"\\tldw\t40(%r22),%r29\\n\", FILE);\t\t\t\\\n+\tif (TARGET_PA_20)\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    fputs (\"\\tbve\t(%r21)\\n\", FILE);\t\t\t\\\n+\t    fputs (\"\\tldw\t40(%r22),%r29\\n\", FILE);\t\t\\\n+\t    fputs (\"\\t.word\t0\\n\", FILE);\t\t\t\t\\\n+\t    fputs (\"\\t.word\t0\\n\", FILE);\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    fputs (\"\\tldsid\t(%r21),%r1\\n\", FILE);\t\t\t\\\n+\t    fputs (\"\\tmtsp\t%r1,%sr0\\n\", FILE);\t\t\t\\\n+\t    fputs (\"\\tbe\t0(%sr0,%r21)\\n\", FILE);\t\t\t\\\n+\t    fputs (\"\\tldw\t40(%r22),%r29\\n\", FILE);\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n \tfputs (\"\\t.word\t0\\n\", FILE);\t\t\t\t\t\\\n \tfputs (\"\\t.word\t0\\n\", FILE);\t\t\t\t\t\\\n \tfputs (\"\\t.word\t0\\n\", FILE);\t\t\t\t\t\\\n@@ -1029,16 +1039,21 @@ extern int may_call_alloca;\n       }\t\t\t\t\t\t\t\t\t\\\n   }\n \n-/* Length in units of the trampoline for entering a nested function.\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE (TARGET_64BIT ? 72 : 52)\n \n-   Flush the cache entries corresponding to the first and last addresses\n-   of the trampoline.  This is necessary as the trampoline may cross two\n-   cache lines.\n+/* Length in units of the trampoline instruction code.  */\n \n-   If the code part of the trampoline ever grows to > 32 bytes, then it\n-   will become necessary to hack on the cacheflush pattern in pa.md.  */\n+#define TRAMPOLINE_CODE_SIZE (TARGET_64BIT ? 24 : (TARGET_PA_20 ? 32 : 40))\n \n-#define TRAMPOLINE_SIZE (TARGET_64BIT ? 72 : 52)\n+/* Minimum length of a cache line.  A length of 16 will work on all\n+   PA-RISC processors.  All PA 1.1 processors have a cache line of\n+   32 bytes.  Most but not all PA 2.0 processors have a cache line\n+   of 64 bytes.  As cache flushes are expensive and we don't support\n+   PA 1.0, we use a minimum length of 32.  */\n+\n+#define MIN_CACHELINE_SIZE 32\n \n /* Emit RTL insns to initialize the variable parts of a trampoline.\n    FNADDR is an RTX for the address of the function's pure code.\n@@ -1048,54 +1063,85 @@ extern int may_call_alloca;\n    Move the static chain value to trampoline template at offset 40.\n    Move the trampoline address to trampoline template at offset 44.\n    Move r19 to trampoline template at offset 48.  The latter two\n-   words create a plabel for the indirect call to the trampoline.  */\n+   words create a plabel for the indirect call to the trampoline.\n+\n+   A similar sequence is used for the 64-bit port but the plabel is\n+   at the beginning of the trampoline.\n+\n+   Finally, the cache entries for the trampoline code are flushed.\n+   This is necessary to ensure that the trampoline instruction sequence\n+   is written to memory prior to any attempts at prefetching the code\n+   sequence.  */\n \n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n+  rtx start_addr = gen_reg_rtx (Pmode);\t\t\t\t\t\\\n+  rtx end_addr = gen_reg_rtx (Pmode);\t\t\t\t\t\\\n+  rtx line_length = gen_reg_rtx (Pmode);\t\t\t\t\\\n+  rtx tmp;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n   if (!TARGET_64BIT)\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      rtx start_addr, end_addr;\t\t\t\t\t\t\\\n+      tmp = memory_address (Pmode, plus_constant ((TRAMP), 36));\t\\\n+      emit_move_insn (gen_rtx_MEM (Pmode, tmp), (FNADDR));\t\t\\\n+      tmp = memory_address (Pmode, plus_constant ((TRAMP), 40));\t\\\n+      emit_move_insn (gen_rtx_MEM (Pmode, tmp), (CXT));\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      start_addr = memory_address (Pmode, plus_constant ((TRAMP), 36));\t\\\n-      emit_move_insn (gen_rtx_MEM (Pmode, start_addr), (FNADDR));\t\\\n-      start_addr = memory_address (Pmode, plus_constant ((TRAMP), 40));\t\\\n-      emit_move_insn (gen_rtx_MEM (Pmode, start_addr), (CXT));\t\t\\\n-      start_addr = memory_address (Pmode, plus_constant ((TRAMP), 44));\t\\\n-      emit_move_insn (gen_rtx_MEM (Pmode, start_addr), (TRAMP));\t\\\n-      start_addr = memory_address (Pmode, plus_constant ((TRAMP), 48));\t\\\n-      emit_move_insn (gen_rtx_MEM (Pmode, start_addr),\t\t\t\\\n+      /* Create a fat pointer for the trampoline.  */\t\t\t\\\n+      tmp = memory_address (Pmode, plus_constant ((TRAMP), 44));\t\\\n+      emit_move_insn (gen_rtx_MEM (Pmode, tmp), (TRAMP));\t\t\\\n+      tmp = memory_address (Pmode, plus_constant ((TRAMP), 48));\t\\\n+      emit_move_insn (gen_rtx_MEM (Pmode, tmp),\t\t\t\t\\\n \t\t      gen_rtx_REG (Pmode, 19));\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n       /* fdc and fic only use registers for the address to flush,\t\\\n-\t they do not accept integer displacements.  */ \t\t\t\\\n-      start_addr = force_reg (Pmode, (TRAMP));\t\t\t\t\\\n-      end_addr = force_reg (Pmode, plus_constant ((TRAMP), 32));\t\\\n-      emit_insn (gen_dcacheflush (start_addr, end_addr));\t\t\\\n-      emit_insn (gen_icacheflush (start_addr, end_addr, start_addr,\t\\\n+\t they do not accept integer displacements.  We align the\t\\\n+\t start and end addresses to the beginning of their respective\t\\\n+\t cache lines to minimize the number of lines flushed.  */\t\\\n+      tmp = force_reg (Pmode, (TRAMP));\t\t\t\t\t\\\n+      emit_insn (gen_andsi3 (start_addr, tmp,\t\t\t\t\\\n+\t\t\t     GEN_INT (-MIN_CACHELINE_SIZE)));\t\t\\\n+      tmp = force_reg (Pmode,\t\t\t\t\t\t\\\n+\t\t       plus_constant (tmp, TRAMPOLINE_CODE_SIZE - 1));\t\\\n+      emit_insn (gen_andsi3 (end_addr, tmp,\t\t\t\t\\\n+\t\t\t     GEN_INT (-MIN_CACHELINE_SIZE)));\t\t\\\n+      emit_move_insn (line_length, GEN_INT (MIN_CACHELINE_SIZE));\t\\\n+      emit_insn (gen_dcacheflush (start_addr, end_addr, line_length));\t\\\n+      emit_insn (gen_icacheflush (start_addr, end_addr, line_length,\t\\\n+\t\t\t\t  gen_reg_rtx (Pmode),\t\t\t\\\n \t\t\t\t  gen_reg_rtx (Pmode),\t\t\t\\\n \t\t\t\t  gen_reg_rtx (Pmode)));\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      rtx start_addr, end_addr;\t\t\t\t\t\t\\\n+      tmp = memory_address (Pmode, plus_constant ((TRAMP), 56));\t\\\n+      emit_move_insn (gen_rtx_MEM (Pmode, tmp), (FNADDR));\t\t\\\n+      tmp = memory_address (Pmode, plus_constant ((TRAMP), 64));\t\\\n+      emit_move_insn (gen_rtx_MEM (Pmode, tmp), (CXT));\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      start_addr = memory_address (Pmode, plus_constant ((TRAMP), 56));\t\\\n-      emit_move_insn (gen_rtx_MEM (Pmode, start_addr), (FNADDR));\t\\\n-      start_addr = memory_address (Pmode, plus_constant ((TRAMP), 64));\t\\\n-      emit_move_insn (gen_rtx_MEM (Pmode, start_addr), (CXT));\t\t\\\n       /* Create a fat pointer for the trampoline.  */\t\t\t\\\n-      end_addr = force_reg (Pmode, plus_constant ((TRAMP), 32));\t\\\n-      start_addr = memory_address (Pmode, plus_constant ((TRAMP), 16));\t\\\n-      emit_move_insn (gen_rtx_MEM (Pmode, start_addr), end_addr);\t\\\n-      end_addr = gen_rtx_REG (Pmode, 27);\t\t\t\t\\\n-      start_addr = memory_address (Pmode, plus_constant ((TRAMP), 24));\t\\\n-      emit_move_insn (gen_rtx_MEM (Pmode, start_addr), end_addr);\t\\\n+      tmp = memory_address (Pmode, plus_constant ((TRAMP), 16));\t\\\n+      emit_move_insn (gen_rtx_MEM (Pmode, tmp),\t\t\t\t\\\n+\t\t      force_reg (Pmode, plus_constant ((TRAMP), 32)));\t\\\n+      tmp = memory_address (Pmode, plus_constant ((TRAMP), 24));\t\\\n+      emit_move_insn (gen_rtx_MEM (Pmode, tmp),\t\t\t\t\\\n+\t\t      gen_rtx_REG (Pmode, 27));\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n       /* fdc and fic only use registers for the address to flush,\t\\\n-\t they do not accept integer displacements.   PA 2.0 cache\t\\\n-\t lines are 64 bytes.  */\t\t \t\t\t\\\n-      start_addr = force_reg (Pmode, (TRAMP));\t\t\t\t\\\n-      end_addr = force_reg (Pmode, plus_constant ((TRAMP), 64));\t\\\n-      emit_insn (gen_dcacheflush (start_addr, end_addr));\t\t\\\n-      emit_insn (gen_icacheflush (start_addr, end_addr, start_addr,\t\\\n+\t they do not accept integer displacements.  We align the\t\\\n+\t start and end addresses to the beginning of their respective\t\\\n+\t cache lines to minimize the number of lines flushed.  */\t\\\n+      tmp = force_reg (Pmode, plus_constant ((TRAMP), 32));\t\t\\\n+      emit_insn (gen_anddi3 (start_addr, tmp,\t\t\t\t\\\n+\t\t\t     GEN_INT (-MIN_CACHELINE_SIZE)));\t\t\\\n+      tmp = force_reg (Pmode,\t\t\t\t\t\t\\\n+\t\t       plus_constant (tmp, TRAMPOLINE_CODE_SIZE - 1));\t\\\n+      emit_insn (gen_anddi3 (end_addr, tmp,\t\t\t\t\\\n+\t\t\t     GEN_INT (-MIN_CACHELINE_SIZE)));\t\t\\\n+      emit_move_insn (line_length, GEN_INT (MIN_CACHELINE_SIZE));\t\\\n+      emit_insn (gen_dcacheflush (start_addr, end_addr, line_length));\t\\\n+      emit_insn (gen_icacheflush (start_addr, end_addr, line_length,\t\\\n+\t\t\t\t  gen_reg_rtx (Pmode),\t\t\t\\\n \t\t\t\t  gen_reg_rtx (Pmode),\t\t\t\\\n \t\t\t\t  gen_reg_rtx (Pmode)));\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\"}, {"sha": "163567761883dfb29e2bdf9744e515622dcf6810", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 79, "deletions": 35, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3914c31fc6095844415cef8f73d8efd858765cb7/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3914c31fc6095844415cef8f73d8efd858765cb7/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=3914c31fc6095844415cef8f73d8efd858765cb7", "patch": "@@ -5322,15 +5322,25 @@\n \n (define_expand \"anddi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(and:DI (match_operand:DI 1 \"arith_double_operand\" \"\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"\")))]\n+\t(and:DI (match_operand:DI 1 \"and_operand\" \"\")\n+\t\t(match_operand:DI 2 \"and_operand\" \"\")))]\n   \"\"\n   \"\n {\n-  if (! register_operand (operands[1], DImode)\n-      || ! register_operand (operands[2], DImode))\n-    /* Let GCC break this into word-at-a-time operations.  */\n-    FAIL;\n+  if (TARGET_64BIT)\n+    {\n+      /* One operand must be a register operand.  */\n+      if (!register_operand (operands[1], DImode)\n+\t  && !register_operand (operands[2], DImode))\n+\tFAIL;\n+    }\n+  else\n+    {\n+      /* Both operands must be register operands.  */\n+      if (!register_operand (operands[1], DImode)\n+\t  || !register_operand (operands[2], DImode))\n+\tFAIL;\n+    }\n }\")\n \n (define_insn \"\"\n@@ -5391,15 +5401,25 @@\n \n (define_expand \"iordi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(ior:DI (match_operand:DI 1 \"arith_double_operand\" \"\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"\")))]\n+\t(ior:DI (match_operand:DI 1 \"ior_operand\" \"\")\n+\t\t(match_operand:DI 2 \"ior_operand\" \"\")))]\n   \"\"\n   \"\n {\n-  if (! register_operand (operands[1], DImode)\n-      || ! register_operand (operands[2], DImode))\n-    /* Let GCC break this into word-at-a-time operations.  */\n-    FAIL;\n+  if (TARGET_64BIT)\n+    {\n+      /* One operand must be a register operand.  */\n+      if (!register_operand (operands[1], DImode)\n+\t  && !register_operand (operands[2], DImode))\n+\tFAIL;\n+    }\n+  else\n+    {\n+      /* Both operands must be register operands.  */\n+      if (!register_operand (operands[1], DImode)\n+\t  || !register_operand (operands[2], DImode))\n+\tFAIL;\n+    }\n }\")\n \n (define_insn \"\"\n@@ -5462,15 +5482,11 @@\n \n (define_expand \"xordi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(xor:DI (match_operand:DI 1 \"arith_double_operand\" \"\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"\")))]\n+\t(xor:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"\")))]\n   \"\"\n   \"\n {\n-  if (! register_operand (operands[1], DImode)\n-      || ! register_operand (operands[2], DImode))\n-    /* Let GCC break this into word-at-a-time operations.  */\n-    FAIL;\n }\")\n \n (define_insn \"\"\n@@ -5532,12 +5548,10 @@\n \n (define_expand \"one_cmpldi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(not:DI (match_operand:DI 1 \"arith_double_operand\" \"\")))]\n+\t(not:DI (match_operand:DI 1 \"register_operand\" \"\")))]\n   \"\"\n   \"\n {\n-  if (! register_operand (operands[1], DImode))\n-    FAIL;\n }\")\n \n (define_insn \"\"\n@@ -8828,29 +8842,59 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   return \\\"\\\";\n }\")\n \n-;; Flush the I and D cache line found at the address in operand 0.\n+;; Flush the I and D cache lines from the start address (operand0)\n+;; to the end address (operand1).  No lines are flushed if the end\n+;; address is less than the start address (unsigned).\n+;;\n+;; Because the range of memory flushed is variable and the size of\n+;; a MEM can only be a CONST_INT, the patterns specify that they\n+;; perform an unspecified volatile operation on all memory.\n+;;\n+;; The address range for an icache flush must lie within a single\n+;; space on targets with non-equivalent space registers.\n+;;\n ;; This is used by the trampoline code for nested functions.\n-;; So long as the trampoline itself is less than 32 bytes this\n-;; is sufficient.\n-\n+;;\n+;; Operand 0 contains the start address.\n+;; Operand 1 contains the end address.\n+;; Operand 2 contains the line length to use.\n+;; Operand 3 contains the start address (clobbered).\n+;; Operands 4 and 5 (icacheflush) are clobbered scratch registers.\n (define_insn \"dcacheflush\"\n-  [(unspec_volatile [(const_int 1)] 0)\n-   (use (mem:SI (match_operand 0 \"pmode_register_operand\" \"r\")))\n-   (use (mem:SI (match_operand 1 \"pmode_register_operand\" \"r\")))]\n+  [(const_int 1)\n+   (unspec_volatile [(mem:BLK (scratch))] 0)\n+   (use (match_operand 0 \"pmode_register_operand\" \"r\"))\n+   (use (match_operand 1 \"pmode_register_operand\" \"r\"))\n+   (use (match_operand 2 \"pmode_register_operand\" \"r\"))\n+   (clobber (match_scratch 3 \"=&0\"))]\n   \"\"\n-  \"fdc 0(%0)\\;fdc 0(%1)\\;sync\"\n+  \"*\n+{\n+  if (TARGET_64BIT)\n+    return \\\"cmpb,*<<=,n %3,%1,.\\;fdc,m %2(%3)\\;sync\\\";\n+  else\n+    return \\\"cmpb,<<=,n %3,%1,.\\;fdc,m %2(%3)\\;sync\\\";\n+}\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"12\")])\n \n (define_insn \"icacheflush\"\n-  [(unspec_volatile [(const_int 2)] 0)\n-   (use (mem:SI (match_operand 0 \"pmode_register_operand\" \"r\")))\n-   (use (mem:SI (match_operand 1 \"pmode_register_operand\" \"r\")))\n+  [(const_int 2)\n+   (unspec_volatile [(mem:BLK (scratch))] 0)\n+   (use (match_operand 0 \"pmode_register_operand\" \"r\"))\n+   (use (match_operand 1 \"pmode_register_operand\" \"r\"))\n    (use (match_operand 2 \"pmode_register_operand\" \"r\"))\n-   (clobber (match_operand 3 \"pmode_register_operand\" \"=&r\"))\n-   (clobber (match_operand 4 \"pmode_register_operand\" \"=&r\"))]\n+   (clobber (match_scratch 3 \"=&0\"))\n+   (clobber (match_operand 4 \"pmode_register_operand\" \"=&r\"))\n+   (clobber (match_operand 5 \"pmode_register_operand\" \"=&r\"))]\n   \"\"\n-  \"mfsp %%sr0,%4\\;ldsid (%2),%3\\;mtsp %3,%%sr0\\;fic 0(%%sr0,%0)\\;fic 0(%%sr0,%1)\\;sync\\;mtsp %4,%%sr0\\;nop\\;nop\\;nop\\;nop\\;nop\\;nop\"\n+  \"*\n+{\n+  if (TARGET_64BIT)\n+    return \\\"mfsp %%sr0,%5\\;ldsid (%3),%4\\;mtsp %4,%%sr0\\;cmpb,*<<=,n %3,%1,.\\;fic,m %2(%%sr0,%3)\\;sync\\;mtsp %5,%%sr0\\;nop\\;nop\\;nop\\;nop\\;nop\\;nop\\\";\n+  else\n+    return \\\"mfsp %%sr0,%5\\;ldsid (%3),%4\\;mtsp %4,%%sr0\\;cmpb,<<=,n %3,%1,.\\;fic,m %2(%%sr0,%3)\\;sync\\;mtsp %5,%%sr0\\;nop\\;nop\\;nop\\;nop\\;nop\\;nop\\\";\n+}\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"52\")])\n "}]}