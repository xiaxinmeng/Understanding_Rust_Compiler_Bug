{"sha": "0e3184ac544fea00da542ed0a9644f0fdba00f10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUzMTg0YWM1NDRmZWEwMGRhNTQyZWQwYTk2NDRmMGZkYmEwMGYxMA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2011-05-03T21:44:27Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-05-03T21:44:27Z"}, "message": "re PR fortran/18918 (Eventually support Fortran 2008's coarrays [co-arrays])\n\n2011-05-03  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * trans-intrinsic.c (trans_this_image): Implement version with\n        coarray argument.\n\n2011-05-03  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * gfortran.dg/coarray/this_image_1.f90: New.\n\nFrom-SVN: r173342", "tree": {"sha": "28e3ddb5e386ef5562ce20a1b8f1cf36fac379e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28e3ddb5e386ef5562ce20a1b8f1cf36fac379e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e3184ac544fea00da542ed0a9644f0fdba00f10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e3184ac544fea00da542ed0a9644f0fdba00f10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e3184ac544fea00da542ed0a9644f0fdba00f10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e3184ac544fea00da542ed0a9644f0fdba00f10/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b0d1c284ed027110200748945495cef172f5a93d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0d1c284ed027110200748945495cef172f5a93d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0d1c284ed027110200748945495cef172f5a93d"}], "stats": {"total": 418, "additions": 406, "deletions": 12}, "files": [{"sha": "ba20715f020292556c092fa497c2c90f71370ff9", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3184ac544fea00da542ed0a9644f0fdba00f10/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3184ac544fea00da542ed0a9644f0fdba00f10/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0e3184ac544fea00da542ed0a9644f0fdba00f10", "patch": "@@ -1,3 +1,12 @@\n+2011-05-03  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* trans-intrinsic.c (trans_this_image): Implement version with\n+\tcoarray argument.\n+\t(conv_intrinsic_cobound): Simplify code.\n+\t(gfc_conv_intrinsic_function): Call trans_this_image for\n+\tthis_image(coarray) except for -fcoarray=single.\n+\n 2011-05-02  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/48720"}, {"sha": "10dadf7555aef76ceb0fa6dba1fc7c77b5ed59d1", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 195, "deletions": 12, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3184ac544fea00da542ed0a9644f0fdba00f10/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3184ac544fea00da542ed0a9644f0fdba00f10/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=0e3184ac544fea00da542ed0a9644f0fdba00f10", "patch": "@@ -923,10 +923,199 @@ gfc_conv_intrinsic_exponent (gfc_se *se, gfc_expr *expr)\n \n \n static void\n-trans_this_image (gfc_se * se, gfc_expr *expr ATTRIBUTE_UNUSED)\n+trans_this_image (gfc_se * se, gfc_expr *expr)\n {\n+  stmtblock_t loop;\n+  tree type, desc, dim_arg, cond, tmp, m, loop_var, exit_label, min_var,\n+       lbound, ubound, extent, ml;\n+  gfc_se argse;\n+  gfc_ss *ss;\n+  int rank, corank;\n+\n+  /* The case -fcoarray=single is handled elsewhere.  */\n+  gcc_assert (gfc_option.coarray != GFC_FCOARRAY_SINGLE);\n+\n   gfc_init_coarray_decl ();\n-  se->expr = gfort_gvar_caf_this_image;\n+\n+  /* Argument-free version: THIS_IMAGE().  */\n+  if (expr->value.function.actual->expr == NULL)\n+    {\n+      se->expr = gfort_gvar_caf_this_image;\n+      return;\n+    }\n+\n+  /* Coarray-argument version: THIS_IMAGE(coarray [, dim]).  */\n+\n+  type = gfc_get_int_type (gfc_default_integer_kind);\n+  corank = gfc_get_corank (expr->value.function.actual->expr);\n+  rank = expr->value.function.actual->expr->rank;\n+\n+  /* Obtain the descriptor of the COARRAY.  */\n+  gfc_init_se (&argse, NULL);\n+  ss = gfc_walk_expr (expr->value.function.actual->expr);\n+  gcc_assert (ss != gfc_ss_terminator);\n+  ss->data.info.codimen = corank;\n+  gfc_conv_expr_descriptor (&argse, expr->value.function.actual->expr, ss);\n+  gfc_add_block_to_block (&se->pre, &argse.pre);\n+  gfc_add_block_to_block (&se->post, &argse.post);\n+  desc = argse.expr;\n+\n+  if (se->ss)\n+    {\n+      /* Create an implicit second parameter from the loop variable.  */\n+      gcc_assert (!expr->value.function.actual->next->expr);\n+      gcc_assert (corank > 0);\n+      gcc_assert (se->loop->dimen == 1);\n+      gcc_assert (se->ss->expr == expr);\n+\n+      dim_arg = se->loop->loopvar[0];\n+      dim_arg = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type, dim_arg,\n+\t\t\t\t gfc_rank_cst[rank]);\n+      gfc_advance_se_ss_chain (se);\n+    }\n+  else\n+    {\n+      /* Use the passed DIM= argument.  */\n+      gcc_assert (expr->value.function.actual->next->expr);\n+      gfc_init_se (&argse, NULL);\n+      gfc_conv_expr_type (&argse, expr->value.function.actual->next->expr,\n+\t\t\t  gfc_array_index_type);\n+      gfc_add_block_to_block (&se->pre, &argse.pre);\n+      dim_arg = argse.expr;\n+\n+      if (INTEGER_CST_P (dim_arg))\n+\t{\n+\t  int hi, co_dim;\n+\n+\t  hi = TREE_INT_CST_HIGH (dim_arg);\n+\t  co_dim = TREE_INT_CST_LOW (dim_arg);\n+\t  if (hi || co_dim < 1\n+\t      || co_dim > GFC_TYPE_ARRAY_CORANK (TREE_TYPE (desc)))\n+\t    gfc_error (\"'dim' argument of %s intrinsic at %L is not a valid \"\n+\t\t       \"dimension index\", expr->value.function.isym->name,\n+\t\t       &expr->where);\n+\t}\n+     else if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n+\t{\n+\t  dim_arg = gfc_evaluate_now (dim_arg, &se->pre);\n+\t  cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t\t  dim_arg,\n+\t\t\t\t  build_int_cst (TREE_TYPE (dim_arg), 1));\n+\t  tmp = gfc_rank_cst[GFC_TYPE_ARRAY_CORANK (TREE_TYPE (desc))];\n+\t  tmp = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+\t\t\t\t dim_arg, tmp);\n+\t  cond = fold_build2_loc (input_location, TRUTH_ORIF_EXPR,\n+\t\t\t\t  boolean_type_node, cond, tmp);\n+\t  gfc_trans_runtime_check (true, false, cond, &se->pre, &expr->where,\n+\t\t\t           gfc_msg_fault);\n+\t}\n+    }\n+\n+  /* Used algorithm; cf. Fortran 2008, C.10. Note, due to the scalarizer,\n+     one always has a dim_arg argument.\n+\n+     m = this_images() - 1\n+     i = rank\n+     min_var = min (corank - 2, dim_arg)\n+     for (;;)\n+       {\n+\t extent = gfc_extent(i)\n+\t ml = m\n+\t m  = m/extent\n+\t if (i >= min_var) \n+\t   goto exit_label\n+\t i++\n+       }\n+     exit_label:\n+     sub(dim_arg) = (dim_arg < corank) ? ml - m*extent + lcobound(dim_arg)\n+\t\t\t\t       : m + lcobound(corank)\n+  */\n+\n+  m = gfc_create_var (type, NULL); \n+  ml = gfc_create_var (type, NULL); \n+  loop_var = gfc_create_var (integer_type_node, NULL); \n+  min_var = gfc_create_var (integer_type_node, NULL); \n+\n+  /* m = this_image () - 1.  */\n+  tmp = fold_convert (type, gfort_gvar_caf_this_image);\n+  tmp = fold_build2_loc (input_location, MINUS_EXPR, type, tmp,\n+\t\t       build_int_cst (type, 1));\n+  gfc_add_modify (&se->pre, m, tmp);\n+\n+  /* min_var = min (rank+corank-2, dim_arg).  */\n+  tmp = fold_build2_loc (input_location, MIN_EXPR, integer_type_node,\n+\t\t\t build_int_cst (integer_type_node, rank + corank - 2),\n+\t\t\t fold_convert (integer_type_node, dim_arg));\n+  gfc_add_modify (&se->pre, min_var, tmp);\n+\n+  /* i = rank.  */\n+  tmp = build_int_cst (integer_type_node, rank);\n+  gfc_add_modify (&se->pre, loop_var, tmp);\n+\n+  exit_label = gfc_build_label_decl (NULL_TREE);\n+  TREE_USED (exit_label) = 1;\n+\n+  /* Loop body.  */\n+  gfc_init_block (&loop);\n+\n+  /* ml = m.  */\n+  gfc_add_modify (&loop, ml, m);\n+\n+  /* extent = ...  */\n+  lbound = gfc_conv_descriptor_lbound_get (desc, loop_var);\n+  ubound = gfc_conv_descriptor_ubound_get (desc, loop_var);\n+  extent = gfc_conv_array_extent_dim (lbound, ubound, NULL);\n+  extent = fold_convert (type, extent);\n+\n+  /* m = m/extent.  */\n+  gfc_add_modify (&loop, m, \n+\t\t  fold_build2_loc (input_location, TRUNC_DIV_EXPR, type,\n+\t\t\t  m, extent));\n+\n+  /* Exit condition:  if (i >= min_var) goto exit_label.  */\n+  cond = fold_build2_loc (input_location, GE_EXPR, boolean_type_node, loop_var,\n+\t\t  min_var);\n+  tmp = build1_v (GOTO_EXPR, exit_label);\n+  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond, tmp,\n+                         build_empty_stmt (input_location));\n+  gfc_add_expr_to_block (&loop, tmp);\n+\n+  /* Increment loop variable: i++.  */\n+  gfc_add_modify (&loop, loop_var,\n+                  fold_build2_loc (input_location, PLUS_EXPR, integer_type_node,\n+\t\t\t\t   loop_var,\n+\t\t\t\t   build_int_cst (integer_type_node, 1)));\n+\n+  /* Making the loop... actually loop!  */\n+  tmp = gfc_finish_block (&loop);\n+  tmp = build1_v (LOOP_EXPR, tmp);\n+  gfc_add_expr_to_block (&se->pre, tmp);\n+\n+  /* The exit label.  */\n+  tmp = build1_v (LABEL_EXPR, exit_label);\n+  gfc_add_expr_to_block (&se->pre, tmp);\n+\n+  /*  sub(co_dim) = (co_dim < corank) ? ml - m*extent + lcobound(dim_arg)\n+\t\t\t\t      : m + lcobound(corank) */\n+\n+  cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node, dim_arg,\n+\t\t\t  build_int_cst (TREE_TYPE (dim_arg), corank));\n+\n+  lbound = gfc_conv_descriptor_lbound_get (desc,\n+\t\t\tfold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t\t gfc_array_index_type, dim_arg,\n+\t\t\t\t\t gfc_rank_cst[rank - 1]));\n+  lbound = fold_convert (type, lbound);\n+\n+  tmp = fold_build2_loc (input_location, MINUS_EXPR, type, ml,\n+\t\t\t fold_build2_loc (input_location, MULT_EXPR, type,\n+\t\t\t\t\t  m, extent));\n+  tmp = fold_build2_loc (input_location, PLUS_EXPR, type, tmp, lbound);\n+\n+  se->expr = fold_build3_loc (input_location, COND_EXPR, type, cond, tmp,\n+\t\t\t      fold_build2_loc (input_location, PLUS_EXPR, type,\n+\t\t\t\t\t       m, lbound));\n }\n \n \n@@ -1281,23 +1470,15 @@ conv_intrinsic_cobound (gfc_se * se, gfc_expr * expr)\n \n   if (se->ss)\n     {\n-      mpz_t mpz_rank;\n-      tree tree_rank;\n-\n       /* Create an implicit second parameter from the loop variable.  */\n       gcc_assert (!arg2->expr);\n       gcc_assert (corank > 0);\n       gcc_assert (se->loop->dimen == 1);\n       gcc_assert (se->ss->expr == expr);\n \n-      mpz_init_set_ui (mpz_rank, arg->expr->rank);\n-      tree_rank = gfc_conv_mpz_to_tree (mpz_rank, gfc_index_integer_kind);\n-\n       bound = se->loop->loopvar[0];\n       bound = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n-\t\t\t       bound, se->ss->data.info.delta[0]);\n-      bound = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n-\t\t\t       bound, tree_rank);\n+\t\t\t       bound, gfc_rank_cst[arg->expr->rank]);\n       gfc_advance_se_ss_chain (se);\n     }\n   else\n@@ -6434,7 +6615,9 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       break;\n \n     case GFC_ISYM_THIS_IMAGE:\n-      if (expr->value.function.actual->expr)\n+      /* For num_images() == 1, handle as LCOBOUND.  */\n+      if (expr->value.function.actual->expr\n+\t  && gfc_option.coarray == GFC_FCOARRAY_SINGLE)\n \tconv_intrinsic_cobound (se, expr);\n       else\n \ttrans_this_image (se, expr);"}, {"sha": "29908e671a0b36dd2983accb63e180545d22fb94", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3184ac544fea00da542ed0a9644f0fdba00f10/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3184ac544fea00da542ed0a9644f0fdba00f10/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0e3184ac544fea00da542ed0a9644f0fdba00f10", "patch": "@@ -1,3 +1,8 @@\n+2011-05-03  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* gfortran.dg/coarray/this_image_1.f90: New.\n+\n 2011-05-03  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/18918"}, {"sha": "64d222b76de11b4e22000bd6405b4b09b1563c2c", "filename": "gcc/testsuite/gfortran.dg/coarray/this_image_1.f90", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3184ac544fea00da542ed0a9644f0fdba00f10/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fthis_image_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3184ac544fea00da542ed0a9644f0fdba00f10/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fthis_image_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fthis_image_1.f90?ref=0e3184ac544fea00da542ed0a9644f0fdba00f10", "patch": "@@ -0,0 +1,197 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=lib -lcaf_single\" }\n+!\n+! PR fortran/18918\n+!\n+! this_image(coarray) run test,\n+! expecially for num_images > 1\n+!\n+! Tested are values up to num_images == 8,\n+! higher values are OK, but not tested for\n+!\n+implicit none\n+integer :: a(1)[2:2, 3:4, 7:*]\n+integer :: b(:)[:, :,:]\n+allocatable :: b\n+integer :: i\n+\n+if (this_image(A, dim=1) /= 2) call abort()\n+i = 1\n+if (this_image(A, dim=i) /= 2) call abort()\n+\n+select case (this_image())\n+  case (1)\n+    if (this_image(A, dim=2) /= 3) call abort()\n+    if (this_image(A, dim=3) /= 7) call abort()\n+    i = 2\n+    if (this_image(A, dim=i) /= 3) call abort()\n+    i = 3\n+    if (this_image(A, dim=i) /= 7) call abort()\n+    if (any (this_image(A) /= [2,3,7])) call abort()\n+\n+  case (2)\n+    if (this_image(A, dim=2) /= 4) call abort()\n+    if (this_image(A, dim=3) /= 7) call abort()\n+    i = 2\n+    if (this_image(A, dim=i) /= 4) call abort()\n+    i = 3\n+    if (this_image(A, dim=i) /= 7) call abort()\n+    if (any (this_image(A) /= [2,4,7])) call abort()\n+\n+  case (3)\n+    if (this_image(A, dim=2) /= 3) call abort()\n+    if (this_image(A, dim=3) /= 8) call abort()\n+    i = 2\n+    if (this_image(A, dim=i) /= 3) call abort()\n+    i = 3\n+    if (this_image(A, dim=i) /= 8) call abort()\n+    if (any (this_image(A) /= [2,3,8])) call abort()\n+\n+  case (4)\n+    if (this_image(A, dim=2) /= 4) call abort()\n+    if (this_image(A, dim=3) /= 8) call abort()\n+    i = 2\n+    if (this_image(A, dim=i) /= 4) call abort()\n+    i = 3\n+    if (this_image(A, dim=i) /= 8) call abort()\n+    if (any (this_image(A) /= [2,4,8])) call abort()\n+\n+  case (5)\n+    if (this_image(A, dim=2) /= 3) call abort()\n+    if (this_image(A, dim=3) /= 9) call abort()\n+    i = 2\n+    if (this_image(A, dim=i) /= 3) call abort()\n+    i = 3\n+    if (this_image(A, dim=i) /= 9) call abort()\n+    if (any (this_image(A) /= [2,3,9])) call abort()\n+\n+  case (6)\n+    if (this_image(A, dim=2) /= 4) call abort()\n+    if (this_image(A, dim=3) /= 9) call abort()\n+    i = 2\n+    if (this_image(A, dim=i) /= 4) call abort()\n+    i = 3\n+    if (this_image(A, dim=i) /= 9) call abort()\n+    if (any (this_image(A) /= [2,4,9])) call abort()\n+\n+  case (7)\n+    if (this_image(A, dim=2) /= 3) call abort()\n+    if (this_image(A, dim=3) /= 10) call abort()\n+    i = 2\n+    if (this_image(A, dim=i) /= 3) call abort()\n+    i = 3\n+    if (this_image(A, dim=i) /= 10) call abort()\n+    if (any (this_image(A) /= [2,3,10])) call abort()\n+\n+  case (8)\n+    if (this_image(A, dim=2) /= 4) call abort()\n+    if (this_image(A, dim=3) /= 10) call abort()\n+    i = 2\n+    if (this_image(A, dim=i) /= 4) call abort()\n+    i = 3\n+    if (this_image(A, dim=i) /= 10) call abort()\n+    if (any (this_image(A) /= [2,4,10])) call abort()\n+end select\n+\n+\n+allocate (b(3)[-1:0,2:4,*])\n+\n+select case (this_image())\n+  case (1)\n+    if (this_image(B, dim=1) /= -1) call abort()\n+    if (this_image(B, dim=2) /= 2) call abort()\n+    if (this_image(B, dim=3) /= 1) call abort()\n+    i = 1\n+    if (this_image(B, dim=i) /= -1) call abort()\n+    i = 2\n+    if (this_image(B, dim=i) /= 2) call abort()\n+    i = 3\n+    if (this_image(B, dim=i) /= 1) call abort()\n+    if (any (this_image(B) /= [-1,2,1])) call abort()\n+\n+  case (2)\n+    if (this_image(B, dim=1) /= 0) call abort()\n+    if (this_image(B, dim=2) /= 2) call abort()\n+    if (this_image(B, dim=3) /= 1) call abort()\n+    i = 1\n+    if (this_image(B, dim=i) /= 0) call abort()\n+    i = 2\n+    if (this_image(B, dim=i) /= 2) call abort()\n+    i = 3\n+    if (this_image(B, dim=i) /= 1) call abort()\n+    if (any (this_image(B) /= [0,2,1])) call abort()\n+\n+  case (3)\n+    if (this_image(B, dim=1) /= -1) call abort()\n+    if (this_image(B, dim=2) /= 3) call abort()\n+    if (this_image(B, dim=3) /= 1) call abort()\n+    i = 1\n+    if (this_image(B, dim=i) /= -1) call abort()\n+    i = 2\n+    if (this_image(B, dim=i) /= 3) call abort()\n+    i = 3\n+    if (this_image(B, dim=i) /= 1) call abort()\n+    if (any (this_image(B) /= [-1,3,1])) call abort()\n+\n+  case (4)\n+    if (this_image(B, dim=1) /= 0) call abort()\n+    if (this_image(B, dim=2) /= 3) call abort()\n+    if (this_image(B, dim=3) /= 1) call abort()\n+    i = 1\n+    if (this_image(B, dim=i) /= 0) call abort()\n+    i = 2\n+    if (this_image(B, dim=i) /= 3) call abort()\n+    i = 3\n+    if (this_image(B, dim=i) /= 1) call abort()\n+    if (any (this_image(B) /= [0,3,1])) call abort()\n+\n+  case (5)\n+    if (this_image(B, dim=1) /= -1) call abort()\n+    if (this_image(B, dim=2) /= 4) call abort()\n+    if (this_image(B, dim=3) /= 1) call abort()\n+    i = 1\n+    if (this_image(B, dim=i) /= -1) call abort()\n+    i = 2\n+    if (this_image(B, dim=i) /= 4) call abort()\n+    i = 3\n+    if (this_image(B, dim=i) /= 1) call abort()\n+    if (any (this_image(B) /= [-1,4,1])) call abort()\n+\n+  case (6)\n+    if (this_image(B, dim=1) /= 0) call abort()\n+    if (this_image(B, dim=2) /= 4) call abort()\n+    if (this_image(B, dim=3) /= 1) call abort()\n+    i = 1\n+    if (this_image(B, dim=i) /= 0) call abort()\n+    i = 2\n+    if (this_image(B, dim=i) /= 4) call abort()\n+    i = 3\n+    if (this_image(B, dim=i) /= 1) call abort()\n+    if (any (this_image(B) /= [0,4,1])) call abort()\n+\n+  case (7)\n+    if (this_image(B, dim=1) /= -1) call abort()\n+    if (this_image(B, dim=2) /= 2) call abort()\n+    if (this_image(B, dim=3) /= 2) call abort()\n+    i = 1\n+    if (this_image(B, dim=i) /= -1) call abort()\n+    i = 2\n+    if (this_image(B, dim=i) /= 2) call abort()\n+    i = 3\n+    if (this_image(B, dim=i) /= 2) call abort()\n+    if (any (this_image(B) /= [-1,2,2])) call abort()\n+\n+  case (8)\n+    if (this_image(B, dim=1) /= 0) call abort()\n+    if (this_image(B, dim=2) /= 2) call abort()\n+    if (this_image(B, dim=3) /= 2) call abort()\n+    i = 1\n+    if (this_image(B, dim=i) /= 0) call abort()\n+    i = 2\n+    if (this_image(B, dim=i) /= 2) call abort()\n+    i = 3\n+    if (this_image(B, dim=i) /= 2) call abort()\n+    if (any (this_image(B) /= [0,2,2])) call abort()\n+end select\n+\n+end"}]}