{"sha": "97458258b8e196f88ba17d4ed985aece3ec5675c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc0NTgyNThiOGUxOTZmODhiYTE3ZDRlZDk4NWFlY2UzZWM1Njc1Yw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-02-04T08:35:11Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-02-04T08:35:11Z"}, "message": "cp-tree.h (CLASSTYPE_INTERFACE_UNKNOWN): Fix formatting.\n\n\t* cp-tree.h (CLASSTYPE_INTERFACE_UNKNOWN): Fix formatting.\n\tDocument.\n\t(CLASSTYPE_INTERFACE_KNOWN): Likewise.\n\t(SET_CLASSTYPE_INTERFACE_UNKNOWN_X): Likewise.\n\t(SET_CLASSTYPE_INTERFACE_UNKNOWN): Likewise.\n\t(SET_CLASSTYPE_INTERFACE_KNOWN): Likewise.\n\t* decl.c (maybe_commonize_var): Use the new name-mangling where\n\tappropriate.\n\t* decl2.c (comdat_linkage): Enhance comments.  Make all\n\tcompiler-generated things static, if COMDAT is not available.\n\t(get_tinfo_decl): Do not make typeinfo objects that belong in the\n\tlibrary COMDAT.\n\t(tinfo_base_init): Use the correct mangled name for typeinfo\n\tstrings, and push them into the global scope.\n\t(typeinfo_in_lib_p): New function.\n\t(synthesize_tinfo_var): Use it.\n\t(create_real_tinfo_var): Likewise.\n\nFrom-SVN: r39437", "tree": {"sha": "1c27fa8594fbc42a3c7557f4dbff567d0733267c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c27fa8594fbc42a3c7557f4dbff567d0733267c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97458258b8e196f88ba17d4ed985aece3ec5675c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97458258b8e196f88ba17d4ed985aece3ec5675c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97458258b8e196f88ba17d4ed985aece3ec5675c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97458258b8e196f88ba17d4ed985aece3ec5675c/comments", "author": null, "committer": null, "parents": [{"sha": "1ca894a0e403de4be67483069f8b59059ad53a31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ca894a0e403de4be67483069f8b59059ad53a31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ca894a0e403de4be67483069f8b59059ad53a31"}], "stats": {"total": 152, "additions": 112, "deletions": 40}, "files": [{"sha": "66746f08df172af5d1359a8fb991a08582e8d52d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97458258b8e196f88ba17d4ed985aece3ec5675c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97458258b8e196f88ba17d4ed985aece3ec5675c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=97458258b8e196f88ba17d4ed985aece3ec5675c", "patch": "@@ -1,3 +1,23 @@\n+2001-02-04  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (CLASSTYPE_INTERFACE_UNKNOWN): Fix formatting.\n+\tDocument.\n+\t(CLASSTYPE_INTERFACE_KNOWN): Likewise.\n+\t(SET_CLASSTYPE_INTERFACE_UNKNOWN_X): Likewise.\n+\t(SET_CLASSTYPE_INTERFACE_UNKNOWN): Likewise.\n+\t(SET_CLASSTYPE_INTERFACE_KNOWN): Likewise.\n+\t* decl.c (maybe_commonize_var): Use the new name-mangling where\n+\tappropriate.\n+\t* decl2.c (comdat_linkage): Enhance comments.  Make all\n+\tcompiler-generated things static, if COMDAT is not available.\n+\t(get_tinfo_decl): Do not make typeinfo objects that belong in the\n+\tlibrary COMDAT.\n+\t(tinfo_base_init): Use the correct mangled name for typeinfo\n+\tstrings, and push them into the global scope.\n+\t(typeinfo_in_lib_p): New function.\n+\t(synthesize_tinfo_var): Use it.\n+\t(create_real_tinfo_var): Likewise.\n+\t\n 2001-02-03  Jakub Jelinek  <jakub@redhat.com>\n \n \t* decl.c (push_class_binding): Use context_for_name_lookup instead"}, {"sha": "9077671bb60a596c693198307b5dc2aa482079a4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97458258b8e196f88ba17d4ed985aece3ec5675c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97458258b8e196f88ba17d4ed985aece3ec5675c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=97458258b8e196f88ba17d4ed985aece3ec5675c", "patch": "@@ -1615,12 +1615,23 @@ struct lang_type\n    `#pragma interface', and it is not included in its implementation file.  */\n #define CLASSTYPE_INTERFACE_ONLY(NODE) (TYPE_LANG_SPECIFIC(NODE)->interface_only)\n \n-/* Same as above, but for classes whose purpose we do not know.  */\n-#define CLASSTYPE_INTERFACE_UNKNOWN(NODE) (TYPE_LANG_SPECIFIC(NODE)->interface_unknown)\n-#define CLASSTYPE_INTERFACE_KNOWN(NODE) (TYPE_LANG_SPECIFIC(NODE)->interface_unknown == 0)\n-#define SET_CLASSTYPE_INTERFACE_UNKNOWN_X(NODE,X) (TYPE_LANG_SPECIFIC(NODE)->interface_unknown = !!(X))\n-#define SET_CLASSTYPE_INTERFACE_UNKNOWN(NODE) (TYPE_LANG_SPECIFIC(NODE)->interface_unknown = 1)\n-#define SET_CLASSTYPE_INTERFACE_KNOWN(NODE) (TYPE_LANG_SPECIFIC(NODE)->interface_unknown = 0)\n+/* True if we have already determined whether or not vtables, VTTs,\n+   typeinfo, and other similar per-class data should be emitted in\n+   this translation unit.  This flag does not indicate whether or not\n+   these items should be emitted; it only indicates that we know one\n+   way or the other.  */\n+#define CLASSTYPE_INTERFACE_KNOWN(NODE) \\\n+  (TYPE_LANG_SPECIFIC(NODE)->interface_unknown == 0)\n+/* The opposite of CLASSTYPE_INTERFANCE_KNOWN.  */\n+#define CLASSTYPE_INTERFACE_UNKNOWN(NODE) \\\n+  (TYPE_LANG_SPECIFIC(NODE)->interface_unknown)\n+\n+#define SET_CLASSTYPE_INTERFACE_UNKNOWN_X(NODE,X) \\\n+  (TYPE_LANG_SPECIFIC(NODE)->interface_unknown = !!(X))\n+#define SET_CLASSTYPE_INTERFACE_UNKNOWN(NODE) \\\n+  (TYPE_LANG_SPECIFIC(NODE)->interface_unknown = 1)\n+#define SET_CLASSTYPE_INTERFACE_KNOWN(NODE) \\\n+  (TYPE_LANG_SPECIFIC(NODE)->interface_unknown = 0)\n \n /* Nonzero if a _DECL node requires us to output debug info for this class.  */\n #define CLASSTYPE_DEBUG_REQUESTED(NODE) (TYPE_LANG_SPECIFIC(NODE)->debug_requested)"}, {"sha": "a250e67c68c396964ca468b3aa60adf0a147f236", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97458258b8e196f88ba17d4ed985aece3ec5675c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97458258b8e196f88ba17d4ed985aece3ec5675c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=97458258b8e196f88ba17d4ed985aece3ec5675c", "patch": "@@ -7517,8 +7517,13 @@ maybe_commonize_var (decl)\n \t     which we can't if it has been initialized.  */\n \n \t  if (TREE_PUBLIC (decl))\n-\t    DECL_ASSEMBLER_NAME (decl)\n-\t      = build_static_name (current_function_decl, DECL_NAME (decl));\n+\t    {\n+\t      if (flag_new_abi)\n+\t\tDECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n+\t      else\n+\t\tDECL_ASSEMBLER_NAME (decl)\n+\t\t  = build_static_name (current_function_decl, DECL_NAME (decl));\n+\t    }\n \t  else\n \t    {\n \t      cp_warning_at (\"sorry: semantics of inline function static data `%#D' are wrong (you'll wind up with multiple copies)\", decl);"}, {"sha": "2c3dbc78daf6af9984585b0549a787f0b7635d6f", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97458258b8e196f88ba17d4ed985aece3ec5675c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97458258b8e196f88ba17d4ed985aece3ec5675c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=97458258b8e196f88ba17d4ed985aece3ec5675c", "patch": "@@ -2396,14 +2396,24 @@ comdat_linkage (decl)\n {\n   if (flag_weak)\n     make_decl_one_only (decl);\n-  else if (TREE_CODE (decl) == FUNCTION_DECL || DECL_VIRTUAL_P (decl))\n-    /* We can just emit functions and vtables statically; having\n-       multiple copies is (for the most part) only a waste of space.\n-       There is at least one correctness issue, however: the address\n-       of a template instantiation with external linkage should be the\n+  else if (TREE_CODE (decl) == FUNCTION_DECL \n+\t   || (TREE_CODE (decl) == VAR_DECL && DECL_ARTIFICIAL (decl)))\n+    /* We can just emit function and compiler-generated variables\n+       statically; having multiple copies is (for the most part) only\n+       a waste of space.  \n+\n+       There are two correctness issues, however: the address of a\n+       template instantiation with external linkage should be the\n        same, independent of what translation unit asks for the\n        address, and this will not hold when we emit multiple copies of\n-       the function.  However, there's little else we can do.  */\n+       the function.  However, there's little else we can do.  \n+\n+       Also, by default, the typeinfo implementation for the new ABI\n+       assumes that there will be only one copy of the string used as\n+       the name for each type.  Therefore, if weak symbols are\n+       unavailable, the run-time library should perform a more\n+       conservative check; it should perform a string comparison,\n+       rather than an address comparison.  */\n     TREE_PUBLIC (decl) = 0;\n   else\n     {"}, {"sha": "8be6f7e1087553be5cf4bbb882ddfccb71e2d537", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 52, "deletions": 26, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97458258b8e196f88ba17d4ed985aece3ec5675c/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97458258b8e196f88ba17d4ed985aece3ec5675c/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=97458258b8e196f88ba17d4ed985aece3ec5675c", "patch": "@@ -68,10 +68,11 @@ static tree dfs_class_hint_unmark PARAMS ((tree, void *));\n static int class_hint_flags PARAMS((tree));\n static tree class_initializer PARAMS((tree, tree, tree));\n static tree synthesize_tinfo_var PARAMS((tree, tree));\n-static tree create_real_tinfo_var PARAMS((tree, tree, tree, int));\n+static tree create_real_tinfo_var PARAMS((tree, tree, tree, tree, int));\n static tree create_pseudo_type_info PARAMS((const char *, int, ...));\n static tree get_vmi_pseudo_type_info PARAMS((int));\n static void create_tinfo_types PARAMS((void));\n+static int typeinfo_in_lib_p PARAMS((tree));\n \n static int doing_runtime = 0;\n \f\n@@ -394,7 +395,7 @@ tinfo_name (type)\n    returned decl, to save the decl.  To use the decl call\n    tinfo_from_decl.  You must arrange that the decl is mark_used, if\n    actually use it --- decls in vtables are only used if the vtable is\n-   output.  */\n+   output.  */ \n \n tree\n get_tinfo_decl (type)\n@@ -443,7 +444,8 @@ get_tinfo_decl (type)\n       TREE_STATIC (d) = 1;\n       DECL_EXTERNAL (d) = 1;\n       TREE_PUBLIC (d) = 1;\n-      comdat_linkage (d);\n+      if (flag_weak || !typeinfo_in_lib_p (d))\n+\tcomdat_linkage (d);\n       DECL_ASSEMBLER_NAME (d) = DECL_NAME (d);\n       cp_finish_decl (d, NULL_TREE, NULL_TREE, 0);\n \n@@ -1327,7 +1329,7 @@ tinfo_base_init (desc, target)\n     tree name_string = tinfo_name (target);\n \n     if (flag_new_abi)\n-      name_name = mangle_typeinfo_for_type (target);\n+      name_name = mangle_typeinfo_string_for_type (target);\n     else\n       name_name = build_overload_with_type (tinfo_var_id, target);\n     name_decl = build_lang_decl (VAR_DECL, name_name, name_type);\n@@ -1347,6 +1349,7 @@ tinfo_base_init (desc, target)\n       DECL_ASSEMBLER_NAME (name_decl) = DECL_NAME (name_decl);\n     DECL_INITIAL (name_decl) = name_string;\n     cp_finish_decl (name_decl, name_string, NULL_TREE, 0);\n+    pushdecl_top_level (name_decl);\n   }\n   \n   if (TINFO_VTABLE_DECL (desc))\n@@ -1538,6 +1541,34 @@ class_initializer (desc, target, trail)\n   return init;  \n }\n \n+/* Returns non-zero if the typeinfo for type should be placed in \n+   the runtime library.  */\n+\n+static int\n+typeinfo_in_lib_p (type)\n+     tree type;\n+{\n+  /* The typeinfo objects for `T*' and `const T*' are in the runtime\n+     library for simple types T.  */\n+  if (TREE_CODE (type) == POINTER_TYPE\n+      && (CP_TYPE_QUALS (TREE_TYPE (type)) == TYPE_QUAL_CONST\n+\t  || CP_TYPE_QUALS (TREE_TYPE (type)) == TYPE_UNQUALIFIED))\n+    type = TREE_TYPE (type);\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case INTEGER_TYPE:\n+    case BOOLEAN_TYPE:\n+    case CHAR_TYPE:\n+    case REAL_TYPE:\n+    case VOID_TYPE:\n+      return 1;\n+    \n+    default:\n+      return 0;\n+    }\n+}\n+\n /* Generate a pseudo_type_info VAR_DECL suitable for the supplied\n    TARGET_TYPE and given the REAL_NAME. This is the structure expected by\n    the runtime, and therefore has additional fields.  If we need not emit a\n@@ -1565,14 +1596,7 @@ synthesize_tinfo_var (target_type, real_name)\n         }\n       else\n         {\n-          int code = TREE_CODE (TREE_TYPE (target_type));\n-          \n-          if ((CP_TYPE_QUALS (TREE_TYPE (target_type)) | TYPE_QUAL_CONST)\n-              == TYPE_QUAL_CONST\n-              && (code == INTEGER_TYPE || code == BOOLEAN_TYPE\n-                  || code == CHAR_TYPE || code == REAL_TYPE\n-                  || code == VOID_TYPE)\n-              && !doing_runtime)\n+          if (typeinfo_in_lib_p (target_type) && !doing_runtime)\n             /* These are in the runtime.  */\n             return NULL_TREE;\n           var_type = ptr_desc_type_node;\n@@ -1675,31 +1699,32 @@ synthesize_tinfo_var (target_type, real_name)\n           var_init = class_initializer (var_type, target_type, base_inits);\n         }\n       break;\n-    case INTEGER_TYPE:\n-    case BOOLEAN_TYPE:\n-    case CHAR_TYPE:\n-    case REAL_TYPE:\n-    case VOID_TYPE:\n-      if (!doing_runtime)\n-        /* These are guaranteed to be in the runtime.  */\n-        return NULL_TREE;\n-      var_type = bltn_desc_type_node;\n-      var_init = generic_initializer (var_type, target_type);\n-      break;\n+\n     default:\n+      if (typeinfo_in_lib_p (target_type))\n+\t{\n+\t  if (!doing_runtime)\n+\t    /* These are guaranteed to be in the runtime.  */\n+\t    return NULL_TREE;\n+\t  var_type = bltn_desc_type_node;\n+\t  var_init = generic_initializer (var_type, target_type);\n+\t  break;\n+\t}\n       my_friendly_abort (20000117);\n     }\n   \n   \n-  return create_real_tinfo_var (real_name, TINFO_PSEUDO_TYPE (var_type),\n+  return create_real_tinfo_var (target_type,\n+\t\t\t\treal_name, TINFO_PSEUDO_TYPE (var_type),\n                                 var_init, non_public);\n }\n \n /* Create the real typeinfo variable.  NON_PUBLIC indicates that we cannot\n    make this variable public (comdat). */\n \n static tree\n-create_real_tinfo_var (name, type, init, non_public)\n+create_real_tinfo_var (target_type, name, type, init, non_public)\n+     tree target_type;\n      tree name;\n      tree type;\n      tree init;\n@@ -1725,7 +1750,8 @@ create_real_tinfo_var (name, type, init, non_public)\n   if (!non_public)\n     {\n       TREE_PUBLIC (decl) = 1;\n-      comdat_linkage (decl);\n+      if (flag_weak || !typeinfo_in_lib_p (target_type))\n+\tcomdat_linkage (decl);\n     }\n   DECL_ASSEMBLER_NAME (decl) = name;\n   DECL_INITIAL (decl) = init;"}]}