{"sha": "8a76829ccfe1b5cb484f79a8b7ba02299f228782", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE3NjgyOWNjZmUxYjVjYjQ4NGY3OWE4YjdiYTAyMjk5ZjIyODc4Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-07-28T21:48:38Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-07-28T21:48:38Z"}, "message": "Makefile.in (rtl-profile.o): Kill all traces of it.\n\n\n\t* Makefile.in (rtl-profile.o): Kill all traces of it.\n\t* common.opt (fspeculative-prefetching, ftree-based-profiling): Kill.\n\t* coverage.h (rtl_coverage_counter_ref): Kill.\n\t* opts.c (flag_speculative_prefetching_set): Kill.\n\t(flag_loop_optimize_set): New.\n\t(common_handle_option): Disable loop optimizer when profiling;\n\tdo not handle speculative prefetching.\n\t* passes.c (init_optimization_passes): Replace pass_profiling combo\n\tby branch_prob pass.\n\t* profile.c (compute_value_histograms): Update for simplified value\n\tprofiles.\n\t(rtl_register_profile_hooks): Kill.\n\t(pass_profiling): Kill.\n\t(rest_of_handle_branch_prob): Do not profile.\n\t* toplev.c (process_options): Remove speculative prefetching.\n\t* toplev.h (flag_tree_based_profiling): Kill.\n\t* tree-profile.c (prepare_instrumented_value,\n\ttree_gen_interval_profiler, tree_gen_pow2_profiler,\n\ttree_gen_one_value_profiler, do_tree_profiling): Update for\n\tsimplified datastructures.\n\t* value-prof.c: Add comment that speculative prefetching was dropped;\n\tupdate rest of file for simplified datastructures.\n\t(NOPREFETCH_RANGE_MIN, NOPREFETCH_RANGE_MAX,\n\trtl_divmod_values_to_profile, insn_prefetch_values_to_profile,\n\tfind_mem_reference_1, find_mem_reference_2, find_mem_reference,\n\trtl_values_to_profile, rtl_divmod_fixed_value, rtl_mod_pow2,\n\trtl_mod_subtract, gen_speculative_prefetch,\n\trtl_divmod_fixed_value_transform, rtl_mod_pow2_value_transform,\n\trtl_mod_subtract_transform, speculative_prefetching_transform): Kill.\n\t(gate_handle_value_profile_transformations,\n\trest_of_handle_value_profile_transformations,\n\tpass_value_profile_transformations): Kill.\n\t* value-prof.h (histogram_value_t): Remove IL based unions.\n\t(rtl_register_value_prof_hooks, rtl_register_profile_hooks,\n\trtl_profile_hooks): Remove hooks.\n\n\t* invoke.texi (-ftree-based-profiling, -fspeculative-prefetching): Kill.\n\n\t* inliner-1.c: Do not dump everything.\n\t* tree-prof.exp: Do not pass -ftree-based-profiling.\n\t* bprob.exp: Likewise.\n\nFrom-SVN: r102522", "tree": {"sha": "377bb80f4913f0795be700e07ba6b59ac515ec9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/377bb80f4913f0795be700e07ba6b59ac515ec9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a76829ccfe1b5cb484f79a8b7ba02299f228782", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a76829ccfe1b5cb484f79a8b7ba02299f228782", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a76829ccfe1b5cb484f79a8b7ba02299f228782", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a76829ccfe1b5cb484f79a8b7ba02299f228782/comments", "author": null, "committer": null, "parents": [{"sha": "c5a4444c50a61d6f787d4d238ed007ad626a3f6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5a4444c50a61d6f787d4d238ed007ad626a3f6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5a4444c50a61d6f787d4d238ed007ad626a3f6d"}], "stats": {"total": 1368, "additions": 118, "deletions": 1250}, "files": [{"sha": "d599ec17a314f7972c927802a071d5c60cc5fb93", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a76829ccfe1b5cb484f79a8b7ba02299f228782", "patch": "@@ -1,5 +1,43 @@\n 2005-07-28  Jan Hubicka  <jh@suse.cz>\n \n+\t* Makefile.in (rtl-profile.o): Kill all traces of it.\n+\t* common.opt (fspeculative-prefetching, ftree-based-profiling): Kill.\n+\t* coverage.h (rtl_coverage_counter_ref): Kill.\n+\t* opts.c (flag_speculative_prefetching_set): Kill.\n+\t(flag_loop_optimize_set): New.\n+\t(common_handle_option): Disable loop optimizer when profiling;\n+\tdo not handle speculative prefetching.\n+\t* passes.c (init_optimization_passes): Replace pass_profiling combo\n+\tby branch_prob pass.\n+\t* profile.c (compute_value_histograms): Update for simplified value\n+\tprofiles.\n+\t(rtl_register_profile_hooks): Kill.\n+\t(pass_profiling): Kill.\n+\t(rest_of_handle_branch_prob): Do not profile.\n+\t* toplev.c (process_options): Remove speculative prefetching.\n+\t* toplev.h (flag_tree_based_profiling): Kill.\n+\t* tree-profile.c (prepare_instrumented_value,\n+\ttree_gen_interval_profiler, tree_gen_pow2_profiler,\n+\ttree_gen_one_value_profiler, do_tree_profiling): Update for\n+\tsimplified datastructures.\n+\t* value-prof.c: Add comment that speculative prefetching was dropped;\n+\tupdate rest of file for simplified datastructures.\n+\t(NOPREFETCH_RANGE_MIN, NOPREFETCH_RANGE_MAX,\n+\trtl_divmod_values_to_profile, insn_prefetch_values_to_profile,\n+\tfind_mem_reference_1, find_mem_reference_2, find_mem_reference,\n+\trtl_values_to_profile, rtl_divmod_fixed_value, rtl_mod_pow2,\n+\trtl_mod_subtract, gen_speculative_prefetch,\n+\trtl_divmod_fixed_value_transform, rtl_mod_pow2_value_transform,\n+\trtl_mod_subtract_transform, speculative_prefetching_transform): Kill.\n+\t(gate_handle_value_profile_transformations,\n+\trest_of_handle_value_profile_transformations,\n+\tpass_value_profile_transformations): Kill.\n+\t* value-prof.h (histogram_value_t): Remove IL based unions.\n+\t(rtl_register_value_prof_hooks, rtl_register_profile_hooks,\n+\trtl_profile_hooks): Remove hooks.\n+\n+\t* invoke.texi (-ftree-based-profiling, -fspeculative-prefetching): Kill.\n+\n \t* cgraph.c (cgraph_clone_edge): New UPDATE_ORIGINAL argument.\n \t(cgraph_clone_node): Likewise.\n \t* cgraph.h (cgraph_clone_edge): Update prototype."}, {"sha": "e465e00550e64b0133fba127087fa3f186eabb76", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8a76829ccfe1b5cb484f79a8b7ba02299f228782", "patch": "@@ -966,7 +966,7 @@ OBJS-common = \\\n  targhooks.o timevar.o toplev.o tracer.o tree.o tree-dump.o\t\t   \\\n  varasm.o varray.o vec.o version.o vmsdbgout.o xcoffout.o alloc-pool.o\t   \\\n  et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o passes.o\t   \\\n- rtl-profile.o tree-profile.o rtlhooks.o cfgexpand.o lambda-mat.o          \\\n+ tree-profile.o rtlhooks.o cfgexpand.o lambda-mat.o    \t\t\t   \\\n  lambda-trans.o\tlambda-code.o tree-loop-linear.o tree-ssa-sink.o \t   \\\n  tree-vrp.o tree-stdarg.o tree-cfgcleanup.o tree-ssa-reassoc.o\t\t   \\\n  tree-ssa-structalias.o tree-object-size.o\n@@ -2242,9 +2242,6 @@ tree-profile.o : tree-profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) \\\n    function.h toplev.h $(COVERAGE_H) $(TREE_H) value-prof.h $(TREE_DUMP_H) \\\n    tree-pass.h $(TREE_FLOW_H) $(TIMEVAR_H) $(GGC_H) gt-tree-profile.h\n-rtl-profile.o : tree-profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-   $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) \\\n-   function.h toplev.h $(COVERAGE_H) value-prof.h $(GGC_H)\n value-prof.o : value-prof.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h value-prof.h $(EXPR_H) output.h $(FLAGS_H) \\\n    $(RECOG_H) insn-config.h $(OPTABS_H) $(REGS_H) $(GGC_H) $(DIAGNOSTIC_H) \\\n@@ -2732,7 +2729,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/tree-iterator.c $(srcdir)/gimplify.c \\\n   $(srcdir)/tree-chrec.h $(srcdir)/tree-vect-generic.c \\\n   $(srcdir)/tree-ssa-operands.h $(srcdir)/tree-ssa-operands.c \\\n-  $(srcdir)/tree-profile.c $(srcdir)/rtl-profile.c $(srcdir)/tree-nested.c \\\n+  $(srcdir)/tree-profile.c $(srcdir)/tree-nested.c \\\n   $(srcdir)/ipa-reference.c \\\n   $(srcdir)/targhooks.c $(out_file) \\\n   @all_gtfiles@"}, {"sha": "d92a8feafa8e84520c831f138a55c3f312e60a1f", "filename": "gcc/common.opt", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=8a76829ccfe1b5cb484f79a8b7ba02299f228782", "patch": "@@ -779,10 +779,6 @@ fsingle-precision-constant\n Common Report Var(flag_single_precision_constant)\n Convert floating point constants to single precision constants\n \n-fspeculative-prefetching\n-Common Report Var(flag_speculative_prefetching)\n-Use value profiling for speculative prefetching\n-\n fsplit-ivs-in-unroller\n Common Report Var(flag_split_ivs_in_unroller) Init(1)\n Split lifetimes of induction variables when loops are unrolled\n@@ -863,10 +859,6 @@ ftrapv\n Common Report Var(flag_trapv)\n Trap for signed overflow in addition, subtraction and multiplication\n \n-ftree-based-profiling\n-Common Report Var(flag_tree_based_profiling)\n-Use tree-ssa based implementation of profiling\n-\n ftree-ccp\n Common Report Var(flag_tree_ccp)\n Enable SSA-CCP optimization on trees"}, {"sha": "a558e869addc2ca6920039eb079ab022f609096e", "filename": "gcc/coverage.c", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=8a76829ccfe1b5cb484f79a8b7ba02299f228782", "patch": "@@ -410,32 +410,6 @@ coverage_counter_alloc (unsigned counter, unsigned num)\n   return 1;\n }\n \n-/* Generate a MEM rtl to access COUNTER NO.  */\n-\n-rtx\n-rtl_coverage_counter_ref (unsigned counter, unsigned no)\n-{\n-  enum machine_mode mode = mode_for_size (GCOV_TYPE_SIZE, MODE_INT, 0);\n-  rtx ref;\n-\n-  gcc_assert (no < fn_n_ctrs[counter] - fn_b_ctrs[counter]);\n-  no += prg_n_ctrs[counter] + fn_b_ctrs[counter];\n-  if (!ctr_labels[counter])\n-      {\n-        ctr_labels[counter] = gen_rtx_SYMBOL_REF (Pmode,\n-\t\t\t       ggc_strdup (IDENTIFIER_POINTER (DECL_NAME\n-\t\t\t       (tree_ctr_tables[counter]))));\n-        SYMBOL_REF_FLAGS (ctr_labels[counter]) = SYMBOL_FLAG_LOCAL;\n-      }\n-  ref = plus_constant (ctr_labels[counter],\n-\t\t       GCOV_TYPE_SIZE / BITS_PER_UNIT * no);\n-  ref = gen_rtx_MEM (mode, ref);\n-  set_mem_alias_set (ref, new_alias_set ());\n-  MEM_NOTRAP_P (ref) = 1;\n-\n-  return ref;\n-}\n-\n /* Generate a tree to access COUNTER NO.  */\n \n tree"}, {"sha": "e070d837e2512b9bfee0de0735d29fc52e9f9d6c", "filename": "gcc/coverage.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Fcoverage.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Fcoverage.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.h?ref=8a76829ccfe1b5cb484f79a8b7ba02299f228782", "patch": "@@ -38,8 +38,6 @@ extern int coverage_begin_output (void);\n /* Allocate some counters. Repeatable per function.  */\n extern int coverage_counter_alloc (unsigned /*counter*/, unsigned/*num*/);\n /* Use a counter from the most recent allocation.  */\n-extern rtx rtl_coverage_counter_ref (unsigned /*counter*/, unsigned/*num*/);\n-/* Use a counter from the most recent allocation.  */\n extern tree tree_coverage_counter_ref (unsigned /*counter*/, unsigned/*num*/);\n \n /* Get all the counters for the current function.  */"}, {"sha": "398d2fc8ed2791b759257a15d5e2dd0a4febb918", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 32, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=8a76829ccfe1b5cb484f79a8b7ba02299f228782", "patch": "@@ -281,7 +281,7 @@ Objective-C and Objective-C++ Dialects}.\n -ftree-vectorizer-verbose=@var{n} @gol\n -fdump-tree-storeccp@r{[}-@var{n}@r{]} @gol\n -feliminate-dwarf2-dups -feliminate-unused-debug-types @gol\n--feliminate-unused-debug-symbols -fmem-report -fprofile-arcs -ftree-based-profiling @gol\n+-feliminate-unused-debug-symbols -fmem-report -fprofile-arcs @gol\n -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol\n -ftest-coverage  -ftime-report -fvar-tracking @gol\n -g  -g@var{level}  -gcoff -gdwarf-2 @gol\n@@ -325,7 +325,7 @@ Objective-C and Objective-C++ Dialects}.\n -fsched-stalled-insns=@var{n} -sched-stalled-insns-dep=@var{n} @gol\n -fsched2-use-superblocks @gol\n -fsched2-use-traces -freschedule-modulo-scheduled-loops @gol\n--fsignaling-nans -fsingle-precision-constant  -fspeculative-prefetching @gol\n+-fsignaling-nans -fsingle-precision-constant  @gol\n -fstrength-reduce  -fstrict-aliasing  -ftracer  -fthread-jumps @gol\n -funroll-all-loops  -funroll-loops  -fpeel-loops @gol\n -fsplit-ivs-in-unroller -funswitch-loops @gol\n@@ -3580,17 +3580,6 @@ executed.  When an arc is the only exit or only entrance to a block, the\n instrumentation code can be added to the block; otherwise, a new basic\n block must be created to hold the instrumentation code.\n \n-@item -ftree-based-profiling\n-@opindex ftree-based-profiling\n-This option is used in addition to @option{-fprofile-arcs} or\n-@option{-fbranch-probabilities} to control whether those optimizations\n-are performed on a tree-based or rtl-based internal representation.\n-If you use this option when compiling with @option{-fprofile-arcs},\n-you must also use it when compiling later with @option{-fbranch-probabilities}.\n-Currently the tree-based optimization is in an early stage of\n-development, and this option is recommended only for those people\n-working on improving it.\n-\n @need 2000\n @item -ftest-coverage\n @opindex ftest-coverage\n@@ -5329,8 +5318,9 @@ The following options are enabled: @code{-fprofile-arcs}, @code{-fprofile-values\n Enable profile feedback directed optimizations, and optimizations\n generally profitable only with profile feedback available.\n \n-The following options are enabled: @code{-fbranch-probabilities},\n-@code{-fvpt}, @code{-funroll-loops}, @code{-fpeel-loops}, @code{-ftracer}.\n+The following options are enabled: @code{-fbranch-probabilities}, @code{-fvpt},\n+@code{-funroll-loops}, @code{-fpeel-loops}, @code{-ftracer},\n+@code{-fno-loop-optimize}.\n \n @end table\n \n@@ -5527,23 +5517,6 @@ and actually performs the optimizations based on them.\n Currently the optimizations include specialization of division operation\n using the knowledge about the value of the denominator.\n \n-@item -fspeculative-prefetching\n-@opindex fspeculative-prefetching\n-If combined with @option{-fprofile-arcs}, it instructs the compiler to add\n-a code to gather information about addresses of memory references in the\n-program.\n-\n-With @option{-fbranch-probabilities}, it reads back the data gathered\n-and issues prefetch instructions according to them.  In addition to the opportunities\n-noticed by @option{-fprefetch-loop-arrays}, it also notices more complicated\n-memory access patterns---for example accesses to the data stored in linked\n-list whose elements are usually allocated sequentially.\n-\n-In order to prevent issuing double prefetches, usage of\n-@option{-fspeculative-prefetching} implies @option{-fno-prefetch-loop-arrays}.\n-\n-Enabled with @option{-fprofile-generate} and @option{-fprofile-use}.\n-\n @item -frename-registers\n @opindex frename-registers\n Attempt to avoid false dependencies in scheduled code by making use"}, {"sha": "7edaeac5b53e6d042a6d41e9d59e9796e4175a6c", "filename": "gcc/opts.c", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=8a76829ccfe1b5cb484f79a8b7ba02299f228782", "patch": "@@ -94,8 +94,8 @@ static const char undocumented_msg[] = N_(\"This switch lacks documentation\");\n static bool profile_arc_flag_set, flag_profile_values_set;\n static bool flag_unroll_loops_set, flag_tracer_set;\n static bool flag_value_profile_transformations_set;\n-bool flag_speculative_prefetching_set;\n static bool flag_peel_loops_set, flag_branch_probabilities_set;\n+static bool flag_loop_optimize_set;\n \n /* Input file names.  */\n const char **in_fnames;\n@@ -807,6 +807,10 @@ common_handle_option (size_t scode, const char *arg, int value)\n       flag_branch_probabilities_set = true;\n       break;\n \n+    case OPT_floop_optimize:\n+      flag_loop_optimize_set = true;\n+      break;\n+\n     case OPT_fcall_used_:\n       fix_register (arg, 0, 1);\n       break;\n@@ -883,10 +887,9 @@ common_handle_option (size_t scode, const char *arg, int value)\n         flag_tracer = value;\n       if (!flag_value_profile_transformations_set)\n         flag_value_profile_transformations = value;\n-#ifdef HAVE_prefetch\n-      if (0 && !flag_speculative_prefetching_set)\n-\tflag_speculative_prefetching = value;\n-#endif\n+      /* Old loop optimizer is incompatible with tree profiling.  */\n+      if (!flag_loop_optimize_set)\n+\tflag_loop_optimize = 0;\n       break;\n \n     case OPT_fprofile_generate:\n@@ -896,12 +899,6 @@ common_handle_option (size_t scode, const char *arg, int value)\n         flag_profile_values = value;\n       if (!flag_value_profile_transformations_set)\n         flag_value_profile_transformations = value;\n-      if (!flag_unroll_loops_set)\n-\tflag_unroll_loops = value;\n-#ifdef HAVE_prefetch\n-      if (0 && !flag_speculative_prefetching_set)\n-\tflag_speculative_prefetching = value;\n-#endif\n       break;\n \n     case OPT_fprofile_values:\n@@ -927,10 +924,6 @@ common_handle_option (size_t scode, const char *arg, int value)\n       flag_value_profile_transformations_set = true;\n       break;\n \n-    case OPT_fspeculative_prefetching:\n-      flag_speculative_prefetching_set = true;\n-      break;\n-\n     case OPT_frandom_seed:\n       /* The real switch is -fno-random-seed.  */\n       if (value)"}, {"sha": "16f816c7c1662839ebea0732ba60987e5ab75034", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=8a76829ccfe1b5cb484f79a8b7ba02299f228782", "patch": "@@ -600,7 +600,7 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_loop_optimize);\n   NEXT_PASS (pass_jump_bypass);\n   NEXT_PASS (pass_cfg);\n-  NEXT_PASS (pass_profiling);\n+  NEXT_PASS (pass_branch_prob);\n   NEXT_PASS (pass_rtl_ifcvt);\n   NEXT_PASS (pass_tracer);\n   /* Perform loop optimizations.  It might be better to do them a bit\n@@ -624,12 +624,6 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_postreload);\n   *p = NULL;\n \n-  p = &pass_profiling.sub;\n-  NEXT_PASS (pass_branch_prob);\n-  NEXT_PASS (pass_value_profile_transformations);\n-  NEXT_PASS (pass_remove_death_notes);\n-  *p = NULL;\n-\n   p = &pass_postreload.sub;\n   NEXT_PASS (pass_postreload_cse);\n   NEXT_PASS (pass_gcse2);"}, {"sha": "113927fd44a7d5868027ec32c472832855890501", "filename": "gcc/profile.c", "status": "modified", "additions": 10, "deletions": 69, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=8a76829ccfe1b5cb484f79a8b7ba02299f228782", "patch": "@@ -651,7 +651,7 @@ compute_value_histograms (histogram_values values)\n   gcov_type *histogram_counts[GCOV_N_VALUE_COUNTERS];\n   gcov_type *act_count[GCOV_N_VALUE_COUNTERS];\n   gcov_type *aact_count;\n-  histogram_value hist;\n+  histogram_value hist = 0;\n  \n   for (t = 0; t < GCOV_N_VALUE_COUNTERS; t++)\n     n_histogram_counters[t] = 0;\n@@ -683,37 +683,21 @@ compute_value_histograms (histogram_values values)\n \n   for (i = 0; i < VEC_length (histogram_value, values); i++)\n     {\n-      rtx hist_list = NULL_RTX;\n+      tree stmt = hist->hvalue.stmt;\n+      stmt_ann_t ann = get_stmt_ann (stmt);\n \n       hist = VEC_index (histogram_value, values, i);\n       t = (int) hist->type;\n \n       aact_count = act_count[t];\n       act_count[t] += hist->n_counters;\n \n-      if (!ir_type ())\n-\t{\n-\t  for (j = hist->n_counters; j > 0; j--)\n-\t    hist_list = alloc_EXPR_LIST (0, GEN_INT (aact_count[j - 1]), \n-\t\t\t\t\thist_list);\n-\t  hist_list = alloc_EXPR_LIST (0, \n-\t\t\tcopy_rtx (hist->hvalue.rtl.value), hist_list);\n-\t  hist_list = alloc_EXPR_LIST (0, GEN_INT (hist->type), hist_list);\n-\t  REG_NOTES (hist->hvalue.rtl.insn) =\n-\t      alloc_EXPR_LIST (REG_VALUE_PROFILE, hist_list,\n-\t\t\t       REG_NOTES (hist->hvalue.rtl.insn));\n-\t}\n-      else\n-\t{\n-\t  tree stmt = hist->hvalue.tree.stmt;\n-\t  stmt_ann_t ann = get_stmt_ann (stmt);\n-\t  hist->hvalue.tree.next = ann->histograms;\n-\t  ann->histograms = hist;\n-\t  hist->hvalue.tree.counters = \n-\t\txmalloc (sizeof (gcov_type) * hist->n_counters);\n-\t  for (j = 0; j < hist->n_counters; j++)\n-\t    hist->hvalue.tree.counters[j] = aact_count[j];\n-  \t}\n+      hist->hvalue.next = ann->histograms;\n+      ann->histograms = hist;\n+      hist->hvalue.counters = \n+\t    xmalloc (sizeof (gcov_type) * hist->n_counters);\n+      for (j = 0; j < hist->n_counters; j++)\n+\thist->hvalue.counters[j] = aact_count[j];\n     }\n \n   for (t = 0; t < GCOV_N_VALUE_COUNTERS; t++)\n@@ -1324,55 +1308,13 @@ tree_register_profile_hooks (void)\n   profile_hooks = &tree_profile_hooks;\n }\n \n-/* Set up hooks to enable RTL-based profiling.  */\n-\n-void\n-rtl_register_profile_hooks (void)\n-{\n-  gcc_assert (!ir_type ());\n-  profile_hooks = &rtl_profile_hooks;\n-}\n \f\n-static bool\n-gate_handle_profiling (void)\n-{\n-  return optimize > 0\n-         || (!flag_tree_based_profiling\n-\t     && (profile_arc_flag || flag_test_coverage\n-\t\t || flag_branch_probabilities));\n-}\n-\n-struct tree_opt_pass pass_profiling =\n-{\n-  NULL,                                 /* name */\n-  gate_handle_profiling,                /* gate */   \n-  NULL,\t\t\t\t        /* execute */       \n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  0,                                    /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0,                                    /* todo_flags_finish */\n-  0                                     /* letter */\n-};\n-\n-\n /* Do branch profiling and static profile estimation passes.  */\n static void\n rest_of_handle_branch_prob (void)\n {\n   struct loops loops;\n \n-  rtl_register_profile_hooks ();\n-  rtl_register_value_prof_hooks ();\n-\n-  if ((profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n-      && !flag_tree_based_profiling)\n-    branch_prob ();\n-\n   /* Discover and record the loop depth at the head of each basic\n      block.  The loop infrastructure does the real job for us.  */\n   flow_loops_find (&loops);\n@@ -1382,8 +1324,7 @@ rest_of_handle_branch_prob (void)\n \n   /* Estimate using heuristics if no profiling info is available.  */\n   if (flag_guess_branch_prob\n-      && (profile_status == PROFILE_ABSENT\n-          || (profile_status == PROFILE_READ && !flag_tree_based_profiling)))\n+      && profile_status == PROFILE_ABSENT)\n     estimate_probability (&loops);\n \n   flow_loops_free (&loops);"}, {"sha": "a8badc528d3f815135b9284376bdfe046dfba137", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8a76829ccfe1b5cb484f79a8b7ba02299f228782", "patch": "@@ -1,5 +1,9 @@\n 2005-07-28  Jan Hubicka  <jh@suse.cz>\n \n+\t* inliner-1.c: Do not dump everything.\n+\t* tree-prof.exp: Do not pass -ftree-based-profiling.\n+\t* bprob.exp: Likewise.\n+\n \t* gcc.dg/tree-prof/update-loopch.c: Fix thinkos.\n \n 2005-07-28  Mark Mitchell  <mark@codesourcery.com>"}, {"sha": "f4b971bff3c1d84be432a020e2c35a8c3aa42596", "filename": "gcc/testsuite/g++.dg/bprob/bprob.exp", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fbprob%2Fbprob.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fbprob%2Fbprob.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fbprob%2Fbprob.exp?ref=8a76829ccfe1b5cb484f79a8b7ba02299f228782", "patch": "@@ -52,10 +52,6 @@ load_lib profopt.exp\n \n set profile_options \"-fprofile-arcs\"\n set feedback_options \"-fbranch-probabilities\"\n-if {[check_profiling_available \"-ftree-based-profiling\"]} {\n-    lappend profile_options \"-ftree-based-profiling -fprofile-arcs\"\n-    lappend feedback_options \"-ftree-based-profiling -fbranch-probabilities\"\n-}\n \n # Main loop.\n foreach profile_option $profile_options feedback_option $feedback_options {"}, {"sha": "8d7c87919a5ba2351e433dd478b6acb75597b764", "filename": "gcc/testsuite/gcc.dg/tree-prof/inliner-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Finliner-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Finliner-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Finliner-1.c?ref=8a76829ccfe1b5cb484f79a8b7ba02299f228782", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -fdump-tree-optimized -fdump-tree-all\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n int a;\n int b[100];\n void abort (void);"}, {"sha": "f7438194396df188177e8eed3d72ef14f886620e", "filename": "gcc/testsuite/gcc.dg/tree-prof/tree-prof.exp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Ftree-prof.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Ftree-prof.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Ftree-prof.exp?ref=8a76829ccfe1b5cb484f79a8b7ba02299f228782", "patch": "@@ -20,7 +20,7 @@\n load_lib target-supports.exp\n \n # Some targets don't support tree profiling.\n-if { ![check_profiling_available \"-ftree-based-profiling\"] } {\n+if { ![check_profiling_available \"\"] } {\n     return\n }\n \n@@ -41,8 +41,8 @@ load_lib profopt.exp\n # These are globals used by profopt-execute.  The first is options\n # needed to generate profile data, the second is options to use the\n # profile data.\n-set profile_option \"-ftree-based-profiling -fprofile-generate\"\n-set feedback_option \"-ftree-based-profiling -fprofile-use\"\n+set profile_option \"-fprofile-generate\"\n+set feedback_option \"-fprofile-use\"\n \n foreach src [lsort [glob -nocomplain $srcdir/$subdir/*.c]] {\n     # If we're only testing specific files and this isn't one of them, skip it."}, {"sha": "745c43993fa37ab99e9156e2e15cc4ee90b4957c", "filename": "gcc/testsuite/gcc.misc-tests/bprob.exp", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fbprob.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fbprob.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fbprob.exp?ref=8a76829ccfe1b5cb484f79a8b7ba02299f228782", "patch": "@@ -49,10 +49,6 @@ load_lib profopt.exp\n \n set profile_options \"-fprofile-arcs\"\n set feedback_options \"-fbranch-probabilities\"\n-if {[check_profiling_available \"-ftree-based-profiling\"]} {\n-    lappend profile_options \"-ftree-based-profiling -fprofile-arcs\"\n-    lappend feedback_options \"-ftree-based-profiling -fbranch-probabilities\"\n-}\n \n foreach profile_option $profile_options feedback_option $feedback_options {\n     foreach src [lsort [glob -nocomplain $srcdir/$subdir/bprob-*.c]] {"}, {"sha": "094a2e245ace6d629012987e7671acb13a9a01aa", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=8a76829ccfe1b5cb484f79a8b7ba02299f228782", "patch": "@@ -1562,17 +1562,6 @@ process_options (void)\n   if (flag_value_profile_transformations)\n     flag_profile_values = 1;\n \n-  /* Speculative prefetching implies the value profiling.  We also switch off\n-     the prefetching in the loop optimizer, so that we do not emit double\n-     prefetches.  TODO -- we should teach these two to cooperate; the loop\n-     based prefetching may sometimes do a better job, especially in connection\n-     with reuse analysis.  */\n-  if (flag_speculative_prefetching)\n-    {\n-      flag_profile_values = 1;\n-      flag_prefetch_loop_arrays = 0;\n-    }\n-\n   /* Warn about options that are not supported on this machine.  */\n #ifndef INSN_SCHEDULING\n   if (flag_schedule_insns || flag_schedule_insns_after_reload)\n@@ -1732,24 +1721,12 @@ process_options (void)\n       warning (0, \"-fprefetch-loop-arrays not supported for this target\");\n       flag_prefetch_loop_arrays = 0;\n     }\n-  if (flag_speculative_prefetching)\n-    {\n-      if (flag_speculative_prefetching_set)\n-\twarning (0, \"-fspeculative-prefetching not supported for this target\");\n-      flag_speculative_prefetching = 0;\n-    }\n #else\n   if (flag_prefetch_loop_arrays && !HAVE_prefetch)\n     {\n       warning (0, \"-fprefetch-loop-arrays not supported for this target (try -march switches)\");\n       flag_prefetch_loop_arrays = 0;\n     }\n-  if (flag_speculative_prefetching && !HAVE_prefetch)\n-    {\n-      if (flag_speculative_prefetching_set)\n-\twarning (0, \"-fspeculative-prefetching not supported for this target (try -march switches)\");\n-      flag_speculative_prefetching = 0;\n-    }\n #endif\n \n   /* This combination of options isn't handled for i386 targets and doesn't"}, {"sha": "e293c9ec25a704899df437bded1bdb54f3c7ca11", "filename": "gcc/toplev.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=8a76829ccfe1b5cb484f79a8b7ba02299f228782", "patch": "@@ -128,7 +128,6 @@ extern int flag_unroll_all_loops;\n extern int flag_unswitch_loops;\n extern int flag_cprop_registers;\n extern int time_report;\n-extern int flag_tree_based_profiling;\n \n /* Things to do with target switches.  */\n extern void print_version (FILE *, const char *);"}, {"sha": "578104f4557ac1b4cc59fa0b7900d2fd76b3e237", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=8a76829ccfe1b5cb484f79a8b7ba02299f228782", "patch": "@@ -123,7 +123,7 @@ static tree\n prepare_instrumented_value (block_stmt_iterator *bsi,\n \t\t\t    histogram_value value)\n {\n-  tree val = value->hvalue.tree.value;\n+  tree val = value->hvalue.value;\n   return force_gimple_operand_bsi (bsi, fold_convert (gcov_type_node, val),\n \t\t\t\t   true, NULL_TREE);\n }\n@@ -135,7 +135,7 @@ prepare_instrumented_value (block_stmt_iterator *bsi,\n static void\n tree_gen_interval_profiler (histogram_value value, unsigned tag, unsigned base)\n {\n-  tree stmt = value->hvalue.tree.stmt;\n+  tree stmt = value->hvalue.stmt;\n   block_stmt_iterator bsi = bsi_for_stmt (stmt);\n   tree ref = tree_coverage_counter_ref (tag, base), ref_ptr;\n   tree args, call, val;\n@@ -162,7 +162,7 @@ tree_gen_interval_profiler (histogram_value value, unsigned tag, unsigned base)\n static void\n tree_gen_pow2_profiler (histogram_value value, unsigned tag, unsigned base)\n {\n-  tree stmt = value->hvalue.tree.stmt;\n+  tree stmt = value->hvalue.stmt;\n   block_stmt_iterator bsi = bsi_for_stmt (stmt);\n   tree ref = tree_coverage_counter_ref (tag, base), ref_ptr;\n   tree args, call, val;\n@@ -185,7 +185,7 @@ tree_gen_pow2_profiler (histogram_value value, unsigned tag, unsigned base)\n static void\n tree_gen_one_value_profiler (histogram_value value, unsigned tag, unsigned base)\n {\n-  tree stmt = value->hvalue.tree.stmt;\n+  tree stmt = value->hvalue.stmt;\n   block_stmt_iterator bsi = bsi_for_stmt (stmt);\n   tree ref = tree_coverage_counter_ref (tag, base), ref_ptr;\n   tree args, call, val;\n@@ -225,8 +225,7 @@ tree_gen_const_delta_profiler (histogram_value value ATTRIBUTE_UNUSED,\n static bool\n do_tree_profiling (void)\n {\n-  if (flag_tree_based_profiling\n-      && (profile_arc_flag || flag_test_coverage || flag_branch_probabilities))\n+  if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n     {\n       tree_register_profile_hooks ();\n       tree_register_value_prof_hooks ();"}, {"sha": "b9594f1fbe7ea3f060b948b6db85b602517e28fb", "filename": "gcc/value-prof.c", "status": "modified", "additions": 36, "deletions": 1024, "changes": 1060, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=8a76829ccfe1b5cb484f79a8b7ba02299f228782", "patch": "@@ -61,75 +61,21 @@ static histogram_values static_values = NULL;\n    2) Speculative prefetching.  If we are able to determine that the difference\n       between addresses accessed by a memory reference is usually constant, we\n       may add the prefetch instructions.\n+      FIXME: This transformation was removed together with RTL based value\n+      profiling.\n \n    Every such optimization should add its requirements for profiled values to\n    insn_values_to_profile function.  This function is called from branch_prob\n    in profile.c and the requested values are instrumented by it in the first\n    compilation with -fprofile-arcs.  The optimization may then read the\n    gathered data in the second compilation with -fbranch-probabilities.\n \n-   There are currently two versions, RTL-based and tree-based.  Over time\n-   the RTL-based version may go away.  \n-\n-   In the RTL-based version, the measured data is appended as REG_VALUE_PROFILE \n-   note to the instrumented insn.  The argument to the note consists of an\n-   EXPR_LIST where its members have the following meaning (from the first to \n-   the last):\n-   \n-   -- type of information gathered (HIST_TYPE*)\n-   -- the expression that is profiled\n-   -- list of counters starting from the first one.\n-\n-   In the tree-based version, the measured data is pointed to from the histograms\n+   The measured data is pointed to from the histograms\n    field of the statement annotation of the instrumented insns.  It is\n    kept as a linked list of struct histogram_value_t's, which contain the\n    same information as above.  */\n \n-/* For speculative prefetching, the range in that we do not prefetch (because\n-   we assume that it will be in cache anyway).  The asymmetry between min and\n-   max range is trying to reflect the fact that the sequential prefetching\n-   of the data is commonly done directly by hardware.  Nevertheless, these\n-   values are just a guess and should of course be target-specific.  \n-\n-   FIXME:  There is no tree form of speculative prefetching as yet.\n-\n-   FIXME:  A better approach to instrumentation in the profile-generation\n-   pass is to generate calls to magic library functions (to be added to\n-   libgcc) rather than inline code.  This approach will probably be\n-   necessary to get tree-based speculative prefetching working in a useful\n-   fashion, as inline code bloats things so much the rest of the compiler has\n-   serious problems dealing with it (judging from the rtl behavior).  */\n-\n-#ifndef NOPREFETCH_RANGE_MIN\n-#define NOPREFETCH_RANGE_MIN (-16)\n-#endif\n-#ifndef NOPREFETCH_RANGE_MAX\n-#define NOPREFETCH_RANGE_MAX 32\n-#endif\n-\n-static void rtl_divmod_values_to_profile (rtx, histogram_values *);\n-#ifdef HAVE_prefetch\n-static bool insn_prefetch_values_to_profile (rtx, histogram_values *);\n-static int find_mem_reference_1 (rtx *, void *);\n-static void find_mem_reference_2 (rtx, rtx, void *);\n-static bool find_mem_reference (rtx, rtx *, int *);\n-#endif\n-\n-static void rtl_values_to_profile (rtx, histogram_values *);\n-static rtx rtl_divmod_fixed_value (enum machine_mode, enum rtx_code, rtx, rtx,\n-\t\t\t\t   rtx, gcov_type, int);\n-static rtx rtl_mod_pow2 (enum machine_mode, enum rtx_code, rtx, rtx, rtx, int);\n-static rtx rtl_mod_subtract (enum machine_mode, enum rtx_code, rtx, rtx, rtx,\n-\t\t\t     int, int, int);\n-#ifdef HAVE_prefetch\n-static rtx gen_speculative_prefetch (rtx, gcov_type, int);\n-#endif\n-static bool rtl_divmod_fixed_value_transform (rtx);\n-static bool rtl_mod_pow2_value_transform (rtx);\n-static bool rtl_mod_subtract_transform (rtx);\n-#ifdef HAVE_prefetch\n-static bool speculative_prefetching_transform (rtx);\n-#endif\n+\n static tree tree_divmod_fixed_value (tree, tree, tree, tree, \n \t\t\t\t    tree, int, gcov_type, gcov_type);\n static tree tree_mod_pow2 (tree, tree, tree, tree, int, gcov_type, gcov_type);\n@@ -139,889 +85,6 @@ static bool tree_divmod_fixed_value_transform (tree);\n static bool tree_mod_pow2_value_transform (tree);\n static bool tree_mod_subtract_transform (tree);\n \n-\f\n-/* Find values inside INSN for that we want to measure histograms for\n-   division/modulo optimization and stores them to VALUES.  */\n-static void\n-rtl_divmod_values_to_profile (rtx insn, histogram_values *values)\n-{\n-  rtx set, set_src, op1, op2;\n-  enum machine_mode mode;\n-  histogram_value hist;\n-\n-  if (!INSN_P (insn))\n-    return;\n-\n-  set = single_set (insn);\n-  if (!set)\n-    return;\n-\n-  mode = GET_MODE (SET_DEST (set));\n-  if (!INTEGRAL_MODE_P (mode))\n-    return;\n-\n-  set_src = SET_SRC (set);\n-  switch (GET_CODE (set_src))\n-    {\n-    case DIV:\n-    case MOD:\n-    case UDIV:\n-    case UMOD:\n-      op1 = XEXP (set_src, 0);\n-      op2 = XEXP (set_src, 1);\n-      if (side_effects_p (op2))\n-\treturn;\n-\n-      /* Check for a special case where the divisor is power of 2.  */\n-      if ((GET_CODE (set_src) == UMOD) && !CONSTANT_P (op2))\n-\t{\n-\t  hist = ggc_alloc (sizeof (*hist));\n-\t  hist->hvalue.rtl.value = op2;\n-\t  hist->hvalue.rtl.seq = NULL_RTX;\n-\t  hist->hvalue.rtl.mode = mode;\n-\t  hist->hvalue.rtl.insn = insn;\n-\t  hist->type = HIST_TYPE_POW2;\n-\t  VEC_safe_push (histogram_value, heap, *values, hist);\n-\t}\n-\n-      /* Check whether the divisor is not in fact a constant.  */\n-      if (!CONSTANT_P (op2))\n-\t{\n-\t  hist = ggc_alloc (sizeof (*hist));\n-\t  hist->hvalue.rtl.value = op2;\n-\t  hist->hvalue.rtl.mode = mode;\n-\t  hist->hvalue.rtl.seq = NULL_RTX;\n-\t  hist->hvalue.rtl.insn = insn;\n-\t  hist->type = HIST_TYPE_SINGLE_VALUE;\n-\t  VEC_safe_push (histogram_value, heap, *values, hist);\n-\t}\n-\n-      /* For mod, check whether it is not often a noop (or replaceable by\n-\t a few subtractions).  */\n-      if (GET_CODE (set_src) == UMOD && !side_effects_p (op1))\n-\t{\n-\t  rtx tmp;\n-\n-\t  hist = ggc_alloc (sizeof (*hist));\n-\t  start_sequence ();\n-\t  tmp = simplify_gen_binary (DIV, mode, copy_rtx (op1), copy_rtx (op2));\n-\t  hist->hvalue.rtl.value = force_operand (tmp, NULL_RTX);\n-\t  hist->hvalue.rtl.seq = get_insns ();\n-\t  end_sequence ();\n-\t  hist->hvalue.rtl.mode = mode;\n-\t  hist->hvalue.rtl.insn = insn;\n-\t  hist->type = HIST_TYPE_INTERVAL;\n-\t  hist->hdata.intvl.int_start = 0;\n-\t  hist->hdata.intvl.steps = 2;\n-\t  VEC_safe_push (histogram_value, heap, *values, hist);\n-\t}\n-      return;\n-\n-    default:\n-      return;\n-    }\n-}\n-\n-#ifdef HAVE_prefetch\n-\n-/* Called from find_mem_reference through for_each_rtx, finds a memory\n-   reference.  I.e. if *EXPR is a MEM, the reference to this MEM is stored\n-   to *RET and the traversing of the expression is interrupted by returning 1.\n-   Otherwise 0 is returned.  */\n-\n-static int\n-find_mem_reference_1 (rtx *expr, void *ret)\n-{\n-  rtx *mem = ret;\n-\n-  if (MEM_P (*expr))\n-    {\n-      *mem = *expr;\n-      return 1;\n-    }\n-  return 0;\n-}\n-\n-/* Called form find_mem_reference through note_stores to find out whether\n-   the memory reference MEM is a store.  I.e. if EXPR == MEM, the variable\n-   FMR2_WRITE is set to true.  */\n-\n-static int fmr2_write;\n-static void\n-find_mem_reference_2 (rtx expr, rtx pat ATTRIBUTE_UNUSED, void *mem)\n-{\n-  if (expr == mem)\n-    fmr2_write = true;\n-}\n-\n-/* Find a memory reference inside INSN, return it in MEM. Set WRITE to true\n-   if it is a write of the mem.  Return false if no memory reference is found,\n-   true otherwise.  */\n-\n-static bool\n-find_mem_reference (rtx insn, rtx *mem, int *write)\n-{\n-  *mem = NULL_RTX;\n-  for_each_rtx (&PATTERN (insn), find_mem_reference_1, mem);\n-\n-  if (!*mem)\n-    return false;\n-  \n-  fmr2_write = false;\n-  note_stores (PATTERN (insn), find_mem_reference_2, *mem);\n-  *write = fmr2_write;\n-  return true;\n-}\n-\n-/* Find values inside INSN for that we want to measure histograms for\n-   a speculative prefetching.  Add them to the list VALUES.\n-   Returns true if such we found any such value, false otherwise.  */\n-\n-static bool\n-insn_prefetch_values_to_profile (rtx insn, histogram_values* values)\n-{\n-  rtx mem, address;\n-  int write;\n-  histogram_value hist;\n-\n-  /* It only makes sense to look for memory references in ordinary insns.  */\n-  if (!NONJUMP_INSN_P (insn))\n-    return false;\n-\n-  if (!find_mem_reference (insn, &mem, &write))\n-    return false;\n-\n-  address = XEXP (mem, 0);\n-  if (side_effects_p (address))\n-    return false;\n-      \n-  if (CONSTANT_P (address))\n-    return false;\n-\n-  hist = ggc_alloc (sizeof (*hist));\n-  hist->hvalue.rtl.value = address;\n-  hist->hvalue.rtl.mode = GET_MODE (address);\n-  hist->hvalue.rtl.seq = NULL_RTX;\n-  hist->hvalue.rtl.insn = insn;\n-  hist->type = HIST_TYPE_CONST_DELTA;\n-  VEC_safe_push (histogram_value, heap, *values, hist);\n-\n-  return true;\n-}\n-#endif\n-/* Find values inside INSN for that we want to measure histograms and adds\n-   them to list VALUES (increasing the record of its length in N_VALUES).  */\n-static void\n-rtl_values_to_profile (rtx insn, histogram_values *values)\n-{\n-  if (flag_value_profile_transformations)\n-    rtl_divmod_values_to_profile (insn, values);\n-\n-#ifdef HAVE_prefetch\n-  if (flag_speculative_prefetching)\n-    insn_prefetch_values_to_profile (insn, values);\n-#endif\n-}\n-\n-/* Find list of values for that we want to measure histograms.  */\n-static void\n-rtl_find_values_to_profile (histogram_values *values)\n-{\n-  rtx insn;\n-  unsigned i, libcall_level;\n-  histogram_value hist;\n-\n-  life_analysis (NULL, PROP_DEATH_NOTES);\n-\n-  *values = NULL;\n-  libcall_level = 0;\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    rtl_values_to_profile (insn, values);\n-  static_values = *values;\n-\n-  for (i = 0; VEC_iterate (histogram_value, *values, i, hist); i++)\n-    {\n-      switch (hist->type)\n-\t{\n-\tcase HIST_TYPE_INTERVAL:\n-\t  if (dump_file)\n-\t    fprintf (dump_file,\n-\t\t     \"Interval counter for insn %d, range %d -- %d.\\n\",\n-\t\t     INSN_UID ((rtx)hist->hvalue.rtl.insn),\n-\t\t     hist->hdata.intvl.int_start,\n-\t\t     (hist->hdata.intvl.int_start\n-\t\t      + hist->hdata.intvl.steps - 1));\n-\t  hist->n_counters = hist->hdata.intvl.steps + 2;\n-\t  break;\n-\n-\tcase HIST_TYPE_POW2:\n-\t  if (dump_file)\n-\t    fprintf (dump_file,\n-\t\t     \"Pow2 counter for insn %d.\\n\",\n-\t\t     INSN_UID ((rtx)hist->hvalue.rtl.insn));\n-\t  hist->n_counters = 2;\n-\t  break;\n-\n-\tcase HIST_TYPE_SINGLE_VALUE:\n-\t  if (dump_file)\n-\t    fprintf (dump_file,\n-\t\t     \"Single value counter for insn %d.\\n\",\n-\t\t     INSN_UID ((rtx)hist->hvalue.rtl.insn));\n-\t  hist->n_counters = 3;\n-\t  break;\n-\n-\tcase HIST_TYPE_CONST_DELTA:\n-\t  if (dump_file)\n-\t    fprintf (dump_file,\n-\t\t     \"Constant delta counter for insn %d.\\n\",\n-\t\t     INSN_UID ((rtx)hist->hvalue.rtl.insn));\n-\t  hist->n_counters = 4;\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-  allocate_reg_info (max_reg_num (), FALSE, FALSE);\n-}\n-\n-/* Main entry point.  Finds REG_VALUE_PROFILE notes from profiler and uses\n-   them to identify and exploit properties of values that are hard to analyze\n-   statically.\n-\n-   We do following transformations:\n-\n-   1)\n-\n-   x = a / b;\n-\n-   where b is almost always a constant N is transformed to\n-\n-   if (b == N)\n-     x = a / N;\n-   else\n-     x = a / b;\n-\n-   Analogically with %\n-\n-   2)\n-\n-   x = a % b\n-\n-   where b is almost always a power of 2 and the division is unsigned\n-   TODO -- handle signed case as well\n-\n-   if ((b & (b - 1)) == 0)\n-     x = a & (b - 1);\n-   else\n-     x = x % b;\n-\n-   Note that when b = 0, no error will occur and x = a; this is correct,\n-   as result of such operation is undefined.\n-\n-   3)\n-\n-   x = a % b\n-\n-   where a is almost always less then b and the division is unsigned\n-   TODO -- handle signed case as well\n-\n-   x = a;\n-   if (x >= b)\n-     x %= b;\n-\n-   4)\n-\n-   x = a % b\n-\n-   where a is almost always less then 2 * b and the division is unsigned\n-   TODO -- handle signed case as well\n-\n-   x = a;\n-   if (x >= b)\n-     x -= b;\n-   if (x >= b)\n-     x %= b;\n-\n-   It would be possible to continue analogically for K * b for other small\n-   K's, but it is probably not useful.\n-\n-   5)\n-\n-   Read or write of mem[address], where the value of address changes usually\n-   by a constant C != 0 between the following accesses to the computation; with\n-   -fspeculative-prefetching we then add a prefetch of address + C before\n-   the insn.  This handles prefetching of several interesting cases in addition\n-   to a simple prefetching for addresses that are induction variables, e. g.\n-   linked lists allocated sequentially (even in case they are processed\n-   recursively).\n-\n-   TODO -- we should also check whether there is not (usually) a small\n-\t   difference with the adjacent memory references, so that we do\n-\t   not issue overlapping prefetches.  Also we should employ some\n-\t   heuristics to eliminate cases where prefetching evidently spoils\n-\t   the code.\n-\t-- it should somehow cooperate with the loop optimizer prefetching\n-\n-   TODO:\n-\n-   There are other useful cases that could be handled by a similar mechanism,\n-   for example:\n-   \n-   for (i = 0; i < n; i++)\n-     ...\n-   \n-   transform to (for constant N):\n-   \n-   if (n == N)\n-     for (i = 0; i < N; i++)\n-       ...\n-   else\n-     for (i = 0; i < n; i++)\n-       ...\n-   making unroller happy.  Since this may grow the code significantly,\n-   we would have to be very careful here.  */\n-\n-static bool\n-rtl_value_profile_transformations (void)\n-{\n-  rtx insn, next;\n-  int changed = false;\n-\n-  for (insn = get_insns (); insn; insn = next)\n-    {\n-      next = NEXT_INSN (insn);\n-\n-      if (!INSN_P (insn))\n-\tcontinue;\n-\n-      /* Scan for insn carrying a histogram.  */\n-      if (!find_reg_note (insn, REG_VALUE_PROFILE, 0))\n-\tcontinue;\n-\n-      /* Ignore cold areas -- we are growing a code.  */\n-      if (!maybe_hot_bb_p (BLOCK_FOR_INSN (insn)))\n-\tcontinue;\n-\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"Trying transformations on insn %d\\n\",\n-\t\t   INSN_UID (insn));\n-\t  print_rtl_single (dump_file, insn);\n-\t}\n-\n-      /* Transformations:  */\n-      if (flag_value_profile_transformations\n-\t  && (rtl_mod_subtract_transform (insn)\n-\t      || rtl_divmod_fixed_value_transform (insn)\n-\t      || rtl_mod_pow2_value_transform (insn)))\n-\tchanged = true;\n-#ifdef HAVE_prefetch\n-      if (flag_speculative_prefetching\n-\t  && speculative_prefetching_transform (insn))\n-\tchanged = true;\n-#endif\n-    }\n-\n-  if (changed)\n-    {\n-      commit_edge_insertions ();\n-      allocate_reg_info (max_reg_num (), FALSE, FALSE);\n-    }\n-\n-  return changed;\n-}\n-\n-/* Generate code for transformation 1 (with MODE and OPERATION, operands OP1\n-   and OP2, whose value is expected to be VALUE, result TARGET and\n-   probability of taking the optimal path PROB).  */\n-static rtx\n-rtl_divmod_fixed_value (enum machine_mode mode, enum rtx_code operation,\n-\t\t\trtx target, rtx op1, rtx op2, gcov_type value,\n-\t\t\tint prob)\n-{\n-  rtx tmp, tmp1, jump;\n-  rtx neq_label = gen_label_rtx ();\n-  rtx end_label = gen_label_rtx ();\n-  rtx sequence;\n-\n-  start_sequence ();\n-  \n-  if (!REG_P (op2))\n-    {\n-      tmp = gen_reg_rtx (mode);\n-      emit_move_insn (tmp, copy_rtx (op2));\n-    }\n-  else\n-    tmp = op2;\n-\n-  do_compare_rtx_and_jump (tmp, GEN_INT (value), NE, 0, mode, NULL_RTX,\n-\t\t\t   NULL_RTX, neq_label);\n-\n-  /* Add branch probability to jump we just created.  */\n-  jump = get_last_insn ();\n-  REG_NOTES (jump) = gen_rtx_EXPR_LIST (REG_BR_PROB,\n-\t\t\t\t\tGEN_INT (REG_BR_PROB_BASE - prob),\n-\t\t\t\t\tREG_NOTES (jump));\n-\n-  tmp1 = simplify_gen_binary (operation, mode,\n-\t\t\t      copy_rtx (op1), GEN_INT (value));\n-  tmp1 = force_operand (tmp1, target);\n-  if (tmp1 != target)\n-    emit_move_insn (copy_rtx (target), copy_rtx (tmp1));\n-\n-  emit_jump_insn (gen_jump (end_label));\n-  emit_barrier ();\n-\n-  emit_label (neq_label);\n-  tmp1 = simplify_gen_binary (operation, mode,\n-\t\t\t      copy_rtx (op1), copy_rtx (tmp));\n-  tmp1 = force_operand (tmp1, target);\n-  if (tmp1 != target)\n-    emit_move_insn (copy_rtx (target), copy_rtx (tmp1));\n-  \n-  emit_label (end_label);\n-\n-  sequence = get_insns ();\n-  end_sequence ();\n-  rebuild_jump_labels (sequence);\n-  return sequence;\n-}\n-\n-/* Do transform 1) on INSN if applicable.  */\n-static bool\n-rtl_divmod_fixed_value_transform (rtx insn)\n-{\n-  rtx set, set_src, set_dest, op1, op2, value, histogram;\n-  enum rtx_code code;\n-  enum machine_mode mode;\n-  gcov_type val, count, all;\n-  edge e;\n-  int prob;\n-\n-  set = single_set (insn);\n-  if (!set)\n-    return false;\n-\n-  set_src = SET_SRC (set);\n-  set_dest = SET_DEST (set);\n-  code = GET_CODE (set_src);\n-  mode = GET_MODE (set_dest);\n-  \n-  if (code != DIV && code != MOD && code != UDIV && code != UMOD)\n-    return false;\n-  op1 = XEXP (set_src, false);\n-  op2 = XEXP (set_src, 1);\n-\n-  for (histogram = REG_NOTES (insn);\n-       histogram;\n-       histogram = XEXP (histogram, 1))\n-    if (REG_NOTE_KIND (histogram) == REG_VALUE_PROFILE\n-\t&& XEXP (XEXP (histogram, 0), 0) == GEN_INT (HIST_TYPE_SINGLE_VALUE))\n-      break;\n-\n-  if (!histogram)\n-    return false;\n-\n-  histogram = XEXP (XEXP (histogram, 0), 1);\n-  value = XEXP (histogram, 0);\n-  histogram = XEXP (histogram, 1);\n-  val = INTVAL (XEXP (histogram, 0));\n-  histogram = XEXP (histogram, 1);\n-  count = INTVAL (XEXP (histogram, 0));\n-  histogram = XEXP (histogram, 1);\n-  all = INTVAL (XEXP (histogram, 0));\n-\n-  /* We require that count be at least half of all; this means\n-     that for the transformation to fire the value must be constant\n-     at least 50% of time (and 75% gives the guarantee of usage).  */\n-  if (!rtx_equal_p (op2, value) || 2 * count < all)\n-    return false;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"Div/mod by constant transformation on insn %d\\n\",\n-\t     INSN_UID (insn));\n-\n-  /* Compute probability of taking the optimal path.  */\n-  prob = (count * REG_BR_PROB_BASE + all / 2) / all;\n-\n-  e = split_block (BLOCK_FOR_INSN (insn), PREV_INSN (insn));\n-  delete_insn (insn);\n-  \n-  insert_insn_on_edge (\n-\trtl_divmod_fixed_value (mode, code, set_dest,\n-\t\t\t\top1, op2, val, prob), e);\n-\n-  return true;\n-}\n-\n-/* Generate code for transformation 2 (with MODE and OPERATION, operands OP1\n-   and OP2, result TARGET and probability of taking the optimal path PROB).  */\n-static rtx\n-rtl_mod_pow2 (enum machine_mode mode, enum rtx_code operation, rtx target,\n-\t      rtx op1, rtx op2, int prob)\n-{\n-  rtx tmp, tmp1, tmp2, tmp3, jump;\n-  rtx neq_label = gen_label_rtx ();\n-  rtx end_label = gen_label_rtx ();\n-  rtx sequence;\n-\n-  start_sequence ();\n-  \n-  if (!REG_P (op2))\n-    {\n-      tmp = gen_reg_rtx (mode);\n-      emit_move_insn (tmp, copy_rtx (op2));\n-    }\n-  else\n-    tmp = op2;\n-\n-  tmp1 = expand_simple_binop (mode, PLUS, tmp, constm1_rtx, NULL_RTX,\n-\t\t\t      0, OPTAB_WIDEN);\n-  tmp2 = expand_simple_binop (mode, AND, tmp, tmp1, NULL_RTX,\n-\t\t\t      0, OPTAB_WIDEN);\n-  do_compare_rtx_and_jump (tmp2, const0_rtx, NE, 0, mode, NULL_RTX,\n-\t\t\t   NULL_RTX, neq_label);\n-\n-  /* Add branch probability to jump we just created.  */\n-  jump = get_last_insn ();\n-  REG_NOTES (jump) = gen_rtx_EXPR_LIST (REG_BR_PROB,\n-\t\t\t\t\tGEN_INT (REG_BR_PROB_BASE - prob),\n-\t\t\t\t\tREG_NOTES (jump));\n-\n-  tmp3 = expand_simple_binop (mode, AND, op1, tmp1, target,\n-\t\t\t      0, OPTAB_WIDEN);\n-  if (tmp3 != target)\n-    emit_move_insn (copy_rtx (target), tmp3);\n-  emit_jump_insn (gen_jump (end_label));\n-  emit_barrier ();\n-\n-  emit_label (neq_label);\n-  tmp1 = simplify_gen_binary (operation, mode, copy_rtx (op1), copy_rtx (tmp));\n-  tmp1 = force_operand (tmp1, target);\n-  if (tmp1 != target)\n-    emit_move_insn (target, tmp1);\n-  \n-  emit_label (end_label);\n-\n-  sequence = get_insns ();\n-  end_sequence ();\n-  rebuild_jump_labels (sequence);\n-  return sequence;\n-}\n-\n-/* Do transform 2) on INSN if applicable.  */\n-static bool\n-rtl_mod_pow2_value_transform (rtx insn)\n-{\n-  rtx set, set_src, set_dest, op1, op2, value, histogram;\n-  enum rtx_code code;\n-  enum machine_mode mode;\n-  gcov_type wrong_values, count;\n-  edge e;\n-  int all, prob;\n-\n-  set = single_set (insn);\n-  if (!set)\n-    return false;\n-\n-  set_src = SET_SRC (set);\n-  set_dest = SET_DEST (set);\n-  code = GET_CODE (set_src);\n-  mode = GET_MODE (set_dest);\n-  \n-  if (code != UMOD)\n-    return false;\n-  op1 = XEXP (set_src, 0);\n-  op2 = XEXP (set_src, 1);\n-\n-  for (histogram = REG_NOTES (insn);\n-       histogram;\n-       histogram = XEXP (histogram, 1))\n-    if (REG_NOTE_KIND (histogram) == REG_VALUE_PROFILE\n-\t&& XEXP (XEXP (histogram, 0), 0) == GEN_INT (HIST_TYPE_POW2))\n-      break;\n-\n-  if (!histogram)\n-    return false;\n-\n-  histogram = XEXP (XEXP (histogram, 0), 1);\n-  value = XEXP (histogram, 0);\n-  histogram = XEXP (histogram, 1);\n-  wrong_values = INTVAL (XEXP (histogram, 0));\n-  histogram = XEXP (histogram, 1);\n-  count = INTVAL (XEXP (histogram, 0));\n-\n-  if (!rtx_equal_p (op2, value))\n-    return false;\n-\n-  /* We require that we hit a power of two at least half of all evaluations.  */\n-  if (count < wrong_values)\n-    return false;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"Mod power of 2 transformation on insn %d\\n\",\n-\t     INSN_UID (insn));\n-\n-  /* Compute probability of taking the optimal path.  */\n-  all = count + wrong_values;\n-  prob = (count * REG_BR_PROB_BASE + all / 2) / all;\n-\n-  e = split_block (BLOCK_FOR_INSN (insn), PREV_INSN (insn));\n-  delete_insn (insn);\n-  \n-  insert_insn_on_edge (\n-\trtl_mod_pow2 (mode, code, set_dest, op1, op2, prob), e);\n-\n-  return true;\n-}\n-\n-/* Generate code for transformations 3 and 4 (with MODE and OPERATION,\n-   operands OP1 and OP2, result TARGET, at most SUB subtractions, and\n-   probability of taking the optimal path(s) PROB1 and PROB2).  */\n-static rtx\n-rtl_mod_subtract (enum machine_mode mode, enum rtx_code operation,\n-\t\t  rtx target, rtx op1, rtx op2, int sub, int prob1, int prob2)\n-{\n-  rtx tmp, tmp1, jump;\n-  rtx end_label = gen_label_rtx ();\n-  rtx sequence;\n-  int i;\n-\n-  start_sequence ();\n-  \n-  if (!REG_P (op2))\n-    {\n-      tmp = gen_reg_rtx (mode);\n-      emit_move_insn (tmp, copy_rtx (op2));\n-    }\n-  else\n-    tmp = op2;\n-\n-  emit_move_insn (target, copy_rtx (op1));\n-  do_compare_rtx_and_jump (target, tmp, LTU, 0, mode, NULL_RTX,\n-\t\t\t   NULL_RTX, end_label);\n-\n-  /* Add branch probability to jump we just created.  */\n-  jump = get_last_insn ();\n-  REG_NOTES (jump) = gen_rtx_EXPR_LIST (REG_BR_PROB,\n-\t\t\t\t\tGEN_INT (prob1), REG_NOTES (jump));\n-\n-  for (i = 0; i < sub; i++)\n-    {\n-      tmp1 = expand_simple_binop (mode, MINUS, target, tmp, target,\n-\t    \t\t\t  0, OPTAB_WIDEN);\n-      if (tmp1 != target)\n-\temit_move_insn (target, tmp1);\n-      do_compare_rtx_and_jump (target, tmp, LTU, 0, mode, NULL_RTX,\n-    \t\t\t       NULL_RTX, end_label);\n-\n-      /* Add branch probability to jump we just created.  */\n-      jump = get_last_insn ();\n-      REG_NOTES (jump) = gen_rtx_EXPR_LIST (REG_BR_PROB,\n-\t\t\t\t\t    GEN_INT (prob2), REG_NOTES (jump));\n-    }\n-\n-  tmp1 = simplify_gen_binary (operation, mode, copy_rtx (target), copy_rtx (tmp));\n-  tmp1 = force_operand (tmp1, target);\n-  if (tmp1 != target)\n-    emit_move_insn (target, tmp1);\n-  \n-  emit_label (end_label);\n-\n-  sequence = get_insns ();\n-  end_sequence ();\n-  rebuild_jump_labels (sequence);\n-  return sequence;\n-}\n-\n-/* Do transforms 3) and 4) on INSN if applicable.  */\n-static bool\n-rtl_mod_subtract_transform (rtx insn)\n-{\n-  rtx set, set_src, set_dest, op1, op2, histogram;\n-  enum rtx_code code;\n-  enum machine_mode mode;\n-  gcov_type wrong_values, counts[2], count, all;\n-  edge e;\n-  int i, prob1, prob2;\n-\n-  set = single_set (insn);\n-  if (!set)\n-    return false;\n-\n-  set_src = SET_SRC (set);\n-  set_dest = SET_DEST (set);\n-  code = GET_CODE (set_src);\n-  mode = GET_MODE (set_dest);\n-  \n-  if (code != UMOD)\n-    return false;\n-  op1 = XEXP (set_src, 0);\n-  op2 = XEXP (set_src, 1);\n-\n-  for (histogram = REG_NOTES (insn);\n-       histogram;\n-       histogram = XEXP (histogram, 1))\n-    if (REG_NOTE_KIND (histogram) == REG_VALUE_PROFILE\n-\t&& XEXP (XEXP (histogram, 0), 0) == GEN_INT (HIST_TYPE_INTERVAL))\n-      break;\n-\n-  if (!histogram)\n-    return false;\n-\n-  histogram = XEXP (XEXP (histogram, 0), 1);\n-  histogram = XEXP (histogram, 1);\n-\n-  all = 0;\n-  for (i = 0; i < 2; i++)\n-    {\n-      counts[i] = INTVAL (XEXP (histogram, 0));\n-      all += counts[i];\n-      histogram = XEXP (histogram, 1);\n-    }\n-  wrong_values = INTVAL (XEXP (histogram, 0));\n-  histogram = XEXP (histogram, 1);\n-  wrong_values += INTVAL (XEXP (histogram, 0));\n-  all += wrong_values;\n-\n-  /* We require that we use just subtractions in at least 50% of all\n-     evaluations.  */\n-  count = 0;\n-  for (i = 0; i < 2; i++)\n-    {\n-      count += counts[i];\n-      if (count * 2 >= all)\n-\tbreak;\n-    }\n-  \n-  if (i == 2)\n-    return false;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"Mod subtract transformation on insn %d\\n\",\n-\t     INSN_UID (insn));\n-\n-  /* Compute probability of taking the optimal path(s).  */\n-  prob1 = (counts[0] * REG_BR_PROB_BASE + all / 2) / all;\n-  prob2 = (counts[1] * REG_BR_PROB_BASE + all / 2) / all;\n-\n-  e = split_block (BLOCK_FOR_INSN (insn), PREV_INSN (insn));\n-  delete_insn (insn);\n-  \n-  insert_insn_on_edge (\n-\trtl_mod_subtract (mode, code, set_dest,\n-\t\t\t  op1, op2, i, prob1, prob2), e);\n-\n-  return true;\n-}\n-\n-#ifdef HAVE_prefetch\n-/* Generate code for transformation 5 for mem with ADDRESS and a constant\n-   step DELTA.  WRITE is true if the reference is a store to mem.  */\n-\n-static rtx\n-gen_speculative_prefetch (rtx address, gcov_type delta, int write)\n-{\n-  rtx tmp;\n-  rtx sequence;\n-\n-  /* TODO: we do the prefetching for just one iteration ahead, which\n-     often is not enough.  */\n-  start_sequence ();\n-  if (offsettable_address_p (0, VOIDmode, address))\n-    tmp = plus_constant (copy_rtx (address), delta);\n-  else\n-    {\n-      tmp = simplify_gen_binary (PLUS, Pmode,\n-\t\t\t\t copy_rtx (address), GEN_INT (delta));\n-      tmp = force_operand (tmp, NULL);\n-    }\n-  if (! (*insn_data[(int)CODE_FOR_prefetch].operand[0].predicate)\n-      (tmp, insn_data[(int)CODE_FOR_prefetch].operand[0].mode))\n-    tmp = force_reg (Pmode, tmp);\n-  emit_insn (gen_prefetch (tmp, GEN_INT (write), GEN_INT (3)));\n-  sequence = get_insns ();\n-  end_sequence ();\n-\n-  return sequence;\n-}\n-\n-/* Do transform 5) on INSN if applicable.  */\n-\n-static bool\n-speculative_prefetching_transform (rtx insn)\n-{\n-  rtx histogram, value;\n-  gcov_type val, count, all;\n-  edge e;\n-  rtx mem, address;\n-  int write;\n-\n-  if (!maybe_hot_bb_p (BLOCK_FOR_INSN (insn)))\n-    return false;\n-\n-  if (!find_mem_reference (insn, &mem, &write))\n-    return false;\n-\n-  address = XEXP (mem, 0);\n-  if (side_effects_p (address))\n-    return false;\n-      \n-  if (CONSTANT_P (address))\n-    return false;\n-\n-  for (histogram = REG_NOTES (insn);\n-       histogram;\n-       histogram = XEXP (histogram, 1))\n-    if (REG_NOTE_KIND (histogram) == REG_VALUE_PROFILE\n-\t&& XEXP (XEXP (histogram, 0), 0) == GEN_INT (HIST_TYPE_CONST_DELTA))\n-      break;\n-\n-  if (!histogram)\n-    return false;\n-\n-  histogram = XEXP (XEXP (histogram, 0), 1);\n-  value = XEXP (histogram, 0);\n-  histogram = XEXP (histogram, 1);\n-  /* Skip last value referenced.  */\n-  histogram = XEXP (histogram, 1);\n-  val = INTVAL (XEXP (histogram, 0));\n-  histogram = XEXP (histogram, 1);\n-  count = INTVAL (XEXP (histogram, 0));\n-  histogram = XEXP (histogram, 1);\n-  all = INTVAL (XEXP (histogram, 0));\n-\n-  /* With that few executions we do not really have a reason to optimize the\n-     statement, and more importantly, the data about differences of addresses\n-     are spoiled by the first item that had no previous value to compare\n-     with.  */\n-  if (all < 4)\n-    return false;\n-\n-  /* We require that count be at least half of all; this means\n-     that for the transformation to fire the value must be constant\n-     at least 50% of time (and 75% gives the guarantee of usage).  */\n-  if (!rtx_equal_p (address, value) || 2 * count < all)\n-    return false;\n-\n-  /* If the difference is too small, it does not make too much sense to\n-     prefetch, as the memory is probably already in cache.  */\n-  if (val >= NOPREFETCH_RANGE_MIN && val <= NOPREFETCH_RANGE_MAX)\n-    return false;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"Speculative prefetching for insn %d\\n\",\n-\t     INSN_UID (insn));\n-\n-  e = split_block (BLOCK_FOR_INSN (insn), PREV_INSN (insn));\n-  \n-  insert_insn_on_edge (gen_speculative_prefetch (address, val, write), e);\n-\n-  return true;\n-}\n-#endif  /* HAVE_prefetch */\n-\n /* Tree based transformations. */\n static bool\n tree_value_profile_transformations (void)\n@@ -1070,8 +133,8 @@ tree_value_profile_transformations (void)\n \t  /* Free extra storage from compute_value_histograms.  */\n \t  while (th)\n \t    {\n-\t      free (th->hvalue.tree.counters);\n-\t      th = th->hvalue.tree.next;\n+\t      free (th->hvalue.counters);\n+\t      th = th->hvalue.next;\n \t    }\n \t  ann->histograms = 0;\n         }\n@@ -1205,17 +268,17 @@ tree_divmod_fixed_value_transform (tree stmt)\n   if (!ann->histograms)\n     return false;\n \n-  for (histogram = ann->histograms; histogram; histogram = histogram->hvalue.tree.next)\n+  for (histogram = ann->histograms; histogram; histogram = histogram->hvalue.next)\n     if (histogram->type == HIST_TYPE_SINGLE_VALUE)\n       break;\n \n   if (!histogram)\n     return false;\n \n-  value = histogram->hvalue.tree.value;\n-  val = histogram->hvalue.tree.counters[0];\n-  count = histogram->hvalue.tree.counters[1];\n-  all = histogram->hvalue.tree.counters[2];\n+  value = histogram->hvalue.value;\n+  val = histogram->hvalue.counters[0];\n+  count = histogram->hvalue.counters[1];\n+  all = histogram->hvalue.counters[2];\n \n   /* We require that count is at least half of all; this means\n      that for the transformation to fire the value must be constant\n@@ -1371,16 +434,16 @@ tree_mod_pow2_value_transform (tree stmt)\n   if (!ann->histograms)\n     return false;\n \n-  for (histogram = ann->histograms; histogram; histogram = histogram->hvalue.tree.next)\n+  for (histogram = ann->histograms; histogram; histogram = histogram->hvalue.next)\n     if (histogram->type == HIST_TYPE_POW2)\n       break;\n \n   if (!histogram)\n     return false;\n \n-  value = histogram->hvalue.tree.value;\n-  wrong_values = histogram->hvalue.tree.counters[0];\n-  count = histogram->hvalue.tree.counters[1];\n+  value = histogram->hvalue.value;\n+  wrong_values = histogram->hvalue.counters[0];\n+  count = histogram->hvalue.counters[1];\n \n   /* We require that we hit a power of 2 at least half of all evaluations.  */\n   if (simple_cst_equal (op2, value) != 1 || count < wrong_values)\n@@ -1551,29 +614,29 @@ tree_mod_subtract_transform (tree stmt)\n   if (!ann->histograms)\n     return false;\n \n-  for (histogram = ann->histograms; histogram; histogram = histogram->hvalue.tree.next)\n+  for (histogram = ann->histograms; histogram; histogram = histogram->hvalue.next)\n     if (histogram->type == HIST_TYPE_INTERVAL)\n       break;\n \n   if (!histogram)\n     return false;\n \n-  value = histogram->hvalue.tree.value;\n+  value = histogram->hvalue.value;\n   all = 0;\n   wrong_values = 0;\n   for (i = 0; i < histogram->hdata.intvl.steps; i++)\n-    all += histogram->hvalue.tree.counters[i];\n+    all += histogram->hvalue.counters[i];\n \n-  wrong_values += histogram->hvalue.tree.counters[i];\n-  wrong_values += histogram->hvalue.tree.counters[i+1];\n+  wrong_values += histogram->hvalue.counters[i];\n+  wrong_values += histogram->hvalue.counters[i+1];\n   all += wrong_values;\n \n   /* We require that we use just subtractions in at least 50% of all\n      evaluations.  */\n   count = 0;\n   for (i = 0; i < histogram->hdata.intvl.steps; i++)\n     {\n-      count += histogram->hvalue.tree.counters[i];\n+      count += histogram->hvalue.counters[i];\n       if (count * 2 >= all)\n \tbreak;\n     }\n@@ -1587,22 +650,20 @@ tree_mod_subtract_transform (tree stmt)\n     }\n \n   /* Compute probability of taking the optimal path(s).  */\n-  prob1 = (histogram->hvalue.tree.counters[0] * REG_BR_PROB_BASE + all / 2) / all;\n-  prob2 = (histogram->hvalue.tree.counters[1] * REG_BR_PROB_BASE + all / 2) / all;\n+  prob1 = (histogram->hvalue.counters[0] * REG_BR_PROB_BASE + all / 2) / all;\n+  prob2 = (histogram->hvalue.counters[1] * REG_BR_PROB_BASE + all / 2) / all;\n \n   /* In practice, \"steps\" is always 2.  This interface reflects this,\n      and will need to be changed if \"steps\" can change.  */\n   result = tree_mod_subtract (stmt, op, op1, op2, prob1, prob2, i,\n-\t\t\t    histogram->hvalue.tree.counters[0], \n-\t\t\t    histogram->hvalue.tree.counters[1], all);\n+\t\t\t    histogram->hvalue.counters[0], \n+\t\t\t    histogram->hvalue.counters[1], all);\n \n   TREE_OPERAND (modify, 1) = result;\n \n   return true;\n }\n-\f\n-/* Connection to the outside world.  */\n-/* Struct for IR-dependent hooks.  */\n+\n struct value_prof_hooks {\n   /* Find list of values for which we want to measure histograms.  */\n   void (*find_values_to_profile) (histogram_values *);\n@@ -1611,20 +672,6 @@ struct value_prof_hooks {\n      statically.  See value-prof.c for more detail.  */\n   bool (*value_profile_transformations) (void);  \n };\n-\n-/* Hooks for RTL-based versions (the only ones that currently work).  */\n-static struct value_prof_hooks rtl_value_prof_hooks =\n-{\n-  rtl_find_values_to_profile,\n-  rtl_value_profile_transformations\n-};\n-\n-void \n-rtl_register_value_prof_hooks (void)\n-{\n-  value_prof_hooks = &rtl_value_prof_hooks;\n-  gcc_assert (!ir_type ());\n-}\n \f\n /* Find values inside STMT for that we want to measure histograms for\n    division/modulo optimization.  */\n@@ -1662,8 +709,8 @@ tree_divmod_values_to_profile (tree stmt, histogram_values *values)\n \t  /* Check for the case where the divisor is the same value most\n \t     of the time.  */\n \t  hist = ggc_alloc (sizeof (*hist));\n-\t  hist->hvalue.tree.value = divisor;\n-\t  hist->hvalue.tree.stmt = stmt;\n+\t  hist->hvalue.value = divisor;\n+\t  hist->hvalue.stmt = stmt;\n \t  hist->type = HIST_TYPE_SINGLE_VALUE;\n \t  VEC_quick_push (histogram_value, *values, hist);\n \t}\n@@ -1675,14 +722,14 @@ tree_divmod_values_to_profile (tree stmt, histogram_values *values)\n \t{\n           /* Check for a special case where the divisor is power of 2.  */\n \t  hist = ggc_alloc (sizeof (*hist));\n-\t  hist->hvalue.tree.value = divisor;\n-\t  hist->hvalue.tree.stmt = stmt;\n+\t  hist->hvalue.value = divisor;\n+\t  hist->hvalue.stmt = stmt;\n \t  hist->type = HIST_TYPE_POW2;\n \t  VEC_quick_push (histogram_value, *values, hist);\n \n \t  hist = ggc_alloc (sizeof (*hist));\n-\t  hist->hvalue.tree.stmt = stmt;\n-\t  hist->hvalue.tree.value\n+\t  hist->hvalue.stmt = stmt;\n+\t  hist->hvalue.value\n \t\t  = build2 (TRUNC_DIV_EXPR, type, op0, divisor);\n \t  hist->type = HIST_TYPE_INTERVAL;\n \t  hist->hdata.intvl.int_start = 0;\n@@ -1728,7 +775,7 @@ tree_find_values_to_profile (histogram_values *values)\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \"Interval counter for tree \");\n-\t      print_generic_expr (dump_file, hist->hvalue.tree.stmt, \n+\t      print_generic_expr (dump_file, hist->hvalue.stmt, \n \t\t\t\t  TDF_SLIM);\n \t      fprintf (dump_file, \", range %d -- %d.\\n\",\n \t\t     hist->hdata.intvl.int_start,\n@@ -1742,7 +789,7 @@ tree_find_values_to_profile (histogram_values *values)\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \"Pow2 counter for tree \");\n-\t      print_generic_expr (dump_file, hist->hvalue.tree.stmt, TDF_SLIM);\n+\t      print_generic_expr (dump_file, hist->hvalue.stmt, TDF_SLIM);\n \t      fprintf (dump_file, \".\\n\");\n \t    }\n \t  hist->n_counters = 2;\n@@ -1752,7 +799,7 @@ tree_find_values_to_profile (histogram_values *values)\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \"Single value counter for tree \");\n-\t      print_generic_expr (dump_file, hist->hvalue.tree.stmt, TDF_SLIM);\n+\t      print_generic_expr (dump_file, hist->hvalue.stmt, TDF_SLIM);\n \t      fprintf (dump_file, \".\\n\");\n \t    }\n \t  hist->n_counters = 3;\n@@ -1762,7 +809,7 @@ tree_find_values_to_profile (histogram_values *values)\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \"Constant delta counter for tree \");\n-\t      print_generic_expr (dump_file, hist->hvalue.tree.stmt, TDF_SLIM);\n+\t      print_generic_expr (dump_file, hist->hvalue.stmt, TDF_SLIM);\n \t      fprintf (dump_file, \".\\n\");\n \t    }\n \t  hist->n_counters = 4;\n@@ -1801,39 +848,4 @@ value_profile_transformations (void)\n   return retval;\n }\n \f\n-static bool \n-gate_handle_value_profile_transformations (void)\n-{\n-  return flag_branch_probabilities\n-         && flag_profile_values\n-         && !flag_tree_based_profiling\n-         && (flag_value_profile_transformations\n-             || flag_speculative_prefetching);\n-}\n-\n-\n-/* Do optimizations based on expression value profiles.  */\n-static void\n-rest_of_handle_value_profile_transformations (void)\n-{\n-  if (value_profile_transformations ())\n-    cleanup_cfg (CLEANUP_EXPENSIVE);\n-}\n-\n-struct tree_opt_pass pass_value_profile_transformations =\n-{\n-  \"vpt\",                               /* name */\n-  gate_handle_value_profile_transformations,           /* gate */\n-  rest_of_handle_value_profile_transformations,        /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_VPT,                               /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_dump_func,                       /* todo_flags_finish */\n-  'V'                                   /* letter */\n-};\n "}, {"sha": "f54b355ae9a4797bde475f69197bae0eb420f1c6", "filename": "gcc/value-prof.h", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76829ccfe1b5cb484f79a8b7ba02299f228782/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=8a76829ccfe1b5cb484f79a8b7ba02299f228782", "patch": "@@ -40,22 +40,12 @@ enum hist_type\n /* The value to measure.  */\n struct histogram_value_t\n {\n-  union \n+  struct\n     {\n-      struct\n-\t{\n-\t  rtx value;\t\t/* The value to profile.  */\n-\t  rtx seq;\t\t/* Insns required to count the profiled value.  */\n-\t  rtx insn;\t\t/* Insn before that to measure.  */\n-\t  enum machine_mode mode;\t        /* Mode of value to profile.  */\n-\t} rtl;\n-      struct\n-\t{\n-\t  tree value;\t\t/* The value to profile.  */\n-\t  tree stmt;\t\t/* Insn containing the value.  */\n-\t  gcov_type *counters;\t\t        /* Pointer to first counter.  */\n-\t  struct histogram_value_t *next;\t\t/* Linked list pointer.  */\n-\t} tree;\n+      tree value;\t\t/* The value to profile.  */\n+      tree stmt;\t\t/* Insn containing the value.  */\n+      gcov_type *counters;\t\t        /* Pointer to first counter.  */\n+      struct histogram_value_t *next;\t\t/* Linked list pointer.  */\n     } hvalue;\n   enum hist_type type;\t\t\t/* Type of information to measure.  */\n   unsigned n_counters;\t\t\t/* Number of required counters.  */\n@@ -77,7 +67,6 @@ DEF_VEC_ALLOC_P(histogram_value,heap);\n typedef VEC(histogram_value,heap) *histogram_values;\n \n /* Hooks registration.  */\n-extern void rtl_register_value_prof_hooks (void);\n extern void tree_register_value_prof_hooks (void);\n \n /* IR-independent entry points.  */\n@@ -113,13 +102,9 @@ extern void init_branch_prob (void);\n extern void branch_prob (void);\n extern void end_branch_prob (void);\n extern void tree_register_profile_hooks (void);\n-extern void rtl_register_profile_hooks (void);\n \n /* In tree-profile.c.  */\n extern struct profile_hooks tree_profile_hooks;\n \n-/* In rtl-profile.c.  */\n-extern struct profile_hooks rtl_profile_hooks;\n-\n #endif\t/* GCC_VALUE_PROF_H */\n "}]}