{"sha": "d76a1885bd4738696ea7e9374cf283aaf0921cce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc2YTE4ODViZDQ3Mzg2OTZlYTdlOTM3NGNmMjgzYWFmMDkyMWNjZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-05-29T00:03:30Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-05-29T00:03:30Z"}, "message": "runtime: disable split stacks for runtime_printf function under Clang\n\nLLVM's code generator does not currently support split stacks for vararg\nfunctions, so we disable split stacks for the only function that uses this\nfeature under Clang. This appears to be OK as long as:\n- this function only calls non-inlined, internal-linkage (hence no dynamic\n  loader) functions compiled with split stacks (i.e. go_vprintf), which can\n  allocate more stack space as required;\n- this function itself does not occupy more than BACKOFF bytes of stack space\n  (see libgcc/config/i386/morestack.S).\nThese conditions are currently known to be satisfied by Clang on x86-32 and\nx86-64. Note that signal handlers receive slightly less stack space than they\nwould normally do if they happen to be called while this function is being\nrun. If this turns out to be a problem we could consider increasing BACKOFF.\n\nFrom-SVN: r211037", "tree": {"sha": "4d779d266d02877f0745ae648992e2b0bc6c2c4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d779d266d02877f0745ae648992e2b0bc6c2c4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d76a1885bd4738696ea7e9374cf283aaf0921cce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d76a1885bd4738696ea7e9374cf283aaf0921cce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d76a1885bd4738696ea7e9374cf283aaf0921cce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d76a1885bd4738696ea7e9374cf283aaf0921cce/comments", "author": null, "committer": null, "parents": [{"sha": "93c521ea9cf06574be59d946d160938accc4eb4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93c521ea9cf06574be59d946d160938accc4eb4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93c521ea9cf06574be59d946d160938accc4eb4c"}], "stats": {"total": 22, "additions": 21, "deletions": 1}, "files": [{"sha": "ba0b86a2c56e24af6b1c99a2bcebfe13217663c9", "filename": "libgo/runtime/print.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d76a1885bd4738696ea7e9374cf283aaf0921cce/libgo%2Fruntime%2Fprint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d76a1885bd4738696ea7e9374cf283aaf0921cce/libgo%2Fruntime%2Fprint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fprint.c?ref=d76a1885bd4738696ea7e9374cf283aaf0921cce", "patch": "@@ -11,7 +11,9 @@\n \n //static Lock debuglock;\n \n-static void go_vprintf(const char*, va_list);\n+// Clang requires this function to not be inlined (see below).\n+static void go_vprintf(const char*, va_list)\n+__attribute__((noinline));\n \n // write to goroutine-local buffer if diverting output,\n // or else standard error.\n@@ -61,6 +63,24 @@ runtime_prints(const char *s)\n \tgwrite(s, runtime_findnull((const byte*)s));\n }\n \n+#if defined (__clang__) && (defined (__i386__) || defined (__x86_64__))\n+// LLVM's code generator does not currently support split stacks for vararg\n+// functions, so we disable the feature for this function under Clang. This\n+// appears to be OK as long as:\n+// - this function only calls non-inlined, internal-linkage (hence no dynamic\n+//   loader) functions compiled with split stacks (i.e. go_vprintf), which can\n+//   allocate more stack space as required;\n+// - this function itself does not occupy more than BACKOFF bytes of stack space\n+//   (see libgcc/config/i386/morestack.S).\n+// These conditions are currently known to be satisfied by Clang on x86-32 and\n+// x86-64. Note that signal handlers receive slightly less stack space than they\n+// would normally do if they happen to be called while this function is being\n+// run. If this turns out to be a problem we could consider increasing BACKOFF.\n+void\n+runtime_printf(const char *s, ...)\n+__attribute__((no_split_stack));\n+#endif\n+\n void\n runtime_printf(const char *s, ...)\n {"}]}