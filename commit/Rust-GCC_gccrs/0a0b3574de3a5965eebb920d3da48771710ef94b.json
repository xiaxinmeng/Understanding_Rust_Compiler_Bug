{"sha": "0a0b3574de3a5965eebb920d3da48771710ef94b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGEwYjM1NzRkZTNhNTk2NWVlYmI5MjBkM2RhNDg3NzE3MTBlZjk0Yg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2010-09-05T21:50:46Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2010-09-05T21:50:46Z"}, "message": "c.opt (Wdouble-promotion): New.\n\n\t* c.opt (Wdouble-promotion): New.\n\n\t* doc/invoke.texi: Document -Wdouble-promotion.\n\t* c-typeck.c (convert_arguments): Check for implicit conversions\n\tfrom float to double.\n\t(do_warn_double_promotion): New function.\n\t(build_conditional_expr): Use it.\n\t(build_binary_op): Likewise.\n\n\t* gcc.dg/Wdouble-promotion.c: New.\n\nFrom-SVN: r163884", "tree": {"sha": "cf50ecb46ce69121764e0c94a17d14428dabc011", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf50ecb46ce69121764e0c94a17d14428dabc011"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a0b3574de3a5965eebb920d3da48771710ef94b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a0b3574de3a5965eebb920d3da48771710ef94b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a0b3574de3a5965eebb920d3da48771710ef94b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a0b3574de3a5965eebb920d3da48771710ef94b/comments", "author": null, "committer": null, "parents": [{"sha": "46d2b70cd7923180ef8869537fd5a2bd9a3de2f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46d2b70cd7923180ef8869537fd5a2bd9a3de2f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46d2b70cd7923180ef8869537fd5a2bd9a3de2f1"}], "stats": {"total": 207, "additions": 203, "deletions": 4}, "files": [{"sha": "1edae2f110776633573ccd1a820a8449e30d287d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0b3574de3a5965eebb920d3da48771710ef94b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0b3574de3a5965eebb920d3da48771710ef94b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a0b3574de3a5965eebb920d3da48771710ef94b", "patch": "@@ -1,3 +1,12 @@\n+2010-09-05  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* doc/invoke.texi: Document -Wdouble-promotion.\n+\t* c-typeck.c (convert_arguments): Check for implicit conversions\n+\tfrom float to double.\n+\t(do_warn_double_promotion): New function.\n+\t(build_conditional_expr): Use it.\n+\t(build_binary_op): Likewise.\n+\n 2010-09-05  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/45535"}, {"sha": "0a6aaa5d59545e2192c0bbece0570fc66419e1fe", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0b3574de3a5965eebb920d3da48771710ef94b/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0b3574de3a5965eebb920d3da48771710ef94b/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=0a0b3574de3a5965eebb920d3da48771710ef94b", "patch": "@@ -1,3 +1,7 @@\n+2010-09-05  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* c.opt (Wdouble-promotion): New.\n+\n 2010-09-02  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c.opt (falt-external-templates, fhuge-objects, fvtable-gc,"}, {"sha": "a997f79cf8c5fd6d904e91b3bbe79bd872d83d92", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0b3574de3a5965eebb920d3da48771710ef94b/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0b3574de3a5965eebb920d3da48771710ef94b/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=0a0b3574de3a5965eebb920d3da48771710ef94b", "patch": "@@ -266,6 +266,10 @@ Wimplicit\n C ObjC Var(warn_implicit) Init(-1) Warning\n Warn about implicit declarations\n \n+Wdouble-promotion\n+C ObjC C++ ObjC++ Var(warn_double_promotion) Warning\n+Warn about implicit conversions from \\\"float\\\" to \\\"double\\\"\n+\n Wimplicit-function-declaration\n C ObjC Var(warn_implicit_function_declaration) Init(-1) Warning\n Warn about implicit function declarations"}, {"sha": "87c51104038ea49f6db8b0b548e44c73576f2224", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0b3574de3a5965eebb920d3da48771710ef94b/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0b3574de3a5965eebb920d3da48771710ef94b/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=0a0b3574de3a5965eebb920d3da48771710ef94b", "patch": "@@ -3106,8 +3106,15 @@ convert_arguments (tree typelist, VEC(tree,gc) *values,\n \t  if (type_generic)\n \t    parmval = val;\n \t  else\n-\t    /* Convert `float' to `double'.  */\n-\t    parmval = convert (double_type_node, val);\n+\t    {\n+\t      /* Convert `float' to `double'.  */\n+\t      if (warn_double_promotion && !c_inhibit_evaluation_warnings)\n+\t\twarning (OPT_Wdouble_promotion,\n+\t\t\t \"implicit conversion from %qT to %qT when passing \"\n+\t\t\t \"argument to function\",\n+\t\t\t valtype, double_type_node);\n+\t      parmval = convert (double_type_node, val);\n+\t    }\n \t}\n       else if (excess_precision && !type_generic)\n \t/* A \"double\" argument with excess precision being passed\n@@ -4029,6 +4036,40 @@ ep_convert_and_check (tree type, tree expr, tree semantic_type)\n   return convert (type, expr);\n }\n \n+/* RESULT_TYPE is the result of converting TYPE1 and TYPE2 to a common\n+   type via c_common_type.  If -Wdouble-promotion is in use, and the\n+   conditions for warning have been met, issue a warning.  GMSGID is\n+   the warning message.  It must have two %T specifiers for the type\n+   that was converted (generally \"float\") and the type to which it was\n+   converted (generally \"double), respectively.  LOC is the location\n+   to which the awrning should refer.  */\n+\n+static void\n+do_warn_double_promotion (tree result_type, tree type1, tree type2,\n+\t\t\t const char *gmsgid, location_t loc)\n+{\n+  tree source_type;\n+\n+  if (!warn_double_promotion)\n+    return;\n+  /* If the conversion will not occur at run-time, there is no need to\n+     warn about it.  */\n+  if (c_inhibit_evaluation_warnings)\n+    return;\n+  if (TYPE_MAIN_VARIANT (result_type) != double_type_node\n+      && TYPE_MAIN_VARIANT (result_type) != complex_double_type_node)\n+    return;\n+  if (TYPE_MAIN_VARIANT (type1) == float_type_node\n+      || TYPE_MAIN_VARIANT (type1) == complex_float_type_node)\n+    source_type = type1;\n+  else if (TYPE_MAIN_VARIANT (type2) == float_type_node\n+\t   || TYPE_MAIN_VARIANT (type2) == complex_float_type_node)\n+    source_type = type2;\n+  else\n+    return;\n+  warning_at (loc, OPT_Wdouble_promotion, gmsgid, source_type, result_type);\n+}\n+\n /* Build and return a conditional expression IFEXP ? OP1 : OP2.  If\n    IFEXP_BCP then the condition is a call to __builtin_constant_p, and\n    if folded to an integer constant then the unselected half may\n@@ -4140,6 +4181,10 @@ build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n \t       || code2 == COMPLEX_TYPE))\n     {\n       result_type = c_common_type (type1, type2);\n+      do_warn_double_promotion (result_type, type1, type2,\n+\t\t\t\t\"implicit conversion from %qT to %qT to \"\n+\t\t\t\t\"match other result of conditional\",\n+\t\t\t\tcolon_loc);\n \n       /* If -Wsign-compare, warn here if type1 and type2 have\n \t different signedness.  We'll promote the signed to unsigned\n@@ -9822,6 +9867,11 @@ build_binary_op (location_t location, enum tree_code code,\n       if (shorten || common || short_compare)\n \t{\n \t  result_type = c_common_type (type0, type1);\n+\t  do_warn_double_promotion (result_type, type0, type1,\n+\t\t\t\t    \"implicit conversion from %qT to %qT \"\n+\t\t\t\t    \"to match other operand of binary \"\n+\t\t\t\t    \"expression\",\n+\t\t\t\t    location);\n \t  if (result_type == error_mark_node)\n \t    return error_mark_node;\n \t}"}, {"sha": "95bfe6c9ba2a2133e82f4d94a26b6b782707824c", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0b3574de3a5965eebb920d3da48771710ef94b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0b3574de3a5965eebb920d3da48771710ef94b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=0a0b3574de3a5965eebb920d3da48771710ef94b", "patch": "@@ -235,8 +235,8 @@ Objective-C and Objective-C++ Dialects}.\n -Wchar-subscripts -Wclobbered  -Wcomment @gol\n -Wconversion  -Wcoverage-mismatch  -Wcpp  -Wno-deprecated  @gol\n -Wno-deprecated-declarations -Wdisabled-optimization  @gol\n--Wno-div-by-zero -Wempty-body  -Wenum-compare -Wno-endif-labels @gol\n--Werror  -Werror=* @gol\n+-Wno-div-by-zero -Wdouble-promotion -Wempty-body  -Wenum-compare @gol\n+-Wno-endif-labels -Werror  -Werror=* @gol\n -Wfatal-errors  -Wfloat-equal  -Wformat  -Wformat=2 @gol\n -Wno-format-contains-nul -Wno-format-extra-args -Wformat-nonliteral @gol\n -Wformat-security  -Wformat-y2k @gol\n@@ -3053,6 +3053,30 @@ This warning is enabled by @option{-Wall}.\n \n Suppress warning messages emitted by @code{#warning} directives.\n \n+@item -Wdouble-promotion @r{(C and Objective-C only)}\n+@opindex Wdouble-promotion\n+@opindex Wno-double-promotion\n+Give a warning when a value of type @code{float} is implicitly\n+promoted to @code{double}.  CPUs with a 32-bit ``single-precision''\n+floating-point unit implement @code{float} in hardware, but emulate\n+@code{double} in software.  On such a machine, doing computations\n+using @code{double} values is much more expensive because of the\n+overhead required for software emulation.  \n+\n+It is easy to accidentally do computations with @code{double} because\n+floating-point literals are implicitly of type @code{double}.  For\n+example, in:\n+@smallexample\n+@group\n+float area(float radius)\n+@{\n+   return 3.14159 * radius * radius;        \n+@}\n+@end group\n+@end smallexample\n+the compiler will perform the entire computation with @code{double}\n+because the floating-point literal is a @code{double}.\n+\n @item -Wformat\n @opindex Wformat\n @opindex Wno-format"}, {"sha": "316811e0f21644eef4c90030cd26ac7e75d86a0c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0b3574de3a5965eebb920d3da48771710ef94b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0b3574de3a5965eebb920d3da48771710ef94b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0a0b3574de3a5965eebb920d3da48771710ef94b", "patch": "@@ -1,3 +1,7 @@\n+2010-09-05  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* gcc.dg/Wdouble-promotion.c: New.\n+\n 2010-09-05  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.dg/float128_1.f90: Remove test case as"}, {"sha": "d7a61899f7fb5938fa4e40ce3c8632140b4d5b66", "filename": "gcc/testsuite/gcc.dg/Wdouble-promotion.c", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a0b3574de3a5965eebb920d3da48771710ef94b/gcc%2Ftestsuite%2Fgcc.dg%2FWdouble-promotion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a0b3574de3a5965eebb920d3da48771710ef94b/gcc%2Ftestsuite%2Fgcc.dg%2FWdouble-promotion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWdouble-promotion.c?ref=0a0b3574de3a5965eebb920d3da48771710ef94b", "patch": "@@ -0,0 +1,104 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wdouble-promotion\" } */\n+\n+#include <stddef.h>\n+\n+/* Some targets do not provide <complex.h> so we define I ourselves.  */\n+#define I 1.0iF\n+#define ID ((_Complex double)I)\n+\n+float f;\n+double d;\n+int i;\n+long double ld;\n+_Complex float cf;\n+_Complex double cd;\n+_Complex long double cld;\n+size_t s;\n+\n+extern void unprototyped_fn ();\n+extern void varargs_fn (int, ...);\n+extern void double_fn (double);\n+extern float float_fn (void);\n+\n+void \n+usual_arithmetic_conversions(void) \n+{\n+  float local_f;\n+  _Complex float local_cf;\n+\n+  /* Values of type \"float\" are implicitly converted to \"double\" or\n+     \"long double\" due to use in arithmetic with \"double\" or \"long\n+     double\" operands.  */\n+  local_f = f + 1.0;         /* { dg-warning \"implicit\" } */\n+  local_f = f - d;           /* { dg-warning \"implicit\" } */\n+  local_f = 1.0f * 1.0;      /* { dg-warning \"implicit\" } */\n+  local_f = 1.0f / d;        /* { dg-warning \"implicit\" } */\n+\n+  local_cf = cf + 1.0;       /* { dg-warning \"implicit\" } */\n+  local_cf = cf - d;         /* { dg-warning \"implicit\" } */\n+  local_cf = cf + 1.0 * ID;  /* { dg-warning \"implicit\" } */\n+  local_cf = cf - cd;        /* { dg-warning \"implicit\" } */\n+  \n+  local_f = i ? f : d;       /* { dg-warning \"implicit\" } */\n+  i = f == d;                /* { dg-warning \"implicit\" } */\n+  i = d != f;                /* { dg-warning \"implicit\" } */\n+}\n+\n+void \n+default_argument_promotion (void) \n+{\n+  /* Because there is no prototype, \"f\" is promoted to \"double\".  */\n+  unprototyped_fn (f); /* { dg-warning \"implicit\" } */\n+  undeclared_fn (f);   /* { dg-warning \"implicit\" } */\n+  /* Because \"f\" is part of the variable argument list, it is promoted\n+     to \"double\".  */\n+  varargs_fn (1, f);   /* { dg-warning \"implicit\" } */\n+}\n+\n+/* There is no warning when an explicit cast is used to perform the\n+   conversion.  */\n+\n+void\n+casts (void) \n+{\n+  float local_f;\n+  _Complex float local_cf;\n+\n+  local_f = (double)f + 1.0;                 /* { dg-bogus \"implicit\" } */\n+  local_f = (double)f - d;                   /* { dg-bogus \"implicit\" } */\n+  local_f = (double)1.0f + 1.0;              /* { dg-bogus \"implicit\" } */\n+  local_f = (double)1.0f - d;                /* { dg-bogus \"implicit\" } */\n+\n+  local_cf = (_Complex double)cf + 1.0;      /* { dg-bogus \"implicit\" } */\n+  local_cf = (_Complex double)cf - d;        /* { dg-bogus \"implicit\" } */\n+  local_cf = (_Complex double)cf + 1.0 * ID; /* { dg-bogus \"implicit\" } */\n+  local_cf = (_Complex double)cf - cd;       /* { dg-bogus \"implicit\" } */\n+\n+  local_f = i ? (double)f : d;               /* { dg-bogus \"implicit\" } */\n+  i = (double)f == d;                        /* { dg-bogus \"implicit\" } */\n+  i = d != (double)f;                        /* { dg-bogus \"implicit\" } */\n+}\n+\n+/* There is no warning on conversions that occur in assignment (and\n+   assignment-like) contexts.  */\n+\n+void \n+assignments (void)\n+{\n+  d = f;           /* { dg-bogus \"implicit\" } */\n+  double_fn (f);   /* { dg-bogus \"implicit\" } */\n+  d = float_fn (); /* { dg-bogus \"implicit\" } */\n+}\n+\n+/* There is no warning in non-evaluated contexts.  */\n+\n+void\n+non_evaluated (void)\n+{\n+  s = sizeof (f + 1.0);             /* { dg-bogus \"implicit\" } */\n+  s = __alignof__ (f + 1.0);        /* { dg-bogus \"implicit\" } */\n+  d = (__typeof__(f + 1.0))f;       /* { dg-bogus \"implicit\" } */\n+  s = sizeof (i ? f : d);           /* { dg-bogus \"implicit\" } */\n+  s = sizeof (unprototyped_fn (f)); /* { dg-bogus \"implicit\" } */\n+}"}]}