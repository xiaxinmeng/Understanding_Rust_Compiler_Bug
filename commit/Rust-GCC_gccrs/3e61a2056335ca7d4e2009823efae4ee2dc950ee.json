{"sha": "3e61a2056335ca7d4e2009823efae4ee2dc950ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U2MWEyMDU2MzM1Y2E3ZDRlMjAwOTgyM2VmYWU0ZWUyZGM5NTBlZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-07-20T11:38:16Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-07-31T06:22:45Z"}, "message": "Compute RPO with adjacent SCC members, expose toplevel SCC extents\n\nThis produces a more optimal RPO order for iteration processing\nby making sure that SCC exits are processed before SCC members\nthemselves..  This avoids iterating blocks unrelated to the current\niteration for RPO VN and has the chance to improve code-generation\nfor the non-iterative mode of RPO VN.  The patch also exposes toplevel\nSCCs and gets rid of the ad-hoc max_rpo computation in RPO VN.\n\nFor simplicity it also removes the odd reverse ordering of the RPO\narray returned from rev_post_order_and_mark_dfs_back_seme.\n\nOverall reduction in the number of visited blocks isn't spectacular\nfor bootstrap (~2.5%) but single cases see up to a 10% reduction.\n\nThe same function can be used to optimize var-tracking iteration order\nas seen in the followup.\n\n2020-07-28  Richard Biener  <rguenther@suse.de>\n\n\t* cfganal.h (rev_post_order_and_mark_dfs_back_seme): Adjust\n\tprototype.\n\t* cfganal.c (rpoamdbs_bb_data): New struct with pre BB data.\n\t(tag_header): New helper.\n\t(cmp_edge_dest_pre): Likewise.\n\t(rev_post_order_and_mark_dfs_back_seme): Compute SCCs,\n\tfind SCC exits and perform a DFS walk with extra edges to\n\tcompute a RPO with adjacent SCC members when requesting an\n\titeration optimized order and populate the toplevel SCC array.\n\t* tree-ssa-sccvn.c (do_rpo_vn): Remove ad-hoc computation\n\tof max_rpo and fill it in from SCC extent info instead.\n\n\t* gcc.dg/torture/20200727-0.c: New testcase.", "tree": {"sha": "c28522ecf41ebd90d07a65fafb9c2c264fc6a030", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c28522ecf41ebd90d07a65fafb9c2c264fc6a030"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e61a2056335ca7d4e2009823efae4ee2dc950ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e61a2056335ca7d4e2009823efae4ee2dc950ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e61a2056335ca7d4e2009823efae4ee2dc950ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e61a2056335ca7d4e2009823efae4ee2dc950ee/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c00059ce058ea2aec2933319e270f5443b8b909", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c00059ce058ea2aec2933319e270f5443b8b909", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c00059ce058ea2aec2933319e270f5443b8b909"}], "stats": {"total": 573, "additions": 451, "deletions": 122}, "files": [{"sha": "24ae41bcac523757bc771cd5d7974e2240ab7720", "filename": "gcc/cfganal.c", "status": "modified", "additions": 356, "deletions": 77, "changes": 433, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e61a2056335ca7d4e2009823efae4ee2dc950ee/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e61a2056335ca7d4e2009823efae4ee2dc950ee/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=3e61a2056335ca7d4e2009823efae4ee2dc950ee", "patch": "@@ -1060,110 +1060,389 @@ pre_and_rev_post_order_compute (int *pre_order, int *rev_post_order,\n   return pre_order_num;\n }\n \n-/* Unlike pre_and_rev_post_order_compute we fill rev_post_order backwards\n-   so iterating in RPO order needs to start with rev_post_order[n - 1]\n-   going to rev_post_order[0].  If FOR_ITERATION is true then try to\n-   make CFG cycles fit into small contiguous regions of the RPO order.\n-   When FOR_ITERATION is true this requires up-to-date loop structures.  */\n+\n+/* Per basic-block data for rev_post_order_and_mark_dfs_back_seme,\n+   element of a sparsely populated array indexed by basic-block number.  */\n+typedef auto_vec<int, 2> scc_exit_vec_t;\n+struct rpoamdbs_bb_data {\n+    int depth;\n+    int bb_to_pre;\n+    /* The basic-block index of the SCC entry of the block visited first\n+       (the SCC leader).  */\n+    int scc;\n+    /* The index into the RPO array where the blocks SCC entries end\n+       (only valid for the SCC leader).  */\n+    int scc_end;\n+    /* The indexes of the exits destinations of this SCC (only valid\n+       for the SCC leader).  Initialized upon discovery of SCC leaders.  */\n+    scc_exit_vec_t scc_exits;\n+};\n+\n+/* Tag H as a header of B, weaving H and its loop header list into the\n+   current loop header list of B.  */\n+\n+static void\n+tag_header (int b, int h, rpoamdbs_bb_data *bb_data)\n+{\n+  if (h == -1 || b == h)\n+    return;\n+  int cur1 = b;\n+  int cur2 = h;\n+  while (bb_data[cur1].scc != -1)\n+    {\n+      int ih = bb_data[cur1].scc;\n+      if (ih == cur2)\n+\treturn;\n+      if (bb_data[ih].depth < bb_data[cur2].depth)\n+\t{\n+\t  bb_data[cur1].scc = cur2;\n+\t  cur1 = cur2;\n+\t  cur2 = ih;\n+\t}\n+      else\n+\tcur1 = ih;\n+    }\n+  bb_data[cur1].scc = cur2;\n+}\n+\n+/* Comparator for a sort of two edges destinations E1 and E2 after their index\n+   in the PRE array as specified by BB_TO_PRE.  */\n+\n+static int\n+cmp_edge_dest_pre (const void *e1_, const void *e2_, void *data_)\n+{\n+  const int *e1 = (const int *)e1_;\n+  const int *e2 = (const int *)e2_;\n+  rpoamdbs_bb_data *bb_data = (rpoamdbs_bb_data *)data_;\n+  return (bb_data[*e1].bb_to_pre - bb_data[*e2].bb_to_pre);\n+}\n+\n+/* Compute the reverse completion number of a depth first search\n+   on the SEME region denoted by the ENTRY edge and the EXIT_BBS set of\n+   exit block indexes and store it in the array REV_POST_ORDER.\n+   Also sets the EDGE_DFS_BACK edge flags according to this visitation\n+   order.\n+   Returns the number of nodes visited.\n+\n+   In case the function has unreachable blocks the number of nodes\n+   visited does not include them.\n+\n+   If FOR_ITERATION is true then compute an RPO where SCCs form a\n+   contiguous region in the RPO array.\n+   *TOPLEVEL_SCC_EXTENTS if not NULL is filled with pairs of\n+   *REV_POST_ORDER indexes denoting extents of the toplevel SCCs in\n+   this region.  */\n \n int\n rev_post_order_and_mark_dfs_back_seme (struct function *fn, edge entry,\n \t\t\t\t       bitmap exit_bbs, bool for_iteration,\n-\t\t\t\t       int *rev_post_order)\n+\t\t\t\t       int *rev_post_order,\n+\t\t\t\t       vec<std::pair<int, int> >\n+\t\t\t\t\t *toplevel_scc_extents)\n {\n-  int pre_order_num = 0;\n   int rev_post_order_num = 0;\n \n-  /* Allocate stack for back-tracking up CFG.  Worst case we need\n-     O(n^2) edges but the following should suffice in practice without\n-     a need to re-allocate.  */\n-  auto_vec<edge, 20> stack (2 * n_basic_blocks_for_fn (fn));\n-\n-  int *pre = XNEWVEC (int, last_basic_block_for_fn (fn));\n-\n   /* BB flag to track nodes that have been visited.  */\n   auto_bb_flag visited (fn);\n-  /* BB flag to track which nodes have postorder visting completed.  Used\n-     for backedge marking.  */\n-  auto_bb_flag post_assigned (fn);\n-\n-  /* Push the first edge on to the stack.  */\n-  stack.quick_push (entry);\n \n-  while (!stack.is_empty ())\n-    {\n-      basic_block src;\n-      basic_block dest;\n+  /* Lazily initialized per-BB data for the two DFS walks below.  */\n+  rpoamdbs_bb_data *bb_data\n+    = XNEWVEC (rpoamdbs_bb_data, last_basic_block_for_fn (fn));\n \n-      /* Look at the edge on the top of the stack.  */\n-      int idx = stack.length () - 1;\n-      edge e = stack[idx];\n-      src = e->src;\n-      dest = e->dest;\n-      e->flags &= ~EDGE_DFS_BACK;\n+  /* First DFS walk, loop discovery according to\n+      A New Algorithm for Identifying Loops in Decompilation\n+     by Tao Wei, Jian Mao, Wei Zou and You Chen of the Institute of\n+     Computer Science and Technology of the Peking University.  */\n+  auto_vec<edge_iterator, 20> ei_stack (n_basic_blocks_for_fn (fn) + 1);\n+  auto_bb_flag is_header (fn);\n+  int depth = 1;\n+  unsigned n_sccs = 0;\n \n-      /* Check if the edge destination has been visited yet.  */\n-      if (! bitmap_bit_p (exit_bbs, dest->index)\n-\t  && ! (dest->flags & visited))\n+  basic_block dest = entry->dest;\n+  edge_iterator ei;\n+  int pre_num = 0;\n+\n+  /* DFS process DEST.  */\n+find_loops:\n+  bb_data[dest->index].bb_to_pre = pre_num++;\n+  bb_data[dest->index].depth = depth;\n+  bb_data[dest->index].scc = -1;\n+  depth++;\n+  gcc_assert ((dest->flags & (is_header|visited)) == 0);\n+  dest->flags |= visited;\n+  ei = ei_start (dest->succs);\n+  while (!ei_end_p (ei))\n+    {\n+      ei_edge (ei)->flags &= ~EDGE_DFS_BACK;\n+      if (bitmap_bit_p (exit_bbs, ei_edge (ei)->dest->index))\n+\t;\n+      else if (!(ei_edge (ei)->dest->flags & visited))\n \t{\n-\t  /* Mark that we have visited the destination.  */\n-\t  dest->flags |= visited;\n-\n-\t  pre[dest->index] = pre_order_num++;\n-\n-\t  if (EDGE_COUNT (dest->succs) > 0)\n+\t  ei_stack.quick_push (ei);\n+\t  dest = ei_edge (ei)->dest;\n+\t  /* DFS recurse on DEST.  */\n+\t  goto find_loops;\n+\n+ret_from_find_loops:\n+\t  /* Return point of DFS recursion.  */\n+\t  ei = ei_stack.pop ();\n+\t  dest = ei_edge (ei)->src;\n+\t  int header = bb_data[ei_edge (ei)->dest->index].scc;\n+\t  tag_header (dest->index, header, bb_data);\n+\t  depth = bb_data[dest->index].depth + 1;\n+\t}\n+      else\n+\t{\n+\t  if (bb_data[ei_edge (ei)->dest->index].depth > 0) /* on the stack */\n \t    {\n-\t      /* Since the DEST node has been visited for the first\n-\t\t time, check its successors.  */\n-\t      /* Push the edge vector in reverse to match previous behavior.  */\n-\t      stack.reserve (EDGE_COUNT (dest->succs));\n-\t      for (int i = EDGE_COUNT (dest->succs) - 1; i >= 0; --i)\n-\t\tstack.quick_push (EDGE_SUCC (dest, i));\n-\t      /* Generalize to handle more successors?  */\n-\t      if (for_iteration\n-\t\t  && EDGE_COUNT (dest->succs) == 2)\n-\t\t{\n-\t\t  edge &e1 = stack[stack.length () - 2];\n-\t\t  if (loop_exit_edge_p (e1->src->loop_father, e1))\n-\t\t    std::swap (e1, stack.last ());\n-\t\t}\n+\t      ei_edge (ei)->flags |= EDGE_DFS_BACK;\n+\t      n_sccs++;\n+\t      ei_edge (ei)->dest->flags |= is_header;\n+\t      ::new (&bb_data[ei_edge (ei)->dest->index].scc_exits)\n+\t\tauto_vec<int, 2> ();\n+\t      tag_header (dest->index, ei_edge (ei)->dest->index, bb_data);\n \t    }\n+\t  else if (bb_data[ei_edge (ei)->dest->index].scc == -1)\n+\t    ;\n \t  else\n \t    {\n-\t      /* There are no successors for the DEST node so assign\n-\t\t its reverse completion number.  */\n-\t      dest->flags |= post_assigned;\n-\t      rev_post_order[rev_post_order_num] = dest->index;\n-\t      rev_post_order_num++;\n+\t      int header = bb_data[ei_edge (ei)->dest->index].scc;\n+\t      if (bb_data[header].depth > 0)\n+\t\ttag_header (dest->index, header, bb_data);\n+\t      else\n+\t\t{\n+\t\t  /* A re-entry into an existing loop.  */\n+\t\t  /* ???  Need to mark is_header?  */\n+\t\t  while (bb_data[header].scc != -1)\n+\t\t    {\n+\t\t      header = bb_data[header].scc;\n+\t\t      if (bb_data[header].depth > 0)\n+\t\t\t{\n+\t\t\t  tag_header (dest->index, header, bb_data);\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n \t    }\n \t}\n-      else\n-\t{\n-\t  if (dest->flags & visited\n-\t      && !(dest->flags & post_assigned)\n-\t      && src != entry->src\n-\t      && pre[src->index] >= pre[dest->index])\n-\t    e->flags |= EDGE_DFS_BACK;\n+      ei_next (&ei);\n+    }\n+  rev_post_order[rev_post_order_num++] = dest->index;\n+  /* not on the stack anymore */\n+  bb_data[dest->index].depth = -bb_data[dest->index].depth;\n+  if (!ei_stack.is_empty ())\n+    /* Return from DFS recursion.  */\n+    goto ret_from_find_loops;\n+\n+  /* Optimize for no SCCs found or !for_iteration.  */\n+  if (n_sccs == 0 || !for_iteration)\n+    {\n+      /* Clear the temporarily allocated flags.  */\n+      for (int i = 0; i < rev_post_order_num; ++i)\n+\tBASIC_BLOCK_FOR_FN (fn, rev_post_order[i])->flags\n+\t  &= ~(is_header|visited);\n+      /* And swap elements.  */\n+      for (int i = 0; i < rev_post_order_num/2; ++i)\n+\tstd::swap (rev_post_order[i], rev_post_order[rev_post_order_num-i-1]);\n+      XDELETEVEC (bb_data);\n+\n+      return rev_post_order_num;\n+    }\n \n-\t  if (idx != 0 && stack[idx - 1]->src != src)\n+  /* Next find SCC exits, clear the visited flag and compute an upper bound\n+     for the edge stack below.  */\n+  unsigned edge_count = 0;\n+  for (int i = 0; i < rev_post_order_num; ++i)\n+    {\n+      int bb = rev_post_order[i];\n+      BASIC_BLOCK_FOR_FN (fn, bb)->flags &= ~visited;\n+      edge e;\n+      FOR_EACH_EDGE (e, ei, BASIC_BLOCK_FOR_FN (fn, bb)->succs)\n+\t{\n+\t  if (bitmap_bit_p (exit_bbs, e->dest->index))\n+\t    continue;\n+\t  edge_count++;\n+\t  /* if e is an exit from e->src, record it for\n+\t     bb_data[e->src].scc.  */\n+\t  int src_scc = e->src->index;\n+\t  if (!(e->src->flags & is_header))\n+\t    src_scc = bb_data[src_scc].scc;\n+\t  if (src_scc == -1)\n+\t    continue;\n+\t  int dest_scc = e->dest->index;\n+\t  if (!(e->dest->flags & is_header))\n+\t    dest_scc = bb_data[dest_scc].scc;\n+\t  if (src_scc == dest_scc)\n+\t    continue;\n+\t  /* When dest_scc is nested insde src_scc it's not an\n+\t     exit.  */\n+\t  int tem_dest_scc = dest_scc;\n+\t  unsigned dest_scc_depth = 0;\n+\t  while (tem_dest_scc != -1)\n \t    {\n-\t      /* There are no more successors for the SRC node\n-\t\t so assign its reverse completion number.  */\n-\t      src->flags |= post_assigned;\n-\t      rev_post_order[rev_post_order_num] = src->index;\n-\t      rev_post_order_num++;\n+\t      dest_scc_depth++;\n+\t      if ((tem_dest_scc = bb_data[tem_dest_scc].scc) == src_scc)\n+\t\tbreak;\n+\t    }\n+\t  if (tem_dest_scc != -1)\n+\t    continue;\n+\t  /* When src_scc is nested inside dest_scc record an\n+\t     exit from the outermost SCC this edge exits.  */\n+\t  int tem_src_scc = src_scc;\n+\t  unsigned src_scc_depth = 0;\n+\t  while (tem_src_scc != -1)\n+\t    {\n+\t      if (bb_data[tem_src_scc].scc == dest_scc)\n+\t\t{\n+\t\t  edge_count++;\n+\t\t  bb_data[tem_src_scc].scc_exits.safe_push (e->dest->index);\n+\t\t  break;\n+\t\t}\n+\t      tem_src_scc = bb_data[tem_src_scc].scc;\n+\t      src_scc_depth++;\n+\t    }\n+\t  /* Else find the outermost SCC this edge exits (exits\n+\t     from the inner SCCs are not important for the DFS\n+\t     walk adjustment).  Do so by computing the common\n+\t     ancestor SCC where the immediate child it to the source\n+\t     SCC is the exited SCC.  */\n+\t  if (tem_src_scc == -1)\n+\t    {\n+\t      edge_count++;\n+\t      while (src_scc_depth > dest_scc_depth)\n+\t\t{\n+\t\t  src_scc = bb_data[src_scc].scc;\n+\t\t  src_scc_depth--;\n+\t\t}\n+\t      while (dest_scc_depth > src_scc_depth)\n+\t\t{\n+\t\t  dest_scc = bb_data[dest_scc].scc;\n+\t\t  dest_scc_depth--;\n+\t\t}\n+\t      while (bb_data[src_scc].scc != bb_data[dest_scc].scc)\n+\t\t{\n+\t\t  src_scc = bb_data[src_scc].scc;\n+\t\t  dest_scc = bb_data[dest_scc].scc;\n+\t\t}\n+\t      bb_data[src_scc].scc_exits.safe_push (e->dest->index);\n \t    }\n-\n-\t  stack.pop ();\n \t}\n     }\n \n-  XDELETEVEC (pre);\n+  /* Now the second DFS walk to compute a RPO where the extent of SCCs\n+     is minimized thus SCC members are adjacent in the RPO array.\n+     This is done by performing a DFS walk computing RPO with first visiting\n+     extra direct edges from SCC entry to its exits.\n+     That simulates a DFS walk over the graph with SCCs collapsed and\n+     walking the SCCs themselves only when all outgoing edges from the\n+     SCCs have been visited.\n+     SCC_END[scc-header-index] is the position in the RPO array of the\n+     last member of the SCC.  */\n+  auto_vec<std::pair<basic_block, basic_block>, 20> estack (edge_count + 1);\n+  int idx = rev_post_order_num;\n+  basic_block edest;\n+  dest = entry->dest;\n+\n+  /* DFS process DEST.  */\n+dfs_rpo:\n+  gcc_checking_assert ((dest->flags & visited) == 0);\n+  /* Verify we enter SCCs through the same header and SCC nesting appears\n+     the same.  */\n+  gcc_assert (bb_data[dest->index].scc == -1\n+\t      || (BASIC_BLOCK_FOR_FN (fn, bb_data[dest->index].scc)->flags\n+\t\t  & visited));\n+  dest->flags |= visited;\n+  bb_data[dest->index].scc_end = -1;\n+  if ((dest->flags & is_header)\n+      && !bb_data[dest->index].scc_exits.is_empty ())\n+    {\n+      /* Push the all SCC exits as outgoing edges from its header to\n+\t be visited first.\n+\t To process exits in the same relative order as in the first\n+\t DFS walk sort them after their destination PRE order index.  */\n+      gcc_sort_r (&bb_data[dest->index].scc_exits[0],\n+\t\t  bb_data[dest->index].scc_exits.length (),\n+\t\t  sizeof (int), cmp_edge_dest_pre, bb_data);\n+      /* Process edges in reverse to match previous DFS walk order.  */\n+      for (int i = bb_data[dest->index].scc_exits.length () - 1; i >= 0; --i)\n+\testack.quick_push (std::make_pair\n+\t  (dest, BASIC_BLOCK_FOR_FN (fn, bb_data[dest->index].scc_exits[i])));\n+    }\n+  else\n+    {\n+      if (dest->flags & is_header)\n+\tbb_data[dest->index].scc_end = idx - 1;\n+      /* Push the edge vector in reverse to match the iteration order\n+\t from the DFS walk above.  */\n+      for (int i = EDGE_COUNT (dest->succs) - 1; i >= 0; --i)\n+\tif (!bitmap_bit_p (exit_bbs, EDGE_SUCC (dest, i)->dest->index))\n+\t  estack.quick_push (std::make_pair (dest,\n+\t\t\t\t\t     EDGE_SUCC (dest, i)->dest));\n+    }\n+  while (!estack.is_empty ()\n+\t && estack.last ().first == dest)\n+    {\n+      edest = estack.last ().second;\n+      if (!(edest->flags & visited))\n+\t{\n+\t  dest = edest;\n+\t  /* DFS recurse on DEST.  */\n+\t  goto dfs_rpo;\n \n-  /* Clear the temporarily allocated flags.  */\n+ret_from_dfs_rpo:\n+\t  /* Return point of DFS recursion.  */\n+\t  dest = estack.last ().first;\n+\t}\n+      estack.pop ();\n+      /* If we processed all SCC exits from DEST mark the SCC end\n+\t since all RPO entries up to DEST itself will now belong\n+\t to its SCC.  The special-case of no SCC exits is already\n+\t dealt with above.  */\n+      if (dest->flags & is_header\n+\t  /* When the last exit edge was processed mark the SCC end\n+\t     and push the regular edges.  */\n+\t  && bb_data[dest->index].scc_end == -1\n+\t  && (estack.is_empty ()\n+\t      || estack.last ().first != dest))\n+\t{\n+\t  bb_data[dest->index].scc_end = idx - 1;\n+\t  /* Push the edge vector in reverse to match the iteration order\n+\t     from the DFS walk above.  */\n+\t  for (int i = EDGE_COUNT (dest->succs) - 1; i >= 0; --i)\n+\t    if (!bitmap_bit_p (exit_bbs, EDGE_SUCC (dest, i)->dest->index))\n+\t      estack.quick_push (std::make_pair (dest,\n+\t\t\t\t\t\t EDGE_SUCC (dest, i)->dest));\n+\t}\n+    }\n+  rev_post_order[--idx] = dest->index;\n+  if (!estack.is_empty ())\n+    /* Return from DFS recursion.  */\n+    goto ret_from_dfs_rpo;\n+\n+  /* Each SCC extends are from the position of the header inside\n+     the RPO array up to RPO array index scc_end[header-index].  */\n+  if (toplevel_scc_extents)\n+    for (int i = 0; i < rev_post_order_num; i++)\n+      {\n+\tbasic_block bb = BASIC_BLOCK_FOR_FN (fn, rev_post_order[i]);\n+\tif (bb->flags & is_header)\n+\t  {\n+\t    toplevel_scc_extents->safe_push\n+\t      (std::make_pair (i, bb_data[bb->index].scc_end));\n+\t    i = bb_data[bb->index].scc_end;\n+\t  }\n+      }\n+\n+  /* Clear the temporarily allocated flags and free memory.  */\n   for (int i = 0; i < rev_post_order_num; ++i)\n-    BASIC_BLOCK_FOR_FN (fn, rev_post_order[i])->flags\n-      &= ~(post_assigned|visited);\n+    {\n+      basic_block bb = BASIC_BLOCK_FOR_FN (fn, rev_post_order[i]);\n+      if (bb->flags & is_header)\n+\tbb_data[bb->index].scc_exits.~scc_exit_vec_t ();\n+      bb->flags &= ~(visited|is_header);\n+    }\n+\n+  XDELETEVEC (bb_data);\n \n   return rev_post_order_num;\n }"}, {"sha": "06830b7f4692b05383c3d61f5987576464e49585", "filename": "gcc/cfganal.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e61a2056335ca7d4e2009823efae4ee2dc950ee/gcc%2Fcfganal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e61a2056335ca7d4e2009823efae4ee2dc950ee/gcc%2Fcfganal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.h?ref=3e61a2056335ca7d4e2009823efae4ee2dc950ee", "patch": "@@ -68,7 +68,8 @@ extern int pre_and_rev_post_order_compute_fn (struct function *,\n \t\t\t\t\t      int *, int *, bool);\n extern int pre_and_rev_post_order_compute (int *, int *, bool);\n extern int rev_post_order_and_mark_dfs_back_seme (struct function *, edge,\n-\t\t\t\t\t\t  bitmap, bool, int *);\n+\t\t\t\t\t\t  bitmap, bool, int *,\n+\t\t\t\t\t\t  vec<std::pair<int, int> > *);\n extern int dfs_enumerate_from (basic_block, int,\n \t\t\t       bool (*)(const_basic_block, const void *),\n \t\t\t       basic_block *, int, const void *);"}, {"sha": "ab915687b3086fa251bd45d82ff6683891a71343", "filename": "gcc/testsuite/gcc.dg/torture/20200727-0.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e61a2056335ca7d4e2009823efae4ee2dc950ee/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20200727-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e61a2056335ca7d4e2009823efae4ee2dc950ee/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20200727-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20200727-0.c?ref=3e61a2056335ca7d4e2009823efae4ee2dc950ee", "patch": "@@ -0,0 +1,82 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-g\" } */\n+\n+typedef long unsigned int size_t;\n+typedef signed int __int32_t;\n+typedef __int32_t int32_t;\n+typedef long int ptrdiff_t;\n+typedef enum {\n+  BT_UNKNOWN = 0, BT_INTEGER, BT_LOGICAL, BT_REAL, BT_COMPLEX,   BT_DERIVED, BT_CHARACTER, BT_CLASS, BT_PROCEDURE, BT_HOLLERITH, BT_VOID,   BT_ASSUMED, BT_UNION, BT_BOZ } bt;\n+typedef int32_t GFC_INTEGER_4;\n+typedef ptrdiff_t index_type;\n+typedef size_t gfc_charlen_type;\n+typedef struct descriptor_dimension {\n+    index_type _stride;\n+    index_type lower_bound;\n+  } descriptor_dimension;\n+typedef struct {\n+  descriptor_dimension dim[15];\n+ } gfc_full_array_i4;\n+typedef void (*formatted_dtio)(void *, GFC_INTEGER_4 *, char *,           gfc_full_array_i4 *,           GFC_INTEGER_4 *, char *,           gfc_charlen_type, gfc_charlen_type);\n+typedef enum { DECIMAL_POINT, DECIMAL_COMMA, DECIMAL_UNSPECIFIED } unit_decimal;\n+typedef struct st_parameter_dt {\n+      union     {\n+\t  struct  {\n+\t      struct gfc_unit *current_unit;\n+\t      unsigned namelist_mode : 1;\n+\t      unsigned unit_is_internal : 1;\n+\t      formatted_dtio fdtio_ptr;\n+\t  } p;\n+      } u;\n+  } st_parameter_dt;\n+typedef struct gfc_unit {\n+    int unit_number;\n+    unit_decimal decimal_status;\n+    int (*next_char_fn_ptr) (st_parameter_dt *);\n+    void (*push_char_fn_ptr) (st_parameter_dt *, int);\n+  } gfc_unit;\n+void read_real (st_parameter_dt *dtp)\n+{\n+  int c;\n+  int seen_dp;\n+  seen_dp = 0;\n+  for (;;)\n+    {\n+      c = ((dtp)->u.p.current_unit->next_char_fn_ptr (dtp));\n+      if (c == ',' && dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA)\n+\tc = '.';\n+      switch (c)  {\n+\tcase '.':\n+\t  if (seen_dp)      goto bad_real;\n+\t  seen_dp = 1;\n+\t  ((dtp)->u.p.current_unit->push_char_fn_ptr (dtp, c));\n+\t  goto real_loop;\n+\tcase 'E':\n+\tcase 'e':\n+\tcase 'D':\n+\tcase 'd':\n+\tcase 'Q':\n+\tcase 'q':\n+\t     goto exp1;\n+\tcase '+':\n+\tcase '-':\n+\t     ((dtp)->u.p.current_unit->push_char_fn_ptr (dtp, 'e'));\n+\t     goto got_repeat;\n+      }\n+    }\n+got_repeat:\n+real_loop:\n+  for (;;)\n+    {\n+      c = ((dtp)->u.p.current_unit->next_char_fn_ptr (dtp));\n+      switch (c)  {\n+\tcase '.':\n+\t  if (seen_dp)      goto bad_real;\n+\t  seen_dp = 1;\n+\t  ((dtp)->u.p.current_unit->push_char_fn_ptr (dtp, c));\n+      }\n+    }\n+exp1:\n+bad_real:\n+  return;\n+}"}, {"sha": "2e925a1afbfdaac8404c3c7f54b22a716757e5e8", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 11, "deletions": 44, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e61a2056335ca7d4e2009823efae4ee2dc950ee/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e61a2056335ca7d4e2009823efae4ee2dc950ee/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=3e61a2056335ca7d4e2009823efae4ee2dc950ee", "patch": "@@ -7332,11 +7332,9 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,\n     e->flags &= ~EDGE_DFS_BACK;\n \n   int *rpo = XNEWVEC (int, n_basic_blocks_for_fn (fn) - NUM_FIXED_BLOCKS);\n+  auto_vec<std::pair<int, int> > toplevel_scc_extents;\n   int n = rev_post_order_and_mark_dfs_back_seme\n-    (fn, entry, exit_bbs, !loops_state_satisfies_p (LOOPS_NEED_FIXUP), rpo);\n-  /* rev_post_order_and_mark_dfs_back_seme fills RPO in reverse order.  */\n-  for (int i = 0; i < n / 2; ++i)\n-    std::swap (rpo[i], rpo[n-i-1]);\n+    (fn, entry, exit_bbs, true, rpo, !iterate ? &toplevel_scc_extents : NULL);\n \n   if (!do_region)\n     BITMAP_FREE (exit_bbs);\n@@ -7414,12 +7412,20 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,\n   vn_valueize = rpo_vn_valueize;\n \n   /* Initialize the unwind state and edge/BB executable state.  */\n-  bool need_max_rpo_iterate = false;\n+  unsigned curr_scc = 0;\n   for (int i = 0; i < n; ++i)\n     {\n       basic_block bb = BASIC_BLOCK_FOR_FN (fn, rpo[i]);\n       rpo_state[i].visited = 0;\n       rpo_state[i].max_rpo = i;\n+      if (!iterate && curr_scc < toplevel_scc_extents.length ())\n+\t{\n+\t  if (i >= toplevel_scc_extents[curr_scc].first\n+\t      && i <= toplevel_scc_extents[curr_scc].second)\n+\t    rpo_state[i].max_rpo = toplevel_scc_extents[curr_scc].second;\n+\t  if (i == toplevel_scc_extents[curr_scc].second)\n+\t    curr_scc++;\n+\t}\n       bb->flags &= ~BB_EXECUTABLE;\n       bool has_backedges = false;\n       edge e;\n@@ -7431,51 +7437,12 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,\n \t  e->flags &= ~EDGE_EXECUTABLE;\n \t  if (iterate || e == entry || (skip_entry_phis && bb == entry->dest))\n \t    continue;\n-\t  if (bb_to_rpo[e->src->index] > i)\n-\t    {\n-\t      rpo_state[i].max_rpo = MAX (rpo_state[i].max_rpo,\n-\t\t\t\t\t  bb_to_rpo[e->src->index]);\n-\t      need_max_rpo_iterate = true;\n-\t    }\n-\t  else\n-\t    rpo_state[i].max_rpo\n-\t      = MAX (rpo_state[i].max_rpo,\n-\t\t     rpo_state[bb_to_rpo[e->src->index]].max_rpo);\n \t}\n       rpo_state[i].iterate = iterate && has_backedges;\n     }\n   entry->flags |= EDGE_EXECUTABLE;\n   entry->dest->flags |= BB_EXECUTABLE;\n \n-  /* When there are irreducible regions the simplistic max_rpo computation\n-     above for the case of backedges doesn't work and we need to iterate\n-     until there are no more changes.  */\n-  unsigned nit = 0;\n-  while (need_max_rpo_iterate)\n-    {\n-      nit++;\n-      need_max_rpo_iterate = false;\n-      for (int i = 0; i < n; ++i)\n-\t{\n-\t  basic_block bb = BASIC_BLOCK_FOR_FN (fn, rpo[i]);\n-\t  edge e;\n-\t  edge_iterator ei;\n-\t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t    {\n-\t      if (e == entry || (skip_entry_phis && bb == entry->dest))\n-\t\tcontinue;\n-\t      int max_rpo = MAX (rpo_state[i].max_rpo,\n-\t\t\t\t rpo_state[bb_to_rpo[e->src->index]].max_rpo);\n-\t      if (rpo_state[i].max_rpo != max_rpo)\n-\t\t{\n-\t\t  rpo_state[i].max_rpo = max_rpo;\n-\t\t  need_max_rpo_iterate = true;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-  statistics_histogram_event (cfun, \"RPO max_rpo iterations\", nit);\n-\n   /* As heuristic to improve compile-time we handle only the N innermost\n      loops and the outermost one optimistically.  */\n   if (iterate)"}]}