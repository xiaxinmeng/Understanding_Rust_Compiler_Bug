{"sha": "6ffd1096cf7620eea04f99693c32601e9312cd8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZmZDEwOTZjZjc2MjBlZWEwNGY5OTY5M2MzMjYwMWU5MzEyY2Q4Yw==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2013-08-06T11:11:07Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2013-08-06T11:11:07Z"}, "message": "2013-08-06  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tRevert the last commit.\n\nFrom-SVN: r201525", "tree": {"sha": "3c9561fad773cc60d0dc75e574995341720a90ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c9561fad773cc60d0dc75e574995341720a90ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ffd1096cf7620eea04f99693c32601e9312cd8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ffd1096cf7620eea04f99693c32601e9312cd8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ffd1096cf7620eea04f99693c32601e9312cd8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ffd1096cf7620eea04f99693c32601e9312cd8c/comments", "author": null, "committer": null, "parents": [{"sha": "78f6dd686219c887085d40b3dacfb7f1a96aad95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78f6dd686219c887085d40b3dacfb7f1a96aad95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78f6dd686219c887085d40b3dacfb7f1a96aad95"}], "stats": {"total": 608, "additions": 318, "deletions": 290}, "files": [{"sha": "66cbccc2c91e97a2ff23043217a1c4e3553ed12d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ffd1096cf7620eea04f99693c32601e9312cd8c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ffd1096cf7620eea04f99693c32601e9312cd8c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=6ffd1096cf7620eea04f99693c32601e9312cd8c", "patch": "@@ -1,3 +1,7 @@\n+2013-08-06  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tRevert the last commit.\n+\n 2013-08-06  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \n \t* include/bits/hashtable_policy.h (_Hashtable_alloc): New."}, {"sha": "44ce3b30ef8d64f9e07d1328abb8ea9f69afa900", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 243, "deletions": 106, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ffd1096cf7620eea04f99693c32601e9312cd8c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ffd1096cf7620eea04f99693c32601e9312cd8c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=6ffd1096cf7620eea04f99693c32601e9312cd8c", "patch": "@@ -103,7 +103,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  Each _Hashtable data structure has:\n    *\n    *  - _Bucket[]       _M_buckets\n-   *  - _Hash_node_base _M_before_begin\n+   *  - _Hash_node_base _M_bbegin\n    *  - size_type       _M_bucket_count\n    *  - size_type       _M_element_count\n    *\n@@ -181,26 +181,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       public __detail::_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t\t\t    _H1, _H2, _Hash, _RehashPolicy, _Traits>,\n       public __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>,\n-      private __detail::_Hashtable_alloc<\n-\ttypename __alloctr_rebind<_Alloc,\n-\t  __detail::_Hash_node<_Value,\n-\t\t\t       _Traits::__hash_cached::value> >::__type>\n+\t\t\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>\n     {\n-      using __traits_type = _Traits;\n-      using __hash_cached = typename __traits_type::__hash_cached;\n-      using __node_type = __detail::_Hash_node<_Value, __hash_cached::value>;\n-      using __node_alloc_type =\n-\ttypename __alloctr_rebind<_Alloc, __node_type>::__type;\n-\n-      using __hashtable_alloc = __detail::_Hashtable_alloc<__node_alloc_type>;\n-\n-      using __value_alloc_traits =\n-\ttypename __hashtable_alloc::__value_alloc_traits;\n-      using __node_alloc_traits =\n-\ttypename __hashtable_alloc::__node_alloc_traits;\n-      using __node_base = typename __hashtable_alloc::__node_base;\n-      using __bucket_type = typename __hashtable_alloc::__bucket_type;\n+      typedef std::allocator_traits<_Alloc> _Alloc_traits;\n+      typedef typename _Alloc_traits::template rebind_alloc<_Value>\n+\t\t\t\t\t\t\t_Value_alloc_type;\n+      typedef __gnu_cxx::__alloc_traits<_Value_alloc_type> _Value_alloc_traits;\n \n     public:\n       typedef _Key\t\t\t\t\t\tkey_type;\n@@ -210,15 +196,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       // mapped_type, if present, comes from _Map_base.\n       // hasher, if present, comes from _Hash_code_base/_Hashtable_base.\n-      typedef typename __value_alloc_traits::pointer\t\tpointer;\n-      typedef typename __value_alloc_traits::const_pointer\tconst_pointer;\n+      typedef typename _Value_alloc_traits::pointer\t\tpointer;\n+      typedef typename _Value_alloc_traits::const_pointer\tconst_pointer;\n       typedef value_type&\t\t\t\t\treference;\n       typedef const value_type&\t\t\t\t\tconst_reference;\n \n     private:\n       using __rehash_type = _RehashPolicy;\n       using __rehash_state = typename __rehash_type::_State;\n \n+      using __traits_type = _Traits;\n+      using __hash_cached = typename __traits_type::__hash_cached;\n       using __constant_iterators = typename __traits_type::__constant_iterators;\n       using __unique_keys = typename __traits_type::__unique_keys;\n \n@@ -233,6 +221,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       using __hash_code_base =  typename __hashtable_base::__hash_code_base;\n       using __hash_code =  typename __hashtable_base::__hash_code;\n+      using __node_type = typename __hashtable_base::__node_type;\n+      using __node_base = typename __hashtable_base::__node_base;\n+      using __bucket_type = typename __hashtable_base::__bucket_type;\n       using __ireturn_type = typename __hashtable_base::__ireturn_type;\n \n       using __map_base = __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey,\n@@ -249,7 +240,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t    _RehashPolicy, _Traits>;\n \n       using __reuse_or_alloc_node_type =\n-\t__detail::_ReuseOrAllocNode<__node_alloc_type>;\n+\t__detail::_ReuseOrAllocNode<_Key, _Value, _Alloc,\n+\t\t\t\t    _ExtractKey, _Equal, _H1, _H2, _Hash,\n+\t\t\t\t    _RehashPolicy, _Traits>;\n \n       // Metaprogramming for picking apart hash caching.\n       template<typename _Cond>\n@@ -316,6 +309,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       bool _Constant_iteratorsa, bool _Unique_keysa>\n \tfriend struct __detail::_Insert;\n \n+      template<typename _Keya, typename _Valuea, typename _Alloca,\n+\t       typename _ExtractKeya, typename _Equala,\n+\t       typename _H1a, typename _H2a, typename _Hasha,\n+\t       typename _RehashPolicya, typename _Traitsa>\n+\tfriend struct __detail::_ReuseOrAllocNode;\n+\n+      template<typename _Keya, typename _Valuea, typename _Alloca,\n+\t       typename _ExtractKeya, typename _Equala,\n+\t       typename _H1a, typename _H2a, typename _Hasha,\n+\t       typename _RehashPolicya, typename _Traitsa>\n+\tfriend struct __detail::_AllocNode;\n+\n     public:\n       using size_type = typename __hashtable_base::size_type;\n       using difference_type = typename __hashtable_base::difference_type;\n@@ -328,20 +333,60 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t   const_local_iterator;\n \n     private:\n+      typedef typename _Alloc_traits::template rebind_alloc<__node_type>\n+\t\t\t\t\t\t\t_Node_alloc_type;\n+      // Use __gnu_cxx to benefit from _S_always_equal and al.\n+      typedef __gnu_cxx::__alloc_traits<_Node_alloc_type> _Node_alloc_traits;\n+\n+      typedef\n+      typename _Alloc_traits::template rebind_alloc<__bucket_type>\n+\t\t\t\t\t\t\t_Bucket_alloc_type;\n+      typedef std::allocator_traits<_Bucket_alloc_type> _Bucket_alloc_traits;\n+\n+      using __before_begin = __detail::_Before_begin<_Node_alloc_type>;\n+\n       __bucket_type*\t\t_M_buckets;\n       size_type\t\t\t_M_bucket_count;\n-      __node_base\t\t_M_before_begin;\n+      __before_begin\t\t_M_bbegin;\n       size_type\t\t\t_M_element_count;\n       _RehashPolicy\t\t_M_rehash_policy;\n \n-      __hashtable_alloc&\n-      _M_base_alloc() { return *this; }\n+      _Node_alloc_type&\n+      _M_node_allocator()\n+      { return _M_bbegin; }\n+\n+      const _Node_alloc_type&\n+      _M_node_allocator() const\n+      { return _M_bbegin; }\n+\n+      __node_base&\n+      _M_before_begin()\n+      { return _M_bbegin._M_node; }\n+\n+      const __node_base&\n+      _M_before_begin() const\n+      { return _M_bbegin._M_node; }\n \n-      using __hashtable_alloc::_M_deallocate_buckets;\n+      template<typename... _Args>\n+\t__node_type*\n+\t_M_allocate_node(_Args&&... __args);\n+\n+      void\n+      _M_deallocate_node(__node_type* __n);\n+\n+      // Deallocate the linked list of nodes pointed to by __n\n+      void\n+      _M_deallocate_nodes(__node_type* __n);\n+\n+      __bucket_type*\n+      _M_allocate_buckets(size_type __n);\n+\n+      void\n+      _M_deallocate_buckets(__bucket_type*, size_type __n);\n \n       void\n       _M_deallocate_buckets()\n-      { this->_M_deallocate_buckets(_M_buckets, _M_bucket_count); }\n+      { _M_deallocate_buckets(_M_buckets, _M_bucket_count); }\n \n       // Gets bucket begin, deals with the fact that non-empty buckets contain\n       // their before begin node.\n@@ -350,7 +395,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       __node_type*\n       _M_begin() const\n-      { return static_cast<__node_type*>(_M_before_begin._M_nxt); }\n+      { return static_cast<__node_type*>(_M_before_begin()._M_nxt); }\n \n       template<typename _NodeGenerator>\n \tvoid\n@@ -432,11 +477,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       _Hashtable&\n       operator=(_Hashtable&& __ht)\n-      noexcept(__node_alloc_traits::_S_nothrow_move())\n+      noexcept(_Node_alloc_traits::_S_nothrow_move())\n       {\n         constexpr bool __move_storage =\n-          __node_alloc_traits::_S_propagate_on_move_assign()\n-          || __node_alloc_traits::_S_always_equal();\n+          _Node_alloc_traits::_S_propagate_on_move_assign()\n+          || _Node_alloc_traits::_S_always_equal();\n         _M_move_assign(std::move(__ht),\n                        integral_constant<bool, __move_storage>());\n \treturn *this;\n@@ -446,7 +491,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       operator=(initializer_list<value_type> __l)\n       {\n \t__reuse_or_alloc_node_type __roan(_M_begin(), *this);\n-\t_M_before_begin._M_nxt = nullptr;\n+\t_M_before_begin()._M_nxt = nullptr;\n \tclear();\n \tthis->_M_insert_range(__l.begin(), __l.end(), __roan);\n \treturn *this;\n@@ -456,7 +501,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       void\n       swap(_Hashtable&)\n-      noexcept(__node_alloc_traits::_S_nothrow_swap());\n+      noexcept(_Node_alloc_traits::_S_nothrow_swap());\n \n       // Basic container operations\n       iterator\n@@ -493,11 +538,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       allocator_type\n       get_allocator() const noexcept\n-      { return allocator_type(this->_M_node_allocator()); }\n+      { return allocator_type(_M_node_allocator()); }\n \n       size_type\n       max_size() const noexcept\n-      { return __node_alloc_traits::max_size(this->_M_node_allocator()); }\n+      { return _Node_alloc_traits::max_size(_M_node_allocator()); }\n \n       // Observers\n       key_equal\n@@ -758,6 +803,101 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n \n   // Definitions of class template _Hashtable's out-of-line member functions.\n+  template<typename _Key, typename _Value,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   typename _Traits>\n+    template<typename... _Args>\n+      typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t\t  _H1, _H2, _Hash, _RehashPolicy, _Traits>::__node_type*\n+      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+      _M_allocate_node(_Args&&... __args)\n+      {\n+\tauto __nptr = _Node_alloc_traits::allocate(_M_node_allocator(), 1);\n+\t__node_type* __n = std::__addressof(*__nptr);\n+\t__try\n+\t  {\n+\t    _Value_alloc_type __a(_M_node_allocator());\n+\t    ::new ((void*)__n) __node_type();\n+\t    _Value_alloc_traits::construct(__a, __n->_M_valptr(),\n+\t\t\t\t\t   std::forward<_Args>(__args)...);\n+\t    return __n;\n+\t  }\n+\t__catch(...)\n+\t  {\n+\t    _Node_alloc_traits::deallocate(_M_node_allocator(), __nptr, 1);\n+\t    __throw_exception_again;\n+\t  }\n+      }\n+\n+  template<typename _Key, typename _Value,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   typename _Traits>\n+    void\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+    _M_deallocate_node(__node_type* __n)\n+    {\n+      typedef typename _Node_alloc_traits::pointer _Ptr;\n+      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);\n+      _Value_alloc_type __a(_M_node_allocator());\n+      _Value_alloc_traits::destroy(__a, __n->_M_valptr());\n+      __n->~__node_type();\n+      _Node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);\n+    }\n+\n+  template<typename _Key, typename _Value,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   typename _Traits>\n+    void\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+    _M_deallocate_nodes(__node_type* __n)\n+    {\n+      while (__n)\n+\t{\n+\t  __node_type* __tmp = __n;\n+\t  __n = __n->_M_next();\n+\t  _M_deallocate_node(__tmp);\n+\t}\n+    }\n+\n+  template<typename _Key, typename _Value,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   typename _Traits>\n+    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy, _Traits>::__bucket_type*\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+    _M_allocate_buckets(size_type __n)\n+    {\n+      _Bucket_alloc_type __alloc(_M_node_allocator());\n+\n+      auto __ptr = _Bucket_alloc_traits::allocate(__alloc, __n);\n+      __bucket_type* __p = std::__addressof(*__ptr);\n+      __builtin_memset(__p, 0, __n * sizeof(__bucket_type));\n+      return __p;\n+    }\n+\n+  template<typename _Key, typename _Value,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   typename _Traits>\n+    void\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+    _M_deallocate_buckets(__bucket_type* __bkts, size_type __n)\n+    {\n+      typedef typename _Bucket_alloc_traits::pointer _Ptr;\n+      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);\n+      _Bucket_alloc_type __alloc(_M_node_allocator());\n+      _Bucket_alloc_traits::deallocate(__alloc, __ptr, __n);\n+    }\n+\n   template<typename _Key, typename _Value,\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n@@ -786,12 +926,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : __hashtable_base(__exk, __h1, __h2, __h, __eq),\n       __map_base(),\n       __rehash_base(),\n-      __hashtable_alloc(__node_alloc_type(__a)),\n+      _M_bbegin(__a),\n       _M_element_count(0),\n       _M_rehash_policy()\n     {\n       _M_bucket_count = _M_rehash_policy._M_next_bkt(__bucket_hint);\n-      _M_buckets = this->_M_allocate_buckets(_M_bucket_count);\n+      _M_buckets = _M_allocate_buckets(_M_bucket_count);\n     }\n \n   template<typename _Key, typename _Value,\n@@ -809,7 +949,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       : __hashtable_base(__exk, __h1, __h2, __h, __eq),\n \t__map_base(),\n \t__rehash_base(),\n-\t__hashtable_alloc(__node_alloc_type(__a)),\n+\t_M_bbegin(__a),\n \t_M_element_count(0),\n \t_M_rehash_policy()\n       {\n@@ -819,7 +959,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    std::max(_M_rehash_policy._M_bkt_for_elements(__nb_elems),\n \t\t     __bucket_hint));\n \n-\t_M_buckets = this->_M_allocate_buckets(_M_bucket_count);\n+\t_M_buckets = _M_allocate_buckets(_M_bucket_count);\n \t__try\n \t  {\n \t    for (; __f != __l; ++__f)\n@@ -847,15 +987,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tif (&__ht == this)\n \t  return *this;\n \n-\tif (__node_alloc_traits::_S_propagate_on_copy_assign())\n+\tif (_Node_alloc_traits::_S_propagate_on_copy_assign())\n \t  {\n \t    auto& __this_alloc = this->_M_node_allocator();\n \t    auto& __that_alloc = __ht._M_node_allocator();\n-\t    if (!__node_alloc_traits::_S_always_equal()\n+\t    if (!_Node_alloc_traits::_S_always_equal()\n \t\t&& __this_alloc != __that_alloc)\n \t      {\n \t\t// Replacement allocator cannot free existing storage.\n-\t\tthis->_M_deallocate_nodes(_M_begin());\n+\t\t_M_deallocate_nodes(_M_begin());\n \t\tif (__builtin_expect(_M_bucket_count != 0, true))\n \t\t  _M_deallocate_buckets();\n \t\t_M_reset();\n@@ -868,7 +1008,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t  {\n \t\t    _M_assign(__ht,\n \t\t\t      [this](const __node_type* __n)\n-\t\t\t      { return this->_M_allocate_node(__n->_M_v()); });\n+\t\t\t      { return _M_allocate_node(__n->_M_v()); });\n \t\t  }\n \t\t__catch(...)\n \t\t  {\n@@ -890,7 +1030,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tif (_M_bucket_count != __ht._M_bucket_count)\n \t  {\n \t    __former_buckets = _M_buckets;\n-\t    _M_buckets = this->_M_allocate_buckets(__ht._M_bucket_count);\n+\t    _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);\n \t    _M_bucket_count = __ht._M_bucket_count;\n \t  }\n \telse\n@@ -903,13 +1043,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    _M_element_count = __ht._M_element_count;\n \t    _M_rehash_policy = __ht._M_rehash_policy;\n \t    __reuse_or_alloc_node_type __roan(_M_begin(), *this);\n-\t    _M_before_begin._M_nxt = nullptr;\n+\t    _M_before_begin()._M_nxt = nullptr;\n \t    _M_assign(__ht, \n \t\t      [&__roan](const __node_type* __n)\n \t\t      { return __roan(__n->_M_v()); });\n \t    if (__former_buckets)\n-\t      this->_M_deallocate_buckets(__former_buckets,\n-\t\t\t\t\t  __former_bucket_count);\n+\t      _M_deallocate_buckets(__former_buckets, __former_bucket_count);\n \t  }\n \t__catch(...)\n \t  {\n@@ -940,20 +1079,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       {\n \t__bucket_type* __buckets = nullptr;\n \tif (!_M_buckets)\n-\t  _M_buckets = __buckets = this->_M_allocate_buckets(_M_bucket_count);\n+\t  _M_buckets = __buckets = _M_allocate_buckets(_M_bucket_count);\n \n \t__try\n \t  {\n-\t    if (!__ht._M_before_begin._M_nxt)\n+\t    if (!__ht._M_before_begin()._M_nxt)\n \t      return;\n \n \t    // First deal with the special first node pointed to by\n \t    // _M_before_begin.\n \t    __node_type* __ht_n = __ht._M_begin();\n \t    __node_type* __this_n = __node_gen(__ht_n);\n \t    this->_M_copy_code(__this_n, __ht_n);\n-\t    _M_before_begin._M_nxt = __this_n;\n-\t    _M_buckets[_M_bucket_index(__this_n)] = &_M_before_begin;\n+\t    _M_before_begin()._M_nxt = __this_n;\n+\t    _M_buckets[_M_bucket_index(__this_n)] = &_M_before_begin();\n \n \t    // Then deal with other nodes.\n \t    __node_base* __prev_n = __this_n;\n@@ -989,7 +1128,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_rehash_policy._M_reset();\n       _M_bucket_count = 0;\n       _M_buckets = nullptr;\n-      _M_before_begin._M_nxt = nullptr;\n+      _M_before_begin()._M_nxt = nullptr;\n       _M_element_count = 0;\n     }\n \n@@ -1002,22 +1141,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_move_assign(_Hashtable&& __ht, std::true_type)\n     {\n-      this->_M_deallocate_nodes(_M_begin());\n+      _M_deallocate_nodes(_M_begin());\n       if (__builtin_expect(_M_bucket_count != 0, true))\n \t_M_deallocate_buckets();\n \n       __hashtable_base::operator=(std::move(__ht));\n       _M_rehash_policy = __ht._M_rehash_policy;\n       _M_buckets = __ht._M_buckets;\n       _M_bucket_count = __ht._M_bucket_count;\n-      _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;\n+      _M_before_begin()._M_nxt = __ht._M_before_begin()._M_nxt;\n       _M_element_count = __ht._M_element_count;\n-      std::__alloc_on_move(this->_M_node_allocator(), __ht._M_node_allocator());\n+      std::__alloc_on_move(_M_node_allocator(), __ht._M_node_allocator());\n \n       // Fix buckets containing the _M_before_begin pointers that can't be\n       // moved.\n       if (_M_begin())\n-\t_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;\n+\t_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin();\n       __ht._M_reset();\n     }\n \n@@ -1030,7 +1169,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_move_assign(_Hashtable&& __ht, std::false_type)\n     {\n-      if (__ht._M_node_allocator() == this->_M_node_allocator())\n+      if (__ht._M_node_allocator() == _M_node_allocator())\n \t_M_move_assign(std::move(__ht), std::true_type());\n       else\n \t{\n@@ -1042,7 +1181,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  if (_M_bucket_count != __ht._M_bucket_count)\n \t    {\n \t      __former_buckets = _M_buckets;\n-\t      _M_buckets = this->_M_allocate_buckets(__ht._M_bucket_count);\n+\t      _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);\n \t      _M_bucket_count = __ht._M_bucket_count;\n \t    }\n \t  else\n@@ -1055,7 +1194,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      _M_element_count = __ht._M_element_count;\n \t      _M_rehash_policy = __ht._M_rehash_policy;\n \t      __reuse_or_alloc_node_type __roan(_M_begin(), *this);\n-\t      _M_before_begin._M_nxt = nullptr;\n+\t      _M_before_begin()._M_nxt = nullptr;\n \t      _M_assign(__ht,\n \t\t\t[&__roan](__node_type* __n)\n \t\t\t{ return __roan(std::move_if_noexcept(__n->_M_v())); });\n@@ -1087,16 +1226,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : __hashtable_base(__ht),\n       __map_base(__ht),\n       __rehash_base(__ht),\n-      __hashtable_alloc(\n-\t__node_alloc_traits::_S_select_on_copy(__ht._M_node_allocator())),\n       _M_buckets(),\n       _M_bucket_count(__ht._M_bucket_count),\n+      _M_bbegin(_Node_alloc_traits::_S_select_on_copy(\n+\t\t__ht._M_node_allocator())),\n       _M_element_count(__ht._M_element_count),\n       _M_rehash_policy(__ht._M_rehash_policy)\n     {\n       _M_assign(__ht,\n \t\t[this](const __node_type* __n)\n-\t\t{ return this->_M_allocate_node(__n->_M_v()); });\n+\t\t{ return _M_allocate_node(__n->_M_v()); });\n     }\n \n   template<typename _Key, typename _Value,\n@@ -1109,17 +1248,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : __hashtable_base(__ht),\n       __map_base(__ht),\n       __rehash_base(__ht),\n-      __hashtable_alloc(std::move(__ht._M_base_alloc())),\n       _M_buckets(__ht._M_buckets),\n       _M_bucket_count(__ht._M_bucket_count),\n-      _M_before_begin(__ht._M_before_begin._M_nxt),\n+      _M_bbegin(std::move(__ht._M_bbegin)),\n       _M_element_count(__ht._M_element_count),\n       _M_rehash_policy(__ht._M_rehash_policy)\n     {\n       // Update, if necessary, bucket pointing to before begin that hasn't\n       // moved.\n       if (_M_begin())\n-\t_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;\n+\t_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin();\n       __ht._M_reset();\n     }\n \n@@ -1133,15 +1271,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : __hashtable_base(__ht),\n       __map_base(__ht),\n       __rehash_base(__ht),\n-      __hashtable_alloc(__node_alloc_type(__a)),\n       _M_buckets(),\n       _M_bucket_count(__ht._M_bucket_count),\n+      _M_bbegin(_Node_alloc_type(__a)),\n       _M_element_count(__ht._M_element_count),\n       _M_rehash_policy(__ht._M_rehash_policy)\n     {\n       _M_assign(__ht,\n \t\t[this](const __node_type* __n)\n-\t\t{ return this->_M_allocate_node(__n->_M_v()); });\n+\t\t{ return _M_allocate_node(__n->_M_v()); });\n     }\n \n   template<typename _Key, typename _Value,\n@@ -1154,28 +1292,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : __hashtable_base(__ht),\n       __map_base(__ht),\n       __rehash_base(__ht),\n-      __hashtable_alloc(__node_alloc_type(__a)),\n       _M_buckets(),\n       _M_bucket_count(__ht._M_bucket_count),\n+      _M_bbegin(_Node_alloc_type(__a)),\n       _M_element_count(__ht._M_element_count),\n       _M_rehash_policy(__ht._M_rehash_policy)\n     {\n-      if (__ht._M_node_allocator() == this->_M_node_allocator())\n+      if (__ht._M_node_allocator() == _M_node_allocator())\n \t{\n \t  _M_buckets = __ht._M_buckets;\n-\t  _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;\n+\t  _M_before_begin()._M_nxt = __ht._M_before_begin()._M_nxt;\n \t  // Update, if necessary, bucket pointing to before begin that hasn't\n \t  // moved.\n \t  if (_M_begin())\n-\t    _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;\n+\t    _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin();\n \t  __ht._M_reset();\n \t}\n       else\n \t{\n \t  _M_assign(__ht,\n \t\t    [this](__node_type* __n)\n \t\t    {\n-\t\t      return this->_M_allocate_node(\n+\t\t      return _M_allocate_node(\n \t\t\t\t\tstd::move_if_noexcept(__n->_M_v()));\n \t\t    });\n \t  __ht.clear();\n@@ -1203,27 +1341,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     swap(_Hashtable& __x)\n-    noexcept(__node_alloc_traits::_S_nothrow_swap())\n+    noexcept(_Node_alloc_traits::_S_nothrow_swap())\n     {\n       // The only base class with member variables is hash_code_base.\n       // We define _Hash_code_base::_M_swap because different\n       // specializations have different members.\n       this->_M_swap(__x);\n \n-      std::__alloc_on_swap(this->_M_node_allocator(), __x._M_node_allocator());\n+      std::__alloc_on_swap(_M_node_allocator(), __x._M_node_allocator());\n       std::swap(_M_rehash_policy, __x._M_rehash_policy);\n       std::swap(_M_buckets, __x._M_buckets);\n       std::swap(_M_bucket_count, __x._M_bucket_count);\n-      std::swap(_M_before_begin._M_nxt, __x._M_before_begin._M_nxt);\n+      std::swap(_M_before_begin()._M_nxt, __x._M_before_begin()._M_nxt);\n       std::swap(_M_element_count, __x._M_element_count);\n \n       // Fix buckets containing the _M_before_begin pointers that can't be\n       // swapped.\n       if (_M_begin())\n-\t_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;\n+\t_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin();\n       if (__x._M_begin())\n \t__x._M_buckets[__x._M_bucket_index(__x._M_begin())]\n-\t  = &__x._M_before_begin;\n+\t  = &(__x._M_before_begin());\n     }\n \n   template<typename _Key, typename _Value,\n@@ -1442,13 +1580,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  // The bucket is empty, the new node is inserted at the\n \t  // beginning of the singly-linked list and the bucket will\n \t  // contain _M_before_begin pointer.\n-\t  __node->_M_nxt = _M_before_begin._M_nxt;\n-\t  _M_before_begin._M_nxt = __node;\n+\t  __node->_M_nxt = _M_before_begin()._M_nxt;\n+\t  _M_before_begin()._M_nxt = __node;\n \t  if (__node->_M_nxt)\n \t    // We must update former begin bucket that is pointing to\n \t    // _M_before_begin.\n \t    _M_buckets[_M_bucket_index(__node->_M_next())] = __node;\n-\t  _M_buckets[__bkt] = &_M_before_begin;\n+\t  _M_buckets[__bkt] = &_M_before_begin();\n \t}\n     }\n \n@@ -1470,8 +1608,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    _M_buckets[__next_bkt] = _M_buckets[__bkt];\n \n \t  // Second update before begin node if necessary\n-\t  if (&_M_before_begin == _M_buckets[__bkt])\n-\t    _M_before_begin._M_nxt = __next;\n+\t  if (&_M_before_begin() == _M_buckets[__bkt])\n+\t    _M_before_begin()._M_nxt = __next;\n \t  _M_buckets[__bkt] = nullptr;\n \t}\n     }\n@@ -1507,7 +1645,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_emplace(std::true_type, _Args&&... __args)\n       {\n \t// First build the node to get access to the hash code\n-\t__node_type* __node = this->_M_allocate_node(std::forward<_Args>(__args)...);\n+\t__node_type* __node = _M_allocate_node(std::forward<_Args>(__args)...);\n \tconst key_type& __k = this->_M_extract()(__node->_M_v());\n \t__hash_code __code;\n \t__try\n@@ -1516,15 +1654,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  }\n \t__catch(...)\n \t  {\n-\t    this->_M_deallocate_node(__node);\n+\t    _M_deallocate_node(__node);\n \t    __throw_exception_again;\n \t  }\n \n \tsize_type __bkt = _M_bucket_index(__k, __code);\n \tif (__node_type* __p = _M_find_node(__bkt, __k, __code))\n \t  {\n \t    // There is already an equivalent node, no insertion\n-\t    this->_M_deallocate_node(__node);\n+\t    _M_deallocate_node(__node);\n \t    return std::make_pair(iterator(__p), false);\n \t  }\n \n@@ -1546,8 +1684,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_emplace(const_iterator __hint, std::false_type, _Args&&... __args)\n       {\n \t// First build the node to get its hash code.\n-\t__node_type* __node =\n-\t  this->_M_allocate_node(std::forward<_Args>(__args)...);\n+\t__node_type* __node = _M_allocate_node(std::forward<_Args>(__args)...);\n \n \t__hash_code __code;\n \t__try\n@@ -1556,7 +1693,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  }\n \t__catch(...)\n \t  {\n-\t    this->_M_deallocate_node(__node);\n+\t    _M_deallocate_node(__node);\n \t    __throw_exception_again;\n \t  }\n \n@@ -1596,7 +1733,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n       __catch(...)\n \t{\n-\t  this->_M_deallocate_node(__node);\n+\t  _M_deallocate_node(__node);\n \t  __throw_exception_again;\n \t}\n     }\n@@ -1662,7 +1799,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n       __catch(...)\n \t{\n-\t  this->_M_deallocate_node(__node);\n+\t  _M_deallocate_node(__node);\n \t  __throw_exception_again;\n \t}\n     }\n@@ -1762,7 +1899,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       __prev_n->_M_nxt = __n->_M_nxt;\n       iterator __result(__n->_M_next());\n-      this->_M_deallocate_node(__n);\n+      _M_deallocate_node(__n);\n       --_M_element_count;\n \n       return __result;\n@@ -1835,7 +1972,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       do\n \t{\n \t  __node_type* __p = __n->_M_next();\n-\t  this->_M_deallocate_node(__n);\n+\t  _M_deallocate_node(__n);\n \t  __n = __p;\n \t  ++__result;\n \t  --_M_element_count;\n@@ -1877,7 +2014,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    {\n \t      __node_type* __tmp = __n;\n \t      __n = __n->_M_next();\n-\t      this->_M_deallocate_node(__tmp);\n+\t      _M_deallocate_node(__tmp);\n \t      --_M_element_count;\n \t      if (!__n)\n \t\tbreak;\n@@ -1907,10 +2044,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     clear() noexcept\n     {\n-      this->_M_deallocate_nodes(_M_begin());\n+      _M_deallocate_nodes(_M_begin());\n       __builtin_memset(_M_buckets, 0, _M_bucket_count * sizeof(__bucket_type));\n       _M_element_count = 0;\n-      _M_before_begin._M_nxt = nullptr;\n+      _M_before_begin()._M_nxt = nullptr;\n     }\n \n   template<typename _Key, typename _Value,\n@@ -1967,19 +2104,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_rehash_aux(size_type __n, std::true_type)\n     {\n-      __bucket_type* __new_buckets = this->_M_allocate_buckets(__n);\n+      __bucket_type* __new_buckets = _M_allocate_buckets(__n);\n       __node_type* __p = _M_begin();\n-      _M_before_begin._M_nxt = nullptr;\n+      _M_before_begin()._M_nxt = nullptr;\n       std::size_t __bbegin_bkt = 0;\n       while (__p)\n \t{\n \t  __node_type* __next = __p->_M_next();\n \t  std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n);\n \t  if (!__new_buckets[__bkt])\n \t    {\n-\t      __p->_M_nxt = _M_before_begin._M_nxt;\n-\t      _M_before_begin._M_nxt = __p;\n-\t      __new_buckets[__bkt] = &_M_before_begin;\n+\t      __p->_M_nxt = _M_before_begin()._M_nxt;\n+\t      _M_before_begin()._M_nxt = __p;\n+\t      __new_buckets[__bkt] = &_M_before_begin();\n \t      if (__p->_M_nxt)\n \t\t__new_buckets[__bbegin_bkt] = __p;\n \t      __bbegin_bkt = __bkt;\n@@ -2009,10 +2146,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_rehash_aux(size_type __n, std::false_type)\n     {\n-      __bucket_type* __new_buckets = this->_M_allocate_buckets(__n);\n+      __bucket_type* __new_buckets = _M_allocate_buckets(__n);\n \n       __node_type* __p = _M_begin();\n-      _M_before_begin._M_nxt = nullptr;\n+      _M_before_begin()._M_nxt = nullptr;\n       std::size_t __bbegin_bkt = 0;\n       std::size_t __prev_bkt = 0;\n       __node_type* __prev_p = nullptr;\n@@ -2057,9 +2194,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n \t      if (!__new_buckets[__bkt])\n \t\t{\n-\t\t  __p->_M_nxt = _M_before_begin._M_nxt;\n-\t\t  _M_before_begin._M_nxt = __p;\n-\t\t  __new_buckets[__bkt] = &_M_before_begin;\n+\t\t  __p->_M_nxt = _M_before_begin()._M_nxt;\n+\t\t  _M_before_begin()._M_nxt = __p;\n+\t\t  __new_buckets[__bkt] = &_M_before_begin();\n \t\t  if (__p->_M_nxt)\n \t\t    __new_buckets[__bbegin_bkt] = __p;\n \t\t  __bbegin_bkt = __bkt;"}, {"sha": "a95b8d4f6a545457b33645ff84913efd785d7076", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 68, "deletions": 181, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ffd1096cf7620eea04f99693c32601e9312cd8c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ffd1096cf7620eea04f99693c32601e9312cd8c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=6ffd1096cf7620eea04f99693c32601e9312cd8c", "patch": "@@ -102,26 +102,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { return std::get<0>(std::forward<_Tp>(__x)); }\n   };\n \n-  template<typename _NodeAlloc>\n-    struct _Hashtable_alloc;\n-\n   // Functor recycling a pool of nodes and using allocation once the pool is\n   // empty.\n-  template<typename _NodeAlloc>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n     struct _ReuseOrAllocNode\n     {\n     private:\n-      using __node_alloc_type = _NodeAlloc;\n-      using __hashtable_alloc = _Hashtable_alloc<__node_alloc_type>;\n-      using __value_alloc_type = typename __hashtable_alloc::__value_alloc_type;\n-      using __value_alloc_traits =\n-\ttypename __hashtable_alloc::__value_alloc_traits;\n-      using __node_alloc_traits =\n-\ttypename __hashtable_alloc::__node_alloc_traits;\n-      using __node_type = typename __hashtable_alloc::__node_type;\n+      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n+\t\t\t\t     _Equal, _H1, _H2, _Hash,\n+\t\t\t\t     _RehashPolicy, _Traits>;\n+      using __val_alloc_type = typename __hashtable::_Value_alloc_type;\n+      using __val_alloc_traits = typename __hashtable::_Value_alloc_traits;\n+      using __node_alloc_traits = typename __hashtable::_Node_alloc_traits;\n+      using __node_type = typename __hashtable::__node_type;\n \n     public:\n-      _ReuseOrAllocNode(__node_type* __nodes, __hashtable_alloc& __h)\n+      _ReuseOrAllocNode(__node_type* __nodes, __hashtable& __h)\n \t: _M_nodes(__nodes), _M_h(__h) { }\n       _ReuseOrAllocNode(const _ReuseOrAllocNode&) = delete;\n \n@@ -137,12 +136,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      __node_type* __node = _M_nodes;\n \t      _M_nodes = _M_nodes->_M_next();\n \t      __node->_M_nxt = nullptr;\n-\t      __value_alloc_type __a(_M_h._M_node_allocator());\n-\t      __value_alloc_traits::destroy(__a, __node->_M_valptr());\n+\t      __val_alloc_type __a(_M_h._M_node_allocator());\n+\t      __val_alloc_traits::destroy(__a, __node->_M_valptr());\n \t      __try\n \t\t{\n-\t\t  __value_alloc_traits::construct(__a, __node->_M_valptr(),\n-\t\t\t\t\t\t  std::forward<_Arg>(__arg));\n+\t\t  __val_alloc_traits::construct(__a, __node->_M_valptr(),\n+\t\t\t\t\t\tstd::forward<_Arg>(__arg));\n \t\t}\n \t      __catch(...)\n \t\t{\n@@ -158,19 +157,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     private:\n       mutable __node_type* _M_nodes;\n-      __hashtable_alloc& _M_h;\n+      __hashtable& _M_h;\n     };\n \n   // Functor similar to the previous one but without any pool of node to recycle.\n-  template<typename _NodeAlloc>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n     struct _AllocNode\n     {\n     private:\n-      using __hashtable_alloc = _Hashtable_alloc<_NodeAlloc>;\n-      using __node_type = typename __hashtable_alloc::__node_type;\n+      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n+\t\t\t\t     _Equal, _H1, _H2, _Hash,\n+\t\t\t\t     _RehashPolicy, _Traits>;\n+      using __node_type = typename __hashtable::__node_type;\n \n     public:\n-      _AllocNode(__hashtable_alloc& __h)\n+      _AllocNode(__hashtable& __h)\n \t: _M_h(__h) { }\n \n       template<typename _Arg>\n@@ -179,7 +183,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{ return _M_h._M_allocate_node(std::forward<_Arg>(__arg)); }\n \n     private:\n-      __hashtable_alloc& _M_h;\n+      __hashtable& _M_h;\n     };\n \n   // Auxiliary types used for all instantiations of _Hashtable nodes\n@@ -243,8 +247,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Value>\n     struct _Hash_node_value_base : _Hash_node_base\n     {\n-      typedef _Value value_type;\n-\n       __gnu_cxx::__aligned_buffer<_Value> _M_storage;\n \n       _Value*\n@@ -334,9 +336,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __node_type = typename __base_type::__node_type;\n \n     public:\n-      typedef _Value\t\t\t\t\tvalue_type;\n-      typedef std::ptrdiff_t\t\t\t\tdifference_type;\n-      typedef std::forward_iterator_tag\t\t\titerator_category;\n+      typedef _Value                                   value_type;\n+      typedef std::ptrdiff_t                           difference_type;\n+      typedef std::forward_iterator_tag                iterator_category;\n \n       using pointer = typename std::conditional<__constant_iterators,\n \t\t\t\t\t\tconst _Value*, _Value*>::type;\n@@ -385,12 +387,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __node_type = typename __base_type::__node_type;\n \n     public:\n-      typedef _Value\t\t\t\t\tvalue_type;\n-      typedef std::ptrdiff_t\t\t\t\tdifference_type;\n-      typedef std::forward_iterator_tag\t\t\titerator_category;\n+      typedef _Value                                   value_type;\n+      typedef std::ptrdiff_t                           difference_type;\n+      typedef std::forward_iterator_tag                iterator_category;\n \n-      typedef const _Value*\t\t\t\tpointer;\n-      typedef const _Value&\t\t\t\treference;\n+      typedef const _Value*                            pointer;\n+      typedef const _Value&                            reference;\n \n       _Node_const_iterator()\n       : __base_type(0) { }\n@@ -497,8 +499,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     static const std::size_t _S_growth_factor = 2;\n \n-    float\t\t_M_max_load_factor;\n-    mutable std::size_t\t_M_next_resize;\n+    float                _M_max_load_factor;\n+    mutable std::size_t  _M_next_resize;\n   };\n \n   // Base classes for std::_Hashtable.  We define these base classes\n@@ -695,10 +697,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       using __unique_keys = typename __hashtable_base::__unique_keys;\n       using __ireturn_type = typename __hashtable_base::__ireturn_type;\n-      using __node_type = _Hash_node<_Value, _Traits::__hash_cached::value>;\n-      using __node_alloc_type =\n-\ttypename __alloctr_rebind<_Alloc, __node_type>::__type;\n-      using __node_gen_type = _AllocNode<__node_alloc_type>;\n+      using __node_gen_type = _AllocNode<_Key, _Value, _Alloc, _ExtractKey,\n+\t\t\t\t\t _Equal, _H1, _H2, _Hash,\n+\t\t\t\t\t _RehashPolicy, _Traits>;\n \n       __hashtable&\n       _M_conjure_hashtable()\n@@ -978,10 +979,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       _Hashtable_ebo_helper() = default;\n \n-      template<typename _OtherTp>\n-\t_Hashtable_ebo_helper(_OtherTp&& __tp)\n-\t  : _Tp(std::forward<_OtherTp>(__tp))\n-\t{ }\n+      _Hashtable_ebo_helper(const _Tp& __tp) : _Tp(__tp)\n+      { }\n \n       static const _Tp&\n       _S_cget(const _Hashtable_ebo_helper& __eboh)\n@@ -998,10 +997,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       _Hashtable_ebo_helper() = default;\n \n-      template<typename _OtherTp>\n-\t_Hashtable_ebo_helper(_OtherTp&& __tp)\n-\t  : _M_tp(std::forward<_OtherTp>(__tp))\n-\t{ }\n+      _Hashtable_ebo_helper(const _Tp& __tp) : _M_tp(__tp)\n+      { }\n \n       static const _Tp&\n       _S_cget(const _Hashtable_ebo_helper& __eboh)\n@@ -1434,15 +1431,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t       _H1, _H2, _Hash, __cache>;\n       using __hash_code_base = typename __base_type::__hash_code_base;\n     public:\n-      typedef _Value\t\t\t\t\tvalue_type;\n+      typedef _Value                                   value_type;\n       typedef typename std::conditional<__constant_iterators,\n \t\t\t\t\tconst _Value*, _Value*>::type\n \t\t\t\t\t\t       pointer;\n       typedef typename std::conditional<__constant_iterators,\n \t\t\t\t\tconst _Value&, _Value&>::type\n \t\t\t\t\t\t       reference;\n-      typedef std::ptrdiff_t\t\t\t\tdifference_type;\n-      typedef std::forward_iterator_tag\t\t\titerator_category;\n+      typedef std::ptrdiff_t                           difference_type;\n+      typedef std::forward_iterator_tag                iterator_category;\n \n       _Local_iterator() = default;\n \n@@ -1490,11 +1487,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __hash_code_base = typename __base_type::__hash_code_base;\n \n     public:\n-      typedef _Value\t\t\t\t\tvalue_type;\n-      typedef const _Value*\t\t\t\tpointer;\n-      typedef const _Value&\t\t\t\treference;\n-      typedef std::ptrdiff_t\t\t\t\tdifference_type;\n-      typedef std::forward_iterator_tag\t\t\titerator_category;\n+      typedef _Value                                   value_type;\n+      typedef const _Value*                            pointer;\n+      typedef const _Value&                            reference;\n+      typedef std::ptrdiff_t                           difference_type;\n+      typedef std::forward_iterator_tag                iterator_category;\n \n       _Local_const_iterator() = default;\n \n@@ -1554,11 +1551,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     private _Hashtable_ebo_helper<0, _Equal>\n   {\n   public:\n-    typedef _Key\t\t\t\t\tkey_type;\n-    typedef _Value\t\t\t\t\tvalue_type;\n-    typedef _Equal\t\t\t\t\tkey_equal;\n-    typedef std::size_t\t\t\t\t\tsize_type;\n-    typedef std::ptrdiff_t\t\t\t\tdifference_type;\n+    typedef _Key                                    key_type;\n+    typedef _Value                                  value_type;\n+    typedef _Equal                                  key_equal;\n+    typedef std::size_t                             size_type;\n+    typedef std::ptrdiff_t                          difference_type;\n \n     using __traits_type = _Traits;\n     using __hash_cached = typename __traits_type::__hash_cached;\n@@ -1600,6 +1597,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t__hash_code, __hash_cached::value>;\n \n   protected:\n+    using __node_base = __detail::_Hash_node_base;\n+    using __bucket_type = __node_base*;\n+\n     _Hashtable_base(const _ExtractKey& __ex, const _H1& __h1, const _H2& __h2,\n \t\t    const _Hash& __hash, const _Equal& __eq)\n     : __hash_code_base(__ex, __h1, __h2, __hash), _EqualEBO(__eq)\n@@ -1787,136 +1787,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   /**\n-   * This type deals with all allocation and keeps an allocator instance through\n-   * inheritance to benefit from EBO when possible.\n+   * This type is to combine a _Hash_node_base instance with an allocator\n+   * instance through inheritance to benefit from EBO when possible.\n    */\n   template<typename _NodeAlloc>\n-    struct _Hashtable_alloc : private _Hashtable_ebo_helper<0, _NodeAlloc>\n+    struct _Before_begin : public _NodeAlloc\n     {\n-    private:\n-      using __ebo_node_alloc = _Hashtable_ebo_helper<0, _NodeAlloc>;\n-    public:\n-      using __node_type = typename _NodeAlloc::value_type;\n-      using __node_alloc_type = _NodeAlloc;\n-      // Use __gnu_cxx to benefit from _S_always_equal and al.\n-      using __node_alloc_traits = __gnu_cxx::__alloc_traits<__node_alloc_type>;\n-\n-      using __value_type = typename __node_type::value_type;\n-      using __value_alloc_type =\n-\ttypename __alloctr_rebind<__node_alloc_type, __value_type>::__type;\n-      using __value_alloc_traits = std::allocator_traits<__value_alloc_type>;\n+      _Hash_node_base _M_node;\n \n-      using __node_base = __detail::_Hash_node_base;\n-      using __bucket_type = __node_base*;      \n-      using __bucket_alloc_type =\n-\ttypename __alloctr_rebind<__node_alloc_type, __bucket_type>::__type;\n-      using __bucket_alloc_traits = std::allocator_traits<__bucket_alloc_type>;\n-\n-      _Hashtable_alloc(const _Hashtable_alloc&) = default;\n-      _Hashtable_alloc(_Hashtable_alloc&&) = default;\n+      _Before_begin(const _Before_begin&) = default;\n+      _Before_begin(_Before_begin&&) = default;\n \n       template<typename _Alloc>\n-\t_Hashtable_alloc(_Alloc&& __a)\n-\t  : __ebo_node_alloc(std::forward<_Alloc>(__a))\n+\t_Before_begin(_Alloc&& __a)\n+\t  : _NodeAlloc(std::forward<_Alloc>(__a))\n \t{ }\n-\n-      __node_alloc_type&\n-      _M_node_allocator()\n-      { return __ebo_node_alloc::_S_get(*this); }\n-\n-      const __node_alloc_type&\n-      _M_node_allocator() const\n-      { return __ebo_node_alloc::_S_cget(*this); }\n-\n-      template<typename... _Args>\n-\t__node_type*\n-\t_M_allocate_node(_Args&&... __args);\n-\n-      void\n-      _M_deallocate_node(__node_type* __n);\n-\n-      // Deallocate the linked list of nodes pointed to by __n\n-      void\n-      _M_deallocate_nodes(__node_type* __n);\n-\n-      __bucket_type*\n-      _M_allocate_buckets(std::size_t __n);\n-\n-      void\n-      _M_deallocate_buckets(__bucket_type*, std::size_t __n);\n     };\n \n-  // Definitions of class template _Hashtable_alloc's out-of-line member\n-  // functions.\n-  template<typename _NodeAlloc>\n-    template<typename... _Args>\n-      typename _Hashtable_alloc<_NodeAlloc>::__node_type*\n-      _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)\n-      {\n-\tauto __nptr = __node_alloc_traits::allocate(_M_node_allocator(), 1);\n-\t__node_type* __n = std::__addressof(*__nptr);\n-\t__try\n-\t  {\n-\t    __value_alloc_type __a(_M_node_allocator());\n-\t    ::new ((void*)__n) __node_type();\n-\t    __value_alloc_traits::construct(__a, __n->_M_valptr(),\n-\t\t\t\t\t    std::forward<_Args>(__args)...);\n-\t    return __n;\n-\t  }\n-\t__catch(...)\n-\t  {\n-\t    __node_alloc_traits::deallocate(_M_node_allocator(), __nptr, 1);\n-\t    __throw_exception_again;\n-\t  }\n-      }\n-\n-  template<typename _NodeAlloc>\n-    void\n-    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_type* __n)\n-    {\n-      typedef typename __node_alloc_traits::pointer _Ptr;\n-      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);\n-      __value_alloc_type __a(_M_node_allocator());\n-      __value_alloc_traits::destroy(__a, __n->_M_valptr());\n-      __n->~__node_type();\n-      __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);\n-    }\n-\n-  template<typename _NodeAlloc>\n-    void\n-    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_type* __n)\n-    {\n-      while (__n)\n-\t{\n-\t  __node_type* __tmp = __n;\n-\t  __n = __n->_M_next();\n-\t  _M_deallocate_node(__tmp);\n-\t}\n-    }\n-\n-  template<typename _NodeAlloc>\n-    typename _Hashtable_alloc<_NodeAlloc>::__bucket_type*\n-    _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __n)\n-    {\n-      __bucket_alloc_type __alloc(_M_node_allocator());\n-\n-      auto __ptr = __bucket_alloc_traits::allocate(__alloc, __n);\n-      __bucket_type* __p = std::__addressof(*__ptr);\n-      __builtin_memset(__p, 0, __n * sizeof(__bucket_type));\n-      return __p;\n-    }\n-\n-  template<typename _NodeAlloc>\n-    void\n-    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_buckets(__bucket_type* __bkts,\n-\t\t\t\t\t\t\tstd::size_t __n)\n-    {\n-      typedef typename __bucket_alloc_traits::pointer _Ptr;\n-      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);\n-      __bucket_alloc_type __alloc(_M_node_allocator());\n-      __bucket_alloc_traits::deallocate(__alloc, __ptr, __n);\n-    }\n-\n  //@} hashtable-detail\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace __detail"}, {"sha": "a3a8b1e2fd71c24496fad1bc8b54bb5b80f97c00", "filename": "libstdc++-v3/python/libstdcxx/v6/printers.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ffd1096cf7620eea04f99693c32601e9312cd8c/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ffd1096cf7620eea04f99693c32601e9312cd8c/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py?ref=6ffd1096cf7620eea04f99693c32601e9312cd8c", "patch": "@@ -652,7 +652,7 @@ def next (self):\n \n class StdHashtableIterator:\n     def __init__(self, hash):\n-        self.node = hash['_M_before_begin']['_M_nxt']\n+        self.node = hash['_M_bbegin']['_M_node']['_M_nxt']\n         self.node_type = find_type(hash.type, '__node_type').pointer()\n \n     def __iter__(self):"}, {"sha": "ff0c832dd88d680564fa95135f14410a8548e85b", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/instantiation_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ffd1096cf7620eea04f99693c32601e9312cd8c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ffd1096cf7620eea04f99693c32601e9312cd8c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc?ref=6ffd1096cf7620eea04f99693c32601e9312cd8c", "patch": "@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"with noexcept\" \"\" { target *-*-* } 265 }\n+// { dg-error \"with noexcept\" \"\" { target *-*-* } 258 }\n \n #include <unordered_set>\n "}, {"sha": "be5b1201edd4d429f21a0b6a0ecb1d93e64b975d", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/not_default_constructible_hash_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ffd1096cf7620eea04f99693c32601e9312cd8c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fnot_default_constructible_hash_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ffd1096cf7620eea04f99693c32601e9312cd8c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fnot_default_constructible_hash_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fnot_default_constructible_hash_neg.cc?ref=6ffd1096cf7620eea04f99693c32601e9312cd8c", "patch": "@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"default constructible\" \"\" { target *-*-* } 283 }\n+// { dg-error \"default constructible\" \"\" { target *-*-* } 276 }\n \n #include <unordered_set>\n "}]}