{"sha": "3dbc07b651f517fa2d07de91473a30b4216d091b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RiYzA3YjY1MWY1MTdmYTJkMDdkZTkxNDczYTMwYjQyMTZkMDkxYg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-04-09T04:28:33Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-04-09T04:28:33Z"}, "message": "Under the new ABI, constructors don't return `this'.\n\n\t* cp-tree.h (warn_reorder): Declare.\n\t(special_function_kind): New enum.\n\t(global_base_init_list): Remove declaration.\n\t(emit_base_init): Don't return a value.\n\t(check_base_init): Don't declare.\n\t(is_aggr_typedef): Likewise.\n\t* decl.c (check_special_function_return_type): New function.\n\t(return_types): Remove.\n\t(grokdeclarator): Use check_special_function_return_type.\n\t(start_function): Don't initialize ctor_label under the new ABI.\n\t(finish_construtor_body): Don't create a corresponding LABEL_STMT.\n\t* init.c (begin_init_stmts): Move to top of file.\n\t(finish_init_stmts): Likewise.\n\t(warn_reorder): Don't declare.\n\t(emit_base_init): Don't create a STMT_EXPR here.  Don't return a\n\tvalue.\n\t(check_base_init): Remove.\n\t(is_aggr_typedef): Likewise.\n\t(build_new_1): Don't use the return value of a constructor.\n\t* semantics.c (setup_vtbl_ptr): Don't use the return value\n\tof emit_base_init.\n\t* typeck.c (check_return_expr): Don't magically convert return\n\tstatements into `return this' in constructors under the new ABI.\n\nFrom-SVN: r33035", "tree": {"sha": "6f1b0dea92e2a38ea78ec4706a12cc4f332eeedf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f1b0dea92e2a38ea78ec4706a12cc4f332eeedf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3dbc07b651f517fa2d07de91473a30b4216d091b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dbc07b651f517fa2d07de91473a30b4216d091b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dbc07b651f517fa2d07de91473a30b4216d091b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dbc07b651f517fa2d07de91473a30b4216d091b/comments", "author": null, "committer": null, "parents": [{"sha": "4eaf5996ad3b761bfb2abd6d65f78b43c4f9a4e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eaf5996ad3b761bfb2abd6d65f78b43c4f9a4e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4eaf5996ad3b761bfb2abd6d65f78b43c4f9a4e5"}], "stats": {"total": 351, "additions": 175, "deletions": 176}, "files": [{"sha": "3d8776e9a6d39fd14ba117d8e9817eff86d4ef8b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dbc07b651f517fa2d07de91473a30b4216d091b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dbc07b651f517fa2d07de91473a30b4216d091b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3dbc07b651f517fa2d07de91473a30b4216d091b", "patch": "@@ -1,5 +1,30 @@\n 2000-04-08  Mark Mitchell  <mark@codesourcery.com>\n \n+\tUnder the new ABI, constructors don't return `this'.\n+\t* cp-tree.h (warn_reorder): Declare.\n+\t(special_function_kind): New enum.\n+\t(global_base_init_list): Remove declaration.\n+\t(emit_base_init): Don't return a value.\n+\t(check_base_init): Don't declare.\n+\t(is_aggr_typedef): Likewise.\n+\t* decl.c (check_special_function_return_type): New function.\n+\t(return_types): Remove.\n+\t(grokdeclarator): Use check_special_function_return_type.\n+\t(start_function): Don't initialize ctor_label under the new ABI.\n+\t(finish_construtor_body): Don't create a corresponding LABEL_STMT.\n+\t* init.c (begin_init_stmts): Move to top of file.\n+\t(finish_init_stmts): Likewise.\n+\t(warn_reorder): Don't declare.\n+\t(emit_base_init): Don't create a STMT_EXPR here.  Don't return a\n+\tvalue.\n+\t(check_base_init): Remove.\n+\t(is_aggr_typedef): Likewise.\n+\t(build_new_1): Don't use the return value of a constructor.\n+\t* semantics.c (setup_vtbl_ptr): Don't use the return value\n+\tof emit_base_init.\n+\t* typeck.c (check_return_expr): Don't magically convert return\n+\tstatements into `return this' in constructors under the new ABI.\n+\t\n \t* cp-tree.h (cp_tree_index): Add CPTI_BASE_CTOR_IDENTIFIER,\n \tCPTI_BASE_DTOR_IDENTIFIER, and CPTI_DELETING_DTOR_IDENTIFIER.\n \t(base_ctor_identifier): New macro."}, {"sha": "1688ee270364ef7b3651913177d92cc9f79bfa2c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dbc07b651f517fa2d07de91473a30b4216d091b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dbc07b651f517fa2d07de91473a30b4216d091b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3dbc07b651f517fa2d07de91473a30b4216d091b", "patch": "@@ -1102,6 +1102,10 @@ extern int warn_extern_inline;\n \n extern int warn_old_style_cast;\n \n+/* Non-zero means warn when the compiler will reorder code.  */\n+\n+extern int warn_reorder;\n+\n /* Nonzero means to treat bitfields as unsigned unless they say `signed'.  */\n \n extern int flag_signed_bitfields;\n@@ -3098,6 +3102,13 @@ typedef enum access_kind {\n   ak_private = 3           /* Accessible, as a `private' thing.  */\n } access_kind;\n \n+typedef enum special_function_kind {\n+  sfk_none,                /* Not a special function.  */\n+  sfk_constructor,         /* A constructor.  */\n+  sfk_destructor,          /* A destructor.  */\n+  sfk_conversion           /* A conversion operator.  */\n+} special_function_kind;\n+\n /* Zero means prototype weakly, as in ANSI C (no args means nothing).\n    Each language context defines how this variable should be set.  */\n extern int strict_prototype;\n@@ -3217,10 +3228,6 @@ extern int current_class_depth;\n /* Points to the name of that function. May not be the DECL_NAME\n    of CURRENT_FUNCTION_DECL due to overloading */\n extern tree original_function_name;\n-\n-/* in init.c  */\n-extern tree global_base_init_list;\n-\n \f\n /* Here's where we control how name mangling takes place.  */\n \n@@ -3999,11 +4006,9 @@ extern tree do_friend\t\t\t\tPARAMS ((tree, tree, tree, tree, tree, enum overload_fl\n \n /* in init.c */\n extern void init_init_processing\t\tPARAMS ((void));\n-extern tree emit_base_init\t\t\tPARAMS ((tree));\n-extern void check_base_init\t\t\tPARAMS ((tree));\n+extern void emit_base_init\t\t\tPARAMS ((tree));\n extern void expand_member_init\t\t\tPARAMS ((tree, tree, tree));\n extern tree build_aggr_init\t\t\tPARAMS ((tree, tree, int));\n-extern int is_aggr_typedef\t\t\tPARAMS ((tree, int));\n extern int is_aggr_type\t\t\t\tPARAMS ((tree, int));\n extern tree get_aggr_from_typedef\t\tPARAMS ((tree, int));\n extern tree get_type_value\t\t\tPARAMS ((tree));"}, {"sha": "858528890024c4a2320514cbfa04499848c04f2a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 90, "deletions": 60, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dbc07b651f517fa2d07de91473a30b4216d091b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dbc07b651f517fa2d07de91473a30b4216d091b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3dbc07b651f517fa2d07de91473a30b4216d091b", "patch": "@@ -178,6 +178,8 @@ static tree start_cleanup_fn PARAMS ((void));\n static void end_cleanup_fn PARAMS ((void));\n static tree cp_make_fname_decl PARAMS ((tree, const char *, int));\n static void initialize_predefined_identifiers PARAMS ((void));\n+static tree check_special_function_return_type \n+  PARAMS ((special_function_kind, tree, tree, tree));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PARAMS ((void));\n@@ -9298,6 +9300,54 @@ create_array_type_for_decl (name, type, size)\n   return build_cplus_array_type (type, itype);\n }\n \n+/* Check that it's OK to declare a function with the indicated TYPE.\n+   SFK indicates the kind of special function (if any) that this\n+   function is.  CTYPE is the class of which this function is a\n+   member.  OPTYPE is the type given in a conversion operator\n+   declaration.  Returns the actual return type of the function; that\n+   may be different than TYPE if an error occurs, or for certain\n+   special functions.  */\n+\n+static tree\n+check_special_function_return_type (sfk, type, ctype, optype)\n+     special_function_kind sfk;\n+     tree type;\n+     tree ctype;\n+     tree optype;\n+{\n+  switch (sfk)\n+    {\n+    case sfk_constructor:\n+      if (type)\n+\tcp_error (\"return type specification for constructor invalid\");\n+\t\n+      /* In the old ABI, we return `this'; in the new ABI we don't\n+\t bother.  */\n+      type = flag_new_abi ? void_type_node : build_pointer_type\t(ctype);\n+      break;\n+\n+    case sfk_destructor:\n+      if (type)\n+\tcp_error (\"return type specification for destructor invalid\");\n+      type = void_type_node;\n+      break;\n+\n+    case sfk_conversion:\n+      if (type && !same_type_p (type, optype))\n+\tcp_error (\"operator `%T' declared to return `%T'\", optype, type);\n+      else if (type)\n+\tcp_pedwarn (\"return type specified for `operator %T'\",  optype);\n+      type = optype;\n+      break;\n+\n+    default:\n+      my_friendly_abort (20000408);\n+      break;\n+    }\n+\n+  return type;\n+}\n+\n /* Given declspecs and a declarator,\n    determine the name and type of the object declared\n    and construct a ..._DECL node for it.\n@@ -9358,8 +9408,6 @@ create_array_type_for_decl (name, type, size)\n    May return void_type_node if the declarator turned out to be a friend.\n    See grokfield for details.  */\n \n-enum return_types { return_normal, return_ctor, return_dtor, return_conversion };\n-\n tree\n grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n      tree declspecs;\n@@ -9398,7 +9446,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n   /* Keep track of what sort of function is being processed\n      so that we can warn about default return values, or explicit\n      return values which do not match prescribed defaults.  */\n-  enum return_types return_type = return_normal;\n+  special_function_kind sfk = sfk_none;\n \n   tree dname = NULL_TREE;\n   tree ctype = current_class_type;\n@@ -9448,7 +9496,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \t      my_friendly_assert (flags == NO_SPECIAL, 152);\n \t      flags = DTOR_FLAG;\n-\t      return_type = return_dtor;\n+\t      sfk = sfk_destructor;\n \t      if (TREE_CODE (name) == TYPE_DECL)\n \t\tTREE_OPERAND (decl, 0) = name = constructor_name (name);\n \t      my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 153);\n@@ -9547,7 +9595,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t&& decl != NULL_TREE && flags != DTOR_FLAG\n \t\t&& decl == constructor_name (ctype))\n \t      {\n-\t\treturn_type = return_ctor;\n+\t\tsfk = sfk_constructor;\n \t\tctor_return_type = ctype;\n \t      }\n \t    ctype = NULL_TREE;\n@@ -9595,7 +9643,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t    my_friendly_assert (flags == NO_SPECIAL, 154);\n \t\t    flags = TYPENAME_FLAG;\n \t\t    ctor_return_type = TREE_TYPE (dname);\n-\t\t    return_type = return_conversion;\n+\t\t    sfk = sfk_conversion;\n \t\t  }\n \t\tname = operator_name_string (dname);\n \t      }\n@@ -9659,15 +9707,15 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t  if (TREE_CODE (decl) == IDENTIFIER_NODE\n \t\t      && constructor_name (ctype) == decl)\n \t\t    {\n-\t\t      return_type = return_ctor;\n+\t\t      sfk = sfk_constructor;\n \t\t      ctor_return_type = ctype;\n \t\t    }\n \t\t  else if (TREE_CODE (decl) == BIT_NOT_EXPR\n \t\t\t   && TREE_CODE (TREE_OPERAND (decl, 0)) == IDENTIFIER_NODE\n \t\t\t   && (constructor_name (ctype) == TREE_OPERAND (decl, 0)\n \t\t\t       || constructor_name_full (ctype) == TREE_OPERAND (decl, 0)))\n \t\t    {\n-\t\t      return_type = return_dtor;\n+\t\t      sfk = sfk_destructor;\n \t\t      ctor_return_type = ctype;\n \t\t      flags = DTOR_FLAG;\n \t\t      TREE_OPERAND (decl, 0) = constructor_name (ctype);\n@@ -9883,58 +9931,35 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n       defaulted_int = 1;\n     }\n \n-  if (type == NULL_TREE)\n+  if (sfk != sfk_none)\n+    type = check_special_function_return_type (sfk, type,\n+\t\t\t\t\t       ctor_return_type,\n+\t\t\t\t\t       ctor_return_type);\n+  else if (type == NULL_TREE)\n     {\n+      int is_main;\n+\n       explicit_int = -1;\n-      if (return_type == return_dtor)\n-\ttype = void_type_node;\n-      else if (return_type == return_ctor)\n-\ttype = build_pointer_type (ctor_return_type);\n-      else if (return_type == return_conversion)\n-\ttype = ctor_return_type;\n-      else\n-\t{\n+\n \t  /* We handle `main' specially here, because 'main () { }' is so\n \t     common.  With no options, it is allowed.  With -Wreturn-type,\n \t     it is a warning.  It is only an error with -pedantic-errors.  */\n-\t  int is_main = (funcdef_flag\n-\t\t\t && MAIN_NAME_P (dname)\n-\t\t\t && ctype == NULL_TREE\n-\t\t\t && in_namespace == NULL_TREE\n-\t\t\t && current_namespace == global_namespace);\n-\n-\t  if (in_system_header || flag_ms_extensions)\n-\t    /* Allow it, sigh.  */;\n-\t  else if (pedantic || ! is_main)\n-\t    cp_pedwarn (\"ISO C++ forbids declaration of `%s' with no type\",\n-\t\t\tname);\n-\t  else if (warn_return_type)\n-\t    cp_warning (\"ISO C++ forbids declaration of `%s' with no type\",\n-\t\t\tname);\n+      is_main = (funcdef_flag\n+\t\t && MAIN_NAME_P (dname)\n+\t\t && ctype == NULL_TREE\n+\t\t && in_namespace == NULL_TREE\n+\t\t && current_namespace == global_namespace);\n+\n+      if (in_system_header || flag_ms_extensions)\n+\t/* Allow it, sigh.  */;\n+      else if (pedantic || ! is_main)\n+\tcp_pedwarn (\"ISO C++ forbids declaration of `%s' with no type\",\n+\t\t    name);\n+      else if (warn_return_type)\n+\tcp_warning (\"ISO C++ forbids declaration of `%s' with no type\",\n+\t\t    name);\n \n-\t  type = integer_type_node;\n-\t}\n-    }\n-  else if (return_type == return_dtor)\n-    {\n-      error (\"return type specification for destructor invalid\");\n-      type = void_type_node;\n-    }\n-  else if (return_type == return_ctor)\n-    {\n-      error (\"return type specification for constructor invalid\");\n-      type = build_pointer_type (ctor_return_type);\n-    }\n-  else if (return_type == return_conversion)\n-    {\n-      if (!same_type_p (type, ctor_return_type))\n-\tcp_error (\"operator `%T' declared to return `%T'\",\n-\t\t  ctor_return_type, type);\n-      else\n-\tcp_pedwarn (\"return type specified for `operator %T'\",\n-\t\t    ctor_return_type);\n-\n-      type = ctor_return_type;\n+      type = integer_type_node;\n     }\n \n   ctype = NULL_TREE;\n@@ -10079,7 +10104,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \ttype = build_complex_type (type);\n     }\n \n-  if (return_type == return_conversion\n+  if (sfk == sfk_conversion\n       && (RIDBIT_SETP (RID_CONST, specbits)\n \t  || RIDBIT_SETP (RID_VOLATILE, specbits)\n \t  || RIDBIT_SETP (RID_RESTRICT, specbits)))\n@@ -10376,7 +10401,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t&& (friendp == 0 || dname == current_class_name))\n \t      ctype = current_class_type;\n \n-\t    if (ctype && return_type == return_conversion)\n+\t    if (ctype && sfk == sfk_conversion)\n \t      TYPE_HAS_CONVERSION (ctype) = 1;\n \t    if (ctype && constructor_name (ctype) == dname)\n \t      {\n@@ -10435,15 +10460,14 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t      if (RIDBIT_ANY_SET (tmp_bits))\n \t\t\terror (\"return value type specifier for constructor ignored\");\n \t\t    }\n-\t\t    type = build_pointer_type (ctype);\n \t\t    if (decl_context == FIELD)\n \t\t      {\n \t\t\tif (! member_function_or_else (ctype,\n \t\t\t\t\t\t       current_class_type,\n \t\t\t\t\t\t       flags))\n \t\t\t  return void_type_node;\n \t\t\tTYPE_HAS_CONSTRUCTOR (ctype) = 1;\n-\t\t\tif (return_type != return_ctor)\n+\t\t\tif (sfk != sfk_constructor)\n \t\t\t  return NULL_TREE;\n \t\t      }\n \t\t  }\n@@ -13532,7 +13556,12 @@ start_function (declspecs, declarator, attrs, flags)\n       dtor_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n       DECL_CONTEXT (dtor_label) = current_function_decl;\n     }\n-  else if (DECL_CONSTRUCTOR_P (decl1))\n+  /* Under the old ABI we return `this' from constructors, so we make\n+     ordinary `return' statements in constructors jump to CTOR_LABEL;\n+     from there we return `this'.  Under the new ABI, we don't bother\n+     with any of this.  By not setting CTOR_LABEL the remainder of the\n+     machinery is automatically disabled.  */\n+  else if (!flag_new_abi && DECL_CONSTRUCTOR_P (decl1))\n     {\n       ctor_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n       DECL_CONTEXT (ctor_label) = current_function_decl;\n@@ -13764,7 +13793,8 @@ static void\n finish_constructor_body ()\n {\n   /* Any return from a constructor will end up here.  */\n-  add_tree (build_min_nt (LABEL_STMT, ctor_label));\n+  if (ctor_label)\n+    add_tree (build_min_nt (LABEL_STMT, ctor_label));\n \n   /* Clear CTOR_LABEL so that finish_return_stmt knows to really\n      generate the return, rather than a goto to CTOR_LABEL.  */"}, {"sha": "8da9d821f1f3454d9f670759057d1baf4677b35d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 44, "deletions": 105, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dbc07b651f517fa2d07de91473a30b4216d091b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dbc07b651f517fa2d07de91473a30b4216d091b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=3dbc07b651f517fa2d07de91473a30b4216d091b", "patch": "@@ -79,6 +79,45 @@ void init_init_processing ()\n   ggc_add_tree_root (&BI_header_size, 1);\n }\n \n+/* We are about to generate some complex initialization code.\n+   Conceptually, it is all a single expression.  However, we may want\n+   to include conditionals, loops, and other such statement-level\n+   constructs.  Therefore, we build the initialization code inside a\n+   statement-expression.  This function starts such an expression.\n+   STMT_EXPR_P and COMPOUND_STMT_P are filled in by this function;\n+   pass them back to finish_init_stmts when the expression is\n+   complete.  */\n+\n+void\n+begin_init_stmts (stmt_expr_p, compound_stmt_p)\n+     tree *stmt_expr_p;\n+     tree *compound_stmt_p;\n+{\n+  *stmt_expr_p = begin_stmt_expr ();\n+  *compound_stmt_p = begin_compound_stmt (/*has_no_scope=*/1);\n+}\n+\n+/* Finish out the statement-expression begun by the previous call to\n+   begin_init_stmts.  Returns the statement-expression itself.  */\n+\n+tree\n+finish_init_stmts (stmt_expr, compound_stmt)\n+     tree stmt_expr;\n+     tree compound_stmt;\n+{\n+  finish_compound_stmt (/*has_no_scope=*/1, compound_stmt);\n+  stmt_expr = finish_stmt_expr (stmt_expr);\n+\n+  /* To avoid spurious warnings about unused values, we set \n+     TREE_USED.  */\n+  if (stmt_expr)\n+    TREE_USED (stmt_expr) = 1;\n+\n+  return stmt_expr;\n+}\n+\n+/* Constructors */\n+\n /* Called from initialize_vtbl_ptrs via dfs_walk.  */\n \n static tree\n@@ -132,8 +171,6 @@ initialize_vtbl_ptrs (type, addr)\n     expand_indirect_vtbls_init (TYPE_BINFO (type), addr);\n }\n \n-\f\n-/* 348 - 351 */\n /* Subroutine of emit_base_init.  */\n \n static void\n@@ -240,8 +277,6 @@ perform_member_init (member, name, init, explicit)\n     }\n }\n \n-extern int warn_reorder;\n-\n /* Subroutine of emit_member_init.  */\n \n static tree\n@@ -485,7 +520,7 @@ sort_base_init (t, rbase_ptr, vbase_ptr)\n    Note that emit_base_init does *not* initialize virtual base\n    classes.  That is done specially, elsewhere.  */\n \n-tree\n+void\n emit_base_init (t)\n      tree t;\n {\n@@ -494,18 +529,15 @@ emit_base_init (t)\n   tree rbase_init_list, vbase_init_list;\n   tree t_binfo = TYPE_BINFO (t);\n   tree binfos = BINFO_BASETYPES (t_binfo);\n-  int i, n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-  tree stmt_expr;\n-  tree compound_stmt;\n+  int i;\n+  int n_baseclasses = BINFO_N_BASETYPES (t_binfo);\n \n   mem_init_list = sort_member_init (t);\n   current_member_init_list = NULL_TREE;\n \n   sort_base_init (t, &rbase_init_list, &vbase_init_list);\n   current_base_init_list = NULL_TREE;\n \n-  begin_init_stmts (&stmt_expr, &compound_stmt);\n-  \n   /* First, initialize the virtual base classes, if we are\n      constructing the most-derived object.  */\n   if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n@@ -618,25 +650,6 @@ emit_base_init (t)\n \t}\n       mem_init_list = TREE_CHAIN (mem_init_list);\n     }\n-\n-  /* All the implicit try blocks we built up will be zapped\n-     when we come to a real binding contour boundary.  */\n-  return finish_init_stmts (stmt_expr, compound_stmt);\n-}\n-\n-/* Check that all fields are properly initialized after\n-   an assignment to `this'.  Called only when such an assignment\n-   is actually noted.  */\n-\n-void\n-check_base_init (t)\n-     tree t;\n-{\n-  tree member;\n-  for (member = TYPE_FIELDS (t); member; member = TREE_CHAIN (member))\n-    if (DECL_NAME (member) && TREE_USED (member))\n-      cp_error (\"field `%D' used before initialized (after assignment to `this')\",\n-\t\tmember);\n }\n \n /* This code sets up the virtual function tables appropriate for\n@@ -983,43 +996,6 @@ expand_member_init (exp, name, init)\n     }\n }\n \n-/* We are about to generate some complex initialization code.\n-   Conceptually, it is all a single expression.  However, we may want\n-   to include conditionals, loops, and other such statement-level\n-   constructs.  Therefore, we build the initialization code inside a\n-   statement-expression.  This function starts such an expression.\n-   STMT_EXPR_P and COMPOUND_STMT_P are filled in by this function;\n-   pass them back to finish_init_stmts when the expression is\n-   complete.  */\n-\n-void\n-begin_init_stmts (stmt_expr_p, compound_stmt_p)\n-     tree *stmt_expr_p;\n-     tree *compound_stmt_p;\n-{\n-  *stmt_expr_p = begin_stmt_expr ();\n-  *compound_stmt_p = begin_compound_stmt (/*has_no_scope=*/1);\n-}\n-\n-/* Finish out the statement-expression begun by the previous call to\n-   begin_init_stmts.  Returns the statement-expression itself.  */\n-\n-tree\n-finish_init_stmts (stmt_expr, compound_stmt)\n-     tree stmt_expr;\n-     tree compound_stmt;\n-{\n-  finish_compound_stmt (/*has_no_scope=*/1, compound_stmt);\n-  stmt_expr = finish_stmt_expr (stmt_expr);\n-\n-  /* To avoid spurious warnings about unused values, we set \n-     TREE_USED.  */\n-  if (stmt_expr)\n-    TREE_USED (stmt_expr) = 1;\n-\n-  return stmt_expr;\n-}\n-\n /* This is like `expand_member_init', only it stores one aggregate\n    value into another.\n \n@@ -1268,39 +1244,6 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, flags)\n   expand_default_init (binfo, true_exp, exp, init, flags);\n }\n \n-/* Report an error if NAME is not the name of a user-defined,\n-   aggregate type.  If OR_ELSE is nonzero, give an error message.  */\n-\n-int\n-is_aggr_typedef (name, or_else)\n-     tree name;\n-     int or_else;\n-{\n-  tree type;\n-\n-  if (name == error_mark_node)\n-    return 0;\n-\n-  if (IDENTIFIER_HAS_TYPE_VALUE (name))\n-    type = IDENTIFIER_TYPE_VALUE (name);\n-  else\n-    {\n-      if (or_else)\n-\tcp_error (\"`%T' is not an aggregate typedef\", name);\n-      return 0;\n-    }\n-\n-  if (! IS_AGGR_TYPE (type)\n-      && TREE_CODE (type) != TEMPLATE_TYPE_PARM\n-      && TREE_CODE (type) != TEMPLATE_TEMPLATE_PARM)\n-    {\n-      if (or_else)\n-\tcp_error (\"`%T' is not an aggregate type\", type);\n-      return 0;\n-    }\n-  return 1;\n-}\n-\n /* Report an error if TYPE is not a user-defined, aggregate type.  If\n    OR_ELSE is nonzero, give an error message.  */\n \n@@ -2413,8 +2356,7 @@ build_new_1 (exp)\n \t      flags |= LOOKUP_HAS_IN_CHARGE;\n \t    }\n \n-\t  if (use_java_new)\n-\t    rval = save_expr (rval);\n+\t  rval = save_expr (rval);\n \t  newrval = rval;\n \n \t  if (newrval && TREE_CODE (TREE_TYPE (newrval)) == POINTER_TYPE)\n@@ -2426,10 +2368,7 @@ build_new_1 (exp)\n \t  if (newrval == NULL_TREE || newrval == error_mark_node)\n \t    return error_mark_node;\n \n-\t  /* Java constructors compiled by jc1 do not return this. */\n-\t  if (use_java_new)\n-\t    newrval = build (COMPOUND_EXPR, TREE_TYPE (newrval),\n-\t\t\t     newrval, rval);\n+\t  newrval = build (COMPOUND_EXPR, TREE_TYPE (rval), newrval, rval);\n \t  rval = newrval;\n \t  TREE_HAS_CONSTRUCTOR (rval) = 1;\n \t}"}, {"sha": "6801456735c55f207bc0c11ed6f39f5b80ac04d1", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dbc07b651f517fa2d07de91473a30b4216d091b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dbc07b651f517fa2d07de91473a30b4216d091b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=3dbc07b651f517fa2d07de91473a30b4216d091b", "patch": "@@ -1235,7 +1235,7 @@ setup_vtbl_ptr ()\n \t  add_tree (ctor_stmt);\n \t  \n \t  /* And actually initialize the base-classes and members.  */\n-\t  finish_expr_stmt (emit_base_init (current_class_type));\n+\t  emit_base_init (current_class_type);\n \t}\n     }\n   else if (DECL_DESTRUCTOR_P (current_function_decl)"}, {"sha": "bce12adaf2381ee58a6f29c7f0c00d3d3bef44db", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dbc07b651f517fa2d07de91473a30b4216d091b/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dbc07b651f517fa2d07de91473a30b4216d091b/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=3dbc07b651f517fa2d07de91473a30b4216d091b", "patch": "@@ -6796,9 +6796,9 @@ check_return_expr (retval)\n     /* You can't return a value from a constructor.  */\n     error (\"returning a value from a constructor\");\n \n-  /* Constructors actually always return `this', even though in C++\n-     you can't return a value from a constructor.  */\n-  if (DECL_CONSTRUCTOR_P (current_function_decl))\n+  /* Under the old ABI, constructors actually always return `this',\n+     even though in C++ you can't return a value from a constructor.  */\n+  if (!flag_new_abi && DECL_CONSTRUCTOR_P (current_function_decl))\n     retval = current_class_ptr;\n \n   /* When no explicit return-value is given in a function with a named"}]}