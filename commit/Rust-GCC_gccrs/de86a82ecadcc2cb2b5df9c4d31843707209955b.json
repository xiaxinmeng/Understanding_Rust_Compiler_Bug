{"sha": "de86a82ecadcc2cb2b5df9c4d31843707209955b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU4NmE4MmVjYWRjYzJjYjJiNWRmOWM0ZDMxODQzNzA3MjA5OTU1Yg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-07T00:51:10Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-07T00:51:10Z"}, "message": "restore portion accidentally deleted last time\n(but not the two functions intentionally deleted).\n\nFrom-SVN: r1485", "tree": {"sha": "58b219513a887b3f838d2a1439abbd519a1acbc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58b219513a887b3f838d2a1439abbd519a1acbc4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de86a82ecadcc2cb2b5df9c4d31843707209955b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de86a82ecadcc2cb2b5df9c4d31843707209955b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de86a82ecadcc2cb2b5df9c4d31843707209955b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de86a82ecadcc2cb2b5df9c4d31843707209955b/comments", "author": null, "committer": null, "parents": [{"sha": "8d9bfdc59dbb0ac947b27c22b8cf12a6e757bc64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d9bfdc59dbb0ac947b27c22b8cf12a6e757bc64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d9bfdc59dbb0ac947b27c22b8cf12a6e757bc64"}], "stats": {"total": 355, "additions": 354, "deletions": 1}, "files": [{"sha": "c82c1977ced7c3e1a1744dcb9930be38fe38b53d", "filename": "gcc/config/i860/i860.c", "status": "modified", "additions": 354, "deletions": 1, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de86a82ecadcc2cb2b5df9c4d31843707209955b/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de86a82ecadcc2cb2b5df9c4d31843707209955b/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=de86a82ecadcc2cb2b5df9c4d31843707209955b", "patch": "@@ -1,3 +1,356 @@\n+/* Subroutines for insn-output.c for Intel 860\n+   Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n+   Derived from sparc.c.\n+\n+   Written by Richard Stallman (rms@ai.mit.edu).\n+\n+   Hacked substantially by Ron Guilmette (rfg@ncd.com) to cater\n+   to the whims of the System V Release 4 assembler.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include \"config.h\"\n+#include \"flags.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"recog.h\"\n+#include \"insn-attr.h\"\n+\n+#include <stdio.h>\n+\n+static rtx find_addr_reg ();\n+\n+#ifndef I860_REG_PREFIX\n+#define I860_REG_PREFIX \"\"\n+#endif\n+\n+char *i860_reg_prefix = I860_REG_PREFIX;\n+\n+/* Save information from a \"cmpxx\" operation until the branch is emitted.  */\n+\n+rtx i860_compare_op0, i860_compare_op1;\n+\f\n+/* Return non-zero if this pattern, can be evaluated safely, even if it\n+   was not asked for.  */\n+int\n+safe_insn_src_p (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  /* Just experimenting.  */\n+\n+  /* No floating point src is safe if it contains an arithmetic\n+     operation, since that operation may trap.  */\n+  switch (GET_CODE (op))\n+    {\n+    case CONST_INT:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST:\n+      return 1;\n+\n+    case REG:\n+      return 1;\n+\n+    case MEM:\n+      return CONSTANT_ADDRESS_P (XEXP (op, 0));\n+\n+      /* We never need to negate or complement constants.  */\n+    case NEG:\n+      return (mode != SFmode && mode != DFmode);\n+    case NOT:\n+    case ZERO_EXTEND:\n+      return 1;\n+\n+    case EQ:\n+    case NE:\n+    case LT:\n+    case GT:\n+    case LE:\n+    case GE:\n+    case LTU:\n+    case GTU:\n+    case LEU:\n+    case GEU:\n+    case MINUS:\n+    case PLUS:\n+      return (mode != SFmode && mode != DFmode);\n+    case AND:\n+    case IOR:\n+    case XOR:\n+    case LSHIFT:\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      if ((GET_CODE (XEXP (op, 0)) == CONST_INT && ! SMALL_INT (XEXP (op, 0)))\n+\t  || (GET_CODE (XEXP (op, 1)) == CONST_INT && ! SMALL_INT (XEXP (op, 1))))\n+\treturn 0;\n+      return 1;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Return 1 if REG is clobbered in IN.\n+   Return 2 if REG is used in IN. \n+   Return 3 if REG is both used and clobbered in IN.\n+   Return 0 if neither.  */\n+\n+static int\n+reg_clobbered_p (reg, in)\n+     rtx reg;\n+     rtx in;\n+{\n+  register enum rtx_code code;\n+\n+  if (in == 0)\n+    return 0;\n+\n+  code = GET_CODE (in);\n+\n+  if (code == SET || code == CLOBBER)\n+    {\n+      rtx dest = SET_DEST (in);\n+      int set = 0;\n+      int used = 0;\n+\n+      while (GET_CODE (dest) == STRICT_LOW_PART\n+\t     || GET_CODE (dest) == SUBREG\n+\t     || GET_CODE (dest) == SIGN_EXTRACT\n+\t     || GET_CODE (dest) == ZERO_EXTRACT)\n+\tdest = XEXP (dest, 0);\n+\n+      if (dest == reg)\n+\tset = 1;\n+      else if (GET_CODE (dest) == REG\n+\t       && refers_to_regno_p (REGNO (reg),\n+\t\t\t\t     REGNO (reg) + HARD_REGNO_NREGS (reg, GET_MODE (reg)),\n+\t\t\t\t     SET_DEST (in), 0))\n+\t{\n+\t  set = 1;\n+\t  /* Anything that sets just part of the register\n+\t     is considered using as well as setting it.\n+\t     But note that a straight SUBREG of a single-word value\n+\t     clobbers the entire value.   */\n+\t  if (dest != SET_DEST (in)\n+\t      && ! (GET_CODE (SET_DEST (in)) == SUBREG\n+\t\t    || UNITS_PER_WORD >= GET_MODE_SIZE (GET_MODE (dest))))\n+\t    used = 1;\n+\t}\n+\n+      if (code == SET)\n+\t{\n+\t  if (set)\n+\t    used = refers_to_regno_p (REGNO (reg),\n+\t\t\t\t      REGNO (reg) + HARD_REGNO_NREGS (reg, GET_MODE (reg)),\n+\t\t\t\t      SET_SRC (in), 0);\n+\t  else\n+\t    used = refers_to_regno_p (REGNO (reg),\n+\t\t\t\t      REGNO (reg) + HARD_REGNO_NREGS (reg, GET_MODE (reg)),\n+\t\t\t\t      in, 0);\n+\t}\n+\n+      return set + used * 2;\n+    }\n+\n+  if (refers_to_regno_p (REGNO (reg),\n+\t\t\t REGNO (reg) + HARD_REGNO_NREGS (reg, GET_MODE (reg)),\n+\t\t\t in, 0))\n+    return 2;\n+  return 0;\n+}\n+\n+/* Return non-zero if OP can be written to without screwing up\n+   GCC's model of what's going on.  It is assumed that this operand\n+   appears in the dest position of a SET insn in a conditional\n+   branch's delay slot.  AFTER is the label to start looking from.  */\n+int\n+operand_clobbered_before_used_after (op, after)\n+     rtx op;\n+     rtx after;\n+{\n+  /* Just experimenting.  */\n+  if (GET_CODE (op) == CC0)\n+    return 1;\n+  if (GET_CODE (op) == REG)\n+    {\n+      rtx insn;\n+\n+      if (op == stack_pointer_rtx)\n+\treturn 0;\n+\n+      /* Scan forward from the label, to see if the value of OP\n+\t is clobbered before the first use.  */\n+\n+      for (insn = NEXT_INSN (after); insn; insn = NEXT_INSN (insn))\n+\t{\n+\t  if (GET_CODE (insn) == NOTE)\n+\t    continue;\n+\t  if (GET_CODE (insn) == INSN\n+\t      || GET_CODE (insn) == JUMP_INSN\n+\t      || GET_CODE (insn) == CALL_INSN)\n+\t    {\n+\t      switch (reg_clobbered_p (op, PATTERN (insn)))\n+\t\t{\n+\t\tdefault:\n+\t\t  return 0;\n+\t\tcase 1:\n+\t\t  return 1;\n+\t\tcase 0:\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  /* If we reach another label without clobbering OP,\n+\t     then we cannot safely write it here.  */\n+\t  else if (GET_CODE (insn) == CODE_LABEL)\n+\t    return 0;\n+\t  if (GET_CODE (insn) == JUMP_INSN)\n+\t    {\n+\t      if (condjump_p (insn))\n+\t\treturn 0;\n+\t      /* This is a jump insn which has already\n+\t\t been mangled.  We can't tell what it does.  */\n+\t      if (GET_CODE (PATTERN (insn)) == PARALLEL)\n+\t\treturn 0;\n+\t      if (! JUMP_LABEL (insn))\n+\t\treturn 0;\n+\t      /* Keep following jumps.  */\n+\t      insn = JUMP_LABEL (insn);\n+\t    }\n+\t}\n+      return 1;\n+    }\n+\n+  /* In both of these cases, the first insn executed\n+     for this op will be a orh whatever%h,%?r0,%?r31,\n+     which is tolerable.  */\n+  if (GET_CODE (op) == MEM)\n+    return (CONSTANT_ADDRESS_P (XEXP (op, 0)));\n+\n+  return 0;\n+}\n+\n+/* Return non-zero if this pattern, as a source to a \"SET\",\n+   is known to yield an instruction of unit size.  */\n+int\n+single_insn_src_p (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case CONST_INT:\n+      /* This is not always a single insn src, technically,\n+\t but output_delayed_branch knows how to deal with it.  */\n+      return 1;\n+\n+    case SYMBOL_REF:\n+    case CONST:\n+      /* This is not a single insn src, technically,\n+\t but output_delayed_branch knows how to deal with it.  */\n+      return 1;\n+\n+    case REG:\n+      return 1;\n+\n+    case MEM:\n+      return 1;\n+\n+      /* We never need to negate or complement constants.  */\n+    case NEG:\n+      return (mode != DFmode);\n+    case NOT:\n+    case ZERO_EXTEND:\n+      return 1;\n+\n+    case PLUS:\n+    case MINUS:\n+      /* Detect cases that require multiple instructions.  */\n+      if (CONSTANT_P (XEXP (op, 1))\n+\t  && !(GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t       && SMALL_INT (XEXP (op, 1))))\n+\treturn 0;\n+    case EQ:\n+    case NE:\n+    case LT:\n+    case GT:\n+    case LE:\n+    case GE:\n+    case LTU:\n+    case GTU:\n+    case LEU:\n+    case GEU:\n+      /* Not doing floating point, since they probably\n+\t take longer than the branch slot they might fill.  */\n+      return (mode != SFmode && mode != DFmode);\n+\n+    case AND:\n+      if (GET_CODE (XEXP (op, 1)) == NOT)\n+\t{\n+\t  rtx arg = XEXP (XEXP (op, 1), 0);\n+\t  if (CONSTANT_P (arg)\n+\t      && !(GET_CODE (arg) == CONST_INT\n+\t\t   && (SMALL_INT (arg)\n+\t\t       || INTVAL (arg) & 0xffff == 0)))\n+\t    return 0;\n+\t}\n+    case IOR:\n+    case XOR:\n+      /* Both small and round numbers take one instruction;\n+\t others take two.  */\n+      if (CONSTANT_P (XEXP (op, 1))\n+\t  && !(GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t       && (SMALL_INT (XEXP (op, 1))\n+\t\t   || INTVAL (XEXP (op, 1)) & 0xffff == 0)))\n+\treturn 0;\n+\n+    case LSHIFT:\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      return 1;\n+\n+    case SUBREG:\n+      if (SUBREG_WORD (op) != 0)\n+\treturn 0;\n+      return single_insn_src_p (SUBREG_REG (op), mode);\n+\n+      /* Not doing floating point, since they probably\n+\t take longer than the branch slot they might fill.  */\n+    case FLOAT_EXTEND:\n+    case FLOAT_TRUNCATE:\n+    case FLOAT:\n+    case FIX:\n+    case UNSIGNED_FLOAT:\n+    case UNSIGNED_FIX:\n+      return 0;\n+\n+    default:\n+      return 0;\n+    }\n+}\n \f\n /* Return non-zero only if OP is a register of mode MODE,\n    or const0_rtx.  */\n@@ -1199,7 +1552,7 @@ sfmode_constant_to_ulong (x)\n    for saving all of the \"preserved\" registers (and use that number, i.e.\n    `80', to define STARTING_FRAME_OFFSET) if we wanted to save them in\n    the lower part of the frame.  That could potentially be very wasteful,\n-   and that could cause serious problems when compiling for embedded\n+   and that wastefulness could really hamper people compiling for embedded\n    i860 targets with very tight limits on stack space.  Thus, we choose\n    here to save the preserved registers in the upper part of the\n    frame, so that we can decide at the very last minute how much (or how"}]}