{"sha": "b823cdfe763c9784a8e9f7b86b8e91614c29de6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgyM2NkZmU3NjNjOTc4NGE4ZTlmN2I4NmI4ZTkxNjE0YzI5ZGU2Yw==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2011-04-29T12:27:26Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2011-04-29T12:27:26Z"}, "message": "lto-streamer.c (lto_streamer_cache_insert_1): Accept to override other trees that just builtins.\n\n\t* lto-streamer.c (lto_streamer_cache_insert_1): Accept to override\n\tother trees that just builtins.\n\t(lto_record_common_node): Don't leave NULL TYPE_CANONICAL.\n\nlto/\n\t* lto.c (toplevel): Include tree-flow.h.\n\t(lto_read_in_decl_state): Don't merge types here.\n\t(tree_with_vars): New static hash table.\n\t(remember_with_vars): New static functions.\n\t(LTO_FIXUP_TYPE): New macro.\n\t(lto_ft_common, lto_ft_decl_minimal, lto_ft_decl_common,\n\tlto_ft_decl_with_vis, lto_ft_decl_non_common, lto_ft_function,\n\tlto_ft_field_decl, lto_ft_type, lto_ft_binfo, lto_ft_constructor,\n\tlto_ft_expr, lto_fixup_types, uniquify_nodes): New static functions.\n\t(lto_read_decls): Uniquify while reading in trees.\n\t(lto_fixup_data_t, LTO_FIXUP_SUBTREE,\n\tLTO_REGISTER_TYPE_AND_FIXUP_SUBTREE, no_fixup_p, lto_fixup_common,\n\tlto_fixup_decl_minimal, lto_fixup_decl_common, lto_fixup_decl_with_vis,\n\tlto_fixup_decl_non_common, lto_fixup_function, lto_fixup_field_decl,\n\tlto_fixup_type, lto_fixup_binfo, lto_fixup_constructor,\n\tlto_fixup_tree): Remove.\n\t(lto_fixup_state): Remove data argument.  Use\n\tlto_symtab_prevailing_decl.\n\t(LTO_SET_PREVAIL, LTO_NO_PREVAIL): New macros.\n\t(lto_fixup_prevailing_decls): New function.\n\t(lto_fixup_state_aux): Argument aux is unused.\n\t(lto_fixup_decls): Don't allocate pointer sets, don't use\n\tlto_fixup_tree, use lto_fixup_prevailing_decls.\n\t(read_cgraph_and_symbols): Allocate and remove tree_with_vars.\n\t* Make-lang.in (lto/lto.o): Depend on $(TREE_FLOW_H).\n\nFrom-SVN: r173155", "tree": {"sha": "c61f3e7031b4f1e93cb11ce662f70e58fc9052aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c61f3e7031b4f1e93cb11ce662f70e58fc9052aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b823cdfe763c9784a8e9f7b86b8e91614c29de6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b823cdfe763c9784a8e9f7b86b8e91614c29de6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b823cdfe763c9784a8e9f7b86b8e91614c29de6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b823cdfe763c9784a8e9f7b86b8e91614c29de6c/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fa5e5a764f6602df0d4b814c49d352f8907cf2e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa5e5a764f6602df0d4b814c49d352f8907cf2e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa5e5a764f6602df0d4b814c49d352f8907cf2e1"}], "stats": {"total": 1007, "additions": 577, "deletions": 430}, "files": [{"sha": "6f7430c148364a429ad50d111b731500c2dad5e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b823cdfe763c9784a8e9f7b86b8e91614c29de6c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b823cdfe763c9784a8e9f7b86b8e91614c29de6c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b823cdfe763c9784a8e9f7b86b8e91614c29de6c", "patch": "@@ -1,3 +1,9 @@\n+2011-04-29  Michael Matz  <matz@suse.de>\n+\n+\t* lto-streamer.c (lto_streamer_cache_insert_1): Accept to override\n+\tother trees that just builtins.\n+\t(lto_record_common_node): Don't leave NULL TYPE_CANONICAL.\n+\n 2011-04-29  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-nested.c (get_trampoline_type): Use size_int."}, {"sha": "80927927dcc01f5f4e9921e6f1cdf8c33c388a95", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b823cdfe763c9784a8e9f7b86b8e91614c29de6c/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b823cdfe763c9784a8e9f7b86b8e91614c29de6c/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=b823cdfe763c9784a8e9f7b86b8e91614c29de6c", "patch": "@@ -383,19 +383,8 @@ lto_streamer_cache_insert_1 (struct lto_streamer_cache_d *cache,\n \t{\n \t  /* If the caller wants to insert T at a specific slot\n \t     location, and ENTRY->TO does not match *IX_P, add T to\n-\t     the requested location slot.  This situation arises when\n-\t     streaming builtin functions.\n-\n-\t     For instance, on the writer side we could have two\n-\t     FUNCTION_DECLS T1 and T2 that are represented by the same\n-\t     builtin function.  The reader will only instantiate the\n-\t     canonical builtin, but since T1 and T2 had been\n-\t     originally stored in different cache slots (S1 and S2),\n-\t     the reader must be able to find the canonical builtin\n-\t     function at slots S1 and S2.  */\n-\t  gcc_assert (lto_stream_as_builtin_p (t));\n+\t     the requested location slot.  */\n \t  ix = *ix_p;\n-\n \t  lto_streamer_cache_add_to_node_array (cache, ix, t);\n \t}\n \n@@ -513,6 +502,8 @@ lto_record_common_node (tree *nodep, VEC(tree, heap) **common_nodes,\n \tTYPE_CANONICAL (node) = NULL_TREE;\n       node = gimple_register_type (node);\n       TYPE_CANONICAL (node) = gimple_register_canonical_type (node);\n+      if (in_lto_p)\n+\tTYPE_CANONICAL (*nodep) = TYPE_CANONICAL (node);\n       *nodep = node;\n     }\n "}, {"sha": "be3a873736aceb9d6dd4bd0ff44d42ce6464e6c5", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b823cdfe763c9784a8e9f7b86b8e91614c29de6c/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b823cdfe763c9784a8e9f7b86b8e91614c29de6c/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=b823cdfe763c9784a8e9f7b86b8e91614c29de6c", "patch": "@@ -1,3 +1,31 @@\n+2011-04-29  Michael Matz  <matz@suse.de>\n+\n+\t* lto.c (toplevel): Include tree-flow.h.\n+\t(lto_read_in_decl_state): Don't merge types here.\n+\t(tree_with_vars): New static hash table.\n+\t(remember_with_vars): New static functions.\n+\t(LTO_FIXUP_TYPE): New macro.\n+\t(lto_ft_common, lto_ft_decl_minimal, lto_ft_decl_common,\n+\tlto_ft_decl_with_vis, lto_ft_decl_non_common, lto_ft_function,\n+\tlto_ft_field_decl, lto_ft_type, lto_ft_binfo, lto_ft_constructor,\n+\tlto_ft_expr, lto_fixup_types, uniquify_nodes): New static functions.\n+\t(lto_read_decls): Uniquify while reading in trees.\n+\t(lto_fixup_data_t, LTO_FIXUP_SUBTREE,\n+\tLTO_REGISTER_TYPE_AND_FIXUP_SUBTREE, no_fixup_p, lto_fixup_common,\n+\tlto_fixup_decl_minimal, lto_fixup_decl_common, lto_fixup_decl_with_vis,\n+\tlto_fixup_decl_non_common, lto_fixup_function, lto_fixup_field_decl,\n+\tlto_fixup_type, lto_fixup_binfo, lto_fixup_constructor,\n+\tlto_fixup_tree): Remove.\n+\t(lto_fixup_state): Remove data argument.  Use\n+\tlto_symtab_prevailing_decl.\n+\t(LTO_SET_PREVAIL, LTO_NO_PREVAIL): New macros.\n+\t(lto_fixup_prevailing_decls): New function.\n+\t(lto_fixup_state_aux): Argument aux is unused.\n+\t(lto_fixup_decls): Don't allocate pointer sets, don't use\n+\tlto_fixup_tree, use lto_fixup_prevailing_decls.\n+\t(read_cgraph_and_symbols): Allocate and remove tree_with_vars.\n+\t* Make-lang.in (lto/lto.o): Depend on $(TREE_FLOW_H).\n+\n 2011-04-16  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* lto.c (lto_balanced_map): Fix typos in head comment."}, {"sha": "6b6930f25d98c368132f820a436efa353df73a1a", "filename": "gcc/lto/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b823cdfe763c9784a8e9f7b86b8e91614c29de6c/gcc%2Flto%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b823cdfe763c9784a8e9f7b86b8e91614c29de6c/gcc%2Flto%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FMake-lang.in?ref=b823cdfe763c9784a8e9f7b86b8e91614c29de6c", "patch": "@@ -81,7 +81,7 @@ lto/lto-lang.o: lto/lto-lang.c $(CONFIG_H) coretypes.h debug.h \\\n \t$(TARGET_H) $(LTO_H) $(GIMPLE_H) gtype-lto.h gt-lto-lto-lang.h \\\n \t$(EXPR_H) $(LTO_STREAMER_H)\n lto/lto.o: lto/lto.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(OPTS_H) \\\n-\ttoplev.h $(TREE_H) $(DIAGNOSTIC_CORE_H) $(TM_H) \\\n+\ttoplev.h $(TREE_H) $(TREE_FLOW_H) $(DIAGNOSTIC_CORE_H) $(TM_H) \\\n \t$(CGRAPH_H) $(GGC_H) tree-ssa-operands.h $(TREE_PASS_H) \\\n \tlanghooks.h $(VEC_H) $(BITMAP_H) pointer-set.h $(IPA_PROP_H) \\\n \t$(COMMON_H) debug.h $(TIMEVAR_H) $(GIMPLE_H) $(LTO_H) $(LTO_TREE_H) \\"}, {"sha": "d8e69c57e80a5c3af2717982b7855eb316b7d205", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 539, "deletions": 417, "changes": 956, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b823cdfe763c9784a8e9f7b86b8e91614c29de6c/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b823cdfe763c9784a8e9f7b86b8e91614c29de6c/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=b823cdfe763c9784a8e9f7b86b8e91614c29de6c", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"opts.h\"\n #include \"toplev.h\"\n #include \"tree.h\"\n+#include \"tree-flow.h\"\n #include \"diagnostic-core.h\"\n #include \"tm.h\"\n #include \"cgraph.h\"\n@@ -215,24 +216,452 @@ lto_read_in_decl_state (struct data_in *data_in, const uint32_t *data,\n       tree *decls = ggc_alloc_vec_tree (size);\n \n       for (j = 0; j < size; j++)\n+\tdecls[j] = lto_streamer_cache_get (data_in->reader_cache, data[j]);\n+\n+      state->streams[i].size = size;\n+      state->streams[i].trees = decls;\n+      data += size;\n+    }\n+\n+  return data;\n+}\n+\n+/* A hashtable of trees that potentially refer to variables or functions\n+   that must be replaced with their prevailing variant.  */\n+static GTY((if_marked (\"ggc_marked_p\"), param_is (union tree_node))) htab_t\n+  tree_with_vars;\n+\n+/* Remember that T is a tree that (potentially) refers to a variable\n+   or function decl that may be replaced with its prevailing variant.  */\n+static void\n+remember_with_vars (tree t)\n+{\n+  *(tree *) htab_find_slot (tree_with_vars, t, INSERT) = t;\n+}\n+\n+#define LTO_FIXUP_TREE(tt) \\\n+  do \\\n+    { \\\n+      if (tt) \\\n+\t{ \\\n+\t  if (TYPE_P (tt)) \\\n+\t    (tt) = gimple_register_type (tt); \\\n+\t  if (VAR_OR_FUNCTION_DECL_P (tt) && TREE_PUBLIC (tt)) \\\n+\t    remember_with_vars (t); \\\n+\t} \\\n+    } while (0)\n+\n+static void lto_fixup_types (tree);\n+\n+/* Fix up fields of a tree_common T.  */\n+\n+static void\n+lto_ft_common (tree t)\n+{\n+  /* The following re-creates the TYPE_REFERENCE_TO and TYPE_POINTER_TO\n+     lists.  We do not stream TYPE_REFERENCE_TO, TYPE_POINTER_TO or\n+     TYPE_NEXT_PTR_TO and TYPE_NEXT_REF_TO.\n+     First remove us from any pointer list we are on.  */\n+  if (TREE_CODE (t) == POINTER_TYPE)\n+    {\n+      if (TYPE_POINTER_TO (TREE_TYPE (t)) == t)\n+\tTYPE_POINTER_TO (TREE_TYPE (t)) = TYPE_NEXT_PTR_TO (t);\n+      else\n \t{\n-\t  decls[j] = lto_streamer_cache_get (data_in->reader_cache, data[j]);\n+\t  tree tem = TYPE_POINTER_TO (TREE_TYPE (t));\n+\t  while (tem && TYPE_NEXT_PTR_TO (tem) != t)\n+\t    tem = TYPE_NEXT_PTR_TO (tem);\n+\t  if (tem)\n+\t    TYPE_NEXT_PTR_TO (tem) = TYPE_NEXT_PTR_TO (t);\n+\t}\n+      TYPE_NEXT_PTR_TO (t) = NULL_TREE;\n+    }\n+  else if (TREE_CODE (t) == REFERENCE_TYPE)\n+    {\n+      if (TYPE_REFERENCE_TO (TREE_TYPE (t)) == t)\n+\tTYPE_REFERENCE_TO (TREE_TYPE (t)) = TYPE_NEXT_REF_TO (t);\n+      else\n+\t{\n+\t  tree tem = TYPE_REFERENCE_TO (TREE_TYPE (t));\n+\t  while (tem && TYPE_NEXT_REF_TO (tem) != t)\n+\t    tem = TYPE_NEXT_REF_TO (tem);\n+\t  if (tem)\n+\t    TYPE_NEXT_REF_TO (tem) = TYPE_NEXT_REF_TO (t);\n+\t}\n+      TYPE_NEXT_REF_TO (t) = NULL_TREE;\n+    }\n+\n+  /* Fixup our type.  */\n+  LTO_FIXUP_TREE (TREE_TYPE (t));\n+\n+  /* Second put us on the list of pointers of the new pointed-to type\n+     if we are a main variant.  This is done in lto_ft_type after\n+     fixing up our main variant.  */\n+  LTO_FIXUP_TREE (TREE_CHAIN (t));\n+}\n+\n+/* Fix up fields of a decl_minimal T.  */\n+\n+static void\n+lto_ft_decl_minimal (tree t)\n+{\n+  lto_ft_common (t);\n+  LTO_FIXUP_TREE (DECL_NAME (t));\n+  LTO_FIXUP_TREE (DECL_CONTEXT (t));\n+}\n+\n+/* Fix up fields of a decl_common T.  */\n+\n+static void\n+lto_ft_decl_common (tree t)\n+{\n+  lto_ft_decl_minimal (t);\n+  LTO_FIXUP_TREE (DECL_SIZE (t));\n+  LTO_FIXUP_TREE (DECL_SIZE_UNIT (t));\n+  LTO_FIXUP_TREE (DECL_INITIAL (t));\n+  LTO_FIXUP_TREE (DECL_ATTRIBUTES (t));\n+  LTO_FIXUP_TREE (DECL_ABSTRACT_ORIGIN (t));\n+}\n+\n+/* Fix up fields of a decl_with_vis T.  */\n+\n+static void\n+lto_ft_decl_with_vis (tree t)\n+{\n+  lto_ft_decl_common (t);\n+\n+  /* Accessor macro has side-effects, use field-name here. */\n+  LTO_FIXUP_TREE (t->decl_with_vis.assembler_name);\n+  LTO_FIXUP_TREE (DECL_SECTION_NAME (t));\n+}\n+\n+/* Fix up fields of a decl_non_common T.  */\n+\n+static void\n+lto_ft_decl_non_common (tree t)\n+{\n+  lto_ft_decl_with_vis (t);\n+  LTO_FIXUP_TREE (DECL_ARGUMENT_FLD (t));\n+  LTO_FIXUP_TREE (DECL_RESULT_FLD (t));\n+  LTO_FIXUP_TREE (DECL_VINDEX (t));\n+}\n+\n+/* Fix up fields of a decl_non_common T.  */\n+\n+static void\n+lto_ft_function (tree t)\n+{\n+  lto_ft_decl_non_common (t);\n+  LTO_FIXUP_TREE (DECL_FUNCTION_PERSONALITY (t));\n+}\n+\n+/* Fix up fields of a field_decl T.  */\n+\n+static void\n+lto_ft_field_decl (tree t)\n+{\n+  lto_ft_decl_common (t);\n+  LTO_FIXUP_TREE (DECL_FIELD_OFFSET (t));\n+  LTO_FIXUP_TREE (DECL_BIT_FIELD_TYPE (t));\n+  LTO_FIXUP_TREE (DECL_QUALIFIER (t));\n+  LTO_FIXUP_TREE (DECL_FIELD_BIT_OFFSET (t));\n+  LTO_FIXUP_TREE (DECL_FCONTEXT (t));\n+}\n+\n+/* Fix up fields of a type T.  */\n+\n+static void\n+lto_ft_type (tree t)\n+{\n+  tree tem, mv;\n+\n+  lto_ft_common (t);\n+  LTO_FIXUP_TREE (TYPE_CACHED_VALUES (t));\n+  LTO_FIXUP_TREE (TYPE_SIZE (t));\n+  LTO_FIXUP_TREE (TYPE_SIZE_UNIT (t));\n+  LTO_FIXUP_TREE (TYPE_ATTRIBUTES (t));\n+  LTO_FIXUP_TREE (TYPE_NAME (t));\n+\n+  /* Accessors are for derived node types only. */\n+  if (!POINTER_TYPE_P (t))\n+    LTO_FIXUP_TREE (t->type.minval);\n+  LTO_FIXUP_TREE (t->type.maxval);\n+\n+  /* Accessor is for derived node types only. */\n+  LTO_FIXUP_TREE (t->type.binfo);\n+\n+  LTO_FIXUP_TREE (TYPE_CONTEXT (t));\n+\n+  /* Compute the canonical type of t and fix that up.  From this point\n+     there are no longer any types with TYPE_STRUCTURAL_EQUALITY_P\n+     and its type-based alias problems.  */\n+  if (!TYPE_CANONICAL (t))\n+    {\n+      TYPE_CANONICAL (t) = gimple_register_canonical_type (t);\n+      LTO_FIXUP_TREE (TYPE_CANONICAL (t));\n+    }\n+\n+  /* The following re-creates proper variant lists while fixing up\n+     the variant leaders.  We do not stream TYPE_NEXT_VARIANT so the\n+     variant list state before fixup is broken.  */\n+\n+  /* Remove us from our main variant list if we are not the variant leader.  */\n+  if (TYPE_MAIN_VARIANT (t) != t)\n+    {\n+      tem = TYPE_MAIN_VARIANT (t);\n+      while (tem && TYPE_NEXT_VARIANT (tem) != t)\n+\ttem = TYPE_NEXT_VARIANT (tem);\n+      if (tem)\n+\tTYPE_NEXT_VARIANT (tem) = TYPE_NEXT_VARIANT (t);\n+      TYPE_NEXT_VARIANT (t) = NULL_TREE;\n+    }\n+\n+  /* Query our new main variant.  */\n+  mv = gimple_register_type (TYPE_MAIN_VARIANT (t));\n+\n+  /* If we were the variant leader and we get replaced ourselves drop\n+     all variants from our list.  */\n+  if (TYPE_MAIN_VARIANT (t) == t\n+      && mv != t)\n+    {\n+      tem = t;\n+      while (tem)\n+\t{\n+\t  tree tem2 = TYPE_NEXT_VARIANT (tem);\n+\t  TYPE_NEXT_VARIANT (tem) = NULL_TREE;\n+\t  tem = tem2;\n+\t}\n+    }\n+\n+  /* Finally adjust our main variant and fix it up.  */\n+  TYPE_MAIN_VARIANT (t) = mv;\n+  LTO_FIXUP_TREE (TYPE_MAIN_VARIANT (t));\n+\n+  /* As the second step of reconstructing the pointer chains put us\n+     on the list of pointers of the new pointed-to type\n+     if we are a main variant.  See lto_ft_common for the first step.  */\n+  if (TREE_CODE (t) == POINTER_TYPE\n+      && TYPE_MAIN_VARIANT (t) == t)\n+    {\n+      TYPE_NEXT_PTR_TO (t) = TYPE_POINTER_TO (TREE_TYPE (t));\n+      TYPE_POINTER_TO (TREE_TYPE (t)) = t;\n+    }\n+  else if (TREE_CODE (t) == REFERENCE_TYPE\n+\t   && TYPE_MAIN_VARIANT (t) == t)\n+    {\n+      TYPE_NEXT_REF_TO (t) = TYPE_REFERENCE_TO (TREE_TYPE (t));\n+      TYPE_REFERENCE_TO (TREE_TYPE (t)) = t;\n+    }\n+}\n+\n+/* Fix up fields of a BINFO T.  */\n+\n+static void\n+lto_ft_binfo (tree t)\n+{\n+  unsigned HOST_WIDE_INT i, n;\n+  tree base, saved_base;\n+\n+  lto_ft_common (t);\n+  LTO_FIXUP_TREE (BINFO_VTABLE (t));\n+  LTO_FIXUP_TREE (BINFO_OFFSET (t));\n+  LTO_FIXUP_TREE (BINFO_VIRTUALS (t));\n+  LTO_FIXUP_TREE (BINFO_VPTR_FIELD (t));\n+  n = VEC_length (tree, BINFO_BASE_ACCESSES (t));\n+  for (i = 0; i < n; i++)\n+    {\n+      saved_base = base = BINFO_BASE_ACCESS (t, i);\n+      LTO_FIXUP_TREE (base);\n+      if (base != saved_base)\n+\tVEC_replace (tree, BINFO_BASE_ACCESSES (t), i, base);\n+    }\n+  LTO_FIXUP_TREE (BINFO_INHERITANCE_CHAIN (t));\n+  LTO_FIXUP_TREE (BINFO_SUBVTT_INDEX (t));\n+  LTO_FIXUP_TREE (BINFO_VPTR_INDEX (t));\n+  n = BINFO_N_BASE_BINFOS (t);\n+  for (i = 0; i < n; i++)\n+    {\n+      saved_base = base = BINFO_BASE_BINFO (t, i);\n+      LTO_FIXUP_TREE (base);\n+      if (base != saved_base)\n+\tVEC_replace (tree, BINFO_BASE_BINFOS (t), i, base);\n+    }\n+}\n+\n+/* Fix up fields of a CONSTRUCTOR T.  */\n+\n+static void\n+lto_ft_constructor (tree t)\n+{\n+  unsigned HOST_WIDE_INT idx;\n+  constructor_elt *ce;\n+\n+  LTO_FIXUP_TREE (TREE_TYPE (t));\n+\n+  for (idx = 0;\n+       VEC_iterate(constructor_elt, CONSTRUCTOR_ELTS (t), idx, ce);\n+       idx++)\n+    {\n+      LTO_FIXUP_TREE (ce->index);\n+      LTO_FIXUP_TREE (ce->value);\n+    }\n+}\n+\n+/* Fix up fields of an expression tree T.  */\n+\n+static void\n+lto_ft_expr (tree t)\n+{\n+  int i;\n+  lto_ft_common (t);\n+  for (i = TREE_OPERAND_LENGTH (t) - 1; i >= 0; --i)\n+    LTO_FIXUP_TREE (TREE_OPERAND (t, i));\n+}\n+\n+/* Given a tree T fixup fields of T by replacing types with their merged\n+   variant and other entities by an equal entity from an earlier compilation\n+   unit, or an entity being canonical in a different way.  This includes\n+   for instance integer or string constants.  */\n+\n+static void\n+lto_fixup_types (tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case IDENTIFIER_NODE:\n+      break;\n+\n+    case TREE_LIST:\n+      LTO_FIXUP_TREE (TREE_VALUE (t));\n+      LTO_FIXUP_TREE (TREE_PURPOSE (t));\n+      LTO_FIXUP_TREE (TREE_CHAIN (t));\n+      break;\n+\n+    case FIELD_DECL:\n+      lto_ft_field_decl (t);\n+      break;\n+\n+    case LABEL_DECL:\n+    case CONST_DECL:\n+    case PARM_DECL:\n+    case RESULT_DECL:\n+    case IMPORTED_DECL:\n+      lto_ft_decl_common (t);\n+      break;\n+\n+    case VAR_DECL:\n+      lto_ft_decl_with_vis (t);\n+      break;\n+\n+    case TYPE_DECL:\n+      lto_ft_decl_non_common (t);\n+      break;\n+\n+    case FUNCTION_DECL:\n+      lto_ft_function (t);\n+      break;\n+\n+    case TREE_BINFO:\n+      lto_ft_binfo (t);\n+      break;\n+\n+    case PLACEHOLDER_EXPR:\n+      lto_ft_common (t);\n+      break;\n+\n+    case BLOCK:\n+    case TRANSLATION_UNIT_DECL:\n+    case OPTIMIZATION_NODE:\n+    case TARGET_OPTION_NODE:\n+      break;\n+\n+    default:\n+      if (TYPE_P (t))\n+\tlto_ft_type (t);\n+      else if (TREE_CODE (t) == CONSTRUCTOR)\n+\tlto_ft_constructor (t);\n+      else if (CONSTANT_CLASS_P (t))\n+\tLTO_FIXUP_TREE (TREE_TYPE (t));\n+      else if (EXPR_P (t))\n+\t{\n+\t  lto_ft_expr (t);\n+\t}\n+      else\n+\t{\n+\t  remember_with_vars (t);\n+\t}\n+    }\n+}\n+\n+/* Given a streamer cache structure DATA_IN (holding a sequence of trees\n+   for one compilation unit) go over all trees starting at index FROM until the\n+   end of the sequence and replace fields of those trees, and the trees\n+   themself with their canonical variants as per gimple_register_type.  */\n+\n+static void\n+uniquify_nodes (struct data_in *data_in, unsigned from)\n+{\n+  struct lto_streamer_cache_d *cache = data_in->reader_cache;\n+  unsigned len = VEC_length (tree, cache->nodes);\n+  unsigned i;\n+  /* Go backwards because childs streamed for the first time come\n+     as part of their parents, and hence are created after them.  */\n+  for (i = len; i-- > from;)\n+    {\n+      tree t = VEC_index (tree, cache->nodes, i);\n+      tree oldt = t;\n+      if (!t)\n+\tcontinue;\n+\n+      /* First fixup the fields of T.  */\n+      lto_fixup_types (t);\n+\n+      /* Now try to find a canonical variant of T itself.  */\n+      if (TYPE_P (t))\n+\t{\n+\t  t = gimple_register_type (t);\n+\t  if (t == oldt\n+\t      && TYPE_MAIN_VARIANT (t) != t)\n+\t    {\n+\t      /* If this is its own type, link it into the variant chain.  */\n+\t      TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (TYPE_MAIN_VARIANT (t));\n+\t      TYPE_NEXT_VARIANT (TYPE_MAIN_VARIANT (t)) = t;\n+\t    }\n+\t}\n+      if (t != oldt)\n+\t{\n+\t  if (RECORD_OR_UNION_TYPE_P (t))\n+\t    {\n+\t      tree f1, f2;\n+\t      if (TYPE_FIELDS (t) != TYPE_FIELDS (oldt))\n+\t\tfor (f1 = TYPE_FIELDS (t), f2 = TYPE_FIELDS (oldt);\n+\t\t     f1 && f2; f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n+\t\t  {\n+\t\t    unsigned ix;\n+\t\t    gcc_assert (f1 != f2 && DECL_NAME (f1) == DECL_NAME (f2));\n+\t\t    if (!lto_streamer_cache_lookup (cache, f2, &ix))\n+\t\t      gcc_unreachable ();\n+\t\t    /* If we're going to replace an element which we'd\n+\t\t       still visit in the next iterations, we wouldn't\n+\t\t       handle it, so do it here.  We do have to handle it\n+\t\t       even though the field_decl itself will be removed,\n+\t\t       as it could refer to e.g. integer_cst which we\n+\t\t       wouldn't reach via any other way, hence they\n+\t\t       (and their type) would stay uncollected.  */\n+\t\t    if (ix < i)\n+\t\t      lto_fixup_types (f2);\n+\t\t    lto_streamer_cache_insert_at (cache, f1, ix);\n+\t\t  }\n+\t    }\n \n-\t  /* Register every type in the global type table.  If the\n-\t     type existed already, use the existing type.  */\n-\t  if (TYPE_P (decls[j]))\n-\t    decls[j] = gimple_register_type (decls[j]);\n+\t  /* If we found a tree that is equal to oldt replace it in the\n+\t     cache, so that further users (in the various LTO sections)\n+\t     make use of it.  */\n+\t  lto_streamer_cache_insert_at (cache, t, i);\n \t}\n-\n-      state->streams[i].size = size;\n-      state->streams[i].trees = decls;\n-      data += size;\n     }\n-\n-  return data;\n }\n \n-\n /* Read all the symbols from buffer DATA, using descriptors in DECL_DATA.\n    RESOLUTIONS is the set of symbols picked by the linker (read from the\n    resolution file when the linker plugin is being used).  */\n@@ -260,8 +689,11 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n   /* Read the global declarations and types.  */\n   while (ib_main.p < ib_main.len)\n     {\n-      tree t = lto_input_tree (&ib_main, data_in);\n+      tree t;\n+      unsigned from = VEC_length (tree, data_in->reader_cache->nodes);\n+      t = lto_input_tree (&ib_main, data_in);\n       gcc_assert (t && ib_main.p <= ib_main.len);\n+      uniquify_nodes (data_in, from);\n     }\n \n   /* Read in lto_in_decl_state objects.  */\n@@ -1514,7 +1946,7 @@ lto_wpa_write_files (void)\n \tfprintf (stderr, \" %s (%s %i insns)\", temp_filename, part->name, part->insns);\n       if (cgraph_dump_file)\n \t{\n-\t  fprintf (cgraph_dump_file, \"Writting partition %s to file %s, %i insns\\n\",\n+\t  fprintf (cgraph_dump_file, \"Writing partition %s to file %s, %i insns\\n\",\n \t\t   part->name, temp_filename, part->insns);\n \t  fprintf (cgraph_dump_file, \"cgraph nodes:\");\n \t  dump_cgraph_node_set (cgraph_dump_file, set);\n@@ -1548,416 +1980,106 @@ lto_wpa_write_files (void)\n }\n \n \n-typedef struct {\n-  struct pointer_set_t *seen;\n-} lto_fixup_data_t;\n-\n-#define LTO_FIXUP_SUBTREE(t) \\\n-  do \\\n-    walk_tree (&(t), lto_fixup_tree, data, NULL); \\\n-  while (0)\n-\n-#define LTO_REGISTER_TYPE_AND_FIXUP_SUBTREE(t) \\\n-  do \\\n-    { \\\n-      if (t) \\\n-\t(t) = gimple_register_type (t); \\\n-      walk_tree (&(t), lto_fixup_tree, data, NULL); \\\n-    } \\\n-  while (0)\n-\n-static tree lto_fixup_tree (tree *, int *, void *);\n-\n-/* Return true if T does not need to be fixed up recursively.  */\n-\n-static inline bool\n-no_fixup_p (tree t)\n-{\n-  return (t == NULL\n-\t  || CONSTANT_CLASS_P (t)\n-\t  || TREE_CODE (t) == IDENTIFIER_NODE);\n-}\n+/* If TT is a variable or function decl replace it with its\n+   prevailing variant.  */\n+#define LTO_SET_PREVAIL(tt) \\\n+  do {\\\n+    if ((tt) && VAR_OR_FUNCTION_DECL_P (tt)) \\\n+      tt = lto_symtab_prevailing_decl (tt); \\\n+  } while (0)\n \n-/* Fix up fields of a tree_common T.  DATA points to fix-up states.  */\n+/* Ensure that TT isn't a replacable var of function decl.  */\n+#define LTO_NO_PREVAIL(tt) \\\n+  gcc_assert (!(tt) || !VAR_OR_FUNCTION_DECL_P (tt))\n \n+/* Given a tree T replace all fields referring to variables or functions\n+   with their prevailing variant.  */\n static void\n-lto_fixup_common (tree t, void *data)\n+lto_fixup_prevailing_decls (tree t)\n {\n-  /* The following re-creates the TYPE_REFERENCE_TO and TYPE_POINTER_TO\n-     lists.  We do not stream TYPE_REFERENCE_TO, TYPE_POINTER_TO or\n-     TYPE_NEXT_PTR_TO and TYPE_NEXT_REF_TO.\n-     First remove us from any pointer list we are on.  */\n-  if (TREE_CODE (t) == POINTER_TYPE)\n+  enum tree_code code = TREE_CODE (t);\n+  LTO_NO_PREVAIL (TREE_TYPE (t));\n+  LTO_NO_PREVAIL (TREE_CHAIN (t));\n+  if (DECL_P (t))\n     {\n-      if (TYPE_POINTER_TO (TREE_TYPE (t)) == t)\n-\tTYPE_POINTER_TO (TREE_TYPE (t)) = TYPE_NEXT_PTR_TO (t);\n-      else\n+      LTO_NO_PREVAIL (DECL_NAME (t));\n+      LTO_SET_PREVAIL (DECL_CONTEXT (t));\n+      if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n \t{\n-\t  tree tem = TYPE_POINTER_TO (TREE_TYPE (t));\n-\t  while (tem && TYPE_NEXT_PTR_TO (tem) != t)\n-\t    tem = TYPE_NEXT_PTR_TO (tem);\n-\t  if (tem)\n-\t    TYPE_NEXT_PTR_TO (tem) = TYPE_NEXT_PTR_TO (t);\n+\t  LTO_SET_PREVAIL (DECL_SIZE (t));\n+\t  LTO_SET_PREVAIL (DECL_SIZE_UNIT (t));\n+\t  LTO_SET_PREVAIL (DECL_INITIAL (t));\n+\t  LTO_NO_PREVAIL (DECL_ATTRIBUTES (t));\n+\t  LTO_SET_PREVAIL (DECL_ABSTRACT_ORIGIN (t));\n \t}\n-      TYPE_NEXT_PTR_TO (t) = NULL_TREE;\n-    }\n-  else if (TREE_CODE (t) == REFERENCE_TYPE)\n-    {\n-      if (TYPE_REFERENCE_TO (TREE_TYPE (t)) == t)\n-\tTYPE_REFERENCE_TO (TREE_TYPE (t)) = TYPE_NEXT_REF_TO (t);\n-      else\n+      if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n \t{\n-\t  tree tem = TYPE_REFERENCE_TO (TREE_TYPE (t));\n-\t  while (tem && TYPE_NEXT_REF_TO (tem) != t)\n-\t    tem = TYPE_NEXT_REF_TO (tem);\n-\t  if (tem)\n-\t    TYPE_NEXT_REF_TO (tem) = TYPE_NEXT_REF_TO (t);\n+\t  LTO_NO_PREVAIL (t->decl_with_vis.assembler_name);\n+\t  LTO_NO_PREVAIL (DECL_SECTION_NAME (t));\n \t}\n-      TYPE_NEXT_REF_TO (t) = NULL_TREE;\n-    }\n-\n-  /* Fixup our type.  */\n-  LTO_REGISTER_TYPE_AND_FIXUP_SUBTREE (TREE_TYPE (t));\n-\n-  /* Second put us on the list of pointers of the new pointed-to type\n-     if we are a main variant.  This is done in lto_fixup_type after\n-     fixing up our main variant.  */\n-\n-  /* This is not very efficient because we cannot do tail-recursion with\n-     a long chain of trees. */\n-  if (CODE_CONTAINS_STRUCT (TREE_CODE (t), TS_COMMON))\n-    LTO_FIXUP_SUBTREE (TREE_CHAIN (t));\n-}\n-\n-/* Fix up fields of a decl_minimal T.  DATA points to fix-up states.  */\n-\n-static void\n-lto_fixup_decl_minimal (tree t, void *data)\n-{\n-  lto_fixup_common (t, data);\n-  LTO_FIXUP_SUBTREE (DECL_NAME (t));\n-  LTO_FIXUP_SUBTREE (DECL_CONTEXT (t));\n-}\n-\n-/* Fix up fields of a decl_common T.  DATA points to fix-up states.  */\n-\n-static void\n-lto_fixup_decl_common (tree t, void *data)\n-{\n-  lto_fixup_decl_minimal (t, data);\n-  LTO_FIXUP_SUBTREE (DECL_SIZE (t));\n-  LTO_FIXUP_SUBTREE (DECL_SIZE_UNIT (t));\n-  LTO_FIXUP_SUBTREE (DECL_INITIAL (t));\n-  LTO_FIXUP_SUBTREE (DECL_ATTRIBUTES (t));\n-  LTO_FIXUP_SUBTREE (DECL_ABSTRACT_ORIGIN (t));\n-}\n-\n-/* Fix up fields of a decl_with_vis T.  DATA points to fix-up states.  */\n-\n-static void\n-lto_fixup_decl_with_vis (tree t, void *data)\n-{\n-  lto_fixup_decl_common (t, data);\n-\n-  /* Accessor macro has side-effects, use field-name here. */\n-  LTO_FIXUP_SUBTREE (t->decl_with_vis.assembler_name);\n-\n-  gcc_assert (no_fixup_p (DECL_SECTION_NAME (t)));\n-}\n-\n-/* Fix up fields of a decl_non_common T.  DATA points to fix-up states.  */\n-\n-static void\n-lto_fixup_decl_non_common (tree t, void *data)\n-{\n-  lto_fixup_decl_with_vis (t, data);\n-  LTO_FIXUP_SUBTREE (DECL_ARGUMENT_FLD (t));\n-  LTO_FIXUP_SUBTREE (DECL_RESULT_FLD (t));\n-  LTO_FIXUP_SUBTREE (DECL_VINDEX (t));\n-\n-  /* SAVED_TREE should not cleared by now.  Also no accessor for base type. */\n-  gcc_assert (no_fixup_p (t->decl_non_common.saved_tree));\n-}\n-\n-/* Fix up fields of a decl_non_common T.  DATA points to fix-up states.  */\n-\n-static void\n-lto_fixup_function (tree t, void *data)\n-{\n-  lto_fixup_decl_non_common (t, data);\n-  LTO_FIXUP_SUBTREE (DECL_FUNCTION_PERSONALITY (t));\n-}\n-\n-/* Fix up fields of a field_decl T.  DATA points to fix-up states.  */\n-\n-static void\n-lto_fixup_field_decl (tree t, void *data)\n-{\n-  lto_fixup_decl_common (t, data);\n-  LTO_FIXUP_SUBTREE (DECL_FIELD_OFFSET (t));\n-  LTO_FIXUP_SUBTREE (DECL_BIT_FIELD_TYPE (t));\n-  LTO_FIXUP_SUBTREE (DECL_QUALIFIER (t));\n-  gcc_assert (no_fixup_p (DECL_FIELD_BIT_OFFSET (t)));\n-  LTO_FIXUP_SUBTREE (DECL_FCONTEXT (t));\n-}\n-\n-/* Fix up fields of a type T.  DATA points to fix-up states.  */\n-\n-static void\n-lto_fixup_type (tree t, void *data)\n-{\n-  tree tem, mv;\n-\n-  lto_fixup_common (t, data);\n-  LTO_FIXUP_SUBTREE (TYPE_CACHED_VALUES (t));\n-  LTO_FIXUP_SUBTREE (TYPE_SIZE (t));\n-  LTO_FIXUP_SUBTREE (TYPE_SIZE_UNIT (t));\n-  LTO_FIXUP_SUBTREE (TYPE_ATTRIBUTES (t));\n-  LTO_FIXUP_SUBTREE (TYPE_NAME (t));\n-\n-  /* Accessors are for derived node types only. */\n-  if (!POINTER_TYPE_P (t))\n-    LTO_FIXUP_SUBTREE (t->type.minval);\n-  LTO_FIXUP_SUBTREE (t->type.maxval);\n-\n-  /* Accessor is for derived node types only. */\n-  LTO_FIXUP_SUBTREE (t->type.binfo);\n-\n-  if (TYPE_CONTEXT (t))\n-    {\n-      if (TYPE_P (TYPE_CONTEXT (t)))\n-\tLTO_REGISTER_TYPE_AND_FIXUP_SUBTREE (TYPE_CONTEXT (t));\n-      else\n-\tLTO_FIXUP_SUBTREE (TYPE_CONTEXT (t));\n-    }\n-\n-  /* Compute the canonical type of t and fix that up.  From this point\n-     there are no longer any types with TYPE_STRUCTURAL_EQUALITY_P\n-     and its type-based alias problems.  */\n-  if (!TYPE_CANONICAL (t))\n-    {\n-      TYPE_CANONICAL (t) = gimple_register_canonical_type (t);\n-      LTO_FIXUP_SUBTREE (TYPE_CANONICAL (t));\n-    }\n-\n-  /* The following re-creates proper variant lists while fixing up\n-     the variant leaders.  We do not stream TYPE_NEXT_VARIANT so the\n-     variant list state before fixup is broken.  */\n-\n-  /* Remove us from our main variant list if we are not the variant leader.  */\n-  if (TYPE_MAIN_VARIANT (t) != t)\n-    {\n-      tem = TYPE_MAIN_VARIANT (t);\n-      while (tem && TYPE_NEXT_VARIANT (tem) != t)\n-\ttem = TYPE_NEXT_VARIANT (tem);\n-      if (tem)\n-\tTYPE_NEXT_VARIANT (tem) = TYPE_NEXT_VARIANT (t);\n-      TYPE_NEXT_VARIANT (t) = NULL_TREE;\n-    }\n-\n-  /* Query our new main variant.  */\n-  mv = gimple_register_type (TYPE_MAIN_VARIANT (t));\n-\n-  /* If we were the variant leader and we get replaced ourselves drop\n-     all variants from our list.  */\n-  if (TYPE_MAIN_VARIANT (t) == t\n-      && mv != t)\n-    {\n-      tem = t;\n-      while (tem)\n+      if (CODE_CONTAINS_STRUCT (code, TS_DECL_NON_COMMON))\n \t{\n-\t  tree tem2 = TYPE_NEXT_VARIANT (tem);\n-\t  TYPE_NEXT_VARIANT (tem) = NULL_TREE;\n-\t  tem = tem2;\n+\t  LTO_NO_PREVAIL (DECL_ARGUMENT_FLD (t));\n+\t  LTO_NO_PREVAIL (DECL_RESULT_FLD (t));\n+\t  LTO_NO_PREVAIL (DECL_VINDEX (t));\n+\t}\n+      if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n+\tLTO_SET_PREVAIL (DECL_FUNCTION_PERSONALITY (t));\n+      if (CODE_CONTAINS_STRUCT (code, TS_FIELD_DECL))\n+\t{\n+\t  LTO_NO_PREVAIL (DECL_FIELD_OFFSET (t));\n+\t  LTO_NO_PREVAIL (DECL_BIT_FIELD_TYPE (t));\n+\t  LTO_NO_PREVAIL (DECL_QUALIFIER (t));\n+\t  LTO_NO_PREVAIL (DECL_FIELD_BIT_OFFSET (t));\n+\t  LTO_NO_PREVAIL (DECL_FCONTEXT (t));\n \t}\n     }\n-\n-  /* If we are not our own variant leader link us into our new leaders\n-     variant list.  */\n-  if (mv != t)\n-    {\n-      TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (mv);\n-      TYPE_NEXT_VARIANT (mv) = t;\n-    }\n-\n-  /* Finally adjust our main variant and fix it up.  */\n-  TYPE_MAIN_VARIANT (t) = mv;\n-  LTO_FIXUP_SUBTREE (TYPE_MAIN_VARIANT (t));\n-\n-  /* As the second step of reconstructing the pointer chains put us\n-     on the list of pointers of the new pointed-to type\n-     if we are a main variant.  See lto_fixup_common for the first step.  */\n-  if (TREE_CODE (t) == POINTER_TYPE\n-      && TYPE_MAIN_VARIANT (t) == t)\n-    {\n-      TYPE_NEXT_PTR_TO (t) = TYPE_POINTER_TO (TREE_TYPE (t));\n-      TYPE_POINTER_TO (TREE_TYPE (t)) = t;\n-    }\n-  else if (TREE_CODE (t) == REFERENCE_TYPE\n-\t   && TYPE_MAIN_VARIANT (t) == t)\n-    {\n-      TYPE_NEXT_REF_TO (t) = TYPE_REFERENCE_TO (TREE_TYPE (t));\n-      TYPE_REFERENCE_TO (TREE_TYPE (t)) = t;\n-    }\n-}\n-\n-/* Fix up fields of a BINFO T.  DATA points to fix-up states.  */\n-\n-static void\n-lto_fixup_binfo (tree t, void *data)\n-{\n-  unsigned HOST_WIDE_INT i, n;\n-  tree base, saved_base;\n-\n-  lto_fixup_common (t, data);\n-  gcc_assert (no_fixup_p (BINFO_OFFSET (t)));\n-  LTO_FIXUP_SUBTREE (BINFO_VTABLE (t));\n-  LTO_FIXUP_SUBTREE (BINFO_VIRTUALS (t));\n-  LTO_FIXUP_SUBTREE (BINFO_VPTR_FIELD (t));\n-  n = VEC_length (tree, BINFO_BASE_ACCESSES (t));\n-  for (i = 0; i < n; i++)\n-    {\n-      saved_base = base = BINFO_BASE_ACCESS (t, i);\n-      LTO_FIXUP_SUBTREE (base);\n-      if (base != saved_base)\n-\tVEC_replace (tree, BINFO_BASE_ACCESSES (t), i, base);\n-    }\n-  LTO_FIXUP_SUBTREE (BINFO_INHERITANCE_CHAIN (t));\n-  LTO_FIXUP_SUBTREE (BINFO_SUBVTT_INDEX (t));\n-  LTO_FIXUP_SUBTREE (BINFO_VPTR_INDEX (t));\n-  n = BINFO_N_BASE_BINFOS (t);\n-  for (i = 0; i < n; i++)\n-    {\n-      saved_base = base = BINFO_BASE_BINFO (t, i);\n-      LTO_FIXUP_SUBTREE (base);\n-      if (base != saved_base)\n-\tVEC_replace (tree, BINFO_BASE_BINFOS (t), i, base);\n-    }\n-}\n-\n-/* Fix up fields of a CONSTRUCTOR T.  DATA points to fix-up states.  */\n-\n-static void\n-lto_fixup_constructor (tree t, void *data)\n-{\n-  unsigned HOST_WIDE_INT idx;\n-  constructor_elt *ce;\n-\n-  LTO_REGISTER_TYPE_AND_FIXUP_SUBTREE (TREE_TYPE (t));\n-\n-  for (idx = 0;\n-       VEC_iterate(constructor_elt, CONSTRUCTOR_ELTS (t), idx, ce);\n-       idx++)\n+  else if (TYPE_P (t))\n     {\n-      LTO_FIXUP_SUBTREE (ce->index);\n-      LTO_FIXUP_SUBTREE (ce->value);\n-    }\n-}\n+      LTO_NO_PREVAIL (TYPE_CACHED_VALUES (t));\n+      LTO_SET_PREVAIL (TYPE_SIZE (t));\n+      LTO_SET_PREVAIL (TYPE_SIZE_UNIT (t));\n+      LTO_NO_PREVAIL (TYPE_ATTRIBUTES (t));\n+      LTO_NO_PREVAIL (TYPE_NAME (t));\n \n-/* A walk_tree callback used by lto_fixup_state. TP is the pointer to the\n-   current tree. WALK_SUBTREES indicates if the subtrees will be walked.\n-   DATA is a pointer set to record visited nodes. */\n+      LTO_SET_PREVAIL (t->type.minval);\n+      LTO_SET_PREVAIL (t->type.maxval);\n+      LTO_SET_PREVAIL (t->type.binfo);\n \n-static tree\n-lto_fixup_tree (tree *tp, int *walk_subtrees, void *data)\n-{\n-  tree t;\n-  lto_fixup_data_t *fixup_data = (lto_fixup_data_t *) data;\n-  tree prevailing;\n-\n-  t = *tp;\n-  *walk_subtrees = 0;\n-  if (!t || pointer_set_contains (fixup_data->seen, t))\n-    return NULL;\n+      LTO_SET_PREVAIL (TYPE_CONTEXT (t));\n \n-  if (TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == FUNCTION_DECL)\n-    {\n-      prevailing = lto_symtab_prevailing_decl (t);\n-\n-      if (t != prevailing)\n-\t{\n-\t   /* Also replace t with prevailing defintion.  We don't want to\n-\t      insert the other defintion in the seen set as we want to\n-\t      replace all instances of it.  */\n-\t  *tp = prevailing;\n-\t  t = prevailing;\n-\t}\n+      LTO_NO_PREVAIL (TYPE_CANONICAL (t));\n+      LTO_NO_PREVAIL (TYPE_MAIN_VARIANT (t));\n+      LTO_NO_PREVAIL (TYPE_NEXT_VARIANT (t));\n     }\n-  else if (TYPE_P (t))\n+  else if (EXPR_P (t))\n     {\n-      /* Replace t with the prevailing type.  We don't want to insert the\n-         other type in the seen set as we want to replace all instances of it.  */\n-      t = gimple_register_type (t);\n-      *tp = t;\n+      int i;\n+      LTO_NO_PREVAIL (t->exp.block);\n+      for (i = TREE_OPERAND_LENGTH (t) - 1; i >= 0; --i)\n+\tLTO_SET_PREVAIL (TREE_OPERAND (t, i));\n     }\n-\n-  if (pointer_set_insert (fixup_data->seen, t))\n-    return NULL;\n-\n-  /* walk_tree does not visit all reachable nodes that need to be fixed up.\n-     Hence we do special processing here for those kind of nodes. */\n-  switch (TREE_CODE (t))\n+  else\n     {\n-    case FIELD_DECL:\n-      lto_fixup_field_decl (t, data);\n-      break;\n-\n-    case LABEL_DECL:\n-    case CONST_DECL:\n-    case PARM_DECL:\n-    case RESULT_DECL:\n-    case IMPORTED_DECL:\n-      lto_fixup_decl_common (t, data);\n-      break;\n-\n-    case VAR_DECL:\n-      lto_fixup_decl_with_vis (t, data);\n-      break;\t\n-\n-    case TYPE_DECL:\n-      lto_fixup_decl_non_common (t, data);\n-      break;\n-\n-    case FUNCTION_DECL:\n-      lto_fixup_function (t, data);\n-      break;\n-\n-    case TREE_BINFO:\n-      lto_fixup_binfo (t, data);\n-      break;\n-\n-    default:\n-      if (TYPE_P (t))\n-\tlto_fixup_type (t, data);\n-      else if (TREE_CODE (t) == CONSTRUCTOR)\n-\tlto_fixup_constructor (t, data);\n-      else if (CONSTANT_CLASS_P (t))\n-\tLTO_REGISTER_TYPE_AND_FIXUP_SUBTREE (TREE_TYPE (t));\n-      else if (EXPR_P (t))\n+      switch (code)\n \t{\n-\t  /* walk_tree only handles TREE_OPERANDs. Do the rest here.  */\n-\t  lto_fixup_common (t, data);\n-\t  LTO_FIXUP_SUBTREE (t->exp.block);\n-\t  *walk_subtrees = 1;\n-\t}\n-      else\n-\t{\n-\t  /* Let walk_tree handle sub-trees.  */\n-\t  *walk_subtrees = 1;\n+\tcase TREE_LIST:\n+\t  LTO_SET_PREVAIL (TREE_VALUE (t));\n+\t  LTO_SET_PREVAIL (TREE_PURPOSE (t));\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n     }\n-\n-  return NULL;\n }\n+#undef LTO_SET_PREVAIL\n+#undef LTO_NO_PREVAIL\n \n /* Helper function of lto_fixup_decls. Walks the var and fn streams in STATE,\n-   replaces var and function decls with the corresponding prevailing def and\n-   records the old decl in the free-list in DATA. We also record visted nodes\n-   in the seen-set in DATA to avoid multiple visit for nodes that need not\n-   to be replaced.  */\n+   replaces var and function decls with the corresponding prevailing def.  */\n \n static void\n-lto_fixup_state (struct lto_in_decl_state *state, lto_fixup_data_t *data)\n+lto_fixup_state (struct lto_in_decl_state *state)\n {\n   unsigned i, si;\n   struct lto_tree_ref_table *table;\n@@ -1969,18 +2091,22 @@ lto_fixup_state (struct lto_in_decl_state *state, lto_fixup_data_t *data)\n     {\n       table = &state->streams[si];\n       for (i = 0; i < table->size; i++)\n-\twalk_tree (table->trees + i, lto_fixup_tree, data, NULL);\n+\t{\n+\t  tree *tp = table->trees + i;\n+\t  if (VAR_OR_FUNCTION_DECL_P (*tp))\n+\t    *tp = lto_symtab_prevailing_decl (*tp);\n+\t}\n     }\n }\n \n-/* A callback of htab_traverse. Just extract a state from SLOT and the\n-   lto_fixup_data_t object from AUX and calls lto_fixup_state. */\n+/* A callback of htab_traverse. Just extracts a state from SLOT\n+   and calls lto_fixup_state. */\n \n static int\n-lto_fixup_state_aux (void **slot, void *aux)\n+lto_fixup_state_aux (void **slot, void *aux ATTRIBUTE_UNUSED)\n {\n   struct lto_in_decl_state *state = (struct lto_in_decl_state *) *slot;\n-  lto_fixup_state (state, (lto_fixup_data_t *) aux);\n+  lto_fixup_state (state);\n   return 1;\n }\n \n@@ -1991,29 +2117,20 @@ static void\n lto_fixup_decls (struct lto_file_decl_data **files)\n {\n   unsigned int i;\n-  tree decl;\n-  struct pointer_set_t *seen = pointer_set_create ();\n-  lto_fixup_data_t data;\n+  htab_iterator hi;\n+  tree t;\n+\n+  FOR_EACH_HTAB_ELEMENT (tree_with_vars, t, tree, hi)\n+    lto_fixup_prevailing_decls (t);\n \n-  data.seen = seen;\n   for (i = 0; files[i]; i++)\n     {\n       struct lto_file_decl_data *file = files[i];\n       struct lto_in_decl_state *state = file->global_decl_state;\n-      lto_fixup_state (state, &data);\n-\n-      htab_traverse (file->function_decl_states, lto_fixup_state_aux, &data);\n-    }\n+      lto_fixup_state (state);\n \n-  FOR_EACH_VEC_ELT (tree, lto_global_var_decls, i, decl)\n-    {\n-      tree saved_decl = decl;\n-      walk_tree (&decl, lto_fixup_tree, &data, NULL);\n-      if (decl != saved_decl)\n-\tVEC_replace (tree, lto_global_var_decls, i, decl);\n+      htab_traverse (file->function_decl_states, lto_fixup_state_aux, NULL);\n     }\n-\n-  pointer_set_destroy (seen);\n }\n \n /* Read the options saved from each file in the command line.  Called\n@@ -2144,6 +2261,9 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n       gcc_assert (num_objects == nfiles);\n     }\n \n+  tree_with_vars = htab_create_ggc (101, htab_hash_pointer, htab_eq_pointer,\n+\t\t\t\t    NULL);\n+\n   if (!quiet_flag)\n     fprintf (stderr, \"Reading object files:\");\n \n@@ -2211,6 +2331,8 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n \n   /* Fixup all decls and types and free the type hash tables.  */\n   lto_fixup_decls (all_file_decl_data);\n+  htab_delete (tree_with_vars);\n+  tree_with_vars = NULL;\n   free_gimple_type_tables ();\n   ggc_collect ();\n "}]}