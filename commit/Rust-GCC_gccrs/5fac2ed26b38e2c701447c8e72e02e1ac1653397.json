{"sha": "5fac2ed26b38e2c701447c8e72e02e1ac1653397", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZhYzJlZDI2YjM4ZTJjNzAxNDQ3YzhlNzJlMDJlMWFjMTY1MzM5Nw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-09T09:59:18Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-09T09:59:18Z"}, "message": "sh-protos.h (sh_va_arg): Remove.\n\n        * config/sh/sh-protos.h (sh_va_arg): Remove.\n        * config/sh/sh.c (TARGET_GIMPLIFY_VA_ARG_EXPR): New.\n        (sh_gimplify_va_arg_expr): Rewrite from sh_va_arg.\n        * config/sh/sh.h (EXPAND_BUILTIN_VA_ARG): Remove.\n\nFrom-SVN: r84355", "tree": {"sha": "0eff12bbc05ce21b2d9ac41dfbbc904026abdf14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0eff12bbc05ce21b2d9ac41dfbbc904026abdf14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fac2ed26b38e2c701447c8e72e02e1ac1653397", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fac2ed26b38e2c701447c8e72e02e1ac1653397", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fac2ed26b38e2c701447c8e72e02e1ac1653397", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fac2ed26b38e2c701447c8e72e02e1ac1653397/comments", "author": null, "committer": null, "parents": [{"sha": "8101c928db65dcda3f1406c4cbbe92537ad2711e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8101c928db65dcda3f1406c4cbbe92537ad2711e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8101c928db65dcda3f1406c4cbbe92537ad2711e"}], "stats": {"total": 173, "additions": 79, "deletions": 94}, "files": [{"sha": "e21729b8f653028dd9bb698427ec7b38e5fafc5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fac2ed26b38e2c701447c8e72e02e1ac1653397/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fac2ed26b38e2c701447c8e72e02e1ac1653397/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5fac2ed26b38e2c701447c8e72e02e1ac1653397", "patch": "@@ -1,5 +1,10 @@\n 2004-07-09  Richard Henderson  <rth@redhat.com>\n \n+\t* config/sh/sh-protos.h (sh_va_arg): Remove.\n+\t* config/sh/sh.c (TARGET_GIMPLIFY_VA_ARG_EXPR): New.\n+\t(sh_gimplify_va_arg_expr): Rewrite from sh_va_arg.\n+\t* config/sh/sh.h (EXPAND_BUILTIN_VA_ARG): Remove.\n+\n \t* config/pa/pa-protos.h (hppa_va_arg): Remove.\n \t* config/pa/pa.c (TARGET_GIMPLIFY_VA_ARG_EXPR): New.\n \t(hppa_gimplify_va_arg_expr): Rewrite from hppa_va_arg."}, {"sha": "05d694d4604d014109b68c8cd73bbdd1325ad0e6", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fac2ed26b38e2c701447c8e72e02e1ac1653397/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fac2ed26b38e2c701447c8e72e02e1ac1653397/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=5fac2ed26b38e2c701447c8e72e02e1ac1653397", "patch": "@@ -100,7 +100,6 @@ extern void sh_expand_binop_v2sf (enum rtx_code, rtx, rtx, rtx);\n extern int sh_expand_t_scc (enum rtx_code code, rtx target);\n #ifdef TREE_CODE\n extern void sh_va_start (tree, rtx);\n-extern rtx sh_va_arg (tree, tree);\n #endif /* TREE_CODE */\n #endif /* RTX_CODE */\n "}, {"sha": "11882ddee650ee73c3b5c42f96233be7346c1315", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 74, "deletions": 89, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fac2ed26b38e2c701447c8e72e02e1ac1653397/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fac2ed26b38e2c701447c8e72e02e1ac1653397/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=5fac2ed26b38e2c701447c8e72e02e1ac1653397", "patch": "@@ -51,6 +51,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"intl.h\"\n #include \"sched-int.h\"\n #include \"ggc.h\"\n+#include \"tree-gimple.h\"\n+\n \n int code_for_indirect_jump_scratch = CODE_FOR_indirect_jump_scratch;\n \n@@ -279,6 +281,7 @@ static void sh_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode, tre\n static bool sh_strict_argument_naming (CUMULATIVE_ARGS *);\n static bool sh_pretend_outgoing_varargs_named (CUMULATIVE_ARGS *);\n static tree sh_build_builtin_va_list (void);\n+static tree sh_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n \n \f\n /* Initialize the GCC target structure.  */\n@@ -436,6 +439,8 @@ static tree sh_build_builtin_va_list (void);\n \n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST sh_build_builtin_va_list\n+#undef TARGET_GIMPLIFY_VA_ARG_EXPR\n+#define TARGET_GIMPLIFY_VA_ARG_EXPR sh_gimplify_va_arg_expr\n \n #undef TARGET_PCH_VALID_P\n #define TARGET_PCH_VALID_P sh_pch_valid_p\n@@ -6287,30 +6292,29 @@ sh_va_start (tree valist, rtx nextarg)\n \n /* Implement `va_arg'.  */\n \n-rtx\n-sh_va_arg (tree valist, tree type)\n+static tree\n+sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n+\t\t\t tree *post_p ATTRIBUTE_UNUSED)\n {\n   HOST_WIDE_INT size, rsize;\n   tree tmp, pptr_type_node;\n-  rtx addr_rtx, r;\n-  rtx result_ptr, result = NULL_RTX;\n+  tree addr, lab_over, result = NULL;\n   int pass_by_ref = MUST_PASS_IN_STACK (TYPE_MODE (type), type);\n-  rtx lab_over = NULL_RTX;\n+\n+  if (pass_by_ref)\n+    type = build_pointer_type (type);\n \n   size = int_size_in_bytes (type);\n   rsize = (size + UNITS_PER_WORD - 1) & -UNITS_PER_WORD;\n   pptr_type_node = build_pointer_type (ptr_type_node);\n \n-  if (pass_by_ref)\n-    type = build_pointer_type (type);\n-\n   if (! TARGET_SH5 && (TARGET_SH2E || TARGET_SH4)\n       && ! (TARGET_HITACHI || sh_cfun_attr_renesas_p ()))\n     {\n       tree f_next_o, f_next_o_limit, f_next_fp, f_next_fp_limit, f_next_stack;\n       tree next_o, next_o_limit, next_fp, next_fp_limit, next_stack;\n       int pass_as_float;\n-      rtx lab_false;\n+      tree lab_false;\n \n       f_next_o = TYPE_FIELDS (va_list_type_node);\n       f_next_o_limit = TREE_CHAIN (f_next_o);\n@@ -6339,6 +6343,7 @@ sh_va_arg (tree valist, tree type)\n \t      || TREE_CODE (TREE_TYPE (TYPE_FIELDS (type))) == COMPLEX_TYPE)\n           && TREE_CHAIN (TYPE_FIELDS (type)) == NULL_TREE)\n \ttype = TREE_TYPE (TYPE_FIELDS (type));\n+\n       if (TARGET_SH4)\n \t{\n \t  pass_as_float = ((TREE_CODE (type) == REAL_TYPE && size <= 8)\n@@ -6351,142 +6356,122 @@ sh_va_arg (tree valist, tree type)\n \t  pass_as_float = (TREE_CODE (type) == REAL_TYPE && size == 4);\n \t}\n \n-      addr_rtx = gen_reg_rtx (Pmode);\n-      lab_false = gen_label_rtx ();\n-      lab_over = gen_label_rtx ();\n+      addr = create_tmp_var (pptr_type_node, NULL);\n+      lab_false = create_artificial_label ();\n+      lab_over = create_artificial_label ();\n \n-      tmp = make_tree (pptr_type_node, addr_rtx);\n-      valist = build1 (INDIRECT_REF, ptr_type_node, tmp);\n+      valist = build1 (INDIRECT_REF, ptr_type_node, addr);\n \n       if (pass_as_float)\n \t{\n \t  int first_floatreg\n \t    = current_function_args_info.arg_count[(int) SH_ARG_FLOAT];\n \t  int n_floatregs = MAX (0, NPARM_REGS (SFmode) - first_floatreg);\n \n-\t  emit_cmp_and_jump_insns (expand_expr (next_fp, NULL_RTX, Pmode,\n-\t\t\t\t\t\tEXPAND_NORMAL),\n-\t\t\t\t   expand_expr (next_fp_limit, NULL_RTX,\n-\t\t\t\t\t\tPmode, EXPAND_NORMAL),\n-\t\t\t\t   GE, const1_rtx, Pmode, 1, lab_false);\n+\t  tmp = build (GE_EXPR, boolean_type_node, next_fp, next_fp_limit);\n+\t  tmp = build (COND_EXPR, void_type_node, tmp,\n+\t\t       build (GOTO_EXPR, void_type_node, lab_false),\n+\t\t       NULL);\n+\t  gimplify_and_add (tmp, pre_p);\n \n \t  if (TYPE_ALIGN (type) > BITS_PER_WORD\n \t      || (((TREE_CODE (type) == REAL_TYPE && size == 8) || size == 16)\n \t\t  && (n_floatregs & 1)))\n \t    {\n-\t      tmp = build (BIT_AND_EXPR, ptr_type_node, next_fp,\n-\t\t\t   build_int_2 (UNITS_PER_WORD, 0));\n+\t      tmp = fold_convert (ptr_type_node, size_int (UNITS_PER_WORD));\n+\t      tmp = build (BIT_AND_EXPR, ptr_type_node, next_fp, tmp);\n \t      tmp = build (PLUS_EXPR, ptr_type_node, next_fp, tmp);\n \t      tmp = build (MODIFY_EXPR, ptr_type_node, next_fp, tmp);\n-\t      TREE_SIDE_EFFECTS (tmp) = 1;\n-\t      expand_expr (tmp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t      gimplify_and_add (tmp, pre_p);\n \t    }\n \n \t  tmp = build1 (ADDR_EXPR, pptr_type_node, next_fp);\n-\t  r = expand_expr (tmp, addr_rtx, Pmode, EXPAND_NORMAL);\n-\t  if (r != addr_rtx)\n-\t    emit_move_insn (addr_rtx, r);\n+\t  tmp = build (MODIFY_EXPR, void_type_node, addr, tmp);\n+\t  gimplify_and_add (tmp, pre_p);\n \n #ifdef FUNCTION_ARG_SCmode_WART\n \t  if (TYPE_MODE (type) == SCmode && TARGET_SH4 && TARGET_LITTLE_ENDIAN)\n \t    {\n-\t      rtx addr, real, imag, result_value, slot;\n \t      tree subtype = TREE_TYPE (type);\n+\t      tree real, imag;\n \n-\t      addr = std_expand_builtin_va_arg (valist, subtype);\n-#ifdef POINTERS_EXTEND_UNSIGNED\n-\t      if (GET_MODE (addr) != Pmode)\n-\t\taddr = convert_memory_address (Pmode, addr);\n-#endif\n-\t      imag = gen_rtx_MEM (TYPE_MODE (type), addr);\n-\t      set_mem_alias_set (imag, get_varargs_alias_set ());\n+\t      imag = std_gimplify_va_arg_expr (valist, subtype, pre_p, NULL);\n+\t      imag = get_initialized_tmp_var (imag, pre_p, NULL);\n \n-\t      addr = std_expand_builtin_va_arg (valist, subtype);\n-#ifdef POINTERS_EXTEND_UNSIGNED\n-\t      if (GET_MODE (addr) != Pmode)\n-\t\taddr = convert_memory_address (Pmode, addr);\n-#endif\n-\t      real = gen_rtx_MEM (TYPE_MODE (type), addr);\n-\t      set_mem_alias_set (real, get_varargs_alias_set ());\n-\n-\t      result_value = gen_rtx_CONCAT (SCmode, real, imag);\n-\t      /* ??? this interface is stupid - why require a pointer?  */\n-\t      result = gen_reg_rtx (Pmode);\n-\t      slot = assign_stack_temp (SCmode, 8, 0);\n-\t      emit_move_insn (slot, result_value);\n-\t      emit_move_insn (result, XEXP (slot, 0));\n+\t      real = std_gimplify_va_arg_expr (valist, subtype, pre_p, NULL);\n+\t      real = get_initialized_tmp_var (real, pre_p, NULL);\n+\n+\t      result = build (COMPLEX_EXPR, type, real, imag);\n+\t      result = get_initialized_tmp_var (result, pre_p, NULL);\n \t    }\n #endif /* FUNCTION_ARG_SCmode_WART */\n \n-\t  emit_jump_insn (gen_jump (lab_over));\n-\t  emit_barrier ();\n-\t  emit_label (lab_false);\n+\t  tmp = build (GOTO_EXPR, void_type_node, lab_over);\n+\t  gimplify_and_add (tmp, pre_p);\n+\n+\t  tmp = build (LABEL_EXPR, void_type_node, lab_false);\n+\t  gimplify_and_add (tmp, pre_p);\n \n \t  tmp = build1 (ADDR_EXPR, pptr_type_node, next_stack);\n-\t  r = expand_expr (tmp, addr_rtx, Pmode, EXPAND_NORMAL);\n-\t  if (r != addr_rtx)\n-\t    emit_move_insn (addr_rtx, r);\n+\t  tmp = build (MODIFY_EXPR, void_type_node, addr, tmp);\n+\t  gimplify_and_add (tmp, pre_p);\n \t}\n       else\n \t{\n-\t  tmp = build (PLUS_EXPR, ptr_type_node, next_o,\n-\t\t       build_int_2 (rsize, 0));\n-\t  \n-\t  emit_cmp_and_jump_insns (expand_expr (tmp, NULL_RTX, Pmode,\n-\t\t\t\t\t\tEXPAND_NORMAL),\n-\t\t\t\t   expand_expr (next_o_limit, NULL_RTX,\n-\t\t\t\t\t\tPmode, EXPAND_NORMAL),\n-\t\t\t\t   GT, const1_rtx, Pmode, 1, lab_false);\n+\t  tmp = fold_convert (ptr_type_node, size_int (rsize));\n+\t  tmp = build (PLUS_EXPR, ptr_type_node, next_o, tmp);\n+\t  tmp = build (GT_EXPR, boolean_type_node, tmp, next_o_limit);\n+\t  tmp = build (COND_EXPR, void_type_node, tmp,\n+\t\t       build (GOTO_EXPR, void_type_node, lab_false),\n+\t\t       NULL);\n+\t  gimplify_and_add (tmp, pre_p);\n \n \t  tmp = build1 (ADDR_EXPR, pptr_type_node, next_o);\n-\t  r = expand_expr (tmp, addr_rtx, Pmode, EXPAND_NORMAL);\n-\t  if (r != addr_rtx)\n-\t    emit_move_insn (addr_rtx, r);\n+\t  tmp = build (MODIFY_EXPR, void_type_node, addr, tmp);\n+\t  gimplify_and_add (tmp, pre_p);\n \n-\t  emit_jump_insn (gen_jump (lab_over));\n-\t  emit_barrier ();\n-\t  emit_label (lab_false);\n+\t  tmp = build (GOTO_EXPR, void_type_node, lab_over);\n+\t  gimplify_and_add (tmp, pre_p);\n+\n+\t  tmp = build (LABEL_EXPR, void_type_node, lab_false);\n+\t  gimplify_and_add (tmp, pre_p);\n \n \t  if (size > 4 && ! TARGET_SH4)\n \t    {\n \t      tmp = build (MODIFY_EXPR, ptr_type_node, next_o, next_o_limit);\n-\t      TREE_SIDE_EFFECTS (tmp) = 1;\n-\t      expand_expr (tmp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t      gimplify_and_add (tmp, pre_p);\n \t    }\n \n \t  tmp = build1 (ADDR_EXPR, pptr_type_node, next_stack);\n-\t  r = expand_expr (tmp, addr_rtx, Pmode, EXPAND_NORMAL);\n-\t  if (r != addr_rtx)\n-\t    emit_move_insn (addr_rtx, r);\n+\t  tmp = build (MODIFY_EXPR, void_type_node, addr, tmp);\n+\t  gimplify_and_add (tmp, pre_p);\n \t}\n \n-      if (! result)\n-        emit_label (lab_over);\n+      if (!result)\n+\t{\n+\t  tmp = build (LABEL_EXPR, void_type_node, lab_over);\n+\t  gimplify_and_add (tmp, pre_p);\n+\t}\n     }\n \n   /* ??? In va-sh.h, there had been code to make values larger than\n      size 8 indirect.  This does not match the FUNCTION_ARG macros.  */\n \n-  result_ptr = std_expand_builtin_va_arg (valist, type);\n+  tmp = std_gimplify_va_arg_expr (valist, type, pre_p, NULL);\n   if (result)\n     {\n-      emit_move_insn (result, result_ptr);\n-      emit_label (lab_over);\n+      tmp = build (MODIFY_EXPR, void_type_node, result, tmp);\n+      gimplify_and_add (tmp, pre_p);\n+\n+      tmp = build (LABEL_EXPR, void_type_node, lab_over);\n+      gimplify_and_add (tmp, pre_p);\n     }\n   else\n-    result = result_ptr;\n+    result = tmp;\n \n   if (pass_by_ref)\n-    {\n-#ifdef POINTERS_EXTEND_UNSIGNED\n-      if (GET_MODE (addr) != Pmode)\n-\taddr = convert_memory_address (Pmode, result);\n-#endif\n-      result = gen_rtx_MEM (ptr_mode, force_reg (Pmode, result));\n-      set_mem_alias_set (result, get_varargs_alias_set ());\n-    }\n-  /* ??? expand_builtin_va_arg will also set the alias set of the dereferenced\n-     argument to the varargs alias set.  */\n+    result = build_fold_indirect_ref (result);\n+\n   return result;\n }\n "}, {"sha": "360ba4aecc0b3be36ceb03baecfe7b2e759f51e1", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fac2ed26b38e2c701447c8e72e02e1ac1653397/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fac2ed26b38e2c701447c8e72e02e1ac1653397/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=5fac2ed26b38e2c701447c8e72e02e1ac1653397", "patch": "@@ -2170,10 +2170,6 @@ struct sh_args {\n #define EXPAND_BUILTIN_VA_START(valist, nextarg) \\\n   sh_va_start (valist, nextarg)\n \n-/* Implement `va_arg'.  */\n-#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n-  sh_va_arg (valist, type)\n-\n /* Call the function profiler with a given profile label.\n    We use two .aligns, so as to make sure that both the .long is aligned\n    on a 4 byte boundary, and that the .long is a fixed distance (2 bytes)"}]}