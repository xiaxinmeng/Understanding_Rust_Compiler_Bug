{"sha": "5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU4MDVlNDRjMGRjNDA3YzZlMmUwYWM0YTZiNjM0NmU0YzY4MDVlYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2005-11-21T22:03:56Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2005-11-21T22:03:56Z"}, "message": "re PR fortran/14943 (read/write code generation is not thread safe)\n\ngcc/fortran/\n\tPR fortran/14943\n\tPR fortran/21647\n\t* Make-lang.in (fortran/trans-io.o): Depend on fortran/ioparm.def.\n\t* dump-parse-tree.c (gfc_show_code_node): Dump c->block for\n\tEXEC_{READ,WRITE,IOLENGTH} nodes.\n\t* io.c (terminate_io, match_io, gfc_match_inquire): Put data\n\ttransfer commands into EXEC_{READ,WRITE,IOLENGTH}'s code->block.\n\t* resolve.c (resolve_blocks): Handle EXEC_{READ,WRITE,IOLENGTH}.\n\t* trans-io.c (ioparm_unit, ioparm_err, ioparm_end, ioparm_eor,\n\tioparm_list_format, ioparm_library_return, ioparm_iostat,\n\tioparm_exist, ioparm_opened, ioparm_number, ioparm_named,\n\tioparm_rec, ioparm_nextrec, ioparm_size, ioparm_recl_in,\n\tioparm_recl_out, ioparm_iolength, ioparm_file, ioparm_file_len,\n\tioparm_status, ioparm_status_len, ioparm_access, ioparm_access_len,\n\tioparm_form, ioparm_form_len, ioparm_blank, ioparm_blank_len,\n\tioparm_position, ioparm_position_len, ioparm_action,\n\tioparm_action_len, ioparm_delim, ioparm_delim_len, ioparm_pad,\n\tioparm_pad_len, ioparm_format, ioparm_format_len, ioparm_advance,\n\tioparm_advance_len, ioparm_name, ioparm_name_len,\n\tioparm_internal_unit, ioparm_internal_unit_len,\n\tioparm_internal_unit_desc, ioparm_sequential, ioparm_sequential_len,\n\tioparm_direct, ioparm_direct_len, ioparm_formatted,\n\tioparm_formatted_len, ioparm_unformatted, ioparm_unformatted_len,\n\tioparm_read, ioparm_read_len, ioparm_write, ioparm_write_len,\n\tioparm_readwrite, ioparm_readwrite_len, ioparm_namelist_name,\n\tioparm_namelist_name_len, ioparm_namelist_read_mode, ioparm_iomsg,\n\tioparm_iomsg_len, ioparm_var): Remove.\n\t(enum ioparam_type, enum iofield_type, enum iofield,\n\tenum iocall): New enums.\n\t(gfc_st_parameter_field, gfc_st_parameter): New typedefs.\n\t(st_parameter, st_parameter_field, iocall): New variables.\n\t(ADD_FIELD, ADD_STRING): Remove.\n\t(dt_parm, dt_post_end_block): New variables.\n\t(gfc_build_st_parameter): New function.\n\t(gfc_build_io_library_fndecls): Use it.  Initialize iocall\n\tarray rather than ioparm_*, add extra first arguments to\n\tthe function types.\n\t(set_parameter_const): New function.\n\t(set_parameter_value): Add type argument, return a bitmask.\n\tChanged to set a field in automatic structure variable rather\n\tthan set a field in a global _gfortran_ioparm variable.\n\t(set_parameter_ref): Likewise.  If requested var has different\n\tsize than what field should point to, call with a temporary and\n\tthen copy into the user variable.  Add postblock argument.\n\t(set_string): Remove var_len argument, add type argument, return\n\ta bitmask.  Changed to set fields in automatic structure variable\n\trather than set a field in a global _gfortran_ioparm variable.\n\t(set_internal_unit): Remove iunit, iunit_len, iunit_desc arguments,\n\tadd var argument.  Return a bitmask.  Changed to set fields in\n\tautomatic structure variable rather than set a field in a global\n\t_gfortran_ioparm variable.\n\t(set_flag): Removed.\n\t(io_result): Add var argument.  Changed to read common.flags field\n\tfrom automatic structure variable and bitwise AND it with 3.\n\t(set_error_locus): Add var argument.  Changed to set fields in\n\tautomatic structure variable rather than set a field in a global\n\t_gfortran_{filename,line} variables.\n\t(gfc_trans_open): Use gfc_start_block rather than gfc_init_block.\n\tCreate a temporary st_parameter_* structure.  Adjust callers of\n\tall above mentioned functions.  Pass address of the temporary\n\tvariable as first argument to the generated function call.\n\tUse iocall array rather than ioparm_* separate variables.\n\t(gfc_trans_close, build_filepos, gfc_trans_inquire): Likewise.\n\t(build_dt): Likewise.  Change first argument to tree from tree *.\n\tDon't dereference code->ext.dt if last_dt == INQUIRE.  Emit\n\tIOLENGTH argument setup here.  Set dt_parm/dt_post_end_block\n\tvariables and gfc_trans_code the nested data transfer commands\n\tin code->block.\n\t(gfc_trans_iolength): Just set last_dt and call build_dt immediately.\n\t(transfer_namelist_element): Pass address of dt_parm variable\n\tto generated functions.  Use iocall array rather than ioparm_*\n\tseparate variables.\n\t(gfc_trans_backspace, gfc_trans_endfile, gfc_trans_rewind,\n\tgfc_trans_flush, gfc_trans_read, gfc_trans_write): Use iocall array\n\trather than ioparm_* separate variables.\n\t(gfc_trans_dt_end): Likewise.  Pass address of dt_parm variable\n\tas first argument to generated function.  Adjust io_result caller.\n\tPrepend dt_post_end_block before io_result code.\n\t(transfer_expr): Use iocall array rather than ioparm_* separate\n\tvariables.  Pass address of dt_parm variables as first argument\n\tto generated functions.\n\t* ioparm.def: New file.\ngcc/testsuite/\n\tPR fortran/24774\n\t* gfortran.dg/inquire_9.f90: New test.\n\n\tPR fortran/21647\n\t* gfortran.fortran-torture/execute/inquire_5.f90: New test.\nlibgfortran/\n\tPR fortran/24774\n\tPR fortran/14943\n\tPR fortran/21647\n\t* Makefile.am (AM_CPPFLAGS): Add gcc directories as -I paths,\n\tadd -D_GNU_SOURCE.\n\t* Makefile.in: Regenerated.\n\t* acinclude.m4 (LIBGFOR_CHECK_SYNC_FETCH_AND_ADD,\n\tLIBGFOR_CHECK_GTHR_DEFAULT, LIBGFOR_CHECK_PRAGMA_WEAK): New macros.\n\t* configure.ac: Add them.\n\t* configure: Rebuilt.\n\t* config.h.in: Rebuilt.\n\t* libtool-version: Bump libgfortran.so SONAME to libgfortran.so.1.\n\t* libgfortran.h (library_start, show_locus, internal_error,\n\tgenerate_error, find_option): Add st_parameter_common * argument.\n\t(library_end): Change into a dummy macro.\n\t* io/io.h: Include gthr.h.\n\t(SUPPORTS_WEAK): Define if HAVE_PRAGMA_WEAK.\n\t(CHARACTER): Remove define.\n\t(st_parameter, global_t): Remove typedef.\n\t(ioparm, g, ionml, current_unit): Remove variables.\n\t(init_error_stream): Remove prototype.\n\t(CHARACTER1, CHARACTER2): Define.\n\t(st_parameter_common, st_parameter_open, st_parameter_close,\n\tst_parameter_filepos, st_parameter_inquire, st_parameter_dt): New\n\ttypedefs.\n\t(IOPARM_LIBRETURN_MASK, IOPARM_LIBRETURN_OK, IOPARM_LIBRETURN_ERROR,\n\tIOPARM_LIBRETURN_END, IOPARM_LIBRETURN_EOR, IOPARM_ERR, IOPARM_END,\n\tIOPARM_EOR, IOPARM_HAS_IOSTAT, IOPARM_HAS_IOMSG, IOPARM_COMMON_MASK,\n\tIOPARM_OPEN_HAS_RECL_IN, IOPARM_OPEN_HAS_FILE, IOPARM_OPEN_HAS_STATUS,\n\tIOPARM_OPEN_HAS_ACCESS, IOPARM_OPEN_HAS_FORM, IOPARM_OPEN_HAS_BLANK,\n\tIOPARM_OPEN_HAS_POSITION, IOPARM_OPEN_HAS_ACTION,\n\tIOPARM_OPEN_HAS_DELIM, IOPARM_OPEN_HAS_PAD, IOPARM_CLOSE_HAS_STATUS,\n\tIOPARM_INQUIRE_HAS_EXIST, IOPARM_INQUIRE_HAS_OPENED,\n\tIOPARM_INQUIRE_HAS_NUMBER, IOPARM_INQUIRE_HAS_NAMED,\n\tIOPARM_INQUIRE_HAS_NEXTREC, IOPARM_INQUIRE_HAS_RECL_OUT,\n\tIOPARM_INQUIRE_HAS_FILE, IOPARM_INQUIRE_HAS_ACCESS,\n\tIOPARM_INQUIRE_HAS_FORM, IOPARM_INQUIRE_HAS_BLANK,\n\tIOPARM_INQUIRE_HAS_POSITION, IOPARM_INQUIRE_HAS_ACTION,\n\tIOPARM_INQUIRE_HAS_DELIM, IOPARM_INQUIRE_HAS_PAD,\n\tIOPARM_INQUIRE_HAS_NAME, IOPARM_INQUIRE_HAS_SEQUENTIAL,\n\tIOPARM_INQUIRE_HAS_DIRECT, IOPARM_INQUIRE_HAS_FORMATTED,\n\tIOPARM_INQUIRE_HAS_UNFORMATTED, IOPARM_INQUIRE_HAS_READ,\n\tIOPARM_INQUIRE_HAS_WRITE, IOPARM_INQUIRE_HAS_READWRITE,\n\tIOPARM_DT_LIST_FORMAT, IOPARM_DT_NAMELIST_READ_MODE,\n\tIOPARM_DT_HAS_REC, IOPARM_DT_HAS_SIZE, IOPARM_DT_HAS_IOLENGTH,\n\tIOPARM_DT_HAS_FORMAT, IOPARM_DT_HAS_ADVANCE,\n\tIOPARM_DT_HAS_INTERNAL_UNIT, IOPARM_DT_HAS_NAMELIST_NAME,\n\tIOPARM_DT_IONML_SET): Define.\n\t(gfc_unit): Add lock, waiting and close fields.  Change file\n\tfrom flexible array member into pointer to char.\n\t(open_external): Add st_parameter_open * argument.\n\t(find_file, file_exists): Add file and file_len arguments.\n\t(flush_all_units): New prototype.\n\t(max_offset, unit_root, unit_lock): New variable.\n\t(is_internal_unit, is_array_io, next_array_record,\n\tparse_format, next_format, unget_format, format_error,\n\tread_block, write_block, next_record, convert_real,\n\tread_a, read_f, read_l, read_x, read_radix, read_decimal,\n\tlist_formatted_read, finish_list_read, namelist_read,\n\tnamelist_write, write_a, write_b, write_d, write_e, write_en,\n\twrite_es, write_f, write_i, write_l, write_o, write_x, write_z,\n\tlist_formatted_write, get_unit): Add st_parameter_dt * argument.\n\t(insert_unit): Remove prototype.\n\t(find_or_create_unit, unlock_unit): New prototype.\n\t(new_unit): Return gfc_unit *.  Add st_parameter_open *\n\tand gfc_unit * arguments.\n\t(free_fnodes): Remove prototype.\n\t(free_format_data): New prototype.\n\t(scratch): Remove.\n\t(init_at_eol): Remove prototype.\n\t(free_ionml): New prototype.\n\t(inc_waiting_locked, predec_waiting_locked, dec_waiting_unlocked):\n\tNew inline functions.\n\t* io/unit.c (max_offset, unit_root, unit_lock): New variables.\n\t(insert): Adjust os_error caller.\n\t(insert_unit): Made static.  Allocate memory here, initialize\n\tlock and after inserting it return it, locked.\n\t(delete_unit): Adjust for deletion of g.\n\t(find_unit_1): New function.\n\t(find_unit): Use it.\n\t(find_or_create_unit): New function.\n\t(get_unit): Add dtp argument, change meaning of the int argument\n\tas creation request flag.  Adjust for different st_* calling\n\tconventions, lock internal unit's lock before returning it\n\tand removal of g.  Call find_unit_1 instead of find_unit.\n\t(is_internal_unit, is_array_io): Add dtp argument, adjust for\n\tremoval of most of global variables.\n\t(init_units): Initialize unit_lock.  Adjust insert_unit callers\n\tand adjust for g removal.\n\t(close_unit_1): New function.\n\t(close_unit): Use it.\n\t(unlock_unit): New function.\n\t(close_units): Lock unit_lock, use close_unit_1 rather than\n\tclose_unit.\n\t* io/close.c (st_close): Add clp argument.  Adjust for new\n\tst_* calling conventions and internal function API changes.\n\t* io/file_pos.c (st_backspace, st_endfile, st_rewind, st_flush):\n\tAdd fpp argument.  Adjust for new st_* calling conventions and\n\tinternal function API changes.\n\t(formatted_backspace, unformatted_backspace): Likewise.  Add\n\tu argument.\n\t* io/open.c (edit_modes, st_open): Add opp argument.  Adjust for\n\tnew st_* calling conventions and internal function API changes.\n\t(already_open): Likewise.  If not HAVE_UNLINK_OPEN_FILE, unlink\n\tscratch file.  Instead of calling close_unit just call sclose,\n\tfree u->file if any and clear a few u fields before calling\n\tnew_unit.\n\t(new_unit): Return gfc_unit *.  Add opp and u arguments.\n\tAdjust for new st_* calling conventions and internal function\n\tAPI changes.  Don't allocate unit here, rather than work with\n\talready created unit u already locked on entry.  In case\n\tof failure, close_unit it.\n\t* io/unix.c: Include unix.h.\n\t(BUFFER_SIZE, unix_stream): Moved to unix.h.\n\t(unit_to_fd): Add unlock_unit call.\n\t(tempfile): Add opp argument, use its fields rather than ioparm.\n\t(regular_file): Likewise.\n\t(open_external): Likewise.  Only unlink file if fd >= 0.\n\t(init_error_stream): Add error argument, set structure it points\n\tto rather than filling static variable and returning its address.\n\t(FIND_FILE0_DECL, FIND_FILE0_ARGS): Define.\n\t(find_file0): Use them.  Don't crash if u->s == NULL.\n\t(find_file): Add file and file_len arguments, use them instead\n\tof ioparm.  Add locking.  Pass either an array of 2 struct stat\n\tor file and file_len pair to find_file0.\n\t(flush_all_units_1, flush_all_units): New functions.\n\t(file_exists): Add file and file_len arguments, use them instead\n\tof ioparm.\n\t* io/unix.h: New file.\n\t* io/lock.c (ioparm, g, ionml): Remove variables.\n\t(library_start): Add cmp argument, adjust for new st_* calling\n\tconventions.\n\t(library_end): Remove.\n\t(free_ionml): New function.\n\t* io/inquire.c (inquire_via_unit, inquire_via_filename,\n\tst_inquire): Add iqp argument, adjust for new st_* calling\n\tconventions and internal function API changes.\n\t* io/format.c (FARRAY_SIZE): Decrease to 64.\n\t(fnode_array, format_data): New typedefs.\n\t(avail, array, format_string, string, error, saved_token, value,\n\tformat_string_len, reversion_ok, saved_format): Remove variables.\n\t(colon_node): Add const.\n\t(free_fnode, free_fnodes): Remove.\n\t(free_format_data): New function.\n\t(next_char, unget_char, get_fnode, format_lex, parse_format_list,\n\tformat_error, parse_format, revert, unget_format, next_test): Add\n\tfmt or dtp arguments, pass it all around, adjust for internal\n\tfunction API changes and adjust for removal of global variables.\n\t(next_format): Likewise.  Constify return type.\n\t(next_format0): Constify return type.\n\t* io/transfer.c (current_unit, sf_seen_eor, eor_condition, max_pos,\n\tskips, pending_spaces, scratch, line_buffer, advance_status,\n\ttransfer): Remove variables.\n\t(transfer_integer, transfer_real, transfer_logical,\n\ttransfer_character, transfer_complex, transfer_array, current_mode,\n\tread_sf, read_block, read_block_direct, write_block,\n\twrite_block_direct, unformatted_read, unformatted_write,\n\ttype_name, write_constant_string, require_type,\n\tformatted_transfer_scalar, us_read, us_write, pre_position,\n\tdata_transfer_init, next_record_r, next_record_w, next_record,\n\tfinalize_transfer, iolength_transfer, iolength_transfer_init,\n\tst_iolength, st_iolength_done, st_read, st_read_done, st_write,\n\tst_write_done, st_set_nml_var, st_set_nml_var_dim,\n\tnext_array_record): Add dtp argument, pass it all around, adjust for\n\tinternal function API changes and removal of global variables.\n\t* io/list_read.c (repeat_count, saved_length, saved_used,\n\tinput_complete, at_eol, comma_flag, last_char, saved_string,\n\tsaved_type, namelist_mode, nml_read_error, value, parse_err_msg,\n\tnml_err_msg, prev_nl): Remove variables.\n\t(push_char, free_saved, next_char, unget_char, eat_spaces,\n\teat_separator, finish_separator, nml_bad_return, convert_integer,\n\tparse_repeat, read_logical, read_integer, read_character,\n\tparse_real, read_complex, read_real, check_type,\n\tlist_formatted_read_scalar, list_formatted_read, finish_list_read,\n\tfind_nml_node, nml_untouch_nodes, nml_match_name, nml_query,\n\tnamelist_read): Add dtp argument, pass it all around, adjust for\n\tinternal function API changes and removal of global variables.\n\t(nml_parse_qualifier): Likewise.  Add parse_err_msg argument.\n\t(nml_read_obj): Likewise.  Add pprev_nl, nml_err_msg, clow and\n\tchigh arguments.\n\t(nml_get_obj_data): Likewise.  Add pprev_nl and nml_err_msg\n\targuments.\n\t(init_at_eol): Removed.\n\t* io/read.c (convert_real, read_l, read_a, next_char, read_decimal,\n\tread_radix, read_f, read_x): Add dtp argument, pass it all around,\n\tadjust for internal function API changes and removal of global\n\tvariables.\n\t(set_integer): Adjust internal_error caller.\n\t* io/write.c (no_leading_blank, nml_delim): Remove variables.\n\t(write_a, calculate_sign, calculate_G_format, output_float,\n\twrite_l, write_float, write_int, write_decimal, write_i, write_b,\n\twrite_o, write_z, write_d, write_e, write_f, write_en, write_es,\n\twrite_x, write_char, write_logical, write_integer, write_character,\n\twrite_real, write_complex, write_separator,\n\tlist_formatted_write_scalar, list_formatted_write, nml_write_obj,\n\tnamelist_write): Add dtp argument, pass it all around, adjust for\n\tinternal function API changes and removal of global variables.\n\t(extract_int, extract_uint, extract_real): Adjust internal_error\n\tcallers.\n\t* runtime/fpu.c (_GNU_SOURCE): Don't define here.\n\t* runtime/error.c: Include ../io/unix.h.\n\t(filename, line): Remove variables.\n\t(st_printf): Pass address of a local variable to init_error_stream.\n\t(show_locus): Add cmp argument.  Use fields it points to rather than\n\tfilename and line variables.\n\t(os_error, runtime_error): Remove show_locus calls.\n\t(internal_error): Add cmp argument.  Pass it down to show_locus.\n\t(generate_error): Likewise.  Use flags bitmask instead of non-NULL\n\tcheck for iostat and iomsg parameter presence, adjust for st_*\n\tcalling convention changes.\n\t* runtime/stop.c (stop_numeric, stop_string): Remove show_locus\n\tcalls.\n\t* runtime/pause.c (pause_numeric, pause_string): Likewise.\n\t* runtime/string.c: Include ../io/io.h.\n\t(find_option): Add cmp argument.  Pass it down to generate_error.\n\t* intrinsics/flush.c (recursive_flush): Remove.\n\t(flush_i4, flush_i8): Use flush_all_units.  Add unlock_unit\n\tcall.\n\t* intrinsics/rand.c: Include ../io/io.h.\n\t(rand_seed_lock): New variable.\n\t(srand, irand): Add locking.\n\t(init): New constructor function.\n\t* intrinsics/random.c: Include ../io/io.h.\n\t(random_lock): New variable.\n\t(random_r4, random_r8, arandom_r4, arandom_r8): Add locking.\n\t(random_seed): Likewise.  open failed if fd < 0.  Set i correctly.\n\t(init): New constructor function.\n\t* intrinsics/system_clock.c (tp0, t0): Remove.\n\t(system_clock_4, system_clock_8): Don't subtract tp0/t0 from current\n\ttime, use just integer arithmetics.\n\t* intrinsics/tty.c (isatty_l4, isatty_l8, ttynam_sub): Add\n\tunlock_unit calls.\n\nFrom-SVN: r107328", "tree": {"sha": "70195ef088833dd65da3e74e108f43543cbb339a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70195ef088833dd65da3e74e108f43543cbb339a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9b92bf04bf7f6ccb1a74fbfe7e9866b1cf4da484", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b92bf04bf7f6ccb1a74fbfe7e9866b1cf4da484", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b92bf04bf7f6ccb1a74fbfe7e9866b1cf4da484"}], "stats": {"total": 6975, "additions": 4176, "deletions": 2799}, "files": [{"sha": "4a124d3b3adf9a252fb1eff49e21c601c264ee38", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -1,3 +1,88 @@\n+2005-11-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/14943\n+\tPR fortran/21647\n+\t* Make-lang.in (fortran/trans-io.o): Depend on fortran/ioparm.def.\n+\t* dump-parse-tree.c (gfc_show_code_node): Dump c->block for\n+\tEXEC_{READ,WRITE,IOLENGTH} nodes.\n+\t* io.c (terminate_io, match_io, gfc_match_inquire): Put data\n+\ttransfer commands into EXEC_{READ,WRITE,IOLENGTH}'s code->block.\n+\t* resolve.c (resolve_blocks): Handle EXEC_{READ,WRITE,IOLENGTH}.\n+\t* trans-io.c (ioparm_unit, ioparm_err, ioparm_end, ioparm_eor,\n+\tioparm_list_format, ioparm_library_return, ioparm_iostat,\n+\tioparm_exist, ioparm_opened, ioparm_number, ioparm_named,\n+\tioparm_rec, ioparm_nextrec, ioparm_size, ioparm_recl_in,\n+\tioparm_recl_out, ioparm_iolength, ioparm_file, ioparm_file_len,\n+\tioparm_status, ioparm_status_len, ioparm_access, ioparm_access_len,\n+\tioparm_form, ioparm_form_len, ioparm_blank, ioparm_blank_len,\n+\tioparm_position, ioparm_position_len, ioparm_action,\n+\tioparm_action_len, ioparm_delim, ioparm_delim_len, ioparm_pad,\n+\tioparm_pad_len, ioparm_format, ioparm_format_len, ioparm_advance,\n+\tioparm_advance_len, ioparm_name, ioparm_name_len,\n+\tioparm_internal_unit, ioparm_internal_unit_len,\n+\tioparm_internal_unit_desc, ioparm_sequential, ioparm_sequential_len,\n+\tioparm_direct, ioparm_direct_len, ioparm_formatted,\n+\tioparm_formatted_len, ioparm_unformatted, ioparm_unformatted_len,\n+\tioparm_read, ioparm_read_len, ioparm_write, ioparm_write_len,\n+\tioparm_readwrite, ioparm_readwrite_len, ioparm_namelist_name,\n+\tioparm_namelist_name_len, ioparm_namelist_read_mode, ioparm_iomsg,\n+\tioparm_iomsg_len, ioparm_var): Remove.\n+\t(enum ioparam_type, enum iofield_type, enum iofield,\n+\tenum iocall): New enums.\n+\t(gfc_st_parameter_field, gfc_st_parameter): New typedefs.\n+\t(st_parameter, st_parameter_field, iocall): New variables.\n+\t(ADD_FIELD, ADD_STRING): Remove.\n+\t(dt_parm, dt_post_end_block): New variables.\n+\t(gfc_build_st_parameter): New function.\n+\t(gfc_build_io_library_fndecls): Use it.  Initialize iocall\n+\tarray rather than ioparm_*, add extra first arguments to\n+\tthe function types.\n+\t(set_parameter_const): New function.\n+\t(set_parameter_value): Add type argument, return a bitmask.\n+\tChanged to set a field in automatic structure variable rather\n+\tthan set a field in a global _gfortran_ioparm variable.\n+\t(set_parameter_ref): Likewise.  If requested var has different\n+\tsize than what field should point to, call with a temporary and\n+\tthen copy into the user variable.  Add postblock argument.\n+\t(set_string): Remove var_len argument, add type argument, return\n+\ta bitmask.  Changed to set fields in automatic structure variable\n+\trather than set a field in a global _gfortran_ioparm variable.\n+\t(set_internal_unit): Remove iunit, iunit_len, iunit_desc arguments,\n+\tadd var argument.  Return a bitmask.  Changed to set fields in\n+\tautomatic structure variable rather than set a field in a global\n+\t_gfortran_ioparm variable.\n+\t(set_flag): Removed.\n+\t(io_result): Add var argument.  Changed to read common.flags field\n+\tfrom automatic structure variable and bitwise AND it with 3.\n+\t(set_error_locus): Add var argument.  Changed to set fields in\n+\tautomatic structure variable rather than set a field in a global\n+\t_gfortran_{filename,line} variables.\n+\t(gfc_trans_open): Use gfc_start_block rather than gfc_init_block.\n+\tCreate a temporary st_parameter_* structure.  Adjust callers of\n+\tall above mentioned functions.  Pass address of the temporary\n+\tvariable as first argument to the generated function call.\n+\tUse iocall array rather than ioparm_* separate variables.\n+\t(gfc_trans_close, build_filepos, gfc_trans_inquire): Likewise.\n+\t(build_dt): Likewise.  Change first argument to tree from tree *.\n+\tDon't dereference code->ext.dt if last_dt == INQUIRE.  Emit\n+\tIOLENGTH argument setup here.  Set dt_parm/dt_post_end_block\n+\tvariables and gfc_trans_code the nested data transfer commands\n+\tin code->block.\n+\t(gfc_trans_iolength): Just set last_dt and call build_dt immediately.\n+\t(transfer_namelist_element): Pass address of dt_parm variable\n+\tto generated functions.  Use iocall array rather than ioparm_*\n+\tseparate variables.\n+\t(gfc_trans_backspace, gfc_trans_endfile, gfc_trans_rewind,\n+\tgfc_trans_flush, gfc_trans_read, gfc_trans_write): Use iocall array\n+\trather than ioparm_* separate variables.\n+\t(gfc_trans_dt_end): Likewise.  Pass address of dt_parm variable\n+\tas first argument to generated function.  Adjust io_result caller.\n+\tPrepend dt_post_end_block before io_result code.\n+\t(transfer_expr): Use iocall array rather than ioparm_* separate\n+\tvariables.  Pass address of dt_parm variables as first argument\n+\tto generated functions.\n+\t* ioparm.def: New file.\n+\n 2005-11-21  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/24223"}, {"sha": "5d3a0e0ef5fcff3be42d038fa0a81b548ff84ad1", "filename": "gcc/fortran/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/gcc%2Ffortran%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/gcc%2Ffortran%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FMake-lang.in?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -287,7 +287,8 @@ fortran/trans-types.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-types.h \\\n fortran/trans-const.o: $(GFORTRAN_TRANS_DEPS)\n fortran/trans-expr.o: $(GFORTRAN_TRANS_DEPS) fortran/dependency.h\n fortran/trans-stmt.o: $(GFORTRAN_TRANS_DEPS)\n-fortran/trans-io.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-io.h\n+fortran/trans-io.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-io.h \\\n+  fortran/ioparm.def\n fortran/trans-array.o: $(GFORTRAN_TRANS_DEPS)\n fortran/trans-intrinsic.o: $(GFORTRAN_TRANS_DEPS) fortran/mathbuiltins.def \\\n   gt-fortran-trans-intrinsic.h"}, {"sha": "499e1fa22e57e31f74403b8217ce40db18e1fe88", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -1357,6 +1357,7 @@ gfc_show_code_node (int level, gfc_code * c)\n     case EXEC_IOLENGTH:\n       gfc_status (\"IOLENGTH \");\n       gfc_show_expr (c->expr);\n+      goto show_dt_code;\n       break;\n \n     case EXEC_READ:\n@@ -1411,7 +1412,11 @@ gfc_show_code_node (int level, gfc_code * c)\n \t  gfc_show_expr (dt->advance);\n \t}\n \n-      break;\n+    show_dt_code:\n+      gfc_status_char ('\\n');\n+      for (c = c->block->next; c; c = c->next)\n+\tgfc_show_code_node (level + (c->next != NULL), c);\n+      return;\n \n     case EXEC_TRANSFER:\n       gfc_status (\"TRANSFER \");"}, {"sha": "26c335688fc8475da7aa14e99243782e849be411", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -2147,7 +2147,7 @@ terminate_io (gfc_code * io_code)\n   gfc_code *c;\n \n   if (io_code == NULL)\n-    io_code = &new_st;\n+    io_code = new_st.block;\n \n   c = gfc_get_code ();\n   c->op = EXEC_DT_END;\n@@ -2353,7 +2353,9 @@ match_io (io_kind k)\n \n   new_st.op = (k == M_READ) ? EXEC_READ : EXEC_WRITE;\n   new_st.ext.dt = dt;\n-  new_st.next = io_code;\n+  new_st.block = gfc_get_code ();\n+  new_st.block->op = new_st.op;\n+  new_st.block->next = io_code;\n \n   terminate_io (io_code);\n \n@@ -2522,8 +2524,6 @@ gfc_match_inquire (void)\n       if (m == MATCH_NO)\n \tgoto syntax;\n \n-      terminate_io (code);\n-\n       new_st.op = EXEC_IOLENGTH;\n       new_st.expr = inquire->iolength;\n       new_st.ext.inquire = inquire;\n@@ -2535,7 +2535,10 @@ gfc_match_inquire (void)\n \t  return MATCH_ERROR;\n \t}\n \n-      new_st.next = code;\n+      new_st.block = gfc_get_code ();\n+      new_st.block->op = EXEC_IOLENGTH;\n+      terminate_io (code);\n+      new_st.block->next = code;\n       return MATCH_YES;\n     }\n "}, {"sha": "9ca0cf659b11702080e7837db394b4db4a1f0f35", "filename": "gcc/fortran/ioparm.def", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/gcc%2Ffortran%2Fioparm.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/gcc%2Ffortran%2Fioparm.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fioparm.def?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -0,0 +1,67 @@\n+#ifndef IOPARM_common_libreturn_mask\n+#define IOPARM_common_libreturn_mask\t3\n+#define IOPARM_common_libreturn_ok\t0\n+#define IOPARM_common_libreturn_error\t1\n+#define IOPARM_common_libreturn_end\t2\n+#define IOPARM_common_libreturn_eor\t3\n+#define IOPARM_common_err\t\t(1 << 2)\n+#define IOPARM_common_end\t\t(1 << 3)\n+#define IOPARM_common_eor\t\t(1 << 4)\n+#endif\n+IOPARM (common,  flags,\t\t0,       int4)\n+IOPARM (common,  unit,\t\t0,       int4)\n+IOPARM (common,  filename,\t0,       pchar)\n+IOPARM (common,  line,\t\t0,       int4)\n+IOPARM (common,  iomsg,\t\t1 << 6,  char2)\n+IOPARM (common,  iostat,\t1 << 5,  pint4)\n+IOPARM (open,    common,\t0,\t common)\n+IOPARM (open,    recl_in,\t1 << 7,  int4)\n+IOPARM (open,    file,\t\t1 << 8,  char2)\n+IOPARM (open,    status,\t1 << 9,  char1)\n+IOPARM (open,    access,\t1 << 10, char2)\n+IOPARM (open,    form,\t\t1 << 11, char1)\n+IOPARM (open,    blank,\t\t1 << 12, char2)\n+IOPARM (open,    position,\t1 << 13, char1)\n+IOPARM (open,    action,\t1 << 14, char2)\n+IOPARM (open,    delim,\t\t1 << 15, char1)\n+IOPARM (open,    pad,\t\t1 << 16, char2)\n+IOPARM (close,   common,\t0,\t common)\n+IOPARM (close,   status,\t1 << 7,  char1)\n+IOPARM (filepos, common,\t0,\t common)\n+IOPARM (inquire, common,\t0,\t common)\n+IOPARM (inquire, exist,\t\t1 << 7,  pint4)\n+IOPARM (inquire, opened,\t1 << 8,  pint4)\n+IOPARM (inquire, number,\t1 << 9,  pint4)\n+IOPARM (inquire, named,\t\t1 << 10, pint4)\n+IOPARM (inquire, nextrec,\t1 << 11, pint4)\n+IOPARM (inquire, recl_out,\t1 << 12, pint4)\n+IOPARM (inquire, file,\t\t1 << 13, char1)\n+IOPARM (inquire, access,\t1 << 14, char2)\n+IOPARM (inquire, form,\t\t1 << 15, char1)\n+IOPARM (inquire, blank,\t\t1 << 16, char2)\n+IOPARM (inquire, position,\t1 << 17, char1)\n+IOPARM (inquire, action,\t1 << 18, char2)\n+IOPARM (inquire, delim,\t\t1 << 19, char1)\n+IOPARM (inquire, pad,\t\t1 << 20, char2)\n+IOPARM (inquire, name,\t\t1 << 21, char1)\n+IOPARM (inquire, sequential,\t1 << 22, char2)\n+IOPARM (inquire, direct,\t1 << 23, char1)\n+IOPARM (inquire, formatted,\t1 << 24, char2)\n+IOPARM (inquire, unformatted,\t1 << 25, char1)\n+IOPARM (inquire, read,\t\t1 << 26, char2)\n+IOPARM (inquire, write,\t\t1 << 27, char1)\n+IOPARM (inquire, readwrite,\t1 << 28, char2)\n+#ifndef IOPARM_dt_list_format\n+#define IOPARM_dt_list_format\t\t(1 << 7)\n+#define IOPARM_dt_namelist_read_mode\t(1 << 8)\n+#endif\n+IOPARM (dt,      common,\t0,\t common)\n+IOPARM (dt,      rec,\t\t1 << 9,  int4)\n+IOPARM (dt,      size,\t\t1 << 10, pint4)\n+IOPARM (dt,      iolength,\t1 << 11, pint4)\n+IOPARM (dt,      internal_unit_desc, 0,  parray)\n+IOPARM (dt,      format,\t1 << 12, char1)\n+IOPARM (dt,      advance,\t1 << 13, char2)\n+IOPARM (dt,      internal_unit,\t1 << 14, char1)\n+IOPARM (dt,      namelist_name,\t1 << 15, char2)\n+IOPARM (dt,      u,\t\t0,       pad)"}, {"sha": "c543a9563698cd478212f0adbc80068718448326", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -3892,6 +3892,9 @@ resolve_blocks (gfc_code * b, gfc_namespace * ns)\n \tcase EXEC_FORALL:\n \tcase EXEC_DO:\n \tcase EXEC_DO_WHILE:\n+\tcase EXEC_READ:\n+\tcase EXEC_WRITE:\n+\tcase EXEC_IOLENGTH:\n \t  break;\n \n \tdefault:"}, {"sha": "720ff5858e08169d3895afb101f440e6a6af336e", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 617, "deletions": 475, "changes": 1092, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -38,351 +38,403 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n /* Members of the ioparm structure.  */\n \n-static GTY(()) tree ioparm_unit;\n-static GTY(()) tree ioparm_err;\n-static GTY(()) tree ioparm_end;\n-static GTY(()) tree ioparm_eor;\n-static GTY(()) tree ioparm_list_format;\n-static GTY(()) tree ioparm_library_return;\n-static GTY(()) tree ioparm_iostat;\n-static GTY(()) tree ioparm_exist;\n-static GTY(()) tree ioparm_opened;\n-static GTY(()) tree ioparm_number;\n-static GTY(()) tree ioparm_named;\n-static GTY(()) tree ioparm_rec;\n-static GTY(()) tree ioparm_nextrec;\n-static GTY(()) tree ioparm_size;\n-static GTY(()) tree ioparm_recl_in;\n-static GTY(()) tree ioparm_recl_out;\n-static GTY(()) tree ioparm_iolength;\n-static GTY(()) tree ioparm_file;\n-static GTY(()) tree ioparm_file_len;\n-static GTY(()) tree ioparm_status;\n-static GTY(()) tree ioparm_status_len;\n-static GTY(()) tree ioparm_access;\n-static GTY(()) tree ioparm_access_len;\n-static GTY(()) tree ioparm_form;\n-static GTY(()) tree ioparm_form_len;\n-static GTY(()) tree ioparm_blank;\n-static GTY(()) tree ioparm_blank_len;\n-static GTY(()) tree ioparm_position;\n-static GTY(()) tree ioparm_position_len;\n-static GTY(()) tree ioparm_action;\n-static GTY(()) tree ioparm_action_len;\n-static GTY(()) tree ioparm_delim;\n-static GTY(()) tree ioparm_delim_len;\n-static GTY(()) tree ioparm_pad;\n-static GTY(()) tree ioparm_pad_len;\n-static GTY(()) tree ioparm_format;\n-static GTY(()) tree ioparm_format_len;\n-static GTY(()) tree ioparm_advance;\n-static GTY(()) tree ioparm_advance_len;\n-static GTY(()) tree ioparm_name;\n-static GTY(()) tree ioparm_name_len;\n-static GTY(()) tree ioparm_internal_unit;\n-static GTY(()) tree ioparm_internal_unit_len;\n-static GTY(()) tree ioparm_internal_unit_desc;\n-static GTY(()) tree ioparm_sequential;\n-static GTY(()) tree ioparm_sequential_len;\n-static GTY(()) tree ioparm_direct;\n-static GTY(()) tree ioparm_direct_len;\n-static GTY(()) tree ioparm_formatted;\n-static GTY(()) tree ioparm_formatted_len;\n-static GTY(()) tree ioparm_unformatted;\n-static GTY(()) tree ioparm_unformatted_len;\n-static GTY(()) tree ioparm_read;\n-static GTY(()) tree ioparm_read_len;\n-static GTY(()) tree ioparm_write;\n-static GTY(()) tree ioparm_write_len;\n-static GTY(()) tree ioparm_readwrite;\n-static GTY(()) tree ioparm_readwrite_len;\n-static GTY(()) tree ioparm_namelist_name;\n-static GTY(()) tree ioparm_namelist_name_len;\n-static GTY(()) tree ioparm_namelist_read_mode;\n-static GTY(()) tree ioparm_iomsg;\n-static GTY(()) tree ioparm_iomsg_len;\n-\n-/* The global I/O variables */\n-\n-static GTY(()) tree ioparm_var;\n-static GTY(()) tree locus_file;\n-static GTY(()) tree locus_line;\n+enum ioparam_type\n+{\n+  IOPARM_ptype_common,\n+  IOPARM_ptype_open,\n+  IOPARM_ptype_close,\n+  IOPARM_ptype_filepos,\n+  IOPARM_ptype_inquire,\n+  IOPARM_ptype_dt,\n+  IOPARM_ptype_num\n+};\n+\n+enum iofield_type\n+{\n+  IOPARM_type_int4,\n+  IOPARM_type_pint4,\n+  IOPARM_type_pchar,\n+  IOPARM_type_parray,\n+  IOPARM_type_pad,\n+  IOPARM_type_char1,\n+  IOPARM_type_char2,\n+  IOPARM_type_common,\n+  IOPARM_type_num\n+};\n+\n+typedef struct gfc_st_parameter_field GTY(())\n+{\n+  const char *name;\n+  unsigned int mask;\n+  enum ioparam_type param_type;\n+  enum iofield_type type;\n+  tree field;\n+  tree field_len;\n+}\n+gfc_st_parameter_field;\n \n+typedef struct gfc_st_parameter GTY(())\n+{\n+  const char *name;\n+  tree type;\n+}\n+gfc_st_parameter;\n+\n+enum iofield\n+{\n+#define IOPARM(param_type, name, mask, type) IOPARM_##param_type##_##name,\n+#include \"ioparm.def\"\n+#undef IOPARM\n+  IOPARM_field_num\n+};\n+\n+static GTY(()) gfc_st_parameter st_parameter[] =\n+{\n+  { \"common\", NULL },\n+  { \"open\", NULL },\n+  { \"close\", NULL },\n+  { \"filepos\", NULL },\n+  { \"inquire\", NULL },\n+  { \"dt\", NULL }\n+};\n+\n+static GTY(()) gfc_st_parameter_field st_parameter_field[] =\n+{\n+#define IOPARM(param_type, name, mask, type) \\\n+  { #name, mask, IOPARM_ptype_##param_type, IOPARM_type_##type, NULL, NULL },\n+#include \"ioparm.def\"\n+#undef IOPARM\n+  { NULL, 0, 0, 0, NULL, NULL }\n+};\n \n /* Library I/O subroutines */\n \n-static GTY(()) tree iocall_read;\n-static GTY(()) tree iocall_read_done;\n-static GTY(()) tree iocall_write;\n-static GTY(()) tree iocall_write_done;\n-static GTY(()) tree iocall_x_integer;\n-static GTY(()) tree iocall_x_logical;\n-static GTY(()) tree iocall_x_character;\n-static GTY(()) tree iocall_x_real;\n-static GTY(()) tree iocall_x_complex;\n-static GTY(()) tree iocall_x_array;\n-static GTY(()) tree iocall_open;\n-static GTY(()) tree iocall_close;\n-static GTY(()) tree iocall_inquire;\n-static GTY(()) tree iocall_iolength;\n-static GTY(()) tree iocall_iolength_done;\n-static GTY(()) tree iocall_rewind;\n-static GTY(()) tree iocall_backspace;\n-static GTY(()) tree iocall_endfile;\n-static GTY(()) tree iocall_flush;\n-static GTY(()) tree iocall_set_nml_val;\n-static GTY(()) tree iocall_set_nml_val_dim;\n+enum iocall\n+{\n+  IOCALL_READ,\n+  IOCALL_READ_DONE,\n+  IOCALL_WRITE,\n+  IOCALL_WRITE_DONE,\n+  IOCALL_X_INTEGER,\n+  IOCALL_X_LOGICAL,\n+  IOCALL_X_CHARACTER,\n+  IOCALL_X_REAL,\n+  IOCALL_X_COMPLEX,\n+  IOCALL_X_ARRAY,\n+  IOCALL_OPEN,\n+  IOCALL_CLOSE,\n+  IOCALL_INQUIRE,\n+  IOCALL_IOLENGTH,\n+  IOCALL_IOLENGTH_DONE,\n+  IOCALL_REWIND,\n+  IOCALL_BACKSPACE,\n+  IOCALL_ENDFILE,\n+  IOCALL_FLUSH,\n+  IOCALL_SET_NML_VAL,\n+  IOCALL_SET_NML_VAL_DIM,\n+  IOCALL_NUM\n+};\n+\n+static GTY(()) tree iocall[IOCALL_NUM];\n \n /* Variable for keeping track of what the last data transfer statement\n    was.  Used for deciding which subroutine to call when the data\n    transfer is complete.  */\n static enum { READ, WRITE, IOLENGTH } last_dt;\n \n-#define ADD_FIELD(name, type)\t\t\t\t\t\t\\\n-  ioparm_ ## name = gfc_add_field_to_struct\t\t\t\t\\\n-        (&(TYPE_FIELDS (ioparm_type)), ioparm_type,\t\t\t\\\n-\t get_identifier (stringize(name)), type)\n+/* The data transfer parameter block that should be shared by all\n+   data transfer calls belonging to the same read/write/iolength.  */\n+static GTY(()) tree dt_parm;\n+static stmtblock_t *dt_post_end_block;\n \n-#define ADD_STRING(name) \\\n-  ioparm_ ## name = gfc_add_field_to_struct\t\t\t\t\\\n-        (&(TYPE_FIELDS (ioparm_type)), ioparm_type,\t\t\t\\\n-\t get_identifier (stringize(name)), pchar_type_node);\t\t\\\n-  ioparm_ ## name ## _len = gfc_add_field_to_struct\t\t\t\\\n-        (&(TYPE_FIELDS (ioparm_type)), ioparm_type,\t\t\t\\\n-\t get_identifier (stringize(name) \"_len\"), gfc_charlen_type_node)\n+static void\n+gfc_build_st_parameter (enum ioparam_type ptype, tree *types)\n+{\n+  enum iofield type;\n+  gfc_st_parameter_field *p;\n+  char name[64];\n+  size_t len;\n+  tree t = make_node (RECORD_TYPE);\n+\n+  len = strlen (st_parameter[ptype].name);\n+  gcc_assert (len <= sizeof (name) - sizeof (\"__st_parameter_\"));\n+  memcpy (name, \"__st_parameter_\", sizeof (\"__st_parameter_\"));\n+  memcpy (name + sizeof (\"__st_parameter_\") - 1, st_parameter[ptype].name,\n+\t  len);\n+  TYPE_NAME (t) = get_identifier (name);\n+\n+  for (type = 0, p = st_parameter_field; type < IOPARM_field_num; type++, p++)\n+    if (p->param_type == ptype)\n+      switch (p->type)\n+\t{\n+\tcase IOPARM_type_int4:\n+\tcase IOPARM_type_pint4:\n+\tcase IOPARM_type_parray:\n+\tcase IOPARM_type_pchar:\n+\tcase IOPARM_type_pad:\n+\t  p->field = gfc_add_field_to_struct (&TYPE_FIELDS (t), t,\n+\t\t\t\t\t      get_identifier (p->name),\n+\t\t\t\t\t      types[p->type]);\n+\t  break;\n+\tcase IOPARM_type_char1:\n+\t  p->field = gfc_add_field_to_struct (&TYPE_FIELDS (t), t,\n+\t\t\t\t\t      get_identifier (p->name),\n+\t\t\t\t\t      pchar_type_node);\n+\t  /* FALLTHROUGH */\n+\tcase IOPARM_type_char2:\n+\t  len = strlen (p->name);\n+\t  gcc_assert (len <= sizeof (name) - sizeof (\"_len\"));\n+\t  memcpy (name, p->name, len);\n+\t  memcpy (name + len, \"_len\", sizeof (\"_len\"));\n+\t  p->field_len = gfc_add_field_to_struct (&TYPE_FIELDS (t), t,\n+\t\t\t\t\t\t  get_identifier (name),\n+\t\t\t\t\t\t  gfc_charlen_type_node);\n+\t  if (p->type == IOPARM_type_char2)\n+\t    p->field = gfc_add_field_to_struct (&TYPE_FIELDS (t), t,\n+\t\t\t\t\t\tget_identifier (p->name),\n+\t\t\t\t\t\tpchar_type_node);\n+\t  break;\n+\tcase IOPARM_type_common:\n+\t  p->field\n+\t    = gfc_add_field_to_struct (&TYPE_FIELDS (t), t,\n+\t\t\t\t       get_identifier (p->name),\n+\t\t\t\t       st_parameter[IOPARM_ptype_common].type);\n+\t  break;\n+\tcase IOPARM_type_num:\n+\t  gcc_unreachable ();\n+\t}\n \n+  gfc_finish_type (t);\n+  st_parameter[ptype].type = t;\n+}\n \n /* Create function decls for IO library functions.  */\n \n void\n gfc_build_io_library_fndecls (void)\n {\n-  tree gfc_int4_type_node;\n-  tree gfc_pint4_type_node;\n+  tree types[IOPARM_type_num], pad_idx, gfc_int4_type_node;\n+  tree parm_type, dt_parm_type;\n   tree gfc_c_int_type_node;\n-  tree ioparm_type;\n-\n-  gfc_int4_type_node = gfc_get_int_type (4);\n-  gfc_pint4_type_node = build_pointer_type (gfc_int4_type_node);\n+  HOST_WIDE_INT pad_size;\n+  enum ioparam_type ptype;\n+\n+  types[IOPARM_type_int4] = gfc_int4_type_node = gfc_get_int_type (4);\n+  types[IOPARM_type_pint4] = build_pointer_type (gfc_int4_type_node);\n+  types[IOPARM_type_parray] = pchar_type_node;\n+  types[IOPARM_type_pchar] = pchar_type_node;\n+  pad_size = 16 * TREE_INT_CST_LOW (TYPE_SIZE_UNIT (pchar_type_node));\n+  pad_size += 32 * TREE_INT_CST_LOW (TYPE_SIZE_UNIT (integer_type_node));\n+  pad_idx = build_index_type (build_int_cst (NULL_TREE, pad_size));\n+  types[IOPARM_type_pad] = build_array_type (char_type_node, pad_idx);\n   gfc_c_int_type_node = gfc_get_int_type (gfc_c_int_kind);\n \n-  /* Build the st_parameter structure.  Information associated with I/O\n-     calls are transferred here.  This must match the one defined in the\n-     library exactly.  */\n-\n-  ioparm_type = make_node (RECORD_TYPE);\n-  TYPE_NAME (ioparm_type) = get_identifier (\"_gfc_ioparm\");\n-\n-  ADD_FIELD (unit, gfc_int4_type_node);\n-  ADD_FIELD (err, gfc_int4_type_node);\n-  ADD_FIELD (end, gfc_int4_type_node);\n-  ADD_FIELD (eor, gfc_int4_type_node);\n-  ADD_FIELD (list_format, gfc_int4_type_node);\n-  ADD_FIELD (library_return, gfc_int4_type_node);\n-\n-  ADD_FIELD (iostat, gfc_pint4_type_node);\n-  ADD_FIELD (exist, gfc_pint4_type_node);\n-  ADD_FIELD (opened, gfc_pint4_type_node);\n-  ADD_FIELD (number, gfc_pint4_type_node);\n-  ADD_FIELD (named, gfc_pint4_type_node);\n-  ADD_FIELD (rec, gfc_int4_type_node);\n-  ADD_FIELD (nextrec, gfc_pint4_type_node);\n-  ADD_FIELD (size, gfc_pint4_type_node);\n-\n-  ADD_FIELD (recl_in, gfc_int4_type_node);\n-  ADD_FIELD (recl_out, gfc_pint4_type_node);\n-\n-  ADD_FIELD (iolength, gfc_pint4_type_node);\n-\n-  ADD_STRING (file);\n-  ADD_STRING (status);\n-\n-  ADD_STRING (access);\n-  ADD_STRING (form);\n-  ADD_STRING (blank);\n-  ADD_STRING (position);\n-  ADD_STRING (action);\n-  ADD_STRING (delim);\n-  ADD_STRING (pad);\n-  ADD_STRING (format);\n-  ADD_STRING (advance);\n-  ADD_STRING (name);\n-  ADD_STRING (internal_unit);\n-  ADD_FIELD (internal_unit_desc, pchar_type_node);\n-  ADD_STRING (sequential);\n-\n-  ADD_STRING (direct);\n-  ADD_STRING (formatted);\n-  ADD_STRING (unformatted);\n-  ADD_STRING (read);\n-  ADD_STRING (write);\n-  ADD_STRING (readwrite);\n-\n-  ADD_STRING (namelist_name);\n-  ADD_FIELD (namelist_read_mode, gfc_int4_type_node);\n-  ADD_STRING (iomsg);\n-\n-  gfc_finish_type (ioparm_type);\n-\n-  ioparm_var = build_decl (VAR_DECL, get_identifier (PREFIX(\"ioparm\")),\n-\t\t\t   ioparm_type);\n-  DECL_EXTERNAL (ioparm_var) = 1;\n-  TREE_PUBLIC (ioparm_var) = 1;\n-\n-  locus_line = build_decl (VAR_DECL, get_identifier (PREFIX(\"line\")),\n-\t\t\t   gfc_int4_type_node);\n-  DECL_EXTERNAL (locus_line) = 1;\n-  TREE_PUBLIC (locus_line) = 1;\n-\n-  locus_file = build_decl (VAR_DECL, get_identifier (PREFIX(\"filename\")),\n-\t\t\t   pchar_type_node);\n-  DECL_EXTERNAL (locus_file) = 1;\n-  TREE_PUBLIC (locus_file) = 1;\n+  for (ptype = IOPARM_ptype_common; ptype < IOPARM_ptype_num; ptype++)\n+    gfc_build_st_parameter (ptype, types);\n \n   /* Define the transfer functions.  */\n \n-  iocall_x_integer =\n+  dt_parm_type = build_pointer_type (st_parameter[IOPARM_ptype_dt].type);\n+\n+  iocall[IOCALL_X_INTEGER] =\n     gfc_build_library_function_decl (get_identifier\n \t\t\t\t     (PREFIX(\"transfer_integer\")),\n-\t\t\t\t     void_type_node, 2, pvoid_type_node,\n-\t\t\t\t     gfc_int4_type_node);\n+\t\t\t\t     void_type_node, 3, dt_parm_type,\n+\t\t\t\t     pvoid_type_node, gfc_int4_type_node);\n \n-  iocall_x_logical =\n+  iocall[IOCALL_X_LOGICAL] =\n     gfc_build_library_function_decl (get_identifier\n \t\t\t\t     (PREFIX(\"transfer_logical\")),\n-\t\t\t\t     void_type_node, 2, pvoid_type_node,\n-\t\t\t\t     gfc_int4_type_node);\n+\t\t\t\t     void_type_node, 3, dt_parm_type,\n+\t\t\t\t     pvoid_type_node, gfc_int4_type_node);\n \n-  iocall_x_character =\n+  iocall[IOCALL_X_CHARACTER] =\n     gfc_build_library_function_decl (get_identifier\n \t\t\t\t     (PREFIX(\"transfer_character\")),\n-\t\t\t\t     void_type_node, 2, pvoid_type_node,\n-\t\t\t\t     gfc_int4_type_node);\n+\t\t\t\t     void_type_node, 3, dt_parm_type,\n+\t\t\t\t     pvoid_type_node, gfc_int4_type_node);\n \n-  iocall_x_real =\n+  iocall[IOCALL_X_REAL] =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"transfer_real\")),\n-\t\t\t\t     void_type_node, 2,\n+\t\t\t\t     void_type_node, 3, dt_parm_type,\n \t\t\t\t     pvoid_type_node, gfc_int4_type_node);\n \n-  iocall_x_complex =\n+  iocall[IOCALL_X_COMPLEX] =\n     gfc_build_library_function_decl (get_identifier\n \t\t\t\t     (PREFIX(\"transfer_complex\")),\n-\t\t\t\t     void_type_node, 2, pvoid_type_node,\n-\t\t\t\t     gfc_int4_type_node);\n+\t\t\t\t     void_type_node, 3, dt_parm_type,\n+\t\t\t\t     pvoid_type_node, gfc_int4_type_node);\n \n-  iocall_x_array =\n+  iocall[IOCALL_X_ARRAY] =\n     gfc_build_library_function_decl (get_identifier\n \t\t\t\t     (PREFIX(\"transfer_array\")),\n-\t\t\t\t     void_type_node, 3, pvoid_type_node,\n-\t\t\t\t     gfc_c_int_type_node,\n+\t\t\t\t     void_type_node, 4, dt_parm_type,\n+\t\t\t\t     pvoid_type_node, gfc_c_int_type_node,\n \t\t\t\t     gfc_charlen_type_node);\n \n   /* Library entry points */\n \n-  iocall_read =\n+  iocall[IOCALL_READ] =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"st_read\")),\n-\t\t\t\t     void_type_node, 0);\n+\t\t\t\t     void_type_node, 1, dt_parm_type);\n \n-  iocall_write =\n+  iocall[IOCALL_WRITE] =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"st_write\")),\n-\t\t\t\t     void_type_node, 0);\n-  iocall_open =\n+\t\t\t\t     void_type_node, 1, dt_parm_type);\n+\n+  parm_type = build_pointer_type (st_parameter[IOPARM_ptype_open].type);\n+  iocall[IOCALL_OPEN] =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"st_open\")),\n-\t\t\t\t     void_type_node, 0);\n+\t\t\t\t     void_type_node, 1, parm_type);\n+\n \n-  iocall_close =\n+  parm_type = build_pointer_type (st_parameter[IOPARM_ptype_close].type);\n+  iocall[IOCALL_CLOSE] =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"st_close\")),\n-\t\t\t\t     void_type_node, 0);\n+\t\t\t\t     void_type_node, 1, parm_type);\n \n-  iocall_inquire =\n+  parm_type = build_pointer_type (st_parameter[IOPARM_ptype_inquire].type);\n+  iocall[IOCALL_INQUIRE] =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"st_inquire\")),\n-\t\t\t\t     gfc_int4_type_node, 0);\n+\t\t\t\t     gfc_int4_type_node, 1, parm_type);\n \n-  iocall_iolength =\n+  iocall[IOCALL_IOLENGTH] =\n     gfc_build_library_function_decl(get_identifier (PREFIX(\"st_iolength\")),\n-\t\t\t\t    void_type_node, 0);\n+\t\t\t\t    void_type_node, 1, dt_parm_type);\n \n-  iocall_rewind =\n+  parm_type = build_pointer_type (st_parameter[IOPARM_ptype_filepos].type);\n+  iocall[IOCALL_REWIND] =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"st_rewind\")),\n-\t\t\t\t     gfc_int4_type_node, 0);\n+\t\t\t\t     gfc_int4_type_node, 1, parm_type);\n \n-  iocall_backspace =\n+  iocall[IOCALL_BACKSPACE] =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"st_backspace\")),\n-\t\t\t\t     gfc_int4_type_node, 0);\n+\t\t\t\t     gfc_int4_type_node, 1, parm_type);\n \n-  iocall_endfile =\n+  iocall[IOCALL_ENDFILE] =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"st_endfile\")),\n-\t\t\t\t     gfc_int4_type_node, 0);\n+\t\t\t\t     gfc_int4_type_node, 1, parm_type);\n \n-  iocall_flush =\n+  iocall[IOCALL_FLUSH] =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"st_flush\")),\n-\t\t\t\t     gfc_int4_type_node, 0);\n+\t\t\t\t     gfc_int4_type_node, 1, parm_type);\n \n   /* Library helpers */\n \n-  iocall_read_done =\n+  iocall[IOCALL_READ_DONE] =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"st_read_done\")),\n-\t\t\t\t     gfc_int4_type_node, 0);\n+\t\t\t\t     gfc_int4_type_node, 1, dt_parm_type);\n \n-  iocall_write_done =\n+  iocall[IOCALL_WRITE_DONE] =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"st_write_done\")),\n-\t\t\t\t     gfc_int4_type_node, 0);\n+\t\t\t\t     gfc_int4_type_node, 1, dt_parm_type);\n \n-  iocall_iolength_done =\n+  iocall[IOCALL_IOLENGTH_DONE] =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"st_iolength_done\")),\n-\t\t\t\t     gfc_int4_type_node, 0);\n+\t\t\t\t     gfc_int4_type_node, 1, dt_parm_type);\n \n \n-  iocall_set_nml_val =\n+  iocall[IOCALL_SET_NML_VAL] =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"st_set_nml_var\")),\n-                                     void_type_node, 5,\n-                                     pvoid_type_node, pvoid_type_node,\n-                                     gfc_int4_type_node, gfc_charlen_type_node, \n+\t\t\t\t     void_type_node, 6, dt_parm_type,\n+\t\t\t\t     pvoid_type_node, pvoid_type_node,\n+\t\t\t\t     gfc_int4_type_node, gfc_charlen_type_node,\n \t\t\t\t     gfc_int4_type_node);\n \n-  iocall_set_nml_val_dim =\n+  iocall[IOCALL_SET_NML_VAL_DIM] =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"st_set_nml_var_dim\")),\n-\t\t\t\t     void_type_node, 4,\n+\t\t\t\t     void_type_node, 5, dt_parm_type,\n \t\t\t\t     gfc_int4_type_node, gfc_int4_type_node,\n \t\t\t\t     gfc_int4_type_node, gfc_int4_type_node);\n }\n \n \n+/* Generate code to store an integer constant into the\n+   st_parameter_XXX structure.  */\n+\n+static unsigned int\n+set_parameter_const (stmtblock_t *block, tree var, enum iofield type,\n+\t\t     unsigned int val)\n+{\n+  tree tmp;\n+  gfc_st_parameter_field *p = &st_parameter_field[type];\n+\n+  if (p->param_type == IOPARM_ptype_common)\n+    var = build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n+\t\t  var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n+  tmp = build3 (COMPONENT_REF, TREE_TYPE (p->field), var, p->field,\n+\t\tNULL_TREE);\n+  gfc_add_modify_expr (block, tmp, build_int_cst (TREE_TYPE (p->field), val));\n+  return p->mask;\n+}\n+\n+\n /* Generate code to store a non-string I/O parameter into the\n-   ioparm structure.  This is a pass by value.  */\n+   st_parameter_XXX structure.  This is a pass by value.  */\n \n-static void\n-set_parameter_value (stmtblock_t * block, tree var, gfc_expr * e)\n+static unsigned int\n+set_parameter_value (stmtblock_t *block, tree var, enum iofield type,\n+\t\t     gfc_expr *e)\n {\n   gfc_se se;\n   tree tmp;\n+  gfc_st_parameter_field *p = &st_parameter_field[type];\n \n   gfc_init_se (&se, NULL);\n-  gfc_conv_expr_type (&se, e, TREE_TYPE (var));\n+  gfc_conv_expr_type (&se, e, TREE_TYPE (p->field));\n   gfc_add_block_to_block (block, &se.pre);\n \n-  tmp = build3 (COMPONENT_REF, TREE_TYPE (var), ioparm_var, var, NULL_TREE);\n+  if (p->param_type == IOPARM_ptype_common)\n+    var = build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n+\t\t  var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n+  tmp = build3 (COMPONENT_REF, TREE_TYPE (p->field), var, p->field,\n+\t\tNULL_TREE);\n   gfc_add_modify_expr (block, tmp, se.expr);\n+  return p->mask;\n }\n \n \n /* Generate code to store a non-string I/O parameter into the\n-   ioparm structure.  This is pass by reference.  */\n+   st_parameter_XXX structure.  This is pass by reference.  */\n \n-static void\n-set_parameter_ref (stmtblock_t * block, tree var, gfc_expr * e)\n+static unsigned int\n+set_parameter_ref (stmtblock_t *block, stmtblock_t *postblock,\n+\t\t   tree var, enum iofield type, gfc_expr *e)\n {\n   gfc_se se;\n-  tree tmp;\n+  tree tmp, addr;\n+  gfc_st_parameter_field *p = &st_parameter_field[type];\n \n+  gcc_assert (e->ts.type == BT_INTEGER || e->ts.type == BT_LOGICAL);\n   gfc_init_se (&se, NULL);\n-  se.want_pointer = 1;\n+  gfc_conv_expr_lhs (&se, e);\n \n-  gfc_conv_expr_type (&se, e, TREE_TYPE (var));\n   gfc_add_block_to_block (block, &se.pre);\n \n-  tmp = build3 (COMPONENT_REF, TREE_TYPE (var), ioparm_var, var, NULL_TREE);\n-  gfc_add_modify_expr (block, tmp, se.expr);\n+  if (TYPE_MODE (TREE_TYPE (se.expr))\n+      == TYPE_MODE (TREE_TYPE (TREE_TYPE (p->field))))\n+    addr = convert (TREE_TYPE (p->field),\n+\t\t    gfc_build_addr_expr (NULL, se.expr));\n+  else\n+    {\n+      /* The type used by the library has different size\n+\t from the type of the variable supplied by the user.\n+\t Need to use a temporary.  */\n+      tree tmpvar\n+\t= gfc_create_var (TREE_TYPE (TREE_TYPE (p->field)),\n+\t\t\t  st_parameter_field[type].name);\n+      addr = gfc_build_addr_expr (NULL, tmpvar);\n+      tmp = convert (TREE_TYPE (se.expr), tmpvar);\n+      gfc_add_modify_expr (postblock, se.expr, tmp);\n+    }\n+\n+  if (p->param_type == IOPARM_ptype_common)\n+    var = build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n+\t\t  var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n+  tmp = build3 (COMPONENT_REF, TREE_TYPE (p->field), var, p->field,\n+\t\tNULL_TREE);\n+  gfc_add_modify_expr (block, tmp, addr);\n+  return p->mask;\n }\n \n /* Given an array expr, find its address and length to get a string. If the\n@@ -450,22 +502,27 @@ gfc_convert_array_to_string (gfc_se * se, gfc_expr * e)\n \n \n /* Generate code to store a string and its length into the\n-   ioparm structure.  */\n+   st_parameter_XXX structure.  */\n \n-static void\n+static unsigned int\n set_string (stmtblock_t * block, stmtblock_t * postblock, tree var,\n-\t    tree var_len, gfc_expr * e)\n+\t    enum iofield type, gfc_expr * e)\n {\n   gfc_se se;\n   tree tmp;\n   tree msg;\n   tree io;\n   tree len;\n+  gfc_st_parameter_field *p = &st_parameter_field[type];\n \n   gfc_init_se (&se, NULL);\n \n-  io = build3 (COMPONENT_REF, TREE_TYPE (var), ioparm_var, var, NULL_TREE);\n-  len = build3 (COMPONENT_REF, TREE_TYPE (var_len), ioparm_var, var_len,\n+  if (p->param_type == IOPARM_ptype_common)\n+    var = build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n+\t\t  var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n+  io = build3 (COMPONENT_REF, TREE_TYPE (p->field), var, p->field,\n+\t       NULL_TREE);\n+  len = build3 (COMPONENT_REF, TREE_TYPE (p->field_len), var, p->field_len,\n \t\tNULL_TREE);\n \n   /* Integer variable assigned a format label.  */\n@@ -500,28 +557,34 @@ set_string (stmtblock_t * block, stmtblock_t * postblock, tree var,\n \n   gfc_add_block_to_block (block, &se.pre);\n   gfc_add_block_to_block (postblock, &se.post);\n+  return p->mask;\n }\n \n \n /* Generate code to store the character (array) and the character length\n    for an internal unit.  */\n \n-static void\n-set_internal_unit (stmtblock_t * block, tree iunit, tree iunit_len,\n-\t\t   tree iunit_desc, gfc_expr * e)\n+static unsigned int\n+set_internal_unit (stmtblock_t * block, tree var, gfc_expr * e)\n {\n   gfc_se se;\n   tree io;\n   tree len;\n   tree desc;\n   tree tmp;\n+  gfc_st_parameter_field *p;\n+  unsigned int mask;\n \n   gfc_init_se (&se, NULL);\n \n-  io = build3 (COMPONENT_REF, TREE_TYPE (iunit), ioparm_var, iunit, NULL_TREE);\n-  len = build3 (COMPONENT_REF, TREE_TYPE (iunit_len), ioparm_var, iunit_len,\n+  p = &st_parameter_field[IOPARM_dt_internal_unit];\n+  mask = p->mask;\n+  io = build3 (COMPONENT_REF, TREE_TYPE (p->field), var, p->field,\n+\t       NULL_TREE);\n+  len = build3 (COMPONENT_REF, TREE_TYPE (p->field_len), var, p->field_len,\n \t\tNULL_TREE);\n-  desc = build3 (COMPONENT_REF, TREE_TYPE (iunit_desc), ioparm_var, iunit_desc,\n+  p = &st_parameter_field[IOPARM_dt_internal_unit_desc];\n+  desc = build3 (COMPONENT_REF, TREE_TYPE (p->field), var, p->field,\n \t\t NULL_TREE);\n \n   gcc_assert (e->ts.type == BT_CHARACTER);\n@@ -555,19 +618,9 @@ set_internal_unit (stmtblock_t * block, tree iunit, tree iunit_len,\n   gfc_add_modify_expr (&se.pre, desc, se.expr);\n \n   gfc_add_block_to_block (block, &se.pre);\n+  return mask;\n }\n \n-/* Set a member of the ioparm structure to one.  */\n-static void\n-set_flag (stmtblock_t *block, tree var)\n-{\n-  tree tmp, type = TREE_TYPE (var);\n-\n-  tmp = build3 (COMPONENT_REF, type, ioparm_var, var, NULL_TREE);\n-  gfc_add_modify_expr (block, tmp, convert (type, integer_one_node));\n-}\n-\n-\n /* Add a case to a IO-result switch.  */\n \n static void\n@@ -600,11 +653,12 @@ add_case (int label_value, gfc_st_label * label, stmtblock_t * body)\n    be created anyway.  */\n \n static void\n-io_result (stmtblock_t * block, gfc_st_label * err_label,\n+io_result (stmtblock_t * block, tree var, gfc_st_label * err_label,\n \t   gfc_st_label * end_label, gfc_st_label * eor_label)\n {\n   stmtblock_t body;\n   tree tmp, rc;\n+  gfc_st_parameter_field *p = &st_parameter_field[IOPARM_common_flags];\n \n   /* If no labels are specified, ignore the result instead\n      of building an empty switch.  */\n@@ -624,8 +678,12 @@ io_result (stmtblock_t * block, gfc_st_label * err_label,\n \n   tmp = gfc_finish_block (&body);\n \n-  rc = build3 (COMPONENT_REF, TREE_TYPE (ioparm_library_return), ioparm_var,\n-\t       ioparm_library_return, NULL_TREE);\n+  var = build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n+\t\tvar, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n+  rc = build3 (COMPONENT_REF, TREE_TYPE (p->field), var, p->field,\n+\t       NULL_TREE);\n+  rc = build2 (BIT_AND_EXPR, TREE_TYPE (rc), rc,\n+\t       build_int_cst (TREE_TYPE (rc), IOPARM_common_libreturn_mask));\n \n   tmp = build3_v (SWITCH_EXPR, rc, tmp, NULL_TREE);\n \n@@ -637,24 +695,29 @@ io_result (stmtblock_t * block, gfc_st_label * err_label,\n    library call goes awry, we can tell the user where the problem is.  */\n \n static void\n-set_error_locus (stmtblock_t * block, locus * where)\n+set_error_locus (stmtblock_t * block, tree var, locus * where)\n {\n   gfc_file *f;\n-  tree tmp;\n+  tree str, locus_file;\n   int line;\n+  gfc_st_parameter_field *p = &st_parameter_field[IOPARM_common_filename];\n \n+  locus_file = build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n+\t\t       var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n+  locus_file = build3 (COMPONENT_REF, TREE_TYPE (p->field), locus_file,\n+\t\t       p->field, NULL_TREE);\n   f = where->lb->file;\n-  tmp = gfc_build_cstring_const (f->filename);\n+  str = gfc_build_cstring_const (f->filename);\n \n-  tmp = gfc_build_addr_expr (pchar_type_node, tmp);\n-  gfc_add_modify_expr (block, locus_file, tmp);\n+  str = gfc_build_addr_expr (pchar_type_node, str);\n+  gfc_add_modify_expr (block, locus_file, str);\n \n #ifdef USE_MAPPED_LOCATION\n   line = LOCATION_LINE (where->lb->location);\n #else\n   line = where->lb->linenum;\n #endif\n-  gfc_add_modify_expr (block, locus_line, build_int_cst (NULL_TREE, line));\n+  set_parameter_const (block, var, IOPARM_common_line, line);\n }\n \n \n@@ -665,69 +728,79 @@ gfc_trans_open (gfc_code * code)\n {\n   stmtblock_t block, post_block;\n   gfc_open *p;\n-  tree tmp;\n+  tree tmp, var;\n+  unsigned int mask = 0;\n \n-  gfc_init_block (&block);\n+  gfc_start_block (&block);\n   gfc_init_block (&post_block);\n \n-  set_error_locus (&block, &code->loc);\n+  var = gfc_create_var (st_parameter[IOPARM_ptype_open].type, \"open_parm\");\n+\n+  set_error_locus (&block, var, &code->loc);\n   p = code->ext.open;\n \n   if (p->unit)\n-    set_parameter_value (&block, ioparm_unit, p->unit);\n+    set_parameter_value (&block, var, IOPARM_common_unit, p->unit);\n+  else\n+    set_parameter_const (&block, var, IOPARM_common_unit, 0);\n \n   if (p->file)\n-    set_string (&block, &post_block, ioparm_file, ioparm_file_len, p->file);\n+    mask |= set_string (&block, &post_block, var, IOPARM_open_file, p->file);\n \n   if (p->status)\n-    set_string (&block, &post_block, ioparm_status,\n-\t\tioparm_status_len, p->status);\n+    mask |= set_string (&block, &post_block, var, IOPARM_open_status,\n+\t\t\tp->status);\n \n   if (p->access)\n-    set_string (&block, &post_block, ioparm_access,\n-\t\tioparm_access_len, p->access);\n+    mask |= set_string (&block, &post_block, var, IOPARM_open_access,\n+\t\t\tp->access);\n \n   if (p->form)\n-    set_string (&block, &post_block, ioparm_form, ioparm_form_len, p->form);\n+    mask |= set_string (&block, &post_block, var, IOPARM_open_form, p->form);\n \n   if (p->recl)\n-    set_parameter_value (&block, ioparm_recl_in, p->recl);\n+    mask |= set_parameter_value (&block, var, IOPARM_open_recl_in, p->recl);\n \n   if (p->blank)\n-    set_string (&block, &post_block, ioparm_blank, ioparm_blank_len,\n-\t\tp->blank);\n+    mask |= set_string (&block, &post_block, var, IOPARM_open_blank,\n+\t\t\tp->blank);\n \n   if (p->position)\n-    set_string (&block, &post_block, ioparm_position,\n-\t\tioparm_position_len, p->position);\n+    mask |= set_string (&block, &post_block, var, IOPARM_open_position,\n+\t\t\tp->position);\n \n   if (p->action)\n-    set_string (&block, &post_block, ioparm_action,\n-\t\tioparm_action_len, p->action);\n+    mask |= set_string (&block, &post_block, var, IOPARM_open_action,\n+\t\t\tp->action);\n \n   if (p->delim)\n-    set_string (&block, &post_block, ioparm_delim, ioparm_delim_len,\n-\t\tp->delim);\n+    mask |= set_string (&block, &post_block, var, IOPARM_open_delim,\n+\t\t\tp->delim);\n \n   if (p->pad)\n-    set_string (&block, &post_block, ioparm_pad, ioparm_pad_len, p->pad);\n+    mask |= set_string (&block, &post_block, var, IOPARM_open_pad, p->pad);\n \n   if (p->iomsg)\n-    set_string (&block, &post_block, ioparm_iomsg, ioparm_iomsg_len,\n-\t\tp->iomsg);\n+    mask |= set_string (&block, &post_block, var, IOPARM_common_iomsg,\n+\t\t\tp->iomsg);\n \n   if (p->iostat)\n-    set_parameter_ref (&block, ioparm_iostat, p->iostat);\n+    mask |= set_parameter_ref (&block, &post_block, var, IOPARM_common_iostat,\n+\t\t\t       p->iostat);\n \n   if (p->err)\n-    set_flag (&block, ioparm_err);\n+    mask |= IOPARM_common_err;\n+\n+  set_parameter_const (&block, var, IOPARM_common_flags, mask);\n \n-  tmp = gfc_build_function_call (iocall_open, NULL_TREE);\n+  tmp = gfc_build_addr_expr (NULL_TREE, var);\n+  tmp = gfc_chainon_list (NULL_TREE, tmp);\n+  tmp = gfc_build_function_call (iocall[IOCALL_OPEN], tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n   gfc_add_block_to_block (&block, &post_block);\n \n-  io_result (&block, p->err, NULL, NULL);\n+  io_result (&block, var, p->err, NULL, NULL);\n \n   return gfc_finish_block (&block);\n }\n@@ -740,37 +813,47 @@ gfc_trans_close (gfc_code * code)\n {\n   stmtblock_t block, post_block;\n   gfc_close *p;\n-  tree tmp;\n+  tree tmp, var;\n+  unsigned int mask = 0;\n \n-  gfc_init_block (&block);\n+  gfc_start_block (&block);\n   gfc_init_block (&post_block);\n \n-  set_error_locus (&block, &code->loc);\n+  var = gfc_create_var (st_parameter[IOPARM_ptype_close].type, \"close_parm\");\n+\n+  set_error_locus (&block, var, &code->loc);\n   p = code->ext.close;\n \n   if (p->unit)\n-    set_parameter_value (&block, ioparm_unit, p->unit);\n+    set_parameter_value (&block, var, IOPARM_common_unit, p->unit);\n+  else\n+    set_parameter_const (&block, var, IOPARM_common_unit, 0);\n \n   if (p->status)\n-    set_string (&block, &post_block, ioparm_status,\n-\t\tioparm_status_len, p->status);\n+    mask |= set_string (&block, &post_block, var, IOPARM_close_status,\n+\t\t\tp->status);\n \n   if (p->iomsg)\n-    set_string (&block, &post_block, ioparm_iomsg, ioparm_iomsg_len,\n-\t\tp->iomsg);\n+    mask |= set_string (&block, &post_block, var, IOPARM_common_iomsg,\n+\t\t\tp->iomsg);\n \n   if (p->iostat)\n-    set_parameter_ref (&block, ioparm_iostat, p->iostat);\n+    mask |= set_parameter_ref (&block, &post_block, var, IOPARM_common_iostat,\n+\t\t\t       p->iostat);\n \n   if (p->err)\n-    set_flag (&block, ioparm_err);\n+    mask |= IOPARM_common_err;\n \n-  tmp = gfc_build_function_call (iocall_close, NULL_TREE);\n+  set_parameter_const (&block, var, IOPARM_common_flags, mask);\n+\n+  tmp = gfc_build_addr_expr (NULL_TREE, var);\n+  tmp = gfc_chainon_list (NULL_TREE, tmp);\n+  tmp = gfc_build_function_call (iocall[IOCALL_CLOSE], tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n   gfc_add_block_to_block (&block, &post_block);\n \n-  io_result (&block, p->err, NULL, NULL);\n+  io_result (&block, var, p->err, NULL, NULL);\n \n   return gfc_finish_block (&block);\n }\n@@ -783,34 +866,45 @@ build_filepos (tree function, gfc_code * code)\n {\n   stmtblock_t block, post_block;\n   gfc_filepos *p;\n-  tree tmp;\n+  tree tmp, var;\n+  unsigned int mask = 0;\n \n   p = code->ext.filepos;\n \n-  gfc_init_block (&block);\n+  gfc_start_block (&block);\n   gfc_init_block (&post_block);\n \n-  set_error_locus (&block, &code->loc);\n+  var = gfc_create_var (st_parameter[IOPARM_ptype_filepos].type,\n+\t\t\t\"filepos_parm\");\n+\n+  set_error_locus (&block, var, &code->loc);\n \n   if (p->unit)\n-    set_parameter_value (&block, ioparm_unit, p->unit);\n+    set_parameter_value (&block, var, IOPARM_common_unit, p->unit);\n+  else\n+    set_parameter_const (&block, var, IOPARM_common_unit, 0);\n \n   if (p->iomsg)\n-    set_string (&block, &post_block, ioparm_iomsg, ioparm_iomsg_len,\n-\t\tp->iomsg);\n+    mask |= set_string (&block, &post_block, var, IOPARM_common_iomsg,\n+\t\t\tp->iomsg);\n \n   if (p->iostat)\n-    set_parameter_ref (&block, ioparm_iostat, p->iostat);\n+    mask |= set_parameter_ref (&block, &post_block, var, IOPARM_common_iostat,\n+\t\t\t       p->iostat);\n \n   if (p->err)\n-    set_flag (&block, ioparm_err);\n+    mask |= IOPARM_common_err;\n \n-  tmp = gfc_build_function_call (function, NULL);\n+  set_parameter_const (&block, var, IOPARM_common_flags, mask);\n+\n+  tmp = gfc_build_addr_expr (NULL_TREE, var);\n+  tmp = gfc_chainon_list (NULL_TREE, tmp);\n+  tmp = gfc_build_function_call (function, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n   gfc_add_block_to_block (&block, &post_block);\n \n-  io_result (&block, p->err, NULL, NULL);\n+  io_result (&block, var, p->err, NULL, NULL);\n \n   return gfc_finish_block (&block);\n }\n@@ -821,8 +915,7 @@ build_filepos (tree function, gfc_code * code)\n tree\n gfc_trans_backspace (gfc_code * code)\n {\n-\n-  return build_filepos (iocall_backspace, code);\n+  return build_filepos (iocall[IOCALL_BACKSPACE], code);\n }\n \n \n@@ -831,8 +924,7 @@ gfc_trans_backspace (gfc_code * code)\n tree\n gfc_trans_endfile (gfc_code * code)\n {\n-\n-  return build_filepos (iocall_endfile, code);\n+  return build_filepos (iocall[IOCALL_ENDFILE], code);\n }\n \n \n@@ -841,8 +933,7 @@ gfc_trans_endfile (gfc_code * code)\n tree\n gfc_trans_rewind (gfc_code * code)\n {\n-\n-  return build_filepos (iocall_rewind, code);\n+  return build_filepos (iocall[IOCALL_REWIND], code);\n }\n \n \n@@ -851,8 +942,7 @@ gfc_trans_rewind (gfc_code * code)\n tree\n gfc_trans_flush (gfc_code * code)\n {\n-\n-  return build_filepos (iocall_flush, code);\n+  return build_filepos (iocall[IOCALL_FLUSH], code);\n }\n \n \n@@ -863,115 +953,136 @@ gfc_trans_inquire (gfc_code * code)\n {\n   stmtblock_t block, post_block;\n   gfc_inquire *p;\n-  tree tmp;\n+  tree tmp, var;\n+  unsigned int mask = 0;\n \n-  gfc_init_block (&block);\n+  gfc_start_block (&block);\n   gfc_init_block (&post_block);\n \n-  set_error_locus (&block, &code->loc);\n+  var = gfc_create_var (st_parameter[IOPARM_ptype_inquire].type,\n+\t\t\t\"inquire_parm\");\n+\n+  set_error_locus (&block, var, &code->loc);\n   p = code->ext.inquire;\n \n   /* Sanity check.  */\n   if (p->unit && p->file)\n     gfc_error (\"INQUIRE statement at %L cannot contain both FILE and UNIT specifiers.\", &code->loc);\n \n   if (p->unit)\n-    set_parameter_value (&block, ioparm_unit, p->unit);\n+    set_parameter_value (&block, var, IOPARM_common_unit, p->unit);\n+  else\n+    set_parameter_const (&block, var, IOPARM_common_unit, 0);\n \n   if (p->file)\n-    set_string (&block, &post_block, ioparm_file, ioparm_file_len, p->file);\n+    mask |= set_string (&block, &post_block, var, IOPARM_inquire_file,\n+\t\t\tp->file);\n \n   if (p->iomsg)\n-    set_string (&block, &post_block, ioparm_iomsg, ioparm_iomsg_len,\n-\t\tp->iomsg);\n+    mask |= set_string (&block, &post_block, var, IOPARM_common_iomsg,\n+\t\t\tp->iomsg);\n \n   if (p->iostat)\n-    set_parameter_ref (&block, ioparm_iostat, p->iostat);\n+    mask |= set_parameter_ref (&block, &post_block, var, IOPARM_common_iostat,\n+\t\t\t       p->iostat);\n \n   if (p->exist)\n-    set_parameter_ref (&block, ioparm_exist, p->exist);\n+    mask |= set_parameter_ref (&block, &post_block, var, IOPARM_inquire_exist,\n+\t\t\t       p->exist);\n \n   if (p->opened)\n-    set_parameter_ref (&block, ioparm_opened, p->opened);\n+    mask |= set_parameter_ref (&block, &post_block, var, IOPARM_inquire_opened,\n+\t\t\t       p->opened);\n \n   if (p->number)\n-    set_parameter_ref (&block, ioparm_number, p->number);\n+    mask |= set_parameter_ref (&block, &post_block, var, IOPARM_inquire_number,\n+\t\t\t       p->number);\n \n   if (p->named)\n-    set_parameter_ref (&block, ioparm_named, p->named);\n+    mask |= set_parameter_ref (&block, &post_block, var, IOPARM_inquire_named,\n+\t\t\t       p->named);\n \n   if (p->name)\n-    set_string (&block, &post_block, ioparm_name, ioparm_name_len, p->name);\n+    mask |= set_string (&block, &post_block, var, IOPARM_inquire_name,\n+\t\t\tp->name);\n \n   if (p->access)\n-    set_string (&block, &post_block, ioparm_access,\n-\t\tioparm_access_len, p->access);\n+    mask |= set_string (&block, &post_block, var, IOPARM_inquire_access,\n+\t\t\tp->access);\n \n   if (p->sequential)\n-    set_string (&block, &post_block, ioparm_sequential,\n-\t\tioparm_sequential_len, p->sequential);\n+    mask |= set_string (&block, &post_block, var, IOPARM_inquire_sequential,\n+\t\t\tp->sequential);\n \n   if (p->direct)\n-    set_string (&block, &post_block, ioparm_direct,\n-\t\tioparm_direct_len, p->direct);\n+    mask |= set_string (&block, &post_block, var, IOPARM_inquire_direct,\n+\t\t\tp->direct);\n \n   if (p->form)\n-    set_string (&block, &post_block, ioparm_form, ioparm_form_len, p->form);\n+    mask |= set_string (&block, &post_block, var, IOPARM_inquire_form,\n+\t\t\tp->form);\n \n   if (p->formatted)\n-    set_string (&block, &post_block, ioparm_formatted,\n-\t\tioparm_formatted_len, p->formatted);\n+    mask |= set_string (&block, &post_block, var, IOPARM_inquire_formatted,\n+\t\t\tp->formatted);\n \n   if (p->unformatted)\n-    set_string (&block, &post_block, ioparm_unformatted,\n-\t\tioparm_unformatted_len, p->unformatted);\n+    mask |= set_string (&block, &post_block, var, IOPARM_inquire_unformatted,\n+\t\t\tp->unformatted);\n \n   if (p->recl)\n-    set_parameter_ref (&block, ioparm_recl_out, p->recl);\n+    mask |= set_parameter_ref (&block, &post_block, var,\n+\t\t\t       IOPARM_inquire_recl_out, p->recl);\n \n   if (p->nextrec)\n-    set_parameter_ref (&block, ioparm_nextrec, p->nextrec);\n+    mask |= set_parameter_ref (&block, &post_block, var,\n+\t\t\t       IOPARM_inquire_nextrec, p->nextrec);\n \n   if (p->blank)\n-    set_string (&block, &post_block, ioparm_blank, ioparm_blank_len,\n-\t\tp->blank);\n+    mask |= set_string (&block, &post_block, var, IOPARM_inquire_blank,\n+\t\t\tp->blank);\n \n   if (p->position)\n-    set_string (&block, &post_block, ioparm_position,\n-\t\tioparm_position_len, p->position);\n+    mask |= set_string (&block, &post_block, var, IOPARM_inquire_position,\n+\t\t\tp->position);\n \n   if (p->action)\n-    set_string (&block, &post_block, ioparm_action,\n-\t\tioparm_action_len, p->action);\n+    mask |= set_string (&block, &post_block, var, IOPARM_inquire_action,\n+\t\t\tp->action);\n \n   if (p->read)\n-    set_string (&block, &post_block, ioparm_read, ioparm_read_len, p->read);\n+    mask |= set_string (&block, &post_block, var, IOPARM_inquire_read,\n+\t\t\tp->read);\n \n   if (p->write)\n-    set_string (&block, &post_block, ioparm_write,\n-\t\tioparm_write_len, p->write);\n+    mask |= set_string (&block, &post_block, var, IOPARM_inquire_write,\n+\t\t\tp->write);\n \n   if (p->readwrite)\n-    set_string (&block, &post_block, ioparm_readwrite,\n-\t\tioparm_readwrite_len, p->readwrite);\n+    mask |= set_string (&block, &post_block, var, IOPARM_inquire_readwrite,\n+\t\t\tp->readwrite);\n \n   if (p->delim)\n-    set_string (&block, &post_block, ioparm_delim, ioparm_delim_len,\n-\t\tp->delim);\n+    mask |= set_string (&block, &post_block, var, IOPARM_inquire_delim,\n+\t\t\tp->delim);\n \n   if (p->pad)\n-    set_string (&block, &post_block, ioparm_pad, ioparm_pad_len,\n-                p->pad); \n+    mask |= set_string (&block, &post_block, var, IOPARM_inquire_pad,\n+\t\t\tp->pad);\n \n   if (p->err)\n-    set_flag (&block, ioparm_err);\n+    mask |= IOPARM_common_err;\n \n-  tmp = gfc_build_function_call (iocall_inquire, NULL);\n+  set_parameter_const (&block, var, IOPARM_common_flags, mask);\n+\n+  tmp = gfc_build_addr_expr (NULL_TREE, var);\n+  tmp = gfc_chainon_list (NULL_TREE, tmp);\n+  tmp = gfc_build_function_call (iocall[IOCALL_INQUIRE], tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n   gfc_add_block_to_block (&block, &post_block);\n \n-  io_result (&block, p->err, NULL, NULL);\n+  io_result (&block, var, p->err, NULL, NULL);\n \n   return gfc_finish_block (&block);\n }\n@@ -1085,8 +1196,8 @@ nml_get_addr_expr (gfc_symbol * sym, gfc_component * c,\n }\n \n /* For an object VAR_NAME whose base address is BASE_ADDR, generate a\n-   call to iocall_set_nml_val.  For derived type variable, recursively\n-   generate calls to iocall_set_nml_val for each component.  */\n+   call to iocall[IOCALL_SET_NML_VAL].  For derived type variable, recursively\n+   generate calls to iocall[IOCALL_SET_NML_VAL] for each component.  */\n \n #define NML_FIRST_ARG(a) args = gfc_chainon_list (NULL_TREE, a)\n #define NML_ADD_ARG(a) args = gfc_chainon_list (args, a)\n@@ -1105,6 +1216,7 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n   tree tmp;\n   tree args;\n   tree dtype;\n+  tree dt_parm_addr;\n   int n_dim; \n   int itype;\n   int rank = 0;\n@@ -1167,7 +1279,9 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n      The call for the scalar part transfers:\n      (address, name, type, kind or string_length, dtype)  */\n \n-  NML_FIRST_ARG (addr_expr);\n+  dt_parm_addr = gfc_build_addr_expr (NULL_TREE, dt_parm);\n+  NML_FIRST_ARG (dt_parm_addr);\n+  NML_ADD_ARG (addr_expr);\n   NML_ADD_ARG (string);\n   NML_ADD_ARG (IARG (ts->kind));\n \n@@ -1177,19 +1291,20 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n     NML_ADD_ARG (convert (gfc_charlen_type_node, integer_zero_node));\n \n   NML_ADD_ARG (dtype);\n-  tmp = gfc_build_function_call (iocall_set_nml_val, args);\n+  tmp = gfc_build_function_call (iocall[IOCALL_SET_NML_VAL], args);\n   gfc_add_expr_to_block (block, tmp);\n \n   /* If the object is an array, transfer rank times:\n      (null pointer, name, stride, lbound, ubound)  */\n \n   for ( n_dim = 0 ; n_dim < rank ; n_dim++ )\n     {\n-      NML_FIRST_ARG (IARG (n_dim));\n+      NML_FIRST_ARG (dt_parm_addr);\n+      NML_ADD_ARG (IARG (n_dim));\n       NML_ADD_ARG (GFC_TYPE_ARRAY_STRIDE (dt, n_dim));\n       NML_ADD_ARG (GFC_TYPE_ARRAY_LBOUND (dt, n_dim));\n       NML_ADD_ARG (GFC_TYPE_ARRAY_UBOUND (dt, n_dim));\n-      tmp = gfc_build_function_call (iocall_set_nml_val_dim, args);\n+      tmp = gfc_build_function_call (iocall[IOCALL_SET_NML_VAL_DIM], args);\n       gfc_add_expr_to_block (block, tmp);\n     }\n \n@@ -1221,98 +1336,142 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n    out by now.  */\n \n static tree\n-build_dt (tree * function, gfc_code * code)\n+build_dt (tree function, gfc_code * code)\n {\n-  stmtblock_t block, post_block;\n+  stmtblock_t block, post_block, post_end_block;\n   gfc_dt *dt;\n-  tree tmp;\n+  tree tmp, var;\n   gfc_expr *nmlname;\n   gfc_namelist *nml;\n+  unsigned int mask = 0;\n \n-  gfc_init_block (&block);\n+  gfc_start_block (&block);\n   gfc_init_block (&post_block);\n+  gfc_init_block (&post_end_block);\n+\n+  var = gfc_create_var (st_parameter[IOPARM_ptype_dt].type, \"dt_parm\");\n+\n+  set_error_locus (&block, var, &code->loc);\n+\n+  if (last_dt == IOLENGTH)\n+    {\n+      gfc_inquire *inq;\n+\n+      inq = code->ext.inquire;\n \n-  set_error_locus (&block, &code->loc);\n-  dt = code->ext.dt;\n+      /* First check that preconditions are met.  */\n+      gcc_assert (inq != NULL);\n+      gcc_assert (inq->iolength != NULL);\n \n-  gcc_assert (dt != NULL);\n+      /* Connect to the iolength variable.  */\n+      mask |= set_parameter_ref (&block, &post_end_block, var,\n+\t\t\t\t IOPARM_dt_iolength, inq->iolength);\n+      dt = NULL;\n+    }\n+  else\n+    {\n+      dt = code->ext.dt;\n+      gcc_assert (dt != NULL);\n+    }\n \n-  if (dt->io_unit)\n+  if (dt && dt->io_unit)\n     {\n       if (dt->io_unit->ts.type == BT_CHARACTER)\n \t{\n-\t  set_internal_unit (&block,\n-\t\t\t     ioparm_internal_unit,\n-\t\t\t     ioparm_internal_unit_len,\n-\t\t\t     ioparm_internal_unit_desc,\n-\t\t\t     dt->io_unit);\n+\t  mask |= set_internal_unit (&block, var, dt->io_unit);\n+\t  set_parameter_const (&block, var, IOPARM_common_unit, 0);\n \t}\n       else\n-\tset_parameter_value (&block, ioparm_unit, dt->io_unit);\n+\tset_parameter_value (&block, var, IOPARM_common_unit, dt->io_unit);\n     }\n+  else\n+    set_parameter_const (&block, var, IOPARM_common_unit, 0);\n \n-  if (dt->rec)\n-    set_parameter_value (&block, ioparm_rec, dt->rec);\n+  if (dt)\n+    {\n+      if (dt->rec)\n+\tmask |= set_parameter_value (&block, var, IOPARM_dt_rec, dt->rec);\n \n-  if (dt->advance)\n-    set_string (&block, &post_block, ioparm_advance, ioparm_advance_len,\n-\t\tdt->advance);\n+      if (dt->advance)\n+\tmask |= set_string (&block, &post_block, var, IOPARM_dt_advance,\n+\t\t\t    dt->advance);\n \n-  if (dt->format_expr)\n-    set_string (&block, &post_block, ioparm_format, ioparm_format_len,\n-\t\tdt->format_expr);\n+      if (dt->format_expr)\n+\tmask |= set_string (&block, &post_block, var, IOPARM_dt_format,\n+\t\t\t    dt->format_expr);\n \n-  if (dt->format_label)\n-    {\n-      if (dt->format_label == &format_asterisk)\n-\tset_flag (&block, ioparm_list_format);\n-      else\n-        set_string (&block, &post_block, ioparm_format,\n-\t\t    ioparm_format_len, dt->format_label->format);\n-    }\n+      if (dt->format_label)\n+\t{\n+\t  if (dt->format_label == &format_asterisk)\n+\t    mask |= IOPARM_dt_list_format;\n+\t  else\n+\t    mask |= set_string (&block, &post_block, var, IOPARM_dt_format,\n+\t\t\t\tdt->format_label->format);\n+\t}\n \n-  if (dt->iomsg)\n-    set_string (&block, &post_block, ioparm_iomsg, ioparm_iomsg_len,\n-\t\tdt->iomsg);\n+      if (dt->iomsg)\n+\tmask |= set_string (&block, &post_block, var, IOPARM_common_iomsg,\n+\t\t\t    dt->iomsg);\n \n-  if (dt->iostat)\n-    set_parameter_ref (&block, ioparm_iostat, dt->iostat);\n+      if (dt->iostat)\n+\tmask |= set_parameter_ref (&block, &post_end_block, var,\n+\t\t\t\t   IOPARM_common_iostat, dt->iostat);\n \n-  if (dt->size)\n-    set_parameter_ref (&block, ioparm_size, dt->size);\n+      if (dt->size)\n+\tmask |= set_parameter_ref (&block, &post_end_block, var,\n+\t\t\t\t   IOPARM_dt_size, dt->size);\n \n-  if (dt->err)\n-    set_flag (&block, ioparm_err);\n+      if (dt->err)\n+\tmask |= IOPARM_common_err;\n \n-  if (dt->eor)\n-    set_flag(&block, ioparm_eor);\n+      if (dt->eor)\n+\tmask |= IOPARM_common_eor;\n \n-  if (dt->end)\n-    set_flag(&block, ioparm_end);\n+      if (dt->end)\n+\tmask |= IOPARM_common_end;\n \n-  if (dt->namelist)\n-    {\n-      if (dt->format_expr || dt->format_label)\n-        gfc_internal_error (\"build_dt: format with namelist\");\n+      if (dt->namelist)\n+\t{\n+\t  if (dt->format_expr || dt->format_label)\n+\t    gfc_internal_error (\"build_dt: format with namelist\");\n+\n+\t  nmlname = gfc_new_nml_name_expr (dt->namelist->name);\n \n-      nmlname = gfc_new_nml_name_expr(dt->namelist->name);\n+\t  mask |= set_string (&block, &post_block, var, IOPARM_dt_namelist_name,\n+\t\t\t      nmlname);\n \n-      set_string (&block, &post_block, ioparm_namelist_name,\n-\t\t  ioparm_namelist_name_len, nmlname);\n+\t  if (last_dt == READ)\n+\t    mask |= IOPARM_dt_namelist_read_mode;\n \n-      if (last_dt == READ)\n-\tset_flag (&block, ioparm_namelist_read_mode);\n+\t  set_parameter_const (&block, var, IOPARM_common_flags, mask);\n \n-      for (nml = dt->namelist->namelist; nml; nml = nml->next)\n-\ttransfer_namelist_element (&block, nml->sym->name, nml->sym,\n-\t\t\t\t   NULL, NULL);\n+\t  dt_parm = var;\n+\n+\t  for (nml = dt->namelist->namelist; nml; nml = nml->next)\n+\t    transfer_namelist_element (&block, nml->sym->name, nml->sym,\n+\t\t\t\t       NULL, NULL);\n+\t}\n+      else\n+\tset_parameter_const (&block, var, IOPARM_common_flags, mask);\n     }\n+  else\n+    set_parameter_const (&block, var, IOPARM_common_flags, mask);\n \n-  tmp = gfc_build_function_call (*function, NULL_TREE);\n+  tmp = gfc_build_addr_expr (NULL_TREE, var);\n+  tmp = gfc_chainon_list (NULL_TREE, tmp);\n+  tmp = gfc_build_function_call (function, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n   gfc_add_block_to_block (&block, &post_block);\n \n+  dt_parm = var;\n+  dt_post_end_block = &post_end_block;\n+\n+  gfc_add_expr_to_block (&block, gfc_trans_code (code->block->next));\n+\n+  dt_parm = NULL;\n+  dt_post_end_block = NULL;\n+\n   return gfc_finish_block (&block);\n }\n \n@@ -1324,31 +1483,8 @@ build_dt (tree * function, gfc_code * code)\n tree\n gfc_trans_iolength (gfc_code * code)\n {\n-  stmtblock_t block;\n-  gfc_inquire *inq;\n-  tree dt;\n-\n-  gfc_init_block (&block);\n-\n-  set_error_locus (&block, &code->loc);\n-\n-  inq = code->ext.inquire;\n-\n-  /* First check that preconditions are met.  */\n-  gcc_assert (inq != NULL);\n-  gcc_assert (inq->iolength != NULL);\n-\n-  /* Connect to the iolength variable.  */\n-  if (inq->iolength)\n-    set_parameter_ref (&block, ioparm_iolength, inq->iolength);\n-\n-  /* Actual logic.  */\n   last_dt = IOLENGTH;\n-  dt = build_dt(&iocall_iolength, code);\n-\n-  gfc_add_expr_to_block (&block, dt);\n-\n-  return gfc_finish_block (&block);\n+  return build_dt (iocall[IOCALL_IOLENGTH], code);\n }\n \n \n@@ -1357,9 +1493,8 @@ gfc_trans_iolength (gfc_code * code)\n tree\n gfc_trans_read (gfc_code * code)\n {\n-\n   last_dt = READ;\n-  return build_dt (&iocall_read, code);\n+  return build_dt (iocall[IOCALL_READ], code);\n }\n \n \n@@ -1368,9 +1503,8 @@ gfc_trans_read (gfc_code * code)\n tree\n gfc_trans_write (gfc_code * code)\n {\n-\n   last_dt = WRITE;\n-  return build_dt (&iocall_write, code);\n+  return build_dt (iocall[IOCALL_WRITE], code);\n }\n \n \n@@ -1387,28 +1521,32 @@ gfc_trans_dt_end (gfc_code * code)\n   switch (last_dt)\n     {\n     case READ:\n-      function = iocall_read_done;\n+      function = iocall[IOCALL_READ_DONE];\n       break;\n \n     case WRITE:\n-      function = iocall_write_done;\n+      function = iocall[IOCALL_WRITE_DONE];\n       break;\n \n     case IOLENGTH:\n-      function = iocall_iolength_done;\n+      function = iocall[IOCALL_IOLENGTH_DONE];\n       break;\n \n     default:\n       gcc_unreachable ();\n     }\n \n-  tmp = gfc_build_function_call (function, NULL);\n+  tmp = gfc_build_addr_expr (NULL_TREE, dt_parm);\n+  tmp = gfc_chainon_list (NULL_TREE, tmp);\n+  tmp = gfc_build_function_call (function, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n+  gfc_add_block_to_block (&block, dt_post_end_block);\n+  gfc_init_block (dt_post_end_block);\n \n   if (last_dt != IOLENGTH)\n     {\n       gcc_assert (code->ext.dt != NULL);\n-      io_result (&block, code->ext.dt->err,\n+      io_result (&block, dt_parm, code->ext.dt->err,\n \t\t code->ext.dt->end, code->ext.dt->eor);\n     }\n \n@@ -1523,22 +1661,22 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr)\n     {\n     case BT_INTEGER:\n       arg2 = build_int_cst (NULL_TREE, kind);\n-      function = iocall_x_integer;\n+      function = iocall[IOCALL_X_INTEGER];\n       break;\n \n     case BT_REAL:\n       arg2 = build_int_cst (NULL_TREE, kind);\n-      function = iocall_x_real;\n+      function = iocall[IOCALL_X_REAL];\n       break;\n \n     case BT_COMPLEX:\n       arg2 = build_int_cst (NULL_TREE, kind);\n-      function = iocall_x_complex;\n+      function = iocall[IOCALL_X_COMPLEX];\n       break;\n \n     case BT_LOGICAL:\n       arg2 = build_int_cst (NULL_TREE, kind);\n-      function = iocall_x_logical;\n+      function = iocall[IOCALL_X_LOGICAL];\n       break;\n \n     case BT_CHARACTER:\n@@ -1550,7 +1688,7 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr)\n \t  gcc_assert (TREE_CODE (TREE_TYPE (tmp)) == ARRAY_TYPE);\n \t  arg2 = TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (tmp)));\n \t}\n-      function = iocall_x_character;\n+      function = iocall[IOCALL_X_CHARACTER];\n       break;\n \n     case BT_DERIVED:\n@@ -1584,7 +1722,9 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr)\n       internal_error (\"Bad IO basetype (%d)\", ts->type);\n     }\n \n-  args = gfc_chainon_list (NULL_TREE, addr_expr);\n+  tmp = gfc_build_addr_expr (NULL_TREE, dt_parm);\n+  args = gfc_chainon_list (NULL_TREE, tmp);\n+  args = gfc_chainon_list (args, addr_expr);\n   args = gfc_chainon_list (args, arg2);\n \n   tmp = gfc_build_function_call (function, args);\n@@ -1609,10 +1749,12 @@ transfer_array_desc (gfc_se * se, gfc_typespec * ts, tree addr_expr)\n \n   kind_arg = build_int_cst (NULL_TREE, ts->kind);\n \n-  args = gfc_chainon_list (NULL_TREE, addr_expr);\n+  tmp = gfc_build_addr_expr (NULL_TREE, dt_parm);\n+  args = gfc_chainon_list (NULL_TREE, tmp);\n+  args = gfc_chainon_list (args, addr_expr);\n   args = gfc_chainon_list (args, kind_arg);\n   args = gfc_chainon_list (args, charlen_arg);\n-  tmp = gfc_build_function_call (iocall_x_array, args);\n+  tmp = gfc_build_function_call (iocall[IOCALL_X_ARRAY], args);\n   gfc_add_expr_to_block (&se->pre, tmp);\n   gfc_add_block_to_block (&se->pre, &se->post);\n }"}, {"sha": "23dabc9ce9a0f941d3f896ab4fa32ffd5d3e79e1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -1,3 +1,11 @@\n+2005-11-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/24774\n+\t* gfortran.dg/inquire_9.f90: New test.\n+\n+\tPR fortran/21647\n+\t* gfortran.fortran-torture/execute/inquire_5.f90: New test.\n+\n 2005-11-21  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \tPR libfortran/24432"}, {"sha": "f1f8ffd1556c0ba40eebce2dafecba6826b094d9", "filename": "gcc/testsuite/gfortran.dg/inquire_9.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/gcc%2Ftestsuite%2Fgfortran.dg%2Finquire_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/gcc%2Ftestsuite%2Fgfortran.dg%2Finquire_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finquire_9.f90?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -0,0 +1,24 @@\n+! PR fortran/24774\n+! { dg-do run }\n+  logical :: l\n+  l = .true.\n+  inquire (file='inquire_9 file that should not exist', exist=l)\n+  if (l) call abort\n+  l = .true.\n+  inquire (unit=-16, exist=l)\n+  if (l) call abort\n+  open (unit=16, file='inquire_9.tst')\n+  print (unit=16, fmt='(a)'), 'Test'\n+  l = .false.\n+  inquire (unit=16, exist=l)\n+  if (.not.l) call abort\n+  l = .false.\n+  inquire (file='inquire_9.tst', exist=l)\n+  if (.not.l) call abort\n+  close (unit=16)\n+  l = .false.\n+  inquire (file='inquire_9.tst', exist=l)\n+  if (.not.l) call abort\n+  open (unit=16, file='inquire_9.tst')\n+  close (unit=16, status='delete')\n+end"}, {"sha": "1077650d87d089dd47eee48c39152fcd64f301b3", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/inquire_5.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Finquire_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Finquire_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Finquire_5.f90?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -0,0 +1,32 @@\n+! PR fortran/21647\n+program inquire_5\n+  integer (kind = 8) :: unit8\n+  logical (kind = 8) :: exist8\n+  integer (kind = 4) :: unit4\n+  logical (kind = 4) :: exist4\n+  integer (kind = 2) :: unit2\n+  logical (kind = 2) :: exist2\n+  integer (kind = 1) :: unit1\n+  logical (kind = 1) :: exist1\n+  character (len = 6) :: del\n+  unit8 = 78\n+  open (file = 'inquire_5.txt', unit = unit8)\n+  unit8 = -1\n+  exist8 = .false.\n+  unit4 = -1\n+  exist4 = .false.\n+  unit2 = -1\n+  exist2 = .false.\n+  unit1 = -1\n+  exist1 = .false.\n+  inquire (file = 'inquire_5.txt', number = unit8, exist = exist8)\n+  if (unit8 .ne. 78 .or. .not. exist8) call abort\n+  inquire (file = 'inquire_5.txt', number = unit4, exist = exist4)\n+  if (unit4 .ne. 78 .or. .not. exist4) call abort\n+  inquire (file = 'inquire_5.txt', number = unit2, exist = exist2)\n+  if (unit2 .ne. 78 .or. .not. exist2) call abort\n+  inquire (file = 'inquire_5.txt', number = unit1, exist = exist1)\n+  if (unit1 .ne. 78 .or. .not. exist1) call abort\n+  del = 'delete'\n+  close (unit = 78, status = del)\n+end"}, {"sha": "80ff9696f5a493a34f6ac2ea2a33f7b6eeed5da9", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -1,3 +1,238 @@\n+2005-11-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/24774\n+\tPR fortran/14943\n+\tPR fortran/21647\n+\t* Makefile.am (AM_CPPFLAGS): Add gcc directories as -I paths,\n+\tadd -D_GNU_SOURCE.\n+\t* Makefile.in: Regenerated.\n+\t* acinclude.m4 (LIBGFOR_CHECK_SYNC_FETCH_AND_ADD,\n+\tLIBGFOR_CHECK_GTHR_DEFAULT, LIBGFOR_CHECK_PRAGMA_WEAK): New macros.\n+\t* configure.ac: Add them.\n+\t* configure: Rebuilt.\n+\t* config.h.in: Rebuilt.\n+\t* libtool-version: Bump libgfortran.so SONAME to libgfortran.so.1.\n+\t* libgfortran.h (library_start, show_locus, internal_error,\n+\tgenerate_error, find_option): Add st_parameter_common * argument.\n+\t(library_end): Change into a dummy macro.\n+\t* io/io.h: Include gthr.h.\n+\t(SUPPORTS_WEAK): Define if HAVE_PRAGMA_WEAK.\n+\t(CHARACTER): Remove define.\n+\t(st_parameter, global_t): Remove typedef.\n+\t(ioparm, g, ionml, current_unit): Remove variables.\n+\t(init_error_stream): Remove prototype.\n+\t(CHARACTER1, CHARACTER2): Define.\n+\t(st_parameter_common, st_parameter_open, st_parameter_close,\n+\tst_parameter_filepos, st_parameter_inquire, st_parameter_dt): New\n+\ttypedefs.\n+\t(IOPARM_LIBRETURN_MASK, IOPARM_LIBRETURN_OK, IOPARM_LIBRETURN_ERROR,\n+\tIOPARM_LIBRETURN_END, IOPARM_LIBRETURN_EOR, IOPARM_ERR, IOPARM_END,\n+\tIOPARM_EOR, IOPARM_HAS_IOSTAT, IOPARM_HAS_IOMSG, IOPARM_COMMON_MASK,\n+\tIOPARM_OPEN_HAS_RECL_IN, IOPARM_OPEN_HAS_FILE, IOPARM_OPEN_HAS_STATUS,\n+\tIOPARM_OPEN_HAS_ACCESS, IOPARM_OPEN_HAS_FORM, IOPARM_OPEN_HAS_BLANK,\n+\tIOPARM_OPEN_HAS_POSITION, IOPARM_OPEN_HAS_ACTION,\n+\tIOPARM_OPEN_HAS_DELIM, IOPARM_OPEN_HAS_PAD, IOPARM_CLOSE_HAS_STATUS,\n+\tIOPARM_INQUIRE_HAS_EXIST, IOPARM_INQUIRE_HAS_OPENED,\n+\tIOPARM_INQUIRE_HAS_NUMBER, IOPARM_INQUIRE_HAS_NAMED,\n+\tIOPARM_INQUIRE_HAS_NEXTREC, IOPARM_INQUIRE_HAS_RECL_OUT,\n+\tIOPARM_INQUIRE_HAS_FILE, IOPARM_INQUIRE_HAS_ACCESS,\n+\tIOPARM_INQUIRE_HAS_FORM, IOPARM_INQUIRE_HAS_BLANK,\n+\tIOPARM_INQUIRE_HAS_POSITION, IOPARM_INQUIRE_HAS_ACTION,\n+\tIOPARM_INQUIRE_HAS_DELIM, IOPARM_INQUIRE_HAS_PAD,\n+\tIOPARM_INQUIRE_HAS_NAME, IOPARM_INQUIRE_HAS_SEQUENTIAL,\n+\tIOPARM_INQUIRE_HAS_DIRECT, IOPARM_INQUIRE_HAS_FORMATTED,\n+\tIOPARM_INQUIRE_HAS_UNFORMATTED, IOPARM_INQUIRE_HAS_READ,\n+\tIOPARM_INQUIRE_HAS_WRITE, IOPARM_INQUIRE_HAS_READWRITE,\n+\tIOPARM_DT_LIST_FORMAT, IOPARM_DT_NAMELIST_READ_MODE,\n+\tIOPARM_DT_HAS_REC, IOPARM_DT_HAS_SIZE, IOPARM_DT_HAS_IOLENGTH,\n+\tIOPARM_DT_HAS_FORMAT, IOPARM_DT_HAS_ADVANCE,\n+\tIOPARM_DT_HAS_INTERNAL_UNIT, IOPARM_DT_HAS_NAMELIST_NAME,\n+\tIOPARM_DT_IONML_SET): Define.\n+\t(gfc_unit): Add lock, waiting and close fields.  Change file\n+\tfrom flexible array member into pointer to char.\n+\t(open_external): Add st_parameter_open * argument.\n+\t(find_file, file_exists): Add file and file_len arguments.\n+\t(flush_all_units): New prototype.\n+\t(max_offset, unit_root, unit_lock): New variable.\n+\t(is_internal_unit, is_array_io, next_array_record,\n+\tparse_format, next_format, unget_format, format_error,\n+\tread_block, write_block, next_record, convert_real,\n+\tread_a, read_f, read_l, read_x, read_radix, read_decimal,\n+\tlist_formatted_read, finish_list_read, namelist_read,\n+\tnamelist_write, write_a, write_b, write_d, write_e, write_en,\n+\twrite_es, write_f, write_i, write_l, write_o, write_x, write_z,\n+\tlist_formatted_write, get_unit): Add st_parameter_dt * argument.\n+\t(insert_unit): Remove prototype.\n+\t(find_or_create_unit, unlock_unit): New prototype.\n+\t(new_unit): Return gfc_unit *.  Add st_parameter_open *\n+\tand gfc_unit * arguments.\n+\t(free_fnodes): Remove prototype.\n+\t(free_format_data): New prototype.\n+\t(scratch): Remove.\n+\t(init_at_eol): Remove prototype.\n+\t(free_ionml): New prototype.\n+\t(inc_waiting_locked, predec_waiting_locked, dec_waiting_unlocked):\n+\tNew inline functions.\n+\t* io/unit.c (max_offset, unit_root, unit_lock): New variables.\n+\t(insert): Adjust os_error caller.\n+\t(insert_unit): Made static.  Allocate memory here, initialize\n+\tlock and after inserting it return it, locked.\n+\t(delete_unit): Adjust for deletion of g.\n+\t(find_unit_1): New function.\n+\t(find_unit): Use it.\n+\t(find_or_create_unit): New function.\n+\t(get_unit): Add dtp argument, change meaning of the int argument\n+\tas creation request flag.  Adjust for different st_* calling\n+\tconventions, lock internal unit's lock before returning it\n+\tand removal of g.  Call find_unit_1 instead of find_unit.\n+\t(is_internal_unit, is_array_io): Add dtp argument, adjust for\n+\tremoval of most of global variables.\n+\t(init_units): Initialize unit_lock.  Adjust insert_unit callers\n+\tand adjust for g removal.\n+\t(close_unit_1): New function.\n+\t(close_unit): Use it.\n+\t(unlock_unit): New function.\n+\t(close_units): Lock unit_lock, use close_unit_1 rather than\n+\tclose_unit.\n+\t* io/close.c (st_close): Add clp argument.  Adjust for new\n+\tst_* calling conventions and internal function API changes.\n+\t* io/file_pos.c (st_backspace, st_endfile, st_rewind, st_flush):\n+\tAdd fpp argument.  Adjust for new st_* calling conventions and\n+\tinternal function API changes.\n+\t(formatted_backspace, unformatted_backspace): Likewise.  Add\n+\tu argument.\n+\t* io/open.c (edit_modes, st_open): Add opp argument.  Adjust for\n+\tnew st_* calling conventions and internal function API changes.\n+\t(already_open): Likewise.  If not HAVE_UNLINK_OPEN_FILE, unlink\n+\tscratch file.  Instead of calling close_unit just call sclose,\n+\tfree u->file if any and clear a few u fields before calling\n+\tnew_unit.\n+\t(new_unit): Return gfc_unit *.  Add opp and u arguments.\n+\tAdjust for new st_* calling conventions and internal function\n+\tAPI changes.  Don't allocate unit here, rather than work with\n+\talready created unit u already locked on entry.  In case\n+\tof failure, close_unit it.\n+\t* io/unix.c: Include unix.h.\n+\t(BUFFER_SIZE, unix_stream): Moved to unix.h.\n+\t(unit_to_fd): Add unlock_unit call.\n+\t(tempfile): Add opp argument, use its fields rather than ioparm.\n+\t(regular_file): Likewise.\n+\t(open_external): Likewise.  Only unlink file if fd >= 0.\n+\t(init_error_stream): Add error argument, set structure it points\n+\tto rather than filling static variable and returning its address.\n+\t(FIND_FILE0_DECL, FIND_FILE0_ARGS): Define.\n+\t(find_file0): Use them.  Don't crash if u->s == NULL.\n+\t(find_file): Add file and file_len arguments, use them instead\n+\tof ioparm.  Add locking.  Pass either an array of 2 struct stat\n+\tor file and file_len pair to find_file0.\n+\t(flush_all_units_1, flush_all_units): New functions.\n+\t(file_exists): Add file and file_len arguments, use them instead\n+\tof ioparm.\n+\t* io/unix.h: New file.\n+\t* io/lock.c (ioparm, g, ionml): Remove variables.\n+\t(library_start): Add cmp argument, adjust for new st_* calling\n+\tconventions.\n+\t(library_end): Remove.\n+\t(free_ionml): New function.\n+\t* io/inquire.c (inquire_via_unit, inquire_via_filename,\n+\tst_inquire): Add iqp argument, adjust for new st_* calling\n+\tconventions and internal function API changes.\n+\t* io/format.c (FARRAY_SIZE): Decrease to 64.\n+\t(fnode_array, format_data): New typedefs.\n+\t(avail, array, format_string, string, error, saved_token, value,\n+\tformat_string_len, reversion_ok, saved_format): Remove variables.\n+\t(colon_node): Add const.\n+\t(free_fnode, free_fnodes): Remove.\n+\t(free_format_data): New function.\n+\t(next_char, unget_char, get_fnode, format_lex, parse_format_list,\n+\tformat_error, parse_format, revert, unget_format, next_test): Add\n+\tfmt or dtp arguments, pass it all around, adjust for internal\n+\tfunction API changes and adjust for removal of global variables.\n+\t(next_format): Likewise.  Constify return type.\n+\t(next_format0): Constify return type.\n+\t* io/transfer.c (current_unit, sf_seen_eor, eor_condition, max_pos,\n+\tskips, pending_spaces, scratch, line_buffer, advance_status,\n+\ttransfer): Remove variables.\n+\t(transfer_integer, transfer_real, transfer_logical,\n+\ttransfer_character, transfer_complex, transfer_array, current_mode,\n+\tread_sf, read_block, read_block_direct, write_block,\n+\twrite_block_direct, unformatted_read, unformatted_write,\n+\ttype_name, write_constant_string, require_type,\n+\tformatted_transfer_scalar, us_read, us_write, pre_position,\n+\tdata_transfer_init, next_record_r, next_record_w, next_record,\n+\tfinalize_transfer, iolength_transfer, iolength_transfer_init,\n+\tst_iolength, st_iolength_done, st_read, st_read_done, st_write,\n+\tst_write_done, st_set_nml_var, st_set_nml_var_dim,\n+\tnext_array_record): Add dtp argument, pass it all around, adjust for\n+\tinternal function API changes and removal of global variables.\n+\t* io/list_read.c (repeat_count, saved_length, saved_used,\n+\tinput_complete, at_eol, comma_flag, last_char, saved_string,\n+\tsaved_type, namelist_mode, nml_read_error, value, parse_err_msg,\n+\tnml_err_msg, prev_nl): Remove variables.\n+\t(push_char, free_saved, next_char, unget_char, eat_spaces,\n+\teat_separator, finish_separator, nml_bad_return, convert_integer,\n+\tparse_repeat, read_logical, read_integer, read_character,\n+\tparse_real, read_complex, read_real, check_type,\n+\tlist_formatted_read_scalar, list_formatted_read, finish_list_read,\n+\tfind_nml_node, nml_untouch_nodes, nml_match_name, nml_query,\n+\tnamelist_read): Add dtp argument, pass it all around, adjust for\n+\tinternal function API changes and removal of global variables.\n+\t(nml_parse_qualifier): Likewise.  Add parse_err_msg argument.\n+\t(nml_read_obj): Likewise.  Add pprev_nl, nml_err_msg, clow and\n+\tchigh arguments.\n+\t(nml_get_obj_data): Likewise.  Add pprev_nl and nml_err_msg\n+\targuments.\n+\t(init_at_eol): Removed.\n+\t* io/read.c (convert_real, read_l, read_a, next_char, read_decimal,\n+\tread_radix, read_f, read_x): Add dtp argument, pass it all around,\n+\tadjust for internal function API changes and removal of global\n+\tvariables.\n+\t(set_integer): Adjust internal_error caller.\n+\t* io/write.c (no_leading_blank, nml_delim): Remove variables.\n+\t(write_a, calculate_sign, calculate_G_format, output_float,\n+\twrite_l, write_float, write_int, write_decimal, write_i, write_b,\n+\twrite_o, write_z, write_d, write_e, write_f, write_en, write_es,\n+\twrite_x, write_char, write_logical, write_integer, write_character,\n+\twrite_real, write_complex, write_separator,\n+\tlist_formatted_write_scalar, list_formatted_write, nml_write_obj,\n+\tnamelist_write): Add dtp argument, pass it all around, adjust for\n+\tinternal function API changes and removal of global variables.\n+\t(extract_int, extract_uint, extract_real): Adjust internal_error\n+\tcallers.\n+\t* runtime/fpu.c (_GNU_SOURCE): Don't define here.\n+\t* runtime/error.c: Include ../io/unix.h.\n+\t(filename, line): Remove variables.\n+\t(st_printf): Pass address of a local variable to init_error_stream.\n+\t(show_locus): Add cmp argument.  Use fields it points to rather than\n+\tfilename and line variables.\n+\t(os_error, runtime_error): Remove show_locus calls.\n+\t(internal_error): Add cmp argument.  Pass it down to show_locus.\n+\t(generate_error): Likewise.  Use flags bitmask instead of non-NULL\n+\tcheck for iostat and iomsg parameter presence, adjust for st_*\n+\tcalling convention changes.\n+\t* runtime/stop.c (stop_numeric, stop_string): Remove show_locus\n+\tcalls.\n+\t* runtime/pause.c (pause_numeric, pause_string): Likewise.\n+\t* runtime/string.c: Include ../io/io.h.\n+\t(find_option): Add cmp argument.  Pass it down to generate_error.\n+\t* intrinsics/flush.c (recursive_flush): Remove.\n+\t(flush_i4, flush_i8): Use flush_all_units.  Add unlock_unit\n+\tcall.\n+\t* intrinsics/rand.c: Include ../io/io.h.\n+\t(rand_seed_lock): New variable.\n+\t(srand, irand): Add locking.\n+\t(init): New constructor function.\n+\t* intrinsics/random.c: Include ../io/io.h.\n+\t(random_lock): New variable.\n+\t(random_r4, random_r8, arandom_r4, arandom_r8): Add locking.\n+\t(random_seed): Likewise.  open failed if fd < 0.  Set i correctly.\n+\t(init): New constructor function.\n+\t* intrinsics/system_clock.c (tp0, t0): Remove.\n+\t(system_clock_4, system_clock_8): Don't subtract tp0/t0 from current\n+\ttime, use just integer arithmetics.\n+\t* intrinsics/tty.c (isatty_l4, isatty_l8, ttynam_sub): Add\n+\tunlock_unit calls.\n+\n 2005-11-20  Richard Henderson  <rth@redhat.com>\n \n         * Makefile.am: Revert 2005-11-14 change.  Enable -free-vectorize"}, {"sha": "ff8b02948e1226473cb4f57297b46339ce03d5d0", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -16,7 +16,9 @@ libgfortranbegin_la_LDFLAGS = -static\n \n ## io.h conflicts with some a system header on some platforms, so\n ## use -iquote\n-AM_CPPFLAGS = -iquote$(srcdir)/io\n+AM_CPPFLAGS = -iquote$(srcdir)/io -I$(srcdir)/$(MULTISRCTOP)../gcc \\\n+\t      -I$(srcdir)/$(MULTISRCTOP)../gcc/config \\\n+\t      -I$(MULTIBUILDTOP)../../gcc -D_GNU_SOURCE\n \n gfor_io_src= \\\n io/close.c \\"}, {"sha": "c34a86cd4dac3e3c4a602e7e3d51b1638ee8a39d", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -358,7 +358,10 @@ toolexeclib_LTLIBRARIES = libgfortran.la libgfortranbegin.la\n libgfortran_la_LDFLAGS = -version-info `grep -v '^\\#' $(srcdir)/libtool-version` -lm $(extra_ldflags_libgfortran)\n libgfortranbegin_la_SOURCES = fmain.c\n libgfortranbegin_la_LDFLAGS = -static\n-AM_CPPFLAGS = -iquote$(srcdir)/io\n+AM_CPPFLAGS = -iquote$(srcdir)/io -I$(srcdir)/$(MULTISRCTOP)../gcc \\\n+\t      -I$(srcdir)/$(MULTISRCTOP)../gcc/config \\\n+\t      -I$(MULTIBUILDTOP)../../gcc -D_GNU_SOURCE\n+\n gfor_io_src = \\\n io/close.c \\\n io/file_pos.c \\"}, {"sha": "9d06a8b84d491c6c2d49568a7daa014b38f3cd56", "filename": "libgfortran/acinclude.m4", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Facinclude.m4?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -149,6 +149,44 @@ extern void bar(void) __attribute__((alias(ULP \"foo\")));],\n       [Define to 1 if the target supports __attribute__((alias(...))).])\n   fi])\n \n+dnl Check whether the target supports __sync_fetch_and_add.\n+AC_DEFUN([LIBGFOR_CHECK_SYNC_FETCH_AND_ADD], [\n+  AC_CACHE_CHECK([whether the target supports __sync_fetch_and_add],\n+\t\t have_sync_fetch_and_add, [\n+  AC_TRY_LINK([int foovar = 0;], [\n+if (foovar <= 0) return __sync_fetch_and_add (&foovar, 1);\n+if (foovar > 10) return __sync_add_and_fetch (&foovar, -1);],\n+\t      have_sync_fetch_and_add=yes, have_sync_fetch_and_add=no)])\n+  if test $have_sync_fetch_and_add = yes; then\n+    AC_DEFINE(HAVE_SYNC_FETCH_AND_ADD, 1,\n+\t      [Define to 1 if the target supports __sync_fetch_and_add])\n+  fi])\n+\n+dnl Check if threads are supported.\n+AC_DEFUN([LIBGFOR_CHECK_GTHR_DEFAULT], [\n+  AC_CACHE_CHECK([configured target thread model],\n+\t\t target_thread_file, [\n+target_thread_file=`$CC -v 2>&1 | sed -n 's/^Thread model: //p'`])\n+\n+  if test $target_thread_file != single; then\n+    AC_DEFINE(HAVE_GTHR_DEFAULT, 1,\n+\t      [Define if the compiler has a thread header that is non single.])\n+  fi])\n+\n+dnl Check for pragma weak.\n+AC_DEFUN([LIBGFOR_CHECK_PRAGMA_WEAK], [\n+  AC_CACHE_CHECK([whether pragma weak works],\n+\t\t have_pragma_weak, [\n+  gfor_save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"$CFLAGS -Wunknown-pragmas\"\n+  AC_TRY_COMPILE([void foo (void);\n+#pragma weak foo], [if (foo) foo ();],\n+\t\t have_pragma_weak=yes, have_pragma_weak=no)])\n+  if test $have_pragma_weak = yes; then\n+    AC_DEFINE(HAVE_PRAGMA_WEAK, 1,\n+\t      [Define to 1 if the target supports #pragma weak])\n+  fi])\n+\n dnl Check whether target can unlink a file still open.\n AC_DEFUN([LIBGFOR_CHECK_UNLINK_OPEN_FILE], [\n   AC_CACHE_CHECK([whether the target can unlink an open file],"}, {"sha": "ba0ca49b455c4cc7854bf3c93d3f587793a22260", "filename": "libgfortran/config.h.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig.h.in?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -363,6 +363,9 @@\n /* libc includes getuid */\n #undef HAVE_GETUID\n \n+/* Define if the compiler has a thread header that is non single. */\n+#undef HAVE_GTHR_DEFAULT\n+\n /* libm includes hypot */\n #undef HAVE_HYPOT\n \n@@ -462,6 +465,9 @@\n /* libm includes powl */\n #undef HAVE_POWL\n \n+/* Define to 1 if the target supports #pragma weak */\n+#undef HAVE_PRAGMA_WEAK\n+\n /* libm includes round */\n #undef HAVE_ROUND\n \n@@ -558,6 +564,9 @@\n /* Define to 1 if you have the `symlink' function. */\n #undef HAVE_SYMLINK\n \n+/* Define to 1 if the target supports __sync_fetch_and_add */\n+#undef HAVE_SYNC_FETCH_AND_ADD\n+\n /* Define to 1 if you have the <sys/mman.h> header file. */\n #undef HAVE_SYS_MMAN_H\n "}, {"sha": "6799fa5277228723585d8ee9f97ec9c862ea75fd", "filename": "libgfortran/configure", "status": "modified", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -20699,6 +20699,166 @@ _ACEOF\n \n   fi\n \n+# Check out sync builtins support.\n+\n+  echo \"$as_me:$LINENO: checking whether the target supports __sync_fetch_and_add\" >&5\n+echo $ECHO_N \"checking whether the target supports __sync_fetch_and_add... $ECHO_C\" >&6\n+if test \"${have_sync_fetch_and_add+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+\n+  if test x$gcc_no_link = xyes; then\n+  { { echo \"$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES.\" >&5\n+echo \"$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES.\" >&2;}\n+   { (exit 1); exit 1; }; }\n+fi\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+int foovar = 0;\n+int\n+main ()\n+{\n+\n+if (foovar <= 0) return __sync_fetch_and_add (&foovar, 1);\n+if (foovar > 10) return __sync_add_and_fetch (&foovar, -1);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  have_sync_fetch_and_add=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+have_sync_fetch_and_add=no\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+fi\n+echo \"$as_me:$LINENO: result: $have_sync_fetch_and_add\" >&5\n+echo \"${ECHO_T}$have_sync_fetch_and_add\" >&6\n+  if test $have_sync_fetch_and_add = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_SYNC_FETCH_AND_ADD 1\n+_ACEOF\n+\n+  fi\n+\n+# Check out thread support.\n+\n+  echo \"$as_me:$LINENO: checking configured target thread model\" >&5\n+echo $ECHO_N \"checking configured target thread model... $ECHO_C\" >&6\n+if test \"${target_thread_file+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+\n+target_thread_file=`$CC -v 2>&1 | sed -n 's/^Thread model: //p'`\n+fi\n+echo \"$as_me:$LINENO: result: $target_thread_file\" >&5\n+echo \"${ECHO_T}$target_thread_file\" >&6\n+\n+  if test $target_thread_file != single; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_GTHR_DEFAULT 1\n+_ACEOF\n+\n+  fi\n+\n+# Check out #pragma weak.\n+\n+  echo \"$as_me:$LINENO: checking whether pragma weak works\" >&5\n+echo $ECHO_N \"checking whether pragma weak works... $ECHO_C\" >&6\n+if test \"${have_pragma_weak+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+\n+  gfor_save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"$CFLAGS -Wunknown-pragmas\"\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+void foo (void);\n+#pragma weak foo\n+int\n+main ()\n+{\n+if (foo) foo ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  have_pragma_weak=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+have_pragma_weak=no\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+echo \"$as_me:$LINENO: result: $have_pragma_weak\" >&5\n+echo \"${ECHO_T}$have_pragma_weak\" >&6\n+  if test $have_pragma_weak = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_PRAGMA_WEAK 1\n+_ACEOF\n+\n+  fi\n+\n # Various other checks on target\n \n   echo \"$as_me:$LINENO: checking whether the target can unlink an open file\" >&5"}, {"sha": "7dc9298cfe6fb5ccb76c672cad3ade901910a020", "filename": "libgfortran/configure.ac", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.ac?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -374,6 +374,15 @@ LIBGFOR_CHECK_ATTRIBUTE_VISIBILITY\n LIBGFOR_CHECK_ATTRIBUTE_DLLEXPORT\n LIBGFOR_CHECK_ATTRIBUTE_ALIAS\n \n+# Check out sync builtins support.\n+LIBGFOR_CHECK_SYNC_FETCH_AND_ADD\n+\n+# Check out thread support.\n+LIBGFOR_CHECK_GTHR_DEFAULT\n+\n+# Check out #pragma weak.\n+LIBGFOR_CHECK_PRAGMA_WEAK\n+\n # Various other checks on target\n LIBGFOR_CHECK_UNLINK_OPEN_FILE\n "}, {"sha": "2164b47473e1103bf160fb8df58e87229d13ad75", "filename": "libgfortran/intrinsics/flush.c", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fintrinsics%2Fflush.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fintrinsics%2Fflush.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fflush.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -41,19 +41,6 @@ Boston, MA 02110-1301, USA.  */\n /* SUBROUTINE FLUSH(UNIT)\n    INTEGER, INTENT(IN), OPTIONAL :: UNIT  */\n \n-static void\n-recursive_flush (gfc_unit *us)\n-{\n-  /* There can be no open files.  */\n-  if (us == NULL)\n-    return;\n-\n-  flush (us->s);\n-  recursive_flush (us->left);\n-  recursive_flush (us->right);\n-}\n-\n-\n extern void flush_i4 (GFC_INTEGER_4 *);\n export_proto(flush_i4);\n \n@@ -64,15 +51,15 @@ flush_i4 (GFC_INTEGER_4 *unit)\n \n   /* flush all streams */\n   if (unit == NULL)\n-    {\n-      us = g.unit_root;\n-      recursive_flush(us);\n-    }\n+    flush_all_units ();\n   else\n     {\n-      us = find_unit(*unit);\n+      us = find_unit (*unit);\n       if (us != NULL)\n-        flush (us->s);\n+\t{\n+\t  flush (us->s);\n+\t  unlock_unit (us);\n+\t}\n     }\n }\n \n@@ -87,14 +74,14 @@ flush_i8 (GFC_INTEGER_8 *unit)\n \n   /* flush all streams */\n   if (unit == NULL)\n-    {\n-      us = g.unit_root;\n-      recursive_flush(us);\n-    }\n+    flush_all_units ();\n   else\n     {\n-      us = find_unit(*unit);\n+      us = find_unit (*unit);\n       if (us != NULL)\n-        flush (us->s);\n+\t{\n+\t  flush (us->s);\n+\t  unlock_unit (us);\n+\t}\n     }\n }"}, {"sha": "7af525e7d2aad106afb3e2ed68441008c6ee1ec1", "filename": "libgfortran/intrinsics/rand.c", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fintrinsics%2Frand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fintrinsics%2Frand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Frand.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -1,5 +1,5 @@\n /* Implementation of the IRAND, RAND, and SRAND intrinsics.\n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n    Contributed by Steven G. Kargl <kargls@comcast.net>.\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n@@ -37,12 +37,18 @@ Boston, MA 02110-1301, USA.  */\n \n #include \"config.h\"\n #include \"libgfortran.h\"\n+#include \"../io/io.h\"\n \n #define GFC_RAND_A\t16807\n #define GFC_RAND_M\t2147483647\n #define GFC_RAND_M1\t(GFC_RAND_M - 1)\n \n static GFC_UINTEGER_8 rand_seed = 1;\n+#ifdef __GTHREAD_MUTEX_INIT\n+static __gthread_mutex_t rand_seed_lock = __GTHREAD_MUTEX_INIT;\n+#else\n+static __gthread_mutex_t rand_seed_lock;\n+#endif\n \n \n /* Set the seed of the irand generator.  Note 0 is a bad seed.  */\n@@ -59,7 +65,9 @@ export_proto_np(PREFIX(srand));\n void\n PREFIX(srand) (GFC_INTEGER_4 *i)\n {\n+  __gthread_mutex_lock (&rand_seed_lock);\n   srand_internal (*i);\n+  __gthread_mutex_unlock (&rand_seed_lock);\n }\n \n /* Return an INTEGER in the range [1,GFC_RAND_M-1].  */\n@@ -76,6 +84,8 @@ irand (GFC_INTEGER_4 *i)\n   else\n     j = 0;\n \n+  __gthread_mutex_lock (&rand_seed_lock);\n+\n   switch (j)\n   {\n     /* Return the next RN. */\n@@ -95,8 +105,11 @@ irand (GFC_INTEGER_4 *i)\n    }\n \n    rand_seed = GFC_RAND_A * rand_seed % GFC_RAND_M;\n+   j = (GFC_INTEGER_4) rand_seed;\n+\n+  __gthread_mutex_unlock (&rand_seed_lock);\n \n-   return (GFC_INTEGER_4) rand_seed;\n+   return j;\n }\n iexport(irand);\n \n@@ -111,3 +124,11 @@ PREFIX(rand) (GFC_INTEGER_4 *i)\n {\n   return normalize_r4_i4 (irand (i) - 1, GFC_RAND_M1 - 1);\n }\n+\n+#ifndef __GTHREAD_MUTEX_INIT\n+static void __attribute__((constructor))\n+init (void)\n+{\n+  __GTHREAD_MUTEX_INIT_FUNCTION (&rand_seed_lock);\n+}\n+#endif"}, {"sha": "463b7e0c17b4f929c8cc44fe5d011673aff428bd", "filename": "libgfortran/intrinsics/random.c", "status": "modified", "additions": 66, "deletions": 7, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fintrinsics%2Frandom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fintrinsics%2Frandom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Frandom.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -30,6 +30,7 @@ write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n Boston, MA 02110-1301, USA.  */\n \n #include \"libgfortran.h\"\n+#include \"../io/io.h\"\n \n extern void random_r4 (GFC_REAL_4 *);\n iexport_proto(random_r4);\n@@ -43,6 +44,12 @@ export_proto(arandom_r4);\n extern void arandom_r8 (gfc_array_r8 *);\n export_proto(arandom_r8);\n \n+#ifdef __GTHREAD_MUTEX_INIT\n+static __gthread_mutex_t random_lock = __GTHREAD_MUTEX_INIT;\n+#else\n+static __gthread_mutex_t random_lock;\n+#endif\n+\n #if 0\n \n /*  The Mersenne Twister code is currently commented out due to\n@@ -111,12 +118,14 @@ static unsigned int seed[N];\n void\n random_seed (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n {\n+  __gthread_mutex_lock (&random_lock);\n+\n   /* Initialize the seed in system dependent manner.  */\n   if (get == NULL && put == NULL && size == NULL)\n     {\n       int fd;\n       fd = open (\"/dev/urandom\", O_RDONLY);\n-      if (fd == 0)\n+      if (fd < 0)\n \t{\n \t  /* We dont have urandom.  */\n \t  GFC_UINTEGER_4 s = (GFC_UINTEGER_4) seed;\n@@ -131,15 +140,16 @@ random_seed (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n \t  /* Using urandom, might have a length issue.  */\n \t  read (fd, &seed[0], sizeof (GFC_UINTEGER_4) * N);\n \t  close (fd);\n+\t  i = N;\n \t}\n-      return;\n+      goto return_unlock;\n     }\n \n   /* Return the size of the seed */\n   if (size != NULL)\n     {\n       *size = N;\n-      return;\n+      goto return_unlock;\n     }\n \n   /* if we have gotten to this pount we have a get or put\n@@ -159,7 +169,7 @@ random_seed (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n \n       /* If this is the case the array is a temporary */\n       if (put->dim[0].stride == 0)\n-\treturn;\n+\tgoto return_unlock;\n \n       /*  This code now should do correct strides. */\n       for (i = 0; i < N; i++)\n@@ -179,12 +189,15 @@ random_seed (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n \n       /* If this is the case the array is a temporary */\n       if (get->dim[0].stride == 0)\n-\treturn;\n+\tgoto return_unlock;\n \n       /*  This code now should do correct strides. */\n       for (i = 0; i < N; i++)\n \tget->data[i * get->dim[0].stride] = seed[i];\n     }\n+\n+ random_unlock:\n+  __gthread_mutex_unlock (&random_lock);\n }\n iexport(random_seed);\n \n@@ -220,13 +233,16 @@ random_generate (void)\n void\n random_r4 (GFC_REAL_4 * harv)\n {\n+  __gthread_mutex_lock (&random_lock);\n+\n   /* Regenerate if we need to.  */\n   if (i >= N)\n     random_generate ();\n \n   /* Convert uint32 to REAL(KIND=4).  */\n   *harv = (GFC_REAL_4) ((GFC_REAL_4) (GFC_UINTEGER_4) seed[i++] /\n \t\t\t(GFC_REAL_4) (~(GFC_UINTEGER_4) 0));\n+  __gthread_mutex_unlock (&random_lock);\n }\n iexport(random_r4);\n \n@@ -235,6 +251,8 @@ iexport(random_r4);\n void\n random_r8 (GFC_REAL_8 * harv)\n {\n+  __gthread_mutex_lock (&random_lock);\n+\n   /* Regenerate if we need to, may waste one 32-bit value.  */\n   if ((i + 1) >= N)\n     random_generate ();\n@@ -243,6 +261,7 @@ random_r8 (GFC_REAL_8 * harv)\n   *harv = ((GFC_REAL_8) ((((GFC_UINTEGER_8) seed[i+1]) << 32) + seed[i])) /\n \t  (GFC_REAL_8) (~(GFC_UINTEGER_8) 0);\n   i += 2;\n+  __gthread_mutex_unlock (&random_lock);\n }\n iexport(random_r8);\n \n@@ -279,6 +298,8 @@ arandom_r4 (gfc_array_r4 * harv)\n \n   stride0 = stride[0];\n \n+  __gthread_mutex_lock (&random_lock);\n+\n   while (dest)\n     {\n       /* Set the elements.  */\n@@ -319,6 +340,8 @@ arandom_r4 (gfc_array_r4 * harv)\n \t    }\n \t}\n     }\n+\n+  __gthread_mutex_unlock (&random_lock);\n }\n \n /* REAL(KIND=8) array.  */\n@@ -352,6 +375,8 @@ arandom_r8 (gfc_array_r8 * harv)\n \n   stride0 = stride[0];\n \n+  __gthread_mutex_lock (&random_lock);\n+\n   while (dest)\n     {\n       /* Set the elements.  */\n@@ -393,6 +418,8 @@ arandom_r8 (gfc_array_r8 * harv)\n \t    }\n \t}\n     }\n+\n+  __gthread_mutex_unlock (&random_lock);\n }\n \n #else\n@@ -470,11 +497,13 @@ random_r4 (GFC_REAL_4 *x)\n {\n   GFC_UINTEGER_4 kiss;\n \n+  __gthread_mutex_lock (&random_lock);\n   kiss = kiss_random_kernel ();\n   /* Burn a random number, so the REAL*4 and REAL*8 functions\n      produce similar sequences of random numbers.  */\n   kiss_random_kernel ();\n   *x = normalize_r4_i4 (kiss, ~(GFC_UINTEGER_4) 0);\n+  __gthread_mutex_unlock (&random_lock);\n }\n iexport(random_r4);\n \n@@ -486,9 +515,11 @@ random_r8 (GFC_REAL_8 *x)\n {\n   GFC_UINTEGER_8 kiss;\n \n+  __gthread_mutex_lock (&random_lock);\n   kiss = ((GFC_UINTEGER_8)kiss_random_kernel ()) << 32;\n   kiss += kiss_random_kernel ();\n   *x = normalize_r8_i8 (kiss, ~(GFC_UINTEGER_8) 0);\n+  __gthread_mutex_unlock (&random_lock);\n }\n iexport(random_r8);\n \n@@ -504,6 +535,7 @@ arandom_r4 (gfc_array_r4 *x)\n   index_type stride0;\n   index_type dim;\n   GFC_REAL_4 *dest;\n+  GFC_UINTEGER_4 kiss;\n   int n;\n \n   dest = x->data;\n@@ -524,9 +556,16 @@ arandom_r4 (gfc_array_r4 *x)\n \n   stride0 = stride[0];\n \n+  __gthread_mutex_lock (&random_lock);\n+\n   while (dest)\n     {\n-      random_r4 (dest);\n+      /* random_r4 (dest); */\n+      kiss = kiss_random_kernel ();\n+      /* Burn a random number, so the REAL*4 and REAL*8 functions\n+\t produce similar sequences of random numbers.  */\n+      kiss_random_kernel ();\n+      *dest = normalize_r4_i4 (kiss, ~(GFC_UINTEGER_4) 0);\n \n       /* Advance to the next element.  */\n       dest += stride0;\n@@ -554,6 +593,7 @@ arandom_r4 (gfc_array_r4 *x)\n             }\n         }\n     }\n+  __gthread_mutex_unlock (&random_lock);\n }\n \n /*  This function fills a REAL(8) array with values from the uniform\n@@ -568,6 +608,7 @@ arandom_r8 (gfc_array_r8 *x)\n   index_type stride0;\n   index_type dim;\n   GFC_REAL_8 *dest;\n+  GFC_UINTEGER_8 kiss;\n   int n;\n \n   dest = x->data;\n@@ -588,9 +629,14 @@ arandom_r8 (gfc_array_r8 *x)\n \n   stride0 = stride[0];\n \n+  __gthread_mutex_lock (&random_lock);\n+\n   while (dest)\n     {\n-      random_r8 (dest);\n+      /* random_r8 (dest); */\n+      kiss = ((GFC_UINTEGER_8)kiss_random_kernel ()) << 32;\n+      kiss += kiss_random_kernel ();\n+      *dest = normalize_r8_i8 (kiss, ~(GFC_UINTEGER_8) 0);\n \n       /* Advance to the next element.  */\n       dest += stride0;\n@@ -618,6 +664,7 @@ arandom_r8 (gfc_array_r8 *x)\n             }\n         }\n     }\n+  __gthread_mutex_unlock (&random_lock);\n }\n \n /* random_seed is used to seed the PRNG with either a default\n@@ -629,6 +676,8 @@ random_seed (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n {\n   int i;\n \n+  __gthread_mutex_lock (&random_lock);\n+\n   if (size == NULL && put == NULL && get == NULL)\n     {\n       /* From the standard: \"If no argument is present, the processor assigns\n@@ -678,7 +727,17 @@ random_seed (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n       for (i = 0; i < kiss_size; i++)\n         get->data[i * get->dim[0].stride] = (GFC_INTEGER_4) kiss_seed[i];\n     }\n+\n+  __gthread_mutex_unlock (&random_lock);\n }\n iexport(random_seed);\n \n #endif /* mersenne twister */\n+\n+#ifndef __GTHREAD_MUTEX_INIT\n+static void __attribute__((constructor))\n+init (void)\n+{\n+  __GTHREAD_MUTEX_INIT_FUNCTION (&random_lock);\n+}\n+#endif"}, {"sha": "63c7045a9bd710baf8f17bcacf36d147c3f5ddc8", "filename": "libgfortran/intrinsics/system_clock.c", "status": "modified", "additions": 53, "deletions": 78, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fintrinsics%2Fsystem_clock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fintrinsics%2Fsystem_clock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fsystem_clock.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -44,13 +44,6 @@ Boston, MA 02110-1301, USA.  */\n #endif\n \n \n-#if defined(HAVE_SYS_TIME_H) && defined(HAVE_GETTIMEOFDAY)\n-static struct timeval tp0 = {-1, 0};\n-#elif defined(HAVE_TIME_H)\n-static time_t t0 = (time_t) -2;\n-#endif\n-\n-\n extern void system_clock_4 (GFC_INTEGER_4 *, GFC_INTEGER_4 *, GFC_INTEGER_4 *);\n export_proto(system_clock_4);\n \n@@ -74,31 +67,18 @@ system_clock_4(GFC_INTEGER_4 *count, GFC_INTEGER_4 *count_rate,\n #if defined(HAVE_SYS_TIME_H) && defined(HAVE_GETTIMEOFDAY)\n   struct timeval tp1;\n   struct timezone tzp;\n-  double t;\n+\n+  if (sizeof (tp1.tv_sec) < sizeof (GFC_INTEGER_4))\n+    internal_error (NULL, \"tv_sec too small\");\n \n   if (gettimeofday(&tp1, &tzp) == 0)\n     {\n-      if (tp0.tv_sec < 0)\n-        {\n-          tp0 = tp1;\n-          cnt = 0;\n-        }\n+      GFC_UINTEGER_4 ucnt = (GFC_UINTEGER_4) tp1.tv_sec * TCK;\n+      ucnt += (tp1.tv_usec + 500000 / TCK) / (1000000 / TCK);\n+      if (ucnt > GFC_INTEGER_4_HUGE)\n+\tcnt = ucnt - GFC_INTEGER_4_HUGE - 1;\n       else\n-        {\n-\t  /* TODO: Convert this to integer arithmetic.  */\n-          t  = (double) (tp1.tv_sec  - tp0.tv_sec);\n-          t += (double) (tp1.tv_usec - tp0.tv_usec) * 1.e-6;\n-          t *= TCK;\n-\n-          if (t > (double) GFC_INTEGER_4_HUGE)\n-            {\n-              /* Time has wrapped. */\n-              while (t > (double) GFC_INTEGER_4_HUGE)\n-                t -= (double) GFC_INTEGER_4_HUGE;\n-              tp0 = tp1;\n-            }\n-\t  cnt = (GFC_INTEGER_4) t;\n-        }\n+\tcnt = ucnt;\n       rate = TCK;\n       mx = GFC_INTEGER_4_HUGE;\n     }\n@@ -113,24 +93,17 @@ system_clock_4(GFC_INTEGER_4 *count, GFC_INTEGER_4 *count_rate,\n       return;\n     }\n #elif defined(HAVE_TIME_H)\n-  time_t t, t1;\n+  GFC_UINTEGER_4 ucnt;\n \n-  t1 = time(NULL);\n+  if (sizeof (time_t) < sizeof (GFC_INTEGER_4))\n+    internal_error (NULL, \"time_t too small\");\n \n-  if (t1 == (time_t) -1)\n-    {\n-      cnt = - GFC_INTEGER_4_HUGE;\n-      mx = 0;\n-    }\n-  else if (t0 == (time_t) -2)\n-    t0 = t1;\n+  ucnt = time (NULL);\n+  if (ucnt > GFC_INTEGER_4_HUGE)\n+    cnt = ucnt - GFC_INTEGER_4_HUGE - 1;\n   else\n-    {\n-      /* The timer counts in seconts, so for simplicity assume it never wraps.\n-\t Even with 32-bit counters this only happens once every 68 years.  */\n-      cnt = t1 - t0;\n-      mx = GFC_INTEGER_4_HUGE;\n-    }\n+    cnt = ucnt;\n+  mx = GFC_INTEGER_4_HUGE;\n #else\n   cnt = - GFC_INTEGER_4_HUGE;\n   mx = 0;\n@@ -148,7 +121,7 @@ system_clock_4(GFC_INTEGER_4 *count, GFC_INTEGER_4 *count_rate,\n \n void\n system_clock_8 (GFC_INTEGER_8 *count, GFC_INTEGER_8 *count_rate,\n-\t        GFC_INTEGER_8 *count_max)\n+\t\tGFC_INTEGER_8 *count_max)\n {\n   GFC_INTEGER_8 cnt;\n   GFC_INTEGER_8 rate;\n@@ -157,33 +130,33 @@ system_clock_8 (GFC_INTEGER_8 *count, GFC_INTEGER_8 *count_rate,\n #if defined(HAVE_SYS_TIME_H) && defined(HAVE_GETTIMEOFDAY)\n   struct timeval tp1;\n   struct timezone tzp;\n-  double t;\n+\n+  if (sizeof (tp1.tv_sec) < sizeof (GFC_INTEGER_4))\n+    internal_error (NULL, \"tv_sec too small\");\n \n   if (gettimeofday(&tp1, &tzp) == 0)\n     {\n-      if (tp0.tv_sec < 0)\n-        {\n-          tp0 = tp1;\n-          cnt = 0;\n-        }\n+      if (sizeof (tp1.tv_sec) < sizeof (GFC_INTEGER_8))\n+\t{\n+\t  GFC_UINTEGER_4 ucnt = (GFC_UINTEGER_4) tp1.tv_sec * TCK;\n+\t  ucnt += (tp1.tv_usec + 500000 / TCK) / (1000000 / TCK);\n+\t  if (ucnt > GFC_INTEGER_4_HUGE)\n+\t    cnt = ucnt - GFC_INTEGER_4_HUGE - 1;\n+\t  else\n+\t    cnt = ucnt;\n+\t  mx = GFC_INTEGER_4_HUGE;\n+\t}\n       else\n-        {\n-\t  /* TODO: Convert this to integer arithmetic.  */\n-          t  = (double) (tp1.tv_sec  - tp0.tv_sec);\n-          t += (double) (tp1.tv_usec - tp0.tv_usec) * 1.e-6;\n-          t *= TCK;\n-\n-          if (t > (double) GFC_INTEGER_8_HUGE)\n-            {\n-              /* Time has wrapped. */\n-              while (t > (double) GFC_INTEGER_8_HUGE)\n-                t -= (double) GFC_INTEGER_8_HUGE;\n-              tp0 = tp1;\n-            }\n-\t  cnt = (GFC_INTEGER_8) t;\n-        }\n+\t{\n+\t  GFC_UINTEGER_8 ucnt = (GFC_UINTEGER_8) tp1.tv_sec * TCK;\n+\t  ucnt += (tp1.tv_usec + 500000 / TCK) / (1000000 / TCK);\n+\t  if (ucnt > GFC_INTEGER_8_HUGE)\n+\t    cnt = ucnt - GFC_INTEGER_8_HUGE - 1;\n+\t  else\n+\t    cnt = ucnt;\n+\t  mx = GFC_INTEGER_8_HUGE;\n+\t}\n       rate = TCK;\n-      mx = GFC_INTEGER_8_HUGE;\n     }\n   else\n     {\n@@ -197,22 +170,24 @@ system_clock_8 (GFC_INTEGER_8 *count, GFC_INTEGER_8 *count_rate,\n       return;\n     }\n #elif defined(HAVE_TIME_H)\n-  time_t t, t1;\n-\n-  t1 = time(NULL);\n-\n-  if (t1 == (time_t) -1)\n+  if (sizeof (time_t) < sizeof (GFC_INTEGER_4))\n+    internal_error (NULL, \"time_t too small\");\n+  else if (sizeof (time_t) == sizeof (GFC_INTEGER_4))\n     {\n-      cnt = - GFC_INTEGER_8_HUGE;\n-      mx = 0;\n+      GFC_UINTEGER_4 ucnt = time (NULL);\n+      if (ucnt > GFC_INTEGER_4_HUGE)\n+\tcnt = ucnt - GFC_INTEGER_4_HUGE - 1;\n+      else\n+\tcnt = ucnt;\n+      mx = GFC_INTEGER_4_HUGE;\n     }\n-  else if (t0 == (time_t) -2)\n-    t0 = t1;\n   else\n     {\n-      /* The timer counts in seconts, so for simplicity assume it never wraps.\n-\t Even with 32-bit counters this only happens once every 68 years.  */\n-      cnt = t1 - t0;\n+      GFC_UINTEGER_8 ucnt = time (NULL);\n+      if (ucnt > GFC_INTEGER_8_HUGE)\n+\tcnt = ucnt - GFC_INTEGER_8_HUGE - 1;\n+      else\n+\tcnt = ucnt;\n       mx = GFC_INTEGER_8_HUGE;\n     }\n #else"}, {"sha": "63c2a5e6d76d0a772dfdbb067554668d1f8a2298", "filename": "libgfortran/intrinsics/tty.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fintrinsics%2Ftty.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fintrinsics%2Ftty.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Ftty.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -44,12 +44,15 @@ GFC_LOGICAL_4\n isatty_l4 (int *unit)\n {\n   gfc_unit *u;\n+  GFC_LOGICAL_4 ret = 0;\n \n   u = find_unit (*unit);\n   if (u != NULL)\n-    return (GFC_LOGICAL_4) stream_isatty (u->s);\n-  else\n-    return 0;\n+    {\n+      ret = (GFC_LOGICAL_4) stream_isatty (u->s);\n+      unlock_unit (u);\n+    }\n+  return ret;\n }\n \n \n@@ -60,12 +63,15 @@ GFC_LOGICAL_8\n isatty_l8 (int *unit)\n {\n   gfc_unit *u;\n+  GFC_LOGICAL_8 ret = 0;\n \n   u = find_unit (*unit);\n   if (u != NULL)\n-    return (GFC_LOGICAL_8) stream_isatty (u->s);\n-  else\n-    return 0;\n+    {\n+      ret = (GFC_LOGICAL_8) stream_isatty (u->s);\n+      unlock_unit (u);\n+    }\n+  return ret;\n }\n \n \n@@ -94,6 +100,7 @@ ttynam_sub (int *unit, char * name, gfc_charlen_type name_len)\n \t  while (*n && i < name_len)\n \t    name[i++] = *(n++);\n \t}\n+      unlock_unit (u);\n     }\n }\n "}, {"sha": "9dcc1a3e60b78868820ba110eefc2417224acf26", "filename": "libgfortran/io/close.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Fclose.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Fclose.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fclose.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -43,11 +43,11 @@ static const st_option status_opt[] = {\n };\n \n \n-extern void st_close (void);\n+extern void st_close (st_parameter_close *);\n export_proto(st_close);\n \n void\n-st_close (void)\n+st_close (st_parameter_close *clp)\n {\n   close_status status;\n   gfc_unit *u;\n@@ -57,25 +57,25 @@ st_close (void)\n   path = NULL;\n #endif\n \n-  library_start ();\n+  library_start (&clp->common);\n \n-  status = (ioparm.status == NULL) ? CLOSE_UNSPECIFIED :\n-    find_option (ioparm.status, ioparm.status_len, status_opt,\n-\t\t \"Bad STATUS parameter in CLOSE statement\");\n+  status = !(clp->common.flags & IOPARM_CLOSE_HAS_STATUS) ? CLOSE_UNSPECIFIED :\n+    find_option (&clp->common, clp->status, clp->status_len,\n+\t\t status_opt, \"Bad STATUS parameter in CLOSE statement\");\n \n-  if (ioparm.library_return != LIBRARY_OK)\n+  if ((clp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n   {\n     library_end ();\n     return;\n   }\n \n-  u = find_unit (ioparm.unit);\n+  u = find_unit (clp->common.unit);\n   if (u != NULL)\n     {\n       if (u->flags.status == STATUS_SCRATCH)\n \t{\n \t  if (status == CLOSE_KEEP)\n-\t    generate_error (ERROR_BAD_OPTION,\n+\t    generate_error (&clp->common, ERROR_BAD_OPTION,\n \t\t\t    \"Can't KEEP a scratch file on CLOSE\");\n #if !HAVE_UNLINK_OPEN_FILE\n \t  path = (char *) gfc_alloca (u->file_len + 1);"}, {"sha": "0049718f63372ae8537efc67493c33050877a120", "filename": "libgfortran/io/file_pos.c", "status": "modified", "additions": 52, "deletions": 44, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Ffile_pos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Ffile_pos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffile_pos.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -36,28 +36,28 @@ Boston, MA 02110-1301, USA.  */\n    ENDFILE, and REWIND as well as the FLUSH statement.  */\n \n \n-/* formatted_backspace(void)-- Move the file back one line.  The\n+/* formatted_backspace(fpp, u)-- Move the file back one line.  The\n    current position is after the newline that terminates the previous\n    record, and we have to sift backwards to find the newline before\n    that or the start of the file, whichever comes first.  */\n \n #define READ_CHUNK 4096\n \n static void\n-formatted_backspace (void)\n+formatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)\n {\n   gfc_offset base;\n   char *p;\n   int n;\n \n-  base = file_position (current_unit->s) - 1;\n+  base = file_position (u->s) - 1;\n \n   do\n     {\n       n = (base < READ_CHUNK) ? base : READ_CHUNK;\n       base -= n;\n \n-      p = salloc_r_at (current_unit->s, &n, base);\n+      p = salloc_r_at (u->s, &n, base);\n       if (p == NULL)\n \tgoto io_error;\n \n@@ -84,68 +84,66 @@ formatted_backspace (void)\n \n   /* base is the new pointer.  Seek to it exactly.  */\n  done:\n-  if (sseek (current_unit->s, base) == FAILURE)\n+  if (sseek (u->s, base) == FAILURE)\n     goto io_error;\n-  current_unit->last_record--;\n-  current_unit->endfile = NO_ENDFILE;\n+  u->last_record--;\n+  u->endfile = NO_ENDFILE;\n \n   return;\n \n  io_error:\n-  generate_error (ERROR_OS, NULL);\n+  generate_error (&fpp->common, ERROR_OS, NULL);\n }\n \n \n-/* unformatted_backspace() -- Move the file backwards for an unformatted\n+/* unformatted_backspace(fpp) -- Move the file backwards for an unformatted\n    sequential file.  We are guaranteed to be between records on entry and \n    we have to shift to the previous record.  */\n \n static void\n-unformatted_backspace (void)\n+unformatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)\n {\n   gfc_offset m, new;\n   int length;\n   char *p;\n \n   length = sizeof (gfc_offset);\n \n-  p = salloc_r_at (current_unit->s, &length,\n-\t\t   file_position (current_unit->s) - length);\n+  p = salloc_r_at (u->s, &length,\n+\t\t   file_position (u->s) - length);\n   if (p == NULL)\n     goto io_error;\n \n   memcpy (&m, p, sizeof (gfc_offset));\n-  new = file_position (current_unit->s) - m - 2*length;\n-  if (sseek (current_unit->s, new) == FAILURE)\n+  new = file_position (u->s) - m - 2*length;\n+  if (sseek (u->s, new) == FAILURE)\n     goto io_error;\n \n-  current_unit->last_record--;\n+  u->last_record--;\n   return;\n \n  io_error:\n-  generate_error (ERROR_OS, NULL);\n+  generate_error (&fpp->common, ERROR_OS, NULL);\n }\n \n \n-extern void st_backspace (void);\n+extern void st_backspace (st_parameter_filepos *);\n export_proto(st_backspace);\n \n void\n-st_backspace (void)\n+st_backspace (st_parameter_filepos *fpp)\n {\n   gfc_unit *u;\n \n-  library_start ();\n+  library_start (&fpp->common);\n \n-  u = find_unit (ioparm.unit);\n+  u = find_unit (fpp->common.unit);\n   if (u == NULL)\n     {\n-      generate_error (ERROR_BAD_UNIT, NULL);\n+      generate_error (&fpp->common, ERROR_BAD_UNIT, NULL);\n       goto done;\n     }\n \n-  current_unit = u;\n-\n   /* Ignore direct access.  Non-advancing I/O is only allowed for formatted\n      sequential I/O and the next direct access transfer repositions the file \n      anyway.  */\n@@ -170,60 +168,69 @@ st_backspace (void)\n         }\n \n       if (u->flags.form == FORM_FORMATTED)\n-\tformatted_backspace ();\n+\tformatted_backspace (fpp, u);\n       else\n-\tunformatted_backspace ();\n+\tunformatted_backspace (fpp, u);\n \n       u->endfile = NO_ENDFILE;\n       u->current_record = 0;\n     }\n \n  done:\n+  if (u != NULL)\n+    unlock_unit (u);\n+\n   library_end ();\n }\n \n \n-extern void st_endfile (void);\n+extern void st_endfile (st_parameter_filepos *);\n export_proto(st_endfile);\n \n void\n-st_endfile (void)\n+st_endfile (st_parameter_filepos *fpp)\n {\n   gfc_unit *u;\n \n-  library_start ();\n+  library_start (&fpp->common);\n \n-  u = get_unit (0);\n+  u = find_unit (fpp->common.unit);\n   if (u != NULL)\n     {\n-      current_unit = u;\t\t/* next_record() needs this set.  */\n       if (u->current_record)\n-\tnext_record (1);\n+\t{\n+\t  st_parameter_dt dtp;\n+\t  dtp.common = fpp->common;\n+\t  memset (&dtp.u.p, 0, sizeof (dtp.u.p));\n+\t  dtp.u.p.current_unit = u;\n+\t  next_record (&dtp, 1);\n+\t}\n \n-      flush(u->s);\n+      flush (u->s);\n       struncate (u->s);\n       u->endfile = AFTER_ENDFILE;\n+      unlock_unit (u);\n     }\n \n   library_end ();\n }\n \n \n-extern void st_rewind (void);\n+extern void st_rewind (st_parameter_filepos *);\n export_proto(st_rewind);\n \n void\n-st_rewind (void)\n+st_rewind (st_parameter_filepos *fpp)\n {\n   gfc_unit *u;\n \n-  library_start ();\n+  library_start (&fpp->common);\n \n-  u = find_unit (ioparm.unit);\n+  u = find_unit (fpp->common.unit);\n   if (u != NULL)\n     {\n       if (u->flags.access != ACCESS_SEQUENTIAL)\n-\tgenerate_error (ERROR_BAD_OPTION,\n+\tgenerate_error (&fpp->common, ERROR_BAD_OPTION,\n \t\t\t\"Cannot REWIND a file opened for DIRECT access\");\n       else\n \t{\n@@ -239,35 +246,36 @@ st_rewind (void)\n \t  u->mode = READING;\n \t  u->last_record = 0;\n \t  if (sseek (u->s, 0) == FAILURE)\n-\t    generate_error (ERROR_OS, NULL);\n+\t    generate_error (&fpp->common, ERROR_OS, NULL);\n \n \t  u->endfile = NO_ENDFILE;\n \t  u->current_record = 0;\n \t  test_endfile (u);\n \t}\n       /* Update position for INQUIRE.  */\n       u->flags.position = POSITION_REWIND;\n+      unlock_unit (u);\n     }\n \n   library_end ();\n }\n \n \n-extern void st_flush (void);\n+extern void st_flush (st_parameter_filepos *);\n export_proto(st_flush);\n \n void\n-st_flush (void)\n+st_flush (st_parameter_filepos *fpp)\n {\n   gfc_unit *u;\n \n-  library_start ();\n+  library_start (&fpp->common);\n \n-  u = get_unit (0);\n+  u = find_unit (fpp->common.unit);\n   if (u != NULL)\n     {\n-      current_unit = u;  /* Just to be sure.  */\n-      flush(u->s);\n+      flush (u->s);\n+      unlock_unit (u);\n     }\n \n   library_end ();"}, {"sha": "1d7e15b11059306e7ec3067b91ca7cab6aebdac3", "filename": "libgfortran/io/format.c", "status": "modified", "additions": 240, "deletions": 240, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Fformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Fformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fformat.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -38,26 +38,30 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n #include \"io.h\"\n \n+#define FARRAY_SIZE 64\n \n+typedef struct fnode_array\n+{\n+  struct fnode_array *next;\n+  fnode array[FARRAY_SIZE];\n+}\n+fnode_array;\n \n-/* Number of format nodes that we can store statically before we have\n- * to resort to dynamic allocation.  The root node is array[0]. */\n-\n-#define FARRAY_SIZE 200\n-\n-static fnode *avail, array[FARRAY_SIZE];\n-\n-/* Local variables for checking format strings.  The saved_token is\n- * used to back up by a single format token during the parsing process. */\n-\n-static char *format_string, *string;\n-static const char *error;\n-static format_token saved_token;\n-static int value, format_string_len, reversion_ok;\n+typedef struct format_data\n+{\n+  char *format_string, *string;\n+  const char *error;\n+  format_token saved_token;\n+  int value, format_string_len, reversion_ok;\n+  fnode *avail;\n+  const fnode *saved_format;\n+  fnode_array *last;\n+  fnode_array array;\n+}\n+format_data;\n \n-static fnode *saved_format;\n-static fnode colon_node = { FMT_COLON, 0, NULL, NULL, {{ 0, 0, 0 }}, 0,\n-\t\t\t    NULL };\n+static const fnode colon_node = { FMT_COLON, 0, NULL, NULL, {{ 0, 0, 0 }}, 0,\n+\t\t\t\t  NULL };\n \n /* Error messages */\n \n@@ -76,17 +80,17 @@ static const char posint_required[] = \"Positive width required in format\",\n  * spaces are significant, otherwise they are not. */\n \n static int\n-next_char (int literal)\n+next_char (format_data *fmt, int literal)\n {\n   int c;\n \n   do\n     {\n-      if (format_string_len == 0)\n+      if (fmt->format_string_len == 0)\n \treturn -1;\n \n-      format_string_len--;\n-      c = toupper (*format_string++);\n+      fmt->format_string_len--;\n+      c = toupper (*fmt->format_string++);\n     }\n   while (c == ' ' && !literal);\n \n@@ -96,25 +100,28 @@ next_char (int literal)\n \n /* unget_char()-- Back up one character position. */\n \n-#define unget_char() { format_string--;  format_string_len++; }\n+#define unget_char(fmt) \\\n+  { fmt->format_string--; fmt->format_string_len++; }\n \n \n /* get_fnode()-- Allocate a new format node, inserting it into the\n  * current singly linked list.  These are initially allocated from the\n  * static buffer. */\n \n static fnode *\n-get_fnode (fnode ** head, fnode ** tail, format_token t)\n+get_fnode (format_data *fmt, fnode **head, fnode **tail, format_token t)\n {\n   fnode *f;\n \n-  if (avail - array >= FARRAY_SIZE)\n-    f = get_mem (sizeof (fnode));\n-  else\n+  if (fmt->avail == &fmt->last->array[FARRAY_SIZE])\n     {\n-      f = avail++;\n-      memset (f, '\\0', sizeof (fnode));\n+      fmt->last->next = get_mem (sizeof (fnode_array));\n+      fmt->last = fmt->last->next;\n+      fmt->last->next = NULL;\n+      fmt->avail = &fmt->last->array[0];\n     }\n+  f = fmt->avail++;\n+  memset (f, '\\0', sizeof (fnode));\n \n   if (*head == NULL)\n     *head = *tail = f;\n@@ -126,67 +133,54 @@ get_fnode (fnode ** head, fnode ** tail, format_token t)\n \n   f->format = t;\n   f->repeat = -1;\n-  f->source = format_string;\n+  f->source = fmt->format_string;\n   return f;\n }\n \n \n-/* free_fnode()-- Recursive function to free the given fnode and\n- * everything it points to.  We only have to actually free something\n- * if it is outside of the static array. */\n+/* free_format_data()-- Free all allocated format data.  */\n \n-static void\n-free_fnode (fnode * f)\n+void\n+free_format_data (st_parameter_dt *dtp)\n {\n-  fnode *next;\n+  fnode_array *fa, *fa_next;\n+  format_data *fmt = dtp->u.p.fmt;\n \n-  for (; f; f = next)\n-    {\n-      next = f->next;\n+  if (fmt == NULL)\n+    return;\n \n-      if (f->format == FMT_LPAREN)\n-\tfree_fnode (f->u.child);\n-      if (f < array || f >= array + FARRAY_SIZE)\n-\tfree_mem (f);\n+  for (fa = fmt->array.next; fa; fa = fa_next)\n+    {\n+      fa_next = fa->next;\n+      free_mem (fa);\n     }\n-}\n-\n \n-/* free_fnodes()-- Free the current tree of fnodes.  We only have to\n- * traverse the tree if some nodes were allocated dynamically. */\n-\n-void\n-free_fnodes (void)\n-{\n-  if (avail - array >= FARRAY_SIZE)\n-    free_fnode (&array[0]);\n-\n-  avail = array;\n-  memset(array, 0, sizeof(avail[0]) * FARRAY_SIZE);\n+  free_mem (fmt);\n+  dtp->u.p.fmt = NULL;\n }\n \n \n /* format_lex()-- Simple lexical analyzer for getting the next token\n  * in a FORMAT string.  We support a one-level token pushback in the\n- * saved_token variable. */\n+ * fmt->saved_token variable. */\n \n static format_token\n-format_lex (void)\n+format_lex (format_data *fmt)\n {\n   format_token token;\n   int negative_flag;\n   int c;\n   char delim;\n \n-  if (saved_token != FMT_NONE)\n+  if (fmt->saved_token != FMT_NONE)\n     {\n-      token = saved_token;\n-      saved_token = FMT_NONE;\n+      token = fmt->saved_token;\n+      fmt->saved_token = FMT_NONE;\n       return token;\n     }\n \n   negative_flag = 0;\n-  c = next_char (0);\n+  c = next_char (fmt, 0);\n \n   switch (c)\n     {\n@@ -195,28 +189,28 @@ format_lex (void)\n       /* Fall Through */\n \n     case '+':\n-      c = next_char (0);\n+      c = next_char (fmt, 0);\n       if (!isdigit (c))\n \t{\n \t  token = FMT_UNKNOWN;\n \t  break;\n \t}\n \n-      value = c - '0';\n+      fmt->value = c - '0';\n \n       for (;;)\n \t{\n-\t  c = next_char (0);\n+\t  c = next_char (fmt, 0);\n \t  if (!isdigit (c))\n \t    break;\n \n-\t  value = 10 * value + c - '0';\n+\t  fmt->value = 10 * fmt->value + c - '0';\n \t}\n \n-      unget_char ();\n+      unget_char (fmt);\n \n       if (negative_flag)\n-\tvalue = -value;\n+\tfmt->value = -fmt->value;\n       token = FMT_SIGNED_INT;\n       break;\n \n@@ -230,19 +224,19 @@ format_lex (void)\n     case '7':\n     case '8':\n     case '9':\n-      value = c - '0';\n+      fmt->value = c - '0';\n \n       for (;;)\n \t{\n-\t  c = next_char (0);\n+\t  c = next_char (fmt, 0);\n \t  if (!isdigit (c))\n \t    break;\n \n-\t  value = 10 * value + c - '0';\n+\t  fmt->value = 10 * fmt->value + c - '0';\n \t}\n \n-      unget_char ();\n-      token = (value == 0) ? FMT_ZERO : FMT_POSINT;\n+      unget_char (fmt);\n+      token = (fmt->value == 0) ? FMT_ZERO : FMT_POSINT;\n       break;\n \n     case '.':\n@@ -266,7 +260,7 @@ format_lex (void)\n       break;\n \n     case 'T':\n-      switch (next_char (0))\n+      switch (next_char (fmt, 0))\n \t{\n \tcase 'L':\n \t  token = FMT_TL;\n@@ -276,7 +270,7 @@ format_lex (void)\n \t  break;\n \tdefault:\n \t  token = FMT_T;\n-\t  unget_char ();\n+\t  unget_char (fmt);\n \t  break;\n \t}\n \n@@ -295,7 +289,7 @@ format_lex (void)\n       break;\n \n     case 'S':\n-      switch (next_char (0))\n+      switch (next_char (fmt, 0))\n \t{\n \tcase 'S':\n \t  token = FMT_SS;\n@@ -305,14 +299,14 @@ format_lex (void)\n \t  break;\n \tdefault:\n \t  token = FMT_S;\n-\t  unget_char ();\n+\t  unget_char (fmt);\n \t  break;\n \t}\n \n       break;\n \n     case 'B':\n-      switch (next_char (0))\n+      switch (next_char (fmt, 0))\n \t{\n \tcase 'N':\n \t  token = FMT_BN;\n@@ -322,7 +316,7 @@ format_lex (void)\n \t  break;\n \tdefault:\n \t  token = FMT_B;\n-\t  unget_char ();\n+\t  unget_char (fmt);\n \t  break;\n \t}\n \n@@ -332,39 +326,39 @@ format_lex (void)\n     case '\"':\n       delim = c;\n \n-      string = format_string;\n-      value = 0;\t\t/* This is the length of the string */\n+      fmt->string = fmt->format_string;\n+      fmt->value = 0;\t\t/* This is the length of the string */\n \n       for (;;)\n \t{\n-\t  c = next_char (1);\n+\t  c = next_char (fmt, 1);\n \t  if (c == -1)\n \t    {\n \t      token = FMT_BADSTRING;\n-\t      error = bad_string;\n+\t      fmt->error = bad_string;\n \t      break;\n \t    }\n \n \t  if (c == delim)\n \t    {\n-\t      c = next_char (1);\n+\t      c = next_char (fmt, 1);\n \n \t      if (c == -1)\n \t\t{\n \t\t  token = FMT_BADSTRING;\n-\t\t  error = bad_string;\n+\t\t  fmt->error = bad_string;\n \t\t  break;\n \t\t}\n \n \t      if (c != delim)\n \t\t{\n-\t\t  unget_char ();\n+\t\t  unget_char (fmt);\n \t\t  token = FMT_STRING;\n \t\t  break;\n \t\t}\n \t    }\n \n-\t  value++;\n+\t  fmt->value++;\n \t}\n \n       break;\n@@ -390,7 +384,7 @@ format_lex (void)\n       break;\n \n     case 'E':\n-      switch (next_char (0))\n+      switch (next_char (fmt, 0))\n \t{\n \tcase 'N':\n \t  token = FMT_EN;\n@@ -400,7 +394,7 @@ format_lex (void)\n \t  break;\n \tdefault:\n \t  token = FMT_E;\n-\t  unget_char ();\n+\t  unget_char (fmt);\n \t  break;\n \t}\n \n@@ -444,44 +438,45 @@ format_lex (void)\n  * parenthesis node which contains the rest of the list. */\n \n static fnode *\n-parse_format_list (void)\n+parse_format_list (st_parameter_dt *dtp)\n {\n   fnode *head, *tail;\n   format_token t, u, t2;\n   int repeat;\n+  format_data *fmt = dtp->u.p.fmt;\n \n   head = tail = NULL;\n \n   /* Get the next format item */\n  format_item:\n-  t = format_lex ();\n+  t = format_lex (fmt);\n  format_item_1:\n   switch (t)\n     {\n     case FMT_POSINT:\n-      repeat = value;\n+      repeat = fmt->value;\n \n-      t = format_lex ();\n+      t = format_lex (fmt);\n       switch (t)\n \t{\n \tcase FMT_LPAREN:\n-\t  get_fnode (&head, &tail, FMT_LPAREN);\n+\t  get_fnode (fmt, &head, &tail, FMT_LPAREN);\n \t  tail->repeat = repeat;\n-\t  tail->u.child = parse_format_list ();\n-\t  if (error != NULL)\n+\t  tail->u.child = parse_format_list (dtp);\n+\t  if (fmt->error != NULL)\n \t    goto finished;\n \n \t  goto between_desc;\n \n \tcase FMT_SLASH:\n-\t  get_fnode (&head, &tail, FMT_SLASH);\n+\t  get_fnode (fmt, &head, &tail, FMT_SLASH);\n \t  tail->repeat = repeat;\n \t  goto optional_comma;\n \n \tcase FMT_X:\n-\t  get_fnode (&head, &tail, FMT_X);\n+\t  get_fnode (fmt, &head, &tail, FMT_X);\n \t  tail->repeat = 1;\n-\t  tail->u.k = value;\n+\t  tail->u.k = fmt->value;\n \t  goto between_desc;\n \n \tcase FMT_P:\n@@ -492,41 +487,41 @@ parse_format_list (void)\n \t}\n \n     case FMT_LPAREN:\n-      get_fnode (&head, &tail, FMT_LPAREN);\n+      get_fnode (fmt, &head, &tail, FMT_LPAREN);\n       tail->repeat = 1;\n-      tail->u.child = parse_format_list ();\n-      if (error != NULL)\n+      tail->u.child = parse_format_list (dtp);\n+      if (fmt->error != NULL)\n \tgoto finished;\n \n       goto between_desc;\n \n     case FMT_SIGNED_INT:\t/* Signed integer can only precede a P format.  */\n     case FMT_ZERO:\t\t/* Same for zero.  */\n-      t = format_lex ();\n+      t = format_lex (fmt);\n       if (t != FMT_P)\n \t{\n-\t  error = \"Expected P edit descriptor in format\";\n+\t  fmt->error = \"Expected P edit descriptor in format\";\n \t  goto finished;\n \t}\n \n     p_descriptor:\n-      get_fnode (&head, &tail, FMT_P);\n-      tail->u.k = value;\n+      get_fnode (fmt, &head, &tail, FMT_P);\n+      tail->u.k = fmt->value;\n       tail->repeat = 1;\n \n-      t = format_lex ();\n+      t = format_lex (fmt);\n       if (t == FMT_F || t == FMT_EN || t == FMT_ES || t == FMT_D\n \t  || t == FMT_G || t == FMT_E)\n \t{\n \t  repeat = 1;\n \t  goto data_desc;\n \t}\n \n-      saved_token = t;\n+      fmt->saved_token = t;\n       goto optional_comma;\n \n     case FMT_P:\t\t/* P and X require a prior number */\n-      error = \"P descriptor requires leading scale factor\";\n+      fmt->error = \"P descriptor requires leading scale factor\";\n       goto finished;\n \n     case FMT_X:\n@@ -536,24 +531,24 @@ parse_format_list (void)\n    If we would be pedantic in the library, we would have to reject\n    an X descriptor without an integer prefix:\n \n-      error = \"X descriptor requires leading space count\";\n+      fmt->error = \"X descriptor requires leading space count\";\n       goto finished;\n \n    However, this is an extension supported by many Fortran compilers,\n    including Cray, HP, AIX, and IRIX.  Therefore, we allow it in the\n    runtime library, and make the front end reject it if the compiler\n    is in pedantic mode.  The interpretation of 'X' is '1X'.\n */\n-      get_fnode (&head, &tail, FMT_X);\n+      get_fnode (fmt, &head, &tail, FMT_X);\n       tail->repeat = 1;\n       tail->u.k = 1;\n       goto between_desc;\n \n     case FMT_STRING:\n-      get_fnode (&head, &tail, FMT_STRING);\n+      get_fnode (fmt, &head, &tail, FMT_STRING);\n \n-      tail->u.string.p = string;\n-      tail->u.string.length = value;\n+      tail->u.string.p = fmt->string;\n+      tail->u.string.length = fmt->value;\n       tail->repeat = 1;\n       goto optional_comma;\n \n@@ -562,38 +557,38 @@ parse_format_list (void)\n     case FMT_SP:\n     case FMT_BN:\n     case FMT_BZ:\n-      get_fnode (&head, &tail, t);\n+      get_fnode (fmt, &head, &tail, t);\n       tail->repeat = 1;\n       goto between_desc;\n \n     case FMT_COLON:\n-      get_fnode (&head, &tail, FMT_COLON);\n+      get_fnode (fmt, &head, &tail, FMT_COLON);\n       tail->repeat = 1;\n       goto optional_comma;\n \n     case FMT_SLASH:\n-      get_fnode (&head, &tail, FMT_SLASH);\n+      get_fnode (fmt, &head, &tail, FMT_SLASH);\n       tail->repeat = 1;\n       tail->u.r = 1;\n       goto optional_comma;\n \n     case FMT_DOLLAR:\n-      get_fnode (&head, &tail, FMT_DOLLAR);\n+      get_fnode (fmt, &head, &tail, FMT_DOLLAR);\n       tail->repeat = 1;\n       notify_std (GFC_STD_GNU, \"Extension: $ descriptor\");\n       goto between_desc;\n \n     case FMT_T:\n     case FMT_TL:\n     case FMT_TR:\n-      t2 = format_lex ();\n+      t2 = format_lex (fmt);\n       if (t2 != FMT_POSINT)\n \t{\n-\t  error = posint_required;\n+\t  fmt->error = posint_required;\n \t  goto finished;\n \t}\n-      get_fnode (&head, &tail, t);\n-      tail->u.n = value;\n+      get_fnode (fmt, &head, &tail, t);\n+      tail->u.n = fmt->value;\n       tail->repeat = 1;\n       goto between_desc;\n \n@@ -613,25 +608,25 @@ parse_format_list (void)\n       goto data_desc;\n \n     case FMT_H:\n-      get_fnode (&head, &tail, FMT_STRING);\n+      get_fnode (fmt, &head, &tail, FMT_STRING);\n \n-      if (format_string_len < 1)\n+      if (fmt->format_string_len < 1)\n \t{\n-\t  error = bad_hollerith;\n+\t  fmt->error = bad_hollerith;\n \t  goto finished;\n \t}\n \n-      tail->u.string.p = format_string;\n+      tail->u.string.p = fmt->format_string;\n       tail->u.string.length = 1;\n       tail->repeat = 1;\n \n-      format_string++;\n-      format_string_len--;\n+      fmt->format_string++;\n+      fmt->format_string_len--;\n \n       goto between_desc;\n \n     case FMT_END:\n-      error = unexpected_end;\n+      fmt->error = unexpected_end;\n       goto finished;\n \n     case FMT_BADSTRING:\n@@ -641,7 +636,7 @@ parse_format_list (void)\n       goto finished;\n \n     default:\n-      error = unexpected_element;\n+      fmt->error = unexpected_element;\n       goto finished;\n     }\n \n@@ -651,42 +646,42 @@ parse_format_list (void)\n   switch (t)\n     {\n     case FMT_P:\n-      t = format_lex ();\n+      t = format_lex (fmt);\n       if (t == FMT_POSINT)\n \t{\n-\t  error = \"Repeat count cannot follow P descriptor\";\n+\t  fmt->error = \"Repeat count cannot follow P descriptor\";\n \t  goto finished;\n \t}\n \n-      saved_token = t;\n-      get_fnode (&head, &tail, FMT_P);\n+      fmt->saved_token = t;\n+      get_fnode (fmt, &head, &tail, FMT_P);\n \n       goto optional_comma;\n \n     case FMT_L:\n-      t = format_lex ();\n+      t = format_lex (fmt);\n       if (t != FMT_POSINT)\n \t{\n-\t  error = posint_required;\n+\t  fmt->error = posint_required;\n \t  goto finished;\n \t}\n \n-      get_fnode (&head, &tail, FMT_L);\n-      tail->u.n = value;\n+      get_fnode (fmt, &head, &tail, FMT_L);\n+      tail->u.n = fmt->value;\n       tail->repeat = repeat;\n       break;\n \n     case FMT_A:\n-      t = format_lex ();\n+      t = format_lex (fmt);\n       if (t != FMT_POSINT)\n \t{\n-\t  saved_token = t;\n-\t  value = -1;\t\t/* Width not present */\n+\t  fmt->saved_token = t;\n+\t  fmt->value = -1;\t\t/* Width not present */\n \t}\n \n-      get_fnode (&head, &tail, FMT_A);\n+      get_fnode (fmt, &head, &tail, FMT_A);\n       tail->repeat = repeat;\n-      tail->u.n = value;\n+      tail->u.n = fmt->value;\n       break;\n \n     case FMT_D:\n@@ -695,148 +690,148 @@ parse_format_list (void)\n     case FMT_G:\n     case FMT_EN:\n     case FMT_ES:\n-      get_fnode (&head, &tail, t);\n+      get_fnode (fmt, &head, &tail, t);\n       tail->repeat = repeat;\n \n-      u = format_lex ();\n-      if (t == FMT_F || g.mode == WRITING)\n+      u = format_lex (fmt);\n+      if (t == FMT_F || dtp->u.p.mode == WRITING)\n \t{\n \t  if (u != FMT_POSINT && u != FMT_ZERO)\n \t    {\n-\t      error = nonneg_required;\n+\t      fmt->error = nonneg_required;\n \t      goto finished;\n \t    }\n \t}\n       else\n \t{\n \t  if (u != FMT_POSINT)\n \t    {\n-\t      error = posint_required;\n+\t      fmt->error = posint_required;\n \t      goto finished;\n \t    }\n \t}\n \n-      tail->u.real.w = value;\n+      tail->u.real.w = fmt->value;\n       t2 = t;\n-      t = format_lex ();\n+      t = format_lex (fmt);\n       if (t != FMT_PERIOD)\n \t{\n-\t  error = period_required;\n+\t  fmt->error = period_required;\n \t  goto finished;\n \t}\n \n-      t = format_lex ();\n+      t = format_lex (fmt);\n       if (t != FMT_ZERO && t != FMT_POSINT)\n \t{\n-\t  error = nonneg_required;\n+\t  fmt->error = nonneg_required;\n \t  goto finished;\n \t}\n \n-      tail->u.real.d = value;\n+      tail->u.real.d = fmt->value;\n \n       if (t == FMT_D || t == FMT_F)\n \tbreak;\n \n       tail->u.real.e = -1;\n \n       /* Look for optional exponent */\n-      t = format_lex ();\n+      t = format_lex (fmt);\n       if (t != FMT_E)\n-\tsaved_token = t;\n+\tfmt->saved_token = t;\n       else\n \t{\n-\t  t = format_lex ();\n+\t  t = format_lex (fmt);\n \t  if (t != FMT_POSINT)\n \t    {\n-\t      error = \"Positive exponent width required in format\";\n+\t      fmt->error = \"Positive exponent width required in format\";\n \t      goto finished;\n \t    }\n \n-\t  tail->u.real.e = value;\n+\t  tail->u.real.e = fmt->value;\n \t}\n \n       break;\n \n     case FMT_H:\n-      if (repeat > format_string_len)\n+      if (repeat > fmt->format_string_len)\n \t{\n-\t  error = bad_hollerith;\n+\t  fmt->error = bad_hollerith;\n \t  goto finished;\n \t}\n \n-      get_fnode (&head, &tail, FMT_STRING);\n+      get_fnode (fmt, &head, &tail, FMT_STRING);\n \n-      tail->u.string.p = format_string;\n+      tail->u.string.p = fmt->format_string;\n       tail->u.string.length = repeat;\n       tail->repeat = 1;\n \n-      format_string += value;\n-      format_string_len -= repeat;\n+      fmt->format_string += fmt->value;\n+      fmt->format_string_len -= repeat;\n \n       break;\n \n     case FMT_I:\n     case FMT_B:\n     case FMT_O:\n     case FMT_Z:\n-      get_fnode (&head, &tail, t);\n+      get_fnode (fmt, &head, &tail, t);\n       tail->repeat = repeat;\n \n-      t = format_lex ();\n+      t = format_lex (fmt);\n \n-      if (g.mode == READING)\n+      if (dtp->u.p.mode == READING)\n \t{\n \t  if (t != FMT_POSINT)\n \t    {\n-\t      error = posint_required;\n+\t      fmt->error = posint_required;\n \t      goto finished;\n \t    }\n \t}\n       else\n \t{\n \t  if (t != FMT_ZERO && t != FMT_POSINT)\n \t    {\n-\t      error = nonneg_required;\n+\t      fmt->error = nonneg_required;\n \t      goto finished;\n \t    }\n \t}\n \n-      tail->u.integer.w = value;\n+      tail->u.integer.w = fmt->value;\n       tail->u.integer.m = -1;\n \n-      t = format_lex ();\n+      t = format_lex (fmt);\n       if (t != FMT_PERIOD)\n \t{\n-\t  saved_token = t;\n+\t  fmt->saved_token = t;\n \t}\n       else\n \t{\n-\t  t = format_lex ();\n+\t  t = format_lex (fmt);\n \t  if (t != FMT_ZERO && t != FMT_POSINT)\n \t    {\n-\t      error = nonneg_required;\n+\t      fmt->error = nonneg_required;\n \t      goto finished;\n \t    }\n \n-\t  tail->u.integer.m = value;\n+\t  tail->u.integer.m = fmt->value;\n \t}\n \n       if (tail->u.integer.w != 0 && tail->u.integer.m > tail->u.integer.w)\n \t{\n-\t  error = \"Minimum digits exceeds field width\";\n+\t  fmt->error = \"Minimum digits exceeds field width\";\n \t  goto finished;\n \t}\n \n       break;\n \n     default:\n-      error = unexpected_element;\n+      fmt->error = unexpected_element;\n       goto finished;\n     }\n \n   /* Between a descriptor and what comes next */\n  between_desc:\n-  t = format_lex ();\n+  t = format_lex (fmt);\n   switch (t)\n     {\n     case FMT_COMMA:\n@@ -846,7 +841,7 @@ parse_format_list (void)\n       goto finished;\n \n     case FMT_SLASH:\n-      get_fnode (&head, &tail, FMT_SLASH);\n+      get_fnode (fmt, &head, &tail, FMT_SLASH);\n       tail->repeat = 1;\n \n       /* Fall Through */\n@@ -855,7 +850,7 @@ parse_format_list (void)\n       goto optional_comma;\n \n     case FMT_END:\n-      error = unexpected_end;\n+      fmt->error = unexpected_end;\n       goto finished;\n \n     default:\n@@ -866,7 +861,7 @@ parse_format_list (void)\n   /* Optional comma is a weird between state where we've just finished\n      reading a colon, slash or P descriptor. */\n  optional_comma:\n-  t = format_lex ();\n+  t = format_lex (fmt);\n   switch (t)\n     {\n     case FMT_COMMA:\n@@ -876,7 +871,7 @@ parse_format_list (void)\n       goto finished;\n \n     default:\t\t\t/* Assume that we have another format item */\n-      saved_token = t;\n+      fmt->saved_token = t;\n       break;\n     }\n \n@@ -892,30 +887,28 @@ parse_format_list (void)\n  * is assumed to happen at parse time, and the current location of the\n  * parser is shown.\n  *\n- * After freeing any dynamically allocated fnodes, generate a message\n- * showing where the problem is.  We take extra care to print only the\n- * relevant part of the format if it is longer than a standard 80\n- * column display. */\n+ * We generate a message showing where the problem is.  We take extra\n+ * care to print only the relevant part of the format if it is longer\n+ * than a standard 80 column display. */\n \n void\n-format_error (fnode * f, const char *message)\n+format_error (st_parameter_dt *dtp, const fnode *f, const char *message)\n {\n   int width, i, j, offset;\n   char *p, buffer[300];\n+  format_data *fmt = dtp->u.p.fmt;\n \n   if (f != NULL)\n-    format_string = f->source;\n-\n-  free_fnodes ();\n+    fmt->format_string = f->source;\n \n   st_sprintf (buffer, \"%s\\n\", message);\n \n-  j = format_string - ioparm.format;\n+  j = fmt->format_string - dtp->format;\n \n   offset = (j > 60) ? j - 40 : 0;\n \n   j -= offset;\n-  width = ioparm.format_len - offset;\n+  width = dtp->format_len - offset;\n \n   if (width > 80)\n     width = 80;\n@@ -924,7 +917,7 @@ format_error (fnode * f, const char *message)\n \n   p = strchr (buffer, '\\0');\n \n-  memcpy (p, ioparm.format + offset, width);\n+  memcpy (p, dtp->format + offset, width);\n \n   p += width;\n   *p++ = '\\n';\n@@ -937,42 +930,49 @@ format_error (fnode * f, const char *message)\n   *p++ = '^';\n   *p = '\\0';\n \n-  generate_error (ERROR_FORMAT, buffer);\n+  generate_error (&dtp->common, ERROR_FORMAT, buffer);\n }\n \n \n /* parse_format()-- Parse a format string.  */\n \n void\n-parse_format (void)\n+parse_format (st_parameter_dt *dtp)\n {\n-  format_string = ioparm.format;\n-  format_string_len = ioparm.format_len;\n+  format_data *fmt;\n \n-  saved_token = FMT_NONE;\n-  error = NULL;\n+  dtp->u.p.fmt = fmt = get_mem (sizeof (format_data));\n+  fmt->format_string = dtp->format;\n+  fmt->format_string_len = dtp->format_len;\n+\n+  fmt->string = NULL;\n+  fmt->saved_token = FMT_NONE;\n+  fmt->error = NULL;\n+  fmt->value = 0;\n \n   /* Initialize variables used during traversal of the tree */\n \n-  reversion_ok = 0;\n-  g.reversion_flag = 0;\n-  saved_format = NULL;\n+  fmt->reversion_ok = 0;\n+  fmt->saved_format = NULL;\n \n   /* Allocate the first format node as the root of the tree */\n \n-  avail = array;\n+  fmt->last = &fmt->array;\n+  fmt->last->next = NULL;\n+  fmt->avail = &fmt->array.array[0];\n \n-  avail->format = FMT_LPAREN;\n-  avail->repeat = 1;\n-  avail++;\n+  memset (fmt->avail, 0, sizeof (*fmt->avail));\n+  fmt->avail->format = FMT_LPAREN;\n+  fmt->avail->repeat = 1;\n+  fmt->avail++;\n \n-  if (format_lex () == FMT_LPAREN)\n-    array[0].u.child = parse_format_list ();\n+  if (format_lex (fmt) == FMT_LPAREN)\n+    fmt->array.array[0].u.child = parse_format_list (dtp);\n   else\n-    error = \"Missing initial left parenthesis in format\";\n+    fmt->error = \"Missing initial left parenthesis in format\";\n \n-  if (error)\n-    format_error (NULL, error);\n+  if (fmt->error)\n+    format_error (dtp, NULL, fmt->error);\n }\n \n \n@@ -984,22 +984,23 @@ parse_format (void)\n  * level. */\n \n static void\n-revert (void)\n+revert (st_parameter_dt *dtp)\n {\n   fnode *f, *r;\n+  format_data *fmt = dtp->u.p.fmt;\n \n-  g.reversion_flag = 1;\n+  dtp->u.p.reversion_flag = 1;\n \n   r = NULL;\n \n-  for (f = array[0].u.child; f; f = f->next)\n+  for (f = fmt->array.array[0].u.child; f; f = f->next)\n     if (f->format == FMT_LPAREN)\n       r = f;\n \n   /* If r is NULL because no node was found, the whole tree will be used */\n \n-  array[0].current = r;\n-  array[0].count = 0;\n+  fmt->array.array[0].current = r;\n+  fmt->array.array[0].count = 0;\n }\n \n \n@@ -1008,10 +1009,10 @@ revert (void)\n  * Parenthesis nodes are incremented after the list has been\n  * exhausted, other nodes are incremented before they are returned. */\n \n-static fnode *\n+static const fnode *\n next_format0 (fnode * f)\n {\n-  fnode *r;\n+  const fnode *r;\n \n   if (f == NULL)\n     return NULL;\n@@ -1053,53 +1054,52 @@ next_format0 (fnode * f)\n  * are no more data descriptors to return (which is an error\n  * condition). */\n \n-fnode *\n-next_format (void)\n+const fnode *\n+next_format (st_parameter_dt *dtp)\n {\n   format_token t;\n-  fnode *f;\n+  const fnode *f;\n+  format_data *fmt = dtp->u.p.fmt;\n \n-  if (saved_format != NULL)\n+  if (fmt->saved_format != NULL)\n     {\t\t\t\t/* Deal with a pushed-back format node */\n-      f = saved_format;\n-      saved_format = NULL;\n+      f = fmt->saved_format;\n+      fmt->saved_format = NULL;\n       goto done;\n     }\n \n-  f = next_format0 (&array[0]);\n+  f = next_format0 (&fmt->array.array[0]);\n   if (f == NULL)\n     {\n-      if (!reversion_ok)\n-\t{\n-\t  return NULL;\n-\t}\n+      if (!fmt->reversion_ok)\n+\treturn NULL;\n \n-      reversion_ok = 0;\n-      revert ();\n+      fmt->reversion_ok = 0;\n+      revert (dtp);\n \n-      f = next_format0 (&array[0]);\n+      f = next_format0 (&fmt->array.array[0]);\n       if (f == NULL)\n \t{\n-\t  format_error (NULL, reversion_error);\n+\t  format_error (dtp, NULL, reversion_error);\n \t  return NULL;\n \t}\n \n       /* Push the first reverted token and return a colon node in case\n        * there are no more data items. */\n \n-      saved_format = f;\n+      fmt->saved_format = f;\n       return &colon_node;\n     }\n \n   /* If this is a data edit descriptor, then reversion has become OK. */\n  done:\n   t = f->format;\n \n-  if (!reversion_ok &&\n+  if (!fmt->reversion_ok &&\n       (t == FMT_I || t == FMT_B || t == FMT_O || t == FMT_Z || t == FMT_F ||\n        t == FMT_E || t == FMT_EN || t == FMT_ES || t == FMT_G || t == FMT_L ||\n        t == FMT_A || t == FMT_D))\n-    reversion_ok = 1;\n+    fmt->reversion_ok = 1;\n   return f;\n }\n \n@@ -1112,9 +1112,9 @@ next_format (void)\n  * which calls the library back with the data item (or not). */\n \n void\n-unget_format (fnode * f)\n+unget_format (st_parameter_dt *dtp, const fnode *f)\n {\n-  saved_format = f;\n+  dtp->u.p.fmt->saved_format = f;\n }\n \n \n@@ -1272,14 +1272,14 @@ dump_format (void)\n \n \n void\n-next_test (void)\n+next_test (st_parameter_dt *dtp)\n {\n   fnode *f;\n   int i;\n \n   for (i = 0; i < 20; i++)\n     {\n-      f = next_format ();\n+      f = next_format (dtp);\n       if (f == NULL)\n \t{\n \t  st_printf (\"No format!\\n\");"}, {"sha": "bccd5a185bb693e60c9106bae37fb14a49f75ee7", "filename": "libgfortran/io/inquire.c", "status": "modified", "additions": 117, "deletions": 115, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Finquire.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Finquire.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Finquire.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002-2003 Free Software Foundation, Inc.\n+/* Copyright (C) 2002, 2003, 2005 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n@@ -41,31 +41,28 @@ static const char undefined[] = \"UNDEFINED\";\n /* inquire_via_unit()-- Inquiry via unit number.  The unit might not exist. */\n \n static void\n-inquire_via_unit (gfc_unit * u)\n+inquire_via_unit (st_parameter_inquire *iqp, gfc_unit * u)\n {\n   const char *p;\n+  GFC_INTEGER_4 cf = iqp->common.flags;\n \n-  if (ioparm.exist != NULL)\n-  {\n-    if (ioparm.unit >= 0)\n-      *ioparm.exist = 1;\n-    else\n-      *ioparm.exist = 0;\n-  }\n+  if ((cf & IOPARM_INQUIRE_HAS_EXIST) != 0)\n+    *iqp->exist = iqp->common.unit >= 0;\n \n-  if (ioparm.opened != NULL)\n-    *ioparm.opened = (u != NULL);\n+  if ((cf & IOPARM_INQUIRE_HAS_OPENED) != 0)\n+    *iqp->opened = (u != NULL);\n \n-  if (ioparm.number != NULL)\n-    *ioparm.number = (u != NULL) ? u->unit_number : -1;\n+  if ((cf & IOPARM_INQUIRE_HAS_NUMBER) != 0)\n+    *iqp->number = (u != NULL) ? u->unit_number : -1;\n \n-  if (ioparm.named != NULL)\n-    *ioparm.named = (u != NULL && u->flags.status != STATUS_SCRATCH);\n+  if ((cf & IOPARM_INQUIRE_HAS_NAMED) != 0)\n+    *iqp->named = (u != NULL && u->flags.status != STATUS_SCRATCH);\n \n-  if (ioparm.name != NULL && u != NULL && u->flags.status != STATUS_SCRATCH)\n-    fstrcpy (ioparm.name, ioparm.name_len, u->file, u->file_len);\n+  if ((cf & IOPARM_INQUIRE_HAS_NAME) != 0\n+      && u != NULL && u->flags.status != STATUS_SCRATCH)\n+    fstrcpy (iqp->name, iqp->name_len, u->file, u->file_len);\n \n-  if (ioparm.access != NULL)\n+  if ((cf & IOPARM_INQUIRE_HAS_ACCESS) != 0)\n     {\n       if (u == NULL)\n \tp = undefined;\n@@ -79,13 +76,13 @@ inquire_via_unit (gfc_unit * u)\n \t    p = \"DIRECT\";\n \t    break;\n \t  default:\n-\t    internal_error (\"inquire_via_unit(): Bad access\");\n+\t    internal_error (&iqp->common, \"inquire_via_unit(): Bad access\");\n \t  }\n \n-      cf_strcpy (ioparm.access, ioparm.access_len, p);\n+      cf_strcpy (iqp->access, iqp->access_len, p);\n     }\n \n-  if (ioparm.sequential != NULL)\n+  if ((cf & IOPARM_INQUIRE_HAS_SEQUENTIAL) != 0)\n     {\n       if (u == NULL)\n \tp = inquire_sequential (NULL, 0);\n@@ -98,18 +95,18 @@ inquire_via_unit (gfc_unit * u)\n             p = inquire_sequential (u->file, u->file_len);\n \t}\n \n-      cf_strcpy (ioparm.sequential, ioparm.sequential_len, p);\n+      cf_strcpy (iqp->sequential, iqp->sequential_len, p);\n     }\n \n-  if (ioparm.direct != NULL)\n+  if ((cf & IOPARM_INQUIRE_HAS_DIRECT) != 0)\n     {\n       p = (u == NULL) ? inquire_direct (NULL, 0) :\n \tinquire_direct (u->file, u->file_len);\n \n-      cf_strcpy (ioparm.direct, ioparm.direct_len, p);\n+      cf_strcpy (iqp->direct, iqp->direct_len, p);\n     }\n \n-  if (ioparm.form != NULL)\n+  if ((cf & IOPARM_INQUIRE_HAS_FORM) != 0)\n     {\n       if (u == NULL)\n \tp = undefined;\n@@ -123,55 +120,55 @@ inquire_via_unit (gfc_unit * u)\n \t    p = \"UNFORMATTED\";\n \t    break;\n \t  default:\n-\t    internal_error (\"inquire_via_unit(): Bad form\");\n+\t    internal_error (&iqp->common, \"inquire_via_unit(): Bad form\");\n \t  }\n \n-      cf_strcpy (ioparm.form, ioparm.form_len, p);\n+      cf_strcpy (iqp->form, iqp->form_len, p);\n     }\n \n-  if (ioparm.formatted != NULL)\n+  if ((cf & IOPARM_INQUIRE_HAS_FORMATTED) != 0)\n     {\n       p = (u == NULL) ? inquire_formatted (NULL, 0) :\n \tinquire_formatted (u->file, u->file_len);\n \n-      cf_strcpy (ioparm.formatted, ioparm.formatted_len, p);\n+      cf_strcpy (iqp->formatted, iqp->formatted_len, p);\n     }\n \n-  if (ioparm.unformatted != NULL)\n+  if ((cf & IOPARM_INQUIRE_HAS_UNFORMATTED) != 0)\n     {\n       p = (u == NULL) ? inquire_unformatted (NULL, 0) :\n \tinquire_unformatted (u->file, u->file_len);\n \n-      cf_strcpy (ioparm.unformatted, ioparm.unformatted_len, p);\n+      cf_strcpy (iqp->unformatted, iqp->unformatted_len, p);\n     }\n \n-  if (ioparm.recl_out != NULL)\n-    *ioparm.recl_out = (u != NULL) ? u->recl : 0;\n+  if ((cf & IOPARM_INQUIRE_HAS_RECL_OUT) != 0)\n+    *iqp->recl_out = (u != NULL) ? u->recl : 0;\n \n-  if (ioparm.nextrec != NULL)\n-    *ioparm.nextrec = (u != NULL) ? u->last_record + 1 : 0;\n+  if ((cf & IOPARM_INQUIRE_HAS_NEXTREC) != 0)\n+    *iqp->nextrec = (u != NULL) ? u->last_record + 1 : 0;\n \n-  if (ioparm.blank != NULL)\n+  if ((cf & IOPARM_INQUIRE_HAS_BLANK) != 0)\n     {\n       if (u == NULL)\n \tp = undefined;\n       else\n \tswitch (u->flags.blank)\n \t  {\n \t  case BLANK_NULL:\n-          p = \"NULL\";\n+\t    p = \"NULL\";\n \t    break;\n \t  case BLANK_ZERO:\n \t    p = \"ZERO\";\n \t    break;\n \t  default:\n-\t    internal_error (\"inquire_via_unit(): Bad blank\");\n+\t    internal_error (&iqp->common, \"inquire_via_unit(): Bad blank\");\n \t  }\n \n-      cf_strcpy (ioparm.blank, ioparm.blank_len, p);\n+      cf_strcpy (iqp->blank, iqp->blank_len, p);\n     }\n \n-  if (ioparm.position != NULL)\n+  if ((cf & IOPARM_INQUIRE_HAS_POSITION) != 0)\n     {\n       if (u == NULL || u->flags.access == ACCESS_DIRECT)\n         p = undefined;\n@@ -194,10 +191,10 @@ inquire_via_unit (gfc_unit * u)\n                p = \"ASIS\";\n                break;\n           }\n-      cf_strcpy (ioparm.position, ioparm.position_len, p);\n+      cf_strcpy (iqp->position, iqp->position_len, p);\n     }\n \n-  if (ioparm.action != NULL)\n+  if ((cf & IOPARM_INQUIRE_HAS_ACTION) != 0)\n     {\n       if (u == NULL)\n \tp = undefined;\n@@ -214,37 +211,37 @@ inquire_via_unit (gfc_unit * u)\n \t    p = \"READWRITE\";\n \t    break;\n \t  default:\n-\t    internal_error (\"inquire_via_unit(): Bad action\");\n+\t    internal_error (&iqp->common, \"inquire_via_unit(): Bad action\");\n \t  }\n \n-      cf_strcpy (ioparm.action, ioparm.action_len, p);\n+      cf_strcpy (iqp->action, iqp->action_len, p);\n     }\n \n-  if (ioparm.read != NULL)\n+  if ((cf & IOPARM_INQUIRE_HAS_READ) != 0)\n     {\n       p = (u == NULL) ? inquire_read (NULL, 0) :\n \tinquire_read (u->file, u->file_len);\n \n-      cf_strcpy (ioparm.read, ioparm.read_len, p);\n+      cf_strcpy (iqp->read, iqp->read_len, p);\n     }\n \n-  if (ioparm.write != NULL)\n+  if ((cf & IOPARM_INQUIRE_HAS_WRITE) != 0)\n     {\n       p = (u == NULL) ? inquire_write (NULL, 0) :\n \tinquire_write (u->file, u->file_len);\n \n-      cf_strcpy (ioparm.write, ioparm.write_len, p);\n+      cf_strcpy (iqp->write, iqp->write_len, p);\n     }\n \n-  if (ioparm.readwrite != NULL)\n+  if ((cf & IOPARM_INQUIRE_HAS_READWRITE) != 0)\n     {\n       p = (u == NULL) ? inquire_readwrite (NULL, 0) :\n \tinquire_readwrite (u->file, u->file_len);\n \n-      cf_strcpy (ioparm.readwrite, ioparm.readwrite_len, p);\n+      cf_strcpy (iqp->readwrite, iqp->readwrite_len, p);\n     }\n \n-  if (ioparm.delim != NULL)\n+  if ((cf & IOPARM_INQUIRE_HAS_DELIM) != 0)\n     {\n       if (u == NULL || u->flags.form != FORM_FORMATTED)\n \tp = undefined;\n@@ -261,13 +258,13 @@ inquire_via_unit (gfc_unit * u)\n \t    p = \"APOSTROPHE\";\n \t    break;\n \t  default:\n-\t    internal_error (\"inquire_via_unit(): Bad delim\");\n+\t    internal_error (&iqp->common, \"inquire_via_unit(): Bad delim\");\n \t  }\n \n-      cf_strcpy (ioparm.delim, ioparm.delim_len, p);\n+      cf_strcpy (iqp->delim, iqp->delim_len, p);\n     }\n \n-  if (ioparm.pad != NULL)\n+  if ((cf & IOPARM_INQUIRE_HAS_PAD) != 0)\n     {\n       if (u == NULL || u->flags.form != FORM_FORMATTED)\n \tp = undefined;\n@@ -281,10 +278,10 @@ inquire_via_unit (gfc_unit * u)\n \t    p = \"YES\";\n \t    break;\n \t  default:\n-\t    internal_error (\"inquire_via_unit(): Bad pad\");\n+\t    internal_error (&iqp->common, \"inquire_via_unit(): Bad pad\");\n \t  }\n \n-      cf_strcpy (ioparm.pad, ioparm.pad_len, p);\n+      cf_strcpy (iqp->pad, iqp->pad_len, p);\n     }\n }\n \n@@ -293,120 +290,125 @@ inquire_via_unit (gfc_unit * u)\n  * only used if the filename is *not* connected to a unit number. */\n \n static void\n-inquire_via_filename (void)\n+inquire_via_filename (st_parameter_inquire *iqp)\n {\n   const char *p;\n+  GFC_INTEGER_4 cf = iqp->common.flags;\n \n-  if (ioparm.exist != NULL)\n-    *ioparm.exist = file_exists ();\n+  if ((cf & IOPARM_INQUIRE_HAS_EXIST) != 0)\n+    *iqp->exist = file_exists (iqp->file, iqp->file_len);\n \n-  if (ioparm.opened != NULL)\n-    *ioparm.opened = 0;\n+  if ((cf & IOPARM_INQUIRE_HAS_OPENED) != 0)\n+    *iqp->opened = 0;\n \n-  if (ioparm.number != NULL)\n-    *ioparm.number = -1;\n+  if ((cf & IOPARM_INQUIRE_HAS_NUMBER) != 0)\n+    *iqp->number = -1;\n \n-  if (ioparm.named != NULL)\n-    *ioparm.named = 1;\n+  if ((cf & IOPARM_INQUIRE_HAS_NAMED) != 0)\n+    *iqp->named = 1;\n \n-  if (ioparm.name != NULL)\n-    fstrcpy (ioparm.name, ioparm.name_len, ioparm.file, ioparm.file_len);\n+  if ((cf & IOPARM_INQUIRE_HAS_NAME) != 0)\n+    fstrcpy (iqp->name, iqp->name_len, iqp->file, iqp->file_len);\n \n-  if (ioparm.access != NULL)\n-    cf_strcpy (ioparm.access, ioparm.access_len, undefined);\n+  if ((cf & IOPARM_INQUIRE_HAS_ACCESS) != 0)\n+    cf_strcpy (iqp->access, iqp->access_len, undefined);\n \n-  if (ioparm.sequential != NULL)\n+  if ((cf & IOPARM_INQUIRE_HAS_SEQUENTIAL) != 0)\n     {\n-      p = inquire_sequential (ioparm.file, ioparm.file_len);\n-      cf_strcpy (ioparm.sequential, ioparm.sequential_len, p);\n+      p = inquire_sequential (iqp->file, iqp->file_len);\n+      cf_strcpy (iqp->sequential, iqp->sequential_len, p);\n     }\n \n-  if (ioparm.direct != NULL)\n+  if ((cf & IOPARM_INQUIRE_HAS_DIRECT) != 0)\n     {\n-      p = inquire_direct (ioparm.file, ioparm.file_len);\n-      cf_strcpy (ioparm.direct, ioparm.direct_len, p);\n+      p = inquire_direct (iqp->file, iqp->file_len);\n+      cf_strcpy (iqp->direct, iqp->direct_len, p);\n     }\n \n-  if (ioparm.form != NULL)\n-    cf_strcpy (ioparm.form, ioparm.form_len, undefined);\n+  if ((cf & IOPARM_INQUIRE_HAS_FORM) != 0)\n+    cf_strcpy (iqp->form, iqp->form_len, undefined);\n \n-  if (ioparm.formatted != NULL)\n+  if ((cf & IOPARM_INQUIRE_HAS_FORMATTED) != 0)\n     {\n-      p = inquire_formatted (ioparm.file, ioparm.file_len);\n-      cf_strcpy (ioparm.formatted, ioparm.formatted_len, p);\n+      p = inquire_formatted (iqp->file, iqp->file_len);\n+      cf_strcpy (iqp->formatted, iqp->formatted_len, p);\n     }\n \n-  if (ioparm.unformatted != NULL)\n+  if ((cf & IOPARM_INQUIRE_HAS_UNFORMATTED) != 0)\n     {\n-      p = inquire_unformatted (ioparm.file, ioparm.file_len);\n-      cf_strcpy (ioparm.unformatted, ioparm.unformatted_len, p);\n+      p = inquire_unformatted (iqp->file, iqp->file_len);\n+      cf_strcpy (iqp->unformatted, iqp->unformatted_len, p);\n     }\n \n-  if (ioparm.recl_out != NULL)\n-    *ioparm.recl_out = 0;\n+  if ((cf & IOPARM_INQUIRE_HAS_RECL_OUT) != 0)\n+    *iqp->recl_out = 0;\n \n-  if (ioparm.nextrec != NULL)\n-    *ioparm.nextrec = 0;\n+  if ((cf & IOPARM_INQUIRE_HAS_NEXTREC) != 0)\n+    *iqp->nextrec = 0;\n \n-  if (ioparm.blank != NULL)\n-    cf_strcpy (ioparm.blank, ioparm.blank_len, undefined);\n+  if ((cf & IOPARM_INQUIRE_HAS_BLANK) != 0)\n+    cf_strcpy (iqp->blank, iqp->blank_len, undefined);\n \n-  if (ioparm.position != NULL)\n-    cf_strcpy (ioparm.position, ioparm.position_len, undefined);\n+  if ((cf & IOPARM_INQUIRE_HAS_POSITION) != 0)\n+    cf_strcpy (iqp->position, iqp->position_len, undefined);\n \n-  if (ioparm.access != NULL)\n-    cf_strcpy (ioparm.access, ioparm.access_len, undefined);\n+  if ((cf & IOPARM_INQUIRE_HAS_ACCESS) != 0)\n+    cf_strcpy (iqp->access, iqp->access_len, undefined);\n \n-  if (ioparm.read != NULL)\n+  if ((cf & IOPARM_INQUIRE_HAS_READ) != 0)\n     {\n-      p = inquire_read (ioparm.file, ioparm.file_len);\n-      cf_strcpy (ioparm.read, ioparm.read_len, p);\n+      p = inquire_read (iqp->file, iqp->file_len);\n+      cf_strcpy (iqp->read, iqp->read_len, p);\n     }\n \n-  if (ioparm.write != NULL)\n+  if ((cf & IOPARM_INQUIRE_HAS_WRITE) != 0)\n     {\n-      p = inquire_write (ioparm.file, ioparm.file_len);\n-      cf_strcpy (ioparm.write, ioparm.write_len, p);\n+      p = inquire_write (iqp->file, iqp->file_len);\n+      cf_strcpy (iqp->write, iqp->write_len, p);\n     }\n \n-  if (ioparm.readwrite != NULL)\n+  if ((cf & IOPARM_INQUIRE_HAS_READWRITE) != 0)\n     {\n-      p = inquire_read (ioparm.file, ioparm.file_len);\n-      cf_strcpy (ioparm.readwrite, ioparm.readwrite_len, p);\n+      p = inquire_read (iqp->file, iqp->file_len);\n+      cf_strcpy (iqp->readwrite, iqp->readwrite_len, p);\n     }\n \n-  if (ioparm.delim != NULL)\n-    cf_strcpy (ioparm.delim, ioparm.delim_len, undefined);\n-\n-  if (ioparm.pad != NULL)\n-    cf_strcpy (ioparm.pad, ioparm.pad_len, undefined);\n+  if ((cf & IOPARM_INQUIRE_HAS_DELIM) != 0)\n+    cf_strcpy (iqp->delim, iqp->delim_len, undefined);\n \n+  if ((cf & IOPARM_INQUIRE_HAS_PAD) != 0)\n+    cf_strcpy (iqp->pad, iqp->pad_len, undefined);\n }\n \n \n /* Library entry point for the INQUIRE statement (non-IOLENGTH\n    form).  */\n \n-extern void st_inquire (void);\n+extern void st_inquire (st_parameter_inquire *);\n export_proto(st_inquire);\n \n void\n-st_inquire (void)\n+st_inquire (st_parameter_inquire *iqp)\n {\n   gfc_unit *u;\n \n-  library_start ();\n+  library_start (&iqp->common);\n \n-  if (ioparm.file == NULL)\n-    inquire_via_unit (find_unit (ioparm.unit));\n+  if ((iqp->common.flags & IOPARM_INQUIRE_HAS_FILE) == 0)\n+    {\n+      u = find_unit (iqp->common.unit);\n+      inquire_via_unit (iqp, u);\n+    }\n   else\n     {\n-      u = find_file ();\n+      u = find_file (iqp->file, iqp->file_len);\n       if (u == NULL)\n-\tinquire_via_filename ();\n+\tinquire_via_filename (iqp);\n       else\n-\tinquire_via_unit (u);\n+\tinquire_via_unit (iqp, u);\n     }\n+  if (u != NULL)\n+    unlock_unit (u);\n \n   library_end ();\n }"}, {"sha": "f080c4607adcc2b4103bcaeeec7277fcc6cda89a", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 319, "deletions": 155, "changes": 474, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -32,6 +32,11 @@ Boston, MA 02110-1301, USA.  */\n \n #include <setjmp.h>\n #include \"libgfortran.h\"\n+#ifdef HAVE_PRAGMA_WEAK\n+/* Used by gthr.h.  */\n+#define SUPPORTS_WEAK 1\n+#endif\n+#include <gthr.h>\n \n #define DEFAULT_TEMPDIR \"/tmp\"\n \n@@ -48,6 +53,8 @@ typedef enum\n { SUCCESS = 1, FAILURE }\n try;\n \n+struct st_parameter_dt;\n+\n typedef struct stream\n {\n   char *(*alloc_w_at) (struct stream *, int *, gfc_offset);\n@@ -202,83 +209,213 @@ typedef enum\n {READING, WRITING}\n unit_mode;\n \n-/* Statement parameters.  These are all the things that can appear in\n-   an I/O statement.  Some are inputs and some are outputs, but none\n-   are both.  All of these values are initially zeroed and are zeroed\n-   at the end of a library statement.  The relevant values need to be\n-   set before entry to an I/O statement.  This structure needs to be\n-   duplicated by the back end.  */\n+#define CHARACTER1(name) \\\n+\t      char * name; \\\n+\t      gfc_charlen_type name ## _len\n+#define CHARACTER2(name) \\\n+\t      gfc_charlen_type name ## _len; \\\n+\t      char * name\n+\n+#define IOPARM_LIBRETURN_MASK\t\t(3 << 0)\n+#define IOPARM_LIBRETURN_OK\t\t(0 << 0)\n+#define IOPARM_LIBRETURN_ERROR\t\t(1 << 0)\n+#define IOPARM_LIBRETURN_END\t\t(2 << 0)\n+#define IOPARM_LIBRETURN_EOR\t\t(3 << 0)\n+#define IOPARM_ERR\t\t\t(1 << 2)\n+#define IOPARM_END\t\t\t(1 << 3)\n+#define IOPARM_EOR\t\t\t(1 << 4)\n+#define IOPARM_HAS_IOSTAT\t\t(1 << 5)\n+#define IOPARM_HAS_IOMSG\t\t(1 << 6)\n+\n+#define IOPARM_COMMON_MASK\t\t((1 << 7) - 1)\n+\n+typedef struct st_parameter_common\n+{\n+  GFC_INTEGER_4 flags;\n+  GFC_INTEGER_4 unit;\n+  const char *filename;\n+  GFC_INTEGER_4 line;\n+  CHARACTER2 (iomsg);\n+  GFC_INTEGER_4 *iostat;\n+}\n+st_parameter_common;\n+\n+#define IOPARM_OPEN_HAS_RECL_IN\t\t(1 << 7)\n+#define IOPARM_OPEN_HAS_FILE\t\t(1 << 8)\n+#define IOPARM_OPEN_HAS_STATUS\t\t(1 << 9)\n+#define IOPARM_OPEN_HAS_ACCESS\t\t(1 << 10)\n+#define IOPARM_OPEN_HAS_FORM\t\t(1 << 11)\n+#define IOPARM_OPEN_HAS_BLANK\t\t(1 << 12)\n+#define IOPARM_OPEN_HAS_POSITION\t(1 << 13)\n+#define IOPARM_OPEN_HAS_ACTION\t\t(1 << 14)\n+#define IOPARM_OPEN_HAS_DELIM\t\t(1 << 15)\n+#define IOPARM_OPEN_HAS_PAD\t\t(1 << 16)\n \n typedef struct\n {\n-  GFC_INTEGER_4 unit;\n-  GFC_INTEGER_4 err, end, eor, list_format; /* These are flags, not values.  */\n+  st_parameter_common common;\n+  GFC_INTEGER_4 recl_in;\n+  CHARACTER2 (file);\n+  CHARACTER1 (status);\n+  CHARACTER2 (access);\n+  CHARACTER1 (form);\n+  CHARACTER2 (blank);\n+  CHARACTER1 (position);\n+  CHARACTER2 (action);\n+  CHARACTER1 (delim);\n+  CHARACTER2 (pad);\n+}\n+st_parameter_open;\n \n-/* Return values from library statements.  These are returned only if\n-   the labels are specified in the statement itself and the condition\n-   occurs.  In most cases, none of the labels are specified and the\n-   return value does not have to be checked.  Must be consistent with\n-   the front end.  */\n+#define IOPARM_CLOSE_HAS_STATUS\t\t(1 << 7)\n \n-  enum\n-  {\n-    LIBRARY_OK = 0,\n-    LIBRARY_ERROR,\n-    LIBRARY_END,\n-    LIBRARY_EOR\n-  }\n-  library_return;\n+typedef struct\n+{\n+  st_parameter_common common;\n+  CHARACTER1 (status);\n+}\n+st_parameter_close;\n \n-  GFC_INTEGER_4 *iostat, *exist, *opened, *number, *named;\n-  GFC_INTEGER_4 rec;\n-  GFC_INTEGER_4 *nextrec, *size;\n+typedef struct\n+{\n+  st_parameter_common common;\n+}\n+st_parameter_filepos;\n+\n+#define IOPARM_INQUIRE_HAS_EXIST\t(1 << 7)\n+#define IOPARM_INQUIRE_HAS_OPENED\t(1 << 8)\n+#define IOPARM_INQUIRE_HAS_NUMBER\t(1 << 9)\n+#define IOPARM_INQUIRE_HAS_NAMED\t(1 << 10)\n+#define IOPARM_INQUIRE_HAS_NEXTREC\t(1 << 11)\n+#define IOPARM_INQUIRE_HAS_RECL_OUT\t(1 << 12)\n+#define IOPARM_INQUIRE_HAS_FILE\t\t(1 << 13)\n+#define IOPARM_INQUIRE_HAS_ACCESS\t(1 << 14)\n+#define IOPARM_INQUIRE_HAS_FORM\t\t(1 << 15)\n+#define IOPARM_INQUIRE_HAS_BLANK\t(1 << 16)\n+#define IOPARM_INQUIRE_HAS_POSITION\t(1 << 17)\n+#define IOPARM_INQUIRE_HAS_ACTION\t(1 << 18)\n+#define IOPARM_INQUIRE_HAS_DELIM\t(1 << 19)\n+#define IOPARM_INQUIRE_HAS_PAD\t\t(1 << 20)\n+#define IOPARM_INQUIRE_HAS_NAME\t\t(1 << 21)\n+#define IOPARM_INQUIRE_HAS_SEQUENTIAL\t(1 << 22)\n+#define IOPARM_INQUIRE_HAS_DIRECT\t(1 << 23)\n+#define IOPARM_INQUIRE_HAS_FORMATTED\t(1 << 24)\n+#define IOPARM_INQUIRE_HAS_UNFORMATTED\t(1 << 25)\n+#define IOPARM_INQUIRE_HAS_READ\t\t(1 << 26)\n+#define IOPARM_INQUIRE_HAS_WRITE\t(1 << 27)\n+#define IOPARM_INQUIRE_HAS_READWRITE\t(1 << 28)\n \n-  GFC_INTEGER_4 recl_in;\n-  GFC_INTEGER_4 *recl_out;\n-\n-  GFC_INTEGER_4 *iolength;\n-\n-#define CHARACTER(name) \\\n-              char * name; \\\n-              gfc_charlen_type name ## _len\n-  CHARACTER (file);\n-  CHARACTER (status);\n-  CHARACTER (access);\n-  CHARACTER (form);\n-  CHARACTER (blank);\n-  CHARACTER (position);\n-  CHARACTER (action);\n-  CHARACTER (delim);\n-  CHARACTER (pad);\n-  CHARACTER (format);\n-  CHARACTER (advance);\n-  CHARACTER (name);\n-  CHARACTER (internal_unit);\n+typedef struct\n+{\n+  st_parameter_common common;\n+  GFC_INTEGER_4 *exist, *opened, *number, *named;\n+  GFC_INTEGER_4 *nextrec, *recl_out;\n+  CHARACTER1 (file);\n+  CHARACTER2 (access);\n+  CHARACTER1 (form);\n+  CHARACTER2 (blank);\n+  CHARACTER1 (position);\n+  CHARACTER2 (action);\n+  CHARACTER1 (delim);\n+  CHARACTER2 (pad);\n+  CHARACTER1 (name);\n+  CHARACTER2 (sequential);\n+  CHARACTER1 (direct);\n+  CHARACTER2 (formatted);\n+  CHARACTER1 (unformatted);\n+  CHARACTER2 (read);\n+  CHARACTER1 (write);\n+  CHARACTER2 (readwrite);\n+}\n+st_parameter_inquire;\n+\n+struct gfc_unit;\n+struct format_data;\n+\n+#define IOPARM_DT_LIST_FORMAT\t\t\t(1 << 7)\n+#define IOPARM_DT_NAMELIST_READ_MODE\t\t(1 << 8)\n+#define IOPARM_DT_HAS_REC\t\t\t(1 << 9)\n+#define IOPARM_DT_HAS_SIZE\t\t\t(1 << 10)\n+#define IOPARM_DT_HAS_IOLENGTH\t\t\t(1 << 11)\n+#define IOPARM_DT_HAS_FORMAT\t\t\t(1 << 12)\n+#define IOPARM_DT_HAS_ADVANCE\t\t\t(1 << 13)\n+#define IOPARM_DT_HAS_INTERNAL_UNIT\t\t(1 << 14)\n+#define IOPARM_DT_HAS_NAMELIST_NAME\t\t(1 << 15)\n+/* Internal use bit.  */\n+#define IOPARM_DT_IONML_SET\t\t\t(1 << 31)\n+\n+typedef struct st_parameter_dt\n+{\n+  st_parameter_common common;\n+  GFC_INTEGER_4 rec;\n+  GFC_INTEGER_4 *size, *iolength;\n   gfc_array_char *internal_unit_desc;\n-  CHARACTER (sequential);\n-  CHARACTER (direct);\n-  CHARACTER (formatted);\n-  CHARACTER (unformatted);\n-  CHARACTER (read);\n-  CHARACTER (write);\n-  CHARACTER (readwrite);\n-\n-/* namelist related data */\n-  CHARACTER (namelist_name);\n-  GFC_INTEGER_4 namelist_read_mode;\n-\n-  /* iomsg */\n-  CHARACTER (iomsg);\n-\n-#undef CHARACTER\n+  CHARACTER1 (format);\n+  CHARACTER2 (advance);\n+  CHARACTER1 (internal_unit);\n+  CHARACTER2 (namelist_name);\n+  /* Private part of the structure.  The compiler just needs\n+     to reserve enough space.  */\n+  union\n+    {\n+      struct\n+\t{\n+\t  void (*transfer) (struct st_parameter_dt *, bt, void *, int,\n+\t\t\t    size_t, size_t);\n+\t  struct gfc_unit *current_unit;\n+\t  int item_count; /* Item number in a formatted data transfer.  */\n+\t  unit_mode mode;\n+\t  unit_blank blank_status;\n+\t  enum {SIGN_S, SIGN_SS, SIGN_SP} sign_status;\n+\t  int scale_factor;\n+\t  int max_pos; /* Maximum righthand column written to.  */\n+\t  /* Number of skips + spaces to be done for T and X-editing.  */\n+\t  int skips;\n+\t  /* Number of spaces to be done for T and X-editing.  */\n+\t  int pending_spaces;\n+\t  unit_advance advance_status;\n+\t  char reversion_flag; /* Format reversion has occurred.  */\n+\t  char first_item;\n+\t  char seen_dollar;\n+\t  char sf_seen_eor;\n+\t  char eor_condition;\n+\t  char no_leading_blank;\n+\t  char nml_delim;\n+\t  char char_flag;\n+\t  char input_complete;\n+\t  char at_eol;\n+\t  char comma_flag;\n+\t  char last_char;\n+\t  /* A namelist specific flag used in the list directed library\n+\t     to flag that calls are being made from namelist read (eg. to\n+\t     ignore comments or to treat '/' as a terminator)  */\n+\t  char namelist_mode;\n+\t  /* A namelist specific flag used in the list directed library\n+\t     to flag read errors and return, so that an attempt can be\n+\t     made to read a new object name.  */\n+\t  char nml_read_error;\n+\t  /* Storage area for values except for strings.  Must be large\n+\t     enough to hold a complex value (two reals) of the largest\n+\t     kind.  */\n+\t  char value[32];\n+\t  int repeat_count;\n+\t  int saved_length;\n+\t  int saved_used;\n+\t  bt saved_type;\n+\t  char *saved_string;\n+\t  char *scratch;\n+\t  char *line_buffer;\n+\t  struct format_data *fmt;\n+\t  jmp_buf *eof_jump;\n+\t  namelist_info *ionml;\n+\t} p;\n+      char pad[16 * sizeof (char *) + 32 * sizeof (int)];\n+    } u;\n }\n-st_parameter;\n+st_parameter_dt;\n \n-extern st_parameter ioparm;\n-iexport_data_proto(ioparm);\n-\n-extern namelist_info * ionml;\n-internal_proto(ionml);\n+#undef CHARACTER1\n+#undef CHARACTER2\n \n typedef struct\n {\n@@ -316,55 +453,36 @@ typedef struct gfc_unit\n   { NO_ENDFILE, AT_ENDFILE, AFTER_ENDFILE }\n   endfile;\n \n-  unit_mode  mode;\n+  unit_mode mode;\n   unit_flags flags;\n-  \n+\n   /* recl           -- Record length of the file.\n      last_record    -- Last record number read or written\n      maxrec         -- Maximum record number in a direct access file\n      bytes_left     -- Bytes left in current record.  */\n   gfc_offset recl, last_record, maxrec, bytes_left;\n \n+  __gthread_mutex_t lock;\n+  /* Number of threads waiting to acquire this unit's lock.\n+     When non-zero, close_unit doesn't only removes the unit\n+     from the UNIT_ROOT tree, but doesn't free it and the\n+     last of the waiting threads will do that.\n+     This must be either atomically increased/decreased, or\n+     always guarded by UNIT_LOCK.  */\n+  int waiting;\n+  /* Flag set by close_unit if the unit as been closed.\n+     Must be manipulated under unit's lock.  */\n+  int closed;\n+\n   /* For traversing arrays */\n   array_loop_spec *ls;\n   int rank;\n-  \n-  /* Filename is allocated at the end of the structure.  */  \n+\n   int file_len;\n-  char file[1];\n+  char *file;\n }\n gfc_unit;\n \n-/* Global variables.  Putting these in a structure makes it easier to\n-   maintain, particularly with the constraint of a prefix.  */\n-\n-typedef struct\n-{\n-  int in_library;       /* Nonzero if a library call is being processed.  */\n-  int size;\t/* Bytes processed by the current data-transfer statement.  */\n-  gfc_offset max_offset;\t/* Maximum file offset.  */\n-  int item_count;\t/* Item number in a formatted data transfer.  */\n-  int reversion_flag;\t/* Format reversion has occurred.  */\n-  int first_item;\n-\n-  gfc_unit *unit_root;\n-  int seen_dollar;\n-\n-  unit_mode  mode;\n-\n-  unit_blank blank_status;\n-  enum {SIGN_S, SIGN_SS, SIGN_SP} sign_status;\n-  int scale_factor;\n-  jmp_buf eof_jump;\n-}\n-global_t;\n-\n-extern global_t g;\n-internal_proto(g);\n-\n-extern gfc_unit *current_unit;\n-internal_proto(current_unit);\n-\n /* Format tokens.  Only about half of these can be stored in the\n    format nodes.  */\n \n@@ -436,10 +554,7 @@ internal_proto(move_pos_offset);\n extern int compare_files (stream *, stream *);\n internal_proto(compare_files);\n \n-extern stream *init_error_stream (void);\n-internal_proto(init_error_stream);\n-\n-extern stream *open_external (unit_flags *);\n+extern stream *open_external (st_parameter_open *, unit_flags *);\n internal_proto(open_external);\n \n extern stream *open_internal (char *, int);\n@@ -457,9 +572,12 @@ internal_proto(error_stream);\n extern int compare_file_filename (gfc_unit *, const char *, int);\n internal_proto(compare_file_filename);\n \n-extern gfc_unit *find_file (void);\n+extern gfc_unit *find_file (const char *file, gfc_charlen_type file_len);\n internal_proto(find_file);\n \n+extern void flush_all_units (void);\n+internal_proto(flush_all_units);\n+\n extern int stream_at_bof (stream *);\n internal_proto(stream_at_bof);\n \n@@ -469,7 +587,7 @@ internal_proto(stream_at_eof);\n extern int delete_file (gfc_unit *);\n internal_proto(delete_file);\n \n-extern int file_exists (void);\n+extern int file_exists (const char *file, gfc_charlen_type file_len);\n internal_proto(file_exists);\n \n extern const char *inquire_sequential (const char *, int);\n@@ -531,72 +649,83 @@ internal_proto(unpack_filename);\n \n /* unit.c */\n \n-extern void insert_unit (gfc_unit *);\n-internal_proto(insert_unit);\n+/* Maximum file offset, computed at library initialization time.  */\n+extern gfc_offset max_offset;\n+internal_proto(max_offset);\n+\n+/* Unit tree root.  */\n+extern gfc_unit *unit_root;\n+internal_proto(unit_root);\n+\n+extern __gthread_mutex_t unit_lock;\n+internal_proto(unit_lock);\n \n extern int close_unit (gfc_unit *);\n internal_proto(close_unit);\n \n-extern int is_internal_unit (void);\n+extern int is_internal_unit (st_parameter_dt *);\n internal_proto(is_internal_unit);\n \n-extern int is_array_io (void);\n+extern int is_array_io (st_parameter_dt *);\n internal_proto(is_array_io);\n \n extern gfc_unit *find_unit (int);\n internal_proto(find_unit);\n \n-extern gfc_unit *get_unit (int);\n+extern gfc_unit *find_or_create_unit (int);\n+internal_proto(find_unit);\n+\n+extern gfc_unit *get_unit (st_parameter_dt *, int);\n internal_proto(get_unit);\n \n+extern void unlock_unit (gfc_unit *);\n+internal_proto(unlock_unit);\n+\n /* open.c */\n \n extern void test_endfile (gfc_unit *);\n internal_proto(test_endfile);\n \n-extern void new_unit (unit_flags *);\n+extern gfc_unit *new_unit (st_parameter_open *, gfc_unit *, unit_flags *);\n internal_proto(new_unit);\n \n /* format.c */\n \n-extern void parse_format (void);\n+extern void parse_format (st_parameter_dt *);\n internal_proto(parse_format);\n \n-extern fnode *next_format (void);\n+extern const fnode *next_format (st_parameter_dt *);\n internal_proto(next_format);\n \n-extern void unget_format (fnode *);\n+extern void unget_format (st_parameter_dt *, const fnode *);\n internal_proto(unget_format);\n \n-extern void format_error (fnode *, const char *);\n+extern void format_error (st_parameter_dt *, const fnode *, const char *);\n internal_proto(format_error);\n \n-extern void free_fnodes (void);\n-internal_proto(free_fnodes);\n+extern void free_format_data (st_parameter_dt *);\n+internal_proto(free_format_data);\n \n /* transfer.c */\n \n #define SCRATCH_SIZE 300\n \n-extern char scratch[];\n-internal_proto(scratch);\n-\n extern const char *type_name (bt);\n internal_proto(type_name);\n \n-extern void *read_block (int *);\n+extern void *read_block (st_parameter_dt *, int *);\n internal_proto(read_block);\n \n-extern void *write_block (int);\n+extern void *write_block (st_parameter_dt *, int);\n internal_proto(write_block);\n \n-extern gfc_offset next_array_record (array_loop_spec *);\n+extern gfc_offset next_array_record (st_parameter_dt *, array_loop_spec *);\n internal_proto(next_array_record);\n \n-extern gfc_offset init_loop_spec (gfc_array_char *desc, array_loop_spec *ls);\n+extern gfc_offset init_loop_spec (gfc_array_char *, array_loop_spec *);\n internal_proto(init_loop_spec);\n \n-extern void next_record (int);\n+extern void next_record (st_parameter_dt *, int);\n internal_proto(next_record);\n \n /* read.c */\n@@ -607,83 +736,82 @@ internal_proto(set_integer);\n extern GFC_UINTEGER_LARGEST max_value (int, int);\n internal_proto(max_value);\n \n-extern int convert_real (void *, const char *, int);\n+extern int convert_real (st_parameter_dt *, void *, const char *, int);\n internal_proto(convert_real);\n \n-extern void read_a (fnode *, char *, int);\n+extern void read_a (st_parameter_dt *, const fnode *, char *, int);\n internal_proto(read_a);\n \n-extern void read_f (fnode *, char *, int);\n+extern void read_f (st_parameter_dt *, const fnode *, char *, int);\n internal_proto(read_f);\n \n-extern void read_l (fnode *, char *, int);\n+extern void read_l (st_parameter_dt *, const fnode *, char *, int);\n internal_proto(read_l);\n \n-extern void read_x (int);\n+extern void read_x (st_parameter_dt *, int);\n internal_proto(read_x);\n \n-extern void read_radix (fnode *, char *, int, int);\n+extern void read_radix (st_parameter_dt *, const fnode *, char *, int, int);\n internal_proto(read_radix);\n \n-extern void read_decimal (fnode *, char *, int);\n+extern void read_decimal (st_parameter_dt *, const fnode *, char *, int);\n internal_proto(read_decimal);\n \n /* list_read.c */\n \n-extern void list_formatted_read (bt, void *, int, size_t, size_t);\n+extern void list_formatted_read (st_parameter_dt *, bt, void *, int, size_t,\n+\t\t\t\t size_t);\n internal_proto(list_formatted_read);\n \n-extern void finish_list_read (void);\n+extern void finish_list_read (st_parameter_dt *);\n internal_proto(finish_list_read);\n \n-extern void init_at_eol (void);\n-internal_proto(init_at_eol);\n-\n-extern void namelist_read (void);\n+extern void namelist_read (st_parameter_dt *);\n internal_proto(namelist_read);\n \n-extern void namelist_write (void);\n+extern void namelist_write (st_parameter_dt *);\n internal_proto(namelist_write);\n \n /* write.c */\n \n-extern void write_a (fnode *, const char *, int);\n+extern void write_a (st_parameter_dt *, const fnode *, const char *, int);\n internal_proto(write_a);\n \n-extern void write_b (fnode *, const char *, int);\n+extern void write_b (st_parameter_dt *, const fnode *, const char *, int);\n internal_proto(write_b);\n \n-extern void write_d (fnode *, const char *, int);\n+extern void write_d (st_parameter_dt *, const fnode *, const char *, int);\n internal_proto(write_d);\n \n-extern void write_e (fnode *, const char *, int);\n+extern void write_e (st_parameter_dt *, const fnode *, const char *, int);\n internal_proto(write_e);\n \n-extern void write_en (fnode *, const char *, int);\n+extern void write_en (st_parameter_dt *, const fnode *, const char *, int);\n internal_proto(write_en);\n \n-extern void write_es (fnode *, const char *, int);\n+extern void write_es (st_parameter_dt *, const fnode *, const char *, int);\n internal_proto(write_es);\n \n-extern void write_f (fnode *, const char *, int);\n+extern void write_f (st_parameter_dt *, const fnode *, const char *, int);\n internal_proto(write_f);\n \n-extern void write_i (fnode *, const char *, int);\n+extern void write_i (st_parameter_dt *, const fnode *, const char *, int);\n internal_proto(write_i);\n \n-extern void write_l (fnode *, char *, int);\n+extern void write_l (st_parameter_dt *, const fnode *, char *, int);\n internal_proto(write_l);\n \n-extern void write_o (fnode *, const char *, int);\n+extern void write_o (st_parameter_dt *, const fnode *, const char *, int);\n internal_proto(write_o);\n \n-extern void write_x (int, int);\n+extern void write_x (st_parameter_dt *, int, int);\n internal_proto(write_x);\n \n-extern void write_z (fnode *, const char *, int);\n+extern void write_z (st_parameter_dt *, const fnode *, const char *, int);\n internal_proto(write_z);\n \n-extern void list_formatted_write (bt, void *, int, size_t, size_t);\n+extern void list_formatted_write (st_parameter_dt *, bt, void *, int, size_t,\n+\t\t\t\t  size_t);\n internal_proto(list_formatted_write);\n \n /* error.c */\n@@ -697,4 +825,40 @@ internal_proto(size_from_real_kind);\n extern size_t size_from_complex_kind (int);\n internal_proto(size_from_complex_kind);\n \n+/* lock.c */\n+extern void free_ionml (st_parameter_dt *);\n+internal_proto(free_ionml);\n+\n+static inline void\n+inc_waiting_locked (gfc_unit *u)\n+{\n+#ifdef HAVE_SYNC_FETCH_AND_ADD\n+  (void) __sync_fetch_and_add (&u->waiting, 1);\n+#else\n+  u->waiting++;\n+#endif\n+}\n+\n+static inline int\n+predec_waiting_locked (gfc_unit *u)\n+{\n+#ifdef HAVE_SYNC_FETCH_AND_ADD\n+  return __sync_add_and_fetch (&u->waiting, -1);\n+#else\n+  return --u->waiting;\n+#endif\n+}\n+\n+static inline void\n+dec_waiting_unlocked (gfc_unit *u)\n+{\n+#ifdef HAVE_SYNC_FETCH_AND_ADD\n+  (void) __sync_fetch_and_add (&u->waiting, -1);\n+#else\n+  __gthread_mutex_lock (&unit_lock);\n+  u->waiting--;\n+  __gthread_mutex_unlock (&unit_lock);\n+#endif\n+}\n+\n #endif"}, {"sha": "be620aef197aaa78dd350697b5bbe4b0180ec2c2", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 528, "deletions": 528, "changes": 1056, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -48,30 +48,7 @@ Boston, MA 02110-1301, USA.  */\n    the repeat count.  Since we can have a lot of potential leading\n    zeros, we have to be able to back up by arbitrary amount.  Because\n    the input might not be seekable, we have to buffer the data\n-   ourselves.  Data is buffered in scratch[] until it becomes too\n-   large, after which we start allocating memory on the heap.  */\n-\n-static int repeat_count, saved_length, saved_used;\n-static int input_complete, at_eol, comma_flag;\n-static char last_char, *saved_string;\n-static bt saved_type;\n-\n-/* A namelist specific flag used in the list directed library\n-   to flag that calls are being made from namelist read (eg. to ignore\n-   comments or to treat '/' as a terminator)  */\n-\n-static int namelist_mode;\n-\n-/* A namelist specific flag used in the list directed library to flag\n-   read errors and return, so that an attempt can be made to read a\n-   new object name.  */\n-\n-static int nml_read_error;\n-\n-/* Storage area for values except for strings.  Must be large enough\n-   to hold a complex value (two reals) of the largest kind.  */\n-\n-static char value[32];\n+   ourselves.  */\n \n #define CASE_DIGITS   case '0': case '1': case '2': case '3': case '4': \\\n                       case '5': case '6': case '7': case '8': case '9'\n@@ -92,72 +69,74 @@ static char value[32];\n /* Save a character to a string buffer, enlarging it as necessary.  */\n \n static void\n-push_char (char c)\n+push_char (st_parameter_dt *dtp, char c)\n {\n   char *new;\n \n-  if (saved_string == NULL)\n+  if (dtp->u.p.saved_string == NULL)\n     {\n-      saved_string = scratch;\n-      memset (saved_string,0,SCRATCH_SIZE);\n-      saved_length = SCRATCH_SIZE;\n-      saved_used = 0;\n+      if (dtp->u.p.scratch == NULL)\n+\tdtp->u.p.scratch = get_mem (SCRATCH_SIZE);\n+      dtp->u.p.saved_string = dtp->u.p.scratch;\n+      memset (dtp->u.p.saved_string, 0, SCRATCH_SIZE);\n+      dtp->u.p.saved_length = SCRATCH_SIZE;\n+      dtp->u.p.saved_used = 0;\n     }\n \n-  if (saved_used >= saved_length)\n+  if (dtp->u.p.saved_used >= dtp->u.p.saved_length)\n     {\n-      saved_length = 2 * saved_length;\n-      new = get_mem (2 * saved_length);\n+      dtp->u.p.saved_length = 2 * dtp->u.p.saved_length;\n+      new = get_mem (2 * dtp->u.p.saved_length);\n \n-      memset (new,0,2 * saved_length);\n+      memset (new, 0, 2 * dtp->u.p.saved_length);\n \n-      memcpy (new, saved_string, saved_used);\n-      if (saved_string != scratch)\n-\tfree_mem (saved_string);\n+      memcpy (new, dtp->u.p.saved_string, dtp->u.p.saved_used);\n+      if (dtp->u.p.saved_string != dtp->u.p.scratch)\n+\tfree_mem (dtp->u.p.saved_string);\n \n-      saved_string = new;\n+      dtp->u.p.saved_string = new;\n     }\n \n-  saved_string[saved_used++] = c;\n+  dtp->u.p.saved_string[dtp->u.p.saved_used++] = c;\n }\n \n \n /* Free the input buffer if necessary.  */\n \n static void\n-free_saved (void)\n+free_saved (st_parameter_dt *dtp)\n {\n-  if (saved_string == NULL)\n+  if (dtp->u.p.saved_string == NULL)\n     return;\n \n-  if (saved_string != scratch)\n-    free_mem (saved_string);\n+  if (dtp->u.p.saved_string != dtp->u.p.scratch)\n+    free_mem (dtp->u.p.saved_string);\n \n-  saved_string = NULL;\n-  saved_used = 0;\n+  dtp->u.p.saved_string = NULL;\n+  dtp->u.p.saved_used = 0;\n }\n \n \n static char\n-next_char (void)\n+next_char (st_parameter_dt *dtp)\n {\n   int length;\n   char c, *p;\n \n-  if (last_char != '\\0')\n+  if (dtp->u.p.last_char != '\\0')\n     {\n-      at_eol = 0;\n-      c = last_char;\n-      last_char = '\\0';\n+      dtp->u.p.at_eol = 0;\n+      c = dtp->u.p.last_char;\n+      dtp->u.p.last_char = '\\0';\n       goto done;\n     }\n \n   length = 1;\n \n-  p = salloc_r (current_unit->s, &length);\n+  p = salloc_r (dtp->u.p.current_unit->s, &length);\n   if (p == NULL)\n     {\n-      generate_error (ERROR_OS, NULL);\n+      generate_error (&dtp->common, ERROR_OS, NULL);\n       return '\\0';\n     }\n \n@@ -166,44 +145,44 @@ next_char (void)\n       /* For internal files return a newline instead of signalling EOF.  */\n       /* ??? This isn't quite right, but we don't handle internal files\n \t with multiple records.  */\n-      if (is_internal_unit ())\n+      if (is_internal_unit (dtp))\n \tc = '\\n';\n       else\n-\tlongjmp (g.eof_jump, 1);\n+\tlongjmp (*dtp->u.p.eof_jump, 1);\n     }\n   else\n     c = *p;\n \n done:\n-  at_eol = (c == '\\n' || c == '\\r');\n+  dtp->u.p.at_eol = (c == '\\n' || c == '\\r');\n   return c;\n }\n \n \n /* Push a character back onto the input.  */\n \n static void\n-unget_char (char c)\n+unget_char (st_parameter_dt *dtp, char c)\n {\n-  last_char = c;\n+  dtp->u.p.last_char = c;\n }\n \n \n /* Skip over spaces in the input.  Returns the nonspace character that\n    terminated the eating and also places it back on the input.  */\n \n static char\n-eat_spaces (void)\n+eat_spaces (st_parameter_dt *dtp)\n {\n   char c;\n \n   do\n     {\n-      c = next_char ();\n+      c = next_char (dtp);\n     }\n   while (c == ' ' || c == '\\t');\n \n-  unget_char (c);\n+  unget_char (dtp, c);\n   return c;\n }\n \n@@ -220,35 +199,35 @@ eat_spaces (void)\n    of the separator.  */\n \n static void\n-eat_separator (void)\n+eat_separator (st_parameter_dt *dtp)\n {\n   char c;\n \n-  eat_spaces ();\n-  comma_flag = 0;\n+  eat_spaces (dtp);\n+  dtp->u.p.comma_flag = 0;\n \n-  c = next_char ();\n+  c = next_char (dtp);\n   switch (c)\n     {\n     case ',':\n-      comma_flag = 1;\n-      eat_spaces ();\n+      dtp->u.p.comma_flag = 1;\n+      eat_spaces (dtp);\n       break;\n \n     case '/':\n-      input_complete = 1;\n+      dtp->u.p.input_complete = 1;\n       break;\n \n     case '\\n':\n     case '\\r':\n-      at_eol = 1;\n+      dtp->u.p.at_eol = 1;\n       break;\n \n     case '!':\n-      if (namelist_mode)\n+      if (dtp->u.p.namelist_mode)\n \t{\t\t\t/* Eat a namelist comment.  */\n \t  do\n-\t    c = next_char ();\n+\t    c = next_char (dtp);\n \t  while (c != '\\n');\n \n \t  break;\n@@ -257,7 +236,7 @@ eat_separator (void)\n       /* Fall Through...  */\n \n     default:\n-      unget_char (c);\n+      unget_char (dtp, c);\n       break;\n     }\n }\n@@ -268,81 +247,81 @@ eat_separator (void)\n    we started on the previous line.  */\n \n static void\n-finish_separator (void)\n+finish_separator (st_parameter_dt *dtp)\n {\n   char c;\n \n  restart:\n-  eat_spaces ();\n+  eat_spaces (dtp);\n \n-  c = next_char ();\n+  c = next_char (dtp);\n   switch (c)\n     {\n     case ',':\n-      if (comma_flag)\n-\tunget_char (c);\n+      if (dtp->u.p.comma_flag)\n+\tunget_char (dtp, c);\n       else\n \t{\n-\t  c = eat_spaces ();\n+\t  c = eat_spaces (dtp);\n \t  if (c == '\\n')\n \t    goto restart;\n \t}\n \n       break;\n \n     case '/':\n-      input_complete = 1;\n-      if (!namelist_mode) next_record (0);\n+      dtp->u.p.input_complete = 1;\n+      if (!dtp->u.p.namelist_mode) next_record (dtp, 0);\n       break;\n \n     case '\\n':\n     case '\\r':\n       goto restart;\n \n     case '!':\n-      if (namelist_mode)\n+      if (dtp->u.p.namelist_mode)\n \t{\n \t  do\n-\t    c = next_char ();\n+\t    c = next_char (dtp);\n \t  while (c != '\\n');\n \n \t  goto restart;\n \t}\n \n     default:\n-      unget_char (c);\n+      unget_char (dtp, c);\n       break;\n     }\n }\n \n /* This function is needed to catch bad conversions so that namelist can\n-   attempt to see if saved_string contains a new object name rather than\n-   a bad value.  */\n+   attempt to see if dtp->u.p.saved_string contains a new object name rather\n+   than a bad value.  */\n \n static int\n-nml_bad_return (char c)\n+nml_bad_return (st_parameter_dt *dtp, char c)\n {\n-  if (namelist_mode)\n+  if (dtp->u.p.namelist_mode)\n     {\n-      nml_read_error = 1;\n-      unget_char(c);\n+      dtp->u.p.nml_read_error = 1;\n+      unget_char (dtp, c);\n       return 1;\n     }\n   return 0;\n }\n \n /* Convert an unsigned string to an integer.  The length value is -1\n    if we are working on a repeat count.  Returns nonzero if we have a\n-   range problem.  As a side effect, frees the saved_string.  */\n+   range problem.  As a side effect, frees the dtp->u.p.saved_string.  */\n \n static int\n-convert_integer (int length, int negative)\n+convert_integer (st_parameter_dt *dtp, int length, int negative)\n {\n   char c, *buffer, message[100];\n   int m;\n   GFC_INTEGER_LARGEST v, max, max10;\n \n-  buffer = saved_string;\n+  buffer = dtp->u.p.saved_string;\n   v = 0;\n \n   max = (length == -1) ? MAX_REPEAT : max_value (length, 1);\n@@ -370,35 +349,35 @@ convert_integer (int length, int negative)\n     {\n       if (negative)\n \tv = -v;\n-      set_integer (value, v, length);\n+      set_integer (dtp->u.p.value, v, length);\n     }\n   else\n     {\n-      repeat_count = v;\n+      dtp->u.p.repeat_count = v;\n \n-      if (repeat_count == 0)\n+      if (dtp->u.p.repeat_count == 0)\n \t{\n \t  st_sprintf (message, \"Zero repeat count in item %d of list input\",\n-\t\t      g.item_count);\n+\t\t      dtp->u.p.item_count);\n \n-\t  generate_error (ERROR_READ_VALUE, message);\n+\t  generate_error (&dtp->common, ERROR_READ_VALUE, message);\n \t  m = 1;\n \t}\n     }\n \n-  free_saved ();\n+  free_saved (dtp);\n   return m;\n \n  overflow:\n   if (length == -1)\n     st_sprintf (message, \"Repeat count overflow in item %d of list input\",\n-\t\tg.item_count);\n+\t\tdtp->u.p.item_count);\n   else\n     st_sprintf (message, \"Integer overflow while reading item %d\",\n-\t\tg.item_count);\n+\t\tdtp->u.p.item_count);\n \n-  free_saved ();\n-  generate_error (ERROR_READ_VALUE, message);\n+  free_saved (dtp);\n+  generate_error (&dtp->common, ERROR_READ_VALUE, message);\n \n   return 1;\n }\n@@ -409,31 +388,31 @@ convert_integer (int length, int negative)\n    should continue on.  */\n \n static int\n-parse_repeat (void)\n+parse_repeat (st_parameter_dt *dtp)\n {\n   char c, message[100];\n   int repeat;\n \n-  c = next_char ();\n+  c = next_char (dtp);\n   switch (c)\n     {\n     CASE_DIGITS:\n       repeat = c - '0';\n       break;\n \n     CASE_SEPARATORS:\n-      unget_char (c);\n-      eat_separator ();\n+      unget_char (dtp, c);\n+      eat_separator (dtp);\n       return 1;\n \n     default:\n-      unget_char (c);\n+      unget_char (dtp, c);\n       return 0;\n     }\n \n   for (;;)\n     {\n-      c = next_char ();\n+      c = next_char (dtp);\n       switch (c)\n \t{\n \tCASE_DIGITS:\n@@ -443,9 +422,9 @@ parse_repeat (void)\n \t    {\n \t      st_sprintf (message,\n \t\t\t  \"Repeat count overflow in item %d of list input\",\n-\t\t\t  g.item_count);\n+\t\t\t  dtp->u.p.item_count);\n \n-\t      generate_error (ERROR_READ_VALUE, message);\n+\t      generate_error (&dtp->common, ERROR_READ_VALUE, message);\n \t      return 1;\n \t    }\n \n@@ -456,9 +435,9 @@ parse_repeat (void)\n \t    {\n \t      st_sprintf (message,\n \t\t\t  \"Zero repeat count in item %d of list input\",\n-\t\t\t  g.item_count);\n+\t\t\t  dtp->u.p.item_count);\n \n-\t      generate_error (ERROR_READ_VALUE, message);\n+\t      generate_error (&dtp->common, ERROR_READ_VALUE, message);\n \t      return 1;\n \t    }\n \n@@ -470,30 +449,30 @@ parse_repeat (void)\n     }\n \n  done:\n-  repeat_count = repeat;\n+  dtp->u.p.repeat_count = repeat;\n   return 0;\n \n  bad_repeat:\n   st_sprintf (message, \"Bad repeat count in item %d of list input\",\n-\t      g.item_count);\n+\t      dtp->u.p.item_count);\n \n-  generate_error (ERROR_READ_VALUE, message);\n+  generate_error (&dtp->common, ERROR_READ_VALUE, message);\n   return 1;\n }\n \n \n /* Read a logical character on the input.  */\n \n static void\n-read_logical (int length)\n+read_logical (st_parameter_dt *dtp, int length)\n {\n   char c, message[100];\n   int v;\n \n-  if (parse_repeat ())\n+  if (parse_repeat (dtp))\n     return;\n \n-  c = next_char ();\n+  c = next_char (dtp);\n   switch (c)\n     {\n     case 't':\n@@ -506,7 +485,7 @@ read_logical (int length)\n       break;\n \n     case '.':\n-      c = next_char ();\n+      c = next_char (dtp);\n       switch (c)\n \t{\n \tcase 't':\n@@ -524,40 +503,40 @@ read_logical (int length)\n       break;\n \n     CASE_SEPARATORS:\n-      unget_char (c);\n-      eat_separator ();\n+      unget_char (dtp, c);\n+      eat_separator (dtp);\n       return;\t\t\t/* Null value.  */\n \n     default:\n       goto bad_logical;\n     }\n \n-  saved_type = BT_LOGICAL;\n-  saved_length = length;\n+  dtp->u.p.saved_type = BT_LOGICAL;\n+  dtp->u.p.saved_length = length;\n \n   /* Eat trailing garbage.  */\n   do\n     {\n-      c = next_char ();\n+      c = next_char (dtp);\n     }\n   while (!is_separator (c));\n \n-  unget_char (c);\n-  eat_separator ();\n-  free_saved ();\n-  set_integer ((int *) value, v, length);\n+  unget_char (dtp, c);\n+  eat_separator (dtp);\n+  free_saved (dtp);\n+  set_integer ((int *) dtp->u.p.value, v, length);\n \n   return;\n \n  bad_logical:\n \n-  if (nml_bad_return (c))\n+  if (nml_bad_return (dtp, c))\n     return;\n \n   st_sprintf (message, \"Bad logical value while reading item %d\",\n-\t      g.item_count);\n+\t      dtp->u.p.item_count);\n \n-  generate_error (ERROR_READ_VALUE, message);\n+  generate_error (&dtp->common, ERROR_READ_VALUE, message);\n }\n \n \n@@ -567,31 +546,31 @@ read_logical (int length)\n    used for repeat counts.  */\n \n static void\n-read_integer (int length)\n+read_integer (st_parameter_dt *dtp, int length)\n {\n   char c, message[100];\n   int negative;\n \n   negative = 0;\n \n-  c = next_char ();\n+  c = next_char (dtp);\n   switch (c)\n     {\n     case '-':\n       negative = 1;\n       /* Fall through...  */\n \n     case '+':\n-      c = next_char ();\n+      c = next_char (dtp);\n       goto get_integer;\n \n     CASE_SEPARATORS:\t\t/* Single null.  */\n-      unget_char (c);\n-      eat_separator ();\n+      unget_char (dtp, c);\n+      eat_separator (dtp);\n       return;\n \n     CASE_DIGITS:\n-      push_char (c);\n+      push_char (dtp, c);\n       break;\n \n     default:\n@@ -602,15 +581,15 @@ read_integer (int length)\n \n   for (;;)\n     {\n-      c = next_char ();\n+      c = next_char (dtp);\n       switch (c)\n \t{\n \tCASE_DIGITS:\n-\t  push_char (c);\n+\t  push_char (dtp, c);\n \t  break;\n \n \tcase '*':\n-\t  push_char ('\\0');\n+\t  push_char (dtp, '\\0');\n \t  goto repeat;\n \n \tCASE_SEPARATORS:\t/* Not a repeat count.  */\n@@ -622,43 +601,43 @@ read_integer (int length)\n     }\n \n  repeat:\n-  if (convert_integer (-1, 0))\n+  if (convert_integer (dtp, -1, 0))\n     return;\n \n   /* Get the real integer.  */\n \n-  c = next_char ();\n+  c = next_char (dtp);\n   switch (c)\n     {\n     CASE_DIGITS:\n       break;\n \n     CASE_SEPARATORS:\n-      unget_char (c);\n-      eat_separator ();\n+      unget_char (dtp, c);\n+      eat_separator (dtp);\n       return;\n \n     case '-':\n       negative = 1;\n       /* Fall through...  */\n \n     case '+':\n-      c = next_char ();\n+      c = next_char (dtp);\n       break;\n     }\n \n  get_integer:\n   if (!isdigit (c))\n     goto bad_integer;\n-  push_char (c);\n+  push_char (dtp, c);\n \n   for (;;)\n     {\n-      c = next_char ();\n+      c = next_char (dtp);\n       switch (c)\n \t{\n \tCASE_DIGITS:\n-\t  push_char (c);\n+\t  push_char (dtp, c);\n \t  break;\n \n \tCASE_SEPARATORS:\n@@ -671,51 +650,52 @@ read_integer (int length)\n \n  bad_integer:\n \n-  if (nml_bad_return (c))\n+  if (nml_bad_return (dtp, c))\n     return;\n \n-  free_saved ();\n+  free_saved (dtp);\n \n-  st_sprintf (message, \"Bad integer for item %d in list input\", g.item_count);\n-  generate_error (ERROR_READ_VALUE, message);\n+  st_sprintf (message, \"Bad integer for item %d in list input\",\n+\t      dtp->u.p.item_count);\n+  generate_error (&dtp->common, ERROR_READ_VALUE, message);\n \n   return;\n \n  done:\n-  unget_char (c);\n-  eat_separator ();\n+  unget_char (dtp, c);\n+  eat_separator (dtp);\n \n-  push_char ('\\0');\n-  if (convert_integer (length, negative))\n+  push_char (dtp, '\\0');\n+  if (convert_integer (dtp, length, negative))\n     {\n-       free_saved ();\n+       free_saved (dtp);\n        return;\n     }\n \n-  free_saved ();\n-  saved_type = BT_INTEGER;\n+  free_saved (dtp);\n+  dtp->u.p.saved_type = BT_INTEGER;\n }\n \n \n /* Read a character variable.  */\n \n static void\n-read_character (int length __attribute__ ((unused)))\n+read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n {\n   char c, quote, message[100];\n \n   quote = ' ';\t\t\t/* Space means no quote character.  */\n \n-  c = next_char ();\n+  c = next_char (dtp);\n   switch (c)\n     {\n     CASE_DIGITS:\n-      push_char (c);\n+      push_char (dtp, c);\n       break;\n \n     CASE_SEPARATORS:\n-      unget_char (c);\t\t/* NULL value.  */\n-      eat_separator ();\n+      unget_char (dtp, c);\t\t/* NULL value.  */\n+      eat_separator (dtp);\n       return;\n \n     case '\"':\n@@ -724,47 +704,47 @@ read_character (int length __attribute__ ((unused)))\n       goto get_string;\n \n     default:\n-      push_char (c);\n+      push_char (dtp, c);\n       goto get_string;\n     }\n \n   /* Deal with a possible repeat count.  */\n \n   for (;;)\n     {\n-      c = next_char ();\n+      c = next_char (dtp);\n       switch (c)\n \t{\n \tCASE_DIGITS:\n-\t  push_char (c);\n+\t  push_char (dtp, c);\n \t  break;\n \n \tCASE_SEPARATORS:\n-\t  unget_char (c);\n+\t  unget_char (dtp, c);\n \t  goto done;\t\t/* String was only digits!  */\n \n \tcase '*':\n-\t  push_char ('\\0');\n+\t  push_char (dtp, '\\0');\n \t  goto got_repeat;\n \n \tdefault:\n-\t  push_char (c);\n+\t  push_char (dtp, c);\n \t  goto get_string;\t/* Not a repeat count after all.  */\n \t}\n     }\n \n  got_repeat:\n-  if (convert_integer (-1, 0))\n+  if (convert_integer (dtp, -1, 0))\n     return;\n \n   /* Now get the real string.  */\n \n-  c = next_char ();\n+  c = next_char (dtp);\n   switch (c)\n     {\n     CASE_SEPARATORS:\n-      unget_char (c);\t\t/* Repeated NULL values.  */\n-      eat_separator ();\n+      unget_char (dtp, c);\t\t/* Repeated NULL values.  */\n+      eat_separator (dtp);\n       return;\n \n     case '\"':\n@@ -773,69 +753,70 @@ read_character (int length __attribute__ ((unused)))\n       break;\n \n     default:\n-      push_char (c);\n+      push_char (dtp, c);\n       break;\n     }\n \n  get_string:\n   for (;;)\n     {\n-      c = next_char ();\n+      c = next_char (dtp);\n       switch (c)\n \t{\n \tcase '\"':\n \tcase '\\'':\n \t  if (c != quote)\n \t    {\n-\t      push_char (c);\n+\t      push_char (dtp, c);\n \t      break;\n \t    }\n \n \t  /* See if we have a doubled quote character or the end of\n \t     the string.  */\n \n-\t  c = next_char ();\n+\t  c = next_char (dtp);\n \t  if (c == quote)\n \t    {\n-\t      push_char (quote);\n+\t      push_char (dtp, quote);\n \t      break;\n \t    }\n \n-\t  unget_char (c);\n+\t  unget_char (dtp, c);\n \t  goto done;\n \n \tCASE_SEPARATORS:\n \t  if (quote == ' ')\n \t    {\n-\t      unget_char (c);\n+\t      unget_char (dtp, c);\n \t      goto done;\n \t    }\n \n \t  if (c != '\\n')\n-\t    push_char (c);\n+\t    push_char (dtp, c);\n \t  break;\n \n \tdefault:\n-\t  push_char (c);\n+\t  push_char (dtp, c);\n \t  break;\n \t}\n     }\n \n   /* At this point, we have to have a separator, or else the string is\n      invalid.  */\n  done:\n-  c = next_char ();\n+  c = next_char (dtp);\n   if (is_separator (c))\n     {\n-      unget_char (c);\n-      eat_separator ();\n-      saved_type = BT_CHARACTER;\n+      unget_char (dtp, c);\n+      eat_separator (dtp);\n+      dtp->u.p.saved_type = BT_CHARACTER;\n     }\n   else\n     {\n-      free_saved ();\n-      st_sprintf (message, \"Invalid string input in item %d\", g.item_count);\n-      generate_error (ERROR_READ_VALUE, message);\n+      free_saved (dtp);\n+      st_sprintf (message, \"Invalid string input in item %d\",\n+\t\t  dtp->u.p.item_count);\n+      generate_error (&dtp->common, ERROR_READ_VALUE, message);\n     }\n }\n \n@@ -844,58 +825,58 @@ read_character (int length __attribute__ ((unused)))\n    are sure is already there.  This is a straight real number parser.  */\n \n static int\n-parse_real (void *buffer, int length)\n+parse_real (st_parameter_dt *dtp, void *buffer, int length)\n {\n   char c, message[100];\n   int m, seen_dp;\n \n-  c = next_char ();\n+  c = next_char (dtp);\n   if (c == '-' || c == '+')\n     {\n-      push_char (c);\n-      c = next_char ();\n+      push_char (dtp, c);\n+      c = next_char (dtp);\n     }\n \n   if (!isdigit (c) && c != '.')\n     goto bad;\n \n-  push_char (c);\n+  push_char (dtp, c);\n \n   seen_dp = (c == '.') ? 1 : 0;\n \n   for (;;)\n     {\n-      c = next_char ();\n+      c = next_char (dtp);\n       switch (c)\n \t{\n \tCASE_DIGITS:\n-\t  push_char (c);\n+\t  push_char (dtp, c);\n \t  break;\n \n \tcase '.':\n \t  if (seen_dp)\n \t    goto bad;\n \n \t  seen_dp = 1;\n-\t  push_char (c);\n+\t  push_char (dtp, c);\n \t  break;\n \n \tcase 'e':\n \tcase 'E':\n \tcase 'd':\n \tcase 'D':\n-\t  push_char ('e');\n+\t  push_char (dtp, 'e');\n \t  goto exp1;\n \n \tcase '-':\n \tcase '+':\n-\t  push_char ('e');\n-\t  push_char (c);\n-\t  c = next_char ();\n+\t  push_char (dtp, 'e');\n+\t  push_char (dtp, c);\n+\t  c = next_char (dtp);\n \t  goto exp2;\n \n \tCASE_SEPARATORS:\n-\t  unget_char (c);\n+\t  unget_char (dtp, c);\n \t  goto done;\n \n \tdefault:\n@@ -904,31 +885,31 @@ parse_real (void *buffer, int length)\n     }\n \n  exp1:\n-  c = next_char ();\n+  c = next_char (dtp);\n   if (c != '-' && c != '+')\n-    push_char ('+');\n+    push_char (dtp, '+');\n   else\n     {\n-      push_char (c);\n-      c = next_char ();\n+      push_char (dtp, c);\n+      c = next_char (dtp);\n     }\n \n  exp2:\n   if (!isdigit (c))\n     goto bad;\n-  push_char (c);\n+  push_char (dtp, c);\n \n   for (;;)\n     {\n-      c = next_char ();\n+      c = next_char (dtp);\n       switch (c)\n \t{\n \tCASE_DIGITS:\n-\t  push_char (c);\n+\t  push_char (dtp, c);\n \t  break;\n \n \tCASE_SEPARATORS:\n-\t  unget_char (c);\n+\t  unget_char (dtp, c);\n \t  goto done;\n \n \tdefault:\n@@ -937,18 +918,19 @@ parse_real (void *buffer, int length)\n     }\n \n  done:\n-  unget_char (c);\n-  push_char ('\\0');\n+  unget_char (dtp, c);\n+  push_char (dtp, '\\0');\n \n-  m = convert_real (buffer, saved_string, length);\n-  free_saved ();\n+  m = convert_real (dtp, buffer, dtp->u.p.saved_string, length);\n+  free_saved (dtp);\n \n   return m;\n \n  bad:\n-  free_saved ();\n-  st_sprintf (message, \"Bad floating point number for item %d\", g.item_count);\n-  generate_error (ERROR_READ_VALUE, message);\n+  free_saved (dtp);\n+  st_sprintf (message, \"Bad floating point number for item %d\",\n+\t      dtp->u.p.item_count);\n+  generate_error (&dtp->common, ERROR_READ_VALUE, message);\n \n   return 1;\n }\n@@ -958,101 +940,101 @@ parse_real (void *buffer, int length)\n    what it is right away.  */\n \n static void\n-read_complex (int kind, size_t size)\n+read_complex (st_parameter_dt *dtp, int kind, size_t size)\n {\n   char message[100];\n   char c;\n \n-  if (parse_repeat ())\n+  if (parse_repeat (dtp))\n     return;\n \n-  c = next_char ();\n+  c = next_char (dtp);\n   switch (c)\n     {\n     case '(':\n       break;\n \n     CASE_SEPARATORS:\n-      unget_char (c);\n-      eat_separator ();\n+      unget_char (dtp, c);\n+      eat_separator (dtp);\n       return;\n \n     default:\n       goto bad_complex;\n     }\n \n-  eat_spaces ();\n-  if (parse_real (value, kind))\n+  eat_spaces (dtp);\n+  if (parse_real (dtp, dtp->u.p.value, kind))\n     return;\n \n eol_1:\n-  eat_spaces ();\n-  c = next_char ();\n+  eat_spaces (dtp);\n+  c = next_char (dtp);\n   if (c == '\\n' || c== '\\r')\n     goto eol_1;\n   else\n-    unget_char (c);\n+    unget_char (dtp, c);\n \n-  if (next_char () != ',')\n+  if (next_char (dtp) != ',')\n     goto bad_complex;\n \n eol_2:\n-  eat_spaces ();\n-  c = next_char ();\n+  eat_spaces (dtp);\n+  c = next_char (dtp);\n   if (c == '\\n' || c== '\\r')\n     goto eol_2;\n   else\n-    unget_char (c);\n+    unget_char (dtp, c);\n \n-  if (parse_real (value + size / 2, kind))\n+  if (parse_real (dtp, dtp->u.p.value + size / 2, kind))\n     return;\n \n-  eat_spaces ();\n-  if (next_char () != ')')\n+  eat_spaces (dtp);\n+  if (next_char (dtp) != ')')\n     goto bad_complex;\n \n-  c = next_char ();\n+  c = next_char (dtp);\n   if (!is_separator (c))\n     goto bad_complex;\n \n-  unget_char (c);\n-  eat_separator ();\n+  unget_char (dtp, c);\n+  eat_separator (dtp);\n \n-  free_saved ();\n-  saved_type = BT_COMPLEX;\n+  free_saved (dtp);\n+  dtp->u.p.saved_type = BT_COMPLEX;\n   return;\n \n  bad_complex:\n \n-  if (nml_bad_return (c))\n+  if (nml_bad_return (dtp, c))\n     return;\n \n   st_sprintf (message, \"Bad complex value in item %d of list input\",\n-\t      g.item_count);\n+\t      dtp->u.p.item_count);\n \n-  generate_error (ERROR_READ_VALUE, message);\n+  generate_error (&dtp->common, ERROR_READ_VALUE, message);\n }\n \n \n /* Parse a real number with a possible repeat count.  */\n \n static void\n-read_real (int length)\n+read_real (st_parameter_dt *dtp, int length)\n {\n   char c, message[100];\n   int seen_dp;\n \n   seen_dp = 0;\n \n-  c = next_char ();\n+  c = next_char (dtp);\n   switch (c)\n     {\n     CASE_DIGITS:\n-      push_char (c);\n+      push_char (dtp, c);\n       break;\n \n     case '.':\n-      push_char (c);\n+      push_char (dtp, c);\n       seen_dp = 1;\n       break;\n \n@@ -1061,8 +1043,8 @@ read_real (int length)\n       goto got_sign;\n \n     CASE_SEPARATORS:\n-      unget_char (c);\t\t/* Single null.  */\n-      eat_separator ();\n+      unget_char (dtp, c);\t\t/* Single null.  */\n+      eat_separator (dtp);\n       return;\n \n     default:\n@@ -1073,19 +1055,19 @@ read_real (int length)\n \n   for (;;)\n     {\n-      c = next_char ();\n+      c = next_char (dtp);\n       switch (c)\n \t{\n \tCASE_DIGITS:\n-\t  push_char (c);\n+\t  push_char (dtp, c);\n \t  break;\n \n \tcase '.':\n           if (seen_dp)\n             goto bad_real;\n \n \t  seen_dp = 1;\n-\t  push_char (c);\n+\t  push_char (dtp, c);\n \t  goto real_loop;\n \n \tcase 'E':\n@@ -1096,18 +1078,18 @@ read_real (int length)\n \n \tcase '+':\n \tcase '-':\n-\t  push_char ('e');\n-\t  push_char (c);\n-\t  c = next_char ();\n+\t  push_char (dtp, 'e');\n+\t  push_char (dtp, c);\n+\t  c = next_char (dtp);\n \t  goto exp2;\n \n \tcase '*':\n-\t  push_char ('\\0');\n+\t  push_char (dtp, '\\0');\n \t  goto got_repeat;\n \n \tCASE_SEPARATORS:\n           if (c != '\\n' &&  c != ',' && c != '\\r')\n-            unget_char (c);\n+\t    unget_char (dtp, c);\n \t  goto done;\n \n \tdefault:\n@@ -1116,26 +1098,26 @@ read_real (int length)\n     }\n \n  got_repeat:\n-  if (convert_integer (-1, 0))\n+  if (convert_integer (dtp, -1, 0))\n     return;\n \n   /* Now get the number itself.  */\n \n-  c = next_char ();\n+  c = next_char (dtp);\n   if (is_separator (c))\n     {\t\t\t\t/* Repeated null value.  */\n-      unget_char (c);\n-      eat_separator ();\n+      unget_char (dtp, c);\n+      eat_separator (dtp);\n       return;\n     }\n \n   if (c != '-' && c != '+')\n-    push_char ('+');\n+    push_char (dtp, '+');\n   else\n     {\n     got_sign:\n-      push_char (c);\n-      c = next_char ();\n+      push_char (dtp, c);\n+      c = next_char (dtp);\n     }\n \n   if (!isdigit (c) && c != '.')\n@@ -1149,16 +1131,16 @@ read_real (int length)\n         seen_dp = 1;\n     }\n \n-  push_char (c);\n+  push_char (dtp, c);\n \n  real_loop:\n   for (;;)\n     {\n-      c = next_char ();\n+      c = next_char (dtp);\n       switch (c)\n \t{\n \tCASE_DIGITS:\n-\t  push_char (c);\n+\t  push_char (dtp, c);\n \t  break;\n \n \tCASE_SEPARATORS:\n@@ -1169,7 +1151,7 @@ read_real (int length)\n \t    goto bad_real;\n \n \t  seen_dp = 1;\n-\t  push_char (c);\n+\t  push_char (dtp, c);\n \t  break;\n \n \tcase 'E':\n@@ -1180,9 +1162,9 @@ read_real (int length)\n \n \tcase '+':\n \tcase '-':\n-\t  push_char ('e');\n-\t  push_char (c);\n-\t  c = next_char ();\n+\t  push_char (dtp, 'e');\n+\t  push_char (dtp, c);\n+\t  c = next_char (dtp);\n \t  goto exp2;\n \n \tdefault:\n@@ -1191,30 +1173,30 @@ read_real (int length)\n     }\n \n  exp1:\n-  push_char ('e');\n+  push_char (dtp, 'e');\n \n-  c = next_char ();\n+  c = next_char (dtp);\n   if (c != '+' && c != '-')\n-    push_char ('+');\n+    push_char (dtp, '+');\n   else\n     {\n-      push_char (c);\n-      c = next_char ();\n+      push_char (dtp, c);\n+      c = next_char (dtp);\n     }\n \n  exp2:\n   if (!isdigit (c))\n     goto bad_real;\n-  push_char (c);\n+  push_char (dtp, c);\n \n   for (;;)\n     {\n-      c = next_char ();\n+      c = next_char (dtp);\n \n       switch (c)\n \t{\n \tCASE_DIGITS:\n-\t  push_char (c);\n+\t  push_char (dtp, c);\n \t  break;\n \n \tCASE_SEPARATORS:\n@@ -1226,54 +1208,56 @@ read_real (int length)\n     }\n \n  done:\n-  unget_char (c);\n-  eat_separator ();\n-  push_char ('\\0');\n-  if (convert_real (value, saved_string, length))\n+  unget_char (dtp, c);\n+  eat_separator (dtp);\n+  push_char (dtp, '\\0');\n+  if (convert_real (dtp, dtp->u.p.value, dtp->u.p.saved_string, length))\n     return;\n \n-  free_saved ();\n-  saved_type = BT_REAL;\n+  free_saved (dtp);\n+  dtp->u.p.saved_type = BT_REAL;\n   return;\n \n  bad_real:\n \n-  if (nml_bad_return (c))\n+  if (nml_bad_return (dtp, c))\n     return;\n \n   st_sprintf (message, \"Bad real number in item %d of list input\",\n-\t      g.item_count);\n+\t      dtp->u.p.item_count);\n \n-  generate_error (ERROR_READ_VALUE, message);\n+  generate_error (&dtp->common, ERROR_READ_VALUE, message);\n }\n \n \n /* Check the current type against the saved type to make sure they are\n    compatible.  Returns nonzero if incompatible.  */\n \n static int\n-check_type (bt type, int len)\n+check_type (st_parameter_dt *dtp, bt type, int len)\n {\n   char message[100];\n \n-  if (saved_type != BT_NULL && saved_type != type)\n+  if (dtp->u.p.saved_type != BT_NULL && dtp->u.p.saved_type != type)\n     {\n       st_sprintf (message, \"Read type %s where %s was expected for item %d\",\n-\t\t  type_name (saved_type), type_name (type), g.item_count);\n+\t\t  type_name (dtp->u.p.saved_type), type_name (type),\n+\t\t  dtp->u.p.item_count);\n \n-      generate_error (ERROR_READ_VALUE, message);\n+      generate_error (&dtp->common, ERROR_READ_VALUE, message);\n       return 1;\n     }\n \n-  if (saved_type == BT_NULL || saved_type == BT_CHARACTER)\n+  if (dtp->u.p.saved_type == BT_NULL || dtp->u.p.saved_type == BT_CHARACTER)\n     return 0;\n \n-  if (saved_length != len)\n+  if (dtp->u.p.saved_length != len)\n     {\n       st_sprintf (message,\n \t\t  \"Read kind %d %s where kind %d is required for item %d\",\n-\t\t  saved_length, type_name (saved_type), len, g.item_count);\n-      generate_error (ERROR_READ_VALUE, message);\n+\t\t  dtp->u.p.saved_length, type_name (dtp->u.p.saved_type), len,\n+\t\t  dtp->u.p.item_count);\n+      generate_error (&dtp->common, ERROR_READ_VALUE, message);\n       return 1;\n     }\n \n@@ -1283,110 +1267,114 @@ check_type (bt type, int len)\n \n /* Top level data transfer subroutine for list reads.  Because we have\n    to deal with repeat counts, the data item is always saved after\n-   reading, usually in the value[] array.  If a repeat count is\n+   reading, usually in the dtp->u.p.value[] array.  If a repeat count is\n    greater than one, we copy the data item multiple times.  */\n \n static void\n-list_formatted_read_scalar (bt type, void *p, int kind, size_t size)\n+list_formatted_read_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n+\t\t\t    size_t size)\n {\n   char c;\n   int m;\n+  jmp_buf eof_jump;\n \n-  namelist_mode = 0;\n+  dtp->u.p.namelist_mode = 0;\n \n-  if (setjmp (g.eof_jump))\n+  dtp->u.p.eof_jump = &eof_jump;\n+  if (setjmp (eof_jump))\n     {\n-      generate_error (ERROR_END, NULL);\n-      return;\n+      generate_error (&dtp->common, ERROR_END, NULL);\n+      goto cleanup;\n     }\n \n-  if (g.first_item)\n+  if (dtp->u.p.first_item)\n     {\n-      g.first_item = 0;\n-      input_complete = 0;\n-      repeat_count = 1;\n-      at_eol = 0;\n+      dtp->u.p.first_item = 0;\n+      dtp->u.p.input_complete = 0;\n+      dtp->u.p.repeat_count = 1;\n+      dtp->u.p.at_eol = 0;\n \n-      c = eat_spaces ();\n+      c = eat_spaces (dtp);\n       if (is_separator (c))\n \t{\t\t\t/* Found a null value.  */\n-\t  eat_separator ();\n-\t  repeat_count = 0;\n-\t  if (at_eol)\n-            finish_separator ();\n+\t  eat_separator (dtp);\n+\t  dtp->u.p.repeat_count = 0;\n+\t  if (dtp->u.p.at_eol)\n+\t    finish_separator (dtp);\n           else\n-            return;\n+\t    goto cleanup;\n \t}\n \n     }\n   else\n     {\n-      if (input_complete)\n-\treturn;\n+      if (dtp->u.p.input_complete)\n+\tgoto cleanup;\n \n-      if (repeat_count > 0)\n+      if (dtp->u.p.repeat_count > 0)\n \t{\n-\t  if (check_type (type, kind))\n+\t  if (check_type (dtp, type, kind))\n \t    return;\n \t  goto set_value;\n \t}\n \n-      if (at_eol)\n-        finish_separator ();\n+      if (dtp->u.p.at_eol)\n+\tfinish_separator (dtp);\n       else\n         {\n-          eat_spaces ();\n+\t  eat_spaces (dtp);\n           /* trailing spaces prior to end of line */\n-          if (at_eol)\n-            finish_separator ();\n+\t  if (dtp->u.p.at_eol)\n+\t    finish_separator (dtp);\n         }\n \n-      saved_type = BT_NULL;\n-      repeat_count = 1;\n+      dtp->u.p.saved_type = BT_NULL;\n+      dtp->u.p.repeat_count = 1;\n     }\n \n   switch (type)\n     {\n     case BT_INTEGER:\n-      read_integer (kind);\n+      read_integer (dtp, kind);\n       break;\n     case BT_LOGICAL:\n-      read_logical (kind);\n+      read_logical (dtp, kind);\n       break;\n     case BT_CHARACTER:\n-      read_character (kind);\n+      read_character (dtp, kind);\n       break;\n     case BT_REAL:\n-      read_real (kind);\n+      read_real (dtp, kind);\n       break;\n     case BT_COMPLEX:\n-      read_complex (kind, size);\n+      read_complex (dtp, kind, size);\n       break;\n     default:\n-      internal_error (\"Bad type for list read\");\n+      internal_error (&dtp->common, \"Bad type for list read\");\n     }\n \n-  if (saved_type != BT_CHARACTER && saved_type != BT_NULL)\n-    saved_length = size;\n+  if (dtp->u.p.saved_type != BT_CHARACTER && dtp->u.p.saved_type != BT_NULL)\n+    dtp->u.p.saved_length = size;\n \n-  if (ioparm.library_return != LIBRARY_OK)\n-    return;\n+  if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n+    goto cleanup;\n \n  set_value:\n-  switch (saved_type)\n+  switch (dtp->u.p.saved_type)\n     {\n     case BT_COMPLEX:\n     case BT_INTEGER:\n     case BT_REAL:\n     case BT_LOGICAL:\n-      memcpy (p, value, size);\n+      memcpy (p, dtp->u.p.value, size);\n       break;\n \n     case BT_CHARACTER:\n-      if (saved_string)\n+      if (dtp->u.p.saved_string)\n        {\n-          m = ((int) size < saved_used) ? (int) size : saved_used;\n-          memcpy (p, saved_string, m);\n+\t  m = ((int) size < dtp->u.p.saved_used)\n+\t      ? (int) size : dtp->u.p.saved_used;\n+\t  memcpy (p, dtp->u.p.saved_string, m);\n        }\n       else\n \t/* Just delimiters encountered, nothing to copy but SPACE.  */\n@@ -1400,13 +1388,17 @@ list_formatted_read_scalar (bt type, void *p, int kind, size_t size)\n       break;\n     }\n \n-  if (--repeat_count <= 0)\n-    free_saved ();\n+  if (--dtp->u.p.repeat_count <= 0)\n+    free_saved (dtp);\n+\n+cleanup:\n+  dtp->u.p.eof_jump = NULL;\n }\n \n \n void\n-list_formatted_read  (bt type, void *p, int kind, size_t size, size_t nelems)\n+list_formatted_read (st_parameter_dt *dtp, bt type, void *p, int kind,\n+\t\t     size_t size, size_t nelems)\n {\n   size_t elem;\n   char *tmp;\n@@ -1416,83 +1408,61 @@ list_formatted_read  (bt type, void *p, int kind, size_t size, size_t nelems)\n   /* Big loop over all the elements.  */\n   for (elem = 0; elem < nelems; elem++)\n     {\n-      g.item_count++;\n-      list_formatted_read_scalar (type, tmp + size*elem, kind, size);\n+      dtp->u.p.item_count++;\n+      list_formatted_read_scalar (dtp, type, tmp + size*elem, kind, size);\n     }\n }\n \n \n-void\n-init_at_eol(void)\n-{\n-  at_eol = 0;\n-}\n-\n /* Finish a list read.  */\n \n void\n-finish_list_read (void)\n+finish_list_read (st_parameter_dt *dtp)\n {\n   char c;\n \n-  free_saved ();\n+  free_saved (dtp);\n \n-  if (at_eol)\n+  if (dtp->u.p.at_eol)\n     {\n-      at_eol = 0;\n+      dtp->u.p.at_eol = 0;\n       return;\n     }\n \n   do\n     {\n-      c = next_char ();\n+      c = next_char (dtp);\n     }\n   while (c != '\\n');\n }\n \n /*\t\t\tNAMELIST INPUT\n \n-void namelist_read (void)\n+void namelist_read (st_parameter_dt *dtp)\n calls:\n    static void nml_match_name (char *name, int len)\n-   static int nml_query (void)\n-   static int nml_get_obj_data (void)\n+   static int nml_query (st_parameter_dt *dtp)\n+   static int nml_get_obj_data (st_parameter_dt *dtp,\n+\t\t\t\tnamelist_info **prev_nl, char *)\n calls:\n-      static void nml_untouch_nodes (void)\n-      static namelist_info * find_nml_node (char * var_name)\n+      static void nml_untouch_nodes (st_parameter_dt *dtp)\n+      static namelist_info * find_nml_node (st_parameter_dt *dtp,\n+\t\t\t\t\t    char * var_name)\n       static int nml_parse_qualifier(descriptor_dimension * ad,\n-\t\t\t\t     array_loop_spec * ls, int rank)\n+\t\t\t\t     array_loop_spec * ls, int rank, char *)\n       static void nml_touch_nodes (namelist_info * nl)\n-      static int nml_read_obj (namelist_info * nl, index_type offset)\n+      static int nml_read_obj (namelist_info *nl, index_type offset,\n+\t\t\t       namelist_info **prev_nl, char *,\n+\t\t\t       index_type clow, index_type chigh)\n calls:\n       -itself-  */\n \n-/* Carries error messages from the qualifier parser.  */\n-static char parse_err_msg[30];\n-\n-/* Carries error messages for error returns.  */\n-static char nml_err_msg[100];\n-\n-/* Pointer to the previously read object, in case attempt is made to read\n-   new object name.  Should this fail, error message can give previous\n-   name.  */\n-\n-static namelist_info * prev_nl;\n-\n-/* Lower index for substring qualifier.  */\n-\n-static index_type clow;\n-\n-/* Upper index for substring qualifier.  */\n-\n-static index_type chigh;\n-\n /* Inputs a rank-dimensional qualifier, which can contain\n    singlets, doublets, triplets or ':' with the standard meanings.  */\n \n static try\n-nml_parse_qualifier(descriptor_dimension * ad,\n-\t\t    array_loop_spec * ls, int rank)\n+nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n+\t\t     array_loop_spec *ls, int rank, char *parse_err_msg)\n {\n   int dim;\n   int indx;\n@@ -1502,21 +1472,21 @@ nml_parse_qualifier(descriptor_dimension * ad,\n \n   /* The next character in the stream should be the '('.  */\n \n-  c = next_char ();\n+  c = next_char (dtp);\n \n   /* Process the qualifier, by dimension and triplet.  */\n \n   for (dim=0; dim < rank; dim++ )\n     {\n       for (indx=0; indx<3; indx++)\n \t{\n-\t  free_saved ();\n-\t  eat_spaces ();\n+\t  free_saved (dtp);\n+\t  eat_spaces (dtp);\n \t  neg = 0;\n \n \t  /*process a potential sign.  */\n \n-\t  c = next_char ();\n+\t  c = next_char (dtp);\n \t  switch (c)\n \t    {\n \t    case '-':\n@@ -1527,15 +1497,15 @@ nml_parse_qualifier(descriptor_dimension * ad,\n \t      break;\n \n \t    default:\n-\t      unget_char (c);\n+\t      unget_char (dtp, c);\n \t      break;\n \t    }\n \n \t  /*process characters up to the next ':' , ',' or ')'  */\n \n \t  for (;;)\n \t    {\n-\t      c = next_char ();\n+\t      c = next_char (dtp);\n \n \t      switch (c)\n \t\t{\n@@ -1553,44 +1523,45 @@ nml_parse_qualifier(descriptor_dimension * ad,\n \t\t  break;\n \n \t\tCASE_DIGITS:\n-\t\t  push_char (c);\n+\t\t  push_char (dtp, c);\n \t\t  continue;\n \n \t\tcase ' ': case '\\t':\n-\t\t  eat_spaces ();\n-\t\t  c = next_char ();\n+\t\t  eat_spaces (dtp);\n+\t\t  c = next_char (dtp);\n \t\t  break;\n \n \t\tdefault:\n \t\t  st_sprintf (parse_err_msg, \"Bad character in index\");\n \t\t  goto err_ret;\n \t\t}\n \n-\t      if (( c==',' || c==')') && indx==0 && saved_string == 0 )\n+\t      if ((c == ',' || c == ')') && indx == 0\n+\t\t  && dtp->u.p.saved_string == 0)\n \t\t{\n \t\t  st_sprintf (parse_err_msg, \"Null index field\");\n \t\t  goto err_ret;\n \t\t}\n \n-\t      if ( ( c==':' && indx==1 && saved_string == 0)\n-\t\t|| (indx==2 && saved_string == 0))\n+\t      if ((c == ':' && indx == 1 && dtp->u.p.saved_string == 0)\n+\t\t|| (indx == 2 && dtp->u.p.saved_string == 0))\n \t\t{\n \t\t  st_sprintf(parse_err_msg, \"Bad index triplet\");\n \t\t  goto err_ret;\n \t\t}\n \n \t      /* If '( : ? )' or '( ? : )' break and flag read failure.  */\n \t      null_flag = 0;\n-\t      if ( (c==':'  && indx==0 && saved_string == 0)\n-\t\t|| (indx==1 && saved_string == 0))\n+\t      if ((c == ':' && indx == 0 && dtp->u.p.saved_string == 0)\n+\t\t|| (indx==1 && dtp->u.p.saved_string == 0))\n \t\t{\n \t\t  null_flag = 1;\n \t\t  break;\n \t\t}\n \n \t      /* Now read the index.  */\n \n-\t      if (convert_integer (sizeof(int),neg))\n+\t      if (convert_integer (dtp, sizeof(int), neg))\n \t\t{\n \t\t  st_sprintf (parse_err_msg, \"Bad integer in index\");\n \t\t  goto err_ret;\n@@ -1603,11 +1574,11 @@ nml_parse_qualifier(descriptor_dimension * ad,\n \t  if (!null_flag)\n \t    {\n \t      if (indx == 0)\n-\t\tls[dim].start = *(int *)value;\n+\t\tls[dim].start = *(int *)dtp->u.p.value;\n \t      if (indx == 1)\n-\t\tls[dim].end   = *(int *)value;\n+\t\tls[dim].end   = *(int *)dtp->u.p.value;\n \t      if (indx == 2)\n-\t\tls[dim].step  = *(int *)value;\n+\t\tls[dim].step  = *(int *)dtp->u.p.value;\n \t    }\n \n \t  /*singlet or doublet indices  */\n@@ -1616,8 +1587,8 @@ nml_parse_qualifier(descriptor_dimension * ad,\n \t    {\n \t      if (indx == 0)\n \t\t{\n-\t\t  ls[dim].start = *(int *)value;\n-\t\t  ls[dim].end = *(int *)value;\n+\t\t  ls[dim].start = *(int *)dtp->u.p.value;\n+\t\t  ls[dim].end = *(int *)dtp->u.p.value;\n \t\t}\n \t      break;\n \t    }\n@@ -1645,7 +1616,7 @@ nml_parse_qualifier(descriptor_dimension * ad,\n       ls[dim].idx = ls[dim].start;\n \n     }\n-  eat_spaces ();\n+  eat_spaces (dtp);\n   return SUCCESS;\n \n err_ret:\n@@ -1654,12 +1625,12 @@ nml_parse_qualifier(descriptor_dimension * ad,\n }\n \n static namelist_info *\n-find_nml_node (char * var_name)\n+find_nml_node (st_parameter_dt *dtp, char * var_name)\n {\n-  namelist_info * t = ionml;\n+  namelist_info * t = dtp->u.p.ionml;\n   while (t != NULL)\n     {\n-      if (strcmp (var_name,t->var_name) == 0)\n+      if (strcmp (var_name, t->var_name) == 0)\n \t{\n \t  t->touched = 1;\n \t  return t;\n@@ -1706,29 +1677,29 @@ nml_touch_nodes (namelist_info * nl)\n    new object.  */\n \n static void\n-nml_untouch_nodes (void)\n+nml_untouch_nodes (st_parameter_dt *dtp)\n {\n   namelist_info * t;\n-  for (t = ionml; t; t = t->next)\n+  for (t = dtp->u.p.ionml; t; t = t->next)\n     t->touched = 0;\n   return;\n }\n \n-/* Attempts to input name to namelist name.  Returns nml_read_error = 1\n-   on no match.  */\n+/* Attempts to input name to namelist name.  Returns\n+   dtp->u.p.nml_read_error = 1 on no match.  */\n \n static void\n-nml_match_name (const char *name, index_type len)\n+nml_match_name (st_parameter_dt *dtp, const char *name, index_type len)\n {\n   index_type i;\n   char c;\n-  nml_read_error = 0;\n+  dtp->u.p.nml_read_error = 0;\n   for (i = 0; i < len; i++)\n     {\n-      c = next_char ();\n+      c = next_char (dtp);\n       if (tolower (c) != tolower (name[i]))\n \t{\n-\t  nml_read_error = 1;\n+\t  dtp->u.p.nml_read_error = 1;\n \t  break;\n \t}\n     }\n@@ -1740,30 +1711,30 @@ nml_match_name (const char *name, index_type len)\n    the names alone are printed.  */\n \n static void\n-nml_query (char c)\n+nml_query (st_parameter_dt *dtp, char c)\n {\n   gfc_unit * temp_unit;\n   namelist_info * nl;\n   index_type len;\n   char * p;\n \n-  if (current_unit->unit_number != options.stdin_unit)\n+  if (dtp->u.p.current_unit->unit_number != options.stdin_unit)\n     return;\n \n   /* Store the current unit and transfer to stdout.  */\n \n-  temp_unit = current_unit;\n-  current_unit = find_unit (options.stdout_unit);\n+  temp_unit = dtp->u.p.current_unit;\n+  dtp->u.p.current_unit = find_unit (options.stdout_unit);\n \n-  if (current_unit)\n+  if (dtp->u.p.current_unit)\n     {\n-      g.mode =WRITING;\n-      next_record (0);\n+      dtp->u.p.mode = WRITING;\n+      next_record (dtp, 0);\n \n       /* Write the namelist in its entirety.  */\n \n       if (c == '=')\n-\tnamelist_write ();\n+\tnamelist_write (dtp);\n \n       /* Or write the list of names.  */\n \n@@ -1772,20 +1743,20 @@ nml_query (char c)\n \n \t  /* \"&namelist_name\\n\"  */\n \n-\t  len = ioparm.namelist_name_len;\n-\t  p = write_block (len + 2);\n+\t  len = dtp->namelist_name_len;\n+\t  p = write_block (dtp, len + 2);\n \t  if (!p)\n \t    goto query_return;\n \t  memcpy (p, \"&\", 1);\n-\t  memcpy ((char*)(p + 1), ioparm.namelist_name, len);\n+\t  memcpy ((char*)(p + 1), dtp->namelist_name, len);\n \t  memcpy ((char*)(p + len + 1), \"\\n\", 1);\n-\t  for (nl =ionml; nl; nl = nl->next)\n+\t  for (nl = dtp->u.p.ionml; nl; nl = nl->next)\n \t    {\n \n \t      /* \" var_name\\n\"  */\n \n \t      len = strlen (nl->var_name);\n-\t      p = write_block (len + 2);\n+\t      p = write_block (dtp, len + 2);\n \t      if (!p)\n \t\tgoto query_return;\n \t      memcpy (p, \" \", 1);\n@@ -1795,23 +1766,24 @@ nml_query (char c)\n \n \t  /* \"&end\\n\"  */\n \n-\t  p = write_block (5);\n+\t  p = write_block (dtp, 5);\n \t  if (!p)\n \t    goto query_return;\n \t  memcpy (p, \"&end\\n\", 5);\n \t}\n \n       /* Flush the stream to force immediate output.  */\n \n-      flush (current_unit->s);\n+      flush (dtp->u.p.current_unit->s);\n+      unlock_unit (dtp->u.p.current_unit);\n     }\n \n query_return:\n \n   /* Restore the current unit.  */\n \n-  current_unit = temp_unit;\n-  g.mode = READING;\n+  dtp->u.p.current_unit = temp_unit;\n+  dtp->u.p.mode = READING;\n   return;\n }\n \n@@ -1826,7 +1798,9 @@ nml_query (char c)\n    error.  */\n \n static try\n-nml_read_obj (namelist_info * nl, index_type offset)\n+nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n+\t      namelist_info **pprev_nl, char *nml_err_msg,\n+\t      index_type clow, index_type chigh)\n {\n \n   namelist_info * cmp;\n@@ -1844,8 +1818,8 @@ nml_read_obj (namelist_info * nl, index_type offset)\n   if (!nl->touched)\n     return SUCCESS;\n \n-  repeat_count = 0;\n-  eat_spaces();\n+  dtp->u.p.repeat_count = 0;\n+  eat_spaces (dtp);\n \n   len = nl->len;\n   switch (nl->type)\n@@ -1883,45 +1857,45 @@ nml_read_obj (namelist_info * nl, index_type offset)\n \t\t nl->dim[dim].stride * nl->size);\n \n       /* Reset the error flag and try to read next value, if\n-\t repeat_count=0  */\n+\t dtp->u.p.repeat_count=0  */\n \n-      nml_read_error = 0;\n+      dtp->u.p.nml_read_error = 0;\n       nml_carry = 0;\n-      if (--repeat_count <= 0)\n+      if (--dtp->u.p.repeat_count <= 0)\n \t{\n-\t  if (input_complete)\n+\t  if (dtp->u.p.input_complete)\n \t    return SUCCESS;\n-\t  if (at_eol)\n-\t    finish_separator ();\n-\t  if (input_complete)\n+\t  if (dtp->u.p.at_eol)\n+\t    finish_separator (dtp);\n+\t  if (dtp->u.p.input_complete)\n \t    return SUCCESS;\n \n \t  /* GFC_TYPE_UNKNOWN through for nulls and is detected\n \t     after the switch block.  */\n \n-\t  saved_type = GFC_DTYPE_UNKNOWN;\n-\t  free_saved ();\n+\t  dtp->u.p.saved_type = GFC_DTYPE_UNKNOWN;\n+\t  free_saved (dtp);\n \n           switch (nl->type)\n \t  {\n \t  case GFC_DTYPE_INTEGER:\n-              read_integer (len);\n+\t      read_integer (dtp, len);\n               break;\n \n \t  case GFC_DTYPE_LOGICAL:\n-              read_logical (len);\n+\t      read_logical (dtp, len);\n               break;\n \n \t  case GFC_DTYPE_CHARACTER:\n-              read_character (len);\n+\t      read_character (dtp, len);\n               break;\n \n \t  case GFC_DTYPE_REAL:\n-              read_real (len);\n+\t      read_real (dtp, len);\n               break;\n \n \t  case GFC_DTYPE_COMPLEX:\n-              read_complex (len, dlen);\n+              read_complex (dtp, len, dlen);\n               break;\n \n \t  case GFC_DTYPE_DERIVED:\n@@ -1942,13 +1916,15 @@ nml_read_obj (namelist_info * nl, index_type offset)\n \t\t cmp = cmp->next)\n \t      {\n \n-\t\tif (nml_read_obj (cmp, (index_type)(pdata - nl->mem_pos)) == FAILURE)\n+\t\tif (nml_read_obj (dtp, cmp, (index_type)(pdata - nl->mem_pos),\n+\t\t\t\t  pprev_nl, nml_err_msg, clow, chigh)\n+\t\t    == FAILURE)\n \t\t  {\n \t\t    free_mem (obj_name);\n \t\t    return FAILURE;\n \t\t  }\n \n-\t\tif (input_complete)\n+\t\tif (dtp->u.p.input_complete)\n \t\t  {\n \t\t    free_mem (obj_name);\n \t\t    return SUCCESS;\n@@ -1960,42 +1936,42 @@ nml_read_obj (namelist_info * nl, index_type offset)\n \n           default:\n \t    st_sprintf (nml_err_msg, \"Bad type for namelist object %s\",\n-\t\t\tnl->var_name );\n-\t    internal_error (nml_err_msg);\n+\t\t\tnl->var_name);\n+\t    internal_error (&dtp->common, nml_err_msg);\n \t    goto nml_err_ret;\n           }\n         }\n \n       /* The standard permits array data to stop short of the number of\n \t elements specified in the loop specification.  In this case, we\n-\t should be here with nml_read_error != 0.  Control returns to\n+\t should be here with dtp->u.p.nml_read_error != 0.  Control returns to\n \t nml_get_obj_data and an attempt is made to read object name.  */\n \n-      prev_nl = nl;\n-      if (nml_read_error)\n+      *pprev_nl = nl;\n+      if (dtp->u.p.nml_read_error)\n \treturn SUCCESS;\n \n-      if (saved_type == GFC_DTYPE_UNKNOWN)\n+      if (dtp->u.p.saved_type == GFC_DTYPE_UNKNOWN)\n \tgoto incr_idx;\n \n \n       /* Note the switch from GFC_DTYPE_type to BT_type at this point.\n \t This comes about because the read functions return BT_types.  */\n \n-      switch (saved_type)\n+      switch (dtp->u.p.saved_type)\n       {\n \n \tcase BT_COMPLEX:\n \tcase BT_REAL:\n \tcase BT_INTEGER:\n \tcase BT_LOGICAL:\n-\t  memcpy (pdata, value, dlen);\n+\t  memcpy (pdata, dtp->u.p.value, dlen);\n \t  break;\n \n \tcase BT_CHARACTER:\n-\t  m = (dlen < saved_used) ? dlen : saved_used;\n+\t  m = (dlen < dtp->u.p.saved_used) ? dlen : dtp->u.p.saved_used;\n \t  pdata = (void*)( pdata + clow - 1 );\n-\t  memcpy (pdata, saved_string, m);\n+\t  memcpy (pdata, dtp->u.p.saved_string, m);\n \t  if (m < dlen)\n \t    memset ((void*)( pdata + m ), ' ', dlen - m);\n \tbreak;\n@@ -2028,7 +2004,7 @@ nml_read_obj (namelist_info * nl, index_type offset)\n         }\n     } while (!nml_carry);\n \n-  if (repeat_count > 1)\n+  if (dtp->u.p.repeat_count > 1)\n     {\n        st_sprintf (nml_err_msg, \"Repeat count too large for namelist object %s\" ,\n \t\t   nl->var_name );\n@@ -2049,55 +2025,57 @@ nml_read_obj (namelist_info * nl, index_type offset)\n    the manner specified by the object name.  */\n \n static try\n-nml_get_obj_data (void)\n+nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n+\t\t  char *nml_err_msg)\n {\n   char c;\n-  char * ext_name;\n   namelist_info * nl;\n   namelist_info * first_nl = NULL;\n   namelist_info * root_nl = NULL;\n   int dim;\n   int component_flag;\n+  char parse_err_msg[30];\n+  index_type clow, chigh;\n \n   /* Look for end of input or object name.  If '?' or '=?' are encountered\n      in stdin, print the node names or the namelist to stdout.  */\n \n-  eat_separator ();\n-  if (input_complete)\n+  eat_separator (dtp);\n+  if (dtp->u.p.input_complete)\n     return SUCCESS;\n \n-  if ( at_eol )\n-    finish_separator ();\n-  if (input_complete)\n+  if (dtp->u.p.at_eol)\n+    finish_separator (dtp);\n+  if (dtp->u.p.input_complete)\n     return SUCCESS;\n \n-  c = next_char ();\n+  c = next_char (dtp);\n   switch (c)\n     {\n     case '=':\n-      c = next_char ();\n+      c = next_char (dtp);\n       if (c != '?')\n \t{\n \t  st_sprintf (nml_err_msg, \"namelist read: missplaced = sign\");\n \t  goto nml_err_ret;\n \t}\n-      nml_query ('=');\n+      nml_query (dtp, '=');\n       return SUCCESS;\n \n     case '?':\n-      nml_query ('?');\n+      nml_query (dtp, '?');\n       return SUCCESS;\n \n     case '$':\n     case '&':\n-      nml_match_name (\"end\", 3);\n-      if (nml_read_error)\n+      nml_match_name (dtp, \"end\", 3);\n+      if (dtp->u.p.nml_read_error)\n \t{\n \t  st_sprintf (nml_err_msg, \"namelist not terminated with / or &end\");\n \t  goto nml_err_ret;\n \t}\n     case '/':\n-      input_complete = 1;\n+      dtp->u.p.input_complete = 1;\n       return SUCCESS;\n \n     default :\n@@ -2107,22 +2085,22 @@ nml_get_obj_data (void)\n   /* Untouch all nodes of the namelist and reset the flag that is set for\n      derived type components.  */\n \n-  nml_untouch_nodes();\n+  nml_untouch_nodes (dtp);\n   component_flag = 0;\n \n   /* Get the object name - should '!' and '\\n' be permitted separators?  */\n \n get_name:\n \n-  free_saved ();\n+  free_saved (dtp);\n \n   do\n     {\n-      push_char(tolower(c));\n-      c = next_char ();\n+      push_char (dtp, tolower(c));\n+      c = next_char (dtp);\n     } while (!( c=='=' || c==' ' || c=='\\t' || c =='(' || c =='%' ));\n \n-  unget_char (c);\n+  unget_char (dtp, c);\n \n   /* Check that the name is in the namelist and get pointer to object.\n      Three error conditions exist: (i) An attempt is being made to\n@@ -2131,30 +2109,33 @@ nml_get_obj_data (void)\n      are present for an object.  (iii) gives the same error message\n      as (i)  */\n \n-  push_char ('\\0');\n+  push_char (dtp, '\\0');\n \n   if (component_flag)\n     {\n-      ext_name = (char*)get_mem (strlen (root_nl->var_name)\n-\t\t\t\t  + (saved_string ? strlen (saved_string) : 0)\n-\t\t\t\t  + 1);\n-      strcpy (ext_name, root_nl->var_name);\n-      strcat (ext_name, saved_string);\n-      nl = find_nml_node (ext_name);\n-      free_mem (ext_name);\n+      size_t var_len = strlen (root_nl->var_name);\n+      size_t saved_len\n+\t= dtp->u.p.saved_string ? strlen (dtp->u.p.saved_string) : 0;\n+      char ext_name[var_len + saved_len + 1];\n+\n+      memcpy (ext_name, root_nl->var_name, var_len);\n+      if (dtp->u.p.saved_string)\n+\tmemcpy (ext_name + var_len, dtp->u.p.saved_string, saved_len);\n+      ext_name[var_len + saved_len] = '\\0';\n+      nl = find_nml_node (dtp, ext_name);\n     }\n   else\n-    nl = find_nml_node (saved_string);\n+    nl = find_nml_node (dtp, dtp->u.p.saved_string);\n \n   if (nl == NULL)\n     {\n-      if (nml_read_error && prev_nl)\n+      if (dtp->u.p.nml_read_error && *pprev_nl)\n \tst_sprintf (nml_err_msg, \"Bad data for namelist object %s\",\n-\t\t    prev_nl->var_name);\n+\t\t    (*pprev_nl)->var_name);\n \n       else\n \tst_sprintf (nml_err_msg, \"Cannot match namelist object name %s\",\n-\t\t    saved_string);\n+\t\t    dtp->u.p.saved_string);\n \n       goto nml_err_ret;\n     }\n@@ -2174,14 +2155,15 @@ nml_get_obj_data (void)\n \n   if (c == '(' && nl->var_rank)\n     {\n-      if (nml_parse_qualifier (nl->dim, nl->ls, nl->var_rank) == FAILURE)\n+      if (nml_parse_qualifier (dtp, nl->dim, nl->ls, nl->var_rank,\n+\t\t\t       parse_err_msg) == FAILURE)\n \t{\n \t  st_sprintf (nml_err_msg, \"%s for namelist variable %s\",\n \t\t      parse_err_msg, nl->var_name);\n \t  goto nml_err_ret;\n \t}\n-      c = next_char ();\n-      unget_char (c);\n+      c = next_char (dtp);\n+      unget_char (dtp, c);\n     }\n \n   /* Now parse a derived type component. The root namelist_info address\n@@ -2203,7 +2185,7 @@ nml_get_obj_data (void)\n \n       root_nl = nl;\n       component_flag = 1;\n-      c = next_char ();\n+      c = next_char (dtp);\n       goto get_name;\n \n     }\n@@ -2219,7 +2201,7 @@ nml_get_obj_data (void)\n       descriptor_dimension chd[1] = { {1, clow, nl->string_length} };\n       array_loop_spec ind[1] = { {1, clow, nl->string_length, 1} };\n \n-      if (nml_parse_qualifier (chd, ind, 1) == FAILURE)\n+      if (nml_parse_qualifier (dtp, chd, ind, 1, parse_err_msg) == FAILURE)\n \t{\n \t  st_sprintf (nml_err_msg, \"%s for namelist variable %s\",\n \t\t      parse_err_msg, nl->var_name);\n@@ -2237,8 +2219,8 @@ nml_get_obj_data (void)\n \t  goto nml_err_ret;\n \t}\n \n-      c = next_char ();\n-      unget_char (c);\n+      c = next_char (dtp);\n+      unget_char (dtp, c);\n     }\n \n   /* If a derived type touch its components and restore the root\n@@ -2261,20 +2243,20 @@ nml_get_obj_data (void)\n \n /* According to the standard, an equal sign MUST follow an object name. The\n    following is possibly lax - it allows comments, blank lines and so on to\n-   intervene.  eat_spaces (); c = next_char (); would be compliant*/\n+   intervene.  eat_spaces (dtp); c = next_char (dtp); would be compliant*/\n \n-  free_saved ();\n+  free_saved (dtp);\n \n-  eat_separator ();\n-  if (input_complete)\n+  eat_separator (dtp);\n+  if (dtp->u.p.input_complete)\n     return SUCCESS;\n \n-  if (at_eol)\n-    finish_separator ();\n-  if (input_complete)\n+  if (dtp->u.p.at_eol)\n+    finish_separator (dtp);\n+  if (dtp->u.p.input_complete)\n     return SUCCESS;\n \n-  c = next_char ();\n+  c = next_char (dtp);\n \n   if (c != '=')\n     {\n@@ -2283,7 +2265,7 @@ nml_get_obj_data (void)\n       goto nml_err_ret;\n     }\n \n-  if (nml_read_obj (nl, 0) == FAILURE)\n+  if (nml_read_obj (dtp, nl, 0, pprev_nl, nml_err_msg, clow, chigh) == FAILURE)\n     goto nml_err_ret;\n \n   return SUCCESS;\n@@ -2298,16 +2280,24 @@ nml_get_obj_data (void)\n   completed or there is an error.  */\n \n void\n-namelist_read (void)\n+namelist_read (st_parameter_dt *dtp)\n {\n   char c;\n+  jmp_buf eof_jump;\n+  char nml_err_msg[100];\n+  /* Pointer to the previously read object, in case attempt is made to read\n+     new object name.  Should this fail, error message can give previous\n+     name.  */\n+  namelist_info *prev_nl = NULL;\n \n-  namelist_mode = 1;\n-  input_complete = 0;\n+  dtp->u.p.namelist_mode = 1;\n+  dtp->u.p.input_complete = 0;\n \n-  if (setjmp (g.eof_jump))\n+  dtp->u.p.eof_jump = &eof_jump;\n+  if (setjmp (eof_jump))\n     {\n-      generate_error (ERROR_END, NULL);\n+      dtp->u.p.eof_jump = NULL;\n+      generate_error (&dtp->common, ERROR_END, NULL);\n       return;\n     }\n \n@@ -2316,57 +2306,67 @@ namelist_read (void)\n      node names or namelist on stdout.  */\n \n find_nml_name:\n-  switch (c = next_char ())\n+  switch (c = next_char (dtp))\n     {\n     case '$':\n     case '&':\n           break;\n \n     case '=':\n-      c = next_char ();\n+      c = next_char (dtp);\n       if (c == '?')\n-\tnml_query ('=');\n+\tnml_query (dtp, '=');\n       else\n-\tunget_char (c);\n+\tunget_char (dtp, c);\n       goto find_nml_name;\n \n     case '?':\n-      nml_query ('?');\n+      nml_query (dtp, '?');\n \n     default:\n       goto find_nml_name;\n     }\n \n   /* Match the name of the namelist.  */\n \n-  nml_match_name (ioparm.namelist_name, ioparm.namelist_name_len);\n+  nml_match_name (dtp, dtp->namelist_name, dtp->namelist_name_len);\n \n-  if (nml_read_error)\n+  if (dtp->u.p.nml_read_error)\n     goto find_nml_name;\n \n   /* Ready to read namelist objects.  If there is an error in input\n      from stdin, output the error message and continue.  */\n \n-  while (!input_complete)\n+  while (!dtp->u.p.input_complete)\n     {\n-      if (nml_get_obj_data ()  == FAILURE)\n+      if (nml_get_obj_data (dtp, &prev_nl, nml_err_msg) == FAILURE)\n \t{\n-\t  if (current_unit->unit_number != options.stdin_unit)\n+\t  gfc_unit *u;\n+\n+\t  if (dtp->u.p.current_unit->unit_number != options.stdin_unit)\n \t    goto nml_err_ret;\n \n+\t  u = find_unit (options.stderr_unit);\n \t  st_printf (\"%s\\n\", nml_err_msg);\n-\t  flush (find_unit (options.stderr_unit)->s);\n+\t  if (u != NULL)\n+\t    {\n+\t      flush (u->s);\n+\t      unlock_unit (u);\n+\t    }\n         }\n \n    }\n-  free_saved ();\n+\n+  dtp->u.p.eof_jump = NULL;\n+  free_saved (dtp);\n   return;\n \n   /* All namelist error calls return from here */\n \n nml_err_ret:\n \n-  free_saved ();\n-  generate_error (ERROR_READ_VALUE , nml_err_msg);\n+  dtp->u.p.eof_jump = NULL;\n+  free_saved (dtp);\n+  generate_error (&dtp->common, ERROR_READ_VALUE, nml_err_msg);\n   return;\n }"}, {"sha": "c39188f9d61402bf626c3148b54e48af5fecb6df", "filename": "libgfortran/io/lock.c", "status": "modified", "additions": 8, "deletions": 36, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Flock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Flock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flock.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -33,53 +33,28 @@ Boston, MA 02110-1301, USA.  */\n #include \"libgfortran.h\"\n #include \"io.h\"\n \n-st_parameter ioparm;\n-iexport_data(ioparm);\n-\n-namelist_info *ionml;\n-global_t g;\n-\n-\n /* library_start()-- Called with a library call is entered.  */\n \n void\n-library_start (void)\n+library_start (st_parameter_common *cmp)\n {\n-  if (g.in_library)\n-    internal_error (\"Recursive library calls not allowed\");\n-\n-  /* The in_library flag indicates whether we're currently processing a\n-     library call.  Some calls leave immediately, but READ and WRITE\n-     processing return control to the caller but are still considered to\n-     stay within the library. */\n-  g.in_library = 1;\n+  if ((cmp->flags & IOPARM_HAS_IOSTAT) != 0)\n+    *cmp->iostat = ERROR_OK;\n \n-  if (ioparm.iostat != NULL)\n-    *ioparm.iostat = ERROR_OK;\n-\n-  ioparm.library_return = LIBRARY_OK;\n+  cmp->flags &= ~IOPARM_LIBRETURN_MASK;\n }\n \n \n-/* library_end()-- Called when a library call is complete in order to\n-   clean up for the next call. */\n-\n void\n-library_end (void)\n+free_ionml (st_parameter_dt *dtp)\n {\n-  int t;\n   namelist_info * t1, *t2;\n \n-  g.in_library = 0;\n-  filename = NULL;\n-  line = 0;\n-  t = ioparm.library_return;\n-\n   /* Delete the namelist, if it exists.  */\n \n-  if (ionml != NULL)\n+  if (dtp->u.p.ionml != NULL)\n     {\n-      t1 = ionml;\n+      t1 = dtp->u.p.ionml;\n       while (t1 != NULL)\n \t{\n \t  t2 = t1;\n@@ -93,8 +68,5 @@ library_end (void)\n \t  free_mem (t2);\n \t}\n     }\n-  ionml = NULL;\n-\n-  memset (&ioparm, '\\0', sizeof (ioparm));\n-  ioparm.library_return = t;\n+  dtp->u.p.ionml = NULL;\n }"}, {"sha": "a1bc99b70eb5eccbe4dbcf4f801ddc35cc94c654", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 170, "deletions": 116, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -116,56 +116,57 @@ test_endfile (gfc_unit * u)\n    changed.  */\n \n static void\n-edit_modes (gfc_unit * u, unit_flags * flags)\n+edit_modes (st_parameter_open *opp, gfc_unit * u, unit_flags * flags)\n {\n   /* Complain about attempts to change the unchangeable.  */\n \n   if (flags->status != STATUS_UNSPECIFIED &&\n       u->flags.status != flags->status)\n-    generate_error (ERROR_BAD_OPTION,\n+    generate_error (&opp->common, ERROR_BAD_OPTION,\n \t\t    \"Cannot change STATUS parameter in OPEN statement\");\n \n   if (flags->access != ACCESS_UNSPECIFIED && u->flags.access != flags->access)\n-    generate_error (ERROR_BAD_OPTION,\n+    generate_error (&opp->common, ERROR_BAD_OPTION,\n \t\t    \"Cannot change ACCESS parameter in OPEN statement\");\n \n   if (flags->form != FORM_UNSPECIFIED && u->flags.form != flags->form)\n-    generate_error (ERROR_BAD_OPTION,\n+    generate_error (&opp->common, ERROR_BAD_OPTION,\n \t\t    \"Cannot change FORM parameter in OPEN statement\");\n \n-  if (ioparm.recl_in != 0 && ioparm.recl_in != u->recl)\n-    generate_error (ERROR_BAD_OPTION,\n+  if ((opp->common.flags & IOPARM_OPEN_HAS_RECL_IN)\n+      && opp->recl_in != u->recl)\n+    generate_error (&opp->common, ERROR_BAD_OPTION,\n \t\t    \"Cannot change RECL parameter in OPEN statement\");\n \n   if (flags->action != ACTION_UNSPECIFIED && u->flags.access != flags->access)\n-    generate_error (ERROR_BAD_OPTION,\n+    generate_error (&opp->common, ERROR_BAD_OPTION,\n \t\t    \"Cannot change ACTION parameter in OPEN statement\");\n \n   /* Status must be OLD if present.  */\n \n   if (flags->status != STATUS_UNSPECIFIED && flags->status != STATUS_OLD)\n-    generate_error (ERROR_BAD_OPTION,\n+    generate_error (&opp->common, ERROR_BAD_OPTION,\n \t\t    \"OPEN statement must have a STATUS of OLD\");\n \n   if (u->flags.form == FORM_UNFORMATTED)\n     {\n       if (flags->delim != DELIM_UNSPECIFIED)\n-\tgenerate_error (ERROR_OPTION_CONFLICT,\n+\tgenerate_error (&opp->common, ERROR_OPTION_CONFLICT,\n \t\t\t\"DELIM parameter conflicts with UNFORMATTED form in \"\n \t\t\t\"OPEN statement\");\n \n       if (flags->blank != BLANK_UNSPECIFIED)\n-\tgenerate_error (ERROR_OPTION_CONFLICT,\n+\tgenerate_error (&opp->common, ERROR_OPTION_CONFLICT,\n \t\t\t\"BLANK parameter conflicts with UNFORMATTED form in \"\n \t\t\t\"OPEN statement\");\n \n       if (flags->pad != PAD_UNSPECIFIED)\n-\tgenerate_error (ERROR_OPTION_CONFLICT,\n+\tgenerate_error (&opp->common, ERROR_OPTION_CONFLICT,\n \t\t\t\"PAD paramter conflicts with UNFORMATTED form in \"\n \t\t\t\"OPEN statement\");\n     }\n \n-  if (ioparm.library_return == LIBRARY_OK)\n+  if ((opp->common.flags & IOPARM_LIBRETURN_MASK) == IOPARM_LIBRETURN_OK)\n     {\n       /* Change the changeable:  */\n       if (flags->blank != BLANK_UNSPECIFIED)\n@@ -203,18 +204,20 @@ edit_modes (gfc_unit * u, unit_flags * flags)\n       break;\n \n     seek_error:\n-      generate_error (ERROR_OS, NULL);\n+      generate_error (&opp->common, ERROR_OS, NULL);\n       break;\n     }\n+\n+  unlock_unit (u);\n }\n \n \n /* Open an unused unit.  */\n \n-void\n-new_unit (unit_flags * flags)\n+gfc_unit *\n+new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n {\n-  gfc_unit *u;\n+  gfc_unit *u2;\n   stream *s;\n   char tmpname[5 /* fort. */ + 10 /* digits of unit number */ + 1 /* 0 */];\n \n@@ -236,10 +239,10 @@ new_unit (unit_flags * flags)\n     {\n       if (flags->form == FORM_UNFORMATTED)\n \t{\n-\t  generate_error (ERROR_OPTION_CONFLICT,\n+\t  generate_error (&opp->common, ERROR_OPTION_CONFLICT,\n \t\t\t  \"DELIM parameter conflicts with UNFORMATTED form in \"\n \t\t\t  \"OPEN statement\");\n-\t  goto cleanup;\n+\t  goto fail;\n \t}\n     }\n \n@@ -249,10 +252,10 @@ new_unit (unit_flags * flags)\n     {\n       if (flags->form == FORM_UNFORMATTED)\n \t{\n-\t  generate_error (ERROR_OPTION_CONFLICT,\n+\t  generate_error (&opp->common, ERROR_OPTION_CONFLICT,\n \t\t\t  \"BLANK parameter conflicts with UNFORMATTED form in \"\n \t\t\t  \"OPEN statement\");\n-\t  goto cleanup;\n+\t  goto fail;\n \t}\n     }\n \n@@ -262,19 +265,19 @@ new_unit (unit_flags * flags)\n     {\n       if (flags->form == FORM_UNFORMATTED)\n \t{\n-\t  generate_error (ERROR_OPTION_CONFLICT,\n+\t  generate_error (&opp->common, ERROR_OPTION_CONFLICT,\n \t\t\t  \"PAD paramter conflicts with UNFORMATTED form in \"\n \t\t\t  \"OPEN statement\");\n-\t  goto cleanup;\n+\t  goto fail;\n \t}\n     }\n \n   if (flags->position != POSITION_ASIS && flags->access == ACCESS_DIRECT)\n    {\n-     generate_error (ERROR_OPTION_CONFLICT,\n+     generate_error (&opp->common, ERROR_OPTION_CONFLICT,\n                      \"ACCESS parameter conflicts with SEQUENTIAL access in \"\n                      \"OPEN statement\");\n-     goto cleanup;\n+     goto fail;\n    }\n   else\n    if (flags->position == POSITION_UNSPECIFIED)\n@@ -286,64 +289,74 @@ new_unit (unit_flags * flags)\n \n   /* Checks.  */\n \n-  if (flags->access == ACCESS_DIRECT && ioparm.recl_in == 0)\n+  if (flags->access == ACCESS_DIRECT\n+      && (opp->common.flags & IOPARM_OPEN_HAS_RECL_IN) == 0)\n     {\n-      generate_error (ERROR_MISSING_OPTION,\n+      generate_error (&opp->common, ERROR_MISSING_OPTION,\n \t\t      \"Missing RECL parameter in OPEN statement\");\n-      goto cleanup;\n+      goto fail;\n     }\n \n-  if (ioparm.recl_in != 0 && ioparm.recl_in <= 0)\n+  if ((opp->common.flags & IOPARM_OPEN_HAS_RECL_IN) && opp->recl_in <= 0)\n     {\n-      generate_error (ERROR_BAD_OPTION,\n+      generate_error (&opp->common, ERROR_BAD_OPTION,\n \t\t      \"RECL parameter is non-positive in OPEN statement\");\n-      goto cleanup;\n+      goto fail;\n     }\n \n   switch (flags->status)\n     {\n     case STATUS_SCRATCH:\n-      if (ioparm.file == NULL)\n-\tbreak;\n+      if ((opp->common.flags & IOPARM_OPEN_HAS_FILE) == 0)\n+\t{\n+\t  opp->file = NULL;\n+\t  break;\n+\t}\n \n-      generate_error (ERROR_BAD_OPTION,\n+      generate_error (&opp->common, ERROR_BAD_OPTION,\n \t\t      \"FILE parameter must not be present in OPEN statement\");\n-      return;\n+      goto fail;\n \n     case STATUS_OLD:\n     case STATUS_NEW:\n     case STATUS_REPLACE:\n     case STATUS_UNKNOWN:\n-      if (ioparm.file != NULL)\n+      if ((opp->common.flags & IOPARM_OPEN_HAS_FILE))\n \tbreak;\n \n-      ioparm.file = tmpname;\n-      ioparm.file_len = sprintf(ioparm.file, \"fort.%d\", ioparm.unit);\n+      opp->file = tmpname;\n+      opp->file_len = sprintf(opp->file, \"fort.%d\", opp->common.unit);\n       break;\n \n     default:\n-      internal_error (\"new_unit(): Bad status\");\n+      internal_error (&opp->common, \"new_unit(): Bad status\");\n     }\n \n   /* Make sure the file isn't already open someplace else.\n      Do not error if opening file preconnected to stdin, stdout, stderr.  */\n \n-  u = find_file ();\n-  if (u != NULL\n+  u2 = NULL;\n+  if ((opp->common.flags & IOPARM_OPEN_HAS_FILE) != 0)\n+    u2 = find_file (opp->file, opp->file_len);\n+  if (u2 != NULL\n       && (options.stdin_unit < 0 || u->unit_number != options.stdin_unit)\n       && (options.stdout_unit < 0 || u->unit_number != options.stdout_unit)\n       && (options.stderr_unit < 0 || u->unit_number != options.stderr_unit))\n     {\n-      generate_error (ERROR_ALREADY_OPEN, NULL);\n+      unlock_unit (u2);\n+      generate_error (&opp->common, ERROR_ALREADY_OPEN, NULL);\n       goto cleanup;\n     }\n \n+  if (u2 != NULL)\n+    unlock_unit (u2);\n+\n   /* Open file.  */\n \n-  s = open_external (flags);\n+  s = open_external (opp, flags);\n   if (s == NULL)\n     {\n-      generate_error (ERROR_OS, NULL);\n+      generate_error (&opp->common, ERROR_OS, NULL);\n       goto cleanup;\n     }\n \n@@ -352,148 +365,188 @@ new_unit (unit_flags * flags)\n \n   /* Create the unit structure.  */\n \n-  u = get_mem (sizeof (gfc_unit) + ioparm.file_len);\n-  memset (u, '\\0', sizeof (gfc_unit) + ioparm.file_len);\n-\n-  u->unit_number = ioparm.unit;\n+  u->file = get_mem (opp->file_len);\n+  if (u->unit_number != opp->common.unit)\n+    internal_error (&opp->common, \"Unit number changed\");\n   u->s = s;\n   u->flags = *flags;\n+  u->read_bad = 0;\n+  u->endfile = NO_ENDFILE;\n+  u->last_record = 0;\n+  u->current_record = 0;\n+  u->mode = READING;\n+  u->maxrec = 0;\n+  u->bytes_left = 0;\n \n   if (flags->position == POSITION_APPEND)\n-  {\n-    if (sseek (u->s, file_length (u->s)) == FAILURE)\n-      generate_error (ERROR_OS, NULL);\n-    u->endfile = AT_ENDFILE;\n-  }\n+    {\n+      if (sseek (u->s, file_length (u->s)) == FAILURE)\n+\tgenerate_error (&opp->common, ERROR_OS, NULL);\n+      u->endfile = AT_ENDFILE;\n+    }\n \n   /* Unspecified recl ends up with a processor dependent value.  */\n \n-  u->recl = (ioparm.recl_in != 0) ? ioparm.recl_in : g.max_offset;\n-  u->last_record = 0;\n-  u->current_record = 0;\n+  if ((opp->common.flags & IOPARM_OPEN_HAS_RECL_IN))\n+    u->recl = opp->recl_in;\n+  else\n+    u->recl = max_offset;\n \n   /* If the file is direct access, calculate the maximum record number\n      via a division now instead of letting the multiplication overflow\n      later.  */\n \n   if (flags->access == ACCESS_DIRECT)\n-    u->maxrec = g.max_offset / u->recl;\n-\n-  memmove (u->file, ioparm.file, ioparm.file_len);\n-  u->file_len = ioparm.file_len;\n+    u->maxrec = max_offset / u->recl;\n \n-  insert_unit (u);\n+  memmove (u->file, opp->file, opp->file_len);\n+  u->file_len = opp->file_len;\n \n-  /* The file is now connected.  Errors after this point leave the\n-     file connected.  Curiously, the standard requires that the\n+  /* Curiously, the standard requires that the\n      position specifier be ignored for new files so a newly connected\n      file starts out that the initial point.  We still need to figure\n      out if the file is at the end or not.  */\n \n   test_endfile (u);\n \n+  if (flags->status == STATUS_SCRATCH && opp->file != NULL)\n+    free_mem (opp->file);\n+  return u;\n+\n  cleanup:\n \n   /* Free memory associated with a temporary filename.  */\n \n-  if (flags->status == STATUS_SCRATCH)\n-    free_mem (ioparm.file);\n+  if (flags->status == STATUS_SCRATCH && opp->file != NULL)\n+    free_mem (opp->file);\n+\n+ fail:\n+\n+  close_unit (u);\n+  return NULL;\n }\n \n \n /* Open a unit which is already open.  This involves changing the\n    modes or closing what is there now and opening the new file.  */\n \n static void\n-already_open (gfc_unit * u, unit_flags * flags)\n+already_open (st_parameter_open *opp, gfc_unit * u, unit_flags * flags)\n {\n-  if (ioparm.file == NULL)\n+  if ((opp->common.flags & IOPARM_OPEN_HAS_FILE) == 0)\n     {\n-      edit_modes (u, flags);\n+      edit_modes (opp, u, flags);\n       return;\n     }\n \n   /* If the file is connected to something else, close it and open a\n      new unit.  */\n \n-  if (!compare_file_filename (u, ioparm.file, ioparm.file_len))\n+  if (!compare_file_filename (u, opp->file, opp->file_len))\n     {\n-      if (close_unit (u))\n+#if !HAVE_UNLINK_OPEN_FILE\n+      char *path = NULL;\n+      if (u->file && u->flags.status == STATUS_SCRATCH)\n \t{\n-\t  generate_error (ERROR_OS, \"Error closing file in OPEN statement\");\n+\t  path = (char *) gfc_alloca (u->file_len + 1);\n+\t  unpack_filename (path, u->file, u->file_len);\n+\t}\n+#endif\n+\n+      if (sclose (u->s) == FAILURE)\n+\t{\n+\t  unlock_unit (u);\n+\t  generate_error (&opp->common, ERROR_OS,\n+\t\t\t  \"Error closing file in OPEN statement\");\n \t  return;\n \t}\n \n-      new_unit (flags);\n+      u->s = NULL;\n+      if (u->file)\n+\tfree_mem (u->file);\n+      u->file = NULL;\n+      u->file_len = 0;\n+\n+#if !HAVE_UNLINK_OPEN_FILE\n+      if (path != NULL)\n+\tunlink (path);\n+#endif\n+\n+      u = new_unit (opp, u, flags);\n+      if (u != NULL)\n+\tunlock_unit (u);\n       return;\n     }\n \n-  edit_modes (u, flags);\n+  edit_modes (opp, u, flags);\n }\n \n \n /* Open file.  */\n \n-extern void st_open (void);\n+extern void st_open (st_parameter_open *opp);\n export_proto(st_open);\n \n void\n-st_open (void)\n+st_open (st_parameter_open *opp)\n {\n   unit_flags flags;\n   gfc_unit *u = NULL;\n+  GFC_INTEGER_4 cf = opp->common.flags;\n  \n-  library_start ();\n+  library_start (&opp->common);\n \n   /* Decode options.  */\n \n-  flags.access = (ioparm.access == NULL) ? ACCESS_UNSPECIFIED :\n-    find_option (ioparm.access, ioparm.access_len, access_opt,\n-\t\t \"Bad ACCESS parameter in OPEN statement\");\n+  flags.access = !(cf & IOPARM_OPEN_HAS_ACCESS) ? ACCESS_UNSPECIFIED :\n+    find_option (&opp->common, opp->access, opp->access_len,\n+\t\t access_opt, \"Bad ACCESS parameter in OPEN statement\");\n \n-  flags.action = (ioparm.action == NULL) ? ACTION_UNSPECIFIED :\n-    find_option (ioparm.action, ioparm.action_len, action_opt,\n-\t\t \"Bad ACTION parameter in OPEN statement\");\n+  flags.action = !(cf & IOPARM_OPEN_HAS_ACTION) ? ACTION_UNSPECIFIED :\n+    find_option (&opp->common, opp->action, opp->action_len,\n+\t\t action_opt, \"Bad ACTION parameter in OPEN statement\");\n \n-  flags.blank = (ioparm.blank == NULL) ? BLANK_UNSPECIFIED :\n-    find_option (ioparm.blank, ioparm.blank_len, blank_opt,\n-\t\t \"Bad BLANK parameter in OPEN statement\");\n+  flags.blank = !(cf & IOPARM_OPEN_HAS_BLANK) ? BLANK_UNSPECIFIED :\n+    find_option (&opp->common, opp->blank, opp->blank_len,\n+\t\t blank_opt, \"Bad BLANK parameter in OPEN statement\");\n \n-  flags.delim = (ioparm.delim == NULL) ? DELIM_UNSPECIFIED :\n-    find_option (ioparm.delim, ioparm.delim_len, delim_opt,\n-\t\t \"Bad DELIM parameter in OPEN statement\");\n+  flags.delim = !(cf & IOPARM_OPEN_HAS_DELIM) ? DELIM_UNSPECIFIED :\n+    find_option (&opp->common, opp->delim, opp->delim_len,\n+\t\t delim_opt, \"Bad DELIM parameter in OPEN statement\");\n \n-  flags.pad = (ioparm.pad == NULL) ? PAD_UNSPECIFIED :\n-    find_option (ioparm.pad, ioparm.pad_len, pad_opt,\n-\t\t \"Bad PAD parameter in OPEN statement\");\n+  flags.pad = !(cf & IOPARM_OPEN_HAS_PAD) ? PAD_UNSPECIFIED :\n+    find_option (&opp->common, opp->pad, opp->pad_len,\n+\t\t pad_opt, \"Bad PAD parameter in OPEN statement\");\n \n-  flags.form = (ioparm.form == NULL) ? FORM_UNSPECIFIED :\n-    find_option (ioparm.form, ioparm.form_len, form_opt,\n-\t\t \"Bad FORM parameter in OPEN statement\");\n+  flags.form = !(cf & IOPARM_OPEN_HAS_FORM) ? FORM_UNSPECIFIED :\n+    find_option (&opp->common, opp->form, opp->form_len,\n+\t\t form_opt, \"Bad FORM parameter in OPEN statement\");\n \n-  flags.position = (ioparm.position == NULL) ? POSITION_UNSPECIFIED :\n-    find_option (ioparm.position, ioparm.position_len, position_opt,\n-\t\t \"Bad POSITION parameter in OPEN statement\");\n+  flags.position = !(cf & IOPARM_OPEN_HAS_POSITION) ? POSITION_UNSPECIFIED :\n+    find_option (&opp->common, opp->position, opp->position_len,\n+\t\t position_opt, \"Bad POSITION parameter in OPEN statement\");\n \n-  flags.status = (ioparm.status == NULL) ? STATUS_UNSPECIFIED :\n-    find_option (ioparm.status, ioparm.status_len, status_opt,\n-\t\t \"Bad STATUS parameter in OPEN statement\");\n+  flags.status = !(cf & IOPARM_OPEN_HAS_STATUS) ? STATUS_UNSPECIFIED :\n+    find_option (&opp->common, opp->status, opp->status_len,\n+\t\t status_opt, \"Bad STATUS parameter in OPEN statement\");\n \n-  if (ioparm.unit < 0)\n-    generate_error (ERROR_BAD_OPTION, \"Bad unit number in OPEN statement\");\n+  if (opp->common.unit < 0)\n+    generate_error (&opp->common, ERROR_BAD_OPTION,\n+\t\t    \"Bad unit number in OPEN statement\");\n \n   if (flags.position != POSITION_UNSPECIFIED\n       && flags.access == ACCESS_DIRECT)\n-    generate_error (ERROR_BAD_OPTION,\n+    generate_error (&opp->common, ERROR_BAD_OPTION,\n \t\t    \"Cannot use POSITION with direct access files\");\n \n   if (flags.access == ACCESS_APPEND)\n     {\n       if (flags.position != POSITION_UNSPECIFIED\n \t  && flags.position != POSITION_APPEND)\n-\tgenerate_error (ERROR_BAD_OPTION, \"Conflicting ACCESS and POSITION \"\n-\t\t\t\"flags in OPEN statement\");\n-\t\n+\tgenerate_error (&opp->common, ERROR_BAD_OPTION,\n+\t\t\t\"Conflicting ACCESS and POSITION flags in\"\n+\t\t\t\" OPEN statement\");\n+\n       notify_std (GFC_STD_GNU,\n \t\t  \"Extension: APPEND as a value for ACCESS in OPEN statement\");\n       flags.access = ACCESS_SEQUENTIAL;\n@@ -503,18 +556,19 @@ st_open (void)\n   if (flags.position == POSITION_UNSPECIFIED)\n     flags.position = POSITION_ASIS;\n \n-  if (ioparm.library_return != LIBRARY_OK)\n-  {\n-    library_end ();\n-    return;\n-  }\n-\n-  u = find_unit (ioparm.unit);\n+  if ((opp->common.flags & IOPARM_LIBRETURN_MASK) == IOPARM_LIBRETURN_OK)\n+    {\n+      u = find_or_create_unit (opp->common.unit);\n \n-  if (u == NULL)\n-    new_unit (&flags);\n-  else\n-    already_open (u, &flags);\n+      if (u->s == NULL)\n+\t{\n+\t  u = new_unit (opp, u, &flags);\n+\t  if (u != NULL)\n+\t    unlock_unit (u);\n+\t}\n+      else\n+\talready_open (opp, u, &flags);\n+    }\n \n   library_end ();\n }"}, {"sha": "5f88a398f05d248b130aca4046e497863faee59b", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 49, "deletions": 43, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002-2003 Free Software Foundation, Inc.\n+/* Copyright (C) 2002, 2003, 2005 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n@@ -80,7 +80,7 @@ set_integer (void *dest, GFC_INTEGER_LARGEST value, int length)\n       }\n       break;\n     default:\n-      internal_error (\"Bad integer kind\");\n+      internal_error (NULL, \"Bad integer kind\");\n     }\n }\n \n@@ -119,7 +119,7 @@ max_value (int length, int signed_flag)\n       value = signed_flag ? 0x7f : 0xff;\n       break;\n     default:\n-      internal_error (\"Bad integer kind\");\n+      internal_error (NULL, \"Bad integer kind\");\n     }\n \n   return value;\n@@ -132,7 +132,7 @@ max_value (int length, int signed_flag)\n  * infinities.  */\n \n int\n-convert_real (void *dest, const char *buffer, int length)\n+convert_real (st_parameter_dt *dtp, void *dest, const char *buffer, int length)\n {\n   errno = 0;\n \n@@ -172,12 +172,12 @@ convert_real (void *dest, const char *buffer, int length)\n       break;\n #endif\n     default:\n-      internal_error (\"Unsupported real kind during IO\");\n+      internal_error (&dtp->common, \"Unsupported real kind during IO\");\n     }\n \n   if (errno != 0 && errno != EINVAL)\n     {\n-      generate_error (ERROR_READ_VALUE,\n+      generate_error (&dtp->common, ERROR_READ_VALUE,\n \t\t      \"Range error during floating point read\");\n       return 1;\n     }\n@@ -189,13 +189,13 @@ convert_real (void *dest, const char *buffer, int length)\n /* read_l()-- Read a logical value */\n \n void\n-read_l (fnode * f, char *dest, int length)\n+read_l (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n {\n   char *p;\n   int w;\n \n   w = f->u.w;\n-  p = read_block (&w);\n+  p = read_block (dtp, &w);\n   if (p == NULL)\n     return;\n \n@@ -225,7 +225,8 @@ read_l (fnode * f, char *dest, int length)\n       break;\n     default:\n     bad:\n-      generate_error (ERROR_READ_VALUE, \"Bad value on logical read\");\n+      generate_error (&dtp->common, ERROR_READ_VALUE,\n+\t\t      \"Bad value on logical read\");\n       break;\n     }\n }\n@@ -234,7 +235,7 @@ read_l (fnode * f, char *dest, int length)\n /* read_a()-- Read a character record.  This one is pretty easy. */\n \n void\n-read_a (fnode * f, char *p, int length)\n+read_a (st_parameter_dt *dtp, const fnode *f, char *p, int length)\n {\n   char *source;\n   int w, m, n;\n@@ -243,7 +244,7 @@ read_a (fnode * f, char *p, int length)\n   if (w == -1) /* '(A)' edit descriptor  */\n     w = length;\n \n-  source = read_block (&w);\n+  source = read_block (dtp, &w);\n   if (source == NULL)\n     return;\n   if (w > length)\n@@ -278,7 +279,7 @@ eat_leading_spaces (int *width, char *p)\n \n \n static char\n-next_char (char **p, int *w)\n+next_char (st_parameter_dt *dtp, char **p, int *w)\n {\n   char c, *q;\n \n@@ -293,7 +294,7 @@ next_char (char **p, int *w)\n \n   if (c != ' ')\n     return c;\n-  if (g.blank_status != BLANK_UNSPECIFIED)\n+  if (dtp->u.p.blank_status != BLANK_UNSPECIFIED)\n     return ' ';  /* return a blank to signal a null */ \n \n   /* At this point, the rest of the field has to be trailing blanks */\n@@ -314,15 +315,15 @@ next_char (char **p, int *w)\n  * signed values. */\n \n void\n-read_decimal (fnode * f, char *dest, int length)\n+read_decimal (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n {\n   GFC_UINTEGER_LARGEST value, maxv, maxv_10;\n   GFC_INTEGER_LARGEST v;\n   int w, negative;\n   char c, *p;\n \n   w = f->u.w;\n-  p = read_block (&w);\n+  p = read_block (dtp, &w);\n   if (p == NULL)\n     return;\n \n@@ -360,14 +361,14 @@ read_decimal (fnode * f, char *dest, int length)\n \n   for (;;)\n     {\n-      c = next_char (&p, &w);\n+      c = next_char (dtp, &p, &w);\n       if (c == '\\0')\n \tbreak;\n \t\n       if (c == ' ')\n         {\n-          if (g.blank_status == BLANK_NULL) continue;\n-          if (g.blank_status == BLANK_ZERO) c = '0';\n+\t  if (dtp->u.p.blank_status == BLANK_NULL) continue;\n+\t  if (dtp->u.p.blank_status == BLANK_ZERO) c = '0';\n         }\n         \n       if (c < '0' || c > '9')\n@@ -392,11 +393,12 @@ read_decimal (fnode * f, char *dest, int length)\n   return;\n \n  bad:\n-  generate_error (ERROR_READ_VALUE, \"Bad value during integer read\");\n+  generate_error (&dtp->common, ERROR_READ_VALUE,\n+\t\t  \"Bad value during integer read\");\n   return;\n \n  overflow:\n-  generate_error (ERROR_READ_OVERFLOW,\n+  generate_error (&dtp->common, ERROR_READ_OVERFLOW,\n \t\t  \"Value overflowed during integer read\");\n   return;\n }\n@@ -408,15 +410,16 @@ read_decimal (fnode * f, char *dest, int length)\n  * the top bit is set, the value will be incorrect. */\n \n void\n-read_radix (fnode * f, char *dest, int length, int radix)\n+read_radix (st_parameter_dt *dtp, const fnode *f, char *dest, int length,\n+\t    int radix)\n {\n   GFC_UINTEGER_LARGEST value, maxv, maxv_r;\n   GFC_INTEGER_LARGEST v;\n   int w, negative;\n   char c, *p;\n \n   w = f->u.w;\n-  p = read_block (&w);\n+  p = read_block (dtp, &w);\n   if (p == NULL)\n     return;\n \n@@ -454,13 +457,13 @@ read_radix (fnode * f, char *dest, int length, int radix)\n \n   for (;;)\n     {\n-      c = next_char (&p, &w);\n+      c = next_char (dtp, &p, &w);\n       if (c == '\\0')\n \tbreak;\n       if (c == ' ')\n         {\n-          if (g.blank_status == BLANK_NULL) continue;\n-          if (g.blank_status == BLANK_ZERO) c = '0';\n+\t  if (dtp->u.p.blank_status == BLANK_NULL) continue;\n+\t  if (dtp->u.p.blank_status == BLANK_ZERO) c = '0';\n         }\n \n       switch (radix)\n@@ -534,11 +537,12 @@ read_radix (fnode * f, char *dest, int length, int radix)\n   return;\n \n  bad:\n-  generate_error (ERROR_READ_VALUE, \"Bad value during integer read\");\n+  generate_error (&dtp->common, ERROR_READ_VALUE,\n+\t\t  \"Bad value during integer read\");\n   return;\n \n  overflow:\n-  generate_error (ERROR_READ_OVERFLOW,\n+  generate_error (&dtp->common, ERROR_READ_OVERFLOW,\n \t\t  \"Value overflowed during integer read\");\n   return;\n }\n@@ -551,7 +555,7 @@ read_radix (fnode * f, char *dest, int length, int radix)\n    the input.  */\n \n void\n-read_f (fnode * f, char *dest, int length)\n+read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n {\n   int w, seen_dp, exponent;\n   int exponent_sign, val_sign;\n@@ -560,11 +564,12 @@ read_f (fnode * f, char *dest, int length)\n   int i;\n   char *p, *buffer;\n   char *digits;\n+  char scratch[SCRATCH_SIZE];\n \n   val_sign = 1;\n   seen_dp = 0;\n   w = f->u.w;\n-  p = read_block (&w);\n+  p = read_block (dtp, &w);\n   if (p == NULL)\n     return;\n \n@@ -648,11 +653,12 @@ read_f (fnode * f, char *dest, int length)\n     }\n \n   /* No exponent has been seen, so we use the current scale factor */\n-  exponent = -g.scale_factor;\n+  exponent = -dtp->u.p.scale_factor;\n   goto done;\n \n  bad_float:\n-  generate_error (ERROR_READ_VALUE, \"Bad value during floating point read\");\n+  generate_error (&dtp->common, ERROR_READ_VALUE,\n+\t\t  \"Bad value during floating point read\");\n   return;\n \n   /* The value read is zero */\n@@ -680,7 +686,7 @@ read_f (fnode * f, char *dest, int length)\n #endif\n \n       default:\n-\tinternal_error (\"Unsupported real kind during IO\");\n+\tinternal_error (&dtp->common, \"Unsupported real kind during IO\");\n     }\n   return;\n \n@@ -718,7 +724,7 @@ read_f (fnode * f, char *dest, int length)\n   p++;\n   w--;\n \n-  if (g.blank_status == BLANK_UNSPECIFIED) /* Normal processing of exponent */\n+  if (dtp->u.p.blank_status == BLANK_UNSPECIFIED) /* Normal processing of exponent */\n     {\n       while (w > 0 && isdigit (*p))\n         {\n@@ -743,8 +749,8 @@ read_f (fnode * f, char *dest, int length)\n         {\n           if (*p == ' ')\n             {\n-              if (g.blank_status == BLANK_ZERO) *p = '0';\n-              if (g.blank_status == BLANK_NULL)\n+\t      if (dtp->u.p.blank_status == BLANK_ZERO) *p = '0';\n+\t      if (dtp->u.p.blank_status == BLANK_NULL)\n                 {\n                   p++;\n                   w--;\n@@ -803,8 +809,8 @@ read_f (fnode * f, char *dest, int length)\n     {\n       if (*digits == ' ')\n         {\n-          if (g.blank_status == BLANK_ZERO) *digits = '0';\n-          if (g.blank_status == BLANK_NULL)\n+\t  if (dtp->u.p.blank_status == BLANK_ZERO) *digits = '0';\n+\t  if (dtp->u.p.blank_status == BLANK_NULL)\n             {\n               digits++;\n               continue;\n@@ -818,7 +824,7 @@ read_f (fnode * f, char *dest, int length)\n   sprintf (p, \"%d\", exponent);\n \n   /* Do the actual conversion.  */\n-  convert_real (dest, buffer, length);\n+  convert_real (dtp, dest, buffer, length);\n \n   if (buffer != scratch)\n      free_mem (buffer);\n@@ -831,12 +837,12 @@ read_f (fnode * f, char *dest, int length)\n  * and never look at it. */\n \n void\n-read_x (int n)\n+read_x (st_parameter_dt *dtp, int n)\n {\n-  if ((current_unit->flags.pad == PAD_NO || is_internal_unit ())\n-      && current_unit->bytes_left < n)\n-    n = current_unit->bytes_left;\n+  if ((dtp->u.p.current_unit->flags.pad == PAD_NO || is_internal_unit (dtp))\n+      && dtp->u.p.current_unit->bytes_left < n)\n+    n = dtp->u.p.current_unit->bytes_left;\n \n   if (n > 0)\n-    read_block (&n);\n+    read_block (dtp, &n);\n }"}, {"sha": "a4ea81c1b032f65229ac7674c75b20ce59c8b2b9", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 581, "deletions": 554, "changes": 1135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -63,50 +63,32 @@ Boston, MA 02110-1301, USA.  */\n     st_write(), an error inhibits any data from actually being\n     transferred.  */\n \n-extern void transfer_integer (void *, int);\n+extern void transfer_integer (st_parameter_dt *, void *, int);\n export_proto(transfer_integer);\n \n-extern void transfer_real (void *, int);\n+extern void transfer_real (st_parameter_dt *, void *, int);\n export_proto(transfer_real);\n \n-extern void transfer_logical (void *, int);\n+extern void transfer_logical (st_parameter_dt *, void *, int);\n export_proto(transfer_logical);\n \n-extern void transfer_character (void *, int);\n+extern void transfer_character (st_parameter_dt *, void *, int);\n export_proto(transfer_character);\n \n-extern void transfer_complex (void *, int);\n+extern void transfer_complex (st_parameter_dt *, void *, int);\n export_proto(transfer_complex);\n \n-extern void transfer_array (gfc_array_char *, int, gfc_charlen_type);\n+extern void transfer_array (st_parameter_dt *, gfc_array_char *, int,\n+\t\t\t    gfc_charlen_type);\n export_proto(transfer_array);\n \n-gfc_unit *current_unit = NULL;\n-static int sf_seen_eor = 0;\n-static int eor_condition = 0;\n-\n-/* Maximum righthand column written to.  */\n-static int max_pos;\n-/* Number of skips + spaces to be done for T and X-editing.  */\n-static int skips;\n-/* Number of spaces to be done for T and X-editing.  */\n-static int pending_spaces;\n-\n-char scratch[SCRATCH_SIZE];\n-static char *line_buffer = NULL;\n-\n-static unit_advance advance_status;\n-\n static const st_option advance_opt[] = {\n   {\"yes\", ADVANCE_YES},\n   {\"no\", ADVANCE_NO},\n   {NULL, 0}\n };\n \n \n-static void (*transfer) (bt, void *, int, size_t, size_t);\n-\n-\n typedef enum\n { FORMATTED_SEQUENTIAL, UNFORMATTED_SEQUENTIAL,\n   FORMATTED_DIRECT, UNFORMATTED_DIRECT\n@@ -115,18 +97,18 @@ file_mode;\n \n \n static file_mode\n-current_mode (void)\n+current_mode (st_parameter_dt *dtp)\n {\n   file_mode m;\n \n-  if (current_unit->flags.access == ACCESS_DIRECT)\n+  if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)\n     {\n-      m = current_unit->flags.form == FORM_FORMATTED ?\n+      m = dtp->u.p.current_unit->flags.form == FORM_FORMATTED ?\n \tFORMATTED_DIRECT : UNFORMATTED_DIRECT;\n     }\n   else\n     {\n-      m = current_unit->flags.form == FORM_FORMATTED ?\n+      m = dtp->u.p.current_unit->flags.form == FORM_FORMATTED ?\n \tFORMATTED_SEQUENTIAL : UNFORMATTED_SEQUENTIAL;\n     }\n \n@@ -151,20 +133,18 @@ current_mode (void)\n    heap.  Hopefully this won't happen very often.  */\n \n static char *\n-read_sf (int *length)\n+read_sf (st_parameter_dt *dtp, int *length)\n {\n-  static char data[SCRATCH_SIZE];\n   char *base, *p, *q;\n   int n, readlen;\n \n   if (*length > SCRATCH_SIZE)\n-    p = base = line_buffer = get_mem (*length);\n-  else\n-    p = base = data;\n+    dtp->u.p.line_buffer = get_mem (*length);\n+  p = base = dtp->u.p.line_buffer;\n \n   /* If we have seen an eor previously, return a length of 0.  The\n      caller is responsible for correctly padding the input field.  */\n-  if (sf_seen_eor)\n+  if (dtp->u.p.sf_seen_eor)\n     {\n       *length = 0;\n       return base;\n@@ -175,22 +155,22 @@ read_sf (int *length)\n \n   do\n     {\n-      if (is_internal_unit())\n+      if (is_internal_unit (dtp))\n \t{\n \t  /* readlen may be modified inside salloc_r if\n-\t     is_internal_unit() is true.  */\n+\t     is_internal_unit (dtp) is true.  */\n \t  readlen = 1;\n \t}\n \n-      q = salloc_r (current_unit->s, &readlen);\n+      q = salloc_r (dtp->u.p.current_unit->s, &readlen);\n       if (q == NULL)\n \tbreak;\n \n       /* If we have a line without a terminating \\n, drop through to\n \t EOR below.  */\n       if (readlen < 1 && n == 0)\n \t{\n-\t  generate_error (ERROR_END, NULL);\n+\t  generate_error (&dtp->common, ERROR_END, NULL);\n \t  return NULL;\n \t}\n \n@@ -200,32 +180,32 @@ read_sf (int *length)\n \n \t  /* If we see an EOR during non-advancing I/O, we need to skip\n \t     the rest of the I/O statement.  Set the corresponding flag.  */\n-\t  if (advance_status == ADVANCE_NO || g.seen_dollar)\n-\t    eor_condition = 1;\n+\t  if (dtp->u.p.advance_status == ADVANCE_NO || dtp->u.p.seen_dollar)\n+\t    dtp->u.p.eor_condition = 1;\n \n \t  /* Without padding, terminate the I/O statement without assigning\n \t     the value.  With padding, the value still needs to be assigned,\n \t     so we can just continue with a short read.  */\n-\t  if (current_unit->flags.pad == PAD_NO)\n+\t  if (dtp->u.p.current_unit->flags.pad == PAD_NO)\n \t    {\n-\t      generate_error (ERROR_EOR, NULL);\n+\t      generate_error (&dtp->common, ERROR_EOR, NULL);\n \t      return NULL;\n \t    }\n \n \t  *length = n;\n-\t  sf_seen_eor = 1;\n+\t  dtp->u.p.sf_seen_eor = 1;\n \t  break;\n \t}\n \n       n++;\n       *p++ = *q;\n-      sf_seen_eor = 0;\n+      dtp->u.p.sf_seen_eor = 0;\n     }\n   while (n < *length);\n-  current_unit->bytes_left -= *length;\n+  dtp->u.p.current_unit->bytes_left -= *length;\n \n-  if (ioparm.size != NULL)\n-    *ioparm.size += *length;\n+  if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n+    *dtp->size += *length;\n \n   return base;\n }\n@@ -242,41 +222,42 @@ read_sf (int *length)\n    short reads.  */\n \n void *\n-read_block (int *length)\n+read_block (st_parameter_dt *dtp, int *length)\n {\n   char *source;\n   int nread;\n \n-  if (current_unit->bytes_left < *length)\n+  if (dtp->u.p.current_unit->bytes_left < *length)\n     {\n-      if (current_unit->flags.pad == PAD_NO)\n+      if (dtp->u.p.current_unit->flags.pad == PAD_NO)\n \t{\n-\t  generate_error (ERROR_EOR, NULL); /* Not enough data left.  */\n+\t  generate_error (&dtp->common, ERROR_EOR, NULL);\n+\t  /* Not enough data left.  */\n \t  return NULL;\n \t}\n \n-      *length = current_unit->bytes_left;\n+      *length = dtp->u.p.current_unit->bytes_left;\n     }\n \n-  if (current_unit->flags.form == FORM_FORMATTED &&\n-      current_unit->flags.access == ACCESS_SEQUENTIAL)\n-    return read_sf (length);\t/* Special case.  */\n+  if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED &&\n+      dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)\n+    return read_sf (dtp, length);\t/* Special case.  */\n \n-  current_unit->bytes_left -= *length;\n+  dtp->u.p.current_unit->bytes_left -= *length;\n \n   nread = *length;\n-  source = salloc_r (current_unit->s, &nread);\n+  source = salloc_r (dtp->u.p.current_unit->s, &nread);\n \n-  if (ioparm.size != NULL)\n-    *ioparm.size += nread;\n+  if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n+    *dtp->size += nread;\n \n   if (nread != *length)\n     {\t\t\t\t/* Short read, this shouldn't happen.  */\n-      if (current_unit->flags.pad == PAD_YES)\n+      if (dtp->u.p.current_unit->flags.pad == PAD_YES)\n \t*length = nread;\n       else\n \t{\n-\t  generate_error (ERROR_EOR, NULL);\n+\t  generate_error (&dtp->common, ERROR_EOR, NULL);\n \t  source = NULL;\n \t}\n     }\n@@ -288,53 +269,54 @@ read_block (int *length)\n /* Reads a block directly into application data space.  */\n \n static void\n-read_block_direct (void * buf, size_t * nbytes)\n+read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n {\n   int *length;\n   void *data;\n   size_t nread;\n \n-  if (current_unit->bytes_left < *nbytes)\n+  if (dtp->u.p.current_unit->bytes_left < *nbytes)\n     {\n-      if (current_unit->flags.pad == PAD_NO)\n+      if (dtp->u.p.current_unit->flags.pad == PAD_NO)\n \t{\n-\t  generate_error (ERROR_EOR, NULL); /* Not enough data left.  */\n+\t  /* Not enough data left.  */\n+\t  generate_error (&dtp->common, ERROR_EOR, NULL);\n \t  return;\n \t}\n \n-      *nbytes = current_unit->bytes_left;\n+      *nbytes = dtp->u.p.current_unit->bytes_left;\n     }\n \n-  if (current_unit->flags.form == FORM_FORMATTED &&\n-      current_unit->flags.access == ACCESS_SEQUENTIAL)\n+  if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED &&\n+      dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)\n     {\n-      length = (int*) nbytes;\n-      data = read_sf (length);\t/* Special case.  */\n+      length = (int *) nbytes;\n+      data = read_sf (dtp, length);\t/* Special case.  */\n       memcpy (buf, data, (size_t) *length);\n       return;\n     }\n \n-  current_unit->bytes_left -= *nbytes;\n+  dtp->u.p.current_unit->bytes_left -= *nbytes;\n \n   nread = *nbytes;\n-  if (sread (current_unit->s, buf, &nread) != 0)\n+  if (sread (dtp->u.p.current_unit->s, buf, &nread) != 0)\n     {\n-      generate_error (ERROR_OS, NULL);\n+      generate_error (&dtp->common, ERROR_OS, NULL);\n       return;\n     }\n \n-  if (ioparm.size != NULL)\n-    *ioparm.size += (GFC_INTEGER_4) nread;\n+  if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n+    *dtp->size += (GFC_INTEGER_4) nread;\n \n   if (nread != *nbytes)\n     {\t\t\t\t/* Short read, e.g. if we hit EOF.  */\n-      if (current_unit->flags.pad == PAD_YES)\n+      if (dtp->u.p.current_unit->flags.pad == PAD_YES)\n \t{\n \t  memset (((char *) buf) + nread, ' ', *nbytes - nread);\n \t  *nbytes = nread;\n \t}\n       else\n-\tgenerate_error (ERROR_EOR, NULL);\n+\tgenerate_error (&dtp->common, ERROR_EOR, NULL);\n     }\n }\n \n@@ -345,27 +327,27 @@ read_block_direct (void * buf, size_t * nbytes)\n    fill in.  Returns NULL on error.  */\n \n void *\n-write_block (int length)\n+write_block (st_parameter_dt *dtp, int length)\n {\n   char *dest;\n   \n-  if (current_unit->bytes_left < length)\n+  if (dtp->u.p.current_unit->bytes_left < length)\n     {\n-      generate_error (ERROR_EOR, NULL);\n+      generate_error (&dtp->common, ERROR_EOR, NULL);\n       return NULL;\n     }\n \n-  current_unit->bytes_left -= (gfc_offset)length;\n-  dest = salloc_w (current_unit->s, &length);\n+  dtp->u.p.current_unit->bytes_left -= (gfc_offset) length;\n+  dest = salloc_w (dtp->u.p.current_unit->s, &length);\n   \n   if (dest == NULL)\n     {\n-      generate_error (ERROR_END, NULL);\n+      generate_error (&dtp->common, ERROR_END, NULL);\n       return NULL;\n     }\n \n-  if (ioparm.size != NULL)\n-    *ioparm.size += length;\n+  if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n+    *dtp->size += length;\n \n   return dest;\n }\n@@ -375,44 +357,44 @@ write_block (int length)\n    buffer.  */\n \n static void\n-write_block_direct (void * buf, size_t * nbytes)\n+write_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n {\n-  if (current_unit->bytes_left < *nbytes)\n-    generate_error (ERROR_EOR, NULL);\n+  if (dtp->u.p.current_unit->bytes_left < *nbytes)\n+    generate_error (&dtp->common, ERROR_EOR, NULL);\n \n-  current_unit->bytes_left -= (gfc_offset) *nbytes;\n+  dtp->u.p.current_unit->bytes_left -= (gfc_offset) *nbytes;\n \n-  if (swrite (current_unit->s, buf, nbytes) != 0)\n-    generate_error (ERROR_OS, NULL);\n+  if (swrite (dtp->u.p.current_unit->s, buf, nbytes) != 0)\n+    generate_error (&dtp->common, ERROR_OS, NULL);\n \n-  if (ioparm.size != NULL)\n-    *ioparm.size += (GFC_INTEGER_4) *nbytes;\n+  if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n+    *dtp->size += (GFC_INTEGER_4) *nbytes;\n }\n \n \n /* Master function for unformatted reads.  */\n \n static void\n-unformatted_read (bt type __attribute__((unused)), void *dest,\n-                 int kind __attribute__((unused)),\n-                 size_t size, size_t nelems)\n+unformatted_read (st_parameter_dt *dtp, bt type __attribute__((unused)),\n+\t\t  void *dest, int kind __attribute__((unused)),\n+\t\t  size_t size, size_t nelems)\n {\n   size *= nelems;\n \n-  read_block_direct (dest, &size);\n+  read_block_direct (dtp, dest, &size);\n }\n \n \n /* Master function for unformatted writes.  */\n \n static void\n-unformatted_write (bt type __attribute__((unused)), void *source,\n-                  int kind __attribute__((unused)),\n-                  size_t size, size_t nelems)\n+unformatted_write (st_parameter_dt *dtp, bt type __attribute__((unused)),\n+\t\t   void *source, int kind __attribute__((unused)),\n+\t\t   size_t size, size_t nelems)\n {\n   size *= nelems;\n \n-  write_block_direct (source, &size);\n+  write_block_direct (dtp, source, &size);\n }\n \n \n@@ -441,7 +423,7 @@ type_name (bt type)\n       p = \"COMPLEX\";\n       break;\n     default:\n-      internal_error (\"type_name(): Bad type\");\n+      internal_error (NULL, \"type_name(): Bad type\");\n     }\n \n   return p;\n@@ -453,7 +435,7 @@ type_name (bt type)\n    in it.  The length in the format node is the true length.  */\n \n static void\n-write_constant_string (fnode * f)\n+write_constant_string (st_parameter_dt *dtp, const fnode *f)\n {\n   char c, delimiter, *p, *q;\n   int length;\n@@ -462,7 +444,7 @@ write_constant_string (fnode * f)\n   if (length == 0)\n     return;\n \n-  p = write_block (length);\n+  p = write_block (dtp, length);\n   if (p == NULL)\n     return;\n \n@@ -483,17 +465,17 @@ write_constant_string (fnode * f)\n    nonzero if something went wrong.  */\n \n static int\n-require_type (bt expected, bt actual, fnode * f)\n+require_type (st_parameter_dt *dtp, bt expected, bt actual, const fnode *f)\n {\n   char buffer[100];\n \n   if (actual == expected)\n     return 0;\n \n   st_sprintf (buffer, \"Expected %s for item %d in formatted transfer, got %s\",\n-\t      type_name (expected), g.item_count, type_name (actual));\n+\t      type_name (expected), dtp->u.p.item_count, type_name (actual));\n \n-  format_error (f, buffer);\n+  format_error (dtp, f, buffer);\n   return 1;\n }\n \n@@ -507,10 +489,12 @@ require_type (bt expected, bt actual, fnode * f)\n    of the next element, then comes back here to process it.  */\n \n static void\n-formatted_transfer_scalar (bt type, void *p, int len, size_t size)\n+formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n+\t\t\t   size_t size)\n {\n+  char scratch[SCRATCH_SIZE];\n   int pos, bytes_used;\n-  fnode *f;\n+  const fnode *f;\n   format_token t;\n   int n;\n   int consume_data_flag;\n@@ -526,206 +510,208 @@ formatted_transfer_scalar (bt type, void *p, int len, size_t size)\n \n   /* If there's an EOR condition, we simulate finalizing the transfer\n      by doing nothing.  */\n-  if (eor_condition)\n+  if (dtp->u.p.eor_condition)\n     return;\n \n+  dtp->u.p.line_buffer = scratch;\n   for (;;)\n     {\n       /* If reversion has occurred and there is another real data item,\n \t then we have to move to the next record.  */\n-      if (g.reversion_flag && n > 0)\n+      if (dtp->u.p.reversion_flag && n > 0)\n \t{\n-\t  g.reversion_flag = 0;\n-\t  next_record (0);\n+\t  dtp->u.p.reversion_flag = 0;\n+\t  next_record (dtp, 0);\n \t}\n \n       consume_data_flag = 1 ;\n-      if (ioparm.library_return != LIBRARY_OK)\n+      if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n \tbreak;\n \n-      f = next_format ();\n+      f = next_format (dtp);\n       if (f == NULL)\n \treturn;\t      /* No data descriptors left (already raised).  */\n \n       /* Now discharge T, TR and X movements to the right.  This is delayed\n \t until a data producing format to suppress trailing spaces.  */\n \t \n       t = f->format;\n-      if (g.mode == WRITING && skips != 0\n+      if (dtp->u.p.mode == WRITING && dtp->u.p.skips != 0\n \t&& ((n>0 && (  t == FMT_I  || t == FMT_B  || t == FMT_O\n \t\t    || t == FMT_Z  || t == FMT_F  || t == FMT_E\n \t\t    || t == FMT_EN || t == FMT_ES || t == FMT_G\n \t\t    || t == FMT_L  || t == FMT_A  || t == FMT_D))\n \t    || t == FMT_STRING))\n \t{\n-\t  if (skips > 0)\n+\t  if (dtp->u.p.skips > 0)\n \t    {\n-\t      write_x (skips, pending_spaces);\n-\t      max_pos = (int)(current_unit->recl - current_unit->bytes_left);\n+\t      write_x (dtp, dtp->u.p.skips, dtp->u.p.pending_spaces);\n+\t      dtp->u.p.max_pos = (int)(dtp->u.p.current_unit->recl\n+\t\t\t\t       - dtp->u.p.current_unit->bytes_left);\n \t    }\n-\t  if (skips < 0)\n+\t  if (dtp->u.p.skips < 0)\n \t    {\n-\t      move_pos_offset (current_unit->s, skips);\n-\t      current_unit->bytes_left -= (gfc_offset)skips;\n+\t      move_pos_offset (dtp->u.p.current_unit->s, dtp->u.p.skips);\n+\t      dtp->u.p.current_unit->bytes_left -= (gfc_offset) dtp->u.p.skips;\n \t    }\n-\t  skips = pending_spaces = 0;\n+\t  dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n \t}\n \n-      bytes_used = (int)(current_unit->recl - current_unit->bytes_left);\n+      bytes_used = (int)(dtp->u.p.current_unit->recl - dtp->u.p.current_unit->bytes_left);\n \n       switch (t)\n \t{\n \tcase FMT_I:\n \t  if (n == 0)\n \t    goto need_data;\n-\t  if (require_type (BT_INTEGER, type, f))\n+\t  if (require_type (dtp, BT_INTEGER, type, f))\n \t    return;\n \n-\t  if (g.mode == READING)\n-\t    read_decimal (f, p, len);\n+\t  if (dtp->u.p.mode == READING)\n+\t    read_decimal (dtp, f, p, len);\n \t  else\n-\t    write_i (f, p, len);\n+\t    write_i (dtp, f, p, len);\n \n \t  break;\n \n \tcase FMT_B:\n \t  if (n == 0)\n \t    goto need_data;\n-\t  if (require_type (BT_INTEGER, type, f))\n+\t  if (require_type (dtp, BT_INTEGER, type, f))\n \t    return;\n \n-\t  if (g.mode == READING)\n-\t    read_radix (f, p, len, 2);\n+\t  if (dtp->u.p.mode == READING)\n+\t    read_radix (dtp, f, p, len, 2);\n \t  else\n-\t    write_b (f, p, len);\n+\t    write_b (dtp, f, p, len);\n \n \t  break;\n \n \tcase FMT_O:\n \t  if (n == 0)\n \t    goto need_data;\n \n-\t  if (g.mode == READING)\n-\t    read_radix (f, p, len, 8);\n+\t  if (dtp->u.p.mode == READING)\n+\t    read_radix (dtp, f, p, len, 8);\n \t  else\n-\t    write_o (f, p, len);\n+\t    write_o (dtp, f, p, len);\n \n \t  break;\n \n \tcase FMT_Z:\n \t  if (n == 0)\n \t    goto need_data;\n \n-\t  if (g.mode == READING)\n-\t    read_radix (f, p, len, 16);\n+\t  if (dtp->u.p.mode == READING)\n+\t    read_radix (dtp, f, p, len, 16);\n \t  else\n-\t    write_z (f, p, len);\n+\t    write_z (dtp, f, p, len);\n \n \t  break;\n \n \tcase FMT_A:\n \t  if (n == 0)\n \t    goto need_data;\n \n-\t  if (g.mode == READING)\n-\t    read_a (f, p, len);\n+\t  if (dtp->u.p.mode == READING)\n+\t    read_a (dtp, f, p, len);\n \t  else\n-\t    write_a (f, p, len);\n+\t    write_a (dtp, f, p, len);\n \n \t  break;\n \n \tcase FMT_L:\n \t  if (n == 0)\n \t    goto need_data;\n \n-\t  if (g.mode == READING)\n-\t    read_l (f, p, len);\n+\t  if (dtp->u.p.mode == READING)\n+\t    read_l (dtp, f, p, len);\n \t  else\n-\t    write_l (f, p, len);\n+\t    write_l (dtp, f, p, len);\n \n \t  break;\n \n \tcase FMT_D:\n \t  if (n == 0)\n \t    goto need_data;\n-\t  if (require_type (BT_REAL, type, f))\n+\t  if (require_type (dtp, BT_REAL, type, f))\n \t    return;\n \n-\t  if (g.mode == READING)\n-\t    read_f (f, p, len);\n+\t  if (dtp->u.p.mode == READING)\n+\t    read_f (dtp, f, p, len);\n \t  else\n-\t    write_d (f, p, len);\n+\t    write_d (dtp, f, p, len);\n \n \t  break;\n \n \tcase FMT_E:\n \t  if (n == 0)\n \t    goto need_data;\n-\t  if (require_type (BT_REAL, type, f))\n+\t  if (require_type (dtp, BT_REAL, type, f))\n \t    return;\n \n-\t  if (g.mode == READING)\n-\t    read_f (f, p, len);\n+\t  if (dtp->u.p.mode == READING)\n+\t    read_f (dtp, f, p, len);\n \t  else\n-\t    write_e (f, p, len);\n+\t    write_e (dtp, f, p, len);\n \t  break;\n \n \tcase FMT_EN:\n \t  if (n == 0)\n \t    goto need_data;\n-\t  if (require_type (BT_REAL, type, f))\n+\t  if (require_type (dtp, BT_REAL, type, f))\n \t    return;\n \n-\t  if (g.mode == READING)\n-\t    read_f (f, p, len);\n+\t  if (dtp->u.p.mode == READING)\n+\t    read_f (dtp, f, p, len);\n \t  else\n-\t    write_en (f, p, len);\n+\t    write_en (dtp, f, p, len);\n \n \t  break;\n \n \tcase FMT_ES:\n \t  if (n == 0)\n \t    goto need_data;\n-\t  if (require_type (BT_REAL, type, f))\n+\t  if (require_type (dtp, BT_REAL, type, f))\n \t    return;\n \n-\t  if (g.mode == READING)\n-\t    read_f (f, p, len);\n+\t  if (dtp->u.p.mode == READING)\n+\t    read_f (dtp, f, p, len);\n \t  else\n-\t    write_es (f, p, len);\n+\t    write_es (dtp, f, p, len);\n \n \t  break;\n \n \tcase FMT_F:\n \t  if (n == 0)\n \t    goto need_data;\n-\t  if (require_type (BT_REAL, type, f))\n+\t  if (require_type (dtp, BT_REAL, type, f))\n \t    return;\n \n-\t  if (g.mode == READING)\n-\t    read_f (f, p, len);\n+\t  if (dtp->u.p.mode == READING)\n+\t    read_f (dtp, f, p, len);\n \t  else\n-\t    write_f (f, p, len);\n+\t    write_f (dtp, f, p, len);\n \n \t  break;\n \n \tcase FMT_G:\n \t  if (n == 0)\n \t    goto need_data;\n-\t  if (g.mode == READING)\n+\t  if (dtp->u.p.mode == READING)\n \t    switch (type)\n \t      {\n \t      case BT_INTEGER:\n-\t\tread_decimal (f, p, len);\n+\t\tread_decimal (dtp, f, p, len);\n \t\tbreak;\n \t      case BT_LOGICAL:\n-\t\tread_l (f, p, len);\n+\t\tread_l (dtp, f, p, len);\n \t\tbreak;\n \t      case BT_CHARACTER:\n-\t\tread_a (f, p, len);\n+\t\tread_a (dtp, f, p, len);\n \t\tbreak;\n \t      case BT_REAL:\n-\t\tread_f (f, p, len);\n+\t\tread_f (dtp, f, p, len);\n \t\tbreak;\n \t      default:\n \t\tgoto bad_type;\n@@ -734,54 +720,56 @@ formatted_transfer_scalar (bt type, void *p, int len, size_t size)\n \t    switch (type)\n \t      {\n \t      case BT_INTEGER:\n-\t\twrite_i (f, p, len);\n+\t\twrite_i (dtp, f, p, len);\n \t\tbreak;\n \t      case BT_LOGICAL:\n-\t\twrite_l (f, p, len);\n+\t\twrite_l (dtp, f, p, len);\n \t\tbreak;\n \t      case BT_CHARACTER:\n-\t\twrite_a (f, p, len);\n+\t\twrite_a (dtp, f, p, len);\n \t\tbreak;\n \t      case BT_REAL:\n-\t\twrite_d (f, p, len);\n+\t\twrite_d (dtp, f, p, len);\n \t\tbreak;\n \t      default:\n \t      bad_type:\n-\t\tinternal_error (\"formatted_transfer(): Bad type\");\n+\t\tinternal_error (&dtp->common,\n+\t\t\t\t\"formatted_transfer(): Bad type\");\n \t      }\n \n \t  break;\n \n \tcase FMT_STRING:\n \t  consume_data_flag = 0 ;\n-\t  if (g.mode == READING)\n+\t  if (dtp->u.p.mode == READING)\n \t    {\n-\t      format_error (f, \"Constant string in input format\");\n+\t      format_error (dtp, f, \"Constant string in input format\");\n \t      return;\n \t    }\n-\t  write_constant_string (f);\n+\t  write_constant_string (dtp, f);\n \t  break;\n \n \t/* Format codes that don't transfer data.  */\n \tcase FMT_X:\n \tcase FMT_TR:\n \t  consume_data_flag = 0 ;\n \n-\t  pos = bytes_used + f->u.n + skips;\n-\t  skips = f->u.n + skips;\n-\t  pending_spaces = pos - max_pos;\n+\t  pos = bytes_used + f->u.n + dtp->u.p.skips;\n+\t  dtp->u.p.skips = f->u.n + dtp->u.p.skips;\n+\t  dtp->u.p.pending_spaces = pos - dtp->u.p.max_pos;\n \n \t  /* Writes occur just before the switch on f->format, above, so\n \t     that trailing blanks are suppressed, unless we are doing a\n \t     non-advancing write in which case we want to output the blanks\n \t     now.  */\n-\t  if (g.mode == WRITING && advance_status == ADVANCE_NO)\n+\t  if (dtp->u.p.mode == WRITING\n+\t      && dtp->u.p.advance_status == ADVANCE_NO)\n \t    {\n-\t      write_x (skips, pending_spaces);\n-\t      skips = pending_spaces = 0;\n+\t      write_x (dtp, dtp->u.p.skips, dtp->u.p.pending_spaces);\n+\t      dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n \t    }\n-\t  if (g.mode == READING)\n-\t    read_x (f->u.n);\n+\t  if (dtp->u.p.mode == READING)\n+\t    read_x (dtp, f->u.n);\n \n \t  break;\n \n@@ -801,75 +789,77 @@ formatted_transfer_scalar (bt type, void *p, int len, size_t size)\n \t     bring us back again.  */\n \t  pos = pos < 0 ? 0 : pos;\n \n-\t  skips = skips + pos - bytes_used;\n-\t  pending_spaces =  pending_spaces + pos - max_pos;\n+\t  dtp->u.p.skips = dtp->u.p.skips + pos - bytes_used;\n+\t  dtp->u.p.pending_spaces = dtp->u.p.pending_spaces\n+\t\t\t\t    + pos - dtp->u.p.max_pos;\n \n-\t  if (skips == 0)\n+\t  if (dtp->u.p.skips == 0)\n \t    break;\n \n \t  /* Writes occur just before the switch on f->format, above, so that\n \t     trailing blanks are suppressed.  */\n-\t  if (g.mode == READING)\n+\t  if (dtp->u.p.mode == READING)\n \t    {\n \t      /* Adjust everything for end-of-record condition */\n-\t      if (sf_seen_eor && !is_internal_unit())\n+\t      if (dtp->u.p.sf_seen_eor && !is_internal_unit (dtp))\n \t\t{\n-\t\t  current_unit->bytes_left--;\n+\t\t  dtp->u.p.current_unit->bytes_left--;\n \t\t  bytes_used = pos;\n-\t\t  sf_seen_eor = 0;\n-\t\t  skips--;\n+\t\t  dtp->u.p.sf_seen_eor = 0;\n+\t\t  dtp->u.p.skips--;\n \t\t}\n-\t      if (skips < 0)\n+\t      if (dtp->u.p.skips < 0)\n \t\t{\n-\t\t  move_pos_offset (current_unit->s, skips);\n-\t\t  current_unit->bytes_left -= (gfc_offset)skips;\n-\t\t  skips = pending_spaces = 0;\n+\t\t  move_pos_offset (dtp->u.p.current_unit->s, dtp->u.p.skips);\n+\t\t  dtp->u.p.current_unit->bytes_left\n+\t\t    -= (gfc_offset) dtp->u.p.skips;\n+\t\t  dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n \t\t}\n \t      else\n-\t\tread_x (skips);\n+\t\tread_x (dtp, dtp->u.p.skips);\n \t    }\n \n \t  break;\n \n \tcase FMT_S:\n \t  consume_data_flag = 0 ;\n-\t  g.sign_status = SIGN_S;\n+\t  dtp->u.p.sign_status = SIGN_S;\n \t  break;\n \n \tcase FMT_SS:\n \t  consume_data_flag = 0 ;\n-\t  g.sign_status = SIGN_SS;\n+\t  dtp->u.p.sign_status = SIGN_SS;\n \t  break;\n \n \tcase FMT_SP:\n \t  consume_data_flag = 0 ;\n-\t  g.sign_status = SIGN_SP;\n+\t  dtp->u.p.sign_status = SIGN_SP;\n \t  break;\n \n \tcase FMT_BN:\n \t  consume_data_flag = 0 ;\n-\t  g.blank_status = BLANK_NULL;\n+\t  dtp->u.p.blank_status = BLANK_NULL;\n \t  break;\n \n \tcase FMT_BZ:\n \t  consume_data_flag = 0 ;\n-\t  g.blank_status = BLANK_ZERO;\n+\t  dtp->u.p.blank_status = BLANK_ZERO;\n \t  break;\n \n \tcase FMT_P:\n \t  consume_data_flag = 0 ;\n-\t  g.scale_factor = f->u.k;\n+\t  dtp->u.p.scale_factor = f->u.k;\n \t  break;\n \n \tcase FMT_DOLLAR:\n \t  consume_data_flag = 0 ;\n-\t  g.seen_dollar = 1;\n+\t  dtp->u.p.seen_dollar = 1;\n \t  break;\n \n \tcase FMT_SLASH:\n \t  consume_data_flag = 0 ;\n-\t  skips = pending_spaces = 0;\n-\t  next_record (0);\n+\t  dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n+\t  next_record (dtp, 0);\n \t  break;\n \n \tcase FMT_COLON:\n@@ -883,17 +873,17 @@ formatted_transfer_scalar (bt type, void *p, int len, size_t size)\n \t  break;\n \n \tdefault:\n-\t  internal_error (\"Bad format node\");\n+\t  internal_error (&dtp->common, \"Bad format node\");\n \t}\n \n       /* Free a buffer that we had to allocate during a sequential\n \t formatted read of a block that was larger than the static\n \t buffer.  */\n \n-      if (line_buffer != NULL)\n+      if (dtp->u.p.line_buffer != scratch)\n \t{\n-\t  free_mem (line_buffer);\n-\t  line_buffer = NULL;\n+\t  free_mem (dtp->u.p.line_buffer);\n+\t  dtp->u.p.line_buffer = scratch;\n \t}\n \n       /* Adjust the item count and data pointer.  */\n@@ -904,11 +894,11 @@ formatted_transfer_scalar (bt type, void *p, int len, size_t size)\n \tp = ((char *) p) + size;\n       }\n \n-      if (g.mode == READING)\n-\tskips = 0;\n+      if (dtp->u.p.mode == READING)\n+\tdtp->u.p.skips = 0;\n \n-      pos = (int)(current_unit->recl - current_unit->bytes_left);\n-      max_pos = (max_pos > pos) ? max_pos : pos;\n+      pos = (int)(dtp->u.p.current_unit->recl - dtp->u.p.current_unit->bytes_left);\n+      dtp->u.p.max_pos = (dtp->u.p.max_pos > pos) ? dtp->u.p.max_pos : pos;\n \n     }\n \n@@ -918,11 +908,12 @@ formatted_transfer_scalar (bt type, void *p, int len, size_t size)\n      push the current format node back onto the input, then return and\n      let the user program call us back with the data.  */\n  need_data:\n-  unget_format (f);\n+  unget_format (dtp, f);\n }\n \n static void\n-formatted_transfer (bt type, void *p, int kind, size_t size, size_t nelems)\n+formatted_transfer (st_parameter_dt *dtp, bt type, void *p, int kind,\n+\t\t    size_t size, size_t nelems)\n {\n   size_t elem;\n   char *tmp;\n@@ -932,8 +923,8 @@ formatted_transfer (bt type, void *p, int kind, size_t size, size_t nelems)\n   /* Big loop over all the elements.  */\n   for (elem = 0; elem < nelems; elem++)\n     {\n-      g.item_count++;\n-      formatted_transfer_scalar (type, tmp + size*elem, kind, size);\n+      dtp->u.p.item_count++;\n+      formatted_transfer_scalar (dtp, type, tmp + size*elem, kind, size);\n     }\n }\n \n@@ -944,59 +935,60 @@ formatted_transfer (bt type, void *p, int kind, size_t size, size_t nelems)\n    share a common enum with the compiler.  */\n \n void\n-transfer_integer (void *p, int kind)\n+transfer_integer (st_parameter_dt *dtp, void *p, int kind)\n {\n-  if (ioparm.library_return != LIBRARY_OK)\n+  if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n     return;\n-  transfer (BT_INTEGER, p, kind, kind, 1);\n+  dtp->u.p.transfer (dtp, BT_INTEGER, p, kind, kind, 1);\n }\n \n \n void\n-transfer_real (void *p, int kind)\n+transfer_real (st_parameter_dt *dtp, void *p, int kind)\n {\n   size_t size;\n-  if (ioparm.library_return != LIBRARY_OK)\n+  if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n     return;\n   size = size_from_real_kind (kind);\n-  transfer (BT_REAL, p, kind, size, 1);\n+  dtp->u.p.transfer (dtp, BT_REAL, p, kind, size, 1);\n }\n \n \n void\n-transfer_logical (void *p, int kind)\n+transfer_logical (st_parameter_dt *dtp, void *p, int kind)\n {\n-  if (ioparm.library_return != LIBRARY_OK)\n+  if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n     return;\n-  transfer (BT_LOGICAL, p, kind, kind, 1);\n+  dtp->u.p.transfer (dtp, BT_LOGICAL, p, kind, kind, 1);\n }\n \n \n void\n-transfer_character (void *p, int len)\n+transfer_character (st_parameter_dt *dtp, void *p, int len)\n {\n-  if (ioparm.library_return != LIBRARY_OK)\n+  if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n     return;\n   /* Currently we support only 1 byte chars, and the library is a bit\n      confused of character kind vs. length, so we kludge it by setting\n      kind = length.  */\n-  transfer (BT_CHARACTER, p, len, len, 1);\n+  dtp->u.p.transfer (dtp, BT_CHARACTER, p, len, len, 1);\n }\n \n \n void\n-transfer_complex (void *p, int kind)\n+transfer_complex (st_parameter_dt *dtp, void *p, int kind)\n {\n   size_t size;\n-  if (ioparm.library_return != LIBRARY_OK)\n+  if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n     return;\n   size = size_from_complex_kind (kind);\n-  transfer (BT_COMPLEX, p, kind, size, 1);\n+  dtp->u.p.transfer (dtp, BT_COMPLEX, p, kind, size, 1);\n }\n \n \n void\n-transfer_array (gfc_array_char *desc, int kind, gfc_charlen_type charlen)\n+transfer_array (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n+\t\tgfc_charlen_type charlen)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -1006,7 +998,7 @@ transfer_array (gfc_array_char *desc, int kind, gfc_charlen_type charlen)\n   char *data;\n   bt iotype;\n \n-  if (ioparm.library_return != LIBRARY_OK)\n+  if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n     return;\n \n   type = GFC_DESCRIPTOR_TYPE (desc);\n@@ -1042,10 +1034,11 @@ transfer_array (gfc_array_char *desc, int kind, gfc_charlen_type charlen)\n       kind = charlen;\n       break;\n     case GFC_DTYPE_DERIVED:\n-      internal_error (\"Derived type I/O should have been handled via the frontend.\");\n+      internal_error (&dtp->common,\n+\t\t\"Derived type I/O should have been handled via the frontend.\");\n       break;\n     default:\n-      internal_error (\"transfer_array(): Bad type\");\n+      internal_error (&dtp->common, \"transfer_array(): Bad type\");\n     }\n \n   if (desc->dim[0].stride == 0)\n@@ -1077,7 +1070,7 @@ transfer_array (gfc_array_char *desc, int kind, gfc_charlen_type charlen)\n \n   while (data)\n     {\n-      transfer (iotype, data, kind, size, tsize);\n+      dtp->u.p.transfer (dtp, iotype, data, kind, size, tsize);\n       data += stride0 * size * tsize;\n       count[0] += tsize;\n       n = 0;\n@@ -1104,57 +1097,57 @@ transfer_array (gfc_array_char *desc, int kind, gfc_charlen_type charlen)\n /* Preposition a sequential unformatted file while reading.  */\n \n static void\n-us_read (void)\n+us_read (st_parameter_dt *dtp)\n {\n   char *p;\n   int n;\n   gfc_offset i;\n \n   n = sizeof (gfc_offset);\n-  p = salloc_r (current_unit->s, &n);\n+  p = salloc_r (dtp->u.p.current_unit->s, &n);\n \n   if (n == 0)\n     return;  /* end of file */\n \n   if (p == NULL || n != sizeof (gfc_offset))\n     {\n-      generate_error (ERROR_BAD_US, NULL);\n+      generate_error (&dtp->common, ERROR_BAD_US, NULL);\n       return;\n     }\n \n   memcpy (&i, p, sizeof (gfc_offset));\n-  current_unit->bytes_left = i;\n+  dtp->u.p.current_unit->bytes_left = i;\n }\n \n \n /* Preposition a sequential unformatted file while writing.  This\n    amount to writing a bogus length that will be filled in later.  */\n \n static void\n-us_write (void)\n+us_write (st_parameter_dt *dtp)\n {\n   char *p;\n   int length;\n \n   length = sizeof (gfc_offset);\n-  p = salloc_w (current_unit->s, &length);\n+  p = salloc_w (dtp->u.p.current_unit->s, &length);\n \n   if (p == NULL)\n     {\n-      generate_error (ERROR_OS, NULL);\n+      generate_error (&dtp->common, ERROR_OS, NULL);\n       return;\n     }\n \n   memset (p, '\\0', sizeof (gfc_offset));\t/* Bogus value for now.  */\n-  if (sfree (current_unit->s) == FAILURE)\n-    generate_error (ERROR_OS, NULL);\n+  if (sfree (dtp->u.p.current_unit->s) == FAILURE)\n+    generate_error (&dtp->common, ERROR_OS, NULL);\n \n   /* For sequential unformatted, we write until we have more bytes than\n      can fit in the record markers. If disk space runs out first, it will\n      error on the write.  */\n-  current_unit->recl = g.max_offset;\n+  dtp->u.p.current_unit->recl = max_offset;\n \n-  current_unit->bytes_left = current_unit->recl;\n+  dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n }\n \n \n@@ -1163,301 +1156,312 @@ us_write (void)\n    record.  */\n \n static void\n-pre_position (void)\n+pre_position (st_parameter_dt *dtp)\n {\n-  if (current_unit->current_record)\n+  if (dtp->u.p.current_unit->current_record)\n     return;\t\t\t/* Already positioned.  */\n \n-  switch (current_mode ())\n+  switch (current_mode (dtp))\n     {\n     case UNFORMATTED_SEQUENTIAL:\n-      if (g.mode == READING)\n-\tus_read ();\n+      if (dtp->u.p.mode == READING)\n+\tus_read (dtp);\n       else\n-\tus_write ();\n+\tus_write (dtp);\n \n       break;\n \n     case FORMATTED_SEQUENTIAL:\n     case FORMATTED_DIRECT:\n     case UNFORMATTED_DIRECT:\n-      current_unit->bytes_left = current_unit->recl;\n+      dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n       break;\n     }\n \n-  current_unit->current_record = 1;\n+  dtp->u.p.current_unit->current_record = 1;\n }\n \n \n /* Initialize things for a data transfer.  This code is common for\n    both reading and writing.  */\n \n static void\n-data_transfer_init (int read_flag)\n+data_transfer_init (st_parameter_dt *dtp, int read_flag)\n {\n   unit_flags u_flags;  /* Used for creating a unit if needed.  */\n+  GFC_INTEGER_4 cf = dtp->common.flags;\n+  namelist_info *ionml;\n \n-  g.mode = read_flag ? READING : WRITING;\n+  ionml = ((cf & IOPARM_DT_IONML_SET) != 0) ? dtp->u.p.ionml : NULL;\n+  memset (&dtp->u.p, 0, sizeof (dtp->u.p));\n+  dtp->u.p.ionml = ionml;\n+  dtp->u.p.mode = read_flag ? READING : WRITING;\n \n-  if (ioparm.size != NULL)\n-    *ioparm.size = 0;\t\t/* Initialize the count.  */\n+  if ((cf & IOPARM_DT_HAS_SIZE) != 0)\n+    *dtp->size = 0;\t\t/* Initialize the count.  */\n \n-  current_unit = get_unit (read_flag);\n-  if (current_unit == NULL)\n+  dtp->u.p.current_unit = get_unit (dtp, 1);\n+  if (dtp->u.p.current_unit->s == NULL)\n   {  /* Open the unit with some default flags.  */\n-     if (ioparm.unit < 0)\n+     st_parameter_open opp;\n+     if (dtp->common.unit < 0)\n      {\n-       generate_error (ERROR_BAD_OPTION, \"Bad unit number in OPEN statement\");\n-       library_end ();\n+       close_unit (dtp->u.p.current_unit);\n+       dtp->u.p.current_unit = NULL;\n+       generate_error (&dtp->common, ERROR_BAD_OPTION,\n+\t\t       \"Bad unit number in OPEN statement\");\n        return;\n      }\n      memset (&u_flags, '\\0', sizeof (u_flags));\n      u_flags.access = ACCESS_SEQUENTIAL;\n      u_flags.action = ACTION_READWRITE;\n      /* Is it unformatted?  */\n-     if (ioparm.format == NULL && !ioparm.list_format)\n+     if (!(cf & (IOPARM_DT_HAS_FORMAT | IOPARM_DT_LIST_FORMAT)))\n        u_flags.form = FORM_UNFORMATTED;\n      else\n        u_flags.form = FORM_UNSPECIFIED;\n      u_flags.delim = DELIM_UNSPECIFIED;\n      u_flags.blank = BLANK_UNSPECIFIED;\n      u_flags.pad = PAD_UNSPECIFIED;\n      u_flags.status = STATUS_UNKNOWN;\n-     new_unit(&u_flags);\n-     current_unit = get_unit (read_flag);\n+     opp.common = dtp->common;\n+     opp.common.flags &= IOPARM_COMMON_MASK;\n+     dtp->u.p.current_unit = new_unit (&opp, dtp->u.p.current_unit, &u_flags);\n+     dtp->common.flags &= ~IOPARM_COMMON_MASK;\n+     dtp->common.flags |= (opp.common.flags & IOPARM_COMMON_MASK);\n+     if (dtp->u.p.current_unit == NULL)\n+       return;\n   }\n \n-  if (current_unit == NULL)\n-    return;\n-\n   /* Check the action.  */\n \n-  if (read_flag && current_unit->flags.action == ACTION_WRITE)\n-    generate_error (ERROR_BAD_ACTION,\n+  if (read_flag && dtp->u.p.current_unit->flags.action == ACTION_WRITE)\n+    generate_error (&dtp->common, ERROR_BAD_ACTION,\n \t\t    \"Cannot read from file opened for WRITE\");\n \n-  if (!read_flag && current_unit->flags.action == ACTION_READ)\n-    generate_error (ERROR_BAD_ACTION, \"Cannot write to file opened for READ\");\n+  if (!read_flag && dtp->u.p.current_unit->flags.action == ACTION_READ)\n+    generate_error (&dtp->common, ERROR_BAD_ACTION,\n+\t\t    \"Cannot write to file opened for READ\");\n \n-  if (ioparm.library_return != LIBRARY_OK)\n+  if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n     return;\n \n+  dtp->u.p.first_item = 1;\n+\n   /* Check the format.  */\n \n-  if (ioparm.format)\n-    parse_format ();\n+  if ((cf & IOPARM_DT_HAS_FORMAT) != 0)\n+    parse_format (dtp);\n \n-  if (ioparm.library_return != LIBRARY_OK)\n+  if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n     return;\n \n-  if (current_unit->flags.form == FORM_UNFORMATTED\n-      && (ioparm.format != NULL || ioparm.list_format))\n-    generate_error (ERROR_OPTION_CONFLICT,\n+  if (dtp->u.p.current_unit->flags.form == FORM_UNFORMATTED\n+      && (cf & (IOPARM_DT_HAS_FORMAT | IOPARM_DT_LIST_FORMAT))\n+\t != 0)\n+    generate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n \t\t    \"Format present for UNFORMATTED data transfer\");\n \n-  if (ioparm.namelist_name != NULL && ionml != NULL)\n+  if ((cf & IOPARM_DT_HAS_NAMELIST_NAME) != 0 && dtp->u.p.ionml != NULL)\n      {\n-\tif(ioparm.format != NULL)\n-\t   generate_error (ERROR_OPTION_CONFLICT,\n+\tif ((cf & IOPARM_DT_HAS_FORMAT) != 0)\n+\t   generate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n \t\t    \"A format cannot be specified with a namelist\");\n      }\n-  else if (current_unit->flags.form == FORM_FORMATTED &&\n-\t   ioparm.format == NULL && !ioparm.list_format)\n-    generate_error (ERROR_OPTION_CONFLICT,\n+  else if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED &&\n+\t   !(cf & (IOPARM_DT_HAS_FORMAT | IOPARM_DT_LIST_FORMAT)))\n+    generate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n \t\t    \"Missing format for FORMATTED data transfer\");\n \n \n-  if (is_internal_unit () && current_unit->flags.form == FORM_UNFORMATTED)\n-    generate_error (ERROR_OPTION_CONFLICT,\n+  if (is_internal_unit (dtp)\n+      && dtp->u.p.current_unit->flags.form == FORM_UNFORMATTED)\n+    generate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n \t\t    \"Internal file cannot be accessed by UNFORMATTED data transfer\");\n \n   /* Check the record number.  */\n \n-  if (current_unit->flags.access == ACCESS_DIRECT && ioparm.rec == 0)\n+  if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT\n+      && (cf & IOPARM_DT_HAS_REC) == 0)\n     {\n-      generate_error (ERROR_MISSING_OPTION,\n+      generate_error (&dtp->common, ERROR_MISSING_OPTION,\n \t\t      \"Direct access data transfer requires record number\");\n       return;\n     }\n \n-  if (current_unit->flags.access == ACCESS_SEQUENTIAL && ioparm.rec != 0)\n+  if (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL\n+      && (cf & IOPARM_DT_HAS_REC) != 0)\n     {\n-      generate_error (ERROR_OPTION_CONFLICT,\n+      generate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n \t\t      \"Record number not allowed for sequential access data transfer\");\n       return;\n     }\n \n   /* Process the ADVANCE option.  */\n \n-  advance_status = (ioparm.advance == NULL) ? ADVANCE_UNSPECIFIED :\n-    find_option (ioparm.advance, ioparm.advance_len, advance_opt,\n-\t\t \"Bad ADVANCE parameter in data transfer statement\");\n+  dtp->u.p.advance_status\n+    = !(cf & IOPARM_DT_HAS_ADVANCE) ? ADVANCE_UNSPECIFIED :\n+      find_option (&dtp->common, dtp->advance, dtp->advance_len, advance_opt,\n+\t\t   \"Bad ADVANCE parameter in data transfer statement\");\n \n-  if (advance_status != ADVANCE_UNSPECIFIED)\n+  if (dtp->u.p.advance_status != ADVANCE_UNSPECIFIED)\n     {\n-      if (current_unit->flags.access == ACCESS_DIRECT)\n-\tgenerate_error (ERROR_OPTION_CONFLICT,\n+      if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)\n+\tgenerate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n \t\t\t\"ADVANCE specification conflicts with sequential access\");\n \n-      if (is_internal_unit ())\n-\tgenerate_error (ERROR_OPTION_CONFLICT,\n+      if (is_internal_unit (dtp))\n+\tgenerate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n \t\t\t\"ADVANCE specification conflicts with internal file\");\n \n-      if (ioparm.format == NULL || ioparm.list_format)\n-\tgenerate_error (ERROR_OPTION_CONFLICT,\n+      if ((cf & (IOPARM_DT_HAS_FORMAT | IOPARM_DT_LIST_FORMAT))\n+\t  != IOPARM_DT_HAS_FORMAT)\n+\tgenerate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n \t\t\t\"ADVANCE specification requires an explicit format\");\n     }\n \n   if (read_flag)\n     {\n-      if (ioparm.eor != 0 && advance_status != ADVANCE_NO)\n-\tgenerate_error (ERROR_MISSING_OPTION,\n+      if ((cf & IOPARM_EOR) != 0 && dtp->u.p.advance_status != ADVANCE_NO)\n+\tgenerate_error (&dtp->common, ERROR_MISSING_OPTION,\n \t\t\t\"EOR specification requires an ADVANCE specification of NO\");\n \n-      if (ioparm.size != NULL && advance_status != ADVANCE_NO)\n-\tgenerate_error (ERROR_MISSING_OPTION,\n+      if ((cf & IOPARM_DT_HAS_SIZE) != 0 && dtp->u.p.advance_status != ADVANCE_NO)\n+\tgenerate_error (&dtp->common, ERROR_MISSING_OPTION,\n \t\t\t\"SIZE specification requires an ADVANCE specification of NO\");\n \n     }\n   else\n     {\t\t\t\t/* Write constraints.  */\n-      if (ioparm.end != 0)\n-\tgenerate_error (ERROR_OPTION_CONFLICT,\n+      if ((cf & IOPARM_END) != 0)\n+\tgenerate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n \t\t\t\"END specification cannot appear in a write statement\");\n \n-      if (ioparm.eor != 0)\n-\tgenerate_error (ERROR_OPTION_CONFLICT,\n+      if ((cf & IOPARM_EOR) != 0)\n+\tgenerate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n \t\t\t\"EOR specification cannot appear in a write statement\");\n \n-      if (ioparm.size != 0)\n-\tgenerate_error (ERROR_OPTION_CONFLICT,\n+      if ((cf & IOPARM_DT_HAS_SIZE) != 0)\n+\tgenerate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n \t\t\t\"SIZE specification cannot appear in a write statement\");\n     }\n \n-  if (advance_status == ADVANCE_UNSPECIFIED)\n-    advance_status = ADVANCE_YES;\n-  if (ioparm.library_return != LIBRARY_OK)\n+  if (dtp->u.p.advance_status == ADVANCE_UNSPECIFIED)\n+    dtp->u.p.advance_status = ADVANCE_YES;\n+  if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n     return;\n \n   /* Sanity checks on the record number.  */\n \n-  if (ioparm.rec)\n+  if ((cf & IOPARM_DT_HAS_REC) != 0)\n     {\n-      if (ioparm.rec <= 0)\n+      if (dtp->rec <= 0)\n \t{\n-\t  generate_error (ERROR_BAD_OPTION, \"Record number must be positive\");\n+\t  generate_error (&dtp->common, ERROR_BAD_OPTION,\n+\t\t\t  \"Record number must be positive\");\n \t  return;\n \t}\n \n-      if (ioparm.rec >= current_unit->maxrec)\n+      if (dtp->rec >= dtp->u.p.current_unit->maxrec)\n \t{\n-\t  generate_error (ERROR_BAD_OPTION, \"Record number too large\");\n+\t  generate_error (&dtp->common, ERROR_BAD_OPTION,\n+\t\t\t  \"Record number too large\");\n \t  return;\n \t}\n \n       /* Check to see if we might be reading what we wrote before  */\n \n-      if (g.mode == READING && current_unit->mode  == WRITING)\n-\t flush(current_unit->s);\n+      if (dtp->u.p.mode == READING && dtp->u.p.current_unit->mode  == WRITING)\n+\t flush(dtp->u.p.current_unit->s);\n \n       /* Check whether the record exists to be read.  Only\n \t a partial record needs to exist.  */\n \n-      if (g.mode == READING && (ioparm.rec -1)\n-\t  * current_unit->recl >= file_length (current_unit->s))\n+      if (dtp->u.p.mode == READING && (dtp->rec -1)\n+\t  * dtp->u.p.current_unit->recl >= file_length (dtp->u.p.current_unit->s))\n \t{\n-\t  generate_error (ERROR_BAD_OPTION, \"Non-existing record number\");\n+\t  generate_error (&dtp->common, ERROR_BAD_OPTION,\n+\t\t\t  \"Non-existing record number\");\n \t  return;\n \t}\n \n       /* Position the file.  */\n-      if (sseek (current_unit->s,\n-\t       (ioparm.rec - 1) * current_unit->recl) == FAILURE)\n+      if (sseek (dtp->u.p.current_unit->s,\n+\t       (dtp->rec - 1) * dtp->u.p.current_unit->recl) == FAILURE)\n \t{\n-\t  generate_error (ERROR_OS, NULL);\n+\t  generate_error (&dtp->common, ERROR_OS, NULL);\n \t  return;\n \t}\n     }\n \n   /* Overwriting an existing sequential file ?\n      it is always safe to truncate the file on the first write */\n-  if (g.mode == WRITING\n-      && current_unit->flags.access == ACCESS_SEQUENTIAL\n-      && current_unit->last_record == 0 && !is_preconnected(current_unit->s))\n-\tstruncate(current_unit->s);\n+  if (dtp->u.p.mode == WRITING\n+      && dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL\n+      && dtp->u.p.current_unit->last_record == 0 && !is_preconnected(dtp->u.p.current_unit->s))\n+\tstruncate(dtp->u.p.current_unit->s);\n \n   /* Bugware for badly written mixed C-Fortran I/O.  */\n-  flush_if_preconnected(current_unit->s);\n+  flush_if_preconnected(dtp->u.p.current_unit->s);\n \n-  current_unit->mode = g.mode;\n+  dtp->u.p.current_unit->mode = dtp->u.p.mode;\n \n   /* Set the initial value of flags.  */\n \n-  g.blank_status = current_unit->flags.blank;\n-  g.sign_status = SIGN_S;\n-  g.scale_factor = 0;\n-  g.seen_dollar = 0;\n-  g.first_item = 1;\n-  g.item_count = 0;\n-  sf_seen_eor = 0;\n-  eor_condition = 0;\n+  dtp->u.p.blank_status = dtp->u.p.current_unit->flags.blank;\n+  dtp->u.p.sign_status = SIGN_S;\n \n-  pre_position ();\n+  pre_position (dtp);\n \n   /* Set up the subroutine that will handle the transfers.  */\n \n   if (read_flag)\n     {\n-      if (current_unit->flags.form == FORM_UNFORMATTED)\n-\ttransfer = unformatted_read;\n+      if (dtp->u.p.current_unit->flags.form == FORM_UNFORMATTED)\n+\tdtp->u.p.transfer = unformatted_read;\n       else\n \t{\n-\t  if (ioparm.list_format)\n-\t    {\n-\t       transfer = list_formatted_read;\n-\t       init_at_eol();\n-\t    }\n+\t  if ((cf & IOPARM_DT_LIST_FORMAT) != 0)\n+\t    dtp->u.p.transfer = list_formatted_read;\n \t  else\n-\t    transfer = formatted_transfer;\n+\t    dtp->u.p.transfer = formatted_transfer;\n \t}\n     }\n   else\n     {\n-      if (current_unit->flags.form == FORM_UNFORMATTED)\n-\ttransfer = unformatted_write;\n+      if (dtp->u.p.current_unit->flags.form == FORM_UNFORMATTED)\n+\tdtp->u.p.transfer = unformatted_write;\n       else\n \t{\n-\t  if (ioparm.list_format)\n-\t    transfer = list_formatted_write;\n+\t  if ((cf & IOPARM_DT_LIST_FORMAT) != 0)\n+\t    dtp->u.p.transfer = list_formatted_write;\n \t  else\n-\t    transfer = formatted_transfer;\n+\t    dtp->u.p.transfer = formatted_transfer;\n \t}\n     }\n \n   /* Make sure that we don't do a read after a nonadvancing write.  */\n \n   if (read_flag)\n     {\n-      if (current_unit->read_bad)\n+      if (dtp->u.p.current_unit->read_bad)\n \t{\n-\t  generate_error (ERROR_BAD_OPTION,\n+\t  generate_error (&dtp->common, ERROR_BAD_OPTION,\n \t\t\t  \"Cannot READ after a nonadvancing WRITE\");\n \t  return;\n \t}\n     }\n   else\n     {\n-      if (advance_status == ADVANCE_YES && !g.seen_dollar)\n-\tcurrent_unit->read_bad = 1;\n+      if (dtp->u.p.advance_status == ADVANCE_YES && !dtp->u.p.seen_dollar)\n+\tdtp->u.p.current_unit->read_bad = 1;\n     }\n \n-  /* Reset counters for T and X-editing.  */\n-  max_pos = skips = pending_spaces = 0;\n-\n   /* Start the data transfer if we are doing a formatted transfer.  */\n-  if (current_unit->flags.form == FORM_FORMATTED && !ioparm.list_format\n-      && ioparm.namelist_name == NULL && ionml == NULL)\n-    formatted_transfer (0, NULL, 0, 0, 1);\n+  if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED\n+      && ((cf & (IOPARM_DT_LIST_FORMAT | IOPARM_DT_HAS_NAMELIST_NAME)) == 0)\n+      && dtp->u.p.ionml == NULL)\n+    formatted_transfer (dtp, 0, NULL, 0, 0, 1);\n }\n \n /* Initialize an array_loop_spec given the array descriptor.  The function\n@@ -1489,15 +1493,15 @@ init_loop_spec (gfc_array_char *desc, array_loop_spec *ls)\n    negative strides. */\n    \n gfc_offset\n-next_array_record ( array_loop_spec * ls )\n+next_array_record (st_parameter_dt *dtp, array_loop_spec *ls)\n {\n   int i, carry;\n   gfc_offset index;\n   \n   carry = 1;\n   index = 0;\n   \n-  for (i = 0; i < current_unit->rank; i++)\n+  for (i = 0; i < dtp->u.p.current_unit->rank; i++)\n     {\n       if (carry)\n         {\n@@ -1522,99 +1526,100 @@ next_array_record ( array_loop_spec * ls )\n #define MAX_READ 4096\n \n static void\n-next_record_r (void)\n+next_record_r (st_parameter_dt *dtp)\n {\n   gfc_offset new, record;\n   int bytes_left, rlength, length;\n   char *p;\n \n-  switch (current_mode ())\n+  switch (current_mode (dtp))\n     {\n     case UNFORMATTED_SEQUENTIAL:\n-      current_unit->bytes_left += sizeof (gfc_offset);\t/* Skip over tail */\n+      dtp->u.p.current_unit->bytes_left += sizeof (gfc_offset);\t/* Skip over tail */\n \n       /* Fall through...  */\n \n     case FORMATTED_DIRECT:\n     case UNFORMATTED_DIRECT:\n-      if (current_unit->bytes_left == 0)\n+      if (dtp->u.p.current_unit->bytes_left == 0)\n \tbreak;\n \n-      if (is_seekable (current_unit->s))\n+      if (is_seekable (dtp->u.p.current_unit->s))\n \t{\n-\t  new = file_position (current_unit->s) + current_unit->bytes_left;\n+\t  new = file_position (dtp->u.p.current_unit->s) + dtp->u.p.current_unit->bytes_left;\n \n \t  /* Direct access files do not generate END conditions,\n \t     only I/O errors.  */\n-\t  if (sseek (current_unit->s, new) == FAILURE)\n-\t    generate_error (ERROR_OS, NULL);\n+\t  if (sseek (dtp->u.p.current_unit->s, new) == FAILURE)\n+\t    generate_error (&dtp->common, ERROR_OS, NULL);\n \n \t}\n       else\n \t{\t\t\t/* Seek by reading data.  */\n-\t  while (current_unit->bytes_left > 0)\n+\t  while (dtp->u.p.current_unit->bytes_left > 0)\n \t    {\n-\t      rlength = length = (MAX_READ > current_unit->bytes_left) ?\n-\t\tMAX_READ : current_unit->bytes_left;\n+\t      rlength = length = (MAX_READ > dtp->u.p.current_unit->bytes_left) ?\n+\t\tMAX_READ : dtp->u.p.current_unit->bytes_left;\n \n-\t      p = salloc_r (current_unit->s, &rlength);\n+\t      p = salloc_r (dtp->u.p.current_unit->s, &rlength);\n \t      if (p == NULL)\n \t\t{\n-\t\t  generate_error (ERROR_OS, NULL);\n+\t\t  generate_error (&dtp->common, ERROR_OS, NULL);\n \t\t  break;\n \t\t}\n \n-\t      current_unit->bytes_left -= length;\n+\t      dtp->u.p.current_unit->bytes_left -= length;\n \t    }\n \t}\n       break;\n \n     case FORMATTED_SEQUENTIAL:\n       length = 1;\n       /* sf_read has already terminated input because of an '\\n'  */\n-      if (sf_seen_eor)\n+      if (dtp->u.p.sf_seen_eor)\n \t{\n-\t  sf_seen_eor=0;\n+\t  dtp->u.p.sf_seen_eor = 0;\n \t  break;\n \t}\n \n-      if (is_internal_unit())\n+      if (is_internal_unit (dtp))\n \t{\n-\t  if (is_array_io())\n-\t  {\n-            record =  next_array_record (current_unit->ls);   \n-                 \n-            /* Now seek to this record.  */\n-            record = record * current_unit->recl;\n-            if (sseek (current_unit->s, record) == FAILURE)\n-              {\n-                generate_error (ERROR_OS, NULL);\n-                break;\n-              }\n-\t    current_unit->bytes_left = current_unit->recl;\n-          }\n-        else  \n-          {\n-\t    bytes_left = (int) current_unit->bytes_left;\n-\t    p = salloc_r (current_unit->s, &bytes_left);\n-\t    if (p != NULL)\n-\t      current_unit->bytes_left = current_unit->recl;\n-\t  } \n-\tbreak;\n+\t  if (is_array_io (dtp))\n+\t    {\n+\t      record = next_array_record (dtp, dtp->u.p.current_unit->ls);\n+\n+\t      /* Now seek to this record.  */\n+\t      record = record * dtp->u.p.current_unit->recl;\n+\t      if (sseek (dtp->u.p.current_unit->s, record) == FAILURE)\n+\t\t{\n+\t\t  generate_error (&dtp->common, ERROR_OS, NULL);\n+\t\t  break;\n+\t\t}\n+\t      dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n+\t    }\n+\t  else  \n+\t    {\n+\t      bytes_left = (int) dtp->u.p.current_unit->bytes_left;\n+\t      p = salloc_r (dtp->u.p.current_unit->s, &bytes_left);\n+\t      if (p != NULL)\n+\t\tdtp->u.p.current_unit->bytes_left\n+\t\t  = dtp->u.p.current_unit->recl;\n+\t    } \n+\t  break;\n \t}\n       else do\n \t{\n-\t  p = salloc_r (current_unit->s, &length);\n+\t  p = salloc_r (dtp->u.p.current_unit->s, &length);\n \n \t  if (p == NULL)\n \t    {\n-\t      generate_error (ERROR_OS, NULL);\n+\t      generate_error (&dtp->common, ERROR_OS, NULL);\n \t      break;\n \t    }\n \n \t  if (length == 0)\n \t    {\n-\t      current_unit->endfile = AT_ENDFILE;\n+\t      dtp->u.p.current_unit->endfile = AT_ENDFILE;\n \t      break;\n \t    }\n \t}\n@@ -1623,116 +1628,117 @@ next_record_r (void)\n       break;\n     }\n \n-  if (current_unit->flags.access == ACCESS_SEQUENTIAL)\n-    test_endfile (current_unit);\n+  if (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)\n+    test_endfile (dtp->u.p.current_unit);\n }\n \n \n /* Position to the next record in write mode.  */\n \n static void\n-next_record_w (void)\n+next_record_w (st_parameter_dt *dtp)\n {\n   gfc_offset c, m, record;\n   int bytes_left, length;\n   char *p;\n \n   /* Zero counters for X- and T-editing.  */\n-  max_pos = skips = pending_spaces = 0;\n+  dtp->u.p.max_pos = dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n \n-  switch (current_mode ())\n+  switch (current_mode (dtp))\n     {\n     case FORMATTED_DIRECT:\n-      if (current_unit->bytes_left == 0)\n+      if (dtp->u.p.current_unit->bytes_left == 0)\n \tbreak;\n \n-      length = current_unit->bytes_left;\n-      p = salloc_w (current_unit->s, &length);\n+      length = dtp->u.p.current_unit->bytes_left;\n+      p = salloc_w (dtp->u.p.current_unit->s, &length);\n \n       if (p == NULL)\n \tgoto io_error;\n \n-      memset (p, ' ', current_unit->bytes_left);\n-      if (sfree (current_unit->s) == FAILURE)\n+      memset (p, ' ', dtp->u.p.current_unit->bytes_left);\n+      if (sfree (dtp->u.p.current_unit->s) == FAILURE)\n \tgoto io_error;\n       break;\n \n     case UNFORMATTED_DIRECT:\n-      if (sfree (current_unit->s) == FAILURE)\n+      if (sfree (dtp->u.p.current_unit->s) == FAILURE)\n \tgoto io_error;\n       break;\n \n     case UNFORMATTED_SEQUENTIAL:\n-      m = current_unit->recl - current_unit->bytes_left; /* Bytes written.  */\n-      c = file_position (current_unit->s);\n+      /* Bytes written.  */\n+      m = dtp->u.p.current_unit->recl - dtp->u.p.current_unit->bytes_left;\n+      c = file_position (dtp->u.p.current_unit->s);\n \n       length = sizeof (gfc_offset);\n \n       /* Write the length tail.  */\n \n-      p = salloc_w (current_unit->s, &length);\n+      p = salloc_w (dtp->u.p.current_unit->s, &length);\n       if (p == NULL)\n \tgoto io_error;\n \n       memcpy (p, &m, sizeof (gfc_offset));\n-      if (sfree (current_unit->s) == FAILURE)\n+      if (sfree (dtp->u.p.current_unit->s) == FAILURE)\n \tgoto io_error;\n \n       /* Seek to the head and overwrite the bogus length with the real\n \t length.  */\n \n-      p = salloc_w_at (current_unit->s, &length, c - m - length);\n+      p = salloc_w_at (dtp->u.p.current_unit->s, &length, c - m - length);\n       if (p == NULL)\n-\tgenerate_error (ERROR_OS, NULL);\n+\tgenerate_error (&dtp->common, ERROR_OS, NULL);\n \n       memcpy (p, &m, sizeof (gfc_offset));\n-      if (sfree (current_unit->s) == FAILURE)\n+      if (sfree (dtp->u.p.current_unit->s) == FAILURE)\n \tgoto io_error;\n \n       /* Seek past the end of the current record.  */\n \n-      if (sseek (current_unit->s, c + sizeof (gfc_offset)) == FAILURE)\n+      if (sseek (dtp->u.p.current_unit->s, c + sizeof (gfc_offset)) == FAILURE)\n \tgoto io_error;\n \n       break;\n \n     case FORMATTED_SEQUENTIAL:\n \n-      if (current_unit->bytes_left == 0)\n+      if (dtp->u.p.current_unit->bytes_left == 0)\n \tbreak;\n \t\n-      if (is_internal_unit())\n+      if (is_internal_unit (dtp))\n \t{\n-\t  if (is_array_io())\n+\t  if (is_array_io (dtp))\n \t    {\n-\t      bytes_left = (int) current_unit->bytes_left;\n-\t      p = salloc_w (current_unit->s, &bytes_left);\n+\t      bytes_left = (int) dtp->u.p.current_unit->bytes_left;\n+\t      p = salloc_w (dtp->u.p.current_unit->s, &bytes_left);\n \t      if (p == NULL)\n \t\t{\n-\t\t  generate_error (ERROR_END, NULL);\n+\t\t  generate_error (&dtp->common, ERROR_END, NULL);\n \t\t  return;\n \t\t}\n-              memset(p, ' ', bytes_left);\n-              \n-              /* Now that the current record has been padded out,\n-                 determine where the next record in the array is. */\n-                 \n-              record =  next_array_record (current_unit->ls);   \n-               \n-              /* Now seek to this record */\n-              record = record * current_unit->recl;\n-              \n-              if (sseek (current_unit->s, record) == FAILURE)\n-                goto io_error;\n-                \n-              current_unit->bytes_left = current_unit->recl;\n+\t      memset(p, ' ', bytes_left);\n+\n+\t      /* Now that the current record has been padded out,\n+\t\t determine where the next record in the array is. */\n+\n+\t      record = next_array_record (dtp, dtp->u.p.current_unit->ls);\n+\n+\t      /* Now seek to this record */\n+\t      record = record * dtp->u.p.current_unit->recl;\n+\n+\t      if (sseek (dtp->u.p.current_unit->s, record) == FAILURE)\n+\t\tgoto io_error;\n+\n+\t      dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n \t    }\n \t  else\n \t    {\n \t      length = 1;\n-\t      p = salloc_w (current_unit->s, &length);\n-\t      if (p==NULL)\n-\t        goto io_error;\n+\t      p = salloc_w (dtp->u.p.current_unit->s, &length);\n+\t      if (p == NULL)\n+\t\tgoto io_error;\n \t    }\n  \t}\n       else\n@@ -1742,7 +1748,7 @@ next_record_w (void)\n #else\n \t  length = 1;\n #endif\n-\t  p = salloc_w (current_unit->s, &length);\n+\t  p = salloc_w (dtp->u.p.current_unit->s, &length);\n \t  if (p)\n \t    {  /* No new line for internal writes.  */\n #ifdef HAVE_CRLF\n@@ -1759,7 +1765,7 @@ next_record_w (void)\n       break;\n \n     io_error:\n-      generate_error (ERROR_OS, NULL);\n+      generate_error (&dtp->common, ERROR_OS, NULL);\n       break;\n     }\n }\n@@ -1770,33 +1776,33 @@ next_record_w (void)\n    the next record.  */\n \n void\n-next_record (int done)\n+next_record (st_parameter_dt *dtp, int done)\n {\n   gfc_offset fp; /* File position.  */\n \n-  current_unit->read_bad = 0;\n+  dtp->u.p.current_unit->read_bad = 0;\n \n-  if (g.mode == READING)\n-    next_record_r ();\n+  if (dtp->u.p.mode == READING)\n+    next_record_r (dtp);\n   else\n-    next_record_w ();\n+    next_record_w (dtp);\n \n   /* keep position up to date for INQUIRE */\n-  current_unit->flags.position = POSITION_ASIS;\n+  dtp->u.p.current_unit->flags.position = POSITION_ASIS;\n \n-  current_unit->current_record = 0;\n-  if (current_unit->flags.access == ACCESS_DIRECT)\n+  dtp->u.p.current_unit->current_record = 0;\n+  if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)\n    {\n-    fp = file_position (current_unit->s);\n+    fp = file_position (dtp->u.p.current_unit->s);\n     /* Calculate next record, rounding up partial records.  */\n-    current_unit->last_record = (fp + current_unit->recl - 1)\n-\t\t\t\t/ current_unit->recl;\n+    dtp->u.p.current_unit->last_record = (fp + dtp->u.p.current_unit->recl - 1)\n+\t\t\t\t/ dtp->u.p.current_unit->recl;\n    }\n   else\n-    current_unit->last_record++;\n+    dtp->u.p.current_unit->last_record++;\n \n   if (!done)\n-    pre_position ();\n+    pre_position (dtp);\n }\n \n \n@@ -1805,62 +1811,64 @@ next_record (int done)\n    stream associated with the unit.  */\n \n static void\n-finalize_transfer (void)\n+finalize_transfer (st_parameter_dt *dtp)\n {\n+  jmp_buf eof_jump;\n+  GFC_INTEGER_4 cf = dtp->common.flags;\n \n-  if (eor_condition)\n+  if (dtp->u.p.eor_condition)\n     {\n-      generate_error (ERROR_EOR, NULL);\n+      generate_error (&dtp->common, ERROR_EOR, NULL);\n       return;\n     }\n \n-  if (ioparm.library_return != LIBRARY_OK)\n+  if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n     return;\n \n-  if ((ionml != NULL) && (ioparm.namelist_name != NULL))\n+  if ((dtp->u.p.ionml != NULL)\n+      && (cf & IOPARM_DT_HAS_NAMELIST_NAME) != 0)\n     {\n-       if (ioparm.namelist_read_mode)\n-\t namelist_read();\n+       if ((cf & IOPARM_DT_NAMELIST_READ_MODE) != 0)\n+\t namelist_read (dtp);\n        else\n-\t namelist_write();\n+\t namelist_write (dtp);\n     }\n \n-  transfer = NULL;\n-  if (current_unit == NULL)\n+  dtp->u.p.transfer = NULL;\n+  if (dtp->u.p.current_unit == NULL)\n     return;\n \n-  if (setjmp (g.eof_jump))\n+  dtp->u.p.eof_jump = &eof_jump;\n+  if (setjmp (eof_jump))\n     {\n-      generate_error (ERROR_END, NULL);\n+      generate_error (&dtp->common, ERROR_END, NULL);\n       return;\n     }\n \n-  if (ioparm.list_format && g.mode == READING)\n-    finish_list_read ();\n+  if ((cf & IOPARM_DT_LIST_FORMAT) != 0 && dtp->u.p.mode == READING)\n+    finish_list_read (dtp);\n   else\n     {\n-      free_fnodes ();\n-\n-      if (advance_status == ADVANCE_NO || g.seen_dollar)\n+      if (dtp->u.p.advance_status == ADVANCE_NO || dtp->u.p.seen_dollar)\n \t{\n \t  /* Most systems buffer lines, so force the partial record\n \t     to be written out.  */\n-\t  flush (current_unit->s);\n-\t  g.seen_dollar = 0;\n+\t  flush (dtp->u.p.current_unit->s);\n+\t  dtp->u.p.seen_dollar = 0;\n \t  return;\n \t}\n \n-      next_record (1);\n-      current_unit->current_record = 0;\n+      next_record (dtp, 1);\n+      dtp->u.p.current_unit->current_record = 0;\n     }\n \n-  sfree (current_unit->s);\n+  sfree (dtp->u.p.current_unit->s);\n \n-  if (is_internal_unit ())\n+  if (is_internal_unit (dtp))\n     {\n-      if (is_array_io() && current_unit->ls != NULL)\n-        free_mem (current_unit->ls);\n-      sclose (current_unit->s);\n+      if (is_array_io (dtp) && dtp->u.p.current_unit->ls != NULL)\n+\tfree_mem (dtp->u.p.current_unit->ls);\n+      sclose (dtp->u.p.current_unit->s);\n     }\n }\n \n@@ -1869,13 +1877,13 @@ finalize_transfer (void)\n    data transfer, it just updates the length counter.  */\n \n static void\n-iolength_transfer (bt type __attribute__((unused)), \n+iolength_transfer (st_parameter_dt *dtp, bt type __attribute__((unused)), \n \t\t   void *dest __attribute__ ((unused)),\n \t\t   int kind __attribute__((unused)), \n \t\t   size_t size, size_t nelems)\n {\n-  if (ioparm.iolength != NULL)\n-    *ioparm.iolength += (GFC_INTEGER_4) size * nelems;\n+  if ((dtp->common.flags & IOPARM_DT_HAS_IOLENGTH) != 0)\n+    *dtp->iolength += (GFC_INTEGER_4) size * nelems;\n }\n \n \n@@ -1884,16 +1892,16 @@ iolength_transfer (bt type __attribute__((unused)),\n    doesn't have to deal with units at all.  */\n \n static void\n-iolength_transfer_init (void)\n+iolength_transfer_init (st_parameter_dt *dtp)\n {\n-  if (ioparm.iolength != NULL)\n-    *ioparm.iolength = 0;\n+  if ((dtp->common.flags & IOPARM_DT_HAS_IOLENGTH) != 0)\n+    *dtp->iolength = 0;\n \n-  g.item_count = 0;\n+  memset (&dtp->u.p, 0, sizeof (dtp->u.p));\n \n   /* Set up the subroutine that will handle the transfers.  */\n \n-  transfer = iolength_transfer;\n+  dtp->u.p.transfer = iolength_transfer;\n }\n \n \n@@ -1902,133 +1910,148 @@ iolength_transfer_init (void)\n    it must still be a runtime library call so that we can determine\n    the iolength for dynamic arrays and such.  */\n \n-extern void st_iolength (void);\n+extern void st_iolength (st_parameter_dt *);\n export_proto(st_iolength);\n \n void\n-st_iolength (void)\n+st_iolength (st_parameter_dt *dtp)\n {\n-  library_start ();\n-  iolength_transfer_init ();\n+  library_start (&dtp->common);\n+  iolength_transfer_init (dtp);\n }\n \n-extern void st_iolength_done (void);\n+extern void st_iolength_done (st_parameter_dt *);\n export_proto(st_iolength_done);\n \n void\n-st_iolength_done (void)\n+st_iolength_done (st_parameter_dt *dtp __attribute__((unused)))\n {\n+  free_ionml (dtp);\n+  if (dtp->u.p.scratch != NULL)\n+    free_mem (dtp->u.p.scratch);\n   library_end ();\n }\n \n \n /* The READ statement.  */\n \n-extern void st_read (void);\n+extern void st_read (st_parameter_dt *);\n export_proto(st_read);\n \n void\n-st_read (void)\n+st_read (st_parameter_dt *dtp)\n {\n \n-  library_start ();\n+  library_start (&dtp->common);\n \n-  data_transfer_init (1);\n+  data_transfer_init (dtp, 1);\n \n   /* Handle complications dealing with the endfile record.  It is\n      significant that this is the only place where ERROR_END is\n      generated.  Reading an end of file elsewhere is either end of\n      record or an I/O error. */\n \n-  if (current_unit->flags.access == ACCESS_SEQUENTIAL)\n-    switch (current_unit->endfile)\n+  if (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)\n+    switch (dtp->u.p.current_unit->endfile)\n       {\n       case NO_ENDFILE:\n \tbreak;\n \n       case AT_ENDFILE:\n-\tif (!is_internal_unit())\n+\tif (!is_internal_unit (dtp))\n \t  {\n-\t    generate_error (ERROR_END, NULL);\n-\t    current_unit->endfile = AFTER_ENDFILE;\n-\t    current_unit->current_record = 0;\n+\t    generate_error (&dtp->common, ERROR_END, NULL);\n+\t    dtp->u.p.current_unit->endfile = AFTER_ENDFILE;\n+\t    dtp->u.p.current_unit->current_record = 0;\n \t  }\n \tbreak;\n \n       case AFTER_ENDFILE:\n-\tgenerate_error (ERROR_ENDFILE, NULL);\n-\tcurrent_unit->current_record = 0;\n+\tgenerate_error (&dtp->common, ERROR_ENDFILE, NULL);\n+\tdtp->u.p.current_unit->current_record = 0;\n \tbreak;\n       }\n }\n \n-extern void st_read_done (void);\n+extern void st_read_done (st_parameter_dt *);\n export_proto(st_read_done);\n \n void\n-st_read_done (void)\n+st_read_done (st_parameter_dt *dtp)\n {\n-  finalize_transfer ();\n+  finalize_transfer (dtp);\n+  free_format_data (dtp);\n+  free_ionml (dtp);\n+  if (dtp->u.p.scratch != NULL)\n+    free_mem (dtp->u.p.scratch);\n+  if (dtp->u.p.current_unit != NULL)\n+    unlock_unit (dtp->u.p.current_unit);\n   library_end ();\n }\n \n-extern void st_write (void);\n+extern void st_write (st_parameter_dt *);\n export_proto(st_write);\n \n void\n-st_write (void)\n+st_write (st_parameter_dt *dtp)\n {\n-\n-  library_start ();\n-  data_transfer_init (0);\n+  library_start (&dtp->common);\n+  data_transfer_init (dtp, 0);\n }\n \n-extern void st_write_done (void);\n+extern void st_write_done (st_parameter_dt *);\n export_proto(st_write_done);\n \n void\n-st_write_done (void)\n+st_write_done (st_parameter_dt *dtp)\n {\n-  finalize_transfer ();\n+  finalize_transfer (dtp);\n \n   /* Deal with endfile conditions associated with sequential files.  */\n \n-  if (current_unit != NULL && current_unit->flags.access == ACCESS_SEQUENTIAL)\n-    switch (current_unit->endfile)\n+  if (dtp->u.p.current_unit != NULL && dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)\n+    switch (dtp->u.p.current_unit->endfile)\n       {\n       case AT_ENDFILE:\t\t/* Remain at the endfile record.  */\n \tbreak;\n \n       case AFTER_ENDFILE:\n-\tcurrent_unit->endfile = AT_ENDFILE;\t/* Just at it now.  */\n+\tdtp->u.p.current_unit->endfile = AT_ENDFILE;\t/* Just at it now.  */\n \tbreak;\n \n       case NO_ENDFILE:\n-\tif (current_unit->current_record > current_unit->last_record)\n+\tif (dtp->u.p.current_unit->current_record > dtp->u.p.current_unit->last_record)\n \t  {\n \t    /* Get rid of whatever is after this record.  */\n-\t    if (struncate (current_unit->s) == FAILURE)\n-\t      generate_error (ERROR_OS, NULL);\n+\t    if (struncate (dtp->u.p.current_unit->s) == FAILURE)\n+\t      generate_error (&dtp->common, ERROR_OS, NULL);\n \t  }\n \n-\tcurrent_unit->endfile = AT_ENDFILE;\n+\tdtp->u.p.current_unit->endfile = AT_ENDFILE;\n \tbreak;\n       }\n \n+  free_format_data (dtp);\n+  free_ionml (dtp);\n+  if (dtp->u.p.scratch != NULL)\n+    free_mem (dtp->u.p.scratch);\n+  if (dtp->u.p.current_unit != NULL)\n+    unlock_unit (dtp->u.p.current_unit);\n   library_end ();\n }\n \n /* Receives the scalar information for namelist objects and stores it\n    in a linked list of namelist_info types.  */\n \n-extern void st_set_nml_var (void * ,char * ,\n-\t\t\t    GFC_INTEGER_4 ,gfc_charlen_type ,GFC_INTEGER_4);\n+extern void st_set_nml_var (st_parameter_dt *dtp, void *, char *,\n+\t\t\t    GFC_INTEGER_4, gfc_charlen_type, GFC_INTEGER_4);\n export_proto(st_set_nml_var);\n \n \n void\n-st_set_nml_var (void * var_addr, char * var_name, GFC_INTEGER_4 len,\n-\t\tgfc_charlen_type string_length, GFC_INTEGER_4 dtype)\n+st_set_nml_var (st_parameter_dt *dtp, void * var_addr, char * var_name,\n+\t\tGFC_INTEGER_4 len, gfc_charlen_type string_length,\n+\t\tGFC_INTEGER_4 dtype)\n {\n   namelist_info *t1 = NULL;\n   namelist_info *nml;\n@@ -2062,31 +2085,35 @@ st_set_nml_var (void * var_addr, char * var_name, GFC_INTEGER_4 len,\n \n   nml->next = NULL;\n \n-  if (ionml == NULL)\n-    ionml = nml;\n+  if ((dtp->common.flags & IOPARM_DT_IONML_SET) == 0)\n+    {\n+      dtp->common.flags |= IOPARM_DT_IONML_SET;\n+      dtp->u.p.ionml = nml;\n+    }\n   else\n     {\n-      for (t1 = ionml; t1->next; t1 = t1->next);\n+      for (t1 = dtp->u.p.ionml; t1->next; t1 = t1->next);\n       t1->next = nml;\n     }\n-  return;\n }\n \n /* Store the dimensional information for the namelist object.  */\n-extern void st_set_nml_var_dim (GFC_INTEGER_4, GFC_INTEGER_4,\n-\t\t\t\tGFC_INTEGER_4 ,GFC_INTEGER_4);\n+extern void st_set_nml_var_dim (st_parameter_dt *, GFC_INTEGER_4,\n+\t\t\t\tGFC_INTEGER_4, GFC_INTEGER_4,\n+\t\t\t\tGFC_INTEGER_4);\n export_proto(st_set_nml_var_dim);\n \n void\n-st_set_nml_var_dim (GFC_INTEGER_4 n_dim, GFC_INTEGER_4 stride,\n-\t\t    GFC_INTEGER_4 lbound, GFC_INTEGER_4 ubound)\n+st_set_nml_var_dim (st_parameter_dt *dtp, GFC_INTEGER_4 n_dim,\n+\t\t    GFC_INTEGER_4 stride, GFC_INTEGER_4 lbound,\n+\t\t    GFC_INTEGER_4 ubound)\n {\n   namelist_info * nml;\n   int n;\n \n   n = (int)n_dim;\n \n-  for (nml = ionml; nml->next; nml = nml->next);\n+  for (nml = dtp->u.p.ionml; nml->next; nml = nml->next);\n \n   nml->dim[n].stride = (ssize_t)stride;\n   nml->dim[n].lbound = (ssize_t)lbound;"}, {"sha": "8ac1a7d60e427f2ad5f5fa70b44e2c5ad53a6a89", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 222, "deletions": 65, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -34,12 +34,55 @@ Boston, MA 02110-1301, USA.  */\n #include \"io.h\"\n \n \n+/* IO locking rules:\n+   UNIT_LOCK is a master lock, protecting UNIT_ROOT tree and UNIT_CACHE.\n+   Concurrent use of different units should be supported, so\n+   each unit has its own lock, LOCK.\n+   Open should be atomic with its reopening of units and list_read.c\n+   in several places needs find_unit another unit while holding stdin\n+   unit's lock, so it must be possible to acquire UNIT_LOCK while holding\n+   some unit's lock.  Therefore to avoid deadlocks, it is forbidden\n+   to acquire unit's private locks while holding UNIT_LOCK, except\n+   for freshly created units (where no other thread can get at their\n+   address yet) or when using just trylock rather than lock operation.\n+   In addition to unit's private lock each unit has a WAITERS counter\n+   and CLOSED flag.  WAITERS counter must be either only\n+   atomically incremented/decremented in all places (if atomic builtins\n+   are supported), or protected by UNIT_LOCK in all places (otherwise).\n+   CLOSED flag must be always protected by unit's LOCK.\n+   After finding a unit in UNIT_CACHE or UNIT_ROOT with UNIT_LOCK held,\n+   WAITERS must be incremented to avoid concurrent close from freeing\n+   the unit between unlocking UNIT_LOCK and acquiring unit's LOCK.\n+   Unit freeing is always done under UNIT_LOCK.  If close_unit sees any\n+   WAITERS, it doesn't free the unit but instead sets the CLOSED flag\n+   and the thread that decrements WAITERS to zero while CLOSED flag is\n+   set is responsible for freeing it (while holding UNIT_LOCK).\n+   flush_all_units operation is iterating over the unit tree with\n+   increasing UNIT_NUMBER while holding UNIT_LOCK and attempting to\n+   flush each unit (and therefore needs the unit's LOCK held as well).\n+   To avoid deadlocks, it just trylocks the LOCK and if unsuccessful,\n+   remembers the current unit's UNIT_NUMBER, unlocks UNIT_LOCK, acquires\n+   unit's LOCK and after flushing reacquires UNIT_LOCK and restarts with\n+   the smallest UNIT_NUMBER above the last one flushed.\n+\n+   If find_unit/find_or_create_unit/find_file/get_unit routines return\n+   non-NULL, the returned unit has its private lock locked and when the\n+   caller is done with it, it must call either unlock_unit or close_unit\n+   on it.  unlock_unit or close_unit must be always called only with the\n+   private lock held.  */\n+\n /* Subroutines related to units */\n \n \n #define CACHE_SIZE 3\n static gfc_unit internal_unit, *unit_cache[CACHE_SIZE];\n-\n+gfc_offset max_offset;\n+gfc_unit *unit_root;\n+#ifdef __GTHREAD_MUTEX_INIT\n+__gthread_mutex_t unit_lock = __GTHREAD_MUTEX_INIT;\n+#else\n+__gthread_mutex_t unit_lock;\n+#endif\n \n /* This implementation is based on Stefan Nilsson's article in the\n  * July 1997 Doctor Dobb's Journal, \"Treaps in Java\". */\n@@ -104,7 +147,7 @@ compare (int a, int b)\n /* insert()-- Recursive insertion function.  Returns the updated treap. */\n \n static gfc_unit *\n-insert (gfc_unit * new, gfc_unit * t)\n+insert (gfc_unit *new, gfc_unit *t)\n {\n   int c;\n \n@@ -128,20 +171,32 @@ insert (gfc_unit * new, gfc_unit * t)\n     }\n \n   if (c == 0)\n-    internal_error (\"insert(): Duplicate key found!\");\n+    internal_error (NULL, \"insert(): Duplicate key found!\");\n \n   return t;\n }\n \n \n-/* insert_unit()-- Given a new node, insert it into the treap.  It is\n- * an error to insert a key that already exists. */\n+/* insert_unit()-- Create a new node, insert it into the treap.  */\n \n-void\n-insert_unit (gfc_unit * new)\n+static gfc_unit *\n+insert_unit (int n)\n {\n-  new->priority = pseudo_random ();\n-  g.unit_root = insert (new, g.unit_root);\n+  gfc_unit *u = get_mem (sizeof (gfc_unit));\n+  memset (u, '\\0', sizeof (gfc_unit));\n+  u->unit_number = n;\n+#ifdef __GTHREAD_MUTEX_INIT\n+  {\n+    __gthread_mutex_t tmp = __GTHREAD_MUTEX_INIT;\n+    u->lock = tmp;\n+  }\n+#else\n+  __GTHREAD_MUTEX_INIT_FUNCTION (&u->lock);\n+#endif\n+  __gthread_mutex_lock (&u->lock);\n+  u->priority = pseudo_random ();\n+  unit_root = insert (u, unit_root);\n+  return u;\n }\n \n \n@@ -201,27 +256,30 @@ delete_treap (gfc_unit * old, gfc_unit * t)\n static void\n delete_unit (gfc_unit * old)\n {\n-  g.unit_root = delete_treap (old, g.unit_root);\n+  unit_root = delete_treap (old, unit_root);\n }\n \n \n /* find_unit()-- Given an integer, return a pointer to the unit\n- * structure.  Returns NULL if the unit does not exist. */\n+ * structure.  Returns NULL if the unit does not exist,\n+ * otherwise returns a locked unit. */\n \n-gfc_unit *\n-find_unit (int n)\n+static gfc_unit *\n+find_unit_1 (int n, int do_create)\n {\n   gfc_unit *p;\n-  int c;\n+  int c, created = 0;\n \n+  __gthread_mutex_lock (&unit_lock);\n+retry:\n   for (c = 0; c < CACHE_SIZE; c++)\n     if (unit_cache[c] != NULL && unit_cache[c]->unit_number == n)\n       {\n \tp = unit_cache[c];\n-\treturn p;\n+\tgoto found;\n       }\n \n-  p = g.unit_root;\n+  p = unit_root;\n   while (p != NULL)\n     {\n       c = compare (n, p->unit_number);\n@@ -233,6 +291,12 @@ find_unit (int n)\n \tbreak;\n     }\n \n+  if (p == NULL && do_create)\n+    {\n+      p = insert_unit (n);\n+      created = 1;\n+    }\n+\n   if (p != NULL)\n     {\n       for (c = 0; c < CACHE_SIZE - 1; c++)\n@@ -241,35 +305,86 @@ find_unit (int n)\n       unit_cache[CACHE_SIZE - 1] = p;\n     }\n \n+  if (created)\n+    {\n+      /* Newly created units have their lock held already\n+\t from insert_unit.  Just unlock UNIT_LOCK and return.  */\n+      __gthread_mutex_unlock (&unit_lock);\n+      return p;\n+    }\n+\n+found:\n+  if (p != NULL)\n+    {\n+      /* Fast path.  */\n+      if (! __gthread_mutex_trylock (&p->lock))\n+\t{\n+\t  /* assert (p->closed == 0); */\n+\t  __gthread_mutex_unlock (&unit_lock);\n+\t  return p;\n+\t}\n+\n+      inc_waiting_locked (p);\n+    }\n+\n+  __gthread_mutex_unlock (&unit_lock);\n+\n+  if (p != NULL)\n+    {\n+      __gthread_mutex_lock (&p->lock);\n+      if (p->closed)\n+\t{\n+\t  __gthread_mutex_lock (&unit_lock);\n+\t  __gthread_mutex_unlock (&p->lock);\n+\t  if (predec_waiting_locked (p) == 0)\n+\t    free_mem (p);\n+\t  goto retry;\n+\t}\n+\n+      dec_waiting_unlocked (p);\n+    }\n   return p;\n }\n \n+gfc_unit *\n+find_unit (int n)\n+{\n+  return find_unit_1 (n, 0);\n+}\n+\n+gfc_unit *\n+find_or_create_unit (int n)\n+{\n+  return find_unit_1 (n, 1);\n+}\n+\n /* get_unit()-- Returns the unit structure associated with the integer\n  * unit or the internal file. */\n \n gfc_unit *\n-get_unit (int read_flag __attribute__ ((unused)))\n+get_unit (st_parameter_dt *dtp, int do_create)\n {\n-  if (ioparm.internal_unit != NULL)\n+  if ((dtp->common.flags & IOPARM_DT_HAS_INTERNAL_UNIT) != 0)\n     {\n-      internal_unit.recl = ioparm.internal_unit_len;\n-      if (is_array_io())\n-      {\n-        internal_unit.rank = GFC_DESCRIPTOR_RANK(ioparm.internal_unit_desc);\n-        internal_unit.ls = (array_loop_spec*)\n-          get_mem (internal_unit.rank * sizeof (array_loop_spec));\n-        ioparm.internal_unit_len *=\n-\t  init_loop_spec (ioparm.internal_unit_desc, internal_unit.ls);\n-      }\n-        \n+      __gthread_mutex_lock (&internal_unit.lock);\n+      internal_unit.recl = dtp->internal_unit_len;\n+      if (is_array_io (dtp))\n+\t{\n+\t  internal_unit.rank = GFC_DESCRIPTOR_RANK (dtp->internal_unit_desc);\n+\t  internal_unit.ls = (array_loop_spec *)\n+\t    get_mem (internal_unit.rank * sizeof (array_loop_spec));\n+\t  dtp->internal_unit_len *=\n+\t    init_loop_spec (dtp->internal_unit_desc, internal_unit.ls);\n+\t}\n+\n       internal_unit.s =\n-\topen_internal (ioparm.internal_unit, ioparm.internal_unit_len);\n+\topen_internal (dtp->internal_unit, dtp->internal_unit_len);\n       internal_unit.bytes_left = internal_unit.recl;\n       internal_unit.last_record=0;\n       internal_unit.maxrec=0;\n       internal_unit.current_record=0;\n \n-      if (g.mode==WRITING && !is_array_io())\n+      if (dtp->u.p.mode==WRITING && !is_array_io (dtp))\n         empty_internal_buffer (internal_unit.s);\n \n       /* Set flags for the internal unit */\n@@ -284,25 +399,25 @@ get_unit (int read_flag __attribute__ ((unused)))\n \n   /* Has to be an external unit */\n \n-  return find_unit (ioparm.unit);\n+  return find_unit_1 (dtp->common.unit, do_create);\n }\n \n \n /* is_internal_unit()-- Determine if the current unit is internal or not */\n \n int\n-is_internal_unit (void)\n+is_internal_unit (st_parameter_dt *dtp)\n {\n-  return current_unit == &internal_unit;\n+  return dtp->u.p.current_unit == &internal_unit;\n }\n \n \n /* is_array_io ()-- Determine if the I/O is to/from an array */\n \n int\n-is_array_io (void)\n+is_array_io (st_parameter_dt *dtp)\n {\n-  return (ioparm.internal_unit_desc != NULL);\n+  return dtp->internal_unit_desc != NULL;\n }\n \n \n@@ -315,12 +430,22 @@ init_units (void)\n   gfc_unit *u;\n   unsigned int i;\n \n+#ifndef __GTHREAD_MUTEX_INIT\n+  __GTHREAD_MUTEX_INIT_FUNCTION (&unit_lock);\n+#endif\n+\n+#ifdef __GTHREAD_MUTEX_INIT\n+  {\n+    __gthread_mutex_t tmp = __GTHREAD_MUTEX_INIT;\n+    internal_unit.lock = tmp;\n+  }\n+#else\n+  __GTHREAD_MUTEX_INIT_FUNCTION (&internal_unit.lock);\n+#endif\n+\n   if (options.stdin_unit >= 0)\n     {\t\t\t\t/* STDIN */\n-      u = get_mem (sizeof (gfc_unit));\n-      memset (u, '\\0', sizeof (gfc_unit));\n-\n-      u->unit_number = options.stdin_unit;\n+      u = insert_unit (options.stdin_unit);\n       u->s = input_stream ();\n \n       u->flags.action = ACTION_READ;\n@@ -334,15 +459,12 @@ init_units (void)\n       u->recl = options.default_recl;\n       u->endfile = NO_ENDFILE;\n \n-      insert_unit (u);\n+      __gthread_mutex_unlock (&u->lock);\n     }\n \n   if (options.stdout_unit >= 0)\n     {\t\t\t\t/* STDOUT */\n-      u = get_mem (sizeof (gfc_unit));\n-      memset (u, '\\0', sizeof (gfc_unit));\n-\n-      u->unit_number = options.stdout_unit;\n+      u = insert_unit (options.stdout_unit);\n       u->s = output_stream ();\n \n       u->flags.action = ACTION_WRITE;\n@@ -356,15 +478,12 @@ init_units (void)\n       u->recl = options.default_recl;\n       u->endfile = AT_ENDFILE;\n \n-      insert_unit (u);\n+      __gthread_mutex_unlock (&u->lock);\n     }\n \n   if (options.stderr_unit >= 0)\n     {\t\t\t\t/* STDERR */\n-      u = get_mem (sizeof (gfc_unit));\n-      memset (u, '\\0', sizeof (gfc_unit));\n-\n-      u->unit_number = options.stderr_unit;\n+      u = insert_unit (options.stderr_unit);\n       u->s = error_stream ();\n \n       u->flags.action = ACTION_WRITE;\n@@ -378,48 +497,86 @@ init_units (void)\n       u->recl = options.default_recl;\n       u->endfile = AT_ENDFILE;\n \n-      insert_unit (u);\n+      __gthread_mutex_unlock (&u->lock);\n     }\n \n   /* Calculate the maximum file offset in a portable manner.\n    * max will be the largest signed number for the type gfc_offset.\n    *\n    * set a 1 in the LSB and keep a running sum, stopping at MSB-1 bit. */\n \n-  g.max_offset = 0;\n-  for (i = 0; i < sizeof (g.max_offset) * 8 - 1; i++)\n-    g.max_offset = g.max_offset + ((gfc_offset) 1 << i);\n-\n+  max_offset = 0;\n+  for (i = 0; i < sizeof (max_offset) * 8 - 1; i++)\n+    max_offset = max_offset + ((gfc_offset) 1 << i);\n }\n \n \n-/* close_unit()-- Close a unit.  The stream is closed, and any memory\n- * associated with the stream is freed.  Returns nonzero on I/O error. */\n-\n-int\n-close_unit (gfc_unit * u)\n+static int\n+close_unit_1 (gfc_unit *u, int locked)\n {\n   int i, rc;\n \n+  rc = (u->s == NULL) ? 0 : sclose (u->s) == FAILURE;\n+\n+  u->closed = 1;\n+  if (!locked)\n+    __gthread_mutex_lock (&unit_lock);\n+\n   for (i = 0; i < CACHE_SIZE; i++)\n     if (unit_cache[i] == u)\n       unit_cache[i] = NULL;\n \n-  rc = (u->s == NULL) ? 0 : sclose (u->s) == FAILURE;\n-\n   delete_unit (u);\n-  free_mem (u);\n+\n+  if (u->file)\n+    free_mem (u->file);\n+  u->file = NULL;\n+  u->file_len = 0;\n+\n+  if (!locked)\n+    __gthread_mutex_unlock (&u->lock);\n+\n+  /* If there are any threads waiting in find_unit for this unit,\n+     avoid freeing the memory, the last such thread will free it\n+     instead.  */\n+  if (u->waiting == 0)\n+    free_mem (u);\n+\n+  if (!locked)\n+    __gthread_mutex_unlock (&unit_lock);\n \n   return rc;\n }\n \n+void\n+unlock_unit (gfc_unit *u)\n+{\n+  __gthread_mutex_unlock (&u->lock);\n+}\n+\n+/* close_unit()-- Close a unit.  The stream is closed, and any memory\n+ * associated with the stream is freed.  Returns nonzero on I/O error.\n+ * Should be called with the u->lock locked. */\n+\n+int\n+close_unit (gfc_unit *u)\n+{\n+  return close_unit_1 (u, 0);\n+}\n+\n \n /* close_units()-- Delete units on completion.  We just keep deleting\n- * the root of the treap until there is nothing left. */\n+ * the root of the treap until there is nothing left.\n+ * Not sure what to do with locking here.  Some other thread might be\n+ * holding some unit's lock and perhaps hold it indefinitely\n+ * (e.g. waiting for input from some pipe) and close_units shouldn't\n+ * delay the program too much.  */\n \n void\n close_units (void)\n {\n-  while (g.unit_root != NULL)\n-    close_unit (g.unit_root);\n+  __gthread_mutex_lock (&unit_lock);\n+  while (unit_root != NULL)\n+    close_unit_1 (unit_root, 1);\n+  __gthread_mutex_unlock (&unit_lock);\n }"}, {"sha": "d1833f37e2dbfe380defe15f1cf794019c070489", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 144, "deletions": 71, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -45,6 +45,7 @@ Boston, MA 02110-1301, USA.  */\n \n #include \"libgfortran.h\"\n #include \"io.h\"\n+#include \"unix.h\"\n \n #ifndef SSIZE_MAX\n #define SSIZE_MAX SHRT_MAX\n@@ -116,35 +117,6 @@ Boston, MA 02110-1301, USA.  */\n  * 'where' parameter and use the current file pointer. */\n \n \n-#define BUFFER_SIZE 8192\n-\n-typedef struct\n-{\n-  stream st;\n-\n-  int fd;\n-  gfc_offset buffer_offset;\t/* File offset of the start of the buffer */\n-  gfc_offset physical_offset;\t/* Current physical file offset */\n-  gfc_offset logical_offset;\t/* Current logical file offset */\n-  gfc_offset dirty_offset;\t/* Start of modified bytes in buffer */\n-  gfc_offset file_length;\t/* Length of the file, -1 if not seekable. */\n-\n-  char *buffer;\n-  int len;\t\t\t/* Physical length of the current buffer */\n-  int active;\t\t\t/* Length of valid bytes in the buffer */\n-\n-  int prot;\n-  int ndirty;\t\t\t/* Dirty bytes starting at dirty_offset */\n-\n-  int special_file;\t\t/* =1 if the fd refers to a special file */\n-\n-  unsigned unbuffered:1;\n-\n-  char small_buffer[BUFFER_SIZE];\n-\n-}\n-unix_stream;\n-\n /*move_pos_offset()--  Move the record pointer right or left\n  *relative to current position */\n \n@@ -998,15 +970,18 @@ fd_to_stream (int fd, int prot)\n /* Given the Fortran unit number, convert it to a C file descriptor.  */\n \n int\n-unit_to_fd(int unit)\n+unit_to_fd (int unit)\n {\n   gfc_unit *us;\n+  int fd;\n \n-  us = find_unit(unit);\n+  us = find_unit (unit);\n   if (us == NULL)\n     return -1;\n \n-  return ((unix_stream *) us->s)->fd;\n+  fd = ((unix_stream *) us->s)->fd;\n+  unlock_unit (us);\n+  return fd;\n }\n \n \n@@ -1032,11 +1007,11 @@ unpack_filename (char *cstring, const char *fstring, int len)\n  * open it.  mkstemp() opens the file for reading and writing, but the\n  * library mode prevents anything that is not allowed.  The descriptor\n  * is returned, which is -1 on error.  The template is pointed to by \n- * ioparm.file, which is copied into the unit structure\n+ * opp->file, which is copied into the unit structure\n  * and freed later. */\n \n static int\n-tempfile (void)\n+tempfile (st_parameter_open *opp)\n {\n   const char *tempdir;\n   char *template;\n@@ -1078,8 +1053,8 @@ tempfile (void)\n     free_mem (template);\n   else\n     {\n-      ioparm.file = template;\n-      ioparm.file_len = strlen (template);\t/* Don't include trailing nul */\n+      opp->file = template;\n+      opp->file_len = strlen (template);\t/* Don't include trailing nul */\n     }\n \n   return fd;\n@@ -1092,15 +1067,15 @@ tempfile (void)\n  * Returns the descriptor, which is less than zero on error. */\n \n static int\n-regular_file (unit_flags *flags)\n+regular_file (st_parameter_open *opp, unit_flags *flags)\n {\n   char path[PATH_MAX + 1];\n   int mode;\n   int rwflag;\n   int crflag;\n   int fd;\n \n-  if (unpack_filename (path, ioparm.file, ioparm.file_len))\n+  if (unpack_filename (path, opp->file, opp->file_len))\n     {\n       errno = ENOENT;\t\t/* Fake an OS error */\n       return -1;\n@@ -1124,7 +1099,7 @@ regular_file (unit_flags *flags)\n       break;\n \n     default:\n-      internal_error (\"regular_file(): Bad action\");\n+      internal_error (&opp->common, \"regular_file(): Bad action\");\n     }\n \n   switch (flags->status)\n@@ -1147,7 +1122,7 @@ regular_file (unit_flags *flags)\n       break;\n \n     default:\n-      internal_error (\"regular_file(): Bad status\");\n+      internal_error (&opp->common, \"regular_file(): Bad status\");\n     }\n \n   /* rwflag |= O_LARGEFILE; */\n@@ -1198,26 +1173,27 @@ regular_file (unit_flags *flags)\n  * Returns NULL on operating system error. */\n \n stream *\n-open_external (unit_flags *flags)\n+open_external (st_parameter_open *opp, unit_flags *flags)\n {\n   int fd, prot;\n \n   if (flags->status == STATUS_SCRATCH)\n     {\n-      fd = tempfile ();\n+      fd = tempfile (opp);\n       if (flags->action == ACTION_UNSPECIFIED)\n         flags->action = ACTION_READWRITE;\n \n #if HAVE_UNLINK_OPEN_FILE\n       /* We can unlink scratch files now and it will go away when closed. */\n-      unlink (ioparm.file);\n+      if (fd >= 0)\n+\tunlink (opp->file);\n #endif\n     }\n   else\n     {\n       /* regular_file resets flags->action if it is ACTION_UNSPECIFIED and\n        * if it succeeds */\n-      fd = regular_file (flags);\n+      fd = regular_file (opp, flags);\n     }\n \n   if (fd < 0)\n@@ -1239,7 +1215,7 @@ open_external (unit_flags *flags)\n       break;\n \n     default:\n-      internal_error (\"open_external(): Bad action\");\n+      internal_error (&opp->common, \"open_external(): Bad action\");\n     }\n \n   return fd_to_stream (fd, prot);\n@@ -1281,21 +1257,19 @@ error_stream (void)\n  * corrupted. */\n \n stream *\n-init_error_stream (void)\n+init_error_stream (unix_stream *error)\n {\n-  static unix_stream error;\n-\n-  memset (&error, '\\0', sizeof (error));\n+  memset (error, '\\0', sizeof (*error));\n \n-  error.fd = options.use_stderr ? STDERR_FILENO : STDOUT_FILENO;\n+  error->fd = options.use_stderr ? STDERR_FILENO : STDOUT_FILENO;\n \n-  error.st.alloc_w_at = (void *) fd_alloc_w_at;\n-  error.st.sfree = (void *) fd_sfree;\n+  error->st.alloc_w_at = (void *) fd_alloc_w_at;\n+  error->st.sfree = (void *) fd_sfree;\n \n-  error.unbuffered = 1;\n-  error.buffer = error.small_buffer;\n+  error->unbuffered = 1;\n+  error->buffer = error->small_buffer;\n \n-  return (stream *) & error;\n+  return (stream *) error;\n }\n \n \n@@ -1332,33 +1306,39 @@ compare_file_filename (gfc_unit *u, const char *name, int len)\n }\n \n \n+#ifdef HAVE_WORKING_STAT\n+# define FIND_FILE0_DECL struct stat *st\n+# define FIND_FILE0_ARGS st\n+#else\n+# define FIND_FILE0_DECL const char *file, gfc_charlen_type file_len\n+# define FIND_FILE0_ARGS file, file_len\n+#endif\n+\n /* find_file0()-- Recursive work function for find_file() */\n \n static gfc_unit *\n-find_file0 (gfc_unit * u, struct stat *st1)\n+find_file0 (gfc_unit *u, FIND_FILE0_DECL)\n {\n-#ifdef HAVE_WORKING_STAT\n-  struct stat st2;\n-#endif\n   gfc_unit *v;\n \n   if (u == NULL)\n     return NULL;\n \n #ifdef HAVE_WORKING_STAT\n-  if (fstat (((unix_stream *) u->s)->fd, &st2) >= 0 &&\n-      st1->st_dev == st2.st_dev && st1->st_ino == st2.st_ino)\n+  if (u->s != NULL\n+      && fstat (((unix_stream *) u->s)->fd, &st[1]) >= 0 &&\n+      st[0].st_dev == st[1].st_dev && st[0].st_ino == st[1].st_ino)\n     return u;\n #else\n-  if (compare_string(u->file_len, u->file, ioparm.file_len, ioparm.file) == 0)\n+  if (compare_string (u->file_len, u->file, file_len, file) == 0)\n     return u;\n #endif\n \n-  v = find_file0 (u->left, st1);\n+  v = find_file0 (u->left, FIND_FILE0_ARGS);\n   if (v != NULL)\n     return v;\n \n-  v = find_file0 (u->right, st1);\n+  v = find_file0 (u->right, FIND_FILE0_ARGS);\n   if (v != NULL)\n     return v;\n \n@@ -1370,18 +1350,111 @@ find_file0 (gfc_unit * u, struct stat *st1)\n  * that has the file already open.  Returns a pointer to the unit if so. */\n \n gfc_unit *\n-find_file (void)\n+find_file (const char *file, gfc_charlen_type file_len)\n {\n   char path[PATH_MAX + 1];\n-  struct stat statbuf;\n+  struct stat st[2];\n+  gfc_unit *u;\n \n-  if (unpack_filename (path, ioparm.file, ioparm.file_len))\n+  if (unpack_filename (path, file, file_len))\n     return NULL;\n \n-  if (stat (path, &statbuf) < 0)\n+  if (stat (path, &st[0]) < 0)\n     return NULL;\n \n-  return find_file0 (g.unit_root, &statbuf);\n+  __gthread_mutex_lock (&unit_lock);\n+retry:\n+  u = find_file0 (unit_root, FIND_FILE0_ARGS);\n+  if (u != NULL)\n+    {\n+      /* Fast path.  */\n+      if (! __gthread_mutex_trylock (&u->lock))\n+\t{\n+\t  /* assert (u->closed == 0); */\n+\t  __gthread_mutex_unlock (&unit_lock);\n+\t  return u;\n+\t}\n+\n+      inc_waiting_locked (u);\n+    }\n+  __gthread_mutex_unlock (&unit_lock);\n+  if (u != NULL)\n+    {\n+      __gthread_mutex_lock (&u->lock);\n+      if (u->closed)\n+\t{\n+\t  __gthread_mutex_lock (&unit_lock);\n+\t  __gthread_mutex_unlock (&u->lock);\n+\t  if (predec_waiting_locked (u) == 0)\n+\t    free_mem (u);\n+\t  goto retry;\n+\t}\n+\n+      dec_waiting_unlocked (u);\n+    }\n+  return u;\n+}\n+\n+static gfc_unit *\n+flush_all_units_1 (gfc_unit *u, int min_unit)\n+{\n+  while (u != NULL)\n+    {\n+      if (u->unit_number > min_unit)\n+\t{\n+\t  gfc_unit *r = flush_all_units_1 (u->left, min_unit);\n+\t  if (r != NULL)\n+\t    return r;\n+\t}\n+      if (u->unit_number >= min_unit)\n+\t{\n+\t  if (__gthread_mutex_trylock (&u->lock))\n+\t    return u;\n+\t  if (u->s)\n+\t    flush (u->s);\n+\t  __gthread_mutex_unlock (&u->lock);\n+\t}\n+      u = u->right;\n+    }\n+  return NULL;\n+}\n+\n+void\n+flush_all_units (void)\n+{\n+  gfc_unit *u;\n+  int min_unit = 0;\n+\n+  __gthread_mutex_lock (&unit_lock);\n+  do\n+    {\n+      u = flush_all_units_1 (unit_root, min_unit);\n+      if (u != NULL)\n+\tinc_waiting_locked (u);\n+      __gthread_mutex_unlock (&unit_lock);\n+      if (u == NULL)\n+\treturn;\n+\n+      __gthread_mutex_lock (&u->lock);\n+\n+      min_unit = u->unit_number + 1;\n+\n+      if (u->closed == 0)\n+\t{\n+\t  flush (u->s);\n+\t  __gthread_mutex_lock (&unit_lock);\n+\t  __gthread_mutex_unlock (&u->lock);\n+\t  (void) predec_waiting_locked (u);\n+\t}\n+      else\n+\t{\n+\t  __gthread_mutex_lock (&unit_lock);\n+\t  __gthread_mutex_unlock (&u->lock);\n+\t  if (predec_waiting_locked (u) == 0)\n+\t    free_mem (u);\n+\t}\n+    }\n+  while (1);\n }\n \n \n@@ -1441,12 +1514,12 @@ delete_file (gfc_unit * u)\n  * the system */\n \n int\n-file_exists (void)\n+file_exists (const char *file, gfc_charlen_type file_len)\n {\n   char path[PATH_MAX + 1];\n   struct stat statbuf;\n \n-  if (unpack_filename (path, ioparm.file, ioparm.file_len))\n+  if (unpack_filename (path, file, file_len))\n     return 0;\n \n   if (stat (path, &statbuf) < 0)"}, {"sha": "25508f117da3d6fbb7a9c23bb55652438bf8773b", "filename": "libgfortran/io/unix.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Funix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Funix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.h?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -0,0 +1,63 @@\n+/* Copyright (C) 2002, 2003, 2004, 2005\n+   Free Software Foundation, Inc.\n+   Contributed by Andy Vaught\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with Libgfortran; see the file COPYING.  If not, write to\n+the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+/* Unix stream I/O module */\n+\n+#define BUFFER_SIZE 8192\n+\n+typedef struct\n+{\n+  stream st;\n+\n+  int fd;\n+  gfc_offset buffer_offset;\t/* File offset of the start of the buffer */\n+  gfc_offset physical_offset;\t/* Current physical file offset */\n+  gfc_offset logical_offset;\t/* Current logical file offset */\n+  gfc_offset dirty_offset;\t/* Start of modified bytes in buffer */\n+  gfc_offset file_length;\t/* Length of the file, -1 if not seekable. */\n+\n+  char *buffer;\n+  int len;\t\t\t/* Physical length of the current buffer */\n+  int active;\t\t\t/* Length of valid bytes in the buffer */\n+\n+  int prot;\n+  int ndirty;\t\t\t/* Dirty bytes starting at dirty_offset */\n+\n+  int special_file;\t\t/* =1 if the fd refers to a special file */\n+\n+  unsigned unbuffered:1;\n+\n+  char small_buffer[BUFFER_SIZE];\n+\n+}\n+unix_stream;\n+\n+extern stream *init_error_stream (unix_stream *);\n+internal_proto(init_error_stream);"}, {"sha": "fb91639d2ac2fad7e667df358978758fa4fc8737", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 156, "deletions": 161, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -46,17 +46,15 @@ typedef enum\n sign_t;\n \n \n-static int no_leading_blank = 0 ;\n-\n void\n-write_a (fnode * f, const char *source, int len)\n+write_a (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n {\n   int wlen;\n   char *p;\n \n   wlen = f->u.string.length < 0 ? len : f->u.string.length;\n \n-  p = write_block (wlen);\n+  p = write_block (dtp, wlen);\n   if (p == NULL)\n     return;\n \n@@ -117,7 +115,7 @@ extract_int (const void *p, int len)\n       break;\n #endif\n     default:\n-      internal_error (\"bad integer kind\");\n+      internal_error (NULL, \"bad integer kind\");\n     }\n \n   return i;\n@@ -171,7 +169,7 @@ extract_uint (const void *p, int len)\n       break;\n #endif\n     default:\n-      internal_error (\"bad integer kind\");\n+      internal_error (NULL, \"bad integer kind\");\n     }\n \n   return i;\n@@ -216,7 +214,7 @@ extract_real (const void *p, int len)\n       break;\n #endif\n     default:\n-      internal_error (\"bad real kind\");\n+      internal_error (NULL, \"bad real kind\");\n     }\n   return i;\n }\n@@ -226,14 +224,14 @@ extract_real (const void *p, int len)\n    sign_t that gives the sign that we need to produce.  */\n \n static sign_t\n-calculate_sign (int negative_flag)\n+calculate_sign (st_parameter_dt *dtp, int negative_flag)\n {\n   sign_t s = SIGN_NONE;\n \n   if (negative_flag)\n     s = SIGN_MINUS;\n   else\n-    switch (g.sign_status)\n+    switch (dtp->u.p.sign_status)\n       {\n       case SIGN_SP:\n \ts = SIGN_PLUS;\n@@ -285,7 +283,8 @@ calculate_exp (int d)\n           for Gw.dEe, n' ' means e+2 blanks  */\n \n static fnode *\n-calculate_G_format (fnode *f, GFC_REAL_LARGEST value, int *num_blank)\n+calculate_G_format (st_parameter_dt *dtp, const fnode *f,\n+\t\t    GFC_REAL_LARGEST value, int *num_blank)\n {\n   int e = f->u.real.e;\n   int d = f->u.real.d;\n@@ -366,15 +365,15 @@ calculate_G_format (fnode *f, GFC_REAL_LARGEST value, int *num_blank)\n     newf->u.real.d = - (mid - d - 1);\n \n   /* For F editing, the scale factor is ignored.  */\n-  g.scale_factor = 0;\n+  dtp->u.p.scale_factor = 0;\n   return newf;\n }\n \n \n /* Output a real number according to its format which is FMT_G free.  */\n \n static void\n-output_float (fnode *f, GFC_REAL_LARGEST value)\n+output_float (st_parameter_dt *dtp, const fnode *f, GFC_REAL_LARGEST value)\n {\n   /* This must be large enough to accurately hold any value.  */\n   char buffer[32];\n@@ -410,12 +409,12 @@ output_float (fnode *f, GFC_REAL_LARGEST value)\n \n   /* We should always know the field width and precision.  */\n   if (d < 0)\n-    internal_error (\"Unspecified precision\");\n+    internal_error (&dtp->common, \"Unspecified precision\");\n \n   /* Use sprintf to print the number in the format +D.DDDDe+ddd\n      For an N digit exponent, this gives us (32-6)-N digits after the\n      decimal point, plus another one before the decimal point.  */\n-  sign = calculate_sign (value < 0.0);\n+  sign = calculate_sign (dtp, value < 0.0);\n   if (value < 0)\n     value = -value;\n \n@@ -436,7 +435,7 @@ output_float (fnode *f, GFC_REAL_LARGEST value)\n     }\n \n   if (ft == FMT_F || ft == FMT_EN\n-      || ((ft == FMT_D || ft == FMT_E) && g.scale_factor != 0))\n+      || ((ft == FMT_D || ft == FMT_E) && dtp->u.p.scale_factor != 0))\n     {\n       /* Always convert at full precision to avoid double rounding.  */\n       ndigits = 27 - edigits;\n@@ -474,7 +473,7 @@ output_float (fnode *f, GFC_REAL_LARGEST value)\n \n   /* Check the resulting string has punctuation in the correct places.  */\n   if (buffer[2] != '.' || buffer[ndigits + 2] != 'e')\n-      internal_error (\"printf is broken\");\n+      internal_error (&dtp->common, \"printf is broken\");\n \n   /* Read the exponent back in.  */\n   e = atoi (&buffer[ndigits + 3]) + 1;\n@@ -491,7 +490,7 @@ output_float (fnode *f, GFC_REAL_LARGEST value)\n   switch (ft)\n     {\n     case FMT_F:\n-      nbefore = e + g.scale_factor;\n+      nbefore = e + dtp->u.p.scale_factor;\n       if (nbefore < 0)\n \t{\n \t  nzero = -nbefore;\n@@ -511,7 +510,7 @@ output_float (fnode *f, GFC_REAL_LARGEST value)\n \n     case FMT_E:\n     case FMT_D:\n-      i = g.scale_factor;\n+      i = dtp->u.p.scale_factor;\n       if (value != 0.0)\n \te -= i;\n       if (i < 0)\n@@ -570,7 +569,7 @@ output_float (fnode *f, GFC_REAL_LARGEST value)\n \n     default:\n       /* Should never happen.  */\n-      internal_error (\"Unexpected format token\");\n+      internal_error (&dtp->common, \"Unexpected format token\");\n     }\n \n   /* Round the value.  */\n@@ -671,7 +670,7 @@ output_float (fnode *f, GFC_REAL_LARGEST value)\n     w = nbefore + nzero + nafter + (sign != SIGN_NONE ? 2 : 1);\n \n   /* Create the ouput buffer.  */\n-  out = write_block (w);\n+  out = write_block (dtp, w);\n   if (out == NULL)\n     return;\n \n@@ -683,7 +682,7 @@ output_float (fnode *f, GFC_REAL_LARGEST value)\n \tbreak;\n     }\n   if (i == ndigits)\n-    sign = calculate_sign (0);\n+    sign = calculate_sign (dtp, 0);\n \n   /* Work out how much padding is needed.  */\n   nblanks = w - (nbefore + nzero + nafter + edigits + 1);\n@@ -709,7 +708,7 @@ output_float (fnode *f, GFC_REAL_LARGEST value)\n   /* Pad to full field width.  */\n \n \n-  if ( ( nblanks > 0 ) && !no_leading_blank )\n+  if ( ( nblanks > 0 ) && !dtp->u.p.no_leading_blank)\n     {\n       memset (out, ' ', nblanks);\n       out += nblanks;\n@@ -784,22 +783,22 @@ output_float (fnode *f, GFC_REAL_LARGEST value)\n       memcpy (out, buffer, edigits);\n     }\n \n-  if ( no_leading_blank )\n+  if (dtp->u.p.no_leading_blank)\n     {\n       out += edigits;\n       memset( out , ' ' , nblanks );\n-      no_leading_blank = 0;\n+      dtp->u.p.no_leading_blank = 0;\n     }\n }\n \n \n void\n-write_l (fnode * f, char *source, int len)\n+write_l (st_parameter_dt *dtp, const fnode *f, char *source, int len)\n {\n   char *p;\n   GFC_INTEGER_LARGEST n;\n \n-  p = write_block (f->u.w);\n+  p = write_block (dtp, f->u.w);\n   if (p == NULL)\n     return;\n \n@@ -811,7 +810,7 @@ write_l (fnode * f, char *source, int len)\n /* Output a real number according to its format.  */\n \n static void\n-write_float (fnode *f, const char *source, int len)\n+write_float (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n {\n   GFC_REAL_LARGEST n;\n   int nb =0, res, save_scale_factor;\n@@ -831,7 +830,7 @@ write_float (fnode *f, const char *source, int len)\n \t     not zero.  4 is chosen to allow output of '-Inf' or '+Inf' */\n \t     \n \t  if (nb == 0) nb = 4;\n-\t  p = write_block (nb);\n+\t  p = write_block (dtp, nb);\n           if (p == NULL)\n             return;\n \t  if (nb < 3)\n@@ -890,21 +889,19 @@ write_float (fnode *f, const char *source, int len)\n     }\n \n   if (f->format != FMT_G)\n-    {\n-      output_float (f, n);\n-    }\n+    output_float (dtp, f, n);\n   else\n     {\n-      save_scale_factor = g.scale_factor;\n-      f2 = calculate_G_format(f, n, &nb);\n-      output_float (f2, n);\n-      g.scale_factor = save_scale_factor;\n+      save_scale_factor = dtp->u.p.scale_factor;\n+      f2 = calculate_G_format (dtp, f, n, &nb);\n+      output_float (dtp, f2, n);\n+      dtp->u.p.scale_factor = save_scale_factor;\n       if (f2 != NULL)\n         free_mem(f2);\n \n       if (nb > 0)\n         {\n-          p = write_block (nb);\n+\t  p = write_block (dtp, nb);\n           if (p == NULL)\n             return;\n           memset (p, ' ', nb);\n@@ -914,7 +911,7 @@ write_float (fnode *f, const char *source, int len)\n \n \n static void\n-write_int (fnode *f, const char *source, int len,\n+write_int (st_parameter_dt *dtp, const fnode *f, const char *source, int len,\n            const char *(*conv) (GFC_UINTEGER_LARGEST, char *, size_t))\n {\n   GFC_UINTEGER_LARGEST n = 0;\n@@ -935,7 +932,7 @@ write_int (fnode *f, const char *source, int len,\n       if (w == 0)\n         w = 1;\n \n-      p = write_block (w);\n+      p = write_block (dtp, w);\n       if (p == NULL)\n         return;\n \n@@ -952,7 +949,7 @@ write_int (fnode *f, const char *source, int len,\n   if (w == 0)\n     w = ((digits < m) ? m : digits);\n \n-  p = write_block (w);\n+  p = write_block (dtp, w);\n   if (p == NULL)\n     return;\n \n@@ -971,13 +968,13 @@ write_int (fnode *f, const char *source, int len,\n     }\n \n \n-  if (!no_leading_blank)\n+  if (!dtp->u.p.no_leading_blank)\n     {\n-  memset (p, ' ', nblank);\n-  p += nblank;\n-  memset (p, '0', nzero);\n-  p += nzero;\n-  memcpy (p, q, digits);\n+      memset (p, ' ', nblank);\n+      p += nblank;\n+      memset (p, '0', nzero);\n+      p += nzero;\n+      memcpy (p, q, digits);\n     }\n   else\n     {\n@@ -986,15 +983,16 @@ write_int (fnode *f, const char *source, int len,\n       memcpy (p, q, digits);\n       p += digits;\n       memset (p, ' ', nblank);\n-      no_leading_blank = 0;\n+      dtp->u.p.no_leading_blank = 0;\n     }\n \n  done:\n   return;\n }\n \n static void\n-write_decimal (fnode *f, const char *source, int len,\n+write_decimal (st_parameter_dt *dtp, const fnode *f, const char *source,\n+\t       int len,\n                const char *(*conv) (GFC_INTEGER_LARGEST, char *, size_t))\n {\n   GFC_INTEGER_LARGEST n = 0;\n@@ -1016,15 +1014,15 @@ write_decimal (fnode *f, const char *source, int len,\n       if (w == 0)\n         w = 1;\n \n-      p = write_block (w);\n+      p = write_block (dtp, w);\n       if (p == NULL)\n         return;\n \n       memset (p, ' ', w);\n       goto done;\n     }\n \n-  sign = calculate_sign (n < 0);\n+  sign = calculate_sign (dtp, n < 0);\n   if (n < 0)\n     n = -n;\n \n@@ -1039,7 +1037,7 @@ write_decimal (fnode *f, const char *source, int len,\n   if (w == 0)\n     w = ((digits < m) ? m : digits) + nsign;\n \n-  p = write_block (w);\n+  p = write_block (dtp, w);\n   if (p == NULL)\n     return;\n \n@@ -1133,75 +1131,75 @@ btoa (GFC_UINTEGER_LARGEST n, char *buffer, size_t len)\n \n \n void\n-write_i (fnode * f, const char *p, int len)\n+write_i (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n {\n-  write_decimal (f, p, len, (void *) gfc_itoa);\n+  write_decimal (dtp, f, p, len, (void *) gfc_itoa);\n }\n \n \n void\n-write_b (fnode * f, const char *p, int len)\n+write_b (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n {\n-  write_int (f, p, len, btoa);\n+  write_int (dtp, f, p, len, btoa);\n }\n \n \n void\n-write_o (fnode * f, const char *p, int len)\n+write_o (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n {\n-  write_int (f, p, len, otoa);\n+  write_int (dtp, f, p, len, otoa);\n }\n \n void\n-write_z (fnode * f, const char *p, int len)\n+write_z (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n {\n-  write_int (f, p, len, xtoa);\n+  write_int (dtp, f, p, len, xtoa);\n }\n \n \n void\n-write_d (fnode *f, const char *p, int len)\n+write_d (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n {\n-  write_float (f, p, len);\n+  write_float (dtp, f, p, len);\n }\n \n \n void\n-write_e (fnode *f, const char *p, int len)\n+write_e (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n {\n-  write_float (f, p, len);\n+  write_float (dtp, f, p, len);\n }\n \n \n void\n-write_f (fnode *f, const char *p, int len)\n+write_f (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n {\n-  write_float (f, p, len);\n+  write_float (dtp, f, p, len);\n }\n \n \n void\n-write_en (fnode *f, const char *p, int len)\n+write_en (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n {\n-  write_float (f, p, len);\n+  write_float (dtp, f, p, len);\n }\n \n \n void\n-write_es (fnode *f, const char *p, int len)\n+write_es (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n {\n-  write_float (f, p, len);\n+  write_float (dtp, f, p, len);\n }\n \n \n /* Take care of the X/TR descriptor.  */\n \n void\n-write_x (int len, int nspaces)\n+write_x (st_parameter_dt *dtp, int len, int nspaces)\n {\n   char *p;\n \n-  p = write_block (len);\n+  p = write_block (dtp, len);\n   if (p == NULL)\n     return;\n \n@@ -1217,11 +1215,11 @@ write_x (int len, int nspaces)\n    something goes wrong.  */\n \n static int\n-write_char (char c)\n+write_char (st_parameter_dt *dtp, char c)\n {\n   char *p;\n \n-  p = write_block (1);\n+  p = write_block (dtp, 1);\n   if (p == NULL)\n     return 1;\n \n@@ -1234,16 +1232,16 @@ write_char (char c)\n /* Write a list-directed logical value.  */\n \n static void\n-write_logical (const char *source, int length)\n+write_logical (st_parameter_dt *dtp, const char *source, int length)\n {\n-  write_char (extract_int (source, length) ? 'T' : 'F');\n+  write_char (dtp, extract_int (source, length) ? 'T' : 'F');\n }\n \n \n /* Write a list-directed integer value.  */\n \n static void\n-write_integer (const char *source, int length)\n+write_integer (st_parameter_dt *dtp, const char *source, int length)\n {\n   char *p;\n   const char *q;\n@@ -1278,19 +1276,19 @@ write_integer (const char *source, int length)\n \n   digits = strlen (q);\n \n-  if(width < digits )\n-    width = digits ;\n-  p = write_block (width) ;\n+  if (width < digits)\n+    width = digits;\n+  p = write_block (dtp, width);\n   if (p == NULL)\n     return;\n-  if (no_leading_blank)\n+  if (dtp->u.p.no_leading_blank)\n     {\n       memcpy (p, q, digits);\n-      memset(p + digits ,' ', width - digits) ;\n+      memset (p + digits, ' ', width - digits);\n     }\n   else\n     {\n-      memset(p ,' ', width - digits) ;\n+      memset (p, ' ', width - digits);\n       memcpy (p + width - digits, q, digits);\n     }\n }\n@@ -1300,12 +1298,12 @@ write_integer (const char *source, int length)\n    the strings if the file has been opened in that mode.  */\n \n static void\n-write_character (const char *source, int length)\n+write_character (st_parameter_dt *dtp, const char *source, int length)\n {\n   int i, extra;\n   char *p, d;\n \n-  switch (current_unit->flags.delim)\n+  switch (dtp->u.p.current_unit->flags.delim)\n     {\n     case DELIM_APOSTROPHE:\n       d = '\\'';\n@@ -1329,7 +1327,7 @@ write_character (const char *source, int length)\n \t  extra++;\n     }\n \n-  p = write_block (length + extra);\n+  p = write_block (dtp, length + extra);\n   if (p == NULL)\n     return;\n \n@@ -1356,12 +1354,12 @@ write_character (const char *source, int length)\n    1PG24.15E4 for REAL(10) and 1PG40.31E4 for REAL(16).  */\n \n static void\n-write_real (const char *source, int length)\n+write_real (st_parameter_dt *dtp, const char *source, int length)\n {\n   fnode f ;\n-  int org_scale = g.scale_factor;\n+  int org_scale = dtp->u.p.scale_factor;\n   f.format = FMT_G;\n-  g.scale_factor = 1;\n+  dtp->u.p.scale_factor = 1;\n   switch (length)\n     {\n     case 4:\n@@ -1385,37 +1383,37 @@ write_real (const char *source, int length)\n       f.u.real.e = 4;\n       break;\n     default:\n-      internal_error (\"bad real kind\");\n+      internal_error (&dtp->common, \"bad real kind\");\n       break;\n     }\n-  write_float (&f, source , length);\n-  g.scale_factor = org_scale;\n+  write_float (dtp, &f, source , length);\n+  dtp->u.p.scale_factor = org_scale;\n }\n \n \n static void\n-write_complex (const char *source, int kind, size_t size)\n+write_complex (st_parameter_dt *dtp, const char *source, int kind, size_t size)\n {\n-  if (write_char ('('))\n+  if (write_char (dtp, '('))\n     return;\n-  write_real (source, kind);\n+  write_real (dtp, source, kind);\n \n-  if (write_char (','))\n+  if (write_char (dtp, ','))\n     return;\n-  write_real (source + size / 2, kind);\n+  write_real (dtp, source + size / 2, kind);\n \n-  write_char (')');\n+  write_char (dtp, ')');\n }\n \n \n /* Write the separator between items.  */\n \n static void\n-write_separator (void)\n+write_separator (st_parameter_dt *dtp)\n {\n   char *p;\n \n-  p = write_block (options.separator_len);\n+  p = write_block (dtp, options.separator_len);\n   if (p == NULL)\n     return;\n \n@@ -1428,53 +1426,52 @@ write_separator (void)\n    with strings.  */\n \n static void\n-list_formatted_write_scalar (bt type, void *p, int kind, size_t size)\n+list_formatted_write_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n+\t\t\t     size_t size)\n {\n-  static int char_flag;\n-\n-  if (current_unit == NULL)\n+  if (dtp->u.p.current_unit == NULL)\n     return;\n \n-  if (g.first_item)\n+  if (dtp->u.p.first_item)\n     {\n-      g.first_item = 0;\n-      char_flag = 0;\n-      write_char (' ');\n+      dtp->u.p.first_item = 0;\n+      write_char (dtp, ' ');\n     }\n   else\n     {\n-      if (type != BT_CHARACTER || !char_flag ||\n-\t  current_unit->flags.delim != DELIM_NONE)\n-\twrite_separator ();\n+      if (type != BT_CHARACTER || !dtp->u.p.char_flag ||\n+\t  dtp->u.p.current_unit->flags.delim != DELIM_NONE)\n+\twrite_separator (dtp);\n     }\n \n   switch (type)\n     {\n     case BT_INTEGER:\n-      write_integer (p, kind);\n+      write_integer (dtp, p, kind);\n       break;\n     case BT_LOGICAL:\n-      write_logical (p, kind);\n+      write_logical (dtp, p, kind);\n       break;\n     case BT_CHARACTER:\n-      write_character (p, kind);\n+      write_character (dtp, p, kind);\n       break;\n     case BT_REAL:\n-      write_real (p, kind);\n+      write_real (dtp, p, kind);\n       break;\n     case BT_COMPLEX:\n-      write_complex (p, kind, size);\n+      write_complex (dtp, p, kind, size);\n       break;\n     default:\n-      internal_error (\"list_formatted_write(): Bad type\");\n+      internal_error (&dtp->common, \"list_formatted_write(): Bad type\");\n     }\n \n-  char_flag = (type == BT_CHARACTER);\n+  dtp->u.p.char_flag = (type == BT_CHARACTER);\n }\n \n \n void\n-list_formatted_write (bt type, void *p, int kind, size_t size, size_t nelems)\n+list_formatted_write (st_parameter_dt *dtp, bt type, void *p, int kind,\n+\t\t      size_t size, size_t nelems)\n {\n   size_t elem;\n   char *tmp;\n@@ -1484,8 +1481,8 @@ list_formatted_write (bt type, void *p, int kind, size_t size, size_t nelems)\n   /* Big loop over all the elements.  */\n   for (elem = 0; elem < nelems; elem++)\n     {\n-      g.item_count++;\n-      list_formatted_write_scalar (type, tmp + size*elem, kind, size);\n+      dtp->u.p.item_count++;\n+      list_formatted_write_scalar (dtp, type, tmp + size*elem, kind, size);\n     }\n }\n \n@@ -1512,12 +1509,8 @@ list_formatted_write (bt type, void *p, int kind, size_t size, size_t nelems)\n \n #define NML_DIGITS 20\n \n-/* Stores the delimiter to be used for character objects.  */\n-\n-static const char * nml_delim;\n-\n static namelist_info *\n-nml_write_obj (namelist_info * obj, index_type offset,\n+nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \t       namelist_info * base, char * base_name)\n {\n   int rep_ctr;\n@@ -1543,23 +1536,23 @@ nml_write_obj (namelist_info * obj, index_type offset,\n \n   if (obj->type != GFC_DTYPE_DERIVED)\n     {\n-      write_character (\"\\n \", 2);\n+      write_character (dtp, \"\\n \", 2);\n       len = 0;\n       if (base)\n \t{\n \t  len =strlen (base->var_name);\n \t  for (dim_i = 0; dim_i < (index_type) strlen (base_name); dim_i++)\n             {\n \t      cup = toupper (base_name[dim_i]);\n-\t      write_character (&cup, 1);\n+\t      write_character (dtp, &cup, 1);\n             }\n \t}\n       for (dim_i =len; dim_i < (index_type) strlen (obj->var_name); dim_i++)\n \t{\n \t  cup = toupper (obj->var_name[dim_i]);\n-\t  write_character (&cup, 1);\n+\t  write_character (dtp, &cup, 1);\n \t}\n-      write_character (\"=\", 1);\n+      write_character (dtp, \"=\", 1);\n     }\n \n   /* Counts the number of data output on a line, including names.  */\n@@ -1629,8 +1622,8 @@ nml_write_obj (namelist_info * obj, index_type offset,\n \t  if (rep_ctr > 1)\n \t    {\n \t      st_sprintf(rep_buff, \" %d*\", rep_ctr);\n-\t      write_character (rep_buff, strlen (rep_buff));\n-\t      no_leading_blank = 1;\n+\t      write_character (dtp, rep_buff, strlen (rep_buff));\n+\t      dtp->u.p.no_leading_blank = 1;\n \t    }\n \t  num++;\n \n@@ -1641,29 +1634,29 @@ nml_write_obj (namelist_info * obj, index_type offset,\n \t    {\n \n \t    case GFC_DTYPE_INTEGER:\n-              write_integer (p, len);\n+\t      write_integer (dtp, p, len);\n               break;\n \n \t    case GFC_DTYPE_LOGICAL:\n-              write_logical (p, len);\n+\t      write_logical (dtp, p, len);\n               break;\n \n \t    case GFC_DTYPE_CHARACTER:\n-\t      if (nml_delim)\n-\t\twrite_character (nml_delim, 1);\n-\t      write_character (p, obj->string_length);\n-\t      if (nml_delim)\n-\t\twrite_character (nml_delim, 1);\n+\t      if (dtp->u.p.nml_delim)\n+\t\twrite_character (dtp, &dtp->u.p.nml_delim, 1);\n+\t      write_character (dtp, p, obj->string_length);\n+\t      if (dtp->u.p.nml_delim)\n+\t\twrite_character (dtp, &dtp->u.p.nml_delim, 1);\n               break;\n \n \t    case GFC_DTYPE_REAL:\n-              write_real (p, len);\n+\t      write_real (dtp, p, len);\n               break;\n \n \t    case GFC_DTYPE_COMPLEX:\n-\t      no_leading_blank = 0;\n+\t      dtp->u.p.no_leading_blank = 0;\n \t      num++;\n-              write_complex (p, len, obj_size);\n+              write_complex (dtp, p, len, obj_size);\n               break;\n \n \t    case GFC_DTYPE_DERIVED:\n@@ -1713,7 +1706,8 @@ nml_write_obj (namelist_info * obj, index_type offset,\n \t\t   cmp && !strncmp (cmp->var_name, obj_name, obj_name_len);\n \t\t   cmp = retval)\n \t\t{\n-\t\t  retval = nml_write_obj (cmp, (index_type)(p - obj->mem_pos),\n+\t\t  retval = nml_write_obj (dtp, cmp,\n+\t\t\t\t\t  (index_type)(p - obj->mem_pos),\n \t\t\t\t\t  obj, ext_name);\n \t\t}\n \n@@ -1722,19 +1716,19 @@ nml_write_obj (namelist_info * obj, index_type offset,\n \t      goto obj_loop;\n \n             default:\n-              internal_error (\"Bad type for namelist write\");\n+\t      internal_error (&dtp->common, \"Bad type for namelist write\");\n             }\n \n \t  /* Reset the leading blank suppression, write a comma and, if 5\n \t     values have been output, write a newline and advance to column\n \t     2. Reset the repeat counter.  */\n \n-\t  no_leading_blank = 0;\n-\t  write_character (\",\", 1);\n+\t  dtp->u.p.no_leading_blank = 0;\n+\t  write_character (dtp, \",\", 1);\n \t  if (num > 5)\n \t    {\n \t      num = 0;\n-\t      write_character (\"\\n \", 2);\n+\t      write_character (dtp, \"\\n \", 2);\n \t    }\n \t  rep_ctr = 1;\n \t}\n@@ -1767,7 +1761,7 @@ nml_write_obj (namelist_info * obj, index_type offset,\n    the treatment of derived types.  */\n \n void\n-namelist_write (void)\n+namelist_write (st_parameter_dt *dtp)\n {\n   namelist_info * t1, *t2, *dummy = NULL;\n   index_type i;\n@@ -1778,46 +1772,47 @@ namelist_write (void)\n \n   /* Set the delimiter for namelist output.  */\n \n-  tmp_delim = current_unit->flags.delim;\n-  current_unit->flags.delim = DELIM_NONE;\n+  tmp_delim = dtp->u.p.current_unit->flags.delim;\n+  dtp->u.p.current_unit->flags.delim = DELIM_NONE;\n   switch (tmp_delim)\n     {\n     case (DELIM_QUOTE):\n-      nml_delim = \"\\\"\";\n+      dtp->u.p.nml_delim = '\"';\n       break;\n \n     case (DELIM_APOSTROPHE):\n-      nml_delim = \"'\";\n+      dtp->u.p.nml_delim = '\\'';\n       break;\n \n     default:\n-      nml_delim = NULL;\n+      dtp->u.p.nml_delim = '\\0';\n+      break;\n     }\n \n-  write_character (\"&\",1);\n+  write_character (dtp, \"&\", 1);\n \n   /* Write namelist name in upper case - f95 std.  */\n \n-  for (i = 0 ;i < ioparm.namelist_name_len ;i++ )\n+  for (i = 0 ;i < dtp->namelist_name_len ;i++ )\n     {\n-      c = toupper (ioparm.namelist_name[i]);\n-      write_character (&c ,1);\n-\t    }\n+      c = toupper (dtp->namelist_name[i]);\n+      write_character (dtp, &c ,1);\n+    }\n \n-  if (ionml != NULL)\n+  if (dtp->u.p.ionml != NULL)\n     {\n-      t1 = ionml;\n+      t1 = dtp->u.p.ionml;\n       while (t1 != NULL)\n \t{\n \t  t2 = t1;\n-\t  t1 = nml_write_obj (t2, dummy_offset, dummy, dummy_name);\n+\t  t1 = nml_write_obj (dtp, t2, dummy_offset, dummy, dummy_name);\n \t}\n     }\n-  write_character (\"  /\\n\", 4);\n+  write_character (dtp, \"  /\\n\", 4);\n \n   /* Recover the original delimiter.  */\n \n-  current_unit->flags.delim = tmp_delim;\n+  dtp->u.p.current_unit->flags.delim = tmp_delim;\n }\n \n #undef NML_DIGITS"}, {"sha": "ba90fa8a6f7c4f1dc889df7dcbc65c1e398e1061", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -437,11 +437,11 @@ iexport_data_proto(filename);\n extern void stupid_function_name_for_static_linking (void);\n internal_proto(stupid_function_name_for_static_linking);\n \n-extern void library_start (void);\n+struct st_parameter_common;\n+extern void library_start (struct st_parameter_common *);\n internal_proto(library_start);\n \n-extern void library_end (void);\n-internal_proto(library_end);\n+#define library_end()\n \n extern void set_args (int, char **);\n export_proto(set_args);\n@@ -465,13 +465,14 @@ internal_proto(xtoa);\n extern void os_error (const char *) __attribute__ ((noreturn));\n internal_proto(os_error);\n \n-extern void show_locus (void);\n+extern void show_locus (struct st_parameter_common *);\n internal_proto(show_locus);\n \n extern void runtime_error (const char *) __attribute__ ((noreturn));\n iexport_proto(runtime_error);\n \n-extern void internal_error (const char *) __attribute__ ((noreturn));\n+extern void internal_error (struct st_parameter_common *, const char *)\n+  __attribute__ ((noreturn));\n internal_proto(internal_error);\n \n extern const char *get_oserror (void);\n@@ -491,7 +492,7 @@ internal_proto(st_sprintf);\n extern const char *translate_error (int);\n internal_proto(translate_error);\n \n-extern void generate_error (int, const char *);\n+extern void generate_error (struct st_parameter_common *, int, const char *);\n internal_proto(generate_error);\n \n /* fpu.c */\n@@ -526,7 +527,8 @@ internal_proto(show_variables);\n \n /* string.c */\n \n-extern int find_option (const char *, int, const st_option *, const char *);\n+extern int find_option (struct st_parameter_common *, const char *, int,\n+\t\t\tconst st_option *, const char *);\n internal_proto(find_option);\n \n extern int fstrlen (const char *, int);"}, {"sha": "31f1cabfc7487f5587f119896154f3efd64391fa", "filename": "libgfortran/libtool-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Flibtool-version", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Flibtool-version", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibtool-version?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -3,4 +3,4 @@\n # This is a separate file so that version updates don't involve re-running\n # automake.\n # CURRENT:REVISION:AGE\n-0:0:0\n+1:0:0"}, {"sha": "7f85b5ceb3a815d3d98f21c0de423c4523bcb590", "filename": "libgfortran/runtime/error.c", "status": "modified", "additions": 25, "deletions": 33, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fruntime%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fruntime%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Ferror.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -37,6 +37,7 @@ Boston, MA 02110-1301, USA.  */\n \n #include \"libgfortran.h\"\n #include \"../io/io.h\"\n+#include \"../io/unix.h\"\n \n /* Error conditions.  The tricky part here is printing a message when\n  * it is the I/O subsystem that is severely wounded.  Our goal is to\n@@ -53,17 +54,6 @@ Boston, MA 02110-1301, USA.  */\n  * Other error returns are reserved for the STOP statement with a numeric code.\n  */\n \n-/* locus variables.  These are optionally set by a caller before a\n- * library subroutine is called.  They are always cleared on exit so\n- * that files that report loci and those that do not can be linked\n- * together without reporting an erroneous position. */\n-\n-char *filename = 0;\n-iexport_data(filename);\n-\n-unsigned line = 0;\n-iexport_data(line);\n-\n /* gfc_itoa()-- Integer to decimal conversion. */\n \n const char *\n@@ -145,9 +135,10 @@ st_printf (const char *format, ...)\n   const char *q;\n   stream *s;\n   char itoa_buf[GFC_ITOA_BUF_SIZE];\n+  unix_stream err_stream;\n \n   total = 0;\n-  s = init_error_stream ();\n+  s = init_error_stream (&err_stream);\n   va_start (arg, format);\n \n   for (;;)\n@@ -288,12 +279,12 @@ st_sprintf (char *buffer, const char *format, ...)\n  * something went wrong */\n \n void\n-show_locus (void)\n+show_locus (st_parameter_common *cmp)\n {\n-  if (!options.locus || filename == NULL)\n+  if (!options.locus || cmp == NULL || cmp->filename == NULL)\n     return;\n \n-  st_printf (\"At line %d of file %s\\n\", line, filename);\n+  st_printf (\"At line %d of file %s\\n\", cmp->line, cmp->filename);\n }\n \n \n@@ -324,7 +315,6 @@ void\n os_error (const char *message)\n {\n   recursion_check ();\n-  show_locus ();\n   st_printf (\"Operating system error: %s\\n%s\\n\", get_oserror (), message);\n   sys_exit (1);\n }\n@@ -337,7 +327,6 @@ void\n runtime_error (const char *message)\n {\n   recursion_check ();\n-  show_locus ();\n   st_printf (\"Fortran runtime error: %s\\n\", message);\n   sys_exit (2);\n }\n@@ -348,10 +337,10 @@ iexport(runtime_error);\n  * that indicate something deeply wrong. */\n \n void\n-internal_error (const char *message)\n+internal_error (st_parameter_common *cmp, const char *message)\n {\n   recursion_check ();\n-  show_locus ();\n+  show_locus (cmp);\n   st_printf (\"Internal Error: %s\\n\", message);\n \n   /* This function call is here to get the main.o object file included\n@@ -452,48 +441,52 @@ translate_error (int code)\n  * the most recent operating system error is used. */\n \n void\n-generate_error (int family, const char *message)\n+generate_error (st_parameter_common *cmp, int family, const char *message)\n {\n   /* Set the error status.  */\n-  if (ioparm.iostat != NULL)\n-    *ioparm.iostat = family;\n+  if ((cmp->flags & IOPARM_HAS_IOSTAT))\n+    *cmp->iostat = family;\n \n   if (message == NULL)\n     message =\n       (family == ERROR_OS) ? get_oserror () : translate_error (family);\n \n-  if (ioparm.iomsg)\n-    cf_strcpy (ioparm.iomsg, ioparm.iomsg_len, message);\n+  if (cmp->flags & IOPARM_HAS_IOMSG)\n+    cf_strcpy (cmp->iomsg, cmp->iomsg_len, message);\n \n   /* Report status back to the compiler.  */\n+  cmp->flags &= ~IOPARM_LIBRETURN_MASK;\n   switch (family)\n     {\n     case ERROR_EOR:\n-      ioparm.library_return = LIBRARY_EOR;\n-      if (ioparm.eor != 0)\n+      cmp->flags |= IOPARM_LIBRETURN_EOR;\n+      if ((cmp->flags & IOPARM_EOR))\n \treturn;\n       break;\n \n     case ERROR_END:\n-      ioparm.library_return = LIBRARY_END;\n-      if (ioparm.end != 0)\n+      cmp->flags |= IOPARM_LIBRETURN_END;\n+      if ((cmp->flags & IOPARM_END))\n \treturn;\n       break;\n \n     default:\n-      ioparm.library_return = LIBRARY_ERROR;\n-      if (ioparm.err != 0)\n+      cmp->flags |= IOPARM_LIBRETURN_ERROR;\n+      if ((cmp->flags & IOPARM_ERR))\n \treturn;\n       break;\n     }\n \n   /* Return if the user supplied an iostat variable.  */\n-  if (ioparm.iostat != NULL)\n+  if ((cmp->flags & IOPARM_HAS_IOSTAT))\n     return;\n \n   /* Terminate the program */\n \n-  runtime_error (message);\n+  recursion_check ();\n+  show_locus (cmp);\n+  st_printf (\"Fortran runtime error: %s\\n\", message);\n+  sys_exit (2);\n }\n \n \n@@ -511,7 +504,6 @@ notify_std (int std, const char * message)\n   if ((compile_options.allow_std & std) != 0 && !warning)\n     return SUCCESS;\n \n-  show_locus ();\n   if (!warning)\n     {\n       st_printf (\"Fortran runtime error: %s\\n\", message);"}, {"sha": "f81a3b05a421e83f6439409365692779a624c9f1", "filename": "libgfortran/runtime/fpu.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fruntime%2Ffpu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fruntime%2Ffpu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Ffpu.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -1,8 +1,3 @@\n-/* This is needed for fpu-glibc.h, before all other includes */\n-#ifdef HAVE_FENV_H\n-#define _GNU_SOURCE\n-#endif\n-\n #include \"libgfortran.h\"\n \n /* We include the platform-dependent code.  */"}, {"sha": "95572e1128bc1042d978bc0c98cfb50ab68166e7", "filename": "libgfortran/runtime/pause.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fruntime%2Fpause.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fruntime%2Fpause.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fpause.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -1,5 +1,5 @@\n /* Implementation of the STOP statement.\n-   Copyright 2002 Free Software Foundation, Inc.\n+   Copyright 2002, 2005 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n@@ -55,8 +55,6 @@ export_proto(pause_numeric);\n void\n pause_numeric (GFC_INTEGER_4 code)\n {\n-  show_locus ();\n-\n   if (code == -1)\n     st_printf (\"PAUSE\\n\");\n   else\n@@ -71,8 +69,6 @@ export_proto(pause_string);\n void\n pause_string (char *string, GFC_INTEGER_4 len)\n {\n-  show_locus ();\n-\n   st_printf (\"PAUSE \");\n   while (len--)\n     st_printf (\"%c\", *(string++));"}, {"sha": "e4c3620e51fd90bc5f335023a3bb145cbb03b841", "filename": "libgfortran/runtime/stop.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fruntime%2Fstop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fruntime%2Fstop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fstop.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -1,5 +1,5 @@\n /* Implementation of the STOP statement.\n-   Copyright 2002 Free Software Foundation, Inc.\n+   Copyright 2002, 2005 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n@@ -37,8 +37,6 @@ Boston, MA 02110-1301, USA.  */\n void\n stop_numeric (GFC_INTEGER_4 code)\n {\n-  show_locus ();\n-\n   if (code == -1)\n     code = 0;\n   else\n@@ -55,8 +53,6 @@ export_proto(stop_string);\n void\n stop_string (const char *string, GFC_INTEGER_4 len)\n {\n-  show_locus ();\n-\n   st_printf (\"STOP \");\n   while (len--)\n     st_printf (\"%c\", *(string++));"}, {"sha": "00dfc298305168111aa89e6abf4c3d93b5827758", "filename": "libgfortran/runtime/string.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fruntime%2Fstring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb/libgfortran%2Fruntime%2Fstring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fstring.c?ref=5e805e44c0dc407c6e2e0ac4a6b6346e4c6805eb", "patch": "@@ -31,7 +31,7 @@ Boston, MA 02110-1301, USA.  */\n #include <string.h>\n \n #include \"libgfortran.h\"\n-\n+#include \"../io/io.h\"\n \n /* Compare a C-style string with a fortran style string in a case-insensitive\n    manner.  Used for decoding string options to various statements.  Returns\n@@ -104,14 +104,14 @@ cf_strcpy (char *dest, int dest_len, const char *src)\n    if no default is provided.  */\n \n int\n-find_option (const char *s1, int s1_len, const st_option * opts,\n-\t     const char *error_message)\n+find_option (st_parameter_common *cmp, const char *s1, int s1_len,\n+\t     const st_option * opts, const char *error_message)\n {\n   for (; opts->name; opts++)\n     if (compare0 (s1, s1_len, opts->name))\n       return opts->value;\n \n-  generate_error (ERROR_BAD_OPTION, error_message);\n+  generate_error (cmp, ERROR_BAD_OPTION, error_message);\n \n   return -1;\n }"}]}