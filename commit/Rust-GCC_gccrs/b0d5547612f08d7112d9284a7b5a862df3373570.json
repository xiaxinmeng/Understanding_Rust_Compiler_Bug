{"sha": "b0d5547612f08d7112d9284a7b5a862df3373570", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBkNTU0NzYxMmYwOGQ3MTEyZDkyODRhN2I1YTg2MmRmMzM3MzU3MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2019-11-21T14:58:08Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-11-21T14:58:08Z"}, "message": "ipa-fnsummary.c (evaluate_conditions_for_known_args): Be ready for some vectors to not be allocated.\n\n\n\t* ipa-fnsummary.c (evaluate_conditions_for_known_args): Be\n\tready for some vectors to not be allocated.\n\t(evaluate_properties_for_edge): Document better; make\n\tknown_vals and known_aggs caller allocated; avoid determining\n\tvalues of parameters which are not used.\n\t(ipa_merge_fn_summary_after_inlining): Pre allocate known_vals and\n\tknown_aggs.\n\t* ipa-inline-analysis.c (do_estimate_edge_time): Likewise.\n\t(do_estimate_edge_size): Likewise.\n\t(do_estimate_edge_hints): Likewise.\n\t* ipa-cp.c (ipa_get_indirect_edge_target_1): Do not early exit when\n\tvalues are not known.\n\t(ipa_release_agg_values): Add option to not release vector itself.\n\nFrom-SVN: r278553", "tree": {"sha": "b47107257744ee912baa2c52e72eef798328f1f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b47107257744ee912baa2c52e72eef798328f1f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0d5547612f08d7112d9284a7b5a862df3373570", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0d5547612f08d7112d9284a7b5a862df3373570", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0d5547612f08d7112d9284a7b5a862df3373570", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0d5547612f08d7112d9284a7b5a862df3373570/comments", "author": null, "committer": null, "parents": [{"sha": "48ffab987ae013a642398ef4fe5ffdce71571ba5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48ffab987ae013a642398ef4fe5ffdce71571ba5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48ffab987ae013a642398ef4fe5ffdce71571ba5"}], "stats": {"total": 270, "additions": 168, "deletions": 102}, "files": [{"sha": "34820c33d2d8f4b452c20aa1f4c9741c1eaba980", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0d5547612f08d7112d9284a7b5a862df3373570/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0d5547612f08d7112d9284a7b5a862df3373570/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b0d5547612f08d7112d9284a7b5a862df3373570", "patch": "@@ -1,3 +1,19 @@\n+2019-11-21  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-fnsummary.c (evaluate_conditions_for_known_args): Be\n+\tready for some vectors to not be allocated.\n+\t(evaluate_properties_for_edge): Document better; make\n+\tknown_vals and known_aggs caller allocated; avoid determining\n+\tvalues of parameters which are not used.\n+\t(ipa_merge_fn_summary_after_inlining): Pre allocate known_vals and\n+\tknown_aggs.\n+\t* ipa-inline-analysis.c (do_estimate_edge_time): Likewise.\n+\t(do_estimate_edge_size): Likewise.\n+\t(do_estimate_edge_hints): Likewise.\n+\t* ipa-cp.c (ipa_get_indirect_edge_target_1): Do not early exit when\n+\tvalues are not known.\n+\t(ipa_release_agg_values): Add option to not release vector itself.\n+\n 2019-11-21  Richard Biener  <rguenther@suse.de>\n \n \t* cfgloop.h (loop_iterator::~loop_iterator): Remove."}, {"sha": "31a98a3d98ab729034d6f89775d87087a0794739", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0d5547612f08d7112d9284a7b5a862df3373570/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0d5547612f08d7112d9284a7b5a862df3373570/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=b0d5547612f08d7112d9284a7b5a862df3373570", "patch": "@@ -2744,18 +2744,17 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n {\n   int param_index = ie->indirect_info->param_index;\n   HOST_WIDE_INT anc_offset;\n-  tree t;\n+  tree t = NULL;\n   tree target = NULL;\n \n   *speculative = false;\n \n-  if (param_index == -1\n-      || known_csts.length () <= (unsigned int) param_index)\n+  if (param_index == -1)\n     return NULL_TREE;\n \n   if (!ie->indirect_info->polymorphic)\n     {\n-      tree t;\n+      tree t = NULL;\n \n       if (ie->indirect_info->agg_contents)\n \t{\n@@ -2782,7 +2781,11 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n \t      else\n \t\tagg = NULL;\n \t      bool from_global_constant;\n-\t      t = ipa_find_agg_cst_for_param (agg, known_csts[param_index],\n+\t      t = ipa_find_agg_cst_for_param (agg,\n+\t\t\t\t\t      (unsigned) param_index\n+\t\t\t\t\t\t < known_csts.length ()\n+\t\t\t\t\t      ? known_csts[param_index]\n+\t\t\t\t\t      : NULL,\n \t\t\t\t\t      ie->indirect_info->offset,\n \t\t\t\t\t      ie->indirect_info->by_ref,\n \t\t\t\t\t      &from_global_constant);\n@@ -2792,7 +2795,7 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n \t\tt = NULL_TREE;\n \t    }\n \t}\n-      else\n+      else if ((unsigned) param_index < known_csts.length ())\n \tt = known_csts[param_index];\n \n       if (t\n@@ -2833,7 +2836,10 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n       && !ie->indirect_info->by_ref)\n     {\n       struct ipa_agg_value_set *agg = &known_aggs[param_index];\n-      t = ipa_find_agg_cst_for_param (agg, known_csts[param_index],\n+      t = ipa_find_agg_cst_for_param (agg,\n+\t\t\t\t      (unsigned) param_index\n+\t\t\t\t\t < known_csts.length ()\n+\t\t\t\t      ? known_csts[param_index] : NULL,\n \t\t\t\t      ie->indirect_info->offset, true);\n     }\n \n@@ -2867,7 +2873,7 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n     }\n \n   /* Do we know the constant value of pointer?  */\n-  if (!t)\n+  if (!t && (unsigned) param_index < known_csts.length ())\n     t = known_csts[param_index];\n \n   gcc_checking_assert (!t || TREE_CODE (t) != TREE_BINFO);"}, {"sha": "9ac998482b5c1731998a4366c732a728ca0bc105", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 129, "deletions": 85, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0d5547612f08d7112d9284a7b5a862df3373570/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0d5547612f08d7112d9284a7b5a862df3373570/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=b0d5547612f08d7112d9284a7b5a862df3373570", "patch": "@@ -342,7 +342,7 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \n   for (i = 0; vec_safe_iterate (info->conds, i, &c); i++)\n     {\n-      tree val;\n+      tree val = NULL;\n       tree res;\n       int j;\n       struct expr_eval_op *op;\n@@ -351,34 +351,33 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n          (especially for K&R style programs).  So bound check here (we assume\n          known_aggs vector, if non-NULL, has the same length as\n          known_vals).  */\n-      gcc_checking_assert (!known_aggs.exists ()\n+      gcc_checking_assert (!known_aggs.length () || !known_vals.length ()\n \t\t\t   || (known_vals.length () == known_aggs.length ()));\n-      if (c->operand_num >= (int) known_vals.length ())\n-\t{\n-\t  clause |= 1 << (i + predicate::first_dynamic_condition);\n-\t  nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n-\t  continue;\n-\t}\n \n       if (c->agg_contents)\n \t{\n \t  struct ipa_agg_value_set *agg;\n \n \t  if (c->code == predicate::changed\n \t      && !c->by_ref\n+\t      && c->operand_num < (int)known_vals.length ()\n \t      && (known_vals[c->operand_num] == error_mark_node))\n \t    continue;\n \n-\t  if (known_aggs.exists ())\n+\t  if (c->operand_num < (int)known_aggs.length ())\n \t    {\n \t      agg = &known_aggs[c->operand_num];\n-\t      val = ipa_find_agg_cst_for_param (agg, known_vals[c->operand_num],\n+\t      val = ipa_find_agg_cst_for_param (agg,\n+\t\t\t\t\t\tc->operand_num\n+\t\t\t\t\t\t   < (int) known_vals.length ()\n+\t\t\t\t\t\t? known_vals[c->operand_num]\n+\t\t\t\t\t\t: NULL,\n \t\t\t\t\t\tc->offset, c->by_ref);\n \t    }\n \t  else\n \t    val = NULL_TREE;\n \t}\n-      else\n+      else if (c->operand_num < (int) known_vals.length ())\n \t{\n \t  val = known_vals[c->operand_num];\n \t  if (val == error_mark_node && c->code != predicate::changed)\n@@ -504,7 +503,18 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n }\n \n \n-/* Work out what conditions might be true at invocation of E.  */\n+/* Work out what conditions might be true at invocation of E.\n+   Compute costs for inlined edge if INLINE_P is true.\n+\n+   Return in CLAUSE_PTR the evaluated condistions and in NONSPEC_CLAUSE_PTR\n+   (if non-NULL) conditions evaluated for nonspecialized clone called\n+   in a given context.\n+\n+   KNOWN_VALS_PTR and KNOWN_AGGS_PTR must be non-NULL and will be filled by\n+   known canstant and aggregate values of parameters.\n+\n+   KNOWN_CONTEXT_PTR, if non-NULL, will be filled by polymorphic call contexts\n+   of parameter used by a polymorphic call.  */\n \n void\n evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n@@ -517,113 +527,141 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n {\n   struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n   class ipa_fn_summary *info = ipa_fn_summaries->get (callee);\n-  vec<tree> known_vals = vNULL;\n   auto_vec<value_range, 32> known_value_ranges;\n-  vec<ipa_agg_value_set> known_aggs = vNULL;\n   class ipa_edge_args *args;\n \n   if (clause_ptr)\n     *clause_ptr = inline_p ? 0 : 1 << predicate::not_inlined_condition;\n-  if (known_vals_ptr)\n-    known_vals_ptr->create (0);\n-  if (known_contexts_ptr)\n-    known_contexts_ptr->create (0);\n \n   if (ipa_node_params_sum\n       && !e->call_stmt_cannot_inline_p\n-      && ((clause_ptr && info->conds) || known_vals_ptr || known_contexts_ptr)\n+      && (info->conds || known_contexts_ptr)\n       && (args = IPA_EDGE_REF (e)) != NULL)\n     {\n       struct cgraph_node *caller;\n-      class ipa_node_params *caller_parms_info, *callee_pi;\n+      class ipa_node_params *caller_parms_info, *callee_pi = NULL;\n       class ipa_call_summary *es = ipa_call_summaries->get (e);\n       int i, count = ipa_get_cs_argument_count (args);\n \n-      if (e->caller->inlined_to)\n-\tcaller = e->caller->inlined_to;\n-      else\n-\tcaller = e->caller;\n-      caller_parms_info = IPA_NODE_REF (caller);\n-      callee_pi = IPA_NODE_REF (callee);\n-\n-      if (count && (info->conds || known_vals_ptr))\n-\tknown_vals.safe_grow_cleared (count);\n-      if (count && info->conds)\n-\tknown_value_ranges.safe_grow_cleared (count);\n-      if (count && (info->conds || known_aggs_ptr))\n-\tknown_aggs.safe_grow_cleared (count);\n-      if (count && known_contexts_ptr)\n-\tknown_contexts_ptr->safe_grow_cleared (count);\n+      if (count)\n+\t{\n+\t  if (e->caller->inlined_to)\n+\t    caller = e->caller->inlined_to;\n+\t  else\n+\t    caller = e->caller;\n+\t  caller_parms_info = IPA_NODE_REF (caller);\n+          callee_pi = IPA_NODE_REF (callee);\n+\n+\t  /* Watch for thunks.  */\n+\t  if (callee_pi)\n+\t    /* Watch for variadic functions.  */\n+\t    count = MIN (count, ipa_get_param_count (callee_pi));\n+\t}\n \n       if (callee_pi)\n \tfor (i = 0; i < count; i++)\n \t  {\n \t    struct ipa_jump_func *jf = ipa_get_ith_jump_func (args, i);\n-\t    tree cst = ipa_value_from_jfunc (caller_parms_info, jf,\n-\t\t\t\t\t     ipa_get_type (callee_pi, i));\n \n-\t    if (!cst && e->call_stmt\n-\t\t&& i < (int)gimple_call_num_args (e->call_stmt))\n+\t    if (ipa_is_param_used_by_indirect_call (callee_pi, i)\n+\t\t|| ipa_is_param_used_by_ipa_predicates (callee_pi, i))\n \t      {\n-\t\tcst = gimple_call_arg (e->call_stmt, i);\n-\t\tif (!is_gimple_min_invariant (cst))\n-\t\t  cst = NULL;\n+\t\t/* Determine if we know constant value of the parameter.  */\n+\t\ttree cst = ipa_value_from_jfunc (caller_parms_info, jf,\n+\t\t\t\t\t\t ipa_get_type (callee_pi, i));\n+\n+\t\tif (!cst && e->call_stmt\n+\t\t    && i < (int)gimple_call_num_args (e->call_stmt))\n+\t\t  {\n+\t\t    cst = gimple_call_arg (e->call_stmt, i);\n+\t\t    if (!is_gimple_min_invariant (cst))\n+\t\t      cst = NULL;\n+\t\t  }\n+\t\tif (cst)\n+\t\t  {\n+\t\t    gcc_checking_assert (TREE_CODE (cst) != TREE_BINFO);\n+\t\t    if (!known_vals_ptr->length ())\n+\t\t      vec_safe_grow_cleared (known_vals_ptr, count);\n+\t\t    (*known_vals_ptr)[i] = cst;\n+\t\t  }\n+\t\telse if (inline_p && !es->param[i].change_prob)\n+\t\t  {\n+\t\t    if (!known_vals_ptr->length ())\n+\t\t      vec_safe_grow_cleared (known_vals_ptr, count);\n+\t\t    (*known_vals_ptr)[i] = error_mark_node;\n+\t\t  }\n+\n+\t\t/* If we failed to get simple constant, try value range.  */\n+\t\tif ((!cst || TREE_CODE (cst) != INTEGER_CST)\n+\t\t    && ipa_is_param_used_by_ipa_predicates (callee_pi, i))\n+\t\t  {\n+\t\t    value_range vr \n+\t\t       = ipa_value_range_from_jfunc (caller_parms_info, e, jf,\n+\t\t\t\t\t\t     ipa_get_type (callee_pi,\n+\t\t\t\t\t\t\t\t   i));\n+\t\t    if (!vr.undefined_p () && !vr.varying_p ())\n+\t\t      {\n+\t\t\tif (!known_value_ranges.length ())\n+\t\t\t  known_value_ranges.safe_grow_cleared (count);\n+\t\t\tknown_value_ranges[i] = vr;\n+\t\t      }\n+\t\t  }\n+\n+\t\t/* Determine known aggregate values.  */\n+\t\tipa_agg_value_set agg\n+\t\t    = ipa_agg_value_set_from_jfunc (caller_parms_info,\n+\t\t\t\t\t\t    caller, &jf->agg);\n+\t\tif (agg.items.length ())\n+\t\t  {\n+\t\t    if (!known_aggs_ptr->length ())\n+\t\t      vec_safe_grow_cleared (known_aggs_ptr, count);\n+\t\t    (*known_aggs_ptr)[i] = agg;\n+\t\t  }\n \t      }\n-\t    if (cst)\n+\n+\t    /* For calls used in polymorphic calls we further determine\n+\t       polymorphic call context.  */\n+\t    if (known_contexts_ptr\n+\t\t&& ipa_is_param_used_by_polymorphic_call (callee_pi, i))\n \t      {\n-\t\tgcc_checking_assert (TREE_CODE (cst) != TREE_BINFO);\n-\t\tif (known_vals.exists ())\n-\t\t  known_vals[i] = cst;\n-\t      }\n-\t    else if (inline_p && !es->param[i].change_prob)\n-\t      known_vals[i] = error_mark_node;\n-\n-\t    if (known_contexts_ptr)\n-\t      (*known_contexts_ptr)[i]\n-\t\t= ipa_context_from_jfunc (caller_parms_info, e, i, jf);\n-\t\n-\t    known_aggs[i] = ipa_agg_value_set_from_jfunc (caller_parms_info,\n-\t\t\t\t\t\t\t  caller, &jf->agg);\n-            if (info->conds)\n-              known_value_ranges[i] \n-                = ipa_value_range_from_jfunc (caller_parms_info, e, jf,\n-                                              ipa_get_type (callee_pi, i));\n+\t\tipa_polymorphic_call_context\n+\t\t   ctx = ipa_context_from_jfunc (caller_parms_info, e, i, jf);\n+\t\tif (!ctx.useless_p ())\n+\t\t  {\n+\t\t    if (!known_contexts_ptr->length ())\n+\t\t      known_contexts_ptr->safe_grow_cleared (count);\n+\t\t    (*known_contexts_ptr)[i]\n+\t\t      = ipa_context_from_jfunc (caller_parms_info, e, i, jf);\n+\t\t  }\n+\t       }\n \t  }\n \telse\n-\t  gcc_assert (callee->thunk.thunk_p);\n+\t  gcc_assert (!count || callee->thunk.thunk_p);\n     }\n-  else if (e->call_stmt && !e->call_stmt_cannot_inline_p\n-\t   && ((clause_ptr && info->conds) || known_vals_ptr))\n+  else if (e->call_stmt && !e->call_stmt_cannot_inline_p && info->conds)\n     {\n       int i, count = (int)gimple_call_num_args (e->call_stmt);\n \n-      if (count && (info->conds || known_vals_ptr))\n-\tknown_vals.safe_grow_cleared (count);\n       for (i = 0; i < count; i++)\n \t{\n \t  tree cst = gimple_call_arg (e->call_stmt, i);\n \t  if (!is_gimple_min_invariant (cst))\n \t    cst = NULL;\n \t  if (cst)\n-\t    known_vals[i] = cst;\n+\t    {\n+\t      if (!known_vals_ptr->length ())\n+\t        vec_safe_grow_cleared (known_vals_ptr, count);\n+\t      (*known_vals_ptr)[i] = cst;\n+\t    }\n \t}\n     }\n \n   evaluate_conditions_for_known_args (callee, inline_p,\n-\t\t\t\t      known_vals,\n+\t\t\t\t      *known_vals_ptr,\n \t\t\t\t      known_value_ranges,\n-\t\t\t\t      known_aggs, clause_ptr,\n+\t\t\t\t      *known_aggs_ptr,\n+\t\t\t\t      clause_ptr,\n \t\t\t\t      nonspec_clause_ptr);\n-\n-  if (known_vals_ptr)\n-    *known_vals_ptr = known_vals;\n-  else\n-    known_vals.release ();\n-\n-  if (known_aggs_ptr)\n-    *known_aggs_ptr = known_aggs;\n-  else\n-    ipa_release_agg_values (known_aggs);\n }\n \n \n@@ -2926,7 +2964,7 @@ estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n   enum availability avail;\n   bool speculative;\n \n-  if (!known_vals.exists () && !known_contexts.exists ())\n+  if (!known_vals.length () && !known_contexts.length ())\n     return false;\n   if (!opt_for_fn (ie->caller->decl, flag_indirect_inlining))\n     return false;\n@@ -3305,11 +3343,13 @@ ipa_call_context::release (bool all)\n   /* See if context is initialized at first place.  */\n   if (!m_node)\n     return;\n-  m_known_vals.release ();\n-  m_known_contexts.release ();\n-  ipa_release_agg_values (m_known_aggs);\n+  ipa_release_agg_values (m_known_aggs, all);\n   if (all)\n-    m_inline_param_summary.release ();\n+    {\n+      m_known_vals.release ();\n+      m_known_contexts.release ();\n+      m_inline_param_summary.release ();\n+    }\n }\n \n /* Return true if CTX describes the same call context as THIS.  */\n@@ -3813,8 +3853,12 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n   info->fp_expressions |= callee_info->fp_expressions;\n \n   if (callee_info->conds)\n-    evaluate_properties_for_edge (edge, true, &clause,\n-\t\t\t\t  NULL, NULL, NULL, NULL);\n+    {\n+      auto_vec<tree, 32> known_vals;\n+      auto_vec<ipa_agg_value_set, 32> known_aggs;\n+      evaluate_properties_for_edge (edge, true, &clause, NULL,\n+\t\t\t\t    &known_vals, NULL, &known_aggs);\n+    }\n   if (ipa_node_params_sum && callee_info->conds)\n     {\n       class ipa_edge_args *args = IPA_EDGE_REF (edge);"}, {"sha": "e36902073f57818c5cf8a762a433b096f783150a", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0d5547612f08d7112d9284a7b5a862df3373570/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0d5547612f08d7112d9284a7b5a862df3373570/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=b0d5547612f08d7112d9284a7b5a862df3373570", "patch": "@@ -186,9 +186,9 @@ do_estimate_edge_time (struct cgraph_edge *edge, sreal *ret_nonspec_time)\n   ipa_hints hints;\n   struct cgraph_node *callee;\n   clause_t clause, nonspec_clause;\n-  vec<tree> known_vals;\n-  vec<ipa_polymorphic_call_context> known_contexts;\n-  vec<ipa_agg_value_set> known_aggs;\n+  auto_vec<tree, 32> known_vals;\n+  auto_vec<ipa_polymorphic_call_context, 32> known_contexts;\n+  auto_vec<ipa_agg_value_set, 32> known_aggs;\n   class ipa_call_summary *es = ipa_call_summaries->get (edge);\n   int min_size = -1;\n \n@@ -308,9 +308,9 @@ do_estimate_edge_size (struct cgraph_edge *edge)\n   int size;\n   struct cgraph_node *callee;\n   clause_t clause, nonspec_clause;\n-  vec<tree> known_vals;\n-  vec<ipa_polymorphic_call_context> known_contexts;\n-  vec<ipa_agg_value_set> known_aggs;\n+  auto_vec<tree, 32> known_vals;\n+  auto_vec<ipa_polymorphic_call_context, 32> known_contexts;\n+  auto_vec<ipa_agg_value_set, 32> known_aggs;\n \n   /* When we do caching, use do_estimate_edge_time to populate the entry.  */\n \n@@ -347,9 +347,9 @@ do_estimate_edge_hints (struct cgraph_edge *edge)\n   ipa_hints hints;\n   struct cgraph_node *callee;\n   clause_t clause, nonspec_clause;\n-  vec<tree> known_vals;\n-  vec<ipa_polymorphic_call_context> known_contexts;\n-  vec<ipa_agg_value_set> known_aggs;\n+  auto_vec<tree, 32> known_vals;\n+  auto_vec<ipa_polymorphic_call_context, 32> known_contexts;\n+  auto_vec<ipa_agg_value_set, 32> known_aggs;\n \n   /* When we do caching, use do_estimate_edge_time to populate the entry.  */\n "}]}