{"sha": "3c9b99ef7115fa88ef4d744cc2afc424bd5c3ef2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M5Yjk5ZWY3MTE1ZmE4OGVmNGQ3NDRjYzJhZmM0MjRiZDVjM2VmMg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-10-29T14:47:17Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-10-29T14:47:17Z"}, "message": "libstdc++: Make std::function work better with -fno-rtti\n\nThis change allows std::function::target<F>() to work even without RTTI,\nusing the same approach as std::any. Because we know what the manager\nfunction would be for a given type, we can check if the stored pointer\nhas the expected address. If it does, we don't need to use RTTI. If it\nisn't equal, we still need to do the RTTI check (when RTTI is enabled)\nto handle the case where the same function has different addresses in\ndifferent shared objects.\n\nThis also changes the implementation of the manager function to return a\nnull pointer result when asked for the type_info of the target object.\nThis not only avoids a warning with -Wswitch -Wsystem-headers, but also\navoids prevents std::function::target_type() from dereferencing an\nuninitialized pointer when the linker keeps an instantiation of the\nmanager function that was compiled without RTTI.\n\nFinally, this fixes a bug in the non-const overload of function::target\nwhere calling it with a function type F was ill-formed, due to\nattempting to use const_cast<F*>(ptr). The standard only allows\nconst_cast<T*> when T is an object type.  The solution is to use\n*const_cast<F**>(&ptr) instead, because F* is an object type even if F\nisn't. I've also used _GLIBCXX17_CONSTEXPR in function::target so that\nit doesn't bother instantiating anything for types that can never be a\nvalid target.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/std_function.h (_Function_handler<void, void>):\n\tDefine explicit specialization used for invalid target types.\n\t(_Base_manager::_M_manager) [!__cpp_rtti]: Return null.\n\t(function::target_type()): Check for null pointer.\n\t(function::target()): Define unconditionall. Fix bug with\n\tconst_cast of function pointer type.\n\t(function::target() const): Define unconditionally, but\n\tonly use RTTI if enabled.\n\t* testsuite/20_util/function/target_no_rtti.cc: New test.", "tree": {"sha": "4f761351c67a25f51e3ad6fabf99175d2f1720b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f761351c67a25f51e3ad6fabf99175d2f1720b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c9b99ef7115fa88ef4d744cc2afc424bd5c3ef2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c9b99ef7115fa88ef4d744cc2afc424bd5c3ef2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c9b99ef7115fa88ef4d744cc2afc424bd5c3ef2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c9b99ef7115fa88ef4d744cc2afc424bd5c3ef2/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "054d7b9f6f6816a83dcadfdfe2532795cae04ff3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/054d7b9f6f6816a83dcadfdfe2532795cae04ff3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/054d7b9f6f6816a83dcadfdfe2532795cae04ff3"}], "stats": {"total": 123, "additions": 109, "deletions": 14}, "files": [{"sha": "054d9cbbf02b57e9d190a13f0aa8580d01e4223f", "filename": "libstdc++-v3/include/bits/std_function.h", "status": "modified", "additions": 53, "deletions": 14, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9b99ef7115fa88ef4d744cc2afc424bd5c3ef2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9b99ef7115fa88ef4d744cc2afc424bd5c3ef2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_function.h?ref=3c9b99ef7115fa88ef4d744cc2afc424bd5c3ef2", "patch": "@@ -183,11 +183,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{\n \t  switch (__op)\n \t    {\n-#if __cpp_rtti\n \t    case __get_type_info:\n+#if __cpp_rtti\n \t      __dest._M_access<const type_info*>() = &typeid(_Functor);\n-\t      break;\n+#else\n+\t      __dest._M_access<const type_info*>() = nullptr;\n #endif\n+\t      break;\n \t    case __get_functor_ptr:\n \t      __dest._M_access<_Functor*>() = _M_get_pointer(__source);\n \t      break;\n@@ -293,6 +295,31 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n     };\n \n+  // Specialization for invalid types\n+  template<>\n+    class _Function_handler<void, void>\n+    {\n+    public:\n+      static bool\n+      _M_manager(_Any_data&, const _Any_data&, _Manager_operation)\n+      { return false; }\n+    };\n+\n+  // Avoids instantiating ill-formed specializations of _Function_handler\n+  // in std::function<_Signature>::target<_Functor>().\n+  // e.g. _Function_handler<Sig, void()> and _Function_handler<Sig, void>\n+  // would be ill-formed.\n+  template<typename _Signature, typename _Functor,\n+\t   bool __valid = is_object<_Functor>::value>\n+    struct _Target_handler\n+    : _Function_handler<_Signature, typename remove_cv<_Functor>::type>\n+    { };\n+\n+  template<typename _Signature, typename _Functor>\n+    struct _Target_handler<_Signature, _Functor, false>\n+    : _Function_handler<void, void>\n+    { };\n+\n   /**\n    *  @brief Primary class template for std::function.\n    *  @ingroup functors\n@@ -553,17 +580,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  {\n \t    _Any_data __typeinfo_result;\n \t    _M_manager(__typeinfo_result, _M_functor, __get_type_info);\n-\t    return *__typeinfo_result._M_access<const type_info*>();\n+\t    if (auto __ti =  __typeinfo_result._M_access<const type_info*>())\n+\t      return *__ti;\n \t  }\n-\telse\n-\t  return typeid(void);\n+\treturn typeid(void);\n       }\n+#endif\n \n       /**\n        *  @brief Access the stored target function object.\n        *\n        *  @return Returns a pointer to the stored target function object,\n-       *  if @c typeid(_Functor).equals(target_type()); otherwise, a NULL\n+       *  if @c typeid(_Functor).equals(target_type()); otherwise, a null\n        *  pointer.\n        *\n        * This function does not throw exceptions.\n@@ -576,24 +604,35 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{\n \t  const function* __const_this = this;\n \t  const _Functor* __func = __const_this->template target<_Functor>();\n-\t  return const_cast<_Functor*>(__func);\n+\t  // If is_function_v<_Functor> is true then const_cast<_Functor*>\n+\t  // would be ill-formed, so use *const_cast<_Functor**> instead.\n+\t  return *const_cast<_Functor**>(&__func);\n \t}\n \n       template<typename _Functor>\n \tconst _Functor*\n \ttarget() const noexcept\n \t{\n-\t  if (typeid(_Functor) == target_type() && _M_manager)\n+\t  if _GLIBCXX17_CONSTEXPR (is_object<_Functor>::value)\n \t    {\n-\t      _Any_data __ptr;\n-\t      _M_manager(__ptr, _M_functor, __get_functor_ptr);\n-\t      return __ptr._M_access<const _Functor*>();\n+\t      // For C++11 and C++14 if-constexpr is not used above, so\n+\t      // _Target_handler avoids ill-formed _Function_handler types.\n+\t      using _Handler = _Target_handler<_Res(_ArgTypes...), _Functor>;\n+\n+\t      if (_M_manager == &_Handler::_M_manager\n+#if __cpp_rtti\n+\t\t  || (_M_manager && typeid(_Functor) == target_type())\n+#endif\n+\t\t )\n+\t\t{\n+\t\t  _Any_data __ptr;\n+\t\t  _M_manager(__ptr, _M_functor, __get_functor_ptr);\n+\t\t  return __ptr._M_access<const _Functor*>();\n+\t\t}\n \t    }\n-\t  else\n-\t    return nullptr;\n+\t  return nullptr;\n \t}\n       // @}\n-#endif\n \n     private:\n       using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...);"}, {"sha": "2215e1d9959439e36197d5457ca63b65b97b8cef", "filename": "libstdc++-v3/testsuite/20_util/function/target_no_rtti.cc", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9b99ef7115fa88ef4d744cc2afc424bd5c3ef2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Ftarget_no_rtti.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9b99ef7115fa88ef4d744cc2afc424bd5c3ef2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Ftarget_no_rtti.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Ftarget_no_rtti.cc?ref=3c9b99ef7115fa88ef4d744cc2afc424bd5c3ef2", "patch": "@@ -0,0 +1,56 @@\n+// { dg-options \"-fno-rtti\" }\n+// { dg-do run { target c++11 } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+using std::function;\n+\n+long f() { return 1; }\n+struct F { long operator()() {  return 2; } };\n+\n+void test01()\n+{\n+  std::function<int()> fun = f;\n+  long (**tgt1)() = fun.target<long(*)()>();\n+  VERIFY( *tgt1 == f );\n+  VERIFY( (*tgt1)() == 1L );\n+  VERIFY( fun.target<long(*)()>() == tgt1 );\n+  VERIFY( fun.target<long(* const)()>() == tgt1 );\n+  VERIFY( fun.target<F>() == nullptr );\n+  VERIFY( fun.target<void>() == nullptr );\n+  VERIFY( fun.target<int()>() == nullptr );\n+  VERIFY( fun.target<long()>() == nullptr );\n+\n+  const F ff;\n+  fun = ff;\n+  F* tgt2 = fun.target<F>();\n+  VERIFY( tgt2 != nullptr );\n+  VERIFY( (*tgt2)() == 2L );\n+  VERIFY( fun.target<const F>() == tgt2 );\n+  VERIFY( fun.target<int(*)()>() == nullptr );\n+  VERIFY( fun.target<void()>() == nullptr );\n+  VERIFY( fun.target<void(*)()>() == nullptr );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}]}