{"sha": "f827f65933319275c46eccf2aa1df4f1d21d6783", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgyN2Y2NTkzMzMxOTI3NWM0NmVjY2YyYWExZGY0ZjFkMjFkNjc4Mw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2010-01-21T00:42:02Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-01-21T00:42:02Z"}, "message": "re PR other/42715 (output_operand: invalid expression as operand)\n\n\tPR debug/42715\n\t* var-tracking.c (use_type): Choose MO_VAL_SET for REGs set\n\twithout a cselib val.\n\t(count_uses): Accept MO_VAL_SET with no val on stores.\n\t(add_stores): Likewise.\n\n\t* gcc.dg/pr42715.c: New.\n\nFrom-SVN: r156102", "tree": {"sha": "7d2031f9d92ffe073540bf43e71015587f36dd46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d2031f9d92ffe073540bf43e71015587f36dd46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f827f65933319275c46eccf2aa1df4f1d21d6783", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f827f65933319275c46eccf2aa1df4f1d21d6783", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f827f65933319275c46eccf2aa1df4f1d21d6783", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f827f65933319275c46eccf2aa1df4f1d21d6783/comments", "author": null, "committer": null, "parents": [{"sha": "a85caf9e0bafa1be233b7b6d864ee96ae2dce042", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a85caf9e0bafa1be233b7b6d864ee96ae2dce042", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a85caf9e0bafa1be233b7b6d864ee96ae2dce042"}], "stats": {"total": 94, "additions": 87, "deletions": 7}, "files": [{"sha": "4ec8ee68706d9712e39761b593220c738b23fe07", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f827f65933319275c46eccf2aa1df4f1d21d6783/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f827f65933319275c46eccf2aa1df4f1d21d6783/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f827f65933319275c46eccf2aa1df4f1d21d6783", "patch": "@@ -1,3 +1,11 @@\n+2010-01-20  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/42715\n+\t* var-tracking.c (use_type): Choose MO_VAL_SET for REGs set\n+\twithout a cselib val.\n+\t(count_uses): Accept MO_VAL_SET with no val on stores.\n+\t(add_stores): Likewise.\n+\n 2010-01-20  Jakub Jelinek  <jakub@redhat.com>\n \n \t* var-tracking.c (check_value_val): Add a compile time assertion."}, {"sha": "0fac516223efaa4273b1d73e345c865957db2c76", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f827f65933319275c46eccf2aa1df4f1d21d6783/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f827f65933319275c46eccf2aa1df4f1d21d6783/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f827f65933319275c46eccf2aa1df4f1d21d6783", "patch": "@@ -1,3 +1,8 @@\n+2010-01-20  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/42715\n+\t* gcc.dg/pr42715.c: New.\n+\n 2010-01-20  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/42038"}, {"sha": "72bdfc86244f78d41b8168854253e2b92d1ec8b1", "filename": "gcc/testsuite/gcc.dg/pr42715.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f827f65933319275c46eccf2aa1df4f1d21d6783/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42715.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f827f65933319275c46eccf2aa1df4f1d21d6783/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42715.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42715.c?ref=f827f65933319275c46eccf2aa1df4f1d21d6783", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do compile { target fpic } } */\n+/* { dg-options \"-fPIC -g -O2 -w\" } */\n+/* var-tracking failed to clobber the reg holding v at the asm insn,\n+   so v ended up bound to an intermediate PIC expression.  */\n+\n+struct A { unsigned a1; char a2[15]; };\n+struct B { long b1; unsigned char b2; long b3; };\n+struct C { void *c1; unsigned c2; unsigned c3; };\n+\n+static struct A v1;\n+struct A *const v2 = &v1;\n+\n+static inline\n+int foo (void)\n+{\n+  int *v;\n+  __asm__ __volatile__ (\"\" : \"=r\" (v));\n+  return v[1];\n+}\n+\n+static void\n+bar (struct C *x)\n+{\n+  if (x->c2 == x->c3 && x->c1)\n+    f1 (foo (), x->c1, x->c3 * sizeof (x->c1[0]));\n+}\n+\n+void\n+baz (struct B *y)\n+{\n+  int i;\n+  const char *j;\n+  char *k;\n+  char x[64];\n+  for (i = 0; i < sizeof (struct B); i++, y)\n+    {\n+      switch (y->b2)\n+        {\n+        case 0x20:\n+          if (__builtin_strchr (j, '='))\n+            continue;\n+        }\n+      switch (y->b2)\n+        {\n+        case 0x80:\n+          bar (&x);\n+          f2 (y->b3);\n+        case 0x2e:\n+        case 0x4e:\n+          break;\n+        default:\n+          if (v2->a1)\n+            f2 (y->b2);\n+        }\n+      k[0] = '\\0';\n+      if (v2->a1)\n+        f2 (y->b1);\n+    }\n+}"}, {"sha": "79e8d560895dd6f3b202db4674a58056fd2b3a1b", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f827f65933319275c46eccf2aa1df4f1d21d6783/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f827f65933319275c46eccf2aa1df4f1d21d6783/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=f827f65933319275c46eccf2aa1df4f1d21d6783", "patch": "@@ -4426,7 +4426,6 @@ static enum micro_operation_type\n use_type (rtx loc, struct count_use_info *cui, enum machine_mode *modep)\n {\n   tree expr;\n-  cselib_val *val;\n \n   if (cui && cui->sets)\n     {\n@@ -4447,19 +4446,24 @@ use_type (rtx loc, struct count_use_info *cui, enum machine_mode *modep)\n \t    return MO_CLOBBER;\n \t}\n \n-      if ((REG_P (loc) || MEM_P (loc))\n-\t  && (val = find_use_val (loc, GET_MODE (loc), cui)))\n+      if (REG_P (loc) || MEM_P (loc))\n \t{\n \t  if (modep)\n \t    *modep = GET_MODE (loc);\n \t  if (cui->store_p)\n \t    {\n \t      if (REG_P (loc)\n-\t\t  || cselib_lookup (XEXP (loc, 0), GET_MODE (loc), 0))\n+\t\t  || (find_use_val (loc, GET_MODE (loc), cui)\n+\t\t      && cselib_lookup (XEXP (loc, 0), GET_MODE (loc), 0)))\n \t\treturn MO_VAL_SET;\n \t    }\n-\t  else if (!cselib_preserved_value_p (val))\n-\t    return MO_VAL_USE;\n+\t  else\n+\t    {\n+\t      cselib_val *val = find_use_val (loc, GET_MODE (loc), cui);\n+\n+\t      if (val && !cselib_preserved_value_p (val))\n+\t\treturn MO_VAL_USE;\n+\t    }\n \t}\n     }\n \n@@ -4580,7 +4584,8 @@ count_uses (rtx *ploc, void *cuip)\n \t      cselib_preserve_value (val);\n \t    }\n \t  else\n-\t    gcc_assert (mopt == MO_VAL_LOC);\n+\t    gcc_assert (mopt == MO_VAL_LOC\n+\t\t\t|| (mopt == MO_VAL_SET && cui->store_p));\n \n \t  break;\n \n@@ -4968,6 +4973,9 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \n   v = find_use_val (oloc, mode, cui);\n \n+  if (!v)\n+    goto log_and_return;\n+\n   resolve = preserve = !cselib_preserved_value_p (v);\n \n   nloc = replace_expr_with_values (oloc);"}]}