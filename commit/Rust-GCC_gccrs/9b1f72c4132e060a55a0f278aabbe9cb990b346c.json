{"sha": "9b1f72c4132e060a55a0f278aabbe9cb990b346c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIxZjcyYzQxMzJlMDYwYTU1YTBmMjc4YWFiYmU5Y2I5OTBiMzQ2Yw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-10-10T22:06:04Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-10-10T22:06:04Z"}, "message": "basic-block.h: Remove the prototypes for can_hoist_insn_p...\n\n\t* basic-block.h: Remove the prototypes for can_hoist_insn_p,\n\thoist_insn_after, and hoist_insn_to_edge.\n\t* rtl.h: Remove the prototypes for reg_referenced_between_p,\n\tno_jumps_between_p, and insn_dependent_p.\n\t* rtlanal.c (no_jumps_between_p, reg_referenced_between_p,\n\tinsn_dependent_p, insn_dependent_p_1, hoist_test_store,\n\tcan_hoist_insn_p, hoist_update_store, hoist_insn_after,\n\thoist_insn_to_edge): Remove.\n\nFrom-SVN: r88860", "tree": {"sha": "f20421efd5314590a7635caeb5784d04b14d1d30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f20421efd5314590a7635caeb5784d04b14d1d30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b1f72c4132e060a55a0f278aabbe9cb990b346c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b1f72c4132e060a55a0f278aabbe9cb990b346c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b1f72c4132e060a55a0f278aabbe9cb990b346c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b1f72c4132e060a55a0f278aabbe9cb990b346c/comments", "author": null, "committer": null, "parents": [{"sha": "382c6e2df802710f74ae2e929587f7ef381646e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/382c6e2df802710f74ae2e929587f7ef381646e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/382c6e2df802710f74ae2e929587f7ef381646e7"}], "stats": {"total": 343, "additions": 11, "deletions": 332}, "files": [{"sha": "a0c99cb4a62286fe2d3de90ebbd6dd7f9c6dee64", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1f72c4132e060a55a0f278aabbe9cb990b346c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1f72c4132e060a55a0f278aabbe9cb990b346c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b1f72c4132e060a55a0f278aabbe9cb990b346c", "patch": "@@ -1,3 +1,14 @@\n+2004-10-10  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* basic-block.h: Remove the prototypes for can_hoist_insn_p,\n+\thoist_insn_after, and hoist_insn_to_edge.\n+\t* rtl.h: Remove the prototypes for reg_referenced_between_p,\n+\tno_jumps_between_p, and insn_dependent_p.\n+\t* rtlanal.c (no_jumps_between_p, reg_referenced_between_p,\n+\tinsn_dependent_p, insn_dependent_p_1, hoist_test_store,\n+\tcan_hoist_insn_p, hoist_update_store, hoist_insn_after,\n+\thoist_insn_to_edge): Remove.\n+\n 2004-10-10  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \tPR c/17881"}, {"sha": "e2d20ac3984e85a171cc6e7332839830c8af5810", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1f72c4132e060a55a0f278aabbe9cb990b346c/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1f72c4132e060a55a0f278aabbe9cb990b346c/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=9b1f72c4132e060a55a0f278aabbe9cb990b346c", "patch": "@@ -815,9 +815,6 @@ extern bool mark_dfs_back_edges (void);\n extern void set_edge_can_fallthru_flag (void);\n extern void update_br_prob_note (basic_block);\n extern void fixup_abnormal_edges (void);\n-extern bool can_hoist_insn_p (rtx, rtx, regset);\n-extern rtx hoist_insn_after (rtx, rtx, rtx, rtx);\n-extern rtx hoist_insn_to_edge (rtx, edge, rtx, rtx);\n extern bool inside_basic_block_p (rtx);\n extern bool control_flow_insn_p (rtx);\n "}, {"sha": "3ebf4aa7a17b7fdff0d068ae614d54434c80753e", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1f72c4132e060a55a0f278aabbe9cb990b346c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1f72c4132e060a55a0f278aabbe9cb990b346c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=9b1f72c4132e060a55a0f278aabbe9cb990b346c", "patch": "@@ -1607,16 +1607,13 @@ extern int reg_mentioned_p (rtx, rtx);\n extern int count_occurrences (rtx, rtx, int);\n extern int reg_referenced_p (rtx, rtx);\n extern int reg_used_between_p (rtx, rtx, rtx);\n-extern int reg_referenced_between_p (rtx, rtx, rtx);\n extern int reg_set_between_p (rtx, rtx, rtx);\n extern int regs_set_between_p (rtx, rtx, rtx);\n extern int commutative_operand_precedence (rtx);\n extern int swap_commutative_operands_p (rtx, rtx);\n extern int modified_between_p (rtx, rtx, rtx);\n extern int no_labels_between_p (rtx, rtx);\n-extern int no_jumps_between_p (rtx, rtx);\n extern int modified_in_p (rtx, rtx);\n-extern int insn_dependent_p (rtx, rtx);\n extern int reg_set_p (rtx, rtx);\n extern rtx single_set_2 (rtx, rtx);\n extern int multiple_sets (rtx);"}, {"sha": "d61df8902bf5da0d177eb5bb39806047a181b830", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 0, "deletions": 326, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1f72c4132e060a55a0f278aabbe9cb990b346c/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1f72c4132e060a55a0f278aabbe9cb990b346c/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=9b1f72c4132e060a55a0f278aabbe9cb990b346c", "patch": "@@ -41,12 +41,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Forward declarations */\n static int global_reg_mentioned_p_1 (rtx *, void *);\n static void set_of_1 (rtx, rtx, void *);\n-static void insn_dependent_p_1 (rtx, rtx, void *);\n static int rtx_referenced_p_1 (rtx *, void *);\n static int computed_jump_p_1 (rtx);\n static void parms_set (rtx, rtx, void *);\n-static bool hoist_test_store (rtx, rtx, regset);\n-static void hoist_update_store (rtx, rtx *, rtx, rtx);\n \n static unsigned HOST_WIDE_INT cached_nonzero_bits (rtx, enum machine_mode,\n                                                    rtx, enum machine_mode,\n@@ -650,19 +647,6 @@ no_labels_between_p (rtx beg, rtx end)\n   return 1;\n }\n \n-/* Return 1 if in between BEG and END, exclusive of BEG and END, there is\n-   no JUMP_INSN insn.  */\n-\n-int\n-no_jumps_between_p (rtx beg, rtx end)\n-{\n-  rtx p;\n-  for (p = NEXT_INSN (beg); p != end; p = NEXT_INSN (p))\n-    if (JUMP_P (p))\n-      return 0;\n-  return 1;\n-}\n-\n /* Nonzero if register REG is used in an insn between\n    FROM_INSN and TO_INSN (exclusive of those two).  */\n \n@@ -760,27 +744,6 @@ reg_referenced_p (rtx x, rtx body)\n       return 0;\n     }\n }\n-\n-/* Nonzero if register REG is referenced in an insn between\n-   FROM_INSN and TO_INSN (exclusive of those two).  Sets of REG do\n-   not count.  */\n-\n-int\n-reg_referenced_between_p (rtx reg, rtx from_insn, rtx to_insn)\n-{\n-  rtx insn;\n-\n-  if (from_insn == to_insn)\n-    return 0;\n-\n-  for (insn = NEXT_INSN (from_insn); insn != to_insn; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn)\n-\t&& (reg_referenced_p (reg, PATTERN (insn))\n-\t   || (CALL_P (insn)\n-\t      && find_reg_fusage (insn, USE, reg))))\n-      return 1;\n-  return 0;\n-}\n \f\n /* Nonzero if register REG is set or clobbered in an insn between\n    FROM_INSN and TO_INSN (exclusive of those two).  */\n@@ -982,41 +945,6 @@ modified_in_p (rtx x, rtx insn)\n \n   return 0;\n }\n-\n-/* Return true if anything in insn X is (anti,output,true) dependent on\n-   anything in insn Y.  */\n-\n-int\n-insn_dependent_p (rtx x, rtx y)\n-{\n-  rtx tmp;\n-\n-  gcc_assert (INSN_P (x));\n-  gcc_assert (INSN_P (y));\n-\n-  tmp = PATTERN (y);\n-  note_stores (PATTERN (x), insn_dependent_p_1, &tmp);\n-  if (tmp == NULL_RTX)\n-    return 1;\n-\n-  tmp = PATTERN (x);\n-  note_stores (PATTERN (y), insn_dependent_p_1, &tmp);\n-  if (tmp == NULL_RTX)\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* A helper routine for insn_dependent_p called through note_stores.  */\n-\n-static void\n-insn_dependent_p_1 (rtx x, rtx pat ATTRIBUTE_UNUSED, void *data)\n-{\n-  rtx * pinsn = (rtx *) data;\n-\n-  if (*pinsn && reg_mentioned_p (x, *pinsn))\n-    *pinsn = NULL_RTX;\n-}\n \f\n /* Helper function for set_of.  */\n struct set_of_data\n@@ -3303,260 +3231,6 @@ keep_with_call_p (rtx insn)\n   return false;\n }\n \n-/* Return true when store to register X can be hoisted to the place\n-   with LIVE registers (can be NULL).  Value VAL contains destination\n-   whose value will be used.  */\n-\n-static bool\n-hoist_test_store (rtx x, rtx val, regset live)\n-{\n-  if (GET_CODE (x) == SCRATCH)\n-    return true;\n-\n-  if (rtx_equal_p (x, val))\n-    return true;\n-\n-  /* Allow subreg of X in case it is not writing just part of multireg pseudo.\n-     Then we would need to update all users to care hoisting the store too.\n-     Caller may represent that by specifying whole subreg as val.  */\n-\n-  if (GET_CODE (x) == SUBREG && rtx_equal_p (SUBREG_REG (x), val))\n-    {\n-      if (GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))) > UNITS_PER_WORD\n-\t  && GET_MODE_BITSIZE (GET_MODE (x)) <\n-\t  GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x))))\n-\treturn false;\n-      return true;\n-    }\n-  if (GET_CODE (x) == SUBREG)\n-    x = SUBREG_REG (x);\n-\n-  /* Anything except register store is not hoistable.  This includes the\n-     partial stores to registers.  */\n-\n-  if (!REG_P (x))\n-    return false;\n-\n-  /* Pseudo registers can be always replaced by another pseudo to avoid\n-     the side effect, for hard register we must ensure that they are dead.\n-     Eventually we may want to add code to try turn pseudos to hards, but it\n-     is unlikely useful.  */\n-\n-  if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n-    {\n-      int regno = REGNO (x);\n-      int n = hard_regno_nregs[regno][GET_MODE (x)];\n-\n-      if (!live)\n-\treturn false;\n-      if (REGNO_REG_SET_P (live, regno))\n-\treturn false;\n-      while (--n > 0)\n-\tif (REGNO_REG_SET_P (live, regno + n))\n-\t  return false;\n-    }\n-  return true;\n-}\n-\n-\n-/* Return true if INSN can be hoisted to place with LIVE hard registers\n-   (LIVE can be NULL when unknown).  VAL is expected to be stored by the insn\n-   and used by the hoisting pass.  */\n-\n-bool\n-can_hoist_insn_p (rtx insn, rtx val, regset live)\n-{\n-  rtx pat = PATTERN (insn);\n-  int i;\n-\n-  /* It probably does not worth the complexity to handle multiple\n-     set stores.  */\n-  if (!single_set (insn))\n-    return false;\n-  /* We can move CALL_INSN, but we need to check that all caller clobbered\n-     regs are dead.  */\n-  if (CALL_P (insn))\n-    return false;\n-  /* In future we will handle hoisting of libcall sequences, but\n-     give up for now.  */\n-  if (find_reg_note (insn, REG_RETVAL, NULL_RTX))\n-    return false;\n-  switch (GET_CODE (pat))\n-    {\n-    case SET:\n-      if (!hoist_test_store (SET_DEST (pat), val, live))\n-\treturn false;\n-      break;\n-    case USE:\n-      /* USES do have sick semantics, so do not move them.  */\n-      return false;\n-      break;\n-    case CLOBBER:\n-      if (!hoist_test_store (XEXP (pat, 0), val, live))\n-\treturn false;\n-      break;\n-    case PARALLEL:\n-      for (i = 0; i < XVECLEN (pat, 0); i++)\n-\t{\n-\t  rtx x = XVECEXP (pat, 0, i);\n-\t  switch (GET_CODE (x))\n-\t    {\n-\t    case SET:\n-\t      if (!hoist_test_store (SET_DEST (x), val, live))\n-\t\treturn false;\n-\t      break;\n-\t    case USE:\n-\t      /* We need to fix callers to really ensure availability\n-\t         of all values insn uses, but for now it is safe to prohibit\n-\t\t hoisting of any insn having such a hidden uses.  */\n-\t      return false;\n-\t      break;\n-\t    case CLOBBER:\n-\t      if (!hoist_test_store (SET_DEST (x), val, live))\n-\t\treturn false;\n-\t      break;\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-  return true;\n-}\n-\n-/* Update store after hoisting - replace all stores to pseudo registers\n-   by new ones to avoid clobbering of values except for store to VAL that will\n-   be updated to NEW.  */\n-\n-static void\n-hoist_update_store (rtx insn, rtx *xp, rtx val, rtx new)\n-{\n-  rtx x = *xp;\n-\n-  if (GET_CODE (x) == SCRATCH)\n-    return;\n-\n-  if (GET_CODE (x) == SUBREG && SUBREG_REG (x) == val)\n-    validate_change (insn, xp,\n-\t\t     simplify_gen_subreg (GET_MODE (x), new, GET_MODE (new),\n-\t\t\t\t\t  SUBREG_BYTE (x)), 1);\n-  if (rtx_equal_p (x, val))\n-    {\n-      validate_change (insn, xp, new, 1);\n-      return;\n-    }\n-  if (GET_CODE (x) == SUBREG)\n-    {\n-      xp = &SUBREG_REG (x);\n-      x = *xp;\n-    }\n-\n-  gcc_assert (REG_P (x));\n-\n-  /* We've verified that hard registers are dead, so we may keep the side\n-     effect.  Otherwise replace it by new pseudo.  */\n-  if (REGNO (x) >= FIRST_PSEUDO_REGISTER)\n-    validate_change (insn, xp, gen_reg_rtx (GET_MODE (x)), 1);\n-  REG_NOTES (insn)\n-    = alloc_EXPR_LIST (REG_UNUSED, *xp, REG_NOTES (insn));\n-}\n-\n-/* Create a copy of INSN after AFTER replacing store of VAL to NEW\n-   and each other side effect to pseudo register by new pseudo register.  */\n-\n-rtx\n-hoist_insn_after (rtx insn, rtx after, rtx val, rtx new)\n-{\n-  rtx pat;\n-  int i;\n-  rtx note;\n-  int applied;\n-\n-  insn = emit_copy_of_insn_after (insn, after);\n-  pat = PATTERN (insn);\n-\n-  /* Remove REG_UNUSED notes as we will re-emit them.  */\n-  while ((note = find_reg_note (insn, REG_UNUSED, NULL_RTX)))\n-    remove_note (insn, note);\n-\n-  /* To get this working callers must ensure to move everything referenced\n-     by REG_EQUAL/REG_EQUIV notes too.  Lets remove them, it is probably\n-     easier.  */\n-  while ((note = find_reg_note (insn, REG_EQUAL, NULL_RTX)))\n-    remove_note (insn, note);\n-  while ((note = find_reg_note (insn, REG_EQUIV, NULL_RTX)))\n-    remove_note (insn, note);\n-\n-  /* Remove REG_DEAD notes as they might not be valid anymore in case\n-     we create redundancy.  */\n-  while ((note = find_reg_note (insn, REG_DEAD, NULL_RTX)))\n-    remove_note (insn, note);\n-  switch (GET_CODE (pat))\n-    {\n-    case SET:\n-      hoist_update_store (insn, &SET_DEST (pat), val, new);\n-      break;\n-    case USE:\n-      break;\n-    case CLOBBER:\n-      hoist_update_store (insn, &XEXP (pat, 0), val, new);\n-      break;\n-    case PARALLEL:\n-      for (i = 0; i < XVECLEN (pat, 0); i++)\n-\t{\n-\t  rtx x = XVECEXP (pat, 0, i);\n-\t  switch (GET_CODE (x))\n-\t    {\n-\t    case SET:\n-\t      hoist_update_store (insn, &SET_DEST (x), val, new);\n-\t      break;\n-\t    case USE:\n-\t      break;\n-\t    case CLOBBER:\n-\t      hoist_update_store (insn, &SET_DEST (x), val, new);\n-\t      break;\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-  applied = apply_change_group ();\n-  gcc_assert (applied);\n-\n-  return insn;\n-}\n-\n-rtx\n-hoist_insn_to_edge (rtx insn, edge e, rtx val, rtx new)\n-{\n-  rtx new_insn;\n-\n-  /* We cannot insert instructions on an abnormal critical edge.\n-     It will be easier to find the culprit if we die now.  */\n-  gcc_assert (!(e->flags & EDGE_ABNORMAL) || !EDGE_CRITICAL_P (e));\n-\n-  /* Do not use emit_insn_on_edge as we want to preserve notes and similar\n-     stuff.  We also emit CALL_INSNS and firends.  */\n-  if (e->insns.r == NULL_RTX)\n-    {\n-      start_sequence ();\n-      emit_note (NOTE_INSN_DELETED);\n-    }\n-  else\n-    push_to_sequence (e->insns.r);\n-\n-  new_insn = hoist_insn_after (insn, get_last_insn (), val, new);\n-\n-  e->insns.r = get_insns ();\n-  end_sequence ();\n-  return new_insn;\n-}\n-\n /* Return true if LABEL is a target of JUMP_INSN.  This applies only\n    to non-complex jumps.  That is, direct unconditional, conditional,\n    and tablejumps, but not computed jumps or returns.  It also does"}]}