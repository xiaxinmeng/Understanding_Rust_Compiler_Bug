{"sha": "111e0469cef8474f5ace78075960fcb785b1806f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTExZTA0NjljZWY4NDc0ZjVhY2U3ODA3NTk2MGZjYjc4NWIxODA2Zg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-01-19T22:25:53Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-01-19T22:25:53Z"}, "message": "* cppinternals.texi: Update.\n\nFrom-SVN: r39144", "tree": {"sha": "4a4252833ae0646aca1823c29c9178ea27691246", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a4252833ae0646aca1823c29c9178ea27691246"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/111e0469cef8474f5ace78075960fcb785b1806f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/111e0469cef8474f5ace78075960fcb785b1806f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/111e0469cef8474f5ace78075960fcb785b1806f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/111e0469cef8474f5ace78075960fcb785b1806f/comments", "author": null, "committer": null, "parents": [{"sha": "55cf7bb97206e4c1f0bcf37bb9adc8bc5c9c58ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55cf7bb97206e4c1f0bcf37bb9adc8bc5c9c58ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55cf7bb97206e4c1f0bcf37bb9adc8bc5c9c58ac"}], "stats": {"total": 103, "additions": 92, "deletions": 11}, "files": [{"sha": "24f4796ef8a03f88c381194ae6496c4cc40e2c91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/111e0469cef8474f5ace78075960fcb785b1806f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/111e0469cef8474f5ace78075960fcb785b1806f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=111e0469cef8474f5ace78075960fcb785b1806f", "patch": "@@ -1,3 +1,7 @@\n+2001-01-19  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+        * cppinternals.texi: Update.\n+\n 2001-01-19  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.c (arm_init_builtins): Re-enable builtins."}, {"sha": "7cd7d49454760ccea3b2a444b9c6e9ba3d85a564", "filename": "gcc/cppinternals.texi", "status": "modified", "additions": 88, "deletions": 11, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/111e0469cef8474f5ace78075960fcb785b1806f/gcc%2Fcppinternals.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/111e0469cef8474f5ace78075960fcb785b1806f/gcc%2Fcppinternals.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinternals.texi?ref=111e0469cef8474f5ace78075960fcb785b1806f", "patch": "@@ -91,11 +91,15 @@ Identifiers, macro expansion, hash nodes, lexing.\n * Conventions::\t    Conventions used in the code.\n * Lexer::\t    The combined C, C++ and Objective C Lexer.\n * Whitespace::      Input and output newlines and whitespace.\n+* Hash Nodes::      All identifiers are hashed.\n+* Macro Expansion:: Macro expansion algorithm.\n+* Files::\t    File handling.\n * Concept Index::   Index of concepts and terms.\n * Index::           Index.\n @end menu\n \n @node Conventions, Lexer, Top, Top\n+@unnumbered Conventions\n \n cpplib has two interfaces - one is exposed internally only, and the\n other is for both internal and external use.\n@@ -113,6 +117,7 @@ are perhaps relying on some kind of undocumented implementation-specific\n behaviour.\n \n @node Lexer, Whitespace, Conventions, Top\n+@unnumbered The Lexer\n \n The lexer is contained in the file @samp{cpplex.c}.  We want to have a\n lexer that is single-pass, for efficiency reasons.  We would also like\n@@ -194,26 +199,98 @@ a trigraph, but the command line option @samp{-trigraphs} is not in\n force but @samp{-Wtrigraphs} is, we need to warn about it but then\n buffer it and continue to treat it as 3 separate characters.\n \n-@node Whitespace, Concept Index, Lexer, Top\n+@node Whitespace, Hash Nodes, Lexer, Top\n+@unnumbered Whitespace\n \n The lexer has been written to treat each of @samp{\\r}, @samp{\\n},\n @samp{\\r\\n} and @samp{\\n\\r} as a single new line indicator.  This allows\n it to transparently preprocess MS-DOS, Macintosh and Unix files without\n their needing to pass through a special filter beforehand.\n \n We also decided to treat a backslash, either @samp{\\} or the trigraph\n-@samp{??/}, separated from one of the above newline forms by whitespace\n-only (one or more space, tab, form-feed, vertical tab or NUL characters),\n-as an intended escaped newline.  The library issues a diagnostic in this\n-case.\n-\n-Handling newlines in this way is made simpler by doing it in one place\n+@samp{??/}, separated from one of the above newline indicators by\n+non-comment whitespace only, as intending to escape the newline.  It\n+tends to be a typing mistake, and cannot reasonably be mistaken for\n+anything else in any of the C-family grammars.  Since handling it this\n+way is not strictly conforming to the ISO standard, the library issues a\n+warning wherever it encounters it.\n+\n+Handling newlines like this is made simpler by doing it in one place\n only.  The function @samp{handle_newline} takes care of all newline\n-characters, and @samp{skip_escaped_newlines} takes care of all escaping\n-of newlines, deferring to @samp{handle_newline} to handle the newlines\n-themselves.\n+characters, and @samp{skip_escaped_newlines} takes care of arbitrarily\n+long sequences of escaped newlines, deferring to @samp{handle_newline}\n+to handle the newlines themselves.\n+\n+@node Hash Nodes, Macro Expansion, Whitespace, Top\n+@unnumbered Hash Nodes\n+\n+When cpplib encounters an \"identifier\", it generates a hash code for it\n+and stores it in the hash table.  By \"identifier\" we mean tokens with\n+type @samp{CPP_NAME}; this includes identifiers in the usual C sense, as\n+well as keywords, directive names, macro names and so on.  For example,\n+all of \"pragma\", \"int\", \"foo\" and \"__GNUC__\" are identifiers and hashed\n+when lexed.\n+\n+Each node in the hash table contain various information about the\n+identifier it represents.  For example, its length and type.  At any one\n+time, each identifier falls into exactly one of three categories:\n+\n+@itemize @bullet\n+@item Macros\n+\n+These have been declared to be macros, either on the command line or\n+with @samp{#define}.  A few, such as @samp{__TIME__} are builtins\n+entered in the hash table during initialisation.  The hash node for a\n+normal macro points to a structure with more information about the\n+macro, such as whether it is function-like, how many arguments it takes,\n+and its expansion.  Builtin macros are flagged as special, and instead\n+contain an enum indicating which of the various builtin macros it is.\n+\n+@item Assertions\n+\n+Assertions are in a separate namespace to macros.  To enforce this, cpp\n+actually prepends a @samp{#} character before hashing and entering it in\n+the hash table.  An assertion's node points to a chain of answers to\n+that assertion.\n+\n+@item Void\n+\n+Everything else falls into this category - an identifier that is not\n+currently a macro, or a macro that has since been undefined with\n+@samp{#undef}.\n+\n+When preprocessing C++, this category also includes the named operators,\n+such as @samp{xor}.  In expressions these behave like the operators they\n+represent, but in contexts where the spelling of a token matters they\n+are spelt differently.  This spelling distinction is relevant when they\n+are operands of the stringizing and pasting macro operators @samp{#} and\n+@samp{##}.  Named operator hash nodes are flagged, both to catch the\n+spelling distinction and to prevent them from being defined as macros.\n+@end itemize\n+\n+The same identifiers share the same hash node.  Since each identifier\n+token, after lexing, contains a pointer to its hash node, this is used\n+to provide rapid lookup of various information.  For example, when\n+parsing a @samp{#define} statement, CPP flags each argument's identifier\n+hash node with the index of that argument.  This makes duplicated\n+argument checking an O(1) operation for each argument.  Similarly, for\n+each identifier in the macro's expansion, lookup to see if it is an\n+argument, and which argument it is, is also an O(1) operation.  Further,\n+each directive name, such as @samp{endif}, has an associated directive\n+enum stored in its hash node, so that directive lookup is also O(1).\n+\n+Later, CPP may also store C front-end information in its identifier hash\n+table, such as a @samp{tree} pointer.\n+\n+@node Macro Expansion, Files, Hash Nodes, Top\n+@unnumbered Macro Expansion Algorithm\n+@printindex cp\n+\n+@node Files, Concept Index, Macro Expansion, Top\n+@unnumbered File Handling\n+@printindex cp\n \n-@node Concept Index, Index, Whitespace, Top\n+@node Concept Index, Index, Files, Top\n @unnumbered Concept Index\n @printindex cp\n "}]}