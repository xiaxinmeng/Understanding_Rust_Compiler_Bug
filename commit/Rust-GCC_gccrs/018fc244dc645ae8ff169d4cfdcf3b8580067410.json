{"sha": "018fc244dc645ae8ff169d4cfdcf3b8580067410", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE4ZmMyNDRkYzY0NWFlOGZmMTY5ZDRjZmRjZjNiODU4MDA2NzQxMA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-10-05T16:19:04Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-10-05T16:19:04Z"}, "message": "method.c (synthesize_method): Call setup_vtbl_ptr for destructors.\n\n\t* method.c (synthesize_method): Call setup_vtbl_ptr for destructors.\n\n\t* decl.c (start_function): Set current_in_charge_parm for\n\tconstructors, too, where appropriate.\n\t* search.c (fixup_all_virtual_upcast_offsets): New function.\n\t(expand_indirect_vtbls_init): Use it.\n\nFrom-SVN: r29826", "tree": {"sha": "d62347643638571648f579cf5e50d9f5442e5f39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d62347643638571648f579cf5e50d9f5442e5f39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/018fc244dc645ae8ff169d4cfdcf3b8580067410", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/018fc244dc645ae8ff169d4cfdcf3b8580067410", "html_url": "https://github.com/Rust-GCC/gccrs/commit/018fc244dc645ae8ff169d4cfdcf3b8580067410", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/018fc244dc645ae8ff169d4cfdcf3b8580067410/comments", "author": null, "committer": null, "parents": [{"sha": "1b42a6a905d4647e1328d8cf6c18c2ef9d2c72f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b42a6a905d4647e1328d8cf6c18c2ef9d2c72f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b42a6a905d4647e1328d8cf6c18c2ef9d2c72f1"}], "stats": {"total": 161, "additions": 112, "deletions": 49}, "files": [{"sha": "6caaf0aabbb18e14daaecf24d97631e6ea3e67f0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/018fc244dc645ae8ff169d4cfdcf3b8580067410/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/018fc244dc645ae8ff169d4cfdcf3b8580067410/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=018fc244dc645ae8ff169d4cfdcf3b8580067410", "patch": "@@ -1,3 +1,12 @@\n+1999-10-05  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* method.c (synthesize_method): Call setup_vtbl_ptr for destructors.\n+\n+\t* decl.c (start_function): Set current_in_charge_parm for\n+\tconstructors, too, where appropriate.\n+\t* search.c (fixup_all_virtual_upcast_offsets): New function.\n+\t(expand_indirect_vtbls_init): Use it.\n+\t\n 1999-10-04  Nathan Sidwell  <nathan@acm.org>\n \n \t* decl2.c (grok_alignof): Don't decay lvalues."}, {"sha": "877f2c439ecd7a6e26e702a5ae8bd57788f331fc", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/018fc244dc645ae8ff169d4cfdcf3b8580067410/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/018fc244dc645ae8ff169d4cfdcf3b8580067410/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=018fc244dc645ae8ff169d4cfdcf3b8580067410", "patch": "@@ -12971,8 +12971,16 @@ start_function (declspecs, declarator, attrs, flags)\n \t= build_indirect_ref (t, NULL_PTR);\n       cp_function_chain->x_current_class_ptr = t;\n \n+      /* Constructors and destructors need to know whether they're \"in\n+\t charge\" of initializing virtual base classes.  */\n       if (DECL_DESTRUCTOR_P (decl1))\n \tcurrent_in_charge_parm = TREE_CHAIN (t);\n+      else if (DECL_CONSTRUCTOR_P (decl1)\n+\t       && TREE_CHAIN (t)\n+\t       && DECL_ARTIFICIAL (TREE_CHAIN (t))\n+\t       && (DECL_NAME (TREE_CHAIN (t))\n+\t\t   == in_charge_identifier))\n+\tcurrent_in_charge_parm = TREE_CHAIN (t);\n     }\n \n   if (DECL_INTERFACE_KNOWN (decl1))"}, {"sha": "f50f0eb37f5392acbc72c369030c6fa31be1458e", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/018fc244dc645ae8ff169d4cfdcf3b8580067410/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/018fc244dc645ae8ff169d4cfdcf3b8580067410/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=018fc244dc645ae8ff169d4cfdcf3b8580067410", "patch": "@@ -2384,7 +2384,7 @@ synthesize_method (fndecl)\n       need_body = 0;\n     }\n   else if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (fndecl)))\n-    ;\n+    setup_vtbl_ptr ();\n   else\n     {\n       tree arg_chain = FUNCTION_ARG_CHAIN (fndecl);"}, {"sha": "e3418a6866220fb72785c864ac0e52a4137aac07", "filename": "gcc/cp/search.c", "status": "modified", "additions": 58, "deletions": 48, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/018fc244dc645ae8ff169d4cfdcf3b8580067410/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/018fc244dc645ae8ff169d4cfdcf3b8580067410/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=018fc244dc645ae8ff169d4cfdcf3b8580067410", "patch": "@@ -149,6 +149,7 @@ static int protected_accessible_p PROTO ((tree, tree, tree, tree));\n static int friend_accessible_p PROTO ((tree, tree, tree, tree));\n static void setup_class_bindings PROTO ((tree, int));\n static int template_self_reference_p PROTO ((tree, tree));\n+static void fixup_all_virtual_upcast_offsets PROTO ((tree, tree));\n \n /* Allocate a level of searching.  */\n \n@@ -2774,18 +2775,62 @@ fixup_virtual_upcast_offsets (real_binfo, binfo, init_self, can_elide, addr, ori\n     }\n }\n \n-/* Build a COMPOUND_EXPR which when expanded will generate the code\n-   needed to initialize all the virtual function table slots of all\n-   the virtual baseclasses.  MAIN_BINFO is the binfo which determines\n-   the virtual baseclasses to use; TYPE is the type of the object to\n-   which the initialization applies.  TRUE_EXP is the true object we\n-   are initializing, and DECL_PTR is the pointer to the sub-object we\n-   are initializing.\n+/* Fixup all the virtual upcast offsets for TYPE.  DECL_PTR is the\n+   address of the sub-object being initialized.  */\n \n-   When USE_COMPUTED_OFFSETS is non-zero, we can assume that the\n-   object was laid out by a top-level constructor and the computed\n-   offsets are valid to store vtables.  When zero, we must store new\n-   vtables through virtual baseclass pointers.  */\n+static void\n+fixup_all_virtual_upcast_offsets (type, decl_ptr)\n+     tree type;\n+     tree decl_ptr;\n+{\n+  tree if_stmt;\n+  tree in_charge_node;\n+  tree vbases;\n+\n+  /* Only tweak the vtables if we're in charge.  */\n+  in_charge_node = current_in_charge_parm;\n+  if (!in_charge_node)\n+    /* There's no need for any fixups in this case.  */\n+    return;\n+  in_charge_node = build_binary_op (EQ_EXPR, \n+\t\t\t\t    in_charge_node, integer_zero_node);\n+  if_stmt = begin_if_stmt ();\n+  finish_if_stmt_cond (in_charge_node, if_stmt);\n+  \n+  /* Iterate through the virtual bases, fixing up the upcast offset\n+     for each one.  */\n+  for (vbases = CLASSTYPE_VBASECLASSES (type);\n+       vbases;\n+       vbases = TREE_CHAIN (vbases))\n+    {\n+      if (flag_vtable_thunks)\n+\t/* We don't have dynamic thunks yet!  So for now, just fail\n+\t   silently.  */\n+\t;\n+      else\n+\t{\n+\t  tree vbase_offsets;\n+\t  tree addr;\n+\n+\t  vbase_offsets = NULL_TREE;\n+\t  addr = convert_pointer_to_vbase (TREE_TYPE (vbases), decl_ptr);\n+\t  fixup_virtual_upcast_offsets (vbases,\n+\t\t\t\t\tTYPE_BINFO (BINFO_TYPE (vbases)),\n+\t\t\t\t\t1, 0, addr, decl_ptr,\n+\t\t\t\t\ttype, vbases, &vbase_offsets);\n+\t}\n+    }\n+\n+  /* Close out the if-statement.  */\n+  finish_then_clause (if_stmt);\n+  finish_if_stmt ();\n+}\n+\n+/* Generate the code needed to initialize all the virtual function\n+   table slots of all the virtual baseclasses.  BINFO is the binfo\n+   which determines the virtual baseclasses to use.  TRUE_EXP is the\n+   true object we are initializing, and DECL_PTR is the pointer to the\n+   sub-object we are initializing.  */\n \n void\n expand_indirect_vtbls_init (binfo, true_exp, decl_ptr)\n@@ -2807,7 +2852,6 @@ expand_indirect_vtbls_init (binfo, true_exp, decl_ptr)\n \n   if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n     {\n-      rtx fixup_insns = NULL_RTX;\n       tree vbases = CLASSTYPE_VBASECLASSES (type);\n       struct vbase_info vi;\n       vi.decl_ptr = (true_exp ? build_unary_op (ADDR_EXPR, true_exp, 0) \n@@ -2828,44 +2872,10 @@ expand_indirect_vtbls_init (binfo, true_exp, decl_ptr)\n \t     binfos.  (in the CLASSTYPE_VFIELD_PARENT sense)  */\n \t  expand_direct_vtbls_init (vbases, TYPE_BINFO (BINFO_TYPE (vbases)),\n \t\t\t\t    1, 0, addr);\n-\n-\t  /* Now we adjust the offsets for virtual functions that\n-\t     cross virtual boundaries on an implicit upcast on vf call\n-\t     so that the layout of the most complete type is used,\n-\t     instead of assuming the layout of the virtual bases from\n-\t     our current type.  */\n-\n-\t  if (flag_vtable_thunks)\n-\t    {\n-\t      /* We don't have dynamic thunks yet!\n-\t\t So for now, just fail silently.  */\n-\t    }\n-\t  else\n-\t    {\n-\t      tree vbase_offsets = NULL_TREE;\n-\t      push_to_sequence (fixup_insns);\n-\t      fixup_virtual_upcast_offsets (vbases,\n-\t\t\t\t\t    TYPE_BINFO (BINFO_TYPE (vbases)),\n-\t\t\t\t\t    1, 0, addr, vi.decl_ptr,\n-\t\t\t\t\t    type, vbases, &vbase_offsets);\n-\t      fixup_insns = get_insns ();\n-\t      end_sequence ();\n-\t    }\n \t}\n \n-      if (fixup_insns)\n-\t{\n-\t  tree in_charge_node = current_in_charge_parm;\n-\t  if (! in_charge_node)\n-\t    {\n-\t      warning (\"recoverable internal compiler error, nobody's in charge!\");\n-\t      in_charge_node = integer_zero_node;\n-\t    }\n-\t  in_charge_node = build_binary_op (EQ_EXPR, in_charge_node, integer_zero_node);\n-\t  expand_start_cond (in_charge_node, 0);\n-\t  emit_insns (fixup_insns);\n-\t  expand_end_cond ();\n-\t}\n+      fixup_all_virtual_upcast_offsets (type,\n+\t\t\t\t\tvi.decl_ptr);\n \n       dfs_walk (binfo, dfs_clear_vbase_slots, marked_new_vtablep, 0);\n     }"}, {"sha": "ab37e39f9f837e431fba22da50c26e298f78a277", "filename": "gcc/testsuite/g++.old-deja/g++.other/dtor5.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/018fc244dc645ae8ff169d4cfdcf3b8580067410/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdtor5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/018fc244dc645ae8ff169d4cfdcf3b8580067410/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdtor5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdtor5.C?ref=018fc244dc645ae8ff169d4cfdcf3b8580067410", "patch": "@@ -0,0 +1,36 @@\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+extern \"C\" void abort ();\n+\n+struct B;\n+\n+struct S \n+{\n+  S (B*);\n+  ~S ();\n+\n+  B* b_;\n+};\n+\n+struct B \n+{\n+  B () : s (this) { }\n+      \n+  virtual void f () { }\n+  \n+  S s;\n+};\n+\n+S::S (B* b) : b_ (b) { }\n+\n+S::~S () { b_->f (); }\n+  \n+struct D : public B\n+{\n+  virtual void f () { abort (); }\n+};\n+\n+int main ()\n+{\n+  D d;\n+}"}]}