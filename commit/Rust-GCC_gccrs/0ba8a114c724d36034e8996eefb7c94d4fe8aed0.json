{"sha": "0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJhOGExMTRjNzI0ZDM2MDM0ZTg5OTZlZWZiN2M5NGQ0ZmU4YWVkMA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-04-24T08:22:06Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-04-24T08:22:06Z"}, "message": "Lazy __FUNCTION__ generation.\n\ngcc:\n\tLazy __FUNCTION__ generation.\n\t* c-common.h (RID_FUNCTION_NAME, RID_PRETTY_FUNCTION_NAME,\n\tRID_C99_FUNCTION_NAME): New _RIDs.\n\t(CTI_FUNCTION_ID, CTI_PRETTY_FUNCTION_ID, CTI_FUNC_ID): Remove.\n\t(CTI_FUNCTION_NAME_DECL, CTI_PRETTY_FUNCTION_NAME_DECL,\n\tCTI_C99_FUNCTION_NAME_DECL, CTI_SAVED_FUNCTION_NAME_DECLS): New\n\tglobal tree slots.\n\t(function_id_node, pretty_function_id_node, func_id_node): Remove.\n\t(c99_function_name_decl_node, function_name_decl_node,\n\tpretty_function_name_decl_node, saved_function_name_decls):\n\tDeclare.\n\t(struct language_function): Remove x_function_name_declared_p.\n\t(make_fname_decl): Remove a parameter.\n\t(declare_function_names): Remove prototype.\n\t(start_fname_decls, finish_fname_decls): Prototype.\n\t(fname_as_string): Likewise.\n\t(fname_string, fname_decl): Likewise.\n\t* c-common.c (make_fname_decl): Adjust.\n\t(struct fname_var_t): New struct.\n\t(fname_vars): New static array.\n\t(declare_function_name): Remove.\n\t(start_fname_decls, finish_fname_decls): New functions.\n\t(fname_as_string): New function from remnants of\n\tdeclare_function_name.\n\t(fname_string, fname_decl): New functions.\n\n\t* c-decl.c (c_function_name_declared_p): Remove.\n\t(init_decl_processing): Don't generate __FUNCTION__ et al ids,\n\tdon't call declare_function_name. Call start_fname_decls.\n\t(c_make_fname_decl): Adjust parameters. Generate the name. Don't\n\tclobber the line number. Call finish_decl.\n\t(start_function): Call start_fname_decls.\n\t(finish_function): Call finish_fname_decls.\n\tRemove c_function_name_declared_p.\n\t(push_c_function_context): Don't push c_function_name_declared_p.\n\t(pop_c_function_context): Don't pop c_function_name_declared_p.\n\t(c_begin_compound_stmt): Don't check c_function_name_declared_p.\n\t* c-parse.in (STRING_FUNC_NAME, VAR_FUNC_NAME): New tokens.\n\t(program): Call finish_fname_decls for C.\n\t(primary): Add VAR_FUNC_NAME.\n\t(reswords): Add slots for __FUNCTION__ et al.\n\t(rid_to_yy): Add mappings for __FUNCTION__ et al.\n\t(yylexname): If it's a STRING_FUNC_NAME generate the function name\n\tnow. Don't look for VAR_DECLs containing __FUNCTION__ et al.\n\t* c-semantics.c (prune_unused_decls): Remove.\n\t(finish_stmt_tree): Don't call prune_unused_decls.\n\t(genrtl_decl_stmt): Don't prune unused decls here.\ncp:\n\tLazy __FUNCTION__ generation.\n\t* cp-tree.def (FUNCTION_NAME): Remove.\n\t* cp-tree.h (function_name_declared_p): Remove.\n\t(cp_fname_init): Prototype.\n\t* decl.c (init_decl_processing): Don't generate __FUNCTION__ et al ids,\n\tdon't call declare_function_name. Call start_fname_decls.\n\t(cp_make_fname_decl): Adjust parameters. Generate the name. Don't\n\tclobber the line number.\n\t(cp_fname_init): New function.\n\t(start_function): Call start_fname_decls.\n\t(finish_function): Call finish_fname_decls.\n\t* lex.c (reswords): Add slots for __FUNCTION__ et al.\n\t(rid_to_yy): Add mappings for __FUNCTION__ et al.\n\t* optimize.c (maybe_clone_body): Remove function_name_declared_p.\n\t* parse.y (VAR_FUNC_NAME): New token.\n\t(primary): Add VAR_FUNC_NAME.\n\t* pt.c (tsubst_decl): Adjust a DECL_PRETTY_FUNCTION_P's\n\tgeneration.\n\t(tsubst, FUNCTION_NAME case): Remove.\n\t(tsubst_copy, FUNCTION_NAME case): Remove.\n\t(tsubst_expr, DECL_STMT case): Be careful with a\n\tDECL_PRETTY_FUNCTION_P.\n\t(instantiate_decl): Remove function_name_declared_p.\n\t* semantics.c (begin_compound_statement): Don't call\n\tdeclare_function_name here.\n\t(setup_vtbl_ptr). Don't save & restore function_name_declared_p.\n\t(finish_translation_unit): Call finish_fname_decls.\n\t(expand_body): Remove function_name_declared_p.\n\t* typeck2.c (digest_init): Allow any ERROR_MARK.\ntestsuite:\n\t* gcc.dg/c99-func-2.c: Remove xfail.\n\t* gcc.dg/c99-func-3.c: Remove xfail.\n\t* gcc.dg/c99-func-4.c: Remove xfail.\n\nFrom-SVN: r41520", "tree": {"sha": "268353894884ce2459e1f3b08adc4825b8ed0dd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/268353894884ce2459e1f3b08adc4825b8ed0dd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/comments", "author": null, "committer": null, "parents": [{"sha": "dfbb4f347cf43b955f56ecbc9709b8836d395ee5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfbb4f347cf43b955f56ecbc9709b8836d395ee5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfbb4f347cf43b955f56ecbc9709b8836d395ee5"}], "stats": {"total": 703, "additions": 431, "deletions": 272}, "files": [{"sha": "cd986491a4ed0161ea45eaafedd42b4c0c511d1c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "patch": "@@ -1,3 +1,54 @@\n+2001-04-24  Zack Weinberg  <zackw@stanford.edu>\n+\t    Nathan Sidwell <nathan@codesourcery.com>\n+\n+\tLazy __FUNCTION__ generation.\n+\t* c-common.h (RID_FUNCTION_NAME, RID_PRETTY_FUNCTION_NAME,\n+\tRID_C99_FUNCTION_NAME): New _RIDs.\n+\t(CTI_FUNCTION_ID, CTI_PRETTY_FUNCTION_ID, CTI_FUNC_ID): Remove.\n+\t(CTI_FUNCTION_NAME_DECL, CTI_PRETTY_FUNCTION_NAME_DECL,\n+\tCTI_C99_FUNCTION_NAME_DECL, CTI_SAVED_FUNCTION_NAME_DECLS): New\n+\tglobal tree slots.\n+\t(function_id_node, pretty_function_id_node, func_id_node): Remove.\n+\t(c99_function_name_decl_node, function_name_decl_node,\n+\tpretty_function_name_decl_node, saved_function_name_decls):\n+\tDeclare.\n+\t(struct language_function): Remove x_function_name_declared_p.\n+\t(make_fname_decl): Remove a parameter.\n+\t(declare_function_names): Remove prototype.\n+\t(start_fname_decls, finish_fname_decls): Prototype.\n+\t(fname_as_string): Likewise.\n+\t(fname_string, fname_decl): Likewise.\n+\t* c-common.c (make_fname_decl): Adjust.\n+\t(struct fname_var_t): New struct.\n+\t(fname_vars): New static array.\n+\t(declare_function_name): Remove.\n+\t(start_fname_decls, finish_fname_decls): New functions.\n+\t(fname_as_string): New function from remnants of\n+\tdeclare_function_name.\n+\t(fname_string, fname_decl): New functions.\n+\n+\t* c-decl.c (c_function_name_declared_p): Remove.\n+\t(init_decl_processing): Don't generate __FUNCTION__ et al ids,\n+\tdon't call declare_function_name. Call start_fname_decls.\n+\t(c_make_fname_decl): Adjust parameters. Generate the name. Don't\n+\tclobber the line number. Call finish_decl.\n+\t(start_function): Call start_fname_decls.\n+\t(finish_function): Call finish_fname_decls.\n+\tRemove c_function_name_declared_p.\n+\t(push_c_function_context): Don't push c_function_name_declared_p.\n+\t(pop_c_function_context): Don't pop c_function_name_declared_p.\n+\t(c_begin_compound_stmt): Don't check c_function_name_declared_p.\n+\t* c-parse.in (STRING_FUNC_NAME, VAR_FUNC_NAME): New tokens.\n+\t(program): Call finish_fname_decls for C.\n+\t(primary): Add VAR_FUNC_NAME.\n+\t(reswords): Add slots for __FUNCTION__ et al.\n+\t(rid_to_yy): Add mappings for __FUNCTION__ et al.\n+\t(yylexname): If it's a STRING_FUNC_NAME generate the function name\n+\tnow. Don't look for VAR_DECLs containing __FUNCTION__ et al.\n+\t* c-semantics.c (prune_unused_decls): Remove.\n+\t(finish_stmt_tree): Don't call prune_unused_decls.\n+\t(genrtl_decl_stmt): Don't prune unused decls here.\n+\n 2001-04-24  Nick Clifton  <nickc@cambridge.redhat.com>\n \n \t* dwarf2out.c (mem_loc_descriptor): If a SYMBOL_REF is in the"}, {"sha": "872750320ed4df0715a7f25c0a6cc4cd218a1212", "filename": "gcc/c-common.c", "status": "modified", "additions": 173, "deletions": 23, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "patch": "@@ -164,11 +164,17 @@ cpp_reader *parse_in;\t\t/* Declared in c-lex.h.  */\n \n \ttree void_list_node;\n \n-  The identifiers __FUNCTION__, __PRETTY_FUNCTION__, and __func__.\n+  The lazily created VAR_DECLS for __FUNCTION__, __PRETTY_FUNCTION__,\n+  and __func__. (C doesn't generate __FUNCTION__ and__PRETTY_FUNCTION__\n+  VAR_DECLS, but C++ does.)\n \n-\ttree function_id_node;\n-\ttree pretty_function_id_node;\n-\ttree func_id_node;\n+\ttree function_name_decl_node;\n+\ttree pretty_function_name_declnode;\n+\ttree c99_function_name_decl_node;\n+\n+  Stack of nested function name VAR_DECLs.\n+  \n+\ttree saved_function_name_decls;\n \n */\n \n@@ -204,7 +210,7 @@ int warn_sequence_point;\n    type names and storage classes.  It is indexed by a RID_... value.  */\n tree *ridpointers;\n \n-tree (*make_fname_decl)                PARAMS ((tree, const char *, int));\n+tree (*make_fname_decl)                PARAMS ((tree, int));\n \n /* If non-NULL, the address of a language-specific function that\n    returns 1 for language-specific statement codes.  */\n@@ -228,6 +234,27 @@ enum attrs {A_PACKED, A_NOCOMMON, A_COMMON, A_NORETURN, A_CONST, A_T_UNION,\n \t    A_UNUSED, A_FORMAT, A_FORMAT_ARG, A_WEAK, A_ALIAS, A_MALLOC,\n \t    A_NO_LIMIT_STACK, A_PURE};\n \n+/* Information about how a function name is generated. */\n+struct fname_var_t\n+{\n+  tree *decl;\t/* pointer to the VAR_DECL. */\n+  unsigned rid;\t/* RID number for the identifier. */\n+  int pretty;\t/* How pretty is it? */\n+};\n+\n+/* The three ways of getting then name of the current function. */\n+\n+const struct fname_var_t fname_vars[] =\n+{\n+  /* C99 compliant __func__, must be first. */\n+  {&c99_function_name_decl_node, RID_C99_FUNCTION_NAME, 0},\n+  /* GCC __FUNCTION__ compliant. */\n+  {&function_name_decl_node, RID_FUNCTION_NAME, 0},\n+  /* GCC __PRETTY_FUNCTION__ compliant. */\n+  {&pretty_function_name_decl_node, RID_PRETTY_FUNCTION_NAME, 1},\n+  {NULL, 0, 0},\n+};\n+\n static void add_attribute\t\tPARAMS ((enum attrs, const char *,\n \t\t\t\t\t\t int, int, int));\n static void init_attributes\t\tPARAMS ((void));\n@@ -344,34 +371,157 @@ c_finish_else ()\n   RECHAIN_STMTS (if_stmt, ELSE_CLAUSE (if_stmt));\n }\n \n-/* Make bindings for __FUNCTION__, __PRETTY_FUNCTION__, and __func__.  */\n+/* Push current bindings for the function name VAR_DECLS. */\n+\n+void\n+start_fname_decls ()\n+{\n+  unsigned ix;\n+  tree saved = NULL_TREE;\n+  \n+  for (ix = 0; fname_vars[ix].decl; ix++)\n+    {\n+      tree decl = *fname_vars[ix].decl;\n+\n+      if (decl)\n+\t{\n+\t  saved = tree_cons (decl, build_int_2 (ix, 0), saved);\n+\t  *fname_vars[ix].decl = NULL_TREE;\n+\t}\n+    }\n+  if (saved || saved_function_name_decls)\n+    /* Normally they'll have been NULL, so only push if we've got a\n+       stack, or they are non-NULL.  */\n+    saved_function_name_decls = tree_cons (saved, NULL_TREE,\n+\t\t\t\t\t   saved_function_name_decls);\n+}\n+\n+/* Finish up the current bindings, adding them into the\n+   current function's statement tree. This is done by wrapping the\n+   function's body in a COMPOUND_STMT containing these decls too. This\n+   must be done _before_ finish_stmt_tree is called. If there is no\n+   current function, we must be at file scope and no statements are\n+   involved. Pop the previous bindings. */\n \n void\n-declare_function_name ()\n+finish_fname_decls ()\n {\n-  const char *name, *printable_name;\n+  unsigned ix;\n+  tree body = NULL_TREE;\n+  tree stack = saved_function_name_decls;\n \n-  if (current_function_decl == NULL)\n+  for (; stack && TREE_VALUE (stack); stack = TREE_CHAIN (stack))\n+    body = chainon (TREE_VALUE (stack), body);\n+  \n+  if (body)\n     {\n-      name = \"\";\n-      printable_name = \"top level\";\n+      /* They were called into existance, so add to statement tree. */\n+      body = chainon (body,\n+\t\t      TREE_CHAIN (DECL_SAVED_TREE (current_function_decl)));\n+      body = build_stmt (COMPOUND_STMT, body);\n+      \n+      COMPOUND_STMT_NO_SCOPE (body) = 1;\n+      TREE_CHAIN (DECL_SAVED_TREE (current_function_decl)) = body;\n     }\n-  else\n+  \n+  for (ix = 0; fname_vars[ix].decl; ix++)\n+    *fname_vars[ix].decl = NULL_TREE;\n+  \n+  if (stack)\n     {\n-      /* Allow functions to be nameless (such as artificial ones).  */\n-      if (DECL_NAME (current_function_decl))\n-        name = IDENTIFIER_POINTER (DECL_NAME (current_function_decl));\n-      else\n-\tname = \"\";\n-      printable_name = (*decl_printable_name) (current_function_decl, 2);\n+      /* We had saved values, restore them. */\n+      tree saved;\n \n-      /* ISO C99 defines __func__, which is a variable, not a string\n-\t constant, and which is not a defined symbol at file scope.  */\n-      (*make_fname_decl) (func_id_node, name, 0);\n+      for (saved = TREE_PURPOSE (stack); saved; saved = TREE_CHAIN (saved))\n+\t{\n+\t  tree decl = TREE_PURPOSE (saved);\n+\t  unsigned ix = TREE_INT_CST_LOW (TREE_VALUE (saved));\n+\t  \n+\t  *fname_vars[ix].decl = decl;\n+\t}\n+      stack = TREE_CHAIN (stack);\n+    }\n+  saved_function_name_decls = stack;\n+}\n+\n+/* Return the text name of the current function, suitable prettified\n+   by PRETTY_P. */\n+\n+const char *\n+fname_as_string (pretty_p)\n+     int pretty_p;\n+{\n+  const char *name = NULL;\n+  \n+  if (pretty_p)\n+    name = (current_function_decl\n+\t    ? (*decl_printable_name) (current_function_decl, 2)\n+\t    : \"top level\");\n+  else if (current_function_decl && DECL_NAME (current_function_decl))\n+    name = IDENTIFIER_POINTER (DECL_NAME (current_function_decl));\n+  else\n+    name = \"\";\n+  return name;\n+}\n+\n+/* Return the text name of the current function, formatted as\n+   required by the supplied RID value.  */\n+\n+const char *\n+fname_string (rid)\n+     unsigned rid;\n+{\n+  unsigned ix;\n+  \n+  for (ix = 0; fname_vars[ix].decl; ix++)\n+    if (fname_vars[ix].rid == rid)\n+      break;\n+  return fname_as_string (fname_vars[ix].pretty);\n+}\n+\n+/* Return the VAR_DECL for a const char array naming the current\n+   function. If the VAR_DECL has not yet been created, create it\n+   now. RID indicates how it should be formatted and IDENTIFIER_NODE\n+   ID is its name (unfortunately C and C++ hold the RID values of\n+   keywords in different places, so we can't derive RID from ID in\n+   this language independant code.  */\n+\n+tree\n+fname_decl (rid, id)\n+     unsigned rid;\n+     tree id;\n+{\n+  unsigned ix;\n+  tree decl = NULL_TREE;\n+\n+  for (ix = 0; fname_vars[ix].decl; ix++)\n+    if (fname_vars[ix].rid == rid)\n+      break;\n+\n+  decl = *fname_vars[ix].decl;\n+  if (!decl)\n+    {\n+      tree saved_last_tree = last_tree;\n+      \n+      decl = (*make_fname_decl) (id, fname_vars[ix].pretty);\n+      if (last_tree != saved_last_tree)\n+\t{\n+\t  /* We created some statement tree for the decl. This belongs\n+\t     at the start of the function, so remove it now and reinsert\n+\t     it after the function is complete. */\n+\t  tree stmts = TREE_CHAIN (saved_last_tree);\n+\n+\t  TREE_CHAIN (saved_last_tree) = NULL_TREE;\n+\t  last_tree = saved_last_tree;\n+\t  saved_function_name_decls = tree_cons (decl, stmts,\n+\t\t\t\t\t\t saved_function_name_decls);\n+\t}\n+      *fname_vars[ix].decl = decl;\n     }\n+  if (!ix && !current_function_decl)\n+    pedwarn_with_decl (decl, \"`%s' is not defined outside of function scope\");\n   \n-  (*make_fname_decl) (function_id_node, name, 0);\n-  (*make_fname_decl) (pretty_function_id_node, printable_name, 1);\n+  return decl;\n }\n \n /* Given a chain of STRING_CST nodes,"}, {"sha": "b9a7a9dd97f295ed200f112af1e30fc89234ff71", "filename": "gcc/c-common.h", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "patch": "@@ -75,6 +75,9 @@ enum rid\n   RID_EXTENSION, RID_IMAGPART, RID_REALPART, RID_LABEL,      RID_PTRBASE,\n   RID_PTREXTENT, RID_PTRVALUE,\n \n+  /* Too many ways of getting the name of a function as a string */\n+  RID_FUNCTION_NAME, RID_PRETTY_FUNCTION_NAME, RID_C99_FUNCTION_NAME,\n+\n   /* C++ */\n   RID_BOOL,     RID_WCHAR,    RID_CLASS,\n   RID_PUBLIC,   RID_PRIVATE,  RID_PROTECTED,\n@@ -154,11 +157,12 @@ enum c_tree_index\n     CTI_G77_LONGINT_TYPE,\n     CTI_G77_ULONGINT_TYPE,\n \n-    /* These are not types, but we have to look them up all the time.  */\n-    CTI_FUNCTION_ID,\n-    CTI_PRETTY_FUNCTION_ID,\n-    CTI_FUNC_ID,\n-\n+    /* These are not types, but we have to look them up all the time. */\n+    CTI_FUNCTION_NAME_DECL,\n+    CTI_PRETTY_FUNCTION_NAME_DECL,\n+    CTI_C99_FUNCTION_NAME_DECL,\n+    CTI_SAVED_FUNCTION_NAME_DECLS,\n+    \n     CTI_VOID_ZERO,\n \n     CTI_MAX\n@@ -202,9 +206,10 @@ enum c_tree_index\n #define g77_longint_type_node\t\tc_global_trees[CTI_G77_LONGINT_TYPE]\n #define g77_ulongint_type_node\t\tc_global_trees[CTI_G77_ULONGINT_TYPE]\n \n-#define function_id_node\t\tc_global_trees[CTI_FUNCTION_ID]\n-#define pretty_function_id_node\t\tc_global_trees[CTI_PRETTY_FUNCTION_ID]\n-#define func_id_node\t\t\tc_global_trees[CTI_FUNC_ID]\n+#define function_name_decl_node\t\tc_global_trees[CTI_FUNCTION_NAME_DECL]\n+#define pretty_function_name_decl_node\tc_global_trees[CTI_PRETTY_FUNCTION_NAME_DECL]\n+#define c99_function_name_decl_node\t\tc_global_trees[CTI_C99_FUNCTION_NAME_DECL]\n+#define saved_function_name_decls\tc_global_trees[CTI_SAVED_FUNCTION_NAME_DECLS]\n \n /* A node for `((void) 0)'.  */\n #define void_zero_node                  c_global_trees[CTI_VOID_ZERO]\n@@ -260,9 +265,6 @@ struct language_function {\n   struct stmt_tree_s x_stmt_tree;\n   /* The stack of SCOPE_STMTs for the current function.  */\n   tree x_scope_stmt_stack;\n-  /* Nonzero if __FUNCTION__ and its ilk have been declared in this\n-     function.  */\n-  int x_function_name_declared_p;\n };\n \n /* When building a statement-tree, this is the last statement added to\n@@ -468,19 +470,22 @@ extern int warn_long_long;\n    what operator was specified for it.  */\n #define C_EXP_ORIGINAL_CODE(exp) ((enum tree_code) TREE_COMPLEXITY (exp))\n \n-/* Pointer to function to generate the VAR_DECL for __FUNCTION__ etc.\n+/* Pointer to function to lazily generate the VAR_DECL for __FUNCTION__ etc.\n    ID is the identifier to use, NAME is the string.\n    TYPE_DEP indicates whether it depends on type of the function or not\n    (i.e. __PRETTY_FUNCTION__).  */\n \n-extern tree (*make_fname_decl)                  PARAMS ((tree, const char *, int));\n+extern tree (*make_fname_decl)                  PARAMS ((tree, int));\n \n extern tree identifier_global_value\t\tPARAMS ((tree));\n extern void record_builtin_type\t\t\tPARAMS ((enum rid,\n \t\t\t\t\t\t\t const char *, tree));\n extern tree build_void_list_node\t\tPARAMS ((void));\n-\n-extern void declare_function_name\t\tPARAMS ((void));\n+extern void start_fname_decls\t\t\tPARAMS ((void));\n+extern void finish_fname_decls\t\t\tPARAMS ((void));\n+extern const char *fname_as_string\t\tPARAMS ((int));\n+extern tree fname_decl\t\t\t\tPARAMS ((unsigned, tree));\n+extern const char *fname_string\t\t\tPARAMS ((unsigned));\n extern void decl_attributes\t\t\tPARAMS ((tree, tree, tree));\n extern void init_function_format_info\t\tPARAMS ((void));\n extern void check_function_format\t\tPARAMS ((int *, tree, tree, tree));"}, {"sha": "a386ecdad15afe6accdd3cd70e76398fdc71c746", "filename": "gcc/c-decl.c", "status": "modified", "additions": 19, "deletions": 33, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "patch": "@@ -104,11 +104,6 @@ static struct stmt_tree_s c_stmt_tree;\n \n static tree c_scope_stmt_stack;\n \n-/* Nonzero if __FUNCTION__ and its ilk have been declared in this\n-   function.  */\n-\n-static int c_function_name_declared_p;\n-\n /* A list (chain of TREE_LIST nodes) of all LABEL_DECLs in the function\n    that have names.  Here so we can clear out their names' definitions\n    at the end of the function.  */\n@@ -279,7 +274,7 @@ static tree grokdeclarator\t\tPARAMS ((tree, tree, enum decl_context,\n \t\t\t\t\t\t int));\n static tree grokparms\t\t\tPARAMS ((tree, int));\n static void layout_array_type\t\tPARAMS ((tree));\n-static tree c_make_fname_decl           PARAMS ((tree, const char *, int));\n+static tree c_make_fname_decl           PARAMS ((tree, int));\n static void c_expand_body               PARAMS ((tree, int));\n \f\n /* C-specific option variables.  */\n@@ -3093,13 +3088,8 @@ init_decl_processing ()\n \n   pedantic_lvalues = pedantic;\n \n-  /* Create the global bindings for __FUNCTION__, __PRETTY_FUNCTION__,\n-     and __func__.  */\n-  function_id_node = get_identifier (\"__FUNCTION__\");\n-  pretty_function_id_node = get_identifier (\"__PRETTY_FUNCTION__\");\n-  func_id_node = get_identifier (\"__func__\");\n   make_fname_decl = c_make_fname_decl;\n-  declare_function_name ();\n+  start_fname_decls ();\n \n   start_identifier_warnings ();\n \n@@ -3132,30 +3122,33 @@ init_decl_processing ()\n    are string merging candidates, which is wrong for C99's __func__.  FIXME.  */\n \n static tree\n-c_make_fname_decl (id, name, type_dep)\n+c_make_fname_decl (id, type_dep)\n      tree id;\n-     const char *name;\n-     int type_dep ATTRIBUTE_UNUSED;\n+     int type_dep;\n {\n+  const char *name = fname_as_string (type_dep);\n   tree decl, type, init;\n   size_t length = strlen (name);\n \n   type =  build_array_type\n           (build_qualified_type (char_type_node, TYPE_QUAL_CONST),\n-\t   build_index_type (build_int_2 (length, 0)));\n+\t   build_index_type (size_int (length)));\n \n   decl = build_decl (VAR_DECL, id, type);\n+  /* We don't push the decl, so have to set its context here. */\n+  DECL_CONTEXT (decl) = current_function_decl;\n+  \n   TREE_STATIC (decl) = 1;\n   TREE_READONLY (decl) = 1;\n-  TREE_ASM_WRITTEN (decl) = 1;\n-  DECL_SOURCE_LINE (decl) = 0;\n   DECL_ARTIFICIAL (decl) = 1;\n-  DECL_IN_SYSTEM_HEADER (decl) = 1;\n-  DECL_IGNORED_P (decl) = 1;\n+  \n   init = build_string (length + 1, name);\n   TREE_TYPE (init) = type;\n   DECL_INITIAL (decl) = init;\n-  finish_decl (pushdecl (decl), init, NULL_TREE);\n+\n+  TREE_USED (decl) = 1;\n+  \n+  finish_decl (decl, init, NULL_TREE);\n \n   return decl;\n }\n@@ -3487,9 +3480,9 @@ finish_decl (decl, init, asmspec_tree)\n     asmspec = TREE_STRING_POINTER (asmspec_tree);\n \n   /* If `start_decl' didn't like having an initialization, ignore it now.  */\n-\n   if (init != 0 && DECL_INITIAL (decl) == 0)\n     init = 0;\n+  \n   /* Don't crash if parm is initialized.  */\n   if (TREE_CODE (decl) == PARM_DECL)\n     init = 0;\n@@ -3507,7 +3500,6 @@ finish_decl (decl, init, asmspec_tree)\n     }\n \n   /* Deduce size of array from initialization, if not already known */\n-\n   if (TREE_CODE (type) == ARRAY_TYPE\n       && TYPE_DOMAIN (type) == 0\n       && TREE_CODE (decl) != TYPE_DECL)\n@@ -6029,6 +6021,8 @@ start_function (declspecs, declarator, prefix_attributes, attributes)\n \n   immediate_size_expand = old_immediate_size_expand;\n \n+  start_fname_decls ();\n+  \n   return 1;\n }\n \n@@ -6656,6 +6650,8 @@ finish_function (nested)\n #endif\n \t}\n     }\n+  \n+  finish_fname_decls ();\n \n   /* Tie off the statement tree for this function.  */\n   finish_stmt_tree (&DECL_SAVED_TREE (fndecl));\n@@ -6674,7 +6670,6 @@ finish_function (nested)\n \t function.  For a nested function, this value is used in\n \t pop_c_function_context and then reset via pop_function_context.  */\n       current_function_decl = NULL;\n-      c_function_name_declared_p = 0;\n     }\n }\n \n@@ -6916,7 +6911,6 @@ push_c_function_context (f)\n \n   p->base.x_stmt_tree = c_stmt_tree;\n   p->base.x_scope_stmt_stack = c_scope_stmt_stack;\n-  p->base.x_function_name_declared_p = c_function_name_declared_p;\n   p->named_labels = named_labels;\n   p->shadowed_labels = shadowed_labels;\n   p->returns_value = current_function_returns_value;\n@@ -6954,7 +6948,6 @@ pop_c_function_context (f)\n \n   c_stmt_tree = p->base.x_stmt_tree;\n   c_scope_stmt_stack = p->base.x_scope_stmt_stack;\n-  c_function_name_declared_p = p->base.x_function_name_declared_p;\n   named_labels = p->named_labels;\n   shadowed_labels = p->shadowed_labels;\n   current_function_returns_value = p->returns_value;\n@@ -7087,13 +7080,6 @@ c_begin_compound_stmt ()\n \n   /* Create the COMPOUND_STMT.  */\n   stmt = add_stmt (build_stmt (COMPOUND_STMT, NULL_TREE));\n-  /* If we haven't already declared __FUNCTION__ and its ilk then this\n-     is the opening curly brace of the function.  Declare them now.  */\n-  if (!c_function_name_declared_p)\n-    {\n-      c_function_name_declared_p = 1;\n-      declare_function_name ();\n-    }\n \n   return stmt;\n }"}, {"sha": "657c3fb700b9e5e903d369d50f457def0d10ce00", "filename": "gcc/c-parse.in", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "patch": "@@ -124,6 +124,9 @@ end ifc\n %token REALPART IMAGPART VA_ARG\n %token PTR_VALUE PTR_BASE PTR_EXTENT\n \n+/* function name can be a string const or a var decl. */\n+%token STRING_FUNC_NAME VAR_FUNC_NAME\n+\n /* Add precedence rules to solve dangling else s/r conflict */\n %nonassoc IF\n %nonassoc ELSE\n@@ -298,7 +301,10 @@ program: /* empty */\n \t\t     get us back to the global binding level.  */\n \t\t  while (! global_bindings_p ())\n \t\t    poplevel (0, 0, 0);\n-\t\t  finish_file ();\n+ifc\n+\t\t  finish_fname_decls ();\n+end ifc\n+                  finish_file ();\n \t\t}\n \t;\n \n@@ -631,6 +637,8 @@ primary:\n \t| CONSTANT\n \t| string\n \t\t{ $$ = combine_strings ($1); }\n+\t| VAR_FUNC_NAME\n+\t\t{ $$ = fname_decl (C_RID_CODE ($$), $$); }\n \t| '(' typename ')' '{' \n \t\t{ start_init (NULL_TREE, NULL, 0);\n \t\t  $2 = groktypename ($2);\n@@ -2884,6 +2892,8 @@ static const struct resword reswords[] =\n {\n   { \"_Bool\",\t\tRID_BOOL,\t0 },\n   { \"_Complex\",\t\tRID_COMPLEX,\t0 },\n+  { \"__FUNCTION__\",\tRID_FUNCTION_NAME, 0 },\n+  { \"__PRETTY_FUNCTION__\", RID_PRETTY_FUNCTION_NAME, 0 },\n   { \"__alignof\",\tRID_ALIGNOF,\t0 },\n   { \"__alignof__\",\tRID_ALIGNOF,\t0 },\n   { \"__asm\",\t\tRID_ASM,\t0 },\n@@ -2898,6 +2908,7 @@ static const struct resword reswords[] =\n   { \"__const\",\t\tRID_CONST,\t0 },\n   { \"__const__\",\tRID_CONST,\t0 },\n   { \"__extension__\",\tRID_EXTENSION,\t0 },\n+  { \"__func__\",\t\tRID_C99_FUNCTION_NAME, 0 },\n   { \"__imag\",\t\tRID_IMAGPART,\t0 },\n   { \"__imag__\",\t\tRID_IMAGPART,\t0 },\n   { \"__inline\",\t\tRID_INLINE,\t0 },\n@@ -3057,6 +3068,10 @@ static const short rid_to_yy[RID_MAX] =\n   /* RID_PTREXTENT */\tPTR_EXTENT,\n   /* RID_PTRVALUE */\tPTR_VALUE,\n \n+  /* RID_FUNCTION_NAME */\t\tSTRING_FUNC_NAME,\n+  /* RID_PRETTY_FUNCTION_NAME */\tSTRING_FUNC_NAME,\n+  /* RID_C99_FUNCTION_NAME */\t\tVAR_FUNC_NAME,\n+\n   /* C++ */\n   /* RID_BOOL */\tTYPESPEC,\n   /* RID_WCHAR */\t0,\n@@ -3098,7 +3113,7 @@ static const short rid_to_yy[RID_MAX] =\n   /* RID_BITAND */\t0,\n   /* RID_BITOR */\t0,\n   /* RID_COMPL */\t0,\n-\n+  \n   /* Objective C */\n   /* RID_ID */\t\t\tOBJECTNAME,\n   /* RID_AT_ENCODE */\t\tENCODE,\n@@ -3226,33 +3241,29 @@ yylexname ()\n   if (C_IS_RESERVED_WORD (yylval.ttype))\n     {\n       enum rid rid_code = C_RID_CODE (yylval.ttype);\n+      int yycode = rid_to_yy[(int) rid_code];\n+\n+      if (yycode == STRING_FUNC_NAME)\n+\t{\n+\t   /* __FUNCTION__ and __PRETTY_FUNCTION__ get converted\n+\t      to string constants.  */\n+\t  const char *name = fname_string (rid_code);\n+\t  \n+\t  yylval.ttype = build_string (strlen (name) + 1, name);\n+\t  last_token = CPP_STRING;  /* so yyerror won't choke */\n+\t  return STRING;\n+\t}\n+      \n       /* Return the canonical spelling for this keyword.  */\n       yylval.ttype = ridpointers[(int) rid_code];\n-      return rid_to_yy[(int) rid_code];\n+      return yycode;\n     }\n \n   decl = lookup_name (yylval.ttype);\n   if (decl)\n     {\n       if (TREE_CODE (decl) == TYPE_DECL)\n \treturn TYPENAME;\n-      /* A user-invisible read-only initialized variable\n-\t should be replaced by its value.\n-\t We handle only strings since that's the only case used in C.  */\n-      else if (TREE_CODE (decl) == VAR_DECL\n-\t       && DECL_IGNORED_P (decl)\n-\t       && TREE_READONLY (decl)\n-\t       && DECL_INITIAL (decl) != 0\n-\t       && TREE_CODE (DECL_INITIAL (decl)) == STRING_CST)\n-\t{\n-\t  tree stringval = DECL_INITIAL (decl);\n-\n-\t  /* Copy the string value so that we won't clobber anything\n-\t     if we put something in the TREE_CHAIN of this one.  */\n-\t  yylval.ttype = build_string (TREE_STRING_LENGTH (stringval),\n-\t\t\t\t       TREE_STRING_POINTER (stringval));\n-\t  return STRING;\n-\t}\n     }\n   else if (doing_objc_thang)\n     {"}, {"sha": "13480480a4337e757f9d80a55d56da94eaad18c5", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 4, "deletions": 71, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "patch": "@@ -48,8 +48,6 @@ void (*lang_expand_stmt) PARAMS ((tree));\n    variables and labels do not require any RTL generation.  */\n void (*lang_expand_decl_stmt) PARAMS ((tree));\n \n-static tree prune_unused_decls PARAMS ((tree *, int *, void *));\n-\n /* Create an empty statement tree rooted at T.  */\n \n void\n@@ -73,8 +71,9 @@ add_stmt (t)\n   /* Add T to the statement-tree.  */\n   TREE_CHAIN (last_tree) = t;\n   last_tree = t;\n+  \n   /* When we expand a statement-tree, we must know whether or not the\n-     statements are full-expresions.  We record that fact here.  */\n+     statements are full-expressions.  We record that fact here.  */\n   STMT_IS_FULL_EXPR_P (last_tree) = stmts_are_full_exprs_p ();\n \n   /* Keep track of the number of statements in this function.  */\n@@ -105,7 +104,7 @@ add_decl_stmt (decl)\n    returns a new TREE_LIST representing the top of the SCOPE_STMT\n    stack.  The TREE_PURPOSE is the new SCOPE_STMT.  If BEGIN_P is\n    zero, returns a TREE_LIST whose TREE_VALUE is the new SCOPE_STMT,\n-   and whose TREE_PURPOSE is the matching SCOPE_STMT iwth\n+   and whose TREE_PURPOSE is the matching SCOPE_STMT with\n    SCOPE_BEGIN_P set.  */\n \n tree\n@@ -141,61 +140,6 @@ add_scope_stmt (begin_p, partial_p)\n   return top;\n }\n \n-/* Remove declarations of internal variables that are not used from a\n-   stmt tree.  To qualify, the variable must have a name and must have\n-   a zero DECL_SOURCE_LINE.  We tried to remove all variables for\n-   which TREE_USED was false, but it turns out that there's tons of\n-   variables for which TREE_USED is false but that are still in fact\n-   used.  */\n-\n-static tree\n-prune_unused_decls (tp, walk_subtrees, data)\n-     tree *tp;\n-     int *walk_subtrees ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  tree t = *tp;\n-\n-  if (t == NULL_TREE)\n-    return error_mark_node;\n-\n-  if (TREE_CODE (t) == DECL_STMT)\n-    {\n-      tree d = DECL_STMT_DECL (t);\n-      if (!TREE_USED (d) && DECL_NAME (d) && DECL_SOURCE_LINE (d) == 0)\n-\t{\n-\t  *tp = TREE_CHAIN (t);\n-\t  /* Recurse on the new value of tp, otherwise we will skip\n-\t     the next statement.  */\n-\t  return prune_unused_decls (tp, walk_subtrees, data);\n-\t}\n-    }\n-  else if (TREE_CODE (t) == SCOPE_STMT)\n-    {\n-      /* Remove all unused decls from the BLOCK of this SCOPE_STMT.  */\n-      tree block = SCOPE_STMT_BLOCK (t);\n-\n-      if (block)\n-\t{\n-\t  tree *vp;\n-\n-\t  for (vp = &BLOCK_VARS (block); *vp; )\n-\t    {\n-\t      tree v = *vp;\n-\t      if (! TREE_USED (v) && DECL_NAME (v) && DECL_SOURCE_LINE (v) == 0)\n-\t\t*vp = TREE_CHAIN (v);  /* drop */\n-\t      else\n-\t\tvp = &TREE_CHAIN (v);  /* advance */\n-\t    }\n-\t  /* If there are now no variables, the entire BLOCK can be dropped.\n-\t     (This causes SCOPE_NULLIFIED_P (t) to be true.)  */\n-\t  if (BLOCK_VARS (block) == NULL_TREE)\n-\t    SCOPE_STMT_BLOCK (t) = NULL_TREE;\n-\t}\n-    }\n-  return NULL_TREE;\n-}\n-\n /* Finish the statement tree rooted at T.  */\n \n void\n@@ -209,9 +153,6 @@ finish_stmt_tree (t)\n   *t = stmt;\n   last_tree = NULL_TREE;\n \n-  /* Remove unused decls from the stmt tree.  */\n-  walk_stmt_tree (t, prune_unused_decls, NULL);\n-\n   if (cfun && stmt)\n     {\n       /* The line-number recorded in the outermost statement in a function\n@@ -420,15 +361,7 @@ genrtl_decl_stmt (t)\n \t\t\t\tDECL_ANON_UNION_ELEMS (decl));\n     }\n   else if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl))\n-    {\n-      if (DECL_ARTIFICIAL (decl) && ! TREE_USED (decl))\n-\t/* Do not emit unused decls. This is not just an\n-\t   optimization. We really do not want to emit\n-\t   __PRETTY_FUNCTION__ etc, if they're never used.  */\n-\tDECL_IGNORED_P (decl) = 1;\n-      else\n-\tmake_rtl_for_local_static (decl);\n-    }\n+    make_rtl_for_local_static (decl);\n   else if (TREE_CODE (decl) == LABEL_DECL \n \t   && C_DECLARED_LABEL_FLAG (decl))\n     declare_nonlocal_label (decl);"}, {"sha": "69a674d954bf3db2ff69f6b8aab02a9f5b6049e2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "patch": "@@ -1,3 +1,35 @@\n+2001-04-24  Nathan Sidwell <nathan@codesourcery.com>\n+\n+\tLazy __FUNCTION__ generation.\n+\t* cp-tree.def (FUNCTION_NAME): Remove.\n+\t* cp-tree.h (function_name_declared_p): Remove.\n+\t(cp_fname_init): Prototype.\n+\t* decl.c (init_decl_processing): Don't generate __FUNCTION__ et al ids,\n+\tdon't call declare_function_name. Call start_fname_decls.\n+\t(cp_make_fname_decl): Adjust parameters. Generate the name. Don't\n+\tclobber the line number.\n+\t(cp_fname_init): New function.\n+\t(start_function): Call start_fname_decls.\n+\t(finish_function): Call finish_fname_decls.\n+\t* lex.c (reswords): Add slots for __FUNCTION__ et al.\n+\t(rid_to_yy): Add mappings for __FUNCTION__ et al.\n+\t* optimize.c (maybe_clone_body): Remove function_name_declared_p.\n+\t* parse.y (VAR_FUNC_NAME): New token.\n+\t(primary): Add VAR_FUNC_NAME.\n+\t* pt.c (tsubst_decl): Adjust a DECL_PRETTY_FUNCTION_P's\n+\tgeneration.\n+\t(tsubst, FUNCTION_NAME case): Remove.\n+\t(tsubst_copy, FUNCTION_NAME case): Remove.\n+\t(tsubst_expr, DECL_STMT case): Be careful with a\n+\tDECL_PRETTY_FUNCTION_P.\n+\t(instantiate_decl): Remove function_name_declared_p.\n+\t* semantics.c (begin_compound_statement): Don't call\n+\tdeclare_function_name here.\n+\t(setup_vtbl_ptr). Don't save & restore function_name_declared_p.\n+\t(finish_translation_unit): Call finish_fname_decls.\n+\t(expand_body): Remove function_name_declared_p.\n+\t* typeck2.c (digest_init): Allow any ERROR_MARK.\n+\n 2001-04-24  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* pt.c (tsubst_decl): Use VOID_TYPE_P."}, {"sha": "486667c3a80f5b4046a4c300166f61dfad5ad9f9", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "patch": "@@ -200,9 +200,6 @@ DEFTREECODE (WRAPPER, \"wrapper\", 'x', 1)\n    unused.  */\n DEFTREECODE (LOOKUP_EXPR, \"lookup_expr\", 'e', 1)\n \n-/* Used to represent __PRETTY_FUNCTION__ in template bodies.  */\n-DEFTREECODE (FUNCTION_NAME, \"function_name\", 'e', 0)\n-\n /* A whole bunch of tree codes for the initial, superficial parsing of\n    templates.  */\n DEFTREECODE (MODOP_EXPR, \"modop_expr\", 'e', 3)"}, {"sha": "2723c316b4ee900b9f6cf7e991a6fcac658a6ed3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "patch": "@@ -968,12 +968,6 @@ struct cp_language_function\n \n #define in_function_try_handler cp_function_chain->in_function_try_handler\n \n-/* Nonzero if __FUNCTION__ and its ilk have been declared in this\n-   function.  */\n-\n-#define function_name_declared_p \\\n-  (cp_function_chain->base.x_function_name_declared_p)\n-\n extern tree current_function_return_value;\n extern tree global_namespace;\n \n@@ -3911,6 +3905,7 @@ extern int nonstatic_local_decl_p               PARAMS ((tree));\n extern tree declare_global_var                  PARAMS ((tree, tree));\n extern void register_dtor_fn                    PARAMS ((tree));\n extern tmpl_spec_kind current_tmpl_spec_kind    PARAMS ((int));\n+extern tree cp_fname_init\t\t\tPARAMS ((const char *));\n \n /* in decl2.c */\n extern void init_decl2\t\t\t\tPARAMS ((void));"}, {"sha": "834e2dcd5da04e1ce14a72f9af645ac0c41d1312", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 58, "deletions": 45, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "patch": "@@ -138,7 +138,7 @@ static tree get_atexit_node PARAMS ((void));\n static tree get_dso_handle_node PARAMS ((void));\n static tree start_cleanup_fn PARAMS ((void));\n static void end_cleanup_fn PARAMS ((void));\n-static tree cp_make_fname_decl PARAMS ((tree, const char *, int));\n+static tree cp_make_fname_decl PARAMS ((tree, int));\n static void initialize_predefined_identifiers PARAMS ((void));\n static tree check_special_function_return_type\n   PARAMS ((special_function_kind, tree, tree));\n@@ -6519,14 +6519,16 @@ init_decl_processing ()\n \n   {\n     tree bad_alloc_type_node, newtype, deltype;\n+    \n     if (flag_honor_std)\n       push_namespace (std_identifier);\n     bad_alloc_type_node = xref_tag\n       (class_type_node, get_identifier (\"bad_alloc\"), 1);\n     if (flag_honor_std)\n       pop_namespace ();\n     newtype = build_exception_variant\n-      (ptr_ftype_sizetype, add_exception_specifier (NULL_TREE, bad_alloc_type_node, -1));\n+      (ptr_ftype_sizetype, add_exception_specifier\n+       (NULL_TREE, bad_alloc_type_node, -1));\n     deltype = build_exception_variant (void_ftype_ptr, empty_except_spec);\n     push_cp_library_fn (NEW_EXPR, newtype);\n     push_cp_library_fn (VEC_NEW_EXPR, newtype);\n@@ -6553,13 +6555,8 @@ init_decl_processing ()\n   if (! supports_one_only ())\n     flag_weak = 0;\n \n-  /* Create the global bindings for __FUNCTION__ and __PRETTY_FUNCTION__.  */\n-  function_id_node = get_identifier (\"__FUNCTION__\");\n-  pretty_function_id_node = get_identifier (\"__PRETTY_FUNCTION__\");\n-  func_id_node = get_identifier (\"__func__\");\n-\n   make_fname_decl = cp_make_fname_decl;\n-  declare_function_name ();\n+  start_fname_decls ();\n \n   /* Prepare to check format strings against argument lists.  */\n   init_function_format_info ();\n@@ -6607,57 +6604,68 @@ init_decl_processing ()\n   ggc_add_tree_root (&free_bindings, 1);\n }\n \n+/* Generate an initializer for a function naming variable from\n+   NAME. NAME may be NULL, in which case we generate a special\n+   ERROR_MARK node which should be replaced later. */\n+\n+tree\n+cp_fname_init (name)\n+     const char *name;\n+{\n+  tree domain = NULL_TREE;\n+  tree type;\n+  tree init = NULL_TREE;\n+  size_t length = 0;\n+\n+  if (name)\n+    {\n+      length = strlen (name);\n+      domain = build_index_type (size_int (length));\n+      init = build_string (length + 1, name);\n+    }\n+  \n+  type = build_qualified_type (char_type_node, TYPE_QUAL_CONST);\n+  type = build_cplus_array_type (type, domain);\n+\n+  if (init)\n+    TREE_TYPE (init) = type;\n+  else\n+    /* We don't know the value until instantiation time. Make\n+       something which will be digested now, but replaced later. */\n+    init = build (ERROR_MARK, type);\n+  \n+  return init;\n+}\n+\n /* Create the VAR_DECL for __FUNCTION__ etc. ID is the name to give the\n    decl, NAME is the initialization string and TYPE_DEP indicates whether\n    NAME depended on the type of the function. We make use of that to detect\n-   __PRETTY_FUNCTION__ inside a template fn.  Because we build a tree for\n-   the function before emitting any of it, we don't need to treat the\n-   VAR_DECL specially. We can decide whether to emit it later, if it was\n-   used.  */\n+   __PRETTY_FUNCTION__ inside a template fn. This is being done\n+   lazily at the point of first use, so we musn't push the decl now.  */\n \n static tree\n-cp_make_fname_decl (id, name, type_dep)\n+cp_make_fname_decl (id, type_dep)\n      tree id;\n-     const char *name;\n      int type_dep;\n {\n-  tree decl, type, init;\n-  size_t length = strlen (name);\n-  tree domain = NULL_TREE;\n-\n-  if (!processing_template_decl)\n-    type_dep = 0;\n-  if (!type_dep)\n-    domain = build_index_type (size_int (length));\n-\n-  type =  build_cplus_array_type\n-          (build_qualified_type (char_type_node, TYPE_QUAL_CONST),\n-\t   domain);\n+  const char *name = (type_dep && processing_template_decl\n+\t\t      ? NULL : fname_as_string (type_dep));\n+  tree init = cp_fname_init (name);\n+  tree decl = build_decl (VAR_DECL, id, TREE_TYPE (init));\n \n-  decl = build_decl (VAR_DECL, id, type);\n+  /* As we don't push the decl here, we must set the context. */\n+  DECL_CONTEXT (decl) = current_function_decl;\n+  DECL_PRETTY_FUNCTION_P (decl) = type_dep;\n+      \n   TREE_STATIC (decl) = 1;\n   TREE_READONLY (decl) = 1;\n-  DECL_SOURCE_LINE (decl) = 0;\n   DECL_ARTIFICIAL (decl) = 1;\n-  DECL_IN_SYSTEM_HEADER (decl) = 1;\n-  DECL_IGNORED_P (decl) = 1;\n-  pushdecl (decl);\n-  if (processing_template_decl)\n-    decl = push_template_decl (decl);\n-  if (type_dep)\n-    {\n-      init = build (FUNCTION_NAME, type);\n-      DECL_PRETTY_FUNCTION_P (decl) = 1;\n-    }\n-  else\n-    {\n-      init = build_string (length + 1, name);\n-      TREE_TYPE (init) = type;\n-    }\n   DECL_INITIAL (decl) = init;\n-  cp_finish_decl (decl, init, NULL_TREE, LOOKUP_ONLYCONVERTING);\n+  \n+  TREE_USED (decl) = 1;\n \n-  /* We will have to make sure we only emit this, if it is actually used. */\n+  cp_finish_decl (decl, init, NULL_TREE, LOOKUP_ONLYCONVERTING);\n+      \n   return decl;\n }\n \n@@ -12966,6 +12974,7 @@ finish_enum (enumtype)\n       if (scope && TREE_CODE (scope) == FUNCTION_DECL)\n \tadd_stmt (build_min (TAG_DEFN, enumtype));\n \n+\n       return;\n     }\n \n@@ -13602,6 +13611,8 @@ start_function (declspecs, declarator, attrs, flags)\n       DECL_CONTEXT (dtor_label) = current_function_decl;\n     }\n \n+  start_fname_decls ();\n+  \n   store_parm_decls (current_function_parms);\n \n   return 1;\n@@ -13931,6 +13942,8 @@ finish_function (flags)\n \n   my_friendly_assert (building_stmt_tree (), 20000911);\n \n+  finish_fname_decls ();\n+  \n   /* For a cloned function, we've already got all the code we need;\n      there's no need to add any extra bits.  */\n   if (!DECL_CLONED_FUNCTION_P (fndecl))"}, {"sha": "f005482aec1776fd4e42011aa55ed945b663a718", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "patch": "@@ -402,6 +402,8 @@ CONSTRAINT(ridbits_fit, RID_LAST_MODIFIER < sizeof(unsigned long) * CHAR_BIT);\n static const struct resword reswords[] =\n {\n   { \"_Complex\",\t\tRID_COMPLEX,\t0 },\n+  { \"__FUNCTION__\",\tRID_FUNCTION_NAME, 0 },\n+  { \"__PRETTY_FUNCTION__\", RID_PRETTY_FUNCTION_NAME, 0 },\n   { \"__alignof\", \tRID_ALIGNOF,\t0 },\n   { \"__alignof__\",\tRID_ALIGNOF,\t0 },\n   { \"__asm\",\t\tRID_ASM,\t0 },\n@@ -414,6 +416,7 @@ static const struct resword reswords[] =\n   { \"__const\",\t\tRID_CONST,\t0 },\n   { \"__const__\",\tRID_CONST,\t0 },\n   { \"__extension__\",\tRID_EXTENSION,\t0 },\n+  { \"__func__\",\t\tRID_C99_FUNCTION_NAME,\t0 },\n   { \"__imag\",\t\tRID_IMAGPART,\t0 },\n   { \"__imag__\",\t\tRID_IMAGPART,\t0 },\n   { \"__inline\",\t\tRID_INLINE,\t0 },\n@@ -585,6 +588,10 @@ const short rid_to_yy[RID_MAX] =\n   /* RID_PTREXTENT */\t0,\n   /* RID_PTRVALUE */\t0,\n \n+  /* RID_FUNCTION_NAME */\tVAR_FUNC_NAME,\n+  /* RID_PRETTY_FUNCTION_NAME */ VAR_FUNC_NAME,\n+  /* RID_c99_FUNCTION_NAME */\tVAR_FUNC_NAME,\n+\n   /* C++ */\n   /* RID_BOOL */\tTYPESPEC,\n   /* RID_WCHAR */\tTYPESPEC,"}, {"sha": "2ed10ea0c341e82ed609ccf6656d154490264090", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "patch": "@@ -1123,7 +1123,6 @@ maybe_clone_body (fn)\n       VARRAY_FREE (id.fns);\n \n       /* Now, expand this function into RTL, if appropriate.  */\n-      function_name_declared_p = 1;\n       finish_function (0);\n       BLOCK_ABSTRACT_ORIGIN (DECL_INITIAL (clone)) = DECL_INITIAL (fn);\n       expand_body (clone);"}, {"sha": "22b3e9583a7320f079b4406dcf2113e622e01345", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "patch": "@@ -259,6 +259,10 @@ cp_parse_init ()\n    yylval is the node for the constant.  */\n %token CONSTANT\n \n+/* __func__, __FUNCTION__ or __PRETTY_FUNCTION__.\n+   yylval contains an IDENTIFIER_NODE which indicates which one.  */\n+%token VAR_FUNC_NAME\n+\n /* String constants in raw form.\n    yylval is a STRING_CST node.  */\n %token STRING\n@@ -1556,6 +1560,12 @@ primary:\n \t\t      (TREE_TYPE (TREE_TYPE ($$)),\n \t\t       TYPE_DOMAIN (TREE_TYPE ($$)));\n \t\t}\n+\t| VAR_FUNC_NAME\n+\t\t{\n+\t\t  $$ = fname_decl (C_RID_CODE ($$), $$);\n+\t\t  if (processing_template_decl)\n+\t\t    $$ = build_min_nt (LOOKUP_EXPR, DECL_NAME ($$));\n+\t\t}\n \t| '(' expr ')'\n \t\t{ $$ = finish_parenthesized_expr ($2); }\n \t| '(' expr_or_declarator_intern ')'"}, {"sha": "2a1dc4414ae6d86c81a69d11efd20e8f866f133a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 30, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "patch": "@@ -5987,10 +5987,9 @@ tsubst_decl (t, args, type)\n \t/* For __PRETTY_FUNCTION__ we have to adjust the initializer.  */\n \tif (DECL_PRETTY_FUNCTION_P (r))\n \t  {\n-\t    DECL_INITIAL (r) = tsubst (DECL_INITIAL (t),\n-\t\t\t\t       args,\n-\t\t\t\t       /*complain=*/1,\n-\t\t\t\t       NULL_TREE);\n+\t    const char *name = (*decl_printable_name)\n+\t      \t\t\t(current_function_decl, 2);\n+\t    DECL_INITIAL (r) = cp_fname_init (name);\n \t    TREE_TYPE (r) = TREE_TYPE (DECL_INITIAL (r));\n \t  }\n \n@@ -6794,24 +6793,6 @@ tsubst (t, args, complain, in_decl)\n \treturn TREE_TYPE (e1); \n       }\n \n-    case FUNCTION_NAME:\n-      {\n-\tconst char *name;\n-\tint len;\n-\ttree type;\n-\ttree str;\n-\n-\t/* This code should match declare_hidden_char_array in\n-\t   c-common.c.  */\n-\tname = (*decl_printable_name) (current_function_decl, 2);\n-\tlen = strlen (name) + 1;\n-\ttype =  build_array_type (char_type_node, \n-\t\t\t\t  build_index_type (size_int (len)));\n-\tstr = build_string (len, name);\n-\tTREE_TYPE (str) = type;\n-\treturn str;\n-      }\n-\n     default:\n       sorry (\"use of `%s' in template\",\n \t     tree_code_name [(int) TREE_CODE (t)]);\n@@ -7172,9 +7153,6 @@ tsubst_copy (t, args, complain, in_decl)\n \t\t\t\t\tin_decl),\n \t\t\t   tsubst (TREE_TYPE (t), args, complain, in_decl));\n \n-    case FUNCTION_NAME:\n-      return tsubst (t, args, complain, in_decl);\n-\n     default:\n       return t;\n     }\n@@ -7254,7 +7232,10 @@ tsubst_expr (t, args, complain, in_decl)\n \t  {\n \t    init = DECL_INITIAL (decl);\n \t    decl = tsubst (decl, args, complain, in_decl);\n-\t    init = tsubst_expr (init, args, complain, in_decl);\n+\t    if (DECL_PRETTY_FUNCTION_P (decl))\n+\t      init = DECL_INITIAL (decl);\n+\t    else\n+\t      init = tsubst_expr (init, args, complain, in_decl);\n \t    if (decl != error_mark_node)\n \t      {\n                 if (TREE_CODE (decl) != TYPE_DECL)\n@@ -9934,10 +9915,6 @@ instantiate_decl (d, defer_ok)\n       /* Set up context.  */\n       start_function (NULL_TREE, d, NULL_TREE, SF_PRE_PARSED);\n \n-      /* We already set up __FUNCTION__, etc., so we don't want to do\n-\t it again now.  */\n-      function_name_declared_p = 1;\n-\n       /* Substitute into the body of the function.  */\n       tsubst_expr (DECL_SAVED_TREE (code_pattern), args,\n \t\t   /*complain=*/1, tmpl);"}, {"sha": "5a42fd034a24f746159bc7de92e1aad952739aac", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "patch": "@@ -852,16 +852,6 @@ begin_compound_stmt (has_no_scope)\n        to accidentally keep a block *inside* the scopeless block.  */ \n     keep_next_level (0);\n \n-  /* If this is the outermost block of the function, declare the\n-     variables __FUNCTION__, __PRETTY_FUNCTION__, and so forth.  */\n-  if (cfun\n-      && !function_name_declared_p\n-      && !has_no_scope)\n-    {\n-      function_name_declared_p = 1;\n-      declare_function_name ();\n-    }\n-\n   return r;\n }\n \n@@ -1180,7 +1170,6 @@ setup_vtbl_ptr (member_init_list, base_init_list)\n     {\n       tree if_stmt;\n       tree compound_stmt;\n-      int saved_cfnd;\n \n       /* If the dtor is empty, and we know there is not any possible\n \t way we could use any vtable entries, before they are possibly\n@@ -1201,12 +1190,7 @@ setup_vtbl_ptr (member_init_list, base_init_list)\n       finish_if_stmt_cond (boolean_true_node, if_stmt);\n       current_vcalls_possible_p = &IF_COND (if_stmt);\n \n-      /* Don't declare __PRETTY_FUNCTION__ and friends here when we\n-\t open the block for the if-body.  */\n-      saved_cfnd = function_name_declared_p;\n-      function_name_declared_p = 1;\n       compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n-      function_name_declared_p = saved_cfnd;\n \n       /* Make all virtual function table pointers in non-virtual base\n \t classes point to CURRENT_CLASS_TYPE's virtual function\n@@ -1706,6 +1690,10 @@ finish_translation_unit ()\n   pop_everything ();\n   while (current_namespace != global_namespace)\n     pop_namespace ();\n+\n+  /* Do file scope __FUNCTION__ et al. */\n+  finish_fname_decls ();\n+  \n   finish_file ();\n }\n \n@@ -2472,11 +2460,6 @@ expand_body (fn)\n   genrtl_start_function (fn);\n   current_function_is_thunk = DECL_THUNK_P (fn);\n \n-  /* We don't need to redeclare __FUNCTION__, __PRETTY_FUNCTION__, or\n-     any of the other magic variables we set up when starting a\n-     function body.  */\n-  function_name_declared_p = 1;\n-\n   /* Expand the body.  */\n   expand_stmt (DECL_SAVED_TREE (fn));\n "}, {"sha": "26b2a1c5a7147a633ce3238ea0a800006bb5c171", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "patch": "@@ -470,6 +470,11 @@ digest_init (type, init, tail)\n \t\t\t\t  && TREE_VALUE (init) == error_mark_node))\n     return error_mark_node;\n \n+  if (TREE_CODE (init) == ERROR_MARK)\n+    /* __PRETTY_FUNCTION__'s initializer is a bogus expression inside\n+       a template function. This gets substituted during instantiation. */\n+    return init;\n+  \n   /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n   if (TREE_CODE (init) == NON_LVALUE_EXPR)\n     init = TREE_OPERAND (init, 0);"}, {"sha": "b93b67523abb2564c2ddcbed849ea8e1e2f9fc56", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "patch": "@@ -1,3 +1,9 @@\n+2001-04-24  Nathan Sidwell <nathan@codesourcery.com>\n+\n+\t* gcc.dg/c99-func-2.c: Remove xfail.\n+\t* gcc.dg/c99-func-3.c: Remove xfail.\n+\t* gcc.dg/c99-func-4.c: Remove xfail.\n+\n 2001-04-23  Zack Weinberg  <zackw@stanford.edu>\n \n \t* gcc.c-torture/execute/20010124-1.c: No longer expected to fail."}, {"sha": "d6a6f243f91293bdf747e07124257df8052d8bd0", "filename": "gcc/testsuite/gcc.dg/c99-func-2.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-func-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-func-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-func-2.c?ref=0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "patch": "@@ -6,6 +6,5 @@\n void\n foo (void)\n {\n-  __func__ \"foo\"; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n-  /* { dg-error \"parse error\" \"__func__ not string constant\" { xfail *-*-* } 9 } */\n+  __func__ \"foo\"; /* { dg-error \"parse error\" \"before string constant\" } */\n }"}, {"sha": "f8a06a0e750952aeaea1d21bb68edf1821b41b84", "filename": "gcc/testsuite/gcc.dg/c99-func-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-func-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-func-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-func-3.c?ref=0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "patch": "@@ -1,6 +1,6 @@\n /* Test for C99 __func__: not merging with string literals.  */\n /* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n-/* { dg-do run { xfail *-*-* } } */\n+/* { dg-do run } */\n /* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n \n extern void abort (void);"}, {"sha": "10ec19566f8762ae0e918ef97b3cad02efa41822", "filename": "gcc/testsuite/gcc.dg/c99-func-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-func-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba8a114c724d36034e8996eefb7c94d4fe8aed0/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-func-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-func-4.c?ref=0ba8a114c724d36034e8996eefb7c94d4fe8aed0", "patch": "@@ -6,5 +6,5 @@\n void\n foo (void)\n {\n-  char *p = __func__; /* { dg-error \"discards\" \"__func__ pointer to const\" { xfail *-*-* } } */\n+  char *p = __func__; /* { dg-error \"discards\" \"__func__ pointer to const\" } */\n }"}]}