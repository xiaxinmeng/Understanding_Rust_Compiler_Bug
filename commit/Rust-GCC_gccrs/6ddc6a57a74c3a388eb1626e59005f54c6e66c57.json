{"sha": "6ddc6a57a74c3a388eb1626e59005f54c6e66c57", "node_id": "C_kwDOANBUbNoAKDZkZGM2YTU3YTc0YzNhMzg4ZWIxNjI2ZTU5MDA1ZjU0YzZlNjZjNTc", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-10T12:31:01Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-10T12:31:01Z"}, "message": "vect: Keep scalar costs around longer\n\nThe scalar costs for a loop are fleeting, with only the final\nsingle_scalar_iteration_cost being kept for later comparison.\nThis patch replaces single_scalar_iteration_cost with the cost\nstructure, so that (with later patches) it's possible for targets\nto examine other target-specific cost properties as well.  This will\nbe done by passing the scalar costs to hooks where appropriate;\ntargets shouldn't try to read the information directly from\nloop_vec_infos.\n\ngcc/\n\t* tree-vectorizer.h (_loop_vec_info::scalar_costs): New member\n\tvariable.\n\t(_loop_vec_info::single_scalar_iteration_cost): Delete.\n\t(LOOP_VINFO_SINGLE_SCALAR_ITERATION_COST): Delete.\n\t(vector_costs::total_cost): New function.\n\t* tree-vect-loop.c (_loop_vec_info::_loop_vec_info): Update\n\tafter above changes.\n\t(_loop_vec_info::~_loop_vec_info): Delete scalar_costs.\n\t(vect_compute_single_scalar_iteration_cost): Store the costs\n\tin loop_vinfo->scalar_costs.\n\t(vect_estimate_min_profitable_iters): Get the scalar cost from\n\tloop_vinfo->scalar_costs.", "tree": {"sha": "ad74173fbfebe5e04d3a357472cc5161ffd1611f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad74173fbfebe5e04d3a357472cc5161ffd1611f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ddc6a57a74c3a388eb1626e59005f54c6e66c57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ddc6a57a74c3a388eb1626e59005f54c6e66c57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ddc6a57a74c3a388eb1626e59005f54c6e66c57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ddc6a57a74c3a388eb1626e59005f54c6e66c57/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5720a9d5beacb558c1ddccbbfef9f9e4f91b14cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5720a9d5beacb558c1ddccbbfef9f9e4f91b14cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5720a9d5beacb558c1ddccbbfef9f9e4f91b14cf"}], "stats": {"total": 34, "additions": 19, "deletions": 15}, "files": [{"sha": "21530126cf63532f79f5466776b5130ed86ec623", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ddc6a57a74c3a388eb1626e59005f54c6e66c57/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ddc6a57a74c3a388eb1626e59005f54c6e66c57/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=6ddc6a57a74c3a388eb1626e59005f54c6e66c57", "patch": "@@ -822,6 +822,7 @@ _loop_vec_info::_loop_vec_info (class loop *loop_in, vec_info_shared *shared)\n     num_iters_unchanged (NULL_TREE),\n     num_iters_assumptions (NULL_TREE),\n     vector_costs (nullptr),\n+    scalar_costs (nullptr),\n     th (0),\n     versioning_threshold (0),\n     vectorization_factor (0),\n@@ -839,7 +840,6 @@ _loop_vec_info::_loop_vec_info (class loop *loop_in, vec_info_shared *shared)\n     ivexpr_map (NULL),\n     scan_map (NULL),\n     slp_unrolling_factor (1),\n-    single_scalar_iteration_cost (0),\n     inner_loop_cost_factor (param_vect_inner_loop_cost_factor),\n     vectorizable (false),\n     can_use_partial_vectors_p (param_vect_partial_vector_usage != 0),\n@@ -931,6 +931,7 @@ _loop_vec_info::~_loop_vec_info ()\n   delete ivexpr_map;\n   delete scan_map;\n   epilogue_vinfos.release ();\n+  delete scalar_costs;\n   delete vector_costs;\n \n   /* When we release an epiloge vinfo that we do not intend to use\n@@ -1292,20 +1293,15 @@ vect_compute_single_scalar_iteration_cost (loop_vec_info loop_vinfo)\n     }\n \n   /* Now accumulate cost.  */\n-  vector_costs *target_cost_data = init_cost (loop_vinfo, true);\n+  loop_vinfo->scalar_costs = init_cost (loop_vinfo, true);\n   stmt_info_for_cost *si;\n   int j;\n   FOR_EACH_VEC_ELT (LOOP_VINFO_SCALAR_ITERATION_COST (loop_vinfo),\n \t\t    j, si)\n-    (void) add_stmt_cost (target_cost_data, si->count,\n+    (void) add_stmt_cost (loop_vinfo->scalar_costs, si->count,\n \t\t\t  si->kind, si->stmt_info, si->vectype,\n \t\t\t  si->misalign, si->where);\n-  unsigned prologue_cost = 0, body_cost = 0, epilogue_cost = 0;\n-  finish_cost (target_cost_data, &prologue_cost, &body_cost,\n-\t       &epilogue_cost);\n-  delete target_cost_data;\n-  LOOP_VINFO_SINGLE_SCALAR_ITERATION_COST (loop_vinfo)\n-    = prologue_cost + body_cost + epilogue_cost;\n+  loop_vinfo->scalar_costs->finish_cost ();\n }\n \n \n@@ -3868,8 +3864,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n      TODO: Consider assigning different costs to different scalar\n      statements.  */\n \n-  scalar_single_iter_cost\n-    = LOOP_VINFO_SINGLE_SCALAR_ITERATION_COST (loop_vinfo);\n+  scalar_single_iter_cost = loop_vinfo->scalar_costs->total_cost ();\n \n   /* Add additional cost for the peeled instructions in prologue and epilogue\n      loop.  (For fully-masked loops there will be no peeling.)"}, {"sha": "a8ce3083c445aca837779490b794a43cd850c49a", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ddc6a57a74c3a388eb1626e59005f54c6e66c57/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ddc6a57a74c3a388eb1626e59005f54c6e66c57/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=6ddc6a57a74c3a388eb1626e59005f54c6e66c57", "patch": "@@ -590,6 +590,9 @@ typedef class _loop_vec_info : public vec_info {\n   /* The cost of the vector code.  */\n   class vector_costs *vector_costs;\n \n+  /* The cost of the scalar code.  */\n+  class vector_costs *scalar_costs;\n+\n   /* Threshold of number of iterations below which vectorization will not be\n      performed. It is calculated from MIN_PROFITABLE_ITERS and\n      param_min_vect_loop_bound.  */\n@@ -721,9 +724,6 @@ typedef class _loop_vec_info : public vec_info {\n      applied to the loop, i.e., no unrolling is needed, this is 1.  */\n   poly_uint64 slp_unrolling_factor;\n \n-  /* Cost of a single scalar iteration.  */\n-  int single_scalar_iteration_cost;\n-\n   /* The factor used to over weight those statements in an inner loop\n      relative to the loop being vectorized.  */\n   unsigned int inner_loop_cost_factor;\n@@ -843,7 +843,6 @@ typedef class _loop_vec_info : public vec_info {\n #define LOOP_VINFO_SCALAR_LOOP_SCALING(L)  (L)->scalar_loop_scaling\n #define LOOP_VINFO_HAS_MASK_STORE(L)       (L)->has_mask_store\n #define LOOP_VINFO_SCALAR_ITERATION_COST(L) (L)->scalar_cost_vec\n-#define LOOP_VINFO_SINGLE_SCALAR_ITERATION_COST(L) (L)->single_scalar_iteration_cost\n #define LOOP_VINFO_ORIG_LOOP_INFO(L)       (L)->orig_loop_info\n #define LOOP_VINFO_SIMD_IF_COND(L)         (L)->simd_if_cond\n #define LOOP_VINFO_INNER_LOOP_COST_FACTOR(L) (L)->inner_loop_cost_factor\n@@ -1438,6 +1437,7 @@ class vector_costs\n   unsigned int body_cost () const;\n   unsigned int epilogue_cost () const;\n   unsigned int outside_cost () const;\n+  unsigned int total_cost () const;\n \n protected:\n   unsigned int record_stmt_cost (stmt_vec_info, vect_cost_model_location,\n@@ -1508,6 +1508,15 @@ vector_costs::outside_cost () const\n   return prologue_cost () + epilogue_cost ();\n }\n \n+/* Return the cost of the prologue, body and epilogue code\n+   (in abstract units).  */\n+\n+inline unsigned int\n+vector_costs::total_cost () const\n+{\n+  return body_cost () + outside_cost ();\n+}\n+\n #define VECT_MAX_COST 1000\n \n /* The maximum number of intermediate steps required in multi-step type"}]}