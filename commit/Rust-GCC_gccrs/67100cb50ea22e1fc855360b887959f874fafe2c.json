{"sha": "67100cb50ea22e1fc855360b887959f874fafe2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjcxMDBjYjUwZWEyMmUxZmM4NTUzNjBiODg3OTU5Zjg3NGZhZmUyYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-11-13T17:57:06Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-11-13T17:57:06Z"}, "message": "openmp: Support allocate for C/C++ array section reductions\n\nThis adds allocate clause support for array section reductions.\nFurthermore, it fixes one bug that would cause inscan reductions with\nallocate to be rejected by C, and for now just ignores allocate for\ninscan/task reductions, that will need slightly more work.\n\n2020-11-13  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/\n\t* omp-low.c (scan_sharing_clauses): For now remove for reduction\n\tclauses with inscan or task modifiers decl from allocate_map.\n\t(lower_private_allocate): Handle TYPE_P (new_var).\n\t(lower_rec_input_clauses): Handle allocate clause for C/C++ array\n\treductions.\ngcc/c/\n\t* c-typeck.c (c_finish_omp_clauses): Don't clear\n\tOMP_CLAUSE_REDUCTION_INSCAN unless reduction_seen == -2.\nlibgomp/\n\t* testsuite/libgomp.c-c++-common/allocate-1.c (foo): Add tests\n\tfor array reductions.\n\t(main): Adjust foo callers.", "tree": {"sha": "8ef9baeb007dcce1c7d132966f7d819e6ce2ab72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ef9baeb007dcce1c7d132966f7d819e6ce2ab72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67100cb50ea22e1fc855360b887959f874fafe2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67100cb50ea22e1fc855360b887959f874fafe2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67100cb50ea22e1fc855360b887959f874fafe2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67100cb50ea22e1fc855360b887959f874fafe2c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e97d6443f0a862ce9b798084499635914e3b8c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e97d6443f0a862ce9b798084499635914e3b8c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e97d6443f0a862ce9b798084499635914e3b8c6"}], "stats": {"total": 112, "additions": 86, "deletions": 26}, "files": [{"sha": "26a5f7128d2d53dc824a69d103684e63285a05df", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67100cb50ea22e1fc855360b887959f874fafe2c/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67100cb50ea22e1fc855360b887959f874fafe2c/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=67100cb50ea22e1fc855360b887959f874fafe2c", "patch": "@@ -15199,7 +15199,8 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t      OMP_CLAUSE_LINEAR_STEP (c));\n \t    remove = true;\n \t  }\n-\telse if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+\telse if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t\t && reduction_seen == -2)\n \t  OMP_CLAUSE_REDUCTION_INSCAN (c) = 0;\n \n \tif (remove)"}, {"sha": "eec34818f1be107a557b5511c76142ffb5099f82", "filename": "gcc/omp-low.c", "status": "modified", "additions": 53, "deletions": 19, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67100cb50ea22e1fc855360b887959f874fafe2c/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67100cb50ea22e1fc855360b887959f874fafe2c/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=67100cb50ea22e1fc855360b887959f874fafe2c", "patch": "@@ -1197,6 +1197,14 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t  if (is_oacc_parallel_or_serial (ctx) || is_oacc_kernels (ctx))\n \t    ctx->local_reduction_clauses\n \t      = tree_cons (NULL, c, ctx->local_reduction_clauses);\n+\t  if ((OMP_CLAUSE_REDUCTION_INSCAN (c)\n+\t       || OMP_CLAUSE_REDUCTION_TASK (c)) && ctx->allocate_map)\n+\t    {\n+\t      tree decl = OMP_CLAUSE_DECL (c);\n+\t      /* For now.  */\n+\t      if (ctx->allocate_map->get (decl))\n+\t\tctx->allocate_map->remove (decl);\n+\t    }\n \t  /* FALLTHRU */\n \n \tcase OMP_CLAUSE_IN_REDUCTION:\n@@ -4392,13 +4400,17 @@ lower_private_allocate (tree var, tree new_var, tree &allocator,\n   if (allocator)\n     return false;\n   gcc_assert (allocate_ptr == NULL_TREE);\n-  if (ctx->allocate_map && DECL_P (new_var))\n+  if (ctx->allocate_map\n+      && (DECL_P (new_var) || (TYPE_P (new_var) && size)))\n     if (tree *allocatorp = ctx->allocate_map->get (var))\n       allocator = *allocatorp;\n   if (allocator == NULL_TREE)\n     return false;\n   if (!is_ref && omp_is_reference (var))\n-    return false;\n+    {\n+      allocator = NULL_TREE;\n+      return false;\n+    }\n \n   if (TREE_CODE (allocator) != INTEGER_CST)\n     allocator = build_outer_var_ref (allocator, ctx);\n@@ -4410,19 +4422,24 @@ lower_private_allocate (tree var, tree new_var, tree &allocator,\n       allocator = var;\n     }\n \n-  tree ptr_type, align, sz;\n-  if (is_ref)\n+  tree ptr_type, align, sz = size;\n+  if (TYPE_P (new_var))\n+    {\n+      ptr_type = build_pointer_type (new_var);\n+      align = build_int_cst (size_type_node, TYPE_ALIGN_UNIT (new_var));\n+    }\n+  else if (is_ref)\n     {\n       ptr_type = build_pointer_type (TREE_TYPE (TREE_TYPE (new_var)));\n       align = build_int_cst (size_type_node,\n \t\t\t     TYPE_ALIGN_UNIT (TREE_TYPE (ptr_type)));\n-      sz = size;\n     }\n   else\n     {\n       ptr_type = build_pointer_type (TREE_TYPE (new_var));\n       align = build_int_cst (size_type_node, DECL_ALIGN_UNIT (new_var));\n-      sz = fold_convert (size_type_node, DECL_SIZE_UNIT (new_var));\n+      if (sz == NULL_TREE)\n+\tsz = fold_convert (size_type_node, DECL_SIZE_UNIT (new_var));\n     }\n   if (TREE_CODE (sz) != INTEGER_CST)\n     {\n@@ -4855,7 +4872,23 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t      tree type = TREE_TYPE (d);\n \t      gcc_assert (TREE_CODE (type) == ARRAY_TYPE);\n \t      tree v = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n+\t      tree sz = v;\n \t      const char *name = get_name (orig_var);\n+\t      if (pass != 3 && !TREE_CONSTANT (v))\n+\t\t{\n+\t\t  tree t = maybe_lookup_decl (v, ctx);\n+\t\t  if (t)\n+\t\t    v = t;\n+\t\t  else\n+\t\t    v = maybe_lookup_decl_in_outer_ctx (v, ctx);\n+\t\t  gimplify_expr (&v, ilist, NULL, is_gimple_val, fb_rvalue);\n+\t\t  t = fold_build2_loc (clause_loc, PLUS_EXPR,\n+\t\t\t\t       TREE_TYPE (v), v,\n+\t\t\t\t       build_int_cst (TREE_TYPE (v), 1));\n+\t\t  sz = fold_build2_loc (clause_loc, MULT_EXPR,\n+\t\t\t\t\tTREE_TYPE (v), t,\n+\t\t\t\t\tTYPE_SIZE_UNIT (TREE_TYPE (type)));\n+\t\t}\n \t      if (pass == 3)\n \t\t{\n \t\t  tree xv = create_tmp_var (ptr_type_node);\n@@ -4913,6 +4946,13 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  gimplify_assign (cond, x, ilist);\n \t\t  x = xv;\n \t\t}\n+\t      else if (lower_private_allocate (var, type, allocator,\n+\t\t\t\t\t       allocate_ptr, ilist, ctx,\n+\t\t\t\t\t       true,\n+\t\t\t\t\t       TREE_CONSTANT (v)\n+\t\t\t\t\t       ? TYPE_SIZE_UNIT (type)\n+\t\t\t\t\t       : sz))\n+\t\tx = allocate_ptr;\n \t      else if (TREE_CONSTANT (v))\n \t\t{\n \t\t  x = create_tmp_var_raw (type, name);\n@@ -4924,20 +4964,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t{\n \t\t  tree atmp\n \t\t    = builtin_decl_explicit (BUILT_IN_ALLOCA_WITH_ALIGN);\n-\t\t  tree t = maybe_lookup_decl (v, ctx);\n-\t\t  if (t)\n-\t\t    v = t;\n-\t\t  else\n-\t\t    v = maybe_lookup_decl_in_outer_ctx (v, ctx);\n-\t\t  gimplify_expr (&v, ilist, NULL, is_gimple_val, fb_rvalue);\n-\t\t  t = fold_build2_loc (clause_loc, PLUS_EXPR,\n-\t\t\t\t       TREE_TYPE (v), v,\n-\t\t\t\t       build_int_cst (TREE_TYPE (v), 1));\n-\t\t  t = fold_build2_loc (clause_loc, MULT_EXPR,\n-\t\t\t\t       TREE_TYPE (v), t,\n-\t\t\t\t       TYPE_SIZE_UNIT (TREE_TYPE (type)));\n \t\t  tree al = size_int (TYPE_ALIGN (TREE_TYPE (type)));\n-\t\t  x = build_call_expr_loc (clause_loc, atmp, 2, t, al);\n+\t\t  x = build_call_expr_loc (clause_loc, atmp, 2, sz, al);\n \t\t}\n \n \t      tree ptype = build_pointer_type (TREE_TYPE (type));\n@@ -5199,6 +5227,12 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  gimple_seq_add_stmt (dlist, g);\n \t\t  gimple_seq_add_stmt (dlist, gimple_build_label (end2));\n \t\t}\n+\t      if (allocator)\n+\t\t{\n+\t\t  tree f = builtin_decl_explicit (BUILT_IN_GOMP_FREE);\n+\t\t  g = gimple_build_call (f, 2, allocate_ptr, allocator);\n+\t\t  gimple_seq_add_stmt (dlist, g);\n+\t\t}\n \t      continue;\n \t    }\n \t  else if (pass == 2)"}, {"sha": "5dd51b5a2b96504560b9e111af5ec092e8d2137a", "filename": "libgomp/testsuite/libgomp.c-c++-common/allocate-1.c", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67100cb50ea22e1fc855360b887959f874fafe2c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fallocate-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67100cb50ea22e1fc855360b887959f874fafe2c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fallocate-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fallocate-1.c?ref=67100cb50ea22e1fc855360b887959f874fafe2c", "patch": "@@ -3,15 +3,20 @@\n #include <stdint.h>\n \n void\n-foo (int x, omp_allocator_handle_t h, int fl)\n+foo (int x, int *p, int *q, int px, omp_allocator_handle_t h, int fl)\n {\n   int y = 0, r = 0, i, i1, l, l2[4], l3, n = 8;\n   int i2, j2, n2 = 9, l4;\n   int i3, j3, n3 = 10, l5;\n   int i4, j4, n4 = 11, l6;\n   int i5;\n   int v[x], w[x];\n+  int r2[4] = { 0, 0, 0, 0 };\n   int xo = x;\n+  for (i = 0; i < 4; i++)\n+    p[i] = 0;\n+  for (i = 0; i < 3; i++)\n+    q[i] = 0;\n   for (i = 0; i < x; i++)\n     w[i] = i;\n   #pragma omp parallel private (y, v) firstprivate (x) allocate (x, y, v)\n@@ -117,6 +122,21 @@ foo (int x, omp_allocator_handle_t h, int fl)\n \tif ((fl & 2) && (((uintptr_t) &i5) & 63) != 0)\n \t  abort ();\n       }\n+    #pragma omp for reduction(+:p[2:px], q[:3], r2) allocate(h: p, q, r2)\n+    for (i = 0; i < 32; i++)\n+      {\n+\tp[2] += i;\n+\tp[3] += 2 * i;\n+\tq[0] += 3 * i;\n+\tq[2] += 4 * i;\n+\tr2[0] += 5 * i;\n+\tr2[3] += 6 * i;\n+\t/* Can't really rely on alignment of &p[0], the implementation could\n+\t   allocate the whole array or do what GCC does and allocate only part\n+\t   of it.  */\n+\tif ((fl & 1) && (((uintptr_t) &q[0] | (uintptr_t) &r2[0]) & 63) != 0)\n+\t  abort ();\n+      }\n   }\n   if (r != 64 * 63 / 2 || l != 63 || n != 8 + 16 * 64)\n     abort ();\n@@ -130,6 +150,10 @@ foo (int x, omp_allocator_handle_t h, int fl)\n     abort ();\n   if (i5 != 19)\n     abort ();\n+  if (p[2] != (32 * 31) / 2 || p[3] != 2 * (32 * 31) / 2\n+      || q[0] != 3 * (32 * 31) / 2 || q[2] != 4 * (32 * 31) / 2\n+      || r2[0] != 5 * (32 * 31) / 2 || r2[3] != 6 * (32 * 31) / 2)\n+    abort ();\n }\n \n void\n@@ -239,15 +263,16 @@ main ()\n \t{ omp_atk_fallback, omp_atv_null_fb } };\n   omp_allocator_handle_t a\n     = omp_init_allocator (omp_default_mem_space, 2, traits);\n+  int p[4], q[3];\n   if (a == omp_null_allocator)\n     abort ();\n   omp_set_default_allocator (omp_default_mem_alloc);\n-  foo (42, omp_null_allocator, 0);\n-  foo (42, omp_default_mem_alloc, 0);\n-  foo (42, a, 1);\n+  foo (42, p, q, 2, omp_null_allocator, 0);\n+  foo (42, p, q, 2, omp_default_mem_alloc, 0);\n+  foo (42, p, q, 2, a, 1);\n   omp_set_default_allocator (a);\n-  foo (42, omp_null_allocator, 3);\n-  foo (42, omp_default_mem_alloc, 2);\n+  foo (42, p, q, 2, omp_null_allocator, 3);\n+  foo (42, p, q, 2, omp_default_mem_alloc, 2);\n   bar (42, a);\n   omp_destroy_allocator (a);\n   return 0;"}]}