{"sha": "f9325b0364fdef06a5168eb809c6e8ae0bf658a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkzMjViMDM2NGZkZWYwNmE1MTY4ZWI4MDljNmU4YWUwYmY2NThhMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-08-06T08:33:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-08-06T08:33:21Z"}, "message": "g-comlin.adb (Define_Switch, [...]): New.\n\n2008-08-06  Jerome Lambourg  <lambourg@adacore.com>\n\n\t* g-comlin.adb (Define_Switch, Get_Switches): New.\n\t(Can_Have_Parameter, Require_Parameter, Actual_Switch): New, used when\n\tungrouping switches.\n\t(For_Each_Simple_Switch): Allow more control over parameters handling.\n\tThis generic method now allows ungrouping of switches with parameters\n\tand switches with more than one letter after the prefix.\n\t(Set_Command_Line): Take care of switches that are prefixed with a\n\tswitch handling parameters without delimiter (-gnatya and -gnaty3 for\n\texample).\n\t(Add_Switch, Remove_Switch): Handle parameters possibly present inside\n\ta group, as in gnaty3aM80 (3 and 80 are parameters). Report status of\n\tthe operation.\n\t(Start, Alias_Switches, Group_Switches): Take care of parameters\n\tpossibly present inside a group.\n\n\t* g-comlin.ads (Define_Switch): New method used to define a list of\n\texpected switches, that are necessary for correctly ungrouping switches\n\twith more that one character after the prefix.\n\t(Get_Switches): Method that builds a getopt string from the list of\n\tswitches as set previously by Define_Switch.\n\t(Add_Switch, Remove_Switch): New versions of the methods, reporting the\n\tstatus of the operation. Also allow the removal of switches with\n\tparameters only.\n\t(Command_Line_Configuration_Record): Maintain a list of expected\n\tswitches.\n\nFrom-SVN: r138775", "tree": {"sha": "bf253ff6c0ad14f839a0965ef719d58c602a7055", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf253ff6c0ad14f839a0965ef719d58c602a7055"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9325b0364fdef06a5168eb809c6e8ae0bf658a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9325b0364fdef06a5168eb809c6e8ae0bf658a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9325b0364fdef06a5168eb809c6e8ae0bf658a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9325b0364fdef06a5168eb809c6e8ae0bf658a0/comments", "author": null, "committer": null, "parents": [{"sha": "1c5a12b418a7d8db0384c83dd1ac47adb80581c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c5a12b418a7d8db0384c83dd1ac47adb80581c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c5a12b418a7d8db0384c83dd1ac47adb80581c9"}], "stats": {"total": 568, "additions": 504, "deletions": 64}, "files": [{"sha": "9b2088bd08bf14fc7e3f16fe15fe6cb36714172f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9325b0364fdef06a5168eb809c6e8ae0bf658a0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9325b0364fdef06a5168eb809c6e8ae0bf658a0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f9325b0364fdef06a5168eb809c6e8ae0bf658a0", "patch": "@@ -1,3 +1,63 @@\n+2008-08-06  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* xnmake.adb: Use new XUtil package for platform independent text\n+\toutput.\n+\n+2008-08-06  Vincent Celier  <celier@adacore.com>\n+\n+\t* gnat_ugn.texi: Document compiler switch -gnateG\n+\n+2008-08-06  Quentin Ochem  <ochem@adacore.com>\n+\n+\t* s-stausa.adb (Fill_Stack): Fixed pragma assert and top pattern mark\n+\tin the case of an empty pattern size.\n+\t(Compute_Result): Do not do any computation in the case of an empty\n+\tpattern size.\n+\t(Report_Result): Fixed computation of the overflow guard.\n+\n+2008-08-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* g-awk.adb (Finalize): Do not use directly objects of the type in the\n+\tfinalization routine to prevent elaboration order anomalies in new\n+\tfinalization scheme.\n+\n+2008-08-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Find_Type_Name): protect against duplicate incomplete\n+\tdeclaration for the same type.\n+\n+2008-08-06  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem.adb: Minor rewording (comment)\n+\n+2008-08-06  Jerome Lambourg  <lambourg@adacore.com>\n+\n+\t* g-comlin.adb (Define_Switch, Get_Switches): New.\n+\t(Can_Have_Parameter, Require_Parameter, Actual_Switch): New, used when\n+\tungrouping switches.\n+\t(For_Each_Simple_Switch): Allow more control over parameters handling.\n+\tThis generic method now allows ungrouping of switches with parameters\n+\tand switches with more than one letter after the prefix.\n+\t(Set_Command_Line): Take care of switches that are prefixed with a\n+\tswitch handling parameters without delimiter (-gnatya and -gnaty3 for\n+\texample).\n+\t(Add_Switch, Remove_Switch): Handle parameters possibly present inside\n+\ta group, as in gnaty3aM80 (3 and 80 are parameters). Report status of\n+\tthe operation.\n+\t(Start, Alias_Switches, Group_Switches): Take care of parameters\n+\tpossibly present inside a group.\n+\n+\t* g-comlin.ads (Define_Switch): New method used to define a list of\n+\texpected switches, that are necessary for correctly ungrouping switches\n+\twith more that one character after the prefix.\n+\t(Get_Switches): Method that builds a getopt string from the list of\n+\tswitches as set previously by Define_Switch.\n+\t(Add_Switch, Remove_Switch): New versions of the methods, reporting the\n+\tstatus of the operation. Also allow the removal of switches with\n+\tparameters only.\n+\t(Command_Line_Configuration_Record): Maintain a list of expected\n+\tswitches.\n+\n 2008-08-06  Doug Rupp  <rupp@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_param): Force 32bit descriptor if"}, {"sha": "221b3a3c4e31c37c0f4f8bd7dcb96f29317b3555", "filename": "gcc/ada/g-comlin.adb", "status": "modified", "additions": 398, "deletions": 60, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9325b0364fdef06a5168eb809c6e8ae0bf658a0/gcc%2Fada%2Fg-comlin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9325b0364fdef06a5168eb809c6e8ae0bf658a0/gcc%2Fada%2Fg-comlin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.adb?ref=f9325b0364fdef06a5168eb809c6e8ae0bf658a0", "patch": "@@ -111,11 +111,22 @@ package body GNAT.Command_Line is\n       Str  : String_Access);\n    --  Append a new element to Line\n \n+   function Can_Have_Parameter (S : String) return Boolean;\n+   --  Tell if S can have a parameter.\n+\n+   function Require_Parameter (S : String) return Boolean;\n+   --  Tell if S requires a paramter.\n+\n+   function Actual_Switch (S : String) return String;\n+   --  Remove any possible trailing '!', ':', '?' and '='\n+\n    generic\n-      with procedure Callback (Simple_Switch : String);\n+      with procedure Callback (Simple_Switch : String; Parameter : String);\n    procedure For_Each_Simple_Switch\n-     (Cmd    : Command_Line;\n-      Switch : String);\n+     (Cmd       : Command_Line;\n+      Switch    : String;\n+      Parameter : String := \"\";\n+      Unalias   : Boolean := True);\n    --  Breaks Switch into as simple switches as possible (expanding aliases and\n    --  ungrouping common prefixes when possible), and call Callback for each of\n    --  these.\n@@ -1089,6 +1100,22 @@ package body GNAT.Command_Line is\n       Append (Config.Prefixes, new String'(Prefix));\n    end Define_Prefix;\n \n+   -------------------\n+   -- Define_Switch --\n+   -------------------\n+\n+   procedure Define_Switch\n+     (Config : in out Command_Line_Configuration;\n+      Switch : String)\n+   is\n+   begin\n+      if Config = null then\n+         Config := new Command_Line_Configuration_Record;\n+      end if;\n+\n+      Append (Config.Switches, new String'(Switch));\n+   end Define_Switch;\n+\n    --------------------\n    -- Define_Section --\n    --------------------\n@@ -1105,6 +1132,35 @@ package body GNAT.Command_Line is\n       Append (Config.Sections, new String'(Section));\n    end Define_Section;\n \n+   ------------------\n+   -- Get_Switches --\n+   ------------------\n+\n+   function Get_Switches\n+     (Config      : Command_Line_Configuration;\n+      Switch_Char : Character)\n+      return String\n+   is\n+      Ret : Ada.Strings.Unbounded.Unbounded_String;\n+      use type Ada.Strings.Unbounded.Unbounded_String;\n+   begin\n+      if Config = null or else Config.Switches = null then\n+         return \"\";\n+      end if;\n+\n+      for J in Config.Switches'Range loop\n+         if Config.Switches (J) (Config.Switches (J)'First) = Switch_Char then\n+            Ret := Ret & \" \" &\n+              Config.Switches (J)\n+                (Config.Switches (J)'First + 1 .. Config.Switches (J)'Last);\n+         else\n+            Ret := Ret & \" \" & Config.Switches (J).all;\n+         end if;\n+      end loop;\n+\n+      return Ada.Strings.Unbounded.To_String (Ret);\n+   end Get_Switches;\n+\n    -----------------------\n    -- Set_Configuration --\n    -----------------------\n@@ -1203,16 +1259,33 @@ package body GNAT.Command_Line is\n \n                   if not Is_Section then\n                      if Section = null then\n-                        Add_Switch\n-                          (Cmd, Sw,\n-                           Parameter (Parser),\n-                           Separator (Parser));\n+                        --  Workaround some weird cases: some switches may\n+                        --  expect parameters, but have the same value as\n+                        --  longer switches: -gnaty3 (-gnaty, parameter=3) and\n+                        --  -gnatya (-gnatya, no parameter).\n+                        --  So we are calling add_switch here with parameter\n+                        --  attached. This will be anyway correctly handled by\n+                        --  Add_Switch if -gnaty3 is actually furnished.\n+                        if Separator (Parser) = ASCII.NUL then\n+                           Add_Switch\n+                             (Cmd, Sw & Parameter (Parser), \"\");\n+                        else\n+                           Add_Switch\n+                             (Cmd, Sw, Parameter (Parser), Separator (Parser));\n+                        end if;\n                      else\n-                        Add_Switch\n-                          (Cmd, Sw,\n-                           Parameter (Parser),\n-                           Separator (Parser),\n-                           Section.all);\n+                        if Separator (Parser) = ASCII.NUL then\n+                           Add_Switch\n+                             (Cmd, Sw & Parameter (Parser), \"\",\n+                              Separator (Parser),\n+                              Section.all);\n+                        else\n+                           Add_Switch\n+                             (Cmd, Sw,\n+                              Parameter (Parser),\n+                              Separator (Parser),\n+                              Section.all);\n+                        end if;\n                      end if;\n                   end if;\n                end;\n@@ -1250,14 +1323,157 @@ package body GNAT.Command_Line is\n         and then Type_Str (Index .. Index + Substring'Length - 1) = Substring;\n    end Looking_At;\n \n+   ------------------------\n+   -- Can_Have_Parameter --\n+   ------------------------\n+\n+   function Can_Have_Parameter (S : String) return Boolean is\n+   begin\n+      if S'Length <= 1 then\n+         return False;\n+      end if;\n+\n+      case S (S'Last) is\n+         when '!' | ':' | '?' | '=' =>\n+            return True;\n+         when others =>\n+            return False;\n+      end case;\n+   end Can_Have_Parameter;\n+\n+   -----------------------\n+   -- Require_Parameter --\n+   -----------------------\n+\n+   function Require_Parameter (S : String) return Boolean is\n+   begin\n+      if S'Length <= 1 then\n+         return False;\n+      end if;\n+\n+      case S (S'Last) is\n+         when '!' | ':' | '=' =>\n+            return True;\n+         when others =>\n+            return False;\n+      end case;\n+   end Require_Parameter;\n+\n+   -------------------\n+   -- Actual_Switch --\n+   -------------------\n+\n+   function Actual_Switch (S : String) return String is\n+   begin\n+      if S'Length <= 1 then\n+         return S;\n+      end if;\n+\n+      case S (S'Last) is\n+         when '!' | ':' | '?' | '=' =>\n+            return S (S'First .. S'Last - 1);\n+         when others =>\n+            return S;\n+      end case;\n+   end Actual_Switch;\n+\n    ----------------------------\n    -- For_Each_Simple_Switch --\n    ----------------------------\n \n    procedure For_Each_Simple_Switch\n-     (Cmd    : Command_Line;\n-      Switch : String)\n+     (Cmd       : Command_Line;\n+      Switch    : String;\n+      Parameter : String := \"\";\n+      Unalias   : Boolean := True)\n    is\n+      function Group_Analysis\n+        (Prefix : String;\n+         Group  : String) return Boolean;\n+      --  Perform the analysis of a group of switches.\n+\n+      --------------------\n+      -- Group_Analysis --\n+      --------------------\n+\n+      function Group_Analysis\n+        (Prefix : String;\n+         Group  : String) return Boolean\n+      is\n+         Idx   : Natural := Group'First;\n+         Found : Boolean;\n+      begin\n+         while Idx <= Group'Last loop\n+            Found := False;\n+\n+            for S in Cmd.Config.Switches'Range loop\n+               declare\n+                  Sw              : constant String :=\n+                                      Actual_Switch\n+                                        (Cmd.Config.Switches (S).all);\n+                  Full            : constant String :=\n+                                      Prefix & Group (Idx .. Group'Last);\n+                  Last            : Natural;\n+                  Param           : Natural;\n+\n+               begin\n+                  if Sw'Length >= Prefix'Length\n+                  --  Verify that sw starts with Prefix\n+                    and then Looking_At (Sw, Sw'First, Prefix)\n+                  --  Verify that the group starts with sw\n+                    and then Looking_At (Full, Full'First, Sw)\n+                  then\n+                     Last := Idx + Sw'Length - Prefix'Length - 1;\n+                     Param := Last + 1;\n+\n+                     if Can_Have_Parameter (Cmd.Config.Switches (S).all) then\n+                        --  Include potential parameter to the recursive call.\n+                        --  Only numbers are allowed.\n+                        while Last < Group'Last\n+                          and then Group (Last + 1) in '0' .. '9'\n+                        loop\n+                           Last := Last + 1;\n+                        end loop;\n+                     end if;\n+\n+                     if not Require_Parameter (Cmd.Config.Switches (S).all)\n+                       or else Last >= Param\n+                     then\n+                        if Idx = Group'First and then Last = Group'Last then\n+                           --  The group only concerns a single switch. Do not\n+                           --  perform recursive call.\n+                           return False;\n+                        end if;\n+\n+                        Found := True;\n+\n+                        --  Recursive call, using the detected parameter if any\n+                        if Last >= Param then\n+                           For_Each_Simple_Switch\n+                             (Cmd,\n+                              Prefix & Group (Idx .. Param - 1),\n+                              Group (Param .. Last));\n+                        else\n+                           For_Each_Simple_Switch\n+                             (Cmd, Prefix & Group (Idx .. Last), \"\");\n+                        end if;\n+\n+                        Idx := Last + 1;\n+                        exit;\n+                     end if;\n+                  end if;\n+               end;\n+            end loop;\n+\n+            if not Found then\n+               For_Each_Simple_Switch (Cmd, Prefix & Group (Idx), \"\");\n+               Idx := Idx + 1;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end Group_Analysis;\n+\n    begin\n       --  Are we adding a switch that can in fact be expanded through aliases ?\n       --  If yes, we add separately each of its expansion.\n@@ -1267,13 +1483,16 @@ package body GNAT.Command_Line is\n       --  in which we do things here, the expansion of the alias will itself\n       --  be checked for a common prefix and further split into simple switches\n \n-      if Cmd.Config /= null\n+      if Unalias\n+        and then Cmd.Config /= null\n         and then Cmd.Config.Aliases /= null\n       then\n          for A in Cmd.Config.Aliases'Range loop\n-            if Cmd.Config.Aliases (A).all = Switch then\n+            if Cmd.Config.Aliases (A).all = Switch\n+              and then Parameter = \"\"\n+            then\n                For_Each_Simple_Switch\n-                 (Cmd, Cmd.Config.Expansions (A).all);\n+                 (Cmd, Cmd.Config.Expansions (A).all, \"\");\n                return;\n             end if;\n          end loop;\n@@ -1291,19 +1510,31 @@ package body GNAT.Command_Line is\n                 (Switch, Switch'First, Cmd.Config.Prefixes (P).all)\n             then\n                --  Alias expansion will be done recursively\n+               if Cmd.Config.Switches = null then\n+                  for S in Switch'First + Cmd.Config.Prefixes (P)'Length\n+                            .. Switch'Last\n+                  loop\n+                     For_Each_Simple_Switch\n+                       (Cmd, Cmd.Config.Prefixes (P).all & Switch (S), \"\");\n+                  end loop;\n \n-               for S in Switch'First + Cmd.Config.Prefixes (P)'Length\n-                          .. Switch'Last\n-               loop\n-                  For_Each_Simple_Switch\n-                    (Cmd, Cmd.Config.Prefixes (P).all & Switch (S));\n-               end loop;\n-               return;\n+                  return;\n+\n+               elsif Group_Analysis\n+                 (Cmd.Config.Prefixes (P).all,\n+                  Switch\n+                    (Switch'First + Cmd.Config.Prefixes (P)'Length\n+                      .. Switch'Last))\n+               then\n+                  --  Recursive calls already done on each switch of the\n+                  --  group. Let's return to not call Callback.\n+                  return;\n+               end if;\n             end if;\n          end loop;\n       end if;\n \n-      Callback (Switch);\n+      Callback (Switch, Parameter);\n    end For_Each_Simple_Switch;\n \n    ----------------\n@@ -1317,40 +1548,63 @@ package body GNAT.Command_Line is\n       Separator : Character := ' ';\n       Section   : String := \"\")\n    is\n-      procedure Add_Simple_Switch (Simple : String);\n+      Success : Boolean;\n+      pragma Unreferenced (Success);\n+   begin\n+      Add_Switch (Cmd, Switch, Parameter, Separator, Section, Success);\n+   end Add_Switch;\n+\n+   ----------------\n+   -- Add_Switch --\n+   ----------------\n+\n+   procedure Add_Switch\n+     (Cmd       : in out Command_Line;\n+      Switch    : String;\n+      Parameter : String := \"\";\n+      Separator : Character := ' ';\n+      Section   : String := \"\";\n+      Success   : out Boolean)\n+   is\n+      procedure Add_Simple_Switch (Simple : String; Param : String);\n       --  Add a new switch that has had all its aliases expanded, and switches\n       --  ungrouped. We know there is no more aliases in Switches\n \n       -----------------------\n       -- Add_Simple_Switch --\n       -----------------------\n \n-      procedure Add_Simple_Switch (Simple : String) is\n+      procedure Add_Simple_Switch (Simple : String; Param : String) is\n       begin\n          if Cmd.Expanded = null then\n             Cmd.Expanded := new Argument_List'(1 .. 1 => new String'(Simple));\n-            if Parameter = \"\" then\n-               Cmd.Params := new Argument_List'(1 .. 1 => null);\n-            else\n+\n+            if Param /= \"\" then\n                Cmd.Params := new Argument_List'\n-                 (1 .. 1 => new String'(Separator & Parameter));\n+                 (1 .. 1 => new String'(Separator & Param));\n+\n+            else\n+               Cmd.Params := new Argument_List'(1 .. 1 => null);\n             end if;\n+\n             if Section = \"\" then\n                Cmd.Sections := new Argument_List'(1 .. 1 => null);\n+\n             else\n                Cmd.Sections := new Argument_List'\n                  (1 .. 1 => new String'(Section));\n             end if;\n+\n          else\n             --  Do we already have this switch ?\n \n             for C in Cmd.Expanded'Range loop\n                if Cmd.Expanded (C).all = Simple\n                  and then\n-                   ((Cmd.Params (C) = null and then Parameter = \"\")\n+                   ((Cmd.Params (C) = null and then Param = \"\")\n                     or else\n                       (Cmd.Params (C) /= null\n-                       and then Cmd.Params (C).all = Separator & Parameter))\n+                       and then Cmd.Params (C).all = Separator & Param))\n                  and then\n                    ((Cmd.Sections (C) = null and then Section = \"\")\n                     or else\n@@ -1361,12 +1615,15 @@ package body GNAT.Command_Line is\n                end if;\n             end loop;\n \n+            --  Inserting at least one switch\n+            Success := True;\n             Append (Cmd.Expanded, new String'(Simple));\n \n-            if Parameter = \"\" then\n-               Append (Cmd.Params, null);\n+            if Param /= \"\" then\n+               Append (Cmd.Params, new String'(Separator & Param));\n+\n             else\n-               Append (Cmd.Params, new String'(Separator & Parameter));\n+               Append (Cmd.Params, null);\n             end if;\n \n             if Section = \"\" then\n@@ -1383,7 +1640,8 @@ package body GNAT.Command_Line is\n    --  Start of processing for Add_Switch\n \n    begin\n-      Add_Simple_Switches (Cmd, Switch);\n+      Success := False;\n+      Add_Simple_Switches (Cmd, Switch, Parameter);\n       Free (Cmd.Coalesce);\n    end Add_Switch;\n \n@@ -1436,20 +1694,40 @@ package body GNAT.Command_Line is\n    -------------------\n \n    procedure Remove_Switch\n-     (Cmd        : in out Command_Line;\n-      Switch     : String;\n-      Remove_All : Boolean := False;\n-      Section    : String  := \"\")\n+     (Cmd           : in out Command_Line;\n+      Switch        : String;\n+      Remove_All    : Boolean := False;\n+      Has_Parameter : Boolean := False;\n+      Section       : String := \"\")\n    is\n-      procedure Remove_Simple_Switch (Simple : String);\n+      Success : Boolean;\n+      pragma Unreferenced (Success);\n+   begin\n+      Remove_Switch (Cmd, Switch, Remove_All, Has_Parameter, Section, Success);\n+   end Remove_Switch;\n+\n+   -------------------\n+   -- Remove_Switch --\n+   -------------------\n+\n+   procedure Remove_Switch\n+     (Cmd           : in out Command_Line;\n+      Switch        : String;\n+      Remove_All    : Boolean := False;\n+      Has_Parameter : Boolean := False;\n+      Section       : String  := \"\";\n+      Success       : out Boolean)\n+   is\n+      procedure Remove_Simple_Switch (Simple : String; Param : String);\n       --  Removes a simple switch, with no aliasing or grouping\n \n       --------------------------\n       -- Remove_Simple_Switch --\n       --------------------------\n \n-      procedure Remove_Simple_Switch (Simple : String) is\n+      procedure Remove_Simple_Switch (Simple : String; Param : String) is\n          C : Integer;\n+         pragma Unreferenced (Param);\n \n       begin\n          if Cmd.Expanded /= null then\n@@ -1462,10 +1740,12 @@ package body GNAT.Command_Line is\n                              and then Section = \"\")\n                     or else (Cmd.Sections (C) /= null\n                              and then Section = Cmd.Sections (C).all))\n+                 and then (not Has_Parameter or else Cmd.Params (C) /= null)\n                then\n                   Remove (Cmd.Expanded, C);\n                   Remove (Cmd.Params, C);\n                   Remove (Cmd.Sections, C);\n+                  Success := True;\n \n                   if not Remove_All then\n                      return;\n@@ -1484,7 +1764,8 @@ package body GNAT.Command_Line is\n    --  Start of processing for Remove_Switch\n \n    begin\n-      Remove_Simple_Switches (Cmd, Switch);\n+      Success := False;\n+      Remove_Simple_Switches (Cmd, Switch, \"\", Unalias => not Has_Parameter);\n       Free (Cmd.Coalesce);\n    end Remove_Switch;\n \n@@ -1498,14 +1779,14 @@ package body GNAT.Command_Line is\n       Parameter : String;\n       Section   : String  := \"\")\n    is\n-      procedure Remove_Simple_Switch (Simple : String);\n+      procedure Remove_Simple_Switch (Simple : String; Param : String);\n       --  Removes a simple switch, with no aliasing or grouping\n \n       --------------------------\n       -- Remove_Simple_Switch --\n       --------------------------\n \n-      procedure Remove_Simple_Switch (Simple : String) is\n+      procedure Remove_Simple_Switch (Simple : String; Param : String) is\n          C : Integer;\n \n       begin\n@@ -1520,7 +1801,7 @@ package body GNAT.Command_Line is\n                       (Cmd.Sections (C) /= null\n                        and then Section = Cmd.Sections (C).all))\n                  and then\n-                   ((Cmd.Params (C) = null and then Parameter = \"\")\n+                   ((Cmd.Params (C) = null and then Param = \"\")\n                       or else\n                         (Cmd.Params (C) /= null\n                            and then\n@@ -1529,7 +1810,7 @@ package body GNAT.Command_Line is\n \n                              Cmd.Params (C) (Cmd.Params (C)'First + 1\n                                              .. Cmd.Params (C)'Last) =\n-                         Parameter))\n+                           Param))\n                then\n                   Remove (Cmd.Expanded, C);\n                   Remove (Cmd.Params, C);\n@@ -1553,7 +1834,7 @@ package body GNAT.Command_Line is\n    --  Start of processing for Remove_Switch\n \n    begin\n-      Remove_Simple_Switches (Cmd, Switch);\n+      Remove_Simple_Switches (Cmd, Switch, Parameter);\n       Free (Cmd.Coalesce);\n    end Remove_Switch;\n \n@@ -1567,6 +1848,36 @@ package body GNAT.Command_Line is\n       Sections : Argument_List_Access;\n       Params   : Argument_List_Access)\n    is\n+      function Compatible_Parameter (Param : String_Access) return Boolean;\n+      --  Tell if the parameter can be part of a group\n+\n+      --------------------------\n+      -- Compatible_Parameter --\n+      --------------------------\n+\n+      function Compatible_Parameter (Param : String_Access) return Boolean is\n+      begin\n+         if Param = null then\n+            --  No parameter, OK\n+            return True;\n+\n+         elsif Param (Param'First) /= ASCII.NUL then\n+            --  We need parameters without separators...\n+            return False;\n+\n+         else\n+            --  We need number only parameters.\n+            for J in Param'First + 1 .. Param'Last loop\n+               if Param (J) not in '0' .. '9' then\n+                  return False;\n+               end if;\n+            end loop;\n+\n+            return True;\n+         end if;\n+\n+      end Compatible_Parameter;\n+\n       Group   : Ada.Strings.Unbounded.Unbounded_String;\n       First   : Natural;\n       use type Ada.Strings.Unbounded.Unbounded_String;\n@@ -1584,7 +1895,7 @@ package body GNAT.Command_Line is\n \n          for C in Result'Range loop\n             if Result (C) /= null\n-              and then Params (C) = null  --  ignored if has a parameter\n+              and then Compatible_Parameter (Params (C))\n               and then Looking_At\n                 (Result (C).all, Result (C)'First, Cmd.Config.Prefixes (P).all)\n             then\n@@ -1602,7 +1913,14 @@ package body GNAT.Command_Line is\n                     Group &\n                       Result (C)\n                         (Result (C)'First + Cmd.Config.Prefixes (P)'Length ..\n-                         Result (C)'Last);\n+                           Result (C)'Last);\n+\n+                  if Params (C) /= null then\n+                     Group := Group &\n+                       Params (C) (Params (C)'First + 1 .. Params (C)'Last);\n+                     Free (Params (C));\n+                  end if;\n+\n                   if First = 0 then\n                      First := C;\n                   end if;\n@@ -1646,22 +1964,25 @@ package body GNAT.Command_Line is\n       Found : Boolean;\n       First : Natural;\n \n-      procedure Check_Cb (Switch : String);\n+      procedure Check_Cb (Switch : String; Param : String);\n       --  Comment required ???\n \n-      procedure Remove_Cb (Switch : String);\n+      procedure Remove_Cb (Switch : String; Param : String);\n       --  Comment required ???\n \n       --------------\n       -- Check_Cb --\n       --------------\n \n-      procedure Check_Cb (Switch : String) is\n+      procedure Check_Cb (Switch : String; Param : String) is\n       begin\n          if Found then\n             for E in Result'Range loop\n                if Result (E) /= null\n-                 and then Params (E) = null    --  Ignore if has a param\n+                 and then\n+                   (Params (E) = null\n+                    or else Params (E) (Params (E)'First + 1\n+                                            .. Params (E)'Last) = Param)\n                  and then Result (E).all = Switch\n                then\n                   return;\n@@ -1676,14 +1997,21 @@ package body GNAT.Command_Line is\n       -- Remove_Cb --\n       ---------------\n \n-      procedure Remove_Cb (Switch : String) is\n+      procedure Remove_Cb (Switch : String; Param : String) is\n       begin\n          for E in Result'Range loop\n-            if Result (E) /= null and then Result (E).all = Switch then\n+            if Result (E) /= null\n+                 and then\n+                   (Params (E) = null\n+                    or else Params (E) (Params (E)'First + 1\n+                                            .. Params (E)'Last) = Param)\n+              and then Result (E).all = Switch\n+            then\n                if First > E then\n                   First := E;\n                end if;\n                Free (Result (E));\n+               Free (Params (E));\n                return;\n             end if;\n          end loop;\n@@ -1820,11 +2148,20 @@ package body GNAT.Command_Line is\n             end if;\n          end loop;\n \n+         Cmd.Coalesce_Params := new Argument_List (Cmd.Params'Range);\n+         for E in Cmd.Params'Range loop\n+            if Cmd.Params (E) = null then\n+               Cmd.Coalesce_Params (E) := null;\n+            else\n+               Cmd.Coalesce_Params (E) := new String'(Cmd.Params (E).all);\n+            end if;\n+         end loop;\n+\n          --  Not a clone, since we will not modify the parameters anyway\n \n-         Cmd.Coalesce_Params := Cmd.Params;\n-         Alias_Switches (Cmd, Cmd.Coalesce, Cmd.Params);\n-         Group_Switches (Cmd, Cmd.Coalesce, Cmd.Coalesce_Sections, Cmd.Params);\n+         Alias_Switches (Cmd, Cmd.Coalesce, Cmd.Coalesce_Params);\n+         Group_Switches\n+           (Cmd, Cmd.Coalesce, Cmd.Coalesce_Sections, Cmd.Coalesce_Params);\n       end if;\n \n       if Expanded then\n@@ -1841,6 +2178,7 @@ package body GNAT.Command_Line is\n          Iter.Current := Integer'Last;\n       else\n          Iter.Current := Iter.List'First;\n+\n          while Iter.Current <= Iter.List'Last\n            and then Iter.List (Iter.Current) = null\n          loop"}, {"sha": "738afe96a6999fa2ecfe8a6c3921deea4b41dc33", "filename": "gcc/ada/g-comlin.ads", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9325b0364fdef06a5168eb809c6e8ae0bf658a0/gcc%2Fada%2Fg-comlin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9325b0364fdef06a5168eb809c6e8ae0bf658a0/gcc%2Fada%2Fg-comlin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.ads?ref=f9325b0364fdef06a5168eb809c6e8ae0bf658a0", "patch": "@@ -513,13 +513,28 @@ package GNAT.Command_Line is\n    --  characters whose order is irrelevant. In fact, this package will sort\n    --  them alphabetically.\n \n+   procedure Define_Switch\n+     (Config : in out Command_Line_Configuration;\n+      Switch : String);\n+   --  Indicates a new switch. The format of this switch follows the getopt\n+   --  format (trailing ':', '?', etc for defining a switch with parameters).\n+   --  The switches defined in the command_line_configuration object are used\n+   --  when ungrouping switches with more that one character after the prefix.\n+\n    procedure Define_Section\n      (Config  : in out Command_Line_Configuration;\n       Section : String);\n    --  Indicates a new switch section. Every switch belonging to the same\n    --  section are ordered together, preceded by the section. They are placed\n    --  at the end of the command line (as in 'gnatmake somefile.adb -cargs -g')\n \n+   function Get_Switches\n+     (Config      : Command_Line_Configuration;\n+      Switch_Char : Character)\n+      return String;\n+   --  Get the switches list as expected by getopt. This list is built using\n+   --  all switches defined previously via Define_Switch above.\n+\n    procedure Free (Config : in out Command_Line_Configuration);\n    --  Free the memory used by Config\n \n@@ -595,11 +610,22 @@ package GNAT.Command_Line is\n    --  added if not already present. For example, to add the -g switch into the\n    --  -cargs section, you need to call (Cmd, \"-g\", Section => \"-cargs\")\n \n+   procedure Add_Switch\n+     (Cmd       : in out Command_Line;\n+      Switch    : String;\n+      Parameter : String    := \"\";\n+      Separator : Character := ' ';\n+      Section   : String    := \"\";\n+      Success   : out Boolean);\n+   --  Same as above, returning the status of\n+   --  the operation\n+\n    procedure Remove_Switch\n-     (Cmd        : in out Command_Line;\n-      Switch     : String;\n-      Remove_All : Boolean := False;\n-      Section    : String := \"\");\n+     (Cmd           : in out Command_Line;\n+      Switch        : String;\n+      Remove_All    : Boolean := False;\n+      Has_Parameter : Boolean := False;\n+      Section       : String := \"\");\n    --  Remove Switch from the command line, and ungroup existing switches if\n    --  necessary.\n    --\n@@ -610,12 +636,25 @@ package GNAT.Command_Line is\n    --  If Remove_All is True, then all matching switches are removed, otherwise\n    --  only the first matching one is removed.\n    --\n+   --  if Has_Parameter is set to True, then only switches having a parameter\n+   --  are removed.\n+   --\n    --  If the switch belongs to a section, then this section should be\n    --  specified: Remove_Switch (Cmd_Line, \"-g\", Section => \"-cargs\") called\n    --  on the command line \"-g -cargs -g\" will result in \"-g\", while if\n    --  called with (Cmd_Line, \"-g\") this will result in \"-cargs -g\".\n    --  If Remove_All is set, then both \"-g\" will be removed.\n \n+   procedure Remove_Switch\n+     (Cmd           : in out Command_Line;\n+      Switch        : String;\n+      Remove_All    : Boolean := False;\n+      Has_Parameter : Boolean := False;\n+      Section       : String  := \"\";\n+      Success       : out Boolean);\n+   --  Same as above, reporting the success of the operation (Success is False\n+   --  if no switch was removed).\n+\n    procedure Remove_Switch\n      (Cmd       : in out Command_Line;\n       Switch    : String;\n@@ -774,6 +813,9 @@ private\n       Aliases    : GNAT.OS_Lib.Argument_List_Access;\n       Expansions : GNAT.OS_Lib.Argument_List_Access;\n       --  The aliases. Both arrays have the same indices\n+\n+      Switches   : GNAT.OS_Lib.Argument_List_Access;\n+      --  List of expected switches. Used when expanding switch groups.\n    end record;\n    type Command_Line_Configuration is access Command_Line_Configuration_Record;\n "}]}