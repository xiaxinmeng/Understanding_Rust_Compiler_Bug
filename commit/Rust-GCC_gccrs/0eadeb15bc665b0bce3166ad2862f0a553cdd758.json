{"sha": "0eadeb15bc665b0bce3166ad2862f0a553cdd758", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVhZGViMTViYzY2NWIwYmNlMzE2NmFkMjg2MmYwYTU1M2NkZDc1OA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-11-04T21:25:00Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-11-04T21:25:00Z"}, "message": "recog.h (enum op_type): Define.\n\n        * recog.h (enum op_type): Define.\n        (constrain_operands): Adjust prototype.\n        (recog_op_type): Declare new variable.\n        * recog.c (recog_op_type): New variable.\n        (insn_invalid_p): Allow modifying an asm statement after reload.\n        (extract_insn): Set up recog_op_type.\n        (constrain_operands): Lose INSN_CODE_NUM arg.  All callers changed.\n        Don't compute operand types, use recog_op_type.\n        Use the information computed by extract_insn instead of the previous\n        method of finding it by insn code number.\n        * caller-save.c (init_caller_save): Use extract_insn, not insn_extract.\n        * reorg.c (fill_slots_from_thread): Likewise.\n        * reload1.c (reload_as_needed): Likewise.\n        (gen_reload): Likewise.\n        (inc_for_reload): Likewise.\n        (reload_cse_simplify_operands): Likewise.\n        Use the information computed by extract_insn instead of the previous\n        method of finding it by insn code number.\n        * genattrtab.c (write_attr_case): Generate call to extract_insn, not\n        insn_extract.\n        * final.c (final_scan_insn): Use extract_insn, not insn_extract.\n        (cleanup_operand_subregs): Use extract_insn, not insn_extract.\n        Use the information computed by extract_insn instead of the previous\n        method of finding it by insn code number.\n        * regmove.c (find_matches): Likewise.  Change meaning of the return\n        value to be nonzero if the optimization can be performed, zero if\n        not.  All callers changed.\n        Shorten some variable names to fix formatting problems.\n        (regmove_optimize): Shorten some variable names to fix formatting\n        problems.\n        Use the information computed by extract_insn instead of the previous\n        method of finding it by insn code number.\n        * regclass.c (scan_one_insn): Likewise.\n        (record_reg_classes): Don't compute operand types, use recog_op_type.\n        * reload.c (find_reloads): Lose CONSTRAINTS1 variable; use\n        recog_constraints instead.\n\nFrom-SVN: r23529", "tree": {"sha": "99a39e0c8a6a367f35a2aad560dc42aff38fce41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99a39e0c8a6a367f35a2aad560dc42aff38fce41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0eadeb15bc665b0bce3166ad2862f0a553cdd758", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eadeb15bc665b0bce3166ad2862f0a553cdd758", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0eadeb15bc665b0bce3166ad2862f0a553cdd758", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eadeb15bc665b0bce3166ad2862f0a553cdd758/comments", "author": null, "committer": null, "parents": [{"sha": "56744d1a2a2177f56136b2fb1a8aaf4f51612d69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56744d1a2a2177f56136b2fb1a8aaf4f51612d69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56744d1a2a2177f56136b2fb1a8aaf4f51612d69"}], "stats": {"total": 577, "additions": 274, "deletions": 303}, "files": [{"sha": "ae03458f0bbc6911092216926711450b39b0a429", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0eadeb15bc665b0bce3166ad2862f0a553cdd758", "patch": "@@ -1,3 +1,42 @@\n+Wed Nov  4 22:16:36 1998  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de>\n+\n+\t* recog.h (enum op_type): Define.\n+\t(constrain_operands): Adjust prototype.\n+\t(recog_op_type): Declare new variable.\n+\t* recog.c (recog_op_type): New variable.\n+\t(insn_invalid_p): Allow modifying an asm statement after reload.\n+\t(extract_insn): Set up recog_op_type.\n+\t(constrain_operands): Lose INSN_CODE_NUM arg.  All callers changed.\n+\tDon't compute operand types, use recog_op_type.\n+\tUse the information computed by extract_insn instead of the previous\n+\tmethod of finding it by insn code number.\n+\t* caller-save.c (init_caller_save): Use extract_insn, not insn_extract.\n+\t* reorg.c (fill_slots_from_thread): Likewise.\n+\t* reload1.c (reload_as_needed): Likewise.\n+\t(gen_reload): Likewise.\n+\t(inc_for_reload): Likewise.\n+\t(reload_cse_simplify_operands): Likewise.\n+\tUse the information computed by extract_insn instead of the previous\n+\tmethod of finding it by insn code number.\n+\t* genattrtab.c (write_attr_case): Generate call to extract_insn, not\n+\tinsn_extract.\n+\t* final.c (final_scan_insn): Use extract_insn, not insn_extract.\n+\t(cleanup_operand_subregs): Use extract_insn, not insn_extract.\n+\tUse the information computed by extract_insn instead of the previous\n+\tmethod of finding it by insn code number.\n+\t* regmove.c (find_matches): Likewise.  Change meaning of the return\n+\tvalue to be nonzero if the optimization can be performed, zero if\n+\tnot.  All callers changed.\n+\tShorten some variable names to fix formatting problems.\n+\t(regmove_optimize): Shorten some variable names to fix formatting\n+\tproblems.\n+\tUse the information computed by extract_insn instead of the previous\n+\tmethod of finding it by insn code number.\n+\t* regclass.c (scan_one_insn): Likewise.\n+\t(record_reg_classes): Don't compute operand types, use recog_op_type.\n+\t* reload.c (find_reloads): Lose CONSTRAINTS1 variable; use\n+\trecog_constraints instead.\n+\n Wed Nov  4 21:37:46 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* rtl.h (flow2_completed): Declare."}, {"sha": "371b65219e2c9b77949e679ea7d1e260323aba81", "filename": "gcc/caller-save.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=0eadeb15bc665b0bce3166ad2862f0a553cdd758", "patch": "@@ -196,10 +196,10 @@ init_caller_save ()\n \t\t&& reg_restore_code[i][j] != (enum insn_code)-1);\n \t  if (ok)\n \t    {\n-\t      insn_extract (saveinsn);\n-\t      ok = constrain_operands (reg_save_code[i][j], 1);\n-\t      insn_extract (restinsn);\n-\t      ok &= constrain_operands (reg_restore_code[i][j], 1);\n+\t      extract_insn (saveinsn);\n+\t      ok = constrain_operands (1);\n+\t      extract_insn (restinsn);\n+\t      ok &= constrain_operands (1);\n \t    }\n \n \t  if (! ok)"}, {"sha": "18c4dc531437a053963a2f34b77f498d0659c0ba", "filename": "gcc/final.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=0eadeb15bc665b0bce3166ad2862f0a553cdd758", "patch": "@@ -2843,20 +2843,19 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t   since `reload' should have changed them so that they do.  */\n \n \tinsn_code_number = recog_memoized (insn);\n-\tinsn_extract (insn);\n+\textract_insn (insn);\n \tcleanup_subreg_operands (insn);\n \n #ifdef REGISTER_CONSTRAINTS\n-\tif (! constrain_operands (insn_code_number, 1))\n+\tif (! constrain_operands (1))\n \t  fatal_insn_not_found (insn);\n #endif\n \n \t/* Some target machines need to prescan each insn before\n \t   it is output.  */\n \n #ifdef FINAL_PRESCAN_INSN\n-\tFINAL_PRESCAN_INSN (insn, recog_operand,\n-\t\t\t    insn_n_operands[insn_code_number]);\n+\tFINAL_PRESCAN_INSN (insn, recog_operand, recog_n_operands);\n #endif\n \n #ifdef HAVE_cc0\n@@ -3047,8 +3046,8 @@ cleanup_subreg_operands (insn)\n      since `reload' should have changed them so that they do.  */\n \n   insn_code_number = recog_memoized (insn);\n-  insn_extract (insn);\n-  for (i = 0; i < insn_n_operands[insn_code_number]; i++)\n+  extract_insn (insn);\n+  for (i = 0; i < recog_n_operands; i++)\n     {\n       if (GET_CODE (recog_operand[i]) == SUBREG)\n         recog_operand[i] = alter_subreg (recog_operand[i]);\n@@ -3057,7 +3056,7 @@ cleanup_subreg_operands (insn)\n        recog_operand[i] = walk_alter_subreg (recog_operand[i]);\n     }\n \n-  for (i = 0; i < insn_n_dups[insn_code_number]; i++)\n+  for (i = 0; i < recog_n_dups; i++)\n     {\n       if (GET_CODE (*recog_dup_loc[i]) == SUBREG)\n         *recog_dup_loc[i] = alter_subreg (*recog_dup_loc[i]);"}, {"sha": "8ac90c67bccff58bd5ebd55eea34d8f4e1885095", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=0eadeb15bc665b0bce3166ad2862f0a553cdd758", "patch": "@@ -34,7 +34,7 @@ Boston, MA 02111-1307, USA.  */\n \n    If the attribute `alternative', or a random C expression is present,\n    `constrain_operands' is called.  If either of these cases of a reference to\n-   an operand is found, `insn_extract' is called.\n+   an operand is found, `extract_insn' is called.\n \n    The special attribute `length' is also recognized.  For this operand, \n    expressions involving the address of an operand or the current insn,\n@@ -5063,14 +5063,14 @@ write_attr_case (attr, av, write_case_lines, prefix, suffix, indent,\n   if (must_extract)\n     {\n       write_indent (indent + 2);\n-      printf (\"insn_extract (insn);\\n\");\n+      printf (\"extract_insn (insn);\\n\");\n     }\n \n   if (must_constrain)\n     {\n #ifdef REGISTER_CONSTRAINTS\n       write_indent (indent + 2);\n-      printf (\"if (! constrain_operands (INSN_CODE (insn), reload_completed))\\n\");\n+      printf (\"if (! constrain_operands (reload_completed))\\n\");\n       write_indent (indent + 2);\n       printf (\"  fatal_insn_not_found (insn);\\n\");\n #endif"}, {"sha": "6ae7a31613df4a0394a5d6cfea324351cb2b4977", "filename": "gcc/recog.c", "status": "modified", "additions": 33, "deletions": 47, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=0eadeb15bc665b0bce3166ad2862f0a553cdd758", "patch": "@@ -56,7 +56,8 @@ static int insn_invalid_p\t\tPROTO((rtx));\n \n int volatile_ok;\n \n-/* The following vectors hold the results from insn_extract.  */\n+/* The next variables are set up by extract_insn.  The first four of them\n+   are also set up during insn_extract.  */\n \n /* Indexed by N, gives value of operand N.  */\n rtx recog_operand[MAX_RECOG_OPERANDS];\n@@ -72,9 +73,6 @@ rtx *recog_dup_loc[MAX_RECOG_OPERANDS];\n    Nth duplicate-appearance of an operand.  */\n char recog_dup_num[MAX_RECOG_OPERANDS];\n \n-\n-/* The next variables are set up by extract_insn.  */\n-\n /* The number of operands of the insn.  */\n int recog_n_operands;\n \n@@ -90,6 +88,9 @@ enum machine_mode recog_operand_mode[MAX_RECOG_OPERANDS];\n /* Indexed by N, gives the constraint string for operand N.  */\n char *recog_constraints[MAX_RECOG_OPERANDS];\n \n+/* Indexed by N, gives the type (in, out, inout) for operand N.  */\n+enum op_type recog_op_type[MAX_RECOG_OPERANDS];\n+\n #ifndef REGISTER_CONSTRAINTS\n /* Indexed by N, nonzero if operand N should be an address.  */\n char recog_operand_address_p[MAX_RECOG_OPERANDS];\n@@ -264,25 +265,17 @@ insn_invalid_p (insn)\n   int icode = recog_memoized (insn);\n   int is_asm = icode < 0 && asm_noperands (PATTERN (insn)) >= 0;\n \n-  if (is_asm)\n-    {\n-      if (! check_asm_operands (PATTERN (insn)))\n-\treturn 1;\n-\n-      /* Disallow modification of ASM_OPERANDS after reload; verifying the\n-\t constraints is too difficult.  */\n-      if (reload_completed)\n-\treturn 1;\n-    }\n-  else if (icode < 0)\n+  if (is_asm && ! check_asm_operands (PATTERN (insn)))\n+    return 1;\n+  if (! is_asm && icode < 0)\n     return 1;\n \n   /* After reload, verify that all constraints are satisfied.  */\n   if (reload_completed)\n     {\n-      insn_extract (insn);\n+      extract_insn (insn);\n \n-      if (! constrain_operands (INSN_CODE (insn), 1))\n+      if (! constrain_operands (1))\n \treturn 1;\n     }\n \n@@ -304,8 +297,7 @@ apply_change_group ()\n      given a MEM and it still is a valid address, or if this is in insn\n      and it is recognized.  In the latter case, if reload has completed,\n      we also require that the operands meet the constraints for\n-     the insn.  We do not allow modifying an ASM_OPERANDS after reload\n-     has completed because verifying the constraints is too difficult.  */\n+     the insn.  */\n \n   for (i = 0; i < num_changes; i++)\n     {\n@@ -1807,13 +1799,18 @@ extract_insn (insn)\n \t  recog_operand_mode[i] = insn_operand_mode[icode][i];\n \t}\n     }\n+  for (i = 0; i < noperands; i++)\n+    recog_op_type[i] = (recog_constraints[i][0] == '=' ? OP_OUT\n+\t\t\t: recog_constraints[i][0] == '+' ? OP_INOUT\n+\t\t\t: OP_IN);\n }\n \n #ifdef REGISTER_CONSTRAINTS\n \n-/* Check the operands of an insn (found in recog_operands)\n-   against the insn's operand constraints (found via INSN_CODE_NUM)\n+/* Check the operands of an insn against the insn's operand constraints\n    and return 1 if they are valid.\n+   The information about the insn's operands, constraints, operand modes\n+   etc. is obtained from the global variables set up by extract_insn.\n \n    WHICH_ALTERNATIVE is set to a number which indicates which\n    alternative of constraints was matched: 0 for the first alternative,\n@@ -1843,40 +1840,35 @@ struct funny_match\n };\n \n int\n-constrain_operands (insn_code_num, strict)\n-     int insn_code_num;\n+constrain_operands (strict)\n      int strict;\n {\n   char *constraints[MAX_RECOG_OPERANDS];\n   int matching_operands[MAX_RECOG_OPERANDS];\n-  enum op_type {OP_IN, OP_OUT, OP_INOUT} op_types[MAX_RECOG_OPERANDS];\n   int earlyclobber[MAX_RECOG_OPERANDS];\n   register int c;\n-  int noperands = insn_n_operands[insn_code_num];\n \n   struct funny_match funny_match[MAX_RECOG_OPERANDS];\n   int funny_match_index;\n-  int nalternatives = insn_n_alternatives[insn_code_num];\n \n-  if (noperands == 0 || nalternatives == 0)\n+  if (recog_n_operands == 0 || recog_n_alternatives == 0)\n     return 1;\n \n-  for (c = 0; c < noperands; c++)\n+  for (c = 0; c < recog_n_operands; c++)\n     {\n-      constraints[c] = insn_operand_constraint[insn_code_num][c];\n+      constraints[c] = recog_constraints[c];\n       matching_operands[c] = -1;\n-      op_types[c] = OP_IN;\n     }\n \n   which_alternative = 0;\n \n-  while (which_alternative < nalternatives)\n+  while (which_alternative < recog_n_alternatives)\n     {\n       register int opno;\n       int lose = 0;\n       funny_match_index = 0;\n \n-      for (opno = 0; opno < noperands; opno++)\n+      for (opno = 0; opno < recog_n_operands; opno++)\n \t{\n \t  register rtx op = recog_operand[opno];\n \t  enum machine_mode mode = GET_MODE (op);\n@@ -1912,6 +1904,8 @@ constrain_operands (insn_code_num, strict)\n \t      case '!':\n \t      case '*':\n \t      case '%':\n+\t      case '=':\n+\t      case '+':\n \t\tbreak;\n \n \t      case '#':\n@@ -1921,14 +1915,6 @@ constrain_operands (insn_code_num, strict)\n \t\t  p++;\n \t\tbreak;\n \n-\t      case '=':\n-\t\top_types[opno] = OP_OUT;\n-\t\tbreak;\n-\n-\t      case '+':\n-\t\top_types[opno] = OP_INOUT;\n-\t\tbreak;\n-\n \t      case '&':\n \t\tearlyclobber[opno] = 1;\n \t\tbreak;\n@@ -1973,8 +1959,8 @@ constrain_operands (insn_code_num, strict)\n \t\t   strictly valid, i.e., that all pseudos requiring hard regs\n \t\t   have gotten them.  */\n \t\tif (strict <= 0\n-\t\t    || (strict_memory_address_p\n-\t\t\t(insn_operand_mode[insn_code_num][opno], op)))\n+\t\t    || (strict_memory_address_p (recog_operand_mode[opno],\n+\t\t\t\t\t\t op)))\n \t\t  win = 1;\n \t\tbreak;\n \n@@ -2154,18 +2140,18 @@ constrain_operands (insn_code_num, strict)\n \t     operand.  */\n \n \t  if (strict > 0)\n-\t    for (eopno = 0; eopno < noperands; eopno++)\n+\t    for (eopno = 0; eopno < recog_n_operands; eopno++)\n \t      /* Ignore earlyclobber operands now in memory,\n \t\t because we would often report failure when we have\n \t\t two memory operands, one of which was formerly a REG.  */\n \t      if (earlyclobber[eopno]\n \t\t  && GET_CODE (recog_operand[eopno]) == REG)\n-\t\tfor (opno = 0; opno < noperands; opno++)\n+\t\tfor (opno = 0; opno < recog_n_operands; opno++)\n \t\t  if ((GET_CODE (recog_operand[opno]) == MEM\n-\t\t       || op_types[opno] != OP_OUT)\n+\t\t       || recog_op_type[opno] != OP_OUT)\n \t\t      && opno != eopno\n \t\t      /* Ignore things like match_operator operands.  */\n-\t\t      && *insn_operand_constraint[insn_code_num][opno] != 0\n+\t\t      && *recog_constraints[opno] != 0\n \t\t      && ! (matching_operands[opno] == eopno\n \t\t\t    && operands_match_p (recog_operand[opno],\n \t\t\t\t\t\t recog_operand[eopno]))\n@@ -2191,7 +2177,7 @@ constrain_operands (insn_code_num, strict)\n   /* If we are about to reject this, but we are not to test strictly,\n      try a very loose test.  Only return failure if it fails also.  */\n   if (strict == 0)\n-    return constrain_operands (insn_code_num, -1);\n+    return constrain_operands (-1);\n   else\n     return 0;\n }"}, {"sha": "d96da77fccc4f9bb20b24a6d75ba0e852a1120cc", "filename": "gcc/recog.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=0eadeb15bc665b0bce3166ad2862f0a553cdd758", "patch": "@@ -20,6 +20,13 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"gansidecl.h\"\n \n+/* Types of operands.  */\n+enum op_type {\n+  OP_IN,\n+  OP_OUT,\n+  OP_INOUT\n+};\n+\n extern void init_recog\t\t\tPROTO((void));\n extern void init_recog_no_volatile\tPROTO((void));\n extern int recog_memoized\t\tPROTO((rtx));\n@@ -28,7 +35,7 @@ extern int validate_change\t\tPROTO((rtx, rtx *, rtx, int));\n extern int apply_change_group\t\tPROTO((void));\n extern int num_validated_changes\tPROTO((void));\n extern void cancel_changes\t\tPROTO((int));\n-extern int constrain_operands\t\tPROTO((int, int));\n+extern int constrain_operands\t\tPROTO((int));\n extern int memory_address_p\t\tPROTO((enum machine_mode, rtx));\n extern int strict_memory_address_p\tPROTO((enum machine_mode, rtx));\n extern int validate_replace_rtx\t\tPROTO((rtx, rtx, rtx));\n@@ -103,6 +110,9 @@ extern enum machine_mode recog_operand_mode[];\n /* Indexed by N, gives the constraint string for operand N.  */\n extern char *recog_constraints[];\n \n+/* Indexed by N, gives the type (in, out, inout) for operand N.  */\n+extern enum op_type recog_op_type[];\n+\n #ifndef REGISTER_CONSTRAINTS\n /* Indexed by N, nonzero if operand N should be an address.  */\n extern char recog_operand_address_p[];"}, {"sha": "8b5f1589196f3d48d0754ce8c564322fde5b17bd", "filename": "gcc/regclass.c", "status": "modified", "additions": 82, "deletions": 116, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=0eadeb15bc665b0bce3166ad2862f0a553cdd758", "patch": "@@ -765,12 +765,9 @@ scan_one_insn (insn, pass)\n {\n   enum rtx_code code = GET_CODE (insn);\n   enum rtx_code pat_code;\n-\n   char *constraints[MAX_RECOG_OPERANDS];\n   enum machine_mode modes[MAX_RECOG_OPERANDS];\n-  int nalternatives;\n-  int noperands;\n-  rtx set;\n+  rtx set, note;\n   int i, j;\n \n   /* Show that an insn inside a loop is likely to be executed three\n@@ -799,106 +796,88 @@ scan_one_insn (insn, pass)\n       || pat_code == ADDR_DIFF_VEC)\n     return insn;\n \n-  if (code == INSN\n-      && (noperands = asm_noperands (PATTERN (insn))) >= 0)\n+  set = single_set (insn);\n+  extract_insn (insn);\n+\n+  for (i = 0; i < recog_n_operands; i++)\n     {\n-      decode_asm_operands (PATTERN (insn), recog_operand, NULL_PTR,\n-\t\t\t   constraints, modes);\n-      nalternatives = (noperands == 0 ? 0\n-\t\t       : n_occurrences (',', constraints[0]) + 1);\n+      constraints[i] = recog_constraints[i];\n+      modes[i] = recog_operand_mode[i];\n     }\n-  else\n-    {\n-      int insn_code_number = recog_memoized (insn);\n-      rtx note;\n \n-      set = single_set (insn);\n-      insn_extract (insn);\n+  /* If this insn loads a parameter from its stack slot, then\n+     it represents a savings, rather than a cost, if the\n+     parameter is stored in memory.  Record this fact.  */\n \n-      nalternatives = insn_n_alternatives[insn_code_number];\n-      noperands = insn_n_operands[insn_code_number];\n+  if (set != 0 && GET_CODE (SET_DEST (set)) == REG\n+      && GET_CODE (SET_SRC (set)) == MEM\n+      && (note = find_reg_note (insn, REG_EQUIV,\n+\t\t\t\tNULL_RTX)) != 0\n+      && GET_CODE (XEXP (note, 0)) == MEM)\n+    {\n+      costs[REGNO (SET_DEST (set))].mem_cost\n+\t-= (MEMORY_MOVE_COST (GET_MODE (SET_DEST (set)),\n+\t\t\t      GENERAL_REGS, 1)\n+\t    * loop_cost);\n+      record_address_regs (XEXP (SET_SRC (set), 0),\n+\t\t\t   BASE_REG_CLASS, loop_cost * 2);\n+      return insn;\n+    }\n \n-      /* If this insn loads a parameter from its stack slot, then\n-\t it represents a savings, rather than a cost, if the\n-\t parameter is stored in memory.  Record this fact.  */\n+  /* Improve handling of two-address insns such as\n+     (set X (ashift CONST Y)) where CONST must be made to\n+     match X. Change it into two insns: (set X CONST)\n+     (set X (ashift X Y)).  If we left this for reloading, it\n+     would probably get three insns because X and Y might go\n+     in the same place. This prevents X and Y from receiving\n+     the same hard reg.\n+\n+     We can only do this if the modes of operands 0 and 1\n+     (which might not be the same) are tieable and we only need\n+     do this during our first pass.  */\n+\n+  if (pass == 0 && optimize\n+      && recog_n_operands >= 3\n+      && recog_constraints[1][0] == '0'\n+      && recog_constraints[1][1] == 0\n+      && CONSTANT_P (recog_operand[1])\n+      && ! rtx_equal_p (recog_operand[0], recog_operand[1])\n+      && ! rtx_equal_p (recog_operand[0], recog_operand[2])\n+      && GET_CODE (recog_operand[0]) == REG\n+      && MODES_TIEABLE_P (GET_MODE (recog_operand[0]),\n+\t\t\t  recog_operand_mode[1]))\n+    {\n+      rtx previnsn = prev_real_insn (insn);\n+      rtx dest\n+\t= gen_lowpart (recog_operand_mode[1],\n+\t\t       recog_operand[0]);\n+      rtx newinsn\n+\t= emit_insn_before (gen_move_insn (dest,\n+\t\t\t\t\t   recog_operand[1]),\n+\t\t\t    insn);\n \n-      if (set != 0 && GET_CODE (SET_DEST (set)) == REG\n-\t  && GET_CODE (SET_SRC (set)) == MEM\n-\t  && (note = find_reg_note (insn, REG_EQUIV,\n-\t\t\t\t    NULL_RTX)) != 0\n-\t  && GET_CODE (XEXP (note, 0)) == MEM)\n+      /* If this insn was the start of a basic block,\n+\t include the new insn in that block.\n+\t We need not check for code_label here;\n+\t while a basic block can start with a code_label,\n+\t INSN could not be at the beginning of that block.  */\n+      if (previnsn == 0 || GET_CODE (previnsn) == JUMP_INSN)\n \t{\n-\t  costs[REGNO (SET_DEST (set))].mem_cost\n-\t    -= (MEMORY_MOVE_COST (GET_MODE (SET_DEST (set)),\n-\t\t\t\t  GENERAL_REGS, 1)\n-\t\t* loop_cost);\n-\t  record_address_regs (XEXP (SET_SRC (set), 0),\n-\t\t\t       BASE_REG_CLASS, loop_cost * 2);\n-\t  return insn;\n+\t  int b;\n+\t  for (b = 0; b < n_basic_blocks; b++)\n+\t    if (insn == basic_block_head[b])\n+\t      basic_block_head[b] = newinsn;\n \t}\n \n-      /* Improve handling of two-address insns such as\n-\t (set X (ashift CONST Y)) where CONST must be made to\n-\t match X. Change it into two insns: (set X CONST)\n-\t (set X (ashift X Y)).  If we left this for reloading, it\n-\t would probably get three insns because X and Y might go\n-\t in the same place. This prevents X and Y from receiving\n-\t the same hard reg.\n-\n-\t We can only do this if the modes of operands 0 and 1\n-\t (which might not be the same) are tieable and we only need\n-\t do this during our first pass.  */\n-\n-      if (pass == 0 && optimize\n-\t  && noperands >= 3\n-\t  && insn_operand_constraint[insn_code_number][1][0] == '0'\n-\t  && insn_operand_constraint[insn_code_number][1][1] == 0\n-\t  && CONSTANT_P (recog_operand[1])\n-\t  && ! rtx_equal_p (recog_operand[0], recog_operand[1])\n-\t  && ! rtx_equal_p (recog_operand[0], recog_operand[2])\n-\t  && GET_CODE (recog_operand[0]) == REG\n-\t  && MODES_TIEABLE_P (GET_MODE (recog_operand[0]),\n-\t\t\t      insn_operand_mode[insn_code_number][1]))\n-\t{\n-\t  rtx previnsn = prev_real_insn (insn);\n-\t  rtx dest\n-\t    = gen_lowpart (insn_operand_mode[insn_code_number][1],\n-\t\t\t   recog_operand[0]);\n-\t  rtx newinsn\n-\t    = emit_insn_before (gen_move_insn (dest,\n-\t\t\t\t\t       recog_operand[1]),\n-\t\t\t\tinsn);\n-\n-\t  /* If this insn was the start of a basic block,\n-\t     include the new insn in that block.\n-\t     We need not check for code_label here;\n-\t     while a basic block can start with a code_label,\n-\t     INSN could not be at the beginning of that block.  */\n-\t  if (previnsn == 0 || GET_CODE (previnsn) == JUMP_INSN)\n-\t    {\n-\t      int b;\n-\t      for (b = 0; b < n_basic_blocks; b++)\n-\t\tif (insn == basic_block_head[b])\n-\t\t  basic_block_head[b] = newinsn;\n-\t    }\n-\n-\t  /* This makes one more setting of new insns's dest.  */\n-\t  REG_N_SETS (REGNO (recog_operand[0]))++;\n-\n-\t  *recog_operand_loc[1] = recog_operand[0];\n-\t  for (i = insn_n_dups[insn_code_number] - 1; i >= 0; i--)\n-\t    if (recog_dup_num[i] == 1)\n-\t      *recog_dup_loc[i] = recog_operand[0];\n+      /* This makes one more setting of new insns's dest.  */\n+      REG_N_SETS (REGNO (recog_operand[0]))++;\n \n-\t  return PREV_INSN (newinsn);\n-\t}\n+      *recog_operand_loc[1] = recog_operand[0];\n+      for (i = recog_n_dups - 1; i >= 0; i--)\n+\tif (recog_dup_num[i] == 1)\n+\t  *recog_dup_loc[i] = recog_operand[0];\n \n-      for (i = 0; i < noperands; i++)\n-\t{\n-\t  constraints[i]\n-\t    = insn_operand_constraint[insn_code_number][i];\n-\t  modes[i] = insn_operand_mode[insn_code_number][i];\n-\t}\n+      return PREV_INSN (newinsn);\n     }\n \n   /* If we get here, we are set up to record the costs of all the\n@@ -907,7 +886,7 @@ scan_one_insn (insn, pass)\n      classes for any pseudos, doing it twice if some pair of\n      operands are commutative.  */\n \t     \n-  for (i = 0; i < noperands; i++)\n+  for (i = 0; i < recog_n_operands; i++)\n     {\n       op_costs[i] = init_cost;\n \n@@ -926,7 +905,7 @@ scan_one_insn (insn, pass)\n      have been initialized.  We must do this even if one operand\n      is a constant--see addsi3 in m68k.md.  */\n \n-  for (i = 0; i < noperands - 1; i++)\n+  for (i = 0; i < recog_n_operands - 1; i++)\n     if (constraints[i][0] == '%')\n       {\n \tchar *xconstraints[MAX_RECOG_OPERANDS];\n@@ -935,23 +914,23 @@ scan_one_insn (insn, pass)\n \t/* Handle commutative operands by swapping the constraints.\n \t   We assume the modes are the same.  */\n \n-\tfor (j = 0; j < noperands; j++)\n+\tfor (j = 0; j < recog_n_operands; j++)\n \t  xconstraints[j] = constraints[j];\n \n \txconstraints[i] = constraints[i+1];\n \txconstraints[i+1] = constraints[i];\n-\trecord_reg_classes (nalternatives, noperands,\n+\trecord_reg_classes (recog_n_alternatives, recog_n_operands,\n \t\t\t    recog_operand, modes, xconstraints,\n \t\t\t    insn);\n       }\n \n-  record_reg_classes (nalternatives, noperands, recog_operand,\n+  record_reg_classes (recog_n_alternatives, recog_n_operands, recog_operand,\n \t\t      modes, constraints, insn);\n \n   /* Now add the cost for each operand to the total costs for\n      its register.  */\n \n-  for (i = 0; i < noperands; i++)\n+  for (i = 0; i < recog_n_operands; i++)\n     if (GET_CODE (recog_operand[i]) == REG\n \t&& REGNO (recog_operand[i]) >= FIRST_PSEUDO_REGISTER)\n       {\n@@ -1171,15 +1150,9 @@ record_reg_classes (n_alts, n_ops, ops, modes, constraints, insn)\n      rtx insn;\n {\n   int alt;\n-  enum op_type {OP_READ, OP_WRITE, OP_READ_WRITE} op_types[MAX_RECOG_OPERANDS];\n   int i, j;\n   rtx set;\n \n-  /* By default, each operand is an input operand.  */\n-\n-  for (i = 0; i < n_ops; i++)\n-    op_types[i] = OP_READ;\n-\n   /* Process each alternative, each time minimizing an operand's cost with\n      the cost for each operand in that alternative.  */\n \n@@ -1220,14 +1193,7 @@ record_reg_classes (n_alts, n_ops, ops, modes, constraints, insn)\n \t     any modifiers for the operand before we can make this test.  */\n \n \t  while (*p == '%' || *p == '=' || *p == '+' || *p == '&')\n-\t    {\n-\t      if (*p == '=')\n-\t\top_types[i] = OP_WRITE;\n-\t      else if (*p == '+')\n-\t\top_types[i] = OP_READ_WRITE;\n-\n-\t      p++;\n-\t    }\n+\t    p++;\n \n \t  if (p[0] >= '0' && p[0] <= '0' + i && (p[1] == ',' || p[1] == 0))\n \t    {\n@@ -1477,10 +1443,10 @@ record_reg_classes (n_alts, n_ops, ops, modes, constraints, insn)\n \n \t  else if (classes[i] != NO_REGS)\n \t    {\n-\t      if (op_types[i] != OP_WRITE)\n+\t      if (recog_op_type[i] != OP_OUT)\n \t\talt_cost += copy_cost (op, mode, classes[i], 1);\n \n-\t      if (op_types[i] != OP_READ)\n+\t      if (recog_op_type[i] != OP_IN)\n \t\talt_cost += copy_cost (op, mode, classes[i], 0);\n \t    }\n \n@@ -1504,7 +1470,7 @@ record_reg_classes (n_alts, n_ops, ops, modes, constraints, insn)\n \t    && REGNO (ops[i]) >= FIRST_PSEUDO_REGISTER)\n \t  {\n \t    struct costs *pp = &op_costs[i], *qq = &this_op_costs[i];\n-\t    int scale = 1 + (op_types[i] == OP_READ_WRITE);\n+\t    int scale = 1 + (recog_op_type[i] == OP_INOUT);\n \n \t    pp->mem_cost = MIN (pp->mem_cost,\n \t\t\t\t(qq->mem_cost + alt_cost) * scale);"}, {"sha": "57227b9a5ce8e903aa13f65fc09b8ba7d231f275", "filename": "gcc/regmove.c", "status": "modified", "additions": 63, "deletions": 77, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=0eadeb15bc665b0bce3166ad2862f0a553cdd758", "patch": "@@ -962,8 +962,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t   insn = pass ? PREV_INSN (insn) : NEXT_INSN (insn))\n \t{\n \t  rtx set;\n-\t  int insn_code_number;\n-\t  int operand_number, match_number;\n+\t  int op_no, match_no;\n \n \t  if (GET_CODE (insn) == NOTE)\n \t    {\n@@ -1008,11 +1007,9 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\t    }\n \t\t}\n \t    }\n-#ifdef REGISTER_CONSTRAINTS\n-\t  insn_code_number\n-\t    = find_matches (insn, &match);\n \n-\t  if (insn_code_number < 0)\n+#ifdef REGISTER_CONSTRAINTS\n+\t  if (find_matches (insn, &match) < 0)\n \t    continue;\n \n \t  /* Now scan through the operands looking for a source operand\n@@ -1022,21 +1019,19 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t     If it dies there, then replace the dest in both operands with\n \t     the source operand.  */\n \n-\t  for (operand_number = 0;\n-\t       operand_number < insn_n_operands[insn_code_number];\n-\t       operand_number++)\n+\t  for (op_no = 0; op_no < recog_n_operands; op_no++)\n \t    {\n \t      rtx src, dst, src_subreg;\n \t      enum reg_class src_class, dst_class;\n \n-\t      match_number = match.with[operand_number];\n+\t      match_no = match.with[op_no];\n \n \t      /* Nothing to do if the two operands aren't supposed to match.  */\n-\t      if (match_number < 0)\n+\t      if (match_no < 0)\n \t\tcontinue;\n \n-\t      src = recog_operand[operand_number];\n-\t      dst = recog_operand[match_number];\n+\t      src = recog_operand[op_no];\n+\t      dst = recog_operand[match_no];\n \n \t      if (GET_CODE (src) != REG)\n \t\tcontinue;\n@@ -1057,36 +1052,36 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \n \t      if (REGNO (src) < FIRST_PSEUDO_REGISTER)\n \t\t{\n-\t\t  if (match.commutative[operand_number] < operand_number)\n+\t\t  if (match.commutative[op_no] < op_no)\n \t\t    regno_src_regno[REGNO (dst)] = REGNO (src);\n \t\t  continue;\n \t\t}\n \n \t      if (REG_LIVE_LENGTH (REGNO (src)) < 0)\n \t\tcontinue;\n \n-\t      /* operand_number/src must be a read-only operand, and\n+\t      /* op_no/src must be a read-only operand, and\n \t\t match_operand/dst must be a write-only operand.  */\n-\t      if (match.use[operand_number] != READ\n-\t\t  || match.use[match_number] != WRITE)\n+\t      if (match.use[op_no] != READ\n+\t\t  || match.use[match_no] != WRITE)\n \t\tcontinue;\n \n-\t      if (match.early_clobber[match_number]\n+\t      if (match.early_clobber[match_no]\n \t\t  && count_occurrences (PATTERN (insn), src) > 1)\n \t\tcontinue;\n \n \t      /* Make sure match_operand is the destination.  */\n-\t      if (recog_operand[match_number] != SET_DEST (set))\n+\t      if (recog_operand[match_no] != SET_DEST (set))\n \t\tcontinue;\n \n \t      /* If the operands already match, then there is nothing to do.  */\n \t      /* But in the commutative case, we might find a better match.  */\n \t      if (operands_match_p (src, dst)\n-\t\t  || (match.commutative[operand_number] >= 0\n+\t\t  || (match.commutative[op_no] >= 0\n \t\t      && operands_match_p (recog_operand[match.commutative\n-\t\t\t\t\t\t\t [operand_number]], dst)\n+\t\t\t\t\t\t\t [op_no]], dst)\n \t\t      && (replacement_quality (recog_operand[match.commutative\n-\t\t\t\t\t\t\t     [operand_number]])\n+\t\t\t\t\t\t\t     [op_no]])\n \t\t\t  >= replacement_quality (src))))\n \t\tcontinue;\n \n@@ -1096,7 +1091,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\tcontinue;\n \t  \n \t      if (fixup_match_1 (insn, set, src, src_subreg, dst, pass,\n-\t\t\t\t operand_number, match_number,\n+\t\t\t\t op_no, match_no,\n \t\t\t\t regmove_dump_file))\n \t\tbreak;\n \t    }\n@@ -1121,11 +1116,10 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t}\n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t{\n-\t  int insn_code_number = find_matches (insn, &match);\n-\t  int operand_number, match_number;\n+\t  int op_no, match_no;\n \t  int success = 0;\n-\t  \n-\t  if (insn_code_number < 0)\n+\n+\t  if (find_matches (insn, &match) < 0)\n \t    continue;\n \n \t  /* Now scan through the operands looking for a destination operand\n@@ -1136,24 +1130,22 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \n \t  copy_src = NULL_RTX;\n \t  copy_dst = NULL_RTX;\n-\t  for (operand_number = 0;\n-\t       operand_number < insn_n_operands[insn_code_number];\n-\t       operand_number++)\n+\t  for (op_no = 0; op_no < recog_n_operands; op_no++)\n \t    {\n \t      rtx set, p, src, dst;\n \t      rtx src_note, dst_note;\n \t      int num_calls = 0;\n \t      enum reg_class src_class, dst_class;\n \t      int length;\n \n-\t      match_number = match.with[operand_number];\n+\t      match_no = match.with[op_no];\n \n \t      /* Nothing to do if the two operands aren't supposed to match.  */\n-\t      if (match_number < 0)\n+\t      if (match_no < 0)\n \t\tcontinue;\n \n-\t      dst = recog_operand[match_number];\n-\t      src = recog_operand[operand_number];\n+\t      dst = recog_operand[match_no];\n+\t      src = recog_operand[op_no];\n \n \t      if (GET_CODE (src) != REG)\n \t\tcontinue;\n@@ -1165,26 +1157,26 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \n \t      /* If the operands already match, then there is nothing to do.  */\n \t      if (operands_match_p (src, dst)\n-\t\t  || (match.commutative[operand_number] >= 0\n-\t\t      && operands_match_p (recog_operand[match.commutative[operand_number]], dst)))\n+\t\t  || (match.commutative[op_no] >= 0\n+\t\t      && operands_match_p (recog_operand[match.commutative[op_no]], dst)))\n \t\tcontinue;\n \n \t      set = single_set (insn);\n \t      if (! set)\n \t\tcontinue;\n \n-\t      /* match_number/dst must be a write-only operand, and\n+\t      /* match_no/dst must be a write-only operand, and\n \t\t operand_operand/src must be a read-only operand.  */\n-\t      if (match.use[operand_number] != READ\n-\t\t  || match.use[match_number] != WRITE)\n+\t      if (match.use[op_no] != READ\n+\t\t  || match.use[match_no] != WRITE)\n \t\tcontinue;\n \n-\t      if (match.early_clobber[match_number]\n+\t      if (match.early_clobber[match_no]\n \t\t  && count_occurrences (PATTERN (insn), src) > 1)\n \t\tcontinue;\n \n-\t      /* Make sure match_number is the destination.  */\n-\t      if (recog_operand[match_number] != SET_DEST (set))\n+\t      /* Make sure match_no is the destination.  */\n+\t      if (recog_operand[match_no] != SET_DEST (set))\n \t\tcontinue;\n \n \t      if (REGNO (src) < FIRST_PSEUDO_REGISTER)\n@@ -1252,11 +1244,11 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t      if (regmove_dump_file)\n \t\tfprintf (regmove_dump_file,\n \t\t\t \"Could fix operand %d of insn %d matching operand %d.\\n\",\n-\t\t\t operand_number, INSN_UID (insn), match_number);\n+\t\t\t op_no, INSN_UID (insn), match_no);\n \n \t      /* Scan backward to find the first instruction that uses\n \t\t the input operand.  If the operand is set here, then\n-\t\t replace it in both instructions with match_number.  */\n+\t\t replace it in both instructions with match_no.  */\n \n \t      for (length = 0, p = PREV_INSN (insn); p; p = PREV_INSN (p))\n \t\t{\n@@ -1304,7 +1296,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\t\t      validate_replace_rtx (dst, src, insn);\n \t\t\t      /* Now make sure the dst is right.  */\n \t\t\t      validate_change (insn,\n-\t\t\t\t\t       recog_operand_loc[match_number],\n+\t\t\t\t\t       recog_operand_loc[match_no],\n \t\t\t\t\t       dst, 0);\n \t\t\t    }\n \t\t\t}\n@@ -1384,7 +1376,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\t  if (regmove_dump_file)\n \t\t    fprintf (regmove_dump_file,\n \t\t\t     \"Fixed operand %d of insn %d matching operand %d.\\n\",\n-\t\t\t     operand_number, INSN_UID (insn), match_number);\n+\t\t\t     op_no, INSN_UID (insn), match_no);\n \n \t\t  break;\n \t\t}\n@@ -1413,9 +1405,9 @@ regmove_optimize (f, nregs, regmove_dump_file)\n     }\n }\n \n-/* Returns the INSN_CODE for INSN if its pattern has matching constraints for\n-   any operand.  Returns -1 if INSN can't be recognized, or if the alternative\n-   can't be determined.\n+/* Returns nonzero if INSN's pattern has matching constraints for any operand.\n+   Returns 0 if INSN can't be recognized, or if the alternative can't be\n+   determined.\n \n    Initialize the info in MATCHP based on the constraints.  */\n \n@@ -1425,39 +1417,33 @@ find_matches (insn, matchp)\n      struct match *matchp;\n {\n   int likely_spilled[MAX_RECOG_OPERANDS];\n-  int operand_number;\n-  int insn_code_number = recog_memoized (insn);\n+  int op_no;\n   int any_matches = 0;\n \n-  if (insn_code_number < 0)\n-    return -1;\n-\n-  insn_extract (insn);\n-  if (! constrain_operands (insn_code_number, 0))\n-    return -1;\n+  extract_insn (insn);\n+  if (! constrain_operands (0))\n+    return 0;\n \n   /* Must initialize this before main loop, because the code for\n      the commutative case may set matches for operands other than\n      the current one.  */\n-  for (operand_number = insn_n_operands[insn_code_number];\n-       --operand_number >= 0; )\n-    matchp->with[operand_number] = matchp->commutative[operand_number] = -1;\n+  for (op_no = recog_n_operands; --op_no >= 0; )\n+    matchp->with[op_no] = matchp->commutative[op_no] = -1;\n \n-  for (operand_number = 0; operand_number < insn_n_operands[insn_code_number];\n-       operand_number++)\n+  for (op_no = 0; op_no < recog_n_operands; op_no++)\n     {\n       char *p, c;\n       int i = 0;\n \n-      p = insn_operand_constraint[insn_code_number][operand_number];\n+      p = recog_constraints[op_no];\n \n-      likely_spilled[operand_number] = 0;\n-      matchp->use[operand_number] = READ;\n-      matchp->early_clobber[operand_number] = 0;\n+      likely_spilled[op_no] = 0;\n+      matchp->use[op_no] = READ;\n+      matchp->early_clobber[op_no] = 0;\n       if (*p == '=')\n-\tmatchp->use[operand_number] = WRITE;\n+\tmatchp->use[op_no] = WRITE;\n       else if (*p == '+')\n-\tmatchp->use[operand_number] = READWRITE;\n+\tmatchp->use[op_no] = READWRITE;\n \n       for (;*p && i < which_alternative; p++)\n \tif (*p == ',')\n@@ -1471,32 +1457,32 @@ find_matches (insn, matchp)\n \t  case '+':\n \t    break;\n \t  case '&':\n-\t    matchp->early_clobber[operand_number] = 1;\n+\t    matchp->early_clobber[op_no] = 1;\n \t    break;\n \t  case '%':\n-\t    matchp->commutative[operand_number] = operand_number + 1;\n-\t    matchp->commutative[operand_number + 1] = operand_number;\n+\t    matchp->commutative[op_no] = op_no + 1;\n+\t    matchp->commutative[op_no + 1] = op_no;\n \t    break;\n \t  case '0': case '1': case '2': case '3': case '4':\n \t  case '5': case '6': case '7': case '8': case '9':\n \t    c -= '0';\n-\t    if (c < operand_number && likely_spilled[(unsigned char) c])\n+\t    if (c < op_no && likely_spilled[(unsigned char) c])\n \t      break;\n-\t    matchp->with[operand_number] = c;\n+\t    matchp->with[op_no] = c;\n \t    any_matches = 1;\n-\t    if (matchp->commutative[operand_number] >= 0)\n-\t      matchp->with[matchp->commutative[operand_number]] = c;\n+\t    if (matchp->commutative[op_no] >= 0)\n+\t      matchp->with[matchp->commutative[op_no]] = c;\n \t    break;\n \t  case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'h':\n \t  case 'j': case 'k': case 'l': case 'p': case 'q': case 't': case 'u':\n \t  case 'v': case 'w': case 'x': case 'y': case 'z': case 'A': case 'B':\n \t  case 'C': case 'D': case 'W': case 'Y': case 'Z':\n \t    if (CLASS_LIKELY_SPILLED_P (REG_CLASS_FROM_LETTER (c)))\n-\t      likely_spilled[operand_number] = 1;\n+\t      likely_spilled[op_no] = 1;\n \t    break;\n \t  }\n     }\n-  return any_matches ? insn_code_number : -1;\n+  return any_matches;\n }\n \n /* Try to replace output operand DST in SET, with input operand SRC.  SET is"}, {"sha": "dc1f4e44b32e8066f3ef9bc83bb673f0f27502ac", "filename": "gcc/reload.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=0eadeb15bc665b0bce3166ad2862f0a553cdd758", "patch": "@@ -2383,8 +2383,6 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   register int insn_code_number;\n   register int i, j;\n   int noperands;\n-  /* These are the constraints for the insn.  We don't change them.  */\n-  char *constraints1[MAX_RECOG_OPERANDS];\n   /* These start out as the constraints for the insn\n      and they are chewed up as we consider alternatives.  */\n   char *constraints[MAX_RECOG_OPERANDS];\n@@ -2488,8 +2486,6 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t noperands * sizeof (enum machine_mode));\n   bcopy ((char *) recog_constraints, (char *) constraints,\n \t noperands * sizeof (char *));\n-  bcopy ((char *) constraints, (char *) constraints1,\n-\t noperands * sizeof (char *));\n \n   commutative = -1;\n \n@@ -3360,7 +3356,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t   || modified[j] != RELOAD_WRITE)\n \t\t  && j != i\n \t\t  /* Ignore things like match_operator operands.  */\n-\t\t  && *constraints1[j] != 0\n+\t\t  && *recog_constraints[j] != 0\n \t\t  /* Don't count an input operand that is constrained to match\n \t\t     the early clobber operand.  */\n \t\t  && ! (this_alternative_matches[j] == i\n@@ -3477,7 +3473,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  pref_or_nothing[commutative] = pref_or_nothing[commutative + 1];\n \t  pref_or_nothing[commutative + 1] = t;\n \n-\t  bcopy ((char *) constraints1, (char *) constraints,\n+\t  bcopy ((char *) recog_constraints, (char *) constraints,\n \t\t noperands * sizeof (char *));\n \t  goto try_swapped;\n \t}\n@@ -3594,7 +3590,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  = find_reloads_toplev (force_const_mem (operand_mode[i],\n \t\t\t\t\t\t  recog_operand[i]),\n \t\t\t\t i, address_type[i], ind_levels, 0, insn);\n-\tif (alternative_allows_memconst (constraints1[i],\n+\tif (alternative_allows_memconst (recog_constraints[i],\n \t\t\t\t\t goal_alternative_number))\n \t  goal_alternative_win[i] = 1;\n       }"}, {"sha": "685d7830fa01082e832b4c6892c04e2d872c4617", "filename": "gcc/reload1.c", "status": "modified", "additions": 29, "deletions": 39, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=0eadeb15bc665b0bce3166ad2862f0a553cdd758", "patch": "@@ -4207,8 +4207,7 @@ reload_as_needed (live_known)\n \t\tfor (p = NEXT_INSN (prev); p != next; p = NEXT_INSN (p))\n \t\t  if (p != insn && GET_RTX_CLASS (GET_CODE (p)) == 'i'\n \t\t      && (recog_memoized (p) < 0\n-\t\t\t  || (insn_extract (p),\n-\t\t\t      ! constrain_operands (INSN_CODE (p), 1))))\n+\t\t\t  || (extract_insn (p), ! constrain_operands (1))))\n \t\t    {\n \t\t      error_for_asm (insn,\n \t\t\t\t     \"`asm' operand requires impossible reload\");\n@@ -7670,7 +7669,7 @@ gen_reload (out, in, opnum, type)\n \n \t It might be better not to actually emit the insn unless it is valid,\n \t but we need to pass the insn as an operand to `recog' and\n-\t `insn_extract' and it is simpler to emit and then delete the insn if\n+\t `extract_insn' and it is simpler to emit and then delete the insn if\n \t not valid than to dummy things up.  */\n \n       rtx op0, op1, tem, insn;\n@@ -7698,11 +7697,11 @@ gen_reload (out, in, opnum, type)\n \n       if (code >= 0)\n \t{\n-\t  insn_extract (insn);\n+\t  extract_insn (insn);\n \t  /* We want constrain operands to treat this insn strictly in\n \t     its validity determination, i.e., the way it would after reload\n \t     has completed.  */\n-\t  if (constrain_operands (code, 1))\n+\t  if (constrain_operands (1))\n \t    return insn;\n \t}\n \n@@ -7740,11 +7739,11 @@ gen_reload (out, in, opnum, type)\n \n       if (code >= 0)\n \t{\n-\t  insn_extract (insn);\n+\t  extract_insn (insn);\n \t  /* We want constrain operands to treat this insn strictly in\n \t     its validity determination, i.e., the way it would after reload\n \t     has completed.  */\n-\t  if (constrain_operands (code, 1))\n+\t  if (constrain_operands (1))\n \t    {\n \t      /* Add a REG_EQUIV note so that find_equiv_reg can find it.  */\n \t      REG_NOTES (insn)\n@@ -8181,8 +8180,8 @@ inc_for_reload (reloadreg, in, value, inc_amount)\n       code = recog_memoized (add_insn);\n       if (code >= 0)\n \t{\n-\t  insn_extract (add_insn);\n-\t  if (constrain_operands (code, 1))\n+\t  extract_insn (add_insn);\n+\t  if (constrain_operands (1))\n \t    {\n \t      /* If this is a pre-increment and we have incremented the value\n \t\t where it lives, copy the incremented value to RELOADREG to\n@@ -9005,7 +9004,6 @@ reload_cse_simplify_operands (insn)\n      rtx insn;\n {\n #ifdef REGISTER_CONSTRAINTS\n-  int insn_code_number, n_operands, n_alternatives;\n   int i,j;\n \n   char *constraints[MAX_RECOG_OPERANDS];\n@@ -9023,41 +9021,33 @@ reload_cse_simplify_operands (insn)\n   int *alternative_order;\n   rtx reg = gen_rtx_REG (VOIDmode, -1);\n   \n-  /* Find out some information about this insn.  */\n-  insn_code_number = recog_memoized (insn);\n-  /* We don't modify asm instructions.  */\n-  if (insn_code_number < 0)\n-    return 0;\n+  extract_insn (insn);\n \n-  n_operands = insn_n_operands[insn_code_number];\n-  n_alternatives = insn_n_alternatives[insn_code_number];\n-  \n-  if (n_alternatives == 0 || n_operands == 0)\n+  if (recog_n_alternatives == 0 || recog_n_operands == 0)\n     return 0;\n-  insn_extract (insn);\n \n   /* Figure out which alternative currently matches.  */\n-  if (! constrain_operands (insn_code_number, 1))\n+  if (! constrain_operands (1))\n     fatal_insn_not_found (insn);\n \n-  alternative_reject = (int *) alloca (n_alternatives * sizeof (int));\n-  alternative_nregs = (int *) alloca (n_alternatives * sizeof (int));\n-  alternative_order = (int *) alloca (n_alternatives * sizeof (int));\n-  bzero ((char *)alternative_reject, n_alternatives * sizeof (int));\n-  bzero ((char *)alternative_nregs, n_alternatives * sizeof (int));\n+  alternative_reject = (int *) alloca (recog_n_alternatives * sizeof (int));\n+  alternative_nregs = (int *) alloca (recog_n_alternatives * sizeof (int));\n+  alternative_order = (int *) alloca (recog_n_alternatives * sizeof (int));\n+  bzero ((char *)alternative_reject, recog_n_alternatives * sizeof (int));\n+  bzero ((char *)alternative_nregs, recog_n_alternatives * sizeof (int));\n \n-  for (i = 0; i < n_operands; i++)\n+  for (i = 0; i < recog_n_operands; i++)\n     {\n       enum machine_mode mode;\n       int regno;\n       char *p;\n \n-      op_alt_regno[i] = (int *) alloca (n_alternatives * sizeof (int));\n-      for (j = 0; j < n_alternatives; j++)\n+      op_alt_regno[i] = (int *) alloca (recog_n_alternatives * sizeof (int));\n+      for (j = 0; j < recog_n_alternatives; j++)\n \top_alt_regno[i][j] = -1;\n \n-      p = constraints[i] = insn_operand_constraint[insn_code_number][i];\n-      mode = insn_operand_mode[insn_code_number][i];\n+      p = constraints[i] = recog_constraints[i];\n+      mode = recog_operand_mode[i];\n \n       /* Add the reject values for each alternative given by the constraints\n \t for this operand.  */\n@@ -9152,21 +9142,21 @@ reload_cse_simplify_operands (insn)\n \n   /* Record all alternatives which are better or equal to the currently\n      matching one in the alternative_order array.  */\n-  for (i = j = 0; i < n_alternatives; i++)\n+  for (i = j = 0; i < recog_n_alternatives; i++)\n     if (alternative_reject[i] <= alternative_reject[which_alternative])\n       alternative_order[j++] = i;\n-  n_alternatives = j;\n+  recog_n_alternatives = j;\n \n   /* Sort it.  Given a small number of alternatives, a dumb algorithm\n      won't hurt too much.  */\n-  for (i = 0; i < n_alternatives - 1; i++)\n+  for (i = 0; i < recog_n_alternatives - 1; i++)\n     {\n       int best = i;\n       int best_reject = alternative_reject[alternative_order[i]];\n       int best_nregs = alternative_nregs[alternative_order[i]];\n       int tmp;\n \n-      for (j = i + 1; j < n_alternatives; j++)\n+      for (j = i + 1; j < recog_n_alternatives; j++)\n \t{\n \t  int this_reject = alternative_reject[alternative_order[j]];\n \t  int this_nregs = alternative_nregs[alternative_order[j]];\n@@ -9192,20 +9182,20 @@ reload_cse_simplify_operands (insn)\n   /* Pop back to the real obstacks while changing the insn.  */\n   pop_obstacks ();\n \n-  for (i = 0; i < n_operands; i++)\n+  for (i = 0; i < recog_n_operands; i++)\n     {\n-      enum machine_mode mode = insn_operand_mode[insn_code_number][i];\n+      enum machine_mode mode = recog_operand_mode[i];\n       if (op_alt_regno[i][j] == -1)\n \tcontinue;\n \n       validate_change (insn, recog_operand_loc[i],\n \t\t       gen_rtx_REG (mode, op_alt_regno[i][j]), 1);\n     }\n \n-  for (i = insn_n_dups[insn_code_number] - 1; i >= 0; i--)\n+  for (i = recog_n_dups - 1; i >= 0; i--)\n     {\n       int op = recog_dup_num[i];\n-      enum machine_mode mode = insn_operand_mode[insn_code_number][op];\n+      enum machine_mode mode = recog_operand_mode[op];\n \n       if (op_alt_regno[op][j] == -1)\n \tcontinue;"}, {"sha": "7fac18c720e542fd0a9af6321af068488eb0e7a7", "filename": "gcc/reorg.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eadeb15bc665b0bce3166ad2862f0a553cdd758/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=0eadeb15bc665b0bce3166ad2862f0a553cdd758", "patch": "@@ -3875,8 +3875,7 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \t\t\t\t   insn);\n \n \t  if (recog_memoized (ninsn) < 0\n-\t      || (insn_extract (ninsn),\n-\t\t  ! constrain_operands (INSN_CODE (ninsn), 1)))\n+\t      || (extract_insn (ninsn), ! constrain_operands (1)))\n \t    {\n \t      delete_insn (ninsn);\n \t      return 0;"}]}