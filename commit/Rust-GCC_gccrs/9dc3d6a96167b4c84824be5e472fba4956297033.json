{"sha": "9dc3d6a96167b4c84824be5e472fba4956297033", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRjM2Q2YTk2MTY3YjRjODQ4MjRiZTVlNDcyZmJhNDk1NjI5NzAzMw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-08-29T14:12:44Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-08-29T14:12:44Z"}, "message": "Make expansion of balanced binary trees of switches on tree level.\n\n2017-08-29  Martin Liska  <mliska@suse.cz>\n\n\t* passes.def: Include pass_lower_switch.\n\t* stmt.c (dump_case_nodes): Remove and move to\n\ttree-switch-conversion.\n\t(case_values_threshold): Likewise.\n\t(expand_switch_as_decision_tree_p): Likewise.\n\t(emit_case_decision_tree): Likewise.\n\t(expand_case): Likewise.\n\t(balance_case_nodes): Likewise.\n\t(node_has_low_bound): Likewise.\n\t(node_has_high_bound): Likewise.\n\t(node_is_bounded): Likewise.\n\t(emit_case_nodes): Likewise.\n\t(struct simple_case_node): New struct.\n\t(add_case_node): Remove.\n\t(emit_case_dispatch_table): Use vector instead of case_list.\n\t(reset_out_edges_aux): Remove.\n\t(compute_cases_per_edge): Likewise.\n\t(expand_case): Build list of simple_case_node.\n\t(expand_sjlj_dispatch_table): Use it.\n\t* tree-switch-conversion.c (struct case_node): Moved from\n\tstmt.c and adjusted.\n\t(emit_case_nodes): Likewise.\n\t(node_has_low_bound): Likewise.\n\t(node_has_high_bound): Likewise.\n\t(node_is_bounded): Likewise.\n\t(case_values_threshold): Likewise.\n\t(reset_out_edges_aux): Likewise.\n\t(compute_cases_per_edge): Likewise.\n\t(add_case_node): Likewise.\n\t(dump_case_nodes): Likewise.\n\t(balance_case_nodes): Likewise.\n\t(expand_switch_as_decision_tree_p): Likewise.\n\t(emit_jump): Likewise.\n\t(emit_case_decision_tree): Likewise.\n\t(try_switch_expansion): Likewise.\n\t(do_jump_if_equal): Likewise.\n\t(emit_cmp_and_jump_insns): Likewise.\n\t(fix_phi_operands_for_edge): New function.\n\t(record_phi_operand_mapping): Likewise.\n\t(class pass_lower_switch): New pass.\n\t(pass_lower_switch::execute): New function.\n\t(make_pass_lower_switch): Likewise.\n\t(conditional_probability):\n\t* timevar.def: Add TV_TREE_SWITCH_LOWERING.\n\t* tree-pass.h: Add make_pass_lower_switch.\n2017-08-29  Martin Liska  <mliska@suse.cz>\n\n\t* gcc.dg/tree-prof/update-loopch.c: Scan patterns in\n\tswitchlower.\n\t* gcc.dg/tree-ssa/vrp104.c: Likewise.\n\nFrom-SVN: r251412", "tree": {"sha": "92bc4b549c7dc2a51066020e0e7c1f5c7585c8ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92bc4b549c7dc2a51066020e0e7c1f5c7585c8ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9dc3d6a96167b4c84824be5e472fba4956297033", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dc3d6a96167b4c84824be5e472fba4956297033", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dc3d6a96167b4c84824be5e472fba4956297033", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dc3d6a96167b4c84824be5e472fba4956297033/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "10bcba61fcfb0cd7f7a2ba64f1a14c62e3512eca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10bcba61fcfb0cd7f7a2ba64f1a14c62e3512eca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10bcba61fcfb0cd7f7a2ba64f1a14c62e3512eca"}], "stats": {"total": 2273, "additions": 1273, "deletions": 1000}, "files": [{"sha": "7fc2f55e1a8e338e59a045eb7f7b1da3ee0fcfbb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc3d6a96167b4c84824be5e472fba4956297033/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc3d6a96167b4c84824be5e472fba4956297033/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9dc3d6a96167b4c84824be5e472fba4956297033", "patch": "@@ -1,3 +1,51 @@\n+2017-08-29  Martin Liska  <mliska@suse.cz>\n+\n+\t* passes.def: Include pass_lower_switch.\n+\t* stmt.c (dump_case_nodes): Remove and move to\n+\ttree-switch-conversion.\n+\t(case_values_threshold): Likewise.\n+\t(expand_switch_as_decision_tree_p): Likewise.\n+\t(emit_case_decision_tree): Likewise.\n+\t(expand_case): Likewise.\n+\t(balance_case_nodes): Likewise.\n+\t(node_has_low_bound): Likewise.\n+\t(node_has_high_bound): Likewise.\n+\t(node_is_bounded): Likewise.\n+\t(emit_case_nodes): Likewise.\n+\t(struct simple_case_node): New struct.\n+\t(add_case_node): Remove.\n+\t(emit_case_dispatch_table): Use vector instead of case_list.\n+\t(reset_out_edges_aux): Remove.\n+\t(compute_cases_per_edge): Likewise.\n+\t(expand_case): Build list of simple_case_node.\n+\t(expand_sjlj_dispatch_table): Use it.\n+\t* tree-switch-conversion.c (struct case_node): Moved from\n+\tstmt.c and adjusted.\n+\t(emit_case_nodes): Likewise.\n+\t(node_has_low_bound): Likewise.\n+\t(node_has_high_bound): Likewise.\n+\t(node_is_bounded): Likewise.\n+\t(case_values_threshold): Likewise.\n+\t(reset_out_edges_aux): Likewise.\n+\t(compute_cases_per_edge): Likewise.\n+\t(add_case_node): Likewise.\n+\t(dump_case_nodes): Likewise.\n+\t(balance_case_nodes): Likewise.\n+\t(expand_switch_as_decision_tree_p): Likewise.\n+\t(emit_jump): Likewise.\n+\t(emit_case_decision_tree): Likewise.\n+\t(try_switch_expansion): Likewise.\n+\t(do_jump_if_equal): Likewise.\n+\t(emit_cmp_and_jump_insns): Likewise.\n+\t(fix_phi_operands_for_edge): New function.\n+\t(record_phi_operand_mapping): Likewise.\n+\t(class pass_lower_switch): New pass.\n+\t(pass_lower_switch::execute): New function.\n+\t(make_pass_lower_switch): Likewise.\n+\t(conditional_probability):\n+\t* timevar.def: Add TV_TREE_SWITCH_LOWERING.\n+\t* tree-pass.h: Add make_pass_lower_switch.\n+\n 2017-08-29  Jozef Lawrynowicz  <jozef.l@somniumtech.com>\n \n \tPR target/80993"}, {"sha": "81b6e62f60226ea2f1c799e7a0c31097787dafa2", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc3d6a96167b4c84824be5e472fba4956297033/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc3d6a96167b4c84824be5e472fba4956297033/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=9dc3d6a96167b4c84824be5e472fba4956297033", "patch": "@@ -394,6 +394,7 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_lower_vaarg);\n   NEXT_PASS (pass_lower_vector);\n   NEXT_PASS (pass_lower_complex_O0);\n+  NEXT_PASS (pass_lower_switch);\n   NEXT_PASS (pass_sancov_O0);\n   NEXT_PASS (pass_asan_O0);\n   NEXT_PASS (pass_tsan_O0);"}, {"sha": "39d29ff3da9adb81d776172853e63be67a06a113", "filename": "gcc/stmt.c", "status": "modified", "additions": 32, "deletions": 994, "changes": 1026, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc3d6a96167b4c84824be5e472fba4956297033/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc3d6a96167b4c84824be5e472fba4956297033/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=9dc3d6a96167b4c84824be5e472fba4956297033", "patch": "@@ -32,7 +32,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple.h\"\n #include \"cfghooks.h\"\n #include \"predict.h\"\n-#include \"alloc-pool.h\"\n #include \"memmodel.h\"\n #include \"tm_p.h\"\n #include \"optabs.h\"\n@@ -63,53 +62,30 @@ along with GCC; see the file COPYING3.  If not see\n    as in C, the high and low limits are the same.\n \n    We start with a vector of case nodes sorted in ascending order, and\n-   the default label as the last element in the vector.  Before expanding\n-   to RTL, we transform this vector into a list linked via the RIGHT\n-   fields in the case_node struct.  Nodes with higher case values are\n-   later in the list.\n-\n-   Switch statements can be output in three forms.  A branch table is\n-   used if there are more than a few labels and the labels are dense\n-   within the range between the smallest and largest case value.  If a\n-   branch table is used, no further manipulations are done with the case\n-   node chain.\n-\n-   The alternative to the use of a branch table is to generate a series\n-   of compare and jump insns.  When that is done, we use the LEFT, RIGHT,\n-   and PARENT fields to hold a binary tree.  Initially the tree is\n-   totally unbalanced, with everything on the right.  We balance the tree\n-   with nodes on the left having lower case values than the parent\n-   and nodes on the right having higher values.  We then output the tree\n-   in order.\n-\n-   For very small, suitable switch statements, we can generate a series\n-   of simple bit test and branches instead.  */\n-\n-struct case_node\n+   the default label as the last element in the vector.\n+\n+   Switch statements are expanded in jump table form.\n+\n+*/\n+\n+struct simple_case_node\n {\n-  struct case_node\t*left;\t/* Left son in binary tree */\n-  struct case_node\t*right;\t/* Right son in binary tree; also node chain */\n-  struct case_node\t*parent; /* Parent of node in binary tree */\n-  tree\t\t\tlow;\t/* Lowest index value for this label */\n-  tree\t\t\thigh;\t/* Highest index value for this label */\n-  tree\t\t\tcode_label; /* Label to jump to when node matches */\n-  profile_probability   prob; /* Probability of taking this case.  */\n-  /* Probability of reaching subtree rooted at this node */\n-  profile_probability   subtree_prob;\n+  simple_case_node (tree low, tree high, tree code_label):\n+    m_low (low), m_high (high), m_code_label (code_label)\n+  {}\n+\n+  /* Lowest index value for this label.  */\n+  tree m_low;\n+  /* Highest index value for this label.  */\n+  tree m_high;\n+  /* Label to jump to when node matches.  */\n+  tree m_code_label;\n };\n \n-typedef struct case_node *case_node_ptr;\n-\n extern basic_block label_to_block_fn (struct function *, tree);\n \f\n static bool check_unique_operand_names (tree, tree, tree);\n static char *resolve_operand_name_1 (char *, tree, tree, tree);\n-static void balance_case_nodes (case_node_ptr *, case_node_ptr);\n-static int node_has_low_bound (case_node_ptr, tree);\n-static int node_has_high_bound (case_node_ptr, tree);\n-static int node_is_bounded (case_node_ptr, tree);\n-static void emit_case_nodes (rtx, case_node_ptr, rtx_code_label *,\n-\t\t\t     profile_probability, tree);\n \f\n /* Return the rtx-label that corresponds to a LABEL_DECL,\n    creating it if necessary.  */\n@@ -711,195 +687,6 @@ do_jump_if_equal (machine_mode mode, rtx op0, rtx op1, rtx_code_label *label,\n \t\t\t   NULL_RTX, NULL, label, prob);\n }\n \f\n-/* Do the insertion of a case label into case_list.  The labels are\n-   fed to us in descending order from the sorted vector of case labels used\n-   in the tree part of the middle end.  So the list we construct is\n-   sorted in ascending order.\n-   \n-   LABEL is the case label to be inserted. LOW and HIGH are the bounds\n-   against which the index is compared to jump to LABEL and PROB is the\n-   estimated probability LABEL is reached from the switch statement.  */\n-\n-static struct case_node *\n-add_case_node (struct case_node *head, tree low, tree high,\n-\t       tree label, profile_probability prob,\n-\t       object_allocator<case_node> &case_node_pool)\n-{\n-  struct case_node *r;\n-\n-  gcc_checking_assert (low);\n-  gcc_checking_assert (high && (TREE_TYPE (low) == TREE_TYPE (high)));\n-\n-  /* Add this label to the chain.  */\n-  r = case_node_pool.allocate ();\n-  r->low = low;\n-  r->high = high;\n-  r->code_label = label;\n-  r->parent = r->left = NULL;\n-  r->prob = prob;\n-  r->subtree_prob = prob;\n-  r->right = head;\n-  return r;\n-}\n-\f\n-/* Dump ROOT, a list or tree of case nodes, to file.  */\n-\n-static void\n-dump_case_nodes (FILE *f, struct case_node *root,\n-\t\t int indent_step, int indent_level)\n-{\n-  if (root == 0)\n-    return;\n-  indent_level++;\n-\n-  dump_case_nodes (f, root->left, indent_step, indent_level);\n-\n-  fputs (\";; \", f);\n-  fprintf (f, \"%*s\", indent_step * indent_level, \"\");\n-  print_dec (root->low, f, TYPE_SIGN (TREE_TYPE (root->low)));\n-  if (!tree_int_cst_equal (root->low, root->high))\n-    {\n-      fprintf (f, \" ... \");\n-      print_dec (root->high, f, TYPE_SIGN (TREE_TYPE (root->high)));\n-    }\n-  fputs (\"\\n\", f);\n-\n-  dump_case_nodes (f, root->right, indent_step, indent_level);\n-}\n-\f\n-/* Return the smallest number of different values for which it is best to use a\n-   jump-table instead of a tree of conditional branches.  */\n-\n-static unsigned int\n-case_values_threshold (void)\n-{\n-  unsigned int threshold = PARAM_VALUE (PARAM_CASE_VALUES_THRESHOLD);\n-\n-  if (threshold == 0)\n-    threshold = targetm.case_values_threshold ();\n-\n-  return threshold;\n-}\n-\n-/* Return true if a switch should be expanded as a decision tree.\n-   RANGE is the difference between highest and lowest case.\n-   UNIQ is number of unique case node targets, not counting the default case.\n-   COUNT is the number of comparisons needed, not counting the default case.  */\n-\n-static bool\n-expand_switch_as_decision_tree_p (tree range,\n-\t\t\t\t  unsigned int uniq ATTRIBUTE_UNUSED,\n-\t\t\t\t  unsigned int count)\n-{\n-  int max_ratio;\n-\n-  /* If neither casesi or tablejump is available, or flag_jump_tables\n-     over-ruled us, we really have no choice.  */\n-  if (!targetm.have_casesi () && !targetm.have_tablejump ())\n-    return true;\n-  if (!flag_jump_tables)\n-    return true;\n-#ifndef ASM_OUTPUT_ADDR_DIFF_ELT\n-  if (flag_pic)\n-    return true;\n-#endif\n-\n-  /* If the switch is relatively small such that the cost of one\n-     indirect jump on the target are higher than the cost of a\n-     decision tree, go with the decision tree.\n-\n-     If range of values is much bigger than number of values,\n-     or if it is too large to represent in a HOST_WIDE_INT,\n-     make a sequence of conditional branches instead of a dispatch.\n-\n-     The definition of \"much bigger\" depends on whether we are\n-     optimizing for size or for speed.  If the former, the maximum\n-     ratio range/count = 3, because this was found to be the optimal\n-     ratio for size on i686-pc-linux-gnu, see PR11823.  The ratio\n-     10 is much older, and was probably selected after an extensive\n-     benchmarking investigation on numerous platforms.  Or maybe it\n-     just made sense to someone at some point in the history of GCC,\n-     who knows...  */\n-  max_ratio = optimize_insn_for_size_p () ? 3 : 10;\n-  if (count < case_values_threshold ()\n-      || ! tree_fits_uhwi_p (range)\n-      || compare_tree_int (range, max_ratio * count) > 0)\n-    return true;\n-\n-  return false;\n-}\n-\n-/* Generate a decision tree, switching on INDEX_EXPR and jumping to\n-   one of the labels in CASE_LIST or to the DEFAULT_LABEL.\n-   DEFAULT_PROB is the estimated probability that it jumps to\n-   DEFAULT_LABEL.\n-   \n-   We generate a binary decision tree to select the appropriate target\n-   code.  This is done as follows:\n-\n-     If the index is a short or char that we do not have\n-     an insn to handle comparisons directly, convert it to\n-     a full integer now, rather than letting each comparison\n-     generate the conversion.\n-\n-     Load the index into a register.\n-\n-     The list of cases is rearranged into a binary tree,\n-     nearly optimal assuming equal probability for each case.\n-\n-     The tree is transformed into RTL, eliminating redundant\n-     test conditions at the same time.\n-\n-     If program flow could reach the end of the decision tree\n-     an unconditional jump to the default code is emitted.\n-\n-   The above process is unaware of the CFG.  The caller has to fix up\n-   the CFG itself.  This is done in cfgexpand.c.  */     \n-\n-static void\n-emit_case_decision_tree (tree index_expr, tree index_type,\n-\t\t\t case_node_ptr case_list, rtx_code_label *default_label,\n-\t\t\t profile_probability default_prob)\n-{\n-  rtx index = expand_normal (index_expr);\n-\n-  if (GET_MODE_CLASS (GET_MODE (index)) == MODE_INT\n-      && ! have_insn_for (COMPARE, GET_MODE (index)))\n-    {\n-      int unsignedp = TYPE_UNSIGNED (index_type);\n-      machine_mode wider_mode;\n-      for (wider_mode = GET_MODE (index); wider_mode != VOIDmode;\n-\t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n-\tif (have_insn_for (COMPARE, wider_mode))\n-\t  {\n-\t    index = convert_to_mode (wider_mode, index, unsignedp);\n-\t    break;\n-\t  }\n-    }\n-\n-  do_pending_stack_adjust ();\n-\n-  if (MEM_P (index))\n-    {\n-      index = copy_to_reg (index);\n-      if (TREE_CODE (index_expr) == SSA_NAME)\n-\tset_reg_attrs_for_decl_rtl (index_expr, index);\n-    }\n-\n-  balance_case_nodes (&case_list, NULL);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      int indent_step = ceil_log2 (TYPE_PRECISION (index_type)) + 2;\n-      fprintf (dump_file, \";; Expanding GIMPLE switch as decision tree:\\n\");\n-      dump_case_nodes (dump_file, case_list, indent_step, 0);\n-    }\n-\n-  emit_case_nodes (index, case_list, default_label, default_prob, index_type);\n-  if (default_label)\n-    emit_jump (default_label);\n-}\n-\n /* Return the sum of probabilities of outgoing edges of basic block BB.  */\n \n static profile_probability\n@@ -944,14 +731,14 @@ conditional_probability (profile_probability target_prob,\n \n static void\n emit_case_dispatch_table (tree index_expr, tree index_type,\n-\t\t\t  struct case_node *case_list, rtx default_label,\n+\t\t\t  auto_vec<simple_case_node> &case_list,\n+\t\t\t  rtx default_label,\n \t\t\t  edge default_edge,  tree minval, tree maxval,\n \t\t\t  tree range, basic_block stmt_bb)\n {\n   int i, ncases;\n-  struct case_node *n;\n   rtx *labelvec;\n-  rtx_insn *fallback_label = label_rtx (case_list->code_label);\n+  rtx_insn *fallback_label = label_rtx (case_list[0].m_code_label);\n   rtx_code_label *table_label = gen_label_rtx ();\n   bool has_gaps = false;\n   profile_probability default_prob = default_edge ? default_edge->probability\n@@ -986,22 +773,23 @@ emit_case_dispatch_table (tree index_expr, tree index_type,\n   labelvec = XALLOCAVEC (rtx, ncases);\n   memset (labelvec, 0, ncases * sizeof (rtx));\n \n-  for (n = case_list; n; n = n->right)\n+  for (unsigned j = 0; j < case_list.length (); j++)\n     {\n+      simple_case_node *n = &case_list[j];\n       /* Compute the low and high bounds relative to the minimum\n \t value since that should fit in a HOST_WIDE_INT while the\n \t actual values may not.  */\n       HOST_WIDE_INT i_low\n \t= tree_to_uhwi (fold_build2 (MINUS_EXPR, index_type,\n-\t\t\t\t     n->low, minval));\n+\t\t\t\t     n->m_low, minval));\n       HOST_WIDE_INT i_high\n \t= tree_to_uhwi (fold_build2 (MINUS_EXPR, index_type,\n-\t\t\t\t     n->high, minval));\n+\t\t\t\t     n->m_high, minval));\n       HOST_WIDE_INT i;\n \n       for (i = i_low; i <= i_high; i ++)\n \tlabelvec[i]\n-\t  = gen_rtx_LABEL_REF (Pmode, label_rtx (n->code_label));\n+\t  = gen_rtx_LABEL_REF (Pmode, label_rtx (n->m_code_label));\n     }\n \n   /* The dispatch table may contain gaps, including at the beginning of\n@@ -1073,36 +861,6 @@ emit_case_dispatch_table (tree index_expr, tree index_type,\n   emit_barrier ();\n }\n \n-/* Reset the aux field of all outgoing edges of basic block BB.  */\n-\n-static inline void\n-reset_out_edges_aux (basic_block bb)\n-{\n-  edge e;\n-  edge_iterator ei;\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    e->aux = (void *)0;\n-}\n-\n-/* Compute the number of case labels that correspond to each outgoing edge of\n-   STMT. Record this information in the aux field of the edge.  */\n-\n-static inline void\n-compute_cases_per_edge (gswitch *stmt)\n-{\n-  basic_block bb = gimple_bb (stmt);\n-  reset_out_edges_aux (bb);\n-  int ncases = gimple_switch_num_labels (stmt);\n-  for (int i = ncases - 1; i >= 1; --i)\n-    {\n-      tree elt = gimple_switch_label (stmt, i);\n-      tree lab = CASE_LABEL (elt);\n-      basic_block case_bb = label_to_block_fn (cfun, lab);\n-      edge case_edge = find_edge (bb, case_bb);\n-      case_edge->aux = (void *)((intptr_t)(case_edge->aux) + 1);\n-    }\n-}\n-\n /* Terminate a case Ada or switch (C) statement\n    in which ORIG_INDEX is the expression to be tested.\n    If ORIG_TYPE is not NULL, it is the original ORIG_INDEX\n@@ -1114,20 +872,15 @@ expand_case (gswitch *stmt)\n {\n   tree minval = NULL_TREE, maxval = NULL_TREE, range = NULL_TREE;\n   rtx_code_label *default_label;\n-  unsigned int count, uniq;\n+  unsigned int count;\n   int i;\n   int ncases = gimple_switch_num_labels (stmt);\n   tree index_expr = gimple_switch_index (stmt);\n   tree index_type = TREE_TYPE (index_expr);\n   tree elt;\n   basic_block bb = gimple_bb (stmt);\n \n-  /* A list of case labels; it is first built as a list and it may then\n-     be rearranged into a nearly balanced binary tree.  */\n-  struct case_node *case_list = 0;\n-\n-  /* A pool for case nodes.  */\n-  object_allocator<case_node> case_node_pool (\"struct case_node pool\");\n+  auto_vec<simple_case_node> case_list;\n \n   /* An ERROR_MARK occurs for various reasons including invalid data type.\n      ??? Can this still happen, with GIMPLE and all?  */\n@@ -1149,7 +902,6 @@ expand_case (gswitch *stmt)\n   default_label = jump_target_rtx (default_lab);\n   basic_block default_bb = label_to_block_fn (cfun, default_lab);\n   edge default_edge = find_edge (bb, default_bb);\n-  profile_probability default_prob = default_edge->probability;\n \n   /* Get upper and lower bounds of case values.  */\n   elt = gimple_switch_label (stmt, 1);\n@@ -1165,10 +917,7 @@ expand_case (gswitch *stmt)\n \n   /* Listify the labels queue and gather some numbers to decide\n      how to expand this switch().  */\n-  uniq = 0;\n   count = 0;\n-  hash_set<tree> seen_labels;\n-  compute_cases_per_edge (stmt);\n \n   for (i = ncases - 1; i >= 1; --i)\n     {\n@@ -1185,11 +934,6 @@ expand_case (gswitch *stmt)\n       if (high)\n \tcount++;\n \n-      /* If we have not seen this label yet, then increase the\n-\t number of unique case node targets seen.  */\n-      if (!seen_labels.add (lab))\n-\tuniq++;\n-\n       /* The bounds on the case range, LOW and HIGH, have to be converted\n \t to case's index type TYPE.  Note that the original type of the\n \t case index in the source code is usually \"lost\" during\n@@ -1208,14 +952,8 @@ expand_case (gswitch *stmt)\n       if (TREE_OVERFLOW (high))\n \thigh = wide_int_to_tree (index_type, high);\n \n-      basic_block case_bb = label_to_block_fn (cfun, lab);\n-      edge case_edge = find_edge (bb, case_bb);\n-      case_list = add_case_node (\n-          case_list, low, high, lab,\n-          case_edge->probability.apply_scale (1, (intptr_t)(case_edge->aux)),\n-          case_node_pool);\n+      case_list.safe_push (simple_case_node (low, high, lab));\n     }\n-  reset_out_edges_aux (bb);\n \n   /* cleanup_tree_cfg removes all SWITCH_EXPR with a single\n      destination, such as one with a default case only.\n@@ -1229,11 +967,6 @@ expand_case (gswitch *stmt)\n      The two options at this point are a dispatch table (casesi or\n      tablejump) or a decision tree.  */\n \n-  if (expand_switch_as_decision_tree_p (range, uniq, count))\n-    emit_case_decision_tree (index_expr, index_type,\n-                             case_list, default_label,\n-                             default_prob);\n-  else\n     {\n       /* If the default case is unreachable, then set default_label to NULL\n \t so that we omit the range check when generating the dispatch table.\n@@ -1320,8 +1053,7 @@ expand_sjlj_dispatch_table (rtx dispatch_index,\n   else\n     {\n       /* Similar to expand_case, but much simpler.  */\n-      struct case_node *case_list = 0;\n-      object_allocator<case_node> case_node_pool (\"struct sjlj_case pool\");\n+      auto_vec<simple_case_node> case_list;\n       tree index_expr = make_tree (index_type, dispatch_index);\n       tree minval = build_int_cst (index_type, 0);\n       tree maxval = CASE_LOW (dispatch_table.last ());\n@@ -1331,12 +1063,9 @@ expand_sjlj_dispatch_table (rtx dispatch_index,\n       for (int i = ncases - 1; i >= 0; --i)\n \t{\n \t  tree elt = dispatch_table[i];\n-\t  tree low = CASE_LOW (elt);\n-\t  tree lab = CASE_LABEL (elt);\n-\t  case_list = add_case_node (case_list, low, low, lab,\n-\t\t\t\t     profile_probability::guessed_always ()\n-\t\t\t\t\t.apply_scale (1, ncases),\n-\t\t\t\t     case_node_pool);\n+\t  case_list.safe_push (simple_case_node (CASE_LOW (elt),\n+\t\t\t\t\t\t CASE_HIGH (elt),\n+\t\t\t\t\t\t CASE_LABEL (elt)));\n \t}\n \n       emit_case_dispatch_table (index_expr, index_type,\n@@ -1355,694 +1084,3 @@ expand_sjlj_dispatch_table (rtx dispatch_index,\n }\n \n \f\n-/* Take an ordered list of case nodes\n-   and transform them into a near optimal binary tree,\n-   on the assumption that any target code selection value is as\n-   likely as any other.\n-\n-   The transformation is performed by splitting the ordered\n-   list into two equal sections plus a pivot.  The parts are\n-   then attached to the pivot as left and right branches.  Each\n-   branch is then transformed recursively.  */\n-\n-static void\n-balance_case_nodes (case_node_ptr *head, case_node_ptr parent)\n-{\n-  case_node_ptr np;\n-\n-  np = *head;\n-  if (np)\n-    {\n-      int i = 0;\n-      int ranges = 0;\n-      case_node_ptr *npp;\n-      case_node_ptr left;\n-\n-      /* Count the number of entries on branch.  Also count the ranges.  */\n-\n-      while (np)\n-\t{\n-\t  if (!tree_int_cst_equal (np->low, np->high))\n-\t    ranges++;\n-\n-\t  i++;\n-\t  np = np->right;\n-\t}\n-\n-      if (i > 2)\n-\t{\n-\t  /* Split this list if it is long enough for that to help.  */\n-\t  npp = head;\n-\t  left = *npp;\n-\n-\t  /* If there are just three nodes, split at the middle one.  */\n-\t  if (i == 3)\n-\t    npp = &(*npp)->right;\n-\t  else\n-\t    {\n-\t      /* Find the place in the list that bisects the list's total cost,\n-\t\t where ranges count as 2.\n-\t\t Here I gets half the total cost.  */\n-\t      i = (i + ranges + 1) / 2;\n-\t      while (1)\n-\t\t{\n-\t\t  /* Skip nodes while their cost does not reach that amount.  */\n-\t\t  if (!tree_int_cst_equal ((*npp)->low, (*npp)->high))\n-\t\t    i--;\n-\t\t  i--;\n-\t\t  if (i <= 0)\n-\t\t    break;\n-\t\t  npp = &(*npp)->right;\n-\t\t}\n-\t    }\n-\t  *head = np = *npp;\n-\t  *npp = 0;\n-\t  np->parent = parent;\n-\t  np->left = left;\n-\n-\t  /* Optimize each of the two split parts.  */\n-\t  balance_case_nodes (&np->left, np);\n-\t  balance_case_nodes (&np->right, np);\n-          np->subtree_prob = np->prob;\n-          np->subtree_prob += np->left->subtree_prob;\n-          np->subtree_prob += np->right->subtree_prob;\n-\t}\n-      else\n-\t{\n-\t  /* Else leave this branch as one level,\n-\t     but fill in `parent' fields.  */\n-\t  np = *head;\n-\t  np->parent = parent;\n-          np->subtree_prob = np->prob;\n-\t  for (; np->right; np = np->right)\n-            {\n-\t      np->right->parent = np;\n-              (*head)->subtree_prob += np->right->subtree_prob;\n-            }\n-\t}\n-    }\n-}\n-\f\n-/* Search the parent sections of the case node tree\n-   to see if a test for the lower bound of NODE would be redundant.\n-   INDEX_TYPE is the type of the index expression.\n-\n-   The instructions to generate the case decision tree are\n-   output in the same order as nodes are processed so it is\n-   known that if a parent node checks the range of the current\n-   node minus one that the current node is bounded at its lower\n-   span.  Thus the test would be redundant.  */\n-\n-static int\n-node_has_low_bound (case_node_ptr node, tree index_type)\n-{\n-  tree low_minus_one;\n-  case_node_ptr pnode;\n-\n-  /* If the lower bound of this node is the lowest value in the index type,\n-     we need not test it.  */\n-\n-  if (tree_int_cst_equal (node->low, TYPE_MIN_VALUE (index_type)))\n-    return 1;\n-\n-  /* If this node has a left branch, the value at the left must be less\n-     than that at this node, so it cannot be bounded at the bottom and\n-     we need not bother testing any further.  */\n-\n-  if (node->left)\n-    return 0;\n-\n-  low_minus_one = fold_build2 (MINUS_EXPR, TREE_TYPE (node->low),\n-\t\t\t       node->low,\n-\t\t\t       build_int_cst (TREE_TYPE (node->low), 1));\n-\n-  /* If the subtraction above overflowed, we can't verify anything.\n-     Otherwise, look for a parent that tests our value - 1.  */\n-\n-  if (! tree_int_cst_lt (low_minus_one, node->low))\n-    return 0;\n-\n-  for (pnode = node->parent; pnode; pnode = pnode->parent)\n-    if (tree_int_cst_equal (low_minus_one, pnode->high))\n-      return 1;\n-\n-  return 0;\n-}\n-\n-/* Search the parent sections of the case node tree\n-   to see if a test for the upper bound of NODE would be redundant.\n-   INDEX_TYPE is the type of the index expression.\n-\n-   The instructions to generate the case decision tree are\n-   output in the same order as nodes are processed so it is\n-   known that if a parent node checks the range of the current\n-   node plus one that the current node is bounded at its upper\n-   span.  Thus the test would be redundant.  */\n-\n-static int\n-node_has_high_bound (case_node_ptr node, tree index_type)\n-{\n-  tree high_plus_one;\n-  case_node_ptr pnode;\n-\n-  /* If there is no upper bound, obviously no test is needed.  */\n-\n-  if (TYPE_MAX_VALUE (index_type) == NULL)\n-    return 1;\n-\n-  /* If the upper bound of this node is the highest value in the type\n-     of the index expression, we need not test against it.  */\n-\n-  if (tree_int_cst_equal (node->high, TYPE_MAX_VALUE (index_type)))\n-    return 1;\n-\n-  /* If this node has a right branch, the value at the right must be greater\n-     than that at this node, so it cannot be bounded at the top and\n-     we need not bother testing any further.  */\n-\n-  if (node->right)\n-    return 0;\n-\n-  high_plus_one = fold_build2 (PLUS_EXPR, TREE_TYPE (node->high),\n-\t\t\t       node->high,\n-\t\t\t       build_int_cst (TREE_TYPE (node->high), 1));\n-\n-  /* If the addition above overflowed, we can't verify anything.\n-     Otherwise, look for a parent that tests our value + 1.  */\n-\n-  if (! tree_int_cst_lt (node->high, high_plus_one))\n-    return 0;\n-\n-  for (pnode = node->parent; pnode; pnode = pnode->parent)\n-    if (tree_int_cst_equal (high_plus_one, pnode->low))\n-      return 1;\n-\n-  return 0;\n-}\n-\n-/* Search the parent sections of the\n-   case node tree to see if both tests for the upper and lower\n-   bounds of NODE would be redundant.  */\n-\n-static int\n-node_is_bounded (case_node_ptr node, tree index_type)\n-{\n-  return (node_has_low_bound (node, index_type)\n-\t  && node_has_high_bound (node, index_type));\n-}\n-\f\n-\n-/* Emit step-by-step code to select a case for the value of INDEX.\n-   The thus generated decision tree follows the form of the\n-   case-node binary tree NODE, whose nodes represent test conditions.\n-   INDEX_TYPE is the type of the index of the switch.\n-\n-   Care is taken to prune redundant tests from the decision tree\n-   by detecting any boundary conditions already checked by\n-   emitted rtx.  (See node_has_high_bound, node_has_low_bound\n-   and node_is_bounded, above.)\n-\n-   Where the test conditions can be shown to be redundant we emit\n-   an unconditional jump to the target code.  As a further\n-   optimization, the subordinates of a tree node are examined to\n-   check for bounded nodes.  In this case conditional and/or\n-   unconditional jumps as a result of the boundary check for the\n-   current node are arranged to target the subordinates associated\n-   code for out of bound conditions on the current node.\n-\n-   We can assume that when control reaches the code generated here,\n-   the index value has already been compared with the parents\n-   of this node, and determined to be on the same side of each parent\n-   as this node is.  Thus, if this node tests for the value 51,\n-   and a parent tested for 52, we don't need to consider\n-   the possibility of a value greater than 51.  If another parent\n-   tests for the value 50, then this node need not test anything.  */\n-\n-static void\n-emit_case_nodes (rtx index, case_node_ptr node, rtx_code_label *default_label,\n-\t\t profile_probability default_prob, tree index_type)\n-{\n-  /* If INDEX has an unsigned type, we must make unsigned branches.  */\n-  int unsignedp = TYPE_UNSIGNED (index_type);\n-  profile_probability probability;\n-  profile_probability prob = node->prob, subtree_prob = node->subtree_prob;\n-  machine_mode mode = GET_MODE (index);\n-  machine_mode imode = TYPE_MODE (index_type);\n-\n-  /* Handle indices detected as constant during RTL expansion.  */\n-  if (mode == VOIDmode)\n-    mode = imode;\n-\n-  /* See if our parents have already tested everything for us.\n-     If they have, emit an unconditional jump for this node.  */\n-  if (node_is_bounded (node, index_type))\n-    emit_jump (label_rtx (node->code_label));\n-\n-  else if (tree_int_cst_equal (node->low, node->high))\n-    {\n-      probability = conditional_probability (prob, subtree_prob + default_prob);\n-      /* Node is single valued.  First see if the index expression matches\n-\t this node and then check our children, if any.  */\n-      do_jump_if_equal (mode, index,\n-\t\t\tconvert_modes (mode, imode,\n-\t\t\t\t       expand_normal (node->low),\n-\t\t\t\t       unsignedp),\n-\t\t\tjump_target_rtx (node->code_label),\n-\t\t\tunsignedp, probability);\n-      /* Since this case is taken at this point, reduce its weight from\n-         subtree_weight.  */\n-      subtree_prob -= prob;\n-      if (node->right != 0 && node->left != 0)\n-\t{\n-\t  /* This node has children on both sides.\n-\t     Dispatch to one side or the other\n-\t     by comparing the index value with this node's value.\n-\t     If one subtree is bounded, check that one first,\n-\t     so we can avoid real branches in the tree.  */\n-\n-\t  if (node_is_bounded (node->right, index_type))\n-\t    {\n-              probability = conditional_probability (\n-                  node->right->prob,\n-                  subtree_prob + default_prob);\n-\t      emit_cmp_and_jump_insns (index,\n-\t\t\t\t       convert_modes\n-\t\t\t\t       (mode, imode,\n-\t\t\t\t\texpand_normal (node->high),\n-\t\t\t\t\tunsignedp),\n-\t\t\t\t       GT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t       label_rtx (node->right->code_label),\n-                                       probability);\n-\t      emit_case_nodes (index, node->left, default_label, default_prob,\n-                               index_type);\n-\t    }\n-\n-\t  else if (node_is_bounded (node->left, index_type))\n-\t    {\n-              probability = conditional_probability (\n-                  node->left->prob,\n-                  subtree_prob + default_prob);\n-\t      emit_cmp_and_jump_insns (index,\n-\t\t\t\t       convert_modes\n-\t\t\t\t       (mode, imode,\n-\t\t\t\t\texpand_normal (node->high),\n-\t\t\t\t\tunsignedp),\n-\t\t\t\t       LT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t       label_rtx (node->left->code_label),\n-                                       probability);\n-\t      emit_case_nodes (index, node->right, default_label, default_prob,\n-\t\t\t       index_type);\n-\t    }\n-\n-\t  /* If both children are single-valued cases with no\n-\t     children, finish up all the work.  This way, we can save\n-\t     one ordered comparison.  */\n-\t  else if (tree_int_cst_equal (node->right->low, node->right->high)\n-\t\t   && node->right->left == 0\n-\t\t   && node->right->right == 0\n-\t\t   && tree_int_cst_equal (node->left->low, node->left->high)\n-\t\t   && node->left->left == 0\n-\t\t   && node->left->right == 0)\n-\t    {\n-\t      /* Neither node is bounded.  First distinguish the two sides;\n-\t\t then emit the code for one side at a time.  */\n-\n-\t      /* See if the value matches what the right hand side\n-\t\t wants.  */\n-              probability = conditional_probability (\n-                  node->right->prob,\n-                  subtree_prob + default_prob);\n-\t      do_jump_if_equal (mode, index,\n-\t\t\t\tconvert_modes (mode, imode,\n-\t\t\t\t\t       expand_normal (node->right->low),\n-\t\t\t\t\t       unsignedp),\n-\t\t\t\tjump_target_rtx (node->right->code_label),\n-\t\t\t\tunsignedp, probability);\n-\n-\t      /* See if the value matches what the left hand side\n-\t\t wants.  */\n-              probability = conditional_probability (\n-                  node->left->prob,\n-                  subtree_prob + default_prob);\n-\t      do_jump_if_equal (mode, index,\n-\t\t\t\tconvert_modes (mode, imode,\n-\t\t\t\t\t       expand_normal (node->left->low),\n-\t\t\t\t\t       unsignedp),\n-\t\t\t\tjump_target_rtx (node->left->code_label),\n-\t\t\t\tunsignedp, probability);\n-\t    }\n-\n-\t  else\n-\t    {\n-\t      /* Neither node is bounded.  First distinguish the two sides;\n-\t\t then emit the code for one side at a time.  */\n-\n-\t      tree test_label\n-\t\t= build_decl (curr_insn_location (),\n-\t\t\t      LABEL_DECL, NULL_TREE, void_type_node);\n-\n-              /* The default label could be reached either through the right\n-                 subtree or the left subtree. Divide the probability\n-                 equally.  */\n-              probability = conditional_probability (\n-                  node->right->subtree_prob + default_prob.apply_scale (1, 2),\n-                  subtree_prob + default_prob);\n-\t      /* See if the value is on the right.  */\n-\t      emit_cmp_and_jump_insns (index,\n-\t\t\t\t       convert_modes\n-\t\t\t\t       (mode, imode,\n-\t\t\t\t\texpand_normal (node->high),\n-\t\t\t\t\tunsignedp),\n-\t\t\t\t       GT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t       label_rtx (test_label),\n-                                       probability);\n-              default_prob = default_prob.apply_scale (1, 2);\n-\n-\t      /* Value must be on the left.\n-\t\t Handle the left-hand subtree.  */\n-\t      emit_case_nodes (index, node->left, default_label, default_prob, index_type);\n-\t      /* If left-hand subtree does nothing,\n-\t\t go to default.  */\n-\t      if (default_label)\n-\t        emit_jump (default_label);\n-\n-\t      /* Code branches here for the right-hand subtree.  */\n-\t      expand_label (test_label);\n-\t      emit_case_nodes (index, node->right, default_label, default_prob, index_type);\n-\t    }\n-\t}\n-\n-      else if (node->right != 0 && node->left == 0)\n-\t{\n-\t  /* Here we have a right child but no left so we issue a conditional\n-\t     branch to default and process the right child.\n-\n-\t     Omit the conditional branch to default if the right child\n-\t     does not have any children and is single valued; it would\n-\t     cost too much space to save so little time.  */\n-\n-\t  if (node->right->right || node->right->left\n-\t      || !tree_int_cst_equal (node->right->low, node->right->high))\n-\t    {\n-\t      if (!node_has_low_bound (node, index_type))\n-\t\t{\n-                  probability = conditional_probability (\n-                      default_prob.apply_scale (1, 2),\n-                      subtree_prob + default_prob);\n-\t\t  emit_cmp_and_jump_insns (index,\n-\t\t\t\t\t   convert_modes\n-\t\t\t\t\t   (mode, imode,\n-\t\t\t\t\t    expand_normal (node->high),\n-\t\t\t\t\t    unsignedp),\n-\t\t\t\t\t   LT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t\t   default_label,\n-                                           probability);\n-                  default_prob = default_prob.apply_scale (1, 2);\n-\t\t}\n-\n-\t      emit_case_nodes (index, node->right, default_label, default_prob, index_type);\n-\t    }\n-\t  else\n-            {\n-              probability = conditional_probability (\n-                  node->right->subtree_prob,\n-                  subtree_prob + default_prob);\n-\t      /* We cannot process node->right normally\n-\t         since we haven't ruled out the numbers less than\n-\t         this node's value.  So handle node->right explicitly.  */\n-\t      do_jump_if_equal (mode, index,\n-\t\t\t        convert_modes\n-\t\t\t        (mode, imode,\n-\t\t\t         expand_normal (node->right->low),\n-\t\t\t         unsignedp),\n-\t\t\t\tjump_target_rtx (node->right->code_label),\n-\t\t\t\tunsignedp, probability);\n-            }\n-\t  }\n-\n-      else if (node->right == 0 && node->left != 0)\n-\t{\n-\t  /* Just one subtree, on the left.  */\n-\t  if (node->left->left || node->left->right\n-\t      || !tree_int_cst_equal (node->left->low, node->left->high))\n-\t    {\n-\t      if (!node_has_high_bound (node, index_type))\n-\t\t{\n-                  probability = conditional_probability (\n-                      default_prob.apply_scale (1, 2),\n-                      subtree_prob + default_prob);\n-\t\t  emit_cmp_and_jump_insns (index,\n-\t\t\t\t\t   convert_modes\n-\t\t\t\t\t   (mode, imode,\n-\t\t\t\t\t    expand_normal (node->high),\n-\t\t\t\t\t    unsignedp),\n-\t\t\t\t\t   GT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t\t   default_label,\n-                                           probability);\n-                  default_prob = default_prob.apply_scale (1, 2);\n-\t\t}\n-\n-\t      emit_case_nodes (index, node->left, default_label,\n-                               default_prob, index_type);\n-\t    }\n-\t  else\n-            {\n-              probability = conditional_probability (\n-                  node->left->subtree_prob,\n-                  subtree_prob + default_prob);\n-\t      /* We cannot process node->left normally\n-\t         since we haven't ruled out the numbers less than\n-\t         this node's value.  So handle node->left explicitly.  */\n-\t      do_jump_if_equal (mode, index,\n-\t\t\t        convert_modes\n-\t\t\t        (mode, imode,\n-\t\t\t         expand_normal (node->left->low),\n-\t\t\t         unsignedp),\n-\t\t\t\tjump_target_rtx (node->left->code_label),\n-\t\t\t\tunsignedp, probability);\n-            }\n-\t}\n-    }\n-  else\n-    {\n-      /* Node is a range.  These cases are very similar to those for a single\n-\t value, except that we do not start by testing whether this node\n-\t is the one to branch to.  */\n-\n-      if (node->right != 0 && node->left != 0)\n-\t{\n-\t  /* Node has subtrees on both sides.\n-\t     If the right-hand subtree is bounded,\n-\t     test for it first, since we can go straight there.\n-\t     Otherwise, we need to make a branch in the control structure,\n-\t     then handle the two subtrees.  */\n-\t  tree test_label = 0;\n-\n-\t  if (node_is_bounded (node->right, index_type))\n-            {\n-\t      /* Right hand node is fully bounded so we can eliminate any\n-\t         testing and branch directly to the target code.  */\n-              probability = conditional_probability (\n-                  node->right->subtree_prob,\n-                  subtree_prob + default_prob);\n-\t      emit_cmp_and_jump_insns (index,\n-\t\t\t\t       convert_modes\n-\t\t\t\t       (mode, imode,\n-\t\t\t\t        expand_normal (node->high),\n-\t\t\t\t        unsignedp),\n-\t\t\t\t       GT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t       label_rtx (node->right->code_label),\n-                                       probability);\n-            }\n-\t  else\n-\t    {\n-\t      /* Right hand node requires testing.\n-\t\t Branch to a label where we will handle it later.  */\n-\n-\t      test_label = build_decl (curr_insn_location (),\n-\t\t\t\t       LABEL_DECL, NULL_TREE, void_type_node);\n-              probability = conditional_probability (\n-                  node->right->subtree_prob + default_prob.apply_scale (1, 2),\n-                  subtree_prob + default_prob);\n-\t      emit_cmp_and_jump_insns (index,\n-\t\t\t\t       convert_modes\n-\t\t\t\t       (mode, imode,\n-\t\t\t\t\texpand_normal (node->high),\n-\t\t\t\t\tunsignedp),\n-\t\t\t\t       GT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t       label_rtx (test_label),\n-                                       probability);\n-              default_prob = default_prob.apply_scale (1, 2);\n-\t    }\n-\n-\t  /* Value belongs to this node or to the left-hand subtree.  */\n-\n-          probability = conditional_probability (\n-              prob,\n-              subtree_prob + default_prob);\n-\t  emit_cmp_and_jump_insns (index,\n-\t\t\t\t   convert_modes\n-\t\t\t\t   (mode, imode,\n-\t\t\t\t    expand_normal (node->low),\n-\t\t\t\t    unsignedp),\n-\t\t\t\t   GE, NULL_RTX, mode, unsignedp,\n-\t\t\t\t   label_rtx (node->code_label),\n-                                   probability);\n-\n-\t  /* Handle the left-hand subtree.  */\n-\t  emit_case_nodes (index, node->left, default_label, default_prob, index_type);\n-\n-\t  /* If right node had to be handled later, do that now.  */\n-\n-\t  if (test_label)\n-\t    {\n-\t      /* If the left-hand subtree fell through,\n-\t\t don't let it fall into the right-hand subtree.  */\n-\t      if (default_label)\n-\t\temit_jump (default_label);\n-\n-\t      expand_label (test_label);\n-\t      emit_case_nodes (index, node->right, default_label, default_prob, index_type);\n-\t    }\n-\t}\n-\n-      else if (node->right != 0 && node->left == 0)\n-\t{\n-\t  /* Deal with values to the left of this node,\n-\t     if they are possible.  */\n-\t  if (!node_has_low_bound (node, index_type))\n-\t    {\n-              probability = conditional_probability (\n-                  default_prob.apply_scale (1, 2),\n-                  subtree_prob + default_prob);\n-\t      emit_cmp_and_jump_insns (index,\n-\t\t\t\t       convert_modes\n-\t\t\t\t       (mode, imode,\n-\t\t\t\t\texpand_normal (node->low),\n-\t\t\t\t\tunsignedp),\n-\t\t\t\t       LT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t       default_label,\n-                                       probability);\n-              default_prob = default_prob.apply_scale (1, 2);\n-\t    }\n-\n-\t  /* Value belongs to this node or to the right-hand subtree.  */\n-\n-          probability = conditional_probability (\n-              prob,\n-              subtree_prob + default_prob);\n-\t  emit_cmp_and_jump_insns (index,\n-\t\t\t\t   convert_modes\n-\t\t\t\t   (mode, imode,\n-\t\t\t\t    expand_normal (node->high),\n-\t\t\t\t    unsignedp),\n-\t\t\t\t   LE, NULL_RTX, mode, unsignedp,\n-\t\t\t\t   label_rtx (node->code_label),\n-                                   probability);\n-\n-\t  emit_case_nodes (index, node->right, default_label, default_prob, index_type);\n-\t}\n-\n-      else if (node->right == 0 && node->left != 0)\n-\t{\n-\t  /* Deal with values to the right of this node,\n-\t     if they are possible.  */\n-\t  if (!node_has_high_bound (node, index_type))\n-\t    {\n-              probability = conditional_probability (\n-                  default_prob.apply_scale (1, 2),\n-                  subtree_prob + default_prob);\n-\t      emit_cmp_and_jump_insns (index,\n-\t\t\t\t       convert_modes\n-\t\t\t\t       (mode, imode,\n-\t\t\t\t\texpand_normal (node->high),\n-\t\t\t\t\tunsignedp),\n-\t\t\t\t       GT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t       default_label,\n-                                       probability);\n-              default_prob = default_prob.apply_scale (1, 2);\n-\t    }\n-\n-\t  /* Value belongs to this node or to the left-hand subtree.  */\n-\n-          probability = conditional_probability (\n-              prob,\n-              subtree_prob + default_prob);\n-\t  emit_cmp_and_jump_insns (index,\n-\t\t\t\t   convert_modes\n-\t\t\t\t   (mode, imode,\n-\t\t\t\t    expand_normal (node->low),\n-\t\t\t\t    unsignedp),\n-\t\t\t\t   GE, NULL_RTX, mode, unsignedp,\n-\t\t\t\t   label_rtx (node->code_label),\n-                                   probability);\n-\n-\t  emit_case_nodes (index, node->left, default_label, default_prob, index_type);\n-\t}\n-\n-      else\n-\t{\n-\t  /* Node has no children so we check low and high bounds to remove\n-\t     redundant tests.  Only one of the bounds can exist,\n-\t     since otherwise this node is bounded--a case tested already.  */\n-\t  int high_bound = node_has_high_bound (node, index_type);\n-\t  int low_bound = node_has_low_bound (node, index_type);\n-\n-\t  if (!high_bound && low_bound)\n-\t    {\n-              probability = conditional_probability (\n-                  default_prob,\n-                  subtree_prob + default_prob);\n-\t      emit_cmp_and_jump_insns (index,\n-\t\t\t\t       convert_modes\n-\t\t\t\t       (mode, imode,\n-\t\t\t\t\texpand_normal (node->high),\n-\t\t\t\t\tunsignedp),\n-\t\t\t\t       GT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t       default_label,\n-                                       probability);\n-\t    }\n-\n-\t  else if (!low_bound && high_bound)\n-\t    {\n-              probability = conditional_probability (\n-                  default_prob,\n-                  subtree_prob + default_prob);\n-\t      emit_cmp_and_jump_insns (index,\n-\t\t\t\t       convert_modes\n-\t\t\t\t       (mode, imode,\n-\t\t\t\t\texpand_normal (node->low),\n-\t\t\t\t\tunsignedp),\n-\t\t\t\t       LT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t       default_label,\n-                                       probability);\n-\t    }\n-\t  else if (!low_bound && !high_bound)\n-\t    {\n-\t      /* Widen LOW and HIGH to the same width as INDEX.  */\n-\t      tree type = lang_hooks.types.type_for_mode (mode, unsignedp);\n-\t      tree low = build1 (CONVERT_EXPR, type, node->low);\n-\t      tree high = build1 (CONVERT_EXPR, type, node->high);\n-\t      rtx low_rtx, new_index, new_bound;\n-\n-\t      /* Instead of doing two branches, emit one unsigned branch for\n-\t\t (index-low) > (high-low).  */\n-\t      low_rtx = expand_expr (low, NULL_RTX, mode, EXPAND_NORMAL);\n-\t      new_index = expand_simple_binop (mode, MINUS, index, low_rtx,\n-\t\t\t\t\t       NULL_RTX, unsignedp,\n-\t\t\t\t\t       OPTAB_WIDEN);\n-\t      new_bound = expand_expr (fold_build2 (MINUS_EXPR, type,\n-\t\t\t\t\t\t    high, low),\n-\t\t\t\t       NULL_RTX, mode, EXPAND_NORMAL);\n-\n-              probability = conditional_probability (\n-                  default_prob,\n-                  subtree_prob + default_prob);\n-\t      emit_cmp_and_jump_insns (new_index, new_bound, GT, NULL_RTX,\n-\t\t\t\t       mode, 1, default_label, probability);\n-\t    }\n-\n-\t  emit_jump (jump_target_rtx (node->code_label));\n-\t}\n-    }\n-}"}, {"sha": "5888d280417b68a8d92bfe34399373c58cee4dbb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc3d6a96167b4c84824be5e472fba4956297033/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc3d6a96167b4c84824be5e472fba4956297033/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9dc3d6a96167b4c84824be5e472fba4956297033", "patch": "@@ -1,3 +1,9 @@\n+2017-08-29  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcc.dg/tree-prof/update-loopch.c: Scan patterns in\n+\tswitchlower.\n+\t* gcc.dg/tree-ssa/vrp104.c: Likewise.\n+\n 2017-08-29  Richard Biener  <rguenther@suse.de>\n \tDominik Infuehr <dominik.infuehr@theobroma-systems.com>\n "}, {"sha": "73efc878ec0a3d197f0ba84d85cf4fdf9678ffa8", "filename": "gcc/testsuite/gcc.dg/tree-prof/update-loopch.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc3d6a96167b4c84824be5e472fba4956297033/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fupdate-loopch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc3d6a96167b4c84824be5e472fba4956297033/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fupdate-loopch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fupdate-loopch.c?ref=9dc3d6a96167b4c84824be5e472fba4956297033", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -fdump-ipa-profile-blocks-details -fdump-tree-optimized-blocks-details\" } */\n+/* { dg-options \"-O2 -fdump-ipa-profile-blocks-details -fdump-tree-switchlower-blocks-details\" } */\n int max = 33333;\n int a[8];\n int\n@@ -16,7 +16,7 @@ main ()\n    edge.  */\n /* autofdo cannot do that precise counts */\n /* { dg-final-use-not-autofdo { scan-ipa-dump \"loop depth 1, count 33334\" \"profile\"} } */\n-/* { dg-final-use-not-autofdo { scan-tree-dump \"loop depth 1, count 33333\" \"optimized\"} } */\n-/* { dg-final-use-not-autofdo { scan-tree-dump-not \"loop depth 1, count 33332\" \"optimized\"} } */\n-/* { dg-final-use-not-autofdo { scan-tree-dump \"Removing basic block\" \"optimized\"} } */\n-/* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */\n+/* { dg-final-use-not-autofdo { scan-tree-dump \"loop depth 1, count 33333\" \"switchlower\"} } */\n+/* { dg-final-use-not-autofdo { scan-tree-dump-not \"loop depth 1, count 33332\" \"switchlower\"} } */\n+/* { dg-final-use-not-autofdo { scan-tree-dump \"Removing basic block\" \"switchlower\"} } */\n+/* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"switchlower\"} } */"}, {"sha": "aa3b00a120458a0966d26fe057c1d884754fd274", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp104.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc3d6a96167b4c84824be5e472fba4956297033/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp104.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc3d6a96167b4c84824be5e472fba4956297033/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp104.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp104.c?ref=9dc3d6a96167b4c84824be5e472fba4956297033", "patch": "@@ -1,6 +1,6 @@\n /* PR tree-optimization/18046  */\n /* { dg-options \"-O2 -fdump-tree-optimized\" }  */\n-/* { dg-final { scan-tree-dump-times \"switch\" 1 \"optimized\" } }  */\n+/* { dg-final { scan-tree-dump-times \"switch\" 1 \"switchlower\" } }  */\n \n void foo (void);\n void bar (void);"}, {"sha": "8cec6af80dfb426e595d12452ff890e72471ccce", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc3d6a96167b4c84824be5e472fba4956297033/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc3d6a96167b4c84824be5e472fba4956297033/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=9dc3d6a96167b4c84824be5e472fba4956297033", "patch": "@@ -208,6 +208,7 @@ DEFTIMEVAR (TV_TREE_COPY_RENAME\t     , \"tree rename SSA copies\")\n DEFTIMEVAR (TV_TREE_SSA_VERIFY       , \"tree SSA verifier\")\n DEFTIMEVAR (TV_TREE_STMT_VERIFY      , \"tree STMT verifier\")\n DEFTIMEVAR (TV_TREE_SWITCH_CONVERSION, \"tree switch conversion\")\n+DEFTIMEVAR (TV_TREE_SWITCH_LOWERING,   \"tree switch lowering\")\n DEFTIMEVAR (TV_TRANS_MEM             , \"transactional memory\")\n DEFTIMEVAR (TV_TREE_STRLEN           , \"tree strlen optimization\")\n DEFTIMEVAR (TV_CGRAPH_VERIFY         , \"callgraph verifier\")"}, {"sha": "9f76d822abcbfe4f5ff33a18d80bc22d806f54d8", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc3d6a96167b4c84824be5e472fba4956297033/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc3d6a96167b4c84824be5e472fba4956297033/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=9dc3d6a96167b4c84824be5e472fba4956297033", "patch": "@@ -409,6 +409,7 @@ extern gimple_opt_pass *make_pass_profile (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_strip_predict_hints (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lower_complex_O0 (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lower_complex (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_lower_switch (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lower_vector (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lower_vector_ssa (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lower_omp (gcc::context *ctxt);"}, {"sha": "5a827a6f1f9a8fcc8ef5b83b9245c1e838af37eb", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 1178, "deletions": 0, "changes": 1178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc3d6a96167b4c84824be5e472fba4956297033/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc3d6a96167b4c84824be5e472fba4956297033/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=9dc3d6a96167b4c84824be5e472fba4956297033", "patch": "@@ -46,6 +46,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"gimplify-me.h\"\n #include \"tree-cfg.h\"\n #include \"cfgloop.h\"\n+#include \"alloc-pool.h\"\n+#include \"target.h\"\n+#include \"tree-into-ssa.h\"\n \n /* ??? For lang_hooks.types.type_for_mode, but is there a word_mode\n    type in the GIMPLE type system that is language-independent?  */\n@@ -1662,3 +1665,1178 @@ make_pass_convert_switch (gcc::context *ctxt)\n {\n   return new pass_convert_switch (ctxt);\n }\n+\n+struct case_node\n+{\n+  case_node\t\t*left;\t/* Left son in binary tree.  */\n+  case_node\t\t*right;\t/* Right son in binary tree;\n+\t\t\t\t   also node chain.  */\n+  case_node\t\t*parent; /* Parent of node in binary tree.  */\n+  tree\t\t\tlow;\t/* Lowest index value for this label.  */\n+  tree\t\t\thigh;\t/* Highest index value for this label.  */\n+  basic_block\t\tcase_bb; /* Label to jump to when node matches.  */\n+  tree\t\t\tcase_label; /* Label to jump to when node matches.  */\n+  profile_probability   prob; /* Probability of taking this case.  */\n+  profile_probability   subtree_prob;  /* Probability of reaching subtree\n+\t\t\t\t\t  rooted at this node.  */\n+};\n+\n+typedef case_node *case_node_ptr;\n+\n+static basic_block emit_case_nodes (basic_block, tree, case_node_ptr,\n+\t\t\t\t    basic_block, tree, profile_probability,\n+\t\t\t\t    tree, hash_map<tree, tree> *);\n+static bool node_has_low_bound (case_node_ptr, tree);\n+static bool node_has_high_bound (case_node_ptr, tree);\n+static bool node_is_bounded (case_node_ptr, tree);\n+\n+/* Return the smallest number of different values for which it is best to use a\n+   jump-table instead of a tree of conditional branches.  */\n+\n+static unsigned int\n+case_values_threshold (void)\n+{\n+  unsigned int threshold = PARAM_VALUE (PARAM_CASE_VALUES_THRESHOLD);\n+\n+  if (threshold == 0)\n+    threshold = targetm.case_values_threshold ();\n+\n+  return threshold;\n+}\n+\n+/* Reset the aux field of all outgoing edges of basic block BB.  */\n+\n+static inline void\n+reset_out_edges_aux (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    e->aux = (void *) 0;\n+}\n+\n+/* Compute the number of case labels that correspond to each outgoing edge of\n+   STMT.  Record this information in the aux field of the edge.  */\n+\n+static inline void\n+compute_cases_per_edge (gswitch *stmt)\n+{\n+  basic_block bb = gimple_bb (stmt);\n+  reset_out_edges_aux (bb);\n+  int ncases = gimple_switch_num_labels (stmt);\n+  for (int i = ncases - 1; i >= 1; --i)\n+    {\n+      tree elt = gimple_switch_label (stmt, i);\n+      tree lab = CASE_LABEL (elt);\n+      basic_block case_bb = label_to_block_fn (cfun, lab);\n+      edge case_edge = find_edge (bb, case_bb);\n+      case_edge->aux = (void *) ((intptr_t) (case_edge->aux) + 1);\n+    }\n+}\n+\n+/* Do the insertion of a case label into case_list.  The labels are\n+   fed to us in descending order from the sorted vector of case labels used\n+   in the tree part of the middle end.  So the list we construct is\n+   sorted in ascending order.\n+\n+   LABEL is the case label to be inserted.  LOW and HIGH are the bounds\n+   against which the index is compared to jump to LABEL and PROB is the\n+   estimated probability LABEL is reached from the switch statement.  */\n+\n+static case_node *\n+add_case_node (case_node *head, tree low, tree high, basic_block case_bb,\n+\t       tree case_label, profile_probability prob,\n+\t       object_allocator<case_node> &case_node_pool)\n+{\n+  case_node *r;\n+\n+  gcc_checking_assert (low);\n+  gcc_checking_assert (high && (TREE_TYPE (low) == TREE_TYPE (high)));\n+\n+  /* Add this label to the chain.  */\n+  r = case_node_pool.allocate ();\n+  r->low = low;\n+  r->high = high;\n+  r->case_bb = case_bb;\n+  r->case_label = case_label;\n+  r->parent = r->left = NULL;\n+  r->prob = prob;\n+  r->subtree_prob = prob;\n+  r->right = head;\n+  return r;\n+}\n+\n+/* Dump ROOT, a list or tree of case nodes, to file.  */\n+\n+static void\n+dump_case_nodes (FILE *f, case_node *root, int indent_step, int indent_level)\n+{\n+  if (root == 0)\n+    return;\n+  indent_level++;\n+\n+  dump_case_nodes (f, root->left, indent_step, indent_level);\n+\n+  fputs (\";; \", f);\n+  fprintf (f, \"%*s\", indent_step * indent_level, \"\");\n+  print_dec (root->low, f, TYPE_SIGN (TREE_TYPE (root->low)));\n+  if (!tree_int_cst_equal (root->low, root->high))\n+    {\n+      fprintf (f, \" ... \");\n+      print_dec (root->high, f, TYPE_SIGN (TREE_TYPE (root->high)));\n+    }\n+  fputs (\"\\n\", f);\n+\n+  dump_case_nodes (f, root->right, indent_step, indent_level);\n+}\n+\n+/* Take an ordered list of case nodes\n+   and transform them into a near optimal binary tree,\n+   on the assumption that any target code selection value is as\n+   likely as any other.\n+\n+   The transformation is performed by splitting the ordered\n+   list into two equal sections plus a pivot.  The parts are\n+   then attached to the pivot as left and right branches.  Each\n+   branch is then transformed recursively.  */\n+\n+static void\n+balance_case_nodes (case_node_ptr *head, case_node_ptr parent)\n+{\n+  case_node_ptr np;\n+\n+  np = *head;\n+  if (np)\n+    {\n+      int i = 0;\n+      int ranges = 0;\n+      case_node_ptr *npp;\n+      case_node_ptr left;\n+\n+      /* Count the number of entries on branch.  Also count the ranges.  */\n+\n+      while (np)\n+\t{\n+\t  if (!tree_int_cst_equal (np->low, np->high))\n+\t    ranges++;\n+\n+\t  i++;\n+\t  np = np->right;\n+\t}\n+\n+      if (i > 2)\n+\t{\n+\t  /* Split this list if it is long enough for that to help.  */\n+\t  npp = head;\n+\t  left = *npp;\n+\n+\t  /* If there are just three nodes, split at the middle one.  */\n+\t  if (i == 3)\n+\t    npp = &(*npp)->right;\n+\t  else\n+\t    {\n+\t      /* Find the place in the list that bisects the list's total cost,\n+\t\t where ranges count as 2.\n+\t\t Here I gets half the total cost.  */\n+\t      i = (i + ranges + 1) / 2;\n+\t      while (1)\n+\t\t{\n+\t\t  /* Skip nodes while their cost does not reach that amount.  */\n+\t\t  if (!tree_int_cst_equal ((*npp)->low, (*npp)->high))\n+\t\t    i--;\n+\t\t  i--;\n+\t\t  if (i <= 0)\n+\t\t    break;\n+\t\t  npp = &(*npp)->right;\n+\t\t}\n+\t    }\n+\t  *head = np = *npp;\n+\t  *npp = 0;\n+\t  np->parent = parent;\n+\t  np->left = left;\n+\n+\t  /* Optimize each of the two split parts.  */\n+\t  balance_case_nodes (&np->left, np);\n+\t  balance_case_nodes (&np->right, np);\n+\t  np->subtree_prob = np->prob;\n+\t  np->subtree_prob += np->left->subtree_prob;\n+\t  np->subtree_prob += np->right->subtree_prob;\n+\t}\n+      else\n+\t{\n+\t  /* Else leave this branch as one level,\n+\t     but fill in `parent' fields.  */\n+\t  np = *head;\n+\t  np->parent = parent;\n+\t  np->subtree_prob = np->prob;\n+\t  for (; np->right; np = np->right)\n+\t    {\n+\t      np->right->parent = np;\n+\t      (*head)->subtree_prob += np->right->subtree_prob;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Return true if a switch should be expanded as a decision tree.\n+   RANGE is the difference between highest and lowest case.\n+   UNIQ is number of unique case node targets, not counting the default case.\n+   COUNT is the number of comparisons needed, not counting the default case.  */\n+\n+static bool\n+expand_switch_as_decision_tree_p (tree range,\n+\t\t\t\t  unsigned int uniq ATTRIBUTE_UNUSED,\n+\t\t\t\t  unsigned int count)\n+{\n+  int max_ratio;\n+\n+  /* If neither casesi or tablejump is available, or flag_jump_tables\n+     over-ruled us, we really have no choice.  */\n+  if (!targetm.have_casesi () && !targetm.have_tablejump ())\n+    return true;\n+  if (!flag_jump_tables)\n+    return true;\n+#ifndef ASM_OUTPUT_ADDR_DIFF_ELT\n+  if (flag_pic)\n+    return true;\n+#endif\n+\n+  /* If the switch is relatively small such that the cost of one\n+     indirect jump on the target are higher than the cost of a\n+     decision tree, go with the decision tree.\n+\n+     If range of values is much bigger than number of values,\n+     or if it is too large to represent in a HOST_WIDE_INT,\n+     make a sequence of conditional branches instead of a dispatch.\n+\n+     The definition of \"much bigger\" depends on whether we are\n+     optimizing for size or for speed.  If the former, the maximum\n+     ratio range/count = 3, because this was found to be the optimal\n+     ratio for size on i686-pc-linux-gnu, see PR11823.  The ratio\n+     10 is much older, and was probably selected after an extensive\n+     benchmarking investigation on numerous platforms.  Or maybe it\n+     just made sense to someone at some point in the history of GCC,\n+     who knows...  */\n+  max_ratio = optimize_insn_for_size_p () ? 3 : 10;\n+  if (count < case_values_threshold () || !tree_fits_uhwi_p (range)\n+      || compare_tree_int (range, max_ratio * count) > 0)\n+    return true;\n+\n+  return false;\n+}\n+\n+static void\n+fix_phi_operands_for_edge (edge e, hash_map<tree, tree> *phi_mapping)\n+{\n+  basic_block bb = e->dest;\n+  gphi_iterator gsi;\n+  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gphi *phi = gsi.phi ();\n+\n+      tree *definition = phi_mapping->get (gimple_phi_result (phi));\n+      if (definition)\n+\tadd_phi_arg (phi, *definition, e, UNKNOWN_LOCATION);\n+    }\n+}\n+\n+\n+/* Add an unconditional jump to CASE_BB that happens in basic block BB.  */\n+\n+static void\n+emit_jump (basic_block bb, basic_block case_bb,\n+\t   hash_map<tree, tree> *phi_mapping)\n+{\n+  edge e = single_succ_edge (bb);\n+  redirect_edge_succ (e, case_bb);\n+  fix_phi_operands_for_edge (e, phi_mapping);\n+}\n+\n+/* Generate a decision tree, switching on INDEX_EXPR and jumping to\n+   one of the labels in CASE_LIST or to the DEFAULT_LABEL.\n+   DEFAULT_PROB is the estimated probability that it jumps to\n+   DEFAULT_LABEL.\n+\n+   We generate a binary decision tree to select the appropriate target\n+   code.  */\n+\n+static void\n+emit_case_decision_tree (gswitch *s, tree index_expr, tree index_type,\n+\t\t\t case_node_ptr case_list, basic_block default_bb,\n+\t\t\t tree default_label, profile_probability default_prob,\n+\t\t\t hash_map<tree, tree> *phi_mapping)\n+{\n+  balance_case_nodes (&case_list, NULL);\n+\n+  if (dump_file)\n+    dump_function_to_file (current_function_decl, dump_file, dump_flags);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      int indent_step = ceil_log2 (TYPE_PRECISION (index_type)) + 2;\n+      fprintf (dump_file, \";; Expanding GIMPLE switch as decision tree:\\n\");\n+      dump_case_nodes (dump_file, case_list, indent_step, 0);\n+    }\n+\n+  basic_block bb = gimple_bb (s);\n+  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+  edge e;\n+  if (gsi_end_p (gsi))\n+    e = split_block_after_labels (bb);\n+  else\n+    {\n+      gsi_prev (&gsi);\n+      e = split_block (bb, gsi_stmt (gsi));\n+    }\n+  bb = split_edge (e);\n+\n+  bb = emit_case_nodes (bb, index_expr, case_list, default_bb, default_label,\n+\t\t\tdefault_prob, index_type, phi_mapping);\n+\n+  if (bb)\n+    emit_jump (bb, default_bb, phi_mapping);\n+\n+  /* Remove all edges and do just an edge that will reach default_bb.  */\n+  gsi = gsi_last_bb (gimple_bb (s));\n+  gsi_remove (&gsi, true);\n+}\n+\n+static void\n+record_phi_operand_mapping (const vec<basic_block> bbs, basic_block switch_bb,\n+\t\t\t    hash_map <tree, tree> *map)\n+{\n+  /* Record all PHI nodes that have to be fixed after conversion.  */\n+  for (unsigned i = 0; i < bbs.length (); i++)\n+    {\n+      basic_block bb = bbs[i];\n+\n+      gphi_iterator gsi;\n+      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gphi *phi = gsi.phi ();\n+\n+\t  for (unsigned i = 0; i < gimple_phi_num_args (phi); i++)\n+\t    {\n+\t      basic_block phi_src_bb = gimple_phi_arg_edge (phi, i)->src;\n+\t      if (phi_src_bb == switch_bb)\n+\t\t{\n+\t\t  tree def = gimple_phi_arg_def (phi, i);\n+\t\t  tree result = gimple_phi_result (phi);\n+\t\t  map->put (result, def);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Attempt to expand gimple switch STMT to a decision tree.  */\n+\n+static bool\n+try_switch_expansion (gswitch *stmt)\n+{\n+  tree minval = NULL_TREE, maxval = NULL_TREE, range = NULL_TREE;\n+  basic_block default_bb;\n+  unsigned int count, uniq;\n+  int i;\n+  int ncases = gimple_switch_num_labels (stmt);\n+  tree index_expr = gimple_switch_index (stmt);\n+  tree index_type = TREE_TYPE (index_expr);\n+  tree elt;\n+  basic_block bb = gimple_bb (stmt);\n+\n+  hash_map<tree, tree> phi_mapping;\n+  auto_vec<basic_block> case_bbs;\n+\n+  /* A list of case labels; it is first built as a list and it may then\n+     be rearranged into a nearly balanced binary tree.  */\n+  case_node *case_list = 0;\n+\n+  /* A pool for case nodes.  */\n+  object_allocator<case_node> case_node_pool (\"struct case_node pool\");\n+\n+  /* cleanup_tree_cfg removes all SWITCH_EXPR with their index\n+     expressions being INTEGER_CST.  */\n+  gcc_assert (TREE_CODE (index_expr) != INTEGER_CST);\n+\n+  /* Optimization of switch statements with only one label has already\n+     occurred, so we should never see them at this point.  */\n+  gcc_assert (ncases > 1);\n+\n+  /* Find the default case target label.  */\n+  tree default_label = CASE_LABEL (gimple_switch_default_label (stmt));\n+  default_bb = label_to_block_fn (cfun, default_label);\n+  edge default_edge = find_edge (bb, default_bb);\n+  profile_probability default_prob = default_edge->probability;\n+  case_bbs.safe_push (default_bb);\n+\n+  /* Get upper and lower bounds of case values.  */\n+  elt = gimple_switch_label (stmt, 1);\n+  minval = fold_convert (index_type, CASE_LOW (elt));\n+  elt = gimple_switch_label (stmt, ncases - 1);\n+  if (CASE_HIGH (elt))\n+    maxval = fold_convert (index_type, CASE_HIGH (elt));\n+  else\n+    maxval = fold_convert (index_type, CASE_LOW (elt));\n+\n+  /* Compute span of values.  */\n+  range = fold_build2 (MINUS_EXPR, index_type, maxval, minval);\n+\n+  /* Listify the labels queue and gather some numbers to decide\n+     how to expand this switch.  */\n+  uniq = 0;\n+  count = 0;\n+  hash_set<tree> seen_labels;\n+  compute_cases_per_edge (stmt);\n+\n+  for (i = ncases - 1; i >= 1; --i)\n+    {\n+      elt = gimple_switch_label (stmt, i);\n+      tree low = CASE_LOW (elt);\n+      gcc_assert (low);\n+      tree high = CASE_HIGH (elt);\n+      gcc_assert (!high || tree_int_cst_lt (low, high));\n+      tree lab = CASE_LABEL (elt);\n+\n+      /* Count the elements.\n+\t A range counts double, since it requires two compares.  */\n+      count++;\n+      if (high)\n+\tcount++;\n+\n+      /* If we have not seen this label yet, then increase the\n+\t number of unique case node targets seen.  */\n+      if (!seen_labels.add (lab))\n+\tuniq++;\n+\n+      /* The bounds on the case range, LOW and HIGH, have to be converted\n+\t to case's index type TYPE.  Note that the original type of the\n+\t case index in the source code is usually \"lost\" during\n+\t gimplification due to type promotion, but the case labels retain the\n+\t original type.  Make sure to drop overflow flags.  */\n+      low = fold_convert (index_type, low);\n+      if (TREE_OVERFLOW (low))\n+\tlow = wide_int_to_tree (index_type, low);\n+\n+      /* The canonical from of a case label in GIMPLE is that a simple case\n+\t has an empty CASE_HIGH.  For the casesi and tablejump expanders,\n+\t the back ends want simple cases to have high == low.  */\n+      if (!high)\n+\thigh = low;\n+      high = fold_convert (index_type, high);\n+      if (TREE_OVERFLOW (high))\n+\thigh = wide_int_to_tree (index_type, high);\n+\n+      basic_block case_bb = label_to_block_fn (cfun, lab);\n+      edge case_edge = find_edge (bb, case_bb);\n+      case_list = add_case_node (\n+\tcase_list, low, high, case_bb, lab,\n+\tcase_edge->probability.apply_scale (1, (intptr_t) (case_edge->aux)),\n+\tcase_node_pool);\n+\n+      case_bbs.safe_push (case_bb);\n+    }\n+  reset_out_edges_aux (bb);\n+  record_phi_operand_mapping (case_bbs, bb, &phi_mapping);\n+\n+  /* cleanup_tree_cfg removes all SWITCH_EXPR with a single\n+     destination, such as one with a default case only.\n+     It also removes cases that are out of range for the switch\n+     type, so we should never get a zero here.  */\n+  gcc_assert (count > 0);\n+\n+  /* Decide how to expand this switch.\n+     The two options at this point are a dispatch table (casesi or\n+     tablejump) or a decision tree.  */\n+\n+  if (expand_switch_as_decision_tree_p (range, uniq, count))\n+    {\n+      emit_case_decision_tree (stmt, index_expr, index_type, case_list,\n+\t\t\t       default_bb, default_label, default_prob,\n+\t\t\t       &phi_mapping);\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* The main function of the pass scans statements for switches and invokes\n+   process_switch on them.  */\n+\n+namespace {\n+\n+const pass_data pass_data_lower_switch =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"switchlower\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_TREE_SWITCH_LOWERING, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_update_ssa | TODO_cleanup_cfg, /* todo_flags_finish */\n+};\n+\n+class pass_lower_switch : public gimple_opt_pass\n+{\n+public:\n+  pass_lower_switch (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_lower_switch, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *) { return true; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_lower_switch\n+\n+unsigned int\n+pass_lower_switch::execute (function *fun)\n+{\n+  basic_block bb;\n+  bool expanded = false;\n+\n+  FOR_EACH_BB_FN (bb, fun)\n+    {\n+      gimple *stmt = last_stmt (bb);\n+      if (stmt && gimple_code (stmt) == GIMPLE_SWITCH)\n+\t{\n+\t  if (dump_file)\n+\t    {\n+\t      expanded_location loc = expand_location (gimple_location (stmt));\n+\n+\t      fprintf (dump_file, \"beginning to process the following \"\n+\t\t\t\t  \"SWITCH statement (%s:%d) : ------- \\n\",\n+\t\t       loc.file, loc.line);\n+\t      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t      putc ('\\n', dump_file);\n+\t    }\n+\n+\t  expanded |= try_switch_expansion (as_a<gswitch *> (stmt));\n+\t}\n+    }\n+\n+  if (expanded)\n+    {\n+      free_dominance_info (CDI_DOMINATORS);\n+      free_dominance_info (CDI_POST_DOMINATORS);\n+      mark_virtual_operands_for_renaming (cfun);\n+    }\n+\n+  return 0;\n+}\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_lower_switch (gcc::context *ctxt)\n+{\n+  return new pass_lower_switch (ctxt);\n+}\n+\n+/* Generate code to jump to LABEL if OP0 and OP1 are equal in mode MODE.\n+   PROB is the probability of jumping to LABEL.  */\n+static basic_block\n+do_jump_if_equal (basic_block bb, tree op0, tree op1, basic_block label_bb,\n+\t\t  profile_probability prob, hash_map<tree, tree> *phi_mapping)\n+{\n+  gcond *cond = gimple_build_cond (EQ_EXPR, op0, op1, NULL_TREE, NULL_TREE);\n+  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+  gsi_insert_before (&gsi, cond, GSI_SAME_STMT);\n+\n+  gcc_assert (single_succ_p (bb));\n+\n+  /* Make a new basic block where false branch will take place.  */\n+  edge false_edge = split_block (bb, cond);\n+  false_edge->flags = EDGE_FALSE_VALUE;\n+  false_edge->probability = prob.invert ();\n+\n+  edge true_edge = make_edge (bb, label_bb, EDGE_TRUE_VALUE);\n+  fix_phi_operands_for_edge (true_edge, phi_mapping);\n+  true_edge->probability = prob;\n+\n+  return false_edge->dest;\n+}\n+\n+/* Generate code to compare X with Y so that the condition codes are\n+   set and to jump to LABEL if the condition is true.  If X is a\n+   constant and Y is not a constant, then the comparison is swapped to\n+   ensure that the comparison RTL has the canonical form.\n+\n+   UNSIGNEDP nonzero says that X and Y are unsigned; this matters if they\n+   need to be widened.  UNSIGNEDP is also used to select the proper\n+   branch condition code.\n+\n+   If X and Y have mode BLKmode, then SIZE specifies the size of both X and Y.\n+\n+   MODE is the mode of the inputs (in case they are const_int).\n+\n+   COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).\n+   It will be potentially converted into an unsigned variant based on\n+   UNSIGNEDP to select a proper jump instruction.\n+\n+   PROB is the probability of jumping to LABEL.  */\n+\n+static basic_block\n+emit_cmp_and_jump_insns (basic_block bb, tree op0, tree op1,\n+\t\t\t tree_code comparison, basic_block label_bb,\n+\t\t\t profile_probability prob,\n+\t\t\t hash_map<tree, tree> *phi_mapping)\n+{\n+  gcond *cond = gimple_build_cond (comparison, op0, op1, NULL_TREE, NULL_TREE);\n+  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+  gsi_insert_after (&gsi, cond, GSI_NEW_STMT);\n+\n+  gcc_assert (single_succ_p (bb));\n+\n+  /* Make a new basic block where false branch will take place.  */\n+  edge false_edge = split_block (bb, cond);\n+  false_edge->flags = EDGE_FALSE_VALUE;\n+  false_edge->probability = prob.invert ();\n+\n+  edge true_edge = make_edge (bb, label_bb, EDGE_TRUE_VALUE);\n+  fix_phi_operands_for_edge (true_edge, phi_mapping);\n+  true_edge->probability = prob;\n+\n+  return false_edge->dest;\n+}\n+\n+/* Computes the conditional probability of jumping to a target if the branch\n+   instruction is executed.\n+   TARGET_PROB is the estimated probability of jumping to a target relative\n+   to some basic block BB.\n+   BASE_PROB is the probability of reaching the branch instruction relative\n+   to the same basic block BB.  */\n+\n+static inline profile_probability\n+conditional_probability (profile_probability target_prob,\n+\t\t\t profile_probability base_prob)\n+{\n+  return target_prob / base_prob;\n+}\n+\n+/* Emit step-by-step code to select a case for the value of INDEX.\n+   The thus generated decision tree follows the form of the\n+   case-node binary tree NODE, whose nodes represent test conditions.\n+   INDEX_TYPE is the type of the index of the switch.\n+\n+   Care is taken to prune redundant tests from the decision tree\n+   by detecting any boundary conditions already checked by\n+   emitted rtx.  (See node_has_high_bound, node_has_low_bound\n+   and node_is_bounded, above.)\n+\n+   Where the test conditions can be shown to be redundant we emit\n+   an unconditional jump to the target code.  As a further\n+   optimization, the subordinates of a tree node are examined to\n+   check for bounded nodes.  In this case conditional and/or\n+   unconditional jumps as a result of the boundary check for the\n+   current node are arranged to target the subordinates associated\n+   code for out of bound conditions on the current node.\n+\n+   We can assume that when control reaches the code generated here,\n+   the index value has already been compared with the parents\n+   of this node, and determined to be on the same side of each parent\n+   as this node is.  Thus, if this node tests for the value 51,\n+   and a parent tested for 52, we don't need to consider\n+   the possibility of a value greater than 51.  If another parent\n+   tests for the value 50, then this node need not test anything.  */\n+\n+static basic_block\n+emit_case_nodes (basic_block bb, tree index, case_node_ptr node,\n+\t\t basic_block default_bb, tree default_label,\n+\t\t profile_probability default_prob, tree index_type,\n+\t\t hash_map<tree, tree> *phi_mapping)\n+{\n+  /* If INDEX has an unsigned type, we must make unsigned branches.  */\n+  profile_probability probability;\n+  profile_probability prob = node->prob, subtree_prob = node->subtree_prob;\n+\n+  /* See if our parents have already tested everything for us.\n+     If they have, emit an unconditional jump for this node.  */\n+  if (node_is_bounded (node, index_type))\n+    {\n+      emit_jump (bb, node->case_bb, phi_mapping);\n+      return NULL;\n+    }\n+\n+  else if (tree_int_cst_equal (node->low, node->high))\n+    {\n+      probability = conditional_probability (prob, subtree_prob + default_prob);\n+      /* Node is single valued.  First see if the index expression matches\n+\t this node and then check our children, if any.  */\n+      bb = do_jump_if_equal (bb, index, node->low, node->case_bb, probability,\n+\t\t\t     phi_mapping);\n+      /* Since this case is taken at this point, reduce its weight from\n+\t subtree_weight.  */\n+      subtree_prob -= prob;\n+      if (node->right != 0 && node->left != 0)\n+\t{\n+\t  /* This node has children on both sides.\n+\t     Dispatch to one side or the other\n+\t     by comparing the index value with this node's value.\n+\t     If one subtree is bounded, check that one first,\n+\t     so we can avoid real branches in the tree.  */\n+\n+\t  if (node_is_bounded (node->right, index_type))\n+\t    {\n+\t      probability\n+\t\t= conditional_probability (node->right->prob,\n+\t\t\t\t\t   subtree_prob + default_prob);\n+\t      bb = emit_cmp_and_jump_insns (bb, index, node->high, GT_EXPR,\n+\t\t\t\t\t    node->right->case_bb, probability,\n+\t\t\t\t\t    phi_mapping);\n+\t      bb = emit_case_nodes (bb, index, node->left, default_bb,\n+\t\t\t\t    default_label, default_prob, index_type,\n+\t\t\t\t    phi_mapping);\n+\t    }\n+\n+\t  else if (node_is_bounded (node->left, index_type))\n+\t    {\n+\t      probability\n+\t\t= conditional_probability (node->left->prob,\n+\t\t\t\t\t   subtree_prob + default_prob);\n+\t      bb = emit_cmp_and_jump_insns (bb, index, node->high, LT_EXPR,\n+\t\t\t\t\t    node->left->case_bb, probability,\n+\t\t\t\t\t    phi_mapping);\n+\t      bb = emit_case_nodes (bb, index, node->right, default_bb,\n+\t\t\t\t    default_label, default_prob, index_type,\n+\t\t\t\t    phi_mapping);\n+\t    }\n+\n+\t  /* If both children are single-valued cases with no\n+\t     children, finish up all the work.  This way, we can save\n+\t     one ordered comparison.  */\n+\t  else if (tree_int_cst_equal (node->right->low, node->right->high)\n+\t\t   && node->right->left == 0 && node->right->right == 0\n+\t\t   && tree_int_cst_equal (node->left->low, node->left->high)\n+\t\t   && node->left->left == 0 && node->left->right == 0)\n+\t    {\n+\t      /* Neither node is bounded.  First distinguish the two sides;\n+\t\t then emit the code for one side at a time.  */\n+\n+\t      /* See if the value matches what the right hand side\n+\t\t wants.  */\n+\t      probability\n+\t\t= conditional_probability (node->right->prob,\n+\t\t\t\t\t   subtree_prob + default_prob);\n+\t      bb = do_jump_if_equal (bb, index, node->right->low,\n+\t\t\t\t     node->right->case_bb, probability,\n+\t\t\t\t     phi_mapping);\n+\n+\t      /* See if the value matches what the left hand side\n+\t\t wants.  */\n+\t      probability\n+\t\t= conditional_probability (node->left->prob,\n+\t\t\t\t\t   subtree_prob + default_prob);\n+\t      bb = do_jump_if_equal (bb, index, node->left->low,\n+\t\t\t\t     node->left->case_bb, probability,\n+\t\t\t\t     phi_mapping);\n+\t    }\n+\n+\t  else\n+\t    {\n+\t      /* Neither node is bounded.  First distinguish the two sides;\n+\t\t then emit the code for one side at a time.  */\n+\n+\t      basic_block test_bb = split_edge (single_succ_edge (bb));\n+\t      redirect_edge_succ (single_pred_edge (test_bb),\n+\t\t\t\t  single_succ_edge (bb)->dest);\n+\n+\t      /* The default label could be reached either through the right\n+\t\t subtree or the left subtree.  Divide the probability\n+\t\t equally.  */\n+\t      probability\n+\t\t= conditional_probability (node->right->subtree_prob\n+\t\t\t\t\t     + default_prob.apply_scale (1, 2),\n+\t\t\t\t\t   subtree_prob + default_prob);\n+\t      /* See if the value is on the right.  */\n+\t      bb = emit_cmp_and_jump_insns (bb, index, node->high, GT_EXPR,\n+\t\t\t\t\t    test_bb, probability, phi_mapping);\n+\t      default_prob = default_prob.apply_scale (1, 2);\n+\n+\t      /* Value must be on the left.\n+\t\t Handle the left-hand subtree.  */\n+\t      bb = emit_case_nodes (bb, index, node->left, default_bb,\n+\t\t\t\t    default_label, default_prob, index_type,\n+\t\t\t\t    phi_mapping);\n+\t      /* If left-hand subtree does nothing,\n+\t\t go to default.  */\n+\n+\t      if (bb && default_bb)\n+\t\temit_jump (bb, default_bb, phi_mapping);\n+\n+\t      /* Code branches here for the right-hand subtree.  */\n+\t      bb = emit_case_nodes (test_bb, index, node->right, default_bb,\n+\t\t\t\t    default_label, default_prob, index_type,\n+\t\t\t\t    phi_mapping);\n+\t    }\n+\t}\n+      else if (node->right != 0 && node->left == 0)\n+\t{\n+\t  /* Here we have a right child but no left so we issue a conditional\n+\t     branch to default and process the right child.\n+\n+\t     Omit the conditional branch to default if the right child\n+\t     does not have any children and is single valued; it would\n+\t     cost too much space to save so little time.  */\n+\n+\t  if (node->right->right || node->right->left\n+\t      || !tree_int_cst_equal (node->right->low, node->right->high))\n+\t    {\n+\t      if (!node_has_low_bound (node, index_type))\n+\t\t{\n+\t\t  probability\n+\t\t    = conditional_probability (default_prob.apply_scale (1, 2),\n+\t\t\t\t\t       subtree_prob + default_prob);\n+\t\t  bb = emit_cmp_and_jump_insns (bb, index, node->high, LT_EXPR,\n+\t\t\t\t\t\tdefault_bb, probability,\n+\t\t\t\t\t\tphi_mapping);\n+\t\t  default_prob = default_prob.apply_scale (1, 2);\n+\t\t}\n+\n+\t      bb = emit_case_nodes (bb, index, node->right, default_bb,\n+\t\t\t\t    default_label, default_prob, index_type,\n+\t\t\t\t    phi_mapping);\n+\t    }\n+\t  else\n+\t    {\n+\t      probability\n+\t\t= conditional_probability (node->right->subtree_prob,\n+\t\t\t\t\t   subtree_prob + default_prob);\n+\t      /* We cannot process node->right normally\n+\t\t since we haven't ruled out the numbers less than\n+\t\t this node's value.  So handle node->right explicitly.  */\n+\t      bb = do_jump_if_equal (bb, index, node->right->low,\n+\t\t\t\t     node->right->case_bb, probability,\n+\t\t\t\t     phi_mapping);\n+\t    }\n+\t}\n+\n+      else if (node->right == 0 && node->left != 0)\n+\t{\n+\t  /* Just one subtree, on the left.  */\n+\t  if (node->left->left || node->left->right\n+\t      || !tree_int_cst_equal (node->left->low, node->left->high))\n+\t    {\n+\t      if (!node_has_high_bound (node, index_type))\n+\t\t{\n+\t\t  probability\n+\t\t    = conditional_probability (default_prob.apply_scale (1, 2),\n+\t\t\t\t\t       subtree_prob + default_prob);\n+\t\t  bb = emit_cmp_and_jump_insns (bb, index, node->high, GT_EXPR,\n+\t\t\t\t\t\tdefault_bb, probability,\n+\t\t\t\t\t\tphi_mapping);\n+\t\t  default_prob = default_prob.apply_scale (1, 2);\n+\t\t}\n+\n+\t      bb = emit_case_nodes (bb, index, node->left, default_bb,\n+\t\t\t\t    default_label, default_prob, index_type,\n+\t\t\t\t    phi_mapping);\n+\t    }\n+\t  else\n+\t    {\n+\t      probability\n+\t\t= conditional_probability (node->left->subtree_prob,\n+\t\t\t\t\t   subtree_prob + default_prob);\n+\t      /* We cannot process node->left normally\n+\t\t since we haven't ruled out the numbers less than\n+\t\t this node's value.  So handle node->left explicitly.  */\n+\t      do_jump_if_equal (bb, index, node->left->low, node->left->case_bb,\n+\t\t\t\tprobability, phi_mapping);\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      /* Node is a range.  These cases are very similar to those for a single\n+\t value, except that we do not start by testing whether this node\n+\t is the one to branch to.  */\n+\n+      if (node->right != 0 && node->left != 0)\n+\t{\n+\t  /* Node has subtrees on both sides.\n+\t     If the right-hand subtree is bounded,\n+\t     test for it first, since we can go straight there.\n+\t     Otherwise, we need to make a branch in the control structure,\n+\t     then handle the two subtrees.  */\n+\t  basic_block test_bb = NULL;\n+\n+\t  if (node_is_bounded (node->right, index_type))\n+\t    {\n+\t      /* Right hand node is fully bounded so we can eliminate any\n+\t\t testing and branch directly to the target code.  */\n+\t      probability\n+\t\t= conditional_probability (node->right->subtree_prob,\n+\t\t\t\t\t   subtree_prob + default_prob);\n+\t      bb = emit_cmp_and_jump_insns (bb, index, node->high, GT_EXPR,\n+\t\t\t\t\t    node->right->case_bb, probability,\n+\t\t\t\t\t    phi_mapping);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Right hand node requires testing.\n+\t\t Branch to a label where we will handle it later.  */\n+\n+\t      test_bb = split_edge (single_succ_edge (bb));\n+\t      redirect_edge_succ (single_pred_edge (test_bb),\n+\t\t\t\t  single_succ_edge (bb)->dest);\n+\n+\t      probability\n+\t\t= conditional_probability (node->right->subtree_prob\n+\t\t\t\t\t     + default_prob.apply_scale (1, 2),\n+\t\t\t\t\t   subtree_prob + default_prob);\n+\t      bb = emit_cmp_and_jump_insns (bb, index, node->high, GT_EXPR,\n+\t\t\t\t\t    test_bb, probability, phi_mapping);\n+\t      default_prob = default_prob.apply_scale (1, 2);\n+\t    }\n+\n+\t  /* Value belongs to this node or to the left-hand subtree.  */\n+\n+\t  probability\n+\t    = conditional_probability (prob, subtree_prob + default_prob);\n+\t  bb = emit_cmp_and_jump_insns (bb, index, node->low, GE_EXPR,\n+\t\t\t\t\tnode->case_bb, probability,\n+\t\t\t\t\tphi_mapping);\n+\n+\t  /* Handle the left-hand subtree.  */\n+\t  bb = emit_case_nodes (bb, index, node->left, default_bb,\n+\t\t\t\tdefault_label, default_prob, index_type,\n+\t\t\t\tphi_mapping);\n+\n+\t  /* If right node had to be handled later, do that now.  */\n+\t  if (test_bb)\n+\t    {\n+\t      /* If the left-hand subtree fell through,\n+\t\t don't let it fall into the right-hand subtree.  */\n+\t      if (bb && default_bb)\n+\t\temit_jump (bb, default_bb, phi_mapping);\n+\n+\t      bb = emit_case_nodes (test_bb, index, node->right, default_bb,\n+\t\t\t\t    default_label, default_prob, index_type,\n+\t\t\t\t    phi_mapping);\n+\t    }\n+\t}\n+\n+      else if (node->right != 0 && node->left == 0)\n+\t{\n+\t  /* Deal with values to the left of this node,\n+\t     if they are possible.  */\n+\t  if (!node_has_low_bound (node, index_type))\n+\t    {\n+\t      probability\n+\t\t= conditional_probability (default_prob.apply_scale (1, 2),\n+\t\t\t\t\t   subtree_prob + default_prob);\n+\t      bb = emit_cmp_and_jump_insns (bb, index, node->low, LT_EXPR,\n+\t\t\t\t\t    default_bb, probability,\n+\t\t\t\t\t    phi_mapping);\n+\t      default_prob = default_prob.apply_scale (1, 2);\n+\t    }\n+\n+\t  /* Value belongs to this node or to the right-hand subtree.  */\n+\n+\t  probability\n+\t    = conditional_probability (prob, subtree_prob + default_prob);\n+\t  bb = emit_cmp_and_jump_insns (bb, index, node->high, LE_EXPR,\n+\t\t\t\t\tnode->case_bb, probability,\n+\t\t\t\t\tphi_mapping);\n+\n+\t  bb = emit_case_nodes (bb, index, node->right, default_bb,\n+\t\t\t\tdefault_label, default_prob, index_type,\n+\t\t\t\tphi_mapping);\n+\t}\n+\n+      else if (node->right == 0 && node->left != 0)\n+\t{\n+\t  /* Deal with values to the right of this node,\n+\t     if they are possible.  */\n+\t  if (!node_has_high_bound (node, index_type))\n+\t    {\n+\t      probability\n+\t\t= conditional_probability (default_prob.apply_scale (1, 2),\n+\t\t\t\t\t   subtree_prob + default_prob);\n+\t      bb = emit_cmp_and_jump_insns (bb, index, node->high, GT_EXPR,\n+\t\t\t\t\t    default_bb, probability,\n+\t\t\t\t\t    phi_mapping);\n+\t      default_prob = default_prob.apply_scale (1, 2);\n+\t    }\n+\n+\t  /* Value belongs to this node or to the left-hand subtree.  */\n+\n+\t  probability\n+\t    = conditional_probability (prob, subtree_prob + default_prob);\n+\t  bb = emit_cmp_and_jump_insns (bb, index, node->low, GE_EXPR,\n+\t\t\t\t\tnode->case_bb, probability,\n+\t\t\t\t\tphi_mapping);\n+\n+\t  bb = emit_case_nodes (bb, index, node->left, default_bb,\n+\t\t\t\tdefault_label, default_prob, index_type,\n+\t\t\t\tphi_mapping);\n+\t}\n+\n+      else\n+\t{\n+\t  /* Node has no children so we check low and high bounds to remove\n+\t     redundant tests.  Only one of the bounds can exist,\n+\t     since otherwise this node is bounded--a case tested already.  */\n+\t  bool high_bound = node_has_high_bound (node, index_type);\n+\t  bool low_bound = node_has_low_bound (node, index_type);\n+\n+\t  if (!high_bound && low_bound)\n+\t    {\n+\t      probability\n+\t\t= conditional_probability (default_prob,\n+\t\t\t\t\t   subtree_prob + default_prob);\n+\t      bb = emit_cmp_and_jump_insns (bb, index, node->high, GT_EXPR,\n+\t\t\t\t\t    default_bb, probability,\n+\t\t\t\t\t    phi_mapping);\n+\t    }\n+\n+\t  else if (!low_bound && high_bound)\n+\t    {\n+\t      probability\n+\t\t= conditional_probability (default_prob,\n+\t\t\t\t\t   subtree_prob + default_prob);\n+\t      bb = emit_cmp_and_jump_insns (bb, index, node->low, LT_EXPR,\n+\t\t\t\t\t    default_bb, probability,\n+\t\t\t\t\t    phi_mapping);\n+\t    }\n+\t  else if (!low_bound && !high_bound)\n+\t    {\n+\t      tree type = TREE_TYPE (index);\n+\t      tree utype = unsigned_type_for (type);\n+\n+\t      tree lhs = make_ssa_name (type);\n+\t      gassign *sub1\n+\t\t= gimple_build_assign (lhs, MINUS_EXPR, index, node->low);\n+\n+\t      tree converted = make_ssa_name (utype);\n+\t      gassign *a = gimple_build_assign (converted, NOP_EXPR, lhs);\n+\n+\t      tree rhs = fold_build2 (MINUS_EXPR, utype,\n+\t\t\t\t      fold_convert (type, node->high),\n+\t\t\t\t      fold_convert (type, node->low));\n+\t      gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+\t      gsi_insert_before (&gsi, sub1, GSI_SAME_STMT);\n+\t      gsi_insert_before (&gsi, a, GSI_SAME_STMT);\n+\n+\t      probability\n+\t\t= conditional_probability (default_prob,\n+\t\t\t\t\t   subtree_prob + default_prob);\n+\t      bb = emit_cmp_and_jump_insns (bb, converted, rhs, GT_EXPR,\n+\t\t\t\t\t    default_bb, probability,\n+\t\t\t\t\t    phi_mapping);\n+\t    }\n+\n+\t  emit_jump (bb, node->case_bb, phi_mapping);\n+\t  return NULL;\n+\t}\n+    }\n+\n+  return bb;\n+}\n+\n+/* Search the parent sections of the case node tree\n+   to see if a test for the lower bound of NODE would be redundant.\n+   INDEX_TYPE is the type of the index expression.\n+\n+   The instructions to generate the case decision tree are\n+   output in the same order as nodes are processed so it is\n+   known that if a parent node checks the range of the current\n+   node minus one that the current node is bounded at its lower\n+   span.  Thus the test would be redundant.  */\n+\n+static bool\n+node_has_low_bound (case_node_ptr node, tree index_type)\n+{\n+  tree low_minus_one;\n+  case_node_ptr pnode;\n+\n+  /* If the lower bound of this node is the lowest value in the index type,\n+     we need not test it.  */\n+\n+  if (tree_int_cst_equal (node->low, TYPE_MIN_VALUE (index_type)))\n+    return true;\n+\n+  /* If this node has a left branch, the value at the left must be less\n+     than that at this node, so it cannot be bounded at the bottom and\n+     we need not bother testing any further.  */\n+\n+  if (node->left)\n+    return false;\n+\n+  low_minus_one = fold_build2 (MINUS_EXPR, TREE_TYPE (node->low), node->low,\n+\t\t\t       build_int_cst (TREE_TYPE (node->low), 1));\n+\n+  /* If the subtraction above overflowed, we can't verify anything.\n+     Otherwise, look for a parent that tests our value - 1.  */\n+\n+  if (!tree_int_cst_lt (low_minus_one, node->low))\n+    return false;\n+\n+  for (pnode = node->parent; pnode; pnode = pnode->parent)\n+    if (tree_int_cst_equal (low_minus_one, pnode->high))\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Search the parent sections of the case node tree\n+   to see if a test for the upper bound of NODE would be redundant.\n+   INDEX_TYPE is the type of the index expression.\n+\n+   The instructions to generate the case decision tree are\n+   output in the same order as nodes are processed so it is\n+   known that if a parent node checks the range of the current\n+   node plus one that the current node is bounded at its upper\n+   span.  Thus the test would be redundant.  */\n+\n+static bool\n+node_has_high_bound (case_node_ptr node, tree index_type)\n+{\n+  tree high_plus_one;\n+  case_node_ptr pnode;\n+\n+  /* If there is no upper bound, obviously no test is needed.  */\n+\n+  if (TYPE_MAX_VALUE (index_type) == NULL)\n+    return true;\n+\n+  /* If the upper bound of this node is the highest value in the type\n+     of the index expression, we need not test against it.  */\n+\n+  if (tree_int_cst_equal (node->high, TYPE_MAX_VALUE (index_type)))\n+    return true;\n+\n+  /* If this node has a right branch, the value at the right must be greater\n+     than that at this node, so it cannot be bounded at the top and\n+     we need not bother testing any further.  */\n+\n+  if (node->right)\n+    return false;\n+\n+  high_plus_one = fold_build2 (PLUS_EXPR, TREE_TYPE (node->high), node->high,\n+\t\t\t       build_int_cst (TREE_TYPE (node->high), 1));\n+\n+  /* If the addition above overflowed, we can't verify anything.\n+     Otherwise, look for a parent that tests our value + 1.  */\n+\n+  if (!tree_int_cst_lt (node->high, high_plus_one))\n+    return false;\n+\n+  for (pnode = node->parent; pnode; pnode = pnode->parent)\n+    if (tree_int_cst_equal (high_plus_one, pnode->low))\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Search the parent sections of the\n+   case node tree to see if both tests for the upper and lower\n+   bounds of NODE would be redundant.  */\n+\n+static bool\n+node_is_bounded (case_node_ptr node, tree index_type)\n+{\n+  return (node_has_low_bound (node, index_type)\n+\t  && node_has_high_bound (node, index_type));\n+}"}]}