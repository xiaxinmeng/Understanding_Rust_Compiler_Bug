{"sha": "4e7d5d2733308bac25794673fa0cc2ae8e2947ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU3ZDVkMjczMzMwOGJhYzI1Nzk0NjczZmEwY2MyYWU4ZTI5NDdhYw==", "commit": {"author": {"name": "David S. Miller", "email": "davem@redhat.com", "date": "2002-05-09T10:38:44Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2002-05-09T10:38:44Z"}, "message": "sparc.h (TARGET_BUGGY_QP_LIB): Define to zero.\n\n2002-05-07  David S. Miller  <davem@redhat.com>\n\n\t* config/sparc/sparc.h (TARGET_BUGGY_QP_LIB): Define to zero.\n\t* config/sparc/sol2.h (TARGET_BUGGY_QP_LIB): Override to one.\n\t* config/sparc/sparc.c (emit_soft_tfmode_libcall): If the Qp\n\tlibrary implementation clobbers the output before the inputs\n\tare fully consumed, use stack temporary for the output.\n\nFrom-SVN: r53322", "tree": {"sha": "d04642ef22117a3979511677417378ceeb18d417", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d04642ef22117a3979511677417378ceeb18d417"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e7d5d2733308bac25794673fa0cc2ae8e2947ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e7d5d2733308bac25794673fa0cc2ae8e2947ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e7d5d2733308bac25794673fa0cc2ae8e2947ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e7d5d2733308bac25794673fa0cc2ae8e2947ac/comments", "author": null, "committer": null, "parents": [{"sha": "0a0576f3f1edcfdea0122ce5190e5017e7fd73ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a0576f3f1edcfdea0122ce5190e5017e7fd73ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a0576f3f1edcfdea0122ce5190e5017e7fd73ab"}], "stats": {"total": 49, "additions": 29, "deletions": 20}, "files": [{"sha": "9bf0db8d6f625c37369e445eae56693accc37e98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7d5d2733308bac25794673fa0cc2ae8e2947ac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7d5d2733308bac25794673fa0cc2ae8e2947ac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4e7d5d2733308bac25794673fa0cc2ae8e2947ac", "patch": "@@ -1,3 +1,11 @@\n+2002-05-07  David S. Miller  <davem@redhat.com>\n+\n+\t* config/sparc/sparc.h (TARGET_BUGGY_QP_LIB): Define to zero.\n+\t* config/sparc/sol2.h (TARGET_BUGGY_QP_LIB): Override to one.\n+\t* config/sparc/sparc.c (emit_soft_tfmode_libcall): If the Qp\n+\tlibrary implementation clobbers the output before the inputs\n+\tare fully consumed, use stack temporary for the output.\n+\n 2002-05-09  Jason Thorpe  <thorpej@wasabisystems.com>\n \n \t* config/netbsd.h (CPP_SPEC): Remove."}, {"sha": "f27b3ad73d23ba72d5c07f8fce1481a266579fbe", "filename": "gcc/config/sparc/sol2.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7d5d2733308bac25794673fa0cc2ae8e2947ac/gcc%2Fconfig%2Fsparc%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7d5d2733308bac25794673fa0cc2ae8e2947ac/gcc%2Fconfig%2Fsparc%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2.h?ref=4e7d5d2733308bac25794673fa0cc2ae8e2947ac", "patch": "@@ -225,6 +225,12 @@ Boston, MA 02111-1307, USA.  */\n #define MODDI3_LIBCALL \"__rem64\"\n #define UMODDI3_LIBCALL \"__urem64\"\n \n+/* Solaris's _Qp_* library routine implementation clobbers the output\n+   memory before the inputs are fully consumed.  */\n+\n+#undef TARGET_BUGGY_QP_LIB\n+#define TARGET_BUGGY_QP_LIB\t1\n+\n #undef INIT_SUBTARGET_OPTABS\n #define INIT_SUBTARGET_OPTABS\t\t\t\t\t\t\\\n   fixsfdi_libfunc\t\t\t\t\t\t\t\\"}, {"sha": "6219be324e5f9f1c789d151b96fba218fa41d1cc", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7d5d2733308bac25794673fa0cc2ae8e2947ac/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7d5d2733308bac25794673fa0cc2ae8e2947ac/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=4e7d5d2733308bac25794673fa0cc2ae8e2947ac", "patch": "@@ -2476,7 +2476,7 @@ emit_soft_tfmode_libcall (func_name, nargs, operands)\n      rtx *operands;\n {\n   rtx ret_slot = NULL, arg[3], func_sym;\n-  int i, j;\n+  int i;\n \n   /* We only expect to be called for conversions, unary, and binary ops.  */\n   if (nargs < 2 || nargs > 3)\n@@ -2490,27 +2490,17 @@ emit_soft_tfmode_libcall (func_name, nargs, operands)\n       /* TFmode arguments and return values are passed by reference.  */\n       if (GET_MODE (this_arg) == TFmode)\n \t{\n-\t  if (GET_CODE (this_arg) == MEM)\n-\t    {\n-\t      this_arg = XEXP (this_arg, 0);\n+\t  int force_stack_temp;\n \n-\t      /* Make sure the output is not in the same place\n-\t\t as one of our inputs.  */\n-\t      if (i == 0)\n-\t\t{\n-\t\t  for (j = 1; j < nargs; j++)\n-\t\t    if (rtx_equal_p (operands[0], operands[j]))\n-\t\t      break;\n+\t  force_stack_temp = 0;\n+\t  if (TARGET_BUGGY_QP_LIB && i == 0)\n+\t    force_stack_temp = 1;\n \n-\t\t  if (j != nargs)\n-\t\t    {\n-\t\t      ret_slot = assign_stack_temp (TFmode,\n-\t\t\t\t\t\t    GET_MODE_SIZE (TFmode), 0);\n-\t\t      this_arg = XEXP (ret_slot, 0);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else if (CONSTANT_P (this_arg))\n+\t  if (GET_CODE (this_arg) == MEM\n+\t      && ! force_stack_temp)\n+\t    this_arg = XEXP (this_arg, 0);\n+\t  else if (CONSTANT_P (this_arg)\n+\t\t   && ! force_stack_temp)\n \t    {\n \t      this_slot = force_const_mem (TFmode, this_arg);\n \t      this_arg = XEXP (this_slot, 0);"}, {"sha": "1b3b2ead507a12a672bebb51724a2e52c4657eb4", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7d5d2733308bac25794673fa0cc2ae8e2947ac/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7d5d2733308bac25794673fa0cc2ae8e2947ac/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=4e7d5d2733308bac25794673fa0cc2ae8e2947ac", "patch": "@@ -2598,6 +2598,11 @@ do {                                                                    \\\n #define LTTF2_LIBCALL \"_Q_flt\"\n #define LETF2_LIBCALL \"_Q_fle\"\n \n+/* Assume by default that the _Qp_* 64-bit libcalls are implemented such\n+   that the inputs are fully consumed before the output memory is clobbered.  */\n+\n+#define TARGET_BUGGY_QP_LIB\t0\n+\n /* We can define the TFmode sqrt optab only if TARGET_FPU.  This is because\n    with soft-float, the SFmode and DFmode sqrt instructions will be absent,\n    and the compiler will notice and try to use the TFmode sqrt instruction"}]}