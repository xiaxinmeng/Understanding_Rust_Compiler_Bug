{"sha": "2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA5MGQ2YTBhODQ1YzU4YTNjNWVkNmM0MjYwZGI1YzE3OGVjNTUxMQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2006-02-07T18:31:27Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2006-02-07T18:31:27Z"}, "message": "tree-vrp.c (find_conditional_asserts): Update comments.\n\n\n2006-02-07  Jeff Law  <law@redhat.com>\n\n\t* tree-vrp.c (find_conditional_asserts): Update comments.\n\t(simplify_stmt_for_jump_threading): New.\n\t(identify_jump_threads, finalize_jump_threads): New.\n\t(vrp_finalize): Call identify_jump_threads.\n\t(execute_vrp): Call finalize_jump_threads.\n\t* tree-ssa-dom.c (struct opt_stats_d): Remove num_iterations field.\n\t(vrp_element, vrp_data, vrp_element_p): Remove.\n\t(vrp_hash_elt, vrp_variables_stack): Remove.\n\t(vrp_hash, vrp_eq, record_range): Remove.\n\t(simplify_cond_and_lookup_avail_expr): Remove.\n\t(extract_range_from_cond): Remove.\n\t(thread_across_edge): Relocated into tree-ssa-threadedge.c.\n\t(simplify_stmt_for_jump_threading): New.\n\t(dom_thread_across_edge): New wrapper.\n\t(tree_ssa_dominator_optimize): No longer initialize or\n\tfinalize any of the VRP datastructures.  Remove iteration\n\tstep and simplify as a result of removal of iteration step.\n\t(pass_dominator): Perform a cfg cleanup after DOM.\n\t(dom_opt_finalize_block): Use the new common routines\n\tfor threading jumps.  Simplify stack management slightly.\n\tNo longer need to unwind VRP state.\n\t(record_equivalences_from_incoming_edge): No longer record\n\tVRP information.\n\t(eliminate_redundant_computations): No longer call\n\tsimplify_cond_and_lookup_avail_expr.\n\t* tree-flow.h (potentially_threadable_block): Prototype.\n\t(thread_across_edge): Likewise.\n\t* Makefile.in (OBJS-common):  Add tree-ssa-threadedge.o\n\t(tree-ssa-threadedge.o): Add dependencies.\n\t* tree-ssa-threadedge.c: New file.\n\t* passes.c (init_optimization_passes): Merge PHIs before\n\tcalling VRP.  Run VRP again late in the SSA optimization pipeline.\n\n\n\t* gcc.dg/tree-ssa/vrp01.c: Update dumpfile names now that we have\n\tmultiple VRP passes.\n\t* gcc.dg/tree-ssa/vrp09.c: Likewise.\n\t* gcc.dg/tree-ssa/vrp18.c: Likewise.\n\t* gcc.dg/tree-ssa/pr21582.c: Likewise.\n\t* gcc.dg/tree-ssa/pr20657.c: Likewise.\n\t* gcc.dg/tree-ssa/pr21001.c: Likewise.\n\t* gcc.dg/tree-ssa/vrp02.c: Likewise\n\t* gcc.dg/tree-ssa/vrp11.c: Likewise\n\t* gcc.dg/tree-ssa/pr14341.c: Likewise\n\t* gcc.dg/tree-ssa/vrp19.c: Likewise\n\t* gcc.dg/tree-ssa/vrp20.c: Likewise\n\t* gcc.dg/tree-ssa/vrp03.c: Likewise\n\t* gcc.dg/tree-ssa/pr21086.c: Likewise\n\t* gcc.dg/tree-ssa/pr21959.c: Likewise\n\t* gcc.dg/tree-ssa/vrp21.c: Likewise\n\t* gcc.dg/tree-ssa/vrp04.c: Likewise \n\t* gcc.dg/tree-ssa/pr25485.c: Likewise\n\t* gcc.dg/tree-ssa/pr22026.c: Likewise\n\t* gcc.dg/tree-ssa/vrp22.c: Likewise\n\t* gcc.dg/tree-ssa/vrp05.c: Likewise\n\t* gcc.dg/tree-ssa/20030807-10.c: Likewise\n\t* gcc.dg/tree-ssa/pr20701.c: Likewise\n\t* gcc.dg/tree-ssa/vrp23.c: Likewise\n\t* gcc.dg/tree-ssa/vrp06.c: Likewise\n\t* gcc.dg/tree-ssa/pr22117.c: Likewise\n\t* gcc.dg/tree-ssa/pr20702.c: Likewise\n\t* gcc.dg/tree-ssa/vrp15.c: Likewise\n\t* gcc.dg/tree-ssa/pr21090.c: Likewise\n\t* gcc.dg/tree-ssa/pr21294.c: Likewise\n\t* gcc.dg/tree-ssa/vrp24.c: Likewise\n\t* gcc.dg/tree-ssa/vrp07.c: Likewise\n\t* gcc.dg/tree-ssa/pr21563.c: Likewise\n\t* gcc.dg/tree-ssa/pr25382.c: Likewise\n\t* gcc.dg/tree-ssa/vrp16.c: Likewise\n\t* gcc.dg/tree-ssa/vrp25.c: Likewise\n\t* gcc.dg/tree-ssa/vrp08.c: Likewise\n\t* gcc.dg/tree-ssa/20030807-6.c: Likewise\n\t* gcc.dg/tree-ssa/vrp17.c: Likewise\n\t* gcc.dg/tree-ssa/pr21458.c: Likewise\n\t* g++.dg/tree-ssa/pr18178.C: Likewise\n\nFrom-SVN: r110705", "tree": {"sha": "f40ff9efe37c223c42c8db07c3380701f619612c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f40ff9efe37c223c42c8db07c3380701f619612c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/comments", "author": null, "committer": null, "parents": [{"sha": "e45dcf9c6eaabca7e9df6e92361c82c0d0ae23d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e45dcf9c6eaabca7e9df6e92361c82c0d0ae23d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e45dcf9c6eaabca7e9df6e92361c82c0d0ae23d0"}], "stats": {"total": 2106, "additions": 1021, "deletions": 1085}, "files": [{"sha": "4d25bc030622f0f49366af303e8b3b517d0ff8e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,3 +1,38 @@\n+2006-02-07  Jeff Law  <law@redhat.com>\n+\n+\t* tree-vrp.c (find_conditional_asserts): Update comments.\n+\t(simplify_stmt_for_jump_threading): New.\n+\t(identify_jump_threads, finalize_jump_threads): New.\n+\t(vrp_finalize): Call identify_jump_threads.\n+\t(execute_vrp): Call finalize_jump_threads.\n+\t* tree-ssa-dom.c (struct opt_stats_d): Remove num_iterations field.\n+\t(vrp_element, vrp_data, vrp_element_p): Remove.\n+\t(vrp_hash_elt, vrp_variables_stack): Remove.\n+\t(vrp_hash, vrp_eq, record_range): Remove.\n+\t(simplify_cond_and_lookup_avail_expr): Remove.\n+\t(extract_range_from_cond): Remove.\n+\t(thread_across_edge): Relocated into tree-ssa-threadedge.c.\n+\t(simplify_stmt_for_jump_threading): New.\n+\t(dom_thread_across_edge): New wrapper.\n+\t(tree_ssa_dominator_optimize): No longer initialize or\n+\tfinalize any of the VRP datastructures.  Remove iteration\n+\tstep and simplify as a result of removal of iteration step.\n+\t(pass_dominator): Perform a cfg cleanup after DOM.\n+\t(dom_opt_finalize_block): Use the new common routines\n+\tfor threading jumps.  Simplify stack management slightly.\n+\tNo longer need to unwind VRP state.\n+\t(record_equivalences_from_incoming_edge): No longer record\n+\tVRP information.\n+\t(eliminate_redundant_computations): No longer call\n+\tsimplify_cond_and_lookup_avail_expr.\n+\t* tree-flow.h (potentially_threadable_block): Prototype.\n+\t(thread_across_edge): Likewise.\n+\t* Makefile.in (OBJS-common):  Add tree-ssa-threadedge.o\n+\t(tree-ssa-threadedge.o): Add dependencies.\n+\t* tree-ssa-threadedge.c: New file.\n+\t* passes.c (init_optimization_passes): Merge PHIs before\n+\tcalling VRP.  Run VRP again late in the SSA optimization pipeline.\n+\n 2006-02-07  Richard Guenther  <rguenther@suse.de>\n \n \tPR c++/26140"}, {"sha": "09786c990873d691207e7a37d841b138ecfea142", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -961,7 +961,7 @@ OBJS-common = \\\n  tree-ssa-dom.o domwalk.o tree-tailcall.o gimple-low.o tree-iterator.o\t   \\\n  omp-low.o tree-phinodes.o tree-ssanames.o tree-sra.o tree-complex.o\t   \\\n  tree-vect-generic.o tree-ssa-loop.o tree-ssa-loop-niter.o\t\t   \\\n- tree-ssa-loop-manip.o tree-ssa-threadupdate.o\t\t\t\t   \\\n+ tree-ssa-loop-manip.o tree-ssa-threadupdate.o tree-ssa-threadedge.o\t   \\\n  tree-vectorizer.o tree-vect-analyze.o tree-vect-transform.o\t\t   \\\n  tree-vect-patterns.o                                                      \\\n  tree-ssa-loop-ivcanon.o tree-ssa-propagate.o tree-ssa-address.o\t   \\\n@@ -1860,6 +1860,10 @@ tree-ssa-uncprop.o : tree-ssa-uncprop.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(DIAGNOSTIC_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\\n    $(TREE_DUMP_H) $(BASIC_BLOCK_H) domwalk.h real.h tree-pass.h $(FLAGS_H) \\\n    langhooks.h tree-ssa-propagate.h\n+tree-ssa-threadedge.o : tree-ssa-threadedge.c $(TREE_FLOW_H) $(CONFIG_H) \\\n+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \\\n+   $(DIAGNOSTIC_H) $(FUNCTION_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n+   $(BASIC_BLOCK_H) $(FLAGS_H) tree-pass.h $(CFGLOOP_H)\n tree-ssa-threadupdate.o : tree-ssa-threadupdate.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \\\n    $(DIAGNOSTIC_H) $(FUNCTION_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\"}, {"sha": "8234ba159b0a21fc4552495af302b624e6dd847f", "filename": "gcc/passes.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,6 +1,6 @@\n /* Top level of GCC compilers (cc1, cc1plus, etc.)\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -507,9 +507,9 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_dce);\n   NEXT_PASS (pass_forwprop);\n   NEXT_PASS (pass_copy_prop);\n+  NEXT_PASS (pass_merge_phi);\n   NEXT_PASS (pass_vrp);\n   NEXT_PASS (pass_dce);\n-  NEXT_PASS (pass_merge_phi);\n   NEXT_PASS (pass_dominator);\n \n   /* The only copy propagation opportunities left after DOM\n@@ -560,6 +560,7 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_tree_loop);\n   NEXT_PASS (pass_cse_reciprocals);\n   NEXT_PASS (pass_reassoc);\n+  NEXT_PASS (pass_vrp);\n   NEXT_PASS (pass_dominator);\n \n   /* The only copy propagation opportunities left after DOM"}, {"sha": "c9e44af3d86fddf9e9ea5dd7bffc1d915c194864", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,3 +1,47 @@\n+2006-02-07  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/vrp01.c: Update dumpfile names now that we have\n+\tmultiple VRP passes.\n+\t* gcc.dg/tree-ssa/vrp09.c: Likewise.\n+\t* gcc.dg/tree-ssa/vrp18.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr21582.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr20657.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr21001.c: Likewise.\n+\t* gcc.dg/tree-ssa/vrp02.c: Likewise\n+\t* gcc.dg/tree-ssa/vrp11.c: Likewise\n+\t* gcc.dg/tree-ssa/pr14341.c: Likewise\n+\t* gcc.dg/tree-ssa/vrp19.c: Likewise\n+\t* gcc.dg/tree-ssa/vrp20.c: Likewise\n+\t* gcc.dg/tree-ssa/vrp03.c: Likewise\n+\t* gcc.dg/tree-ssa/pr21086.c: Likewise\n+\t* gcc.dg/tree-ssa/pr21959.c: Likewise\n+\t* gcc.dg/tree-ssa/vrp21.c: Likewise\n+\t* gcc.dg/tree-ssa/vrp04.c: Likewise \n+\t* gcc.dg/tree-ssa/pr25485.c: Likewise\n+\t* gcc.dg/tree-ssa/pr22026.c: Likewise\n+\t* gcc.dg/tree-ssa/vrp22.c: Likewise\n+\t* gcc.dg/tree-ssa/vrp05.c: Likewise\n+\t* gcc.dg/tree-ssa/20030807-10.c: Likewise\n+\t* gcc.dg/tree-ssa/pr20701.c: Likewise\n+\t* gcc.dg/tree-ssa/vrp23.c: Likewise\n+\t* gcc.dg/tree-ssa/vrp06.c: Likewise\n+\t* gcc.dg/tree-ssa/pr22117.c: Likewise\n+\t* gcc.dg/tree-ssa/pr20702.c: Likewise\n+\t* gcc.dg/tree-ssa/vrp15.c: Likewise\n+\t* gcc.dg/tree-ssa/pr21090.c: Likewise\n+\t* gcc.dg/tree-ssa/pr21294.c: Likewise\n+\t* gcc.dg/tree-ssa/vrp24.c: Likewise\n+\t* gcc.dg/tree-ssa/vrp07.c: Likewise\n+\t* gcc.dg/tree-ssa/pr21563.c: Likewise\n+\t* gcc.dg/tree-ssa/pr25382.c: Likewise\n+\t* gcc.dg/tree-ssa/vrp16.c: Likewise\n+\t* gcc.dg/tree-ssa/vrp25.c: Likewise\n+\t* gcc.dg/tree-ssa/vrp08.c: Likewise\n+\t* gcc.dg/tree-ssa/20030807-6.c: Likewise\n+\t* gcc.dg/tree-ssa/vrp17.c: Likewise\n+\t* gcc.dg/tree-ssa/pr21458.c: Likewise\n+\t* g++.dg/tree-ssa/pr18178.C: Likewise\n+\n 2006-02-07  Richard Guenther  <rguenther@suse.de>\n \n \tPR c++/26140"}, {"sha": "9223e8323c0a82ff603fefa429c2a93e0d2e3b29", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr18178.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr18178.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr18178.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr18178.C?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n // Define this to see it work.\n // #define WORK_WORK_WORK\n@@ -43,5 +43,5 @@ void doit (array *a)\n \n /* VRP should remove all but 1 if() in the loop.  */\n \n-/* { dg-final { scan-tree-dump-times \"if \" 1 \"vrp\"} } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"if \" 1 \"vrp1\"} } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "fe5e859ee5d0dd867298c931ed41a92a6a17bf3e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030807-10.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030807-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030807-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030807-10.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n      \n \n extern const unsigned char mode_size[];\n@@ -18,9 +18,9 @@ subreg_highpart_offset (outermode, innermode)\n }\n \n /* There should be one mask with the value 3.  */\n-/* { dg-final { scan-tree-dump-times \" \\& 3\" 1 \"vrp\"} } */\n+/* { dg-final { scan-tree-dump-times \" \\& 3\" 1 \"vrp1\"} } */\n   \n /* There should be one right shift by 2 places.  */\n-/* { dg-final { scan-tree-dump-times \" >> 2\" 1 \"vrp\"} } */\n+/* { dg-final { scan-tree-dump-times \" >> 2\" 1 \"vrp1\"} } */\n \n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "8a6506b3d6ca1acafee77da2890ecaeaeb69c79f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030807-6.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030807-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030807-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030807-6.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n      \n \n void\n@@ -39,5 +39,5 @@ foo4 (distance, i, j)\n }\n \n /* There should be no ABS_EXPR.  */\n-/* { dg-final { scan-tree-dump-times \"ABS_EXPR \" 0 \"vrp\"} } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"ABS_EXPR \" 0 \"vrp1\"} } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "ee661a0f3a99823a6c68513500496dd8ff6531fd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr14341.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr14341.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr14341.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr14341.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n void fn_call (int);\n int h(int, int);\n@@ -12,5 +12,5 @@ void t()\n     }\n }\n \n-/* { dg-final { scan-tree-dump-times \"fn_call \\\\(1\\\\)\" 1 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"fn_call \\\\(1\\\\)\" 1 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "1c3dbf9fd66d8ca82ca1edc01e2ca0aa6fb4abae", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr20657.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20657.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20657.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20657.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -3,7 +3,7 @@\n    statement, which was needed to eliminate the second \"if\" statement.  */\n \n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fno-tree-dominator-opts -fdump-tree-vrp-details\" } */\n+/* { dg-options \"-O2 -fno-tree-dominator-opts -fdump-tree-vrp1-details\" } */\n \n int\n foo (int a)\n@@ -14,5 +14,5 @@ foo (int a)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate\" 1 \"vrp\"} } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate\" 1 \"vrp1\"} } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "708bee19d32fe22bcd952eb4cff77f152a3e18df", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr20701.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20701.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20701.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20701.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n typedef struct {\n   int code;\n@@ -26,5 +26,5 @@ can_combine_p (rtx insn, rtx elt)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate.*to 0\" 1 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate.*to 0\" 1 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "0e1b4e6d3be1458f28750d8233ef79cae55862f8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr20702.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20702.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20702.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20702.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -4,7 +4,7 @@\n    immediate successors of the basic block.  */\n \n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fno-tree-dominator-opts -fdump-tree-vrp-details\" } */\n+/* { dg-options \"-O2 -fno-tree-dominator-opts -fdump-tree-vrp1-details\" } */\n \n extern void bar (int);\n \n@@ -25,5 +25,5 @@ foo (int *p, int b)\n   return a;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate\" 1 \"vrp\"} } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate\" 1 \"vrp1\"} } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "84280b39ccb5445e72a4bb97350d382860e7f843", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21001.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21001.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21001.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21001.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -5,7 +5,7 @@\n    range infomation out of the conditional.  */\n \n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fno-tree-dominator-opts -fdump-tree-vrp-details\" } */\n+/* { dg-options \"-O2 -fno-tree-dominator-opts -fdump-tree-vrp1-details\" } */\n \n int\n foo (int a)\n@@ -17,5 +17,5 @@ foo (int a)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate\" 1 \"vrp\"} } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate\" 1 \"vrp1\"} } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "1498ad75d25a5deee453000d4a8b41492c577b88", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21086.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21086.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21086.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21086.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n int\n foo (int *p)\n@@ -15,5 +15,5 @@ foo (int *p)\n     return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate \" 2 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate \" 2 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "8e32e4217440937f682ec7c574066cca402e3135", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21090.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21090.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21090.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21090.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n int g, h;\n \n@@ -19,5 +19,5 @@ foo (int a)\n     return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate.*to 1\" 1 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate.*to 1\" 1 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "567e6366ad4caaf941e55f9915e244bce23e4c4d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21294.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21294.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21294.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21294.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -4,7 +4,7 @@\n    allows us to eliminate the second \"if\" statement.  */\n \n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fno-tree-dominator-opts -fdump-tree-vrp-details\" } */\n+/* { dg-options \"-O2 -fno-tree-dominator-opts -fdump-tree-vrp1-details\" } */\n \n struct f {\n   int i;\n@@ -19,5 +19,5 @@ foo (struct f *p)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate\" 1 \"vrp\"} } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate\" 1 \"vrp1\"} } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "01777f6e64da8de209d24361db14294908dea4f4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21458.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21458.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21458.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21458.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n extern void g (void);\n extern void bar (int);\n@@ -16,5 +16,5 @@ foo (int a)\n     }\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate.*to 1\" 1 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate.*to 1\" 1 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "8e6c57850b5b850da96634244bb319c43a5d784b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21563.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21563.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21563.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21563.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -2,7 +2,7 @@\n    Make sure VRP folds the second \"if\" statement.  */\n \n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fno-tree-dominator-opts -fdump-tree-vrp-details\" } */\n+/* { dg-options \"-O2 -fno-tree-dominator-opts -fdump-tree-vrp1-details\" } */\n \n int\n foo (int a)\n@@ -13,5 +13,5 @@ foo (int a)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate\" 1 \"vrp\"} } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate\" 1 \"vrp1\"} } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "0f5dc9ec1d492633f79a8333fc18e635339edb80", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21582.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21582.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21582.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21582.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do link }  */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" }  */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" }  */\n \n static inline void do_thing(char *s, int *p, char *q)\n {\n@@ -24,5 +24,5 @@ main()\n   do_other_thing (\"xxx\", &i, \"yyy\");\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate p_.*\" 0 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate p_.*\" 0 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "decbcaf3adcabce32ed3bb097da49a5ad42ddbb4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21959.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21959.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21959.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21959.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n unsigned char c[0xFF];\n void f(void)\n@@ -16,5 +16,5 @@ void f(void)\n   }\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate \" 0 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate \" 0 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "7e6914d9d6bd9fd94b213bc7ed895339d0b09ca8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr22026.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22026.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22026.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22026.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -3,7 +3,7 @@\n    same applies to subtraction and unsigned multiplication.  */\n \n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n int\n plus (int x, int y)\n@@ -45,5 +45,5 @@ mult (unsigned x, unsigned y)\n }\n \n /* None of the predicates can be folded in these functions.  */\n-/* { dg-final { scan-tree-dump-times \"Folding predicate\" 0 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate\" 0 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "d265d5e2c13eb67fe291d62d94f46b2154bef413", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr22117.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22117.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22117.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22117.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -3,7 +3,7 @@\n    known to be zero after entering the first two \"if\" statements.  */\n \n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n void\n foo (int *p, int q)\n@@ -19,5 +19,5 @@ foo (int *p, int q)\n     }\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate r_.* != 0B to 0\" 1 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate r_.* != 0B to 0\" 1 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "a80480094a36bb6fd4d65df55f0a240309d3005b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr25382.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr25382.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr25382.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr25382.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -3,7 +3,7 @@\n    Check that VRP now gets ranges from BIT_AND_EXPRs.  */\n \n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n int\n foo (int a)\n@@ -15,5 +15,5 @@ foo (int a)\n     return 1;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate b_.* > 300 to 0\" 1 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate b_.* > 300 to 0\" 1 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "93f583cc34a0f260857815fabbe7c6980dd14d84", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr25485.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr25485.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr25485.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr25485.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,7 +1,7 @@\n /* PR tree-optimization/25485\n    VRP did not fold TRUTH_AND_EXPR.  Make sure it does now.  */\n \n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n int\n foo (int a, int b)\n@@ -13,5 +13,5 @@ foo (int a, int b)\n   return 31;\n }\n \n-/* { dg-final { scan-tree-dump-times \"if\" 1 \"vrp\"} } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"if\" 1 \"vrp1\"} } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "3f8e820611cdd43769e7e7e8213f3433dd007107", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp01.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp01.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp01.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp01.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n foo (int *p, int i)\n {\n@@ -24,5 +24,5 @@ foo (int *p, int i)\n   return i;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate p_.*to 1\" 1 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate p_.*to 1\" 1 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "d5cd775aaafe13d4e48851626b4add70aff8ebb7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp02.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp02.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp02.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp02.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n struct A\n {\n@@ -20,5 +20,5 @@ foo (struct A *p, struct A *q)\n     return x + p->b;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate p_.*to 1\" 1 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate p_.*to 1\" 1 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "9b7c08256da3683f50cacb7176019a810ddf64bd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp03.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp03.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp03.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp03.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n struct A\n {\n@@ -30,6 +30,6 @@ foo (struct A *p, struct A *q)\n   return q->a;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate q_.*to 1\" 1 \"vrp\" } } */\n-/* { dg-final { scan-tree-dump-times \"Folding predicate r_.*to 1\" 1 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate q_.*to 1\" 1 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate r_.*to 1\" 1 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "bf5d683cb79618eaf3ea877b586129b52d380d76", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp04.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp04.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp04.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp04.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n foo (int a, int b)\n {\n@@ -9,5 +9,5 @@ foo (int a, int b)\n       return a + b;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate a_.*to 1\" 1 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate a_.*to 1\" 1 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "201f8ee5a00f5785fcce0dfb1f4f09ab9dc343de", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp05.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp05.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp05.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp05.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n foo (int k, int j)\n {\n@@ -16,5 +16,5 @@ foo (int k, int j)\n   return j;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate j_.*to 1\" 1 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate j_.*to 1\" 1 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "1ef6c922e8634ef322bf01297ad11ce7be572fdc", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp06.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp06.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp06.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp06.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n foo (int i, int j, int a)\n {\n@@ -25,7 +25,7 @@ foo (int i, int j, int a)\n   return i + a + j;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate i_.*to 0\" 1 \"vrp\" } } */\n-/* { dg-final { scan-tree-dump-times \"Folding predicate j_.*to 1\" 1 \"vrp\" } } */\n-/* { dg-final { scan-tree-dump-times \"Folding predicate i_.*to 0\" 1 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate i_.*to 0\" 1 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate j_.*to 1\" 1 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate i_.*to 0\" 1 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "ec7afe6288b53e5313fb65f689fe49cbb136d93f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp07.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp07.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp07.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp07.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp-details\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1-details\" } */\n \n foo (int i, int *p)\n {\n@@ -30,7 +30,7 @@ foo (int i, int *p)\n   return i;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate p_.*to 1\" 1 \"vrp\" } } */\n-/* { dg-final { scan-tree-dump-times \"Folding predicate p_.*to 0\" 1 \"vrp\" } } */\n-/* { dg-final { scan-tree-dump-times \"PREDICATE: p_\\[0-9\\] ne_expr 0B\" 2 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate p_.*to 1\" 1 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate p_.*to 0\" 1 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"PREDICATE: p_\\[0-9\\] ne_expr 0B\" 2 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "2b0bbd1a2ecab6a0de38d090ed9325791be44764", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp08.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp08.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp08.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp08.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fno-tree-fre -fdump-tree-vrp-details\" } */\n+/* { dg-options \"-O2 -fno-tree-fre -fdump-tree-vrp1-details\" } */\n \n /* Compile with -fno-tree-fre -O2 to prevent CSEing *p.  */\n foo (int a, int *p)\n@@ -18,6 +18,6 @@ foo (int a, int *p)\n   return a;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate p_.*to 1\" 1 \"vrp\" } } */\n-/* { dg-final { scan-tree-dump-times \"PREDICATE: p_. ne_expr 0\" 1 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate p_.*to 1\" 1 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"PREDICATE: p_. ne_expr 0\" 1 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "9ff0f14f72529211102ec93ab3f3ae6b6d24ebf0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp09.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp09.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp09.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp09.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n foo (int *p)\n {\n@@ -27,5 +27,5 @@ foo (int *p)\n     }\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate p_.. != 0B to 1\" 2 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate p_.. != 0B to 1\" 2 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "d21985626fa3557803eaba7518eebd684efd45f6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp11.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp11.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n foo (int k, int j, int z)\n {\n@@ -16,5 +16,5 @@ foo (int k, int j, int z)\n   return j;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate.*to 1\" 1 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate.*to 1\" 1 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "7e7226487c2bd0535f09c6ac3ae7c0f3a80c8e5a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp15.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp15.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n \n extern void abort (void) __attribute__ ((__noreturn__));\n@@ -29,6 +29,6 @@ blah (tree t)\n \n }\n \n-/* { dg-final { scan-tree-dump-times \"tree_code_length.42.\" 1 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"tree_code_length.42.\" 1 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */\n "}, {"sha": "166529ab98b47e99b9a9843d7fd933b20c1947c8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp16.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp16.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp-details\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1-details\" } */\n \n \n extern void abort (void) __attribute__ ((__noreturn__));\n@@ -18,6 +18,6 @@ nonlocal_mentioned_p (rtx x)\n \tabort ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate .*to 0\" 1 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate .*to 0\" 1 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */\n "}, {"sha": "c04b9ba7843526a707e8f61d0168153fffdcfe9f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp17.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp17.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n extern void abort (void) __attribute__ ((__noreturn__));\n union tree_node;\n@@ -27,6 +27,6 @@ gimplify_for_stmt (tree stmt)\n     abort ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"Simplified relational\" 1 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Simplified relational\" 1 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */\n "}, {"sha": "a3cc536ae56f857fe065fa8aa0907255ab3a40f7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp18.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp18.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n \n static int blocksize = 4096;\n \n@@ -30,5 +30,5 @@ void foo (void)\n     eof_reached = 1;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Simplified relational\" 1 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Simplified relational\" 1 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "e4c884a85d18926ee0e34f5ddf81f1dc50fad801", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp19.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp19.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fwrapv -O1 -ftree-vrp -fdump-tree-vrp\" } */\n+/* { dg-options \"-fwrapv -O1 -ftree-vrp -fdump-tree-vrp1\" } */\n \n #include <limits.h>\n extern void abort ();\n@@ -22,6 +22,6 @@ int g (int b) {\n \t}\n \treturn 1;\n }\n-/* { dg-final { scan-tree-dump \"Folding predicate a_. < 0 to 0\" \"vrp\" } } */\n-/* { dg-final { scan-tree-dump \"Folding predicate b_. >= 0 to 1\" \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump \"Folding predicate a_. < 0 to 0\" \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump \"Folding predicate b_. >= 0 to 1\" \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "14da7df48db55eb7230499e3b4059a8c033a6019", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp20.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp20.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fwrapv -O1 -ftree-vrp -fdump-tree-vrp\" } */\n+/* { dg-options \"-fwrapv -O1 -ftree-vrp -fdump-tree-vrp1\" } */\n \n extern void abort ();\n extern void exit (int);\n@@ -23,6 +23,6 @@ int g (int b) {\n \treturn 1;\n }\n \n-/* { dg-final { scan-tree-dump \"Folding predicate a_. == 0 to 0\" \"vrp\" } } */\n-/* { dg-final { scan-tree-dump \"Folding predicate b_. != 0 to 1\" \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump \"Folding predicate a_. == 0 to 0\" \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump \"Folding predicate b_. != 0 to 1\" \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "0e675d9114731443488711e40507499a5378367f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp21.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp21.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -ftree-vrp -fdump-tree-vrp\" } */\n+/* { dg-options \"-O1 -ftree-vrp -fdump-tree-vrp1\" } */\n \n extern void link_error ();\n \n@@ -22,5 +22,5 @@ void test02(unsigned int a, unsigned int b)\n         link_error ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "6120d07237716edad9ad5c4456bfa897e81b1d9d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp22.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp22.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -ftree-vrp -fdump-tree-vrp\" } */\n+/* { dg-options \"-O1 -ftree-vrp -fdump-tree-vrp1\" } */\n \n extern void link_error ();\n \n@@ -12,5 +12,5 @@ void test02(unsigned int a, unsigned int b)\n         link_error ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "77899a65fcade2039514da746f62547139387333", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp23.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp23.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp-details\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1-details\" } */\n \n blah (int code1, int code2)\n {\n@@ -40,6 +40,6 @@ blah (int code1, int code2)\n /* The n_sets > 0 test can be simplified into n_sets == 1 since the\n    only way to reach the test is when n_sets <= 1, and the only value\n    which satisfies both conditions is n_sets == 1.  */\n-/* { dg-final { scan-tree-dump-times \"Simplified relational\" 1 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Simplified relational\" 1 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */\n "}, {"sha": "b181cfa4c0d11457b2092694a1905a2f3830ce2e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp24.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp24.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp-details\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1-details\" } */\n \n \n struct rtx_def;\n@@ -84,6 +84,6 @@ sss (rtx insn, int code1, int code2, int code3)\n /* The n_sets > 0 test can be simplified into n_sets == 1 since the\n    only way to reach the test is when n_sets <= 1, and the only value\n    which satisfies both conditions is n_sets == 1.  */\n-/* { dg-final { scan-tree-dump-times \"Simplified relational\" 1 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Simplified relational\" 1 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */\n "}, {"sha": "fa8bbfd4c0ec8d3501fc95198986a3ee5ffdf7ac", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp25.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp25.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp-details\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1-details\" } */\n \n extern void abort ();\n int tree_code_length[100];\n@@ -47,6 +47,6 @@ blah (int code1)\n /* The second test of (code1 != 53) and the test (D18670 <= 2) are\n    both totally subsumed by earlier tests and thus should be folded\n    away using VRP.  */\n-/* { dg-final { scan-tree-dump-times \"Folding predicate\" 2 \"vrp\" } } */\n-/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate\" 2 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */\n "}, {"sha": "0e4824e93217c13bad0c6cdbb81ae473b9a0390d", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -749,6 +749,11 @@ tree expand_simple_operations (tree);\n void substitute_in_loop_info (struct loop *, tree, tree);\n edge single_dom_exit (struct loop *);\n \n+/* In tree-ssa-threadedge.c */\n+extern bool potentially_threadable_block (basic_block);\n+extern void thread_across_edge (tree, edge, bool,\n+\t\t\t\tVEC(tree, heap) **, tree (*) (tree));\n+\n /* In tree-ssa-loop-im.c  */\n /* The possibilities of statement movement.  */\n "}, {"sha": "371e53bb182af8dced02c136437a9136c1ba60d9", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 85, "deletions": 952, "changes": 1037, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -1,5 +1,6 @@\n /* SSA Dominator optimizations for trees\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006\n+   Free Software Foundation, Inc.\n    Contributed by Diego Novillo <dnovillo@redhat.com>\n \n This file is part of GCC.\n@@ -160,92 +161,10 @@ struct opt_stats_d\n   long num_re;\n   long num_const_prop;\n   long num_copy_prop;\n-  long num_iterations;\n };\n \n static struct opt_stats_d opt_stats;\n \n-/* Value range propagation record.  Each time we encounter a conditional\n-   of the form SSA_NAME COND CONST we create a new vrp_element to record\n-   how the condition affects the possible values SSA_NAME may have.\n-\n-   Each record contains the condition tested (COND), and the range of\n-   values the variable may legitimately have if COND is true.  Note the\n-   range of values may be a smaller range than COND specifies if we have\n-   recorded other ranges for this variable.  Each record also contains the\n-   block in which the range was recorded for invalidation purposes.\n-\n-   Note that the current known range is computed lazily.  This allows us\n-   to avoid the overhead of computing ranges which are never queried.\n-\n-   When we encounter a conditional, we look for records which constrain\n-   the SSA_NAME used in the condition.  In some cases those records allow\n-   us to determine the condition's result at compile time.  In other cases\n-   they may allow us to simplify the condition.\n-\n-   We also use value ranges to do things like transform signed div/mod\n-   operations into unsigned div/mod or to simplify ABS_EXPRs. \n-\n-   Simple experiments have shown these optimizations to not be all that\n-   useful on switch statements (much to my surprise).  So switch statement\n-   optimizations are not performed.\n-\n-   Note carefully we do not propagate information through each statement\n-   in the block.  i.e., if we know variable X has a value defined of\n-   [0, 25] and we encounter Y = X + 1, we do not track a value range\n-   for Y (which would be [1, 26] if we cared).  Similarly we do not\n-   constrain values as we encounter narrowing typecasts, etc.  */\n-\n-struct vrp_element\n-{\n-  /* The highest and lowest values the variable in COND may contain when\n-     COND is true.  Note this may not necessarily be the same values\n-     tested by COND if the same variable was used in earlier conditionals. \n-\n-     Note this is computed lazily and thus can be NULL indicating that\n-     the values have not been computed yet.  */\n-  tree low;\n-  tree high;\n-\n-  /* The actual conditional we recorded.  This is needed since we compute\n-     ranges lazily.  */\n-  tree cond;\n-\n-  /* The basic block where this record was created.  We use this to determine\n-     when to remove records.  */\n-  basic_block bb;\n-};\n-\n-/* A hash table holding value range records (VRP_ELEMENTs) for a given\n-   SSA_NAME.  We used to use a varray indexed by SSA_NAME_VERSION, but\n-   that gets awful wasteful, particularly since the density objects\n-   with useful information is very low.  */\n-static htab_t vrp_data;\n-\n-typedef struct vrp_element *vrp_element_p;\n-\n-DEF_VEC_P(vrp_element_p);\n-DEF_VEC_ALLOC_P(vrp_element_p,heap);\n-\n-/* An entry in the VRP_DATA hash table.  We record the variable and a\n-   varray of VRP_ELEMENT records associated with that variable.  */\n-struct vrp_hash_elt\n-{\n-  tree var;\n-  VEC(vrp_element_p,heap) *records;\n-};\n-\n-/* Array of variables which have their values constrained by operations\n-   in this basic block.  We use this during finalization to know\n-   which variables need their VRP data updated.  */\n-\n-/* Stack of SSA_NAMEs which had their values constrained by operations\n-   in this basic block.  During finalization of this block we use this\n-   list to determine which variables need their VRP data updated.\n-\n-   A NULL entry marks the end of the SSA_NAMEs associated with this block.  */\n-static VEC(tree,heap) *vrp_variables_stack;\n-\n struct eq_expr_value\n {\n   tree src;\n@@ -257,23 +176,18 @@ static void optimize_stmt (struct dom_walk_data *,\n \t\t\t   basic_block bb,\n \t\t\t   block_stmt_iterator);\n static tree lookup_avail_expr (tree, bool);\n-static hashval_t vrp_hash (const void *);\n-static int vrp_eq (const void *, const void *);\n static hashval_t avail_expr_hash (const void *);\n static hashval_t real_avail_expr_hash (const void *);\n static int avail_expr_eq (const void *, const void *);\n static void htab_statistics (FILE *, htab_t);\n static void record_cond (tree, tree);\n static void record_const_or_copy (tree, tree);\n static void record_equality (tree, tree);\n-static tree simplify_cond_and_lookup_avail_expr (tree);\n-static void record_range (tree, basic_block);\n-static bool extract_range_from_cond (tree, tree *, tree *, int *);\n static void record_equivalences_from_phis (basic_block);\n static void record_equivalences_from_incoming_edge (basic_block);\n static bool eliminate_redundant_computations (tree);\n static void record_equivalences_from_stmt (tree, int, stmt_ann_t);\n-static void thread_across_edge (struct dom_walk_data *, edge);\n+static void dom_thread_across_edge (struct dom_walk_data *, edge);\n static void dom_opt_finalize_block (struct dom_walk_data *, basic_block);\n static void dom_opt_initialize_block (struct dom_walk_data *, basic_block);\n static void propagate_to_outgoing_edges (struct dom_walk_data *, basic_block);\n@@ -328,18 +242,6 @@ free_all_edge_infos (void)\n     }\n }\n \n-/* Free an instance of vrp_hash_elt.  */\n-\n-static void\n-vrp_free (void *data)\n-{\n-  struct vrp_hash_elt *elt = (struct vrp_hash_elt *) data;\n-  struct VEC(vrp_element_p,heap) **vrp_elt = &elt->records;\n-\n-  VEC_free (vrp_element_p, heap, *vrp_elt);\n-  free (elt);\n-}\n-\n /* Jump threading, redundancy elimination and const/copy propagation. \n \n    This pass may expose new symbols that need to be renamed into SSA.  For\n@@ -357,12 +259,9 @@ tree_ssa_dominator_optimize (void)\n \n   /* Create our hash tables.  */\n   avail_exprs = htab_create (1024, real_avail_expr_hash, avail_expr_eq, free);\n-  vrp_data = htab_create (ceil_log2 (num_ssa_names), vrp_hash, vrp_eq,\n-\t\t\t  vrp_free);\n   avail_exprs_stack = VEC_alloc (tree, heap, 20);\n   const_and_copies_stack = VEC_alloc (tree, heap, 20);\n   nonzero_vars_stack = VEC_alloc (tree, heap, 20);\n-  vrp_variables_stack = VEC_alloc (tree, heap, 20);\n   stmts_to_rescan = VEC_alloc (tree, heap, 20);\n   nonzero_vars = BITMAP_ALLOC (NULL);\n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n@@ -401,123 +300,69 @@ tree_ssa_dominator_optimize (void)\n   cleanup_tree_cfg ();\n   calculate_dominance_info (CDI_DOMINATORS);\n \n-  /* If we prove certain blocks are unreachable, then we want to\n-     repeat the dominator optimization process as PHI nodes may\n-     have turned into copies which allows better propagation of\n-     values.  So we repeat until we do not identify any new unreachable\n-     blocks.  */\n-  do\n-    {\n-      /* Optimize the dominator tree.  */\n-      cfg_altered = false;\n-\n-      /* We need accurate information regarding back edges in the CFG\n-\t for jump threading.  */\n-      mark_dfs_back_edges ();\n+  /* We need accurate information regarding back edges in the CFG\n+     for jump threading.  */\n+  mark_dfs_back_edges ();\n \n-      /* Recursively walk the dominator tree optimizing statements.  */\n-      walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n+  /* Recursively walk the dominator tree optimizing statements.  */\n+  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n \n+  {\n+    block_stmt_iterator bsi;\n+    basic_block bb;\n+    FOR_EACH_BB (bb)\n       {\n-\tblock_stmt_iterator bsi;\n-\tbasic_block bb;\n-\tFOR_EACH_BB (bb)\n-\t  {\n-\t    for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\t      {\n-\t\tupdate_stmt_if_modified (bsi_stmt (bsi));\n-\t      }\n-\t  }\n+\tfor (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t  update_stmt_if_modified (bsi_stmt (bsi));\n       }\n+  }\n \n-      /* If we exposed any new variables, go ahead and put them into\n-\t SSA form now, before we handle jump threading.  This simplifies\n-\t interactions between rewriting of _DECL nodes into SSA form\n-\t and rewriting SSA_NAME nodes into SSA form after block\n-\t duplication and CFG manipulation.  */\n-      update_ssa (TODO_update_ssa);\n-\n-      free_all_edge_infos ();\n-\n-      /* Thread jumps, creating duplicate blocks as needed.  */\n-      cfg_altered |= thread_through_all_blocks ();\n-\n-      /* Removal of statements may make some EH edges dead.  Purge\n-\t such edges from the CFG as needed.  */\n-      if (!bitmap_empty_p (need_eh_cleanup))\n-\t{\n-\t  cfg_altered |= tree_purge_all_dead_eh_edges (need_eh_cleanup);\n-\t  bitmap_zero (need_eh_cleanup);\n-\t}\n-\n-      if (cfg_altered)\n-        free_dominance_info (CDI_DOMINATORS);\n+  /* If we exposed any new variables, go ahead and put them into\n+     SSA form now, before we handle jump threading.  This simplifies\n+     interactions between rewriting of _DECL nodes into SSA form\n+     and rewriting SSA_NAME nodes into SSA form after block\n+     duplication and CFG manipulation.  */\n+  update_ssa (TODO_update_ssa);\n \n-      /* Only iterate if we threaded jumps AND the CFG cleanup did\n-\t something interesting.  Other cases generate far fewer\n-\t optimization opportunities and thus are not worth another\n-\t full DOM iteration.  */\n-      cfg_altered &= cleanup_tree_cfg ();\n+  free_all_edge_infos ();\n \n-      if (rediscover_loops_after_threading)\n-\t{\n-\t  /* Rerun basic loop analysis to discover any newly\n-\t     created loops and update the set of exit edges.  */\n-\t  rediscover_loops_after_threading = false;\n-\t  flow_loops_find (&loops_info);\n-\t  mark_loop_exit_edges (&loops_info);\n-\t  flow_loops_free (&loops_info);\n-\n-\t  /* Remove any forwarder blocks inserted by loop\n-\t     header canonicalization.  */\n-\t  cleanup_tree_cfg ();\n-\t}\n-\n-      calculate_dominance_info (CDI_DOMINATORS);\n-\n-      update_ssa (TODO_update_ssa);\n+  /* Thread jumps, creating duplicate blocks as needed.  */\n+  cfg_altered |= thread_through_all_blocks ();\n \n-      /* Reinitialize the various tables.  */\n-      bitmap_clear (nonzero_vars);\n-      htab_empty (avail_exprs);\n-      htab_empty (vrp_data);\n+  /* Removal of statements may make some EH edges dead.  Purge\n+     such edges from the CFG as needed.  */\n+  if (!bitmap_empty_p (need_eh_cleanup))\n+    {\n+      cfg_altered |= tree_purge_all_dead_eh_edges (need_eh_cleanup);\n+      bitmap_zero (need_eh_cleanup);\n+    }\n \n-      /* Finally, remove everything except invariants in SSA_NAME_VALUE.\n+  if (cfg_altered)\n+    free_dominance_info (CDI_DOMINATORS);\n \n-\t This must be done before we iterate as we might have a\n-\t reference to an SSA_NAME which was removed by the call to\n-\t update_ssa.\n+  /* Finally, remove everything except invariants in SSA_NAME_VALUE.\n \n-\t Long term we will be able to let everything in SSA_NAME_VALUE\n-\t persist.  However, for now, we know this is the safe thing to do.  */\n-      for (i = 0; i < num_ssa_names; i++)\n-\t{\n-\t  tree name = ssa_name (i);\n-\t  tree value;\n+     Long term we will be able to let everything in SSA_NAME_VALUE\n+     persist.  However, for now, we know this is the safe thing to do.  */\n+  for (i = 0; i < num_ssa_names; i++)\n+   {\n+      tree name = ssa_name (i);\n+      tree value;\n \n-\t  if (!name)\n-\t    continue;\n+      if (!name)\n+        continue;\n \n-\t  value = SSA_NAME_VALUE (name);\n-\t  if (value && !is_gimple_min_invariant (value))\n-\t    SSA_NAME_VALUE (name) = NULL;\n-\t}\n-\n-      opt_stats.num_iterations++;\n+      value = SSA_NAME_VALUE (name);\n+      if (value && !is_gimple_min_invariant (value))\n+\tSSA_NAME_VALUE (name) = NULL;\n     }\n-  while (optimize > 1 && cfg_altered);\n \n   /* Debugging dumps.  */\n   if (dump_file && (dump_flags & TDF_STATS))\n     dump_dominator_optimization_stats (dump_file);\n \n-  /* We emptied the hash table earlier, now delete it completely.  */\n+  /* Delete our main hashtable.  */\n   htab_delete (avail_exprs);\n-  htab_delete (vrp_data);\n-\n-  /* It is not necessary to clear CURRDEFS, REDIRECTION_EDGES, VRP_DATA,\n-     CONST_AND_COPIES, and NONZERO_VARS as they all get cleared at the bottom\n-     of the do-while loop above.  */\n \n   /* And finalize the dominator walker.  */\n   fini_walk_dominator_tree (&walk_data);\n@@ -529,7 +374,6 @@ tree_ssa_dominator_optimize (void)\n   VEC_free (tree, heap, avail_exprs_stack);\n   VEC_free (tree, heap, const_and_copies_stack);\n   VEC_free (tree, heap, nonzero_vars_stack);\n-  VEC_free (tree, heap, vrp_variables_stack);\n   VEC_free (tree, heap, stmts_to_rescan);\n }\n \n@@ -554,6 +398,7 @@ struct tree_opt_pass pass_dominator =\n   0,\t\t\t\t\t/* todo_flags_start */\n   TODO_dump_func\n     | TODO_update_ssa\n+    | TODO_cleanup_cfg\n     | TODO_verify_ssa,\t\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n@@ -605,321 +450,6 @@ canonicalize_comparison (tree condstmt)\n \t}\n     }\n }\n-/* We are exiting E->src, see if E->dest ends with a conditional\n-   jump which has a known value when reached via E. \n-\n-   Special care is necessary if E is a back edge in the CFG as we\n-   will have already recorded equivalences for E->dest into our\n-   various tables, including the result of the conditional at\n-   the end of E->dest.  Threading opportunities are severely\n-   limited in that case to avoid short-circuiting the loop\n-   incorrectly.\n-\n-   Note it is quite common for the first block inside a loop to\n-   end with a conditional which is either always true or always\n-   false when reached via the loop backedge.  Thus we do not want\n-   to blindly disable threading across a loop backedge.  */\n-\n-static void\n-thread_across_edge (struct dom_walk_data *walk_data, edge e)\n-{\n-  block_stmt_iterator bsi;\n-  tree stmt = NULL;\n-  tree phi;\n-  int stmt_count = 0;\n-  int max_stmt_count;\n-\n-\n-  /* If E->dest does not end with a conditional, then there is\n-     nothing to do.  */\n-  bsi = bsi_last (e->dest);\n-  if (bsi_end_p (bsi)\n-      || ! bsi_stmt (bsi)\n-      || (TREE_CODE (bsi_stmt (bsi)) != COND_EXPR\n-\t  && TREE_CODE (bsi_stmt (bsi)) != GOTO_EXPR\n-\t  && TREE_CODE (bsi_stmt (bsi)) != SWITCH_EXPR))\n-    return;\n-\n-  /* The basic idea here is to use whatever knowledge we have\n-     from our dominator walk to simplify statements in E->dest,\n-     with the ultimate goal being to simplify the conditional\n-     at the end of E->dest.\n-\n-     Note that we must undo any changes we make to the underlying\n-     statements as the simplifications we are making are control\n-     flow sensitive (ie, the simplifications are valid when we \n-     traverse E, but may not be valid on other paths to E->dest.  */\n-     \n-  /* Each PHI creates a temporary equivalence, record them.  Again\n-     these are context sensitive equivalences and will be removed\n-     by our caller.  */\n-  for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n-    {\n-      tree src = PHI_ARG_DEF_FROM_EDGE (phi, e);\n-      tree dst = PHI_RESULT (phi);\n-\n-      /* Do not include virtual PHIs in our statement count as\n-\t they never generate code.  */\n-      if (is_gimple_reg (dst))\n-\tstmt_count++;\n-\n-      /* If the desired argument is not the same as this PHI's result \n-\t and it is set by a PHI in E->dest, then we can not thread\n-\t through E->dest.  */\n-      if (src != dst\n-\t  && TREE_CODE (src) == SSA_NAME\n-\t  && TREE_CODE (SSA_NAME_DEF_STMT (src)) == PHI_NODE\n-\t  && bb_for_stmt (SSA_NAME_DEF_STMT (src)) == e->dest)\n-\treturn;\n-\n-      record_const_or_copy (dst, src);\n-    }\n-\n-  /* Try to simplify each statement in E->dest, ultimately leading to\n-     a simplification of the COND_EXPR at the end of E->dest.\n-\n-     We might consider marking just those statements which ultimately\n-     feed the COND_EXPR.  It's not clear if the overhead of bookkeeping\n-     would be recovered by trying to simplify fewer statements.\n-\n-     If we are able to simplify a statement into the form\n-     SSA_NAME = (SSA_NAME | gimple invariant), then we can record\n-     a context sensitive equivalency which may help us simplify\n-     later statements in E->dest. \n-\n-     Failure to simplify into the form above merely means that the\n-     statement provides no equivalences to help simplify later\n-     statements.  This does not prevent threading through E->dest.  */\n-  max_stmt_count = PARAM_VALUE (PARAM_MAX_JUMP_THREAD_DUPLICATION_STMTS);\n-  for (bsi = bsi_start (e->dest); ! bsi_end_p (bsi); bsi_next (&bsi))\n-    {\n-      tree cached_lhs = NULL;\n-\n-      stmt = bsi_stmt (bsi);\n-\n-      /* Ignore empty statements and labels.  */\n-      if (IS_EMPTY_STMT (stmt) || TREE_CODE (stmt) == LABEL_EXPR)\n-\tcontinue;\n-\n-      /* If duplicating this block is going to cause too much code\n-\t expansion, then do not thread through this block.  */\n-      stmt_count++;\n-      if (stmt_count > max_stmt_count)\n-\treturn;\n-\n-      /* Safely handle threading across loop backedges.  This is\n-\t over conservative, but still allows us to capture the\n-\t majority of the cases where we can thread across a loop\n-\t backedge.  */\n-      if ((e->flags & EDGE_DFS_BACK) != 0\n-\t  && TREE_CODE (stmt) != COND_EXPR\n-\t  && TREE_CODE (stmt) != SWITCH_EXPR)\n-\treturn;\n-\n-      /* If the statement has volatile operands, then we assume we\n-\t can not thread through this block.  This is overly\n-\t conservative in some ways.  */\n-      if (TREE_CODE (stmt) == ASM_EXPR && ASM_VOLATILE_P (stmt))\n-\treturn;\n-\n-      /* If this is not a MODIFY_EXPR which sets an SSA_NAME to a new\n-\t value, then do not try to simplify this statement as it will\n-\t not simplify in any way that is helpful for jump threading.  */\n-      if (TREE_CODE (stmt) != MODIFY_EXPR\n-\t  || TREE_CODE (TREE_OPERAND (stmt, 0)) != SSA_NAME)\n-\tcontinue;\n-\n-      /* At this point we have a statement which assigns an RHS to an\n-\t SSA_VAR on the LHS.  We want to try and simplify this statement\n-\t to expose more context sensitive equivalences which in turn may\n-\t allow us to simplify the condition at the end of the loop.  */\n-      if (TREE_CODE (TREE_OPERAND (stmt, 1)) == SSA_NAME)\n-\tcached_lhs = TREE_OPERAND (stmt, 1);\n-      else\n-\t{\n-\t  /* Copy the operands.  */\n-\t  tree *copy, pre_fold_expr;\n-\t  ssa_op_iter iter;\n-\t  use_operand_p use_p;\n-\t  unsigned int num, i = 0;\n-\n-\t  num = NUM_SSA_OPERANDS (stmt, (SSA_OP_USE | SSA_OP_VUSE));\n-\t  copy = XCNEWVEC (tree, num);\n-\n-\t  /* Make a copy of the uses & vuses into USES_COPY, then cprop into\n-\t     the operands.  */\n-\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE | SSA_OP_VUSE)\n-\t    {\n-\t      tree tmp = NULL;\n-\t      tree use = USE_FROM_PTR (use_p);\n-\n-\t      copy[i++] = use;\n-\t      if (TREE_CODE (use) == SSA_NAME)\n-\t\ttmp = SSA_NAME_VALUE (use);\n-\t      if (tmp && TREE_CODE (tmp) != VALUE_HANDLE)\n-\t\tSET_USE (use_p, tmp);\n-\t    }\n-\n-\t  /* Try to fold/lookup the new expression.  Inserting the\n-\t     expression into the hash table is unlikely to help\n-\t     Sadly, we have to handle conditional assignments specially\n-\t     here, because fold expects all the operands of an expression\n-\t     to be folded before the expression itself is folded, but we\n-\t     can't just substitute the folded condition here.  */\n-\t  if (TREE_CODE (TREE_OPERAND (stmt, 1)) == COND_EXPR)\n-\t    {\n-\t      tree cond = COND_EXPR_COND (TREE_OPERAND (stmt, 1));\n-\t      cond = fold (cond);\n-\t      if (cond == boolean_true_node)\n-\t\tpre_fold_expr = COND_EXPR_THEN (TREE_OPERAND (stmt, 1));\n-\t      else if (cond == boolean_false_node)\n-\t\tpre_fold_expr = COND_EXPR_ELSE (TREE_OPERAND (stmt, 1));\n-\t      else\n-\t\tpre_fold_expr = TREE_OPERAND (stmt, 1);\n-\t    }\n-\t  else\n-\t    pre_fold_expr = TREE_OPERAND (stmt, 1);\n-\n-\t  if (pre_fold_expr)\n-\t    {\n-\t      cached_lhs = fold (pre_fold_expr);\n-\t      if (TREE_CODE (cached_lhs) != SSA_NAME\n-\t\t  && !is_gimple_min_invariant (cached_lhs))\n-\t        cached_lhs = lookup_avail_expr (stmt, false);\n-\t    }\n-\n-\t  /* Restore the statement's original uses/defs.  */\n-\t  i = 0;\n-\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE | SSA_OP_VUSE)\n-\t    SET_USE (use_p, copy[i++]);\n-\n-\t  free (copy);\n-\t}\n-\n-      /* Record the context sensitive equivalence if we were able\n-\t to simplify this statement.  */\n-      if (cached_lhs\n-\t  && (TREE_CODE (cached_lhs) == SSA_NAME\n-\t      || is_gimple_min_invariant (cached_lhs)))\n-\trecord_const_or_copy (TREE_OPERAND (stmt, 0), cached_lhs);\n-    }\n-\n-  /* If we stopped at a COND_EXPR or SWITCH_EXPR, see if we know which arm\n-     will be taken.  */\n-  if (stmt\n-      && (TREE_CODE (stmt) == COND_EXPR\n-\t  || TREE_CODE (stmt) == GOTO_EXPR\n-\t  || TREE_CODE (stmt) == SWITCH_EXPR))\n-    {\n-      tree cond, cached_lhs;\n-\n-      /* Now temporarily cprop the operands and try to find the resulting\n-\t expression in the hash tables.  */\n-      if (TREE_CODE (stmt) == COND_EXPR)\n-\t{\n-\t  canonicalize_comparison (stmt);\n-\t  cond = COND_EXPR_COND (stmt);\n-\t}\n-      else if (TREE_CODE (stmt) == GOTO_EXPR)\n-\tcond = GOTO_DESTINATION (stmt);\n-      else\n-\tcond = SWITCH_COND (stmt);\n-\n-      if (COMPARISON_CLASS_P (cond))\n-\t{\n-\t  tree dummy_cond, op0, op1;\n-\t  enum tree_code cond_code;\n-\n-\t  op0 = TREE_OPERAND (cond, 0);\n-\t  op1 = TREE_OPERAND (cond, 1);\n-\t  cond_code = TREE_CODE (cond);\n-\n-\t  /* Get the current value of both operands.  */\n-\t  if (TREE_CODE (op0) == SSA_NAME)\n-\t    {\n-\t      tree tmp = SSA_NAME_VALUE (op0);\n-\t      if (tmp && TREE_CODE (tmp) != VALUE_HANDLE)\n-\t\top0 = tmp;\n-\t    }\n-\n-\t  if (TREE_CODE (op1) == SSA_NAME)\n-\t    {\n-\t      tree tmp = SSA_NAME_VALUE (op1);\n-\t      if (tmp && TREE_CODE (tmp) != VALUE_HANDLE)\n-\t\top1 = tmp;\n-\t    }\n-\n-\t  /* Stuff the operator and operands into our dummy conditional\n-\t     expression, creating the dummy conditional if necessary.  */\n-\t  dummy_cond = (tree) walk_data->global_data;\n-\t  if (! dummy_cond)\n-\t    {\n-\t      dummy_cond = build2 (cond_code, boolean_type_node, op0, op1);\n-\t      dummy_cond = build3 (COND_EXPR, void_type_node,\n-\t\t\t\t   dummy_cond, NULL_TREE, NULL_TREE);\n-\t      walk_data->global_data = dummy_cond;\n-\t    }\n-\t  else\n-\t    {\n-\t      TREE_SET_CODE (COND_EXPR_COND (dummy_cond), cond_code);\n-\t      TREE_OPERAND (COND_EXPR_COND (dummy_cond), 0) = op0;\n-\t      TREE_OPERAND (COND_EXPR_COND (dummy_cond), 1) = op1;\n-\t    }\n-\n-\t  /* We absolutely do not care about any type conversions\n-\t     we only care about a zero/nonzero value.  */\n-\t  cached_lhs = fold (COND_EXPR_COND (dummy_cond));\n-\t  while (TREE_CODE (cached_lhs) == NOP_EXPR\n-\t\t || TREE_CODE (cached_lhs) == CONVERT_EXPR\n-\t\t || TREE_CODE (cached_lhs) == NON_LVALUE_EXPR)\n-\t    cached_lhs = TREE_OPERAND (cached_lhs, 0);\n-\t    \n-\t  if (! is_gimple_min_invariant (cached_lhs))\n-\t    {\n-\t      cached_lhs = lookup_avail_expr (dummy_cond, false);\n-\t      if (!cached_lhs || ! is_gimple_min_invariant (cached_lhs))\n-\t\tcached_lhs = simplify_cond_and_lookup_avail_expr (dummy_cond);\n-\t    }\n-\t}\n-      /* We can have conditionals which just test the state of a\n-\t variable rather than use a relational operator.  These are\n-\t simpler to handle.  */\n-      else if (TREE_CODE (cond) == SSA_NAME)\n-\t{\n-\t  cached_lhs = cond;\n-\t  cached_lhs = SSA_NAME_VALUE (cached_lhs);\n-\t  if (cached_lhs && ! is_gimple_min_invariant (cached_lhs))\n-\t    cached_lhs = NULL;\n-\t}\n-      else\n-\tcached_lhs = lookup_avail_expr (stmt, false);\n-\n-      if (cached_lhs)\n-\t{\n-\t  edge taken_edge = find_taken_edge (e->dest, cached_lhs);\n-\t  basic_block dest = (taken_edge ? taken_edge->dest : NULL);\n-\n-\t  if (dest == e->dest)\n-\t    return;\n-\n-\t  /* If we have a known destination for the conditional, then\n-\t     we can perform this optimization, which saves at least one\n-\t     conditional jump each time it applies since we get to\n-\t     bypass the conditional at our original destination.  */\n-\t  if (dest)\n-\t    {\n-\t      struct edge_info *edge_info;\n-\n-\t      if (e->aux)\n-\t\tedge_info = (struct edge_info *) e->aux;\n-\t      else\n-\t\tedge_info = allocate_edge_info (e);\n-\t      register_jump_thread (e, taken_edge);\n-\t    }\n-\t}\n-    }\n-}\n-\n \n /* Initialize local stacks for this optimizer and record equivalences\n    upon entry to BB.  Equivalences can come from the edge traversed to\n@@ -937,7 +467,6 @@ dom_opt_initialize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n   VEC_safe_push (tree, heap, avail_exprs_stack, NULL_TREE);\n   VEC_safe_push (tree, heap, const_and_copies_stack, NULL_TREE);\n   VEC_safe_push (tree, heap, nonzero_vars_stack, NULL_TREE);\n-  VEC_safe_push (tree, heap, vrp_variables_stack, NULL_TREE);\n \n   record_equivalences_from_incoming_edge (bb);\n \n@@ -1049,6 +578,35 @@ restore_vars_to_original_value (void)\n     }\n }\n \n+/* A trivial wrapper so that we can present the generic jump\n+   threading code with a simple API for simplifying statements.  */\n+static tree\n+simplify_stmt_for_jump_threading (tree stmt)\n+{\n+  return lookup_avail_expr (stmt, false);\n+}\n+\n+/* Wrapper for common code to attempt to thread an edge.  For example,\n+   it handles lazily building the dummy condition and the bookkeeping\n+   when jump threading is successful.  */\n+\n+static void\n+dom_thread_across_edge (struct dom_walk_data *walk_data, edge e)\n+{\n+  /* If we don't already have a dummy condition, build it now.  */\n+  if (! walk_data->global_data)\n+    {\n+      tree dummy_cond = build2 (NE, boolean_type_node,\n+\t\t\t        integer_zero_node, integer_zero_node);\n+      dummy_cond = build3 (COND_EXPR, void_type_node, dummy_cond, NULL, NULL);\n+      walk_data->global_data = dummy_cond;\n+    }\n+\n+  thread_across_edge (walk_data->global_data, e, false,\n+\t\t      &const_and_copies_stack,\n+\t\t      simplify_stmt_for_jump_threading);\n+}\n+\n /* We have finished processing the dominator children of BB, perform\n    any finalization actions in preparation for leaving this node in\n    the dominator tree.  */\n@@ -1058,17 +616,16 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n {\n   tree last;\n \n+\n   /* If we have an outgoing edge to a block with multiple incoming and\n      outgoing edges, then we may be able to thread the edge.  ie, we\n      may be able to statically determine which of the outgoing edges\n      will be traversed when the incoming edge from BB is traversed.  */\n   if (single_succ_p (bb)\n       && (single_succ_edge (bb)->flags & EDGE_ABNORMAL) == 0\n-      && !single_pred_p (single_succ (bb))\n-      && !single_succ_p (single_succ (bb)))\n-\t\n+      && potentially_threadable_block (single_succ (bb)))\n     {\n-      thread_across_edge (walk_data, single_succ_edge (bb));\n+      dom_thread_across_edge (walk_data, single_succ_edge (bb));\n     }\n   else if ((last = last_stmt (bb))\n \t   && TREE_CODE (last) == COND_EXPR\n@@ -1084,7 +641,7 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \n       /* Only try to thread the edge if it reaches a target block with\n \t more than one predecessor and more than one successor.  */\n-      if (!single_pred_p (true_edge->dest) && !single_succ_p (true_edge->dest))\n+      if (potentially_threadable_block (true_edge->dest))\n \t{\n \t  struct edge_info *edge_info;\n \t  unsigned int i;\n@@ -1121,21 +678,20 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t\t  }\n \t    }\n \n-\t  /* Now thread the edge.  */\n-\t  thread_across_edge (walk_data, true_edge);\n+\t  dom_thread_across_edge (walk_data, true_edge);\n \n \t  /* And restore the various tables to their state before\n \t     we threaded this edge.  */\n \t  remove_local_expressions_from_table ();\n-\t  restore_vars_to_original_value ();\n \t}\n \n       /* Similarly for the ELSE arm.  */\n-      if (!single_pred_p (false_edge->dest) && !single_succ_p (false_edge->dest))\n+      if (potentially_threadable_block (false_edge->dest))\n \t{\n \t  struct edge_info *edge_info;\n \t  unsigned int i;\n \n+\t  VEC_safe_push (tree, heap, const_and_copies_stack, NULL_TREE);\n \t  edge_info = (struct edge_info *) false_edge->aux;\n \n \t  /* If we have info associated with this edge, record it into\n@@ -1162,7 +718,8 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t\t  }\n \t    }\n \n-\t  thread_across_edge (walk_data, false_edge);\n+\t  /* Now thread the edge.  */\n+\t  dom_thread_across_edge (walk_data, false_edge);\n \n \t  /* No need to remove local expressions from our tables\n \t     or restore vars to their original value as that will\n@@ -1174,48 +731,6 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n   restore_nonzero_vars_to_original_value ();\n   restore_vars_to_original_value ();\n \n-  /* Remove VRP records associated with this basic block.  They are no\n-     longer valid.\n-\n-     To be efficient, we note which variables have had their values\n-     constrained in this block.  So walk over each variable in the\n-     VRP_VARIABLEs array.  */\n-  while (VEC_length (tree, vrp_variables_stack) > 0)\n-    {\n-      tree var = VEC_pop (tree, vrp_variables_stack);\n-      struct vrp_hash_elt vrp_hash_elt, *vrp_hash_elt_p;\n-      void **slot;\n-\n-      /* Each variable has a stack of value range records.  We want to\n-\t invalidate those associated with our basic block.  So we walk\n-\t the array backwards popping off records associated with our\n-\t block.  Once we hit a record not associated with our block\n-\t we are done.  */\n-      VEC(vrp_element_p,heap) **var_vrp_records;\n-\n-      if (var == NULL)\n-\tbreak;\n-\n-      vrp_hash_elt.var = var;\n-      vrp_hash_elt.records = NULL;\n-\n-      slot = htab_find_slot (vrp_data, &vrp_hash_elt, NO_INSERT);\n-\n-      vrp_hash_elt_p = (struct vrp_hash_elt *) *slot;\n-      var_vrp_records = &vrp_hash_elt_p->records;\n-\n-      while (VEC_length (vrp_element_p, *var_vrp_records) > 0)\n-\t{\n-\t  struct vrp_element *element\n-\t    = VEC_last (vrp_element_p, *var_vrp_records);\n-\n-\t  if (element->bb != bb)\n-\t    break;\n-  \n-\t  VEC_pop (vrp_element_p, *var_vrp_records);\n-\t}\n-    }\n-\n   /* If we queued any statements to rescan in this block, then\n      go ahead and rescan them now.  */\n   while (VEC_length (tree, stmts_to_rescan) > 0)\n@@ -1366,26 +881,12 @@ record_equivalences_from_incoming_edge (basic_block bb)\n \n \t  if (cond_equivalences)\n \t    {\n-\t      bool recorded_range = false;\n \t      for (i = 0; i < edge_info->max_cond_equivalences; i += 2)\n \t\t{\n \t\t  tree expr = cond_equivalences[i];\n \t\t  tree value = cond_equivalences[i + 1];\n \n \t\t  record_cond (expr, value);\n-\n-\t\t  /* For the first true equivalence, record range\n-\t\t     information.  We only do this for the first\n-\t\t     true equivalence as it should dominate any\n-\t\t     later true equivalences.  */\n-\t\t  if (! recorded_range \n-\t\t      && COMPARISON_CLASS_P (expr)\n-\t\t      && value == boolean_true_node\n-\t\t      && TREE_CONSTANT (TREE_OPERAND (expr, 1)))\n-\t\t    {\n-\t\t      record_range (expr, bb);\n-\t\t      recorded_range = true;\n-\t\t    }\n \t\t}\n \t    }\n \t}\n@@ -1416,9 +917,6 @@ dump_dominator_optimization_stats (FILE *file)\n   fprintf (file, \"    Copies propagated:                        %6ld\\n\",\n \t   opt_stats.num_copy_prop);\n \n-  fprintf (file, \"\\nTotal number of DOM iterations:             %6ld\\n\",\n-\t   opt_stats.num_iterations);\n-\n   fprintf (file, \"\\nHash table statistics:\\n\");\n \n   fprintf (file, \"    avail_exprs: \");\n@@ -1768,216 +1266,6 @@ simple_iv_increment_p (tree stmt)\n   return false;\n }\n \n-/* STMT is a COND_EXPR for which we could not trivially determine its\n-   result.  This routine attempts to find equivalent forms of the\n-   condition which we may be able to optimize better.  It also \n-   uses simple value range propagation to optimize conditionals.  */\n-\n-static tree\n-simplify_cond_and_lookup_avail_expr (tree stmt)\n-{\n-  tree cond = COND_EXPR_COND (stmt);\n-\n-  if (COMPARISON_CLASS_P (cond))\n-    {\n-      tree op0 = TREE_OPERAND (cond, 0);\n-      tree op1 = TREE_OPERAND (cond, 1);\n-\n-      if (TREE_CODE (op0) == SSA_NAME && is_gimple_min_invariant (op1))\n-\t{\n-\t  int limit;\n-\t  tree low, high, cond_low, cond_high;\n-\t  int lowequal, highequal, swapped, no_overlap, subset, cond_inverted;\n-\t  VEC(vrp_element_p,heap) **vrp_records;\n-\t  struct vrp_element *element;\n-\t  struct vrp_hash_elt vrp_hash_elt, *vrp_hash_elt_p;\n-\t  void **slot;\n-\n-\t  /* Consult the value range records for this variable (if they exist)\n-\t     to see if we can eliminate or simplify this conditional. \n-\n-\t     Note two tests are necessary to determine no records exist.\n-\t     First we have to see if the virtual array exists, if it \n-\t     exists, then we have to check its active size. \n-\n-\t     Also note the vast majority of conditionals are not testing\n-\t     a variable which has had its range constrained by an earlier\n-\t     conditional.  So this filter avoids a lot of unnecessary work.  */\n-\t  vrp_hash_elt.var = op0;\n-\t  vrp_hash_elt.records = NULL;\n-          slot = htab_find_slot (vrp_data, &vrp_hash_elt, NO_INSERT);\n-          if (slot == NULL)\n-\t    return NULL;\n-\n-\t  vrp_hash_elt_p = (struct vrp_hash_elt *) *slot;\n-\t  vrp_records = &vrp_hash_elt_p->records;\n-\n-\t  limit = VEC_length (vrp_element_p, *vrp_records);\n-\n-\t  /* If we have no value range records for this variable, or we are\n-\t     unable to extract a range for this condition, then there is\n-\t     nothing to do.  */\n-\t  if (limit == 0\n-\t      || ! extract_range_from_cond (cond, &cond_high,\n-\t\t\t\t\t    &cond_low, &cond_inverted))\n-\t    return NULL;\n-\n-\t  /* We really want to avoid unnecessary computations of range\n-\t     info.  So all ranges are computed lazily; this avoids a\n-\t     lot of unnecessary work.  i.e., we record the conditional,\n-\t     but do not process how it constrains the variable's \n-\t     potential values until we know that processing the condition\n-\t     could be helpful.\n-\n-\t     However, we do not want to have to walk a potentially long\n-\t     list of ranges, nor do we want to compute a variable's\n-\t     range more than once for a given path.\n-\n-\t     Luckily, each time we encounter a conditional that can not\n-\t     be otherwise optimized we will end up here and we will\n-\t     compute the necessary range information for the variable\n-\t     used in this condition.\n-\n-\t     Thus you can conclude that there will never be more than one\n-\t     conditional associated with a variable which has not been\n-\t     processed.  So we never need to merge more than one new\n-\t     conditional into the current range. \n-\n-\t     These properties also help us avoid unnecessary work.  */\n-\t   element = VEC_last (vrp_element_p, *vrp_records);\n-\n-\t  if (element->high && element->low)\n-\t    {\n-\t      /* The last element has been processed, so there is no range\n-\t\t merging to do, we can simply use the high/low values\n-\t\t recorded in the last element.  */\n-\t      low = element->low;\n-\t      high = element->high;\n-\t    }\n-\t  else\n-\t    {\n-\t      tree tmp_high, tmp_low;\n-\t      int dummy;\n-\n-\t      /* The last element has not been processed.  Process it now.\n-\t\t record_range should ensure for cond inverted is not set.\n-\t\t This call can only fail if cond is x < min or x > max,\n-\t\t which fold should have optimized into false.\n-\t\t If that doesn't happen, just pretend all values are\n-\t\t in the range.  */\n-\t      if (! extract_range_from_cond (element->cond, &tmp_high,\n-\t\t\t\t\t     &tmp_low, &dummy))\n-\t\tgcc_unreachable ();\n-\t      else\n-\t\tgcc_assert (dummy == 0);\n-\n-\t      /* If this is the only element, then no merging is necessary, \n-\t\t the high/low values from extract_range_from_cond are all\n-\t\t we need.  */\n-\t      if (limit == 1)\n-\t\t{\n-\t\t  low = tmp_low;\n-\t\t  high = tmp_high;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Get the high/low value from the previous element.  */\n-\t\t  struct vrp_element *prev\n-\t\t    = VEC_index (vrp_element_p, *vrp_records, limit - 2);\n-\t\t  low = prev->low;\n-\t\t  high = prev->high;\n-\n-\t\t  /* Merge in this element's range with the range from the\n-\t\t     previous element.\n-\n-\t\t     The low value for the merged range is the maximum of\n-\t\t     the previous low value and the low value of this record.\n-\n-\t\t     Similarly the high value for the merged range is the\n-\t\t     minimum of the previous high value and the high value of\n-\t\t     this record.  */\n-\t\t  low = (low && tree_int_cst_compare (low, tmp_low) == 1\n-\t\t\t ? low : tmp_low);\n-\t\t  high = (high && tree_int_cst_compare (high, tmp_high) == -1\n-\t\t\t  ? high : tmp_high);\n-\t\t}\n-\n-\t      /* And record the computed range.  */\n-\t      element->low = low;\n-\t      element->high = high;\n-\n-\t    }\n-\n-\t  /* After we have constrained this variable's potential values,\n-\t     we try to determine the result of the given conditional.\n-\n-\t     To simplify later tests, first determine if the current\n-\t     low value is the same low value as the conditional.\n-\t     Similarly for the current high value and the high value\n-\t     for the conditional.  */\n-\t  lowequal = tree_int_cst_equal (low, cond_low);\n-\t  highequal = tree_int_cst_equal (high, cond_high);\n-\n-\t  if (lowequal && highequal)\n-\t    return (cond_inverted ? boolean_false_node : boolean_true_node);\n-\n-\t  /* To simplify the overlap/subset tests below we may want\n-\t     to swap the two ranges so that the larger of the two\n-\t     ranges occurs \"first\".  */\n-\t  swapped = 0;\n-\t  if (tree_int_cst_compare (low, cond_low) == 1\n-\t      || (lowequal \n-\t\t  && tree_int_cst_compare (cond_high, high) == 1))\n-\t    {\n-\t      tree temp;\n-\n-\t      swapped = 1;\n-\t      temp = low;\n-\t      low = cond_low;\n-\t      cond_low = temp;\n-\t      temp = high;\n-\t      high = cond_high;\n-\t      cond_high = temp;\n-\t    }\n-\n-\t  /* Now determine if there is no overlap in the ranges\n-\t     or if the second range is a subset of the first range.  */\n-\t  no_overlap = tree_int_cst_lt (high, cond_low);\n-\t  subset = tree_int_cst_compare (cond_high, high) != 1;\n-\n-\t  /* If there was no overlap in the ranges, then this conditional\n-\t     always has a false value (unless we had to invert this\n-\t     conditional, in which case it always has a true value).  */\n-\t  if (no_overlap)\n-\t    return (cond_inverted ? boolean_true_node : boolean_false_node);\n-\n-\t  /* If the current range is a subset of the condition's range,\n-\t     then this conditional always has a true value (unless we\n-\t     had to invert this conditional, in which case it always\n-\t     has a true value).  */\n-\t  if (subset && swapped)\n-\t    return (cond_inverted ? boolean_false_node : boolean_true_node);\n-\n-\t  /* We were unable to determine the result of the conditional.\n-\t     However, we may be able to simplify the conditional.  First\n-\t     merge the ranges in the same manner as range merging above.  */\n-\t  low = tree_int_cst_compare (low, cond_low) == 1 ? low : cond_low;\n-\t  high = tree_int_cst_compare (high, cond_high) == -1 ? high : cond_high;\n-\t  \n-\t  /* If the range has converged to a single point, then turn this\n-\t     into an equality comparison.  */\n-\t  if (TREE_CODE (cond) != EQ_EXPR\n-\t      && TREE_CODE (cond) != NE_EXPR\n-\t      && tree_int_cst_equal (low, high))\n-\t    {\n-\t      TREE_SET_CODE (cond, EQ_EXPR);\n-\t      TREE_OPERAND (cond, 1) = high;\n-\t    }\n-\t}\n-    }\n-  return 0;\n-}\n-\n /* CONST_AND_COPIES is a table which maps an SSA_NAME to the current\n    known value for that SSA_NAME (or NULL if no value is known).  \n \n@@ -2265,11 +1553,6 @@ eliminate_redundant_computations (tree stmt)\n   /* Check if the expression has been computed before.  */\n   cached_lhs = lookup_avail_expr (stmt, insert);\n \n-  /* If this is a COND_EXPR and we did not find its expression in\n-     the hash table, simplify the condition and try again.  */\n-  if (! cached_lhs && TREE_CODE (stmt) == COND_EXPR)\n-    cached_lhs = simplify_cond_and_lookup_avail_expr (stmt);\n-\n   opt_stats.num_exprs_considered++;\n \n   /* Get a pointer to the expression we are trying to optimize.  */\n@@ -2816,156 +2099,6 @@ lookup_avail_expr (tree stmt, bool insert)\n   return lhs;\n }\n \n-/* Given a condition COND, record into HI_P, LO_P and INVERTED_P the\n-   range of values that result in the conditional having a true value.\n-\n-   Return true if we are successful in extracting a range from COND and\n-   false if we are unsuccessful.  */\n-\n-static bool\n-extract_range_from_cond (tree cond, tree *hi_p, tree *lo_p, int *inverted_p)\n-{\n-  tree op1 = TREE_OPERAND (cond, 1);\n-  tree high, low, type;\n-  int inverted;\n-\n-  type = TREE_TYPE (op1);\n-\n-  /* Experiments have shown that it's rarely, if ever useful to\n-     record ranges for enumerations.  Presumably this is due to\n-     the fact that they're rarely used directly.  They are typically\n-     cast into an integer type and used that way.  */\n-  if (TREE_CODE (type) != INTEGER_TYPE)\n-    return 0;\n-\n-  switch (TREE_CODE (cond))\n-    {\n-    case EQ_EXPR:\n-      high = low = op1;\n-      inverted = 0;\n-      break;\n-\n-    case NE_EXPR:\n-      high = low = op1;\n-      inverted = 1;\n-      break;\n-\n-    case GE_EXPR:\n-      low = op1;\n-\n-      /* Get the highest value of the type.  If not a constant, use that\n-\t of its base type, if it has one.  */\n-      high = TYPE_MAX_VALUE (type);\n-      if (TREE_CODE (high) != INTEGER_CST && TREE_TYPE (type))\n-\thigh = TYPE_MAX_VALUE (TREE_TYPE (type));\n-      inverted = 0;\n-      break;\n-\n-    case GT_EXPR:\n-      high = TYPE_MAX_VALUE (type);\n-      if (TREE_CODE (high) != INTEGER_CST && TREE_TYPE (type))\n-\thigh = TYPE_MAX_VALUE (TREE_TYPE (type));\n-      if (!tree_int_cst_lt (op1, high))\n-\treturn 0;\n-      low = int_const_binop (PLUS_EXPR, op1, integer_one_node, 1);\n-      inverted = 0;\n-      break;\n-\n-    case LE_EXPR:\n-      high = op1;\n-      low = TYPE_MIN_VALUE (type);\n-      if (TREE_CODE (low) != INTEGER_CST && TREE_TYPE (type))\n-\tlow = TYPE_MIN_VALUE (TREE_TYPE (type));\n-      inverted = 0;\n-      break;\n-\n-    case LT_EXPR:\n-      low = TYPE_MIN_VALUE (type);\n-      if (TREE_CODE (low) != INTEGER_CST && TREE_TYPE (type))\n-\tlow = TYPE_MIN_VALUE (TREE_TYPE (type));\n-      if (!tree_int_cst_lt (low, op1))\n-\treturn 0;\n-      high = int_const_binop (MINUS_EXPR, op1, integer_one_node, 1);\n-      inverted = 0;\n-      break;\n-\n-    default:\n-      return 0;\n-    }\n-\n-  *hi_p = high;\n-  *lo_p = low;\n-  *inverted_p = inverted;\n-  return 1;\n-}\n-\n-/* Record a range created by COND for basic block BB.  */\n-\n-static void\n-record_range (tree cond, basic_block bb)\n-{\n-  enum tree_code code = TREE_CODE (cond);\n-\n-  /* We explicitly ignore NE_EXPRs and all the unordered comparisons.\n-     They rarely allow for meaningful range optimizations and significantly\n-     complicate the implementation.  */\n-  if ((code == LT_EXPR || code == LE_EXPR || code == GT_EXPR\n-       || code == GE_EXPR || code == EQ_EXPR)\n-      && TREE_CODE (TREE_TYPE (TREE_OPERAND (cond, 1))) == INTEGER_TYPE)\n-    {\n-      struct vrp_hash_elt *vrp_hash_elt;\n-      struct vrp_element *element;\n-      VEC(vrp_element_p,heap) **vrp_records_p;\n-      void **slot;\n-\n-\n-      vrp_hash_elt = XNEW (struct vrp_hash_elt);\n-      vrp_hash_elt->var = TREE_OPERAND (cond, 0);\n-      vrp_hash_elt->records = NULL;\n-      slot = htab_find_slot (vrp_data, vrp_hash_elt, INSERT);\n-\n-      if (*slot == NULL)\n-\t*slot = (void *) vrp_hash_elt;\n-      else\n-\tvrp_free (vrp_hash_elt);\n-\n-      vrp_hash_elt = (struct vrp_hash_elt *) *slot;\n-      vrp_records_p = &vrp_hash_elt->records;\n-\n-      element = GGC_NEW (struct vrp_element);\n-      element->low = NULL;\n-      element->high = NULL;\n-      element->cond = cond;\n-      element->bb = bb;\n-\n-      VEC_safe_push (vrp_element_p, heap, *vrp_records_p, element);\n-      VEC_safe_push (tree, heap, vrp_variables_stack, TREE_OPERAND (cond, 0));\n-    }\n-}\n-\n-/* Hashing and equality functions for VRP_DATA.\n-\n-   Since this hash table is addressed by SSA_NAMEs, we can hash on\n-   their version number and equality can be determined with a \n-   pointer comparison.  */\n-\n-static hashval_t\n-vrp_hash (const void *p)\n-{\n-  tree var = ((struct vrp_hash_elt *)p)->var;\n-\n-  return SSA_NAME_VERSION (var);\n-}\n-\n-static int\n-vrp_eq (const void *p1, const void *p2)\n-{\n-  tree var1 = ((struct vrp_hash_elt *)p1)->var;\n-  tree var2 = ((struct vrp_hash_elt *)p2)->var;\n-\n-  return var1 == var2;\n-}\n-\n /* Hashing and equality functions for AVAIL_EXPRS.  The table stores\n    MODIFY_EXPR statements.  We compute a value number for expressions using\n    the code of the expression and the SSA numbers of its operands.  */"}, {"sha": "bd78c6b68642e2dc149e48fdf645e61918f94f2a", "filename": "gcc/tree-ssa-threadedge.c", "status": "added", "additions": 537, "deletions": 0, "changes": 537, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -0,0 +1,537 @@\n+/* SSA Jump Threading\n+   Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+   Contributed by Jeff Law  <law@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"ggc.h\"\n+#include \"basic-block.h\"\n+#include \"cfgloop.h\"\n+#include \"output.h\"\n+#include \"expr.h\"\n+#include \"function.h\"\n+#include \"diagnostic.h\"\n+#include \"timevar.h\"\n+#include \"tree-dump.h\"\n+#include \"tree-flow.h\"\n+#include \"domwalk.h\"\n+#include \"real.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-ssa-propagate.h\"\n+#include \"langhooks.h\"\n+#include \"params.h\"\n+\n+/* To avoid code explosion due to jump threading, we limit the\n+   number of statements we are going to copy.  This variable\n+   holds the number of statements currently seen that we'll have\n+   to copy as part of the jump threading process.  */\n+static int stmt_count;\n+\n+/* Return TRUE if we may be able to thread an incoming edge into\n+   BB to an outgoing edge from BB.  Return FALSE otherwise.  */\n+\n+bool\n+potentially_threadable_block (basic_block bb)\n+{\n+  block_stmt_iterator bsi;\n+\n+  /* If BB has a single successor or a single predecessor, then\n+     there is no threading opportunity.  */\n+  if (single_succ_p (bb) || single_pred_p (bb))\n+    return false;\n+\n+  /* If BB does not end with a conditional, switch or computed goto,\n+     then there is no threading opportunity.  */\n+  bsi = bsi_last (bb);\n+  if (bsi_end_p (bsi)\n+      || ! bsi_stmt (bsi)\n+      || (TREE_CODE (bsi_stmt (bsi)) != COND_EXPR\n+\t  && TREE_CODE (bsi_stmt (bsi)) != GOTO_EXPR\n+\t  && TREE_CODE (bsi_stmt (bsi)) != SWITCH_EXPR))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Return the LHS of any ASSERT_EXPR where OP appears as the first\n+   argument to the ASSERT_EXPR and in which the ASSERT_EXPR dominates\n+   BB.  If no such ASSERT_EXPR is found, return OP.  */\n+\n+static tree\n+lhs_of_dominating_assert (tree op, basic_block bb, tree stmt)\n+{\n+  imm_use_iterator imm_iter;\n+  use_operand_p imm_use;\n+\n+  FOR_EACH_IMM_USE_SAFE (imm_use, imm_iter, op)\n+    {\n+      tree use_stmt = USE_STMT (imm_use);\n+\n+      if (use_stmt != stmt\n+          && TREE_CODE (use_stmt) == MODIFY_EXPR\n+          && TREE_CODE (TREE_OPERAND (use_stmt, 1)) == ASSERT_EXPR\n+          && TREE_OPERAND (TREE_OPERAND (use_stmt, 1), 0) == op\n+\t  && dominated_by_p (CDI_DOMINATORS, bb, bb_for_stmt (use_stmt)))\n+\top = TREE_OPERAND (use_stmt, 0);\n+    }\n+  return op;\n+}\n+\n+\n+/* We record temporary equivalences created by PHI nodes or\n+   statements within the target block.  Doing so allows us to\n+   identify more jump threading opportunities, even in blocks\n+   with side effects.\n+\n+   We keep track of those temporary equivalences in a stack\n+   structure so that we can unwind them when we're done processing\n+   a particular edge.  This routine handles unwinding the data\n+   structures.  */\n+\n+static void\n+remove_temporary_equivalences (VEC(tree, heap) **stack)\n+{\n+  while (VEC_length (tree, *stack) > 0)\n+    {\n+      tree prev_value, dest;\n+\n+      dest = VEC_pop (tree, *stack);\n+\n+      /* A NULL value indicates we should stop unwinding, oherwise\n+\t pop off the next entry as they're recorded in pairs.  */\n+      if (dest == NULL)\n+\tbreak;\n+\n+      prev_value = VEC_pop (tree, *stack);\n+      SSA_NAME_VALUE (dest) = prev_value;\n+    }\n+}\n+\n+/* Record a temporary equivalence, saving enough information so that\n+   we can restore the state of recorded equivalences when we're\n+   done processing the current edge.  */\n+\n+static void\n+record_temporary_equivalence (tree x, tree y, VEC(tree, heap) **stack)\n+{\n+  tree prev_x = SSA_NAME_VALUE (x);\n+\n+  if (TREE_CODE (y) == SSA_NAME)\n+    {\n+      tree tmp = SSA_NAME_VALUE (y);\n+      y = tmp ? tmp : y;\n+    }\n+\n+  SSA_NAME_VALUE (x) = y;\n+  VEC_reserve (tree, heap, *stack, 2);\n+  VEC_quick_push (tree, *stack, prev_x);\n+  VEC_quick_push (tree, *stack, x);\n+}\n+\n+/* Record temporary equivalences created by PHIs at the target of the\n+   edge E.  Record unwind information for the equivalences onto STACK. \n+\n+   If a PHI which prevents threading is encountered, then return FALSE\n+   indicating we should not thread this edge, else return TRUE.  */\n+\n+static bool\n+record_temporary_equivalences_from_phis (edge e, VEC(tree, heap) **stack)\n+{\n+  tree phi;\n+\n+  /* Each PHI creates a temporary equivalence, record them.\n+     These are context sensitive equivalences and will be removed\n+     later.  */\n+  for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n+    {\n+      tree src = PHI_ARG_DEF_FROM_EDGE (phi, e);\n+      tree dst = PHI_RESULT (phi);\n+\n+      /* If the desired argument is not the same as this PHI's result \n+\t and it is set by a PHI in E->dest, then we can not thread\n+\t through E->dest.  */\n+      if (src != dst\n+\t  && TREE_CODE (src) == SSA_NAME\n+\t  && TREE_CODE (SSA_NAME_DEF_STMT (src)) == PHI_NODE\n+\t  && bb_for_stmt (SSA_NAME_DEF_STMT (src)) == e->dest)\n+\treturn false;\n+\n+      /* We consider any non-virtual PHI as a statement since it\n+\t count result in a constant assignment or copy operation.  */\n+      if (is_gimple_reg (dst))\n+\tstmt_count++;\n+\n+      record_temporary_equivalence (dst, src, stack);\n+    }\n+  return true;\n+}\n+\n+/* Try to simplify each statement in E->dest, ultimately leading to\n+   a simplification of the COND_EXPR at the end of E->dest.\n+\n+   Record unwind information for temporary equivalences onto STACK.\n+\n+   Use SIMPLIFY (a pointer to a callback function) to further simplify\n+   statements using pass specific information. \n+\n+   We might consider marking just those statements which ultimately\n+   feed the COND_EXPR.  It's not clear if the overhead of bookkeeping\n+   would be recovered by trying to simplify fewer statements.\n+\n+   If we are able to simplify a statement into the form\n+   SSA_NAME = (SSA_NAME | gimple invariant), then we can record\n+   a context sensitive equivalency which may help us simplify\n+   later statements in E->dest.  */\n+\n+static tree\n+record_temporary_equivalences_from_stmts_at_dest (edge e,\n+\t\t\t\t\t\t  VEC(tree, heap) **stack,\n+\t\t\t\t\t\t  tree (*simplify) (tree))\n+{\n+  block_stmt_iterator bsi;\n+  tree stmt = NULL;\n+  int max_stmt_count;\n+\n+  max_stmt_count = PARAM_VALUE (PARAM_MAX_JUMP_THREAD_DUPLICATION_STMTS);\n+\n+  /* Walk through each statement in the block recording equivalences\n+     we discover.  Note any equivalences we discover are context\n+     sensitive (ie, are dependent on traversing E) and must be unwound\n+     when we're finished processing E.  */\n+  for (bsi = bsi_start (e->dest); ! bsi_end_p (bsi); bsi_next (&bsi))\n+    {\n+      tree cached_lhs = NULL;\n+\n+      stmt = bsi_stmt (bsi);\n+\n+      /* Ignore empty statements and labels.  */\n+      if (IS_EMPTY_STMT (stmt) || TREE_CODE (stmt) == LABEL_EXPR)\n+\tcontinue;\n+\n+      /* Safely handle threading across loop backedges.  Only allowing\n+\t a conditional at the target of the backedge is over conservative,\n+\t but still allows us to capture the majority of the cases where\n+\t we can thread across a loop backedge.  */\n+      if ((e->flags & EDGE_DFS_BACK) != 0\n+\t  && TREE_CODE (stmt) != COND_EXPR\n+\t  && TREE_CODE (stmt) != SWITCH_EXPR)\n+\treturn NULL;\n+\n+      /* If the statement has volatile operands, then we assume we\n+\t can not thread through this block.  This is overly\n+\t conservative in some ways.  */\n+      if (TREE_CODE (stmt) == ASM_EXPR && ASM_VOLATILE_P (stmt))\n+\treturn NULL;\n+\n+      /* If duplicating this block is going to cause too much code\n+\t expansion, then do not thread through this block.  */\n+      stmt_count++;\n+      if (stmt_count > max_stmt_count)\n+\treturn NULL;\n+\n+      /* If this is not a MODIFY_EXPR which sets an SSA_NAME to a new\n+\t value, then do not try to simplify this statement as it will\n+\t not simplify in any way that is helpful for jump threading.  */\n+      if (TREE_CODE (stmt) != MODIFY_EXPR\n+\t  || TREE_CODE (TREE_OPERAND (stmt, 0)) != SSA_NAME)\n+\tcontinue;\n+\n+      /* At this point we have a statement which assigns an RHS to an\n+\t SSA_VAR on the LHS.  We want to try and simplify this statement\n+\t to expose more context sensitive equivalences which in turn may\n+\t allow us to simplify the condition at the end of the loop. \n+\n+\t Handle simple copy operations as well as implied copies from\n+\t ASSERT_EXPRs.  */\n+      if (TREE_CODE (TREE_OPERAND (stmt, 1)) == SSA_NAME)\n+\tcached_lhs = TREE_OPERAND (stmt, 1);\n+      else if (TREE_CODE (TREE_OPERAND (stmt, 1)) == ASSERT_EXPR)\n+\tcached_lhs = TREE_OPERAND (TREE_OPERAND (stmt, 1), 0);\n+      else\n+\t{\n+\t  /* A statement that is not a trivial copy or ASSERT_EXPR.\n+\t     We're going to temporarily copy propagate the operands\n+\t     and see if that allows us to simplify this statement.  */\n+\t  tree *copy, pre_fold_expr;\n+\t  ssa_op_iter iter;\n+\t  use_operand_p use_p;\n+\t  unsigned int num, i = 0;\n+\n+\t  num = NUM_SSA_OPERANDS (stmt, (SSA_OP_USE | SSA_OP_VUSE));\n+\t  copy = XCNEWVEC (tree, num);\n+\n+\t  /* Make a copy of the uses & vuses into USES_COPY, then cprop into\n+\t     the operands.  */\n+\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE | SSA_OP_VUSE)\n+\t    {\n+\t      tree tmp = NULL;\n+\t      tree use = USE_FROM_PTR (use_p);\n+\n+\t      copy[i++] = use;\n+\t      if (TREE_CODE (use) == SSA_NAME)\n+\t\ttmp = SSA_NAME_VALUE (use);\n+\t      if (tmp && TREE_CODE (tmp) != VALUE_HANDLE)\n+\t\tSET_USE (use_p, tmp);\n+\t    }\n+\n+\t  /* Try to fold/lookup the new expression.  Inserting the\n+\t     expression into the hash table is unlikely to help\n+\t     Sadly, we have to handle conditional assignments specially\n+\t     here, because fold expects all the operands of an expression\n+\t     to be folded before the expression itself is folded, but we\n+\t     can't just substitute the folded condition here.  */\n+\t  if (TREE_CODE (TREE_OPERAND (stmt, 1)) == COND_EXPR)\n+\t    {\n+\t      tree cond = COND_EXPR_COND (TREE_OPERAND (stmt, 1));\n+\t      cond = fold (cond);\n+\t      if (cond == boolean_true_node)\n+\t\tpre_fold_expr = COND_EXPR_THEN (TREE_OPERAND (stmt, 1));\n+\t      else if (cond == boolean_false_node)\n+\t\tpre_fold_expr = COND_EXPR_ELSE (TREE_OPERAND (stmt, 1));\n+\t      else\n+\t\tpre_fold_expr = TREE_OPERAND (stmt, 1);\n+\t    }\n+\t  else\n+\t    pre_fold_expr = TREE_OPERAND (stmt, 1);\n+\n+\t  if (pre_fold_expr)\n+\t    {\n+\t      cached_lhs = fold (pre_fold_expr);\n+\t      if (TREE_CODE (cached_lhs) != SSA_NAME\n+\t\t  && !is_gimple_min_invariant (cached_lhs))\n+\t        cached_lhs = (*simplify) (stmt);\n+\t    }\n+\n+\t  /* Restore the statement's original uses/defs.  */\n+\t  i = 0;\n+\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE | SSA_OP_VUSE)\n+\t    SET_USE (use_p, copy[i++]);\n+\n+\t  free (copy);\n+\t}\n+\n+      /* Record the context sensitive equivalence if we were able\n+\t to simplify this statement.  */\n+      if (cached_lhs\n+\t  && (TREE_CODE (cached_lhs) == SSA_NAME\n+\t      || is_gimple_min_invariant (cached_lhs)))\n+\trecord_temporary_equivalence (TREE_OPERAND (stmt, 0),\n+\t\t\t\t      cached_lhs,\n+\t\t\t\t      stack);\n+    }\n+  return stmt;\n+}\n+\n+/* Simplify the control statement at the end of the block E->dest.\n+\n+   To avoid allocating memory unnecessarily, a scratch COND_EXPR\n+   is available to use/clobber in DUMMY_COND.\n+\n+   Use SIMPLIFY (a pointer to a callback function) to further simplify\n+   a condition using pass specific information.\n+\n+   Return the simplified condition or NULL if simplification could\n+   not be performed.  */\n+\n+static tree\n+simplify_control_stmt_condition (edge e,\n+\t\t\t\t tree stmt,\n+\t\t\t\t tree dummy_cond,\n+\t\t\t\t tree (*simplify) (tree),\n+\t\t\t\t bool handle_dominating_asserts)\n+{\n+  tree cond, cached_lhs;\n+\n+  if (TREE_CODE (stmt) == COND_EXPR)\n+    cond = COND_EXPR_COND (stmt);\n+  else if (TREE_CODE (stmt) == GOTO_EXPR)\n+    cond = GOTO_DESTINATION (stmt);\n+  else\n+    cond = SWITCH_COND (stmt);\n+\n+  /* For comparisons, we have to update both operands, then try\n+     to simplify the comparison.  */\n+  if (COMPARISON_CLASS_P (cond))\n+    {\n+      tree op0, op1;\n+      enum tree_code cond_code;\n+\n+      op0 = TREE_OPERAND (cond, 0);\n+      op1 = TREE_OPERAND (cond, 1);\n+      cond_code = TREE_CODE (cond);\n+\n+      /* Get the current value of both operands.  */\n+      if (TREE_CODE (op0) == SSA_NAME)\n+\t{\n+          tree tmp = SSA_NAME_VALUE (op0);\n+\t  if (tmp && TREE_CODE (tmp) != VALUE_HANDLE)\n+\t    op0 = tmp;\n+\t}\n+\n+      if (TREE_CODE (op1) == SSA_NAME)\n+\t{\n+\t  tree tmp = SSA_NAME_VALUE (op1);\n+\t  if (tmp && TREE_CODE (tmp) != VALUE_HANDLE)\n+\t    op1 = tmp;\n+\t}\n+\n+      if (handle_dominating_asserts)\n+\t{\n+\t  /* Now see if the operand was consumed by an ASSERT_EXPR\n+\t     which dominates E->src.  If so, we want to replace the\n+\t     operand with the LHS of the ASSERT_EXPR.  */\n+\t  if (TREE_CODE (op0) == SSA_NAME)\n+\t    op0 = lhs_of_dominating_assert (op0, e->src, stmt);\n+\n+\t  if (TREE_CODE (op1) == SSA_NAME)\n+\t    op1 = lhs_of_dominating_assert (op1, e->src, stmt);\n+\t}\n+\n+      /* We may need to canonicalize the comparison.  For\n+\t example, op0 might be a constant while op1 is an\n+\t SSA_NAME.  Failure to canonicalize will cause us to\n+\t miss threading opportunities.  */\n+      if (cond_code != SSA_NAME\n+\t  && tree_swap_operands_p (op0, op1, false))\n+\t{\n+\t  tree tmp;\n+\t  cond_code = swap_tree_comparison (TREE_CODE (cond));\n+\t  tmp = op0;\n+\t  op0 = op1;\n+\t  op1 = tmp;\n+\t}\n+\n+      /* Stuff the operator and operands into our dummy conditional\n+\t expression.  */\n+      TREE_SET_CODE (COND_EXPR_COND (dummy_cond), cond_code);\n+      TREE_OPERAND (COND_EXPR_COND (dummy_cond), 0) = op0;\n+      TREE_OPERAND (COND_EXPR_COND (dummy_cond), 1) = op1;\n+\n+      /* We absolutely do not care about any type conversions\n+         we only care about a zero/nonzero value.  */\n+      cached_lhs = fold (COND_EXPR_COND (dummy_cond));\n+      while (TREE_CODE (cached_lhs) == NOP_EXPR\n+\t     || TREE_CODE (cached_lhs) == CONVERT_EXPR\n+\t     || TREE_CODE (cached_lhs) == NON_LVALUE_EXPR)\n+\tcached_lhs = TREE_OPERAND (cached_lhs, 0);\n+\t    \n+      /* If we have not simplified the condition down to an invariant,\n+\t then use the pass specific callback to simplify the condition.  */\n+      if (! is_gimple_min_invariant (cached_lhs))\n+\tcached_lhs = (*simplify) (dummy_cond);\n+    }\n+\n+  /* We can have conditionals which just test the state of a variable\n+     rather than use a relational operator.  These are simpler to handle.  */\n+  else if (TREE_CODE (cond) == SSA_NAME)\n+    {\n+      cached_lhs = cond;\n+\n+      /* Get the variable's current value from the equivalency chains.  */\n+      while (cached_lhs\n+\t     && TREE_CODE (cached_lhs) == SSA_NAME\n+\t     && SSA_NAME_VALUE (cached_lhs))\n+\tcached_lhs = SSA_NAME_VALUE (cached_lhs);\n+\n+      /* If we're dominated by a suitable ASSERT_EXPR, then\n+\t update CACHED_LHS appropriately.  */\n+      if (handle_dominating_asserts && TREE_CODE (cached_lhs) == SSA_NAME)\n+\tcached_lhs = lhs_of_dominating_assert (cached_lhs, e->src, stmt);\n+\n+      /* If we haven't simplified to an invariant yet, then use the\n+\t pass specific callback to try and simplify it further.  */\n+      if (cached_lhs && ! is_gimple_min_invariant (cached_lhs))\n+        cached_lhs = (*simplify) (stmt);\n+    }\n+  else\n+    cached_lhs = NULL;\n+\n+  return cached_lhs;\n+}\n+\n+/* We are exiting E->src, see if E->dest ends with a conditional\n+   jump which has a known value when reached via E. \n+\n+   Special care is necessary if E is a back edge in the CFG as we\n+   may have already recorded equivalences for E->dest into our\n+   various tables, including the result of the conditional at\n+   the end of E->dest.  Threading opportunities are severely\n+   limited in that case to avoid short-circuiting the loop\n+   incorrectly.\n+\n+   Note it is quite common for the first block inside a loop to\n+   end with a conditional which is either always true or always\n+   false when reached via the loop backedge.  Thus we do not want\n+   to blindly disable threading across a loop backedge.  */\n+\n+void\n+thread_across_edge (tree dummy_cond,\n+\t\t    edge e,\n+\t\t    bool handle_dominating_asserts,\n+\t\t    VEC(tree, heap) **stack,\n+\t\t    tree (*simplify) (tree))\n+{\n+  tree stmt;\n+\n+  stmt_count = 0;\n+\n+  /* PHIs create temporary equivalences.  */\n+  if (!record_temporary_equivalences_from_phis (e, stack))\n+    goto fail;\n+\n+  /* Now walk each statement recording any context sensitive\n+     temporary equivalences we can detect.  */\n+  stmt = record_temporary_equivalences_from_stmts_at_dest (e, stack, simplify);\n+  if (!stmt)\n+    goto fail;\n+\n+  /* If we stopped at a COND_EXPR or SWITCH_EXPR, see if we know which arm\n+     will be taken.  */\n+  if (TREE_CODE (stmt) == COND_EXPR\n+      || TREE_CODE (stmt) == GOTO_EXPR\n+      || TREE_CODE (stmt) == SWITCH_EXPR)\n+    {\n+      tree cond;\n+\n+      /* Extract and simplify the condition.  */\n+      cond = simplify_control_stmt_condition (e, stmt, dummy_cond, simplify, handle_dominating_asserts);\n+\n+      if (cond && is_gimple_min_invariant (cond))\n+\t{\n+\t  edge taken_edge = find_taken_edge (e->dest, cond);\n+\t  basic_block dest = (taken_edge ? taken_edge->dest : NULL);\n+\n+\t  if (dest == e->dest)\n+\t    goto fail;\n+\n+\t  remove_temporary_equivalences (stack);\n+\t  register_jump_thread (e, taken_edge);\n+\t}\n+    }\n+\n+ fail:\n+  remove_temporary_equivalences (stack);\n+}"}, {"sha": "9fa311b3c5e6bed1f91d1ba6066ec895d3390521", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 178, "deletions": 1, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2090d6a0a845c58a3c5ed6c4260db5c178ec5511/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=2090d6a0a845c58a3c5ed6c4260db5c178ec5511", "patch": "@@ -2755,7 +2755,24 @@ find_conditional_asserts (basic_block bb)\n       /* Remove the COND_EXPR operands from the FOUND_IN_SUBGRAPH bitmap.\n \t Otherwise, when we finish traversing each of the sub-graphs, we\n \t won't know whether the variables were found in the sub-graphs or\n-\t if they had been found in a block upstream from BB.  */\n+\t if they had been found in a block upstream from BB. \n+\n+\t This is actually a bad idea is some cases, particularly jump\n+\t threading.  Consider a CFG like the following:\n+\n+                    0\n+                   /|\n+                  1 |\n+                   \\|\n+                    2\n+                   / \\\n+                  3   4\n+\n+\t Assume that one or more operands in the conditional at the\n+\t end of block 0 are used in a conditional in block 2, but not\n+\t anywhere in block 1.  In this case we will not insert any\n+\t assert statements in block 1, which may cause us to miss\n+\t opportunities to optimize, particularly for jump threading.  */\n       FOR_EACH_SSA_TREE_OPERAND (op, last, iter, SSA_OP_USE)\n \tRESET_BIT (found_in_subgraph, SSA_NAME_VERSION (op));\n \n@@ -4202,6 +4219,157 @@ simplify_stmt_using_ranges (tree stmt)\n     }\n }\n \n+/* Stack of dest,src equivalency pairs that need to be restored after\n+   each attempt to thread a block's incoming edge to an outgoing edge. \n+\n+   A NULL entry is used to mark the end of pairs which need to be\n+   restored.  */\n+static VEC(tree,heap) *stack;\n+\n+/* A trivial wrapper so that we can present the generic jump\n+   threading code with a simple API for simplifying statements.  */\n+static tree\n+simplify_stmt_for_jump_threading (tree stmt)\n+{\n+  /* We only use VRP information to simplify conditionals.  This is\n+     overly conservative, but it's unclear if doing more would be\n+     worth the compile time cost.  */\n+  if (TREE_CODE (stmt) != COND_EXPR)\n+    return NULL;\n+\n+  return vrp_evaluate_conditional (COND_EXPR_COND (stmt), true);\n+}\n+\n+/* Blocks which have more than one predecessor and more than\n+   one successor present jump threading opportunities.  ie,\n+   when the block is reached from a specific predecessor, we\n+   may be able to determine which of the outgoing edges will\n+   be traversed.  When this optimization applies, we are able\n+   to avoid conditionals at runtime and we may expose secondary\n+   optimization opportunities.\n+\n+   This routine is effectively a driver for the generic jump\n+   threading code.  It basically just presents the generic code\n+   with edges that may be suitable for jump threading.\n+\n+   Unlike DOM, we do not iterate VRP if jump threading was successful.\n+   While iterating may expose new opportunities for VRP, it is expected\n+   those opportunities would be very limited and the compile time cost\n+   to expose those opportunities would be significant. \n+\n+   As jump threading opportunities are discovered, they are registered\n+   for later realization.  */\n+\n+static void\n+identify_jump_threads (void)\n+{\n+  basic_block bb;\n+  tree dummy;\n+\n+  /* Ugh.  When substituting values earlier in this pass we can\n+     wipe the dominance information.  So rebuild the dominator\n+     information as we need it within the jump threading code.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  /* We do not allow VRP information to be used for jump threading\n+     across a back edge in the CFG.  Otherwise it becomes too\n+     difficult to avoid eliminating loop exit tests.  Of course\n+     EDGE_DFS_BACK is not accurate at this time so we have to\n+     recompute it.  */\n+  mark_dfs_back_edges ();\n+\n+  /* Allocate our unwinder stack to unwind any temporary equivalences\n+     that might be recorded.  */\n+  stack = VEC_alloc (tree, heap, 20);\n+\n+  /* To avoid lots of silly node creation, we create a single\n+     conditional and just modify it in-place when attempting to\n+     thread jumps.  */\n+  dummy = build2 (EQ_EXPR, boolean_type_node, NULL, NULL);\n+  dummy = build3 (COND_EXPR, void_type_node, dummy, NULL, NULL);\n+\n+  /* Walk through all the blocks finding those which present a\n+     potential jump threading opportunity.  We could set this up\n+     as a dominator walker and record data during the walk, but\n+     I doubt it's worth the effort for the classes of jump\n+     threading opportunities we are trying to identify at this\n+     point in compilation.  */\n+  FOR_EACH_BB (bb)\n+    {\n+      tree last, cond;\n+\n+      /* If the generic jump threading code does not find this block\n+\t interesting, then there is nothing to do.  */\n+      if (! potentially_threadable_block (bb))\n+\tcontinue;\n+\n+      /* We only care about blocks ending in a COND_EXPR.  While there\n+\t may be some value in handling SWITCH_EXPR here, I doubt it's\n+\t terribly important.  */\n+      last = bsi_stmt (bsi_last (bb));\n+      if (TREE_CODE (last) != COND_EXPR)\n+\tcontinue;\n+\n+      /* We're basically looking for any kind of conditional with\n+\t integral type arguments.  */\n+      cond = COND_EXPR_COND (last);\n+      if ((TREE_CODE (cond) == SSA_NAME\n+\t   && INTEGRAL_TYPE_P (TREE_TYPE (cond)))\n+\t  || (COMPARISON_CLASS_P (cond)\n+\t      && TREE_CODE (TREE_OPERAND (cond, 0)) == SSA_NAME\n+\t      && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (cond, 0)))\n+\t      && (TREE_CODE (TREE_OPERAND (cond, 1)) == SSA_NAME\n+\t\t  || is_gimple_min_invariant (TREE_OPERAND (cond, 1)))\n+\t      && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (cond, 1)))))\n+\t{\n+\t  edge_iterator ei;\n+\t  edge e;\n+\n+\t  /* We've got a block with multiple predecessors and multiple\n+\t     successors which also ends in a suitable conditional.  For\n+\t     each predecessor, see if we can thread it to a specific\n+\t     successor.  */\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    {\n+\t      /* Do not thread across back edges or abnormal edges\n+\t\t in the CFG.  */\n+\t      if (e->flags & (EDGE_DFS_BACK | EDGE_COMPLEX))\n+\t\tcontinue;\n+\n+\t      thread_across_edge (dummy, e, true,\n+\t\t\t\t  &stack,\n+\t\t\t\t  simplify_stmt_for_jump_threading);\n+\t    }\n+\t}\n+    }\n+\n+  /* We do not actually update the CFG or SSA graphs at this point as\n+     ASSERT_EXPRs are still in the IL and cfg cleanup code does not yet\n+     handle ASSERT_EXPRs gracefully.  */\n+}\n+\n+/* We identified all the jump threading opportunities earlier, but could\n+   not transform the CFG at that time.  This routine transforms the\n+   CFG and arranges for the dominator tree to be rebuilt if necessary.\n+\n+   Note the SSA graph update will occur during the normal TODO\n+   processing by the pass manager.  */\n+static void\n+finalize_jump_threads (void)\n+{\n+  bool cfg_altered = false;\n+  cfg_altered = thread_through_all_blocks ();\n+\n+  /* If we threaded jumps, then we need to recompute the dominance\n+     information, to safely do that we must clean up the CFG first.  */\n+  if (cfg_altered)\n+    {\n+      free_dominance_info (CDI_DOMINATORS);\n+      cleanup_tree_cfg ();\n+      calculate_dominance_info (CDI_DOMINATORS);\n+    }\n+  VEC_free (tree, heap, stack);\n+}\n \n \n /* Traverse all the blocks folding conditionals with known ranges.  */\n@@ -4246,6 +4414,10 @@ vrp_finalize (void)\n \n   substitute_and_fold (single_val_range, true);\n \n+  /* We must identify jump threading opportunities before we release\n+     the datastructures built by VRP.  */\n+  identify_jump_threads ();\n+\n   /* Free allocated memory.  */\n   for (i = 0; i < num_ssa_names; i++)\n     if (vr_value[i])\n@@ -4323,7 +4495,12 @@ execute_vrp (void)\n       current_loops = NULL;\n     }\n \n+  /* ASSERT_EXPRs must be removed before finalizing jump threads\n+     as finalizing jump threads calls the CFG cleanup code which\n+     does not properly handle ASSERT_EXPRs.  */\n   remove_range_assertions ();\n+  finalize_jump_threads ();\n+\n }\n \n static bool"}]}