{"sha": "8f4fe86cd10bfe5e02237768c40b258b0e668abf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY0ZmU4NmNkMTBiZmU1ZTAyMjM3NzY4YzQwYjI1OGIwZTY2OGFiZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2010-06-10T20:24:17Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2010-06-10T20:24:17Z"}, "message": "md.texi (define_enum_attr): Document.\n\ngcc/\n\t* doc/md.texi (define_enum_attr): Document.\n\t* rtl.def (DEFINE_ENUM_ATTR): New rtx.\n\t* read-md.h (lookup_enum_type): Declare.\n\t* read-md.c (lookup_enum_type): New function.\n\t* genattr.c (gen_attr, main): Handle DEFINE_ENUM_ATTR.\n\t* genattrtab.c (attr_desc): Add an enum_name field.\n\t(evaluate_eq_attr): Take the associated attribute as argument.\n\tGet the enum prefix from the enum_name field, if defined.\n\tUse ACONCAT rather than a fixed-length buffer.  Update recursive calls.\n\t(simplify_test_exp): Pass attr to evaluate_eq_attr.\n\t(add_attr_value): New function, split out from...\n\t(gen_attr): ...here.  Handle DEFINE_ENUM_ATTR.\n\t(write_test_expr): Pass attr to evaluate_eq_attr.\n\t(write_attr_get): Use the enum_name as the enum tag, if defined.\n\t(write_attr_valueq): Use the enum_name as a prefix, if defined.\n\t(find_attr): Initialize enum_name.\n\t(main): Handle DEFINE_ENUM_ATTR.\n\t* gensupport.c (process_rtx): Likewise.\n\t* config/mips/mips.h (mips_tune_attr): Delete.\n\t* config/mips/mips.md (cpu): Use define_attr_enum.\n\nFrom-SVN: r160581", "tree": {"sha": "7c7c84950cd4b41af7efd6b64db9e7e3cfb1f188", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c7c84950cd4b41af7efd6b64db9e7e3cfb1f188"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f4fe86cd10bfe5e02237768c40b258b0e668abf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f4fe86cd10bfe5e02237768c40b258b0e668abf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f4fe86cd10bfe5e02237768c40b258b0e668abf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f4fe86cd10bfe5e02237768c40b258b0e668abf/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "24609606bd4dec8c2cf5f8eaa82c44f67f4f5f6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24609606bd4dec8c2cf5f8eaa82c44f67f4f5f6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24609606bd4dec8c2cf5f8eaa82c44f67f4f5f6e"}], "stats": {"total": 221, "additions": 163, "deletions": 58}, "files": [{"sha": "77453d9ba5ec06195d40fa5a86eb856408c2357c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4fe86cd10bfe5e02237768c40b258b0e668abf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4fe86cd10bfe5e02237768c40b258b0e668abf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8f4fe86cd10bfe5e02237768c40b258b0e668abf", "patch": "@@ -1,3 +1,26 @@\n+2010-06-10  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* doc/md.texi (define_enum_attr): Document.\n+\t* rtl.def (DEFINE_ENUM_ATTR): New rtx.\n+\t* read-md.h (lookup_enum_type): Declare.\n+\t* read-md.c (lookup_enum_type): New function.\n+\t* genattr.c (gen_attr, main): Handle DEFINE_ENUM_ATTR.\n+\t* genattrtab.c (attr_desc): Add an enum_name field.\n+\t(evaluate_eq_attr): Take the associated attribute as argument.\n+\tGet the enum prefix from the enum_name field, if defined.\n+\tUse ACONCAT rather than a fixed-length buffer.  Update recursive calls.\n+\t(simplify_test_exp): Pass attr to evaluate_eq_attr.\n+\t(add_attr_value): New function, split out from...\n+\t(gen_attr): ...here.  Handle DEFINE_ENUM_ATTR.\n+\t(write_test_expr): Pass attr to evaluate_eq_attr.\n+\t(write_attr_get): Use the enum_name as the enum tag, if defined.\n+\t(write_attr_valueq): Use the enum_name as a prefix, if defined.\n+\t(find_attr): Initialize enum_name.\n+\t(main): Handle DEFINE_ENUM_ATTR.\n+\t* gensupport.c (process_rtx): Likewise.\n+\t* config/mips/mips.h (mips_tune_attr): Delete.\n+\t* config/mips/mips.md (cpu): Use define_attr_enum.\n+\n 2010-06-10  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* doc/md.texi (define_c_enum, define_enum): Document."}, {"sha": "4026bd737140397b967448e1351978dc6d48e9e9", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4fe86cd10bfe5e02237768c40b258b0e668abf/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4fe86cd10bfe5e02237768c40b258b0e668abf/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=8f4fe86cd10bfe5e02237768c40b258b0e668abf", "patch": "@@ -3035,10 +3035,6 @@ extern enum mips_code_readable_setting mips_code_readable;\n #define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS)\t\\\n   mips_final_prescan_insn (INSN, OPVEC, NOPERANDS)\n \n-/* This is necessary to avoid a warning about comparing different enum\n-   types.  */\n-#define mips_tune_attr ((enum attr_cpu) mips_tune)\n-\n /* As on most targets, we want the .eh_frame section to be read-only where\n    possible.  And as on most targets, this means two things:\n "}, {"sha": "0ad21bd178302be574b62c20835d79ac2bebbe01", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4fe86cd10bfe5e02237768c40b258b0e668abf/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4fe86cd10bfe5e02237768c40b258b0e668abf/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=8f4fe86cd10bfe5e02237768c40b258b0e668abf", "patch": "@@ -508,11 +508,9 @@\n \t  (symbol_ref \"mips_sync_loop_insns (insn, operands) * 4\")\n \t  ] (const_int 4)))\n \n-;; Attribute describing the processor.  This attribute must match exactly\n-;; with the processor enumeration above.\n-(define_attr \"cpu\"\n-  \"r3000,4kc,4kp,5kc,5kf,20kc,24kc,24kf2_1,24kf1_1,74kc,74kf2_1,74kf1_1,74kf3_2,loongson_2e,loongson_2f,m4k,octeon,r3900,r6000,r4000,r4100,r4111,r4120,r4130,r4300,r4600,r4650,r5000,r5400,r5500,r7000,r8000,r9000,r10000,sb1,sb1a,sr71000,xlr\"\n-  (const (symbol_ref \"mips_tune_attr\")))\n+;; Attribute describing the processor.\n+(define_enum_attr \"cpu\" \"processor\"\n+  (const (symbol_ref \"mips_tune\")))\n \n ;; The type of hardware hazard associated with this instruction.\n ;; DELAY means that the next instruction cannot read the result"}, {"sha": "d0aa8646ede1c67260681aa46cc30fc6b6004e5e", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4fe86cd10bfe5e02237768c40b258b0e668abf/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4fe86cd10bfe5e02237768c40b258b0e668abf/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=8f4fe86cd10bfe5e02237768c40b258b0e668abf", "patch": "@@ -6700,9 +6700,46 @@ distances. @xref{Insn Lengths}.\n The @code{enabled} attribute can be defined to prevent certain\n alternatives of an insn definition from being used during code\n generation. @xref{Disable Insn Alternatives}.\n-\n @end table\n \n+@findex define_enum_attr\n+@anchor{define_enum_attr}\n+Another way of defining an attribute is to use:\n+\n+@smallexample\n+(define_enum_attr \"@var{attr}\" \"@var{enum}\" @var{default})\n+@end smallexample\n+\n+This works in just the same way as @code{define_attr}, except that\n+the list of values is taken from a separate enumeration called\n+@var{enum} (@pxref{define_enum}).  This form allows you to use\n+the same list of values for several attributes without having to\n+repeat the list each time.  For example:\n+\n+@smallexample\n+(define_enum \"processor\" [\n+  model_a\n+  model_b\n+  @dots{}\n+])\n+(define_enum_attr \"arch\" \"processor\"\n+  (const (symbol_ref \"target_arch\")))\n+(define_enum_attr \"tune\" \"processor\"\n+  (const (symbol_ref \"target_tune\")))\n+@end smallexample\n+\n+defines the same attributes as:\n+\n+@smallexample\n+(define_attr \"arch\" \"model_a,model_b,@dots{}\"\n+  (const (symbol_ref \"target_arch\")))\n+(define_attr \"tune\" \"model_a,model_b,@dots{}\"\n+  (const (symbol_ref \"target_tune\")))\n+@end smallexample\n+\n+but without duplicating the processor list.  The second example defines two\n+separate C enums (@code{attr_arch} and @code{attr_tune}) whereas the first\n+defines a single C enum (@code{processor}).\n @end ifset\n @ifset INTERNALS\n @node Expressions\n@@ -7961,6 +7998,7 @@ it is convenient to define all synchronization-specific enumeration\n values in @file{sync.md} rather than in the main @file{.md} file.\n \n @findex define_enum\n+@anchor{define_enum}\n Another way of defining an enumeration is to use @code{define_enum}:\n \n @smallexample\n@@ -7983,7 +8021,11 @@ This directive implies:\n ])\n @end smallexample\n \n+@findex define_enum_attr\n where @var{cvaluei} is the capitalized form of @var{valuei}.\n+However, unlike @code{define_c_enum}, the enumerations defined\n+by @code{define_enum} can be used in attribute specifications\n+(@pxref{define_enum_attr}).\n @end ifset\n @ifset INTERNALS\n @node Iterators"}, {"sha": "e4609ca41743a47935f9697773acaa3e62897ec0", "filename": "gcc/genattr.c", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4fe86cd10bfe5e02237768c40b258b0e668abf/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4fe86cd10bfe5e02237768c40b258b0e668abf/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=8f4fe86cd10bfe5e02237768c40b258b0e668abf", "patch": "@@ -49,27 +49,33 @@ gen_attr (rtx attr)\n   printf (\"#define HAVE_ATTR_%s\\n\", XSTR (attr, 0));\n \n   /* If numeric attribute, don't need to write an enum.  */\n-  p = XSTR (attr, 1);\n-  if (*p == '\\0')\n-    printf (\"extern int get_attr_%s (%s);\\n\", XSTR (attr, 0),\n-\t    (is_const ? \"void\" : \"rtx\"));\n+  if (GET_CODE (attr) == DEFINE_ENUM_ATTR)\n+    printf (\"extern enum %s get_attr_%s (%s);\\n\\n\",\n+\t    XSTR (attr, 1), XSTR (attr, 0), (is_const ? \"void\" : \"rtx\"));\n   else\n     {\n-      printf (\"enum attr_%s {\", XSTR (attr, 0));\n-\n-      while ((tag = scan_comma_elt (&p)) != 0)\n+      p = XSTR (attr, 1);\n+      if (*p == '\\0')\n+\tprintf (\"extern int get_attr_%s (%s);\\n\", XSTR (attr, 0),\n+\t\t(is_const ? \"void\" : \"rtx\"));\n+      else\n \t{\n-\t  write_upcase (XSTR (attr, 0));\n-\t  putchar ('_');\n-\t  while (tag != p)\n-\t    putchar (TOUPPER (*tag++));\n-\t  if (*p == ',')\n-\t    fputs (\", \", stdout);\n-\t}\n+\t  printf (\"enum attr_%s {\", XSTR (attr, 0));\n+\n+\t  while ((tag = scan_comma_elt (&p)) != 0)\n+\t    {\n+\t      write_upcase (XSTR (attr, 0));\n+\t      putchar ('_');\n+\t      while (tag != p)\n+\t\tputchar (TOUPPER (*tag++));\n+\t      if (*p == ',')\n+\t\tfputs (\", \", stdout);\n+\t    }\n+\t  fputs (\"};\\n\", stdout);\n \n-      fputs (\"};\\n\", stdout);\n-      printf (\"extern enum attr_%s get_attr_%s (%s);\\n\\n\",\n-\t      XSTR (attr, 0), XSTR (attr, 0), (is_const ? \"void\" : \"rtx\"));\n+\t  printf (\"extern enum attr_%s get_attr_%s (%s);\\n\\n\",\n+\t\t  XSTR (attr, 0), XSTR (attr, 0), (is_const ? \"void\" : \"rtx\"));\n+\t}\n     }\n \n   /* If `length' attribute, write additional function definitions and define\n@@ -122,7 +128,8 @@ main (int argc, char **argv)\n       if (desc == NULL)\n \tbreak;\n \n-      if (GET_CODE (desc) == DEFINE_ATTR)\n+      if (GET_CODE (desc) == DEFINE_ATTR\n+\t  || GET_CODE (desc) == DEFINE_ENUM_ATTR)\n \tgen_attr (desc);\n \n       else if (GET_CODE (desc) == DEFINE_DELAY)"}, {"sha": "9fe1c5caa7c59c4b738f45bafd41f34013e425fa", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 53, "deletions": 30, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4fe86cd10bfe5e02237768c40b258b0e668abf/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4fe86cd10bfe5e02237768c40b258b0e668abf/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=8f4fe86cd10bfe5e02237768c40b258b0e668abf", "patch": "@@ -171,6 +171,7 @@ struct attr_value\n struct attr_desc\n {\n   char *name;\t\t\t/* Name of attribute.  */\n+  const char *enum_name;\t/* Enum name for DEFINE_ENUM_NAME.  */\n   struct attr_desc *next;\t/* Next attribute.  */\n   struct attr_value *first_value; /* First value of this attribute.  */\n   struct attr_value *default_val; /* Default value for this attribute.  */\n@@ -1901,11 +1902,13 @@ make_alternative_compare (int mask)\n    computation.  If a test condition involves an address, we leave the EQ_ATTR\n    intact because addresses are only valid for the `length' attribute.\n \n-   EXP is the EQ_ATTR expression and VALUE is the value of that attribute\n-   for the insn corresponding to INSN_CODE and INSN_INDEX.  */\n+   EXP is the EQ_ATTR expression and ATTR is the attribute to which\n+   it refers.  VALUE is the value of that attribute for the insn\n+   corresponding to INSN_CODE and INSN_INDEX.  */\n \n static rtx\n-evaluate_eq_attr (rtx exp, rtx value, int insn_code, int insn_index)\n+evaluate_eq_attr (rtx exp, struct attr_desc *attr, rtx value,\n+\t\t  int insn_code, int insn_index)\n {\n   rtx orexp, andexp;\n   rtx right;\n@@ -1923,16 +1926,12 @@ evaluate_eq_attr (rtx exp, rtx value, int insn_code, int insn_index)\n \n     case SYMBOL_REF:\n       {\n-\tchar *p;\n-\tchar string[256];\n+\tconst char *prefix;\n+\tchar *string, *p;\n \n \tgcc_assert (GET_CODE (exp) == EQ_ATTR);\n-\tgcc_assert (strlen (XSTR (exp, 0)) + strlen (XSTR (exp, 1)) + 2\n-\t\t    <= 256);\n-\n-\tstrcpy (string, XSTR (exp, 0));\n-\tstrcat (string, \"_\");\n-\tstrcat (string, XSTR (exp, 1));\n+\tprefix = attr->enum_name ? attr->enum_name : attr->name;\n+\tstring = ACONCAT ((prefix, \"_\", XSTR (exp, 1), NULL));\n \tfor (p = string; *p; p++)\n \t  *p = TOUPPER (*p);\n \n@@ -1966,7 +1965,7 @@ evaluate_eq_attr (rtx exp, rtx value, int insn_code, int insn_index)\n \t  right = insert_right_side (AND, andexp, this_cond,\n \t\t\t\t     insn_code, insn_index);\n \t  right = insert_right_side (AND, right,\n-\t\t\t\t     evaluate_eq_attr (exp,\n+\t\t\t\t     evaluate_eq_attr (exp, attr,\n \t\t\t\t\t\t       XVECEXP (value, 0,\n \t\t\t\t\t\t\t\ti + 1),\n \t\t\t\t\t\t       insn_code, insn_index),\n@@ -1982,7 +1981,7 @@ evaluate_eq_attr (rtx exp, rtx value, int insn_code, int insn_index)\n \n       /* Handle the default case.  */\n       right = insert_right_side (AND, andexp,\n-\t\t\t\t evaluate_eq_attr (exp, XEXP (value, 1),\n+\t\t\t\t evaluate_eq_attr (exp, attr, XEXP (value, 1),\n \t\t\t\t\t\t   insn_code, insn_index),\n \t\t\t\t insn_code, insn_index);\n       newexp = insert_right_side (IOR, orexp, right, insn_code, insn_index);\n@@ -2732,7 +2731,8 @@ simplify_test_exp (rtx exp, int insn_code, int insn_index)\n \t  if (av)\n \t    {\n \t    got_av:\n-\t      x = evaluate_eq_attr (exp, av->value, insn_code, insn_index);\n+\t      x = evaluate_eq_attr (exp, attr, av->value,\n+\t\t\t\t    insn_code, insn_index);\n \t      x = SIMPLIFY_TEST_EXP (x, insn_code, insn_index);\n \t      if (attr_rtx_cost(x) < 20)\n \t\treturn x;\n@@ -2900,13 +2900,30 @@ clear_struct_flag (rtx x)\n     }\n }\n \n-/* Create table entries for DEFINE_ATTR.  */\n+/* Add attribute value NAME to the beginning of ATTR's list.  */\n+\n+static void\n+add_attr_value (struct attr_desc *attr, const char *name)\n+{\n+  struct attr_value *av;\n+\n+  av = oballoc (struct attr_value);\n+  av->value = attr_rtx (CONST_STRING, name);\n+  av->next = attr->first_value;\n+  attr->first_value = av;\n+  av->first_insn = NULL;\n+  av->num_insns = 0;\n+  av->has_asm_insn = 0;\n+}\n+\n+/* Create table entries for DEFINE_ATTR or DEFINE_ENUM_ATTR.  */\n \n static void\n gen_attr (rtx exp, int lineno)\n {\n+  struct enum_type *et;\n+  struct enum_value *ev;\n   struct attr_desc *attr;\n-  struct attr_value *av;\n   const char *name_ptr;\n   char *p;\n \n@@ -2922,21 +2939,23 @@ gen_attr (rtx exp, int lineno)\n     }\n   attr->lineno = lineno;\n \n-  if (*XSTR (exp, 1) == '\\0')\n+  if (GET_CODE (exp) == DEFINE_ENUM_ATTR)\n+    {\n+      attr->enum_name = XSTR (exp, 1);\n+      et = lookup_enum_type (XSTR (exp, 1));\n+      if (!et || !et->md_p)\n+\terror_with_line (lineno, \"No define_enum called `%s' defined\",\n+\t\t\t attr->name);\n+      for (ev = et->values; ev; ev = ev->next)\n+\tadd_attr_value (attr, ev->name);\n+    }\n+  else if (*XSTR (exp, 1) == '\\0')\n     attr->is_numeric = 1;\n   else\n     {\n       name_ptr = XSTR (exp, 1);\n       while ((p = next_comma_elt (&name_ptr)) != NULL)\n-\t{\n-\t  av = oballoc (struct attr_value);\n-\t  av->value = attr_rtx (CONST_STRING, p);\n-\t  av->next = attr->first_value;\n-\t  attr->first_value = av;\n-\t  av->first_insn = NULL;\n-\t  av->num_insns = 0;\n-\t  av->has_asm_insn = 0;\n-\t}\n+\tadd_attr_value (attr, p);\n     }\n \n   if (GET_CODE (XEXP (exp, 2)) == CONST)\n@@ -3319,8 +3338,8 @@ write_test_expr (rtx exp, int flags)\n       /* Now is the time to expand the value of a constant attribute.  */\n       if (attr->is_const)\n \t{\n-\t  write_test_expr (evaluate_eq_attr (exp, attr->default_val->value,\n-\t\t\t\t\t     -2, -2),\n+\t  write_test_expr (evaluate_eq_attr (exp, attr,\n+\t\t\t\t\t     attr->default_val->value, -2, -2),\n \t\t\t   flags);\n \t}\n       else\n@@ -3612,7 +3631,9 @@ write_attr_get (struct attr_desc *attr)\n \n   /* Write out start of function, then all values with explicit `case' lines,\n      then a `default', then the value with the most uses.  */\n-  if (!attr->is_numeric)\n+  if (attr->enum_name)\n+    printf (\"enum %s\\n\", attr->enum_name);\n+  else if (!attr->is_numeric)\n     printf (\"enum attr_%s\\n\", attr->name);\n   else\n     printf (\"int\\n\");\n@@ -3869,7 +3890,7 @@ write_attr_valueq (struct attr_desc *attr, const char *s)\n     }\n   else\n     {\n-      write_upcase (attr->name);\n+      write_upcase (attr->enum_name ? attr->enum_name : attr->name);\n       printf (\"_\");\n       write_upcase (s);\n     }\n@@ -4133,6 +4154,7 @@ find_attr (const char **name_p, int create)\n \n   attr = oballoc (struct attr_desc);\n   attr->name = DEF_ATTR_STRING (name);\n+  attr->enum_name = 0;\n   attr->first_value = attr->default_val = NULL;\n   attr->is_numeric = attr->is_const = attr->is_special = 0;\n   attr->next = attrs[index];\n@@ -4459,6 +4481,7 @@ from the machine description file `md'.  */\\n\\n\");\n \t  break;\n \n \tcase DEFINE_ATTR:\n+\tcase DEFINE_ENUM_ATTR:\n \t  gen_attr (desc, lineno);\n \t  break;\n "}, {"sha": "206e96b7c61525a07abd54be2f16477d1d9501c3", "filename": "gcc/gensupport.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4fe86cd10bfe5e02237768c40b258b0e668abf/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4fe86cd10bfe5e02237768c40b258b0e668abf/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=8f4fe86cd10bfe5e02237768c40b258b0e668abf", "patch": "@@ -173,6 +173,7 @@ process_rtx (rtx desc, int lineno)\n       break;\n \n     case DEFINE_ATTR:\n+    case DEFINE_ENUM_ATTR:\n       queue_pattern (desc, &define_attr_tail, read_md_filename, lineno);\n       break;\n "}, {"sha": "9c622912b3a6fe265d0fd1146c8bc51b3a169517", "filename": "gcc/read-md.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4fe86cd10bfe5e02237768c40b258b0e668abf/gcc%2Fread-md.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4fe86cd10bfe5e02237768c40b258b0e668abf/gcc%2Fread-md.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.c?ref=8f4fe86cd10bfe5e02237768c40b258b0e668abf", "patch": "@@ -847,6 +847,14 @@ handle_enum (int lineno, bool md_p)\n     }\n }\n \n+/* Try to find the definition of the given enum.  Return null on failure.  */\n+\n+struct enum_type *\n+lookup_enum_type (const char *name)\n+{\n+  return (struct enum_type *) htab_find (enum_types, &name);\n+}\n+\n /* For every enum definition, call CALLBACK with two arguments:\n    a pointer to the constant definition and INFO.  Stop when CALLBACK\n    returns zero.  */"}, {"sha": "abcca51ac72b01fec370d405947863ce7f4ddc28", "filename": "gcc/read-md.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4fe86cd10bfe5e02237768c40b258b0e668abf/gcc%2Fread-md.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4fe86cd10bfe5e02237768c40b258b0e668abf/gcc%2Fread-md.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.h?ref=8f4fe86cd10bfe5e02237768c40b258b0e668abf", "patch": "@@ -135,5 +135,6 @@ extern const char *scan_comma_elt (const char **);\n extern void upcase_string (char *);\n extern void traverse_md_constants (htab_trav, void *);\n extern void traverse_enum_types (htab_trav, void *);\n+extern struct enum_type *lookup_enum_type (const char *);\n extern bool read_md_files (int, char **, bool (*) (const char *),\n \t\t\t   directive_handler_t);"}, {"sha": "c4a3646afeaee15d55a97c0c30948344a8a23b59", "filename": "gcc/rtl.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4fe86cd10bfe5e02237768c40b258b0e668abf/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4fe86cd10bfe5e02237768c40b258b0e668abf/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=8f4fe86cd10bfe5e02237768c40b258b0e668abf", "patch": "@@ -1198,6 +1198,12 @@ DEF_RTL_EXPR(DEFINE_INSN_RESERVATION, \"define_insn_reservation\", \"sies\", RTX_EXT\n    3rd operand: expression for the default value of the attribute.  */\n DEF_RTL_EXPR(DEFINE_ATTR, \"define_attr\", \"sse\", RTX_EXTRA)\n \n+/* Definition of an insn attribute that uses an existing enumerated type.\n+   1st operand: name of the attribute\n+   2nd operand: the name of the enumerated type\n+   3rd operand: expression for the default value of the attribute.  */\n+DEF_RTL_EXPR(DEFINE_ENUM_ATTR, \"define_enum_attr\", \"sse\", RTX_EXTRA)\n+\n /* Marker for the name of an attribute.  */\n DEF_RTL_EXPR(ATTR, \"attr\", \"s\", RTX_EXTRA)\n "}]}