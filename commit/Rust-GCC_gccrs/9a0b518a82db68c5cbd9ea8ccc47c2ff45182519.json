{"sha": "9a0b518a82db68c5cbd9ea8ccc47c2ff45182519", "node_id": "C_kwDOANBUbNoAKDlhMGI1MThhODJkYjY4YzVjYmQ5ZWE4Y2NjNDdjMmZmNDUxODI1MTk", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-01-13T22:08:43Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-01-14T10:14:25Z"}, "message": "libstdc++: Add C++20 std::make_shared enhancements (P0674R1)\n\nThis adds the overloads of std::make_shared and std::allocate_shared for\ncreating arrays, added to C++20 by P0674R1.\n\nIt also adds std::make_shared_for_overwrite, added to C++20 by P1020R1\n(and renamed by P1973R1). The std::make_unique_for_overwite overloads\nare already supported.\n\nThe original std::make_shared overload is changed to construct a\nshared_ptr directly instead of calling std::allocate_shared. This\nremoves a function call at runtime, and avoids having to do overload\nresolution for std::allocate_shared, now that there are five overloads\nof it.\n\nAllocating a shared array is done by a new __shared_count constructor.\nAn array is allocated with space for additional elements at the end and\nan instance of new _Sp_counted_array class template is constructed in\nthat unused capacity.\n\nThe non-array form of std::make_shared_for_overwrite uses the same\n__shared_count constructor as the original std::make_shared overload,\nbut a new partial specialization of _Sp_counted_ptr_inplace is selected\nwhen the allocator's value_type is the new _Sp_overwrite_tag type. That\nnew partial specialization default-initializes its contained object and\ndestroys it with a destructor call rather than using the allocator.\n\nDespite being C++20 features, this implementation only uses concepts\nconditionally, with workarounds when they are not supported. This allows\nit to work with older non-GCC compilers (Clang 9 and icc 2021). At some\npoint we can simplify the code by removing the workarounds.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/shared_ptr.h (__cpp_lib_shared_ptr_weak_type):\n\tCorrect type of macro value.\n\t(shared_ptr): Add additional friend declarations.\n\t(make_shared, allocate_shared): Constrain existing overloads and\n\tremove static_assert.\n\t* include/bits/shared_ptr_base.h (__cpp_lib_smart_ptr_for_overwrite):\n\tNew macro.\n\t(_Sp_counted_ptr_inplace<T, Alloc, Lp>): New partial\n\tspecialization for use with make_shared_for_overwrite.\n\t(__cpp_lib_shared_ptr_arrays): Update value for C++20.\n\t(_Sp_counted_array_base): New class template.\n\t(_Sp_counted_array): New class template.\n\t(__shared_count(_Tp*&, const _Sp_counted_array_base&, _Init)):\n\tNew constructor for allocating shared arrays.\n\t(__shared_ptr(const _Sp_counted_array_base&, _Init)): Likewise.\n\t* include/std/version (__cpp_lib_shared_ptr_weak_type): Correct\n\ttype.\n\t(__cpp_lib_shared_ptr_arrays): Update value for C++20.\n\t(__cpp_lib_smart_ptr_for_overwrite): New macro.\n\t* testsuite/20_util/shared_ptr/creation/99006.cc: Adjust\n\texpected errors.\n\t* testsuite/20_util/shared_ptr/creation/array.cc: New test.\n\t* testsuite/20_util/shared_ptr/creation/overwrite.cc: New test.\n\t* testsuite/20_util/shared_ptr/creation/version.cc: New test.\n\t* testsuite/20_util/unique_ptr/creation/for_overwrite.cc: Check\n\tfeature test macro. Test non-trivial default-initialization.", "tree": {"sha": "6fce64cd7aacd03b1f14e5cb0282f4d917d49d23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fce64cd7aacd03b1f14e5cb0282f4d917d49d23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a0b518a82db68c5cbd9ea8ccc47c2ff45182519", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a0b518a82db68c5cbd9ea8ccc47c2ff45182519", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a0b518a82db68c5cbd9ea8ccc47c2ff45182519", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a0b518a82db68c5cbd9ea8ccc47c2ff45182519/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc6f1128ae603164aea6303ce2b3ed0b57e6a378", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc6f1128ae603164aea6303ce2b3ed0b57e6a378", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc6f1128ae603164aea6303ce2b3ed0b57e6a378"}], "stats": {"total": 993, "additions": 975, "deletions": 18}, "files": [{"sha": "f44008ed2b142b791da0621f714bf361539b1d96", "filename": "libstdc++-v3/include/bits/shared_ptr.h", "status": "modified", "additions": 261, "deletions": 10, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0b518a82db68c5cbd9ea8ccc47c2ff45182519/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0b518a82db68c5cbd9ea8ccc47c2ff45182519/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h?ref=9a0b518a82db68c5cbd9ea8ccc47c2ff45182519", "patch": "@@ -100,6 +100,57 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif\n     }\n \n+  /// @cond undocumented\n+\n+  // Constraint for overloads taking non-array types.\n+#if __cpp_concepts && __cpp_lib_type_trait_variable_templates\n+  template<typename _Tp>\n+    requires (!is_array_v<_Tp>)\n+    using _NonArray = _Tp;\n+#else\n+  template<typename _Tp>\n+    using _NonArray = __enable_if_t<!is_array<_Tp>::value, _Tp>;\n+#endif\n+\n+#if __cpp_lib_shared_ptr_arrays >= 201707L\n+  // Constraint for overloads taking array types with unknown bound, U[].\n+#if __cpp_concepts\n+  template<typename _Tp>\n+    requires is_array_v<_Tp> && (extent_v<_Tp> == 0)\n+    using _UnboundedArray = _Tp;\n+#else\n+  template<typename _Tp>\n+    using _UnboundedArray\n+      = __enable_if_t<__is_array_unknown_bounds<_Tp>::value, _Tp>;\n+#endif\n+\n+  // Constraint for overloads taking array types with known bound, U[N].\n+#if __cpp_concepts\n+  template<typename _Tp>\n+    requires (extent_v<_Tp> != 0)\n+    using _BoundedArray = _Tp;\n+#else\n+  template<typename _Tp>\n+    using _BoundedArray\n+      = __enable_if_t<__is_array_known_bounds<_Tp>::value, _Tp>;\n+#endif\n+\n+#if __cpp_lib_smart_ptr_for_overwrite\n+  // Constraint for overloads taking either non-array or bounded array, U[N].\n+#if __cpp_concepts\n+  template<typename _Tp>\n+    requires (!is_array_v<_Tp>) || (extent_v<_Tp> != 0)\n+    using _NotUnboundedArray = _Tp;\n+#else\n+  template<typename _Tp>\n+    using _NotUnboundedArray\n+      = __enable_if_t<!__is_array_unknown_bounds<_Tp>::value, _Tp>;\n+#endif\n+#endif // smart_ptr_for_overwrite\n+#endif // shared_ptr_arrays\n+\n+  /// @endcond\n+\n   /**\n    *  @brief  A smart pointer with reference-counted copy semantics.\n    *  @headerfile memory\n@@ -139,7 +190,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using element_type = typename __shared_ptr<_Tp>::element_type;\n \n #if __cplusplus >= 201703L\n-# define __cpp_lib_shared_ptr_weak_type 201606\n+# define __cpp_lib_shared_ptr_weak_type 201606L\n       /// The corresponding weak_ptr type for this shared_ptr\n       /// @since C++17\n       using weak_type = weak_ptr<_Tp>;\n@@ -414,8 +465,71 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{ }\n \n       template<typename _Yp, typename _Alloc, typename... _Args>\n-\tfriend shared_ptr<_Yp>\n-\tallocate_shared(const _Alloc& __a, _Args&&... __args);\n+\tfriend shared_ptr<_NonArray<_Yp>>\n+\tallocate_shared(const _Alloc&, _Args&&...);\n+\n+      template<typename _Yp, typename... _Args>\n+\tfriend shared_ptr<_NonArray<_Yp>>\n+\tmake_shared(_Args&&...);\n+\n+#if __cpp_lib_shared_ptr_arrays >= 201707L\n+      // This constructor is non-standard, it is used by allocate_shared<T[]>.\n+      template<typename _Alloc, typename _Init = const remove_extent_t<_Tp>*>\n+\tshared_ptr(const _Sp_counted_array_base<_Alloc>& __a,\n+\t\t   _Init __init = nullptr)\n+\t: __shared_ptr<_Tp>(__a, __init)\n+\t{ }\n+\n+      template<typename _Yp, typename _Alloc>\n+\tfriend shared_ptr<_UnboundedArray<_Yp>>\n+\tallocate_shared(const _Alloc&, size_t);\n+\n+      template<typename _Yp>\n+\tfriend shared_ptr<_UnboundedArray<_Yp>>\n+\tmake_shared(size_t);\n+\n+      template<typename _Yp, typename _Alloc>\n+\tfriend shared_ptr<_UnboundedArray<_Yp>>\n+\tallocate_shared(const _Alloc&, size_t, const remove_extent_t<_Yp>&);\n+\n+      template<typename _Yp>\n+\tfriend shared_ptr<_UnboundedArray<_Yp>>\n+\tmake_shared(size_t, const remove_extent_t<_Yp>&);\n+\n+      template<typename _Yp, typename _Alloc>\n+\tfriend shared_ptr<_BoundedArray<_Yp>>\n+\tallocate_shared(const _Alloc&);\n+\n+      template<typename _Yp>\n+\tfriend shared_ptr<_BoundedArray<_Yp>>\n+\tmake_shared();\n+\n+      template<typename _Yp, typename _Alloc>\n+\tfriend shared_ptr<_BoundedArray<_Yp>>\n+\tallocate_shared(const _Alloc&, const remove_extent_t<_Yp>&);\n+\n+      template<typename _Yp>\n+\tfriend shared_ptr<_BoundedArray<_Yp>>\n+\tmake_shared(const remove_extent_t<_Yp>&);\n+\n+#if __cpp_lib_smart_ptr_for_overwrite\n+      template<typename _Yp, typename _Alloc>\n+\tfriend shared_ptr<_NotUnboundedArray<_Yp>>\n+\tallocate_shared_for_overwrite(const _Alloc&);\n+\n+      template<typename _Yp>\n+\tfriend shared_ptr<_NotUnboundedArray<_Yp>>\n+\tmake_shared_for_overwrite();\n+\n+      template<typename _Yp, typename _Alloc>\n+\tfriend shared_ptr<_UnboundedArray<_Yp>>\n+\tallocate_shared_for_overwrite(const _Alloc&, size_t);\n+\n+      template<typename _Yp>\n+\tfriend shared_ptr<_UnboundedArray<_Yp>>\n+\tmake_shared_for_overwrite(size_t);\n+#endif\n+#endif\n \n       // This constructor is non-standard, it is used by weak_ptr::lock().\n       shared_ptr(const weak_ptr<_Tp>& __r, std::nothrow_t) noexcept\n@@ -872,11 +986,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  and the new object.\n    */\n   template<typename _Tp, typename _Alloc, typename... _Args>\n-    inline shared_ptr<_Tp>\n+    inline shared_ptr<_NonArray<_Tp>>\n     allocate_shared(const _Alloc& __a, _Args&&... __args)\n     {\n-      static_assert(!is_array<_Tp>::value, \"make_shared<T[]> not supported\");\n-\n       return shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc>{__a},\n \t\t\t     std::forward<_Args>(__args)...);\n     }\n@@ -889,13 +1001,152 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *          constructor of @a _Tp.\n    */\n   template<typename _Tp, typename... _Args>\n-    inline shared_ptr<_Tp>\n+    inline shared_ptr<_NonArray<_Tp>>\n     make_shared(_Args&&... __args)\n     {\n-      typedef typename std::remove_cv<_Tp>::type _Tp_nc;\n-      return std::allocate_shared<_Tp>(std::allocator<_Tp_nc>(),\n-\t\t\t\t       std::forward<_Args>(__args)...);\n+      using _Alloc = allocator<void>;\n+      _Alloc __a;\n+      return shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc>{__a},\n+\t\t\t     std::forward<_Args>(__args)...);\n+    }\n+\n+#if __cpp_lib_shared_ptr_arrays >= 201707L\n+  /// @cond undocumented\n+  template<typename _Tp, typename _Alloc = allocator<void>>\n+    auto\n+    __make_shared_arr_tag(size_t __n, const _Alloc& __a = _Alloc()) noexcept\n+    {\n+      using _Up = remove_all_extents_t<_Tp>;\n+      using _UpAlloc = __alloc_rebind<_Alloc, _Up>;\n+      size_t __s = sizeof(remove_extent_t<_Tp>) / sizeof(_Up);\n+      if (__builtin_mul_overflow(__s, __n, &__n))\n+\tstd::__throw_bad_array_new_length();\n+      return _Sp_counted_array_base<_UpAlloc>{_UpAlloc(__a), __n};\n+    }\n+  /// @endcond\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline shared_ptr<_UnboundedArray<_Tp>>\n+    allocate_shared(const _Alloc& __a, size_t __n)\n+    {\n+      return shared_ptr<_Tp>(std::__make_shared_arr_tag<_Tp>(__n, __a));\n+    }\n+\n+  template<typename _Tp>\n+    inline shared_ptr<_UnboundedArray<_Tp>>\n+    make_shared(size_t __n)\n+    {\n+      return shared_ptr<_Tp>(std::__make_shared_arr_tag<_Tp>(__n));\n+    }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline shared_ptr<_UnboundedArray<_Tp>>\n+    allocate_shared(const _Alloc& __a, size_t __n,\n+\t\t    const remove_extent_t<_Tp>& __u)\n+    {\n+      return shared_ptr<_Tp>(std::__make_shared_arr_tag<_Tp>(__n, __a),\n+\t\t\t     std::__addressof(__u));\n+    }\n+\n+  template<typename _Tp>\n+    inline shared_ptr<_UnboundedArray<_Tp>>\n+    make_shared(size_t __n, const remove_extent_t<_Tp>& __u)\n+    {\n+      return shared_ptr<_Tp>(std::__make_shared_arr_tag<_Tp>(__n),\n+\t\t\t     std::__addressof(__u));\n+    }\n+\n+  /// @cond undocumented\n+  template<typename _Tp, typename _Alloc = allocator<void>>\n+    auto\n+    __make_shared_arrN_tag(const _Alloc& __a = _Alloc()) noexcept\n+    {\n+      using _Up = remove_all_extents_t<_Tp>;\n+      using _UpAlloc = __alloc_rebind<_Alloc, _Up>;\n+      size_t __n = sizeof(_Tp) / sizeof(_Up);\n+      return _Sp_counted_array_base<_UpAlloc>{_UpAlloc(__a), __n};\n+    }\n+  /// @endcond\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline shared_ptr<_BoundedArray<_Tp>>\n+    allocate_shared(const _Alloc& __a)\n+    {\n+      return shared_ptr<_Tp>(std::__make_shared_arrN_tag<_Tp>(__a));\n+    }\n+\n+  template<typename _Tp>\n+    inline shared_ptr<_BoundedArray<_Tp>>\n+    make_shared()\n+    {\n+      return shared_ptr<_Tp>(std::__make_shared_arrN_tag<_Tp>());\n+    }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline shared_ptr<_BoundedArray<_Tp>>\n+    allocate_shared(const _Alloc& __a, const remove_extent_t<_Tp>& __u)\n+    {\n+      return shared_ptr<_Tp>(std::__make_shared_arrN_tag<_Tp>(__a),\n+\t\t\t     std::__addressof(__u));\n+    }\n+\n+  template<typename _Tp>\n+    inline shared_ptr<_BoundedArray<_Tp>>\n+    make_shared(const remove_extent_t<_Tp>& __u)\n+    {\n+      return shared_ptr<_Tp>(std::__make_shared_arrN_tag<_Tp>(),\n+\t\t\t     std::__addressof(__u));\n+    }\n+\n+#if __cpp_lib_smart_ptr_for_overwrite\n+  template<typename _Tp, typename _Alloc>\n+    inline shared_ptr<_NotUnboundedArray<_Tp>>\n+    allocate_shared_for_overwrite(const _Alloc& __a)\n+    {\n+      if constexpr (is_array_v<_Tp>)\n+\treturn shared_ptr<_Tp>(std::__make_shared_arrN_tag<_Tp>(__a),\n+\t\t\t       _Sp_overwrite_tag{});\n+      else\n+\t{\n+\t  // Rebind the allocator to _Sp_overwrite_tag, so that the\n+\t  // relevant _Sp_counted_ptr_inplace specialization is used.\n+\t  using _Alloc2 = __alloc_rebind<_Alloc, _Sp_overwrite_tag>;\n+\t  _Alloc2 __a2 = __a;\n+\t  return shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc2>{__a2});\n+\t}\n+    }\n+\n+  template<typename _Tp>\n+    inline shared_ptr<_NotUnboundedArray<_Tp>>\n+    make_shared_for_overwrite()\n+    {\n+      if constexpr (is_array_v<_Tp>)\n+\treturn shared_ptr<_Tp>(std::__make_shared_arrN_tag<_Tp>(),\n+\t\t\t       _Sp_overwrite_tag{});\n+      else\n+\t{\n+\t  using _Alloc = allocator<_Sp_overwrite_tag>;\n+\t  return shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc>{{}});\n+\t}\n+    }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline shared_ptr<_UnboundedArray<_Tp>>\n+    allocate_shared_for_overwrite(const _Alloc& __a, size_t __n)\n+    {\n+      return shared_ptr<_Tp>(std::__make_shared_arr_tag<_Tp>(__n, __a),\n+\t\t\t     _Sp_overwrite_tag{});\n+    }\n+\n+  template<typename _Tp>\n+    inline shared_ptr<_UnboundedArray<_Tp>>\n+    make_shared_for_overwrite(size_t __n)\n+    {\n+      return shared_ptr<_Tp>(std::__make_shared_arr_tag<_Tp>(__n),\n+\t\t\t     _Sp_overwrite_tag{});\n     }\n+#endif // smart_ptr_for_overwrite\n+#endif // shared_ptr_arrays\n \n   /// std::hash specialization for shared_ptr.\n   template<typename _Tp>"}, {"sha": "e16a9250592fa44c889191aff1c01e4329a8f08b", "filename": "libstdc++-v3/include/bits/shared_ptr_base.h", "status": "modified", "additions": 296, "deletions": 3, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0b518a82db68c5cbd9ea8ccc47c2ff45182519/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0b518a82db68c5cbd9ea8ccc47c2ff45182519/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h?ref=9a0b518a82db68c5cbd9ea8ccc47c2ff45182519", "patch": "@@ -60,8 +60,11 @@\n #include <ext/aligned_buffer.h>\n #include <ext/atomicity.h>\n #include <ext/concurrence.h>\n-#if __cplusplus > 201703L\n+#if __cplusplus >= 202002L\n+# include <bit>          // __bit_floor\n # include <compare>\n+# include <bits/align.h> // std::align\n+# include <bits/stl_uninitialized.h>\n #endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n@@ -447,6 +450,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     inline void\n     _Sp_counted_ptr<nullptr_t, _S_atomic>::_M_dispose() noexcept { }\n \n+  // FIXME: once __has_cpp_attribute(__no_unique_address__)) is true for\n+  // all supported compilers we can greatly simplify _Sp_ebo_helper.\n+  // N.B. unconditionally applying the attribute could change layout for\n+  // final types, which currently cannot use EBO so have a unique address.\n+\n   template<int _Nm, typename _Tp,\n \t   bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>\n     struct _Sp_ebo_helper;\n@@ -640,6 +648,233 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Impl _M_impl;\n     };\n \n+#if __cplusplus >= 202002L\n+# define __cpp_lib_smart_ptr_for_overwrite 202002L\n+  struct _Sp_overwrite_tag { };\n+\n+  // Partial specialization used for make_shared_for_overwrite<non-array>().\n+  // This partial specialization is used when the allocator's value type\n+  // is the special _Sp_overwrite_tag type.\n+#if __cpp_concepts\n+  template<typename _Tp, typename _Alloc, _Lock_policy _Lp>\n+    requires is_same_v<typename _Alloc::value_type, _Sp_overwrite_tag>\n+    class _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> final\n+#else\n+  template<typename _Tp, template<typename> class _Alloc, _Lock_policy _Lp>\n+    class _Sp_counted_ptr_inplace<_Tp, _Alloc<_Sp_overwrite_tag>, _Lp> final\n+#endif\n+    : public _Sp_counted_base<_Lp>\n+    {\n+      [[no_unique_address]] _Alloc _M_alloc;\n+\n+      union {\n+\t_Tp _M_obj;\n+\tchar _M_unused;\n+      };\n+\n+      friend class __shared_count<_Lp>; // To be able to call _M_ptr().\n+\n+      _Tp* _M_ptr() noexcept { return std::__addressof(_M_obj); }\n+\n+    public:\n+      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_ptr_inplace>;\n+\n+      _Sp_counted_ptr_inplace(const _Alloc& __a)\n+      : _M_alloc(__a)\n+      {\n+\t::new((void*)_M_ptr()) _Tp; // default-initialized, for overwrite.\n+      }\n+\n+      ~_Sp_counted_ptr_inplace() noexcept { }\n+\n+      virtual void\n+      _M_dispose() noexcept\n+      {\n+\t_M_obj.~_Tp();\n+      }\n+\n+      // Override because the allocator needs to know the dynamic type\n+      virtual void\n+      _M_destroy() noexcept\n+      {\n+\tusing pointer = typename allocator_traits<__allocator_type>::pointer;\n+\t__allocator_type __a(_M_alloc);\n+\tauto __p = pointer_traits<pointer>::pointer_to(*this);\n+\t__allocated_ptr<__allocator_type> __guard_ptr{ __a, __p };\n+\tthis->~_Sp_counted_ptr_inplace();\n+      }\n+\n+      void*\n+      _M_get_deleter(const std::type_info&) noexcept override\n+      { return nullptr; }\n+    };\n+#endif // C++20\n+\n+#if __cplusplus <= 201703L\n+# define __cpp_lib_shared_ptr_arrays 201611L\n+#else\n+# define __cpp_lib_shared_ptr_arrays 201707L\n+\n+  struct _Sp_overwrite_tag;\n+\n+  // For make_shared<T[]>, make_shared<T[N]>, allocate_shared<T[]> etc.\n+  template<typename _Alloc>\n+    struct _Sp_counted_array_base\n+    {\n+      [[no_unique_address]] _Alloc _M_alloc{};\n+      size_t _M_n = 0;\n+      bool _M_overwrite = false;\n+\n+      typename allocator_traits<_Alloc>::pointer\n+      _M_alloc_array(size_t __tail)\n+      {\n+\treturn allocator_traits<_Alloc>::allocate(_M_alloc, _M_n + __tail);\n+      }\n+\n+      void\n+      _M_dealloc_array(typename allocator_traits<_Alloc>::pointer __p,\n+\t\t       size_t __tail)\n+      {\n+\tallocator_traits<_Alloc>::deallocate(_M_alloc, __p, _M_n + __tail);\n+      }\n+\n+      // Init the array elements\n+      template<typename _Init>\n+\tvoid\n+\t_M_init(typename allocator_traits<_Alloc>::value_type* __p,\n+\t\t_Init __init)\n+\t{\n+\t  using _Tp = remove_pointer_t<_Init>;\n+\t  using _Up = typename allocator_traits<_Alloc>::value_type;\n+\n+\t  if constexpr (is_same_v<_Init, _Sp_overwrite_tag>)\n+\t    {\n+\t      std::uninitialized_default_construct_n(__p, _M_n);\n+\t      _M_overwrite = true;\n+\t    }\n+\t  else if (__init == nullptr)\n+\t    std::__uninitialized_default_n_a(__p, _M_n, _M_alloc);\n+\t  else if constexpr (!is_array_v<_Tp>)\n+\t    std::__uninitialized_fill_n_a(__p, _M_n, *__init, _M_alloc);\n+\t  else\n+\t    {\n+\t      struct _Iter\n+\t      {\n+\t\tusing value_type = _Up;\n+\t\tusing difference_type = ptrdiff_t;\n+\t\tusing pointer = const _Up*;\n+\t\tusing reference = const _Up&;\n+\t\tusing iterator_category = forward_iterator_tag;\n+\n+\t\tconst _Up* _M_p;\n+\t\tsize_t _M_len;\n+\t\tsize_t _M_pos;\n+\n+\t\t_Iter& operator++() { ++_M_pos; return *this; }\n+\t\t_Iter operator++(int) { auto __i(*this); ++_M_pos; return __i; }\n+\n+\t\treference operator*() const { return _M_p[_M_pos % _M_len]; }\n+\t\tpointer operator->() const { return _M_p + (_M_pos % _M_len); }\n+\n+\t\tbool operator==(const _Iter& __i) const\n+\t\t{ return _M_pos == __i._M_pos; }\n+\t      };\n+\n+\t      _Iter __first{_S_first_elem(__init), sizeof(_Tp) / sizeof(_Up)};\n+\t      _Iter __last = __first;\n+\t      __last._M_pos = _M_n;\n+\t      std::__uninitialized_copy_a(__first, __last, __p, _M_alloc);\n+\t    }\n+\t}\n+\n+    protected:\n+      // Destroy the array elements\n+      void\n+      _M_dispose_array(typename allocator_traits<_Alloc>::value_type* __p)\n+      {\n+\tif (_M_overwrite)\n+\t  std::destroy_n(__p, _M_n);\n+\telse\n+\t  {\n+\t    size_t __n = _M_n;\n+\t    while (__n--)\n+\t      allocator_traits<_Alloc>::destroy(_M_alloc, __p + __n);\n+\t  }\n+      }\n+\n+    private:\n+      template<typename _Tp>\n+\tstatic _Tp*\n+\t_S_first_elem(_Tp* __p) { return __p; }\n+\n+      template<typename _Tp, size_t _Nm>\n+\tstatic auto\n+\t_S_first_elem(_Tp (*__p)[_Nm]) { return _S_first_elem(*__p); }\n+    };\n+\n+  // Control block for make_shared<T[]>, make_shared<T[N]> etc. that will be\n+  // placed into unused memory at the end of the array.\n+  template<typename _Alloc, _Lock_policy _Lp>\n+    class _Sp_counted_array final\n+    : public _Sp_counted_base<_Lp>, _Sp_counted_array_base<_Alloc>\n+    {\n+      using pointer = typename allocator_traits<_Alloc>::pointer;\n+\n+      pointer _M_alloc_ptr;\n+\n+      auto _M_ptr() const noexcept { return std::to_address(_M_alloc_ptr); }\n+\n+      friend class __shared_count<_Lp>; // To be able to call _M_ptr().\n+\n+    public:\n+      _Sp_counted_array(const _Sp_counted_array_base<_Alloc>& __a,\n+\t\t\tpointer __p) noexcept\n+      : _Sp_counted_array_base<_Alloc>(__a), _M_alloc_ptr(__p)\n+      { }\n+\n+      ~_Sp_counted_array() = default;\n+\n+      virtual void\n+      _M_dispose() noexcept\n+      {\n+\tif (this->_M_n)\n+\t  this->_M_dispose_array(_M_ptr());\n+      }\n+\n+      // Override because the allocator needs to know the dynamic type\n+      virtual void\n+      _M_destroy() noexcept\n+      {\n+\t_Sp_counted_array_base<_Alloc> __a = *this;\n+\tpointer __p = _M_alloc_ptr;\n+\tthis->~_Sp_counted_array();\n+\t__a._M_dealloc_array(__p, _S_tail());\n+      }\n+\n+      // Returns the number of additional array elements that must be\n+      // allocated in order to store a _Sp_counted_array at the end.\n+      static constexpr size_t\n+      _S_tail()\n+      {\n+\t// The array elemenent type.\n+\tusing _Tp = typename allocator_traits<_Alloc>::value_type;\n+\n+\t// The space needed to store a _Sp_counted_array object.\n+\tsize_t __bytes = sizeof(_Sp_counted_array);\n+\n+\t// Add any padding needed for manual alignment within the buffer.\n+\tif constexpr (alignof(_Tp) < alignof(_Sp_counted_array))\n+\t  __bytes += alignof(_Sp_counted_array) - alignof(_Tp);\n+\n+\treturn (__bytes + sizeof(_Tp) - 1) / sizeof(_Tp);\n+      }\n+\n+      void*\n+      _M_get_deleter(const std::type_info&) noexcept override\n+      { return nullptr; }\n+    };\n+#endif // C++20\n+\n   // The default deleter for shared_ptr<T[]> and shared_ptr<T[N]>.\n   struct __sp_array_delete\n   {\n@@ -650,12 +885,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<_Lock_policy _Lp>\n     class __shared_count\n     {\n+      // Prevent _Sp_alloc_shared_tag from matching the shared_ptr(P, D) ctor.\n       template<typename _Tp>\n \tstruct __not_alloc_shared_tag { using type = void; };\n \n       template<typename _Tp>\n \tstruct __not_alloc_shared_tag<_Sp_alloc_shared_tag<_Tp>> { };\n \n+#if __cpp_lib_shared_ptr_arrays >= 201707L\n+      template<typename _Alloc>\n+\tstruct __not_alloc_shared_tag<_Sp_counted_array_base<_Alloc>> { };\n+#endif\n+\n     public:\n       constexpr __shared_count() noexcept : _M_pi(0)\n       { }\n@@ -727,6 +968,51 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  __p = __pi->_M_ptr();\n \t}\n \n+#if __cpp_lib_shared_ptr_arrays >= 201707L\n+      template<typename _Tp, typename _Alloc, typename _Init>\n+\t__shared_count(_Tp*& __p, const _Sp_counted_array_base<_Alloc>& __a,\n+\t\t       _Init __init)\n+\t{\n+\t  using _Up = remove_all_extents_t<_Tp>;\n+\t  static_assert(is_same_v<_Up, typename _Alloc::value_type>);\n+\n+\t  using _Sp_ca_type = _Sp_counted_array<_Alloc, _Lp>;\n+\t  const size_t __tail = _Sp_ca_type::_S_tail();\n+\n+\t  struct _Guarded_ptr : _Sp_counted_array_base<_Alloc>\n+\t  {\n+\t    typename allocator_traits<_Alloc>::pointer _M_ptr;\n+\n+\t    _Guarded_ptr(_Sp_counted_array_base<_Alloc> __a)\n+\t    : _Sp_counted_array_base<_Alloc>(__a),\n+\t      _M_ptr(this->_M_alloc_array(_Sp_ca_type::_S_tail()))\n+\t    { }\n+\n+\t    ~_Guarded_ptr()\n+\t    {\n+\t      if (_M_ptr)\n+\t\tthis->_M_dealloc_array(_M_ptr, _Sp_ca_type::_S_tail());\n+\t    }\n+\t  };\n+\n+\t  _Guarded_ptr __guard{__a};\n+\t  _Up* const __raw = std::to_address(__guard._M_ptr);\n+\t  __guard._M_init(__raw, __init); // might throw\n+\n+\t  void* __c = __raw + __a._M_n;\n+\t  if constexpr (alignof(_Up) < alignof(_Sp_ca_type))\n+\t    {\n+\t      size_t __space = sizeof(_Up) * __tail;\n+\t      __c = std::align(alignof(_Sp_ca_type), sizeof(_Sp_ca_type),\n+\t\t\t       __c, __space);\n+\t    }\n+\t  auto __pi = ::new(__c) _Sp_ca_type(__guard, __guard._M_ptr);\n+\t  __guard._M_ptr = nullptr;\n+\t  _M_pi = __pi;\n+\t  __p = reinterpret_cast<_Tp*>(__raw);\n+\t}\n+#endif\n+\n #if _GLIBCXX_USE_DEPRECATED\n #pragma GCC diagnostic push\n #pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n@@ -957,8 +1243,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_M_pi = nullptr;\n     }\n \n-#define __cpp_lib_shared_ptr_arrays 201611L\n-\n   // Helper traits for shared_ptr of array:\n \n   // A pointer type Y* is said to be compatible with a pointer type T* when\n@@ -1420,6 +1704,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tfriend __shared_ptr<_Tp1, _Lp1>\n \t__allocate_shared(const _Alloc& __a, _Args&&... __args);\n \n+#if __cpp_lib_shared_ptr_arrays >= 201707L\n+      // This constructor is non-standard, it is used by allocate_shared<T[]>.\n+      template<typename _Alloc, typename _Init = const remove_extent_t<_Tp>*>\n+\t__shared_ptr(const _Sp_counted_array_base<_Alloc>& __a,\n+\t\t     _Init __init = nullptr)\n+\t: _M_ptr(), _M_refcount(_M_ptr, __a, __init)\n+\t{ }\n+#endif\n+\n       // This constructor is used by __weak_ptr::lock() and\n       // shared_ptr::shared_ptr(const weak_ptr&, std::nothrow_t).\n       __shared_ptr(const __weak_ptr<_Tp, _Lp>& __r, std::nothrow_t) noexcept"}, {"sha": "a8b792e9b0f78e64b54f7acde62048c853a45fdf", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0b518a82db68c5cbd9ea8ccc47c2ff45182519/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0b518a82db68c5cbd9ea8ccc47c2ff45182519/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=9a0b518a82db68c5cbd9ea8ccc47c2ff45182519", "patch": "@@ -51,8 +51,10 @@\n \n #if _GLIBCXX_HOSTED\n # define __cpp_lib_allocator_traits_is_always_equal 201411\n+#if __cplusplus < 201703L // N.B. updated value in C++20\n # define __cpp_lib_shared_ptr_arrays 201611L\n #endif\n+#endif\n \n #if !defined(__STRICT_ANSI__)\n // gnu++11\n@@ -167,7 +169,7 @@\n # define __cpp_lib_scoped_lock 201703\n # define __cpp_lib_shared_mutex 201505L\n #endif\n-#define __cpp_lib_shared_ptr_weak_type 201606\n+#define __cpp_lib_shared_ptr_weak_type 201606L\n #define __cpp_lib_string_view 201803L\n #if _GLIBCXX_HAVE_USELOCALE\n # define __cpp_lib_to_chars 201611L\n@@ -275,7 +277,9 @@\n #if __cpp_lib_atomic_wait || _GLIBCXX_HAVE_POSIX_SEMAPHORE\n # define __cpp_lib_semaphore 201907L\n #endif\n+#define __cpp_lib_shared_ptr_arrays 201707L\n #define __cpp_lib_shift 201806L\n+#define __cpp_lib_smart_ptr_for_overwrite 202002L\n #if __cpp_lib_concepts\n # define __cpp_lib_span 202002L\n #endif"}, {"sha": "67069a1ec10ba53187833e2844fc7f172ee8e6d0", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/creation/99006.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0b518a82db68c5cbd9ea8ccc47c2ff45182519/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2F99006.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0b518a82db68c5cbd9ea8ccc47c2ff45182519/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2F99006.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2F99006.cc?ref=9a0b518a82db68c5cbd9ea8ccc47c2ff45182519", "patch": "@@ -1,9 +1,10 @@\n-// FIXME: This should use { target { c++11 && { ! c++20 } } }\n // { dg-do compile { target { c++11 } } }\n \n #include <memory>\n \n-auto p = std::make_shared<int[]>(2); // { dg-error \"here\" }\n+auto p = std::make_shared<int[]>(2); // { dg-error \"here\" \"\" { target c++17_down } }\n auto q = std::make_shared<int[2]>(1, 2); // { dg-error \"here\" }\n \n-// { dg-prune-output \"static assertion failed\" }\n+// { dg-prune-output \"enable_if<false\" }\n+// { dg-prune-output \"template constraint failure\" }\n+// { dg-prune-output \"no matching function\" }"}, {"sha": "cd614c0ce0a87950fab5996505b70f55120f1101", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/creation/array.cc", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0b518a82db68c5cbd9ea8ccc47c2ff45182519/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Farray.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0b518a82db68c5cbd9ea8ccc47c2ff45182519/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Farray.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Farray.cc?ref=9a0b518a82db68c5cbd9ea8ccc47c2ff45182519", "patch": "@@ -0,0 +1,224 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+// C++20 20.11.3.7 shared_ptr Creation [util.smartptr.shared.create]\n+\n+#include <memory>\n+\n+#ifndef __cpp_lib_shared_ptr_arrays\n+# error \"Feature-test macro for make_shared arrays missing in <memory>\"\n+#elif __cpp_lib_shared_ptr_arrays < 201707L\n+# error \"Feature-test macro for make_shared arrays has wrong value in <memory>\"\n+#endif\n+\n+#include <testsuite_hooks.h>\n+\n+int counter = 0;\n+\n+template<typename T>\n+struct Alloc : std::allocator<T>\n+{\n+  Alloc() = default;\n+\n+  template<typename U>\n+    Alloc(const Alloc<U>&) { }\n+\n+  T* allocate(std::size_t n)\n+  {\n+    ++counter;\n+    return std::allocator<T>::allocate(n);\n+  }\n+};\n+\n+void\n+test01()\n+{\n+  Alloc<int> a;\n+\n+  std::shared_ptr<int[]> p1 = std::allocate_shared<int[]>(a, 24);\n+  VERIFY( counter == 1 );\n+  VERIFY( p1[23] == 0 );\n+  std::shared_ptr<int[48]> p2 = std::allocate_shared<int[48]>(a);\n+  VERIFY( counter == 2 );\n+  VERIFY( p2[47] == 0 );\n+\n+  std::shared_ptr<int[][12]> p3 = std::allocate_shared<int[][12]>(a, 3);\n+  VERIFY( counter == 3 );\n+  VERIFY( p3[2][11] == 0 );\n+  std::shared_ptr<int[4][5]> p4 = std::allocate_shared<int[4][5]>(a);\n+  VERIFY( counter == 4 );\n+  VERIFY( p4[3][4] == 0 );\n+}\n+\n+void\n+test02()\n+{\n+  std::shared_ptr<int[]> p1 = std::make_shared<int[]>(24);\n+  VERIFY( p1[23] == 0 );\n+  std::shared_ptr<int[48]> p2 = std::make_shared<int[48]>();\n+  VERIFY( p2[47] == 0 );\n+\n+  std::shared_ptr<int[][12]> p3 = std::make_shared<int[][12]>(3);\n+  VERIFY( p3[2][11] == 0 );\n+  std::shared_ptr<int[4][5]> p4 = std::make_shared<int[4][5]>();\n+  VERIFY( p4[3][4] == 0 );\n+}\n+\n+#include <vector>\n+\n+std::vector<std::uintptr_t> addresses;\n+\n+void\n+test03()\n+{\n+  // Verify construction and destruction order\n+  struct Addressed\n+  {\n+    Addressed() { addresses.push_back(me()); }\n+    ~Addressed() { VERIFY( addresses.back() == me() ); addresses.pop_back(); }\n+\n+    std::uintptr_t me() const { return reinterpret_cast<std::uintptr_t>(this); }\n+  };\n+\n+  auto check = [](auto shptr) {\n+    std::uintptr_t last = 0;\n+    for (auto a : addresses)\n+    {\n+      VERIFY( a > last );\n+      last = a;\n+    }\n+    shptr.reset();\n+    return addresses.empty();\n+  };\n+\n+  VERIFY( check(std::make_shared<Addressed[][2]>(3)) );\n+  VERIFY( check(std::make_shared<Addressed[4][2]>()) );\n+}\n+\n+void\n+test04()\n+{\n+  // Verify initial value\n+  auto p1 = std::make_shared<int[]>(3, 9);\n+  VERIFY( p1[0] == 9 && p1[1] == 9 && p1[2] == 9 );\n+\n+  auto p2 = std::make_shared<int[2]>(4);\n+  VERIFY( p2[0] == 4 && p2[1] == 4 );\n+\n+  auto p3 = std::make_shared<int[][3]>(10, {1,2,3});\n+  const auto& p3_0 = p3[0];\n+  VERIFY( p3_0[0] == 1 && p3_0[1] == 2 && p3_0[2] == 3 );\n+  for (int i = 1; i < 10; ++i)\n+    for (int j = 0; j < 3; ++j)\n+      VERIFY( p3[i][j] == p3_0[j] );\n+\n+  auto p4 = std::make_shared<int[10][3]>({4,5,6});\n+  const auto& p4_0 = p4[0];\n+  VERIFY( p4_0[0] == 4 && p4_0[1] == 5 && p4_0[2] == 6 );\n+  for (int i = 1; i < 10; ++i)\n+    for (int j = 0; j < 3; ++j)\n+      VERIFY( p4[i][j] == p4_0[j] );\n+\n+  auto p5 = std::make_shared<int[][3][2]>(10, {{1,2},{3,4},{5,6}});\n+  const auto& p5_0 = p5[0];\n+  VERIFY( p5_0[0][0] == 1 && p5_0[0][1] == 2 );\n+  VERIFY( p5_0[1][0] == 3 && p5_0[1][1] == 4 );\n+  VERIFY( p5_0[2][0] == 5 && p5_0[2][1] == 6 );\n+  for (int i = 1; i < 10; ++i)\n+    for (int j = 0; j < 3; ++j)\n+      for (int k = 0; k < 2; ++k)\n+\tVERIFY( p5[i][j][k] == p5_0[j][k] );\n+\n+  auto p6 = std::make_shared<int[4][3][2]>({{7,8},{9,10},{11,12}});\n+  const auto& p6_0 = p6[0];\n+  VERIFY( p6_0[0][0] ==  7 && p6_0[0][1] ==  8 );\n+  VERIFY( p6_0[1][0] ==  9 && p6_0[1][1] == 10 );\n+  VERIFY( p6_0[2][0] == 11 && p6_0[2][1] == 12 );\n+  for (int i = 1; i < 4; ++i)\n+    for (int j = 0; j < 3; ++j)\n+      for (int k = 0; k < 2; ++k)\n+\tVERIFY( p6[i][j][k] == p6_0[j][k] );\n+}\n+\n+void\n+test05()\n+{\n+  // Examples from the standard\n+  using namespace std;\n+\n+  // Example 2\n+  {\n+    shared_ptr<double[]> p = make_shared<double[]>(1024);\n+    // shared_ptr to a value-initialized double[1024]\n+    for (int i = 0; i < 1024; ++i)\n+      VERIFY( p[i] == 0.0 );\n+\n+    shared_ptr<double[][2][2]> q = make_shared<double[][2][2]>(6);\n+    // shared_ptr to a value-initialized double[6][2][2]\n+    for (int i = 0; i < 6; ++i)\n+      for (auto& j : q[i])\n+\tfor (auto& k : j)\n+\t  VERIFY( k == 0.0 );\n+  }\n+\n+  // Example 3\n+  {\n+    shared_ptr<double[1024]> p = make_shared<double[1024]>();\n+    // shared_ptr to a value-initialized double[1024]\n+    for (int i = 0; i < 1024; ++i)\n+      VERIFY( p[i] == 0.0 );\n+\n+    shared_ptr<double[6][2][2]> q = make_shared<double[6][2][2]>();\n+    // shared_ptr to a value-initialized double[6][2][2]\n+    for (int i = 0; i < 6; ++i)\n+      for (auto& j : q[i])\n+\tfor (auto& k : j)\n+\t  VERIFY( k == 0.0 );\n+  }\n+\n+  // Example 4\n+  {\n+    shared_ptr<double[]> p = make_shared<double[]>(1024, 1.0);\n+    // shared_ptr to a double[1024], where each element is 1.0\n+    for (int i = 0; i < 1024; ++i)\n+      VERIFY( p[i] == 1.0 );\n+\n+    shared_ptr<double[][2]> q = make_shared<double[][2]>(6, {1.0, 0.0});\n+    // shared_ptr to a double[6][2], where each double[2] element is {1.0, 0.0}\n+    for (int i = 0; i < 6; ++i)\n+      VERIFY( q[i][0] == 1.0 && q[i][1] == 0.0 );\n+\n+    shared_ptr<vector<int>[]> r = make_shared<vector<int>[]>(4, {1, 2});\n+    // shared_ptr to a vector<int>[4], where each vector has contents {1, 2}\n+    for (int i = 0; i < 4; ++i)\n+      VERIFY( r[i] == vector<int>({1, 2}) );\n+  }\n+\n+  // Example 5\n+  {\n+    shared_ptr<double[1024]> p = make_shared<double[1024]>(1.0);\n+    // shared_ptr to a double[1024], where each element is 1.0\n+    for (int i = 0; i < 1024; ++i)\n+      VERIFY( p[i] == 1.0 );\n+\n+    shared_ptr<double[6][2]> q = make_shared<double[6][2]>({1.0, 0.0});\n+    // shared_ptr to a double[6][2], where each double[2] element is {1.0, 0.0}\n+    for (int i = 0; i < 6; ++i)\n+      VERIFY( q[i][0] == 1.0 && q[i][1] == 0.0 );\n+\n+    shared_ptr<vector<int>[4]> r = make_shared<vector<int>[4]>({1, 2});\n+    // shared_ptr to a vector<int>[4], where each vector has contents {1, 2}\n+    for (int i = 0; i < 4; ++i)\n+      VERIFY( r[i] == vector<int>({1, 2}) );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+}"}, {"sha": "f207fdee0974a3e78669c5198cc8d80156a1da9c", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/creation/overwrite.cc", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0b518a82db68c5cbd9ea8ccc47c2ff45182519/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Foverwrite.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0b518a82db68c5cbd9ea8ccc47c2ff45182519/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Foverwrite.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Foverwrite.cc?ref=9a0b518a82db68c5cbd9ea8ccc47c2ff45182519", "patch": "@@ -0,0 +1,143 @@\n+// { dg-options \"-std=gnu++20 -fno-lifetime-dse -O0\" }\n+// { dg-do run { target c++20 } }\n+\n+// C++20 20.11.3.7 shared_ptr Creation [util.smartptr.shared.create]\n+\n+#include <memory>\n+\n+#ifndef __cpp_lib_smart_ptr_for_overwrite\n+# error \"Feature-test macro for make_shared_for_overwrite missing in <memory>\"\n+#elif __cpp_lib_smart_ptr_for_overwrite < 202002L\n+# error \"Feature-test macro for make_shared_for_overwrite has wrong value in <memory>\"\n+#endif\n+\n+#include <cstring>\n+#include <testsuite_hooks.h>\n+\n+int counter = 0;\n+\n+template<typename T>\n+struct Alloc : std::allocator<T>\n+{\n+  Alloc() = default;\n+\n+  template<typename U>\n+    Alloc(const Alloc<U>&) { }\n+\n+  T* allocate(std::size_t n)\n+  {\n+    ++counter;\n+    void* p = std::allocator<T>::allocate(n);\n+    // need -fno-lifetime-dse to check for these values later.\n+    std::memset(p, 0xff, n * sizeof(T));\n+    return (T*)p;\n+  }\n+\n+  void construct(auto*, auto&&...)\n+  {\n+    // The objects must be default-initialized, not using this function.\n+    VERIFY( ! \"allocator_traits::construct\" );\n+  }\n+\n+  void destroy(auto*)\n+  {\n+    // The objects must be destroyed by ~T(), not using this function.\n+    VERIFY( ! \"allocator_traits::destroy\" );\n+  }\n+};\n+\n+void\n+test01()\n+{\n+  Alloc<int> a;\n+  const int expected = 0xffffffff;\n+\n+  std::shared_ptr<int> p1 = std::allocate_shared_for_overwrite<int>(a);\n+  VERIFY( counter == 1 );\n+  VERIFY( *p1 == expected );\n+  std::shared_ptr<int[44]> p2 = std::allocate_shared_for_overwrite<int[44]>(a);\n+  VERIFY( counter == 2 );\n+  VERIFY( p2[0] == expected );\n+  p2.reset();\n+  std::shared_ptr<int[]> p3 = std::allocate_shared_for_overwrite<int[]>(a, 88);\n+  VERIFY( counter == 3 );\n+  VERIFY( p3[0] == expected );\n+  VERIFY( p3[87] == expected );\n+  std::shared_ptr<int[3][4]> p4 = std::allocate_shared_for_overwrite<int[3][4]>(a);\n+  VERIFY( counter == 4 );\n+  VERIFY( p4[0][0] == expected );\n+  VERIFY( p4[2][3] == expected );\n+  std::shared_ptr<int[][5]> p5 = std::allocate_shared_for_overwrite<int[][5]>(a, 6);\n+  VERIFY( counter == 5 );\n+  VERIFY( p5[0][0] == expected );\n+  VERIFY( p5[5][4] == expected );\n+\n+  struct BigBoi { int x[100]; };\n+  std::shared_ptr<BigBoi> p6 = std::allocate_shared_for_overwrite<BigBoi>(a);\n+  VERIFY( counter == 6 );\n+  VERIFY( p6->x[0] == expected );\n+  std::shared_ptr<BigBoi[22]> p7 = std::allocate_shared_for_overwrite<BigBoi[22]>(a);\n+  VERIFY( counter == 7 );\n+  VERIFY( p7[0].x[0] == expected );\n+  VERIFY( p7[21].x[99] == expected );\n+  std::shared_ptr<BigBoi[]> p8 = std::allocate_shared_for_overwrite<BigBoi[]>(a, 11);\n+  VERIFY( counter == 8 );\n+  VERIFY( p8[0].x[0] == expected );\n+  VERIFY( p8[10].x[10] == expected );\n+}\n+\n+void\n+test02()\n+{\n+  // These aren't created by the custom allocator, so we can't check that the\n+  // memory was left uninitialized. Just dereference them.\n+\n+  std::shared_ptr<int> p1 = std::make_shared_for_overwrite<int>();\n+  (void) *p1;\n+  std::shared_ptr<int[44]> p2 = std::make_shared_for_overwrite<int[44]>();\n+  (void) p2[0];\n+  std::shared_ptr<int[]> p3 = std::make_shared_for_overwrite<int[]>(88);\n+  (void) p3[0];\n+  (void) p3[87];\n+  std::shared_ptr<int[3][4]> p4 = std::make_shared_for_overwrite<int[3][4]>();\n+  (void) p4[0][0];\n+  (void) p4[2][3];\n+  std::shared_ptr<int[][5]> p5 = std::make_shared_for_overwrite<int[][5]>(6);\n+  (void) p5[0][0];\n+  (void) p5[5][4];\n+\n+  struct BigBoi { int x[100]; };\n+  std::shared_ptr<BigBoi> p6 = std::make_shared_for_overwrite<BigBoi>();\n+  (void) p6->x[0];\n+  std::shared_ptr<BigBoi[22]> p7 = std::make_shared_for_overwrite<BigBoi[22]>();\n+  (void) p7[0].x[0];\n+  (void) p7[21].x[99];\n+  std::shared_ptr<BigBoi[]> p8 = std::make_shared_for_overwrite<BigBoi[]>(11);\n+  (void) p8[0].x[0];\n+  (void) p8[10].x[10];\n+}\n+\n+void\n+test03()\n+{\n+  // Type with non-trivial initialization should still be default-initialized.\n+  struct NonTriv\n+  {\n+    int init = 0xbb;\n+    int uninit;\n+  };\n+  std::shared_ptr<NonTriv> a = std::make_shared_for_overwrite<NonTriv>();\n+  VERIFY( a->init == 0xbb );\n+  std::shared_ptr<NonTriv[]> b = std::make_shared_for_overwrite<NonTriv[2]>();\n+  VERIFY( b[1].init == 0xbb );\n+  std::shared_ptr<NonTriv[]> c = std::make_shared_for_overwrite<NonTriv[]>(2);\n+  VERIFY( c[1].init == 0xbb );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "0e47f19061d4a81dcef09af9a79c3f77cd5acc52", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/creation/version.cc", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0b518a82db68c5cbd9ea8ccc47c2ff45182519/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Fversion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0b518a82db68c5cbd9ea8ccc47c2ff45182519/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Fversion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Fversion.cc?ref=9a0b518a82db68c5cbd9ea8ccc47c2ff45182519", "patch": "@@ -0,0 +1,18 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do preprocess { target c++20 } }\n+\n+// C++20 20.11.3.7 shared_ptr Creation [util.smartptr.shared.create]\n+\n+#include <version>\n+\n+#ifndef __cpp_lib_shared_ptr_arrays\n+# error \"Feature-test macro for make_shared arrays missing in <version>\"\n+#elif __cpp_lib_shared_ptr_arrays < 201707L\n+# error \"Feature-test macro for make_shared arrays has wrong value in <version>\"\n+#endif\n+\n+#ifndef __cpp_lib_smart_ptr_for_overwrite\n+# error \"Feature-test macro for make_shared_for_overwrite missing in <version>\"\n+#elif __cpp_lib_smart_ptr_for_overwrite < 202002L\n+# error \"Feature-test macro for make_shared_for_overwrite has wrong value in <version>\"\n+#endif"}, {"sha": "f736c762a436724735d7edae01b5df911ed9e370", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/creation/for_overwrite.cc", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0b518a82db68c5cbd9ea8ccc47c2ff45182519/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcreation%2Ffor_overwrite.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0b518a82db68c5cbd9ea8ccc47c2ff45182519/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcreation%2Ffor_overwrite.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcreation%2Ffor_overwrite.cc?ref=9a0b518a82db68c5cbd9ea8ccc47c2ff45182519", "patch": "@@ -1,4 +1,4 @@\n-// { dg-options \"-std=gnu++20\" }\n+// { dg-options \"-std=gnu++20 -fno-lifetime-dse -O0\" }\n // { dg-do run { target c++2a } }\n // { dg-xfail-run-if \"AIX operator new\" { powerpc-ibm-aix* } }\n \n@@ -22,6 +22,13 @@\n // C++20 20.11.1.5 unique_ptr creation [unique.ptr.create]\n \n #include <memory>\n+\n+#ifndef __cpp_lib_smart_ptr_for_overwrite\n+# error \"Feature-test macro for make_unique_for_overwrite missing in <memory>\"\n+#elif __cpp_lib_smart_ptr_for_overwrite < 202002L\n+# error \"Feature-test macro for make_unique_for_overwrite has wrong value in <memory>\"\n+#endif\n+\n #include <cstdlib>\n #include <cstring>\n #include <testsuite_hooks.h>\n@@ -58,9 +65,25 @@ test02()\n     VERIFY( c == 0xaa );\n }\n \n+void\n+test03()\n+{\n+  // Type with non-trivial initialization should still be default-initialized.\n+  struct NonTriv\n+  {\n+    int init = 0xbb;\n+    int uninit;\n+  };\n+  std::unique_ptr<NonTriv> a = std::make_unique_for_overwrite<NonTriv>();\n+  VERIFY( a->init == 0xbb );\n+  std::unique_ptr<NonTriv[]> b = std::make_unique_for_overwrite<NonTriv[]>(2);\n+  VERIFY( b[1].init == 0xbb );\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n+  test03();\n }"}]}