{"sha": "7bd5dad24907ba68a81365932d442d40460e4ed0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JkNWRhZDI0OTA3YmE2OGE4MTM2NTkzMmQ0NDJkNDA0NjBlNGVkMA==", "commit": {"author": {"name": "Louis Krupp", "email": "louis.krupp@zoho.com", "date": "2017-01-18T21:41:48Z"}, "committer": {"name": "Louis Krupp", "email": "lkrupp@gcc.gnu.org", "date": "2017-01-18T21:41:48Z"}, "message": "re PR fortran/50069 (FORALL fails on a character array)\n\n2017-01-18  Louis Krupp  <louis.krupp@zoho.com>\n\n\tPR fortran/50069\n\tPR fortran/55086\n\t* gfortran.dg/pr50069_1.f90: New test.\n\t* gfortran.dg/pr50069_2.f90: New test.\n\t* gfortran.dg/pr55086_1.f90: New test.\n\t* gfortran.dg/pr55086_1_tfat.f90: New test.\n\t* gfortran.dg/pr55086_2.f90: New test.\n\t* gfortran.dg/pr55086_2_tfat.f90: New test.\n\t* gfortran.dg/pr55086_aliasing_dummy_4_tfat.f90: New test.\n\n2017-01-18  Louis Krupp  <louis.krupp@zoho.com>\n\n\tPR fortran/50069\n\tPR fortran/55086\n\t* trans-expr.c (gfc_conv_variable): Don't treat temporary variables\n\tas function arguments.\n\t* trans-stmt.c (forall_make_variable_temp,\n\tgenerate_loop_for_temp_to_lhs, gfc_trans_assign_need_temp,\n\tgfc_trans_forall_1): Don't adjust offset of forall temporary\n\tfor array sections, make forall temporaries work for substring\n\texpressions, improve test coverage by adding -ftest-forall-temp\n\toption to request usage of temporary array in forall code.\n\t* lang.opt: Add -ftest-forall-temp option.\n\t* invoke.texi: Add -ftest-forall-temp option.\n\nFrom-SVN: r244601", "tree": {"sha": "f3c2d51177dd1d7a3ef318c7e91d16919ecfdf48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3c2d51177dd1d7a3ef318c7e91d16919ecfdf48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7bd5dad24907ba68a81365932d442d40460e4ed0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bd5dad24907ba68a81365932d442d40460e4ed0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bd5dad24907ba68a81365932d442d40460e4ed0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bd5dad24907ba68a81365932d442d40460e4ed0/comments", "author": null, "committer": null, "parents": [{"sha": "b37589b0c4c23db8e9f1d4825998aea18125435a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b37589b0c4c23db8e9f1d4825998aea18125435a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b37589b0c4c23db8e9f1d4825998aea18125435a"}], "stats": {"total": 492, "additions": 398, "deletions": 94}, "files": [{"sha": "17c419f4ff9e10a0cf8fc66ce1f220d51382b46c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7bd5dad24907ba68a81365932d442d40460e4ed0", "patch": "@@ -1,3 +1,18 @@\n+2017-01-18  Louis Krupp  <louis.krupp@zoho.com>\n+\n+\tPR fortran/50069\n+\tPR fortran/55086\n+\t* trans-expr.c (gfc_conv_variable): Don't treat temporary variables\n+\tas function arguments.\n+\t* trans-stmt.c (forall_make_variable_temp,\n+\tgenerate_loop_for_temp_to_lhs, gfc_trans_assign_need_temp,\n+\tgfc_trans_forall_1): Don't adjust offset of forall temporary\n+\tfor array sections, make forall temporaries work for substring\n+\texpressions, improve test coverage by adding -ftest-forall-temp\n+\toption to request usage of temporary array in forall code.\n+\t* lang.opt: Add -ftest-forall-temp option.\n+\t* invoke.texi: Add -ftest-forall-temp option.\n+\n 2017-01-18  Andre Vehreschild  <vehre@gcc.gnu.org>\n \n \t* primary.c (caf_variable_attr): Improve figuring whether the current"}, {"sha": "2a89647f9f0c094ee202625729f238407f814bc3", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=7bd5dad24907ba68a81365932d442d40460e4ed0", "patch": "@@ -124,6 +124,7 @@ by type.  Explanations are in the following sections.\n -fmax-identifier-length -fmodule-private -ffixed-form -fno-range-check @gol\n -fopenacc -fopenmp -freal-4-real-10 -freal-4-real-16 -freal-4-real-8 @gol\n -freal-8-real-10 -freal-8-real-16 -freal-8-real-4 -std=@var{std}\n+-ftest-forall-temp\n }\n \n @item Preprocessing Options\n@@ -459,6 +460,10 @@ allows the Fortran 2008 standard including the additions of the\n Technical Specification (TS) 29113 on Further Interoperability of Fortran\n with C and TS 18508 on Additional Parallel Features in Fortran.\n \n+@item -ftest-forall-temp\n+@opindex @code{ftest-forall-temp}\n+Enhance test coverage by forcing most forall assignments to use temporary.\n+\n @end table\n \n @node Preprocessing Options"}, {"sha": "bdc621b3d5493ce35a18227f5da6cd6519b43a54", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=7bd5dad24907ba68a81365932d442d40460e4ed0", "patch": "@@ -488,6 +488,10 @@ ffixed-form\n Fortran RejectNegative\n Assume that the source file is fixed form.\n \n+ftest-forall-temp\n+Fortran Var(flag_test_forall_temp) Init(0)\n+Force creation of temporary to test infrequently-executed forall code\n+\n finteger-4-integer-8\n Fortran RejectNegative Var(flag_integer4_kind,8)\n Interpret any INTEGER(4) as an INTEGER(8)."}, {"sha": "138af56e5d3d4b28be7479976cd7b461d36df9e7", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=7bd5dad24907ba68a81365932d442d40460e4ed0", "patch": "@@ -2544,8 +2544,10 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n       if (se_expr)\n \tse->expr = se_expr;\n \n-      /* Procedure actual arguments.  */\n-      else if (sym->attr.flavor == FL_PROCEDURE\n+      /* Procedure actual arguments.  Look out for temporary variables\n+\t with the same attributes as function values.  */\n+      else if (!sym->attr.temporary\n+\t       && sym->attr.flavor == FL_PROCEDURE\n \t       && se->expr != current_function_decl)\n \t{\n \t  if (!sym->attr.dummy && !sym->attr.proc_pointer)"}, {"sha": "113545b85546d083d8e09cdad7e123a4a3d8db6b", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 106, "deletions": 92, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=7bd5dad24907ba68a81365932d442d40460e4ed0", "patch": "@@ -3196,7 +3196,7 @@ forall_make_variable_temp (gfc_code *c, stmtblock_t *pre, stmtblock_t *post)\n       gfc_add_block_to_block (post, &tse.post);\n       tse.expr = build_fold_indirect_ref_loc (input_location, tse.expr);\n \n-      if (e->ts.type != BT_CHARACTER)\n+      if (c->expr1->ref->u.ar.type != AR_SECTION)\n \t{\n \t  /* Use the variable offset for the temporary.  */\n \t  tmp = gfc_conv_array_offset (old_sym->backend_decl);\n@@ -3526,114 +3526,103 @@ gfc_do_allocate (tree bytesize, tree size, tree * pdata, stmtblock_t * pblock,\n \n static tree\n generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree count3,\n-\t\t\t       tree count1, tree wheremask, bool invert)\n+\t\t\t       tree count1,\n+\t\t\t       gfc_ss *lss, gfc_ss *rss,\n+\t\t\t       tree wheremask, bool invert)\n {\n-  gfc_ss *lss;\n-  gfc_se lse, rse;\n-  stmtblock_t block, body;\n-  gfc_loopinfo loop1;\n+  stmtblock_t block, body1;\n+  gfc_loopinfo loop;\n+  gfc_se lse;\n+  gfc_se rse;\n   tree tmp;\n   tree wheremaskexpr;\n \n-  /* Walk the lhs.  */\n-  lss = gfc_walk_expr (expr);\n+  (void) rss; /* TODO: unused.  */\n \n-  if (lss == gfc_ss_terminator)\n-    {\n-      gfc_start_block (&block);\n+  gfc_start_block (&block);\n \n-      gfc_init_se (&lse, NULL);\n+  gfc_init_se (&rse, NULL);\n+  gfc_init_se (&lse, NULL);\n \n-      /* Translate the expression.  */\n+  if (lss == gfc_ss_terminator)\n+    {\n+      gfc_init_block (&body1);\n       gfc_conv_expr (&lse, expr);\n-\n-      /* Form the expression for the temporary.  */\n-      tmp = gfc_build_array_ref (tmp1, count1, NULL);\n-\n-      /* Use the scalar assignment as is.  */\n-      gfc_add_block_to_block (&block, &lse.pre);\n-      gfc_add_modify (&block, lse.expr, tmp);\n-      gfc_add_block_to_block (&block, &lse.post);\n-\n-      /* Increment the count1.  */\n-      tmp = fold_build2_loc (input_location, PLUS_EXPR, TREE_TYPE (count1),\n-\t\t\t     count1, gfc_index_one_node);\n-      gfc_add_modify (&block, count1, tmp);\n-\n-      tmp = gfc_finish_block (&block);\n+      rse.expr = gfc_build_array_ref (tmp1, count1, NULL);\n     }\n   else\n     {\n-      gfc_start_block (&block);\n-\n-      gfc_init_loopinfo (&loop1);\n-      gfc_init_se (&rse, NULL);\n-      gfc_init_se (&lse, NULL);\n+      /* Initialize the loop.  */\n+      gfc_init_loopinfo (&loop);\n \n-      /* Associate the lss with the loop.  */\n-      gfc_add_ss_to_loop (&loop1, lss);\n+      /* We may need LSS to determine the shape of the expression.  */\n+      gfc_add_ss_to_loop (&loop, lss);\n \n-      /* Calculate the bounds of the scalarization.  */\n-      gfc_conv_ss_startstride (&loop1);\n-      /* Setup the scalarizing loops.  */\n-      gfc_conv_loop_setup (&loop1, &expr->where);\n+      gfc_conv_ss_startstride (&loop);\n+      gfc_conv_loop_setup (&loop, &expr->where);\n \n       gfc_mark_ss_chain_used (lss, 1);\n+      /* Start the loop body.  */\n+      gfc_start_scalarized_body (&loop, &body1);\n \n-      /* Start the scalarized loop body.  */\n-      gfc_start_scalarized_body (&loop1, &body);\n-\n-      /* Setup the gfc_se structures.  */\n-      gfc_copy_loopinfo_to_se (&lse, &loop1);\n+      /* Translate the expression.  */\n+      gfc_copy_loopinfo_to_se (&lse, &loop);\n       lse.ss = lss;\n+      gfc_conv_expr (&lse, expr);\n \n       /* Form the expression of the temporary.  */\n-      if (lss != gfc_ss_terminator)\n-\trse.expr = gfc_build_array_ref (tmp1, count1, NULL);\n-      /* Translate expr.  */\n-      gfc_conv_expr (&lse, expr);\n+      rse.expr = gfc_build_array_ref (tmp1, count1, NULL);\n+    }\n \n-      /* Use the scalar assignment.  */\n-      rse.string_length = lse.string_length;\n-      tmp = gfc_trans_scalar_assign (&lse, &rse, expr->ts, true, true);\n+  /* Use the scalar assignment.  */\n+  rse.string_length = lse.string_length;\n+  tmp = gfc_trans_scalar_assign (&lse, &rse, expr->ts,\n+\t\t\t\t expr->expr_type == EXPR_VARIABLE, false);\n \n-      /* Form the mask expression according to the mask tree list.  */\n-      if (wheremask)\n-\t{\n-\t  wheremaskexpr = gfc_build_array_ref (wheremask, count3, NULL);\n-\t  if (invert)\n-\t    wheremaskexpr = fold_build1_loc (input_location, TRUTH_NOT_EXPR,\n-\t\t\t\t\t     TREE_TYPE (wheremaskexpr),\n-\t\t\t\t\t     wheremaskexpr);\n-\t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n-\t\t\t\t wheremaskexpr, tmp,\n-\t\t\t\t build_empty_stmt (input_location));\n-       }\n+  /* Form the mask expression according to the mask tree list.  */\n+  if (wheremask)\n+    {\n+      wheremaskexpr = gfc_build_array_ref (wheremask, count3, NULL);\n+      if (invert)\n+\twheremaskexpr = fold_build1_loc (input_location, TRUTH_NOT_EXPR,\n+\t\t\t\t\t TREE_TYPE (wheremaskexpr),\n+\t\t\t\t\t wheremaskexpr);\n+      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t     wheremaskexpr, tmp,\n+\t\t\t     build_empty_stmt (input_location));\n+    }\n \n-      gfc_add_expr_to_block (&body, tmp);\n+  gfc_add_expr_to_block (&body1, tmp);\n \n-      /* Increment count1.  */\n-      tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n-\t\t\t     count1, gfc_index_one_node);\n-      gfc_add_modify (&body, count1, tmp);\n+  tmp = fold_build2_loc (input_location, PLUS_EXPR, TREE_TYPE (count1),\n+\t\t\t count1, gfc_index_one_node);\n+  gfc_add_modify (&body1, count1, tmp);\n \n+  if (lss == gfc_ss_terminator)\n+      gfc_add_block_to_block (&block, &body1);\n+  else\n+    {\n       /* Increment count3.  */\n       if (count3)\n \t{\n \t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t\t gfc_array_index_type, count3,\n-\t\t\t\t gfc_index_one_node);\n-\t  gfc_add_modify (&body, count3, tmp);\n+\t\t\t\t gfc_array_index_type,\n+\t\t\t\t count3, gfc_index_one_node);\n+\t  gfc_add_modify (&body1, count3, tmp);\n \t}\n \n       /* Generate the copying loops.  */\n-      gfc_trans_scalarizing_loops (&loop1, &body);\n-      gfc_add_block_to_block (&block, &loop1.pre);\n-      gfc_add_block_to_block (&block, &loop1.post);\n-      gfc_cleanup_loop (&loop1);\n+      gfc_trans_scalarizing_loops (&loop, &body1);\n+\n+      gfc_add_block_to_block (&block, &loop.pre);\n+      gfc_add_block_to_block (&block, &loop.post);\n \n-      tmp = gfc_finish_block (&block);\n+      gfc_cleanup_loop (&loop);\n+      /* TODO: Reuse lss and rss when copying temp->lhs.  Need to be careful\n+\t as tree nodes in SS may not be valid in different scope.  */\n     }\n+\n+  tmp = gfc_finish_block (&block);\n   return tmp;\n }\n \n@@ -3989,26 +3978,39 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n \n   /* Calculate the size of temporary needed in the assignment. Return loop, lss\n      and rss which are used in function generate_loop_for_rhs_to_temp().  */\n-  gfc_init_block (&inner_size_body);\n-  inner_size = compute_inner_temp_size (expr1, expr2, &inner_size_body,\n-\t\t\t\t\t&lss, &rss);\n-\n   /* The type of LHS. Used in function allocate_temp_for_forall_nest */\n-  if (expr1->ts.type == BT_CHARACTER && expr1->ts.u.cl->length)\n+  if (expr1->ts.type == BT_CHARACTER)\n     {\n-      if (!expr1->ts.u.cl->backend_decl)\n+      type = NULL;\n+      if (expr1->ref && expr1->ref->type == REF_SUBSTRING)\n \t{\n-\t  gfc_se tse;\n-\t  gfc_init_se (&tse, NULL);\n-\t  gfc_conv_expr (&tse, expr1->ts.u.cl->length);\n-\t  expr1->ts.u.cl->backend_decl = tse.expr;\n+\t  gfc_se ssse;\n+\t  gfc_init_se (&ssse, NULL);\n+\t  gfc_conv_expr (&ssse, expr1);\n+\t  type = gfc_get_character_type_len (gfc_default_character_kind,\n+\t\t\t\t\t     ssse.string_length);\n+\t}\n+      else\n+\t{\n+\t  if (!expr1->ts.u.cl->backend_decl)\n+\t    {\n+\t      gfc_se tse;\n+\t      gcc_assert (expr1->ts.u.cl->length);\n+\t      gfc_init_se (&tse, NULL);\n+\t      gfc_conv_expr (&tse, expr1->ts.u.cl->length);\n+\t      expr1->ts.u.cl->backend_decl = tse.expr;\n+\t    }\n+\t  type = gfc_get_character_type_len (gfc_default_character_kind,\n+\t\t\t\t\t     expr1->ts.u.cl->backend_decl);\n \t}\n-      type = gfc_get_character_type_len (gfc_default_character_kind,\n-\t\t\t\t         expr1->ts.u.cl->backend_decl);\n     }\n   else\n     type = gfc_typenode_for_spec (&expr1->ts);\n \n+  gfc_init_block (&inner_size_body);\n+  inner_size = compute_inner_temp_size (expr1, expr2, &inner_size_body,\n+\t\t\t\t\t&lss, &rss);\n+\n   /* Allocate temporary for nested forall construct according to the\n      information in nested_forall_info and inner_size.  */\n   tmp1 = allocate_temp_for_forall_nest (nested_forall_info, type, inner_size,\n@@ -4030,8 +4032,14 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n   if (wheremask)\n     gfc_add_modify (block, count, gfc_index_zero_node);\n \n+  /* TODO: Second call to compute_inner_temp_size to initialize lss and\n+     rss;  there must be a better way.  */\n+  inner_size = compute_inner_temp_size (expr1, expr2, &inner_size_body,\n+\t\t\t\t\t&lss, &rss);\n+\n   /* Generate codes to copy the temporary to lhs.  */\n   tmp = generate_loop_for_temp_to_lhs (expr1, tmp1, count, count1,\n+\t\t\t\t       lss, rss,\n \t\t\t\t       wheremask, invert);\n \n   /* Generate body and loops according to the information in\n@@ -4488,8 +4496,8 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n \n           /* Temporaries due to array assignment data dependencies introduce\n              no end of problems.  */\n-\t  if (need_temp)\n-            gfc_trans_assign_need_temp (c->expr1, c->expr2, NULL, false,\n+\t  if (need_temp || flag_test_forall_temp)\n+\t    gfc_trans_assign_need_temp (c->expr1, c->expr2, NULL, false,\n                                         nested_forall_info, &block);\n           else\n             {\n@@ -4517,7 +4525,12 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n         /* Pointer assignment inside FORALL.  */\n \tcase EXEC_POINTER_ASSIGN:\n           need_temp = gfc_check_dependency (c->expr1, c->expr2, 0);\n-          if (need_temp)\n+\t  /* Avoid cases where a temporary would never be needed and where\n+\t     the temp code is guaranteed to fail.  */\n+\t  if (need_temp\n+\t      || (flag_test_forall_temp\n+\t\t  && c->expr2->expr_type != EXPR_CONSTANT\n+\t\t  && c->expr2->expr_type != EXPR_NULL))\n             gfc_trans_pointer_assign_need_temp (c->expr1, c->expr2,\n                                                 nested_forall_info, &block);\n           else\n@@ -5125,7 +5138,8 @@ gfc_trans_where_2 (gfc_code * code, tree mask, bool invert,\n               if (nested_forall_info != NULL)\n                 {\n                   need_temp = gfc_check_dependency (expr1, expr2, 0);\n-                  if (need_temp && cnext->op != EXEC_ASSIGN_CALL)\n+\t\t  if ((need_temp || flag_test_forall_temp)\n+\t\t    && cnext->op != EXEC_ASSIGN_CALL)\n                     gfc_trans_assign_need_temp (expr1, expr2,\n \t\t\t\t\t\tcmask, invert,\n                                                 nested_forall_info, block);"}, {"sha": "9cd63f3057d38759641a75ec6b5ba52bbbb65519", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7bd5dad24907ba68a81365932d442d40460e4ed0", "patch": "@@ -1,3 +1,15 @@\n+2017-01-18  Louis Krupp  <louis.krupp@zoho.com>\n+\n+\tPR fortran/50069\n+\tPR fortran/55086\n+\t* gfortran.dg/pr50069_1.f90: New test.\n+\t* gfortran.dg/pr50069_2.f90: New test.\n+\t* gfortran.dg/pr55086_1.f90: New test.\n+\t* gfortran.dg/pr55086_1_tfat.f90: New test.\n+\t* gfortran.dg/pr55086_2.f90: New test.\n+\t* gfortran.dg/pr55086_2_tfat.f90: New test.\n+\t* gfortran.dg/pr55086_aliasing_dummy_4_tfat.f90: New test.\n+\n 2017-01-18  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n \t* gcc.dg/strcmp-1.c: New test.\n \t* gcc.dg/strncmp-1.c: Add test for a bug that escaped."}, {"sha": "74890fad6c408f17ad850a506fa081b556f333d4", "filename": "gcc/testsuite/gfortran.dg/pr50069_1.f90", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr50069_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr50069_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr50069_1.f90?ref=7bd5dad24907ba68a81365932d442d40460e4ed0", "patch": "@@ -0,0 +1,9 @@\n+! { dg-do run }\n+\n+  implicit none\n+  integer i\n+  character(LEN=6) :: a(1) = \"123456\"\n+  forall (i = 3:4) a(1)(i:i+2) = a(1)(i-2:i)\n+  !print *,a ! displays '12@' must be '121234'\n+  IF (a(1) .ne. \"121234\") call abort\n+end"}, {"sha": "a5046d47630ddce9db5619b0566d4d9034f3a118", "filename": "gcc/testsuite/gfortran.dg/pr50069_2.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr50069_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr50069_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr50069_2.f90?ref=7bd5dad24907ba68a81365932d442d40460e4ed0", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+\n+function reverse(string)\n+implicit none\n+character(len=*), intent(in) :: string\n+character(len=:),allocatable :: reverse\n+integer i\n+reverse = string\n+forall (i=1:len(reverse)) reverse(i:i) = &\n+  reverse(len(reverse)-i+1:len(reverse)-i+1)\n+end function reverse"}, {"sha": "52306d56312d069c3db4fd53e57adf6f76b066e4", "filename": "gcc/testsuite/gfortran.dg/pr55086_1.f90", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr55086_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr55086_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr55086_1.f90?ref=7bd5dad24907ba68a81365932d442d40460e4ed0", "patch": "@@ -0,0 +1,63 @@\n+! { dg-do run }\n+!\n+  implicit none\n+  character(len=5), pointer :: a(:), b(:)\n+  character(len=5), pointer :: c, d\n+  allocate (a(2), b(2), c, d)\n+  a = [ \"abcde\", \"ABCDE\" ]\n+  call aloct_pointer_copy_4 (b, a)\n+  !print *, b(1)\n+  !print *, b(2)\n+  if (any (a /= b)) stop 'WRONG'\n+\n+  call aloct_copy_4 (b, a)\n+  !print *, b(1)\n+  !print *, b(2)\n+  if (any (a /= b)) stop 'WRONG'\n+\n+  d = '12345'\n+  c = \"abcde\"\n+  call test2 (d, c)\n+  !print *, d\n+  if (d /= '1cb15') stop 'WRONG'\n+\n+  call test2p (d, c)\n+  !print *, d\n+  if (d /= '1cb15') stop 'WRONG'\n+\n+contains\n+ subroutine aloct_pointer_copy_4(o, i)\n+  character(len=*), pointer :: o(:), i(:)\n+  integer :: nl1, nu1\n+  integer :: i1\n+  nl1 = lbound(i,dim=1)\n+  nu1 = ubound(i,dim=1)\n+  forall (i1 = nl1:nu1) o(i1) = i(i1)\n+ end subroutine aloct_pointer_copy_4\n+ subroutine aloct_copy_4(o, i)\n+  character(len=*), pointer :: o(:), i(:)\n+  integer :: nl1, nu1\n+  integer :: i1\n+  nl1 = lbound(i,dim=1)\n+  nu1 = ubound(i,dim=1)\n+  forall (i1 = nl1:nu1) o(i1) = i(i1)\n+ end subroutine aloct_copy_4\n+ subroutine test2(o, i)\n+  character(len=*) :: o, i\n+  integer :: nl1, nu1\n+  integer :: i1\n+  nl1 = 2\n+  nu1 = 4\n+  forall (i1 = nl1:nu1) o(i1:i1) = i(i1:i1)\n+  forall (i1 = nl1:nu1) o(i1:i1) = o(nu1+1-i1:nu1+1-i1)\n+ end subroutine test2\n+ subroutine test2p(o, i)\n+  character(len=*), pointer :: o, i\n+  integer :: nl1, nu1\n+  integer :: i1\n+  nl1 = 2\n+  nu1 = 4\n+  forall (i1 = nl1:nu1) o(i1:i1) = i(i1:i1)   ! <<<< ICE\n+  forall (i1 = nl1:nu1) o(i1:i1) = o(nu1+1-i1:nu1+1-i1)\n+ end subroutine test2p\n+end"}, {"sha": "45f6e7b64a8bd9d05946aff3c9cf16cbac92ffc6", "filename": "gcc/testsuite/gfortran.dg/pr55086_1_tfat.f90", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr55086_1_tfat.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr55086_1_tfat.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr55086_1_tfat.f90?ref=7bd5dad24907ba68a81365932d442d40460e4ed0", "patch": "@@ -0,0 +1,64 @@\n+! { dg-do run }\n+! { dg-options \"-ftest-forall-temp\" }\n+!\n+  implicit none\n+  character(len=5), pointer :: a(:), b(:)\n+  character(len=5), pointer :: c, d\n+  allocate (a(2), b(2), c, d)\n+  a = [ \"abcde\", \"ABCDE\" ]\n+  call aloct_pointer_copy_4 (b, a)\n+  !print *, b(1)\n+  !print *, b(2)\n+  if (any (a /= b)) stop 'WRONG'\n+\n+  call aloct_copy_4 (b, a)\n+  !print *, b(1)\n+  !print *, b(2)\n+  if (any (a /= b)) stop 'WRONG'\n+\n+  d = '12345'\n+  c = \"abcde\"\n+  call test2 (d, c)\n+  !print *, d\n+  if (d /= '1cb15') stop 'WRONG'\n+\n+  call test2p (d, c)\n+  !print *, d\n+  if (d /= '1cb15') stop 'WRONG'\n+\n+contains\n+ subroutine aloct_pointer_copy_4(o, i)\n+  character(len=*), pointer :: o(:), i(:)\n+  integer :: nl1, nu1\n+  integer :: i1\n+  nl1 = lbound(i,dim=1)\n+  nu1 = ubound(i,dim=1)\n+  forall (i1 = nl1:nu1) o(i1) = i(i1)\n+ end subroutine aloct_pointer_copy_4\n+ subroutine aloct_copy_4(o, i)\n+  character(len=*), pointer :: o(:), i(:)\n+  integer :: nl1, nu1\n+  integer :: i1\n+  nl1 = lbound(i,dim=1)\n+  nu1 = ubound(i,dim=1)\n+  forall (i1 = nl1:nu1) o(i1) = i(i1)\n+ end subroutine aloct_copy_4\n+ subroutine test2(o, i)\n+  character(len=*) :: o, i\n+  integer :: nl1, nu1\n+  integer :: i1\n+  nl1 = 2\n+  nu1 = 4\n+  forall (i1 = nl1:nu1) o(i1:i1) = i(i1:i1)\n+  forall (i1 = nl1:nu1) o(i1:i1) = o(nu1+1-i1:nu1+1-i1)\n+ end subroutine test2\n+ subroutine test2p(o, i)\n+  character(len=*), pointer :: o, i\n+  integer :: nl1, nu1\n+  integer :: i1\n+  nl1 = 2\n+  nu1 = 4\n+  forall (i1 = nl1:nu1) o(i1:i1) = i(i1:i1)   ! <<<< ICE\n+  forall (i1 = nl1:nu1) o(i1:i1) = o(nu1+1-i1:nu1+1-i1)\n+ end subroutine test2p\n+end"}, {"sha": "d731da4a16507a18cb515f323b1cdbf324ea51da", "filename": "gcc/testsuite/gfortran.dg/pr55086_2.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr55086_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr55086_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr55086_2.f90?ref=7bd5dad24907ba68a81365932d442d40460e4ed0", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do run }\n+!\n+  implicit none\n+\n+  character(len=7), pointer :: u\n+  character(len=7), pointer :: v\n+\n+  character(len=7), target  :: a\n+  character(len=7), target  :: b\n+\n+  integer :: j\n+\n+  b = \"1234567\"\n+  a = \"abcdefg\"\n+\n+  u => a\n+  v => b\n+\n+  forall (j = 1:2) a(j:j) = b(j:j)\n+\n+  if (a /= \"12cdefg\") call abort\n+\n+  forall (j = 2:3) a(j:j) = v(j:j)\n+  if (a /= \"123defg\") call abort\n+\n+  forall (j = 3:4) u(j:j) = b(j:j)\n+  if (a /= \"1234efg\") call abort\n+\n+  forall (j = 4:5) u(j:j) = v(j:j)\n+  if (a /= \"12345fg\") call abort\n+\n+end"}, {"sha": "7d09ed1d8c1a06336004463f531e7b2088904217", "filename": "gcc/testsuite/gfortran.dg/pr55086_2_tfat.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr55086_2_tfat.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr55086_2_tfat.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr55086_2_tfat.f90?ref=7bd5dad24907ba68a81365932d442d40460e4ed0", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+! { dg-options \"-ftest-forall-temp\" }\n+!\n+  implicit none\n+\n+  character(len=7), pointer :: u\n+  character(len=7), pointer :: v\n+\n+  character(len=7), target  :: a\n+  character(len=7), target  :: b\n+\n+  integer :: j\n+\n+  b = \"1234567\"\n+  a = \"abcdefg\"\n+\n+  u => a\n+  v => b\n+\n+  forall (j = 1:2) a(j:j) = b(j:j)\n+\n+  if (a /= \"12cdefg\") call abort\n+\n+  forall (j = 2:3) a(j:j) = v(j:j)\n+  if (a /= \"123defg\") call abort\n+\n+  forall (j = 3:4) u(j:j) = b(j:j)\n+  if (a /= \"1234efg\") call abort\n+\n+  forall (j = 4:5) u(j:j) = v(j:j)\n+  if (a /= \"12345fg\") call abort\n+\n+end"}, {"sha": "3c45c0a0dd049a425684e0b5f365317d058ffb6f", "filename": "gcc/testsuite/gfortran.dg/pr55086_aliasing_dummy_4_tfat.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr55086_aliasing_dummy_4_tfat.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd5dad24907ba68a81365932d442d40460e4ed0/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr55086_aliasing_dummy_4_tfat.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr55086_aliasing_dummy_4_tfat.f90?ref=7bd5dad24907ba68a81365932d442d40460e4ed0", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do run }\n+! { dg-options \"-ftest-forall-temp\" }\n+! This is a copy of aliasing_dummy_4.f90, with an option set to improve\n+! test coverage by forcing forall code to use a temporary.\n+!\n+program  test_f90\n+\n+    integer, parameter :: N = 2\n+\n+    type test_type\n+        integer a(N, N)\n+    end type\n+\n+    type (test_type) s(N, N)\n+\n+    forall (l = 1:N, m = 1:N) &\n+        s(l, m)%a(:, :) = reshape ([((i*l + 10*j*m +100, i = 1, N), j = 1, N)], [N, N])\n+\n+    call test_sub(s%a(1, 1), 1000) ! Test the original problem.\n+\n+    if ( any (s(1, 1)%a(:, :) /= reshape ([1111, 112, 121, 122], [2, 2]))) call abort ()\n+    if ( any (s(1, 2)%a(:, :) /= reshape ([1121, 122, 141, 142], [2, 2]))) call abort ()\n+    if ( any (s(2, 1)%a(:, :) /= reshape ([1112, 114, 122, 124], [2, 2]))) call abort ()\n+    if ( any (s(2, 2)%a(:, :) /= reshape ([1122, 124, 142, 144], [2, 2]))) call abort ()\n+\n+    call test_sub(s(1, 1)%a(:, :), 1000)  ! Check \"normal\" references.\n+\n+    if ( any (s(1, 1)%a(:, :) /= reshape ([2111,1112,1121,1122], [2, 2]))) call abort ()\n+    if ( any (s(1, 2)%a(:, :) /= reshape ([1121, 122, 141, 142], [2, 2]))) call abort ()\n+    if ( any (s(2, 1)%a(:, :) /= reshape ([1112, 114, 122, 124], [2, 2]))) call abort ()\n+    if ( any (s(2, 2)%a(:, :) /= reshape ([1122, 124, 142, 144], [2, 2]))) call abort ()\n+contains\n+  subroutine test_sub(array, offset)\n+    integer array(:, :), offset\n+\n+    forall (i = 1:N, j = 1:N) &\n+        array(i, j) = array(i, j) + offset\n+  end subroutine\n+end program\n+"}]}