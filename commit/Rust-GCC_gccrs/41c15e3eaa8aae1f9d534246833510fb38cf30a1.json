{"sha": "41c15e3eaa8aae1f9d534246833510fb38cf30a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFjMTVlM2VhYThhYWUxZjlkNTM0MjQ2ODMzNTEwZmIzOGNmMzBhMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-11-06T09:37:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-11-06T09:37:34Z"}, "message": "[multiple changes]\n\n2012-11-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_prag.adb: Add with and use clause for Sem_Ch8.\n\t(Expand_N_Pragma): Add a new variant to expand pragma Loop_Assertion.\n\t(Expand_Pragma_Loop_Assertion): New routine.\n\t* par-prag.adb (Prag): The semantic analysis of pragma\n\tLoop_Assertion is carried out by Analyze_Pragma. No need for\n\tchecks in the parser.\n\t* sem_prag.adb: Add a reference position value for pragma\n\tLoop_Assertion in Sig_Flags.\n\t(Analyze_Pragma): Add semantic analysis for pragma Loop_Assertion.\n\t* snames.ads-tmpl: Add the following new names:\n\tName_Decreases Name_Increases Name_Loop_Assertion.\n\tAdd new pragma id Pragma_Loop_Assertion.\n\n2012-11-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch5.adb: Identifier in iterator must have debug\n\tinformation.\n\nFrom-SVN: r193211", "tree": {"sha": "83e770aeee904a0e4016cefa9cb5008e91f7f546", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83e770aeee904a0e4016cefa9cb5008e91f7f546"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41c15e3eaa8aae1f9d534246833510fb38cf30a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41c15e3eaa8aae1f9d534246833510fb38cf30a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41c15e3eaa8aae1f9d534246833510fb38cf30a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41c15e3eaa8aae1f9d534246833510fb38cf30a1/comments", "author": null, "committer": null, "parents": [{"sha": "11e185566b2122be2da3d71878286aeec0c71f10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11e185566b2122be2da3d71878286aeec0c71f10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11e185566b2122be2da3d71878286aeec0c71f10"}], "stats": {"total": 456, "additions": 456, "deletions": 0}, "files": [{"sha": "bf1db35e738a0ef9c04de4f8dd6d73b076cbefc3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c15e3eaa8aae1f9d534246833510fb38cf30a1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c15e3eaa8aae1f9d534246833510fb38cf30a1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=41c15e3eaa8aae1f9d534246833510fb38cf30a1", "patch": "@@ -1,3 +1,23 @@\n+2012-11-06  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_prag.adb: Add with and use clause for Sem_Ch8.\n+\t(Expand_N_Pragma): Add a new variant to expand pragma Loop_Assertion.\n+\t(Expand_Pragma_Loop_Assertion): New routine.\n+\t* par-prag.adb (Prag): The semantic analysis of pragma\n+\tLoop_Assertion is carried out by Analyze_Pragma. No need for\n+\tchecks in the parser.\n+\t* sem_prag.adb: Add a reference position value for pragma\n+\tLoop_Assertion in Sig_Flags.\n+\t(Analyze_Pragma): Add semantic analysis for pragma Loop_Assertion.\n+\t* snames.ads-tmpl: Add the following new names:\n+\tName_Decreases Name_Increases Name_Loop_Assertion.\n+\tAdd new pragma id Pragma_Loop_Assertion.\n+\n+2012-11-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch5.adb: Identifier in iterator must have debug\n+\tinformation.\n+\n 2012-11-06  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gcc-interface/Makefile.in, gcc-interface/Make-lang.in: Remove"}, {"sha": "eb861d289335301187dac13d0add019b4eb0fda4", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c15e3eaa8aae1f9d534246833510fb38cf30a1/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c15e3eaa8aae1f9d534246833510fb38cf30a1/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=41c15e3eaa8aae1f9d534246833510fb38cf30a1", "patch": "@@ -3108,6 +3108,11 @@ package body Exp_Ch5 is\n                        Expressions =>\n                          New_List (New_Occurrence_Of (Cursor, Loc))));\n \n+               --  The defining identifier in the iterator is user-visible\n+               --  and must be visible in the debugger.\n+\n+               Set_Debug_Info_Needed (Id);\n+\n                --  If the container holds controlled objects, wrap the loop\n                --  statements and element renaming declaration with a block.\n                --  This ensures that the result of Element (Cusor) is"}, {"sha": "e7b16a985ad607418801c3a67d1a3a4101eb731c", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c15e3eaa8aae1f9d534246833510fb38cf30a1/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c15e3eaa8aae1f9d534246833510fb38cf30a1/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=41c15e3eaa8aae1f9d534246833510fb38cf30a1", "patch": "@@ -39,6 +39,7 @@ with Restrict; use Restrict;\n with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n+with Sem_Ch8;  use Sem_Ch8;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n@@ -68,6 +69,7 @@ package body Exp_Prag is\n    procedure Expand_Pragma_Import_Export_Exception (N : Node_Id);\n    procedure Expand_Pragma_Inspection_Point        (N : Node_Id);\n    procedure Expand_Pragma_Interrupt_Priority      (N : Node_Id);\n+   procedure Expand_Pragma_Loop_Assertion          (N : Node_Id);\n    procedure Expand_Pragma_Psect_Object            (N : Node_Id);\n    procedure Expand_Pragma_Relative_Deadline       (N : Node_Id);\n \n@@ -189,6 +191,9 @@ package body Exp_Prag is\n             when Pragma_Interrupt_Priority =>\n                Expand_Pragma_Interrupt_Priority (N);\n \n+            when Pragma_Loop_Assertion =>\n+               Expand_Pragma_Loop_Assertion (N);\n+\n             when Pragma_Psect_Object =>\n                Expand_Pragma_Psect_Object (N);\n \n@@ -790,6 +795,348 @@ package body Exp_Prag is\n       end if;\n    end Expand_Pragma_Interrupt_Priority;\n \n+   ----------------------------------\n+   -- Expand_Pragma_Loop_Assertion --\n+   ----------------------------------\n+\n+   --  Pragma Loop_Assertion is expanded in the following manner:\n+\n+   --  Original code\n+\n+   --     for | while ... loop\n+   --        <preceding source statements>\n+   --        pragma Loop_Assertion\n+   --           (Invariant => Invar_Expr,\n+   --            Increases => Incr_Expr,\n+   --            Decreases => Decr_Expr);\n+   --        <succeeding source statements>\n+   --     end loop;\n+\n+   --  Expanded code\n+\n+   --     Curr_1 : <type of Incr_Expr>;\n+   --     Curr_2 : <type of Decr_Expr>;\n+   --     Old_1  : <type of Incr_Expr>;\n+   --     Old_2  : <type of Decr_Expr>;\n+   --     Flag   : Boolean := False;\n+   --\n+   --     for | while ... loop\n+   --        <preceding source statements>\n+   --\n+   --        pragma Assert (<Invar_Expr>);\n+   --\n+   --        if Flag then\n+   --           Old_1 := Curr_1;\n+   --           Old_2 := Curr_2;\n+   --        end if;\n+   --\n+   --        Curr_1 := <Incr_Expr>;\n+   --        Curr_2 := <Decr_Expr>;\n+   --\n+   --        if Flag then\n+   --           if Curr_1 /= Old_1 then\n+   --              pragma Assert (Curr_1 > Old_1);\n+   --           else\n+   --              pragma Assert (Curr_2 < Old_2);\n+   --           end if;\n+   --        else\n+   --           Flag := True;\n+   --        end if;\n+   --\n+   --        <succeeding source statements>\n+   --     end loop;\n+\n+   procedure Expand_Pragma_Loop_Assertion (N : Node_Id) is\n+      Loc         : constant Source_Ptr := Sloc (N);\n+      Curr_Assign : List_Id   := No_List;\n+      Flag_Id     : Entity_Id := Empty;\n+      If_Stmt     : Node_Id   := Empty;\n+      Loop_Scop   : Entity_Id;\n+      Loop_Stmt   : Node_Id;\n+      Old_Assign  : List_Id   := No_List;\n+\n+      procedure Process_Increase_Decrease (Arg : Node_Id; Is_Last : Boolean);\n+      --  Process a single increases/decreases expression. Flag Is_Last should\n+      --  be set when the expression is the last argument to be processed.\n+\n+      -------------------------------\n+      -- Process_Increase_Decrease --\n+      -------------------------------\n+\n+      procedure Process_Increase_Decrease (Arg : Node_Id; Is_Last : Boolean) is\n+         function Make_Op\n+           (Loc      : Source_Ptr;\n+            Curr_Val : Node_Id;\n+            Old_Val  : Node_Id) return Node_Id;\n+         --  Generate a comparison between Curr_Val and Old_Val depending on\n+         --  the argument name (Increases / Decreases).\n+\n+         -------------\n+         -- Make_Op --\n+         -------------\n+\n+         function Make_Op\n+           (Loc      : Source_Ptr;\n+            Curr_Val : Node_Id;\n+            Old_Val  : Node_Id) return Node_Id\n+         is\n+         begin\n+            if Chars (Arg) = Name_Increases then\n+               return\n+                 Make_Op_Gt (Loc,\n+                   Left_Opnd  => Curr_Val,\n+                   Right_Opnd => Old_Val);\n+            else\n+               return\n+                 Make_Op_Lt (Loc,\n+                   Left_Opnd  => Curr_Val,\n+                   Right_Opnd => Old_Val);\n+            end if;\n+         end Make_Op;\n+\n+         --  Local variables\n+\n+         Expr     : constant Node_Id := Expression (Arg);\n+         Loop_Loc : constant Source_Ptr := Sloc (Loop_Stmt);\n+         Cond     : Node_Id;\n+         Curr_Id  : Entity_Id;\n+         Old_Id   : Entity_Id;\n+         Prag     : Node_Id;\n+\n+      --  Start of processing for Process_Increase_Decrease\n+\n+      begin\n+         --  All temporaries generated in this routine must be inserted before\n+         --  the related loop statement. Ensure that the proper scope is on the\n+         --  stack when analyzing the temporaries.\n+\n+         Push_Scope (Scope (Loop_Scop));\n+\n+         --  Step 1: Create the declaration of the flag which controls the\n+         --  behavior of the assertion on the first iteration of the loop.\n+\n+         if No (Flag_Id) then\n+\n+            --  Generate:\n+            --    Flag : Boolean := False;\n+\n+            Flag_Id := Make_Temporary (Loop_Loc, 'F');\n+\n+            Insert_Action (Loop_Stmt,\n+              Make_Object_Declaration (Loop_Loc,\n+                Defining_Identifier => Flag_Id,\n+                Object_Definition   =>\n+                  New_Reference_To (Standard_Boolean, Loop_Loc),\n+                Expression          =>\n+                  New_Reference_To (Standard_False, Loop_Loc)));\n+         end if;\n+\n+         --  Step 2: Create the temporaries which store the old and current\n+         --  values of the associated expression.\n+\n+         --  Generate:\n+         --    Curr : <type of Expr>;\n+\n+         Curr_Id := Make_Temporary (Loc, 'C');\n+\n+         Insert_Action (Loop_Stmt,\n+           Make_Object_Declaration (Loop_Loc,\n+             Defining_Identifier => Curr_Id,\n+             Object_Definition   =>\n+               New_Reference_To (Etype (Expr), Loop_Loc)));\n+\n+         --  Generate:\n+         --    Old : <type of Expr>;\n+\n+         Old_Id  := Make_Temporary (Loc, 'P');\n+\n+         Insert_Action (Loop_Stmt,\n+           Make_Object_Declaration (Loop_Loc,\n+             Defining_Identifier => Old_Id,\n+             Object_Definition   =>\n+               New_Reference_To (Etype (Expr), Loop_Loc)));\n+\n+         --  Restore the original scope after all temporaries have been\n+         --  analyzed.\n+\n+         Pop_Scope;\n+\n+         --  Step 3: Store the value of the expression from the previous\n+         --  iteration.\n+\n+         if No (Old_Assign) then\n+            Old_Assign := New_List;\n+         end if;\n+\n+         --  Generate:\n+         --    Old := Curr;\n+\n+         Append_To (Old_Assign,\n+           Make_Assignment_Statement (Loc,\n+             Name       => New_Reference_To (Old_Id, Loc),\n+             Expression => New_Reference_To (Curr_Id, Loc)));\n+\n+         --  Step 4: Store the current value of the expression\n+\n+         if No (Curr_Assign) then\n+            Curr_Assign := New_List;\n+         end if;\n+\n+         --  Generate:\n+         --    Curr := <Expr>;\n+\n+         Append_To (Curr_Assign,\n+           Make_Assignment_Statement (Loc,\n+             Name       => New_Reference_To (Curr_Id, Loc),\n+             Expression => Relocate_Node (Expr)));\n+\n+         --  Step 5: Create the corresponding assertion to verify the change of\n+         --  value.\n+\n+         --  Generate:\n+         --    pragma Assert (Curr <|> Old);\n+\n+         Prag :=\n+           Make_Pragma (Loc,\n+             Chars                        => Name_Assert,\n+             Pragma_Argument_Associations => New_List (\n+               Make_Pragma_Argument_Association (Loc,\n+                 Expression =>\n+                   Make_Op (Loc,\n+                     Curr_Val => New_Reference_To (Curr_Id, Loc),\n+                     Old_Val  => New_Reference_To (Old_Id, Loc)))));\n+\n+         --  Generate:\n+         --    if Curr /= Old then\n+         --       <Prag>;\n+\n+         Cond :=\n+           Make_Op_Ne (Loc,\n+             Left_Opnd  => New_Reference_To (Curr_Id, Loc),\n+             Right_Opnd => New_Reference_To (Old_Id, Loc));\n+\n+         if No (If_Stmt) then\n+            If_Stmt :=\n+              Make_If_Statement (Loc,\n+                Condition       => Cond,\n+                Then_Statements => New_List (Prag));\n+\n+         --  Generate:\n+         --    else\n+         --       <Prag>;\n+         --    end if;\n+\n+         elsif Is_Last then\n+            Set_Else_Statements (If_Stmt, New_List (Prag));\n+\n+         --  Generate:\n+         --    elsif Curr /= Old then\n+         --       <Prag>;\n+\n+         else\n+            if Elsif_Parts (If_Stmt) = No_List then\n+               Set_Elsif_Parts (If_Stmt, New_List);\n+            end if;\n+\n+            Append_To (Elsif_Parts (If_Stmt),\n+              Make_Elsif_Part (Loc,\n+                Condition       => Cond,\n+                Then_Statements => New_List (Prag)));\n+         end if;\n+      end Process_Increase_Decrease;\n+\n+      --  Local variables\n+\n+      Args     : constant List_Id := Pragma_Argument_Associations (N);\n+      Last_Arg : constant Node_Id := Last (Args);\n+      Arg      : Node_Id;\n+      Invar    : Node_Id := Empty;\n+\n+   --  Start of processing for Expand_Pragma_Loop_Assertion\n+\n+   begin\n+      --  Locate the enclosing loop for which this assertion applies\n+\n+      Loop_Scop := Current_Scope;\n+      while Present (Loop_Scop)\n+        and then Loop_Scop /= Standard_Standard\n+        and then Ekind (Loop_Scop) /= E_Loop\n+      loop\n+         Loop_Scop := Scope (Loop_Scop);\n+      end loop;\n+\n+      Loop_Stmt := N;\n+      while Present (Loop_Stmt)\n+        and then Nkind (Loop_Stmt) /= N_Loop_Statement\n+      loop\n+         Loop_Stmt := Parent (Loop_Stmt);\n+      end loop;\n+\n+      --  Process all pragma arguments\n+\n+      Arg := First (Args);\n+      while Present (Arg) loop\n+         if No (Invar) or else Chars (Arg) = Name_Invariant then\n+            Invar := Expression (Arg);\n+         else\n+            Process_Increase_Decrease (Arg, Is_Last => Arg = Last_Arg);\n+         end if;\n+\n+         Next (Arg);\n+      end loop;\n+\n+      --  Verify the invariant expression, generate:\n+      --    pragma Assert (<Invar>);\n+\n+      Insert_Action (N,\n+        Make_Pragma (Loc,\n+          Chars                        => Name_Assert,\n+          Pragma_Argument_Associations => New_List (\n+            Make_Pragma_Argument_Association (Loc,\n+              Expression => Relocate_Node (Invar)))));\n+\n+      --  Construct the segment which stores the old values of all expressions.\n+      --  Generate:\n+      --    if Flag then\n+      --       <Old_Assign>\n+      --    end if;\n+\n+      if Present (Old_Assign) then\n+         Insert_Action (N,\n+           Make_If_Statement (Loc,\n+             Condition       => New_Reference_To (Flag_Id, Loc),\n+             Then_Statements => Old_Assign));\n+      end if;\n+\n+      --  Update the values of all expressions\n+\n+      if Present (Curr_Assign) then\n+         Insert_Actions (N, Curr_Assign);\n+      end if;\n+\n+      --  Add the assertion circuitry to test all changes in expressions.\n+      --  Generate:\n+      --    if Flag then\n+      --       <If_Stmt>\n+      --    else\n+      --       Flag := True;\n+      --    end if;\n+\n+      if Present (If_Stmt) then\n+         Insert_Action (N,\n+           Make_If_Statement (Loc,\n+             Condition       => New_Reference_To (Flag_Id, Loc),\n+             Then_Statements => New_List (If_Stmt),\n+             Else_Statements => New_List (\n+               Make_Assignment_Statement (Loc,\n+                 Name       => New_Reference_To (Flag_Id, Loc),\n+                 Expression => New_Reference_To (Standard_True, Loc)))));\n+      end if;\n+\n+      Rewrite (N, Make_Null_Statement (Loc));\n+      Analyze (N);\n+   end Expand_Pragma_Loop_Assertion;\n+\n    --------------------------------\n    -- Expand_Pragma_Psect_Object --\n    --------------------------------"}, {"sha": "a59a39b1c00cc12008b176f97bc93f03c3abff0b", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c15e3eaa8aae1f9d534246833510fb38cf30a1/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c15e3eaa8aae1f9d534246833510fb38cf30a1/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=41c15e3eaa8aae1f9d534246833510fb38cf30a1", "patch": "@@ -1188,6 +1188,7 @@ begin\n            Pragma_Lock_Free                      |\n            Pragma_Locking_Policy                 |\n            Pragma_Long_Float                     |\n+           Pragma_Loop_Assertion                 |\n            Pragma_Machine_Attribute              |\n            Pragma_Main                           |\n            Pragma_Main_Storage                   |"}, {"sha": "2d660577a086060bcc2465f7ef62fd0b53ef994a", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c15e3eaa8aae1f9d534246833510fb38cf30a1/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c15e3eaa8aae1f9d534246833510fb38cf30a1/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=41c15e3eaa8aae1f9d534246833510fb38cf30a1", "patch": "@@ -11284,6 +11284,84 @@ package body Sem_Prag is\n             Set_Standard_Fpt_Formats;\n          end Long_Float;\n \n+         --------------------\n+         -- Loop_Assertion --\n+         --------------------\n+\n+         --  pragma Loop_Assertion (\n+         --     [[Invariant   =>] boolean_EXPRESSION],\n+         --      {CHANGE_MODE =>  discrete_EXPRESSION} );\n+         --\n+         --  CHANGE_MODE ::= Increases | Decreases\n+\n+         when Pragma_Loop_Assertion => Loop_Assertion : declare\n+            Arg  : Node_Id;\n+            Expr : Node_Id;\n+            Seen : Boolean := False;\n+            Stmt : Node_Id;\n+\n+         begin\n+            GNAT_Pragma;\n+            S14_Pragma;\n+\n+            --  Completely ignore if disabled\n+\n+            if Check_Disabled (Pname) then\n+               Rewrite (N, Make_Null_Statement (Loc));\n+               Analyze (N);\n+               return;\n+            end if;\n+\n+            --  Verify that the pragma appears inside a loop\n+\n+            Stmt := N;\n+            while Present (Stmt) and then Nkind (Stmt) /= N_Loop_Statement loop\n+               Stmt := Parent (Stmt);\n+            end loop;\n+\n+            if No (Stmt) then\n+               Error_Pragma (\"pragma % must appear inside a loop\");\n+            end if;\n+\n+            Check_At_Least_N_Arguments (1);\n+\n+            --  Process the arguments\n+\n+            Arg := Arg1;\n+            while Present (Arg) loop\n+               Expr := Expression (Arg);\n+\n+               --  All expressions are preanalyzed because they will be\n+               --  relocated during expansion and analyzed in their new\n+               --  context.\n+\n+               if Chars (Arg) = Name_Invariant or else Arg_Count = 1 then\n+\n+                  --  Only one invariant is allowed in the pragma\n+\n+                  if Seen then\n+                     Error_Pragma_Arg\n+                       (\"only one invariant allowed in pragma %\", Arg);\n+                  else\n+                     Seen := True;\n+                     Preanalyze_And_Resolve (Expr, Any_Boolean);\n+                  end if;\n+\n+               elsif Chars (Arg) = Name_Increases\n+                 or else Chars (Arg) = Name_Decreases\n+               then\n+                  Preanalyze_And_Resolve (Expr, Any_Discrete);\n+\n+               --  Illegal argument\n+\n+               else\n+                  Error_Pragma_Arg (\"argument & not allowed in pragma %\", Arg);\n+               end if;\n+\n+               Next (Arg);\n+            end loop;\n+         end Loop_Assertion;\n+\n          -----------------------\n          -- Machine_Attribute --\n          -----------------------\n@@ -15428,6 +15506,7 @@ package body Sem_Prag is\n       Pragma_Lock_Free                      => -1,\n       Pragma_Locking_Policy                 => -1,\n       Pragma_Long_Float                     => -1,\n+      Pragma_Loop_Assertion                 => -1,\n       Pragma_Machine_Attribute              => -1,\n       Pragma_Main                           => -1,\n       Pragma_Main_Storage                   => -1,"}, {"sha": "f44c6898fa4d094906ac54eed75822b955f59051", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c15e3eaa8aae1f9d534246833510fb38cf30a1/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c15e3eaa8aae1f9d534246833510fb38cf30a1/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=41c15e3eaa8aae1f9d534246833510fb38cf30a1", "patch": "@@ -405,6 +405,7 @@ package Snames is\n    Name_License                        : constant Name_Id := N + $; -- GNAT\n    Name_Locking_Policy                 : constant Name_Id := N + $;\n    Name_Long_Float                     : constant Name_Id := N + $; -- VMS\n+   Name_Loop_Assertion                 : constant Name_Id := N + $; -- GNAT\n    Name_No_Run_Time                    : constant Name_Id := N + $; -- GNAT\n    Name_No_Strict_Aliasing             : constant Name_Id := N + $; -- GNAT\n    Name_Normalize_Scalars              : constant Name_Id := N + $;\n@@ -670,6 +671,7 @@ package Snames is\n    Name_Component_Size_4               : constant Name_Id := N + $;\n    Name_Copy                           : constant Name_Id := N + $;\n    Name_D_Float                        : constant Name_Id := N + $;\n+   Name_Decreases                      : constant Name_Id := N + $;\n    Name_Descriptor                     : constant Name_Id := N + $;\n    Name_Disable                        : constant Name_Id := N + $;\n    Name_Dot_Replacement                : constant Name_Id := N + $;\n@@ -689,6 +691,7 @@ package Snames is\n    Name_GPL                            : constant Name_Id := N + $;\n    Name_IEEE_Float                     : constant Name_Id := N + $;\n    Name_Ignore                         : constant Name_Id := N + $;\n+   Name_Increases                      : constant Name_Id := N + $;\n    Name_Info                           : constant Name_Id := N + $;\n    Name_Internal                       : constant Name_Id := N + $;\n    Name_Link_Name                      : constant Name_Id := N + $;\n@@ -1675,6 +1678,7 @@ package Snames is\n       Pragma_License,\n       Pragma_Locking_Policy,\n       Pragma_Long_Float,\n+      Pragma_Loop_Assertion,\n       Pragma_No_Run_Time,\n       Pragma_No_Strict_Aliasing,\n       Pragma_Normalize_Scalars,"}]}