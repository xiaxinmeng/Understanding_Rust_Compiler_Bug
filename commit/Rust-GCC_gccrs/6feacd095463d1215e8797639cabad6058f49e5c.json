{"sha": "6feacd095463d1215e8797639cabad6058f49e5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZlYWNkMDk1NDYzZDEyMTVlODc5NzYzOWNhYmFkNjA1OGY0OWU1Yw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1998-07-02T13:49:34Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1998-07-02T13:49:34Z"}, "message": "Switch reg_n_info structure to use varrays\n\nFrom-SVN: r20894", "tree": {"sha": "07fac8f9725ba2a3a78cb899e4367fe27d91d686", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07fac8f9725ba2a3a78cb899e4367fe27d91d686"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6feacd095463d1215e8797639cabad6058f49e5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6feacd095463d1215e8797639cabad6058f49e5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6feacd095463d1215e8797639cabad6058f49e5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6feacd095463d1215e8797639cabad6058f49e5c/comments", "author": null, "committer": null, "parents": [{"sha": "39403d8233deb862fc951f95cd11280440c90880", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39403d8233deb862fc951f95cd11280440c90880", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39403d8233deb862fc951f95cd11280440c90880"}], "stats": {"total": 285, "additions": 189, "deletions": 96}, "files": [{"sha": "4169c6ebccaec6ada0f7be985b2543615432de0f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6feacd095463d1215e8797639cabad6058f49e5c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6feacd095463d1215e8797639cabad6058f49e5c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6feacd095463d1215e8797639cabad6058f49e5c", "patch": "@@ -18,13 +18,37 @@ Thu Jul  2 14:34:48 1998  David Edelsohn  <edelsohn@mhpcc.edu>\n Thu Jul  2 14:16:11 1998  Michael Meissner  <meissner@cygnus.com>\n \n \t* varray.{c,h}: New files to provide virtual array support.\n+\n \t* Makefile.in (OBJS): Add varray.o.\n \t(varray.o): Add new file.\n+\t(REGS_H): New variable for dependencies for files including\n+\tregs.h.  Add varray.h and files it includes.  Change all regs.h\n+\tdependencies to $(REGS_H).\n \n \t* toplev.c (x{m,re}alloc): If size is 0, allocate 1 byte.\n \t(xcalloc): Provide frontend for calloc.\n \t* {tree,rtl}.h (xcalloc): Add declaration.\n \n+\t* basic-block.h (REG_BASIC_BLOCK): Convert reg_n_info to be a\n+\tvarray.\n+\n+\t* regs.h (toplevel): Include varray.h.\n+\t(reg_n_info): Switch to use a varray.\n+\t(REG_*): Ditto.\n+\t(allocate_reg_info): Change num_regs argument to be size_t.\n+\n+\t* regclass.c (reg_info_data): New structure to remember groups of\n+\treg_info structures allocated that are to be zeroed.\n+\t({pref,alt}class_buffer): New statics to hold buffers\n+\tallocate_reg_info allocates for {pref,alt}class_buffer.\n+        (regclass): Use {pref,alt}class_buffer to initialize\n+        {pref,alt}class.\n+\t(allocate_reg_info): Switch to make reg_n_info use varrays.\n+\tAllocate buffers for the preferred and alter register class\n+\tinformation.  Change num_regs argument to be size_t, not int.\n+\n+\t* flow.c (reg_n_info): Switch to use varrays.\n+\n Thu Jul  2 10:11:47 1998  Robert Lipe  <robertl@dgii.com>\n \n \t* install.texi (sco3.2v5): Document new --with-gnu-as flag."}, {"sha": "a07015b15b4c52bbcf52f84f487b8a285eb3b33d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 41, "deletions": 39, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6feacd095463d1215e8797639cabad6058f49e5c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6feacd095463d1215e8797639cabad6058f49e5c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6feacd095463d1215e8797639cabad6058f49e5c", "patch": "@@ -637,7 +637,7 @@ OBJS = toplev.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n  function.o stmt.o except.o expr.o calls.o expmed.o explow.o optabs.o \\\n  varasm.o rtl.o print-rtl.o rtlanal.o emit-rtl.o genrtl.o real.o regmove.o \\\n  dbxout.o sdbout.o dwarfout.o dwarf2out.o xcoffout.o bitmap.o alias.o \\\n- integrate.o jump.o cse.o loop.o unroll.o flow.o stupid.o combine.o \\\n+ integrate.o jump.o cse.o loop.o unroll.o flow.o stupid.o combine.o varray.o \\\n  regclass.o local-alloc.o global.o reload.o reload1.o caller-save.o gcse.o \\\n  insn-peep.o reorg.o $(SCHED_PREFIX)sched.o final.o recog.o reg-stack.o \\\n  insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o \\\n@@ -720,6 +720,7 @@ BASIC_BLOCK_H = basic-block.h bitmap.h\n DEMANGLE_H = demangle.h gansidecl.h\n RECOG_H = recog.h gansidecl.h\n EXPR_H = expr.h insn-codes.h\n+REGS_H = regs.h varray.h machmode.h machmode.def gansidecl.h\n #\f\n # Language makefile fragments.\n \n@@ -1379,116 +1380,117 @@ print-rtl.o : print-rtl.c $(CONFIG_H) system.h $(RTL_H) bitmap.h\n rtlanal.o : rtlanal.c $(CONFIG_H) system.h $(RTL_H)\n \n varasm.o : varasm.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) flags.h \\\n-   function.h defaults.h $(EXPR_H) hard-reg-set.h regs.h \\\n+   function.h defaults.h $(EXPR_H) hard-reg-set.h $(REGS_H) \\\n    xcoffout.h output.h c-pragma.h toplev.h except.h dbxout.h sdbout.h\n function.o : function.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n-   function.h insn-flags.h insn-codes.h $(EXPR_H) regs.h hard-reg-set.h \\\n+   function.h insn-flags.h insn-codes.h $(EXPR_H) $(REGS_H) hard-reg-set.h \\\n    insn-config.h $(RECOG_H) output.h toplev.h except.h\n stmt.o : stmt.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h function.h  \\\n    insn-flags.h insn-config.h insn-codes.h hard-reg-set.h $(EXPR_H) except.h \\\n    loop.h $(RECOG_H) toplev.h output.h\n except.o : except.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n-   function.h insn-flags.h $(EXPR_H) regs.h hard-reg-set.h \\\n+   function.h insn-flags.h $(EXPR_H) $(REGS_H) hard-reg-set.h \\\n    insn-config.h $(RECOG_H) output.h except.h toplev.h\n expr.o : expr.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h function.h \\\n-   regs.h insn-flags.h insn-codes.h $(EXPR_H) insn-config.h $(RECOG_H) output.h \\\n+   $(REGS_H) insn-flags.h insn-codes.h $(EXPR_H) insn-config.h $(RECOG_H) output.h \\\n    typeclass.h hard-reg-set.h toplev.h hard-reg-set.h except.h\n calls.o : calls.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h $(EXPR_H) \\\n-   insn-flags.h regs.h toplev.h output.h\n+   insn-flags.h $(REGS_H) toplev.h output.h\n expmed.o : expmed.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h  \\\n    insn-flags.h insn-config.h insn-codes.h $(EXPR_H) $(RECOG_H) real.h\n explow.o : explow.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    hard-reg-set.h insn-config.h $(EXPR_H) $(RECOG_H) insn-flags.h insn-codes.h\n optabs.o : optabs.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h  \\\n    insn-flags.h insn-config.h insn-codes.h $(EXPR_H) $(RECOG_H) reload.h\n-dbxout.o : dbxout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) flags.h regs.h \\\n+dbxout.o : dbxout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) flags.h $(REGS_H) \\\n    insn-config.h reload.h gstab.h xcoffout.h defaults.h output.h dbxout.h \\\n    toplev.h\n sdbout.o : sdbout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) flags.h except.h \\\n-   function.h $(EXPR_H) output.h hard-reg-set.h regs.h defaults.h real.h \\\n+   function.h $(EXPR_H) output.h hard-reg-set.h $(REGS_H) defaults.h real.h \\\n    insn-config.h obstack.h xcoffout.h c-pragma.h sdbout.h toplev.h\n dwarfout.o : dwarfout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) dwarf.h \\\n    flags.h insn-config.h reload.h output.h defaults.h toplev.h dwarfout.h\n dwarf2out.o : dwarf2out.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) dwarf2.h \\\n    flags.h insn-config.h reload.h output.h defaults.h \\\n-   hard-reg-set.h regs.h $(EXPR_H) toplev.h dwarf2out.h\n+   hard-reg-set.h $(REGS_H) $(EXPR_H) toplev.h dwarf2out.h\n xcoffout.o : xcoffout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) xcoffout.h \\\n    flags.h toplev.h output.h dbxout.h\n emit-rtl.o : emit-rtl.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n-   except.h function.h regs.h insn-config.h $(RECOG_H) real.h \\\n+   except.h function.h $(REGS_H) insn-config.h $(RECOG_H) real.h \\\n    $(EXPR_H) obstack.h hard-reg-set.h bitmap.h\n real.o : real.c $(CONFIG_H) system.h $(TREE_H) toplev.h\n getpwd.o : getpwd.c $(CONFIG_H) system.h\n \n integrate.o : integrate.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n-   integrate.h insn-flags.h insn-config.h $(EXPR_H) real.h regs.h \\\n+   integrate.h insn-flags.h insn-config.h $(EXPR_H) real.h $(REGS_H) \\\n    function.h output.h $(RECOG_H) except.h toplev.h\n \n-jump.o : jump.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h regs.h \\\n+jump.o : jump.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h $(REGS_H) \\\n    insn-config.h insn-flags.h $(RECOG_H) $(EXPR_H) real.h except.h \\\n    toplev.h\n-stupid.o : stupid.c $(CONFIG_H) system.h $(RTL_H) regs.h hard-reg-set.h \\\n+stupid.o : stupid.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h \\\n    flags.h toplev.h\n \n-cse.o : cse.c $(CONFIG_H) system.h $(RTL_H) regs.h hard-reg-set.h flags.h \\\n+cse.o : cse.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n    real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h output.h\n-gcse.o : gcse.c $(CONFIG_H) system.h $(RTL_H) regs.h hard-reg-set.h flags.h \\\n+gcse.o : gcse.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n    real.h insn-config.h $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) output.h\n profile.o : profile.c $(CONFIG_H) system.h $(RTL_H) flags.h insn-flags.h \\\n-   gcov-io.h $(TREE_H) output.h regs.h toplev.h\n+   gcov-io.h $(TREE_H) output.h $(REGS_H) toplev.h\n loop.o : loop.c $(CONFIG_H) system.h $(RTL_H) flags.h loop.h insn-config.h \\\n-   insn-flags.h regs.h hard-reg-set.h $(RECOG_H) $(EXPR_H) real.h \\\n+   insn-flags.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) real.h \\\n    toplev.h\n unroll.o : unroll.c $(CONFIG_H) system.h $(RTL_H) insn-config.h \\\n-   integrate.h regs.h $(RECOG_H) flags.h $(EXPR_H) loop.h toplev.h\n+   integrate.h $(REGS_H) $(RECOG_H) flags.h $(EXPR_H) loop.h toplev.h\n flow.o : flow.c $(CONFIG_H) system.h $(RTL_H) flags.h insn-config.h \\\n-   $(BASIC_BLOCK_H) regs.h hard-reg-set.h output.h toplev.h\n+   $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h\n combine.o : combine.c $(CONFIG_H) system.h $(RTL_H) flags.h  \\\n-   insn-config.h insn-flags.h insn-codes.h insn-attr.h regs.h $(EXPR_H) \\\n+   insn-config.h insn-flags.h insn-codes.h insn-attr.h $(REGS_H) $(EXPR_H) \\\n    $(BASIC_BLOCK_H) $(RECOG_H) real.h hard-reg-set.h toplev.h\n regclass.o : regclass.c $(CONFIG_H) system.h $(RTL_H) hard-reg-set.h flags.h \\\n-   $(BASIC_BLOCK_H) regs.h insn-config.h $(RECOG_H) reload.h real.h toplev.h \\\n+   $(BASIC_BLOCK_H) $(REGS_H) insn-config.h $(RECOG_H) reload.h real.h toplev.h \\\n    output.h\n local-alloc.o : local-alloc.c $(CONFIG_H) system.h $(RTL_H) flags.h \\\n-   $(BASIC_BLOCK_H) regs.h hard-reg-set.h insn-config.h $(RECOG_H) output.h \\\n+   $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) output.h \\\n    insn-attr.h toplev.h\n bitmap.o : bitmap.c $(CONFIG_H) system.h $(RTL_H) flags.h $(BASIC_BLOCK_H) \\\n-   regs.h\n+   $(REGS_H)\n global.o : global.c $(CONFIG_H) system.h $(RTL_H) flags.h  \\\n-   $(BASIC_BLOCK_H) regs.h hard-reg-set.h insn-config.h output.h toplev.h\n+   $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h insn-config.h output.h toplev.h\n+varray.o : varray.c $(CONFIG_H) system.h varray.h $(RTL_H) $(TREE_H) bitmap.h\n \n reload.o : reload.c $(CONFIG_H) system.h $(RTL_H) flags.h output.h $(EXPR_H) \\\n-   reload.h $(RECOG_H) hard-reg-set.h insn-config.h insn-codes.h regs.h \\\n+   reload.h $(RECOG_H) hard-reg-set.h insn-config.h insn-codes.h $(REGS_H) \\\n    real.h toplev.h\n reload1.o : reload1.c $(CONFIG_H) system.h $(RTL_H) real.h flags.h $(EXPR_H) \\\n-   reload.h regs.h hard-reg-set.h insn-config.h insn-flags.h insn-codes.h \\\n+   reload.h $(REGS_H) hard-reg-set.h insn-config.h insn-flags.h insn-codes.h \\\n    $(BASIC_BLOCK_H) $(RECOG_H) output.h toplev.h\n caller-save.o : caller-save.c $(CONFIG_H) system.h $(RTL_H) flags.h \\\n-   regs.h hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) \\\n+   $(REGS_H) hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) \\\n    $(RECOG_H) reload.h $(EXPR_H) toplev.h\n reorg.o : reorg.c $(CONFIG_H) system.h $(RTL_H) conditions.h hard-reg-set.h \\\n-   $(BASIC_BLOCK_H) regs.h insn-config.h insn-attr.h \\\n+   $(BASIC_BLOCK_H) $(REGS_H) insn-config.h insn-attr.h \\\n    insn-flags.h $(RECOG_H) flags.h output.h $(EXPR_H)\n-alias.o : alias.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h regs.h \\\n+alias.o : alias.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h $(REGS_H) \\\n    toplev.h\n regmove.o : regmove.c $(CONFIG_H) system.h $(RTL_H) insn-config.h \\\n-   $(RECOG_H) output.h reload.h regs.h hard-reg-set.h flags.h \\\n+   $(RECOG_H) output.h reload.h $(REGS_H) hard-reg-set.h flags.h \\\n    $(EXPR_H) insn-flags.h $(BASIC_BLOCK_H) toplev.h\n $(SCHED_PREFIX)sched.o : $(SCHED_PREFIX)sched.c $(CONFIG_H) system.h $(RTL_H) \\\n-   $(BASIC_BLOCK_H) regs.h hard-reg-set.h flags.h insn-config.h insn-attr.h \\\n+   $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h insn-attr.h \\\n    toplev.h\n-final.o : final.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h regs.h \\\n+final.o : final.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h $(REGS_H) \\\n    $(RECOG_H) conditions.h insn-config.h insn-attr.h except.h real.h output.h \\\n    hard-reg-set.h insn-flags.h insn-codes.h gstab.h xcoffout.h defaults.h \\\n    toplev.h reload.h dwarfout.h dwarf2out.h sdbout.h dbxout.h\n recog.o : recog.c $(CONFIG_H) system.h $(RTL_H)  \\\n-   regs.h $(RECOG_H) hard-reg-set.h flags.h insn-config.h insn-attr.h \\\n+   $(REGS_H) $(RECOG_H) hard-reg-set.h flags.h insn-config.h insn-attr.h \\\n    insn-flags.h insn-codes.h real.h\n reg-stack.o : reg-stack.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) \\\n-   regs.h hard-reg-set.h flags.h insn-config.h insn-flags.h toplev.h\n+   $(REGS_H) hard-reg-set.h flags.h insn-config.h insn-flags.h toplev.h\n \n $(out_object_file): $(out_file) $(CONFIG_H) $(TREE_H) \\\n-   $(RTL_H) regs.h hard-reg-set.h real.h insn-config.h conditions.h \\\n+   $(RTL_H) $(REGS_H) hard-reg-set.h real.h insn-config.h conditions.h \\\n    insn-flags.h output.h insn-attr.h insn-codes.h system.h toplev.h\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(out_file)\n \n@@ -1597,7 +1599,7 @@ s-extract : $(md_file) genextract $(srcdir)/move-if-change\n \t$(srcdir)/move-if-change tmp-extract.c insn-extract.c\n \ttouch s-extract\n \n-insn-peep.o : insn-peep.c $(CONFIG_H) $(RTL_H) regs.h output.h real.h system.h\n+insn-peep.o : insn-peep.c $(CONFIG_H) $(RTL_H) $(REGS_H) output.h real.h system.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c insn-peep.c\n \n insn-peep.c: s-peep ; @true\n@@ -1606,7 +1608,7 @@ s-peep : $(md_file) genpeep $(srcdir)/move-if-change\n \t$(srcdir)/move-if-change tmp-peep.c insn-peep.c\n \ttouch s-peep\n \n-insn-attrtab.o : insn-attrtab.c $(CONFIG_H) $(RTL_H) regs.h real.h output.h \\\n+insn-attrtab.o : insn-attrtab.c $(CONFIG_H) $(RTL_H) $(REGS_H) real.h output.h \\\n      insn-attr.h insn-config.h system.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c insn-attrtab.c\n \n@@ -1628,7 +1630,7 @@ s-attrtab : $(md_file) genattrtab $(srcdir)/move-if-change\n \t$(srcdir)/move-if-change tmp-attrtab.c insn-attrtab.c\n \ttouch s-attrtab\n \n-insn-output.o : insn-output.c $(CONFIG_H) $(RTL_H) regs.h real.h conditions.h \\\n+insn-output.o : insn-output.c $(CONFIG_H) $(RTL_H) $(REGS_H) real.h conditions.h \\\n     hard-reg-set.h insn-config.h insn-flags.h insn-attr.h output.h $(RECOG_H) \\\n     insn-codes.h system.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c insn-output.c\n@@ -1766,7 +1768,7 @@ $(HOST_PREFIX_1)print-rtl.o: $(srcdir)/print-rtl.c $(CONFIG_H) $(RTL_H)\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)print-rtl.c\n \n $(HOST_PREFIX_1)bitmap.o: $(srcdir)/bitmap.c $(CONFIG_H) system.h $(RTL_H) \\\n-  flags.h $(BASIC_BLOCK_H) regs.h\n+  flags.h $(BASIC_BLOCK_H) $(REGS_H)\n \trm -f $(HOST_PREFIX)bitmap.c\n \tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/bitmap.c > $(HOST_PREFIX)bitmap.c\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)bitmap.c"}, {"sha": "552f74a5d9f6cd4cfd12a0859c8656742b2ae383", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6feacd095463d1215e8797639cabad6058f49e5c/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6feacd095463d1215e8797639cabad6058f49e5c/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=6feacd095463d1215e8797639cabad6058f49e5c", "patch": "@@ -1,5 +1,5 @@\n /* Define control and data flow tables, and regsets.\n-   Copyright (C) 1987, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1997, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -132,7 +132,7 @@ extern regset regs_live_at_setjmp;\n #define REG_BLOCK_UNKNOWN -1\n #define REG_BLOCK_GLOBAL -2\n \n-#define REG_BASIC_BLOCK(N) (reg_n_info[(N)].basic_block)\n+#define REG_BASIC_BLOCK(N) (VARRAY_REG (reg_n_info, N)->basic_block)\n \n /* List of integers.\n    These are used for storing things like predecessors, etc."}, {"sha": "43ea11d8adc0fe000a4123ffb55cd03e1d5e4e68", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6feacd095463d1215e8797639cabad6058f49e5c/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6feacd095463d1215e8797639cabad6058f49e5c/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=6feacd095463d1215e8797639cabad6058f49e5c", "patch": "@@ -174,7 +174,7 @@ static int num_scratch;\n \n /* Indexed by n, giving various register information */\n \n-reg_info *reg_n_info;\n+varray_type reg_n_info;\n \n /* Size of the reg_n_info table.  */\n "}, {"sha": "d76ace3349910b62e8dd3c128e39c518e45ca2eb", "filename": "gcc/regclass.c", "status": "modified", "additions": 108, "deletions": 32, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6feacd095463d1215e8797639cabad6058f49e5c/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6feacd095463d1215e8797639cabad6058f49e5c/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=6feacd095463d1215e8797639cabad6058f49e5c", "patch": "@@ -193,6 +193,21 @@ static rtx top_of_stack[MAX_MACHINE_MODE];\n \n #endif /* HAVE_SECONDARY_RELOADS */\n \n+/* Linked list of reg_info structures allocated for reg_n_info array.\n+   Grouping all of the allocated structures together in one lump\n+   means only one call to bzero to clear them, rather than n smaller\n+   calls.  */\n+struct reg_info_data {\n+  struct reg_info_data *next;\t/* next set of reg_info structures */\n+  size_t min_index;\t\t/* minimum index # */\n+  size_t max_index;\t\t/* maximum index # */\n+  char used_p;\t\t\t/* non-zero if this has been used previously */\n+  reg_info data[1];\t\t/* beginning of the reg_info data */\n+};\n+\n+static struct reg_info_data *reg_info_head;\n+\n+\n /* Function called only once to initialize the above data on reg usage.\n    Once this is done, various switches may override.  */\n \n@@ -637,6 +652,10 @@ static char *prefclass;\n \n static char *altclass;\n \n+/* Allocated buffers for prefclass and altclass. */\n+static char *prefclass_buffer;\n+static char *altclass_buffer;\n+\n /* Record the depth of loops that we are in.  */\n \n static int loop_depth;\n@@ -987,8 +1006,8 @@ regclass (f, nregs)\n     \n       if (pass == 0)\n \t{\n-\t  prefclass = (char *) oballoc (nregs);\n-\t  altclass = (char *) oballoc (nregs);\n+\t  prefclass = prefclass_buffer;\n+\t  altclass = altclass_buffer;\n \t}\n \n       for (i = FIRST_PSEUDO_REGISTER; i < nregs; i++)\n@@ -1750,29 +1769,36 @@ auto_inc_dec_reg_p (reg, mode)\n \n void\n allocate_reg_info (num_regs, new_p, renumber_p)\n-     int num_regs;\n+     size_t num_regs;\n      int new_p;\n      int renumber_p;\n {\n-  static int regno_allocated = 0;\n+  static size_t regno_allocated = 0;\n   static short *renumber = (short *)0;\n   int i;\n-  int size_info;\n-  int size_renumber;\n-  int min = (new_p) ? 0 : reg_n_max;\n-\n-  /* If this message come up, and you want to fix it, then all of the tables\n-     like reg_renumber, etc. that use short will have to be found and lengthed\n-     to int or HOST_WIDE_INT.  */\n+  size_t size_info;\n+  size_t size_renumber;\n+  size_t min = (new_p) ? 0 : reg_n_max;\n+  struct reg_info_data *reg_data;\n+  struct reg_info_data *reg_next;\n \n   /* Free up all storage allocated */\n   if (num_regs < 0)\n     {\n       if (reg_n_info)\n \t{\n-\t  free ((char *)reg_n_info);\n-\t  free ((char *)renumber);\n-\t  reg_n_info = (reg_info *)0;\n+\t  VARRAY_FREE (reg_n_info);\n+\t  for (reg_data = reg_info_head; reg_data; reg_data = reg_next)\n+\t    {\n+\t      reg_next = reg_data->next;\n+\t      free ((char *)reg_data);\n+\t    }\n+\n+\t  free (prefclass_buffer);\n+\t  free (altclass_buffer);\n+\t  prefclass_buffer = (char *)0;\n+\t  altclass_buffer = (char *)0;\n+\t  reg_info_head = (struct reg_info_data *)0;\n \t  renumber = (short *)0;\n \t}\n       regno_allocated = 0;\n@@ -1782,48 +1808,98 @@ allocate_reg_info (num_regs, new_p, renumber_p)\n \n   if (num_regs > regno_allocated)\n     {\n+      size_t old_allocated = regno_allocated;\n+\n       regno_allocated = num_regs + (num_regs / 20);\t/* add some slop space */\n-      size_info = regno_allocated * sizeof (reg_info);\n       size_renumber = regno_allocated * sizeof (short);\n \n       if (!reg_n_info)\n \t{\n-\t  reg_n_info = (reg_info *) xmalloc (size_info);\n-\t  renumber = (short *) xmalloc (size_renumber);\n-\t}\n-\n-      else if (new_p)\t\t/* if we're zapping everything, no need to realloc */\n-\t{\n-\t  free ((char *)reg_n_info);\n-\t  free ((char *)renumber);\n-\t  reg_n_info = (reg_info *) xmalloc (size_info);\n+\t  VARRAY_REG_INIT (reg_n_info, regno_allocated, \"reg_n_info\");\n \t  renumber = (short *) xmalloc (size_renumber);\n+\t  prefclass_buffer = (char *) xmalloc (regno_allocated);\n+\t  altclass_buffer = (char *) xmalloc (regno_allocated);\n \t}\n \n       else\n \t{\n-\t  reg_n_info = (reg_info *) xrealloc ((char *)reg_n_info, size_info);\n-\t  renumber = (short *) xrealloc ((char *)renumber, size_renumber);\n+\t  VARRAY_GROW (reg_n_info, regno_allocated);\n+\n+\t  if (new_p)\t\t/* if we're zapping everything, no need to realloc */\n+\t    {\n+\t      free ((char *)renumber);\n+\t      free ((char *)prefclass_buffer);\n+\t      free ((char *)altclass_buffer);\n+\t      renumber = (short *) xmalloc (size_renumber);\n+\t      prefclass_buffer = (char *) xmalloc (regno_allocated);\n+\t      altclass_buffer = (char *) xmalloc (regno_allocated);\n+\t    }\n+\n+\t  else\n+\t    {\n+\t      renumber = (short *) xrealloc ((char *)renumber, size_renumber);\n+\t      prefclass_buffer = (char *) xrealloc ((char *)prefclass_buffer,\n+\t\t\t\t\t\t    regno_allocated);\n+\n+\t      altclass_buffer = (char *) xrealloc ((char *)altclass_buffer,\n+\t\t\t\t\t\t   regno_allocated);\n+\t    }\n \t}\n+\n+      size_info = (regno_allocated - old_allocated) * sizeof (reg_info)\n+\t+ sizeof (struct reg_info_data) - sizeof (reg_info);\n+      reg_data = (struct reg_info_data *) xcalloc (size_info, 1);\n+      reg_data->min_index = old_allocated;\n+      reg_data->max_index = regno_allocated - 1;\n+      reg_data->next = reg_info_head;\n+      reg_info_head = reg_data;\n     }\n \n+  reg_n_max = num_regs;\n   if (min < num_regs)\n     {\n-      bzero ((char *) &reg_n_info[min], (num_regs - min) * sizeof (reg_info));\n-      for (i = min; i < num_regs; i++)\n+      /* Loop through each of the segments allocated for the actual\n+\t reg_info pages, and set up the pointers, zero the pages, etc.  */\n+      for (reg_data = reg_info_head; reg_data; reg_data = reg_next)\n \t{\n-\t  REG_BASIC_BLOCK (i) = REG_BLOCK_UNKNOWN;\n-\t  renumber[i] = -1;\n+\t  size_t min_index = reg_data->min_index;\n+\t  size_t max_index = reg_data->max_index;\n+\n+\t  reg_next = reg_data->next;\n+\t  if (min_index <= num_regs)\n+\t    {\n+\t      size_t max = (max_index > num_regs) ? num_regs : max_index;\n+\t      if (!reg_data->used_p)\t/* page just allocated with calloc */\n+\t\treg_data->used_p = 1;\t/* no need to zero */\n+\t      else\n+\t\tbzero ((char *) &reg_data->data,\n+\t\t       sizeof (reg_info) * (max - min_index + 1));\n+\n+\t      for (i = min_index; i <= max; i++)\n+\t\t{\n+\t\t  VARRAY_REG (reg_n_info, i) = &reg_data->data[i-min_index];\n+\t\t  REG_BASIC_BLOCK (i) = REG_BLOCK_UNKNOWN;\n+\t\t  renumber[i] = -1;\n+\t\t  prefclass_buffer[i] = (char) NO_REGS;\n+\t\t  altclass_buffer[i] = (char) NO_REGS;\n+\t\t}\n+\t    }\n \t}\n     }\n \n+  /* If {pref,alt}class have already been allocated, update the pointers to\n+     the newly realloced ones.  */\n+  if (prefclass)\n+    {\n+      prefclass = prefclass_buffer;\n+      altclass = altclass_buffer;\n+    }\n+\n   if (renumber_p)\n     reg_renumber = renumber;\n \n   /* Tell the regset code about the new number of registers */\n   MAX_REGNO_REG_SET (num_regs, new_p, renumber_p);\n-\n-  reg_n_max = num_regs;\n }\n \n \f"}, {"sha": "e248665e9badece7179503739a983f2d086e61f4", "filename": "gcc/regs.h", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6feacd095463d1215e8797639cabad6058f49e5c/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6feacd095463d1215e8797639cabad6058f49e5c/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=6feacd095463d1215e8797639cabad6058f49e5c", "patch": "@@ -1,5 +1,5 @@\n /* Define per-register tables for data flow info and register allocation.\n-   Copyright (C) 1987, 1993, 1994, 1995, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1993, 1994, 1995, 1997, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -19,6 +19,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n \n+#include \"varray.h\"\n \n #define REG_BYTES(R) mode_size[(int) GET_MODE (R)]\n \n@@ -60,44 +61,34 @@ typedef struct reg_info_def {\n   char changes_size;\t\t/* whether (SUBREG (REG n)) changes size */\n } reg_info;\n \n-extern reg_info *reg_n_info;\n+extern varray_type reg_n_info;\n \n extern unsigned int reg_n_max;\n \n-/* Check for REG_N_xxx macros being in bound, return N for use as an\n-   index.  */\n-#ifdef ENABLE_CHECKING\n-#define REG_N_CHECK(N)\t\t\t\t\t\t\t\\\n-((((unsigned)(N) < (unsigned)reg_n_max)\t\t\t\t\t\\\n- ? 0 : (fatal (\"Register %d out of bounds\", (N)), 0)), (N))\n-#else\n-#define REG_N_CHECK(N) (N)\n-#endif\n-\n /* Indexed by n, gives number of times (REG n) is used or set.\n    References within loops may be counted more times.  */\n \n-#define REG_N_REFS(N) (reg_n_info[REG_N_CHECK (N)].refs)\n+#define REG_N_REFS(N) (VARRAY_REG (reg_n_info, N)->refs)\n \n /* Indexed by n, gives number of times (REG n) is set.\n    ??? both regscan and flow allocate space for this.  We should settle\n    on just copy.  */\n \n-#define REG_N_SETS(N) (reg_n_info[REG_N_CHECK (N)].sets)\n+#define REG_N_SETS(N) (VARRAY_REG (reg_n_info, N)->sets)\n \n /* Indexed by N, gives number of insns in which register N dies.\n    Note that if register N is live around loops, it can die\n    in transitions between basic blocks, and that is not counted here.\n    So this is only a reliable indicator of how many regions of life there are\n    for registers that are contained in one basic block.  */\n \n-#define REG_N_DEATHS(N) (reg_n_info[REG_N_CHECK (N)].deaths)\n+#define REG_N_DEATHS(N) (VARRAY_REG (reg_n_info, N)->deaths)\n \n /* Indexed by N; says whether a pseudo register N was ever used\n    within a SUBREG that changes the size of the reg.  Some machines prohibit\n    such objects to be in certain (usually floating-point) registers.  */\n \n-#define REG_CHANGES_SIZE(N) (reg_n_info[REG_N_CHECK (N)].changes_size)\n+#define REG_CHANGES_SIZE(N) (VARRAY_REG (reg_n_info, N)->changes_size)\n \n /* Get the number of consecutive words required to hold pseudo-reg N.  */\n \n@@ -116,7 +107,7 @@ extern unsigned int reg_n_max;\n \n /* Indexed by N, gives number of CALL_INSNS across which (REG n) is live.  */\n \n-#define REG_N_CALLS_CROSSED(N) (reg_n_info[REG_N_CHECK (N)].calls_crossed)\n+#define REG_N_CALLS_CROSSED(N) (VARRAY_REG (reg_n_info, N)->calls_crossed)\n \n /* Total number of instructions at which (REG n) is live.\n    The larger this is, the less priority (REG n) gets for\n@@ -133,7 +124,7 @@ extern unsigned int reg_n_max;\n    is not required.  global.c makes an allocno for this but does\n    not try to assign a hard register to it.  */\n \n-#define REG_LIVE_LENGTH(N) (reg_n_info[REG_N_CHECK (N)].live_length)\n+#define REG_LIVE_LENGTH(N) (VARRAY_REG (reg_n_info, N)->live_length)\n \n /* Vector of substitutions of register numbers,\n    used to map pseudo regs into hardware regs.\n@@ -165,19 +156,19 @@ extern enum machine_mode reg_raw_mode[FIRST_PSEUDO_REGISTER];\n    It is sometimes adjusted for subsequent changes during loop,\n    but not adjusted by cse even if cse invalidates it.  */\n \n-#define REGNO_FIRST_UID(N) (reg_n_info[REG_N_CHECK (N)].first_uid)\n+#define REGNO_FIRST_UID(N) (VARRAY_REG (reg_n_info, N)->first_uid)\n \n /* Vector indexed by regno; gives uid of last insn using that reg.\n    This is computed by reg_scan for use by cse and loop.\n    It is sometimes adjusted for subsequent changes during loop,\n    but not adjusted by cse even if cse invalidates it.\n    This is harmless since cse won't scan through a loop end.  */\n \n-#define REGNO_LAST_UID(N) (reg_n_info[REG_N_CHECK (N)].last_uid)\n+#define REGNO_LAST_UID(N) (VARRAY_REG (reg_n_info, N)->last_uid)\n \n /* Similar, but includes insns that mention the reg in their notes.  */\n \n-#define REGNO_LAST_NOTE_UID(N) (reg_n_info[REG_N_CHECK (N)].last_note_uid)\n+#define REGNO_LAST_NOTE_UID(N) (VARRAY_REG (reg_n_info, N)->last_note_uid)\n \n /* This is reset to LAST_VIRTUAL_REGISTER + 1 at the start of each function.\n    After rtl generation, it is 1 plus the largest register number used.  */\n@@ -230,4 +221,4 @@ extern int *scratch_block;\n extern int scratch_list_length;\n \n /* Allocate reg_n_info tables */\n-extern void allocate_reg_info PROTO((int, int, int));\n+extern void allocate_reg_info PROTO((size_t, int, int));"}]}