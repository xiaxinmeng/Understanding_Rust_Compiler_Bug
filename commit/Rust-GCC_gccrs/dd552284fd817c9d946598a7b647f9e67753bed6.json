{"sha": "dd552284fd817c9d946598a7b647f9e67753bed6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ1NTIyODRmZDgxN2M5ZDk0NjU5OGE3YjY0N2Y5ZTY3NzUzYmVkNg==", "commit": {"author": {"name": "Walter Lee", "email": "walt@tilera.com", "date": "2012-02-14T10:02:21Z"}, "committer": {"name": "Walter Lee", "email": "walt@gcc.gnu.org", "date": "2012-02-14T10:02:21Z"}, "message": "Add ports for TILE-Gx and TILEPro.\n\n.\n\t* MAINTAINERS (tilegx port): Add myself.\n\t(tilepro port): Add myself.\n\ncontrib\n\t* config-list.mk (LIST): Add tilegx-linux-gnu and\n\ttilepro-linux-gnu.\n\t* gcc_update (gcc/config/tilegx/mul-tables.c): New dependencies.\n\t(gcc/config/tilepro/mul-tables.c): New dependencies.\n\ngcc\n\t* config.gcc: Handle tilegx and tilepro.\n\t* configure.ac (gcc_cv_as_dwarf2_debug_line): Enable test for\n\ttilegx and tilepro.\n\tAdd HAVE_AS_TLS check for tilegx and tilepro.\n\t* configure: Regenerate.\n\t* doc/contrib.texi: Add Mat Hostetter and self.\n\t* doc/extend.texi (TILE-Gx Built-in Functions): New node.\n\tDocument instruction intrinsics and network accessing intrinsics.\n\t(TILEPro Built-in Functions): New node.\t Document instruction\n\tintrinsics and network accessing intrinsics.\n\t* doc/install.texi (Specific, tilegx-*-linux*): Document it.\n\t(Specific, tilepro-*-linux*): Likewise.\n\t* doc/invoke.texi (TILE-Gx Options): New section.\n\t(TILEPro Options): New section.\n\t* doc/md.texi (TILE-Gx): New section.\n\t(TILEPro): New section.\n\t* common/config/tilegx: New directory for tilegx.\n\t* common/config/tilepro: New directory for tilepro.\n\t* config/tilegx: New directory for tilegx.\n\t* config/tilepro: New directory for tilepro.\n\ngcc/testsuite\n\t* g++.dg/other/PR23205.C: Disable test on tile.\n\t* g++.dg/other/pr23205-2.C: Disable test on tile.\n\t* gcc.dg/20020312-2.c: Add a condition for __tile__.\n\t* gcc.dg/20040813-1.c: Disable test on tile.\n\t* gcc.dg/lower-subreg-1.c: Disable test on tilegx.\n\t* gcc.misc-tests/linkage.exp: Handle tilegx.\n\nlibcpp\n\t* configure.ac: Require 64-bit hwint for tilegx and tilepro.\n\t* configure: Regenerate.\n\nlibgcc\n\t* config.host: Handle tilegx and tilepro.\n\t* config/tilegx: New directory for tilegx.\n\t* config/tilepro: New directory for tilepro.\n\nlibgomp\n\t* configure.tgt: Handle tilegx and tilepro.\n\t* config/linux/tile: New directory for tilegx and tilepro.\n\nAdded:\n     trunk/gcc/common/config/tilegx/tilegx-common.c\n     trunk/gcc/common/config/tilepro/tilepro-common.c\n     trunk/gcc/config/tilegx/constraints.md\n     trunk/gcc/config/tilegx/linux.h\n     trunk/gcc/config/tilegx/mul-tables.c\n     trunk/gcc/config/tilegx/predicates.md\n     trunk/gcc/config/tilegx/sync.md\n     trunk/gcc/config/tilegx/t-tilegx\n     trunk/gcc/config/tilegx/tilegx-builtins.h\n     trunk/gcc/config/tilegx/tilegx-c.c\n     trunk/gcc/config/tilegx/tilegx-generic.md\n     trunk/gcc/config/tilegx/tilegx-modes.def\n     trunk/gcc/config/tilegx/tilegx-multiply.h\n     trunk/gcc/config/tilegx/tilegx-protos.h\n     trunk/gcc/config/tilegx/tilegx.c\n     trunk/gcc/config/tilegx/tilegx.h\n     trunk/gcc/config/tilegx/tilegx.md\n     trunk/gcc/config/tilegx/tilegx.opt\n     trunk/gcc/config/tilepro/constraints.md\n     trunk/gcc/config/tilepro/gen-mul-tables.cc\n     trunk/gcc/config/tilepro/linux.h\n     trunk/gcc/config/tilepro/mul-tables.c\n     trunk/gcc/config/tilepro/predicates.md\n     trunk/gcc/config/tilepro/t-tilepro\n     trunk/gcc/config/tilepro/tilepro-builtins.h\n     trunk/gcc/config/tilepro/tilepro-c.c\n     trunk/gcc/config/tilepro/tilepro-generic.md\n     trunk/gcc/config/tilepro/tilepro-modes.def\n     trunk/gcc/config/tilepro/tilepro-multiply.h\n     trunk/gcc/config/tilepro/tilepro-protos.h\n     trunk/gcc/config/tilepro/tilepro.c\n     trunk/gcc/config/tilepro/tilepro.h\n     trunk/gcc/config/tilepro/tilepro.md\n     trunk/gcc/config/tilepro/tilepro.opt\n     trunk/libgcc/config/tilegx/sfp-machine.h\n     trunk/libgcc/config/tilegx/sfp-machine32.h\n     trunk/libgcc/config/tilegx/sfp-machine64.h\n     trunk/libgcc/config/tilegx/t-crtstuff\n     trunk/libgcc/config/tilegx/t-softfp\n     trunk/libgcc/config/tilegx/t-tilegx\n     trunk/libgcc/config/tilepro/atomic.c\n     trunk/libgcc/config/tilepro/atomic.h\n     trunk/libgcc/config/tilepro/linux-unwind.h\n     trunk/libgcc/config/tilepro/sfp-machine.h\n     trunk/libgcc/config/tilepro/softdivide.c\n     trunk/libgcc/config/tilepro/softmpy.S\n     trunk/libgcc/config/tilepro/t-crtstuff\n     trunk/libgcc/config/tilepro/t-tilepro\n     trunk/libgomp/config/linux/tile/futex.h\nModified:\n     trunk/MAINTAINERS\n     trunk/contrib/config-list.mk\n     trunk/contrib/gcc_update\n     trunk/gcc/config.gcc\n     trunk/gcc/configure\n     trunk/gcc/configure.ac\n     trunk/gcc/doc/contrib.texi\n     trunk/gcc/doc/extend.texi\n     trunk/gcc/doc/install.texi\n     trunk/gcc/doc/invoke.texi\n     trunk/gcc/doc/md.texi\n     trunk/gcc/testsuite/g++.dg/other/PR23205.C\n     trunk/gcc/testsuite/g++.dg/other/pr23205-2.C\n     trunk/gcc/testsuite/gcc.dg/20020312-2.c\n     trunk/gcc/testsuite/gcc.dg/20040813-1.c\n     trunk/gcc/testsuite/gcc.dg/lower-subreg-1.c\n     trunk/gcc/testsuite/gcc.misc-tests/linkage.exp\n     trunk/libcpp/configure\n     trunk/libcpp/configure.ac\n     trunk/libgcc/config.host\n     trunk/libgomp/configure.tgt\n\nFrom-SVN: r184203", "tree": {"sha": "2ebff3fcffa7603a372455fbc14c68ad06466730", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ebff3fcffa7603a372455fbc14c68ad06466730"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd552284fd817c9d946598a7b647f9e67753bed6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd552284fd817c9d946598a7b647f9e67753bed6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd552284fd817c9d946598a7b647f9e67753bed6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd552284fd817c9d946598a7b647f9e67753bed6/comments", "author": {"login": "walt-tilera", "id": 6602917, "node_id": "MDQ6VXNlcjY2MDI5MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/6602917?v=4", "gravatar_id": "", "url": "https://api.github.com/users/walt-tilera", "html_url": "https://github.com/walt-tilera", "followers_url": "https://api.github.com/users/walt-tilera/followers", "following_url": "https://api.github.com/users/walt-tilera/following{/other_user}", "gists_url": "https://api.github.com/users/walt-tilera/gists{/gist_id}", "starred_url": "https://api.github.com/users/walt-tilera/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/walt-tilera/subscriptions", "organizations_url": "https://api.github.com/users/walt-tilera/orgs", "repos_url": "https://api.github.com/users/walt-tilera/repos", "events_url": "https://api.github.com/users/walt-tilera/events{/privacy}", "received_events_url": "https://api.github.com/users/walt-tilera/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "62513f7bedaa6e0467da08030b61a35a1b83ab39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62513f7bedaa6e0467da08030b61a35a1b83ab39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62513f7bedaa6e0467da08030b61a35a1b83ab39"}], "stats": {"total": 71566, "additions": 71556, "deletions": 10}, "files": [{"sha": "3a14fa7b6d52bc711453e063e4b68d1f11d0ef41", "filename": "ChangeLog", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -1,6 +1,8 @@\n 2012-02-14  Walter Lee  <walt@tilera.com>\n \n-\t* MAINTAINERS (Write After Approval): Add myself.\n+\t* MAINTAINERS (tilegx port): Add myself.\n+\t(tilepro port): Add myself.\n+\t(Write After Approval): Add myself.\n \n 2012-02-12  Gerald Pfeifer  <gerald@pfeifer.com>\n "}, {"sha": "2c8f466bc6e08c8f3bdb965811c16373c18e8639", "filename": "MAINTAINERS", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -104,6 +104,8 @@ sparc port\t\tEric Botcazou\t\tebotcazou@libertysurf.fr\n spu port\t\tTrevor Smigiel\t\ttrevor_smigiel@playstation.sony.com\n spu port\t\tDavid Edelsohn\t\tdje.gcc@gmail.com\n spu port\t\tUlrich Weigand\t\tuweigand@de.ibm.com\n+tilegx port\t\tWalter Lee\t\twalt@tilera.com\n+tilepro port\t\tWalter Lee\t\twalt@tilera.com\n v850 port\t\tNick Clifton\t\tnickc@redhat.com\n vax port\t\tMatt Thomas\t\tmatt@3am-software.com\n x86-64 port\t\tJan Hubicka\t\tjh@suse.cz"}, {"sha": "789f345e0f537e907b227f6884bf4d5df09f3ee9", "filename": "contrib/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -1,3 +1,10 @@\n+2012-02-14  Walter Lee  <walt@tilera.com>\n+\n+\t* config-list.mk (LIST): Add tilegx-linux-gnu and\n+\ttilepro-linux-gnu.\n+\t* gcc_update (gcc/config/tilegx/mul-tables.c): New dependencies.\n+\t(gcc/config/tilepro/mul-tables.c): New dependencies.\n+\n 2012-02-11  Mike Stump  <mikestump@comcast.net>\n \n \t* compare_tests (exit_status): Fix."}, {"sha": "108f84d85cf7c595b5a1e3dec45e11e126865bb4", "filename": "contrib/config-list.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/contrib%2Fconfig-list.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/contrib%2Fconfig-list.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fconfig-list.mk?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -60,7 +60,8 @@ LIST = alpha-linux-gnu alpha-freebsd6 alpha-netbsd alpha-openbsd \\\n   sparc-leon3-linux-gnuOPT-enable-target=all sparc-netbsdelf \\\n   sparc64-sun-solaris2.10OPT-with-gnu-ldOPT-with-gnu-asOPT-enable-threads=posix \\\n   sparc-wrs-vxworks sparc64-elf sparc64-rtems sparc64-linux sparc64-freebsd6 \\\n-  sparc64-netbsd sparc64-openbsd spu-elf v850e-elf v850-elf vax-linux-gnu \\\n+  sparc64-netbsd sparc64-openbsd spu-elf tilegx-linux-gnu tilepro-linux-gnu \\\n+  v850e-elf v850-elf vax-linux-gnu \\\n   vax-netbsdelf vax-openbsd x86_64-apple-darwin \\\n   x86_64-pc-linux-gnuOPT-with-fpmath=avx \\\n   x86_64-elfOPT-with-fpmath=sse x86_64-freebsd6 x86_64-netbsd \\"}, {"sha": "0289d9b2663dde2bb3152b4d72b1a85d26565bc5", "filename": "contrib/gcc_update", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/contrib%2Fgcc_update", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/contrib%2Fgcc_update", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc_update?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -90,6 +90,8 @@ gcc/config/c6x/c6x-mult.md: gcc/config/c6x/c6x-mult.md.in gcc/config/c6x/genmult\n gcc/config/m68k/m68k-tables.opt: gcc/config/m68k/m68k-devices.def gcc/config/m68k/m68k-isas.def gcc/config/m68k/m68k-microarchs.def gcc/config/m68k/genopt.sh\n gcc/config/mips/mips-tables.opt: gcc/config/mips/mips-cpus.def gcc/config/mips/genopt.sh\n gcc/config/rs6000/rs6000-tables.opt: gcc/config/rs6000/rs6000-cpus.def gcc/config/rs6000/genopt.sh\n+gcc/config/tilegx/mul-tables.c: gcc/config/tilepro/gen-mul-tables.cc\n+gcc/config/tilepro/mul-tables.c: gcc/config/tilepro/gen-mul-tables.cc\n # And then, language-specific files\n gcc/cp/cfns.h: gcc/cp/cfns.gperf\n gcc/java/keyword.h: gcc/java/keyword.gperf"}, {"sha": "eca470c3cc87eb78e782b0aac507eea900d9a7f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -1,3 +1,56 @@\n+2012-02-14  Walter Lee  <walt@tilera.com>\n+\n+\t* config.gcc: Handle tilegx and tilepro.\n+\t* configure.ac (gcc_cv_as_dwarf2_debug_line): Enable test for\n+\ttilegx and tilepro.\n+\tAdd HAVE_AS_TLS check for tilegx and tilepro.\n+\t* configure: Regenerate.\n+\t* doc/contrib.texi: Add Mat Hostetter and self.\n+\t* doc/extend.texi (TILE-Gx Built-in Functions): New node.\n+\tDocument instruction intrinsics and network accessing intrinsics.\n+\t(TILEPro Built-in Functions): New node.  Document instruction\n+\tintrinsics and network accessing intrinsics.\n+\t* doc/install.texi (Specific, tilegx-*-linux*): Document it.\n+\t(Specific, tilepro-*-linux*): Likewise.\n+\t* doc/invoke.texi (TILE-Gx Options): New section.\n+\t(TILEPro Options): New section.\n+\t* doc/md.texi (TILE-Gx): New section.\n+\t(TILEPro): New section.\n+\t* common/config/tilegx/tilegx-common.c: New file.\n+\t* common/config/tilepro/tilepro-common.c: New file.\n+\t* config/tilegx/constraints.md: New file.\n+\t* config/tilegx/linux.h: New file.\n+\t* config/tilegx/mul-tables.c: New file.\n+\t* config/tilegx/predicates.md: New file.\n+\t* config/tilegx/sync.md: New file.\n+\t* config/tilegx/t-tilegx: New file.\n+\t* config/tilegx/tilegx-builtins.h: New file.\n+\t* config/tilegx/tilegx-c.c: New file.\n+\t* config/tilegx/tilegx-generic.md: New file.\n+\t* config/tilegx/tilegx-modes.def: New file.\n+\t* config/tilegx/tilegx-multiply.h: New file.\n+\t* config/tilegx/tilegx-protos.h: New file.\n+\t* config/tilegx/tilegx.c: New file.\n+\t* config/tilegx/tilegx.h: New file.\n+\t* config/tilegx/tilegx.md: New file.\n+\t* config/tilegx/tilegx.opt: New file.\n+\t* config/tilepro/constraints.md: New file.\n+\t* config/tilepro/gen-mul-tables.cc: New file.\n+\t* config/tilepro/linux.h: New file.\n+\t* config/tilepro/mul-tables.c: New file.\n+\t* config/tilepro/predicates.md: New file.\n+\t* config/tilepro/t-tilepro: New file.\n+\t* config/tilepro/tilepro-builtins.h: New file.\n+\t* config/tilepro/tilepro-c.c: New file.\n+\t* config/tilepro/tilepro-generic.md: New file.\n+\t* config/tilepro/tilepro-modes.def: New file.\n+\t* config/tilepro/tilepro-multiply.h: New file.\n+\t* config/tilepro/tilepro-protos.h: New file.\n+\t* config/tilepro/tilepro.c: New file.\n+\t* config/tilepro/tilepro.h: New file.\n+\t* config/tilepro/tilepro.md: New file.\n+\t* config/tilepro/tilepro.opt: New file.\n+\n 2012-02-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/52210"}, {"sha": "7ee29b76bf70f57cf95fc460b36ad69c3c3ee4f2", "filename": "gcc/common/config/tilegx/tilegx-common.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fcommon%2Fconfig%2Ftilegx%2Ftilegx-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fcommon%2Fconfig%2Ftilegx%2Ftilegx-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Ftilegx%2Ftilegx-common.c?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,55 @@\n+/* Common hooks for TILE-Gx.\n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"diagnostic-core.h\"\n+#include \"tm.h\"\n+#include \"common/common-target.h\"\n+#include \"common/common-target-def.h\"\n+#include \"opts.h\"\n+#include \"flags.h\"\n+\n+static const struct default_options tilegx_option_optimization_table[] = {\n+  {OPT_LEVELS_1_PLUS, OPT_fomit_frame_pointer, NULL, 1},\n+  /* Scheduling and bundling are super important for our architecture, so\n+     enable them at -O1. */\n+  {OPT_LEVELS_1_PLUS, OPT_fschedule_insns, NULL, 1},\n+  {OPT_LEVELS_1_PLUS, OPT_fschedule_insns2, NULL, 1},\n+  {OPT_LEVELS_NONE, 0, NULL, 0}\n+};\n+\n+\n+static void\n+tilegx_option_init_struct (struct gcc_options *opts)\n+{\n+  opts->x_flag_asynchronous_unwind_tables = 1;\n+}\n+\n+\n+#undef  TARGET_OPTION_OPTIMIZATION_TABLE\n+#define TARGET_OPTION_OPTIMIZATION_TABLE tilegx_option_optimization_table\n+\n+#undef  TARGET_OPTION_INIT_STRUCT\n+#define TARGET_OPTION_INIT_STRUCT tilegx_option_init_struct\n+\n+struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;"}, {"sha": "01ceb7f248c8285bb80620ebf7b941d2229b9675", "filename": "gcc/common/config/tilepro/tilepro-common.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fcommon%2Fconfig%2Ftilepro%2Ftilepro-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fcommon%2Fconfig%2Ftilepro%2Ftilepro-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Ftilepro%2Ftilepro-common.c?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,56 @@\n+/* Common hooks for TILEPro.\n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"diagnostic-core.h\"\n+#include \"tm.h\"\n+#include \"common/common-target.h\"\n+#include \"common/common-target-def.h\"\n+#include \"opts.h\"\n+#include \"flags.h\"\n+\n+static const struct default_options tilepro_option_optimization_table[] = {\n+  {OPT_LEVELS_1_PLUS, OPT_fomit_frame_pointer, NULL, 1},\n+  /* Scheduling and bundling are super important for our architecture, so\n+     enable them at -O1. */\n+  {OPT_LEVELS_1_PLUS, OPT_fschedule_insns, NULL, 1},\n+  {OPT_LEVELS_1_PLUS, OPT_fschedule_insns2, NULL, 1},\n+  {OPT_LEVELS_NONE, 0, NULL, 0}\n+};\n+\n+\n+static void\n+tilepro_option_init_struct (struct gcc_options *opts)\n+{\n+  opts->x_flag_asynchronous_unwind_tables = 1;\n+}\n+\n+\n+\n+#undef  TARGET_OPTION_OPTIMIZATION_TABLE\n+#define TARGET_OPTION_OPTIMIZATION_TABLE tilepro_option_optimization_table\n+\n+#undef  TARGET_OPTION_INIT_STRUCT\n+#define TARGET_OPTION_INIT_STRUCT tilepro_option_init_struct\n+\n+struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;"}, {"sha": "bdd5eb3189040066bb5c91f8663a8e455dbe07e2", "filename": "gcc/config.gcc", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -448,6 +448,14 @@ tic6x-*-*)\n xtensa*-*-*)\n \textra_options=\"${extra_options} fused-madd.opt\"\n \t;;\n+tilegx*-*-*)\n+\tcpu_type=tilegx\n+\tneed_64bit_hwint=yes\n+\t;;\n+tilepro-*-*)\n+\tcpu_type=tilepro\n+\tneed_64bit_hwint=yes\n+\t;;\n esac\n \n tm_file=${cpu_type}/${cpu_type}.h\n@@ -2468,6 +2476,20 @@ tic6x-*-uclinux)\n \ttmake_file=\"${tmake_file} c6x/t-c6x c6x/t-c6x-elf c6x/t-c6x-uclinux\"\n \tuse_collect2=no\n \t;;\n+tilegx-*-linux*)\n+\ttm_file=\"elfos.h gnu-user.h linux.h glibc-stdint.h tilegx/linux.h ${tm_file}\"\n+        tmake_file=\"${tmake_file} tilegx/t-tilegx\"\n+\textra_objs=\"mul-tables.o\"\n+\tc_target_objs=\"tilegx-c.o\"\n+\tcxx_target_objs=\"tilegx-c.o\"\n+\t;;\n+tilepro-*-linux*)\n+\ttm_file=\"elfos.h gnu-user.h linux.h glibc-stdint.h tilepro/linux.h ${tm_file}\"\n+        tmake_file=\"${tmake_file} tilepro/t-tilepro\"\n+\textra_objs=\"mul-tables.o\"\n+\tc_target_objs=\"tilepro-c.o\"\n+\tcxx_target_objs=\"tilepro-c.o\"\n+\t;;\n v850*-*-*)\n \tcase ${target} in\n \tv850e2v3-*-*)"}, {"sha": "fcbd22070686d1fdf8743fec45dbf40561c3d337", "filename": "gcc/config/tilegx/constraints.md", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Fconstraints.md?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,123 @@\n+;; Constraint definitions for Tilera TILE-Gx.\n+;; Copyright (C) 2011, 2012\n+;; Free Software Foundation, Inc.\n+;; Contributed by Walter Lee (walt@tilera.com)\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_register_constraint \"R00\" \"R0_REGS\"  \"r0\")\n+(define_register_constraint \"R01\" \"R1_REGS\"  \"r1\")\n+(define_register_constraint \"R02\" \"R2_REGS\"  \"r2\")\n+(define_register_constraint \"R03\" \"R3_REGS\"  \"r3\")\n+(define_register_constraint \"R04\" \"R4_REGS\"  \"r4\")\n+(define_register_constraint \"R05\" \"R5_REGS\"  \"r5\")\n+(define_register_constraint \"R06\" \"R6_REGS\"  \"r6\")\n+(define_register_constraint \"R07\" \"R7_REGS\"  \"r7\")\n+(define_register_constraint \"R08\" \"R8_REGS\"  \"r8\")\n+(define_register_constraint \"R09\" \"R9_REGS\"  \"r9\")\n+(define_register_constraint \"R10\" \"R10_REGS\" \"r10\")\n+\n+(define_constraint \"I\"\n+  \"A signed 8 bit constant\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -128 && ival <= 127\")))\n+\n+(define_constraint \"J\"\n+  \"Signed 16-bit integer constant\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -32768 && ival <= 32767\")))\n+\n+(define_constraint \"K\"\n+  \"Unsigned 16-bit integer constant\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(ival >= 0 && ival <= 65535)\")))\n+\n+(define_constraint \"L\"\n+  \"Integer constant that fits in one signed byte when incremented\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -129 && ival <= 126\")))\n+\n+(define_constraint \"M\"\n+  \"A bit mask suitable for 'bfins'\"\n+  (and (match_code \"const_int\")\n+       (match_test \"tilegx_bitfield_operand_p (ival, NULL, NULL)\")))\n+\n+(define_constraint \"N\"\n+  \"Integer constant that is a byte tiled out eight times\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(ival == (ival & 0xFF) * 0x0101010101010101LL)\")))\n+\n+(define_constraint \"O\"\n+ \"The integer zero constant\"\n+ (and (match_code \"const_int\")\n+      (match_test \"ival == 0\")))\n+\n+(define_constraint \"P\"\n+  \"Integer constant that is a sign-extended byte tiled out as four shorts\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(ival\n+                     == ((trunc_int_for_mode (ival, QImode) & 0xFFFF)\n+                         * 0x0001000100010001LL))\")))\n+\n+(define_constraint \"Q\"\n+  \"Integer constant that fits in one signed byte when incremented, but not -1\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -129 && ival <= 126 && ival != -1\")))\n+\n+(define_constraint \"S\"\n+  \"Integer constant that has all 1 bits consecutive and starting at bit 0\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival != 0 && (ival & (ival + 1)) == 0\")))\n+\n+(define_constraint \"T\"\n+  \"An unspec wrapper for a symbolc operand\"\n+  (ior (match_operand 0 \"const_last_symbolic_operand\")\n+       (match_operand 0 \"const_symbolic_operand\")))\n+\n+(define_memory_constraint \"U\"\n+  \"Non-auto-incrementing memory\"\n+  (and (match_code \"mem\")\n+       (match_test \"GET_RTX_CLASS (GET_CODE (XEXP (op, 0))) != RTX_AUTOINC\")))\n+\n+(define_constraint \"W\"\n+  \"An 8-element vector constant with identical elements\"\n+  (and (match_code \"const_vector\")\n+       (match_test \"CONST_VECTOR_NUNITS (op) == 8\")\n+       (match_test \"CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 1)\")\n+       (match_test \"CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 2)\")\n+       (match_test \"CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 3)\")\n+       (match_test \"CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 4)\")\n+       (match_test \"CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 5)\")\n+       (match_test \"CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 6)\")\n+       (match_test \"CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 7)\")))\n+\n+(define_constraint \"Y\"\n+  \"A 4-element vector constant with identical elements\"\n+  (and (match_code \"const_vector\")\n+       (match_test \"CONST_VECTOR_NUNITS (op) == 4\")\n+       (match_test \"CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 1)\")\n+       (match_test \"CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 2)\")\n+       (match_test \"CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 3)\")))\n+(define_constraint \"Z0\"\n+ \"The integer constant 0xffffffff\"\n+ (and (match_code \"const_int\")\n+      (match_test \"ival == 0xffffffff\")))\n+\n+(define_constraint \"Z1\"\n+ \"The integer constant 0xffffffff00000000\"\n+ (and (match_code \"const_int\")\n+      (match_test \"ival == (HOST_WIDE_INT)0xffffffff00000000LL\")))"}, {"sha": "b42e2bb05369b3370efaf674626bceb571cd993b", "filename": "gcc/config/tilegx/linux.h", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Flinux.h?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,72 @@\n+/* Definitions for TILE-Gx running Linux-based GNU systems with ELF.\n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#undef CPP_SPEC\n+#define CPP_SPEC \"%{pthread:-D_REENTRANT}\"\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \"%{m32:--32} %{m64:--64}\"\n+\n+#undef\tLINK_SPEC\n+#define LINK_SPEC \"%{m64:-m elf64tilegx} %{m32:-m elf32tilegx} \\\n+  %{shared:-shared} \\\n+  %{!shared: \\\n+    %{!static: \\\n+      %{rdynamic:-export-dynamic} \\\n+      -dynamic-linker \\\n+        %{ m32: /lib32/ld.so.1} \\\n+        %{!m32: /lib/ld.so.1}} \\\n+    %{static:-static}}\"\n+\n+#define MULTILIB_DEFAULTS { \"m64\" }\n+\n+#define NO_PROFILE_COUNTERS\t1\n+\n+#undef MCOUNT_NAME\n+#define MCOUNT_NAME \"__mcount\"\n+\n+#undef NEED_INDICATE_EXEC_STACK\n+#define NEED_INDICATE_EXEC_STACK 1\n+\n+#ifdef TARGET_LIBC_PROVIDES_SSP\n+/* TILE-Gx glibc provides __stack_chk_guard two pointer-size words before\n+   tp. */\n+#define TARGET_THREAD_SSP_OFFSET (-2 * GET_MODE_SIZE (ptr_mode))\n+#endif\n+\n+/* For __clear_cache in libgcc2.c.  */\n+#ifdef IN_LIBGCC2\n+\n+#include <arch/icache.h>\n+\n+/* Use the minimum page size of 4K.  Alternatively we can call\n+   getpagesize() but it introduces a libc dependence.  */\n+#undef CLEAR_INSN_CACHE\n+#define CLEAR_INSN_CACHE(beg, end) invalidate_icache (beg, end - beg, 4096)\n+\n+#else\n+\n+/* define CLEAR_INSN_CACHE so that gcc knows to expand __builtin__clear_cache\n+   to the libraray call.  */\n+#undef CLEAR_INSN_CACHE\n+#define CLEAR_INSN_CACHE 1\n+\n+#endif"}, {"sha": "b7d171f192e0c2f401d044ed4cb118713b897556", "filename": "gcc/config/tilegx/mul-tables.c", "status": "added", "additions": 27244, "deletions": 0, "changes": 27244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Fmul-tables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Fmul-tables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Fmul-tables.c?ref=dd552284fd817c9d946598a7b647f9e67753bed6"}, {"sha": "5a493ff6df01308a0ae754d2705d6fdf6b5e9f09", "filename": "gcc/config/tilegx/predicates.md", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Fpredicates.md?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,293 @@\n+;; Predicate definitions for Tilera TILE-Gx.\n+;; Copyright (C) 2011, 2012\n+;; Free Software Foundation, Inc.\n+;; Contributed by Walter Lee (walt@tilera.com)\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; Return true if OP is the zero constant for MODE.\n+(define_predicate \"const_zero_operand\"\n+  (and (match_code \"const_int,const_double,const_vector\")\n+       (match_test \"op == CONST0_RTX (mode)\")))\n+\n+;; Returns true if OP is either the constant zero or a register.\n+(define_predicate \"reg_or_0_operand\"\n+  (and (ior (match_operand 0 \"register_operand\")\n+\t    (match_operand 0 \"const_zero_operand\"))\n+       (match_test \"GET_MODE_SIZE (mode) <= UNITS_PER_WORD\")))\n+\n+; Return 1 if OP is a valid Pmode pointer.\n+(define_predicate \"pointer_operand\"\n+  (and (match_operand 0 \"address_operand\")\n+       (ior (match_operand 0 \"pmode_register_operand\")\n+\t    (match_operand 0 \"const_zero_operand\"))))\n+\n+; Return 1 if OP is a network register identifier.\n+(define_predicate \"netreg_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 5)\")))\n+\n+; Return 1 if OP is an unsigned 6-bit constant.\n+(define_predicate \"u6bit_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) == (INTVAL (op) & 0x3F)\")))\n+\n+;; Return 1 if OP is an unsigned 16-bit constant.\n+(define_predicate \"u16bit_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(unsigned HOST_WIDE_INT)INTVAL (op) < (1U << 16)\")))\n+\n+;; Return 1 if OP is a signed 8-bit constant.\n+(define_predicate \"s8bit_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"satisfies_constraint_I (op)\")))\n+\n+;; Return 1 if OP is a signed 16-bit constant.\n+(define_predicate \"s16bit_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"satisfies_constraint_J (op)\")))\n+\n+;; Return 1 if OP is an unsigned 14-bit constant.\n+(define_predicate \"u14bit_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(unsigned HOST_WIDE_INT)INTVAL (op) < (1U << 14)\")))\n+\n+;; Return 1 if OP is a constant or any register.\n+(define_predicate \"reg_or_cint_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"const_int_operand\")))\n+\n+;; Returns 1 if OP is a \"last\" unspec wrapper for a symbol, got, or\n+;; tls reference.\n+(define_predicate \"const_last_symbolic_operand\"\n+  (and (match_code \"const\")\n+       (match_test \"GET_CODE (XEXP (op,0)) == UNSPEC\")\n+       (ior (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_LAST\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_LAST\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW2_LAST\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_LAST_PCREL\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_LAST_GOT\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_LAST_GOT\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_LAST_TLS_GD\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_LAST_TLS_IE\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_LAST_TLS_LE\"))))\n+\n+;; Returns 1 if OP is an unspec wrapper for a symbol, got, or tls\n+;; reference.\n+(define_predicate \"const_symbolic_operand\"\n+  (and (match_code \"const\")\n+       (match_test \"GET_CODE (XEXP (op,0)) == UNSPEC\")\n+       (ior (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW2\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW3\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_PCREL\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_GOT\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_TLS_GD\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_TLS_IE\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_TLS_LE\"))))\n+\n+;; Return 1 if OP is a 8-element vector constant with identical signed\n+;; 8-bit elements or any register.\n+(define_predicate \"reg_or_v8s8bit_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_code \"const_vector\")\n+\t    (match_test \"CONST_VECTOR_NUNITS (op) == 8\n+                         && satisfies_constraint_I (CONST_VECTOR_ELT (op, 0))\n+                         && CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 1)\n+                         && CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 2)\n+                         && CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 3)\n+                         && CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 4)\n+                         && CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 5)\n+                         && CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 6)\n+                         && CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 7)\"))))\n+\n+;; Return 1 if OP is a 4-element vector constant with identical signed\n+;; 8-bit elements or any register.\n+(define_predicate \"reg_or_v4s8bit_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_code \"const_vector\")\n+\t    (match_test \"CONST_VECTOR_NUNITS (op) == 4\n+                         && satisfies_constraint_I (CONST_VECTOR_ELT (op, 0))\n+                         && CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 1)\n+                         && CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 2)\n+                         && CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 3)\"))))\n+\n+;; Return 1 if the operand is a valid second operand to an add insn.\n+(define_predicate \"add_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"satisfies_constraint_J (op)\")\n+    (ior (match_operand 0 \"register_operand\")\n+\t (match_operand 0 \"const_last_symbolic_operand\"))))\n+\n+;; Return 1 if the operand is a register or signed 8-bit immediate operand.\n+(define_predicate \"reg_or_s8bit_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"satisfies_constraint_I (op)\")\n+    (match_operand 0 \"register_operand\")))\n+\n+;; Return 1 if the operand is a register or unsigned 5-bit immediate operand.\n+(define_predicate \"reg_or_u5bit_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"INTVAL (op) == (INTVAL (op) & 0x1F)\")\n+    (match_operand 0 \"register_operand\")))\n+\n+;; Return 1 if the operand is a register or unsigned 6-bit immediate operand.\n+(define_predicate \"reg_or_u6bit_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"INTVAL (op) == (INTVAL (op) & 0x3F)\")\n+    (match_operand 0 \"register_operand\")))\n+\n+;; Return 1 for an operand suitable for ANDing with a register.\n+(define_predicate \"and_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"satisfies_constraint_I (op) || satisfies_constraint_M (op)\")\n+    (match_operand 0 \"register_operand\")))\n+\n+; Return 1 if the operand is 2, 4 or 8.\n+(define_predicate \"cint_248_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test\n+        \"INTVAL (op) == 2 || INTVAL (op) == 4 || INTVAL (op) == 8\")))\n+\n+;; Return true if OP is a TLS symbolic operand.\n+(define_predicate \"tls_symbolic_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"SYMBOL_REF_TLS_MODEL (op) !=  TLS_MODEL_NONE\")))\n+\n+;; Return true if OP is a symbolic operand for the TLS Global Dynamic model.\n+(define_predicate \"tls_gd_symbolic_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_GLOBAL_DYNAMIC\")))\n+\n+;; Return true if OP is a symbolic operand for the TLS Local Dynamic model.\n+(define_predicate \"tls_ld_symbolic_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_DYNAMIC\")))\n+\n+;; Return true if OP is a symbolic operand that can be used for the\n+;; TLS Initial Exec model.\n+(define_predicate \"tls_ie_symbolic_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (ior (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_INITIAL_EXEC\")\n+            (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_EXEC\"))))\n+\n+;; Return true if OP is a symbolic operand for the TLS Local Exec model.\n+(define_predicate \"tls_le_symbolic_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_EXEC\")))\n+\n+;; Returns true if OP is any general operand except for an\n+;; auto-incrementing address operand.\n+(define_predicate \"nonautoinc_operand\"\n+  (and (match_operand 0 \"general_operand\")\n+       (not (ior (match_code \"pre_dec\") (match_code \"pre_inc\")\n+\t\t (match_code \"post_dec\") (match_code \"post_inc\")\n+\t\t (match_code \"post_modify\") (match_code \"pre_modify\")))))\n+ \n+;; Returns true if OP is a non-auto-incrementing memory operand.\n+(define_predicate \"nonautoincmem_operand\"\n+  (match_operand 0 \"memory_operand\")\n+{\n+  return nonautoinc_operand (XEXP (op, 0), GET_MODE (XEXP (op, 0)));\n+})\n+\n+;; Returns true if OP is a non-auto-incrementing memory, general\n+;; operand.\n+(define_predicate \"nonautoincmem_general_operand\"\n+  (match_operand 0 \"general_operand\")\n+{\n+  if (memory_operand (op, mode))\n+    return nonautoinc_operand (XEXP (op, 0), GET_MODE (XEXP (op, 0)));\n+  else\n+    return true;\n+})\n+ \n+;; Returns true if OP is a non-auto-incrementing memory, non-immediate\n+;; operand.\n+(define_predicate \"nonautoincmem_nonimmediate_operand\"\n+  (match_operand 0 \"nonimmediate_operand\")\n+{\n+  if (memory_operand (op, mode))\n+    return nonautoinc_operand (XEXP (op, 0), GET_MODE (XEXP (op, 0)));\n+  else\n+    return true;\n+})\n+ \n+;; Return true if OP is a valid operand for the source of a move insn.\n+(define_predicate \"move_operand\"\n+  (match_operand 0 \"general_operand\")\n+{\n+  /* If both modes are non-void they must be the same.  */\n+  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n+    return false;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case CONST_INT:\n+      return (satisfies_constraint_J (op)\n+              || satisfies_constraint_K (op)\n+              || (mode == DImode &&\n+                  (satisfies_constraint_N (op)\n+                   || satisfies_constraint_P (op))));\n+\n+    case MEM:\n+      return memory_address_p (mode, XEXP (op, 0));\n+\n+    case CONST:\n+      return const_last_symbolic_operand (op, mode);\n+\n+    default:\n+      return register_operand (op, mode);\n+    }\n+})\n+\n+;; Returns 1 if OP is a symbolic operand, i.e. a symbol_ref or a label_ref,\n+;; possibly with an offset.\n+(define_predicate \"symbolic_operand\"\n+  (ior (match_code \"symbol_ref,label_ref\")\n+       (and (match_code \"const\")\n+\t    (match_test \"GET_CODE (XEXP (op,0)) == PLUS\n+\t\t\t && (GET_CODE (XEXP (XEXP (op,0), 0)) == SYMBOL_REF\n+\t\t\t     || GET_CODE (XEXP (XEXP (op,0), 0)) == LABEL_REF)\n+\t\t\t && CONST_INT_P (XEXP (XEXP (op,0), 1))\"))))\n+\n+;; Return 1 for an unsigned 16 bit or a const symbolc operand.\n+(define_predicate \"u16bit_or_const_symbolic_operand\"\n+  (ior (match_operand 0 \"u16bit_cint_operand\")\n+       (match_operand 0 \"const_symbolic_operand\")))\n+\n+;; Return true if OP is an address suitable for a call insn.\n+;; Call insn on TILE can take a PC-relative constant address\n+;; or any regular memory address.\n+(define_predicate \"call_address_operand\"\n+  (ior (match_operand 0 \"symbolic_operand\")\n+       (match_test \"memory_address_p (Pmode, op)\")))\n+\n+;; Return true if OP is an operand suitable for a call insn.\n+(define_predicate \"call_operand\"\n+  (and (match_code \"mem\")\n+       (match_test \"call_address_operand (XEXP (op, 0), mode)\")))\n+\n+;; Return 1 if OP is a signed comparison operation.\n+;; We can use these directly in compares against zero.\n+(define_predicate \"signed_comparison_operator\"\n+  (match_code \"eq,ne,le,lt,ge,gt\"))\n+\n+;; Return 1 if OP is a equal or not-equal operation.\n+(define_predicate \"eqne_operator\"\n+  (match_code \"eq,ne\"))"}, {"sha": "8be762af004fcfc51fc2078308d10d9031dbd3da", "filename": "gcc/config/tilegx/sync.md", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Fsync.md?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,165 @@\n+;; GCC machine description for Tilera TILE-Gx synchronization\n+;; instructions.\n+;; Copyright (C) 2011, 2012\n+;; Free Software Foundation, Inc.\n+;; Contributed by Walter Lee (walt@tilera.com)\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_code_iterator fetchop [plus ior and])\n+(define_code_attr fetchop_name [(plus \"add\") (ior \"or\") (and \"and\")])\n+\n+(define_insn \"mtspr_cmpexch<mode>\"\n+  [(set (reg:I48MODE TILEGX_CMPEXCH_REG)\n+        (unspec_volatile:I48MODE\n+         [(match_operand:I48MODE 0 \"reg_or_0_operand\" \"rO\")]\n+         UNSPEC_SPR_MOVE))]\n+  \"\"\n+  \"mtspr\\tCMPEXCH_VALUE, %r0\"\n+  [(set_attr \"type\" \"X1\")])\n+\n+\n+(define_expand \"atomic_compare_and_swap<mode>\"\n+  [(match_operand:DI 0 \"register_operand\" \"\")\t\t;; bool output\n+   (match_operand:I48MODE 1 \"register_operand\" \"\")\t;; val output\n+   (match_operand:I48MODE 2 \"nonautoincmem_operand\" \"\") ;; memory\n+   (match_operand:I48MODE 3 \"reg_or_0_operand\" \"\")\t;; expected value\n+   (match_operand:I48MODE 4 \"reg_or_0_operand\" \"\")\t;; desired value\n+   (match_operand:SI 5 \"const_int_operand\" \"\")\t\t;; is_weak\n+   (match_operand:SI 6 \"const_int_operand\" \"\")\t\t;; mod_s\n+   (match_operand:SI 7 \"const_int_operand\" \"\")]\t\t;; mod_f\n+  \"\"\n+{\n+  enum memmodel mod_s = (enum memmodel) INTVAL (operands[6]);\n+\n+  if (operands[3] != const0_rtx)\n+    operands[3] = force_reg (<MODE>mode, operands[3]);\n+  if (operands[4] != const0_rtx)\n+    operands[4] = force_reg (<MODE>mode, operands[4]);\n+\n+  tilegx_pre_atomic_barrier (mod_s);\n+  emit_insn (gen_mtspr_cmpexch<mode> (operands[3]));\n+  emit_insn (gen_atomic_compare_and_swap_bare<mode> (operands[1], operands[2],\n+                                                   operands[4]));\n+  tilegx_post_atomic_barrier (mod_s);\n+  emit_insn (gen_insn_cmpeq_<mode>di (operands[0], operands[1], operands[3]));\n+  DONE;\n+})\n+\n+\n+(define_insn \"atomic_compare_and_swap_bare<mode>\"\n+  [(set (match_operand:I48MODE 0 \"register_operand\" \"=r\")\n+        (match_operand:I48MODE 1 \"nonautoincmem_operand\" \"+U\"))\n+   (set (match_dup 1)\n+        (unspec_volatile:I48MODE\n+         [(match_dup 1)\n+         (reg:I48MODE TILEGX_CMPEXCH_REG)\n+         (match_operand:I48MODE 2 \"reg_or_0_operand\" \"rO\")]\n+         UNSPEC_CMPXCHG))]\n+  \"\"\n+  \"cmpexch<four_if_si>\\t%0, %1, %r2\"\n+  [(set_attr \"type\" \"X1_L2\")])\n+\n+\n+(define_expand \"atomic_exchange<mode>\"\n+  [(match_operand:I48MODE 0 \"register_operand\" \"\")      ;; result\n+   (match_operand:I48MODE 1 \"nonautoincmem_operand\" \"\") ;; memory\n+   (match_operand:I48MODE 2 \"reg_or_0_operand\" \"\")      ;; input\n+   (match_operand:SI 3 \"const_int_operand\" \"\")]         ;; model\n+  \"\"\n+{\n+  enum memmodel model = (enum memmodel) INTVAL (operands[3]);\n+\n+  tilegx_pre_atomic_barrier (model);\n+  emit_insn (gen_atomic_exchange_bare<mode> (operands[0], operands[1],\n+                                             operands[2]));\n+  tilegx_post_atomic_barrier (model);\n+  DONE;\n+})\n+\n+\n+(define_insn \"atomic_exchange_bare<mode>\"\n+  [(set (match_operand:I48MODE 0 \"register_operand\" \"=r\")\n+\t(match_operand:I48MODE 1 \"nonautoincmem_operand\" \"+U\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:I48MODE\n+\t [(match_operand:I48MODE 2 \"reg_or_0_operand\" \"rO\")]\n+\t UNSPEC_XCHG))]\n+  \"\"\n+  \"exch<four_if_si>\\t%0, %1, %r2\"\n+  [(set_attr \"type\" \"X1_2cycle\")])\n+\n+\n+(define_expand \"atomic_fetch_<fetchop_name><mode>\"\n+  [(match_operand:I48MODE 0 \"register_operand\" \"\")      ;; result\n+   (match_operand:I48MODE 1 \"nonautoincmem_operand\" \"\") ;; memory\n+   (unspec_volatile:I48MODE\n+    [(fetchop:I48MODE\n+      (match_dup 1)\n+      (match_operand:I48MODE 2 \"reg_or_0_operand\" \"\"))] ;; value\n+    UNSPEC_ATOMIC)\n+   (match_operand:SI 3 \"const_int_operand\" \"\")]         ;; model\n+  \"\"\n+{\n+  enum memmodel model = (enum memmodel) INTVAL (operands[3]);\n+\n+  tilegx_pre_atomic_barrier (model);\n+  emit_insn (gen_atomic_fetch_<fetchop_name>_bare<mode> (operands[0],\n+                                                         operands[1],\n+                                                         operands[2]));\n+  tilegx_pre_atomic_barrier (model);\n+  DONE;\n+})\n+\n+\n+(define_insn \"atomic_fetch_<fetchop_name>_bare<mode>\"\n+  [(set (match_operand:I48MODE 0 \"register_operand\" \"=r\")\n+\t(match_operand:I48MODE 1 \"nonautoincmem_operand\" \"+U\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:I48MODE\n+\t [(fetchop:I48MODE\n+\t   (match_dup 1)\n+\t   (match_operand:I48MODE 2 \"reg_or_0_operand\" \"rO\"))]\n+\t   UNSPEC_ATOMIC))]\n+  \"\"\n+  \"fetch<fetchop_name><four_if_si>\\t%0, %1, %r2\"\n+  [(set_attr \"type\" \"X1_2cycle\")])\n+\n+\n+(define_expand \"atomic_fetch_sub<mode>\"\n+  [(match_operand:I48MODE 0 \"register_operand\" \"\")      ;; result\n+   (match_operand:I48MODE 1 \"nonautoincmem_operand\" \"\") ;; memory\n+   (unspec_volatile:I48MODE\n+    [(minus:I48MODE\n+      (match_dup 1)\n+      (match_operand:I48MODE 2 \"reg_or_0_operand\" \"\"))] ;; value\n+    UNSPEC_ATOMIC)\n+   (match_operand:SI 3 \"const_int_operand\" \"\")]         ;; model\n+  \"\"\n+{\n+  enum memmodel model = (enum memmodel) INTVAL (operands[3]);\n+\n+  if (operands[2] != const0_rtx)\n+    emit_move_insn (operands[2], gen_rtx_NEG (<MODE>mode, operands[2]));\n+\n+  tilegx_pre_atomic_barrier (model);\n+  emit_insn (gen_atomic_fetch_add_bare<mode> (operands[0],\n+                                              operands[1],\n+                                              operands[2]));\n+  tilegx_pre_atomic_barrier (model);\n+  DONE;\n+})"}, {"sha": "4e3203cd1b7ef31ec961dbbbf28094114d6c71e1", "filename": "gcc/config/tilegx/t-tilegx", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ft-tilegx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ft-tilegx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ft-tilegx?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,21 @@\n+MULTILIB_OPTIONS = m64/m32\n+MULTILIB_DIRNAMES = 64 32\n+MULTILIB_OSDIRNAMES = ../lib ../lib32\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib\n+\n+tilegx-c.o: $(srcdir)/config/tilegx/tilegx-c.c \\\n+    $(CONFIG_H) $(SYSTEM_H) coretypes.h $(MACHMODE_H) \\\n+    $(TM_H) $(TM_P_H) $(CPPLIB_H) $(TREE_H) $(C_COMMON_H)\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n+\n+$(srcdir)/config/tilegx/mul-tables.c: \\\n+    $(srcdir)/config/tilepro/gen-mul-tables.cc\n+\t$(CC_FOR_BUILD) $(BUILD_CPPFLAGS) -O2 -o gen-mul-tables -lstdc++ $<;\n+\t./gen-mul-tables > $@\n+\n+mul-tables.o: $(srcdir)/config/tilegx/mul-tables.c \\\n+    $(CONFIG_H) $(SYSTEM_H) coretypes.h $(EXPR_H) $(OPTABS_H) \\\n+    $(srcdir)/config/tilegx/tilegx-multiply.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<"}, {"sha": "49067ae0b26133f9a82f5898c02dd2757d28f11d", "filename": "gcc/config/tilegx/tilegx-builtins.h", "status": "added", "additions": 325, "deletions": 0, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ftilegx-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ftilegx-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx-builtins.h?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,325 @@\n+/* Enum for builtin intrinsics for TILE-Gx.\n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TILEGX_BUILTINS_H\n+#define GCC_TILEGX_BUILTINS_H\n+\n+enum tilegx_builtin\n+{\n+  TILEGX_INSN_ADD,\n+  TILEGX_INSN_ADDX,\n+  TILEGX_INSN_ADDXSC,\n+  TILEGX_INSN_AND,\n+  TILEGX_INSN_BFEXTS,\n+  TILEGX_INSN_BFEXTU,\n+  TILEGX_INSN_BFINS,\n+  TILEGX_INSN_CLZ,\n+  TILEGX_INSN_CMOVEQZ,\n+  TILEGX_INSN_CMOVNEZ,\n+  TILEGX_INSN_CMPEQ,\n+  TILEGX_INSN_CMPEXCH,\n+  TILEGX_INSN_CMPEXCH4,\n+  TILEGX_INSN_CMPLES,\n+  TILEGX_INSN_CMPLEU,\n+  TILEGX_INSN_CMPLTS,\n+  TILEGX_INSN_CMPLTU,\n+  TILEGX_INSN_CMPNE,\n+  TILEGX_INSN_CMUL,\n+  TILEGX_INSN_CMULA,\n+  TILEGX_INSN_CMULAF,\n+  TILEGX_INSN_CMULF,\n+  TILEGX_INSN_CMULFR,\n+  TILEGX_INSN_CMULH,\n+  TILEGX_INSN_CMULHR,\n+  TILEGX_INSN_CRC32_32,\n+  TILEGX_INSN_CRC32_8,\n+  TILEGX_INSN_CTZ,\n+  TILEGX_INSN_DBLALIGN,\n+  TILEGX_INSN_DBLALIGN2,\n+  TILEGX_INSN_DBLALIGN4,\n+  TILEGX_INSN_DBLALIGN6,\n+  TILEGX_INSN_DRAIN,\n+  TILEGX_INSN_DTLBPR,\n+  TILEGX_INSN_EXCH,\n+  TILEGX_INSN_EXCH4,\n+  TILEGX_INSN_FDOUBLE_ADD_FLAGS,\n+  TILEGX_INSN_FDOUBLE_ADDSUB,\n+  TILEGX_INSN_FDOUBLE_MUL_FLAGS,\n+  TILEGX_INSN_FDOUBLE_PACK1,\n+  TILEGX_INSN_FDOUBLE_PACK2,\n+  TILEGX_INSN_FDOUBLE_SUB_FLAGS,\n+  TILEGX_INSN_FDOUBLE_UNPACK_MAX,\n+  TILEGX_INSN_FDOUBLE_UNPACK_MIN,\n+  TILEGX_INSN_FETCHADD,\n+  TILEGX_INSN_FETCHADD4,\n+  TILEGX_INSN_FETCHADDGEZ,\n+  TILEGX_INSN_FETCHADDGEZ4,\n+  TILEGX_INSN_FETCHAND,\n+  TILEGX_INSN_FETCHAND4,\n+  TILEGX_INSN_FETCHOR,\n+  TILEGX_INSN_FETCHOR4,\n+  TILEGX_INSN_FINV,\n+  TILEGX_INSN_FLUSH,\n+  TILEGX_INSN_FLUSHWB,\n+  TILEGX_INSN_FNOP,\n+  TILEGX_INSN_FSINGLE_ADD1,\n+  TILEGX_INSN_FSINGLE_ADDSUB2,\n+  TILEGX_INSN_FSINGLE_MUL1,\n+  TILEGX_INSN_FSINGLE_MUL2,\n+  TILEGX_INSN_FSINGLE_PACK1,\n+  TILEGX_INSN_FSINGLE_PACK2,\n+  TILEGX_INSN_FSINGLE_SUB1,\n+  TILEGX_INSN_ICOH,\n+  TILEGX_INSN_ILL,\n+  TILEGX_INSN_INFO,\n+  TILEGX_INSN_INFOL,\n+  TILEGX_INSN_INV,\n+  TILEGX_INSN_LD,\n+  TILEGX_INSN_LD1S,\n+  TILEGX_INSN_LD1U,\n+  TILEGX_INSN_LD2S,\n+  TILEGX_INSN_LD2U,\n+  TILEGX_INSN_LD4S,\n+  TILEGX_INSN_LD4U,\n+  TILEGX_INSN_LDNA,\n+  TILEGX_INSN_LDNT,\n+  TILEGX_INSN_LDNT1S,\n+  TILEGX_INSN_LDNT1U,\n+  TILEGX_INSN_LDNT2S,\n+  TILEGX_INSN_LDNT2U,\n+  TILEGX_INSN_LDNT4S,\n+  TILEGX_INSN_LDNT4U,\n+  TILEGX_INSN_LD_L2,\n+  TILEGX_INSN_LD1S_L2,\n+  TILEGX_INSN_LD1U_L2,\n+  TILEGX_INSN_LD2S_L2,\n+  TILEGX_INSN_LD2U_L2,\n+  TILEGX_INSN_LD4S_L2,\n+  TILEGX_INSN_LD4U_L2,\n+  TILEGX_INSN_LDNA_L2,\n+  TILEGX_INSN_LDNT_L2,\n+  TILEGX_INSN_LDNT1S_L2,\n+  TILEGX_INSN_LDNT1U_L2,\n+  TILEGX_INSN_LDNT2S_L2,\n+  TILEGX_INSN_LDNT2U_L2,\n+  TILEGX_INSN_LDNT4S_L2,\n+  TILEGX_INSN_LDNT4U_L2,\n+  TILEGX_INSN_LD_MISS,\n+  TILEGX_INSN_LD1S_MISS,\n+  TILEGX_INSN_LD1U_MISS,\n+  TILEGX_INSN_LD2S_MISS,\n+  TILEGX_INSN_LD2U_MISS,\n+  TILEGX_INSN_LD4S_MISS,\n+  TILEGX_INSN_LD4U_MISS,\n+  TILEGX_INSN_LDNA_MISS,\n+  TILEGX_INSN_LDNT_MISS,\n+  TILEGX_INSN_LDNT1S_MISS,\n+  TILEGX_INSN_LDNT1U_MISS,\n+  TILEGX_INSN_LDNT2S_MISS,\n+  TILEGX_INSN_LDNT2U_MISS,\n+  TILEGX_INSN_LDNT4S_MISS,\n+  TILEGX_INSN_LDNT4U_MISS,\n+  TILEGX_INSN_LNK,\n+  TILEGX_INSN_MF,\n+  TILEGX_INSN_MFSPR,\n+  TILEGX_INSN_MM,\n+  TILEGX_INSN_MNZ,\n+  TILEGX_INSN_MOVE,\n+  TILEGX_INSN_MTSPR,\n+  TILEGX_INSN_MUL_HS_HS,\n+  TILEGX_INSN_MUL_HS_HU,\n+  TILEGX_INSN_MUL_HS_LS,\n+  TILEGX_INSN_MUL_HS_LU,\n+  TILEGX_INSN_MUL_HU_HU,\n+  TILEGX_INSN_MUL_HU_LS,\n+  TILEGX_INSN_MUL_HU_LU,\n+  TILEGX_INSN_MUL_LS_LS,\n+  TILEGX_INSN_MUL_LS_LU,\n+  TILEGX_INSN_MUL_LU_LU,\n+  TILEGX_INSN_MULA_HS_HS,\n+  TILEGX_INSN_MULA_HS_HU,\n+  TILEGX_INSN_MULA_HS_LS,\n+  TILEGX_INSN_MULA_HS_LU,\n+  TILEGX_INSN_MULA_HU_HU,\n+  TILEGX_INSN_MULA_HU_LS,\n+  TILEGX_INSN_MULA_HU_LU,\n+  TILEGX_INSN_MULA_LS_LS,\n+  TILEGX_INSN_MULA_LS_LU,\n+  TILEGX_INSN_MULA_LU_LU,\n+  TILEGX_INSN_MULAX,\n+  TILEGX_INSN_MULX,\n+  TILEGX_INSN_MZ,\n+  TILEGX_INSN_NAP,\n+  TILEGX_INSN_NOP,\n+  TILEGX_INSN_NOR,\n+  TILEGX_INSN_OR,\n+  TILEGX_INSN_PCNT,\n+  TILEGX_INSN_PREFETCH_L1,\n+  TILEGX_INSN_PREFETCH_L1_FAULT,\n+  TILEGX_INSN_PREFETCH_L2,\n+  TILEGX_INSN_PREFETCH_L2_FAULT,\n+  TILEGX_INSN_PREFETCH_L3,\n+  TILEGX_INSN_PREFETCH_L3_FAULT,\n+  TILEGX_INSN_REVBITS,\n+  TILEGX_INSN_REVBYTES,\n+  TILEGX_INSN_ROTL,\n+  TILEGX_INSN_SHL,\n+  TILEGX_INSN_SHL16INSLI,\n+  TILEGX_INSN_SHL1ADD,\n+  TILEGX_INSN_SHL1ADDX,\n+  TILEGX_INSN_SHL2ADD,\n+  TILEGX_INSN_SHL2ADDX,\n+  TILEGX_INSN_SHL3ADD,\n+  TILEGX_INSN_SHL3ADDX,\n+  TILEGX_INSN_SHLX,\n+  TILEGX_INSN_SHRS,\n+  TILEGX_INSN_SHRU,\n+  TILEGX_INSN_SHRUX,\n+  TILEGX_INSN_SHUFFLEBYTES,\n+  TILEGX_INSN_ST,\n+  TILEGX_INSN_ST1,\n+  TILEGX_INSN_ST2,\n+  TILEGX_INSN_ST4,\n+  TILEGX_INSN_STNT,\n+  TILEGX_INSN_STNT1,\n+  TILEGX_INSN_STNT2,\n+  TILEGX_INSN_STNT4,\n+  TILEGX_INSN_SUB,\n+  TILEGX_INSN_SUBX,\n+  TILEGX_INSN_SUBXSC,\n+  TILEGX_INSN_TBLIDXB0,\n+  TILEGX_INSN_TBLIDXB1,\n+  TILEGX_INSN_TBLIDXB2,\n+  TILEGX_INSN_TBLIDXB3,\n+  TILEGX_INSN_V1ADD,\n+  TILEGX_INSN_V1ADDI,\n+  TILEGX_INSN_V1ADDUC,\n+  TILEGX_INSN_V1ADIFFU,\n+  TILEGX_INSN_V1AVGU,\n+  TILEGX_INSN_V1CMPEQ,\n+  TILEGX_INSN_V1CMPEQI,\n+  TILEGX_INSN_V1CMPLES,\n+  TILEGX_INSN_V1CMPLEU,\n+  TILEGX_INSN_V1CMPLTS,\n+  TILEGX_INSN_V1CMPLTSI,\n+  TILEGX_INSN_V1CMPLTU,\n+  TILEGX_INSN_V1CMPLTUI,\n+  TILEGX_INSN_V1CMPNE,\n+  TILEGX_INSN_V1DDOTPU,\n+  TILEGX_INSN_V1DDOTPUA,\n+  TILEGX_INSN_V1DDOTPUS,\n+  TILEGX_INSN_V1DDOTPUSA,\n+  TILEGX_INSN_V1DOTP,\n+  TILEGX_INSN_V1DOTPA,\n+  TILEGX_INSN_V1DOTPU,\n+  TILEGX_INSN_V1DOTPUA,\n+  TILEGX_INSN_V1DOTPUS,\n+  TILEGX_INSN_V1DOTPUSA,\n+  TILEGX_INSN_V1INT_H,\n+  TILEGX_INSN_V1INT_L,\n+  TILEGX_INSN_V1MAXU,\n+  TILEGX_INSN_V1MAXUI,\n+  TILEGX_INSN_V1MINU,\n+  TILEGX_INSN_V1MINUI,\n+  TILEGX_INSN_V1MNZ,\n+  TILEGX_INSN_V1MULTU,\n+  TILEGX_INSN_V1MULU,\n+  TILEGX_INSN_V1MULUS,\n+  TILEGX_INSN_V1MZ,\n+  TILEGX_INSN_V1SADAU,\n+  TILEGX_INSN_V1SADU,\n+  TILEGX_INSN_V1SHL,\n+  TILEGX_INSN_V1SHLI,\n+  TILEGX_INSN_V1SHRS,\n+  TILEGX_INSN_V1SHRSI,\n+  TILEGX_INSN_V1SHRU,\n+  TILEGX_INSN_V1SHRUI,\n+  TILEGX_INSN_V1SUB,\n+  TILEGX_INSN_V1SUBUC,\n+  TILEGX_INSN_V2ADD,\n+  TILEGX_INSN_V2ADDI,\n+  TILEGX_INSN_V2ADDSC,\n+  TILEGX_INSN_V2ADIFFS,\n+  TILEGX_INSN_V2AVGS,\n+  TILEGX_INSN_V2CMPEQ,\n+  TILEGX_INSN_V2CMPEQI,\n+  TILEGX_INSN_V2CMPLES,\n+  TILEGX_INSN_V2CMPLEU,\n+  TILEGX_INSN_V2CMPLTS,\n+  TILEGX_INSN_V2CMPLTSI,\n+  TILEGX_INSN_V2CMPLTU,\n+  TILEGX_INSN_V2CMPLTUI,\n+  TILEGX_INSN_V2CMPNE,\n+  TILEGX_INSN_V2DOTP,\n+  TILEGX_INSN_V2DOTPA,\n+  TILEGX_INSN_V2INT_H,\n+  TILEGX_INSN_V2INT_L,\n+  TILEGX_INSN_V2MAXS,\n+  TILEGX_INSN_V2MAXSI,\n+  TILEGX_INSN_V2MINS,\n+  TILEGX_INSN_V2MINSI,\n+  TILEGX_INSN_V2MNZ,\n+  TILEGX_INSN_V2MULFSC,\n+  TILEGX_INSN_V2MULS,\n+  TILEGX_INSN_V2MULTS,\n+  TILEGX_INSN_V2MZ,\n+  TILEGX_INSN_V2PACKH,\n+  TILEGX_INSN_V2PACKL,\n+  TILEGX_INSN_V2PACKUC,\n+  TILEGX_INSN_V2SADAS,\n+  TILEGX_INSN_V2SADAU,\n+  TILEGX_INSN_V2SADS,\n+  TILEGX_INSN_V2SADU,\n+  TILEGX_INSN_V2SHL,\n+  TILEGX_INSN_V2SHLI,\n+  TILEGX_INSN_V2SHLSC,\n+  TILEGX_INSN_V2SHRS,\n+  TILEGX_INSN_V2SHRSI,\n+  TILEGX_INSN_V2SHRU,\n+  TILEGX_INSN_V2SHRUI,\n+  TILEGX_INSN_V2SUB,\n+  TILEGX_INSN_V2SUBSC,\n+  TILEGX_INSN_V4ADD,\n+  TILEGX_INSN_V4ADDSC,\n+  TILEGX_INSN_V4INT_H,\n+  TILEGX_INSN_V4INT_L,\n+  TILEGX_INSN_V4PACKSC,\n+  TILEGX_INSN_V4SHL,\n+  TILEGX_INSN_V4SHLSC,\n+  TILEGX_INSN_V4SHRS,\n+  TILEGX_INSN_V4SHRU,\n+  TILEGX_INSN_V4SUB,\n+  TILEGX_INSN_V4SUBSC,\n+  TILEGX_INSN_WH64,\n+  TILEGX_INSN_XOR,\n+  TILEGX_NETWORK_BARRIER,\n+  TILEGX_IDN0_RECEIVE,\n+  TILEGX_IDN1_RECEIVE,\n+  TILEGX_IDN_SEND,\n+  TILEGX_UDN0_RECEIVE,\n+  TILEGX_UDN1_RECEIVE,\n+  TILEGX_UDN2_RECEIVE,\n+  TILEGX_UDN3_RECEIVE,\n+  TILEGX_UDN_SEND,\n+  TILEGX_BUILTIN_max\n+};\n+\n+#endif /* !GCC_TILEGX_BUILTINS_H */"}, {"sha": "9cb8f7af171751a3e9b2c45ba79c66331c8520fe", "filename": "gcc/config/tilegx/tilegx-c.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ftilegx-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ftilegx-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx-c.c?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,55 @@\n+/* Definitions of C specific functions for TILE-Gx.\n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"machmode.h\"\n+#include \"tm.h\"\n+#include \"tm_p.h\"\n+#include \"cpplib.h\"\n+#include \"tree.h\"\n+#include \"c-family/c-common.h\"\n+\n+/* copy defines in c-cppbuiltin.c */\n+# define builtin_define(TXT) cpp_define (pfile, TXT)\n+# define builtin_assert(TXT) cpp_assert (pfile, TXT)\n+\n+\n+/* Implement TARGET_CPU_CPP_BUILTINS.  */\n+void\n+tilegx_cpu_cpp_builtins (struct cpp_reader *pfile)\n+{\n+  builtin_define (\"__tile__\");\n+  builtin_define (\"__tilegx__\");\n+  builtin_define (\"__tile_chip__=10\");\n+  builtin_define (\"__tile_chip_rev__=0\");\n+  builtin_assert (\"cpu=tilegx\");\n+  builtin_assert (\"machine=tilegx\");\n+\n+  if (TARGET_32BIT)\n+    builtin_define (\"__tilegx32__\");\n+\n+  TILEGX_CPU_CPP_ENDIAN_BUILTINS ();\n+  GNU_USER_TARGET_OS_CPP_BUILTINS ();\n+}\n+\n+"}, {"sha": "970344aacf41aa49a8c350b4d0e201f48dd53367", "filename": "gcc/config/tilegx/tilegx-generic.md", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ftilegx-generic.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ftilegx-generic.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx-generic.md?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,112 @@\n+;; Scheduling description for Tilera TILE-Gx chip.\n+;; Copyright (C) 2011, 2012\n+;; Free Software Foundation, Inc.\n+;; Contributed by Walter Lee (walt@tilera.com)\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_automaton \"tile\")\n+\n+; Make the scheduling automaton an ndfa.\n+(automata_option \"ndfa\")\n+\n+; Name the three pipes.\n+(define_cpu_unit \"X0\" \"tile\")\n+(define_cpu_unit \"X1\" \"tile\")\n+(define_cpu_unit \"Y0\" \"tile\")\n+(define_cpu_unit \"Y1\" \"tile\")\n+(define_cpu_unit \"Y2\" \"tile\")\n+\n+(define_insn_reservation \"X0\" 1\n+  (eq_attr \"type\" \"X0\")\n+  \"X0\")\n+\n+(define_insn_reservation \"X0_2cycle\" 2\n+  (eq_attr \"type\" \"X0_2cycle\")\n+  \"X0,nothing\")\n+\n+(define_insn_reservation \"X1\" 1\n+  (eq_attr \"type\" \"X1,X1_branch\")\n+  \"X1\")\n+\n+(define_insn_reservation \"X1_2cycle\" 2\n+  (eq_attr \"type\" \"X1_2cycle\")\n+  \"X1,nothing\")\n+\n+(define_insn_reservation \"X1_L2\" 11\n+  (eq_attr \"type\" \"X1_L2\")\n+  \"X1\")\n+\n+(define_insn_reservation \"X1_miss\" 80\n+  (eq_attr \"type\" \"X1_miss\")\n+  \"X1\")\n+\n+(define_insn_reservation \"X01\" 1\n+  (eq_attr \"type\" \"X01\")\n+  \"X0|X1\")\n+\n+(define_insn_reservation \"Y0\" 1\n+  (eq_attr \"type\" \"Y0\")\n+  \"Y0|X0\")\n+\n+(define_insn_reservation \"Y0_2cycle\" 2\n+  (eq_attr \"type\" \"Y0_2cycle\")\n+  \"Y0|X0,nothing\")\n+\n+(define_insn_reservation \"Y1\" 1\n+  (eq_attr \"type\" \"Y1\")\n+  \"Y1|X1\")\n+\n+(define_insn_reservation \"Y2\" 1\n+  (eq_attr \"type\" \"Y2\")\n+  \"Y2|X1\")\n+\n+(define_insn_reservation \"Y2_2cycle\" 2\n+  (eq_attr \"type\" \"Y2_2cycle\")\n+  \"Y2|X1,nothing\")\n+\n+(define_insn_reservation \"Y2_L2\" 11\n+  (eq_attr \"type\" \"Y2_L2\")\n+  \"Y2|X1\")\n+\n+(define_insn_reservation \"Y2_miss\" 80\n+  (eq_attr \"type\" \"Y2_miss\")\n+  \"Y2|X1\")\n+\n+(define_insn_reservation \"Y01\" 1\n+  (eq_attr \"type\" \"Y01\")\n+  \"Y0|Y1|X0|X1\")\n+\n+(define_insn_reservation \"nothing\" 0\n+  (eq_attr \"type\" \"nothing\")\n+  \"nothing\")\n+\n+(define_insn_reservation \"cannot_bundle\" 1\n+  (eq_attr \"type\" \"cannot_bundle\")\n+  \"X0+X1\")\n+\n+(define_insn_reservation \"cannot_bundle_3cycle\" 3\n+  (eq_attr \"type\" \"cannot_bundle_3cycle\")\n+  \"X0+X1\")\n+\n+(define_insn_reservation \"cannot_bundle_4cycle\" 4\n+  (eq_attr \"type\" \"cannot_bundle_4cycle\")\n+  \"X0+X1\")\n+\n+\n+; A bundle must be in either X format or Y format.\n+(exclusion_set \"X0,X1\" \"Y0,Y1,Y2\")"}, {"sha": "47c959f7ba90250a95443a50d0ca839b1728a364", "filename": "gcc/config/tilegx/tilegx-modes.def", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ftilegx-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ftilegx-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx-modes.def?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,38 @@\n+/* TILE-Gx extra machine modes. \n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Extra modes for handling struct returns in up to 10 registers. */\n+INT_MODE (R3I, 24);\n+INT_MODE (R5I, 40);\n+INT_MODE (R6I, 48);\n+INT_MODE (R7I, 56);\n+INT_MODE (R8I, 64);\n+INT_MODE (R9I, 72);\n+INT_MODE (R10I, 80);\n+\n+/* Vector modes.  */\n+VECTOR_MODES (INT, 8);     /* V8QI V4HI V2SI */\n+VECTOR_MODE (INT, QI, 16); /* V16QI */\n+VECTOR_MODE (INT, HI, 8);  /* V8HI */\n+VECTOR_MODE (INT, SI, 4);  /* V4SI */\n+VECTOR_MODE (INT, HI, 2);  /* V2HI */\n+\n+VECTOR_MODE (INT, QI, 4);  /* V4QI */"}, {"sha": "7acba069736667077bb706bfc9915b82d830d8f9", "filename": "gcc/config/tilegx/tilegx-multiply.h", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ftilegx-multiply.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ftilegx-multiply.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx-multiply.h?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,79 @@\n+/* Header for constant multiple table for TILE-Gx.\n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TILEGX_MULTIPLY_H\n+#define GCC_TILEGX_MULTIPLY_H\n+\n+/* A node of a tilegx_multiply_insn_seq, corresponding to a single\n+   machine instruction such as 'add', 's1a', or an shl by a constant.  */\n+struct tilegx_multiply_insn_seq_entry\n+{\n+  /* Which operation this node performs (e.g. an add or sub).\n+     Don't use this directly, call get_opcode() table to get a insn_code.  */\n+  unsigned char compressed_opcode;\n+\n+  /* The left-hand side of this expression tree.\n+     If equal to 0, it refers to 'zero'.\n+     If equal to 1, it refers to the original input to the multiply operation.\n+     Otherwise, subtract two and it is an index into the containing\n+     tilegx_multiply_insn_seq's 'op' array. Since it can only point to some\n+     value that has already been computed it will always point to an\n+     earlier entry in the array.  */\n+  unsigned char lhs;\n+\n+  /* This is like lhs, but for the right-hand side. However, for shift\n+     opcodes this is a shift count rather than an operand index.  */\n+  unsigned char rhs;\n+};\n+\n+/* Maximum size of op array.  */\n+#define tilegx_multiply_insn_seq_MAX_OPERATIONS 4\n+\n+/* This defines a DAG describing how to multiply by a constant in\n+   terms of one or more machine instructions.  */\n+struct tilegx_multiply_insn_seq\n+{\n+  /* The constant factor by which this expression tree multiplies its input.  */\n+  long long multiplier;\n+\n+  /* The nodes of the parse tree. These are ordered so that instructions\n+     can be emitted in the same order that they appear in this array.\n+     Entry entry in this array can only refer to earlier entries in\n+     the array.  */\n+  struct tilegx_multiply_insn_seq_entry\n+    op[tilegx_multiply_insn_seq_MAX_OPERATIONS];\n+\n+};\n+\n+/* A mapping from the compressed opcode to the corresponding enum\n+   insn_code.  */\n+extern const enum insn_code tilegx_multiply_insn_seq_decode_opcode[];\n+\n+/* Table mapping constant int multipliers to an expression\n+   tree that efficiently performs that multiplication.\n+   This is sorted by its 'multiplier' field so a binary search\n+   can look for matches.  */\n+extern const struct tilegx_multiply_insn_seq tilegx_multiply_insn_seq_table[];\n+\n+/* The number of elements in multiply_insn_seq_table.  */\n+extern const int tilegx_multiply_insn_seq_table_size;\n+\n+#endif /* !GCC_TILEGX_MULTIPLY_H */"}, {"sha": "56ce617e1f6519fb40dfb9890bed04c4f1155932", "filename": "gcc/config/tilegx/tilegx-protos.h", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ftilegx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ftilegx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx-protos.h?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,74 @@\n+/* Prototypes of target machine for TILE-Gx.\n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TILEGX_PROTOS_H\n+#define GCC_TILEGX_PROTOS_H\n+\n+extern void tilegx_init_expanders (void);\n+extern bool tilegx_legitimate_pic_operand_p (rtx);\n+extern rtx tilegx_simd_int (rtx, enum machine_mode);\n+\n+#ifdef RTX_CODE\n+extern bool tilegx_bitfield_operand_p (HOST_WIDE_INT, int *, int *);\n+extern void tilegx_expand_set_const64 (rtx, rtx);\n+extern bool tilegx_expand_mov (enum machine_mode, rtx *);\n+extern void tilegx_expand_unaligned_load (rtx, rtx, HOST_WIDE_INT,\n+\t\t\t\t\t  HOST_WIDE_INT, bool);\n+extern void tilegx_expand_movmisalign (enum machine_mode, rtx *);\n+extern void tilegx_allocate_stack (rtx, rtx);\n+extern bool tilegx_expand_muldi (rtx, rtx, rtx);\n+extern void tilegx_expand_smuldi3_highpart (rtx, rtx, rtx);\n+extern void tilegx_expand_umuldi3_highpart (rtx, rtx, rtx);\n+\n+extern bool tilegx_emit_setcc (rtx[], enum machine_mode);\n+extern void tilegx_emit_conditional_branch (rtx[], enum machine_mode);\n+extern rtx tilegx_emit_conditional_move (rtx);\n+extern const char *tilegx_output_cbranch_with_opcode (rtx, rtx *,\n+\t\t\t\t\t\t      const char *,\n+\t\t\t\t\t\t      const char *, int);\n+extern const char *tilegx_output_cbranch (rtx, rtx *, bool);\n+extern void tilegx_expand_tablejump (rtx, rtx);\n+extern void tilegx_expand_builtin_vector_binop (rtx (*)(rtx, rtx, rtx),\n+\t\t\t\t\t\tenum machine_mode, rtx,\n+\t\t\t\t\t\tenum machine_mode, rtx, rtx,\n+\t\t\t\t\t\tbool);\n+extern void tilegx_pre_atomic_barrier (enum memmodel);\n+extern void tilegx_post_atomic_barrier (enum memmodel);\n+#endif /* RTX_CODE */\n+\n+extern bool tilegx_can_use_return_insn_p (void);\n+extern void tilegx_expand_prologue (void);\n+extern void tilegx_expand_epilogue (bool);\n+extern int tilegx_initial_elimination_offset (int, int);\n+extern rtx tilegx_return_addr (int, rtx);\n+extern rtx tilegx_eh_return_handler_rtx (void);\n+extern int tilegx_adjust_insn_length (rtx, int);\n+\n+extern int tilegx_asm_preferred_eh_data_format (int, int);\n+extern void tilegx_final_prescan_insn (rtx);\n+extern const char *tilegx_asm_output_opcode (FILE *, const char *);\n+extern void tilegx_function_profiler (FILE *, int);\n+\n+/* Declare functions in tilegx-c.c */\n+\n+extern void tilegx_cpu_cpp_builtins (struct cpp_reader *);\n+\n+#endif /* GCC_TILEGX_PROTOS_H */"}, {"sha": "276b5d21672d8c953d62d022ef1825900f77391f", "filename": "gcc/config/tilegx/tilegx.c", "status": "added", "additions": 5501, "deletions": 0, "changes": 5501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=dd552284fd817c9d946598a7b647f9e67753bed6"}, {"sha": "081ecc1756af6afc163bd2e40b7d49ab065f4b88", "filename": "gcc/config/tilegx/tilegx.h", "status": "added", "additions": 505, "deletions": 0, "changes": 505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ftilegx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ftilegx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.h?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,505 @@\n+/* Definitions of target machine for GNU compiler for TILE-Gx.\n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is used by tilegx_cpu_cpp_builtins to indicate the byte order\n+   we're compiling for.  */\n+#define TILEGX_CPU_CPP_ENDIAN_BUILTINS()\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (TARGET_BIG_ENDIAN)\t\t\t\\\n+\tbuiltin_define (\"__BIG_ENDIAN__\");\t\\\n+      else\t\t\t\t\t\\\n+\tbuiltin_define (\"__LITTLE_ENDIAN__\");\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+\n+/* Target CPU builtins.  */\n+#define TARGET_CPU_CPP_BUILTINS() \\\n+  tilegx_cpu_cpp_builtins (pfile)\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE (TARGET_32BIT ? \"int\" : \"long int\")\n+\n+#undef SIZE_TYPE\n+#define SIZE_TYPE (TARGET_32BIT ? \"unsigned int\" : \"long unsigned int\")\n+\n+#undef WCHAR_TYPE\n+#define WCHAR_TYPE \"int\"\n+\n+#undef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE 32\n+\f\n+\n+/* Target machine storage layout */\n+\n+#define TARGET_BIG_ENDIAN 0\n+#define BITS_BIG_ENDIAN 0\n+#define BYTES_BIG_ENDIAN TARGET_BIG_ENDIAN\n+#define WORDS_BIG_ENDIAN TARGET_BIG_ENDIAN\n+\n+#define UNITS_PER_WORD 8\n+#define PARM_BOUNDARY BITS_PER_WORD\n+#define STACK_BOUNDARY 64\n+#define FUNCTION_BOUNDARY 64\n+#define BIGGEST_ALIGNMENT 64\n+#define STRICT_ALIGNMENT 1\n+\n+#define INT_TYPE_SIZE         32\n+#define LONG_TYPE_SIZE        (TARGET_32BIT ? 32 : 64)\n+#define LONG_LONG_TYPE_SIZE   64\n+#define FLOAT_TYPE_SIZE       32\n+#define DOUBLE_TYPE_SIZE      64\n+#define LONG_DOUBLE_TYPE_SIZE 64\n+#define POINTER_SIZE          LONG_TYPE_SIZE\n+\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+#define FASTEST_ALIGNMENT 64\n+#define BIGGEST_FIELD_ALIGNMENT 64\n+#define WIDEST_HARDWARE_FP_SIZE 64\n+\n+/* Unaligned moves trap and are very slow.  */\n+#define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) 1\n+\n+/* Make strings word-aligned so strcpy from constants will be\n+   faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  ((TREE_CODE (EXP) == STRING_CST\t\\\n+    && (ALIGN) < FASTEST_ALIGNMENT)\t\\\n+   ? FASTEST_ALIGNMENT : (ALIGN))\n+\n+/* Make arrays of chars word-aligned for the same reasons.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+   && (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))\n+\n+/* Make local arrays of chars word-aligned for the same reasons.  */\n+#define LOCAL_ALIGNMENT(TYPE, ALIGN) DATA_ALIGNMENT (TYPE, ALIGN)\n+\f\n+\n+/* Standard register usage.  */\n+\n+#define FIRST_PSEUDO_REGISTER (64 + 4)\n+\n+#define FIXED_REGISTERS \\\n+ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1}\n+#define CALL_USED_REGISTERS \\\n+ {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1}\n+\n+#define CALL_REALLY_USED_REGISTERS \\\n+ CALL_USED_REGISTERS\n+\n+#define REG_ALLOC_ORDER {\t\t\t\t\\\n+      10, 11, 12, 13, 14, /* call used */\t\t\\\n+      15, 16, 17, 18, 19,\t\t\t\t\\\n+      20, 21, 22, 23, 24,\t\t\t\t\\\n+      25, 26, 27, 28, 29,\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+      9, 8, 7, 6, 5,      /* argument */\t\t\\\n+      4, 3, 2, 1, 0,\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+      55,\t          /* return address */\t\t\\\n+\t\t\t\t\t\t\t\\\n+      30, 31, 32, 33, 34, /* call saved registers */\t\\\n+      35, 36, 37, 38, 39,\t\t\t\t\\\n+      40, 41, 42, 43, 44,\t\t\t\t\\\n+      45, 46, 47, 48, 49,\t\t\t\t\\\n+      50, 51,\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+      52, \t\t  /* hard frame pointer */\t\\\n+      53, 54, \t\t  /* tp, sp */\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+      56, 57, 58, 59, 60, /* special purpose */\t\t\\\n+      61, 62, 63, 64, 65, /* or fake registers */\t\\\n+      66, 67\t\t\t\t\t\t\\\n+}\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)\t\\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n+\n+#define MODES_TIEABLE_P(MODE1, MODE2)  1\n+\n+/* Register that holds an address into the text segment that can be\n+   used by pic code.  */\n+#define TILEGX_PIC_TEXT_LABEL_REGNUM (flag_pic ? 50 : INVALID_REGNUM)\n+#define PIC_OFFSET_TABLE_REGNUM (flag_pic ? 51 : INVALID_REGNUM)\n+#define HARD_FRAME_POINTER_REGNUM 52\n+#define THREAD_POINTER_REGNUM 53\n+#define STACK_POINTER_REGNUM 54\n+#define TILEGX_LINK_REGNUM 55\n+#define FRAME_POINTER_REGNUM 64\n+#define ARG_POINTER_REGNUM 65\n+/* SPR storing the comparison value for compare and exchange.  */\n+#define TILEGX_CMPEXCH_REGNUM 66\n+/* Pseudo registers used to enforce order between instructions that\n+   touch the networks.  */\n+#define TILEGX_NETORDER_REGNUM 67\n+#define STATIC_CHAIN_REGNUM 10\n+\f\n+\n+enum reg_class\n+{\n+  NO_REGS,\n+  R0_REGS,\n+  R1_REGS,\n+  R2_REGS,\n+  R3_REGS,\n+  R4_REGS,\n+  R5_REGS,\n+  R6_REGS,\n+  R7_REGS,\n+  R8_REGS,\n+  R9_REGS,\n+  R10_REGS,\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Since GENERAL_REGS is the same class as ALL_REGS, don't give it a \n+   different class number; just make it an alias.  */\n+#define GENERAL_REGS ALL_REGS\n+\n+#define REG_CLASS_NAMES\t\\\n+  { \\\n+    \"NO_REGS\", \\\n+    \"R0_REGS\", \\\n+    \"R1_REGS\", \\\n+    \"R2_REGS\", \\\n+    \"R3_REGS\", \\\n+    \"R4_REGS\", \\\n+    \"R5_REGS\", \\\n+    \"R6_REGS\", \\\n+    \"R7_REGS\", \\\n+    \"R8_REGS\", \\\n+    \"R9_REGS\", \\\n+    \"R10_REGS\", \\\n+    \"ALL_REGS\" \\\n+  }\n+\n+#define REG_CLASS_CONTENTS \\\n+  { \\\n+    { 0 }, \\\n+    { 1 << 0 }, \\\n+    { 1 << 1 }, \\\n+    { 1 << 2 }, \\\n+    { 1 << 3 }, \\\n+    { 1 << 4 }, \\\n+    { 1 << 5 }, \\\n+    { 1 << 6 }, \\\n+    { 1 << 7 }, \\\n+    { 1 << 8 }, \\\n+    { 1 << 9 }, \\\n+    { 1 << 10 }, \\\n+    { 0xffffffff, 0xffffffff } \\\n+  }\n+\n+#define REGNO_REG_CLASS(REGNO) \\\n+  ((unsigned)(REGNO) <= 10 ? \\\n+   (enum reg_class)(R0_REGS + (REGNO)) : ALL_REGS)\n+\n+#define INDEX_REG_CLASS NO_REGS\n+#define BASE_REG_CLASS ALL_REGS\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)  (CLASS)\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+ ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\f\n+\n+/* Stack layout; function entry, exit and calling.  */\n+\n+#define STACK_GROWS_DOWNWARD\n+#define FRAME_GROWS_DOWNWARD 1\n+#define STARTING_FRAME_OFFSET 0\n+\n+#define DYNAMIC_CHAIN_ADDRESS(FRAME) plus_constant ((FRAME), UNITS_PER_WORD)\n+\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+#define ACCUMULATE_OUTGOING_ARGS 1\n+\n+#define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 1\n+\n+#define INCOMING_FRAME_SP_OFFSET 0\n+\n+#define STACK_POINTER_OFFSET (2 * UNITS_PER_WORD)\n+\n+#define ARG_POINTER_CFA_OFFSET(FNDECL) (-STACK_POINTER_OFFSET)\n+\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\n+/* The first 10 registers may hold return value.  */\n+#define TILEGX_NUM_RETURN_REGS 10\n+\n+/* The first 10 registers hold function arguments.  */\n+#define TILEGX_NUM_ARG_REGS 10\n+\n+#define FUNCTION_ARG_REGNO_P(N) ((N) < TILEGX_NUM_ARG_REGS)\n+\n+/* The type used to store the number of words of arguments scanned so\n+   far during argument scanning.  This includes any space that is\n+   skipped.  */\n+#define CUMULATIVE_ARGS int\n+\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n+ ((CUM) = 0)\n+\f\n+\n+#define ELIMINABLE_REGS\t\t\t\t\t\\\n+  {{ARG_POINTER_REGNUM,\t STACK_POINTER_REGNUM},\t\t\\\n+  {ARG_POINTER_REGNUM,\t HARD_FRAME_POINTER_REGNUM},\t\\\n+  {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n+  {FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+  ((OFFSET) = tilegx_initial_elimination_offset((FROM),(TO)))\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO) \\\n+  tilegx_function_profiler (FILE, LABELNO)\n+\n+#define TRAMPOLINE_SIZE (TARGET_32BIT ? 48 : 56)\n+#define TRAMPOLINE_ALIGNMENT 64\n+#define TRAMPOLINE_SECTION text_section\n+\f\n+\n+/* Call frame debugging information.  */\n+\n+#define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (Pmode, TILEGX_LINK_REGNUM)\n+\n+#define RETURN_ADDR_RTX tilegx_return_addr\n+\n+#define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (TILEGX_LINK_REGNUM)\n+\n+#define DWARF_ZERO_REG 63\n+\n+#define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (N + 12) : INVALID_REGNUM)\n+#define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, 11)\n+#define EH_RETURN_HANDLER_RTX tilegx_eh_return_handler_rtx ()\n+\n+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL) \\\n+  tilegx_asm_preferred_eh_data_format ((CODE), (GLOBAL))\n+\f\n+\n+/* Addressing modes, and classification of registers for them.  */\n+\n+#define HAVE_POST_INCREMENT 1\n+#define HAVE_POST_DECREMENT 1\n+#define HAVE_POST_MODIFY_DISP 1\n+\n+#define REGNO_OK_FOR_INDEX_P(regno) 0\n+#define REGNO_OK_FOR_BASE_P(regno)\t\\\n+  ((regno) < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)\n+\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+#define CONSTANT_ADDRESS_P(X) 0\n+\n+#define LEGITIMATE_PIC_OPERAND_P(X) tilegx_legitimate_pic_operand_p (X)\n+\f\n+\n+#define CASE_VECTOR_MODE Pmode\n+#define CASE_VECTOR_PC_RELATIVE 0\n+#define JUMP_TABLES_IN_TEXT_SECTION 0\n+\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+#define MOVE_MAX UNITS_PER_WORD\n+\n+/* Use a value of 11 for MOVE_RATIO and friends, because TILEPro\n+   returns structs as large as 10 words in registers.  Because of some\n+   some code generation inefficiency, we never get smaller code for\n+   turning that into a memcpy, so pick a value that guarantees this\n+   doesn't happen.  */\n+#define TILEGX_CALL_RATIO 11\n+#define MOVE_RATIO(speed) ((speed) ? 15 : TILEGX_CALL_RATIO)\n+#define CLEAR_RATIO(speed) ((speed) ? 15 : TILEGX_CALL_RATIO)\n+#define SET_RATIO(speed) ((speed) ? 15 : TILEGX_CALL_RATIO)\n+\n+#define WORD_REGISTER_OPERATIONS\n+\n+#define LOAD_EXTEND_OP(MODE) ((MODE) == SImode ? SIGN_EXTEND : ZERO_EXTEND)\n+\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)\t\\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD) \\\n+    {                                           \\\n+      if ((MODE) == SImode)                     \\\n+        (UNSIGNEDP) = 0;                        \\\n+      (MODE) = DImode;                          \\\n+    }\n+\n+/* Define SLOW_BYTE_ACCESS to avoid making a QI or HI mode\n+   register.  */\n+#define SLOW_BYTE_ACCESS 1\n+\n+#define SHIFT_COUNT_TRUNCATED 0\n+\n+#define SHORT_IMMEDIATES_SIGN_EXTEND\n+\n+/* We represent all SI values as sign-extended DI values in\n+   registers.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) \\\n+  ((INPREC) <= 32 || (OUTPREC) > 32)\n+\n+#define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) ((VALUE) = 64, 1)\n+#define CTZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) ((VALUE) = 64, 1)\n+\n+#define Pmode (TARGET_32BIT ? SImode : DImode)\n+\n+#define STACK_SIZE_MODE Pmode\n+\n+#define STORE_FLAG_VALUE 1\n+\n+#define FUNCTION_MODE DImode\n+\n+#define NO_FUNCTION_CSE 1\n+\n+#define ADJUST_INSN_LENGTH(INSN, LENGTH) \\\n+  ((LENGTH) = tilegx_adjust_insn_length ((INSN), (LENGTH)))\n+\n+#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n+\n+#define BRANCH_COST(speed_p, predictable_p) ((predictable_p) ? 2 : 6)\n+\f\n+\n+/* Control the assembler format that we output.  */\n+\n+#undef NO_DOLLAR_IN_LABEL\n+\n+#define ASM_COMMENT_START \"##\"\n+\n+#define TEXT_SECTION_ASM_OP \"\\t.text\"\n+\n+#define DATA_SECTION_ASM_OP \"\\t.data\"\n+\n+#undef READONLY_DATA_SECTION_ASM_OP\n+#define READONLY_DATA_SECTION_ASM_OP \"\\t.section\\t.rodata, \\\"a\\\"\"\n+\n+#undef BSS_SECTION_ASM_OP\n+#define BSS_SECTION_ASM_OP\t\"\\t.section\\t.bss, \\\"wa\\\"\"\n+\n+#undef INIT_SECTION_ASM_OP\n+#define INIT_SECTION_ASM_OP\t\"\\t.section\\t.init, \\\"ax\\\"\"\n+\n+#undef FINI_SECTION_ASM_OP\n+#define FINI_SECTION_ASM_OP\t\"\\t.section\\t.fini, \\\"ax\\\"\"\n+\n+#define GLOBAL_ASM_OP \".global \"\n+\n+#define SUPPORTS_WEAK 1\n+\n+#define USER_LABEL_PREFIX \"\"\n+\n+#define REGISTER_PREFIX \"\"\n+#define REGISTER_NAMES                                                  \\\n+  { \"r0\",   \"r1\",   \"r2\",   \"r3\",   \"r4\",   \"r5\",   \"r6\",   \"r7\",       \\\n+    \"r8\",   \"r9\",   \"r10\",  \"r11\",  \"r12\",  \"r13\",  \"r14\",  \"r15\",      \\\n+    \"r16\",  \"r17\",  \"r18\",  \"r19\",  \"r20\",  \"r21\",  \"r22\",  \"r23\",      \\\n+    \"r24\",  \"r25\",  \"r26\",  \"r27\",  \"r28\",  \"r29\",  \"r30\",  \"r31\",      \\\n+    \"r32\",  \"r33\",  \"r34\",  \"r35\",  \"r36\",  \"r37\",  \"r38\",  \"r39\",      \\\n+    \"r40\",  \"r41\",  \"r42\",  \"r43\",  \"r44\",  \"r45\",  \"r46\",  \"r47\",      \\\n+    \"r48\",  \"r49\",  \"r50\",  \"r51\",  \"r52\",  \"tp\",   \"sp\",   \"lr\",       \\\n+    \"?r56?\",\"idn0\", \"idn1\", \"udn0\", \"udn1\", \"udn2\", \"udn3\", \"zero\",     \\\n+    \"?FRAME?\", \"?ARG?\", \"?CMPEXCH?\", \"?NET?\" }\n+\n+#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS) \\\n+  tilegx_final_prescan_insn (insn)\n+\n+#define ASM_OUTPUT_OPCODE(STREAM, PTR)\t\\\n+  (PTR = tilegx_asm_output_opcode (STREAM, PTR))\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      char label[256];\t\t\t\t\t\t\\\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"L\", (VALUE));\t\\\n+      fprintf (FILE, \"\\t%s \",\t\t\t\t\t\\\n+               integer_asm_op (GET_MODE_SIZE (Pmode), TRUE));\t\\\n+      assemble_name (FILE, label);\t\t\t\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      char label[256];\t\t\t\t\t\t\\\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"L\", (VALUE));\t\\\n+      fprintf (FILE, \"\\t%s \", \t\t\t\t\t\\\n+               integer_asm_op (GET_MODE_SIZE (Pmode), TRUE));\t\\\n+      assemble_name (FILE, label);\t\t\t\t\\\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"L\", (REL));\t\t\\\n+      fprintf (FILE, \"-\");\t\t\t\t\t\\\n+      assemble_name (FILE, label);\t\t\t\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)  \\\n+  do { if ((LOG) != 0) fprintf (FILE, \"\\t.align %d\\n\", 1 << (LOG)); } while (0)\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\\\n+  ( fputs (\".comm \", (FILE)),\t\t\t\t\\\n+    assemble_name ((FILE), (NAME)),\t\t\t\\\n+    fprintf ((FILE), \",%u\\n\", (unsigned int)(ROUNDED)))\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)\t\\\n+  ( fputs (\".lcomm \", (FILE)),\t\t\t\t\\\n+    assemble_name ((FILE), (NAME)),\t\t\t\\\n+    fprintf ((FILE), \",%u\\n\", (unsigned int)(ROUNDED)))\n+\n+\f\n+\n+#define INIT_EXPANDERS tilegx_init_expanders ()\n+\n+/* A C structure for machine-specific, per-function data.  This is\n+   added to the cfun structure.  */\n+typedef struct GTY(()) machine_function\n+{\n+  /* Symbol for the text label used for pic.  */\n+  rtx text_label_symbol;\n+\n+  /* Register for the text label.  */\n+  rtx text_label_rtx;\n+\n+  /* Register for the pic offset table.  */\n+  rtx got_rtx;\n+\n+  /* The function calls tls_get_addr.  */\n+  int calls_tls_get_addr;\n+} machine_function;\n+\n+#ifndef HAVE_AS_TLS\n+#define HAVE_AS_TLS 0\n+#endif"}, {"sha": "033d125a99b6e97d13013dd180722740a587b97f", "filename": "gcc/config/tilegx/tilegx.md", "status": "added", "additions": 5121, "deletions": 0, "changes": 5121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ftilegx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ftilegx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.md?ref=dd552284fd817c9d946598a7b647f9e67753bed6"}, {"sha": "5a65eaec3802b5ff0d06b89d12eb54f1e6651725", "filename": "gcc/config/tilegx/tilegx.opt", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ftilegx.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilegx%2Ftilegx.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.opt?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,40 @@\n+; Options for the TILE-Gx port of the compiler.\n+; Copyright (C) 2011, 2012\n+; Free Software Foundation, Inc.\n+; Contributed by Walter Lee (walt@tilera.com)\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.\n+\n+mcpu=\n+Target RejectNegative Joined Enum(tilegx_cpu) Var(tilegx_cpu) Init(0)\n+-mcpu=CPU\tUse features of and schedule code for given CPU\n+\n+Enum\n+Name(tilegx_cpu) Type(int)\n+Known TILE-Gx CPUs (for use with the -mcpu= option):\n+\n+EnumValue\n+Enum(tilegx_cpu) String(tilegx) Value(0)\n+\n+m32\n+Target Report RejectNegative Negative(m64) Mask(32BIT)\n+Compile with 32 bit longs and pointers.\n+\n+m64\n+Target Report RejectNegative Negative(m32) InverseMask(32BIT, 64BIT)\n+Compile with 64 bit longs and pointers.\n+"}, {"sha": "868c9cafb7fff3b6abd454379639ab644b0775df", "filename": "gcc/config/tilepro/constraints.md", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Fconstraints.md?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,102 @@\n+;; Constraint definitions for Tilera TILEPro chip.\n+;; Copyright (C) 2011, 2012\n+;; Free Software Foundation, Inc.\n+;; Contributed by Walter Lee (walt@tilera.com)\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_register_constraint \"R00\" \"R0_REGS\"  \"r0\")\n+(define_register_constraint \"R01\" \"R1_REGS\"  \"r1\")\n+(define_register_constraint \"R02\" \"R2_REGS\"  \"r2\")\n+(define_register_constraint \"R03\" \"R3_REGS\"  \"r3\")\n+(define_register_constraint \"R04\" \"R4_REGS\"  \"r4\")\n+(define_register_constraint \"R05\" \"R5_REGS\"  \"r5\")\n+(define_register_constraint \"R06\" \"R6_REGS\"  \"r6\")\n+(define_register_constraint \"R07\" \"R7_REGS\"  \"r7\")\n+(define_register_constraint \"R08\" \"R8_REGS\"  \"r8\")\n+(define_register_constraint \"R09\" \"R9_REGS\"  \"r9\")\n+(define_register_constraint \"R10\" \"R10_REGS\" \"r10\")\n+\n+(define_constraint \"I\"\n+  \"A signed 8 bit constant\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -128 && ival <= 127\")))\n+\n+(define_constraint \"J\"\n+  \"Signed 16-bit integer constant\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -32768 && ival <= 32767\")))\n+\n+(define_constraint \"K\"\n+  \"Nonzero integer constant with low 16 bits zero\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival && (ival & 0xFFFF) == 0\")))\n+\n+(define_constraint \"L\"\n+  \"Integer constant that fits in one signed byte when incremented\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -129 && ival <= 126\")))\n+\n+(define_constraint \"M\"\n+  \"A bit mask suitable for 'mm'\"\n+  (and (match_code \"const_int\")\n+       (match_test \"tilepro_bitfield_operand_p (ival, NULL, NULL)\")))\n+\n+(define_constraint \"N\"\n+  \"Integer constant that is a byte tiled out four times\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(ival & 0xFFFFFFFF) == (ival & 0xFF) * 0x01010101\")))\n+\n+(define_constraint \"O\"\n+ \"The integer zero constant\"\n+ (and (match_code \"const_int\")\n+      (match_test \"ival == 0\")))\n+\n+(define_constraint \"P\"\n+  \"Integer constant that is a sign-extended byte tiled out as two shorts\"\n+  (and (match_code \"const_int\")\n+       (match_test \"((ival & 0xFFFFFFFF)\n+                     == ((trunc_int_for_mode (ival, QImode) & 0xFFFF)\n+                         * 0x00010001))\")))\n+\n+(define_constraint \"Q\"\n+  \"Integer constant that fits in one signed byte when incremented, but not -1\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -129 && ival <= 126 && ival != -1\")))\n+\n+(define_constraint \"T\"\n+  \"A const symbolc operand\"\n+  (match_operand 0 \"const_symbolic_operand\"))\n+\n+(define_memory_constraint \"U\"\n+  \"Non-auto-incrementing memory\"\n+  (and (match_code \"mem\")\n+       (match_test \"GET_RTX_CLASS (GET_CODE (XEXP (op, 0))) != RTX_AUTOINC\")))\n+\n+(define_constraint \"W\"\n+  \"A 4-element vector constant with identical elements\"\n+  (and (match_code \"const_vector\")\n+       (match_test \"CONST_VECTOR_NUNITS (op) == 4\")\n+       (match_test \"CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 1)\")\n+       (match_test \"CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 2)\")\n+       (match_test \"CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 3)\")))\n+\n+(define_constraint \"Y\"\n+  \"A 2-element vector constant with identical elements\"\n+  (and (match_code \"const_vector\")\n+       (match_test \"CONST_VECTOR_NUNITS (op) == 2\")\n+       (match_test \"CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 1)\")))"}, {"sha": "5f4551b356fc5c7330cc922b845c084deab8bef0", "filename": "gcc/config/tilepro/gen-mul-tables.cc", "status": "added", "additions": 1363, "deletions": 0, "changes": 1363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Fgen-mul-tables.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Fgen-mul-tables.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Fgen-mul-tables.cc?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,1363 @@\n+/* Multiply table generator for tile.\n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This program creates a table used to compile multiply by constant\n+   efficiently.\n+\n+   This program should be compiled by a c++ compiler.  If it's\n+   compiled with with -DTILEPRO, it generates the multiply table for\n+   TILEPro; otherwise it generates the multiply table for TILE-Gx.\n+   Running the program produces the table in stdout.\n+\n+   The program works by generating every possible combination of up to\n+   MAX_INSTRUCTIONS linear operators (such as add, sub, s2a, left\n+   shift) and computing the multiplier computed by those instructions.\n+   For example,\n+\n+   s2a r2,r1,r1\n+   s2a r3,r2,r2\n+\n+   multiplies r1 by 25.\n+\n+   There are usually multiple instruction sequences to multiply by a\n+   given constant. This program keeps only the cheapest one.\n+   \"Cheapest\" is defined first by the minimum theoretical schedule\n+   length, and if those are equal then by the number of instructions,\n+   and if those are equal then by which instructions we \"prefer\"\n+   (e.g. because we think one might take infinitesimally less power\n+   than another, or simply because we arbitrarily pick one to be more\n+   canonical).\n+\n+   Once this program has determined the best instruction sequence for\n+   each multiplier, it emits them in a table sorted by the multiplier\n+   so the user can binary-search it to look for a match.  The table is\n+   pruned based on various criteria to keep its sizes reasonable.  */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+#define __STDC_LIMIT_MACROS\n+#include <stdint.h>\n+\n+#include <map>\n+\n+#ifdef TILEPRO\n+\n+/* The string representing the architecture.  */\n+#define ARCH \"tilepro\"\n+\n+/* The type for the multiplication.  */\n+typedef int MUL_TYPE;\n+\n+#else\n+\n+/* The string representing the architecture.  */\n+#define ARCH \"tilegx\"\n+\n+/* The type for the multiplication.  */\n+typedef long long MUL_TYPE;\n+\n+#endif\n+\n+/* Longest instruction sequence this will produce. With the current\n+   stupid algorithm runtime grows very quickly with this number.  */\n+#define MAX_INSTRUCTIONS 4\n+\n+/* Maximum number of subexpressions in the expression DAG being\n+   generated.  This is the same as the number of instructions, except\n+   that zero and the original register we'd like to multiply by a\n+   constant are also thrown into the mix.  */\n+#define MAX_SUBEXPRS (2 + MAX_INSTRUCTIONS)\n+\n+#define MIN(x, y)  ((x) <= (y) ? (x) : (y))\n+#define MAX(x, y)  ((x) >= (y) ? (x) : (y))\n+\n+/* For this program a unary op is one which has only one nonconstant\n+   operand.  So shift left by 5 is considered unary.  */\n+typedef MUL_TYPE (*unary_op_func) (MUL_TYPE);\n+typedef MUL_TYPE (*binary_op_func) (MUL_TYPE, MUL_TYPE);\n+\n+/* This describes an operation like 'add two registers' or 'left-shift\n+   by 7'.\n+\n+   We call something a 'unary' operator if it only takes in one\n+   register as input, even though it might have an implicit second\n+   constant operand.  Currently this is used for left-shift by\n+   constant.  */\n+class Operator\n+{\n+public:\n+  /* Construct for a binary operator.  */\n+  Operator (const char *pattern, const char *name, binary_op_func func,\n+\t    int cost)\n+    : m_pattern (pattern), m_name (name), m_top_index (-1),\n+      m_unary_func (0), m_binary_func (func), m_cost (cost),\n+      m_rhs_if_unary (0)\n+  {\n+  }\n+\n+  /* Construct for a unary operator.  */\n+  Operator (const char *pattern, const char *name, unary_op_func func,\n+\t    int rhs_if_unary, int cost)\n+    : m_pattern (pattern), m_name (name), m_top_index (-1),\n+      m_unary_func (func), m_binary_func (0), m_cost (cost),\n+      m_rhs_if_unary (rhs_if_unary)\n+  {\n+  }\n+\n+  bool is_unary () const\n+  {\n+    return m_binary_func == NULL;\n+  }\n+\n+  /* Name of the pattern for this operation, e.g. CODE_FOR_addsi3.  */\n+  const char *m_pattern;\n+\n+  /* Name of the opcode for this operation, e.g. add.  */\n+  const char *m_name;\n+\n+  /* We don't have enough bits in our output representation to store\n+     the original insn_code value, so we store a compressed form\n+     instead.  These values are decoded back into insn_code via the\n+     machine-generated multiply_insn_seq_decode_opcode lookup\n+     table.  */\n+  int m_top_index;\n+\n+  /* Unary operator to apply, or NULL if this is a binary operator.  */\n+  unary_op_func m_unary_func;\n+\n+  /* Binary operator to apply, or NULL if this is a unary operator.  */\n+  binary_op_func m_binary_func;\n+\n+  /* Function of how expensive we consider this operator. Higher is\n+     worse.  */\n+  int m_cost;\n+\n+  /* the RHS value to write into the C file if unary; used for shift\n+     count.  */\n+  int m_rhs_if_unary;\n+};\n+\n+\n+/* An entry in an expression DAG.  */\n+class Expr\n+{\n+public:\n+  Expr () : m_op (NULL), m_lhs (0), m_rhs (0), m_produced_val (0),\n+    m_critical_path_length (0)\n+  {\n+  }\n+\n+  /* The operator being applied to the operands.  */\n+  const Operator *m_op;\n+\n+  /* The index of the left-hand operand in the array of subexpressions\n+     already computed.  */\n+  int m_lhs;\n+\n+  /* For binary ops ,this is the index of the left-hand operand in the\n+     array of subexpressions already computed. For unary ops, it is\n+     specific to the op (e.g. it might hold a constant shift\n+     count).  */\n+  int m_rhs;\n+\n+  /* The multiplier produced by this expression tree. For example, for\n+     the tree ((x << 5) + x), the value would be 33.  */\n+  MUL_TYPE m_produced_val;\n+\n+  /* How far is this expression from the root, i.e. how many cycles\n+     minimum will it take to compute this?  */\n+  int m_critical_path_length;\n+};\n+\n+\n+/* Make function pointers for the various linear operators we can\n+   apply to compute a multiplicative value.  */\n+\n+static MUL_TYPE\n+add (MUL_TYPE n1, MUL_TYPE n2)\n+{\n+  return n1 + n2;\n+}\n+\n+static MUL_TYPE\n+sub (MUL_TYPE n1, MUL_TYPE n2)\n+{\n+  return n1 - n2;\n+}\n+\n+static MUL_TYPE\n+s1a (MUL_TYPE n1, MUL_TYPE n2)\n+{\n+  return n1 * 2 + n2;\n+}\n+\n+static MUL_TYPE\n+s2a (MUL_TYPE n1, MUL_TYPE n2)\n+{\n+  return n1 * 4 + n2;\n+}\n+\n+static MUL_TYPE\n+s3a (MUL_TYPE n1, MUL_TYPE n2)\n+{\n+  return n1 * 8 + n2;\n+}\n+\n+#define SHIFT(count)                            \\\n+static MUL_TYPE                                 \\\n+shift##count(MUL_TYPE n)                        \\\n+{                                               \\\n+  return n << (count);                          \\\n+}\n+\n+SHIFT (1);\n+SHIFT (2);\n+SHIFT (3);\n+SHIFT (4);\n+SHIFT (5);\n+SHIFT (6);\n+SHIFT (7);\n+SHIFT (8);\n+SHIFT (9);\n+SHIFT (10);\n+SHIFT (11);\n+SHIFT (12);\n+SHIFT (13);\n+SHIFT (14);\n+SHIFT (15);\n+SHIFT (16);\n+SHIFT (17);\n+SHIFT (18);\n+SHIFT (19);\n+SHIFT (20);\n+SHIFT (21);\n+SHIFT (22);\n+SHIFT (23);\n+SHIFT (24);\n+SHIFT (25);\n+SHIFT (26);\n+SHIFT (27);\n+SHIFT (28);\n+SHIFT (29);\n+SHIFT (30);\n+SHIFT (31);\n+#ifndef TILEPRO\n+SHIFT (32);\n+SHIFT (33);\n+SHIFT (34);\n+SHIFT (35);\n+SHIFT (36);\n+SHIFT (37);\n+SHIFT (38);\n+SHIFT (39);\n+SHIFT (40);\n+SHIFT (41);\n+SHIFT (42);\n+SHIFT (43);\n+SHIFT (44);\n+SHIFT (45);\n+SHIFT (46);\n+SHIFT (47);\n+SHIFT (48);\n+SHIFT (49);\n+SHIFT (50);\n+SHIFT (51);\n+SHIFT (52);\n+SHIFT (53);\n+SHIFT (54);\n+SHIFT (55);\n+SHIFT (56);\n+SHIFT (57);\n+SHIFT (58);\n+SHIFT (59);\n+SHIFT (60);\n+SHIFT (61);\n+SHIFT (62);\n+SHIFT (63);\n+#endif\n+\n+#ifdef TILEPRO\n+static Operator ops[] = {\n+  Operator (\"CODE_FOR_addsi3\", \"add\", add, 1040),\n+  Operator (\"CODE_FOR_subsi3\", \"sub\", sub, 1041),\n+  Operator (\"CODE_FOR_insn_s1a\", \"s1a\", s1a, 1042),\n+  Operator (\"CODE_FOR_insn_s2a\", \"s2a\", s2a, 1043),\n+  Operator (\"CODE_FOR_insn_s3a\", \"s3a\", s3a, 1044),\n+  /* Note: shl by 1 is not necessary, since adding a value to itself\n+     produces the same result. But the architecture team thinks\n+     left-shift may use slightly less power, so we might as well\n+     prefer it.  */\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift1, 1, 1001),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift2, 2, 1002),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift3, 3, 1003),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift4, 4, 1004),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift5, 5, 1005),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift6, 6, 1006),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift7, 7, 1007),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift8, 8, 1008),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift9, 9, 1009),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift10, 10, 1010),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift11, 11, 1011),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift12, 12, 1012),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift13, 13, 1013),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift14, 14, 1014),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift15, 15, 1015),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift16, 16, 1016),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift17, 17, 1017),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift18, 18, 1018),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift19, 19, 1019),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift20, 20, 1020),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift21, 21, 1021),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift22, 22, 1022),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift23, 23, 1023),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift24, 24, 1024),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift25, 25, 1025),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift26, 26, 1026),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift27, 27, 1027),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift28, 28, 1028),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift29, 29, 1029),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift30, 30, 1030),\n+  Operator (\"CODE_FOR_ashlsi3\", \"shli\", shift31, 31, 1031)\n+};\n+#else\n+static Operator ops[] = {\n+  Operator (\"CODE_FOR_adddi3\", \"add\", add, 1070),\n+  Operator (\"CODE_FOR_subdi3\", \"sub\", sub, 1071),\n+  Operator (\"CODE_FOR_insn_shl1add\", \"shl1add\", s1a, 1072),\n+  Operator (\"CODE_FOR_insn_shl2add\", \"shl2add\", s2a, 1073),\n+  Operator (\"CODE_FOR_insn_shl3add\", \"shl3add\", s3a, 1074),\n+  // Note: shl by 1 is not necessary, since adding a value to itself\n+  // produces the same result. But the architecture team thinks left-shift\n+  // may use slightly less power, so we might as well prefer it.\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift1, 1, 1001),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift2, 2, 1002),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift3, 3, 1003),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift4, 4, 1004),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift5, 5, 1005),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift6, 6, 1006),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift7, 7, 1007),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift8, 8, 1008),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift9, 9, 1009),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift10, 10, 1010),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift11, 11, 1011),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift12, 12, 1012),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift13, 13, 1013),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift14, 14, 1014),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift15, 15, 1015),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift16, 16, 1016),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift17, 17, 1017),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift18, 18, 1018),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift19, 19, 1019),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift20, 20, 1020),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift21, 21, 1021),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift22, 22, 1022),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift23, 23, 1023),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift24, 24, 1024),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift25, 25, 1025),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift26, 26, 1026),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift27, 27, 1027),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift28, 28, 1028),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift29, 29, 1029),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift30, 30, 1030),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift31, 31, 1031),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift32, 32, 1032),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift33, 33, 1033),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift34, 34, 1034),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift35, 35, 1035),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift36, 36, 1036),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift37, 37, 1037),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift38, 38, 1038),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift39, 39, 1039),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift40, 40, 1040),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift41, 41, 1041),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift42, 42, 1042),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift43, 43, 1043),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift44, 44, 1044),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift45, 45, 1045),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift46, 46, 1046),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift47, 47, 1047),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift48, 48, 1048),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift49, 49, 1049),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift50, 50, 1050),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift51, 51, 1051),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift52, 52, 1052),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift53, 53, 1053),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift54, 54, 1054),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift55, 55, 1055),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift56, 56, 1056),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift57, 57, 1057),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift58, 58, 1058),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift59, 59, 1059),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift60, 60, 1060),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift61, 61, 1061),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift62, 62, 1062),\n+  Operator (\"CODE_FOR_ashldi3\", \"shli\", shift63, 63, 1063)\n+};\n+#endif\n+\n+/* An ExpressionTree is an expression DAG.  */\n+class ExpressionTree\n+{\n+public:\n+  ExpressionTree () : m_num_vals (2)\n+  {\n+    m_exprs[0].m_produced_val = 0;\n+    m_exprs[1].m_produced_val = 1;\n+  }\n+\n+  void copy_technique_from (ExpressionTree * other)\n+  {\n+    /* TODO: write this; other can compute the same products with less\n+       cost.  We update this ExpressionTree object because some int is\n+       already mapped to it.  */\n+  }\n+\n+  int m_num_vals;\n+  Expr m_exprs[MAX_SUBEXPRS];\n+\n+  int cost () const\n+  {\n+    int cost = 0;\n+    for (int j = 2; j < m_num_vals; j++)\n+        cost += m_exprs[j].m_op->m_cost;\n+      return cost + m_exprs[m_num_vals - 1].m_critical_path_length * 1000000;\n+  }\n+};\n+\n+\n+typedef std::map<MUL_TYPE, ExpressionTree *> ExpressionTreeMap;\n+\n+\n+static void\n+find_sequences (ExpressionTree &s, ExpressionTreeMap &best_solution)\n+{\n+  /* Don't look more if we can't add any new values to the expression\n+     tree.  */\n+  const int num_vals = s.m_num_vals;\n+  if (num_vals == MAX_SUBEXPRS)\n+    return;\n+\n+  /* Grow array to make room for new values added as we loop.  */\n+  s.m_num_vals = num_vals + 1;\n+\n+  const Operator *const prev_op = s.m_exprs[num_vals - 1].m_op;\n+  const int prev_top_index = (prev_op != NULL) ? prev_op->m_top_index : -1;\n+\n+  for (size_t f = 0; f < sizeof ops / sizeof ops[0]; f++)\n+    {\n+      const Operator *const op = &ops[f];\n+\n+      for (int i = 0; i < num_vals; i++)\n+\t{\n+\t  /* Only allow zero as the first operand to sub, otherwise\n+\t     it is useless.  */\n+\t  if (i == 0 && op->m_binary_func != sub)\n+\t    continue;\n+\n+\t  /* Unary ops don't actually use the second operand, so as a\n+\t     big hack we trick it into only looping once in the inner\n+\t     loop.  */\n+\t  const int j_end = op->is_unary () ? 2 : num_vals;\n+\n+\t  /* We never allow zero as the second operand, as it is\n+\t     always useless.  */\n+\t  for (int j = 1; j < j_end; j++)\n+\t    {\n+\t      /* Does this expression use the immediately previous\n+\t\t expression?  */\n+\t      const bool uses_prev_value =\n+\t\t(i == num_vals - 1\n+\t\t || (!op->is_unary () && j == num_vals - 1));\n+\n+\t      if (!uses_prev_value)\n+\t\t{\n+\t\t  /* For search efficiency, prune redundant\n+\t\t     instruction orderings.\n+\n+\t\t     This op does not take the immediately preceding\n+\t\t     value as input, which means we could have done it\n+\t\t     in the previous slot. If its opcode is less than\n+\t\t     the previous instruction's, we'll declare this\n+\t\t     instruction order non-canonical and not pursue\n+\t\t     this branch of the search.  */\n+\t\t  if (op->m_top_index < prev_top_index)\n+\t\t    continue;\n+\t\t}\n+\n+\t      MUL_TYPE n;\n+\t      if (op->is_unary ())\n+\t\t{\n+\t\t  n = op->m_unary_func (s.m_exprs[i].m_produced_val);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  n = op->m_binary_func (s.m_exprs[i].m_produced_val,\n+\t\t\t\t\t s.m_exprs[j].m_produced_val);\n+\t\t}\n+\n+\t      bool duplicate = false;\n+\t      for (int k = 0; k < num_vals; k++)\n+\t\tif (n == s.m_exprs[j].m_produced_val)\n+\t\t  {\n+\t\t    duplicate = true;\n+\t\t    break;\n+\t\t  }\n+\n+\t      if (duplicate)\n+\t\tcontinue;\n+\n+\t      /* See if we found the best solution for n.  */\n+\t      Expr *e = &s.m_exprs[num_vals];\n+\t      e->m_op = op;\n+\t      e->m_lhs = i;\n+\t      e->m_rhs = op->is_unary () ? op->m_rhs_if_unary : j;\n+\t      e->m_produced_val = n;\n+\t      e->m_critical_path_length =\n+\t\t1 + MAX (s.m_exprs[i].m_critical_path_length,\n+\t\t\t s.m_exprs[j].m_critical_path_length);\n+\n+\t      ExpressionTreeMap::iterator best (best_solution.find (n));\n+\t      if (best == best_solution.end ()\n+\t\t  || (*best).second->cost () > s.cost ())\n+\t\tbest_solution[n] = new ExpressionTree (s);\n+\n+\t      /* Recurse and find more.  */\n+\t      find_sequences (s, best_solution);\n+\t    }\n+\t}\n+    }\n+\n+  /* Restore old size.  */\n+  s.m_num_vals = num_vals;\n+}\n+\n+\n+/* For each insn_code used by an operator, choose a compact number so\n+   it takes less space in the output data structure. This prints out a\n+   lookup table used to map the compactified number back to an\n+   insn_code.  */\n+static void\n+create_insn_code_compression_table ()\n+{\n+  int next_index = 1;\n+\n+  /* Entry 0 must hold CODE_FOR_nothing to mean \"end of array\".  */\n+  printf (\"const enum insn_code %s_multiply_insn_seq_decode_opcode[] = {\\n\"\n+\t  \"  CODE_FOR_nothing /* must be first */ \", ARCH);\n+\n+  for (size_t i = 0; i < sizeof ops / sizeof ops[0]; i++)\n+    {\n+      Operator *op = &ops[i];\n+      int index = -1;\n+\n+      /* See if some previous Operator was using the same insn_code.\n+\t If so, reuse its table entry.  */\n+      for (size_t j = 0; j < i; j++)\n+\t{\n+\t  Operator *old = &ops[j];\n+\t  if (strcmp (old->m_pattern, op->m_pattern) == 0)\n+\t    {\n+\t      index = old->m_top_index;\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (index == -1)\n+\t{\n+\t  /* We need to make a new entry in the table.  */\n+\t  printf (\",\\n  %s\", op->m_pattern);\n+\t  index = next_index++;\n+\t}\n+\n+      op->m_top_index = index;\n+    }\n+\n+  printf (\"\\n};\\n\\n\");\n+}\n+\n+\n+/* These are constants we've seen in code, that we want to keep table\n+   entries for.  */\n+static int multiply_constants_used[] = {\n+  -11796480,\n+  -27439,\n+  -25148,\n+  -22820,\n+  -21709,\n+  -20995,\n+  -20284,\n+  -20239,\n+  -19595,\n+  -19447,\n+  -19183,\n+  -19165,\n+  -18730,\n+  -17828,\n+  -17799,\n+  -17237,\n+  -17036,\n+  -16549,\n+  -16423,\n+  -16294,\n+  -16244,\n+  -16069,\n+  -15137,\n+  -15083,\n+  -15038,\n+  -14924,\n+  -14905,\n+  -14752,\n+  -14731,\n+  -14529,\n+  -14273,\n+  -14090,\n+  -14084,\n+  -14043,\n+  -13850,\n+  -13802,\n+  -13631,\n+  -13455,\n+  -13275,\n+  -12879,\n+  -12700,\n+  -12534,\n+  -12399,\n+  -12131,\n+  -12112,\n+  -12054,\n+  -12019,\n+  -11759,\n+  -11585,\n+  -11467,\n+  -11395,\n+  -11295,\n+  -11248,\n+  -11148,\n+  -11116,\n+  -11086,\n+  -11059,\n+  -11018,\n+  -10811,\n+  -10538,\n+  -10258,\n+  -10217,\n+  -10033,\n+  -9766,\n+  -9754,\n+  -9534,\n+  -9527,\n+  -9467,\n+  -9262,\n+  -9232,\n+  -9222,\n+  -9198,\n+  -9191,\n+  -9113,\n+  -8825,\n+  -8756,\n+  -8697,\n+  -8693,\n+  -8565,\n+  -8342,\n+  -8208,\n+  -8200,\n+  -8170,\n+  -8102,\n+  -7770,\n+  -7678,\n+  -7562,\n+  -7376,\n+  -7373,\n+  -7221,\n+  -7121,\n+  -6835,\n+  -6810,\n+  -6626,\n+  -6581,\n+  -6461,\n+  -6278,\n+  -6263,\n+  -6163,\n+  -6029,\n+  -5816,\n+  -5540,\n+  -5461,\n+  -5384,\n+  -5329,\n+  -4985,\n+  -4926,\n+  -4815,\n+  -4788,\n+  -4758,\n+  -4433,\n+  -4229,\n+  -4209,\n+  -4176,\n+  -4104,\n+  -4095,\n+  -4078,\n+  -3941,\n+  -3818,\n+  -3600,\n+  -3474,\n+  -3314,\n+  -3264,\n+  -3196,\n+  -3072,\n+  -2912,\n+  -2836,\n+  -2773,\n+  -2269,\n+  -2184,\n+  -2100,\n+  -1730,\n+  -1512,\n+  -1500,\n+  -1396,\n+  -1344,\n+  -1312,\n+  -1297,\n+  -1059,\n+  -1058,\n+  1027,\n+  1049,\n+  1059,\n+  1100,\n+  1104,\n+  1108,\n+  1136,\n+  1200,\n+  1204,\n+  1242,\n+  1292,\n+  1304,\n+  1312,\n+  1320,\n+  1336,\n+  1344,\n+  1348,\n+  1360,\n+  1364,\n+  1395,\n+  1448,\n+  1460,\n+  1461,\n+  1472,\n+  1488,\n+  1500,\n+  1512,\n+  1568,\n+  1576,\n+  1649,\n+  1664,\n+  1684,\n+  1696,\n+  1744,\n+  1812,\n+  1822,\n+  1884,\n+  1963,\n+  1978,\n+  2000,\n+  2012,\n+  2014,\n+  2037,\n+  2039,\n+  2100,\n+  2139,\n+  2144,\n+  2184,\n+  2237,\n+  2260,\n+  2320,\n+  2408,\n+  2446,\n+  2447,\n+  2499,\n+  2531,\n+  2578,\n+  2592,\n+  2611,\n+  2633,\n+  2704,\n+  2730,\n+  2773,\n+  2880,\n+  2896,\n+  2998,\n+  3000,\n+  3001,\n+  3021,\n+  3079,\n+  3112,\n+  3150,\n+  3179,\n+  3192,\n+  3240,\n+  3264,\n+  3271,\n+  3283,\n+  3328,\n+  3363,\n+  3367,\n+  3453,\n+  3529,\n+  3570,\n+  3580,\n+  3600,\n+  3624,\n+  3707,\n+  3783,\n+  3826,\n+  3897,\n+  3941,\n+  3962,\n+  3989,\n+  4000,\n+  4025,\n+  4073,\n+  4093,\n+  4099,\n+  4108,\n+  4184,\n+  4209,\n+  4369,\n+  4376,\n+  4416,\n+  4433,\n+  4434,\n+  4482,\n+  4582,\n+  4712,\n+  4717,\n+  4813,\n+  4815,\n+  4864,\n+  5000,\n+  5027,\n+  5040,\n+  5091,\n+  5195,\n+  5243,\n+  5260,\n+  5285,\n+  5329,\n+  5331,\n+  5350,\n+  5361,\n+  5387,\n+  5461,\n+  5492,\n+  5529,\n+  5573,\n+  5793,\n+  5819,\n+  5915,\n+  5946,\n+  5992,\n+  6000,\n+  6164,\n+  6205,\n+  6262,\n+  6263,\n+  6269,\n+  6270,\n+  6387,\n+  6400,\n+  6406,\n+  6476,\n+  6541,\n+  6565,\n+  6568,\n+  6626,\n+  6656,\n+  6732,\n+  6810,\n+  6817,\n+  6859,\n+  7040,\n+  7053,\n+  7141,\n+  7169,\n+  7221,\n+  7223,\n+  7274,\n+  7282,\n+  7350,\n+  7369,\n+  7373,\n+  7442,\n+  7447,\n+  7471,\n+  7518,\n+  7542,\n+  7566,\n+  7587,\n+  7663,\n+  7678,\n+  7682,\n+  7748,\n+  7752,\n+  7791,\n+  8000,\n+  8026,\n+  8048,\n+  8170,\n+  8203,\n+  8204,\n+  8290,\n+  8368,\n+  8520,\n+  8640,\n+  8666,\n+  8672,\n+  8697,\n+  8716,\n+  8728,\n+  8756,\n+  8820,\n+  8875,\n+  8918,\n+  8956,\n+  9058,\n+  9154,\n+  9175,\n+  9191,\n+  9217,\n+  9262,\n+  9321,\n+  9373,\n+  9434,\n+  9465,\n+  9514,\n+  9534,\n+  9633,\n+  9746,\n+  9810,\n+  9850,\n+  9947,\n+  9973,\n+  10000,\n+  10009,\n+  10033,\n+  10055,\n+  10217,\n+  10248,\n+  10298,\n+  10310,\n+  10323,\n+  10368,\n+  10438,\n+  10456,\n+  10486,\n+  10538,\n+  10664,\n+  10695,\n+  10700,\n+  10703,\n+  10832,\n+  10887,\n+  10935,\n+  10958,\n+  11018,\n+  11059,\n+  11061,\n+  11086,\n+  11116,\n+  11148,\n+  11190,\n+  11249,\n+  11314,\n+  11332,\n+  11363,\n+  11409,\n+  11415,\n+  11443,\n+  11467,\n+  11512,\n+  11522,\n+  11529,\n+  11585,\n+  11759,\n+  11768,\n+  11795,\n+  11893,\n+  11997,\n+  12131,\n+  12299,\n+  12536,\n+  12543,\n+  12893,\n+  12945,\n+  12998,\n+  13109,\n+  13213,\n+  13685,\n+  13930,\n+  14023,\n+  14024,\n+  14271,\n+  14564,\n+  14647,\n+  15326,\n+  15850,\n+  15855,\n+  15929,\n+  16000,\n+  16154,\n+  16496,\n+  16807,\n+  16819,\n+  16984,\n+  17203,\n+  17223,\n+  17333,\n+  17760,\n+  17799,\n+  17837,\n+  18029,\n+  18068,\n+  18336,\n+  18515,\n+  19595,\n+  20017,\n+  20131,\n+  20862,\n+  20995,\n+  21709,\n+  22554,\n+  25000,\n+  25172,\n+  25600,\n+  25733,\n+  27439,\n+  38470,\n+  46802,\n+  50000,\n+  11796480,\n+  16843009,\n+  23592960,\n+};\n+\n+\n+const int num_mult_constants_used =\n+  (int)(sizeof multiply_constants_used\n+\t/ sizeof multiply_constants_used[0]);\n+\n+\n+#define XSIZE (sizeof multiply_constants_used / \\\n+\t       sizeof multiply_constants_used[0] + 32) / 32\n+unsigned multiply_constants_avail[XSIZE];\n+#undef XSIZE\n+\n+\n+/* bsearch helper function.  */\n+static int\n+compare_constants (const void *key, const void *t)\n+{\n+  return (*(int*)key) - *((int*)t);\n+}\n+\n+\n+static int *\n+find_mult_constants_used (int multiplier)\n+{\n+  return (int *) bsearch (&multiplier, multiply_constants_used,\n+\t\t\t  num_mult_constants_used,\n+\t\t\t  sizeof multiply_constants_used[0],\n+\t\t\t  compare_constants);\n+}\n+\n+\n+int num_ops (ExpressionTree *s)\n+{\n+  int n = 0;\n+  for (int i = 0; i < s->m_num_vals; i++)\n+    {\n+      Expr *e = &s->m_exprs[i];\n+      if (e->m_op != NULL)\n+\tn++;\n+    }\n+  return n;\n+}\n+\n+\n+#ifdef TILEPRO\n+bool\n+tilepro_emit (int multiplier, int num_ops)\n+{\n+  int abs_multiplier = (multiplier >= 0) ? multiplier : -multiplier;\n+\n+  /* Keep constants in range [-1024, 1024].  */\n+  if (abs_multiplier <= 1024)\n+    return true;\n+\n+  /* Keep constants near powers of two.  */\n+  int prev_pow2 = 1 << (31 - __builtin_clz (abs_multiplier));\n+  int next_pow2 = prev_pow2 << 1;\n+\n+  if ((abs_multiplier - prev_pow2 <= 10)\n+      || (next_pow2 - abs_multiplier <= 10))\n+    return true;\n+\n+  /* Keep constants near powers of ten.  */\n+  {\n+    long long j = 1;\n+    long long prev_pow10;\n+    long long next_pow10;\n+\n+    while (((j * 10) < abs_multiplier)\n+\t   && (j < (j * 10)))\n+      j = j * 10;\n+\n+    prev_pow10 = j;\n+    next_pow10 = j * 10;\n+\n+    if ((abs_multiplier - prev_pow10 <= 10)\n+\t|| (next_pow10 - abs_multiplier <= 10))\n+      return true;\n+  }\n+\n+  /* Keep short sequences that have two or fewer ops.  */\n+  if (num_ops <= 2)\n+    return true;\n+\n+  /* Keep constants that are mostly 0's or mostly 1's.  */\n+  if (__builtin_popcount (multiplier) <= 2 ||\n+      __builtin_popcount (multiplier) >= 30)\n+    return true;\n+\n+  /* Keep constants seen in actual code.  */\n+  if ((find_mult_constants_used (multiplier)))\n+    return true;\n+\n+  return false;\n+}\n+#else\n+bool\n+tilegx_emit (long long multiplier, int num_ops)\n+{\n+  long long abs_multiplier = (multiplier >= 0) ? multiplier : - multiplier;\n+\n+  /* Keep constants in range [-1024, 1024].  */\n+  if (abs_multiplier <= 1024)\n+    return true;\n+\n+  /* Otherwise exclude sequences with four ops.  */\n+  if (num_ops > 3)\n+    return false;\n+\n+  /* Keep constants near powers of two.  */\n+  {\n+    unsigned long long prev_pow2 =\n+      1LL << (63 - __builtin_clzll (abs_multiplier));\n+    unsigned long long next_pow2 = prev_pow2 << 1;\n+\n+    /* handle overflow case. */\n+    if (next_pow2 == 0)\n+      {\n+\tif (prev_pow2 - abs_multiplier <= 10)\n+\t  return true;\n+      }\n+    else if ((abs_multiplier - prev_pow2 <= 10)\n+\t     || (next_pow2 - abs_multiplier <= 10))\n+      return true;\n+  }\n+\n+  /* Keep constants near powers of ten.  */\n+  {\n+    long long j = 1;\n+    long long prev_pow10;\n+    long long next_pow10;\n+\n+    while (((j * 10) < abs_multiplier)\n+\t   && (j < (INTMAX_MAX / 10)))\n+      j = j * 10;\n+\n+    prev_pow10 = j;\n+    next_pow10 = (j > (INTMAX_MAX / 10)) ? 0 : j * 10;\n+\n+    if ((abs_multiplier - prev_pow10 <= 100)\n+\t|| (next_pow10\n+\t    && (next_pow10 - abs_multiplier <= 100)))\n+      return true;\n+  }\n+\n+  if (num_ops <= 2)\n+    return true;\n+\n+  /* Keep constants that are mostly 0's or mostly 1's.  */\n+  if (__builtin_popcountll (multiplier) <= 2 ||\n+      __builtin_popcountll (multiplier) >= 62)\n+    return true;\n+\n+  /* Keep constants seen in actual code.  */\n+  if (find_mult_constants_used (multiplier))\n+    return true;\n+\n+  return false;\n+}\n+#endif\n+\n+\n+int\n+main ()\n+{\n+  ExpressionTreeMap best_solution;\n+  ExpressionTree s;\n+\n+#ifdef TILEPRO\n+  printf (\"/* Constant multiply table for TILEPro.\\n\");\n+#else\n+  printf (\"/* Constant multiply table for TILE-Gx.\\n\");\n+#endif\n+  printf (\"   Copyright (C) 2011, 2012\\n\");\n+  printf (\"   Free Software Foundation, Inc.\\n\");\n+  printf (\"   Contributed by Walter Lee (walt@tilera.com)\\n\");\n+  printf (\"\\n\");\n+  printf (\"   This file is part of GCC.\\n\");\n+  printf (\"\\n\");\n+  printf (\"   GCC is free software; you can redistribute it and/or modify it\\n\");\n+  printf (\"   under the terms of the GNU General Public License as published\\n\");\n+  printf (\"   by the Free Software Foundation; either version 3, or (at your\\n\");\n+  printf (\"   option) any later version.\\n\");\n+  printf (\"\\n\");\n+  printf (\"   GCC is distributed in the hope that it will be useful, but WITHOUT\\n\");\n+  printf (\"   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\\n\");\n+  printf (\"   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\\n\");\n+  printf (\"   License for more details.\\n\");\n+  printf (\"\\n\");\n+  printf (\"   You should have received a copy of the GNU General Public License\\n\");\n+  printf (\"   along with GCC; see the file COPYING3.  If not see\\n\");\n+  printf (\"   <http://www.gnu.org/licenses/>.  */\\n\");\n+  printf (\"\\n\");\n+  printf (\"#include \\\"config.h\\\"\\n\");\n+  printf (\"#include \\\"system.h\\\"\\n\");\n+  printf (\"#include \\\"coretypes.h\\\"\\n\");\n+  printf (\"#include \\\"expr.h\\\"\\n\");\n+  printf (\"#include \\\"optabs.h\\\"\\n\");\n+  printf (\"#include \\\"%s-multiply.h\\\"\\n\\n\", ARCH);\n+  create_insn_code_compression_table ();\n+\n+  /* Try all combinations of operators and see what constants we\n+     produce.  For each possible constant, record the most efficient\n+     way to generate it.  */\n+  find_sequences (s, best_solution);\n+\n+  printf (\"const struct %s_multiply_insn_seq \"\n+\t  \"%s_multiply_insn_seq_table[] = {\\n\",\n+\t  ARCH, ARCH);\n+\n+  const char *comma_separator = \"\";\n+\n+  ExpressionTreeMap::iterator i (best_solution.begin ());\n+  for (; i != best_solution.end (); ++i)\n+    {\n+      ExpressionTree *s = (*i).second;\n+      const MUL_TYPE n = (*i).first;\n+\n+      if (n == 0 || n == 1)\n+\t{\n+\t  /* Both of these require zero operations, so these entries\n+\t     are bogus and should never be used.  */\n+\t  continue;\n+\t}\n+\n+      /* Prune the list of entries to keep the table to a reasonable\n+\t size.  */\n+#ifdef TILEPRO\n+      if (!tilepro_emit (n, num_ops (s)))\n+\tcontinue;\n+#else\n+      if (!tilegx_emit (n, num_ops (s)))\n+\tcontinue;\n+#endif\n+\n+      printf (\"%s\", comma_separator);\n+\n+#ifdef TILEPRO\n+      const MUL_TYPE int_min = INT32_MIN;\n+#else\n+      const MUL_TYPE int_min = INT64_MIN;\n+#endif\n+      if (n == int_min)\n+\t{\n+\t  /* Handle C's woeful lack of unary negation. Without this,\n+\t     printing out INT_MIN in decimal will yield an unsigned\n+\t     int which could generate a compiler warning.  */\n+#ifdef TILEPRO\n+\t  printf (\"  {%d - 1 /* 0x%x */ ,\\n   {\", n + 1,\n+\t\t  (unsigned) n);\n+#else\n+\t  printf (\"  {%lldll - 1 /* 0x%llx */ ,\\n   {\", n + 1,\n+\t\t  (unsigned MUL_TYPE) n);\n+#endif\n+\t}\n+      else\n+\t{\n+#ifdef TILEPRO\n+\t  printf (\"  {%d /* 0x%x */ ,\\n   {\", n, (unsigned) n);\n+#else\n+\t  printf (\"  {%lldll /* 0x%llx */ ,\\n   {\", n, (unsigned MUL_TYPE) n);\n+#endif\n+\t}\n+\n+      bool first = true;\n+      for (int j = 0; j < s->m_num_vals; j++)\n+\t{\n+\t  Expr *e = &s->m_exprs[j];\n+\n+\t  const Operator *op = e->m_op;\n+\t  if (op == NULL)\n+\t    continue;\n+\n+\t  char buf[1024];\n+\t  snprintf (buf, sizeof buf, \"%s{%d, %d, %d}%s\",\n+\t\t    first ? \"\" : \"    \",\n+\t\t    op->m_top_index,\n+\t\t    e->m_lhs, e->m_rhs, (j + 1) == s->m_num_vals ? \"}\" : \",\");\n+\n+\t  char opnd0[10];\n+\t  if (e->m_lhs)\n+\t    snprintf (opnd0, sizeof opnd0, \"r%d\", e->m_lhs);\n+\t  else\n+\t    snprintf (opnd0, sizeof opnd0, \"zero\");\n+\n+\t  printf (\"%s\\t\\t\\t/* %s r%d, %s, %s%d */\\n\",\n+\t\t  buf, op->m_name, j, opnd0,\n+\t\t  op->is_unary () ? \"\" : \"r\", e->m_rhs);\n+\n+\t  first = false;\n+\t}\n+      printf (\"   }\");\n+      comma_separator = \",\\n\";\n+    }\n+\n+  printf (\"\\n};\\n\\n\");\n+  printf (\"const int %s_multiply_insn_seq_table_size =\\n\"\n+\t  \"  (int) (sizeof %s_multiply_insn_seq_table\\n\"\n+\t  \"         / sizeof %s_multiply_insn_seq_table[0]);\\n\",\n+\t  ARCH, ARCH, ARCH);\n+\n+  return EXIT_SUCCESS;\n+}"}, {"sha": "c96399fdaddf59360e7ce2aef0615b4b640a87c4", "filename": "gcc/config/tilepro/linux.h", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Flinux.h?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,65 @@\n+/* Definitions for TILEPro running Linux-based GNU systems with ELF.\n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#undef CPP_SPEC\n+#define CPP_SPEC \"%{pthread:-D_REENTRANT}\"\n+\n+#undef\tLINK_SPEC\n+#define LINK_SPEC \"\\\n+  %{shared:-shared} \\\n+  %{!shared: \\\n+    %{!static: \\\n+      %{rdynamic:-export-dynamic} \\\n+      -dynamic-linker /lib/ld.so.1} \\\n+    %{static:-static}}\"\n+\n+#define NO_PROFILE_COUNTERS\t1\n+\n+#undef MCOUNT_NAME\n+#define MCOUNT_NAME \"__mcount\"\n+\n+#undef NEED_INDICATE_EXEC_STACK\n+#define NEED_INDICATE_EXEC_STACK 1\n+\n+#ifdef TARGET_LIBC_PROVIDES_SSP\n+/* TILEPro glibc provides __stack_chk_guard two pointer-size words before\n+   tp. */\n+#define TARGET_THREAD_SSP_OFFSET (-2 * GET_MODE_SIZE (ptr_mode))\n+#endif\n+\n+/* For __clear_cache in libgcc2.c.  */\n+#ifdef IN_LIBGCC2\n+\n+#include <arch/icache.h>\n+\n+/* Use the minimum page size of 4K.  Alternatively we can call getpagesize()\n+   but it introduces a libc dependence.  */\n+#undef CLEAR_INSN_CACHE\n+#define CLEAR_INSN_CACHE(beg, end) invalidate_icache (beg, end - beg, 4096)\n+\n+#else\n+\n+/* define CLEAR_INSN_CACHE so that gcc knows to expand __builtin__clear_cache\n+   to the libraray call.  */\n+#undef CLEAR_INSN_CACHE\n+#define CLEAR_INSN_CACHE 1\n+\n+#endif"}, {"sha": "742e061bfe9cb240e52cfe43750f154f42afd1dc", "filename": "gcc/config/tilepro/mul-tables.c", "status": "added", "additions": 17832, "deletions": 0, "changes": 17832, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Fmul-tables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Fmul-tables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Fmul-tables.c?ref=dd552284fd817c9d946598a7b647f9e67753bed6"}, {"sha": "6c4ffbe4a206642714ee3724db0bac07e5ccc20f", "filename": "gcc/config/tilepro/predicates.md", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Fpredicates.md?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,261 @@\n+;; Predicate definitions for Tilera TILEPro chip.\n+;; Copyright (C) 2011, 2012\n+;; Free Software Foundation, Inc.\n+;; Contributed by Walter Lee (walt@tilera.com)\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; Return true if OP is the zero constant for MODE.\n+(define_predicate \"const_zero_operand\"\n+  (and (match_code \"const_int,const_double,const_vector\")\n+       (match_test \"op == CONST0_RTX (mode)\")))\n+\n+;; Returns true if OP is either the constant zero or a register.\n+(define_predicate \"reg_or_0_operand\"\n+  (and (ior (match_operand 0 \"register_operand\")\n+\t    (match_operand 0 \"const_zero_operand\"))\n+       (match_test \"GET_MODE_SIZE (mode) <= UNITS_PER_WORD\")))\n+\n+; Return 1 if OP is a network register identifier.\n+(define_predicate \"netreg_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 6)\")))\n+\n+; Return 1 if OP is an unsigned 5-bit constant.\n+(define_predicate \"u5bit_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) == (INTVAL (op) & 0x1F)\")))\n+\n+;; Return 1 if OP is an unsigned 16-bit constant.\n+(define_predicate \"u16bit_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(unsigned HOST_WIDE_INT)INTVAL (op) < (1U << 16)\")))\n+\n+;; Return 1 if OP is a signed 8-bit constant.\n+(define_predicate \"s8bit_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"satisfies_constraint_I (op)\")))\n+\n+;; Return 1 if OP is a signed 16-bit constant.\n+(define_predicate \"s16bit_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"satisfies_constraint_J (op)\")))\n+\n+;; Return 1 if OP is a nonzero integer constant whose low 16 bits are zero.\n+(define_predicate \"auli_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"satisfies_constraint_K (op)\")))\n+\n+;; Return 1 if OP is an unsigned 15-bit constant.\n+(define_predicate \"u15bit_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(unsigned HOST_WIDE_INT)INTVAL (op) < (1U << 15)\")))\n+\n+;; Return 1 if OP is a constant or any register.\n+(define_predicate \"reg_or_cint_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"const_int_operand\")))\n+\n+;; Return 1 if OP is a 4-element vector constant with identical signed\n+;; 8-bit elements or any register.\n+(define_predicate \"reg_or_v4s8bit_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_code \"const_vector\")\n+\t    (match_test \"CONST_VECTOR_NUNITS (op) == 4\n+                         && satisfies_constraint_I (CONST_VECTOR_ELT (op, 0))\n+                         && CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 1)\n+                         && CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 2)\n+                         && CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 3)\"))))\n+\n+;; Return 1 if OP is a 2-element vector constant with identical signed\n+;; 8-bit elements or any register.\n+(define_predicate \"reg_or_v2s8bit_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_code \"const_vector\")\n+\t    (match_test \"CONST_VECTOR_NUNITS (op) == 2\n+                         && satisfies_constraint_I (CONST_VECTOR_ELT (op, 0))\n+                         && CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 1)\"))))\n+\n+;; Return 1 if the operand is a valid second operand to an add insn.\n+(define_predicate \"add_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"satisfies_constraint_J (op) || satisfies_constraint_K (op)\")\n+    (match_operand 0 \"register_operand\")))\n+\n+;; Return 1 if the operand is a register or signed 8-bit immediate operand.\n+(define_predicate \"reg_or_s8bit_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"satisfies_constraint_I (op)\")\n+    (match_operand 0 \"register_operand\")))\n+\n+;; Return 1 for an operand suitable for ANDing with a register.\n+(define_predicate \"and_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"satisfies_constraint_I (op) || satisfies_constraint_M (op)\")\n+    (match_operand 0 \"register_operand\")))\n+\n+;; Return 1 if the operand is a register or unsigned 5-bit immediate operand.\n+(define_predicate \"reg_or_u5bit_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"INTVAL (op) == (INTVAL (op) & 0x1F)\")\n+    (match_operand 0 \"register_operand\")))\n+\n+; Return 1 if the operand is 2, 4 or 8.\n+(define_predicate \"cint_248_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test\n+        \"INTVAL (op) == 2 || INTVAL (op) == 4 || INTVAL (op) == 8\")))\n+\n+\n+;; Return true if OP is a TLS symbolic operand.\n+(define_predicate \"tls_symbolic_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"SYMBOL_REF_TLS_MODEL (op) !=  TLS_MODEL_NONE\")))\n+\n+;; Return true if OP is a symbolic operand for the TLS Global Dynamic model.\n+(define_predicate \"tls_gd_symbolic_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_GLOBAL_DYNAMIC\")))\n+\n+;; Return true if OP is a symbolic operand for the TLS Local Dynamic model.\n+(define_predicate \"tls_ld_symbolic_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_DYNAMIC\")))\n+\n+;; Return true if OP is a symbolic operand that can be used for the\n+;; TLS Initial Exec model.\n+(define_predicate \"tls_ie_symbolic_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (ior (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_INITIAL_EXEC\")\n+            (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_EXEC\"))))\n+\n+;; Return true if OP is a symbolic operand for the TLS Local Exec model.\n+(define_predicate \"tls_le_symbolic_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_EXEC\")))\n+\n+;; Returns true if OP is any general operand except for an\n+;; auto-incrementing address operand.\n+(define_predicate \"nonautoinc_operand\"\n+  (and (match_operand 0 \"general_operand\")\n+       (not (ior (match_code \"pre_dec\") (match_code \"pre_inc\")\n+\t\t (match_code \"post_dec\") (match_code \"post_inc\")\n+\t\t (match_code \"post_modify\") (match_code \"pre_modify\")))))\n+\n+;; Returns true if OP is a non-auto-incrementing memory operand.\n+(define_predicate \"nonautoincmem_operand\"\n+  (match_operand 0 \"memory_operand\")\n+{\n+  return nonautoinc_operand (XEXP (op, 0), GET_MODE (XEXP (op, 0)));\n+})\n+\n+;; Returns true if OP is a non-auto-incrementing memory, general\n+;; operand.\n+(define_predicate \"nonautoincmem_general_operand\"\n+  (match_operand 0 \"general_operand\")\n+{\n+  if (memory_operand (op, mode))\n+    return nonautoinc_operand (XEXP (op, 0), GET_MODE (XEXP (op, 0)));\n+  else\n+    return true;\n+})\n+ \n+;; Returns true if OP is a non-auto-incrementing memory, non-immediate\n+;; operand.\n+(define_predicate \"nonautoincmem_nonimmediate_operand\"\n+  (match_operand 0 \"nonimmediate_operand\")\n+{\n+  if (memory_operand (op, mode))\n+    return nonautoinc_operand (XEXP (op, 0), GET_MODE (XEXP (op, 0)));\n+  else\n+    return true;\n+})\n+ \n+;; Return true if OP is a valid operand for the source of a move insn.\n+(define_predicate \"move_operand\"\n+  (match_operand 0 \"general_operand\")\n+{\n+  /* If both modes are non-void they must be the same.  */\n+  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n+    return false;\n+\n+  if (GET_MODE_SIZE (mode) > 4)\n+    return false;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case CONST_INT:\n+      return (satisfies_constraint_J (op)\n+              || satisfies_constraint_K (op)\n+              || satisfies_constraint_N (op)\n+              || satisfies_constraint_P (op));\n+\n+    case HIGH:\n+      return true;\n+\n+    case MEM:\n+      return memory_address_p (mode, XEXP (op, 0));\n+\n+    default:\n+      return register_operand (op, mode);\n+    }\n+})\n+\n+;; Returns 1 if OP is a symbolic operand, i.e. a symbol_ref or a label_ref,\n+;; possibly with an offset.\n+(define_predicate \"symbolic_operand\"\n+  (ior (match_code \"symbol_ref,label_ref\")\n+       (and (match_code \"const\")\n+\t    (match_test \"GET_CODE (XEXP (op,0)) == PLUS\n+\t\t\t && (GET_CODE (XEXP (XEXP (op,0), 0)) == SYMBOL_REF\n+\t\t\t     || GET_CODE (XEXP (XEXP (op,0), 0)) == LABEL_REF)\n+\t\t\t && CONST_INT_P (XEXP (XEXP (op,0), 1))\"))))\n+\n+;; Returns 1 if OP is a symbolic operand, or a const unspec wrapper\n+;; representing a got reference, a tls reference, or pc-relative\n+;; reference.\n+(define_predicate \"const_symbolic_operand\"\n+  (ior (match_operand 0 \"symbolic_operand\")\n+       (and (match_code \"const\")\n+\t    (match_test \"GET_CODE (XEXP (op,0)) == UNSPEC\")\n+\t    (ior (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_GOT16_SYM\")\n+\t\t (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_GOT32_SYM\")\n+\t\t (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_PCREL_SYM\")\n+\t\t (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_TLS_GD\")\n+\t\t (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_TLS_IE\")\n+\t\t (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_TLS_LE\")))))\n+\n+;; Return true if OP is an address suitable for a call insn.\n+;; Call insn on TILE can take a PC-relative constant address\n+;; or any regular memory address.\n+(define_predicate \"call_address_operand\"\n+  (ior (match_operand 0 \"symbolic_operand\")\n+       (match_test \"memory_address_p (Pmode, op)\")))\n+\n+;; Return true if OP is an operand suitable for a call insn.\n+(define_predicate \"call_operand\"\n+  (and (match_code \"mem\")\n+       (match_test \"call_address_operand (XEXP (op, 0), mode)\")))\n+\n+;; Return 1 if OP is a signed comparison operation.\n+;; We can use these directly in compares against zero.\n+(define_predicate \"signed_comparison_operator\"\n+  (match_code \"eq,ne,le,lt,ge,gt\"))\n+\n+;; Return 1 if OP is a equal or not-equal operation.\n+(define_predicate \"eqne_operator\"\n+  (match_code \"eq,ne\"))"}, {"sha": "bc2a5aa5b6690f5d5dc9c0776fa19a584228e7cd", "filename": "gcc/config/tilepro/t-tilepro", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ft-tilepro", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ft-tilepro", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ft-tilepro?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,15 @@\n+tilepro-c.o: $(srcdir)/config/tilepro/tilepro-c.c \\\n+    $(CONFIG_H) $(SYSTEM_H) coretypes.h $(MACHMODE_H) \\\n+    $(TM_H) $(TM_P_H) $(CPPLIB_H) $(TREE_H) $(C_COMMON_H)\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n+\n+$(srcdir)/config/tilepro/mul-tables.c: \\\n+    $(srcdir)/config/tilepro/gen-mul-tables.cc\n+\t$(CC_FOR_BUILD) $(BUILD_CPPFLAGS) -O2 -DTILEPRO \\\n+\t  -o gen-mul-tables -lstdc++ $<;\n+\t./gen-mul-tables > $@\n+\n+mul-tables.o: $(srcdir)/config/tilepro/mul-tables.c \\\n+    $(CONFIG_H) $(SYSTEM_H) coretypes.h $(EXPR_H) $(OPTABS_H) \\\n+    $(srcdir)/config/tilepro/tilepro-multiply.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<"}, {"sha": "807401fcdb190b9a90df9fd427a10273b3d678d2", "filename": "gcc/config/tilepro/tilepro-builtins.h", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ftilepro-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ftilepro-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro-builtins.h?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,217 @@\n+/* Enum for builtin intrinsics for TILEPro.\n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TILEPRO_BUILTINS_H\n+#define GCC_TILEPRO_BUILTINS_H\n+\n+enum tilepro_builtin\n+{\n+  TILEPRO_INSN_ADD,\n+  TILEPRO_INSN_ADDB,\n+  TILEPRO_INSN_ADDBS_U,\n+  TILEPRO_INSN_ADDH,\n+  TILEPRO_INSN_ADDHS,\n+  TILEPRO_INSN_ADDIB,\n+  TILEPRO_INSN_ADDIH,\n+  TILEPRO_INSN_ADDLIS,\n+  TILEPRO_INSN_ADDS,\n+  TILEPRO_INSN_ADIFFB_U,\n+  TILEPRO_INSN_ADIFFH,\n+  TILEPRO_INSN_AND,\n+  TILEPRO_INSN_AULI,\n+  TILEPRO_INSN_AVGB_U,\n+  TILEPRO_INSN_AVGH,\n+  TILEPRO_INSN_BITX,\n+  TILEPRO_INSN_BYTEX,\n+  TILEPRO_INSN_CLZ,\n+  TILEPRO_INSN_CRC32_32,\n+  TILEPRO_INSN_CRC32_8,\n+  TILEPRO_INSN_CTZ,\n+  TILEPRO_INSN_DRAIN,\n+  TILEPRO_INSN_DTLBPR,\n+  TILEPRO_INSN_DWORD_ALIGN,\n+  TILEPRO_INSN_FINV,\n+  TILEPRO_INSN_FLUSH,\n+  TILEPRO_INSN_FNOP,\n+  TILEPRO_INSN_ICOH,\n+  TILEPRO_INSN_ILL,\n+  TILEPRO_INSN_INFO,\n+  TILEPRO_INSN_INFOL,\n+  TILEPRO_INSN_INTHB,\n+  TILEPRO_INSN_INTHH,\n+  TILEPRO_INSN_INTLB,\n+  TILEPRO_INSN_INTLH,\n+  TILEPRO_INSN_INV,\n+  TILEPRO_INSN_LB,\n+  TILEPRO_INSN_LB_U,\n+  TILEPRO_INSN_LH,\n+  TILEPRO_INSN_LH_U,\n+  TILEPRO_INSN_LNK,\n+  TILEPRO_INSN_LW,\n+  TILEPRO_INSN_LW_NA,\n+  TILEPRO_INSN_LB_L2,\n+  TILEPRO_INSN_LB_U_L2,\n+  TILEPRO_INSN_LH_L2,\n+  TILEPRO_INSN_LH_U_L2,\n+  TILEPRO_INSN_LW_L2,\n+  TILEPRO_INSN_LW_NA_L2,\n+  TILEPRO_INSN_LB_MISS,\n+  TILEPRO_INSN_LB_U_MISS,\n+  TILEPRO_INSN_LH_MISS,\n+  TILEPRO_INSN_LH_U_MISS,\n+  TILEPRO_INSN_LW_MISS,\n+  TILEPRO_INSN_LW_NA_MISS,\n+  TILEPRO_INSN_MAXB_U,\n+  TILEPRO_INSN_MAXH,\n+  TILEPRO_INSN_MAXIB_U,\n+  TILEPRO_INSN_MAXIH,\n+  TILEPRO_INSN_MF,\n+  TILEPRO_INSN_MFSPR,\n+  TILEPRO_INSN_MINB_U,\n+  TILEPRO_INSN_MINH,\n+  TILEPRO_INSN_MINIB_U,\n+  TILEPRO_INSN_MINIH,\n+  TILEPRO_INSN_MM,\n+  TILEPRO_INSN_MNZ,\n+  TILEPRO_INSN_MNZB,\n+  TILEPRO_INSN_MNZH,\n+  TILEPRO_INSN_MOVE,\n+  TILEPRO_INSN_MOVELIS,\n+  TILEPRO_INSN_MTSPR,\n+  TILEPRO_INSN_MULHH_SS,\n+  TILEPRO_INSN_MULHH_SU,\n+  TILEPRO_INSN_MULHH_UU,\n+  TILEPRO_INSN_MULHHA_SS,\n+  TILEPRO_INSN_MULHHA_SU,\n+  TILEPRO_INSN_MULHHA_UU,\n+  TILEPRO_INSN_MULHHSA_UU,\n+  TILEPRO_INSN_MULHL_SS,\n+  TILEPRO_INSN_MULHL_SU,\n+  TILEPRO_INSN_MULHL_US,\n+  TILEPRO_INSN_MULHL_UU,\n+  TILEPRO_INSN_MULHLA_SS,\n+  TILEPRO_INSN_MULHLA_SU,\n+  TILEPRO_INSN_MULHLA_US,\n+  TILEPRO_INSN_MULHLA_UU,\n+  TILEPRO_INSN_MULHLSA_UU,\n+  TILEPRO_INSN_MULLL_SS,\n+  TILEPRO_INSN_MULLL_SU,\n+  TILEPRO_INSN_MULLL_UU,\n+  TILEPRO_INSN_MULLLA_SS,\n+  TILEPRO_INSN_MULLLA_SU,\n+  TILEPRO_INSN_MULLLA_UU,\n+  TILEPRO_INSN_MULLLSA_UU,\n+  TILEPRO_INSN_MVNZ,\n+  TILEPRO_INSN_MVZ,\n+  TILEPRO_INSN_MZ,\n+  TILEPRO_INSN_MZB,\n+  TILEPRO_INSN_MZH,\n+  TILEPRO_INSN_NAP,\n+  TILEPRO_INSN_NOP,\n+  TILEPRO_INSN_NOR,\n+  TILEPRO_INSN_OR,\n+  TILEPRO_INSN_PACKBS_U,\n+  TILEPRO_INSN_PACKHB,\n+  TILEPRO_INSN_PACKHS,\n+  TILEPRO_INSN_PACKLB,\n+  TILEPRO_INSN_PCNT,\n+  TILEPRO_INSN_PREFETCH,\n+  TILEPRO_INSN_PREFETCH_L1,\n+  TILEPRO_INSN_RL,\n+  TILEPRO_INSN_S1A,\n+  TILEPRO_INSN_S2A,\n+  TILEPRO_INSN_S3A,\n+  TILEPRO_INSN_SADAB_U,\n+  TILEPRO_INSN_SADAH,\n+  TILEPRO_INSN_SADAH_U,\n+  TILEPRO_INSN_SADB_U,\n+  TILEPRO_INSN_SADH,\n+  TILEPRO_INSN_SADH_U,\n+  TILEPRO_INSN_SB,\n+  TILEPRO_INSN_SEQ,\n+  TILEPRO_INSN_SEQB,\n+  TILEPRO_INSN_SEQH,\n+  TILEPRO_INSN_SEQIB,\n+  TILEPRO_INSN_SEQIH,\n+  TILEPRO_INSN_SH,\n+  TILEPRO_INSN_SHL,\n+  TILEPRO_INSN_SHLB,\n+  TILEPRO_INSN_SHLH,\n+  TILEPRO_INSN_SHLIB,\n+  TILEPRO_INSN_SHLIH,\n+  TILEPRO_INSN_SHR,\n+  TILEPRO_INSN_SHRB,\n+  TILEPRO_INSN_SHRH,\n+  TILEPRO_INSN_SHRIB,\n+  TILEPRO_INSN_SHRIH,\n+  TILEPRO_INSN_SLT,\n+  TILEPRO_INSN_SLT_U,\n+  TILEPRO_INSN_SLTB,\n+  TILEPRO_INSN_SLTB_U,\n+  TILEPRO_INSN_SLTE,\n+  TILEPRO_INSN_SLTE_U,\n+  TILEPRO_INSN_SLTEB,\n+  TILEPRO_INSN_SLTEB_U,\n+  TILEPRO_INSN_SLTEH,\n+  TILEPRO_INSN_SLTEH_U,\n+  TILEPRO_INSN_SLTH,\n+  TILEPRO_INSN_SLTH_U,\n+  TILEPRO_INSN_SLTIB,\n+  TILEPRO_INSN_SLTIB_U,\n+  TILEPRO_INSN_SLTIH,\n+  TILEPRO_INSN_SLTIH_U,\n+  TILEPRO_INSN_SNE,\n+  TILEPRO_INSN_SNEB,\n+  TILEPRO_INSN_SNEH,\n+  TILEPRO_INSN_SRA,\n+  TILEPRO_INSN_SRAB,\n+  TILEPRO_INSN_SRAH,\n+  TILEPRO_INSN_SRAIB,\n+  TILEPRO_INSN_SRAIH,\n+  TILEPRO_INSN_SUB,\n+  TILEPRO_INSN_SUBB,\n+  TILEPRO_INSN_SUBBS_U,\n+  TILEPRO_INSN_SUBH,\n+  TILEPRO_INSN_SUBHS,\n+  TILEPRO_INSN_SUBS,\n+  TILEPRO_INSN_SW,\n+  TILEPRO_INSN_TBLIDXB0,\n+  TILEPRO_INSN_TBLIDXB1,\n+  TILEPRO_INSN_TBLIDXB2,\n+  TILEPRO_INSN_TBLIDXB3,\n+  TILEPRO_INSN_TNS,\n+  TILEPRO_INSN_WH64,\n+  TILEPRO_INSN_XOR,\n+  TILEPRO_NETWORK_BARRIER,\n+  TILEPRO_IDN0_RECEIVE,\n+  TILEPRO_IDN1_RECEIVE,\n+  TILEPRO_IDN_SEND,\n+  TILEPRO_SN_RECEIVE,\n+  TILEPRO_SN_SEND,\n+  TILEPRO_UDN0_RECEIVE,\n+  TILEPRO_UDN1_RECEIVE,\n+  TILEPRO_UDN2_RECEIVE,\n+  TILEPRO_UDN3_RECEIVE,\n+  TILEPRO_UDN_SEND,\n+  TILEPRO_BUILTIN_max\n+};\n+\n+#endif /* !GCC_TILEPRO_BUILTINS_H */"}, {"sha": "7eb95f1332d44b98805fcf14253f50e8aa846b3f", "filename": "gcc/config/tilepro/tilepro-c.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ftilepro-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ftilepro-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro-c.c?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,52 @@\n+/* Definitions of C specific functions for TILEPro.\n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"machmode.h\"\n+#include \"tm.h\"\n+#include \"tm_p.h\"\n+#include \"cpplib.h\"\n+#include \"tree.h\"\n+#include \"c-family/c-common.h\"\n+\n+/* copy defines in c-cppbuiltin.c */\n+# define builtin_define(TXT) cpp_define (pfile, TXT)\n+# define builtin_assert(TXT) cpp_assert (pfile, TXT)\n+\n+\n+/* Implement TARGET_CPU_CPP_BUILTINS.  */\n+void\n+tilepro_cpu_cpp_builtins (struct cpp_reader *pfile)\n+{\n+  builtin_define (\"__tile__\");\n+  builtin_define (\"__tilepro__\");\n+  builtin_assert (\"cpu=tile\");\n+  builtin_assert (\"machine=tile\");\n+  builtin_define (\"__tile_chip__=1\");\n+  builtin_define (\"__tile_chip_rev__=0\");\n+\n+  TILEPRO_CPU_CPP_ENDIAN_BUILTINS ();\n+  GNU_USER_TARGET_OS_CPP_BUILTINS ();\n+}\n+\n+"}, {"sha": "fcbb1d43ad2fb9a16d59e129d2704060a4b59ee1", "filename": "gcc/config/tilepro/tilepro-generic.md", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ftilepro-generic.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ftilepro-generic.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro-generic.md?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,108 @@\n+;; Scheduling description for Tilera TILEPro chip.\n+;; Copyright (C) 2011, 2012\n+;; Free Software Foundation, Inc.\n+;; Contributed by Walter Lee (walt@tilera.com)\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_automaton \"tile\")\n+\n+; Make the scheduling automaton an ndfa.\n+(automata_option \"ndfa\")\n+\n+; Name the three pipes.\n+(define_cpu_unit \"X0\" \"tile\")\n+(define_cpu_unit \"X1\" \"tile\")\n+(define_cpu_unit \"Y0\" \"tile\")\n+(define_cpu_unit \"Y1\" \"tile\")\n+(define_cpu_unit \"Y2\" \"tile\")\n+\n+(define_insn_reservation \"X0\" 1\n+  (eq_attr \"type\" \"X0\")\n+  \"X0\")\n+\n+(define_insn_reservation \"X0_2cycle\" 2\n+  (eq_attr \"type\" \"X0_2cycle\")\n+  \"X0,nothing\")\n+\n+(define_insn_reservation \"X1\" 1\n+  (eq_attr \"type\" \"X1,X1_branch\")\n+  \"X1\")\n+\n+(define_insn_reservation \"X1_2cycle\" 2\n+  (eq_attr \"type\" \"X1_2cycle\")\n+  \"X1,nothing\")\n+\n+(define_insn_reservation \"X1_L2\" 8\n+  (eq_attr \"type\" \"X1_L2\")\n+  \"X1\")\n+\n+(define_insn_reservation \"X1_miss\" 80\n+  (eq_attr \"type\" \"X1_miss\")\n+  \"X1\")\n+\n+(define_insn_reservation \"X01\" 1\n+  (eq_attr \"type\" \"X01\")\n+  \"X0|X1\")\n+\n+(define_insn_reservation \"Y0\" 1\n+  (eq_attr \"type\" \"Y0\")\n+  \"Y0|X0\")\n+\n+(define_insn_reservation \"Y0_2cycle\" 2\n+  (eq_attr \"type\" \"Y0_2cycle\")\n+  \"Y0|X0,nothing\")\n+\n+(define_insn_reservation \"Y2\" 1\n+  (eq_attr \"type\" \"Y2\")\n+  \"Y2|X1\")\n+\n+(define_insn_reservation \"Y2_2cycle\" 2\n+  (eq_attr \"type\" \"Y2_2cycle\")\n+  \"Y2|X1,nothing\")\n+\n+(define_insn_reservation \"Y2_L2\" 8\n+  (eq_attr \"type\" \"Y2_L2\")\n+  \"Y2|X1\")\n+\n+(define_insn_reservation \"Y2_miss\" 80\n+  (eq_attr \"type\" \"Y2_miss\")\n+  \"Y2|X1\")\n+\n+(define_insn_reservation \"Y01\" 1\n+  (eq_attr \"type\" \"Y01\")\n+  \"Y0|Y1|X0|X1\")\n+\n+(define_insn_reservation \"nothing\" 0\n+  (eq_attr \"type\" \"nothing\")\n+  \"nothing\")\n+\n+(define_insn_reservation \"cannot_bundle\" 1\n+  (eq_attr \"type\" \"cannot_bundle\")\n+  \"X0+X1\")\n+\n+(define_insn_reservation \"cannot_bundle_3cycle\" 3\n+  (eq_attr \"type\" \"cannot_bundle_3cycle\")\n+  \"X0+X1\")\n+\n+(define_insn_reservation \"cannot_bundle_4cycle\" 4\n+  (eq_attr \"type\" \"cannot_bundle_4cycle\")\n+  \"X0+X1\")\n+\n+\n+; A bundle must be in either X format or Y format.\n+(exclusion_set \"X0,X1\" \"Y0,Y1,Y2\")"}, {"sha": "0031f4948da4fbe2637262f5bf167240d5965257", "filename": "gcc/config/tilepro/tilepro-modes.def", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ftilepro-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ftilepro-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro-modes.def?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,35 @@\n+/* TILEPro extra machine modes.\n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Extra modes for handling struct returns in up to 10 registers. */\n+INT_MODE (R3I, 12);\n+INT_MODE (R5I, 20);\n+INT_MODE (R6I, 24);\n+INT_MODE (R7I, 28);\n+INT_MODE (R8I, 32);\n+INT_MODE (R9I, 36);\n+INT_MODE (R10I, 40);\n+\n+/* Vector modes.  */\n+VECTOR_MODES (INT, 4);    /* V4QI V2HI */\n+VECTOR_MODE (INT, QI, 8); /* V8QI */\n+VECTOR_MODE (INT, HI, 4); /* V4HI */\n+VECTOR_MODE (INT, QI, 2); /* V2QI */"}, {"sha": "e3f88587e6aa51c7d8e737a19b64ef9339835f16", "filename": "gcc/config/tilepro/tilepro-multiply.h", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ftilepro-multiply.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ftilepro-multiply.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro-multiply.h?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,83 @@\n+/* Header for constant multiple table for TILEPro.\n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TILEPRO_MULTIPLY_H\n+#define GCC_TILEPRO_MULTIPLY_H\n+\n+/* A node of a tilepro_multiply_insn_seq, corresponding to a single\n+   machine instruction such as 'add', 's1a', or an shl by a\n+   constant.  */\n+struct tilepro_multiply_insn_seq_entry\n+{\n+  /* Which operation this node performs (e.g. an add or sub).  Don't\n+     use this directly, call get_opcode() table to get a\n+     insn_code.  */\n+  unsigned char compressed_opcode;\n+\n+  /* The left-hand side of this expression tree.\n+     If equal to 0, it refers to 'zero'.\n+     If equal to 1, it refers to the original input to the multiply\n+     operation.\n+     Otherwise, subtract two and it is an index into the containing\n+     tilepro_multiply_insn_seq's 'op' array. Since it can only point\n+     to some value that has already been computed it will always point\n+     to an earlier entry in the array.  */\n+  unsigned char lhs;\n+\n+  /* This is like lhs, but for the right-hand side. However, for shift\n+     opcodes this is a shift count rather than an operand index.  */\n+  unsigned char rhs;\n+};\n+\n+/* Maximum size of op array.  */\n+#define tilepro_multiply_insn_seq_MAX_OPERATIONS 4\n+\n+/* This defines a DAG describing how to multiply by a constant in\n+   terms of one or more machine instructions.  */\n+struct tilepro_multiply_insn_seq\n+{\n+  /* The constant factor by which this expression tree multiplies its\n+     input.  */\n+  int multiplier;\n+\n+  /* The nodes of the parse tree. These are ordered so that\n+     instructions can be emitted in the same order that they appear in\n+     this array.  Entry entry in this array can only refer to earlier\n+     entries in the array.  */\n+  struct tilepro_multiply_insn_seq_entry\n+    op[tilepro_multiply_insn_seq_MAX_OPERATIONS];\n+\n+};\n+\n+/* A mapping from the compressed opcode to the corresponding enum\n+   insn_code.  */\n+extern const enum insn_code tilepro_multiply_insn_seq_decode_opcode[];\n+\n+/* Table mapping constant int multipliers to an expression tree that\n+   efficiently performs that multiplication.  This is sorted by its\n+   'multiplier' field so a binary search can look for matches.  */\n+extern const struct tilepro_multiply_insn_seq\n+  tilepro_multiply_insn_seq_table[];\n+\n+/* The number of elements in multiply_insn_seq_table.  */\n+extern const int tilepro_multiply_insn_seq_table_size;\n+\n+#endif /* !GCC_TILEPRO_MULTIPLY_H */"}, {"sha": "9325bb976b0020fae6a311c6ddba9f93ccdef116", "filename": "gcc/config/tilepro/tilepro-protos.h", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ftilepro-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ftilepro-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro-protos.h?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,77 @@\n+/* Prototypes of target machine for TILEPro.\n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC__TILEPRO_PROTOS_H\n+#define GCC__TILEPRO_PROTOS_H\n+\n+\n+extern void tilepro_init_expanders (void);\n+extern bool tilepro_legitimate_pic_operand_p (rtx);\n+extern rtx tilepro_simd_int (rtx, enum machine_mode);\n+\n+#ifdef RTX_CODE\n+extern void split_di (rtx[], int, rtx[], rtx[]);\n+extern bool tilepro_bitfield_operand_p (HOST_WIDE_INT, int *, int *);\n+extern void tilepro_expand_set_const32 (rtx, rtx);\n+extern bool tilepro_expand_mov (enum machine_mode, rtx *);\n+extern void tilepro_expand_insv (rtx operands[4]);\n+extern void tilepro_expand_unaligned_load (rtx, rtx, HOST_WIDE_INT,\n+\t\t\t\t\t   HOST_WIDE_INT, bool);\n+extern void tilepro_expand_movmisalign (enum machine_mode, rtx *);\n+extern bool tilepro_expand_addsi (rtx, rtx, rtx);\n+extern void tilepro_allocate_stack (rtx, rtx);\n+extern bool tilepro_expand_mulsi (rtx, rtx, rtx);\n+extern void tilepro_expand_smulsi3_highpart (rtx, rtx, rtx);\n+extern void tilepro_expand_umulsi3_highpart (rtx, rtx, rtx);\n+\n+extern bool tilepro_emit_setcc (rtx[], enum machine_mode);\n+extern void tilepro_emit_conditional_branch (rtx[], enum machine_mode);\n+extern rtx tilepro_emit_conditional_move (rtx);\n+extern const char *tilepro_output_cbranch_with_opcode (rtx, rtx *,\n+\t\t\t\t\t\t       const char *,\n+\t\t\t\t\t\t       const char *, int,\n+\t\t\t\t\t\t       bool);\n+extern const char *tilepro_output_cbranch (rtx, rtx *, bool);\n+extern void tilepro_expand_tablejump (rtx, rtx);\n+extern void tilepro_expand_builtin_vector_binop (rtx (*)(rtx, rtx, rtx),\n+\t\t\t\t\t\t enum machine_mode, rtx,\n+\t\t\t\t\t\t enum machine_mode, rtx, rtx,\n+\t\t\t\t\t\t bool);\n+#endif /* RTX_CODE */\n+\n+extern bool tilepro_can_use_return_insn_p (void);\n+extern void tilepro_expand_prologue (void);\n+extern void tilepro_expand_epilogue (bool);\n+extern int tilepro_initial_elimination_offset (int, int);\n+extern rtx tilepro_return_addr (int, rtx);\n+extern rtx tilepro_eh_return_handler_rtx (void);\n+extern int tilepro_adjust_insn_length (rtx, int);\n+\n+extern int tilepro_asm_preferred_eh_data_format (int, int);\n+extern void tilepro_final_prescan_insn (rtx);\n+extern const char *tilepro_asm_output_opcode (FILE *, const char *);\n+extern void tilepro_function_profiler (FILE *, int);\n+\n+/* Declare functions in tile-c.c */\n+\n+extern void tilepro_cpu_cpp_builtins (struct cpp_reader *);\n+\n+#endif /* GCC_TILEPRO_PROTOS_H */"}, {"sha": "71b5807c5de7e0c290c7058d9f13e55c5314a396", "filename": "gcc/config/tilepro/tilepro.c", "status": "added", "additions": 5084, "deletions": 0, "changes": 5084, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.c?ref=dd552284fd817c9d946598a7b647f9e67753bed6"}, {"sha": "930612d1fb4a5b9faf951e3e70bac20ad18e6129", "filename": "gcc/config/tilepro/tilepro.h", "status": "added", "additions": 479, "deletions": 0, "changes": 479, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ftilepro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ftilepro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.h?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,479 @@\n+/* Definitions of target machine for GNU compiler for TILEPro.\n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is used by tilepro_cpu_cpp_builtins to indicate the byte order\n+   we're compiling for.  */\n+#define TILEPRO_CPU_CPP_ENDIAN_BUILTINS()\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (BYTES_BIG_ENDIAN)\t\t\t\\\n+\tbuiltin_define (\"__BIG_ENDIAN__\");\t\\\n+      else\t\t\t\t\t\\\n+\tbuiltin_define (\"__LITTLE_ENDIAN__\");\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* Target CPU builtins.  */\n+#define TARGET_CPU_CPP_BUILTINS() \\\n+  tilepro_cpu_cpp_builtins (pfile)\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"int\"\n+\n+#undef SIZE_TYPE\n+#define SIZE_TYPE \"unsigned int\"\n+\f\n+\n+/* Target machine storage layout */\n+\n+#define BITS_BIG_ENDIAN 0\n+#define BYTES_BIG_ENDIAN 0\n+#define WORDS_BIG_ENDIAN 0\n+\n+#define UNITS_PER_WORD 4\n+#define PARM_BOUNDARY 32\n+#define STACK_BOUNDARY 64\n+#define FUNCTION_BOUNDARY 64\n+#define BIGGEST_ALIGNMENT 64\n+#define STRICT_ALIGNMENT 1\n+\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+#define FASTEST_ALIGNMENT 32\n+#define BIGGEST_FIELD_ALIGNMENT 64\n+\n+/* Unaligned moves trap and are very slow.  */\n+#define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) 1\n+\n+/* Make strings word-aligned so strcpy from constants will be\n+   faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  ((TREE_CODE (EXP) == STRING_CST\t\\\n+    && (ALIGN) < FASTEST_ALIGNMENT)\t\\\n+   ? FASTEST_ALIGNMENT : (ALIGN))\n+\n+/* Make arrays of chars word-aligned for the same reasons.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+   && (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))\n+\n+/* Make local arrays of chars word-aligned for the same reasons.  */\n+#define LOCAL_ALIGNMENT(TYPE, ALIGN) DATA_ALIGNMENT (TYPE, ALIGN)\n+\f\n+\n+/* Standard register usage.  */\n+\n+#define FIRST_PSEUDO_REGISTER (64 + 3)\n+\n+#define FIXED_REGISTERS \\\n+ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1}\n+\n+#define CALL_USED_REGISTERS \\\n+ {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1}\n+\n+#define CALL_REALLY_USED_REGISTERS \\\n+ CALL_USED_REGISTERS\n+\n+#define REG_ALLOC_ORDER {\t\t\t\t\\\n+      10, 11, 12, 13, 14, /* call used */\t\t\\\n+      15, 16, 17, 18, 19,\t\t\t\t\\\n+      20, 21, 22, 23, 24,\t\t\t\t\\\n+      25, 26, 27, 28, 29,\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+      9, 8, 7, 6, 5,      /* argument */\t\t\\\n+      4, 3, 2, 1, 0,\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+      55,\t          /* return address */\t\t\\\n+\t\t\t\t\t\t\t\\\n+      30, 31, 32, 33, 34, /* call saved registers */\t\\\n+      35, 36, 37, 38, 39,\t\t\t\t\\\n+      40, 41, 42, 43, 44,\t\t\t\t\\\n+      45, 46, 47, 48, 49,\t\t\t\t\\\n+      50, 51,\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+      52, \t\t  /* hard frame pointer */\t\\\n+      53, 54, \t\t  /* tp, sp */\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+      56, 57, 58, 59, 60, /* special purpose */\t\t\\\n+      61, 62, 63, 64, 65, /* or fake registers */\t\\\n+      66\t\t\t\t\t\t\\\n+}\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)\t\\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* All registers can hold all modes.  */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n+\n+#define MODES_TIEABLE_P(MODE1, MODE2)  1\n+\n+/* Register that holds an address into the text segment that can be\n+   used by pic code.  */\n+#define TILEPRO_PIC_TEXT_LABEL_REGNUM (flag_pic ? 50 : INVALID_REGNUM)\n+#define PIC_OFFSET_TABLE_REGNUM (flag_pic ? 51 : INVALID_REGNUM)\n+#define HARD_FRAME_POINTER_REGNUM 52\n+#define THREAD_POINTER_REGNUM 53\n+#define STACK_POINTER_REGNUM 54\n+#define TILEPRO_LINK_REGNUM 55\n+#define FRAME_POINTER_REGNUM 64\n+#define ARG_POINTER_REGNUM 65\n+/* Pseudo register used to enforce order between instructions that\n+   touch the networks.  */\n+#define TILEPRO_NETORDER_REGNUM 66\n+#define STATIC_CHAIN_REGNUM 10\n+\f\n+\n+enum reg_class\n+{\n+  NO_REGS,\n+  R0_REGS,\n+  R1_REGS,\n+  R2_REGS,\n+  R3_REGS,\n+  R4_REGS,\n+  R5_REGS,\n+  R6_REGS,\n+  R7_REGS,\n+  R8_REGS,\n+  R9_REGS,\n+  R10_REGS,\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Since GENERAL_REGS is the same class as ALL_REGS, don't give it a\n+   different class number; just make it an alias.  */\n+#define GENERAL_REGS ALL_REGS\n+\n+#define REG_CLASS_NAMES\t\\\n+  { \\\n+    \"NO_REGS\", \\\n+    \"R0_REGS\", \\\n+    \"R1_REGS\", \\\n+    \"R2_REGS\", \\\n+    \"R3_REGS\", \\\n+    \"R4_REGS\", \\\n+    \"R5_REGS\", \\\n+    \"R6_REGS\", \\\n+    \"R7_REGS\", \\\n+    \"R8_REGS\", \\\n+    \"R9_REGS\", \\\n+    \"R10_REGS\", \\\n+    \"ALL_REGS\" \\\n+  }\n+\n+#define REG_CLASS_CONTENTS \\\n+  { \\\n+    { 0 }, \\\n+    { 1 << 0 }, \\\n+    { 1 << 1 }, \\\n+    { 1 << 2 }, \\\n+    { 1 << 3 }, \\\n+    { 1 << 4 }, \\\n+    { 1 << 5 }, \\\n+    { 1 << 6 }, \\\n+    { 1 << 7 }, \\\n+    { 1 << 8 }, \\\n+    { 1 << 9 }, \\\n+    { 1 << 10 }, \\\n+    { 0xffffffff, 0xffffffff } \\\n+  }\n+\n+#define REGNO_REG_CLASS(REGNO) \\\n+  ((unsigned)(REGNO) <= 10 ? \\\n+   (enum reg_class)(R0_REGS + (REGNO)) : ALL_REGS)\n+\n+#define INDEX_REG_CLASS NO_REGS\n+#define BASE_REG_CLASS ALL_REGS\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)  (CLASS)\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+ ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\f\n+\n+/* Stack layout; function entry, exit and calling.  */\n+\n+#define STACK_GROWS_DOWNWARD\n+#define FRAME_GROWS_DOWNWARD 1\n+#define STARTING_FRAME_OFFSET 0\n+\n+#define DYNAMIC_CHAIN_ADDRESS(FRAME) plus_constant ((FRAME), UNITS_PER_WORD)\n+\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+#define ACCUMULATE_OUTGOING_ARGS 1\n+\n+#define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 1\n+\n+#define INCOMING_FRAME_SP_OFFSET 0\n+\n+#define STACK_POINTER_OFFSET (2 * UNITS_PER_WORD)\n+\n+#define ARG_POINTER_CFA_OFFSET(FNDECL) (-STACK_POINTER_OFFSET)\n+\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\n+/* The first 10 registers may hold return value.  */\n+#define TILEPRO_NUM_RETURN_REGS 10\n+\n+/* The first 10 registers hold function arguments.  */\n+#define TILEPRO_NUM_ARG_REGS 10\n+\n+#define FUNCTION_ARG_REGNO_P(N) ((N) < TILEPRO_NUM_ARG_REGS)\n+\n+/* The type used to store the number of words of arguments scanned so\n+   far during argument scanning.  This includes any space that is\n+   skipped.  */\n+#define CUMULATIVE_ARGS int\n+\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n+ ((CUM) = 0)\n+\f\n+\n+#define ELIMINABLE_REGS\t\t\t\t\t\\\n+  {{ARG_POINTER_REGNUM,\t STACK_POINTER_REGNUM},\t\t\\\n+  {ARG_POINTER_REGNUM,\t HARD_FRAME_POINTER_REGNUM},\t\\\n+  {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n+  {FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+  ((OFFSET) = tilepro_initial_elimination_offset((FROM),(TO)))\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO) \\\n+  tilepro_function_profiler (FILE, LABELNO)\n+\n+#define TRAMPOLINE_SIZE 48\n+#define TRAMPOLINE_ALIGNMENT 64\n+#define TRAMPOLINE_SECTION text_section\n+\f\n+\n+/* Call frame debugging information.  */\n+\n+#define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (Pmode, TILEPRO_LINK_REGNUM)\n+\n+#define RETURN_ADDR_RTX tilepro_return_addr\n+\n+#define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (TILEPRO_LINK_REGNUM)\n+\n+#define DWARF_ZERO_REG 63\n+\n+#define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (N + 12) : INVALID_REGNUM)\n+#define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, 11)\n+#define EH_RETURN_HANDLER_RTX tilepro_eh_return_handler_rtx ()\n+\n+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL) \\\n+  tilepro_asm_preferred_eh_data_format ((CODE), (GLOBAL))\n+\f\n+\n+/* Addressing modes, and classification of registers for them.  */\n+\n+#define HAVE_POST_INCREMENT 1\n+#define HAVE_POST_DECREMENT 1\n+#define HAVE_POST_MODIFY_DISP 1\n+\n+#define REGNO_OK_FOR_INDEX_P(regno) 0\n+#define REGNO_OK_FOR_BASE_P(regno)\t\\\n+  ((regno) < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)\n+\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+#define CONSTANT_ADDRESS_P(X) 0\n+\n+#define LEGITIMATE_PIC_OPERAND_P(X) tilepro_legitimate_pic_operand_p (X)\n+\f\n+\n+#define CASE_VECTOR_MODE SImode\n+#define CASE_VECTOR_PC_RELATIVE 0\n+#define JUMP_TABLES_IN_TEXT_SECTION 0\n+\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+#define MOVE_MAX UNITS_PER_WORD\n+\n+/* Use a value of 11 for MOVE_RATIO and friends, because TILEPro\n+   returns structs as large as 10 words in registers.  Because of some\n+   some code generation inefficiency, we never get smaller code for\n+   turning that into a memcpy, so pick a value that guarantees this\n+   doesn't happen.  */\n+#define TILEPRO_CALL_RATIO 11\n+#define MOVE_RATIO(speed) ((speed) ? 15 : TILEPRO_CALL_RATIO)\n+#define CLEAR_RATIO(speed) ((speed) ? 15 : TILEPRO_CALL_RATIO)\n+#define SET_RATIO(speed) ((speed) ? 15 : TILEPRO_CALL_RATIO)\n+\n+#define WORD_REGISTER_OPERATIONS\n+\n+#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n+\n+#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)\t\\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD) \\\n+    (MODE) = SImode;\n+\n+/* Define SLOW_BYTE_ACCESS to avoid making a QI or HI mode\n+   register.  */\n+#define SLOW_BYTE_ACCESS 1\n+\n+#define SHIFT_COUNT_TRUNCATED 1\n+\n+#define SHORT_IMMEDIATES_SIGN_EXTEND\n+\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+#define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) ((VALUE) = 32, 1)\n+#define CTZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) ((VALUE) = 32, 1)\n+\n+#define Pmode SImode\n+\n+#define STORE_FLAG_VALUE 1\n+\n+#define FUNCTION_MODE SImode\n+\n+#define NO_FUNCTION_CSE 1\n+\n+#define ADJUST_INSN_LENGTH(INSN, LENGTH) \\\n+  ((LENGTH) = tilepro_adjust_insn_length ((INSN), (LENGTH)))\n+\n+#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n+\n+#define BRANCH_COST(speed_p, predictable_p) ((predictable_p) ? 2 : 6)\n+\f\n+\n+/* Control the assembler format that we output.  */\n+\n+#undef NO_DOLLAR_IN_LABEL\n+\n+#define ASM_COMMENT_START \"##\"\n+\n+#define TEXT_SECTION_ASM_OP \"\\t.text\"\n+\n+#define DATA_SECTION_ASM_OP \"\\t.data\"\n+\n+#undef READONLY_DATA_SECTION_ASM_OP\n+#define READONLY_DATA_SECTION_ASM_OP \"\\t.section\\t.rodata, \\\"a\\\"\"\n+\n+#undef BSS_SECTION_ASM_OP\n+#define BSS_SECTION_ASM_OP\t\"\\t.section\\t.bss, \\\"wa\\\"\"\n+\n+#undef INIT_SECTION_ASM_OP\n+#define INIT_SECTION_ASM_OP\t\"\\t.section\\t.init, \\\"ax\\\"\"\n+\n+#undef FINI_SECTION_ASM_OP\n+#define FINI_SECTION_ASM_OP\t\"\\t.section\\t.fini, \\\"ax\\\"\"\n+\n+#define GLOBAL_ASM_OP \".global \"\n+\n+#define SUPPORTS_WEAK 1\n+\n+#define USER_LABEL_PREFIX \"\"\n+\n+#define REGISTER_PREFIX \"\"\n+#define REGISTER_NAMES                                                  \\\n+  { \"r0\",   \"r1\",   \"r2\",   \"r3\",   \"r4\",   \"r5\",   \"r6\",   \"r7\",       \\\n+    \"r8\",   \"r9\",   \"r10\",  \"r11\",  \"r12\",  \"r13\",  \"r14\",  \"r15\",      \\\n+    \"r16\",  \"r17\",  \"r18\",  \"r19\",  \"r20\",  \"r21\",  \"r22\",  \"r23\",      \\\n+    \"r24\",  \"r25\",  \"r26\",  \"r27\",  \"r28\",  \"r29\",  \"r30\",  \"r31\",      \\\n+    \"r32\",  \"r33\",  \"r34\",  \"r35\",  \"r36\",  \"r37\",  \"r38\",  \"r39\",      \\\n+    \"r40\",  \"r41\",  \"r42\",  \"r43\",  \"r44\",  \"r45\",  \"r46\",  \"r47\",      \\\n+    \"r48\",  \"r49\",  \"r50\",  \"r51\",  \"r52\",  \"tp\",   \"sp\",   \"lr\",       \\\n+    \"sn\",   \"idn0\", \"idn1\", \"udn0\", \"udn1\", \"udn2\", \"udn3\", \"zero\",     \\\n+    \"?FRAME?\", \"?ARG?\", \"?NET?\" }\n+\n+/* This is used to help emit bundles.  */\n+#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS) \\\n+  tilepro_final_prescan_insn (insn)\n+\n+/* This is used to help emit bundles.  */\n+#define ASM_OUTPUT_OPCODE(STREAM, PTR)\t\\\n+  (PTR = tilepro_asm_output_opcode (STREAM, PTR))\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      char label[256];\t\t\t\t\t\\\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"L\", (VALUE));\\\n+      fprintf (FILE, \"\\t.word \");\t\t\t\\\n+      assemble_name (FILE, label);\t\t\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      char label[256];\t\t\t\t\t\t\\\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"L\", (VALUE));\t\\\n+      fprintf (FILE, \"\\t.word \");\t\t\t\t\\\n+      assemble_name (FILE, label);\t\t\t\t\\\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"L\", (REL));\t\t\\\n+      fprintf (FILE, \"-\");\t\t\t\t\t\\\n+      assemble_name (FILE, label);\t\t\t\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)  \\\n+  do { if ((LOG) != 0) fprintf (FILE, \"\\t.align %d\\n\", 1 << (LOG)); } while (0)\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\\\n+  ( fputs (\".comm \", (FILE)),\t\t\t\t\\\n+    assemble_name ((FILE), (NAME)),\t\t\t\\\n+    fprintf ((FILE), \",%u\\n\", (unsigned int)(ROUNDED)))\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)\t\\\n+  ( fputs (\".lcomm \", (FILE)),\t\t\t\t\\\n+    assemble_name ((FILE), (NAME)),\t\t\t\\\n+    fprintf ((FILE), \",%u\\n\", (unsigned int)(ROUNDED)))\n+\n+\f\n+\n+#define INIT_EXPANDERS tilepro_init_expanders ()\n+\n+/* A C structure for machine-specific, per-function data.  This is\n+   added to the cfun structure.  */\n+typedef struct GTY(()) machine_function\n+{\n+  /* Symbol for the text label used for pic.  */\n+  rtx text_label_symbol;\n+\n+  /* Register for the text label.  */\n+  rtx text_label_rtx;\n+\n+  /* Register for the pic offset table.  */\n+  rtx got_rtx;\n+\n+  /* The function calls tls_get_addr.  */\n+  int calls_tls_get_addr;\n+} machine_function;\n+\n+#ifndef HAVE_AS_TLS\n+#define HAVE_AS_TLS 0\n+#endif"}, {"sha": "9d5d44e85ed392292aa6bf81bd3b227a07b60904", "filename": "gcc/config/tilepro/tilepro.md", "status": "added", "additions": 3817, "deletions": 0, "changes": 3817, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ftilepro.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ftilepro.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.md?ref=dd552284fd817c9d946598a7b647f9e67753bed6"}, {"sha": "2ab54e0c52014fd8e8dbdad6913d47eae3b14dbc", "filename": "gcc/config/tilepro/tilepro.opt", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ftilepro.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfig%2Ftilepro%2Ftilepro.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.opt?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,37 @@\n+; Options for the TILEPro port of the compiler.\n+; Copyright (C) 2011, 2012\n+; Free Software Foundation, Inc.\n+; Contributed by Walter Lee (walt@tilera.com)\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.\n+\n+m32\n+Target Report RejectNegative\n+Compile with 32 bit longs and pointers, which is the only supported\n+behavior and thus the flag is ignored.\n+\n+mcpu=\n+Target RejectNegative Joined Enum(tilepro_cpu) Var(tilepro_cpu) Init(0)\n+-mcpu=CPU\tUse features of and schedule code for given CPU\n+\n+Enum\n+Name(tilepro_cpu) Type(int)\n+Known TILEPro CPUs (for use with the -mcpu= option):\n+\n+EnumValue\n+Enum(tilepro_cpu) String(tilepro) Value(0)\n+"}, {"sha": "15a9ece5e6fd6e2b246bd65414029854b4a199c9", "filename": "gcc/configure", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -23491,6 +23491,37 @@ foo:\t.long\t25\n \txor\t%l1, %tle_lox10(foo), %o5\n \tld\t[%g7 + %o5], %o1\"\n \t;;\n+  tilepro*-*-*)\n+      conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\t.long\t25\n+\t.text\n+\taddli\tr0, zero, tls_gd(foo)\n+\tauli\tr0, zero, tls_gd_ha16(foo)\n+\taddli\tr0, r0, tls_gd_lo16(foo)\n+\tjal\t__tls_get_addr\n+\taddli\tr0, zero, tls_ie(foo)\n+\tauli\tr0, r0, tls_ie_ha16(foo)\n+\taddli\tr0, r0, tls_ie_lo16(foo)'\n+\ttls_first_major=2\n+\ttls_first_minor=22\n+\ttls_as_opt=\"--fatal-warnings\"\n+\t;;\n+  tilegx*-*-*)\n+      conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\t.long\t25\n+\t.text\n+\tshl16insli r0, zero, hw0_last_tls_gd(foo)\n+\tshl16insli r0, zero, hw1_last_tls_gd(foo)\n+\tshl16insli r0, r0,   hw0_tls_gd(foo)\n+\tjal\t   __tls_get_addr\n+\tshl16insli r0, zero, hw1_last_tls_ie(foo)\n+\tshl16insli r0, r0,   hw0_tls_ie(foo)'\n+\ttls_first_major=2\n+\ttls_first_minor=22\n+\ttls_as_opt=\"--fatal-warnings\"\n+\t;;\n   xtensa*-*-*)\n     conftest_s='\n \t.section \".tdata\",\"awT\",@progbits\n@@ -25835,7 +25866,7 @@ esac\n # version to the per-target configury.\n case \"$cpu_type\" in\n   alpha | arm | avr | bfin | cris | i386 | m32c | m68k | microblaze | mips \\\n-  | pa | rs6000 | score | sparc | spu | xstormy16 | xtensa)\n+  | pa | rs6000 | score | sparc | spu | tilegx | tilepro | xstormy16 | xtensa)\n     insn=\"nop\"\n     ;;\n   ia64 | s390)"}, {"sha": "5d6aa5d3c280ed05dd95a9253de80ea3ac675925", "filename": "gcc/configure.ac", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -3125,6 +3125,37 @@ foo:\t.long\t25\n \txor\t%l1, %tle_lox10(foo), %o5\n \tld\t[%g7 + %o5], %o1\"\n \t;;\n+  tilepro*-*-*)\n+      conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\t.long\t25\n+\t.text\n+\taddli\tr0, zero, tls_gd(foo)\n+\tauli\tr0, zero, tls_gd_ha16(foo)\n+\taddli\tr0, r0, tls_gd_lo16(foo)\n+\tjal\t__tls_get_addr\n+\taddli\tr0, zero, tls_ie(foo)\n+\tauli\tr0, r0, tls_ie_ha16(foo)\n+\taddli\tr0, r0, tls_ie_lo16(foo)'\n+\ttls_first_major=2\n+\ttls_first_minor=22\n+\ttls_as_opt=\"--fatal-warnings\"\n+\t;;\n+  tilegx*-*-*)\n+      conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\t.long\t25\n+\t.text\n+\tshl16insli r0, zero, hw0_last_tls_gd(foo)\n+\tshl16insli r0, zero, hw1_last_tls_gd(foo)\n+\tshl16insli r0, r0,   hw0_tls_gd(foo)\n+\tjal\t   __tls_get_addr\n+\tshl16insli r0, zero, hw1_last_tls_ie(foo)\n+\tshl16insli r0, r0,   hw0_tls_ie(foo)'\n+\ttls_first_major=2\n+\ttls_first_minor=22\n+\ttls_as_opt=\"--fatal-warnings\"\n+\t;;\n   xtensa*-*-*)\n     conftest_s='\n \t.section \".tdata\",\"awT\",@progbits\n@@ -4071,7 +4102,7 @@ esac\n # version to the per-target configury.\n case \"$cpu_type\" in\n   alpha | arm | avr | bfin | cris | i386 | m32c | m68k | microblaze | mips \\\n-  | pa | rs6000 | score | sparc | spu | xstormy16 | xtensa)\n+  | pa | rs6000 | score | sparc | spu | tilegx | tilepro | xstormy16 | xtensa)\n     insn=\"nop\"\n     ;;\n   ia64 | s390)"}, {"sha": "face894ff484176e004c29cab7fe3f3701dcaa69", "filename": "gcc/doc/contrib.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fdoc%2Fcontrib.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fdoc%2Fcontrib.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcontrib.texi?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -394,6 +394,9 @@ of testing and bug fixing, particularly of GCC configury code.\n @item\n Steve Holmgren for MachTen patches.\n \n+@item\n+Mat Hostetter for work on the TILE-Gx and TILEPro ports.\n+\n @item\n Jan Hubicka for his x86 port improvements.\n \n@@ -505,6 +508,9 @@ entire egcs project and GCC 2.95, rolling out snapshots and releases,\n handling merges from GCC2, reviewing tons of patches that might have\n fallen through the cracks else, and random but extensive hacking.\n \n+@item\n+Walter Lee for work on the TILE-Gx and TILEPro ports.\n+\n @item\n Marc Lehmann for his direction via the steering committee and helping\n with analysis and improvements of x86 performance."}, {"sha": "4c7196080a193207738eb259c1bb757e94ea3a43", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -8531,6 +8531,8 @@ instructions, but allow the compiler to schedule those calls.\n * SPARC VIS Built-in Functions::\n * SPU Built-in Functions::\n * TI C6X Built-in Functions::\n+* TILE-Gx Built-in Functions::\n+* TILEPro Built-in Functions::\n @end menu\n \n @node Alpha Built-in Functions\n@@ -13718,6 +13720,78 @@ int _abs2 (int)\n \n @end smallexample\n \n+@node TILE-Gx Built-in Functions\n+@subsection TILE-Gx Built-in Functions\n+\n+GCC provides intrinsics to access every instruction of the TILE-Gx\n+processor.  The intrinsics are of the form:\n+\n+@smallexample\n+\n+unsigned long long __insn_@var{op} (...)\n+\n+@end smallexample\n+\n+Where @var{op} is the name of the instruction.  Refer to the ISA manual\n+for the complete list of instructions.\n+\n+GCC also provides intrinsics to directly access the network registers.\n+The intrinsics are:\n+\n+@smallexample\n+\n+unsigned long long __tile_idn0_receive (void)\n+unsigned long long __tile_idn1_receive (void)\n+unsigned long long __tile_udn0_receive (void)\n+unsigned long long __tile_udn1_receive (void)\n+unsigned long long __tile_udn2_receive (void)\n+unsigned long long __tile_udn3_receive (void)\n+void __tile_idn_send (unsigned long long)\n+void __tile_udn_send (unsigned long long)\n+\n+@end smallexample\n+\n+The intrinsic @code{void __tile_network_barrier (void)} is used to\n+guarantee that no network operatons before it will be reordered with\n+those after it.\n+\n+@node TILEPro Built-in Functions\n+@subsection TILEPro Built-in Functions\n+\n+GCC provides intrinsics to access every instruction of the TILEPro\n+processor.  The intrinsics are of the form:\n+\n+@smallexample\n+\n+unsigned __insn_@var{op} (...)\n+\n+@end smallexample\n+\n+Where @var{op} is the name of the instruction.  Refer to the ISA manual\n+for the complete list of instructions.\n+\n+GCC also provides intrinsics to directly access the network registers.\n+The intrinsics are:\n+\n+@smallexample\n+\n+unsigned __tile_idn0_receive (void)\n+unsigned __tile_idn1_receive (void)\n+unsigned __tile_sn_receive (void)\n+unsigned __tile_udn0_receive (void)\n+unsigned __tile_udn1_receive (void)\n+unsigned __tile_udn2_receive (void)\n+unsigned __tile_udn3_receive (void)\n+void __tile_idn_send (unsigned)\n+void __tile_sn_send (unsigned)\n+void __tile_udn_send (unsigned)\n+\n+@end smallexample\n+\n+The intrinsic @code{void __tile_network_barrier (void)} is used to\n+guarantee that no network operatons before it will be reordered with\n+those after it.\n+\n @node Target Format Checks\n @section Format Checks Specific to Particular Target Machines\n "}, {"sha": "f1f2a6ca87772ba7617aaa2bdcadb6fbf487d95d", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -3096,6 +3096,10 @@ information are.\n @item\n @uref{#c6x-x-x,,c6x-*-*}\n @item\n+@uref{#tilegx-x-linux,,tilegx-*-linux*}\n+@item\n+@uref{#tilepro-x-linux,,tilepro-*-linux*}\n+@item\n @uref{#x-x-vxworks,,*-*-vxworks*}\n @item\n @uref{#x86-64-x-x,,x86_64-*-*, amd64-*-*}\n@@ -4457,6 +4461,22 @@ This is a synonym for @samp{sparc64-*-solaris2*}.\n \n The C6X family of processors. This port requires binutils-2.22 or newer.\n \n+@html\n+<hr />\n+@end html\n+@heading @anchor{tilegx-*-linux}tilegx-*-linux*\n+\n+The TILE-Gx processor running GNU/Linux.  This port requires\n+binutils-2.22 or newer.\n+\n+@html\n+<hr />\n+@end html\n+@heading @anchor{tilepro-*-linux}tilepro-*-linux*\n+\n+The TILEPro processor running GNU/Linux.  This port requires\n+binutils-2.22 or newer.\n+\n @html\n <hr />\n @end html"}, {"sha": "9f3af4cff30229cb09880de8d920f5b85c75fa30", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -923,6 +923,12 @@ See RS/6000 and PowerPC Options.\n @emph{System V Options}\n @gccoptlist{-Qy  -Qn  -YP,@var{paths}  -Ym,@var{dir}}\n \n+@emph{TILE-Gx Options}\n+@gccoptlist{-mcpu=CPU -m32 -m64}\n+\n+@emph{TILEPro Options}\n+@gccoptlist{-mcpu=CPU -m32}\n+\n @emph{V850 Options}\n @gccoptlist{-mlong-calls  -mno-long-calls  -mep  -mno-ep @gol\n -mprolog-function  -mno-prolog-function  -mspace @gol\n@@ -10349,6 +10355,8 @@ platform.\n * SPARC Options::\n * SPU Options::\n * System V Options::\n+* TILE-Gx Options::\n+* TILEPro Options::\n * V850 Options::\n * VAX Options::\n * VxWorks Options::\n@@ -18479,6 +18487,46 @@ The assembler uses this option.\n @c the generic assembler that comes with Solaris takes just -Ym.\n @end table\n \n+@node TILE-Gx Options\n+@subsection TILE-Gx Options\n+@cindex TILE-Gx options\n+\n+These @samp{-m} options are supported on the TILE-Gx:\n+\n+@table @gcctabopt\n+@item -mcpu=@var{name}\n+@opindex mcpu\n+Selects the type of CPU to be targeted.  Currently the only supported\n+type is @samp{tilegx}.\n+\n+@item -m32\n+@itemx -m64\n+@opindex m32\n+@opindex m64\n+Generate code for a 32-bit or 64-bit environment.  The 32-bit\n+environment sets int, long, and pointer to 32 bits.  The 64-bit\n+environment sets int to 32 bits and long and pointer to 64 bits.\n+@end table\n+\n+@node TILEPro Options\n+@subsection TILEPro Options\n+@cindex TILEPro options\n+\n+These @samp{-m} options are supported on the TILEPro:\n+\n+@table @gcctabopt\n+@item -mcpu=@var{name}\n+@opindex mcpu\n+Selects the type of CPU to be targeted.  Currently the only supported\n+type is @samp{tilepro}.\n+\n+@item -m32\n+@opindex m32\n+Generate code for a 32-bit environment, which sets int, long, and\n+pointer to 32 bits.  This is the only supported behavior so the flag\n+is essentially ignored.\n+@end table\n+\n @node V850 Options\n @subsection V850 Options\n @cindex V850 Options"}, {"sha": "c4eb355e253719551b394c03acac35645a773fcb", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -3576,6 +3576,154 @@ Register B14 (aka DP).\n \n @end table\n \n+@item TILE-Gx---@file{config/tilegx/constraints.md}\n+@table @code\n+@item R00\n+@itemx R01\n+@itemx R02\n+@itemx R03\n+@itemx R04\n+@itemx R05\n+@itemx R06\n+@itemx R07\n+@itemx R08\n+@itemx R09\n+@itemx R010\n+Each of these represents a register constraint for an individual\n+register, from r0 to r10.\n+\n+@item I\n+Signed 8-bit integer constant.\n+\n+@item J\n+Signed 16-bit integer constant.\n+\n+@item K\n+Unsigned 16-bit integer constant.\n+\n+@item L\n+Integer constant that fits in one signed byte when incremented by one\n+(@minus{}129 @dots{} 126).\n+\n+@item m\n+Memory operand.  If used together with @samp{<} or @samp{>}, the\n+operand can have postincrement which requires printing with @samp{%In}\n+and @samp{%in} on TILE-Gx.  For example:\n+\n+@smallexample\n+asm (\"st_add %I0,%1,%i0\" : \"=m<>\" (*mem) : \"r\" (val));\n+@end smallexample\n+\n+@item M\n+A bit mask suitable for the BFINS instruction.\n+\n+@item N\n+Integer constant that is a byte tiled out eight times.\n+\n+@item O\n+The integer zero constant.\n+\n+@item P\n+Integer constant that is a sign-extended byte tiled out as four shorts.\n+\n+@item Q\n+Integer constant that fits in one signed byte when incremented\n+(@minus{}129 @dots{} 126), but excluding -1.\n+\n+@item S\n+Integer constant that has all 1 bits consecutive and starting at bit 0.\n+\n+@item T\n+A 16-bit fragment of a got, tls, or pc-relative reference.\n+\n+@item U\n+Memory operand except postincrement.  This is roughly the same as\n+@samp{m} when not used together with @samp{<} or @samp{>}.\n+\n+@item W\n+An 8-element vector constant with identical elements.\n+\n+@item Y\n+A 4-element vector constant with identical elements.\n+\n+@item Z0\n+The integer constant 0xffffffff.\n+\n+@item Z1\n+The integer constant 0xffffffff00000000.\n+\n+@end table\n+\n+@item TILEPro---@file{config/tilepro/constraints.md}\n+@table @code\n+@item R00\n+@itemx R01\n+@itemx R02\n+@itemx R03\n+@itemx R04\n+@itemx R05\n+@itemx R06\n+@itemx R07\n+@itemx R08\n+@itemx R09\n+@itemx R010\n+Each of these represents a register constraint for an individual\n+register, from r0 to r10.\n+\n+@item I\n+Signed 8-bit integer constant.\n+\n+@item J\n+Signed 16-bit integer constant.\n+\n+@item K\n+Nonzero integer constant with low 16 bits zero.\n+\n+@item L\n+Integer constant that fits in one signed byte when incremented by one\n+(@minus{}129 @dots{} 126).\n+\n+@item m\n+Memory operand.  If used together with @samp{<} or @samp{>}, the\n+operand can have postincrement which requires printing with @samp{%In}\n+and @samp{%in} on TILEPro.  For example:\n+\n+@smallexample\n+asm (\"swadd %I0,%1,%i0\" : \"=m<>\" (mem) : \"r\" (val));\n+@end smallexample\n+\n+@item M\n+A bit mask suitable for the MM instruction.\n+\n+@item N\n+Integer constant that is a byte tiled out four times.\n+\n+@item O\n+The integer zero constant.\n+\n+@item P\n+Integer constant that is a sign-extended byte tiled out as two shorts.\n+\n+@item Q\n+Integer constant that fits in one signed byte when incremented\n+(@minus{}129 @dots{} 126), but excluding -1.\n+\n+@item T\n+A symbolic operand, or a 16-bit fragment of a got, tls, or pc-relative\n+reference.\n+\n+@item U\n+Memory operand except postincrement.  This is roughly the same as\n+@samp{m} when not used together with @samp{<} or @samp{>}.\n+\n+@item W\n+A 4-element vector constant with identical elements.\n+\n+@item Y\n+A 2-element vector constant with identical elements.\n+\n+@end table\n+\n @item Xtensa---@file{config/xtensa/constraints.md}\n @table @code\n @item a"}, {"sha": "05a6af0e1bc0e4ca9d95ee5a86ed0232df5991a9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -1,3 +1,12 @@\n+2012-02-14  Walter Lee  <walt@tilera.com>\n+\n+\t* g++.dg/other/PR23205.C: Disable test on tile.\n+\t* g++.dg/other/pr23205-2.C: Disable test on tile.\n+\t* gcc.dg/20020312-2.c: Add a condition for __tile__.\n+\t* gcc.dg/20040813-1.c: Disable test on tile.\n+\t* gcc.dg/lower-subreg-1.c: Disable test on tilegx.\n+\t* gcc.misc-tests/linkage.exp: Handle tilegx.\n+\n 2012-02-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/52210"}, {"sha": "a31fc1d773ddf0b21bdb219be2646c574923d7a5", "filename": "gcc/testsuite/g++.dg/other/PR23205.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2FPR23205.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2FPR23205.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2FPR23205.C?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-skip-if \"No stabs\" { mmix-*-* *-*-aix* alpha*-*-* hppa*64*-*-* ia64-*-* *-*-vxworks } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"No stabs\" { mmix-*-* *-*-aix* alpha*-*-* hppa*64*-*-* ia64-*-* tile*-*-* *-*-vxworks } { \"*\" } { \"\" } } */\n /* { dg-options \"-gstabs+ -fno-eliminate-unused-debug-types\" } */\n \n const int foobar = 4;"}, {"sha": "fbd16dfab5836e4f0ceb987cbf42271d3728c63f", "filename": "gcc/testsuite/g++.dg/other/pr23205-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr23205-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr23205-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr23205-2.C?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-skip-if \"No stabs\" { mmix-*-* *-*-aix* alpha*-*-* hppa*64*-*-* ia64-*-* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"No stabs\" { mmix-*-* *-*-aix* alpha*-*-* hppa*64*-*-* ia64-*-* tile*-*-* } { \"*\" } { \"\" } } */\n /* { dg-options \"-gstabs+ -fno-eliminate-unused-debug-types -ftoplevel-reorder\" } */\n \n const int foobar = 4;"}, {"sha": "768e17e64cda63d12b75f3f40bbddffe4b1b1266", "filename": "gcc/testsuite/gcc.dg/20020312-2.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -66,6 +66,8 @@ extern void abort (void);\n # define PIC_REG  \"12\"\n #elif defined(__sparc__)\n # define PIC_REG  \"l7\"\n+#elif defined(__tile__)\n+# define PIC_REG \"r51\"\n #elif defined(__TMS320C6X__)\n # define PIC_REG \"B14\"\n #elif defined(__v850)"}, {"sha": "e16344164d59f5a09a7e083669132eaac4c54d7e", "filename": "gcc/testsuite/gcc.dg/20040813-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Ftestsuite%2Fgcc.dg%2F20040813-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Ftestsuite%2Fgcc.dg%2F20040813-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20040813-1.c?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -2,7 +2,7 @@\n /* Contributed by Devang Patel  <dpatel@apple.com>  */\n \n /* { dg-do compile } */\n-/* { dg-skip-if \"No stabs\" { mmix-*-* *-*-aix* alpha*-*-* hppa*64*-*-* ia64-*-* *-*-vxworks* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"No stabs\" { mmix-*-* *-*-aix* alpha*-*-* hppa*64*-*-* ia64-*-* tile*-*-* *-*-vxworks* } { \"*\" } { \"\" } } */\n /* { dg-options \"-gstabs\" } */\n \n int"}, {"sha": "12a20adfc3807ff2b01bbf265b7570ba39809fd7", "filename": "gcc/testsuite/gcc.dg/lower-subreg-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Ftestsuite%2Fgcc.dg%2Flower-subreg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Ftestsuite%2Fgcc.dg%2Flower-subreg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flower-subreg-1.c?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-do compile { target { { { ! mips64 } && { ! ia64-*-* } } && { ! spu-*-* } } } } */\n+/* { dg-do compile { target { { { ! mips64 } && { ! ia64-*-* } } && { ! spu-*-* } && { ! tilegx-*-* } } } } */\n /* { dg-options \"-O -fdump-rtl-subreg1\" } */\n /* { dg-skip-if \"\" { { i?86-*-* x86_64-*-* } && x32 } { \"*\" } { \"\" } } */\n /* { dg-require-effective-target ilp32 } */"}, {"sha": "887f31b21ac9722a96c16bc5be40bae87c1fa46c", "filename": "gcc/testsuite/gcc.misc-tests/linkage.exp", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Ftestsuite%2Fgcc.misc-tests%2Flinkage.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/gcc%2Ftestsuite%2Fgcc.misc-tests%2Flinkage.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.misc-tests%2Flinkage.exp?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -88,6 +88,13 @@ if { [isnative] && ![is_remote host] } then {\n             } elseif [ string match \"*ppc\" $file_string ] {\n                 set native_cflags \"-m32\"\n             }\n+        } elseif [istarget \"tilegx-*-linux*\"] {\n+\t    set file_string [exec file \"linkage-x.o\"]\n+\t    if [ string match \"*64-bit*\" $file_string ] {\n+\t\tset native_cflags \"-m64\"\n+\t    } elseif [ string match \"*32-bit*\" $file_string ] {\n+\t\tset native_cflags \"-m32\"\n+\t    }\n         } elseif [istarget \"*86*-*-darwin*\"] {\n \t   set file_string [exec file \"linkage-x.o\"]\n \t   if [ string match \"*64*\" $file_string ] {"}, {"sha": "a8a949c7d91ad0b8c220ed6f84a26efe678c0fe5", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -1,3 +1,8 @@\n+2012-02-14  Walter Lee  <walt@tilera.com>\n+\n+\t* configure.ac: Require 64-bit hwint for tilegx and tilepro.\n+\t* configure: Regenerate.\n+\n 2012-01-09  Richard Guenther  <rguenther@suse.de>\n \n \t* macro.c (_cpp_builtin_macro_text): Remove unused variable map."}, {"sha": "fb5654de54d8ca398aebfa9f0750d35612d13cbc", "filename": "libcpp/configure", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libcpp%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libcpp%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fconfigure?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -7382,7 +7382,8 @@ case $target in\n \ts390*-*-* | \\\n \tsparc*-*-* | \\\n \tspu-*-* | \\\n-\tsh[123456789lbe]*-*-* | sh-*-*)\n+\tsh[123456789lbe]*-*-* | sh-*-* | \\\n+\ttilegx-*-* | tilepro-*-* )\n \t\tneed_64bit_hwint=yes ;;\n \t*)\n \t\tneed_64bit_hwint=no ;;"}, {"sha": "070ab633d801043c1436673443828bbf2bf0aa6b", "filename": "libcpp/configure.ac", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libcpp%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libcpp%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fconfigure.ac?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -162,7 +162,8 @@ case $target in\n \ts390*-*-* | \\\n \tsparc*-*-* | \\\n \tspu-*-* | \\\n-\tsh[123456789lbe]*-*-* | sh-*-*)\n+\tsh[123456789lbe]*-*-* | sh-*-* | \\\n+\ttilegx-*-* | tilepro-*-* )\n \t\tneed_64bit_hwint=yes ;;\n \t*)\n \t\tneed_64bit_hwint=no ;;"}, {"sha": "85b39cf7dfa80371c3ea6bb0206a36f8180da960", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -1,3 +1,21 @@\n+2012-02-14  Walter Lee  <walt@tilera.com>\n+\n+\t* config.host: Handle tilegx and tilepro.\n+\t* config/tilegx/sfp-machine.h: New file.\n+\t* config/tilegx/sfp-machine32.h: New file.\n+\t* config/tilegx/sfp-machine64.h: New file.\n+\t* config/tilegx/t-crtstuff: New file.\n+\t* config/tilegx/t-softfp: New file.\n+\t* config/tilegx/t-tilegx: New file.\n+\t* config/tilepro/atomic.c: New file.\n+\t* config/tilepro/atomic.h: New file.\n+\t* config/tilepro/linux-unwind.h: New file.\n+\t* config/tilepro/sfp-machine.h: New file.\n+\t* config/tilepro/softdivide.c: New file.\n+\t* config/tilepro/softmpy.S: New file.\n+\t* config/tilepro/t-crtstuff: New file.\n+\t* config/tilepro/t-tilepro: New file.\n+\n 2012-02-07  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \tPR libstdc++/51296"}, {"sha": "5ad27caa17236940dec8cac6f6b6ac93d52a4107", "filename": "libgcc/config.host", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -1090,6 +1090,14 @@ tic6x-*-elf)\n \textra_parts=\"$extra_parts crtbeginS.o crtendS.o crti.o crtn.o\"\n \tunwind_header=config/c6x/unwind-c6x.h\n \t;;\n+tilegx-*-linux*)\n+\ttmake_file=\"${tmake_file} tilegx/t-crtstuff t-softfp-sfdf tilegx/t-softfp t-softfp tilegx/t-tilegx\"\n+\tmd_unwind_header=tilepro/linux-unwind.h\n+        ;;\n+tilepro-*-linux*)\n+\ttmake_file=\"${tmake_file} tilepro/t-crtstuff t-softfp-sfdf t-softfp tilepro/t-tilepro\"\n+\tmd_unwind_header=tilepro/linux-unwind.h\n+        ;;\n v850*-*-*)\n \ttmake_file=\"v850/t-v850 t-fdpbit\"\n \t;;"}, {"sha": "1ce84e10943e35fdf0cab82751e1cf57674403ed", "filename": "libgcc/config/tilegx/sfp-machine.h", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine.h?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,5 @@\n+#ifdef __tilegx32__\n+#include \"config/tilegx/sfp-machine32.h\"\n+#else\n+#include \"config/tilegx/sfp-machine64.h\"\n+#endif"}, {"sha": "378410001677abba09037475b97091efbce7133a", "filename": "libgcc/config/tilegx/sfp-machine32.h", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine32.h?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,61 @@\n+#define _FP_W_TYPE_SIZE\t\t32\n+#define _FP_W_TYPE\t\tunsigned long\n+#define _FP_WS_TYPE\t\tsigned long\n+#define _FP_I_TYPE\t\tlong\n+\n+typedef int TItype __attribute__ ((mode (TI)));\n+typedef unsigned int UTItype __attribute__ ((mode (TI)));\n+\n+#define TI_BITS (__CHAR_BIT__ * (int)sizeof(TItype))\n+\n+/* The type of the result of a floating point comparison.  This must\n+   match `__libgcc_cmp_return__' in GCC for the target.  */\n+typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n+#define CMPtype __gcc_CMPtype\n+\n+#define _FP_MUL_MEAT_S(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)\n+#define _FP_MUL_MEAT_D(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)\n+#define _FP_MUL_MEAT_Q(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)\n+\n+#define _FP_DIV_MEAT_S(R,X,Y)\t_FP_DIV_MEAT_1_loop(S,R,X,Y)\n+#define _FP_DIV_MEAT_D(R,X,Y)\t_FP_DIV_MEAT_2_udiv(D,R,X,Y)\n+#define _FP_DIV_MEAT_Q(R,X,Y)\t_FP_DIV_MEAT_4_udiv(Q,R,X,Y)\n+\n+#define _FP_NANFRAC_S\t\t_FP_QNANBIT_S\n+#define _FP_NANFRAC_D\t\t_FP_QNANBIT_D, 0\n+#define _FP_NANFRAC_Q\t\t_FP_QNANBIT_Q, 0, 0, 0\n+#define _FP_NANSIGN_S\t\t1\n+#define _FP_NANSIGN_D\t\t1\n+#define _FP_NANSIGN_Q\t\t1\n+\n+#define _FP_KEEPNANFRACP 1\n+\n+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)\t\t\\\n+\t&& !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = Y##_s;\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R,Y);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = X##_s;\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R,X);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    R##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define\t__LITTLE_ENDIAN\t1234\n+#define\t__BIG_ENDIAN\t4321\n+\n+#define __BYTE_ORDER __LITTLE_ENDIAN\n+\n+/* Define ALIASNAME as a strong alias for NAME.  */\n+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n+# define _strong_alias(name, aliasname) \\\n+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));\n+"}, {"sha": "88bdcf5a3180280e023c4d29c9073a5cddb98e89", "filename": "libgcc/config/tilegx/sfp-machine64.h", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine64.h?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,61 @@\n+#define _FP_W_TYPE_SIZE\t\t64\n+#define _FP_W_TYPE\t\tunsigned long\n+#define _FP_WS_TYPE\t\tsigned long\n+#define _FP_I_TYPE\t\tlong\n+\n+typedef int TItype __attribute__ ((mode (TI)));\n+typedef unsigned int UTItype __attribute__ ((mode (TI)));\n+\n+#define TI_BITS (__CHAR_BIT__ * (int)sizeof(TItype))\n+\n+/* The type of the result of a floating point comparison.  This must\n+   match `__libgcc_cmp_return__' in GCC for the target.  */\n+typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n+#define CMPtype __gcc_CMPtype\n+\n+#define _FP_MUL_MEAT_S(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_1_imm(_FP_WFRACBITS_S,R,X,Y)\n+#define _FP_MUL_MEAT_D(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)\n+#define _FP_MUL_MEAT_Q(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)\n+\n+#define _FP_DIV_MEAT_S(R,X,Y)\t_FP_DIV_MEAT_1_imm(S,R,X,Y,_FP_DIV_HELP_imm)\n+#define _FP_DIV_MEAT_D(R,X,Y)\t_FP_DIV_MEAT_1_udiv_norm(D,R,X,Y)\n+#define _FP_DIV_MEAT_Q(R,X,Y)\t_FP_DIV_MEAT_2_udiv(Q,R,X,Y)\n+\n+#define _FP_NANFRAC_S\t\t_FP_QNANBIT_S\n+#define _FP_NANFRAC_D\t\t_FP_QNANBIT_D\n+#define _FP_NANFRAC_Q\t\t_FP_QNANBIT_Q, 0\n+#define _FP_NANSIGN_S\t\t1\n+#define _FP_NANSIGN_D\t\t1\n+#define _FP_NANSIGN_Q\t\t1\n+\n+#define _FP_KEEPNANFRACP 1\n+\n+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)\t\t\\\n+\t&& !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = Y##_s;\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R,Y);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = X##_s;\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R,X);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    R##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define\t__LITTLE_ENDIAN\t1234\n+#define\t__BIG_ENDIAN\t4321\n+\n+#define __BYTE_ORDER __LITTLE_ENDIAN\n+\n+/* Define ALIASNAME as a strong alias for NAME.  */\n+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n+# define _strong_alias(name, aliasname) \\\n+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));\n+"}, {"sha": "eddc45ce9d8774c36547c0d2db8185b4ea53bcf8", "filename": "libgcc/config/tilegx/t-crtstuff", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilegx%2Ft-crtstuff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilegx%2Ft-crtstuff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilegx%2Ft-crtstuff?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,4 @@\n+# crtend*.o cannot be compiled without -fno-asynchronous-unwind-tables,\n+# because then __FRAME_END__ might not be the last thing in .eh_frame\n+# section.\n+CRTSTUFF_T_CFLAGS += -fno-asynchronous-unwind-tables"}, {"sha": "a1e3513e2884ffa856cc2d41670f150a27e87553", "filename": "libgcc/config/tilegx/t-softfp", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilegx%2Ft-softfp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilegx%2Ft-softfp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilegx%2Ft-softfp?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1 @@\n+softfp_int_modes += ti"}, {"sha": "2fb64454c3686c9322ab7f60f23dd27b95289485", "filename": "libgcc/config/tilegx/t-tilegx", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilegx%2Ft-tilegx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilegx%2Ft-tilegx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilegx%2Ft-tilegx?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,26 @@\n+LIB2ADD += \\\n+  $(srcdir)/config/tilepro/atomic.c\n+\n+SOFTDIVIDE_FUNCS := \\\n+  _tile_udivsi3 \\\n+  _tile_divsi3 \\\n+  _tile_udivdi3 \\\n+  _tile_divdi3 \\\n+  _tile_umodsi3 \\\n+  _tile_modsi3 \\\n+  _tile_umoddi3 \\\n+  _tile_moddi3\n+\n+softdivide-o = $(patsubst %,%$(objext),$(SOFTDIVIDE_FUNCS))\n+$(softdivide-o): %$(objext): $(srcdir)/config/tilepro/softdivide.c\n+\t$(gcc_compile) -ffunction-sections -DMAYBE_STATIC= -DL$* -c $< \\\n+\t  $(vis_hide)\n+libgcc-objects += $(softdivide-o)\n+\n+ifeq ($(enable_shared),yes)\n+softdivide-s-o = $(patsubst %,%_s$(objext),$(SOFTDIVIDE_FUNCS))\n+$(softdivide-s-o): %_s$(objext): $(srcdir)/config/tilepro/softdivide.c\n+\t$(gcc_s_compile) -ffunction-sections -DMAYBE_STATIC= -DL$* -c $<\n+libgcc-s-objects += $(softdivide-s-o)\n+libgcc-eh-objects += _tile_divdi3.o _tile_umoddi3.o\n+endif"}, {"sha": "cafbde8abee7cd71e42639a366e374b0b961f29f", "filename": "libgcc/config/tilepro/atomic.c", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilepro%2Fatomic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilepro%2Fatomic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilepro%2Fatomic.c?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,232 @@\n+/* TILE atomics.\n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"atomic.h\"\n+\n+/* This code should be inlined by the compiler, but for now support\n+   it as out-of-line methods in libgcc.  */\n+\n+static void\n+pre_atomic_barrier (int model)\n+{\n+  switch ((enum memmodel) model)\n+    {\n+    case MEMMODEL_RELEASE:\n+    case MEMMODEL_ACQ_REL:\n+    case MEMMODEL_SEQ_CST:\n+      __atomic_thread_fence (model);\n+      break;\n+    default:\n+      break;\n+    }\n+  return;\n+}\n+\n+static void\n+post_atomic_barrier (int model)\n+{\n+  switch ((enum memmodel) model)\n+    {\n+    case MEMMODEL_ACQUIRE:\n+    case MEMMODEL_ACQ_REL:\n+    case MEMMODEL_SEQ_CST:\n+      __atomic_thread_fence (model);\n+      break;\n+    default:\n+      break;\n+    }\n+  return;\n+}\n+\n+#define __unused __attribute__((unused))\n+\n+/* Provide additional methods not implemented by atomic.h. */\n+#define atomic_xor(mem, mask) \\\n+  __atomic_update_cmpxchg(mem, mask, __old ^ __value)\n+#define atomic_nand(mem, mask) \\\n+  __atomic_update_cmpxchg(mem, mask, ~(__old & __value))\n+\n+#define __atomic_fetch_and_do(type, size, opname)\t\t\\\n+type\t\t\t\t\t\t\t\t\\\n+__atomic_fetch_##opname##_##size(type* p, type i, int model)\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  pre_atomic_barrier(model);\t\t\t\t\t\\\n+  type rv = atomic_##opname(p, i);\t\t\t\t\\\n+  post_atomic_barrier(model);\t\t\t\t\t\\\n+  return rv;\t\t\t\t\t\t\t\\\n+}\n+\n+__atomic_fetch_and_do (int, 4, add)\n+__atomic_fetch_and_do (int, 4, sub)\n+__atomic_fetch_and_do (int, 4, or)\n+__atomic_fetch_and_do (int, 4, and)\n+__atomic_fetch_and_do (int, 4, xor)\n+__atomic_fetch_and_do (int, 4, nand)\n+__atomic_fetch_and_do (long long, 8, add)\n+__atomic_fetch_and_do (long long, 8, sub)\n+__atomic_fetch_and_do (long long, 8, or)\n+__atomic_fetch_and_do (long long, 8, and)\n+__atomic_fetch_and_do (long long, 8, xor)\n+__atomic_fetch_and_do (long long, 8, nand)\n+#define __atomic_do_and_fetch(type, size, opname, op)\t\t\\\n+type\t\t\t\t\t\t\t\t\\\n+__atomic_##opname##_fetch_##size(type* p, type i, int model)\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  pre_atomic_barrier(model);\t\t\t\t\t\\\n+  type rv = atomic_##opname(p, i) op i;\t\t\t\t\\\n+  post_atomic_barrier(model);\t\t\t\t\t\\\n+  return rv;\t\t\t\t\t\t\t\\\n+}\n+__atomic_do_and_fetch (int, 4, add, +)\n+__atomic_do_and_fetch (int, 4, sub, -)\n+__atomic_do_and_fetch (int, 4, or, |)\n+__atomic_do_and_fetch (int, 4, and, &)\n+__atomic_do_and_fetch (int, 4, xor, |)\n+__atomic_do_and_fetch (int, 4, nand, &)\n+__atomic_do_and_fetch (long long, 8, add, +)\n+__atomic_do_and_fetch (long long, 8, sub, -)\n+__atomic_do_and_fetch (long long, 8, or, |)\n+__atomic_do_and_fetch (long long, 8, and, &)\n+__atomic_do_and_fetch (long long, 8, xor, |)\n+__atomic_do_and_fetch (long long, 8, nand, &)\n+#define __atomic_exchange_methods(type, size)\t\t\t\t\\\n+bool\t\t\t\t\t\t\t\t\t\\\n+__atomic_compare_exchange_##size(volatile type* ptr, type* oldvalp,\t\\\n+\t\t\t\t type newval, bool weak __unused,\t\\\n+\t\t\t\t int models, int modelf __unused)\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  type oldval = *oldvalp;\t\t\t\t\t\t\\\n+  pre_atomic_barrier(models);\t\t\t\t\t\t\\\n+  type retval = atomic_val_compare_and_exchange(ptr, oldval, newval);\t\\\n+  post_atomic_barrier(models);\t\t\t\t\t\t\\\n+  bool success = (retval == oldval);\t\t\t\t\t\\\n+  *oldvalp = retval;\t\t\t\t\t\t\t\\\n+  return success;\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+type\t\t\t\t\t\t\t\t\t\\\n+__atomic_exchange_##size(volatile type* ptr, type val, int model)\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  pre_atomic_barrier(model);\t\t\t\t\t\t\\\n+  type retval = atomic_exchange(ptr, val);\t\t\t\t\\\n+  post_atomic_barrier(model);\t\t\t\t\t\t\\\n+  return retval;\t\t\t\t\t\t\t\\\n+}\n+__atomic_exchange_methods (int, 4)\n+__atomic_exchange_methods (long long, 8)\n+\n+/* Subword methods require the same approach for both TILEPro and\n+   TILE-Gx.  We load the background data for the word, insert the\n+   desired subword piece, then compare-and-exchange it into place.  */\n+#define u8 unsigned char\n+#define u16 unsigned short\n+#define __atomic_subword_cmpxchg(type, size)\t\t\t\t\\\n+  \t\t\t\t\t\t\t\t\t\\\n+bool\t\t\t\t\t\t\t\t\t\\\n+__atomic_compare_exchange_##size(volatile type* ptr, type* guess,\t\\\n+\t\t\t\t type val, bool weak __unused, int models, \\\n+\t\t\t\t int modelf __unused)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  pre_atomic_barrier(models);\t\t\t\t\t\t\\\n+  unsigned int *p = (unsigned int *)((unsigned long)ptr & ~3UL);\t\\\n+  const int shift = ((unsigned long)ptr & 3UL) * 8;\t\t\t\\\n+  const unsigned int valmask = (1 << (sizeof(type) * 8)) - 1;\t\t\\\n+  const unsigned int bgmask = ~(valmask << shift);\t\t\t\\\n+  unsigned int oldword = *p;\t\t\t\t\t\t\\\n+  type oldval = (oldword >> shift) & valmask;\t\t\t\t\\\n+  if (__builtin_expect((oldval == *guess), 1)) {\t\t\t\\\n+    unsigned int word = (oldword & bgmask) | ((val & valmask) << shift); \\\n+    oldword = atomic_val_compare_and_exchange(p, oldword, word);\t\\\n+    oldval = (oldword >> shift) & valmask;\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+  post_atomic_barrier(models);\t\t\t\t\t\t\\\n+  bool success = (oldval == *guess);\t\t\t\t\t\\\n+  *guess = oldval;\t\t\t\t\t\t\t\\\n+  return success;\t\t\t\t\t\t\t\\\n+}\n+__atomic_subword_cmpxchg (u8, 1)\n+__atomic_subword_cmpxchg (u16, 2)\n+/* For the atomic-update subword methods, we use the same approach as\n+   above, but we retry until we succeed if the compare-and-exchange\n+   fails.  */\n+#define __atomic_subword(type, proto, top, expr, bottom)\t\t\\\n+proto\t\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  top\t\t\t\t\t\t\t\t\t\\\n+  unsigned int *p = (unsigned int *)((unsigned long)ptr & ~3UL);\t\\\n+  const int shift = ((unsigned long)ptr & 3UL) * 8;\t\t\t\\\n+  const unsigned int valmask = (1 << (sizeof(type) * 8)) - 1;\t\t\\\n+  const unsigned int bgmask = ~(valmask << shift);\t\t\t\\\n+  unsigned int oldword, xword = *p;\t\t\t\t\t\\\n+  type val, oldval;\t\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    oldword = xword;\t\t\t\t\t\t\t\\\n+    oldval = (oldword >> shift) & valmask;\t\t\t\t\\\n+    val = expr;\t\t\t\t\t\t\t\t\\\n+    unsigned int word = (oldword & bgmask) | ((val & valmask) << shift); \\\n+    xword = atomic_val_compare_and_exchange(p, oldword, word);          \\\n+  } while (__builtin_expect(xword != oldword, 0));\t\t\t\\\n+  bottom\t\t\t\t\t\t\t\t\\\n+}\n+#define __atomic_subword_fetch(type, funcname, expr, retval)\t\t\\\n+  __atomic_subword(type,\t\t\t\t\t\t\\\n+\t\t   type __atomic_ ## funcname(volatile type *ptr, type i, int model), \\\n+\t\t   pre_atomic_barrier(model);,\t\t\t\t\\\n+\t\t   expr,\t\t\t\t\t\t\\\n+\t\t   post_atomic_barrier(model); return retval;)\n+__atomic_subword_fetch (u8, fetch_add_1, oldval + i, oldval)\n+__atomic_subword_fetch (u8, fetch_sub_1, oldval - i, oldval)\n+__atomic_subword_fetch (u8, fetch_or_1, oldval | i, oldval)\n+__atomic_subword_fetch (u8, fetch_and_1, oldval & i, oldval)\n+__atomic_subword_fetch (u8, fetch_xor_1, oldval ^ i, oldval)\n+__atomic_subword_fetch (u8, fetch_nand_1, ~(oldval & i), oldval)\n+__atomic_subword_fetch (u16, fetch_add_2, oldval + i, oldval)\n+__atomic_subword_fetch (u16, fetch_sub_2, oldval - i, oldval)\n+__atomic_subword_fetch (u16, fetch_or_2, oldval | i, oldval)\n+__atomic_subword_fetch (u16, fetch_and_2, oldval & i, oldval)\n+__atomic_subword_fetch (u16, fetch_xor_2, oldval ^ i, oldval)\n+__atomic_subword_fetch (u16, fetch_nand_2, ~(oldval & i), oldval)\n+__atomic_subword_fetch (u8, add_fetch_1, oldval + i, val)\n+__atomic_subword_fetch (u8, sub_fetch_1, oldval - i, val)\n+__atomic_subword_fetch (u8, or_fetch_1, oldval | i, val)\n+__atomic_subword_fetch (u8, and_fetch_1, oldval & i, val)\n+__atomic_subword_fetch (u8, xor_fetch_1, oldval ^ i, val)\n+__atomic_subword_fetch (u8, nand_fetch_1, ~(oldval & i), val)\n+__atomic_subword_fetch (u16, add_fetch_2, oldval + i, val)\n+__atomic_subword_fetch (u16, sub_fetch_2, oldval - i, val)\n+__atomic_subword_fetch (u16, or_fetch_2, oldval | i, val)\n+__atomic_subword_fetch (u16, and_fetch_2, oldval & i, val)\n+__atomic_subword_fetch (u16, xor_fetch_2, oldval ^ i, val)\n+__atomic_subword_fetch (u16, nand_fetch_2, ~(oldval & i), val)\n+#define __atomic_subword_lock(type, size)\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+__atomic_subword(type,\t\t\t\t\t\t\t\\\n+\t\t type __atomic_exchange_##size(volatile type* ptr, type nval, int model), \\\n+\t         pre_atomic_barrier(model);,\t\t\t\t\\\n+\t         nval,\t\t\t\t\t\t\t\\\n+\t         post_atomic_barrier(model); return oldval;)\n+__atomic_subword_lock (u8, 1)\n+__atomic_subword_lock (u16, 2)"}, {"sha": "16306fe0e76e54838cbda6fa69146c332c3f99d9", "filename": "libgcc/config/tilepro/atomic.h", "status": "added", "additions": 428, "deletions": 0, "changes": 428, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilepro%2Fatomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilepro%2Fatomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilepro%2Fatomic.h?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,428 @@\n+/* Macros for atomic functionality for tile.\n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+\n+/* Provides macros for common atomic functionality.  */\n+\n+#ifndef _ATOMIC_H_\n+#define _ATOMIC_H_\n+\n+#ifdef __tilegx__\n+/* Atomic instruction macros\n+\n+   The macros provided by atomic.h simplify access to the TILE-Gx\n+   architecture's atomic instructions.  The architecture provides a\n+   variety of atomic instructions, including \"exchange\", \"compare and\n+   exchange\", \"fetch and ADD\", \"fetch and AND\", \"fetch and OR\", and\n+   \"fetch and ADD if greater than or equal to zero\".\n+\n+   No barrier or fence semantics are implied by any of the atomic\n+   instructions for manipulating memory; you must specify the barriers\n+   that you wish explicitly, using the provided macros.\n+\n+   Any integral 32- or 64-bit value can be used as the argument\n+   to these macros, such as \"int\", \"long long\", \"unsigned long\", etc.\n+   The pointers must be aligned to 4 or 8 bytes for 32- or 64-bit data.\n+   The \"exchange\" and \"compare and exchange\" macros may also take\n+   pointer values.  We use the pseudo-type \"VAL\" in the documentation\n+   to indicate the use of an appropriate type.  */\n+#else\n+/* Atomic instruction macros\n+\n+   The macros provided by atomic.h simplify access to the Tile\n+   architecture's atomic instructions.  Since the architecture\n+   supports test-and-set as its only in-silicon atomic operation, many\n+   of the operations provided by this header are implemented as\n+   fast-path calls to Linux emulation routines.\n+\n+   Using the kernel for atomic operations allows userspace to take\n+   advantage of the kernel's existing atomic-integer support (managed\n+   by a distributed array of locks).  The kernel provides proper\n+   ordering among simultaneous atomic operations on different cores,\n+   and guarantees a process can not be context-switched part way\n+   through an atomic operation.  By virtue of sharing the kernel\n+   atomic implementation, the userspace atomic operations\n+   are compatible with the atomic methods provided by the kernel's\n+   futex() syscall API.  Note that these operations never cause Linux\n+   kernel scheduling, and are in fact invisible to the kernel; they\n+   simply act as regular function calls but with an elevated privilege\n+   level.  Note that the kernel's distributed lock array is hashed by\n+   using only VA bits from the atomic value's address (to avoid the\n+   performance hit of page table locking and multiple page-table\n+   lookups to get the PA) and only the VA bits that are below page\n+   granularity (to properly lock simultaneous accesses to the same\n+   page mapped at different VAs).  As a result, simultaneous atomic\n+   operations on values whose addresses are at the same offset on a\n+   page will contend in the kernel for the same lock array element.\n+\n+   No barrier or fence semantics are implied by any of the atomic\n+   instructions for manipulating memory; you must specify the barriers\n+   that you wish explicitly, using the provided macros.\n+\n+   Any integral 32- or 64-bit value can be used as the argument\n+   to these macros, such as \"int\", \"long long\", \"unsigned long\", etc.\n+   The pointers must be aligned to 4 or 8 bytes for 32- or 64-bit data.\n+   The \"exchange\" and \"compare and exchange\" macros may also take\n+   pointer values.  We use the pseudo-type \"VAL\" in the documentation\n+   to indicate the use of an appropriate type.\n+\n+   The 32-bit routines are implemented using a single kernel fast\n+   syscall, as is the 64-bit compare-and-exchange.  The other 64-bit\n+   routines are implemented by looping over the 64-bit\n+   compare-and-exchange routine, so may be potentially less efficient.  */\n+#endif\n+\n+#include <stdint.h>\n+#include <features.h>\n+#ifdef __tilegx__\n+#include <arch/spr_def.h>\n+#else\n+#include <asm/unistd.h>\n+#endif\n+\n+\n+/* 32-bit integer compare-and-exchange.  */\n+static __inline __attribute__ ((always_inline))\n+     int atomic_val_compare_and_exchange_4 (volatile int *mem,\n+\t\t\t\t\t    int oldval, int newval)\n+{\n+#ifdef __tilegx__\n+  __insn_mtspr (SPR_CMPEXCH_VALUE, oldval);\n+  return __insn_cmpexch4 (mem, newval);\n+#else\n+  int result;\n+  __asm__ __volatile__ (\"swint1\":\"=R00\" (result),\n+\t\t\t\"=m\" (*mem):\"R10\" (__NR_FAST_cmpxchg), \"R00\" (mem),\n+\t\t\t\"R01\" (oldval), \"R02\" (newval), \"m\" (*mem):\"r20\",\n+\t\t\t\"r21\", \"r22\", \"r23\", \"r24\", \"r25\", \"r26\", \"r27\",\n+\t\t\t\"r28\", \"r29\", \"memory\");\n+  return result;\n+#endif\n+}\n+\n+/* 64-bit integer compare-and-exchange.  */\n+static __inline __attribute__ ((always_inline))\n+     int64_t atomic_val_compare_and_exchange_8 (volatile int64_t * mem,\n+\t\t\t\t\t\tint64_t oldval,\n+\t\t\t\t\t\tint64_t newval)\n+{\n+#ifdef __tilegx__\n+  __insn_mtspr (SPR_CMPEXCH_VALUE, oldval);\n+  return __insn_cmpexch (mem, newval);\n+#else\n+  unsigned int result_lo, result_hi;\n+  unsigned int oldval_lo = oldval & 0xffffffffu, oldval_hi = oldval >> 32;\n+  unsigned int newval_lo = newval & 0xffffffffu, newval_hi = newval >> 32;\n+  __asm__ __volatile__ (\"swint1\":\"=R00\" (result_lo), \"=R01\" (result_hi),\n+\t\t\t\"=m\" (*mem):\"R10\" (__NR_FAST_cmpxchg64), \"R00\" (mem),\n+\t\t\t\"R02\" (oldval_lo), \"R03\" (oldval_hi),\n+\t\t\t\"R04\" (newval_lo), \"R05\" (newval_hi),\n+\t\t\t\"m\" (*mem):\"r20\", \"r21\", \"r22\", \"r23\", \"r24\", \"r25\",\n+\t\t\t\"r26\", \"r27\", \"r28\", \"r29\", \"memory\");\n+  return ((uint64_t) result_hi) << 32 | result_lo;\n+#endif\n+}\n+\n+/* This non-existent symbol is called for sizes other than \"4\" and \"8\",\n+   indicating a bug in the caller.  */\n+extern int __atomic_error_bad_argument_size (void)\n+  __attribute__ ((warning (\"sizeof atomic argument not 4 or 8\")));\n+\n+\n+#define atomic_val_compare_and_exchange(mem, o, n)                      \\\n+  ({                                                                    \\\n+    (__typeof(*(mem)))(__typeof(*(mem)-*(mem)))                         \\\n+      ((sizeof(*(mem)) == 8) ?                                          \\\n+       atomic_val_compare_and_exchange_8(                               \\\n+         (volatile int64_t*)(mem), (__typeof((o)-(o)))(o),              \\\n+         (__typeof((n)-(n)))(n)) :                                      \\\n+       (sizeof(*(mem)) == 4) ?                                          \\\n+       atomic_val_compare_and_exchange_4(                               \\\n+         (volatile int*)(mem), (__typeof((o)-(o)))(o),                  \\\n+         (__typeof((n)-(n)))(n)) :                                      \\\n+       __atomic_error_bad_argument_size());                             \\\n+  })\n+\n+#define atomic_bool_compare_and_exchange(mem, o, n)                     \\\n+  ({                                                                    \\\n+    __typeof(o) __o = (o);                                              \\\n+    __builtin_expect(                                                   \\\n+      __o == atomic_val_compare_and_exchange((mem), __o, (n)), 1);      \\\n+  })\n+\n+\n+/* Loop with compare_and_exchange until we guess the correct value.\n+   Normally \"expr\" will be an expression using __old and __value.  */\n+#define __atomic_update_cmpxchg(mem, value, expr)                       \\\n+  ({                                                                    \\\n+    __typeof(value) __value = (value);                                  \\\n+    __typeof(*(mem)) *__mem = (mem), __old = *__mem, __guess;           \\\n+    do {                                                                \\\n+      __guess = __old;                                                  \\\n+      __old = atomic_val_compare_and_exchange(__mem, __old, (expr));    \\\n+    } while (__builtin_expect(__old != __guess, 0));                    \\\n+    __old;                                                              \\\n+  })\n+\n+#ifdef __tilegx__\n+\n+/* Generic atomic op with 8- or 4-byte variant.\n+   The _mask, _addend, and _expr arguments are ignored on tilegx.  */\n+#define __atomic_update(mem, value, op, _mask, _addend, _expr)          \\\n+  ({                                                                    \\\n+    ((__typeof(*(mem)))                                                 \\\n+     ((sizeof(*(mem)) == 8) ? (__typeof(*(mem)-*(mem)))__insn_##op(     \\\n+        (void *)(mem), (int64_t)(__typeof((value)-(value)))(value)) :   \\\n+      (sizeof(*(mem)) == 4) ? (int)__insn_##op##4(                      \\\n+        (void *)(mem), (int32_t)(__typeof((value)-(value)))(value)) :   \\\n+      __atomic_error_bad_argument_size()));                             \\\n+  })\n+\n+#else\n+\n+/* This uses TILEPro's fast syscall support to atomically compute:\n+\n+   int old = *ptr;\n+   *ptr = (old & mask) + addend;\n+   return old;\n+\n+   This primitive can be used for atomic exchange, add, or, and.\n+   Only 32-bit support is provided.  */\n+static __inline __attribute__ ((always_inline))\n+     int\n+     __atomic_update_4 (volatile int *mem, int mask, int addend)\n+{\n+  int result;\n+  __asm__ __volatile__ (\"swint1\":\"=R00\" (result),\n+\t\t\t\"=m\" (*mem):\"R10\" (__NR_FAST_atomic_update),\n+\t\t\t\"R00\" (mem), \"R01\" (mask), \"R02\" (addend),\n+\t\t\t\"m\" (*mem):\"r20\", \"r21\", \"r22\", \"r23\", \"r24\", \"r25\",\n+\t\t\t\"r26\", \"r27\", \"r28\", \"r29\", \"memory\");\n+  return result;\n+}\n+\n+/* Generic atomic op with 8- or 4-byte variant.\n+   The _op argument is ignored on tilepro.  */\n+#define __atomic_update(mem, value, _op, mask, addend, expr)            \\\n+  ({                                                                    \\\n+    (__typeof(*(mem)))(__typeof(*(mem)-*(mem)))                         \\\n+      ((sizeof(*(mem)) == 8) ?                                          \\\n+       __atomic_update_cmpxchg((mem), (value), (expr)) :                \\\n+       (sizeof(*(mem)) == 4) ?                                          \\\n+       __atomic_update_4((volatile int*)(mem), (__typeof((mask)-(mask)))(mask), \\\n+                         (__typeof((addend)-(addend)))(addend)) :       \\\n+       __atomic_error_bad_argument_size());                             \\\n+  })\n+\n+#endif /* __tilegx__ */\n+\n+\n+#define atomic_exchange(mem, newvalue) \\\n+  __atomic_update(mem, newvalue, exch, 0, newvalue, __value)\n+\n+#define atomic_add(mem, value) \\\n+  __atomic_update(mem, value, fetchadd, -1, value, __old + __value)\n+\n+#define atomic_sub(mem, value) atomic_add((mem), -(value))\n+\n+#define atomic_increment(mem) atomic_add((mem), 1)\n+\n+#define atomic_decrement(mem) atomic_add((mem), -1)\n+\n+#define atomic_and(mem, mask) \\\n+  __atomic_update(mem, mask, fetchand, mask, 0, __old & __value)\n+\n+#define atomic_or(mem, mask) \\\n+  __atomic_update(mem, mask, fetchor, ~mask, mask, __old | __value)\n+\n+#define atomic_bit_set(mem, bit)                                        \\\n+  ({                                                                    \\\n+    __typeof(*(mem)) __mask = (__typeof(*(mem)))1 << (bit);             \\\n+    __mask & atomic_or((mem), __mask);                                  \\\n+  })\n+\n+#define atomic_bit_clear(mem, bit)                                      \\\n+  ({                                                                    \\\n+    __typeof(*(mem)) __mask = (__typeof(*(mem)))1 << (bit);             \\\n+    __mask & atomic_and((mem), ~__mask);                                \\\n+  })\n+\n+#ifdef __tilegx__\n+/* Atomically store a new value to memory.\n+   Note that you can freely use types of any size here, unlike the\n+   other atomic routines, which require 32- or 64-bit types.\n+   This accessor is provided for compatibility with TILEPro, which\n+   required an explicit atomic operation for stores that needed\n+   to be atomic with respect to other atomic methods in this header.  */\n+#define atomic_write(mem, value) ((void) (*(mem) = (value)))\n+#else\n+#define atomic_write(mem, value)                                        \\\n+  do {                                                                  \\\n+    __typeof(mem) __aw_mem = (mem);                                     \\\n+    __typeof(value) __aw_val = (value);                                 \\\n+    unsigned int *__aw_mem32, __aw_intval, __aw_val32, __aw_off, __aw_mask; \\\n+    __aw_intval = (__typeof((value) - (value)))__aw_val;                \\\n+    switch (sizeof(*__aw_mem)) {                                        \\\n+    case 8:                                                             \\\n+      __atomic_update_cmpxchg(__aw_mem, __aw_val, __value);             \\\n+      break;                                                            \\\n+    case 4:                                                             \\\n+      __atomic_update_4((int *)__aw_mem, 0, __aw_intval);               \\\n+      break;                                                            \\\n+    case 2:                                                             \\\n+      __aw_off = 8 * ((long)__aw_mem & 0x2);                            \\\n+      __aw_mask = 0xffffU << __aw_off;                                  \\\n+      __aw_mem32 = (unsigned int *)((long)__aw_mem & ~0x2);             \\\n+      __aw_val32 = (__aw_intval << __aw_off) & __aw_mask;               \\\n+      __atomic_update_cmpxchg(__aw_mem32, __aw_val32,                   \\\n+                              (__old & ~__aw_mask) | __value);          \\\n+      break;                                                            \\\n+    case 1:                                                             \\\n+      __aw_off = 8 * ((long)__aw_mem & 0x3);                            \\\n+      __aw_mask = 0xffU << __aw_off;                                    \\\n+      __aw_mem32 = (unsigned int *)((long)__aw_mem & ~0x3);             \\\n+      __aw_val32 = (__aw_intval << __aw_off) & __aw_mask;               \\\n+      __atomic_update_cmpxchg(__aw_mem32, __aw_val32,                   \\\n+                              (__old & ~__aw_mask) | __value);          \\\n+      break;                                                            \\\n+    }                                                                   \\\n+  } while (0)\n+#endif\n+\n+/* Compiler barrier.\n+\n+   This macro prevents loads or stores from being moved by the compiler\n+   across the macro.  Any loaded value that was loaded before this\n+   macro must then be reloaded by the compiler.  */\n+#define atomic_compiler_barrier() __asm__ __volatile__(\"\" ::: \"memory\")\n+\n+/* Full memory barrier.\n+\n+   This macro has the semantics of atomic_compiler_barrer(), but also\n+   ensures that previous stores are visible to other cores, and that\n+   all previous loaded values have been placed into their target\n+   register on this core.  */\n+#define atomic_full_barrier() __insn_mf()\n+\n+/* Read memory barrier.\n+\n+   Ensure that all reads by this processor that occurred prior to the\n+   read memory barrier have completed, and that no reads that occur\n+   after the read memory barrier on this processor are initiated\n+   before the barrier.\n+\n+   On current TILE chips a read barrier is implemented as a full barrier,\n+   but this may not be true in later versions of the architecture.\n+\n+   See also atomic_acquire_barrier() for the appropriate idiom to use\n+   to ensure no reads are lifted above an atomic lock instruction.  */\n+#define atomic_read_barrier() atomic_full_barrier()\n+\n+/* Write memory barrier.\n+\n+   Ensure that all writes by this processor that occurred prior to the\n+   write memory barrier have completed, and that no writes that occur\n+   after the write memory barrier on this processor are initiated\n+   before the barrier.\n+\n+   On current TILE chips a write barrier is implemented as a full barrier,\n+   but this may not be true in later versions of the architecture.\n+\n+   See also atomic_release_barrier() for the appropriate idiom to use\n+   to ensure all writes are complete prior to an atomic unlock instruction.  */\n+#define atomic_write_barrier() atomic_full_barrier()\n+\n+/* Lock acquisition barrier.\n+\n+   Ensure that no load operations that follow this macro in the\n+   program can issue prior to the barrier.  Without such a barrier,\n+   the compiler can reorder them to issue earlier, or the hardware can\n+   issue them speculatively.  The latter is not currently done in the\n+   Tile microarchitecture, but using this operation improves\n+   portability to future implementations.\n+\n+   This operation is intended to be used as part of the \"acquire\"\n+   path for locking, that is, when entering a critical section.\n+   This should be done after the atomic operation that actually\n+   acquires the lock, and in conjunction with a \"control dependency\"\n+   that checks the atomic operation result to see if the lock was\n+   in fact acquired.  See the atomic_read_barrier() macro\n+   for a heavier-weight barrier to use in certain unusual constructs,\n+   or atomic_acquire_barrier_value() if no control dependency exists.  */\n+#define atomic_acquire_barrier() atomic_compiler_barrier()\n+\n+/* Lock release barrier.\n+\n+   Ensure that no store operations that precede this macro in the\n+   program complete subsequent to the barrier.  Without such a\n+   barrier, the compiler can reorder stores to issue later, or stores\n+   can be still outstanding in the memory network.\n+\n+   This operation is intended to be used as part of the \"release\" path\n+   for locking, that is, when leaving a critical section.  This should\n+   be done before the operation (such as a store of zero) that\n+   actually releases the lock.  */\n+#define atomic_release_barrier() atomic_write_barrier()\n+\n+/* Barrier until the read of a particular value is complete.\n+\n+   This is occasionally useful when constructing certain locking\n+   scenarios.  For example, you might write a routine that issues an\n+   atomic instruction to enter a critical section, then reads one or\n+   more values within the critical section without checking to see if\n+   the critical section was in fact acquired, and only later checks\n+   the atomic instruction result to see if the lock was acquired.  If\n+   so the routine could properly release the lock and know that the\n+   values that were read were valid.\n+\n+   In this scenario, it is required to wait for the result of the\n+   atomic instruction, even if the value itself is not checked.  This\n+   guarantees that if the atomic instruction succeeded in taking the lock,\n+   the lock was held before any reads in the critical section issued.  */\n+#define atomic_acquire_barrier_value(val) \\\n+  __asm__ __volatile__(\"move %0, %0\" :: \"r\"(val))\n+\n+/* Access the given variable in memory exactly once.\n+\n+   In some contexts, an algorithm may need to force access to memory,\n+   since otherwise the compiler may think it can optimize away a\n+   memory load or store; for example, in a loop when polling memory to\n+   see if another cpu has updated it yet.  Generally this is only\n+   required for certain very carefully hand-tuned algorithms; using it\n+   unnecessarily may result in performance losses.\n+\n+   A related use of this macro is to ensure that the compiler does not\n+   rematerialize the value of \"x\" by reloading it from memory\n+   unexpectedly; the \"volatile\" marking will prevent the compiler from\n+   being able to rematerialize.  This is helpful if an algorithm needs\n+   to read a variable without locking, but needs it to have the same\n+   value if it ends up being used several times within the algorithm.\n+\n+   Note that multiple uses of this macro are guaranteed to be ordered,\n+   i.e. the compiler will not reorder stores or loads that are wrapped\n+   in atomic_access_once().  */\n+#define atomic_access_once(x) (*(volatile __typeof(x) *)&(x))\n+\n+\n+#endif /* !_ATOMIC_H_ */"}, {"sha": "0ed662c659834751da82376699cc2ba255a67a63", "filename": "libgcc/config/tilepro/linux-unwind.h", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilepro%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilepro%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilepro%2Flinux-unwind.h?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,100 @@\n+/* DWARF2 EH unwinding support for TILEPro.\n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef inhibit_libc\n+\n+#include <arch/abi.h>\n+#include <signal.h>\n+#include <sys/ucontext.h>\n+#include <linux/unistd.h>\n+\n+/* Macro to define a copy of the kernel's __rt_sigreturn function\n+   (in arch/tile/kernel/entry.S).  If that function is changed,\n+   this one needs to be changed to match it.  */\n+#define _sigreturn_asm(REG, NR) asm(                    \\\n+    \".pushsection .text.__rt_sigreturn,\\\"a\\\"\\n\"         \\\n+    \".global __rt_sigreturn\\n\"                          \\\n+    \".type __rt_sigreturn,@function\\n\"                  \\\n+    \"__rt_sigreturn:\\n\"                                 \\\n+    \"moveli \" #REG \", \" #NR \"\\n\"                        \\\n+    \"swint1\\n\"                                          \\\n+    \".size __rt_sigreturn, . - __rt_sigreturn\\n\"        \\\n+    \".popsection\")\n+#define sigreturn_asm(REG, NR) _sigreturn_asm(REG, NR)\n+sigreturn_asm (TREG_SYSCALL_NR_NAME, __NR_rt_sigreturn);\n+#define SIGRETURN_LEN 16\n+extern char __rt_sigreturn[];\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR tile_fallback_frame_state\n+\n+static _Unwind_Reason_Code\n+tile_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t      _Unwind_FrameState *fs)\n+{\n+  unsigned char *pc = context->ra;\n+  struct sigcontext *sc;\n+  long new_cfa;\n+  int i;\n+\n+  struct rt_sigframe {\n+    unsigned char save_area[C_ABI_SAVE_AREA_SIZE];\n+    struct siginfo info;\n+    struct ucontext uc;\n+  } *rt_;\n+\n+  /* Return if this is not a signal handler.  */\n+  if (memcmp (pc, __rt_sigreturn, SIGRETURN_LEN) != 0)\n+    return _URC_END_OF_STACK;\n+\n+  /* It was a signal handler; update the reported PC to point to our\n+     copy, since that will be findable with dladdr() and therefore\n+     somewhat easier to help understand what actually happened. */\n+  context->ra = __rt_sigreturn;\n+\n+  rt_ = context->cfa;\n+  sc = &rt_->uc.uc_mcontext;\n+\n+  new_cfa = sc->sp;\n+  fs->regs.cfa_how = CFA_REG_OFFSET;\n+  fs->regs.cfa_reg = STACK_POINTER_REGNUM;\n+  fs->regs.cfa_offset = new_cfa - (long) context->cfa;\n+\n+  for (i = 0; i < 56; ++i)\n+    {\n+      fs->regs.reg[i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i].loc.offset\n+\t= (long)&sc->gregs[i] - new_cfa;\n+    }\n+\n+  fs->regs.reg[56].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[56].loc.offset = (long)&sc->pc - new_cfa;\n+  fs->retaddr_column = 56;\n+  fs->signal_frame = 1;\n+\n+  return _URC_NO_REASON;\n+}\n+\n+#endif /* ifdef inhibit_libc  */"}, {"sha": "ac5b8285e2ea149fbd56a1cce57b499c7876df92", "filename": "libgcc/config/tilepro/sfp-machine.h", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilepro%2Fsfp-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilepro%2Fsfp-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilepro%2Fsfp-machine.h?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,56 @@\n+#define _FP_W_TYPE_SIZE\t\t32\n+#define _FP_W_TYPE\t\tunsigned long\n+#define _FP_WS_TYPE\t\tsigned long\n+#define _FP_I_TYPE\t\tlong\n+\n+/* The type of the result of a floating point comparison.  This must\n+   match `__libgcc_cmp_return__' in GCC for the target.  */\n+typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n+#define CMPtype __gcc_CMPtype\n+\n+#define _FP_MUL_MEAT_S(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)\n+#define _FP_MUL_MEAT_D(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)\n+#define _FP_MUL_MEAT_Q(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)\n+\n+#define _FP_DIV_MEAT_S(R,X,Y)\t_FP_DIV_MEAT_1_loop(S,R,X,Y)\n+#define _FP_DIV_MEAT_D(R,X,Y)\t_FP_DIV_MEAT_2_udiv(D,R,X,Y)\n+#define _FP_DIV_MEAT_Q(R,X,Y)\t_FP_DIV_MEAT_4_udiv(Q,R,X,Y)\n+\n+#define _FP_NANFRAC_S\t\t_FP_QNANBIT_S\n+#define _FP_NANFRAC_D\t\t_FP_QNANBIT_D, 0\n+#define _FP_NANFRAC_Q\t\t_FP_QNANBIT_Q, 0, 0, 0\n+#define _FP_NANSIGN_S\t\t1\n+#define _FP_NANSIGN_D\t\t1\n+#define _FP_NANSIGN_Q\t\t1\n+\n+#define _FP_KEEPNANFRACP 1\n+\n+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)\t\t\\\n+\t&& !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = Y##_s;\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R,Y);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = X##_s;\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R,X);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    R##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define\t__LITTLE_ENDIAN\t1234\n+#define\t__BIG_ENDIAN\t4321\n+\n+#define __BYTE_ORDER __LITTLE_ENDIAN\n+\n+/* Define ALIASNAME as a strong alias for NAME.  */\n+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n+# define _strong_alias(name, aliasname) \\\n+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));\n+"}, {"sha": "f09b9a29406bab4f0cc5a2b91c14cc37851e27af", "filename": "libgcc/config/tilepro/softdivide.c", "status": "added", "additions": 354, "deletions": 0, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilepro%2Fsoftdivide.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilepro%2Fsoftdivide.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilepro%2Fsoftdivide.c?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,354 @@\n+/* Division and remainder routines for Tile.\n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+typedef int int32_t;\n+typedef unsigned uint32_t;\n+typedef long long int64_t;\n+typedef unsigned long long uint64_t;\n+\n+/* Raise signal 8 (SIGFPE) with code 1 (FPE_INTDIV).  */\n+static inline void\n+raise_intdiv (void)\n+{\n+  asm (\"{ raise; moveli zero, 8 + (1 << 6) }\");\n+}\n+\n+\n+#ifndef __tilegx__\n+/*__udivsi3 - 32 bit integer unsigned divide  */\n+static inline uint32_t __attribute__ ((always_inline))\n+__udivsi3_inline (uint32_t dividend, uint32_t divisor)\n+{\n+  /* Divide out any power of two factor from dividend and divisor.\n+     Note that when dividing by zero the divisor will remain zero,\n+     which is all we need to detect that case below.  */\n+  const int power_of_two_factor = __insn_ctz (divisor);\n+  divisor >>= power_of_two_factor;\n+  dividend >>= power_of_two_factor;\n+\n+  /* Checks for division by power of two or division by zero.  */\n+  if (divisor <= 1)\n+    {\n+      if (divisor == 0)\n+\t{\n+\t  raise_intdiv ();\n+\t  return 0;\n+\t}\n+      return dividend;\n+    }\n+\n+  /* Compute (a / b) by repeatedly finding the largest N\n+     such that (b << N) <= a. For each such N, set bit N in the\n+     quotient, subtract (b << N) from a, and keep going. Think of this as\n+     the reverse of the \"shift-and-add\" that a multiply does. The values\n+     of N are precisely those shift counts.\n+\n+     Finding N is easy. First, use clz(b) - clz(a) to find the N\n+     that lines up the high bit of (b << N) with the high bit of a.\n+     Any larger value of N would definitely make (b << N) > a,\n+     which is too big.\n+\n+     Then, if (b << N) > a (because it has larger low bits), decrement\n+     N by one.  This adjustment will definitely make (b << N) less\n+     than a, because a's high bit is now one higher than b's.  */\n+\n+  /* Precomputing the max_ values allows us to avoid a subtract\n+     in the inner loop and just right shift by clz(remainder).  */\n+  const int divisor_clz = __insn_clz (divisor);\n+  const uint32_t max_divisor = divisor << divisor_clz;\n+  const uint32_t max_qbit = 1 << divisor_clz;\n+\n+  uint32_t quotient = 0;\n+  uint32_t remainder = dividend;\n+\n+  while (remainder >= divisor)\n+    {\n+      int shift = __insn_clz (remainder);\n+      uint32_t scaled_divisor = max_divisor >> shift;\n+      uint32_t quotient_bit = max_qbit >> shift;\n+\n+      int too_big = (scaled_divisor > remainder);\n+      scaled_divisor >>= too_big;\n+      quotient_bit >>= too_big;\n+      remainder -= scaled_divisor;\n+      quotient |= quotient_bit;\n+    }\n+  return quotient;\n+}\n+#endif /* !__tilegx__ */\n+\n+\n+/* __udivdi3 - 64 bit integer unsigned divide  */\n+static inline uint64_t __attribute__ ((always_inline))\n+__udivdi3_inline (uint64_t dividend, uint64_t divisor)\n+{\n+  /* Divide out any power of two factor from dividend and divisor.\n+     Note that when dividing by zero the divisor will remain zero,\n+     which is all we need to detect that case below.  */\n+  const int power_of_two_factor = __builtin_ctzll (divisor);\n+  divisor >>= power_of_two_factor;\n+  dividend >>= power_of_two_factor;\n+\n+  /* Checks for division by power of two or division by zero.  */\n+  if (divisor <= 1)\n+    {\n+      if (divisor == 0)\n+\t{\n+\t  raise_intdiv ();\n+\t  return 0;\n+\t}\n+      return dividend;\n+    }\n+\n+#ifndef __tilegx__\n+  if (((uint32_t) (dividend >> 32) | ((uint32_t) (divisor >> 32))) == 0)\n+    {\n+      /* Operands both fit in 32 bits, so use faster 32 bit algorithm.  */\n+      return __udivsi3_inline ((uint32_t) dividend, (uint32_t) divisor);\n+    }\n+#endif /* !__tilegx__ */\n+\n+  /* See algorithm description in __udivsi3  */\n+\n+  const int divisor_clz = __builtin_clzll (divisor);\n+  const uint64_t max_divisor = divisor << divisor_clz;\n+  const uint64_t max_qbit = 1ULL << divisor_clz;\n+\n+  uint64_t quotient = 0;\n+  uint64_t remainder = dividend;\n+\n+  while (remainder >= divisor)\n+    {\n+      int shift = __builtin_clzll (remainder);\n+      uint64_t scaled_divisor = max_divisor >> shift;\n+      uint64_t quotient_bit = max_qbit >> shift;\n+\n+      int too_big = (scaled_divisor > remainder);\n+      scaled_divisor >>= too_big;\n+      quotient_bit >>= too_big;\n+      remainder -= scaled_divisor;\n+      quotient |= quotient_bit;\n+    }\n+  return quotient;\n+}\n+\n+\n+#ifndef __tilegx__\n+/* __umodsi3 - 32 bit integer unsigned modulo  */\n+static inline uint32_t __attribute__ ((always_inline))\n+__umodsi3_inline (uint32_t dividend, uint32_t divisor)\n+{\n+  /* Shortcircuit mod by a power of two (and catch mod by zero).  */\n+  const uint32_t mask = divisor - 1;\n+  if ((divisor & mask) == 0)\n+    {\n+      if (divisor == 0)\n+\t{\n+\t  raise_intdiv ();\n+\t  return 0;\n+\t}\n+      return dividend & mask;\n+    }\n+\n+  /* We compute the remainder (a % b) by repeatedly subtracting off\n+     multiples of b from a until a < b. The key is that subtracting\n+     off a multiple of b does not affect the result mod b.\n+\n+     To make the algorithm run efficiently, we need to subtract\n+     off a large multiple of b at each step. We subtract the largest\n+     (b << N) that is <= a.\n+\n+     Finding N is easy. First, use clz(b) - clz(a) to find the N\n+     that lines up the high bit of (b << N) with the high bit of a.\n+     Any larger value of N would definitely make (b << N) > a,\n+     which is too big.\n+\n+     Then, if (b << N) > a (because it has larger low bits), decrement\n+     N by one.  This adjustment will definitely make (b << N) less\n+     than a, because a's high bit is now one higher than b's.  */\n+  const uint32_t max_divisor = divisor << __insn_clz (divisor);\n+\n+  uint32_t remainder = dividend;\n+  while (remainder >= divisor)\n+    {\n+      const int shift = __insn_clz (remainder);\n+      uint32_t scaled_divisor = max_divisor >> shift;\n+      scaled_divisor >>= (scaled_divisor > remainder);\n+      remainder -= scaled_divisor;\n+    }\n+\n+  return remainder;\n+}\n+#endif /* !__tilegx__ */\n+\n+\n+/* __umoddi3 - 64 bit integer unsigned modulo  */\n+static inline uint64_t __attribute__ ((always_inline))\n+__umoddi3_inline (uint64_t dividend, uint64_t divisor)\n+{\n+#ifndef __tilegx__\n+  if (((uint32_t) (dividend >> 32) | ((uint32_t) (divisor >> 32))) == 0)\n+    {\n+      /* Operands both fit in 32 bits, so use faster 32 bit algorithm.  */\n+      return __umodsi3_inline ((uint32_t) dividend, (uint32_t) divisor);\n+    }\n+#endif /* !__tilegx__ */\n+\n+  /* Shortcircuit mod by a power of two (and catch mod by zero).  */\n+  const uint64_t mask = divisor - 1;\n+  if ((divisor & mask) == 0)\n+    {\n+      if (divisor == 0)\n+\t{\n+\t  raise_intdiv ();\n+\t  return 0;\n+\t}\n+      return dividend & mask;\n+    }\n+\n+  /* See algorithm description in __umodsi3  */\n+  const uint64_t max_divisor = divisor << __builtin_clzll (divisor);\n+\n+  uint64_t remainder = dividend;\n+  while (remainder >= divisor)\n+    {\n+      const int shift = __builtin_clzll (remainder);\n+      uint64_t scaled_divisor = max_divisor >> shift;\n+      scaled_divisor >>= (scaled_divisor > remainder);\n+      remainder -= scaled_divisor;\n+    }\n+\n+  return remainder;\n+}\n+\n+\n+uint32_t __udivsi3 (uint32_t dividend, uint32_t divisor);\n+#ifdef L_tile_udivsi3\n+uint32_t\n+__udivsi3 (uint32_t dividend, uint32_t divisor)\n+{\n+#ifndef __tilegx__\n+  return __udivsi3_inline (dividend, divisor);\n+#else /* !__tilegx__ */\n+  uint64_t n = __udivdi3_inline (((uint64_t) dividend), ((uint64_t) divisor));\n+  return (uint32_t) n;\n+#endif /* !__tilegx__ */\n+}\n+#endif\n+\n+#define ABS(x) ((x) >= 0 ? (x) : -(x))\n+\n+int32_t __divsi3 (int32_t dividend, int32_t divisor);\n+#ifdef L_tile_divsi3\n+/* __divsi3 - 32 bit integer signed divide  */\n+int32_t\n+__divsi3 (int32_t dividend, int32_t divisor)\n+{\n+#ifndef __tilegx__\n+  uint32_t n = __udivsi3_inline (ABS (dividend), ABS (divisor));\n+#else /* !__tilegx__ */\n+  uint64_t n =\n+    __udivdi3_inline (ABS ((int64_t) dividend), ABS ((int64_t) divisor));\n+#endif /* !__tilegx__ */\n+  if ((dividend ^ divisor) < 0)\n+    n = -n;\n+  return (int32_t) n;\n+}\n+#endif\n+\n+\n+uint64_t __udivdi3 (uint64_t dividend, uint64_t divisor);\n+#ifdef L_tile_udivdi3\n+uint64_t\n+__udivdi3 (uint64_t dividend, uint64_t divisor)\n+{\n+  return __udivdi3_inline (dividend, divisor);\n+}\n+#endif\n+\n+/*__divdi3 - 64 bit integer signed divide  */\n+int64_t __divdi3 (int64_t dividend, int64_t divisor);\n+#ifdef L_tile_divdi3\n+int64_t\n+__divdi3 (int64_t dividend, int64_t divisor)\n+{\n+  uint64_t n = __udivdi3_inline (ABS (dividend), ABS (divisor));\n+  if ((dividend ^ divisor) < 0)\n+    n = -n;\n+  return (int64_t) n;\n+}\n+#endif\n+\n+\n+uint32_t __umodsi3 (uint32_t dividend, uint32_t divisor);\n+#ifdef L_tile_umodsi3\n+uint32_t\n+__umodsi3 (uint32_t dividend, uint32_t divisor)\n+{\n+#ifndef __tilegx__\n+  return __umodsi3_inline (dividend, divisor);\n+#else /* !__tilegx__ */\n+  return __umoddi3_inline ((uint64_t) dividend, (uint64_t) divisor);\n+#endif /* !__tilegx__ */\n+}\n+#endif\n+\n+\n+/* __modsi3 - 32 bit integer signed modulo  */\n+int32_t __modsi3 (int32_t dividend, int32_t divisor);\n+#ifdef L_tile_modsi3\n+int32_t\n+__modsi3 (int32_t dividend, int32_t divisor)\n+{\n+#ifndef __tilegx__\n+  uint32_t remainder = __umodsi3_inline (ABS (dividend), ABS (divisor));\n+#else /* !__tilegx__ */\n+  uint64_t remainder =\n+    __umoddi3_inline (ABS ((int64_t) dividend), ABS ((int64_t) divisor));\n+#endif /* !__tilegx__ */\n+  return (int32_t) ((dividend >= 0) ? remainder : -remainder);\n+}\n+#endif\n+\n+\n+uint64_t __umoddi3 (uint64_t dividend, uint64_t divisor);\n+#ifdef L_tile_umoddi3\n+uint64_t\n+__umoddi3 (uint64_t dividend, uint64_t divisor)\n+{\n+  return __umoddi3_inline (dividend, divisor);\n+}\n+#endif\n+\n+\n+/* __moddi3 - 64 bit integer signed modulo  */\n+int64_t __moddi3 (int64_t dividend, int64_t divisor);\n+#ifdef L_tile_moddi3\n+int64_t\n+__moddi3 (int64_t dividend, int64_t divisor)\n+{\n+  uint64_t remainder = __umoddi3_inline (ABS (dividend), ABS (divisor));\n+  return (int64_t) ((dividend >= 0) ? remainder : -remainder);\n+}\n+#endif"}, {"sha": "eb571f65a748ed6b7b63b30981e4879e1ce26e74", "filename": "libgcc/config/tilepro/softmpy.S", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilepro%2Fsoftmpy.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilepro%2Fsoftmpy.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilepro%2Fsoftmpy.S?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,95 @@\n+/* 64-bit multiplication support for TILEPro.\n+   Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* 64-bit multiplication support.  */\n+\n+\t.file \"softmpy.S\"\n+\n+/* Parameters */\n+#define lo0             r9   /* low 32 bits of n0  */\n+#define hi0             r1   /* high 32 bits of n0 */\n+#define lo1             r2   /* low 32 bits of n1  */\n+#define hi1             r3   /* high 32 bits of n1 */\n+\n+/* temps */\n+#define result1_a       r4\n+#define result1_b       r5\n+\n+#define tmp0            r6\n+#define tmp0_left_16    r7\n+#define tmp1            r8\n+\n+\t.section .text.__muldi3, \"ax\"\n+\t.align 8\n+\t.globl __muldi3\n+\t.type __muldi3, @function\n+__muldi3:\n+\t{\n+\t move\t     lo0, r0 /* so we can write \"out r0\" while \"in r0\" alive */\n+\t mulhl_uu    tmp0, lo1, r0\n+\t}\n+\t{\n+\t mulll_uu    result1_a, lo1, hi0\n+\t}\n+\t{\n+\t move        tmp1, tmp0\n+\t mulhla_uu   tmp0, lo0, lo1\n+\t}\n+\t{\n+\t mulhlsa_uu  result1_a, lo1, hi0\n+\t}\n+\t{\n+\t mulll_uu    result1_b, lo0, hi1\n+\t slt_u       tmp1, tmp0, tmp1\n+\t}\n+\t{\n+\t mulhlsa_uu  result1_a, lo0, hi1\n+\t shli        r0, tmp0, 16\n+\t}\n+\t{\n+\t move        tmp0_left_16, r0\n+\t mulhha_uu   result1_b, lo0, lo1\n+\t}\n+\t{\n+\t mullla_uu   r0, lo1, lo0\n+\t shli        tmp1, tmp1, 16\n+\t}\n+\t{\n+\t mulhlsa_uu  result1_b, hi0, lo1\n+\t inthh       tmp1, tmp1, tmp0\n+\t}\n+\t{\n+\t mulhlsa_uu  result1_a, hi1, lo0\n+\t slt_u       tmp0, r0, tmp0_left_16\n+\t}\n+\t/* NOTE: this will stall for a cycle here. Oh well. */\n+\t{\n+\t add         r1, tmp0, tmp1\n+\t add         result1_a, result1_a, result1_b\n+\t}\n+\t{\n+\t add         r1, r1, result1_a\n+\t jrp         lr\n+\t}\n+\t.size __muldi3,.-__muldi3"}, {"sha": "eddc45ce9d8774c36547c0d2db8185b4ea53bcf8", "filename": "libgcc/config/tilepro/t-crtstuff", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilepro%2Ft-crtstuff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilepro%2Ft-crtstuff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilepro%2Ft-crtstuff?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,4 @@\n+# crtend*.o cannot be compiled without -fno-asynchronous-unwind-tables,\n+# because then __FRAME_END__ might not be the last thing in .eh_frame\n+# section.\n+CRTSTUFF_T_CFLAGS += -fno-asynchronous-unwind-tables"}, {"sha": "eb6894ce115b0d6d8672f3a60f19a1ca471f459b", "filename": "libgcc/config/tilepro/t-tilepro", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilepro%2Ft-tilepro", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libgcc%2Fconfig%2Ftilepro%2Ft-tilepro", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilepro%2Ft-tilepro?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,33 @@\n+LIB2ADD += \\\n+  $(srcdir)/config/tilepro/softmpy.S \\\n+  $(srcdir)/config/tilepro/atomic.c\n+\n+LIB2FUNCS_EXCLUDE += \\\n+  _divdi3 \\\n+  _moddi3 \\\n+  _muldi3 \\\n+  _udivdi3 \\\n+  _umoddi3\n+\n+SOFTDIVIDE_FUNCS := \\\n+  _tile_udivsi3 \\\n+  _tile_divsi3 \\\n+  _tile_udivdi3 \\\n+  _tile_divdi3 \\\n+  _tile_umodsi3 \\\n+  _tile_modsi3 \\\n+  _tile_umoddi3 \\\n+  _tile_moddi3\n+\n+softdivide-o = $(patsubst %,%$(objext),$(SOFTDIVIDE_FUNCS))\n+$(softdivide-o): %$(objext): $(srcdir)/config/tilepro/softdivide.c\n+\t$(gcc_compile) -ffunction-sections -DMAYBE_STATIC= -DL$* -c $< \\\n+\t  $(vis_hide)\n+libgcc-objects += $(softdivide-o)\n+\n+ifeq ($(enable_shared),yes)\n+softdivide-s-o = $(patsubst %,%_s$(objext),$(SOFTDIVIDE_FUNCS))\n+$(softdivide-s-o): %_s$(objext): $(srcdir)/config/tilepro/softdivide.c\n+\t$(gcc_s_compile) -ffunction-sections -DMAYBE_STATIC= -DL$* -c $<\n+libgcc-s-objects += $(softdivide-s-o)\n+endif"}, {"sha": "95a6303738e9afb283f580c85b60805e1aacd2e9", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -1,3 +1,8 @@\n+2012-02-14  Walter Lee  <walt@tilera.com>\n+\n+\t* configure.tgt: Handle tilegx and tilepro.\n+\t* config/linux/tile/futex.h: New file.\n+\n 2012-02-08  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/46886"}, {"sha": "2e733a7401873732a0e6e82237cea5de11eebe7d", "filename": "libgomp/config/linux/tile/futex.h", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libgomp%2Fconfig%2Flinux%2Ftile%2Ffutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libgomp%2Fconfig%2Flinux%2Ftile%2Ffutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Ftile%2Ffutex.h?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -0,0 +1,73 @@\n+/* Copyright (C) 2011, 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Provide target-specific access to the futex system call.  */\n+\n+#include <sys/syscall.h>\n+#include <linux/futex.h>\n+\n+static inline void\n+sys_futex0 (int *addr, int op, int val)\n+{\n+  long _sys_result;\n+  long _clobber_r2, _clobber_r3, _clobber_r4, _clobber_r5, _clobber_r10;\n+  int err;\n+\n+  __asm__ __volatile__ (\n+    \"swint1\"\n+    : \"=R00\" (_sys_result), \"=R01\" (err), \"=R02\" (_clobber_r2),\n+      \"=R03\" (_clobber_r3), \"=R04\" (_clobber_r4), \"=R05\" (_clobber_r5),\n+      \"=R10\" (_clobber_r10)\n+    : \"R10\" (SYS_futex), \"R00\" (addr), \"R01\" (op), \"R02\" (val),\n+      \"R03\" (0)\n+    :  \"r6\",  \"r7\",\n+       \"r8\",  \"r9\",        \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\n+      \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",\n+      \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"memory\");\n+}\n+\n+static inline void\n+futex_wait (int *addr, int val)\n+{\n+  sys_futex0 (addr, FUTEX_WAIT, val);\n+}\n+\n+static inline void\n+futex_wake (int *addr, int count)\n+{\n+  sys_futex0 (addr, FUTEX_WAKE, count);\n+}\n+\n+static inline void\n+cpu_relax (void)\n+{\n+  __asm volatile (\"\" : : : \"memory\");\n+}\n+\n+static inline void\n+atomic_write_barrier (void)\n+{\n+  __sync_synchronize ();\n+}"}, {"sha": "210dd5da3482ca029e41cd2a220c54e6f321d4ca", "filename": "libgomp/configure.tgt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd552284fd817c9d946598a7b647f9e67753bed6/libgomp%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd552284fd817c9d946598a7b647f9e67753bed6/libgomp%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure.tgt?ref=dd552284fd817c9d946598a7b647f9e67753bed6", "patch": "@@ -51,6 +51,10 @@ if test $enable_linux_futex = yes; then\n \tconfig_path=\"linux/s390 linux posix\"\n \t;;\n \n+    tile*-*-linux*)\n+\tconfig_path=\"linux/tile linux posix\"\n+\t;;\n+\n     # Note that bare i386 is not included here.  We need cmpxchg.\n     i[456]86-*-linux*)\n \tconfig_path=\"linux/x86 linux posix\""}]}