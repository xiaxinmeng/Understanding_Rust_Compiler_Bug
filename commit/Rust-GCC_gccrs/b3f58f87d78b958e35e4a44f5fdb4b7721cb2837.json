{"sha": "b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "node_id": "C_kwDOANBUbNoAKGIzZjU4Zjg3ZDc4Yjk1OGUzNWU0YTQ0ZjVmZGI0Yjc3MjFjYjI4Mzc", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-12-20T18:25:32Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-12-20T18:29:43Z"}, "message": "d: Merge upstream dmd ad8412530, druntime fd9a4544, phobos 495e835c2.\n\nD front-end changes:\n\n    - Import dmd v2.098.1\n    - Remove calling of _d_delstruct from code generator.\n\nDruntime changes:\n\n    - Import druntime v2.098.1\n\nPhobos changes:\n\n    - Import phobos v2.098.1\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd ad8412530.\n\t* expr.cc (ExprVisitor::visit (DeleteExp *)): Remove code generation\n\tof _d_delstruct.\n\t* runtime.def (DELSTRUCT): Remove.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/MERGE: Merge upstream druntime fd9a4544.\n\t* src/MERGE: Merge upstream phobos 495e835c2.", "tree": {"sha": "cb6530272537c7d845faab6a1ce0042f3096f618", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb6530272537c7d845faab6a1ce0042f3096f618"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d5d5032c7200714388db63c7a5676b6ab3e040e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d5d5032c7200714388db63c7a5676b6ab3e040e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d5d5032c7200714388db63c7a5676b6ab3e040e"}], "stats": {"total": 740, "additions": 468, "deletions": 272}, "files": [{"sha": "b42576c2ce64966b89ef4df09a49cbea7ec5a80b", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -1,4 +1,4 @@\n-93108bb9ea6216d67fa97bb4842fb59f26f6bfc7\n+ad8412530e607ffebec36f2dbdff1a6f2798faf7\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "b1877151c8869d45a71ecd9ff17215fb22c1bb5a", "filename": "gcc/d/dmd/canthrow.d", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Fcanthrow.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Fcanthrow.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcanthrow.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -82,6 +82,22 @@ extern (C++) bool canThrow(Expression e, FuncDeclaration func, bool mustNotThrow\n \n             if (global.errors && !ce.e1.type)\n                 return; // error recovery\n+\n+            import dmd.id : Id;\n+\n+            if (ce.f && ce.f.ident == Id._d_delstruct)\n+            {\n+                // Only check if the dtor throws.\n+                Type tb = (*ce.arguments)[0].type.toBasetype();\n+                auto ts = tb.nextOf().baseElemOf().isTypeStruct();\n+                if (ts)\n+                {\n+                    auto sd = ts.sym;\n+                    if (sd.dtor)\n+                        checkFuncThrows(ce, sd.dtor);\n+                }\n+            }\n+\n             /* If calling a function or delegate that is typed as nothrow,\n              * then this expression cannot throw.\n              * Note that pure functions can throw."}, {"sha": "a572a1ff6e0f4aeafce5e527a7d336af75d68606", "filename": "gcc/d/dmd/dcast.d", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Fdcast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Fdcast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -1565,9 +1565,9 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n                 result = e;\n                 return;\n             }\n-            if (e.op == EXP.variable)\n+            if (auto ve = e.isVarExp())\n             {\n-                VarDeclaration v = (cast(VarExp)e).var.isVarDeclaration();\n+                VarDeclaration v = ve.var.isVarDeclaration();\n                 if (v && v.storage_class & STC.manifest)\n                 {\n                     result = e.ctfeInterpret();\n@@ -1852,8 +1852,8 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n         override void visit(StructLiteralExp e)\n         {\n             visit(cast(Expression)e);\n-            if (result.op == EXP.structLiteral)\n-                (cast(StructLiteralExp)result).stype = t; // commit type\n+            if (auto sle = result.isStructLiteralExp())\n+                sle.stype = t; // commit type\n         }\n \n         override void visit(StringExp e)\n@@ -1866,7 +1866,8 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n \n             //printf(\"StringExp::castTo(t = %s), '%s' committed = %d\\n\", t.toChars(), e.toChars(), e.committed);\n \n-            if (!e.committed && t.ty == Tpointer && t.nextOf().ty == Tvoid)\n+            if (!e.committed && t.ty == Tpointer && t.nextOf().ty == Tvoid &&\n+                (!sc || !(sc.flags & SCOPE.Cfile)))\n             {\n                 e.error(\"cannot convert string literal to `void*`\");\n                 result = ErrorExp.get();\n@@ -1883,7 +1884,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n \n             if (!e.committed)\n             {\n-                se = cast(StringExp)e.copy();\n+                se = e.copy().isStringExp();\n                 se.committed = 1;\n                 copied = 1;\n             }\n@@ -1908,7 +1909,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n             {\n                 if (!copied)\n                 {\n-                    se = cast(StringExp)e.copy();\n+                    se = e.copy().isStringExp();\n                     copied = 1;\n                 }\n                 se.type = t;\n@@ -1924,7 +1925,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n              */\n             if (e.committed && tb.ty == Tsarray && typeb.ty == Tarray)\n             {\n-                se = cast(StringExp)e.copy();\n+                se = e.copy().isStringExp();\n                 d_uns64 szx = tb.nextOf().size();\n                 assert(szx <= 255);\n                 se.sz = cast(ubyte)szx;\n@@ -1952,7 +1953,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n             {\n                 if (!copied)\n                 {\n-                    se = cast(StringExp)e.copy();\n+                    se = e.copy().isStringExp();\n                     copied = 1;\n                 }\n                 return lcast();\n@@ -1961,7 +1962,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n             {\n                 if (!copied)\n                 {\n-                    se = cast(StringExp)e.copy();\n+                    se = e.copy().isStringExp();\n                     copied = 1;\n                 }\n                 return lcast();\n@@ -1977,7 +1978,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n             {\n                 if (!copied)\n                 {\n-                    se = cast(StringExp)e.copy();\n+                    se = e.copy().isStringExp();\n                     copied = 1;\n                 }\n                 if (tb.ty == Tsarray)\n@@ -2088,7 +2089,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n                 L1:\n                     if (!copied)\n                     {\n-                        se = cast(StringExp)e.copy();\n+                        se = e.copy().isStringExp();\n                         copied = 1;\n                     }\n \n@@ -2154,10 +2155,10 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n             }\n \n             // Look for pointers to functions where the functions are overloaded.\n-            if (e.e1.op == EXP.overloadSet &&\n+            if (e.e1.isOverExp() &&\n                 (tb.ty == Tpointer || tb.ty == Tdelegate) && tb.nextOf().ty == Tfunction)\n             {\n-                OverExp eo = cast(OverExp)e.e1;\n+                OverExp eo = e.e1.isOverExp();\n                 FuncDeclaration f = null;\n                 for (size_t i = 0; i < eo.vars.a.dim; i++)\n                 {\n@@ -2188,11 +2189,11 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n                 }\n             }\n \n-            if (e.e1.op == EXP.variable &&\n+            if (e.e1.isVarExp() &&\n                 typeb.ty == Tpointer && typeb.nextOf().ty == Tfunction &&\n                 tb.ty == Tpointer && tb.nextOf().ty == Tfunction)\n             {\n-                auto ve = cast(VarExp)e.e1;\n+                auto ve = e.e1.isVarExp();\n                 auto f = ve.var.isFuncDeclaration();\n                 if (f)\n                 {\n@@ -2303,7 +2304,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n                             goto L1;\n                     }\n \n-                    ae = cast(ArrayLiteralExp)e.copy();\n+                    ae = e.copy().isArrayLiteralExp();\n                     if (e.basis)\n                         ae.basis = e.basis.castTo(sc, tb.nextOf());\n                     ae.elements = e.elements.copy();\n@@ -2325,7 +2326,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n                 Type tp = typeb.nextOf().pointerTo();\n                 if (!tp.equals(ae.type))\n                 {\n-                    ae = cast(ArrayLiteralExp)e.copy();\n+                    ae = e.copy().isArrayLiteralExp();\n                     ae.type = tp;\n                 }\n             }\n@@ -2382,7 +2383,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n             if (tb.ty == Taarray && typeb.ty == Taarray &&\n                 tb.nextOf().toBasetype().ty != Tvoid)\n             {\n-                AssocArrayLiteralExp ae = cast(AssocArrayLiteralExp)e.copy();\n+                AssocArrayLiteralExp ae = e.copy().isAssocArrayLiteralExp();\n                 ae.keys = e.keys.copy();\n                 ae.values = e.values.copy();\n                 assert(e.keys.dim == e.values.dim);\n@@ -2422,7 +2423,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n             {\n                 result = e.copy();\n                 result.type = t;\n-                (cast(SymOffExp)result).hasOverloads = false;\n+                result.isSymOffExp().hasOverloads = false;\n                 return;\n             }\n \n@@ -2641,7 +2642,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n                 {\n                     Expression e1x = e.e1.implicitCastTo(sc, t1b);\n                     assert(e1x.op != EXP.error);\n-                    e = cast(SliceExp)e.copy();\n+                    e = e.copy().isSliceExp();\n                     e.e1 = e1x;\n                     e.type = t;\n                     result = e;\n@@ -2751,10 +2752,10 @@ Expression inferType(Expression e, Type t, int flag = 0)\n \n     if (t) switch (e.op)\n     {\n-        case EXP.arrayLiteral:      return visitAle(cast(ArrayLiteralExp) e);\n-        case EXP.assocArrayLiteral: return visitAar(cast(AssocArrayLiteralExp) e);\n-        case EXP.function_:         return visitFun(cast(FuncExp) e);\n-        case EXP.question:          return visitTer(cast(CondExp) e);\n+        case EXP.arrayLiteral:      return visitAle(e.isArrayLiteralExp());\n+        case EXP.assocArrayLiteral: return visitAar(e.isAssocArrayLiteralExp());\n+        case EXP.function_:         return visitFun(e.isFuncExp());\n+        case EXP.question:          return visitTer(e.isCondExp());\n         default:\n     }\n     return e;\n@@ -2830,9 +2831,9 @@ Expression scaleFactor(BinExp be, Scope* sc)\n  */\n private bool isVoidArrayLiteral(Expression e, Type other)\n {\n-    while (e.op == EXP.arrayLiteral && e.type.ty == Tarray && ((cast(ArrayLiteralExp)e).elements.dim == 1))\n+    while (e.op == EXP.arrayLiteral && e.type.ty == Tarray && (e.isArrayLiteralExp().elements.dim == 1))\n     {\n-        auto ale = cast(ArrayLiteralExp)e;\n+        auto ale = e.isArrayLiteralExp();\n         e = ale[0];\n         if (other.ty == Tsarray || other.ty == Tarray)\n             other = other.nextOf();\n@@ -2842,7 +2843,7 @@ private bool isVoidArrayLiteral(Expression e, Type other)\n     if (other.ty != Tsarray && other.ty != Tarray)\n         return false;\n     Type t = e.type;\n-    return (e.op == EXP.arrayLiteral && t.ty == Tarray && t.nextOf().ty == Tvoid && (cast(ArrayLiteralExp)e).elements.dim == 0);\n+    return (e.op == EXP.arrayLiteral && t.ty == Tarray && t.nextOf().ty == Tvoid && e.isArrayLiteralExp().elements.dim == 0);\n }\n \n /**\n@@ -3463,20 +3464,20 @@ LmodCompare:\n         Expression rhs = e2;\n \n         // T[x .. y] op ?\n-        if (e1.isSliceExp())\n-            lhs = new IndexExp(Loc.initial, (cast(UnaExp)e1).e1, IntegerExp.literal!0);\n+        if (auto se1 = e1.isSliceExp())\n+            lhs = new IndexExp(Loc.initial, se1.e1, IntegerExp.literal!0);\n \n         // [t1, t2, .. t3] op ?\n-        if (e1.isArrayLiteralExp())\n-            lhs = (cast(ArrayLiteralExp)e1).opIndex(0);\n+        if (auto ale1 = e1.isArrayLiteralExp())\n+            lhs = ale1.opIndex(0);\n \n         // ? op U[z .. t]\n-        if (e2.isSliceExp())\n-            rhs = new IndexExp(Loc.initial, (cast(UnaExp)e2).e1, IntegerExp.literal!0);\n+        if (auto se2 = e2.isSliceExp())\n+            rhs = new IndexExp(Loc.initial, se2.e1, IntegerExp.literal!0);\n \n         // ? op [u1, u2, .. u3]\n-        if (e2.isArrayLiteralExp())\n-            rhs = (cast(ArrayLiteralExp)e2).opIndex(0);\n+        if (auto ale2 = e2.isArrayLiteralExp())\n+            rhs = ale2.opIndex(0);\n \n         // create a new binary expression with the new lhs and rhs (at this stage, at least\n         // one of lhs/rhs has been replaced with the 0'th element of the array it was before)"}, {"sha": "fc5b9a8843b618370cda8f48c66a01c8a30171f1", "filename": "gcc/d/dmd/dinterpret.d", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Fdinterpret.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Fdinterpret.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -4837,6 +4837,47 @@ public:\n                 result = interpret(ce, istate);\n                 return;\n             }\n+            else if (fd.ident == Id._d_delstruct)\n+            {\n+                // Only interpret the dtor and the argument.\n+                assert(e.arguments.dim == 1);\n+\n+                Type tb = (*e.arguments)[0].type.toBasetype();\n+                auto ts = tb.nextOf().baseElemOf().isTypeStruct();\n+                if (ts)\n+                {\n+                    result = interpretRegion((*e.arguments)[0], istate);\n+                    if (exceptionOrCant(result))\n+                        return;\n+\n+                    if (result.op == EXP.null_)\n+                    {\n+                        result = CTFEExp.voidexp;\n+                        return;\n+                    }\n+\n+                    if (result.op != EXP.address ||\n+                        (cast(AddrExp)result).e1.op != EXP.structLiteral)\n+                    {\n+                        e.error(\"`delete` on invalid struct pointer `%s`\", result.toChars());\n+                        result = CTFEExp.cantexp;\n+                        return;\n+                    }\n+\n+                    auto sd = ts.sym;\n+                    if (sd.dtor)\n+                    {\n+                        auto sle = cast(StructLiteralExp)(cast(AddrExp)result).e1;\n+                        result = interpretFunction(pue, sd.dtor, istate, null, sle);\n+                        if (exceptionOrCant(result))\n+                            return;\n+\n+                        result = CTFEExp.voidexp;\n+                    }\n+                }\n+\n+                return;\n+            }\n         }\n         else if (auto soe = ecall.isSymOffExp())\n         {"}, {"sha": "e34a94ad44b25ad714e0734800aa1e3834d352e8", "filename": "gcc/d/dmd/dsymbol.d", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Fdsymbol.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Fdsymbol.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -2453,10 +2453,10 @@ Dsymbol handleSymbolRedeclarations(ref Scope sc, Dsymbol s, Dsymbol s2, ScopeDsy\n         if (i1 && i2)\n             return collision();         // can't both have initializers\n \n-        if (i1)\n+        if (i1)                         // vd is the definition\n         {\n-            vd2._init = vd._init;\n-            vd._init = null;\n+            sds.symtab.update(vd);      // replace vd2 with the definition\n+            return vd;\n         }\n \n         /* BUG: the types should match, which needs semantic() to be run on it\n@@ -2497,14 +2497,10 @@ Dsymbol handleSymbolRedeclarations(ref Scope sc, Dsymbol s, Dsymbol s2, ScopeDsy\n         if (fd.fbody && fd2.fbody)\n             return collision();         // can't both have bodies\n \n-        if (fd.fbody)\n+        if (fd.fbody)                   // fd is the definition\n         {\n-            fd2.fbody = fd.fbody;       // transfer body to existing declaration\n-            fd.fbody = null;\n-\n-            auto tf = fd.type.toTypeFunction();\n-            auto tf2 = fd2.type.toTypeFunction();\n-            tf2.parameterList = tf.parameterList;   // transfer parameter list.\n+            sds.symtab.update(fd);      // replace fd2 in symbol table with fd\n+            return fd;\n         }\n \n         /* BUG: just like with VarDeclaration, the types should match, which needs semantic() to be run on it."}, {"sha": "118b861d0596cea1e0b83978abb15b004e43c635", "filename": "gcc/d/dmd/dsymbolsem.d", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -3981,15 +3981,15 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             return;\n \n         TypeFunction tf = ctd.type.toTypeFunction();\n+        immutable dim = tf.parameterList.length;\n+        auto sd = ad.isStructDeclaration();\n \n         /* See if it's the default constructor\n          * But, template constructor should not become a default constructor.\n          */\n         if (ad && (!ctd.parent.isTemplateInstance() || ctd.parent.isTemplateMixin()))\n         {\n-            immutable dim = tf.parameterList.length;\n-\n-            if (auto sd = ad.isStructDeclaration())\n+            if (sd)\n             {\n                 if (dim == 0 && tf.parameterList.varargs == VarArg.none) // empty default ctor w/o any varargs\n                 {\n@@ -4034,6 +4034,24 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                 ad.defaultCtor = ctd;\n             }\n         }\n+        // https://issues.dlang.org/show_bug.cgi?id=22593\n+        else if (auto ti = ctd.parent.isTemplateInstance())\n+        {\n+            if (sd && sd.hasCopyCtor && (dim == 1 || (dim > 1 && tf.parameterList[1].defaultArg)))\n+            {\n+                auto param = tf.parameterList[0];\n+\n+                // if the template instance introduces an rvalue constructor\n+                // between the members of a struct declaration, we should check if a\n+                // copy constructor exists and issue an error in that case.\n+                if (!(param.storageClass & STC.ref_) && param.type.mutableOf().unSharedOf() == sd.type.mutableOf().unSharedOf())\n+                {\n+                    .error(ctd.loc, \"Cannot define both an rvalue constructor and a copy constructor for `struct %s`\", sd.toChars);\n+                    .errorSupplemental(ti.loc, \"Template instance `%s` creates a rvalue constructor for `struct %s`\",\n+                            ti.toChars(), sd.toChars());\n+                }\n+            }\n+        }\n     }\n \n     override void visit(PostBlitDeclaration pbd)"}, {"sha": "2f1cd4767c5e28884e0da068e43421fb29ae5cc0", "filename": "gcc/d/dmd/expressionsem.d", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -7316,6 +7316,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 deprecation(exp.loc, \"The `delete` keyword has been deprecated.  Use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead.\");\n         }\n \n+        Expression e = exp;\n+\n         if (Expression ex = unaSemantic(exp, sc))\n         {\n             result = ex;\n@@ -7352,7 +7354,27 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             if (tb.ty == Tstruct)\n             {\n                 ad = (cast(TypeStruct)tb).sym;\n-                semanticTypeInfo(sc, tb);\n+\n+                Identifier hook = global.params.tracegc ? Id._d_delstructTrace : Id._d_delstruct;\n+                if (!verifyHookExist(exp.loc, *sc, Id._d_delstructImpl, \"deleting struct with dtor\", Id.object))\n+                    return setError();\n+\n+                // Lower to .object._d_delstruct{,Trace}(exp.e1)\n+                Expression id = new IdentifierExp(exp.loc, Id.empty);\n+                id = new DotIdExp(exp.loc, id, Id.object);\n+\n+                auto tiargs = new Objects();\n+                tiargs.push(exp.e1.type);\n+                id = new DotTemplateInstanceExp(exp.loc, id, Id._d_delstructImpl, tiargs);\n+                id = new DotIdExp(exp.loc, id, hook);\n+\n+                e = new CallExp(exp.loc, id, exp.e1);\n+                /* Gag errors generated by calls to `_d_delstruct`, because they display\n+                 * internal compiler information, which is unnecessary to the user.\n+                 */\n+                uint errors = global.startGagging();\n+                e = e.expressionSemantic(sc);\n+                global.endGagging(errors);\n             }\n             break;\n \n@@ -7397,7 +7419,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         if (err)\n             return setError();\n \n-        result = exp;\n+        result = e;\n     }\n \n     override void visit(CastExp exp)"}, {"sha": "d33b676a032577cb076e38f2766e025dcb3df182", "filename": "gcc/d/dmd/id.d", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Fid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Fid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fid.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -311,6 +311,9 @@ immutable Msgtable[] msgtable =\n     { \"__ArrayPostblit\" },\n     { \"__ArrayDtor\" },\n     { \"_d_delThrowable\" },\n+    { \"_d_delstructImpl\" },\n+    { \"_d_delstruct\" },\n+    { \"_d_delstructTrace\" },\n     { \"_d_assert_fail\" },\n     { \"dup\" },\n     { \"_aaApply\" },"}, {"sha": "826b0adebed2778137ca64a307e9651a59960892", "filename": "gcc/d/dmd/initsem.d", "status": "modified", "additions": 59, "deletions": 47, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Finitsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Finitsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finitsem.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -284,7 +284,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n         case Tarray:\n             break;\n         case Tvector:\n-            t = (cast(TypeVector)t).basetype;\n+            t = t.isTypeVector().basetype;\n             break;\n         case Taarray:\n         case Tstruct: // consider implicit constructor call\n@@ -346,7 +346,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n             // found a tuple, expand it\n             if (ei && ei.exp.op == EXP.tuple)\n             {\n-                TupleExp te = cast(TupleExp)ei.exp;\n+                TupleExp te = ei.exp.isTupleExp();\n                 i.index.remove(j);\n                 i.value.remove(j);\n                 for (size_t k = 0; k < te.exps.dim; ++k)\n@@ -462,7 +462,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n         {\n             return i; // Failed, suppress duplicate error messages\n         }\n-        if (i.exp.type.ty == Ttuple && (cast(TypeTuple)i.exp.type).arguments.dim == 0)\n+        if (i.exp.type.isTypeTuple() && i.exp.type.isTypeTuple().arguments.dim == 0)\n         {\n             Type et = i.exp.type;\n             i.exp = new TupleExp(i.exp.loc, new Expressions());\n@@ -492,12 +492,12 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n          */\n         if (i.exp.op == EXP.string_ && tb.ty == Tsarray)\n         {\n-            StringExp se = cast(StringExp)i.exp;\n+            StringExp se = i.exp.isStringExp();\n             Type typeb = se.type.toBasetype();\n             TY tynto = tb.nextOf().ty;\n             if (!se.committed &&\n                 (typeb.ty == Tarray || typeb.ty == Tsarray) && tynto.isSomeChar &&\n-                se.numberOfCodeUnits(tynto) < (cast(TypeSArray)tb).dim.toInteger())\n+                se.numberOfCodeUnits(tynto) < tb.isTypeSArray().dim.toInteger())\n             {\n                 i.exp = se.castTo(sc, t);\n                 goto L1;\n@@ -520,7 +520,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n         // Look for implicit constructor call\n         if (tb.ty == Tstruct && !(ti.ty == Tstruct && tb.toDsymbol(sc) == ti.toDsymbol(sc)) && !i.exp.implicitConvTo(t))\n         {\n-            StructDeclaration sd = (cast(TypeStruct)tb).sym;\n+            StructDeclaration sd = tb.isTypeStruct().sym;\n             if (sd.ctor)\n             {\n                 // Rewrite as S().ctor(exp)\n@@ -573,18 +573,16 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n             // better diagnostic message, as same as AssignExp::semantic.\n             if (tb.ty == Tsarray && i.exp.implicitConvTo(tb.nextOf().arrayOf()) > MATCH.nomatch)\n             {\n-                uinteger_t dim1 = (cast(TypeSArray)tb).dim.toInteger();\n+                uinteger_t dim1 = tb.isTypeSArray().dim.toInteger();\n                 uinteger_t dim2 = dim1;\n-                if (i.exp.op == EXP.arrayLiteral)\n+                if (auto ale = i.exp.isArrayLiteralExp())\n                 {\n-                    ArrayLiteralExp ale = cast(ArrayLiteralExp)i.exp;\n                     dim2 = ale.elements ? ale.elements.dim : 0;\n                 }\n-                else if (i.exp.op == EXP.slice)\n+                else if (auto se = i.exp.isSliceExp())\n                 {\n-                    Type tx = toStaticArrayType(cast(SliceExp)i.exp);\n-                    if (tx)\n-                        dim2 = (cast(TypeSArray)tx).dim.toInteger();\n+                    if (Type tx = toStaticArrayType(se))\n+                        dim2 = tx.isTypeSArray().dim.toInteger();\n                 }\n                 if (dim1 != dim2)\n                 {\n@@ -746,10 +744,11 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n          * Params:\n          *    t = element type\n          *    dim = max number of elements\n+         *    simple = true if array of simple elements\n          * Returns:\n          *    # of elements in array\n          */\n-        size_t array(Type t, size_t dim)\n+        size_t array(Type t, size_t dim, ref bool simple)\n         {\n             //printf(\" type %s i %d dim %d dil.length = %d\\n\", t.toChars(), cast(int)i, cast(int)dim, cast(int)dil.length);\n             auto tn = t.nextOf().toBasetype();\n@@ -791,14 +790,30 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n                 if (tnsa && di.initializer.isExpInitializer())\n                 {\n                     // no braces enclosing array initializer, so recurse\n-                    array(tnsa, nelems);\n+                    array(tnsa, nelems, simple);\n                 }\n                 else if (auto tns = tn.isTypeStruct())\n                 {\n-                    if (di.initializer.isExpInitializer())\n+                    if (auto ei = di.initializer.isExpInitializer())\n                     {\n                         // no braces enclosing struct initializer\n-                        dil[n].initializer = structs(tns);\n+\n+                        /* Disambiguate between an exp representing the entire\n+                         * struct, and an exp representing the first field of the struct\n+                        */\n+                        if (needInterpret)\n+                            sc = sc.startCTFE();\n+                        ei.exp = ei.exp.expressionSemantic(sc);\n+                        ei.exp = resolveProperties(sc, ei.exp);\n+                        if (needInterpret)\n+                            sc = sc.endCTFE();\n+                        if (ei.exp.implicitConvTo(tn))\n+                            di.initializer = elem(di.initializer); // the whole struct\n+                        else\n+                        {\n+                            simple = false;\n+                            dil[n].initializer = structs(tns); // the first field\n+                        }\n                     }\n                     else\n                         dil[n].initializer = elem(di.initializer);\n@@ -816,7 +831,8 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n         }\n \n         size_t dim = tsa.isIncomplete() ? dil.length : cast(size_t)tsa.dim.toInteger();\n-        auto newdim = array(t, dim);\n+        bool simple = true;\n+        auto newdim = array(t, dim, simple);\n \n         if (errors)\n             return err();\n@@ -849,7 +865,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n         /* If an array of simple elements, replace with an ArrayInitializer\n          */\n         auto tnb = tn.toBasetype();\n-        if (!(tnb.isTypeSArray() || tnb.isTypeStruct()))\n+        if (!tnb.isTypeSArray() && (!tnb.isTypeStruct() || simple))\n         {\n             auto ai = new ArrayInitializer(ci.loc);\n             ai.dim = cast(uint) dil.length;\n@@ -884,12 +900,12 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n \n     final switch (init.kind)\n     {\n-        case InitKind.void_:   return visitVoid  (cast(  VoidInitializer)init);\n-        case InitKind.error:   return visitError (cast( ErrorInitializer)init);\n-        case InitKind.struct_: return visitStruct(cast(StructInitializer)init);\n-        case InitKind.array:   return visitArray (cast( ArrayInitializer)init);\n-        case InitKind.exp:     return visitExp   (cast(   ExpInitializer)init);\n-        case InitKind.C_:      return visitC     (cast(     CInitializer)init);\n+        case InitKind.void_:   return visitVoid  (init.isVoidInitializer());\n+        case InitKind.error:   return visitError (init.isErrorInitializer());\n+        case InitKind.struct_: return visitStruct(init.isStructInitializer());\n+        case InitKind.array:   return visitArray (init.isArrayInitializer());\n+        case InitKind.exp:     return visitExp   (init.isExpInitializer());\n+        case InitKind.C_:      return visitC     (init.isCInitializer());\n     }\n }\n \n@@ -943,8 +959,7 @@ Initializer inferType(Initializer init, Scope* sc)\n                 {\n                     return iz;\n                 }\n-                assert(iz.isExpInitializer());\n-                (*values)[i] = (cast(ExpInitializer)iz).exp;\n+                (*values)[i] = iz.isExpInitializer().exp;\n                 assert(!(*values)[i].isErrorExp());\n             }\n             Expression e = new AssocArrayLiteralExp(init.loc, keys, values);\n@@ -966,8 +981,7 @@ Initializer inferType(Initializer init, Scope* sc)\n                 {\n                     return iz;\n                 }\n-                assert(iz.isExpInitializer());\n-                (*elements)[i] = (cast(ExpInitializer)iz).exp;\n+                (*elements)[i] = iz.isExpInitializer().exp;\n                 assert(!(*elements)[i].isErrorExp());\n             }\n             Expression e = new ArrayLiteralExp(init.loc, null, elements);\n@@ -996,9 +1010,8 @@ Initializer inferType(Initializer init, Scope* sc)\n             init.exp = resolveAliasThis(sc, init.exp);\n \n         init.exp = resolveProperties(sc, init.exp);\n-        if (init.exp.op == EXP.scope_)\n+        if (auto se = init.exp.isScopeExp())\n         {\n-            ScopeExp se = cast(ScopeExp)init.exp;\n             TemplateInstance ti = se.sds.isTemplateInstance();\n             if (ti && ti.semanticRun == PASS.semantic && !ti.aliasdecl)\n                 se.error(\"cannot infer type from %s `%s`, possible circular dependency\", se.sds.kind(), se.toChars());\n@@ -1021,16 +1034,15 @@ Initializer inferType(Initializer init, Scope* sc)\n                 return new ErrorInitializer();\n             }\n         }\n-        if (init.exp.op == EXP.address)\n+        if (auto ae = init.exp.isAddrExp())\n         {\n-            AddrExp ae = cast(AddrExp)init.exp;\n             if (ae.e1.op == EXP.overloadSet)\n             {\n                 init.exp.error(\"cannot infer type from overloaded function symbol `%s`\", init.exp.toChars());\n                 return new ErrorInitializer();\n             }\n         }\n-        if (init.exp.op == EXP.error)\n+        if (init.exp.isErrorExp())\n         {\n             return new ErrorInitializer();\n         }\n@@ -1050,12 +1062,12 @@ Initializer inferType(Initializer init, Scope* sc)\n \n     final switch (init.kind)\n     {\n-        case InitKind.void_:   return visitVoid  (cast(  VoidInitializer)init);\n-        case InitKind.error:   return visitError (cast( ErrorInitializer)init);\n-        case InitKind.struct_: return visitStruct(cast(StructInitializer)init);\n-        case InitKind.array:   return visitArray (cast( ArrayInitializer)init);\n-        case InitKind.exp:     return visitExp   (cast(   ExpInitializer)init);\n-        case InitKind.C_:      return visitC     (cast(     CInitializer)init);\n+        case InitKind.void_:   return visitVoid  (init.isVoidInitializer());\n+        case InitKind.error:   return visitError (init.isErrorInitializer());\n+        case InitKind.struct_: return visitStruct(init.isStructInitializer());\n+        case InitKind.array:   return visitArray (init.isArrayInitializer());\n+        case InitKind.exp:     return visitExp   (init.isExpInitializer());\n+        case InitKind.C_:      return visitC     (init.isCInitializer());\n     }\n }\n \n@@ -1260,12 +1272,12 @@ extern (C++) Expression initializerToExpression(Initializer init, Type itype = n\n \n     final switch (init.kind)\n     {\n-        case InitKind.void_:   return visitVoid  (cast(  VoidInitializer)init);\n-        case InitKind.error:   return visitError (cast( ErrorInitializer)init);\n-        case InitKind.struct_: return visitStruct(cast(StructInitializer)init);\n-        case InitKind.array:   return visitArray (cast( ArrayInitializer)init);\n-        case InitKind.exp:     return visitExp   (cast(   ExpInitializer)init);\n-        case InitKind.C_:      return visitC     (cast(     CInitializer)init);\n+        case InitKind.void_:   return visitVoid  (init.isVoidInitializer());\n+        case InitKind.error:   return visitError (init.isErrorInitializer());\n+        case InitKind.struct_: return visitStruct(init.isStructInitializer());\n+        case InitKind.array:   return visitArray (init.isArrayInitializer());\n+        case InitKind.exp:     return visitExp   (init.isExpInitializer());\n+        case InitKind.C_:      return visitC     (init.isCInitializer());\n     }\n }\n \n@@ -1308,7 +1320,7 @@ private bool hasNonConstPointers(Expression e)\n     {\n         if (ae.type.nextOf().hasPointers() && checkArray(ae.values))\n             return true;\n-        if ((cast(TypeAArray)ae.type).index.hasPointers())\n+        if (ae.type.isTypeAArray().index.hasPointers())\n             return checkArray(ae.keys);\n         return false;\n     }"}, {"sha": "8bdddb8f9ea3a79493cbbf689b773d3929fc0e68", "filename": "gcc/d/dmd/nogc.d", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Fnogc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Fnogc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fnogc.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -83,6 +83,20 @@ public:\n             }\n             f.printGCUsage(e.loc, \"setting `length` may cause a GC allocation\");\n         }\n+        else if (fd.ident == Id._d_delstruct)\n+        {\n+            // In expressionsem.d, `delete s` was lowererd to `_d_delstruct(s)`.\n+            // The following code handles the call like the original expression,\n+            // so the error is menaningful to the user.\n+            if (f.setGC())\n+            {\n+                e.error(\"cannot use `delete` in `@nogc` %s `%s`\", f.kind(),\n+                    f.toPrettyChars());\n+                err = true;\n+                return;\n+            }\n+            f.printGCUsage(e.loc, \"`delete` requires the GC\");\n+        }\n     }\n \n     override void visit(ArrayLiteralExp e)"}, {"sha": "49b87d6bf47a3aec0574d017f0a22981a1e555b1", "filename": "gcc/d/dmd/semantic3.d", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Fsemantic3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Fsemantic3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic3.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -419,8 +419,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                     sc2.insert(_arguments);\n                     _arguments.parent = funcdecl;\n                 }\n-                if ((f.linkage == LINK.d || f.parameterList.length) &&\n-                    !(sc.flags & SCOPE.Cfile))  // don't want to require importing stdarg for C files\n+                if (f.linkage == LINK.d || f.parameterList.length)\n                 {\n                     // Declare _argptr\n                     Type t = target.va_listType(funcdecl.loc, sc);"}, {"sha": "e5b05d38a45dce1a34a41cdd4ce29d408f1b3bd3", "filename": "gcc/d/dmd/tokens.d", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Ftokens.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Ftokens.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -23,7 +23,7 @@ import dmd.common.outbuffer;\n import dmd.root.rmem;\n import dmd.utf;\n \n-enum TOK : ushort\n+enum TOK : ubyte\n {\n     reserved,\n \n@@ -84,10 +84,7 @@ enum TOK : ushort\n     rightShiftAssign,\n     unsignedRightShift,\n     unsignedRightShiftAssign,\n-    concatenate,\n     concatenateAssign, // ~=\n-    concatenateElemAssign,\n-    concatenateDcharAssign,\n     add,\n     min,\n     addAssign,\n@@ -109,15 +106,11 @@ enum TOK : ushort\n     tilde,\n     plusPlus,\n     minusMinus,\n-    construct,\n-    blit,\n     dot,\n     comma,\n     question,\n     andAnd,\n     orOr,\n-    prePlusPlus,\n-    preMinusMinus,\n \n     // Numeric literals\n     int32Literal,\n@@ -144,7 +137,6 @@ enum TOK : ushort\n     hexadecimalString,\n     this_,\n     super_,\n-    tuple,\n     error,\n \n     // Basic types\n@@ -244,7 +236,6 @@ enum TOK : ushort\n \n     parameters,\n     traits,\n-    overloadSet,\n     pure_,\n     nothrow_,\n     gshared,\n@@ -564,7 +555,6 @@ private immutable TOK[] keywords =\n     TOK.gshared,\n     TOK.traits,\n     TOK.vector,\n-    TOK.overloadSet,\n     TOK.file,\n     TOK.fileFullPath,\n     TOK.line,\n@@ -769,7 +759,6 @@ extern (C++) struct Token\n         TOK.gshared: \"__gshared\",\n         TOK.traits: \"__traits\",\n         TOK.vector: \"__vector\",\n-        TOK.overloadSet: \"__overloadset\",\n         TOK.file: \"__FILE__\",\n         TOK.fileFullPath: \"__FILE_FULL_PATH__\",\n         TOK.line: \"__LINE__\",\n@@ -793,8 +782,6 @@ extern (C++) struct Token\n         TOK.xor: \"^\",\n         TOK.xorAssign: \"^=\",\n         TOK.assign: \"=\",\n-        TOK.construct: \"=\",\n-        TOK.blit: \"=\",\n         TOK.lessThan: \"<\",\n         TOK.greaterThan: \">\",\n         TOK.lessOrEqual: \"<=\",\n@@ -824,8 +811,6 @@ extern (C++) struct Token\n         TOK.dollar: \"$\",\n         TOK.plusPlus: \"++\",\n         TOK.minusMinus: \"--\",\n-        TOK.prePlusPlus: \"++\",\n-        TOK.preMinusMinus: \"--\",\n         TOK.type: \"type\",\n         TOK.question: \"?\",\n         TOK.negate: \"-\",\n@@ -842,9 +827,6 @@ extern (C++) struct Token\n         TOK.andAssign: \"&=\",\n         TOK.orAssign: \"|=\",\n         TOK.concatenateAssign: \"~=\",\n-        TOK.concatenateElemAssign: \"~=\",\n-        TOK.concatenateDcharAssign: \"~=\",\n-        TOK.concatenate: \"~\",\n         TOK.call: \"call\",\n         TOK.identity: \"is\",\n         TOK.notIdentity: \"!is\",\n@@ -860,7 +842,6 @@ extern (C++) struct Token\n         // For debugging\n         TOK.error: \"error\",\n         TOK.string_: \"string\",\n-        TOK.tuple: \"tuple\",\n         TOK.declaration: \"declaration\",\n         TOK.onScopeExit: \"scope(exit)\",\n         TOK.onScopeSuccess: \"scope(success)\",\n@@ -1113,11 +1094,6 @@ nothrow:\n         return toString(value).ptr;\n     }\n \n-    static const(char)* toChars(ushort value)\n-    {\n-        return toString(cast(TOK)value).ptr;\n-    }\n-\n     extern (D) static string toString(TOK value) pure nothrow @nogc @safe\n     {\n         return tochars[value];"}, {"sha": "e095aa6b91a9f55f823f3e1879b77d15f63a8401", "filename": "gcc/d/dmd/tokens.h", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Ftokens.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Ftokens.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.h?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -32,7 +32,7 @@ class Identifier;\n         ?       &&      ||\n  */\n \n-enum class TOK : unsigned short\n+enum class TOK : unsigned char\n {\n     reserved,\n \n@@ -93,10 +93,7 @@ enum class TOK : unsigned short\n     rightShiftAssign,\n     unsignedRightShift,\n     unsignedRightShiftAssign,\n-    concatenate,\n     concatenateAssign, // ~=\n-    concatenateElemAssign,\n-    concatenateDcharAssign,\n     add,\n     min,\n     addAssign,\n@@ -118,15 +115,11 @@ enum class TOK : unsigned short\n     tilde,\n     plusPlus,\n     minusMinus,\n-    construct,\n-    blit,\n     dot,\n     comma,\n     question,\n     andAnd,\n     orOr,\n-    prePlusPlus,\n-    preMinusMinus,\n \n     // Numeric literals\n     int32Literal,   // 104,\n@@ -153,7 +146,6 @@ enum class TOK : unsigned short\n     hexadecimalString,\n     this_,\n     super_,\n-    tuple,\n     error,\n \n     // Basic types\n@@ -253,7 +245,6 @@ enum class TOK : unsigned short\n \n     parameters,     // 210\n     traits,\n-    overloadSet,\n     pure_,\n     nothrow_,\n     gshared,"}, {"sha": "b8c43174f4a82af09c20ba6f5398e171a54f744a", "filename": "gcc/d/dmd/typesem.d", "status": "modified", "additions": 89, "deletions": 89, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Ftypesem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fdmd%2Ftypesem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -271,7 +271,7 @@ private void resolveHelper(TypeQualified mt, const ref Loc loc, Scope* sc, Dsymb\n                 sm = null;\n             }\n             // Same check as in Expression.semanticY(DotIdExp)\n-            else if (sm.isPackage() && checkAccess(sc, cast(Package)sm))\n+            else if (sm.isPackage() && checkAccess(sc, sm.isPackage()))\n             {\n                 // @@@DEPRECATED_2.096@@@\n                 // Should be an error in 2.106. Just remove the deprecation call\n@@ -509,7 +509,7 @@ private Type stripDefaultArgs(Type t)\n         Parameters* params = stripParams(tf.parameterList.parameters);\n         if (tret == tf.next && params == tf.parameterList.parameters)\n             return t;\n-        TypeFunction tr = cast(TypeFunction)tf.copy();\n+        TypeFunction tr = tf.copy().isTypeFunction();\n         tr.parameterList.parameters = params;\n         tr.next = tret;\n         //printf(\"strip %s\\n   <- %s\\n\", tr.toChars(), t.toChars());\n@@ -520,7 +520,7 @@ private Type stripDefaultArgs(Type t)\n         Parameters* args = stripParams(tt.arguments);\n         if (args == tt.arguments)\n             return t;\n-        TypeTuple tr = cast(TypeTuple)t.copy();\n+        TypeTuple tr = t.copy().isTypeTuple();\n         tr.arguments = args;\n         return tr;\n     }\n@@ -588,11 +588,11 @@ Expression typeToExpression(Type t)\n         return null;\n     switch (t.ty)\n     {\n-        case Tsarray:   return visitSArray(cast(TypeSArray) t);\n-        case Taarray:   return visitAArray(cast(TypeAArray) t);\n-        case Tident:    return visitIdentifier(cast(TypeIdentifier) t);\n-        case Tinstance: return visitInstance(cast(TypeInstance) t);\n-        case Tmixin:    return visitMixin(cast(TypeMixin) t);\n+        case Tsarray:   return visitSArray(t.isTypeSArray());\n+        case Taarray:   return visitAArray(t.isTypeAArray());\n+        case Tident:    return visitIdentifier(t.isTypeIdentifier());\n+        case Tinstance: return visitInstance(t.isTypeInstance());\n+        case Tmixin:    return visitMixin(t.isTypeMixin());\n         default:        return null;\n     }\n }\n@@ -684,7 +684,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n             .error(loc, \"T in __vector(T) must be a static array, not `%s`\", mtype.basetype.toChars());\n             return error();\n         }\n-        TypeSArray t = cast(TypeSArray)mtype.basetype;\n+        TypeSArray t = mtype.basetype.isTypeSArray();\n         const sz = cast(int)t.size(loc);\n         final switch (target.isVectorTypeSupported(sz, t.nextOf()))\n         {\n@@ -790,8 +790,8 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                 return overflowError();\n \n             Type tbx = tbn.baseElemOf();\n-            if (tbx.ty == Tstruct && !(cast(TypeStruct)tbx).sym.members ||\n-                tbx.ty == Tenum && !(cast(TypeEnum)tbx).sym.members)\n+            if (tbx.ty == Tstruct && !tbx.isTypeStruct().sym.members ||\n+                tbx.ty == Tenum && !tbx.isTypeEnum().sym.members)\n             {\n                 /* To avoid meaningless error message, skip the total size limit check\n                  * when the bottom of element type is opaque.\n@@ -802,7 +802,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                      tbn.ty == Tarray ||\n                      tbn.ty == Tsarray ||\n                      tbn.ty == Taarray ||\n-                     (tbn.ty == Tstruct && ((cast(TypeStruct)tbn).sym.sizeok == Sizeok.done)) ||\n+                     (tbn.ty == Tstruct && tbn.isTypeStruct().sym.sizeok == Sizeok.done) ||\n                      tbn.ty == Tclass)\n             {\n                 /* Only do this for types that don't need to have semantic()\n@@ -819,7 +819,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n             {\n                 // Index the tuple to get the type\n                 assert(mtype.dim);\n-                TypeTuple tt = cast(TypeTuple)tbn;\n+                TypeTuple tt = tbn.isTypeTuple();\n                 uinteger_t d = mtype.dim.toUInteger();\n                 if (d >= tt.arguments.dim)\n                 {\n@@ -1026,9 +1026,9 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                  */\n             }\n         }\n-        else if (tbase.ty == Tclass && !(cast(TypeClass)tbase).sym.isInterfaceDeclaration())\n+        else if (tbase.ty == Tclass && !tbase.isTypeClass().sym.isInterfaceDeclaration())\n         {\n-            ClassDeclaration cd = (cast(TypeClass)tbase).sym;\n+            ClassDeclaration cd = tbase.isTypeClass().sym;\n             if (cd.semanticRun < PASS.semanticdone)\n                 cd.dsymbolSemantic(null);\n \n@@ -1275,7 +1275,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n             }\n             if (e.op == EXP.function_) // https://issues.dlang.org/show_bug.cgi?id=4820\n             {\n-                FuncExp fe = cast(FuncExp)e;\n+                FuncExp fe = e.isFuncExp();\n                 // Replace function literal with a function symbol,\n                 // since default arg expression must be copied when used\n                 // and copying the literal itself is wrong.\n@@ -1402,8 +1402,8 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                          (t.ty == Tstruct || t.ty == Tsarray || t.ty == Tenum))\n                 {\n                     Type tb2 = t.baseElemOf();\n-                    if (tb2.ty == Tstruct && !(cast(TypeStruct)tb2).sym.members ||\n-                        tb2.ty == Tenum && !(cast(TypeEnum)tb2).sym.memtype)\n+                    if (tb2.ty == Tstruct && !tb2.isTypeStruct().sym.members ||\n+                        tb2.ty == Tenum   && !tb2.isTypeEnum().sym.memtype)\n                     {\n                         if (global.params.previewIn && (fparam.storageClass & STC.in_))\n                         {\n@@ -1467,7 +1467,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                     else\n                     {\n                         Type tv = t.baseElemOf();\n-                        if (tv.ty == Tstruct && (cast(TypeStruct)tv).sym.noDefaultCtor)\n+                        if (tv.ty == Tstruct && tv.isTypeStruct().sym.noDefaultCtor)\n                         {\n                             .error(loc, \"cannot have `out` parameter of type `%s` because the default construction is disabled\", fparam.type.toChars());\n                             errors = true;\n@@ -1824,26 +1824,26 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n             switch (e.op)\n             {\n             case EXP.dotVariable:\n-                mtype.sym = (cast(DotVarExp)e).var;\n+                mtype.sym = e.isDotVarExp().var;\n                 break;\n             case EXP.variable:\n-                mtype.sym = (cast(VarExp)e).var;\n+                mtype.sym = e.isVarExp().var;\n                 break;\n             case EXP.function_:\n-                auto fe = cast(FuncExp)e;\n+                auto fe = e.isFuncExp();\n                 mtype.sym = fe.td ? fe.td : fe.fd;\n                 break;\n             case EXP.dotTemplateDeclaration:\n-                mtype.sym = (cast(DotTemplateExp)e).td;\n+                mtype.sym = e.isDotTemplateExp().td;\n                 break;\n             case EXP.dSymbol:\n-                mtype.sym = (cast(DsymbolExp)e).s;\n+                mtype.sym = e.isDsymbolExp().s;\n                 break;\n             case EXP.template_:\n-                mtype.sym = (cast(TemplateExp)e).td;\n+                mtype.sym = e.isTemplateExp().td;\n                 break;\n             case EXP.scope_:\n-                mtype.sym = (cast(ScopeExp)e).sds;\n+                mtype.sym = e.isScopeExp().sds;\n                 break;\n             case EXP.tuple:\n                 TupleExp te = e.toTupleExp();\n@@ -1854,13 +1854,13 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                     switch (src.op)\n                     {\n                     case EXP.type:\n-                        (*elems)[i] = (cast(TypeExp)src).type;\n+                        (*elems)[i] = src.isTypeExp().type;\n                         break;\n                     case EXP.dotType:\n-                        (*elems)[i] = (cast(DotTypeExp)src).sym.isType();\n+                        (*elems)[i] = src.isDotTypeExp().sym.isType();\n                         break;\n                     case EXP.overloadSet:\n-                        (*elems)[i] = (cast(OverExp)src).type;\n+                        (*elems)[i] = src.isOverExp().type;\n                         break;\n                     default:\n                         if (auto sym = isDsymbol(src))\n@@ -1873,13 +1873,13 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                 mtype.sym = td;\n                 break;\n             case EXP.dotType:\n-                result = (cast(DotTypeExp)e).sym.isType();\n+                result = e.isDotTypeExp().sym.isType();\n                 break;\n             case EXP.type:\n-                result = (cast(TypeExp)e).type;\n+                result = e.isTypeExp().type;\n                 break;\n             case EXP.overloadSet:\n-                result = (cast(OverExp)e).type;\n+                result = e.isOverExp().type;\n                 break;\n             default:\n                 break;\n@@ -2211,26 +2211,26 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n     switch (type.ty)\n     {\n         default:         return visitType(type);\n-        case Tvector:    return visitVector(cast(TypeVector)type);\n-        case Tsarray:    return visitSArray(cast(TypeSArray)type);\n-        case Tarray:     return visitDArray(cast(TypeDArray)type);\n-        case Taarray:    return visitAArray(cast(TypeAArray)type);\n-        case Tpointer:   return visitPointer(cast(TypePointer)type);\n-        case Treference: return visitReference(cast(TypeReference)type);\n-        case Tfunction:  return visitFunction(cast(TypeFunction)type);\n-        case Tdelegate:  return visitDelegate(cast(TypeDelegate)type);\n-        case Tident:     return visitIdentifier(cast(TypeIdentifier)type);\n-        case Tinstance:  return visitInstance(cast(TypeInstance)type);\n-        case Ttypeof:    return visitTypeof(cast(TypeTypeof)type);\n-        case Ttraits:    return visitTraits(cast(TypeTraits)type);\n-        case Treturn:    return visitReturn(cast(TypeReturn)type);\n-        case Tstruct:    return visitStruct(cast(TypeStruct)type);\n-        case Tenum:      return visitEnum(cast(TypeEnum)type);\n-        case Tclass:     return visitClass(cast(TypeClass)type);\n-        case Ttuple:     return visitTuple (cast(TypeTuple)type);\n-        case Tslice:     return visitSlice(cast(TypeSlice)type);\n-        case Tmixin:     return visitMixin(cast(TypeMixin)type);\n-        case Ttag:       return visitTag(cast(TypeTag)type);\n+        case Tvector:    return visitVector(type.isTypeVector());\n+        case Tsarray:    return visitSArray(type.isTypeSArray());\n+        case Tarray:     return visitDArray(type.isTypeDArray());\n+        case Taarray:    return visitAArray(type.isTypeAArray());\n+        case Tpointer:   return visitPointer(type.isTypePointer());\n+        case Treference: return visitReference(type.isTypeReference());\n+        case Tfunction:  return visitFunction(type.isTypeFunction());\n+        case Tdelegate:  return visitDelegate(type.isTypeDelegate());\n+        case Tident:     return visitIdentifier(type.isTypeIdentifier());\n+        case Tinstance:  return visitInstance(type.isTypeInstance());\n+        case Ttypeof:    return visitTypeof(type.isTypeTypeof());\n+        case Ttraits:    return visitTraits(type.isTypeTraits());\n+        case Treturn:    return visitReturn(type.isTypeReturn());\n+        case Tstruct:    return visitStruct(type.isTypeStruct());\n+        case Tenum:      return visitEnum(type.isTypeEnum());\n+        case Tclass:     return visitClass(type.isTypeClass());\n+        case Ttuple:     return visitTuple(type.isTypeTuple());\n+        case Tslice:     return visitSlice(type.isTypeSlice());\n+        case Tmixin:     return visitMixin(type.isTypeMixin());\n+        case Ttag:       return visitTag(type.isTypeTag());\n     }\n }\n \n@@ -2300,15 +2300,15 @@ extern (C++) Type merge(Type type)\n \n         case Tsarray:\n             // prevents generating the mangle if the array dim is not yet known\n-            if (!(cast(TypeSArray) type).dim.isIntegerExp())\n+            if (!type.isTypeSArray().dim.isIntegerExp())\n                 return type;\n             goto default;\n \n         case Tenum:\n             break;\n \n         case Taarray:\n-            if (!(cast(TypeAArray)type).index.merge().deco)\n+            if (!type.isTypeAArray().index.merge().deco)\n                 return type;\n             goto default;\n \n@@ -2761,10 +2761,10 @@ Expression getProperty(Type t, Scope* scope_, const ref Loc loc, Identifier iden\n                                 visitBasic(cast(TypeBasic)t) :\n                                 visitType(t);\n \n-        case Terror:    return visitError (cast(TypeError)t);\n-        case Tvector:   return visitVector(cast(TypeVector)t);\n-        case Tenum:     return visitEnum  (cast(TypeEnum)t);\n-        case Ttuple:    return visitTuple (cast(TypeTuple)t);\n+        case Terror:    return visitError (t.isTypeError());\n+        case Tvector:   return visitVector(t.isTypeVector());\n+        case Tenum:     return visitEnum  (t.isTypeEnum());\n+        case Ttuple:    return visitTuple (t.isTypeTuple());\n     }\n }\n \n@@ -2889,7 +2889,7 @@ void resolve(Type mt, const ref Loc loc, Scope* sc, out Expression pe, out Type\n                 {\n                     Expression e = cast(Expression)o;\n                     if (e.op == EXP.dSymbol)\n-                        return returnSymbol((cast(DsymbolExp)e).s);\n+                        return returnSymbol(e.isDsymbolExp().s);\n                     else\n                         return returnExp(e);\n                 }\n@@ -3154,8 +3154,8 @@ void resolve(Type mt, const ref Loc loc, Scope* sc, out Expression pe, out Type\n              * template functions.\n              */\n         }\n-        if (auto f = mt.exp.op == EXP.variable    ? (cast(   VarExp)mt.exp).var.isFuncDeclaration()\n-                   : mt.exp.op == EXP.dotVariable ? (cast(DotVarExp)mt.exp).var.isFuncDeclaration() : null)\n+        if (auto f = mt.exp.op == EXP.variable    ? mt.exp.isVarExp().var.isFuncDeclaration()\n+                   : mt.exp.op == EXP.dotVariable ? mt.exp.isDotVarExp().var.isFuncDeclaration() : null)\n         {\n             // f might be a unittest declaration which is incomplete when compiled\n             // without -unittest. That causes a segfault in checkForwardRef, see\n@@ -3350,17 +3350,17 @@ void resolve(Type mt, const ref Loc loc, Scope* sc, out Expression pe, out Type\n \n     switch (mt.ty)\n     {\n-        default:        visitType      (mt);                     break;\n-        case Tsarray:   visitSArray    (cast(TypeSArray)mt);     break;\n-        case Tarray:    visitDArray    (cast(TypeDArray)mt);     break;\n-        case Taarray:   visitAArray    (cast(TypeAArray)mt);     break;\n-        case Tident:    visitIdentifier(cast(TypeIdentifier)mt); break;\n-        case Tinstance: visitInstance  (cast(TypeInstance)mt);   break;\n-        case Ttypeof:   visitTypeof    (cast(TypeTypeof)mt);     break;\n-        case Treturn:   visitReturn    (cast(TypeReturn)mt);     break;\n-        case Tslice:    visitSlice     (cast(TypeSlice)mt);      break;\n-        case Tmixin:    visitMixin     (cast(TypeMixin)mt);      break;\n-        case Ttraits:   visitTraits    (cast(TypeTraits)mt);     break;\n+        default:        visitType      (mt);                    break;\n+        case Tsarray:   visitSArray    (mt.isTypeSArray());     break;\n+        case Tarray:    visitDArray    (mt.isTypeDArray());     break;\n+        case Taarray:   visitAArray    (mt.isTypeAArray());     break;\n+        case Tident:    visitIdentifier(mt.isTypeIdentifier()); break;\n+        case Tinstance: visitInstance  (mt.isTypeInstance());   break;\n+        case Ttypeof:   visitTypeof    (mt.isTypeTypeof());     break;\n+        case Treturn:   visitReturn    (mt.isTypeReturn());     break;\n+        case Tslice:    visitSlice     (mt.isTypeSlice());      break;\n+        case Tmixin:    visitMixin     (mt.isTypeMixin());      break;\n+        case Ttraits:   visitTraits    (mt.isTypeTraits());     break;\n     }\n }\n \n@@ -4616,16 +4616,16 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n \n     switch (mt.ty)\n     {\n-        case Tvector:    return visitVector   (cast(TypeVector)mt);\n-        case Tsarray:    return visitSArray   (cast(TypeSArray)mt);\n-        case Tstruct:    return visitStruct   (cast(TypeStruct)mt);\n-        case Tenum:      return visitEnum     (cast(TypeEnum)mt);\n-        case Terror:     return visitError    (cast(TypeError)mt);\n-        case Tarray:     return visitDArray   (cast(TypeDArray)mt);\n-        case Taarray:    return visitAArray   (cast(TypeAArray)mt);\n-        case Treference: return visitReference(cast(TypeReference)mt);\n-        case Tdelegate:  return visitDelegate (cast(TypeDelegate)mt);\n-        case Tclass:     return visitClass    (cast(TypeClass)mt);\n+        case Tvector:    return visitVector   (mt.isTypeVector());\n+        case Tsarray:    return visitSArray   (mt.isTypeSArray());\n+        case Tstruct:    return visitStruct   (mt.isTypeStruct());\n+        case Tenum:      return visitEnum     (mt.isTypeEnum());\n+        case Terror:     return visitError    (mt.isTypeError());\n+        case Tarray:     return visitDArray   (mt.isTypeDArray());\n+        case Taarray:    return visitAArray   (mt.isTypeAArray());\n+        case Treference: return visitReference(mt.isTypeReference());\n+        case Tdelegate:  return visitDelegate (mt.isTypeDelegate());\n+        case Tclass:     return visitClass    (mt.isTypeClass());\n \n         default:         return mt.isTypeBasic()\n                                 ? visitBasic(cast(TypeBasic)mt)\n@@ -4786,12 +4786,12 @@ extern (C++) Expression defaultInit(Type mt, const ref Loc loc, const bool isCfi\n \n     switch (mt.ty)\n     {\n-        case Tvector:   return visitVector  (cast(TypeVector)mt);\n-        case Tsarray:   return visitSArray  (cast(TypeSArray)mt);\n-        case Tfunction: return visitFunction(cast(TypeFunction)mt);\n-        case Tstruct:   return visitStruct  (cast(TypeStruct)mt);\n-        case Tenum:     return visitEnum    (cast(TypeEnum)mt);\n-        case Ttuple:    return visitTuple   (cast(TypeTuple)mt);\n+        case Tvector:   return visitVector  (mt.isTypeVector());\n+        case Tsarray:   return visitSArray  (mt.isTypeSArray());\n+        case Tfunction: return visitFunction(mt.isTypeFunction());\n+        case Tstruct:   return visitStruct  (mt.isTypeStruct());\n+        case Tenum:     return visitEnum    (mt.isTypeEnum());\n+        case Ttuple:    return visitTuple   (mt.isTypeTuple());\n \n         case Tnull:     return new NullExp(Loc.initial, Type.tnull);\n \n@@ -4803,7 +4803,7 @@ extern (C++) Expression defaultInit(Type mt, const ref Loc loc, const bool isCfi\n         case Treference:\n         case Tdelegate:\n         case Tclass:    return new NullExp(loc, mt);\n-        case Tnoreturn: return visitNoreturn(cast(TypeNoreturn) mt);\n+        case Tnoreturn: return visitNoreturn(mt.isTypeNoreturn());\n \n         default:        return mt.isTypeBasic() ?\n                                 visitBasic(cast(TypeBasic)mt) :"}, {"sha": "665d12205b31f661d06a13a9c787d1a3e7c6f04d", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -1477,16 +1477,10 @@ class ExprVisitor : public Visitor\n \tt1 = build_address (t1);\n \tType *tnext = tb1->isTypePointer ()->next->toBasetype ();\n \n+\t/* This case should have been rewritten to `_d_delstruct` in the\n+\t   semantic phase.  */\n \tif (TypeStruct *ts = tnext->isTypeStruct ())\n-\t  {\n-\t    if (ts->sym->dtor)\n-\t      {\n-\t\ttree ti = build_typeinfo (e->loc, tnext);\n-\t\tthis->result_ = build_libcall (LIBCALL_DELSTRUCT, Type::tvoid,\n-\t\t\t\t\t       2, t1, ti);\n-\t\treturn;\n-\t      }\n-\t  }\n+\t  gcc_assert (!ts->sym->dtor);\n \n \t/* Otherwise, the garbage collector is called to immediately free the\n \t   memory allocated for the pointer.  */"}, {"sha": "ef54a37d9bc17e5d2deba9e1d3b7ad4e1d77e5de", "filename": "gcc/d/runtime.def", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Fd%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fruntime.def?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -85,8 +85,6 @@ DEF_D_RUNTIME (NEWITEMIT, \"_d_newitemiT\", RT(VOIDPTR), P1(CONST_TYPEINFO), 0)\n \n /* Used when calling delete on a pointer.  */\n DEF_D_RUNTIME (DELMEMORY, \"_d_delmemory\", RT(VOID), P1(POINTER_VOIDPTR), 0)\n-DEF_D_RUNTIME (DELSTRUCT, \"_d_delstruct\", RT(VOID),\n-\t       P2(POINTER_VOIDPTR, TYPEINFO), 0)\n \n /* Used when calling new on an array.  The `i' variant is for when the\n    initializer is nonzero, and the `m' variant is when initializing a"}, {"sha": "20912941620b1fcbf56622d1075753fbffa19100", "filename": "gcc/testsuite/gdc.test/compilable/test22593.d", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22593.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22593.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22593.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -0,0 +1,13 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22593\n+\n+struct Foo(T){\n+    this(Rhs, this This)(scope Rhs rhs){\n+    }\n+\n+    this(ref scope typeof(this) rhs){\n+    }\n+}\n+\n+struct Bar{\n+    Foo!int foo;\n+}"}, {"sha": "84c4d8533e2e1e1344a053017e6b6a0c9c482426", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice17074.d", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice17074.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice17074.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice17074.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -1,19 +1,13 @@\n /*\n-TEST_OUTPUT:\n----\n-fail_compilation/ice17074.d(9): Error: identifier expected for C++ namespace\n-fail_compilation/ice17074.d(9): Error: found `__overloadset` when expecting `)`\n-fail_compilation/ice17074.d(9): Error: declaration expected, not `)`\n----\n */\n extern(C++, std.__overloadset) void ice_std_keyword();\n \n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice17074.d(19): Error: identifier expected for C++ namespace\n-fail_compilation/ice17074.d(19): Error: found `*` when expecting `)`\n-fail_compilation/ice17074.d(19): Error: declaration expected, not `)`\n+fail_compilation/ice17074.d(13): Error: identifier expected for C++ namespace\n+fail_compilation/ice17074.d(13): Error: found `*` when expecting `)`\n+fail_compilation/ice17074.d(13): Error: declaration expected, not `)`\n ---\n */\n extern(C++, std.*) void ice_std_token();"}, {"sha": "f90287e9e06e6a6d4f73afdce4ee681a96c0af4a", "filename": "gcc/testsuite/gdc.test/fail_compilation/test22593.d", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22593.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22593.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22593.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -0,0 +1,23 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22593\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/test22593.d(14): Error: Cannot define both an rvalue constructor and a copy constructor for `struct Foo`\n+fail_compilation/test22593.d(22):        Template instance `__ctor!(immutable(Foo!int), immutable(Foo!int))` creates a rvalue constructor for `struct Foo`\n+fail_compilation/test22593.d(22): Error: template instance `test22593.Foo!int.Foo.__ctor!(immutable(Foo!int), immutable(Foo!int))` error instantiating\n+---\n+*/\n+\n+struct Foo(T)\n+{\n+    this(Rhs, this This)(scope Rhs rhs){}\n+\n+    this(ref scope typeof(this) rhs){}\n+}\n+\n+void main()\n+{\n+    immutable Foo!int a;\n+    a.__ctor(a);\n+}"}, {"sha": "70f7ff596a8d00e412824561faece107ed4ee5a4", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -1,4 +1,4 @@\n-6364e010bc87f3621028c8ac648133535c126fb3\n+fd9a45448244fb9dd4326520ad8526c540895eb0\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/druntime repository."}, {"sha": "1ed80f7d94ab6ffef7e7afaec8ee71d4e3dfad63", "filename": "libphobos/libdruntime/core/builtins.d", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/libphobos%2Flibdruntime%2Fcore%2Fbuiltins.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/libphobos%2Flibdruntime%2Fcore%2Fbuiltins.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fbuiltins.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -1,11 +1,45 @@\n /**********************************************\n- * This module implements common builtins for the D frontend.\n- *\n- * Copyright: Copyright \u00a9 2019, The D Language Foundation\n- * License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Authors:   Walter Bright\n- * Source:    $(DRUNTIMESRC core/builtins.d)\n- */\n+To provide access to features that would be otherwise counterproductive or\n+difficult to implement, compilers provide an interface consisting of a set\n+of builtins (also called intrinsics) which can be called like normal functions.\n+\n+This module exposes builtins both common to all D compilers\n+(those provided by the frontend) and specific to the host compiler i.e. those\n+specific to either LLVM or GCC (`ldc.intrinsics` and `gcc.builtins` are publicly imported, respectively).\n+Host-specific intrinsics cannot be reliably listed here, however listings can be found\n+at the documentation for the relevant backends, i.e.\n+$(LINK2 https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html, GCC) and\n+$(LINK2 https://llvm.org/docs/LangRef.html, LLVM). It should be noted that not all\n+builtins listed are necessarily supported by the host compiler, please file a bug\n+if this is the case for your workload.\n+\n+Use of this module reduces the amount of conditional compilation needed\n+to use a given builtin. For example, to write a target independent function\n+that uses prefetching we can write the following:\n+---\n+float usePrefetch(float[] x)\n+{\n+    // There is only one import statement required rather than two (versioned) imports\n+    import core.builtins;\n+    version (GNU)\n+        __builtin_prefetch(x.ptr);\n+    version (LDC)\n+        /+\n+            For the curious: 0, 3, 1 mean `x` will only be read-from (0), it will be used\n+            very often (3), and it should be fetched to the data-cache (1).\n+        +/\n+        llvm_prefetch(x.ptr, 0, 3, 1);\n+    const doMath = blahBlahBlah;\n+    return doMath;\n+}\n+---\n+\n+\n+Copyright: Copyright \u00a9 2021, The D Language Foundation\n+License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+Authors:   Walter Bright\n+Source:    $(DRUNTIMESRC core/builtins.d)\n+*/\n \n module core.builtins;\n "}, {"sha": "9a99f2da02a63ea4b99fb204352728adb0a6ef4f", "filename": "libphobos/libdruntime/core/lifetime.d", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/libphobos%2Flibdruntime%2Fcore%2Flifetime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/libphobos%2Flibdruntime%2Fcore%2Flifetime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Flifetime.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -1545,9 +1545,8 @@ template forward(args...)\n {\n     import core.internal.traits : AliasSeq;\n \n-    static if (args.length)\n+    template fwd(alias arg)\n     {\n-        alias arg = args[0];\n         // by ref || lazy || const/immutable\n         static if (__traits(isRef,  arg) ||\n                    __traits(isOut,  arg) ||\n@@ -1556,15 +1555,16 @@ template forward(args...)\n             alias fwd = arg;\n         // (r)value\n         else\n-            @property auto fwd(){ return move(arg); }\n-\n-        static if (args.length == 1)\n-            alias forward = fwd;\n-        else\n-            alias forward = AliasSeq!(fwd, forward!(args[1..$]));\n+            @property auto fwd(){ pragma(inline, true); return move(arg); }\n     }\n+\n+    alias Result = AliasSeq!();\n+    static foreach (arg; args)\n+        Result = AliasSeq!(Result, fwd!arg);\n+    static if (Result.length == 1)\n+        alias forward = Result[0];\n     else\n-        alias forward = AliasSeq!();\n+        alias forward = Result;\n }\n \n ///\n@@ -2316,7 +2316,7 @@ template _d_delstructImpl(T)\n @system pure nothrow unittest\n {\n     int dtors = 0;\n-    struct S { ~this() { ++dtors; } }\n+    struct S { ~this() nothrow { ++dtors; } }\n \n     S *s = new S();\n     _d_delstructImpl!(typeof(s))._d_delstruct(s);"}, {"sha": "e828b7447d11a3e9c1dba415d9178d36bd6bc5c4", "filename": "libphobos/libdruntime/core/sys/linux/sched.d", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fsched.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fsched.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fsched.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -153,6 +153,9 @@ version (CRuntime_Glibc)\n     int sched_getcpu();\n }\n \n+/* Reassociate the calling thread with namespace referred to by fd */\n+int setns(int fd, int nstype);\n+\n enum CLONE_FILES = 0x400;\n enum CLONE_FS = 0x200;\n enum CLONE_NEWCGROUP = 0x2000000;"}, {"sha": "c989caa64bf4e144233fc3caebc5a2302988210e", "filename": "libphobos/libdruntime/object.d", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/libphobos%2Flibdruntime%2Fobject.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/libphobos%2Flibdruntime%2Fobject.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fobject.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -4667,17 +4667,33 @@ public import core.internal.switch_: __switch_error;\n public @trusted @nogc nothrow pure extern (C) void _d_delThrowable(scope Throwable);\n \n // Compare class and interface objects for ordering.\n-private int __cmp(Obj)(Obj lhs, Obj rhs)\n-if (is(Obj : Object))\n+int __cmp(C1, C2)(C1 lhs, C2 rhs)\n+if ((is(C1 : const(Object)) || (is(C1 == interface) && (__traits(getLinkage, C1) == \"D\"))) &&\n+    (is(C2 : const(Object)) || (is(C2 == interface) && (__traits(getLinkage, C2) == \"D\"))))\n {\n-    if (lhs is rhs)\n+    static if (is(C1 == typeof(null)) && is(C2 == typeof(null)))\n+    {\n         return 0;\n-    // Regard null references as always being \"less than\"\n-    if (!lhs)\n+    }\n+    else static if (is(C1 == typeof(null)))\n+    {\n+        // Regard null references as always being \"less than\"\n         return -1;\n-    if (!rhs)\n+    }\n+    else static if (is(C2 == typeof(null)))\n+    {\n         return 1;\n-    return lhs.opCmp(rhs);\n+    }\n+    else\n+    {\n+        if (lhs is rhs)\n+            return 0;\n+        if (lhs is null)\n+            return -1;\n+        if (rhs is null)\n+            return 1;\n+        return lhs.opCmp(rhs);\n+    }\n }\n \n // objects"}, {"sha": "b517749b54269983b7ee2abdd3436e607ef16cb6", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -1,4 +1,4 @@\n-575b67a9b4f78415f96ca77ad50b2de4c667cc74\n+495e835c2da47606142ff24c85de707e3b955a9a\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "e67d95ccc23de0bd160505ca4f84ea09e754d350", "filename": "libphobos/src/std/format/write.d", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/libphobos%2Fsrc%2Fstd%2Fformat%2Fwrite.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/libphobos%2Fsrc%2Fstd%2Fformat%2Fwrite.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fformat%2Fwrite.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -1287,3 +1287,26 @@ void formatValue(Writer, T, Char)(auto ref Writer w, auto ref T val, scope const\n \n     assertThrown!FormatException(formattedWrite(w, \"%(%0*d%)\", new int[1]));\n }\n+\n+// https://issues.dlang.org/show_bug.cgi?id=22609\n+@safe pure unittest\n+{\n+    static enum State: ubyte { INACTIVE }\n+    static struct S {\n+        State state = State.INACTIVE;\n+        int generation = 1;\n+        alias state this;\n+        // DMDBUG: https://issues.dlang.org/show_bug.cgi?id=16657\n+        auto opEquals(S other) const { return state == other.state && generation == other.generation; }\n+        auto opEquals(State other) const { return state == other; }\n+    }\n+\n+    import std.array : appender;\n+    import std.format.spec : singleSpec;\n+\n+    auto writer = appender!string();\n+    const spec = singleSpec(\"%s\");\n+    S a;\n+    writer.formatValue(a, spec);\n+    assert(writer.data == \"0\");\n+}"}, {"sha": "6d55d4149c753c96bbfbf012466ef3c29960e9ba", "filename": "libphobos/src/std/range/interfaces.d", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/libphobos%2Fsrc%2Fstd%2Frange%2Finterfaces.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/libphobos%2Fsrc%2Fstd%2Frange%2Finterfaces.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Frange%2Finterfaces.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -201,6 +201,9 @@ interface RandomAccessFinite(E) : BidirectionalRange!(E) {\n \n /**Interface for an infinite random access range of type `E`.*/\n interface RandomAccessInfinite(E) : ForwardRange!E {\n+    ///\n+    enum bool empty = false;\n+\n     /**Calls $(REF moveAt, std, range, primitives) on the wrapped range, if\n      * possible. Otherwise, throws an $(LREF UnsupportedRangeMethod) exception.\n      */\n@@ -213,6 +216,12 @@ interface RandomAccessInfinite(E) : ForwardRange!E {\n     E opIndex(size_t);\n }\n \n+// https://issues.dlang.org/show_bug.cgi?id=22608\n+@safe unittest\n+{\n+    static assert(isRandomAccessRange!(RandomAccessInfinite!int));\n+}\n+\n /**Adds assignable elements to InputRange.*/\n interface InputAssignable(E) : InputRange!E {\n     ///"}, {"sha": "cde2b9da055ae2d8c323ded596ca0049f9bafbeb", "filename": "libphobos/src/std/typecons.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/libphobos%2Fsrc%2Fstd%2Ftypecons.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f58f87d78b958e35e4a44f5fdb4b7721cb2837/libphobos%2Fsrc%2Fstd%2Ftypecons.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ftypecons.d?ref=b3f58f87d78b958e35e4a44f5fdb4b7721cb2837", "patch": "@@ -6971,7 +6971,7 @@ mixin template Proxy(alias a)\n             static if (is(typeof(a.opCmp(b))))\n                 return a.opCmp(b);\n             else static if (is(typeof(b.opCmp(a))))\n-                return -b.opCmp(b);\n+                return -b.opCmp(a);\n             else\n                 return a < b ? -1 : a > b ? +1 : 0;\n         }"}]}