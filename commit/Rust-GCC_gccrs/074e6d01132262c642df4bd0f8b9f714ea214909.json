{"sha": "074e6d01132262c642df4bd0f8b9f714ea214909", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc0ZTZkMDExMzIyNjJjNjQyZGY0YmQwZjhiOWY3MTRlYTIxNDkwOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-12-12T21:12:43Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-12-12T21:12:43Z"}, "message": "expr.c (emit_move_change_mode): New.\n\n        * expr.c (emit_move_change_mode): New.\n        (emit_move_via_alt_mode): Use it.\n\nFrom-SVN: r92065", "tree": {"sha": "e9963f8e60cf011e1d03417f864235eb33ad2a54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9963f8e60cf011e1d03417f864235eb33ad2a54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/074e6d01132262c642df4bd0f8b9f714ea214909", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/074e6d01132262c642df4bd0f8b9f714ea214909", "html_url": "https://github.com/Rust-GCC/gccrs/commit/074e6d01132262c642df4bd0f8b9f714ea214909", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/074e6d01132262c642df4bd0f8b9f714ea214909/comments", "author": null, "committer": null, "parents": [{"sha": "23acf4d41122152f857318a67d63a5f4e8f1cb32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23acf4d41122152f857318a67d63a5f4e8f1cb32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23acf4d41122152f857318a67d63a5f4e8f1cb32"}], "stats": {"total": 72, "additions": 43, "deletions": 29}, "files": [{"sha": "34f3dda7a19a75ed7e5b744d825d40fa9398f972", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/074e6d01132262c642df4bd0f8b9f714ea214909/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/074e6d01132262c642df4bd0f8b9f714ea214909/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=074e6d01132262c642df4bd0f8b9f714ea214909", "patch": "@@ -1,3 +1,8 @@\n+2004-12-12  Richard Henderson  <rth@redhat.com>\n+\n+\t* expr.c (emit_move_change_mode): New.\n+\t(emit_move_via_alt_mode): Use it.\n+\n 2004-12-12  Nathanael Nerode  <neroden@gcc.gnu.org>\n \t    John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n "}, {"sha": "fffb60d003b6bf9b0c38c295fbaa2967dd260015", "filename": "gcc/expr.c", "status": "modified", "additions": 38, "deletions": 29, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/074e6d01132262c642df4bd0f8b9f714ea214909/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/074e6d01132262c642df4bd0f8b9f714ea214909/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=074e6d01132262c642df4bd0f8b9f714ea214909", "patch": "@@ -2652,46 +2652,55 @@ read_complex_part (rtx cplx, bool imag_p)\n \t\t\t    true, NULL_RTX, imode, imode);\n }\n \f\n-/* A subroutine of emit_move_insn_1.  Generate a move from Y into X using\n-   ALT_MODE instead of the operand's natural mode, MODE.  CODE is the insn\n-   code for the move in ALT_MODE, and is known to be valid.  Returns the\n-   instruction emitted.  */\n+/* A subroutine of emit_move_via_alt_mode.  Yet another lowpart generator.\n+   NEW_MODE and OLD_MODE are the same size.  Return NULL if X cannot be\n+   represented in NEW_MODE.  */\n \n static rtx\n-emit_move_via_alt_mode (enum machine_mode alt_mode, enum machine_mode mode,\n-\t\t\tenum insn_code code, rtx x, rtx y)\n+emit_move_change_mode (enum machine_mode new_mode,\n+\t\t       enum machine_mode old_mode, rtx x)\n {\n-  /* Get X and Y in ALT_MODE.  We can't use gen_lowpart here because it\n-     may call change_address which is not appropriate if we were\n-     called when a reload was in progress.  We don't have to worry\n-     about changing the address since the size in bytes is supposed to\n-     be the same.  Copy the MEM to change the mode and move any\n-     substitutions from the old MEM to the new one.  */\n+  rtx ret;\n \n-  if (reload_in_progress)\n+  if (reload_in_progress && MEM_P (x))\n     {\n-      rtx x1 = x, y1 = y;\n+      /* We can't use gen_lowpart here because it may call change_address\n+\t which is not appropriate if we were called when a reload was in\n+\t progress.  We don't have to worry about changing the address since\n+\t the size in bytes is supposed to be the same.  Copy the MEM to\n+\t change the mode and move any substitutions from the old MEM to\n+\t the new one.  */\n \n-      x = gen_lowpart_common (alt_mode, x1);\n-      if (x == 0 && MEM_P (x1))\n-\t{\n-\t  x = adjust_address_nv (x1, alt_mode, 0);\n-\t  copy_replacements (x1, x);\n-\t}\n-\n-      y = gen_lowpart_common (alt_mode, y1);\n-      if (y == 0 && MEM_P (y1))\n-\t{\n-\t  y = adjust_address_nv (y1, alt_mode, 0);\n-\t  copy_replacements (y1, y);\n-\t}\n+      ret = adjust_address_nv (x, new_mode, 0);\n+      copy_replacements (x, ret);\n     }\n   else\n     {\n-      x = simplify_gen_subreg (alt_mode, x, mode, 0);\n-      y = simplify_gen_subreg (alt_mode, y, mode, 0);\n+      /* Note that we do want simplify_subreg's behaviour of validating\n+\t that the new mode is ok for a hard register.  If we were to use\n+\t simplify_gen_subreg, we would create the subreg, but would\n+\t probably run into the target not being able to implement it.  */\n+      ret = simplify_subreg (new_mode, x, old_mode, 0);\n     }\n \n+  return ret;\n+}\n+\n+/* A subroutine of emit_move_insn_1.  Generate a move from Y into X using\n+   ALT_MODE instead of the operand's natural mode, MODE.  CODE is the insn\n+   code for the move in ALT_MODE, and is known to be valid.  Returns the\n+   instruction emitted, or NULL if X or Y cannot be represented in ALT_MODE.  */\n+\n+static rtx\n+emit_move_via_alt_mode (enum machine_mode alt_mode, enum machine_mode mode,\n+\t\t\tenum insn_code code, rtx x, rtx y)\n+{\n+  x = emit_move_change_mode (alt_mode, mode, x);\n+  if (x == NULL_RTX)\n+    return NULL_RTX;\n+  y = emit_move_change_mode (alt_mode, mode, y);\n+  if (y == NULL_RTX)\n+    return NULL_RTX;\n   return emit_insn (GEN_FCN (code) (x, y));\n }\n "}]}