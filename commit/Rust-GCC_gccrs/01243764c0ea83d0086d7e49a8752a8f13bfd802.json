{"sha": "01243764c0ea83d0086d7e49a8752a8f13bfd802", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEyNDM3NjRjMGVhODNkMDA4NmQ3ZTQ5YTg3NTJhOGYxM2JmZDgwMg==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2018-05-24T13:06:47Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-24T13:06:47Z"}, "message": "[Ada] Wrong renaming of variant record equality\n\nFor a renaming of the equality operator of a variant record the compiler\nerroneously generates code that compares all the record component (thus\ncomputing wrong results).\n\nAfter this patch the following test provides the correct results.\n\npackage Types is\n   type Data (Bool : Boolean := False) is record\n      case Bool is\n         when False =>\n            null;\n\n         when True =>\n            Val1 : Integer range 0 .. 2 ** 23 - 1;\n            Val2 : Float;\n      end case;\n   end record;\n\n   function IsEqual (Left, Right : Data) return Boolean renames \"=\";\nend Types;\n\nwith Types;\nwith Ada.Text_IO;\nprocedure Main is\n   A : Types.Data := Types.Data'(Bool => True,\n                                 Val1 => 16#05A5A5#,\n                                 Val2 => 999999999.0);\n\n   B : Types.Data := Types.Data'(Bool => True,\n                                 Val1 => 16#0A5A5A#,\n                                 Val2 => 6666666666.0);\n   use type Types.Data;\nbegin\n   A := (Bool => False);             --  Test\n   B := (Bool => False);             --  Test\n\n   if Types.IsEqual (A, B) then      --  Test\n      Ada.Text_IO.Put_Line (\"OK\");\n   else\n      Ada.Text_IO.Put_Line (\"ERROR\");\n   end if;\nend Main;\n\nCommand: gnatmake main; ./main\n Output: OK\n\n2018-05-24  Javier Miranda  <miranda@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch8.adb (Build_Body_For_Renaming): Adding support to build the\n\tbody of a variant record equality renaming.\n\t(Expand_N_Subprogram_Renaming_Declaration): Adapt the code to the new\n\timplementation of Build_Body_For_Renaming.\n\t* exp_ch3.ads (Build_Variant_Record_Equality): New library level\n\tfunction that factorizes the functionality needed by\n\tBuild_Body_For_Renaming and Expand_Freeze_Record_Type to build the body\n\tof a variant record equality subprogram.\n\t* exp_ch3.adb (Build_Variant_Record_Equality): New subprogram.\n\t(Build_Variant_Record_Equality): New local procedure of\n\tExpand_Freeze_Record_Type containing all the code specific for freezing\n\tthe record type that cannot be place in the new library level function.\n\nFrom-SVN: r260667", "tree": {"sha": "14fea77a675cf77b7a628bcb69d4fc6986420750", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14fea77a675cf77b7a628bcb69d4fc6986420750"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01243764c0ea83d0086d7e49a8752a8f13bfd802", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01243764c0ea83d0086d7e49a8752a8f13bfd802", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01243764c0ea83d0086d7e49a8752a8f13bfd802", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01243764c0ea83d0086d7e49a8752a8f13bfd802/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7037d2bbd04f5b845b899e533a96334c0e2f653e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7037d2bbd04f5b845b899e533a96334c0e2f653e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7037d2bbd04f5b845b899e533a96334c0e2f653e"}], "stats": {"total": 297, "additions": 187, "deletions": 110}, "files": [{"sha": "fa77f2afe1f91dc526b043fd6452bb80506712ef", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01243764c0ea83d0086d7e49a8752a8f13bfd802/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01243764c0ea83d0086d7e49a8752a8f13bfd802/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=01243764c0ea83d0086d7e49a8752a8f13bfd802", "patch": "@@ -1,3 +1,18 @@\n+2018-05-24  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch8.adb (Build_Body_For_Renaming): Adding support to build the\n+\tbody of a variant record equality renaming.\n+\t(Expand_N_Subprogram_Renaming_Declaration): Adapt the code to the new\n+\timplementation of Build_Body_For_Renaming.\n+\t* exp_ch3.ads (Build_Variant_Record_Equality): New library level\n+\tfunction that factorizes the functionality needed by\n+\tBuild_Body_For_Renaming and Expand_Freeze_Record_Type to build the body\n+\tof a variant record equality subprogram.\n+\t* exp_ch3.adb (Build_Variant_Record_Equality): New subprogram.\n+\t(Build_Variant_Record_Equality): New local procedure of\n+\tExpand_Freeze_Record_Type containing all the code specific for freezing\n+\tthe record type that cannot be place in the new library level function.\n+\n 2018-05-24  Ed Schonberg  <schonberg@adacore.com>\n \n \t* einfo.ads, einfo.adb (Is_Activation_Record): New flag on"}, {"sha": "6c3f7dc53ec3e9df750a4901b1f7822e1fadd459", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 118, "deletions": 71, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01243764c0ea83d0086d7e49a8752a8f13bfd802/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01243764c0ea83d0086d7e49a8752a8f13bfd802/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=01243764c0ea83d0086d7e49a8752a8f13bfd802", "patch": "@@ -131,10 +131,6 @@ package body Exp_Ch3 is\n    --  of a record type that has user-defined primitive equality operations.\n    --  The resulting operation is a TSS subprogram.\n \n-   procedure Build_Variant_Record_Equality (Typ  : Entity_Id);\n-   --  Create An Equality function for the untagged variant record Typ and\n-   --  attach it to the TSS list\n-\n    procedure Check_Stream_Attributes (Typ : Entity_Id);\n    --  Check that if a limited extension has a parent with user-defined stream\n    --  attributes, and does not itself have user-defined stream-attributes,\n@@ -4235,7 +4231,14 @@ package body Exp_Ch3 is\n \n    --  Generates:\n \n-   --    function _Equality (X, Y : T) return Boolean is\n+   --    function <<Body_Id>> (Left, Right : T) return Boolean is\n+   --       [ X : T renames Left;  ]\n+   --       [ Y : T renames Right; ]\n+   --       --  The above renamings are generated only if the parameters of\n+   --       --  this built function (which are passed by the caller) are not\n+   --       --  named 'X' and 'Y'; these names are required to reuse several\n+   --       --  expander routines when generating this body.\n+\n    --    begin\n    --       --  Compare discriminants\n \n@@ -4266,71 +4269,45 @@ package body Exp_Ch3 is\n    --       return True;\n    --    end _Equality;\n \n-   procedure Build_Variant_Record_Equality (Typ : Entity_Id) is\n-      Loc : constant Source_Ptr := Sloc (Typ);\n-\n-      F : constant Entity_Id :=\n-            Make_Defining_Identifier (Loc,\n-              Chars => Make_TSS_Name (Typ, TSS_Composite_Equality));\n-\n-      X : constant Entity_Id := Make_Defining_Identifier (Loc, Name_X);\n-      Y : constant Entity_Id := Make_Defining_Identifier (Loc, Name_Y);\n-\n-      Def    : constant Node_Id := Parent (Typ);\n-      Comps  : constant Node_Id := Component_List (Type_Definition (Def));\n-      Stmts  : constant List_Id := New_List;\n-      Pspecs : constant List_Id := New_List;\n+   function Build_Variant_Record_Equality\n+     (Typ         : Entity_Id;\n+      Body_Id     : Entity_Id;\n+      Param_Specs : List_Id) return Node_Id\n+   is\n+      Loc       : constant Source_Ptr := Sloc (Typ);\n+      Def       : constant Node_Id := Parent (Typ);\n+      Comps     : constant Node_Id := Component_List (Type_Definition (Def));\n+      Left      : constant Entity_Id := Defining_Identifier\n+                                          (First (Param_Specs));\n+      Right     : constant Entity_Id := Defining_Identifier\n+                                          (Next (First (Param_Specs)));\n+      Decls     : constant List_Id := New_List;\n+      Stmts     : constant List_Id := New_List;\n+      Subp_Body : Node_Id;\n \n    begin\n-      --  If we have a variant record with restriction No_Implicit_Conditionals\n-      --  in effect, then we skip building the procedure. This is safe because\n-      --  if we can see the restriction, so can any caller, calls to equality\n-      --  test routines are not allowed for variant records if this restriction\n-      --  is active.\n-\n-      if Restriction_Active (No_Implicit_Conditionals) then\n-         return;\n+      pragma Assert (not Is_Tagged_Type (Typ));\n+\n+      --  In order to reuse the expander routines Make_Eq_If and Make_Eq_Case\n+      --  the name of the formals must be X and Y; otherwise we generate two\n+      --  renaming declarations for such purpose.\n+\n+      if Chars (Left) /= Name_X then\n+         Append_To (Decls,\n+           Make_Object_Renaming_Declaration (Loc,\n+             Defining_Identifier => Make_Defining_Identifier (Loc, Name_X),\n+             Subtype_Mark        => New_Occurrence_Of (Typ, Loc),\n+             Name                => Make_Identifier (Loc, Chars (Left))));\n       end if;\n \n-      --  Derived Unchecked_Union types no longer inherit the equality function\n-      --  of their parent.\n-\n-      if Is_Derived_Type (Typ)\n-        and then not Is_Unchecked_Union (Typ)\n-        and then not Has_New_Non_Standard_Rep (Typ)\n-      then\n-         declare\n-            Parent_Eq : constant Entity_Id :=\n-                          TSS (Root_Type (Typ), TSS_Composite_Equality);\n-         begin\n-            if Present (Parent_Eq) then\n-               Copy_TSS (Parent_Eq, Typ);\n-               return;\n-            end if;\n-         end;\n+      if Chars (Right) /= Name_Y then\n+         Append_To (Decls,\n+           Make_Object_Renaming_Declaration (Loc,\n+             Defining_Identifier => Make_Defining_Identifier (Loc, Name_Y),\n+             Subtype_Mark        => New_Occurrence_Of (Typ, Loc),\n+             Name                => Make_Identifier (Loc, Chars (Right))));\n       end if;\n \n-      Discard_Node (\n-        Make_Subprogram_Body (Loc,\n-          Specification =>\n-            Make_Function_Specification (Loc,\n-              Defining_Unit_Name       => F,\n-              Parameter_Specifications => Pspecs,\n-              Result_Definition => New_Occurrence_Of (Standard_Boolean, Loc)),\n-          Declarations               => New_List,\n-          Handled_Statement_Sequence =>\n-            Make_Handled_Sequence_Of_Statements (Loc, Statements => Stmts)));\n-\n-      Append_To (Pspecs,\n-        Make_Parameter_Specification (Loc,\n-          Defining_Identifier => X,\n-          Parameter_Type      => New_Occurrence_Of (Typ, Loc)));\n-\n-      Append_To (Pspecs,\n-        Make_Parameter_Specification (Loc,\n-          Defining_Identifier => Y,\n-          Parameter_Type      => New_Occurrence_Of (Typ, Loc)));\n-\n       --  Unchecked_Unions require additional machinery to support equality.\n       --  Two extra parameters (A and B) are added to the equality function\n       --  parameter list for each discriminant of the type, in order to\n@@ -4359,13 +4336,13 @@ package body Exp_Ch3 is\n \n                --  Add new parameters to the parameter list\n \n-               Append_To (Pspecs,\n+               Append_To (Param_Specs,\n                  Make_Parameter_Specification (Loc,\n                    Defining_Identifier => A,\n                    Parameter_Type      =>\n                      New_Occurrence_Of (Discr_Type, Loc)));\n \n-               Append_To (Pspecs,\n+               Append_To (Param_Specs,\n                  Make_Parameter_Specification (Loc,\n                    Defining_Identifier => B,\n                    Parameter_Type      =>\n@@ -4413,12 +4390,20 @@ package body Exp_Ch3 is\n         Make_Simple_Return_Statement (Loc,\n           Expression => New_Occurrence_Of (Standard_True, Loc)));\n \n-      Set_TSS (Typ, F);\n-      Set_Is_Pure (F);\n+      Subp_Body :=\n+        Make_Subprogram_Body (Loc,\n+          Specification =>\n+            Make_Function_Specification (Loc,\n+              Defining_Unit_Name       => Body_Id,\n+              Parameter_Specifications => Param_Specs,\n+              Result_Definition        =>\n+                New_Occurrence_Of (Standard_Boolean, Loc)),\n+          Declarations               => Decls,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => Stmts));\n \n-      if not Debug_Generated_Code then\n-         Set_Debug_Info_Off (F);\n-      end if;\n+      return Subp_Body;\n    end Build_Variant_Record_Equality;\n \n    -----------------------------\n@@ -4963,6 +4948,68 @@ package body Exp_Ch3 is\n    -------------------------------\n \n    procedure Expand_Freeze_Record_Type (N : Node_Id) is\n+      procedure Build_Variant_Record_Equality (Typ  : Entity_Id);\n+      --  Create An Equality function for the untagged variant record Typ and\n+      --  attach it to the TSS list.\n+\n+      procedure Build_Variant_Record_Equality (Typ : Entity_Id) is\n+         Loc : constant Source_Ptr := Sloc (Typ);\n+         F   : constant Entity_Id :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => Make_TSS_Name (Typ, TSS_Composite_Equality));\n+      begin\n+         --  For a variant record with restriction No_Implicit_Conditionals\n+         --  in effect we skip building the procedure. This is safe because\n+         --  if we can see the restriction, so can any caller, and calls to\n+         --  equality test routines are not allowed for variant records if\n+         --  this restriction is active.\n+\n+         if Restriction_Active (No_Implicit_Conditionals) then\n+            return;\n+         end if;\n+\n+         --  Derived Unchecked_Union types no longer inherit the equality\n+         --  function of their parent.\n+\n+         if Is_Derived_Type (Typ)\n+           and then not Is_Unchecked_Union (Typ)\n+           and then not Has_New_Non_Standard_Rep (Typ)\n+         then\n+            declare\n+               Parent_Eq : constant Entity_Id :=\n+                             TSS (Root_Type (Typ), TSS_Composite_Equality);\n+            begin\n+               if Present (Parent_Eq) then\n+                  Copy_TSS (Parent_Eq, Typ);\n+                  return;\n+               end if;\n+            end;\n+         end if;\n+\n+         Discard_Node (\n+           Build_Variant_Record_Equality\n+             (Typ         => Typ,\n+              Body_Id     => F,\n+              Param_Specs => New_List (\n+                Make_Parameter_Specification (Loc,\n+                  Defining_Identifier => Make_Defining_Identifier (Loc,\n+                                           Name_X),\n+                  Parameter_Type      => New_Occurrence_Of (Typ, Loc)),\n+                Make_Parameter_Specification (Loc,\n+                  Defining_Identifier => Make_Defining_Identifier (Loc,\n+                                           Name_Y),\n+                  Parameter_Type      => New_Occurrence_Of (Typ, Loc)))));\n+\n+         Set_TSS (Typ, F);\n+         Set_Is_Pure (F);\n+\n+         if not Debug_Generated_Code then\n+            Set_Debug_Info_Off (F);\n+         end if;\n+      end Build_Variant_Record_Equality;\n+\n+      --  Local variables\n+\n       Typ      : constant Node_Id := Entity (N);\n       Typ_Decl : constant Node_Id := Parent (Typ);\n "}, {"sha": "9d2d5d933d08080611c4dce295e82174b8c2faf4", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01243764c0ea83d0086d7e49a8752a8f13bfd802/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01243764c0ea83d0086d7e49a8752a8f13bfd802/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=01243764c0ea83d0086d7e49a8752a8f13bfd802", "patch": "@@ -84,6 +84,13 @@ package Exp_Ch3 is\n    --  Constructor_Ref is a call to a constructor subprogram. It is currently\n    --  used only to support C++ constructors.\n \n+   function Build_Variant_Record_Equality\n+     (Typ         : Entity_Id;\n+      Body_Id     : Entity_Id;\n+      Param_Specs : List_Id) return Node_Id;\n+   --  Build the body of the equality function Body_Id for the untagged variant\n+   --  record Typ with the given parameters specification list.\n+\n    function Freeze_Type (N : Node_Id) return Boolean;\n    --  This function executes the freezing actions associated with the given\n    --  freeze type node N and returns True if the node is to be deleted. We"}, {"sha": "e2ffb91775fcc43358fa081edef0ea12fd74dff7", "filename": "gcc/ada/exp_ch8.adb", "status": "modified", "additions": 47, "deletions": 39, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01243764c0ea83d0086d7e49a8752a8f13bfd802/gcc%2Fada%2Fexp_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01243764c0ea83d0086d7e49a8752a8f13bfd802/gcc%2Fada%2Fexp_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch8.adb?ref=01243764c0ea83d0086d7e49a8752a8f13bfd802", "patch": "@@ -25,6 +25,7 @@\n \n with Atree;    use Atree;\n with Einfo;    use Einfo;\n+with Exp_Ch3;  use Exp_Ch3;\n with Exp_Ch4;  use Exp_Ch4;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Dbug; use Exp_Dbug;\n@@ -35,6 +36,7 @@ with Nmake;    use Nmake;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n with Sem;      use Sem;\n+with Sem_Aux;  use Sem_Aux;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n@@ -260,15 +262,17 @@ package body Exp_Ch8 is\n       Loc : constant Source_Ptr := Sloc (N);\n       Id  : constant Entity_Id  := Defining_Entity (N);\n \n-      function Build_Body_For_Renaming return Node_Id;\n+      function Build_Body_For_Renaming (Typ : Entity_Id) return Node_Id;\n       --  Build and return the body for the renaming declaration of an equality\n-      --  or inequality operator.\n+      --  or inequality operator of type Typ.\n \n       -----------------------------\n       -- Build_Body_For_Renaming --\n       -----------------------------\n \n-      function Build_Body_For_Renaming return Node_Id is\n+      function Build_Body_For_Renaming (Typ : Entity_Id) return Node_Id is\n+         Left    : constant Entity_Id := First_Formal (Id);\n+         Right   : constant Entity_Id := Next_Formal (Left);\n          Body_Id : Entity_Id;\n          Decl    : Node_Id;\n \n@@ -283,16 +287,44 @@ package body Exp_Ch8 is\n          Body_Id := Make_Defining_Identifier (Sloc (N), Chars (Id));\n          Set_Debug_Info_Needed (Body_Id);\n \n-         Decl :=\n-           Make_Subprogram_Body (Loc,\n-             Specification              =>\n-               Make_Function_Specification (Loc,\n-                 Defining_Unit_Name       => Body_Id,\n-                 Parameter_Specifications => Copy_Parameter_List (Id),\n-                 Result_Definition        =>\n-                   New_Occurrence_Of (Standard_Boolean, Loc)),\n-             Declarations               => Empty_List,\n-             Handled_Statement_Sequence => Empty);\n+         if Has_Variant_Part (Typ) then\n+            Decl :=\n+              Build_Variant_Record_Equality\n+                (Typ         => Typ,\n+                 Body_Id     => Body_Id,\n+                 Param_Specs => Copy_Parameter_List (Id));\n+\n+         --  Build body for renamed equality, to capture its current\n+         --  meaning. It may be redefined later, but the renaming is\n+         --  elaborated where it occurs. This is technically known as\n+         --  Squirreling semantics. Renaming is rewritten as a subprogram\n+         --  declaration, and the generated  body is inserted into the\n+         --  freeze actions for the subprogram.\n+\n+         else\n+            Decl :=\n+              Make_Subprogram_Body (Loc,\n+                Specification              =>\n+                  Make_Function_Specification (Loc,\n+                    Defining_Unit_Name       => Body_Id,\n+                    Parameter_Specifications => Copy_Parameter_List (Id),\n+                    Result_Definition        =>\n+                      New_Occurrence_Of (Standard_Boolean, Loc)),\n+                Declarations               => Empty_List,\n+                Handled_Statement_Sequence => Empty);\n+\n+            Set_Handled_Statement_Sequence (Decl,\n+              Make_Handled_Sequence_Of_Statements (Loc,\n+                Statements => New_List (\n+                  Make_Simple_Return_Statement (Loc,\n+                    Expression =>\n+                      Expand_Record_Equality\n+                        (Id,\n+                         Typ    => Typ,\n+                         Lhs    => Make_Identifier (Loc, Chars (Left)),\n+                         Rhs    => Make_Identifier (Loc, Chars (Right)),\n+                         Bodies => Declarations (Decl))))));\n+         end if;\n \n          return Decl;\n       end Build_Body_For_Renaming;\n@@ -328,10 +360,7 @@ package body Exp_Ch8 is\n         and then Scope (Entity (Nam)) = Standard_Standard\n       then\n          declare\n-            Left  : constant Entity_Id := First_Formal (Id);\n-            Right : constant Entity_Id := Next_Formal (Left);\n-            Typ   : constant Entity_Id := Etype (Left);\n-            Decl  : Node_Id;\n+            Typ  : constant Entity_Id := Etype (First_Formal (Id));\n \n          begin\n             --  Check whether this is a renaming of a predefined equality on an\n@@ -342,28 +371,7 @@ package body Exp_Ch8 is\n               and then not Is_Tagged_Type (Typ)\n               and then not Is_Frozen (Typ)\n             then\n-               --  Build body for renamed equality, to capture its current\n-               --  meaning. It may be redefined later, but the renaming is\n-               --  elaborated where it occurs. This is technically known as\n-               --  Squirreling semantics. Renaming is rewritten as a subprogram\n-               --  declaration, and the generated  body is inserted into the\n-               --  freeze actions for the subprogram.\n-\n-               Decl := Build_Body_For_Renaming;\n-\n-               Set_Handled_Statement_Sequence (Decl,\n-                 Make_Handled_Sequence_Of_Statements (Loc,\n-                   Statements => New_List (\n-                     Make_Simple_Return_Statement (Loc,\n-                       Expression =>\n-                         Expand_Record_Equality\n-                           (Id,\n-                            Typ    => Typ,\n-                            Lhs    => Make_Identifier (Loc, Chars (Left)),\n-                            Rhs    => Make_Identifier (Loc, Chars (Right)),\n-                            Bodies => Declarations (Decl))))));\n-\n-               Append_Freeze_Action (Id, Decl);\n+               Append_Freeze_Action (Id, Build_Body_For_Renaming (Typ));\n             end if;\n          end;\n       end if;"}]}