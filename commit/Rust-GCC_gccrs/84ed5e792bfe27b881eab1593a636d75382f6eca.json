{"sha": "84ed5e792bfe27b881eab1593a636d75382f6eca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRlZDVlNzkyYmZlMjdiODgxZWFiMTU5M2E2MzZkNzUzODJmNmVjYQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1996-02-27T13:15:13Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1996-02-27T13:15:13Z"}, "message": "arm.c (aof_text_section): Remove pseudo read-only hack.\n\n* arm.c (aof_text_section): Remove pseudo read-only hack.  Doesn't\ntake a parameter any more.\n(arm_current_cc): Now an enum.\n(ARM_INVERSE_CONDITION_CODE): Moved to arm.h\n(revsersible_cc_register): Delete.\n(dominant_cc_register): New function.\n(select_dominance_cc_mode): New function.\n(arm_select_cc_mode): New function.\n(output_return_instruction): New parameter REVERSE, used to\nreverse the condition of a conditional return.  All callers\nchanged.\n(arm_print_operand case 'D'): Only suppress condition printing\nif the operand is a NULL pointer.\n(get_arm_condition_code): Now a static function returning\nenum arm_cond_code.  Handle dominance expressions.  Return enum\nvalues rather than integers.\n({load,store}_multiple_sequence): New functions.\n(emit_{ldm,stm}_seq): New functions.\n\nFrom-SVN: r11351", "tree": {"sha": "436500d99738c7a850eb0279918eb1a931846f32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/436500d99738c7a850eb0279918eb1a931846f32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84ed5e792bfe27b881eab1593a636d75382f6eca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84ed5e792bfe27b881eab1593a636d75382f6eca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84ed5e792bfe27b881eab1593a636d75382f6eca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84ed5e792bfe27b881eab1593a636d75382f6eca/comments", "author": null, "committer": null, "parents": [{"sha": "89c7ca526df13eeae5b07901ca96b6c08b94b785", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89c7ca526df13eeae5b07901ca96b6c08b94b785", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89c7ca526df13eeae5b07901ca96b6c08b94b785"}], "stats": {"total": 697, "additions": 649, "deletions": 48}, "files": [{"sha": "3b4a06ace1f848963965db0812a7ab435c3db1d2", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 649, "deletions": 48, "changes": 697, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84ed5e792bfe27b881eab1593a636d75382f6eca/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84ed5e792bfe27b881eab1593a636d75382f6eca/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=84ed5e792bfe27b881eab1593a636d75382f6eca", "patch": "@@ -1,5 +1,5 @@\n /* Output routines for GCC for ARM/RISCiX.\n-   Copyright (C) 1991, 1993, 1994, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n    Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n    \t      and Martin Simmons (@harleqn.co.uk).\n    More major hacks by Richard Earnshaw (rwe11@cl.cam.ac.uk)\n@@ -114,7 +114,7 @@ static int arm_constant_limit = 3;\n \n /* For an explanation of these variables, see final_prescan_insn below.  */\n int arm_ccfsm_state;\n-int arm_current_cc;\n+enum arm_cond_code arm_current_cc;\n rtx arm_target_insn;\n int arm_target_label;\n \n@@ -125,7 +125,7 @@ char *arm_condition_codes[] =\n   \"hi\", \"ls\", \"ge\", \"lt\", \"gt\", \"le\", \"al\", \"nv\"\n };\n \n-#define ARM_INVERSE_CONDITION_CODE(X)  ((X) ^ 1)\n+static enum arm_cond_code get_arm_condition_code ();\n \n \f\n /* Initialization code */\n@@ -1657,24 +1657,28 @@ cc_register (x, mode)\n }\n \n /* Return TRUE if this is the condition code register, if we aren't given\n-   a mode, accept any mode in class CC_MODE that is reversible */\n+   a mode, accept any class CCmode register which indicates a dominance\n+   expression.  */\n \n int\n-reversible_cc_register (x, mode)\n+dominant_cc_register (x, mode)\n      rtx x;\n      enum machine_mode mode;\n {\n   if (mode == VOIDmode)\n     {\n       mode = GET_MODE (x);\n-      if (GET_MODE_CLASS (mode) != MODE_CC\n-\t  && GET_CODE (x) == REG && REGNO (x) == 24)\n-\tabort ();\n-      if (GET_MODE_CLASS (mode) != MODE_CC\n-\t  || (! flag_fast_math && ! REVERSIBLE_CC_MODE (mode)))\n+      if (GET_MODE_CLASS (mode) != MODE_CC)\n \treturn FALSE;\n     }\n \n+  if (mode != CC_DNEmode && mode != CC_DEQmode\n+      && mode != CC_DLEmode && mode != CC_DLTmode\n+      && mode != CC_DGEmode && mode != CC_DGTmode\n+      && mode != CC_DLEUmode && mode != CC_DLTUmode\n+      && mode != CC_DGEUmode && mode != CC_DGTUmode)\n+    return FALSE;\n+\n   if (mode == GET_MODE (x) && GET_CODE (x) == REG && REGNO (x) == 24)\n     return TRUE;\n \n@@ -1930,6 +1934,384 @@ store_multiple_operation (op, mode)\n   return 1;\n }\n \n+int\n+load_multiple_sequence (operands, nops, regs, base, load_offset)\n+     rtx *operands;\n+     int nops;\n+     int *regs;\n+     int *base;\n+     HOST_WIDE_INT *load_offset;\n+{\n+  int unsorted_regs[4];\n+  HOST_WIDE_INT unsorted_offsets[4];\n+  int order[4];\n+  int base_reg;\n+  int i;\n+\n+  /* Can only handle 2, 3, or 4 insns at present, though could be easily\n+     extended if required.  */\n+  if (nops < 2 || nops > 4)\n+    abort ();\n+\n+  /* Loop over the operands and check that the memory references are\n+     suitable (ie immediate offsets from the same base register).  At\n+     the same time, extract the target register, and the memory\n+     offsets.  */\n+  for (i = 0; i < nops; i++)\n+    {\n+      rtx reg;\n+      rtx offset;\n+\n+      if (GET_CODE (operands[nops + i]) != MEM)\n+\tabort ();\n+\n+      /* Don't reorder volatile memory references; it doesn't seem worth\n+\t looking for the case where the order is ok anyway.  */\n+      if (MEM_VOLATILE_P (operands[nops + i]))\n+\treturn 0;\n+\n+      offset = const0_rtx;\n+\n+      if ((GET_CODE (reg = XEXP (operands[nops + i], 0)) == REG\n+\t   || (GET_CODE (reg) == SUBREG\n+\t       && GET_CODE (reg = SUBREG_REG (reg)) == REG))\n+\t  || (GET_CODE (XEXP (operands[nops + i], 0)) == PLUS\n+\t      && ((GET_CODE (reg = XEXP (XEXP (operands[nops + i], 0), 0))\n+\t\t   == REG)\n+\t\t  || (GET_CODE (reg) == SUBREG\n+\t\t      && GET_CODE (reg = SUBREG_REG (reg)) == REG))\n+\t      && (GET_CODE (offset = XEXP (XEXP (operands[nops + i], 0), 1))\n+\t\t  == CONST_INT)))\n+\t{\n+\t  if (i == 0)\n+\t    {\n+\t      base_reg = REGNO(reg);\n+\t      unsorted_regs[0] = (GET_CODE (operands[i]) == REG\n+\t\t\t\t  ? REGNO (operands[i])\n+\t\t\t\t  : REGNO (SUBREG_REG (operands[i])));\n+\t      order[0] = 0;\n+\t    }\n+\t  else \n+\t    {\n+\t      if (base_reg != REGNO (reg))\n+\t\t/* Not addressed from the same base register.  */\n+\t\treturn 0;\n+\n+\t      unsorted_regs[i] = (GET_CODE (operands[i]) == REG\n+\t\t\t\t  ? REGNO (operands[i])\n+\t\t\t\t  : REGNO (SUBREG_REG (operands[i])));\n+\t      if (unsorted_regs[i] < unsorted_regs[order[0]])\n+\t\torder[0] = i;\n+\t    }\n+\n+\t  /* If it isn't an integer register, or if it overwrites the\n+\t     base register but isn't the last insn in the list, then\n+\t     we can't do this.  */\n+\t  if (unsorted_regs[i] < 0 || unsorted_regs[i] > 14\n+\t      || (i != nops - 1 && unsorted_regs[i] == base_reg))\n+\t    return 0;\n+\n+\t  unsorted_offsets[i] = INTVAL (offset);\n+\t}\n+      else\n+\t/* Not a suitable memory address.  */\n+\treturn 0;\n+    }\n+\n+  /* All the useful information has now been extracted from the\n+     operands into unsorted_regs and unsorted_offsets; additionally,\n+     order[0] has been set to the lowest numbered register in the\n+     list.  Sort the registers into order, and check that the memory\n+     offsets are ascending and adjacent.  */\n+\n+  for (i = 1; i < nops; i++)\n+    {\n+      int j;\n+\n+      order[i] = order[i - 1];\n+      for (j = 0; j < nops; j++)\n+\tif (unsorted_regs[j] > unsorted_regs[order[i - 1]]\n+\t    && (order[i] == order[i - 1]\n+\t\t|| unsorted_regs[j] < unsorted_regs[order[i]]))\n+\t  order[i] = j;\n+\n+      /* Have we found a suitable register? if not, one must be used more\n+\t than once.  */\n+      if (order[i] == order[i - 1])\n+\treturn 0;\n+\n+      /* Is the memory address adjacent and ascending? */\n+      if (unsorted_offsets[order[i]] != unsorted_offsets[order[i - 1]] + 4)\n+\treturn 0;\n+    }\n+\n+  if (base)\n+    {\n+      *base = base_reg;\n+\n+      for (i = 0; i < nops; i++)\n+\tregs[i] = unsorted_regs[order[i]];\n+\n+      *load_offset = unsorted_offsets[order[0]];\n+    }\n+\n+  if (unsorted_offsets[order[0]] == 0)\n+    return 1; /* ldmia */\n+\n+  if (unsorted_offsets[order[0]] == 4)\n+    return 2; /* ldmib */\n+\n+  if (unsorted_offsets[order[nops - 1]] == 0)\n+    return 3; /* ldmda */\n+\n+  if (unsorted_offsets[order[nops - 1]] == -4)\n+    return 4; /* ldmdb */\n+\n+  /* Can't do it without setting up the offset, only do this if it takes\n+     no more than one insn.  */\n+  return (const_ok_for_arm (unsorted_offsets[order[0]]) \n+\t  || const_ok_for_arm (-unsorted_offsets[order[0]])) ? 5 : 0;\n+}\n+\n+char *\n+emit_ldm_seq (operands, nops)\n+     rtx *operands;\n+     int nops;\n+{\n+  int regs[4];\n+  int base_reg;\n+  HOST_WIDE_INT offset;\n+  char buf[100];\n+  int i;\n+\n+  switch (load_multiple_sequence (operands, nops, regs, &base_reg, &offset))\n+    {\n+    case 1:\n+      strcpy (buf, \"ldm%?ia\\t\");\n+      break;\n+\n+    case 2:\n+      strcpy (buf, \"ldm%?ib\\t\");\n+      break;\n+\n+    case 3:\n+      strcpy (buf, \"ldm%?da\\t\");\n+      break;\n+\n+    case 4:\n+      strcpy (buf, \"ldm%?db\\t\");\n+      break;\n+\n+    case 5:\n+      if (offset >= 0)\n+\tsprintf (buf, \"add%%?\\t%s%s, %s%s, #%ld\", REGISTER_PREFIX,\n+\t\t reg_names[regs[0]], REGISTER_PREFIX, reg_names[base_reg],\n+\t\t (long) offset);\n+      else\n+\tsprintf (buf, \"sub%%?\\t%s%s, %s%s, #%ld\", REGISTER_PREFIX,\n+\t\t reg_names[regs[0]], REGISTER_PREFIX, reg_names[base_reg],\n+\t\t (long) -offset);\n+      output_asm_insn (buf, operands);\n+      base_reg = regs[0];\n+      strcpy (buf, \"ldm%?ia\\t\");\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  sprintf (buf + strlen (buf), \"%s%s, {%s%s\", REGISTER_PREFIX, \n+\t   reg_names[base_reg], REGISTER_PREFIX, reg_names[regs[0]]);\n+\n+  for (i = 1; i < nops; i++)\n+    sprintf (buf + strlen (buf), \", %s%s\", REGISTER_PREFIX,\n+\t     reg_names[regs[i]]);\n+\n+  strcat (buf, \"}\\t%@ phole ldm\");\n+\n+  output_asm_insn (buf, operands);\n+  return \"\";\n+}\n+\n+int\n+store_multiple_sequence (operands, nops, regs, base, load_offset)\n+     rtx *operands;\n+     int nops;\n+     int *regs;\n+     int *base;\n+     HOST_WIDE_INT *load_offset;\n+{\n+  int unsorted_regs[4];\n+  HOST_WIDE_INT unsorted_offsets[4];\n+  int order[4];\n+  int base_reg;\n+  int i;\n+\n+  /* Can only handle 2, 3, or 4 insns at present, though could be easily\n+     extended if required.  */\n+  if (nops < 2 || nops > 4)\n+    abort ();\n+\n+  /* Loop over the operands and check that the memory references are\n+     suitable (ie immediate offsets from the same base register).  At\n+     the same time, extract the target register, and the memory\n+     offsets.  */\n+  for (i = 0; i < nops; i++)\n+    {\n+      rtx reg;\n+      rtx offset;\n+\n+      if (GET_CODE (operands[nops + i]) != MEM)\n+\tabort ();\n+\n+      /* Don't reorder volatile memory references; it doesn't seem worth\n+\t looking for the case where the order is ok anyway.  */\n+      if (MEM_VOLATILE_P (operands[nops + i]))\n+\treturn 0;\n+\n+      offset = const0_rtx;\n+\n+      if ((GET_CODE (reg = XEXP (operands[nops + i], 0)) == REG\n+\t   || (GET_CODE (reg) == SUBREG\n+\t       && GET_CODE (reg = SUBREG_REG (reg)) == REG))\n+\t  || (GET_CODE (XEXP (operands[nops + i], 0)) == PLUS\n+\t      && ((GET_CODE (reg = XEXP (XEXP (operands[nops + i], 0), 0))\n+\t\t   == REG)\n+\t\t  || (GET_CODE (reg) == SUBREG\n+\t\t      && GET_CODE (reg = SUBREG_REG (reg)) == REG))\n+\t      && (GET_CODE (offset = XEXP (XEXP (operands[nops + i], 0), 1))\n+\t\t  == CONST_INT)))\n+\t{\n+\t  if (i == 0)\n+\t    {\n+\t      base_reg = REGNO(reg);\n+\t      unsorted_regs[0] = (GET_CODE (operands[i]) == REG\n+\t\t\t\t  ? REGNO (operands[i])\n+\t\t\t\t  : REGNO (SUBREG_REG (operands[i])));\n+\t      order[0] = 0;\n+\t    }\n+\t  else \n+\t    {\n+\t      if (base_reg != REGNO (reg))\n+\t\t/* Not addressed from the same base register.  */\n+\t\treturn 0;\n+\n+\t      unsorted_regs[i] = (GET_CODE (operands[i]) == REG\n+\t\t\t\t  ? REGNO (operands[i])\n+\t\t\t\t  : REGNO (SUBREG_REG (operands[i])));\n+\t      if (unsorted_regs[i] < unsorted_regs[order[0]])\n+\t\torder[0] = i;\n+\t    }\n+\n+\t  /* If it isn't an integer register, then we can't do this.  */\n+\t  if (unsorted_regs[i] < 0 || unsorted_regs[i] > 14)\n+\t    return 0;\n+\n+\t  unsorted_offsets[i] = INTVAL (offset);\n+\t}\n+      else\n+\t/* Not a suitable memory address.  */\n+\treturn 0;\n+    }\n+\n+  /* All the useful information has now been extracted from the\n+     operands into unsorted_regs and unsorted_offsets; additionally,\n+     order[0] has been set to the lowest numbered register in the\n+     list.  Sort the registers into order, and check that the memory\n+     offsets are ascending and adjacent.  */\n+\n+  for (i = 1; i < nops; i++)\n+    {\n+      int j;\n+\n+      order[i] = order[i - 1];\n+      for (j = 0; j < nops; j++)\n+\tif (unsorted_regs[j] > unsorted_regs[order[i - 1]]\n+\t    && (order[i] == order[i - 1]\n+\t\t|| unsorted_regs[j] < unsorted_regs[order[i]]))\n+\t  order[i] = j;\n+\n+      /* Have we found a suitable register? if not, one must be used more\n+\t than once.  */\n+      if (order[i] == order[i - 1])\n+\treturn 0;\n+\n+      /* Is the memory address adjacent and ascending? */\n+      if (unsorted_offsets[order[i]] != unsorted_offsets[order[i - 1]] + 4)\n+\treturn 0;\n+    }\n+\n+  if (base)\n+    {\n+      *base = base_reg;\n+\n+      for (i = 0; i < nops; i++)\n+\tregs[i] = unsorted_regs[order[i]];\n+\n+      *load_offset = unsorted_offsets[order[0]];\n+    }\n+\n+  if (unsorted_offsets[order[0]] == 0)\n+    return 1; /* stmia */\n+\n+  if (unsorted_offsets[order[0]] == 4)\n+    return 2; /* stmib */\n+\n+  if (unsorted_offsets[order[nops - 1]] == 0)\n+    return 3; /* stmda */\n+\n+  if (unsorted_offsets[order[nops - 1]] == -4)\n+    return 4; /* stmdb */\n+\n+  return 0;\n+}\n+\n+char *\n+emit_stm_seq (operands, nops)\n+     rtx *operands;\n+     int nops;\n+{\n+  int regs[4];\n+  int base_reg;\n+  HOST_WIDE_INT offset;\n+  char buf[100];\n+  int i;\n+\n+  switch (store_multiple_sequence (operands, nops, regs, &base_reg, &offset))\n+    {\n+    case 1:\n+      strcpy (buf, \"stm%?ia\\t\");\n+      break;\n+\n+    case 2:\n+      strcpy (buf, \"stm%?ib\\t\");\n+      break;\n+\n+    case 3:\n+      strcpy (buf, \"stm%?da\\t\");\n+      break;\n+\n+    case 4:\n+      strcpy (buf, \"stm%?db\\t\");\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  sprintf (buf + strlen (buf), \"%s%s, {%s%s\", REGISTER_PREFIX, \n+\t   reg_names[base_reg], REGISTER_PREFIX, reg_names[regs[0]]);\n+\n+  for (i = 1; i < nops; i++)\n+    sprintf (buf + strlen (buf), \", %s%s\", REGISTER_PREFIX,\n+\t     reg_names[regs[i]]);\n+\n+  strcat (buf, \"}\\t%@ phole stm\");\n+\n+  output_asm_insn (buf, operands);\n+  return \"\";\n+}\n+\n int\n multi_register_push (op, mode)\n      rtx op;\n@@ -2183,6 +2565,183 @@ gen_rotated_half_load (memref)\n   return gen_rtx (ROTATE, SImode, base, GEN_INT (16));\n }\n \n+static enum machine_mode\n+select_dominance_cc_mode (op, x, y, cond_or)\n+     enum rtx_code op;\n+     rtx x;\n+     rtx y;\n+     HOST_WIDE_INT cond_or;\n+{\n+  enum rtx_code cond1, cond2;\n+  int swapped = 0;\n+\n+  /* Currently we will probably get the wrong result if the individual\n+     comparisons are not simple.  This also ensures that it is safe to\n+     reverse a comparions if necessary.  */\n+  if ((arm_select_cc_mode (cond1 = GET_CODE (x), XEXP (x, 0), XEXP (x, 1))\n+       != CCmode)\n+      || (arm_select_cc_mode (cond2 = GET_CODE (y), XEXP (y, 0), XEXP (y, 1))\n+\t  != CCmode))\n+    return CCmode;\n+\n+  if (cond_or)\n+    cond1 = reverse_condition (cond1);\n+\n+  /* If the comparisons are not equal, and one doesn't dominate the other,\n+     then we can't do this.  */\n+  if (cond1 != cond2 \n+      && ! comparison_dominates_p (cond1, cond2)\n+      && (swapped = 1, ! comparison_dominates_p (cond2, cond1)))\n+    return CCmode;\n+\n+  if (swapped)\n+    {\n+      enum rtx_code temp = cond1;\n+      cond1 = cond2;\n+      cond2 = temp;\n+    }\n+\n+  switch (cond1)\n+    {\n+    case EQ:\n+      if (cond2 == EQ || ! cond_or)\n+\treturn CC_DEQmode;\n+\n+      switch (cond2)\n+\t{\n+\tcase LE: return CC_DLEmode;\n+\tcase LEU: return CC_DLEUmode;\n+\tcase GE: return CC_DGEmode;\n+\tcase GEU: return CC_DGEUmode;\n+\t}\n+\n+      break;\n+\n+    case LT:\n+      if (cond2 == LT || ! cond_or)\n+\treturn CC_DLTmode;\n+      if (cond2 == LE)\n+\treturn CC_DLEmode;\n+      if (cond2 == NE)\n+\treturn CC_DNEmode;\n+      break;\n+\n+    case GT:\n+      if (cond2 == GT || ! cond_or)\n+\treturn CC_DGTmode;\n+      if (cond2 == GE)\n+\treturn CC_DGEmode;\n+      if (cond2 == NE)\n+\treturn CC_DNEmode;\n+      break;\n+      \n+    case LTU:\n+      if (cond2 == LTU || ! cond_or)\n+\treturn CC_DLTUmode;\n+      if (cond2 == LEU)\n+\treturn CC_DLEUmode;\n+      if (cond2 == NE)\n+\treturn CC_DNEmode;\n+      break;\n+\n+    case GTU:\n+      if (cond2 == GTU || ! cond_or)\n+\treturn CC_DGTUmode;\n+      if (cond2 == GEU)\n+\treturn CC_DGEUmode;\n+      if (cond2 == NE)\n+\treturn CC_DNEmode;\n+      break;\n+\n+    /* The remaining cases only occur when both comparisons are the\n+       same.  */\n+    case NE:\n+      return CC_DNEmode;\n+\n+    case LE:\n+      return CC_DLEmode;\n+\n+    case GE:\n+      return CC_DGEmode;\n+\n+    case LEU:\n+      return CC_DLEUmode;\n+\n+    case GEU:\n+      return CC_DGEUmode;\n+    }\n+\n+  abort ();\n+}\n+\n+enum machine_mode\n+arm_select_cc_mode (op, x, y)\n+     enum rtx_code op;\n+     rtx x;\n+     rtx y;\n+{\n+  /* All floating point compares return CCFP if it is an equality\n+     comparison, and CCFPE otherwise.  */\n+  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+    return (op == EQ || op == NE) ? CCFPmode : CCFPEmode;\n+  \n+  /* A compare with a shifted operand.  Because of canonicalization, the\n+     comparison will have to be swapped when we emit the assembler.  */\n+  if (GET_MODE (y) == SImode && GET_CODE (y) == REG\n+      && (GET_CODE (x) == ASHIFT || GET_CODE (x) == ASHIFTRT\n+\t  || GET_CODE (x) == LSHIFTRT || GET_CODE (x) == ROTATE\n+\t  || GET_CODE (x) == ROTATERT))\n+    return CC_SWPmode;\n+\n+  /* This is a special case, that is used by combine to alow a \n+     comarison of a shifted byte load to be split into a zero-extend\n+     followed by a comparison of the shifted integer (only valid for\n+     equalities and unsigned inequalites.  */\n+  if (GET_MODE (x) == SImode\n+      && GET_CODE (x) == ASHIFT\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT && INTVAL (XEXP (x, 1)) == 24\n+      && GET_CODE (XEXP (x, 0)) == SUBREG\n+      && GET_CODE (SUBREG_REG (XEXP (x, 0))) == MEM\n+      && GET_MODE (SUBREG_REG (XEXP (x, 0))) == QImode\n+      && (op == EQ || op == NE\n+\t  || op == GEU || op == GTU || op == LTU || op == LEU)\n+      && GET_CODE (y) == CONST_INT)\n+    return CC_Zmode;\n+\n+  /* An operation that sets the condition codes as a side-effect, the\n+     V flag is not set correctly, so we can only use comparisons where\n+     this doesn't matter.  (For LT and GE we can use \"mi\" and \"pl\"\n+     instead.  */\n+  if (GET_MODE (x) == SImode\n+      && y == const0_rtx\n+      && (op == EQ || op == NE || op == LT || op == GE)\n+      && (GET_CODE (x) == PLUS || GET_CODE (x) == MINUS\n+\t  || GET_CODE (x) == AND || GET_CODE (x) == IOR\n+\t  || GET_CODE (x) == XOR || GET_CODE (x) == MULT\n+\t  || GET_CODE (x) == NOT || GET_CODE (x) == NEG\n+\t  || GET_CODE (x) == LSHIFTRT\n+\t  || GET_CODE (x) == ASHIFT || GET_CODE (x) == ASHIFTRT\n+\t  || GET_CODE (x) == ROTATERT || GET_CODE (x) == ZERO_EXTRACT))\n+    return CC_NOOVmode;\n+\n+  /* A construct for a conditional compare, if the false arm contains\n+     0, then both conditions must be true, otherwise either condition\n+     must be true.  Not all conditions are possible, so CCmode is\n+     returned if it can't be done.  */\n+  if (GET_CODE (x) == IF_THEN_ELSE\n+      && (XEXP (x, 2) == const0_rtx\n+\t  || XEXP (x, 2) == const1_rtx)\n+      && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n+      && GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == '<')\n+    return select_dominance_cc_mode (op, XEXP (x, 0), XEXP (x, 1), \n+\t\t\t\t     INTVAL (XEXP (x, 2)));\n+\n+  if (GET_MODE (x) == QImode && (op == EQ || op == NE))\n+    return CC_Zmode;\n+\n+  return CCmode;\n+}\n+\n /* X and Y are two things to compare using CODE.  Emit the compare insn and\n    return the rtx for register 0 in the proper mode.  FP means this is a\n    floating point compare: I don't think that it is needed on the arm.  */\n@@ -3587,9 +4146,10 @@ function_really_clobbers_lr (first)\n }\n \n char *\n-output_return_instruction (operand, really_return)\n+output_return_instruction (operand, really_return, reverse)\n      rtx operand;\n      int really_return;\n+     int reverse;\n {\n   char instr[100];\n   int reg, live_regs = 0;\n@@ -3610,7 +4170,7 @@ output_return_instruction (operand, really_return)\n       ops[0] = operand;\n       ops[1] = gen_rtx (SYMBOL_REF, Pmode, \"abort\");\n       assemble_external_libcall (ops[1]);\n-      output_asm_insn (\"bl%d0\\t%a1\", ops);\n+      output_asm_insn (reverse ? \"bl%D0\\t%a1\" : \"bl%d0\\t%a1\", ops);\n       return \"\";\n     }\n       \n@@ -3633,9 +4193,11 @@ output_return_instruction (operand, really_return)\n         live_regs++;\n \n       if (frame_pointer_needed)\n-        strcpy (instr, \"ldm%?%d0ea\\t%|fp, {\");\n+        strcpy (instr,\n+\t\treverse ? \"ldm%?%D0ea\\t%|fp, {\" : \"ldm%?%d0ea\\t%|fp, {\");\n       else\n-        strcpy (instr, \"ldm%?%d0fd\\t%|sp!, {\");\n+        strcpy (instr, \n+\t\treverse ? \"ldm%?%D0fd\\t%|sp!, {\" : \"ldm%?%d0fd\\t%|sp!, {\");\n \n       for (reg = 0; reg <= 10; reg++)\n         if (regs_ever_live[reg] && ! call_used_regs[reg])\n@@ -3667,8 +4229,8 @@ output_return_instruction (operand, really_return)\n     }\n   else if (really_return)\n     {\n-      strcpy (instr, (TARGET_APCS_32\n-\t\t      ? \"mov%?%d0\\t%|pc, %|lr\" : \"mov%?%d0s\\t%|pc, %|lr\"));\n+      sprintf (instr, \"mov%%?%%%s0%s\\t%%|pc, %%|lr\",\n+\t       reverse ? \"D\" : \"d\", TARGET_APCS_32 ? \"\" : \"s\");\n       output_asm_insn (instr, &operand);\n     }\n \n@@ -4131,11 +4693,7 @@ arm_print_operand (stream, x, code)\n       return;\n \n     case 'D':\n-      if (x && (flag_fast_math\n-\t\t|| GET_CODE (x) == EQ || GET_CODE (x) == NE\n-\t\t|| (GET_MODE (XEXP (x, 0)) != CCFPEmode\n-\t\t    && (GET_MODE_CLASS (GET_MODE (XEXP (x, 0)))\n-\t\t\t!= MODE_FLOAT))))\n+      if (x)\n         fputs (arm_condition_codes[ARM_INVERSE_CONDITION_CODE\n \t\t\t\t   (get_arm_condition_code (x))],\n \t       stream);\n@@ -4277,58 +4835,104 @@ output_lcomm_directive (stream, name, size, rounded)\n    `arm_condition_codes'.  COMPARISON should be an rtx like\n    `(eq (...) (...))'.  */\n \n-int\n+static enum arm_cond_code\n get_arm_condition_code (comparison)\n      rtx comparison;\n {\n   enum machine_mode mode = GET_MODE (XEXP (comparison, 0));\n+  register int code;\n+  register enum rtx_code comp_code = GET_CODE (comparison);\n \n   if (GET_MODE_CLASS (mode) != MODE_CC)\n-    mode = SELECT_CC_MODE (GET_CODE (comparison), XEXP (comparison, 0),\n+    mode = SELECT_CC_MODE (comp_code, XEXP (comparison, 0),\n \t\t\t   XEXP (comparison, 1));\n \n   switch (mode)\n     {\n+    case CC_DNEmode: code = ARM_NE; goto dominance;\n+    case CC_DEQmode: code = ARM_EQ; goto dominance;\n+    case CC_DGEmode: code = ARM_GE; goto dominance;\n+    case CC_DGTmode: code = ARM_GT; goto dominance;\n+    case CC_DLEmode: code = ARM_LE; goto dominance;\n+    case CC_DLTmode: code = ARM_LT; goto dominance;\n+    case CC_DGEUmode: code = ARM_CS; goto dominance;\n+    case CC_DGTUmode: code = ARM_HI; goto dominance;\n+    case CC_DLEUmode: code = ARM_LS; goto dominance;\n+    case CC_DLTUmode: code = ARM_CC;\n+\n+    dominance:\n+      if (comp_code != EQ && comp_code != NE)\n+\tabort ();\n+\n+      if (comp_code == EQ)\n+\treturn ARM_INVERSE_CONDITION_CODE (code);\n+      return code;\n+\n     case CC_NOOVmode:\n-      switch (GET_CODE (comparison))\n+      switch (comp_code)\n \t{\n-\tcase NE: return 1;\n-\tcase EQ: return 0;\n-\tcase GE: return 5;\n-\tcase LT: return 4;\n+\tcase NE: return ARM_NE;\n+\tcase EQ: return ARM_EQ;\n+\tcase GE: return ARM_PL;\n+\tcase LT: return ARM_MI;\n \tdefault: abort ();\n \t}\n \n     case CC_Zmode:\n     case CCFPmode:\n-      switch (GET_CODE (comparison))\n+      switch (comp_code)\n \t{\n-\tcase NE: return 1;\n-\tcase EQ: return 0;\n+\tcase NE: return ARM_NE;\n+\tcase EQ: return ARM_EQ;\n \tdefault: abort ();\n \t}\n \n     case CCFPEmode:\n+      switch (comp_code)\n+\t{\n+\tcase GE: return ARM_GE;\n+\tcase GT: return ARM_GT;\n+\tcase LE: return ARM_LS;\n+\tcase LT: return ARM_MI;\n+\tdefault: abort ();\n+\t}\n+\n+    case CC_SWPmode:\n+      switch (comp_code)\n+\t{\n+\tcase NE: return ARM_NE;\n+\tcase EQ: return ARM_EQ;\n+\tcase GE: return ARM_LE;\n+\tcase GT: return ARM_LT;\n+\tcase LE: return ARM_GE;\n+\tcase LT: return ARM_GT;\n+\tcase GEU: return ARM_LS;\n+\tcase GTU: return ARM_CC;\n+\tcase LEU: return ARM_CS;\n+\tcase LTU: return ARM_HI;\n+\tdefault: abort ();\n+\t}\n+\n     case CCmode:\n-      switch (GET_CODE (comparison))\n+      switch (comp_code)\n \t{\n-\tcase NE: return 1;\n-\tcase EQ: return 0;\n-\tcase GE: return 10;\n-\tcase GT: return 12;\n-\tcase LE: return 13;\n-\tcase LT: return 11;\n-\tcase GEU: return 2;\n-\tcase GTU: return 8;\n-\tcase LEU: return 9;\n-\tcase LTU: return 3;\n+\tcase NE: return ARM_NE;\n+\tcase EQ: return ARM_EQ;\n+\tcase GE: return ARM_GE;\n+\tcase GT: return ARM_GT;\n+\tcase LE: return ARM_LE;\n+\tcase LT: return ARM_LT;\n+\tcase GEU: return ARM_CS;\n+\tcase GTU: return ARM_HI;\n+\tcase LEU: return ARM_LS;\n+\tcase LTU: return ARM_CC;\n \tdefault: abort ();\n \t}\n \n     default: abort ();\n     }\n-  /*NOTREACHED*/\n-  return (42);\n+\n+  abort ();\n }\n \n \n@@ -4646,12 +5250,9 @@ final_prescan_insn (insn, opvec, noperands)\n int arm_text_section_count = 1;\n \n char *\n-aof_text_section (in_readonly)\n-     int in_readonly;\n+aof_text_section ()\n {\n   static char buf[100];\n-  if (in_readonly)\n-    return \"\";\n   sprintf (buf, \"\\tAREA |C$$code%d|, CODE, READONLY\",\n \t   arm_text_section_count++);\n   if (flag_pic)"}]}