{"sha": "abd471378cbe20d51cc6a9c8b4f20907ef0f6825", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJkNDcxMzc4Y2JlMjBkNTFjYzZhOWM4YjRmMjA5MDdlZjBmNjgyNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-01-09T23:16:56Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-01-09T23:16:56Z"}, "message": "runtime: fix 32-bit malloc for pointers >= 0x80000000\n\nThe spans array is allocated in runtime_mallocinit.  On a\n32-bit system the number of entries in the spans array is\nMaxArena32 / PageSize, which (2U << 30) / (1 << 12) == (1 << 19).\nSo we are allocating an array that can hold 19 bits for an\nindex that can hold 20 bits.  According to the comment in the\nfunction, this is intentional: we only allocate enough spans\n(and bitmaps) for a 2G arena, because allocating more would\nprobably be wasteful.\n\nBut since the span index is simply the upper 20 bits of the\nmemory address, this scheme only works if memory addresses are\nlimited to the low 2G of memory.  That would be OK if we were\ncareful to enforce it, but we're not.  What we are careful to\nenforce, in functions like runtime_MHeap_SysAlloc, is that we\nalways return addresses between the heap's arena_start and\narena_start + MaxArena32.\n\nWe generally get away with it because we start allocating just\nafter the program end, so we only run into trouble with\nprograms that allocate a lot of memory, enough to get past\naddress 0x80000000.\n\nThis changes the code that computes a span index to subtract\narena_start on 32-bit systems just as we currently do on\n64-bit systems.\n\nFrom-SVN: r206501", "tree": {"sha": "c0286cd5ffeb41b8c66f7fccc2d3d9f9f966eb1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0286cd5ffeb41b8c66f7fccc2d3d9f9f966eb1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abd471378cbe20d51cc6a9c8b4f20907ef0f6825", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abd471378cbe20d51cc6a9c8b4f20907ef0f6825", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abd471378cbe20d51cc6a9c8b4f20907ef0f6825", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abd471378cbe20d51cc6a9c8b4f20907ef0f6825/comments", "author": null, "committer": null, "parents": [{"sha": "3fadf78ac801aab49b8863e79d4c74e5ff7c2a83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fadf78ac801aab49b8863e79d4c74e5ff7c2a83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fadf78ac801aab49b8863e79d4c74e5ff7c2a83"}], "stats": {"total": 36, "additions": 12, "deletions": 24}, "files": [{"sha": "a06dd11811f1ab4efc401996ebea9ea065894db7", "filename": "libgo/runtime/malloc.goc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd471378cbe20d51cc6a9c8b4f20907ef0f6825/libgo%2Fruntime%2Fmalloc.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd471378cbe20d51cc6a9c8b4f20907ef0f6825/libgo%2Fruntime%2Fmalloc.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.goc?ref=abd471378cbe20d51cc6a9c8b4f20907ef0f6825", "patch": "@@ -637,8 +637,7 @@ runtime_settype_flush(M *mp)\n \n \t\t// (Manually inlined copy of runtime_MHeap_Lookup)\n \t\tp = (uintptr)v>>PageShift;\n-\t\tif(sizeof(void*) == 8)\n-\t\t\tp -= (uintptr)runtime_mheap.arena_start >> PageShift;\n+\t\tp -= (uintptr)runtime_mheap.arena_start >> PageShift;\n \t\ts = runtime_mheap.spans[p];\n \n \t\tif(s->sizeclass == 0) {"}, {"sha": "8ceece37b5afb89d17462d24b2b3684eb13055fb", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd471378cbe20d51cc6a9c8b4f20907ef0f6825/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd471378cbe20d51cc6a9c8b4f20907ef0f6825/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=abd471378cbe20d51cc6a9c8b4f20907ef0f6825", "patch": "@@ -269,8 +269,7 @@ markonly(void *obj)\n \t// (Manually inlined copy of MHeap_LookupMaybe.)\n \tk = (uintptr)obj>>PageShift;\n \tx = k;\n-\tif(sizeof(void*) == 8)\n-\t\tx -= (uintptr)runtime_mheap.arena_start>>PageShift;\n+\tx -= (uintptr)runtime_mheap.arena_start>>PageShift;\n \ts = runtime_mheap.spans[x];\n \tif(s == nil || k < s->start || (byte*)obj >= s->limit || s->state != MSpanInUse)\n \t\treturn false;\n@@ -453,8 +452,7 @@ flushptrbuf(PtrTarget *ptrbuf, PtrTarget **ptrbufpos, Obj **_wp, Workbuf **_wbuf\n \t\t\t// (Manually inlined copy of MHeap_LookupMaybe.)\n \t\t\tk = (uintptr)obj>>PageShift;\n \t\t\tx = k;\n-\t\t\tif(sizeof(void*) == 8)\n-\t\t\t\tx -= (uintptr)arena_start>>PageShift;\n+\t\t\tx -= (uintptr)arena_start>>PageShift;\n \t\t\ts = runtime_mheap.spans[x];\n \t\t\tif(s == nil || k < s->start || obj >= s->limit || s->state != MSpanInUse)\n \t\t\t\tcontinue;\n@@ -501,8 +499,7 @@ flushptrbuf(PtrTarget *ptrbuf, PtrTarget **ptrbufpos, Obj **_wp, Workbuf **_wbuf\n \t\t\t// Ask span about size class.\n \t\t\t// (Manually inlined copy of MHeap_Lookup.)\n \t\t\tx = (uintptr)obj >> PageShift;\n-\t\t\tif(sizeof(void*) == 8)\n-\t\t\t\tx -= (uintptr)arena_start>>PageShift;\n+\t\t\tx -= (uintptr)arena_start>>PageShift;\n \t\t\ts = runtime_mheap.spans[x];\n \n \t\t\tPREFETCH(obj);\n@@ -617,8 +614,7 @@ checkptr(void *obj, uintptr objti)\n \tif(t == nil)\n \t\treturn;\n \tx = (uintptr)obj >> PageShift;\n-\tif(sizeof(void*) == 8)\n-\t\tx -= (uintptr)(runtime_mheap.arena_start)>>PageShift;\n+\tx -= (uintptr)(runtime_mheap.arena_start)>>PageShift;\n \ts = runtime_mheap.spans[x];\n \tobjstart = (byte*)((uintptr)s->start<<PageShift);\n \tif(s->sizeclass != 0) {"}, {"sha": "fee493c1367f09f9495c2d3fc689b89ef1ddfb3c", "filename": "libgo/runtime/mheap.c", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd471378cbe20d51cc6a9c8b4f20907ef0f6825/libgo%2Fruntime%2Fmheap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd471378cbe20d51cc6a9c8b4f20907ef0f6825/libgo%2Fruntime%2Fmheap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmheap.c?ref=abd471378cbe20d51cc6a9c8b4f20907ef0f6825", "patch": "@@ -73,8 +73,7 @@ runtime_MHeap_MapSpans(MHeap *h)\n \n \t// Map spans array, PageSize at a time.\n \tn = (uintptr)h->arena_used;\n-\tif(sizeof(void*) == 8)\n-\t\tn -= (uintptr)h->arena_start;\n+\tn -= (uintptr)h->arena_start;\n \tn = n / PageSize * sizeof(h->spans[0]);\n \tn = ROUND(n, PageSize);\n \tpagesize = getpagesize();\n@@ -170,8 +169,7 @@ MHeap_AllocLocked(MHeap *h, uintptr npage, int32 sizeclass)\n \t\truntime_MSpan_Init(t, s->start + npage, s->npages - npage);\n \t\ts->npages = npage;\n \t\tp = t->start;\n-\t\tif(sizeof(void*) == 8)\n-\t\t\tp -= ((uintptr)h->arena_start>>PageShift);\n+\t\tp -= ((uintptr)h->arena_start>>PageShift);\n \t\tif(p > 0)\n \t\t\th->spans[p-1] = s;\n \t\th->spans[p] = t;\n@@ -189,8 +187,7 @@ MHeap_AllocLocked(MHeap *h, uintptr npage, int32 sizeclass)\n \ts->elemsize = (sizeclass==0 ? s->npages<<PageShift : (uintptr)runtime_class_to_size[sizeclass]);\n \ts->types.compression = MTypes_Empty;\n \tp = s->start;\n-\tif(sizeof(void*) == 8)\n-\t\tp -= ((uintptr)h->arena_start>>PageShift);\n+\tp -= ((uintptr)h->arena_start>>PageShift);\n \tfor(n=0; n<npage; n++)\n \t\th->spans[p+n] = s;\n \treturn s;\n@@ -258,8 +255,7 @@ MHeap_Grow(MHeap *h, uintptr npage)\n \ts = runtime_FixAlloc_Alloc(&h->spanalloc);\n \truntime_MSpan_Init(s, (uintptr)v>>PageShift, ask>>PageShift);\n \tp = s->start;\n-\tif(sizeof(void*) == 8)\n-\t\tp -= ((uintptr)h->arena_start>>PageShift);\n+\tp -= ((uintptr)h->arena_start>>PageShift);\n \th->spans[p] = s;\n \th->spans[p + s->npages - 1] = s;\n \ts->state = MSpanInUse;\n@@ -276,8 +272,7 @@ runtime_MHeap_Lookup(MHeap *h, void *v)\n \tuintptr p;\n \t\n \tp = (uintptr)v;\n-\tif(sizeof(void*) == 8)\n-\t\tp -= (uintptr)h->arena_start;\n+\tp -= (uintptr)h->arena_start;\n \treturn h->spans[p >> PageShift];\n }\n \n@@ -298,8 +293,7 @@ runtime_MHeap_LookupMaybe(MHeap *h, void *v)\n \t\treturn nil;\n \tp = (uintptr)v>>PageShift;\n \tq = p;\n-\tif(sizeof(void*) == 8)\n-\t\tq -= (uintptr)h->arena_start >> PageShift;\n+\tq -= (uintptr)h->arena_start >> PageShift;\n \ts = h->spans[q];\n \tif(s == nil || p < s->start || (byte*)v >= s->limit || s->state != MSpanInUse)\n \t\treturn nil;\n@@ -346,8 +340,7 @@ MHeap_FreeLocked(MHeap *h, MSpan *s)\n \n \t// Coalesce with earlier, later spans.\n \tp = s->start;\n-\tif(sizeof(void*) == 8)\n-\t\tp -= (uintptr)h->arena_start >> PageShift;\n+\tp -= (uintptr)h->arena_start >> PageShift;\n \tif(p > 0 && (t = h->spans[p-1]) != nil && t->state != MSpanInUse) {\n \t\tif(t->npreleased == 0) {  // cant't touch this otherwise\n \t\t\ttp = (uintptr*)(t->start<<PageShift);"}]}