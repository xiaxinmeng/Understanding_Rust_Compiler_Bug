{"sha": "9e544d738ad9dd9251db1eb43592c5306270e230", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU1NDRkNzM4YWQ5ZGQ5MjUxZGIxZWI0MzU5MmM1MzA2MjcwZTIzMA==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2009-03-22T10:51:05Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2009-03-22T10:51:05Z"}, "message": "PR libfortran/25561 libfortran/37754\n\n2009-03-22  Janne Blomqvist  <jb@gcc.gnu.org>\n\n        PR libfortran/25561 libfortran/37754\n\t* io/io.h (struct stream): Define new stream interface function\n\tpointers, and inline functions for accessing it.\n\t(struct fbuf): Use int instead of size_t, remove flushed element.\n\t(mem_alloc_w): New prototype.\n\t(mem_alloc_r): New prototype.\n\t(stream_at_bof): Remove prototype.\n\t(stream_at_eof): Remove prototype.\n\t(file_position): Remove prototype.\n\t(flush): Remove prototype.\n\t(stream_offset): Remove prototype.\n\t(unit_truncate): New prototype.\n\t(read_block_form): Change to return pointer, int* argument.\n\t(hit_eof): New prototype.\n\t(fbuf_init): Change prototype.\n\t(fbuf_reset): Change prototype.\n\t(fbuf_alloc): Change prototype.\n\t(fbuf_flush): Change prototype.\n\t(fbuf_seek): Change prototype.\n\t(fbuf_read): New prototype.\n\t(fbuf_getc_refill): New prototype.\n\t(fbuf_getc): New inline function.\n        * io/fbuf.c (fbuf_init): Use int, get rid of flushed.\n\t(fbuf_debug): New function.\n\t(fbuf_reset): Flush, and return position offset.\n\t(fbuf_alloc): Simplify, don't flush, just realloc.\n\t(fbuf_flush): Make usable for read mode, salvage remaining bytes.\n\t(fbuf_seek): New whence argument.\n\t(fbuf_read): New function.\n\t(fbuf_getc_refill): New function.\n\t* io/file_pos.c (formatted_backspace): Use new stream interface.\n\t(unformatted_backspace): Likewise.\n\t(st_backspace): Make sure format buffer is reset, use new stream\n\tinterface, use unit_truncate.\n\t(st_endfile): Likewise.\n\t(st_rewind): Likewise.\n\t* io/intrinsics.c: Use new stream interface.\n\t* io/list_read.c (push_char): Don't use u.p.scratch, use realloc\n\tto resize.\n\t(free_saved): Don't check u.p.scratch.\n\t(next_char): Use new stream interface, use fbuf_getc() for external files.\n\t(finish_list_read): flush format buffer.\n\t(nml_query): Update to use modified interface:s\n\t* io/open.c (test_endfile): Use new stream interface.\n\t(edit_modes): Likewise.\n\t(new_unit): Likewise, set bytes_left to 1 for stream files.\n\t* io/read.c (read_l): Use new read_block_form interface.\n\t(read_utf8): Likewise.\n\t(read_utf8_char1): Likewise.\n\t(read_default_char1): Likewise.\n\t(read_utf8_char4): Likewise.\n\t(read_default_char4): Likewise.\n\t(read_a): Likewise.\n\t(read_a_char4): Likewise.\n\t(read_decimal): Likewise.\n\t(read_radix): Likewise.\n\t(read_f): Likewise.\n\t* io/transfer.c (read_sf): Use fbuf_read and mem_alloc_r, remove\n\tusage of u.p.line_buffer.\n\t(read_block_form): Update interface to return pointer, use\n\tfbuf_read for direct access.\n\t(read_block_direct): Update to new stream interface.\n\t(write_block): Use mem_alloc_w for internal I/O.\n\t(write_buf): Update to new stream interface.\n\t(formatted_transfer_scalar): Don't use u.p.line_buffer, use\n\tfbuf_seek for external files.\n\t(us_read): Update to new stream interface.\n\t(us_write): Likewise.\n\t(data_transfer_init): Always check if we switch modes and flush.\n\t(skip_record): Use new stream interface, fix comparison.\n\t(next_record_r): Check for and reset u.p.at_eof, use new stream\n\tinterface, use fbuf_getc for spacing.\n\t(write_us_marker): Update to new stream interface, don't inline.\n\t(next_record_w_unf): Likewise.\n\t(sset): New function.\n\t(next_record_w): Use new stream interface, use fbuf for printing\n\tnewline.\n\t(next_record): Use new stream interface.\n\t(finalize_transfer): Remove sfree call, use new stream interface.\n\t(st_iolength_done): Don't use u.p.scratch.\n\t(st_read): Don't check for end of file.\n\t(st_read_done): Don't use u.p.scratch, use unit_truncate.\n\t(hit_eof): New function.\n\t* io/unit.c (init_units): Always init fbuf for formatted units.\n\t(update_position): Use new stream interface.\n\t(unit_truncate): New function.\n\t(finish_last_advance_record): Use fbuf to print newline.\n\t* io/unix.c: Remove unused SSIZE_MAX macro.\n\t(BUFFER_SIZE): Make static const variable rather than macro.\n\t(struct unix_stream): Remove dirty_offset, len, method,\n\tsmall_buffer. Order elements by decreasing size.\n\t(struct int_stream): Remove.\n\t(move_pos_offset): Remove usage of dirty_offset.\n\t(reset_stream): Remove.\n\t(do_read): Rename to raw_read, update to match new stream\n\tinterface.\n\t(do_write): Rename to raw_write, update to new stream interface.\n\t(raw_seek): New function.\n\t(raw_tell): New function.\n\t(raw_truncate): New function.\n\t(raw_close): New function.\n\t(raw_flush): New function.\n\t(raw_init): New function.\n\t(fd_alloc): Remove.\n\t(fd_alloc_r_at): Remove.\n\t(fd_alloc_w_at): Remove.\n\t(fd_sfree): Remove.\n\t(fd_seek): Remove.\n\t(fd_truncate): Remove.\n\t(fd_sset): Remove.\n\t(fd_read): Remove.\n\t(fd_write): Remove.\n\t(fd_close): Remove.\n\t(fd_open): Remove.\n\t(fd_flush): Rename to buf_flush, update to new stream interface\n\tand unix_stream.\n\t(buf_read): New function.\n\t(buf_write): New function.\n\t(buf_seek): New function.\n\t(buf_tell): New function.\n\t(buf_truncate): New function.\n\t(buf_close): New function.\n\t(buf_init): New function.\n\t(mem_alloc_r_at): Rename to mem_alloc_r, change prototype.\n\t(mem_alloc_w_at): Rename to mem_alloc_w, change prototype.\n\t(mem_read): Change to match new stream interface.\n\t(mem_write): Likewise.\n\t(mem_seek): Likewise.\n\t(mem_tell): Likewise.\n\t(mem_truncate): Likewise.\n\t(mem_close): Likewise.\n\t(mem_flush): New function.\n\t(mem_sfree): Remove.\n\t(empty_internal_buffer): Cast to correct type.\n\t(open_internal): Use correct type, init function pointers.\n\t(fd_to_stream): Test whether to open file as buffered or raw.\n\t(output_stream): Remove mode set.\n\t(error_stream): Likewise.\n\t(flush_all_units_1): Use new stream interface.\n\t(flush_all_units): Likewise.\n\t(stream_at_bof): Remove.\n\t(stream_at_eof): Remove.\n\t(file_position): Remove.\n\t(file_length): Update logic to use stream interface.\n\t(flush): Remove.\n\t(stream_offset): Remove.\n\t* io/write.c (write_utf8_char4): Use int instead of size_t.\n\t(write_x): Extra safety check.\n\t(namelist_write_newline): Use new stream interface.\n\n[[Split portion of a mixed commit.]]\n\nFrom-SVN: r144993.2", "tree": {"sha": "5e18a854022f3a5ad1d31571188febf9bef04568", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e18a854022f3a5ad1d31571188febf9bef04568"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e544d738ad9dd9251db1eb43592c5306270e230", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e544d738ad9dd9251db1eb43592c5306270e230", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e544d738ad9dd9251db1eb43592c5306270e230", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e544d738ad9dd9251db1eb43592c5306270e230/comments", "author": null, "committer": null, "parents": [{"sha": "048fd7857b889d9e83b7b1ed8ee3d949b3c0e24a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/048fd7857b889d9e83b7b1ed8ee3d949b3c0e24a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/048fd7857b889d9e83b7b1ed8ee3d949b3c0e24a"}], "stats": {"total": 970, "additions": 530, "deletions": 440}, "files": [{"sha": "f1731652abfaca7cb6ab69b0faa12dcc3e023163", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 81, "deletions": 45, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e544d738ad9dd9251db1eb43592c5306270e230/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e544d738ad9dd9251db1eb43592c5306270e230/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=9e544d738ad9dd9251db1eb43592c5306270e230", "patch": "@@ -49,34 +49,59 @@ struct st_parameter_dt;\n \n typedef struct stream\n {\n-  char *(*alloc_w_at) (struct stream *, int *);\n-  try (*sfree) (struct stream *);\n-  try (*close) (struct stream *);\n-  try (*seek) (struct stream *, gfc_offset);\n-  try (*trunc) (struct stream *);\n-  int (*read) (struct stream *, void *, size_t *);\n-  int (*write) (struct stream *, const void *, size_t *);\n-  try (*set) (struct stream *, int, size_t);\n+  ssize_t (*read) (struct stream *, void *, ssize_t);\n+  ssize_t (*write) (struct stream *, const void *, ssize_t);\n+  off_t (*seek) (struct stream *, off_t, int);\n+  off_t (*tell) (struct stream *);\n+  int (*truncate) (struct stream *, off_t);\n+  int (*flush) (struct stream *);\n+  int (*close) (struct stream *);\n }\n stream;\n \n-typedef enum\n-{ SYNC_BUFFERED, SYNC_UNBUFFERED, ASYNC }\n-io_mode;\n+/* Inline functions for doing file I/O given a stream.  */\n+static inline ssize_t\n+sread (stream * s, void * buf, ssize_t nbyte)\n+{\n+  return s->read (s, buf, nbyte);\n+}\n \n-/* Macros for doing file I/O given a stream.  */\n+static inline ssize_t\n+swrite (stream * s, const void * buf, ssize_t nbyte)\n+{\n+  return s->write (s, buf, nbyte);\n+}\n \n-#define sfree(s) ((s)->sfree)(s)\n-#define sclose(s) ((s)->close)(s)\n+static inline off_t\n+sseek (stream * s, off_t offset, int whence)\n+{\n+  return s->seek (s, offset, whence);\n+}\n \n-#define salloc_w(s, len) ((s)->alloc_w_at)(s, len)\n+static inline off_t\n+stell (stream * s)\n+{\n+  return s->tell (s);\n+}\n \n-#define sseek(s, pos) ((s)->seek)(s, pos)\n-#define struncate(s) ((s)->trunc)(s)\n-#define sread(s, buf, nbytes) ((s)->read)(s, buf, nbytes)\n-#define swrite(s, buf, nbytes) ((s)->write)(s, buf, nbytes)\n+static inline int\n+struncate (stream * s, off_t length)\n+{\n+  return s->truncate (s, length);\n+}\n+\n+static inline int\n+sflush (stream * s)\n+{\n+  return s->flush (s);\n+}\n+\n+static inline int\n+sclose (stream * s)\n+{\n+  return s->close (s);\n+}\n \n-#define sset(s, c, n) ((s)->set)(s, c, n)\n \n /* Macros for testing what kinds of I/O we are doing.  */\n \n@@ -538,10 +563,9 @@ unit_flags;\n typedef struct fbuf\n {\n   char *buf;\t\t\t/* Start of buffer.  */\n-  size_t len;\t\t\t/* Length of buffer.  */\n-  size_t act;\t\t\t/* Active bytes in buffer.  */\n-  size_t flushed;\t\t/* Flushed bytes from beginning of buffer.  */\n-  size_t pos;\t\t\t/* Current position in buffer.  */\n+  int len;\t\t\t/* Length of buffer.  */\n+  int act;\t\t\t/* Active bytes in buffer.  */\n+  int pos;\t\t\t/* Current position in buffer.  */\n }\n fbuf;\n \n@@ -683,6 +707,12 @@ internal_proto(open_external);\n extern stream *open_internal (char *, int, gfc_offset);\n internal_proto(open_internal);\n \n+extern char * mem_alloc_w (stream *, int *);\n+internal_proto(mem_alloc_w);\n+\n+extern char * mem_alloc_r (stream *, int *);\n+internal_proto(mem_alloc_w);\n+\n extern stream *input_stream (void);\n internal_proto(input_stream);\n \n@@ -698,12 +728,6 @@ internal_proto(compare_file_filename);\n extern gfc_unit *find_file (const char *file, gfc_charlen_type file_len);\n internal_proto(find_file);\n \n-extern int stream_at_bof (stream *);\n-internal_proto(stream_at_bof);\n-\n-extern int stream_at_eof (stream *);\n-internal_proto(stream_at_eof);\n-\n extern int delete_file (gfc_unit *);\n internal_proto(delete_file);\n \n@@ -734,9 +758,6 @@ internal_proto(inquire_readwrite);\n extern gfc_offset file_length (stream *);\n internal_proto(file_length);\n \n-extern gfc_offset file_position (stream *);\n-internal_proto(file_position);\n-\n extern int is_seekable (stream *);\n internal_proto(is_seekable);\n \n@@ -752,18 +773,12 @@ internal_proto(flush_if_preconnected);\n extern void empty_internal_buffer(stream *);\n internal_proto(empty_internal_buffer);\n \n-extern try flush (stream *);\n-internal_proto(flush);\n-\n extern int stream_isatty (stream *);\n internal_proto(stream_isatty);\n \n extern char * stream_ttyname (stream *);\n internal_proto(stream_ttyname);\n \n-extern gfc_offset stream_offset (stream *s);\n-internal_proto(stream_offset);\n-\n extern int unpack_filename (char *, const char *, int);\n internal_proto(unpack_filename);\n \n@@ -807,6 +822,9 @@ internal_proto(update_position);\n extern void finish_last_advance_record (gfc_unit *u);\n internal_proto (finish_last_advance_record);\n \n+extern int unit_truncate (gfc_unit *, gfc_offset, st_parameter_common *);\n+internal_proto (unit_truncate);\n+\n /* open.c */\n \n extern gfc_unit *new_unit (st_parameter_open *, gfc_unit *, unit_flags *);\n@@ -836,7 +854,7 @@ internal_proto(free_format_data);\n extern const char *type_name (bt);\n internal_proto(type_name);\n \n-extern try read_block_form (st_parameter_dt *, void *, size_t *);\n+extern void * read_block_form (st_parameter_dt *, int *);\n internal_proto(read_block_form);\n \n extern char *read_sf (st_parameter_dt *, int *, int);\n@@ -862,6 +880,9 @@ internal_proto (reverse_memcpy);\n extern void st_wait (st_parameter_wait *);\n export_proto(st_wait);\n \n+extern void hit_eof (st_parameter_dt *);\n+internal_proto(hit_eof);\n+\n /* read.c */\n \n extern void set_integer (void *, GFC_INTEGER_LARGEST, int);\n@@ -968,24 +989,39 @@ extern size_t size_from_complex_kind (int);\n internal_proto(size_from_complex_kind);\n \n /* fbuf.c */\n-extern void fbuf_init (gfc_unit *, size_t);\n+extern void fbuf_init (gfc_unit *, int);\n internal_proto(fbuf_init);\n \n extern void fbuf_destroy (gfc_unit *);\n internal_proto(fbuf_destroy);\n \n-extern void fbuf_reset (gfc_unit *);\n+extern int fbuf_reset (gfc_unit *);\n internal_proto(fbuf_reset);\n \n-extern char * fbuf_alloc (gfc_unit *, size_t);\n+extern char * fbuf_alloc (gfc_unit *, int);\n internal_proto(fbuf_alloc);\n \n-extern int fbuf_flush (gfc_unit *, int);\n+extern int fbuf_flush (gfc_unit *, unit_mode);\n internal_proto(fbuf_flush);\n \n-extern int fbuf_seek (gfc_unit *, gfc_offset);\n+extern int fbuf_seek (gfc_unit *, int, int);\n internal_proto(fbuf_seek);\n \n+extern char * fbuf_read (gfc_unit *, int *);\n+internal_proto(fbuf_read);\n+\n+/* Never call this function, only use fbuf_getc().  */\n+extern int fbuf_getc_refill (gfc_unit *);\n+internal_proto(fbuf_getc_refill);\n+\n+static inline int\n+fbuf_getc (gfc_unit * u)\n+{\n+  if (u->fbuf->pos < u->fbuf->act)\n+    return (unsigned char) u->fbuf->buf[u->fbuf->pos++];\n+  return fbuf_getc_refill (u);\n+}\n+\n /* lock.c */\n extern void free_ionml (st_parameter_dt *);\n internal_proto(free_ionml);"}, {"sha": "eba44781438ae269d5b9f498e0fac75627c87b2b", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e544d738ad9dd9251db1eb43592c5306270e230/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e544d738ad9dd9251db1eb43592c5306270e230/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=9e544d738ad9dd9251db1eb43592c5306270e230", "patch": "@@ -33,6 +33,7 @@ Boston, MA 02110-1301, USA.  */\n \n #include \"io.h\"\n #include <string.h>\n+#include <stdlib.h>\n #include <ctype.h>\n \n \n@@ -79,9 +80,8 @@ push_char (st_parameter_dt *dtp, char c)\n \n   if (dtp->u.p.saved_string == NULL)\n     {\n-      if (dtp->u.p.scratch == NULL)\n-\tdtp->u.p.scratch = get_mem (SCRATCH_SIZE);\n-      dtp->u.p.saved_string = dtp->u.p.scratch;\n+      dtp->u.p.saved_string = get_mem (SCRATCH_SIZE);\n+      // memset below should be commented out.\n       memset (dtp->u.p.saved_string, 0, SCRATCH_SIZE);\n       dtp->u.p.saved_length = SCRATCH_SIZE;\n       dtp->u.p.saved_used = 0;\n@@ -90,15 +90,15 @@ push_char (st_parameter_dt *dtp, char c)\n   if (dtp->u.p.saved_used >= dtp->u.p.saved_length)\n     {\n       dtp->u.p.saved_length = 2 * dtp->u.p.saved_length;\n-      new = get_mem (2 * dtp->u.p.saved_length);\n-\n-      memset (new, 0, 2 * dtp->u.p.saved_length);\n-\n-      memcpy (new, dtp->u.p.saved_string, dtp->u.p.saved_used);\n-      if (dtp->u.p.saved_string != dtp->u.p.scratch)\n-\tfree_mem (dtp->u.p.saved_string);\n-\n+      new = realloc (dtp->u.p.saved_string, dtp->u.p.saved_length);\n+      if (new == NULL)\n+\tgenerate_error (&dtp->common, LIBERROR_OS, NULL);\n       dtp->u.p.saved_string = new;\n+      \n+      // Also this should not be necessary.\n+      memset (new + dtp->u.p.saved_used, 0, \n+\t      dtp->u.p.saved_length - dtp->u.p.saved_used);\n+\n     }\n \n   dtp->u.p.saved_string[dtp->u.p.saved_used++] = c;\n@@ -113,8 +113,7 @@ free_saved (st_parameter_dt *dtp)\n   if (dtp->u.p.saved_string == NULL)\n     return;\n \n-  if (dtp->u.p.saved_string != dtp->u.p.scratch)\n-    free_mem (dtp->u.p.saved_string);\n+  free_mem (dtp->u.p.saved_string);\n \n   dtp->u.p.saved_string = NULL;\n   dtp->u.p.saved_used = 0;\n@@ -140,9 +139,10 @@ free_line (st_parameter_dt *dtp)\n static char\n next_char (st_parameter_dt *dtp)\n {\n-  size_t length;\n+  ssize_t length;\n   gfc_offset record;\n   char c;\n+  int cc;\n \n   if (dtp->u.p.last_char != '\\0')\n     {\n@@ -194,7 +194,7 @@ next_char (st_parameter_dt *dtp)\n \t    }\n \n \t  record *= dtp->u.p.current_unit->recl;\n-\t  if (sseek (dtp->u.p.current_unit->s, record) == FAILURE)\n+\t  if (sseek (dtp->u.p.current_unit->s, record, SEEK_SET) < 0)\n \t    longjmp (*dtp->u.p.eof_jump, 1);\n \n \t  dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n@@ -204,19 +204,15 @@ next_char (st_parameter_dt *dtp)\n \n   /* Get the next character and handle end-of-record conditions.  */\n \n-  length = 1;\n-\n-  if (sread (dtp->u.p.current_unit->s, &c, &length) != 0)\n-    {\n-\tgenerate_error (&dtp->common, LIBERROR_OS, NULL);\n-\treturn '\\0';\n-    }\n-  \n-  if (is_stream_io (dtp) && length == 1)\n-    dtp->u.p.current_unit->strm_pos++;\n-\n   if (is_internal_unit (dtp))\n     {\n+      length = sread (dtp->u.p.current_unit->s, &c, 1);\n+      if (length < 0)\n+\t{\n+\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n+\t  return '\\0';\n+\t}\n+  \n       if (is_array_io (dtp))\n \t{\n \t  /* Check whether we hit EOF.  */ \n@@ -240,13 +236,20 @@ next_char (st_parameter_dt *dtp)\n     }\n   else\n     {\n-      if (length == 0)\n+      cc = fbuf_getc (dtp->u.p.current_unit);\n+\n+      if (cc == EOF)\n \t{\n \t  if (dtp->u.p.current_unit->endfile == AT_ENDFILE)\n \t    longjmp (*dtp->u.p.eof_jump, 1);\n \t  dtp->u.p.current_unit->endfile = AT_ENDFILE;\n \t  c = '\\n';\n \t}\n+      else\n+\tc = (char) cc;\n+      if (is_stream_io (dtp) && cc != EOF)\n+\tdtp->u.p.current_unit->strm_pos++;\n+\n     }\n done:\n   dtp->u.p.at_eol = (c == '\\n' || c == '\\r');\n@@ -1698,7 +1701,7 @@ list_formatted_read_scalar (st_parameter_dt *dtp, volatile bt type, void *p,\n       dtp->u.p.input_complete = 0;\n       dtp->u.p.repeat_count = 1;\n       dtp->u.p.at_eol = 0;\n-\n+      \n       c = eat_spaces (dtp);\n       if (is_separator (c))\n \t{\n@@ -1853,6 +1856,8 @@ finish_list_read (st_parameter_dt *dtp)\n \n   free_saved (dtp);\n \n+  fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);\n+\n   if (dtp->u.p.at_eol)\n     {\n       dtp->u.p.at_eol = 0;\n@@ -2261,8 +2266,8 @@ nml_query (st_parameter_dt *dtp, char c)\n \n       /* Flush the stream to force immediate output.  */\n \n-      fbuf_flush (dtp->u.p.current_unit, 1);\n-      flush (dtp->u.p.current_unit->s);\n+      fbuf_flush (dtp->u.p.current_unit, WRITING);\n+      sflush (dtp->u.p.current_unit->s);\n       unlock_unit (dtp->u.p.current_unit);\n     }\n \n@@ -2903,7 +2908,7 @@ namelist_read (st_parameter_dt *dtp)\n \t  st_printf (\"%s\\n\", nml_err_msg);\n \t  if (u != NULL)\n \t    {\n-\t      flush (u->s);\n+\t      sflush (u->s);\n \t      unlock_unit (u);\n \t    }\n         }"}, {"sha": "101f6f4d3bbe06232dc2819eb342ee11546fbaa9", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 351, "deletions": 353, "changes": 704, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e544d738ad9dd9251db1eb43592c5306270e230/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e544d738ad9dd9251db1eb43592c5306270e230/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=9e544d738ad9dd9251db1eb43592c5306270e230", "patch": "@@ -37,6 +37,7 @@ Boston, MA 02110-1301, USA.  */\n #include <string.h>\n #include <assert.h>\n #include <stdlib.h>\n+#include <errno.h>\n \n \n /* Calling conventions:  Data transfer statements are unlike other\n@@ -183,60 +184,58 @@ current_mode (st_parameter_dt *dtp)\n    heap.  Hopefully this won't happen very often.  */\n \n char *\n-read_sf (st_parameter_dt *dtp, int *length, int no_error)\n+read_sf (st_parameter_dt *dtp, int * length, int no_error)\n {\n+  static char *empty_string[0];\n   char *base, *p, q;\n-  int n, crlf;\n-  gfc_offset pos;\n-  size_t readlen;\n+  int n, lorig, memread, seen_comma;\n \n-  if (*length > SCRATCH_SIZE)\n-    dtp->u.p.line_buffer = get_mem (*length);\n-  p = base = dtp->u.p.line_buffer;\n+  /* If we hit EOF previously with the no_error flag set (i.e. X, T,\n+     TR edit descriptors), and we now try to read again, this time\n+     without setting no_error.  */\n+  if (!no_error && dtp->u.p.at_eof)\n+    {\n+      *length = 0;\n+      hit_eof (dtp);\n+      return NULL;\n+    }\n \n   /* If we have seen an eor previously, return a length of 0.  The\n      caller is responsible for correctly padding the input field.  */\n   if (dtp->u.p.sf_seen_eor)\n     {\n       *length = 0;\n-      return base;\n+      /* Just return something that isn't a NULL pointer, otherwise the\n+         caller thinks an error occured.  */\n+      return (char*) empty_string;\n     }\n \n   if (is_internal_unit (dtp))\n     {\n-      readlen = *length;\n-      if (unlikely (sread (dtp->u.p.current_unit->s, p, &readlen) != 0\n-\t\t    || readlen < (size_t) *length))\n+      memread = *length;\n+      base = mem_alloc_r (dtp->u.p.current_unit->s, length);\n+      if (unlikely (memread > *length))\n \t{\n-\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n+          hit_eof (dtp);\n \t  return NULL;\n \t}\n-\t\n+      n = *length;\n       goto done;\n     }\n \n-  readlen = 1;\n-  n = 0;\n+  n = seen_comma = 0;\n \n-  do\n-    {\n-      if (unlikely (sread (dtp->u.p.current_unit->s, &q, &readlen) != 0))\n-        {\n-\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n-\t  return NULL;\n-\t}\n+  /* Read data into format buffer and scan through it.  */\n+  lorig = *length;\n+  base = p = fbuf_read (dtp->u.p.current_unit, length);\n+  if (base == NULL)\n+    return NULL;\n \n-      /* If we have a line without a terminating \\n, drop through to\n-\t EOR below.  */\n-      if (readlen < 1 && n == 0)\n-\t{\n-\t  if (likely (no_error))\n-\t    break;\n-\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n-\t  return NULL;\n-\t}\n+  while (n < *length)\n+    {\n+      q = *p;\n \n-      if (readlen < 1 || q == '\\n' || q == '\\r')\n+      if (q == '\\n' || q == '\\r')\n \t{\n \t  /* Unexpected end of line.  */\n \n@@ -245,23 +244,14 @@ read_sf (st_parameter_dt *dtp, int *length, int no_error)\n \t  if (dtp->u.p.advance_status == ADVANCE_NO || dtp->u.p.seen_dollar)\n \t    dtp->u.p.eor_condition = 1;\n \n-\t  crlf = 0;\n \t  /* If we encounter a CR, it might be a CRLF.  */\n \t  if (q == '\\r') /* Probably a CRLF */\n \t    {\n-\t      readlen = 1;\n-\t      pos = stream_offset (dtp->u.p.current_unit->s);\n-\t      if (unlikely (sread (dtp->u.p.current_unit->s, &q, &readlen)\n-\t\t\t    != 0))\n-\t        {\n-\t\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n-\t\t  return NULL;\n-\t\t}\n-\t      if (q != '\\n' && readlen == 1) /* Not a CRLF after all.  */\n-\t\tsseek (dtp->u.p.current_unit->s, pos);\n-\t      else\n-\t\tcrlf = 1;\n+\t      if (n < *length && *(p + 1) == '\\n')\n+\t\tdtp->u.p.sf_seen_eor = 2;\n \t    }\n+          else\n+            dtp->u.p.sf_seen_eor = 1;\n \n \t  /* Without padding, terminate the I/O statement without assigning\n \t     the value.  With padding, the value still needs to be assigned,\n@@ -275,7 +265,6 @@ read_sf (st_parameter_dt *dtp, int *length, int no_error)\n \t    }\n \n \t  *length = n;\n-\t  dtp->u.p.sf_seen_eor = (crlf ? 2 : 1);\n \t  break;\n \t}\n       /*  Short circuit the read if a comma is found during numeric input.\n@@ -284,23 +273,39 @@ read_sf (st_parameter_dt *dtp, int *length, int no_error)\n       if (q == ',')\n \tif (dtp->u.p.sf_read_comma == 1)\n \t  {\n+            seen_comma = 1;\n \t    notify_std (&dtp->common, GFC_STD_GNU,\n \t\t\t\"Comma in formatted numeric read.\");\n \t    *length = n;\n \t    break;\n \t  }\n \n       n++;\n-      *p++ = q;\n-      dtp->u.p.sf_seen_eor = 0;\n+      p++;\n+    } \n+\n+  fbuf_seek (dtp->u.p.current_unit, n + dtp->u.p.sf_seen_eor + seen_comma, \n+             SEEK_CUR);\n+\n+  /* A short read implies we hit EOF, unless we hit EOR, a comma, or\n+     some other stuff. Set the relevant flags.  */\n+  if (lorig > *length && !dtp->u.p.sf_seen_eor && !seen_comma)\n+    {\n+      if (no_error)\n+        dtp->u.p.at_eof = 1;\n+      else\n+        {\n+          hit_eof (dtp);\n+          return NULL;\n+        }\n     }\n-  while (n < *length);\n \n  done:\n-  dtp->u.p.current_unit->bytes_left -= *length;\n+\n+  dtp->u.p.current_unit->bytes_left -= n;\n \n   if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n-    dtp->u.p.size_used += (GFC_IO_INT) *length;\n+    dtp->u.p.size_used += (GFC_IO_INT) n;\n \n   return base;\n }\n@@ -316,12 +321,11 @@ read_sf (st_parameter_dt *dtp, int *length, int no_error)\n    opened with PAD=YES.  The caller must assume tailing spaces for\n    short reads.  */\n \n-try\n-read_block_form (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n+void *\n+read_block_form (st_parameter_dt *dtp, int * nbytes)\n {\n   char *source;\n-  size_t nread;\n-  int nb;\n+  int norig;\n \n   if (!is_stream_io (dtp))\n     {\n@@ -338,15 +342,14 @@ read_block_form (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \t\t{\n \t\t  /* Not enough data left.  */\n \t\t  generate_error (&dtp->common, LIBERROR_EOR, NULL);\n-\t\t  return FAILURE;\n+\t\t  return NULL;\n \t\t}\n \t    }\n \n \t  if (unlikely (dtp->u.p.current_unit->bytes_left == 0))\n \t    {\n-\t      dtp->u.p.current_unit->endfile = AT_ENDFILE;\n-\t      generate_error (&dtp->common, LIBERROR_END, NULL);\n-\t      return FAILURE;\n+              hit_eof (dtp);\n+\t      return NULL;\n \t    }\n \n \t  *nbytes = dtp->u.p.current_unit->bytes_left;\n@@ -357,42 +360,36 @@ read_block_form (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n       (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL ||\n        dtp->u.p.current_unit->flags.access == ACCESS_STREAM))\n     {\n-      nb = *nbytes;\n-      source = read_sf (dtp, &nb, 0);\n-      *nbytes = nb;\n+      source = read_sf (dtp, nbytes, 0);\n       dtp->u.p.current_unit->strm_pos +=\n \t(gfc_offset) (*nbytes + dtp->u.p.sf_seen_eor);\n-      if (source == NULL)\n-\treturn FAILURE;\n-      memcpy (buf, source, *nbytes);\n-      return SUCCESS;\n+      return source;\n     }\n+\n+  /* If we reach here, we can assume it's direct access.  */\n+\n   dtp->u.p.current_unit->bytes_left -= (gfc_offset) *nbytes;\n \n-  nread = *nbytes;\n-  if (unlikely (sread (dtp->u.p.current_unit->s, buf, &nread) != 0))\n-    {\n-      generate_error (&dtp->common, LIBERROR_OS, NULL);\n-      return FAILURE;\n-    }\n+  norig = *nbytes;\n+  source = fbuf_read (dtp->u.p.current_unit, nbytes);\n+  fbuf_seek (dtp->u.p.current_unit, *nbytes, SEEK_CUR);\n \n   if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n-    dtp->u.p.size_used += (GFC_IO_INT) nread;\n+    dtp->u.p.size_used += (GFC_IO_INT) *nbytes;\n \n-  if (nread != *nbytes)\n-    {\t\t\t\t/* Short read, this shouldn't happen.  */\n-      if (likely (dtp->u.p.current_unit->pad_status == PAD_YES))\n-\t*nbytes = nread;\n-      else\n+  if (norig != *nbytes)\n+    {\t\t\t\t\n+      /* Short read, this shouldn't happen.  */\n+      if (!dtp->u.p.current_unit->pad_status == PAD_YES)\n \t{\n \t  generate_error (&dtp->common, LIBERROR_EOR, NULL);\n \t  source = NULL;\n \t}\n     }\n \n-  dtp->u.p.current_unit->strm_pos += (gfc_offset) nread;\n+  dtp->u.p.current_unit->strm_pos += (gfc_offset) *nbytes;\n \n-  return SUCCESS;\n+  return source;\n }\n \n \n@@ -402,18 +399,18 @@ read_block_form (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n static void\n read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n {\n-  size_t to_read_record;\n-  size_t have_read_record;\n-  size_t to_read_subrecord;\n-  size_t have_read_subrecord;\n+  ssize_t to_read_record;\n+  ssize_t have_read_record;\n+  ssize_t to_read_subrecord;\n+  ssize_t have_read_subrecord;\n   int short_record;\n \n   if (is_stream_io (dtp))\n     {\n       to_read_record = *nbytes;\n-      have_read_record = to_read_record;\n-      if (unlikely (sread (dtp->u.p.current_unit->s, buf, &have_read_record)\n-\t\t    != 0))\n+      have_read_record = sread (dtp->u.p.current_unit->s, buf, \n+\t\t\t\tto_read_record);\n+      if (unlikely (have_read_record < 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return;\n@@ -425,7 +422,7 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \t{\n \t  /* Short read,  e.g. if we hit EOF.  For stream files,\n \t   we have to set the end-of-file condition.  */\n-\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n+          hit_eof (dtp);\n \t  return;\n \t}\n       return;\n@@ -448,14 +445,14 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \n       dtp->u.p.current_unit->bytes_left -= to_read_record;\n \n-      if (unlikely (sread (dtp->u.p.current_unit->s, buf, &to_read_record)\n-\t\t    != 0))\n+      to_read_record = sread (dtp->u.p.current_unit->s, buf, to_read_record);\n+      if (unlikely (to_read_record < 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return;\n \t}\n \n-      if (to_read_record != *nbytes)  \n+      if (to_read_record != (ssize_t) *nbytes)  \n \t{\n \t  /* Short read, e.g. if we hit EOF.  Apparently, we read\n \t   more than was written to the last record.  */\n@@ -475,18 +472,12 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n      until the request has been fulfilled or the record has run out\n      of continuation subrecords.  */\n \n-  if (unlikely (dtp->u.p.current_unit->endfile == AT_ENDFILE))\n-    {\n-      generate_error (&dtp->common, LIBERROR_END, NULL);\n-      return;\n-    }\n-\n   /* Check whether we exceed the total record length.  */\n \n   if (dtp->u.p.current_unit->flags.has_recl\n       && (*nbytes > (size_t) dtp->u.p.current_unit->bytes_left))\n     {\n-      to_read_record = (size_t) dtp->u.p.current_unit->bytes_left;\n+      to_read_record = (ssize_t) dtp->u.p.current_unit->bytes_left;\n       short_record = 1;\n     }\n   else\n@@ -501,7 +492,7 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n       if (dtp->u.p.current_unit->bytes_left_subrecord\n \t  < (gfc_offset) to_read_record)\n \t{\n-\t  to_read_subrecord = (size_t) dtp->u.p.current_unit->bytes_left_subrecord;\n+\t  to_read_subrecord = (ssize_t) dtp->u.p.current_unit->bytes_left_subrecord;\n \t  to_read_record -= to_read_subrecord;\n \t}\n       else\n@@ -512,9 +503,9 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \n       dtp->u.p.current_unit->bytes_left_subrecord -= to_read_subrecord;\n \n-      have_read_subrecord = to_read_subrecord;\n-      if (unlikely (sread (dtp->u.p.current_unit->s, buf + have_read_record,\n-\t\t\t   &have_read_subrecord) != 0))\n+      have_read_subrecord = sread (dtp->u.p.current_unit->s, \n+\t\t\t\t   buf + have_read_record, to_read_subrecord);\n+      if (unlikely (have_read_subrecord) < 0)\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return;\n@@ -603,7 +594,7 @@ write_block (st_parameter_dt *dtp, int length)\n \n   if (is_internal_unit (dtp))\n     {\n-    dest = salloc_w (dtp->u.p.current_unit->s, &length);\n+    dest = mem_alloc_w (dtp->u.p.current_unit->s, &length);\n \n     if (dest == NULL)\n       {\n@@ -641,20 +632,22 @@ static try\n write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n {\n \n-  size_t have_written, to_write_subrecord;\n+  ssize_t have_written;\n+  ssize_t to_write_subrecord;\n   int short_record;\n \n   /* Stream I/O.  */\n \n   if (is_stream_io (dtp))\n     {\n-      if (unlikely (swrite (dtp->u.p.current_unit->s, buf, &nbytes) != 0))\n+      have_written = swrite (dtp->u.p.current_unit->s, buf, nbytes);\n+      if (unlikely (have_written < 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return FAILURE;\n \t}\n \n-      dtp->u.p.current_unit->strm_pos += (gfc_offset) nbytes; \n+      dtp->u.p.current_unit->strm_pos += (gfc_offset) have_written; \n \n       return SUCCESS;\n     }\n@@ -672,14 +665,15 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n       if (buf == NULL && nbytes == 0)\n \treturn SUCCESS;\n \n-      if (unlikely (swrite (dtp->u.p.current_unit->s, buf, &nbytes) != 0))\n+      have_written = swrite (dtp->u.p.current_unit->s, buf, nbytes); \n+      if (unlikely (have_written < 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return FAILURE;\n \t}\n \n-      dtp->u.p.current_unit->strm_pos += (gfc_offset) nbytes;\n-      dtp->u.p.current_unit->bytes_left -= (gfc_offset) nbytes;\n+      dtp->u.p.current_unit->strm_pos += (gfc_offset) have_written;\n+      dtp->u.p.current_unit->bytes_left -= (gfc_offset) have_written;\n \n       return SUCCESS;\n     }\n@@ -709,8 +703,9 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n       dtp->u.p.current_unit->bytes_left_subrecord -=\n \t(gfc_offset) to_write_subrecord;\n \n-      if (unlikely (swrite (dtp->u.p.current_unit->s, buf + have_written,\n-\t\t\t    &to_write_subrecord) != 0))\n+      to_write_subrecord = swrite (dtp->u.p.current_unit->s, \n+\t\t\t\t   buf + have_written, to_write_subrecord);\n+      if (unlikely (to_write_subrecord < 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return FAILURE;\n@@ -932,7 +927,6 @@ static void\n formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n \t\t\t   size_t size)\n {\n-  char scratch[SCRATCH_SIZE];\n   int pos, bytes_used;\n   const fnode *f;\n   format_token t;\n@@ -959,8 +953,6 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n   dtp->u.p.sf_read_comma =\n     dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA ? 0 : 1;\n \n-  dtp->u.p.line_buffer = scratch;\n-\n   for (;;)\n     {\n       /* If reversion has occurred and there is another real data item,\n@@ -1010,7 +1002,7 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n               if (is_internal_unit (dtp))  \n \t        move_pos_offset (dtp->u.p.current_unit->s, dtp->u.p.skips);\n               else\n-                fbuf_seek (dtp->u.p.current_unit, dtp->u.p.skips);\n+                fbuf_seek (dtp->u.p.current_unit, dtp->u.p.skips, SEEK_CUR);\n \t      dtp->u.p.current_unit->bytes_left -= (gfc_offset) dtp->u.p.skips;\n \t    }\n \t  dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n@@ -1221,7 +1213,7 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n \t\tbreak;\n \t      case BT_REAL:\n \t\tif (f->u.real.w == 0)\n-\t\t  write_real_g0 (dtp, p, kind, f->u.real.d);\n+                  write_real_g0 (dtp, p, kind, f->u.real.d);\n \t\telse\n \t\t  write_d (dtp, f, p, kind);\n \t\tbreak;\n@@ -1251,7 +1243,6 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n \t  dtp->u.p.skips += f->u.n;\n \t  pos = bytes_used + dtp->u.p.skips - 1;\n \t  dtp->u.p.pending_spaces = pos - dtp->u.p.max_pos + 1;\n-\n \t  /* Writes occur just before the switch on f->format, above, so\n \t     that trailing blanks are suppressed, unless we are doing a\n \t     non-advancing write in which case we want to output the blanks\n@@ -1316,24 +1307,17 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n \t      /* Adjust everything for end-of-record condition */\n \t      if (dtp->u.p.sf_seen_eor && !is_internal_unit (dtp))\n \t\t{\n-\t\t  if (dtp->u.p.sf_seen_eor == 2)\n-\t\t    {\n-\t\t      /* The EOR was a CRLF (two bytes wide).  */\n-\t\t      dtp->u.p.current_unit->bytes_left -= 2;\n-\t\t      dtp->u.p.skips -= 2;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      /* The EOR marker was only one byte wide.  */\n-\t\t      dtp->u.p.current_unit->bytes_left--;\n-\t\t      dtp->u.p.skips--;\n-\t\t    }\n+                  dtp->u.p.current_unit->bytes_left -= dtp->u.p.sf_seen_eor;\n+                  dtp->u.p.skips -= dtp->u.p.sf_seen_eor;\n \t\t  bytes_used = pos;\n \t\t  dtp->u.p.sf_seen_eor = 0;\n \t\t}\n \t      if (dtp->u.p.skips < 0)\n \t\t{\n-\t\t  move_pos_offset (dtp->u.p.current_unit->s, dtp->u.p.skips);\n+                  if (is_internal_unit (dtp))  \n+                    move_pos_offset (dtp->u.p.current_unit->s, dtp->u.p.skips);\n+                  else\n+                    fbuf_seek (dtp->u.p.current_unit, dtp->u.p.skips, SEEK_CUR);\n \t\t  dtp->u.p.current_unit->bytes_left\n \t\t    -= (gfc_offset) dtp->u.p.skips;\n \t\t  dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n@@ -1409,16 +1393,6 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n \t  internal_error (&dtp->common, \"Bad format node\");\n \t}\n \n-      /* Free a buffer that we had to allocate during a sequential\n-\t formatted read of a block that was larger than the static\n-\t buffer.  */\n-\n-      if (dtp->u.p.line_buffer != scratch)\n-\t{\n-\t  free_mem (dtp->u.p.line_buffer);\n-\t  dtp->u.p.line_buffer = scratch;\n-\t}\n-\n       /* Adjust the item count and data pointer.  */\n \n       if ((consume_data_flag > 0) && (n > 0))\n@@ -1657,34 +1631,28 @@ transfer_array (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n static void\n us_read (st_parameter_dt *dtp, int continued)\n {\n-  size_t n, nr;\n+  ssize_t n, nr;\n   GFC_INTEGER_4 i4;\n   GFC_INTEGER_8 i8;\n   gfc_offset i;\n \n-  if (dtp->u.p.current_unit->endfile == AT_ENDFILE)\n-    return;\n-\n   if (compile_options.record_marker == 0)\n     n = sizeof (GFC_INTEGER_4);\n   else\n     n = compile_options.record_marker;\n \n-  nr = n;\n-\n-  if (unlikely (sread (dtp->u.p.current_unit->s, &i, &n) != 0))\n+  nr = sread (dtp->u.p.current_unit->s, &i, n);\n+  if (unlikely (nr < 0))\n     {\n       generate_error (&dtp->common, LIBERROR_BAD_US, NULL);\n       return;\n     }\n-\n-  if (n == 0)\n+  else if (nr == 0)\n     {\n-      dtp->u.p.current_unit->endfile = AT_ENDFILE;\n+      hit_eof (dtp);\n       return;  /* end of file */\n     }\n-\n-  if (unlikely (n != nr))\n+  else if (unlikely (n != nr))\n     {\n       generate_error (&dtp->common, LIBERROR_BAD_US, NULL);\n       return;\n@@ -1750,7 +1718,7 @@ us_read (st_parameter_dt *dtp, int continued)\n static void\n us_write (st_parameter_dt *dtp, int continued)\n {\n-  size_t nbytes;\n+  ssize_t nbytes;\n   gfc_offset dummy;\n \n   dummy = 0;\n@@ -1760,7 +1728,7 @@ us_write (st_parameter_dt *dtp, int continued)\n   else\n     nbytes = compile_options.record_marker ;\n \n-  if (swrite (dtp->u.p.current_unit->s, &dummy, &nbytes) != 0)\n+  if (swrite (dtp->u.p.current_unit->s, &dummy, nbytes) != nbytes)\n     generate_error (&dtp->common, LIBERROR_OS, NULL);\n \n   /* For sequential unformatted, if RECL= was not specified in the OPEN\n@@ -1962,7 +1930,7 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n       return;\n     }\n \n-  /* Check the record number.  */\n+  /* Check the record or position number.  */\n \n   if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT\n       && (cf & IOPARM_DT_HAS_REC) == 0)\n@@ -2111,65 +2079,71 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n   \n   if (dtp->u.p.current_unit->pad_status == PAD_UNSPECIFIED)\n \tdtp->u.p.current_unit->pad_status = dtp->u.p.current_unit->flags.pad;\n-  \n+\n+  /* Check to see if we might be reading what we wrote before  */\n+\n+  if (dtp->u.p.mode != dtp->u.p.current_unit->mode\n+      && !is_internal_unit (dtp))\n+    {\n+      int pos = fbuf_reset (dtp->u.p.current_unit);\n+      if (pos != 0)\n+        sseek (dtp->u.p.current_unit->s, pos, SEEK_CUR);\n+      sflush(dtp->u.p.current_unit->s);\n+    }\n+\n   /* Check the POS= specifier: that it is in range and that it is used with a\n      unit that has been connected for STREAM access. F2003 9.5.1.10.  */\n   \n   if (((cf & IOPARM_DT_HAS_POS) != 0))\n     {\n       if (is_stream_io (dtp))\n-\t{\n-\n-\t  if (dtp->pos <= 0)\n-\t    {\n-\t      generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n-\t\t\t      \"POS=specifier must be positive\");\n-\t      return;\n-\t    }\n-\n-\t  if (dtp->pos >= dtp->u.p.current_unit->maxrec)\n-\t    {\n-\t      generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n-\t\t\t      \"POS=specifier too large\");\n-\t      return;\n-\t    }\n-\n-\t  dtp->rec = dtp->pos;\n-\n-\t  if (dtp->u.p.mode == READING)\n-\t    {\n-\t      /* Required for compatibility between 4.3 and 4.4 runtime. Check\n-\t      to see if we might be reading what we wrote before  */\n-\t      if (dtp->u.p.current_unit->mode == WRITING)\n-\t\t{\n-\t\t  fbuf_flush (dtp->u.p.current_unit, 1);      \n-\t\t  flush(dtp->u.p.current_unit->s);\n-\t\t}\n-\n-\t      if (dtp->pos < file_length (dtp->u.p.current_unit->s))\n-\t\tdtp->u.p.current_unit->endfile = NO_ENDFILE;\n-\t    }\n-\n-\t  if (dtp->pos != dtp->u.p.current_unit->strm_pos)\n-\t    {\n-\t      fbuf_flush (dtp->u.p.current_unit, 1);\n-\t      flush (dtp->u.p.current_unit->s);\n-\t      if (sseek (dtp->u.p.current_unit->s, dtp->pos - 1) == FAILURE)\n-\t\t{\n-\t\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n-\t\t  return;\n-\t\t}\n-\t      dtp->u.p.current_unit->strm_pos = dtp->pos;\n-\t    }\n-\t}\n+        {\n+          \n+          if (dtp->pos <= 0)\n+            {\n+              generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n+                              \"POS=specifier must be positive\");\n+              return;\n+            }\n+          \n+          if (dtp->pos >= dtp->u.p.current_unit->maxrec)\n+            {\n+              generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n+                              \"POS=specifier too large\");\n+              return;\n+            }\n+          \n+          dtp->rec = dtp->pos;\n+          \n+          if (dtp->u.p.mode == READING)\n+            {\n+              /* Reset the endfile flag; if we hit EOF during reading\n+                 we'll set the flag and generate an error at that point\n+                 rather than worrying about it here.  */\n+              dtp->u.p.current_unit->endfile = NO_ENDFILE;\n+            }\n+         \n+          if (dtp->pos != dtp->u.p.current_unit->strm_pos)\n+            {\n+              fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);\n+              sflush (dtp->u.p.current_unit->s);\n+              if (sseek (dtp->u.p.current_unit->s, dtp->pos - 1, SEEK_SET) < 0)\n+                {\n+                  generate_error (&dtp->common, LIBERROR_OS, NULL);\n+                  return;\n+                }\n+              dtp->u.p.current_unit->strm_pos = dtp->pos;\n+            }\n+        }\n       else\n-\t{\n-\t  generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n-\t\t\t  \"POS=specifier not allowed, \"\n-\t\t\t  \"Try OPEN with ACCESS='stream'\");\n-\t  return;\n-\t}\n+        {\n+          generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n+                          \"POS=specifier not allowed, \"\n+                          \"Try OPEN with ACCESS='stream'\");\n+          return;\n+        }\n     }\n+  \n \n   /* Sanity checks on the record number.  */\n   if ((cf & IOPARM_DT_HAS_REC) != 0)\n@@ -2188,15 +2162,10 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \t  return;\n \t}\n \n-      /* Check to see if we might be reading what we wrote before  */\n+      /* Make sure format buffer is reset.  */\n+      if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED)\n+        fbuf_reset (dtp->u.p.current_unit);\n \n-      if (dtp->u.p.mode == READING\n-\t  && dtp->u.p.current_unit->mode == WRITING\n-\t  && !is_internal_unit (dtp))\n-\t{\n-\t  fbuf_flush (dtp->u.p.current_unit, 1);      \n-\t  flush(dtp->u.p.current_unit->s);\n-\t}\n \n       /* Check whether the record exists to be read.  Only\n \t a partial record needs to exist.  */\n@@ -2211,37 +2180,28 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \n       /* Position the file.  */\n       if (sseek (dtp->u.p.current_unit->s, (gfc_offset) (dtp->rec - 1)\n-\t\t * dtp->u.p.current_unit->recl) == FAILURE)\n-\t{\n-\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n-\t  return;\n-\t}\n+                 * dtp->u.p.current_unit->recl, SEEK_SET) < 0)\n+        {\n+          generate_error (&dtp->common, LIBERROR_OS, NULL);\n+          return;\n+        }\n \n       /* TODO: This is required to maintain compatibility between\n-\t 4.3 and 4.4 runtime. Remove when ABI changes from 4.3 */\n+         4.3 and 4.4 runtime. Remove when ABI changes from 4.3 */\n \n       if (is_stream_io (dtp))\n-\tdtp->u.p.current_unit->strm_pos = dtp->rec;\n-      \n+        dtp->u.p.current_unit->strm_pos = dtp->rec;\n+\n       /* TODO: Un-comment this code when ABI changes from 4.3.\n       if (dtp->u.p.current_unit->flags.access == ACCESS_STREAM)\n-\t{\n-\t  generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n-\t\t      \"Record number not allowed for stream access \"\n-\t\t      \"data transfer\");\n-\t  return;\n-\t}  */\n-\n+       {\n+         generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n+                     \"Record number not allowed for stream access \"\n+                     \"data transfer\");\n+         return;\n+       }  */\n     }\n \n-  /* Overwriting an existing sequential file ?\n-     it is always safe to truncate the file on the first write */\n-  if (dtp->u.p.mode == WRITING\n-      && dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL\n-      && dtp->u.p.current_unit->last_record == 0 \n-      && !is_preconnected(dtp->u.p.current_unit->s))\n-\tstruncate(dtp->u.p.current_unit->s);\n-\n   /* Bugware for badly written mixed C-Fortran I/O.  */\n   flush_if_preconnected(dtp->u.p.current_unit->s);\n \n@@ -2394,8 +2354,8 @@ next_array_record (st_parameter_dt *dtp, array_loop_spec *ls, int *finished)\n static void\n skip_record (st_parameter_dt *dtp, size_t bytes)\n {\n-  gfc_offset new;\n   size_t rlength;\n+  ssize_t readb;\n   static const size_t MAX_READ = 4096;\n   char p[MAX_READ];\n \n@@ -2405,29 +2365,28 @@ skip_record (st_parameter_dt *dtp, size_t bytes)\n \n   if (is_seekable (dtp->u.p.current_unit->s))\n     {\n-      new = file_position (dtp->u.p.current_unit->s)\n-\t+ dtp->u.p.current_unit->bytes_left_subrecord;\n-\n       /* Direct access files do not generate END conditions,\n \t only I/O errors.  */\n-      if (sseek (dtp->u.p.current_unit->s, new) == FAILURE)\n+      if (sseek (dtp->u.p.current_unit->s, \n+\t\t dtp->u.p.current_unit->bytes_left_subrecord, SEEK_CUR) < 0)\n \tgenerate_error (&dtp->common, LIBERROR_OS, NULL);\n     }\n   else\n     {\t\t\t/* Seek by reading data.  */\n       while (dtp->u.p.current_unit->bytes_left_subrecord > 0)\n \t{\n \t  rlength = \n-\t    (MAX_READ > (size_t) dtp->u.p.current_unit->bytes_left_subrecord) ?\n+\t    (MAX_READ < (size_t) dtp->u.p.current_unit->bytes_left_subrecord) ?\n \t    MAX_READ : (size_t) dtp->u.p.current_unit->bytes_left_subrecord;\n \n-\t  if (sread (dtp->u.p.current_unit->s, p, &rlength) != 0)\n+\t  readb = sread (dtp->u.p.current_unit->s, p, rlength);\n+\t  if (readb < 0)\n \t    {\n \t      generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t      return;\n \t    }\n \n-\t  dtp->u.p.current_unit->bytes_left_subrecord -= rlength;\n+\t  dtp->u.p.current_unit->bytes_left_subrecord -= readb;\n \t}\n     }\n \n@@ -2475,8 +2434,8 @@ next_record_r (st_parameter_dt *dtp)\n {\n   gfc_offset record;\n   int bytes_left;\n-  size_t length;\n   char p;\n+  int cc;\n \n   switch (current_mode (dtp))\n     {\n@@ -2496,11 +2455,12 @@ next_record_r (st_parameter_dt *dtp)\n \n     case FORMATTED_STREAM:\n     case FORMATTED_SEQUENTIAL:\n-      length = 1;\n-      /* sf_read has already terminated input because of an '\\n'  */\n-      if (dtp->u.p.sf_seen_eor)\n+      /* read_sf has already terminated input because of an '\\n', or\n+         we have hit EOF.  */\n+      if (dtp->u.p.sf_seen_eor || dtp->u.p.at_eof)\n \t{\n \t  dtp->u.p.sf_seen_eor = 0;\n+          dtp->u.p.at_eof = 0;\n \t  break;\n \t}\n \n@@ -2515,7 +2475,7 @@ next_record_r (st_parameter_dt *dtp)\n \n \t      /* Now seek to this record.  */\n \t      record = record * dtp->u.p.current_unit->recl;\n-\t      if (sseek (dtp->u.p.current_unit->s, record) == FAILURE)\n+\t      if (sseek (dtp->u.p.current_unit->s, record, SEEK_SET) < 0)\n \t\t{\n \t\t  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t\t  break;\n@@ -2527,10 +2487,9 @@ next_record_r (st_parameter_dt *dtp)\n \t      bytes_left = (int) dtp->u.p.current_unit->bytes_left;\n \t      bytes_left = min_off (bytes_left, \n \t\t      file_length (dtp->u.p.current_unit->s)\n-\t\t      - file_position (dtp->u.p.current_unit->s));\n+\t\t      - stell (dtp->u.p.current_unit->s));\n \t      if (sseek (dtp->u.p.current_unit->s, \n-\t\t\t  file_position (dtp->u.p.current_unit->s) \n-\t\t\t  + bytes_left) == FAILURE)\n+\t\t\t bytes_left, SEEK_CUR) < 0)\n \t        {\n \t\t  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t\t  break;\n@@ -2540,42 +2499,37 @@ next_record_r (st_parameter_dt *dtp)\n \t    } \n \t  break;\n \t}\n-      else do\n+      else \n \t{\n-\t  if (sread (dtp->u.p.current_unit->s, &p, &length) != 0) \n+\t  do\n \t    {\n-\t      generate_error (&dtp->common, LIBERROR_OS, NULL);\n-\t      break;\n-\t    }\n-\n-\t  if (length == 0)\n-\t    {\n-\t      dtp->u.p.current_unit->endfile = AT_ENDFILE;\n-\t      break;\n+              errno = 0;\n+              cc = fbuf_getc (dtp->u.p.current_unit);\n+\t      if (cc == EOF) \n+\t\t{\n+                  if (errno != 0)\n+                    generate_error (&dtp->common, LIBERROR_OS, NULL);\n+                  else\n+                    hit_eof (dtp);\n+\t\t  break;\n+                }\n+\t      \n+\t      if (is_stream_io (dtp))\n+\t\tdtp->u.p.current_unit->strm_pos++;\n+              \n+              p = (char) cc;\n \t    }\n-\n-\t  if (is_stream_io (dtp))\n-\t    dtp->u.p.current_unit->strm_pos++;\n+\t  while (p != '\\n');\n \t}\n-      while (p != '\\n');\n-\n       break;\n     }\n-\n-  if (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL\n-      && !dtp->u.p.namelist_mode\n-      && dtp->u.p.current_unit->endfile == NO_ENDFILE\n-      && (file_length (dtp->u.p.current_unit->s) ==\n-\t file_position (dtp->u.p.current_unit->s)))\n-    dtp->u.p.current_unit->endfile = AT_ENDFILE;\n-\n }\n \n \n /* Small utility function to write a record marker, taking care of\n    byte swapping and of choosing the correct size.  */\n \n-inline static int\n+static int\n write_us_marker (st_parameter_dt *dtp, const gfc_offset buf)\n {\n   size_t len;\n@@ -2595,12 +2549,12 @@ write_us_marker (st_parameter_dt *dtp, const gfc_offset buf)\n \t{\n \tcase sizeof (GFC_INTEGER_4):\n \t  buf4 = buf;\n-\t  return swrite (dtp->u.p.current_unit->s, &buf4, &len);\n+\t  return swrite (dtp->u.p.current_unit->s, &buf4, len);\n \t  break;\n \n \tcase sizeof (GFC_INTEGER_8):\n \t  buf8 = buf;\n-\t  return swrite (dtp->u.p.current_unit->s, &buf8, &len);\n+\t  return swrite (dtp->u.p.current_unit->s, &buf8, len);\n \t  break;\n \n \tdefault:\n@@ -2615,13 +2569,13 @@ write_us_marker (st_parameter_dt *dtp, const gfc_offset buf)\n \tcase sizeof (GFC_INTEGER_4):\n \t  buf4 = buf;\n \t  reverse_memcpy (p, &buf4, sizeof (GFC_INTEGER_4));\n-\t  return swrite (dtp->u.p.current_unit->s, p, &len);\n+\t  return swrite (dtp->u.p.current_unit->s, p, len);\n \t  break;\n \n \tcase sizeof (GFC_INTEGER_8):\n \t  buf8 = buf;\n \t  reverse_memcpy (p, &buf8, sizeof (GFC_INTEGER_8));\n-\t  return swrite (dtp->u.p.current_unit->s, p, &len);\n+\t  return swrite (dtp->u.p.current_unit->s, p, len);\n \t  break;\n \n \tdefault:\n@@ -2644,7 +2598,7 @@ next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)\n   /* Bytes written.  */\n   m = dtp->u.p.current_unit->recl_subrecord\n     - dtp->u.p.current_unit->bytes_left_subrecord;\n-  c = file_position (dtp->u.p.current_unit->s);\n+  c = stell (dtp->u.p.current_unit->s);\n \n   /* Write the length tail.  If we finish a record containing\n      subrecords, we write out the negative length.  */\n@@ -2654,7 +2608,7 @@ next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)\n   else\n     m_write = m;\n \n-  if (unlikely (write_us_marker (dtp, m_write) != 0))\n+  if (unlikely (write_us_marker (dtp, m_write) < 0))\n     goto io_error;\n \n   if (compile_options.record_marker == 0)\n@@ -2665,22 +2619,22 @@ next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)\n   /* Seek to the head and overwrite the bogus length with the real\n      length.  */\n \n-  if (unlikely (sseek (dtp->u.p.current_unit->s, c - m - record_marker)\n-\t\t== FAILURE))\n+  if (unlikely (sseek (dtp->u.p.current_unit->s, c - m - record_marker, \n+\t\t       SEEK_SET) < 0))\n     goto io_error;\n \n   if (next_subrecord)\n     m_write = -m;\n   else\n     m_write = m;\n \n-  if (unlikely (write_us_marker (dtp, m_write) != 0))\n+  if (unlikely (write_us_marker (dtp, m_write) < 0))\n     goto io_error;\n \n   /* Seek past the end of the current record.  */\n \n-  if (unlikely (sseek (dtp->u.p.current_unit->s, c + record_marker)\n-\t\t== FAILURE))\n+  if (unlikely (sseek (dtp->u.p.current_unit->s, c + record_marker, \n+\t\t       SEEK_SET) < 0))\n     goto io_error;\n \n   return;\n@@ -2691,6 +2645,35 @@ next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)\n \n }\n \n+\n+/* Utility function like memset() but operating on streams. Return\n+   value is same as for POSIX write().  */\n+\n+static ssize_t\n+sset (stream * s, int c, ssize_t nbyte)\n+{\n+  static const int WRITE_CHUNK = 256;\n+  char p[WRITE_CHUNK];\n+  ssize_t bytes_left, trans;\n+\n+  if (nbyte < WRITE_CHUNK)\n+    memset (p, c, nbyte);\n+  else\n+    memset (p, c, WRITE_CHUNK);\n+\n+  bytes_left = nbyte;\n+  while (bytes_left > 0)\n+    {\n+      trans = (bytes_left < WRITE_CHUNK) ? bytes_left : WRITE_CHUNK;\n+      trans = swrite (s, p, trans);\n+      if (trans < 0)\n+\treturn trans;\n+      bytes_left -= trans;\n+    }\n+\t       \n+  return nbyte - bytes_left;\n+}\n+\n /* Position to the next record in write mode.  */\n \n static void\n@@ -2699,9 +2682,6 @@ next_record_w (st_parameter_dt *dtp, int done)\n   gfc_offset m, record, max_pos;\n   int length;\n \n-  /* Flush and reset the format buffer.  */\n-  fbuf_flush (dtp->u.p.current_unit, 1);\n-  \n   /* Zero counters for X- and T-editing.  */\n   max_pos = dtp->u.p.max_pos;\n   dtp->u.p.max_pos = dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n@@ -2716,8 +2696,11 @@ next_record_w (st_parameter_dt *dtp, int done)\n       if (dtp->u.p.current_unit->bytes_left == 0)\n \tbreak;\n \n+      fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);\n+      fbuf_flush (dtp->u.p.current_unit, WRITING);\n       if (sset (dtp->u.p.current_unit->s, ' ', \n-\t\tdtp->u.p.current_unit->bytes_left) == FAILURE)\n+\t\tdtp->u.p.current_unit->bytes_left) \n+\t  != dtp->u.p.current_unit->bytes_left)\n \tgoto io_error;\n \n       break;\n@@ -2726,7 +2709,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n       if (dtp->u.p.current_unit->bytes_left > 0)\n \t{\n \t  length = (int) dtp->u.p.current_unit->bytes_left;\n-\t  if (sset (dtp->u.p.current_unit->s, 0, length) == FAILURE)\n+\t  if (sset (dtp->u.p.current_unit->s, 0, length) != length)\n \t    goto io_error;\n \t}\n       break;\n@@ -2757,16 +2740,15 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t\t{\n \t\t  length = (int) (max_pos - m);\n \t\t  if (sseek (dtp->u.p.current_unit->s, \n-\t\t\t      file_position (dtp->u.p.current_unit->s) \n-\t\t\t      + length) == FAILURE)\n+\t\t\t     length, SEEK_CUR) < 0)\n \t\t    {\n \t\t      generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t\t      return;\n \t\t    }\n \t\t  length = (int) (dtp->u.p.current_unit->recl - max_pos);\n \t\t}\n \n-\t      if (sset (dtp->u.p.current_unit->s, ' ', length) == FAILURE)\n+\t      if (sset (dtp->u.p.current_unit->s, ' ', length) != length)\n \t\t{\n \t\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n \t\t  return;\n@@ -2782,7 +2764,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t      /* Now seek to this record */\n \t      record = record * dtp->u.p.current_unit->recl;\n \n-\t      if (sseek (dtp->u.p.current_unit->s, record) == FAILURE)\n+\t      if (sseek (dtp->u.p.current_unit->s, record, SEEK_SET) < 0)\n \t\t{\n \t\t  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t\t  return;\n@@ -2805,8 +2787,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t\t    {\n \t\t      length = (int) (max_pos - m);\n \t\t      if (sseek (dtp->u.p.current_unit->s, \n-\t\t\t\t  file_position (dtp->u.p.current_unit->s)\n-\t\t\t\t  + length) == FAILURE)\n+\t\t\t\t length, SEEK_CUR) < 0)\n \t\t        {\n \t\t\t  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t\t\t  return;\n@@ -2817,7 +2798,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t\t    length = (int) dtp->u.p.current_unit->bytes_left;\n \t\t}\n \n-\t      if (sset (dtp->u.p.current_unit->s, ' ', length) == FAILURE)\n+\t      if (sset (dtp->u.p.current_unit->s, ' ', length) != length)\n \t\t{\n \t\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n \t\t  return;\n@@ -2826,23 +2807,27 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t}\n       else\n \t{\n-\t  size_t len;\n-\t  const char crlf[] = \"\\r\\n\";\n-\n #ifdef HAVE_CRLF\n-\t  len = 2;\n+\t  const int len = 2;\n #else\n-\t  len = 1;\n+\t  const int len = 1;\n #endif\n-\t  if (swrite (dtp->u.p.current_unit->s, &crlf[2-len], &len) != 0)\n-\t    goto io_error;\n-\t  \n+          fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);\n+          char * p = fbuf_alloc (dtp->u.p.current_unit, len);\n+          if (!p)\n+            goto io_error;\n+#ifdef HAVE_CRLF\n+          *(p++) = '\\r';\n+#endif\n+          *p = '\\n';\n \t  if (is_stream_io (dtp))\n \t    {\n \t      dtp->u.p.current_unit->strm_pos += len;\n \t      if (dtp->u.p.current_unit->strm_pos\n \t\t  < file_length (dtp->u.p.current_unit->s))\n-\t\tstruncate (dtp->u.p.current_unit->s);\n+\t\tunit_truncate (dtp->u.p.current_unit,\n+                               dtp->u.p.current_unit->strm_pos - 1,\n+                               &dtp->common);\n \t    }\n \t}\n \n@@ -2880,7 +2865,7 @@ next_record (st_parameter_dt *dtp, int done)\n       dtp->u.p.current_unit->current_record = 0;\n       if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)\n \t{\n-\t  fp = file_position (dtp->u.p.current_unit->s);\n+\t  fp = stell (dtp->u.p.current_unit->s);\n \t  /* Calculate next record, rounding up partial records.  */\n \t  dtp->u.p.current_unit->last_record =\n \t    (fp + dtp->u.p.current_unit->recl - 1) /\n@@ -2892,6 +2877,8 @@ next_record (st_parameter_dt *dtp, int done)\n \n   if (!done)\n     pre_position (dtp);\n+\n+  fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);\n }\n \n \n@@ -2940,7 +2927,6 @@ finalize_transfer (st_parameter_dt *dtp)\n   if ((cf & IOPARM_DT_LIST_FORMAT) != 0 && dtp->u.p.mode == READING)\n     {\n       finish_list_read (dtp);\n-      sfree (dtp->u.p.current_unit->s);\n       return;\n     }\n \n@@ -2955,10 +2941,9 @@ finalize_transfer (st_parameter_dt *dtp)\n \tnext_record (dtp, 1);\n \n       if (dtp->u.p.current_unit->flags.form == FORM_UNFORMATTED\n-\t  && file_position (dtp->u.p.current_unit->s) >= dtp->rec)\n+\t  && stell (dtp->u.p.current_unit->s) >= dtp->rec)\n \t{\n-\t  flush (dtp->u.p.current_unit->s);\n-\t  sfree (dtp->u.p.current_unit->s);\n+\t  sflush (dtp->u.p.current_unit->s);\n \t}\n       return;\n     }\n@@ -2967,9 +2952,8 @@ finalize_transfer (st_parameter_dt *dtp)\n \n   if (!is_internal_unit (dtp) && dtp->u.p.seen_dollar)\n     {\n+      fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);\n       dtp->u.p.seen_dollar = 0;\n-      fbuf_flush (dtp->u.p.current_unit, 1);\n-      sfree (dtp->u.p.current_unit->s);\n       return;\n     }\n \n@@ -2981,15 +2965,17 @@ finalize_transfer (st_parameter_dt *dtp)\n \t- dtp->u.p.current_unit->bytes_left);\n       dtp->u.p.current_unit->saved_pos =\n \tdtp->u.p.max_pos > 0 ? dtp->u.p.max_pos - bytes_written : 0;\n-      fbuf_flush (dtp->u.p.current_unit, 0);\n-      flush (dtp->u.p.current_unit->s);\n+      fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);\n+      sflush (dtp->u.p.current_unit->s);\n       return;\n     }\n+  else if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED \n+           && dtp->u.p.mode == WRITING && !is_internal_unit (dtp))\n+      fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);    \n \n   dtp->u.p.current_unit->saved_pos = 0;\n \n   next_record (dtp, 1);\n-  sfree (dtp->u.p.current_unit->s);\n }\n \n /* Transfer function for IOLENGTH. It doesn't actually do any\n@@ -3046,8 +3032,6 @@ void\n st_iolength_done (st_parameter_dt *dtp __attribute__((unused)))\n {\n   free_ionml (dtp);\n-  if (dtp->u.p.scratch != NULL)\n-    free_mem (dtp->u.p.scratch);\n   library_end ();\n }\n \n@@ -3063,29 +3047,6 @@ st_read (st_parameter_dt *dtp)\n   library_start (&dtp->common);\n \n   data_transfer_init (dtp, 1);\n-\n-  /* Handle complications dealing with the endfile record.  */\n-\n-  if (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)\n-    switch (dtp->u.p.current_unit->endfile)\n-      {\n-      case NO_ENDFILE:\n-\tbreak;\n-\n-      case AT_ENDFILE:\n-\tif (!is_internal_unit (dtp))\n-\t  {\n-\t    generate_error (&dtp->common, LIBERROR_END, NULL);\n-\t    dtp->u.p.current_unit->endfile = AFTER_ENDFILE;\n-\t    dtp->u.p.current_unit->current_record = 0;\n-\t  }\n-\tbreak;\n-\n-      case AFTER_ENDFILE:\n-\tgenerate_error (&dtp->common, LIBERROR_ENDFILE, NULL);\n-\tdtp->u.p.current_unit->current_record = 0;\n-\tbreak;\n-      }\n }\n \n extern void st_read_done (st_parameter_dt *);\n@@ -3097,8 +3058,6 @@ st_read_done (st_parameter_dt *dtp)\n   finalize_transfer (dtp);\n   free_format_data (dtp);\n   free_ionml (dtp);\n-  if (dtp->u.p.scratch != NULL)\n-    free_mem (dtp->u.p.scratch);\n   if (dtp->u.p.current_unit != NULL)\n     unlock_unit (dtp->u.p.current_unit);\n \n@@ -3141,19 +3100,15 @@ st_write_done (st_parameter_dt *dtp)\n       case NO_ENDFILE:\n \t/* Get rid of whatever is after this record.  */\n         if (!is_internal_unit (dtp))\n-\t  {\n-\t    flush (dtp->u.p.current_unit->s);\n-\t    if (struncate (dtp->u.p.current_unit->s) == FAILURE)\n-\t      generate_error (&dtp->common, LIBERROR_OS, NULL);\n-\t  }\n+          unit_truncate (dtp->u.p.current_unit, \n+                         stell (dtp->u.p.current_unit->s),\n+                         &dtp->common);\n \tdtp->u.p.current_unit->endfile = AT_ENDFILE;\n \tbreak;\n       }\n \n   free_format_data (dtp);\n   free_ionml (dtp);\n-  if (dtp->u.p.scratch != NULL)\n-    free_mem (dtp->u.p.scratch);\n   if (dtp->u.p.current_unit != NULL)\n     unlock_unit (dtp->u.p.current_unit);\n   \n@@ -3267,3 +3222,46 @@ void reverse_memcpy (void *dest, const void *src, size_t n)\n   for (i=0; i<n; i++)\n       *(d++) = *(s--);\n }\n+\n+\n+/* Once upon a time, a poor innocent Fortran program was reading a\n+   file, when suddenly it hit the end-of-file (EOF).  Unfortunately\n+   the OS doesn't tell whether we're at the EOF or whether we already\n+   went past it.  Luckily our hero, libgfortran, keeps track of this.\n+   Call this function when you detect an EOF condition.  See Section\n+   9.10.2 in F2003.  */\n+\n+void\n+hit_eof (st_parameter_dt * dtp)\n+{\n+  dtp->u.p.current_unit->flags.position = POSITION_APPEND;\n+\n+  if (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)\n+    switch (dtp->u.p.current_unit->endfile)\n+      {\n+      case NO_ENDFILE:\n+      case AT_ENDFILE:\n+        generate_error (&dtp->common, LIBERROR_END, NULL);\n+\tif (!is_internal_unit (dtp))\n+\t  {\n+\t    dtp->u.p.current_unit->endfile = AFTER_ENDFILE;\n+\t    dtp->u.p.current_unit->current_record = 0;\n+\t  }\n+        else\n+          dtp->u.p.current_unit->endfile = AT_ENDFILE;\n+\tbreak;\n+        \n+      case AFTER_ENDFILE:\n+\tgenerate_error (&dtp->common, LIBERROR_ENDFILE, NULL);\n+\tdtp->u.p.current_unit->current_record = 0;\n+\tbreak;\n+      }\n+  else\n+    {\n+      /* Non-sequential files don't have an ENDFILE record, so we\n+         can't be at AFTER_ENDFILE.  */\n+      dtp->u.p.current_unit->endfile = AT_ENDFILE;\n+      generate_error (&dtp->common, LIBERROR_END, NULL);\n+      dtp->u.p.current_unit->current_record = 0;\n+    }\n+}"}, {"sha": "21d4074e1a709aa4c64300937c28746d82a0f3c5", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 62, "deletions": 11, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e544d738ad9dd9251db1eb43592c5306270e230/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e544d738ad9dd9251db1eb43592c5306270e230/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=9e544d738ad9dd9251db1eb43592c5306270e230", "patch": "@@ -540,6 +540,8 @@ init_units (void)\n       u->file_len = strlen (stdin_name);\n       u->file = get_mem (u->file_len);\n       memmove (u->file, stdin_name, u->file_len);\n+\n+      fbuf_init (u, 0);\n     \n       __gthread_mutex_unlock (&u->lock);\n     }\n@@ -697,15 +699,62 @@ close_units (void)\n void\n update_position (gfc_unit *u)\n {\n-  if (file_position (u->s) == 0)\n+  if (stell (u->s) == 0)\n     u->flags.position = POSITION_REWIND;\n-  else if (file_length (u->s) == file_position (u->s))\n+  else if (file_length (u->s) == stell (u->s))\n     u->flags.position = POSITION_APPEND;\n   else\n     u->flags.position = POSITION_ASIS;\n }\n \n \n+/* High level interface to truncate a file safely, i.e. flush format\n+   buffers, check that it's a regular file, and generate error if that\n+   occurs.  Just like POSIX ftruncate, returns 0 on success, -1 on\n+   failure.  */\n+\n+int\n+unit_truncate (gfc_unit * u, gfc_offset pos, st_parameter_common * common)\n+{\n+  int ret;\n+\n+  /* Make sure format buffer is flushed.  */\n+  if (u->flags.form == FORM_FORMATTED)\n+    {\n+      if (u->mode == READING)\n+\tpos += fbuf_reset (u);\n+      else\n+\tfbuf_flush (u, u->mode);\n+    }\n+  \n+  /* Don't try to truncate a special file, just pretend that it\n+     succeeds.  */\n+  if (is_special (u->s) || !is_seekable (u->s))\n+    {\n+      sflush (u->s);\n+      return 0;\n+    }\n+\n+  /* struncate() should flush the stream buffer if necessary, so don't\n+     bother calling sflush() here.  */\n+  ret = struncate (u->s, pos);\n+\n+  if (ret != 0)\n+    {\n+      generate_error (common, LIBERROR_OS, NULL);\n+      u->endfile = NO_ENDFILE;\n+      u->flags.position = POSITION_ASIS;\n+    }\n+  else\n+    {\n+      u->endfile = AT_ENDFILE;\n+      u->flags.position = POSITION_APPEND;\n+    }\n+\n+  return ret;\n+}\n+\n+\n /* filename_from_unit()-- If the unit_number exists, return a pointer to the\n    name of the associated file, otherwise return the empty string.  The caller\n    must free memory allocated for the filename string.  */\n@@ -746,23 +795,25 @@ finish_last_advance_record (gfc_unit *u)\n {\n   \n   if (u->saved_pos > 0)\n-    fbuf_seek (u, u->saved_pos);\n-    \n-  fbuf_flush (u, 1);\n+    fbuf_seek (u, u->saved_pos, SEEK_CUR);\n \n   if (!(u->unit_number == options.stdout_unit\n \t|| u->unit_number == options.stderr_unit))\n     {\n-      size_t len;\n-\n-      const char crlf[] = \"\\r\\n\";\n #ifdef HAVE_CRLF\n-      len = 2;\n+      const int len = 2;\n #else\n-      len = 1;\n+      const int len = 1;\n #endif\n-      if (swrite (u->s, &crlf[2-len], &len) != 0)\n+      char *p = fbuf_alloc (u, len);\n+      if (!p)\n \tos_error (\"Completing record after ADVANCE_NO failed\");\n+#ifdef HAVE_CRLF\n+      *(p++) = '\\r';\n+#endif\n+      *p = '\\n';\n     }\n+\n+  fbuf_flush (u, u->mode);\n }\n "}]}