{"sha": "36846b26721512effe580079a9ef6b982c651cb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY4NDZiMjY3MjE1MTJlZmZlNTgwMDc5YTllZjZiOTgyYzY1MWNiOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-01-19T17:14:31Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-01-19T17:14:31Z"}, "message": "mn10300: Cleanup legitimate addresses\n\nAllow REG+REG and POST_MODIFY addressing for AM33.  Fix AM33 base and\nindex register classes.  Remove a bunch of register class combinations\nthat aren't really useful after this cleanup.\n\nFrom-SVN: r169006", "tree": {"sha": "74d79658c20eaf38043ebd82ab72890515b6e4ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74d79658c20eaf38043ebd82ab72890515b6e4ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36846b26721512effe580079a9ef6b982c651cb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36846b26721512effe580079a9ef6b982c651cb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36846b26721512effe580079a9ef6b982c651cb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36846b26721512effe580079a9ef6b982c651cb8/comments", "author": null, "committer": null, "parents": [{"sha": "8b119bb67de0c95e25150b8a280878af67cb3eb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b119bb67de0c95e25150b8a280878af67cb3eb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b119bb67de0c95e25150b8a280878af67cb3eb6"}], "stats": {"total": 272, "additions": 175, "deletions": 97}, "files": [{"sha": "7ef09ccaae78851ba652962d8bea57a6d2483908", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36846b26721512effe580079a9ef6b982c651cb8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36846b26721512effe580079a9ef6b982c651cb8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=36846b26721512effe580079a9ef6b982c651cb8", "patch": "@@ -1,5 +1,33 @@\n 2011-01-19  Richard Henderson  <rth@redhat.com>\n \n+\t* config/mn10300/mn10300.c (mn10300_print_operand_address): Handle\n+\tPOST_MODIFY.\n+\t(mn10300_secondary_reload): Tidy combination reload classes.\n+\t(mn10300_legitimate_address_p): Allow post-modify and reg+reg\n+\taddresses for AM33.  Allow symbolic offsets for reg+imm.\n+\t(mn10300_regno_in_class_p): New.\n+\t(mn10300_legitimize_reload_address): New.\n+\t* config/mn10300/mn10300.h (enum reg_class): Remove\n+\tDATA_OR_ADDRESS_REGS, DATA_OR_EXTENDED_REGS, ADDRESS_OR_EXTENDED_REGS,\n+\tSP_OR_EXTENDED_REGS, SP_OR_ADDRESS_OR_EXTENDED_REGS.  Add\n+\tSP_OR_GENERAL_REGS.\n+\t(REG_CLASS_NAMES): Update to match.\n+\t(REG_CLASS_CONTENTS): Likewise.\n+\t(INDEX_REG_CLASS): Use GENERAL_REGS for AM33.\n+\t(BASE_REG_CLASS): Use SP_OR_GENERAL_REGS for AM33.\n+\t(REGNO_IN_RANGE_P): Remove.\n+\t(REGNO_DATA_P): Use mn10300_regno_in_class_p.\n+\t(REGNO_ADDRESS_P, REGNO_EXTENDED_P): Likewise.\n+\t(REGNO_STRICT_OK_FOR_BASE_P): Likewise.\n+\t(REGNO_STRICT_OK_FOR_BIT_BASE_P): Likewise.\n+\t(REGNO_STRICT_OK_FOR_INDEX_P): Likewise.\n+\t(REGNO_SP_P, REGNO_AM33_P, REGNO_FP_P): Remove.\n+\t(REGNO_GENERAL_P): New.\n+\t(HAVE_POST_MODIFY_DISP): New.\n+\t(USE_LOAD_POST_INCREMENT, USE_STORE_POST_INCREMENT): New.\n+\t(LEGITIMIZE_RELOAD_ADDRESS): New.\n+\t* config/mn10300/mn10300-protos.h: Update.\n+\n \t* config/mn10300/mn10300.c (mn10300_preferred_reload_class): Allow\n \tDATA_REGS for AM33 stack-pointer destination.\n \t(mn10300_preferred_output_reload_class): Likewise."}, {"sha": "d0ce1b3f7b648aa2427ddb015e133530e030c3dd", "filename": "gcc/config/mn10300/mn10300-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36846b26721512effe580079a9ef6b982c651cb8/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36846b26721512effe580079a9ef6b982c651cb8/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h?ref=36846b26721512effe580079a9ef6b982c651cb8", "patch": "@@ -26,6 +26,7 @@\n #ifdef RTX_CODE\n extern rtx   mn10300_legitimize_pic_address (rtx, rtx);\n extern int   mn10300_legitimate_pic_operand_p (rtx);\n+extern rtx   mn10300_legitimize_reload_address (rtx, Mmode, int, int, int);\n extern bool  mn10300_function_value_regno_p (const unsigned int);\n extern int   mn10300_get_live_callee_saved_regs (void);\n extern bool  mn10300_hard_regno_mode_ok (unsigned int, Mmode);\n@@ -40,6 +41,7 @@ extern int   mn10300_store_multiple_operation (rtx, Mmode);\n extern int   mn10300_symbolic_operand (rtx, Mmode);\n #endif /* RTX_CODE */\n \n+extern bool  mn10300_regno_in_class_p (unsigned, int, bool);\n extern int   mn10300_can_use_return_insn (void);\n extern void  mn10300_expand_prologue (void);\n extern void  mn10300_expand_epilogue (void);"}, {"sha": "197ff85a6f00e8cbe9bd52227261f2815fcf7567", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 108, "deletions": 49, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36846b26721512effe580079a9ef6b982c651cb8/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36846b26721512effe580079a9ef6b982c651cb8/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=36846b26721512effe580079a9ef6b982c651cb8", "patch": "@@ -495,26 +495,38 @@ mn10300_print_operand_address (FILE *file, rtx addr)\n   switch (GET_CODE (addr))\n     {\n     case POST_INC:\n-      mn10300_print_operand_address (file, XEXP (addr, 0));\n+      mn10300_print_operand (file, XEXP (addr, 0), 0);\n       fputc ('+', file);\n       break;\n+\n+    case POST_MODIFY:\n+      mn10300_print_operand (file, XEXP (addr, 0), 0);\n+      fputc ('+', file);\n+      fputc (',', file);\n+      mn10300_print_operand (file, XEXP (addr, 1), 0);\n+      break;\n+\n     case REG:\n       mn10300_print_operand (file, addr, 0);\n       break;\n     case PLUS:\n       {\n-\trtx base, index;\n-\tif (REG_P (XEXP (addr, 0))\n-\t    && REG_OK_FOR_BASE_P (XEXP (addr, 0)))\n-\t  base = XEXP (addr, 0), index = XEXP (addr, 1);\n-\telse if (REG_P (XEXP (addr, 1))\n-\t    && REG_OK_FOR_BASE_P (XEXP (addr, 1)))\n-\t  base = XEXP (addr, 1), index = XEXP (addr, 0);\n-      \telse\n-\t  gcc_unreachable ();\n+\trtx base = XEXP (addr, 0);\n+\trtx index = XEXP (addr, 1);\n+\t\n+\tif (REG_P (index) && !REG_OK_FOR_INDEX_P (index))\n+\t  {\n+\t    rtx x = base;\n+\t    base = index;\n+\t    index = x;\n+\n+\t    gcc_assert (REG_P (index) && REG_OK_FOR_INDEX_P (index));\n+\t  }\n+\tgcc_assert (REG_OK_FOR_BASE_P (base));\n+\n \tmn10300_print_operand (file, index, 0);\n \tfputc (',', file);\n-\tmn10300_print_operand (file, base, 0);;\n+\tmn10300_print_operand (file, base, 0);\n \tbreak;\n       }\n     case SYMBOL_REF:\n@@ -1395,8 +1407,7 @@ mn10300_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n   if (in_p\n       && rclass != SP_REGS\n       && rclass != SP_OR_ADDRESS_REGS\n-      && rclass != SP_OR_EXTENDED_REGS\n-      && rclass != SP_OR_ADDRESS_OR_EXTENDED_REGS\n+      && rclass != SP_OR_GENERAL_REGS\n       && GET_CODE (x) == PLUS\n       && (XEXP (x, 0) == stack_pointer_rtx\n \t  || XEXP (x, 1) == stack_pointer_rtx))\n@@ -1422,7 +1433,7 @@ mn10300_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \taddr = XEXP (x, 0);\n \n       if (addr && CONSTANT_ADDRESS_P (addr))\n-\treturn DATA_OR_EXTENDED_REGS;\n+\treturn GENERAL_REGS;\n     }\n \n   /* Otherwise assume no secondary reloads are needed.  */\n@@ -1954,51 +1965,99 @@ mn10300_legitimate_pic_operand_p (rtx x)\n static bool\n mn10300_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {\n-  if (CONSTANT_ADDRESS_P (x)\n-      && (! flag_pic || mn10300_legitimate_pic_operand_p (x)))\n-    return TRUE;\n+  rtx base, index;\n+\n+  if (CONSTANT_ADDRESS_P (x))\n+    return !flag_pic || mn10300_legitimate_pic_operand_p (x);\n \n   if (RTX_OK_FOR_BASE_P (x, strict))\n-    return TRUE;\n+    return true;\n \n-  if (TARGET_AM33\n-      && GET_CODE (x) == POST_INC\n-      && RTX_OK_FOR_BASE_P (XEXP (x, 0), strict)\n-      && (mode == SImode || mode == SFmode || mode == HImode))\n-    return TRUE;\n+  if (TARGET_AM33 && (mode == SImode || mode == SFmode || mode == HImode))\n+    {\n+      if (GET_CODE (x) == POST_INC)\n+\treturn RTX_OK_FOR_BASE_P (XEXP (x, 0), strict);\n+      if (GET_CODE (x) == POST_MODIFY)\n+\treturn (RTX_OK_FOR_BASE_P (XEXP (x, 0), strict)\n+\t\t&& CONSTANT_ADDRESS_P (XEXP (x, 1)));\n+    }\n \n-  if (GET_CODE (x) == PLUS)\n+  if (GET_CODE (x) != PLUS)\n+    return false;\n+\n+  base = XEXP (x, 0);\n+  index = XEXP (x, 1);\n+\n+  if (!REG_P (base))\n+    return false;\n+  if (REG_P (index))\n     {\n-      rtx base = 0, index = 0;\n+      /* ??? Without AM33 generalized (Ri,Rn) addressing, reg+reg\n+\t addressing is hard to satisfy.  */\n+      if (!TARGET_AM33)\n+\treturn false;\n \n-      if (REG_P (XEXP (x, 0))\n-\t  && REGNO_STRICT_OK_FOR_BASE_P (REGNO (XEXP (x, 0)), strict))\n-\t{\n-\t  base = XEXP (x, 0);\n-\t  index = XEXP (x, 1);\n-\t}\n+      return (REGNO_GENERAL_P (REGNO (base), strict)\n+\t      && REGNO_GENERAL_P (REGNO (index), strict));\n+    }\n \n-      if (REG_P (XEXP (x, 1))\n-\t  && REGNO_STRICT_OK_FOR_BASE_P (REGNO (XEXP (x, 1)), strict))\n-\t{\n-\t  base = XEXP (x, 1);\n-\t  index = XEXP (x, 0);\n-\t}\n+  if (!REGNO_STRICT_OK_FOR_BASE_P (REGNO (base), strict))\n+    return false;\n \n-      if (base != 0 && index != 0)\n-\t{\n-\t  if (CONST_INT_P (index))\n-\t    return TRUE;\n-\t  if (GET_CODE (index) == CONST\n-\t      && GET_CODE (XEXP (index, 0)) != PLUS\n-\t      && (! flag_pic\n- \t\t  || (mn10300_legitimate_pic_operand_p (index)\n-\t\t      && GET_MODE_SIZE (mode) == 4)))\n-\t    return TRUE;\n-\t}\n+  if (CONST_INT_P (index))\n+    return IN_RANGE (INTVAL (index), -1 - 0x7fffffff, 0x7fffffff);\n+\n+  if (CONSTANT_ADDRESS_P (index))\n+    return !flag_pic || mn10300_legitimate_pic_operand_p (index);\n+\n+  return false;\n+}\n+\n+bool\n+mn10300_regno_in_class_p (unsigned regno, int rclass, bool strict)\n+{\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      if (!strict)\n+\treturn true;\n+      if (!reg_renumber)\n+\treturn false;\n+      regno = reg_renumber[regno];\n+    }\n+  return TEST_HARD_REG_BIT (reg_class_contents[rclass], regno);\n+}\n+\n+rtx\n+mn10300_legitimize_reload_address (rtx x,\n+\t\t\t\t   enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\t   int opnum, int type,\n+\t\t\t\t   int ind_levels ATTRIBUTE_UNUSED)\n+{\n+  bool any_change = false;\n+\n+  /* See above re disabling reg+reg addressing for MN103.  */\n+  if (!TARGET_AM33)\n+    return NULL_RTX;\n+\n+  if (GET_CODE (x) != PLUS)\n+    return NULL_RTX;\n+\n+  if (XEXP (x, 0) == stack_pointer_rtx)\n+    {\n+      push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n+\t\t   GENERAL_REGS, GET_MODE (x), VOIDmode, 0, 0,\n+\t\t   opnum, (enum reload_type) type);\n+      any_change = true;\n+    }\n+  if (XEXP (x, 1) == stack_pointer_rtx)\n+    {\n+      push_reload (XEXP (x, 1), NULL_RTX, &XEXP (x, 1), NULL,\n+\t\t   GENERAL_REGS, GET_MODE (x), VOIDmode, 0, 0,\n+\t\t   opnum, (enum reload_type) type);\n+      any_change = true;\n     }\n \n-  return FALSE;\n+  return any_change ? x : NULL_RTX;\n }\n \n /* Used by LEGITIMATE_CONSTANT_P().  Returns TRUE if X is a valid"}, {"sha": "587ba17338bec6331005bc4bbdc8648cfdab03ee", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 37, "deletions": 48, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36846b26721512effe580079a9ef6b982c651cb8/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36846b26721512effe580079a9ef6b982c651cb8/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=36846b26721512effe580079a9ef6b982c651cb8", "patch": "@@ -261,26 +261,19 @@ extern enum processor_type mn10300_tune_cpu;\n \n enum reg_class\n {\n-  NO_REGS, DATA_REGS, ADDRESS_REGS, SP_REGS,\n-  DATA_OR_ADDRESS_REGS, SP_OR_ADDRESS_REGS,\n-  EXTENDED_REGS, DATA_OR_EXTENDED_REGS, ADDRESS_OR_EXTENDED_REGS,\n-  SP_OR_EXTENDED_REGS, SP_OR_ADDRESS_OR_EXTENDED_REGS,\n-  FP_REGS, FP_ACC_REGS, CC_REGS,\n-  GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n+  NO_REGS, DATA_REGS, ADDRESS_REGS, SP_REGS, SP_OR_ADDRESS_REGS,\n+  EXTENDED_REGS, FP_REGS, FP_ACC_REGS, CC_REGS,\n+  GENERAL_REGS, SP_OR_GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n };\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n /* Give names of register classes as strings for dump file.  */\n \n #define REG_CLASS_NAMES\t\t\t\t\t   \t\\\n-{ \"NO_REGS\", \"DATA_REGS\", \"ADDRESS_REGS\",\t\t\t\\\n-  \"SP_REGS\", \"DATA_OR_ADDRESS_REGS\", \"SP_OR_ADDRESS_REGS\",\t\\\n-  \"EXTENDED_REGS\",\t\t\t\t\t\t\\\n-  \"DATA_OR_EXTENDED_REGS\", \"ADDRESS_OR_EXTENDED_REGS\",\t\t\\\n-  \"SP_OR_EXTENDED_REGS\", \"SP_OR_ADDRESS_OR_EXTENDED_REGS\",\t\\\n-  \"FP_REGS\", \"FP_ACC_REGS\", \"CC_REGS\",\t\t\t\t\\\n-  \"GENERAL_REGS\", \"ALL_REGS\", \"LIM_REGS\"\t\t\t\\\n+{ \"NO_REGS\", \"DATA_REGS\", \"ADDRESS_REGS\", \"SP_REGS\", \"SP_OR_ADDRESS_REGS\", \\\n+  \"EXTENDED_REGS\", \"FP_REGS\", \"FP_ACC_REGS\", \"CC_REGS\",\t\t\\\n+  \"GENERAL_REGS\", \"SP_OR_GENERAL_REGS\", \"ALL_REGS\", \"LIM_REGS\"\t\\\n }\n \n /* Define which registers fit in which classes.\n@@ -292,17 +285,13 @@ enum reg_class\n   { 0x0000000f, 0 },\t  /* DATA_REGS */\t\t\t\\\n   { 0x000001f0, 0 },\t  /* ADDRESS_REGS */\t\t\t\\\n   { 0x00000200, 0 },\t  /* SP_REGS */\t\t\t\t\\\n-  { 0x000001ff, 0 },\t  /* DATA_OR_ADDRESS_REGS */\t\t\\\n   { 0x000003f0, 0 },\t  /* SP_OR_ADDRESS_REGS */\t\t\\\n   { 0x0003fc00, 0 },\t  /* EXTENDED_REGS */\t\t\t\\\n-  { 0x0003fc0f, 0 },\t  /* DATA_OR_EXTENDED_REGS */\t\t\\\n-  { 0x0003fdf0, 0 },\t  /* ADDRESS_OR_EXTENDED_REGS */\t\\\n-  { 0x0003fe00, 0 },\t  /* SP_OR_EXTENDED_REGS */\t\t\\\n-  { 0x0003fff0, 0 },\t  /* SP_OR_ADDRESS_OR_EXTENDED_REGS */\t\\\n   { 0xfffc0000, 0x3ffff },/* FP_REGS */\t\t\t\t\\\n   { 0x03fc0000, 0 },\t  /* FP_ACC_REGS */\t\t\t\\\n   { 0x00000000, 0x80000 },/* CC_REGS */\t\t\t\t\\\n   { 0x0003fdff, 0 }, \t  /* GENERAL_REGS */\t\t\t\\\n+  { 0x0003ffff, 0 },      /* SP_OR_GENERAL_REGS */\t\t\\\n   { 0xffffffff, 0xfffff } /* ALL_REGS */\t\t\t\\\n }\n \n@@ -334,8 +323,10 @@ enum reg_class\n    NO_REGS)\n \n /* The class value for index registers, and the one for base regs.  */\n-#define INDEX_REG_CLASS DATA_OR_EXTENDED_REGS\n-#define BASE_REG_CLASS  SP_OR_ADDRESS_REGS\n+#define INDEX_REG_CLASS \\\n+  (TARGET_AM33 ? GENERAL_REGS : DATA_REGS)\n+#define BASE_REG_CLASS \\\n+  (TARGET_AM33 ? SP_OR_GENERAL_REGS : SP_OR_ADDRESS_REGS)\n \n /* Macros to check register numbers against specific register classes.  */\n \n@@ -364,50 +355,31 @@ enum reg_class\n # define REG_STRICT 1\n #endif\n \n-# define REGNO_IN_RANGE_P(regno,min,max,strict) \\\n-  (IN_RANGE ((regno), (min), (max)) \t\t\\\n-   || ((strict)\t\t\t\t\t\\\n-       ? (reg_renumber\t\t\t\t\\\n-\t  && reg_renumber[(regno)] >= (min)\t\\\n-\t  && reg_renumber[(regno)] <= (max))\t\\\n-       : (regno) >= FIRST_PSEUDO_REGISTER))\n-\n #define REGNO_DATA_P(regno, strict) \\\n-  (REGNO_IN_RANGE_P ((regno), FIRST_DATA_REGNUM, LAST_DATA_REGNUM, \\\n-\t\t     (strict)))\n+  mn10300_regno_in_class_p (regno, DATA_REGS, strict)\n #define REGNO_ADDRESS_P(regno, strict) \\\n-  (REGNO_IN_RANGE_P ((regno), FIRST_ADDRESS_REGNUM, LAST_ADDRESS_REGNUM, \\\n-\t\t     (strict)))\n-#define REGNO_SP_P(regno, strict) \\\n-  (REGNO_IN_RANGE_P ((regno), STACK_POINTER_REGNUM, STACK_POINTER_REGNUM, \\\n-\t\t     (strict)))\n+  mn10300_regno_in_class_p (regno, ADDRESS_REGS, strict)\n #define REGNO_EXTENDED_P(regno, strict) \\\n-  (REGNO_IN_RANGE_P ((regno), FIRST_EXTENDED_REGNUM, LAST_EXTENDED_REGNUM, \\\n-\t\t     (strict)))\n-#define REGNO_AM33_P(regno, strict) \\\n-  (REGNO_DATA_P ((regno), (strict)) || REGNO_ADDRESS_P ((regno), (strict)) \\\n-   || REGNO_EXTENDED_P ((regno), (strict)))\n-#define REGNO_FP_P(regno, strict) \\\n-  (REGNO_IN_RANGE_P ((regno), FIRST_FP_REGNUM, LAST_FP_REGNUM, (strict)))\n+  mn10300_regno_in_class_p (regno, EXTENDED_REGS, strict)\n+#define REGNO_GENERAL_P(regno, strict) \\\n+  mn10300_regno_in_class_p (regno, GENERAL_REGS, strict)\n \n #define REGNO_STRICT_OK_FOR_BASE_P(regno, strict) \\\n-  (REGNO_SP_P ((regno), (strict)) \\\n-   || REGNO_ADDRESS_P ((regno), (strict)) \\\n-   || REGNO_EXTENDED_P ((regno), (strict)))\n+  mn10300_regno_in_class_p (regno, BASE_REG_CLASS, strict)\n #define REGNO_OK_FOR_BASE_P(regno) \\\n   (REGNO_STRICT_OK_FOR_BASE_P ((regno), REG_STRICT))\n #define REG_OK_FOR_BASE_P(X) \\\n   (REGNO_OK_FOR_BASE_P (REGNO (X)))\n \n #define REGNO_STRICT_OK_FOR_BIT_BASE_P(regno, strict) \\\n-  (REGNO_SP_P ((regno), (strict)) || REGNO_ADDRESS_P ((regno), (strict)))\n+  mn10300_regno_in_class_p (regno, ADDRESS_REGS, strict)\n #define REGNO_OK_FOR_BIT_BASE_P(regno) \\\n   (REGNO_STRICT_OK_FOR_BIT_BASE_P ((regno), REG_STRICT))\n #define REG_OK_FOR_BIT_BASE_P(X) \\\n   (REGNO_OK_FOR_BIT_BASE_P (REGNO (X)))\n \n #define REGNO_STRICT_OK_FOR_INDEX_P(regno, strict) \\\n-  (REGNO_DATA_P ((regno), (strict)) || REGNO_EXTENDED_P ((regno), (strict)))\n+  mn10300_regno_in_class_p (regno, INDEX_REG_CLASS, strict)\n #define REGNO_OK_FOR_INDEX_P(regno) \\\n   (REGNO_STRICT_OK_FOR_INDEX_P ((regno), REG_STRICT))\n #define REG_OK_FOR_INDEX_P(X) \\\n@@ -557,7 +529,15 @@ struct cum_arg\n #define MAX_REGS_PER_ADDRESS 2\n \n \f\n-#define HAVE_POST_INCREMENT (TARGET_AM33)\n+/* We have post-increments.  */\n+#define HAVE_POST_INCREMENT\tTARGET_AM33\n+#define HAVE_POST_MODIFY_DISP\tTARGET_AM33\n+\n+/* ... But we don't want to use them for block moves.  Small offsets are\n+   just as effective, at least for inline block move sizes, and appears\n+   to produce cleaner code.  */\n+#define USE_LOAD_POST_INCREMENT(M)\t0\n+#define USE_STORE_POST_INCREMENT(M)\t0\n \n /* Accept either REG or SUBREG where a register is valid.  */\n \n@@ -568,6 +548,15 @@ struct cum_arg\n        && REGNO_STRICT_OK_FOR_BASE_P (REGNO (SUBREG_REG (X)),\t\\\n  \t\t\t\t      (strict))))\n \n+#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_L,WIN)\t\t     \\\n+do {\t\t\t\t\t\t\t\t\t     \\\n+  rtx new_x = mn10300_legitimize_reload_address (X, MODE, OPNUM, TYPE, IND_L); \\\n+  if (new_x)\t\t\t\t\t\t\t\t     \\\n+    {\t\t\t\t\t\t\t\t\t     \\\n+      X = new_x;\t\t\t\t\t\t\t     \\\n+      goto WIN;\t\t\t\t\t\t\t\t     \\\n+    }\t\t\t\t\t\t\t\t\t     \\\n+} while (0)\n \f\n \n /* Nonzero if the constant value X is a legitimate general operand."}]}