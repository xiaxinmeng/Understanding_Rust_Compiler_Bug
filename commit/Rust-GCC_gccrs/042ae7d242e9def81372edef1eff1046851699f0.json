{"sha": "042ae7d242e9def81372edef1eff1046851699f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQyYWU3ZDI0MmU5ZGVmODEzNzJlZGVmMWVmZjEwNDY4NTE2OTlmMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-08-09T15:23:19Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-08-09T15:23:19Z"}, "message": "cgraphbuild.c (cgraph_rebuild_references): Rebuild only non-speculative refs.\n\n\n\t* cgraphbuild.c (cgraph_rebuild_references): Rebuild only non-speculative\n\trefs.\n\t* cgraph.c (cgraph_update_edge_in_call_site_hash): New function.\n\t(cgraph_add_edge_to_call_site_hash): Deal with speculative calls.\n\t(cgraph_set_call_stmt): Likewise.\n\t(cgraph_create_edge_1): Fix release checking compilatoin;\n\tclear lto_stmt_uid.\n\t(cgraph_free_edge): Free indirect info.\n\t(cgraph_turn_edge_to_speculative): New function.\n\t(cgraph_speculative_call_info): New function.\n\t(cgraph_make_edge_direct): Return direct edge; handle speculation.\n\t(cgraph_redirect_edge_call_stmt_to_callee): Expand speculative\n\tedges.\n\t(dump_cgraph_node): Dump speculation.\n\t(verify_edge_count_and_frequency): Accept speculative edges.\n\t(verify_edge_corresponds_to_fndecl): Handle partitioned cgraph.\n\t(verify_cgraph_node): Handle speculation.\n\t* cgraph.h (cgraph_edge): Add SPECULATIVE flag.\n\t(cgraph_set_call_stmt): Update prototype.\n\t(cgraph_make_edge_direct): Update prototype.\n\t(cgraph_speculative_call_info): Declare.\n\t* ipa-cp.c (ipcp_discover_new_direct_edges): Be ready for edge\n\tto change; update call of ipa_find_references.\n\t* ipa-ref.c (ipa_record_reference): Fix return value; clear\n\tlto_stmt_uid and speculative flags.\n\t(ipa_dump_references): Dump speculation.\n\t(ipa_clone_references): Clone speculative flag.\n\t(ipa_clone_referring): Likewise.\n\t(ipa_clone_ref): New function.\n\t(ipa_find_reference): Look into lto_stmt_uids\n\t(ipa_clear_stmts_in_references): Do not clear speculative calls.\n\t* ipa-ref.h (ipa_ref): Add lto_stmt_uid and speculative flags.\n\t(ipa_find_reference): Update declaration.\n\t(ipa_clone_ref): Declare.\n\t* lto-cgraph.c (lto_output_edge): Make lto_stmt_uids start from 0;\n\tstream speculative flag.\n\t(lto_output_ref): Stream statements uids and speculation.\n\t(input_ref): Likewise.\n\t(input_edge): Stream speuclation.\n\t* cgraphclones.c (cgraph_clone_edge): Clone speculation.\n\t(cgraph_set_call_stmt_including_clones): Handle speculation.\n\t* ipa-inline.c (heap_edge_removal_hook): New function.\n\t(inline_small_functions): Register it.\n\t* lto-streamer-in.c (fixup_call_stmt_edges_1): Bounds checking;\n\talso initialize refs.\n\t* ipa-prop.c (ipa_make_edge_direct_to_target): Be ready for\n\tedge to change.\n\t(try_make_edge_direct_simple_call): Likewise.\n\t(try_make_edge_direct_simple_call): Likewise.\n\t(update_indirect_edges_after_inlining): Likewise.\n\t(remove_described_reference): Look proper lto_stmt_uid.\n\t(propagate_controlled_uses): Likewise.\n\t(propagate_controlled_uses): Liekwise.\n\t* tree-inline.c (copy_bb): Copy speculative edges.\n\t(redirect_all_calls): New function.\n\t(copy_cfg_body): Do redirection after loop info\n\tis updated.\n\t(delete_unreachable_blocks_update_callgraph): Updadte\n\tspeculation.\n\nFrom-SVN: r201632", "tree": {"sha": "9f0bf5f1369dcb3ba206377f3550a5b0a59cdd38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f0bf5f1369dcb3ba206377f3550a5b0a59cdd38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/042ae7d242e9def81372edef1eff1046851699f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/042ae7d242e9def81372edef1eff1046851699f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/042ae7d242e9def81372edef1eff1046851699f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/042ae7d242e9def81372edef1eff1046851699f0/comments", "author": null, "committer": null, "parents": [{"sha": "6efa6002d5b3575c7e1f9096f2e0f15252ac9c4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6efa6002d5b3575c7e1f9096f2e0f15252ac9c4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6efa6002d5b3575c7e1f9096f2e0f15252ac9c4b"}], "stats": {"total": 791, "additions": 677, "deletions": 114}, "files": [{"sha": "0207b565fa5a29c9fbb47871c4e2e84fb5105b11", "filename": "gcc/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/042ae7d242e9def81372edef1eff1046851699f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/042ae7d242e9def81372edef1eff1046851699f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=042ae7d242e9def81372edef1eff1046851699f0", "patch": "@@ -1,3 +1,65 @@\n+2013-08-09  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraphbuild.c (cgraph_rebuild_references): Rebuild only non-speculative\n+\trefs.\n+\t* cgraph.c (cgraph_update_edge_in_call_site_hash): New function.\n+\t(cgraph_add_edge_to_call_site_hash): Deal with speculative calls.\n+\t(cgraph_set_call_stmt): Likewise.\n+\t(cgraph_create_edge_1): Fix release checking compilatoin;\n+\tclear lto_stmt_uid.\n+\t(cgraph_free_edge): Free indirect info.\n+\t(cgraph_turn_edge_to_speculative): New function.\n+\t(cgraph_speculative_call_info): New function.\n+\t(cgraph_make_edge_direct): Return direct edge; handle speculation.\n+\t(cgraph_redirect_edge_call_stmt_to_callee): Expand speculative\n+\tedges.\n+\t(dump_cgraph_node): Dump speculation.\n+\t(verify_edge_count_and_frequency): Accept speculative edges.\n+\t(verify_edge_corresponds_to_fndecl): Handle partitioned cgraph.\n+\t(verify_cgraph_node): Handle speculation.\n+\t* cgraph.h (cgraph_edge): Add SPECULATIVE flag.\n+\t(cgraph_set_call_stmt): Update prototype.\n+\t(cgraph_make_edge_direct): Update prototype.\n+\t(cgraph_speculative_call_info): Declare.\n+\t* ipa-cp.c (ipcp_discover_new_direct_edges): Be ready for edge\n+\tto change; update call of ipa_find_references.\n+\t* ipa-ref.c (ipa_record_reference): Fix return value; clear\n+\tlto_stmt_uid and speculative flags.\n+\t(ipa_dump_references): Dump speculation.\n+\t(ipa_clone_references): Clone speculative flag.\n+\t(ipa_clone_referring): Likewise.\n+\t(ipa_clone_ref): New function.\n+\t(ipa_find_reference): Look into lto_stmt_uids\n+\t(ipa_clear_stmts_in_references): Do not clear speculative calls.\n+\t* ipa-ref.h (ipa_ref): Add lto_stmt_uid and speculative flags.\n+\t(ipa_find_reference): Update declaration.\n+\t(ipa_clone_ref): Declare.\n+\t* lto-cgraph.c (lto_output_edge): Make lto_stmt_uids start from 0;\n+\tstream speculative flag.\n+\t(lto_output_ref): Stream statements uids and speculation.\n+\t(input_ref): Likewise.\n+\t(input_edge): Stream speuclation.\n+\t* cgraphclones.c (cgraph_clone_edge): Clone speculation.\n+\t(cgraph_set_call_stmt_including_clones): Handle speculation.\n+\t* ipa-inline.c (heap_edge_removal_hook): New function.\n+\t(inline_small_functions): Register it.\n+\t* lto-streamer-in.c (fixup_call_stmt_edges_1): Bounds checking;\n+\talso initialize refs.\n+\t* ipa-prop.c (ipa_make_edge_direct_to_target): Be ready for\n+\tedge to change.\n+\t(try_make_edge_direct_simple_call): Likewise.\n+\t(try_make_edge_direct_simple_call): Likewise.\n+\t(update_indirect_edges_after_inlining): Likewise.\n+\t(remove_described_reference): Look proper lto_stmt_uid.\n+\t(propagate_controlled_uses): Likewise.\n+\t(propagate_controlled_uses): Liekwise.\n+\t* tree-inline.c (copy_bb): Copy speculative edges.\n+\t(redirect_all_calls): New function.\n+\t(copy_cfg_body): Do redirection after loop info\n+\tis updated.\n+\t(delete_unreachable_blocks_update_callgraph): Updadte\n+\tspeculation.\n+\n 2013-08-09  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-streamer-out.c (output_function): Renumber PHIs."}, {"sha": "43b499489f905b8c726ea823d9b4b509e5d1cf68", "filename": "gcc/cgraph.c", "status": "modified", "additions": 272, "deletions": 10, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=042ae7d242e9def81372edef1eff1046851699f0", "patch": "@@ -673,15 +673,37 @@ edge_eq (const void *x, const void *y)\n \n /* Add call graph edge E to call site hash of its caller.  */\n \n+static inline void\n+cgraph_update_edge_in_call_site_hash (struct cgraph_edge *e)\n+{\n+  void **slot;\n+  slot = htab_find_slot_with_hash (e->caller->call_site_hash,\n+\t\t\t\t   e->call_stmt,\n+\t\t\t\t   htab_hash_pointer (e->call_stmt),\n+\t\t\t\t   INSERT);\n+  *slot = e;\n+}\n+\n+/* Add call graph edge E to call site hash of its caller.  */\n+\n static inline void\n cgraph_add_edge_to_call_site_hash (struct cgraph_edge *e)\n {\n   void **slot;\n+  /* There are two speculative edges for every statement (one direct,\n+     one indirect); always hash the direct one.  */\n+  if (e->speculative && e->indirect_unknown_callee)\n+    return;\n   slot = htab_find_slot_with_hash (e->caller->call_site_hash,\n \t\t\t\t   e->call_stmt,\n \t\t\t\t   htab_hash_pointer (e->call_stmt),\n \t\t\t\t   INSERT);\n-  gcc_assert (!*slot);\n+  if (*slot)\n+    {\n+      gcc_assert (((struct cgraph_edge *)*slot)->speculative);\n+      return;\n+    }\n+  gcc_assert (!*slot || e->speculative);\n   *slot = e;\n }\n \n@@ -732,14 +754,33 @@ cgraph_edge (struct cgraph_node *node, gimple call_stmt)\n }\n \n \n-/* Change field call_stmt of edge E to NEW_STMT.  */\n+/* Change field call_stmt of edge E to NEW_STMT.\n+   If UPDATE_SPECULATIVE and E is any component of speculative\n+   edge, then update all components.  */\n \n void\n-cgraph_set_call_stmt (struct cgraph_edge *e, gimple new_stmt)\n+cgraph_set_call_stmt (struct cgraph_edge *e, gimple new_stmt,\n+\t\t      bool update_speculative)\n {\n   tree decl;\n \n-  if (e->caller->call_site_hash)\n+  /* Speculative edges has three component, update all of them\n+     when asked to.  */\n+  if (update_speculative && e->speculative)\n+    {\n+      struct cgraph_edge *direct, *indirect;\n+      struct ipa_ref *ref;\n+\n+      cgraph_speculative_call_info (e, direct, indirect, ref);\n+      cgraph_set_call_stmt (direct, new_stmt, false);\n+      cgraph_set_call_stmt (indirect, new_stmt, false);\n+      ref->stmt = new_stmt;\n+      return;\n+    }\n+\n+  /* Only direct speculative edges go to call_site_hash.  */\n+  if (e->caller->call_site_hash\n+      && (!e->speculative || !e->indirect_unknown_callee))\n     {\n       htab_remove_elt_with_hash (e->caller->call_site_hash,\n \t\t\t\t e->call_stmt,\n@@ -755,7 +796,7 @@ cgraph_set_call_stmt (struct cgraph_edge *e, gimple new_stmt)\n       struct cgraph_node *new_callee = cgraph_get_node (decl);\n \n       gcc_checking_assert (new_callee);\n-      cgraph_make_edge_direct (e, new_callee);\n+      e = cgraph_make_edge_direct (e, new_callee);\n     }\n \n   push_cfun (DECL_STRUCT_FUNCTION (e->caller->symbol.decl));\n@@ -781,7 +822,10 @@ cgraph_create_edge_1 (struct cgraph_node *caller, struct cgraph_node *callee,\n     {\n       /* This is a rather expensive check possibly triggering\n \t construction of call stmt hashtable.  */\n-      gcc_checking_assert (!cgraph_edge (caller, call_stmt));\n+#ifdef ENABLE_CHECKING\n+      struct cgraph_edge *e;\n+      gcc_checking_assert (!(e=cgraph_edge (caller, call_stmt)) || e->speculative);\n+#endif\n \n       gcc_assert (is_gimple_call (call_stmt));\n     }\n@@ -804,6 +848,7 @@ cgraph_create_edge_1 (struct cgraph_node *caller, struct cgraph_node *callee,\n   edge->next_caller = NULL;\n   edge->prev_callee = NULL;\n   edge->next_callee = NULL;\n+  edge->lto_stmt_uid = 0;\n \n   edge->count = count;\n   gcc_assert (count >= 0);\n@@ -937,6 +982,9 @@ cgraph_free_edge (struct cgraph_edge *e)\n {\n   int uid = e->uid;\n \n+  if (e->indirect_info)\n+    ggc_free (e->indirect_info);\n+\n   /* Clear out the edge so we do not dangle pointers.  */\n   memset (e, 0, sizeof (*e));\n   e->uid = uid;\n@@ -977,6 +1025,110 @@ cgraph_set_edge_callee (struct cgraph_edge *e, struct cgraph_node *n)\n   e->callee = n;\n }\n \n+/* Turn edge E into speculative call calling N2. Update\n+   the profile so the direct call is taken COUNT times\n+   with FREQUENCY.  \n+\n+   At clone materialization time, the indirect call E will\n+   be expanded as:\n+\n+   if (call_dest == N2)\n+     n2 ();\n+   else\n+     call call_dest\n+\n+   At this time the function just creates the direct call,\n+   the referencd representing the if conditional and attaches\n+   them all to the orginal indirect call statement.  */\n+\n+void\n+cgraph_turn_edge_to_speculative (struct cgraph_edge *e,\n+\t\t\t\t struct cgraph_node *n2,\n+\t\t\t\t gcov_type direct_count,\n+\t\t\t\t int direct_frequency)\n+{\n+  struct cgraph_node *n = e->caller;\n+  struct ipa_ref *ref;\n+  struct cgraph_edge *e2;\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Indirect call -> direct call from\"\n+\t       \" other module %s/%i => %s/%i\\n\",\n+\t       xstrdup (cgraph_node_name (n)), n->symbol.order,\n+\t       xstrdup (cgraph_node_name (n2)), n2->symbol.order);\n+    }\n+  e->speculative = true;\n+  e2 = cgraph_create_edge (n, n2, e->call_stmt, direct_count, direct_frequency);\n+  initialize_inline_failed (e2);\n+  e2->speculative = true;\n+  e2->call_stmt = e->call_stmt;\n+  e2->can_throw_external = e->can_throw_external;\n+  e2->lto_stmt_uid = e->lto_stmt_uid;\n+  e->count -= e2->count;\n+  e->frequency -= e2->frequency;\n+  cgraph_call_edge_duplication_hooks (e, e2);\n+  ref = ipa_record_reference ((symtab_node)n, (symtab_node)n2,\n+\t\t\t      IPA_REF_ADDR, e->call_stmt);\n+  ref->lto_stmt_uid = e->lto_stmt_uid;\n+  ref->speculative = e->speculative;\n+}\n+\n+/* Speculative call consist of three components:\n+   1) an indirect edge representing the original call\n+   2) an direct edge representing the new call\n+   3) ADDR_EXPR reference representing the speculative check.\n+   All three components are attached to single statement (the indirect\n+   call) and if one of them exists, all of them must exist.\n+\n+   Given speculative call edge E, return all three components. \n+ */\n+\n+void\n+cgraph_speculative_call_info (struct cgraph_edge *e,\n+\t\t\t      struct cgraph_edge *&indirect,\n+\t\t\t      struct cgraph_edge *&direct,\n+\t\t\t      struct ipa_ref *&reference)\n+{\n+  struct ipa_ref *ref;\n+  int i;\n+  struct cgraph_edge *e2;\n+\n+  if (!e->indirect_unknown_callee)\n+    for (e2 = e->caller->indirect_calls;\n+\t e2->call_stmt != e->call_stmt || e2->lto_stmt_uid != e->lto_stmt_uid;\n+\t e2 = e2->next_callee)\n+      ;\n+  else\n+    {\n+      e2 = e;\n+      /* We can take advantage of the call stmt hash.  */\n+      if (e2->call_stmt)\n+\t{\n+\t  e = cgraph_edge (e->caller, e2->call_stmt);\n+\t  gcc_assert (!e->speculative && !e->indirect_unknown_callee);\n+\t}\n+      else\n+\tfor (e = e->caller->callees; \n+\t     e2->call_stmt != e->call_stmt || e2->lto_stmt_uid != e->lto_stmt_uid;\n+\t     e = e->next_callee)\n+\t  ;\n+    }\n+  gcc_assert (e->speculative && e2->speculative);\n+  indirect = e;\n+  direct = e2;\n+\n+  reference = NULL;\n+  for (i = 0; ipa_ref_list_reference_iterate (&e->caller->symbol.ref_list, i, ref); i++)\n+    if (ref->speculative\n+\t&& ((ref->stmt && ref->stmt == e->call_stmt)\n+\t    || (ref->lto_stmt_uid == e->lto_stmt_uid)))\n+      {\n+\treference = ref;\n+\tbreak;\n+      }\n+}\n+\n /* Redirect callee of E to N.  The function does not update underlying\n    call expression.  */\n \n@@ -990,14 +1142,74 @@ cgraph_redirect_edge_callee (struct cgraph_edge *e, struct cgraph_node *n)\n   cgraph_set_edge_callee (e, n);\n }\n \n+/* Speculative call EDGE turned out to be direct call to CALLE_DECL.\n+   Remove the speculative call sequence and return edge representing the call.\n+   It is up to caller to redirect the call as appropriate. */\n+\n+static struct cgraph_edge *\n+cgraph_resolve_speculation (struct cgraph_edge *edge, tree callee_decl)\n+{\n+  struct cgraph_edge *e2;\n+  struct ipa_ref *ref;\n+\n+  gcc_assert (edge->speculative);\n+  cgraph_speculative_call_info (edge, e2, edge, ref);\n+  if (ref->referred->symbol.decl != callee_decl)\n+    {\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"Speculative indirect call %s/%i => %s/%i has \"\n+\t\t   \"turned out to have contradicitng known target \",\n+\t\t   xstrdup (cgraph_node_name (edge->caller)), edge->caller->symbol.order,\n+\t\t   xstrdup (cgraph_node_name (e2->callee)), e2->callee->symbol.order);\n+\t  print_generic_expr (dump_file, callee_decl, 0);\n+          fprintf (dump_file, \"\\n\");\n+\t}\n+    }\n+  else\n+    {\n+      struct cgraph_edge *tmp = edge;\n+      if (dump_file)\n+        fprintf (dump_file, \"Speculative call turned into direct call.\\n\");\n+      edge = e2;\n+      e2 = tmp;\n+    }\n+  edge->count += e2->count;\n+  edge->frequency += e2->frequency;\n+  edge->speculative = false;\n+  e2->speculative = false;\n+  if (e2->indirect_unknown_callee || e2->inline_failed)\n+    cgraph_remove_edge (e2);\n+  else\n+    cgraph_remove_node_and_inline_clones (e2->callee, NULL);\n+  if (edge->caller->call_site_hash)\n+    cgraph_update_edge_in_call_site_hash (edge);\n+  ipa_remove_reference (ref);\n+  return edge;\n+}\n+\n /* Make an indirect EDGE with an unknown callee an ordinary edge leading to\n    CALLEE.  DELTA is an integer constant that is to be added to the this\n    pointer (first parameter) to compensate for skipping a thunk adjustment.  */\n \n-void\n+struct cgraph_edge *\n cgraph_make_edge_direct (struct cgraph_edge *edge, struct cgraph_node *callee)\n {\n+  gcc_assert (edge->indirect_unknown_callee);\n+\n+  /* If we are redirecting speculative call, make it non-speculative.  */\n+  if (edge->indirect_unknown_callee && edge->speculative)\n+    {\n+      edge = cgraph_resolve_speculation (edge, callee->symbol.decl);\n+\n+      /* On successful speculation just return the pre existing direct edge.  */\n+      if (!edge->indirect_unknown_callee)\n+        return edge;\n+    }\n+\n   edge->indirect_unknown_callee = 0;\n+  ggc_free (edge->indirect_info);\n+  edge->indirect_info = NULL;\n \n   /* Get the edge out of the indirect edge list. */\n   if (edge->prev_callee)\n@@ -1024,6 +1236,7 @@ cgraph_make_edge_direct (struct cgraph_edge *edge, struct cgraph_node *callee)\n \n   /* We need to re-determine the inlining status of the edge.  */\n   initialize_inline_failed (edge);\n+  return edge;\n }\n \n /* If necessary, change the function declaration in the call statement\n@@ -1039,6 +1252,50 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n   struct cgraph_node *node;\n #endif\n \n+  if (e->speculative)\n+    {\n+      struct cgraph_edge *e2;\n+      gimple new_stmt;\n+      struct ipa_ref *ref;\n+\n+      cgraph_speculative_call_info (e, e, e2, ref);\n+      if (gimple_call_fndecl (e->call_stmt))\n+\te = cgraph_resolve_speculation (e, gimple_call_fndecl (e->call_stmt));\n+      else\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Expanding speculative call of %s/%i -> %s/%i\\n\",\n+\t\t     xstrdup (cgraph_node_name (e->caller)), e->caller->symbol.order,\n+\t\t     xstrdup (cgraph_node_name (e->callee)), e->callee->symbol.order);\n+\t  gcc_assert (e2->speculative);\n+\t  push_cfun (DECL_STRUCT_FUNCTION (e->caller->symbol.decl));\n+\t  new_stmt = gimple_ic (e->call_stmt, cgraph (ref->referred),\n+\t\t\t\te->count || e2->count\n+\t\t\t\t?  RDIV (e->count * REG_BR_PROB_BASE,\n+\t\t\t\t\t e->count + e2->count)\n+\t\t\t\t: e->frequency || e2->frequency\n+\t\t\t\t? RDIV (e->frequency * REG_BR_PROB_BASE,\n+\t\t\t\t\te->frequency + e2->frequency)\n+\t\t\t\t: REG_BR_PROB_BASE / 2,\n+\t\t\t\te->count, e->count + e2->count);\n+\t  e->speculative = false;\n+\t  cgraph_set_call_stmt_including_clones (e->caller, e->call_stmt, new_stmt, false);\n+\t  e->frequency = compute_call_stmt_bb_frequency (e->caller->symbol.decl,\n+\t\t\t\t\t\t\t gimple_bb (e->call_stmt));\n+\t  e2->frequency = compute_call_stmt_bb_frequency (e2->caller->symbol.decl,\n+\t\t\t\t\t\t\t  gimple_bb (e2->call_stmt));\n+\t  e2->speculative = false;\n+\t  ref->speculative = false;\n+\t  ref->stmt = NULL;\n+\t  /* Indirect edges are not both in the call site hash.\n+\t     get it updated.  */\n+\t  if (e->caller->call_site_hash)\n+\t    cgraph_update_edge_in_call_site_hash (e2);\n+\t  pop_cfun ();\n+\t  /* Continue redirecting E to proper target.  */\n+\t}\n+    }\n+\n   if (e->indirect_unknown_callee\n       || decl == e->callee->symbol.decl)\n     return e->call_stmt;\n@@ -1099,7 +1356,7 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n       update_stmt (new_stmt);\n     }\n \n-  cgraph_set_call_stmt_including_clones (e->caller, e->call_stmt, new_stmt);\n+  cgraph_set_call_stmt_including_clones (e->caller, e->call_stmt, new_stmt, false);\n \n   if (cgraph_dump_file)\n     {\n@@ -1603,6 +1860,8 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n       if (edge->frequency)\n \tfprintf (f, \"(%.2f per call) \",\n \t\t edge->frequency / (double)CGRAPH_FREQ_BASE);\n+      if (edge->speculative)\n+\tfprintf(f, \"(speculative) \");\n       if (!edge->inline_failed)\n \tfprintf(f, \"(inlined) \");\n       if (edge->indirect_inlining_edge)\n@@ -1616,6 +1875,8 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     {\n       fprintf (f, \"%s/%i \", cgraph_node_asm_name (edge->callee),\n \t       edge->callee->symbol.order);\n+      if (edge->speculative)\n+\tfprintf(f, \"(speculative) \");\n       if (!edge->inline_failed)\n \tfprintf(f, \"(inlined) \");\n       if (edge->indirect_inlining_edge)\n@@ -2262,6 +2523,7 @@ verify_edge_count_and_frequency (struct cgraph_edge *e)\n     }\n   if (gimple_has_body_p (e->caller->symbol.decl)\n       && !e->caller->global.inlined_to\n+      && !e->speculative\n       /* FIXME: Inline-analysis sets frequency to 0 when edge is optimized out.\n \t Remove this once edges are actually removed from the function at that time.  */\n       && (e->frequency\n@@ -2316,7 +2578,7 @@ verify_edge_corresponds_to_fndecl (struct cgraph_edge *e, tree decl)\n \n   /* We do not know if a node from a different partition is an alias or what it\n      aliases and therefore cannot do the former_clone_of check reliably.  */\n-  if (!node || node->symbol.in_other_partition)\n+  if (!node || node->symbol.in_other_partition || e->callee->symbol.in_other_partition)\n     return false;\n   node = cgraph_function_or_thunk_node (node, NULL);\n \n@@ -2625,7 +2887,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t}\n       for (e = node->indirect_calls; e; e = e->next_callee)\n \t{\n-\t  if (!e->aux)\n+\t  if (!e->aux && !e->speculative)\n \t    {\n \t      error (\"an indirect edge from %s has no corresponding call_stmt\",\n \t\t     identifier_to_locale (cgraph_node_name (e->caller)));"}, {"sha": "78cee2987b166ced2630246356cd46d516744493", "filename": "gcc/cgraph.h", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=042ae7d242e9def81372edef1eff1046851699f0", "patch": "@@ -483,6 +483,24 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgrap\n   unsigned int call_stmt_cannot_inline_p : 1;\n   /* Can this call throw externally?  */\n   unsigned int can_throw_external : 1;\n+  /* Edges with SPECULATIVE flag represents indirect calls that was\n+     speculatively turned into direct (i.e. by profile feedback).\n+     The final code sequence will have form:\n+\n+     if (call_target == expected_fn)\n+       expected_fn ();\n+     else\n+       call_target ();\n+\n+     Every speculative call is represented by three components attached\n+     to a same call statement:\n+     1) a direct call (to expected_fn)\n+     2) an indirect call (to call_target)\n+     3) a IPA_REF_ADDR refrence to expected_fn.\n+\n+     Optimizers may later redirect direct call to clone, so 1) and 3)\n+     do not need to necesarily agree with destination.  */\n+  unsigned int speculative : 1;\n };\n \n #define CGRAPH_FREQ_BASE 1000\n@@ -629,7 +647,7 @@ struct cgraph_node * cgraph_add_thunk (struct cgraph_node *, tree, tree, bool, H\n \t\t\t\t       HOST_WIDE_INT, tree, tree);\n struct cgraph_node *cgraph_node_for_asm (tree);\n struct cgraph_edge *cgraph_edge (struct cgraph_node *, gimple);\n-void cgraph_set_call_stmt (struct cgraph_edge *, gimple);\n+void cgraph_set_call_stmt (struct cgraph_edge *, gimple, bool update_speculative = true);\n void cgraph_update_edges_for_call_stmt (gimple, tree, gimple);\n struct cgraph_local_info *cgraph_local_info (tree);\n struct cgraph_global_info *cgraph_global_info (tree);\n@@ -641,7 +659,7 @@ void cgraph_call_edge_duplication_hooks (struct cgraph_edge *,\n \t\t\t\t         struct cgraph_edge *);\n \n void cgraph_redirect_edge_callee (struct cgraph_edge *, struct cgraph_node *);\n-void cgraph_make_edge_direct (struct cgraph_edge *, struct cgraph_node *);\n+struct cgraph_edge *cgraph_make_edge_direct (struct cgraph_edge *, struct cgraph_node *);\n bool cgraph_only_called_directly_p (struct cgraph_node *);\n \n bool cgraph_function_possibly_inlined_p (tree);\n@@ -702,6 +720,14 @@ bool cgraph_propagate_frequency (struct cgraph_node *node);\n struct cgraph_node * cgraph_function_node (struct cgraph_node *,\n \t\t\t\t\t   enum availability *avail = NULL);\n bool cgraph_get_body (struct cgraph_node *node);\n+void\n+cgraph_turn_edge_to_speculative (struct cgraph_edge *,\n+\t\t\t\t struct cgraph_node *,\n+\t\t\t\t gcov_type, int);\n+void cgraph_speculative_call_info (struct cgraph_edge *,\n+\t\t\t\t   struct cgraph_edge *&,\n+\t\t\t\t   struct cgraph_edge *&,\n+\t\t\t\t   struct ipa_ref *&);\n \n /* In cgraphunit.c  */\n struct asm_node *add_asm_node (tree);\n@@ -735,7 +761,8 @@ struct cgraph_node * cgraph_create_virtual_clone (struct cgraph_node *old_node,\n \t\t\t\t\t\t  const char *clone_name);\n struct cgraph_node *cgraph_find_replacement_node (struct cgraph_node *);\n bool cgraph_remove_node_and_inline_clones (struct cgraph_node *, struct cgraph_node *);\n-void cgraph_set_call_stmt_including_clones (struct cgraph_node *, gimple, gimple);\n+void cgraph_set_call_stmt_including_clones (struct cgraph_node *, gimple, gimple,\n+\t\t\t\t\t    bool update_speculative = true);\n void cgraph_create_edge_including_clones (struct cgraph_node *,\n \t\t\t\t\t  struct cgraph_node *,\n \t\t\t\t\t  gimple, gimple, gcov_type, int,"}, {"sha": "b9c112fef4d53ba39c602a75a4a3223a42ee547d", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=042ae7d242e9def81372edef1eff1046851699f0", "patch": "@@ -483,8 +483,15 @@ cgraph_rebuild_references (void)\n   basic_block bb;\n   struct cgraph_node *node = cgraph_get_node (current_function_decl);\n   gimple_stmt_iterator gsi;\n-\n-  ipa_remove_all_references (&node->symbol.ref_list);\n+  struct ipa_ref *ref;\n+  int i;\n+\n+  /* Keep speculative references for further cgraph edge expansion.  */\n+  for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list, i, ref);)\n+    if (!ref->speculative)\n+      ipa_remove_reference (ref);\n+    else\n+      i++;\n \n   node->count = ENTRY_BLOCK_PTR->count;\n "}, {"sha": "ae26a026d6453fdd4ed43dd632e4ee2d09b6a90b", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=042ae7d242e9def81372edef1eff1046851699f0", "patch": "@@ -147,6 +147,7 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n   /* Clone flags that depend on call_stmt availability manually.  */\n   new_edge->can_throw_external = e->can_throw_external;\n   new_edge->call_stmt_cannot_inline_p = e->call_stmt_cannot_inline_p;\n+  new_edge->speculative = e->speculative;\n   if (update_original)\n     {\n       e->count -= new_edge->count;\n@@ -474,25 +475,45 @@ cgraph_find_replacement_node (struct cgraph_node *node)\n }\n \n /* Like cgraph_set_call_stmt but walk the clone tree and update all\n-   clones sharing the same function body.  */\n+   clones sharing the same function body.  \n+   When WHOLE_SPECULATIVE_EDGES is true, all three components of\n+   speculative edge gets updated.  Otherwise we update only direct\n+   call.  */\n \n void\n cgraph_set_call_stmt_including_clones (struct cgraph_node *orig,\n-\t\t\t\t       gimple old_stmt, gimple new_stmt)\n+\t\t\t\t       gimple old_stmt, gimple new_stmt,\n+\t\t\t\t       bool update_speculative)\n {\n   struct cgraph_node *node;\n   struct cgraph_edge *edge = cgraph_edge (orig, old_stmt);\n \n   if (edge)\n-    cgraph_set_call_stmt (edge, new_stmt);\n+    cgraph_set_call_stmt (edge, new_stmt, update_speculative);\n \n   node = orig->clones;\n   if (node)\n     while (node != orig)\n       {\n \tstruct cgraph_edge *edge = cgraph_edge (node, old_stmt);\n \tif (edge)\n-\t  cgraph_set_call_stmt (edge, new_stmt);\n+\t  {\n+\t    cgraph_set_call_stmt (edge, new_stmt, update_speculative);\n+\t    /* If UPDATE_SPECULATIVE is false, it means that we are turning\n+\t       speculative call into a real code sequence.  Update the\n+\t       callgraph edges.  */\n+\t    if (edge->speculative && !update_speculative)\n+\t      {\n+\t\tstruct cgraph_edge *direct, *indirect;\n+\t\tstruct ipa_ref *ref;\n+\n+\t\tgcc_assert (!edge->indirect_unknown_callee);\n+\t\tcgraph_speculative_call_info (edge, direct, indirect, ref);\n+\t\tdirect->speculative = false;\n+\t\tindirect->speculative = false;\n+\t\tref->speculative = false;\n+\t      }\n+\t  }\n \tif (node->clones)\n \t  node = node->clones;\n \telse if (node->next_sibling_clone)\n@@ -811,6 +832,7 @@ cgraph_materialize_all_clones (void)\n {\n   struct cgraph_node *node;\n   bool stabilized = false;\n+  \n \n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file, \"Materializing clones\\n\");"}, {"sha": "a52bf7f5524cea70767dad659af4231836489c4f", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=042ae7d242e9def81372edef1eff1046851699f0", "patch": "@@ -2278,14 +2278,15 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node,\n \t\t\t\t\t       aggvals);\n       if (target)\n \t{\n+\t  bool agg_contents = ie->indirect_info->agg_contents;\n+\t  bool polymorphic = ie->indirect_info->polymorphic;\n+\t  bool param_index = ie->indirect_info->param_index;\n \t  struct cgraph_edge *cs = ipa_make_edge_direct_to_target (ie, target);\n \t  found = true;\n \n-\t  if (cs && !ie->indirect_info->agg_contents\n-\t      && !ie->indirect_info->polymorphic)\n+\t  if (cs && !agg_contents && !polymorphic)\n \t    {\n \t      struct ipa_node_params *info = IPA_NODE_REF (node);\n-\t      int param_index = ie->indirect_info->param_index;\n \t      int c = ipa_get_controlled_uses (info, param_index);\n \t      if (c != IPA_UNDESCRIBED_USE)\n \t\t{\n@@ -2299,7 +2300,7 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node,\n \t\t  if (c == 0\n \t\t      && (to_del = ipa_find_reference ((symtab_node) node,\n \t\t\t\t\t\t       (symtab_node) cs->callee,\n-\t\t\t\t\t\t       NULL)))\n+\t\t\t\t\t\t       NULL, 0)))\n \t\t    {\n \t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t\tfprintf (dump_file, \"       and even removing its \""}, {"sha": "033b314b34a33ada58d00c36fe884078bfe3f27d", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=042ae7d242e9def81372edef1eff1046851699f0", "patch": "@@ -1388,6 +1388,17 @@ add_new_edges_to_heap (fibheap_t heap, vec<cgraph_edge_p> new_edges)\n     }\n }\n \n+/* Remove EDGE from the fibheap.  */\n+\n+static void\n+heap_edge_removal_hook (struct cgraph_edge *e, void *data)\n+{\n+  if (e->aux)\n+    {\n+      fibheap_delete_node ((fibheap_t)data, (fibnode_t)e->aux);\n+      e->aux = NULL;\n+    }\n+}\n \n /* We use greedy algorithm for inlining of small functions:\n    All inline candidates are put into prioritized heap ordered in\n@@ -1406,10 +1417,14 @@ inline_small_functions (void)\n   vec<cgraph_edge_p> new_indirect_edges = vNULL;\n   int initial_size = 0;\n   struct cgraph_node **order = XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n+  struct cgraph_edge_hook_list *edge_removal_hook_holder;\n \n   if (flag_indirect_inlining)\n     new_indirect_edges.create (8);\n \n+  edge_removal_hook_holder\n+    = cgraph_add_edge_removal_hook (&heap_edge_removal_hook, edge_heap);\n+\n   /* Compute overall unit size and other global parameters used by badness\n      metrics.  */\n \n@@ -1663,6 +1678,7 @@ inline_small_functions (void)\n \t     initial_size, overall_size,\n \t     initial_size ? overall_size * 100 / (initial_size) - 100: 0);\n   BITMAP_FREE (updated_nodes);\n+  cgraph_remove_edge_removal_hook (edge_removal_hook_holder);\n }\n \n /* Flatten NODE.  Performed both during early inlining and"}, {"sha": "b06f640b3f8727a7651b522b37cf66632c59def9", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=042ae7d242e9def81372edef1eff1046851699f0", "patch": "@@ -2313,27 +2313,26 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n      the cgraph node too early.  */\n   gcc_assert (!callee->global.inlined_to);\n \n-  cgraph_make_edge_direct (ie, callee);\n-  es = inline_edge_summary (ie);\n-  es->call_stmt_size -= (eni_size_weights.indirect_call_cost\n-\t\t\t - eni_size_weights.call_cost);\n-  es->call_stmt_time -= (eni_time_weights.indirect_call_cost\n-\t\t\t - eni_time_weights.call_cost);\n   if (dump_file && !unreachable)\n     {\n       fprintf (dump_file, \"ipa-prop: Discovered %s call to a known target \"\n \t       \"(%s/%i -> %s/%i), for stmt \",\n \t       ie->indirect_info->polymorphic ? \"a virtual\" : \"an indirect\",\n \t       xstrdup (cgraph_node_name (ie->caller)),\n \t       ie->caller->symbol.order,\n-\t       xstrdup (cgraph_node_name (ie->callee)),\n-\t       ie->callee->symbol.order);\n+\t       xstrdup (cgraph_node_name (callee)),\n+\t       callee->symbol.order);\n       if (ie->call_stmt)\n \tprint_gimple_stmt (dump_file, ie->call_stmt, 2, TDF_SLIM);\n       else\n \tfprintf (dump_file, \"with uid %i\\n\", ie->lto_stmt_uid);\n-    }\n-  callee = cgraph_function_or_thunk_node (callee, NULL);\n+     }\n+  ie = cgraph_make_edge_direct (ie, callee);\n+  es = inline_edge_summary (ie);\n+  es->call_stmt_size -= (eni_size_weights.indirect_call_cost\n+\t\t\t - eni_size_weights.call_cost);\n+  es->call_stmt_time -= (eni_time_weights.indirect_call_cost\n+\t\t\t - eni_time_weights.call_cost);\n \n   return ie;\n }\n@@ -2374,7 +2373,7 @@ remove_described_reference (symtab_node symbol, struct ipa_cst_ref_desc *rdesc)\n \n   origin = rdesc->cs;\n   to_del = ipa_find_reference ((symtab_node) origin->caller, symbol,\n-\t\t\t       origin->call_stmt);\n+\t\t\t       origin->call_stmt, origin->lto_stmt_uid);\n   gcc_assert (to_del);\n   ipa_remove_reference (to_del);\n   if (dump_file)\n@@ -2408,9 +2407,11 @@ try_make_edge_direct_simple_call (struct cgraph_edge *ie,\n \t\t\t\t  struct ipa_jump_func *jfunc,\n \t\t\t\t  struct ipa_node_params *new_root_info)\n {\n-  struct ipa_cst_ref_desc *rdesc;\n   struct cgraph_edge *cs;\n   tree target;\n+  bool agg_contents = ie->indirect_info->agg_contents;\n+  bool speculative = ie->speculative;\n+  struct ipa_cst_ref_desc *rdesc;\n \n   if (ie->indirect_info->agg_contents)\n     target = ipa_find_agg_cst_for_param (&jfunc->agg,\n@@ -2422,7 +2423,8 @@ try_make_edge_direct_simple_call (struct cgraph_edge *ie,\n     return NULL;\n   cs = ipa_make_edge_direct_to_target (ie, target);\n \n-  if (cs && !ie->indirect_info->agg_contents\n+  /* FIXME: speculative edges can be handled.  */\n+  if (cs && !agg_contents && !speculative\n       && jfunc->type == IPA_JF_CONST\n       && (rdesc = jfunc_rdesc_usable (jfunc))\n       && --rdesc->refcount == 0)\n@@ -2521,7 +2523,14 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n       else\n \tnew_direct_edge = try_make_edge_direct_simple_call (ie, jfunc,\n \t\t\t\t\t\t\t    new_root_info);\n-      if (new_direct_edge)\n+      /* If speculation was removed, then we need to do nothing.  */\n+      if (new_direct_edge && new_direct_edge != ie)\n+\t{\n+\t  new_direct_edge->indirect_inlining_edge = 1;\n+\t  top = IPA_EDGE_REF (cs);\n+\t  res = true;\n+\t}\n+      else if (new_direct_edge)\n \t{\n \t  new_direct_edge->indirect_inlining_edge = 1;\n \t  if (new_direct_edge->call_stmt)\n@@ -2532,9 +2541,9 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \t  if (new_edges)\n \t    {\n \t      new_edges->safe_push (new_direct_edge);\n-\t      top = IPA_EDGE_REF (cs);\n \t      res = true;\n \t    }\n+\t  top = IPA_EDGE_REF (cs);\n \t}\n       else if (jfunc->type == IPA_JF_PASS_THROUGH\n \t       && ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n@@ -2645,7 +2654,7 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t\t  && TREE_CODE (TREE_OPERAND (t, 0)) == FUNCTION_DECL\n \t\t  && (n = cgraph_get_node (TREE_OPERAND (t, 0)))\n \t\t  && (ref = ipa_find_reference ((symtab_node) new_root,\n-\t\t\t\t\t\t(symtab_node) n, NULL)))\n+\t\t\t\t\t\t(symtab_node) n, NULL, 0)))\n \t\t{\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"ipa-prop: Removing cloning-created \"\n@@ -2683,7 +2692,7 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t\t    {\n \t\t      struct ipa_ref *ref;\n \t\t      ref = ipa_find_reference ((symtab_node) clone,\n-\t\t\t\t\t\t(symtab_node) n, NULL);\n+\t\t\t\t\t\t(symtab_node) n, NULL, 0);\n \t\t      if (ref)\n \t\t\t{\n \t\t\t  if (dump_file)"}, {"sha": "9f45c8eb866f35cca2e7aea12dc5812f312a9322", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 60, "deletions": 15, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=042ae7d242e9def81372edef1eff1046851699f0", "patch": "@@ -38,7 +38,7 @@ ipa_record_reference (symtab_node referring_node,\n \t\t      symtab_node referred_node,\n \t\t      enum ipa_ref_use use_type, gimple stmt)\n {\n-  struct ipa_ref *ref;\n+  struct ipa_ref *ref, *ref2;\n   struct ipa_ref_list *list, *list2;\n   ipa_ref_t *old_references;\n \n@@ -56,14 +56,16 @@ ipa_record_reference (symtab_node referring_node,\n   ref->referring = referring_node;\n   ref->referred = referred_node;\n   ref->stmt = stmt;\n+  ref->lto_stmt_uid = 0;\n   ref->use = use_type;\n+  ref->speculative = 0;\n \n   /* If vector was moved in memory, update pointers.  */\n   if (old_references != list->references->address ())\n     {\n       int i;\n-      for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)\n-\tipa_ref_referred_ref_list (ref)->referring[ref->referred_index] = ref;\n+      for (i = 0; ipa_ref_list_reference_iterate (list, i, ref2); i++)\n+\tipa_ref_referred_ref_list (ref2)->referring[ref2->referred_index] = ref2;\n     }\n   return ref;\n }\n@@ -155,6 +157,8 @@ ipa_dump_references (FILE * file, struct ipa_ref_list *list)\n                symtab_node_asm_name (ref->referred),\n                ref->referred->symbol.order,\n \t       ipa_ref_use_name [ref->use]);\n+      if (ref->speculative)\n+\tfprintf (file, \" (speculative)\");\n     }\n   fprintf (file, \"\\n\");\n }\n@@ -172,22 +176,50 @@ ipa_dump_referring (FILE * file, struct ipa_ref_list *list)\n                symtab_node_asm_name (ref->referring),\n                ref->referring->symbol.order,\n \t       ipa_ref_use_name [ref->use]);\n+      if (ref->speculative)\n+\tfprintf (file, \" (speculative)\");\n     }\n   fprintf (file, \"\\n\");\n }\n \n+/* Clone reference REF to DEST_NODE and set its stmt to STMT.  */\n+\n+struct ipa_ref *\n+ipa_clone_ref (struct ipa_ref *ref,\n+\t       symtab_node dest_node,\n+\t       gimple stmt)\n+{\n+  bool speculative = ref->speculative;\n+  unsigned int stmt_uid = ref->lto_stmt_uid;\n+  struct ipa_ref *ref2;\n+\n+  ref2 = ipa_record_reference (dest_node,\n+\t\t\t       ref->referred,\n+\t\t\t       ref->use, stmt);\n+  ref2->speculative = speculative;\n+  ref2->lto_stmt_uid = stmt_uid;\n+  return ref2;\n+}\n+\n /* Clone all references from SRC to DEST_NODE or DEST_VARPOOL_NODE.  */\n \n void\n ipa_clone_references (symtab_node dest_node,\n \t\t      struct ipa_ref_list *src)\n {\n-  struct ipa_ref *ref;\n+  struct ipa_ref *ref, *ref2;\n   int i;\n   for (i = 0; ipa_ref_list_reference_iterate (src, i, ref); i++)\n-    ipa_record_reference (dest_node,\n-\t\t\t  ref->referred,\n-\t\t\t  ref->use, ref->stmt);\n+    {\n+      bool speculative = ref->speculative;\n+      unsigned int stmt_uid = ref->lto_stmt_uid;\n+\n+      ref2 = ipa_record_reference (dest_node,\n+\t\t\t\t   ref->referred,\n+\t\t\t\t   ref->use, ref->stmt);\n+      ref2->speculative = speculative;\n+      ref2->lto_stmt_uid = stmt_uid;\n+    }\n }\n \n /* Clone all referring from SRC to DEST_NODE or DEST_VARPOOL_NODE.  */\n@@ -196,12 +228,19 @@ void\n ipa_clone_referring (symtab_node dest_node,\n \t\t    struct ipa_ref_list *src)\n {\n-  struct ipa_ref *ref;\n+  struct ipa_ref *ref, *ref2;\n   int i;\n   for (i = 0; ipa_ref_list_referring_iterate (src, i, ref); i++)\n-    ipa_record_reference (ref->referring,\n-\t\t\t  dest_node,\n-\t\t\t  ref->use, ref->stmt);\n+    {\n+      bool speculative = ref->speculative;\n+      unsigned int stmt_uid = ref->lto_stmt_uid;\n+\n+      ref2 = ipa_record_reference (ref->referring,\n+\t\t\t\t   dest_node,\n+\t\t\t\t   ref->use, ref->stmt);\n+      ref2->speculative = speculative;\n+      ref2->lto_stmt_uid = stmt_uid;\n+    }\n }\n \n /* Return true when execution of REF can lead to return from\n@@ -230,14 +269,17 @@ ipa_ref_has_aliases_p (struct ipa_ref_list *ref_list)\n \n struct ipa_ref *\n ipa_find_reference (symtab_node referring_node, symtab_node referred_node,\n-\t\t    gimple stmt)\n+\t\t    gimple stmt, unsigned int lto_stmt_uid)\n {\n   struct ipa_ref *r = NULL;\n   int i;\n \n   for (i = 0; ipa_ref_list_reference_iterate (&referring_node->symbol.ref_list, i, r); i++)\n     if (r->referred == referred_node\n-\t&& (in_lto_p || r->stmt == stmt))\n+\t&& !r->speculative\n+\t&& ((stmt && r->stmt == stmt)\n+\t    || (lto_stmt_uid && r->lto_stmt_uid == lto_stmt_uid)\n+\t    || (!stmt && !lto_stmt_uid && !r->stmt && !r->lto_stmt_uid)))\n       return r;\n   return NULL;\n }\n@@ -257,7 +299,9 @@ ipa_remove_stmt_references (symtab_node referring_node, gimple stmt)\n }\n \n /* Remove all stmt references in non-speculative references.\n-   Those are not maintained during inlining & clonning. */\n+   Those are not maintained during inlining & clonning. \n+   The exception are speculative references that are updated along\n+   with callgraph edges associated with them.  */\n \n void\n ipa_clear_stmts_in_references (symtab_node referring_node)\n@@ -266,5 +310,6 @@ ipa_clear_stmts_in_references (symtab_node referring_node)\n   int i;\n \n   for (i = 0; ipa_ref_list_reference_iterate (&referring_node->symbol.ref_list, i, r); i++)\n-    r->stmt = NULL;\n+    if (!r->speculative)\n+      r->stmt = NULL;\n }"}, {"sha": "e0553bb660925f0b0aaae417553167a59da99d09", "filename": "gcc/ipa-ref.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fipa-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fipa-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.h?ref=042ae7d242e9def81372edef1eff1046851699f0", "patch": "@@ -40,8 +40,10 @@ struct GTY(()) ipa_ref\n   symtab_node referring;\n   symtab_node referred;\n   gimple stmt;\n+  unsigned int lto_stmt_uid;\n   unsigned int referred_index;\n   ENUM_BITFIELD (ipa_ref_use) use:2;\n+  unsigned int speculative:1;\n };\n \n typedef struct ipa_ref ipa_ref_t;\n@@ -71,8 +73,9 @@ void ipa_dump_references (FILE *, struct ipa_ref_list *);\n void ipa_dump_referring (FILE *, struct ipa_ref_list *);\n void ipa_clone_references (symtab_node, struct ipa_ref_list *);\n void ipa_clone_referring (symtab_node, struct ipa_ref_list *);\n+struct ipa_ref * ipa_clone_ref (struct ipa_ref *, symtab_node, gimple);\n bool ipa_ref_cannot_lead_to_return (struct ipa_ref *);\n bool ipa_ref_has_aliases_p (struct ipa_ref_list *);\n-struct ipa_ref * ipa_find_reference (symtab_node, symtab_node, gimple);\n+struct ipa_ref * ipa_find_reference (symtab_node, symtab_node, gimple, unsigned int);\n void ipa_remove_stmt_references (symtab_node, gimple);\n void ipa_clear_stmts_in_references (symtab_node);"}, {"sha": "e0d09913ae75954e49225086419a1cbd754c87f1", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=042ae7d242e9def81372edef1eff1046851699f0", "patch": "@@ -273,12 +273,13 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n \n   bp = bitpack_create (ob->main_stream);\n   uid = (!gimple_has_body_p (edge->caller->symbol.decl)\n-\t ? edge->lto_stmt_uid : gimple_uid (edge->call_stmt));\n+\t ? edge->lto_stmt_uid : gimple_uid (edge->call_stmt) + 1);\n   bp_pack_enum (&bp, cgraph_inline_failed_enum,\n \t        CIF_N_REASONS, edge->inline_failed);\n   bp_pack_var_len_unsigned (&bp, uid);\n   bp_pack_var_len_unsigned (&bp, edge->frequency);\n   bp_pack_value (&bp, edge->indirect_inlining_edge, 1);\n+  bp_pack_value (&bp, edge->speculative, 1);\n   bp_pack_value (&bp, edge->call_stmt_cannot_inline_p, 1);\n   bp_pack_value (&bp, edge->can_throw_external, 1);\n   if (edge->indirect_unknown_callee)\n@@ -589,13 +590,24 @@ lto_output_ref (struct lto_simple_output_block *ob, struct ipa_ref *ref,\n {\n   struct bitpack_d bp;\n   int nref;\n+  int uid = ref->lto_stmt_uid;\n+  struct cgraph_node *node;\n \n   bp = bitpack_create (ob->main_stream);\n   bp_pack_value (&bp, ref->use, 2);\n+  bp_pack_value (&bp, ref->speculative, 1);\n   streamer_write_bitpack (&bp);\n   nref = lto_symtab_encoder_lookup (encoder, ref->referred);\n   gcc_assert (nref != LCC_NOT_FOUND);\n   streamer_write_hwi_stream (ob->main_stream, nref);\n+  \n+  node = dyn_cast <cgraph_node> (ref->referring);\n+  if (node)\n+    {\n+      if (ref->stmt)\n+\tuid = gimple_uid (ref->stmt) + 1;\n+      streamer_write_hwi_stream (ob->main_stream, uid);\n+    }\n }\n \n /* Stream out profile_summary to OB.  */\n@@ -1116,11 +1128,17 @@ input_ref (struct lto_input_block *ib,\n   symtab_node node = NULL;\n   struct bitpack_d bp;\n   enum ipa_ref_use use;\n+  bool speculative;\n+  struct ipa_ref *ref;\n \n   bp = streamer_read_bitpack (ib);\n   use = (enum ipa_ref_use) bp_unpack_value (&bp, 2);\n+  speculative = (enum ipa_ref_use) bp_unpack_value (&bp, 1);\n   node = nodes[streamer_read_hwi (ib)];\n-  ipa_record_reference (referring_node, node, use, NULL);\n+  ref = ipa_record_reference (referring_node, node, use, NULL);\n+  ref->speculative = speculative;\n+  if (is_a <cgraph_node> (referring_node))\n+    ref->lto_stmt_uid = streamer_read_hwi (ib);\n }\n \n /* Read an edge from IB.  NODES points to a vector of previously read nodes for\n@@ -1167,6 +1185,7 @@ input_edge (struct lto_input_block *ib, vec<symtab_node> nodes,\n     edge = cgraph_create_edge (caller, callee, NULL, count, freq);\n \n   edge->indirect_inlining_edge = bp_unpack_value (&bp, 1);\n+  edge->speculative = bp_unpack_value (&bp, 1);\n   edge->lto_stmt_uid = stmt_id;\n   edge->inline_failed = inline_failed;\n   edge->call_stmt_cannot_inline_p = bp_unpack_value (&bp, 1);"}, {"sha": "0684cdaa7bad4bade829410ecf3373f09008cad2", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=042ae7d242e9def81372edef1eff1046851699f0", "patch": "@@ -755,30 +755,60 @@ input_ssa_names (struct lto_input_block *ib, struct data_in *data_in,\n    so they point to STMTS.  */\n \n static void\n-fixup_call_stmt_edges_1 (struct cgraph_node *node, gimple *stmts)\n+fixup_call_stmt_edges_1 (struct cgraph_node *node, gimple *stmts,\n+\t\t\t struct function *fn)\n {\n   struct cgraph_edge *cedge;\n+  struct ipa_ref *ref;\n+  unsigned int i;\n+\n   for (cedge = node->callees; cedge; cedge = cedge->next_callee)\n-    cedge->call_stmt = stmts[cedge->lto_stmt_uid];\n+    {\n+      if (gimple_stmt_max_uid (fn) < cedge->lto_stmt_uid)\n+      fatal_error (\"Cgraph edge statement index out of range\");\n+      cedge->call_stmt = stmts[cedge->lto_stmt_uid - 1];\n+      if (!cedge->call_stmt)\n+      fatal_error (\"Cgraph edge statement index not found\");\n+    }\n   for (cedge = node->indirect_calls; cedge; cedge = cedge->next_callee)\n-    cedge->call_stmt = stmts[cedge->lto_stmt_uid];\n+    {\n+      if (gimple_stmt_max_uid (fn) < cedge->lto_stmt_uid)\n+      fatal_error (\"Cgraph edge statement index out of range\");\n+      cedge->call_stmt = stmts[cedge->lto_stmt_uid - 1];\n+      if (!cedge->call_stmt)\n+      fatal_error (\"Cgraph edge statement index not found\");\n+    }\n+  for (i = 0;\n+       ipa_ref_list_reference_iterate (&node->symbol.ref_list, i, ref);\n+       i++)\n+    if (ref->lto_stmt_uid)\n+      {\n+\tif (gimple_stmt_max_uid (fn) < ref->lto_stmt_uid)\n+\t  fatal_error (\"Reference statement index out of range\");\n+\tref->stmt = stmts[ref->lto_stmt_uid - 1];\n+\tif (!ref->stmt)\n+\t  fatal_error (\"Reference statement index not found\");\n+      }\n }\n \n+\n /* Fixup call_stmt pointers in NODE and all clones.  */\n \n static void\n fixup_call_stmt_edges (struct cgraph_node *orig, gimple *stmts)\n {\n   struct cgraph_node *node;\n+  struct function *fn;\n \n   while (orig->clone_of)\n     orig = orig->clone_of;\n+  fn = DECL_STRUCT_FUNCTION (orig->symbol.decl);\n \n-  fixup_call_stmt_edges_1 (orig, stmts);\n+  fixup_call_stmt_edges_1 (orig, stmts, fn);\n   if (orig->clones)\n     for (node = orig->clones; node != orig;)\n       {\n-\tfixup_call_stmt_edges_1 (node, stmts);\n+\tfixup_call_stmt_edges_1 (node, stmts, fn);\n \tif (node->clones)\n \t  node = node->clones;\n \telse if (node->next_sibling_clone)"}, {"sha": "00e31982957ba59d3513e486a2590b8a9fcb8fc1", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 108, "deletions": 50, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=042ae7d242e9def81372edef1eff1046851699f0", "patch": "@@ -1676,32 +1676,61 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t  if (edge)\n \t\t    {\n \t\t      int edge_freq = edge->frequency;\n+\t\t      int new_freq;\n+\t\t      struct cgraph_edge *old_edge = edge;\n \t\t      edge = cgraph_clone_edge (edge, id->dst_node, stmt,\n \t\t\t\t\t        gimple_uid (stmt),\n \t\t\t\t\t        REG_BR_PROB_BASE, CGRAPH_FREQ_BASE,\n \t\t\t\t\t        true);\n \t\t      /* We could also just rescale the frequency, but\n \t\t         doing so would introduce roundoff errors and make\n \t\t\t verifier unhappy.  */\n-\t\t      edge->frequency\n-\t\t        = compute_call_stmt_bb_frequency (id->dst_node->symbol.decl,\n-\t\t\t\t\t\t\t  copy_basic_block);\n-\t\t      if (dump_file\n-\t\t      \t  && profile_status_for_function (cfun) != PROFILE_ABSENT\n-\t\t\t  && (edge_freq > edge->frequency + 10\n-\t\t\t      || edge_freq < edge->frequency - 10))\n+\t\t      new_freq  = compute_call_stmt_bb_frequency (id->dst_node->symbol.decl,\n+\t\t\t\t\t\t\t\t  copy_basic_block);\n+\n+\t\t      /* Speculative calls consist of two edges - direct and indirect.\n+\t\t\t Duplicate the whole thing and distribute frequencies accordingly.  */\n+\t\t      if (edge->speculative)\n+\t\t\t{\n+\t\t\t  struct cgraph_edge *direct, *indirect;\n+\t\t\t  struct ipa_ref *ref;\n+\n+\t\t\t  gcc_assert (!edge->indirect_unknown_callee);\n+\t\t\t  cgraph_speculative_call_info (old_edge, direct, indirect, ref);\n+\t\t\t  indirect = cgraph_clone_edge (indirect, id->dst_node, stmt,\n+\t\t\t\t\t\t\tgimple_uid (stmt),\n+\t\t\t\t\t\t\tREG_BR_PROB_BASE, CGRAPH_FREQ_BASE,\n+\t\t\t\t\t\t\ttrue);\n+\t\t\t  if (old_edge->frequency + indirect->frequency)\n+\t\t\t    {\n+\t\t\t      edge->frequency = MIN (RDIV ((gcov_type)new_freq * old_edge->frequency,\n+\t\t\t\t\t\t           (old_edge->frequency + indirect->frequency)),\n+\t\t\t\t\t\t     CGRAPH_FREQ_MAX);\n+\t\t\t      indirect->frequency = MIN (RDIV ((gcov_type)new_freq * indirect->frequency,\n+\t\t\t\t\t\t\t       (old_edge->frequency + indirect->frequency)),\n+\t\t\t\t\t\t\t CGRAPH_FREQ_MAX);\n+\t\t\t    }\n+\t\t\t  ipa_clone_ref (ref, (symtab_node)id->dst_node, stmt);\n+\t\t\t}\n+\t\t      else\n \t\t\t{\n-\t\t\t  fprintf (dump_file, \"Edge frequency estimated by \"\n-\t\t\t           \"cgraph %i diverge from inliner's estimate %i\\n\",\n-\t\t\t  \t   edge_freq,\n-\t\t\t\t   edge->frequency);\n-\t\t\t  fprintf (dump_file,\n-\t\t\t  \t   \"Orig bb: %i, orig bb freq %i, new bb freq %i\\n\",\n-\t\t\t\t   bb->index,\n-\t\t\t\t   bb->frequency,\n-\t\t\t\t   copy_basic_block->frequency);\n+\t\t\t  edge->frequency = new_freq;\n+\t\t\t  if (dump_file\n+\t\t\t      && profile_status_for_function (cfun) != PROFILE_ABSENT\n+\t\t\t      && (edge_freq > edge->frequency + 10\n+\t\t\t\t  || edge_freq < edge->frequency - 10))\n+\t\t\t    {\n+\t\t\t      fprintf (dump_file, \"Edge frequency estimated by \"\n+\t\t\t\t       \"cgraph %i diverge from inliner's estimate %i\\n\",\n+\t\t\t\t       edge_freq,\n+\t\t\t\t       edge->frequency);\n+\t\t\t      fprintf (dump_file,\n+\t\t\t\t       \"Orig bb: %i, orig bb freq %i, new bb freq %i\\n\",\n+\t\t\t\t       bb->index,\n+\t\t\t\t       bb->frequency,\n+\t\t\t\t       copy_basic_block->frequency);\n+\t\t\t    }\n \t\t\t}\n-\t\t      stmt = cgraph_redirect_edge_call_stmt_to_callee (edge);\n \t\t    }\n \t\t  break;\n \n@@ -2232,6 +2261,23 @@ copy_loops (bitmap blocks_to_copy,\n     }\n }\n \n+/* Call cgraph_redirect_edge_call_stmt_to_callee on all calls in BB */\n+\n+void\n+redirect_all_calls (copy_body_data * id, basic_block bb)\n+{\n+  gimple_stmt_iterator si;\n+  for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+    {\n+      if (is_gimple_call (gsi_stmt (si)))\n+\t{\n+\t  struct cgraph_edge *edge = cgraph_edge (id->dst_node, gsi_stmt (si));\n+\t  if (edge)\n+\t    cgraph_redirect_edge_call_stmt_to_callee (edge);\n+\t}\n+    }\n+}\n+\n /* Make a copy of the body of FN so that it can be inserted inline in\n    another function.  Walks FN via CFG, returns new fndecl.  */\n \n@@ -2356,6 +2402,10 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n \t    && bb->index != ENTRY_BLOCK\n \t    && bb->index != EXIT_BLOCK)\n \t  maybe_move_debug_stmts_to_successors (id, (basic_block) bb->aux);\n+\t/* Update call edge destinations.  This can not be done before loop\n+\t   info is updated, because we may split basic blocks.  */\n+\tif (id->transform_call_graph_edges == CB_CGE_DUPLICATE)\n+\t  redirect_all_calls (id, (basic_block)bb->aux);\n \t((basic_block)bb->aux)->aux = NULL;\n \tbb->aux = NULL;\n       }\n@@ -2367,6 +2417,10 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n       if (need_debug_cleanup)\n \tmaybe_move_debug_stmts_to_successors (id, BASIC_BLOCK (last));\n       BASIC_BLOCK (last)->aux = NULL;\n+      /* Update call edge destinations.  This can not be done before loop\n+\t info is updated, because we may split basic blocks.  */\n+      if (id->transform_call_graph_edges == CB_CGE_DUPLICATE)\n+\tredirect_all_calls (id, BASIC_BLOCK (last));\n     }\n   entry_block_map->aux = NULL;\n   exit_block_map->aux = NULL;\n@@ -4941,43 +4995,47 @@ delete_unreachable_blocks_update_callgraph (copy_body_data *id)\n           gimple_stmt_iterator bsi;\n \n           for (bsi = gsi_start_bb (b); !gsi_end_p (bsi); gsi_next (&bsi))\n-\t    if (gimple_code (gsi_stmt (bsi)) == GIMPLE_CALL)\n-\t      {\n-\t        struct cgraph_edge *e;\n-\t\tstruct cgraph_node *node;\n+\t    {\n+\t      struct cgraph_edge *e;\n+\t      struct cgraph_node *node;\n \n-\t        if ((e = cgraph_edge (id->dst_node, gsi_stmt (bsi))) != NULL)\n+\t      ipa_remove_stmt_references ((symtab_node)id->dst_node, gsi_stmt (bsi));\n+\n+\t      if (gimple_code (gsi_stmt (bsi)) == GIMPLE_CALL\n+\t\t  &&(e = cgraph_edge (id->dst_node, gsi_stmt (bsi))) != NULL)\n+\t\t{\n+\t\t  if (!e->inline_failed)\n+\t\t    cgraph_remove_node_and_inline_clones (e->callee, id->dst_node);\n+\t\t  else\n+\t\t    cgraph_remove_edge (e);\n+\t\t}\n+\t      if (id->transform_call_graph_edges == CB_CGE_MOVE_CLONES\n+\t\t  && id->dst_node->clones)\n+\t\tfor (node = id->dst_node->clones; node != id->dst_node;)\n \t\t  {\n-\t\t    if (!e->inline_failed)\n-\t\t      cgraph_remove_node_and_inline_clones (e->callee, id->dst_node);\n+\t\t    ipa_remove_stmt_references ((symtab_node)node, gsi_stmt (bsi));\n+\t\t    if (gimple_code (gsi_stmt (bsi)) == GIMPLE_CALL\n+\t\t\t&& (e = cgraph_edge (node, gsi_stmt (bsi))) != NULL)\n+\t\t      {\n+\t\t\tif (!e->inline_failed)\n+\t\t\t  cgraph_remove_node_and_inline_clones (e->callee, id->dst_node);\n+\t\t\telse\n+\t\t\t  cgraph_remove_edge (e);\n+\t\t      }\n+\n+\t\t    if (node->clones)\n+\t\t      node = node->clones;\n+\t\t    else if (node->next_sibling_clone)\n+\t\t      node = node->next_sibling_clone;\n \t\t    else\n-\t              cgraph_remove_edge (e);\n+\t\t      {\n+\t\t\twhile (node != id->dst_node && !node->next_sibling_clone)\n+\t\t\t  node = node->clone_of;\n+\t\t\tif (node != id->dst_node)\n+\t\t\t  node = node->next_sibling_clone;\n+\t\t      }\n \t\t  }\n-\t\tif (id->transform_call_graph_edges == CB_CGE_MOVE_CLONES\n-\t\t    && id->dst_node->clones)\n-     \t\t  for (node = id->dst_node->clones; node != id->dst_node;)\n-\t\t    {\n-\t              if ((e = cgraph_edge (node, gsi_stmt (bsi))) != NULL)\n-\t\t\t{\n-\t\t          if (!e->inline_failed)\n-\t\t            cgraph_remove_node_and_inline_clones (e->callee, id->dst_node);\n-\t\t\t  else\n-\t                    cgraph_remove_edge (e);\n-\t\t\t}\n-\n-\t\t      if (node->clones)\n-\t\t\tnode = node->clones;\n-\t\t      else if (node->next_sibling_clone)\n-\t\t\tnode = node->next_sibling_clone;\n-\t\t      else\n-\t\t\t{\n-\t\t\t  while (node != id->dst_node && !node->next_sibling_clone)\n-\t\t\t    node = node->clone_of;\n-\t\t\t  if (node != id->dst_node)\n-\t\t\t    node = node->next_sibling_clone;\n-\t\t\t}\n-\t\t    }\n-\t      }\n+\t    }\n \t  delete_basic_block (b);\n \t  changed = true;\n \t}"}, {"sha": "c198c650a6013e6c2514c7b972eadb954ace5b23", "filename": "gcc/value-prof.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=042ae7d242e9def81372edef1eff1046851699f0", "patch": "@@ -1248,7 +1248,7 @@ check_ic_target (gimple call_stmt, struct cgraph_node *target)\n     old call\n  */\n \n-static gimple\n+gimple\n gimple_ic (gimple icall_stmt, struct cgraph_node *direct_call,\n \t   int prob, gcov_type count, gcov_type all)\n {"}, {"sha": "fca6bc565b52ce0b890fa5d94d0c31ff090609eb", "filename": "gcc/value-prof.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/042ae7d242e9def81372edef1eff1046851699f0/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=042ae7d242e9def81372edef1eff1046851699f0", "patch": "@@ -86,6 +86,8 @@ void gimple_move_stmt_histograms (struct function *, gimple, gimple);\n void verify_histograms (void);\n void free_histograms (void);\n void stringop_block_profile (gimple, unsigned int *, HOST_WIDE_INT *);\n+gimple gimple_ic (gimple, struct cgraph_node *, int, gcov_type, gcov_type);\n+\n \n /* In tree-profile.c.  */\n extern void gimple_init_edge_profiler (void);"}]}