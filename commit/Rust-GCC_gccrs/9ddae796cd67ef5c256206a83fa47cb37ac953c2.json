{"sha": "9ddae796cd67ef5c256206a83fa47cb37ac953c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRkYWU3OTZjZDY3ZWY1YzI1NjIwNmE4M2ZhNDdjYjM3YWM5NTNjMg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-03-28T02:41:14Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-03-28T02:41:14Z"}, "message": "fold-const.c (fold_inf_compare): New function to simplify FP comparisons against +Infinity or -Infinity.\n\n\n\t* fold-const.c (fold_inf_compare):  New function to simplify FP\n\tcomparisons against +Infinity or -Infinity.\n\t(fold):  Optimize floating point comparisons against Infs and NaNs.\n\n\t* gcc.c-torture/execute/ieee/fp-cmp-6.c: New test case.\n\t* gcc.c-torture/execute/ieee/fp-cmp-7.c: New test case.\n\nFrom-SVN: r64945", "tree": {"sha": "b0c28630163f7f911309e25022ada80efb24b629", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0c28630163f7f911309e25022ada80efb24b629"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ddae796cd67ef5c256206a83fa47cb37ac953c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ddae796cd67ef5c256206a83fa47cb37ac953c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ddae796cd67ef5c256206a83fa47cb37ac953c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ddae796cd67ef5c256206a83fa47cb37ac953c2/comments", "author": null, "committer": null, "parents": [{"sha": "36875565ebc10f5c19ea9303551077618d52b35f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36875565ebc10f5c19ea9303551077618d52b35f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36875565ebc10f5c19ea9303551077618d52b35f"}], "stats": {"total": 163, "additions": 149, "deletions": 14}, "files": [{"sha": "80acf516402d42211af55a49b8bbb917493f3573", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ddae796cd67ef5c256206a83fa47cb37ac953c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ddae796cd67ef5c256206a83fa47cb37ac953c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ddae796cd67ef5c256206a83fa47cb37ac953c2", "patch": "@@ -1,3 +1,9 @@\n+2003-03-27  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (fold_inf_compare):  New function to simplify FP\n+\tcomparisons against +Infinity or -Infinity.\n+\t(fold):  Optimize floating point comparisons against Infs and NaNs.\n+\n 2003-03-27  Janis Johnson  <janis187@us.ibm.com>\n \n \t* libgcov.c: Provide only dummy functions if libc is not available."}, {"sha": "6e17e00340ed1a473d86c6ec6e30c04bbe4111da", "filename": "gcc/fold-const.c", "status": "modified", "additions": 93, "deletions": 14, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ddae796cd67ef5c256206a83fa47cb37ac953c2/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ddae796cd67ef5c256206a83fa47cb37ac953c2/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=9ddae796cd67ef5c256206a83fa47cb37ac953c2", "patch": "@@ -114,6 +114,7 @@ static tree fold_binary_op_with_conditional_arg\n static bool fold_real_zero_addition_p\tPARAMS ((tree, tree, int));\n static tree fold_mathfn_compare\tPARAMS ((enum built_in_function,\n \t\t\t\t\t enum tree_code, tree, tree, tree));\n+static tree fold_inf_compare\tPARAMS ((enum tree_code, tree, tree, tree));\n \n /* The following constants represent a bit based encoding of GCC's\n    comparison operators.  This encoding simplifies transformations\n@@ -4798,6 +4799,62 @@ fold_mathfn_compare (fcode, code, type, arg0, arg1)\n   return NULL_TREE;\n }\n \n+/* Subroutine of fold() that optimizes comparisons against Infinities,\n+   either +Inf or -Inf.\n+\n+   CODE is the comparison operator: EQ_EXPR, NE_EXPR, GT_EXPR, LT_EXPR,\n+   GE_EXPR or LE_EXPR.  TYPE is the type of the result and ARG0 and ARG1\n+   are the operands of the comparison.  ARG1 must be a TREE_REAL_CST.\n+\n+   The function returns the constant folded tree if a simplification\n+   can be made, and NULL_TREE otherwise.  */\n+\n+static tree\n+fold_inf_compare (code, type, arg0, arg1)\n+     enum tree_code code;\n+     tree type, arg0, arg1;\n+{\n+  /* For negative infinity swap the sense of the comparison.  */\n+  if (REAL_VALUE_NEGATIVE (TREE_REAL_CST (arg1)))\n+    code = swap_tree_comparison (code);\n+\n+  switch (code)\n+    {\n+    case GT_EXPR:\n+      /* x > +Inf is always false, if with ignore sNANs.  */\n+      if (HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0))))\n+        return NULL_TREE;\n+      return omit_one_operand (type,\n+\t\t\t       convert (type, integer_zero_node),\n+\t\t\t       arg0);\n+\n+    case LE_EXPR:\n+      /* x <= +Inf is always true, if we don't case about NaNs.  */\n+      if (! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0))))\n+\treturn omit_one_operand (type,\n+\t\t\t\t convert (type, integer_one_node),\n+\t\t\t\t arg0);\n+\n+      /* x <= +Inf is the same as x == x, i.e. isfinite(x).  */\n+      if ((*lang_hooks.decls.global_bindings_p) () == 0\n+\t  && ! contains_placeholder_p (arg0))\n+\t{\n+\t  arg0 = save_expr (arg0);\n+\t  return fold (build (EQ_EXPR, type, arg0, arg0));\n+\t}\n+      break;\n+\n+    case EQ_EXPR:  /* ??? x == +Inf is x > DBL_MAX  */\n+    case GE_EXPR:  /* ??? x >= +Inf is x > DBL_MAX  */\n+    case LT_EXPR:  /* ??? x < +Inf is x <= DBL_MAX  */\n+    case NE_EXPR:  /* ??? x != +Inf is !(x > DBL_MAX)  */\n+\n+    default:\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n \n /* Perform constant folding and related simplification of EXPR.\n    The related simplifications include x*1 => x, x*0 => 0, etc.,\n@@ -6317,20 +6374,42 @@ fold (expr)\n \t      && TREE_CODE (arg1) == NEGATE_EXPR)\n \t    return fold (build (code, type, TREE_OPERAND (arg1, 0),\n \t\t\t\tTREE_OPERAND (arg0, 0)));\n-\t  /* (-a) CMP CST -> a swap(CMP) (-CST)  */\n-\t  if (TREE_CODE (arg0) == NEGATE_EXPR && TREE_CODE (arg1) == REAL_CST)\n-\t    return\n-\t      fold (build\n-\t\t    (swap_tree_comparison (code), type,\n-\t\t     TREE_OPERAND (arg0, 0),\n-\t\t     build_real (TREE_TYPE (arg1),\n-\t\t\t\t REAL_VALUE_NEGATE (TREE_REAL_CST (arg1)))));\n-\t  /* IEEE doesn't distinguish +0 and -0 in comparisons.  */\n-\t  /* a CMP (-0) -> a CMP 0  */\n-\t  if (TREE_CODE (arg1) == REAL_CST\n-\t      && REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (arg1)))\n-\t    return fold (build (code, type, arg0,\n-\t\t\t\tbuild_real (TREE_TYPE (arg1), dconst0)));\n+\n+\t  if (TREE_CODE (arg1) == REAL_CST)\n+\t  {\n+\t    REAL_VALUE_TYPE cst;\n+\t    cst = TREE_REAL_CST (arg1);\n+\n+\t    /* (-a) CMP CST -> a swap(CMP) (-CST)  */\n+\t    if (TREE_CODE (arg0) == NEGATE_EXPR)\n+\t      return\n+\t\tfold (build (swap_tree_comparison (code), type,\n+\t\t\t     TREE_OPERAND (arg0, 0),\n+\t\t\t     build_real (TREE_TYPE (arg1),\n+\t\t\t\t\t REAL_VALUE_NEGATE (cst))));\n+\n+\t    /* IEEE doesn't distinguish +0 and -0 in comparisons.  */\n+\t    /* a CMP (-0) -> a CMP 0  */\n+\t    if (REAL_VALUE_MINUS_ZERO (cst))\n+\t      return fold (build (code, type, arg0,\n+\t\t\t\t  build_real (TREE_TYPE (arg1), dconst0)));\n+\n+\t    /* x != NaN is always true, other ops are always false.  */\n+\t    if (REAL_VALUE_ISNAN (cst)\n+\t\t&& ! HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg1))))\n+\t      {\n+\t\tt = (code == NE_EXPR) ? integer_one_node : integer_zero_node;\n+\t\treturn omit_one_operand (type, convert (type, t), arg0);\n+\t      }\n+\n+\t    /* Fold comparisons against infinity.  */\n+\t    if (REAL_VALUE_ISINF (cst))\n+\t      {\n+\t\ttem = fold_inf_compare (code, type, arg0, arg1);\n+\t\tif (tem != NULL_TREE)\n+\t\t  return tem;\n+\t      }\n+\t  }\n \n \t  /* If this is a comparison of a real constant with a PLUS_EXPR\n \t     or a MINUS_EXPR of a real constant, we can convert it into a"}, {"sha": "f9d63b210a7d51287a0c55e942120faad2bb6a82", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ddae796cd67ef5c256206a83fa47cb37ac953c2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ddae796cd67ef5c256206a83fa47cb37ac953c2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9ddae796cd67ef5c256206a83fa47cb37ac953c2", "patch": "@@ -1,3 +1,8 @@\n+2003-03-27  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.c-torture/execute/ieee/fp-cmp-6.c: New test case.\n+\t* gcc.c-torture/execute/ieee/fp-cmp-7.c: New test case.\n+\n 2003-03-27  Mark Mitchell  <mark@codesourcery.com>\n \n \t* lib/gcov.exp (run-gcov): Add branches and calls options, rather"}, {"sha": "9111d6e5c46fa8d882e78f7af375d5d6eb2d6606", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/fp-cmp-6.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ddae796cd67ef5c256206a83fa47cb37ac953c2/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Ffp-cmp-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ddae796cd67ef5c256206a83fa47cb37ac953c2/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Ffp-cmp-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Ffp-cmp-6.c?ref=9ddae796cd67ef5c256206a83fa47cb37ac953c2", "patch": "@@ -0,0 +1,31 @@\n+\n+const double dnan = 1.0/0.0 - 1.0/0.0;\n+double x = 1.0;\n+\n+extern void link_error ();\n+\n+main ()\n+{\n+#if ! defined (__vax__) && ! defined (_CRAY)\n+  /* NaN is an IEEE unordered operand.  All these test should be false.  */\n+  if (dnan == dnan)\n+    link_error ();\n+  if (dnan != x)\n+    x = 1.0;\n+  else\n+    link_error ();\n+\n+  if (dnan < x)\n+    link_error ();\n+  if (dnan > x)\n+    link_error ();\n+  if (dnan <= x)\n+    link_error ();\n+  if (dnan >= x)\n+    link_error ();\n+  if (dnan == x)\n+    link_error ();\n+#endif\n+  exit (0);\n+}\n+"}, {"sha": "385acafc204cb049a097a92b3efa51d1e65f16d6", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/fp-cmp-7.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ddae796cd67ef5c256206a83fa47cb37ac953c2/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Ffp-cmp-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ddae796cd67ef5c256206a83fa47cb37ac953c2/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Ffp-cmp-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Ffp-cmp-7.c?ref=9ddae796cd67ef5c256206a83fa47cb37ac953c2", "patch": "@@ -0,0 +1,14 @@\n+extern void link_error ();\n+\n+void foo(double x)\n+{\n+  if (x > __builtin_inf())\n+    link_error ();\n+}\n+\n+int main ()\n+{\n+  foo (1.0);\n+  return 0;\n+}\n+"}]}