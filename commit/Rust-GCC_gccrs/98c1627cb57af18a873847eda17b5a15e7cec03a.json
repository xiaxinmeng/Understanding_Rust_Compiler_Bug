{"sha": "98c1627cb57af18a873847eda17b5a15e7cec03a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThjMTYyN2NiNTdhZjE4YTg3Mzg0N2VkYTE3YjVhMTVlN2NlYzAzYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2015-04-17T16:43:28Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-04-17T16:43:28Z"}, "message": "re PR target/65689 ([AArch64] S constraint fails for inline asm at -O0)\n\n\tPR target/65689\n\t* genpreds.c (struct constraint_data): Add maybe_allows_reg and\n\tmaybe_allows_mem bitfields.\n\t(maybe_allows_none_start, maybe_allows_none_end,\n\tmaybe_allows_reg_start, maybe_allows_reg_end, maybe_allows_mem_start,\n\tmaybe_allows_mem_end): New variables.\n\t(compute_maybe_allows): New function.\n\t(add_constraint): Use it to initialize maybe_allows_reg and\n\tmaybe_allows_mem fields.\n\t(choose_enum_order): Sort the non-is_register/is_const_int/is_memory/\n\tis_address constraints such that those that allow neither mem nor\n\treg come first, then those that only allow reg but not mem, then\n\tthose that only allow mem but not reg, then the rest.\n\t(write_allows_reg_mem_function): New function.\n\t(write_tm_preds_h): Call it.\n\t* stmt.c (parse_output_constraint, parse_input_constraint): Use\n\tthe generated insn_extra_constraint_allows_reg_mem function\n\tinstead of always setting *allows_reg = true; *allows_mem = true;\n\tfor unknown extra constraints.\n\n\t* gcc.target/aarch64/c-output-template-4.c: New test.\n\nFrom-SVN: r222186", "tree": {"sha": "ea89bc53cc7f08fb1d28f5bca8fb11c0881cf295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea89bc53cc7f08fb1d28f5bca8fb11c0881cf295"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98c1627cb57af18a873847eda17b5a15e7cec03a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98c1627cb57af18a873847eda17b5a15e7cec03a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98c1627cb57af18a873847eda17b5a15e7cec03a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98c1627cb57af18a873847eda17b5a15e7cec03a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "96583f22d708d874ca90a012d8587e7ad484faed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96583f22d708d874ca90a012d8587e7ad484faed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96583f22d708d874ca90a012d8587e7ad484faed"}], "stats": {"total": 163, "additions": 142, "deletions": 21}, "files": [{"sha": "8cbf7c69eafa99c301b8bad38e37b6554a4e235a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c1627cb57af18a873847eda17b5a15e7cec03a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c1627cb57af18a873847eda17b5a15e7cec03a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98c1627cb57af18a873847eda17b5a15e7cec03a", "patch": "@@ -1,3 +1,25 @@\n+2015-04-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/65689\n+\t* genpreds.c (struct constraint_data): Add maybe_allows_reg and\n+\tmaybe_allows_mem bitfields.\n+\t(maybe_allows_none_start, maybe_allows_none_end,\n+\tmaybe_allows_reg_start, maybe_allows_reg_end, maybe_allows_mem_start,\n+\tmaybe_allows_mem_end): New variables.\n+\t(compute_maybe_allows): New function.\n+\t(add_constraint): Use it to initialize maybe_allows_reg and\n+\tmaybe_allows_mem fields.\n+\t(choose_enum_order): Sort the non-is_register/is_const_int/is_memory/\n+\tis_address constraints such that those that allow neither mem nor\n+\treg come first, then those that only allow reg but not mem, then\n+\tthose that only allow mem but not reg, then the rest.\n+\t(write_allows_reg_mem_function): New function.\n+\t(write_tm_preds_h): Call it.\n+\t* stmt.c (parse_output_constraint, parse_input_constraint): Use\n+\tthe generated insn_extra_constraint_allows_reg_mem function\n+\tinstead of always setting *allows_reg = true; *allows_mem = true;\n+\tfor unknown extra constraints.\n+\n 2015-04-17  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/65780"}, {"sha": "1dcb76936eb9f01918ddcd32b15d5f99cdec28ef", "filename": "gcc/genpreds.c", "status": "modified", "additions": 103, "deletions": 7, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c1627cb57af18a873847eda17b5a15e7cec03a/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c1627cb57af18a873847eda17b5a15e7cec03a/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=98c1627cb57af18a873847eda17b5a15e7cec03a", "patch": "@@ -640,12 +640,14 @@ struct constraint_data\n   const char *regclass;  /* for register constraints */\n   rtx exp;               /* for other constraints */\n   unsigned int lineno;   /* line of definition */\n-  unsigned int is_register  : 1;\n-  unsigned int is_const_int : 1;\n-  unsigned int is_const_dbl : 1;\n-  unsigned int is_extra     : 1;\n-  unsigned int is_memory    : 1;\n-  unsigned int is_address   : 1;\n+  unsigned int is_register\t: 1;\n+  unsigned int is_const_int\t: 1;\n+  unsigned int is_const_dbl\t: 1;\n+  unsigned int is_extra\t\t: 1;\n+  unsigned int is_memory\t: 1;\n+  unsigned int is_address\t: 1;\n+  unsigned int maybe_allows_reg : 1;\n+  unsigned int maybe_allows_mem : 1;\n };\n \n /* Overview of all constraints beginning with a given letter.  */\n@@ -691,6 +693,9 @@ static unsigned int satisfied_start;\n static unsigned int const_int_start, const_int_end;\n static unsigned int memory_start, memory_end;\n static unsigned int address_start, address_end;\n+static unsigned int maybe_allows_none_start, maybe_allows_none_end;\n+static unsigned int maybe_allows_reg_start, maybe_allows_reg_end;\n+static unsigned int maybe_allows_mem_start, maybe_allows_mem_end;\n \n /* Convert NAME, which contains angle brackets and/or underscores, to\n    a string that can be used as part of a C identifier.  The string\n@@ -711,6 +716,34 @@ mangle (const char *name)\n   return XOBFINISH (rtl_obstack, const char *);\n }\n \n+/* Return a bitmask, bit 1 if EXP maybe allows a REG/SUBREG, 2 if EXP\n+   maybe allows a MEM.  Bits should be clear only when we are sure it\n+   will not allow a REG/SUBREG or a MEM.  */\n+static int\n+compute_maybe_allows (rtx exp)\n+{\n+  switch (GET_CODE (exp))\n+    {\n+    case IF_THEN_ELSE:\n+      /* Conservative answer is like IOR, of the THEN and ELSE branches.  */\n+      return compute_maybe_allows (XEXP (exp, 1))\n+\t     | compute_maybe_allows (XEXP (exp, 2));\n+    case AND:\n+      return compute_maybe_allows (XEXP (exp, 0))\n+\t     & compute_maybe_allows (XEXP (exp, 1));\n+    case IOR:\n+      return compute_maybe_allows (XEXP (exp, 0))\n+\t     | compute_maybe_allows (XEXP (exp, 1));\n+    case MATCH_CODE:\n+      if (*XSTR (exp, 1) == '\\0')\n+\treturn (strstr (XSTR (exp, 0), \"reg\") != NULL ? 1 : 0)\n+\t       | (strstr (XSTR (exp, 0), \"mem\") != NULL ? 2 : 0);\n+      /* FALLTHRU */\n+    default:\n+      return 3;\n+    }\n+}\n+\n /* Add one constraint, of any sort, to the tables.  NAME is its name;\n    REGCLASS is the register class, if any; EXP is the expression to\n    test, if any;  IS_MEMORY and IS_ADDRESS indicate memory and address\n@@ -866,6 +899,11 @@ add_constraint (const char *name, const char *regclass,\n   c->is_extra = !(regclass || is_const_int || is_const_dbl);\n   c->is_memory = is_memory;\n   c->is_address = is_address;\n+  int maybe_allows = 3;\n+  if (exp)\n+    maybe_allows = compute_maybe_allows (exp);\n+  c->maybe_allows_reg = (maybe_allows & 1) != 0;\n+  c->maybe_allows_mem = (maybe_allows & 2) != 0;\n \n   c->next_this_letter = *slot;\n   *slot = c;\n@@ -940,8 +978,30 @@ choose_enum_order (void)\n       enum_order[next++] = c;\n   address_end = next;\n \n+  maybe_allows_none_start = next;\n+  FOR_ALL_CONSTRAINTS (c)\n+    if (!c->is_register && !c->is_const_int && !c->is_memory && !c->is_address\n+\t&& !c->maybe_allows_reg && !c->maybe_allows_mem)\n+      enum_order[next++] = c;\n+  maybe_allows_none_end = next;\n+\n+  maybe_allows_reg_start = next;\n+  FOR_ALL_CONSTRAINTS (c)\n+    if (!c->is_register && !c->is_const_int && !c->is_memory && !c->is_address\n+\t&& c->maybe_allows_reg && !c->maybe_allows_mem)\n+      enum_order[next++] = c;\n+  maybe_allows_reg_end = next;\n+\n+  maybe_allows_mem_start = next;\n+  FOR_ALL_CONSTRAINTS (c)\n+    if (!c->is_register && !c->is_const_int && !c->is_memory && !c->is_address\n+\t&& !c->maybe_allows_reg && c->maybe_allows_mem)\n+      enum_order[next++] = c;\n+  maybe_allows_mem_end = next;\n+\n   FOR_ALL_CONSTRAINTS (c)\n-    if (!c->is_register && !c->is_const_int && !c->is_memory && !c->is_address)\n+    if (!c->is_register && !c->is_const_int && !c->is_memory && !c->is_address\n+\t&& c->maybe_allows_reg && c->maybe_allows_mem)\n       enum_order[next++] = c;\n   gcc_assert (next == num_constraints);\n }\n@@ -1229,6 +1289,41 @@ write_range_function (const char *name, unsigned int start, unsigned int end)\n \t    \"}\\n\\n\", name);\n }\n \n+/* Write a definition for insn_extra_constraint_allows_reg_mem function.  */\n+static void\n+write_allows_reg_mem_function (void)\n+{\n+  printf (\"static inline void\\n\"\n+\t  \"insn_extra_constraint_allows_reg_mem (enum constraint_num c,\\n\"\n+\t  \"\\t\\t\\t\\t      bool *allows_reg, bool *allows_mem)\\n\"\n+\t  \"{\\n\");\n+  if (maybe_allows_none_start != maybe_allows_none_end)\n+    printf (\"  if (c >= CONSTRAINT_%s && c <= CONSTRAINT_%s)\\n\"\n+\t    \"    return;\\n\",\n+\t    enum_order[maybe_allows_none_start]->c_name,\n+\t    enum_order[maybe_allows_none_end - 1]->c_name);\n+  if (maybe_allows_reg_start != maybe_allows_reg_end)\n+    printf (\"  if (c >= CONSTRAINT_%s && c <= CONSTRAINT_%s)\\n\"\n+\t    \"    {\\n\"\n+\t    \"      *allows_reg = true;\\n\"\n+\t    \"      return;\\n\"\n+\t    \"    }\\n\",\n+\t    enum_order[maybe_allows_reg_start]->c_name,\n+\t    enum_order[maybe_allows_reg_end - 1]->c_name);\n+  if (maybe_allows_mem_start != maybe_allows_mem_end)\n+    printf (\"  if (c >= CONSTRAINT_%s && c <= CONSTRAINT_%s)\\n\"\n+\t    \"    {\\n\"\n+\t    \"      *allows_mem = true;\\n\"\n+\t    \"      return;\\n\"\n+\t    \"    }\\n\",\n+\t    enum_order[maybe_allows_mem_start]->c_name,\n+\t    enum_order[maybe_allows_mem_end - 1]->c_name);\n+  printf (\"  (void) c;\\n\"\n+\t  \"  *allows_reg = true;\\n\"\n+\t  \"  *allows_mem = true;\\n\"\n+\t  \"}\\n\\n\");\n+}\n+\n /* VEC is a list of key/value pairs, with the keys being lower bounds\n    of a range.  Output a decision tree that handles the keys covered by\n    [VEC[START], VEC[END]), returning FALLBACK for keys lower then VEC[START]'s.\n@@ -1326,6 +1421,7 @@ write_tm_preds_h (void)\n \t\t\t    memory_start, memory_end);\n       write_range_function (\"insn_extra_address_constraint\",\n \t\t\t    address_start, address_end);\n+      write_allows_reg_mem_function ();\n \n       if (constraint_max_namelen > 1)\n         {"}, {"sha": "6c62a129601ccb65d5f7cb289c197d5e653003d8", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c1627cb57af18a873847eda17b5a15e7cec03a/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c1627cb57af18a873847eda17b5a15e7cec03a/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=98c1627cb57af18a873847eda17b5a15e7cec03a", "patch": "@@ -342,13 +342,7 @@ parse_output_constraint (const char **constraint_p, int operand_num,\n \telse if (insn_extra_memory_constraint (cn))\n \t  *allows_mem = true;\n \telse\n-\t  {\n-\t    /* Otherwise we can't assume anything about the nature of\n-\t       the constraint except that it isn't purely registers.\n-\t       Treat it like \"g\" and hope for the best.  */\n-\t    *allows_reg = true;\n-\t    *allows_mem = true;\n-\t  }\n+\t  insn_extra_constraint_allows_reg_mem (cn, allows_reg, allows_mem);\n \tbreak;\n       }\n \n@@ -465,13 +459,7 @@ parse_input_constraint (const char **constraint_p, int input_num,\n \telse if (insn_extra_memory_constraint (cn))\n \t  *allows_mem = true;\n \telse\n-\t  {\n-\t    /* Otherwise we can't assume anything about the nature of\n-\t       the constraint except that it isn't purely registers.\n-\t       Treat it like \"g\" and hope for the best.  */\n-\t    *allows_reg = true;\n-\t    *allows_mem = true;\n-\t  }\n+\t  insn_extra_constraint_allows_reg_mem (cn, allows_reg, allows_mem);\n \tbreak;\n       }\n "}, {"sha": "cec5fa10bfee43c015b39660ac10ffe5c812391d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c1627cb57af18a873847eda17b5a15e7cec03a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c1627cb57af18a873847eda17b5a15e7cec03a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=98c1627cb57af18a873847eda17b5a15e7cec03a", "patch": "@@ -1,3 +1,8 @@\n+2015-04-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/65689\n+\t* gcc.target/aarch64/c-output-template-4.c: New test.\n+\n 2015-04-17  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/65780"}, {"sha": "c5a93915af1c7f252414d4540f267d69641914f6", "filename": "gcc/testsuite/gcc.target/aarch64/c-output-template-4.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c1627cb57af18a873847eda17b5a15e7cec03a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fc-output-template-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c1627cb57af18a873847eda17b5a15e7cec03a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fc-output-template-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fc-output-template-4.c?ref=98c1627cb57af18a873847eda17b5a15e7cec03a", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0\" } */\n+\n+void\n+test (void)\n+{\n+    __asm__ (\"@ %c0\" : : \"S\" (&test + 4));\n+}\n+\n+/* { dg-final { scan-assembler \"@ test\\\\+4\" } } */"}]}