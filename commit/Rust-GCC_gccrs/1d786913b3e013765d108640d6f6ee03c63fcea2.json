{"sha": "1d786913b3e013765d108640d6f6ee03c63fcea2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ3ODY5MTNiM2UwMTM3NjVkMTA4NjQwZDZmNmVlMDNjNjNmY2VhMg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-12-30T23:29:33Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-12-30T23:29:33Z"}, "message": "cp-tree.h (cp_declarator): Split \"name\" field into qualifying_scope and unqualified_name.\n\n\t* cp-tree.h (cp_declarator): Split \"name\" field into\n\tqualifying_scope and unqualified_name.\n\t* decl.c (get_scope_of_declarator): Adjust accordingly.\n\t(grokdeclarator): Likewise.\n\t* decl2.c (grokfield): Likewise, and adjust call to\n\tdo_class_using_decl.\n\t* name-lookup.c (do_class_using_decl): Split \"decl\" into\n\t\"scope\" and \"name\".  Remove unnecessary code.\n\t* name-lookup.h (do_class_using_decl): Adjust declaration.\n\t* parser.c (make_id_declarator): Split \"id\" into qualifying_scope\n\tand unqualified_name.\n\t(cp_parser_using_declaration): Adjust call to do_class_using_decl.\n\t(cp_parser_direct_declarator): Adjust to handle the fact that\n\tcp_parser_declarator_id no longer returns a SCOPE_REF.\n\t(cp_parser_direct_declarator): Likewise.\n\t(cp_parser_declarator_id): Do not create a SCOPE_REF for qualified\n\tnames.\n\t(cp_parser_member_declaration): Adjust call to make_id_declarator.\n\t(cp_parser_check_declarator_template_parameters): Do not expect a\n\tSCOPE_REF.\n\n\t* decl.c (duplicate_decls): Call ggc_free on declarations we will\n\tnot be needing any longer.\n\nFrom-SVN: r92746", "tree": {"sha": "80c424b73600d77daa433461d979103437d7196b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80c424b73600d77daa433461d979103437d7196b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d786913b3e013765d108640d6f6ee03c63fcea2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d786913b3e013765d108640d6f6ee03c63fcea2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d786913b3e013765d108640d6f6ee03c63fcea2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d786913b3e013765d108640d6f6ee03c63fcea2/comments", "author": null, "committer": null, "parents": [{"sha": "36651afeec5fca8d1a0f00775b1586b1669f211f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36651afeec5fca8d1a0f00775b1586b1669f211f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36651afeec5fca8d1a0f00775b1586b1669f211f"}], "stats": {"total": 270, "additions": 138, "deletions": 132}, "files": [{"sha": "cad590d6afde630076d1fc8604d4810fd50ef75e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d786913b3e013765d108640d6f6ee03c63fcea2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d786913b3e013765d108640d6f6ee03c63fcea2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1d786913b3e013765d108640d6f6ee03c63fcea2", "patch": "@@ -1,4 +1,28 @@\n-2004-12-29  Mark Mitchell  <mark@codesourcery.com>\n+2004-12-30  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (cp_declarator): Split \"name\" field into\n+\tqualifying_scope and unqualified_name.\n+\t* decl.c (get_scope_of_declarator): Adjust accordingly.\n+\t(grokdeclarator): Likewise.\n+\t* decl2.c (grokfield): Likewise, and adjust call to\n+\tdo_class_using_decl.\n+\t* name-lookup.c (do_class_using_decl): Split \"decl\" into\n+\t\"scope\" and \"name\".  Remove unnecessary code.\n+\t* name-lookup.h (do_class_using_decl): Adjust declaration.\n+\t* parser.c (make_id_declarator): Split \"id\" into qualifying_scope\n+\tand unqualified_name.\n+\t(cp_parser_using_declaration): Adjust call to do_class_using_decl.\n+\t(cp_parser_direct_declarator): Adjust to handle the fact that\n+\tcp_parser_declarator_id no longer returns a SCOPE_REF.\n+\t(cp_parser_direct_declarator): Likewise.\n+\t(cp_parser_declarator_id): Do not create a SCOPE_REF for qualified\n+\tnames.\n+\t(cp_parser_member_declaration): Adjust call to make_id_declarator.\n+\t(cp_parser_check_declarator_template_parameters): Do not expect a\n+\tSCOPE_REF. \n+\t\n+\t* decl.c (duplicate_decls): Call ggc_free on declarations we will\n+\tnot be needing any longer.\n \n \tPR c++/19190\n \t* cvt.c (convert_to_void): Do not use STRIP_NOPs."}, {"sha": "1309db3952257d939af1086cc2956e87e5963301", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d786913b3e013765d108640d6f6ee03c63fcea2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d786913b3e013765d108640d6f6ee03c63fcea2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1d786913b3e013765d108640d6f6ee03c63fcea2", "patch": "@@ -3591,9 +3591,12 @@ struct cp_declarator {\n   union {\n     /* For identifiers.  */\n     struct {\n-      /* The name of the function -- an IDENTIFIER_NODE, BIT_NOT_EXPR,\n-\t TEMPLATE_ID_EXPR, or SCOPE_REF.  */\n-      tree name;\n+      /* If non-NULL, the qualifiying scope (a NAMESPACE_DECL or\n+         *_TYPE) for this identifier.  */\n+      tree qualifying_scope;\n+      /* The unqualified name of the entity -- an IDENTIFIER_NODE,\n+\t BIT_NOT_EXPR, or TEMPLATE_ID_EXPR.  */\n+      tree unqualified_name;\n       /* If this is the name of a function, what kind of special\n \t function (if any).  */\n       special_function_kind sfk;"}, {"sha": "61f2d648679ea853d9bf8287d3307d01bb9eaeab", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 30, "deletions": 36, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d786913b3e013765d108640d6f6ee03c63fcea2/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d786913b3e013765d108640d6f6ee03c63fcea2/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=1d786913b3e013765d108640d6f6ee03c63fcea2", "patch": "@@ -1938,6 +1938,15 @@ duplicate_decls (tree newdecl, tree olddecl)\n       DECL_VISIBILITY_SPECIFIED (newdecl) = 1;\n     }\n \n+  /* The DECL_LANG_SPECIFIC information in OLDDECL will be replaced\n+     with that from NEWDECL below.  */\n+  if (DECL_LANG_SPECIFIC (olddecl))\n+    {\n+      gcc_assert (DECL_LANG_SPECIFIC (olddecl) \n+\t\t  != DECL_LANG_SPECIFIC (newdecl));\n+      ggc_free (DECL_LANG_SPECIFIC (olddecl));\n+    }\n+\n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n       int function_size;\n@@ -1999,6 +2008,11 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t      && TREE_STATIC (olddecl))))\n     make_decl_rtl (olddecl);\n \n+  /* The NEWDECL will no longer be needed.  Because every out-of-class\n+     declaration of a member results in a call to duplicate_decls,\n+     freeing these nodes represents in a significant savings.  */\n+  ggc_free (newdecl);\n+\n   return olddecl;\n }\n \f\n@@ -6327,9 +6341,8 @@ get_scope_of_declarator (const cp_declarator *declarator)\n   /* If the declarator-id is a SCOPE_REF, the scope in which the\n      declaration occurs is the first operand.  */\n   if (declarator\n-      && declarator->u.id.name\n-      && TREE_CODE (declarator->u.id.name) == SCOPE_REF)\n-    return TREE_OPERAND (declarator->u.id.name, 0);\n+      && declarator->u.id.qualifying_scope)\n+    return declarator->u.id.qualifying_scope;\n \n   /* Otherwise, the declarator is not a qualified name; the entity will\n      be declared in the current scope.  */\n@@ -6628,40 +6641,27 @@ grokdeclarator (const cp_declarator *declarator,\n \n \tcase cdk_id:\n \t  {\n-\t    tree decl = id_declarator->u.id.name;\n+\t    tree qualifying_scope = id_declarator->u.id.qualifying_scope;\n+\t    tree decl = id_declarator->u.id.unqualified_name;\n \t    if (!decl)\n \t      break;\n-\t    if (TREE_CODE (decl) == SCOPE_REF)\n+\t    if (qualifying_scope)\n \t      {\n-\t\ttree qualifying_scope = TREE_OPERAND (decl, 0);\n-\n-\t\t/* It is valid to write:\n-\n-\t\t   class C { void f(); };\n-\t\t   typedef C D;\n-\t\t   void D::f();\n-\n-\t\t The standard is not clear about whether `typedef const C D' is\n-\t\t legal; as of 2002-09-15 the committee is considering\n-\t\t that question.  EDG 3.0 allows that syntax.\n-\t\t Therefore, we do as well.  */\n-\t\tif (qualifying_scope && TYPE_P (qualifying_scope))\n+\t\tif (TYPE_P (qualifying_scope))\n \t\t  {\n-\t\t    ctype = TYPE_MAIN_VARIANT (qualifying_scope);\n+\t\t    ctype = qualifying_scope;\n \t\t    if (innermost_code != cdk_function\n \t\t\t&& current_class_type\n \t\t\t&& !UNIQUELY_DERIVED_FROM_P (ctype,\n \t\t\t\t\t\t     current_class_type))\n \t\t      {\n \t\t\terror (\"type %qT is not derived from type %qT\",\n \t\t\t       ctype, current_class_type);\n-\t\t\tctype = NULL_TREE;\n+\t\t\treturn error_mark_node;\n \t\t      }\n-\t\t    TREE_OPERAND (decl, 0) = ctype;\n \t\t  }\n \t\telse if (TREE_CODE (qualifying_scope) == NAMESPACE_DECL)\n \t\t  in_namespace = qualifying_scope;\n-\t\tdecl = TREE_OPERAND (decl, 1);\n \t      }\n \t    if (TREE_CODE (decl) == BASELINK)\n \t      decl = BASELINK_FUNCTIONS (decl);\n@@ -7125,9 +7125,9 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t{\n \t\t  /* Avoid trying to get an operand off an identifier node.  */\n \t\t  if (declarator->kind != cdk_id)\n-\t\t    tmp = declarator->declarator->u.id.name;\n+\t\t    tmp = declarator->declarator->u.id.unqualified_name;\n \t\t  else\n-\t\t    tmp = declarator->u.id.name;\n+\t\t    tmp = declarator->u.id.unqualified_name;\n \t\t  op = IDENTIFIER_OPNAME_P (tmp);\n \t\t  if (IDENTIFIER_TYPENAME_P (tmp))\n \t\t    {\n@@ -7192,9 +7192,7 @@ grokdeclarator (const cp_declarator *declarator,\n     unqualified_id = NULL_TREE;\n   else\n     {\n-      unqualified_id = id_declarator->u.id.name;\n-      if (TREE_CODE (unqualified_id) == SCOPE_REF)\n-\tunqualified_id = TREE_OPERAND (unqualified_id, 1);\n+      unqualified_id = id_declarator->u.id.unqualified_name;\n       if (TREE_CODE (unqualified_id) == BASELINK)\n \tunqualified_id = BASELINK_FUNCTIONS (unqualified_id);\n       switch (TREE_CODE (unqualified_id))\n@@ -7489,17 +7487,13 @@ grokdeclarator (const cp_declarator *declarator,\n   /* If DECLARATOR is non-NULL, we know it is a cdk_id declarator;\n      otherwise, we would not have exited the loop above.  */\n   if (declarator\n-      && TREE_CODE (declarator->u.id.name) == SCOPE_REF\n-      /* If the qualifying scope was invalid, it will have been set to\n-\t NULL_TREE above.  */\n-      && TREE_OPERAND (declarator->u.id.name, 0)\n-      && TYPE_P (TREE_OPERAND (declarator->u.id.name, 0)))\n+      && declarator->u.id.qualifying_scope\n+      && TYPE_P (declarator->u.id.qualifying_scope))\n     {\n       tree t;\n \n-      ctype = TREE_OPERAND (declarator->u.id.name, 0);\n-      if (TYPE_P (ctype))\n-\tctype = TYPE_MAIN_VARIANT (ctype);\n+      ctype = declarator->u.id.qualifying_scope;\n+      ctype = TYPE_MAIN_VARIANT (ctype);\n       t = ctype;\n       while (t != NULL_TREE && CLASS_TYPE_P (t))\n \t{\n@@ -7537,7 +7531,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t}\n       else if (TREE_CODE (type) == FUNCTION_TYPE)\n \t{\n-\t  tree sname = TREE_OPERAND (declarator->u.id.name, 1);\n+\t  tree sname = declarator->u.id.unqualified_name;\n \n \t  if (TREE_CODE (sname) == IDENTIFIER_NODE\n \t      && NEW_DELETE_OPNAME_P (sname))"}, {"sha": "0df5b25e1170bad916572f1da997c45ddb925333", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d786913b3e013765d108640d6f6ee03c63fcea2/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d786913b3e013765d108640d6f6ee03c63fcea2/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=1d786913b3e013765d108640d6f6ee03c63fcea2", "patch": "@@ -830,11 +830,11 @@ grokfield (const cp_declarator *declarator,\n \n   if (!declspecs->any_specifiers_p\n       && declarator->kind == cdk_id\n-      && TREE_CODE (declarator->u.id.name) == SCOPE_REF\n-      && (TREE_CODE (TREE_OPERAND (declarator->u.id.name, 1)) \n-\t  == IDENTIFIER_NODE))\n+      && declarator->u.id.qualifying_scope \n+      && TREE_CODE (declarator->u.id.unqualified_name) == IDENTIFIER_NODE)\n     /* Access declaration */\n-    return do_class_using_decl (declarator->u.id.name);\n+    return do_class_using_decl (declarator->u.id.qualifying_scope,\n+\t\t\t\tdeclarator->u.id.unqualified_name);\n \n   if (init\n       && TREE_CODE (init) == TREE_LIST"}, {"sha": "7f1ba919c07e63e991d840db0c566806a207da3f", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d786913b3e013765d108640d6f6ee03c63fcea2/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d786913b3e013765d108640d6f6ee03c63fcea2/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=1d786913b3e013765d108640d6f6ee03c63fcea2", "patch": "@@ -2686,34 +2686,24 @@ push_class_level_binding (tree name, tree x)\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, ok);\n }\n \n+/* Process \"using SCOPE::NAME\" in a class scope.  Return the\n+   USING_DECL created.  */\n+\n tree\n-do_class_using_decl (tree decl)\n+do_class_using_decl (tree scope, tree name)\n {\n-  tree name, value, scope, type;\n+  tree value, type;\n   \n-  if (TREE_CODE (decl) != SCOPE_REF\n-      || !TREE_OPERAND (decl, 0)\n-      || !TYPE_P (TREE_OPERAND (decl, 0)))\n+  if (!scope || !TYPE_P (scope))\n     {\n       error (\"using-declaration for non-member at class scope\");\n       return NULL_TREE;\n     }\n-  scope = TREE_OPERAND (decl, 0);\n-  name = TREE_OPERAND (decl, 1);\n   if (TREE_CODE (name) == BIT_NOT_EXPR)\n     {\n       error (\"using-declaration cannot name destructor\");\n       return NULL_TREE;\n     }\n-  if (TREE_CODE (name) == TYPE_DECL)\n-    name = DECL_NAME (name);\n-  else if (TREE_CODE (name) == TEMPLATE_DECL)\n-     name = DECL_NAME (name);\n-  else if (BASELINK_P (name))\n-    {\n-      tree fns = BASELINK_FUNCTIONS (name);\n-      name = DECL_NAME (get_first_fn (fns));\n-    }\n \n   gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n "}, {"sha": "13ac45964a6d4ef8b71c915a61720216b887ff60", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d786913b3e013765d108640d6f6ee03c63fcea2/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d786913b3e013765d108640d6f6ee03c63fcea2/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=1d786913b3e013765d108640d6f6ee03c63fcea2", "patch": "@@ -335,7 +335,7 @@ extern void pop_decl_namespace (void);\n extern void do_namespace_alias (tree, tree);\n extern void do_toplevel_using_decl (tree, tree, tree);\n extern void do_local_using_decl (tree, tree, tree);\n-extern tree do_class_using_decl (tree);\n+extern tree do_class_using_decl (tree, tree);\n extern void do_using_directive (tree);\n extern tree lookup_arg_dependent (tree, tree, tree);\n extern bool is_associated_namespace (tree, tree);"}, {"sha": "ccc64732afe9547ada0f5b36401f29c8d31b3d72", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 66, "deletions": 71, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d786913b3e013765d108640d6f6ee03c63fcea2/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d786913b3e013765d108640d6f6ee03c63fcea2/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=1d786913b3e013765d108640d6f6ee03c63fcea2", "patch": "@@ -747,8 +747,6 @@ clear_decl_specs (cp_decl_specifier_seq *decl_specs)\n    Other parts of the front end that need to create entities (like\n    VAR_DECLs or FUNCTION_DECLs) should do that directly.  */\n \n-static cp_declarator *make_id_declarator\n-  (tree);\n static cp_declarator *make_call_declarator\n   (cp_declarator *, cp_parameter_declarator *, cp_cv_quals, tree);\n static cp_declarator *make_array_declarator\n@@ -792,15 +790,31 @@ make_declarator (cp_declarator_kind kind)\n   return declarator;\n }\n \n-/* Make a declarator for a generalized identifier.  */\n+/* Make a declarator for a generalized identifier.  If non-NULL, the\n+   identifier is QUALIFYING_SCOPE::UNQUALIFIED_NAME; otherwise, it is\n+   just UNQUALIFIED_NAME.  */\n \n-cp_declarator *\n-make_id_declarator (tree id)\n+static cp_declarator *\n+make_id_declarator (tree qualifying_scope, tree unqualified_name)\n {\n   cp_declarator *declarator;\n \n+  /* It is valid to write:\n+\n+       class C { void f(); };\n+       typedef C D;\n+       void D::f();\n+\n+     The standard is not clear about whether `typedef const C D' is\n+     legal; as of 2002-09-15 the committee is considering that\n+     question.  EDG 3.0 allows that syntax.  Therefore, we do as\n+     well.  */\n+  if (qualifying_scope && TYPE_P (qualifying_scope))\n+    qualifying_scope = TYPE_MAIN_VARIANT (qualifying_scope);\n+\n   declarator = make_declarator (cdk_id);\n-  declarator->u.id.name = id;\n+  declarator->u.id.qualifying_scope = qualifying_scope;\n+  declarator->u.id.unqualified_name = unqualified_name;\n   declarator->u.id.sfk = sfk_none;\n \n   return declarator;\n@@ -10160,9 +10174,7 @@ cp_parser_using_declaration (cp_parser* parser)\n       if (at_class_scope_p ())\n \t{\n \t  /* Create the USING_DECL.  */\n-\t  decl = do_class_using_decl (build_nt (SCOPE_REF,\n-\t\t\t\t\t\tparser->scope,\n-\t\t\t\t\t\tidentifier));\n+\t  decl = do_class_using_decl (parser->scope, identifier);\n \t  /* Add it to the list of members in this class.  */\n \t  finish_member_declaration (decl);\n \t}\n@@ -11018,33 +11030,36 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t}\n       else if (first && dcl_kind != CP_PARSER_DECLARATOR_ABSTRACT)\n \t{\n-\t  tree id;\n+\t  tree qualifying_scope;\n+\t  tree unqualified_name;\n \n \t  /* Parse a declarator-id */\n \t  if (dcl_kind == CP_PARSER_DECLARATOR_EITHER)\n \t    cp_parser_parse_tentatively (parser);\n-\t  id = cp_parser_declarator_id (parser);\n+\t  unqualified_name = cp_parser_declarator_id (parser);\n+\t  qualifying_scope = parser->scope;\n \t  if (dcl_kind == CP_PARSER_DECLARATOR_EITHER)\n \t    {\n \t      if (!cp_parser_parse_definitely (parser))\n-\t\tid = error_mark_node;\n-\t      else if (TREE_CODE (id) != IDENTIFIER_NODE)\n+\t\tunqualified_name = error_mark_node;\n+\t      else if (qualifying_scope\n+\t\t       || (TREE_CODE (unqualified_name) \n+\t\t\t   != IDENTIFIER_NODE))\n \t\t{\n \t\t  cp_parser_error (parser, \"expected unqualified-id\");\n-\t\t  id = error_mark_node;\n+\t\t  unqualified_name = error_mark_node;\n \t\t}\n \t    }\n \n-\t  if (id == error_mark_node)\n+\t  if (unqualified_name == error_mark_node)\n \t    {\n \t      declarator = cp_error_declarator;\n \t      break;\n \t    }\n \n-\t  if (TREE_CODE (id) == SCOPE_REF && at_namespace_scope_p ())\n+\t  if (qualifying_scope && at_namespace_scope_p ()\n+\t      && TREE_CODE (qualifying_scope) == TYPENAME_TYPE)\n \t    {\n-\t      tree scope = TREE_OPERAND (id, 0);\n-\n \t      /* In the declaration of a member of a template class\n \t     \t outside of the class itself, the SCOPE will sometimes\n \t     \t be a TYPENAME_TYPE.  For example, given:\n@@ -11061,40 +11076,30 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t     \t `S<T>::R' not a type.  However, if `S' is\n \t     \t specialized, then this `i' will not be used, so there\n \t     \t is no harm in resolving the types here.  */\n-\t      if (TREE_CODE (scope) == TYPENAME_TYPE)\n-\t\t{\n-\t\t  tree type;\n-\n-\t\t  /* Resolve the TYPENAME_TYPE.  */\n-\t\t  type = resolve_typename_type (scope,\n-\t\t\t\t\t\t /*only_current_p=*/false);\n-\t\t  /* If that failed, the declarator is invalid.  */\n-\t\t  if (type == error_mark_node)\n-\t\t    error (\"%<%T::%D%> is not a type\",\n-\t\t\t   TYPE_CONTEXT (scope),\n-\t\t\t   TYPE_IDENTIFIER (scope));\n-\t\t  /* Build a new DECLARATOR.  */\n-\t\t  id = build_nt (SCOPE_REF, type, TREE_OPERAND (id, 1));\n-\t\t}\n+\t      tree type;\n+\t      \n+\t      /* Resolve the TYPENAME_TYPE.  */\n+\t      type = resolve_typename_type (qualifying_scope,\n+\t\t\t\t\t    /*only_current_p=*/false);\n+\t      /* If that failed, the declarator is invalid.  */\n+\t      if (type == error_mark_node)\n+\t\terror (\"%<%T::%D%> is not a type\",\n+\t\t       TYPE_CONTEXT (qualifying_scope),\n+\t\t       TYPE_IDENTIFIER (qualifying_scope));\n+\t      qualifying_scope = type;\n \t    }\n \n-\t  declarator = make_id_declarator (id);\n-\t  if (id)\n+\t  declarator = make_id_declarator (qualifying_scope, \n+\t\t\t\t\t   unqualified_name);\n+\t  if (unqualified_name)\n \t    {\n \t      tree class_type;\n-\t      tree unqualified_name;\n \n-\t      if (TREE_CODE (id) == SCOPE_REF\n-\t\t  && CLASS_TYPE_P (TREE_OPERAND (id, 0)))\n-\t\t{\n-\t\t  class_type = TREE_OPERAND (id, 0);\n-\t\t  unqualified_name = TREE_OPERAND (id, 1);\n-\t\t}\n+\t      if (qualifying_scope\n+\t\t  && CLASS_TYPE_P (qualifying_scope))\n+\t\tclass_type = qualifying_scope;\n \t      else\n-\t\t{\n-\t\t  class_type = current_class_type;\n-\t\t  unqualified_name = id;\n-\t\t}\n+\t\tclass_type = current_class_type;\n \n \t      if (class_type)\n \t\t{\n@@ -11111,7 +11116,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \n \t\t  if (ctor_dtor_or_conv_p && declarator->u.id.sfk != sfk_none)\n \t\t    *ctor_dtor_or_conv_p = -1;\n-\t\t  if (TREE_CODE (id) == SCOPE_REF\n+\t\t  if (qualifying_scope\n \t\t      && TREE_CODE (unqualified_name) == TYPE_DECL\n \t\t      && CLASSTYPE_USE_TEMPLATE (TREE_TYPE (unqualified_name)))\n \t\t    {\n@@ -11333,8 +11338,6 @@ cp_parser_cv_qualifier_seq_opt (cp_parser* parser)\n static tree\n cp_parser_declarator_id (cp_parser* parser)\n {\n-  tree id_expression;\n-\n   /* The expression must be an id-expression.  Assume that qualified\n      names are the names of types so that:\n \n@@ -11349,20 +11352,11 @@ cp_parser_declarator_id (cp_parser* parser)\n        int S<T>::R<T>::i = 3;\n \n      will work, too.  */\n-  id_expression = cp_parser_id_expression (parser,\n-\t\t\t\t\t   /*template_keyword_p=*/false,\n-\t\t\t\t\t   /*check_dependency_p=*/false,\n-\t\t\t\t\t   /*template_p=*/NULL,\n-\t\t\t\t\t   /*declarator_p=*/true);\n-  /* If the name was qualified, create a SCOPE_REF to represent\n-     that.  */\n-  if (parser->scope)\n-    {\n-      id_expression = build_nt (SCOPE_REF, parser->scope, id_expression);\n-      parser->scope = NULL_TREE;\n-    }\n-\n-  return id_expression;\n+  return cp_parser_id_expression (parser,\n+\t\t\t\t  /*template_keyword_p=*/false,\n+\t\t\t\t  /*check_dependency_p=*/false,\n+\t\t\t\t  /*template_p=*/NULL,\n+\t\t\t\t  /*declarator_p=*/true);\n }\n \n /* Parse a type-id.\n@@ -13064,7 +13058,8 @@ cp_parser_member_declaration (cp_parser* parser)\n \n \t      /* Create the bitfield declaration.  */\n \t      decl = grokbitfield (identifier\n-\t\t\t\t   ? make_id_declarator (identifier)\n+\t\t\t\t   ? make_id_declarator (NULL_TREE,\n+\t\t\t\t\t\t\t identifier)\n \t\t\t\t   : NULL,\n \t\t\t\t   &decl_specifiers,\n \t\t\t\t   width);\n@@ -14383,13 +14378,13 @@ cp_parser_check_declarator_template_parameters (cp_parser* parser,\n   switch (declarator->kind)\n     {\n     case cdk_id:\n-      if (TREE_CODE (declarator->u.id.name) == SCOPE_REF)\n+      if (declarator->u.id.qualifying_scope)\n \t{\n \t  tree scope;\n \t  tree member;\n \n-\t  scope = TREE_OPERAND (declarator->u.id.name, 0);\n-\t  member = TREE_OPERAND (declarator->u.id.name, 1);\n+\t  scope = declarator->u.id.qualifying_scope;\n+\t  member = declarator->u.id.unqualified_name;\n \n \t  while (scope && CLASS_TYPE_P (scope))\n \t    {\n@@ -14412,10 +14407,10 @@ cp_parser_check_declarator_template_parameters (cp_parser* parser,\n \t      scope = TYPE_CONTEXT (scope);\n \t    }\n \t}\n-\n-      /* If the DECLARATOR has the form `X<y>' then it uses one\n-\t additional level of template parameters.  */\n-      if (TREE_CODE (declarator->u.id.name) == TEMPLATE_ID_EXPR)\n+      else if (TREE_CODE (declarator->u.id.unqualified_name) \n+\t       == TEMPLATE_ID_EXPR)\n+\t/* If the DECLARATOR has the form `X<y>' then it uses one\n+\t   additional level of template parameters.  */\n \t++num_templates;\n \n       return cp_parser_check_template_parameters (parser,"}]}