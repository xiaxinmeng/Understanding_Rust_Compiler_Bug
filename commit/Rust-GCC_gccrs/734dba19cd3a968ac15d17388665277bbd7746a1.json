{"sha": "734dba19cd3a968ac15d17388665277bbd7746a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM0ZGJhMTljZDNhOTY4YWMxNWQxNzM4ODY2NTI3N2JiZDc3NDZhMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-01-08T12:47:15Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-01-08T12:47:15Z"}, "message": "i386.c (ix86_expand_int_movcc): Take care to reverse fp conditions properly.\n\n\n\t* i386.c (ix86_expand_int_movcc): Take care to reverse fp conditions\n\tproperly.\n\nFrom-SVN: r38799", "tree": {"sha": "f71a6cb10e508a17faf565cb1876f5247ef6cbb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f71a6cb10e508a17faf565cb1876f5247ef6cbb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/734dba19cd3a968ac15d17388665277bbd7746a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/734dba19cd3a968ac15d17388665277bbd7746a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/734dba19cd3a968ac15d17388665277bbd7746a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/734dba19cd3a968ac15d17388665277bbd7746a1/comments", "author": null, "committer": null, "parents": [{"sha": "1f0d71c5bb8b6db96c0b99ccfad95d157f4f2064", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f0d71c5bb8b6db96c0b99ccfad95d157f4f2064", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f0d71c5bb8b6db96c0b99ccfad95d157f4f2064"}], "stats": {"total": 37, "additions": 33, "deletions": 4}, "files": [{"sha": "52bb93d1bfad8d67d2f55107f1e69c0233f02a2e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/734dba19cd3a968ac15d17388665277bbd7746a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/734dba19cd3a968ac15d17388665277bbd7746a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=734dba19cd3a968ac15d17388665277bbd7746a1", "patch": "@@ -1,3 +1,8 @@\n+Mon Jan  8 13:46:02 MET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (ix86_expand_int_movcc): Take care to reverse fp conditions\n+\tproperly.\n+\n Sun Jan  7 18:37:43 2001  Mark P Mitchell  <mark@codesourcery.com>\n \n \t* ggc-page.c (max_alignment): New structure."}, {"sha": "53e33d4cbd634b1726afe32281c55d69cfb6c54c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/734dba19cd3a968ac15d17388665277bbd7746a1/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/734dba19cd3a968ac15d17388665277bbd7746a1/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=734dba19cd3a968ac15d17388665277bbd7746a1", "patch": "@@ -5399,8 +5399,20 @@ ix86_expand_int_movcc (operands)\n \t  HOST_WIDE_INT tmp;\n \t  tmp = ct, ct = cf, cf = tmp;\n \t  diff = -diff;\n-\t  compare_code = reverse_condition (compare_code);\n-\t  code = reverse_condition (code);\n+\t  if (FLOAT_MODE_P (GET_MODE (ix86_compare_op0)))\n+\t    {\n+\t      /* We may be reversing unordered compare to normal compare, that\n+\t\t is not valid in general (we may convert non-trapping condition\n+\t\t to trapping one), however on i386 we currently emit all\n+\t\t comparisons unordered.  */\n+\t      compare_code = reverse_condition_maybe_unordered (compare_code);\n+\t      code = reverse_condition_maybe_unordered (code);\n+\t    }\n+\t  else\n+\t    {\n+\t      compare_code = reverse_condition (compare_code);\n+\t      code = reverse_condition (code);\n+\t    }\n \t}\n       if (diff == 1 || diff == 2 || diff == 4 || diff == 8\n \t  || diff == 3 || diff == 5 || diff == 9)\n@@ -5489,8 +5501,20 @@ ix86_expand_int_movcc (operands)\n \t    {\n \t      ct = cf;\n \t      cf = 0;\n-\t      compare_code = reverse_condition (compare_code);\n-\t      code = reverse_condition (code);\n+\t      if (FLOAT_MODE_P (GET_MODE (ix86_compare_op0)))\n+\t\t{\n+\t\t  /* We may be reversing unordered compare to normal compare,\n+\t\t     that is not valid in general (we may convert non-trapping\n+\t\t     condition to trapping one), however on i386 we currently\n+\t\t     emit all comparisons unordered.  */\n+\t\t  compare_code = reverse_condition_maybe_unordered (compare_code);\n+\t\t  code = reverse_condition_maybe_unordered (code);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  compare_code = reverse_condition (compare_code);\n+\t\t  code = reverse_condition (code);\n+\t\t}\n \t    }\n \n \t  out = emit_store_flag (out, code, ix86_compare_op0,"}]}