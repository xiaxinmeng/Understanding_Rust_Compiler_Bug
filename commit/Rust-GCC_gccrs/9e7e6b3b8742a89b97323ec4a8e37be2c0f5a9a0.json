{"sha": "9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU3ZTZiM2I4NzQyYTg5Yjk3MzIzZWM0YThlMzdiZTJjMGY1YTlhMA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-06-29T16:20:47Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-06-30T16:31:41Z"}, "message": "Implicit Self on Traits\n\nSelf is actually an implicit inherited type parameter on Trait\ndeclarations. This adds this akin to impl blocks, and substitutes the\nactual impl self type into the trait-impl item for type checking.\n\nFixes #473", "tree": {"sha": "2a29dac59f9d376f554172197539e51d918af283", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a29dac59f9d376f554172197539e51d918af283"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0163ca4b6f2248103d416405b6758f7abb5e18ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0163ca4b6f2248103d416405b6758f7abb5e18ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0163ca4b6f2248103d416405b6758f7abb5e18ab"}], "stats": {"total": 331, "additions": 263, "deletions": 68}, "files": [{"sha": "7865a44cae1f89f2365c3b52d323d2b0ccc81e33", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0", "patch": "@@ -3382,24 +3382,11 @@ class Trait : public VisItem\n {\n   bool has_unsafe;\n   Identifier name;\n-\n-  // bool has_generics;\n-  // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n-\n-  // bool has_type_param_bounds;\n-  // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound> >\n-    type_param_bounds; // inlined form\n-\n-  // bool has_where_clause;\n+  std::vector<std::unique_ptr<GenericParam> > generic_params;\n+  std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds;\n   WhereClause where_clause;\n-\n   std::vector<Attribute> inner_attrs;\n-\n-  // bool has_trait_items;\n   std::vector<std::unique_ptr<TraitItem> > trait_items;\n-\n   Location locus;\n \n public:\n@@ -3432,7 +3419,6 @@ class Trait : public VisItem\n \t std::vector<std::unique_ptr<TraitItem> > trait_items, Visibility vis,\n \t std::vector<Attribute> outer_attrs, std::vector<Attribute> inner_attrs,\n \t Location locus)\n-\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n       has_unsafe (is_unsafe), name (std::move (name)),\n       generic_params (std::move (generic_params)),\n@@ -3530,13 +3516,17 @@ class Trait : public VisItem\n     return type_param_bounds;\n   }\n \n-  // TODO: is this better? Or is a \"vis_block\" better?\n   WhereClause &get_where_clause ()\n   {\n     rust_assert (has_where_clause ());\n     return where_clause;\n   }\n \n+  void insert_implict_self (std::unique_ptr<AST::GenericParam> &&param)\n+  {\n+    generic_params.push_back (std::move (param));\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "665ca2a3f8a3d9f3c0fef03e8eba3212bfd1e2fd", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0", "patch": "@@ -385,7 +385,7 @@ struct SelfParam\n   bool has_lifetime () const { return !lifetime.is_error (); }\n \n   // Returns whether the self-param is in an error state.\n-  bool is_error () const { return self_kind != ImplicitSelfKind::NONE; }\n+  bool is_error () const { return self_kind == ImplicitSelfKind::NONE; }\n \n   std::string as_string () const;\n \n@@ -2364,7 +2364,7 @@ struct TraitFunctionDecl\n       generic_params (std::move (generic_params)),\n       function_params (std::move (function_params)),\n       return_type (std::move (return_type)),\n-      where_clause (std::move (where_clause)), self (self)\n+      where_clause (std::move (where_clause)), self (std::move (self))\n   {}\n \n   // Copy constructor with clone\n@@ -2661,24 +2661,11 @@ class TraitItemType : public TraitItem\n class Trait : public VisItem\n {\n   bool has_unsafe;\n-\n   Identifier name;\n-\n-  // bool has_generics;\n-  // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n-\n-  // bool has_type_param_bounds;\n-  // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound> >\n-    type_param_bounds; // inlined form\n-\n-  // bool has_where_clause;\n+  std::vector<std::unique_ptr<GenericParam> > generic_params;\n+  std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds;\n   WhereClause where_clause;\n-\n-  // bool has_trait_items;\n   std::vector<std::unique_ptr<TraitItem> > trait_items;\n-\n   Location locus;\n \n public:\n@@ -2768,6 +2755,16 @@ class Trait : public VisItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "fafd27ea21714f9704e3a9a9394a72c019244fb5", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 69, "deletions": 17, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0", "patch": "@@ -310,16 +310,15 @@ class ResolveItem : public ResolverBase\n     NodeId scope_node_id = trait.get_node_id ();\n     resolver->get_type_scope ().push (scope_node_id);\n \n-    // TODO\n     // we need to inject an implicit self TypeParam here\n-    // see: https://doc.rust-lang.org/reference/items/traits.html\n+    AST::TypeParam *implicit_self\n+      = new AST::TypeParam (\"Self\", trait.get_locus ());\n+    trait.insert_implict_self (\n+      std::unique_ptr<AST::GenericParam> (implicit_self));\n \n-    if (trait.has_generics ())\n+    for (auto &generic : trait.get_generic_params ())\n       {\n-\tfor (auto &generic : trait.get_generic_params ())\n-\t  {\n-\t    ResolveGenericParam::go (generic.get (), trait.get_node_id ());\n-\t  }\n+\tResolveGenericParam::go (generic.get (), trait.get_node_id ());\n       }\n \n     for (auto &item : trait.get_trait_items ())\n@@ -371,21 +370,74 @@ class ResolveItem : public ResolverBase\n     resolver->get_label_scope ().pop ();\n   }\n \n-  void visit (AST::TraitItemMethod &) override\n+  void visit (AST::TraitItemMethod &func) override\n   {\n-    // TODO\n-  }\n+    NodeId scope_node_id = func.get_node_id ();\n+    resolver->get_name_scope ().push (scope_node_id);\n+    resolver->get_type_scope ().push (scope_node_id);\n+    resolver->get_label_scope ().push (scope_node_id);\n+    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n \n-  void visit (AST::TraitItemConst &) override\n-  {\n-    // TODO\n-  }\n+    AST::TraitMethodDecl &function = func.get_trait_method_decl ();\n+    if (function.has_generics ())\n+      {\n+\tfor (auto &generic : function.get_generic_params ())\n+\t  ResolveGenericParam::go (generic.get (), func.get_node_id ());\n+      }\n \n-  void visit (AST::TraitItemType &) override\n-  {\n-    // TODO\n+    if (function.has_return_type ())\n+      ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n+\n+    // self turns into (self: Self) as a function param\n+    AST::SelfParam &self_param = function.get_self_param ();\n+    AST::IdentifierPattern self_pattern (\n+      self_param.get_node_id (), \"self\", self_param.get_locus (),\n+      self_param.get_has_ref (), self_param.get_is_mut (),\n+      std::unique_ptr<AST::Pattern> (nullptr));\n+\n+    std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n+    segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n+      new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n+\n+    AST::TypePath self_type_path (std::move (segments),\n+\t\t\t\t  self_param.get_locus ());\n+\n+    ResolveType::go (&self_type_path, self_param.get_node_id ());\n+    PatternDeclaration::go (&self_pattern, self_param.get_node_id ());\n+\n+    resolver->mark_assignment_to_decl (self_pattern.get_node_id (),\n+\t\t\t\t       self_pattern.get_node_id ());\n+\n+    // we make a new scope so the names of parameters are resolved and shadowed\n+    // correctly\n+    for (auto &param : function.get_function_params ())\n+      {\n+\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n+\tPatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t\tparam.get_node_id ());\n+\n+\t// the mutability checker needs to verify for immutable decls the number\n+\t// of assignments are <1. This marks an implicit assignment\n+\tresolver->mark_assignment_to_decl (param.get_pattern ()->get_node_id (),\n+\t\t\t\t\t   param.get_node_id ());\n+      }\n+\n+    // trait items have an optional body\n+    if (func.has_definition ())\n+      ResolveExpr::go (func.get_definition ().get (), func.get_node_id ());\n+\n+    resolver->get_name_scope ().pop ();\n+    resolver->get_type_scope ().pop ();\n+    resolver->get_label_scope ().pop ();\n   }\n \n+  // TODO\n+  void visit (AST::TraitItemConst &) override { gcc_unreachable (); }\n+\n+  void visit (AST::TraitItemType &) override { gcc_unreachable (); }\n+\n private:\n   ResolveItem () : ResolverBase (UNKNOWN_NODEID) {}\n };"}, {"sha": "19e732494e51d87d0b775ebe07be96e65d3ea0bf", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0", "patch": "@@ -312,9 +312,7 @@ class ResolveGenericParam : public ResolverBase\n \n     // if it has a type lets resolve it\n     if (param.has_type ())\n-      {\n-\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n-      }\n+      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n \n     // for now lets focus on handling the basics: like struct<T> { a:T, ....}\n     resolver->get_type_scope ().insert (\n@@ -328,11 +326,7 @@ class ResolveGenericParam : public ResolverBase\n   }\n \n private:\n-  ResolveGenericParam (NodeId parent)\n-    : ResolverBase (parent),\n-\n-      ok (false)\n-  {}\n+  ResolveGenericParam (NodeId parent) : ResolverBase (parent), ok (false) {}\n \n   bool ok;\n };"}, {"sha": "6a9fe8732070a13d4622556e249e2c1bc34948b8", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 57, "deletions": 6, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0", "patch": "@@ -33,9 +33,11 @@ class ResolveTraitItemToRef : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static TraitItemReference Resolve (HIR::TraitItem &item)\n+  static TraitItemReference\n+  Resolve (HIR::TraitItem &item, TyTy::BaseType *self,\n+\t   std::vector<TyTy::SubstitutionParamMapping> substitutions)\n   {\n-    ResolveTraitItemToRef resolver;\n+    ResolveTraitItemToRef resolver (self, substitutions);\n     item.accept_vis (resolver);\n     return resolver.resolved;\n   }\n@@ -89,7 +91,6 @@ class ResolveTraitItemToRef : public TypeCheckBase\n     if (!context->lookup_type (fn.get_mappings ().get_hirid (), &ty))\n       {\n \tHIR::TraitFunctionDecl &function = fn.get_decl ();\n-\tstd::vector<TyTy::SubstitutionParamMapping> substitutions;\n \tif (function.has_generics ())\n \t  {\n \t    for (auto &generic_param : function.get_generic_params ())\n@@ -135,6 +136,21 @@ class ResolveTraitItemToRef : public TypeCheckBase\n \t  }\n \n \tstd::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n+\tif (function.is_method ())\n+\t  {\n+\t    // add the synthetic self param at the front, this is a placeholder\n+\t    // for compilation to know parameter names. The types are ignored\n+\t    // but we reuse the HIR identifier pattern which requires it\n+\t    HIR::SelfParam &self_param = function.get_self ();\n+\t    HIR::IdentifierPattern *self_pattern = new HIR::IdentifierPattern (\n+\t      \"self\", self_param.get_locus (), self_param.is_ref (),\n+\t      self_param.is_mut (), std::unique_ptr<HIR::Pattern> (nullptr));\n+\t    context->insert_type (self_param.get_mappings (), self->clone ());\n+\t    params.push_back (\n+\t      std::pair<HIR::Pattern *, TyTy::BaseType *> (self_pattern,\n+\t\t\t\t\t\t\t   self->clone ()));\n+\t  }\n+\n \tfor (auto &param : function.get_function_params ())\n \t  {\n \t    // get the name as well required for later on\n@@ -163,11 +179,16 @@ class ResolveTraitItemToRef : public TypeCheckBase\n   }\n \n private:\n-  ResolveTraitItemToRef ()\n-    : TypeCheckBase (), resolved (TraitItemReference::error ())\n+  ResolveTraitItemToRef (\n+    TyTy::BaseType *self,\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions)\n+    : TypeCheckBase (), resolved (TraitItemReference::error ()), self (self),\n+      substitutions (substitutions)\n   {}\n \n   TraitItemReference resolved;\n+  TyTy::BaseType *self;\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n };\n \n class TraitResolver : public TypeCheckBase\n@@ -224,11 +245,41 @@ class TraitResolver : public TypeCheckBase\n \treturn tref;\n       }\n \n+    TyTy::BaseType *self = nullptr;\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+    for (auto &generic_param : trait_reference->get_generic_params ())\n+      {\n+\tswitch (generic_param.get ()->get_kind ())\n+\t  {\n+\t  case HIR::GenericParam::GenericKind::LIFETIME:\n+\t    // Skipping Lifetime completely until better handling.\n+\t    break;\n+\n+\t    case HIR::GenericParam::GenericKind::TYPE: {\n+\t      auto param_type\n+\t\t= TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t      context->insert_type (generic_param->get_mappings (), param_type);\n+\n+\t      auto &typaram = static_cast<HIR::TypeParam &> (*generic_param);\n+\t      substitutions.push_back (\n+\t\tTyTy::SubstitutionParamMapping (typaram, param_type));\n+\n+\t      if (typaram.get_type_representation ().compare (\"Self\") == 0)\n+\t\t{\n+\t\t  self = param_type;\n+\t\t}\n+\t    }\n+\t    break;\n+\t  }\n+      }\n+\n+    rust_assert (self != nullptr);\n+\n     std::vector<TraitItemReference> item_refs;\n     for (auto &item : trait_reference->get_trait_items ())\n       {\n \tTraitItemReference trait_item_ref\n-\t  = ResolveTraitItemToRef::Resolve (*item.get ());\n+\t  = ResolveTraitItemToRef::Resolve (*item.get (), self, substitutions);\n \titem_refs.push_back (std::move (trait_item_ref));\n       }\n "}, {"sha": "242f6d77a9c06e75a837f4116763a53bb41ab237", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 96, "deletions": 2, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0", "patch": "@@ -303,7 +303,75 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \n   void visit (HIR::TypeAlias &type) override { gcc_unreachable (); }\n \n-  void visit (HIR::Method &method) override { gcc_unreachable (); }\n+  void visit (HIR::Method &method) override\n+  {\n+    TypeCheckImplItem::visit (method);\n+\n+    // we get the error checking from the base method here\n+    TyTy::BaseType *lookup;\n+    if (!context->lookup_type (method.get_mappings ().get_hirid (), &lookup))\n+      return;\n+\n+    if (lookup->get_kind () != TyTy::TypeKind::FNDEF)\n+      return;\n+\n+    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n+    const TraitItemReference &trait_item_ref\n+      = trait_reference.lookup_trait_item (\n+\tfntype->get_identifier (), TraitItemReference::TraitItemType::FN);\n+\n+    // unknown trait item\n+    if (trait_item_ref.is_error ())\n+      {\n+\tRichLocation r (method.get_locus ());\n+\tr.add_range (trait_reference.get_locus ());\n+\trust_error_at (r, \"method %<%s%> is not a member of trait %<%s%>\",\n+\t\t       fntype->get_identifier ().c_str (),\n+\t\t       trait_reference.get_name ().c_str ());\n+\treturn;\n+      }\n+\n+    rust_assert (trait_item_ref.get_tyty ()->get_kind ()\n+\t\t == TyTy::TypeKind::FNDEF);\n+    TyTy::FnType *trait_item_fntype\n+      = static_cast<TyTy::FnType *> (trait_item_ref.get_tyty ());\n+\n+    // sets substitute self into the trait_item_ref->tyty\n+    TyTy::SubstitutionParamMapping *self_mapping = nullptr;\n+    for (auto &param_mapping : trait_item_fntype->get_substs ())\n+      {\n+\tconst HIR::TypeParam &type_param = param_mapping.get_generic_param ();\n+\tif (type_param.get_type_representation ().compare (\"Self\") == 0)\n+\t  {\n+\t    self_mapping = &param_mapping;\n+\t    break;\n+\t  }\n+      }\n+    rust_assert (self_mapping != nullptr);\n+\n+    std::vector<TyTy::SubstitutionArg> mappings;\n+    mappings.push_back (TyTy::SubstitutionArg (self_mapping, self));\n+\n+    TyTy::SubstitutionArgumentMappings implicit_self_substs (\n+      mappings, method.get_locus ());\n+    trait_item_fntype\n+      = trait_item_fntype->handle_substitions (implicit_self_substs);\n+\n+    // check the types are compatible\n+    if (!trait_item_fntype->can_eq (fntype))\n+      {\n+\tRichLocation r (method.get_locus ());\n+\tr.add_range (trait_item_ref.get_locus ());\n+\n+\trust_error_at (\n+\t  r, \"method %<%s%> has an incompatible type for trait %<%s%>\",\n+\t  fntype->get_identifier ().c_str (),\n+\t  trait_reference.get_name ().c_str ());\n+\treturn;\n+      }\n+\n+    resolved_trait_item = trait_item_ref;\n+  }\n \n   void visit (HIR::Function &function) override\n   {\n@@ -333,8 +401,34 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \treturn;\n       }\n \n+    rust_assert (trait_item_ref.get_tyty ()->get_kind ()\n+\t\t == TyTy::TypeKind::FNDEF);\n+    TyTy::FnType *trait_item_fntype\n+      = static_cast<TyTy::FnType *> (trait_item_ref.get_tyty ());\n+\n+    // sets substitute self into the trait_item_ref->tyty\n+    TyTy::SubstitutionParamMapping *self_mapping = nullptr;\n+    for (auto &param_mapping : trait_item_fntype->get_substs ())\n+      {\n+\tconst HIR::TypeParam &type_param = param_mapping.get_generic_param ();\n+\tif (type_param.get_type_representation ().compare (\"Self\") == 0)\n+\t  {\n+\t    self_mapping = &param_mapping;\n+\t    break;\n+\t  }\n+      }\n+    rust_assert (self_mapping != nullptr);\n+\n+    std::vector<TyTy::SubstitutionArg> mappings;\n+    mappings.push_back (TyTy::SubstitutionArg (self_mapping, self));\n+\n+    TyTy::SubstitutionArgumentMappings implicit_self_substs (\n+      mappings, function.get_locus ());\n+    trait_item_fntype\n+      = trait_item_fntype->handle_substitions (implicit_self_substs);\n+\n     // check the types are compatible\n-    if (!trait_item_ref.get_tyty ()->can_eq (fntype))\n+    if (!trait_item_fntype->can_eq (fntype))\n       {\n \tRichLocation r (function.get_locus ());\n \tr.add_range (trait_item_ref.get_locus ());"}, {"sha": "438c52b4e8c025cb775d03b45ea0d759d5ccc8e4", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0", "patch": "@@ -468,7 +468,6 @@ class SubstitutionParamMapping\n {\n public:\n   SubstitutionParamMapping (const HIR::TypeParam &generic, ParamType *param)\n-\n     : generic (generic), param (param)\n   {}\n "}, {"sha": "621fcde8745a37877ef87ed579a77014845cbf4c", "filename": "gcc/testsuite/rust/compile/torture/traits3.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits3.rs?ref=9e7e6b3b8742a89b97323ec4a8e37be2c0f5a9a0", "patch": "@@ -0,0 +1,18 @@\n+pub trait Foo {\n+    fn Bar(self) -> i32;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .Bar.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+struct Baz;\n+// { dg-warning \"struct is never constructed: .Baz.\" \"\" { target *-*-* } .-1 }\n+\n+impl Foo for Baz {\n+    fn Bar(self) -> i32 {\n+        // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+        // { dg-warning \"unused name .<Baz as Foo>::Bar.\" \"\" { target *-*-* } .-2 }\n+        123\n+    }\n+}\n+\n+fn main() {}"}]}