{"sha": "5ffe0bab81981655b009617fc7041a818fee1d89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZmZTBiYWI4MTk4MTY1NWIwMDk2MTdmYzcwNDFhODE4ZmVlMWQ4OQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T15:12:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T15:12:06Z"}, "message": "[multiple changes]\n\n2011-08-03  Thomas Quinot  <quinot@adacore.com>\n\n\t* scos.adb, get_scos.adb, put_scos.adb\n\tNew code letter for decisions: G (entry guard)\n\t* par_sco.adb\n\t(Traverse_Subprogram_Body): Rename to...\n\t(Traverse_Subprogram_Or_Task_Body): New subrpogram.\n\t(Traverse_Protected_Body): New subprogram\n\t(Traverse_Declarations_Or_Statements): Add traversal of task bodies,\n\tprotected bodies and entry bodies.\n\n2011-08-03  Yannick Moy  <moy@adacore.com>\n\n\t* einfo.adb, einfo.ads (Is_Postcondition_Proc): new flag for procedure\n\tentities with get/set subprograms, which is set on procedure entities\n\tgenerated by the compiler for a postcondition.\n\t* sem_ch6.adb (Process_PPCs): set new flag on postcondition procedures\n\t* alfa.adb, alfa.ads (Get_Entity_For_Decl): new function returning the\n\tentity for a declaration\n\t(Get_Unique_Entity_For_Decl): new function returning an entity which\n\trepresents a declaration, so that matching spec and body have the same\n\tentity.\n\n2011-08-03  Robert Dewar  <dewar@adacore.com>\n\n\t* a-except-2005.adb, a-cfhama.adb, a-cfhase.adb, a-cfhase.ads,\n\ta-cforma.adb, a-cforse.ads, a-cforse.adb: Minor reformatting\n\n2011-08-03  Yannick Moy  <moy@adacore.com>\n\n\t* lib-xref-alfa.adb (Detect_And_Add_ALFA_Scope): make the subprogram\n\tlibrary-level because retriction No_Implicit_Dynamic_Code in the\n\tfront-end prevents its definition as a local subprogram\n\t(Traverse_Compilation_Unit): extract new procedure from Add_ALFA_File,\n\tfor reuse in other contexts\n\t(Traverse_Declarations_Or_Statements,\n\tTraverse_Handled_Statement_Sequence, Traverse_Package_Body,\n\tTraverse_Package_Declaration, Traverse_Subprogram_Body): make all these\n\tprocedures take a callback parameter to be called on all declarations\n\t* lib-xref.ads\n\t(Traverse_All_Compilation_Units): new generic function to traverse a\n\tcompilation unit and call a callback parameter on all declarations\n\nFrom-SVN: r177284", "tree": {"sha": "c3e1b37787cbc0bbe2f029504a32efa76e9d5ecd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3e1b37787cbc0bbe2f029504a32efa76e9d5ecd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ffe0bab81981655b009617fc7041a818fee1d89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ffe0bab81981655b009617fc7041a818fee1d89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ffe0bab81981655b009617fc7041a818fee1d89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ffe0bab81981655b009617fc7041a818fee1d89/comments", "author": null, "committer": null, "parents": [{"sha": "f9ad6b6231baeb79e967d1e7f1d1d9a7953453b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9ad6b6231baeb79e967d1e7f1d1d9a7953453b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9ad6b6231baeb79e967d1e7f1d1d9a7953453b7"}], "stats": {"total": 1022, "additions": 562, "deletions": 460}, "files": [{"sha": "fb01723f9a1d1643daebb22be9cf31326821d240", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5ffe0bab81981655b009617fc7041a818fee1d89", "patch": "@@ -1,3 +1,46 @@\n+2011-08-03  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* scos.adb, get_scos.adb, put_scos.adb\n+\tNew code letter for decisions: G (entry guard)\n+\t* par_sco.adb\n+\t(Traverse_Subprogram_Body): Rename to...\n+\t(Traverse_Subprogram_Or_Task_Body): New subrpogram.\n+\t(Traverse_Protected_Body): New subprogram\n+\t(Traverse_Declarations_Or_Statements): Add traversal of task bodies,\n+\tprotected bodies and entry bodies.\n+\n+2011-08-03  Yannick Moy  <moy@adacore.com>\n+\n+\t* einfo.adb, einfo.ads (Is_Postcondition_Proc): new flag for procedure\n+\tentities with get/set subprograms, which is set on procedure entities\n+\tgenerated by the compiler for a postcondition.\n+\t* sem_ch6.adb (Process_PPCs): set new flag on postcondition procedures\n+\t* alfa.adb, alfa.ads (Get_Entity_For_Decl): new function returning the\n+\tentity for a declaration\n+\t(Get_Unique_Entity_For_Decl): new function returning an entity which\n+\trepresents a declaration, so that matching spec and body have the same\n+\tentity.\n+\n+2011-08-03  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-except-2005.adb, a-cfhama.adb, a-cfhase.adb, a-cfhase.ads,\n+\ta-cforma.adb, a-cforse.ads, a-cforse.adb: Minor reformatting\n+\n+2011-08-03  Yannick Moy  <moy@adacore.com>\n+\n+\t* lib-xref-alfa.adb (Detect_And_Add_ALFA_Scope): make the subprogram\n+\tlibrary-level because retriction No_Implicit_Dynamic_Code in the\n+\tfront-end prevents its definition as a local subprogram\n+\t(Traverse_Compilation_Unit): extract new procedure from Add_ALFA_File,\n+\tfor reuse in other contexts\n+\t(Traverse_Declarations_Or_Statements,\n+\tTraverse_Handled_Statement_Sequence, Traverse_Package_Body,\n+\tTraverse_Package_Declaration, Traverse_Subprogram_Body): make all these\n+\tprocedures take a callback parameter to be called on all declarations\n+\t* lib-xref.ads\n+\t(Traverse_All_Compilation_Units): new generic function to traverse a\n+\tcompilation unit and call a callback parameter on all declarations\n+\n 2011-08-03  Javier Miranda  <miranda@adacore.com>\n \n \t* sem_prag.adb (Process_Interface_Name): Allow duplicated export names"}, {"sha": "f2d670c751c8d8ad42c9dfc9f7a904b7339a483e", "filename": "gcc/ada/a-cfhama.adb", "status": "modified", "additions": 72, "deletions": 64, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fa-cfhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fa-cfhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.adb?ref=5ffe0bab81981655b009617fc7041a818fee1d89", "patch": "@@ -41,6 +41,8 @@ package body Ada.Containers.Formal_Hashed_Maps is\n    -- Local Subprograms --\n    -----------------------\n \n+   --  All local subprograms require comments ???\n+\n    function Equivalent_Keys\n      (Key  : Key_Type;\n       Node : Node_Type) return Boolean;\n@@ -73,10 +75,10 @@ package body Ada.Containers.Formal_Hashed_Maps is\n \n    package HT_Ops is\n      new Hash_Tables.Generic_Bounded_Operations\n-       (HT_Types        => HT_Types,\n-        Hash_Node       => Hash_Node,\n-        Next            => Next,\n-        Set_Next        => Set_Next);\n+       (HT_Types  => HT_Types,\n+        Hash_Node => Hash_Node,\n+        Next      => Next,\n+        Set_Next  => Set_Next);\n \n    package Key_Ops is\n      new Hash_Tables.Generic_Bounded_Keys\n@@ -93,7 +95,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n \n    function \"=\" (Left, Right : Map) return Boolean is\n    begin\n-\n       if Length (Left) /= Length (Right) then\n          return False;\n       end if;\n@@ -103,13 +104,15 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       end if;\n \n       declare\n-         Node  : Count_Type := Left.First.Node;\n+         Node  : Count_Type;\n          ENode : Count_Type;\n-      begin\n \n+      begin\n+         Node := Left.First.Node;\n          while Node /= 0 loop\n             ENode := Find (Container => Right,\n                            Key       => Left.Nodes (Node).Key).Node;\n+\n             if ENode = 0 or else\n               Right.Nodes (ENode).Element /= Left.Nodes (Node).Element\n             then\n@@ -120,9 +123,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n          end loop;\n \n          return True;\n-\n       end;\n-\n    end \"=\";\n \n    ------------\n@@ -149,7 +150,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       --  Start of processing for Assign\n \n    begin\n-\n       if Target'Address = Source'Address then\n          return;\n       end if;\n@@ -159,7 +159,9 @@ package body Ada.Containers.Formal_Hashed_Maps is\n            \"Source length exceeds Target capacity\";\n       end if;\n \n-      Clear (Target);  -- checks busy bits\n+      --  Check busy bits\n+\n+      Clear (Target);\n \n       Insert_Elements (Source);\n    end Assign;\n@@ -201,27 +203,33 @@ package body Ada.Containers.Formal_Hashed_Maps is\n    is\n       C      : constant Count_Type :=\n                  Count_Type'Max (Capacity, Source.Capacity);\n-      H      : Hash_Type := 1;\n-      N      : Count_Type := 1;\n+      H      : Hash_Type;\n+      N      : Count_Type;\n       Target : Map (C, Source.Modulus);\n       Cu     : Cursor;\n-   begin\n \n+   begin\n       Target.Length := Source.Length;\n       Target.Free := Source.Free;\n+\n+      H := 1;\n       while H <= Source.Modulus loop\n          Target.Buckets (H) := Source.Buckets (H);\n          H := H + 1;\n       end loop;\n+\n+      N := 1;\n       while N <= Source.Capacity loop\n          Target.Nodes (N) := Source.Nodes (N);\n          N := N + 1;\n       end loop;\n+\n       while N <= C loop\n          Cu := (Node => N);\n          Free (Target, Cu.Node);\n          N := N + 1;\n       end loop;\n+\n       return Target;\n    end Copy;\n \n@@ -242,7 +250,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       X : Count_Type;\n \n    begin\n-\n       Key_Ops.Delete_Key_Sans_Free (Container, Key, X);\n \n       if X = 0 then\n@@ -254,7 +261,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) is\n    begin\n-\n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with\n            \"Position cursor of Delete has no element\";\n@@ -306,14 +312,18 @@ package body Ada.Containers.Formal_Hashed_Maps is\n \n    function Equivalent_Keys\n      (Key  : Key_Type;\n-      Node : Node_Type) return Boolean is\n+      Node : Node_Type) return Boolean\n+   is\n    begin\n       return Equivalent_Keys (Key, Node.Key);\n    end Equivalent_Keys;\n \n-   function Equivalent_Keys (Left  : Map; CLeft : Cursor;\n-                             Right : Map; CRight : Cursor)\n-                             return Boolean is\n+   function Equivalent_Keys\n+     (Left   : Map;\n+      CLeft  : Cursor;\n+      Right  : Map;\n+      CRight : Cursor) return Boolean\n+   is\n    begin\n       if not Has_Element (Left, CLeft) then\n          raise Constraint_Error with\n@@ -331,10 +341,8 @@ package body Ada.Containers.Formal_Hashed_Maps is\n                      \"Right cursor of Equivalent_Keys is bad\");\n \n       declare\n-\n          LN : Node_Type renames Left.Nodes (CLeft.Node);\n          RN : Node_Type renames Right.Nodes (CRight.Node);\n-\n       begin\n          return Equivalent_Keys (LN.Key, RN.Key);\n       end;\n@@ -343,7 +351,8 @@ package body Ada.Containers.Formal_Hashed_Maps is\n    function Equivalent_Keys\n      (Left  : Map;\n       CLeft : Cursor;\n-      Right : Key_Type) return Boolean is\n+      Right : Key_Type) return Boolean\n+   is\n    begin\n       if not Has_Element (Left, CLeft) then\n          raise Constraint_Error with\n@@ -355,7 +364,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n \n       declare\n          LN : Node_Type renames Left.Nodes (CLeft.Node);\n-\n       begin\n          return Equivalent_Keys (LN.Key, Right);\n       end;\n@@ -364,7 +372,8 @@ package body Ada.Containers.Formal_Hashed_Maps is\n    function Equivalent_Keys\n      (Left   : Key_Type;\n       Right  : Map;\n-      CRight : Cursor) return Boolean is\n+      CRight : Cursor) return Boolean\n+   is\n    begin\n       if Has_Element (Right, CRight) then\n          raise Constraint_Error with\n@@ -399,7 +408,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n \n    function Find (Container : Map; Key : Key_Type) return Cursor is\n       Node : constant Count_Type :=\n-        Key_Ops.Find (Container, Key);\n+               Key_Ops.Find (Container, Key);\n \n    begin\n       if Node = 0 then\n@@ -422,17 +431,13 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       end if;\n \n       return (Node => Node);\n-\n    end First;\n \n    ----------\n    -- Free --\n    ----------\n \n-   procedure Free\n-     (HT : in out Map;\n-      X  : Count_Type)\n-   is\n+   procedure Free (HT : in out Map; X : Count_Type) is\n    begin\n       HT.Nodes (X).Has_Element := False;\n       HT_Ops.Free (HT, X);\n@@ -442,10 +447,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n    -- Generic_Allocate --\n    ----------------------\n \n-   procedure Generic_Allocate\n-     (HT   : in out Map;\n-      Node : out Count_Type)\n-   is\n+   procedure Generic_Allocate (HT : in out Map; Node : out Count_Type) is\n \n       procedure Allocate is\n         new HT_Ops.Generic_Allocate (Set_Element);\n@@ -465,15 +467,15 @@ package body Ada.Containers.Formal_Hashed_Maps is\n         not Container.Nodes (Position.Node).Has_Element then\n          return False;\n       end if;\n+\n       return True;\n    end Has_Element;\n \n    ---------------\n    -- Hash_Node --\n    ---------------\n \n-   function Hash_Node\n-     (Node : Node_Type) return Hash_Type is\n+   function Hash_Node (Node : Node_Type) return Hash_Type is\n    begin\n       return Hash (Node.Key);\n    end Hash_Node;\n@@ -537,6 +539,8 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       procedure Assign_Key (Node : in out Node_Type) is\n       begin\n          Node.Key := Key;\n+\n+         --  What is following commented out line doing here ???\n          --  Node.Element := New_Item;\n       end Assign_Key;\n \n@@ -551,7 +555,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n          return Result;\n       end New_Node;\n \n-      --  Start of processing for Insert\n+   --  Start of processing for Insert\n \n    begin\n \n@@ -598,10 +602,9 @@ package body Ada.Containers.Formal_Hashed_Maps is\n          return Result;\n       end New_Node;\n \n-      --  Start of processing for Insert\n+   --  Start of processing for Insert\n \n    begin\n-\n       Local_Insert (Container, Key, Position.Node, Inserted);\n    end Insert;\n \n@@ -639,8 +642,8 @@ package body Ada.Containers.Formal_Hashed_Maps is\n \n    procedure Iterate\n      (Container : Map;\n-      Process   :\n-        not null access procedure (Container : Map; Position : Cursor))\n+      Process   : not null\n+                    access procedure (Container : Map; Position : Cursor))\n    is\n       procedure Process_Node (Node : Count_Type);\n       pragma Inline (Process_Node);\n@@ -658,7 +661,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n \n       B : Natural renames Container'Unrestricted_Access.Busy;\n \n-      --  Start of processing for Iterate\n+   --  Start of processing for Iterate\n \n    begin\n       B := B + 1;\n@@ -695,14 +698,18 @@ package body Ada.Containers.Formal_Hashed_Maps is\n    ----------\n \n    function Left (Container : Map; Position : Cursor) return Map is\n-      Curs : Cursor := Position;\n-      C : Map (Container.Capacity, Container.Modulus) :=\n-        Copy (Container, Container.Capacity);\n+      Curs : Cursor;\n+      C    : Map (Container.Capacity, Container.Modulus) :=\n+               Copy (Container, Container.Capacity);\n       Node : Count_Type;\n+\n    begin\n+      Curs := Position;\n+\n       if Curs = No_Element then\n          return C;\n       end if;\n+\n       if not Has_Element (Container, Curs) then\n          raise Constraint_Error;\n       end if;\n@@ -712,6 +719,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n          Delete (C, Curs);\n          Curs := Next (Container, (Node => Node));\n       end loop;\n+\n       return C;\n    end Left;\n \n@@ -736,7 +744,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       X, Y : Count_Type;\n \n    begin\n-\n       if Target'Address = Source'Address then\n          return;\n       end if;\n@@ -816,6 +823,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n    function Overlap (Left, Right : Map) return Boolean is\n       Left_Node  : Count_Type;\n       Left_Nodes : Nodes_Type renames Left.Nodes;\n+\n    begin\n       if Length (Right) = 0 or Length (Left) = 0 then\n          return False;\n@@ -826,12 +834,10 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       end if;\n \n       Left_Node := First (Left).Node;\n-\n       while Left_Node /= 0 loop\n          declare\n             N : Node_Type renames Left_Nodes (Left_Node);\n             E : Key_Type renames N.Key;\n-\n          begin\n             if Find (Right, E).Node /= 0 then\n                return True;\n@@ -852,10 +858,9 @@ package body Ada.Containers.Formal_Hashed_Maps is\n      (Container : in out Map;\n       Position  : Cursor;\n       Process   : not null access\n-        procedure (Key : Key_Type; Element : Element_Type))\n+                    procedure (Key : Key_Type; Element : Element_Type))\n    is\n    begin\n-\n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with\n            \"Position cursor of Query_Element has no element\";\n@@ -864,8 +869,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       pragma Assert (Vet (Container, Position), \"bad cursor in Query_Element\");\n \n       declare\n-         N  : Node_Type renames Container.Nodes (Position.Node);\n-\n+         N : Node_Type renames Container.Nodes (Position.Node);\n          B : Natural renames Container.Busy;\n          L : Natural renames Container.Lock;\n \n@@ -876,7 +880,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n          declare\n             K : Key_Type renames N.Key;\n             E : Element_Type renames N.Element;\n-\n          begin\n             Process (K, E);\n          exception\n@@ -909,8 +912,8 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       -- Read_Node --\n       ---------------\n \n-      function Read_Node (Stream : not null access Root_Stream_Type'Class)\n-                          return Count_Type\n+      function Read_Node\n+        (Stream : not null access Root_Stream_Type'Class) return Count_Type\n       is\n          procedure Read_Element (Node : in out Node_Type);\n          pragma Inline (Read_Element);\n@@ -925,14 +928,15 @@ package body Ada.Containers.Formal_Hashed_Maps is\n \n          Node : Count_Type;\n \n-         --  Start of processing for Read_Node\n+      --  Start of processing for Read_Node\n \n       begin\n          Allocate (Container, Node);\n          return Node;\n       end Read_Node;\n \n-      --  Start of processing for Read\n+   --  Start of processing for Read\n+\n    begin\n       Read_Nodes (Stream, Container);\n    end Read;\n@@ -957,7 +961,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       Node : constant Count_Type := Key_Ops.Find (Container, Key);\n \n    begin\n-\n       if Node = 0 then\n          raise Constraint_Error with\n            \"attempt to replace key not in map\";\n@@ -986,7 +989,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       New_Item  : Element_Type)\n    is\n    begin\n-\n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with\n            \"Position cursor of Replace_Element has no element\";\n@@ -1012,7 +1014,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       Capacity  : Count_Type)\n    is\n    begin\n-\n       if Capacity > Container.Capacity then\n          raise Capacity_Error with \"requested capacity is too large\";\n       end if;\n@@ -1024,14 +1025,16 @@ package body Ada.Containers.Formal_Hashed_Maps is\n \n    function Right (Container : Map; Position : Cursor) return Map is\n       Curs : Cursor := First (Container);\n-      C : Map (Container.Capacity, Container.Modulus) :=\n-        Copy (Container, Container.Capacity);\n+      C    : Map (Container.Capacity, Container.Modulus) :=\n+               Copy (Container, Container.Capacity);\n       Node : Count_Type;\n+\n    begin\n       if Curs = No_Element then\n          Clear (C);\n          return C;\n       end if;\n+\n       if Position /= No_Element and not Has_Element (Container, Position) then\n          raise Constraint_Error;\n       end if;\n@@ -1041,6 +1044,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n          Delete (C, Curs);\n          Curs := Next (Container, (Node => Node));\n       end loop;\n+\n       return C;\n    end Right;\n \n@@ -1060,6 +1064,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n    function Strict_Equal (Left, Right : Map) return Boolean is\n       CuL : Cursor := First (Left);\n       CuR : Cursor := First (Right);\n+\n    begin\n       if Length (Left) /= Length (Right) then\n          return False;\n@@ -1073,6 +1078,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n               Right.Nodes (CuR.Node).Key) then\n             return False;\n          end if;\n+\n          CuL := Next (Left, CuL);\n          CuR := Next (Right, CuR);\n       end loop;\n@@ -1173,7 +1179,9 @@ package body Ada.Containers.Formal_Hashed_Maps is\n             end if;\n \n             if X = Container.Nodes (X).Next then\n-               --  to prevent unnecessary looping\n+\n+               --  Prevent unnecessary looping\n+\n                return False;\n             end if;\n "}, {"sha": "164433eb3b7f777a22c6a1c2815f69aac15f7a97", "filename": "gcc/ada/a-cfhase.adb", "status": "modified", "additions": 100, "deletions": 97, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fa-cfhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fa-cfhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.adb?ref=5ffe0bab81981655b009617fc7041a818fee1d89", "patch": "@@ -41,6 +41,8 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    -- Local Subprograms --\n    -----------------------\n \n+   --  All need comments ???\n+\n    procedure Difference\n      (Left, Right : Set;\n       Target      : in out Set);\n@@ -117,7 +119,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n    function \"=\" (Left, Right : Set) return Boolean is\n    begin\n-\n       if Length (Left) /= Length (Right) then\n          return False;\n       end if;\n@@ -127,14 +128,15 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       end if;\n \n       declare\n-         Node  : Count_Type := First (Left).Node;\n+         Node  : Count_Type;\n          ENode : Count_Type;\n-      begin\n \n+      begin\n+         Node  := First (Left).Node;\n          while Node /= 0 loop\n             ENode := Find (Container => Right,\n                            Item      => Left.Nodes (Node).Element).Node;\n-            if ENode = 0  or else\n+            if ENode = 0 or else\n               Right.Nodes (ENode).Element /= Left.Nodes (Node).Element\n             then\n                return False;\n@@ -173,10 +175,9 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          pragma Assert (B);\n       end Insert_Element;\n \n-      --  Start of processing for Assign\n+   --  Start of processing for Assign\n \n    begin\n-\n       if Target'Address = Source'Address then\n          return;\n       end if;\n@@ -204,7 +205,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n    procedure Clear (Container : in out Set) is\n    begin\n-\n       HT_Ops.Clear (Container);\n    end Clear;\n \n@@ -226,28 +226,34 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       Capacity : Count_Type := 0) return Set\n    is\n       C      : constant Count_Type :=\n-        Count_Type'Max (Capacity, Source.Capacity);\n-      H      : Hash_Type := 1;\n-      N      : Count_Type := 1;\n+                 Count_Type'Max (Capacity, Source.Capacity);\n+      H      : Hash_Type;\n+      N      : Count_Type;\n       Target : Set (C, Source.Modulus);\n       Cu     : Cursor;\n-   begin\n \n+   begin\n       Target.Length := Source.Length;\n       Target.Free := Source.Free;\n+\n+      H := 1;\n       while H <= Source.Modulus loop\n          Target.Buckets (H) := Source.Buckets (H);\n          H := H + 1;\n       end loop;\n+\n+      N := 1;\n       while N <= Source.Capacity loop\n          Target.Nodes (N) := Source.Nodes (N);\n          N := N + 1;\n       end loop;\n+\n       while N <= C loop\n          Cu := (Node => N);\n          Free (Target, Cu.Node);\n          N := N + 1;\n       end loop;\n+\n       return Target;\n    end Copy;\n \n@@ -271,12 +277,12 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       X : Count_Type;\n \n    begin\n-\n       Element_Keys.Delete_Key_Sans_Free (Container, Item, X);\n \n       if X = 0 then\n          raise Constraint_Error with \"attempt to delete element not in set\";\n       end if;\n+\n       Free (Container, X);\n    end Delete;\n \n@@ -285,7 +291,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       Position  : in out Cursor)\n    is\n    begin\n-\n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n@@ -317,7 +322,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       SN : Nodes_Type renames Source.Nodes;\n \n    begin\n-\n       if Target'Address = Source'Address then\n          Clear (Target);\n          return;\n@@ -337,28 +341,28 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       if Src_Length >= Target.Length then\n          Tgt_Node := HT_Ops.First (Target);\n          while Tgt_Node /= 0 loop\n-            if Element_Keys.Find (Source,\n-                                  TN (Tgt_Node).Element) /= 0 then\n+            if Element_Keys.Find (Source, TN (Tgt_Node).Element) /= 0 then\n                declare\n                   X : constant Count_Type := Tgt_Node;\n                begin\n                   Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n                   HT_Ops.Delete_Node_Sans_Free (Target, X);\n                   Free (Target, X);\n                end;\n+\n             else\n                Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n             end if;\n          end loop;\n+\n          return;\n       else\n          Src_Node := HT_Ops.First (Source);\n          Src_Last := 0;\n       end if;\n \n       while Src_Node /= Src_Last loop\n-         Tgt_Node := Element_Keys.Find\n-           (Target, SN (Src_Node).Element);\n+         Tgt_Node := Element_Keys.Find (Target, SN (Src_Node).Element);\n \n          if Tgt_Node /= 0 then\n             HT_Ops.Delete_Node_Sans_Free (Target, Tgt_Node);\n@@ -386,15 +390,14 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          E : Element_Type renames Left.Nodes (L_Node).Element;\n          X : Count_Type;\n          B : Boolean;\n-\n       begin\n          if Find (Right, E).Node = 0 then\n             Insert (Target, E, X, B);\n             pragma Assert (B);\n          end if;\n       end Process;\n \n-      --  Start of processing for Difference\n+   --  Start of processing for Difference\n \n    begin\n       Iterate (Left);\n@@ -403,6 +406,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    function Difference (Left, Right : Set) return Set is\n       C : Count_Type;\n       H : Hash_Type;\n+\n    begin\n       if Left'Address = Right'Address then\n          return Empty_Set;\n@@ -418,6 +422,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n       C := Length (Left);\n       H := Default_Modulus (C);\n+\n       return S : Set (C, H) do\n          Difference (Left, Right, Target => S);\n       end return;\n@@ -429,7 +434,8 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n    function Element\n      (Container : Set;\n-      Position  : Cursor) return Element_Type is\n+      Position  : Cursor) return Element_Type\n+   is\n    begin\n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with \"Position cursor equals No_Element\";\n@@ -464,10 +470,8 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          L_Node : Node_Type) return Boolean\n       is\n          R_Index : constant Hash_Type :=\n-           Element_Keys.Index (R_HT, L_Node.Element);\n-\n+                     Element_Keys.Index (R_HT, L_Node.Element);\n          R_Node  : Count_Type := R_HT.Buckets (R_Index);\n-\n          RN      : Nodes_Type renames R_HT.Nodes;\n \n       begin\n@@ -485,7 +489,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          end loop;\n       end Find_Equivalent_Key;\n \n-      --  Start of processing of Equivalent_Sets\n+   --  Start of processing of Equivalent_Sets\n \n    begin\n       return Is_Equivalent (Left, Right);\n@@ -495,9 +499,12 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    -- Equivalent_Elements --\n    -------------------------\n \n-   function Equivalent_Elements (Left  : Set; CLeft : Cursor;\n-                                 Right : Set; CRight : Cursor)\n-                                 return Boolean is\n+   function Equivalent_Elements\n+     (Left  : Set;\n+      CLeft : Cursor;\n+      Right  : Set;\n+      CRight : Cursor) return Boolean\n+   is\n    begin\n       if not Has_Element (Left, CLeft) then\n          raise Constraint_Error with\n@@ -525,7 +532,8 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    function Equivalent_Elements\n      (Left  : Set;\n       CLeft : Cursor;\n-      Right : Element_Type) return Boolean is\n+      Right : Element_Type) return Boolean\n+   is\n    begin\n       if not Has_Element (Left, CLeft) then\n          raise Constraint_Error with\n@@ -545,7 +553,8 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    function Equivalent_Elements\n      (Left   : Element_Type;\n       Right  : Set;\n-      CRight : Cursor) return Boolean is\n+      CRight : Cursor) return Boolean\n+   is\n    begin\n       if not Has_Element (Right, CRight) then\n          raise Constraint_Error with\n@@ -563,14 +572,17 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       end;\n    end Equivalent_Elements;\n \n+   --  What does the following comment signify???\n    --  NOT MODIFIED\n \n    ---------------------\n    -- Equivalent_Keys --\n    ---------------------\n \n-   function Equivalent_Keys (Key : Element_Type; Node : Node_Type)\n-                             return Boolean is\n+   function Equivalent_Keys\n+     (Key  : Element_Type;\n+      Node : Node_Type) return Boolean\n+   is\n    begin\n       return Equivalent_Elements (Key, Node.Element);\n    end Equivalent_Keys;\n@@ -597,15 +609,14 @@ package body Ada.Containers.Formal_Hashed_Sets is\n      (Container : Set;\n       Item      : Element_Type) return Cursor\n    is\n-      Node : constant Count_Type :=\n-        Element_Keys.Find (Container, Item);\n+      Node : constant Count_Type := Element_Keys.Find (Container, Item);\n \n    begin\n       if Node = 0 then\n          return No_Element;\n       end if;\n-      return (Node => Node);\n \n+      return (Node => Node);\n    end Find;\n \n    -----------\n@@ -614,13 +625,13 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n    function First (Container : Set) return Cursor is\n       Node : constant Count_Type := HT_Ops.First (Container);\n+\n    begin\n       if Node = 0 then\n          return No_Element;\n       end if;\n \n       return (Node => Node);\n-\n    end First;\n \n    ----------\n@@ -644,10 +655,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n      (HT   : in out Set;\n       Node : out Count_Type)\n    is\n-\n-      procedure Allocate is\n-        new HT_Ops.Generic_Allocate (Set_Element);\n-\n+      procedure Allocate is new HT_Ops.Generic_Allocate (Set_Element);\n    begin\n       Allocate (HT, Node);\n       HT.Nodes (Node).Has_Element := True;\n@@ -659,10 +667,12 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n    function Has_Element (Container : Set; Position : Cursor) return Boolean is\n    begin\n-      if Position.Node = 0 or else\n-        not Container.Nodes (Position.Node).Has_Element then\n+      if Position.Node = 0\n+        or else not Container.Nodes (Position.Node).Has_Element\n+      then\n          return False;\n       end if;\n+\n       return True;\n    end Has_Element;\n \n@@ -767,12 +777,10 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          return Result;\n       end New_Node;\n \n-      --  Start of processing for Insert\n+   --  Start of processing for Insert\n \n    begin\n-\n       Local_Insert (Container, New_Item, Node, Inserted);\n-\n    end Insert;\n \n    ------------------\n@@ -787,7 +795,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       TN       : Nodes_Type renames Target.Nodes;\n \n    begin\n-\n       if Target'Address = Source'Address then\n          return;\n       end if;\n@@ -845,7 +852,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          end if;\n       end Process;\n \n-      --  Start of processing for Intersection\n+   --  Start of processing for Intersection\n \n    begin\n       Iterate (Left);\n@@ -862,6 +869,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n       C := Count_Type'Min (Length (Left), Length (Right));  -- ???\n       H := Default_Modulus (C);\n+\n       return S : Set (C, H) do\n          if Length (Left) /= 0 and Length (Right) /= 0 then\n                Intersection (Left, Right, Target => S);\n@@ -882,8 +890,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    -- Is_In --\n    -----------\n \n-   function Is_In (HT : Set;\n-                   Key : Node_Type) return Boolean is\n+   function Is_In (HT : Set; Key : Node_Type) return Boolean is\n    begin\n       return Element_Keys.Find (HT, Key.Element) /= 0;\n    end Is_In;\n@@ -895,6 +902,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean is\n       Subset_Node  : Count_Type;\n       Subset_Nodes : Nodes_Type renames Subset.Nodes;\n+\n    begin\n       if Subset'Address = Of_Set'Address then\n          return True;\n@@ -905,7 +913,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       end if;\n \n       Subset_Node := First (Subset).Node;\n-\n       while Subset_Node /= 0 loop\n          declare\n             N : Node_Type renames Subset_Nodes (Subset_Node);\n@@ -949,7 +956,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n       B : Natural renames Container'Unrestricted_Access.Busy;\n \n-      --  Start of processing for Iterate\n+   --  Start of processing for Iterate\n \n    begin\n       B := B + 1;\n@@ -971,13 +978,15 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n    function Left (Container : Set; Position : Cursor) return Set is\n       Curs : Cursor := Position;\n-      C : Set (Container.Capacity, Container.Modulus) :=\n-        Copy (Container, Container.Capacity);\n+      C    : Set (Container.Capacity, Container.Modulus) :=\n+               Copy (Container, Container.Capacity);\n       Node : Count_Type;\n+\n    begin\n       if Curs = No_Element then\n          return C;\n       end if;\n+\n       if not Has_Element (Container, Curs) then\n          raise Constraint_Error;\n       end if;\n@@ -987,6 +996,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          Delete (C, Curs);\n          Curs := Next (Container, (Node => Node));\n       end loop;\n+\n       return C;\n    end Left;\n \n@@ -1003,12 +1013,13 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    -- Move --\n    ----------\n \n+   --  Comments???\n+\n    procedure Move (Target : in out Set; Source : in out Set) is\n       NN   : HT_Types.Nodes_Type renames Source.Nodes;\n       X, Y : Count_Type;\n \n    begin\n-\n       if Target'Address = Source'Address then\n          return;\n       end if;\n@@ -1079,6 +1090,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    function Overlap (Left, Right : Set) return Boolean is\n       Left_Node  : Count_Type;\n       Left_Nodes : Nodes_Type renames Left.Nodes;\n+\n    begin\n       if Length (Right) = 0 or Length (Left) = 0 then\n          return False;\n@@ -1089,12 +1101,10 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       end if;\n \n       Left_Node := First (Left).Node;\n-\n       while Left_Node /= 0 loop\n          declare\n             N : Node_Type renames Left_Nodes (Left_Node);\n             E : Element_Type renames N.Element;\n-\n          begin\n             if Find (Right, E).Node /= 0 then\n                return True;\n@@ -1125,7 +1135,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       pragma Assert (Vet (Container, Position), \"bad cursor in Query_Element\");\n \n       declare\n-\n          B : Natural renames Container.Busy;\n          L : Natural renames Container.Lock;\n \n@@ -1171,8 +1180,11 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          procedure Read_Element (Node : in out Node_Type);\n          pragma Inline (Read_Element);\n \n-         procedure Allocate is\n-           new Generic_Allocate (Read_Element);\n+         procedure Allocate is new Generic_Allocate (Read_Element);\n+\n+         ------------------\n+         -- Read_Element --\n+         ------------------\n \n          procedure Read_Element (Node : in out Node_Type) is\n          begin\n@@ -1181,16 +1193,16 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n          Node : Count_Type;\n \n-         --  Start of processing for Read_Node\n+      --  Start of processing for Read_Node\n \n       begin\n          Allocate (Container, Node);\n          return Node;\n       end Read_Node;\n \n-      --  Start of processing for Read\n-   begin\n+   --  Start of processing for Read\n \n+   begin\n       Read_Nodes (Stream, Container);\n    end Read;\n \n@@ -1210,11 +1222,9 @@ package body Ada.Containers.Formal_Hashed_Sets is\n      (Container : in out Set;\n       New_Item  : Element_Type)\n    is\n-      Node : constant Count_Type :=\n-        Element_Keys.Find (Container, New_Item);\n+      Node : constant Count_Type := Element_Keys.Find (Container, New_Item);\n \n    begin\n-\n       if Node = 0 then\n          raise Constraint_Error with\n            \"attempt to replace element not in set\";\n@@ -1238,7 +1248,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       New_Item  : Element_Type)\n    is\n    begin\n-\n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with\n            \"Position cursor equals No_Element\";\n@@ -1270,14 +1279,16 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n    function Right (Container : Set; Position : Cursor) return Set is\n       Curs : Cursor := First (Container);\n-      C : Set (Container.Capacity, Container.Modulus) :=\n-        Copy (Container, Container.Capacity);\n+      C    : Set (Container.Capacity, Container.Modulus) :=\n+               Copy (Container, Container.Capacity);\n       Node : Count_Type;\n+\n    begin\n       if Curs = No_Element then\n          Clear (C);\n          return C;\n       end if;\n+\n       if Position /= No_Element and not Has_Element (Container, Position) then\n          raise Constraint_Error;\n       end if;\n@@ -1287,6 +1298,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          Delete (C, Curs);\n          Curs := Next (Container, (Node => Node));\n       end loop;\n+\n       return C;\n    end Right;\n \n@@ -1315,17 +1327,20 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    function Strict_Equal (Left, Right : Set) return Boolean is\n       CuL : Cursor := First (Left);\n       CuR : Cursor := First (Right);\n+\n    begin\n       if Length (Left) /= Length (Right) then\n          return False;\n       end if;\n \n       while CuL.Node /= 0 or CuR.Node /= 0 loop\n-         if CuL.Node /= CuR.Node or else\n-           Left.Nodes (CuL.Node).Element /=\n-           Right.Nodes (CuR.Node).Element then\n+         if CuL.Node /= CuR.Node\n+           or else Left.Nodes (CuL.Node).Element /=\n+                   Right.Nodes (CuR.Node).Element\n+         then\n             return False;\n          end if;\n+\n          CuL := Next (Left, CuL);\n          CuR := Next (Right, CuR);\n       end loop;\n@@ -1344,8 +1359,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       procedure Process (Source_Node : Count_Type);\n       pragma Inline (Process);\n \n-      procedure Iterate is\n-        new HT_Ops.Generic_Iteration (Process);\n+      procedure Iterate is new HT_Ops.Generic_Iteration (Process);\n \n       -------------\n       -- Process --\n@@ -1355,7 +1369,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          N : Node_Type renames Source.Nodes (Source_Node);\n          X : Count_Type;\n          B : Boolean;\n-\n       begin\n          if Is_In (Target, N) then\n             Delete (Target, N.Element);\n@@ -1365,10 +1378,9 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          end if;\n       end Process;\n \n-      --  Start of processing for Symmetric_Difference\n+   --  Start of processing for Symmetric_Difference\n \n    begin\n-\n       if Target'Address = Source'Address then\n          Clear (Target);\n          return;\n@@ -1383,8 +1395,8 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          raise Program_Error with\n            \"attempt to tamper with elements (set is busy)\";\n       end if;\n-      Iterate (Source);\n \n+      Iterate (Source);\n    end Symmetric_Difference;\n \n    function Symmetric_Difference (Left, Right : Set) return Set is\n@@ -1406,6 +1418,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n       C := Length (Left) + Length (Right);\n       H := Default_Modulus (C);\n+\n       return S : Set (C, H) do\n          Difference (Left, Right, S);\n          Difference (Right, Left, S);\n@@ -1523,8 +1536,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n             return False;\n          end if;\n \n-         X := S.Buckets (Element_Keys.Index (S,\n-           N (Position.Node).Element));\n+         X := S.Buckets (Element_Keys.Index (S, N (Position.Node).Element));\n \n          for J in 1 .. S.Length loop\n             if X = Position.Node then\n@@ -1684,7 +1696,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       is\n          X : Count_Type;\n       begin\n-\n          Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n          Free (Container, X);\n       end Exclude;\n@@ -1697,16 +1708,9 @@ package body Ada.Containers.Formal_Hashed_Sets is\n         (Container : Set;\n          Key       : Key_Type) return Cursor\n       is\n-         Node : constant Count_Type :=\n-           Key_Keys.Find (Container, Key);\n-\n+         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n       begin\n-         if Node = 0 then\n-            return No_Element;\n-         end if;\n-\n-         return (Node => Node);\n-\n+         return (if Node = 0 then No_Element else (Node => Node));\n       end Find;\n \n       ---------\n@@ -1720,8 +1724,8 @@ package body Ada.Containers.Formal_Hashed_Sets is\n               \"Position cursor has no element\";\n          end if;\n \n-         pragma Assert (Vet (Container, Position),\n-                        \"bad cursor in function Key\");\n+         pragma Assert\n+           (Vet (Container, Position), \"bad cursor in function Key\");\n \n          declare\n             N  : Node_Type renames Container.Nodes (Position.Node);\n@@ -1739,8 +1743,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          Key       : Key_Type;\n          New_Item  : Element_Type)\n       is\n-         Node : constant Count_Type :=\n-           Key_Keys.Find (Container, Key);\n+         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n \n       begin\n          if Node = 0 then\n@@ -1759,7 +1762,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n         (Container : in out Set;\n          Position  : Cursor;\n          Process   : not null access\n-           procedure (Element : in out Element_Type))\n+                       procedure (Element : in out Element_Type))\n       is\n          Indx : Hash_Type;\n          N    : Nodes_Type renames Container.Nodes;\n@@ -1775,13 +1778,13 @@ package body Ada.Containers.Formal_Hashed_Sets is\n            (Vet (Container, Position),\n             \"bad cursor in Update_Element_Preserving_Key\");\n \n-         --  Record bucket now, in case key is changed.\n+      --  Record bucket now, in case key is changed\n+\n          Indx := HT_Ops.Index (Container.Buckets, N (Position.Node));\n \n          declare\n             E : Element_Type renames N (Position.Node).Element;\n             K : constant Key_Type := Key (E);\n-\n             B : Natural renames Container.Busy;\n             L : Natural renames Container.Lock;\n \n@@ -1807,7 +1810,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n             end if;\n          end;\n \n-         --  Key was modified, so remove this node from set.\n+         --  Key was modified, so remove this node from set\n \n          if Container.Buckets (Indx) = Position.Node then\n             Container.Buckets (Indx) := N (Position.Node).Next;"}, {"sha": "ad6c72fe151c66897b48096e1b29820829f8c529", "filename": "gcc/ada/a-cfhase.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fa-cfhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fa-cfhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.ads?ref=5ffe0bab81981655b009617fc7041a818fee1d89", "patch": "@@ -68,6 +68,7 @@ package Ada.Containers.Formal_Hashed_Sets is\n    pragma Pure;\n \n    type Set (Capacity : Count_Type; Modulus : Hash_Type) is tagged private;\n+   --  why is this commented out ???\n    --  pragma Preelaborable_Initialization (Set);\n \n    type Cursor is private;"}, {"sha": "d102a3d7375ae288259d791300f9d05f8b3924a9", "filename": "gcc/ada/a-cforma.adb", "status": "modified", "additions": 60, "deletions": 82, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fa-cforma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fa-cforma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.adb?ref=5ffe0bab81981655b009617fc7041a818fee1d89", "patch": "@@ -43,8 +43,8 @@ package body Ada.Containers.Formal_Ordered_Maps is\n    --  These subprograms provide a functional interface to access fields\n    --  of a node, and a procedural interface for modifying these values.\n \n-   function Color (Node : Node_Type)\n-                   return Ada.Containers.Red_Black_Trees.Color_Type;\n+   function Color\n+     (Node : Node_Type) return Ada.Containers.Red_Black_Trees.Color_Type;\n    pragma Inline (Color);\n \n    function Left_Son (Node : Node_Type) return Count_Type;\n@@ -74,6 +74,8 @@ package body Ada.Containers.Formal_Ordered_Maps is\n    -- Local Subprograms --\n    -----------------------\n \n+   --  All need comments ???\n+\n    generic\n       with procedure Set_Element (Node : in out Node_Type);\n    procedure Generic_Allocate\n@@ -99,8 +101,8 @@ package body Ada.Containers.Formal_Ordered_Maps is\n    package Tree_Operations is\n      new Red_Black_Trees.Generic_Bounded_Operations\n        (Tree_Types => Tree_Types,\n-        Left      => Left_Son,\n-        Right     => Right_Son);\n+        Left       => Left_Son,\n+        Right      => Right_Son);\n \n    use Tree_Operations;\n \n@@ -117,10 +119,10 @@ package body Ada.Containers.Formal_Ordered_Maps is\n \n    function \"=\" (Left, Right : Map) return Boolean is\n       Lst   : Count_Type;\n-      Node  : Count_Type := First (Left).Node;\n+      Node  : Count_Type;\n       ENode : Count_Type;\n-   begin\n \n+   begin\n       if Length (Left) /= Length (Right) then\n          return False;\n       end if;\n@@ -130,18 +132,21 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       end if;\n \n       Lst := Next (Left, Last (Left).Node);\n+\n+      Node := First (Left).Node;\n       while Node /= Lst loop\n          ENode := Find (Right, Left.Nodes (Node).Key).Node;\n+\n          if ENode = 0 or else\n            Left.Nodes (Node).Element /= Right.Nodes (ENode).Element\n          then\n             return False;\n          end if;\n+\n          Node := Next (Left, Node);\n       end loop;\n \n       return True;\n-\n    end \"=\";\n \n    ------------\n@@ -167,27 +172,24 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          function New_Node return Count_Type;\n          pragma Inline (New_Node);\n \n-         procedure Insert_Post is\n-            new Key_Ops.Generic_Insert_Post (New_Node);\n+         procedure Insert_Post is new Key_Ops.Generic_Insert_Post (New_Node);\n \n          procedure Unconditional_Insert_Sans_Hint is\n-            new Key_Ops.Generic_Unconditional_Insert (Insert_Post);\n+           new Key_Ops.Generic_Unconditional_Insert (Insert_Post);\n \n          procedure Unconditional_Insert_Avec_Hint is\n-            new Key_Ops.Generic_Unconditional_Insert_With_Hint\n-              (Insert_Post,\n-               Unconditional_Insert_Sans_Hint);\n+           new Key_Ops.Generic_Unconditional_Insert_With_Hint\n+             (Insert_Post,\n+              Unconditional_Insert_Sans_Hint);\n \n-         procedure Allocate is\n-            new Generic_Allocate (Set_Element);\n+         procedure Allocate is new Generic_Allocate (Set_Element);\n \n          --------------\n          -- New_Node --\n          --------------\n \n          function New_Node return Count_Type is\n             Result : Count_Type;\n-\n          begin\n             Allocate (Target, Result);\n             return Result;\n@@ -218,7 +220,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n    --  Start of processing for Assign\n \n    begin\n-\n       if Target'Address = Source'Address then\n          return;\n       end if;\n@@ -236,9 +237,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n    -------------\n \n    function Ceiling (Container : Map; Key : Key_Type) return Cursor is\n-\n-      Node : constant Count_Type :=\n-        Key_Ops.Ceiling (Container, Key);\n+      Node : constant Count_Type := Key_Ops.Ceiling (Container, Key);\n \n    begin\n       if Node = 0 then\n@@ -254,7 +253,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n \n    procedure Clear (Container : in out Map) is\n    begin\n-\n       Tree_Operations.Clear_Tree (Container);\n    end Clear;\n \n@@ -283,6 +281,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n    function Copy (Source : Map; Capacity : Count_Type := 0) return Map is\n       Node : Count_Type := 1;\n       N    : Count_Type;\n+\n    begin\n       return Target : Map (Count_Type'Max (Source.Capacity, Capacity)) do\n          if Length (Source) > 0 then\n@@ -325,7 +324,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) is\n    begin\n-\n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with\n            \"Position cursor of Delete has no element\";\n@@ -340,7 +338,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n    end Delete;\n \n    procedure Delete (Container : in out Map; Key : Key_Type) is\n-\n       X : constant Node_Access := Key_Ops.Find (Container, Key);\n \n    begin\n@@ -358,9 +355,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n \n    procedure Delete_First (Container : in out Map) is\n       X : constant Node_Access := First (Container).Node;\n-\n    begin\n-\n       if X /= 0 then\n          Tree_Operations.Delete_Node_Sans_Free (Container, X);\n          Formal_Ordered_Maps.Free (Container, X);\n@@ -373,9 +368,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n \n    procedure Delete_Last (Container : in out Map) is\n       X : constant Node_Access := Last (Container).Node;\n-\n    begin\n-\n       if X /= 0 then\n          Tree_Operations.Delete_Node_Sans_Free (Container, X);\n          Formal_Ordered_Maps.Free (Container, X);\n@@ -432,9 +425,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n \n    procedure Exclude (Container : in out Map; Key : Key_Type) is\n       X : constant Node_Access := Key_Ops.Find (Container, Key);\n-\n    begin\n-\n       if X /= 0 then\n          Tree_Operations.Delete_Node_Sans_Free (Container, X);\n          Formal_Ordered_Maps.Free (Container, X);\n@@ -446,9 +437,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n    ----------\n \n    function Find (Container : Map; Key : Key_Type) return Cursor is\n-\n-      Node : constant Count_Type :=\n-        Key_Ops.Find (Container, Key);\n+      Node : constant Count_Type := Key_Ops.Find (Container, Key);\n \n    begin\n       if Node = 0 then\n@@ -469,7 +458,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       end if;\n \n       return (Node => Container.First);\n-\n    end First;\n \n    -------------------\n@@ -503,9 +491,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n    -----------\n \n    function Floor (Container : Map; Key : Key_Type) return Cursor is\n-\n-      Node : constant Count_Type :=\n-        Key_Ops.Floor (Container, Key);\n+      Node : constant Count_Type := Key_Ops.Floor (Container, Key);\n \n    begin\n       if Node = 0 then\n@@ -536,10 +522,8 @@ package body Ada.Containers.Formal_Ordered_Maps is\n      (Tree : in out Tree_Types.Tree_Type'Class;\n       Node : out Count_Type)\n    is\n-\n       procedure Allocate is\n         new Tree_Operations.Generic_Allocate (Set_Element);\n-\n    begin\n       Allocate (Tree, Node);\n       Tree.Nodes (Node).Has_Element := True;\n@@ -596,6 +580,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       Inserted  : out Boolean)\n    is\n       function New_Node return Node_Access;\n+      --  Comment ???\n \n       procedure Insert_Post is\n         new Key_Ops.Generic_Insert_Post (New_Node);\n@@ -624,7 +609,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          return X;\n       end New_Node;\n \n-      --  Start of processing for Insert\n+   --  Start of processing for Insert\n \n    begin\n       Insert_Sans_Hint\n@@ -676,26 +661,28 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          procedure Initialize (Node : in out Node_Type);\n          procedure Allocate_Node is new Generic_Allocate (Initialize);\n \n+         ----------------\n+         -- Initialize --\n+         ----------------\n+\n          procedure Initialize (Node : in out Node_Type) is\n          begin\n             Node.Key := Key;\n          end Initialize;\n \n          X : Node_Access;\n \n+      --  Start of processing for New_Node\n+\n       begin\n          Allocate_Node (Container, X);\n          return X;\n       end New_Node;\n \n-      --  Start of processing for Insert\n+   --  Start of processing for Insert\n \n    begin\n-      Insert_Sans_Hint\n-        (Container,\n-         Key,\n-         Position.Node,\n-         Inserted);\n+      Insert_Sans_Hint (Container, Key, Position.Node, Inserted);\n    end Insert;\n \n    --------------\n@@ -801,6 +788,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       if Length (Container) = 0 then\n          return No_Element;\n       end if;\n+\n       return (Node => Container.Last);\n    end Last;\n \n@@ -836,13 +824,14 @@ package body Ada.Containers.Formal_Ordered_Maps is\n \n    function Left (Container : Map; Position : Cursor) return Map is\n       Curs : Cursor := Position;\n-      C : Map (Container.Capacity) :=\n-        Copy (Container, Container.Capacity);\n+      C    : Map (Container.Capacity) := Copy (Container, Container.Capacity);\n       Node : Count_Type;\n+\n    begin\n       if Curs = No_Element then\n          return C;\n       end if;\n+\n       if not Has_Element (Container, Curs) then\n          raise Constraint_Error;\n       end if;\n@@ -852,6 +841,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          Delete (C, Curs);\n          Curs := Next (Container, (Node => Node));\n       end loop;\n+\n       return C;\n    end Left;\n \n@@ -882,7 +872,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       X  : Node_Access;\n \n    begin\n-\n       if Target'Address = Source'Address then\n          return;\n       end if;\n@@ -904,7 +893,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          exit when X = 0;\n \n          --  Here we insert a copy of the source element into the target, and\n-         --  then delete the element from the source.  Another possibility is\n+         --  then delete the element from the source. Another possibility is\n          --  that delete it first (and hang onto its index), then insert it.\n          --  ???\n \n@@ -946,20 +935,15 @@ package body Ada.Containers.Formal_Ordered_Maps is\n \n    function Overlap (Left, Right : Map) return Boolean is\n    begin\n-\n       if Length (Left) = 0 or Length (Right) = 0 then\n          return False;\n       end if;\n \n       declare\n-\n-         L_Node : Count_Type := First (Left).Node;\n-         R_Node : Count_Type := First (Right).Node;\n-\n-         L_Last : constant Count_Type :=\n-                    Next (Left, Last (Left).Node);\n-         R_Last : constant Count_Type :=\n-                    Next (Right, Last (Right).Node);\n+         L_Node : Count_Type          := First (Left).Node;\n+         R_Node : Count_Type          := First (Right).Node;\n+         L_Last : constant Count_Type := Next (Left, Last (Left).Node);\n+         R_Last : constant Count_Type := Next (Right, Last (Right).Node);\n \n       begin\n          if Left'Address = Right'Address then\n@@ -973,11 +957,10 @@ package body Ada.Containers.Formal_Ordered_Maps is\n                return False;\n             end if;\n \n-            if Left.Nodes (L_Node).Key\n-              < Right.Nodes (R_Node).Key then\n+            if Left.Nodes (L_Node).Key < Right.Nodes (R_Node).Key then\n                L_Node := Next (Left, L_Node);\n-            elsif Right.Nodes (R_Node).Key\n-              < Left.Nodes (L_Node).Key then\n+\n+            elsif Right.Nodes (R_Node).Key < Left.Nodes (L_Node).Key then\n                R_Node := Next (Right, R_Node);\n \n             else\n@@ -1052,7 +1035,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n                      \"Position cursor of Query_Element is bad\");\n \n       declare\n-\n          B : Natural renames Container.Busy;\n          L : Natural renames Container.Lock;\n \n@@ -1106,9 +1088,9 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          Element_Type'Read (Stream, Node.Element);\n       end Read_Element;\n \n-      --  Start of processing for Read\n-   begin\n+   --  Start of processing for Read\n \n+   begin\n       Read_Elements (Stream, Container);\n    end Read;\n \n@@ -1130,7 +1112,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       New_Item  : Element_Type)\n    is\n    begin\n-\n       declare\n          Node : constant Node_Access := Key_Ops.Find (Container, Key);\n \n@@ -1163,7 +1144,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       New_Item  : Element_Type)\n    is\n    begin\n-\n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with\n            \"Position cursor of Replace_Element has no element\";\n@@ -1186,8 +1166,8 @@ package body Ada.Containers.Formal_Ordered_Maps is\n \n    procedure Reverse_Iterate\n      (Container : Map;\n-      Process   :\n-        not null access procedure (Container : Map; Position : Cursor))\n+      Process   : not null access procedure (Container : Map;\n+                                             Position : Cursor))\n    is\n       procedure Process_Node (Node : Node_Access);\n       pragma Inline (Process_Node);\n@@ -1206,14 +1186,13 @@ package body Ada.Containers.Formal_Ordered_Maps is\n \n       B : Natural renames Container'Unrestricted_Access.Busy;\n \n-      --  Start of processing for Reverse_Iterate\n+   --  Start of processing for Reverse_Iterate\n \n    begin\n       B := B + 1;\n \n       begin\n          Local_Reverse_Iterate (Container);\n-\n       exception\n          when others =>\n             B := B - 1;\n@@ -1229,13 +1208,14 @@ package body Ada.Containers.Formal_Ordered_Maps is\n \n    function Right (Container : Map; Position : Cursor) return Map is\n       Curs : Cursor := First (Container);\n-      C : Map (Container.Capacity) :=\n-        Copy (Container, Container.Capacity);\n+      C    : Map (Container.Capacity) := Copy (Container, Container.Capacity);\n       Node : Count_Type;\n+\n    begin\n       if Curs = No_Element then\n          Clear (C);\n          return C;\n+\n       end if;\n       if Position /= No_Element and not Has_Element (Container, Position) then\n          raise Constraint_Error;\n@@ -1246,6 +1226,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          Delete (C, Curs);\n          Curs := Next (Container, (Node => Node));\n       end loop;\n+\n       return C;\n    end Right;\n \n@@ -1262,10 +1243,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n    -- Set_Color --\n    ---------------\n \n-   procedure Set_Color\n-     (Node  : in out Node_Type;\n-      Color : Color_Type)\n-   is\n+   procedure Set_Color (Node  : in out Node_Type; Color : Color_Type) is\n    begin\n       Node.Color := Color;\n    end Set_Color;\n@@ -1304,6 +1282,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n    function Strict_Equal (Left, Right : Map) return Boolean is\n       LNode : Count_Type := First (Left).Node;\n       RNode : Count_Type := First (Right).Node;\n+\n    begin\n       if Length (Left) /= Length (Right) then\n          return False;\n@@ -1314,15 +1293,16 @@ package body Ada.Containers.Formal_Ordered_Maps is\n             return True;\n          end if;\n \n-         if Left.Nodes (LNode).Element /=\n-           Right.Nodes (RNode).Element or\n-           Left.Nodes (LNode).Key /= Right.Nodes (RNode).Key then\n+         if Left.Nodes (LNode).Element /= Right.Nodes (RNode).Element\n+           or else Left.Nodes (LNode).Key /= Right.Nodes (RNode).Key\n+         then\n             exit;\n          end if;\n \n          LNode := Next (Left, LNode);\n          RNode := Next (Right, RNode);\n       end loop;\n+\n       return False;\n    end Strict_Equal;\n \n@@ -1337,7 +1317,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n                                              Element : in out Element_Type))\n    is\n    begin\n-\n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with\n            \"Position cursor of Update_Element has no element\";\n@@ -1347,7 +1326,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n                      \"Position cursor of Update_Element is bad\");\n \n       declare\n-\n          B : Natural renames Container.Busy;\n          L : Natural renames Container.Lock;\n "}, {"sha": "794b47baf9c8cc2c252755f6d4828011fa1cfb39", "filename": "gcc/ada/a-cforse.adb", "status": "modified", "additions": 82, "deletions": 148, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fa-cforse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fa-cforse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.adb?ref=5ffe0bab81981655b009617fc7041a818fee1d89", "patch": "@@ -77,6 +77,8 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    -- Local Subprograms --\n    -----------------------\n \n+   --  Comments needed???\n+\n    generic\n       with procedure Set_Element (Node : in out Node_Type);\n    procedure Generic_Allocate\n@@ -122,8 +124,8 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    package Tree_Operations is\n      new Red_Black_Trees.Generic_Bounded_Operations\n        (Tree_Types,\n-        Left      => Left_Son,\n-        Right     => Right_Son);\n+        Left  => Left_Son,\n+        Right => Right_Son);\n \n    use Tree_Operations;\n \n@@ -148,10 +150,10 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    function \"=\" (Left, Right : Set) return Boolean is\n       Lst   : Count_Type;\n-      Node  : Count_Type := First (Left).Node;\n+      Node  : Count_Type;\n       ENode : Count_Type;\n-   begin\n \n+   begin\n       if Length (Left) /= Length (Right) then\n          return False;\n       end if;\n@@ -161,18 +163,20 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       end if;\n \n       Lst := Next (Left, Last (Left).Node);\n+\n+      Node := First (Left).Node;\n       while Node /= Lst loop\n          ENode := Find (Right, Left.Nodes (Node).Element).Node;\n-         if ENode = 0 or else\n-           Left.Nodes (Node).Element /= Right.Nodes (ENode).Element\n+         if ENode = 0\n+           or else Left.Nodes (Node).Element /= Right.Nodes (ENode).Element\n          then\n             return False;\n          end if;\n+\n          Node := Next (Left, Node);\n       end loop;\n \n       return True;\n-\n    end \"=\";\n \n    ------------\n@@ -206,19 +210,17 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n          procedure Unconditional_Insert_Avec_Hint is\n            new Element_Keys.Generic_Unconditional_Insert_With_Hint\n-             (Insert_Post,\n-              Unconditional_Insert_Sans_Hint);\n+                 (Insert_Post,\n+                  Unconditional_Insert_Sans_Hint);\n \n-         procedure Allocate is\n-           new Generic_Allocate (Set_Element);\n+         procedure Allocate is new Generic_Allocate (Set_Element);\n \n          --------------\n          -- New_Node --\n          --------------\n \n          function New_Node return Count_Type is\n             Result : Count_Type;\n-\n          begin\n             Allocate (Target, Result);\n             return Result;\n@@ -233,9 +235,11 @@ package body Ada.Containers.Formal_Ordered_Sets is\n             Node.Element := SN.Element;\n          end Set_Element;\n \n+         --  Local variables\n+\n          Target_Node : Count_Type;\n \n-         --  Start of processing for Append_Element\n+      --  Start of processing for Append_Element\n \n       begin\n          Unconditional_Insert_Avec_Hint\n@@ -266,7 +270,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    -------------\n \n    function Ceiling (Container : Set; Item : Element_Type) return Cursor is\n-\n       Node : constant Count_Type := Element_Keys.Ceiling (Container, Item);\n \n    begin\n@@ -275,7 +278,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       end if;\n \n       return (Node => Node);\n-\n    end Ceiling;\n \n    -----------\n@@ -313,17 +315,19 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    ----------\n \n    function Copy (Source : Set; Capacity : Count_Type := 0) return Set is\n-      Node : Count_Type := 1;\n-      N    : Count_Type;\n+      Node   : Count_Type;\n+      N      : Count_Type;\n       Target : Set (Count_Type'Max (Source.Capacity, Capacity));\n+\n    begin\n       if Length (Source) > 0 then\n          Target.Length := Source.Length;\n-         Target.Root := Source.Root;\n-         Target.First := Source.First;\n-         Target.Last := Source.Last;\n-         Target.Free := Source.Free;\n+         Target.Root   := Source.Root;\n+         Target.First  := Source.First;\n+         Target.Last   := Source.Last;\n+         Target.Free   := Source.Free;\n \n+         Node := 1;\n          while Node <= Source.Capacity loop\n             Target.Nodes (Node).Element :=\n               Source.Nodes (Node).Element;\n@@ -346,6 +350,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n             Node := Node + 1;\n          end loop;\n       end if;\n+\n       return Target;\n    end Copy;\n \n@@ -355,7 +360,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    procedure Delete (Container : in out Set; Position : in out Cursor) is\n    begin\n-\n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n@@ -373,7 +377,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       X : constant Count_Type := Element_Keys.Find (Container, Item);\n \n    begin\n-\n       if X = 0 then\n          raise Constraint_Error with \"attempt to delete element not in set\";\n       end if;\n@@ -388,9 +391,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    procedure Delete_First (Container : in out Set) is\n       X    : constant Count_Type := Container.First;\n-\n    begin\n-\n       if X /= 0 then\n          Tree_Operations.Delete_Node_Sans_Free (Container, X);\n          Formal_Ordered_Sets.Free (Container, X);\n@@ -403,9 +404,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    procedure Delete_Last (Container : in out Set) is\n       X    : constant Count_Type := Container.Last;\n-\n    begin\n-\n       if X /= 0 then\n          Tree_Operations.Delete_Node_Sans_Free (Container, X);\n          Formal_Ordered_Sets.Free (Container, X);\n@@ -419,7 +418,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    procedure Difference (Target : in out Set; Source : Set) is\n    begin\n       Set_Ops.Set_Difference (Target, Source);\n-\n    end Difference;\n \n    function Difference (Left, Right : Set) return Set is\n@@ -437,9 +435,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       end if;\n \n       return S : Set (Length (Left)) do\n-            Assign (S,\n-                    Set_Ops.Set_Difference (Left, Right));\n-\n+            Assign (S, Set_Ops.Set_Difference (Left, Right));\n       end return;\n    end Difference;\n \n@@ -484,7 +480,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    function Equivalent_Sets (Left, Right : Set) return Boolean is\n       function Is_Equivalent_Node_Node\n-        (L, R        : Node_Type) return Boolean;\n+        (L, R : Node_Type) return Boolean;\n       pragma Inline (Is_Equivalent_Node_Node);\n \n       function Is_Equivalent is\n@@ -505,7 +501,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          end if;\n       end Is_Equivalent_Node_Node;\n \n-      --  Start of processing for Equivalent_Sets\n+   --  Start of processing for Equivalent_Sets\n \n    begin\n       return Is_Equivalent (Left, Right);\n@@ -517,9 +513,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    procedure Exclude (Container : in out Set; Item : Element_Type) is\n       X : constant Count_Type := Element_Keys.Find (Container, Item);\n-\n    begin\n-\n       if X /= 0 then\n          Tree_Operations.Delete_Node_Sans_Free (Container, X);\n          Formal_Ordered_Sets.Free (Container, X);\n@@ -531,17 +525,14 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    ----------\n \n    function Find (Container : Set; Item : Element_Type) return Cursor is\n-\n-      Node : constant Count_Type :=\n-        Element_Keys.Find (Container, Item);\n+      Node : constant Count_Type := Element_Keys.Find (Container, Item);\n \n    begin\n       if Node = 0 then\n          return No_Element;\n       end if;\n \n       return (Node => Node);\n-\n    end Find;\n \n    -----------\n@@ -555,7 +546,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       end if;\n \n       return (Node => Container.First);\n-\n    end First;\n \n    -------------------\n@@ -582,10 +572,8 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    function Floor (Container : Set; Item : Element_Type) return Cursor is\n    begin\n-\n       declare\n-         Node : constant Count_Type :=\n-           Element_Keys.Floor (Container, Item);\n+         Node : constant Count_Type := Element_Keys.Floor (Container, Item);\n \n       begin\n          if Node = 0 then\n@@ -600,10 +588,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    -- Free --\n    ----------\n \n-   procedure Free\n-     (Tree : in out Set;\n-      X  : Count_Type)\n-   is\n+   procedure Free (Tree : in out Set; X : Count_Type) is\n    begin\n       Tree.Nodes (X).Has_Element := False;\n       Tree_Operations.Free (Tree, X);\n@@ -617,10 +602,8 @@ package body Ada.Containers.Formal_Ordered_Sets is\n      (Tree : in out Tree_Types.Tree_Type'Class;\n       Node : out Count_Type)\n    is\n-\n       procedure Allocate is\n         new Tree_Operations.Generic_Allocate (Set_Element);\n-\n    begin\n       Allocate (Tree, Node);\n       Tree.Nodes (Node).Has_Element := True;\n@@ -662,8 +645,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       -------------\n \n       function Ceiling (Container : Set; Key : Key_Type) return Cursor is\n-         Node : constant Count_Type :=\n-           Key_Keys.Ceiling (Container, Key);\n+         Node : constant Count_Type := Key_Keys.Ceiling (Container, Key);\n \n       begin\n          if Node = 0 then\n@@ -687,7 +669,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       ------------\n \n       procedure Delete (Container : in out Set; Key : Key_Type) is\n-\n          X : constant Count_Type := Key_Keys.Find (Container, Key);\n \n       begin\n@@ -704,8 +685,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       -------------\n \n       function Element (Container : Set; Key : Key_Type) return Element_Type is\n-         Node : constant Count_Type :=\n-           Key_Keys.Find (Container, Key);\n+         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n \n       begin\n          if Node = 0 then\n@@ -739,9 +719,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       -------------\n \n       procedure Exclude (Container : in out Set; Key : Key_Type) is\n-\n          X : constant Count_Type := Key_Keys.Find (Container, Key);\n-\n       begin\n          if X /= 0 then\n             Delete_Node_Sans_Free (Container, X);\n@@ -754,33 +732,19 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       ----------\n \n       function Find (Container : Set; Key : Key_Type) return Cursor is\n-\n          Node : constant Count_Type := Key_Keys.Find (Container, Key);\n-\n       begin\n-         if Node = 0 then\n-            return No_Element;\n-         end if;\n-\n-         return (Node => Node);\n+         return (if Node = 0 then No_Element else (Node => Node));\n       end Find;\n \n       -----------\n       -- Floor --\n       -----------\n \n       function Floor (Container : Set; Key : Key_Type) return Cursor is\n-\n-         Node : constant Count_Type :=\n-           Key_Keys.Floor (Container, Key);\n-\n+         Node : constant Count_Type := Key_Keys.Floor (Container, Key);\n       begin\n-         if Node = 0 then\n-            return No_Element;\n-         end if;\n-\n-         return (Node => Node);\n-\n+         return (if Node = 0 then No_Element else (Node => Node));\n       end Floor;\n \n       -------------------------\n@@ -838,15 +802,13 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          New_Item  : Element_Type)\n       is\n          Node : constant Count_Type := Key_Keys.Find (Container, Key);\n-\n       begin\n-\n          if not Has_Element (Container, (Node => Node)) then\n             raise Constraint_Error with\n               \"attempt to replace key not in set\";\n+         else\n+            Replace_Element (Container, Node, New_Item);\n          end if;\n-\n-         Replace_Element (Container, Node, New_Item);\n       end Replace;\n \n       -----------------------------------\n@@ -859,7 +821,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          Process   : not null access procedure (Element : in out Element_Type))\n       is\n       begin\n-\n          if not Has_Element (Container, Position) then\n             raise Constraint_Error with\n               \"Position cursor has no element\";\n@@ -918,9 +879,9 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    begin\n       if Position.Node = 0 then\n          return False;\n+      else\n+         return Container.Nodes (Position.Node).Has_Element;\n       end if;\n-\n-      return Container.Nodes (Position.Node).Has_Element;\n    end Has_Element;\n \n    -------------\n@@ -959,13 +920,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       Inserted  : out Boolean)\n    is\n    begin\n-\n-      Insert_Sans_Hint\n-        (Container,\n-         New_Item,\n-         Position.Node,\n-         Inserted);\n-\n+      Insert_Sans_Hint (Container, New_Item, Position.Node, Inserted);\n    end Insert;\n \n    procedure Insert\n@@ -994,7 +949,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       Node      : out Count_Type;\n       Inserted  : out Boolean)\n    is\n-\n       procedure Set_Element (Node : in out Node_Type);\n \n       function New_Node return Count_Type;\n@@ -1006,16 +960,14 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       procedure Conditional_Insert_Sans_Hint is\n         new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n \n-      procedure Allocate is\n-        new Generic_Allocate (Set_Element);\n+      procedure Allocate is new Generic_Allocate (Set_Element);\n \n       --------------\n       -- New_Node --\n       --------------\n \n       function New_Node return Count_Type is\n          Result : Count_Type;\n-\n       begin\n          Allocate (Container, Result);\n          return Result;\n@@ -1030,7 +982,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          Node.Element := New_Item;\n       end Set_Element;\n \n-      --  Start of processing for Insert_Sans_Hint\n+   --  Start of processing for Insert_Sans_Hint\n \n    begin\n       Conditional_Insert_Sans_Hint\n@@ -1066,19 +1018,16 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n       procedure Local_Insert_With_Hint is\n         new Element_Keys.Generic_Conditional_Insert_With_Hint\n-          (Insert_Post,\n-           Insert_Sans_Hint);\n+              (Insert_Post, Insert_Sans_Hint);\n \n-      procedure Allocate is\n-        new Generic_Allocate (Set_Element);\n+      procedure Allocate is new Generic_Allocate (Set_Element);\n \n       --------------\n       -- New_Node --\n       --------------\n \n       function New_Node return Count_Type is\n          Result : Count_Type;\n-\n       begin\n          Allocate (Dst_Set, Result);\n          return Result;\n@@ -1093,7 +1042,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          Node.Element := Src_Node.Element;\n       end Set_Element;\n \n-      --  Start of processing for Insert_With_Hint\n+   --  Start of processing for Insert_With_Hint\n \n    begin\n       Local_Insert_With_Hint\n@@ -1120,8 +1069,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       end if;\n \n       return S : Set (Count_Type'Min (Length (Left), Length (Right))) do\n-            Assign (S, Set_Ops.Set_Intersection\n-                    (Left, Right));\n+            Assign (S, Set_Ops.Set_Intersection (Left, Right));\n       end return;\n    end Intersection;\n \n@@ -1175,8 +1123,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean is\n    begin\n-      return Set_Ops.Set_Subset (Subset,\n-                                 Of_Set => Of_Set);\n+      return Set_Ops.Set_Subset (Subset, Of_Set => Of_Set);\n    end Is_Subset;\n \n    -------------\n@@ -1185,8 +1132,8 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    procedure Iterate\n      (Container : Set;\n-      Process   :\n-      not null access procedure (Container : Set; Position : Cursor))\n+      Process   : not null access procedure (Container : Set;\n+                                             Position : Cursor))\n    is\n       procedure Process_Node (Node : Count_Type);\n       pragma Inline (Process_Node);\n@@ -1203,9 +1150,11 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          Process (Container, (Node => Node));\n       end Process_Node;\n \n+      --  Local variables\n+\n       B : Natural renames Container'Unrestricted_Access.Busy;\n \n-      --  Start of prccessing for Iterate\n+   --  Start of prccessing for Iterate\n \n    begin\n       B := B + 1;\n@@ -1227,12 +1176,9 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    function Last (Container : Set) return Cursor is\n    begin\n-      if Length (Container) = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Container.Last);\n-\n+      return (if Length (Container) = 0\n+              then No_Element\n+              else (Node => Container.Last));\n    end Last;\n \n    ------------------\n@@ -1258,13 +1204,14 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    function Left (Container : Set; Position : Cursor) return Set is\n       Curs : Cursor := Position;\n-      C : Set (Container.Capacity) :=\n-        Copy (Container, Container.Capacity);\n+      C    : Set (Container.Capacity) := Copy (Container, Container.Capacity);\n       Node : Count_Type;\n+\n    begin\n       if Curs = No_Element then\n          return C;\n       end if;\n+\n       if not Has_Element (Container, Curs) then\n          raise Constraint_Error;\n       end if;\n@@ -1274,6 +1221,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          Delete (C, Curs);\n          Curs := Next (Container, (Node => Node));\n       end loop;\n+\n       return C;\n    end Left;\n \n@@ -1304,7 +1252,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       X : Count_Type;\n \n    begin\n-\n       if Target'Address = Source'Address then\n          return;\n       end if;\n@@ -1363,7 +1310,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    function Overlap (Left, Right : Set) return Boolean is\n    begin\n       return Set_Ops.Set_Overlap (Left, Right);\n-\n    end Overlap;\n \n    ------------\n@@ -1394,14 +1340,9 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n       declare\n          Node : constant Count_Type :=\n-           Tree_Operations.Previous (Container, Position.Node);\n-\n+                  Tree_Operations.Previous (Container, Position.Node);\n       begin\n-         if Node = 0 then\n-            return No_Element;\n-         end if;\n-\n-         return (Node => Node);\n+         return (if Node = 0 then No_Element else (Node => Node));\n       end;\n    end Previous;\n \n@@ -1420,7 +1361,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       Process   : not null access procedure (Element : Element_Type))\n    is\n    begin\n-\n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n@@ -1429,7 +1369,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n                      \"bad cursor in Query_Element\");\n \n       declare\n-\n          B : Natural renames Container.Busy;\n          L : Natural renames Container.Lock;\n \n@@ -1477,9 +1416,9 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          Element_Type'Read (Stream, Node.Element);\n       end Read_Element;\n \n-      --  Start of processing for Read\n-   begin\n+   --  Start of processing for Read\n \n+   begin\n       Read_Elements (Stream, Container);\n    end Read;\n \n@@ -1496,9 +1435,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    -------------\n \n    procedure Replace (Container : in out Set; New_Item : Element_Type) is\n-\n-      Node : constant Count_Type :=\n-        Element_Keys.Find (Container, New_Item);\n+      Node : constant Count_Type := Element_Keys.Find (Container, New_Item);\n \n    begin\n       if Node = 0 then\n@@ -1547,22 +1484,20 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n       function New_Node return Count_Type is\n          N  : Node_Type renames NN (Node);\n-\n       begin\n          N.Element := Item;\n-         N.Color := Red;\n-         N.Parent := 0;\n-         N.Right := 0;\n-         N.Left := 0;\n-\n+         N.Color   := Red;\n+         N.Parent  := 0;\n+         N.Right   := 0;\n+         N.Left    := 0;\n          return Node;\n       end New_Node;\n \n       Hint      : Count_Type;\n       Result    : Count_Type;\n       Inserted  : Boolean;\n \n-      --  Start of processing for Insert\n+   --  Start of processing for Insert\n \n    begin\n       if Item < NN (Node).Element\n@@ -1620,7 +1555,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       New_Item  : Element_Type)\n    is\n    begin\n-\n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n@@ -1638,8 +1572,8 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    procedure Reverse_Iterate\n      (Container : Set;\n-      Process   :\n-      not null access procedure (Container : Set; Position : Cursor))\n+      Process   : not null access procedure (Container : Set;\n+                                             Position : Cursor))\n    is\n       procedure Process_Node (Node : Count_Type);\n       pragma Inline (Process_Node);\n@@ -1658,7 +1592,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n       B : Natural renames Container'Unrestricted_Access.Busy;\n \n-      --  Start of processing for Reverse_Iterate\n+   --  Start of processing for Reverse_Iterate\n \n    begin\n       B := B + 1;\n@@ -1680,14 +1614,15 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    function Right (Container : Set; Position : Cursor) return Set is\n       Curs : Cursor := First (Container);\n-      C : Set (Container.Capacity) :=\n-        Copy (Container, Container.Capacity);\n+      C    : Set (Container.Capacity) := Copy (Container, Container.Capacity);\n       Node : Count_Type;\n+\n    begin\n       if Curs = No_Element then\n          Clear (C);\n          return C;\n       end if;\n+\n       if Position /= No_Element and not Has_Element (Container, Position) then\n          raise Constraint_Error;\n       end if;\n@@ -1697,6 +1632,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          Delete (C, Curs);\n          Curs := Next (Container, (Node => Node));\n       end loop;\n+\n       return C;\n    end Right;\n \n@@ -1755,6 +1691,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    function Strict_Equal (Left, Right : Set) return Boolean is\n       LNode : Count_Type := First (Left).Node;\n       RNode : Count_Type := First (Right).Node;\n+\n    begin\n       if Length (Left) /= Length (Right) then\n          return False;\n@@ -1773,8 +1710,8 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          LNode := Next (Left, LNode);\n          RNode := Next (Right, RNode);\n       end loop;\n-      return False;\n \n+      return False;\n    end Strict_Equal;\n \n    --------------------------\n@@ -1801,9 +1738,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       end if;\n \n       return S : Set (Length (Left) + Length (Right)) do\n-            Assign (S,\n-              Set_Ops.Set_Symmetric_Difference (Left,\n-                Right));\n+         Assign (S, Set_Ops.Set_Symmetric_Difference (Left, Right));\n       end return;\n    end Symmetric_Difference;\n \n@@ -1814,7 +1749,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    function To_Set (New_Item : Element_Type) return Set is\n       Node     : Count_Type;\n       Inserted : Boolean;\n-\n    begin\n       return S : Set (Capacity => 1) do\n          Insert_Sans_Hint (S, New_Item, Node, Inserted);\n@@ -1879,7 +1813,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          Element_Type'Write (Stream, Node.Element);\n       end Write_Element;\n \n-      --  Start of processing for Write\n+   --  Start of processing for Write\n \n    begin\n       Write_Elements (Stream, Container);"}, {"sha": "03203cdbd7b61c9dbb784422dc89d8fe157fab91", "filename": "gcc/ada/a-cforse.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fa-cforse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fa-cforse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.ads?ref=5ffe0bab81981655b009617fc7041a818fee1d89", "patch": "@@ -67,6 +67,7 @@ package Ada.Containers.Formal_Ordered_Sets is\n    function Equivalent_Elements (Left, Right : Element_Type) return Boolean;\n \n    type Set (Capacity : Count_Type) is tagged private;\n+   --  why is this commented out ???\n    --  pragma Preelaborable_Initialization (Set);\n \n    type Cursor is private;\n@@ -276,7 +277,7 @@ private\n      new Red_Black_Trees.Generic_Bounded_Tree_Types (Node_Type);\n \n    type Set (Capacity : Count_Type) is\n-      new Tree_Types.Tree_Type (Capacity) with null record;\n+     new Tree_Types.Tree_Type (Capacity) with null record;\n \n    use Red_Black_Trees;\n    use Ada.Streams;"}, {"sha": "3b72130cbe8b5e40b8bd9add1058c9a0d2a207a3", "filename": "gcc/ada/a-except-2005.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fa-except-2005.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fa-except-2005.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except-2005.adb?ref=5ffe0bab81981655b009617fc7041a818fee1d89", "patch": "@@ -895,9 +895,11 @@ package body Ada.Exceptions is\n             Prefix             : constant String := \"adjust/finalize raised \";\n             Orig_Msg           : constant String := Exception_Message (X);\n             Orig_Prefix_Length : constant Natural :=\n-              Integer'Min (Prefix'Length, Orig_Msg'Length);\n+                                   Integer'Min\n+                                     (Prefix'Length, Orig_Msg'Length);\n             Orig_Prefix        : String renames Orig_Msg\n-              (Orig_Msg'First .. Orig_Msg'First + Orig_Prefix_Length - 1);\n+                                   (Orig_Msg'First ..\n+                                    Orig_Msg'First + Orig_Prefix_Length - 1);\n \n          begin\n             --  Message already has the proper prefix, just re-raise"}, {"sha": "9030d0008686402b504bb293e222adf06f5c844a", "filename": "gcc/ada/alfa.adb", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Falfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Falfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Falfa.adb?ref=5ffe0bab81981655b009617fc7041a818fee1d89", "patch": "@@ -23,8 +23,10 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Atree;    use Atree;\n with Output;   use Output;\n with Put_ALFA;\n+with Sinfo;    use Sinfo;\n \n package body ALFA is\n \n@@ -153,6 +155,74 @@ package body ALFA is\n       ALFA_Xref_Table.Init;\n    end Initialize_ALFA_Tables;\n \n+   -------------------------\n+   -- Get_Entity_For_Decl --\n+   -------------------------\n+\n+   function Get_Entity_For_Decl (N : Node_Id) return Entity_Id is\n+      E : Entity_Id := Empty;\n+\n+   begin\n+      case Nkind (N) is\n+         when N_Subprogram_Declaration |\n+              N_Subprogram_Body        |\n+              N_Package_Declaration    =>\n+            E := Defining_Unit_Name (Specification (N));\n+\n+         when N_Package_Body =>\n+            E := Defining_Unit_Name (N);\n+\n+         when N_Object_Declaration =>\n+            E := Defining_Identifier (N);\n+\n+         when others =>\n+            null;\n+      end case;\n+\n+      if Nkind (E) = N_Defining_Program_Unit_Name then\n+         E := Defining_Identifier (E);\n+      end if;\n+\n+      return E;\n+   end Get_Entity_For_Decl;\n+\n+   --------------------------------\n+   -- Get_Unique_Entity_For_Decl --\n+   --------------------------------\n+\n+   function Get_Unique_Entity_For_Decl (N : Node_Id) return Entity_Id is\n+      E : Entity_Id := Empty;\n+\n+   begin\n+      case Nkind (N) is\n+         when N_Subprogram_Declaration |\n+              N_Package_Declaration    =>\n+            E := Defining_Unit_Name (Specification (N));\n+\n+         when N_Package_Body =>\n+            E := Corresponding_Spec (N);\n+\n+         when N_Subprogram_Body =>\n+            if Acts_As_Spec (N) then\n+               E := Defining_Unit_Name (Specification (N));\n+            else\n+               E := Corresponding_Spec (N);\n+            end if;\n+\n+         when N_Object_Declaration =>\n+            E := Defining_Identifier (N);\n+\n+         when others =>\n+            null;\n+      end case;\n+\n+      if Nkind (E) = N_Defining_Program_Unit_Name then\n+         E := Defining_Identifier (E);\n+      end if;\n+\n+      return E;\n+   end Get_Unique_Entity_For_Decl;\n+\n    -----------\n    -- palfa --\n    -----------"}, {"sha": "1813a795fdfdd9ac43d0c0a2a3fa179ecb407293", "filename": "gcc/ada/alfa.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Falfa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Falfa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Falfa.ads?ref=5ffe0bab81981655b009617fc7041a818fee1d89", "patch": "@@ -323,6 +323,13 @@ package ALFA is\n    procedure Initialize_ALFA_Tables;\n    --  Reset tables for a new compilation\n \n+   function Get_Entity_For_Decl (N : Node_Id) return Entity_Id;\n+   --  Return the entity for declaration N\n+\n+   function Get_Unique_Entity_For_Decl (N : Node_Id) return Entity_Id;\n+   --  Return the entity which represents declaration N, so that matching\n+   --  declaration and body have the same entity.\n+\n    procedure palfa;\n    --  Debugging procedure to output contents of ALFA binary tables in the\n    --  format in which they appear in an ALI file."}, {"sha": "e1b63f03d7729674b93a660634659467364fba70", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=5ffe0bab81981655b009617fc7041a818fee1d89", "patch": "@@ -521,7 +521,7 @@ package body Einfo is\n \n    --    Body_Is_In_ALFA                 Flag251\n    --    Is_Processed_Transient          Flag252\n-   --    (unused)                        Flag253\n+   --    Is_Postcondition_Proc           Flag253\n    --    (unused)                        Flag254\n \n    -----------------------\n@@ -1976,6 +1976,12 @@ package body Einfo is\n       return Flag138 (Id);\n    end Is_Packed_Array_Type;\n \n+   function Is_Postcondition_Proc (Id : E) return B is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Procedure);\n+      return Flag253 (Id);\n+   end Is_Postcondition_Proc;\n+\n    function Is_Potentially_Use_Visible (Id : E) return B is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -4494,6 +4500,12 @@ package body Einfo is\n       Set_Flag138 (Id, V);\n    end Set_Is_Packed_Array_Type;\n \n+   procedure Set_Is_Postcondition_Proc (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Procedure);\n+      Set_Flag253 (Id, V);\n+   end Set_Is_Postcondition_Proc;\n+\n    procedure Set_Is_Potentially_Use_Visible (Id : E; V : B := True) is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -7563,6 +7575,7 @@ package body Einfo is\n       W (\"Is_Package_Body_Entity\",          Flag160 (Id));\n       W (\"Is_Packed\",                       Flag51  (Id));\n       W (\"Is_Packed_Array_Type\",            Flag138 (Id));\n+      W (\"Is_Postcondition_Proc\",           Flag253 (Id));\n       W (\"Is_Potentially_Use_Visible\",      Flag9   (Id));\n       W (\"Is_Preelaborated\",                Flag59  (Id));\n       W (\"Is_Primitive\",                    Flag218 (Id));"}, {"sha": "0bc2e386cd1023710dd78f3dc5742ed5f96c55ed", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=5ffe0bab81981655b009617fc7041a818fee1d89", "patch": "@@ -2563,6 +2563,10 @@ package Einfo is\n --       an entity, then the Original_Array_Type field of this entity points\n --       to the original array type for which this is the packed array type.\n \n+--    Is_Postcondition_Proc (Flag253)\n+--       Present in procedures. Set if entity is a procedure generated by the\n+--       compiler for a postcondition.\n+\n --    Is_Potentially_Use_Visible (Flag9)\n --       Present in all entities. Set if entity is potentially use visible,\n --       i.e. it is defined in a package that appears in a currently active\n@@ -5521,6 +5525,7 @@ package Einfo is\n    --    Is_Intrinsic_Subprogram             (Flag64)\n    --    Is_Machine_Code_Subprogram          (Flag137)  (non-generic case only)\n    --    Is_Null_Init_Proc                   (Flag178)\n+   --    Is_Postcondition_Proc               (Flag253)  (non-generic case only)\n    --    Is_Primitive                        (Flag218)\n    --    Is_Primitive_Wrapper                (Flag195)  (non-generic case only)\n    --    Is_Private_Descendant               (Flag53)\n@@ -6213,6 +6218,7 @@ package Einfo is\n    function Is_Package_Body_Entity              (Id : E) return B;\n    function Is_Packed                           (Id : E) return B;\n    function Is_Packed_Array_Type                (Id : E) return B;\n+   function Is_Postcondition_Proc               (Id : E) return B;\n    function Is_Potentially_Use_Visible          (Id : E) return B;\n    function Is_Preelaborated                    (Id : E) return B;\n    function Is_Primitive                        (Id : E) return B;\n@@ -6807,6 +6813,7 @@ package Einfo is\n    procedure Set_Is_Package_Body_Entity          (Id : E; V : B := True);\n    procedure Set_Is_Packed                       (Id : E; V : B := True);\n    procedure Set_Is_Packed_Array_Type            (Id : E; V : B := True);\n+   procedure Set_Is_Postcondition_Proc           (Id : E; V : B := True);\n    procedure Set_Is_Potentially_Use_Visible      (Id : E; V : B := True);\n    procedure Set_Is_Preelaborated                (Id : E; V : B := True);\n    procedure Set_Is_Primitive                    (Id : E; V : B := True);\n@@ -7535,6 +7542,7 @@ package Einfo is\n    pragma Inline (Is_Overloadable);\n    pragma Inline (Is_Packed);\n    pragma Inline (Is_Packed_Array_Type);\n+   pragma Inline (Is_Postcondition_Proc);\n    pragma Inline (Is_Potentially_Use_Visible);\n    pragma Inline (Is_Preelaborated);\n    pragma Inline (Is_Primitive);\n@@ -7946,6 +7954,7 @@ package Einfo is\n    pragma Inline (Set_Is_Package_Body_Entity);\n    pragma Inline (Set_Is_Packed);\n    pragma Inline (Set_Is_Packed_Array_Type);\n+   pragma Inline (Set_Is_Postcondition_Proc);\n    pragma Inline (Set_Is_Potentially_Use_Visible);\n    pragma Inline (Set_Is_Preelaborated);\n    pragma Inline (Set_Is_Primitive);"}, {"sha": "7ee46b300b044f2aeb2776ba67c8e2a4c0fd457d", "filename": "gcc/ada/get_scos.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fget_scos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fget_scos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_scos.adb?ref=5ffe0bab81981655b009617fc7041a818fee1d89", "patch": "@@ -307,7 +307,7 @@ begin\n \n          --  Decision entry\n \n-         when 'I' | 'E' | 'P' | 'W' | 'X' =>\n+         when 'I' | 'E' | 'G' | 'P' | 'W' | 'X' =>\n             Dtyp := C;\n             Skip_Spaces;\n "}, {"sha": "67076f509289138af1f997fc1a5506d38e0e37e3", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 87, "deletions": 58, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=5ffe0bab81981655b009617fc7041a818fee1d89", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2009-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2009-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -126,7 +126,8 @@ package body Par_SCO is\n    procedure Traverse_Handled_Statement_Sequence  (N : Node_Id);\n    procedure Traverse_Package_Body                (N : Node_Id);\n    procedure Traverse_Package_Declaration         (N : Node_Id);\n-   procedure Traverse_Subprogram_Body             (N : Node_Id);\n+   procedure Traverse_Protected_Body              (N : Node_Id);\n+   procedure Traverse_Subprogram_Or_Task_Body     (N : Node_Id);\n    procedure Traverse_Subprogram_Declaration      (N : Node_Id);\n    --  Traverse the corresponding construct, generating SCO table entries\n \n@@ -439,62 +440,57 @@ package body Par_SCO is\n       -------------------\n \n       procedure Output_Header (T : Character) is\n+         Loc   : Source_Ptr := No_Location;\n+         --  Node whose sloc is used for the decision\n+\n       begin\n          case T is\n             when 'I' | 'E' | 'W' =>\n \n                --  For IF, EXIT, WHILE, the token SLOC can be found from\n                --  the SLOC of the parent of the expression.\n \n-               Set_Table_Entry\n-                 (C1   => T,\n-                  C2   => ' ',\n-                  From => Sloc (Parent (N)),\n-                  To   => No_Location,\n-                  Last => False);\n+               Loc := Sloc (Parent (N));\n \n-            when 'P' =>\n+            when 'G' | 'P' =>\n \n+               --  For entry, the token sloc is from the N_Entry_Body.\n                --  For PRAGMA, we must get the location from the pragma node.\n                --  Argument N is the pragma argument, and we have to go up two\n                --  levels (through the pragma argument association) to get to\n                --  the pragma node itself.\n \n-               declare\n-                  Loc : constant Source_Ptr := Sloc (Parent (Parent (N)));\n-\n-               begin\n-                  Set_Table_Entry\n-                    (C1   => 'P',\n-                     C2   => 'd',\n-                     From => Loc,\n-                     To   => No_Location,\n-                     Last => False);\n-\n-                  --  For pragmas we also must make an entry in the hash table\n-                  --  for later access by Set_SCO_Pragma_Enabled. We set the\n-                  --  pragma as disabled above, the call will change C2 to 'e'\n-                  --  to enable the pragma header entry.\n-\n-                  Condition_Pragma_Hash_Table.Set (Loc, SCO_Table.Last);\n-               end;\n+               Loc := Sloc (Parent (Parent (N)));\n \n             when 'X' =>\n \n                --  For an expression, no Sloc\n \n-               Set_Table_Entry\n-                 (C1   => 'X',\n-                  C2   => ' ',\n-                  From => No_Location,\n-                  To   => No_Location,\n-                  Last => False);\n+               null;\n \n             --  No other possibilities\n \n             when others =>\n                raise Program_Error;\n          end case;\n+\n+         Set_Table_Entry\n+           (C1   => T,\n+            C2   => ' ',\n+            From => Loc,\n+            To   => No_Location,\n+            Last => False);\n+\n+         if T = 'P' then\n+            --  For pragmas we also must make an entry in the hash table\n+            --  for later access by Set_SCO_Pragma_Enabled. We set the\n+            --  pragma as disabled now, the call will change C2 to 'e'\n+            --  to enable the pragma header entry.\n+\n+            SCO_Table.Table (SCO_Table.Last).C2 := 'd';\n+            Condition_Pragma_Hash_Table.Set (Loc, SCO_Table.Last);\n+         end if;\n+\n       end Output_Header;\n \n       ------------------------------\n@@ -773,30 +769,34 @@ package body Par_SCO is\n \n       --  Traverse the unit\n \n-      if Nkind (Lu) = N_Subprogram_Body then\n-         Traverse_Subprogram_Body (Lu);\n+      case Nkind (Lu) is\n+         when N_Protected_Body =>\n+            Traverse_Protected_Body (Lu);\n \n-      elsif Nkind (Lu) = N_Subprogram_Declaration then\n-         Traverse_Subprogram_Declaration (Lu);\n+         when N_Subprogram_Body | N_Task_Body =>\n+            Traverse_Subprogram_Or_Task_Body (Lu);\n \n-      elsif Nkind (Lu) = N_Package_Declaration then\n-         Traverse_Package_Declaration (Lu);\n+         when N_Subprogram_Declaration =>\n+            Traverse_Subprogram_Declaration (Lu);\n \n-      elsif Nkind (Lu) = N_Package_Body then\n-         Traverse_Package_Body (Lu);\n+         when N_Package_Declaration =>\n+            Traverse_Package_Declaration (Lu);\n \n-      elsif Nkind (Lu) = N_Generic_Package_Declaration then\n-         Traverse_Generic_Package_Declaration (Lu);\n+         when N_Package_Body =>\n+            Traverse_Package_Body (Lu);\n \n-      elsif Nkind (Lu) in N_Generic_Instantiation then\n-         Traverse_Generic_Instantiation (Lu);\n+         when N_Generic_Package_Declaration =>\n+            Traverse_Generic_Package_Declaration (Lu);\n \n-      --  All other cases of compilation units (e.g. renamings), generate\n-      --  no SCO information.\n+         when N_Generic_Instantiation =>\n+            Traverse_Generic_Instantiation (Lu);\n \n-      else\n-         null;\n-      end if;\n+         when others =>\n+            --  All other cases of compilation units (e.g. renamings), generate\n+            --  no SCO information.\n+\n+            null;\n+      end case;\n \n       --  Make entry for new unit in unit tables, we will fill in the file\n       --  name and dependency numbers later.\n@@ -1144,11 +1144,31 @@ package body Par_SCO is\n                     (Parameter_Specifications (Specification (N)), 'X');\n                   Set_Statement_Entry;\n \n-               --  Subprogram_Body\n+               --  Task or subprogram body\n+\n+               when N_Task_Body | N_Subprogram_Body =>\n+                  Set_Statement_Entry;\n+                  Traverse_Subprogram_Or_Task_Body (N);\n+\n+               --  Entry body\n+\n+               when N_Entry_Body =>\n+                  declare\n+                     Cond : constant Node_Id :=\n+                              Condition (Entry_Body_Formal_Part (N));\n+                  begin\n+                     Set_Statement_Entry;\n+                     if Present (Cond) then\n+                        Process_Decisions_Defer (Cond, 'G');\n+                     end if;\n+                     Traverse_Subprogram_Or_Task_Body (N);\n+                  end;\n+\n+               --  Protected body\n \n-               when N_Subprogram_Body =>\n+               when N_Protected_Body =>\n                   Set_Statement_Entry;\n-                  Traverse_Subprogram_Body (N);\n+                  Traverse_Protected_Body (N);\n \n                --  Exit statement, which is an exit statement in the SCO sense,\n                --  so it is included in the current statement sequence, but\n@@ -1485,15 +1505,24 @@ package body Par_SCO is\n       Traverse_Declarations_Or_Statements (Private_Declarations (Spec));\n    end Traverse_Package_Declaration;\n \n-   ------------------------------\n-   -- Traverse_Subprogram_Body --\n-   ------------------------------\n+   -----------------------------\n+   -- Traverse_Protected_Body --\n+   -----------------------------\n+\n+   procedure Traverse_Protected_Body (N : Node_Id) is\n+   begin\n+      Traverse_Declarations_Or_Statements (Declarations (N));\n+   end Traverse_Protected_Body;\n+\n+   --------------------------------------\n+   -- Traverse_Subprogram_Or_Task_Body --\n+   --------------------------------------\n \n-   procedure Traverse_Subprogram_Body (N : Node_Id) is\n+   procedure Traverse_Subprogram_Or_Task_Body (N : Node_Id) is\n    begin\n       Traverse_Declarations_Or_Statements (Declarations (N));\n       Traverse_Handled_Statement_Sequence (Handled_Statement_Sequence (N));\n-   end Traverse_Subprogram_Body;\n+   end Traverse_Subprogram_Or_Task_Body;\n \n    -------------------------------------\n    -- Traverse_Subprogram_Declaration --"}, {"sha": "6154abb6dce2e6849c26ef578ac74957445919e0", "filename": "gcc/ada/put_scos.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fput_scos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fput_scos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_scos.adb?ref=5ffe0bab81981655b009617fc7041a818fee1d89", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n---                             P U T _ S C O S                               --\n+--                             P U T _ S C O S                              --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2009, Free Software Foundation, Inc.           --\n+--          Copyright (C) 2009-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -142,7 +142,7 @@ begin\n \n                   --  Decision\n \n-                  when 'I' | 'E' | 'P' | 'W' | 'X' =>\n+                  when 'I' | 'E' | 'G' | 'P' | 'W' | 'X' =>\n                      Start := Start + 1;\n \n                      --  For disabled pragma, skip decision output"}, {"sha": "ea16370fc2c3d53d5344cd251757b172df7219f1", "filename": "gcc/ada/scos.ads", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fscos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fscos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscos.ads?ref=5ffe0bab81981655b009617fc7041a818fee1d89", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2009-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2009-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -228,12 +228,13 @@ package SCOs is\n \n    --      I  decision in IF statement or conditional expression\n    --      E  decision in EXIT WHEN statement\n+   --      G  decision in entry guard\n    --      P  decision in pragma Assert/Check/Pre_Condition/Post_Condition\n    --      W  decision in WHILE iteration scheme\n    --      X  decision appearing in some other expression context\n \n-   --    For I, E, P, W, sloc is the source location of the IF, EXIT, PRAGMA or\n-   --    WHILE token.\n+   --    For I, E, G, P, W, sloc is the source location of the IF, EXIT,\n+   --    ENTRY, PRAGMA or WHILE token, respectively\n \n    --    For X, sloc is omitted\n "}, {"sha": "ebc1c71da186f3434d23256f8f90d604263b67d8", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffe0bab81981655b009617fc7041a818fee1d89/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=5ffe0bab81981655b009617fc7041a818fee1d89", "patch": "@@ -9550,6 +9550,9 @@ package body Sem_Ch6 is\n                   Make_Handled_Sequence_Of_Statements (Loc,\n                     Statements => Plist)));\n \n+            Set_Ekind (Post_Proc, E_Procedure);\n+            Set_Is_Postcondition_Proc (Post_Proc);\n+\n             --  If this is a procedure, set the Postcondition_Proc attribute on\n             --  the proper defining entity for the subprogram.\n "}]}