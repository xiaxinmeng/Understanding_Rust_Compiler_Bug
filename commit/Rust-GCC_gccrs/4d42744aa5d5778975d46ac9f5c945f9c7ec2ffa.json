{"sha": "4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa", "node_id": "C_kwDOANBUbNoAKDRkNDI3NDRhYTVkNTc3ODk3NWQ0NmFjOWY1Yzk0NWY5YzdlYzJmZmE", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-10-25T09:24:10Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-10-26T07:58:05Z"}, "message": "intrinsics: Add early implementation for atomic_store_{seqcst, relaxed, release}\n\nThis commit adds support for three `atomic_store_*` intrinsics declared\nin the core library. The mapping is as follows:\n\n- atomic_store_seqcst(dst, val) -> __atomic_store_n(dst, val,\n  __ATOMIC_SEQ_CST)\n- atomic_store_release(dst, val) -> __atomic_store_n(dst, val,\n  __ATOMIC_RELEASE)\n- atomic_store_relaxed(dst, val) -> __atomic_store_n(dst, val,\n  __ATOMIC_RELAXED)\n- atomic_store_unordered(dst, val) -> __atomic_store_n(dst, val,\n  __ATOMIC_RELAXED)\n\nThis commit also performs the overloading \"by hand\": Replacing\n`atomic_store_release<i32>` with `__atomic_store_4` as I cannot get the\ngeneric version to work. This will be done in future improvements.\nBecause of this, size type atomics are not handled and result in a call\nto `rust_sorry_at`.\n\nCo-authored-by: bjorn3 <bjorn3@github.com>\nCo-authored-by: dafaust <dafaust@github.com>", "tree": {"sha": "2ff9ff65e2f5155b0b344f9e75fff884344e9ffe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ff9ff65e2f5155b0b344f9e75fff884344e9ffe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83e5265d6af48e1572cbe019b4b7f7a5603086a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83e5265d6af48e1572cbe019b4b7f7a5603086a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83e5265d6af48e1572cbe019b4b7f7a5603086a9"}], "stats": {"total": 290, "additions": 268, "deletions": 22}, "files": [{"sha": "64e06e1a24094816a06dd57ccfc9675ee85ca769", "filename": "gcc/rust/backend/rust-builtins.cc", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa/gcc%2Frust%2Fbackend%2Frust-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa/gcc%2Frust%2Fbackend%2Frust-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-builtins.cc?ref=4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa", "patch": "@@ -68,11 +68,47 @@ BuiltinsContext::setup_math_fns ()\n \t\t  math_function_type_f32, builtin_const);\n }\n \n+void\n+BuiltinsContext::setup_atomic_fns ()\n+{\n+  define_builtin (\"atomic_store\", BUILT_IN_ATOMIC_STORE, \"__atomic_store\", NULL,\n+\t\t  build_function_type_list (void_type_node, size_type_node,\n+\t\t\t\t\t    build_pointer_type (void_type_node),\n+\t\t\t\t\t    const_ptr_type_node,\n+\t\t\t\t\t    integer_type_node, NULL_TREE),\n+\t\t  0);\n+  define_builtin (\"atomic_store_n\", BUILT_IN_ATOMIC_STORE_N, \"__atomic_store_n\",\n+\t\t  NULL,\n+\t\t  build_varargs_function_type_list (void_type_node, NULL_TREE),\n+\t\t  0);\n+  define_builtin (\"atomic_store_1\", BUILT_IN_ATOMIC_STORE_1, \"__atomic_store_1\",\n+\t\t  NULL,\n+\t\t  build_varargs_function_type_list (void_type_node, NULL_TREE),\n+\t\t  0);\n+  define_builtin (\"atomic_store_2\", BUILT_IN_ATOMIC_STORE_2, \"__atomic_store_2\",\n+\t\t  NULL,\n+\t\t  build_varargs_function_type_list (void_type_node, NULL_TREE),\n+\t\t  0);\n+  define_builtin (\"atomic_store_4\", BUILT_IN_ATOMIC_STORE_4, \"__atomic_store_4\",\n+\t\t  NULL,\n+\t\t  build_varargs_function_type_list (void_type_node, NULL_TREE),\n+\t\t  0);\n+  define_builtin (\"atomic_store_8\", BUILT_IN_ATOMIC_STORE_8, \"__atomic_store_8\",\n+\t\t  NULL,\n+\t\t  build_varargs_function_type_list (void_type_node, NULL_TREE),\n+\t\t  0);\n+  define_builtin (\"atomic_store_16\", BUILT_IN_ATOMIC_STORE_16,\n+\t\t  \"__atomic_store_16\", NULL,\n+\t\t  build_varargs_function_type_list (void_type_node, NULL_TREE),\n+\t\t  0);\n+}\n+\n void\n BuiltinsContext::setup ()\n {\n   setup_math_fns ();\n   setup_overflow_fns ();\n+  setup_atomic_fns ();\n \n   define_builtin (\"unreachable\", BUILT_IN_UNREACHABLE, \"__builtin_unreachable\",\n \t\t  NULL, build_function_type (void_type_node, void_list_node),"}, {"sha": "c2825107faff2317a40b696c3477b62139475f26", "filename": "gcc/rust/backend/rust-builtins.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa/gcc%2Frust%2Fbackend%2Frust-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa/gcc%2Frust%2Fbackend%2Frust-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-builtins.h?ref=4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa", "patch": "@@ -86,8 +86,8 @@ class BuiltinsContext\n   BuiltinsContext ();\n \n   void setup_overflow_fns ();\n-\n   void setup_math_fns ();\n+  void setup_atomic_fns ();\n \n   void setup ();\n "}, {"sha": "7c592dabb38568d4202fd527c1aa5ff98067e65d", "filename": "gcc/rust/backend/rust-compile-intrinsic.cc", "status": "modified", "additions": 144, "deletions": 21, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc?ref=4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa", "patch": "@@ -93,6 +93,17 @@ prefetch_write_data (Context *ctx, TyTy::FnType *fntype)\n   return prefetch_data_handler (ctx, fntype, Prefetch::Write);\n }\n \n+static tree\n+atomic_store_handler_inner (Context *ctx, TyTy::FnType *fntype, int ordering);\n+\n+static inline std::function<tree (Context *, TyTy::FnType *)>\n+atomic_store_handler (int ordering)\n+{\n+  return [ordering] (Context *ctx, TyTy::FnType *fntype) {\n+    return atomic_store_handler_inner (ctx, fntype, ordering);\n+  };\n+}\n+\n static inline tree\n sorry_handler (Context *ctx, TyTy::FnType *fntype)\n {\n@@ -105,18 +116,22 @@ sorry_handler (Context *ctx, TyTy::FnType *fntype)\n static const std::map<std::string,\n \t\t      std::function<tree (Context *, TyTy::FnType *)>>\n   generic_intrinsics = {\n-    {\"offset\", &offset_handler},\n-    {\"size_of\", &sizeof_handler},\n-    {\"transmute\", &transmute_handler},\n-    {\"rotate_left\", &rotate_left_handler},\n-    {\"rotate_right\", &rotate_right_handler},\n-    {\"wrapping_add\", &wrapping_add_handler},\n-    {\"wrapping_sub\", &wrapping_sub_handler},\n-    {\"wrapping_mul\", &wrapping_mul_handler},\n-    {\"copy_nonoverlapping\", &copy_nonoverlapping_handler},\n-    {\"prefetch_read_data\", &prefetch_read_data},\n-    {\"prefetch_write_data\", &prefetch_write_data},\n-    {\"atomic_load\", &sorry_handler},\n+    {\"offset\", offset_handler},\n+    {\"size_of\", sizeof_handler},\n+    {\"transmute\", transmute_handler},\n+    {\"rotate_left\", rotate_left_handler},\n+    {\"rotate_right\", rotate_right_handler},\n+    {\"wrapping_add\", wrapping_add_handler},\n+    {\"wrapping_sub\", wrapping_sub_handler},\n+    {\"wrapping_mul\", wrapping_mul_handler},\n+    {\"copy_nonoverlapping\", copy_nonoverlapping_handler},\n+    {\"prefetch_read_data\", prefetch_read_data},\n+    {\"prefetch_write_data\", prefetch_write_data},\n+    {\"atomic_load\", sorry_handler},\n+    {\"atomic_store_seqcst\", atomic_store_handler (__ATOMIC_SEQ_CST)},\n+    {\"atomic_store_release\", atomic_store_handler (__ATOMIC_RELEASE)},\n+    {\"atomic_store_relaxed\", atomic_store_handler (__ATOMIC_RELAXED)},\n+    {\"atomic_store_unordered\", atomic_store_handler (__ATOMIC_RELAXED)},\n };\n \n Intrinsics::Intrinsics (Context *ctx) : ctx (ctx) {}\n@@ -551,6 +566,16 @@ copy_nonoverlapping_handler (Context *ctx, TyTy::FnType *fntype)\n   return fndecl;\n }\n \n+static tree\n+make_unsigned_long_tree (Context *ctx, unsigned long value)\n+{\n+  mpz_t mpz_value;\n+  mpz_init_set_ui (mpz_value, value);\n+\n+  return ctx->get_backend ()->integer_constant_expression (integer_type_node,\n+\t\t\t\t\t\t\t   mpz_value);\n+}\n+\n static tree\n prefetch_data_handler (Context *ctx, TyTy::FnType *fntype, Prefetch kind)\n {\n@@ -576,16 +601,8 @@ prefetch_data_handler (Context *ctx, TyTy::FnType *fntype, Prefetch kind)\n \n   auto addr = ctx->get_backend ()->var_expression (args[0], Location ());\n   auto locality = ctx->get_backend ()->var_expression (args[1], Location ());\n+  auto rw_flag = make_unsigned_long_tree (ctx, kind == Prefetch::Write ? 1 : 0);\n \n-  mpz_t zero;\n-  mpz_t one;\n-  mpz_init_set_ui (zero, 0);\n-  mpz_init_set_ui (one, 1);\n-\n-  auto rw_flag_value = kind == Prefetch::Write ? one : zero;\n-  auto rw_flag\n-    = ctx->get_backend ()->integer_constant_expression (integer_type_node,\n-\t\t\t\t\t\t\trw_flag_value);\n   auto prefetch_raw = NULL_TREE;\n   auto ok\n     = BuiltinsContext::get ().lookup_simple_builtin (\"prefetch\", &prefetch_raw);\n@@ -597,12 +614,118 @@ prefetch_data_handler (Context *ctx, TyTy::FnType *fntype, Prefetch kind)\n     = ctx->get_backend ()->call_expression (prefetch, {addr, rw_flag, locality},\n \t\t\t\t\t    nullptr, Location ());\n \n+  TREE_READONLY (prefetch_call) = 0;\n+  TREE_SIDE_EFFECTS (prefetch_call) = 1;\n+\n   ctx->add_statement (prefetch_call);\n \n   finalize_intrinsic_block (ctx, fndecl);\n \n   return fndecl;\n }\n \n+static std::string\n+build_atomic_builtin_name (Location locus, tree operand_type)\n+{\n+  static const std::map<std::string, std::string> allowed_types = {\n+    {\"i8\", \"1\"},    {\"i16\", \"2\"},   {\"i32\", \"4\"},   {\"i64\", \"8\"},\n+    {\"i128\", \"16\"}, {\"isize\", \"8\"}, {\"u8\", \"1\"},    {\"u16\", \"2\"},\n+    {\"u32\", \"4\"},   {\"u64\", \"8\"},   {\"u128\", \"16\"}, {\"usize\", \"8\"},\n+  };\n+\n+  // TODO: Can we maybe get the generic version (atomic_store_n) to work... This\n+  // would be so much better\n+\n+  std::string result = \"atomic_store_\";\n+\n+  auto type_name = std::string (TYPE_NAME_STRING (operand_type));\n+  if (type_name == \"usize\" || type_name == \"isize\")\n+    {\n+      rust_sorry_at (\n+\tlocus, \"atomics are not yet available for size types (usize, isize)\");\n+      return \"\";\n+    }\n+\n+  // FIXME: Can we have a better looking name here?\n+  // Instead of `<crate>::<module>::<type>`?\n+  // Maybe instead of giving the tree node, pass the resolved Tyty before it\n+  // gets compiled?\n+  //\n+  // Or should we perform this check somwhere else in the compiler?\n+  auto type_size_str = allowed_types.find (type_name);\n+  if (type_size_str == allowed_types.end ())\n+    {\n+      rust_error_at (locus,\n+\t\t     \"atomic intrinsics are only available for basic integer \"\n+\t\t     \"types: got type %qs\",\n+\t\t     type_name.c_str ());\n+      return \"\";\n+    }\n+\n+  result += type_size_str->second;\n+\n+  return result;\n+}\n+\n+static tree\n+atomic_store_handler_inner (Context *ctx, TyTy::FnType *fntype, int ordering)\n+{\n+  rust_assert (fntype->get_params ().size () == 2);\n+  rust_assert (fntype->get_num_substitutions () == 1);\n+\n+  tree lookup = NULL_TREE;\n+  if (check_for_cached_intrinsic (ctx, fntype, &lookup))\n+    return lookup;\n+\n+  auto fndecl = compile_intrinsic_function (ctx, fntype);\n+\n+  // Most intrinsic functions are pure but not the atomic ones\n+  TREE_READONLY (fndecl) = 0;\n+  TREE_SIDE_EFFECTS (fndecl) = 1;\n+\n+  // setup the params\n+  std::vector<Bvariable *> param_vars;\n+  std::vector<tree> types;\n+  compile_fn_params (ctx, fntype, fndecl, &param_vars, &types);\n+\n+  auto ok = ctx->get_backend ()->function_set_parameters (fndecl, param_vars);\n+  rust_assert (ok);\n+\n+  enter_intrinsic_block (ctx, fndecl);\n+\n+  auto dst = ctx->get_backend ()->var_expression (param_vars[0], Location ());\n+  TREE_READONLY (dst) = 0;\n+\n+  auto value = ctx->get_backend ()->var_expression (param_vars[1], Location ());\n+  auto memorder = make_unsigned_long_tree (ctx, ordering);\n+\n+  auto builtin_name\n+    = build_atomic_builtin_name (fntype->get_locus (), TREE_TYPE (types[0]));\n+  if (builtin_name.empty ())\n+    return error_mark_node;\n+\n+  tree atomic_store_raw = nullptr;\n+  BuiltinsContext::get ().lookup_simple_builtin (builtin_name,\n+\t\t\t\t\t\t &atomic_store_raw);\n+  rust_assert (atomic_store_raw);\n+\n+  auto atomic_store\n+    = build_fold_addr_expr_loc (Location ().gcc_location (), atomic_store_raw);\n+\n+  auto store_call\n+    = ctx->get_backend ()->call_expression (atomic_store,\n+\t\t\t\t\t    {dst, value, memorder}, nullptr,\n+\t\t\t\t\t    Location ());\n+\n+  TREE_READONLY (store_call) = 0;\n+  TREE_SIDE_EFFECTS (store_call) = 1;\n+\n+  ctx->add_statement (store_call);\n+\n+  finalize_intrinsic_block (ctx, fndecl);\n+\n+  return fndecl;\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "243d4460089fd6276fb005c1a711c4d24186eedf", "filename": "gcc/testsuite/rust/compile/torture/intrinsics-4.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-4.rs?ref=4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa", "patch": "@@ -0,0 +1,20 @@\n+trait Copy {}\n+\n+extern \"rust-intrinsic\" {\n+    pub fn atomic_store_seqcst<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_release<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_relaxed<T: Copy>(dst: *mut T, val: T);\n+    // pub fn atomic_store_unordered<T: Copy>(dst: *mut T, val: T);\n+}\n+\n+fn main() {\n+    let mut dst = 15;\n+    let new_value = 14;\n+\n+    unsafe {\n+        atomic_store_seqcst(&mut dst, new_value);\n+        atomic_store_release(&mut dst, new_value);\n+        atomic_store_relaxed(&mut dst, new_value);\n+        // atomic_store_unordered(&mut dst, new_value);\n+    }\n+}"}, {"sha": "e0087720cc4fd25ecf59d00227be99db652ed32d", "filename": "gcc/testsuite/rust/compile/torture/intrinsics-5.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-5.rs?ref=4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa", "patch": "@@ -0,0 +1,35 @@\n+trait Copy {}\n+\n+extern \"rust-intrinsic\" {\n+    pub fn atomic_store_seqcst<T: Copy>(dst: *mut T, value: T);\n+    // { dg-error \"atomic intrinsics are only available for basic integer types: got type .intrinsics_5::VeryLargeType.\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"atomic intrinsics are only available for basic integer types: got type .bool.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+struct VeryLargeType {\n+    a0: i128,\n+    a1: i128,\n+    a2: i128,\n+    a3: i128,\n+}\n+\n+impl VeryLargeType {\n+    pub fn new(value: i128) -> VeryLargeType {\n+        VeryLargeType {\n+            a0: value,\n+            a1: 0,\n+            a2: 0,\n+            a3: 0,\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let mut dst = VeryLargeType::new(0);\n+    let mut b = false;\n+\n+    unsafe {\n+        atomic_store_seqcst(&mut dst, VeryLargeType::new(1));\n+        atomic_store_seqcst(&mut b, true);\n+    }\n+}"}, {"sha": "9f248b4f823f5175600da5922650d4dea266f0ee", "filename": "gcc/testsuite/rust/execute/torture/atomic_store.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fatomic_store.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fatomic_store.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fatomic_store.rs?ref=4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa", "patch": "@@ -0,0 +1,32 @@\n+trait Copy {}\n+\n+extern \"rust-intrinsic\" {\n+    pub fn atomic_store_seqcst<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_release<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_relaxed<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_unordered<T: Copy>(dst: *mut T, val: T);\n+}\n+\n+fn main() -> i32 {\n+    let mut dst = 15;\n+    let one;\n+    let two;\n+    let three;\n+    let four;\n+\n+    unsafe {\n+        atomic_store_seqcst(&mut dst, 1);\n+        one = dst;\n+\n+        atomic_store_release(&mut dst, 2);\n+        two = dst;\n+\n+        atomic_store_relaxed(&mut dst, 3);\n+        three = dst;\n+\n+        atomic_store_unordered(&mut dst, 4);\n+        four = dst;\n+    }\n+\n+    (four + three + two + one) - 10\n+}"}]}