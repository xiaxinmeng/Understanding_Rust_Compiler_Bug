{"sha": "29a5298955f777c539c628f51e78b75d8e586c44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlhNTI5ODk1NWY3NzdjNTM5YzYyOGY1MWU3OGI3NWQ4ZTU4NmM0NA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2021-02-23T19:29:04Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2021-02-23T19:29:04Z"}, "message": "Fortran: Fix for class defined operators [PR99124].\n\n2021-02-23  Paul Thomas  <pault@gcc.gnu.org>\n\ngcc/fortran\n\tPR fortran/99124\n\t* resolve.c (resolve_fl_procedure): Include class results in\n\tthe test for F2018, C15100.\n\t* trans-array.c (get_class_info_from_ss): Do not use the saved\n\tdescriptor to obtain the class expression for variables. Use\n\tgfc_get_class_from_expr instead.\n\ngcc/testsuite/\n\tPR fortran/99124\n\t* gfortran.dg/class_defined_operator_2.f03 : New test.\n\t* gfortran.dg/elemental_result_2.f90 : New test.\n\t* gfortran.dg/class_assign_4.f90: Correct the non-conforming\n\telemental function with an allocatable result with an operator\n\tinterface with array dummies and result.", "tree": {"sha": "547cb45715e524c698d1a53c1cf0bebe5a4c53eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/547cb45715e524c698d1a53c1cf0bebe5a4c53eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29a5298955f777c539c628f51e78b75d8e586c44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29a5298955f777c539c628f51e78b75d8e586c44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29a5298955f777c539c628f51e78b75d8e586c44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29a5298955f777c539c628f51e78b75d8e586c44/comments", "author": null, "committer": null, "parents": [{"sha": "a6c7e0fcffc857e67dffdd7609be663cc3aac7d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6c7e0fcffc857e67dffdd7609be663cc3aac7d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6c7e0fcffc857e67dffdd7609be663cc3aac7d2"}], "stats": {"total": 94, "additions": 86, "deletions": 8}, "files": [{"sha": "2a91ae743eaa4dcca8f293b87bc2ce1ef4c7fa58", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a5298955f777c539c628f51e78b75d8e586c44/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a5298955f777c539c628f51e78b75d8e586c44/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=29a5298955f777c539c628f51e78b75d8e586c44", "patch": "@@ -13051,6 +13051,7 @@ static bool\n resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n {\n   gfc_formal_arglist *arg;\n+  bool allocatable_or_pointer;\n \n   if (sym->attr.function\n       && !resolve_fl_var_and_proc (sym, mp_flag))\n@@ -13235,8 +13236,16 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n   /* F2018, C15100: \"The result of an elemental function shall be scalar,\n      and shall not have the POINTER or ALLOCATABLE attribute.\"  The scalar\n      pointer is tested and caught elsewhere.  */\n+  if (sym->result)\n+    allocatable_or_pointer = sym->result->ts.type == BT_CLASS\n+\t\t\t     && CLASS_DATA (sym->result) ?\n+\t\t\t     (CLASS_DATA (sym->result)->attr.allocatable\n+\t\t\t      || CLASS_DATA (sym->result)->attr.pointer) :\n+\t\t\t     (sym->result->attr.allocatable\n+\t\t\t      || sym->result->attr.pointer);\n+\n   if (sym->attr.elemental && sym->result\n-      && (sym->result->attr.allocatable || sym->result->attr.pointer))\n+      && allocatable_or_pointer)\n     {\n       gfc_error (\"Function result variable %qs at %L of elemental \"\n \t\t \"function %qs shall not have an ALLOCATABLE or POINTER \""}, {"sha": "c672565909353ddf21ab823c0a97926d3c16ef1d", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a5298955f777c539c628f51e78b75d8e586c44/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a5298955f777c539c628f51e78b75d8e586c44/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=29a5298955f777c539c628f51e78b75d8e586c44", "patch": "@@ -1167,8 +1167,11 @@ get_class_info_from_ss (stmtblock_t * pre, gfc_ss *ss, tree *eltype)\n       && rhs_ss->info->expr->ts.type == BT_CLASS\n       && rhs_ss->info->data.array.descriptor)\n     {\n-      rhs_class_expr\n-\t= gfc_get_class_from_expr (rhs_ss->info->data.array.descriptor);\n+      if (rhs_ss->info->expr->expr_type != EXPR_VARIABLE)\n+\trhs_class_expr\n+\t  = gfc_get_class_from_expr (rhs_ss->info->data.array.descriptor);\n+      else\n+\trhs_class_expr = gfc_get_class_from_gfc_expr (rhs_ss->info->expr);\n       unlimited_rhs = UNLIMITED_POLY (rhs_ss->info->expr);\n       if (rhs_ss->info->expr->expr_type == EXPR_FUNCTION)\n \trhs_function = true;"}, {"sha": "2a77d8111b57f8adc698f8bf337119eda22bb5cf", "filename": "gcc/testsuite/gfortran.dg/class_assign_4.f90", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a5298955f777c539c628f51e78b75d8e586c44/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_assign_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a5298955f777c539c628f51e78b75d8e586c44/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_assign_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_assign_4.f90?ref=29a5298955f777c539c628f51e78b75d8e586c44", "patch": "@@ -11,17 +11,19 @@ module m\n   type :: t1\n     integer :: i\n   CONTAINS\n-    PROCEDURE :: add_t1\n-    GENERIC :: OPERATOR(+) => add_t1\n   end type\n   type, extends(t1) :: t2\n     real :: r\n   end type\n \n+  interface operator(+)\n+    module procedure add_t1\n+  end interface\n+\n contains\n-  impure elemental function add_t1 (a, b) result (c)\n-    class(t1), intent(in) :: a, b\n-    class(t1), allocatable :: c\n+  function add_t1 (a, b) result (c)\n+    class(t1), intent(in) :: a(:), b(:)\n+    class(t1), allocatable :: c(:)\n     allocate (c, source = a)\n     c%i = a%i + b%i\n     select type (c)"}, {"sha": "b7d53b84e2a201fd36f3c51843e5f124738841f1", "filename": "gcc/testsuite/gfortran.dg/class_defined_operator_2.f03", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a5298955f777c539c628f51e78b75d8e586c44/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_defined_operator_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a5298955f777c539c628f51e78b75d8e586c44/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_defined_operator_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_defined_operator_2.f03?ref=29a5298955f777c539c628f51e78b75d8e586c44", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR99124 which used to ICE as shown.\n+!\n+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>\n+!\n+module m\n+   type t\n+      integer :: i\n+   contains\n+      procedure :: f\n+      generic :: operator(+) => f\n+   end type\n+contains\n+   elemental function f(a, b) result(c)\n+      class(t), intent(in) :: a, b\n+      type(t) :: c\n+      c = t(a%i + b%i)\n+   end\n+end\n+program p\n+   use m\n+   class(t), allocatable :: x(:), y(:), z\n+   allocate (x, source = [t(1), t(2)])\n+   allocate (y, source = [t(1), t(2)])\n+   x = x(2) + y                               ! ICE\n+   if (any (x%i .ne. [3, 4])) stop 1\n+   z = x(1)\n+   x = z + y                                  ! ICE\n+   if (any (x%i .ne. [4, 5])) stop 2\n+end"}, {"sha": "490c2ef68de0ef6159eee6531b3d54f456c5192d", "filename": "gcc/testsuite/gfortran.dg/elemental_result_2.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a5298955f777c539c628f51e78b75d8e586c44/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_result_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a5298955f777c539c628f51e78b75d8e586c44/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_result_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_result_2.f90?ref=29a5298955f777c539c628f51e78b75d8e586c44", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do compile }\n+!\n+! Test part of the fix for PR99124 which adds errors for class results\n+! That violate F2018, C15100.\n+!\n+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>\n+!\n+module m\n+   type t\n+      integer :: i\n+   contains\n+      procedure :: f\n+      generic :: operator(+) => f\n+   end type\n+contains\n+   elemental function f(a, b) &\n+   result(c)                     ! { dg-error \"shall not have an ALLOCATABLE or POINTER attribute\" }\n+      class(t), intent(in) :: a, b\n+      class(t), allocatable :: c\n+      c = t(a%i + b%i)\n+   end\n+   elemental function g(a, b) &\n+   result(c)                     ! { dg-error \"shall not have an ALLOCATABLE or POINTER attribute\" }\n+      class(t), intent(in) :: a, b\n+      class(t), pointer :: c\n+      c => null ()\n+   end\n+   elemental function h(a, b) &  ! { dg-error \"must have a scalar result\" }\n+   result(c)                     ! { dg-error \"must be dummy, allocatable or pointer\" }\n+      class(t), intent(in) :: a, b\n+      class(t) :: c(2)\n+   end\n+end"}]}