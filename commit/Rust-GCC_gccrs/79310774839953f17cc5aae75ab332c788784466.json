{"sha": "79310774839953f17cc5aae75ab332c788784466", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzkzMTA3NzQ4Mzk5NTNmMTdjYzVhYWU3NWFiMzMyYzc4ODc4NDQ2Ng==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2017-09-29T18:17:47Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-09-29T18:17:47Z"}, "message": "c-ada-spec.c (max_ada_macros): Move around.\n\n\t* c-ada-spec.c (max_ada_macros): Move around.\n\t(store_ada_macro_index): Likewise.\n\t(source_file): Rename into...\n\t(macro_source_file): ...this.\n\t(count_ada_macro): Move around.\n\t(store_ada_macro): Likewise.\n\t(compare_macro): Likewise.\n\t(print_ada_macros): Merge in...\n\t(dump_ada_macros): ...this.\n\t(source_file_base): Rename into...\n\t(current_source_file): ...this.\n\t(print_comment): Move around.\n\t(dump_ada_nodes): Call dump_ada_declaration directly.\n\t(struct with): Change type of limited field to bool.\n\t(append_withs): Change type of limited_access parameter to bool.\n\t(pp_ada_tree_identifie): Likewise.\n\t(dump_ada_decl_nam): Likewise.\n\t(dump_generic_ada_node): Likewise.  Do not print the return type.\n\t(to_ada_name): Change type of space_found parameter to bool.\n\t(dump_ada_function_declaration): Return void and change type of\n\tparameters to bool.  Also print the return type for a function.\n\t(print_ada_methods): Rename into...\n\t(dump_ada_methods): ...this.\n\t(print_ada_declaration): Rename into ...\n\t(dump_ada_declaration): ...this.  Do not print the return type.\n\t(print_ada_struct_decl): Rename into...\n\t(dump_ada_struct_decl): ...this.\n\nFrom-SVN: r253304", "tree": {"sha": "4c755d99378b2e1d37b165d606269914ca37d8a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c755d99378b2e1d37b165d606269914ca37d8a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79310774839953f17cc5aae75ab332c788784466", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79310774839953f17cc5aae75ab332c788784466", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79310774839953f17cc5aae75ab332c788784466", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79310774839953f17cc5aae75ab332c788784466/comments", "author": null, "committer": null, "parents": [{"sha": "249be95c772d6487b48a0d1cd2a459762cff4f9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/249be95c772d6487b48a0d1cd2a459762cff4f9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/249be95c772d6487b48a0d1cd2a459762cff4f9b"}], "stats": {"total": 487, "additions": 226, "deletions": 261}, "files": [{"sha": "e15e6647453a50227318c6571a5edf3a4562b351", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79310774839953f17cc5aae75ab332c788784466/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79310774839953f17cc5aae75ab332c788784466/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=79310774839953f17cc5aae75ab332c788784466", "patch": "@@ -1,3 +1,33 @@\n+2017-09-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* c-ada-spec.c (max_ada_macros): Move around.\n+\t(store_ada_macro_index): Likewise.\n+\t(source_file): Rename into...\n+\t(macro_source_file): ...this.\n+\t(count_ada_macro): Move around.\n+\t(store_ada_macro): Likewise.\n+\t(compare_macro): Likewise.\n+\t(print_ada_macros): Merge in...\n+\t(dump_ada_macros): ...this.\n+\t(source_file_base): Rename into...\n+\t(current_source_file): ...this.\n+\t(print_comment): Move around.\n+\t(dump_ada_nodes): Call dump_ada_declaration directly.\n+\t(struct with): Change type of limited field to bool.\n+\t(append_withs): Change type of limited_access parameter to bool.\n+\t(pp_ada_tree_identifie): Likewise.\n+\t(dump_ada_decl_nam): Likewise.\n+\t(dump_generic_ada_node): Likewise.  Do not print the return type.\n+\t(to_ada_name): Change type of space_found parameter to bool.\n+\t(dump_ada_function_declaration): Return void and change type of\n+\tparameters to bool.  Also print the return type for a function.\n+\t(print_ada_methods): Rename into...\n+\t(dump_ada_methods): ...this.\n+\t(print_ada_declaration): Rename into ...\n+\t(dump_ada_declaration): ...this.  Do not print the return type.\n+\t(print_ada_struct_decl): Rename into...\n+\t(dump_ada_struct_decl): ...this.\n+\n 2017-09-29  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-attribs.c (handle_packed_attribute): Test DECL_C_BIT_FIELD"}, {"sha": "8f616ed77249cb0ddb76728f323b2bdf446f3ef8", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 196, "deletions": 261, "changes": 457, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79310774839953f17cc5aae75ab332c788784466/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79310774839953f17cc5aae75ab332c788784466/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=79310774839953f17cc5aae75ab332c788784466", "patch": "@@ -32,21 +32,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n \n /* Local functions, macros and variables.  */\n-static int dump_generic_ada_node (pretty_printer *, tree, tree, int, int,\n-\t\t\t\t  bool);\n-static int print_ada_declaration (pretty_printer *, tree, tree, int);\n-static void print_ada_struct_decl (pretty_printer *, tree, tree, int, bool);\n-static void dump_sloc (pretty_printer *buffer, tree node);\n-static void print_comment (pretty_printer *, const char *);\n-static void print_generic_ada_decl (pretty_printer *, tree, const char *);\n-static char *get_ada_package (const char *);\n-static void dump_ada_nodes (pretty_printer *, const char *);\n-static void reset_ada_withs (void);\n-static void dump_ada_withs (FILE *);\n-static void dump_ads (const char *, void (*)(const char *),\n-\t\t      int (*)(tree, cpp_operation));\n-static char *to_ada_name (const char *, int *);\n-static bool separate_class_package (tree);\n+static int  dump_generic_ada_node (pretty_printer *, tree, tree, int, bool,\n+\t\t\t\t   bool);\n+static int  dump_ada_declaration (pretty_printer *, tree, tree, int);\n+static void dump_ada_struct_decl (pretty_printer *, tree, tree, int, bool);\n+static char *to_ada_name (const char *, bool *);\n \n #define INDENT(SPACE) \\\n   do { int i; for (i = 0; i<SPACE; i++) pp_space (buffer); } while (0)\n@@ -56,6 +46,10 @@ static bool separate_class_package (tree);\n /* Global hook used to perform C++ queries on nodes.  */\n static int (*cpp_check) (tree, cpp_operation) = NULL;\n \n+/* Global variables used in macro-related callbacks.  */\n+static int max_ada_macros;\n+static int store_ada_macro_index;\n+static const char *macro_source_file;\n \n /* Given a cpp MACRO, compute the max length BUFFER_LEN of the macro, as well\n    as max length PARAM_LEN of arguments for fun_like macros, and also set\n@@ -170,15 +164,77 @@ handle_escape_character (unsigned char *buffer, char c)\n   return buffer;\n }\n \n-/* Dump into PP a set of MAX_ADA_MACROS MACROS (C/C++) as Ada constants when\n-   possible.  */\n+/* Callback used to count the number of macros from cpp_forall_identifiers.\n+   PFILE and V are not used.  NODE is the current macro to consider.  */\n+\n+static int\n+count_ada_macro (cpp_reader *pfile ATTRIBUTE_UNUSED, cpp_hashnode *node,\n+\t\t void *v ATTRIBUTE_UNUSED)\n+{\n+  const cpp_macro *macro = node->value.macro;\n+\n+  if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN)\n+      && macro->count\n+      && *NODE_NAME (node) != '_'\n+      && LOCATION_FILE (macro->line) == macro_source_file)\n+    max_ada_macros++;\n+\n+  return 1;\n+}\n+\n+/* Callback used to store relevant macros from cpp_forall_identifiers.\n+   PFILE is not used.  NODE is the current macro to store if relevant.\n+   MACROS is an array of cpp_hashnode* used to store NODE.  */\n+\n+static int\n+store_ada_macro (cpp_reader *pfile ATTRIBUTE_UNUSED,\n+\t\t cpp_hashnode *node, void *macros)\n+{\n+  const cpp_macro *macro = node->value.macro;\n+\n+  if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN)\n+      && macro->count\n+      && *NODE_NAME (node) != '_'\n+      && LOCATION_FILE (macro->line) == macro_source_file)\n+    ((cpp_hashnode **) macros)[store_ada_macro_index++] = node;\n+\n+  return 1;\n+}\n+\n+/* Callback used to compare (during qsort) macros.  NODE1 and NODE2 are the\n+   two macro nodes to compare.  */\n+\n+static int\n+compare_macro (const void *node1, const void *node2)\n+{\n+  typedef const cpp_hashnode *const_hnode;\n+\n+  const_hnode n1 = *(const const_hnode *) node1;\n+  const_hnode n2 = *(const const_hnode *) node2;\n+\n+  return n1->value.macro->line - n2->value.macro->line;\n+}\n+\n+/* Dump in PP all relevant macros appearing in FILE.  */\n \n static void\n-print_ada_macros (pretty_printer *pp, cpp_hashnode **macros, int max_ada_macros)\n+dump_ada_macros (pretty_printer *pp, const char* file)\n {\n-  int j, num_macros = 0, prev_line = -1;\n+  int num_macros = 0, prev_line = -1;\n+  cpp_hashnode **macros;\n+\n+  /* Initialize file-scope variables.  */\n+  max_ada_macros = 0;\n+  store_ada_macro_index = 0;\n+  macro_source_file = file;\n+\n+  /* Count all potentially relevant macros, and then sort them by sloc.  */\n+  cpp_forall_identifiers (parse_in, count_ada_macro, NULL);\n+  macros = XALLOCAVEC (cpp_hashnode *, max_ada_macros);\n+  cpp_forall_identifiers (parse_in, store_ada_macro, macros);\n+  qsort (macros, max_ada_macros, sizeof (cpp_hashnode *), compare_macro);\n \n-  for (j = 0; j < max_ada_macros; j++)\n+  for (int j = 0; j < max_ada_macros; j++)\n     {\n       cpp_hashnode *node = macros[j];\n       const cpp_macro *macro = node->value.macro;\n@@ -557,87 +613,8 @@ print_ada_macros (pretty_printer *pp, cpp_hashnode **macros, int max_ada_macros)\n     pp_newline (pp);\n }\n \n-static const char *source_file;\n-static int max_ada_macros;\n-\n-/* Callback used to count the number of relevant macros from\n-   cpp_forall_identifiers. PFILE and V are not used. NODE is the current macro\n-   to consider.  */\n-\n-static int\n-count_ada_macro (cpp_reader *pfile ATTRIBUTE_UNUSED, cpp_hashnode *node,\n-\t\t void *v ATTRIBUTE_UNUSED)\n-{\n-  const cpp_macro *macro = node->value.macro;\n-\n-  if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN)\n-      && macro->count\n-      && *NODE_NAME (node) != '_'\n-      && LOCATION_FILE (macro->line) == source_file)\n-    max_ada_macros++;\n-\n-  return 1;\n-}\n-\n-static int store_ada_macro_index;\n-\n-/* Callback used to store relevant macros from cpp_forall_identifiers.\n-   PFILE is not used. NODE is the current macro to store if relevant.\n-   MACROS is an array of cpp_hashnode* used to store NODE.  */\n-\n-static int\n-store_ada_macro (cpp_reader *pfile ATTRIBUTE_UNUSED,\n-\t\t cpp_hashnode *node, void *macros)\n-{\n-  const cpp_macro *macro = node->value.macro;\n-\n-  if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN)\n-      && macro->count\n-      && *NODE_NAME (node) != '_'\n-      && LOCATION_FILE (macro->line) == source_file)\n-    ((cpp_hashnode **) macros)[store_ada_macro_index++] = node;\n-\n-  return 1;\n-}\n-\n-/* Callback used to compare (during qsort) macros.  NODE1 and NODE2 are the\n-   two macro nodes to compare.  */\n-\n-static int\n-compare_macro (const void *node1, const void *node2)\n-{\n-  typedef const cpp_hashnode *const_hnode;\n-\n-  const_hnode n1 = *(const const_hnode *) node1;\n-  const_hnode n2 = *(const const_hnode *) node2;\n-\n-  return n1->value.macro->line - n2->value.macro->line;\n-}\n-\n-/* Dump in PP all relevant macros appearing in FILE.  */\n-\n-static void\n-dump_ada_macros (pretty_printer *pp, const char* file)\n-{\n-  cpp_hashnode **macros;\n-\n-  /* Initialize file-scope variables.  */\n-  max_ada_macros = 0;\n-  store_ada_macro_index = 0;\n-  source_file = file;\n-\n-  /* Count all potentially relevant macros, and then sort them by sloc.  */\n-  cpp_forall_identifiers (parse_in, count_ada_macro, NULL);\n-  macros = XALLOCAVEC (cpp_hashnode *, max_ada_macros);\n-  cpp_forall_identifiers (parse_in, store_ada_macro, macros);\n-  qsort (macros, max_ada_macros, sizeof (cpp_hashnode *), compare_macro);\n-\n-  print_ada_macros (pp, macros, max_ada_macros);\n-}\n-\n /* Current source file being handled.  */\n-\n-static const char *source_file_base;\n+static const char *current_source_file;\n \n /* Return sloc of DECL, using sloc of last field if LAST is true.  */\n \n@@ -751,6 +728,42 @@ unmark_visited_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n   return NULL_TREE;\n }\n \n+/* Print a COMMENT to the output stream PP.  */\n+\n+static void\n+print_comment (pretty_printer *pp, const char *comment)\n+{\n+  int len = strlen (comment);\n+  char *str = XALLOCAVEC (char, len + 1);\n+  char *tok;\n+  bool extra_newline = false;\n+\n+  memcpy (str, comment, len + 1);\n+\n+  /* Trim C/C++ comment indicators.  */\n+  if (str[len - 2] == '*' && str[len - 1] == '/')\n+    {\n+      str[len - 2] = ' ';\n+      str[len - 1] = '\\0';\n+    }\n+  str += 2;\n+\n+  tok = strtok (str, \"\\n\");\n+  while (tok) {\n+    pp_string (pp, \"  --\");\n+    pp_string (pp, tok);\n+    pp_newline (pp);\n+    tok = strtok (NULL, \"\\n\");\n+\n+    /* Leave a blank line after multi-line comments.  */\n+    if (tok)\n+      extra_newline = true;\n+  }\n+\n+  if (extra_newline)\n+    pp_newline (pp);\n+}\n+\n /* Dump nodes into PP relevant to SOURCE_FILE, as collected by previous calls\n    to collect_ada_nodes.  */\n \n@@ -792,7 +805,16 @@ dump_ada_nodes (pretty_printer *pp, const char *source_file)\n \t  if (j == comments->count\n \t      || LOCATION_LINE (decl_sloc (to_dump[i], false))\n \t      <  LOCATION_LINE (comments->entries[j].sloc))\n-\t    print_generic_ada_decl (pp, to_dump[i++], source_file);\n+\t    {\n+\t      current_source_file = source_file;\n+\n+\t      if (dump_ada_declaration (pp, to_dump[i++], NULL_TREE,\n+\t\t\t\t\t INDENT_INCR))\n+\t\t{\n+\t\t  pp_newline (pp);\n+\t\t  pp_newline (pp);\n+\t\t}\n+\t    }\n \t  else\n \t    break;\n \t}\n@@ -816,57 +838,6 @@ dump_ada_nodes (pretty_printer *pp, const char *source_file)\n     }\n }\n \n-/* Print a COMMENT to the output stream PP.  */\n-\n-static void\n-print_comment (pretty_printer *pp, const char *comment)\n-{\n-  int len = strlen (comment);\n-  char *str = XALLOCAVEC (char, len + 1);\n-  char *tok;\n-  bool extra_newline = false;\n-\n-  memcpy (str, comment, len + 1);\n-\n-  /* Trim C/C++ comment indicators.  */\n-  if (str[len - 2] == '*' && str[len - 1] == '/')\n-    {\n-      str[len - 2] = ' ';\n-      str[len - 1] = '\\0';\n-    }\n-  str += 2;\n-\n-  tok = strtok (str, \"\\n\");\n-  while (tok) {\n-    pp_string (pp, \"  --\");\n-    pp_string (pp, tok);\n-    pp_newline (pp);\n-    tok = strtok (NULL, \"\\n\");\n-\n-    /* Leave a blank line after multi-line comments.  */\n-    if (tok)\n-      extra_newline = true;\n-  }\n-\n-  if (extra_newline)\n-    pp_newline (pp);\n-}\n-\n-/* Print declaration DECL to PP in Ada syntax.  The current source file being\n-   handled is SOURCE_FILE.  */\n-\n-static void\n-print_generic_ada_decl (pretty_printer *pp, tree decl, const char *source_file)\n-{\n-  source_file_base = source_file;\n-\n-  if (print_ada_declaration (pp, decl, NULL_TREE, INDENT_INCR))\n-    {\n-      pp_newline (pp);\n-      pp_newline (pp);\n-    }\n-}\n-\n /* Dump a newline and indent BUFFER by SPC chars.  */\n \n static void\n@@ -876,7 +847,7 @@ newline_and_indent (pretty_printer *buffer, int spc)\n   INDENT (spc);\n }\n \n-struct with { char *s; const char *in_file; int limited; };\n+struct with { char *s; const char *in_file; bool limited; };\n static struct with *withs = NULL;\n static int withs_max = 4096;\n static int with_len = 0;\n@@ -885,7 +856,7 @@ static int with_len = 0;\n    true), if not already done.  */\n \n static void\n-append_withs (const char *s, int limited_access)\n+append_withs (const char *s, bool limited_access)\n {\n   int i;\n \n@@ -900,14 +871,14 @@ append_withs (const char *s, int limited_access)\n \n   for (i = 0; i < with_len; i++)\n     if (!strcmp (s, withs[i].s)\n-\t&& source_file_base == withs[i].in_file)\n+\t&& current_source_file == withs[i].in_file)\n       {\n \twiths[i].limited &= limited_access;\n \treturn;\n       }\n \n   withs[with_len].s = xstrdup (s);\n-  withs[with_len].in_file = source_file_base;\n+  withs[with_len].in_file = current_source_file;\n   withs[with_len].limited = limited_access;\n   with_len++;\n }\n@@ -1107,24 +1078,24 @@ has_nontrivial_methods (tree type)\n   return false;\n }\n \n-/* Generate a legal Ada name from a C NAME, returning a malloc'd string.\n-   SPACE_FOUND, if not NULL, is used to indicate whether a space was found in\n-   NAME.  */\n+/* Generate a legal Ada name from a C/C++ NAME and return a malloc'ed string. \n+   SPACE_FOUND, if not NULL, is used to indicate whether a space was found\n+   in NAME.  */\n \n static char *\n-to_ada_name (const char *name, int *space_found)\n+to_ada_name (const char *name, bool *space_found)\n {\n   const char **names;\n-  int len = strlen (name);\n+  const int len = strlen (name);\n   int j, len2 = 0;\n-  int found = false;\n+  bool found = false;\n   char *s = XNEWVEC (char, len * 2 + 5);\n   char c;\n \n   if (space_found)\n     *space_found = false;\n \n-  /* Add trailing \"c_\" if name is an Ada reserved word.  */\n+  /* Add \"c_\" prefix if name is an Ada reserved word.  */\n   for (names = ada_reserved; *names; names++)\n     if (!strcasecmp (name, *names))\n       {\n@@ -1135,7 +1106,7 @@ to_ada_name (const char *name, int *space_found)\n       }\n \n   if (!found)\n-    /* Add trailing \"c_\" if name is an potential case sensitive duplicate.  */\n+    /* Add \"c_\" prefix if name is a potential case sensitive duplicate.  */\n     for (names = c_duplicates; *names; names++)\n       if (!strcmp (name, *names))\n \t{\n@@ -1161,7 +1132,6 @@ to_ada_name (const char *name, int *space_found)\n     }\n \n   /* Replace unsuitable characters for Ada identifiers.  */\n-\n   for (; j < len; j++)\n     switch (name[j])\n       {\n@@ -1340,24 +1310,21 @@ static bool package_prefix = true;\n \n static void\n pp_ada_tree_identifier (pretty_printer *buffer, tree node, tree type,\n-\t\t\tint limited_access)\n+\t\t\tbool limited_access)\n {\n   const char *name = IDENTIFIER_POINTER (node);\n-  int space_found = false;\n+  bool space_found = false;\n   char *s = to_ada_name (name, &space_found);\n-  tree decl;\n-\n-  /* If the entity is a type and comes from another file, generate \"package\"\n-     prefix.  */\n-  decl = get_underlying_decl (type);\n+  tree decl = get_underlying_decl (type);\n \n+  /* If the entity comes from another file, generate a package prefix.  */\n   if (decl)\n     {\n       expanded_location xloc = expand_location (decl_sloc (decl, false));\n \n       if (xloc.file && xloc.line)\n \t{\n-\t  if (xloc.file != source_file_base)\n+\t  if (xloc.file != current_source_file)\n \t    {\n \t      switch (TREE_CODE (type))\n \t\t{\n@@ -1464,7 +1431,7 @@ pp_asm_name (pretty_printer *buffer, tree t)\n    'with' clause rather than a regular 'with' clause.  */\n \n static void\n-dump_ada_decl_name (pretty_printer *buffer, tree decl, int limited_access)\n+dump_ada_decl_name (pretty_printer *buffer, tree decl, bool limited_access)\n {\n   if (DECL_NAME (decl))\n     pp_ada_tree_identifier (buffer, DECL_NAME (decl), decl, limited_access);\n@@ -1586,10 +1553,10 @@ check_name (pretty_printer *buffer, tree t)\n    IS_DESTRUCTOR whether FUNC is a C++ destructor.\n    SPC is the current indentation level.  */\n \n-static int\n+static void\n dump_ada_function_declaration (pretty_printer *buffer, tree func,\n-\t\t\t       int is_method, int is_constructor,\n-\t\t\t       int is_destructor, int spc)\n+\t\t\t       bool is_method, bool is_constructor,\n+\t\t\t       bool is_destructor, int spc)\n {\n   tree arg;\n   const tree node = TREE_TYPE (func);\n@@ -1708,7 +1675,13 @@ dump_ada_function_declaration (pretty_printer *buffer, tree func,\n \n   if (num_args > 0)\n     pp_right_paren (buffer);\n-  return num_args;\n+\n+  if (is_constructor || !VOID_TYPE_P (TREE_TYPE (node)))\n+    {\n+      pp_string (buffer, \" return \");\n+      tree type = is_constructor ? DECL_CONTEXT (func) : TREE_TYPE (node);\n+      dump_generic_ada_node (buffer, type, type, spc, false, true);\n+    }\n }\n \n /* Dump in BUFFER all the domains associated with an array NODE,\n@@ -1973,7 +1946,7 @@ static bool bitfield_used = false;\n \n static int\n dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n-\t\t       int limited_access, bool name_only)\n+\t\t       bool limited_access, bool name_only)\n {\n   if (node == NULL_TREE)\n     return 0;\n@@ -2042,8 +2015,8 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t      newline_and_indent (buffer, spc);\n \t\t    }\n \n-\t\t  pp_ada_tree_identifier\n-\t\t    (buffer, TREE_PURPOSE (value), node, false);\n+\t\t  pp_ada_tree_identifier (buffer, TREE_PURPOSE (value), node,\n+\t\t\t\t\t  false);\n \t\t}\n \t      pp_string (buffer, \");\");\n \t      spc -= INDENT_INCR;\n@@ -2065,8 +2038,8 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t  pp_semicolon (buffer);\n \t\t  newline_and_indent (buffer, spc);\n \n-\t\t  pp_ada_tree_identifier\n-\t\t    (buffer, TREE_PURPOSE (value), node, false);\n+\t\t  pp_ada_tree_identifier (buffer, TREE_PURPOSE (value), node,\n+\t\t\t\t\t  false);\n \t\t  pp_string (buffer, \" : constant \");\n \n \t\t  dump_generic_ada_node\n@@ -2096,8 +2069,8 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \tif (tclass == tcc_declaration)\n \t  {\n \t    if (DECL_NAME (node))\n-\t      pp_ada_tree_identifier\n-\t\t(buffer, DECL_NAME (node), NULL_TREE, limited_access);\n+\t      pp_ada_tree_identifier (buffer, DECL_NAME (node), NULL_TREE,\n+\t\t\t\t      limited_access);\n \t    else\n \t      pp_string (buffer, \"<unnamed type decl>\");\n \t  }\n@@ -2106,8 +2079,8 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t    if (TYPE_NAME (node))\n \t      {\n \t\tif (TREE_CODE (TYPE_NAME (node)) == IDENTIFIER_NODE)\n-\t\t  pp_ada_tree_identifier (buffer, TYPE_NAME (node),\n-\t\t\t\t\t  node, limited_access);\n+\t\t  pp_ada_tree_identifier (buffer, TYPE_NAME (node), node,\n+\t\t\t\t\t  limited_access);\n \t\telse if (TREE_CODE (TYPE_NAME (node)) == TYPE_DECL\n \t\t\t && DECL_NAME (TYPE_NAME (node)))\n \t\t  dump_ada_decl_name (buffer, TYPE_NAME (node), limited_access);\n@@ -2143,41 +2116,24 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \n       else if (TREE_CODE (TREE_TYPE (node)) == FUNCTION_TYPE)\n \t{\n-\t  tree fnode = TREE_TYPE (node);\n-\t  bool is_function;\n-\n-\t  if (VOID_TYPE_P (TREE_TYPE (fnode)))\n-\t    {\n-\t      is_function = false;\n-\t      pp_string (buffer, \"access procedure\");\n-\t    }\n+\t  if (VOID_TYPE_P (TREE_TYPE (TREE_TYPE (node))))\n+\t    pp_string (buffer, \"access procedure \");\n \t  else\n-\t    {\n-\t      is_function = true;\n-\t      pp_string (buffer, \"access function\");\n-\t    }\n+\t    pp_string (buffer, \"access function \");\n \n \t  dump_ada_function_declaration\n \t    (buffer, node, false, false, false, spc + INDENT_INCR);\n \n-\t  if (is_function)\n+\t  /* If we are dumping the full type, it means we are part of a\n+\t     type definition and need also a Convention C pragma.  */\n+\t  if (!name_only)\n \t    {\n-\t      pp_string (buffer, \" return \");\n-\t      dump_generic_ada_node\n-\t\t(buffer, TREE_TYPE (fnode), type, spc, 0, true);\n+\t      pp_semicolon (buffer);\n+\t      newline_and_indent (buffer, spc);\n+\t      pp_string (buffer, \"pragma Convention (C, \");\n+\t      dump_generic_ada_node (buffer, type, 0, spc, false, true);\n+\t      pp_right_paren (buffer);\n \t    }\n-\n-\t    /* If we are dumping the full type, it means we are part of a\n-\t       type definition and need also a Convention C pragma.  */\n-\t    if (!name_only)\n-\t      {\n-\t\tpp_semicolon (buffer);\n-\t\tnewline_and_indent (buffer, spc);\n-\t\tpp_string (buffer, \"pragma Convention (C, \");\n-\t\tdump_generic_ada_node\n-\t\t  (buffer, type, 0, spc, false, true);\n-\t\tpp_right_paren (buffer);\n-\t      }\n \t}\n       else\n \t{\n@@ -2229,7 +2185,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t      || !decl\n \t\t      || (!enclosing_decl\n \t\t\t  && !TREE_VISITED (decl)\n-\t\t\t  && DECL_SOURCE_FILE (decl) == source_file_base)\n+\t\t\t  && DECL_SOURCE_FILE (decl) == current_source_file)\n \t\t      || (enclosing_decl\n \t\t\t  && !TREE_VISITED (decl)\n \t\t\t  && DECL_SOURCE_FILE (decl)\n@@ -2314,7 +2270,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t    }\n \t}\n       else\n-\tprint_ada_struct_decl (buffer, node, type, spc, true);\n+\tdump_ada_struct_decl (buffer, node, type, spc, true);\n       break;\n \n     case INTEGER_CST:\n@@ -2353,11 +2309,6 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n     case VECTOR_CST:\n       return 0;\n \n-    case FUNCTION_DECL:\n-    case CONST_DECL:\n-      dump_ada_decl_name (buffer, node, limited_access);\n-      break;\n-\n     case TYPE_DECL:\n       if (DECL_IS_BUILTIN (node))\n \t{\n@@ -2416,6 +2367,8 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t}\n       break;\n \n+    case FUNCTION_DECL:\n+    case CONST_DECL:\n     case VAR_DECL:\n     case PARM_DECL:\n     case FIELD_DECL:\n@@ -2435,7 +2388,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n    methods were printed, 0 otherwise.  */\n \n static int\n-print_ada_methods (pretty_printer *buffer, tree node, int spc)\n+dump_ada_methods (pretty_printer *buffer, tree node, int spc)\n {\n   if (!has_nontrivial_methods (node))\n     return 0;\n@@ -2451,8 +2404,8 @@ print_ada_methods (pretty_printer *buffer, tree node, int spc)\n \t    pp_newline (buffer);\n \t    pp_newline (buffer);\n \t  }\n-\t\n-\tres = print_ada_declaration (buffer, fld, node, spc);\n+\n+\tres = dump_ada_declaration (buffer, fld, node, spc);\n       }\n \n   return 1;\n@@ -2597,7 +2550,7 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n \t  if (TREE_CODE (field_type) == UNION_TYPE)\n \t    pp_string (buffer, \" (discr : unsigned := 0)\");\n \t  pp_string (buffer, \" is \");\n-\t  print_ada_struct_decl (buffer, field_type, t, spc, false);\n+\t  dump_ada_struct_decl (buffer, field_type, t, spc, false);\n \n \t  pp_string (buffer, \"pragma Convention (C_Pass_By_Copy, \");\n \t  dump_generic_ada_node (buffer, field_type, 0, spc, false, true);\n@@ -2617,7 +2570,7 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n \t  if (TREE_CODE (field_type) == UNION_TYPE)\n \t    pp_string (buffer, \" (discr : unsigned := 0)\");\n \t  pp_string (buffer, \" is \");\n-\t  print_ada_struct_decl (buffer, field_type, t, spc, false);\n+\t  dump_ada_struct_decl (buffer, field_type, t, spc, false);\n \n \t  pp_string (buffer, \"pragma Convention (C_Pass_By_Copy, \");\n \t  dump_ada_double_name (buffer, parent, field);\n@@ -2672,12 +2625,12 @@ type_name (tree t)\n     return IDENTIFIER_POINTER (DECL_NAME (n));\n }\n \n-/* Print in BUFFER the declaration of a variable T of type TYPE in Ada syntax.\n+/* Dump in BUFFER the declaration of a variable T of type TYPE in Ada syntax.\n    SPC is the indentation level.  Return 1 if a declaration was printed,\n    0 otherwise.  */\n \n static int\n-print_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n+dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n {\n   int is_var = 0, need_indent = 0;\n   int is_class = false;\n@@ -2722,7 +2675,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t      else\n \t\t{\n \t\t  if (RECORD_OR_UNION_TYPE_P (typ)\n-\t\t      && DECL_SOURCE_FILE (stub) == source_file_base)\n+\t\t      && DECL_SOURCE_FILE (stub) == current_source_file)\n \t\t    dump_nested_types (buffer, stub, stub, true, spc);\n \n \t\t  pp_string (buffer, \"subtype \");\n@@ -2876,7 +2829,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n     }\n   else if (TREE_CODE (t) == FUNCTION_DECL)\n     {\n-      bool is_function, is_abstract_class = false;\n+      bool is_abstract_class = false;\n       bool is_method = TREE_CODE (TREE_TYPE (t)) == METHOD_TYPE;\n       tree decl_name = DECL_NAME (t);\n       bool is_abstract = false;\n@@ -2927,15 +2880,9 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \tINDENT (spc);\n \n       if (VOID_TYPE_P (TREE_TYPE (TREE_TYPE (t))) && !is_constructor)\n-\t{\n-\t  pp_string (buffer, \"procedure \");\n-\t  is_function = false;\n-\t}\n+\tpp_string (buffer, \"procedure \");\n       else\n-\t{\n-\t  pp_string (buffer, \"function \");\n-\t  is_function = true;\n-\t}\n+\tpp_string (buffer, \"function \");\n \n       if (is_constructor)\n \tprint_constructor (buffer, t, type);\n@@ -2947,14 +2894,6 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n       dump_ada_function_declaration\n \t(buffer, t, is_method, is_constructor, is_destructor, spc);\n \n-      if (is_function)\n-\t{\n-\t  pp_string (buffer, \" return \");\n-\t  tree ret_type\n-\t    = is_constructor ? DECL_CONTEXT (t) : TREE_TYPE (TREE_TYPE (t));\n-\t  dump_generic_ada_node (buffer, ret_type, type, spc, false, true);\n-\t}\n-\n       if (is_constructor && RECORD_OR_UNION_TYPE_P (type))\n \tfor (tree fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))\n \t  if (TREE_CODE (fld) == FUNCTION_DECL && cpp_check (fld, IS_ABSTRACT))\n@@ -2992,9 +2931,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t  pp_string (buffer, \"\\\");\");\n \t}\n       else\n-\t{\n-\t  dump_ada_import (buffer, t);\n-\t}\n+\tdump_ada_import (buffer, t);\n \n       return 1;\n     }\n@@ -3059,7 +2996,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t    (buffer, TYPE_NAME (TREE_TYPE (t)), type, spc, false, true);\n   \t  pp_right_paren (buffer);\n \n-\t  print_ada_methods (buffer, TREE_TYPE (t), spc);\n+\t  dump_ada_methods (buffer, TREE_TYPE (t), spc);\n \t}\n       else\n \t{\n@@ -3156,12 +3093,12 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n   return 1;\n }\n \n-/* Prints in BUFFER a structure NODE of type TYPE: name, fields, and methods\n+/* Dump in BUFFER a structure NODE of type TYPE: name, fields, and methods\n    with Ada syntax.  SPC is the indentation level.  If DISPLAY_CONVENTION is\n    true, also print the pragma Convention for NODE.  */\n \n static void\n-print_ada_struct_decl (pretty_printer *buffer, tree node, tree type, int spc,\n+dump_ada_struct_decl (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t       bool display_convention)\n {\n   tree tmp;\n@@ -3196,7 +3133,7 @@ print_ada_struct_decl (pretty_printer *buffer, tree node, tree type, int spc,\n \t      if (!is_tagged_type (TREE_TYPE (tmp)))\n \t\t{\n \t\t  if (!TYPE_NAME (TREE_TYPE (tmp)))\n-\t\t    print_ada_declaration (buffer, tmp, type, field_spc);\n+\t\t    dump_ada_declaration (buffer, tmp, type, field_spc);\n \t\t  else\n \t\t    {\n \t\t      INDENT (field_spc);\n@@ -3235,7 +3172,7 @@ print_ada_struct_decl (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t      pp_newline (buffer);\n \t\t    }\n \n-\t\t  if (print_ada_declaration (buffer, tmp, type, field_spc))\n+\t\t  if (dump_ada_declaration (buffer, tmp, type, field_spc))\n \t\t    {\n \t\t      pp_newline (buffer);\n \t\t      field_num++;\n@@ -3305,7 +3242,7 @@ print_ada_struct_decl (pretty_printer *buffer, tree node, tree type, int spc,\n       bitfield_used = false;\n     }\n \n-  need_semicolon = !print_ada_methods (buffer, node, spc);\n+  need_semicolon = !dump_ada_methods (buffer, node, spc);\n \n   /* Print the static fields of the structure, if any.  */\n   for (tmp = TYPE_FIELDS (node); tmp; tmp = TREE_CHAIN (tmp))\n@@ -3319,7 +3256,7 @@ print_ada_struct_decl (pretty_printer *buffer, tree node, tree type, int spc,\n \t    }\n \t  pp_newline (buffer);\n \t  pp_newline (buffer);\n-\t  print_ada_declaration (buffer, tmp, type, spc);\n+\t  dump_ada_declaration (buffer, tmp, type, spc);\n \t}\n     }\n }\n@@ -3434,10 +3371,8 @@ void\n dump_ada_specs (void (*collect_all_refs)(const char *),\n \t\tint (*check)(tree, cpp_operation))\n {\n-  int i;\n-\n-  /* Iterate over the list of files to dump specs for */\n-  for (i = 0; i < source_refs_used; i++)\n+  /* Iterate over the list of files to dump specs for.  */\n+  for (int i = 0; i < source_refs_used; i++)\n     dump_ads (source_refs[i], collect_all_refs, check);\n \n   /* Free files table.  */"}]}