{"sha": "8006f46bdd8be581f287ed7d1c2d204c608fb426", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAwNmY0NmJkZDhiZTU4MWYyODdlZDdkMWMyZDIwNGM2MDhmYjQyNg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-11-26T14:39:43Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-11-26T14:39:43Z"}, "message": "fold-const.h (const_unop): Declare.\n\n2014-11-26  Richard Biener  <rguenther@suse.de>\n\n\t* fold-const.h (const_unop): Declare.\n\t(const_binop): Likewise.\n\t* fold-const.c (const_binop): Export overload that expects\n\ta type parameter and dispatches to fold_relational_const as well.\n\tCheck both operand kinds for guarding the transforms.\n\t(const_unop): New function, with constant folding from fold_unary_loc.\n\t(fold_unary_loc): Dispatch to const_unop for tcc_constant operand.\n\tRemove constant folding done there from the simplifications.\n\t(fold_binary_loc): Check for constants using CONSTANT_CLASS_P.\n\t(fold_negate_expr): Remove dead code from the REAL_CST case.\n\tAvoid building garbage in the COMPLEX_CST case.\n\t* gimple-match-head.c (gimple_resimplify1): Dispatch to\n\tconst_unop.\n\t(gimple_resimplify2): Dispatch to const_binop.\n\t(gimple_simplify): Likewise.\n\nFrom-SVN: r218086", "tree": {"sha": "8513d233a582b2c8a38f6db93929f5a48aaf43a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8513d233a582b2c8a38f6db93929f5a48aaf43a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8006f46bdd8be581f287ed7d1c2d204c608fb426", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8006f46bdd8be581f287ed7d1c2d204c608fb426", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8006f46bdd8be581f287ed7d1c2d204c608fb426", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8006f46bdd8be581f287ed7d1c2d204c608fb426/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4186636315b90403a2dc34952b34f6ab4b79ed16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4186636315b90403a2dc34952b34f6ab4b79ed16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4186636315b90403a2dc34952b34f6ab4b79ed16"}], "stats": {"total": 384, "additions": 230, "deletions": 154}, "files": [{"sha": "34f66f95b2b472739adaeb041272fbcf2239f185", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8006f46bdd8be581f287ed7d1c2d204c608fb426/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8006f46bdd8be581f287ed7d1c2d204c608fb426/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8006f46bdd8be581f287ed7d1c2d204c608fb426", "patch": "@@ -1,3 +1,21 @@\n+2014-11-26  Richard Biener  <rguenther@suse.de>\n+\n+\t* fold-const.h (const_unop): Declare.\n+\t(const_binop): Likewise.\n+\t* fold-const.c (const_binop): Export overload that expects\n+\ta type parameter and dispatches to fold_relational_const as well.\n+\tCheck both operand kinds for guarding the transforms.\n+\t(const_unop): New function, with constant folding from fold_unary_loc.\n+\t(fold_unary_loc): Dispatch to const_unop for tcc_constant operand.\n+\tRemove constant folding done there from the simplifications.\n+\t(fold_binary_loc): Check for constants using CONSTANT_CLASS_P.\n+\t(fold_negate_expr): Remove dead code from the REAL_CST case.\n+\tAvoid building garbage in the COMPLEX_CST case.\n+\t* gimple-match-head.c (gimple_resimplify1): Dispatch to\n+\tconst_unop.\n+\t(gimple_resimplify2): Dispatch to const_binop.\n+\t(gimple_simplify): Likewise.\n+\n 2014-11-26  Ilya Enkovich  <ilya.enkovich@intel.com>\n \n \tPR bootstrap/63995"}, {"sha": "195d1e5408d372fb7ad229d9c449fe8193d91286", "filename": "gcc/fold-const.c", "status": "modified", "additions": 206, "deletions": 149, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8006f46bdd8be581f287ed7d1c2d204c608fb426/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8006f46bdd8be581f287ed7d1c2d204c608fb426/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=8006f46bdd8be581f287ed7d1c2d204c608fb426", "patch": "@@ -115,7 +115,6 @@ static bool negate_expr_p (tree);\n static tree negate_expr (tree);\n static tree split_tree (tree, enum tree_code, tree *, tree *, tree *, int);\n static tree associate_trees (location_t, tree, tree, enum tree_code, tree);\n-static tree const_binop (enum tree_code, tree, tree);\n static enum comparison_code comparison_to_compcode (enum tree_code);\n static enum tree_code compcode_to_comparison (enum comparison_code);\n static int operand_equal_for_comparison_p (tree, tree, tree);\n@@ -156,6 +155,9 @@ static tree fold_negate_const (tree, tree);\n static tree fold_not_const (const_tree, tree);\n static tree fold_relational_const (enum tree_code, tree, tree, tree);\n static tree fold_convert_const (enum tree_code, tree, tree);\n+static tree fold_view_convert_expr (tree, tree);\n+static bool vec_cst_ctor_to_array (tree, tree *);\n+\n \n /* Return EXPR_LOCATION of T if it is not UNKNOWN_LOCATION.\n    Otherwise, return LOC.  */\n@@ -564,24 +566,17 @@ fold_negate_expr (location_t loc, tree t)\n \n     case REAL_CST:\n       tem = fold_negate_const (t, type);\n-      /* Two's complement FP formats, such as c4x, may overflow.  */\n-      if (!TREE_OVERFLOW (tem) || !flag_trapping_math)\n-\treturn tem;\n-      break;\n+      return tem;\n \n     case FIXED_CST:\n       tem = fold_negate_const (t, type);\n       return tem;\n \n     case COMPLEX_CST:\n       {\n-\ttree rpart = negate_expr (TREE_REALPART (t));\n-\ttree ipart = negate_expr (TREE_IMAGPART (t));\n-\n-\tif ((TREE_CODE (rpart) == REAL_CST\n-\t     && TREE_CODE (ipart) == REAL_CST)\n-\t    || (TREE_CODE (rpart) == INTEGER_CST\n-\t\t&& TREE_CODE (ipart) == INTEGER_CST))\n+\ttree rpart = fold_negate_expr (loc, TREE_REALPART (t));\n+\ttree ipart = fold_negate_expr (loc, TREE_IMAGPART (t));\n+\tif (rpart && ipart)\n \t  return build_complex (type, rpart, ipart);\n       }\n       break;\n@@ -1138,10 +1133,10 @@ const_binop (enum tree_code code, tree arg1, tree arg2)\n   STRIP_NOPS (arg1);\n   STRIP_NOPS (arg2);\n \n-  if (TREE_CODE (arg1) == INTEGER_CST)\n+  if (TREE_CODE (arg1) == INTEGER_CST && TREE_CODE (arg2) == INTEGER_CST)\n     return int_const_binop (code, arg1, arg2);\n \n-  if (TREE_CODE (arg1) == REAL_CST)\n+  if (TREE_CODE (arg1) == REAL_CST && TREE_CODE (arg2) == REAL_CST)\n     {\n       machine_mode mode;\n       REAL_VALUE_TYPE d1;\n@@ -1219,7 +1214,7 @@ const_binop (enum tree_code code, tree arg1, tree arg2)\n       return t;\n     }\n \n-  if (TREE_CODE (arg1) == FIXED_CST)\n+  if (TREE_CODE (arg1) == FIXED_CST && TREE_CODE (arg2) == FIXED_CST)\n     {\n       FIXED_VALUE_TYPE f1;\n       FIXED_VALUE_TYPE f2;\n@@ -1263,7 +1258,7 @@ const_binop (enum tree_code code, tree arg1, tree arg2)\n       return t;\n     }\n \n-  if (TREE_CODE (arg1) == COMPLEX_CST)\n+  if (TREE_CODE (arg1) == COMPLEX_CST && TREE_CODE (arg2) == COMPLEX_CST)\n     {\n       tree type = TREE_TYPE (arg1);\n       tree r1 = TREE_REALPART (arg1);\n@@ -1440,6 +1435,179 @@ const_binop (enum tree_code code, tree arg1, tree arg2)\n   return NULL_TREE;\n }\n \n+/* Overload that adds a TYPE parameter to be able to dispatch\n+   to fold_relational_const.  */\n+\n+tree\n+const_binop (enum tree_code code, tree type, tree arg1, tree arg2)\n+{\n+  if (TREE_CODE_CLASS (code) == tcc_comparison)\n+    return fold_relational_const (code, type, arg1, arg2);\n+  else\n+    return const_binop (code, arg1, arg2);\n+}\n+\n+/* Compute CODE ARG1 with resulting type TYPE with ARG1 being constant.\n+   Return zero if computing the constants is not possible.  */\n+\n+tree\n+const_unop (enum tree_code code, tree type, tree arg0)\n+{\n+  switch (code)\n+    {\n+    CASE_CONVERT:\n+    case FLOAT_EXPR:\n+    case FIX_TRUNC_EXPR:\n+    case FIXED_CONVERT_EXPR:\n+      return fold_convert_const (code, type, arg0);\n+\n+    case ADDR_SPACE_CONVERT_EXPR:\n+      if (integer_zerop (arg0))\n+\treturn fold_convert_const (code, type, arg0);\n+      break;\n+\n+    case VIEW_CONVERT_EXPR:\n+      return fold_view_convert_expr (type, arg0);\n+\n+    case NEGATE_EXPR:\n+      {\n+\t/* Can't call fold_negate_const directly here as that doesn't\n+\t   handle all cases and we might not be able to negate some\n+\t   constants.  */\n+\ttree tem = fold_negate_expr (UNKNOWN_LOCATION, arg0);\n+\tif (tem && CONSTANT_CLASS_P (tem))\n+\t  return tem;\n+\tbreak;\n+      }\n+\n+    case ABS_EXPR:\n+      return fold_abs_const (arg0, type);\n+\n+    case CONJ_EXPR:\n+      if (TREE_CODE (arg0) == COMPLEX_CST)\n+\t{\n+\t  tree ipart = fold_negate_const (TREE_IMAGPART (arg0),\n+\t\t\t\t\t  TREE_TYPE (type));\n+\t  return build_complex (type, TREE_REALPART (arg0), ipart);\n+\t}\n+      break;\n+\n+    case BIT_NOT_EXPR:\n+      if (TREE_CODE (arg0) == INTEGER_CST)\n+\treturn fold_not_const (arg0, type);\n+      /* Perform BIT_NOT_EXPR on each element individually.  */\n+      else if (TREE_CODE (arg0) == VECTOR_CST)\n+\t{\n+\t  tree *elements;\n+\t  tree elem;\n+\t  unsigned count = VECTOR_CST_NELTS (arg0), i;\n+\n+\t  elements = XALLOCAVEC (tree, count);\n+\t  for (i = 0; i < count; i++)\n+\t    {\n+\t      elem = VECTOR_CST_ELT (arg0, i);\n+\t      elem = const_unop (BIT_NOT_EXPR, TREE_TYPE (type), elem);\n+\t      if (elem == NULL_TREE)\n+\t\tbreak;\n+\t      elements[i] = elem;\n+\t    }\n+\t  if (i == count)\n+\t    return build_vector (type, elements);\n+\t}\n+      break;\n+\n+    case TRUTH_NOT_EXPR:\n+      if (TREE_CODE (arg0) == INTEGER_CST)\n+\treturn constant_boolean_node (integer_zerop (arg0), type);\n+      break;\n+\n+    case REALPART_EXPR:\n+      if (TREE_CODE (arg0) == COMPLEX_CST)\n+\treturn fold_convert (type, TREE_REALPART (arg0));\n+      break;\n+\n+    case IMAGPART_EXPR:\n+      if (TREE_CODE (arg0) == COMPLEX_CST)\n+\treturn fold_convert (type, TREE_IMAGPART (arg0));\n+      break;\n+\n+    case VEC_UNPACK_LO_EXPR:\n+    case VEC_UNPACK_HI_EXPR:\n+    case VEC_UNPACK_FLOAT_LO_EXPR:\n+    case VEC_UNPACK_FLOAT_HI_EXPR:\n+      {\n+\tunsigned int nelts = TYPE_VECTOR_SUBPARTS (type), i;\n+\ttree *elts;\n+\tenum tree_code subcode;\n+\n+\tgcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0)) == nelts * 2);\n+\tif (TREE_CODE (arg0) != VECTOR_CST)\n+\t  return NULL_TREE;\n+\n+\telts = XALLOCAVEC (tree, nelts * 2);\n+\tif (!vec_cst_ctor_to_array (arg0, elts))\n+\t  return NULL_TREE;\n+\n+\tif ((!BYTES_BIG_ENDIAN) ^ (code == VEC_UNPACK_LO_EXPR\n+\t\t\t\t   || code == VEC_UNPACK_FLOAT_LO_EXPR))\n+\t  elts += nelts;\n+\n+\tif (code == VEC_UNPACK_LO_EXPR || code == VEC_UNPACK_HI_EXPR)\n+\t  subcode = NOP_EXPR;\n+\telse\n+\t  subcode = FLOAT_EXPR;\n+\n+\tfor (i = 0; i < nelts; i++)\n+\t  {\n+\t    elts[i] = fold_convert_const (subcode, TREE_TYPE (type), elts[i]);\n+\t    if (elts[i] == NULL_TREE || !CONSTANT_CLASS_P (elts[i]))\n+\t      return NULL_TREE;\n+\t  }\n+\n+\treturn build_vector (type, elts);\n+      }\n+\n+    case REDUC_MIN_EXPR:\n+    case REDUC_MAX_EXPR:\n+    case REDUC_PLUS_EXPR:\n+      {\n+\tunsigned int nelts, i;\n+\ttree *elts;\n+\tenum tree_code subcode;\n+\n+\tif (TREE_CODE (arg0) != VECTOR_CST)\n+\t  return NULL_TREE;\n+        nelts = TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0));\n+\n+\telts = XALLOCAVEC (tree, nelts);\n+\tif (!vec_cst_ctor_to_array (arg0, elts))\n+\t  return NULL_TREE;\n+\n+\tswitch (code)\n+\t  {\n+\t  case REDUC_MIN_EXPR: subcode = MIN_EXPR; break;\n+\t  case REDUC_MAX_EXPR: subcode = MAX_EXPR; break;\n+\t  case REDUC_PLUS_EXPR: subcode = PLUS_EXPR; break;\n+\t  default: gcc_unreachable ();\n+\t  }\n+\n+\tfor (i = 1; i < nelts; i++)\n+\t  {\n+\t    elts[0] = const_binop (subcode, elts[0], elts[i]);\n+\t    if (elts[0] == NULL_TREE || !CONSTANT_CLASS_P (elts[0]))\n+\t      return NULL_TREE;\n+\t  }\n+\n+\treturn elts[0];\n+      }\n+\n+    default:\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Create a sizetype INT_CST node with NUMBER sign extended.  KIND\n    indicates which particular sizetype to create.  */\n \n@@ -7507,8 +7675,6 @@ build_fold_addr_expr_loc (location_t loc, tree t)\n   return build_fold_addr_expr_with_type_loc (loc, t, ptrtype);\n }\n \n-static bool vec_cst_ctor_to_array (tree, tree *);\n-\n /* Fold a unary expression of code CODE and type TYPE with operand\n    OP0.  Return the folded expression if folding is successful.\n    Otherwise, return NULL_TREE.  */\n@@ -7523,10 +7689,6 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n   gcc_assert (IS_EXPR_CODE_CLASS (kind)\n \t      && TREE_CODE_LENGTH (code) == 1);\n \n-  tem = generic_simplify (loc, code, type, op0);\n-  if (tem)\n-    return tem;\n-\n   arg0 = op0;\n   if (arg0)\n     {\n@@ -7552,8 +7714,23 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n \t     constant folder.  */\n \t  STRIP_NOPS (arg0);\n \t}\n+\n+      if (CONSTANT_CLASS_P (arg0))\n+\t{\n+\t  tree tem = const_unop (code, type, arg0);\n+\t  if (tem)\n+\t    {\n+\t      if (TREE_TYPE (tem) != type)\n+\t\ttem = fold_convert_loc (loc, type, tem);\n+\t      return tem;\n+\t    }\n+\t}\n     }\n \n+  tem = generic_simplify (loc, code, type, op0);\n+  if (tem)\n+    return tem;\n+\n   if (TREE_CODE_CLASS (code) == tcc_unary)\n     {\n       if (TREE_CODE (arg0) == COMPOUND_EXPR)\n@@ -7790,24 +7967,14 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n \t    }\n \t}\n \n-      tem = fold_convert_const (code, type, arg0);\n-      return tem ? tem : NULL_TREE;\n-\n-    case ADDR_SPACE_CONVERT_EXPR:\n-      if (integer_zerop (arg0))\n-\treturn fold_convert_const (code, type, arg0);\n       return NULL_TREE;\n \n-    case FIXED_CONVERT_EXPR:\n-      tem = fold_convert_const (code, type, arg0);\n-      return tem ? tem : NULL_TREE;\n-\n     case VIEW_CONVERT_EXPR:\n       if (TREE_CODE (op0) == MEM_REF)\n \treturn fold_build2_loc (loc, MEM_REF, type,\n \t\t\t\tTREE_OPERAND (op0, 0), TREE_OPERAND (op0, 1));\n \n-      return fold_view_convert_expr (type, op0);\n+      return NULL_TREE;\n \n     case NEGATE_EXPR:\n       tem = fold_negate_expr (loc, arg0);\n@@ -7816,11 +7983,9 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n       return NULL_TREE;\n \n     case ABS_EXPR:\n-      if (TREE_CODE (arg0) == INTEGER_CST || TREE_CODE (arg0) == REAL_CST)\n-\treturn fold_abs_const (arg0, type);\n       /* Convert fabs((double)float) into (double)fabsf(float).  */\n-      else if (TREE_CODE (arg0) == NOP_EXPR\n-\t       && TREE_CODE (type) == REAL_TYPE)\n+      if (TREE_CODE (arg0) == NOP_EXPR\n+\t  && TREE_CODE (type) == REAL_TYPE)\n \t{\n \t  tree targ0 = strip_float_extensions (arg0);\n \t  if (targ0 != arg0)\n@@ -7854,22 +8019,13 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n \t  return fold_build2_loc (loc, COMPLEX_EXPR, type, rpart,\n \t\t\t      negate_expr (ipart));\n \t}\n-      if (TREE_CODE (arg0) == COMPLEX_CST)\n-\t{\n-\t  tree itype = TREE_TYPE (type);\n-\t  tree rpart = fold_convert_loc (loc, itype, TREE_REALPART (arg0));\n-\t  tree ipart = fold_convert_loc (loc, itype, TREE_IMAGPART (arg0));\n-\t  return build_complex (type, rpart, negate_expr (ipart));\n-\t}\n       if (TREE_CODE (arg0) == CONJ_EXPR)\n \treturn fold_convert_loc (loc, type, TREE_OPERAND (arg0, 0));\n       return NULL_TREE;\n \n     case BIT_NOT_EXPR:\n-      if (TREE_CODE (arg0) == INTEGER_CST)\n-        return fold_not_const (arg0, type);\n       /* Convert ~ (-A) to A - 1.  */\n-      else if (INTEGRAL_TYPE_P (type) && TREE_CODE (arg0) == NEGATE_EXPR)\n+      if (INTEGRAL_TYPE_P (type) && TREE_CODE (arg0) == NEGATE_EXPR)\n \treturn fold_build2_loc (loc, MINUS_EXPR, type,\n \t\t\t    fold_convert_loc (loc, type, TREE_OPERAND (arg0, 0)),\n \t\t\t    build_int_cst (type, 1));\n@@ -7897,25 +8053,6 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n \treturn fold_build2_loc (loc, BIT_XOR_EXPR, type,\n \t\t\t    fold_convert_loc (loc, type,\n \t\t\t\t\t      TREE_OPERAND (arg0, 0)), tem);\n-      /* Perform BIT_NOT_EXPR on each element individually.  */\n-      else if (TREE_CODE (arg0) == VECTOR_CST)\n-\t{\n-\t  tree *elements;\n-\t  tree elem;\n-\t  unsigned count = VECTOR_CST_NELTS (arg0), i;\n-\n-\t  elements = XALLOCAVEC (tree, count);\n-\t  for (i = 0; i < count; i++)\n-\t    {\n-\t      elem = VECTOR_CST_ELT (arg0, i);\n-\t      elem = fold_unary_loc (loc, BIT_NOT_EXPR, TREE_TYPE (type), elem);\n-\t      if (elem == NULL_TREE)\n-\t\tbreak;\n-\t      elements[i] = elem;\n-\t    }\n-\t  if (i == count)\n-\t    return build_vector (type, elements);\n-\t}\n \n       return NULL_TREE;\n \n@@ -7932,8 +8069,6 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n     case REALPART_EXPR:\n       if (TREE_CODE (TREE_TYPE (arg0)) != COMPLEX_TYPE)\n \treturn fold_convert_loc (loc, type, arg0);\n-      if (TREE_CODE (arg0) == COMPLEX_CST)\n-\treturn fold_convert_loc (loc, type, TREE_REALPART (arg0));\n       if (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n \t{\n \t  tree itype = TREE_TYPE (TREE_TYPE (arg0));\n@@ -7972,8 +8107,6 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n     case IMAGPART_EXPR:\n       if (TREE_CODE (TREE_TYPE (arg0)) != COMPLEX_TYPE)\n \treturn build_zero_cst (type);\n-      if (TREE_CODE (arg0) == COMPLEX_CST)\n-\treturn fold_convert_loc (loc, type, TREE_IMAGPART (arg0));\n       if (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n \t{\n \t  tree itype = TREE_TYPE (TREE_TYPE (arg0));\n@@ -8021,76 +8154,6 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n \t}\n       return NULL_TREE;\n \n-    case VEC_UNPACK_LO_EXPR:\n-    case VEC_UNPACK_HI_EXPR:\n-    case VEC_UNPACK_FLOAT_LO_EXPR:\n-    case VEC_UNPACK_FLOAT_HI_EXPR:\n-      {\n-\tunsigned int nelts = TYPE_VECTOR_SUBPARTS (type), i;\n-\ttree *elts;\n-\tenum tree_code subcode;\n-\n-\tgcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0)) == nelts * 2);\n-\tif (TREE_CODE (arg0) != VECTOR_CST)\n-\t  return NULL_TREE;\n-\n-\telts = XALLOCAVEC (tree, nelts * 2);\n-\tif (!vec_cst_ctor_to_array (arg0, elts))\n-\t  return NULL_TREE;\n-\n-\tif ((!BYTES_BIG_ENDIAN) ^ (code == VEC_UNPACK_LO_EXPR\n-\t\t\t\t   || code == VEC_UNPACK_FLOAT_LO_EXPR))\n-\t  elts += nelts;\n-\n-\tif (code == VEC_UNPACK_LO_EXPR || code == VEC_UNPACK_HI_EXPR)\n-\t  subcode = NOP_EXPR;\n-\telse\n-\t  subcode = FLOAT_EXPR;\n-\n-\tfor (i = 0; i < nelts; i++)\n-\t  {\n-\t    elts[i] = fold_convert_const (subcode, TREE_TYPE (type), elts[i]);\n-\t    if (elts[i] == NULL_TREE || !CONSTANT_CLASS_P (elts[i]))\n-\t      return NULL_TREE;\n-\t  }\n-\n-\treturn build_vector (type, elts);\n-      }\n-\n-    case REDUC_MIN_EXPR:\n-    case REDUC_MAX_EXPR:\n-    case REDUC_PLUS_EXPR:\n-      {\n-\tunsigned int nelts, i;\n-\ttree *elts;\n-\tenum tree_code subcode;\n-\n-\tif (TREE_CODE (op0) != VECTOR_CST)\n-\t  return NULL_TREE;\n-        nelts = TYPE_VECTOR_SUBPARTS (TREE_TYPE (op0));\n-\n-\telts = XALLOCAVEC (tree, nelts);\n-\tif (!vec_cst_ctor_to_array (op0, elts))\n-\t  return NULL_TREE;\n-\n-\tswitch (code)\n-\t  {\n-\t  case REDUC_MIN_EXPR: subcode = MIN_EXPR; break;\n-\t  case REDUC_MAX_EXPR: subcode = MAX_EXPR; break;\n-\t  case REDUC_PLUS_EXPR: subcode = PLUS_EXPR; break;\n-\t  default: gcc_unreachable ();\n-\t  }\n-\n-\tfor (i = 1; i < nelts; i++)\n-\t  {\n-\t    elts[0] = const_binop (subcode, elts[0], elts[i]);\n-\t    if (elts[0] == NULL_TREE || !CONSTANT_CLASS_P (elts[0]))\n-\t      return NULL_TREE;\n-\t  }\n-\n-\treturn elts[0];\n-      }\n-\n     default:\n       return NULL_TREE;\n     } /* switch (code) */\n@@ -9689,19 +9752,13 @@ fold_binary_loc (location_t loc,\n \n   /* Note that TREE_CONSTANT isn't enough: static var addresses are\n      constant but we can't do arithmetic on them.  */\n-  if ((TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST)\n-      || (TREE_CODE (arg0) == REAL_CST && TREE_CODE (arg1) == REAL_CST)\n-      || (TREE_CODE (arg0) == FIXED_CST && TREE_CODE (arg1) == FIXED_CST)\n-      || (TREE_CODE (arg0) == FIXED_CST && TREE_CODE (arg1) == INTEGER_CST)\n-      || (TREE_CODE (arg0) == COMPLEX_CST && TREE_CODE (arg1) == COMPLEX_CST)\n-      || (TREE_CODE (arg0) == VECTOR_CST && TREE_CODE (arg1) == VECTOR_CST)\n-      || (TREE_CODE (arg0) == VECTOR_CST && TREE_CODE (arg1) == INTEGER_CST))\n+  if (CONSTANT_CLASS_P (arg0) && CONSTANT_CLASS_P (arg1))\n     {\n       if (kind == tcc_binary)\n \t{\n \t  /* Make sure type and arg0 have the same saturating flag.  */\n-\t  gcc_assert (TYPE_SATURATING (type)\n-\t\t      == TYPE_SATURATING (TREE_TYPE (arg0)));\n+\t  gcc_checking_assert (TYPE_SATURATING (type)\n+\t\t\t       == TYPE_SATURATING (TREE_TYPE (arg0)));\n \t  tem = const_binop (code, arg0, arg1);\n \t}\n       else if (kind == tcc_comparison)"}, {"sha": "31c5984ae65af6621c9db9d1f5c989a2ec43c91c", "filename": "gcc/fold-const.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8006f46bdd8be581f287ed7d1c2d204c608fb426/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8006f46bdd8be581f287ed7d1c2d204c608fb426/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=8006f46bdd8be581f287ed7d1c2d204c608fb426", "patch": "@@ -169,5 +169,7 @@ extern bool merge_ranges (int *, tree *, tree *, int, tree, tree, int,\n \t\t\t  tree, tree);\n extern tree sign_bit_p (tree, const_tree);\n extern tree exact_inverse (tree, tree);\n+extern tree const_unop (enum tree_code, tree, tree);\n+extern tree const_binop (enum tree_code, tree, tree, tree);\n \n #endif // GCC_FOLD_CONST_H"}, {"sha": "4bd4a48c55cbeaab840ef14b417c8e171eab64c8", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8006f46bdd8be581f287ed7d1c2d204c608fb426/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8006f46bdd8be581f287ed7d1c2d204c608fb426/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=8006f46bdd8be581f287ed7d1c2d204c608fb426", "patch": "@@ -94,7 +94,7 @@ gimple_resimplify1 (gimple_seq *seq,\n     {\n       tree tem = NULL_TREE;\n       if (res_code->is_tree_code ())\n-\ttem = fold_unary_to_constant (*res_code, type, res_ops[0]);\n+\ttem = const_unop (*res_code, type, res_ops[0]);\n       else\n \t{\n \t  tree decl = builtin_decl_implicit (*res_code);\n@@ -150,8 +150,7 @@ gimple_resimplify2 (gimple_seq *seq,\n     {\n       tree tem = NULL_TREE;\n       if (res_code->is_tree_code ())\n-\ttem = fold_binary_to_constant (*res_code, type,\n-\t\t\t\t       res_ops[0], res_ops[1]);\n+\ttem = const_binop (*res_code, type, res_ops[0], res_ops[1]);\n       else\n \t{\n \t  tree decl = builtin_decl_implicit (*res_code);\n@@ -386,7 +385,7 @@ gimple_simplify (enum tree_code code, tree type,\n {\n   if (constant_for_folding (op0))\n     {\n-      tree res = fold_unary_to_constant (code, type, op0);\n+      tree res = const_unop (code, type, op0);\n       if (res != NULL_TREE\n \t  && CONSTANT_CLASS_P (res))\n \treturn res;\n@@ -409,7 +408,7 @@ gimple_simplify (enum tree_code code, tree type,\n {\n   if (constant_for_folding (op0) && constant_for_folding (op1))\n     {\n-      tree res = fold_binary_to_constant (code, type, op0, op1);\n+      tree res = const_binop (code, type, op0, op1);\n       if (res != NULL_TREE\n \t  && CONSTANT_CLASS_P (res))\n \treturn res;"}]}