{"sha": "2056c5ede5306b0a0ad948d8409c5f7484ee65bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA1NmM1ZWRlNTMwNmIwYTBhZDk0OGQ4NDA5YzVmNzQ4NGVlNjViZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-11-30T11:50:53Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-11-30T11:50:53Z"}, "message": "gigi.h (create_var_decl): Adjust prototype.\n\n\t* gcc-interface/gigi.h (create_var_decl): Adjust prototype.\n\t(create_subprog_decl): Likewise.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Variable>: Rename\n\tstatic_p into static_flag and add volatile_flag local variable.\n\tDo not locally change the type of a volatile object, except for the\n\tpointed-to type if the object is handled by reference.  Adjust calls\n\tto create_var_decl.\n\t<E_Subprogram_Type>: Likewise for const and noreturn subprograms.\n\t(get_minimal_subprog_decl): Adjust call to create_subprog_decl.\n\t(elaborate_expression_1): Adjust call to create_var_decl.\n\t(gnat_to_gnu_field): Minor tweak.\n\t* gcc-interface/trans.c (gigi): Adjust calls to create_var_decl and\n\tcreate_subprog_decl.\n\t(build_raise_check): Likewise.\n\t(Subprogram_Body_to_gnu): Likewise.\n\t(create_temporary): Likewise.\n\t(Handled_Sequence_Of_Statements_to_gnu): Likewise.\n\t(Exception_Handler_to_gnu_gcc): Likewise.\n\t(Compilation_Unit_to_gnu): Likewise.\n\t(gnat_to_gnu): Likewise.\n\t* gcc-interface/utils.c (maybe_pad_type): Likewise.\n\t(create_var_decl): Add VOLATILE_FLAG parameter and handle it.\n\t(create_subprog_decl): Add CONST_FLAG and VOLATILE_FLAG parameters and\n\thandle them.\n\nFrom-SVN: r231065", "tree": {"sha": "dcd71d54265ff238bf0e079a7cf34b93eac626bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcd71d54265ff238bf0e079a7cf34b93eac626bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2056c5ede5306b0a0ad948d8409c5f7484ee65bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2056c5ede5306b0a0ad948d8409c5f7484ee65bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2056c5ede5306b0a0ad948d8409c5f7484ee65bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2056c5ede5306b0a0ad948d8409c5f7484ee65bf/comments", "author": null, "committer": null, "parents": [{"sha": "933a73251d95fb930028cb76eee7a892f41f867b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/933a73251d95fb930028cb76eee7a892f41f867b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/933a73251d95fb930028cb76eee7a892f41f867b"}], "stats": {"total": 339, "additions": 187, "deletions": 152}, "files": [{"sha": "34b12caa154f36fd6a11eaa811ebf0028bac12db", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2056c5ede5306b0a0ad948d8409c5f7484ee65bf/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2056c5ede5306b0a0ad948d8409c5f7484ee65bf/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2056c5ede5306b0a0ad948d8409c5f7484ee65bf", "patch": "@@ -1,3 +1,30 @@\n+2015-11-30  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (create_var_decl): Adjust prototype.\n+\t(create_subprog_decl): Likewise.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Variable>: Rename\n+\tstatic_p into static_flag and add volatile_flag local variable.\n+\tDo not locally change the type of a volatile object, except for the\n+\tpointed-to type if the object is handled by reference.  Adjust calls\n+\tto create_var_decl.\n+\t<E_Subprogram_Type>: Likewise for const and noreturn subprograms.\n+\t(get_minimal_subprog_decl): Adjust call to create_subprog_decl.\n+\t(elaborate_expression_1): Adjust call to create_var_decl.\n+\t(gnat_to_gnu_field): Minor tweak.\n+\t* gcc-interface/trans.c (gigi): Adjust calls to create_var_decl and\n+\tcreate_subprog_decl.\n+\t(build_raise_check): Likewise.\n+\t(Subprogram_Body_to_gnu): Likewise.\n+\t(create_temporary): Likewise.\n+\t(Handled_Sequence_Of_Statements_to_gnu): Likewise.\n+\t(Exception_Handler_to_gnu_gcc): Likewise.\n+\t(Compilation_Unit_to_gnu): Likewise.\n+\t(gnat_to_gnu): Likewise.\n+\t* gcc-interface/utils.c (maybe_pad_type): Likewise.\n+\t(create_var_decl): Add VOLATILE_FLAG parameter and handle it.\n+\t(create_subprog_decl): Add CONST_FLAG and VOLATILE_FLAG parameters and\n+\thandle them.\n+\n 2015-11-30  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/gigi.h (is_simple_additive_expression): Declare."}, {"sha": "c72e9207fe0a832caba69fd66f376135d2d38c96", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 64, "deletions": 59, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2056c5ede5306b0a0ad948d8409c5f7484ee65bf/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2056c5ede5306b0a0ad948d8409c5f7484ee65bf/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=2056c5ede5306b0a0ad948d8409c5f7484ee65bf", "patch": "@@ -598,7 +598,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t || Present (Renamed_Object (gnat_entity))\n \t\t || imported_p));\n \tbool inner_const_flag = const_flag;\n-\tbool static_p = Is_Statically_Allocated (gnat_entity);\n+\tbool static_flag = Is_Statically_Allocated (gnat_entity);\n+\t/* We implement RM 13.3(19) for exported and imported (non-constant)\n+\t   objects by making them volatile.  */\n+\tbool volatile_flag\n+\t  = (Treat_As_Volatile (gnat_entity)\n+\t     || (!const_flag && (Is_Exported (gnat_entity) || imported_p)));\n \tbool mutable_p = false;\n \tbool used_by_ref = false;\n \ttree gnu_ext_name = NULL_TREE;\n@@ -1034,10 +1039,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tif (TREE_THIS_VOLATILE (gnu_expr) && !TYPE_VOLATILE (gnu_type))\n \t\t  gnu_type\n \t\t    = change_qualified_type (gnu_type, TYPE_QUAL_VOLATILE);\n-\n \t\tgnu_type = build_reference_type (gnu_type);\n \t\tused_by_ref = true;\n \t\tconst_flag = true;\n+\t\tvolatile_flag = false;\n \t\tinner_const_flag = TREE_READONLY (gnu_expr);\n \t\tgnu_size = NULL_TREE;\n \n@@ -1068,21 +1073,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      }\n \t  }\n \n-\t/* Make a volatile version of this object's type if we are to make\n-\t   the object volatile.  We also implement RM 13.3(19) for exported\n-\t   and imported (non-constant) objects by making them volatile.  */\n-\tif ((Treat_As_Volatile (gnat_entity)\n-\t     || (!const_flag\n-\t\t && gnu_type != except_type_node\n-\t\t && (Is_Exported (gnat_entity) || imported_p)))\n-\t    && !TYPE_VOLATILE (gnu_type))\n-\t  {\n-\t    const int quals\n-\t      = TYPE_QUAL_VOLATILE\n-\t\t| (Is_Atomic_Or_VFA (gnat_entity) ? TYPE_QUAL_ATOMIC : 0);\n-\t    gnu_type = change_qualified_type (gnu_type, quals);\n-\t  }\n-\n \t/* If we are defining an aliased object whose nominal subtype is\n \t   unconstrained, the object is a record that contains both the\n \t   template and the object.  If there is an initializer, it will\n@@ -1142,13 +1132,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t    /* Convert the type of the object to a reference type that can\n \t       alias everything as per RM 13.3(19).  */\n+\t    if (volatile_flag && !TYPE_VOLATILE (gnu_type))\n+\t      gnu_type = change_qualified_type (gnu_type, TYPE_QUAL_VOLATILE);\n \t    gnu_type\n \t      = build_reference_type_for_mode (gnu_type, ptr_mode, true);\n \t    gnu_address = convert (gnu_type, gnu_address);\n \t    used_by_ref = true;\n \t    const_flag\n-\t      = !Is_Public (gnat_entity)\n-\t\t|| compile_time_known_address_p (gnat_expr);\n+\t      = (!Is_Public (gnat_entity)\n+\t\t || compile_time_known_address_p (gnat_expr));\n+\t    volatile_flag = false;\n \t    gnu_size = NULL_TREE;\n \n \t    /* If this is an aliased object with an unconstrained array nominal\n@@ -1210,9 +1203,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  {\n \t    /* Convert the type of the object to a reference type that can\n \t       alias everything as per RM 13.3(19).  */\n+\t    if (volatile_flag && !TYPE_VOLATILE (gnu_type))\n+\t      gnu_type = change_qualified_type (gnu_type, TYPE_QUAL_VOLATILE);\n \t    gnu_type\n \t      = build_reference_type_for_mode (gnu_type, ptr_mode, true);\n \t    used_by_ref = true;\n+\t    const_flag = false;\n+\t    volatile_flag = false;\n \t    gnu_size = NULL_TREE;\n \n \t    /* No point in taking the address of an initializing expression\n@@ -1248,19 +1245,22 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (!allocatable_size_p (TYPE_SIZE_UNIT (gnu_type),\n \t\t\t\t global_bindings_p ()\n \t\t\t\t || !definition\n-\t\t\t\t || static_p)\n+\t\t\t\t || static_flag)\n \t    || (gnu_size\n \t\t&& !allocatable_size_p (convert (sizetype,\n \t\t\t\t\t\t size_binop\n \t\t\t\t\t\t (CEIL_DIV_EXPR, gnu_size,\n \t\t\t\t\t\t  bitsize_unit_node)),\n \t\t\t\t\tglobal_bindings_p ()\n \t\t\t\t\t|| !definition\n-\t\t\t\t\t|| static_p)))\n+\t\t\t\t\t|| static_flag)))\n \t  {\n+\t    if (volatile_flag && !TYPE_VOLATILE (gnu_type))\n+\t      gnu_type = change_qualified_type (gnu_type, TYPE_QUAL_VOLATILE);\n \t    gnu_type = build_reference_type (gnu_type);\n \t    used_by_ref = true;\n \t    const_flag = true;\n+\t    volatile_flag = false;\n \t    gnu_size = NULL_TREE;\n \n \t    /* In case this was a aliased object whose nominal subtype is\n@@ -1314,7 +1314,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   a variable of \"aligning type\".  */\n \tif (definition\n \t    && !global_bindings_p ()\n-\t    && !static_p\n+\t    && !static_flag\n \t    && !imported_p\n \t    && TYPE_ALIGN (gnu_type) > BIGGEST_ALIGNMENT)\n \t  {\n@@ -1326,9 +1326,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t    BIGGEST_ALIGNMENT, 0, gnat_entity);\n \t    tree gnu_new_var\n \t      = create_var_decl (create_concat_name (gnat_entity, \"ALIGN\"),\n-\t\t\t\t NULL_TREE, gnu_new_type, NULL_TREE, false,\n-\t\t\t\t false, false, false, true, debug_info_p,\n-\t\t\t\t NULL, gnat_entity);\n+\t\t\t\t NULL_TREE, gnu_new_type, NULL_TREE,\n+\t\t\t\t false, false, false, false, false,\n+\t\t\t\t true, debug_info_p, NULL, gnat_entity);\n \n \t    /* Initialize the aligned field if we have an initializer.  */\n \t    if (gnu_expr)\n@@ -1351,6 +1351,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t    used_by_ref = true;\n \t    const_flag = true;\n+\t    volatile_flag = false;\n \t    gnu_size = NULL_TREE;\n \t  }\n \n@@ -1375,13 +1376,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t   = create_var_decl (concat_name (gnu_entity_name, \"UNC\"),\n \t\t\t\t      NULL_TREE, gnu_type, gnu_expr,\n \t\t\t\t      const_flag, Is_Public (gnat_entity),\n-\t\t\t\t      imported_p || !definition, static_p,\n-\t\t\t\t      true, debug_info_p, NULL, gnat_entity);\n+\t\t\t\t      imported_p || !definition, static_flag,\n+\t\t\t\t      volatile_flag, true, debug_info_p,\n+\t\t\t\t      NULL, gnat_entity);\n \t\tgnu_expr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_unc_var);\n \t\tTREE_CONSTANT (gnu_expr) = 1;\n \n \t\tused_by_ref = true;\n \t\tconst_flag = true;\n+\t\tvolatile_flag = false;\n \t\tinner_const_flag = TREE_READONLY (gnu_unc_var);\n \t\tgnu_size = NULL_TREE;\n \t      }\n@@ -1408,15 +1411,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t/* If this is an aggregate constant initialized to a constant, force it\n \t   to be statically allocated.  This saves an initialization copy.  */\n-\tif (!static_p\n+\tif (!static_flag\n \t    && const_flag\n \t    && gnu_expr && TREE_CONSTANT (gnu_expr)\n \t    && AGGREGATE_TYPE_P (gnu_type)\n \t    && tree_fits_uhwi_p (TYPE_SIZE_UNIT (gnu_type))\n \t    && !(TYPE_IS_PADDING_P (gnu_type)\n \t\t && !tree_fits_uhwi_p (TYPE_SIZE_UNIT\n \t\t\t\t       (TREE_TYPE (TYPE_FIELDS (gnu_type))))))\n-\t  static_p = true;\n+\t  static_flag = true;\n \n \t/* Deal with a pragma Linker_Section on a constant or variable.  */\n \tif ((kind == E_Constant || kind == E_Variable)\n@@ -1428,9 +1431,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tgnu_decl\n \t  = create_var_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n \t\t\t     gnu_expr, const_flag, Is_Public (gnat_entity),\n-\t\t\t     imported_p || !definition, static_p,\n-\t\t\t     artificial_p, debug_info_p, attr_list,\n-\t\t\t     gnat_entity, !renamed_obj);\n+\t\t\t     imported_p || !definition, static_flag,\n+\t\t\t     volatile_flag, artificial_p, debug_info_p,\n+\t\t\t     attr_list, gnat_entity, !renamed_obj);\n \tDECL_BY_REF_P (gnu_decl) = used_by_ref;\n \tDECL_POINTS_TO_READONLY_P (gnu_decl) = used_by_ref && inner_const_flag;\n \tDECL_CAN_NEVER_BE_NULL_P (gnu_decl) = Can_Never_Be_Null (gnat_entity);\n@@ -1481,9 +1484,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    tree gnu_corr_var\n \t      = create_var_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n \t\t\t\t gnu_expr, true, Is_Public (gnat_entity),\n-\t\t\t\t !definition, static_p, artificial_p,\n-\t\t\t\t debug_info_p, attr_list, gnat_entity,\n-\t\t\t\t false);\n+\t\t\t\t !definition, static_flag, volatile_flag,\n+\t\t\t\t artificial_p, debug_info_p, attr_list,\n+\t\t\t\t gnat_entity, false);\n \n \t    SET_DECL_CONST_CORRESPONDING_VAR (gnu_decl, gnu_corr_var);\n \t  }\n@@ -1599,8 +1602,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      tree gnu_literal\n \t\t= create_var_decl (get_entity_name (gnat_literal), NULL_TREE,\n \t\t\t\t   gnu_type, gnu_value, true, false, false,\n-\t\t\t\t   false, !Comes_From_Source (gnat_literal),\n-\t\t\t\t   false, NULL, gnat_literal);\n+\t\t\t\t   false, false, artificial_p, false,\n+\t\t\t\t   NULL, gnat_literal);\n \t      save_gnu_tree (gnat_literal, gnu_literal, false);\n \t      gnu_list\n \t        = tree_cons (DECL_NAME (gnu_literal), gnu_value, gnu_list);\n@@ -3583,8 +3586,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t      = create_var_decl (create_concat_name (gnat_entity,\n \t\t\t\t\t\t\t     \"XVZ\"),\n \t\t\t\t\t NULL_TREE, sizetype, gnu_size_unit,\n-\t\t\t\t\t false, false, false, false, true,\n-\t\t\t\t\t debug_info_p, NULL, gnat_entity);\n+\t\t\t\t\t false, false, false, false, false,\n+\t\t\t\t\t true, debug_info_p,\n+\t\t\t\t\t NULL, gnat_entity);\n \t\t}\n \n \t      gnu_variant_list.release ();\n@@ -4090,10 +4094,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n           Ada subprograms that can throw have side effects since they can\n           trigger an \"abnormal\" transfer of control flow; thus they can be\n           neither \"const\" nor \"pure\" in the back-end sense.  */\n-\tbool const_flag\n-\t  = (Back_End_Exceptions ()\n-\t     && Is_Pure (gnat_entity));\n-\tbool noreturn_flag = No_Return (gnat_entity);\n+\tbool const_flag = (Back_End_Exceptions () && Is_Pure (gnat_entity));\n+\tbool volatile_flag = No_Return (gnat_entity);\n \tbool return_by_direct_ref_p = false;\n \tbool return_by_invisi_ref_p = false;\n \tbool return_unconstrained_p = false;\n@@ -4552,14 +4554,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (TREE_CODE (gnu_return_type) == VOID_TYPE || return_unconstrained_p)\n \t  const_flag = false;\n \n-\tif (const_flag || noreturn_flag)\n-\t  {\n-\t    const int quals\n-\t      = (const_flag ? TYPE_QUAL_CONST : 0)\n-\t\t| (noreturn_flag ? TYPE_QUAL_VOLATILE : 0);\n-\t    gnu_type = change_qualified_type (gnu_type, quals);\n-\t  }\n-\n \t/* If we have a builtin decl for that function, use it.  Check if the\n \t   profiles are compatible and warn if they are not.  The checker is\n \t   expected to post extra diagnostics in this case.  */\n@@ -4617,14 +4611,23 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    gnu_decl\n \t      = create_var_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n \t\t\t\t gnu_address, false, Is_Public (gnat_entity),\n-\t\t\t\t extern_flag, false, artificial_p,\n+\t\t\t\t extern_flag, false, false, artificial_p,\n \t\t\t\t debug_info_p, NULL, gnat_entity);\n \t    DECL_BY_REF_P (gnu_decl) = 1;\n \t  }\n \n \telse if (kind == E_Subprogram_Type)\n \t  {\n \t    process_attributes (&gnu_type, &attr_list, false, gnat_entity);\n+\n+\t    if (const_flag || volatile_flag)\n+\t      {\n+\t\tconst int quals\n+\t\t  = (const_flag ? TYPE_QUAL_CONST : 0)\n+\t\t     | (volatile_flag ? TYPE_QUAL_VOLATILE : 0);\n+\t\tgnu_type = change_qualified_type (gnu_type, quals);\n+\t      }\n+\n \t    gnu_decl\n \t      = create_type_decl (gnu_entity_name, gnu_type, artificial_p,\n \t\t\t\t  debug_info_p, gnat_entity);\n@@ -4633,9 +4636,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  {\n \t    gnu_decl\n \t      = create_subprog_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n-\t\t\t\t     gnu_param_list, inline_status,\n-\t\t\t\t     public_flag, extern_flag, artificial_p,\n-\t\t\t\t     debug_info_p, attr_list, gnat_entity);\n+\t\t\t\t     gnu_param_list, inline_status, const_flag,\n+\t\t\t\t     public_flag, extern_flag, volatile_flag,\n+\t\t\t\t     artificial_p, debug_info_p,\n+\t\t\t\t     attr_list, gnat_entity);\n \t    /* This is unrelated to the stub built right above.  */\n \t    DECL_STUBBED_P (gnu_decl)\n \t      = Convention (gnat_entity) == Convention_Stubbed;\n@@ -5418,8 +5422,8 @@ get_minimal_subprog_decl (Entity_Id gnat_entity)\n \n   return\n     create_subprog_decl (gnu_entity_name, gnu_ext_name, void_ftype, NULL_TREE,\n-\t\t\t is_disabled, true, true, true, false, attr_list,\n-\t\t\t gnat_entity);\n+\t\t\t is_disabled, false, true, true, false, true, false,\n+\t\t\t attr_list, gnat_entity);\n }\n \n /* Return whether the E_Subprogram_Type/E_Function/E_Procedure GNAT_ENTITY is\n@@ -6311,7 +6315,8 @@ elaborate_expression_1 (tree gnu_expr, Entity_Id gnat_entity, const char *s,\n \t= create_var_decl (create_concat_name (gnat_entity, s), NULL_TREE,\n \t\t\t   TREE_TYPE (gnu_expr), gnu_expr, true,\n \t\t\t   expr_public_p, !definition && expr_global_p,\n-\t\t\t   expr_global_p, true, need_debug, NULL, gnat_entity);\n+\t\t\t   expr_global_p, false, true, need_debug,\n+\t\t\t   NULL, gnat_entity);\n \n       /* Using this variable at debug time (if need_debug is true) requires a\n \t proper location.  The back-end will compute a location for this\n@@ -6824,7 +6829,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \t\t\t gnu_size, gnu_pos, packed, Is_Aliased (gnat_field));\n   Sloc_to_locus (Sloc (gnat_field), &DECL_SOURCE_LOCATION (gnu_field));\n   DECL_ALIASED_P (gnu_field) = Is_Aliased (gnat_field);\n-  TREE_THIS_VOLATILE (gnu_field) = TREE_SIDE_EFFECTS (gnu_field) = is_volatile;\n+  TREE_SIDE_EFFECTS (gnu_field) = TREE_THIS_VOLATILE (gnu_field) = is_volatile;\n \n   if (Ekind (gnat_field) == E_Discriminant)\n     {"}, {"sha": "a6c7d42844fde679588e057cdf86d9f52d7ac644", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2056c5ede5306b0a0ad948d8409c5f7484ee65bf/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2056c5ede5306b0a0ad948d8409c5f7484ee65bf/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=2056c5ede5306b0a0ad948d8409c5f7484ee65bf", "patch": "@@ -685,8 +685,10 @@ extern tree create_type_decl (tree name, tree type, bool artificial_p,\n    EXTERN_FLAG is nonzero when processing an external variable declaration (as\n    opposed to a definition: no storage is to be allocated for the variable).\n \n-   STATIC_FLAG is only relevant when not at top level.  In that case\n-   it indicates whether to always allocate storage to the variable.\n+   STATIC_FLAG is only relevant when not at top level and indicates whether\n+   to always allocate storage to the variable.\n+\n+   VOLATILE_FLAG is true if this variable is declared as volatile.\n \n    ARTIFICIAL_P is true if the variable was generated by the compiler.\n \n@@ -696,6 +698,7 @@ extern tree create_type_decl (tree name, tree type, bool artificial_p,\n extern tree create_var_decl (tree name, tree asm_name, tree type, tree init,\n \t\t\t     bool const_flag, bool public_flag,\n \t\t\t     bool extern_flag, bool static_flag,\n+\t\t\t     bool volatile_flag,\n \t\t\t     bool artificial_p, bool debug_info_p,\n \t\t\t     struct attrib *attr_list, Node_Id gnat_node,\n \t\t\t     bool const_decl_allowed_p = true);\n@@ -725,8 +728,8 @@ extern tree create_label_decl (tree name, Node_Id gnat_node);\n    the list of its parameters (a list of PARM_DECL nodes chained through the\n    DECL_CHAIN field).\n \n-   INLINE_STATUS, PUBLIC_FLAG, EXTERN_FLAG and ATTR_LIST are used to set the\n-   appropriate fields in the FUNCTION_DECL.\n+   INLINE_STATUS, CONST_FLAG, PUBLIC_FLAG, EXTERN_FLAG, VOLATILE_FLAG as well\n+   as ATTR_LIST are used to set the appropriate fields in the FUNCTION_DECL.\n \n    ARTIFICIAL_P is true if the subprogram was generated by the compiler.\n \n@@ -736,7 +739,8 @@ extern tree create_label_decl (tree name, Node_Id gnat_node);\n extern tree create_subprog_decl (tree name, tree asm_name, tree type,\n \t\t\t\t tree param_decl_list,\n \t\t\t\t enum inline_status_t inline_status,\n-\t\t\t\t bool public_flag, bool extern_flag,\n+\t\t\t\t bool const_flag, bool public_flag,\n+\t\t\t\t bool extern_flag, bool volatile_flag,\n \t\t\t\t bool artificial_p, bool debug_info_p,\n \t\t\t\t struct attrib *attr_list, Node_Id gnat_node);\n "}, {"sha": "eda1b3a63e8ed1f1f6b87c02d6a96e12089cc6c9", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 56, "deletions": 63, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2056c5ede5306b0a0ad948d8409c5f7484ee65bf/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2056c5ede5306b0a0ad948d8409c5f7484ee65bf/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=2056c5ede5306b0a0ad948d8409c5f7484ee65bf", "patch": "@@ -375,14 +375,14 @@ gigi (Node_Id gnat_root,\n   t = UI_To_gnu (Enumeration_Rep (gnat_literal), boolean_type_node);\n   gcc_assert (t == boolean_false_node);\n   t = create_var_decl (get_entity_name (gnat_literal), NULL_TREE,\n-\t\t       boolean_type_node, t, true, false, false, false,\n+\t\t       boolean_type_node, t, true, false, false, false, false,\n \t\t       true, false, NULL, gnat_literal);\n   save_gnu_tree (gnat_literal, t, false);\n   gnat_literal = Next_Literal (gnat_literal);\n   t = UI_To_gnu (Enumeration_Rep (gnat_literal), boolean_type_node);\n   gcc_assert (t == boolean_true_node);\n   t = create_var_decl (get_entity_name (gnat_literal), NULL_TREE,\n-\t\t       boolean_type_node, t, true, false, false, false,\n+\t\t       boolean_type_node, t, true, false, false, false, false,\n \t\t       true, false, NULL, gnat_literal);\n   save_gnu_tree (gnat_literal, t, false);\n \n@@ -397,8 +397,8 @@ gigi (Node_Id gnat_root,\n   malloc_decl\n     = create_subprog_decl (get_identifier (\"__gnat_malloc\"), NULL_TREE,\n \t\t\t   ftype,\n-\t\t\t   NULL_TREE, is_disabled, true, true, true, false,\n-\t\t\t   NULL, Empty);\n+\t\t\t   NULL_TREE, is_disabled, false, true, true, false,\n+\t\t\t   true, false, NULL, Empty);\n   DECL_IS_MALLOC (malloc_decl) = 1;\n \n   /* free is a function declaration tree for a function to free memory.  */\n@@ -407,17 +407,17 @@ gigi (Node_Id gnat_root,\n \t\t\t   build_function_type_list (void_type_node,\n \t\t\t\t\t\t     ptr_type_node,\n \t\t\t\t\t\t     NULL_TREE),\n-\t\t\t   NULL_TREE, is_disabled, true, true, true, false,\n-\t\t\t   NULL, Empty);\n+\t\t\t   NULL_TREE, is_disabled, false, true, true, false,\n+\t\t\t   true, false, NULL, Empty);\n \n   /* This is used for 64-bit multiplication with overflow checking.  */\n   int64_type = gnat_type_for_size (64, 0);\n   mulv64_decl\n     = create_subprog_decl (get_identifier (\"__gnat_mulv64\"), NULL_TREE,\n \t\t\t   build_function_type_list (int64_type, int64_type,\n \t\t\t\t\t\t     int64_type, NULL_TREE),\n-\t\t\t   NULL_TREE, is_disabled, true, true, true, false,\n-\t\t\t   NULL, Empty);\n+\t\t\t   NULL_TREE, is_disabled, false, true, true, false,\n+\t\t\t   true, false, NULL, Empty);\n \n   /* Name of the _Parent field in tagged record types.  */\n   parent_name_id = get_identifier (Get_Name_String (Name_uParent));\n@@ -440,21 +440,24 @@ gigi (Node_Id gnat_root,\n     = create_subprog_decl\n       (get_identifier (\"system__soft_links__get_jmpbuf_address_soft\"),\n        NULL_TREE, build_function_type_list (jmpbuf_ptr_type, NULL_TREE),\n-       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n+       NULL_TREE, is_disabled, false, true, true, false, true, false,\n+       NULL, Empty);\n \n   set_jmpbuf_decl\n     = create_subprog_decl\n       (get_identifier (\"system__soft_links__set_jmpbuf_address_soft\"),\n        NULL_TREE, build_function_type_list (void_type_node, jmpbuf_ptr_type,\n \t\t\t\t\t    NULL_TREE),\n-       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n+       NULL_TREE, is_disabled, false, true, true, false, true, false,\n+       NULL, Empty);\n \n   get_excptr_decl\n     = create_subprog_decl\n       (get_identifier (\"system__soft_links__get_gnat_exception\"), NULL_TREE,\n        build_function_type_list (build_pointer_type (except_type_node),\n \t\t\t\t NULL_TREE),\n-       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n+       NULL_TREE, is_disabled, false, true, true, false, true, false,\n+       NULL, Empty);\n \n   not_handled_by_others_decl = get_identifier (\"not_handled_by_others\");\n   for (t = TYPE_FIELDS (except_type_node); t; t = DECL_CHAIN (t))\n@@ -472,7 +475,8 @@ gigi (Node_Id gnat_root,\n       (get_identifier (\"__builtin_setjmp\"), NULL_TREE,\n        build_function_type_list (integer_type_node, jmpbuf_ptr_type,\n \t\t\t\t NULL_TREE),\n-       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n+       NULL_TREE, is_disabled, false, true, true, false, true, false,\n+       NULL, Empty);\n   DECL_BUILT_IN_CLASS (setjmp_decl) = BUILT_IN_NORMAL;\n   DECL_FUNCTION_CODE (setjmp_decl) = BUILT_IN_SETJMP;\n \n@@ -482,62 +486,55 @@ gigi (Node_Id gnat_root,\n     = create_subprog_decl\n       (get_identifier (\"__builtin_update_setjmp_buf\"), NULL_TREE,\n        build_function_type_list (void_type_node, jmpbuf_ptr_type, NULL_TREE),\n-       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n+       NULL_TREE, is_disabled, false, true, true, false, true, false,\n+       NULL, Empty);\n   DECL_BUILT_IN_CLASS (update_setjmp_buf_decl) = BUILT_IN_NORMAL;\n   DECL_FUNCTION_CODE (update_setjmp_buf_decl) = BUILT_IN_UPDATE_SETJMP_BUF;\n \n+  /* Indicate that it never returns.  */\n   raise_nodefer_decl\n     = create_subprog_decl\n       (get_identifier (\"__gnat_raise_nodefer_with_msg\"), NULL_TREE,\n        build_function_type_list (void_type_node,\n \t\t\t\t build_pointer_type (except_type_node),\n \t\t\t\t NULL_TREE),\n-       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n-\n-  /* Indicate that it never returns.  */\n-  TREE_THIS_VOLATILE (raise_nodefer_decl) = 1;\n-  TREE_SIDE_EFFECTS (raise_nodefer_decl) = 1;\n-  TREE_TYPE (raise_nodefer_decl)\n-    = build_qualified_type (TREE_TYPE (raise_nodefer_decl),\n-\t\t\t    TYPE_QUAL_VOLATILE);\n+       NULL_TREE, is_disabled, false, true, true, true, true, false,\n+       NULL, Empty);\n \n+  /* Indicate that these never return.  */\n   reraise_zcx_decl\n     = create_subprog_decl (get_identifier (\"__gnat_reraise_zcx\"), NULL_TREE,\n \t\t\t   ftype, NULL_TREE,\n-\t\t\t   is_disabled, true, true, true, false,\n+\t\t\t   is_disabled, false, true, true, true, true, false,\n \t\t\t   NULL, Empty);\n-  /* Indicate that these never return.  */\n-  TREE_THIS_VOLATILE (reraise_zcx_decl) = 1;\n-  TREE_SIDE_EFFECTS (reraise_zcx_decl) = 1;\n-  TREE_TYPE (reraise_zcx_decl)\n-    = build_qualified_type (TREE_TYPE (reraise_zcx_decl), TYPE_QUAL_VOLATILE);\n \n   set_exception_parameter_decl\n     = create_subprog_decl\n       (get_identifier (\"__gnat_set_exception_parameter\"), NULL_TREE,\n        build_function_type_list (void_type_node, ptr_type_node, ptr_type_node,\n \t\t\t\t NULL_TREE),\n-       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n+       NULL_TREE, is_disabled, false, true, true, false, true, false,\n+       NULL, Empty);\n \n   /* Hooks to call when entering/leaving an exception handler.  */\n   ftype = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n \n   begin_handler_decl\n     = create_subprog_decl (get_identifier (\"__gnat_begin_handler\"), NULL_TREE,\n \t\t\t   ftype, NULL_TREE,\n-\t\t\t   is_disabled, true, true, true, false,\n+\t\t\t   is_disabled, false, true, true, false, true, false,\n \t\t\t   NULL, Empty);\n \n   end_handler_decl\n     = create_subprog_decl (get_identifier (\"__gnat_end_handler\"), NULL_TREE,\n \t\t\t   ftype, NULL_TREE,\n-\t\t\t   is_disabled, true, true, true, false,\n+\t\t\t   is_disabled, false, true, true, false, true, false,\n \t\t\t   NULL, Empty);\n \n   unhandled_except_decl\n     = create_subprog_decl (get_identifier (\"__gnat_unhandled_except_handler\"),\n \t\t\t   NULL_TREE, ftype, NULL_TREE,\n-\t\t\t   is_disabled, true, true, true, false,\n+\t\t\t   is_disabled, false, true, true, false, true, false,\n \t\t\t   NULL, Empty);\n \n   /* Dummy objects to materialize \"others\" and \"all others\" in the exception\n@@ -547,21 +544,21 @@ gigi (Node_Id gnat_root,\n     = create_var_decl (get_identifier (\"OTHERS\"),\n \t\t       get_identifier (\"__gnat_others_value\"),\n \t\t       unsigned_char_type_node, NULL_TREE,\n-\t\t       true, false, true, false, true, false,\n+\t\t       true, false, true, false, false, true, false,\n \t\t       NULL, Empty);\n \n   all_others_decl\n     = create_var_decl (get_identifier (\"ALL_OTHERS\"),\n \t\t       get_identifier (\"__gnat_all_others_value\"),\n \t\t       unsigned_char_type_node, NULL_TREE,\n-\t\t       true, false, true, false, true, false,\n+\t\t       true, false, true, false, false, true, false,\n \t\t       NULL, Empty);\n \n   unhandled_others_decl\n     = create_var_decl (get_identifier (\"UNHANDLED_OTHERS\"),\n \t\t       get_identifier (\"__gnat_unhandled_others_value\"),\n \t\t       unsigned_char_type_node, NULL_TREE,\n-\t\t       true, false, true, false, true, false,\n+\t\t       true, false, true, false, false, true, false,\n \t\t       NULL, Empty);\n \n   /* If in no exception handlers mode, all raise statements are redirected to\n@@ -576,11 +573,8 @@ gigi (Node_Id gnat_root,\n \t\t\t\t     build_pointer_type\n \t\t\t\t     (unsigned_char_type_node),\n \t\t\t\t     integer_type_node, NULL_TREE),\n-\t   NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n-      TREE_THIS_VOLATILE (decl) = 1;\n-      TREE_SIDE_EFFECTS (decl) = 1;\n-      TREE_TYPE (decl)\n-\t= build_qualified_type (TREE_TYPE (decl), TYPE_QUAL_VOLATILE);\n+\t   NULL_TREE, is_disabled, false, true, true, true, true, false,\n+\t   NULL, Empty);\n       for (i = 0; i < (int) ARRAY_SIZE (gnat_raise_decls); i++)\n \tgnat_raise_decls[i] = decl;\n     }\n@@ -742,18 +736,13 @@ build_raise_check (int check, enum exception_info_kind kind)\n \t\t\t\t    t, t, NULL_TREE);\n     }\n \n+  /* Indicate that it never returns.  */\n   result\n-    = create_subprog_decl (get_identifier (Name_Buffer),\n-\t\t\t   NULL_TREE, ftype, NULL_TREE,\n-\t\t\t   is_disabled, true, true, true, false,\n+    = create_subprog_decl (get_identifier (Name_Buffer), NULL_TREE,\n+\t\t\t   ftype, NULL_TREE,\n+\t\t\t   is_disabled, false, true, true, true, true, false,\n \t\t\t   NULL, Empty);\n \n-  /* Indicate that it never returns.  */\n-  TREE_THIS_VOLATILE (result) = 1;\n-  TREE_SIDE_EFFECTS (result) = 1;\n-  TREE_TYPE (result)\n-    = build_qualified_type (TREE_TYPE (result), TYPE_QUAL_VOLATILE);\n-\n   return result;\n }\n \f\n@@ -3827,9 +3816,9 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \n \t  gnu_return_var\n \t    = create_var_decl (get_identifier (\"RETVAL\"), NULL_TREE,\n-\t\t\t       gnu_return_type, NULL_TREE, false, false,\n-\t\t\t       false, false, true, false,\n-\t\t\t       NULL, gnat_subprog_id);\n+\t\t\t       gnu_return_type, NULL_TREE,\n+\t\t\t       false, false, false, false, false,\n+\t\t\t       true, false, NULL, gnat_subprog_id);\n \t  TREE_VALUE (gnu_return_var_elmt) = gnu_return_var;\n \t}\n \n@@ -4230,9 +4219,11 @@ atomic_access_required_p (Node_Id gnat_node, bool *sync)\n static tree\n create_temporary (const char *prefix, tree type)\n {\n-  tree gnu_temp = create_var_decl (create_tmp_var_name (prefix), NULL_TREE,\n-\t\t\t\t   type, NULL_TREE, false, false, false, false,\n-\t\t\t\t   true, false, NULL, Empty);\n+  tree gnu_temp\n+    = create_var_decl (create_tmp_var_name (prefix), NULL_TREE,\n+\t\t      type, NULL_TREE,\n+\t\t      false, false, false, false, false,\n+\t\t      true, false, NULL, Empty);\n   return gnu_temp;\n }\n \n@@ -5008,7 +4999,7 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n \t= create_var_decl (get_identifier (\"JMPBUF_SAVE\"), NULL_TREE,\n \t\t\t   jmpbuf_ptr_type,\n \t\t\t   build_call_n_expr (get_jmpbuf_decl, 0),\n-\t\t\t   false, false, false, false, true, false,\n+\t\t\t   false, false, false, false, false, true, false,\n \t\t\t   NULL, gnat_node);\n \n       /* The __builtin_setjmp receivers will immediately reinstall it.  Now\n@@ -5020,7 +5011,7 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n \t= create_var_decl (get_identifier (\"JMP_BUF\"), NULL_TREE,\n \t\t\t   jmpbuf_type,\n \t\t\t   NULL_TREE,\n-\t\t\t   false, false, false, false, true, false,\n+\t\t\t   false, false, false, false, false, true, false,\n \t\t\t   NULL, gnat_node);\n \n       set_block_jmpbuf_decl (gnu_jmpbuf_decl);\n@@ -5084,8 +5075,8 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n \t\t     create_var_decl (get_identifier (\"EXCEPT_PTR\"), NULL_TREE,\n \t\t\t\t      build_pointer_type (except_type_node),\n \t\t\t\t      build_call_n_expr (get_excptr_decl, 0),\n-\t\t\t\t      false, false, false, false, true, false,\n-\t\t\t\t      NULL, gnat_node));\n+\t\t\t\t      false, false, false, false, false,\n+\t\t\t\t      true, false, NULL, gnat_node));\n \n       /* Generate code for each handler. The N_Exception_Handler case does the\n \t real work and returns a COND_EXPR for each handler, which we chain\n@@ -5334,7 +5325,7 @@ Exception_Handler_to_gnu_gcc (Node_Id gnat_node)\n   gnu_incoming_exc_ptr\n     = create_var_decl (get_identifier (\"EXPTR\"), NULL_TREE,\n \t\t       ptr_type_node, gnu_current_exc_ptr,\n-\t\t       false, false, false, false, true, true,\n+\t\t       false, false, false, false, false, true, true,\n \t\t       NULL, gnat_node);\n \n   add_stmt_with_node (build_call_n_expr (begin_handler_decl, 1,\n@@ -5381,7 +5372,8 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n   tree gnu_elab_proc_decl\n     = create_subprog_decl\n       (create_concat_name (gnat_unit_entity, body_p ? \"elabb\" : \"elabs\"),\n-       NULL_TREE, void_ftype, NULL_TREE, is_disabled, true, false, true, true,\n+       NULL_TREE, void_ftype, NULL_TREE,\n+       is_disabled, false, true, false, false, true, true,\n        NULL, gnat_unit);\n   struct elab_info *info;\n \n@@ -6410,7 +6402,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t (Entity (Prefix (gnat_node)),\n \t\t\t\t  attr == Attr_Elab_Body ? \"elabb\" : \"elabs\"),\n \t\t\t\t NULL_TREE, void_ftype, NULL_TREE, is_disabled,\n-\t\t\t\t true, true, true, true, NULL, gnat_node);\n+\t\t\t\t false, true, true, false, true, true,\n+\t\t\t\t NULL, gnat_node);\n \n \tgnu_result = Attribute_to_gnu (gnat_node, &gnu_result_type, attr);\n       }\n@@ -7379,8 +7372,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t deallocated.  */\n       gnu_expr = create_var_decl (get_identifier (\"SAVED_EXPTR\"), NULL_TREE,\n \t\t\t\t  ptr_type_node, gnu_incoming_exc_ptr,\n-\t\t\t\t  false, false, false, false, true, true,\n-\t\t\t\t  NULL, gnat_node);\n+\t\t\t\t  false, false, false, false, false,\n+\t\t\t\t  true, true, NULL, gnat_node);\n \n       add_stmt (build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_incoming_exc_ptr,\n \t\t\t\t convert (ptr_type_node, integer_zero_node)));"}, {"sha": "10d3e22668a82964c2e63175db19f646b5fbffaf", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2056c5ede5306b0a0ad948d8409c5f7484ee65bf/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2056c5ede5306b0a0ad948d8409c5f7484ee65bf/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=2056c5ede5306b0a0ad948d8409c5f7484ee65bf", "patch": "@@ -1369,7 +1369,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \t    = create_var_decl (concat_name (name, \"XVZ\"), NULL_TREE, sizetype,\n \t\t\t      size_unit, true, global_bindings_p (),\n \t\t\t      !definition && global_bindings_p (), false,\n-\t\t\t      true, true, NULL, gnat_entity);\n+\t\t\t      false, true, true, NULL, gnat_entity);\n \t  TYPE_SIZE_UNIT (record) = size_unit;\n \t}\n \n@@ -2335,8 +2335,10 @@ create_type_decl (tree name, tree type, bool artificial_p, bool debug_info_p,\n    EXTERN_FLAG is true when processing an external variable declaration (as\n    opposed to a definition: no storage is to be allocated for the variable).\n \n-   STATIC_FLAG is only relevant when not at top level.  In that case\n-   it indicates whether to always allocate storage to the variable.\n+   STATIC_FLAG is only relevant when not at top level and indicates whether\n+   to always allocate storage to the variable.\n+\n+   VOLATILE_FLAG is true if this variable is declared as volatile.\n \n    ARTIFICIAL_P is true if the variable was generated by the compiler.\n \n@@ -2347,9 +2349,9 @@ create_type_decl (tree name, tree type, bool artificial_p, bool debug_info_p,\n tree\n create_var_decl (tree name, tree asm_name, tree type, tree init,\n \t\t bool const_flag, bool public_flag, bool extern_flag,\n-\t\t bool static_flag, bool artificial_p, bool debug_info_p,\n-\t\t struct attrib *attr_list, Node_Id gnat_node,\n-\t\t bool const_decl_allowed_p)\n+\t\t bool static_flag, bool volatile_flag, bool artificial_p,\n+\t\t bool debug_info_p, struct attrib *attr_list,\n+\t\t Node_Id gnat_node, bool const_decl_allowed_p)\n {\n   /* Whether the object has static storage duration, either explicitly or by\n      virtue of being declared at the global level.  */\n@@ -2406,16 +2408,6 @@ create_var_decl (tree name, tree asm_name, tree type, tree init,\n   /* Directly set some flags.  */\n   DECL_ARTIFICIAL (var_decl) = artificial_p;\n   DECL_EXTERNAL (var_decl) = extern_flag;\n-  TREE_CONSTANT (var_decl) = constant_p;\n-  TREE_READONLY (var_decl) = const_flag;\n-\n-  /* We need to allocate static storage for an object with static storage\n-     duration if it isn't external.  */\n-  TREE_STATIC (var_decl) = !extern_flag && static_storage;\n-\n-  /* The object is public if it is external or if it is declared public\n-     and has static storage duration.  */\n-  TREE_PUBLIC (var_decl) = extern_flag || (public_flag && static_storage);\n \n   /* Ada doesn't feature Fortran-like COMMON variables so we shouldn't\n      try to fiddle with DECL_COMMON.  However, on platforms that don't\n@@ -2441,8 +2433,20 @@ create_var_decl (tree name, tree asm_name, tree type, tree init,\n \t     != null_pointer_node))\n     DECL_IGNORED_P (var_decl) = 1;\n \n-  if (TYPE_VOLATILE (type))\n-    TREE_SIDE_EFFECTS (var_decl) = TREE_THIS_VOLATILE (var_decl) = 1;\n+  TREE_CONSTANT (var_decl) = constant_p;\n+  TREE_READONLY (var_decl) = const_flag;\n+\n+  /* The object is public if it is external or if it is declared public\n+     and has static storage duration.  */\n+  TREE_PUBLIC (var_decl) = extern_flag || (public_flag && static_storage);\n+\n+  /* We need to allocate static storage for an object with static storage\n+     duration if it isn't external.  */\n+  TREE_STATIC (var_decl) = !extern_flag && static_storage;\n+\n+  TREE_SIDE_EFFECTS (var_decl)\n+    = TREE_THIS_VOLATILE (var_decl)\n+    = TYPE_VOLATILE (type) | volatile_flag;\n \n   if (TREE_SIDE_EFFECTS (var_decl))\n     TREE_ADDRESSABLE (var_decl) = 1;\n@@ -3044,8 +3048,8 @@ create_label_decl (tree name, Node_Id gnat_node)\n    the list of its parameters (a list of PARM_DECL nodes chained through the\n    DECL_CHAIN field).\n \n-   INLINE_STATUS, PUBLIC_FLAG, EXTERN_FLAG and ATTR_LIST are used to set the\n-   appropriate fields in the FUNCTION_DECL.\n+   INLINE_STATUS, CONST_FLAG, PUBLIC_FLAG, EXTERN_FLAG, VOLATILE_FLAG as well\n+   as ATTR_LIST are used to set the appropriate fields in the FUNCTION_DECL.\n \n    ARTIFICIAL_P is true if the subprogram was generated by the compiler.\n \n@@ -3055,8 +3059,9 @@ create_label_decl (tree name, Node_Id gnat_node)\n \n tree\n create_subprog_decl (tree name, tree asm_name, tree type, tree param_decl_list,\n-\t\t     enum inline_status_t inline_status, bool public_flag,\n-\t\t     bool extern_flag, bool artificial_p, bool debug_info_p,\n+\t\t     enum inline_status_t inline_status, bool const_flag,\n+\t\t     bool public_flag, bool extern_flag, bool volatile_flag,\n+\t\t     bool artificial_p, bool debug_info_p,\n \t\t     struct attrib *attr_list, Node_Id gnat_node)\n {\n   tree subprog_decl = build_decl (input_location, FUNCTION_DECL, name, type);\n@@ -3097,10 +3102,11 @@ create_subprog_decl (tree name, tree asm_name, tree type, tree param_decl_list,\n   if (!debug_info_p)\n     DECL_IGNORED_P (subprog_decl) = 1;\n \n+  TREE_READONLY (subprog_decl) = TYPE_READONLY (type) | const_flag;\n   TREE_PUBLIC (subprog_decl) = public_flag;\n-  TREE_READONLY (subprog_decl) = TYPE_READONLY (type);\n-  TREE_THIS_VOLATILE (subprog_decl) = TYPE_VOLATILE (type);\n-  TREE_SIDE_EFFECTS (subprog_decl) = TYPE_VOLATILE (type);\n+  TREE_SIDE_EFFECTS (subprog_decl)\n+    = TREE_THIS_VOLATILE (subprog_decl)\n+    = TYPE_VOLATILE (type) | volatile_flag;\n \n   DECL_ARTIFICIAL (result_decl) = 1;\n   DECL_IGNORED_P (result_decl) = 1;"}]}