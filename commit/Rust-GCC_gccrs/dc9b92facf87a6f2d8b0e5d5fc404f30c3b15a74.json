{"sha": "dc9b92facf87a6f2d8b0e5d5fc404f30c3b15a74", "node_id": "C_kwDOANBUbNoAKGRjOWI5MmZhY2Y4N2E2ZjJkOGIwZTVkNWZjNDA0ZjMwYzNiMTVhNzQ", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2022-02-15T08:47:52Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2022-06-15T18:21:52Z"}, "message": "libstdc++: [_Hashtable] Insert range of types convertible to value_type PR 105717\n\nFix insertion of range of instances convertible to value_type.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/105717\n\t* include/bits/hashtable_policy.h (_ConvertToValueType): New.\n\t* include/bits/hashtable.h (_Hashtable<>::_M_insert_unique_aux): New.\n\t(_Hashtable<>::_M_insert(_Arg&&, const _NodeGenerator&, true_type)): Use latters.\n\t(_Hashtable<>::_M_insert(_Arg&&, const _NodeGenerator&, false_type)): Likewise.\n\t(_Hashtable(_InputIterator, _InputIterator, size_type, const _Hash&, const _Equal&,\n\tconst allocator_type&, true_type)): Use this.insert range.\n\t(_Hashtable(_InputIterator, _InputIterator, size_type, const _Hash&, const _Equal&,\n\tconst allocator_type&, false_type)): Use _M_insert.\n\t* testsuite/23_containers/unordered_map/cons/56112.cc: Check how many times conversion\n\tis done.\n\t* testsuite/23_containers/unordered_map/insert/105717.cc: New test.\n\t* testsuite/23_containers/unordered_set/insert/105717.cc: New test.", "tree": {"sha": "95c4d41b34dc6e916d89672541364d4deed646af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95c4d41b34dc6e916d89672541364d4deed646af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc9b92facf87a6f2d8b0e5d5fc404f30c3b15a74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc9b92facf87a6f2d8b0e5d5fc404f30c3b15a74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc9b92facf87a6f2d8b0e5d5fc404f30c3b15a74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc9b92facf87a6f2d8b0e5d5fc404f30c3b15a74/comments", "author": null, "committer": null, "parents": [{"sha": "636b01ab4910da0b96d844301fea1a2b56c5344d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/636b01ab4910da0b96d844301fea1a2b56c5344d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/636b01ab4910da0b96d844301fea1a2b56c5344d"}], "stats": {"total": 243, "additions": 227, "deletions": 16}, "files": [{"sha": "1b21b795f8912cb85fa1cacd736f4bd7e68ce312", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc9b92facf87a6f2d8b0e5d5fc404f30c3b15a74/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc9b92facf87a6f2d8b0e5d5fc404f30c3b15a74/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=dc9b92facf87a6f2d8b0e5d5fc404f30c3b15a74", "patch": "@@ -899,21 +899,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       template<typename _Arg, typename _NodeGenerator>\n \tstd::pair<iterator, bool>\n-\t_M_insert(_Arg&& __arg, const _NodeGenerator& __node_gen,\n-\t\t  true_type /* __uks */)\n+\t_M_insert_unique_aux(_Arg&& __arg, const _NodeGenerator& __node_gen)\n \t{\n \t  return _M_insert_unique(\n \t    _S_forward_key(_ExtractKey{}(std::forward<_Arg>(__arg))),\n \t    std::forward<_Arg>(__arg), __node_gen);\n \t}\n \n+      template<typename _Arg, typename _NodeGenerator>\n+\tstd::pair<iterator, bool>\n+\t_M_insert(_Arg&& __arg, const _NodeGenerator& __node_gen,\n+\t\t  true_type /* __uks */)\n+\t{\n+\t  using __to_value\n+\t    = __detail::_ConvertToValueType<_ExtractKey, value_type>;\n+\t  return _M_insert_unique_aux(\n+\t    __to_value{}(std::forward<_Arg>(__arg)), __node_gen);\n+\t}\n+\n       template<typename _Arg, typename _NodeGenerator>\n \titerator\n \t_M_insert(_Arg&& __arg, const _NodeGenerator& __node_gen,\n \t\t  false_type __uks)\n \t{\n-\t  return _M_insert(cend(), std::forward<_Arg>(__arg), __node_gen,\n-\t\t\t   __uks);\n+\t  using __to_value\n+\t    = __detail::_ConvertToValueType<_ExtractKey, value_type>;\n+\t  return _M_insert(cend(),\n+\t    __to_value{}(std::forward<_Arg>(__arg)), __node_gen, __uks);\n \t}\n \n       // Insert with hint, not used when keys are unique.\n@@ -1185,10 +1197,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t const _Hash& __h, const _Equal& __eq,\n \t\t const allocator_type& __a, true_type /* __uks */)\n       : _Hashtable(__bkt_count_hint, __h, __eq, __a)\n-      {\n-\tfor (; __f != __l; ++__f)\n-\t  this->insert(*__f);\n-      }\n+      { this->insert(__f, __l); }\n \n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n@@ -1200,7 +1209,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Hashtable(_InputIterator __f, _InputIterator __l,\n \t\t size_type __bkt_count_hint,\n \t\t const _Hash& __h, const _Equal& __eq,\n-\t\t const allocator_type& __a, false_type /* __uks */)\n+\t\t const allocator_type& __a, false_type __uks)\n       : _Hashtable(__h, __eq, __a)\n       {\n \tauto __nb_elems = __detail::__distance_fw(__f, __l);\n@@ -1215,8 +1224,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    _M_bucket_count = __bkt_count;\n \t  }\n \n+\t__alloc_node_gen_t __node_gen(*this);\n \tfor (; __f != __l; ++__f)\n-\t  this->insert(*__f);\n+\t  _M_insert(*__f, __node_gen, __uks);\n       }\n \n   template<typename _Key, typename _Value, typename _Alloc,"}, {"sha": "f2696ae9b07a588885e064d4c4d86d9958d31584", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc9b92facf87a6f2d8b0e5d5fc404f30c3b15a74/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc9b92facf87a6f2d8b0e5d5fc404f30c3b15a74/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=dc9b92facf87a6f2d8b0e5d5fc404f30c3b15a74", "patch": "@@ -113,6 +113,40 @@ namespace __detail\n       { return std::forward<_Tp>(__x).first; }\n   };\n \n+  template<typename _ExKey, typename _Value>\n+    struct _ConvertToValueType;\n+\n+  template<typename _Value>\n+    struct _ConvertToValueType<_Identity, _Value>\n+    {\n+      template<typename _Kt>\n+\tconstexpr _Kt&&\n+\toperator()(_Kt&& __k) const noexcept\n+\t{ return std::forward<_Kt>(__k); }\n+    };\n+\n+  template<typename _Value>\n+    struct _ConvertToValueType<_Select1st, _Value>\n+    {\n+      constexpr _Value&&\n+      operator()(_Value&& __x) const noexcept\n+      { return std::move(__x); }\n+\n+      constexpr const _Value&\n+      operator()(const _Value& __x) const noexcept\n+      { return __x; }\n+\n+      template<typename _Kt, typename _Val>\n+\tconstexpr std::pair<_Kt, _Val>&&\n+\toperator()(std::pair<_Kt, _Val>&& __x) const noexcept\n+\t{ return std::move(__x); }\n+\n+      template<typename _Kt, typename _Val>\n+\tconstexpr const std::pair<_Kt, _Val>&\n+\toperator()(const std::pair<_Kt, _Val>& __x) const noexcept\n+\t{ return __x; }\n+    };\n+\n   template<typename _ExKey>\n     struct _NodeBuilder;\n "}, {"sha": "b0eda30b4cb33e65445829c90f52dec0226f9f53", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/cons/56112.cc", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc9b92facf87a6f2d8b0e5d5fc404f30c3b15a74/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fcons%2F56112.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc9b92facf87a6f2d8b0e5d5fc404f30c3b15a74/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fcons%2F56112.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fcons%2F56112.cc?ref=dc9b92facf87a6f2d8b0e5d5fc404f30c3b15a74", "patch": "@@ -20,30 +20,51 @@\n #include <unordered_map>\n #include <utility>\n \n+#include <testsuite_hooks.h>\n+\n struct Key\n {\n   explicit Key(const int* p) : value(p) { }\n   ~Key() { value = nullptr; }\n \n-  bool operator==(const Key& k) const { return *value == *k.value; }\n+  bool operator==(const Key& k) const\n+  { return *value == *k.value; }\n \n   const int* value;\n };\n \n struct hash\n {\n-  std::size_t operator()(const Key& k) const noexcept { return *k.value; }\n+  std::size_t operator()(const Key& k) const noexcept\n+  { return *k.value; }\n };\n \n struct S\n {\n+  static int _count;\n+\n   int value;\n-  operator std::pair<const Key, int>() const { return {Key(&value), value}; }\n+  operator std::pair<const Key, int>() const\n+  {\n+    ++_count;\n+    return { Key(&value), value };\n+  }\n };\n \n-int main()\n+int S::_count = 0;\n+\n+void test01()\n {\n     S s[1] = { {2} };\n-    std::unordered_map<Key, int, hash> m(s, s+1);\n-    std::unordered_multimap<Key, int, hash> mm(s, s+1);\n+    std::unordered_map<Key, int, hash> m(s, s + 1);\n+    VERIFY( S::_count == 1 );\n+\n+    std::unordered_multimap<Key, int, hash> mm(s, s + 1);\n+    VERIFY( S::_count == 2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n }"}, {"sha": "202baa9818b9d2f3706f98db508edfd29deeabd7", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/insert/105717.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc9b92facf87a6f2d8b0e5d5fc404f30c3b15a74/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2F105717.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc9b92facf87a6f2d8b0e5d5fc404f30c3b15a74/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2F105717.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2F105717.cc?ref=dc9b92facf87a6f2d8b0e5d5fc404f30c3b15a74", "patch": "@@ -0,0 +1,73 @@\n+// { dg-do run { target c++11 } }\n+\n+// Copyright (C) 2022 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <testsuite_hooks.h>\n+\n+struct Key\n+{\n+  explicit Key(const int* p) : value(p) { }\n+  ~Key() { value = nullptr; }\n+\n+  bool operator==(const Key& k) const\n+  { return *value == *k.value; }\n+\n+  const int* value;\n+};\n+\n+struct hash\n+{\n+  std::size_t operator()(const Key& k) const noexcept\n+  { return *k.value; }\n+};\n+\n+struct S\n+{\n+  static int _count;\n+\n+  int value;\n+  operator std::pair<const Key, int>() const\n+  {\n+    ++_count;\n+    return { Key(&value), value };\n+  }\n+};\n+\n+int S::_count = 0;\n+\n+void test01()\n+{\n+    S s[1] = { {2} };\n+    std::unordered_map<Key, int, hash> m;\n+    std::unordered_multimap<Key, int, hash> mm;\n+\n+    m.insert(s, s + 1);\n+    VERIFY( S::_count == 1 );\n+\n+    mm.insert(s, s + 1);\n+    VERIFY( S::_count == 2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "ab229c5baa1015482ed92952688e88cae7972823", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/insert/105717.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc9b92facf87a6f2d8b0e5d5fc404f30c3b15a74/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2F105717.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc9b92facf87a6f2d8b0e5d5fc404f30c3b15a74/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2F105717.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2F105717.cc?ref=dc9b92facf87a6f2d8b0e5d5fc404f30c3b15a74", "patch": "@@ -0,0 +1,73 @@\n+// { dg-do run { target c++11 } }\n+\n+// Copyright (C) 2022 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_set>\n+#include <utility>\n+\n+#include <testsuite_hooks.h>\n+\n+struct Key\n+{\n+  explicit Key(const int* p) : value(p) { }\n+  ~Key() { value = nullptr; }\n+\n+  bool operator==(const Key& k) const\n+  { return *value == *k.value; }\n+\n+  const int* value;\n+};\n+\n+struct hash\n+{\n+  std::size_t operator()(const Key& k) const noexcept\n+  { return *k.value; }\n+};\n+\n+struct S\n+{\n+  static int _count;\n+\n+  int value;\n+  operator Key() const\n+  {\n+    ++_count;\n+    return Key(&value);\n+  }\n+};\n+\n+int S::_count = 0;\n+\n+void test01()\n+{\n+    S a[1] = { {2} };\n+    std::unordered_set<Key, hash> s;\n+    std::unordered_multiset<Key, hash> ms;\n+\n+    s.insert(a, a + 1);\n+    VERIFY( S::_count == 1 );\n+\n+    ms.insert(a, a + 1);\n+    VERIFY( S::_count == 2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}