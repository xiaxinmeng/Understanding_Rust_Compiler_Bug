{"sha": "90988f773c8e516007ead0d0d602a7c1708ddc23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA5ODhmNzczYzhlNTE2MDA3ZWFkMGQwZDYwMmE3YzE3MDhkZGMyMw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2015-01-12T08:47:26Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2015-01-12T08:47:26Z"}, "message": "cgraph_edge refactoring.\n\n\t* cgraph.c (cgraph_edge::remove_callee): Move function to header\n\tfile for being inlined.\n\t(cgraph_set_edge_callee): Delete.\n\t(cgraph_edge::redirect_callee): Move function to header file\n\tfor being inlined.\n\t(cgraph_edge::make_direct): Use new function.\n\t(cgraph_edge::dump_edge_flags): New function created from\n\tstatic dump_edge_flags function.\n\t(cgraph_node::dump): Use new function.\n\t(cgraph_edge::verify_count_and_frequency): New function created\n\tfrom verify_edge_count_and_frequency.\n\t(cgraph_edge::verify_corresponds_to_fndecl): New function created\n\tfrom verify_edge_corresponds_to_fndecl.\n\t(verify_edge_corresponds_to_fndecl): Delete.\n\t(cgraph_node::verify_node): Use new function.\n\t* cgraph.h (cgraph_edge::set_callee): New function.\n\t(cgraph_edge::dump_edge_flags): Likewise.\n\t(cgraph_edge::verify_corresponds_to_fndecl): Likewise.\n\nFrom-SVN: r219448", "tree": {"sha": "b6f94f7e64d65df1361e011532e113c8e06636ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6f94f7e64d65df1361e011532e113c8e06636ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90988f773c8e516007ead0d0d602a7c1708ddc23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90988f773c8e516007ead0d0d602a7c1708ddc23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90988f773c8e516007ead0d0d602a7c1708ddc23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90988f773c8e516007ead0d0d602a7c1708ddc23/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6e7bdfacf2a5fe99a2d5eb31a860eb2ba681554b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e7bdfacf2a5fe99a2d5eb31a860eb2ba681554b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e7bdfacf2a5fe99a2d5eb31a860eb2ba681554b"}], "stats": {"total": 211, "additions": 122, "deletions": 89}, "files": [{"sha": "1abad52e9c240136d3040943d2ac73cd0392541e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90988f773c8e516007ead0d0d602a7c1708ddc23/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90988f773c8e516007ead0d0d602a7c1708ddc23/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=90988f773c8e516007ead0d0d602a7c1708ddc23", "patch": "@@ -1,3 +1,24 @@\n+2015-01-12  Martin Liska  <mliska@suse.cz>\n+\n+\t* cgraph.c (cgraph_edge::remove_callee): Move function to header\n+\tfile for being inlined.\n+\t(cgraph_set_edge_callee): Delete.\n+\t(cgraph_edge::redirect_callee): Move function to header file\n+\tfor being inlined.\n+\t(cgraph_edge::make_direct): Use new function.\n+\t(cgraph_edge::dump_edge_flags): New function created from\n+\tstatic dump_edge_flags function.\n+\t(cgraph_node::dump): Use new function.\n+\t(cgraph_edge::verify_count_and_frequency): New function created\n+\tfrom verify_edge_count_and_frequency.\n+\t(cgraph_edge::verify_corresponds_to_fndecl): New function created\n+\tfrom verify_edge_corresponds_to_fndecl.\n+\t(verify_edge_corresponds_to_fndecl): Delete.\n+\t(cgraph_node::verify_node): Use new function.\n+\t* cgraph.h (cgraph_edge::set_callee): New function.\n+\t(cgraph_edge::dump_edge_flags): Likewise.\n+\t(cgraph_edge::verify_corresponds_to_fndecl): Likewise.\n+\n 2015-01-11  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-utils.c (estimate_function_body_sizes): Do not"}, {"sha": "f3f7fece0c05225539f3bfeaf1624d70ff57998f", "filename": "gcc/cgraph.c", "status": "modified", "additions": 46, "deletions": 89, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90988f773c8e516007ead0d0d602a7c1708ddc23/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90988f773c8e516007ead0d0d602a7c1708ddc23/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=90988f773c8e516007ead0d0d602a7c1708ddc23", "patch": "@@ -965,20 +965,6 @@ cgraph_node::create_indirect_edge (gcall *call_stmt, int ecf_flags,\n   return edge;\n }\n \n-/* Remove the edge from the list of the callers of the callee.  */\n-\n-void\n-cgraph_edge::remove_callee (void)\n-{\n-  gcc_assert (!indirect_unknown_callee);\n-  if (prev_caller)\n-    prev_caller->next_caller = next_caller;\n-  if (next_caller)\n-    next_caller->prev_caller = prev_caller;\n-  if (!prev_caller)\n-    callee->callers = next_caller;\n-}\n-\n /* Remove the edge from the list of the callees of the caller.  */\n \n void\n@@ -1037,20 +1023,6 @@ cgraph_edge::remove (void)\n   symtab->free_edge (this);\n }\n \n-/* Set callee of call graph edge E and add it to the corresponding set of\n-   callers. */\n-\n-static void\n-cgraph_set_edge_callee (cgraph_edge *e, cgraph_node *n)\n-{\n-  e->prev_caller = NULL;\n-  if (n->callers)\n-    n->callers->prev_caller = e;\n-  e->next_caller = n->callers;\n-  n->callers = e;\n-  e->callee = n;\n-}\n-\n /* Turn edge into speculative call calling N2. Update\n    the profile so the direct call is taken COUNT times\n    with FREQUENCY.  \n@@ -1165,19 +1137,6 @@ cgraph_edge::speculative_call_info (cgraph_edge *&direct,\n   gcc_assert (e && e2 && ref);\n }\n \n-/* Redirect callee of the edge to N.  The function does not update underlying\n-   call expression.  */\n-\n-void\n-cgraph_edge::redirect_callee (cgraph_node *n)\n-{\n-  /* Remove from callers list of the current callee.  */\n-  remove_callee ();\n-\n-  /* Insert to callers list of the new callee.  */\n-  cgraph_set_edge_callee (this, n);\n-}\n-\n /* Speculative call edge turned out to be direct call to CALLE_DECL.\n    Remove the speculative call sequence and return edge representing the call.\n    It is up to caller to redirect the call as appropriate. */\n@@ -1284,7 +1243,7 @@ cgraph_edge::make_direct (cgraph_node *callee)\n   caller->callees = edge;\n \n   /* Insert to callers list of the new callee.  */\n-  cgraph_set_edge_callee (edge, callee);\n+  edge->set_callee (callee);\n \n   if (call_stmt)\n     call_stmt_cannot_inline_p\n@@ -1948,24 +1907,22 @@ cgraph_inline_failed_type (cgraph_inline_failed_t reason)\n const char * const cgraph_availability_names[] =\n   {\"unset\", \"not_available\", \"overwritable\", \"available\", \"local\"};\n \n-/* Output flags of edge E.  */\n+/* Output flags of edge to a file F.  */\n \n-static void\n-dump_edge_flags (FILE *f, struct cgraph_edge *edge)\n+void\n+cgraph_edge::dump_edge_flags (FILE *f)\n {\n-  if (edge->speculative)\n+  if (speculative)\n     fprintf (f, \"(speculative) \");\n-  if (!edge->inline_failed)\n+  if (!inline_failed)\n     fprintf (f, \"(inlined) \");\n-  if (edge->indirect_inlining_edge)\n+  if (indirect_inlining_edge)\n     fprintf (f, \"(indirect_inlining) \");\n-  if (edge->count)\n-    fprintf (f, \"(%\"PRId64\"x) \",\n-\t     (int64_t)edge->count);\n-  if (edge->frequency)\n-    fprintf (f, \"(%.2f per call) \",\n-\t     edge->frequency / (double)CGRAPH_FREQ_BASE);\n-  if (edge->can_throw_external)\n+  if (count)\n+    fprintf (f, \"(%\"PRId64\"x) \", (int64_t)count);\n+  if (frequency)\n+    fprintf (f, \"(%.2f per call) \", frequency / (double)CGRAPH_FREQ_BASE);\n+  if (can_throw_external)\n     fprintf (f, \"(can throw external) \");\n }\n \n@@ -2057,15 +2014,15 @@ cgraph_node::dump (FILE *f)\n     {\n       fprintf (f, \"%s/%i \", edge->caller->asm_name (),\n \t       edge->caller->order);\n-      dump_edge_flags (f, edge);\n+      edge->dump_edge_flags (f);\n     }\n \n   fprintf (f, \"\\n  Calls: \");\n   for (edge = callees; edge; edge = edge->next_callee)\n     {\n       fprintf (f, \"%s/%i \", edge->callee->asm_name (),\n \t       edge->callee->order);\n-      dump_edge_flags (f, edge);\n+      edge->dump_edge_flags (f);\n     }\n   fprintf (f, \"\\n\");\n \n@@ -2079,7 +2036,7 @@ cgraph_node::dump (FILE *f)\n \t}\n       else\n         fprintf (f, \"   Indirect call\");\n-      dump_edge_flags (f, edge);\n+      edge->dump_edge_flags (f);\n       if (edge->indirect_info->param_index != -1)\n \t{\n \t  fprintf (f, \" of param:%i\", edge->indirect_info->param_index);\n@@ -2638,44 +2595,44 @@ clone_of_p (cgraph_node *node, cgraph_node *node2)\n   return node2 != NULL;\n }\n \n-/* Verify edge E count and frequency.  */\n+/* Verify edge count and frequency.  */\n \n-static bool\n-verify_edge_count_and_frequency (cgraph_edge *e)\n+bool\n+cgraph_edge::verify_count_and_frequency ()\n {\n   bool error_found = false;\n-  if (e->count < 0)\n+  if (count < 0)\n     {\n       error (\"caller edge count is negative\");\n       error_found = true;\n     }\n-  if (e->frequency < 0)\n+  if (frequency < 0)\n     {\n       error (\"caller edge frequency is negative\");\n       error_found = true;\n     }\n-  if (e->frequency > CGRAPH_FREQ_MAX)\n+  if (frequency > CGRAPH_FREQ_MAX)\n     {\n       error (\"caller edge frequency is too large\");\n       error_found = true;\n     }\n-  if (gimple_has_body_p (e->caller->decl)\n-      && !e->caller->global.inlined_to\n-      && !e->speculative\n+  if (gimple_has_body_p (caller->decl)\n+      && !caller->global.inlined_to\n+      && !speculative\n       /* FIXME: Inline-analysis sets frequency to 0 when edge is optimized out.\n \t Remove this once edges are actually removed from the function at that time.  */\n-      && (e->frequency\n+      && (frequency\n \t  || (inline_edge_summary_vec.exists ()\n-\t      && ((inline_edge_summary_vec.length () <= (unsigned) e->uid)\n-\t          || !inline_edge_summary (e)->predicate)))\n-      && (e->frequency\n-\t  != compute_call_stmt_bb_frequency (e->caller->decl,\n-\t\t\t\t\t     gimple_bb (e->call_stmt))))\n+\t      && ((inline_edge_summary_vec.length () <= (unsigned) uid)\n+\t          || !inline_edge_summary (this)->predicate)))\n+      && (frequency\n+\t  != compute_call_stmt_bb_frequency (caller->decl,\n+\t\t\t\t\t     gimple_bb (call_stmt))))\n     {\n       error (\"caller edge frequency %i does not match BB frequency %i\",\n-\t     e->frequency,\n-\t     compute_call_stmt_bb_frequency (e->caller->decl,\n-\t\t\t\t\t     gimple_bb (e->call_stmt)));\n+\t     frequency,\n+\t     compute_call_stmt_bb_frequency (caller->decl,\n+\t\t\t\t\t     gimple_bb (call_stmt)));\n       error_found = true;\n     }\n   return error_found;\n@@ -2700,15 +2657,15 @@ cgraph_debug_gimple_stmt (function *this_cfun, gimple stmt)\n     current_function_decl = NULL;\n }\n \n-/* Verify that call graph edge E corresponds to DECL from the associated\n+/* Verify that call graph edge corresponds to DECL from the associated\n    statement.  Return true if the verification should fail.  */\n \n-static bool\n-verify_edge_corresponds_to_fndecl (cgraph_edge *e, tree decl)\n+bool\n+cgraph_edge::verify_corresponds_to_fndecl (tree decl)\n {\n   cgraph_node *node;\n \n-  if (!decl || e->callee->global.inlined_to)\n+  if (!decl || callee->global.inlined_to)\n     return false;\n   if (symtab->state == LTO_STREAMING)\n     return false;\n@@ -2722,20 +2679,20 @@ verify_edge_corresponds_to_fndecl (cgraph_edge *e, tree decl)\n       || node->body_removed\n       || node->in_other_partition\n       || node->icf_merged\n-      || e->callee->in_other_partition)\n+      || callee->in_other_partition)\n     return false;\n \n   node = node->ultimate_alias_target ();\n \n   /* Optimizers can redirect unreachable calls or calls triggering undefined\n      behaviour to builtin_unreachable.  */\n-  if (DECL_BUILT_IN_CLASS (e->callee->decl) == BUILT_IN_NORMAL\n-      && DECL_FUNCTION_CODE (e->callee->decl) == BUILT_IN_UNREACHABLE)\n+  if (DECL_BUILT_IN_CLASS (callee->decl) == BUILT_IN_NORMAL\n+      && DECL_FUNCTION_CODE (callee->decl) == BUILT_IN_UNREACHABLE)\n     return false;\n \n-  if (e->callee->former_clone_of != node->decl\n-      && (node != e->callee->ultimate_alias_target ())\n-      && !clone_of_p (node, e->callee))\n+  if (callee->former_clone_of != node->decl\n+      && (node != callee->ultimate_alias_target ())\n+      && !clone_of_p (node, callee))\n     return true;\n   else\n     return false;\n@@ -2815,7 +2772,7 @@ cgraph_node::verify_node (void)\n   bool check_comdat = comdat_local_p ();\n   for (e = callers; e; e = e->next_caller)\n     {\n-      if (verify_edge_count_and_frequency (e))\n+      if (e->verify_count_and_frequency ())\n \terror_found = true;\n       if (check_comdat\n \t  && !in_same_comdat_group_p (e->caller))\n@@ -2847,7 +2804,7 @@ cgraph_node::verify_node (void)\n \t  }\n     }\n   for (e = indirect_calls; e; e = e->next_callee)\n-    if (verify_edge_count_and_frequency (e))\n+    if (e->verify_count_and_frequency ())\n       error_found = true;\n   if (!callers && global.inlined_to)\n     {\n@@ -3052,7 +3009,7 @@ cgraph_node::verify_node (void)\n \t\t\t    }\n \t\t\t  if (!e->indirect_unknown_callee)\n \t\t\t    {\n-\t\t\t      if (verify_edge_corresponds_to_fndecl (e, decl))\n+\t\t\t      if (e->verify_corresponds_to_fndecl (decl))\n \t\t\t\t{\n \t\t\t\t  error (\"edge points to wrong declaration:\");\n \t\t\t\t  debug_tree (e->callee->decl);"}, {"sha": "e3e29d0be5c033f2b59bebee061ba30f732c11a2", "filename": "gcc/cgraph.h", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90988f773c8e516007ead0d0d602a7c1708ddc23/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90988f773c8e516007ead0d0d602a7c1708ddc23/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=90988f773c8e516007ead0d0d602a7c1708ddc23", "patch": "@@ -1524,6 +1524,9 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n   cgraph_edge * clone (cgraph_node *n, gcall *call_stmt, unsigned stmt_uid,\n \t\t       gcov_type count_scale, int freq_scale, bool update_original);\n \n+  /* Verify edge count and frequency.  */\n+  bool verify_count_and_frequency ();\n+\n   /* Return true when call of edge can not lead to return from caller\n      and thus it is safe to ignore its side effects for IPA analysis\n      when computing side effects of the caller.  */\n@@ -1606,6 +1609,17 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n \n   /* Remove the edge from the list of the callees of the caller.  */\n   void remove_callee (void);\n+\n+  /* Set callee N of call graph edge and add it to the corresponding set of\n+     callers. */\n+  void set_callee (cgraph_node *n);\n+\n+  /* Output flags of edge to a file F.  */\n+  void dump_edge_flags (FILE *f);\n+\n+  /* Verify that call graph edge corresponds to DECL from the associated\n+     statement.  Return true if the verification should fail.  */\n+  bool verify_corresponds_to_fndecl (tree decl);\n };\n \n #define CGRAPH_FREQ_BASE 1000\n@@ -2719,6 +2733,33 @@ varpool_node::ultimate_alias_target (availability *availability)\n   return n;\n }\n \n+/* Set callee N of call graph edge and add it to the corresponding set of\n+   callers. */\n+\n+inline void\n+cgraph_edge::set_callee (cgraph_node *n)\n+{\n+  prev_caller = NULL;\n+  if (n->callers)\n+    n->callers->prev_caller = this;\n+  next_caller = n->callers;\n+  n->callers = this;\n+  callee = n;\n+}\n+\n+/* Redirect callee of the edge to N.  The function does not update underlying\n+   call expression.  */\n+\n+inline void\n+cgraph_edge::redirect_callee (cgraph_node *n)\n+{\n+  /* Remove from callers list of the current callee.  */\n+  remove_callee ();\n+\n+  /* Insert to callers list of the new callee.  */\n+  set_callee (n);\n+}\n+\n /* Return true when the edge represents a direct recursion.  */\n inline bool\n cgraph_edge::recursive_p (void)\n@@ -2730,6 +2771,20 @@ cgraph_edge::recursive_p (void)\n     return caller->decl == c->decl;\n }\n \n+/* Remove the edge from the list of the callers of the callee.  */\n+\n+inline void\n+cgraph_edge::remove_callee (void)\n+{\n+  gcc_assert (!indirect_unknown_callee);\n+  if (prev_caller)\n+    prev_caller->next_caller = next_caller;\n+  if (next_caller)\n+    next_caller->prev_caller = prev_caller;\n+  if (!prev_caller)\n+    callee->callers = next_caller;\n+}\n+\n /* Return true if the TM_CLONE bit is set for a given FNDECL.  */\n static inline bool\n decl_is_tm_clone (const_tree fndecl)"}]}