{"sha": "c3f34952484cfe374448d5021dfb7dedf138c9ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNmMzQ5NTI0ODRjZmUzNzQ0NDhkNTAyMWRmYjdkZWRmMTM4YzlhYg==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-11-16T21:37:43Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-11-16T21:37:43Z"}, "message": "re PR fortran/39427 (F2003: Procedures with same name as types/type constructors)\n\ngcc/fortran\n2011-11-16  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/39427\n        PR fortran/37829\n        * decl.c (match_data_constant, match_data_constant,\n        * variable_decl,\n        gfc_match_decl_type_spec, access_attr_decl,\n        check_extended_derived_type, gfc_match_derived_decl,\n        gfc_match_derived_decl, gfc_match_derived_decl) Modified to deal\n        with DT constructors.\n        * gfortran.h (gfc_find_dt_in_generic,\n        gfc_convert_to_structure_constructor): New function prototypes.\n        * interface.c (check_interface0, check_interface1,\n        gfc_search_interface): Ignore DT constructors in generic list.\n        * match.h (gfc_match_structure_constructor): Update prototype.\n        * match.c (match_derived_type_spec): Ensure that one uses the DT\n        not the generic function.\n        * module.c (MOD_VERSION): Bump.\n        (dt_lower_string, dt_upper_string): New functions.\n        (find_use_name_n, find_use_operator, compare_true_names,\n        find_true_name, add_true_name, fix_mio_expr, load_needed,\n        read_module, write_dt_extensions, write_symbol): Changes to deal with\n        different symtree vs. sym names.\n        (create_derived_type): Create also generic procedure.\n        * parse.c (gfc_fixup_sibling_symbols): Don't regard DT and\n        * generic\n        function as the same.\n        * primary.c (gfc_convert_to_structure_constructor): New\n        * function.\n        (gfc_match_structure_constructor): Restructured; calls\n        gfc_convert_to_structure_constructor.\n        (build_actual_constructor, gfc_match_rvalue): Update for DT generic\n        functions.\n        * resolve.c (resolve_formal_arglist, resolve_structure_cons,\n        is_illegal_recursion, resolve_generic_f, resolve_variable,\n        resolve_fl_variable_derived, resolve_fl_derived0,\n        resolve_symbol): Handle DT and DT generic constructors.\n        * symbol.c (gfc_use_derived, gfc_undo_symbols,\n        gen_special_c_interop_ptr, gen_cptr_param,\n        generate_isocbinding_symbol, gfc_get_derived_super_type): Handle\n        derived-types, which are hidden in the generic type.\n        (gfc_find_dt_in_generic): New function\n        * trans-array.c (gfc_conv_array_initializer): Replace\n        * FL_PARAMETER\n        expr by actual value.\n        * trans-decl.c (gfc_get_module_backend_decl,\n        * gfc_trans_use_stmts):\n        Ensure that we use the DT and not the generic function.\n        * trans-types.c (gfc_get_derived_type): Ensure that we use the\n        * DT\n        and not the generic procedure.\n\ngcc/testsuite/\n2011-11-16  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/39427\n        PR fortran/37829\n        * gfortran.dg/constructor_1.f90: New.\n        * gfortran.dg/constructor_2.f90: New.\n        * gfortran.dg/constructor_3.f90: New.\n        * gfortran.dg/constructor_4.f90: New.\n        * gfortran.dg/constructor_5.f90: New.\n        * gfortran.dg/constructor_6.f90: New.\n        * gfortran.dg/use_only_5.f90: New.\n        * gfortran.dg/c_ptr_tests_17.f90: New.\n        * gfortran.dg/c_ptr_tests_18.f90: New.\n        * gfortran.dg/used_types_25.f90: New.\n        * gfortran.dg/used_types_26.f90: New\n        * gfortran.dg/type_decl_3.f90: New.\n        * gfortran.dg/function_types_3.f90: Update dg-error.\n        * gfortran.dg/result_1.f90: Ditto.\n        * gfortran.dg/structure_constructor_3.f03: Ditto.\n        * gfortran.dg/structure_constructor_4.f03: Ditto.\n\nFrom-SVN: r181425", "tree": {"sha": "61a919d8cae4728618964335046a765c914ca292", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61a919d8cae4728618964335046a765c914ca292"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3f34952484cfe374448d5021dfb7dedf138c9ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3f34952484cfe374448d5021dfb7dedf138c9ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3f34952484cfe374448d5021dfb7dedf138c9ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3f34952484cfe374448d5021dfb7dedf138c9ab/comments", "author": null, "committer": null, "parents": [{"sha": "16e835bb5c484dfd735d5ee24c023ace800d0332", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16e835bb5c484dfd735d5ee24c023ace800d0332", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16e835bb5c484dfd735d5ee24c023ace800d0332"}], "stats": {"total": 1749, "additions": 1440, "deletions": 309}, "files": [{"sha": "cd452ab557f1423cdabce41e770a5746e4ce4bb6", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -1,3 +1,49 @@\n+2011-11-16  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/39427\n+\tPR fortran/37829\n+\t* decl.c (match_data_constant, match_data_constant, variable_decl,\n+\tgfc_match_decl_type_spec, access_attr_decl,\n+\tcheck_extended_derived_type, gfc_match_derived_decl,\n+\tgfc_match_derived_decl, gfc_match_derived_decl) Modified to deal\n+\twith DT constructors.\n+\t* gfortran.h (gfc_find_dt_in_generic,\n+\tgfc_convert_to_structure_constructor): New function prototypes.\n+\t* interface.c (check_interface0, check_interface1,\n+\tgfc_search_interface): Ignore DT constructors in generic list.\n+\t* match.h (gfc_match_structure_constructor): Update prototype.\n+\t* match.c (match_derived_type_spec): Ensure that one uses the DT\n+\tnot the generic function.\n+\t* module.c (MOD_VERSION): Bump.\n+\t(dt_lower_string, dt_upper_string): New functions.\n+\t(find_use_name_n, find_use_operator, compare_true_names,\n+\tfind_true_name, add_true_name, fix_mio_expr, load_needed,\n+\tread_module, write_dt_extensions, write_symbol): Changes to deal with\n+\tdifferent symtree vs. sym names.\n+\t(create_derived_type): Create also generic procedure.\n+\t* parse.c (gfc_fixup_sibling_symbols): Don't regard DT and generic\n+\tfunction as the same.\n+\t* primary.c (gfc_convert_to_structure_constructor): New function.\n+\t(gfc_match_structure_constructor): Restructured; calls\n+\tgfc_convert_to_structure_constructor.\n+\t(build_actual_constructor, gfc_match_rvalue): Update for DT generic\n+\tfunctions.\n+\t* resolve.c (resolve_formal_arglist, resolve_structure_cons,\n+\tis_illegal_recursion, resolve_generic_f, resolve_variable,\n+\tresolve_fl_variable_derived, resolve_fl_derived0,\n+\tresolve_symbol): Handle DT and DT generic constructors.\n+\t* symbol.c (gfc_use_derived, gfc_undo_symbols,\n+\tgen_special_c_interop_ptr, gen_cptr_param,\n+\tgenerate_isocbinding_symbol, gfc_get_derived_super_type): Handle\n+\tderived-types, which are hidden in the generic type.\n+\t(gfc_find_dt_in_generic): New function\n+\t* trans-array.c (gfc_conv_array_initializer): Replace FL_PARAMETER\n+\texpr by actual value.\n+\t* trans-decl.c (gfc_get_module_backend_decl, gfc_trans_use_stmts):\n+\tEnsure that we use the DT and not the generic function.\n+\t* trans-types.c (gfc_get_derived_type): Ensure that we use the DT\n+\tand not the generic procedure.\n+\n 2011-11-14  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/51073"}, {"sha": "3e553a38143ec7cc24bb809d3edc0dad3b849c52", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 150, "deletions": 29, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -323,7 +323,7 @@ static match\n match_data_constant (gfc_expr **result)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n-  gfc_symbol *sym;\n+  gfc_symbol *sym, *dt_sym = NULL;\n   gfc_expr *expr;\n   match m;\n   locus old_loc;\n@@ -366,15 +366,19 @@ match_data_constant (gfc_expr **result)\n   if (gfc_find_symbol (name, NULL, 1, &sym))\n     return MATCH_ERROR;\n \n+  if (sym && sym->attr.generic)\n+    dt_sym = gfc_find_dt_in_generic (sym);\n+\n   if (sym == NULL\n-      || (sym->attr.flavor != FL_PARAMETER && sym->attr.flavor != FL_DERIVED))\n+      || (sym->attr.flavor != FL_PARAMETER\n+\t  && (!dt_sym || dt_sym->attr.flavor != FL_DERIVED)))\n     {\n       gfc_error (\"Symbol '%s' must be a PARAMETER in DATA statement at %C\",\n \t\t name);\n       return MATCH_ERROR;\n     }\n-  else if (sym->attr.flavor == FL_DERIVED)\n-    return gfc_match_structure_constructor (sym, result, false);\n+  else if (dt_sym && dt_sym->attr.flavor == FL_DERIVED)\n+    return gfc_match_structure_constructor (dt_sym, result);\n \n   /* Check to see if the value is an initialization array expression.  */\n   if (sym->value->expr_type == EXPR_ARRAY)\n@@ -1954,10 +1958,10 @@ variable_decl (int elem)\n       st = gfc_find_symtree (gfc_current_ns->sym_root, current_ts.u.derived->name);\n       if (!(current_ts.u.derived->attr.imported\n \t\t&& st != NULL\n-\t\t&& st->n.sym == current_ts.u.derived)\n+\t\t&& gfc_find_dt_in_generic (st->n.sym) == current_ts.u.derived)\n \t    && !gfc_current_ns->has_import_set)\n \t{\n-\t    gfc_error (\"the type of '%s' at %C has not been declared within the \"\n+\t    gfc_error (\"The type of '%s' at %C has not been declared within the \"\n \t\t       \"interface\", name);\n \t    m = MATCH_ERROR;\n \t    goto cleanup;\n@@ -2501,10 +2505,11 @@ match\n gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n-  gfc_symbol *sym;\n+  gfc_symbol *sym, *dt_sym;\n   match m;\n   char c;\n   bool seen_deferred_kind, matched_type;\n+  const char *dt_name;\n \n   /* A belt and braces check that the typespec is correctly being treated\n      as a deferred characteristic association.  */\n@@ -2668,40 +2673,96 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n       ts->u.derived = NULL;\n       if (gfc_current_state () != COMP_INTERFACE\n \t    && !gfc_find_symbol (name, NULL, 1, &sym) && sym)\n-\tts->u.derived = sym;\n+\t{\n+\t  sym = gfc_find_dt_in_generic (sym);\n+\t  ts->u.derived = sym;\n+\t}\n       return MATCH_YES;\n     }\n \n   /* Search for the name but allow the components to be defined later.  If\n      type = -1, this typespec has been seen in a function declaration but\n-     the type could not be accessed at that point.  */\n+     the type could not be accessed at that point.  The actual derived type is\n+     stored in a symtree with the first letter of the name captialized; the\n+     symtree with the all lower-case name contains the associated\n+     generic function.  */\n+  dt_name = gfc_get_string (\"%c%s\",\n+\t\t\t    (char) TOUPPER ((unsigned char) name[0]),\n+\t\t\t    (const char*)&name[1]);\n   sym = NULL;\n-  if (ts->kind != -1 && gfc_get_ha_symbol (name, &sym))\n+  dt_sym = NULL;\n+  if (ts->kind != -1)\n     {\n-      gfc_error (\"Type name '%s' at %C is ambiguous\", name);\n-      return MATCH_ERROR;\n+      gfc_get_ha_symbol (name, &sym);\n+      if (sym->generic && gfc_find_symbol (dt_name, NULL, 0, &dt_sym))\n+\t{\n+\t  gfc_error (\"Type name '%s' at %C is ambiguous\", name);\n+\t  return MATCH_ERROR;\n+\t}\n+      if (sym->generic && !dt_sym)\n+\tdt_sym = gfc_find_dt_in_generic (sym);\n     }\n   else if (ts->kind == -1)\n     {\n       int iface = gfc_state_stack->previous->state != COMP_INTERFACE\n \t\t    || gfc_current_ns->has_import_set;\n-      if (gfc_find_symbol (name, NULL, iface, &sym))\n+      gfc_find_symbol (name, NULL, iface, &sym);\n+      if (sym && sym->generic && gfc_find_symbol (dt_name, NULL, 1, &dt_sym))\n \t{       \n \t  gfc_error (\"Type name '%s' at %C is ambiguous\", name);\n \t  return MATCH_ERROR;\n \t}\n+      if (sym && sym->generic && !dt_sym)\n+\tdt_sym = gfc_find_dt_in_generic (sym);\n \n       ts->kind = 0;\n       if (sym == NULL)\n \treturn MATCH_NO;\n     }\n \n-  if (sym->attr.flavor != FL_DERIVED\n-      && gfc_add_flavor (&sym->attr, FL_DERIVED, sym->name, NULL) == FAILURE)\n-    return MATCH_ERROR;\n+  if ((sym->attr.flavor != FL_UNKNOWN\n+       && !(sym->attr.flavor == FL_PROCEDURE && sym->attr.generic))\n+      || sym->attr.subroutine)\n+    {\n+      gfc_error (\"Type name '%s' at %C conflicts with previously declared \"\n+\t         \"entity at %L, which has the same name\", name,\n+\t\t &sym->declared_at);\n+      return MATCH_ERROR;\n+    }\n \n   gfc_set_sym_referenced (sym);\n-  ts->u.derived = sym;\n+  if (!sym->attr.generic\n+      && gfc_add_generic (&sym->attr, sym->name, NULL) == FAILURE)\n+    return MATCH_ERROR;\n+\n+  if (!sym->attr.function\n+      && gfc_add_function (&sym->attr, sym->name, NULL) == FAILURE)\n+    return MATCH_ERROR;\n+\n+  if (!dt_sym)\n+    {\n+      gfc_interface *intr, *head;\n+\n+      /* Use upper case to save the actual derived-type symbol.  */\n+      gfc_get_symbol (dt_name, NULL, &dt_sym);\n+      dt_sym->name = gfc_get_string (sym->name);\n+      head = sym->generic;\n+      intr = gfc_get_interface ();\n+      intr->sym = dt_sym;\n+      intr->where = gfc_current_locus;\n+      intr->next = head;\n+      sym->generic = intr;\n+      sym->attr.if_source = IFSRC_DECL;\n+    }\n+\n+  gfc_set_sym_referenced (dt_sym);\n+\n+  if (dt_sym->attr.flavor != FL_DERIVED\n+      && gfc_add_flavor (&dt_sym->attr, FL_DERIVED, sym->name, NULL)\n+\t\t\t == FAILURE)\n+    return MATCH_ERROR;\n+\n+  ts->u.derived = dt_sym;\n \n   return MATCH_YES;\n \n@@ -3053,6 +3114,20 @@ gfc_match_import (void)\n \t  sym->refs++;\n \t  sym->attr.imported = 1;\n \n+\t  if (sym->attr.generic && (sym = gfc_find_dt_in_generic (sym)))\n+\t    {\n+\t      /* The actual derived type is stored in a symtree with the first\n+\t\t letter of the name captialized; the symtree with the all\n+\t\t lower-case name contains the associated generic function. */\n+\t      st = gfc_new_symtree (&gfc_current_ns->sym_root,\n+\t\t\tgfc_get_string (\"%c%s\",\n+\t\t\t\t(char) TOUPPER ((unsigned char) sym->name[0]),\n+\t\t\t\t&sym->name[1]));\n+\t      st->n.sym = sym;\n+\t      sym->refs++;\n+\t      sym->attr.imported = 1;\n+\t    }\n+\n \t  goto next_item;\n \n \tcase MATCH_NO:\n@@ -6475,7 +6550,7 @@ access_attr_decl (gfc_statement st)\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   interface_type type;\n   gfc_user_op *uop;\n-  gfc_symbol *sym;\n+  gfc_symbol *sym, *dt_sym;\n   gfc_intrinsic_op op;\n   match m;\n \n@@ -6505,6 +6580,13 @@ access_attr_decl (gfc_statement st)\n \t\t\t      sym->name, NULL) == FAILURE)\n \t    return MATCH_ERROR;\n \n+\t  if (sym->attr.generic && (dt_sym = gfc_find_dt_in_generic (sym))\n+\t      && gfc_add_access (&dt_sym->attr,\n+\t\t\t\t (st == ST_PUBLIC) ? ACCESS_PUBLIC\n+\t\t\t\t\t\t   : ACCESS_PRIVATE,\n+\t\t\t\t sym->name, NULL) == FAILURE)\n+\t    return MATCH_ERROR;\n+\n \t  break;\n \n \tcase INTERFACE_INTRINSIC_OP:\n@@ -7175,6 +7257,8 @@ check_extended_derived_type (char *name)\n       return NULL;\n     }\n \n+  extended = gfc_find_dt_in_generic (extended);\n+\n   if (extended->attr.flavor != FL_DERIVED)\n     {\n       gfc_error (\"'%s' in EXTENDS expression at %C is not a \"\n@@ -7277,11 +7361,12 @@ gfc_match_derived_decl (void)\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   char parent[GFC_MAX_SYMBOL_LEN + 1];\n   symbol_attribute attr;\n-  gfc_symbol *sym;\n+  gfc_symbol *sym, *gensym;\n   gfc_symbol *extended;\n   match m;\n   match is_type_attr_spec = MATCH_NO;\n   bool seen_attr = false;\n+  gfc_interface *intr = NULL, *head;\n \n   if (gfc_current_state () == COMP_DERIVED)\n     return MATCH_NO;\n@@ -7327,16 +7412,50 @@ gfc_match_derived_decl (void)\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_get_symbol (name, NULL, &sym))\n+  if (gfc_get_symbol (name, NULL, &gensym))\n     return MATCH_ERROR;\n \n-  if (sym->ts.type != BT_UNKNOWN)\n+  if (!gensym->attr.generic && gensym->ts.type != BT_UNKNOWN)\n     {\n       gfc_error (\"Derived type name '%s' at %C already has a basic type \"\n-\t\t \"of %s\", sym->name, gfc_typename (&sym->ts));\n+\t\t \"of %s\", gensym->name, gfc_typename (&gensym->ts));\n+      return MATCH_ERROR;\n+    }\n+\n+  if (!gensym->attr.generic\n+      && gfc_add_generic (&gensym->attr, gensym->name, NULL) == FAILURE)\n+    return MATCH_ERROR;\n+\n+  if (!gensym->attr.function\n+      && gfc_add_function (&gensym->attr, gensym->name, NULL) == FAILURE)\n+    return MATCH_ERROR;\n+\n+  sym = gfc_find_dt_in_generic (gensym);\n+\n+  if (sym && (sym->components != NULL || sym->attr.zero_comp))\n+    {\n+      gfc_error (\"Derived type definition of '%s' at %C has already been \"\n+                 \"defined\", sym->name);\n       return MATCH_ERROR;\n     }\n \n+  if (!sym)\n+    {\n+      /* Use upper case to save the actual derived-type symbol.  */\n+      gfc_get_symbol (gfc_get_string (\"%c%s\",\n+\t\t\t(char) TOUPPER ((unsigned char) gensym->name[0]),\n+\t\t\t&gensym->name[1]), NULL, &sym);\n+      sym->name = gfc_get_string (gensym->name);\n+      head = gensym->generic;\n+      intr = gfc_get_interface ();\n+      intr->sym = sym;\n+      intr->where = gfc_current_locus;\n+      intr->sym->declared_at = gfc_current_locus;\n+      intr->next = head;\n+      gensym->generic = intr;\n+      gensym->attr.if_source = IFSRC_DECL;\n+    }\n+\n   /* The symbol may already have the derived attribute without the\n      components.  The ways this can happen is via a function\n      definition, an INTRINSIC statement or a subtype in another\n@@ -7346,16 +7465,18 @@ gfc_match_derived_decl (void)\n       && gfc_add_flavor (&sym->attr, FL_DERIVED, sym->name, NULL) == FAILURE)\n     return MATCH_ERROR;\n \n-  if (sym->components != NULL || sym->attr.zero_comp)\n-    {\n-      gfc_error (\"Derived type definition of '%s' at %C has already been \"\n-\t\t \"defined\", sym->name);\n-      return MATCH_ERROR;\n-    }\n-\n   if (attr.access != ACCESS_UNKNOWN\n       && gfc_add_access (&sym->attr, attr.access, sym->name, NULL) == FAILURE)\n     return MATCH_ERROR;\n+  else if (sym->attr.access == ACCESS_UNKNOWN\n+\t   && gensym->attr.access != ACCESS_UNKNOWN\n+\t   && gfc_add_access (&sym->attr, gensym->attr.access, sym->name, NULL)\n+\t      == FAILURE)\n+    return MATCH_ERROR;\n+\n+  if (sym->attr.access != ACCESS_UNKNOWN\n+      && gensym->attr.access == ACCESS_UNKNOWN)\n+    gensym->attr.access = sym->attr.access;\n \n   /* See if the derived type was labeled as bind(c).  */\n   if (attr.is_bind_c != 0)"}, {"sha": "372c056d3d1efbcb5b9302980198cc4ae919977f", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -2630,6 +2630,7 @@ gfc_try gfc_check_symbol_typed (gfc_symbol*, gfc_namespace*, bool, locus);\n gfc_namespace* gfc_find_proc_namespace (gfc_namespace*);\n \n bool gfc_is_associate_pointer (gfc_symbol*);\n+gfc_symbol * gfc_find_dt_in_generic (gfc_symbol *);\n \n /* intrinsic.c -- true if working in an init-expr, false otherwise.  */\n extern bool gfc_init_expr_flag;\n@@ -2874,6 +2875,9 @@ match gfc_match_rvalue (gfc_expr **);\n match gfc_match_varspec (gfc_expr*, int, bool, bool);\n int gfc_check_digit (char, int);\n bool gfc_is_function_return_value (gfc_symbol *, gfc_namespace *);\n+gfc_try gfc_convert_to_structure_constructor (gfc_expr *, gfc_symbol *,\n+\t\t\t\t\t      gfc_expr **,\n+\t\t\t\t\t      gfc_actual_arglist **, bool);\n \n /* trans.c */\n void gfc_generate_code (gfc_namespace *);"}, {"sha": "6d2acce378afdfc4ce2c94f16dd54c0ad7892bce", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -1262,8 +1262,9 @@ check_interface0 (gfc_interface *p, const char *interface_name)\n     {\n       /* Make sure all symbols in the interface have been defined as\n \t functions or subroutines.  */\n-      if ((!p->sym->attr.function && !p->sym->attr.subroutine)\n-\t  || !p->sym->attr.if_source)\n+      if (((!p->sym->attr.function && !p->sym->attr.subroutine)\n+\t   || !p->sym->attr.if_source)\n+\t  && p->sym->attr.flavor != FL_DERIVED)\n \t{\n \t  if (p->sym->attr.external)\n \t    gfc_error (\"Procedure '%s' in %s at %L has no explicit interface\",\n@@ -1276,11 +1277,18 @@ check_interface0 (gfc_interface *p, const char *interface_name)\n \t}\n \n       /* Verify that procedures are either all SUBROUTINEs or all FUNCTIONs.  */\n-      if ((psave->sym->attr.function && !p->sym->attr.function)\n+      if ((psave->sym->attr.function && !p->sym->attr.function\n+\t   && p->sym->attr.flavor != FL_DERIVED)\n \t  || (psave->sym->attr.subroutine && !p->sym->attr.subroutine))\n \t{\n-\t  gfc_error (\"In %s at %L procedures must be either all SUBROUTINEs\"\n-\t\t     \" or all FUNCTIONs\", interface_name, &p->sym->declared_at);\n+\t  if (p->sym->attr.flavor != FL_DERIVED)\n+\t    gfc_error (\"In %s at %L procedures must be either all SUBROUTINEs\"\n+\t\t       \" or all FUNCTIONs\", interface_name,\n+\t\t       &p->sym->declared_at);\n+\t  else\n+\t    gfc_error (\"In %s at %L procedures must be all FUNCTIONs as the \"\n+\t\t       \"generic name is also the name of a derived type\",\n+\t\t       interface_name, &p->sym->declared_at);\n \t  return 1;\n \t}\n \n@@ -1336,8 +1344,10 @@ check_interface1 (gfc_interface *p, gfc_interface *q0,\n \tif (p->sym->name == q->sym->name && p->sym->module == q->sym->module)\n \t  continue;\n \n-\tif (gfc_compare_interfaces (p->sym, q->sym, q->sym->name, generic_flag,\n-\t\t\t\t    0, NULL, 0))\n+\tif (p->sym->attr.flavor != FL_DERIVED\n+\t    && q->sym->attr.flavor != FL_DERIVED\n+\t    && gfc_compare_interfaces (p->sym, q->sym, q->sym->name,\n+\t\t\t\t       generic_flag, 0, NULL, 0))\n \t  {\n \t    if (referenced)\n \t      gfc_error (\"Ambiguous interfaces '%s' and '%s' in %s at %L\",\n@@ -3019,6 +3029,8 @@ gfc_search_interface (gfc_interface *intr, int sub_flag,\n \n   for (; intr; intr = intr->next)\n     {\n+      if (intr->sym->attr.flavor == FL_DERIVED)\n+\tcontinue;\n       if (sub_flag && intr->sym->attr.function)\n \tcontinue;\n       if (!sub_flag && intr->sym->attr.subroutine)"}, {"sha": "fbafe82cc6659e2f7c6d399217798676dc18d4ca", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -1920,6 +1920,9 @@ match_derived_type_spec (gfc_typespec *ts)\n \n   gfc_find_symbol (name, NULL, 1, &derived);\n \n+  if (derived && derived->attr.flavor == FL_PROCEDURE && derived->attr.generic)\n+    derived = gfc_find_dt_in_generic (derived);\n+\n   if (derived && derived->attr.flavor == FL_DERIVED)\n     {\n       ts->type = BT_DERIVED;"}, {"sha": "df18074c58a5a33cf0e907ae80d173eb4e242e24", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -206,7 +206,7 @@ match gfc_match_bind_c (gfc_symbol *, bool);\n match gfc_get_type_attr_spec (symbol_attribute *, char*);\n \n /* primary.c.  */\n-match gfc_match_structure_constructor (gfc_symbol *, gfc_expr **, bool);\n+match gfc_match_structure_constructor (gfc_symbol *, gfc_expr **);\n match gfc_match_variable (gfc_expr **, int);\n match gfc_match_equiv_variable (gfc_expr **);\n match gfc_match_actual_arglist (int, gfc_actual_arglist **);"}, {"sha": "7c28e8bb97cc96222d6451d2f7fe38f523b5d869", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 100, "deletions": 16, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -80,7 +80,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Don't put any single quote (') in MOD_VERSION, \n    if yout want it to be recognized.  */\n-#define MOD_VERSION \"7\"\n+#define MOD_VERSION \"8\"\n \n \n /* Structure that describes a position within a module file.  */\n@@ -429,6 +429,34 @@ resolve_fixups (fixup_t *f, void *gp)\n }\n \n \n+/* Convert a string such that it starts with a lower-case character. Used\n+   to convert the symtree name of a derived-type to the symbol name or to\n+   the name of the associated generic function.  */\n+\n+const char *\n+dt_lower_string (const char *name)\n+{\n+  if (name[0] != (char) TOLOWER ((unsigned char) name[0]))\n+    return gfc_get_string (\"%c%s\", (char) TOLOWER ((unsigned char) name[0]),\n+\t\t\t   &name[1]);\n+  return gfc_get_string (name);\n+}\n+\n+\n+/* Convert a string such that it starts with an upper-case character. Used to\n+   return the symtree-name for a derived type; the symbol name itself and the\n+   symtree/symbol name of the associated generic function start with a lower-\n+   case character.  */\n+\n+const char *\n+dt_upper_string (const char *name)\n+{\n+  if (name[0] != (char) TOUPPER ((unsigned char) name[0]))\n+    return gfc_get_string (\"%c%s\", (char) TOUPPER ((unsigned char) name[0]),\n+\t\t\t   &name[1]);\n+  return gfc_get_string (name);\n+}\n+\n /* Call here during module reading when we know what pointer to\n    associate with an integer.  Any fixups that exist are resolved at\n    this time.  */\n@@ -699,12 +727,18 @@ static const char *\n find_use_name_n (const char *name, int *inst, bool interface)\n {\n   gfc_use_rename *u;\n+  const char *low_name = NULL;\n   int i;\n \n+  /* For derived types.  */\n+  if (name[0] != (char) TOLOWER ((unsigned char) name[0]))\n+    low_name = dt_lower_string (name);\n+\n   i = 0;\n   for (u = gfc_rename_list; u; u = u->next)\n     {\n-      if (strcmp (u->use_name, name) != 0\n+      if ((!low_name && strcmp (u->use_name, name) != 0)\n+\t  || (low_name && strcmp (u->use_name, low_name) != 0)\n \t  || (u->op == INTRINSIC_USER && !interface)\n \t  || (u->op != INTRINSIC_USER &&  interface))\n \tcontinue;\n@@ -723,6 +757,13 @@ find_use_name_n (const char *name, int *inst, bool interface)\n \n   u->found = 1;\n \n+  if (low_name)\n+    {\n+      if (u->local_name[0] == '\\0')\n+\treturn name;\n+      return dt_upper_string (u->local_name);\n+    }\n+\n   return (u->local_name[0] != '\\0') ? u->local_name : name;\n }\n \n@@ -780,6 +821,7 @@ find_use_operator (gfc_intrinsic_op op)\n typedef struct true_name\n {\n   BBT_HEADER (true_name);\n+  const char *name;\n   gfc_symbol *sym;\n }\n true_name;\n@@ -803,7 +845,7 @@ compare_true_names (void *_t1, void *_t2)\n   if (c != 0)\n     return c;\n \n-  return strcmp (t1->sym->name, t2->sym->name);\n+  return strcmp (t1->name, t2->name);\n }\n \n \n@@ -817,7 +859,7 @@ find_true_name (const char *name, const char *module)\n   gfc_symbol sym;\n   int c;\n \n-  sym.name = gfc_get_string (name);\n+  t.name = gfc_get_string (name);\n   if (module != NULL)\n     sym.module = gfc_get_string (module);\n   else\n@@ -847,6 +889,10 @@ add_true_name (gfc_symbol *sym)\n \n   t = XCNEW (true_name);\n   t->sym = sym;\n+  if (sym->attr.flavor == FL_DERIVED)\n+    t->name = dt_upper_string (sym->name);\n+  else\n+    t->name = sym->name;\n \n   gfc_insert_bbt (&true_name_root, t, compare_true_names);\n }\n@@ -858,13 +904,19 @@ add_true_name (gfc_symbol *sym)\n static void\n build_tnt (gfc_symtree *st)\n {\n+  const char *name;\n   if (st == NULL)\n     return;\n \n   build_tnt (st->left);\n   build_tnt (st->right);\n \n-  if (find_true_name (st->n.sym->name, st->n.sym->module) != NULL)\n+  if (st->n.sym->attr.flavor == FL_DERIVED)\n+    name = dt_upper_string (st->n.sym->name);\n+  else\n+    name = st->n.sym->name;\n+\n+  if (find_true_name (name, st->n.sym->module) != NULL)\n     return;\n \n   add_true_name (st->n.sym);\n@@ -2986,8 +3038,12 @@ fix_mio_expr (gfc_expr *e)\n \t namespace to see if the required, non-contained symbol is available\n \t yet. If so, the latter should be written.  */\n       if (e->symtree->n.sym && check_unique_name (e->symtree->name))\n-\tns_st = gfc_find_symtree (gfc_current_ns->sym_root,\n-\t\t\t\t  e->symtree->n.sym->name);\n+\t{\n+          const char *name = e->symtree->n.sym->name;\n+\t  if (e->symtree->n.sym->attr.flavor == FL_DERIVED)\n+\t    name = dt_upper_string (name);\n+\t  ns_st = gfc_find_symtree (gfc_current_ns->sym_root, name);\n+\t}\n \n       /* On the other hand, if the existing symbol is the module name or the\n \t new symbol is a dummy argument, do not do the promotion.  */\n@@ -4205,6 +4261,7 @@ load_needed (pointer_info *p)\n \t\t\t\t 1, &ns->proc_name);\n \n       sym = gfc_new_symbol (p->u.rsym.true_name, ns);\n+      sym->name = dt_lower_string (p->u.rsym.true_name);\n       sym->module = gfc_get_string (p->u.rsym.module);\n       strcpy (sym->binding_label, p->u.rsym.binding_label);\n \n@@ -4497,6 +4554,7 @@ read_module (void)\n \t\t{\n \t\t  info->u.rsym.sym = gfc_new_symbol (info->u.rsym.true_name,\n \t\t\t\t\t\t     gfc_current_ns);\n+\t\t  info->u.rsym.sym->name = dt_lower_string (info->u.rsym.true_name);\n \t\t  sym = info->u.rsym.sym;\n \t\t  sym->module = gfc_get_string (info->u.rsym.module);\n \n@@ -4835,7 +4893,7 @@ write_dt_extensions (gfc_symtree *st)\n     return;\n \n   mio_lparen ();\n-  mio_pool_string (&st->n.sym->name);\n+  mio_pool_string (&st->name);\n   if (st->n.sym->module != NULL)\n     mio_pool_string (&st->n.sym->module);\n   else\n@@ -4870,7 +4928,15 @@ write_symbol (int n, gfc_symbol *sym)\n     gfc_internal_error (\"write_symbol(): bad module symbol '%s'\", sym->name);\n \n   mio_integer (&n);\n-  mio_pool_string (&sym->name);\n+\n+  if (sym->attr.flavor == FL_DERIVED)\n+    {\n+      const char *name;\n+      name = dt_upper_string (sym->name);\n+      mio_pool_string (&name);\n+    }\n+  else\n+    mio_pool_string (&sym->name);\n \n   mio_pool_string (&sym->module);\n   if (sym->attr.is_bind_c || sym->attr.is_iso_c)\n@@ -5566,7 +5632,8 @@ create_derived_type (const char *name, const char *modname,\n \t\t      intmod_id module, int id)\n {\n   gfc_symtree *tmp_symtree;\n-  gfc_symbol *sym;\n+  gfc_symbol *sym, *dt_sym;\n+  gfc_interface *intr, *head;\n \n   tmp_symtree = gfc_find_symtree (gfc_current_ns->sym_root, name);\n   if (tmp_symtree != NULL)\n@@ -5579,18 +5646,35 @@ create_derived_type (const char *name, const char *modname,\n \n   gfc_get_sym_tree (name, gfc_current_ns, &tmp_symtree, false);\n   sym = tmp_symtree->n.sym;\n-\n   sym->module = gfc_get_string (modname);\n   sym->from_intmod = module;\n   sym->intmod_sym_id = id;\n-  sym->attr.flavor = FL_DERIVED;\n-  sym->attr.private_comp = 1;\n-  sym->attr.zero_comp = 1;\n-  sym->attr.use_assoc = 1;\n+  sym->attr.flavor = FL_PROCEDURE;\n+  sym->attr.function = 1;\n+  sym->attr.generic = 1;\n+\n+  gfc_get_sym_tree (dt_upper_string (sym->name),\n+\t\t    gfc_current_ns, &tmp_symtree, false);\n+  dt_sym = tmp_symtree->n.sym;\n+  dt_sym->name = gfc_get_string (sym->name);\n+  dt_sym->attr.flavor = FL_DERIVED;\n+  dt_sym->attr.private_comp = 1;\n+  dt_sym->attr.zero_comp = 1;\n+  dt_sym->attr.use_assoc = 1;\n+  dt_sym->module = gfc_get_string (modname);\n+  dt_sym->from_intmod = module;\n+  dt_sym->intmod_sym_id = id;\n+\n+  head = sym->generic;\n+  intr = gfc_get_interface ();\n+  intr->sym = dt_sym;\n+  intr->where = gfc_current_locus;\n+  intr->next = head;\n+  sym->generic = intr;\n+  sym->attr.if_source = IFSRC_DECL;\n }\n \n \n-\n /* USE the ISO_FORTRAN_ENV intrinsic module.  */\n \n static void"}, {"sha": "7d91645207b27d4ca2a0afda40489b05b1a3961b", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -3881,6 +3881,12 @@ gfc_fixup_sibling_symbols (gfc_symbol *sym, gfc_namespace *siblings)\n       if (!st || (st->n.sym->attr.dummy && ns == st->n.sym->ns))\n \tgoto fixup_contained;\n \n+      if ((st->n.sym->attr.flavor == FL_DERIVED\n+\t   && sym->attr.generic && sym->attr.function)\n+\t  ||(sym->attr.flavor == FL_DERIVED\n+\t     && st->n.sym->attr.generic && st->n.sym->attr.function))\n+\tgoto fixup_contained;\n+\n       old_sym = st->n.sym;\n       if (old_sym->ns == ns\n \t    && !old_sym->attr.contained"}, {"sha": "0f67ec782820241a44401b43db2665af0cca9859", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 194, "deletions": 145, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -2315,171 +2315,162 @@ build_actual_constructor (gfc_structure_ctor_component **comp_head,\n   return SUCCESS;\n }\n \n-match\n-gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result,\n-\t\t\t\t bool parent)\n+\n+gfc_try\n+gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **cexpr,\n+\t\t\t\t      gfc_actual_arglist **arglist,\n+\t\t\t\t      bool parent)\n {\n+  gfc_actual_arglist *actual;\n   gfc_structure_ctor_component *comp_tail, *comp_head, *comp_iter;\n   gfc_constructor_base ctor_head = NULL;\n   gfc_component *comp; /* Is set NULL when named component is first seen */\n-  gfc_expr *e;\n-  locus where;\n-  match m;\n   const char* last_name = NULL;\n+  locus old_locus;\n+  gfc_expr *expr;\n \n-  comp_tail = comp_head = NULL;\n-\n-  if (!parent && gfc_match_char ('(') != MATCH_YES)\n-    goto syntax;\n-\n-  where = gfc_current_locus;\n+  expr = parent ? *cexpr : e;\n+  old_locus = gfc_current_locus;\n+  if (parent)\n+    ; /* gfc_current_locus = *arglist->expr ? ->where;*/\n+  else\n+    gfc_current_locus = expr->where;\n \n-  gfc_find_component (sym, NULL, false, true);\n+  comp_tail = comp_head = NULL;\n \n-  /* Check that we're not about to construct an ABSTRACT type.  */\n   if (!parent && sym->attr.abstract)\n     {\n-      gfc_error (\"Can't construct ABSTRACT type '%s' at %C\", sym->name);\n-      return MATCH_ERROR;\n+      gfc_error (\"Can't construct ABSTRACT type '%s' at %L\",\n+\t\t sym->name, &expr->where);\n+      goto cleanup;\n     }\n \n-  /* Match the component list and store it in a list together with the\n-     corresponding component names.  Check for empty argument list first.  */\n-  if (gfc_match_char (')') != MATCH_YES)\n+  comp = sym->components;\n+  actual = parent ? *arglist : expr->value.function.actual;\n+  for ( ; actual; )\n     {\n-      comp = sym->components;\n-      do\n-\t{\n-\t  gfc_component *this_comp = NULL;\n-\n-\t  if (comp == sym->components && sym->attr.extension\n-\t      && comp->ts.type == BT_DERIVED\n-\t      && comp->ts.u.derived->attr.zero_comp)\n-\t    /* Skip empty parents.  */ \n-\t    comp = comp->next;\n+      gfc_component *this_comp = NULL;\n \n-\t  if (!comp_head)\n-\t    comp_tail = comp_head = gfc_get_structure_ctor_component ();\n-\t  else\n-\t    {\n-\t      comp_tail->next = gfc_get_structure_ctor_component ();\n-\t      comp_tail = comp_tail->next;\n-\t    }\n-\t  comp_tail->name = XCNEWVEC (char, GFC_MAX_SYMBOL_LEN + 1);\n-\t  comp_tail->val = NULL;\n-\t  comp_tail->where = gfc_current_locus;\n+      if (!comp_head)\n+\tcomp_tail = comp_head = gfc_get_structure_ctor_component ();\n+      else\n+\t{\n+\t  comp_tail->next = gfc_get_structure_ctor_component ();\n+\t  comp_tail = comp_tail->next;\n+       \t}\n+      if (actual->name)\n+\t{\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Structure\"\n+\t\t\t      \" constructor with named arguments at %C\")\n+\t      == FAILURE)\n+\t    goto cleanup;\n \n-\t  /* Try matching a component name.  */\n-\t  if (gfc_match_name (comp_tail->name) == MATCH_YES \n-\t      && gfc_match_char ('=') == MATCH_YES)\n+\t  comp_tail->name = xstrdup (actual->name);\n+\t  last_name = comp_tail->name;\n+\t  comp = NULL;\n+\t}\n+      else\n+\t{\n+\t  /* Components without name are not allowed after the first named\n+\t     component initializer!  */\n+\t  if (!comp)\n \t    {\n-\t      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Structure\"\n-\t\t\t\t  \" constructor with named arguments at %C\")\n-\t\t  == FAILURE)\n-\t\tgoto cleanup;\n-\n-\t      last_name = comp_tail->name;\n-\t      comp = NULL;\n+\t      if (last_name)\n+\t\tgfc_error (\"Component initializer without name after component\"\n+\t\t\t   \" named %s at %L!\", last_name,\n+\t\t\t   actual->expr ? &actual->expr->where\n+\t\t\t\t\t: &gfc_current_locus);\n+\t      else\n+\t\tgfc_error (\"Too many components in structure constructor at \"\n+\t\t\t   \"%L!\", actual->expr ? &actual->expr->where\n+\t\t\t\t\t       : &gfc_current_locus);\n+\t      goto cleanup;\n \t    }\n-\t  else\n-\t    {\n-\t      /* Components without name are not allowed after the first named\n-\t\t component initializer!  */\n-\t      if (!comp)\n-\t\t{\n-\t\t  if (last_name)\n-\t\t    gfc_error (\"Component initializer without name after\"\n-\t\t\t       \" component named %s at %C!\", last_name);\n-\t\t  else if (!parent)\n-\t\t    gfc_error (\"Too many components in structure constructor at\"\n-\t\t\t       \" %C!\");\n-\t\t  goto cleanup;\n-\t\t}\n \n-\t      gfc_current_locus = comp_tail->where;\n-\t      strncpy (comp_tail->name, comp->name, GFC_MAX_SYMBOL_LEN + 1);\n-\t    }\n+\t  comp_tail->name = xstrdup (comp->name);\n+\t}\n \n-\t  /* Find the current component in the structure definition and check\n+      /* Find the current component in the structure definition and check\n \t     its access is not private.  */\n-\t  if (comp)\n-\t    this_comp = gfc_find_component (sym, comp->name, false, false);\n-\t  else\n-\t    {\n-\t      this_comp = gfc_find_component (sym,\n-\t\t\t\t\t      (const char *)comp_tail->name,\n-\t\t\t\t\t      false, false);\n-\t      comp = NULL; /* Reset needed!  */\n-\t    }\n-\n-\t  /* Here we can check if a component name is given which does not\n-\t     correspond to any component of the defined structure.  */\n-\t  if (!this_comp)\n-\t    goto cleanup;\n+      if (comp)\n+\tthis_comp = gfc_find_component (sym, comp->name, false, false);\n+      else\n+\t{\n+\t  this_comp = gfc_find_component (sym, (const char *)comp_tail->name,\n+\t\t\t\t\t  false, false);\n+\t  comp = NULL; /* Reset needed!  */\n+\t}\n \n-\t  /* Check if this component is already given a value.  */\n-\t  for (comp_iter = comp_head; comp_iter != comp_tail; \n-\t       comp_iter = comp_iter->next)\n-\t    {\n-\t      gcc_assert (comp_iter);\n-\t      if (!strcmp (comp_iter->name, comp_tail->name))\n-\t\t{\n-\t\t  gfc_error (\"Component '%s' is initialized twice in the\"\n-\t\t\t     \" structure constructor at %C!\", comp_tail->name);\n-\t\t  goto cleanup;\n-\t\t}\n-\t    }\n+      /* Here we can check if a component name is given which does not\n+\t correspond to any component of the defined structure.  */\n+      if (!this_comp)\n+\tgoto cleanup;\n \n-\t  /* Match the current initializer expression.  */\n-\t  if (this_comp->attr.proc_pointer)\n-\t    gfc_matching_procptr_assignment = 1;\n-\t  m = gfc_match_expr (&comp_tail->val);\n-\t  gfc_matching_procptr_assignment = 0;\n-\t  if (m == MATCH_NO)\n-\t    goto syntax;\n-\t  if (m == MATCH_ERROR)\n-\t    goto cleanup;\n+      comp_tail->val = actual->expr;\n+      if (actual->expr != NULL)\n+\tcomp_tail->where = actual->expr->where;\n+      actual->expr = NULL;\n \n-\t  /* F2008, R457/C725, for PURE C1283.  */\n-          if (this_comp->attr.pointer && gfc_is_coindexed (comp_tail->val))\n+      /* Check if this component is already given a value.  */\n+      for (comp_iter = comp_head; comp_iter != comp_tail; \n+\t   comp_iter = comp_iter->next)\n+\t{\n+\t  gcc_assert (comp_iter);\n+\t  if (!strcmp (comp_iter->name, comp_tail->name))\n \t    {\n-\t      gfc_error (\"Coindexed expression to pointer component '%s' in \"\n-\t\t\t \"structure constructor at %C!\", comp_tail->name);\n+\t      gfc_error (\"Component '%s' is initialized twice in the structure\"\n+\t\t\t \" constructor at %L!\", comp_tail->name,\n+\t\t\t comp_tail->val ? &comp_tail->where\n+\t\t\t\t\t: &gfc_current_locus);\n \t      goto cleanup;\n- \t    }\n+\t    }\n+\t}\n \n+      /* F2008, R457/C725, for PURE C1283.  */\n+      if (this_comp->attr.pointer && comp_tail->val\n+\t  && gfc_is_coindexed (comp_tail->val))\n+     \t{\n+       \t  gfc_error (\"Coindexed expression to pointer component '%s' in \"\n+\t\t     \"structure constructor at %L!\", comp_tail->name,\n+\t\t     &comp_tail->where);\n+\t  goto cleanup;\n+\t}\n \n-\t  /* If not explicitly a parent constructor, gather up the components\n-\t     and build one.  */\n-\t  if (comp && comp == sym->components\n-\t\t&& sym->attr.extension\n-\t\t&& (comp_tail->val->ts.type != BT_DERIVED\n-\t\t      ||\n-\t\t    comp_tail->val->ts.u.derived != this_comp->ts.u.derived))\n-\t    {\n-\t      gfc_current_locus = where;\n-\t      gfc_free_expr (comp_tail->val);\n-\t      comp_tail->val = NULL;\n+          /* If not explicitly a parent constructor, gather up the components\n+             and build one.  */\n+          if (comp && comp == sym->components\n+                && sym->attr.extension\n+\t\t&& comp_tail->val\n+                && (comp_tail->val->ts.type != BT_DERIVED\n+                      ||\n+                    comp_tail->val->ts.u.derived != this_comp->ts.u.derived))\n+            {\n+              gfc_try m;\n+\t      gfc_actual_arglist *arg_null = NULL;\n \n-\t      m = gfc_match_structure_constructor (comp->ts.u.derived, \n-\t\t\t\t\t\t   &comp_tail->val, true);\n-\t      if (m == MATCH_NO)\n-\t\tgoto syntax;\n-\t      if (m == MATCH_ERROR)\n-\t\tgoto cleanup;\n-\t    }\n+\t      actual->expr = comp_tail->val;\n+\t      comp_tail->val = NULL;\n \n- \t  if (comp)\n-\t    comp = comp->next;\n+              m = gfc_convert_to_structure_constructor (NULL,\n+\t\t\t\t\tcomp->ts.u.derived, &comp_tail->val,\n+\t\t\t\t\tcomp->ts.u.derived->attr.zero_comp\n+\t\t\t\t\t  ? &arg_null : &actual, true);\n+              if (m == FAILURE)\n+                goto cleanup;\n \n-\t  if (parent && !comp)\n-\t    break;\n-\t}\n+\t      if (comp->ts.u.derived->attr.zero_comp)\n+\t\t{\n+\t\t  comp = comp->next;\n+\t\t  continue;\n+\t\t}\n+            }\n \n-      while (gfc_match_char (',') == MATCH_YES);\n+      if (comp)\n+\tcomp = comp->next;\n+      if (parent && !comp)\n+\tbreak;\n \n-      if (!parent && gfc_match_char (')') != MATCH_YES)\n-\tgoto syntax;\n+      actual = actual->next;\n     }\n \n   if (build_actual_constructor (&comp_head, &ctor_head, sym) == FAILURE)\n@@ -2488,9 +2479,8 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result,\n   /* No component should be left, as this should have caused an error in the\n      loop constructing the component-list (name that does not correspond to any\n      component in the structure definition).  */\n-  if (comp_head)\n+  if (comp_head && sym->attr.extension)\n     {\n-      gcc_assert (sym->attr.extension);\n       for (comp_iter = comp_head; comp_iter; comp_iter = comp_iter->next)\n \t{\n \t  gfc_error (\"component '%s' at %L has already been set by a \"\n@@ -2499,26 +2489,79 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result,\n \t}\n       goto cleanup;\n     }\n+  else\n+    gcc_assert (!comp_head);\n \n-  e = gfc_get_structure_constructor_expr (BT_DERIVED, 0, &where);\n-  e->ts.u.derived = sym;\n-  e->value.constructor = ctor_head;\n+  if (parent)\n+    {\n+      expr = gfc_get_structure_constructor_expr (BT_DERIVED, 0, &gfc_current_locus);\n+      expr->ts.u.derived = sym;\n+      expr->value.constructor = ctor_head;\n+      *cexpr = expr;\n+    }\n+  else\n+    {\n+      expr->ts.u.derived = sym;\n+      expr->ts.kind = 0;\n+      expr->ts.type = BT_DERIVED;\n+      expr->value.constructor = ctor_head;\n+      expr->expr_type = EXPR_STRUCTURE;\n+    }\n \n-  *result = e;\n-  return MATCH_YES;\n+  gfc_current_locus = old_locus; \n+  if (parent)\n+    *arglist = actual;\n+  return SUCCESS;\n \n-syntax:\n-  gfc_error (\"Syntax error in structure constructor at %C\");\n+  cleanup:\n+  gfc_current_locus = old_locus; \n \n-cleanup:\n   for (comp_iter = comp_head; comp_iter; )\n     {\n       gfc_structure_ctor_component *next = comp_iter->next;\n       gfc_free_structure_ctor_component (comp_iter);\n       comp_iter = next;\n     }\n   gfc_constructor_free (ctor_head);\n-  return MATCH_ERROR;\n+\n+  return FAILURE;\n+}\n+\n+\n+match\n+gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result)\n+{\n+  match m;\n+  gfc_expr *e;\n+  gfc_symtree *symtree;\n+\n+  gfc_get_sym_tree (sym->name, NULL, &symtree, false);   /* Can't fail */\n+\n+  e = gfc_get_expr ();\n+  e->symtree = symtree;\n+  e->expr_type = EXPR_FUNCTION;\n+\n+  gcc_assert (sym->attr.flavor == FL_DERIVED\n+\t      && symtree->n.sym->attr.flavor == FL_PROCEDURE);\n+  e->value.function.esym = sym;\n+  e->symtree->n.sym->attr.generic = 1;\n+\n+   m = gfc_match_actual_arglist (0, &e->value.function.actual);\n+   if (m != MATCH_YES)\n+     {\n+       gfc_free_expr (e);\n+       return m;\n+     }\n+\n+   if (gfc_convert_to_structure_constructor (e, sym, NULL, NULL, false)\n+       != SUCCESS)\n+     {\n+       gfc_free_expr (e);\n+       return MATCH_ERROR;\n+     }\n+\n+   *result = e;\n+   return MATCH_YES;\n }\n \n \n@@ -2715,7 +2758,7 @@ gfc_match_rvalue (gfc_expr **result)\n       if (sym == NULL)\n \tm = MATCH_ERROR;\n       else\n-\tm = gfc_match_structure_constructor (sym, &e, false);\n+\tgoto generic_function;\n       break;\n \n     /* If we're here, then the name is known to be the name of a\n@@ -2989,6 +3032,12 @@ gfc_match_rvalue (gfc_expr **result)\n       e->symtree = symtree;\n       e->expr_type = EXPR_FUNCTION;\n \n+      if (sym->attr.flavor == FL_DERIVED)\n+\t{\n+\t  e->value.function.esym = sym;\n+\t  e->symtree->n.sym->attr.generic = 1;\n+\t}\n+\n       m = gfc_match_actual_arglist (0, &e->value.function.actual);\n       break;\n "}, {"sha": "94c21bedf8d595e17395e0ab8052cc30e131deb6", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 78, "deletions": 29, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -454,7 +454,8 @@ resolve_formal_arglist (gfc_symbol *proc)\n static void\n find_arglists (gfc_symbol *sym)\n {\n-  if (sym->attr.if_source == IFSRC_UNKNOWN || sym->ns != gfc_current_ns)\n+  if (sym->attr.if_source == IFSRC_UNKNOWN || sym->ns != gfc_current_ns\n+      || sym->attr.flavor == FL_DERIVED)\n     return;\n \n   resolve_formal_arglist (sym);\n@@ -967,13 +968,6 @@ resolve_structure_cons (gfc_expr *expr, int init)\n     resolve_fl_derived0 (expr->ts.u.derived);\n \n   cons = gfc_constructor_first (expr->value.constructor);\n-  /* A constructor may have references if it is the result of substituting a\n-     parameter variable.  In this case we just pull out the component we\n-     want.  */\n-  if (expr->ref)\n-    comp = expr->ref->u.c.sym->components;\n-  else\n-    comp = expr->ts.u.derived->components;\n \n   /* See if the user is trying to invoke a structure constructor for one of\n      the iso_c_binding derived types.  */\n@@ -992,6 +986,14 @@ resolve_structure_cons (gfc_expr *expr, int init)\n       && cons->expr && cons->expr->expr_type == EXPR_NULL)\n     return SUCCESS;\n \n+  /* A constructor may have references if it is the result of substituting a\n+     parameter variable.  In this case we just pull out the component we\n+     want.  */\n+  if (expr->ref)\n+    comp = expr->ref->u.c.sym->components;\n+  else\n+    comp = expr->ts.u.derived->components;\n+\n   for (; comp && cons; comp = comp->next, cons = gfc_constructor_next (cons))\n     {\n       int rank;\n@@ -1401,7 +1403,8 @@ is_illegal_recursion (gfc_symbol* sym, gfc_namespace* context)\n   gfc_symbol* context_proc;\n   gfc_namespace* real_context;\n \n-  if (sym->attr.flavor == FL_PROGRAM)\n+  if (sym->attr.flavor == FL_PROGRAM\n+      || sym->attr.flavor == FL_DERIVED)\n     return false;\n \n   gcc_assert (sym->attr.flavor == FL_PROCEDURE);\n@@ -2323,6 +2326,7 @@ resolve_generic_f (gfc_expr *expr)\n {\n   gfc_symbol *sym;\n   match m;\n+  gfc_interface *intr = NULL;\n \n   sym = expr->symtree->n.sym;\n \n@@ -2335,6 +2339,11 @@ resolve_generic_f (gfc_expr *expr)\n \treturn FAILURE;\n \n generic:\n+      if (!intr)\n+\tfor (intr = sym->generic; intr; intr = intr->next)\n+\t  if (intr->sym->attr.flavor == FL_DERIVED)\n+\t    break;\n+\n       if (sym->ns->parent == NULL)\n \tbreak;\n       gfc_find_symbol (sym->name, sym->ns->parent, 1, &sym);\n@@ -2347,16 +2356,25 @@ resolve_generic_f (gfc_expr *expr)\n \n   /* Last ditch attempt.  See if the reference is to an intrinsic\n      that possesses a matching interface.  14.1.2.4  */\n-  if (sym && !gfc_is_intrinsic (sym, 0, expr->where))\n+  if (sym  && !intr && !gfc_is_intrinsic (sym, 0, expr->where))\n     {\n-      gfc_error (\"There is no specific function for the generic '%s' at %L\",\n-\t\t expr->symtree->n.sym->name, &expr->where);\n+      gfc_error (\"There is no specific function for the generic '%s' \"\n+\t\t \"at %L\", expr->symtree->n.sym->name, &expr->where);\n       return FAILURE;\n     }\n \n+  if (intr)\n+    {\n+      if (gfc_convert_to_structure_constructor (expr, intr->sym, NULL, NULL,\n+\t\t\t\t\t\tfalse) != SUCCESS)\n+\treturn FAILURE;\n+      return resolve_structure_cons (expr, 0);\n+    }\n+\n   m = gfc_intrinsic_func_interface (expr, 0);\n   if (m == MATCH_YES)\n     return SUCCESS;\n+\n   if (m == MATCH_NO)\n     gfc_error (\"Generic function '%s' at %L is not consistent with a \"\n \t       \"specific intrinsic interface\", expr->symtree->n.sym->name,\n@@ -5053,6 +5071,9 @@ resolve_variable (gfc_expr *e)\n   if (sym->assoc && !sym->attr.dimension && e->ref && e->ref->type == REF_ARRAY)\n     return FAILURE;\n \n+  if (sym->ts.type == BT_DERIVED && sym->ts.u.derived->attr.generic)\n+    sym->ts.u.derived = gfc_find_dt_in_generic (sym->ts.u.derived);\n+\n   /* On the other hand, the parser may not have known this is an array;\n      in this case, we have to add a FULL reference.  */\n   if (sym->assoc && sym->attr.dimension && !e->ref)\n@@ -10152,6 +10173,8 @@ resolve_fl_variable_derived (gfc_symbol *sym, int no_init_flag)\n     {\n       gfc_symbol *s;\n       gfc_find_symbol (sym->ts.u.derived->name, sym->ns, 0, &s);\n+      if (s && s->attr.generic)\n+\ts = gfc_find_dt_in_generic (s);\n       if (s && s->attr.flavor != FL_DERIVED)\n \t{\n \t  gfc_error (\"The type '%s' cannot be host associated at %L \"\n@@ -11718,6 +11741,13 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \t    }\n \t}\n \n+      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.generic)\n+\tc->ts.u.derived = gfc_find_dt_in_generic (c->ts.u.derived);\n+      else if (c->ts.type == BT_CLASS && c->attr.class_ok\n+\t       && CLASS_DATA (c)->ts.u.derived->attr.generic)\n+\tCLASS_DATA (c)->ts.u.derived\n+\t\t\t= gfc_find_dt_in_generic (CLASS_DATA (c)->ts.u.derived);\n+\n       if (!sym->attr.is_class && c->ts.type == BT_DERIVED && !sym->attr.vtype\n \t  && c->attr.pointer && c->ts.u.derived->components == NULL\n \t  && !c->ts.u.derived->attr.zero_comp)\n@@ -11788,6 +11818,23 @@ resolve_fl_derived0 (gfc_symbol *sym)\n static gfc_try\n resolve_fl_derived (gfc_symbol *sym)\n {\n+  gfc_symbol *gen_dt = NULL;\n+\n+  if (!sym->attr.is_class)\n+    gfc_find_symbol (sym->name, sym->ns, 0, &gen_dt);\n+  if (gen_dt && gen_dt->generic && gen_dt->generic->next\n+      && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Generic name '%s' of \"\n+\t\t\t \"function '%s' at %L being the same name as derived \"\n+\t\t\t \"type at %L\", sym->name,\n+\t\t\t gen_dt->generic->sym == sym\n+\t\t\t   ? gen_dt->generic->next->sym->name\n+\t\t\t   : gen_dt->generic->sym->name,\n+\t\t\t gen_dt->generic->sym == sym\n+\t\t\t   ? &gen_dt->generic->next->sym->declared_at\n+\t\t\t   : &gen_dt->generic->sym->declared_at,\n+\t\t\t &sym->declared_at) == FAILURE)\n+    return FAILURE;\n+\n   if (sym->attr.is_class && sym->ts.u.derived == NULL)\n     {\n       /* Fix up incomplete CLASS symbols.  */\n@@ -12191,6 +12238,20 @@ resolve_symbol (gfc_symbol *sym)\n \t}\n     }\n \n+  if (sym->ts.type == BT_DERIVED && !sym->attr.is_iso_c\n+      && sym->ts.u.derived->attr.generic)\n+    {\n+      sym->ts.u.derived = gfc_find_dt_in_generic (sym->ts.u.derived);\n+      if (!sym->ts.u.derived)\n+\t{\n+\t  gfc_error (\"The derived type '%s' at %L is of type '%s', \"\n+\t\t     \"which has not been defined\", sym->name,\n+\t\t     &sym->declared_at, sym->ts.u.derived->name);\n+\t  sym->ts.type = BT_UNKNOWN;\n+\t  return;\n+\t}\n+    }\n+\n   /* If the symbol is marked as bind(c), verify it's type and kind.  Do not\n      do this for something that was implicitly typed because that is handled\n      in gfc_set_default_type.  Handle dummy arguments and procedure\n@@ -12260,7 +12321,8 @@ resolve_symbol (gfc_symbol *sym)\n      the type is not declared in the scope of the implicit\n      statement. Change the type to BT_UNKNOWN, both because it is so\n      and to prevent an ICE.  */\n-  if (sym->ts.type == BT_DERIVED && sym->ts.u.derived->components == NULL\n+  if (sym->ts.type == BT_DERIVED && !sym->attr.is_iso_c\n+      && sym->ts.u.derived->components == NULL\n       && !sym->ts.u.derived->attr.zero_comp)\n     {\n       gfc_error (\"The derived type '%s' at %L is of type '%s', \"\n@@ -12276,22 +12338,9 @@ resolve_symbol (gfc_symbol *sym)\n   if (sym->ts.type == BT_DERIVED\n \t&& sym->ts.u.derived->attr.use_assoc\n \t&& sym->ns->proc_name\n-\t&& sym->ns->proc_name->attr.flavor == FL_MODULE)\n-    {\n-      gfc_symbol *ds;\n-\n-      if (resolve_fl_derived (sym->ts.u.derived) == FAILURE)\n-\treturn;\n-\n-      gfc_find_symbol (sym->ts.u.derived->name, sym->ns, 1, &ds);\n-      if (!ds && sym->attr.function && gfc_check_symbol_access (sym))\n-\t{\n-\t  symtree = gfc_new_symtree (&sym->ns->sym_root,\n-\t\t\t\t     sym->ts.u.derived->name);\n-\t  symtree->n.sym = sym->ts.u.derived;\n-\t  sym->ts.u.derived->refs++;\n-\t}\n-    }\n+\t&& sym->ns->proc_name->attr.flavor == FL_MODULE\n+        && resolve_fl_derived (sym->ts.u.derived) == FAILURE)\n+    return;\n \n   /* Unless the derived-type declaration is use associated, Fortran 95\n      does not allow public entries of private derived types."}, {"sha": "9bd6ed489f33ea9f264876adaef84eff75fd2ecc", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 168, "deletions": 76, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -1949,6 +1949,9 @@ gfc_use_derived (gfc_symbol *sym)\n   if (!sym)\n     return NULL;\n \n+  if (sym->attr.generic)\n+    sym = gfc_find_dt_in_generic (sym);\n+\n   if (sym->components != NULL || sym->attr.zero_comp)\n     return sym;               /* Already defined.  */\n \n@@ -2880,7 +2883,15 @@ gfc_undo_symbols (void)\n \t\t}\n \t    }\n \n-\t  gfc_delete_symtree (&p->ns->sym_root, p->name);\n+\t  /* The derived type is saved in the symtree with the first\n+\t     letter capitalized; the all lower-case version to the\n+\t     derived type contains its associated generic function.  */\n+\t  if (p->attr.flavor == FL_DERIVED)\n+\t    gfc_delete_symtree (&p->ns->sym_root, gfc_get_string (\"%c%s\",\n+                        (char) TOUPPER ((unsigned char) p->name[0]),\n+                        &p->name[1]));\n+\t  else\n+\t    gfc_delete_symtree (&p->ns->sym_root, p->name);\n \n \t  gfc_release_symbol (p);\n \t  continue;\n@@ -3773,15 +3784,15 @@ gen_special_c_interop_ptr (int ptr_id, const char *ptr_name,\n          that has arg(s) of the missing type.  In this case, a\n          regular version of the thing should have been put in the\n          current ns.  */\n+\n       generate_isocbinding_symbol (module_name, ptr_id == ISOCBINDING_NULL_PTR \n                                    ? ISOCBINDING_PTR : ISOCBINDING_FUNPTR,\n                                    (const char *) (ptr_id == ISOCBINDING_NULL_PTR \n-\t\t\t\t   ? \"_gfortran_iso_c_binding_c_ptr\"\n-\t\t\t\t   : \"_gfortran_iso_c_binding_c_funptr\"));\n-\n+\t\t\t\t   ? \"c_ptr\"\n+\t\t\t\t   : \"c_funptr\"));\n       tmp_sym->ts.u.derived =\n-        get_iso_c_binding_dt (ptr_id == ISOCBINDING_NULL_PTR\n-                              ? ISOCBINDING_PTR : ISOCBINDING_FUNPTR);\n+\tget_iso_c_binding_dt (ptr_id == ISOCBINDING_NULL_PTR\n+\t\t\t      ? ISOCBINDING_PTR : ISOCBINDING_FUNPTR);\n     }\n \n   /* Module name is some mangled version of iso_c_binding.  */\n@@ -3859,9 +3870,9 @@ gen_cptr_param (gfc_formal_arglist **head,\n   const char *c_ptr_type = NULL;\n \n   if (iso_c_sym_id == ISOCBINDING_F_PROCPOINTER)\n-    c_ptr_type = \"_gfortran_iso_c_binding_c_funptr\";\n+    c_ptr_type = \"c_funptr\";\n   else\n-    c_ptr_type = \"_gfortran_iso_c_binding_c_ptr\";\n+    c_ptr_type = \"c_ptr\";\n \n   if(c_ptr_name == NULL)\n     c_ptr_in = \"gfc_cptr__\";\n@@ -4338,19 +4349,31 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n \t\t\t\t\t     : c_interop_kinds_table[s].name;\n   gfc_symtree *tmp_symtree = NULL;\n   gfc_symbol *tmp_sym = NULL;\n-  gfc_dt_list **dt_list_ptr = NULL;\n-  gfc_component *tmp_comp = NULL;\n-  char comp_name[(GFC_MAX_SYMBOL_LEN * 2) + 1];\n   int index;\n \n   if (gfc_notification_std (std_for_isocbinding_symbol (s)) == ERROR)\n     return;\n+\n   tmp_symtree = gfc_find_symtree (gfc_current_ns->sym_root, name);\n \n-  /* Already exists in this scope so don't re-add it.\n-     TODO: we should probably check that it's really the same symbol.  */\n-  if (tmp_symtree != NULL)\n-    return;\n+  /* Already exists in this scope so don't re-add it. */\n+  if (tmp_symtree != NULL && (tmp_sym = tmp_symtree->n.sym) != NULL\n+      && (!tmp_sym->attr.generic\n+\t  || (tmp_sym = gfc_find_dt_in_generic (tmp_sym)) != NULL)\n+      && tmp_sym->from_intmod == INTMOD_ISO_C_BINDING)\n+    {\n+      if (tmp_sym->attr.flavor == FL_DERIVED\n+\t  && !get_iso_c_binding_dt (tmp_sym->intmod_sym_id))\n+\t{\n+\t  gfc_dt_list *dt_list;\n+\t  dt_list = gfc_get_dt_list ();\n+\t  dt_list->derived = tmp_sym;\n+\t  dt_list->next = gfc_derived_types;\n+  \t  gfc_derived_types = dt_list;\n+        }\n+\n+      return;\n+    }\n \n   /* Create the sym tree in the current ns.  */\n   gfc_get_sym_tree (name, gfc_current_ns, &tmp_symtree, false);\n@@ -4443,64 +4466,112 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n \n       case ISOCBINDING_PTR:\n       case ISOCBINDING_FUNPTR:\n-\n-\t/* Initialize an integer constant expression node.  */\n-\ttmp_sym->attr.flavor = FL_DERIVED;\n-\ttmp_sym->ts.is_c_interop = 1;\n-\ttmp_sym->attr.is_c_interop = 1;\n-\ttmp_sym->attr.is_iso_c = 1;\n-\ttmp_sym->ts.is_iso_c = 1;\n-\ttmp_sym->ts.type = BT_DERIVED;\n-\n-\t/* A derived type must have the bind attribute to be\n-\t   interoperable (J3/04-007, Section 15.2.3), even though\n-\t   the binding label is not used.  */\n-\ttmp_sym->attr.is_bind_c = 1;\n-\n-\ttmp_sym->attr.referenced = 1;\n-\n-\ttmp_sym->ts.u.derived = tmp_sym;\n-\n-        /* Add the symbol created for the derived type to the current ns.  */\n-        dt_list_ptr = &(gfc_derived_types);\n-        while (*dt_list_ptr != NULL && (*dt_list_ptr)->next != NULL)\n-          dt_list_ptr = &((*dt_list_ptr)->next);\n-\n-        /* There is already at least one derived type in the list, so append\n-           the one we're currently building for c_ptr or c_funptr.  */\n-        if (*dt_list_ptr != NULL)\n-          dt_list_ptr = &((*dt_list_ptr)->next);\n-        (*dt_list_ptr) = gfc_get_dt_list ();\n-        (*dt_list_ptr)->derived = tmp_sym;\n-        (*dt_list_ptr)->next = NULL;\n-\n-        /* Set up the component of the derived type, which will be\n-           an integer with kind equal to c_ptr_size.  Mangle the name of\n-           the field for the c_address to prevent the curious user from\n-           trying to access it from Fortran.  */\n-        sprintf (comp_name, \"__%s_%s\", tmp_sym->name, \"c_address\");\n-        gfc_add_component (tmp_sym, comp_name, &tmp_comp);\n-        if (tmp_comp == NULL)\n+\t{\n+\t  gfc_interface *intr, *head;\n+\t  gfc_symbol *dt_sym;\n+\t  const char *hidden_name;\n+\t  gfc_dt_list **dt_list_ptr = NULL;\n+\t  gfc_component *tmp_comp = NULL;\n+\t  char comp_name[(GFC_MAX_SYMBOL_LEN * 2) + 1];\n+\n+\t  hidden_name = gfc_get_string (\"%c%s\",\n+\t\t\t    (char) TOUPPER ((unsigned char) tmp_sym->name[0]),\n+                            &tmp_sym->name[1]);\n+\n+\t  /* Generate real derived type.  */\n+\t  tmp_symtree = gfc_find_symtree (gfc_current_ns->sym_root,\n+\t\t\t\t\t  hidden_name);\n+\n+\t  if (tmp_symtree != NULL)\n+\t    gcc_unreachable ();\n+\t  gfc_get_sym_tree (hidden_name, gfc_current_ns, &tmp_symtree, false);\n+\t  if (tmp_symtree)\n+\t    dt_sym = tmp_symtree->n.sym;\n+\t  else\n+\t    gcc_unreachable ();\n+\n+\t  /* Generate an artificial generic function.  */\n+\t  dt_sym->name = gfc_get_string (tmp_sym->name);\n+\t  head = tmp_sym->generic;\n+\t  intr = gfc_get_interface ();\n+\t  intr->sym = dt_sym;\n+\t  intr->where = gfc_current_locus;\n+\t  intr->next = head;\n+\t  tmp_sym->generic = intr;\n+\n+\t  if (!tmp_sym->attr.generic\n+\t      && gfc_add_generic (&tmp_sym->attr, tmp_sym->name, NULL)\n+\t\t == FAILURE)\n+\t    return;\n+\n+\t  if (!tmp_sym->attr.function\n+\t      && gfc_add_function (&tmp_sym->attr, tmp_sym->name, NULL)\n+\t\t == FAILURE)\n+\t    return;\n+\n+\t  /* Say what module this symbol belongs to.  */\n+\t  dt_sym->module = gfc_get_string (mod_name);\n+\t  dt_sym->from_intmod = INTMOD_ISO_C_BINDING;\n+\t  dt_sym->intmod_sym_id = s;\n+\n+\t  /* Initialize an integer constant expression node.  */\n+\t  dt_sym->attr.flavor = FL_DERIVED;\n+\t  dt_sym->ts.is_c_interop = 1;\n+\t  dt_sym->attr.is_c_interop = 1;\n+\t  dt_sym->attr.is_iso_c = 1;\n+\t  dt_sym->ts.is_iso_c = 1;\n+\t  dt_sym->ts.type = BT_DERIVED;\n+\n+\t  /* A derived type must have the bind attribute to be\n+\t     interoperable (J3/04-007, Section 15.2.3), even though\n+\t     the binding label is not used.  */\n+\t  dt_sym->attr.is_bind_c = 1;\n+\n+\t  dt_sym->attr.referenced = 1;\n+\t  dt_sym->ts.u.derived = dt_sym;\n+\n+\t  /* Add the symbol created for the derived type to the current ns.  */\n+\t  dt_list_ptr = &(gfc_derived_types);\n+\t  while (*dt_list_ptr != NULL && (*dt_list_ptr)->next != NULL)\n+\t    dt_list_ptr = &((*dt_list_ptr)->next);\n+\n+\t  /* There is already at least one derived type in the list, so append\n+\t     the one we're currently building for c_ptr or c_funptr.  */\n+\t  if (*dt_list_ptr != NULL)\n+\t    dt_list_ptr = &((*dt_list_ptr)->next);\n+\t  (*dt_list_ptr) = gfc_get_dt_list ();\n+\t  (*dt_list_ptr)->derived = dt_sym;\n+\t  (*dt_list_ptr)->next = NULL;\n+\n+\t  /* Set up the component of the derived type, which will be\n+\t     an integer with kind equal to c_ptr_size.  Mangle the name of\n+\t     the field for the c_address to prevent the curious user from\n+\t     trying to access it from Fortran.  */\n+\t  sprintf (comp_name, \"__%s_%s\", dt_sym->name, \"c_address\");\n+\t  gfc_add_component (dt_sym, comp_name, &tmp_comp);\n+\t  if (tmp_comp == NULL)\n           gfc_internal_error (\"generate_isocbinding_symbol(): Unable to \"\n \t\t\t      \"create component for c_address\");\n \n-        tmp_comp->ts.type = BT_INTEGER;\n+\t  tmp_comp->ts.type = BT_INTEGER;\n \n-        /* Set this because the module will need to read/write this field.  */\n-        tmp_comp->ts.f90_type = BT_INTEGER;\n+\t  /* Set this because the module will need to read/write this field.  */\n+\t  tmp_comp->ts.f90_type = BT_INTEGER;\n \n-        /* The kinds for c_ptr and c_funptr are the same.  */\n-        index = get_c_kind (\"c_ptr\", c_interop_kinds_table);\n-        tmp_comp->ts.kind = c_interop_kinds_table[index].value;\n+\t  /* The kinds for c_ptr and c_funptr are the same.  */\n+\t  index = get_c_kind (\"c_ptr\", c_interop_kinds_table);\n+\t  tmp_comp->ts.kind = c_interop_kinds_table[index].value;\n \n-        tmp_comp->attr.pointer = 0;\n-        tmp_comp->attr.dimension = 0;\n+\t  tmp_comp->attr.pointer = 0;\n+\t  tmp_comp->attr.dimension = 0;\n \n-        /* Mark the component as C interoperable.  */\n-        tmp_comp->ts.is_c_interop = 1;\n+\t  /* Mark the component as C interoperable.  */\n+\t  tmp_comp->ts.is_c_interop = 1;\n+\n+\t  /* Make it use associated (iso_c_binding module).  */\n+\t  dt_sym->attr.use_assoc = 1;\n+\t}\n \n-        /* Make it use associated (iso_c_binding module).  */\n-        tmp_sym->attr.use_assoc = 1;\n \tbreak;\n \n       case ISOCBINDING_NULL_PTR:\n@@ -4550,21 +4621,20 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n                   tmp_sym->ts.u.derived =\n                     get_iso_c_binding_dt (ISOCBINDING_FUNPTR);\n \n-                if (tmp_sym->ts.u.derived == NULL)\n-                  {\n+\t\tif (tmp_sym->ts.u.derived == NULL)\n+\t\t  {\n                     /* Create the necessary derived type so we can continue\n                        processing the file.  */\n-                    generate_isocbinding_symbol\n+\t\t    generate_isocbinding_symbol\n \t\t      (mod_name, s == ISOCBINDING_FUNLOC\n-\t\t\t\t ? ISOCBINDING_FUNPTR : ISOCBINDING_PTR,\n-\t\t       (const char *)(s == ISOCBINDING_FUNLOC\n-                                ? \"_gfortran_iso_c_binding_c_funptr\"\n-\t\t\t\t: \"_gfortran_iso_c_binding_c_ptr\"));\n+\t\t\t\t? ISOCBINDING_FUNPTR : ISOCBINDING_PTR,\n+\t\t      (const char *)(s == ISOCBINDING_FUNLOC\n+\t\t\t\t? \"c_funptr\" : \"c_ptr\"));\n                     tmp_sym->ts.u.derived =\n-                      get_iso_c_binding_dt (s == ISOCBINDING_FUNLOC\n-                                            ? ISOCBINDING_FUNPTR\n-                                            : ISOCBINDING_PTR);\n-                  }\n+\t\t    get_iso_c_binding_dt (s == ISOCBINDING_FUNLOC\n+\t\t\t\t\t    ? ISOCBINDING_FUNPTR\n+\t\t\t\t\t    : ISOCBINDING_PTR);\n+\t\t  }\n \n \t\t/* The function result is itself (no result clause).  */\n \t\ttmp_sym->result = tmp_sym;\n@@ -4712,13 +4782,19 @@ gfc_get_typebound_proc (gfc_typebound_proc *tb0)\n gfc_symbol*\n gfc_get_derived_super_type (gfc_symbol* derived)\n {\n+  if (derived && derived->attr.generic)\n+    derived = gfc_find_dt_in_generic (derived);\n+\n   if (!derived->attr.extension)\n     return NULL;\n \n   gcc_assert (derived->components);\n   gcc_assert (derived->components->ts.type == BT_DERIVED);\n   gcc_assert (derived->components->ts.u.derived);\n \n+  if (derived->components->ts.u.derived->attr.generic)\n+    return gfc_find_dt_in_generic (derived->components->ts.u.derived);\n+\n   return derived->components->ts.u.derived;\n }\n \n@@ -4814,3 +4890,19 @@ gfc_is_associate_pointer (gfc_symbol* sym)\n \n   return true;\n }\n+\n+\n+gfc_symbol *\n+gfc_find_dt_in_generic (gfc_symbol *sym)\n+{\n+  gfc_interface *intr = NULL;\n+\n+  if (!sym || sym->attr.flavor == FL_DERIVED)\n+    return sym;\n+\n+  if (sym->attr.generic)\n+    for (intr = (sym ? sym->generic : NULL); intr; intr = intr->next)\n+      if (intr->sym->attr.flavor == FL_DERIVED)\n+        break;\n+  return intr ? intr->sym : NULL;\n+}"}, {"sha": "2fb2d34ae4a1f2739dde6a47f17f3c257255e1d7", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -5027,6 +5027,11 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)\n   tree index, range;\n   VEC(constructor_elt,gc) *v = NULL;\n \n+  if (expr->expr_type == EXPR_VARIABLE\n+      && expr->symtree->n.sym->attr.flavor == FL_PARAMETER\n+      && expr->symtree->n.sym->value)\n+    expr = expr->symtree->n.sym->value;\n+\n   switch (expr->expr_type)\n     {\n     case EXPR_CONSTANT:"}, {"sha": "02c0ed71802fcb1fa7677715e164930269b3adf8", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -699,6 +699,18 @@ gfc_get_module_backend_decl (gfc_symbol *sym)\n \t}\n       else if (sym->attr.flavor == FL_DERIVED)\n \t{\n+\t  if (s && s->attr.flavor == FL_PROCEDURE)\n+\t    {\n+\t      gfc_interface *intr;\n+\t      gcc_assert (s->attr.generic);\n+\t      for (intr = s->generic; intr; intr = intr->next)\n+\t\tif (intr->sym->attr.flavor == FL_DERIVED)\n+\t\t  {\n+\t\t    s = intr->sym;\n+\t\t    break;\n+\t\t  }\n+    \t    }\n+\n \t  if (!s->backend_decl)\n \t    s->backend_decl = gfc_get_derived_type (s);\n \t  gfc_copy_dt_decls_ifequal (s, sym, true);\n@@ -4035,7 +4047,18 @@ gfc_trans_use_stmts (gfc_namespace * ns)\n \t      st = gfc_find_symtree (ns->sym_root,\n \t\t\t\t     rent->local_name[0]\n \t\t\t\t     ? rent->local_name : rent->use_name);\n-\t      gcc_assert (st);\n+\n+\t      /* The following can happen if a derived type is renamed.  */\n+\t      if (!st)\n+\t\t{\n+\t\t  char *name;\n+\t\t  name = xstrdup (rent->local_name[0]\n+\t\t\t\t  ? rent->local_name : rent->use_name);\n+\t\t  name[0] = (char) TOUPPER ((unsigned char) name[0]);\n+\t\t  st = gfc_find_symtree (ns->sym_root, name);\n+\t\t  free (name);\n+\t\t  gcc_assert (st);\n+\t\t}\n \n \t      /* Sometimes, generic interfaces wind up being over-ruled by a\n \t\t local symbol (see PR41062).  */"}, {"sha": "3f4ebd5b7b7c038f7d22ac97bb060fa58e064994", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -2257,6 +2257,10 @@ gfc_get_derived_type (gfc_symbol * derived)\n   gfc_dt_list *dt;\n   gfc_namespace *ns;\n \n+  if (derived && derived->attr.flavor == FL_PROCEDURE\n+      && derived->attr.generic)\n+    derived = gfc_find_dt_in_generic (derived);\n+\n   gcc_assert (derived && derived->attr.flavor == FL_DERIVED);\n \n   /* See if it's one of the iso_c_binding derived types.  */"}, {"sha": "78c101aeeafdab03ed8f30ce477605083fb15f76", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -1,3 +1,24 @@\n+2011-11-16  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/39427\n+\tPR fortran/37829\n+\t* gfortran.dg/constructor_1.f90: New.\n+\t* gfortran.dg/constructor_2.f90: New.\n+\t* gfortran.dg/constructor_3.f90: New.\n+\t* gfortran.dg/constructor_4.f90: New.\n+\t* gfortran.dg/constructor_5.f90: New.\n+\t* gfortran.dg/constructor_6.f90: New.\n+\t* gfortran.dg/use_only_5.f90: New.\n+\t* gfortran.dg/c_ptr_tests_17.f90: New.\n+\t* gfortran.dg/c_ptr_tests_18.f90: New.\n+\t* gfortran.dg/used_types_25.f90: New.\n+\t* gfortran.dg/used_types_26.f90: New\n+\t* gfortran.dg/type_decl_3.f90: New.\n+\t* gfortran.dg/function_types_3.f90: Update dg-error.\n+\t* gfortran.dg/result_1.f90: Ditto.\n+\t* gfortran.dg/structure_constructor_3.f03: Ditto.\n+\t* gfortran.dg/structure_constructor_4.f03: Ditto.\n+\n 2011-10-16  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>\n \n \t* gcc.dg/vect/pr30858.c: Update expected output for\n@@ -12,7 +33,7 @@\n \n 2011-11-16  Razya Ladelsky  <razya@il.ibm.com>\n \n-        PR tree-optimization/49960\n+\tPR tree-optimization/49960\n \t* gcc.dg/autopar/pr49960.c: New test.\n \t* gcc.dg/autopar/pr49960-1.c: New test.\n "}, {"sha": "9bbd0dd41adceaeda7189ef7ee90f58db98360b9", "filename": "gcc/testsuite/gfortran.dg/c_ptr_tests_17.f90", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_17.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_17.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_17.f90?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -0,0 +1,88 @@\n+! { dg-do compile }\n+!\n+! PR fortran/37829\n+!\n+! Contributed by James Van Buskirk and Jerry DeLisle.\n+!\n+! Fix derived-type loading with ISO_BIND_C's C_PTR/C_FUNPTR.\n+\n+module m3\n+   use ISO_C_BINDING\n+   implicit none\n+   private\n+\n+   public kill_C_PTR\n+   interface\n+      function kill_C_PTR() bind(C)\n+         import\n+         implicit none\n+         type(C_PTR) kill_C_PTR\n+      end function kill_C_PTR\n+   end interface\n+\n+   public kill_C_FUNPTR\n+   interface\n+      function kill_C_FUNPTR() bind(C)\n+         import\n+         implicit none\n+         type(C_FUNPTR) kill_C_FUNPTR\n+      end function kill_C_FUNPTR\n+   end interface\n+end module m3\n+\n+module m1\n+   use m3\n+end module m1\n+\n+program X\n+   use m1\n+   use ISO_C_BINDING\n+   implicit none\n+   type(C_PTR) cp\n+   type(C_FUNPTR) fp\n+   integer(C_INT),target :: i\n+   interface\n+      function fun() bind(C)\n+         use ISO_C_BINDING\n+         implicit none\n+         real(C_FLOAT) fun\n+      end function fun\n+   end interface\n+\n+   cp = C_NULL_PTR\n+   cp = C_LOC(i)\n+   fp = C_NULL_FUNPTR\n+   fp = C_FUNLOC(fun)\n+end program X\n+\n+function fun() bind(C)\n+   use ISO_C_BINDING\n+   implicit none\n+   real(C_FLOAT) fun\n+   fun = 1.0\n+end function fun\n+\n+function kill_C_PTR() bind(C)\n+   use ISO_C_BINDING\n+   implicit none\n+   type(C_PTR) kill_C_PTR\n+   integer(C_INT), pointer :: p\n+   allocate(p)\n+   kill_C_PTR = C_LOC(p)\n+end function kill_C_PTR\n+\n+function kill_C_FUNPTR() bind(C)\n+   use ISO_C_BINDING\n+   implicit none\n+   type(C_FUNPTR) kill_C_FUNPTR\n+   interface\n+      function fun() bind(C)\n+         use ISO_C_BINDING\n+         implicit none\n+         real(C_FLOAT) fun\n+      end function fun\n+   end interface\n+   kill_C_FUNPTR = C_FUNLOC(fun)\n+end function kill_C_FUNPTR\n+\n+! { dg-final { cleanup-modules \"m3 m1\" } }"}, {"sha": "6239516ec2e84deeabd2f6bce3bf5e12a609f170", "filename": "gcc/testsuite/gfortran.dg/c_ptr_tests_18.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_18.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_18.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_18.f90?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do compile }\n+!\n+! PR fortran/37829\n+! PR fortran/45190\n+!\n+! Contributed by Mat Cross\n+!\n+! Fix derived-type loading with ISO_BIND_C's C_PTR/C_FUNPTR.\n+\n+MODULE NAG_J_TYPES\n+  USE ISO_C_BINDING, ONLY : C_PTR\n+  IMPLICIT NONE\n+  TYPE                            :: NAG_IMAGE\n+     INTEGER                      :: WIDTH, HEIGHT, PXFMT, NCHAN\n+     TYPE (C_PTR)                 :: PIXELS\n+  END TYPE NAG_IMAGE\n+END MODULE NAG_J_TYPES\n+program cfpointerstress\n+  use nag_j_types\n+  use iso_c_binding\n+  implicit none\n+  type(nag_image),pointer :: img\n+  type(C_PTR)             :: ptr\n+  real, pointer           :: r\n+  allocate(r)\n+  allocate(img)\n+  r = 12\n+  ptr = c_loc(img)\n+  write(*,*) 'C_ASSOCIATED =', C_ASSOCIATED(ptr)\n+  call c_f_pointer(ptr, img)\n+  write(*,*) 'ASSOCIATED =', associated(img)\n+  deallocate(r)\n+end program cfpointerstress\n+\n+! { dg-final { cleanup-modules \"nag_j_types\" } }"}, {"sha": "e8fe03ac38c44cfbdda69da11e50998b1174d53d", "filename": "gcc/testsuite/gfortran.dg/constructor_1.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fconstructor_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fconstructor_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fconstructor_1.f90?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do compile }\n+!\n+! PR fortran/39427\n+!\n+! Check constructor functionality.\n+!\n+! Contributed by Damian Rouson.\n+!\n+module mycomplex_module\n+   private\n+   public :: mycomplex\n+   type mycomplex\n+!      private\n+      real :: argument, modulus\n+   end type\n+   interface mycomplex\n+      module procedure complex_to_mycomplex, two_reals_to_mycomplex\n+   end interface\n+!   :\n+   contains\n+      type(mycomplex) function complex_to_mycomplex(c)\n+         complex, intent(in) :: c\n+!         :\n+      end function complex_to_mycomplex\n+      type(mycomplex) function two_reals_to_mycomplex(x,y)\n+         real, intent(in)           :: x\n+         real, intent(in), optional :: y\n+!         :\n+       end function two_reals_to_mycomplex\n+!       :\n+    end module mycomplex_module\n+!    :\n+program myuse\n+    use mycomplex_module\n+    type(mycomplex) :: a, b, c\n+!    :\n+    a = mycomplex(argument=5.6, modulus=1.0)  ! The structure constructor\n+    c = mycomplex(x=0.0, y=1.0)               ! A function reference\n+    c = mycomplex(0.0, 1.0)               ! A function reference\n+end program myuse\n+\n+! { dg-final { cleanup-modules \"mycomplex_module\" } }"}, {"sha": "0e3d8af29f30293412e3289baf579e0028302421", "filename": "gcc/testsuite/gfortran.dg/constructor_2.f90", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fconstructor_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fconstructor_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fconstructor_2.f90?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -0,0 +1,73 @@\n+! { dg-do run }\n+!\n+! PR fortran/39427\n+!\n+module foo_module\n+  interface foo\n+    procedure constructor\n+  end interface\n+\n+  type foo\n+    integer :: bar\n+  end type\n+contains\n+  type(foo) function constructor()\n+    constructor%bar = 1\n+  end function\n+\n+  subroutine test_foo()\n+    type(foo) :: f\n+    f = foo()\n+    if (f%bar /= 1) call abort ()\n+    f = foo(2)\n+    if (f%bar /= 2) call abort ()\n+  end subroutine test_foo\n+end module foo_module\n+\n+\n+! Same as foo_module but order\n+! of INTERFACE and TYPE reversed\n+module bar_module\n+  type bar\n+    integer :: bar\n+  end type\n+\n+  interface bar\n+    procedure constructor\n+  end interface\n+contains\n+  type(bar) function constructor()\n+    constructor%bar = 3\n+  end function\n+\n+  subroutine test_bar()\n+    type(bar) :: f\n+    f = bar()\n+    if (f%bar /= 3) call abort ()\n+    f = bar(4)\n+    if (f%bar /= 4) call abort ()\n+  end subroutine test_bar\n+end module bar_module\n+\n+program main\n+  use foo_module\n+  use bar_module\n+  implicit none\n+\n+  type(foo) :: f\n+  type(bar) :: b\n+\n+  call test_foo()\n+  f = foo()\n+  if (f%bar /= 1) call abort ()\n+  f = foo(2)\n+  if (f%bar /= 2) call abort ()\n+\n+  call test_bar()\n+  b = bar()\n+  if (b%bar /= 3) call abort ()\n+  b = bar(4)\n+  if (b%bar /= 4) call abort ()\n+end program main\n+\n+! { dg-final { cleanup-tree-dump \"foo_module bar_module\" } }"}, {"sha": "4015090bced724f727d6fe519ccbbff0e0b549b7", "filename": "gcc/testsuite/gfortran.dg/constructor_3.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fconstructor_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fconstructor_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fconstructor_3.f90?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do run }\n+!\n+! PR fortran/39427\n+!\n+! Check constructor functionality.\n+!\n+!\n+module m\n+  interface cons\n+    procedure cons42\n+  end interface cons\n+contains\n+  integer function cons42()\n+    cons42 = 42\n+  end function cons42\n+end module m\n+\n+\n+module m2\n+  type cons\n+    integer :: j = -1\n+  end type cons\n+  interface cons\n+    procedure consT\n+  end interface cons\n+contains\n+  type(cons) function consT(k)\n+    integer :: k\n+    consT%j = k**2\n+  end function consT\n+end module m2\n+\n+\n+use m\n+use m2, only: cons\n+implicit none\n+type(cons) :: x\n+integer :: k\n+x = cons(3)\n+k = cons()\n+if (x%j /= 9) call abort ()\n+if (k /= 42) call abort ()\n+!print *, x%j\n+!print *, k\n+end\n+\n+! { dg-final { cleanup-modules \"m m2\" } }"}, {"sha": "34dfba80c276e88fd3616c5f88cbca3168825b60", "filename": "gcc/testsuite/gfortran.dg/constructor_4.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fconstructor_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fconstructor_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fconstructor_4.f90?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+!\n+! PR fortran/39427\n+!\n+! Check constructor functionality.\n+!\n+!\n+module m\n+  type t ! { dg-error \"the same name as derived type\" }\n+    integer :: x\n+  end type t\n+  interface t\n+    module procedure f\n+  end interface t\n+contains\n+  function f() ! { dg-error \"the same name as derived type\" }\n+    type(t) :: f\n+  end function\n+end module\n+\n+module m2\n+  interface t2\n+    module procedure f2\n+  end interface t2\n+  type t2 ! { dg-error \"the same name as derived type\" }\n+    integer :: x2\n+  end type t2\n+contains\n+  function f2() ! { dg-error \"the same name as derived type\" }\n+    type(t2) :: f2\n+  end function\n+end module"}, {"sha": "ab9c9f2f5e3f32aeac9cf20b4748d9174df4939a", "filename": "gcc/testsuite/gfortran.dg/constructor_5.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fconstructor_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fconstructor_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fconstructor_5.f90?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do compile }\n+!\n+! PR fortran/39427\n+!\n+! Check constructor functionality.\n+!\n+!\n+module m\n+  type t\n+    integer :: x\n+  end type t\n+  interface t\n+    module procedure f\n+  end interface t\n+contains\n+  function f()\n+    type(t) :: f\n+  end function\n+end module\n+\n+module m2\n+  interface t2\n+    module procedure f2\n+  end interface t2\n+  type t2\n+    integer :: x2\n+  end type t2\n+contains\n+  function f2()\n+    type(t2) :: f2\n+  end function\n+end module\n+\n+! { dg-final { cleanup-modules \"m m2\" } }"}, {"sha": "00b99f2eba63c084da7783fcaab7cb66f29afe99", "filename": "gcc/testsuite/gfortran.dg/constructor_6.f90", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fconstructor_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fconstructor_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fconstructor_6.f90?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -0,0 +1,171 @@\n+! { dg-do run }\n+!\n+! PR fortran/39427\n+!\n+! Contributed by Norman S. Clerman (in PR fortran/45155)\n+!\n+! Constructor test case\n+!\n+!\n+module test_cnt\n+  integer, public, save :: my_test_cnt = 0\n+end module test_cnt\n+\n+module Rational\n+  use test_cnt\n+  implicit none\n+  private\n+\n+  type, public :: rational_t\n+    integer :: n = 0, id = 1\n+  contains\n+    procedure, nopass :: Construct_rational_t\n+    procedure :: Print_rational_t\n+    procedure, private :: Rational_t_init\n+    generic :: Rational_t => Construct_rational_t\n+    generic :: print      => Print_rational_t\n+  end type rational_t\n+\n+contains\n+\n+  function Construct_rational_t (message_) result (return_type)\n+    character (*), intent (in) :: message_\n+    type (rational_t) :: return_type\n+\n+!    print *, trim (message_)\n+    if (my_test_cnt /= 1) call abort()\n+    my_test_cnt = my_test_cnt + 1\n+    call return_type % Rational_t_init\n+\n+  end function Construct_rational_t\n+\n+  subroutine Print_rational_t (this_)\n+    class (rational_t), intent (in) :: this_\n+\n+!    print *, \"n, id\", this_% n, this_% id\n+    if (my_test_cnt == 0) then\n+      if (this_% n /= 0 .or. this_% id /= 1) call abort ()\n+    else if (my_test_cnt == 2) then\n+      if (this_% n /= 10 .or. this_% id /= 0) call abort ()\n+    else\n+      call abort ()\n+    end if\n+    my_test_cnt = my_test_cnt + 1\n+  end subroutine Print_rational_t\n+\n+  subroutine Rational_t_init (this_)\n+    class (rational_t), intent (in out) :: this_\n+\n+    this_% n = 10\n+    this_% id = 0\n+\n+  end subroutine Rational_t_init\n+\n+end module Rational\n+\n+module Temp_node\n+  use test_cnt\n+  implicit none\n+  private\n+\n+  real, parameter :: NOMINAL_TEMP = 20.0\n+\n+  type, public :: temp_node_t\n+    real :: temperature = NOMINAL_TEMP\n+    integer :: id = 1\n+  contains\n+    procedure :: Print_temp_node_t\n+    procedure, private :: Temp_node_t_init\n+    generic :: Print => Print_temp_node_t\n+  end type temp_node_t\n+\n+  interface temp_node_t\n+    module procedure Construct_temp_node_t\n+  end interface\n+\n+contains\n+\n+  function Construct_temp_node_t (message_) result (return_type)\n+    character (*), intent (in) :: message_\n+    type (temp_node_t) :: return_type\n+\n+    !print *, trim (message_)\n+    if (my_test_cnt /= 4) call abort()\n+    my_test_cnt = my_test_cnt + 1\n+    call return_type % Temp_node_t_init\n+\n+  end function Construct_temp_node_t\n+\n+  subroutine Print_temp_node_t (this_)\n+    class (temp_node_t), intent (in) :: this_\n+\n+!    print *, \"temp, id\", this_% temperature, this_% id\n+    if (my_test_cnt == 3) then\n+      if (this_% temperature /= 20 .or. this_% id /= 1) call abort ()\n+    else if (my_test_cnt == 5) then\n+      if (this_% temperature /= 10 .or. this_% id /= 0) call abort ()\n+    else\n+      call abort ()\n+    end if\n+    my_test_cnt = my_test_cnt + 1\n+  end subroutine Print_temp_node_t\n+\n+  subroutine Temp_node_t_init (this_)\n+    class (temp_node_t), intent (in out) :: this_\n+\n+    this_% temperature = 10.0\n+    this_% id = 0\n+\n+  end subroutine Temp_node_t_init\n+\n+end module Temp_node\n+\n+program Struct_over\n+  use test_cnt\n+  use Rational,  only : rational_t\n+  use Temp_node, only : temp_node_t\n+\n+  implicit none\n+\n+  type (rational_t)  :: sample_rational_t\n+  type (temp_node_t) :: sample_temp_node_t\n+\n+!  print *, \"rational_t\"\n+!  print *, \"----------\"\n+!  print *, \"\"\n+!\n+!  print *, \"after declaration\"\n+  if (my_test_cnt /= 0) call abort()\n+  call sample_rational_t % print\n+\n+  if (my_test_cnt /= 1) call abort()\n+\n+  sample_rational_t = sample_rational_t % rational_t (\"using override\")\n+  if (my_test_cnt /= 2) call abort()\n+!  print *, \"after override\"\n+  !  call print (sample_rational_t)\n+  !  call sample_rational_t % print ()\n+  call sample_rational_t % print\n+\n+  if (my_test_cnt /= 3) call abort()\n+\n+!  print *, \"sample_t\"\n+!  print *, \"--------\"\n+!  print *, \"\"\n+!\n+!  print *, \"after declaration\"\n+  call sample_temp_node_t % print\n+\n+  if (my_test_cnt /= 4) call abort()\n+\n+  sample_temp_node_t = temp_node_t (\"using override\")\n+  if (my_test_cnt /= 5) call abort()\n+!  print *, \"after override\"\n+  !  call print (sample_rational_t)\n+  !  call sample_rational_t % print ()\n+  call sample_temp_node_t % print\n+  if (my_test_cnt /= 6) call abort()\n+\n+end program Struct_over\n+\n+! { dg-final { cleanup-modules \"test_cnt rational temp_node\" } }"}, {"sha": "49d5d5f561bb917f094a45f52de6c6fe3a0956a0", "filename": "gcc/testsuite/gfortran.dg/function_types_3.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_types_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_types_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_types_3.f90?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -14,6 +14,6 @@ function f()      ! { dg-error \"must be a dummy argument\" }\n \n ! PR 50403: SIGSEGV in gfc_use_derived\n \n-type(f) function f()  ! { dg-error \"conflicts with DERIVED attribute|is not accessible\" }\n+type(f) function f()  ! { dg-error \"Type name 'f' at .1. conflicts with previously declared entity|The type for function 'f' at .1. is not accessible\" }\n   f=110               ! { dg-error \"Unclassifiable statement\" }\n end"}, {"sha": "96d2a1febe5704d4a4dd26ab09afe41dd43b025a", "filename": "gcc/testsuite/gfortran.dg/result_1.f90", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fresult_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fresult_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fresult_1.f90?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -14,5 +14,10 @@ function g() result(s)\n end function\n \n function h() result(t)\n-type t    ! { dg-error \"attribute conflicts\" }\n+type t    ! { dg-error \"GENERIC attribute conflicts with RESULT attribute\" }\n+end type t ! { dg-error \"Expecting END FUNCTION statement\" }\n+end function\n+\n+function i() result(t)\n+type t    ! { dg-error \"GENERIC attribute conflicts with RESULT attribute\" }\n end function"}, {"sha": "5fb7d612d0e39b96e7b58cc367fab2a3e1cda321", "filename": "gcc/testsuite/gfortran.dg/structure_constructor_3.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_3.f03?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -13,6 +13,6 @@ PROGRAM test\n \n   TYPE(basics_t) :: basics\n \n-  basics = basics_t (i=42, 1.5) ! { dg-error \"without name after\" }\n+  basics = basics_t (i=42, 1.5) ! { dg-error \"Missing keyword name\" }\n \n END PROGRAM test"}, {"sha": "8a5aaa7a23f9f9e3da25216f9fdc94964abc472d", "filename": "gcc/testsuite/gfortran.dg/structure_constructor_4.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_4.f03?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -14,6 +14,6 @@ PROGRAM test\n   TYPE(basics_t) :: basics\n \n   basics = basics_t (42, r=1.5, i=15) ! { dg-error \"'i' is initialized twice\" }\n-  basics = basics_t (42, r=1., r=-2.) ! { dg-error \"'r' is initialized twice\" }\n+  basics = basics_t (42, r=1., r=-2.) ! { dg-error \"has already appeared in the current argument list\" }\n \n END PROGRAM test"}, {"sha": "a3fc54ad32670f9c1b6032e0e9bd2a9ba1f960ac", "filename": "gcc/testsuite/gfortran.dg/type_decl_3.f90", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Ftype_decl_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Ftype_decl_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftype_decl_3.f90?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -0,0 +1,7 @@\n+! { dg-do compile }\n+!\n+! PR fortran/39427\n+!\n+   subroutine t(x) ! { dg-error \"conflicts with previously declared entity\" }\n+     type(t) :: x ! { dg-error \"conflicts with previously declared entity\" }\n+   end subroutine t"}, {"sha": "56d33f42750b9d390697192abd19f74ab675004f", "filename": "gcc/testsuite/gfortran.dg/use_only_5.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_only_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_only_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_only_5.f90?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do compile }\n+!\n+! PR fortran/39427\n+!\n+! Test case was failing with the initial version of the\n+! constructor patch.\n+!\n+! Based on the Fortran XML library FoX\n+\n+module m_common_attrs\n+  implicit none\n+  private\n+\n+  type dict_item\n+    integer, allocatable :: i(:)\n+  end type dict_item\n+\n+  type dictionary_t\n+    private\n+    type(dict_item), pointer :: d => null()\n+  end type dictionary_t\n+\n+  public :: dictionary_t\n+  public :: get_prefix_by_index\n+\n+contains\n+  pure function get_prefix_by_index(dict) result(prefix)\n+    type(dictionary_t), intent(in) :: dict\n+    character(len=size(dict%d%i)) :: prefix\n+  end function get_prefix_by_index\n+end module m_common_attrs\n+\n+module m_common_namespaces\n+  use m_common_attrs, only: dictionary_t\n+  use m_common_attrs, only: get_prefix_by_index\n+end module m_common_namespaces\n+\n+! { dg-final { cleanup-modules \"m_common_attrs m_common_namespaces\" } }"}, {"sha": "35ac8c75b86e3814e8913ef940a2c23248248df5", "filename": "gcc/testsuite/gfortran.dg/used_types_25.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_25.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_25.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_25.f90?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+!\n+! Created to check this ambiguity when\n+! constructors were added. Cf. PR fortran/39427\n+\n+module m\n+  type t\n+  end type t\n+end module m\n+\n+use m\n+ type t ! { dg-error \"Derived type definition of 't' at .1. has already been defined\" }\n+ end type t ! { dg-error \"Expecting END PROGRAM statement\" }\n+end\n+\n+! { dg-final { cleanup-modules \"m\" } }\n+"}, {"sha": "2c0437f63e17758b48021ea42efe7ea4a3c2161a", "filename": "gcc/testsuite/gfortran.dg/used_types_26.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_26.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f34952484cfe374448d5021dfb7dedf138c9ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_26.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_26.f90?ref=c3f34952484cfe374448d5021dfb7dedf138c9ab", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do compile }\n+!\n+! Check for ambiguity.\n+!\n+! Added as part of the constructor work (PR fortran/39427).\n+!\n+  module m\n+    type t\n+    end type t\n+  end module m\n+\n+  module m2\n+    type t\n+    end type t\n+  end module m2\n+\n+  use m\n+  use m2\n+  type(t) :: x ! { dg-error \"Type name 't' at .1. is ambiguous\" }\n+  end\n+\n+! { dg-final { cleanup-modules \"m m2\" } }"}]}