{"sha": "c312b9f280e4bf77c5b2869a9508ea3e8a6c5744", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzMxMmI5ZjI4MGU0YmY3N2M1YjI4NjlhOTUwOGVhM2U4YTZjNTc0NA==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-11-09T11:24:53Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-11-09T11:24:53Z"}, "message": "[multiple changes]\n\n2017-11-09  Piotr Trojanek  <trojanek@adacore.com>\n\n\t* sem_prag.adb (Analyze_Part_Of): Reword error message.\n\t(Get_SPARK_Mode_Type): Do not raise Program_Error in case pragma\n\tSPARK_Mode appears with an illegal mode, treat this as a non-existent\n\tmode.\n\n2017-11-09  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Analyze_Call): Reject a call to a function that returns\n\ta limited view of a type T declared in unit U1, when the function is\n\tdeclared in another unit U2 and the call appears in a procedure within\n\tanother unit.\n\n2017-11-09  Justin Squirek  <squirek@adacore.com>\n\n\t* sem_ch8.adb (Analyze_Use_Package): Force installation of use_clauses\n\twhen processing generic instances.\n\n2017-11-09  Bob Duff  <duff@adacore.com>\n\n\t* namet.ads, namet.adb (Valid_Name_Id): New subtype that excludes\n\tError_Name and No_Name.  Use this (versus Name_Id) to indicate which\n\tobjects can have those special values. Valid_Name_Id could usefully be\n\tused all over the compiler front end, but that's too much trouble for\n\tnow. If we did that, we might want to rename:\n\tName_Id --> Optional_Name_Id, Valid_Name_Id --> Name_Id.\n\tFor parameters of type Valid_Name_Id, remove some redundant tests,\n\tincluding the ones found by CodePeer.  Use Is_Valid_Name instead of\n\tmembership test when appropriate.\n\t(Error_Name_Or_No_Name): Delete this; it's no longer needed.\n\t* sem_ch2.adb (Analyze_Identifier): Use \"not Is_Valid_Name\" instead of\n\t\"in Error_Name_Or_No_Name\".\n\t(Check_Parameterless_Call): Use \"not Is_Valid_Name\" instead of \"in\n\tError_Name_Or_No_Name\".\n\nFrom-SVN: r254569", "tree": {"sha": "fa6e4b6952c72e3548456b6e8cdb7e351e7731e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa6e4b6952c72e3548456b6e8cdb7e351e7731e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c312b9f280e4bf77c5b2869a9508ea3e8a6c5744", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c312b9f280e4bf77c5b2869a9508ea3e8a6c5744", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c312b9f280e4bf77c5b2869a9508ea3e8a6c5744", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c312b9f280e4bf77c5b2869a9508ea3e8a6c5744/comments", "author": null, "committer": null, "parents": [{"sha": "c23f55b4932192981183ab6a3f914ef22476ec93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c23f55b4932192981183ab6a3f914ef22476ec93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c23f55b4932192981183ab6a3f914ef22476ec93"}], "stats": {"total": 294, "additions": 177, "deletions": 117}, "files": [{"sha": "1e599d03aa271a2e477ac9dd7305d878f9552bb7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c312b9f280e4bf77c5b2869a9508ea3e8a6c5744/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c312b9f280e4bf77c5b2869a9508ea3e8a6c5744/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c312b9f280e4bf77c5b2869a9508ea3e8a6c5744", "patch": "@@ -1,3 +1,39 @@\n+2017-11-09  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Part_Of): Reword error message.\n+\t(Get_SPARK_Mode_Type): Do not raise Program_Error in case pragma\n+\tSPARK_Mode appears with an illegal mode, treat this as a non-existent\n+\tmode.\n+\n+2017-11-09  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Analyze_Call): Reject a call to a function that returns\n+\ta limited view of a type T declared in unit U1, when the function is\n+\tdeclared in another unit U2 and the call appears in a procedure within\n+\tanother unit.\n+\n+2017-11-09  Justin Squirek  <squirek@adacore.com>\n+\n+\t* sem_ch8.adb (Analyze_Use_Package): Force installation of use_clauses\n+\twhen processing generic instances.\n+\n+2017-11-09  Bob Duff  <duff@adacore.com>\n+\n+\t* namet.ads, namet.adb (Valid_Name_Id): New subtype that excludes\n+\tError_Name and No_Name.  Use this (versus Name_Id) to indicate which\n+\tobjects can have those special values. Valid_Name_Id could usefully be\n+\tused all over the compiler front end, but that's too much trouble for\n+\tnow. If we did that, we might want to rename:\n+\tName_Id --> Optional_Name_Id, Valid_Name_Id --> Name_Id.\n+\tFor parameters of type Valid_Name_Id, remove some redundant tests,\n+\tincluding the ones found by CodePeer.  Use Is_Valid_Name instead of\n+\tmembership test when appropriate.\n+\t(Error_Name_Or_No_Name): Delete this; it's no longer needed.\n+\t* sem_ch2.adb (Analyze_Identifier): Use \"not Is_Valid_Name\" instead of\n+\t\"in Error_Name_Or_No_Name\".\n+\t(Check_Parameterless_Call): Use \"not Is_Valid_Name\" instead of \"in\n+\tError_Name_Or_No_Name\".\n+\n 2017-11-09  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gnat1drv.adb (Adjust_Global_Switches): Suppress warnings in codepeer"}, {"sha": "ddb54823439145817fccc2f9fe2c1cae48c6d172", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 65, "deletions": 68, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c312b9f280e4bf77c5b2869a9508ea3e8a6c5744/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c312b9f280e4bf77c5b2869a9508ea3e8a6c5744/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=c312b9f280e4bf77c5b2869a9508ea3e8a6c5744", "patch": "@@ -159,8 +159,8 @@ package body Namet is\n       Append (Buf, Buf2.Chars (1 .. Buf2.Length));\n    end Append;\n \n-   procedure Append (Buf : in out Bounded_String; Id : Name_Id) is\n-      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n+   procedure Append (Buf : in out Bounded_String; Id : Valid_Name_Id) is\n+      pragma Assert (Is_Valid_Name (Id));\n \n       Index : constant Int   := Name_Entries.Table (Id).Name_Chars_Index;\n       Len   : constant Short := Name_Entries.Table (Id).Name_Len;\n@@ -174,7 +174,9 @@ package body Namet is\n    -- Append_Decoded --\n    --------------------\n \n-   procedure Append_Decoded (Buf : in out Bounded_String; Id : Name_Id) is\n+   procedure Append_Decoded\n+     (Buf : in out Bounded_String; Id : Valid_Name_Id)\n+   is\n       C    : Character;\n       P    : Natural;\n       Temp : Bounded_String;\n@@ -449,7 +451,7 @@ package body Namet is\n \n    procedure Append_Decoded_With_Brackets\n      (Buf : in out Bounded_String;\n-      Id  : Name_Id)\n+      Id  : Valid_Name_Id)\n    is\n       P : Natural;\n \n@@ -596,7 +598,9 @@ package body Namet is\n    -- Append_Unqualified --\n    ------------------------\n \n-   procedure Append_Unqualified (Buf : in out Bounded_String; Id : Name_Id) is\n+   procedure Append_Unqualified\n+     (Buf : in out Bounded_String; Id : Valid_Name_Id)\n+   is\n       Temp : Bounded_String;\n    begin\n       Append (Temp, Id);\n@@ -610,7 +614,7 @@ package body Namet is\n \n    procedure Append_Unqualified_Decoded\n      (Buf : in out Bounded_String;\n-      Id  : Name_Id)\n+      Id  : Valid_Name_Id)\n    is\n       Temp : Bounded_String;\n    begin\n@@ -773,7 +777,7 @@ package body Namet is\n    -- Get_Decoded_Name_String --\n    -----------------------------\n \n-   procedure Get_Decoded_Name_String (Id : Name_Id) is\n+   procedure Get_Decoded_Name_String (Id : Valid_Name_Id) is\n    begin\n       Global_Name_Buffer.Length := 0;\n       Append_Decoded (Global_Name_Buffer, Id);\n@@ -783,7 +787,7 @@ package body Namet is\n    -- Get_Decoded_Name_String_With_Brackets --\n    -------------------------------------------\n \n-   procedure Get_Decoded_Name_String_With_Brackets (Id : Name_Id) is\n+   procedure Get_Decoded_Name_String_With_Brackets (Id : Valid_Name_Id) is\n    begin\n       Global_Name_Buffer.Length := 0;\n       Append_Decoded_With_Brackets (Global_Name_Buffer, Id);\n@@ -794,7 +798,7 @@ package body Namet is\n    ------------------------\n \n    procedure Get_Last_Two_Chars\n-     (N  : Name_Id;\n+     (N  : Valid_Name_Id;\n       C1 : out Character;\n       C2 : out Character)\n    is\n@@ -815,13 +819,13 @@ package body Namet is\n    -- Get_Name_String --\n    ---------------------\n \n-   procedure Get_Name_String (Id : Name_Id) is\n+   procedure Get_Name_String (Id : Valid_Name_Id) is\n    begin\n       Global_Name_Buffer.Length := 0;\n       Append (Global_Name_Buffer, Id);\n    end Get_Name_String;\n \n-   function Get_Name_String (Id : Name_Id) return String is\n+   function Get_Name_String (Id : Valid_Name_Id) return String is\n       Buf : Bounded_String (Max_Length => Natural (Length_Of_Name (Id)));\n    begin\n       Append (Buf, Id);\n@@ -832,7 +836,7 @@ package body Namet is\n    -- Get_Name_String_And_Append --\n    --------------------------------\n \n-   procedure Get_Name_String_And_Append (Id : Name_Id) is\n+   procedure Get_Name_String_And_Append (Id : Valid_Name_Id) is\n    begin\n       Append (Global_Name_Buffer, Id);\n    end Get_Name_String_And_Append;\n@@ -841,57 +845,57 @@ package body Namet is\n    -- Get_Name_Table_Boolean1 --\n    -----------------------------\n \n-   function Get_Name_Table_Boolean1 (Id : Name_Id) return Boolean is\n+   function Get_Name_Table_Boolean1 (Id : Valid_Name_Id) return Boolean is\n    begin\n-      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n+      pragma Assert (Is_Valid_Name (Id));\n       return Name_Entries.Table (Id).Boolean1_Info;\n    end Get_Name_Table_Boolean1;\n \n    -----------------------------\n    -- Get_Name_Table_Boolean2 --\n    -----------------------------\n \n-   function Get_Name_Table_Boolean2 (Id : Name_Id) return Boolean is\n+   function Get_Name_Table_Boolean2 (Id : Valid_Name_Id) return Boolean is\n    begin\n-      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n+      pragma Assert (Is_Valid_Name (Id));\n       return Name_Entries.Table (Id).Boolean2_Info;\n    end Get_Name_Table_Boolean2;\n \n    -----------------------------\n    -- Get_Name_Table_Boolean3 --\n    -----------------------------\n \n-   function Get_Name_Table_Boolean3 (Id : Name_Id) return Boolean is\n+   function Get_Name_Table_Boolean3 (Id : Valid_Name_Id) return Boolean is\n    begin\n-      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n+      pragma Assert (Is_Valid_Name (Id));\n       return Name_Entries.Table (Id).Boolean3_Info;\n    end Get_Name_Table_Boolean3;\n \n    -------------------------\n    -- Get_Name_Table_Byte --\n    -------------------------\n \n-   function Get_Name_Table_Byte (Id : Name_Id) return Byte is\n+   function Get_Name_Table_Byte (Id : Valid_Name_Id) return Byte is\n    begin\n-      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n+      pragma Assert (Is_Valid_Name (Id));\n       return Name_Entries.Table (Id).Byte_Info;\n    end Get_Name_Table_Byte;\n \n    -------------------------\n    -- Get_Name_Table_Int --\n    -------------------------\n \n-   function Get_Name_Table_Int (Id : Name_Id) return Int is\n+   function Get_Name_Table_Int (Id : Valid_Name_Id) return Int is\n    begin\n-      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n+      pragma Assert (Is_Valid_Name (Id));\n       return Name_Entries.Table (Id).Int_Info;\n    end Get_Name_Table_Int;\n \n    -----------------------------------------\n    -- Get_Unqualified_Decoded_Name_String --\n    -----------------------------------------\n \n-   procedure Get_Unqualified_Decoded_Name_String (Id : Name_Id) is\n+   procedure Get_Unqualified_Decoded_Name_String (Id : Valid_Name_Id) is\n    begin\n       Global_Name_Buffer.Length := 0;\n       Append_Unqualified_Decoded (Global_Name_Buffer, Id);\n@@ -901,7 +905,7 @@ package body Namet is\n    -- Get_Unqualified_Name_String --\n    ---------------------------------\n \n-   procedure Get_Unqualified_Name_String (Id : Name_Id) is\n+   procedure Get_Unqualified_Name_String (Id : Valid_Name_Id) is\n    begin\n       Global_Name_Buffer.Length := 0;\n       Append_Unqualified (Global_Name_Buffer, Id);\n@@ -1032,15 +1036,11 @@ package body Namet is\n       return False;\n    end Is_Internal_Name;\n \n-   function Is_Internal_Name (Id : Name_Id) return Boolean is\n+   function Is_Internal_Name (Id : Valid_Name_Id) return Boolean is\n       Buf : Bounded_String (Max_Length => Natural (Length_Of_Name (Id)));\n    begin\n-      if Id in Error_Name_Or_No_Name then\n-         return False;\n-      else\n-         Append (Buf, Id);\n-         return Is_Internal_Name (Buf);\n-      end if;\n+      Append (Buf, Id);\n+      return Is_Internal_Name (Buf);\n    end Is_Internal_Name;\n \n    function Is_Internal_Name return Boolean is\n@@ -1066,10 +1066,10 @@ package body Namet is\n    -- Is_Operator_Name --\n    ----------------------\n \n-   function Is_Operator_Name (Id : Name_Id) return Boolean is\n+   function Is_Operator_Name (Id : Valid_Name_Id) return Boolean is\n       S : Int;\n    begin\n-      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n+      pragma Assert (Is_Valid_Name (Id));\n       S := Name_Entries.Table (Id).Name_Chars_Index;\n       return Name_Chars.Table (S + 1) = 'O';\n    end Is_Operator_Name;\n@@ -1087,7 +1087,7 @@ package body Namet is\n    -- Length_Of_Name --\n    --------------------\n \n-   function Length_Of_Name (Id : Name_Id) return Nat is\n+   function Length_Of_Name (Id : Valid_Name_Id) return Nat is\n    begin\n       return Int (Name_Entries.Table (Id).Name_Len);\n    end Length_Of_Name;\n@@ -1111,7 +1111,7 @@ package body Namet is\n    ----------------\n \n    function Name_Enter\n-     (Buf : Bounded_String := Global_Name_Buffer) return Name_Id\n+     (Buf : Bounded_String := Global_Name_Buffer) return Valid_Name_Id\n    is\n    begin\n       Name_Entries.Append\n@@ -1136,7 +1136,7 @@ package body Namet is\n       return Name_Entries.Last;\n    end Name_Enter;\n \n-   function Name_Enter (S : String) return Name_Id is\n+   function Name_Enter (S : String) return Valid_Name_Id is\n       Buf : Bounded_String (Max_Length => S'Length);\n    begin\n       Append (Buf, S);\n@@ -1157,7 +1157,7 @@ package body Namet is\n    ---------------\n \n    function Name_Find\n-     (Buf : Bounded_String := Global_Name_Buffer) return Name_Id\n+     (Buf : Bounded_String := Global_Name_Buffer) return Valid_Name_Id\n    is\n       New_Id : Name_Id;\n       --  Id of entry in hash search, and value to be returned\n@@ -1172,7 +1172,7 @@ package body Namet is\n       --  Quick handling for one character names\n \n       if Buf.Length = 1 then\n-         return Name_Id (First_Name_Id + Character'Pos (Buf.Chars (1)));\n+         return Valid_Name_Id (First_Name_Id + Character'Pos (Buf.Chars (1)));\n \n       --  Otherwise search hash table for existing matching entry\n \n@@ -1241,7 +1241,7 @@ package body Namet is\n       end if;\n    end Name_Find;\n \n-   function Name_Find (S : String) return Name_Id is\n+   function Name_Find (S : String) return Valid_Name_Id is\n       Buf : Bounded_String (Max_Length => S'Length);\n    begin\n       Append (Buf, S);\n@@ -1476,7 +1476,7 @@ package body Namet is\n    -- Name_Equals --\n    -----------------\n \n-   function Name_Equals (N1 : Name_Id; N2 : Name_Id) return Boolean is\n+   function Name_Equals (N1, N2 : Valid_Name_Id) return Boolean is\n    begin\n       return N1 = N2 or else Get_Name_String (N1) = Get_Name_String (N2);\n    end Name_Equals;\n@@ -1550,49 +1550,49 @@ package body Namet is\n    -- Set_Name_Table_Boolean1 --\n    -----------------------------\n \n-   procedure Set_Name_Table_Boolean1 (Id : Name_Id; Val : Boolean) is\n+   procedure Set_Name_Table_Boolean1 (Id : Valid_Name_Id; Val : Boolean) is\n    begin\n-      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n+      pragma Assert (Is_Valid_Name (Id));\n       Name_Entries.Table (Id).Boolean1_Info := Val;\n    end Set_Name_Table_Boolean1;\n \n    -----------------------------\n    -- Set_Name_Table_Boolean2 --\n    -----------------------------\n \n-   procedure Set_Name_Table_Boolean2 (Id : Name_Id; Val : Boolean) is\n+   procedure Set_Name_Table_Boolean2 (Id : Valid_Name_Id; Val : Boolean) is\n    begin\n-      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n+      pragma Assert (Is_Valid_Name (Id));\n       Name_Entries.Table (Id).Boolean2_Info := Val;\n    end Set_Name_Table_Boolean2;\n \n    -----------------------------\n    -- Set_Name_Table_Boolean3 --\n    -----------------------------\n \n-   procedure Set_Name_Table_Boolean3 (Id : Name_Id; Val : Boolean) is\n+   procedure Set_Name_Table_Boolean3 (Id : Valid_Name_Id; Val : Boolean) is\n    begin\n-      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n+      pragma Assert (Is_Valid_Name (Id));\n       Name_Entries.Table (Id).Boolean3_Info := Val;\n    end Set_Name_Table_Boolean3;\n \n    -------------------------\n    -- Set_Name_Table_Byte --\n    -------------------------\n \n-   procedure Set_Name_Table_Byte (Id : Name_Id; Val : Byte) is\n+   procedure Set_Name_Table_Byte (Id : Valid_Name_Id; Val : Byte) is\n    begin\n-      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n+      pragma Assert (Is_Valid_Name (Id));\n       Name_Entries.Table (Id).Byte_Info := Val;\n    end Set_Name_Table_Byte;\n \n    -------------------------\n    -- Set_Name_Table_Int --\n    -------------------------\n \n-   procedure Set_Name_Table_Int (Id : Name_Id; Val : Int) is\n+   procedure Set_Name_Table_Int (Id : Valid_Name_Id; Val : Int) is\n    begin\n-      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n+      pragma Assert (Is_Valid_Name (Id));\n       Name_Entries.Table (Id).Int_Info := Val;\n    end Set_Name_Table_Int;\n \n@@ -1734,8 +1734,13 @@ package body Namet is\n \n    procedure wn (Id : Name_Id) is\n    begin\n-      if Id not in Name_Entries.First .. Name_Entries.Last then\n-         Write_Str (\"<invalid name_id>\");\n+      if Is_Valid_Name (Id) then\n+         declare\n+            Buf : Bounded_String (Max_Length => Natural (Length_Of_Name (Id)));\n+         begin\n+            Append (Buf, Id);\n+            Write_Str (Buf.Chars (1 .. Buf.Length));\n+         end;\n \n       elsif Id = No_Name then\n          Write_Str (\"<No_Name>\");\n@@ -1744,12 +1749,8 @@ package body Namet is\n          Write_Str (\"<Error_Name>\");\n \n       else\n-         declare\n-            Buf : Bounded_String (Max_Length => Natural (Length_Of_Name (Id)));\n-         begin\n-            Append (Buf, Id);\n-            Write_Str (Buf.Chars (1 .. Buf.Length));\n-         end;\n+         Write_Str (\"<invalid name_id>\");\n+         Write_Int (Int (Id));\n       end if;\n \n       Write_Eol;\n@@ -1759,26 +1760,22 @@ package body Namet is\n    -- Write_Name --\n    ----------------\n \n-   procedure Write_Name (Id : Name_Id) is\n+   procedure Write_Name (Id : Valid_Name_Id) is\n       Buf : Bounded_String (Max_Length => Natural (Length_Of_Name (Id)));\n    begin\n-      if Id >= First_Name_Id then\n-         Append (Buf, Id);\n-         Write_Str (Buf.Chars (1 .. Buf.Length));\n-      end if;\n+      Append (Buf, Id);\n+      Write_Str (Buf.Chars (1 .. Buf.Length));\n    end Write_Name;\n \n    ------------------------\n    -- Write_Name_Decoded --\n    ------------------------\n \n-   procedure Write_Name_Decoded (Id : Name_Id) is\n+   procedure Write_Name_Decoded (Id : Valid_Name_Id) is\n       Buf : Bounded_String;\n    begin\n-      if Id >= First_Name_Id then\n-         Append_Decoded (Buf, Id);\n-         Write_Str (Buf.Chars (1 .. Buf.Length));\n-      end if;\n+      Append_Decoded (Buf, Id);\n+      Write_Str (Buf.Chars (1 .. Buf.Length));\n    end Write_Name_Decoded;\n \n --  Package initialization, initialize tables"}, {"sha": "f5b078de92b90a5e2842189f5a81f03a6ac2ead4", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c312b9f280e4bf77c5b2869a9508ea3e8a6c5744/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c312b9f280e4bf77c5b2869a9508ea3e8a6c5744/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=c312b9f280e4bf77c5b2869a9508ea3e8a6c5744", "patch": "@@ -198,12 +198,12 @@ package Namet is\n    --  indicate that some kind of error was encountered in scanning out\n    --  the relevant name, so it does not have a representable label.\n \n-   subtype Error_Name_Or_No_Name is Name_Id range No_Name .. Error_Name;\n-   --  Used to test for either error name or no name\n-\n    First_Name_Id : constant Name_Id := Names_Low_Bound + 2;\n    --  Subscript of first entry in names table\n \n+   subtype Valid_Name_Id is Name_Id range First_Name_Id .. Name_Id'Last;\n+   --  All but No_Name and Error_Name\n+\n    ------------------------------\n    -- Name_Id Membership Tests --\n    ------------------------------\n@@ -337,17 +337,17 @@ package Namet is\n    function \"+\" (Buf : Bounded_String) return String renames To_String;\n \n    function Name_Find\n-     (Buf : Bounded_String := Global_Name_Buffer) return Name_Id;\n-   function Name_Find (S : String) return Name_Id;\n+     (Buf : Bounded_String := Global_Name_Buffer) return Valid_Name_Id;\n+   function Name_Find (S : String) return Valid_Name_Id;\n    --  Name_Find searches the names table to see if the string has already been\n    --  stored. If so, the Id of the existing entry is returned. Otherwise a new\n    --  entry is created with its Name_Table_Int fields set to zero/false. Note\n    --  that it is permissible for Buf.Length to be zero to lookup the empty\n    --  name string.\n \n    function Name_Enter\n-     (Buf : Bounded_String := Global_Name_Buffer) return Name_Id;\n-   function Name_Enter (S : String) return Name_Id;\n+     (Buf : Bounded_String := Global_Name_Buffer) return Valid_Name_Id;\n+   function Name_Enter (S : String) return Valid_Name_Id;\n    --  Name_Enter is similar to Name_Find. The difference is that it does not\n    --  search the table for an existing match, and also subsequent Name_Find\n    --  calls using the same name will not locate the entry created by this\n@@ -358,10 +358,10 @@ package Namet is\n    --  names, since these are efficiently located without hashing by Name_Find\n    --  in any case.\n \n-   function Name_Equals (N1 : Name_Id; N2 : Name_Id) return Boolean;\n+   function Name_Equals (N1, N2 : Valid_Name_Id) return Boolean;\n    --  Return whether N1 and N2 denote the same character sequence\n \n-   function Get_Name_String (Id : Name_Id) return String;\n+   function Get_Name_String (Id : Valid_Name_Id) return String;\n    --  Returns the characters of Id as a String. The lower bound is 1.\n \n    --  The following Append procedures ignore any characters that don't fit in\n@@ -380,11 +380,11 @@ package Namet is\n    procedure Append (Buf : in out Bounded_String; Buf2 : Bounded_String);\n    --  Append Buf2 onto Buf\n \n-   procedure Append (Buf : in out Bounded_String; Id : Name_Id);\n+   procedure Append (Buf : in out Bounded_String; Id : Valid_Name_Id);\n    --  Append the characters of Id onto Buf. It is an error to call this with\n    --  one of the special name Id values (No_Name or Error_Name).\n \n-   procedure Append_Decoded (Buf : in out Bounded_String; Id : Name_Id);\n+   procedure Append_Decoded (Buf : in out Bounded_String; Id : Valid_Name_Id);\n    --  Same as Append, except that the result is decoded, so that upper half\n    --  characters and wide characters appear as originally found in the source\n    --  program text, operators have their source forms (special characters and\n@@ -393,7 +393,7 @@ package Namet is\n \n    procedure Append_Decoded_With_Brackets\n      (Buf : in out Bounded_String;\n-      Id  : Name_Id);\n+      Id  : Valid_Name_Id);\n    --  Same as Append_Decoded, except that the brackets notation (Uhh\n    --  replaced by [\"hh\"], Whhhh replaced by [\"hhhh\"], WWhhhhhhhh replaced by\n    --  [\"hhhhhhhh\"]) is used for all non-lower half characters, regardless of\n@@ -403,7 +403,8 @@ package Namet is\n    --  requirement for a canonical representation not affected by the\n    --  character set options (e.g. in the binder generation of symbols).\n \n-   procedure Append_Unqualified (Buf : in out Bounded_String; Id : Name_Id);\n+   procedure Append_Unqualified\n+     (Buf : in out Bounded_String; Id : Valid_Name_Id);\n    --  Same as Append, except that qualification (as defined in unit\n    --  Exp_Dbug) is removed (including both preceding __ delimited names, and\n    --  also the suffixes used to indicate package body entities and to\n@@ -415,7 +416,7 @@ package Namet is\n \n    procedure Append_Unqualified_Decoded\n      (Buf : in out Bounded_String;\n-      Id  : Name_Id);\n+      Id  : Valid_Name_Id);\n    --  Same as Append_Unqualified, but decoded as for Append_Decoded\n \n    procedure Append_Encoded (Buf : in out Bounded_String; C : Char_Code);\n@@ -443,40 +444,40 @@ package Namet is\n    function Is_Internal_Name (Buf : Bounded_String) return Boolean;\n \n    procedure Get_Last_Two_Chars\n-     (N  : Name_Id;\n+     (N  : Valid_Name_Id;\n       C1 : out Character;\n       C2 : out Character);\n    --  Obtains last two characters of a name. C1 is last but one character and\n    --  C2 is last character. If name is less than two characters long then both\n    --  C1 and C2 are set to ASCII.NUL on return.\n \n-   function Get_Name_Table_Boolean1 (Id : Name_Id) return Boolean;\n-   function Get_Name_Table_Boolean2 (Id : Name_Id) return Boolean;\n-   function Get_Name_Table_Boolean3 (Id : Name_Id) return Boolean;\n+   function Get_Name_Table_Boolean1 (Id : Valid_Name_Id) return Boolean;\n+   function Get_Name_Table_Boolean2 (Id : Valid_Name_Id) return Boolean;\n+   function Get_Name_Table_Boolean3 (Id : Valid_Name_Id) return Boolean;\n    --  Fetches the Boolean values associated with the given name\n \n-   function Get_Name_Table_Byte (Id : Name_Id) return Byte;\n+   function Get_Name_Table_Byte (Id : Valid_Name_Id) return Byte;\n    pragma Inline (Get_Name_Table_Byte);\n    --  Fetches the Byte value associated with the given name\n \n-   function Get_Name_Table_Int (Id : Name_Id) return Int;\n+   function Get_Name_Table_Int (Id : Valid_Name_Id) return Int;\n    pragma Inline (Get_Name_Table_Int);\n    --  Fetches the Int value associated with the given name\n \n-   procedure Set_Name_Table_Boolean1 (Id : Name_Id; Val : Boolean);\n-   procedure Set_Name_Table_Boolean2 (Id : Name_Id; Val : Boolean);\n-   procedure Set_Name_Table_Boolean3 (Id : Name_Id; Val : Boolean);\n+   procedure Set_Name_Table_Boolean1 (Id : Valid_Name_Id; Val : Boolean);\n+   procedure Set_Name_Table_Boolean2 (Id : Valid_Name_Id; Val : Boolean);\n+   procedure Set_Name_Table_Boolean3 (Id : Valid_Name_Id; Val : Boolean);\n    --  Sets the Boolean value associated with the given name\n \n-   procedure Set_Name_Table_Byte (Id : Name_Id; Val : Byte);\n+   procedure Set_Name_Table_Byte (Id : Valid_Name_Id; Val : Byte);\n    pragma Inline (Set_Name_Table_Byte);\n    --  Sets the Byte value associated with the given name\n \n-   procedure Set_Name_Table_Int (Id : Name_Id; Val : Int);\n+   procedure Set_Name_Table_Int (Id : Valid_Name_Id; Val : Int);\n    pragma Inline (Set_Name_Table_Int);\n    --  Sets the Int value associated with the given name\n \n-   function Is_Internal_Name (Id : Name_Id) return Boolean;\n+   function Is_Internal_Name (Id : Valid_Name_Id) return Boolean;\n    --  Returns True if the name is an internal name, i.e. contains a character\n    --  for which Is_OK_Internal_Letter is true, or if the name starts or ends\n    --  with an underscore.\n@@ -500,15 +501,15 @@ package Namet is\n    --  set of reserved letters is O, Q, U, W) and also returns False for the\n    --  letter X, which is reserved for debug output (see Exp_Dbug).\n \n-   function Is_Operator_Name (Id : Name_Id) return Boolean;\n+   function Is_Operator_Name (Id : Valid_Name_Id) return Boolean;\n    --  Returns True if name given is of the form of an operator (that is, it\n    --  starts with an upper case O).\n \n    function Is_Valid_Name (Id : Name_Id) return Boolean;\n    --  True if Id is a valid name - points to a valid entry in the Name_Entries\n    --  table.\n \n-   function Length_Of_Name (Id : Name_Id) return Nat;\n+   function Length_Of_Name (Id : Valid_Name_Id) return Nat;\n    pragma Inline (Length_Of_Name);\n    --  Returns length of given name in characters. This is the length of the\n    --  encoded name, as stored in the names table.\n@@ -553,13 +554,13 @@ package Namet is\n    --  Writes out internal tables to current tree file using the relevant\n    --  Table.Tree_Write routines.\n \n-   procedure Write_Name (Id : Name_Id);\n+   procedure Write_Name (Id : Valid_Name_Id);\n    --  Write_Name writes the characters of the specified name using the\n    --  standard output procedures in package Output. The name is written\n    --  in encoded form (i.e. including Uhh, Whhh, Qx, _op as they appear in\n    --  the name table). If Id is Error_Name, or No_Name, no text is output.\n \n-   procedure Write_Name_Decoded (Id : Name_Id);\n+   procedure Write_Name_Decoded (Id : Valid_Name_Id);\n    --  Like Write_Name, except that the name written is the decoded name, as\n    --  described for Append_Decoded.\n \n@@ -586,17 +587,17 @@ package Namet is\n \n    procedure Add_Str_To_Name_Buffer (S : String);\n \n-   procedure Get_Decoded_Name_String (Id : Name_Id);\n+   procedure Get_Decoded_Name_String (Id : Valid_Name_Id);\n \n-   procedure Get_Decoded_Name_String_With_Brackets (Id : Name_Id);\n+   procedure Get_Decoded_Name_String_With_Brackets (Id : Valid_Name_Id);\n \n-   procedure Get_Name_String (Id : Name_Id);\n+   procedure Get_Name_String (Id : Valid_Name_Id);\n \n-   procedure Get_Name_String_And_Append (Id : Name_Id);\n+   procedure Get_Name_String_And_Append (Id : Valid_Name_Id);\n \n-   procedure Get_Unqualified_Decoded_Name_String (Id : Name_Id);\n+   procedure Get_Unqualified_Decoded_Name_String (Id : Valid_Name_Id);\n \n-   procedure Get_Unqualified_Name_String (Id : Name_Id);\n+   procedure Get_Unqualified_Name_String (Id : Valid_Name_Id);\n \n    procedure Insert_Str_In_Name_Buffer (S : String; Index : Positive);\n \n@@ -739,12 +740,12 @@ private\n    for Name_Entry'Size use 16 * 8;\n    --  This ensures that we did not leave out any fields\n \n-   --  This is the table that is referenced by Name_Id entries.\n+   --  This is the table that is referenced by Valid_Name_Id entries.\n    --  It contains one entry for each unique name in the table.\n \n    package Name_Entries is new Table.Table (\n      Table_Component_Type => Name_Entry,\n-     Table_Index_Type     => Name_Id'Base,\n+     Table_Index_Type     => Valid_Name_Id'Base,\n      Table_Low_Bound      => First_Name_Id,\n      Table_Initial        => Alloc.Names_Initial,\n      Table_Increment      => Alloc.Names_Increment,"}, {"sha": "92f1c0215b6528d244b516050f8b9fcd8b2b7688", "filename": "gcc/ada/sem_ch2.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c312b9f280e4bf77c5b2869a9508ea3e8a6c5744/gcc%2Fada%2Fsem_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c312b9f280e4bf77c5b2869a9508ea3e8a6c5744/gcc%2Fada%2Fsem_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch2.adb?ref=c312b9f280e4bf77c5b2869a9508ea3e8a6c5744", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -68,7 +68,7 @@ package body Sem_Ch2 is\n       --  this is the result of some kind of previous error generating a\n       --  junk identifier.\n \n-      if Chars (N) in Error_Name_Or_No_Name\n+      if not Is_Valid_Name (Chars (N))\n         and then Total_Errors_Detected /= 0\n       then\n          return;"}, {"sha": "c8ef8d8e0956a6c01cc3b447d972d073895af438", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c312b9f280e4bf77c5b2869a9508ea3e8a6c5744/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c312b9f280e4bf77c5b2869a9508ea3e8a6c5744/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=c312b9f280e4bf77c5b2869a9508ea3e8a6c5744", "patch": "@@ -1520,6 +1520,27 @@ package body Sem_Ch4 is\n               and then Present (Non_Limited_View (Etype (N)))\n             then\n                Set_Etype (N, Non_Limited_View (Etype (N)));\n+\n+            --  If there is no completion for the type, this may be because\n+            --  there is only a limited view of it and there is nothing in\n+            --  the context of the current unit that has required a regular\n+            --  compilation of the unit containing the type. We recognize\n+            --  this unusual case by the fact that that unit is not analyzed.\n+            --  Note that the call being analyzed is in a different unit from\n+            --  the function declaration, and nothing indicates that the type\n+            --  is a limited view.\n+\n+            elsif Ekind (Scope (Etype (N))) = E_Package\n+              and then Present (Limited_View (Scope (Etype (N))))\n+              and then not Analyzed (Unit_Declaration_Node (Scope (Etype (N))))\n+            then\n+               Error_Msg_NE (\"cannot call function that returns \"\n+                 & \"limited view of}\", N, Etype (N));\n+               Error_Msg_NE\n+                 (\"\\there must be a regular with_clause for package& \"\n+                   & \"in the current unit, or in some unit in its context\",\n+                    N, Scope (Etype (N)));\n+               Set_Etype (N, Any_Type);\n             end if;\n          end if;\n       end if;\n@@ -8681,7 +8702,8 @@ package body Sem_Ch4 is\n          else\n             --  The type of the subprogram may be a limited view obtained\n             --  transitively from another unit. If full view is available,\n-            --  use it to analyze call.\n+            --  use it to analyze call. If there is no nonlimited view, then\n+            --  this is diagnosed when analyzing the rewritten call.\n \n             declare\n                T : constant Entity_Id := Etype (Subprog);"}, {"sha": "aea9bf8b48061c537a41b2ed440ed4b2a76b3c3f", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c312b9f280e4bf77c5b2869a9508ea3e8a6c5744/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c312b9f280e4bf77c5b2869a9508ea3e8a6c5744/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=c312b9f280e4bf77c5b2869a9508ea3e8a6c5744", "patch": "@@ -3821,7 +3821,10 @@ package body Sem_Ch8 is\n             Check_In_Previous_With_Clause (N, Name (N));\n          end if;\n \n-         Use_One_Package (N, Name (N));\n+         --  Force the use_clause when we are in a generic instance because the\n+         --  scope of the package has changed and we must ensure visibility.\n+\n+         Use_One_Package (N, Name (N), Force => In_Instance);\n \n          --  Capture the first Ghost package and the first living package\n "}, {"sha": "596f306af3dc610382683e74cc8a34f915b87646", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c312b9f280e4bf77c5b2869a9508ea3e8a6c5744/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c312b9f280e4bf77c5b2869a9508ea3e8a6c5744/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=c312b9f280e4bf77c5b2869a9508ea3e8a6c5744", "patch": "@@ -3287,8 +3287,8 @@ package body Sem_Prag is\n \n                if not Is_Child_Or_Sibling (Pack_Id, Scope (Encap_Id)) then\n                   SPARK_Msg_NE\n-                    (\"indicator Part_Of must denote abstract state or public \"\n-                     & \"descendant of & (SPARK RM 7.2.6(3))\",\n+                    (\"indicator Part_Of must denote abstract state of & \"\n+                     & \"or of its public descendant (SPARK RM 7.2.6(3))\",\n                      Indic, Parent_Unit);\n                   return;\n \n@@ -3301,8 +3301,8 @@ package body Sem_Prag is\n \n                else\n                   SPARK_Msg_NE\n-                    (\"indicator Part_Of must denote abstract state or public \"\n-                     & \"descendant of & (SPARK RM 7.2.6(3))\",\n+                    (\"indicator Part_Of must denote abstract state of & \"\n+                     & \"or of its public descendant (SPARK RM 7.2.6(3))\",\n                      Indic, Parent_Unit);\n                   return;\n                end if;\n@@ -29364,10 +29364,11 @@ package body Sem_Prag is\n       elsif N = Name_Off then\n          return Off;\n \n-      --  Any other argument is illegal\n+      --  Any other argument is illegal. Assume that no SPARK mode applies to\n+      --  avoid potential cascaded errors.\n \n       else\n-         raise Program_Error;\n+         return None;\n       end if;\n    end Get_SPARK_Mode_Type;\n "}, {"sha": "49a654f8fd69453754defadf885ecc66a181e440", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c312b9f280e4bf77c5b2869a9508ea3e8a6c5744/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c312b9f280e4bf77c5b2869a9508ea3e8a6c5744/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=c312b9f280e4bf77c5b2869a9508ea3e8a6c5744", "patch": "@@ -1030,7 +1030,7 @@ package body Sem_Res is\n          if Nkind (N) in N_Has_Etype and then Etype (N) = Any_Type then\n             return;\n          elsif Nkind (N) in N_Has_Chars\n-           and then Chars (N) in Error_Name_Or_No_Name\n+           and then not Is_Valid_Name (Chars (N))\n          then\n             return;\n          end if;"}]}