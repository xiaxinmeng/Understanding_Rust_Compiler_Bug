{"sha": "551d69292f127eb1625d3d4f56d57049876c581f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUxZDY5MjkyZjEyN2ViMTYyNWQzZDRmNTZkNTcwNDk4NzZjNTgxZg==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2007-02-21T15:05:01Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2007-02-21T15:05:01Z"}, "message": "re PR middle-end/30761 (Error: unsupported relocation against sfp)\n\n\tPR middle-end/30761\n\t* reload1.c (eliminate_regs_in_insn): In the single_set special\n\tcase, attempt to re-recognize the insn before falling back to\n\thaving reload fix it up.\n\nFrom-SVN: r122199", "tree": {"sha": "c499bc04c3f21099f3f26ea278da323d2ed87637", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c499bc04c3f21099f3f26ea278da323d2ed87637"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/551d69292f127eb1625d3d4f56d57049876c581f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/551d69292f127eb1625d3d4f56d57049876c581f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/551d69292f127eb1625d3d4f56d57049876c581f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/551d69292f127eb1625d3d4f56d57049876c581f/comments", "author": null, "committer": null, "parents": [{"sha": "71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71d6fc6b0b32ba0b1c1aabe9ccac7ff0e069dbb2"}], "stats": {"total": 49, "additions": 24, "deletions": 25}, "files": [{"sha": "59d93bb9962fbe3ff927e7e0ad066432af694ad8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/551d69292f127eb1625d3d4f56d57049876c581f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/551d69292f127eb1625d3d4f56d57049876c581f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=551d69292f127eb1625d3d4f56d57049876c581f", "patch": "@@ -1,3 +1,10 @@\n+2007-02-21  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\tPR middle-end/30761\n+\t* reload1.c (eliminate_regs_in_insn): In the single_set special\n+\tcase, attempt to re-recognize the insn before falling back to\n+\thaving reload fix it up.\n+\n 2007-02-20  Eric Christopher  <echristo@gmail.com>\n \n \t* config/frv/frv.c (frv_read_argument): Take a tree and int argument."}, {"sha": "c86b2bd429f57e363bd320729a58e901246a77db", "filename": "gcc/reload1.c", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/551d69292f127eb1625d3d4f56d57049876c581f/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/551d69292f127eb1625d3d4f56d57049876c581f/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=551d69292f127eb1625d3d4f56d57049876c581f", "patch": "@@ -3105,35 +3105,15 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t    if (GET_CODE (XEXP (plus_cst_src, 0)) == SUBREG)\n \t      to_rtx = gen_lowpart (GET_MODE (XEXP (plus_cst_src, 0)),\n \t\t\t\t    to_rtx);\n-\t    if (offset == 0)\n-\t      {\n-\t\tint num_clobbers;\n-\t\t/* We assume here that if we need a PARALLEL with\n-\t\t   CLOBBERs for this assignment, we can do with the\n-\t\t   MATCH_SCRATCHes that add_clobbers allocates.\n-\t\t   There's not much we can do if that doesn't work.  */\n-\t\tPATTERN (insn) = gen_rtx_SET (VOIDmode,\n-\t\t\t\t\t      SET_DEST (old_set),\n-\t\t\t\t\t      to_rtx);\n-\t\tnum_clobbers = 0;\n-\t\tINSN_CODE (insn) = recog (PATTERN (insn), insn, &num_clobbers);\n-\t\tif (num_clobbers)\n-\t\t  {\n-\t\t    rtvec vec = rtvec_alloc (num_clobbers + 1);\n-\n-\t\t    vec->elem[0] = PATTERN (insn);\n-\t\t    PATTERN (insn) = gen_rtx_PARALLEL (VOIDmode, vec);\n-\t\t    add_clobbers (PATTERN (insn), INSN_CODE (insn));\n-\t\t  }\n-\t\tgcc_assert (INSN_CODE (insn) >= 0);\n-\t      }\n \t    /* If we have a nonzero offset, and the source is already\n \t       a simple REG, the following transformation would\n \t       increase the cost of the insn by replacing a simple REG\n \t       with (plus (reg sp) CST).  So try only when we already\n \t       had a PLUS before.  */\n-\t    else if (plus_src)\n+\t    if (offset == 0 || plus_src)\n \t      {\n+\t\trtx new_src = plus_constant (to_rtx, offset);\n+\n \t\tnew_body = old_body;\n \t\tif (! replace)\n \t\t  {\n@@ -3144,8 +3124,20 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t\tPATTERN (insn) = new_body;\n \t\told_set = single_set (insn);\n \n-\t\tXEXP (SET_SRC (old_set), 0) = to_rtx;\n-\t\tXEXP (SET_SRC (old_set), 1) = GEN_INT (offset);\n+\t\t/* First see if this insn remains valid when we make the\n+\t\t   change.  If not, try to replace the whole pattern with\n+\t\t   a simple set (this may help if the original insn was a\n+\t\t   PARALLEL that was only recognized as single_set due to \n+\t\t   REG_UNUSED notes).  If this isn't valid either, keep\n+\t\t   the INSN_CODE the same and let reload fix it up.  */\n+\t\tif (!validate_change (insn, &SET_SRC (old_set), new_src, 0))\n+\t\t  {\n+\t\t    rtx new_pat = gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t       SET_DEST (old_set), new_src);\n+\n+\t\t    if (!validate_change (insn, &PATTERN (insn), new_pat, 0))\n+\t\t      SET_SRC (old_set) = new_src;\n+\t\t  }\n \t      }\n \t    else\n \t      break;"}]}