{"sha": "4af3895e739fefe2d158ab1c632d7d860abd4705", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFmMzg5NWU3MzlmZWZlMmQxNThhYjFjNjMyZDdkODYwYWJkNDcwNQ==", "commit": {"author": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-04-12T21:47:29Z"}, "committer": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-04-12T21:47:29Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r731", "tree": {"sha": "41610a367e4ab958ae72a8d9dba7353b23800431", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41610a367e4ab958ae72a8d9dba7353b23800431"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4af3895e739fefe2d158ab1c632d7d860abd4705", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4af3895e739fefe2d158ab1c632d7d860abd4705", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4af3895e739fefe2d158ab1c632d7d860abd4705", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4af3895e739fefe2d158ab1c632d7d860abd4705/comments", "author": null, "committer": null, "parents": [{"sha": "dcfedcd0da4e503b81c99e13e773f71f7035102c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcfedcd0da4e503b81c99e13e773f71f7035102c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcfedcd0da4e503b81c99e13e773f71f7035102c"}], "stats": {"total": 309, "additions": 132, "deletions": 177}, "files": [{"sha": "3495d1da6b11fe3fbf5a44f729b1f01c296a9a8a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af3895e739fefe2d158ab1c632d7d860abd4705/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af3895e739fefe2d158ab1c632d7d860abd4705/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=4af3895e739fefe2d158ab1c632d7d860abd4705", "patch": "@@ -976,8 +976,6 @@ print_operand (file, x, code)\n \t    putc ('*', file);\n \t  return;\n \n-\tcase 'D':\n-\t  PUT_OP_SIZE (code, 'l', file);\n \tcase 'L':\n \t  PUT_OP_SIZE (code, 'l', file);\n \t  return;\n@@ -998,10 +996,6 @@ print_operand (file, x, code)\n \t  PUT_OP_SIZE (code, 's', file);\n \t  return;\n \n-\tcase 'R':\n-\t  fprintf (file, \"%s\", RP);\n-\t  return;\n-\n \tcase 'z':\n \t  /* 387 opcodes don't get size suffixes if the operands are\n \t     registers. */\n@@ -1037,6 +1031,17 @@ print_operand (file, x, code)\n \t      PUT_OP_SIZE ('Q', 'l', file);\n \t      return;\n \t    }\n+\n+\tcase 'b':\n+\tcase 'w':\n+\tcase 'k':\n+\tcase 'h':\n+\tcase 'y':\n+\tcase 'P':\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n \t}\n     }\n   if (GET_CODE (x) == REG)\n@@ -1063,13 +1068,8 @@ print_operand (file, x, code)\n       u.i[0] = CONST_DOUBLE_LOW (x);\n       u.i[1] = CONST_DOUBLE_HIGH (x);\n       u1.f = u.d;\n-      if (code == 'f')\n-        fprintf (file, \"%.22e\", u1.f);\n-      else\n-        {\n-\t  PRINT_IMMED_PREFIX (file);\n-\t  fprintf (file, \"0x%x\", u1.i);\n-\t}\n+      PRINT_IMMED_PREFIX (file);\n+      fprintf (file, \"0x%x\", u1.i);\n     }\n   else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == DFmode)\n     {\n@@ -1080,7 +1080,7 @@ print_operand (file, x, code)\n     }\n   else \n     {\n-      if (code != 'c' && code != 'P')\n+      if (code != 'P')\n \t{\n \t  if (GET_CODE (x) == CONST_INT)\n \t    PRINT_IMMED_PREFIX (file);"}, {"sha": "561eb8f7173da1c9ec8032b43706c88457e15ab2", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 35, "deletions": 134, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af3895e739fefe2d158ab1c632d7d860abd4705/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af3895e739fefe2d158ab1c632d7d860abd4705/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=4af3895e739fefe2d158ab1c632d7d860abd4705", "patch": "@@ -19,37 +19,41 @@\n ;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n \n \n-;;- instruction definitions\n+;; The original PO technology requires these to be ordered by speed,\n+;; so that assigner will pick the fastest.\n \n-;;- @@The original PO technology requires these to be ordered by speed,\n-;;- @@    so that assigner will pick the fastest.\n+;; See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n \n-;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+;; Macro #define NOTICE_UPDATE_CC in file i386.h handles condition code\n+;; updates for most instructions.\n \n-;;- When naming insn's (operand 0 of define_insn) be careful about using\n-;;- names from other targets machine descriptions.\n-\n-;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code\n-;;- updates for most instructions.\n-\n-;;- Operand classes for the register allocator:\n-;;- 'a' for eax\n-;;- 'd' for edx\n-;;- 'c' for ecx\n-;;- 'b' for ebx\n-;;- 'f' for anything in FLOAT_REGS\n-;;- 'r' any (non-floating-point) register\n-;;- 'q' regs that allow byte operations (A, B, C and D)\n-;;- 'A' A and D registers\n+;; Macro REG_CLASS_FROM_LETTER in file i386.h defines the register\n+;; constraint letters.\n \n ;; the special asm out single letter directives following a '%' are:\n-;; 'z' mov%z1 would be movl, movw, or movb depending on the mode of operands[1]\n-;; 's' output a '*'\n-;; 'w' If the operand is a REG, it uses the mode size to determine the\n-;;      printing of the reg\n+;; 'z' mov%z1 would be movl, movw, or movb depending on the mode of\n+;;     operands[1].\n+;; 'L' Print the opcode suffix for a 32-bit integer opcode.\n+;; 'W' Print the opcode suffix for a 16-bit integer opcode.\n+;; 'B' Print the opcode suffix for an 8-bit integer opcode.\n+;; 'S' Print the opcode suffix for a 32-bit float opcode.\n+;; 'Q' Print the opcode suffix for a 64-bit float opcode.\n+\n+;; 'b' Print the QImode name of the register for the indicated operand.\n+;;     %b0 would print %al if operands[0] is reg 0.\n+;; 'w' Likewise, print the HImode name of the register.\n+;; 'k' Likewise, print the SImode name of the register.\n+;; 'h' Print the QImode name for a \"high\" register, either ah, bh, ch or dh.\n+;; 'y' Print \"st(0)\" instead of \"st\" as a register.\n+\n+;; UNSPEC usage:\n+;; 0  This is a `scas' operation.  The mode of the UNSPEC is always SImode.\n+;;    operand 0 is the memory address to scan.\n+;;    operand 1 is a register containing the value to scan for.  The mode\n+;;       of the scas opcode will be the same as the mode of this operand.\n+;;    operand 2 is the known alignment of operand 0.\n \n \f\n-\n ;; \"movl MEM,REG / testl REG,REG\" is faster on a 486 than \"cmpl $0,MEM\".\n ;; But restricting MEM here would mean that gcc could not remove a redundant\n ;; test in cases like \"incl MEM / je TARGET\".\n@@ -2573,9 +2577,9 @@\n (define_insn \"\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"general_operand\" \"+rm\")\n \t\t\t (const_int 1)\n-\t\t\t (match_operand:SI 2 \"nonimmediate_operand\" \"r\"))\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"r\"))\n \t(match_operand:SI 3 \"immediate_operand\" \"i\"))]\n-  \"! TARGET_486\"\n+  \"! TARGET_486 && GET_CODE (operands[2]) != CONST_INT\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -2593,7 +2597,7 @@\n \t(xor:SI (ashift:SI (const_int 1)\n \t\t\t   (match_operand:SI 1 \"general_operand\" \"r\"))\n \t\t(match_dup 0)))]\n-  \"! TARGET_486\"\n+  \"! TARGET_486 && GET_CODE (operands[1]) != CONST_INT\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -2628,118 +2632,15 @@\n ;; don't allow a MEM in the operand predicate without allowing it in the\n ;; constraint.\n \n-(define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:QI 0 \"register_operand\" \"q\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (match_operand:SI 1 \"general_operand\" \"ri\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    {\n-      operands[1] = gen_rtx (CONST_INT, VOIDmode, 1 << INTVAL (operands[1]));\n-      output_asm_insn (AS2 (test%B0,%1,%0), operands);\n-    }\n-  else\n-    {\n-      operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]));\n-      cc_status.flags |= CC_Z_IN_NOT_C;\n-      output_asm_insn (AS2 (bt%L0,%1,%0), operands);\n-    }\n-  RET;\n-}\")\n-\n-;; ??? The first argument of a zero_extract must not be reloaded, so\n-;; don't allow a MEM in the operand predicate without allowing it in the\n-;; constraint.\n-\n-(define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:HI 0 \"register_operand\" \"r\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (match_operand:SI 1 \"general_operand\" \"ri\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    {\n-      if (QI_REG_P (operands[0]) && INTVAL (operands[1]) < 8)\n-\t{\n-\t  cc_status.flags |= CC_NOT_NEGATIVE;\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t 1 << INTVAL (operands[1]));\n-\n-\t  output_asm_insn (AS2 (test%B0,%1,%b0), operands);\n-\t}\n-      else if (QI_REG_P (operands[0]))\n-        {\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t 1 << (INTVAL (operands[1]) - 8));\n-\n-\t  output_asm_insn (AS2 (test%B0,%1,%h0), operands);\n-\t}\n-      else\n-        {\n-\t  /* ??? This will never set CC to negative, even if we test\n-\t     the sign bit of the HImode reg.  But CC0 is only tested\n-\t     for EQ and NE after this insn.  */\n-\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t 1 << INTVAL (operands[1]));\n-\n-\t  output_asm_insn (AS2 (test%L0,%1,%k0), operands);\n-\t}\n-    }\n-  else\n-    {\n-      cc_status.flags |= CC_Z_IN_NOT_C;\n-      output_asm_insn (AS2 (bt%W0,%1,%0), operands);\n-    }\n-  RET;\n-}\")\n-\n-;; ??? The first argument of a zero_extract must not be reloaded, so\n-;; don't allow a MEM in the operand predicate without allowing it in the\n-;; constraint.\n-\n (define_insn \"\"\n   [(set (cc0) (zero_extract (match_operand:SI 0 \"register_operand\" \"r\")\n \t\t\t    (const_int 1)\n-\t\t\t    (match_operand:SI 1 \"general_operand\" \"ri\")))]\n-  \"\"\n+\t\t\t    (match_operand:SI 1 \"general_operand\" \"r\")))]\n+  \"GET_CODE (operands[1]) != CONST_INT\"\n   \"*\n {\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    {\n-      if (QI_REG_P (operands[0]) && INTVAL (operands[1]) < 8)\n-        {\n-\t  cc_status.flags |= CC_NOT_NEGATIVE;\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t 1 << INTVAL (operands[1]));\n-\n-\t  output_asm_insn (AS2 (test%B0,%1,%b0), operands);\n-        }\n-      else if (QI_REG_P (operands[0]) && INTVAL (operands[1]) < 16)\n-        {\n-\t  cc_status.flags |= CC_NOT_NEGATIVE;\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t 1 << (INTVAL (operands[1]) - 8));\n-\n-\t  output_asm_insn (AS2 (test%B0,%1,%h0), operands);\n-        }\n-      else\n-        {\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t 1 << INTVAL (operands[1]));\n-\n-\t  output_asm_insn (AS2 (test%L0,%1,%0), operands);\n-        }\n-    }\n-  else\n-    {\n-      cc_status.flags |= CC_Z_IN_NOT_C;\n-      output_asm_insn (AS2 (bt%L0,%1,%0), operands);\n-    }\n-  RET;\n+  cc_status.flags |= CC_Z_IN_NOT_C;\n+  return AS2 (bt%L0,%1,%0);\n }\")\n \f\n ;; Store-flag instructions."}, {"sha": "8d2a42439a2931588eda393d172f9e1304e85114", "filename": "gcc/expr.c", "status": "modified", "additions": 83, "deletions": 29, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af3895e739fefe2d158ab1c632d7d860abd4705/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af3895e739fefe2d158ab1c632d7d860abd4705/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4af3895e739fefe2d158ab1c632d7d860abd4705", "patch": "@@ -2204,6 +2204,8 @@ store_constructor (exp, target)\n      tree exp;\n      rtx target;\n {\n+  tree type = TREE_TYPE (exp);\n+\n   /* We know our target cannot conflict, since safe_from_p has been called.  */\n #if 0\n   /* Don't try copying piece by piece into a hard register\n@@ -2218,19 +2220,25 @@ store_constructor (exp, target)\n     }\n #endif\n \n-  if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE\n-      || TREE_CODE (TREE_TYPE (exp)) == UNION_TYPE)\n+  if (TREE_CODE (type) == RECORD_TYPE || TREE_CODE (type) == UNION_TYPE)\n     {\n       register tree elt;\n \n-      if (TREE_CODE (TREE_TYPE (exp)) == UNION_TYPE)\n-\t/* Inform later passes that the whole union value is dead.  */\n+      /* Inform later passes that the whole union value is dead.  */\n+      if (TREE_CODE (type) == UNION_TYPE)\n \temit_insn (gen_rtx (CLOBBER, VOIDmode, target));\n+\n+      /* If we are building a static constructor into a register,\n+\t set the initial value as zero so we can fold the value into\n+\t a constant.  */\n+      else if (GET_CODE (target) == REG && TREE_STATIC (exp))\n+\temit_move_insn (target, const0_rtx);\n+\n       /* If the constructor has fewer fields than the structure,\n \t clear the whole structure first.  */\n       else if (list_length (CONSTRUCTOR_ELTS (exp))\n-\t       != list_length (TYPE_FIELDS (TREE_TYPE (exp))))\n-\tclear_storage (target, int_size_in_bytes (TREE_TYPE (exp)));\n+\t       != list_length (TYPE_FIELDS (type)))\n+\tclear_storage (target, int_size_in_bytes (type));\n       else\n \t/* Inform later passes that the old value is dead.  */\n \temit_insn (gen_rtx (CLOBBER, VOIDmode, target));\n@@ -2262,23 +2270,25 @@ store_constructor (exp, target)\n \t\t       /* The alignment of TARGET is\n \t\t\t  at least what its type requires.  */\n \t\t       VOIDmode, 0,\n-\t\t       TYPE_ALIGN (TREE_TYPE (exp)) / BITS_PER_UNIT,\n-\t\t       int_size_in_bytes (TREE_TYPE (exp)));\n+\t\t       TYPE_ALIGN (type) / BITS_PER_UNIT,\n+\t\t       int_size_in_bytes (type));\n \t}\n     }\n-  else if (TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE)\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       register tree elt;\n       register int i;\n-      tree domain = TYPE_DOMAIN (TREE_TYPE (exp));\n+      tree domain = TYPE_DOMAIN (type);\n       int minelt = TREE_INT_CST_LOW (TYPE_MIN_VALUE (domain));\n       int maxelt = TREE_INT_CST_LOW (TYPE_MAX_VALUE (domain));\n-      tree elttype = TREE_TYPE (TREE_TYPE (exp));\n+      tree elttype = TREE_TYPE (type);\n \n       /* If the constructor has fewer fields than the structure,\n-\t clear the whole structure first.  */\n+\t clear the whole structure first.  Similarly if this this is\n+\t static constructor of a non-BLKmode object.  */\n \n-      if (list_length (CONSTRUCTOR_ELTS (exp)) < maxelt - minelt + 1)\n+      if (list_length (CONSTRUCTOR_ELTS (exp)) < maxelt - minelt + 1\n+\t  || (GET_CODE (target) == REG && TREE_STATIC (exp)))\n \tclear_storage (target, maxelt - minelt + 1);\n       else\n \t/* Inform later passes that the old value is dead.  */\n@@ -2306,8 +2316,8 @@ store_constructor (exp, target)\n \t\t       /* The alignment of TARGET is\n \t\t\t  at least what its type requires.  */\n \t\t       VOIDmode, 0,\n-\t\t       TYPE_ALIGN (TREE_TYPE (exp)) / BITS_PER_UNIT,\n-\t\t       int_size_in_bytes (TREE_TYPE (exp)));\n+\t\t       TYPE_ALIGN (type) / BITS_PER_UNIT,\n+\t\t       int_size_in_bytes (type));\n \t}\n     }\n \n@@ -2930,7 +2940,7 @@ expand_expr (exp, target, tmode, modifier)\n       if (DECL_RTL (exp) == 0)\n \t{\n \t  error_with_decl (exp, \"prior parameter's size depends on `%s'\");\n-\t  return const0_rtx;\n+\t  return CONST0_RTX (mode);\n \t}\n \n     case FUNCTION_DECL:\n@@ -2968,6 +2978,7 @@ expand_expr (exp, target, tmode, modifier)\n \t    addr = fix_lexical_addr (addr, exp);\n \t  return change_address (DECL_RTL (exp), mode, addr);\n \t}\n+\n       /* This is the case of an array whose size is to be determined\n \t from its initializer, while the initializer is still being parsed.\n \t See expand_decl.  */\n@@ -3125,10 +3136,11 @@ expand_expr (exp, target, tmode, modifier)\n       return RTL_EXPR_RTL (exp);\n \n     case CONSTRUCTOR:\n-      /* All elts simple constants => refer to a constant in memory.  */\n-      if (TREE_STATIC (exp))\n-\t/* For aggregate types with non-BLKmode modes,\n-\t   this should ideally construct a CONST_INT.  */\n+      /* All elts simple constants => refer to a constant in memory.  But\n+\t if this is a non-BLKmode mode, let it store a field at a time\n+\t since that should make a CONST_INT or CONST_DOUBLE when we\n+\t fold.  */\n+      if (TREE_STATIC (exp) && (mode == BLKmode || TREE_ADDRESSABLE (exp)))\n \t{\n \t  rtx constructor = output_constant_def (exp);\n \t  if (! memory_address_p (GET_MODE (constructor),\n@@ -3290,13 +3302,36 @@ expand_expr (exp, target, tmode, modifier)\n       }\n \n       /* If this is a constant index into a constant array,\n-\t just get the value from the array.  */\n-      if (TREE_READONLY (TREE_OPERAND (exp, 0))\n-\t  && ! TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 0))\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == ARRAY_TYPE\n-\t  && TREE_CODE (TREE_OPERAND (exp, 0)) == VAR_DECL\n-\t  && DECL_INITIAL (TREE_OPERAND (exp, 0))\n-\t  && TREE_CODE (DECL_INITIAL (TREE_OPERAND (exp, 0))) != ERROR_MARK)\n+\t just get the value from the array.  Handle both the cases when\n+\t we have an explicit constructor and when our operand is a variable\n+\t that was declared const.  */\n+\n+      if (TREE_CODE (TREE_OPERAND (exp, 0)) == CONSTRUCTOR\n+\t  && ! TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 0)))\n+\t{\n+\t  tree index = fold (TREE_OPERAND (exp, 1));\n+\t  if (TREE_CODE (index) == INTEGER_CST\n+\t      && TREE_INT_CST_HIGH (index) == 0)\n+\t    {\n+\t      int i = TREE_INT_CST_LOW (index);\n+\t      tree elem = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0));\n+\n+\t      while (elem && i--)\n+\t\telem = TREE_CHAIN (elem);\n+\t      if (elem)\n+\t\treturn expand_expr (fold (TREE_VALUE (elem)), target,\n+\t\t\t\t    tmode, modifier);\n+\t    }\n+\t}\n+\t  \n+      else if (TREE_READONLY (TREE_OPERAND (exp, 0))\n+\t       && ! TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 0))\n+\t       && TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == ARRAY_TYPE\n+\t       && TREE_CODE (TREE_OPERAND (exp, 0)) == VAR_DECL\n+\t       && DECL_INITIAL (TREE_OPERAND (exp, 0))\n+\t       && optimize >= 1\n+\t       && (TREE_CODE (DECL_INITIAL (TREE_OPERAND (exp, 0)))\n+\t\t   != ERROR_MARK))\n \t{\n \t  tree index = fold (TREE_OPERAND (exp, 1));\n \t  if (TREE_CODE (index) == INTEGER_CST\n@@ -3328,6 +3363,19 @@ expand_expr (exp, target, tmode, modifier)\n \n     case COMPONENT_REF:\n     case BIT_FIELD_REF:\n+      /* If the operand is a CONSTRUCTOR, we can just extract the\n+\t appropriate field if it is present.  */\n+      if (code != ARRAY_REF\n+\t  && TREE_CODE (TREE_OPERAND (exp, 0)) == CONSTRUCTOR)\n+\t{\n+\t  tree elt;\n+\n+\t  for (elt = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0)); elt;\n+\t       elt = TREE_CHAIN (elt))\n+\t    if (TREE_PURPOSE (elt) == TREE_OPERAND (exp, 1))\n+\t      return expand_expr (TREE_VALUE (elt), target, tmode, modifier);\n+\t}\n+\n       {\n \tenum machine_mode mode1;\n \tint bitsize;\n@@ -4736,7 +4784,10 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       lab2 = gen_label_rtx ();\n \n       /* By default check the arguments.  If flag_fast_math is turned on,\n-\t then assume sqrt will always be called with valid arguments.  */\n+\t then assume sqrt will always be called with valid arguments. \n+\t Note changing the test below from \"> 0\" to \">= 0\" would cause\n+\t incorrect results when computing sqrt(-0.0).  */\n+\n       if (! flag_fast_math) \n \t{\n \t  /* By checking op > 0 we are able to catch all of the\n@@ -4745,8 +4796,11 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t\t\t GET_MODE (op0), 0, 0);\n           emit_jump_insn (gen_bgt (lab1));\n \n-          /* The argument was not in the domain; do this via library call.  */\n+          /* The argument was not in the domain; do this via library call.\n+\t     Pop the arguments right away in case the call gets deleted. */\n+\t  NO_DEFER_POP;\n           expand_call (exp, target, 0, 0);\n+\t  OK_DEFER_POP;\n \n           /* Branch around open coded version */\n           emit_jump_insn (gen_jump (lab2));"}]}