{"sha": "a01e93f11b7ce050679951dedae66e40bca6be4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAxZTkzZjExYjdjZTA1MDY3OTk1MWRlZGFlNjZlNDBiY2E2YmU0ZA==", "commit": {"author": {"name": "Yuri Rumyantsev", "email": "ysrumyan@gmail.com", "date": "2015-10-08T13:14:09Z"}, "committer": {"name": "Ilya Enkovich", "email": "ienkovich@gcc.gnu.org", "date": "2015-10-08T13:14:09Z"}, "message": "tree-ssa-loop-unswitch.c: Include \"gimple-iterator.h\" and \"cfghooks.h\"...\n\ngcc/\n\n\t* tree-ssa-loop-unswitch.c: Include \"gimple-iterator.h\" and\n\t\"cfghooks.h\", add prototypes for introduced new functions.\n\t(tree_ssa_unswitch_loops): Use from innermost loop iterator, move all\n\tchecks on ability of loop unswitching to tree_unswitch_single_loop;\n\tinvoke tree_unswitch_single_loop or tree_unswitch_outer_loop depending\n\ton innermost loop check.\n\t(tree_unswitch_single_loop): Add all required checks on ability of\n\tloop unswitching under zero recursive level guard.\n\t(tree_unswitch_outer_loop): New function.\n\t(find_loop_guard): Likewise.\n\t(empty_bb_without_guard_p): Likewise.\n\t(used_outside_loop_p): Likewise.\n\t(get_vop_from_header): Likewise.\n\t(hoist_guard): Likewise.\n\t(check_exit_phi): Likewise.\n\ngcc/testsuite/\n\n\t* gcc.dg/loop-unswitch-2.c: New test.\n\t* gcc.dg/loop-unswitch-3.c: Likewise.\n\t* gcc.dg/loop-unswitch-4.c: Likewise.\n\nFrom-SVN: r228599", "tree": {"sha": "5f7294b8f0b81c4c83835b68641e48339dc64aa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f7294b8f0b81c4c83835b68641e48339dc64aa4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a01e93f11b7ce050679951dedae66e40bca6be4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a01e93f11b7ce050679951dedae66e40bca6be4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a01e93f11b7ce050679951dedae66e40bca6be4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a01e93f11b7ce050679951dedae66e40bca6be4d/comments", "author": {"login": "ysrumyan", "id": 44425612, "node_id": "MDQ6VXNlcjQ0NDI1NjEy", "avatar_url": "https://avatars.githubusercontent.com/u/44425612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ysrumyan", "html_url": "https://github.com/ysrumyan", "followers_url": "https://api.github.com/users/ysrumyan/followers", "following_url": "https://api.github.com/users/ysrumyan/following{/other_user}", "gists_url": "https://api.github.com/users/ysrumyan/gists{/gist_id}", "starred_url": "https://api.github.com/users/ysrumyan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ysrumyan/subscriptions", "organizations_url": "https://api.github.com/users/ysrumyan/orgs", "repos_url": "https://api.github.com/users/ysrumyan/repos", "events_url": "https://api.github.com/users/ysrumyan/events{/privacy}", "received_events_url": "https://api.github.com/users/ysrumyan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f28ff5b5c504d19083ca474821475a04d0f46111", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f28ff5b5c504d19083ca474821475a04d0f46111", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f28ff5b5c504d19083ca474821475a04d0f46111"}], "stats": {"total": 568, "additions": 534, "deletions": 34}, "files": [{"sha": "76829e1b14525e06b6f78e68567e220e8db889ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01e93f11b7ce050679951dedae66e40bca6be4d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01e93f11b7ce050679951dedae66e40bca6be4d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a01e93f11b7ce050679951dedae66e40bca6be4d", "patch": "@@ -1,3 +1,21 @@\n+2015-10-08  Yuri Rumyantsev  <ysrumyan@gmail.com>\n+\n+\t* tree-ssa-loop-unswitch.c: Include \"gimple-iterator.h\" and\n+\t\"cfghooks.h\", add prototypes for introduced new functions.\n+\t(tree_ssa_unswitch_loops): Use from innermost loop iterator, move all\n+\tchecks on ability of loop unswitching to tree_unswitch_single_loop;\n+\tinvoke tree_unswitch_single_loop or tree_unswitch_outer_loop depending\n+\ton innermost loop check.\n+\t(tree_unswitch_single_loop): Add all required checks on ability of\n+\tloop unswitching under zero recursive level guard.\n+\t(tree_unswitch_outer_loop): New function.\n+\t(find_loop_guard): Likewise.\n+\t(empty_bb_without_guard_p): Likewise.\n+\t(used_outside_loop_p): Likewise.\n+\t(get_vop_from_header): Likewise.\n+\t(hoist_guard): Likewise.\n+\t(check_exit_phi): Likewise.\n+\n 2015-10-08  Marek Polacek  <polacek@redhat.com>\n \n \t* tree-ssa-reassoc.c (dump_ops_vector): Print newline after each"}, {"sha": "ef2faab16a1041a59e25bedf7b205349899bb7f4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01e93f11b7ce050679951dedae66e40bca6be4d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01e93f11b7ce050679951dedae66e40bca6be4d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a01e93f11b7ce050679951dedae66e40bca6be4d", "patch": "@@ -1,3 +1,9 @@\n+2015-10-08  Yuri Rumyantsev  <ysrumyan@gmail.com>\n+\n+\t* gcc.dg/loop-unswitch-2.c: New test.\n+\t* gcc.dg/loop-unswitch-3.c: Likewise.\n+\t* gcc.dg/loop-unswitch-4.c: Likewise.\n+\n 2015-10-08  Tom de Vries  <tom@codesourcery.com>\n \n \t* gcc.dg/dse.c: Only dump in dse1 pass."}, {"sha": "5ebf6087fcde9c8fff252a37f2a26aa1c2bd7c90", "filename": "gcc/testsuite/gcc.dg/loop-unswitch-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01e93f11b7ce050679951dedae66e40bca6be4d/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01e93f11b7ce050679951dedae66e40bca6be4d/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-2.c?ref=a01e93f11b7ce050679951dedae66e40bca6be4d", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -funswitch-loops -fdump-tree-unswitch-details\" } */\n+\n+void foo (float **a, float **b, float *c, int n, int m, int l)\n+{\n+  int i,j,k;\n+  float s;\n+  for (i=0; i<l; i++)\n+    for (j=0; j<n; j++)\n+      for (k=0; k<m; k++)\n+\tc[i] += a[i][k] * b[k][j];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"guard hoisted\" 2 \"unswitch\" } } */\n+"}, {"sha": "e3552866dfe3f7cee3981f0918609421068ac187", "filename": "gcc/testsuite/gcc.dg/loop-unswitch-3.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01e93f11b7ce050679951dedae66e40bca6be4d/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01e93f11b7ce050679951dedae66e40bca6be4d/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-3.c?ref=a01e93f11b7ce050679951dedae66e40bca6be4d", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -funswitch-loops -fdump-tree-unswitch-details\" } */\n+\n+#include <stdlib.h>\n+#define N 32\n+float *foo(int ustride, int size, float *src)\n+{\n+   float *buffer, *p;\n+   int i, k;\n+\n+   if (!src)\n+    return NULL;\n+\n+   buffer = (float *) malloc(N * size * sizeof(float));\n+\n+   if(buffer)\n+      for(i=0, p=buffer; i<N; i++, src+=ustride)\n+\tfor(k=0; k<size; k++)\n+\t  *p++ = src[k];\n+\n+   return buffer;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"guard hoisted\" 1 \"unswitch\" } } */\n+\n+"}, {"sha": "320a1cdb50758842623df90d5d1ca27d37697d46", "filename": "gcc/testsuite/gcc.dg/loop-unswitch-4.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01e93f11b7ce050679951dedae66e40bca6be4d/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01e93f11b7ce050679951dedae66e40bca6be4d/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-4.c?ref=a01e93f11b7ce050679951dedae66e40bca6be4d", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -funswitch-loops\" } */\n+\n+#include <stdlib.h>\n+__attribute__ ((noinline))\n+void foo (float **a, float **b, float *c, int n, int m, int l)\n+{\n+  int i,j,k;\n+  float s;\n+  for (i=0; i<l; i++)\n+    for (j=0; j<n; j++)\n+      for (k=0; k<m; k++)\n+\tc[i] += a[i][k] * b[k][j];\n+}\n+\n+int main()\n+{\n+  const int N = 32;\n+  float **ar1, **ar2;\n+  float *res;\n+  int i, j;\n+  ar1 = (float **)malloc (N * sizeof (float*));\n+  ar2 = (float **)malloc (N * sizeof (float*));\n+  res = (float *)malloc( N * sizeof (float));\n+  for (i=0; i<N; i++)\n+    {\n+      ar1[i] = (float*)malloc (N * sizeof (float));\n+      ar2[i] = (float*)malloc (N * sizeof (float));\n+    }\n+  for (i=0; i<N; i++)\n+    {\n+      for (j=0; j<N; j++)\n+\t{\n+\t  ar1[i][j] = 2.0f;\n+\t  ar2[i][j] = 1.5f;\n+\t}\n+      res[i] = 0.0f;\n+    }\n+  foo (ar1, ar2, res, N, N, N);\n+  for (i=0; i<N; i++)\n+    if (res[i] != 3072.0f)\n+      abort();\n+  for (i=0; i<N; i++)\n+    res[i] = 0.0f;\n+  foo (ar1, ar2, res, N, 0, N);\n+  for (i=0; i<N; i++)\n+    if (res[i] != 0.0f)\n+      abort();\n+ \n+  return 0;\n+}\n+"}, {"sha": "4328d6ae6de2393acbae223ebf70769dae64f47e", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 417, "deletions": 34, "changes": 451, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01e93f11b7ce050679951dedae66e40bca6be4d/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01e93f11b7ce050679951dedae66e40bca6be4d/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=a01e93f11b7ce050679951dedae66e40bca6be4d", "patch": "@@ -39,6 +39,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"tree-pass.h\"\n #include \"tree-inline.h\"\n+#include \"gimple-iterator.h\"\n+#include \"cfghooks.h\"\n \n /* This file implements the loop unswitching, i.e. transformation of loops like\n \n@@ -79,6 +81,13 @@ along with GCC; see the file COPYING3.  If not see\n static struct loop *tree_unswitch_loop (struct loop *, basic_block, tree);\n static bool tree_unswitch_single_loop (struct loop *, int);\n static tree tree_may_unswitch_on (basic_block, struct loop *);\n+static bool tree_unswitch_outer_loop (struct loop *);\n+static edge find_loop_guard (struct loop *);\n+static bool empty_bb_without_guard_p (struct loop *, basic_block);\n+static bool used_outside_loop_p (struct loop *, tree);\n+static void hoist_guard (struct loop *, edge);\n+static bool check_exit_phi (struct loop *);\n+static tree get_vop_from_header (struct loop *);\n \n /* Main entry point.  Perform loop unswitching on all suitable loops.  */\n \n@@ -87,42 +96,15 @@ tree_ssa_unswitch_loops (void)\n {\n   struct loop *loop;\n   bool changed = false;\n-  HOST_WIDE_INT iterations;\n \n-  /* Go through inner loops (only original ones).  */\n-  FOR_EACH_LOOP (loop, LI_ONLY_INNERMOST)\n+  /* Go through all loops starting from innermost.  */\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-        fprintf (dump_file, \";; Considering loop %d\\n\", loop->num);\n-\n-      /* Do not unswitch in cold regions. */\n-      if (optimize_loop_for_size_p (loop))\n-        {\n-          if (dump_file && (dump_flags & TDF_DETAILS))\n-            fprintf (dump_file, \";; Not unswitching cold loops\\n\");\n-          continue;\n-        }\n-\n-      /* The loop should not be too large, to limit code growth. */\n-      if (tree_num_loop_insns (loop, &eni_size_weights)\n-          > (unsigned) PARAM_VALUE (PARAM_MAX_UNSWITCH_INSNS))\n-        {\n-          if (dump_file && (dump_flags & TDF_DETAILS))\n-            fprintf (dump_file, \";; Not unswitching, loop too big\\n\");\n-          continue;\n-        }\n-\n-      /* If the loop is not expected to iterate, there is no need\n-\t for unswitching.  */\n-      iterations = estimated_loop_iterations_int (loop);\n-      if (iterations >= 0 && iterations <= 1)\n-\t{\n-          if (dump_file && (dump_flags & TDF_DETAILS))\n-            fprintf (dump_file, \";; Not unswitching, loop is not expected to iterate\\n\");\n-          continue;\n-\t}\n-\n-      changed |= tree_unswitch_single_loop (loop, 0);\n+      if (!loop->inner)\n+\t/* Unswitch innermost loop.  */\n+\tchanged |= tree_unswitch_single_loop (loop, 0);\n+      else\n+\tchanged |= tree_unswitch_outer_loop (loop);\n     }\n \n   if (changed)\n@@ -216,6 +198,39 @@ tree_unswitch_single_loop (struct loop *loop, int num)\n   tree cond = NULL_TREE;\n   gimple *stmt;\n   bool changed = false;\n+  HOST_WIDE_INT iterations;\n+\n+  /* Perform initial tests if unswitch is eligible.  */\n+  if (num == 0)\n+    {\n+      /* Do not unswitch in cold regions. */\n+      if (optimize_loop_for_size_p (loop))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \";; Not unswitching cold loops\\n\");\n+\t  return false;\n+\t}\n+\n+      /* The loop should not be too large, to limit code growth. */\n+      if (tree_num_loop_insns (loop, &eni_size_weights)\n+\t  > (unsigned) PARAM_VALUE (PARAM_MAX_UNSWITCH_INSNS))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \";; Not unswitching, loop too big\\n\");\n+\t  return false;\n+\t}\n+\n+      /* If the loop is not expected to iterate, there is no need\n+\t for unswitching.  */\n+      iterations = estimated_loop_iterations_int (loop);\n+      if (iterations >= 0 && iterations <= 1)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \";; Not unswitching, loop is not expected\"\n+\t\t     \" to iterate\\n\");\n+\t  return false;\n+\t}\n+    }\n \n   i = 0;\n   bbs = get_loop_body (loop);\n@@ -403,6 +418,374 @@ tree_unswitch_loop (struct loop *loop,\n \t\t       REG_BR_PROB_BASE - prob_true, false);\n }\n \n+/* Unswitch outer loops by hoisting invariant guard on\n+   inner loop without code duplication.  */\n+static bool\n+tree_unswitch_outer_loop (struct loop *loop)\n+{\n+  edge exit, guard;\n+  HOST_WIDE_INT iterations;\n+\n+  gcc_assert (loop->inner);\n+  if (loop->inner->next)\n+    return false;\n+  /* Accept loops with single exit only.  */\n+  exit = single_exit (loop);\n+  if (!exit)\n+    return false;\n+  /* Check that phi argument of exit edge is not defined inside loop.  */\n+  if (!check_exit_phi (loop))\n+    return false;\n+  /* If the loop is not expected to iterate, there is no need\n+      for unswitching.  */\n+  iterations = estimated_loop_iterations_int (loop);\n+  if (iterations >= 0 && iterations <= 1)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \";; Not unswitching, loop is not expected\"\n+\t\t \" to iterate\\n\");\n+\treturn false;\n+    }\n+\n+  guard = find_loop_guard (loop);\n+  if (guard)\n+    {\n+      hoist_guard (loop, guard);\n+      update_ssa (TODO_update_ssa);\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Checks if the body of the LOOP is within an invariant guard.  If this\n+   is the case, returns the edge that jumps over the real body of the loop,\n+   otherwise returns NULL.  */\n+\n+static edge\n+find_loop_guard (struct loop *loop)\n+{\n+  basic_block header = loop->header;\n+  edge guard_edge, te, fe;\n+  /* bitmap processed, known_invariants;*/\n+  basic_block *body = NULL;\n+  unsigned i;\n+  tree use;\n+  ssa_op_iter iter;\n+\n+  /* We check for the following situation:\n+\n+     while (1)\n+       {\n+\t [header]]\n+         loop_phi_nodes;\n+\t something1;\n+\t if (cond1)\n+\t   body;\n+\t nvar = phi(orig, bvar) ... for all variables changed in body;\n+\t [guard_end]\n+\t something2;\n+\t if (cond2)\n+\t   break;\n+\t something3;\n+       }\n+\n+     where:\n+\n+     1) cond1 is loop invariant\n+     2) If cond1 is false, then the loop is essentially empty; i.e.,\n+\ta) nothing in something1, something2 and something3 has side\n+\t   effects\n+\tb) anything defined in something1, something2 and something3\n+\t   is not used outside of the loop.  */\n+\n+  while (single_succ_p (header))\n+    header = single_succ (header);\n+  if (!last_stmt (header)\n+      || gimple_code (last_stmt (header)) != GIMPLE_COND)\n+    return NULL;\n+\n+  extract_true_false_edges_from_block (header, &te, &fe);\n+  if (!flow_bb_inside_loop_p (loop, te->dest)\n+      || !flow_bb_inside_loop_p (loop, fe->dest))\n+    return NULL;\n+\n+  if (just_once_each_iteration_p (loop, te->dest)\n+      || (single_succ_p (te->dest)\n+\t  && just_once_each_iteration_p (loop, single_succ (te->dest))))\n+    {\n+      if (just_once_each_iteration_p (loop, fe->dest))\n+\treturn NULL;\n+      guard_edge = te;\n+    }\n+  else if (just_once_each_iteration_p (loop, fe->dest)\n+\t   || (single_succ_p (fe->dest)\n+\t       && just_once_each_iteration_p (loop, single_succ (fe->dest))))\n+    guard_edge = fe;\n+  else\n+    return NULL;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file,\n+\t     \"Considering guard %d -> %d in loop %d\\n\",\n+\t     guard_edge->src->index, guard_edge->dest->index, loop->num);\n+  /* Check if condition operands do not have definitions inside loop since\n+     any bb copying is not performed.  */\n+  FOR_EACH_SSA_TREE_OPERAND (use, last_stmt (header), iter, SSA_OP_USE)\n+    {\n+      gimple *def = SSA_NAME_DEF_STMT (use);\n+      basic_block def_bb = gimple_bb (def);\n+      if (def_bb\n+          && flow_bb_inside_loop_p (loop, def_bb))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"  guard operands have definitions\"\n+\t\t\t\t\" inside loop\\n\");\n+\t  return NULL;\n+\t}\n+    }\n+\n+  body = get_loop_body (loop);\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      basic_block bb = body[i];\n+      if (bb->loop_father != loop)\n+\tcontinue;\n+      if (bb->flags & BB_IRREDUCIBLE_LOOP)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Block %d is marked as irreducible in loop\\n\",\n+\t\t      bb->index);\n+\t  guard_edge = NULL;\n+\t  goto end;\n+\t}\n+      if (!empty_bb_without_guard_p (loop, bb))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"  block %d has side effects\\n\", bb->index);\n+\t  guard_edge = NULL;\n+\t  goto end;\n+\t}\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"  suitable to hoist\\n\");\n+end:\n+  if (body)\n+    free (body);\n+  return guard_edge;\n+}\n+\n+/* Returns true if\n+   1) no statement in BB has side effects\n+   2) assuming that edge GUARD is always taken, all definitions in BB\n+      are noy used outside of the loop.\n+   KNOWN_INVARIANTS is a set of ssa names we know to be invariant, and\n+   PROCESSED is a set of ssa names for that we already tested whether they\n+   are invariant or not.  */\n+\n+static bool\n+empty_bb_without_guard_p (struct loop *loop, basic_block bb)\n+{\n+  basic_block exit_bb = single_exit (loop)->src;\n+  bool may_be_used_outside = (bb == exit_bb\n+\t\t\t      || !dominated_by_p (CDI_DOMINATORS, bb, exit_bb));\n+  tree name;\n+  ssa_op_iter op_iter;\n+\n+  /* Phi nodes do not have side effects, but their results might be used\n+     outside of the loop.  */\n+  if (may_be_used_outside)\n+    {\n+      for (gphi_iterator gsi = gsi_start_phis (bb);\n+\t   !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gphi *phi = gsi.phi ();\n+\t  name = PHI_RESULT (phi);\n+\t  if (virtual_operand_p (name))\n+\t    continue;\n+\n+\t  if (used_outside_loop_p (loop, name))\n+\t    return false;\n+\t}\n+    }\n+\n+  for (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n+       !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+      if (gimple_has_side_effects (stmt))\n+\treturn false;\n+\n+      if (gimple_vdef(stmt))\n+\treturn false;\n+\n+      FOR_EACH_SSA_TREE_OPERAND (name, stmt, op_iter, SSA_OP_DEF)\n+\t{\n+\t  if (may_be_used_outside\n+\t      && used_outside_loop_p (loop, name))\n+\t    return false;\n+\t}\n+    }\n+  return true;\n+}\n+\n+/* Return true if NAME is used outside of LOOP.  */\n+\n+static bool\n+used_outside_loop_p (struct loop *loop, tree name)\n+{\n+  imm_use_iterator it;\n+  use_operand_p use;\n+\n+  FOR_EACH_IMM_USE_FAST (use, it, name)\n+    {\n+      gimple *stmt = USE_STMT (use);\n+      if (!flow_bb_inside_loop_p (loop, gimple_bb (stmt)))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Return argument for loop preheader edge in header virtual phi if any.  */\n+\n+static tree\n+get_vop_from_header (struct loop *loop)\n+{\n+  for (gphi_iterator gsi = gsi_start_phis (loop->header);\n+       !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gphi *phi = gsi.phi ();\n+      if (!virtual_operand_p (gimple_phi_result (phi)))\n+\tcontinue;\n+      return PHI_ARG_DEF_FROM_EDGE (phi, loop_preheader_edge (loop));\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Move the check of GUARD outside of LOOP.  */\n+\n+static void\n+hoist_guard (struct loop *loop, edge guard)\n+{\n+  edge exit = single_exit (loop);\n+  edge preh = loop_preheader_edge (loop);\n+  basic_block pre_header = preh->src;\n+  basic_block bb;\n+  edge te, fe, e, new_edge;\n+  gimple *stmt;\n+  basic_block guard_bb = guard->src;\n+  gimple_stmt_iterator gsi;\n+  int flags = 0;\n+  bool fix_dom_of_exit;\n+  gcond *cond_stmt, *new_cond_stmt;\n+\n+  bb = get_immediate_dominator (CDI_DOMINATORS, exit->dest);\n+  fix_dom_of_exit = flow_bb_inside_loop_p (loop, bb);\n+  gsi = gsi_last_bb (guard_bb);\n+  stmt = gsi_stmt (gsi);\n+  gcc_assert (gimple_code (stmt) == GIMPLE_COND);\n+  cond_stmt = as_a <gcond *> (stmt);\n+  extract_true_false_edges_from_block (guard_bb, &te, &fe);\n+  /* Insert guard to PRE_HEADER.  */\n+  if (!empty_block_p (pre_header))\n+    gsi = gsi_last_bb (pre_header);\n+  else\n+    gsi = gsi_start_bb (pre_header);\n+  /* Create copy of COND_STMT.  */\n+  new_cond_stmt = gimple_build_cond (gimple_cond_code (cond_stmt),\n+\t\t\t\t     gimple_cond_lhs (cond_stmt),\n+\t\t\t\t     gimple_cond_rhs (cond_stmt),\n+\t\t\t\t     NULL_TREE, NULL_TREE);\n+  gsi_insert_after (&gsi, new_cond_stmt, GSI_NEW_STMT);\n+  /* Convert COND_STMT to true/false conditional.  */\n+  if (guard == te)\n+    gimple_cond_make_false (cond_stmt);\n+  else\n+    gimple_cond_make_true (cond_stmt);\n+  update_stmt (cond_stmt);\n+  /* Create new loop pre-header.  */\n+  e = split_block (pre_header, last_stmt (pre_header));\n+  gcc_assert (loop_preheader_edge (loop)->src == e->dest);\n+  if (guard == fe)\n+    {\n+      e->flags = EDGE_TRUE_VALUE;\n+      flags |= EDGE_FALSE_VALUE;\n+    }\n+  else\n+    {\n+      e->flags = EDGE_FALSE_VALUE;\n+      flags |= EDGE_TRUE_VALUE;\n+    }\n+  new_edge = make_edge (pre_header, exit->dest, flags);\n+  if (fix_dom_of_exit)\n+    set_immediate_dominator (CDI_DOMINATORS, exit->dest, pre_header);\n+  /* Add NEW_ADGE argument for all phi in post-header block.  */\n+  bb = exit->dest;\n+  for (gphi_iterator gsi = gsi_start_phis (bb);\n+       !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gphi *phi = gsi.phi ();\n+      tree arg;\n+      if (virtual_operand_p (gimple_phi_result (phi)))\n+\t{\n+\t  arg = get_vop_from_header (loop);\n+\t  if (arg == NULL_TREE)\n+\t    /* Use exit edge argument.  */\n+\t    arg =  PHI_ARG_DEF_FROM_EDGE (phi, exit);\n+\t  add_phi_arg (phi, arg, new_edge, UNKNOWN_LOCATION);\n+\t}\n+      else\n+\t{\n+\t  /* Use exit edge argument.  */\n+\t  arg = PHI_ARG_DEF_FROM_EDGE (phi, exit);\n+\t  add_phi_arg (phi, arg, new_edge, UNKNOWN_LOCATION);\n+\t}\n+    }\n+\n+  mark_virtual_operands_for_renaming (cfun);\n+  update_ssa (TODO_update_ssa);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"  guard hoisted.\\n\");\n+}\n+\n+/* Return true if phi argument for exit edge can be used\n+   for edge around loop.  */\n+\n+static bool\n+check_exit_phi (struct loop *loop)\n+{\n+  edge exit = single_exit (loop);\n+  basic_block pre_header = loop_preheader_edge (loop)->src;\n+\n+  for (gphi_iterator gsi = gsi_start_phis (exit->dest);\n+       !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gphi *phi = gsi.phi ();\n+      tree arg;\n+      gimple *def;\n+      basic_block def_bb;\n+      if (virtual_operand_p (gimple_phi_result (phi)))\n+\tcontinue;\n+      arg = PHI_ARG_DEF_FROM_EDGE (phi, exit);\n+      if (TREE_CODE (arg) != SSA_NAME)\n+\tcontinue;\n+      def = SSA_NAME_DEF_STMT (arg);\n+      if (!def)\n+\tcontinue;\n+      def_bb = gimple_bb (def);\n+      if (!def_bb)\n+\tcontinue;\n+      if (!dominated_by_p (CDI_DOMINATORS, pre_header, def_bb))\n+\t/* Definition inside loop!  */\n+\treturn false;\n+      /* Check loop closed phi invariant.  */\n+      if (!flow_bb_inside_loop_p (def_bb->loop_father, pre_header))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n /* Loop unswitching pass.  */\n \n namespace {"}]}