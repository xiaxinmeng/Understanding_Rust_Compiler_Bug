{"sha": "12f9df4ec55a2004a9c9201886440d9503b6a858", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJmOWRmNGVjNTVhMjAwNGE5YzkyMDE4ODY0NDBkOTUwM2I2YTg1OA==", "commit": {"author": {"name": "Per Bothner", "email": "per@bothner.com", "date": "2004-02-11T15:29:30Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2004-02-11T15:29:30Z"}, "message": "Represent column numbers using line-map's source_location.\n\n\tThe \"next available source_location\" is now managed internally by\n\tline-maps.c rather than by clients.\n\t* line-map.h (struct line_map):  New field column_bits.\n\t<from_line>:  Rename field to start_location.\n\t(struct line_maps):  New fields highest_location and max_column_hint.\n\t(linemap_check_files_exited):  New declaration.\n\t(linemap_line_start):  New declaration.\n\t(linemap_add):  Remove from_line parameter; use highest_location field.\n\t(SOURCE_LINE, LAST_SOURCE_LINE):  Modify to use column_bits.\n\t(SOURCE_COLUMN, LAST_SOURCE_LINE_LOCATION):  New macros.\n\t(CURRENT_LINE_MAP):  Remove macro.\n\t(linemap_position_for_column):  New inline function.\n\t* line-map.c (linemap_init):  Clear new fields.\n\t(linemap_check_files_exited):  New function, extracted from ...\n\t(linemap_free):  Use linemap_check_files_exited.\n\t(linemap_add):  Remove from_line parameter.  Various updates.\n\t(linemap_line_start):  New function.\n\t(linemap_lookeup):  Update for new field names.\n\t* cpphash.h (struct cpp_reader) <map>:  Field removed.  Because\n\tlinemap_position_for_column may unpredictably change the current map,\n\tit is cleaner and simpler for us to not cache it in cpp_reader.\n\t(struct cpp_buffer):  New sysp field.\n\tChanged warned_cplusplus_comments and from_stage3 to bitfields.\n\t* cppinit.c (cpp_read_min_file):  pfile->map no longer exists.\n\t* cpplib.c (do_line, do_linemarker, _cpp_do_file_change):  Get\n\tcurrent map using linemap_lookup.\n\t(do_linemarker):  Also set buffer's sysp field.\n\t(destringize_and_run):  No longer need to decrement current line.\n\t* cppfiles.c (_cpp_stack_file):  Set sysp from and in buffer.\n\t(search_path_head, open_file_failed):  Use buffer's sysp.\n\t(cpp_make_system_header):  Get current map using linemap_lookup.\n\tAlso set buffer's sysp flag.\n\t* cppmacro.c (_cpp_builtin_macro_text):  Likewise use linemap_lookup.\n\t* cpphash.h (CPP_INCREMENT_LINE):  New macro.\n\t(struct cpp_buffer):  Moved fields saved_cur, saved_rlimit to ...\n\t(struct cpp_reader):  ... and adding saved_line_base field.\n\t* cpptrad.c (_cpp_overlay_buffer, _cpp_remove_overlay):\n\tUpdate accordingly.  Don't adjust line.\n\t(_cpp_scan_out_logical_line):  Use CPP_INCREMENT_LINE.\n\t* cpphash.c (CPP_IN_SYSTEM_HEADER):  Replaced macro by ...\n\t(cpp_in_system_header):  ... new inline function, using buffer's sysp.\n\t* cpperror.c (_cpp_begin_message):  Update to use cpp_in_system_header.\n\t* cpplex.c (_cpp_lex_direct):  Likewise.\n\t* cppmacro.c (_cpp_builtin_macro_text):  Likewise.\n\t* cppmacro.c (_cpp_create_definition):  Use buffer's sysp field.\n\t* cpplib.h (struct cpp_token):  Rename line field to src_loc.\n\tRemove col field as it is now subsumed by src_loc.\n\t* cpperror.c:  Update various field, parameter, and macro names.\n\t(print_location):  If col==0, try SOURCE_COLUMN of line.\n\t(cpp_error):  Use cur_token's src_loc field, rather than line+col.\n\t* cpplib.c (do_diagnostic):  Token's src_loc fields replaces line+col.\n\t* cpplex.c (_cpp_process_line_notes, _cpp_lex_direct,\n\t_cpp_skip_block_comment):  Use CPP_INCREMENT_LINE.\n\t(_cpp_temp_token):  Replace cpp_token's line+col fields by src_loc.\n\t(_cpp_get_fresh_line):  Don't need to adjust line for missing newline.\n\t(_cpp_lex_direct):  Use linemap_position_for_column.\n\t* c-ppoutput.c (maybe_print_line, print_line):  Don't take map\n\tparameter.  Instead get it from the line_table global.  Adjust callers.\n\t(print):  Remove map field.  Replace line field to src_line.\n\t(init_pp_output, account_for_newlines, maybe_print_line):  Adjust.\n\t(cb_line_change):  Use SOURCE_COLUMN.  Minor optimizations.\n\t(pp_file_change):  Use MAIN_FILE_P since we cannot checked print.map.\n\tUse LAST_SOURCE_LINE_LOCATION to \"catch up\" after #include.\n\t* cpptrad.c (copy_comment):  Rename variable.\n\t* c-lex.c (map):  Remove static variable, for same reason we removed\n\tcpp_reader's map field.\n\t(cb_line_change, cb_def_pragma, cb_define, cb_undef):  Hence we need\n\tto call linemap_lookup.\n\t(cb_line_change):  Token's line field replaced by src_loc.\n\t(fe_file_change):  Use MAINFILE_P and LAST_SOURCE_LINE macros.\n\tDon't save new_map.\n\n\t* cpphash.h, cpperror.c, cpplib.h:  Some renames of fileline to\n\tsource_location.\n\nFrom-SVN: r77663", "tree": {"sha": "a9c4a3f1215b61026ad26cff4b8f9fc9396740cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9c4a3f1215b61026ad26cff4b8f9fc9396740cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12f9df4ec55a2004a9c9201886440d9503b6a858", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f9df4ec55a2004a9c9201886440d9503b6a858", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12f9df4ec55a2004a9c9201886440d9503b6a858", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f9df4ec55a2004a9c9201886440d9503b6a858/comments", "author": {"login": "PerBothner", "id": 10293361, "node_id": "MDQ6VXNlcjEwMjkzMzYx", "avatar_url": "https://avatars.githubusercontent.com/u/10293361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PerBothner", "html_url": "https://github.com/PerBothner", "followers_url": "https://api.github.com/users/PerBothner/followers", "following_url": "https://api.github.com/users/PerBothner/following{/other_user}", "gists_url": "https://api.github.com/users/PerBothner/gists{/gist_id}", "starred_url": "https://api.github.com/users/PerBothner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PerBothner/subscriptions", "organizations_url": "https://api.github.com/users/PerBothner/orgs", "repos_url": "https://api.github.com/users/PerBothner/repos", "events_url": "https://api.github.com/users/PerBothner/events{/privacy}", "received_events_url": "https://api.github.com/users/PerBothner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8914b65e213507d28c235ddeeff22e4867c2e2c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8914b65e213507d28c235ddeeff22e4867c2e2c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8914b65e213507d28c235ddeeff22e4867c2e2c0"}], "stats": {"total": 610, "additions": 423, "deletions": 187}, "files": [{"sha": "2921e539f730aee75835b6268aa13258f81aaeda", "filename": "gcc/ChangeLog", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=12f9df4ec55a2004a9c9201886440d9503b6a858", "patch": "@@ -1,3 +1,82 @@\n+\n+2004-02-11  Per Bothner  <per@bothner.com>\n+\n+\tRepresent column numbers using line-map's source_location.\n+\tThe \"next available source_location\" is now managed internally by\n+\tline-maps.c rather than by clients.\n+\t* line-map.h (struct line_map):  New field column_bits.\n+\t<from_line>:  Rename field to start_location.\n+\t(struct line_maps):  New fields highest_location and max_column_hint.\n+\t(linemap_check_files_exited):  New declaration.\n+\t(linemap_line_start):  New declaration.\n+\t(linemap_add):  Remove from_line parameter; use highest_location field.\n+\t(SOURCE_LINE, LAST_SOURCE_LINE):  Modify to use column_bits.\n+\t(SOURCE_COLUMN, LAST_SOURCE_LINE_LOCATION):  New macros.\n+\t(CURRENT_LINE_MAP):  Remove macro.\n+\t(linemap_position_for_column):  New inline function.\n+\t* line-map.c (linemap_init):  Clear new fields.\n+\t(linemap_check_files_exited):  New function, extracted from ...\n+\t(linemap_free):  Use linemap_check_files_exited.\n+\t(linemap_add):  Remove from_line parameter.  Various updates.\n+\t(linemap_line_start):  New function.\n+\t(linemap_lookeup):  Update for new field names.\n+\t* cpphash.h (struct cpp_reader) <map>:  Field removed.  Because\n+\tlinemap_position_for_column may unpredictably change the current map,\n+\tit is cleaner and simpler for us to not cache it in cpp_reader.\n+\t(struct cpp_buffer):  New sysp field.\n+\tChanged warned_cplusplus_comments and from_stage3 to bitfields.\n+\t* cppinit.c (cpp_read_min_file):  pfile->map no longer exists.\n+\t* cpplib.c (do_line, do_linemarker, _cpp_do_file_change):  Get\n+\tcurrent map using linemap_lookup.\n+\t(do_linemarker):  Also set buffer's sysp field.\n+\t(destringize_and_run):  No longer need to decrement current line.\n+\t* cppfiles.c (_cpp_stack_file):  Set sysp from and in buffer.\n+\t(search_path_head, open_file_failed):  Use buffer's sysp.\n+\t(cpp_make_system_header):  Get current map using linemap_lookup.\n+\tAlso set buffer's sysp flag.\n+\t* cppmacro.c (_cpp_builtin_macro_text):  Likewise use linemap_lookup.\n+\t* cpphash.h (CPP_INCREMENT_LINE):  New macro.\n+\t(struct cpp_buffer):  Moved fields saved_cur, saved_rlimit to ...\n+\t(struct cpp_reader):  ... and adding saved_line_base field.\n+\t* cpptrad.c (_cpp_overlay_buffer, _cpp_remove_overlay):\n+\tUpdate accordingly.  Don't adjust line.\n+\t(_cpp_scan_out_logical_line):  Use CPP_INCREMENT_LINE.\n+\t* cpphash.c (CPP_IN_SYSTEM_HEADER):  Replaced macro by ...\n+\t(cpp_in_system_header):  ... new inline function, using buffer's sysp.\n+\t* cpperror.c (_cpp_begin_message):  Update to use cpp_in_system_header.\n+\t* cpplex.c (_cpp_lex_direct):  Likewise.\n+\t* cppmacro.c (_cpp_builtin_macro_text):  Likewise.\n+\t* cppmacro.c (_cpp_create_definition):  Use buffer's sysp field.\n+\t* cpplib.h (struct cpp_token):  Rename line field to src_loc.\n+\tRemove col field as it is now subsumed by src_loc.\n+\t* cpperror.c:  Update various field, parameter, and macro names.\n+\t(print_location):  If col==0, try SOURCE_COLUMN of line.\n+\t(cpp_error):  Use cur_token's src_loc field, rather than line+col.\n+\t* cpplib.c (do_diagnostic):  Token's src_loc fields replaces line+col.\n+\t* cpplex.c (_cpp_process_line_notes, _cpp_lex_direct,\n+\t_cpp_skip_block_comment):  Use CPP_INCREMENT_LINE.\n+\t(_cpp_temp_token):  Replace cpp_token's line+col fields by src_loc.\n+\t(_cpp_get_fresh_line):  Don't need to adjust line for missing newline.\n+\t(_cpp_lex_direct):  Use linemap_position_for_column.\n+\t* c-ppoutput.c (maybe_print_line, print_line):  Don't take map\n+\tparameter.  Instead get it from the line_table global.  Adjust callers.\n+\t(print):  Remove map field.  Replace line field to src_line.\n+\t(init_pp_output, account_for_newlines, maybe_print_line):  Adjust.\n+\t(cb_line_change):  Use SOURCE_COLUMN.  Minor optimizations.\n+\t(pp_file_change):  Use MAIN_FILE_P since we cannot checked print.map.\n+\tUse LAST_SOURCE_LINE_LOCATION to \"catch up\" after #include.\n+\t* cpptrad.c (copy_comment):  Rename variable.\n+\t* c-lex.c (map):  Remove static variable, for same reason we removed\n+\tcpp_reader's map field.\n+\t(cb_line_change, cb_def_pragma, cb_define, cb_undef):  Hence we need\n+\tto call linemap_lookup.\n+\t(cb_line_change):  Token's line field replaced by src_loc.\n+\t(fe_file_change):  Use MAINFILE_P and LAST_SOURCE_LINE macros.\n+\tDon't save new_map.\n+\n+\t* cpphash.h, cpperror.c, cpplib.h:  Some renames of fileline to\n+\tsource_location.\n+\n 2004-02-11  Hartmut Penner  <hpenner@de.ibm.com>\n \t\n \t* config/rs6000/altivec.md (*movv4si_internal): At least one"}, {"sha": "cbd557346f959fcdbf970922d45f343a5f68681a", "filename": "gcc/c-lex.c", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=12f9df4ec55a2004a9c9201886440d9503b6a858", "patch": "@@ -42,9 +42,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"splay-tree.h\"\n #include \"debug.h\"\n \n-/* The current line map.  */\n-static const struct line_map *map;\n-\n /* We may keep statistics about how long which files took to compile.  */\n static int header_time, body_time;\n static splay_tree file_info_tree;\n@@ -194,28 +191,27 @@ static void\n cb_line_change (cpp_reader *pfile ATTRIBUTE_UNUSED, const cpp_token *token,\n \t\tint parsing_args)\n {\n-  if (token->type == CPP_EOF || parsing_args)\n-    return;\n-\n-  input_line = SOURCE_LINE (map, token->line);\n+  if (token->type != CPP_EOF && !parsing_args)\n+    {\n+      source_location loc = token->src_loc;\n+      const struct line_map *map = linemap_lookup (&line_table, loc);\n+      input_line = SOURCE_LINE (map, loc);\n+    }\n }\n \n void\n fe_file_change (const struct line_map *new_map)\n {\n   if (new_map == NULL)\n-    {\n-      map = NULL;\n-      return;\n-    }\n+    return;\n \n   if (new_map->reason == LC_ENTER)\n     {\n       /* Don't stack the main buffer on the input stack;\n \t we already did in compile_file.  */\n-      if (map != NULL)\n+      if (! MAIN_FILE_P (new_map))\n \t{\n-          int included_at = SOURCE_LINE (new_map - 1, new_map->from_line - 1);\n+          int included_at = LAST_SOURCE_LINE (new_map - 1);\n \n \t  input_line = included_at;\n \t  push_srcloc (new_map->to_file, 1);\n@@ -250,20 +246,20 @@ fe_file_change (const struct line_map *new_map)\n   in_system_header = new_map->sysp != 0;\n   input_filename = new_map->to_file;\n   input_line = new_map->to_line;\n-  map = new_map;\n \n   /* Hook for C++.  */\n   extract_interface_info ();\n }\n \n static void\n-cb_def_pragma (cpp_reader *pfile, unsigned int line)\n+cb_def_pragma (cpp_reader *pfile, source_location loc)\n {\n   /* Issue a warning message if we have been asked to do so.  Ignore\n      unknown pragmas in system headers unless an explicit\n      -Wunknown-pragmas has been given.  */\n   if (warn_unknown_pragmas > in_system_header)\n     {\n+      const struct line_map *map = linemap_lookup (&line_table, loc);\n       const unsigned char *space, *name;\n       const cpp_token *s;\n \n@@ -277,25 +273,27 @@ cb_def_pragma (cpp_reader *pfile, unsigned int line)\n \t    name = cpp_token_as_text (pfile, s);\n \t}\n \n-      input_line = SOURCE_LINE (map, line);\n+      input_line = SOURCE_LINE (map, loc);\n       warning (\"ignoring #pragma %s %s\", space, name);\n     }\n }\n \n /* #define callback for DWARF and DWARF2 debug info.  */\n static void\n-cb_define (cpp_reader *pfile, unsigned int line, cpp_hashnode *node)\n+cb_define (cpp_reader *pfile, source_location loc, cpp_hashnode *node)\n {\n-  (*debug_hooks->define) (SOURCE_LINE (map, line),\n+  const struct line_map *map = linemap_lookup (&line_table, loc);\n+  (*debug_hooks->define) (SOURCE_LINE (map, loc),\n \t\t\t  (const char *) cpp_macro_definition (pfile, node));\n }\n \n /* #undef callback for DWARF and DWARF2 debug info.  */\n static void\n-cb_undef (cpp_reader *pfile ATTRIBUTE_UNUSED, unsigned int line,\n+cb_undef (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location loc,\n \t  cpp_hashnode *node)\n {\n-  (*debug_hooks->undef) (SOURCE_LINE (map, line),\n+  const struct line_map *map = linemap_lookup (&line_table, loc);\n+  (*debug_hooks->undef) (SOURCE_LINE (map, loc),\n \t\t\t (const char *) NODE_NAME (node));\n }\n \f"}, {"sha": "2d32445d4fe6b4363e44bae3caa6920f4cb02cc4", "filename": "gcc/c-ppoutput.c", "status": "modified", "additions": 50, "deletions": 49, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fc-ppoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fc-ppoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-ppoutput.c?ref=12f9df4ec55a2004a9c9201886440d9503b6a858", "patch": "@@ -32,10 +32,9 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n static struct\n {\n   FILE *outf;\t\t\t/* Stream to write to.  */\n-  const struct line_map *map;\t/* Logical to physical line mappings.  */\n   const cpp_token *prev;\t/* Previous token.  */\n   const cpp_token *source;\t/* Source token for spacing.  */\n-  fileline line;\t\t/* Line currently being written.  */\n+  int src_line;\t\t\t/* Line number currently being written.  */\n   unsigned char printed;\t/* Nonzero if something output at line.  */\n } print;\n \n@@ -45,8 +44,8 @@ static void scan_translation_unit_trad (cpp_reader *);\n static void account_for_newlines (const unsigned char *, size_t);\n static int dump_macro (cpp_reader *, cpp_hashnode *, void *);\n \n-static void print_line (const struct line_map *, fileline, const char *);\n-static void maybe_print_line (const struct line_map *, fileline);\n+static void print_line (source_location, const char *);\n+static void maybe_print_line (source_location);\n \n /* Callback routines for the parser.   Most of these are active only\n    in specific modes.  */\n@@ -112,13 +111,12 @@ init_pp_output (FILE *out_stream)\n       cb->undef  = cb_undef;\n     }\n \n-  /* Initialize the print structure.  Setting print.line to -1 here is\n+  /* Initialize the print structure.  Setting print.src_line to -1 here is\n      a trick to guarantee that the first token of the file will cause\n      a linemarker to be output by maybe_print_line.  */\n-  print.line = (fileline) -1;\n+  print.src_line = -1;\n   print.printed = 0;\n   print.prev = 0;\n-  print.map = 0;\n   print.outf = out_stream;\n }\n \n@@ -171,13 +169,13 @@ scan_translation_unit (cpp_reader *pfile)\n     }\n }\n \n-/* Adjust print.line for newlines embedded in output.  */\n+/* Adjust print.src_line for newlines embedded in output.  */\n static void\n account_for_newlines (const unsigned char *str, size_t len)\n {\n   while (len--)\n     if (*str++ == '\\n')\n-      print.line++;\n+      print.src_line++;\n }\n \n /* Writes out a traditionally preprocessed file.  */\n@@ -187,7 +185,7 @@ scan_translation_unit_trad (cpp_reader *pfile)\n   while (_cpp_read_logical_line_trad (pfile))\n     {\n       size_t len = pfile->out.cur - pfile->out.base;\n-      maybe_print_line (print.map, pfile->out.first_line);\n+      maybe_print_line (pfile->out.first_line);\n       fwrite (pfile->out.base, 1, len, print.outf);\n       print.printed = 1;\n       if (!CPP_OPTION (pfile, discard_comments))\n@@ -199,52 +197,56 @@ scan_translation_unit_trad (cpp_reader *pfile)\n    different line to the current one, output the required newlines or\n    a line marker, and return 1.  Otherwise return 0.  */\n static void\n-maybe_print_line (const struct line_map *map, fileline line)\n+maybe_print_line (source_location src_loc)\n {\n+  const struct line_map *map = linemap_lookup (&line_table, src_loc);\n+  int src_line = SOURCE_LINE (map, src_loc);\n   /* End the previous line of text.  */\n   if (print.printed)\n     {\n       putc ('\\n', print.outf);\n-      print.line++;\n+      print.src_line++;\n       print.printed = 0;\n     }\n \n-  if (line >= print.line && line < print.line + 8)\n+  if (src_line >= print.src_line && src_line < print.src_line + 8)\n     {\n-      while (line > print.line)\n+      while (src_line > print.src_line)\n \t{\n \t  putc ('\\n', print.outf);\n-\t  print.line++;\n+\t  print.src_line++;\n \t}\n     }\n   else\n-    print_line (map, line, \"\");\n+    print_line (src_loc, \"\");\n }\n \n /* Output a line marker for logical line LINE.  Special flags are \"1\"\n    or \"2\" indicating entering or leaving a file.  */\n static void\n-print_line (const struct line_map *map, fileline line, const char *special_flags)\n+print_line (source_location src_loc, const char *special_flags)\n {\n   /* End any previous line of text.  */\n   if (print.printed)\n     putc ('\\n', print.outf);\n   print.printed = 0;\n \n-  print.line = line;\n   if (!flag_no_line_commands)\n     {\n+      const struct line_map *map = linemap_lookup (&line_table, src_loc);\n+\n       size_t to_file_len = strlen (map->to_file);\n       unsigned char *to_file_quoted = alloca (to_file_len * 4 + 1);\n       unsigned char *p;\n \n+      print.src_line = SOURCE_LINE (map, src_loc);\n+\n       /* cpp_quote_string does not nul-terminate, so we have to do it\n \t ourselves.  */\n       p = cpp_quote_string (to_file_quoted,\n \t\t\t    (unsigned char *)map->to_file, to_file_len);\n       *p = '\\0';\n-      fprintf (print.outf, \"# %u \\\"%s\\\"%s\",\n-\t       SOURCE_LINE (map, print.line),\n+      fprintf (print.outf, \"# %u \\\"%s\\\"%s\", print.src_line,\n \t       to_file_quoted, special_flags);\n \n       if (map->sysp == 2)\n@@ -262,10 +264,12 @@ static void\n cb_line_change (cpp_reader *pfile, const cpp_token *token,\n \t\tint parsing_args)\n {\n+  source_location src_loc = token->src_loc;\n+\n   if (token->type == CPP_EOF || parsing_args)\n     return;\n \n-  maybe_print_line (print.map, token->line);\n+  maybe_print_line (src_loc);\n   print.prev = 0;\n   print.source = 0;\n \n@@ -276,30 +280,28 @@ cb_line_change (cpp_reader *pfile, const cpp_token *token,\n      ought to care.  Some things do care; the fault lies with them.  */\n   if (!CPP_OPTION (pfile, traditional))\n     {\n+      const struct line_map *map = linemap_lookup (&line_table, src_loc);\n+      int spaces = SOURCE_COLUMN (map, src_loc) - 2;\n       print.printed = 1;\n-      if (token->col > 2)\n-\t{\n-\t  unsigned int spaces = token->col - 2;\n \n-\t  while (spaces--)\n-\t    putc (' ', print.outf);\n-\t}\n+      while (-- spaces >= 0)\n+\tputc (' ', print.outf);\n     }\n }\n \n static void\n cb_ident (cpp_reader *pfile ATTRIBUTE_UNUSED, fileline line,\n \t  const cpp_string *str)\n {\n-  maybe_print_line (print.map, line);\n+  maybe_print_line (line);\n   fprintf (print.outf, \"#ident \\\"%s\\\"\\n\", str->text);\n-  print.line++;\n+  print.src_line++;\n }\n \n static void\n cb_define (cpp_reader *pfile, fileline line, cpp_hashnode *node)\n {\n-  maybe_print_line (print.map, line);\n+  maybe_print_line (line);\n   fputs (\"#define \", print.outf);\n \n   /* 'D' is whole definition; 'N' is name only.  */\n@@ -310,28 +312,28 @@ cb_define (cpp_reader *pfile, fileline line, cpp_hashnode *node)\n     fputs ((const char *) NODE_NAME (node), print.outf);\n \n   putc ('\\n', print.outf);\n-  print.line++;\n+  print.src_line++;\n }\n \n static void\n-cb_undef (cpp_reader *pfile ATTRIBUTE_UNUSED, fileline line,\n+cb_undef (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,\n \t  cpp_hashnode *node)\n {\n-  maybe_print_line (print.map, line);\n+  maybe_print_line (line);\n   fprintf (print.outf, \"#undef %s\\n\", NODE_NAME (node));\n-  print.line++;\n+  print.src_line++;\n }\n \n static void\n-cb_include (cpp_reader *pfile ATTRIBUTE_UNUSED, fileline line,\n+cb_include (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,\n \t    const unsigned char *dir, const char *header, int angle_brackets)\n {\n-  maybe_print_line (print.map, line);\n+  maybe_print_line (line);\n   if (angle_brackets)\n     fprintf (print.outf, \"#%s <%s>\\n\", dir, header);\n   else\n     fprintf (print.outf, \"#%s \\\"%s\\\"\\n\", dir, header);\n-  print.line++;\n+  print.src_line++;\n }\n \n /* Callback called when -fworking-director and -E to emit working\n@@ -351,8 +353,7 @@ pp_dir_change (cpp_reader *pfile ATTRIBUTE_UNUSED, const char *dir)\n }\n \n /* The file name, line number or system header flags have changed, as\n-   described in MAP.  From this point on, the old print.map might be\n-   pointing to freed memory, and so must not be dereferenced.  */\n+   described in MAP.  */\n \n void\n pp_file_change (const struct line_map *map)\n@@ -365,37 +366,37 @@ pp_file_change (const struct line_map *map)\n   if (map != NULL)\n     {\n       /* First time?  */\n-      if (print.map == NULL)\n+      if (MAIN_FILE_P (map))\n \t{\n \t  /* Avoid printing foo.i when the main file is foo.c.  */\n \t  if (!cpp_get_options (parse_in)->preprocessed)\n-\t    print_line (map, map->from_line, flags);\n+\t    print_line (map->start_location, flags);\n \t}\n       else\n \t{\n \t  /* Bring current file to correct line when entering a new file.  */\n \t  if (map->reason == LC_ENTER)\n-\t    maybe_print_line (map - 1, map->from_line - 1);\n-\n+\t    {\n+\t      const struct line_map *from = INCLUDED_FROM (&line_table, map);\n+\t      maybe_print_line (LAST_SOURCE_LINE_LOCATION (from));\n+\t    }\n \t  if (map->reason == LC_ENTER)\n \t    flags = \" 1\";\n \t  else if (map->reason == LC_LEAVE)\n \t    flags = \" 2\";\n-\t  print_line (map, map->from_line, flags);\n+\t  print_line (map->start_location, flags);\n \t}\n     }\n-\n-  print.map = map;\n }\n \n /* Copy a #pragma directive to the preprocessed output.  */\n static void\n cb_def_pragma (cpp_reader *pfile, fileline line)\n {\n-  maybe_print_line (print.map, line);\n+  maybe_print_line (line);\n   fputs (\"#pragma \", print.outf);\n   cpp_output_line (pfile, print.outf);\n-  print.line++;\n+  print.src_line++;\n }\n \n /* Dump out the hash table.  */\n@@ -408,7 +409,7 @@ dump_macro (cpp_reader *pfile, cpp_hashnode *node, void *v ATTRIBUTE_UNUSED)\n       fputs ((const char *) cpp_macro_definition (pfile, node),\n \t     print.outf);\n       putc ('\\n', print.outf);\n-      print.line++;\n+      print.src_line++;\n     }\n \n   return 1;"}, {"sha": "d57238069d6574f9ea2dc05095e2dbd85f492d55", "filename": "gcc/cpperror.c", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=12f9df4ec55a2004a9c9201886440d9503b6a858", "patch": "@@ -29,14 +29,14 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"cpphash.h\"\n #include \"intl.h\"\n \n-static void print_location (cpp_reader *, fileline, unsigned int);\n+static void print_location (cpp_reader *, source_location, unsigned int);\n \n /* Print the logical file location (LINE, COL) in preparation for a\n    diagnostic.  Outputs the #include chain if it has changed.  A line\n    of zero suppresses the include stack, and outputs the program name\n    instead.  */\n static void\n-print_location (cpp_reader *pfile, fileline line, unsigned int col)\n+print_location (cpp_reader *pfile, source_location line, unsigned int col)\n {\n   if (line == 0)\n     fprintf (stderr, \"%s: \", progname);\n@@ -50,7 +50,11 @@ print_location (cpp_reader *pfile, fileline line, unsigned int col)\n \n       lin = SOURCE_LINE (map, line);\n       if (col == 0)\n-\tcol = 1;\n+\t{\n+\t  col = SOURCE_COLUMN (map, line);\n+\t  if (col == 0)\n+\t    col = 1;\n+\t}\n \n       if (lin == 0)\n \tfprintf (stderr, \"%s:\", map->to_file);\n@@ -64,21 +68,26 @@ print_location (cpp_reader *pfile, fileline line, unsigned int col)\n }\n \n /* Set up for a diagnostic: print the file and line, bump the error\n-   counter, etc.  LINE is the logical line number; zero means to print\n+   counter, etc.  SRC_LOC is the logical line number; zero means to print\n    at the location of the previously lexed token, which tends to be\n-   the correct place by default.  Returns 0 if the error has been\n-   suppressed.  */\n+   the correct place by default.  The column number can be specified either\n+   using COLUMN or (if COLUMN==0) extracting SOURCE_COLUMN from SRC_LOC.\n+   (This may seem redundant, but is useful when pre-scanning (cleaning) a line,\n+   when we haven't yet verified whether the current line_map has a\n+   big enough max_column_hint.)\n+\n+   Returns 0 if the error has been suppressed.  */\n int\n-_cpp_begin_message (cpp_reader *pfile, int code, fileline line,\n-\t\t    unsigned int column)\n+_cpp_begin_message (cpp_reader *pfile, int code,\n+\t\t    source_location src_loc, unsigned int column)\n {\n   int level = CPP_DL_EXTRACT (code);\n \n   switch (level)\n     {\n     case CPP_DL_WARNING:\n     case CPP_DL_PEDWARN:\n-      if (CPP_IN_SYSTEM_HEADER (pfile)\n+      if (cpp_in_system_header (pfile)\n \t  && ! CPP_OPTION (pfile, warn_system_headers))\n \treturn 0;\n       /* Fall through.  */\n@@ -105,7 +114,7 @@ _cpp_begin_message (cpp_reader *pfile, int code, fileline line,\n       break;\n     }\n \n-  print_location (pfile, line, column);\n+  print_location (pfile, src_loc, column);\n   if (CPP_DL_WARNING_P (level))\n     fputs (_(\"warning: \"), stderr);\n   else if (level == CPP_DL_ICE)\n@@ -125,27 +134,24 @@ _cpp_begin_message (cpp_reader *pfile, int code, fileline line,\n void\n cpp_error (cpp_reader * pfile, int level, const char *msgid, ...)\n {\n-  fileline line;\n-  unsigned int column;\n+  source_location src_loc;\n   va_list ap;\n   \n   va_start (ap, msgid);\n \n   if (CPP_OPTION (pfile, traditional))\n     {\n       if (pfile->state.in_directive)\n-\tline = pfile->directive_line;\n+\tsrc_loc = pfile->directive_line;\n       else\n-\tline = pfile->line;\n-      column = 0;\n+\tsrc_loc = pfile->line;\n     }\n   else\n     {\n-      line = pfile->cur_token[-1].line;\n-      column = pfile->cur_token[-1].col;\n+      src_loc = pfile->cur_token[-1].src_loc;\n     }\n \n-  if (_cpp_begin_message (pfile, level, line, column))\n+  if (_cpp_begin_message (pfile, level, src_loc, 0))\n     v_message (msgid, ap);\n \n   va_end (ap);\n@@ -154,14 +160,14 @@ cpp_error (cpp_reader * pfile, int level, const char *msgid, ...)\n /* Print an error at a specific location.  */\n void\n cpp_error_with_line (cpp_reader *pfile, int level,\n-\t\t     fileline line, unsigned int column,\n+\t\t     source_location src_loc, unsigned int column,\n \t\t     const char *msgid, ...)\n {\n   va_list ap;\n   \n   va_start (ap, msgid);\n \n-  if (_cpp_begin_message (pfile, level, line, column))\n+  if (_cpp_begin_message (pfile, level, src_loc, column))\n     v_message (msgid, ap);\n \n   va_end (ap);"}, {"sha": "862be9f61d2eb9820d4a7c566e5c80344872707e", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=12f9df4ec55a2004a9c9201886440d9503b6a858", "patch": "@@ -640,8 +640,10 @@ _cpp_stack_file (cpp_reader *pfile, _cpp_file *file, bool import)\n   if (!should_stack_file (pfile, file, import))\n       return false;\n \n-  sysp = MAX ((pfile->map ? pfile->map->sysp : 0),\n-\t      (file->dir ? file->dir->sysp : 0));\n+  if (pfile->buffer == NULL || file->dir == NULL)\n+    sysp = 0;\n+  else\n+    sysp = MAX (pfile->buffer->sysp,  file->dir->sysp);\n \n   /* Add the file to the dependencies on its first inclusion.  */\n   if (CPP_OPTION (pfile, deps.style) > !!sysp && !file->stack_count)\n@@ -658,6 +660,7 @@ _cpp_stack_file (cpp_reader *pfile, _cpp_file *file, bool import)\n   buffer = cpp_push_buffer (pfile, file->buffer, file->st.st_size,\n \t\t\t    CPP_OPTION (pfile, preprocessed));\n   buffer->file = file;\n+  buffer->sysp = sysp;\n \n   /* Initialize controlling macro state.  */\n   pfile->mi_valid = true;\n@@ -707,7 +710,8 @@ search_path_head (cpp_reader *pfile, const char *fname, int angle_brackets,\n   else if (pfile->quote_ignores_source_dir)\n     dir = pfile->quote_include;\n   else\n-    return make_cpp_dir (pfile, dir_name_of_file (file), pfile->map->sysp);\n+    return make_cpp_dir (pfile, dir_name_of_file (file),\n+\t\t\t pfile->buffer ? pfile->buffer->sysp : 0);\n \n   if (dir == NULL)\n     cpp_error (pfile, CPP_DL_ERROR,\n@@ -756,7 +760,7 @@ _cpp_stack_include (cpp_reader *pfile, const char *fname, int angle_brackets,\n static void\n open_file_failed (cpp_reader *pfile, _cpp_file *file)\n {\n-  int sysp = pfile->map ? pfile->map->sysp: 0;\n+  int sysp = pfile->line > 1 && pfile->buffer ? pfile->buffer->sysp : 0;\n   bool print_dep = CPP_OPTION (pfile, deps.style) > !!sysp;\n \n   errno = file->err_no;\n@@ -936,12 +940,14 @@ void\n cpp_make_system_header (cpp_reader *pfile, int syshdr, int externc)\n {\n   int flags = 0;\n+  const struct line_map *map = linemap_lookup (pfile->line_table, pfile->line);\n \n   /* 1 = system header, 2 = system header to be treated as C.  */\n   if (syshdr)\n     flags = 1 + (externc != 0);\n-  _cpp_do_file_change (pfile, LC_RENAME, pfile->map->to_file,\n-\t\t       SOURCE_LINE (pfile->map, pfile->line), flags);\n+  pfile->buffer->sysp = flags;\n+  _cpp_do_file_change (pfile, LC_RENAME, map->to_file,\n+\t\t       SOURCE_LINE (map, pfile->line), flags);\n }\n \n /* Allow the client to change the current file.  Used by the front end"}, {"sha": "d704c092d0f0617d09c6fd7afdfcb0c4d341a1c1", "filename": "gcc/cpphash.h", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=12f9df4ec55a2004a9c9201886440d9503b6a858", "patch": "@@ -64,6 +64,13 @@ typedef unsigned char uchar;\n #define CPP_BUF_COLUMN(BUF, CUR) ((CUR) - (BUF)->line_base)\n #define CPP_BUF_COL(BUF) CPP_BUF_COLUMN(BUF, (BUF)->cur)\n \n+#define CPP_INCREMENT_LINE(PFILE, COLS_HINT) do { \\\n+    const struct line_map *map \\\n+      = linemap_lookup (PFILE->line_table, PFILE->line); \\\n+    unsigned int line = SOURCE_LINE (map, PFILE->line) + 1; \\\n+    PFILE->line = linemap_line_start (PFILE->line_table, line, COLS_HINT); \\\n+  } while (0)\n+\n /* Maximum nesting of cpp_buffers.  We use a static limit, partly for\n    efficiency, and partly to limit runaway recursion.  */\n #define CPP_STACK_MAX 200\n@@ -296,24 +303,25 @@ struct cpp_buffer\n      The warning happens only for C89 extended mode with -pedantic on,\n      or for -Wtraditional, and only once per file (otherwise it would\n      be far too noisy).  */\n-  unsigned char warned_cplusplus_comments;\n+  unsigned int warned_cplusplus_comments : 1;\n \n   /* True if we don't process trigraphs and escaped newlines.  True\n      for preprocessed input, command line directives, and _Pragma\n      buffers.  */\n-  unsigned char from_stage3;\n+  unsigned int from_stage3 : 1;\n \n   /* Nonzero means that the directory to start searching for \"\"\n      include files has been calculated and stored in \"dir\" below.  */\n   unsigned char search_cached;\n \n+  /* One for a system header, two for a C system header file that therefore\n+     needs to be extern \"C\" protected in C++, and zero otherwise. */\n+  unsigned char sysp;\n+\n   /* The directory of the this buffer's file.  Its NAME member is not\n      allocated, so we don't need to worry about freeing it.  */\n   struct cpp_dir dir;\n \n-  /* Used for buffer overlays by cpptrad.c.  */\n-  const uchar *saved_cur, *saved_rlimit;\n-\n   /* Descriptor for converting from the input character set to the\n      source character set.  */\n   struct cset_converter input_cset_desc;\n@@ -335,7 +343,6 @@ struct cpp_reader\n \n   /* Source line tracking.  */\n   struct line_maps *line_table;\n-  const struct line_map *map;\n   fileline line;\n \n   /* The line of the '#' of the current directive.  */\n@@ -455,6 +462,9 @@ struct cpp_reader\n     fileline first_line;\n   } out;\n \n+  /* Used for buffer overlays by cpptrad.c.  */\n+  const uchar *saved_cur, *saved_rlimit, *saved_line_base;\n+\n   /* Used to save the original line number during traditional\n      preprocessing.  */\n   unsigned int saved_line;\n@@ -493,12 +503,18 @@ extern unsigned char _cpp_trigraph_map[UCHAR_MAX + 1];\n \n /* Macros.  */\n \n-#define CPP_IN_SYSTEM_HEADER(PFILE) ((PFILE)->map && (PFILE)->map->sysp)\n+static inline int cpp_in_system_header (cpp_reader *);\n+static inline int\n+cpp_in_system_header (cpp_reader *pfile)\n+{\n+  return pfile->buffer ? pfile->buffer->sysp : 0;\n+}\n #define CPP_PEDANTIC(PF) CPP_OPTION (PF, pedantic)\n #define CPP_WTRADITIONAL(PF) CPP_OPTION (PF, warn_traditional)\n \n /* In cpperror.c  */\n-extern int _cpp_begin_message (cpp_reader *, int, fileline, unsigned int);\n+extern int _cpp_begin_message (cpp_reader *, int,\n+\t\t\t       source_location, unsigned int);\n \n /* In cppmacro.c */\n extern void _cpp_free_definition (cpp_hashnode *);"}, {"sha": "ed91b0e6ea19f0311adecf02ec7050990f55ef66", "filename": "gcc/cppinit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=12f9df4ec55a2004a9c9201886440d9503b6a858", "patch": "@@ -479,7 +479,7 @@ cpp_read_main_file (cpp_reader *pfile, const char *fname)\n   if (CPP_OPTION (pfile, preprocessed))\n     {\n       read_original_filename (pfile);\n-      fname = pfile->map->to_file;\n+      fname = pfile->line_table->maps[pfile->line_table->used-1].to_file;\n     }\n   return fname;\n }"}, {"sha": "c53a9965481f3d16b6379bbcf05185cb3283c28a", "filename": "gcc/cpplex.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=12f9df4ec55a2004a9c9201886440d9503b6a858", "patch": "@@ -282,7 +282,7 @@ _cpp_process_line_notes (cpp_reader *pfile, int in_comment)\n \t    }\n \n \t  buffer->line_base = note->pos;\n-\t  pfile->line++;\n+\t  CPP_INCREMENT_LINE (pfile, 0);\n \t}\n       else if (_cpp_trigraph_map[note->type])\n \t{\n@@ -349,12 +349,16 @@ _cpp_skip_block_comment (cpp_reader *pfile)\n \t}\n       else if (c == '\\n')\n \t{\n+\t  unsigned int cols;\n \t  buffer->cur = cur - 1;\n \t  _cpp_process_line_notes (pfile, true);\n \t  if (buffer->next_line >= buffer->rlimit)\n \t    return true;\n \t  _cpp_clean_line (pfile);\n-\t  pfile->line++;\n+\n+\t  cols = buffer->next_line - buffer->line_base;\n+\t  CPP_INCREMENT_LINE (pfile, cols);\n+\n \t  cur = buffer->cur;\n \t}\n     }\n@@ -680,8 +684,7 @@ _cpp_temp_token (cpp_reader *pfile)\n     }\n \n   result = pfile->cur_token++;\n-  result->line = old->line;\n-  result->col = old->col;\n+  result->src_loc = old->src_loc;\n   return result;\n }\n \n@@ -772,7 +775,7 @@ _cpp_get_fresh_line (cpp_reader *pfile)\n \t{\n \t  /* Only warn once.  */\n \t  buffer->next_line = buffer->rlimit;\n-\t  cpp_error_with_line (pfile, CPP_DL_PEDWARN, pfile->line - 1,\n+\t  cpp_error_with_line (pfile, CPP_DL_PEDWARN, pfile->line,\n \t\t\t       CPP_BUF_COLUMN (buffer, buffer->cur),\n \t\t\t       \"no newline at end of file\");\n \t}\n@@ -822,7 +825,7 @@ _cpp_lex_direct (cpp_reader *pfile)\n \t  if (!pfile->state.in_directive)\n \t    {\n \t      /* Tell the compiler the line number of the EOF token.  */\n-\t      result->line = pfile->line;\n+\t      result->src_loc = pfile->line;\n \t      result->flags = BOL;\n \t    }\n \t  return result;\n@@ -839,17 +842,19 @@ _cpp_lex_direct (cpp_reader *pfile)\n     }\n   buffer = pfile->buffer;\n  update_tokens_line:\n-  result->line = pfile->line;\n+  result->src_loc = pfile->line;\n \n  skipped_white:\n   if (buffer->cur >= buffer->notes[buffer->cur_note].pos\n       && !pfile->overlaid_buffer)\n     {\n       _cpp_process_line_notes (pfile, false);\n-      result->line = pfile->line;\n+      result->src_loc = pfile->line;\n     }\n   c = *buffer->cur++;\n-  result->col = CPP_BUF_COLUMN (buffer, buffer->cur);\n+\n+  result->src_loc = linemap_position_for_column (pfile->line_table,\n+\t\t\t\t\t\t CPP_BUF_COLUMN (buffer, buffer->cur));\n \n   switch (c)\n     {\n@@ -859,7 +864,8 @@ _cpp_lex_direct (cpp_reader *pfile)\n       goto skipped_white;\n \n     case '\\n':\n-      pfile->line++;\n+      if (buffer->cur < buffer->rlimit)\n+\tCPP_INCREMENT_LINE (pfile, 0);\n       buffer->need_line = true;\n       goto fresh_line;\n \n@@ -916,7 +922,7 @@ _cpp_lex_direct (cpp_reader *pfile)\n \t    cpp_error (pfile, CPP_DL_ERROR, \"unterminated comment\");\n \t}\n       else if (c == '/' && (CPP_OPTION (pfile, cplusplus_comments)\n-\t\t\t    || CPP_IN_SYSTEM_HEADER (pfile)))\n+\t\t\t    || cpp_in_system_header (pfile)))\n \t{\n \t  /* Warn about comments only if pedantically GNUC89, and not\n \t     in system headers.  */"}, {"sha": "3165351f28d6f03eff0daff9f30916b817a40a74", "filename": "gcc/cpplib.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=12f9df4ec55a2004a9c9201886440d9503b6a858", "patch": "@@ -777,8 +777,9 @@ strtoul_for_line (const uchar *str, unsigned int len, long unsigned int *nump)\n static void\n do_line (cpp_reader *pfile)\n {\n+  const struct line_map *map = linemap_lookup (pfile->line_table, pfile->line);\n   const cpp_token *token;\n-  const char *new_file = pfile->map->to_file;\n+  const char *new_file = map->to_file;\n   unsigned long new_lineno;\n \n   /* C99 raised the minimum limit on #line numbers.  */\n@@ -816,7 +817,7 @@ do_line (cpp_reader *pfile)\n \n   skip_rest_of_line (pfile);\n   _cpp_do_file_change (pfile, LC_RENAME, new_file, new_lineno,\n-\t\t       pfile->map->sysp);\n+\t\t       map->sysp);\n }\n \n /* Interpret the # 44 \"file\" [flags] notation, which has slightly\n@@ -825,10 +826,11 @@ do_line (cpp_reader *pfile)\n static void\n do_linemarker (cpp_reader *pfile)\n {\n+  const struct line_map *map = linemap_lookup (pfile->line_table, pfile->line);\n   const cpp_token *token;\n-  const char *new_file = pfile->map->to_file;\n+  const char *new_file = map->to_file;\n   unsigned long new_lineno;\n-  unsigned int new_sysp = pfile->map->sysp;\n+  unsigned int new_sysp = map->sysp;\n   enum lc_reason reason = LC_RENAME;\n   int flag;\n \n@@ -876,6 +878,7 @@ do_linemarker (cpp_reader *pfile)\n \t  flag = read_flag (pfile, flag);\n \t  if (flag == 4)\n \t    new_sysp = 2;\n+\t  pfile->buffer->sysp = new_sysp;\n \t}\n \n       check_eol (pfile);\n@@ -900,21 +903,23 @@ _cpp_do_file_change (cpp_reader *pfile, enum lc_reason reason,\n \t\t     const char *to_file, unsigned int file_line,\n \t\t     unsigned int sysp)\n {\n-  pfile->map = linemap_add (pfile->line_table, reason, sysp,\n-\t\t\t    pfile->line, to_file, file_line);\n+  const struct line_map *map = linemap_add (pfile->line_table, reason, sysp,\n+\t\t\t\t\t    to_file, file_line);\n+  if (map == NULL)\n+    pfile->line = 0;\n+  else\n+    pfile->line = linemap_line_start (pfile->line_table, map->to_line, 127);\n \n   if (pfile->cb.file_change)\n-    pfile->cb.file_change (pfile, pfile->map);\n+    pfile->cb.file_change (pfile, map);\n }\n \n /* Report a warning or error detected by the program we are\n    processing.  Use the directive's tokens in the error message.  */\n static void\n do_diagnostic (cpp_reader *pfile, int code, int print_dir)\n {\n-  if (_cpp_begin_message (pfile, code,\n-\t\t\t  pfile->cur_token[-1].line,\n-\t\t\t  pfile->cur_token[-1].col))\n+  if (_cpp_begin_message (pfile, code, pfile->cur_token[-1].src_loc, 0))\n     {\n       if (print_dir)\n \tfprintf (stderr, \"#%s \", pfile->directive->name);\n@@ -1340,7 +1345,6 @@ destringize_and_run (cpp_reader *pfile, const cpp_string *in)\n     pfile->context = saved_context;\n     pfile->cur_token = saved_cur_token;\n     pfile->cur_run = saved_cur_run;\n-    pfile->line--;\n   }\n \n   /* See above comment.  For the moment, we'd like\n@@ -1903,13 +1907,6 @@ cpp_get_callbacks (cpp_reader *pfile)\n   return &pfile->cb;\n }\n \n-/* The line map set.  */\n-const struct line_maps *\n-cpp_get_line_maps (cpp_reader *pfile)\n-{\n-  return pfile->line_table;\n-}\n-\n /* Copy the given callbacks structure to our own.  */\n void\n cpp_set_callbacks (cpp_reader *pfile, cpp_callbacks *cb)"}, {"sha": "11838212ea51f9c541f6ea7d80ca1c8482fec3a0", "filename": "gcc/cpplib.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=12f9df4ec55a2004a9c9201886440d9503b6a858", "patch": "@@ -174,8 +174,7 @@ struct cpp_string\n    occupy 16 bytes on 32-bit hosts and 24 bytes on 64-bit hosts.  */\n struct cpp_token\n {\n-  fileline line;\t\t/* Logical line of first char of token.  */\n-  unsigned short col;\t\t/* Column of first char of token.  */\n+  source_location src_loc;\t/* Location of first char of token.  */\n   ENUM_BITFIELD(cpp_ttype) type : CHAR_BIT;  /* token type */\n   unsigned char flags;\t\t/* flags - see above */\n \n@@ -527,7 +526,6 @@ extern void cpp_set_include_chains (cpp_reader *, cpp_dir *, cpp_dir *, int);\n    through the pointer returned from cpp_get_callbacks, or set them\n    with cpp_set_callbacks.  */\n extern cpp_options *cpp_get_options (cpp_reader *);\n-extern const struct line_maps *cpp_get_line_maps (cpp_reader *);\n extern cpp_callbacks *cpp_get_callbacks (cpp_reader *);\n extern void cpp_set_callbacks (cpp_reader *, cpp_callbacks *);\n \n@@ -685,7 +683,7 @@ extern void cpp_errno (cpp_reader *, int, const char *msgid);\n /* Same as cpp_error, except additionally specifies a position as a\n    (translation unit) physical line and physical column.  If the line is\n    zero, then no location is printed.  */\n-extern void cpp_error_with_line (cpp_reader *, int, fileline, unsigned,\n+extern void cpp_error_with_line (cpp_reader *, int, source_location, unsigned,\n \t\t\t\t const char *msgid, ...) ATTRIBUTE_PRINTF_5;\n \n /* In cpplex.c */"}, {"sha": "f396a9dbec469c6181eb2fc21e70de94275d50ae", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=12f9df4ec55a2004a9c9201886440d9503b6a858", "patch": "@@ -116,6 +116,7 @@ static const char * const monthnames[] =\n const uchar *\n _cpp_builtin_macro_text (cpp_reader *pfile, cpp_hashnode *node)\n {\n+  const struct line_map *map;\n   const uchar *result = NULL;\n   unsigned int number = 1;\n \n@@ -132,7 +133,7 @@ _cpp_builtin_macro_text (cpp_reader *pfile, cpp_hashnode *node)\n \tunsigned int len;\n \tconst char *name;\n \tuchar *buf;\n-\tconst struct line_map *map = pfile->map;\n+\tmap = linemap_lookup (pfile->line_table, pfile->line);\n \n \tif (node->value.builtin == BT_BASE_FILE)\n \t  while (! MAIN_FILE_P (map))\n@@ -157,14 +158,15 @@ _cpp_builtin_macro_text (cpp_reader *pfile, cpp_hashnode *node)\n       break;\n \n     case BT_SPECLINE:\n+      map = linemap_lookup (pfile->line_table, pfile->line);\n       /* If __LINE__ is embedded in a macro, it must expand to the\n \t line of the macro's invocation, not its definition.\n \t Otherwise things like assert() will not work properly.  */\n       if (CPP_OPTION (pfile, traditional))\n \tnumber = pfile->line;\n       else\n-\tnumber = pfile->cur_token[-1].line;\n-      number = SOURCE_LINE (pfile->map, number);\n+\tnumber = pfile->cur_token[-1].src_loc;\n+      number = SOURCE_LINE (map, number);\n       break;\n \n       /* __STDC__ has the value 1 under normal circumstances.\n@@ -174,7 +176,7 @@ _cpp_builtin_macro_text (cpp_reader *pfile, cpp_hashnode *node)\n \t value 0.  */\n     case BT_STDC:\n       {\n-\tif (CPP_IN_SYSTEM_HEADER (pfile)\n+\tif (cpp_in_system_header (pfile)\n \t    && CPP_OPTION (pfile, stdc_0_in_system_headers)\n \t    && !CPP_OPTION (pfile,std))\n \t  number = 0;\n@@ -1488,7 +1490,7 @@ _cpp_create_definition (cpp_reader *pfile, cpp_hashnode *node)\n   macro->count = 0;\n   macro->fun_like = 0;\n   /* To suppress some diagnostics.  */\n-  macro->syshdr = pfile->map->sysp != 0;\n+  macro->syshdr = pfile->buffer && pfile->buffer->sysp != 0;\n \n   if (CPP_OPTION (pfile, traditional))\n     ok = _cpp_create_trad_definition (pfile, macro);"}, {"sha": "f6dc99d3fecf39b1e489a702b2c22ffba5c11af1", "filename": "gcc/cpptrad.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fcpptrad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fcpptrad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpptrad.c?ref=12f9df4ec55a2004a9c9201886440d9503b6a858", "patch": "@@ -148,7 +148,7 @@ static const uchar *\n copy_comment (cpp_reader *pfile, const uchar *cur, int in_define)\n {\n   bool unterminated, copy = false;\n-  unsigned int from_line = pfile->line;\n+  source_location src_loc = pfile->line;\n   cpp_buffer *buffer = pfile->buffer;\n \n   buffer->cur = cur;\n@@ -158,7 +158,7 @@ copy_comment (cpp_reader *pfile, const uchar *cur, int in_define)\n     unterminated = _cpp_skip_block_comment (pfile);\n     \n   if (unterminated)\n-    cpp_error_with_line (pfile, CPP_DL_ERROR, from_line, 0,\n+    cpp_error_with_line (pfile, CPP_DL_ERROR, src_loc, 0,\n \t\t\t \"unterminated comment\");\n \n   /* Comments in directives become spaces so that tokens are properly\n@@ -268,13 +268,14 @@ _cpp_overlay_buffer (cpp_reader *pfile, const uchar *start, size_t len)\n   cpp_buffer *buffer = pfile->buffer;\n \n   pfile->overlaid_buffer = buffer;\n-  buffer->saved_cur = buffer->cur;\n-  buffer->saved_rlimit = buffer->rlimit;\n-  /* Prevent the ISO lexer from scanning a fresh line.  */\n-  pfile->saved_line = pfile->line--;\n+  pfile->saved_cur = buffer->cur;\n+  pfile->saved_rlimit = buffer->rlimit;\n+  pfile->saved_line_base = buffer->next_line;\n+  pfile->saved_line = pfile->line;\n   buffer->need_line = false;\n \n   buffer->cur = start;\n+  buffer->line_base = start;\n   buffer->rlimit = start + len;\n }\n \n@@ -284,12 +285,12 @@ _cpp_remove_overlay (cpp_reader *pfile)\n {\n   cpp_buffer *buffer = pfile->overlaid_buffer;\n \n-  buffer->cur = buffer->saved_cur;\n-  buffer->rlimit = buffer->saved_rlimit;\n+  buffer->cur = pfile->saved_cur;\n+  buffer->rlimit = pfile->saved_rlimit;\n+  buffer->line_base = pfile->saved_line_base;\n   buffer->need_line = true;\n \n   pfile->overlaid_buffer = NULL;\n-  pfile->line = pfile->saved_line;\n }\n \n /* Reads a logical line into the output buffer.  Returns TRUE if there\n@@ -404,7 +405,7 @@ _cpp_scan_out_logical_line (cpp_reader *pfile, cpp_macro *macro)\n \t  pfile->out.cur = out - 1;\n \t  pfile->buffer->cur = cur;\n \t  pfile->buffer->need_line = true;\n-\t  pfile->line++;\n+\t  CPP_INCREMENT_LINE (pfile, 0);\n \n \t  if ((lex_state == ls_fun_open || lex_state == ls_fun_close)\n \t      && !pfile->state.in_directive\n@@ -605,7 +606,7 @@ _cpp_scan_out_logical_line (cpp_reader *pfile, cpp_macro *macro)\n \t\t  /* Null directive.  Ignore it and don't invalidate\n \t\t     the MI optimization.  */\n \t\t  pfile->buffer->need_line = true;\n-\t\t  pfile->line++;\n+\t\t  CPP_INCREMENT_LINE (pfile, 0);\n \t\t  result = false;\n \t\t  goto done;\n \t\t}"}, {"sha": "a7398bb98eeabc316dabd1954b3540b370260835", "filename": "gcc/line-map.c", "status": "modified", "additions": 82, "deletions": 16, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fline-map.c?ref=12f9df4ec55a2004a9c9201886440d9503b6a858", "patch": "@@ -39,23 +39,32 @@ linemap_init (struct line_maps *set)\n   set->trace_includes = false;\n   set->depth = 0;\n   set->cache = 0;\n+  set->highest_location = 0;\n+  set->max_column_hint = 0;\n }\n \n+/* Check for and warn about line_maps entered but not exited. */\n+\n+void\n+linemap_check_files_exited (struct line_maps *set)\n+{\n+  struct line_map *map;\n+  /* Depending upon whether we are handling preprocessed input or\n+     not, this can be a user error or an ICE.  */\n+  for (map = &set->maps[set->used - 1]; ! MAIN_FILE_P (map);\n+       map = INCLUDED_FROM (set, map))\n+    fprintf (stderr, \"line-map.c: file \\\"%s\\\" entered but not left\\n\",\n+\t     map->to_file);\n+}\n+ \n /* Free a line map set.  */\n \n void\n linemap_free (struct line_maps *set)\n {\n   if (set->maps)\n     {\n-      struct line_map *map;\n-\n-      /* Depending upon whether we are handling preprocessed input or\n-\t not, this can be a user error or an ICE.  */\n-      for (map = CURRENT_LINE_MAP (set); ! MAIN_FILE_P (map);\n-\t   map = INCLUDED_FROM (set, map))\n-\tfprintf (stderr, \"line-map.c: file \\\"%s\\\" entered but not left\\n\",\n-\t\t map->to_file);\n+      linemap_check_files_exited (set);\n \n       free (set->maps);\n     }\n@@ -72,16 +81,17 @@ linemap_free (struct line_maps *set)\n \n    FROM_LINE should be monotonic increasing across calls to this\n    function.  A call to this function can relocate the previous set of\n+   A call to this function can relocate the previous set of\n    maps, so any stored line_map pointers should not be used.  */\n \n const struct line_map *\n linemap_add (struct line_maps *set, enum lc_reason reason,\n-\t     unsigned int sysp, source_location from_line,\n-\t     const char *to_file, unsigned int to_line)\n+\t     unsigned int sysp, const char *to_file, unsigned int to_line)\n {\n   struct line_map *map;\n+  source_location start_location = set->highest_location + 1;\n \n-  if (set->used && from_line < set->maps[set->used - 1].from_line)\n+  if (set->used && start_location < set->maps[set->used - 1].start_location)\n     abort ();\n \n   if (set->used == set->allocated)\n@@ -131,17 +141,20 @@ linemap_add (struct line_maps *set, enum lc_reason reason,\n       if (error || to_file == NULL)\n \t{\n \t  to_file = from->to_file;\n-\t  to_line = LAST_SOURCE_LINE (from) + 1;\n+\t  to_line = SOURCE_LINE (from, from[1].start_location);\n \t  sysp = from->sysp;\n \t}\n     }\n \n   map->reason = reason;\n   map->sysp = sysp;\n-  map->from_line = from_line;\n+  map->start_location = start_location;\n   map->to_file = to_file;\n   map->to_line = to_line;\n   set->cache = set->used++;\n+  map->column_bits = 0;\n+  set->highest_location = start_location;\n+  set->max_column_hint = 0;\n \n   if (reason == LC_ENTER)\n     {\n@@ -161,6 +174,59 @@ linemap_add (struct line_maps *set, enum lc_reason reason,\n   return map;\n }\n \n+source_location\n+linemap_line_start (struct line_maps *set, unsigned int to_line,\n+\t\t    unsigned int max_column_hint)\n+{\n+  struct line_map *map = &set->maps[set->used - 1];\n+  source_location highest = set->highest_location;\n+  source_location r;\n+  unsigned int last_line = SOURCE_LINE (map, highest);\n+  int line_delta = to_line - last_line;\n+  bool add_map = false;\n+  if (line_delta < 0\n+      || (line_delta > 10 && line_delta * map->column_bits > 1000)\n+      || (max_column_hint >= (1U << map->column_bits))\n+      || (max_column_hint <= 80 && map->column_bits >= 10))\n+    {\n+      add_map = true;\n+    }\n+  else\n+    max_column_hint = set->max_column_hint;\n+  if (add_map)\n+    {\n+      int column_bits;\n+      if (max_column_hint > 1000000 || highest > 0xC0000000)\n+\t{\n+\t  max_column_hint = 0;\n+\t  if (highest >0xF0000000)\n+\t    return 0;\n+\t  column_bits = 0;\n+\t}\n+      else\n+\t{\n+\t  column_bits = 7;\n+\t  while (max_column_hint >= (1U << column_bits))\n+\t    column_bits++;\n+\t  max_column_hint = 1U << column_bits;\n+\t}\n+      if (line_delta < 0\n+\t  || last_line != map->to_line\n+\t  || SOURCE_COLUMN (map, highest) >= (1U << column_bits))\n+\tmap = (struct line_map*) linemap_add (set, LC_RENAME, map->sysp,\n+\t\t\t\t      map->to_file, to_line);\n+      map->column_bits = column_bits;\n+      r = map->start_location;\n+    }\n+  else\n+    r = highest - SOURCE_COLUMN (map, highest)\n+      + (line_delta << map->column_bits);\n+  if (r > set->highest_location)\n+    set->highest_location = r;\n+  set->max_column_hint = max_column_hint;\n+  return r;\n+}\n+\n /* Given a logical line, returns the map from which the corresponding\n    (source file, line) pair can be deduced.  Since the set is built\n    chronologically, the logical lines are monotonic increasing, and so\n@@ -177,9 +243,9 @@ linemap_lookup (struct line_maps *set, source_location line)\n   \n   cached = &set->maps[mn];\n   /* We should get a segfault if no line_maps have been added yet. */\n-  if (line >= cached->from_line)\n+  if (line >= cached->start_location)\n     {\n-      if (mn + 1 == mx || line < cached[1].from_line)\n+      if (mn + 1 == mx || line < cached[1].start_location)\n \treturn cached;\n     }\n   else\n@@ -191,7 +257,7 @@ linemap_lookup (struct line_maps *set, source_location line)\n   while (mx - mn > 1)\n     {\n       md = (mn + mx) / 2;\n-      if (set->maps[md].from_line > line)\n+      if (set->maps[md].start_location > line)\n \tmx = md;\n       else\n \tmn = md;"}, {"sha": "6f09fcfd3312347aba24966a583a776517fb4266", "filename": "gcc/line-map.h", "status": "modified", "additions": 78, "deletions": 18, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f9df4ec55a2004a9c9201886440d9503b6a858/gcc%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fline-map.h?ref=12f9df4ec55a2004a9c9201886440d9503b6a858", "patch": "@@ -30,28 +30,35 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    (e.g. a #line directive in C).  */\n enum lc_reason {LC_ENTER = 0, LC_LEAVE, LC_RENAME};\n \n-/* A logical line number, i,e, an \"index\" into a line_map.  */\n+/* A logical line/column number, i.e. an \"index\" into a line_map.  */\n /* Long-term, we want to use this to replace struct location_s (in input.h),\n    and effectively typedef source_location location_t.  */\n typedef unsigned int source_location;\n typedef source_location fileline; /* deprecated name */\n \n-/* The logical line FROM_LINE maps to physical source file TO_FILE at\n-   line TO_LINE, and subsequently one-to-one until the next line_map\n-   structure in the set.  INCLUDED_FROM is an index into the set that\n-   gives the line mapping at whose end the current one was included.\n-   File(s) at the bottom of the include stack have this set to -1.\n-   REASON is the reason for creation of this line map, SYSP is one for\n-   a system header, two for a C system header file that therefore\n-   needs to be extern \"C\" protected in C++, and zero otherwise.  */\n+/* Physical source file TO_FILE at line TO_LINE at column 0 is represented\n+   by the logical START_LOCATION.  TO_LINE+L at column C is represented by\n+   START_LOCATION+(L*(1<<column_bits))+C, as long as C<(1<<column_bits),\n+   and the result_location is less than the next line_map's start_location.\n+   (The top line is line 1 and the leftmost column is column 1; line/column 0\n+   means \"entire file/line\" or \"unknown line/column\" or \"not applicable\".)\n+   INCLUDED_FROM is an index into the set that gives the line mapping\n+   at whose end the current one was included.  File(s) at the bottom\n+   of the include stack have this set to -1.  REASON is the reason for\n+   creation of this line map, SYSP is one for a system header, two for\n+   a C system header file that therefore needs to be extern \"C\"\n+   protected in C++, and zero otherwise.  */\n struct line_map\n {\n   const char *to_file;\n   unsigned int to_line;\n-  source_location from_line;\n+  source_location start_location;\n   int included_from;\n   ENUM_BITFIELD (lc_reason) reason : CHAR_BIT;\n+  /* The sysp field isn't really needed now that it's in cpp_buffer. */\n   unsigned char sysp;\n+  /* Number of the low-order source_location bits used for a column number. */\n+  unsigned int column_bits : 8;\n };\n \n /* A set of chronological line_map structures.  */\n@@ -73,6 +80,13 @@ struct line_maps\n \n   /* If true, prints an include trace a la -H.  */\n   bool trace_includes;\n+\n+  /* Highest source_location \"given out\". */\n+  source_location highest_location;\n+\n+  /* The maximum column number we can quickly allocate.  Higher numbers\n+     may require allocating a new line_map. */\n+  unsigned int max_column_hint;\n };\n \n /* Initialize a line map set.  */\n@@ -81,6 +95,19 @@ extern void linemap_init (struct line_maps *);\n /* Free a line map set.  */\n extern void linemap_free (struct line_maps *);\n \n+/* Check for and warn about line_maps entered but not exited. */\n+\n+extern void linemap_check_files_exited (struct line_maps *);\n+\n+/* Return a source_location for the start (i.e. column==0) of\n+   (physical) line TO_LINE in the current source file (as in the\n+   most recent linemap_add).   MAX_COLUMN_HINT is the highest column\n+   number we expect to use in this line (but it does not change\n+   the highest_location). */\n+\n+extern source_location linemap_line_start\n+(struct line_maps *, unsigned int,  unsigned int);\n+\n /* Add a mapping of logical source line to physical source file and\n    line number.\n \n@@ -90,12 +117,12 @@ extern void linemap_free (struct line_maps *);\n    TO_FILE is NULL, then TO_FILE, TO_LINE and SYSP are given their\n    natural values considering the file we are returning to.\n \n-   FROM_LINE should be monotonic increasing across calls to this\n+   START_LOCATION should be monotonic increasing across calls to this\n    function.  A call to this function can relocate the previous set of\n    maps, so any stored line_map pointers should not be used.  */\n extern const struct line_map *linemap_add\n   (struct line_maps *, enum lc_reason, unsigned int sysp,\n-   source_location from_line, const char *to_file, unsigned int to_line);\n+   const char *to_file, unsigned int to_line);\n \n /* Given a logical line, returns the map from which the corresponding\n    (source file, line) pair can be deduced.  */\n@@ -108,21 +135,54 @@ extern const struct line_map *linemap_lookup\n extern void linemap_print_containing_files (struct line_maps *,\n \t\t\t\t\t    const struct line_map *);\n \n-/* Converts a map and logical line to source line.  */\n-#define SOURCE_LINE(MAP, LINE) ((LINE) + (MAP)->to_line - (MAP)->from_line)\n+/* Converts a map and a source_location to source line.  */\n+#define SOURCE_LINE(MAP, LINE) \\\n+  ((((LINE) - (MAP)->start_location) >> (MAP)->column_bits) + (MAP)->to_line)\n+\n+#define SOURCE_COLUMN(MAP, LINE) \\\n+  (((LINE) - (MAP)->start_location) & ((1 << (MAP)->column_bits) - 1))\n \n /* Returns the last source line within a map.  This is the (last) line\n    of the #include, or other directive, that caused a map change.  */\n-#define LAST_SOURCE_LINE(MAP) SOURCE_LINE ((MAP), (MAP)[1].from_line - 1)\n+#define LAST_SOURCE_LINE(MAP) \\\n+  SOURCE_LINE (MAP, LAST_SOURCE_LINE_LOCATION (MAP))\n+#define LAST_SOURCE_LINE_LOCATION(MAP) \\\n+  ((((MAP)[1].start_location - 2 - (MAP)->start_location) \\\n+    & ~((1 << (MAP)->column_bits) - 1))\t\t\t  \\\n+   + (MAP)->start_location)\n \n /* Returns the map a given map was included from.  */\n #define INCLUDED_FROM(SET, MAP) (&(SET)->maps[(MAP)->included_from])\n \n /* Nonzero if the map is at the bottom of the include stack.  */\n #define MAIN_FILE_P(MAP) ((MAP)->included_from < 0)\n \n-/* The current line map.  Saves a call to lookup_line if the caller is\n-   sure he is in the scope of the current map.  */\n-#define CURRENT_LINE_MAP(MAPS) ((MAPS)->maps + (MAPS)->used - 1)\n+/* Get a source position that for the same line as the most recent\n+   linemap_line_start, but with the specified TO_COLUMN column number. */\n \n+static inline source_location\n+linemap_position_for_column (struct line_maps *set, unsigned int to_column)\n+{\n+  struct line_map *map = &set->maps[set->used - 1];\n+  source_location r = set->highest_location;\n+  if (__builtin_expect (to_column > set->max_column_hint, 0))\n+    {\n+      if (r >= 0xC000000 || to_column > 1000000) /* FIXME */\n+\t{\n+\t  /* Running low on source_locations - disable column numbers. */\n+\t  return r - SOURCE_COLUMN (map, r);\n+\t}\n+      else\n+\t{\n+\t  r = linemap_line_start (set, SOURCE_LINE (map, r), to_column + 50);\n+\t  map = &set->maps[set->used - 1];\n+\t  r = set->highest_location;\n+\t}\n+    }\n+  r = r - SOURCE_COLUMN (map, r) + to_column;\n+  if (r >= set->highest_location)\n+    set->highest_location = r;\n+  return r;\n+}\n+\t\t\t\t\t\t  \n #endif /* !GCC_LINE_MAP_H  */"}]}