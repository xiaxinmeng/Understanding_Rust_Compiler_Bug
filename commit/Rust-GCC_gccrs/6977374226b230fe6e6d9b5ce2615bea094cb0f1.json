{"sha": "6977374226b230fe6e6d9b5ce2615bea094cb0f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk3NzM3NDIyNmIyMzBmZTZlNmQ5YjVjZTI2MTViZWEwOTRjYjBmMQ==", "commit": {"author": {"name": "Janus Weil", "email": "jaydub66@gmail.com", "date": "2007-09-04T13:50:35Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2007-09-04T13:50:35Z"}, "message": "decl.c (match_procedure_decl,match_procedure_in_interface, [...]): Handle PROCEDURE statements.\n\n2007-09-04  Janus Weil  <jaydub66@gmail.com>\n\t    Paul Thomas  <pault@gcc.gnu.org>\n\n\t* decl.c (match_procedure_decl,match_procedure_in_interface,\n\tgfc_match_procedure): Handle PROCEDURE statements.\n\t* gfortran.h (struct gfc_symbol): New member \"gfc_symbol *interface\".\n\t(enum gfc_statement): New element \"ST_PROCEDURE\".\n\t(strcut symbol_attribute): New member \"unsigned procedure\".\n\t* interface.c (check_interface0): Extended error checking.\n\t* match.h: Add gfc_match_procedure prototype.\n\t* parse.c (decode_statement,next_statement,gfc_ascii_statement,\n\tparse_derived,parse_interface): Implement PROCEDURE statements.\n\t* resolve.c (resolve_symbol): Ditto.\n\t* symbol.c (check_conflict): Ditto.\n\t(gfc_add_proc): New function for setting the procedure attribute.\n\t(copy_formal_args): New function for copying formal argument lists.\n\n\n2007-09-04  Janus Weil  <jaydub66@gmail.com>\n\t    Tobias Burnus  <burnus@net-b.de>\n\n\t* gfortran.dg/proc_decl_1.f90: New.\n\t* gfortran.dg/proc_decl_2.f90: New.\n\t* gfortran.dg/proc_decl_3.f90: New.\n\t* gfortran.dg/proc_decl_4.f90: New.\n\n\nCo-Authored-By: Paul Thomas <pault@gcc.gnu.org>\nCo-Authored-By: Tobias Burnus <burnus@net-b.de>\n\nFrom-SVN: r128081", "tree": {"sha": "978d0573428d251aa1224d4da532cdb6c957b8b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/978d0573428d251aa1224d4da532cdb6c957b8b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6977374226b230fe6e6d9b5ce2615bea094cb0f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6977374226b230fe6e6d9b5ce2615bea094cb0f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6977374226b230fe6e6d9b5ce2615bea094cb0f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6977374226b230fe6e6d9b5ce2615bea094cb0f1/comments", "author": null, "committer": null, "parents": [{"sha": "8070c91a53e4f058080e610b9d18c7c2c7d6fdfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8070c91a53e4f058080e610b9d18c7c2c7d6fdfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8070c91a53e4f058080e610b9d18c7c2c7d6fdfe"}], "stats": {"total": 697, "additions": 691, "deletions": 6}, "files": [{"sha": "6ac59b6ba6eff00fe29fe19fb5919db0419044a1", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6977374226b230fe6e6d9b5ce2615bea094cb0f1", "patch": "@@ -1,3 +1,20 @@\n+2007-09-04  Janus Weil  <jaydub66@gmail.com>\n+\t    Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* decl.c (match_procedure_decl,match_procedure_in_interface,\n+\tgfc_match_procedure): Handle PROCEDURE statements.\n+\t* gfortran.h (struct gfc_symbol): New member \"gfc_symbol *interface\".\n+\t(enum gfc_statement): New element \"ST_PROCEDURE\".\n+\t(strcut symbol_attribute): New member \"unsigned procedure\".\n+\t* interface.c (check_interface0): Extended error checking.\n+\t* match.h: Add gfc_match_procedure prototype.\n+\t* parse.c (decode_statement,next_statement,gfc_ascii_statement,\n+\tparse_derived,parse_interface): Implement PROCEDURE statements.\n+\t* resolve.c (resolve_symbol): Ditto.\n+\t* symbol.c (check_conflict): Ditto.\n+\t(gfc_add_proc): New function for setting the procedure attribute.\n+\t(copy_formal_args): New function for copying formal argument lists.\n+\n 2007-09-03  Daniel Jacobowitz  <dan@codesourcery.com>\n \n \t* Make-lang.in (gfortranspec.o): Remove SHLIB_MULTILIB."}, {"sha": "470cbfa415480eb2d750412ffea4ad46e1a87d3a", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=6977374226b230fe6e6d9b5ce2615bea094cb0f1", "patch": "@@ -3759,6 +3759,248 @@ gfc_match_suffix (gfc_symbol *sym, gfc_symbol **result)\n }\n \n \n+/* Match a PROCEDURE declaration (R1211).  */\n+\n+static match\n+match_procedure_decl (void)\n+{\n+  match m;\n+  locus old_loc, entry_loc;\n+  gfc_symbol *sym, *proc_if = NULL;\n+  int num;\n+\n+  old_loc = entry_loc = gfc_current_locus;\n+\n+  gfc_clear_ts (&current_ts);\n+\n+  if (gfc_match (\" (\") != MATCH_YES)\n+    {\n+      gfc_current_locus = entry_loc;\n+      return MATCH_NO;\n+    }\n+\n+  /* Get the type spec. for the procedure interface.  */\n+  old_loc = gfc_current_locus;\n+  m = match_type_spec (&current_ts, 0);\n+  if (m == MATCH_YES || (m == MATCH_NO && gfc_peek_char () == ')'))\n+    goto got_ts;\n+\n+  if (m == MATCH_ERROR)\n+    return m;\n+\n+  gfc_current_locus = old_loc;\n+\n+  /* Get the name of the procedure or abstract interface\n+  to inherit the interface from.  */\n+  m = gfc_match_symbol (&proc_if, 1);\n+\n+  if (m == MATCH_NO)\n+    goto syntax;\n+  else if (m == MATCH_ERROR)\n+    return m;\n+\n+  /* Various interface checks.  */\n+  if (proc_if)\n+    {\n+      if (proc_if->generic)\n+\t{\n+\t  gfc_error (\"Interface '%s' at %C may not be generic\", proc_if->name);\n+\t  return MATCH_ERROR;\n+\t}\n+      if (proc_if->attr.proc == PROC_ST_FUNCTION)\n+\t{\n+\t  gfc_error (\"Interface '%s' at %C may not be a statement function\",\n+\t\t    proc_if->name);\n+\t  return MATCH_ERROR;\n+\t}\n+      /* Handle intrinsic procedures.  */\n+      if (gfc_intrinsic_name (proc_if->name, 0)\n+\t  || gfc_intrinsic_name (proc_if->name, 1))\n+\tproc_if->attr.intrinsic = 1;\n+      if (proc_if->attr.intrinsic\n+\t  && !gfc_intrinsic_actual_ok (proc_if->name, 0))\n+\t{\n+\t  gfc_error (\"Intrinsic procedure '%s' not allowed \"\n+\t\t    \"in PROCEDURE statement at %C\", proc_if->name);\n+\t  return MATCH_ERROR;\n+\t}\n+      /* TODO: Allow intrinsics with gfc_intrinsic_actual_ok\n+\t (proc_if->name, 0) after PR33162 is fixed.  */\n+      if (proc_if->attr.intrinsic)\n+\t{\n+\t  gfc_error (\"Fortran 2003: Support for intrinsic procedure '%s' \"\n+\t\t     \"in PROCEDURE statement at %C not yet implemented \"\n+\t\t     \"in gfortran\", proc_if->name);\n+\t  return MATCH_ERROR;\n+\t}\n+    }\n+\n+got_ts:\n+\n+  if (gfc_match (\" )\") != MATCH_YES)\n+    {\n+      gfc_current_locus = entry_loc;\n+      return MATCH_NO;\n+    }\n+\n+  /* Parse attributes.  */\n+  m = match_attr_spec();\n+  if (m == MATCH_ERROR)\n+    return MATCH_ERROR;\n+\n+  /* Get procedure symbols.  */\n+  for(num=1;;num++)\n+    {\n+\n+      m = gfc_match_symbol (&sym, 0);\n+      if (m == MATCH_NO)\n+\tgoto syntax;\n+      else if (m == MATCH_ERROR)\n+\treturn m;\n+\n+      /* Add current_attr to the symbol attributes.  */\n+      if (gfc_copy_attr (&sym->attr, &current_attr, NULL) == FAILURE)\n+\treturn MATCH_ERROR;\n+\n+      if (sym->attr.is_bind_c)\n+\t{\n+\t  /* Check for C1218.  */\n+\t  if (!proc_if || !proc_if->attr.is_bind_c)\n+\t    {\n+\t      gfc_error (\"BIND(C) attribute at %C requires \"\n+\t\t\t\"an interface with BIND(C)\");\n+\t      return MATCH_ERROR;\n+\t    }\n+\t  /* Check for C1217.  */\n+\t  if (has_name_equals && sym->attr.pointer)\n+\t    {\n+\t      gfc_error (\"BIND(C) procedure with NAME may not have \"\n+\t\t\t\"POINTER attribute at %C\");\n+\t      return MATCH_ERROR;\n+\t    }\n+\t  if (has_name_equals && sym->attr.dummy)\n+\t    {\n+\t      gfc_error (\"Dummy procedure at %C may not have \"\n+\t\t\t\"BIND(C) attribute with NAME\");\n+\t      return MATCH_ERROR;\n+\t    }\n+\t  /* Set binding label for BIND(C).  */\n+\t  if (set_binding_label (sym->binding_label, sym->name, num) != SUCCESS)\n+\t    return MATCH_ERROR;\n+\t}\n+\n+      if (!sym->attr.pointer && gfc_add_external (&sym->attr, NULL) == FAILURE)\n+\treturn MATCH_ERROR;\n+      if (gfc_add_proc (&sym->attr, sym->name, NULL) == FAILURE)\n+\treturn MATCH_ERROR;\n+\n+      /* Set interface.  */\n+      if (proc_if != NULL)\n+\tsym->interface = proc_if;\n+      else if (current_ts.type != BT_UNKNOWN)\n+\t{\n+\t  sym->interface = gfc_new_symbol (\"\", gfc_current_ns);\n+\t  sym->interface->ts = current_ts;\n+\t  sym->interface->attr.function = 1;\n+\t  sym->ts = sym->interface->ts;\n+\t  sym->attr.function = sym->interface->attr.function;\n+\t}\n+\n+      if (gfc_match_eos () == MATCH_YES)\n+\treturn MATCH_YES;\n+      if (gfc_match_char (',') != MATCH_YES)\n+\tgoto syntax;\n+    }\n+\n+syntax:\n+  gfc_error (\"Syntax error in PROCEDURE statement at %C\");\n+  return MATCH_ERROR;\n+}\n+\n+\n+/* Match a PROCEDURE declaration inside an interface (R1206).  */\n+\n+static match\n+match_procedure_in_interface (void)\n+{\n+  match m;\n+  gfc_symbol *sym;\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+\n+  if (current_interface.type == INTERFACE_NAMELESS\n+      || current_interface.type == INTERFACE_ABSTRACT)\n+    {\n+      gfc_error (\"PROCEDURE at %C must be in a generic interface\");\n+      return MATCH_ERROR;\n+    }\n+\n+  for(;;)\n+    {\n+      m = gfc_match_name (name);\n+      if (m == MATCH_NO)\n+\tgoto syntax;\n+      else if (m == MATCH_ERROR)\n+\treturn m;\n+      if (gfc_get_symbol (name, gfc_current_ns->parent, &sym))\n+\treturn MATCH_ERROR;\n+\n+      if (gfc_add_interface (sym) == FAILURE)\n+\treturn MATCH_ERROR;\n+\n+      sym->attr.procedure = 1;\n+\n+      if (gfc_match_eos () == MATCH_YES)\n+\tbreak;\n+      if (gfc_match_char (',') != MATCH_YES)\n+\tgoto syntax;\n+    }\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_error (\"Syntax error in PROCEDURE statement at %C\");\n+  return MATCH_ERROR;\n+}\n+\n+\n+/* General matcher for PROCEDURE declarations.  */\n+\n+match\n+gfc_match_procedure (void)\n+{\n+  match m;\n+\n+  switch (gfc_current_state ())\n+    {\n+    case COMP_NONE:\n+    case COMP_PROGRAM:\n+    case COMP_MODULE:\n+    case COMP_SUBROUTINE:\n+    case COMP_FUNCTION:\n+      m = match_procedure_decl ();\n+      break;\n+    case COMP_INTERFACE:\n+      m = match_procedure_in_interface ();\n+      break;\n+    case COMP_DERIVED:\n+      gfc_error (\"Fortran 2003: Procedure components at %C are \"\n+\t\t\"not yet implemented in gfortran\");\n+      return MATCH_ERROR;\n+    default:\n+      return MATCH_NO;\n+    }\n+\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: PROCEDURE statement at %C\")\n+      == FAILURE)\n+    return MATCH_ERROR;\n+\n+  return m;\n+}\n+\n+\n /* Match a function declaration.  */\n \n match"}, {"sha": "bfd1af88b90f7a7ab06dc266f292583e1178ab1f", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=6977374226b230fe6e6d9b5ce2615bea094cb0f1", "patch": "@@ -222,7 +222,7 @@ typedef enum\n   ST_OMP_END_WORKSHARE, ST_OMP_DO, ST_OMP_FLUSH, ST_OMP_MASTER, ST_OMP_ORDERED,\n   ST_OMP_PARALLEL, ST_OMP_PARALLEL_DO, ST_OMP_PARALLEL_SECTIONS,\n   ST_OMP_PARALLEL_WORKSHARE, ST_OMP_SECTIONS, ST_OMP_SECTION, ST_OMP_SINGLE,\n-  ST_OMP_THREADPRIVATE, ST_OMP_WORKSHARE,\n+  ST_OMP_THREADPRIVATE, ST_OMP_WORKSHARE, ST_PROCEDURE,\n   ST_NONE\n }\n gfc_statement;\n@@ -589,7 +589,8 @@ typedef struct\n     imported:1;\t\t\t/* Symbol has been associated by IMPORT.  */\n \n   unsigned in_namelist:1, in_common:1, in_equivalence:1;\n-  unsigned function:1, subroutine:1, generic:1, generic_copy:1;\n+  unsigned function:1, subroutine:1, procedure:1;\n+  unsigned generic:1, generic_copy:1;\n   unsigned implicit_type:1;\t/* Type defined via implicit rules.  */\n   unsigned untyped:1;           /* No implicit type could be found.  */\n \n@@ -961,6 +962,8 @@ typedef struct gfc_symbol\n   struct gfc_symbol *result;\t/* function result symbol */\n   gfc_component *components;\t/* Derived type components */\n \n+  struct gfc_symbol *interface;\t/* For PROCEDURE declarations.  */\n+\n   /* Defined only for Cray pointees; points to their pointer.  */\n   struct gfc_symbol *cp_pointer;\n \n@@ -2039,6 +2042,7 @@ try gfc_add_recursive (symbol_attribute *, locus *);\n try gfc_add_function (symbol_attribute *, const char *, locus *);\n try gfc_add_subroutine (symbol_attribute *, const char *, locus *);\n try gfc_add_volatile (symbol_attribute *, const char *, locus *);\n+try gfc_add_proc (symbol_attribute *attr, const char *name, locus *where);\n \n try gfc_add_access (symbol_attribute *, gfc_access, const char *, locus *);\n try gfc_add_is_bind_c(symbol_attribute *, const char *, locus *, int);\n@@ -2110,6 +2114,8 @@ void gfc_symbol_state (void);\n gfc_gsymbol *gfc_get_gsymbol (const char *);\n gfc_gsymbol *gfc_find_gsymbol (gfc_gsymbol *, const char *);\n \n+void copy_formal_args (gfc_symbol *dest, gfc_symbol *src);\n+\n /* intrinsic.c */\n extern int gfc_init_expr;\n "}, {"sha": "741bba57520998e7bc03f8caafd33d241a89b568", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=6977374226b230fe6e6d9b5ce2615bea094cb0f1", "patch": "@@ -986,7 +986,8 @@ check_interface0 (gfc_interface *p, const char *interface_name)\n   /* Make sure all symbols in the interface have been defined as\n      functions or subroutines.  */\n   for (; p; p = p->next)\n-    if (!p->sym->attr.function && !p->sym->attr.subroutine)\n+    if ((!p->sym->attr.function && !p->sym->attr.subroutine)\n+\t|| !p->sym->attr.if_source)\n       {\n \tif (p->sym->attr.external)\n \t  gfc_error (\"Procedure '%s' in %s at %L has no explicit interface\","}, {"sha": "4841f33eacc2e621885003dc5db94221754573f5", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=6977374226b230fe6e6d9b5ce2615bea094cb0f1", "patch": "@@ -133,6 +133,7 @@ match gfc_match_old_kind_spec (gfc_typespec *);\n match gfc_match_end (gfc_statement *);\n match gfc_match_data_decl (void);\n match gfc_match_formal_arglist (gfc_symbol *, int, int);\n+match gfc_match_procedure (void);\n match gfc_match_function_decl (void);\n match gfc_match_entry (void);\n match gfc_match_subroutine (void);"}, {"sha": "50c0c0dd979e8ad6ad66186e5e34f053094cc335", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=6977374226b230fe6e6d9b5ce2615bea094cb0f1", "patch": "@@ -258,6 +258,7 @@ decode_statement (void)\n       match (\"pointer\", gfc_match_pointer, ST_ATTR_DECL);\n       if (gfc_match_private (&st) == MATCH_YES)\n \treturn st;\n+      match (\"procedure\", gfc_match_procedure, ST_PROCEDURE);\n       match (\"program\", gfc_match_program, ST_PROGRAM);\n       if (gfc_match_public (&st) == MATCH_YES)\n \treturn st;\n@@ -719,7 +720,8 @@ next_statement (void)\n \n #define case_decl case ST_ATTR_DECL: case ST_COMMON: case ST_DATA_DECL: \\\n   case ST_EQUIVALENCE: case ST_NAMELIST: case ST_STATEMENT_FUNCTION: \\\n-  case ST_TYPE: case ST_INTERFACE: case ST_OMP_THREADPRIVATE\n+  case ST_TYPE: case ST_INTERFACE: case ST_OMP_THREADPRIVATE: \\\n+  case ST_PROCEDURE\n \n /* Block end statements.  Errors associated with interchanging these\n    are detected in gfc_match_end().  */\n@@ -1078,6 +1080,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_PROGRAM:\n       p = \"PROGRAM\";\n       break;\n+    case ST_PROCEDURE:\n+      p = \"PROCEDURE\";\n+      break;\n     case ST_READ:\n       p = \"READ\";\n       break;\n@@ -1537,6 +1542,7 @@ parse_derived (void)\n \t  unexpected_eof ();\n \n \tcase ST_DATA_DECL:\n+\tcase ST_PROCEDURE:\n \t  accept_statement (st);\n \t  seen_component = 1;\n \t  break;\n@@ -1749,6 +1755,7 @@ parse_interface (void)\n \t\t\t\t  gfc_new_block->formal, NULL);\n       break;\n \n+    case ST_PROCEDURE:\n     case ST_MODULE_PROC:\t/* The module procedure matcher makes\n \t\t\t\t   sure the context is correct.  */\n       accept_statement (st);"}, {"sha": "76a20a4cb5b4cf67faf472e6fd8e23069e6d3b95", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=6977374226b230fe6e6d9b5ce2615bea094cb0f1", "patch": "@@ -7362,6 +7362,25 @@ resolve_symbol (gfc_symbol *sym)\n \t}\n     }\n \n+  if (sym->attr.procedure && sym->interface\n+      && sym->attr.if_source != IFSRC_DECL)\n+    {\n+      /* Get the attributes from the interface (now resolved).  */\n+      if (sym->interface->attr.if_source || sym->interface->attr.intrinsic)\n+\t{\n+\t  sym->ts = sym->interface->ts;\n+\t  sym->attr.function = sym->interface->attr.function;\n+\t  sym->attr.subroutine = sym->interface->attr.subroutine;\n+\t  copy_formal_args (sym, sym->interface);\n+\t}\n+      else if (sym->interface->name[0] != '\\0')\n+\t{\n+\t  gfc_error (\"Interface '%s' of procedure '%s' at %L must be explicit\",\n+\t\t    sym->interface->name, sym->name, &sym->declared_at);\n+\t  return;\n+\t}\n+    }\n+\n   if (sym->attr.flavor == FL_DERIVED && resolve_fl_derived (sym) == FAILURE)\n     return;\n "}, {"sha": "69a675b93d0b0c1abec3cc3b7578d487de400be4", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 96, "deletions": 2, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=6977374226b230fe6e6d9b5ce2615bea094cb0f1", "patch": "@@ -352,7 +352,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n     *use_assoc = \"USE ASSOCIATED\", *cray_pointer = \"CRAY POINTER\",\n     *cray_pointee = \"CRAY POINTEE\", *data = \"DATA\", *value = \"VALUE\",\n     *volatile_ = \"VOLATILE\", *protected = \"PROTECTED\",\n-    *is_bind_c = \"BIND(C)\";\n+    *is_bind_c = \"BIND(C)\", *procedure = \"PROCEDURE\";\n   static const char *threadprivate = \"THREADPRIVATE\";\n \n   const char *a1, *a2;\n@@ -438,7 +438,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n \n   conf (external, intrinsic);\n \n-  if (attr->if_source || attr->contained)\n+  if ((attr->if_source && !attr->procedure) || attr->contained)\n     {\n       conf (external, subroutine);\n       conf (external, function);\n@@ -545,6 +545,22 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n       goto conflict;\n     }\n \n+  conf (procedure, allocatable)\n+  conf (procedure, dimension)\n+  conf (procedure, intrinsic)\n+  conf (procedure, protected)\n+  conf (procedure, target)\n+  conf (procedure, value)\n+  conf (procedure, volatile_)\n+  conf (procedure, entry)\n+  /* TODO: Implement procedure pointers.  */\n+  if (attr->procedure && attr->pointer)\n+    {\n+      gfc_error (\"Fortran 2003: Procedure pointers at %L are \"\n+\t\t \"not yet implemented in gfortran\", where);\n+      return FAILURE;\n+    }\n+\n   a1 = gfc_code2string (flavors, attr->flavor);\n \n   if (attr->in_namelist\n@@ -1212,6 +1228,29 @@ gfc_add_generic (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n+try\n+gfc_add_proc (symbol_attribute *attr, const char *name, locus *where)\n+{\n+\n+  if (check_used (attr, NULL, where))\n+    return FAILURE;\n+\n+  if (attr->flavor != FL_PROCEDURE\n+      && gfc_add_flavor (attr, FL_PROCEDURE, name, where) == FAILURE)\n+    return FAILURE;\n+\n+  if (attr->procedure)\n+    {\n+      duplicate_attr (\"PROCEDURE\", where);\n+      return FAILURE;\n+    }\n+\n+  attr->procedure = 1;\n+\n+  return check_conflict (attr, NULL, where);\n+}\n+\n+\n /* Flavors are special because some flavors are not what Fortran\n    considers attributes and can be reaffirmed multiple times.  */\n \n@@ -3532,6 +3571,61 @@ add_proc_interface (gfc_symbol *sym, ifsrc source,\n   sym->attr.if_source = source;\n }\n \n+/* Copy the formal args from an existing symbol, src, into a new\n+   symbol, dest.  New formal args are created, and the description of\n+   each arg is set according to the existing ones.  This function is\n+   used when creating procedure declaration variables from a procedure\n+   declaration statement (see match_proc_decl()) to create the formal\n+   args based on the args of a given named interface.  */\n+\n+void copy_formal_args (gfc_symbol *dest, gfc_symbol *src)\n+{\n+  gfc_formal_arglist *head = NULL;\n+  gfc_formal_arglist *tail = NULL;\n+  gfc_formal_arglist *formal_arg = NULL;\n+  gfc_formal_arglist *curr_arg = NULL;\n+  gfc_formal_arglist *formal_prev = NULL;\n+  /* Save current namespace so we can change it for formal args.  */\n+  gfc_namespace *parent_ns = gfc_current_ns;\n+\n+  /* Create a new namespace, which will be the formal ns (namespace\n+     of the formal args).  */\n+  gfc_current_ns = gfc_get_namespace (parent_ns, 0);\n+  gfc_current_ns->proc_name = dest;\n+\n+  for (curr_arg = src->formal; curr_arg; curr_arg = curr_arg->next)\n+    {\n+      formal_arg = gfc_get_formal_arglist ();\n+      gfc_get_symbol (curr_arg->sym->name, gfc_current_ns, &(formal_arg->sym));\n+\n+      /* May need to copy more info for the symbol.  */\n+      formal_arg->sym->attr = curr_arg->sym->attr;\n+      formal_arg->sym->ts = curr_arg->sym->ts;\n+\n+      /* If this isn't the first arg, set up the next ptr.  For the\n+        last arg built, the formal_arg->next will never get set to\n+        anything other than NULL.  */\n+      if (formal_prev != NULL)\n+\tformal_prev->next = formal_arg;\n+      else\n+\tformal_arg->next = NULL;\n+\n+      formal_prev = formal_arg;\n+\n+      /* Add arg to list of formal args.  */\n+      add_formal_arg (&head, &tail, formal_arg, formal_arg->sym);\n+    }\n+\n+  /* Add the interface to the symbol.  */\n+  add_proc_interface (dest, IFSRC_DECL, head);\n+\n+  /* Store the formal namespace information.  */\n+  if (dest->formal != NULL)\n+    /* The current ns should be that for the dest proc.  */\n+    dest->formal_ns = gfc_current_ns;\n+  /* Restore the current namespace to what it was on entry.  */\n+  gfc_current_ns = parent_ns;\n+}\n \n /* Builds the parameter list for the iso_c_binding procedure\n    c_f_pointer or c_f_procpointer.  The old_sym typically refers to a"}, {"sha": "5762c3204b6c79acc3f9de12e1a4662ff537fc8b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6977374226b230fe6e6d9b5ce2615bea094cb0f1", "patch": "@@ -1,3 +1,11 @@\n+2007-09-04  Janus Weil  <jaydub66@gmail.com>\n+\t    Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.dg/proc_decl_1.f90: New.\n+\t* gfortran.dg/proc_decl_2.f90: New.\n+\t* gfortran.dg/proc_decl_3.f90: New.\n+\t* gfortran.dg/proc_decl_4.f90: New.\n+\n 2007-09-04  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.dg/vect/vect-reduc-dot-s16b.c: Mark functions noinline."}, {"sha": "2070b2ae21ca8b551ab2d93ffa2d0c377fef3768", "filename": "gcc/testsuite/gfortran.dg/proc_decl_1.f90", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_1.f90?ref=6977374226b230fe6e6d9b5ce2615bea094cb0f1", "patch": "@@ -0,0 +1,77 @@\n+! { dg-do compile }\n+! This tests various error messages for PROCEDURE declarations.\n+! Contributed by Janus Weil <jaydub66@gmail.com>\n+\n+module m\n+\n+  abstract interface\n+    subroutine sub()\n+    end subroutine\n+    subroutine sub2() bind(c)\n+    end subroutine\n+  end interface\n+\n+  procedure(), public, private :: a  ! { dg-error \"was already specified\" }\n+  procedure(sub),bind(C) :: a2  ! { dg-error \"requires an interface with BIND.C.\" }\n+  procedure(sub2), public, bind(c, name=\"myEF\") :: e, f  ! { dg-error \"Multiple identifiers provided with single NAME= specifier\" }\n+  procedure(sub2), bind(C, name=\"\"), pointer :: g  ! { dg-error \"may not have POINTER attribute\" }\n+\n+  public:: h\n+  procedure(),public:: h  ! { dg-error \"was already specified\" }\n+\n+end module m\n+\n+\n+program prog\n+\n+  interface z\n+    subroutine z1()\n+    end subroutine\n+    subroutine z2(a)\n+      integer :: a\n+    end subroutine\n+  end interface\n+\n+  procedure(z) :: bar   ! { dg-error \"may not be generic\" }\n+\n+  procedure(), allocatable:: b  ! { dg-error \"PROCEDURE attribute conflicts with ALLOCATABLE attribute\" }\n+  procedure(), save:: c  ! { dg-error \"PROCEDURE attribute conflicts with SAVE attribute\" }\n+\n+  procedure(dcos) :: my1  ! { dg-error \"PROCEDURE statement at .1. not yet implemented\" }\n+  procedure(amax0) :: my2  ! { dg-error \"not allowed in PROCEDURE statement\" }\n+\n+  procedure(),pointer:: ptr  ! { dg-error \"not yet implemented\" }\n+\n+  type t\n+    procedure(),pointer:: p  ! { dg-error \"not yet implemented\" }\n+  end type\n+\n+  real f, x\n+  f(x) = sin(x**2)\n+  external oo\n+\n+  procedure(f) :: q  ! { dg-error \"may not be a statement function\" }\n+  procedure(oo) :: p  ! { dg-error \"must be explicit\" }\n+\n+contains\n+\n+  subroutine foo(a,c)\n+    abstract interface\n+      subroutine b() bind(C)\n+      end subroutine b\n+    end interface\n+    procedure(b), bind(c,name=\"hjj\") :: a  ! { dg-error \"may not have BIND.C. attribute with NAME\" }\n+    procedure(c),intent(in):: c  ! { dg-error \"PROCEDURE attribute conflicts with INTENT attribute\" }\n+  end subroutine foo \n+\n+end program\n+\n+\n+subroutine abc\n+\n+ procedure() :: abc2\n+\n+entry abc2(x)  ! { dg-error \"PROCEDURE attribute conflicts with ENTRY attribute\" }\n+ real x\n+\n+end subroutine"}, {"sha": "6edc6bd42b37f5886410f96eef5c59a6452a832b", "filename": "gcc/testsuite/gfortran.dg/proc_decl_2.f90", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_2.f90?ref=6977374226b230fe6e6d9b5ce2615bea094cb0f1", "patch": "@@ -0,0 +1,128 @@\n+! { dg-do run }\n+! Various runtime tests of PROCEDURE declarations.\n+! Contributed by Janus Weil <jaydub66@gmail.com>\n+\n+module m\n+\n+  abstract interface\n+    subroutine csub() bind(c)\n+    end subroutine csub\n+  end interface\n+\n+  procedure():: mp1\n+  procedure(real), private:: mp2\n+  procedure(mfun), public:: mp3\n+  procedure(csub), public, bind(c) :: c, d\n+  procedure(csub), public, bind(c, name=\"myB\") :: b\n+\n+contains\n+\n+  real function mfun(x,y)\n+    real x,y\n+    mfun=4.2\n+  end function\n+\n+  subroutine bar(a,b)\n+    implicit none\n+    interface\n+      subroutine a()\n+      end subroutine a\n+    end interface\n+    optional ::  a\n+    procedure(a), optional :: b\n+  end subroutine bar\n+\n+end module\n+\n+\n+program p\n+  implicit none\n+\n+  abstract interface\n+    subroutine abssub(x)\n+      real x\n+    end subroutine\n+  end interface\n+\n+  integer i\n+  real r\n+\n+  procedure(integer):: p1\n+  procedure(fun):: p2\n+  procedure(abssub):: p3\n+  procedure(sub):: p4\n+  procedure():: p5\n+  procedure(p4):: p6\n+  procedure(integer) :: p7\n+\n+  i=p1()\n+  if (i /= 5) call abort()\n+  i=p2(3.1)\n+  if (i /= 3) call abort()\n+  r=4.2\n+  call p3(r)\n+  if (abs(r-5.2)>1e-6) call abort()\n+  call p4(r)\n+  if (abs(r-3.7)>1e-6) call abort()\n+  call p5()\n+  call p6(r)\n+  if (abs(r-7.4)>1e-6) call abort()\n+  i=p7(4)\n+  if (i /= -8) call abort()\n+  r=dummytest(p3)\n+  if (abs(r-2.1)>1e-6) call abort()\n+\n+contains\n+\n+  integer function fun(x)\n+    real x\n+    fun=7\n+  end function\n+\n+  subroutine sub(x)\n+    real x\n+  end subroutine\n+\n+  real function dummytest(dp)\n+    procedure(abssub):: dp\n+    real y\n+    y=1.1\n+    call dp(y)\n+    dummytest=y\n+  end function\n+\n+end program p\n+\n+\n+integer function p1()\n+  p1 = 5\n+end function\n+\n+integer function p2(x)\n+  real x\n+  p2 = int(x)\n+end function\n+\n+subroutine p3(x)\n+  real,intent(inout):: x\n+  x=x+1.0\n+end subroutine\n+\n+subroutine p4(x)\n+  real,intent(inout):: x\n+  x=x-1.5\n+end subroutine\n+\n+subroutine p5()\n+end subroutine\n+\n+subroutine p6(x)\n+  real,intent(inout):: x\n+  x=x*2.\n+end subroutine\n+\n+function p7(x)\n+ implicit none\n+ integer :: x, p7\n+ p7 = x*(-2)\n+end function"}, {"sha": "5ee8a9117582757f9d5fc8a40fe1b064cba0d802", "filename": "gcc/testsuite/gfortran.dg/proc_decl_3.f90", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_3.f90?ref=6977374226b230fe6e6d9b5ce2615bea094cb0f1", "patch": "@@ -0,0 +1,75 @@\n+! { dg-do compile }\n+! Some tests for PROCEDURE declarations inside of interfaces.\n+! Contributed by Janus Weil <jaydub66@gmail.com>\n+\n+module m\n+\n+  interface\n+    subroutine a()\n+    end subroutine a\n+  end interface\n+\n+  procedure(c) :: f\n+\n+  interface bar\n+    procedure a,d\n+  end interface bar\n+\n+  interface foo\n+    procedure c\n+  end interface foo\n+\n+  abstract interface\n+    procedure f  ! { dg-error \"must be in a generic interface\" }\n+  end interface\n+\n+  interface\n+    function opfoo(a)\n+      integer,intent(in) :: a\n+      integer :: opfoo\n+    end function opfoo\n+  end interface\n+\n+  interface operator(.op.)\n+    procedure opfoo\n+  end interface\n+\n+  external ex  ! { dg-error \"has no explicit interface\" }\n+  procedure():: ip  ! { dg-error \"has no explicit interface\" }\n+  procedure(real):: pip  ! { dg-error \"has no explicit interface\" }\n+\n+  interface nn1\n+    procedure ex\n+    procedure a, a  ! { dg-error \"already present in the interface\" }\n+  end interface\n+\n+  interface nn2\n+    procedure ip\n+  end interface\n+\n+  interface nn3\n+    procedure pip\n+  end interface\n+\n+contains\n+\n+ subroutine d(x)\n+\n+   interface\n+     subroutine x()\n+     end subroutine x\n+   end interface\n+\n+   interface gen\n+     procedure x\n+   end interface\n+\n+ end subroutine d\n+\n+ function c(x)\n+   integer :: x\n+   real :: c\n+   c = 3.4*x\n+ end function c\n+\n+end module m"}, {"sha": "fa133d45e92ee5873fbb4b63360abc83d033897c", "filename": "gcc/testsuite/gfortran.dg/proc_decl_4.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6977374226b230fe6e6d9b5ce2615bea094cb0f1/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_4.f90?ref=6977374226b230fe6e6d9b5ce2615bea094cb0f1", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+! Test for PROCEDURE statements with the -std=f95 flag.\n+! Contributed by Janus Weil <jaydub66@gmail.com>\n+\n+program p\n+\n+procedure():: proc  ! { dg-error \"Fortran 2003: PROCEDURE statement\" }\n+\n+end program "}]}