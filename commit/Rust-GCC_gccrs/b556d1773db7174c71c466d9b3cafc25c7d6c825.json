{"sha": "b556d1773db7174c71c466d9b3cafc25c7d6c825", "node_id": "C_kwDOANBUbNoAKGI1NTZkMTc3M2RiNzE3NGM3MWM0NjZkOWIzY2FmYzI1YzdkNmM4MjU", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2022-11-12T17:03:21Z"}, "committer": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2022-11-12T17:03:21Z"}, "message": "c: C2x constexpr\n\nImplement C2x constexpr (a feature based on the C++ one but much more\nminimal, with only constexpr variables, not functions).\n\nI believe this implementation is fully functional for use of this\nfeature.  However, there are several things that seem unclear about\nthe specification that I'll need to raise in NB comments.  There are\nalso areas where there may be followup bug fixes because the\nimplementation doesn't reject some more obscure cases that ought to be\nrejected: cases where a constexpr initializer for floating type meets\nthe constraints for a constant expression in initializers but not\nthose for an arithmetic constant expression (previously we haven't had\nto track whether something is an arithmetic constant expression in\ndetail, unlike with integer constant expressions), and some cases\nwhere a tag or struct or union member gets declared indirectly in the\ndeclaration specifiers or declarator of a constexpr declaration, which\nis not permitted (modulo lack of clarity in the specification) for\nunderspecified declarations in general (the cases of a declaration in\nthe initializer, or a tagged type being directly declared as a type\nspecifier, are already detected).\n\nCases of ambiguity in the specification include:\n\n* Many questions (previously raised in WG14 discussions) over the rule\n  about what conversions do or do not involve a change of value that's\n  not allowed in a constexpr initializer, that aren't properly\n  addressed by the normative text (and where the footnote on the\n  subject isn't very clear either, and the examples don't necessarily\n  follow from the normative text).  I've made a series of choices\n  there, that include disallowing all conversions between real and\n  complex types or between binary and decimal floating types in\n  constexpr initializers, that might not necessarily agree with how\n  things end up getting clarified.\n\n  The dfp.cc change also arises here, to allow quiet NaN initializers\n  of one DFP type to be used in a constexpr initializer for another\n  DFP type (as is possible for signaling NaNs) by ensuring the result\n  of such a conversion is properly marked as canonical (note that most\n  of the DFP code doesn't actually do anything with NaN payloads at\n  all).\n\n* Various issues with what exactly counts as part of a declaration for\n  the purposes of the rule on underspecified declarations not\n  declaring any identifiers other than ordinary identifiers (and not\n  declaring more than one ordinary identifier, though the latter is\n  undefined behavior).  These include cases where the declaration of a\n  struct / union / enum type appears inside typeof or alignas in the\n  declaration specifiers (the latter also applies with auto), or in\n  the declarator (e.g. an array size or in a parameter declaration).\n  The issues are similar to those involved in C90 DR#115 and C99 DRs\n  #277 and #341; the intent may not be the same in all the different\n  cases involved, but it's not clear that the normative wording in the\n  various places is sufficient to deduce the differences in intent.\n\n* The wording about producing a compound literal constant using member\n  access is present in one place but another place only applies that\n  to named constants.\n\n* It's not clear when a structure or union constant (a constexpr\n  variable or compound literal with structure or union type, or a\n  member with such type extracted by a series of member access\n  operations) can itself be used in an initializer (constexpr or\n  otherwise).  Based on general wording for initializers not having\n  been changed, the working draft might only strictly allow it at\n  automatic storage duration (but elsewhere it would be undefined\n  behavior, not a constraint violation, so no diagnostic required) -\n  since that's the only case mentioned where a single expression of\n  structure or union type can be used to initialize an object of such\n  a type.  But it definitely seems to be allowed in even constexpr\n  initializers at automatic storage duration - and since generally\n  constexpr initializers (any storage duration) are *more* constrained\n  than ordinary static storage duration initializers, it would seem\n  odd for it not to be allowed at static storage duration.\n\n* When you do allow such initializers, it's then not entirely clear\n  how the constraint that constexpr pointer initializers must be null\n  pointer constants should be applied (given that a constexpr object\n  of pointer type is a null pointer but *not* a null pointer\n  constant).  My guess would be that a constexpr struct or union\n  containing such a field should still be allowed as an initializer,\n  but the wording could be read otherwise.\n\n* It also becomes important with constexpr exactly what kind of\n  constant expression an implicit zero initializer is; the wording for\n  default initialization only really deals with the value of the\n  initializer and not what kind of constant it is.  In particular,\n  this affects whether {} is a valid constexpr initializer for a\n  pointer not of type void *, since the wording only talks about a\n  null pointer, not whether it's a null pointer *constant*.  I assumed\n  that it should be a null pointer constant in that case.\n\n* It's also not entirely clear whether constexpr can be used in the\n  declaration part of a for loop (which \"shall only declare\n  identifiers for objects having storage class auto or register\").  I\n  interpreted it as allowed (treating such objects as implicitly auto\n  just like those with no storage class specifiers), but it could also\n  be argued that constexpr is another storage class specifier and so\n  not allowed there.\n\nBootstrapped with no regressions for x86_64-pc-linux-gnu.\n\ngcc/\n\t* dfp.cc (decimal_from_binary): Convert a canonical NaN to a\n\tcanonical NaN.\n\ngcc/c-family/\n\t* c-common.cc (c_common_reswords): Use D_C2X instead of D_CXXONLY.\n\ngcc/c/\n\t* c-decl.cc (start_underspecified_init)\n\t(finish_underspecified_init): Handle name == NULL_TREE for\n\tcompound literals.\n\t(merge_decls): Merge C_DECL_DECLARED_CONSTEXPR.\n\t(shadow_tag_warned): Check for constexpr.\n\t(start_decl): Add parameter do_push.\n\t(build_compound_literal): Set C_DECL_DECLARED_CONSTEXPR.\n\t(grokdeclarator): Handle constexpr.\n\t(finish_struct): Set C_TYPE_FIELDS_NON_CONSTEXPR.\n\t(declspecs_add_scspec): Handle constexpr.\n\t* c-parser.cc (c_token_starts_compound_literal)\n\t(c_token_starts_declspecs, c_parser_declaration_or_fndef)\n\t(c_parser_declspecs, c_parser_gnu_attribute_any_word)\n\t(c_parser_compound_literal_scspecs)\n\t(c_parser_postfix_expression_after_paren_type): Handle constexpr.\n\tUpdate calls to start_init.\n\t(c_parser_declaration_or_fndef, c_parser_initializer)\n\t(c_parser_initval): Pass true for new argument of\n\tconvert_lvalue_to_rvalue.  Call convert_lvalue_to_rvalue for\n\tconstexpr compound literals.\n\t(c_parser_static_assert_declaration_no_semi)\n\t(c_parser_enum_specifier, c_parser_struct_declaration)\n\t(c_parser_alignas_specifier, c_parser_initelt, c_parser_label):\n\tCall convert_lvalue_to_rvalue on expressions required to be\n\tinteger constant expressions.\n\t(c_parser_omp_declare_reduction): Update call to start_init.\n\t* c-tree.h (C_TYPE_FIELDS_NON_CONSTEXPR)\n\t(C_DECL_DECLARED_CONSTEXPR): New macros.\n\t(struct c_declspecs): Add constexpr_p.\n\t(start_decl, convert_lvalue_to_rvalue, start_init): Update\n\tprototypes.\n\t* c-typeck.cc (require_constant_value, require_constant_elements):\n\tChange to bool.\n\t(require_constexpr_value, maybe_get_constexpr_init)\n\t(constexpr_init_fits_real_type, check_constexpr_init): New.\n\t(convert_lvalue_to_rvalue): Add new parameter for_init.  Call\n\tmaybe_get_constexpr_init.\n\t(store_init_value): Update call to digest_init.\n\t(digest_init): Add parameters int_const_expr, arith_const_expr and\n\trequire_constexpr.  Check constexpr initializers.\n\t(constructor_top_level): Remove.\n\t(struct initializer_stack): Remove top_level.  Add\n\trequire_constexpr_value.\n\t(start_init): Remove parameter top_level.  Add parameters\n\tinit_require_constant and init_require_constexpr.  Save\n\trequire_constexpr_value on stack.\n\t(pop_init_level): Use a null pointer constant for zero initializer\n\tof pointer initialized with {}.\n\t(output_init_element): Update call to digest_init.  Avoid passing\n\tnull pointer constants of pointer type through digest_init a\n\tsecond time when initializing a constexpr object.\n\ngcc/testsuite/\n\t* gcc.dg/c11-keywords-1.c: Also test constexpr.\n\t* gcc.dg/c2x-constexpr-1.c, gcc.dg/c2x-constexpr-2a.c,\n\tgcc.dg/c2x-constexpr-2b.c, gcc.dg/c2x-constexpr-3.c,\n\tgcc.dg/c2x-constexpr-4.c, gcc.dg/c2x-constexpr-5.c,\n\tgcc.dg/c2x-constexpr-6.c, gcc.dg/c2x-constexpr-7.c,\n\tgcc.dg/c2x-constexpr-8.c, gcc.dg/c2x-constexpr-9.c,\n\tgcc.dg/dfp/c2x-constexpr-dfp-1.c,\n\tgcc.dg/dfp/c2x-constexpr-dfp-2.c, gcc.dg/gnu2x-constexpr-1.c,\n\tgcc.target/i386/excess-precision-11.c,\n\tgcc.target/i386/excess-precision-12.c: New tests.", "tree": {"sha": "b8d88b114a9e5eb1e143544124c477da19aaa5f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8d88b114a9e5eb1e143544124c477da19aaa5f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b556d1773db7174c71c466d9b3cafc25c7d6c825", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b556d1773db7174c71c466d9b3cafc25c7d6c825", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b556d1773db7174c71c466d9b3cafc25c7d6c825", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b556d1773db7174c71c466d9b3cafc25c7d6c825/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f232715d15618e91c90eb210e23de10909590944", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f232715d15618e91c90eb210e23de10909590944", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f232715d15618e91c90eb210e23de10909590944"}], "stats": {"total": 1636, "additions": 1539, "deletions": 97}, "files": [{"sha": "71507d4cb0a9f93087e149da4a410560b5db6852", "filename": "gcc/c-family/c-common.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Fc-family%2Fc-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Fc-family%2Fc-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.cc?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -440,7 +440,7 @@ const struct c_common_resword c_common_reswords[] =\n   { \"class\",\t\tRID_CLASS,\tD_CXX_OBJC | D_CXXWARN },\n   { \"const\",\t\tRID_CONST,\t0 },\n   { \"consteval\",\tRID_CONSTEVAL,\tD_CXXONLY | D_CXX20 | D_CXXWARN },\n-  { \"constexpr\",\tRID_CONSTEXPR,\tD_CXXONLY | D_CXX11 | D_CXXWARN },\n+  { \"constexpr\",\tRID_CONSTEXPR,\tD_C2X | D_CXX11 | D_CXXWARN },\n   { \"constinit\",\tRID_CONSTINIT,\tD_CXXONLY | D_CXX20 | D_CXXWARN },\n   { \"const_cast\",\tRID_CONSTCAST,\tD_CXXONLY | D_CXXWARN },\n   { \"continue\",\t\tRID_CONTINUE,\t0 },"}, {"sha": "36de77814baa4786afe1f7a6c500b4589b4ca74d", "filename": "gcc/c/c-decl.cc", "status": "modified", "additions": 126, "deletions": 27, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Fc%2Fc-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Fc%2Fc-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.cc?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -1480,26 +1480,34 @@ static bool in_underspecified_init;\n    means that NAME is shadowed inside its initializer, so neither the\n    definition being initialized, nor any definition from an outer\n    scope, may be referenced during that initializer.  Return state to\n-   be passed to finish_underspecified_init.  */\n+   be passed to finish_underspecified_init.  If NAME is NULL_TREE, the\n+   underspecified object is a (constexpr) compound literal; there is\n+   no shadowing in that case, but all the other restrictions on\n+   underspecified object definitions still apply.  */\n unsigned int\n start_underspecified_init (location_t loc, tree name)\n {\n   bool prev = in_underspecified_init;\n   bool ok;\n-  tree decl = build_decl (loc, VAR_DECL, name, error_mark_node);\n-  C_DECL_UNDERSPECIFIED (decl) = 1;\n-  struct c_scope *scope = current_scope;\n-  struct c_binding *b = I_SYMBOL_BINDING (name);\n-  if (b && B_IN_SCOPE (b, scope))\n-    {\n-      error_at (loc, \"underspecified declaration of %qE, which is already \"\n-\t\t\"declared in this scope\", name);\n-      ok = false;\n-    }\n+  if (name == NULL_TREE)\n+    ok = true;\n   else\n     {\n-      bind (name, decl, scope, false, false, loc);\n-      ok = true;\n+      tree decl = build_decl (loc, VAR_DECL, name, error_mark_node);\n+      C_DECL_UNDERSPECIFIED (decl) = 1;\n+      struct c_scope *scope = current_scope;\n+      struct c_binding *b = I_SYMBOL_BINDING (name);\n+      if (b && B_IN_SCOPE (b, scope))\n+\t{\n+\t  error_at (loc, \"underspecified declaration of %qE, which is already \"\n+\t\t    \"declared in this scope\", name);\n+\t  ok = false;\n+\t}\n+      else\n+\t{\n+\t  bind (name, decl, scope, false, false, loc);\n+\t  ok = true;\n+\t}\n     }\n   in_underspecified_init = true;\n   return ok | (prev << 1);\n@@ -1508,11 +1516,12 @@ start_underspecified_init (location_t loc, tree name)\n /* Finish an underspecified object definition for NAME, before that\n    name is bound to the real declaration instead of a placeholder.\n    PREV_STATE is the value returned by the call to\n-   start_underspecified_init.  */\n+   start_underspecified_init.  If NAME is NULL_TREE, this means a\n+   compound literal, as for start_underspecified_init.  */\n void\n finish_underspecified_init (tree name, unsigned int prev_state)\n {\n-  if (prev_state & 1)\n+  if (name != NULL_TREE && (prev_state & 1))\n     {\n       /* A VAR_DECL was bound to the name to shadow any previous\n \t declarations for the name; remove that binding now.  */\n@@ -2745,6 +2754,15 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n    if (DECL_INITIAL (newdecl) == NULL_TREE)\n     DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n \n+  /* Merge 'constexpr' information.  */\n+  if (VAR_P (olddecl) && VAR_P (newdecl))\n+    {\n+      if (C_DECL_DECLARED_CONSTEXPR (olddecl))\n+\tC_DECL_DECLARED_CONSTEXPR (newdecl) = 1;\n+      else if (C_DECL_DECLARED_CONSTEXPR (newdecl))\n+\tC_DECL_DECLARED_CONSTEXPR (olddecl) = 1;\n+    }\n+\n   /* Merge the threadprivate attribute.  */\n   if (VAR_P (olddecl) && C_DECL_THREADPRIVATE_P (olddecl))\n     C_DECL_THREADPRIVATE_P (newdecl) = 1;\n@@ -4944,6 +4962,12 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n       warned = 1;\n     }\n \n+  if (declspecs->constexpr_p)\n+    {\n+      error (\"%<constexpr%> in empty declaration\");\n+      warned = 1;\n+    }\n+\n   if (current_scope == file_scope && declspecs->storage_class == csc_auto)\n     {\n       error (\"%<auto%> in file-scope empty declaration\");\n@@ -5301,7 +5325,7 @@ c_decl_attributes (tree *node, tree attributes, int flags)\n    This is called as soon as the type information and variable name\n    have been parsed, before parsing the initializer if any.\n    Here we create the ..._DECL node, fill in its type,\n-   and put it on the list of decls for the current context.\n+   and (if DO_PUSH) put it on the list of decls for the current context.\n    When nonnull, set *LASTLOC to the location of the prior declaration\n    of the same entity if one exists.\n    The ..._DECL node is returned as the value.\n@@ -5316,7 +5340,8 @@ c_decl_attributes (tree *node, tree attributes, int flags)\n \n tree\n start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n-\t    bool initialized, tree attributes, location_t *lastloc /* = NULL */)\n+\t    bool initialized, tree attributes, bool do_push /* = true */,\n+\t    location_t *lastloc /* = NULL */)\n {\n   tree decl;\n   tree tem;\n@@ -5489,15 +5514,20 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n \n   /* Add this decl to the current scope.\n      TEM may equal DECL or it may be a previous decl of the same name.  */\n-  tem = pushdecl (decl);\n-\n-  if (initialized && DECL_EXTERNAL (tem))\n+  if (do_push)\n     {\n-      DECL_EXTERNAL (tem) = 0;\n-      TREE_STATIC (tem) = 1;\n-    }\n+      tem = pushdecl (decl);\n+\n+      if (initialized && DECL_EXTERNAL (tem))\n+\t{\n+\t  DECL_EXTERNAL (tem) = 0;\n+\t  TREE_STATIC (tem) = 1;\n+\t}\n \n-  return tem;\n+      return tem;\n+    }\n+  else\n+    return decl;\n }\n \n /* Subroutine of finish_decl. TYPE is the type of an uninitialized object\n@@ -6214,6 +6244,7 @@ build_compound_literal (location_t loc, tree type, tree init, bool non_const,\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_IGNORED_P (decl) = 1;\n   C_DECL_COMPOUND_LITERAL_P (decl) = 1;\n+  C_DECL_DECLARED_CONSTEXPR (decl) = scspecs && scspecs->constexpr_p;\n   TREE_TYPE (decl) = type;\n   if (threadp)\n     set_decl_tls_model (decl, decl_default_tls_model (decl));\n@@ -6501,6 +6532,7 @@ grokdeclarator (const struct c_declarator *declarator,\n {\n   tree type = declspecs->type;\n   bool threadp = declspecs->thread_p;\n+  bool constexprp = declspecs->constexpr_p;\n   enum c_storage_class storage_class = declspecs->storage_class;\n   int constp;\n   int restrictp;\n@@ -6743,6 +6775,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \n   if (funcdef_flag\n       && (threadp\n+\t  || constexprp\n \t  || storage_class == csc_auto\n \t  || storage_class == csc_register\n \t  || storage_class == csc_typedef))\n@@ -6759,17 +6792,22 @@ grokdeclarator (const struct c_declarator *declarator,\n \terror_at (loc, \"function definition declared %qs\",\n \t\t  declspecs->thread_gnu_p ? \"__thread\" : \"_Thread_local\");\n       threadp = false;\n+      /* The parser ensures a constexpr function definition never\n+\t reaches here.  */\n+      gcc_assert (!constexprp);\n       if (storage_class == csc_auto\n \t  || storage_class == csc_register\n \t  || storage_class == csc_typedef)\n \tstorage_class = csc_none;\n     }\n   else if (decl_context != NORMAL && (storage_class != csc_none\n \t\t\t\t      || threadp\n+\t\t\t\t      || constexprp\n \t\t\t\t      || declspecs->c2x_auto_p))\n     {\n       if (decl_context == PARM\n \t  && storage_class == csc_register\n+\t  && !constexprp\n \t  && !declspecs->c2x_auto_p)\n \t;\n       else\n@@ -6796,6 +6834,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    }\n \t  storage_class = csc_none;\n \t  threadp = false;\n+\t  constexprp = false;\n \t}\n     }\n   else if (storage_class == csc_extern\n@@ -7843,7 +7882,7 @@ grokdeclarator (const struct c_declarator *declarator,\n       }\n     else if (TREE_CODE (type) == FUNCTION_TYPE)\n       {\n-\tif (storage_class == csc_register || threadp)\n+\tif (storage_class == csc_register || threadp || constexprp)\n \t  {\n \t    error_at (loc, \"invalid storage class for function %qE\", name);\n \t  }\n@@ -7943,6 +7982,32 @@ grokdeclarator (const struct c_declarator *declarator,\n \t/* An uninitialized decl with `extern' is a reference.  */\n \tint extern_ref = !initialized && storage_class == csc_extern;\n \n+\tif (constexprp)\n+\t  {\n+\t    /* The type of a constexpr variable must not be variably\n+\t       modified, volatile, atomic or restrict qualified or\n+\t       have a member with such a qualifier.  const\n+\t       qualification is implicitly added, and, at file scope,\n+\t       has internal linkage.  */\n+\t    if (variably_modified_type_p (type, NULL_TREE))\n+\t      error_at (loc, \"%<constexpr%> object has variably modified \"\n+\t\t\t\"type\");\n+\t    if (type_quals\n+\t\t& (TYPE_QUAL_VOLATILE | TYPE_QUAL_RESTRICT | TYPE_QUAL_ATOMIC))\n+\t      error_at (loc, \"invalid qualifiers for %<constexpr%> object\");\n+\t    else\n+\t      {\n+\t\ttree type_no_array = strip_array_types (type);\n+\t\tif (RECORD_OR_UNION_TYPE_P (type_no_array)\n+\t\t    && C_TYPE_FIELDS_NON_CONSTEXPR (type_no_array))\n+\t\t  error_at (loc, \"invalid qualifiers for field of \"\n+\t\t\t    \"%<constexpr%> object\");\n+\t      }\n+\t    type_quals |= TYPE_QUAL_CONST;\n+\t    if (current_scope == file_scope)\n+\t      storage_class = csc_static;\n+\t  }\n+\n \ttype = c_build_qualified_type (type, type_quals, orig_qual_type,\n \t\t\t\t       orig_qual_indirect);\n \n@@ -7969,6 +8034,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t\t   VAR_DECL, declarator->u.id.id, type);\n \tif (size_varies)\n \t  C_DECL_VARIABLE_SIZE (decl) = 1;\n+\tif (constexprp)\n+\t  C_DECL_DECLARED_CONSTEXPR (decl) = 1;\n \n \tif (declspecs->inline_p)\n \t  pedwarn (loc, 0, \"variable %q+D declared %<inline%>\", decl);\n@@ -9119,21 +9186,32 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n \n       DECL_CONTEXT (x) = t;\n \n+      tree t1 = strip_array_types (TREE_TYPE (x));\n       /* If any field is const, the structure type is pseudo-const.  */\n       if (TREE_READONLY (x))\n \tC_TYPE_FIELDS_READONLY (t) = 1;\n       else\n \t{\n \t  /* A field that is pseudo-const makes the structure likewise.  */\n-\t  tree t1 = strip_array_types (TREE_TYPE (x));\n \t  if (RECORD_OR_UNION_TYPE_P (t1) && C_TYPE_FIELDS_READONLY (t1))\n \t    C_TYPE_FIELDS_READONLY (t) = 1;\n \t}\n \n       /* Any field that is volatile means variables of this type must be\n \t treated in some ways as volatile.  */\n       if (TREE_THIS_VOLATILE (x))\n-\tC_TYPE_FIELDS_VOLATILE (t) = 1;\n+\t{\n+\t  C_TYPE_FIELDS_VOLATILE (t) = 1;\n+\t  C_TYPE_FIELDS_NON_CONSTEXPR (t) = 1;\n+\t}\n+\n+      /* Any field that is volatile, restrict-qualified or atomic\n+\t means the type cannot be used for a constexpr object.  */\n+      if (TYPE_QUALS (t1)\n+\t  & (TYPE_QUAL_VOLATILE | TYPE_QUAL_RESTRICT | TYPE_QUAL_ATOMIC))\n+\tC_TYPE_FIELDS_NON_CONSTEXPR (t) = 1;\n+      else if (RECORD_OR_UNION_TYPE_P (t1) && C_TYPE_FIELDS_NON_CONSTEXPR (t1))\n+\t    C_TYPE_FIELDS_NON_CONSTEXPR (t) = 1;\n \n       /* Any field of nominal variable size implies structure is too.  */\n       if (C_DECL_VARIABLE_SIZE (x))\n@@ -9335,6 +9413,7 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n       TYPE_TRANSPARENT_AGGR (x) = TYPE_TRANSPARENT_AGGR (t);\n       C_TYPE_FIELDS_READONLY (x) = C_TYPE_FIELDS_READONLY (t);\n       C_TYPE_FIELDS_VOLATILE (x) = C_TYPE_FIELDS_VOLATILE (t);\n+      C_TYPE_FIELDS_NON_CONSTEXPR (x) = C_TYPE_FIELDS_NON_CONSTEXPR (t);\n       C_TYPE_VARIABLE_SIZE (x) = C_TYPE_VARIABLE_SIZE (t);\n       C_TYPE_INCOMPLETE_VARS (x) = NULL_TREE;\n     }\n@@ -12266,6 +12345,8 @@ declspecs_add_scspec (location_t loc,\n \terror (\"%qE used with %<register%>\", scspec);\n       else if (specs->storage_class == csc_typedef)\n \terror (\"%qE used with %<typedef%>\", scspec);\n+      else if (specs->constexpr_p)\n+\terror (\"%qE used with %<constexpr%>\", scspec);\n       else\n \t{\n \t  specs->thread_p = true;\n@@ -12323,6 +12404,18 @@ declspecs_add_scspec (location_t loc,\n \t  specs->c2x_auto_p = false;\n \t}\n       break;\n+    case RID_CONSTEXPR:\n+      dupe = specs->constexpr_p;\n+      if (specs->storage_class == csc_extern)\n+\terror (\"%qE used with %<extern%>\", scspec);\n+      else if (specs->storage_class == csc_typedef)\n+\terror (\"%qE used with %<typedef%>\", scspec);\n+      else if (specs->thread_p)\n+\terror (\"%qE used with %qs\", scspec,\n+\t       specs->thread_gnu_p ? \"__thread\" : \"_Thread_local\");\n+      else\n+\tspecs->constexpr_p = true;\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -12352,6 +12445,12 @@ declspecs_add_scspec (location_t loc,\n \t\t     scspec);\n \t      specs->thread_p = false;\n \t    }\n+\t  if (n != csc_auto && n != csc_register && n != csc_static\n+\t      && specs->constexpr_p)\n+\t    {\n+\t      error (\"%<constexpr%> used with %qE\", scspec);\n+\t      specs->constexpr_p = false;\n+\t    }\n \t}\n     }\n   return specs;"}, {"sha": "1d144bba24dfd5d44528e085ee3145a93ca88cf8", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 185, "deletions": 38, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -677,6 +677,7 @@ c_token_starts_compound_literal (c_token *token)\n     case CPP_KEYWORD:\n       switch (token->keyword)\n \t{\n+\tcase RID_CONSTEXPR:\n \tcase RID_REGISTER:\n \tcase RID_STATIC:\n \tcase RID_THREAD:\n@@ -795,6 +796,7 @@ c_token_starts_declspecs (c_token *token)\n \tcase RID_ALIGNAS:\n \tcase RID_ATOMIC:\n \tcase RID_AUTO_TYPE:\n+\tcase RID_CONSTEXPR:\n \t  return true;\n \tdefault:\n \t  if (token->keyword >= RID_FIRST_INT_N\n@@ -2108,6 +2110,32 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n   bool any_auto_type_p = gnu_auto_type_p || std_auto_type_p;\n   gcc_assert (!(gnu_auto_type_p && std_auto_type_p));\n   const char *auto_type_keyword = gnu_auto_type_p ? \"__auto_type\" : \"auto\";\n+  if (specs->constexpr_p)\n+    {\n+      /* An underspecified declaration may not declare tags or members\n+\t or structures or unions; it is undefined behavior to declare\n+\t the members of an enumeration.  Where the structure, union or\n+\t enumeration type is declared within an initializer, this is\n+\t diagnosed elsewhere.  Diagnose here the case of declaring\n+\t such a type in the type specifiers of a constexpr\n+\t declaration.  */\n+      switch (specs->typespec_kind)\n+\t{\n+\tcase ctsk_tagfirstref:\n+\tcase ctsk_tagfirstref_attrs:\n+\t  error_at (here, \"%qT declared in underspecified object declaration\",\n+\t\t    specs->type);\n+\t  break;\n+\n+\tcase ctsk_tagdef:\n+\t  error_at (here, \"%qT defined in underspecified object declaration\",\n+\t\t    specs->type);\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n   if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n     {\n       bool handled_assume = false;\n@@ -2257,7 +2285,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n       bool dummy = false;\n       timevar_id_t tv;\n       tree fnbody = NULL_TREE;\n-      tree std_auto_name = NULL_TREE;\n+      tree underspec_name = NULL_TREE;\n       /* Declaring either one or more declarators (in which case we\n \t should diagnose if there were no declaration specifiers) or a\n \t function definition (in which case the diagnostic for\n@@ -2296,7 +2324,14 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t      c_parser_skip_to_end_of_block_or_statement (parser);\n \t      return;\n \t    }\n-\t  std_auto_name = d->u.id.id;\n+\t  underspec_name = d->u.id.id;\n+\t}\n+      else if (specs->constexpr_p)\n+\t{\n+\t  struct c_declarator *d = declarator;\n+\t  while (d->kind != cdk_id)\n+\t    d = d->declarator;\n+\t  underspec_name = d->u.id.id;\n \t}\n       if (c_parser_next_token_is (parser, CPP_EQ)\n \t  || c_parser_next_token_is (parser, CPP_COMMA)\n@@ -2343,9 +2378,13 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t  rich_location richloc (line_table, init_loc);\n \t\t  unsigned int underspec_state = 0;\n \t\t  if (std_auto_type_p)\n-\t\t    underspec_state = start_underspecified_init (init_loc,\n-\t\t\t\t\t\t\t\t std_auto_name);\n-\t\t  start_init (NULL_TREE, asm_name, global_bindings_p (), &richloc);\n+\t\t    underspec_state =\n+\t\t      start_underspecified_init (init_loc, underspec_name);\n+\t\t  start_init (NULL_TREE, asm_name,\n+\t\t\t      (global_bindings_p ()\n+\t\t\t       || specs->storage_class == csc_static\n+\t\t\t       || specs->constexpr_p),\n+\t\t\t      specs->constexpr_p, &richloc);\n \t\t  /* A parameter is initialized, which is invalid.  Don't\n \t\t     attempt to instrument the initializer.  */\n \t\t  int flag_sanitize_save = flag_sanitize;\n@@ -2364,15 +2403,17 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t  else\n \t\t    init = c_parser_expr_no_commas (parser, NULL);\n \t\t  if (std_auto_type_p)\n-\t\t    finish_underspecified_init (std_auto_name, underspec_state);\n+\t\t    finish_underspecified_init (underspec_name,\n+\t\t\t\t\t\tunderspec_state);\n \t\t  flag_sanitize = flag_sanitize_save;\n \t\t  if (gnu_auto_type_p\n \t\t      && TREE_CODE (init.value) == COMPONENT_REF\n \t\t      && DECL_C_BIT_FIELD (TREE_OPERAND (init.value, 1)))\n \t\t    error_at (here,\n \t\t\t      \"%<__auto_type%> used with a bit-field\"\n \t\t\t      \" initializer\");\n-\t\t  init = convert_lvalue_to_rvalue (init_loc, init, true, true);\n+\t\t  init = convert_lvalue_to_rvalue (init_loc, init, true, true,\n+\t\t\t\t\t\t   true);\n \t\t  tree init_type = TREE_TYPE (init.value);\n \t\t  bool vm_type = variably_modified_type_p (init_type,\n \t\t\t\t\t\t\t   NULL_TREE);\n@@ -2417,24 +2458,42 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t      else\n \t\t{\n \t\t  /* The declaration of the variable is in effect while\n-\t\t     its initializer is parsed.  */\n+\t\t     its initializer is parsed, except for a constexpr\n+\t\t     variable.  */\n+\t\t  init_loc = c_parser_peek_token (parser)->location;\n+\t\t  rich_location richloc (line_table, init_loc);\n+\t\t  unsigned int underspec_state = 0;\n+\t\t  if (specs->constexpr_p)\n+\t\t    underspec_state =\n+\t\t      start_underspecified_init (init_loc, underspec_name);\n \t\t  d = start_decl (declarator, specs, true,\n-\t\t\t\t  chainon (postfix_attrs, all_prefix_attrs));\n+\t\t\t\t  chainon (postfix_attrs,\n+\t\t\t\t\t   all_prefix_attrs),\n+\t\t\t\t  !specs->constexpr_p);\n \t\t  if (!d)\n \t\t    d = error_mark_node;\n-\t\t  if (omp_declare_simd_clauses)\n+\t\t  if (!specs->constexpr_p && omp_declare_simd_clauses)\n \t\t    c_finish_omp_declare_simd (parser, d, NULL_TREE,\n \t\t\t\t\t       omp_declare_simd_clauses);\n-\t\t  init_loc = c_parser_peek_token (parser)->location;\n-\t\t  rich_location richloc (line_table, init_loc);\n-\t\t  start_init (d, asm_name, global_bindings_p (), &richloc);\n+\t\t  start_init (d, asm_name,\n+\t\t\t      TREE_STATIC (d) || specs->constexpr_p,\n+\t\t\t      specs->constexpr_p, &richloc);\n \t\t  /* A parameter is initialized, which is invalid.  Don't\n \t\t     attempt to instrument the initializer.  */\n \t\t  int flag_sanitize_save = flag_sanitize;\n \t\t  if (TREE_CODE (d) == PARM_DECL)\n \t\t    flag_sanitize = 0;\n \t\t  init = c_parser_initializer (parser, d);\n \t\t  flag_sanitize = flag_sanitize_save;\n+\t\t  if (specs->constexpr_p)\n+\t\t    {\n+\t\t      finish_underspecified_init (underspec_name,\n+\t\t\t\t\t\t  underspec_state);\n+\t\t      d = pushdecl (d);\n+\t\t      if (omp_declare_simd_clauses)\n+\t\t\tc_finish_omp_declare_simd (parser, d, NULL_TREE,\n+\t\t\t\t\t\t   omp_declare_simd_clauses);\n+\t\t    }\n \t\t  finish_init ();\n \t\t}\n \t      if (oacc_routine_data)\n@@ -2448,18 +2507,19 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t    }\n \t  else\n \t    {\n-\t      if (any_auto_type_p)\n+\t      if (any_auto_type_p || specs->constexpr_p)\n \t\t{\n \t\t  error_at (here,\n \t\t\t    \"%qs requires an initialized data declaration\",\n-\t\t\t    auto_type_keyword);\n+\t\t\t    any_auto_type_p ? auto_type_keyword : \"constexpr\");\n \t\t  c_parser_skip_to_end_of_block_or_statement (parser);\n \t\t  return;\n \t\t}\n \n \t      location_t lastloc = UNKNOWN_LOCATION;\n \t      tree attrs = chainon (postfix_attrs, all_prefix_attrs);\n-\t      tree d = start_decl (declarator, specs, false, attrs, &lastloc);\n+\t      tree d = start_decl (declarator, specs, false, attrs, true,\n+\t\t\t\t   &lastloc);\n \t      if (d && TREE_CODE (d) == FUNCTION_DECL)\n \t\t{\n \t\t  /* Find the innermost declarator that is neither cdk_id\n@@ -2540,11 +2600,11 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t    }\n \t  if (c_parser_next_token_is (parser, CPP_COMMA))\n \t    {\n-\t      if (any_auto_type_p)\n+\t      if (any_auto_type_p || specs->constexpr_p)\n \t\t{\n \t\t  error_at (here,\n \t\t\t    \"%qs may only be used with a single declarator\",\n-\t\t\t    auto_type_keyword);\n+\t\t\t    any_auto_type_p ? auto_type_keyword : \"constexpr\");\n \t\t  c_parser_skip_to_end_of_block_or_statement (parser);\n \t\t  return;\n \t\t}\n@@ -2577,11 +2637,11 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t      return;\n \t    }\n \t}\n-      else if (any_auto_type_p)\n+      else if (any_auto_type_p || specs->constexpr_p)\n \t{\n \t  error_at (here,\n \t\t    \"%qs requires an initialized data declaration\",\n-\t\t    auto_type_keyword);\n+\t\t    any_auto_type_p ? auto_type_keyword : \"constexpr\");\n \t  c_parser_skip_to_end_of_block_or_statement (parser);\n \t  return;\n \t}\n@@ -2789,7 +2849,9 @@ c_parser_static_assert_declaration_no_semi (c_parser *parser)\n   if (!parens.require_open (parser))\n     return;\n   location_t value_tok_loc = c_parser_peek_token (parser)->location;\n-  value = c_parser_expr_no_commas (parser, NULL).value;\n+  value = convert_lvalue_to_rvalue (value_tok_loc,\n+\t\t\t\t    c_parser_expr_no_commas (parser, NULL),\n+\t\t\t\t    true, true).value;\n   value_loc = EXPR_LOC_OR_LOC (value, value_tok_loc);\n   if (c_parser_next_token_is (parser, CPP_COMMA))\n     {\n@@ -3092,6 +3154,7 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \tcase RID_NORETURN:\n \tcase RID_AUTO:\n \tcase RID_THREAD:\n+\tcase RID_CONSTEXPR:\n \t  if (!scspec_ok)\n \t    goto out;\n \t  attrs_ok = true;\n@@ -3462,7 +3525,10 @@ c_parser_enum_specifier (c_parser *parser)\n \t    {\n \t      c_parser_consume_token (parser);\n \t      value_loc = c_parser_peek_token (parser)->location;\n-\t      enum_value = c_parser_expr_no_commas (parser, NULL).value;\n+\t      enum_value = convert_lvalue_to_rvalue (value_loc,\n+\t\t\t\t\t\t     (c_parser_expr_no_commas\n+\t\t\t\t\t\t      (parser, NULL)),\n+\t\t\t\t\t\t     true, true).value;\n \t    }\n \t  else\n \t    enum_value = NULL_TREE;\n@@ -3900,7 +3966,11 @@ c_parser_struct_declaration (c_parser *parser)\n \t  if (c_parser_next_token_is (parser, CPP_COLON))\n \t    {\n \t      c_parser_consume_token (parser);\n-\t      width = c_parser_expr_no_commas (parser, NULL).value;\n+\t      location_t loc = c_parser_peek_token (parser)->location;\n+\t      width = convert_lvalue_to_rvalue (loc,\n+\t\t\t\t\t\t(c_parser_expr_no_commas\n+\t\t\t\t\t\t (parser, NULL)),\n+\t\t\t\t\t\ttrue, true).value;\n \t    }\n \t  if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n \t    postfix_attrs = c_parser_gnu_attributes (parser);\n@@ -4069,7 +4139,9 @@ c_parser_alignas_specifier (c_parser * parser)\n \t\t\t\t\tfalse, true, 1);\n     }\n   else\n-    ret = c_parser_expr_no_commas (parser, NULL).value;\n+    ret = convert_lvalue_to_rvalue (loc,\n+\t\t\t\t    c_parser_expr_no_commas (parser, NULL),\n+\t\t\t\t    true, true).value;\n   parens.skip_until_found_close (parser);\n   return ret;\n }\n@@ -4817,6 +4889,7 @@ c_parser_gnu_attribute_any_word (c_parser *parser)\n \tcase RID_TRANSACTION_CANCEL:\n \tcase RID_ATOMIC:\n \tcase RID_AUTO_TYPE:\n+\tcase RID_CONSTEXPR:\n \tcase RID_INT_N_0:\n \tcase RID_INT_N_1:\n \tcase RID_INT_N_2:\n@@ -5538,8 +5611,10 @@ c_parser_initializer (c_parser *parser, tree decl)\n \t  && !warn_init_self)\n \tsuppress_warning (decl, OPT_Winit_self);\n       if (TREE_CODE (ret.value) != STRING_CST\n-\t  && TREE_CODE (ret.value) != COMPOUND_LITERAL_EXPR)\n-\tret = convert_lvalue_to_rvalue (loc, ret, true, true);\n+\t  && (TREE_CODE (ret.value) != COMPOUND_LITERAL_EXPR\n+\t      || C_DECL_DECLARED_CONSTEXPR (COMPOUND_LITERAL_EXPR_DECL\n+\t\t\t\t\t    (ret.value))))\n+\tret = convert_lvalue_to_rvalue (loc, ret, true, true, true);\n       return ret;\n     }\n }\n@@ -5685,6 +5760,7 @@ c_parser_initelt (c_parser *parser, struct obstack * braced_init_obstack)\n \t    }\n \t  else\n \t    {\n+\t      struct c_expr first_expr;\n \t      tree first, second;\n \t      location_t ellipsis_loc = UNKNOWN_LOCATION;  /* Quiet warning.  */\n \t      location_t array_index_loc = UNKNOWN_LOCATION;\n@@ -5728,11 +5804,13 @@ c_parser_initelt (c_parser *parser, struct obstack * braced_init_obstack)\n \t\t      rec = objc_get_class_reference (id);\n \t\t      goto parse_message_args;\n \t\t    }\n-\t\t  first = c_parser_expr_no_commas (parser, NULL).value;\n-\t\t  mark_exp_read (first);\n+\t\t  array_index_loc = c_parser_peek_token (parser)->location;\n+\t\t  first_expr = c_parser_expr_no_commas (parser, NULL);\n+\t\t  mark_exp_read (first_expr.value);\n \t\t  if (c_parser_next_token_is (parser, CPP_ELLIPSIS)\n \t\t      || c_parser_next_token_is (parser, CPP_CLOSE_SQUARE))\n \t\t    goto array_desig_after_first;\n+\t\t  first = first_expr.value;\n \t\t  /* Expression receiver.  So far only one part\n \t\t     without commas has been parsed; there might be\n \t\t     more of the expression.  */\n@@ -5767,14 +5845,21 @@ c_parser_initelt (c_parser *parser, struct obstack * braced_init_obstack)\n \t\t}\n \t      c_parser_consume_token (parser);\n \t      array_index_loc = c_parser_peek_token (parser)->location;\n-\t      first = c_parser_expr_no_commas (parser, NULL).value;\n-\t      mark_exp_read (first);\n+\t      first_expr = c_parser_expr_no_commas (parser, NULL);\n+\t      mark_exp_read (first_expr.value);\n \t    array_desig_after_first:\n+\t      first_expr = convert_lvalue_to_rvalue (array_index_loc,\n+\t\t\t\t\t\t     first_expr,\n+\t\t\t\t\t\t     true, true);\n+\t      first = first_expr.value;\n \t      if (c_parser_next_token_is (parser, CPP_ELLIPSIS))\n \t\t{\n \t\t  ellipsis_loc = c_parser_peek_token (parser)->location;\n \t\t  c_parser_consume_token (parser);\n-\t\t  second = c_parser_expr_no_commas (parser, NULL).value;\n+\t\t  second = convert_lvalue_to_rvalue (ellipsis_loc,\n+\t\t\t\t\t\t     (c_parser_expr_no_commas\n+\t\t\t\t\t\t      (parser, NULL)),\n+\t\t\t\t\t\t     true, true).value;\n \t\t  mark_exp_read (second);\n \t\t}\n \t      else\n@@ -5847,8 +5932,10 @@ c_parser_initval (c_parser *parser, struct c_expr *after,\n       init = c_parser_expr_no_commas (parser, after);\n       if (init.value != NULL_TREE\n \t  && TREE_CODE (init.value) != STRING_CST\n-\t  && TREE_CODE (init.value) != COMPOUND_LITERAL_EXPR)\n-\tinit = convert_lvalue_to_rvalue (loc, init, true, true);\n+\t  && (TREE_CODE (init.value) != COMPOUND_LITERAL_EXPR\n+\t      || C_DECL_DECLARED_CONSTEXPR (COMPOUND_LITERAL_EXPR_DECL\n+\t\t\t\t\t    (init.value))))\n+\tinit = convert_lvalue_to_rvalue (loc, init, true, true, true);\n     }\n   process_init_element (loc, init, false, braced_init_obstack);\n }\n@@ -6205,7 +6292,9 @@ c_parser_label (c_parser *parser, tree std_attrs)\n     {\n       tree exp1, exp2;\n       c_parser_consume_token (parser);\n-      exp1 = c_parser_expr_no_commas (parser, NULL).value;\n+      exp1 = convert_lvalue_to_rvalue (loc1,\n+\t\t\t\t       c_parser_expr_no_commas (parser, NULL),\n+\t\t\t\t       true, true).value;\n       if (c_parser_next_token_is (parser, CPP_COLON))\n \t{\n \t  c_parser_consume_token (parser);\n@@ -6214,7 +6303,10 @@ c_parser_label (c_parser *parser, tree std_attrs)\n       else if (c_parser_next_token_is (parser, CPP_ELLIPSIS))\n \t{\n \t  c_parser_consume_token (parser);\n-\t  exp2 = c_parser_expr_no_commas (parser, NULL).value;\n+\t  exp2 = convert_lvalue_to_rvalue (loc1,\n+\t\t\t\t\t   c_parser_expr_no_commas (parser,\n+\t\t\t\t\t\t\t\t    NULL),\n+\t\t\t\t\t   true, true).value;\n \t  if (c_parser_require (parser, CPP_COLON, \"expected %<:%>\"))\n \t    label = do_case (loc1, exp1, exp2, std_attrs);\n \t}\n@@ -8411,6 +8503,7 @@ c_parser_compound_literal_scspecs (c_parser *parser)\n     {\n       switch (c_parser_peek_token (parser)->keyword)\n \t{\n+\tcase RID_CONSTEXPR:\n \tcase RID_REGISTER:\n \tcase RID_STATIC:\n \tcase RID_THREAD:\n@@ -10697,17 +10790,71 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n   location_t start_loc;\n   tree type_expr = NULL_TREE;\n   bool type_expr_const = true;\n+  bool constexpr_p = scspecs ? scspecs->constexpr_p : false;\n+  unsigned int underspec_state = 0;\n   check_compound_literal_type (type_loc, type_name);\n   rich_location richloc (line_table, type_loc);\n-  start_init (NULL_TREE, NULL, 0, &richloc);\n-  type = groktypename (type_name, &type_expr, &type_expr_const);\n   start_loc = c_parser_peek_token (parser)->location;\n+  if (constexpr_p)\n+    {\n+      underspec_state = start_underspecified_init (start_loc, NULL_TREE);\n+      /* A constexpr compound literal is subject to the constraints on\n+\t underspecified declarations, which may not declare tags or\n+\t members or structures or unions; it is undefined behavior to\n+\t declare the members of an enumeration.  Where the structure,\n+\t union or enumeration type is declared within the compound\n+\t literal initializer, this is diagnosed elsewhere as a result\n+\t of the above call to start_underspecified_init.  Diagnose\n+\t here the case of declaring such a type in the type specifiers\n+\t of the compound literal.  */\n+      switch (type_name->specs->typespec_kind)\n+\t{\n+\tcase ctsk_tagfirstref:\n+\tcase ctsk_tagfirstref_attrs:\n+\t  error_at (type_loc, \"%qT declared in %<constexpr%> compound literal\",\n+\t\t    type_name->specs->type);\n+\t  break;\n+\n+\tcase ctsk_tagdef:\n+\t  error_at (type_loc, \"%qT defined in %<constexpr%> compound literal\",\n+\t\t    type_name->specs->type);\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  start_init (NULL_TREE, NULL,\n+\t      (global_bindings_p ()\n+\t       || (scspecs && scspecs->storage_class == csc_static)\n+\t       || constexpr_p), constexpr_p, &richloc);\n+  type = groktypename (type_name, &type_expr, &type_expr_const);\n   if (type != error_mark_node && C_TYPE_VARIABLE_SIZE (type))\n     {\n       error_at (type_loc, \"compound literal has variable size\");\n       type = error_mark_node;\n     }\n+  if (constexpr_p && type != error_mark_node)\n+    {\n+      tree type_no_array = strip_array_types (type);\n+      /* The type of a constexpr object must not be variably modified\n+\t (which applies to all compound literals), volatile, atomic or\n+\t restrict qualified or have a member with such a qualifier.\n+\t const qualification is implicitly added.  */\n+      if (TYPE_QUALS (type_no_array)\n+\t  & (TYPE_QUAL_VOLATILE | TYPE_QUAL_RESTRICT | TYPE_QUAL_ATOMIC))\n+\terror_at (type_loc, \"invalid qualifiers for %<constexpr%> object\");\n+      else if (RECORD_OR_UNION_TYPE_P (type_no_array)\n+\t       && C_TYPE_FIELDS_NON_CONSTEXPR (type_no_array))\n+\terror_at (type_loc, \"invalid qualifiers for field of \"\n+\t\t  \"%<constexpr%> object\");\n+      type = c_build_qualified_type (type,\n+\t\t\t\t     (TYPE_QUALS (type_no_array)\n+\t\t\t\t      | TYPE_QUAL_CONST));\n+    }\n   init = c_parser_braced_init (parser, type, false, NULL, NULL_TREE);\n+  if (constexpr_p)\n+    finish_underspecified_init (NULL_TREE, underspec_state);\n   finish_init ();\n   maybe_warn_string_init (type_loc, type, init);\n \n@@ -23194,7 +23341,7 @@ c_parser_omp_declare_reduction (c_parser *parser, enum pragma_context context)\n \t\t  tree st = push_stmt_list ();\n \t\t  location_t loc = c_parser_peek_token (parser)->location;\n \t\t  rich_location richloc (line_table, loc);\n-\t\t  start_init (omp_priv, NULL_TREE, 0, &richloc);\n+\t\t  start_init (omp_priv, NULL_TREE, false, false, &richloc);\n \t\t  struct c_expr init = c_parser_initializer (parser, omp_priv);\n \t\t  finish_init ();\n \t\t  finish_decl (omp_priv, loc, init.value,"}, {"sha": "c287124c990b40f92d907883b821ed278a8591be", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -34,6 +34,11 @@ along with GCC; see the file COPYING3.  If not see\n /* In a RECORD_TYPE or UNION_TYPE, nonzero if any component is volatile.  */\n #define C_TYPE_FIELDS_VOLATILE(TYPE) TREE_LANG_FLAG_2 (TYPE)\n \n+/* In a RECORD_TYPE or UNION_TYPE, nonzero if any component is\n+   volatile, restrict-qualified or atomic; that is, has a type not\n+   permitted for a constexpr object.  */\n+#define C_TYPE_FIELDS_NON_CONSTEXPR(TYPE) TREE_LANG_FLAG_4 (TYPE)\n+\n /* In a RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE\n    nonzero if the definition of the type has already started.  */\n #define C_TYPE_BEING_DEFINED(TYPE) TYPE_LANG_FLAG_0 (TYPE)\n@@ -104,6 +109,10 @@ along with GCC; see the file COPYING3.  If not see\n    definition.  */\n #define C_DECL_UNDERSPECIFIED(DECL) DECL_LANG_FLAG_7 (DECL)\n \n+/* Set on VAR_DECLs declared as 'constexpr'.  */\n+#define C_DECL_DECLARED_CONSTEXPR(DECL) \\\n+  DECL_LANG_FLAG_8 (VAR_DECL_CHECK (DECL))\n+\n /* Nonzero for a decl which either doesn't exist or isn't a prototype.\n    N.B. Could be simplified if all built-in decls had complete prototypes\n    (but this is presently difficult because some of them need FILE*).  */\n@@ -439,6 +448,8 @@ struct c_declspecs {\n      no type specifier appears later in these declaration\n      specifiers.  */\n   BOOL_BITFIELD c2x_auto_p : 1;\n+  /* Whether \"constexpr\" was specified.  */\n+  BOOL_BITFIELD constexpr_p : 1;\n   /* The address space that the declaration belongs to.  */\n   addr_space_t address_space;\n };\n@@ -662,7 +673,7 @@ extern void shadow_tag_warned (const struct c_declspecs *, int);\n extern tree start_enum (location_t, struct c_enum_contents *, tree, tree);\n extern bool start_function (struct c_declspecs *, struct c_declarator *, tree);\n extern tree start_decl (struct c_declarator *, struct c_declspecs *, bool,\n-\t\t\ttree, location_t * = NULL);\n+\t\t\ttree, bool = true, location_t * = NULL);\n extern tree start_struct (location_t, enum tree_code, tree,\n \t\t\t  class c_struct_parse_info **);\n extern void store_parm_decls (void);\n@@ -733,7 +744,7 @@ extern struct c_expr default_function_array_conversion (location_t,\n extern struct c_expr default_function_array_read_conversion (location_t,\n \t\t\t\t\t\t\t     struct c_expr);\n extern struct c_expr convert_lvalue_to_rvalue (location_t, struct c_expr,\n-\t\t\t\t\t       bool, bool);\n+\t\t\t\t\t       bool, bool, bool = false);\n extern tree decl_constant_value_1 (tree, bool);\n extern void mark_exp_read (tree);\n extern tree composite_type (tree, tree);\n@@ -756,7 +767,7 @@ extern tree c_cast_expr (location_t, struct c_type_name *, tree);\n extern tree build_c_cast (location_t, tree, tree);\n extern void store_init_value (location_t, tree, tree, tree);\n extern void maybe_warn_string_init (location_t, tree, struct c_expr);\n-extern void start_init (tree, tree, int, rich_location *);\n+extern void start_init (tree, tree, bool, bool, rich_location *);\n extern void finish_init (void);\n extern void really_start_incremental_init (tree);\n extern void finish_implicit_inits (location_t, struct obstack *);"}, {"sha": "e06f052eb46a72d3d50835330c5af975e7c52084", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 333, "deletions": 28, "changes": 361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -84,8 +84,9 @@ location_t c_last_sizeof_loc;\n    initializer\" message within this initializer.  */\n static int found_missing_braces;\n \n-static int require_constant_value;\n-static int require_constant_elements;\n+static bool require_constant_value;\n+static bool require_constant_elements;\n+static bool require_constexpr_value;\n \n static bool null_pointer_constant_p (const_tree);\n static tree qualify_type (tree, tree);\n@@ -109,7 +110,8 @@ static void push_member_name (tree);\n static int spelling_length (void);\n static char *print_spelling (char *);\n static void warning_init (location_t, int, const char *);\n-static tree digest_init (location_t, tree, tree, tree, bool, bool, int);\n+static tree digest_init (location_t, tree, tree, tree, bool, bool, bool, bool,\n+\t\t\t bool, bool);\n static void output_init_element (location_t, tree, tree, bool, tree, tree, bool,\n \t\t\t\t bool, struct obstack *);\n static void output_pending_init_elements (int, struct obstack *);\n@@ -2133,20 +2135,91 @@ really_atomic_lvalue (tree expr)\n   return true;\n }\n \n+/* If EXPR is a named constant (C2x) derived from a constexpr variable\n+   - that is, a reference to such a variable, or a member extracted by\n+   a sequence of structure and union (but not array) member accesses\n+   (where union member accesses must access the same member as\n+   initialized) - then return the corresponding initializer;\n+   otherwise, return NULL_TREE.  */\n+\n+static tree\n+maybe_get_constexpr_init (tree expr)\n+{\n+  tree decl = NULL_TREE;\n+  if (TREE_CODE (expr) == VAR_DECL)\n+    decl = expr;\n+  else if (TREE_CODE (expr) == COMPOUND_LITERAL_EXPR)\n+    decl = COMPOUND_LITERAL_EXPR_DECL (expr);\n+  if (decl\n+      && C_DECL_DECLARED_CONSTEXPR (decl)\n+      && DECL_INITIAL (decl) != NULL_TREE\n+      && !error_operand_p (DECL_INITIAL (decl)))\n+    return DECL_INITIAL (decl);\n+  if (TREE_CODE (expr) != COMPONENT_REF)\n+    return NULL_TREE;\n+  tree inner = maybe_get_constexpr_init (TREE_OPERAND (expr, 0));\n+  if (inner == NULL_TREE)\n+    return NULL_TREE;\n+  while ((CONVERT_EXPR_P (inner) || TREE_CODE (inner) == NON_LVALUE_EXPR)\n+\t && !error_operand_p (inner)\n+\t && (TYPE_MAIN_VARIANT (TREE_TYPE (inner))\n+\t     == TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (inner, 0)))))\n+    inner = TREE_OPERAND (inner, 0);\n+  if (TREE_CODE (inner) != CONSTRUCTOR)\n+    return NULL_TREE;\n+  tree field = TREE_OPERAND (expr, 1);\n+  unsigned HOST_WIDE_INT cidx;\n+  tree cfield, cvalue;\n+  bool have_other_init = false;\n+  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (inner), cidx, cfield, cvalue)\n+    {\n+      if (cfield == field)\n+\treturn cvalue;\n+      have_other_init = true;\n+    }\n+  if (TREE_CODE (TREE_TYPE (inner)) == UNION_TYPE\n+      && (have_other_init || field != TYPE_FIELDS (TREE_TYPE (inner))))\n+    return NULL_TREE;\n+  /* Return a default initializer.  */\n+  if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (expr)))\n+    return build_constructor (TREE_TYPE (expr), NULL);\n+  return build_zero_cst (TREE_TYPE (expr));\n+}\n+\n /* Convert expression EXP (location LOC) from lvalue to rvalue,\n    including converting functions and arrays to pointers if CONVERT_P.\n-   If READ_P, also mark the expression as having been read.  */\n+   If READ_P, also mark the expression as having been read.  If\n+   FOR_INIT, constexpr expressions of structure and union type should\n+   be replaced by the corresponding CONSTRUCTOR; otherwise, only\n+   constexpr scalars (including elements of structures and unions) are\n+   replaced by their initializers.  */\n \n struct c_expr\n convert_lvalue_to_rvalue (location_t loc, struct c_expr exp,\n-\t\t\t  bool convert_p, bool read_p)\n+\t\t\t  bool convert_p, bool read_p, bool for_init)\n {\n+  bool force_non_npc = false;\n   if (read_p)\n     mark_exp_read (exp.value);\n   if (convert_p)\n     exp = default_function_array_conversion (loc, exp);\n   if (!VOID_TYPE_P (TREE_TYPE (exp.value)))\n     exp.value = require_complete_type (loc, exp.value);\n+  if (for_init || !RECORD_OR_UNION_TYPE_P (TREE_TYPE (exp.value)))\n+    {\n+      tree init = maybe_get_constexpr_init (exp.value);\n+      if (init != NULL_TREE)\n+\t{\n+\t  /* A named constant of pointer type or type nullptr_t is not\n+\t     a null pointer constant even if the initializer is\n+\t     one.  */\n+\t  if (TREE_CODE (init) == INTEGER_CST\n+\t      && !INTEGRAL_TYPE_P (TREE_TYPE (init))\n+\t      && integer_zerop (init))\n+\t    force_non_npc = true;\n+\t  exp.value = init;\n+\t}\n+    }\n   if (really_atomic_lvalue (exp.value))\n     {\n       vec<tree, va_gc> *params;\n@@ -2187,6 +2260,8 @@ convert_lvalue_to_rvalue (location_t loc, struct c_expr exp,\n   if (convert_p && !error_operand_p (exp.value)\n       && (TREE_CODE (TREE_TYPE (exp.value)) != ARRAY_TYPE))\n     exp.value = convert (build_qualified_type (TREE_TYPE (exp.value), TYPE_UNQUALIFIED), exp.value);\n+  if (force_non_npc)\n+    exp.value = build1 (NOP_EXPR, TREE_TYPE (exp.value), exp.value);\n   return exp;\n }\n \n@@ -6050,7 +6125,7 @@ build_c_cast (location_t loc, tree type, tree expr)\n \t  if (!maybe_const)\n \t    t = c_wrap_maybe_const (t, true);\n \t  t = digest_init (loc, type, t,\n-\t\t\t   NULL_TREE, false, true, 0);\n+\t\t\t   NULL_TREE, false, false, false, true, false, false);\n \t  TREE_CONSTANT (t) = TREE_CONSTANT (value);\n \t  return t;\n \t}\n@@ -7851,6 +7926,8 @@ store_init_value (location_t init_loc, tree decl, tree init, tree origtype)\n {\n   tree value, type;\n   bool npc = false;\n+  bool int_const_expr = false;\n+  bool arith_const_expr = false;\n \n   /* If variable's type was invalidly declared, just ignore it.  */\n \n@@ -7861,9 +7938,19 @@ store_init_value (location_t init_loc, tree decl, tree init, tree origtype)\n   /* Digest the specified initializer into an expression.  */\n \n   if (init)\n-    npc = null_pointer_constant_p (init);\n-  value = digest_init (init_loc, type, init, origtype, npc,\n-      \t\t       true, TREE_STATIC (decl));\n+    {\n+      npc = null_pointer_constant_p (init);\n+      int_const_expr = (TREE_CODE (init) == INTEGER_CST\n+\t\t\t&& !TREE_OVERFLOW (init)\n+\t\t\t&& INTEGRAL_TYPE_P (TREE_TYPE (init)));\n+      /* Not fully determined before folding.  */\n+      arith_const_expr = true;\n+    }\n+  bool constexpr_p = (TREE_CODE (decl) == VAR_DECL\n+\t\t      && C_DECL_DECLARED_CONSTEXPR (decl));\n+  value = digest_init (init_loc, type, init, origtype, npc, int_const_expr,\n+\t\t       arith_const_expr, true,\n+\t\t       TREE_STATIC (decl) || constexpr_p, constexpr_p);\n \n   /* Store the expression if valid; else report error.  */\n \n@@ -8033,12 +8120,151 @@ print_spelling (char *buffer)\n   return buffer;\n }\n \n+/* Check whether INIT, a floating or integer constant, is\n+   representable in TYPE, a real floating type with the same radix.\n+   Return true if OK, false if not.  */\n+static bool\n+constexpr_init_fits_real_type (tree type, tree init)\n+{\n+  gcc_assert (TREE_CODE (type) == REAL_TYPE);\n+  gcc_assert (TREE_CODE (init) == INTEGER_CST || TREE_CODE (init) == REAL_CST);\n+  if (TREE_CODE (init) == REAL_CST\n+      && TYPE_MODE (TREE_TYPE (init)) == TYPE_MODE (type))\n+    /* Same mode, no conversion required.  */\n+    return true;\n+  if (TREE_CODE (init) == INTEGER_CST)\n+    {\n+      tree converted = build_real_from_int_cst (type, init);\n+      bool fail = false;\n+      wide_int w = real_to_integer (&TREE_REAL_CST (converted), &fail,\n+\t\t\t\t    TYPE_PRECISION (TREE_TYPE (init)));\n+      return !fail && wi::eq_p (w, wi::to_wide (init));\n+    }\n+  /* exact_real_truncate is not quite right here, since it doesn't\n+     allow even an exact conversion to subnormal values.  */\n+  REAL_VALUE_TYPE t;\n+  real_convert (&t, TYPE_MODE (type), &TREE_REAL_CST (init));\n+  return real_identical (&t, &TREE_REAL_CST (init));\n+}\n+\n+/* Check whether INIT (location LOC) is valid as a 'constexpr'\n+   initializer for type TYPE, and give an error if not.  INIT has\n+   already been folded and verified to be constant.\n+   NULL_POINTER_CONSTANT, INT_CONST_EXPR and ARITH_CONST_EXPR say\n+   whether it is a null pointer constant, integer constant expression\n+   or arithmetic constant expression, respectively.  If TYPE is not a\n+   scalar type, this function does nothing.  */\n+\n+static void\n+check_constexpr_init (location_t loc, tree type, tree init,\n+\t\t      bool null_pointer_constant, bool int_const_expr,\n+\t\t      bool arith_const_expr)\n+{\n+  if (POINTER_TYPE_P (type))\n+    {\n+      /* The initializer must be a null pointer constant.  */\n+      if (!null_pointer_constant)\n+\terror_at (loc, \"%<constexpr%> pointer initializer is not a \"\n+\t\t  \"null pointer constant\");\n+      return;\n+    }\n+  if (INTEGRAL_TYPE_P (type))\n+    {\n+      /* The initializer must be an integer constant expression,\n+\t representable in the target type.  */\n+      if (!int_const_expr)\n+\terror_at (loc, \"%<constexpr%> integer initializer is not an \"\n+\t\t  \"integer constant expression\");\n+      if (!int_fits_type_p (init, type))\n+\terror_at (loc, \"%<constexpr%> initializer not representable in \"\n+\t\t  \"type of object\");\n+      return;\n+    }\n+  /* We don't apply any extra checks to extension types such as vector\n+     or fixed-point types.  */\n+  if (TREE_CODE (type) != REAL_TYPE && TREE_CODE (type) != COMPLEX_TYPE)\n+    return;\n+  if (!arith_const_expr)\n+    {\n+      error_at (loc, \"%<constexpr%> initializer is not an arithmetic \"\n+\t\t\"constant expression\");\n+      return;\n+    }\n+  /* We don't apply any extra checks to complex integers.  */\n+  if (TREE_CODE (type) == COMPLEX_TYPE\n+      && TREE_CODE (TREE_TYPE (type)) != REAL_TYPE)\n+    return;\n+  /* Both the normative text and the relevant footnote are unclear, as\n+     of the C2x CD, about what exactly counts as a change of value in\n+     floating-point cases.  Here, we consider all conversions between\n+     binary and decimal types (even of infinities and NaNs, where\n+     quantum exponents are not involved) as involving a change of\n+     value, and likewise for conversions between real and complex\n+     types (even when the complex constant has imaginary part positive\n+     zero), and conversions of signaling NaN to a different machine\n+     mode.  But we allow exact conversions of integers to binary or\n+     decimal floating types, and exact conversions between different\n+     binary types or different decimal types, where \"exact\" in the\n+     decimal case requires the quantum exponent to be preserved.  */\n+  if (TREE_CODE (TREE_TYPE (init)) == COMPLEX_TYPE\n+      && TREE_CODE (type) == REAL_TYPE)\n+    {\n+      error_at (loc, \"%<constexpr%> initializer for a real type is of \"\n+\t\t\"complex type\");\n+      return;\n+    }\n+  if (TREE_CODE (type) == COMPLEX_TYPE\n+      && TREE_CODE (TREE_TYPE (init)) != COMPLEX_TYPE)\n+    {\n+      error_at (loc, \"%<constexpr%> initializer for a complex type is of \"\n+\t\t\"real type\");\n+      return;\n+    }\n+  if (TREE_CODE (type) == REAL_TYPE\n+      && TREE_CODE (TREE_TYPE (init)) == REAL_TYPE)\n+    {\n+      if (DECIMAL_FLOAT_TYPE_P (type)\n+\t  && !DECIMAL_FLOAT_TYPE_P (TREE_TYPE (init)))\n+\t{\n+\t  error_at (loc, \"%<constexpr%> initializer for a decimal \"\n+\t\t    \"floating-point type is of binary type\");\n+\t  return;\n+\t}\n+      else if (DECIMAL_FLOAT_TYPE_P (TREE_TYPE (init))\n+\t       && !DECIMAL_FLOAT_TYPE_P (type))\n+\t{\n+\t  error_at (loc, \"%<constexpr%> initializer for a binary \"\n+\t\t    \"floating-point type is of decimal type\");\n+\t  return;\n+\t}\n+    }\n+  bool fits;\n+  if (TREE_CODE (type) == COMPLEX_TYPE)\n+    {\n+      gcc_assert (TREE_CODE (init) == COMPLEX_CST);\n+      fits = (constexpr_init_fits_real_type (TREE_TYPE (type),\n+\t\t\t\t\t     TREE_REALPART (init))\n+\t      && constexpr_init_fits_real_type (TREE_TYPE (type),\n+\t\t\t\t\t\tTREE_IMAGPART (init)));\n+    }\n+  else\n+    fits = constexpr_init_fits_real_type (type, init);\n+  if (!fits)\n+    error_at (loc, \"%<constexpr%> initializer not representable in \"\n+\t      \"type of object\");\n+}\n+\n /* Digest the parser output INIT as an initializer for type TYPE.\n    Return a C expression of type TYPE to represent the initial value.\n \n    If ORIGTYPE is not NULL_TREE, it is the original type of INIT.\n \n-   NULL_POINTER_CONSTANT is true if INIT is a null pointer constant.\n+   NULL_POINTER_CONSTANT is true if INIT is a null pointer constant,\n+   INT_CONST_EXPR is true if INIT is an integer constant expression,\n+   and ARITH_CONST_EXPR is true if INIT is, or might be, an arithmetic\n+   constant expression, false if it has already been determined in the\n+   caller that it is not (but folding may have made the value passed here\n+   indistinguishable from an arithmetic constant expression).\n \n    If INIT is a string constant, STRICT_STRING is true if it is\n    unparenthesized or we should not warn here for it being parenthesized.\n@@ -8047,12 +8273,14 @@ print_spelling (char *buffer)\n    INIT_LOC is the location of the INIT.\n \n    REQUIRE_CONSTANT requests an error if non-constant initializers or\n-   elements are seen.  */\n+   elements are seen.  REQUIRE_CONSTEXPR means the stricter requirements\n+   on initializers for 'constexpr' objects apply.  */\n \n static tree\n digest_init (location_t init_loc, tree type, tree init, tree origtype,\n-    \t     bool null_pointer_constant, bool strict_string,\n-\t     int require_constant)\n+    \t     bool null_pointer_constant, bool int_const_expr,\n+\t     bool arith_const_expr, bool strict_string,\n+\t     bool require_constant, bool require_constexpr)\n {\n   enum tree_code code = TREE_CODE (type);\n   tree inside_init = init;\n@@ -8075,6 +8303,20 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n \t}\n       inside_init = c_fully_fold (inside_init, require_constant, &maybe_const);\n     }\n+  /* TODO: this may not detect all cases of expressions folding to\n+     constants that are not arithmetic constant expressions.  */\n+  if (!maybe_const)\n+    arith_const_expr = false;\n+  else if (!INTEGRAL_TYPE_P (TREE_TYPE (inside_init))\n+      && TREE_CODE (TREE_TYPE (inside_init)) != REAL_TYPE\n+      && TREE_CODE (TREE_TYPE (inside_init)) != COMPLEX_TYPE)\n+    arith_const_expr = false;\n+  else if (TREE_CODE (inside_init) != INTEGER_CST\n+      && TREE_CODE (inside_init) != REAL_CST\n+      && TREE_CODE (inside_init) != COMPLEX_CST)\n+    arith_const_expr = false;\n+  else if (TREE_OVERFLOW (inside_init))\n+    arith_const_expr = false;\n \n   /* Initialization of an array of chars from a string constant\n      optionally enclosed in braces.  */\n@@ -8132,6 +8374,25 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n \t      return error_mark_node;\n             }\n \n+\t  if (require_constexpr\n+\t      && TYPE_UNSIGNED (typ1) != TYPE_UNSIGNED (typ2))\n+\t    {\n+\t      /* Check if all characters of the string can be\n+\t\t represented in the type of the constexpr object being\n+\t\t initialized.  */\n+\t      unsigned HOST_WIDE_INT len = TREE_STRING_LENGTH (inside_init);\n+\t      const unsigned char *p =\n+\t\t(const unsigned char *) TREE_STRING_POINTER (inside_init);\n+\t      gcc_assert (CHAR_TYPE_SIZE == 8 && CHAR_BIT == 8);\n+\t      for (unsigned i = 0; i < len; i++)\n+\t\tif (p[i] > 127)\n+\t\t  {\n+\t\t    error_init (init_loc, \"%<constexpr%> initializer not \"\n+\t\t\t\t\"representable in type of object\");\n+\t\t    break;\n+\t\t  }\n+\t    }\n+\n \t  if (TYPE_DOMAIN (type) != NULL_TREE\n \t      && TYPE_SIZE (type) != NULL_TREE\n \t      && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)\n@@ -8294,6 +8555,10 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n       else if (require_constant && !maybe_const)\n \tpedwarn_init (init_loc, OPT_Wpedantic,\n \t\t      \"initializer element is not a constant expression\");\n+      else if (require_constexpr)\n+\tcheck_constexpr_init (init_loc, type, inside_init,\n+\t\t\t      null_pointer_constant, int_const_expr,\n+\t\t\t      arith_const_expr);\n \n       /* Added to enable additional -Wsuggest-attribute=format warnings.  */\n       if (TREE_CODE (TREE_TYPE (inside_init)) == POINTER_TYPE)\n@@ -8312,6 +8577,7 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n       || code == POINTER_TYPE || code == ENUMERAL_TYPE || code == BOOLEAN_TYPE\n       || code == COMPLEX_TYPE || code == VECTOR_TYPE)\n     {\n+      tree unconverted_init = inside_init;\n       if (TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE\n \t  && (TREE_CODE (init) == STRING_CST\n \t      || TREE_CODE (init) == COMPOUND_LITERAL_EXPR))\n@@ -8345,6 +8611,10 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n       else if (require_constant && !maybe_const)\n \tpedwarn_init (init_loc, OPT_Wpedantic,\n \t\t      \"initializer element is not a constant expression\");\n+      else if (require_constexpr)\n+\tcheck_constexpr_init (init_loc, type, unconverted_init,\n+\t\t\t      null_pointer_constant, int_const_expr,\n+\t\t\t      arith_const_expr);\n \n       return inside_init;\n     }\n@@ -8444,9 +8714,6 @@ static int constructor_depth;\n    such as (struct foo) {...}.  */\n static tree constructor_decl;\n \n-/* Nonzero if this is an initializer for a top-level decl.  */\n-static int constructor_top_level;\n-\n /* Nonzero if there were any member designators in this initializer.  */\n static int constructor_designated;\n \n@@ -8523,9 +8790,9 @@ struct initializer_stack\n   struct spelling *spelling;\n   struct spelling *spelling_base;\n   int spelling_size;\n-  char top_level;\n   char require_constant_value;\n   char require_constant_elements;\n+  char require_constexpr_value;\n   char designated;\n   rich_location *missing_brace_richloc;\n };\n@@ -8535,7 +8802,8 @@ static struct initializer_stack *initializer_stack;\n /* Prepare to parse and output the initializer for variable DECL.  */\n \n void\n-start_init (tree decl, tree asmspec_tree ATTRIBUTE_UNUSED, int top_level,\n+start_init (tree decl, tree asmspec_tree ATTRIBUTE_UNUSED,\n+\t    bool init_require_constant, bool init_require_constexpr,\n \t    rich_location *richloc)\n {\n   const char *locus;\n@@ -8544,36 +8812,35 @@ start_init (tree decl, tree asmspec_tree ATTRIBUTE_UNUSED, int top_level,\n   p->decl = constructor_decl;\n   p->require_constant_value = require_constant_value;\n   p->require_constant_elements = require_constant_elements;\n+  p->require_constexpr_value = require_constexpr_value;\n   p->constructor_stack = constructor_stack;\n   p->constructor_range_stack = constructor_range_stack;\n   p->elements = constructor_elements;\n   p->spelling = spelling;\n   p->spelling_base = spelling_base;\n   p->spelling_size = spelling_size;\n-  p->top_level = constructor_top_level;\n   p->next = initializer_stack;\n   p->missing_brace_richloc = richloc;\n   p->designated = constructor_designated;\n   initializer_stack = p;\n \n   constructor_decl = decl;\n   constructor_designated = 0;\n-  constructor_top_level = top_level;\n \n+  require_constant_value = init_require_constant;\n+  require_constexpr_value = init_require_constexpr;\n   if (decl != NULL_TREE && decl != error_mark_node)\n     {\n-      require_constant_value = TREE_STATIC (decl);\n       require_constant_elements\n-\t= ((TREE_STATIC (decl) || (pedantic && !flag_isoc99))\n+\t= ((init_require_constant || (pedantic && !flag_isoc99))\n \t   /* For a scalar, you can always use any value to initialize,\n \t      even within braces.  */\n \t   && AGGREGATE_TYPE_P (TREE_TYPE (decl)));\n       locus = identifier_to_locale (IDENTIFIER_POINTER (DECL_NAME (decl)));\n     }\n   else\n     {\n-      require_constant_value = 0;\n-      require_constant_elements = 0;\n+      require_constant_elements = false;\n       locus = _(\"(anonymous)\");\n     }\n \n@@ -8611,14 +8878,14 @@ finish_init (void)\n   constructor_decl = p->decl;\n   require_constant_value = p->require_constant_value;\n   require_constant_elements = p->require_constant_elements;\n+  require_constexpr_value = p->require_constexpr_value;\n   constructor_stack = p->constructor_stack;\n   constructor_designated = p->designated;\n   constructor_range_stack = p->constructor_range_stack;\n   constructor_elements = p->elements;\n   spelling = p->spelling;\n   spelling_base = p->spelling_base;\n   spelling_size = p->spelling_size;\n-  constructor_top_level = p->top_level;\n   initializer_stack = p->next;\n   XDELETE (p);\n }\n@@ -9096,6 +9363,10 @@ pop_init_level (location_t loc, int implicit,\n \t{\n \t  if (constructor_erroneous || constructor_type == error_mark_node)\n \t    ret.value = error_mark_node;\n+\t  else if (TREE_CODE (constructor_type) == POINTER_TYPE)\n+\t    /* Ensure this is a null pointer constant in the case of a\n+\t       'constexpr' object initialized with {}.  */\n+\t    ret.value = build_zero_cst (ptr_type_node);\n \t  else\n \t    ret.value = build_zero_cst (constructor_type);\n \t}\n@@ -9844,7 +10115,7 @@ output_init_element (location_t loc, tree value, tree origtype,\n {\n   tree semantic_type = NULL_TREE;\n   bool maybe_const = true;\n-  bool npc;\n+  bool npc, int_const_expr, arith_const_expr;\n \n   if (type == error_mark_node || value == error_mark_node)\n     {\n@@ -9875,12 +10146,31 @@ output_init_element (location_t loc, tree value, tree origtype,\n     }\n \n   npc = null_pointer_constant_p (value);\n+  int_const_expr = (TREE_CODE (value) == INTEGER_CST\n+\t\t    && !TREE_OVERFLOW (value)\n+\t\t    && INTEGRAL_TYPE_P (TREE_TYPE (value)));\n+  /* Not fully determined before folding.  */\n+  arith_const_expr = true;\n   if (TREE_CODE (value) == EXCESS_PRECISION_EXPR)\n     {\n       semantic_type = TREE_TYPE (value);\n       value = TREE_OPERAND (value, 0);\n     }\n   value = c_fully_fold (value, require_constant_value, &maybe_const);\n+  /* TODO: this may not detect all cases of expressions folding to\n+     constants that are not arithmetic constant expressions.  */\n+  if (!maybe_const)\n+    arith_const_expr = false;\n+  else if (!INTEGRAL_TYPE_P (TREE_TYPE (value))\n+      && TREE_CODE (TREE_TYPE (value)) != REAL_TYPE\n+      && TREE_CODE (TREE_TYPE (value)) != COMPLEX_TYPE)\n+    arith_const_expr = false;\n+  else if (TREE_CODE (value) != INTEGER_CST\n+      && TREE_CODE (value) != REAL_CST\n+      && TREE_CODE (value) != COMPLEX_CST)\n+    arith_const_expr = false;\n+  else if (TREE_OVERFLOW (value))\n+    arith_const_expr = false;\n \n   if (value == error_mark_node)\n     constructor_erroneous = 1;\n@@ -9903,8 +10193,18 @@ output_init_element (location_t loc, tree value, tree origtype,\n   tree new_value = value;\n   if (semantic_type)\n     new_value = build1 (EXCESS_PRECISION_EXPR, semantic_type, value);\n-  new_value = digest_init (loc, type, new_value, origtype, npc, strict_string,\n-\t\t\t   require_constant_value);\n+  /* In the case of braces around a scalar initializer, the result of\n+     this initializer processing goes through digest_init again at the\n+     outer level.  In the case of a constexpr initializer for a\n+     pointer, avoid converting a null pointer constant to something\n+     that is not a null pointer constant to avoid a spurious error\n+     from that second processing.  */\n+  if (!require_constexpr_value\n+      || !npc\n+      || TREE_CODE (constructor_type) != POINTER_TYPE)\n+    new_value = digest_init (loc, type, new_value, origtype, npc,\n+\t\t\t     int_const_expr, arith_const_expr, strict_string,\n+\t\t\t     require_constant_value, require_constexpr_value);\n   if (new_value == error_mark_node)\n     {\n       constructor_erroneous = 1;\n@@ -9929,6 +10229,11 @@ output_init_element (location_t loc, tree value, tree origtype,\n \t   && (require_constant_value || require_constant_elements))\n     pedwarn_init (loc, OPT_Wpedantic,\n \t\t  \"initializer element is not a constant expression\");\n+  /* digest_init has already carried out the additional checks\n+     required for 'constexpr' initializers (using the information\n+     passed to it about whether the original initializer was certain\n+     kinds of constant expression), so that check does not need to be\n+     repeated here.  */\n \n   /* Issue -Wc++-compat warnings about initializing a bitfield with\n      enum type.  */"}, {"sha": "084ceb70a7d29bf9653e700e896e9aad37dbd874", "filename": "gcc/dfp.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Fdfp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Fdfp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdfp.cc?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -364,6 +364,12 @@ decimal_from_binary (REAL_VALUE_TYPE *to, const REAL_VALUE_TYPE *from)\n   /* We convert to string, then to decNumber then to decimal128.  */\n   real_to_decimal (string, from, sizeof (string), 0, 1);\n   decimal_real_from_string (to, string);\n+  /* When a canonical NaN is originally created, it is not marked as\n+     decimal.  Ensure the result of converting to another decimal type\n+     (which passes through this function) is also marked as\n+     canonical.  */\n+  if (from->cl == rvc_nan && from->canonical)\n+    to->canonical = 1;\n }\n \n /* Helper function to real.cc:do_compare() to handle decimal internal"}, {"sha": "997c1b0aff0f8bacdc7d051889df679f2e61a74f", "filename": "gcc/testsuite/gcc.dg/c11-keywords-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-keywords-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-keywords-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-keywords-1.c?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -5,6 +5,7 @@\n int alignas;\n int alignof;\n int bool;\n+int constexpr;\n int false;\n int true;\n int static_assert;"}, {"sha": "f7f64e2d3003716bf7e5d47fd9e4b3de9df8e840", "filename": "gcc/testsuite/gcc.dg/c2x-constexpr-1.c", "status": "added", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-1.c?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -0,0 +1,312 @@\n+/* Test C2x constexpr.  Valid code, compilation tests.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+#include <float.h>\n+\n+constexpr int v1 = 1;\n+static_assert (v1 == 1);\n+extern typeof (v1) *pci;\n+extern const int *pci;\n+extern typeof (&(constexpr int) {}) pci;\n+/* Redeclaring a constexpr object is OK (although it can't be declared before\n+   the definition without undefined behavior).  */\n+extern const int v1;\n+static_assert (v1 == 1);\n+unsigned int constexpr v2 = 2;\n+static_assert (v2 == 2);\n+extern typeof (v2) *pcui;\n+extern const unsigned int *pcui;\n+static constexpr char v3 = 3;\n+static_assert (v3 == 3);\n+extern typeof (v3) *pcc;\n+extern const char *pcc;\n+constexpr void *v4 = 0;\n+extern typeof (v4) *pcpv;\n+extern void *const *pcpv;\n+constexpr int *v5 = nullptr;\n+extern typeof (v5) *pcpi;\n+extern int *const *pcpi;\n+constexpr double v6 = 3.5;\n+extern typeof (v6) *pcd;\n+extern const double *pcd;\n+auto constexpr v7 = 1.0;\n+extern typeof (v7) *pcd;\n+constexpr auto v8 = 1.5f;\n+extern typeof (v8) *pcf;\n+extern const float *pcf;\n+constexpr static long v9 = 2ULL;\n+static_assert (v9 == 2);\n+extern typeof (v9) *pcl;\n+extern const long *pcl;\n+const short *v10 = &(constexpr short) { 10 };\n+/* Qualifiers that aren't permitted on a constexpr object itself are OK in a\n+   pointer target.  */\n+constexpr volatile int *v11 = nullptr;\n+extern typeof (v11) *pcpvi;\n+extern volatile int *const *pcpvi;\n+constexpr _Atomic int *v12 = nullptr;\n+extern typeof (v12) *pcpai;\n+extern _Atomic int *const *pcpai;\n+constexpr int *restrict *v13 = nullptr;\n+extern typeof (v13) cprpi;\n+extern int *restrict *const cprpi;\n+typedef int *P;\n+constexpr restrict P *v14 = nullptr;\n+extern typeof (v14) cprpi;\n+struct s15 { volatile int a; _Atomic int b; int *restrict p; };\n+constexpr struct s15 *v16 = nullptr;\n+constexpr char v17[3] = { 1, 2, 3 };\n+struct s18 { int a; int *b; double c; };\n+constexpr struct s18 v19 = { 12345ULL, 0, 19.0L };\n+static_assert (v19.a == 12345);\n+union u20 { int a; float b; };\n+constexpr union u20 v21 = { 1 };\n+static_assert (v21.a == 1);\n+constexpr union u20 v22 = { .b = 23.0 };\n+constexpr float v23 = (float) (1.0f / 3.0f);\n+constexpr double v24 = (double) (1.0 / 3.0);\n+constexpr struct s18 v25 = { 0, 0, (double) (1.0 / 3.0) };\n+static_assert (v25.a == 0);\n+constexpr char v26[] = \"abc\\xfe\";\n+constexpr unsigned char v27[] = u8\"xyz\\xff\";\n+constexpr unsigned char v28[] = \"\\x12\\x7f\";\n+constexpr signed char v29[] = \"\\x34\\x66\";\n+constexpr double v30 = (int) (double) 3.0 - (long) (double) 2.0;\n+constexpr int v31 = 1 + 2 + (int) 3.0;\n+static_assert (v31 == 6);\n+constexpr typeof (nullptr) v32 = nullptr;\n+constexpr _Complex double v33 = __builtin_complex (1.0f, 3.0f / 2.0f);\n+constexpr float v34 = 1234.0L;\n+constexpr char v35 = 127ULL;\n+#if FLT_MIN_EXP == -125 && FLT_MANT_DIG == 24\n+constexpr float v36 = 0x1p-149;\n+constexpr float _Complex v37 = __builtin_complex (0x1p-149, 0x1p127);\n+constexpr float v38 = 0xffffffUL;\n+constexpr float v39 = -0xffffffL;\n+constexpr float v40 = 0xffffff0L;\n+constexpr float v41 = 1ULL << 63;\n+#endif\n+#if DBL_MIN_EXP == -1021 && DBL_MANT_DIG == 53\n+constexpr double v42 = 0x1p-1074L;\n+constexpr _Complex double v43 = __builtin_complex (0x1p1023L, 0x1p-1074L);\n+constexpr double v44 = 0x1fffffffffffffULL;\n+constexpr double v45 = -0x1fffffffffffffLL;\n+constexpr double v46 = 0x3ffffffffffffeULL;\n+constexpr double v47 = 1ULL << 63;\n+#endif\n+constexpr void *v48 = (void *) 0;\n+constexpr int *v49 = (void *) 0L;\n+constexpr long *v50 = 0LL;\n+constexpr int v51 = {};\n+static_assert (v51 == 0);\n+constexpr float v52 = {};\n+constexpr long double v53 = {};\n+constexpr int *v54 = {};\n+constexpr void *v55 = {};\n+constexpr typeof (nullptr) v56 = {};\n+struct s57 { int *p; };\n+union u58 { int *p; };\n+constexpr int *v59 = 0;\n+constexpr int *v60 = { 0 };\n+constexpr struct s57 v61 = { 0 };\n+constexpr struct s57 v62 = { { } }; /* { dg-warning \"braces around scalar initializer\" } */\n+constexpr struct s57 v63 = { { 0 } }; /* { dg-warning \"braces around scalar initializer\" } */\n+constexpr union u58 v64 = { 0 };\n+constexpr union u58 v65 = { { } }; /* { dg-warning \"braces around scalar initializer\" } */\n+constexpr union u58 v66 = { { 0 } }; /* { dg-warning \"braces around scalar initializer\" } */\n+struct s67 { int a; float b; void *c; int *d; typeof (nullptr) e; int f; int g[2]; };\n+struct s68 { struct s67 x; };\n+union u69 { int a; float b; void *c; int *d; struct s68 e; };\n+struct s70 { union u69 x; };\n+constexpr struct s67 v71 = { 1, 2.0, 0, 0, nullptr, 7, { 3, 4 } };\n+static_assert (v71.a == 1);\n+static_assert (v71.f == 7);\n+constexpr struct s67 v72 = v71;\n+static_assert (v72.a == 1);\n+static_assert (v72.f == 7);\n+extern const struct s67 v71;\n+constexpr auto v73 = v71;\n+static_assert (v73.a == 1);\n+static_assert (v73.f == 7);\n+auto v74 = v71;\n+constexpr struct s68 v75 = { v72 };\n+static_assert (v75.x.a == 1);\n+static_assert (v75.x.f == 7);\n+constexpr union u69 v76 = { };\n+static_assert (v76.a == 0);\n+constexpr union u69 v77 = { .e = v75 };\n+static_assert (v77.e.x.a == 1);\n+static_assert (v77.e.x.f == 7);\n+constexpr union u69 v78 = { .a = 1 };\n+static_assert (v78.a == 1);\n+constexpr union u69 v79 = { .e = { v72 } };\n+static_assert (v79.e.x.a == 1);\n+static_assert (v79.e.x.f == 7);\n+enum e80 { E80 = v79.e.x.f };\n+static_assert (E80 == 7);\n+constexpr struct s70 v81 = { v79 };\n+static_assert (v81.x.e.x.f == 7);\n+constexpr struct s68 v82 = { (constexpr struct s67) { 5, 6, 0, 0, nullptr, 9, { 1, 2 } } };\n+static_assert (v82.x.a == 5);\n+static_assert (v82.x.f == 9);\n+constexpr auto v83 = (constexpr int) { (constexpr int) { 0 } };\n+/* These are null pointers but not null pointer constants.  */\n+constexpr typeof (nullptr) v84 = nullptr;\n+constexpr void *v85 = 0;\n+int *v86 = v85;\n+int *v87 = v84;\n+typeof (1 ? v85 : (int *) 0) v88;\n+extern void *v88;\n+typeof (1 ? (void *) 0 : (int *) 0) v89;\n+extern int *v89;\n+constexpr struct s68 v90 = { };\n+static_assert (v90.x.a == 0);\n+static_assert (v90.x.f == 0);\n+constexpr int v91 = { 123 };\n+static_assert (v91 == 123);\n+constexpr int v92 = { v91 };\n+static_assert (v92 == 123);\n+/* Verify that constexpr values can be used in various contexts requiring\n+   (integer) constant expressions.  */\n+struct s93 { int x : v79.e.x.f; };\n+constexpr int v94 = alignof (int);\n+alignas (v94) int v95;\n+constexpr int v97[100] = { [v82.x.f] = 7 };\n+static int v98[v94];\n+\n+void\n+f0 ()\n+{\n+  constexpr int fv0 = 3;\n+  static_assert (fv0 == 3);\n+  auto constexpr int fv1 = 4;\n+  static_assert (fv1 == 4);\n+  register constexpr float fv2 = 1.0;\n+  constexpr auto int fv3 = 123;\n+  static_assert (fv3 == 123);\n+  constexpr register void *fv4 = (void *) 0;\n+  const int *fv5 = &(constexpr int) { 234 };\n+  const int *fv6 = &(constexpr static int) { 234 };\n+  const int *fv7 = &(static constexpr int) { 234 };\n+  typeof ((constexpr register int) { 234 }) *fv8;\n+  typeof ((register constexpr int) { 234 }) *fv9;\n+  int fv10 = (constexpr int) { 1 } + sizeof (struct fs *);\n+  constexpr auto fv11 = (constexpr int) { (constexpr int) { 0 } };\n+  static_assert (fv11 == 0);\n+  constexpr char fv12[3] = { 1, 2, 3 };\n+  (constexpr short [4]) { 9, 8, 7, -6 };\n+  constexpr struct s18 fv13 = { 1234ULL, 0, 13.0f };\n+  (constexpr struct s18) { 123, (void *) 0, 11 };\n+  constexpr union u20 fv14 = { 2 };\n+  (constexpr union u20) { 5 };\n+  constexpr union u20 fv15 = { .b = 15.0 };\n+  (constexpr union u20) { .b = 20 };\n+  (constexpr float) { (float) (1.0f / 3.0f) };\n+  (constexpr double) { (double) (1.0 / 3.0) };\n+  (constexpr struct s18) { 0, 0, (double) (1.0 / 3.0) };\n+  (constexpr char []) { \"abc\\xfe\" };\n+  (constexpr unsigned char []) { u8\"xyz\\xff\" };\n+  (constexpr unsigned char []) { \"\\x12\\x7f\" };\n+  (constexpr signed char []) { \"\\x34\\x66\" };\n+  (constexpr double) { (int) (double) 3.0 - (long) (double) 2.0 };\n+  (constexpr int) { 1 + 2 + (int) 3.0 };\n+  (constexpr typeof (nullptr)) { nullptr };\n+  (constexpr _Complex double) { __builtin_complex (1.0f, 3.0f / 2.0f) };\n+  (constexpr float) { 1234.0L };\n+  (constexpr char) { 127ULL };\n+#if FLT_MIN_EXP == -125 && FLT_MANT_DIG == 24\n+  (constexpr float) { 0x1p-149 };\n+  (constexpr float _Complex) { __builtin_complex (0x1p-149, 0x1p127) };\n+  (constexpr float) { 0xffffffUL };\n+  (constexpr float) { -0xffffffL };\n+  (constexpr float) { 0xffffff0L };\n+  (constexpr float) { 1ULL << 63 };\n+#endif\n+#if DBL_MIN_EXP == -1021 && DBL_MANT_DIG == 53\n+  (constexpr double) { 0x1p-1074L };\n+  (constexpr _Complex double) { __builtin_complex (0x1p1023L, 0x1p-1074L) };\n+  (constexpr double) { 0x1fffffffffffffULL };\n+  (constexpr double) { -0x1fffffffffffffLL };\n+  (constexpr double) { 0x3ffffffffffffeULL };\n+  (constexpr double) { 1ULL << 63 };\n+#endif\n+  (constexpr void *) { (void *) 0 };\n+  (constexpr int *) { (void *) 0L };\n+  (constexpr long *) { 0LL };\n+  (constexpr int) {};\n+  (constexpr float) {};\n+  (constexpr long double) {};\n+  (constexpr int *) {};\n+  (constexpr void *) {};\n+  (constexpr typeof (nullptr)) {};\n+  (constexpr int *) { 0 };\n+  (constexpr struct s57) { 0 };\n+  (constexpr struct s57) { { } }; /* { dg-warning \"braces around scalar initializer\" } */\n+  (constexpr struct s57) { { 0 } }; /* { dg-warning \"braces around scalar initializer\" } */\n+  (constexpr union u58) { 0 };\n+  (constexpr union u58) { { } }; /* { dg-warning \"braces around scalar initializer\" } */\n+  (constexpr union u58) { { 0 } }; /* { dg-warning \"braces around scalar initializer\" } */\n+  /* It's not entirely clear if constexpr declarations are allowed in this\n+     position in a for loop; presume they are, as implicitly auto just as if no\n+     storage class specifiers were used.  */\n+  for (constexpr int fv16 = 1;;)\n+    break;\n+  constexpr struct s67 fv17 = { 1, 2.0, 0, 0, nullptr, 7, { 3, 4 } };\n+  static_assert (fv17.a == 1);\n+  static_assert (fv17.f == 7);\n+  constexpr struct s67 fv18 = fv17;\n+  static_assert (fv18.a == 1);\n+  static_assert (fv18.f == 7);\n+  constexpr auto fv19 = fv17;\n+  static_assert (fv19.a == 1);\n+  static_assert (fv19.f == 7);\n+  auto fv20 = fv17;\n+  constexpr struct s68 fv21 = { fv18 };\n+  static_assert (fv21.x.a == 1);\n+  static_assert (fv21.x.f == 7);\n+  constexpr union u69 fv22 = { };\n+  static_assert (fv22.a == 0);\n+  constexpr union u69 fv23 = { .e = fv21 };\n+  static_assert (fv23.e.x.a == 1);\n+  static_assert (fv23.e.x.f == 7);\n+  constexpr union u69 fv24 = { .a = 1 };\n+  static_assert (fv24.a == 1);\n+  constexpr union u69 fv25 = { .e = { fv18 } };\n+  static_assert (fv25.e.x.a == 1);\n+  static_assert (fv25.e.x.f == 7);\n+  enum fe80 { FE80 = fv25.e.x.f };\n+  static_assert (FE80 == 7);\n+  constexpr struct s70 fv26 = { fv25 };\n+  static_assert (fv26.x.e.x.f == 7);\n+  constexpr struct s68 fv27 = { (constexpr struct s67) { 5, 6, 0, 0, nullptr, 9, { 1, 2 } } };\n+  static_assert (fv27.x.a == 5);\n+  static_assert (fv27.x.f == 9);\n+  constexpr struct s68 fv28 = { };\n+  static_assert (fv28.x.a == 0);\n+  static_assert (fv28.x.f == 0);\n+  constexpr int fv29 = { 123 };\n+  static_assert (fv29 == 123);\n+  constexpr int fv30 = { fv29 };\n+  static_assert (fv30 == 123);\n+  static_assert ((constexpr struct s67) { 1, 2.0, 0, 0, nullptr, 7, { 3, 4 } }.f == 7);\n+  static_assert ((constexpr struct s68) { fv18 }.x.a == 1);\n+  static_assert ((constexpr union u69) { }.a == 0);\n+  static_assert ((constexpr union u69) { .e = fv21 }.e.x.f == 7);\n+  static_assert ((constexpr union u69) { .a = 1 }.a == 1);\n+  static_assert ((constexpr union u69) { .e = { fv18 } }.e.x.a == 1);\n+  static_assert ((constexpr struct s70) { fv25 }.x.e.x.f == 7);\n+  static_assert ((constexpr struct s68) { (constexpr struct s67) { 5, 6, 0, 0, nullptr, 9, { 1, 2 } } }.x.f == 9);\n+  static_assert ((constexpr struct s68) { }.x.f == 0);\n+  /* Verify that constexpr values can be used in various contexts requiring\n+     (integer) constant expressions.  */\n+  struct fs93 { int x : fv25.e.x.f; };\n+  constexpr int fv31 = alignof (int);\n+  alignas (fv31) int fv32;\n+  constexpr int fv33[100] = { [fv27.x.f] = 7 };\n+  static int fv34[fv31];\n+  switch (fv0)\n+    {\n+    case fv27.x.f: ;\n+    }\n+}"}, {"sha": "f74e2ec53bb15a6e969b3b30715d30f1cce1c326", "filename": "gcc/testsuite/gcc.dg/c2x-constexpr-2a.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-2a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-2a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-2a.c?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -0,0 +1,37 @@\n+/* Test C2x constexpr.  Valid code, execution test.  */\n+/* { dg-do link } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+/* { dg-additional-sources \"c2x-constexpr-2b.c\" } */\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+/* constexpr objects at file scope have internal linkage.  */\n+constexpr int a = 2;\n+\n+struct s { int a; float b; int c[3]; };\n+constexpr struct s s1 = { 2, 3, { 4, 5, 6 } };\n+constexpr struct s s2 = s1;\n+struct s s3 = s2;\n+\n+void\n+check (const struct s *p)\n+{\n+  if (p->a != 2 || p->b != 3 || p->c[0] != 4 || p->c[1] != 5 || p->c[2] != 6)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  constexpr struct s s4 = s1;\n+  struct s s5 = s4;\n+  constexpr struct s s6 = { s1.a, s2.b, { 4, 5, 6 } };\n+  check (&s1);\n+  check (&s2);\n+  check (&s3);\n+  check (&s4);\n+  check (&s5);\n+  check (&s6);\n+  exit (0);\n+}"}, {"sha": "04058b3f55986e9c3ff040c20790d254228e8082", "filename": "gcc/testsuite/gcc.dg/c2x-constexpr-2b.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-2b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-2b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-2b.c?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -0,0 +1,6 @@\n+/* Test C2x constexpr.  Second file for link test.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+/* constexpr objects at file scope have internal linkage.  */\n+constexpr int a = 3;"}, {"sha": "16e56db283535665f6926a8f0405942e4f5779e5", "filename": "gcc/testsuite/gcc.dg/c2x-constexpr-3.c", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-3.c?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -0,0 +1,228 @@\n+/* Test C2x constexpr.  Invalid code.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+extern constexpr int v0 = 0; /* { dg-error \"'constexpr' used with 'extern'\" } */\n+/* { dg-warning \"initialized and declared 'extern'\" \"initialized extern\" { target *-*-* } .-1 } */\n+constexpr extern int v1 = 0; /* { dg-error \"'constexpr' used with 'extern'\" } */\n+/* { dg-warning \"initialized and declared 'extern'\" \"initialized extern\" { target *-*-* } .-1 } */\n+typedef constexpr int v2; /* { dg-error \"'constexpr' used with 'typedef'\" } */\n+constexpr typedef int v3; /* { dg-error \"'constexpr' used with 'typedef'\" } */\n+thread_local constexpr int v4 = 0; /* { dg-error \"'constexpr' used with '_Thread_local'\" } */\n+constexpr thread_local int v5 = 0; /* { dg-error \"'thread_local' used with 'constexpr'\" } */\n+constexpr constexpr int v6 = 1; /* { dg-error \"duplicate 'constexpr'\" } */\n+constexpr struct v7; /* { dg-error \"'constexpr' in empty declaration\" } */\n+/* { dg-error \"'struct v7' declared in underspecified object declaration\" \"underspecified\" { target *-*-* } .-1 } */\n+constexpr union v8; /* { dg-error \"'constexpr' in empty declaration\" } */\n+/* { dg-error \"'union v8' declared in underspecified object declaration\" \"underspecified\" { target *-*-* } .-1 } */\n+constexpr struct v9 { int a; }; /* { dg-error \"'constexpr' in empty declaration\" } */\n+/* { dg-error \"'struct v9' defined in underspecified object declaration\" \"underspecified\" { target *-*-* } .-1 } */\n+constexpr union v10 { int a; }; /* { dg-error \"'constexpr' in empty declaration\" } */\n+/* { dg-error \"'union v10' defined in underspecified object declaration\" \"underspecified\" { target *-*-* } .-1 } */\n+constexpr; /* { dg-error \"'constexpr' in empty declaration\" } */\n+constexpr int; /* { dg-error \"empty declaration\" } */\n+constexpr const; /* { dg-error \"empty declaration\" } */\n+constexpr int v11; /* { dg-error \"initialized data declaration\" } */\n+constexpr int v12 { } /* { dg-error \"initialized data declaration\" } */\n+constexpr int v13 = 1, v14 = 2; /* { dg-error \"single declarator\" } */\n+constexpr int v15 = sizeof (struct v16 *); /* { dg-error \"declared in underspecified object initializer\" } */\n+constexpr int v17 = sizeof (union v18 *); /* { dg-error \"declared in underspecified object initializer\" } */\n+constexpr int v19 = sizeof (struct v20 { int a; }); /* { dg-error \"defined in underspecified object initializer\" } */\n+constexpr int v21 = sizeof (struct { int a; }); /* { dg-error \"defined in underspecified object initializer\" } */\n+constexpr int v22 = sizeof (union v23 { int a; }); /* { dg-error \"defined in underspecified object initializer\" } */\n+constexpr int v24 = sizeof (union { int a; }); /* { dg-error \"defined in underspecified object initializer\" } */\n+constexpr int v25 = sizeof (enum v26 { A }); /* { dg-error \"defined in underspecified object initializer\" } */\n+/* The following case is undefined behavior (so doesn't actually require a\n+   diagnostic).  */\n+constexpr int v27 = sizeof (enum { B }); /* { dg-error \"defined in underspecified object initializer\" } */\n+/* Examples with a forward declaration, then definition inside constexpr.  */\n+struct v28;\n+constexpr int v29 = sizeof (struct v28 { int a; }); /* { dg-error \"defined in underspecified object initializer\" } */\n+union v30;\n+constexpr int v31 = sizeof (union v30 { int a; }); /* { dg-error \"defined in underspecified object initializer\" } */\n+constexpr int v32 = sizeof (v32); /* { dg-error \"underspecified 'v32' referenced in its initializer\" } */\n+static const int v33;\n+constexpr const int v33 = 1; /* { dg-error \"underspecified declaration of 'v33', which is already declared in this scope\" } */\n+constexpr void v34 () {} /* { dg-error \"'constexpr' requires an initialized data declaration\" } */\n+void v35 (constexpr int v36); /* { dg-error \"storage class specified for parameter 'v36'\" } */\n+void v37 (constexpr short); /* { dg-error \"storage class specified for unnamed parameter\" } */\n+void v38 (constexpr register int v39); /* { dg-error \"storage class specified for parameter 'v39'\" } */\n+void v40 (constexpr register short); /* { dg-error \"storage class specified for unnamed parameter\" } */\n+/* The following case is undefined behavior (presumably to allow for possible\n+   future support for constexpr functions), but should clearly be diagnosed\n+   when such functions aren't actually supported.  */\n+constexpr int v41 (); /* { dg-error \"'constexpr' requires an initialized data declaration\" } */\n+typedef volatile long t42;\n+typedef int *restrict t43;\n+typedef _Atomic int t44;\n+struct t45 { struct { struct { t42 a[2]; } a; } a; };\n+struct t46 { struct { struct { int z; int *restrict a; } a[3]; } a; };\n+struct t47 { short x; struct { struct { _Atomic long a; } a; } a[4][5]; };\n+constexpr t42 v48 = {}; /* { dg-error \"invalid qualifiers for 'constexpr' object\" } */\n+constexpr t43 v49 = {}; /* { dg-error \"invalid qualifiers for 'constexpr' object\" } */\n+constexpr t44 v50 = {}; /* { dg-error \"invalid qualifiers for 'constexpr' object\" } */\n+constexpr volatile double v51 = {}; /* { dg-error \"invalid qualifiers for 'constexpr' object\" } */\n+constexpr int *restrict v52 = {}; /* { dg-error \"invalid qualifiers for 'constexpr' object\" } */\n+constexpr _Atomic (short) v53 = {}; /* { dg-error \"invalid qualifiers for 'constexpr' object\" } */\n+constexpr long *volatile v54 = {}; /* { dg-error \"invalid qualifiers for 'constexpr' object\" } */\n+constexpr struct t45 v55 = {}; /* { dg-error \"invalid qualifiers for field of 'constexpr' object\" } */\n+constexpr struct t46 v56 = {}; /* { dg-error \"invalid qualifiers for field of 'constexpr' object\" } */\n+constexpr struct t47 v57 = {}; /* { dg-error \"invalid qualifiers for field of 'constexpr' object\" } */\n+union t58 { struct { union { t42 a[1]; } a; } a; };\n+union t59 { struct { union { int z; int *restrict a; } a; } a; };\n+union t60 { short x; union { struct { _Atomic long a; } a[3]; } a; };\n+constexpr union t58 v61 = {}; /* { dg-error \"invalid qualifiers for field of 'constexpr' object\" } */\n+constexpr union t59 v62 = {}; /* { dg-error \"invalid qualifiers for field of 'constexpr' object\" } */\n+constexpr union t60 v63 = {}; /* { dg-error \"invalid qualifiers for field of 'constexpr' object\" } */\n+constexpr t42 v64[1][2][3] = {}; /* { dg-error \"invalid qualifiers for 'constexpr' object\" } */\n+constexpr volatile int v65[1][2][3] = {}; /* { dg-error \"invalid qualifiers for 'constexpr' object\" } */\n+constexpr struct t45 v66[2][2][4] = {}; /* { dg-error \"invalid qualifiers for field of 'constexpr' object\" } */\n+constexpr union t60 v67[2][2][4] = {}; /* { dg-error \"invalid qualifiers for field of 'constexpr' object\" } */\n+int v68 = 0;\n+constexpr int v69 = v68; /* { dg-error \"initializer element is not constant\" } */\n+double exp (double);\n+constexpr double v70 = exp (0); /* { dg-error \"initializer element is not a constant expression\" } */\n+struct s71 { int a; double b; };\n+constexpr struct s71 v72 = { 0, exp (0) }; /* { dg-error \"initializer element is not a constant expression\" } */\n+/* { dg-error \"'constexpr' initializer is not an arithmetic constant expression\" \"arithmetic\" { target *-*-* } .-1 } */\n+constexpr struct s71 v73 = { v68, 0 }; /* { dg-error \"initializer element is not constant\" } */\n+union u74 { int a; double b; };\n+constexpr union u74 v75 = { v68 }; /* { dg-error \"initializer element is not constant\" } */\n+constexpr union u74 v76 = { .b = exp (0) }; /* { dg-error \"initializer element is not a constant expression\" } */\n+/* { dg-error \"'constexpr' initializer is not an arithmetic constant expression\" \"arithmetic\" { target *-*-* } .-1 } */\n+constexpr struct s77 *v77 = 0; /* { dg-error \"'struct s77' declared in underspecified object declaration\" } */\n+constexpr union u78 *v78 = 0; /* { dg-error \"'union u78' declared in underspecified object declaration\" } */\n+constexpr struct s79 { int a; } v79 = { 0 }; /* { dg-error \"'struct s79' defined in underspecified object declaration\" } */\n+constexpr union u80 { int a; } v80 = { 0 }; /* { dg-error \"'union u80' defined in underspecified object declaration\" } */\n+constexpr enum e81 { E81 } v81 = E81; /* { dg-error \"'enum e81' defined in underspecified object declaration\" } */\n+constexpr enum { E82 } v82 = E82; /* { dg-error \"defined in underspecified object declaration\" } */\n+struct s83 constexpr *v83 = 0; /* { dg-error \"'struct s83' declared in underspecified object declaration\" } */\n+union u84 constexpr *v84 = 0; /* { dg-error \"'union u84' declared in underspecified object declaration\" } */\n+struct s85 { int a; } constexpr v85 = { 0 }; /* { dg-error \"'struct s85' defined in underspecified object declaration\" } */\n+union u86 { int a; } constexpr v86 = { 0 }; /* { dg-error \"'union u86' defined in underspecified object declaration\" } */\n+enum e87 { E87 } constexpr v87 = E87; /* { dg-error \"'enum e87' defined in underspecified object declaration\" } */\n+enum { E88 } constexpr v88 = E88; /* { dg-error \"defined in underspecified object declaration\" } */\n+constexpr int *v89 = (int *) 0; /* { dg-error \"'constexpr' pointer initializer is not a null pointer constant\" } */\n+constexpr void *v90 = (void *) (void *) 0; /* { dg-error \"'constexpr' pointer initializer is not a null pointer constant\" } */\n+constexpr int v91 = (int) (double) 1.0; /* { dg-error \"constexpr' integer initializer is not an integer constant expression\" } */\n+constexpr struct s71 v92 = { (int) (double) 1.0, 0 }; /* { dg-error \"constexpr' integer initializer is not an integer constant expression\" } */\n+struct s93 { void *p; };\n+constexpr struct s93 v94 = { (int *) 0 }; /* { dg-error \"'constexpr' pointer initializer is not a null pointer constant\" } */\n+constexpr int v95 = (unsigned int) -1; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr unsigned char v96 = -1; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr signed char v97 = 1234567LL; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+/* { dg-warning \"overflow in conversion\" \"overflow warning\" { target *-*-* } .-1 } */\n+/* Disallow all real/complex conversions (the C2x CD is unclear about\n+   real-to-complex and about complex-to-real with imaginary part positive 0, if\n+   the real parts can be exactly represented in the relevant types).  */\n+constexpr double v98 = __builtin_complex (1.0, 0.0); /* { dg-error \"'constexpr' initializer for a real type is of complex type\" } */\n+constexpr double v99 = __builtin_complex (1.0, 1.0); /* { dg-error \"'constexpr' initializer for a real type is of complex type\" } */\n+constexpr double v100 = __builtin_complex (1.0, -0.0); /* { dg-error \"'constexpr' initializer for a real type is of complex type\" } */\n+constexpr _Complex double v101 = 1.0; /* { dg-error \"'constexpr' initializer for a complex type is of real type\" } */\n+constexpr float v102 = (unsigned long long) -1; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr double v103 = (unsigned long long) -1; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr float v104 = __LONG_LONG_MAX__; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr double v105 = __LONG_LONG_MAX__; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr signed char v106[] = u8\"\\xff\"; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+/* Only the initialized (possibly by default) element of a constexpr union is a\n+   named constant.  */\n+union u107 { int a; int b; };\n+constexpr union u107 v108 = { };\n+constexpr union u107 v109 = { .a = 0 };\n+constexpr union u107 v110 = { .b = 0 };\n+constexpr int v111 = v108.b; /* { dg-error \"initializer\" } */\n+constexpr int v112 = v109.b; /* { dg-error \"initializer\" } */\n+constexpr int v113 = v110.a; /* { dg-error \"initializer\" } */\n+/* A reference to an array in a constexpr object is converted to a pointer as\n+   usual, so in particular is not equivalent to directly using a string literal\n+   initializer extracted from the initializer of that object.  */\n+struct s114 { char c[10]; };\n+constexpr struct s114 v115 = { \"abc\" };\n+constexpr struct s114 v116 = { v115.c }; /* { dg-error \"initializer\" } */\n+/* { dg-error \"integer from pointer\" \"conversion\" { target *-*-* } .-1 } */\n+\n+void\n+f0 ()\n+{\n+  (constexpr constexpr int) { 1 }; /* { dg-error \"duplicate 'constexpr'\" } */\n+  (constexpr thread_local int) { 1 }; /* { dg-error \"'thread_local' used with 'constexpr'\" } */\n+  (thread_local constexpr static int) { 1 }; /* { dg-error \"'constexpr' used with '_Thread_local'\" } */\n+  (constexpr int) { sizeof (struct fs1 *) }; /* { dg-error \"declared in underspecified object initializer\" } */\n+  (constexpr int) { sizeof (union fs2 *) }; /* { dg-error \"declared in underspecified object initializer\" } */\n+  (constexpr int) { sizeof (struct fs3 { int a; }) }; /* { dg-error \"defined in underspecified object initializer\" } */\n+  (constexpr int) { sizeof (struct { int a; }) }; /* { dg-error \"defined in underspecified object initializer\" } */\n+  (constexpr int) { sizeof (union fs4 { int a; }) }; /* { dg-error \"defined in underspecified object initializer\" } */\n+  (constexpr int) { sizeof (union { int a; }) }; /* { dg-error \"defined in underspecified object initializer\" } */\n+  (constexpr int) { sizeof (enum fs5 { A }) }; /* { dg-error \"defined in underspecified object initializer\" } */\n+  /* The following case is undefined behavior (so doesn't actually require a\n+     diagnostic).  */\n+  (constexpr int) { sizeof (enum { B }) }; /* { dg-error \"defined in underspecified object initializer\" } */\n+  /* Examples with a forward declaration, then definition inside constexpr.  */\n+  struct fs6;\n+  (constexpr int) { sizeof (struct fs6 { int a; }) }; /* { dg-error \"defined in underspecified object initializer\" } */\n+  union fs7;\n+  (constexpr int) { sizeof (union fs7 { int a; }) }; /* { dg-error \"defined in underspecified object initializer\" } */\n+  constexpr int fv32 = sizeof (fv32); /* { dg-error \"underspecified 'fv32' referenced in its initializer\" } */\n+  /* Test entering then exiting nested underspecified initializers.  */\n+  constexpr int x = (constexpr int) { 1 } + sizeof (struct fs8 *); /* { dg-error \"declared in underspecified object initializer\" } */\n+  auto y = (constexpr int) { 1 } + sizeof (struct fs9 *); /* { dg-error \"declared in underspecified object initializer\" } */\n+  extern const int z; /* { dg-message \"previous declaration\" } */\n+  constexpr const int z = 1; /* { dg-error \"underspecified declaration of 'z', which is already declared in this scope\" } */\n+  /* { dg-error \"declaration of 'z' with no linkage follows extern declaration\" \"linkage error\" { target *-*-* } .-1 } */\n+  int non_const = 1;\n+  typedef int VLA[non_const];\n+  constexpr VLA *pnc = nullptr; /* { dg-error \"'constexpr' object has variably modified type\" } */\n+  (constexpr t42) {}; /* { dg-error \"invalid qualifiers for 'constexpr' object\" } */\n+  (constexpr t43) {}; /* { dg-error \"invalid qualifiers for 'constexpr' object\" } */\n+  (constexpr t44) {}; /* { dg-error \"invalid qualifiers for 'constexpr' object\" } */\n+  (constexpr volatile double) {}; /* { dg-error \"invalid qualifiers for 'constexpr' object\" } */\n+  (constexpr int *restrict) {}; /* { dg-error \"invalid qualifiers for 'constexpr' object\" } */\n+  (constexpr _Atomic (short)) {}; /* { dg-error \"invalid qualifiers for 'constexpr' object\" } */\n+  (constexpr long *volatile) {}; /* { dg-error \"invalid qualifiers for 'constexpr' object\" } */\n+  (constexpr struct t45) {}; /* { dg-error \"invalid qualifiers for field of 'constexpr' object\" } */\n+  (constexpr struct t46) {}; /* { dg-error \"invalid qualifiers for field of 'constexpr' object\" } */\n+  (constexpr struct t47) {}; /* { dg-error \"invalid qualifiers for field of 'constexpr' object\" } */\n+  (constexpr union t58) {}; /* { dg-error \"invalid qualifiers for field of 'constexpr' object\" } */\n+  (constexpr union t59) {}; /* { dg-error \"invalid qualifiers for field of 'constexpr' object\" } */\n+  (constexpr union t60) {}; /* { dg-error \"invalid qualifiers for field of 'constexpr' object\" } */\n+  (constexpr t42 [1][2][3]) {}; /* { dg-error \"invalid qualifiers for 'constexpr' object\" } */\n+  (constexpr volatile int [1][2][3]) {}; /* { dg-error \"invalid qualifiers for 'constexpr' object\" } */\n+  (constexpr struct t45 [2][2][4]) {}; /* { dg-error \"invalid qualifiers for field of 'constexpr' object\" } */\n+  (constexpr union t60 [2][2][4]) {}; /* { dg-error \"invalid qualifiers for field of 'constexpr' object\" } */\n+  (constexpr int) { v68 }; /* { dg-error \"initializer element is not constant\" } */\n+  (constexpr double) { exp (0) }; /* { dg-error \"initializer element is not a constant expression\" } */\n+  /* { dg-error \"'constexpr' initializer is not an arithmetic constant expression\" \"arithmetic\" { target *-*-* } .-1 } */\n+  (constexpr struct s71) { 0, exp (0) }; /* { dg-error \"initializer element is not a constant expression\" } */\n+  /* { dg-error \"'constexpr' initializer is not an arithmetic constant expression\" \"arithmetic\" { target *-*-* } .-1 } */\n+  (constexpr struct s71) { v68, 0 }; /* { dg-error \"initializer element is not constant\" } */\n+  (constexpr union u74) { v68 }; /* { dg-error \"initializer element is not constant\" } */\n+  (constexpr union u74) { .b = exp (0) }; /* { dg-error \"initializer element is not a constant expression\" } */\n+  /* { dg-error \"'constexpr' initializer is not an arithmetic constant expression\" \"arithmetic\" { target *-*-* } .-1 } */\n+  (constexpr struct fs10 *) { 0 }; /* { dg-error \"declared in 'constexpr' compound literal\" } */\n+  (constexpr union fs11 *) { 0 }; /* { dg-error \"declared in 'constexpr' compound literal\" } */\n+  (constexpr struct fs12 { int a; }) { 0 }; /* { dg-error \"defined in 'constexpr' compound literal\" } */\n+  (constexpr union fs13 { int a; }) { 0 }; /* { dg-error \"defined in 'constexpr' compound literal\" } */\n+  (constexpr enum fs14 { FS14 }) { FS14 }; /* { dg-error \"defined in 'constexpr' compound literal\" } */\n+  (constexpr enum { FS15 }) { FS15 }; /* { dg-error \"defined in 'constexpr' compound literal\" } */\n+  (constexpr int *) { (int *) 0 }; /* { dg-error \"'constexpr' pointer initializer is not a null pointer constant\" } */\n+  (constexpr void *) { (void *) (void *) 0 }; /* { dg-error \"'constexpr' pointer initializer is not a null pointer constant\" } */\n+  (constexpr int) { (int) (double) 1.0 }; /* { dg-error \"constexpr' integer initializer is not an integer constant expression\" } */\n+  (constexpr struct s71) { (int) (double) 1.0, 0 }; /* { dg-error \"constexpr' integer initializer is not an integer constant expression\" } */\n+  (constexpr struct s93) { (int *) 0 }; /* { dg-error \"'constexpr' pointer initializer is not a null pointer constant\" } */\n+  (constexpr int) { (unsigned int) -1 }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr unsigned char) { -1 }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr signed char) { 1234567LL }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  /* { dg-warning \"overflow in conversion\" \"overflow warning\" { target *-*-* } .-1 } */\n+  (constexpr double) { __builtin_complex (1.0, 0.0) }; /* { dg-error \"'constexpr' initializer for a real type is of complex type\" } */\n+  (constexpr double) { __builtin_complex (1.0, 1.0) }; /* { dg-error \"'constexpr' initializer for a real type is of complex type\" } */\n+  (constexpr double) { __builtin_complex (1.0, -0.0) }; /* { dg-error \"'constexpr' initializer for a real type is of complex type\" } */\n+  (constexpr _Complex double) { 1.0 }; /* { dg-error \"'constexpr' initializer for a complex type is of real type\" } */\n+  (constexpr float) { (unsigned long long) -1 }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr double) { (unsigned long long) -1 }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr float) { __LONG_LONG_MAX__ }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr double) { __LONG_LONG_MAX__ }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr signed char []) { u8\"\\xff\" }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  constexpr typeof (nullptr) not_npc = nullptr;\n+  int *ptr = 0;\n+  (void) (ptr == not_npc); /* { dg-error \"invalid operands\" } */\n+}"}, {"sha": "2a42af890a2a87804aa7460ec2bf725dc9501ffd", "filename": "gcc/testsuite/gcc.dg/c2x-constexpr-4.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-4.c?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -0,0 +1,21 @@\n+/* Test C2x constexpr.  Valid code, compilation tests, signed char.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors -fsigned-char\" } */\n+\n+constexpr char v1[] = \"\\x00\\xff\";\n+constexpr signed char v2[] = \"\\x7f\\x80\";\n+constexpr unsigned char v3[] = \"\\x00\\x7f\";\n+constexpr char v4[] = u8\"\\x00\\x7f\";\n+constexpr signed char v5[] = u8\"\\x7f\\x00\";\n+constexpr unsigned char v6[] = u8\"\\x00\\xff\";\n+\n+void\n+f0 ()\n+{\n+  (constexpr char []) { \"\\x00\\xff\" };\n+  (constexpr signed char []) { \"\\x7f\\x80\" };\n+  (constexpr unsigned char []) { \"\\x00\\x7f\" };\n+  (constexpr char []) { u8\"\\x00\\x7f\" };\n+  (constexpr signed char []) { u8\"\\x7f\\x00\" };\n+  (constexpr unsigned char []) { u8\"\\x00\\xff\" };\n+}"}, {"sha": "6febd2ee67f16133488ed4372c3be6fe10f74a0e", "filename": "gcc/testsuite/gcc.dg/c2x-constexpr-5.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-5.c?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -0,0 +1,21 @@\n+/* Test C2x constexpr.  Valid code, compilation tests, unsigned char.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors -funsigned-char\" } */\n+\n+constexpr char v1[] = \"\\x00\\xff\";\n+constexpr signed char v2[] = \"\\x7f\\x00\";\n+constexpr unsigned char v3[] = \"\\x80\\x7f\";\n+constexpr char v4[] = u8\"\\x00\\xff\";\n+constexpr signed char v5[] = u8\"\\x7f\\x00\";\n+constexpr unsigned char v6[] = u8\"\\x00\\xff\";\n+\n+void\n+f0 ()\n+{\n+  (constexpr char []) { \"\\x00\\xff\" };\n+  (constexpr signed char []) { \"\\x7f\\x00\" };\n+  (constexpr unsigned char []) { \"\\x80\\x7f\" };\n+  (constexpr char []) { u8\"\\x00\\xff\" };\n+  (constexpr signed char []) { u8\"\\x7f\\x00\" };\n+  (constexpr unsigned char []) { u8\"\\x00\\xff\" };\n+}"}, {"sha": "a86124a9974c184784f1be3d0298c576a942c65c", "filename": "gcc/testsuite/gcc.dg/c2x-constexpr-6.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-6.c?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -0,0 +1,15 @@\n+/* Test C2x constexpr.  Invalid code, compilation tests, signed char.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors -fsigned-char\" } */\n+\n+constexpr unsigned char v3[] = \"\\x00\\xff\"; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr char v4[] = u8\"\\x00\\xff\"; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr signed char v5[] = u8\"\\x00\\xff\"; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+\n+void\n+f0 ()\n+{\n+  (constexpr unsigned char []) { \"\\x00\\xff\" }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr char []) { u8\"\\x00\\xff\" }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr signed char []) { u8\"\\x00\\xff\" }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+}"}, {"sha": "5282d9231821eb39878719b394995cc607dace51", "filename": "gcc/testsuite/gcc.dg/c2x-constexpr-7.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-7.c?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -0,0 +1,13 @@\n+/* Test C2x constexpr.  Invalid code, compilation tests, unsigned char.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors -funsigned-char\" } */\n+\n+constexpr signed char v2[] = \"\\x00\\xff\"; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr signed char v5[] = u8\"\\x00\\xff\"; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+\n+void\n+f0 ()\n+{\n+  (constexpr signed char []) { \"\\x00\\xff\" }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr signed char []) { u8\"\\x00\\xff\" }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+}"}, {"sha": "c7119c97a6978df7ebf7ef45fe812ea607aea7e8", "filename": "gcc/testsuite/gcc.dg/c2x-constexpr-8.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-8.c?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -0,0 +1,23 @@\n+/* Test C2x constexpr.  Valid code, compilation tests, IEEE arithmetic.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+/* { dg-add-options ieee } */\n+/* { dg-require-effective-target inff } */\n+\n+constexpr float fi = __builtin_inf ();\n+constexpr double di = __builtin_inff ();\n+constexpr float fn = __builtin_nan (\"\");\n+constexpr double dn = __builtin_nanf (\"\");\n+constexpr float fns = __builtin_nansf (\"\");\n+constexpr double dns = __builtin_nans (\"\");\n+\n+void\n+f0 (void)\n+{\n+  (constexpr float) { __builtin_inf () };\n+  (constexpr double) { __builtin_inff () };\n+  (constexpr float) { __builtin_nan (\"\") };\n+  (constexpr double) { __builtin_nanf (\"\") };\n+  (constexpr float) { __builtin_nansf (\"\") };\n+  (constexpr double) { __builtin_nans (\"\") };\n+}"}, {"sha": "c62fc738fa055a21d48d9b27a4da6c3330075000", "filename": "gcc/testsuite/gcc.dg/c2x-constexpr-9.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-constexpr-9.c?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -0,0 +1,39 @@\n+/* Test C2x constexpr.  Invalid code, compilation tests, IEEE arithmetic.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+/* { dg-add-options ieee } */\n+/* { dg-require-effective-target inff } */\n+\n+/* A conversion from signaling NaN to quiet NaN in a different format is not\n+   valid for constexpr.  */\n+constexpr float fns = __builtin_nans (\"\"); /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr double dns = __builtin_nansf (\"\"); /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+\n+/* Test out-of-range values.  */\n+constexpr float fu = __DBL_MIN__; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr float fo = __DBL_MAX__; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr float fp = 0x1.ffffffp0; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+\n+constexpr _Complex float cfur = __builtin_complex (__DBL_MIN__, 0.0); /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr _Complex float cfor = __builtin_complex (__DBL_MAX__, 0.0); /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr _Complex float cfpr = __builtin_complex (0x1.ffffffp0, 0.0); /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+\n+constexpr _Complex float cfui = __builtin_complex (0.0, __DBL_MIN__); /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr _Complex float cfoi = __builtin_complex (0.0, __DBL_MAX__); /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr _Complex float cfpi = __builtin_complex (0.0, 0x1.ffffffp0); /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+\n+void\n+f0 ()\n+{\n+  (constexpr float) { __builtin_nans (\"\") }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr double) { __builtin_nansf (\"\") }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr float) { __DBL_MIN__ }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr float) { __DBL_MAX__ }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr float) { 0x1.ffffffp0 }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr _Complex float) { __builtin_complex (__DBL_MIN__, 0.0) }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr _Complex float) { __builtin_complex (__DBL_MAX__, 0.0) }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr _Complex float) { __builtin_complex (0x1.ffffffp0, 0.0) }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr _Complex float) { __builtin_complex (0.0, __DBL_MIN__) }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr _Complex float) { __builtin_complex (0.0, __DBL_MAX__) }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr _Complex float) { __builtin_complex (0.0, 0x1.ffffffp0) }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+}"}, {"sha": "568f1428b40bf7c24027e4471bfe72938b139e3c", "filename": "gcc/testsuite/gcc.dg/dfp/c2x-constexpr-dfp-1.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fc2x-constexpr-dfp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fc2x-constexpr-dfp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fc2x-constexpr-dfp-1.c?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -0,0 +1,79 @@\n+/* Test C2x constexpr.  Valid code, compilation tests, DFP.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+constexpr _Decimal32 v1 = __DEC32_MIN__;\n+constexpr _Decimal32 v2 = __DEC32_SUBNORMAL_MIN__;\n+constexpr _Decimal32 v3 = -__DEC32_MAX__;\n+constexpr _Decimal64 v4 = __DEC32_MIN__;\n+constexpr _Decimal64 v5 = __DEC32_SUBNORMAL_MIN__;\n+constexpr _Decimal64 v6 = -__DEC32_MAX__;\n+constexpr _Decimal64 v7 = __DEC64_MIN__;\n+constexpr _Decimal64 v8 = __DEC64_SUBNORMAL_MIN__;\n+constexpr _Decimal64 v9 = -__DEC64_MAX__;\n+constexpr _Decimal128 v10 = __DEC32_MIN__;\n+constexpr _Decimal128 v11 = __DEC32_SUBNORMAL_MIN__;\n+constexpr _Decimal128 v12 = -__DEC32_MAX__;\n+constexpr _Decimal128 v13 = __DEC64_MIN__;\n+constexpr _Decimal128 v14 = __DEC64_SUBNORMAL_MIN__;\n+constexpr _Decimal128 v15 = -__DEC64_MAX__;\n+constexpr _Decimal128 v16 = __DEC128_MIN__;\n+constexpr _Decimal128 v17 = __DEC128_SUBNORMAL_MIN__;\n+constexpr _Decimal128 v18 = -__DEC128_MAX__;\n+constexpr _Decimal32 v19 = 1234567L;\n+constexpr _Decimal32 v20 = -123456700000LL;\n+constexpr _Decimal64 v21 = 1234567890123456LL;\n+constexpr _Decimal64 v22 = -123456789012345600LL;\n+constexpr _Decimal128 v23 = (unsigned long long) -1;\n+constexpr _Decimal32 v24 = 1e-101DL;\n+constexpr _Decimal64 v25 = 1e-398DL;\n+constexpr _Decimal32 v26 = __builtin_infd128 ();\n+constexpr _Decimal128 v27 = __builtin_infd32 ();\n+constexpr _Decimal64 v28 = __builtin_nand128 (\"\");\n+constexpr _Decimal128 v29 = __builtin_nand32 (\"\");\n+constexpr _Decimal32 v30 = __builtin_nansd32 (\"\");\n+constexpr _Decimal64 v31 = __builtin_nansd64 (\"\");\n+constexpr _Decimal128 v32 = __builtin_nansd128 (\"\");\n+constexpr _Decimal32 v33 = {};\n+constexpr _Decimal64 v34 = {};\n+constexpr _Decimal128 v35 = {};\n+\n+void\n+f0 ()\n+{\n+  (constexpr _Decimal32) { __DEC32_MIN__ };\n+  (constexpr _Decimal32) { __DEC32_SUBNORMAL_MIN__ };\n+  (constexpr _Decimal32) { -__DEC32_MAX__ };\n+  (constexpr _Decimal64) { __DEC32_MIN__ };\n+  (constexpr _Decimal64) { __DEC32_SUBNORMAL_MIN__ };\n+  (constexpr _Decimal64) { -__DEC32_MAX__ };\n+  (constexpr _Decimal64) { __DEC64_MIN__ };\n+  (constexpr _Decimal64) { __DEC64_SUBNORMAL_MIN__ };\n+  (constexpr _Decimal64) { -__DEC64_MAX__ };\n+  (constexpr _Decimal128) { __DEC32_MIN__ };\n+  (constexpr _Decimal128) { __DEC32_SUBNORMAL_MIN__ };\n+  (constexpr _Decimal128) { -__DEC32_MAX__ };\n+  (constexpr _Decimal128) { __DEC64_MIN__ };\n+  (constexpr _Decimal128) { __DEC64_SUBNORMAL_MIN__ };\n+  (constexpr _Decimal128) { -__DEC64_MAX__ };\n+  (constexpr _Decimal128) { __DEC128_MIN__ };\n+  (constexpr _Decimal128) { __DEC128_SUBNORMAL_MIN__ };\n+  (constexpr _Decimal128) { -__DEC128_MAX__ };\n+  (constexpr _Decimal32) { 1234567L };\n+  (constexpr _Decimal32) { -123456700000LL };\n+  (constexpr _Decimal64) { 1234567890123456LL };\n+  (constexpr _Decimal64) { -123456789012345600LL };\n+  (constexpr _Decimal128) { (unsigned long long) -1 };\n+  (constexpr _Decimal32) { 1e-101DL };\n+  (constexpr _Decimal64) { 1e-398DL };\n+  (constexpr _Decimal32) { __builtin_infd128 () };\n+  (constexpr _Decimal128) { __builtin_infd32 () };\n+  (constexpr _Decimal64) { __builtin_nand128 (\"\") };\n+  (constexpr _Decimal128) { __builtin_nand32 (\"\") };\n+  (constexpr _Decimal32) { __builtin_nansd32 (\"\") };\n+  (constexpr _Decimal64) { __builtin_nansd64 (\"\") };\n+  (constexpr _Decimal128) { __builtin_nansd128 (\"\") };\n+  (constexpr _Decimal32) {};\n+  (constexpr _Decimal64) {};\n+  (constexpr _Decimal128) {};\n+}"}, {"sha": "8b1ecf239083e653a380258658a352138cacc2cc", "filename": "gcc/testsuite/gcc.dg/dfp/c2x-constexpr-dfp-2.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fc2x-constexpr-dfp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fc2x-constexpr-dfp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fc2x-constexpr-dfp-2.c?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -0,0 +1,48 @@\n+/* Test C2x constexpr.  Invalid code, compilation tests, DFP.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+/* Test conversions between binary and decimal.  */\n+constexpr _Decimal32 v1 = 0.0; /* { dg-error \"'constexpr' initializer for a decimal floating-point type is of binary type\" } */\n+constexpr double v2 = 0.0DF; /* { dg-error \"'constexpr' initializer for a binary floating-point type is of decimal type\" } */\n+\n+/* A conversion from signaling NaN to quiet NaN in a different format is not\n+   valid for constexpr.  */\n+constexpr _Decimal32 v3 = __builtin_nansd64 (\"\"); /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr _Decimal32 v4 = __builtin_nansd128 (\"\"); /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr _Decimal64 v5 = __builtin_nansd32 (\"\"); /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr _Decimal64 v6 = __builtin_nansd128 (\"\"); /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr _Decimal128 v7 = __builtin_nansd32 (\"\"); /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr _Decimal128 v8 = __builtin_nansd64 (\"\"); /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+\n+/* Test out-of-range values, including integers.  */\n+constexpr _Decimal32 v9 = 12345678; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr _Decimal64 v10 = (unsigned long long) -1; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr _Decimal32 v11 = __DEC64_MIN__; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr _Decimal64 v12 = -__DEC128_MAX__; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr _Decimal64 v13 = 12345678901234567890.DL; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+\n+/* Test cases where the value can be represented, but the quantum exponent\n+   cannot.  */\n+constexpr _Decimal32 v14 = 0e-200DD; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr _Decimal32 v15 = 0e200DL; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+\n+void\n+f0 ()\n+{\n+  (constexpr _Decimal32) { 0.0 }; /* { dg-error \"'constexpr' initializer for a decimal floating-point type is of binary type\" } */\n+  (constexpr double) { 0.0DF }; /* { dg-error \"'constexpr' initializer for a binary floating-point type is of decimal type\" } */\n+  (constexpr _Decimal32) { __builtin_nansd64 (\"\") }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr _Decimal32) { __builtin_nansd128 (\"\") }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr _Decimal64) { __builtin_nansd32 (\"\") }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr _Decimal64) { __builtin_nansd128 (\"\") }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr _Decimal128) { __builtin_nansd32 (\"\") }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr _Decimal128) { __builtin_nansd64 (\"\") }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr _Decimal32) { 12345678 }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr _Decimal64) { (unsigned long long) -1 }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr _Decimal32) { __DEC64_MIN__ }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr _Decimal64) { -__DEC128_MAX__ }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr _Decimal64) { 12345678901234567890.DL }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr _Decimal32) { 0e-200DD }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+  (constexpr _Decimal32) { 0e200DL }; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+}"}, {"sha": "6078f0807e3c92b52d975ec53c9b4cc5766721d8", "filename": "gcc/testsuite/gcc.dg/gnu2x-constexpr-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-constexpr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-constexpr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-constexpr-1.c?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -0,0 +1,17 @@\n+/* Test C2x constexpr.  Valid code using GNU extensions, compilation tests.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu2x\" } */\n+\n+struct s { struct { int x, y; } x; };\n+constexpr struct s v = { { 123, 150 } };\n+int k;\n+constexpr int a[200] = { [v.x.x ... v.x.y] = 7 };\n+\n+void\n+f ()\n+{\n+  switch (k)\n+    {\n+    case v.x.x ... v.x.y: ;\n+    }\n+}"}, {"sha": "b83ecaec6e913f9ecf9365c9345a0078195bfa77", "filename": "gcc/testsuite/gcc.target/i386/excess-precision-11.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-11.c?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -0,0 +1,8 @@\n+/* Test C2x constexpr.  Valid code, compilation tests, excess precision.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors -mfpmath=387 -fexcess-precision=standard\" } */\n+\n+constexpr long double ld = 1.0 / 3.0;\n+constexpr long double ld2 = 1.1;\n+constexpr double d = (double) (1.0 / 3.0);\n+constexpr double d2 = (double) 1.1;"}, {"sha": "b44f0b5bf76763fff23c50b2e8e0cb7de97e8afe", "filename": "gcc/testsuite/gcc.target/i386/excess-precision-12.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b556d1773db7174c71c466d9b3cafc25c7d6c825/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-12.c?ref=b556d1773db7174c71c466d9b3cafc25c7d6c825", "patch": "@@ -0,0 +1,6 @@\n+/* Test C2x constexpr.  Invalid code, compilation tests, excess precision.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors -mfpmath=387 -fexcess-precision=standard\" } */\n+\n+constexpr double d = 1.0 / 3.0; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */\n+constexpr double d2 = 1.1; /* { dg-error \"'constexpr' initializer not representable in type of object\" } */"}]}