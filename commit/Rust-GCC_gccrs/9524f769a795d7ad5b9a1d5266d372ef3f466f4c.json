{"sha": "9524f769a795d7ad5b9a1d5266d372ef3f466f4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTUyNGY3NjlhNzk1ZDdhZDViOWExZDUyNjZkMzcyZWYzZjQ2NmY0Yw==", "commit": {"author": {"name": "David S. Miller", "email": "davem@tanya.rutgers.edu", "date": "1997-09-22T17:41:48Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-22T17:41:48Z"}, "message": "combine.c (try_combine): Use NULL_RTX instead of '0' where appropriate in calls to gen_rtx().\n\n        * combine.c (try_combine): Use NULL_RTX instead of '0' where\n        appropriate in calls to gen_rtx().\n        * cse.c (cse_main): Likewise.\n        * emit-rtl.c (gen_label_rtx): Likewise.\n        * expr.c (init_expr_once): Likewise.\n        * haifa-sched.c (flush_pending_lists, sched_analyze_insn,\n        sched_analyze, init_rgn_data_dependences,\n        compute_block_backward_dependences): Likewise.\n        * sched.c (schedule_insns): Likewise.\n        * varasm.c (immed_double_const): Likewise.\n\nFrom-SVN: r15630", "tree": {"sha": "09c3e794edb6d39b306cac0fd9a903f1f56efe84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09c3e794edb6d39b306cac0fd9a903f1f56efe84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9524f769a795d7ad5b9a1d5266d372ef3f466f4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9524f769a795d7ad5b9a1d5266d372ef3f466f4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9524f769a795d7ad5b9a1d5266d372ef3f466f4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9524f769a795d7ad5b9a1d5266d372ef3f466f4c/comments", "author": null, "committer": null, "parents": [{"sha": "d70276675c27fde7ac40da9d59d1b49c7a0be851", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d70276675c27fde7ac40da9d59d1b49c7a0be851", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d70276675c27fde7ac40da9d59d1b49c7a0be851"}], "stats": {"total": 38, "additions": 25, "deletions": 13}, "files": [{"sha": "e421b20bf27badbd9ca4bb08dd65c8619a18dc5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9524f769a795d7ad5b9a1d5266d372ef3f466f4c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9524f769a795d7ad5b9a1d5266d372ef3f466f4c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9524f769a795d7ad5b9a1d5266d372ef3f466f4c", "patch": "@@ -1,5 +1,16 @@\n Mon Sep 22 11:36:42 1997  David S. Miller  <davem@tanya.rutgers.edu>\n \n+\t* combine.c (try_combine): Use NULL_RTX instead of '0' where\n+\tappropriate in calls to gen_rtx().\n+\t* cse.c (cse_main): Likewise.\n+\t* emit-rtl.c (gen_label_rtx): Likewise.\n+\t* expr.c (init_expr_once): Likewise.\n+\t* haifa-sched.c (flush_pending_lists, sched_analyze_insn,\n+\tsched_analyze, init_rgn_data_dependences,\n+\tcompute_block_backward_dependences): Likewise.\n+\t* sched.c (schedule_insns): Likewise.\n+\t* varasm.c (immed_double_const): Likewise.\n+\n \t* sparc.h (INCOMING_FRAME_SP_OFFSET): Define to\n \tSPARC_STACK_BIAS for sake of dwarf2 on sparc64.\n "}, {"sha": "2ef88c09f52079199a3bd02a472942c85b2bdb43", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9524f769a795d7ad5b9a1d5266d372ef3f466f4c/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9524f769a795d7ad5b9a1d5266d372ef3f466f4c/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=9524f769a795d7ad5b9a1d5266d372ef3f466f4c", "patch": "@@ -1401,8 +1401,8 @@ try_combine (i3, i2, i1)\n \t     as I2 will not cause a problem.  */\n \n \t  subst_prev_insn = i1\n-\t    = gen_rtx (INSN, VOIDmode, INSN_UID (i2), 0, i2,\n-\t\t       XVECEXP (PATTERN (i2), 0, 1), -1, 0, 0);\n+\t    = gen_rtx (INSN, VOIDmode, INSN_UID (i2), NULL_RTX, i2,\n+\t\t       XVECEXP (PATTERN (i2), 0, 1), -1, NULL_RTX, NULL_RTX);\n \n \t  SUBST (PATTERN (i2), XVECEXP (PATTERN (i2), 0, 0));\n \t  SUBST (XEXP (SET_SRC (PATTERN (i2)), 0),"}, {"sha": "a8c6090326fe11ce3d793932e6cd5a49028435d1", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9524f769a795d7ad5b9a1d5266d372ef3f466f4c/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9524f769a795d7ad5b9a1d5266d372ef3f466f4c/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=9524f769a795d7ad5b9a1d5266d372ef3f466f4c", "patch": "@@ -8200,7 +8200,7 @@ cse_main (f, nregs, after_loop, file)\n \n   /* Allocate scratch rtl here.  cse_insn will fill in the memory reference\n      and change the code and mode as appropriate.  */\n-  memory_extend_rtx = gen_rtx (ZERO_EXTEND, VOIDmode, 0);\n+  memory_extend_rtx = gen_rtx (ZERO_EXTEND, VOIDmode, NULL_RTX);\n #endif\n \n   /* Discard all the free elements of the previous function"}, {"sha": "50c6597281902e79b6e6a23feb1718cd39be0347", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9524f769a795d7ad5b9a1d5266d372ef3f466f4c/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9524f769a795d7ad5b9a1d5266d372ef3f466f4c/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=9524f769a795d7ad5b9a1d5266d372ef3f466f4c", "patch": "@@ -1444,7 +1444,8 @@ gen_label_rtx ()\n \n   label = (output_bytecode\n \t   ? gen_rtx (CODE_LABEL, VOIDmode, NULL, bc_get_bytecode_label ())\n-\t   : gen_rtx (CODE_LABEL, VOIDmode, 0, 0, 0, label_num++, NULL_PTR));\n+\t   : gen_rtx (CODE_LABEL, VOIDmode, 0, NULL_RTX,\n+\t\t      NULL_RTX, label_num++, NULL_PTR));\n \n   LABEL_NUSES (label) = 0;\n   return label;"}, {"sha": "4ed0b39d7101c3ef962404cdee43dc9acc47ddfd", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9524f769a795d7ad5b9a1d5266d372ef3f466f4c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9524f769a795d7ad5b9a1d5266d372ef3f466f4c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=9524f769a795d7ad5b9a1d5266d372ef3f466f4c", "patch": "@@ -292,7 +292,7 @@ init_expr_once ()\n   rtx mem1 = gen_rtx (MEM, VOIDmode, frame_pointer_rtx);\n \n   start_sequence ();\n-  insn = emit_insn (gen_rtx (SET, 0, 0));\n+  insn = emit_insn (gen_rtx (SET, 0, NULL_RTX, NULL_RTX));\n   pat = PATTERN (insn);\n \n   for (mode = VOIDmode; (int) mode < NUM_MACHINE_MODES;"}, {"sha": "38e2892aacf0e90aa893ef9886745616829927dc", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9524f769a795d7ad5b9a1d5266d372ef3f466f4c/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9524f769a795d7ad5b9a1d5266d372ef3f466f4c/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=9524f769a795d7ad5b9a1d5266d372ef3f466f4c", "patch": "@@ -3362,7 +3362,7 @@ flush_pending_lists (insn, only_write)\n     add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n \n   last_pending_memory_flush =\n-    gen_rtx (INSN_LIST, VOIDmode, insn, 0);\n+    gen_rtx (INSN_LIST, VOIDmode, insn, NULL_RTX);\n }\n \n /* Analyze a single SET or CLOBBER rtx, X, creating all dependencies generated\n@@ -3830,7 +3830,7 @@ sched_analyze_insn (x, insn, loop_notes)\n \t\t\t     {\n \t\t\t       /* reg_last_sets[r] is now a list of insns */\n \t\t\t       reg_last_sets[i]\n-\t\t\t\t = gen_rtx (INSN_LIST, VOIDmode, insn, 0);\n+\t\t\t\t = gen_rtx (INSN_LIST, VOIDmode, insn, NULL_RTX);\n \t\t\t     });\n   CLEAR_REG_SET (reg_pending_sets);\n \n@@ -3840,7 +3840,7 @@ sched_analyze_insn (x, insn, loop_notes)\n \n \t/* reg_last_sets[r] is now a list of insns */\n \treg_last_sets[i]\n-\t  = gen_rtx (INSN_LIST, VOIDmode, insn, 0);\n+\t  = gen_rtx (INSN_LIST, VOIDmode, insn, NULL_RTX);\n \n       reg_pending_sets_all = 0;\n     }\n@@ -3988,7 +3988,7 @@ sched_analyze (head, tail)\n \n \t  /* last_function_call is now a list of insns */\n \t  last_function_call\n-\t    = gen_rtx (INSN_LIST, VOIDmode, insn, 0);\n+\t    = gen_rtx (INSN_LIST, VOIDmode, insn, NULL_RTX);\n \t}\n \n       /* See comments on reemit_notes as to why we do this.  */\n@@ -7060,7 +7060,7 @@ init_rgn_data_dependences (n_bbs)\n     {\n       bb_sched_before_next_call[bb] =\n \tgen_rtx (INSN, VOIDmode, 0, NULL_RTX, NULL_RTX,\n-\t\t NULL_RTX, 0, NULL_RTX, 0);\n+\t\t NULL_RTX, 0, NULL_RTX, NULL_RTX);\n       LOG_LINKS (bb_sched_before_next_call[bb]) = 0;\n     }\n }\n@@ -7191,7 +7191,7 @@ compute_block_backward_dependences (bb)\n       last_pending_memory_flush = 0;\n       sched_before_next_call\n \t= gen_rtx (INSN, VOIDmode, 0, NULL_RTX, NULL_RTX,\n-\t\t   NULL_RTX, 0, NULL_RTX, 0);\n+\t\t   NULL_RTX, 0, NULL_RTX, NULL_RTX);\n       LOG_LINKS (sched_before_next_call) = 0;\n     }\n   else"}, {"sha": "b81532425742c785d59b708d7b31b73b51d8a173", "filename": "gcc/sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9524f769a795d7ad5b9a1d5266d372ef3f466f4c/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9524f769a795d7ad5b9a1d5266d372ef3f466f4c/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=9524f769a795d7ad5b9a1d5266d372ef3f466f4c", "patch": "@@ -4238,7 +4238,7 @@ schedule_insns (dump_file)\n   /* Create an insn here so that we can hang dependencies off of it later.  */\n   sched_before_next_call\n     = gen_rtx (INSN, VOIDmode, 0, NULL_RTX, NULL_RTX,\n-\t       NULL_RTX, 0, NULL_RTX, 0);\n+\t       NULL_RTX, 0, NULL_RTX, NULL_RTX);\n \n   /* Initialize the unused_*_lists.  We can't use the ones left over from\n      the previous function, because gcc has freed that memory.  We can use"}, {"sha": "3210aa2e65c6502e59216289d3363bb5a02a5575", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9524f769a795d7ad5b9a1d5266d372ef3f466f4c/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9524f769a795d7ad5b9a1d5266d372ef3f466f4c/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=9524f769a795d7ad5b9a1d5266d372ef3f466f4c", "patch": "@@ -2192,7 +2192,7 @@ immed_double_const (i0, i1, mode)\n \n   push_obstacks_nochange ();\n   rtl_in_saveable_obstack ();\n-  r = gen_rtx (CONST_DOUBLE, mode, 0, i0, i1);\n+  r = gen_rtx (CONST_DOUBLE, mode, NULL_RTX, i0, i1);\n   pop_obstacks ();\n \n   /* Don't touch const_double_chain in nested function; see force_const_mem."}]}