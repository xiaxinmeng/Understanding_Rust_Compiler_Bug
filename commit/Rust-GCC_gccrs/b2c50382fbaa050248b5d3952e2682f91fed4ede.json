{"sha": "b2c50382fbaa050248b5d3952e2682f91fed4ede", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJjNTAzODJmYmFhMDUwMjQ4YjVkMzk1MmUyNjgyZjkxZmVkNGVkZQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2007-03-10T20:29:45Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2007-03-10T20:29:45Z"}, "message": "PR libstdc++/28080 (partial)\n\n2007-03-10  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/28080 (partial)\n\t* include/std/memory: Move C++03 implementation...\n\t* include/bits/stl_memory.h: ... here, new.\n\t* include/Makefile.am: Add.\n\t* include/bits/stl_tempbuf.h: Include the latter instead.\n\t* include/tr1/hashtable: Include allocator.h instead of\n\tthe whole <memory>.\n\t* include/tr1/hashtable_policy.h: Include stl_function.h\n\tinstead of <functional>.\n\t* include/Makefile.in: Regenerate.\n\t* testsuite/20_util/auto_ptr/assign_neg.cc: Adjust dg-error\n\tline numbers.\n\nFrom-SVN: r122805", "tree": {"sha": "2d0ef131bfcdf020e5338698fadb983f70ab6134", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d0ef131bfcdf020e5338698fadb983f70ab6134"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2c50382fbaa050248b5d3952e2682f91fed4ede", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2c50382fbaa050248b5d3952e2682f91fed4ede", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2c50382fbaa050248b5d3952e2682f91fed4ede", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2c50382fbaa050248b5d3952e2682f91fed4ede/comments", "author": null, "committer": null, "parents": [{"sha": "ed574fe919cb1bfc8cd49ea1a991428c818072d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed574fe919cb1bfc8cd49ea1a991428c818072d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed574fe919cb1bfc8cd49ea1a991428c818072d6"}], "stats": {"total": 726, "additions": 392, "deletions": 334}, "files": [{"sha": "24dabcf2d781cf9b653aef7da845c59d8a145787", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2c50382fbaa050248b5d3952e2682f91fed4ede/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2c50382fbaa050248b5d3952e2682f91fed4ede/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b2c50382fbaa050248b5d3952e2682f91fed4ede", "patch": "@@ -1,3 +1,18 @@\n+2007-03-10  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/28080 (partial)\n+\t* include/std/memory: Move C++03 implementation...\n+\t* include/bits/stl_memory.h: ... here, new.\n+\t* include/Makefile.am: Add.\n+\t* include/bits/stl_tempbuf.h: Include the latter instead.\n+\t* include/tr1/hashtable: Include allocator.h instead of\n+\tthe whole <memory>.\n+\t* include/tr1/hashtable_policy.h: Include stl_function.h\n+\tinstead of <functional>.\n+\t* include/Makefile.in: Regenerate.\n+\t* testsuite/20_util/auto_ptr/assign_neg.cc: Adjust dg-error\n+\tline numbers.\n+\n 2007-03-09  Douglas Gregor  <doug.gregor@gmail.com>\n \n \t* include/Makefile.in: Regenerate."}, {"sha": "87c4f977add698e2578aedde48df71fba4a51ee3", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2c50382fbaa050248b5d3952e2682f91fed4ede/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2c50382fbaa050248b5d3952e2682f91fed4ede/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=b2c50382fbaa050248b5d3952e2682f91fed4ede", "patch": "@@ -111,6 +111,7 @@ bits_headers = \\\n \t${bits_srcdir}/stl_iterator_base_types.h \\\n \t${bits_srcdir}/stl_list.h \\\n \t${bits_srcdir}/stl_map.h \\\n+\t${bits_srcdir}/stl_memory.h \\\n \t${bits_srcdir}/stl_multimap.h \\\n \t${bits_srcdir}/stl_multiset.h \\\n \t${bits_srcdir}/stl_numeric.h \\"}, {"sha": "d1feae17be74abc9146c3177f89ffc96fec8138c", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2c50382fbaa050248b5d3952e2682f91fed4ede/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2c50382fbaa050248b5d3952e2682f91fed4ede/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=b2c50382fbaa050248b5d3952e2682f91fed4ede", "patch": "@@ -345,6 +345,7 @@ bits_headers = \\\n \t${bits_srcdir}/stl_iterator_base_types.h \\\n \t${bits_srcdir}/stl_list.h \\\n \t${bits_srcdir}/stl_map.h \\\n+\t${bits_srcdir}/stl_memory.h \\\n \t${bits_srcdir}/stl_multimap.h \\\n \t${bits_srcdir}/stl_multiset.h \\\n \t${bits_srcdir}/stl_numeric.h \\"}, {"sha": "1018ae018c4c7fc25b231c2c8b836a619e3b6ff0", "filename": "libstdc++-v3/include/bits/stl_memory.h", "status": "added", "additions": 367, "deletions": 0, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2c50382fbaa050248b5d3952e2682f91fed4ede/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2c50382fbaa050248b5d3952e2682f91fed4ede/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_memory.h?ref=b2c50382fbaa050248b5d3952e2682f91fed4ede", "patch": "@@ -0,0 +1,367 @@\n+// Memory implementation -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file stl_memory.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef _STL_MEMORY_H\n+#define _STL_MEMORY_H 1\n+\n+#include <bits/stl_algobase.h>\n+#include <bits/allocator.h>\n+#include <bits/stl_construct.h>\n+#include <bits/stl_uninitialized.h>\n+#include <bits/stl_raw_storage_iter.h>\n+#include <debug/debug.h>\n+#include <limits>\n+\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+  /**\n+   *  @if maint\n+   *  This is a helper function.  The unused second parameter exists to\n+   *  permit the real get_temporary_buffer to use template parameter deduction.\n+   *\n+   *  XXX This should perhaps use the pool.\n+   *  @endif\n+   */\n+  template<typename _Tp>\n+    pair<_Tp*, ptrdiff_t>\n+    __get_temporary_buffer(ptrdiff_t __len, _Tp*)\n+    {\n+      const ptrdiff_t __max = numeric_limits<ptrdiff_t>::max() / sizeof(_Tp);\n+      if (__len > __max)\n+\t__len = __max;\n+      \n+      while (__len > 0) \n+\t{\n+\t  _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp), \n+\t\t\t\t\t\t\tnothrow));\n+\t  if (__tmp != 0)\n+\t    return pair<_Tp*, ptrdiff_t>(__tmp, __len);\n+\t  __len /= 2;\n+\t}\n+      return pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);\n+    }\n+\n+  /**\n+   *  @brief Allocates a temporary buffer.\n+   *  @param  len  The number of objects of type Tp.\n+   *  @return See full description.\n+   *\n+   *  Reinventing the wheel, but this time with prettier spokes!\n+   *\n+   *  This function tries to obtain storage for @c len adjacent Tp\n+   *  objects.  The objects themselves are not constructed, of course.\n+   *  A pair<> is returned containing \"the buffer s address and\n+   *  capacity (in the units of sizeof(Tp)), or a pair of 0 values if\n+   *  no storage can be obtained.\"  Note that the capacity obtained\n+   *  may be less than that requested if the memory is unavailable;\n+   *  you should compare len with the .second return value.\n+   *\n+   * Provides the nothrow exception guarantee.\n+   */\n+  template<typename _Tp>\n+    inline pair<_Tp*, ptrdiff_t>\n+    get_temporary_buffer(ptrdiff_t __len)\n+    { return std::__get_temporary_buffer(__len, static_cast<_Tp*>(0)); }\n+\n+  /**\n+   *  @brief The companion to get_temporary_buffer().\n+   *  @param  p  A buffer previously allocated by get_temporary_buffer.\n+   *  @return   None.\n+   *\n+   *  Frees the memory pointed to by p.\n+   */\n+  template<typename _Tp>\n+    void\n+    return_temporary_buffer(_Tp* __p)\n+    { ::operator delete(__p, nothrow); }\n+\n+  /**\n+   *  A wrapper class to provide auto_ptr with reference semantics.\n+   *  For example, an auto_ptr can be assigned (or constructed from)\n+   *  the result of a function which returns an auto_ptr by value.\n+   *\n+   *  All the auto_ptr_ref stuff should happen behind the scenes.\n+   */\n+  template<typename _Tp1>\n+    struct auto_ptr_ref\n+    {\n+      _Tp1* _M_ptr;\n+      \n+      explicit\n+      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }\n+    };\n+\n+\n+  /**\n+   *  @brief  A simple smart pointer providing strict ownership semantics.\n+   *\n+   *  The Standard says:\n+   *  <pre>\n+   *  An @c auto_ptr owns the object it holds a pointer to.  Copying\n+   *  an @c auto_ptr copies the pointer and transfers ownership to the\n+   *  destination.  If more than one @c auto_ptr owns the same object\n+   *  at the same time the behavior of the program is undefined.\n+   *\n+   *  The uses of @c auto_ptr include providing temporary\n+   *  exception-safety for dynamically allocated memory, passing\n+   *  ownership of dynamically allocated memory to a function, and\n+   *  returning dynamically allocated memory from a function.  @c\n+   *  auto_ptr does not meet the CopyConstructible and Assignable\n+   *  requirements for Standard Library <a\n+   *  href=\"tables.html#65\">container</a> elements and thus\n+   *  instantiating a Standard Library container with an @c auto_ptr\n+   *  results in undefined behavior.\n+   *  </pre>\n+   *  Quoted from [20.4.5]/3.\n+   *\n+   *  Good examples of what can and cannot be done with auto_ptr can\n+   *  be found in the libstdc++ testsuite.\n+   *\n+   *  @if maint\n+   *  _GLIBCXX_RESOLVE_LIB_DEFECTS\n+   *  127.  auto_ptr<> conversion issues\n+   *  These resolutions have all been incorporated.\n+   *  @endif\n+   */\n+  template<typename _Tp>\n+    class auto_ptr\n+    {\n+    private:\n+      _Tp* _M_ptr;\n+      \n+    public:\n+      /// The pointed-to type.\n+      typedef _Tp element_type;\n+      \n+      /**\n+       *  @brief  An %auto_ptr is usually constructed from a raw pointer.\n+       *  @param  p  A pointer (defaults to NULL).\n+       *\n+       *  This object now @e owns the object pointed to by @a p.\n+       */\n+      explicit\n+      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }\n+\n+      /**\n+       *  @brief  An %auto_ptr can be constructed from another %auto_ptr.\n+       *  @param  a  Another %auto_ptr of the same type.\n+       *\n+       *  This object now @e owns the object previously owned by @a a,\n+       *  which has given up ownsership.\n+       */\n+      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }\n+\n+      /**\n+       *  @brief  An %auto_ptr can be constructed from another %auto_ptr.\n+       *  @param  a  Another %auto_ptr of a different but related type.\n+       *\n+       *  A pointer-to-Tp1 must be convertible to a\n+       *  pointer-to-Tp/element_type.\n+       *\n+       *  This object now @e owns the object previously owned by @a a,\n+       *  which has given up ownsership.\n+       */\n+      template<typename _Tp1>\n+        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }\n+\n+      /**\n+       *  @brief  %auto_ptr assignment operator.\n+       *  @param  a  Another %auto_ptr of the same type.\n+       *\n+       *  This object now @e owns the object previously owned by @a a,\n+       *  which has given up ownsership.  The object that this one @e\n+       *  used to own and track has been deleted.\n+       */\n+      auto_ptr&\n+      operator=(auto_ptr& __a) throw()\n+      {\n+\treset(__a.release());\n+\treturn *this;\n+      }\n+\n+      /**\n+       *  @brief  %auto_ptr assignment operator.\n+       *  @param  a  Another %auto_ptr of a different but related type.\n+       *\n+       *  A pointer-to-Tp1 must be convertible to a pointer-to-Tp/element_type.\n+       *\n+       *  This object now @e owns the object previously owned by @a a,\n+       *  which has given up ownsership.  The object that this one @e\n+       *  used to own and track has been deleted.\n+       */\n+      template<typename _Tp1>\n+        auto_ptr&\n+        operator=(auto_ptr<_Tp1>& __a) throw()\n+        {\n+\t  reset(__a.release());\n+\t  return *this;\n+\t}\n+\n+      /**\n+       *  When the %auto_ptr goes out of scope, the object it owns is\n+       *  deleted.  If it no longer owns anything (i.e., @c get() is\n+       *  @c NULL), then this has no effect.\n+       *\n+       *  @if maint\n+       *  The C++ standard says there is supposed to be an empty throw\n+       *  specification here, but omitting it is standard conforming.  Its\n+       *  presence can be detected only if _Tp::~_Tp() throws, but this is\n+       *  prohibited.  [17.4.3.6]/2\n+       *  @endif\n+       */\n+      ~auto_ptr() { delete _M_ptr; }\n+      \n+      /**\n+       *  @brief  Smart pointer dereferencing.\n+       *\n+       *  If this %auto_ptr no longer owns anything, then this\n+       *  operation will crash.  (For a smart pointer, \"no longer owns\n+       *  anything\" is the same as being a null pointer, and you know\n+       *  what happens when you dereference one of those...)\n+       */\n+      element_type&\n+      operator*() const throw() \n+      {\n+\t_GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n+\treturn *_M_ptr; \n+      }\n+      \n+      /**\n+       *  @brief  Smart pointer dereferencing.\n+       *\n+       *  This returns the pointer itself, which the language then will\n+       *  automatically cause to be dereferenced.\n+       */\n+      element_type*\n+      operator->() const throw() \n+      {\n+\t_GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n+\treturn _M_ptr; \n+      }\n+      \n+      /**\n+       *  @brief  Bypassing the smart pointer.\n+       *  @return  The raw pointer being managed.\n+       *\n+       *  You can get a copy of the pointer that this object owns, for\n+       *  situations such as passing to a function which only accepts\n+       *  a raw pointer.\n+       *\n+       *  @note  This %auto_ptr still owns the memory.\n+       */\n+      element_type*\n+      get() const throw() { return _M_ptr; }\n+      \n+      /**\n+       *  @brief  Bypassing the smart pointer.\n+       *  @return  The raw pointer being managed.\n+       *\n+       *  You can get a copy of the pointer that this object owns, for\n+       *  situations such as passing to a function which only accepts\n+       *  a raw pointer.\n+       *\n+       *  @note  This %auto_ptr no longer owns the memory.  When this object\n+       *  goes out of scope, nothing will happen.\n+       */\n+      element_type*\n+      release() throw()\n+      {\n+\telement_type* __tmp = _M_ptr;\n+\t_M_ptr = 0;\n+\treturn __tmp;\n+      }\n+      \n+      /**\n+       *  @brief  Forcibly deletes the managed object.\n+       *  @param  p  A pointer (defaults to NULL).\n+       *\n+       *  This object now @e owns the object pointed to by @a p.  The\n+       *  previous object has been deleted.\n+       */\n+      void\n+      reset(element_type* __p = 0) throw()\n+      {\n+\tif (__p != _M_ptr)\n+\t  {\n+\t    delete _M_ptr;\n+\t    _M_ptr = __p;\n+\t  }\n+      }\n+      \n+      /** \n+       *  @brief  Automatic conversions\n+       *\n+       *  These operations convert an %auto_ptr into and from an auto_ptr_ref\n+       *  automatically as needed.  This allows constructs such as\n+       *  @code\n+       *    auto_ptr<Derived>  func_returning_auto_ptr(.....);\n+       *    ...\n+       *    auto_ptr<Base> ptr = func_returning_auto_ptr(.....);\n+       *  @endcode\n+       */\n+      auto_ptr(auto_ptr_ref<element_type> __ref) throw()\n+      : _M_ptr(__ref._M_ptr) { }\n+      \n+      auto_ptr&\n+      operator=(auto_ptr_ref<element_type> __ref) throw()\n+      {\n+\tif (__ref._M_ptr != this->get())\n+\t  {\n+\t    delete _M_ptr;\n+\t    _M_ptr = __ref._M_ptr;\n+\t  }\n+\treturn *this;\n+      }\n+      \n+      template<typename _Tp1>\n+        operator auto_ptr_ref<_Tp1>() throw()\n+        { return auto_ptr_ref<_Tp1>(this->release()); }\n+\n+      template<typename _Tp1>\n+        operator auto_ptr<_Tp1>() throw()\n+        { return auto_ptr<_Tp1>(this->release()); }\n+    };\n+\n+  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+  // 541. shared_ptr template assignment and void\n+  template<>\n+    class auto_ptr<void>\n+    {\n+    public:\n+      typedef void element_type;\n+    };\n+\n+_GLIBCXX_END_NAMESPACE\n+\n+#endif /* _STL_MEMORY_H */"}, {"sha": "6c64c3fe56a84d8d656f3d28b6ad0ff5c7c4b8c2", "filename": "libstdc++-v3/include/bits/stl_tempbuf.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2c50382fbaa050248b5d3952e2682f91fed4ede/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2c50382fbaa050248b5d3952e2682f91fed4ede/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h?ref=b2c50382fbaa050248b5d3952e2682f91fed4ede", "patch": "@@ -1,6 +1,6 @@\n // Temporary buffer implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006 \n+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -62,7 +62,7 @@\n #ifndef _TEMPBUF_H\n #define _TEMPBUF_H 1\n \n-#include <memory>\n+#include <bits/stl_memory.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n "}, {"sha": "33bc2169f73d3dbbe0c63096fd2644712a3c35d8", "filename": "libstdc++-v3/include/std/memory", "status": "modified", "additions": 2, "deletions": 328, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2c50382fbaa050248b5d3952e2682f91fed4ede/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2c50382fbaa050248b5d3952e2682f91fed4ede/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory?ref=b2c50382fbaa050248b5d3952e2682f91fed4ede", "patch": "@@ -51,334 +51,8 @@\n \n #pragma GCC system_header\n \n-#include <bits/stl_algobase.h>\n-#include <bits/allocator.h>\n-#include <bits/stl_construct.h>\n-#include <bits/stl_uninitialized.h>\n-#include <bits/stl_raw_storage_iter.h>\n-#include <debug/debug.h>\n-#include <limits>\n-\n-_GLIBCXX_BEGIN_NAMESPACE(std)\n-\n-  /**\n-   *  @if maint\n-   *  This is a helper function.  The unused second parameter exists to\n-   *  permit the real get_temporary_buffer to use template parameter deduction.\n-   *\n-   *  XXX This should perhaps use the pool.\n-   *  @endif\n-   */\n-  template<typename _Tp>\n-    pair<_Tp*, ptrdiff_t>\n-    __get_temporary_buffer(ptrdiff_t __len, _Tp*)\n-    {\n-      const ptrdiff_t __max = numeric_limits<ptrdiff_t>::max() / sizeof(_Tp);\n-      if (__len > __max)\n-\t__len = __max;\n-      \n-      while (__len > 0) \n-\t{\n-\t  _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp), \n-\t\t\t\t\t\t\tnothrow));\n-\t  if (__tmp != 0)\n-\t    return pair<_Tp*, ptrdiff_t>(__tmp, __len);\n-\t  __len /= 2;\n-\t}\n-      return pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);\n-    }\n-\n-  /**\n-   *  @brief Allocates a temporary buffer.\n-   *  @param  len  The number of objects of type Tp.\n-   *  @return See full description.\n-   *\n-   *  Reinventing the wheel, but this time with prettier spokes!\n-   *\n-   *  This function tries to obtain storage for @c len adjacent Tp\n-   *  objects.  The objects themselves are not constructed, of course.\n-   *  A pair<> is returned containing \"the buffer s address and\n-   *  capacity (in the units of sizeof(Tp)), or a pair of 0 values if\n-   *  no storage can be obtained.\"  Note that the capacity obtained\n-   *  may be less than that requested if the memory is unavailable;\n-   *  you should compare len with the .second return value.\n-   *\n-   * Provides the nothrow exception guarantee.\n-   */\n-  template<typename _Tp>\n-    inline pair<_Tp*, ptrdiff_t>\n-    get_temporary_buffer(ptrdiff_t __len)\n-    { return std::__get_temporary_buffer(__len, static_cast<_Tp*>(0)); }\n-\n-  /**\n-   *  @brief The companion to get_temporary_buffer().\n-   *  @param  p  A buffer previously allocated by get_temporary_buffer.\n-   *  @return   None.\n-   *\n-   *  Frees the memory pointed to by p.\n-   */\n-  template<typename _Tp>\n-    void\n-    return_temporary_buffer(_Tp* __p)\n-    { ::operator delete(__p, nothrow); }\n-\n-  /**\n-   *  A wrapper class to provide auto_ptr with reference semantics.\n-   *  For example, an auto_ptr can be assigned (or constructed from)\n-   *  the result of a function which returns an auto_ptr by value.\n-   *\n-   *  All the auto_ptr_ref stuff should happen behind the scenes.\n-   */\n-  template<typename _Tp1>\n-    struct auto_ptr_ref\n-    {\n-      _Tp1* _M_ptr;\n-      \n-      explicit\n-      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }\n-    };\n-\n-\n-  /**\n-   *  @brief  A simple smart pointer providing strict ownership semantics.\n-   *\n-   *  The Standard says:\n-   *  <pre>\n-   *  An @c auto_ptr owns the object it holds a pointer to.  Copying\n-   *  an @c auto_ptr copies the pointer and transfers ownership to the\n-   *  destination.  If more than one @c auto_ptr owns the same object\n-   *  at the same time the behavior of the program is undefined.\n-   *\n-   *  The uses of @c auto_ptr include providing temporary\n-   *  exception-safety for dynamically allocated memory, passing\n-   *  ownership of dynamically allocated memory to a function, and\n-   *  returning dynamically allocated memory from a function.  @c\n-   *  auto_ptr does not meet the CopyConstructible and Assignable\n-   *  requirements for Standard Library <a\n-   *  href=\"tables.html#65\">container</a> elements and thus\n-   *  instantiating a Standard Library container with an @c auto_ptr\n-   *  results in undefined behavior.\n-   *  </pre>\n-   *  Quoted from [20.4.5]/3.\n-   *\n-   *  Good examples of what can and cannot be done with auto_ptr can\n-   *  be found in the libstdc++ testsuite.\n-   *\n-   *  @if maint\n-   *  _GLIBCXX_RESOLVE_LIB_DEFECTS\n-   *  127.  auto_ptr<> conversion issues\n-   *  These resolutions have all been incorporated.\n-   *  @endif\n-   */\n-  template<typename _Tp>\n-    class auto_ptr\n-    {\n-    private:\n-      _Tp* _M_ptr;\n-      \n-    public:\n-      /// The pointed-to type.\n-      typedef _Tp element_type;\n-      \n-      /**\n-       *  @brief  An %auto_ptr is usually constructed from a raw pointer.\n-       *  @param  p  A pointer (defaults to NULL).\n-       *\n-       *  This object now @e owns the object pointed to by @a p.\n-       */\n-      explicit\n-      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }\n-\n-      /**\n-       *  @brief  An %auto_ptr can be constructed from another %auto_ptr.\n-       *  @param  a  Another %auto_ptr of the same type.\n-       *\n-       *  This object now @e owns the object previously owned by @a a,\n-       *  which has given up ownsership.\n-       */\n-      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }\n-\n-      /**\n-       *  @brief  An %auto_ptr can be constructed from another %auto_ptr.\n-       *  @param  a  Another %auto_ptr of a different but related type.\n-       *\n-       *  A pointer-to-Tp1 must be convertible to a\n-       *  pointer-to-Tp/element_type.\n-       *\n-       *  This object now @e owns the object previously owned by @a a,\n-       *  which has given up ownsership.\n-       */\n-      template<typename _Tp1>\n-        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }\n-\n-      /**\n-       *  @brief  %auto_ptr assignment operator.\n-       *  @param  a  Another %auto_ptr of the same type.\n-       *\n-       *  This object now @e owns the object previously owned by @a a,\n-       *  which has given up ownsership.  The object that this one @e\n-       *  used to own and track has been deleted.\n-       */\n-      auto_ptr&\n-      operator=(auto_ptr& __a) throw()\n-      {\n-\treset(__a.release());\n-\treturn *this;\n-      }\n-\n-      /**\n-       *  @brief  %auto_ptr assignment operator.\n-       *  @param  a  Another %auto_ptr of a different but related type.\n-       *\n-       *  A pointer-to-Tp1 must be convertible to a pointer-to-Tp/element_type.\n-       *\n-       *  This object now @e owns the object previously owned by @a a,\n-       *  which has given up ownsership.  The object that this one @e\n-       *  used to own and track has been deleted.\n-       */\n-      template<typename _Tp1>\n-        auto_ptr&\n-        operator=(auto_ptr<_Tp1>& __a) throw()\n-        {\n-\t  reset(__a.release());\n-\t  return *this;\n-\t}\n-\n-      /**\n-       *  When the %auto_ptr goes out of scope, the object it owns is\n-       *  deleted.  If it no longer owns anything (i.e., @c get() is\n-       *  @c NULL), then this has no effect.\n-       *\n-       *  @if maint\n-       *  The C++ standard says there is supposed to be an empty throw\n-       *  specification here, but omitting it is standard conforming.  Its\n-       *  presence can be detected only if _Tp::~_Tp() throws, but this is\n-       *  prohibited.  [17.4.3.6]/2\n-       *  @endif\n-       */\n-      ~auto_ptr() { delete _M_ptr; }\n-      \n-      /**\n-       *  @brief  Smart pointer dereferencing.\n-       *\n-       *  If this %auto_ptr no longer owns anything, then this\n-       *  operation will crash.  (For a smart pointer, \"no longer owns\n-       *  anything\" is the same as being a null pointer, and you know\n-       *  what happens when you dereference one of those...)\n-       */\n-      element_type&\n-      operator*() const throw() \n-      {\n-\t_GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n-\treturn *_M_ptr; \n-      }\n-      \n-      /**\n-       *  @brief  Smart pointer dereferencing.\n-       *\n-       *  This returns the pointer itself, which the language then will\n-       *  automatically cause to be dereferenced.\n-       */\n-      element_type*\n-      operator->() const throw() \n-      {\n-\t_GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n-\treturn _M_ptr; \n-      }\n-      \n-      /**\n-       *  @brief  Bypassing the smart pointer.\n-       *  @return  The raw pointer being managed.\n-       *\n-       *  You can get a copy of the pointer that this object owns, for\n-       *  situations such as passing to a function which only accepts\n-       *  a raw pointer.\n-       *\n-       *  @note  This %auto_ptr still owns the memory.\n-       */\n-      element_type*\n-      get() const throw() { return _M_ptr; }\n-      \n-      /**\n-       *  @brief  Bypassing the smart pointer.\n-       *  @return  The raw pointer being managed.\n-       *\n-       *  You can get a copy of the pointer that this object owns, for\n-       *  situations such as passing to a function which only accepts\n-       *  a raw pointer.\n-       *\n-       *  @note  This %auto_ptr no longer owns the memory.  When this object\n-       *  goes out of scope, nothing will happen.\n-       */\n-      element_type*\n-      release() throw()\n-      {\n-\telement_type* __tmp = _M_ptr;\n-\t_M_ptr = 0;\n-\treturn __tmp;\n-      }\n-      \n-      /**\n-       *  @brief  Forcibly deletes the managed object.\n-       *  @param  p  A pointer (defaults to NULL).\n-       *\n-       *  This object now @e owns the object pointed to by @a p.  The\n-       *  previous object has been deleted.\n-       */\n-      void\n-      reset(element_type* __p = 0) throw()\n-      {\n-\tif (__p != _M_ptr)\n-\t  {\n-\t    delete _M_ptr;\n-\t    _M_ptr = __p;\n-\t  }\n-      }\n-      \n-      /** \n-       *  @brief  Automatic conversions\n-       *\n-       *  These operations convert an %auto_ptr into and from an auto_ptr_ref\n-       *  automatically as needed.  This allows constructs such as\n-       *  @code\n-       *    auto_ptr<Derived>  func_returning_auto_ptr(.....);\n-       *    ...\n-       *    auto_ptr<Base> ptr = func_returning_auto_ptr(.....);\n-       *  @endcode\n-       */\n-      auto_ptr(auto_ptr_ref<element_type> __ref) throw()\n-      : _M_ptr(__ref._M_ptr) { }\n-      \n-      auto_ptr&\n-      operator=(auto_ptr_ref<element_type> __ref) throw()\n-      {\n-\tif (__ref._M_ptr != this->get())\n-\t  {\n-\t    delete _M_ptr;\n-\t    _M_ptr = __ref._M_ptr;\n-\t  }\n-\treturn *this;\n-      }\n-      \n-      template<typename _Tp1>\n-        operator auto_ptr_ref<_Tp1>() throw()\n-        { return auto_ptr_ref<_Tp1>(this->release()); }\n-\n-      template<typename _Tp1>\n-        operator auto_ptr<_Tp1>() throw()\n-        { return auto_ptr<_Tp1>(this->release()); }\n-    };\n-\n-  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-  // 541. shared_ptr template assignment and void\n-  template<>\n-    class auto_ptr<void>\n-    {\n-    public:\n-      typedef void element_type;\n-    };\n-\n-_GLIBCXX_END_NAMESPACE\n+#include <bits/c++config.h>\n+#include <bits/stl_memory.h>\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n # include <tr1/memory>"}, {"sha": "7fa9ea11789a15a14a164e783dfe631ceac1f77f", "filename": "libstdc++-v3/include/tr1/hashtable", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2c50382fbaa050248b5d3952e2682f91fed4ede/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2c50382fbaa050248b5d3952e2682f91fed4ede/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable?ref=b2c50382fbaa050248b5d3952e2682f91fed4ede", "patch": "@@ -53,10 +53,10 @@\n #define _TR1_HASHTABLE 1\n \n #include <utility>\t\t// For std::pair\n-#include <memory>\n #include <iterator>\n #include <cstddef>\n #include <cmath>\n+#include <bits/allocator.h>\n #include <bits/functexcept.h>\n #include <tr1/type_traits>\t// For true_type and false_type\n #include <tr1/hashtable_policy.h>"}, {"sha": "270380c8dfc5fe8604c450b0827d12224928caac", "filename": "libstdc++-v3/include/tr1/hashtable_policy.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2c50382fbaa050248b5d3952e2682f91fed4ede/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2c50382fbaa050248b5d3952e2682f91fed4ede/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable_policy.h?ref=b2c50382fbaa050248b5d3952e2682f91fed4ede", "patch": "@@ -34,8 +34,8 @@\n #ifndef _TR1_HASHTABLE_POLICY_H\n #define _TR1_HASHTABLE_POLICY_H 1\n \n-#include <functional> // _Identity, _Select1st\n #include <algorithm> // lower_bound\n+#include <bits/stl_function.h> // equal_to, _Identity, _Select1st\n #include <tr1/utility>\n #include <ext/type_traits.h>\n "}, {"sha": "5ce62eeac3b3771857f3d980329de657e1e51b62", "filename": "libstdc++-v3/testsuite/20_util/auto_ptr/assign_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2c50382fbaa050248b5d3952e2682f91fed4ede/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2c50382fbaa050248b5d3952e2682f91fed4ede/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr%2Fassign_neg.cc?ref=b2c50382fbaa050248b5d3952e2682f91fed4ede", "patch": "@@ -46,5 +46,5 @@ main()\n   test01();\n   return 0;\n }\n-// { dg-error \"candidates\" \"\" { target *-*-* } 223 } \n-// { dg-error \"::auto_ptr\" \"\" { target *-*-* } 353 } \n+// { dg-error \"candidates\" \"\" { target *-*-* } 207 } \n+// { dg-error \"::auto_ptr\" \"\" { target *-*-* } 337 } "}]}