{"sha": "fe3ad57221f647b880567025bf825dcca9b7174a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmUzYWQ1NzIyMWY2NDdiODgwNTY3MDI1YmY4MjVkY2NhOWI3MTc0YQ==", "commit": {"author": {"name": "Stephen Clarke", "email": "stephen.clarke@superh.com", "date": "2003-06-18T19:43:55Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2003-06-18T19:43:55Z"}, "message": "bt-load.c: New file.\n\n2003-06-18  Stephen Clarke <stephen.clarke@superh.com>\n            J\"orn Rennecke <joern.rennecke@superh.com>\n\n\t* bt-load.c: New file.\n\t* Makefile.in (OBJS): Include bt-load.o\n\t(bt-load.o): Add dependencies.\n\t* flags.h (flag_branch_target_load_optimize): Declare.\n\t(flag_branch_target_load_optimize2): Likewise.\n\t* hooks.c (hook_reg_class_void_no_regs): New function.\n\t(hook_bool_bool_false): Likewise.\n\t* hooks.h (hook_reg_class_void_no_regs, hook_bool_bool_false): Declare.\n\t* rtl.h (branch_target_load_optimize): Declare.\n\t* target-def.h (TARGET_BRANCH_TARGET_REGISTER_CLASS): Define.\n\t(TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED): Likewise.\n\t(TARGET_INITIALIZER): Include these.\n\t* target.h (struct gcc_target): Add branch_target_register_class\n\tand branch_target_register_callee_saved members.\n\t* toplev.c (enum dump_file_index): Add DFI_branch_target_load\n\t(dump_file) Add \"tars\" entry.\n\t(flag_branch_target_load_optimize): New variable.\n\t(flag_branch_target_load_optimize2): Likewise.\n\t(lang_independent_options): Add entries for new options.\n\t(rest_of_compilation): Call branch_target_load_optimize.\n\t* doc/tm.texi (TARGET_BRANCH_TARGET_REGISTER_CLASS): Document.\n\t(TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED): Likewise.\n\t* doc/invoke.texi: Document -fbranch-target-load-optimize and\n\t-fbranch-target-load-optimize2.\n\t* rtl.h (epilogue_completed): Declare.\n\t* recog.c (epilogue_completed): New variable.\n\t* toplev.c (rest_of_compilation): Set it.\n\t* flow.c (mark_regs_live_at_end): Use it.\n\t* config/ia64/ia64.c (ia64_output_mi_thunk): Set it.\n\t* config/rs6000/rs6000.c (rs6000_output_mi_thunk): Likewise.\n\t* config/sh/sh.c (sh_output_mi_thunk): Likewise.\n\t* config/sparc/sparc.c (sparc_output_mi_thunk): Likewise.\n\n\t* sh.c (shmedia_space_reserved_for_target_registers): New variable.\n\t(sh_target_reg_class): New function.\n\t(sh_optimize_target_register_callee_saved): Likwise.\n\t(shmedia_target_regs_stack_space): Likewise.\n\t(shmedia_reserve_space_for_target_registers_p): Likewise.\n\t(shmedia_target_regs_stack_adjust): Likewise.\n\t(TARGET_BRANCH_TARGET_REGISTER_CLASS): Override.\n\t(TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED): Likewise.\n\t(calc_live_regs): If flag_branch_target_load_optimize2 and\n\tTARGET_SAVE_ALL_TARGET_REGS is enabled, and we have space reserved\n\tfor target registers, make sure that we save all target registers.\n\t(sh_expand_prologue, sh_expand_epilogue): Take target register\n\toptimizations into account.  Collapse stack adjustments if that\n\tis beneficial.\n\t(initial_elimination_offset): Reserve space for target registers\n\tif necessary.\n\t* sh.h (SAVE_ALL_TR_BIT, TARGET_SAVE_ALL_TARGET_REGS): Define.\n\t(OPTIMIZATION_OPTIONS): Enable flag_branch_target_load_optimize.\n\nCo-Authored-By: J\"orn Rennecke <joern.rennecke@superh.com>\n\nFrom-SVN: r68165", "tree": {"sha": "b7be589065a18041782f05367c05430c81cde781", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7be589065a18041782f05367c05430c81cde781"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe3ad57221f647b880567025bf825dcca9b7174a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe3ad57221f647b880567025bf825dcca9b7174a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe3ad57221f647b880567025bf825dcca9b7174a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe3ad57221f647b880567025bf825dcca9b7174a/comments", "author": null, "committer": null, "parents": [{"sha": "acd8e2d08fc5128d65776f04d40ba65eaa8dc76d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acd8e2d08fc5128d65776f04d40ba65eaa8dc76d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acd8e2d08fc5128d65776f04d40ba65eaa8dc76d"}], "stats": {"total": 1788, "additions": 1754, "deletions": 34}, "files": [{"sha": "f2a20d192585046bdf9426bba5c46fc72bc90d51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe3ad57221f647b880567025bf825dcca9b7174a", "patch": "@@ -1,3 +1,58 @@\n+2003-06-18  Stephen Clarke <stephen.clarke@superh.com>\n+            J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* bt-load.c: New file.\n+\t* Makefile.in (OBJS): Include bt-load.o\n+\t(bt-load.o): Add dependencies.\n+\t* flags.h (flag_branch_target_load_optimize): Declare.\n+\t(flag_branch_target_load_optimize2): Likewise.\n+\t* hooks.c (hook_reg_class_void_no_regs): New function.\n+\t(hook_bool_bool_false): Likewise.\n+\t* hooks.h (hook_reg_class_void_no_regs, hook_bool_bool_false): Declare.\n+\t* rtl.h (branch_target_load_optimize): Declare.\n+\t* target-def.h (TARGET_BRANCH_TARGET_REGISTER_CLASS): Define.\n+\t(TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED): Likewise.\n+\t(TARGET_INITIALIZER): Include these.\n+\t* target.h (struct gcc_target): Add branch_target_register_class\n+\tand branch_target_register_callee_saved members.\n+\t* toplev.c (enum dump_file_index): Add DFI_branch_target_load\n+\t(dump_file) Add \"tars\" entry.\n+\t(flag_branch_target_load_optimize): New variable.\n+\t(flag_branch_target_load_optimize2): Likewise.\n+\t(lang_independent_options): Add entries for new options.\n+\t(rest_of_compilation): Call branch_target_load_optimize.\n+\t* doc/tm.texi (TARGET_BRANCH_TARGET_REGISTER_CLASS): Document.\n+\t(TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED): Likewise.\n+\t* doc/invoke.texi: Document -fbranch-target-load-optimize and\n+\t-fbranch-target-load-optimize2.\n+\t* rtl.h (epilogue_completed): Declare.\n+\t* recog.c (epilogue_completed): New variable.\n+\t* toplev.c (rest_of_compilation): Set it.\n+\t* flow.c (mark_regs_live_at_end): Use it.\n+\t* config/ia64/ia64.c (ia64_output_mi_thunk): Set it.\n+\t* config/rs6000/rs6000.c (rs6000_output_mi_thunk): Likewise.\n+\t* config/sh/sh.c (sh_output_mi_thunk): Likewise.\n+\t* config/sparc/sparc.c (sparc_output_mi_thunk): Likewise.\n+\n+\t* sh.c (shmedia_space_reserved_for_target_registers): New variable.\n+\t(sh_target_reg_class): New function.\n+\t(sh_optimize_target_register_callee_saved): Likwise.\n+\t(shmedia_target_regs_stack_space): Likewise.\n+\t(shmedia_reserve_space_for_target_registers_p): Likewise.\n+\t(shmedia_target_regs_stack_adjust): Likewise.\n+\t(TARGET_BRANCH_TARGET_REGISTER_CLASS): Override.\n+\t(TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED): Likewise.\n+\t(calc_live_regs): If flag_branch_target_load_optimize2 and\n+\tTARGET_SAVE_ALL_TARGET_REGS is enabled, and we have space reserved\n+\tfor target registers, make sure that we save all target registers.\n+\t(sh_expand_prologue, sh_expand_epilogue): Take target register\n+\toptimizations into account.  Collapse stack adjustments if that\n+\tis beneficial.\n+\t(initial_elimination_offset): Reserve space for target registers\n+\tif necessary.\n+\t* sh.h (SAVE_ALL_TR_BIT, TARGET_SAVE_ALL_TARGET_REGS): Define.\n+\t(OPTIMIZATION_OPTIONS): Enable flag_branch_target_load_optimize.\n+\n 2003-06-18  Nick Clifton  <nickc@redhat.com>\n \n \t* config.gcc: Add an extra_header for ARM targets."}, {"sha": "51255061ac356af823b2d71f742de28055a7add8", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=fe3ad57221f647b880567025bf825dcca9b7174a", "patch": "@@ -822,7 +822,7 @@ OBJS = alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t   \\\n  sibcall.o simplify-rtx.o sreal.o ssa.o ssa-ccp.o ssa-dce.o stmt.o\t   \\\n  stor-layout.o stringpool.o timevar.o toplev.o tracer.o tree.o tree-dump.o \\\n  tree-inline.o unroll.o varasm.o varray.o version.o vmsdbgout.o xcoffout.o \\\n- alloc-pool.o et-forest.o cgraph.o cgraphunit.o cfghooks.o\t\t   \\\n+ alloc-pool.o et-forest.o cgraph.o cgraphunit.o cfghooks.o bt-load.o\t   \\\n  $(GGC) $(out_object_file) $(EXTRA_OBJS) $(host_hook_obj)\n \n BACKEND = main.o libbackend.a\n@@ -1726,6 +1726,9 @@ reload1.o : reload1.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) real.\n caller-save.o : caller-save.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    flags.h $(REGS_H) hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) function.h \\\n    $(RECOG_H) reload.h $(EXPR_H) toplev.h $(TM_P_H)\n+bt-load.o : bt-load.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(BASIC_BLOCK_H) $(RTL_H) hard-reg-set.h $(REGS_H) $(OBSTACK_H) \\\n+   $(FIBHEAP_H) output.h $(TARGET_H) $(EXPR_H) flags.h $(INSN_ATTR_H)\n reorg.o : reorg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) conditions.h \\\n    hard-reg-set.h $(BASIC_BLOCK_H) $(REGS_H) insn-config.h $(INSN_ATTR_H) except.h \\\n    $(RECOG_H) function.h flags.h output.h $(EXPR_H) toplev.h $(PARAMS_H) $(TM_P_H)"}, {"sha": "dd2dcb2b16bf44dde29b2387be0afd42556fee2a", "filename": "gcc/bt-load.c", "status": "added", "additions": 1380, "deletions": 0, "changes": 1380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=fe3ad57221f647b880567025bf825dcca9b7174a", "patch": "@@ -0,0 +1,1380 @@\n+/* Perform branch target register load optimizations.\n+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"bitmap.h\"\n+#include \"sbitmap.h\"\n+#include \"rtl.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"regs.h\"\n+#include \"obstack.h\"\n+#include \"fibheap.h\"\n+#include \"output.h\"\n+#include \"target.h\"\n+#include \"expr.h\"\n+#include \"flags.h\"\n+#include \"insn-attr.h\"\n+#include \"function.h\"\n+\n+/* Target register optimizations - these are performed after reload.  */\n+\n+typedef struct btr_def_group_s\n+{\n+  struct btr_def_group_s *next;\n+  rtx src;\n+  struct btr_def_s *members;\n+} *btr_def_group;\n+\n+typedef struct btr_user_s\n+{\n+  struct btr_user_s *next;\n+  basic_block bb;\n+  int luid;\n+  rtx insn;\n+  /* If INSN has a single use of a single branch register, then\n+     USE points to it within INSN.  If there is more than\n+     one branch register use, or the use is in some way ambiguous,\n+     then USE is NULL.  */\n+  rtx use;\n+  int n_reaching_defs;\n+  int first_reaching_def;\n+  char other_use_this_block;\n+} *btr_user;\n+\n+/* btr_def structs appear on three lists:\n+     1. A list of all btr_def structures (head is\n+\tALL_BTR_DEFS, linked by the NEXT field).\n+     2. A list of branch reg definitions per basic block (head is\n+\tBB_BTR_DEFS[i], linked by the NEXT_THIS_BB field).\n+     3. A list of all branch reg definitions belonging to the same\n+\tgroup (head is in a BTR_DEF_GROUP struct, linked by\n+\tNEXT_THIS_GROUP field).  */\n+\n+typedef struct btr_def_s\n+{\n+  struct btr_def_s *next_this_bb;\n+  struct btr_def_s *next_this_group;\n+  basic_block bb;\n+  int luid;\n+  rtx insn;\n+  int btr;\n+  int cost;\n+  /* For a branch register setting insn that has a constant\n+     source (i.e. a label), group links together all the\n+     insns with the same source.  For other branch register\n+     setting insns, group is NULL.  */\n+  btr_def_group group;\n+  btr_user uses;\n+  /* If this def has a reaching use which is not a simple use\n+     in a branch instruction, then has_ambiguous_use will be true,\n+     and we will not attempt to migrate this definition.       */\n+  char has_ambiguous_use;\n+  /* live_range is an approximation to the true live range for this\n+     def/use web, because it records the set of blocks that contain\n+     the live range.  There could be other live ranges for the same\n+     branch register in that set of blocks, either in the block\n+     containing the def (before the def), or in a block containing\n+     a use (after the use).  If there are such other live ranges, then\n+     other_btr_uses_before_def or other_btr_uses_after_use must be set true\n+     as appropriate. */\n+  char other_btr_uses_before_def;\n+  char other_btr_uses_after_use;\n+  bitmap live_range;\n+} *btr_def;\n+\n+static int issue_rate;\n+\n+static int basic_block_freq (basic_block);\n+static int insn_sets_btr_p (rtx, int, int *);\n+static rtx *find_btr_use (rtx);\n+static int btr_referenced_p (rtx, rtx *);\n+static int find_btr_reference (rtx *, void *);\n+static void find_btr_def_group (btr_def_group *, btr_def);\n+static btr_def add_btr_def (fibheap_t, basic_block, int, rtx,\n+\t\t\t    unsigned int, int, btr_def_group *);\n+static btr_user new_btr_user (basic_block, int, rtx);\n+static void dump_hard_reg_set (HARD_REG_SET);\n+static void dump_btrs_live (int);\n+static void note_other_use_this_block (unsigned int, btr_user);\n+static void compute_defs_uses_and_gen (fibheap_t, btr_def *,btr_user *,\n+\t\t\t\t       sbitmap *, sbitmap *, HARD_REG_SET *);\n+static void compute_kill (sbitmap *, sbitmap *, HARD_REG_SET *);\n+static void compute_out (sbitmap *bb_out, sbitmap *, sbitmap *, int);\n+static void link_btr_uses (btr_def *, btr_user *, sbitmap *, sbitmap *, int);\n+static void build_btr_def_use_webs (fibheap_t);\n+static int block_at_edge_of_live_range_p (int, btr_def);\n+static void clear_btr_from_live_range (btr_def def);\n+static void add_btr_to_live_range (btr_def);\n+static void augment_live_range (bitmap, HARD_REG_SET *, basic_block,\n+\t\t\t\tbasic_block);\n+static int choose_btr (HARD_REG_SET);\n+static void combine_btr_defs (btr_def, HARD_REG_SET *);\n+static void btr_def_live_range (btr_def, HARD_REG_SET *);\n+static void move_btr_def (basic_block, int, btr_def, bitmap, HARD_REG_SET *);\n+static int migrate_btr_def (btr_def, int);\n+static void migrate_btr_defs (enum reg_class, int);\n+static int can_move_up (basic_block, rtx, int);\n+static void note_btr_set (rtx, rtx, void *);\n+\f\n+/* The following code performs code motion of target load instructions\n+   (instructions that set branch target registers), to move them\n+   forward away from the branch instructions and out of loops (or,\n+   more generally, from a more frequently executed place to a less\n+   frequently executed place).\n+   Moving target load instructions further in front of the branch\n+   instruction that uses the target register value means that the hardware\n+   has a better chance of preloading the instructions at the branch\n+   target by the time the branch is reached.  This avoids bubbles\n+   when a taken branch needs to flush out the pipeline.\n+   Moving target load instructions out of loops means they are executed\n+   less frequently.  */\n+\n+/* An obstack to hold the def-use web data structures built up for\n+   migrating branch target load instructions.  */\n+static struct obstack migrate_btrl_obstack;\n+\n+/* Basic block dominator information used when migrating PT instructions */\n+static dominance_info dom;\n+\n+/* Array indexed by basic block number, giving the set of registers\n+   live in that block.  */\n+static HARD_REG_SET *btrs_live;\n+\n+/* Set of all target registers that we are willing to allocate.  */\n+static HARD_REG_SET all_btrs;\n+\n+/* Provide lower and upper bounds for target register numbers, so that\n+   we don't need to search through all the hard registers all the time.  */\n+static int first_btr, last_btr;\n+\n+\n+\n+/* Return an estimate of the frequency of execution of block bb.\n+   If we have a profiling count available, we could use it here.  */\n+static int\n+basic_block_freq (basic_block bb)\n+{\n+  return bb->frequency;\n+}\n+\n+static rtx *btr_reference_found;\n+\n+/* A subroutine of btr_referenced_p, called through for_each_rtx.\n+   PREG is a pointer to an rtx that is to be excluded from the\n+   traversal.  If we find a reference to a target register anywhere\n+   else, return 1, and put a pointer to it into btr_reference_found.  */\n+static int\n+find_btr_reference (rtx *px, void *preg)\n+{\n+  rtx x;\n+  int regno, i;\n+\n+  if (px == preg)\n+    return -1;\n+  x = *px;\n+  if (GET_CODE (x) != REG)\n+    return 0;\n+  regno = REGNO (x);\n+  for (i = HARD_REGNO_NREGS (regno, GET_MODE (x)) - 1; i >= 0; i--)\n+    if (TEST_HARD_REG_BIT (all_btrs, regno+i))\n+      {\n+\tbtr_reference_found = px;\n+\treturn 1;\n+      }\n+  return -1;\n+}\n+\n+/* Return nonzero if X references (sets or reads) any branch target register.\n+   If EXCLUDEP is set, disregard any references within the rtx pointed to\n+   by it.  If returning nonzero, also set btr_reference_found as above.  */\n+static int\n+btr_referenced_p (rtx x, rtx *excludep)\n+{\n+  return for_each_rtx (&x, find_btr_reference, excludep);\n+}\n+\n+/* Return true if insn is an instruction that sets a target register.\n+   if CHECK_CONST is true, only return true if the source is constant.\n+   If such a set is found and REGNO is nonzero, assign the register number\n+   of the destination register to *REGNO.  */\n+static int\n+insn_sets_btr_p (rtx insn, int check_const, int *regno)\n+{\n+  rtx set;\n+\n+  if (GET_CODE (insn) == INSN\n+      && (set = single_set (insn)))\n+    {\n+      rtx dest = SET_DEST (set);\n+      rtx src = SET_SRC (set);\n+\n+      if (GET_CODE (dest) == SUBREG)\n+\tdest = XEXP (dest, 0);\n+\n+      if (GET_CODE (dest) == REG\n+\t  && TEST_HARD_REG_BIT (all_btrs, REGNO (dest)))\n+\t{\n+\t  if (btr_referenced_p (src, NULL))\n+\t    abort();\n+\t  if (!check_const || CONSTANT_P (src))\n+\t    {\n+\t      if (regno)\n+\t\t*regno = REGNO (dest);\n+\t      return 1;\n+\t    }\n+\t}\n+    }\n+  return 0;\n+}\n+\n+/* Find and return a use of a target register within an instruction INSN. */\n+static rtx *\n+find_btr_use (rtx insn)\n+{\n+  return btr_referenced_p (insn, NULL) ? btr_reference_found : NULL;\n+}\n+\n+/* Find the group that the target register definition DEF belongs\n+   to in the list starting with *ALL_BTR_DEF_GROUPS.  If no such\n+   group exists, create one.  Add def to the group.  */\n+static void\n+find_btr_def_group (btr_def_group *all_btr_def_groups, btr_def def)\n+{\n+  if (insn_sets_btr_p (def->insn, 1, NULL))\n+    {\n+      btr_def_group this_group;\n+      rtx def_src = SET_SRC (single_set (def->insn));\n+\n+      /* ?? This linear search is an efficiency concern, particularly\n+\t as the search will almost always fail to find a match.  */\n+      for (this_group = *all_btr_def_groups;\n+\t   this_group != NULL;\n+\t   this_group = this_group->next)\n+\tif (rtx_equal_p (def_src, this_group->src))\n+\t  break;\n+\n+      if (!this_group)\n+\t{\n+\t  this_group = (btr_def_group)\n+\t    obstack_alloc (&migrate_btrl_obstack,\n+\t\t\t   sizeof (struct btr_def_group_s));\n+\t  this_group->src = def_src;\n+\t  this_group->members = NULL;\n+\t  this_group->next = *all_btr_def_groups;\n+\t  *all_btr_def_groups = this_group;\n+\t}\n+      def->group = this_group;\n+      def->next_this_group = this_group->members;\n+      this_group->members = def;\n+    }\n+  else\n+    def->group = NULL;\n+}\n+\n+/* Create a new target register definition structure, for a definition in\n+   block BB, instruction INSN, and insert it into ALL_BTR_DEFS.  Return\n+   the new definition.  */\n+static btr_def\n+add_btr_def (fibheap_t all_btr_defs, basic_block bb, int insn_luid, rtx insn,\n+\t     unsigned int dest_reg, int other_btr_uses_before_def,\n+\t     btr_def_group *all_btr_def_groups)\n+{\n+  btr_def this = (btr_def)\n+    obstack_alloc (&migrate_btrl_obstack, sizeof (struct btr_def_s));\n+  this->bb = bb;\n+  this->luid = insn_luid;\n+  this->insn = insn;\n+  this->btr = dest_reg;\n+  this->cost = basic_block_freq (bb);\n+  this->has_ambiguous_use = 0;\n+  this->other_btr_uses_before_def = other_btr_uses_before_def;\n+  this->other_btr_uses_after_use = 0;\n+  this->next_this_bb = NULL;\n+  this->next_this_group = NULL;\n+  this->uses = NULL;\n+  this->live_range = NULL;\n+  find_btr_def_group (all_btr_def_groups, this);\n+\n+  fibheap_insert (all_btr_defs, -this->cost, this);\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file,\n+      \"Found target reg definition: sets %u { bb %d, insn %d }%s priority %d\\n\",\n+      dest_reg, bb->index, INSN_UID (insn), (this->group ? \"\" : \":not const\"),\n+      this->cost);\n+\n+  return this;\n+}\n+\n+/* Create a new target register user structure, for a use in block BB,\n+   instruction INSN.  Return the new user.  */\n+static btr_user\n+new_btr_user (basic_block bb, int insn_luid, rtx insn)\n+{\n+  /* This instruction reads target registers.  We need\n+     to decide whether we can replace all target register\n+     uses easily.\n+   */\n+  rtx *usep = find_btr_use (PATTERN (insn));\n+  rtx use;\n+  btr_user user = NULL;\n+\n+  if (usep)\n+    {\n+      int unambiguous_single_use;\n+\n+      /* We want to ensure that USE is the only use of a target\n+\t register in INSN, so that we know that to rewrite INSN to use\n+\t a different target register, all we have to do is replace USE.  */\n+      unambiguous_single_use = !btr_referenced_p (PATTERN (insn), usep);\n+      if (!unambiguous_single_use)\n+\tusep = NULL;\n+    }\n+  use = usep ? *usep : NULL_RTX;\n+  user = (btr_user)\n+    obstack_alloc (&migrate_btrl_obstack, sizeof (struct btr_user_s));\n+  user->bb = bb;\n+  user->luid = insn_luid;\n+  user->insn = insn;\n+  user->use = use;\n+  user->other_use_this_block = 0;\n+  user->next = NULL;\n+  user->n_reaching_defs = 0;\n+  user->first_reaching_def = -1;\n+\n+  if (rtl_dump_file)\n+    {\n+      fprintf (rtl_dump_file, \"Uses target reg: { bb %d, insn %d }\",\n+\t       bb->index, INSN_UID (insn));\n+\n+      if (user->use)\n+\tfprintf (rtl_dump_file, \": unambiguous use of reg %d\\n\",\n+\t\t REGNO (user->use));\n+    }\n+\n+  return user;\n+}\n+\n+/* Write the contents of S to the dump file. */\n+static void\n+dump_hard_reg_set (HARD_REG_SET s)\n+{\n+  int reg;\n+  for (reg = 0; reg < FIRST_PSEUDO_REGISTER; reg++)\n+    if (TEST_HARD_REG_BIT (s, reg))\n+      fprintf (rtl_dump_file, \" %d\", reg);\n+}\n+\n+/* Write the set of target regs live in block BB to the dump file. */\n+static void\n+dump_btrs_live (int bb)\n+{\n+  fprintf (rtl_dump_file, \"BB%d live:\", bb);\n+  dump_hard_reg_set (btrs_live[bb]);\n+  fprintf (rtl_dump_file, \"\\n\");\n+}\n+\n+/* REGNO is the number of a branch target register that is being used or\n+   set.  USERS_THIS_BB is a list of preceding branch target register users;\n+   If any of them use the same register, set their other_use_this_block\n+   flag.  */\n+static void\n+note_other_use_this_block (unsigned int regno, btr_user users_this_bb)\n+{\n+  btr_user user;\n+\n+  for (user = users_this_bb; user != NULL; user = user->next)\n+    if (user->use && REGNO (user->use) == regno)\n+      user->other_use_this_block = 1;\n+}\n+\n+typedef struct {\n+  btr_user users_this_bb;\n+  HARD_REG_SET btrs_written_in_block;\n+  HARD_REG_SET btrs_live_in_block;\n+  sbitmap bb_gen;\n+  sbitmap *btr_defset;\n+} defs_uses_info;\n+\n+/* Called via note_stores or directly to register stores into /\n+   clobbers of a branch target register DEST that are not recognized as\n+   straightforward definitions.  DATA points to information about the\n+   current basic block that needs updating.   */\n+static void\n+note_btr_set (rtx dest, rtx set ATTRIBUTE_UNUSED, void *data)\n+{\n+  defs_uses_info *info = data;\n+  int regno, end_regno;\n+\n+  if (GET_CODE (dest) != REG)\n+    return;\n+  regno = REGNO (dest);\n+  end_regno = regno + HARD_REGNO_NREGS (regno, GET_MODE (dest));\n+  for (; regno < end_regno; regno++)\n+    if (TEST_HARD_REG_BIT (all_btrs, regno))\n+      {\n+\tnote_other_use_this_block (regno, info->users_this_bb);\n+\tSET_HARD_REG_BIT (info->btrs_written_in_block, regno);\n+\tSET_HARD_REG_BIT (info->btrs_live_in_block, regno);\n+\tsbitmap_difference (info->bb_gen, info->bb_gen,\n+\t\t\t    info->btr_defset[regno - first_btr]);\n+      }\n+}\n+\n+static void\n+compute_defs_uses_and_gen (fibheap_t all_btr_defs, btr_def *def_array,\n+\t\t\t   btr_user *use_array, sbitmap *btr_defset,\n+\t\t\t   sbitmap *bb_gen, HARD_REG_SET *btrs_written)\n+{\n+  /* Scan the code building up the set of all defs and all uses.\n+     For each target register, build the set of defs of that register.\n+     For each block, calculate the set of target registers\n+     written in that block.\n+     Also calculate the set of btrs ever live in that block.\n+  */\n+  int i;\n+  int insn_luid = 0;\n+  btr_def_group all_btr_def_groups = NULL;\n+  defs_uses_info info;\n+\n+  sbitmap_vector_zero (bb_gen, n_basic_blocks);\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+      int reg;\n+      btr_def defs_this_bb = NULL;\n+      rtx insn;\n+      rtx last;\n+\n+      info.users_this_bb = NULL;\n+      info.bb_gen = bb_gen[i];\n+      info.btr_defset = btr_defset;\n+\n+      CLEAR_HARD_REG_SET (info.btrs_live_in_block);\n+      CLEAR_HARD_REG_SET (info.btrs_written_in_block);\n+      for (reg = first_btr; reg <= last_btr; reg++)\n+\tif (TEST_HARD_REG_BIT (all_btrs, reg)\n+\t    && REGNO_REG_SET_P (bb->global_live_at_start, reg))\n+\t  SET_HARD_REG_BIT (info.btrs_live_in_block, reg);\n+\n+      for (insn = bb->head, last = NEXT_INSN (bb->end);\n+\t   insn != last;\n+\t   insn = NEXT_INSN (insn), insn_luid++)\n+\t{\n+\t  if (INSN_P (insn))\n+\t    {\n+\t      int regno;\n+\t      int insn_uid = INSN_UID (insn);\n+\n+\t      if (insn_sets_btr_p (insn, 0, &regno))\n+\t\t{\n+\t\t  btr_def def = add_btr_def (\n+\t\t      all_btr_defs, bb, insn_luid, insn, regno,\n+\t\t      TEST_HARD_REG_BIT (info.btrs_live_in_block, regno),\n+\t\t      &all_btr_def_groups);\n+\n+\t\t  def_array[insn_uid] = def;\n+\t\t  SET_HARD_REG_BIT (info.btrs_written_in_block, regno);\n+\t\t  SET_HARD_REG_BIT (info.btrs_live_in_block, regno);\n+\t\t  sbitmap_difference (bb_gen[i], bb_gen[i],\n+\t\t\t\t      btr_defset[regno - first_btr]);\n+\t\t  SET_BIT (bb_gen[i], insn_uid);\n+\t\t  def->next_this_bb = defs_this_bb;\n+\t\t  defs_this_bb = def;\n+\t\t  SET_BIT (btr_defset[regno - first_btr], insn_uid);\n+\t\t  note_other_use_this_block (regno, info.users_this_bb);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (btr_referenced_p (PATTERN (insn), NULL))\n+\t\t    {\n+\t\t      btr_user user = new_btr_user (bb, insn_luid, insn);\n+\n+\t\t      use_array[insn_uid] = user;\n+\t\t      if (user->use)\n+\t\t\tSET_HARD_REG_BIT (info.btrs_live_in_block,\n+\t\t\t\t\t  REGNO (user->use));\n+\t\t      else\n+\t\t\t{\n+\t\t\t  int reg;\n+\t\t\t  for (reg = first_btr; reg <= last_btr; reg++)\n+\t\t\t    if (TEST_HARD_REG_BIT (all_btrs, reg)\n+\t\t\t\t&& refers_to_regno_p (reg, reg + 1, user->insn,\n+\t\t\t\t\t\t      NULL))\n+\t\t\t      {\n+\t\t\t\tnote_other_use_this_block (reg,\n+\t\t\t\t\t\t\t   info.users_this_bb);\n+\t\t\t\tSET_HARD_REG_BIT (info.btrs_live_in_block, reg);\n+\t\t\t      }\n+\t\t\t  note_stores (PATTERN (insn), note_btr_set, &info);\n+\t\t\t}\n+\t\t      user->next = info.users_this_bb;\n+\t\t      info.users_this_bb = user;\n+\t\t    }\n+\t\t  if (GET_CODE (insn) == CALL_INSN)\n+\t\t    {\n+\t\t      HARD_REG_SET *clobbered = &call_used_reg_set;\n+\t\t      HARD_REG_SET call_saved;\n+\t\t      rtx pat = PATTERN (insn);\n+\t\t      int i;\n+\n+\t\t      /* Check for sibcall.  */\n+\t\t      if (GET_CODE (pat) == PARALLEL)\n+\t\t\tfor (i = XVECLEN (pat, 0) - 1; i >= 0; i--)\n+\t\t\t  if (GET_CODE (XVECEXP (pat, 0, i)) == RETURN)\n+\t\t\t    {\n+\t\t\t      COMPL_HARD_REG_SET (call_saved,\n+\t\t\t\t\t\t  call_used_reg_set);\n+\t\t\t      clobbered = &call_saved;\n+\t\t\t    }\n+\t\t\t      \n+\t\t      for (regno = first_btr; regno <= last_btr; regno++)\n+\t\t\tif (TEST_HARD_REG_BIT (*clobbered, regno))\n+\t\t\t  note_btr_set (regno_reg_rtx[regno], NULL_RTX, &info);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      COPY_HARD_REG_SET (btrs_live[i], info.btrs_live_in_block);\n+      COPY_HARD_REG_SET (btrs_written[i], info.btrs_written_in_block);\n+      if (rtl_dump_file)\n+\tdump_btrs_live(i);\n+    }\n+}\n+\n+static void\n+compute_kill (sbitmap *bb_kill, sbitmap *btr_defset,\n+\t      HARD_REG_SET *btrs_written)\n+{\n+  int i;\n+  int regno;\n+\n+  /* For each basic block, form the set BB_KILL - the set\n+     of definitions that the block kills. */\n+  sbitmap_vector_zero (bb_kill, n_basic_blocks);\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      for (regno = first_btr; regno <= last_btr; regno++)\n+\tif (TEST_HARD_REG_BIT (all_btrs, regno)\n+\t    && TEST_HARD_REG_BIT (btrs_written[i], regno))\n+\t  sbitmap_a_or_b (bb_kill[i], bb_kill[i],\n+\t\t\t  btr_defset[regno - first_btr]);\n+    }\n+}\n+\n+static void\n+compute_out (sbitmap *bb_out, sbitmap *bb_gen, sbitmap *bb_kill, int max_uid)\n+{\n+  /* Perform iterative dataflow:\n+      Initially, for all blocks, BB_OUT = BB_GEN.\n+      For each block,\n+\tBB_IN  = union over predecessors of BB_OUT(pred)\n+\tBB_OUT = (BB_IN - BB_KILL) + BB_GEN\n+     Iterate until the bb_out sets stop growing.   */\n+  int i;\n+  int changed;\n+  sbitmap bb_in = sbitmap_alloc (max_uid);\n+\n+  for (i = 0; i < n_basic_blocks; i++)\n+    sbitmap_copy (bb_out[i], bb_gen[i]);\n+\n+  changed = 1;\n+  while (changed)\n+    {\n+      changed = 0;\n+      for (i = 0; i < n_basic_blocks; i++)\n+\t{\n+\t  sbitmap_union_of_preds (bb_in, bb_out, i);\n+\t  changed |= sbitmap_union_of_diff_cg (bb_out[i], bb_gen[i],\n+\t\t\t\t\t       bb_in, bb_kill[i]);\n+\t}\n+    }\n+  sbitmap_free (bb_in);\n+}\n+\n+static void\n+link_btr_uses (btr_def *def_array, btr_user *use_array, sbitmap *bb_out,\n+\t       sbitmap *btr_defset, int max_uid)\n+{\n+  int i;\n+  sbitmap reaching_defs = sbitmap_alloc (max_uid);\n+\n+  /* Link uses to the uses lists of all of their reaching defs.\n+     Count up the number of reaching defs of each use. */\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+      rtx insn;\n+      rtx last;\n+\n+      sbitmap_union_of_preds (reaching_defs, bb_out, i);\n+      for (insn = bb->head, last = NEXT_INSN (bb->end);\n+\t   insn != last;\n+\t   insn = NEXT_INSN (insn))\n+\t{\n+\t  if (INSN_P (insn))\n+\t    {\n+\t      int insn_uid = INSN_UID (insn);\n+\n+\t      btr_def def   = def_array[insn_uid];\n+\t      btr_user user = use_array[insn_uid];\n+\t      if (def != NULL)\n+\t\t{\n+\t\t  /* Remove all reaching defs of regno except\n+\t\t     for this one. */\n+\t\t  sbitmap_difference (reaching_defs, reaching_defs,\n+\t\t\t\t      btr_defset[def->btr - first_btr]);\n+\t\t  SET_BIT(reaching_defs, insn_uid);\n+\t\t}\n+\n+\t      if (user != NULL)\n+\t\t{\n+\t\t  /* Find all the reaching defs for this use */\n+\t\t  sbitmap reaching_defs_of_reg = sbitmap_alloc(max_uid);\n+\t\t  int uid;\n+\n+\t\t  if (user->use)\n+\t\t    sbitmap_a_and_b (\n+\t\t      reaching_defs_of_reg,\n+\t\t      reaching_defs,\n+\t\t      btr_defset[REGNO (user->use) - first_btr]);\n+\t\t  else\n+\t\t    {\n+\t\t      int reg;\n+\n+\t\t      sbitmap_zero (reaching_defs_of_reg);\n+\t\t      for (reg = first_btr; reg <= last_btr; reg++)\n+\t\t\tif (TEST_HARD_REG_BIT (all_btrs, reg)\n+\t\t\t    && refers_to_regno_p (reg, reg + 1, user->insn,\n+\t\t\t\t\t\t  NULL))\n+\t\t\t  sbitmap_a_or_b_and_c (reaching_defs_of_reg,\n+\t\t\t    reaching_defs_of_reg,\n+\t\t\t    reaching_defs,\n+\t\t\t    btr_defset[reg - first_btr]);\n+\t\t    }\n+\t\t  EXECUTE_IF_SET_IN_SBITMAP (reaching_defs_of_reg, 0, uid,\n+\t\t    {\n+\t\t      btr_def def = def_array[uid];\n+\n+\t\t      /* We now know that def reaches user */\n+\n+\t\t      if (rtl_dump_file)\n+\t\t\tfprintf (rtl_dump_file,\n+\t\t\t  \"Def in insn %d reaches use in insn %d\\n\",\n+\t\t\t  uid, insn_uid);\n+\n+\t\t      user->n_reaching_defs++;\n+\t\t      if (!user->use)\n+\t\t\tdef->has_ambiguous_use = 1;\n+\t\t      if (user->first_reaching_def != -1)\n+\t\t\t{ /* There is more than one reaching def.  This is\n+\t\t\t     a rare case, so just give up on this def/use\n+\t\t\t     web when it occurs. */\n+\t\t\t  def->has_ambiguous_use = 1;\n+\t\t\t  def_array[user->first_reaching_def]\n+\t\t\t    ->has_ambiguous_use = 1;\n+\t\t\t  if (rtl_dump_file)\n+\t\t\t    fprintf (rtl_dump_file,\n+\t\t\t\t     \"(use %d has multiple reaching defs)\\n\",\n+\t\t\t\t     insn_uid);\n+\t\t\t}\n+\t\t      else\n+\t\t\tuser->first_reaching_def = uid;\n+\t\t      if (user->other_use_this_block)\n+\t\t\tdef->other_btr_uses_after_use = 1;\n+\t\t      user->next = def->uses;\n+\t\t      def->uses = user;\n+\t\t    });\n+\t\t  sbitmap_free (reaching_defs_of_reg);\n+\t\t}\n+\n+\t      if (GET_CODE (insn) == CALL_INSN)\n+\t\t{\n+\t\t  int regno;\n+\n+\t\t  for (regno = first_btr; regno <= last_btr; regno++)\n+\t\t    if (TEST_HARD_REG_BIT (all_btrs, regno)\n+\t\t\t&& TEST_HARD_REG_BIT (call_used_reg_set, regno))\n+\t\t      sbitmap_difference (reaching_defs, reaching_defs,\n+\t\t\t\t\t  btr_defset[regno - first_btr]);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  sbitmap_free (reaching_defs);\n+}\n+\n+static void\n+build_btr_def_use_webs (fibheap_t all_btr_defs)\n+{\n+  const int max_uid = get_max_uid ();\n+  btr_def  *def_array   = xcalloc (max_uid, sizeof (btr_def));\n+  btr_user *use_array   = xcalloc (max_uid, sizeof (btr_user));\n+  sbitmap *btr_defset   = sbitmap_vector_alloc (\n+\t\t\t   (last_btr - first_btr) + 1, max_uid);\n+  sbitmap *bb_gen      = sbitmap_vector_alloc (n_basic_blocks, max_uid);\n+  HARD_REG_SET *btrs_written = (HARD_REG_SET *) xcalloc (\n+\t\t\t       n_basic_blocks, sizeof (HARD_REG_SET));\n+  sbitmap *bb_kill;\n+  sbitmap *bb_out;\n+\n+  sbitmap_vector_zero (btr_defset, (last_btr - first_btr) + 1);\n+\n+  compute_defs_uses_and_gen (all_btr_defs, def_array, use_array, btr_defset,\n+\t\t\t     bb_gen, btrs_written);\n+\n+  bb_kill = sbitmap_vector_alloc (n_basic_blocks, max_uid);\n+  compute_kill (bb_kill, btr_defset, btrs_written);\n+  free (btrs_written);\n+\n+  bb_out = sbitmap_vector_alloc (n_basic_blocks, max_uid);\n+  compute_out (bb_out, bb_gen, bb_kill, max_uid);\n+\n+  sbitmap_vector_free (bb_gen);\n+  sbitmap_vector_free (bb_kill);\n+\n+  link_btr_uses (def_array, use_array, bb_out, btr_defset, max_uid);\n+\n+  sbitmap_vector_free (bb_out);\n+  sbitmap_vector_free (btr_defset);\n+  free (use_array);\n+  free (def_array);\n+}\n+\n+/* Return true if basic block BB contains the start or end of the\n+   live range of the definition DEF, AND there are other live\n+   ranges of the same target register that include BB.  */\n+static int\n+block_at_edge_of_live_range_p (int bb, btr_def def)\n+{\n+  if (def->other_btr_uses_before_def && BASIC_BLOCK (bb) == def->bb)\n+    return 1;\n+  else if (def->other_btr_uses_after_use)\n+    {\n+      btr_user user;\n+      for (user = def->uses; user != NULL; user = user->next)\n+\tif (BASIC_BLOCK (bb) == user->bb)\n+\t  return 1;\n+    }\n+  return 0;\n+}\n+\n+/* We are removing the def/use web DEF.  The target register\n+   used in this web is therefore no longer live in the live range\n+   of this web, so remove it from the live set of all basic blocks\n+   in the live range of the web.\n+   Blocks at the boundary of the live range may contain other live\n+   ranges for the same target register, so we have to be careful\n+   to remove the target register from the live set of these blocks\n+   only if they do not contain other live ranges for the same register. */\n+static void\n+clear_btr_from_live_range (btr_def def)\n+{\n+  int bb;\n+\n+  EXECUTE_IF_SET_IN_BITMAP\n+    (def->live_range, 0, bb,\n+     {\n+       if ((!def->other_btr_uses_before_def\n+\t     && !def->other_btr_uses_after_use)\n+\t   || !block_at_edge_of_live_range_p (bb, def))\n+\t {\n+\t   CLEAR_HARD_REG_BIT (btrs_live[bb], def->btr);\n+\t   if (rtl_dump_file)\n+\t     dump_btrs_live (bb);\n+\t }\n+     });\n+}\n+\n+\n+/* We are adding the def/use web DEF.  Add the target register used\n+   in this web to the live set of all of the basic blocks that contain\n+   the live range of the web.  */\n+static void\n+add_btr_to_live_range (btr_def def)\n+{\n+  int bb;\n+  EXECUTE_IF_SET_IN_BITMAP\n+    (def->live_range, 0, bb,\n+     {\n+       SET_HARD_REG_BIT (btrs_live[bb], def->btr);\n+       if (rtl_dump_file)\n+\t dump_btrs_live (bb);\n+     });\n+}\n+\n+/* Update a live range to contain the basic block NEW_BLOCK, and all\n+   blocks on paths between the existing live range and NEW_BLOCK.\n+   HEAD is a block contained in the existing live range that dominates\n+   all other blocks in the existing live range.\n+   Also add to the set BTRS_LIVE_IN_RANGE all target registers that\n+   are live in the blocks that we add to the live range.\n+   It is a precondition that either NEW_BLOCK dominates HEAD,or\n+   HEAD dom NEW_BLOCK.  This is used to speed up the\n+   implementation of this function.  */\n+static void\n+augment_live_range (bitmap live_range, HARD_REG_SET *btrs_live_in_range,\n+\t\t    basic_block head_bb, basic_block new_bb)\n+{\n+  basic_block *worklist, *tos;\n+\n+  tos = worklist =\n+    (basic_block *) xmalloc (sizeof (basic_block) * (n_basic_blocks + 1));\n+\n+  if (dominated_by_p (dom, new_bb, head_bb))\n+    *tos++ = new_bb;\n+  else if (dominated_by_p (dom, head_bb, new_bb))\n+    {\n+      edge e;\n+      int new_block = new_bb->index;\n+\n+      bitmap_set_bit (live_range, new_block);\n+      IOR_HARD_REG_SET (*btrs_live_in_range, btrs_live[new_block]);\n+      if (rtl_dump_file)\n+\t{\n+\t  fprintf (rtl_dump_file,\n+\t\t   \"Adding block %d to live range\\n\", new_block);\n+\t  fprintf (rtl_dump_file,\"Now live btrs are \");\n+\t  dump_hard_reg_set (*btrs_live_in_range);\n+\t  fprintf (rtl_dump_file, \"\\n\");\n+\t}\n+      for (e = head_bb->pred; e; e = e->pred_next)\n+\t*tos++ = e->src;\n+    }\n+  else\n+    abort();\n+\n+  while (tos != worklist)\n+    {\n+      basic_block bb = *--tos;\n+      if (!bitmap_bit_p (live_range, bb->index))\n+\t{\n+\t  edge e;\n+\n+\t  bitmap_set_bit (live_range, bb->index);\n+\t  IOR_HARD_REG_SET (*btrs_live_in_range,\n+\t    btrs_live[bb->index]);\n+\t  if (rtl_dump_file)\n+\t    {\n+\t      fprintf (rtl_dump_file,\n+\t\t\"Adding block %d to live range\\n\", bb->index);\n+\t      fprintf (rtl_dump_file,\"Now live btrs are \");\n+\t      dump_hard_reg_set (*btrs_live_in_range);\n+\t      fprintf (rtl_dump_file, \"\\n\");\n+\t    }\n+\n+\t  for (e = bb->pred; e != NULL; e = e->pred_next)\n+\t    {\n+\t      basic_block pred = e->src;\n+\t      if (!bitmap_bit_p (live_range, pred->index))\n+\t\t*tos++ = pred;\n+\t    }\n+\t}\n+    }\n+\n+  free (worklist);\n+}\n+\n+/*  Return the most desirable target register that is not in\n+    the set USED_BTRS.  */\n+static int\n+choose_btr (HARD_REG_SET used_btrs)\n+{\n+  int i;\n+  GO_IF_HARD_REG_SUBSET (all_btrs, used_btrs, give_up);\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+#ifdef REG_ALLOC_ORDER\n+      int regno = reg_alloc_order[i];\n+#else\n+      int regno = i;\n+#endif\n+      if (TEST_HARD_REG_BIT (all_btrs, regno)\n+\t  && !TEST_HARD_REG_BIT (used_btrs, regno))\n+\treturn regno;\n+    }\n+give_up:\n+  return -1;\n+}\n+\n+/* Calculate the set of basic blocks that contain the live range of\n+   the def/use web DEF.\n+   Also calculate the set of target registers that are live at time\n+   in this live range, but ignore the live range represented by DEF\n+   when calculating this set.  */\n+static void\n+btr_def_live_range (btr_def def, HARD_REG_SET *btrs_live_in_range)\n+{\n+  if (!def->live_range)\n+    {\n+      btr_user user;\n+\n+      def->live_range = BITMAP_XMALLOC ();\n+\n+      bitmap_set_bit (def->live_range, def->bb->index);\n+      COPY_HARD_REG_SET (*btrs_live_in_range, btrs_live[def->bb->index]);\n+\n+      for (user = def->uses; user != NULL; user = user->next)\n+\taugment_live_range (def->live_range, btrs_live_in_range,\n+\t\t\t    def->bb, user->bb);\n+    }\n+  else\n+    {\n+      /* def->live_range is accurate, but we need to recompute\n+\t the set of target registers live over it, because migration\n+\t of other PT instructions may have affected it.\n+      */\n+      int bb;\n+\n+      CLEAR_HARD_REG_SET (*btrs_live_in_range);\n+      EXECUTE_IF_SET_IN_BITMAP\n+\t(def->live_range, 0, bb,\n+\t {\n+\t   IOR_HARD_REG_SET (*btrs_live_in_range,\n+\t     btrs_live[bb]);\n+\t });\n+    }\n+  if (!def->other_btr_uses_before_def &&\n+      !def->other_btr_uses_after_use)\n+    CLEAR_HARD_REG_BIT (*btrs_live_in_range, def->btr);\n+}\n+\n+/* Merge into the def/use web DEF any other def/use webs in the same\n+   group that are dominated by DEF, provided that there is a target\n+   register available to allocate to the merged web.  */\n+static void\n+combine_btr_defs (btr_def def, HARD_REG_SET *btrs_live_in_range)\n+{\n+  btr_def other_def;\n+\n+  for (other_def = def->group->members;\n+       other_def != NULL;\n+       other_def = other_def->next_this_group)\n+    {\n+      if (other_def != def\n+\t  && other_def->uses != NULL\n+\t  && ! other_def->has_ambiguous_use\n+\t  && dominated_by_p (dom, other_def->bb, def->bb))\n+\t{\n+\t  /* def->bb dominates the other def, so def and other_def could\n+\t     be combined. */\n+\t  /* Merge their live ranges, and get the set of\n+\t     target registers live over the merged range. */\n+\t  int btr;\n+\t  HARD_REG_SET combined_btrs_live;\n+\t  bitmap combined_live_range = BITMAP_XMALLOC ();\n+\t  btr_user user;\n+\n+\t  if (other_def->live_range == NULL)\n+\t    {\n+\t      HARD_REG_SET dummy_btrs_live_in_range;\n+\t      btr_def_live_range (other_def, &dummy_btrs_live_in_range);\n+\t    }\n+\t  COPY_HARD_REG_SET (combined_btrs_live, *btrs_live_in_range);\n+\t  bitmap_copy (combined_live_range, def->live_range);\n+\n+\t  for (user = other_def->uses; user != NULL; user = user->next)\n+\t    augment_live_range (combined_live_range, &combined_btrs_live,\n+\t\t\t\tdef->bb, user->bb);\n+\n+\t  btr = choose_btr (combined_btrs_live);\n+\t  if (btr != -1)\n+\t    {\n+\t      /* We can combine them */\n+\t      if (rtl_dump_file)\n+\t\tfprintf (rtl_dump_file,\n+\t\t\t \"Combining def in insn %d with def in insn %d\\n\",\n+\t\t\t INSN_UID (other_def->insn), INSN_UID (def->insn));\n+\n+\t      def->btr = btr;\n+\t      user = other_def->uses;\n+\t      while (user != NULL)\n+\t\t{\n+\t\t  btr_user next = user->next;\n+\n+\t\t  user->next = def->uses;\n+\t\t  def->uses = user;\n+\t\t  user = next;\n+\t\t}\n+\t      /* Combining def/use webs can make target registers live\n+\t\t after uses where they previously were not.  This means\n+\t\t some REG_DEAD notes may no longer be correct.  We could\n+\t\t be more precise about this if we looked at the combined\n+\t\t live range, but here I just delete any REG_DEAD notes\n+\t\t in case they are no longer correct. */\n+\t      for (user = def->uses; user != NULL; user = user->next)\n+\t\tremove_note (user->insn,\n+\t\t\t     find_regno_note (user->insn, REG_DEAD,\n+\t\t\t\t\t      REGNO (user->use)));\n+\t      clear_btr_from_live_range (other_def);\n+\t      other_def->uses = NULL;\n+\t      bitmap_copy (def->live_range, combined_live_range);\n+\t      if (other_def->other_btr_uses_after_use)\n+\t\tdef->other_btr_uses_after_use = 1;\n+\t      COPY_HARD_REG_SET (*btrs_live_in_range, combined_btrs_live);\n+\n+\t      /* Delete the old target register initialization */\n+\t      delete_insn (other_def->insn);\n+\n+\t    }\n+\t  BITMAP_XFREE (combined_live_range);\n+\t}\n+    }\n+}\n+\n+/* Move the definition DEF from its current position to basic\n+   block NEW_DEF_BB, and modify it to use branch target register BTR.\n+   Delete the old defining insn, and insert a new one in NEW_DEF_BB.\n+   Update all reaching uses of DEF in the RTL to use BTR.\n+   If this new position means that other defs in the\n+   same group can be combined with DEF then combine them.  */\n+static void\n+move_btr_def (basic_block new_def_bb, int btr, btr_def def, bitmap live_range,\n+\t     HARD_REG_SET *btrs_live_in_range)\n+{\n+  /* We can move the instruction.\n+     Set a target register in block NEW_DEF_BB to the value\n+     needed for this target register definition.\n+     Replace all uses of the old target register definition by\n+     uses of the new definition.  Delete the old definition. */\n+  basic_block b = new_def_bb;\n+  rtx insp = b->head;\n+  rtx old_insn = def->insn;\n+  rtx src;\n+  rtx btr_rtx;\n+  rtx new_insn;\n+  enum machine_mode btr_mode;\n+  btr_user user;\n+  rtx set;\n+\n+  if (rtl_dump_file)\n+    fprintf(rtl_dump_file, \"migrating to basic block %d, using reg %d\\n\",\n+\t    new_def_bb->index, btr);\n+\n+  clear_btr_from_live_range (def);\n+  def->btr = btr;\n+  def->bb = new_def_bb;\n+  def->luid = 0;\n+  def->cost = basic_block_freq (new_def_bb);\n+  def->other_btr_uses_before_def = 0;\n+  bitmap_copy (def->live_range, live_range);\n+  combine_btr_defs (def, btrs_live_in_range);\n+  btr = def->btr;\n+  add_btr_to_live_range (def);\n+  if (GET_CODE (insp) == CODE_LABEL)\n+    insp = NEXT_INSN (insp);\n+  /* N.B.: insp is expected to be NOTE_INSN_BASIC_BLOCK now.  Some\n+     optimizations can result in insp being both first and last insn of\n+     its basic block.  */\n+  /* ?? some assertions to check that insp is sensible? */\n+\n+  set = single_set (old_insn);\n+  src = SET_SRC (set);\n+  btr_mode = GET_MODE (SET_DEST (set));\n+  btr_rtx = gen_rtx (REG, btr_mode, btr);\n+\n+  new_insn = gen_move_insn (btr_rtx, src);\n+\n+  /* Insert target register initialization at head of basic block. */\n+  def->insn = emit_insn_after (new_insn, insp);\n+\n+  regs_ever_live[btr] = 1;\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"New pt is insn %d, inserted after insn %d\\n\",\n+\t     INSN_UID (def->insn), INSN_UID (insp));\n+\n+  /* Delete the old target register initialization */\n+  delete_insn (old_insn);\n+\n+  /* Replace each use of the old target register by a use of the new target\n+     register. */\n+  for (user = def->uses; user != NULL; user = user->next)\n+    {\n+      /* Some extra work here to ensure consistent modes, because\n+\t it seems that a target register REG rtx can be given a different\n+\t mode depending on the context (surely that should not be\n+\t the case?). */\n+      rtx replacement_rtx;\n+      if (GET_MODE (user->use) == GET_MODE (btr_rtx)\n+\t  || GET_MODE (user->use) == VOIDmode)\n+\treplacement_rtx = btr_rtx;\n+      else\n+\treplacement_rtx = gen_rtx (REG, GET_MODE (user->use), btr);\n+      replace_rtx (user->insn, user->use, replacement_rtx);\n+      user->use = replacement_rtx;\n+    }\n+}\n+\n+/* We anticipate intra-block scheduling to be done.  See if INSN could move\n+   up within BB by N_INSNS.  */\n+static int\n+can_move_up (basic_block bb, rtx insn, int n_insns)\n+{\n+  while (insn != bb->head && n_insns > 0)\n+    {\n+      insn = PREV_INSN (insn);\n+      /* ??? What if we have an anti-dependency that actually prevents the\n+\t scheduler from doing the move?  We'd like to re-allocate the register,\n+\t but not necessarily put the load into another basic block.  */\n+      if (INSN_P (insn))\n+\tn_insns--;\n+    }\n+  return n_insns <= 0;\n+}\n+\n+/* Attempt to migrate the target register definition DEF to an\n+   earlier point in the flowgraph.\n+\n+   It is a precondition of this function that DEF is migratable:\n+   i.e. it has a constant source, and all uses are unambiguous.\n+\n+   Only migrations that reduce the cost of DEF will be made.\n+   MIN_COST is the lower bound on the cost of the DEF after migration.\n+   If we migrate DEF so that its cost falls below MIN_COST,\n+   then we do not attempt to migrate further.  The idea is that\n+   we migrate defintions in a priority order based on their cost,\n+   when the cost of this definition falls below MIN_COST, then\n+   there is another definition with cost == MIN_COST which now\n+   has a higher priority than this definition.\n+\n+   Return non-zero if there may be benefit from attempting to\n+   migrate this DEF further (i.e. we have reduced the cost below\n+   MIN_COST, but we may be able to reduce it further).\n+   Return zero if no further migration is possible. */\n+static int\n+migrate_btr_def (btr_def def, int min_cost)\n+{\n+  bitmap live_range;\n+  HARD_REG_SET btrs_live_in_range;\n+  int btr_used_near_def = 0;\n+  int def_basic_block_freq;\n+  basic_block try;\n+  int give_up = 0;\n+  int def_moved = 0;\n+  btr_user user;\n+  int def_latency;\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file,\n+\t     \"Attempting to migrate pt from insn %d (cost = %d, min_cost = %d) ... \",\n+\t     INSN_UID (def->insn), def->cost, min_cost);\n+\n+  if (!def->group || def->has_ambiguous_use)\n+    /* These defs are not migratable */\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"it's not migratable\\n\");\n+      return 0;\n+    }\n+\n+  if (!def->uses)\n+    /* We have combined this def with another in the same group, so\n+       no need to consider it further.\n+    */\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"it's already combined with another pt\\n\");\n+      return 0;\n+    }\n+\n+  btr_def_live_range (def, &btrs_live_in_range);\n+  live_range = BITMAP_XMALLOC ();\n+  bitmap_copy (live_range, def->live_range);\n+\n+  if ((*targetm.sched.use_dfa_pipeline_interface) ())\n+    def_latency = insn_default_latency (def->insn);\n+  else\n+    def_latency = result_ready_cost (def->insn);\n+  def_latency *= issue_rate;\n+\n+  for (user = def->uses; user != NULL; user = user->next)\n+    {\n+      if (user->bb == def->bb\n+\t  && user->luid > def->luid\n+\t  && (def->luid + def_latency) > user->luid\n+\t  && ! can_move_up (def->bb, def->insn,\n+\t\t\t    (def->luid + def_latency) - user->luid))\n+\t{\n+\t  btr_used_near_def = 1;\n+\t  break;\n+\t}\n+    }\n+\n+  def_basic_block_freq = basic_block_freq (def->bb);\n+\n+  for (try = get_immediate_dominator (dom, def->bb);\n+       !give_up && try && try != ENTRY_BLOCK_PTR && def->cost >= min_cost;\n+       try = get_immediate_dominator (dom, try))\n+    {\n+      /* Try to move the instruction that sets the target register into\n+\t basic block TRY. */\n+      int try_freq = basic_block_freq (try);\n+\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"trying block %d ...\", try->index);\n+\n+      if (try_freq < def_basic_block_freq\n+\t  || (try_freq == def_basic_block_freq && btr_used_near_def))\n+\t{\n+\t  int btr;\n+\t  augment_live_range (live_range, &btrs_live_in_range, def->bb, try);\n+\t  if (rtl_dump_file)\n+\t    {\n+\t      fprintf (rtl_dump_file, \"Now btrs live in range are: \");\n+\t      dump_hard_reg_set (btrs_live_in_range);\n+\t      fprintf (rtl_dump_file, \"\\n\");\n+\t    }\n+\t  btr = choose_btr (btrs_live_in_range);\n+\t  if (btr != -1)\n+\t    {\n+\t      move_btr_def (try, btr, def, live_range, &btrs_live_in_range);\n+\t      bitmap_copy(live_range, def->live_range);\n+\t      btr_used_near_def = 0;\n+\t      def_moved = 1;\n+\t      def_basic_block_freq = basic_block_freq (def->bb);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* There are no free target registers available to move\n+\t\t this far forward, so give up */\n+\t      give_up = 1;\n+\t      if (rtl_dump_file)\n+\t\tfprintf (rtl_dump_file,\n+\t\t\t \"giving up because there are no free target registers\\n\");\n+\t    }\n+\n+\t}\n+    }\n+  if (!def_moved)\n+    {\n+      give_up = 1;\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"failed to move\\n\");\n+    }\n+  BITMAP_XFREE (live_range);\n+  return !give_up;\n+}\n+\n+/* Attempt to move instructions that set target registers earlier\n+   in the flowgraph, away from their corresponding uses. */\n+static void\n+migrate_btr_defs (enum reg_class btr_class, int allow_callee_save)\n+{\n+  fibheap_t all_btr_defs = fibheap_new ();\n+  int reg;\n+\n+  gcc_obstack_init (&migrate_btrl_obstack);\n+  if (rtl_dump_file)\n+    {\n+      int i;\n+\n+      for (i = 0; i < n_basic_blocks; i++)\n+\t{\n+\t  basic_block bb = BASIC_BLOCK (i);\n+\t  fprintf(rtl_dump_file,\n+\t    \"Basic block %d: count = %lld loop-depth = %d idom = %d\\n\",\n+\t    i, bb->count, bb->loop_depth,\n+\t    get_immediate_dominator (dom, bb)->index);\n+\t}\n+    }\n+\n+  CLEAR_HARD_REG_SET (all_btrs);\n+  for (first_btr = -1, reg = 0; reg < FIRST_PSEUDO_REGISTER; reg++)\n+    if (TEST_HARD_REG_BIT (reg_class_contents[(int) btr_class], reg)\n+\t&& (allow_callee_save || call_used_regs[reg] || regs_ever_live[reg]))\n+      {\n+\tSET_HARD_REG_BIT (all_btrs, reg);\n+\tlast_btr = reg;\n+\tif (first_btr < 0)\n+\t  first_btr = reg;\n+      }\n+\n+  btrs_live =\n+    (HARD_REG_SET *) xcalloc (n_basic_blocks, sizeof (HARD_REG_SET));\n+\n+  build_btr_def_use_webs (all_btr_defs);\n+\n+  while (!fibheap_empty (all_btr_defs))\n+    {\n+      btr_def def =\n+\t(btr_def) fibheap_extract_min (all_btr_defs);\n+      int min_cost = -fibheap_min_key (all_btr_defs);\n+      if (migrate_btr_def (def, min_cost))\n+\t{\n+\t  fibheap_insert (all_btr_defs, -def->cost, (void *) def);\n+\t  if (rtl_dump_file)\n+\t    {\n+\t      fprintf (rtl_dump_file,\n+\t\t\"Putting insn %d back on queue with priority %d\\n\",\n+\t\tINSN_UID (def->insn), def->cost);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (def->live_range)\n+\t    BITMAP_XFREE (def->live_range);\n+\t}\n+    }\n+\n+  free (btrs_live);\n+  obstack_free (&migrate_btrl_obstack, NULL);\n+  fibheap_delete (all_btr_defs);\n+}\n+\n+void\n+branch_target_load_optimize (rtx insns, bool after_prologue_epilogue_gen)\n+{\n+  enum reg_class class = (*targetm.branch_target_register_class) ();\n+  if (class != NO_REGS)\n+    {\n+      /* Initialize issue_rate.  */\n+      if (targetm.sched.issue_rate)\n+\tissue_rate = (*targetm.sched.issue_rate) ();\n+      else\n+\tissue_rate = 1;\n+\n+      /* Build the CFG for migrate_btr_defs. */\n+#if 1\n+      /* This may or may not be needed, depending on where we\n+\t run this phase. */\n+      cleanup_cfg (optimize ? CLEANUP_EXPENSIVE : 0);\n+#endif\n+\n+      life_analysis (insns, NULL, 0);\n+\n+      /* Dominator info is also needed for migrate_btr_def. */\n+      dom = calculate_dominance_info (CDI_DOMINATORS);\n+      migrate_btr_defs (class,\n+\t\t       ((*targetm.branch_target_register_callee_saved)\n+\t\t\t(after_prologue_epilogue_gen)));\n+\n+      free_dominance_info (dom);\n+\n+      update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n+\t\t\tPROP_DEATH_NOTES | PROP_REG_INFO);\n+    }\n+}"}, {"sha": "59c2652d0cc4f34502f809bab9a94243232b3a0e", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=fe3ad57221f647b880567025bf825dcca9b7174a", "patch": "@@ -8470,6 +8470,7 @@ ia64_output_mi_thunk (file, thunk, delta, vcall_offset, function)\n   rtx this, insn, funexp;\n \n   reload_completed = 1;\n+  epilogue_completed = 1;\n   no_new_pseudos = 1;\n \n   /* Set things up as ia64_expand_prologue might.  */\n@@ -8537,6 +8538,7 @@ ia64_output_mi_thunk (file, thunk, delta, vcall_offset, function)\n \n   /* Code generation for calls relies on splitting.  */\n   reload_completed = 1;\n+  epilogue_completed = 1;\n   try_split (PATTERN (insn), insn, 0);\n \n   emit_barrier ();\n@@ -8555,6 +8557,7 @@ ia64_output_mi_thunk (file, thunk, delta, vcall_offset, function)\n   final_end_function ();\n \n   reload_completed = 0;\n+  epilogue_completed = 0;\n   no_new_pseudos = 0;\n }\n "}, {"sha": "f2ece833eff74c4778fdc1ebceb1926fc982b19f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=fe3ad57221f647b880567025bf825dcca9b7174a", "patch": "@@ -12237,6 +12237,7 @@ rs6000_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n   rtx this, insn, funexp;\n \n   reload_completed = 1;\n+  epilogue_completed = 1;\n   no_new_pseudos = 1;\n \n   /* Mark the end of the (empty) prologue.  */\n@@ -12316,6 +12317,7 @@ rs6000_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n   final_end_function ();\n \n   reload_completed = 0;\n+  epilogue_completed = 0;\n   no_new_pseudos = 0;\n }\n \f"}, {"sha": "3dfa6eea2c4b2d347b648370229bb0f7142bfb0c", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 170, "deletions": 28, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=fe3ad57221f647b880567025bf825dcca9b7174a", "patch": "@@ -175,6 +175,8 @@ enum reg_class reg_class_from_letter[] =\n \n int assembler_dialect;\n \n+static bool shmedia_space_reserved_for_target_registers;\n+\n static void split_branches PARAMS ((rtx));\n static int branch_dest PARAMS ((rtx));\n static void force_into PARAMS ((rtx, rtx));\n@@ -209,6 +211,8 @@ static int sh_issue_rate PARAMS ((void));\n static bool sh_function_ok_for_sibcall PARAMS ((tree, tree));\n \n static bool sh_cannot_modify_jumps_p PARAMS ((void));\n+static enum reg_class sh_target_reg_class (void);\n+static bool sh_optimize_target_register_callee_saved (bool);\n static bool sh_ms_bitfield_layout_p PARAMS ((tree));\n \n static void sh_init_builtins PARAMS ((void));\n@@ -226,6 +230,9 @@ static bool unspec_caller_rtx_p PARAMS ((rtx));\n static bool sh_cannot_copy_insn_p PARAMS ((rtx));\n static bool sh_rtx_costs PARAMS ((rtx, int, int, int *));\n static int sh_address_cost PARAMS ((rtx));\n+static int shmedia_target_regs_stack_space (HARD_REG_SET *);\n+static int shmedia_reserve_space_for_target_registers_p (int, HARD_REG_SET *);\n+static int shmedia_target_regs_stack_adjust (HARD_REG_SET *);\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ATTRIBUTE_TABLE\n@@ -266,6 +273,11 @@ static int sh_address_cost PARAMS ((rtx));\n \n #undef TARGET_CANNOT_MODIFY_JUMPS_P\n #define TARGET_CANNOT_MODIFY_JUMPS_P sh_cannot_modify_jumps_p\n+#undef TARGET_BRANCH_TARGET_REGISTER_CLASS\n+#define TARGET_BRANCH_TARGET_REGISTER_CLASS sh_target_reg_class\n+#undef TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED\n+#define TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED \\\n+ sh_optimize_target_register_callee_saved\n \n #undef TARGET_MS_BITFIELD_LAYOUT_P\n #define TARGET_MS_BITFIELD_LAYOUT_P sh_ms_bitfield_layout_p\n@@ -4698,6 +4710,53 @@ push_regs (mask, interrupt_handler)\n     push (PR_REG);\n }\n \n+/* Calculate how much extra space is needed to save all callee-saved\n+   target registers.\n+   LIVE_REGS_MASK is the register mask calculated by calc_live_regs.  */\n+\n+static int\n+shmedia_target_regs_stack_space (HARD_REG_SET *live_regs_mask)\n+{\n+  int reg;\n+  int stack_space = 0;\n+  int interrupt_handler = sh_cfun_interrupt_handler_p ();\n+\n+  for (reg = LAST_TARGET_REG; reg >= FIRST_TARGET_REG; reg--)\n+    if ((! call_used_regs[reg] || interrupt_handler)\n+        && ! TEST_HARD_REG_BIT (*live_regs_mask, reg))\n+      /* Leave space to save this target register on the stack,\n+\t in case target register allocation wants to use it. */\n+      stack_space += GET_MODE_SIZE (REGISTER_NATURAL_MODE (reg));\n+  return stack_space;\n+}\n+   \n+/* Decide whether we should reserve space for callee-save target registers,\n+   in case target register allocation wants to use them.  REGS_SAVED is\n+   the space, in bytes, that is already required for register saves.\n+   LIVE_REGS_MASK is the register mask calculated by calc_live_regs.  */\n+\n+static int\n+shmedia_reserve_space_for_target_registers_p (int regs_saved,\n+\t\t\t\t\t      HARD_REG_SET *live_regs_mask)\n+{\n+  if (optimize_size)\n+    return 0;\n+  return shmedia_target_regs_stack_space (live_regs_mask) <= regs_saved;\n+}\n+\n+/* Decide how much space to reserve for callee-save target registers\n+   in case target register allocation wants to use them.\n+   LIVE_REGS_MASK is the register mask calculated by calc_live_regs.  */\n+\n+static int\n+shmedia_target_regs_stack_adjust (HARD_REG_SET *live_regs_mask)\n+{\n+  if (shmedia_space_reserved_for_target_registers)\n+    return shmedia_target_regs_stack_space (live_regs_mask);\n+  else\n+    return 0;\n+}\n+\n /* Work out the registers which need to be saved, both as a mask and a\n    count of saved words.  Return the count.\n \n@@ -4801,6 +4860,19 @@ calc_live_regs (live_regs_mask)\n \t    }\n \t}\n     }\n+  /* If we have a target register optimization pass after prologue / epilogue\n+     threading, we need to assume all target registers will be live even if\n+     they aren't now.  */\n+  if (flag_branch_target_load_optimize2\n+      && TARGET_SAVE_ALL_TARGET_REGS\n+      && shmedia_space_reserved_for_target_registers)\n+    for (reg = LAST_TARGET_REG; reg >= FIRST_TARGET_REG; reg--)\n+      if ((! call_used_regs[reg] || interrupt_handler)\n+\t  && ! TEST_HARD_REG_BIT (*live_regs_mask, reg))\n+\t{\n+\t  SET_HARD_REG_BIT (*live_regs_mask, reg);\n+\t  count += GET_MODE_SIZE (REGISTER_NATURAL_MODE (reg));\n+\t}\n \n   return count;\n }\n@@ -4950,13 +5022,37 @@ sh_expand_prologue ()\n       rtx r0 = gen_rtx_REG (Pmode, R0_REG);\n       int offset_in_r0 = -1;\n       int sp_in_r0 = 0;\n-\n-      if (d % (STACK_BOUNDARY / BITS_PER_UNIT))\n+      int tregs_space = shmedia_target_regs_stack_adjust (&live_regs_mask);\n+      int total_size, save_size;\n+\n+      /* D is the actual number of bytes that we need for saving registers,\n+\t however, in initial_elimination_offset we have committed to using\n+\t an additional TREGS_SPACE amount of bytes - in order to keep both\n+\t addresses to arguments supplied by the caller and local variables\n+\t valid, we must keep this gap.  Place it between the incoming\n+\t arguments and the actually saved registers in a bid to optimize\n+\t locality of reference.  */\n+      total_size = d + tregs_space;\n+      total_size += rounded_frame_size (total_size);\n+      save_size = total_size - rounded_frame_size (d);\n+      if (save_size % (STACK_BOUNDARY / BITS_PER_UNIT))\n \td_rounding = ((STACK_BOUNDARY / BITS_PER_UNIT)\n-\t\t      - d % (STACK_BOUNDARY / BITS_PER_UNIT));\n+\t\t\t- save_size % (STACK_BOUNDARY / BITS_PER_UNIT));\n+\n+      /* If adjusting the stack in a single step costs nothing extra, do so.\n+\t I.e. either if a single addi is enough, or we need a movi anyway,\n+\t and we don't exceed the maximum offset range (the test for the\n+\t latter is conservative for simplicity).  */\n+      if (TARGET_SHMEDIA\n+\t  && (CONST_OK_FOR_I10 (-total_size)\n+\t      || (! CONST_OK_FOR_I10 (-(save_size + d_rounding))\n+\t\t  && total_size <= 2044)))\n+\td_rounding = total_size - save_size;\n \n       offset = d + d_rounding;\n-      output_stack_adjust (-offset, stack_pointer_rtx, 1, frame_insn);\n+\n+      output_stack_adjust (-(save_size + d_rounding), stack_pointer_rtx,\n+\t\t\t   1, frame_insn);\n \n       /* We loop twice: first, we save 8-byte aligned registers in the\n \t higher addresses, that are known to be aligned.  Then, we\n@@ -5168,16 +5264,39 @@ sh_expand_epilogue ()\n   int d_rounding = 0;\n \n   int save_flags = target_flags;\n-  int frame_size;\n+  int frame_size, save_size;\n   int fpscr_deferred = 0;\n \n   d = calc_live_regs (&live_regs_mask);\n \n-  if (TARGET_SH5 && d % (STACK_BOUNDARY / BITS_PER_UNIT))\n-    d_rounding = ((STACK_BOUNDARY / BITS_PER_UNIT)\n-\t\t  - d % (STACK_BOUNDARY / BITS_PER_UNIT));\n+  save_size = d;\n+  frame_size = rounded_frame_size (d);\n+\n+  if (TARGET_SH5)\n+    {\n+      int tregs_space = shmedia_target_regs_stack_adjust (&live_regs_mask);\n+      int total_size;\n+      if (d % (STACK_BOUNDARY / BITS_PER_UNIT))\n+      d_rounding = ((STACK_BOUNDARY / BITS_PER_UNIT)\n+\t\t    - d % (STACK_BOUNDARY / BITS_PER_UNIT));\n+\n+      total_size = d + tregs_space;\n+      total_size += rounded_frame_size (total_size);\n+      save_size = total_size - frame_size;\n+\n+      /* If adjusting the stack in a single step costs nothing extra, do so.\n+\t I.e. either if a single addi is enough, or we need a movi anyway,\n+\t and we don't exceed the maximum offset range (the test for the\n+\t latter is conservative for simplicity).  */\n+      if (TARGET_SHMEDIA\n+\t  && ! frame_pointer_needed\n+\t  && (CONST_OK_FOR_I10 (total_size)\n+\t      || (! CONST_OK_FOR_I10 (save_size + d_rounding)\n+\t\t  && total_size <= 2044)))\n+\td_rounding = frame_size;\n \n-  frame_size = rounded_frame_size (d) - d_rounding;\n+      frame_size -= d_rounding;\n+    }\n \n   if (frame_pointer_needed)\n     {\n@@ -5356,33 +5475,33 @@ sh_expand_epilogue ()\n \n       if (offset != d + d_rounding)\n \tabort ();\n-\n-      goto finish;\n     }\n-  else\n-    d = 0;\n-  if (TEST_HARD_REG_BIT (live_regs_mask, PR_REG))\n-    pop (PR_REG);\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+  else /* ! TARGET_SH5 */\n     {\n-      int j = (FIRST_PSEUDO_REGISTER - 1) - i;\n+      save_size = 0;\n+      if (TEST_HARD_REG_BIT (live_regs_mask, PR_REG))\n+\tpop (PR_REG);\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t{\n+\t  int j = (FIRST_PSEUDO_REGISTER - 1) - i;\n+  \n+\t  if (j == FPSCR_REG && current_function_interrupt && TARGET_FMOVD\n+\t      && hard_regs_intersect_p (&live_regs_mask,\n+\t\t\t\t\t&reg_class_contents[DF_REGS]))\n+\t    fpscr_deferred = 1;\n+\t  else if (j != PR_REG && TEST_HARD_REG_BIT (live_regs_mask, j))\n+\t    pop (j);\n+\t  if (j == FIRST_FP_REG && fpscr_deferred)\n+\t    pop (FPSCR_REG);\n \n-      if (j == FPSCR_REG && current_function_interrupt && TARGET_FMOVD\n-\t  && hard_regs_intersect_p (&live_regs_mask,\n-\t\t\t\t    &reg_class_contents[DF_REGS]))\n-\tfpscr_deferred = 1;\n-      else if (j != PR_REG && TEST_HARD_REG_BIT (live_regs_mask, j))\n-\tpop (j);\n-      if (j == FIRST_FP_REG && fpscr_deferred)\n-\tpop (FPSCR_REG);\n+\t}\n     }\n- finish:\n   if (target_flags != save_flags && ! current_function_interrupt)\n     emit_insn (gen_toggle_sz ());\n   target_flags = save_flags;\n \n   output_stack_adjust (extra_push + current_function_pretend_args_size\n-\t\t       + d + d_rounding\n+\t\t       + save_size + d_rounding\n \t\t       + current_function_args_info.stack_regs * 8,\n \t\t       stack_pointer_rtx, 7, emit_insn);\n \n@@ -5961,10 +6080,18 @@ initial_elimination_offset (from, to)\n   int total_auto_space;\n   int save_flags = target_flags;\n   int copy_flags;\n-\n   HARD_REG_SET live_regs_mask;\n+\n+  shmedia_space_reserved_for_target_registers = false;\n   regs_saved = calc_live_regs (&live_regs_mask);\n   regs_saved += SHMEDIA_REGS_STACK_ADJUST ();\n+\n+  if (shmedia_reserve_space_for_target_registers_p (regs_saved, &live_regs_mask))\n+    {\n+      shmedia_space_reserved_for_target_registers = true;\n+      regs_saved += shmedia_target_regs_stack_adjust (&live_regs_mask);\n+    }\n+\n   if (TARGET_SH5 && regs_saved % (STACK_BOUNDARY / BITS_PER_UNIT))\n     regs_saved_rounding = ((STACK_BOUNDARY / BITS_PER_UNIT)\n \t\t\t   - regs_saved % (STACK_BOUNDARY / BITS_PER_UNIT));\n@@ -7659,6 +7786,19 @@ sh_cannot_modify_jumps_p ()\n   return (TARGET_SHMEDIA && (reload_in_progress || reload_completed));\n }\n \n+static enum reg_class\n+sh_target_reg_class (void)\n+{\n+  return TARGET_SHMEDIA ? TARGET_REGS : NO_REGS;\n+}\n+\n+static bool\n+sh_optimize_target_register_callee_saved (bool after_prologue_epilogue_gen)\n+{\n+  return (shmedia_space_reserved_for_target_registers\n+\t  && (! after_prologue_epilogue_gen || TARGET_SAVE_ALL_TARGET_REGS));\n+}\n+\n static bool\n sh_ms_bitfield_layout_p (record_type)\n      tree record_type ATTRIBUTE_UNUSED;\n@@ -8331,6 +8471,7 @@ sh_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n   rtx scratch0, scratch1, scratch2;\n \n   reload_completed = 1;\n+  epilogue_completed = 1;\n   no_new_pseudos = 1;\n   current_function_uses_only_leaf_regs = 1;\n \n@@ -8480,6 +8621,7 @@ sh_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n     }\n \n   reload_completed = 0;\n+  epilogue_completed = 0;\n   no_new_pseudos = 0;\n }\n "}, {"sha": "ac5924fe59e48a201269c9a861bf04a7be657638", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=fe3ad57221f647b880567025bf825dcca9b7174a", "patch": "@@ -150,6 +150,7 @@ extern int target_flags;\n #define PADSTRUCT_BIT  (1<<28)\n #define LITTLE_ENDIAN_BIT (1<<29)\n #define IEEE_BIT (1<<30)\n+#define SAVE_ALL_TR_BIT (1<<2)\n \n /* Nonzero if we should dump out instruction size info.  */\n #define TARGET_DUMPISIZE  (target_flags & ISIZE_BIT)\n@@ -257,6 +258,8 @@ extern int target_flags;\n /* Nonzero if we should prefer @GOT calls when generating PIC.  */\n #define TARGET_PREFERGOT\t(target_flags & PREFERGOT_BIT)\n \n+#define TARGET_SAVE_ALL_TARGET_REGS (target_flags & SAVE_ALL_TR_BIT)\n+\n #define SELECT_SH1               (SH1_BIT)\n #define SELECT_SH2               (SH2_BIT | SELECT_SH1)\n #define SELECT_SH2E              (SH_E_BIT | SH2_BIT | SH1_BIT | FPU_SINGLE_BIT)\n@@ -417,6 +420,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n     flag_omit_frame_pointer = -1;\t\t\t\t\t\\\n   if (SIZE)\t\t\t\t\t\t\t\t\\\n     target_flags |= SPACE_BIT;\t\t\t\t\t\t\\\n+  if (TARGET_SHMEDIA && LEVEL > 1)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      flag_branch_target_load_optimize = 1;\t\t\t\t\\\n+      if (! (SIZE))\t\t\t\t\t\t\t\\\n+\ttarget_flags |= SAVE_ALL_TR_BIT;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n } while (0)\n \n #define ASSEMBLER_DIALECT assembler_dialect"}, {"sha": "e11340658c06becc2afd499bb17c352204101290", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=fe3ad57221f647b880567025bf825dcca9b7174a", "patch": "@@ -8589,6 +8589,7 @@ sparc_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n   rtx this, insn, funexp, delta_rtx, tmp;\n \n   reload_completed = 1;\n+  epilogue_completed = 1;\n   no_new_pseudos = 1;\n   current_function_uses_only_leaf_regs = 1;\n \n@@ -8641,6 +8642,7 @@ sparc_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n   final_end_function ();\n \n   reload_completed = 0;\n+  epilogue_completed = 0;\n   no_new_pseudos = 0;\n }\n "}, {"sha": "5256e66d8ff4e28de25e035ac28a9a2bf59db617", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=fe3ad57221f647b880567025bf825dcca9b7174a", "patch": "@@ -258,7 +258,8 @@ in the following sections.\n @xref{Optimize Options,,Options that Control Optimization}.\n @gccoptlist{-falign-functions=@var{n}  -falign-jumps=@var{n} @gol\n -falign-labels=@var{n}  -falign-loops=@var{n}  @gol\n--fbranch-probabilities  -fcaller-saves  -fcprop-registers @gol\n+-fbranch-probabilities  -fbranch-target-load-optimize @gol\n+-fbranch-target-load-optimize2 -fcaller-saves  -fcprop-registers @gol\n -fcse-follow-jumps  -fcse-skip-blocks  -fdata-sections @gol\n -fdelayed-branch  -fdelete-null-pointer-checks @gol\n -fexpensive-optimizations  -ffast-math  -ffloat-store @gol\n@@ -4420,6 +4421,19 @@ Perform Sparse Conditional Constant Propagation in SSA form.  Requires\n Perform aggressive dead-code elimination in SSA form.  Requires @option{-fssa}.\n Like @option{-fssa}, this is an experimental feature.\n \n+@item -fbranch-target-load-optimize\n+@opindex fbranch-target-load-optimize\n+Perform branch target register load optimization before prologue / epilogue\n+threading.\n+The use of target registers can typically be exposed only during reload,\n+thus hoisting loads out of loops and doing inter-block scheduling needs\n+a separate optimization pass.\n+\n+@item -fbranch-target-load-optimize2\n+@opindex fbranch-target-load-optimize2\n+Perform branch target register load optimization after prologue / epilogue\n+threading.\n+\n \n \n "}, {"sha": "4ba28b5dcccf6ad35c3f4cdb26e383e7c433b3e6", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=fe3ad57221f647b880567025bf825dcca9b7174a", "patch": "@@ -9271,3 +9271,25 @@ cannot_modify_jumps_past_reload_p ()\n @}\n @end smallexample\n @end deftypefn\n+\n+@deftypefn {Target Hook} enum reg_class TARGET_BRANCH_TARGET_REGISTER_CLASS (void)\n+This target hook returns a register class for which branch target register\n+optimizations should be applied.  All registers in this class should be\n+usable interchangably.  After reload, registers in this class will be\n+re-allocated and loads will be hoisted out of loops and be subjected\n+to inter-block scheduling.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} bool TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED (bool @var{after_prologue_epilogue_gen})\n+Branch target register optimization will by default exclude callee-saved\n+registers\n+that are not already live during the current function; if this target hook\n+returns true, they will be included.  The target code must than make sure\n+that all target registers in the class returned by\n+@samp{TARGET_BRANCH_TARGET_REGISTER_CLASS} that might need saving are\n+saved.  @var{after_prologue_epilogue_gen} indicates if prologues and\n+epilogues have already been generated.  Note, even if you only return\n+true when @var{after_prologue_epilogue_gen} is false, you still are likely\n+to have to make special provisions in @code{INITIAL_ELIMINATION_OFFSET}\n+to reserve space for caller-saved target registers.\n+@end deftypefn"}, {"sha": "35c054f15b7a3e382a4560dcb59a15a4b5086458", "filename": "gcc/flags.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=fe3ad57221f647b880567025bf825dcca9b7174a", "patch": "@@ -652,6 +652,16 @@ extern int flag_gcse_lm;\n \n extern int flag_gcse_sm;\n \n+/* Perform branch target register optimization before prologue / epilogue\n+   threading.  */\n+\n+extern int flag_branch_target_load_optimize;\n+\n+/* Perform branch target register optimization after prologue / epilogue\n+   threading and jump2.  */\n+\n+extern int flag_branch_target_load_optimize2;\n+\n \n /* Nonzero means we should do dwarf2 duplicate elimination.  */\n "}, {"sha": "6949bebcf17b9f6ad1d22146ffb1f81bfccbcb9c", "filename": "gcc/flow.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=fe3ad57221f647b880567025bf825dcca9b7174a", "patch": "@@ -985,7 +985,7 @@ mark_regs_live_at_end (set)\n \n   /* If exiting needs the right stack value, consider the stack pointer\n      live at the end of the function.  */\n-  if ((HAVE_epilogue && reload_completed)\n+  if ((HAVE_epilogue && epilogue_completed)\n       || ! EXIT_IGNORE_STACK\n       || (! FRAME_POINTER_REQUIRED\n \t  && ! current_function_calls_alloca\n@@ -1025,7 +1025,7 @@ mark_regs_live_at_end (set)\n     if (global_regs[i] || EPILOGUE_USES (i))\n       SET_REGNO_REG_SET (set, i);\n \n-  if (HAVE_epilogue && reload_completed)\n+  if (HAVE_epilogue && epilogue_completed)\n     {\n       /* Mark all call-saved registers that we actually used.  */\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n@@ -1046,7 +1046,7 @@ mark_regs_live_at_end (set)\n       }\n #endif\n #ifdef EH_RETURN_STACKADJ_RTX\n-  if ((! HAVE_epilogue || ! reload_completed)\n+  if ((! HAVE_epilogue || ! epilogue_completed)\n       && current_function_calls_eh_return)\n     {\n       rtx tmp = EH_RETURN_STACKADJ_RTX;\n@@ -1055,7 +1055,7 @@ mark_regs_live_at_end (set)\n     }\n #endif\n #ifdef EH_RETURN_HANDLER_RTX\n-  if ((! HAVE_epilogue || ! reload_completed)\n+  if ((! HAVE_epilogue || ! epilogue_completed)\n       && current_function_calls_eh_return)\n     {\n       rtx tmp = EH_RETURN_HANDLER_RTX;"}, {"sha": "97dd2c9b828bd3884afbb73b4b923497a55c9407", "filename": "gcc/hooks.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=fe3ad57221f647b880567025bf825dcca9b7174a", "patch": "@@ -41,6 +41,21 @@ hook_bool_void_false ()\n   return false;\n }\n \n+/* The same, but formally returning an enum reg_class.  */\n+enum reg_class\n+hook_reg_class_void_no_regs (void)\n+{\n+  return NO_REGS;\n+}\n+\n+/* Generic hook that takes (bool) and returns false.  */\n+bool\n+hook_bool_bool_false (bool a ATTRIBUTE_UNUSED)\n+{\n+  return false;\n+}\n+\n+\n /* Generic hook that takes (tree, int) and does nothing.  */\n void\n hook_void_tree_int (a, b)"}, {"sha": "d0abf889b9590ebf5c0bc3cb0b8c627d7707022d", "filename": "gcc/hooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=fe3ad57221f647b880567025bf825dcca9b7174a", "patch": "@@ -23,6 +23,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define GCC_HOOKS_H\n \n bool hook_bool_void_false PARAMS ((void));\n+enum reg_class hook_reg_class_void_no_regs (void);\n+bool hook_bool_bool_false (bool);\n bool hook_bool_tree_false PARAMS ((tree));\n bool hook_bool_tree_hwi_hwi_tree_false\n   PARAMS ((tree, HOST_WIDE_INT, HOST_WIDE_INT, tree));"}, {"sha": "28b7c400c4276e50984754e8b99d83c57403f06a", "filename": "gcc/recog.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=fe3ad57221f647b880567025bf825dcca9b7174a", "patch": "@@ -88,6 +88,9 @@ int which_alternative;\n \n int reload_completed;\n \n+/* Nonzero after thread_prologue_and_epilogue_insns has run.  */\n+int epilogue_completed;\n+\n /* Initialize data used by the function `recog'.\n    This must be called once in the compilation of a function\n    before any insn recognition may be done in the function.  */"}, {"sha": "b19bc1fc10d83bb0f6c07447504f05ffc60d07fa", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=fe3ad57221f647b880567025bf825dcca9b7174a", "patch": "@@ -1965,6 +1965,9 @@ extern int flow2_completed;\n \n extern int reload_completed;\n \n+/* Nonzero after thread_prologue_and_epilogue_insns has run.  */\n+extern int epilogue_completed;\n+\n /* Set to 1 while reload_as_needed is operating.\n    Required by some machines to handle any generated moves differently.  */\n \n@@ -2123,6 +2126,7 @@ extern rtx libcall_other_reg\t\tPARAMS ((rtx, rtx));\n #ifdef BUFSIZ\n extern void loop_optimize\t\tPARAMS ((rtx, FILE *, int));\n #endif\n+extern void branch_target_load_optimize (rtx, bool);\n extern void record_excess_regs\t\tPARAMS ((rtx, rtx, rtx *));\n \n /* In function.c */"}, {"sha": "f339868f1c8ce981a8a776774e9873f2f01530bc", "filename": "gcc/target-def.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=fe3ad57221f647b880567025bf825dcca9b7174a", "patch": "@@ -269,6 +269,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n /* In hook.c.  */\n #define TARGET_CANNOT_MODIFY_JUMPS_P hook_bool_void_false\n+#define TARGET_BRANCH_TARGET_REGISTER_CLASS hook_reg_class_void_no_regs\n+#define TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED hook_bool_bool_false\n #define TARGET_CANNOT_FORCE_CONST_MEM hook_bool_rtx_false\n #define TARGET_CANNOT_COPY_INSN_P NULL\n #define TARGET_DELEGITIMIZE_ADDRESS hook_rtx_rtx_identity\n@@ -307,6 +309,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n   TARGET_EXPAND_BUILTIN,\t\t\t\\\n   TARGET_SECTION_TYPE_FLAGS,\t\t\t\\\n   TARGET_CANNOT_MODIFY_JUMPS_P,\t\t\t\\\n+  TARGET_BRANCH_TARGET_REGISTER_CLASS,\t\\\n+  TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED,\t\\\n   TARGET_CANNOT_FORCE_CONST_MEM,\t\t\\\n   TARGET_CANNOT_COPY_INSN_P,\t\t\t\\\n   TARGET_DELEGITIMIZE_ADDRESS,\t\t\t\\"}, {"sha": "d6e30e3a469012744ee65ed0f8f3fbd7182acfeb", "filename": "gcc/target.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=fe3ad57221f647b880567025bf825dcca9b7174a", "patch": "@@ -291,6 +291,9 @@ struct gcc_target\n      not, at the current point in the compilation.  */\n   bool (* cannot_modify_jumps_p) PARAMS ((void));\n \n+  enum reg_class (* branch_target_register_class) PARAMS ((void));\n+  bool (* branch_target_register_callee_saved) PARAMS ((bool));\n+\n   /* True if the constant X cannot be placed in the constant pool.  */\n   bool (* cannot_force_const_mem) PARAMS ((rtx));\n "}, {"sha": "b4d8a388a8cc466d319b0bcf9ef56739365eba3e", "filename": "gcc/toplev.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3ad57221f647b880567025bf825dcca9b7174a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=fe3ad57221f647b880567025bf825dcca9b7174a", "patch": "@@ -287,6 +287,7 @@ enum dump_file_index\n   DFI_rnreg,\n   DFI_bbro,\n   DFI_ce3,\n+  DFI_branch_target_load,\n   DFI_sched2,\n   DFI_stack,\n   DFI_mach,\n@@ -338,6 +339,7 @@ static struct dump_file_info dump_file[DFI_MAX] =\n   { \"rnreg\",\t'n', 1, 0, 0 },\n   { \"bbro\",\t'B', 1, 0, 0 },\n   { \"ce3\",\t'E', 1, 0, 0 },\n+  { \"btl\",\t'd', 1, 0, 0 }, /* Yes, duplicate enable switch.  */\n   { \"sched2\",\t'R', 1, 0, 0 },\n   { \"stack\",\t'k', 1, 0, 0 },\n   { \"mach\",\t'M', 1, 0, 0 },\n@@ -689,6 +691,16 @@ int flag_gcse_lm = 1;\n \n int flag_gcse_sm = 1;\n \n+/* Perform target register optimization before prologue / epilogue\n+   threading.  */\n+\n+int flag_branch_target_load_optimize = 0;\n+\n+/* Perform target register optimization after prologue / epilogue\n+   threading and jump2.  */\n+\n+int flag_branch_target_load_optimize2 = 0;\n+\n /* Nonzero means to rerun cse after loop optimization.  This increases\n    compilation time about 20% and picks up a few more common expressions.  */\n \n@@ -1118,6 +1130,10 @@ static const lang_independent_options f_options[] =\n    N_(\"Perform enhanced load motion during global subexpression elimination\") },\n   {\"gcse-sm\", &flag_gcse_sm, 1,\n    N_(\"Perform store motion after global subexpression elimination\") },\n+  {\"branch-target-load-optimize\", &flag_branch_target_load_optimize, 1,\n+   N_(\"Perform branch target load optimization before prologue / epilogue threading\") },\n+  {\"branch-target-load-optimize2\", &flag_branch_target_load_optimize2, 1,\n+   N_(\"Perform branch target load optimization after prologue / epilogue threading\") },\n   {\"loop-optimize\", &flag_loop_optimize, 1,\n    N_(\"Perform the loop optimizations\") },\n   {\"crossjumping\", &flag_crossjumping, 1,\n@@ -3761,6 +3777,17 @@ rest_of_compilation (tree decl)\n #endif\n     split_all_insns (0);\n \n+    if (flag_branch_target_load_optimize)\n+      {\n+\topen_dump_file (DFI_branch_target_load, decl);\n+\n+\tbranch_target_load_optimize (insns, false);\n+\n+\tclose_dump_file (DFI_branch_target_load, print_rtl_with_bb, insns);\n+\n+\tggc_collect ();\n+      }\n+\n   if (optimize)\n     cleanup_cfg (CLEANUP_EXPENSIVE);\n \n@@ -3769,6 +3796,7 @@ rest_of_compilation (tree decl)\n      it and the rest of the code and also allows delayed branch\n      scheduling to operate in the epilogue.  */\n   thread_prologue_and_epilogue_insns (insns);\n+  epilogue_completed = 1;\n \n   if (optimize)\n     {\n@@ -3825,6 +3853,24 @@ rest_of_compilation (tree decl)\n       timevar_pop (TV_IFCVT2);\n     }\n \n+    if (flag_branch_target_load_optimize2)\n+      {\n+\t/* Leave this a warning for now so that it is possible to experiment\n+\t   with running this pass twice.  In 3.6, we should either make this\n+\t   an error, or use separate dump files.  */\n+\tif (flag_branch_target_load_optimize)\n+\t  warning (\"branch target register load optimization is not intended \"\n+\t\t   \"to be run twice\");\n+\n+\topen_dump_file (DFI_branch_target_load, decl);\n+\n+\tbranch_target_load_optimize (insns, true);\n+\n+\tclose_dump_file (DFI_branch_target_load, print_rtl_with_bb, insns);\n+\n+\tggc_collect ();\n+      }\n+\n #ifdef INSN_SCHEDULING\n   if (optimize > 0 && flag_schedule_insns_after_reload)\n     rest_of_handle_sched2 (decl, insns);\n@@ -3904,6 +3950,7 @@ rest_of_compilation (tree decl)\n #endif\n \n   reload_completed = 0;\n+  epilogue_completed = 0;\n   flow2_completed = 0;\n   no_new_pseudos = 0;\n "}]}