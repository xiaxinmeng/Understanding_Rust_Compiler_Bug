{"sha": "a10fd356018dec958ed6f1fbfd800d9003c5737c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTEwZmQzNTYwMThkZWM5NThlZDZmMWZiZmQ4MDBkOTAwM2M1NzM3Yw==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@mckinlay.net.nz", "date": "2003-10-25T06:49:20Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2003-10-25T06:49:20Z"}, "message": "re PR libgcj/11780 (Method.invoke() is slow)\n\n\tPR libgcj/11780:\n\t* java/lang/reflect/natMethod.cc (invoke): Look up caller and\n\tperform accessibility check only if target is non-public and\n\taccessible flag is not set.\n\t* java/lang/reflect/natField.cc (getAddr): Likewise.\n\nFrom-SVN: r72918", "tree": {"sha": "19ae3b15fb086062210a6d746f8d2c5cd7f71853", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19ae3b15fb086062210a6d746f8d2c5cd7f71853"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a10fd356018dec958ed6f1fbfd800d9003c5737c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a10fd356018dec958ed6f1fbfd800d9003c5737c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a10fd356018dec958ed6f1fbfd800d9003c5737c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a10fd356018dec958ed6f1fbfd800d9003c5737c/comments", "author": null, "committer": null, "parents": [{"sha": "b2398b494702b0e87a0951f7352cc2c38b8b8447", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2398b494702b0e87a0951f7352cc2c38b8b8447", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2398b494702b0e87a0951f7352cc2c38b8b8447"}], "stats": {"total": 93, "additions": 57, "deletions": 36}, "files": [{"sha": "304bb33728983219f3ad38316f37b68789423755", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a10fd356018dec958ed6f1fbfd800d9003c5737c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a10fd356018dec958ed6f1fbfd800d9003c5737c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a10fd356018dec958ed6f1fbfd800d9003c5737c", "patch": "@@ -1,3 +1,11 @@\n+2003-10-25  Bryce McKinlay  <bryce@mckinlay.net.nz>\n+\n+\tPR libgcj/11780:\n+\t* java/lang/reflect/natMethod.cc (invoke): Look up caller and perform\n+\taccessibility check only if target is non-public and accessible flag\n+\tis not set.\n+\t* java/lang/reflect/natField.cc (getAddr): Likewise.\n+\n 2003-10-24  Thomas Fitzsimmons  <fitzsim@redhat.com>\n \n \t* gnu/java/awt/peer/gtk/GtkDialogPeer.java (handleEvent):"}, {"sha": "469cf74de8ef9bed14910a3ccf3bbedd15164249", "filename": "libjava/java/lang/reflect/natField.cc", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a10fd356018dec958ed6f1fbfd800d9003c5737c/libjava%2Fjava%2Flang%2Freflect%2FnatField.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a10fd356018dec958ed6f1fbfd800d9003c5737c/libjava%2Fjava%2Flang%2Freflect%2FnatField.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatField.cc?ref=a10fd356018dec958ed6f1fbfd800d9003c5737c", "patch": "@@ -58,27 +58,32 @@ getAddr (java::lang::reflect::Field* field, jclass caller, jobject obj)\n   // have the compiler insert the caller as a hidden argument in some\n   // calls.  However, we never implemented that, so we have to find\n   // the caller by hand instead.\n-  gnu::gcj::runtime::StackTrace *t \n-    = new gnu::gcj::runtime::StackTrace(7);\n-  try\n-    {\n-      // We want to skip all the frames on the stack from this class.\n-      for (int i = 1;\n-\t   !caller || caller == &java::lang::reflect::Field::class$;\n-\t   i++)\n-\tcaller = t->classAt (i);\n-    }\n-  catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n-    {\n-    }\n-\n+  \n+  using namespace java::lang::reflect;\n+  \n   jfieldID fld = _Jv_FromReflectedField (field);\n   _Jv_ushort flags = fld->getModifiers();\n-  if (! field->isAccessible ()\n-      && ! _Jv_CheckAccess (caller, field->getDeclaringClass(), flags))\n-    throw new java::lang::IllegalAccessException;\n+  \n+  // Check accessibility, if required.\n+  if (! (Modifier::isPublic (flags) || field->isAccessible()))\n+    {\n+      gnu::gcj::runtime::StackTrace *t \n+\t= new gnu::gcj::runtime::StackTrace(7);\n+      try\n+\t{\n+\t  // We want to skip all the frames on the stack from this class.\n+\t  for (int i = 1; !caller || caller == &Field::class$; i++)\n+\t    caller = t->classAt (i);\n+\t}\n+      catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n+\t{\n+\t}\n+\n+      if (! _Jv_CheckAccess (caller, field->getDeclaringClass(), flags))\n+\tthrow new java::lang::IllegalAccessException;\n+    }\n \n-  if (flags & java::lang::reflect::Modifier::STATIC)\n+  if (flags & Modifier::STATIC)\n     {\n       jclass fldClass = field->getDeclaringClass ();\n       JvInitClass(fldClass);"}, {"sha": "b3413ce68801171d00a9191cf31c3d4937f24da1", "filename": "libjava/java/lang/reflect/natMethod.cc", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a10fd356018dec958ed6f1fbfd800d9003c5737c/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a10fd356018dec958ed6f1fbfd800d9003c5737c/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc?ref=a10fd356018dec958ed6f1fbfd800d9003c5737c", "patch": "@@ -28,6 +28,7 @@ details.  */\n #include <java/lang/Long.h>\n #include <java/lang/Float.h>\n #include <java/lang/Double.h>\n+#include <java/lang/IllegalAccessException.h>\n #include <java/lang/IllegalArgumentException.h>\n #include <java/lang/NullPointerException.h>\n #include <java/lang/ArrayIndexOutOfBoundsException.h>\n@@ -141,26 +142,15 @@ get_ffi_type (jclass klass)\n jobject\n java::lang::reflect::Method::invoke (jobject obj, jobjectArray args)\n {\n+  using namespace java::lang::reflect;\n+  \n   if (parameter_types == NULL)\n     getType ();\n-\n-  gnu::gcj::runtime::StackTrace *t \n-    = new gnu::gcj::runtime::StackTrace(4);\n-  Class *caller = NULL;\n-  try\n-    {\n-      for (int i = 1; !caller; i++)\n-\t{\n-\t  caller = t->classAt (i);\n-\t}\n-    }\n-  catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n-    {\n-    }\n-\n+    \n   jmethodID meth = _Jv_FromReflectedMethod (this);\n+\n   jclass klass;\n-  if (! java::lang::reflect::Modifier::isStatic(meth->accflags))\n+  if (! Modifier::isStatic(meth->accflags))\n     {\n       if (! obj)\n \tthrow new java::lang::NullPointerException;\n@@ -181,8 +171,26 @@ java::lang::reflect::Method::invoke (jobject obj, jobjectArray args)\n       klass = declaringClass;\n     }\n \n-  if (! isAccessible() && ! _Jv_CheckAccess(caller, klass, meth->accflags))\n-    throw new IllegalArgumentException;\n+  // Check accessibility, if required.\n+  if (! (Modifier::isPublic (meth->accflags) || this->isAccessible()))\n+    {\n+      gnu::gcj::runtime::StackTrace *t \n+\t= new gnu::gcj::runtime::StackTrace(4);\n+      Class *caller = NULL;\n+      try\n+\t{\n+\t  for (int i = 1; !caller; i++)\n+\t    {\n+\t      caller = t->classAt (i);\n+\t    }\n+\t}\n+      catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n+\t{\n+\t}\n+\n+      if (! _Jv_CheckAccess(caller, klass, meth->accflags))\n+\tthrow new IllegalAccessException;\n+    }\n \n   return _Jv_CallAnyMethodA (obj, return_type, meth, false,\n \t\t\t     parameter_types, args);"}]}