{"sha": "0174469a67d4a7c6290237bf80084a3ddaae27a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE3NDQ2OWE2N2Q0YTdjNjI5MDIzN2JmODAwODRhM2RkYWFlMjdhNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-07-26T07:04:47Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-07-26T07:04:47Z"}, "message": "i860.h (EXPAND_BUILTIN_SAVEREGS): New.\n\n        * i860.h (EXPAND_BUILTIN_SAVEREGS): New.\n        (BUILD_VA_LIST_TYPE): New.\n        (EXPAND_BUILTIN_VA_START): New.\n        (EXPAND_BUILTIN_VA_ARG): New.\n        * i860.c (output_delayed_branch): Disable.\n        (output_delay_insn): Likewise.\n        (i860_saveregs): New.\n        (i860_build_va_list): New.\n        (i860_va_start): New.\n        (i860_va_arg): New.\n        * i860.md: Disable all peepholes using output_delayed_branch.\n        * i860/sysv4.h (I860_SVR4_VA_LIST): New.\n\nFrom-SVN: r28259", "tree": {"sha": "e8febd06c68616764ad061670173af4aeec41ef2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8febd06c68616764ad061670173af4aeec41ef2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0174469a67d4a7c6290237bf80084a3ddaae27a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0174469a67d4a7c6290237bf80084a3ddaae27a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0174469a67d4a7c6290237bf80084a3ddaae27a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0174469a67d4a7c6290237bf80084a3ddaae27a7/comments", "author": null, "committer": null, "parents": [{"sha": "eb11a473473d8461a21ddeb5648d5bb87bdaf505", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb11a473473d8461a21ddeb5648d5bb87bdaf505", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb11a473473d8461a21ddeb5648d5bb87bdaf505"}], "stats": {"total": 479, "additions": 387, "deletions": 92}, "files": [{"sha": "f9fd9f1dd98f7f5bb6429299d7feb30710e1306e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0174469a67d4a7c6290237bf80084a3ddaae27a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0174469a67d4a7c6290237bf80084a3ddaae27a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0174469a67d4a7c6290237bf80084a3ddaae27a7", "patch": "@@ -1,3 +1,18 @@\n+Sun Jul 25 23:51:59 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* i860.h (EXPAND_BUILTIN_SAVEREGS): New.\n+\t(BUILD_VA_LIST_TYPE): New.\n+\t(EXPAND_BUILTIN_VA_START): New.\n+\t(EXPAND_BUILTIN_VA_ARG): New.\n+\t* i860.c (output_delayed_branch): Disable.\n+\t(output_delay_insn): Likewise.\n+\t(i860_saveregs): New.\n+\t(i860_build_va_list): New.\n+\t(i860_va_start): New.\n+\t(i860_va_arg): New.\n+\t* i860.md: Disable all peepholes using output_delayed_branch.\n+\t* i860/sysv4.h (I860_SVR4_VA_LIST): New.\n+\n Sun Jul 25 23:44:13 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* clipper.h (EXPAND_BUILTIN_SAVEREGS): Remove argument."}, {"sha": "08e2db7f739591028d929b36670d5492d3e70754", "filename": "gcc/config/i860/i860.c", "status": "modified", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0174469a67d4a7c6290237bf80084a3ddaae27a7/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0174469a67d4a7c6290237bf80084a3ddaae27a7/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=0174469a67d4a7c6290237bf80084a3ddaae27a7", "patch": "@@ -29,6 +29,7 @@ Boston, MA 02111-1307, USA.  */\n #include <stdio.h>\n #include \"flags.h\"\n #include \"rtl.h\"\n+#include \"tree.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n #include \"real.h\"\n@@ -38,6 +39,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"recog.h\"\n #include \"insn-attr.h\"\n+#include \"expr.h\"\n \n static rtx find_addr_reg ();\n \n@@ -1323,6 +1325,7 @@ output_block_move (operands)\n   return \"\";\n }\n \f\n+#if 0\n /* Output a delayed branch insn with the delay insn in its\n    branch slot.  The delayed branch insn template is in TEMPLATE,\n    with operands OPERANDS.  The insn in its delay slot is INSN.\n@@ -1343,6 +1346,9 @@ output_block_move (operands)\n \tor l%x,%0,%1\n \n    */\n+/* ??? Disabled because this re-recognition is incomplete and causes\n+   constrain_operands to segfault.  Anyone who cares should fix up\n+   the code to use the DBR pass.  */\n \n char *\n output_delayed_branch (template, operands, insn)\n@@ -1512,6 +1518,7 @@ output_delay_insn (delay_insn)\n   output_asm_insn (template, recog_operand);\n   return \"\";\n }\n+#endif\n \f\n /* Special routine to convert an SFmode value represented as a\n    CONST_DOUBLE into its equivalent unsigned long bit pattern.\n@@ -2095,3 +2102,250 @@ function_epilogue (asm_file, local_bytes)\n   text_section();\n #endif\n }\n+\f\n+\n+/* Expand a library call to __builtin_saveregs.  */\n+rtx\n+i860_saveregs ()\n+{\n+  rtx fn = gen_rtx_SYMBOL_REF (Pmode, \"__builtin_saveregs\");\n+  rtx save = gen_reg_rtx (Pmode);\n+  rtx valreg = LIBCALL_VALUE (Pmode);\n+  rtx ret;\n+\n+  /* The return value register overlaps the first argument register.\n+     Save and restore it around the call.  */\n+  emit_move_insn (save, valreg);\n+  ret = emit_library_call_value (fn, NULL_RTX, 1, Pmode, 0);\n+  if (GET_CODE (ret) != REG || REGNO (ret) < FIRST_PSEUDO_REGISTER)\n+    ret = copy_to_reg (ret);\n+  emit_move_insn (valreg, save);\n+\n+  return ret;\n+}\n+\n+tree\n+i860_build_va_list ()\n+{\n+  tree field_ireg_used, field_freg_used, field_reg_base, field_mem_ptr;\n+  tree record;\n+\n+  record = make_node (RECORD_TYPE);\n+\n+  field_ireg_used = build_decl (FIELD_DECL, get_identifier (\"__ireg_used\"),\n+\t\t\t\tunsigned_type_node);\n+  field_freg_used = build_decl (FIELD_DECL, get_identifier (\"__freg_used\"),\n+\t\t\t\tunsigned_type_node);\n+  field_reg_base = build_decl (FIELD_DECL, get_identifier (\"__reg_base\"),\n+\t\t\t       ptr_type_node);\n+  field_mem_ptr = build_decl (FIELD_DECL, get_identifier (\"__mem_ptr\"),\n+\t\t\t      ptr_type_node);\n+\n+  DECL_FIELD_CONTEXT (field_ireg_used) = record;\n+  DECL_FIELD_CONTEXT (field_freg_used) = record;\n+  DECL_FIELD_CONTEXT (field_reg_base) = record;\n+  DECL_FIELD_CONTEXT (field_mem_ptr) = record;\n+\n+#ifdef I860_SVR4_VA_LIST\n+  TYPE_FIELDS (record) = field_ireg_used;\n+  TREE_CHAIN (field_ireg_used) = field_freg_used;\n+  TREE_CHAIN (field_freg_used) = field_reg_base;\n+  TREE_CHAIN (field_reg_base) = field_mem_ptr;\n+#else\n+  TYPE_FIELDS (record) = field_reg_base;\n+  TREE_CHAIN (field_reg_base) = field_mem_ptr;\n+  TREE_CHAIN (field_mem_ptr) = field_ireg_used;\n+  TREE_CHAIN (field_ireg_used) = field_freg_used;\n+#endif\n+\n+  layout_type (record);\n+  return record;\n+}\n+\n+void\n+i860_va_start (stdarg_p, valist, nextarg)\n+     int stdarg_p;\n+     tree valist;\n+     rtx nextarg;\n+{\n+  tree saveregs, t;\n+\n+  saveregs = make_tree (build_pointer_type (va_list_type_node),\n+\t\t\texpand_builtin_saveregs ());\n+  saveregs = build1 (INDIRECT_REF, va_list_type_node, saveregs);\n+\n+  if (stdarg_p)\n+    {\n+      tree field_ireg_used, field_freg_used, field_reg_base, field_mem_ptr;\n+      tree ireg_used, freg_used, reg_base, mem_ptr;\n+\n+#ifdef I860_SVR4_VA_LIST\n+      field_ireg_used = TYPE_FIELDS (va_list_type_node);\n+      field_freg_used = TREE_CHAIN (field_ireg_used);\n+      field_reg_base = TREE_CHAIN (field_freg_used);\n+      field_mem_ptr = TREE_CHAIN (field_reg_base);\n+#else\n+      field_reg_base = TYPE_FIELDS (va_list_type_node);\n+      field_mem_ptr = TREE_CHAIN (field_reg_base);\n+      field_ireg_used = TREE_CHAIN (field_mem_ptr);\n+      field_freg_used = TREE_CHAIN (field_ireg_used);\n+#endif\n+\n+      ireg_used = build (COMPONENT_REF, TREE_TYPE (field_ireg_used),\n+\t\t\t valist, field_ireg_used);\n+      freg_used = build (COMPONENT_REF, TREE_TYPE (field_freg_used),\n+\t\t\t valist, field_freg_used);\n+      reg_base = build (COMPONENT_REF, TREE_TYPE (field_reg_base),\n+\t\t\tvalist, field_reg_base);\n+      mem_ptr = build (COMPONENT_REF, TREE_TYPE (field_mem_ptr),\n+\t\t       valist, field_mem_ptr);\n+\n+      t = build_int_2 (current_function_args_info.ints, 0);\n+      t = build (MODIFY_EXPR, TREE_TYPE (ireg_used), ireg_used, t);\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+      \n+      t = build_int_2 (ROUNDUP (current_function_args_info.floats, 8), 0);\n+      t = build (MODIFY_EXPR, TREE_TYPE (freg_used), freg_used, t);\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+      \n+      t = build (COMPONENT_REF, TREE_TYPE (field_reg_base),\n+\t\t saveregs, field_reg_base);\n+      t = build (MODIFY_EXPR, TREE_TYPE (reg_base), reg_base, t);\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+      t = make_tree (ptr_type_node, nextarg);\n+      t = build (MODIFY_EXPR, TREE_TYPE (mem_ptr), mem_ptr, t);\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+    }\n+  else\n+    {\n+      t = build (MODIFY_EXPR, va_list_type_node, valist, saveregs);\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+    }\n+}\n+\n+#define NUM_PARM_FREGS\t8\n+#define NUM_PARM_IREGS\t12\n+#ifdef I860_SVR4_VARARGS\n+#define FREG_OFFSET 0\n+#define IREG_OFFSET (NUM_PARM_FREGS * UNITS_PER_WORD)\n+#else\n+#define FREG_OFFSET (NUM_PARM_IREGS * UNITS_PER_WORD)\n+#define IREG_OFFSET 0\n+#endif\n+\n+rtx\n+i860_va_arg (valist, type)\n+     tree valist, type;\n+{\n+  tree field_ireg_used, field_freg_used, field_reg_base, field_mem_ptr;\n+  tree type_ptr_node, t;\n+  rtx lab_over = NULL_RTX;\n+  rtx ret, val;\n+  HOST_WIDE_INT align;\n+\n+#ifdef I860_SVR4_VA_LIST\n+  field_ireg_used = TYPE_FIELDS (va_list_type_node);\n+  field_freg_used = TREE_CHAIN (field_ireg_used);\n+  field_reg_base = TREE_CHAIN (field_freg_used);\n+  field_mem_ptr = TREE_CHAIN (field_reg_base);\n+#else\n+  field_reg_base = TYPE_FIELDS (va_list_type_node);\n+  field_mem_ptr = TREE_CHAIN (field_reg_base);\n+  field_ireg_used = TREE_CHAIN (field_mem_ptr);\n+  field_freg_used = TREE_CHAIN (field_ireg_used);\n+#endif\n+\n+  field_ireg_used = build (COMPONENT_REF, TREE_TYPE (field_ireg_used),\n+\t\t\t   valist, field_ireg_used);\n+  field_freg_used = build (COMPONENT_REF, TREE_TYPE (field_freg_used),\n+\t\t\t   valist, field_freg_used);\n+  field_reg_base = build (COMPONENT_REF, TREE_TYPE (field_reg_base),\n+\t\t\t  valist, field_reg_base);\n+  field_mem_ptr = build (COMPONENT_REF, TREE_TYPE (field_mem_ptr),\n+\t\t\t valist, field_mem_ptr);\n+\n+  ret = gen_reg_rtx (Pmode);\n+  type_ptr_node = build_pointer_type (type);\n+\n+  if (! AGGREGATE_TYPE_P (type))\n+    {\n+      int nparm, incr, ofs;\n+      tree field;\n+      rtx lab_false;\n+\n+      if (FLOAT_TYPE_P (type))\n+\t{\n+\t  field = field_freg_used;\n+\t  nparm = NUM_PARM_FREGS;\n+\t  incr = 2;\n+\t  ofs = FREG_OFFSET;\n+\t}\n+      else\n+\t{\n+\t  field = field_ireg_used;\n+\t  nparm = NUM_PARM_IREGS;\n+\t  incr = int_size_in_bytes (type) / UNITS_PER_WORD;\n+\t  ofs = IREG_OFFSET;\n+\t}\n+\n+      lab_false = gen_label_rtx ();\n+      lab_over = gen_label_rtx ();\n+\n+      emit_cmp_and_jump_insns (expand_expr (field, NULL_RTX, 0, 0),\n+\t\t\t       GEN_INT (nparm - incr), GT, const0_rtx,\n+\t\t\t       TYPE_MODE (TREE_TYPE (field)),\n+\t\t\t       TREE_UNSIGNED (field), 0, lab_false);\n+\n+      t = fold (build (POSTINCREMENT_EXPR, TREE_TYPE (field), field,\n+\t\t       build_int_2 (incr, 0)));\n+      TREE_SIDE_EFFECTS (t) = 1;\n+\n+      t = fold (build (MULT_EXPR, TREE_TYPE (field), field,\n+\t\t       build_int_2 (UNITS_PER_WORD, 0)));\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      \n+      t = fold (build (PLUS_EXPR, ptr_type_node, field_reg_base,\n+\t\t       fold (build (PLUS_EXPR, TREE_TYPE (field), t,\n+\t\t\t\t    build_int_2 (ofs, 0)))));\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      \n+      val = expand_expr (t, ret, VOIDmode, EXPAND_NORMAL);\n+      if (val != ret)\n+\temit_move_insn (ret, val);\n+\n+      emit_jump_insn (gen_jump (lab_over));\n+      emit_barrier ();\n+      emit_label (lab_false);\n+    }\n+\n+  align = TYPE_ALIGN (type);\n+  if (align < BITS_PER_WORD)\n+    align = BITS_PER_WORD;\n+  align /= BITS_PER_UNIT;\n+\n+  t = build (PLUS_EXPR, ptr_type_node, field_mem_ptr,\n+\t     build_int_2 (align - 1, 0));\n+  t = build (BIT_AND_EXPR, ptr_type_node, t, build_int_2 (-align, -1));\n+\n+  val = expand_expr (t, ret, VOIDmode, EXPAND_NORMAL);\n+  if (val != ret)\n+    emit_move_insn (ret, val);\n+\n+  t = fold (build (PLUS_EXPR, ptr_type_node,\n+\t\t   make_tree (ptr_type_node, ret),\n+\t\t   build_int_2 (int_size_in_bytes (type), 0)));\n+  t = build (MODIFY_EXPR, ptr_type_node, field_mem_ptr, t);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  if (lab_over)\n+    emit_label (lab_over);\n+\n+  return ret;\n+}"}, {"sha": "a95eccfc842d0f88dbec1eff0784cfb8564050e9", "filename": "gcc/config/i860/i860.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0174469a67d4a7c6290237bf80084a3ddaae27a7/gcc%2Fconfig%2Fi860%2Fi860.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0174469a67d4a7c6290237bf80084a3ddaae27a7/gcc%2Fconfig%2Fi860%2Fi860.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.h?ref=0174469a67d4a7c6290237bf80084a3ddaae27a7", "patch": "@@ -596,6 +596,22 @@ struct cumulative_args { int ints, floats; };\n \n #define FUNCTION_EPILOGUE(FILE, SIZE) function_epilogue ((FILE), (SIZE))\n \n+/* Generate necessary RTL for __builtin_saveregs().  */\n+#define EXPAND_BUILTIN_SAVEREGS() \\\n+  i860_saveregs()\n+\n+/* Define the `__builtin_va_list' type for the ABI.  */\n+#define BUILD_VA_LIST_TYPE(VALIST) \\\n+  (VALIST) = i860_build_va_list ()\n+\n+/* Implement `va_start' for varargs and stdarg.  */\n+#define EXPAND_BUILTIN_VA_START(stdarg, valist, nextarg) \\\n+  i860_va_start (stdarg, valist, nextarg)\n+\n+/* Implement `va_arg'.  */\n+#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n+  i860_va_arg (valist, type)\n+\n /* Store in the variable DEPTH the initial difference between the\n    frame pointer reg contents and the stack pointer reg contents,\n    as of the start of the function body.  This depends on the layout\n@@ -1428,5 +1444,7 @@ extern char *output_move_double ();\n extern char *output_fp_move_double ();\n extern char *output_block_move ();\n extern char *output_delay_insn ();\n+#if 0\n extern char *output_delayed_branch ();\n+#endif\n extern void output_load_address ();"}, {"sha": "3b1fc32822c400f0b2ce421691d15a5a7144ca10", "filename": "gcc/config/i860/i860.md", "status": "modified", "additions": 96, "deletions": 92, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0174469a67d4a7c6290237bf80084a3ddaae27a7/gcc%2Fconfig%2Fi860%2Fi860.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0174469a67d4a7c6290237bf80084a3ddaae27a7/gcc%2Fconfig%2Fi860%2Fi860.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.md?ref=0174469a67d4a7c6290237bf80084a3ddaae27a7", "patch": "@@ -2072,34 +2072,38 @@ fmul.ss %1,%0,%4\\;fmul.ss %3,%4,%0\\\";\n \n ;; Here are two simple peepholes which fill the delay slot of\n ;; an unconditional branch.\n-\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n-\t(match_operand:SI 1 \"single_insn_src_p\" \"gfG\"))\n-   (set (pc) (label_ref (match_operand 2 \"\" \"\")))]\n-  \"\"\n-  \"* return output_delayed_branch (\\\"br %l2\\\", operands, insn);\")\n-\n-(define_peephole\n-  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n-\t(match_operand:SI 1 \"reg_or_0_operand\" \"rfJ\"))\n-   (set (pc) (label_ref (match_operand 2 \"\" \"\")))]\n-  \"\"\n-  \"* return output_delayed_branch (\\\"br %l2\\\", operands, insn);\")\n+;\n+;; ??? All disabled, because output_delayed_branch is a crock\n+;; that will reliably segfault.  This should be using the dbr\n+;; pass in any case.  Anyone who cares is welcome to fix it.\n+;\n+;(define_peephole\n+;  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n+;\t(match_operand:SI 1 \"single_insn_src_p\" \"gfG\"))\n+;   (set (pc) (label_ref (match_operand 2 \"\" \"\")))]\n+;  \"\"\n+;  \"* return output_delayed_branch (\\\"br %l2\\\", operands, insn);\")\n+;\n+;(define_peephole\n+;  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+;\t(match_operand:SI 1 \"reg_or_0_operand\" \"rfJ\"))\n+;   (set (pc) (label_ref (match_operand 2 \"\" \"\")))]\n+;  \"\"\n+;  \"* return output_delayed_branch (\\\"br %l2\\\", operands, insn);\")\n \n (define_insn \"tablejump\"\n   [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"\"\n   \"bri %0\\;nop\")\n \n-(define_peephole\n-  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n-\t(match_operand:SI 1 \"reg_or_0_operand\" \"rfJ\"))\n-   (set (pc) (match_operand:SI 2 \"register_operand\" \"r\"))\n-   (use (label_ref (match_operand 3 \"\" \"\")))]\n-  \"\"\n-  \"* return output_delayed_branch (\\\"bri %2\\\", operands, insn);\")\n+;(define_peephole\n+;  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+;\t(match_operand:SI 1 \"reg_or_0_operand\" \"rfJ\"))\n+;   (set (pc) (match_operand:SI 2 \"register_operand\" \"r\"))\n+;   (use (label_ref (match_operand 3 \"\" \"\")))]\n+;  \"\"\n+;  \"* return output_delayed_branch (\\\"bri %2\\\", operands, insn);\")\n \n ;;- jump to subroutine\n (define_expand \"call\"\n@@ -2137,37 +2141,37 @@ fmul.ss %1,%0,%4\\;fmul.ss %3,%4,%0\\\";\n   return \\\"call %0\\;nop\\\";\n }\")\n \n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n-\t(match_operand:SI 1 \"single_insn_src_p\" \"gfG\"))\n-   (call (match_operand:SI 2 \"memory_operand\" \"m\")\n-\t (match_operand 3 \"\" \"i\"))]\n-  ;;- Don't use operand 1 for most machines.\n-  \"! reg_mentioned_p (operands[0], operands[2])\"\n-  \"*\n-{\n-  /* strip the MEM.  */\n-  operands[2] = XEXP (operands[2], 0);\n-  if (GET_CODE (operands[2]) == REG)\n-    return output_delayed_branch (\\\"calli %2\\\", operands, insn);\n-  return output_delayed_branch (\\\"call %2\\\", operands, insn);\n-}\")\n-\n-(define_peephole\n-  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n-\t(match_operand:SI 1 \"reg_or_0_operand\" \"rfJ\"))\n-   (call (match_operand:SI 2 \"call_insn_operand\" \"m\")\n-\t (match_operand 3 \"\" \"i\"))]\n-  ;;- Don't use operand 1 for most machines.\n-  \"\"\n-  \"*\n-{\n-  /* strip the MEM.  */\n-  operands[2] = XEXP (operands[2], 0);\n-  if (GET_CODE (operands[2]) == REG)\n-    return output_delayed_branch (\\\"calli %2\\\", operands, insn);\n-  return output_delayed_branch (\\\"call %2\\\", operands, insn);\n-}\")\n+;(define_peephole\n+;  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n+;\t(match_operand:SI 1 \"single_insn_src_p\" \"gfG\"))\n+;   (call (match_operand:SI 2 \"memory_operand\" \"m\")\n+;\t (match_operand 3 \"\" \"i\"))]\n+;  ;;- Don't use operand 1 for most machines.\n+;  \"! reg_mentioned_p (operands[0], operands[2])\"\n+;  \"*\n+;{\n+;  /* strip the MEM.  */\n+;  operands[2] = XEXP (operands[2], 0);\n+;  if (GET_CODE (operands[2]) == REG)\n+;    return output_delayed_branch (\\\"calli %2\\\", operands, insn);\n+;  return output_delayed_branch (\\\"call %2\\\", operands, insn);\n+;}\")\n+\n+;(define_peephole\n+;  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+;\t(match_operand:SI 1 \"reg_or_0_operand\" \"rfJ\"))\n+;   (call (match_operand:SI 2 \"call_insn_operand\" \"m\")\n+;\t (match_operand 3 \"\" \"i\"))]\n+;  ;;- Don't use operand 1 for most machines.\n+;  \"\"\n+;  \"*\n+;{\n+;  /* strip the MEM.  */\n+;  operands[2] = XEXP (operands[2], 0);\n+;  if (GET_CODE (operands[2]) == REG)\n+;    return output_delayed_branch (\\\"calli %2\\\", operands, insn);\n+;  return output_delayed_branch (\\\"call %2\\\", operands, insn);\n+;}\")\n \n (define_expand \"call_value\"\n   [(set (match_operand 0 \"register_operand\" \"=rf\")\n@@ -2205,39 +2209,39 @@ fmul.ss %1,%0,%4\\;fmul.ss %3,%4,%0\\\";\n   return \\\"call %1\\;nop\\\";\n }\")\n \n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n-\t(match_operand:SI 1 \"single_insn_src_p\" \"gfG\"))\n-   (set (match_operand 2 \"\" \"=rf\")\n-\t(call (match_operand:SI 3 \"call_insn_operand\" \"m\")\n-\t      (match_operand 4 \"\" \"i\")))]\n-  ;;- Don't use operand 4 for most machines.\n-  \"! reg_mentioned_p (operands[0], operands[3])\"\n-  \"*\n-{\n-  /* strip the MEM.  */\n-  operands[3] = XEXP (operands[3], 0);\n-  if (GET_CODE (operands[3]) == REG)\n-    return output_delayed_branch (\\\"calli %3\\\", operands, insn);\n-  return output_delayed_branch (\\\"call %3\\\", operands, insn);\n-}\")\n-\n-(define_peephole\n-  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n-\t(match_operand:SI 1 \"reg_or_0_operand\" \"rJf\"))\n-   (set (match_operand 2 \"\" \"=rf\")\n-\t(call (match_operand:SI 3 \"call_insn_operand\" \"m\")\n-\t      (match_operand 4 \"\" \"i\")))]\n-  ;;- Don't use operand 4 for most machines.\n-  \"\"\n-  \"*\n-{\n-  /* strip the MEM.  */\n-  operands[3] = XEXP (operands[3], 0);\n-  if (GET_CODE (operands[3]) == REG)\n-    return output_delayed_branch (\\\"calli %3\\\", operands, insn);\n-  return output_delayed_branch (\\\"call %3\\\", operands, insn);\n-}\")\n+;(define_peephole\n+;  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n+;\t(match_operand:SI 1 \"single_insn_src_p\" \"gfG\"))\n+;   (set (match_operand 2 \"\" \"=rf\")\n+;\t(call (match_operand:SI 3 \"call_insn_operand\" \"m\")\n+;\t      (match_operand 4 \"\" \"i\")))]\n+;  ;;- Don't use operand 4 for most machines.\n+;  \"! reg_mentioned_p (operands[0], operands[3])\"\n+;  \"*\n+;{\n+;  /* strip the MEM.  */\n+;  operands[3] = XEXP (operands[3], 0);\n+;  if (GET_CODE (operands[3]) == REG)\n+;    return output_delayed_branch (\\\"calli %3\\\", operands, insn);\n+;  return output_delayed_branch (\\\"call %3\\\", operands, insn);\n+;}\")\n+\n+;(define_peephole\n+;  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+;\t(match_operand:SI 1 \"reg_or_0_operand\" \"rJf\"))\n+;   (set (match_operand 2 \"\" \"=rf\")\n+;\t(call (match_operand:SI 3 \"call_insn_operand\" \"m\")\n+;\t      (match_operand 4 \"\" \"i\")))]\n+;  ;;- Don't use operand 4 for most machines.\n+;  \"\"\n+;  \"*\n+;{\n+;  /* strip the MEM.  */\n+;  operands[3] = XEXP (operands[3], 0);\n+;  if (GET_CODE (operands[3]) == REG)\n+;    return output_delayed_branch (\\\"calli %3\\\", operands, insn);\n+;  return output_delayed_branch (\\\"call %3\\\", operands, insn);\n+;}\")\n \n ;; Call subroutine returning any type.\n \n@@ -2301,10 +2305,10 @@ fmul.ss %1,%0,%4\\;fmul.ss %3,%4,%0\\\";\n   return \\\"orh %H2,%?r0,%?r31\\;or %L2,%?r31,%?r31\\;ld.l %?r31(%1),%0\\\";\n }\")\n   \n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n-\t(match_operand:SI 1 \"single_insn_src_p\" \"gfG\"))\n-   (set (pc) (match_operand:SI 2 \"register_operand\" \"r\"))\n-   (use (label_ref (match_operand 3 \"\" \"\")))]\n-  \"REGNO (operands[0]) != REGNO (operands[2])\"\n-  \"* return output_delayed_branch (\\\"bri %2\\\", operands, insn);\")\n+;(define_peephole\n+;  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n+;\t(match_operand:SI 1 \"single_insn_src_p\" \"gfG\"))\n+;   (set (pc) (match_operand:SI 2 \"register_operand\" \"r\"))\n+;   (use (label_ref (match_operand 3 \"\" \"\")))]\n+;  \"REGNO (operands[0]) != REGNO (operands[2])\"\n+;  \"* return output_delayed_branch (\\\"bri %2\\\", operands, insn);\")"}, {"sha": "08d1112b28c6b3a25e5cb21a73e61369981e7ac6", "filename": "gcc/config/i860/sysv4.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0174469a67d4a7c6290237bf80084a3ddaae27a7/gcc%2Fconfig%2Fi860%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0174469a67d4a7c6290237bf80084a3ddaae27a7/gcc%2Fconfig%2Fi860%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fsysv4.h?ref=0174469a67d4a7c6290237bf80084a3ddaae27a7", "patch": "@@ -34,6 +34,10 @@ Boston, MA 02111-1307, USA.  */\n #define CPP_PREDEFINES \\\n   \"-Di860 -Dunix -DSVR4 -D__svr4__ -Asystem(unix) -Asystem(svr4) -Acpu(i860) -Amachine(i860)\"\n \n+/* For the benefit of i860_va_arg, flag it this way too.  */\n+\n+#define I860_SVR4_VA_LIST 1\n+\n /* The prefix to be used in assembler output for all names of registers.\n    This string gets prepended to all i860 register names (svr4 only).  */\n "}]}