{"sha": "c5604b48f91fa510171faf5a6e9d4138799186f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU2MDRiNDhmOTFmYTUxMDE3MWZhZjVhNmU5ZDQxMzg3OTkxODZmMQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2014-03-07T05:07:56Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-03-07T05:07:56Z"}, "message": "sort.c: New file.\n\n\t* sort.c: New file.\n\t* stest.c: New file.\n\t* internal.h (backtrace_qsort): Declare.\n\t* dwarf.c (read_abbrevs): Call backtrace_qsort instead of qsort.\n\t(read_line_info, read_function_entry): Likewise.\n\t(read_function_info, build_dwarf_data): Likewise.\n\t* elf.c (elf_initialize_syminfo): Likewise.\n\t* Makefile.am (libbacktrace_la_SOURCES): Add sort.c.\n\t(stest_SOURCES, stest_LDADD): Define.\n\t(check_PROGRAMS): Add stest.\n\nFrom-SVN: r208392", "tree": {"sha": "e0c8c1eba373485f6f43bbc665aa196c676034bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0c8c1eba373485f6f43bbc665aa196c676034bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5604b48f91fa510171faf5a6e9d4138799186f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5604b48f91fa510171faf5a6e9d4138799186f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5604b48f91fa510171faf5a6e9d4138799186f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5604b48f91fa510171faf5a6e9d4138799186f1/comments", "author": null, "committer": null, "parents": [{"sha": "9c48398f49677101465307e46eab76b26afe8751", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c48398f49677101465307e46eab76b26afe8751", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c48398f49677101465307e46eab76b26afe8751"}], "stats": {"total": 303, "additions": 288, "deletions": 15}, "files": [{"sha": "abbea3ed6e8b46e0796ce481c939b254a1e2b370", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5604b48f91fa510171faf5a6e9d4138799186f1/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5604b48f91fa510171faf5a6e9d4138799186f1/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=c5604b48f91fa510171faf5a6e9d4138799186f1", "patch": "@@ -1,3 +1,16 @@\n+2014-03-06  Ian Lance Taylor  <iant@google.com>\n+\n+\t* sort.c: New file.\n+\t* stest.c: New file.\n+\t* internal.h (backtrace_qsort): Declare.\n+\t* dwarf.c (read_abbrevs): Call backtrace_qsort instead of qsort.\n+\t(read_line_info, read_function_entry): Likewise.\n+\t(read_function_info, build_dwarf_data): Likewise.\n+\t* elf.c (elf_initialize_syminfo): Likewise.\n+\t* Makefile.am (libbacktrace_la_SOURCES): Add sort.c.\n+\t(stest_SOURCES, stest_LDADD): Define.\n+\t(check_PROGRAMS): Add stest.\n+\n 2014-02-07  Misty De Meo  <misty@brew.sh>\n \n \tPR target/58710"}, {"sha": "ab1a6b32b5e0a3d19bdb564b7c0df418f873797d", "filename": "libbacktrace/Makefile.am", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5604b48f91fa510171faf5a6e9d4138799186f1/libbacktrace%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5604b48f91fa510171faf5a6e9d4138799186f1/libbacktrace%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FMakefile.am?ref=c5604b48f91fa510171faf5a6e9d4138799186f1", "patch": "@@ -46,6 +46,7 @@ libbacktrace_la_SOURCES = \\\n \tinternal.h \\\n \tposix.c \\\n \tprint.c \\\n+\tsort.c \\\n \tstate.c\n \n BACKTRACE_FILES = \\\n@@ -93,6 +94,11 @@ btest_LDADD = libbacktrace.la\n \n check_PROGRAMS += btest\n \n+stest_SOURCES = stest.c\n+stest_LDADD = libbacktrace.la\n+\n+check_PROGRAMS += stest\n+\n endif NATIVE\n \n # We can't use automake's automatic dependency tracking, because it"}, {"sha": "f2821fc15262f90749ad545bae0800698f23d0e3", "filename": "libbacktrace/Makefile.in", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5604b48f91fa510171faf5a6e9d4138799186f1/libbacktrace%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5604b48f91fa510171faf5a6e9d4138799186f1/libbacktrace%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FMakefile.in?ref=c5604b48f91fa510171faf5a6e9d4138799186f1", "patch": "@@ -67,7 +67,7 @@ build_triplet = @build@\n host_triplet = @host@\n target_triplet = @target@\n check_PROGRAMS = $(am__EXEEXT_1)\n-@NATIVE_TRUE@am__append_1 = btest\n+@NATIVE_TRUE@am__append_1 = btest stest\n subdir = .\n DIST_COMMON = README ChangeLog $(srcdir)/Makefile.in \\\n \t$(srcdir)/Makefile.am $(top_srcdir)/configure \\\n@@ -94,15 +94,18 @@ CONFIG_CLEAN_VPATH_FILES =\n LTLIBRARIES = $(noinst_LTLIBRARIES)\n am__DEPENDENCIES_1 =\n am_libbacktrace_la_OBJECTS = atomic.lo dwarf.lo fileline.lo posix.lo \\\n-\tprint.lo state.lo\n+\tprint.lo sort.lo state.lo\n libbacktrace_la_OBJECTS = $(am_libbacktrace_la_OBJECTS)\n-@NATIVE_TRUE@am__EXEEXT_1 = btest$(EXEEXT)\n+@NATIVE_TRUE@am__EXEEXT_1 = btest$(EXEEXT) stest$(EXEEXT)\n @NATIVE_TRUE@am_btest_OBJECTS = btest-btest.$(OBJEXT)\n btest_OBJECTS = $(am_btest_OBJECTS)\n @NATIVE_TRUE@btest_DEPENDENCIES = libbacktrace.la\n btest_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CCLD) $(btest_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n \t$(LDFLAGS) -o $@\n+@NATIVE_TRUE@am_stest_OBJECTS = stest.$(OBJEXT)\n+stest_OBJECTS = $(am_stest_OBJECTS)\n+@NATIVE_TRUE@stest_DEPENDENCIES = libbacktrace.la\n DEFAULT_INCLUDES = -I.@am__isrc@\n depcomp =\n am__depfiles_maybe =\n@@ -116,7 +119,7 @@ LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n \t$(LDFLAGS) -o $@\n SOURCES = $(libbacktrace_la_SOURCES) $(EXTRA_libbacktrace_la_SOURCES) \\\n-\t$(btest_SOURCES)\n+\t$(btest_SOURCES) $(stest_SOURCES)\n MULTISRCTOP = \n MULTIBUILDTOP = \n MULTIDIRS = \n@@ -264,6 +267,7 @@ libbacktrace_la_SOURCES = \\\n \tinternal.h \\\n \tposix.c \\\n \tprint.c \\\n+\tsort.c \\\n \tstate.c\n \n BACKTRACE_FILES = \\\n@@ -300,6 +304,8 @@ TESTS = $(check_PROGRAMS)\n @NATIVE_TRUE@btest_SOURCES = btest.c\n @NATIVE_TRUE@btest_CFLAGS = $(AM_CFLAGS) -g -O\n @NATIVE_TRUE@btest_LDADD = libbacktrace.la\n+@NATIVE_TRUE@stest_SOURCES = stest.c\n+@NATIVE_TRUE@stest_LDADD = libbacktrace.la\n \n # We can't use automake's automatic dependency tracking, because it\n # breaks when using bootstrap-lean.  Automatic dependency tracking\n@@ -394,6 +400,9 @@ clean-checkPROGRAMS:\n btest$(EXEEXT): $(btest_OBJECTS) $(btest_DEPENDENCIES) \n \t@rm -f btest$(EXEEXT)\n \t$(btest_LINK) $(btest_OBJECTS) $(btest_LDADD) $(LIBS)\n+stest$(EXEEXT): $(stest_OBJECTS) $(stest_DEPENDENCIES) \n+\t@rm -f stest$(EXEEXT)\n+\t$(LINK) $(stest_OBJECTS) $(stest_LDADD) $(LIBS)\n \n mostlyclean-compile:\n \t-rm -f *.$(OBJEXT)"}, {"sha": "143bb280f5f83d70f237f6491d2786a9d4bc2465", "filename": "libbacktrace/dwarf.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5604b48f91fa510171faf5a6e9d4138799186f1/libbacktrace%2Fdwarf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5604b48f91fa510171faf5a6e9d4138799186f1/libbacktrace%2Fdwarf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fdwarf.c?ref=c5604b48f91fa510171faf5a6e9d4138799186f1", "patch": "@@ -1134,8 +1134,8 @@ read_abbrevs (struct backtrace_state *state, uint64_t abbrev_offset,\n       ++num_abbrevs;\n     }\n \n-  qsort (abbrevs->abbrevs, abbrevs->num_abbrevs, sizeof (struct abbrev),\n-\t abbrev_compare);\n+  backtrace_qsort (abbrevs->abbrevs, abbrevs->num_abbrevs,\n+\t\t   sizeof (struct abbrev), abbrev_compare);\n \n   return 1;\n \n@@ -2016,7 +2016,7 @@ read_line_info (struct backtrace_state *state, struct dwarf_data *ddata,\n     goto fail;\n \n   ln = (struct line *) vec.vec.base;\n-  qsort (ln, vec.count, sizeof (struct line), line_compare);\n+  backtrace_qsort (ln, vec.count, sizeof (struct line), line_compare);\n \n   *lines = ln;\n   *lines_count = vec.count;\n@@ -2476,9 +2476,9 @@ read_function_entry (struct backtrace_state *state, struct dwarf_data *ddata,\n \t\t    return 0;\n \n \t\t  faddrs = (struct function_addrs *) fvec.vec.base;\n-\t\t  qsort (faddrs, fvec.count,\n-\t\t\t sizeof (struct function_addrs),\n-\t\t\t function_addrs_compare);\n+\t\t  backtrace_qsort (faddrs, fvec.count,\n+\t\t\t\t   sizeof (struct function_addrs),\n+\t\t\t\t   function_addrs_compare);\n \n \t\t  function->function_addrs = faddrs;\n \t\t  function->function_addrs_count = fvec.count;\n@@ -2555,8 +2555,8 @@ read_function_info (struct backtrace_state *state, struct dwarf_data *ddata,\n       fvec->count = 0;\n     }\n \n-  qsort (addrs, addrs_count, sizeof (struct function_addrs),\n-\t function_addrs_compare);\n+  backtrace_qsort (addrs, addrs_count, sizeof (struct function_addrs),\n+\t\t   function_addrs_compare);\n \n   *ret_addrs = addrs;\n   *ret_addrs_count = addrs_count;\n@@ -2923,7 +2923,8 @@ build_dwarf_data (struct backtrace_state *state,\n     return NULL;\n   addrs = (struct unit_addrs *) addrs_vec.vec.base;\n   addrs_count = addrs_vec.count;\n-  qsort (addrs, addrs_count, sizeof (struct unit_addrs), unit_addrs_compare);\n+  backtrace_qsort (addrs, addrs_count, sizeof (struct unit_addrs),\n+\t\t   unit_addrs_compare);\n \n   fdata = ((struct dwarf_data *)\n \t   backtrace_alloc (state, sizeof (struct dwarf_data),"}, {"sha": "e63aaf5dbdfef94339da3c5e7b5d9c7889f1d781", "filename": "libbacktrace/elf.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5604b48f91fa510171faf5a6e9d4138799186f1/libbacktrace%2Felf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5604b48f91fa510171faf5a6e9d4138799186f1/libbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Felf.c?ref=c5604b48f91fa510171faf5a6e9d4138799186f1", "patch": "@@ -407,8 +407,8 @@ elf_initialize_syminfo (struct backtrace_state *state,\n       ++j;\n     }\n \n-  qsort (elf_symbols, elf_symbol_count, sizeof (struct elf_symbol),\n-\t elf_symbol_compare);\n+  backtrace_qsort (elf_symbols, elf_symbol_count, sizeof (struct elf_symbol),\n+\t\t   elf_symbol_compare);\n \n   sdata->next = NULL;\n   sdata->symbols = elf_symbols;"}, {"sha": "1ae43177f380ee831fe8055f0c1dc68c895499c2", "filename": "libbacktrace/internal.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5604b48f91fa510171faf5a6e9d4138799186f1/libbacktrace%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5604b48f91fa510171faf5a6e9d4138799186f1/libbacktrace%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Finternal.h?ref=c5604b48f91fa510171faf5a6e9d4138799186f1", "patch": "@@ -196,6 +196,11 @@ extern int backtrace_close (int descriptor,\n \t\t\t    backtrace_error_callback error_callback,\n \t\t\t    void *data);\n \n+/* Sort without using memory.  */\n+\n+extern void backtrace_qsort (void *base, size_t count, size_t size,\n+\t\t\t     int (*compar) (const void *, const void *));\n+\n /* Allocate memory.  This is like malloc.  */\n \n extern void *backtrace_alloc (struct backtrace_state *state, size_t size,"}, {"sha": "88f9231422472eac95d41194115ede9e84ceceb4", "filename": "libbacktrace/sort.c", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5604b48f91fa510171faf5a6e9d4138799186f1/libbacktrace%2Fsort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5604b48f91fa510171faf5a6e9d4138799186f1/libbacktrace%2Fsort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fsort.c?ref=c5604b48f91fa510171faf5a6e9d4138799186f1", "patch": "@@ -0,0 +1,102 @@\n+/* sort.c -- Sort without allocating memory\n+   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <stddef.h>\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* The GNU glibc version of qsort allocates memory, which we must not\n+   do if we are invoked by a signal handler.  So provide our own\n+   sort.  */\n+\n+static void\n+swap (char *a, char *b, size_t size)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < size; i++, a++, b++)\n+    {\n+      char t;\n+\n+      t = *a;\n+      *a = *b;\n+      *b = t;\n+    }\n+}\n+\n+void\n+backtrace_qsort (void *basearg, size_t count, size_t size,\n+\t\t int (*compar) (const void *, const void *))\n+{\n+  char *base = (char *) basearg;\n+  size_t i;\n+  size_t mid;\n+\n+ tail_recurse:\n+  if (count < 2)\n+    return;\n+\n+  mid = 0;\n+  for (i = 1; i < count; i++)\n+    {\n+      if ((*compar) (base, base + i * size) > 0)\n+\t{\n+\t  ++mid;\n+\t  if (i != mid)\n+\t    swap (base + mid * size, base + i * size, size);\n+\t}\n+    }\n+\n+  if (mid > 0)\n+    swap (base, base + mid * size, size);\n+\n+  /* Recurse with the smaller array, loop with the larger one.  That\n+     ensures that our maximum stack depth is log count.  */\n+  if (2 * mid < count)\n+    {\n+      backtrace_qsort (base, mid, size, compar);\n+      base += (mid + 1) * size;\n+      count -= mid + 1;\n+      goto tail_recurse;\n+    }\n+  else\n+    {\n+      backtrace_qsort (base + (mid + 1) * size, count - (mid + 1),\n+\t\t       size, compar);\n+      count = mid;\n+      goto tail_recurse;\n+    }\n+}"}, {"sha": "5676745547d80aebf499c29d4ebc1445099a1c00", "filename": "libbacktrace/stest.c", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5604b48f91fa510171faf5a6e9d4138799186f1/libbacktrace%2Fstest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5604b48f91fa510171faf5a6e9d4138799186f1/libbacktrace%2Fstest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fstest.c?ref=c5604b48f91fa510171faf5a6e9d4138799186f1", "patch": "@@ -0,0 +1,137 @@\n+/* stest.c -- Test for libbacktrace internal sort function\n+   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* Test the local qsort implementation.  */\n+\n+#define MAX 10\n+\n+struct test\n+{\n+  size_t count;\n+  int input[MAX];\n+  int output[MAX];\n+};\n+\n+static struct test tests[] =\n+  {\n+    {\n+      10,\n+      { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },\n+      { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }\n+    },\n+    {\n+      9,\n+      { 1, 2, 3, 4, 5, 6, 7, 8, 9 },\n+      { 1, 2, 3, 4, 5, 6, 7, 8, 9 }\n+    },\n+    {\n+      10,\n+      { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 },\n+      { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },\n+    },\n+    {\n+      9,\n+      { 9, 8, 7, 6, 5, 4, 3, 2, 1 },\n+      { 1, 2, 3, 4, 5, 6, 7, 8, 9 },\n+    },\n+    {\n+      10,\n+      { 2, 4, 6, 8, 10, 1, 3, 5, 7, 9 },\n+      { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },\n+    },\n+    {\n+      5,\n+      { 4, 5, 3, 1, 2 },\n+      { 1, 2, 3, 4, 5 },\n+    },\n+    {\n+      5,\n+      { 1, 1, 1, 1, 1 },\n+      { 1, 1, 1, 1, 1 },\n+    },\n+    {\n+      5,\n+      { 1, 1, 2, 1, 1 },\n+      { 1, 1, 1, 1, 2 },\n+    },\n+    {\n+      5,\n+      { 2, 1, 1, 1, 1 },\n+      { 1, 1, 1, 1, 2 },\n+    },\n+  };\n+\n+static int\n+compare (const void *a, const void *b)\n+{\n+  const int *ai = (const int *) a;\n+  const int *bi = (const int *) b;\n+\n+  return *ai - *bi;\n+}\n+\n+int\n+main (int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED)\n+{\n+  int failures;\n+  size_t i;\n+  int a[MAX];\n+\n+  failures = 0;\n+  for (i = 0; i < sizeof tests / sizeof tests[0]; i++)\n+    {\n+      memcpy (a, tests[i].input, tests[i].count * sizeof (int));\n+      backtrace_qsort (a, tests[i].count, sizeof (int), compare);\n+      if (memcmp (a, tests[i].output, tests[i].count * sizeof (int)) != 0)\n+\t{\n+\t  size_t j;\n+\n+\t  fprintf (stderr, \"test %d failed:\", (int) i);\n+\t  for (j = 0; j < tests[i].count; j++)\n+\t    fprintf (stderr, \" %d\", a[j]);\n+\t  fprintf (stderr, \"\\n\");\n+\t  ++failures;\n+\t}\n+    }\n+\n+  exit (failures > 0 ? EXIT_FAILURE : EXIT_SUCCESS);\n+}"}]}