{"sha": "956e776dd245fe24a7d9586451e9f3d6ae8efa07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU2ZTc3NmRkMjQ1ZmUyNGE3ZDk1ODY0NTFlOWYzZDZhZThlZmEwNw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-01-23T00:07:39Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-01-23T00:07:39Z"}, "message": "TextField.java: Replaced with Classpath version.\n\n\t* java/awt/TextField.java: Replaced with Classpath version.\n\t* java/awt/TextArea.java: Replaced with Classpath version.\n\t* java/awt/TextComponent.java: Replaced with Classpath version.\n\nFrom-SVN: r49113", "tree": {"sha": "99f00b9ed0ddb5e870f2d0e8cdb1cdd2e918bc44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99f00b9ed0ddb5e870f2d0e8cdb1cdd2e918bc44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/956e776dd245fe24a7d9586451e9f3d6ae8efa07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/956e776dd245fe24a7d9586451e9f3d6ae8efa07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/956e776dd245fe24a7d9586451e9f3d6ae8efa07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/956e776dd245fe24a7d9586451e9f3d6ae8efa07/comments", "author": null, "committer": null, "parents": [{"sha": "d0c9db30790251ccb1e4af3848aceb41ead63d71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0c9db30790251ccb1e4af3848aceb41ead63d71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0c9db30790251ccb1e4af3848aceb41ead63d71"}], "stats": {"total": 1503, "additions": 1417, "deletions": 86}, "files": [{"sha": "afaeacbacff13bb64f2f35c673df455fc7de023f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956e776dd245fe24a7d9586451e9f3d6ae8efa07/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956e776dd245fe24a7d9586451e9f3d6ae8efa07/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=956e776dd245fe24a7d9586451e9f3d6ae8efa07", "patch": "@@ -1,5 +1,9 @@\n 2002-01-22  Tom Tromey  <tromey@redhat.com>\n \n+\t* java/awt/TextField.java: Replaced with Classpath version.\n+\t* java/awt/TextArea.java: Replaced with Classpath version.\n+\t* java/awt/TextComponent.java: Replaced with Classpath version.\n+\n \t* java/awt/GridBagConstraints.java: Updated copyright.\n \n 2002-01-22  Mark Wielaard <mark@klomp.org>"}, {"sha": "799656ec5547d0c35fd304eb811c9a97557ecd8d", "filename": "libjava/java/awt/TextArea.java", "status": "modified", "additions": 543, "deletions": 43, "changes": 586, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956e776dd245fe24a7d9586451e9f3d6ae8efa07/libjava%2Fjava%2Fawt%2FTextArea.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956e776dd245fe24a7d9586451e9f3d6ae8efa07/libjava%2Fjava%2Fawt%2FTextArea.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FTextArea.java?ref=956e776dd245fe24a7d9586451e9f3d6ae8efa07", "patch": "@@ -1,49 +1,549 @@\n-/* Copyright (C) 1999  Free Software Foundation\n+/* TextArea.java -- A multi-line text entry widget\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n \n-   This file is part of libjava.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libjava License.  Please consult the file \"LIBJAVA_LICENSE\" for\n-details.  */\n \n package java.awt;\n \n-/* A very incomplete placeholder. */\n-\n-public class TextArea extends TextComponent\n-{\n-  public synchronized void append (String str)\n-  {\n-    replaceRange(str, length, length);\n-  }\n-\n-  public synchronized void insert (String str, int pos)\n-  {\n-    replaceRange(str, pos, pos);\n-  }\n-\n-  public synchronized void replaceRange (String str, int start, int end)\n-  {\n-    if (length == 0)\n-      setText (str);\n-    else\n-      {\n-\tint len = str.length();\n-\tint delta = len - (end - start);\n-\tint new_length = length + delta;\n-\tif (buffer.length < new_length)\n-\t  {\n-\t    int new_size = 2 * buffer.length;\n-\t    if (new_size < new_length)\n-\t      new_size = new_length;\n-\t    char[] new_buffer = new char[new_size];\n-\t    System.arraycopy(buffer, 0, new_buffer, 0, length);\n-\t    buffer = new_buffer;\n-\t  }\n-\tif (len != end)\n-\t  System.arraycopy(buffer, start, buffer, start + len, len - end);\n-\tstr.getChars(0, len, buffer, start);\n-\tlength += delta;\n-      }\n-  }\n+import java.awt.peer.TextAreaPeer;\n+import java.awt.peer.TextComponentPeer;\n+import java.awt.peer.ComponentPeer;\n+\n+/**\n+  * This implements a multi-line text entry widget.\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public class TextArea extends TextComponent implements java.io.Serializable\n+{\n+\n+/*\n+ * Static Variables\n+ */\n+\n+/**\n+  * Use both horiztonal and vertical scroll bars.\n+  */\n+public static final int SCROLLBARS_BOTH = 0;\n+\n+/**\n+  * Use vertical scroll bars only.\n+  */\n+public static final int SCROLLBARS_VERTICAL_ONLY = 1;\n+\n+/**\n+  * Use horizatonal scroll bars only.\n+  */\n+public static final int SCROLLBARS_HORIZONTAL_ONLY = 2;\n+\n+/**\n+  * Use no scrollbars.\n+  */\n+public static final int SCROLLBARS_NONE = 3;\n+\n+// Serialization constant\n+private static final long serialVersionUID = 3692302836626095722L;\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Variables\n+ */\n+\n+/**\n+  * @serial The number of columns in this text area.\n+  */\n+private int columns;\n+\n+/**\n+  * @serial The number of rows in this text area.\n+  */\n+private int rows;\n+\n+/**\n+  * @serial The type of scrollbars to display, which will be one of\n+  * the contstants from this class.\n+  */\n+private int scrollbarVisibility;\n+\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n+ */\n+\n+/**\n+  * Initialize a new instance of <code>TextArea</code> that is empty\n+  * and is one row and one column.  Both horizontal and vertical\n+  * scrollbars will be used.\n+  */\n+public\n+TextArea()\n+{\n+  this(\"\", 1, 1, SCROLLBARS_BOTH);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Initializes a new instance of <code>TextArea</code> that \n+  * contains the specified string.  Both horizontal and veritcal\n+  * scrollbars will be used.\n+  *\n+  * @param text The text to display in this text area.\n+  */\n+public\n+TextArea(String text)\n+{\n+  this(text, 1, text.length(), SCROLLBARS_BOTH);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Initializes a new instance of <code>TextArea</code> that is empty\n+  * and has the specified number of rows and columns.  Both\n+  * horizontal and vertical scrollbars will be used.\n+  *\n+  * @param rows The number of rows in this text area.\n+  * @param columns The number of columns in this text area.\n+  */\n+public\n+TextArea(int rows, int columns)\n+{\n+  this(\"\", rows, columns, SCROLLBARS_BOTH);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Initializes a new instance of <code>TextArea</code> that is the\n+  * specified size and has the specified text.\n+  *\n+  * @param text The text to display in this text area.\n+  * @param rows The number of rows in this text area.\n+  * @param columns The number of columns in this text area.\n+  */\n+public\n+TextArea(String text, int rows, int columns)\n+{\n+  this(text, rows, columns, SCROLLBARS_BOTH);\n+}\n+\n+/*************************************************************************/\n+\n+/** \n+  * Initializes a new instance of <code>TextArea</code> with the\n+  * specified values.  The scrollbar visibility value must be one\n+  * of the constants in this class.\n+  *\n+  * @param text The text to display in this text area.\n+  * @param rows The number of rows in this text area.\n+  * @param columns The number of columns in this text area.\n+  * @param scrollbarVisibility Which scrollbars to display.\n+  */\n+public\n+TextArea(String text, int rows, int columns, int scrollbarVisibility)\n+{\n+  super(text);\n+\n+  if ((rows < 1) || (columns < 0))\n+    throw new IllegalArgumentException(\"Bad row or column value\");\n+\n+  if ((scrollbarVisibility != SCROLLBARS_BOTH) &&\n+      (scrollbarVisibility != SCROLLBARS_VERTICAL_ONLY) &&\n+      (scrollbarVisibility != SCROLLBARS_HORIZONTAL_ONLY) &&\n+      (scrollbarVisibility != SCROLLBARS_NONE))\n+    throw new IllegalArgumentException(\"Bad scrollbar visibility value\");\n+\n+  this.rows = rows;\n+  this.columns = columns;\n+  this.scrollbarVisibility = scrollbarVisibility;\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Variables\n+ */\n+\n+/**\n+  * Returns the number of columns in the field.\n+  *\n+  * @return The number of columns in the field.\n+  */\n+public int\n+getColumns()\n+{\n+  return(columns);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Sets the number of columns in this field to the specified value.\n+  *\n+  * @param columns The new number of columns in the field.\n+  *\n+  * @exception IllegalArgumentException If columns is less than zero.\n+  */\n+public synchronized void\n+setColumns(int columns)\n+{\n+  if (columns < 0)\n+    throw new IllegalArgumentException(\"Value is less than zero: \" +\n+                                       columns);\n+\n+  this.columns = columns;\n+  // FIXME: How to we communicate this to our peer?\n }\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the number of rows in the field.\n+  *\n+  * @return The number of rows in the field.\n+  */\n+public int\n+getRows()\n+{\n+  return(rows);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Sets the number of rows in this field to the specified value.\n+  *\n+  * @param rows The new number of rows in the field.\n+  *\n+  * @exception IllegalArgumentException If rows is less than zero.\n+  */\n+public synchronized void\n+setRows(int rows)\n+{\n+  if (rows < 1)\n+    throw new IllegalArgumentException(\"Value is less than one: \" +\n+                                       rows);\n+\n+  this.rows = rows;\n+  // FIXME: How to we communicate this to our peer?\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the minimum size for this text field.\n+  *\n+  * @return The minimum size for this text field.\n+  */\n+public Dimension\n+getMinimumSize()\n+{\n+  return(getMinimumSize(getRows(), getColumns()));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the minimum size of a text field with the specified number\n+  * of rows and columns.\n+  *\n+  * @param rows The number of rows to get the minimum size for.\n+  * @param columns The number of columns to get the minimum size for.\n+  */\n+public Dimension\n+getMinimumSize(int rows, int columns)\n+{\n+  TextAreaPeer tap = (TextAreaPeer)getPeer();\n+  if (tap == null)\n+    return(null); // FIXME: What do we do if there is no peer?\n+\n+  return(tap.getMinimumSize(rows, columns));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the minimum size for this text field.\n+  *\n+  * @return The minimum size for this text field.\n+  *\n+  * @deprecated This method is depcreated in favor of\n+  * <code>getMinimumSize()</code>.\n+  */\n+public Dimension\n+minimumSize()\n+{\n+  return(getMinimumSize(getRows(), getColumns()));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the minimum size of a text field with the specified number\n+  * of rows and columns.\n+  *\n+  * @param rows The number of rows to get the minimum size for.\n+  * @param columns The number of columns to get the minimum size for.\n+  *\n+  * @deprecated This method is deprecated in favor of \n+  * <code>getMinimumSize(int)</code>.\n+  */\n+public Dimension\n+minimumSize(int rows, int columns)\n+{\n+  return(getMinimumSize(rows, columns));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the preferred size for this text field.\n+  *\n+  * @return The preferred size for this text field.\n+  */\n+public Dimension\n+getPreferredSize()\n+{\n+  return(getPreferredSize(getRows(), getColumns()));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the preferred size of a text field with the specified number\n+  * of rows and columns.\n+  *\n+  * @param rows The number of rows to get the preferred size for.\n+  * @param columns The number of columns to get the preferred size for.\n+  */\n+public Dimension\n+getPreferredSize(int rows, int columns)\n+{\n+  TextAreaPeer tap = (TextAreaPeer)getPeer();\n+  if (tap == null)\n+    return(null); // FIXME: What do we do if there is no peer?\n+\n+  return(tap.getPreferredSize(rows, columns));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the preferred size for this text field.\n+  *\n+  * @return The preferred size for this text field.\n+  *\n+  * @deprecated This method is deprecated in favor of \n+  * <code>getPreferredSize()</code>.\n+  */\n+public Dimension\n+preferredSize()\n+{\n+  return(getPreferredSize(getRows(), getColumns()));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the preferred size of a text field with the specified number\n+  * of rows and columns.\n+  *\n+  * @param rows The number of rows to get the preferred size for.\n+  * @param columns The number of columns to get the preferred size for.\n+  *\n+  * @deprecated This method is deprecated in favor of \n+  * <code>getPreferredSize(int)</code>.\n+  */\n+public Dimension\n+preferredSize(int columns)\n+{\n+  return(getPreferredSize(rows, columns));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns one of the constants from this class indicating which\n+  * types of scrollbars this object uses, if any.\n+  *\n+  * @return The scrollbar type constant for this object.\n+  */\n+public int\n+getScrollbarVisibility()\n+{\n+  return(scrollbarVisibility);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Notify this object that it should create its native peer.\n+  */\n+public void\n+addNotify()\n+{\n+  if (getPeer() != null)\n+    return;\n+\n+  setPeer((ComponentPeer)getToolkit().createTextArea(this));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Appends the specified text to the end of the current text.\n+  *\n+  * @param text The text to append.\n+  */\n+public void\n+append(String str)\n+{\n+  TextAreaPeer tap = (TextAreaPeer)getPeer();\n+  if (tap == null) \n+    return;\n+\n+  tap.insert(str, tap.getText().length());\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Appends the specified text to the end of the current text.\n+  *\n+  * @param text The text to append.\n+  *\n+  * @deprecated This method is deprecated in favor of \n+  * <code>append()</code>.\n+  */\n+public void\n+appendText(String text)\n+{\n+  append(text);\n+}\n+ \n+/*************************************************************************/\n+\n+/**\n+  * Inserts the specified text at the specified location.\n+  *\n+  * @param text The text to insert.\n+  * @param pos The insert position.\n+  */\n+public void\n+insert(String text, int pos)\n+{\n+  TextAreaPeer tap = (TextAreaPeer)getPeer();\n+  if (tap == null)\n+    return;\n+\n+  tap.insert(text, pos);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Inserts the specified text at the specified location.\n+  *\n+  * @param text The text to insert.\n+  * @param pos The insert position.\n+  *\n+  * @deprecated This method is depcreated in favor of <code>insert()</code>.\n+  */\n+public void\n+insertText(String text, int pos)\n+{\n+  insert(text, pos);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Replaces the text bounded by the specified start and end positions\n+  * with the specified text.\n+  *\n+  * @param text The new text for the range.\n+  * @param start The start position of the replacement range.\n+  * @param end The end position of the replacement range.\n+  */\n+public void\n+replaceRange(String text, int start, int end)\n+{\n+  TextAreaPeer tap = (TextAreaPeer)getPeer();\n+  if (tap == null)\n+    return;\n+\n+  tap.replaceRange(text, start, end);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Replaces the text bounded by the specified start and end positions\n+  * with the specified text.\n+  *\n+  * @param text The new text for the range.\n+  * @param start The start position of the replacement range.\n+  * @param end The end position of the replacement range.\n+  *\n+  * @deprecated This method is deprecated in favor of\n+  * <code>replaceRange()</code>.\n+  */\n+public void\n+replaceText(String text, int start, int end)\n+{\n+  replaceRange(text, start, end);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns a debugging string for this text area.\n+  *\n+  * @return A debugging string for this text area.\n+  */\n+protected String\n+paramString()\n+{\n+  return(getClass().getName() + \"(rows=\" + getRows() + \",columns=\" +\n+         getColumns() + \",scrollbars=\" + getScrollbarVisibility() +\n+         \")\");\n+}\n+\n+} // class TextArea \n+"}, {"sha": "a90cb80e52d2825293ad02ca3568950841663a60", "filename": "libjava/java/awt/TextComponent.java", "status": "modified", "additions": 409, "deletions": 35, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956e776dd245fe24a7d9586451e9f3d6ae8efa07/libjava%2Fjava%2Fawt%2FTextComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956e776dd245fe24a7d9586451e9f3d6ae8efa07/libjava%2Fjava%2Fawt%2FTextComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FTextComponent.java?ref=956e776dd245fe24a7d9586451e9f3d6ae8efa07", "patch": "@@ -1,51 +1,425 @@\n-/* Copyright (C) 1999, 2001  Free Software Foundation\n+/* TextComponent.java -- Widgets for entering text\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n \n-   This file is part of libjava.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libjava License.  Please consult the file \"LIBJAVA_LICENSE\" for\n-details.  */\n \n package java.awt;\n \n-import java.awt.event.*;\n+import java.awt.event.TextEvent;\n+import java.awt.event.TextListener;\n import java.awt.peer.TextComponentPeer;\n+import java.awt.peer.ComponentPeer;\n+\n+/**\n+  * This class provides common functionality for widgets than \n+  * contain text.\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public class TextComponent extends Component implements java.io.Serializable\n+{\n+\n+/*\n+ * Static Variables\n+ */\n+\n+// Constant for serialization\n+private static final long serialVersionUID = -2214773872412987419L;\n+\n+/*\n+ * Instance Variables\n+ */\n+\n+/**\n+  * @serial Indicates whether or not this component is editable.\n+  */\n+private boolean editable;\n+\n+/**\n+  * @serial The starting position of the selected text region.\n+  */\n+private int selectionStart;\n+\n+/**\n+  * @serial The ending position of the selected text region.\n+  */\n+private int selectionEnd;\n \n-/* A very incomplete placeholder. */\n+/**\n+  * @serial The text in the component\n+  */\n+private String text;\n \n-public class TextComponent extends Component\n+/**\n+  * A list of listeners that will receive events from this object.\n+  */\n+protected transient TextListener textListener;\n+\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n+ */\n+\n+TextComponent(String text)\n {\n-  protected TextListener textListener;\n+  this.text = text;\n+}\n \n-  char[] buffer;\n-  int length;\n-  int caretPosition;\n+/*************************************************************************/\n \n-  public synchronized void addTextListener (TextListener listener)\n-  {\n-    textListener = AWTEventMulticaster.add (textListener, listener);\n-  }\n+/*\n+ * Instance Methods\n+ */\n \n-  public synchronized String getText ()\n-  { return new String(buffer, 0, length); }\n+/**\n+  * Returns the text in this component\n+  *\n+  * @return The text in this component.\n+  */\n+public synchronized String\n+getText()\n+{\n+  TextComponentPeer tcp = (TextComponentPeer)getPeer();\n+  if (tcp != null)\n+    text = tcp.getText();\n \n-  public synchronized void setText (String text)\n-  {\n-    length = text.length();\n-    if (buffer == null || buffer.length < length)\n-      buffer = new char[length];\n-    text.getChars(0, length, buffer, 0);\n-  }\n+  return(text);\n+}\n \n-  public int getCaretPosition () { return caretPosition; }\n+/*************************************************************************/\n \n-  public void setCaretPosition (int pos)\n-  {\n-    caretPosition = pos;\n-    if (peer != null)\n-      {\n-\tTextComponentPeer t = (TextComponentPeer) peer;\n-\tt.setCaretPosition (pos);\n-      }\n-  }\n+/**\n+  * Sets the text in this component to the specified string.\n+  *\n+  * @param text The new text for this component.\n+  */\n+public synchronized void\n+setText(String text)\n+{\n+  if (text == null)\n+    text = \"\";\n+\n+  this.text = text;\n+\n+  TextComponentPeer tcp = (TextComponentPeer)getPeer();\n+  if (tcp != null)\n+    tcp.setText(text);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns a string that contains the text that is currently selected.\n+  *\n+  * @return The currently selected text region.\n+  */\n+public synchronized String\n+getSelectedText()\n+{\n+  String alltext = getText();\n+  int start = getSelectionStart();\n+  int end = getSelectionEnd();\n+  \n+  return(alltext.substring(start, end));\n }\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the starting position of the selected text region.\n+  * // FIXME: What is returned if there is no selected text?\n+  *\n+  * @return The starting position of the selected text region.\n+  */\n+public synchronized int\n+getSelectionStart()\n+{\n+  TextComponentPeer tcp = (TextComponentPeer)getPeer();\n+  if (tcp != null)\n+    selectionStart = tcp.getSelectionStart();\n+\n+  return(selectionStart);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Sets the starting position of the selected region to the\n+  * specified value.  If the specified value is out of range, then it\n+  * will be silently changed to the nearest legal value.\n+  *\n+  * @param selectionStart The new start position for selected text.\n+  */\n+public synchronized void\n+setSelectionStart(int selectionStart)\n+{\n+  select(selectionStart, getSelectionEnd());\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the ending position of the selected text region.\n+  * // FIXME: What is returned if there is no selected text.\n+  *\n+  * @return The ending position of the selected text region.\n+  */\n+public synchronized int\n+getSelectionEnd()\n+{\n+  TextComponentPeer tcp = (TextComponentPeer)getPeer();\n+  if (tcp != null)\n+    selectionEnd = tcp.getSelectionEnd();\n+\n+  return(selectionEnd);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Sets the ending position of the selected region to the\n+  * specified value.  If the specified value is out of range, then it\n+  * will be silently changed to the nearest legal value.\n+  *\n+  * @param selectionEnd The new start position for selected text.\n+  */\n+public synchronized void\n+setSelectionEnd(int selectionEnd)\n+{\n+  select(getSelectionStart(), selectionEnd);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method sets the selected text range to the text between the\n+  * specified start and end positions.  Illegal values for these\n+  * positions are silently fixed.\n+  *\n+  * @param startSelection The new start position for the selected text.\n+  * @param endSelection The new end position for the selected text.\n+  */\n+public synchronized void\n+select(int selectionStart, int endSelection)\n+{\n+  if (selectionStart < 0)\n+    selectionStart = 0;\n+\n+  if (selectionStart > getText().length())\n+    selectionStart = text.length();\n+\n+  if (selectionEnd > text.length())\n+    selectionEnd = text.length();\n+\n+  if (selectionStart > getSelectionEnd())\n+    selectionStart = selectionEnd;\n+\n+  this.selectionStart = selectionStart;\n+  this.selectionEnd = selectionEnd;\n+\n+  TextComponentPeer tcp = (TextComponentPeer)getPeer();\n+  if (tcp != null)\n+    tcp.select(selectionStart, selectionEnd);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Selects all of the text in the component.\n+  */\n+public synchronized void\n+selectAll()\n+{\n+  select(0, getText().length());\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the current caret position in the text.\n+  *\n+  * @return The caret position in the text.\n+  */\n+public synchronized int\n+getCaretPosition()\n+{\n+  TextComponentPeer tcp = (TextComponentPeer)getPeer();\n+  if (tcp != null)\n+    return(tcp.getCaretPosition());\n+  else\n+    return(0);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Sets the caret position to the specified value.\n+  *\n+  * @param caretPosition The new caret position.\n+  */\n+public synchronized void\n+setCaretPosition(int caretPosition)\n+{\n+  TextComponentPeer tcp = (TextComponentPeer)getPeer();\n+  if (tcp != null)\n+    tcp.setCaretPosition(caretPosition);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Tests whether or not this component's text can be edited.\n+  *\n+  * @return <code>true</code> if the text can be edited, <code>false</code>\n+  * otherwise.\n+  */\n+public boolean\n+isEditable()\n+{\n+  return(editable);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Sets whether or not this component's text can be edited.\n+  *\n+  * @param editable <code>true</code> to enable editing of the text,\n+  * <code>false</code> to disable it.\n+  */\n+public synchronized void\n+setEditable(boolean editable)\n+{\n+  this.editable = editable;\n+\n+  TextComponentPeer tcp = (TextComponentPeer)getPeer();\n+  if (tcp != null)\n+    tcp.setEditable(editable);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Notifies the component that it should destroy its native peer.\n+  */\n+public void\n+removeNotify()\n+{\n+  super.removeNotify();\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Adds a new listener to the list of text listeners for this\n+  * component.\n+  *\n+  * @param listener The listener to be added.\n+  */\n+public synchronized void\n+addTextListener(TextListener listener)\n+{\n+  textListener = AWTEventMulticaster.add(textListener, listener);\n+\n+  enableEvents(AWTEvent.TEXT_EVENT_MASK);  \n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Removes the specified listener from the list of listeners\n+  * for this component.\n+  *\n+  * @param listener The listener to remove.\n+  */\n+public synchronized void\n+removeTextListener(TextListener listener)\n+{\n+  textListener = AWTEventMulticaster.remove(textListener, listener);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Processes the specified event for this component.  Text events are\n+  * processed by calling the <code>processTextEvent()</code> method.\n+  * All other events are passed to the superclass method.\n+  * \n+  * @param event The event to process.\n+  */\n+protected void\n+processEvent(AWTEvent event)\n+{\n+  if (event instanceof TextEvent)\n+    processTextEvent((TextEvent)event);\n+  else\n+    super.processEvent(event);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Processes the specified text event by dispatching it to any listeners\n+  * that are registered.  Note that this method will only be called\n+  * if text event's are enabled.  This will be true if there are any\n+  * registered listeners, or if the event has been specifically\n+  * enabled using <code>enableEvents()</code>.\n+  *\n+  * @param event The text event to process.\n+  */\n+protected void\n+processTextEvent(TextEvent event)\n+{\n+  if (textListener != null)\n+    textListener.textValueChanged(event);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns a debugging string.\n+  *\n+  * @return A debugging string.\n+  */\n+protected String\n+paramString()\n+{\n+  return(getClass().getName() + \"(text=\" + getText() + \")\");\n+}\n+\n+} // class TextComponent\n+"}, {"sha": "5499305f8751b1937973031602151f4b8c714f70", "filename": "libjava/java/awt/TextField.java", "status": "modified", "additions": 461, "deletions": 8, "changes": 469, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956e776dd245fe24a7d9586451e9f3d6ae8efa07/libjava%2Fjava%2Fawt%2FTextField.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956e776dd245fe24a7d9586451e9f3d6ae8efa07/libjava%2Fjava%2Fawt%2FTextField.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FTextField.java?ref=956e776dd245fe24a7d9586451e9f3d6ae8efa07", "patch": "@@ -1,16 +1,469 @@\n-/* Copyright (C) 2000  Free Software Foundation\n+/* TextField.java -- A one line text entry field\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.awt;\n-import java.awt.event.*;\n \n-/* A very incomplete placeholder. */\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.peer.TextFieldPeer;\n+import java.awt.peer.TextComponentPeer;\n+import java.awt.peer.ComponentPeer;\n+\n+/**\n+  * This class implements a single line text entry field widget\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public class TextField extends TextComponent implements java.io.Serializable\n+{\n+\n+/*\n+ * Static Variables\n+ */\n+\n+// Serialization constant\n+private static final long serialVersionUID = -2966288784432217853L;\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Variables\n+ */\n+\n+/**\n+  * @serial The number of columns in the text entry field.\n+  */\n+private int columns;\n+\n+/**\n+  * @serial The character that is echoed when doing protected input\n+  */\n+private char echoChar;\n+\n+// List of registered ActionListener's for this object.\n+private ActionListener action_listeners;\n+\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n+ */\n+\n+/*\n+ * Initializes a new instance of <code>TextField</code> that is empty\n+ * and has one column.\n+ */\n+public\n+TextField()\n+{\n+  this(\"\", 1);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Initializes a new instance of <code>TextField</code> containing\n+  * the specified text.  The number of columns will be equal to the\n+  * length of the text string.\n+  *\n+  * @param text The text to display in the field.\n+  */\n+public\n+TextField(String text)\n+{\n+  this(text, text.length());\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Initializes a new instance of <code>TextField</code> that is empty\n+  * and has the specified number of columns.\n+  *\n+  * @param columns The number of columns in the text field.\n+  */\n+public\n+TextField(int columns)\n+{\n+  this(\"\", columns);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Initializes a new instance of <code>TextField</code> with the\n+  * specified text and number of columns.\n+  *\n+  * @param text The text to display in the field.\n+  * @param columns The number of columns in the field.\n+  */\n+public\n+TextField(String text, int columns)\n+{\n+  super(text);\n+  this.columns = columns;\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Methods\n+ */\n+\n+/**\n+  * Returns the number of columns in the field.\n+  *\n+  * @return The number of columns in the field.\n+  */\n+public int\n+getColumns()\n+{\n+  return(columns);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Sets the number of columns in this field to the specified value.\n+  *\n+  * @param columns The new number of columns in the field.\n+  *\n+  * @exception IllegalArgumentException If columns is less than zero.\n+  */\n+public synchronized void\n+setColumns(int columns)\n+{\n+  if (columns < 0)\n+    throw new IllegalArgumentException(\"Value is less than zero: \" +\n+                                       columns);\n+\n+  this.columns = columns;\n+  // FIXME: How to we communicate this to our peer?\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the character that is echoed to the screen when a text \n+  * field is protected (such as when a password is being entered).\n+  *\n+  * @return The echo character for this text field.\n+  */\n+public char\n+getEchoChar()\n+{\n+  return(echoChar);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Sets the character that is echoed when protected input such as\n+  * a password is displayed.\n+  *\n+  * @param echoChar The new echo character.\n+  */\n+public void\n+setEchoChar(char echoChar)\n+{\n+  this.echoChar = echoChar;\n+\n+  TextFieldPeer tfp = (TextFieldPeer)getPeer();\n+  if (tfp != null)\n+    tfp.setEchoChar(echoChar);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Sets the character that is echoed when protected input such as\n+  * a password is displayed.\n+  *\n+  * @param echoChar The new echo character.\n+  *\n+  * @deprecated This method is deprecated in favor of \n+  * <code>setEchoChar()</code>\n+  */\n+public void\n+setEchoCharacter(char echoChar)\n+{\n+  setEchoChar(echoChar);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Tests whether or not this text field has an echo character set\n+  * so that characters the user type are not echoed to the screen.\n+  *\n+  * @return <code>true</code> if an echo character is set,\n+  * <code>false</code> otherwise.\n+  */\n+public boolean\n+echoCharIsSet()\n+{\n+  if (echoChar == '\\u0000')\n+    return(false);\n+  else\n+    return(true);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the minimum size for this text field.\n+  *\n+  * @return The minimum size for this text field.\n+  */\n+public Dimension\n+getMinimumSize()\n+{\n+  return(getMinimumSize(getColumns()));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the minimum size of a text field with the specified number\n+  * of columns.\n+  *\n+  * @param columns The number of columns to get the minimum size for.\n+  */\n+public Dimension\n+getMinimumSize(int columns)\n+{\n+  TextFieldPeer tfp = (TextFieldPeer)getPeer();\n+  if (tfp == null)\n+    return(null); // FIXME: What do we do if there is no peer?\n+\n+  return(tfp.getMinimumSize(columns));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the minimum size for this text field.\n+  *\n+  * @return The minimum size for this text field.\n+  *\n+  * @deprecated This method is depcreated in favor of\n+  * <code>getMinimumSize()</code>.\n+  */\n+public Dimension\n+minimumSize()\n+{\n+  return(getMinimumSize(getColumns()));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the minimum size of a text field with the specified number\n+  * of columns.\n+  *\n+  * @param columns The number of columns to get the minimum size for.\n+  *\n+  * @deprecated This method is deprecated in favor of \n+  * <code>getMinimumSize(int)</code>.\n+  */\n+public Dimension\n+minimumSize(int columns)\n+{\n+  return(getMinimumSize(columns));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the preferred size for this text field.\n+  *\n+  * @return The preferred size for this text field.\n+  */\n+public Dimension\n+getPreferredSize()\n+{\n+  return(getPreferredSize(getColumns()));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the preferred size of a text field with the specified number\n+  * of columns.\n+  *\n+  * @param columns The number of columns to get the preferred size for.\n+  */\n+public Dimension\n+getPreferredSize(int columns)\n+{\n+  TextFieldPeer tfp = (TextFieldPeer)getPeer();\n+  if (tfp == null)\n+    return(null); // FIXME: What do we do if there is no peer?\n+\n+  return(tfp.getPreferredSize(columns));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the preferred size for this text field.\n+  *\n+  * @return The preferred size for this text field.\n+  *\n+  * @deprecated This method is deprecated in favor of \n+  * <code>getPreferredSize()</code>.\n+  */\n+public Dimension\n+preferredSize()\n+{\n+  return(getPreferredSize(getColumns()));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns the preferred size of a text field with the specified number\n+  * of columns.\n+  *\n+  * @param columns The number of columns to get the preferred size for.\n+  *\n+  * @deprecated This method is deprecated in favor of \n+  * <code>getPreferredSize(int)</code>.\n+  */\n+public Dimension\n+preferredSize(int columns)\n+{\n+  return(getPreferredSize(columns));\n+}\n+\n+/*************************************************************************/\n \n-public class TextField extends TextComponent\n+/**\n+  * Notifies this object that it should create its native peer.\n+  */\n+public void\n+addNotify()\n {\n+  if (getPeer() != null)\n+    return;\n+\n+  setPeer((ComponentPeer)getToolkit().createTextField(this));\n }\n+\n+/*************************************************************************/\n+\n+/**\n+  * Addes a new listener to the list of action listeners for this\n+  * object.\n+  *\n+  * @param listener The listener to add to the list.\n+  */\n+public synchronized void\n+addActionListener(ActionListener listener)\n+{\n+  action_listeners = AWTEventMulticaster.add(action_listeners, listener);\n+\n+  enableEvents(AWTEvent.ACTION_EVENT_MASK);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Removes the specified listener from the list of action listeners\n+  * for this object.\n+  *\n+  * @param listener The listener to remove from the list.\n+  */\n+public synchronized void\n+removeActionListener(ActionListener listener)\n+{\n+  action_listeners = AWTEventMulticaster.remove(action_listeners, listener);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Processes the specified event.  If the event is an instance of\n+  * <code>ActionEvent</code> then <code>processActionEvent()</code> is\n+  * called to process it, otherwise the event is sent to the\n+  * superclass.\n+  *\n+  * @param event The event to process.\n+  */\n+protected void\n+processEvent(AWTEvent event)\n+{\n+  if (event instanceof ActionEvent)\n+    processActionEvent((ActionEvent)event);\n+  else\n+    super.processEvent(event);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Processes an action event by calling any registered listeners.\n+  * Note to subclasses: This method is not called unless action events\n+  * are enabled on this object.  This will be true if any listeners\n+  * are registered, or if action events were specifically enabled\n+  * using <code>enableEvents()</code>.\n+  * \n+  * @param event The event to process.\n+  */\n+protected void\n+processActionEvent(ActionEvent event)\n+{\n+  if (action_listeners != null)\n+    action_listeners.actionPerformed(event);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Returns a debug string for this object.\n+  *\n+  * @return A debug string for this object.\n+  */\n+protected String\n+paramString()\n+{\n+  return(getClass().getName() + \"(columns=\" + getColumns() + \",echoChar=\" +\n+         getEchoChar());\n+}\n+\n+} // class TextField"}]}