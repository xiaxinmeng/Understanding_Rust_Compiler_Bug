{"sha": "f9d6338bd15ce1fae36bf25d3a0545e9678ddc58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjlkNjMzOGJkMTVjZTFmYWUzNmJmMjVkM2EwNTQ1ZTk2NzhkZGM1OA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-16T11:43:31Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-16T11:43:31Z"}, "message": "Use a single comparison for index-based alias checks\n\nThis patch rewrites the index-based alias checks to use conditions\nof the form:\n\n  (unsigned T) (a - b + bias) <= limit\n\nE.g. before the patch:\n\n  struct s { int x[100]; };\n\n  void\n  f1 (struct s *s1, int a, int b)\n  {\n    for (int i = 0; i < 32; ++i)\n      s1->x[i + a] += s1->x[i + b];\n  }\n\nused:\n\n        add     w3, w1, 3\n        cmp     w3, w2\n        add     w3, w2, 3\n        ccmp    w1, w3, 0, ge\n        ble     .L2\n\nwhereas after the patch it uses:\n\n        sub     w3, w1, w2\n        add     w3, w3, 3\n        cmp     w3, 6\n        bls     .L2\n\nThe patch also fixes the seg_len1 and seg_len2 negation for cases in\nwhich seg_len is a \"negative unsigned\" value narrower than 64 bits,\nlike it is for 32-bit targets.  Previously we'd end up with values\nlike 0xffffffff000000001 instead of 1.\n\n2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-data-ref.c (create_intersect_range_checks_index): Rewrite\n\tthe index tests to have the form (unsigned T) (B - A + bias) <= limit.\n\ngcc/testsuite/\n\t* gcc.dg/vect/vect-alias-check-18.c: New test.\n\t* gcc.dg/vect/vect-alias-check-19.c: Likewise.\n\t* gcc.dg/vect/vect-alias-check-20.c: Likewise.\n\nFrom-SVN: r278354", "tree": {"sha": "df3f266e8905b2bb9efece9a71af140fced56abb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df3f266e8905b2bb9efece9a71af140fced56abb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9d6338bd15ce1fae36bf25d3a0545e9678ddc58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9d6338bd15ce1fae36bf25d3a0545e9678ddc58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9d6338bd15ce1fae36bf25d3a0545e9678ddc58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9d6338bd15ce1fae36bf25d3a0545e9678ddc58/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b4d1b635737a4780e5be247f8be9550eaf83dae5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4d1b635737a4780e5be247f8be9550eaf83dae5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4d1b635737a4780e5be247f8be9550eaf83dae5"}], "stats": {"total": 346, "additions": 295, "deletions": 51}, "files": [{"sha": "e99cfe70d1018c9c85d0b2b7c5a640444de21ef3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d6338bd15ce1fae36bf25d3a0545e9678ddc58/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d6338bd15ce1fae36bf25d3a0545e9678ddc58/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9d6338bd15ce1fae36bf25d3a0545e9678ddc58", "patch": "@@ -1,3 +1,8 @@\n+2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-data-ref.c (create_intersect_range_checks_index): Rewrite\n+\tthe index tests to have the form (unsigned T) (B - A + bias) <= limit.\n+\n 2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-data-ref.c (create_intersect_range_checks_index)"}, {"sha": "ef5bd71af8e9b3617cd2e14386644a496179a03b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d6338bd15ce1fae36bf25d3a0545e9678ddc58/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d6338bd15ce1fae36bf25d3a0545e9678ddc58/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f9d6338bd15ce1fae36bf25d3a0545e9678ddc58", "patch": "@@ -1,3 +1,9 @@\n+2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.dg/vect/vect-alias-check-18.c: New test.\n+\t* gcc.dg/vect/vect-alias-check-19.c: Likewise.\n+\t* gcc.dg/vect/vect-alias-check-20.c: Likewise.\n+\n 2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc.dg/vect/vect-alias-check-1.c: Test for the type of alias check."}, {"sha": "e9fd31a14002cb5a1fd52a0cfb047be06bdab58e", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-18.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d6338bd15ce1fae36bf25d3a0545e9678ddc58/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d6338bd15ce1fae36bf25d3a0545e9678ddc58/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-18.c?ref=f9d6338bd15ce1fae36bf25d3a0545e9678ddc58", "patch": "@@ -0,0 +1,64 @@\n+#define N 200\n+#define DIST 32\n+\n+typedef signed char sc;\n+typedef unsigned char uc;\n+typedef signed short ss;\n+typedef unsigned short us;\n+typedef int si;\n+typedef unsigned int ui;\n+typedef signed long long sll;\n+typedef unsigned long long ull;\n+\n+#define FOR_EACH_TYPE(M) \\\n+  M (sc) M (uc) \\\n+  M (ss) M (us) \\\n+  M (si) M (ui) \\\n+  M (sll) M (ull) \\\n+  M (float) M (double)\n+\n+#define TEST_VALUE(I) ((I) * 11 / 2)\n+\n+#define ADD_TEST(TYPE)\t\t\t\t\\\n+  TYPE a_##TYPE[N * 2];\t\t\t\t\\\n+  void __attribute__((noinline, noclone))\t\\\n+  test_##TYPE (int x, int y)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\\\n+      a_##TYPE[x - i] += a_##TYPE[y - i];\t\\\n+  }\n+\n+#define DO_TEST(TYPE)\t\t\t\t\t\t\\\n+  for (int i = 0; i < DIST * 2; ++i)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      for (int j = 0; j < N + DIST * 2; ++j)\t\t\t\\\n+\ta_##TYPE[j] = TEST_VALUE (j);\t\t\t\t\\\n+      test_##TYPE (i + N - 1, DIST + N - 1);\t\t\t\\\n+      for (int j = 0; j < N + DIST * 2; ++j)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  TYPE expected;\t\t\t\t\t\\\n+\t  if (j < i || j >= i + N)\t\t\t\t\\\n+\t    expected = TEST_VALUE (j);\t\t\t\t\\\n+\t  else if (i >= DIST)\t\t\t\t\t\\\n+\t    expected = ((TYPE) TEST_VALUE (j)\t\t\t\\\n+\t\t\t+ (TYPE) TEST_VALUE (j + DIST - i));\t\\\n+\t  else\t\t\t\t\t\t\t\\\n+\t    expected = ((TYPE) TEST_VALUE (j)\t\t\t\\\n+\t\t\t+ a_##TYPE[j + DIST - i]);\t\t\\\n+\t  if (expected != a_##TYPE[j])\t\t\t\t\\\n+\t    __builtin_abort ();\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    }\n+\n+FOR_EACH_TYPE (ADD_TEST)\n+\n+int\n+main (void)\n+{\n+  FOR_EACH_TYPE (DO_TEST)\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {flags: *WAR\\n} \"vect\" { target vect_int } } } */\n+/* { dg-final { scan-tree-dump \"using an index-based overlap test\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not \"using an address-based\" \"vect\" } } */"}, {"sha": "583e296f7f17ccaec747e67371c405c849d6c77b", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-19.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d6338bd15ce1fae36bf25d3a0545e9678ddc58/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d6338bd15ce1fae36bf25d3a0545e9678ddc58/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-19.c?ref=f9d6338bd15ce1fae36bf25d3a0545e9678ddc58", "patch": "@@ -0,0 +1,62 @@\n+#define N 200\n+#define DIST 32\n+\n+typedef signed char sc;\n+typedef unsigned char uc;\n+typedef signed short ss;\n+typedef unsigned short us;\n+typedef int si;\n+typedef unsigned int ui;\n+typedef signed long long sll;\n+typedef unsigned long long ull;\n+\n+#define FOR_EACH_TYPE(M) \\\n+  M (sc) M (uc) \\\n+  M (ss) M (us) \\\n+  M (si) M (ui) \\\n+  M (sll) M (ull) \\\n+  M (float) M (double)\n+\n+#define ADD_TEST(TYPE)\t\t\t\t\\\n+  TYPE a_##TYPE[N * 2];\t\t\t\t\\\n+  void __attribute__((noinline, noclone))\t\\\n+  test_##TYPE (int x, int y)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+\ta_##TYPE[i + x] = i;\t\t\t\\\n+\ta_##TYPE[i + y] = 42 - i * 2;\t\t\\\n+      }\t\t\t\t\t\t\\\n+  }\n+\n+#define DO_TEST(TYPE)\t\t\t\t\t\t\\\n+  for (int i = 0; i < DIST * 2; ++i)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      __builtin_memset (a_##TYPE, 0, sizeof (a_##TYPE));\t\\\n+      test_##TYPE (DIST, i);\t\t\t\t\t\\\n+      for (int j = 0; j < N + DIST * 2; ++j)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  TYPE expected = 0;\t\t\t\t\t\\\n+\t  if (i > DIST && j >= i && j < i + N)\t\t\t\\\n+\t    expected = 42 - (j - i) * 2;\t\t\t\\\n+\t  if (j >= DIST && j < DIST + N)\t\t\t\\\n+\t    expected = j - DIST;\t\t\t\t\\\n+\t  if (i <= DIST && j >= i && j < i + N)\t\t\t\\\n+\t    expected = 42 - (j - i) * 2;\t\t\t\\\n+\t  if (expected != a_##TYPE[j])\t\t\t\t\\\n+\t    __builtin_abort ();\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    }\n+\n+FOR_EACH_TYPE (ADD_TEST)\n+\n+int\n+main (void)\n+{\n+  FOR_EACH_TYPE (DO_TEST)\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {flags: *WAW\\n} \"vect\" { target vect_int } } } */\n+/* { dg-final { scan-tree-dump \"using an index-based overlap test\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not \"using an address-based\" \"vect\" } } */"}, {"sha": "8a699ebfda8bfffdafc5e5f09d137bb0c7e78beb", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-20.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d6338bd15ce1fae36bf25d3a0545e9678ddc58/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d6338bd15ce1fae36bf25d3a0545e9678ddc58/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-20.c?ref=f9d6338bd15ce1fae36bf25d3a0545e9678ddc58", "patch": "@@ -0,0 +1,66 @@\n+#define N 200\n+#define DIST 32\n+\n+typedef signed char sc;\n+typedef unsigned char uc;\n+typedef signed short ss;\n+typedef unsigned short us;\n+typedef int si;\n+typedef unsigned int ui;\n+typedef signed long long sll;\n+typedef unsigned long long ull;\n+\n+#define FOR_EACH_TYPE(M) \\\n+  M (sc) M (uc) \\\n+  M (ss) M (us) \\\n+  M (si) M (ui) \\\n+  M (sll) M (ull) \\\n+  M (float) M (double)\n+\n+#define TEST_VALUE(I) ((I) * 11 / 2)\n+\n+#define ADD_TEST(TYPE)\t\t\t\t\\\n+  TYPE a_##TYPE[N * 2];\t\t\t\t\\\n+  TYPE __attribute__((noinline, noclone))\t\\\n+  test_##TYPE (int x, int y)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    TYPE res = 0;\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+\ta_##TYPE[i + x] = i;\t\t\t\\\n+\tres += a_##TYPE[i + y];\t\t\t\\\n+      }\t\t\t\t\t\t\\\n+    return res;\t\t\t\t\t\\\n+  }\n+\n+#define DO_TEST(TYPE)\t\t\t\t\t\t\\\n+  for (int i = 0; i < DIST * 2; ++i)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      for (int j = 0; j < N + DIST * 2; ++j)\t\t\t\\\n+\ta_##TYPE[j] = TEST_VALUE (j);\t\t\t\t\\\n+      TYPE res = test_##TYPE (DIST, i);\t\t\t\t\\\n+      for (int j = 0; j < N; ++j)\t\t\t\t\\\n+\tif (a_##TYPE[j + DIST] != (TYPE) j)\t\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\t\\\n+      TYPE expected_res = 0;\t\t\t\t\t\\\n+      for (int j = i; j < i + N; ++j)\t\t\t\t\\\n+\tif (i <= DIST && j >= DIST && j < DIST + N)\t\t\\\n+\t  expected_res += j - DIST;\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\\\n+\t  expected_res += TEST_VALUE (j);\t\t\t\\\n+      if (expected_res != res)\t\t\t\t\t\\\n+\t__builtin_abort ();\t\t\t\t\t\\\n+    }\n+\n+FOR_EACH_TYPE (ADD_TEST)\n+\n+int\n+main (void)\n+{\n+  FOR_EACH_TYPE (DO_TEST)\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {flags: *RAW\\n} \"vect\" { target vect_int } } } */\n+/* { dg-final { scan-tree-dump \"using an index-based overlap test\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not \"using an address-based\" \"vect\" } } */"}, {"sha": "4dfa33404e3da0b15f395678987fa326d08e6ea9", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 92, "deletions": 51, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d6338bd15ce1fae36bf25d3a0545e9678ddc58/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d6338bd15ce1fae36bf25d3a0545e9678ddc58/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=f9d6338bd15ce1fae36bf25d3a0545e9678ddc58", "patch": "@@ -1743,7 +1743,9 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n \n    We can create expression based on index rather than address:\n \n-     (i_0 + 4 < j_0 || j_0 + 4 < i_0)\n+     (unsigned) (i_0 - j_0 + 3) <= 6\n+\n+   i.e. the indices are less than 4 apart.\n \n    Note evolution step of index needs to be considered in comparison.  */\n \n@@ -1780,15 +1782,8 @@ create_intersect_range_checks_index (class loop *loop, tree *cond_expr,\n   if (neg_step)\n     {\n       abs_step = -abs_step;\n-      seg_len1 = -seg_len1;\n-      seg_len2 = -seg_len2;\n-    }\n-  else\n-    {\n-      /* Include the access size in the length, so that we only have one\n-\t tree addition below.  */\n-      seg_len1 += dr_a.access_size;\n-      seg_len2 += dr_b.access_size;\n+      seg_len1 = (-wi::to_poly_wide (dr_a.seg_len)).force_uhwi ();\n+      seg_len2 = (-wi::to_poly_wide (dr_b.seg_len)).force_uhwi ();\n     }\n \n   /* Infer the number of iterations with which the memory segment is accessed\n@@ -1802,16 +1797,13 @@ create_intersect_range_checks_index (class loop *loop, tree *cond_expr,\n       || !can_div_trunc_p (seg_len2 + abs_step - 1, abs_step, &niter_len2))\n     return false;\n \n-  poly_uint64 niter_access1 = 0, niter_access2 = 0;\n-  if (neg_step)\n-    {\n-      /* Divide each access size by the byte step, rounding up.  */\n-      if (!can_div_trunc_p (dr_a.access_size - abs_step - 1,\n-\t\t\t    abs_step, &niter_access1)\n-\t  || !can_div_trunc_p (dr_b.access_size + abs_step - 1,\n-\t\t\t       abs_step, &niter_access2))\n-\treturn false;\n-    }\n+  /* Divide each access size by the byte step, rounding up.  */\n+  poly_uint64 niter_access1, niter_access2;\n+  if (!can_div_trunc_p (dr_a.access_size + abs_step - 1,\n+\t\t\tabs_step, &niter_access1)\n+      || !can_div_trunc_p (dr_b.access_size + abs_step - 1,\n+\t\t\t   abs_step, &niter_access2))\n+    return false;\n \n   unsigned int i;\n   for (i = 0; i < DR_NUM_DIMENSIONS (dr_a.dr); i++)\n@@ -1851,38 +1843,87 @@ create_intersect_range_checks_index (class loop *loop, tree *cond_expr,\n \t index of data reference.  Like segment length, index length is\n \t linear function of the number of iterations with index_step as\n \t the coefficient, i.e, niter_len * idx_step.  */\n-      tree idx_len1 = fold_build2 (MULT_EXPR, TREE_TYPE (min1), idx_step,\n-\t\t\t\t   build_int_cst (TREE_TYPE (min1),\n-\t\t\t\t\t\t  niter_len1));\n-      tree idx_len2 = fold_build2 (MULT_EXPR, TREE_TYPE (min2), idx_step,\n-\t\t\t\t   build_int_cst (TREE_TYPE (min2),\n-\t\t\t\t\t\t  niter_len2));\n-      tree max1 = fold_build2 (PLUS_EXPR, TREE_TYPE (min1), min1, idx_len1);\n-      tree max2 = fold_build2 (PLUS_EXPR, TREE_TYPE (min2), min2, idx_len2);\n-      /* Adjust ranges for negative step.  */\n+      offset_int abs_idx_step = offset_int::from (wi::to_wide (idx_step),\n+\t\t\t\t\t\t  SIGNED);\n       if (neg_step)\n-\t{\n-\t  /* IDX_LEN1 and IDX_LEN2 are negative in this case.  */\n-\t  std::swap (min1, max1);\n-\t  std::swap (min2, max2);\n-\n-\t  /* As with the lengths just calculated, we've measured the access\n-\t     sizes in iterations, so multiply them by the index step.  */\n-\t  tree idx_access1\n-\t    = fold_build2 (MULT_EXPR, TREE_TYPE (min1), idx_step,\n-\t\t\t   build_int_cst (TREE_TYPE (min1), niter_access1));\n-\t  tree idx_access2\n-\t    = fold_build2 (MULT_EXPR, TREE_TYPE (min2), idx_step,\n-\t\t\t   build_int_cst (TREE_TYPE (min2), niter_access2));\n-\n-\t  /* MINUS_EXPR because the above values are negative.  */\n-\t  max1 = fold_build2 (MINUS_EXPR, TREE_TYPE (max1), max1, idx_access1);\n-\t  max2 = fold_build2 (MINUS_EXPR, TREE_TYPE (max2), max2, idx_access2);\n-\t}\n-      tree part_cond_expr\n-\t= fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t    fold_build2 (LE_EXPR, boolean_type_node, max1, min2),\n-\t    fold_build2 (LE_EXPR, boolean_type_node, max2, min1));\n+\tabs_idx_step = -abs_idx_step;\n+      poly_offset_int idx_len1 = abs_idx_step * niter_len1;\n+      poly_offset_int idx_len2 = abs_idx_step * niter_len2;\n+      poly_offset_int idx_access1 = abs_idx_step * niter_access1;\n+      poly_offset_int idx_access2 = abs_idx_step * niter_access2;\n+\n+      gcc_assert (known_ge (idx_len1, 0)\n+\t\t  && known_ge (idx_len2, 0)\n+\t\t  && known_ge (idx_access1, 0)\n+\t\t  && known_ge (idx_access2, 0));\n+\n+      /* Each access has the following pattern, with lengths measured\n+\t in units of INDEX:\n+\n+\t      <-- idx_len -->\n+\t      <--- A: -ve step --->\n+\t      +-----+-------+-----+-------+-----+\n+\t      | n-1 | ..... |  0  | ..... | n-1 |\n+\t      +-----+-------+-----+-------+-----+\n+\t\t\t    <--- B: +ve step --->\n+\t\t\t    <-- idx_len -->\n+\t\t\t    |\n+\t\t\t   min\n+\n+\t where \"n\" is the number of scalar iterations covered by the segment\n+\t and where each access spans idx_access units.\n+\n+\t A is the range of bytes accessed when the step is negative,\n+\t B is the range when the step is positive.\n+\n+\t When checking for general overlap, we need to test whether\n+\t the range:\n+\n+\t   [min1 + low_offset1, min2 + high_offset1 + idx_access1 - 1]\n+\n+\t overlaps:\n+\n+\t   [min2 + low_offset2, min2 + high_offset2 + idx_access2 - 1]\n+\n+\t where:\n+\n+\t    low_offsetN = +ve step ? 0 : -idx_lenN;\n+\t   high_offsetN = +ve step ? idx_lenN : 0;\n+\n+\t This is equivalent to testing whether:\n+\n+\t   min1 + low_offset1 <= min2 + high_offset2 + idx_access2 - 1\n+\t   && min2 + low_offset2 <= min1 + high_offset1 + idx_access1 - 1\n+\n+\t Converting this into a single test, there is an overlap if:\n+\n+\t   0 <= min2 - min1 + bias <= limit\n+\n+\t where  bias = high_offset2 + idx_access2 - 1 - low_offset1\n+\t       limit = (high_offset1 - low_offset1 + idx_access1 - 1)\n+\t\t     + (high_offset2 - low_offset2 + idx_access2 - 1)\n+\t  i.e. limit = idx_len1 + idx_access1 - 1 + idx_len2 + idx_access2 - 1\n+\n+\t Combining the tests requires limit to be computable in an unsigned\n+\t form of the index type; if it isn't, we fall back to the usual\n+\t pointer-based checks.  */\n+      poly_offset_int limit = (idx_len1 + idx_access1 - 1\n+\t\t\t       + idx_len2 + idx_access2 - 1);\n+      tree utype = unsigned_type_for (TREE_TYPE (min1));\n+      if (!wi::fits_to_tree_p (limit, utype))\n+\treturn false;\n+\n+      poly_offset_int low_offset1 = neg_step ? -idx_len1 : 0;\n+      poly_offset_int high_offset2 = neg_step ? 0 : idx_len2;\n+      poly_offset_int bias = high_offset2 + idx_access2 - 1 - low_offset1;\n+\n+      tree subject = fold_build2 (MINUS_EXPR, utype,\n+\t\t\t\t  fold_convert (utype, min2),\n+\t\t\t\t  fold_convert (utype, min1));\n+      subject = fold_build2 (PLUS_EXPR, utype, subject,\n+\t\t\t     wide_int_to_tree (utype, bias));\n+      tree part_cond_expr = fold_build2 (GT_EXPR, boolean_type_node, subject,\n+\t\t\t\t\t wide_int_to_tree (utype, limit));\n       if (*cond_expr)\n \t*cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t  *cond_expr, part_cond_expr);"}]}