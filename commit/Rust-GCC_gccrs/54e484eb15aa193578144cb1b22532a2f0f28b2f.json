{"sha": "54e484eb15aa193578144cb1b22532a2f0f28b2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTRlNDg0ZWIxNWFhMTkzNTc4MTQ0Y2IxYjIyNTMyYTJmMGYyOGIyZg==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2015-11-17T18:06:01Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2015-11-17T18:06:01Z"}, "message": "re PR other/56036 (Wrong indentation in multiple -O options explaination)\n\n2015-11-17  Sandra Loosemore  <sandra@codesourcery.com>\n\n\tPR target/56036\n\t* doc/invoke.texi (Option Summary): Add -mms-bitfields to x86\n\toption list.\n\t(x86 Options): Add -mms-bitfields and -mno-ms-bitfields.  Move\n\tdiscussion of the Microsoft structure layout details here from\n\tits former home in extend.texi.\n\t* doc/extend.texi (x86 Variable Attributes): Replace detailed\n\tdiscussion with pointer to its new location.  Add cross-reference\n\tto corresponding type attributes.\n\t(x86 Type Attributes): Add cross-references to command-line options\n\tand variable attributes.\n\nFrom-SVN: r230467", "tree": {"sha": "40789979ece1c015b1f2ef951f5918531b2bf2d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40789979ece1c015b1f2ef951f5918531b2bf2d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54e484eb15aa193578144cb1b22532a2f0f28b2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54e484eb15aa193578144cb1b22532a2f0f28b2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54e484eb15aa193578144cb1b22532a2f0f28b2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54e484eb15aa193578144cb1b22532a2f0f28b2f/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3d7bfee0b0728c744571986baf4b6ee58ed7c72f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d7bfee0b0728c744571986baf4b6ee58ed7c72f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d7bfee0b0728c744571986baf4b6ee58ed7c72f"}], "stats": {"total": 283, "additions": 164, "deletions": 119}, "files": [{"sha": "b9bb07c07cea2b58e417282c33f173de9b7784ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e484eb15aa193578144cb1b22532a2f0f28b2f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e484eb15aa193578144cb1b22532a2f0f28b2f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=54e484eb15aa193578144cb1b22532a2f0f28b2f", "patch": "@@ -1,3 +1,17 @@\n+2015-11-17  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR target/56036\n+\t* doc/invoke.texi (Option Summary): Add -mms-bitfields to x86\n+\toption list.\n+\t(x86 Options): Add -mms-bitfields and -mno-ms-bitfields.  Move\n+\tdiscussion of the Microsoft structure layout details here from\n+\tits former home in extend.texi.\n+\t* doc/extend.texi (x86 Variable Attributes): Replace detailed\n+\tdiscussion with pointer to its new location.  Add cross-reference\n+\tto corresponding type attributes.\n+\t(x86 Type Attributes): Add cross-references to command-line options\n+\tand variable attributes.\n+\n 2015-11-17  Ilya Enkovich  <enkovich.gnu@gmail.com>\n \n \tPR middle-end/68134"}, {"sha": "a81f8df0a240a80b48d6a2fd39cd879636dd6631", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 13, "deletions": 118, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e484eb15aa193578144cb1b22532a2f0f28b2f/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e484eb15aa193578144cb1b22532a2f0f28b2f/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=54e484eb15aa193578144cb1b22532a2f0f28b2f", "patch": "@@ -6047,123 +6047,13 @@ data between functions compiled with GCC and the native Microsoft compiler\n (either via function call or as data in a file), it may be necessary to access\n either format.\n \n-Currently @option{-m[no-]ms-bitfields} is provided for the Microsoft Windows x86\n-compilers to match the native Microsoft compiler.\n+The @code{ms_struct} and @code{gcc_struct} attributes correspond\n+to the @option{-mms-bitfields} and @option{-mno-ms-bitfields}\n+command-line options, respectively;\n+see @ref{x86 Options}, for details of how structure layout is affected.\n+@xref{x86 Type Attributes}, for information about the corresponding\n+attributes on types.\n \n-The Microsoft structure layout algorithm is fairly simple with the exception\n-of the bit-field packing.  \n-The padding and alignment of members of structures and whether a bit-field \n-can straddle a storage-unit boundary are determine by these rules:\n-\n-@enumerate\n-@item Structure members are stored sequentially in the order in which they are\n-declared: the first member has the lowest memory address and the last member\n-the highest.\n-\n-@item Every data object has an alignment requirement.  The alignment requirement\n-for all data except structures, unions, and arrays is either the size of the\n-object or the current packing size (specified with either the\n-@code{aligned} attribute or the @code{pack} pragma),\n-whichever is less.  For structures, unions, and arrays,\n-the alignment requirement is the largest alignment requirement of its members.\n-Every object is allocated an offset so that:\n-\n-@smallexample\n-offset % alignment_requirement == 0\n-@end smallexample\n-\n-@item Adjacent bit-fields are packed into the same 1-, 2-, or 4-byte allocation\n-unit if the integral types are the same size and if the next bit-field fits\n-into the current allocation unit without crossing the boundary imposed by the\n-common alignment requirements of the bit-fields.\n-@end enumerate\n-\n-MSVC interprets zero-length bit-fields in the following ways:\n-\n-@enumerate\n-@item If a zero-length bit-field is inserted between two bit-fields that\n-are normally coalesced, the bit-fields are not coalesced.\n-\n-For example:\n-\n-@smallexample\n-struct\n- @{\n-   unsigned long bf_1 : 12;\n-   unsigned long : 0;\n-   unsigned long bf_2 : 12;\n- @} t1;\n-@end smallexample\n-\n-@noindent\n-The size of @code{t1} is 8 bytes with the zero-length bit-field.  If the\n-zero-length bit-field were removed, @code{t1}'s size would be 4 bytes.\n-\n-@item If a zero-length bit-field is inserted after a bit-field, @code{foo}, and the\n-alignment of the zero-length bit-field is greater than the member that follows it,\n-@code{bar}, @code{bar} is aligned as the type of the zero-length bit-field.\n-\n-For example:\n-\n-@smallexample\n-struct\n- @{\n-   char foo : 4;\n-   short : 0;\n-   char bar;\n- @} t2;\n-\n-struct\n- @{\n-   char foo : 4;\n-   short : 0;\n-   double bar;\n- @} t3;\n-@end smallexample\n-\n-@noindent\n-For @code{t2}, @code{bar} is placed at offset 2, rather than offset 1.\n-Accordingly, the size of @code{t2} is 4.  For @code{t3}, the zero-length\n-bit-field does not affect the alignment of @code{bar} or, as a result, the size\n-of the structure.\n-\n-Taking this into account, it is important to note the following:\n-\n-@enumerate\n-@item If a zero-length bit-field follows a normal bit-field, the type of the\n-zero-length bit-field may affect the alignment of the structure as whole. For\n-example, @code{t2} has a size of 4 bytes, since the zero-length bit-field follows a\n-normal bit-field, and is of type short.\n-\n-@item Even if a zero-length bit-field is not followed by a normal bit-field, it may\n-still affect the alignment of the structure:\n-\n-@smallexample\n-struct\n- @{\n-   char foo : 6;\n-   long : 0;\n- @} t4;\n-@end smallexample\n-\n-@noindent\n-Here, @code{t4} takes up 4 bytes.\n-@end enumerate\n-\n-@item Zero-length bit-fields following non-bit-field members are ignored:\n-\n-@smallexample\n-struct\n- @{\n-   char foo;\n-   long : 0;\n-   char bar;\n- @} t5;\n-@end smallexample\n-\n-@noindent\n-Here, @code{t5} takes up 2 bytes.\n-@end enumerate\n @end table\n \n @node Xstormy16 Variable Attributes\n@@ -6683,8 +6573,13 @@ data between functions compiled with GCC and the native Microsoft compiler\n (either via function call or as data in a file), it may be necessary to access\n either format.\n \n-Currently @option{-m[no-]ms-bitfields} is provided for the Microsoft Windows x86\n-compilers to match the native Microsoft compiler.\n+The @code{ms_struct} and @code{gcc_struct} attributes correspond\n+to the @option{-mms-bitfields} and @option{-mno-ms-bitfields}\n+command-line options, respectively;\n+see @ref{x86 Options}, for details of how structure layout is affected.\n+@xref{x86 Variable Attributes}, for information about the corresponding\n+attributes on variables.\n+\n @end table\n \n @node Label Attributes"}, {"sha": "8be39b7fa64fb27f21ca2047bff5fccdbb25cf48", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 137, "deletions": 1, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e484eb15aa193578144cb1b22532a2f0f28b2f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e484eb15aa193578144cb1b22532a2f0f28b2f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=54e484eb15aa193578144cb1b22532a2f0f28b2f", "patch": "@@ -1103,7 +1103,7 @@ See RS/6000 and PowerPC Options.\n -mprefetchwt1 -mclflushopt -mxsavec -mxsaves @gol\n -msse4a -m3dnow -mpopcnt -mabm -mbmi -mtbm -mfma4 -mxop -mlzcnt @gol\n -mbmi2 -mfxsr -mxsave -mxsaveopt -mrtm -mlwp -mmpx -mmwaitx -mthreads @gol\n--mno-align-stringops  -minline-all-stringops @gol\n+-mms-bitfields -mno-align-stringops  -minline-all-stringops @gol\n -minline-stringops-dynamically -mstringop-strategy=@var{alg} @gol\n -mmemcpy-strategy=@var{strategy} -mmemset-strategy=@var{strategy} @gol\n -mpush-args  -maccumulate-outgoing-args  -m128bit-long-double @gol\n@@ -23431,6 +23431,142 @@ on thread-safe exception handling must compile and link all code with the\n @option{-D_MT}; when linking, it links in a special thread helper library\n @option{-lmingwthrd} which cleans up per-thread exception-handling data.\n \n+@item -mms-bitfields\n+@itemx -mno-ms-bitfields\n+@opindex mms-bitfields\n+@opindex mno-ms-bitfields\n+\n+Enable/disable bit-field layout compatible with the native Microsoft\n+Windows compiler.  \n+\n+If @code{packed} is used on a structure, or if bit-fields are used,\n+it may be that the Microsoft ABI lays out the structure differently\n+than the way GCC normally does.  Particularly when moving packed\n+data between functions compiled with GCC and the native Microsoft compiler\n+(either via function call or as data in a file), it may be necessary to access\n+either format.\n+\n+This option is enabled by default for Microsoft Windows\n+targets.  This behavior can also be controlled locally by use of variable\n+or type attributes.  For more information, see @ref{x86 Variable Attributes}\n+and @ref{x86 Type Attributes}.\n+\n+The Microsoft structure layout algorithm is fairly simple with the exception\n+of the bit-field packing.  \n+The padding and alignment of members of structures and whether a bit-field \n+can straddle a storage-unit boundary are determine by these rules:\n+\n+@enumerate\n+@item Structure members are stored sequentially in the order in which they are\n+declared: the first member has the lowest memory address and the last member\n+the highest.\n+\n+@item Every data object has an alignment requirement.  The alignment requirement\n+for all data except structures, unions, and arrays is either the size of the\n+object or the current packing size (specified with either the\n+@code{aligned} attribute or the @code{pack} pragma),\n+whichever is less.  For structures, unions, and arrays,\n+the alignment requirement is the largest alignment requirement of its members.\n+Every object is allocated an offset so that:\n+\n+@smallexample\n+offset % alignment_requirement == 0\n+@end smallexample\n+\n+@item Adjacent bit-fields are packed into the same 1-, 2-, or 4-byte allocation\n+unit if the integral types are the same size and if the next bit-field fits\n+into the current allocation unit without crossing the boundary imposed by the\n+common alignment requirements of the bit-fields.\n+@end enumerate\n+\n+MSVC interprets zero-length bit-fields in the following ways:\n+\n+@enumerate\n+@item If a zero-length bit-field is inserted between two bit-fields that\n+are normally coalesced, the bit-fields are not coalesced.\n+\n+For example:\n+\n+@smallexample\n+struct\n+ @{\n+   unsigned long bf_1 : 12;\n+   unsigned long : 0;\n+   unsigned long bf_2 : 12;\n+ @} t1;\n+@end smallexample\n+\n+@noindent\n+The size of @code{t1} is 8 bytes with the zero-length bit-field.  If the\n+zero-length bit-field were removed, @code{t1}'s size would be 4 bytes.\n+\n+@item If a zero-length bit-field is inserted after a bit-field, @code{foo}, and the\n+alignment of the zero-length bit-field is greater than the member that follows it,\n+@code{bar}, @code{bar} is aligned as the type of the zero-length bit-field.\n+\n+For example:\n+\n+@smallexample\n+struct\n+ @{\n+   char foo : 4;\n+   short : 0;\n+   char bar;\n+ @} t2;\n+\n+struct\n+ @{\n+   char foo : 4;\n+   short : 0;\n+   double bar;\n+ @} t3;\n+@end smallexample\n+\n+@noindent\n+For @code{t2}, @code{bar} is placed at offset 2, rather than offset 1.\n+Accordingly, the size of @code{t2} is 4.  For @code{t3}, the zero-length\n+bit-field does not affect the alignment of @code{bar} or, as a result, the size\n+of the structure.\n+\n+Taking this into account, it is important to note the following:\n+\n+@enumerate\n+@item If a zero-length bit-field follows a normal bit-field, the type of the\n+zero-length bit-field may affect the alignment of the structure as whole. For\n+example, @code{t2} has a size of 4 bytes, since the zero-length bit-field follows a\n+normal bit-field, and is of type short.\n+\n+@item Even if a zero-length bit-field is not followed by a normal bit-field, it may\n+still affect the alignment of the structure:\n+\n+@smallexample\n+struct\n+ @{\n+   char foo : 6;\n+   long : 0;\n+ @} t4;\n+@end smallexample\n+\n+@noindent\n+Here, @code{t4} takes up 4 bytes.\n+@end enumerate\n+\n+@item Zero-length bit-fields following non-bit-field members are ignored:\n+\n+@smallexample\n+struct\n+ @{\n+   char foo;\n+   long : 0;\n+   char bar;\n+ @} t5;\n+@end smallexample\n+\n+@noindent\n+Here, @code{t5} takes up 2 bytes.\n+@end enumerate\n+\n+\n @item -mno-align-stringops\n @opindex mno-align-stringops\n Do not align the destination of inlined string operations.  This switch reduces"}]}