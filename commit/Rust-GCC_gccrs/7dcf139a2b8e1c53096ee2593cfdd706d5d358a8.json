{"sha": "7dcf139a2b8e1c53096ee2593cfdd706d5d358a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RjZjEzOWEyYjhlMWM1MzA5NmVlMjU5M2NmZGQ3MDZkNWQzNThhOA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-23T13:17:07Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-24T07:07:06Z"}, "message": "refactor SLP permute propagation\n\nThis refactors SLP permute propagation to record the outgoing permute\nseparately from the incoming/materialized one.  Instead of separate\narrays/bitmaps I've now created a struct to represent the state.\n\n2021-06-23  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-slp.c (slpg_vertex): New struct.\n\t(vect_slp_build_vertices): Adjust.\n\t(vect_optimize_slp): Likewise.  Maintain an outgoing permute\n\tand a materialized one.", "tree": {"sha": "9a8f7c1207e112215c420dbf46b4b36a378d8466", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a8f7c1207e112215c420dbf46b4b36a378d8466"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7dcf139a2b8e1c53096ee2593cfdd706d5d358a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dcf139a2b8e1c53096ee2593cfdd706d5d358a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dcf139a2b8e1c53096ee2593cfdd706d5d358a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dcf139a2b8e1c53096ee2593cfdd706d5d358a8/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50374fdacbd121bc4a61b073e559208ff61bee06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50374fdacbd121bc4a61b073e559208ff61bee06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50374fdacbd121bc4a61b073e559208ff61bee06"}], "stats": {"total": 91, "additions": 49, "deletions": 42}, "files": [{"sha": "29db56ed532b9ef5c79b6b420f521e104ad01d4c", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 49, "deletions": 42, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcf139a2b8e1c53096ee2593cfdd706d5d358a8/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcf139a2b8e1c53096ee2593cfdd706d5d358a8/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=7dcf139a2b8e1c53096ee2593cfdd706d5d358a8", "patch": "@@ -3467,11 +3467,27 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n   return opt_result::success ();\n }\n \n+struct slpg_vertex\n+{\n+  slpg_vertex (slp_tree node_)\n+    : node (node_), visited (0), perm_out (0), materialize (0) {}\n+\n+  int get_perm_in () const { return materialize ? materialize : perm_out; }\n+\n+  slp_tree node;\n+  unsigned visited : 1;\n+  /* The permutation on the outgoing lanes (towards SLP parents).  */\n+  int perm_out;\n+  /* The permutation that is applied by this node.  perm_out is\n+     relative to this.  */\n+  int materialize;\n+};\n+\n /* Fill the vertices and leafs vector with all nodes in the SLP graph.  */\n \n static void\n vect_slp_build_vertices (hash_set<slp_tree> &visited, slp_tree node,\n-\t\t\t vec<slp_tree> &vertices, vec<int> &leafs)\n+\t\t\t vec<slpg_vertex> &vertices, vec<int> &leafs)\n {\n   unsigned i;\n   slp_tree child;\n@@ -3480,7 +3496,7 @@ vect_slp_build_vertices (hash_set<slp_tree> &visited, slp_tree node,\n     return;\n \n   node->vertex = vertices.length ();\n-  vertices.safe_push (node);\n+  vertices.safe_push (slpg_vertex (node));\n \n   bool leaf = true;\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n@@ -3496,7 +3512,7 @@ vect_slp_build_vertices (hash_set<slp_tree> &visited, slp_tree node,\n /* Fill the vertices and leafs vector with all nodes in the SLP graph.  */\n \n static void\n-vect_slp_build_vertices (vec_info *info, vec<slp_tree> &vertices,\n+vect_slp_build_vertices (vec_info *info, vec<slpg_vertex> &vertices,\n \t\t\t vec<int> &leafs)\n {\n   hash_set<slp_tree> visited;\n@@ -3568,39 +3584,28 @@ vect_optimize_slp (vec_info *vinfo)\n \n   slp_tree node;\n   unsigned i;\n-  auto_vec<slp_tree> vertices;\n+  auto_vec<slpg_vertex> vertices;\n   auto_vec<int> leafs;\n   vect_slp_build_vertices (vinfo, vertices, leafs);\n \n   struct graph *slpg = new_graph (vertices.length ());\n-  FOR_EACH_VEC_ELT (vertices, i, node)\n-    {\n-      unsigned j;\n-      slp_tree child;\n-      FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n-\tif (child)\n-\t  add_edge (slpg, i, child->vertex);\n-    }\n+  for (slpg_vertex &v : vertices)\n+    for (slp_tree child : SLP_TREE_CHILDREN (v.node))\n+      if (child)\n+\tadd_edge (slpg, v.node->vertex, child->vertex);\n \n   /* Compute (reverse) postorder on the inverted graph.  */\n   auto_vec<int> ipo;\n   graphds_dfs (slpg, &leafs[0], leafs.length (), &ipo, false, NULL, NULL);\n \n-  auto_sbitmap n_visited (vertices.length ());\n-  auto_sbitmap n_materialize (vertices.length ());\n-  auto_vec<int> n_perm (vertices.length ());\n   auto_vec<vec<unsigned> > perms;\n-\n-  bitmap_clear (n_visited);\n-  bitmap_clear (n_materialize);\n-  n_perm.quick_grow_cleared (vertices.length ());\n   perms.safe_push (vNULL); /* zero is no permute */\n \n   /* Produce initial permutations.  */\n   for (i = 0; i < leafs.length (); ++i)\n     {\n       int idx = leafs[i];\n-      slp_tree node = vertices[idx];\n+      slp_tree node = vertices[idx].node;\n \n       /* Handle externals and constants optimistically throughout the\n \t iteration.  */\n@@ -3611,7 +3616,7 @@ vect_optimize_slp (vec_info *vinfo)\n       /* Leafs do not change across iterations.  Note leafs also double\n \t as entries to the reverse graph.  */\n       if (!slpg->vertices[idx].succ)\n-\tbitmap_set_bit (n_visited, idx);\n+\tvertices[idx].visited = 1;\n       /* Loads are the only thing generating permutes.  */\n       if (!SLP_TREE_LOAD_PERMUTATION (node).exists ())\n \tcontinue;\n@@ -3660,7 +3665,7 @@ vect_optimize_slp (vec_info *vinfo)\n       for (unsigned j = 0; j < SLP_TREE_LANES (node); ++j)\n \tperm[j] = SLP_TREE_LOAD_PERMUTATION (node)[j] - imin;\n       perms.safe_push (perm);\n-      n_perm[idx] = perms.length () - 1;\n+      vertices[idx].perm_out = perms.length () - 1;\n     }\n \n   /* Propagate permutes along the graph and compute materialization points.  */\n@@ -3674,13 +3679,13 @@ vect_optimize_slp (vec_info *vinfo)\n       for (i = vertices.length (); i > 0 ; --i)\n \t{\n \t  int idx = ipo[i-1];\n-\t  slp_tree node = vertices[idx];\n+\t  slp_tree node = vertices[idx].node;\n \t  /* For leafs there's nothing to do - we've seeded permutes\n \t     on those above.  */\n \t  if (SLP_TREE_DEF_TYPE (node) != vect_internal_def)\n \t    continue;\n \n-\t  bitmap_set_bit (n_visited, idx);\n+\t  vertices[idx].visited = 1;\n \n \t  /* We cannot move a permute across a store.  */\n \t  if (STMT_VINFO_DATA_REF (SLP_TREE_REPRESENTATIVE (node))\n@@ -3698,13 +3703,9 @@ vect_optimize_slp (vec_info *vinfo)\n \t\t permutes we have to verify the permute, when unifying lanes,\n \t\t will not unify different constants.  For example see\n \t\t gcc.dg/vect/bb-slp-14.c for a case that would break.  */\n-\t      if (!bitmap_bit_p (n_visited, succ_idx))\n+\t      if (!vertices[succ_idx].visited)\n \t\tcontinue;\n-\t      int succ_perm = n_perm[succ_idx];\n-\t      /* Once we materialize succs permutation its output lanes\n-\t\t appear unpermuted to us.  */\n-\t      if (bitmap_bit_p (n_materialize, succ_idx))\n-\t\tsucc_perm = 0;\n+\t      int succ_perm = vertices[succ_idx].perm_out;\n \t      if (perm == -1)\n \t\tperm = succ_perm;\n \t      else if (succ_perm == 0)\n@@ -3721,15 +3722,20 @@ vect_optimize_slp (vec_info *vinfo)\n \n \t  if (perm == -1)\n \t    /* Pick up pre-computed leaf values.  */\n-\t    perm = n_perm[idx];\n-\t  else if (!vect_slp_perms_eq (perms, perm, n_perm[idx]))\n+\t    perm = vertices[idx].perm_out;\n+\t  else if (!vect_slp_perms_eq (perms, perm,\n+\t\t\t\t       vertices[idx].get_perm_in ()))\n \t    {\n \t      if (iteration > 1)\n \t\t/* Make sure we eventually converge.  */\n \t\tgcc_checking_assert (perm == 0);\n-\t      n_perm[idx] = perm;\n \t      if (perm == 0)\n-\t\tbitmap_clear_bit (n_materialize, idx);\n+\t\t{\n+\t\t  vertices[idx].perm_out = 0;\n+\t\t  vertices[idx].materialize = 0;\n+\t\t}\n+\t      if (!vertices[idx].materialize)\n+\t\tvertices[idx].perm_out = perm;\n \t      changed = true;\n \t    }\n \n@@ -3756,8 +3762,8 @@ vect_optimize_slp (vec_info *vinfo)\n \t    for (graph_edge *pred = slpg->vertices[idx].pred;\n \t\t pred; pred = pred->pred_next)\n \t      {\n-\t\tgcc_checking_assert (bitmap_bit_p (n_visited, pred->src));\n-\t\tint pred_perm = n_perm[pred->src];\n+\t\tgcc_checking_assert (vertices[pred->src].visited);\n+\t\tint pred_perm = vertices[pred->src].get_perm_in ();\n \t\tif (!vect_slp_perms_eq (perms, perm, pred_perm))\n \t\t  {\n \t\t    all_preds_permuted = false;\n@@ -3766,9 +3772,10 @@ vect_optimize_slp (vec_info *vinfo)\n \t      }\n \t  if (!all_preds_permuted)\n \t    {\n-\t      if (!bitmap_bit_p (n_materialize, idx))\n+\t      if (!vertices[idx].materialize)\n \t\tchanged = true;\n-\t      bitmap_set_bit (n_materialize, idx);\n+\t      vertices[idx].materialize = perm;\n+\t      vertices[idx].perm_out = 0;\n \t    }\n \t}\n     }\n@@ -3777,11 +3784,11 @@ vect_optimize_slp (vec_info *vinfo)\n   /* Materialize.  */\n   for (i = 0; i < vertices.length (); ++i)\n     {\n-      int perm = n_perm[i];\n+      int perm = vertices[i].get_perm_in ();\n       if (perm <= 0)\n \tcontinue;\n \n-      slp_tree node = vertices[i];\n+      slp_tree node = vertices[i].node;\n \n       /* First permute invariant/external original successors.  */\n       unsigned j;\n@@ -3808,7 +3815,7 @@ vect_optimize_slp (vec_info *vinfo)\n \t\t\t    SLP_TREE_SCALAR_OPS (child), true);\n \t}\n \n-      if (bitmap_bit_p (n_materialize, i))\n+      if (vertices[i].materialize)\n \t{\n \t  if (SLP_TREE_LOAD_PERMUTATION (node).exists ())\n \t    /* For loads simply drop the permutation, the load permutation\n@@ -3897,7 +3904,7 @@ vect_optimize_slp (vec_info *vinfo)\n   /* Now elide load permutations that are not necessary.  */\n   for (i = 0; i < leafs.length (); ++i)\n     {\n-      node = vertices[leafs[i]];\n+      node = vertices[leafs[i]].node;\n       if (!SLP_TREE_LOAD_PERMUTATION (node).exists ())\n \tcontinue;\n "}]}