{"sha": "51bbfa0c65bda8c617aea710627532754481f666", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFiYmZhMGM2NWJkYThjNjE3YWVhNzEwNjI3NTMyNzU0NDgxZjY2Ng==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-17T22:48:42Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-17T22:48:42Z"}, "message": "Initial revision\n\nFrom-SVN: r201", "tree": {"sha": "0776d327e1ee7b8ad779ebcdce9c21de1c14318a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0776d327e1ee7b8ad779ebcdce9c21de1c14318a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51bbfa0c65bda8c617aea710627532754481f666", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51bbfa0c65bda8c617aea710627532754481f666", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51bbfa0c65bda8c617aea710627532754481f666", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51bbfa0c65bda8c617aea710627532754481f666/comments", "author": null, "committer": null, "parents": [{"sha": "ab83232a37d045eb644bca473428416da3254cd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab83232a37d045eb644bca473428416da3254cd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab83232a37d045eb644bca473428416da3254cd2"}], "stats": {"total": 1839, "additions": 1839, "deletions": 0}, "files": [{"sha": "9054f459e8b3bd0bf263105f26029cf5db3c7635", "filename": "gcc/calls.c", "status": "added", "additions": 1839, "deletions": 0, "changes": 1839, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bbfa0c65bda8c617aea710627532754481f666/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bbfa0c65bda8c617aea710627532754481f666/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=51bbfa0c65bda8c617aea710627532754481f666", "patch": "@@ -0,0 +1,1839 @@\n+/* Convert function calls to rtl insns, for GNU C compiler.\n+   Copyright (C) 1989, 1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"expr.h\"\n+#include \"insn-flags.h\"\n+\n+/* Decide whether a function's arguments should be processed\n+   from first to last or from last to first.  */\n+\n+#ifdef STACK_GROWS_DOWNWARD\n+#ifdef PUSH_ROUNDING\n+#define PUSH_ARGS_REVERSED\t/* If it's last to first */\n+#endif\n+#endif\n+\n+/* Like STACK_BOUNDARY but in units of bytes, not bits.  */\n+#define STACK_BYTES (STACK_BOUNDARY / BITS_PER_UNIT)\n+\n+/* Data structure and subroutines used within expand_call.  */\n+\n+struct arg_data\n+{\n+  /* Tree node for this argument.  */\n+  tree tree_value;\n+  /* Current RTL value for argument, or 0 if it isn't precomputed.  */\n+  rtx value;\n+  /* Initially-compute RTL value for argument; only for const functions.  */\n+  rtx initial_value;\n+  /* Register to pass this argument in, 0 if passed on stack, or an\n+     EXPR_LIST if the arg is to be copied into multiple different\n+     registers.  */\n+  rtx reg;\n+  /* Number of registers to use.  0 means put the whole arg in registers.\n+     Also 0 if not passed in registers.  */\n+  int partial;\n+  /* Non-zero if argument must be passed on stack.  */\n+  int pass_on_stack;\n+  /* Offset of this argument from beginning of stack-args.  */\n+  struct args_size offset;\n+  /* Similar, but offset to the start of the stack slot.  Different from\n+     OFFSET if this arg pads downward.  */\n+  struct args_size slot_offset;\n+  /* Size of this argument on the stack, rounded up for any padding it gets,\n+     parts of the argument passed in registers do not count.\n+     If REG_PARM_STACK_SPACE is defined, then register parms\n+     are counted here as well.  */\n+  struct args_size size;\n+  /* Location on the stack at which parameter should be stored.  The store\n+     has already been done if STACK == VALUE.  */\n+  rtx stack;\n+  /* Location on the stack of the start of this argument slot.  This can\n+     differ from STACK if this arg pads downward.  This location is known\n+     to be aligned to FUNCTION_ARG_BOUNDARY.  */\n+  rtx stack_slot;\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+  /* Place that this stack area has been saved, if needed.  */\n+  rtx save_area;\n+#endif\n+};\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+/* A vector of one char per word of stack space.  A byte if non-zero if\n+   the corresponding stack location has been used.\n+   This vector is used to prevent a function call within an argument from\n+   clobbering any stack already set up.  */\n+static char *stack_usage_map;\n+\n+/* Size of STACK_USAGE_MAP.  */\n+static int highest_outgoing_arg_in_use;\n+#endif\n+\n+static void store_one_arg ();\n+extern enum machine_mode mode_for_size ();\n+\f\n+/* Return 1 if EXP contains a call to the built-in function `alloca'.  */\n+\n+static int\n+calls_alloca (exp)\n+     tree exp;\n+{\n+  register int i;\n+  int type = TREE_CODE_CLASS (TREE_CODE (exp));\n+  int length = tree_code_length[(int) TREE_CODE (exp)];\n+\n+  /* Only expressions and references can contain calls.  */\n+\n+  if (type != 'e' && type != '<' && type != '1' && type != '2' && type != 'r')\n+    return 0;\n+\n+  switch (TREE_CODE (exp))\n+    {\n+    case CALL_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n+\t  && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n+\t      == FUNCTION_DECL)\n+\t  && DECL_BUILT_IN (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n+\t  && (DECL_FUNCTION_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n+\t      == BUILT_IN_ALLOCA))\n+\treturn 1;\n+\n+      /* Third operand is RTL.  */\n+      length = 2;\n+      break;\n+\n+    case SAVE_EXPR:\n+      if (SAVE_EXPR_RTL (exp) != 0)\n+\treturn 0;\n+      break;\n+\n+    case BLOCK:\n+      /* Must not look at BLOCK_SUPERCONTEXT since it will point back to\n+\t us.  */\n+      length = 3;\n+      break;\n+\n+    case METHOD_CALL_EXPR:\n+      length = 3;\n+      break;\n+\n+    case WITH_CLEANUP_EXPR:\n+      length = 1;\n+      break;\n+\n+    case RTL_EXPR:\n+      return 0;\n+    }\n+\n+  for (i = 0; i < length; i++)\n+    if (TREE_OPERAND (exp, i) != 0\n+\t&& calls_alloca (TREE_OPERAND (exp, i)))\n+      return 1;\n+\n+  return 0;\n+}\n+\f\n+/* Force FUNEXP into a form suitable for the address of a CALL,\n+   and return that as an rtx.  Also load the static chain register\n+   if FNDECL is a nested function.\n+\n+   USE_INSNS points to a variable holding a chain of USE insns\n+   to which a USE of the static chain\n+   register should be added, if required.  */\n+\n+rtx\n+prepare_call_address (funexp, fndecl, use_insns)\n+     rtx funexp;\n+     tree fndecl;\n+     rtx *use_insns;\n+{\n+  rtx static_chain_value = 0;\n+\n+  funexp = protect_from_queue (funexp, 0);\n+\n+  if (fndecl != 0)\n+    /* Get possible static chain value for nested function in C. */\n+    static_chain_value = lookup_static_chain (fndecl);\n+\n+  /* Make a valid memory address and copy constants thru pseudo-regs,\n+     but not for a constant address if -fno-function-cse.  */\n+  if (GET_CODE (funexp) != SYMBOL_REF)\n+    funexp = memory_address (FUNCTION_MODE, funexp);\n+  else\n+    {\n+#ifndef NO_FUNCTION_CSE\n+      if (optimize && ! flag_no_function_cse)\n+#ifdef NO_RECURSIVE_FUNCTION_CSE\n+\tif (fndecl != current_function_decl)\n+#endif\n+\t  funexp = force_reg (Pmode, funexp);\n+#endif\n+    }\n+\n+  if (static_chain_value != 0)\n+    {\n+      emit_move_insn (static_chain_rtx, static_chain_value);\n+\n+      /* Put the USE insn in the chain we were passed.  It will later be\n+\t output immediately in front of the CALL insn.  */\n+      push_to_sequence (*use_insns);\n+      emit_insn (gen_rtx (USE, VOIDmode, static_chain_rtx));\n+      *use_insns = get_insns ();\n+      end_sequence ();\n+    }\n+\n+  return funexp;\n+}\n+\n+/* Generate instructions to call function FUNEXP,\n+   and optionally pop the results.\n+   The CALL_INSN is the first insn generated.\n+\n+   FUNTYPE is the data type of the function, or, for a library call,\n+   the identifier for the name of the call.  This is given to the\n+   macro RETURN_POPS_ARGS to determine whether this function pops its own args.\n+\n+   STACK_SIZE is the number of bytes of arguments on the stack,\n+   rounded up to STACK_BOUNDARY; zero if the size is variable.\n+   This is both to put into the call insn and\n+   to generate explicit popping code if necessary.\n+\n+   STRUCT_VALUE_SIZE is the number of bytes wanted in a structure value.\n+   It is zero if this call doesn't want a structure value.\n+\n+   NEXT_ARG_REG is the rtx that results from executing\n+     FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1)\n+   just after all the args have had their registers assigned.\n+   This could be whatever you like, but normally it is the first\n+   arg-register beyond those used for args in this call,\n+   or 0 if all the arg-registers are used in this call.\n+   It is passed on to `gen_call' so you can put this info in the call insn.\n+\n+   VALREG is a hard register in which a value is returned,\n+   or 0 if the call does not return a value.\n+\n+   OLD_INHIBIT_DEFER_POP is the value that `inhibit_defer_pop' had before\n+   the args to this call were processed.\n+   We restore `inhibit_defer_pop' to that value.\n+\n+   USE_INSNS is a chain of USE insns to be emitted immediately before\n+   the actual CALL insn.\n+\n+   IS_CONST is true if this is a `const' call.  */\n+\n+void\n+emit_call_1 (funexp, funtype, stack_size, struct_value_size, next_arg_reg,\n+\t     valreg, old_inhibit_defer_pop, use_insns, is_const)\n+     rtx funexp;\n+     tree funtype;\n+     int stack_size;\n+     int struct_value_size;\n+     rtx next_arg_reg;\n+     rtx valreg;\n+     int old_inhibit_defer_pop;\n+     rtx use_insns;\n+     int is_const;\n+{\n+  rtx stack_size_rtx = gen_rtx (CONST_INT, VOIDmode, stack_size);\n+  rtx struct_value_size_rtx = gen_rtx (CONST_INT, VOIDmode, struct_value_size);\n+  rtx call_insn;\n+  int already_popped = 0;\n+\n+  /* Ensure address is valid.  SYMBOL_REF is already valid, so no need,\n+     and we don't want to load it into a register as an optimization,\n+     because prepare_call_address already did it if it should be done.  */\n+  if (GET_CODE (funexp) != SYMBOL_REF)\n+    funexp = memory_address (FUNCTION_MODE, funexp);\n+\n+#ifndef ACCUMULATE_OUTGOING_ARGS\n+#if defined (HAVE_call_pop) && defined (HAVE_call_value_pop)\n+  if (HAVE_call_pop && HAVE_call_value_pop\n+      && (RETURN_POPS_ARGS (funtype, stack_size) > 0 || stack_size == 0))\n+    {\n+      rtx n_pop = gen_rtx (CONST_INT, VOIDmode, \n+\t\t\t   RETURN_POPS_ARGS (funtype, stack_size));\n+      rtx pat;\n+\n+      /* If this subroutine pops its own args, record that in the call insn\n+\t if possible, for the sake of frame pointer elimination.  */\n+      if (valreg)\n+\tpat = gen_call_value_pop (valreg,\n+\t\t\t\t  gen_rtx (MEM, FUNCTION_MODE, funexp),\n+\t\t\t\t  stack_size_rtx, next_arg_reg, n_pop);\n+      else\n+\tpat = gen_call_pop (gen_rtx (MEM, FUNCTION_MODE, funexp),\n+\t\t\t    stack_size_rtx, next_arg_reg, n_pop);\n+\n+      emit_call_insn (pat);\n+      already_popped = 1;\n+    }\n+  else\n+#endif\n+#endif\n+\n+#if defined (HAVE_call) && defined (HAVE_call_value)\n+  if (HAVE_call && HAVE_call_value)\n+    {\n+      if (valreg)\n+\temit_call_insn (gen_call_value (valreg,\n+\t\t\t\t\tgen_rtx (MEM, FUNCTION_MODE, funexp),\n+\t\t\t\t\tstack_size_rtx, next_arg_reg));\n+      else\n+\temit_call_insn (gen_call (gen_rtx (MEM, FUNCTION_MODE, funexp),\n+\t\t\t\t  stack_size_rtx, next_arg_reg,\n+\t\t\t\t  struct_value_size_rtx));\n+    }\n+  else\n+#endif\n+    abort ();\n+\n+  /* Find the CALL insn we just emitted and write the USE insns before it.  */\n+  for (call_insn = get_last_insn ();\n+       call_insn && GET_CODE (call_insn) != CALL_INSN;\n+       call_insn = PREV_INSN (call_insn))\n+    ;\n+\n+  if (! call_insn)\n+    abort ();\n+\n+  /* Put the USE insns before the CALL.  */\n+  emit_insns_before (use_insns, call_insn);\n+\n+  /* If this is a const call, then set the insn's unchanging bit.  */\n+  if (is_const)\n+    CONST_CALL_P (call_insn) = 1;\n+\n+  inhibit_defer_pop = old_inhibit_defer_pop;\n+\n+#ifndef ACCUMULATE_OUTGOING_ARGS\n+  /* If returning from the subroutine does not automatically pop the args,\n+     we need an instruction to pop them sooner or later.\n+     Perhaps do it now; perhaps just record how much space to pop later.\n+\n+     If returning from the subroutine does pop the args, indicate that the\n+     stack pointer will be changed.  */\n+\n+  if (stack_size != 0 && RETURN_POPS_ARGS (funtype, stack_size) > 0)\n+    {\n+      if (!already_popped)\n+\temit_insn (gen_rtx (CLOBBER, VOIDmode, stack_pointer_rtx));\n+      stack_size -= RETURN_POPS_ARGS (funtype, stack_size);\n+      stack_size_rtx = gen_rtx (CONST_INT, VOIDmode, stack_size);\n+    }\n+\n+  if (stack_size != 0)\n+    {\n+      if (flag_defer_pop && inhibit_defer_pop == 0)\n+\tpending_stack_adjust += stack_size;\n+      else\n+\tadjust_stack (stack_size_rtx);\n+    }\n+#endif\n+}\n+\n+/* Generate all the code for a function call\n+   and return an rtx for its value.\n+   Store the value in TARGET (specified as an rtx) if convenient.\n+   If the value is stored in TARGET then TARGET is returned.\n+   If IGNORE is nonzero, then we ignore the value of the function call.  */\n+\n+rtx\n+expand_call (exp, target, ignore, modifier)\n+     tree exp;\n+     rtx target;\n+     int ignore;\n+     enum expand_modifier modifier;\n+{\n+  /* List of actual parameters.  */\n+  tree actparms = TREE_OPERAND (exp, 1);\n+  /* RTX for the function to be called.  */\n+  rtx funexp;\n+  /* Tree node for the function to be called (not the address!).  */\n+  tree funtree;\n+  /* Data type of the function.  */\n+  tree funtype;\n+  /* Declaration of the function being called,\n+     or 0 if the function is computed (not known by name).  */\n+  tree fndecl = 0;\n+  char *name = 0;\n+\n+  /* Register in which non-BLKmode value will be returned,\n+     or 0 if no value or if value is BLKmode.  */\n+  rtx valreg;\n+  /* Address where we should return a BLKmode value;\n+     0 if value not BLKmode.  */\n+  rtx structure_value_addr = 0;\n+  /* Nonzero if that address is being passed by treating it as\n+     an extra, implicit first parameter.  Otherwise,\n+     it is passed by being copied directly into struct_value_rtx.  */\n+  int structure_value_addr_parm = 0;\n+  /* Size of aggregate value wanted, or zero if none wanted\n+     or if we are using the non-reentrant PCC calling convention\n+     or expecting the value in registers.  */\n+  int struct_value_size = 0;\n+  /* Nonzero if called function returns an aggregate in memory PCC style,\n+     by returning the address of where to find it.  */\n+  int pcc_struct_value = 0;\n+\n+  /* Number of actual parameters in this call, including struct value addr.  */\n+  int num_actuals;\n+  /* Number of named args.  Args after this are anonymous ones\n+     and they must all go on the stack.  */\n+  int n_named_args;\n+  /* Count arg position in order args appear.  */\n+  int argpos;\n+\n+  /* Vector of information about each argument.\n+     Arguments are numbered in the order they will be pushed,\n+     not the order they are written.  */\n+  struct arg_data *args;\n+\n+  /* Total size in bytes of all the stack-parms scanned so far.  */\n+  struct args_size args_size;\n+  /* Size of arguments before any adjustments (such as rounding).  */\n+  struct args_size original_args_size;\n+  /* Data on reg parms scanned so far.  */\n+  CUMULATIVE_ARGS args_so_far;\n+  /* Nonzero if a reg parm has been scanned.  */\n+  int reg_parm_seen;\n+\n+  /* Nonzero if we must avoid push-insns in the args for this call. \n+     If stack space is allocated for register parameters, but not by the\n+     caller, then it is preallocated in the fixed part of the stack frame.\n+     So the entire argument block must then be preallocated (i.e., we\n+     ignore PUSH_ROUNDING in that case).  */\n+\n+#if defined(REG_PARM_STACK_SPACE) && ! defined(OUTGOING_REG_PARM_STACK_SPACE)\n+  int must_preallocate = 1;\n+#else\n+#ifdef PUSH_ROUNDING\n+  int must_preallocate = 0;\n+#else\n+  int must_preallocate = 1;\n+#endif\n+#endif\n+\n+  /* 1 if scanning parms front to back, -1 if scanning back to front.  */\n+  int inc;\n+  /* Address of space preallocated for stack parms\n+     (on machines that lack push insns), or 0 if space not preallocated.  */\n+  rtx argblock = 0;\n+\n+  /* Nonzero if it is plausible that this is a call to alloca.  */\n+  int may_be_alloca;\n+  /* Nonzero if this is a call to setjmp or a related function.  */\n+  int returns_twice;\n+  /* Nonzero if this is a call to `longjmp'.  */\n+  int is_longjmp;\n+  /* Nonzero if this is a call to an inline function.  */\n+  int is_integrable = 0;\n+  /* Nonzero if this is a call to __builtin_new.  */\n+  int is_builtin_new;\n+  /* Nonzero if this is a call to a `const' function.\n+     Note that only explicitly named functions are handled as `const' here.  */\n+  int is_const = 0;\n+  /* Nonzero if this is a call to a `volatile' function.  */\n+  int is_volatile = 0;\n+#if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n+  /* Define the boundary of the register parm stack space that needs to be\n+     save, if any.  */\n+  int low_to_save = -1, high_to_save;\n+  rtx save_area = 0;\t\t/* Place that it is saved */\n+#endif\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+  int initial_highest_arg_in_use = highest_outgoing_arg_in_use;\n+  char *initial_stack_usage_map = stack_usage_map;\n+#endif\n+\n+  rtx old_stack_level = 0;\n+  int old_pending_adj;\n+  int old_inhibit_defer_pop = inhibit_defer_pop;\n+  tree old_cleanups = cleanups_this_call;\n+\n+  rtx use_insns = 0;\n+\n+  register tree p;\n+  register int i;\n+\n+  /* See if we can find a DECL-node for the actual function.\n+     As a result, decide whether this is a call to an integrable function.  */\n+\n+  p = TREE_OPERAND (exp, 0);\n+  if (TREE_CODE (p) == ADDR_EXPR)\n+    {\n+      fndecl = TREE_OPERAND (p, 0);\n+      if (TREE_CODE (fndecl) != FUNCTION_DECL)\n+\t{\n+\t  /* May still be a `const' function if it is\n+\t     a call through a pointer-to-const.\n+\t     But we don't handle that.  */\n+\t  fndecl = 0;\n+\t}\n+      else\n+\t{\n+\t  if (!flag_no_inline\n+\t      && fndecl != current_function_decl\n+\t      && DECL_SAVED_INSNS (fndecl))\n+\t    is_integrable = 1;\n+\t  else if (! TREE_ADDRESSABLE (fndecl))\n+\t    {\n+\t      /* In case this function later becomes inlineable,\n+\t\t record that there was already a non-inline call to it.\n+\n+\t\t Use abstraction instead of setting TREE_ADDRESSABLE\n+\t\t directly.  */\n+\t      if (TREE_INLINE (fndecl) && extra_warnings && !flag_no_inline)\n+\t\twarning_with_decl (fndecl, \"can't inline call to `%s' which was declared inline\");\n+\t      mark_addressable (fndecl);\n+\t    }\n+\n+\t  if (TREE_READONLY (fndecl) && ! TREE_THIS_VOLATILE (fndecl))\n+\t    is_const = 1;\n+\t}\n+    }\n+\n+  is_volatile = TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (p)));\n+\n+  /* Warn if this value is an aggregate type,\n+     regardless of which calling convention we are using for it.  */\n+  if (warn_aggregate_return\n+      && (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE\n+\t  || TREE_CODE (TREE_TYPE (exp)) == UNION_TYPE\n+\t  || TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE))\n+    warning (\"function call has aggregate value\");\n+\n+  /* Set up a place to return a structure.  */\n+\n+  /* Cater to broken compilers.  */\n+  if (aggregate_value_p (exp))\n+    {\n+      /* This call returns a big structure.  */\n+      is_const = 0;\n+\n+#ifdef PCC_STATIC_STRUCT_RETURN\n+      if (flag_pcc_struct_return)\n+\t{\n+\t  pcc_struct_value = 1;\n+\t  is_integrable = 0;  /* Easier than making that case work right.  */\n+\t}\n+      else\n+#endif\n+\t{\n+\t  struct_value_size = int_size_in_bytes (TREE_TYPE (exp));\n+\n+\t  if (struct_value_size < 0)\n+\t    abort ();\n+\n+\t  if (target && GET_CODE (target) == MEM)\n+\t    structure_value_addr = XEXP (target, 0);\n+\t  else\n+\t    {\n+\t      /* Assign a temporary on the stack to hold the value.  */\n+\n+\t      /* For variable-sized objects, we must be called with a target\n+\t\t specified.  If we were to allocate space on the stack here,\n+\t\t we would have no way of knowing when to free it.  */\n+\n+\t      structure_value_addr\n+\t\t= XEXP (assign_stack_temp (BLKmode, struct_value_size, 1), 0);\n+\t      target = 0;\n+\t    }\n+\t}\n+    }\n+\n+  /* If called function is inline, try to integrate it.  */\n+\n+  if (is_integrable)\n+    {\n+      rtx temp;\n+\n+      temp = expand_inline_function (fndecl, actparms, target,\n+\t\t\t\t     ignore, TREE_TYPE (exp),\n+\t\t\t\t     structure_value_addr);\n+\n+      /* If inlining succeeded, return.  */\n+      if ((int) temp != -1)\n+\t{\n+\t  /* Perform all cleanups needed for the arguments of this call\n+\t     (i.e. destructors in C++).  It is ok if these destructors\n+\t     clobber RETURN_VALUE_REG, because the only time we care about\n+\t     this is when TARGET is that register.  But in C++, we take\n+\t     care to never return that register directly.  */\n+\t  expand_cleanups_to (old_cleanups);\n+\n+\t  /* If the result is equivalent to TARGET, return TARGET to simplify\n+\t     checks in store_expr.  They can be equivalent but not equal in the\n+\t     case of a function that returns BLKmode.  */\n+\t  if (temp != target && rtx_equal_p (temp, target))\n+\t    return target;\n+\t  return temp;\n+\t}\n+\n+      /* If inlining failed, mark FNDECL as needing to be compiled\n+\t separately after all.  */\n+      mark_addressable (fndecl);\n+    }\n+\n+  /* When calling a const function, we must pop the stack args right away,\n+     so that the pop is deleted or moved with the call.  */\n+  if (is_const)\n+    NO_DEFER_POP;\n+\n+  function_call_count++;\n+\n+  if (fndecl && DECL_NAME (fndecl))\n+    name = IDENTIFIER_POINTER (DECL_NAME (fndecl));\n+\n+#if 0\n+  /* Unless it's a call to a specific function that isn't alloca,\n+     if it has one argument, we must assume it might be alloca.  */\n+\n+  may_be_alloca =\n+    (!(fndecl != 0 && strcmp (name, \"alloca\"))\n+     && actparms != 0\n+     && TREE_CHAIN (actparms) == 0);\n+#else\n+  /* We assume that alloca will always be called by name.  It\n+     makes no sense to pass it as a pointer-to-function to\n+     anything that does not understand its behavior.  */\n+  may_be_alloca =\n+    (name && ((IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 6\n+\t\t && name[0] == 'a'\n+\t\t && ! strcmp (name, \"alloca\"))\n+\t\t|| (IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 16\n+\t\t    && name[0] == '_'\n+\t\t    && ! strcmp (name, \"__builtin_alloca\"))));\n+#endif\n+\n+  /* See if this is a call to a function that can return more than once\n+     or a call to longjmp.  */\n+\n+  returns_twice = 0;\n+  is_longjmp = 0;\n+\n+  if (name != 0 && IDENTIFIER_LENGTH (DECL_NAME (fndecl)) <= 15)\n+    {\n+      char *tname = name;\n+\n+      if (name[0] == '_')\n+\ttname += ((name[1] == '_' && name[2] == 'x') ? 3 : 1);\n+\n+      if (tname[0] == 's')\n+\t{\n+\t  returns_twice\n+\t    = ((tname[1] == 'e'\n+\t\t&& (! strcmp (tname, \"setjmp\")\n+\t\t    || ! strcmp (tname, \"setjmp_syscall\")))\n+\t       || (tname[1] == 'i'\n+\t\t   && ! strcmp (tname, \"sigsetjmp\"))\n+\t       || (tname[1] == 'a'\n+\t\t   && ! strcmp (tname, \"savectx\")));\n+\t  if (tname[1] == 'i'\n+\t      && ! strcmp (tname, \"siglongjmp\"))\n+\t    is_longjmp = 1;\n+\t}\n+      else if ((tname[0] == 'q' && tname[1] == 's'\n+\t\t&& ! strcmp (tname, \"qsetjmp\"))\n+\t       || (tname[0] == 'v' && tname[1] == 'f'\n+\t\t   && ! strcmp (tname, \"vfork\")))\n+\treturns_twice = 1;\n+\n+      else if (tname[0] == 'l' && tname[1] == 'o'\n+\t       && ! strcmp (tname, \"longjmp\"))\n+\tis_longjmp = 1;\n+    }\n+\n+  is_builtin_new\n+    = (name != 0\n+       && IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 13\n+       && (!strcmp (name, \"__builtin_new\")));\n+\n+  if (may_be_alloca)\n+    current_function_calls_alloca = 1;\n+\n+  /* Don't let pending stack adjusts add up to too much.\n+     Also, do all pending adjustments now\n+     if there is any chance this might be a call to alloca.  */\n+\n+  if (pending_stack_adjust >= 32\n+      || (pending_stack_adjust > 0 && may_be_alloca))\n+    do_pending_stack_adjust ();\n+\n+  /* Operand 0 is a pointer-to-function; get the type of the function.  */\n+  funtype = TREE_TYPE (TREE_OPERAND (exp, 0));\n+  if (TREE_CODE (funtype) != POINTER_TYPE)\n+    abort ();\n+  funtype = TREE_TYPE (funtype);\n+\n+  /* Push the temporary stack slot level so that we can free temporaries used\n+     by each of the arguments separately.  */\n+  push_temp_slots ();\n+\n+  /* Start updating where the next arg would go.  */\n+  INIT_CUMULATIVE_ARGS (args_so_far, funtype, 0);\n+\n+  /* If struct_value_rtx is 0, it means pass the address\n+     as if it were an extra parameter.  */\n+  if (structure_value_addr && struct_value_rtx == 0)\n+    {\n+      actparms\n+\t= tree_cons (error_mark_node,\n+\t\t     make_tree (build_pointer_type (TREE_TYPE (funtype)),\n+\t\t\t\tforce_reg (Pmode, structure_value_addr)),\n+\t\t     actparms);\n+      structure_value_addr_parm = 1;\n+    }\n+\n+  /* Count the arguments and set NUM_ACTUALS.  */\n+  for (p = actparms, i = 0; p; p = TREE_CHAIN (p)) i++;\n+  num_actuals = i;\n+\n+  /* Compute number of named args.\n+     Normally, don't include the last named arg if anonymous args follow.\n+     (If no anonymous args follow, the result of list_length\n+     is actually one too large.)\n+\n+     If SETUP_INCOMING_VARARGS is defined, this machine will be able to\n+     place unnamed args that were passed in registers into the stack.  So\n+     treat all args as named.  This allows the insns emitting for a specific\n+     argument list to be independant of the function declaration.\n+\n+     If SETUP_INCOMING_VARARGS is not defined, we do not have any reliable\n+     way to pass unnamed args in registers, so we must force them into\n+     memory.  */\n+#ifndef SETUP_INCOMING_VARARGS\n+  if (TYPE_ARG_TYPES (funtype) != 0)\n+    n_named_args\n+      = list_length (TYPE_ARG_TYPES (funtype)) - 1\n+\t/* Count the struct value address, if it is passed as a parm.  */\n+\t+ structure_value_addr_parm;\n+  else\n+#endif\n+    /* If we know nothing, treat all args as named.  */\n+    n_named_args = num_actuals;\n+\n+  /* Make a vector to hold all the information about each arg.  */\n+  args = (struct arg_data *) alloca (num_actuals * sizeof (struct arg_data));\n+  bzero (args, num_actuals * sizeof (struct arg_data));\n+\n+  args_size.constant = 0;\n+  args_size.var = 0;\n+\n+  /* In this loop, we consider args in the order they are written.\n+     We fill up ARGS from the front of from the back if necessary\n+     so that in any case the first arg to be pushed ends up at the front.  */\n+\n+#ifdef PUSH_ARGS_REVERSED\n+  i = num_actuals - 1, inc = -1;\n+  /* In this case, must reverse order of args\n+     so that we compute and push the last arg first.  */\n+#else\n+  i = 0, inc = 1;\n+#endif\n+\n+  /* I counts args in order (to be) pushed; ARGPOS counts in order written.  */\n+  for (p = actparms, argpos = 0; p; p = TREE_CHAIN (p), i += inc, argpos++)\n+    {\n+      tree type = TREE_TYPE (TREE_VALUE (p));\n+\n+      args[i].tree_value = TREE_VALUE (p);\n+\n+      /* Replace erroneous argument with constant zero.  */\n+      if (type == error_mark_node || TYPE_SIZE (type) == 0)\n+\targs[i].tree_value = integer_zero_node, type = integer_type_node;\n+\n+      /* Decide where to pass this arg.\n+\n+\t args[i].reg is nonzero if all or part is passed in registers.\n+\n+\t args[i].partial is nonzero if part but not all is passed in registers,\n+\t and the exact value says how many words are passed in registers.\n+\n+\t args[i].pass_on_stack is nonzero if the argument must at least be\n+\t computed on the stack.  It may then be loaded back into registers\n+\t if args[i].reg is nonzero.\n+\n+\t These decisions are driven by the FUNCTION_... macros and must agree\n+\t with those made by function.c.  */\n+\n+#ifdef FUNCTION_ARG_PASS_BY_REFERENCE\n+      /* See if this argument should be passed by invisible reference.  */\n+      if (FUNCTION_ARG_PASS_BY_REFERENCE (args_so_far, TYPE_MODE (type), type,\n+\t\t\t\t\t  argpos < n_named_args))\n+\t{\n+\t  /* We make a copy of the object and pass the address to the function\n+\t     being called.  */\n+\t  int size = int_size_in_bytes (type);\n+\t  rtx copy;\n+\n+\t  if (size < 0)\n+\t    {\n+\t      /* This is a variable-sized object.  Make space on the stack\n+\t\t for it.  */\n+\t      rtx size_rtx = expand_expr (size_in_bytes (type), 0,\n+\t\t\t\t\t  VOIDmode, 0);\n+\n+\t      if (old_stack_level == 0)\n+\t\t{\n+\t\t  old_stack_level = copy_to_mode_reg (Pmode, stack_pointer_rtx);\n+\t\t  old_pending_adj = pending_stack_adjust;\n+\t\t  pending_stack_adjust = 0;\n+\t\t}\n+\n+\t      copy = gen_rtx (MEM, BLKmode,\n+\t\t\t      allocate_dynamic_stack_space (size_rtx, 0));\n+\t    }\n+\t  else\n+\t    copy = assign_stack_temp (TYPE_MODE (type), size, 1);\n+\n+\t  store_expr (args[i].tree_value, copy, 0);\n+\n+\t  args[i].tree_value = build1 (ADDR_EXPR, build_pointer_type (type),\n+\t\t\t\t       make_tree (type, copy));\n+\t  type = build_pointer_type (type);\n+\t}\n+#endif\n+\n+      args[i].reg = FUNCTION_ARG (args_so_far, TYPE_MODE (type), type,\n+\t\t\t\t  argpos < n_named_args);\n+#ifdef FUNCTION_ARG_PARTIAL_NREGS\n+      if (args[i].reg)\n+\targs[i].partial\n+\t  = FUNCTION_ARG_PARTIAL_NREGS (args_so_far, TYPE_MODE (type), type,\n+\t\t\t\t\targpos < n_named_args);\n+#endif\n+\n+      args[i].pass_on_stack = MUST_PASS_IN_STACK (TYPE_MODE (type), type);\n+\n+      /* If FUNCTION_ARG returned an (expr_list (nil) FOO), it means that\n+\t we are to pass this arg in the register(s) designated by FOO, but\n+\t also to pass it in the stack.  */\n+      if (args[i].reg && GET_CODE (args[i].reg) == EXPR_LIST\n+\t  && XEXP (args[i].reg, 0) == 0)\n+\targs[i].pass_on_stack = 1, args[i].reg = XEXP (args[i].reg, 1);\n+\n+      /* If this is an addressable type, we must preallocate the stack\n+\t since we must evaluate the object into its final location.\n+\n+\t If this is to be passed in both registers and the stack, it is simpler\n+\t to preallocate.  */\n+      if (TREE_ADDRESSABLE (type)\n+\t  || (args[i].pass_on_stack && args[i].reg != 0))\n+\tmust_preallocate = 1;\n+\n+      /* If this is an addressable type, we cannot pre-evaluate it.  Thus,\n+\t we cannot consider this function call constant.  */\n+      if (TREE_ADDRESSABLE (type))\n+\tis_const = 0;\n+\n+      /* Compute the stack-size of this argument.  */\n+      if (args[i].reg == 0 || args[i].partial != 0\n+#ifdef REG_PARM_STACK_SPACE\n+\t  || REG_PARM_STACK_SPACE (fndecl) > 0\n+#endif\n+\t  || args[i].pass_on_stack)\n+\tlocate_and_pad_parm (TYPE_MODE (type), type,\n+#ifdef STACK_PARMS_IN_REG_PARM_AREA\n+\t\t\t     1,\n+#else\n+\t\t\t     args[i].reg != 0,\n+#endif\n+\t\t\t     fndecl, &args_size, &args[i].offset,\n+\t\t\t     &args[i].size);\n+\n+#ifndef ARGS_GROW_DOWNWARD\n+      args[i].slot_offset = args_size;\n+#endif\n+\n+#ifndef REG_PARM_STACK_SPACE\n+      /* If a part of the arg was put into registers,\n+\t don't include that part in the amount pushed.  */\n+      if (! args[i].pass_on_stack)\n+\targs[i].size.constant -= ((args[i].partial * UNITS_PER_WORD)\n+\t\t\t\t  / (PARM_BOUNDARY / BITS_PER_UNIT)\n+\t\t\t\t  * (PARM_BOUNDARY / BITS_PER_UNIT));\n+#endif\n+      \n+      /* Update ARGS_SIZE, the total stack space for args so far.  */\n+\n+      args_size.constant += args[i].size.constant;\n+      if (args[i].size.var)\n+\t{\n+\t  ADD_PARM_SIZE (args_size, args[i].size.var);\n+\t}\n+\n+      /* Since the slot offset points to the bottom of the slot,\n+\t we must record it after incrementing if the args grow down.  */\n+#ifdef ARGS_GROW_DOWNWARD\n+      args[i].slot_offset = args_size;\n+\n+      args[i].slot_offset.constant = -args_size.constant;\n+      if (args_size.var)\n+\t{\n+\t  SUB_PARM_SIZE (args[i].slot_offset, args_size.var);\n+\t}\n+#endif\n+\n+      /* Increment ARGS_SO_FAR, which has info about which arg-registers\n+\t have been used, etc.  */\n+\n+      FUNCTION_ARG_ADVANCE (args_so_far, TYPE_MODE (type), type,\n+\t\t\t    argpos < n_named_args);\n+    }\n+\n+  /* Compute the actual size of the argument block required.  The variable\n+     and constant sizes must be combined, the size may have to be rounded,\n+     and there may be a minimum required size.  */\n+\n+  original_args_size = args_size;\n+  if (args_size.var)\n+    {\n+      /* If this function requires a variable-sized argument list, don't try to\n+\t make a cse'able block for this call.  We may be able to do this\n+\t eventually, but it is too complicated to keep track of what insns go\n+\t in the cse'able block and which don't.  */\n+\n+      is_const = 0;\n+      must_preallocate = 1;\n+\n+      args_size.var = ARGS_SIZE_TREE (args_size);\n+      args_size.constant = 0;\n+\n+#ifdef STACK_BOUNDARY\n+      if (STACK_BOUNDARY != BITS_PER_UNIT)\n+\targs_size.var = round_up (args_size.var, STACK_BYTES);\n+#endif\n+\n+#ifdef REG_PARM_STACK_SPACE\n+      if (REG_PARM_STACK_SPACE (fndecl) > 0)\n+\t{\n+\t  args_size.var\n+\t    = size_binop (MAX_EXPR, args_size.var,\n+\t\t\t  size_int (REG_PARM_STACK_SPACE (fndecl)));\n+\n+#ifndef OUTGOING_REG_PARM_STACK_SPACE\n+\t  /* The area corresponding to register parameters is not to count in\n+\t     the size of the block we need.  So make the adjustment.  */\n+\t  args_size.var\n+\t    = size_binop (MINUS_EXPR, args_size.var,\n+\t\t\t  size_int (REG_PARM_STACK_SPACE (fndecl)));\n+#endif\n+\t}\n+#endif\n+    }\n+  else\n+    {\n+#ifdef STACK_BOUNDARY\n+      args_size.constant = (((args_size.constant + (STACK_BYTES - 1))\n+\t\t\t     / STACK_BYTES) * STACK_BYTES);\n+#endif\n+\n+#ifdef REG_PARM_STACK_SPACE\n+      args_size.constant = MAX (args_size.constant,\n+\t\t\t\tREG_PARM_STACK_SPACE (fndecl));\n+#ifndef OUTGOING_REG_PARM_STACK_SPACE\n+      args_size.constant -= REG_PARM_STACK_SPACE (fndecl);\n+#endif\n+#endif\n+    }\n+\n+  /* See if we have or want to preallocate stack space.\n+\n+     If we would have to push a partially-in-regs parm\n+     before other stack parms, preallocate stack space instead.\n+\n+     If the size of some parm is not a multiple of the required stack\n+     alignment, we must preallocate.\n+\n+     If the total size of arguments that would otherwise create a copy in\n+     a temporary (such as a CALL) is more than half the total argument list\n+     size, preallocation is faster.\n+\n+     Another reason to preallocate is if we have a machine (like the m88k)\n+     where stack alignment is required to be maintained between every\n+     pair of insns, not just when the call is made.  However, we assume here\n+     that such machines either do not have push insns (and hence preallocation\n+     would occur anyway) or the problem is taken care of with\n+     PUSH_ROUNDING.  */\n+\n+  if (! must_preallocate)\n+    {\n+      int partial_seen = 0;\n+      int copy_to_evaluate_size = 0;\n+\n+      for (i = 0; i < num_actuals && ! must_preallocate; i++)\n+\t{\n+\t  if (args[i].partial > 0 && ! args[i].pass_on_stack)\n+\t    partial_seen = 1;\n+\t  else if (partial_seen && args[i].reg == 0)\n+\t    must_preallocate = 1;\n+\n+\t  if (TYPE_MODE (TREE_TYPE (args[i].tree_value)) == BLKmode\n+\t      && (TREE_CODE (args[i].tree_value) == CALL_EXPR\n+\t\t  || TREE_CODE (args[i].tree_value) == TARGET_EXPR\n+\t\t  || TREE_CODE (args[i].tree_value) == COND_EXPR\n+\t\t  || TREE_ADDRESSABLE (TREE_TYPE (args[i].tree_value))))\n+\t    copy_to_evaluate_size\n+\t      += int_size_in_bytes (TREE_TYPE (args[i].tree_value));\n+\t}\n+\n+      if (copy_to_evaluate_size >= args_size.constant / 2)\n+\tmust_preallocate = 1;\n+    }\n+\n+  /* If the structure value address will reference the stack pointer, we must\n+     stabilize it.  We don't need to do this if we know that we are not going\n+     to adjust the stack pointer in processing this call.  */\n+\n+  if (structure_value_addr\n+      && (reg_mentioned_p (virtual_stack_dynamic_rtx, structure_value_addr)\n+       || reg_mentioned_p (virtual_outgoing_args_rtx, structure_value_addr))\n+      && (args_size.var\n+#ifndef ACCUMULATE_OUTGOING_ARGS\n+\t  || args_size.constant\n+#endif\n+\t  ))\n+    structure_value_addr = copy_to_reg (structure_value_addr);\n+\n+  /* If this function call is cse'able, precompute all the parameters.\n+     Note that if the parameter is constructed into a temporary, this will\n+     cause an additional copy because the parameter will be constructed\n+     into a temporary location and then copied into the outgoing arguments.\n+     If a parameter contains a call to alloca and this function uses the\n+     stack, precompute the parameter.  */\n+\n+  for (i = 0; i < num_actuals; i++)\n+    if (is_const\n+\t|| ((args_size.var != 0 || args_size.constant != 0)\n+\t    && calls_alloca (args[i].tree_value)))\n+      {\n+\targs[i].initial_value = args[i].value\n+\t  = expand_expr (args[i].tree_value, 0, VOIDmode, 0);\n+\tpreserve_temp_slots (args[i].value);\n+\tfree_temp_slots ();\n+\n+\t/* ANSI doesn't require a sequence point here,\n+\t   but PCC has one, so this will avoid some problems.  */\n+\temit_queue ();\n+      }\n+\n+  /* Now we are about to start emitting insns that can be deleted\n+     if a libcall is deleted.  */\n+  if (is_const)\n+    start_sequence ();\n+\n+  /* If we have no actual push instructions, or shouldn't use them,\n+     make space for all args right now.  */\n+\n+  if (args_size.var != 0)\n+    {\n+      if (old_stack_level == 0)\n+\t{\n+\t  old_stack_level = copy_to_mode_reg (Pmode, stack_pointer_rtx);\n+\t  old_pending_adj = pending_stack_adjust;\n+\t  pending_stack_adjust = 0;\n+\t}\n+      argblock = push_block (ARGS_SIZE_RTX (args_size), 0, 0);\n+    }\n+  else if (must_preallocate)\n+    {\n+      /* Note that we must go through the motions of allocating an argument\n+\t block even if the size is zero because we may be storing args\n+\t in the area reserved for register arguments, which may be part of\n+\t the stack frame.  */\n+      int needed = args_size.constant;\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+      /* Store the maximum argument space used.  It will be pushed by the\n+\t prologue.\n+\n+\t Since the stack pointer will never be pushed, it is possible for\n+\t the evaluation of a parm to clobber something we have already\n+\t written to the stack.  Since most function calls on RISC machines\n+\t do not use the stack, this is uncommon, but must work correctly.\n+\t \n+\t Therefore, we save any area of the stack that was already written\n+\t and that we are using.  Here we set up to do this by making a new\n+\t stack usage map from the old one.  The actual save will be done\n+\t by store_one_arg. \n+\n+\t Another approach might be to try to reorder the argument\n+\t evaluations to avoid this conflicting stack usage.  */\n+\n+      if (needed > current_function_outgoing_args_size)\n+\tcurrent_function_outgoing_args_size = needed;\n+\n+#if defined(REG_PARM_STACK_SPACE) && ! defined(OUTGOING_REG_PARM_STACK_SPACE)\n+      /* Since we will be writing into the entire argument area, the\n+\t map must be allocated for its entire size, not just the part that\n+\t is the responsibility of the caller.  */\n+      needed += REG_PARM_STACK_SPACE (fndecl);\n+#endif\n+\n+#ifdef ARGS_GROW_DOWNWARD\n+      highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n+\t\t\t\t\t needed + 1);\n+#else\n+      highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use, needed);\n+#endif\n+      stack_usage_map = (char *) alloca (highest_outgoing_arg_in_use);\n+\n+      if (initial_highest_arg_in_use)\n+\tbcopy (initial_stack_usage_map, stack_usage_map,\n+\t       initial_highest_arg_in_use);\n+\n+      if (initial_highest_arg_in_use != highest_outgoing_arg_in_use)\n+\tbzero (&stack_usage_map[initial_highest_arg_in_use],\n+\t       highest_outgoing_arg_in_use - initial_highest_arg_in_use);\n+      needed = 0;\n+      /* No need to copy this virtual register; the space we're\n+\t using gets preallocated at the start of the function\n+\t so the stack pointer won't change here.  */\n+      argblock = virtual_outgoing_args_rtx;\n+#else /* not ACCUMULATE_OUTGOING_ARGS */\n+      if (inhibit_defer_pop == 0)\n+\t{\n+\t  /* Try to reuse some or all of the pending_stack_adjust\n+\t     to get this space.  Maybe we can avoid any pushing.  */\n+\t  if (needed > pending_stack_adjust)\n+\t    {\n+\t      needed -= pending_stack_adjust;\n+\t      pending_stack_adjust = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      pending_stack_adjust -= needed;\n+\t      needed = 0;\n+\t    }\n+\t}\n+      /* Special case this because overhead of `push_block' in this\n+\t case is non-trivial.  */\n+      if (needed == 0)\n+\targblock = virtual_outgoing_args_rtx;\n+      else\n+\targblock = push_block (gen_rtx (CONST_INT, VOIDmode, needed), 0, 0);\n+\n+      /* We only really need to call `copy_to_reg' in the case where push\n+\t insns are going to be used to pass ARGBLOCK to a function\n+\t call in ARGS.  In that case, the stack pointer changes value\n+\t from the allocation point to the call point, and hence\n+\t the value of VIRTUAL_OUTGOING_ARGS_RTX changes as well.\n+\t But might as well always do it.  */\n+      argblock = copy_to_reg (argblock);\n+#endif /* not ACCUMULATE_OUTGOING_ARGS */\n+    }\n+\n+  /* If we preallocated stack space, compute the address of each argument.\n+     We need not ensure it is a valid memory address here; it will be \n+     validized when it is used.  */\n+  if (argblock)\n+    {\n+      rtx arg_reg = argblock;\n+      int arg_offset = 0;\n+\n+      if (GET_CODE (argblock) == PLUS)\n+\targ_reg = XEXP (argblock, 0), arg_offset = INTVAL (XEXP (argblock, 1));\n+\n+      for (i = 0; i < num_actuals; i++)\n+\t{\n+\t  rtx offset = ARGS_SIZE_RTX (args[i].offset);\n+\t  rtx slot_offset = ARGS_SIZE_RTX (args[i].slot_offset);\n+\t  rtx addr;\n+\n+\t  /* Skip this parm if it will not be passed on the stack.  */\n+\t  if (! args[i].pass_on_stack && args[i].reg != 0)\n+\t    continue;\n+\n+\t  if (GET_CODE (offset) == CONST_INT)\n+\t    addr = plus_constant (arg_reg, INTVAL (offset));\n+\t  else\n+\t    addr = gen_rtx (PLUS, Pmode, arg_reg, offset);\n+\n+\t  addr = plus_constant (addr, arg_offset);\n+\t  args[i].stack\n+\t    = gen_rtx (MEM, TYPE_MODE (TREE_TYPE (args[i].tree_value)), addr);\n+\n+\t  if (GET_CODE (slot_offset) == CONST_INT)\n+\t    addr = plus_constant (arg_reg, INTVAL (slot_offset));\n+\t  else\n+\t    addr = gen_rtx (PLUS, Pmode, arg_reg, slot_offset);\n+\n+\t  addr = plus_constant (addr, arg_offset);\n+\t  args[i].stack_slot\n+\t    = gen_rtx (MEM, TYPE_MODE (TREE_TYPE (args[i].tree_value)), addr);\n+\t}\n+    }\n+\t\t\t\t\t       \n+#ifdef PUSH_ARGS_REVERSED\n+#ifdef STACK_BOUNDARY\n+  /* If we push args individually in reverse order, perform stack alignment\n+     before the first push (the last arg).  */\n+  if (argblock == 0)\n+    anti_adjust_stack (gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t(args_size.constant\n+\t\t\t\t - original_args_size.constant)));\n+#endif\n+#endif\n+\n+  /* Don't try to defer pops if preallocating, not even from the first arg,\n+     since ARGBLOCK probably refers to the SP.  */\n+  if (argblock)\n+    NO_DEFER_POP;\n+\n+  /* Get the function to call, in the form of RTL.  */\n+  if (fndecl)\n+    /* Get a SYMBOL_REF rtx for the function address.  */\n+    funexp = XEXP (DECL_RTL (fndecl), 0);\n+  else\n+    /* Generate an rtx (probably a pseudo-register) for the address.  */\n+    {\n+      funexp = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n+      free_temp_slots ();\t/* FUNEXP can't be BLKmode */\n+      emit_queue ();\n+    }\n+\n+  /* Figure out the register where the value, if any, will come back.  */\n+  valreg = 0;\n+  if (TYPE_MODE (TREE_TYPE (exp)) != VOIDmode\n+      && ! structure_value_addr)\n+    {\n+      if (pcc_struct_value)\n+\tvalreg = hard_function_value (build_pointer_type (TREE_TYPE (exp)),\n+\t\t\t\t      fndecl);\n+      else\n+\tvalreg = hard_function_value (TREE_TYPE (exp), fndecl);\n+    }\n+\n+  /* Precompute all register parameters.  It isn't safe to compute anything\n+     once we have started filling any specific hard regs. */\n+  reg_parm_seen = 0;\n+  for (i = 0; i < num_actuals; i++)\n+    if (args[i].reg != 0 && ! args[i].pass_on_stack)\n+      {\n+\treg_parm_seen = 1;\n+\n+\tif (args[i].value == 0)\n+\t  {\n+\t    args[i].value = expand_expr (args[i].tree_value, 0, VOIDmode, 0);\n+\t    preserve_temp_slots (args[i].value);\n+\t    free_temp_slots ();\n+\n+\t    /* ANSI doesn't require a sequence point here,\n+\t       but PCC has one, so this will avoid some problems.  */\n+\t    emit_queue ();\n+\t  }\n+      }\n+\n+#if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n+  /* The argument list is the property of the called routine and it\n+     may clobber it.  If the fixed area has been used for previous\n+     parameters, we must save and restore it.\n+\n+     Here we compute the boundary of the that needs to be saved, if any.  */\n+\n+  for (i = 0; i < REG_PARM_STACK_SPACE (fndecl); i++)\n+    {\n+      if (i >=  highest_outgoing_arg_in_use\n+\t  || stack_usage_map[i] == 0)\n+\tcontinue;\n+\n+      if (low_to_save == -1)\n+\tlow_to_save = i;\n+\n+      high_to_save = i;\n+    }\n+\n+  if (low_to_save >= 0)\n+    {\n+      int num_to_save = high_to_save - low_to_save + 1;\n+      enum machine_mode save_mode\n+\t= mode_for_size (num_to_save * BITS_PER_UNIT, MODE_INT, 1);\n+      rtx stack_area;\n+\n+      /* If we don't have the required alignment, must do this in BLKmode.  */\n+      if ((low_to_save & (MIN (GET_MODE_SIZE (save_mode),\n+\t\t\t       BIGGEST_ALIGNMENT / UNITS_PER_WORD) - 1)))\n+\tsave_mode = BLKmode;\n+\n+      stack_area = gen_rtx (MEM, save_mode,\n+\t\t\t    memory_address (save_mode,\n+\t\t\t\t\t    plus_constant (argblock,\n+\t\t\t\t\t\t\t   low_to_save)));\n+      if (save_mode == BLKmode)\n+\t{\n+\t  save_area = assign_stack_temp (BLKmode, num_to_save, 1);\n+\t  emit_block_move (validize_mem (save_area), stack_area,\n+\t\t\t   gen_rtx (CONST_INT, VOIDmode, num_to_save),\n+\t\t\t   PARM_BOUNDARY / BITS_PER_UNIT);\n+\t}\n+      else\n+\t{\n+\t  save_area = gen_reg_rtx (save_mode);\n+\t  emit_move_insn (save_area, stack_area);\n+\t}\n+    }\n+#endif\n+\t  \n+\n+  /* Now store (and compute if necessary) all non-register parms.\n+     These come before register parms, since they can require block-moves,\n+     which could clobber the registers used for register parms.\n+     Parms which have partial registers are not stored here,\n+     but we do preallocate space here if they want that.  */\n+\n+  for (i = 0; i < num_actuals; i++)\n+    if (args[i].reg == 0 || args[i].pass_on_stack)\n+      store_one_arg (&args[i], argblock, may_be_alloca,\n+\t\t     args_size.var != 0, fndecl);\n+\n+  /* Now store any partially-in-registers parm.\n+     This is the last place a block-move can happen.  */\n+  if (reg_parm_seen)\n+    for (i = 0; i < num_actuals; i++)\n+      if (args[i].partial != 0 && ! args[i].pass_on_stack)\n+\tstore_one_arg (&args[i], argblock, may_be_alloca,\n+\t\t       args_size.var != 0, fndecl);\n+\n+#ifndef PUSH_ARGS_REVERSED\n+#ifdef STACK_BOUNDARY\n+  /* If we pushed args in forward order, perform stack alignment\n+     after pushing the last arg.  */\n+  if (argblock == 0)\n+    anti_adjust_stack (gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t(args_size.constant\n+\t\t\t\t - original_args_size.constant)));\n+#endif\n+#endif\n+\n+  /* Pass the function the address in which to return a structure value.  */\n+  if (structure_value_addr && ! structure_value_addr_parm)\n+    {\n+      emit_move_insn (struct_value_rtx,\n+\t\t      force_reg (Pmode,\n+\t\t\t\t force_operand (structure_value_addr, 0)));\n+      if (GET_CODE (struct_value_rtx) == REG)\n+\t{\n+\t  push_to_sequence (use_insns);\n+\t  emit_insn (gen_rtx (USE, VOIDmode, struct_value_rtx));\n+\t  use_insns = get_insns ();\n+\t  end_sequence ();\n+\t}\n+    }\n+\n+  /* Now do the register loads required for any wholly-register parms or any\n+     parms which are passed both on the stack and in a register.  Their\n+     expressions were already evaluated. \n+\n+     Mark all register-parms as living through the call, putting these USE\n+     insns in a list headed by USE_INSNS.  */\n+\n+  for (i = 0; i < num_actuals; i++)\n+    {\n+      rtx list = args[i].reg;\n+      int partial = args[i].partial;\n+\n+      while (list)\n+\t{\n+\t  rtx reg;\n+\t  int nregs;\n+\n+\t  /* Process each register that needs to get this arg.  */\n+\t  if (GET_CODE (list) == EXPR_LIST)\n+\t    reg = XEXP (list, 0), list = XEXP (list, 1);\n+\t  else\n+\t    reg = list, list = 0;\n+\n+\t  /* Set to non-zero if must move a word at a time, even if just one\n+\t     word (e.g, partial == 1 && mode == DFmode).  Set to zero if\n+\t     we just use a normal move insn.  */\n+\t  nregs = (partial ? partial\n+\t\t   : (TYPE_MODE (TREE_TYPE (args[i].tree_value)) == BLKmode\n+\t\t      ? ((int_size_in_bytes (TREE_TYPE (args[i].tree_value))\n+\t\t\t  + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n+\t\t      : 0));\n+\n+\t  /* If simple case, just do move.  If normal partial, store_one_arg\n+\t     has already loaded the register for us.  In all other cases,\n+\t     load the register(s) from memory.  */\n+\n+\t  if (nregs == 0)\n+\t    emit_move_insn (reg, args[i].value);\n+\t  else if (args[i].partial == 0 || args[i].pass_on_stack)\n+\t    move_block_to_reg (REGNO (reg),\n+\t\t\t       validize_mem (args[i].value), nregs,\n+\t\t\t       TYPE_MODE (TREE_TYPE (args[i].tree_value)));\n+\t\n+\t  push_to_sequence (use_insns);\n+\t  if (nregs == 0)\n+\t    emit_insn (gen_rtx (USE, VOIDmode, reg));\n+\t  else\n+\t    use_regs (REGNO (reg), nregs);\n+\t  use_insns = get_insns ();\n+\t  end_sequence ();\n+\n+\t  /* PARTIAL referred only to the first register, so clear it for the\n+\t     next time.  */\n+\t  partial = 0;\n+\t}\n+    }\n+\n+  /* Perform postincrements before actually calling the function.  */\n+  emit_queue ();\n+\n+  /* All arguments and registers used for the call must be set up by now!  */\n+\n+  funexp = prepare_call_address (funexp, fndecl, &use_insns);\n+\n+  /* Generate the actual call instruction.  */\n+  emit_call_1 (funexp, funtype, args_size.constant, struct_value_size,\n+\t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n+\t       valreg, old_inhibit_defer_pop, use_insns, is_const);\n+\n+  /* If call is cse'able, make appropriate pair of reg-notes around it.\n+     Test valreg so we don't crash; may safely ignore `const'\n+     if return type is void.  */\n+  if (is_const && valreg != 0)\n+    {\n+      rtx note = 0;\n+      rtx temp = gen_reg_rtx (GET_MODE (valreg));\n+      rtx insns;\n+\n+      /* Construct an \"equal form\" for the value which mentions all the\n+\t arguments in order as well as the function name.  */\n+#ifdef PUSH_ARGS_REVERSED\n+      for (i = 0; i < num_actuals; i++)\n+\tnote = gen_rtx (EXPR_LIST, VOIDmode, args[i].initial_value, note);\n+#else\n+      for (i = num_actuals - 1; i >= 0; i--)\n+\tnote = gen_rtx (EXPR_LIST, VOIDmode, args[i].initial_value, note);\n+#endif\n+      note = gen_rtx (EXPR_LIST, VOIDmode, funexp, note);\n+\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      emit_libcall_block (insns, temp, valreg, note);\n+\n+      valreg = temp;\n+    }\n+\n+  /* For calls to `setjmp', etc., inform flow.c it should complain\n+     if nonvolatile values are live.  */\n+\n+  if (returns_twice)\n+    {\n+      emit_note (name, NOTE_INSN_SETJMP);\n+      current_function_calls_setjmp = 1;\n+    }\n+\n+  if (is_longjmp)\n+    current_function_calls_longjmp = 1;\n+\n+  /* Notice functions that cannot return.\n+     If optimizing, insns emitted below will be dead.\n+     If not optimizing, they will exist, which is useful\n+     if the user uses the `return' command in the debugger.  */\n+\n+  if (is_volatile || is_longjmp)\n+    emit_barrier ();\n+\n+  /* For calls to __builtin_new, note that it can never return 0.\n+     This is because a new handler will be called, and 0 it not\n+     among the numbers it is supposed to return.  */\n+#if 0\n+  if (is_builtin_new)\n+    emit_note (name, NOTE_INSN_BUILTIN_NEW);\n+#endif\n+\n+  /* If value type not void, return an rtx for the value.  */\n+\n+  /* If there are cleanups to be called, don't use a hard reg as target.  */\n+  if (cleanups_this_call != old_cleanups\n+      && target && REG_P (target)\n+      && REGNO (target) < FIRST_PSEUDO_REGISTER)\n+    target = 0;\n+\n+  if (TYPE_MODE (TREE_TYPE (exp)) == VOIDmode\n+      || ignore)\n+    {\n+      target = const0_rtx;\n+    }\n+  else if (structure_value_addr)\n+    {\n+      if (target == 0 || GET_CODE (target) != MEM)\n+\ttarget = gen_rtx (MEM, TYPE_MODE (TREE_TYPE (exp)),\n+\t\t\t  memory_address (TYPE_MODE (TREE_TYPE (exp)),\n+\t\t\t\t\t  structure_value_addr));\n+    }\n+  else if (pcc_struct_value)\n+    {\n+      if (target == 0)\n+\ttarget = gen_rtx (MEM, TYPE_MODE (TREE_TYPE (exp)),\n+\t\t\t  copy_to_reg (valreg));\n+      else if (TYPE_MODE (TREE_TYPE (exp)) != BLKmode)\n+\temit_move_insn (target, gen_rtx (MEM, TYPE_MODE (TREE_TYPE (exp)),\n+\t\t\t\t\t copy_to_reg (valreg)));\n+      else\n+\temit_block_move (target, gen_rtx (MEM, BLKmode, copy_to_reg (valreg)),\n+\t\t\t expr_size (exp),\n+\t\t\t TYPE_ALIGN (TREE_TYPE (exp)) / BITS_PER_UNIT);\n+    }\n+  else if (target && GET_MODE (target) == TYPE_MODE (TREE_TYPE (exp)))\n+    /* TARGET and VALREG cannot be equal at this point because the latter\n+       would not have REG_FUNCTION_VALUE_P true, while the former would if\n+       it were referring to the same register.\n+\n+       If they refer to the same register, this move will be a no-op, except\n+       when function inlining is being done.  */\n+    emit_move_insn (target, valreg);\n+  else\n+    target = copy_to_reg (valreg);\n+\n+  /* Perform all cleanups needed for the arguments of this call\n+     (i.e. destructors in C++).  */\n+  expand_cleanups_to (old_cleanups);\n+\n+  /* If size of args is variable, restore saved stack-pointer value.  */\n+\n+  if (old_stack_level)\n+    {\n+      emit_move_insn (stack_pointer_rtx, old_stack_level);\n+      pending_stack_adjust = old_pending_adj;\n+    }\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+  else\n+    {\n+#ifdef REG_PARM_STACK_SPACE\n+      if (save_area)\n+\t{\n+\t  enum machine_mode save_mode = GET_MODE (save_area);\n+\t  rtx stack_area\n+\t    = gen_rtx (MEM, save_mode,\n+\t\t       memory_address (save_mode,\n+\t\t\t\t       plus_constant (argblock, low_to_save)));\n+\n+\t  if (save_mode != BLKmode)\n+\t    emit_move_insn (stack_area, save_area);\n+\t  else\n+\t    emit_block_move (stack_area, validize_mem (save_area),\n+\t\t\t     gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t      high_to_save - low_to_save + 1,\n+\t\t\t\t      PARM_BOUNDARY / BITS_PER_UNIT));\n+\t}\n+#endif\n+\t  \n+      /* If we saved any argument areas, restore them.  */\n+      for (i = 0; i < num_actuals; i++)\n+\tif (args[i].save_area)\n+\t  {\n+\t    enum machine_mode save_mode = GET_MODE (args[i].save_area);\n+\t    rtx stack_area\n+\t      = gen_rtx (MEM, save_mode,\n+\t\t\t memory_address (save_mode,\n+\t\t\t\t\t XEXP (args[i].stack_slot, 0)));\n+\n+\t    if (save_mode != BLKmode)\n+\t      emit_move_insn (stack_area, args[i].save_area);\n+\t    else\n+\t      emit_block_move (stack_area, validize_mem (args[i].save_area),\n+\t\t\t       gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t\targs[i].size.constant),\n+\t\t\t       PARM_BOUNDARY / BITS_PER_UNIT);\n+\t  }\n+\n+      highest_outgoing_arg_in_use = initial_highest_arg_in_use;\n+      stack_usage_map = initial_stack_usage_map;\n+    }\n+#endif\n+\n+  /* If this was alloca, record the new stack level for nonlocal gotos.  */\n+  if (may_be_alloca && nonlocal_goto_stack_level != 0)\n+    emit_move_insn (nonlocal_goto_stack_level, stack_pointer_rtx);\n+\n+  pop_temp_slots ();\n+\n+  return target;\n+}\n+\f\n+#if 0\n+/* Return an rtx which represents a suitable home on the stack\n+   given TYPE, the type of the argument looking for a home.\n+   This is called only for BLKmode arguments.\n+\n+   SIZE is the size needed for this target.\n+   ARGS_ADDR is the address of the bottom of the argument block for this call.\n+   OFFSET describes this parameter's offset into ARGS_ADDR.  It is meaningless\n+   if this machine uses push insns.  */\n+\n+static rtx\n+target_for_arg (type, size, args_addr, offset)\n+     tree type;\n+     rtx size;\n+     rtx args_addr;\n+     struct args_size offset;\n+{\n+  rtx target;\n+  rtx offset_rtx = ARGS_SIZE_RTX (offset);\n+\n+  /* We do not call memory_address if possible,\n+     because we want to address as close to the stack\n+     as possible.  For non-variable sized arguments,\n+     this will be stack-pointer relative addressing.  */\n+  if (GET_CODE (offset_rtx) == CONST_INT)\n+    target = plus_constant (args_addr, INTVAL (offset_rtx));\n+  else\n+    {\n+      /* I have no idea how to guarantee that this\n+\t will work in the presence of register parameters.  */\n+      target = gen_rtx (PLUS, Pmode, args_addr, offset_rtx);\n+      target = memory_address (QImode, target);\n+    }\n+\n+  return gen_rtx (MEM, BLKmode, target);\n+}\n+#endif\n+\f\n+/* Store a single argument for a function call\n+   into the register or memory area where it must be passed.\n+   *ARG describes the argument value and where to pass it.\n+\n+   ARGBLOCK is the address of the stack-block for all the arguments,\n+   or 0 on a machine where arguemnts are pushed individually.\n+\n+   MAY_BE_ALLOCA nonzero says this could be a call to `alloca'\n+   so must be careful about how the stack is used. \n+\n+   VARIABLE_SIZE nonzero says that this was a variable-sized outgoing\n+   argument stack.  This is used if ACCUMULATE_OUTGOING_ARGS to indicate\n+   that we need not worry about saving and restoring the stack.\n+\n+   FNDECL is the declaration of the function we are calling.  */\n+\n+static void\n+store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl)\n+     struct arg_data *arg;\n+     rtx argblock;\n+     int may_be_alloca;\n+     int variable_size;\n+     tree fndecl;\n+{\n+  register tree pval = arg->tree_value;\n+  rtx reg = 0;\n+  int partial = 0;\n+  int used = 0;\n+  int i, lower_bound, upper_bound;\n+\n+  if (TREE_CODE (pval) == ERROR_MARK)\n+    return;\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+  /* If this is being stored into a pre-allocated, fixed-size, stack area,\n+     save any previous data at that location.  */\n+  if (argblock && ! variable_size && arg->stack)\n+    {\n+#ifdef ARGS_GROW_DOWNWARD\n+      /* stack_slot is negative, but we want to index stack_usage_map */\n+      /* with positive values. */\n+      if (GET_CODE (XEXP (arg->stack_slot, 0)) == PLUS)\n+\tupper_bound = -INTVAL (XEXP (XEXP (arg->stack_slot, 0), 1)) + 1;\n+      else\n+\tabort ();\n+\n+      lower_bound = upper_bound - arg->size.constant;\n+#else\n+      if (GET_CODE (XEXP (arg->stack_slot, 0)) == PLUS)\n+\tlower_bound = INTVAL (XEXP (XEXP (arg->stack_slot, 0), 1));\n+      else\n+\tlower_bound = 0;\n+\n+      upper_bound = lower_bound + arg->size.constant;\n+#endif\n+\n+      for (i = lower_bound; i < upper_bound; i++)\n+\tif (stack_usage_map[i]\n+#ifdef REG_PARM_STACK_SPACE\n+\t    /* Don't store things in the fixed argument area at this point;\n+\t       it has already been saved.  */\n+\t    && i > REG_PARM_STACK_SPACE (fndecl)\n+#endif\n+\t    )\n+\t  break;\n+\n+      if (i != upper_bound)\n+\t{\n+\t  /* We need to make a save area.  See what mode we can make it.  */\n+\t  enum machine_mode save_mode\n+\t    = mode_for_size (arg->size.constant * BITS_PER_UNIT, MODE_INT, 1);\n+\t  rtx stack_area\n+\t    = gen_rtx (MEM, save_mode,\n+\t\t       memory_address (save_mode, XEXP (arg->stack_slot, 0)));\n+\n+\t  if (save_mode == BLKmode)\n+\t    {\n+\t      arg->save_area = assign_stack_temp (BLKmode,\n+\t\t\t\t\t\t  arg->size.constant, 1);\n+\t      emit_block_move (validize_mem (arg->save_area), stack_area,\n+\t\t\t       gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t\targ->size.constant),\n+\t\t\t       PARM_BOUNDARY / BITS_PER_UNIT);\n+\t    }\n+\t  else\n+\t    {\n+\t      arg->save_area = gen_reg_rtx (save_mode);\n+\t      emit_move_insn (arg->save_area, stack_area);\n+\t    }\n+\t}\n+    }\n+#endif\n+\n+  /* If this isn't going to be placed on both the stack and in registers,\n+     set up the register and number of words.  */\n+  if (! arg->pass_on_stack)\n+    reg = arg->reg, partial = arg->partial;\n+\n+  if (reg != 0 && partial == 0)\n+    /* Being passed entirely in a register.  We shouldn't be called in\n+       this case.   */\n+    abort ();\n+\n+  /* If this is being partially passed in a register, but multiple locations\n+     are specified, we assume that the one partially used is the one that is\n+     listed first.  */\n+  if (reg && GET_CODE (reg) == EXPR_LIST)\n+    reg = XEXP (reg, 0);\n+\n+  /* If this is being passes partially in a register, we can't evaluate\n+     it directly into its stack slot.  Otherwise, we can.  */\n+  if (arg->value == 0)\n+    arg->value = expand_expr (pval, partial ? 0 : arg->stack, VOIDmode, 0);\n+\n+  /* Don't allow anything left on stack from computation\n+     of argument to alloca.  */\n+  if (may_be_alloca)\n+    do_pending_stack_adjust ();\n+\n+  if (arg->value == arg->stack)\n+    /* If the value is already in the stack slot, we are done.  */\n+    ;\n+  else if (TYPE_MODE (TREE_TYPE (pval)) != BLKmode)\n+    {\n+      register int size;\n+\n+      /* Argument is a scalar, not entirely passed in registers.\n+\t (If part is passed in registers, arg->partial says how much\n+\t and emit_push_insn will take care of putting it there.)\n+\t \n+\t Push it, and if its size is less than the\n+\t amount of space allocated to it,\n+\t also bump stack pointer by the additional space.\n+\t Note that in C the default argument promotions\n+\t will prevent such mismatches.  */\n+\n+      size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (pval)));\n+      /* Compute how much space the push instruction will push.\n+\t On many machines, pushing a byte will advance the stack\n+\t pointer by a halfword.  */\n+#ifdef PUSH_ROUNDING\n+      size = PUSH_ROUNDING (size);\n+#endif\n+      used = size;\n+\n+      /* Compute how much space the argument should get:\n+\t round up to a multiple of the alignment for arguments.  */\n+      if (none != FUNCTION_ARG_PADDING (TYPE_MODE (TREE_TYPE (pval)),\n+\t\t\t\t\tTREE_TYPE (pval)))\n+\tused = (((size + PARM_BOUNDARY / BITS_PER_UNIT - 1)\n+\t\t / (PARM_BOUNDARY / BITS_PER_UNIT))\n+\t\t* (PARM_BOUNDARY / BITS_PER_UNIT));\n+\n+      /* This isn't already where we want it on the stack, so put it there.\n+\t This can either be done with push or copy insns.  */\n+      emit_push_insn (arg->value, TYPE_MODE (TREE_TYPE (pval)),\n+\t\t      TREE_TYPE (pval), 0, 0, partial, reg,\n+\t\t      used - size, argblock, ARGS_SIZE_RTX (arg->offset));\n+    }\n+  else\n+    {\n+      /* BLKmode, at least partly to be pushed.  */\n+\n+      register int excess;\n+      rtx size_rtx;\n+\n+      /* Pushing a nonscalar.\n+\t If part is passed in registers, PARTIAL says how much\n+\t and emit_push_insn will take care of putting it there.  */\n+\n+      /* Round its size up to a multiple\n+\t of the allocation unit for arguments.  */\n+\n+      if (arg->size.var != 0)\n+\t{\n+\t  excess = 0;\n+\t  size_rtx = ARGS_SIZE_RTX (arg->size);\n+\t}\n+      else\n+\t{\n+\t  register tree size = size_in_bytes (TREE_TYPE (pval));\n+\t  /* PUSH_ROUNDING has no effect on us, because\n+\t     emit_push_insn for BLKmode is careful to avoid it.  */\n+\t  excess = (arg->size.constant - TREE_INT_CST_LOW (size)\n+\t\t    + partial * UNITS_PER_WORD);\n+\t  size_rtx = expand_expr (size, 0, VOIDmode, 0);\n+\t}\n+\n+      emit_push_insn (arg->value, TYPE_MODE (TREE_TYPE (pval)),\n+\t\t      TREE_TYPE (pval), size_rtx,\n+\t\t      TYPE_ALIGN (TREE_TYPE (pval)) / BITS_PER_UNIT, partial,\n+\t\t      reg, excess, argblock, ARGS_SIZE_RTX (arg->offset));\n+    }\n+\n+\n+  /* Unless this is a partially-in-register argument, the argument is now\n+     in the stack. \n+\n+     ??? Note that this can change arg->value from arg->stack to\n+     arg->stack_slot and it matters when they are not the same.\n+     It isn't totally clear that this is correct in all cases.  */\n+  if (partial == 0)\n+    arg->value = arg->stack_slot;\n+\n+  /* Once we have pushed something, pops can't safely\n+     be deferred during the rest of the arguments.  */\n+  NO_DEFER_POP;\n+\n+  /* ANSI doesn't require a sequence point here,\n+     but PCC has one, so this will avoid some problems.  */\n+  emit_queue ();\n+\n+  /* Free any temporary slots made in processing this argument.  */\n+  free_temp_slots ();\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+  /* Now mark the segment we just used.  */\n+  if (argblock && ! variable_size && arg->stack)\n+    for (i = lower_bound; i < upper_bound; i++)\n+      stack_usage_map[i] = 1;\n+#endif\n+}"}]}