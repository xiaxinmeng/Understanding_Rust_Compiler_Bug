{"sha": "44799f87c36be1a05c9b314e00a767c43b3c3190", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ3OTlmODdjMzZiZTFhMDVjOWIzMTRlMDBhNzY3YzQzYjNjMzE5MA==", "commit": {"author": {"name": "Ilya Verbin", "email": "ilya.verbin@intel.com", "date": "2015-09-29T14:11:16Z"}, "committer": {"name": "Ilya Verbin", "email": "iverbin@gcc.gnu.org", "date": "2015-09-29T14:11:16Z"}, "message": "libgomp-plugin-intelmic.cpp (OFFLOAD_ACTIVE_WAIT_ENV): New define.\n\nliboffloadmic/\n\t* plugin/libgomp-plugin-intelmic.cpp (OFFLOAD_ACTIVE_WAIT_ENV): New\n\tdefine.\n\t(init): Set OFFLOAD_ACTIVE_WAIT env var to 0, if it is not set.\n\t* runtime/emulator/coi_common.h (PIPE_HOST_PATH): Replace with ...\n\t(PIPE_HOST2TGT_NAME): ... this.\n\t(PIPE_TARGET_PATH): Replace with ...\n\t(PIPE_TGT2HOST_NAME): ... this.\n\t(MALLOCN): New define.\n\t(READN): Likewise.\n\t(WRITEN): Likewise.\n\t(enum cmd_t): Replace CMD_RUN_FUNCTION with CMD_PIPELINE_RUN_FUNCTION.\n\tAdd CMD_PIPELINE_CREATE, CMD_PIPELINE_DESTROY.\n\t* runtime/emulator/coi_device.cpp (engine_dir): New static variable.\n\t(pipeline_thread_routine): New static function.\n\t(COIProcessWaitForShutdown): Use global engine_dir instead of mic_dir.\n\tRename pipe_host and pipe_target to pipe_host2tgt and pipe_tgt2host.\n\tIf cmd is CMD_PIPELINE_CREATE, create a new thread for the pipeline.\n\tRemove cmd == CMD_RUN_FUNCTION case.\n\t* runtime/emulator/coi_device.h (COIERRORN): New define.\n\t* runtime/emulator/coi_host.cpp: Include set, map, queue.\n\tReplace typedefs with enums and structs.\n\t(struct Function): Remove name, add num_buffers, bufs_size,\n\tbufs_data_target, misc_data_len, misc_data, return_value_len,\n\treturn_value, completion_event.\n\t(struct Callback): New.\n\t(struct Process): Remove pipeline.  Add pipe_host2tgt and pipe_tgt2host.\n\t(struct Pipeline): Remove pipe_host and pipe_target.  Add thread,\n\tdestroy, is_destroyed, pipe_host2tgt_path, pipe_tgt2host_path,\n\tpipe_host2tgt, pipe_tgt2host, queue, process.\n\t(max_pipeline_num): New static variable.\n\t(pipelines): Likewise.\n\t(max_event_num): Likewise.\n\t(non_signalled_events): Likewise.\n\t(errored_events): Likewise.\n\t(callbacks): Likewise.\n\t(cleanup): Do not check tmp_dirs before free.\n\t(start_critical_section): New static function.\n\t(finish_critical_section): Likewise.\n\t(pipeline_is_destroyed): Likewise.\n\t(maybe_invoke_callback): Likewise.\n\t(signal_event): Likewise.\n\t(get_event_result): Likewise.\n\t(COIBufferCopy): Rename arguments according to headers.  Add asserts.\n\tUse process' main pipes, instead of pipeline's pipes.  Signal completion\n\tevent.\n\t(COIBufferCreate): Rename arguments according to headers.  Add asserts.\n\tUse process' main pipes, instead of pipeline's pipes.\n\t(COIBufferCreateFromMemory): Rename arguments according to headers.\n\tAdd asserts.\n\t(COIBufferDestroy): Rename arguments according to headers.  Add asserts.\n\tUse process' main pipes, instead of pipeline's pipes.\n\t(COIBufferGetSinkAddress): Rename arguments according to headers.\n\tAdd asserts.\n\t(COIBufferMap): Rename arguments according to headers.  Add asserts.\n\tSignal completion event.\n\t(COIBufferRead): Likewise.\n\t(COIBufferSetState): Likewise.\n\t(COIBufferUnmap): Likewise.\n\t(COIBufferWrite): Likewise.\n\t(COIEngineGetCount): Add assert.\n\t(COIEngineGetHandle): Rename arguments according to headers.\n\tAdd assert.\n\t(COIEventWait): Rename arguments according to headers.  Add asserts.\n\tImplement waiting for events with zero or infinite timeout.\n\t(COIEventRegisterCallback): New function.\n\t(pipeline_thread_routine): New static function.\n\t(COIPipelineCreate): Create a new thread for the pipeline.\n\t(COIPipelineDestroy): Exit pipeline thread.\n\t(COIPipelineRunFunction): Add the function into pipeline's queue,\n\tinstead running it here.  Wait for it's completion in case of\n\tsynchronous execution.\n\t(COIProcessCreateFromMemory): Rename arguments according to headers.\n\tAdd asserts.  Create process' main pipes, instead of pipeline's pipes.\n\t(COIProcessDestroy): Rename arguments according to headers.\n\tAdd asserts.  Destroy all undestroyed pipelines.\n\t(COIProcessGetFunctionHandles): Rename arguments according to headers.\n\tAdd asserts.  Use process' main pipes, instead of pipeline's pipes.\n\tRemove useless function names.\n\t(COIProcessLoadLibraryFromMemory): Add asserts.  Use process' main\n\tpipes, instead of pipeline's pipes.\n\t(COIProcessUnloadLibrary): Likewise.\n\t(COIEngineGetInfo): Add assert.\n\t* runtime/emulator/coi_host.h (COIERRORN): New define.\n\nFrom-SVN: r228248", "tree": {"sha": "df85e4252fe312b0fb210b230a2922d7b3305f91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df85e4252fe312b0fb210b230a2922d7b3305f91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44799f87c36be1a05c9b314e00a767c43b3c3190", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44799f87c36be1a05c9b314e00a767c43b3c3190", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44799f87c36be1a05c9b314e00a767c43b3c3190", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44799f87c36be1a05c9b314e00a767c43b3c3190/comments", "author": null, "committer": null, "parents": [{"sha": "b59882293f2283335b565047de33c8fd8146686c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b59882293f2283335b565047de33c8fd8146686c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b59882293f2283335b565047de33c8fd8146686c"}], "stats": {"total": 1737, "additions": 1126, "deletions": 611}, "files": [{"sha": "d974aa3098470f81f6c089cbd652248b9f17820e", "filename": "liboffloadmic/ChangeLog", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44799f87c36be1a05c9b314e00a767c43b3c3190/liboffloadmic%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44799f87c36be1a05c9b314e00a767c43b3c3190/liboffloadmic%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FChangeLog?ref=44799f87c36be1a05c9b314e00a767c43b3c3190", "patch": "@@ -1,3 +1,89 @@\n+2015-09-29  Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* plugin/libgomp-plugin-intelmic.cpp (OFFLOAD_ACTIVE_WAIT_ENV): New\n+\tdefine.\n+\t(init): Set OFFLOAD_ACTIVE_WAIT env var to 0, if it is not set.\n+\t* runtime/emulator/coi_common.h (PIPE_HOST_PATH): Replace with ...\n+\t(PIPE_HOST2TGT_NAME): ... this.\n+\t(PIPE_TARGET_PATH): Replace with ...\n+\t(PIPE_TGT2HOST_NAME): ... this.\n+\t(MALLOCN): New define.\n+\t(READN): Likewise.\n+\t(WRITEN): Likewise.\n+\t(enum cmd_t): Replace CMD_RUN_FUNCTION with CMD_PIPELINE_RUN_FUNCTION.\n+\tAdd CMD_PIPELINE_CREATE, CMD_PIPELINE_DESTROY.\n+\t* runtime/emulator/coi_device.cpp (engine_dir): New static variable.\n+\t(pipeline_thread_routine): New static function.\n+\t(COIProcessWaitForShutdown): Use global engine_dir instead of mic_dir.\n+\tRename pipe_host and pipe_target to pipe_host2tgt and pipe_tgt2host.\n+\tIf cmd is CMD_PIPELINE_CREATE, create a new thread for the pipeline.\n+\tRemove cmd == CMD_RUN_FUNCTION case.\n+\t* runtime/emulator/coi_device.h (COIERRORN): New define.\n+\t* runtime/emulator/coi_host.cpp: Include set, map, queue.\n+\tReplace typedefs with enums and structs.\n+\t(struct Function): Remove name, add num_buffers, bufs_size,\n+\tbufs_data_target, misc_data_len, misc_data, return_value_len,\n+\treturn_value, completion_event.\n+\t(struct Callback): New.\n+\t(struct Process): Remove pipeline.  Add pipe_host2tgt and pipe_tgt2host.\n+\t(struct Pipeline): Remove pipe_host and pipe_target.  Add thread,\n+\tdestroy, is_destroyed, pipe_host2tgt_path, pipe_tgt2host_path,\n+\tpipe_host2tgt, pipe_tgt2host, queue, process.\n+\t(max_pipeline_num): New static variable.\n+\t(pipelines): Likewise.\n+\t(max_event_num): Likewise.\n+\t(non_signalled_events): Likewise.\n+\t(errored_events): Likewise.\n+\t(callbacks): Likewise.\n+\t(cleanup): Do not check tmp_dirs before free.\n+\t(start_critical_section): New static function.\n+\t(finish_critical_section): Likewise.\n+\t(pipeline_is_destroyed): Likewise.\n+\t(maybe_invoke_callback): Likewise.\n+\t(signal_event): Likewise.\n+\t(get_event_result): Likewise.\n+\t(COIBufferCopy): Rename arguments according to headers.  Add asserts.\n+\tUse process' main pipes, instead of pipeline's pipes.  Signal completion\n+\tevent.\n+\t(COIBufferCreate): Rename arguments according to headers.  Add asserts.\n+\tUse process' main pipes, instead of pipeline's pipes.\n+\t(COIBufferCreateFromMemory): Rename arguments according to headers.\n+\tAdd asserts.\n+\t(COIBufferDestroy): Rename arguments according to headers.  Add asserts.\n+\tUse process' main pipes, instead of pipeline's pipes.\n+\t(COIBufferGetSinkAddress): Rename arguments according to headers.\n+\tAdd asserts.\n+\t(COIBufferMap): Rename arguments according to headers.  Add asserts.\n+\tSignal completion event.\n+\t(COIBufferRead): Likewise.\n+\t(COIBufferSetState): Likewise.\n+\t(COIBufferUnmap): Likewise.\n+\t(COIBufferWrite): Likewise.\n+\t(COIEngineGetCount): Add assert.\n+\t(COIEngineGetHandle): Rename arguments according to headers.\n+\tAdd assert.\n+\t(COIEventWait): Rename arguments according to headers.  Add asserts.\n+\tImplement waiting for events with zero or infinite timeout.\n+\t(COIEventRegisterCallback): New function.\n+\t(pipeline_thread_routine): New static function.\n+\t(COIPipelineCreate): Create a new thread for the pipeline.\n+\t(COIPipelineDestroy): Exit pipeline thread.\n+\t(COIPipelineRunFunction): Add the function into pipeline's queue,\n+\tinstead running it here.  Wait for it's completion in case of\n+\tsynchronous execution.\n+\t(COIProcessCreateFromMemory): Rename arguments according to headers.\n+\tAdd asserts.  Create process' main pipes, instead of pipeline's pipes.\n+\t(COIProcessDestroy): Rename arguments according to headers.\n+\tAdd asserts.  Destroy all undestroyed pipelines.\n+\t(COIProcessGetFunctionHandles): Rename arguments according to headers.\n+\tAdd asserts.  Use process' main pipes, instead of pipeline's pipes.\n+\tRemove useless function names.\n+\t(COIProcessLoadLibraryFromMemory): Add asserts.  Use process' main\n+\tpipes, instead of pipeline's pipes.\n+\t(COIProcessUnloadLibrary): Likewise.\n+\t(COIEngineGetInfo): Add assert.\n+\t* runtime/emulator/coi_host.h (COIERRORN): New define.\n+\n 2015-09-28  Ilya Verbin  <ilya.verbin@intel.com>\n \n \tPR other/67652"}, {"sha": "9ebd070e0f5ea55fbe43e2308d6122a3f0c19750", "filename": "liboffloadmic/plugin/libgomp-plugin-intelmic.cpp", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44799f87c36be1a05c9b314e00a767c43b3c3190/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44799f87c36be1a05c9b314e00a767c43b3c3190/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp?ref=44799f87c36be1a05c9b314e00a767c43b3c3190", "patch": "@@ -42,6 +42,7 @@\n \n #define LD_LIBRARY_PATH_ENV\t\"LD_LIBRARY_PATH\"\n #define MIC_LD_LIBRARY_PATH_ENV\t\"MIC_LD_LIBRARY_PATH\"\n+#define OFFLOAD_ACTIVE_WAIT_ENV\t\"OFFLOAD_ACTIVE_WAIT\"\n \n #ifdef DEBUG\n #define TRACE(...)\t\t\t\t\t    \\\n@@ -115,18 +116,23 @@ static VarDesc vd_tgt2host = {\n };\n \n \n-/* Add path specified in LD_LIBRARY_PATH to MIC_LD_LIBRARY_PATH, which is\n-   required by liboffloadmic.  */\n __attribute__((constructor))\n static void\n init (void)\n {\n   const char *ld_lib_path = getenv (LD_LIBRARY_PATH_ENV);\n   const char *mic_lib_path = getenv (MIC_LD_LIBRARY_PATH_ENV);\n+  const char *active_wait = getenv (OFFLOAD_ACTIVE_WAIT_ENV);\n+\n+  /* Disable active wait by default to avoid useless CPU usage.  */\n+  if (!active_wait)\n+    setenv (OFFLOAD_ACTIVE_WAIT_ENV, \"0\", 0);\n \n   if (!ld_lib_path)\n     goto out;\n \n+  /* Add path specified in LD_LIBRARY_PATH to MIC_LD_LIBRARY_PATH, which is\n+     required by liboffloadmic.  */\n   if (!mic_lib_path)\n     setenv (MIC_LD_LIBRARY_PATH_ENV, ld_lib_path, 1);\n   else"}, {"sha": "63af984ca84959c6733678b004977a4c1f099f51", "filename": "liboffloadmic/runtime/emulator/coi_common.h", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44799f87c36be1a05c9b314e00a767c43b3c3190/liboffloadmic%2Fruntime%2Femulator%2Fcoi_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44799f87c36be1a05c9b314e00a767c43b3c3190/liboffloadmic%2Fruntime%2Femulator%2Fcoi_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_common.h?ref=44799f87c36be1a05c9b314e00a767c43b3c3190", "patch": "@@ -72,11 +72,11 @@\n /* Relative path to directory with pipes.  */\n #define PIPES_PATH\t\t  \"/pipes\"\n \n-/* Relative path to target-to-host pipe.  */\n-#define PIPE_HOST_PATH\t\t  PIPES_PATH\"/host\"\n+/* Non-numerical part of host-to-target pipe file name.  */\n+#define PIPE_HOST2TGT_NAME\t  PIPES_PATH \"/host2tgt_\"\n \n-/* Relative path to host-to-target pipe.  */\n-#define PIPE_TARGET_PATH\t  PIPES_PATH\"/target\"\n+/* Non-numerical part of target-to-host pipe file name.  */\n+#define PIPE_TGT2HOST_NAME\t  PIPES_PATH \"/tgt2host_\"\n \n /* Non-numerical part of shared memory file name.  */\n #define SHM_NAME\t\t  \"/offload_shm_\"\n@@ -99,6 +99,15 @@\n   ptr = p;\t\t\t\t\t\\\n }\n \n+/* Like MALLOC, but return NULL instead of COIRESULT.  */\n+#define MALLOCN(type, ptr, size)\t\t\\\n+{\t\t\t\t\t\t\\\n+  type p = (type) malloc (size);\t\t\\\n+  if (p == NULL)\t\t\t\t\\\n+    COIERRORN (\"Cannot allocate memory.\");\t\\\n+  ptr = p;\t\t\t\t\t\\\n+}\n+\n /* Wrapper for strdup.  */\n #define STRDUP(ptr, str)\t\t\t\\\n {\t\t\t\t\t\t\\\n@@ -116,6 +125,14 @@\n     COIERROR (\"Cannot read from pipe.\");\t\\\n }\n \n+/* Like READ, but return NULL instead of COIRESULT.  */\n+#define READN(pipe, ptr, size)\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  int s = (int) size;\t\t\t\t\\\n+  if (read (pipe, ptr, s) != s)\t\t\t\\\n+    COIERRORN (\"Cannot read from pipe.\");\t\\\n+}\n+\n /* Wrapper for pipe writing.  */\n #define WRITE(pipe, ptr, size)\t\t\t\\\n {\t\t\t\t\t\t\\\n@@ -124,6 +141,14 @@\n     COIERROR (\"Cannot write in pipe.\");\t\t\\\n }\n \n+/* Like WRITE, but return NULL instead of COIRESULT.  */\n+#define WRITEN(pipe, ptr, size)\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  int s = (int) size;\t\t\t\t\\\n+  if (write (pipe, ptr, s) != s)\t\t\\\n+    COIERRORN (\"Cannot write in pipe.\");\t\\\n+}\n+\n \n /* Command codes enum.  */\n typedef enum\n@@ -134,7 +159,9 @@ typedef enum\n   CMD_GET_FUNCTION_HANDLE,\n   CMD_OPEN_LIBRARY,\n   CMD_CLOSE_LIBRARY,\n-  CMD_RUN_FUNCTION,\n+  CMD_PIPELINE_CREATE,\n+  CMD_PIPELINE_DESTROY,\n+  CMD_PIPELINE_RUN_FUNCTION,\n   CMD_SHUTDOWN\n } cmd_t;\n "}, {"sha": "f9dd2cde888546ede029bebce3dce96bbf673eb5", "filename": "liboffloadmic/runtime/emulator/coi_device.cpp", "status": "modified", "additions": 158, "deletions": 103, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44799f87c36be1a05c9b314e00a767c43b3c3190/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44799f87c36be1a05c9b314e00a767c43b3c3190/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.cpp?ref=44799f87c36be1a05c9b314e00a767c43b3c3190", "patch": "@@ -35,6 +35,7 @@\n \n \n static uint32_t engine_index;\n+static char *engine_dir;\n \n \n extern \"C\"\n@@ -68,7 +69,7 @@ SYMBOL_VERSION (COIEngineGetIndex, 1) (COI_ISA_TYPE *type,\n {\n   COITRACE (\"COIEngineGetIndex\");\n \n-  /* type is not used in liboffload.  */\n+  /* type is not used in liboffloadmic.  */\n   *index = engine_index;\n \n   return COI_SUCCESS;\n@@ -86,50 +87,144 @@ SYMBOL_VERSION (COIPipelineStartExecutingRunFunctions, 1) ()\n }\n \n \n+/* The start routine for the COI pipeline thread.  */\n+\n+static void *\n+pipeline_thread_routine (void *in_pipeline_num)\n+{\n+  uint32_t pipeline_num = *(uint32_t *) in_pipeline_num;\n+  free (in_pipeline_num);\n+\n+  /* Open pipes.  */\n+  char *pipe_host2tgt_path, *pipe_tgt2host_path;\n+  MALLOCN (char *, pipe_host2tgt_path,\n+\t  strlen (engine_dir) + sizeof (PIPE_HOST2TGT_NAME \"0000000000\"));\n+  MALLOCN (char *, pipe_tgt2host_path,\n+\t  strlen (engine_dir) + sizeof (PIPE_TGT2HOST_NAME \"0000000000\"));\n+  sprintf (pipe_host2tgt_path, \"%s\" PIPE_HOST2TGT_NAME \"%010d\", engine_dir,\n+\t   pipeline_num);\n+  sprintf (pipe_tgt2host_path, \"%s\" PIPE_TGT2HOST_NAME \"%010d\", engine_dir,\n+\t   pipeline_num);\n+  int pipe_host2tgt = open (pipe_host2tgt_path, O_CLOEXEC | O_RDONLY);\n+  if (pipe_host2tgt < 0)\n+    COIERRORN (\"Cannot open host-to-target pipe.\");\n+  int pipe_tgt2host = open (pipe_tgt2host_path, O_CLOEXEC | O_WRONLY);\n+  if (pipe_tgt2host < 0)\n+    COIERRORN (\"Cannot open target-to-host pipe.\");\n+\n+  free (pipe_host2tgt_path);\n+  free (pipe_tgt2host_path);\n+\n+  while (1)\n+    {\n+      /* Read and execute command.  */\n+      cmd_t cmd = CMD_PIPELINE_DESTROY;\n+      int cmd_len = read (pipe_host2tgt, &cmd, sizeof (cmd_t));\n+      if (cmd_len != sizeof (cmd_t) && cmd_len != 0)\n+\tCOIERRORN (\"Cannot read from pipe.\");\n+\n+      if (cmd == CMD_PIPELINE_DESTROY)\n+\tbreak;\n+      else if (cmd == CMD_PIPELINE_RUN_FUNCTION)\n+\t{\n+\t  /* Receive data from host.  */\n+\t  void (*func) (uint32_t, void **, uint64_t *, void *, uint16_t, void *,\n+\t\t\tuint16_t);\n+\t  uint32_t buffer_count;\n+\t  READN (pipe_host2tgt, &func, sizeof (void *));\n+\t  READN (pipe_host2tgt, &buffer_count, sizeof (uint32_t));\n+\t  void **buffers;\n+\t  uint64_t *buffers_len;\n+\t  MALLOCN (void **, buffers, buffer_count * sizeof (void *));\n+\t  MALLOCN (uint64_t *, buffers_len, buffer_count * sizeof (uint64_t));\n+\t  for (uint32_t i = 0; i < buffer_count; i++)\n+\t    {\n+\t      READN (pipe_host2tgt, &buffers_len[i], sizeof (uint64_t));\n+\t      READN (pipe_host2tgt, &buffers[i], sizeof (void *));\n+\t    }\n+\t  uint16_t misc_data_len;\n+\t  READN (pipe_host2tgt, &misc_data_len, sizeof (uint16_t));\n+\t  void *misc_data = NULL;\n+\t  if (misc_data_len > 0)\n+\t    {\n+\t      MALLOCN (void *, misc_data, misc_data_len);\n+\t      READN (pipe_host2tgt, misc_data, misc_data_len);\n+\t    }\n+\t  uint16_t return_data_len;\n+\t  READN (pipe_host2tgt, &return_data_len, sizeof (uint16_t));\n+\t  void *return_data;\n+\t  if (return_data_len > 0)\n+\t    MALLOCN (void *, return_data, return_data_len);\n+\n+\t  /* Run function.  */\n+\t  func (buffer_count, buffers, buffers_len, misc_data,\n+\t\tmisc_data_len, return_data, return_data_len);\n+\n+\t  /* Send data to host if any or just send notification.  */\n+\t  WRITEN (pipe_tgt2host, return_data_len > 0 ? return_data : &cmd,\n+\t\t  return_data_len > 0 ? return_data_len : sizeof (cmd_t));\n+\n+\t  /* Clean up.  */\n+\t  free (buffers);\n+\t  free (buffers_len);\n+\t  if (misc_data_len > 0)\n+\t    free (misc_data);\n+\t  if (return_data_len > 0)\n+\t    free (return_data);\n+\t}\n+      else\n+\tCOIERRORN (\"Unrecognizable command from host.\");\n+    }\n+\n+  /* Close pipes.  */\n+  if (close (pipe_host2tgt) < 0)\n+    COIERRORN (\"Cannot close host-to-target pipe.\");\n+  if (close (pipe_tgt2host) < 0)\n+    COIERRORN (\"Cannot close target-to-host pipe.\");\n+\n+  return NULL;\n+}\n+\n+\n COIRESULT\n SYMBOL_VERSION (COIProcessWaitForShutdown, 1) ()\n {\n   COITRACE (\"COIProcessWaitForShutdown\");\n \n-  char *mic_dir = getenv (MIC_DIR_ENV);\n+  engine_dir = getenv (MIC_DIR_ENV);\n   char *mic_index = getenv (MIC_INDEX_ENV);\n-  char *pipe_host_path, *pipe_target_path;\n-  int pipe_host, pipe_target;\n-  int cmd_len;\n-  pid_t ppid = getppid ();\n-  cmd_t cmd;\n-\n-  assert (mic_dir != NULL && mic_index != NULL);\n+  assert (engine_dir != NULL && mic_index != NULL);\n \n   /* Get engine index.  */\n   engine_index = atoi (mic_index);\n \n-  /* Open pipes.  */\n-  MALLOC (char *, pipe_host_path,\n-\t  strlen (PIPE_HOST_PATH) + strlen (mic_dir) + 1);\n-  MALLOC (char *, pipe_target_path,\n-\t  strlen (PIPE_TARGET_PATH) + strlen (mic_dir) + 1);\n-  sprintf (pipe_host_path, \"%s\" PIPE_HOST_PATH, mic_dir);\n-  sprintf (pipe_target_path, \"%s\" PIPE_TARGET_PATH, mic_dir);\n-  pipe_host = open (pipe_host_path, O_CLOEXEC | O_WRONLY);\n-  if (pipe_host < 0)\n-    COIERROR (\"Cannot open target-to-host pipe.\");\n-  pipe_target = open (pipe_target_path, O_CLOEXEC | O_RDONLY);\n-  if (pipe_target < 0)\n-    COIERROR (\"Cannot open host-to-target pipe.\");\n+  /* Open main pipes.  */\n+  char *pipe_host2tgt_path, *pipe_tgt2host_path;\n+  MALLOC (char *, pipe_host2tgt_path,\n+\t  strlen (engine_dir) + sizeof (PIPE_HOST2TGT_NAME \"mainpipe\"));\n+  MALLOC (char *, pipe_tgt2host_path,\n+\t  strlen (engine_dir) + sizeof (PIPE_TGT2HOST_NAME \"mainpipe\"));\n+  sprintf (pipe_host2tgt_path, \"%s\" PIPE_HOST2TGT_NAME \"mainpipe\", engine_dir);\n+  sprintf (pipe_tgt2host_path, \"%s\" PIPE_TGT2HOST_NAME \"mainpipe\", engine_dir);\n+  int pipe_host2tgt = open (pipe_host2tgt_path, O_CLOEXEC | O_RDONLY);\n+  if (pipe_host2tgt < 0)\n+    COIERROR (\"Cannot open host-to-target main pipe.\");\n+  int pipe_tgt2host = open (pipe_tgt2host_path, O_CLOEXEC | O_WRONLY);\n+  if (pipe_tgt2host < 0)\n+    COIERROR (\"Cannot open target-to-host main pipe.\");\n \n   /* Clean up.  */\n-  free (pipe_host_path);\n-  free (pipe_target_path);\n+  free (pipe_host2tgt_path);\n+  free (pipe_tgt2host_path);\n \n   /* Handler.  */\n   while (1)\n     {\n       /* Read and execute command.  */\n-      cmd = CMD_SHUTDOWN;\n-      cmd_len = read (pipe_target, &cmd, sizeof (cmd_t));\n+      cmd_t cmd = CMD_SHUTDOWN;\n+      int cmd_len = read (pipe_host2tgt, &cmd, sizeof (cmd_t));\n       if (cmd_len != sizeof (cmd_t) && cmd_len != 0)\n-\tCOIERROR (\"Cannot read from pipe.\");\n+\tCOIERROR (\"Cannot read from main pipe.\");\n \n       switch (cmd)\n \t{\n@@ -139,34 +234,33 @@ SYMBOL_VERSION (COIProcessWaitForShutdown, 1) ()\n \t    void *dest, *source;\n \n \t    /* Receive data from host.  */\n-\t    READ (pipe_target, &dest, sizeof (void *));\n-\t    READ (pipe_target, &source, sizeof (void *));\n-\t    READ (pipe_target, &len, sizeof (uint64_t));\n+\t    READ (pipe_host2tgt, &dest, sizeof (void *));\n+\t    READ (pipe_host2tgt, &source, sizeof (void *));\n+\t    READ (pipe_host2tgt, &len, sizeof (uint64_t));\n \n \t    /* Copy.  */\n \t    memcpy (dest, source, len);\n \n \t    /* Notify host about completion.  */\n-\t    WRITE (pipe_host, &cmd, sizeof (cmd_t));\n+\t    WRITE (pipe_tgt2host, &cmd, sizeof (cmd_t));\n \n \t    break;\n \t  }\n \tcase CMD_BUFFER_MAP:\n \t  {\n \t    char *name;\n-\t    int fd;\n \t    size_t len;\n \t    uint64_t buffer_len;\n \t    void *buffer;\n \n \t    /* Receive data from host.  */\n-\t    READ (pipe_target, &len, sizeof (size_t));\n+\t    READ (pipe_host2tgt, &len, sizeof (size_t));\n \t    MALLOC (char *, name, len);\n-\t    READ (pipe_target, name, len);\n-\t    READ (pipe_target, &buffer_len, sizeof (uint64_t));\n+\t    READ (pipe_host2tgt, name, len);\n+\t    READ (pipe_host2tgt, &buffer_len, sizeof (uint64_t));\n \n \t    /* Open shared memory.  */\n-\t    fd = shm_open (name, O_CLOEXEC | O_RDWR, S_IRUSR | S_IWUSR);\n+\t    int fd = shm_open (name, O_CLOEXEC | O_RDWR, S_IRUSR | S_IWUSR);\n \t    if (fd < 0)\n \t      COIERROR (\"Cannot open shared memory.\");\n \n@@ -177,8 +271,8 @@ SYMBOL_VERSION (COIProcessWaitForShutdown, 1) ()\n \t      COIERROR (\"Cannot map shared memory.\");\n \n \t    /* Send data to host.  */\n-\t    WRITE (pipe_host, &fd, sizeof (int));\n-\t    WRITE (pipe_host, &buffer, sizeof (void *));\n+\t    WRITE (pipe_tgt2host, &fd, sizeof (int));\n+\t    WRITE (pipe_tgt2host, &buffer, sizeof (void *));\n \n \t    /* Clean up.  */\n \t    free (name);\n@@ -192,9 +286,9 @@ SYMBOL_VERSION (COIProcessWaitForShutdown, 1) ()\n \t    void *buffer;\n \n \t    /* Receive data from host.  */\n-\t    READ (pipe_target, &fd, sizeof (int));\n-\t    READ (pipe_target, &buffer, sizeof (void *));\n-\t    READ (pipe_target, &buffer_len, sizeof (uint64_t));\n+\t    READ (pipe_host2tgt, &fd, sizeof (int));\n+\t    READ (pipe_host2tgt, &buffer, sizeof (void *));\n+\t    READ (pipe_host2tgt, &buffer_len, sizeof (uint64_t));\n \n \t    /* Unmap buffer.  */\n \t    if (munmap (buffer, buffer_len) < 0)\n@@ -205,28 +299,27 @@ SYMBOL_VERSION (COIProcessWaitForShutdown, 1) ()\n \t      COIERROR (\"Cannot close shared memory file.\");\n \n \t    /* Notify host about completion.  */\n-\t    WRITE (pipe_host, &cmd, sizeof (cmd_t));\n+\t    WRITE (pipe_tgt2host, &cmd, sizeof (cmd_t));\n \n \t    break;\n \t  }\n \tcase CMD_GET_FUNCTION_HANDLE:\n \t  {\n \t    char *name;\n \t    size_t len;\n-\t    void *ptr;\n \n \t    /* Receive data from host.  */\n-\t    READ (pipe_target, &len, sizeof (size_t));\n+\t    READ (pipe_host2tgt, &len, sizeof (size_t));\n \t    MALLOC (char *, name, len);\n-\t    READ (pipe_target, name, len);\n+\t    READ (pipe_host2tgt, name, len);\n \n \t    /* Find function.  */\n-\t    ptr = dlsym (RTLD_DEFAULT, name);\n+\t    void *ptr = dlsym (RTLD_DEFAULT, name);\n \t    if (ptr == NULL)\n \t      COIERROR (\"Cannot find symbol %s.\", name);\n \n \t    /* Send data to host.  */\n-\t    WRITE (pipe_host, &ptr, sizeof (void *));\n+\t    WRITE (pipe_tgt2host, &ptr, sizeof (void *));\n \n \t    /* Clean up.  */\n \t    free (name);\n@@ -237,20 +330,19 @@ SYMBOL_VERSION (COIProcessWaitForShutdown, 1) ()\n \t  {\n \t    char *lib_path;\n \t    size_t len;\n-\t    void *handle;\n \n \t    /* Receive data from host.  */\n-\t    READ (pipe_target, &len, sizeof (size_t));\n+\t    READ (pipe_host2tgt, &len, sizeof (size_t));\n \t    MALLOC (char *, lib_path, len);\n-\t    READ (pipe_target, lib_path, len);\n+\t    READ (pipe_host2tgt, lib_path, len);\n \n \t    /* Open library.  */\n-\t    handle = dlopen (lib_path, RTLD_LAZY | RTLD_GLOBAL);\n+\t    void *handle = dlopen (lib_path, RTLD_LAZY | RTLD_GLOBAL);\n \t    if (handle == NULL)\n \t      COIERROR (\"Cannot load %s: %s\", lib_path, dlerror ());\n \n \t    /* Send data to host.  */\n-\t    WRITE (pipe_host, &handle, sizeof (void *));\n+\t    WRITE (pipe_tgt2host, &handle, sizeof (void *));\n \n \t    /* Clean up.  */\n \t    free (lib_path);\n@@ -261,67 +353,30 @@ SYMBOL_VERSION (COIProcessWaitForShutdown, 1) ()\n \t  {\n \t    /* Receive data from host.  */\n \t    void *handle;\n-\t    READ (pipe_target, &handle, sizeof (void *));\n+\t    READ (pipe_host2tgt, &handle, sizeof (void *));\n \n \t    dlclose (handle);\n \n \t    break;\n \t  }\n-\tcase CMD_RUN_FUNCTION:\n+\tcase CMD_PIPELINE_CREATE:\n \t  {\n-\t    uint16_t misc_data_len, return_data_len;\n-\t    uint32_t buffer_count, i;\n-\t    uint64_t *buffers_len, size;\n-\t    void *ptr;\n-\t    void **buffers, *misc_data, *return_data;\n-\n-\t    void (*func) (uint32_t, void **, uint64_t *,\n-\t\t\t  void *, uint16_t, void*, uint16_t);\n-\n \t    /* Receive data from host.  */\n-\t    READ (pipe_target, &func, sizeof (void *));\n-\t    READ (pipe_target, &buffer_count, sizeof (uint32_t));\n-\t    MALLOC (void **, buffers, buffer_count * sizeof (void *));\n-\t    MALLOC (uint64_t *, buffers_len, buffer_count * sizeof (uint64_t));\n-\n-\t    for (i = 0; i < buffer_count; i++)\n-\t      {\n-\t\tREAD (pipe_target, &(buffers_len[i]), sizeof (uint64_t));\n-\t\tREAD (pipe_target, &(buffers[i]), sizeof (void *));\n-\t      }\n-\t    READ (pipe_target, &misc_data_len, sizeof (uint16_t));\n-\t    if (misc_data_len > 0)\n-\t      {\n-\t\tMALLOC (void *, misc_data, misc_data_len);\n-\t\tREAD (pipe_target, misc_data, misc_data_len);\n-\t      }\n-\t    READ (pipe_target, &return_data_len, sizeof (uint16_t));\n-\t    if (return_data_len > 0)\n-\t      MALLOC (void *, return_data, return_data_len);\n-\n-\t    /* Run function.  */\n-\t    func (buffer_count, buffers, buffers_len, misc_data,\n-\t\t  misc_data_len, return_data, return_data_len);\n-\n-\t    /* Send data to host if any or just send notification.  */\n-\t    WRITE (pipe_host, return_data_len > 0 ? return_data : &cmd,\n-\t\t   return_data_len > 0 ? return_data_len : sizeof (cmd_t));\n-\n-\t    /* Clean up.  */\n-\t    free (buffers);\n-\t    free (buffers_len);\n-\t    if (misc_data_len > 0)\n-\t      free (misc_data);\n-\t    if (return_data_len > 0)\n-\t      free (return_data);\n-\n+\t    uint32_t *pipeline_num = (uint32_t *) malloc (sizeof (uint32_t));\n+\t    READ (pipe_host2tgt, pipeline_num, sizeof (*pipeline_num));\n+\n+\t    /* Create a new thread for the pipeline.  */\n+\t    pthread_t thread;\n+\t    if (pthread_create (&thread, NULL, pipeline_thread_routine,\n+\t\t\t\tpipeline_num))\n+\t      COIERROR (\"Cannot create new thread.\");\n \t    break;\n \t  }\n \tcase CMD_SHUTDOWN:\n-\t  if (close (pipe_host) < 0)\n-\t    COIERROR (\"Cannot close target-to-host pipe.\");\n-\t  if (close (pipe_target) < 0)\n-\t    COIERROR (\"Cannot close host-to-target pipe.\");\n+\t  if (close (pipe_host2tgt) < 0)\n+\t    COIERROR (\"Cannot close host-to-target main pipe.\");\n+\t  if (close (pipe_tgt2host) < 0)\n+\t    COIERROR (\"Cannot close target-to-host main pipe.\");\n \t  return COI_SUCCESS;\n \tdefault:\n \t  COIERROR (\"Unrecognizable command from host.\");"}, {"sha": "2b842e3ec17c128bc8c9c0883c6ccdae13733b1d", "filename": "liboffloadmic/runtime/emulator/coi_device.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44799f87c36be1a05c9b314e00a767c43b3c3190/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44799f87c36be1a05c9b314e00a767c43b3c3190/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.h?ref=44799f87c36be1a05c9b314e00a767c43b3c3190", "patch": "@@ -41,6 +41,16 @@\n   return COI_ERROR;\t\t\t    \\\n }\n \n+/* Like COIERROR, but return NULL instead of COIRESULT.  */\n+#define COIERRORN(...)\t\t\t    \\\n+{\t\t\t\t\t    \\\n+  fprintf (stderr, \"COI ERROR - TARGET: \"); \\\n+  fprintf (stderr, __VA_ARGS__);\t    \\\n+  fprintf (stderr, \"\\n\");\t\t    \\\n+  perror (NULL);\t\t\t    \\\n+  return NULL;\t\t\t\t    \\\n+}\n+\n #ifdef DEBUG\n   #define COITRACE(...)\t\t\t      \\\n   {\t\t\t\t\t      \\"}, {"sha": "960c59ecff38aba759938f645d5f3de664b40123", "filename": "liboffloadmic/runtime/emulator/coi_host.cpp", "status": "modified", "additions": 822, "deletions": 501, "changes": 1323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44799f87c36be1a05c9b314e00a767c43b3c3190/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44799f87c36be1a05c9b314e00a767c43b3c3190/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.cpp?ref=44799f87c36be1a05c9b314e00a767c43b3c3190", "patch": "@@ -27,60 +27,71 @@\n     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n \n+#include <set>\n+#include <map>\n+#include <queue>\n+\n #include \"coi_host.h\"\n \n #include \"coi_version_asm.h\"\n \n #define CYCLE_FREQUENCY     1000000000\n \n-/* Environment variables.  */\n-extern char **environ;\n-\n-/* List of directories for removing on exit.  */\n-char **tmp_dirs;\n-unsigned tmp_dirs_num = 0;\n-\n-/* Number of emulated MIC engines.  */\n-long num_engines;\n-\n-/* Mutex to sync parallel execution.  */\n-pthread_mutex_t mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;\n-\n-\n-typedef enum\n+enum buffer_t\n {\n   BUFFER_NORMAL,\n   BUFFER_MEMORY\n-} buffer_t;\n+};\n \n-typedef struct\n+struct Engine\n {\n   COI_ISA_TYPE type;\n   uint32_t index;\n   char *dir;\n-} Engine;\n+};\n \n-typedef struct\n+struct Function\n {\n-  char *name;\n   void *ptr;\n-} Function;\n-\n-typedef struct\n+  uint32_t num_buffers;\n+  uint64_t *bufs_size;\n+  void * *bufs_data_target;\n+  uint16_t misc_data_len;\n+  void *misc_data;\n+  uint16_t return_value_len;\n+  void *return_value;\n+  COIEVENT completion_event;\n+};\n+\n+struct Callback\n {\n-  int pipe_host;\n-  int pipe_target;\n-} Pipeline;\n+  COI_EVENT_CALLBACK ptr;\n+  const void *data;\n+};\n \n-typedef struct\n+struct Process\n {\n   pid_t pid;\n+  int pipe_host2tgt;\n+  int pipe_tgt2host;\n   Engine *engine;\n-  Function **functions;\n-  Pipeline *pipeline;\n-} Process;\n+  void **functions;\n+};\n \n-typedef struct\n+struct Pipeline\n+{\n+  pthread_t thread;\n+  bool destroy;\n+  bool is_destroyed;\n+  char *pipe_host2tgt_path;\n+  char *pipe_tgt2host_path;\n+  int pipe_host2tgt;\n+  int pipe_tgt2host;\n+  std::queue<Function> queue;\n+  Process *process;\n+};\n+\n+struct Buffer\n {\n   buffer_t type;\n   char *name;\n@@ -90,7 +101,39 @@ typedef struct\n   void *data;\n   void *data_target;\n   Process *process;\n-} Buffer;\n+};\n+\n+\n+/* Environment variables.  */\n+extern char **environ;\n+\n+/* List of directories for removing on exit.  */\n+static char **tmp_dirs;\n+static unsigned tmp_dirs_num;\n+\n+/* Number of emulated MIC engines.  */\n+static long num_engines;\n+\n+/* Number of the last COI pipeline.  */\n+static uint32_t max_pipeline_num;\n+\n+/* Set of undestroyed pipelines.  */\n+static std::set<Pipeline *> pipelines;\n+\n+/* Number of the last COI event, the event #0 is always signalled.  */\n+static uint64_t max_event_num = 1;\n+\n+/* Set of created COI events, which are not signalled.  */\n+static std::set<uint64_t> non_signalled_events;\n+\n+/* Set of COI events, which encountered errors.  */\n+static std::map<uint64_t, COIRESULT> errored_events;\n+\n+/* Set of registered callbacks, indexed by event number.  */\n+static std::map<uint64_t, Callback> callbacks;\n+\n+/* Mutex to sync parallel execution.  */\n+static pthread_mutex_t mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;\n \n \n static COIRESULT\n@@ -168,90 +211,155 @@ __attribute__((destructor))\n static void\n cleanup ()\n {\n-  unsigned i;\n-  for (i = 0; i < tmp_dirs_num; i++)\n+  for (unsigned i = 0; i < tmp_dirs_num; i++)\n     {\n       remove_directory (tmp_dirs[i]);\n       free (tmp_dirs[i]);\n     }\n-  if (tmp_dirs)\n-    free (tmp_dirs);\n+  free (tmp_dirs);\n+}\n+\n+static COIRESULT\n+start_critical_section ()\n+{\n+  if (pthread_mutex_lock (&mutex) != 0)\n+    COIERROR (\"Cannot lock mutex.\");\n+  return COI_SUCCESS;\n+}\n+\n+static COIRESULT\n+finish_critical_section ()\n+{\n+  if (pthread_mutex_unlock (&mutex) != 0)\n+    COIERROR (\"Cannot unlock mutex.\");\n+  return COI_SUCCESS;\n+}\n+\n+static bool\n+pipeline_is_destroyed (const Pipeline *pipeline)\n+{\n+  start_critical_section ();\n+  bool res = pipeline->is_destroyed;\n+  finish_critical_section ();\n+  return res;\n+}\n+\n+static void\n+maybe_invoke_callback (const COIEVENT event, const COIRESULT result)\n+{\n+  std::map<uint64_t, Callback>::iterator cb = callbacks.find (event.opaque[0]);\n+\n+  if (cb != callbacks.end ())\n+    {\n+      Callback callback = cb->second;\n+      callback.ptr (event, result, callback.data);\n+      callbacks.erase (cb);\n+    }\n+}\n+\n+static void\n+signal_event (const COIEVENT event, const COIRESULT result)\n+{\n+  if (result != COI_SUCCESS)\n+    errored_events.insert (std::pair <uint64_t, COIRESULT> (event.opaque[0],\n+\t\t\t\t\t\t\t    result));\n+  non_signalled_events.erase (event.opaque[0]);\n+\n+  maybe_invoke_callback (event, result);\n+}\n+\n+static COIRESULT\n+get_event_result (const COIEVENT event)\n+{\n+  COIRESULT res = COI_SUCCESS;\n+\n+  std::map<uint64_t, COIRESULT>::iterator ee\n+    = errored_events.find (event.opaque[0]);\n+\n+  if (ee != errored_events.end ())\n+    res = ee->second;\n+\n+  return res;\n }\n \n \n extern \"C\"\n {\n \n COIRESULT\n-SYMBOL_VERSION (COIBufferCopy, 1) (COIBUFFER dest_buffer,\n-\t\t\t\t   COIBUFFER source_buffer,\n-\t\t\t\t   uint64_t dest_offset,\n-\t\t\t\t   uint64_t source_offset,\n-\t\t\t\t   uint64_t length,\n-\t\t\t\t   COI_COPY_TYPE type,\n-\t\t\t\t   uint32_t dependencies_num,     // Ignored\n-\t\t\t\t   const COIEVENT *dependencies,  // Ignored\n-\t\t\t\t   COIEVENT *completion)\t  // Ignored\n+SYMBOL_VERSION (COIBufferCopy, 1) (COIBUFFER in_DestBuffer,\n+\t\t\t\t   COIBUFFER in_SourceBuffer,\n+\t\t\t\t   uint64_t in_DestOffset,\n+\t\t\t\t   uint64_t in_SourceOffset,\n+\t\t\t\t   uint64_t in_Length,\n+\t\t\t\t   COI_COPY_TYPE in_Type,\n+\t\t\t\t   uint32_t in_NumDependencies,\n+\t\t\t\t   const COIEVENT *in_pDependencies,  // Ignored\n+\t\t\t\t   COIEVENT *out_pCompletion)\n {\n   COITRACE (\"COIBufferCopy\");\n \n+  /* Features of liboffloadmic.  */\n+  assert (in_DestBuffer != NULL);\n+  assert (in_SourceBuffer != NULL);\n+  assert (in_Type == COI_COPY_UNSPECIFIED);\n+  assert (in_NumDependencies == 0);\n+\n   /* Convert input arguments.  */\n-  Buffer *dest = (Buffer *) dest_buffer;\n-  Buffer *source = (Buffer *) source_buffer;\n+  Buffer *dest = (Buffer *) in_DestBuffer;\n+  Buffer *source = (Buffer *) in_SourceBuffer;\n \n-  /* Features of liboffload.  */\n-  assert (type == COI_COPY_UNSPECIFIED);\n-\n-  /* Start critical section.  */\n-  if (pthread_mutex_lock (&mutex) != 0)\n-    COIERROR (\"Cannot lock mutex.\");\n+  start_critical_section ();\n \n   /* Map buffers if needed.  */\n   if (dest->data == 0 && dest->type == BUFFER_NORMAL)\n-    if (COIBufferMap (dest_buffer, 0, dest->size, (COI_MAP_TYPE) 0,\n+    if (COIBufferMap (in_DestBuffer, 0, dest->size, (COI_MAP_TYPE) 0,\n \t\t      0, 0, 0, 0, 0) == COI_ERROR)\n       return COI_ERROR;\n   if (source->data == 0 && source->type == BUFFER_NORMAL)\n-    if (COIBufferMap (source_buffer, 0, source->size, (COI_MAP_TYPE) 0,\n+    if (COIBufferMap (in_SourceBuffer, 0, source->size, (COI_MAP_TYPE) 0,\n \t\t      0, 0, 0, 0, 0) == COI_ERROR)\n       return COI_ERROR;\n \n   /* Copy data.  */\n   if (source->data != 0 && dest->data != 0)\n-    memcpy ((void *) ((uintptr_t) dest->data+dest_offset),\n-\t    (void *) ((uintptr_t) source->data+source_offset), length);\n+    memcpy ((void *) ((uintptr_t) dest->data + in_DestOffset),\n+\t    (void *) ((uintptr_t) source->data + in_SourceOffset), in_Length);\n   else\n     {\n       assert (dest->process == source->process);\n \n       Buffer *buffer;\n       cmd_t cmd = CMD_BUFFER_COPY;\n-      Pipeline *pipeline = dest->process->pipeline;\n \n       /* Create intermediary buffer.  */\n-      if (COIBufferCreate (length, COI_BUFFER_NORMAL, 0, 0, 1,\n+      if (COIBufferCreate (in_Length, COI_BUFFER_NORMAL, 0, 0, 1,\n \t\t\t   (COIPROCESS*) &dest->process,\n \t\t\t   (COIBUFFER *) &buffer) == COI_ERROR)\n \treturn COI_ERROR;\n \n+      int pipe_host2tgt = dest->process->pipe_host2tgt;\n+      int pipe_tgt2host = dest->process->pipe_tgt2host;\n+\n       /* Copy from source to intermediary buffer.  */\n       if (source->data == 0)\n \t{\n \t  assert (source->data_target != 0);\n \n \t  /* Send data to target.  */\n-\t  WRITE (pipeline->pipe_target, &cmd, sizeof (cmd_t));\n-\t  WRITE (pipeline->pipe_target, &(buffer->data_target), sizeof (void *));\n-\t  WRITE (pipeline->pipe_target, &(source->data_target), sizeof (void *));\n-\t  WRITE (pipeline->pipe_target, &(buffer->size), sizeof (uint64_t));\n+\t  WRITE (pipe_host2tgt, &cmd, sizeof (cmd_t));\n+\t  WRITE (pipe_host2tgt, &buffer->data_target, sizeof (void *));\n+\t  WRITE (pipe_host2tgt, &source->data_target, sizeof (void *));\n+\t  WRITE (pipe_host2tgt, &buffer->size, sizeof (uint64_t));\n \n-\t  /* Receive data from  target.  */\n-\t  READ (pipeline->pipe_host, &cmd, sizeof (cmd_t));\n+\t  /* Receive data from target.  */\n+\t  READ (pipe_tgt2host, &cmd, sizeof (cmd_t));\n \t}\n       else\n \t{\n-\t  if (COIBufferCopy ((COIBUFFER) buffer, source_buffer, 0, source_offset,\n-\t\t\t     length, type, 0, 0, 0) == COI_ERROR)\n+\t  if (COIBufferCopy ((COIBUFFER) buffer, in_SourceBuffer, 0,\n+\t\t\t     in_SourceOffset, in_Length, in_Type, 0, 0, 0)\n+\t      == COI_ERROR)\n \t    return COI_ERROR;\n \t}\n \n@@ -261,18 +369,18 @@ SYMBOL_VERSION (COIBufferCopy, 1) (COIBUFFER dest_buffer,\n \t  assert (dest->data_target != 0);\n \n \t  /* Send data to target.  */\n-\t  WRITE (pipeline->pipe_target, &cmd, sizeof (cmd_t));\n-\t  WRITE (pipeline->pipe_target, &(dest->data_target), sizeof (void *));\n-\t  WRITE (pipeline->pipe_target, &(buffer->data_target), sizeof (void *));\n-\t  WRITE (pipeline->pipe_target, &(buffer->size), sizeof (uint64_t));\n+\t  WRITE (pipe_host2tgt, &cmd, sizeof (cmd_t));\n+\t  WRITE (pipe_host2tgt, &dest->data_target, sizeof (void *));\n+\t  WRITE (pipe_host2tgt, &buffer->data_target, sizeof (void *));\n+\t  WRITE (pipe_host2tgt, &buffer->size, sizeof (uint64_t));\n \n-\t  /* Receive data from  target.  */\n-\t  READ (pipeline->pipe_host, &cmd, sizeof (cmd_t));\n+\t  /* Receive data from target.  */\n+\t  READ (pipe_tgt2host, &cmd, sizeof (cmd_t));\n \t}\n       else\n \t{\n-\t  if (COIBufferCopy (dest_buffer, (COIBUFFER) buffer, dest_offset,\n-\t\t\t     0, length, type, 0, 0, 0) == COI_ERROR)\n+\t  if (COIBufferCopy (in_DestBuffer, (COIBUFFER) buffer, in_DestOffset,\n+\t\t\t     0, in_Length, in_Type, 0, 0, 0) == COI_ERROR)\n \t    return COI_ERROR;\n \t}\n \n@@ -289,89 +397,84 @@ SYMBOL_VERSION (COIBufferCopy, 1) (COIBUFFER dest_buffer,\n     if (COIBufferUnmap ((COIMAPINSTANCE) source, 0, 0, 0) == COI_ERROR)\n       return COI_ERROR;\n \n-  /* Finish critical section.  */\n-  if (pthread_mutex_unlock (&mutex) != 0)\n-    COIERROR (\"Cannot unlock mutex.\");\n+  finish_critical_section ();\n+\n+  if (out_pCompletion)\n+    out_pCompletion->opaque[0] = 0;\n \n   return COI_SUCCESS;\n }\n \n \n COIRESULT\n-SYMBOL_VERSION (COIBufferCreate, 1) (uint64_t size,\n-\t\t\t\t     COI_BUFFER_TYPE type,\n-\t\t\t\t     uint32_t flags,\n-\t\t\t\t     const void *init_data,\n-\t\t\t\t     uint32_t processes_num,\n-\t\t\t\t     const COIPROCESS *processes,\n-\t\t\t\t     COIBUFFER *buffer)\n+SYMBOL_VERSION (COIBufferCreate, 1) (uint64_t in_Size,\n+\t\t\t\t     COI_BUFFER_TYPE in_Type,\n+\t\t\t\t     uint32_t in_Flags,\n+\t\t\t\t     const void *in_pInitData,\n+\t\t\t\t     uint32_t in_NumProcesses,\n+\t\t\t\t     const COIPROCESS *in_pProcesses,\n+\t\t\t\t     COIBUFFER *out_pBuffer)\n {\n   COITRACE (\"COIBufferCreate\");\n \n   char *shm_name;\n-  cmd_t cmd = CMD_BUFFER_MAP;\n   int shm_fd;\n   const int ullong_max_len = 20;\n-  size_t len;\n-  unsigned long long i;\n-\n-  Buffer *buf;\n-  Pipeline *pipeline;\n \n-  /* Features of liboffload.  */\n-  assert (type == COI_BUFFER_NORMAL);\n-  assert ((flags & COI_SINK_MEMORY) == 0);\n-  assert ((flags & COI_SAME_ADDRESS_SINKS) == 0);\n-  assert ((flags & COI_SAME_ADDRESS_SINKS_AND_SOURCE) == 0);\n-  assert (init_data == 0);\n-  assert (processes_num == 1);\n+  /* Features of liboffloadmic.  */\n+  assert (in_Type == COI_BUFFER_NORMAL);\n+  assert ((in_Flags & COI_SINK_MEMORY) == 0);\n+  assert ((in_Flags & COI_SAME_ADDRESS_SINKS) == 0);\n+  assert ((in_Flags & COI_SAME_ADDRESS_SINKS_AND_SOURCE) == 0);\n+  assert (in_pInitData == NULL);\n+  assert (in_NumProcesses == 1);\n+  assert (in_pProcesses != NULL);\n+  assert (out_pBuffer != NULL);\n \n   /* Create shared memory with an unique name.  */\n   MALLOC (char *, shm_name, strlen (SHM_NAME) + ullong_max_len + 1);\n-  for (i = 0; i >= 0; i++)\n+  for (unsigned long long i = 0; i >= 0; i++)\n     {\n-      sprintf (shm_name, SHM_NAME\"%lu\", i);\n+      sprintf (shm_name, SHM_NAME \"%lu\", i);\n       shm_fd = shm_open (shm_name, O_CLOEXEC | O_CREAT | O_EXCL | O_RDWR,\n \t\t\t S_IRUSR | S_IWUSR);\n       if (shm_fd > 0)\n \tbreak;\n     }\n-  if (ftruncate (shm_fd, size) < 0)\n+  if (ftruncate (shm_fd, in_Size) < 0)\n     COIERROR (\"Cannot truncate shared memory file.\");\n \n   /* Create buffer.  */\n-  MALLOC (Buffer *, buf, sizeof (Buffer));\n+  Buffer *buf = new Buffer;\n   buf->data = 0;\n   buf->fd = shm_fd;\n-  buf->process = (Process *) processes[0];\n-  buf->size = size;\n+  buf->process = (Process *) in_pProcesses[0];\n+  buf->size = in_Size;\n   buf->type = BUFFER_NORMAL;\n   STRDUP (buf->name, shm_name);\n \n   /* Map buffer on target.  */\n-  len = strlen (buf->name) + 1;\n-  pipeline = buf->process->pipeline;\n+  size_t len = strlen (buf->name) + 1;\n \n-  /* Start critical section.  */\n-  if (pthread_mutex_lock (&mutex) != 0)\n-    COIERROR (\"Cannot lock mutex.\");\n+  start_critical_section ();\n \n   /* Send data to target.  */\n-  WRITE (pipeline->pipe_target, &cmd, sizeof (cmd_t));\n-  WRITE (pipeline->pipe_target, &len, sizeof (size_t));\n-  WRITE (pipeline->pipe_target, buf->name, len);\n-  WRITE (pipeline->pipe_target, &(buf->size), sizeof (uint64_t));\n+  const cmd_t cmd = CMD_BUFFER_MAP;\n+  int pipe_host2tgt = buf->process->pipe_host2tgt;\n+  WRITE (pipe_host2tgt, &cmd, sizeof (cmd_t));\n+  WRITE (pipe_host2tgt, &len, sizeof (size_t));\n+  WRITE (pipe_host2tgt, buf->name, len);\n+  WRITE (pipe_host2tgt, &buf->size, sizeof (uint64_t));\n \n-  /* Receive data from  target.  */\n-  READ (pipeline->pipe_host, &(buf->fd_target), sizeof (int));\n-  READ (pipeline->pipe_host, &(buf->data_target), sizeof (void *));\n+  /* Receive data from target.  */\n+  int pipe_tgt2host = buf->process->pipe_tgt2host;\n+  READ (pipe_tgt2host, &buf->fd_target, sizeof (int));\n+  READ (pipe_tgt2host, &buf->data_target, sizeof (void *));\n \n-  /* Finish critical section.  */\n-  if (pthread_mutex_unlock (&mutex) != 0)\n-    COIERROR (\"Cannot unlock mutex.\");\n+  finish_critical_section ();\n \n   /* Prepare output arguments.  */\n-  *buffer = (COIBUFFER) buf;\n+  *out_pBuffer = (COIBUFFER) buf;\n \n   /* Clean up.  */\n   free (shm_name);\n@@ -381,74 +484,72 @@ SYMBOL_VERSION (COIBufferCreate, 1) (uint64_t size,\n \n \n COIRESULT\n-SYMBOL_VERSION (COIBufferCreateFromMemory, 1) (uint64_t size,\n-\t\t\t\t\t       COI_BUFFER_TYPE type,\n-\t\t\t\t\t       uint32_t flags,\n-\t\t\t\t\t       void *memory,\n-\t\t\t\t\t       uint32_t processes_num,\n-\t\t\t\t\t       const COIPROCESS *processes,\n-\t\t\t\t\t       COIBUFFER *buffer)\n+SYMBOL_VERSION (COIBufferCreateFromMemory, 1) (uint64_t in_Size,\n+\t\t\t\t\t       COI_BUFFER_TYPE in_Type,\n+\t\t\t\t\t       uint32_t in_Flags,\n+\t\t\t\t\t       void *in_Memory,\n+\t\t\t\t\t       uint32_t in_NumProcesses,\n+\t\t\t\t\t       const COIPROCESS *in_pProcesses,\n+\t\t\t\t\t       COIBUFFER *out_pBuffer)\n {\n   COITRACE (\"COIBufferCreateFromMemory\");\n \n-  Buffer *buf;\n-\n-  /* Features of liboffload.  */\n-  assert (type == COI_BUFFER_NORMAL);\n-  assert ((flags & COI_SAME_ADDRESS_SINKS) == 0);\n-  assert ((flags & COI_SAME_ADDRESS_SINKS_AND_SOURCE) == 0);\n-  assert (processes_num == 1);\n+  /* Features of liboffloadmic.  */\n+  assert (in_Type == COI_BUFFER_NORMAL);\n+  assert ((in_Flags & COI_SAME_ADDRESS_SINKS) == 0);\n+  assert ((in_Flags & COI_SAME_ADDRESS_SINKS_AND_SOURCE) == 0);\n+  assert (in_NumProcesses == 1);\n+  assert (in_pProcesses != NULL);\n+  assert (out_pBuffer != NULL);\n \n   /* Create buffer.  */\n-  MALLOC (Buffer *, buf, sizeof (Buffer));\n-  buf->data = (flags & COI_SINK_MEMORY) == 0 ? memory : 0;\n-  buf->data_target = (flags & COI_SINK_MEMORY) != 0 ? memory : 0;\n-  buf->process = (Process *) processes[0];\n-  buf->size = size;\n+  Buffer *buf = new Buffer;\n+  buf->data = (in_Flags & COI_SINK_MEMORY) == 0 ? in_Memory : 0;\n+  buf->data_target = (in_Flags & COI_SINK_MEMORY) != 0 ? in_Memory : 0;\n+  buf->process = (Process *) in_pProcesses[0];\n+  buf->size = in_Size;\n   buf->type = BUFFER_MEMORY;\n \n   /* Prepare output argument.  */\n-  *buffer = (COIBUFFER) buf;\n+  *out_pBuffer = (COIBUFFER) buf;\n \n   return COI_SUCCESS;\n }\n \n \n COIRESULT\n-SYMBOL_VERSION (COIBufferDestroy, 1) (COIBUFFER buffer)\n+SYMBOL_VERSION (COIBufferDestroy, 1) (COIBUFFER in_Buffer)\n {\n   COITRACE (\"COIBufferDestroy\");\n \n   cmd_t cmd = CMD_BUFFER_UNMAP;\n \n+  assert (in_Buffer != NULL);\n+\n   /* Convert input arguments.  */\n-  Buffer *buf = (Buffer *) buffer;\n-  Pipeline *pipeline = buf->process->pipeline;\n+  Buffer *buf = (Buffer *) in_Buffer;\n \n   /* Unmap buffer on host.  */\n   if (buf->data != 0 && buf->type == BUFFER_NORMAL)\n-    if (COIBufferUnmap ((COIMAPINSTANCE) buffer, 0, 0, 0) == COI_ERROR)\n+    if (COIBufferUnmap ((COIMAPINSTANCE) in_Buffer, 0, 0, 0) == COI_ERROR)\n       return COI_ERROR;\n \n   /* Unmap buffer on target.  */\n   if (buf->data_target != 0)\n     {\n-      /* Start critical section.  */\n-      if (pthread_mutex_lock (&mutex) != 0)\n-\tCOIERROR (\"Cannot lock mutex.\");\n+      start_critical_section ();\n \n       /* Send data to target.  */\n-      WRITE (pipeline->pipe_target, &cmd, sizeof (cmd_t));\n-      WRITE (pipeline->pipe_target, &(buf->fd_target), sizeof (int));\n-      WRITE (pipeline->pipe_target, &(buf->data_target), sizeof (void *));\n-      WRITE (pipeline->pipe_target, &(buf->size), sizeof (uint64_t));\n+      int pipe_host2tgt = buf->process->pipe_host2tgt;\n+      WRITE (pipe_host2tgt, &cmd, sizeof (cmd_t));\n+      WRITE (pipe_host2tgt, &buf->fd_target, sizeof (int));\n+      WRITE (pipe_host2tgt, &buf->data_target, sizeof (void *));\n+      WRITE (pipe_host2tgt, &buf->size, sizeof (uint64_t));\n \n-      /* Receive data from  target.  */\n-      READ (pipeline->pipe_host, &cmd, sizeof (cmd_t));\n+      /* Receive data from target.  */\n+      READ (buf->process->pipe_tgt2host, &cmd, sizeof (cmd_t));\n \n-      /* Finish critical section.  */\n-      if (pthread_mutex_unlock (&mutex) != 0)\n-\tCOIERROR (\"Cannot unlock mutex.\");\n+      finish_critical_section ();\n     }\n \n   /* Unlink shared memory.  */\n@@ -462,49 +563,53 @@ SYMBOL_VERSION (COIBufferDestroy, 1) (COIBUFFER buffer)\n     }\n \n   /* Clean up.  */\n-  free (buf);\n+  delete buf;\n \n   return COI_SUCCESS;\n }\n \n \n COIRESULT\n-SYMBOL_VERSION (COIBufferGetSinkAddress, 1) (COIBUFFER buffer,\n-\t\t\t\t\t     uint64_t *data)\n+SYMBOL_VERSION (COIBufferGetSinkAddress, 1) (COIBUFFER in_Buffer,\n+\t\t\t\t\t     uint64_t *out_pAddress)\n {\n   COITRACE (\"COIBufferGetSinkAddress\");\n \n+  assert (in_Buffer != NULL);\n+  assert (out_pAddress != NULL);\n+\n   /* Convert input arguments.  */\n-  Buffer *buf = (Buffer *) buffer;\n+  Buffer *buf = (Buffer *) in_Buffer;\n \n   /* Here should come BUFFER_NORMAL buffer.  */\n   assert (buf->type == BUFFER_NORMAL);\n \n   /* Prepare output argument.  */\n-  *data = (uint64_t) buf->data_target;\n+  *out_pAddress = (uint64_t) buf->data_target;\n \n   return COI_SUCCESS;\n }\n \n \n COIRESULT\n-SYMBOL_VERSION (COIBufferMap, 1) (COIBUFFER buffer,\n-\t\t\t\t  uint64_t offset,\n-\t\t\t\t  uint64_t length,\n-\t\t\t\t  COI_MAP_TYPE type,\t\t    // Ignored\n-\t\t\t\t  uint32_t dependencies_num,\t    // Ignored\n-\t\t\t\t  const COIEVENT *dependencies,     // Ignored\n-\t\t\t\t  COIEVENT *completion,\t\t    // Ignored\n-\t\t\t\t  COIMAPINSTANCE *map_instance,\n-\t\t\t\t  void **data)\n+SYMBOL_VERSION (COIBufferMap, 1) (COIBUFFER in_Buffer,\n+\t\t\t\t  uint64_t in_Offset,\n+\t\t\t\t  uint64_t in_Length,\t\t    // Ignored\n+\t\t\t\t  COI_MAP_TYPE in_Type,\t\t    // Ignored\n+\t\t\t\t  uint32_t in_NumDependencies,\n+\t\t\t\t  const COIEVENT *in_pDependencies, // Ignored\n+\t\t\t\t  COIEVENT *out_pCompletion,\n+\t\t\t\t  COIMAPINSTANCE *out_pMapInstance,\n+\t\t\t\t  void **out_ppData)\n {\n   COITRACE (\"COIBufferMap\");\n \n-  /* Features of liboffload.  */\n-  assert (offset == 0);\n+  /* Features of liboffloadmic.  */\n+  assert (in_Offset == 0);\n+  assert (in_NumDependencies == 0);\n \n   /* Convert input arguments.  */\n-  Buffer *buf = (Buffer *) buffer;\n+  Buffer *buf = (Buffer *) in_Buffer;\n \n   /* Only BUFFER_NORMAL buffers should come here.  */\n   assert (buf->type == BUFFER_NORMAL);\n@@ -516,89 +621,102 @@ SYMBOL_VERSION (COIBufferMap, 1) (COIBUFFER buffer,\n     COIERROR (\"Cannot map shared memory.\");\n \n   /* Prepare output arguments.  */\n-  if (map_instance != 0)\n-    *map_instance = (COIMAPINSTANCE) buf;\n-  if (data != 0)\n-    *data = buf->data;\n+  if (out_pMapInstance != 0)\n+    *out_pMapInstance = (COIMAPINSTANCE) buf;\n+  if (out_ppData != 0)\n+    *out_ppData = buf->data;\n+\n+  if (out_pCompletion)\n+    out_pCompletion->opaque[0] = 0;\n \n   return COI_SUCCESS;\n }\n \n \n COIRESULT\n-SYMBOL_VERSION (COIBufferRead, 1) (COIBUFFER buffer,\n-\t\t\t\t   uint64_t offset,\n-\t\t\t\t   void *data,\n-\t\t\t\t   uint64_t length,\n-\t\t\t\t   COI_COPY_TYPE type,\n-\t\t\t\t   uint32_t dependencies_num,     // Ignored\n-\t\t\t\t   const COIEVENT *dependencies,  // Ignored\n-\t\t\t\t   COIEVENT *completion)\t  // Ignored\n+SYMBOL_VERSION (COIBufferRead, 1) (COIBUFFER in_SourceBuffer,\n+\t\t\t\t   uint64_t in_Offset,\n+\t\t\t\t   void *in_pDestData,\n+\t\t\t\t   uint64_t in_Length,\n+\t\t\t\t   COI_COPY_TYPE in_Type,\n+\t\t\t\t   uint32_t in_NumDependencies,\n+\t\t\t\t   const COIEVENT *in_pDependencies,  // Ignored\n+\t\t\t\t   COIEVENT *out_pCompletion)\n {\n   COITRACE (\"COIBufferRead\");\n \n-  /* Convert input arguments.  */\n-  Buffer *buf = (Buffer *) buffer;\n+  /* Features of liboffloadmic.  */\n+  assert (in_pDestData != NULL);\n+  assert (in_Type == COI_COPY_UNSPECIFIED);\n+  assert (in_NumDependencies == 0);\n \n-  /* Features of liboffload.  */\n-  assert (type == COI_COPY_UNSPECIFIED);\n+  /* Convert input arguments.  */\n+  Buffer *buf = (Buffer *) in_SourceBuffer;\n \n-  /* Start critical section.  */\n-  if (pthread_mutex_lock (&mutex) != 0)\n-    COIERROR (\"Cannot lock mutex.\");\n+  start_critical_section ();\n \n   /* Map buffers if needed.  */\n   if (buf->data == 0 && buf->type == BUFFER_NORMAL)\n-    if (COIBufferMap (buffer, 0, buf->size, (COI_MAP_TYPE) 0,\n-\t\t      0, 0, 0, 0, 0) == COI_ERROR)\n+    if (COIBufferMap (in_SourceBuffer, 0, buf->size, (COI_MAP_TYPE) 0, 0, 0, 0,\n+\t\t      0, 0) == COI_ERROR)\n       return COI_ERROR;\n \n   /* Copy data.  */\n-  memcpy (data, (void *) ((uintptr_t) buf->data+offset), length);\n+  memcpy (in_pDestData, (void *) ((uintptr_t) buf->data + in_Offset),\n+\t  in_Length);\n \n   /* Unmap buffers if needed.  */\n   if (buf->type == BUFFER_NORMAL)\n     if (COIBufferUnmap ((COIMAPINSTANCE) buf, 0, 0, 0) == COI_ERROR)\n       return COI_ERROR;\n \n-  /* Finish critical section.  */\n-  if (pthread_mutex_unlock (&mutex) != 0)\n-    COIERROR (\"Cannot unlock mutex.\");\n+  finish_critical_section ();\n+\n+  if (out_pCompletion)\n+    out_pCompletion->opaque[0] = 0;\n \n   return COI_SUCCESS;\n }\n \n \n COIRESULT\n-SYMBOL_VERSION (COIBufferSetState, 1) (COIBUFFER buffer,\n-\t\t\t\t       COIPROCESS process,\n-\t\t\t\t       COI_BUFFER_STATE state,\n-\t\t\t\t       COI_BUFFER_MOVE_FLAG flag,\n-\t\t\t\t       uint32_t dependencies_num,     // Ignored\n-\t\t\t\t       const COIEVENT *dependencies,  // Ignored\n-\t\t\t\t       COIEVENT *completion)\t      // Ignored\n+SYMBOL_VERSION (COIBufferSetState, 1) (COIBUFFER in_Buffer,\t\t  // Ignored\n+\t\t\t\t       COIPROCESS in_Process,\t\t  // Ignored\n+\t\t\t\t       COI_BUFFER_STATE in_State,\t  // Ignored\n+\t\t\t\t       COI_BUFFER_MOVE_FLAG in_DataMove,\n+\t\t\t\t       uint32_t in_NumDependencies,\n+\t\t\t\t       const COIEVENT *in_pDependencies,  // Ignored\n+\t\t\t\t       COIEVENT *out_pCompletion)\n {\n   COITRACE (\"COIBufferSetState\");\n \n-  /* Features of liboffload.  */\n-  assert (flag == COI_BUFFER_NO_MOVE);\n+  /* Features of liboffloadmic.  */\n+  assert (in_DataMove == COI_BUFFER_NO_MOVE);\n+  assert (in_NumDependencies == 0);\n \n   /* Looks like we have nothing to do here.  */\n \n+  if (out_pCompletion)\n+    out_pCompletion->opaque[0] = 0;\n+\n   return COI_SUCCESS;\n }\n \n \n COIRESULT\n-SYMBOL_VERSION (COIBufferUnmap, 1) (COIMAPINSTANCE map_instance,\n-\t\t\t\t    uint32_t dependencies_num,      // Ignored\n-\t\t\t\t    const COIEVENT *dependencies,   // Ignored\n-\t\t\t\t    COIEVENT *completion)\t    // Ignored\n+SYMBOL_VERSION (COIBufferUnmap, 1) (COIMAPINSTANCE in_MapInstance,\n+\t\t\t\t    uint32_t in_NumDependencies,\n+\t\t\t\t    const COIEVENT *in_pDependencies, // Ignored\n+\t\t\t\t    COIEVENT *out_pCompletion)\n {\n   COITRACE (\"COIBufferUnmap\");\n \n+  /* Features of liboffloadmic.  */\n+  assert (in_MapInstance != NULL);\n+  assert (in_NumDependencies == 0);\n+\n   /* Convert input arguments.  */\n-  Buffer *buffer = (Buffer *) map_instance;\n+  Buffer *buffer = (Buffer *) in_MapInstance;\n \n   /* Only BUFFER_NORMAL buffers should come here.  */\n   assert (buffer->type == BUFFER_NORMAL);\n@@ -609,49 +727,55 @@ SYMBOL_VERSION (COIBufferUnmap, 1) (COIMAPINSTANCE map_instance,\n \n   buffer->data = 0;\n \n+  if (out_pCompletion)\n+    out_pCompletion->opaque[0] = 0;\n+\n   return COI_SUCCESS;\n }\n \n \n COIRESULT\n-SYMBOL_VERSION (COIBufferWrite, 1) (COIBUFFER buffer,\n-\t\t\t\t    uint64_t offset,\n-\t\t\t\t    const void *data,\n-\t\t\t\t    uint64_t length,\n-\t\t\t\t    COI_COPY_TYPE type,\n-\t\t\t\t    uint32_t dependencies_num,    // Ignored\n-\t\t\t\t    const COIEVENT *dependencies, // Ignored\n-\t\t\t\t    COIEVENT *completion)\t  // Ignored\n+SYMBOL_VERSION (COIBufferWrite, 1) (COIBUFFER in_DestBuffer,\n+\t\t\t\t    uint64_t in_Offset,\n+\t\t\t\t    const void *in_pSourceData,\n+\t\t\t\t    uint64_t in_Length,\n+\t\t\t\t    COI_COPY_TYPE in_Type,\n+\t\t\t\t    uint32_t in_NumDependencies,\n+\t\t\t\t    const COIEVENT *in_pDependencies, // Ignored\n+\t\t\t\t    COIEVENT *out_pCompletion)\n {\n   COITRACE (\"COIBufferWrite\");\n \n+  /* Features of liboffloadmic.  */\n+  assert (in_DestBuffer != NULL);\n+  assert (in_pSourceData != NULL);\n+  assert (in_Type == COI_COPY_UNSPECIFIED);\n+  assert (in_NumDependencies == 0);\n+\n   /* Convert input arguments.  */\n-  Buffer *buf = (Buffer *) buffer;\n+  Buffer *buf = (Buffer *) in_DestBuffer;\n \n-  /* Features of liboffload.  */\n-  assert (type == COI_COPY_UNSPECIFIED);\n-\n-  /* Start critical section.  */\n-  if (pthread_mutex_lock (&mutex) != 0)\n-    COIERROR (\"Cannot lock mutex.\");\n+  start_critical_section ();\n \n   /* Map buffers if needed.  */\n   if (buf->data == 0 && buf->type == BUFFER_NORMAL)\n-    if (COIBufferMap (buffer, 0, buf->size, (COI_MAP_TYPE) 0,\n-\t\t      0, 0, 0, 0, 0) == COI_ERROR)\n+    if (COIBufferMap (in_DestBuffer, 0, buf->size, (COI_MAP_TYPE) 0, 0, 0, 0, 0,\n+\t\t      0) == COI_ERROR)\n       return COI_ERROR;\n \n   /* Copy data.  */\n-  memcpy ((void *) ((uintptr_t) buf->data+offset), data, length);\n+  memcpy ((void *) ((uintptr_t) buf->data + in_Offset), in_pSourceData,\n+\t  in_Length);\n \n   /* Unmap buffers if needed.  */\n   if (buf->type == BUFFER_NORMAL)\n     if (COIBufferUnmap ((COIMAPINSTANCE) buf, 0, 0, 0) == COI_ERROR)\n       return COI_ERROR;\n \n-  /* Finish critical section.  */\n-  if (pthread_mutex_unlock (&mutex) != 0)\n-    COIERROR (\"Cannot unlock mutex.\");\n+  finish_critical_section ();\n+\n+  if (out_pCompletion)\n+    out_pCompletion->opaque[0] = 0;\n \n   return COI_SUCCESS;\n }\n@@ -663,8 +787,9 @@ SYMBOL_VERSION (COIEngineGetCount, 1) (COI_ISA_TYPE isa,\n {\n   COITRACE (\"COIEngineGetCount\");\n \n-  /* Features of liboffload.  */\n+  /* Features of liboffloadmic.  */\n   assert (isa == COI_ISA_MIC);\n+  assert (count != NULL);\n \n   /* Prepare output arguments.  */\n   *count = num_engines;\n@@ -674,186 +799,397 @@ SYMBOL_VERSION (COIEngineGetCount, 1) (COI_ISA_TYPE isa,\n \n \n COIRESULT\n-SYMBOL_VERSION (COIEngineGetHandle, 1) (COI_ISA_TYPE isa,\n-\t\t\t\t\tuint32_t index,\n-\t\t\t\t\tCOIENGINE *handle)\n+SYMBOL_VERSION (COIEngineGetHandle, 1) (COI_ISA_TYPE in_ISA,\n+\t\t\t\t\tuint32_t in_EngineIndex,\n+\t\t\t\t\tCOIENGINE *out_pEngineHandle)\n {\n   COITRACE (\"COIEngineGetHandle\");\n \n-  Engine *engine;\n-\n-  /* Features of liboffload.  */\n-  assert (isa == COI_ISA_MIC);\n+  /* Features of liboffloadmic.  */\n+  assert (in_ISA == COI_ISA_MIC);\n+  assert (out_pEngineHandle != NULL);\n \n   /* Check engine index.  */\n-  if (index >= num_engines)\n+  if (in_EngineIndex >= num_engines)\n     COIERROR (\"Wrong engine index.\");\n \n   /* Create engine handle.  */\n-  MALLOC (Engine *, engine, sizeof (Engine));\n+  Engine *engine = new Engine;\n   engine->dir = NULL;\n-  engine->index = index;\n-  engine->type = isa;\n+  engine->index = in_EngineIndex;\n+  engine->type = in_ISA;\n \n   /* Prepare output argument.  */\n-  *handle = (COIENGINE) engine;\n+  *out_pEngineHandle = (COIENGINE) engine;\n \n   return COI_SUCCESS;\n }\n \n \n COIRESULT\n-SYMBOL_VERSION (COIEventWait, 1) (uint16_t events_num,    // Ignored\n-\t\t\t\t  const COIEVENT *events, // Ignored\n-\t\t\t\t  int32_t timeout,\t  // Ignored\n-\t\t\t\t  uint8_t wait_all,\n-\t\t\t\t  uint32_t *signaled_num,\n-\t\t\t\t  uint32_t *signaled_indices)\n+SYMBOL_VERSION (COIEventWait, 1) (uint16_t in_NumEvents,\n+\t\t\t\t  const COIEVENT *in_pEvents,\n+\t\t\t\t  int32_t in_TimeoutMilliseconds,\n+\t\t\t\t  uint8_t in_WaitForAll,\n+\t\t\t\t  uint32_t *out_pNumSignaled,\n+\t\t\t\t  uint32_t *out_pSignaledIndices)\n {\n   COITRACE (\"COIEventWait\");\n \n-  /* Features of liboffload.  */\n-  assert (wait_all == 1);\n-  assert (signaled_num == 0);\n-  assert (signaled_indices == 0);\n+  /* Features of liboffloadmic.  */\n+  assert (in_pEvents != NULL);\n+  assert (in_TimeoutMilliseconds == 0 || in_TimeoutMilliseconds == -1);\n+  assert (in_WaitForAll == 1);\n+  assert (out_pNumSignaled == NULL);\n+  assert (out_pSignaledIndices == NULL);\n \n-  /* Looks like we have nothing to do here.  */\n+  if (in_TimeoutMilliseconds == 0)\n+    {\n+      /* If some event is not signalled, return timeout error.  */\n+      for (uint16_t i = 0; i < in_NumEvents; i++)\n+\tif (non_signalled_events.count (in_pEvents[i].opaque[0]) > 0)\n+\t  return COI_TIME_OUT_REACHED;\n+\telse\n+\t  {\n+\t    /* If the event signalled with an error, return that error.  */\n+\t    start_critical_section ();\n+\t    COIRESULT res = get_event_result (in_pEvents[i]);\n+\t    finish_critical_section ();\n+\t    if (res != COI_SUCCESS)\n+\t      return res;\n+\t  }\n+    }\n+  else\n+    {\n+      /* Wait indefinitely for all events.  */\n+      for (uint16_t i = 0; i < in_NumEvents; i++)\n+\t{\n+\t  while (non_signalled_events.count (in_pEvents[i].opaque[0]) > 0)\n+\t    usleep (1000);\n+\n+\t  /* If the event signalled with an error, return that error.  */\n+\t  start_critical_section ();\n+\t  COIRESULT res = get_event_result (in_pEvents[i]);\n+\t  finish_critical_section ();\n+\t  if (res != COI_SUCCESS)\n+\t    return res;\n+\t}\n+    }\n \n   return COI_SUCCESS;\n }\n \n \n COIRESULT\n-SYMBOL_VERSION (COIPipelineCreate, 1) (COIPROCESS process,\n-\t\t\t\t       COI_CPU_MASK mask,\n-\t\t\t\t       uint32_t stack_size,       // Ignored\n-\t\t\t\t       COIPIPELINE *pipeline)\n+SYMBOL_VERSION (COIEventRegisterCallback, 1) (const COIEVENT in_Event,\n+\t\t\t\t\t      COI_EVENT_CALLBACK in_Callback,\n+\t\t\t\t\t      const void *in_UserData,\n+\t\t\t\t\t      const uint64_t in_Flags)\n {\n-  COITRACE (\"COIPipelineCreate\");\n+  COITRACE (\"COIEventRegisterCallback\");\n \n-  /* Features of liboffload.  */\n-  assert (mask == 0);\n+  /* Features of liboffloadmic.  */\n+  assert (in_Callback != NULL);\n+  assert (in_UserData != NULL);\n+  assert (in_Flags == 0);\n \n-  /* Prepare output arguments.  */\n-  *pipeline = (COIPIPELINE) ((Process *) process)->pipeline;\n+  start_critical_section ();\n+  if (non_signalled_events.count (in_Event.opaque[0]) == 0)\n+    {\n+      /* If the event is already signalled, invoke the callback immediately.  */\n+      COIRESULT res = get_event_result (in_Event);\n+      in_Callback (in_Event, res, in_UserData);\n+    }\n+  else\n+    {\n+      Callback callback;\n+      callback.ptr = in_Callback;\n+      callback.data = in_UserData;\n+      callbacks.insert (std::pair <uint64_t, Callback> (in_Event.opaque[0],\n+\t\t\t\t\t\t\tcallback));\n+    }\n+  finish_critical_section ();\n \n   return COI_SUCCESS;\n }\n \n \n+/* The start routine for the COI pipeline thread.  */\n+\n+static void *\n+pipeline_thread_routine (void *in_Pipeline)\n+{\n+  /* Convert input arguments.  */\n+  Pipeline *pipeline = (Pipeline *) in_Pipeline;\n+\n+  /* Open pipes.  */\n+  pipeline->pipe_host2tgt\n+    = open (pipeline->pipe_host2tgt_path, O_CLOEXEC | O_WRONLY);\n+  if (pipeline->pipe_host2tgt < 0)\n+    COIERRORN (\"Cannot open host-to-target pipe.\");\n+  pipeline->pipe_tgt2host\n+    = open (pipeline->pipe_tgt2host_path, O_CLOEXEC | O_RDONLY);\n+  if (pipeline->pipe_tgt2host < 0)\n+    COIERRORN (\"Cannot open target-to-host pipe.\");\n+\n+  free (pipeline->pipe_host2tgt_path);\n+  free (pipeline->pipe_tgt2host_path);\n+  pipeline->pipe_host2tgt_path = NULL;\n+  pipeline->pipe_tgt2host_path = NULL;\n+\n+  while (!pipeline->destroy)\n+    if (pipeline->queue.empty ())\n+      usleep (1000);\n+    else\n+      {\n+\tFunction func = pipeline->queue.front ();\n+\tstart_critical_section ();\n+\tpipeline->queue.pop ();\n+\tfinish_critical_section ();\n+\n+\t/* Send data to target.  */\n+\tcmd_t cmd = CMD_PIPELINE_RUN_FUNCTION;\n+\tWRITEN (pipeline->pipe_host2tgt, &cmd, sizeof (cmd_t));\n+\tWRITEN (pipeline->pipe_host2tgt, &func.ptr, sizeof (void *));\n+\tWRITEN (pipeline->pipe_host2tgt, &func.num_buffers, sizeof (uint32_t));\n+\tfor (uint32_t i = 0; i < func.num_buffers; i++)\n+\t  {\n+\t    WRITEN (pipeline->pipe_host2tgt, &func.bufs_size[i],\n+\t\t    sizeof (uint64_t));\n+\t    WRITEN (pipeline->pipe_host2tgt, &func.bufs_data_target[i],\n+\t\t    sizeof (void *));\n+\t  }\n+\tWRITEN (pipeline->pipe_host2tgt, &func.misc_data_len,\n+\t\tsizeof (uint16_t));\n+\tif (func.misc_data_len > 0)\n+\t  WRITEN (pipeline->pipe_host2tgt, func.misc_data, func.misc_data_len);\n+\tWRITEN (pipeline->pipe_host2tgt, &func.return_value_len,\n+\t\tsizeof (uint16_t));\n+\n+\tdelete [] func.bufs_size;\n+\tdelete [] func.bufs_data_target;\n+\n+\t/* Receive data from target.  Wait for target function to complete,\n+\t   whether it has any data to return or not.  */\n+\tbool has_return_value = func.return_value_len > 0;\n+\tint ret_len\n+\t  = read (pipeline->pipe_tgt2host,\n+\t\t  has_return_value ? func.return_value : &cmd,\n+\t\t  has_return_value ? func.return_value_len : sizeof (cmd_t));\n+\tif (ret_len == 0)\n+\t  {\n+\t    start_critical_section ();\n+\t    signal_event (func.completion_event, COI_PROCESS_DIED);\n+\t    pipeline->is_destroyed = true;\n+\t    finish_critical_section ();\n+\t    return NULL;\n+\t  }\n+\telse if (ret_len != (has_return_value ? func.return_value_len\n+\t\t\t\t\t      : sizeof (cmd_t)))\n+\t  COIERRORN (\"Cannot read from pipe.\");\n+\n+\tstart_critical_section ();\n+\tsignal_event (func.completion_event, COI_SUCCESS);\n+\tfinish_critical_section ();\n+      }\n+\n+  /* Send data to target.  */\n+  const cmd_t cmd = CMD_PIPELINE_DESTROY;\n+  WRITEN (pipeline->pipe_host2tgt, &cmd, sizeof (cmd_t));\n+\n+  /* Close pipes.  */\n+  if (close (pipeline->pipe_host2tgt) < 0)\n+    COIERRORN (\"Cannot close host-to-target pipe.\");\n+  if (close (pipeline->pipe_tgt2host) < 0)\n+    COIERRORN (\"Cannot close target-to-host pipe.\");\n+\n+  start_critical_section ();\n+  pipeline->is_destroyed = true;\n+  finish_critical_section ();\n+  return NULL;\n+}\n+\n+\n COIRESULT\n-SYMBOL_VERSION (COIPipelineDestroy, 1) (COIPIPELINE pipeline)\n+SYMBOL_VERSION (COIPipelineCreate, 1) (COIPROCESS in_Process,\n+\t\t\t\t       COI_CPU_MASK in_Mask,\n+\t\t\t\t       uint32_t in_StackSize,\t    // Ignored\n+\t\t\t\t       COIPIPELINE *out_pPipeline)\n {\n-  COITRACE (\"COIPipelineDestroy\");\n+  COITRACE (\"COIPipelineCreate\");\n+\n+  /* Features of liboffloadmic.  */\n+  assert (in_Process != NULL);\n+  assert (in_Mask == 0);\n+  assert (out_pPipeline != NULL);\n+\n+  /* Convert input arguments.  */\n+  Process *proc = (Process *) in_Process;\n+\n+  start_critical_section ();\n+\n+  /* Create pipeline handle.  */\n+  Pipeline *pipeline = new Pipeline;\n+  pipeline->destroy = false;\n+  pipeline->is_destroyed = false;\n+  pipeline->process = proc;\n+  pipelines.insert (pipeline);\n+\n+  /* Create pipes.  */\n+  uint32_t pipeline_num = max_pipeline_num++;\n+  char *eng_dir = pipeline->process->engine->dir;\n+  MALLOC (char *, pipeline->pipe_host2tgt_path,\n+\t  strlen (eng_dir) + sizeof (PIPE_HOST2TGT_NAME \"0000000000\"));\n+  MALLOC (char *, pipeline->pipe_tgt2host_path,\n+\t  strlen (eng_dir) + sizeof (PIPE_TGT2HOST_NAME \"0000000000\"));\n+  sprintf (pipeline->pipe_host2tgt_path, \"%s\" PIPE_HOST2TGT_NAME \"%010d\",\n+\t   eng_dir, pipeline_num);\n+  sprintf (pipeline->pipe_tgt2host_path, \"%s\" PIPE_TGT2HOST_NAME \"%010d\",\n+\t   eng_dir, pipeline_num);\n+  if (mkfifo (pipeline->pipe_host2tgt_path, S_IRUSR | S_IWUSR) < 0)\n+    COIERROR (\"Cannot create pipe %s.\", pipeline->pipe_host2tgt_path);\n+  if (mkfifo (pipeline->pipe_tgt2host_path, S_IRUSR | S_IWUSR) < 0)\n+    COIERROR (\"Cannot create pipe %s.\", pipeline->pipe_tgt2host_path);\n \n-  /* Do nothing here. Pipeline will be closed during COIProcessDestroy.  */\n+  /* Send data to target.  */\n+  const cmd_t cmd = CMD_PIPELINE_CREATE;\n+  WRITE (proc->pipe_host2tgt, &cmd, sizeof (cmd_t));\n+  WRITE (proc->pipe_host2tgt, &pipeline_num, sizeof (pipeline_num));\n+\n+  /* Create a new thread for the pipeline.  */\n+  if (pthread_create (&pipeline->thread, NULL, pipeline_thread_routine,\n+\t\t      pipeline))\n+    COIERROR (\"Cannot create new thread.\");\n+\n+  finish_critical_section ();\n+\n+  /* Prepare output arguments.  */\n+  *out_pPipeline = (COIPIPELINE) pipeline;\n \n   return COI_SUCCESS;\n }\n \n \n COIRESULT\n-SYMBOL_VERSION (COIPipelineRunFunction, 1) (COIPIPELINE pipeline,\n-\t\t\t\t\t    COIFUNCTION function,\n-\t\t\t\t\t    uint32_t buffers_num,\n-\t\t\t\t\t    const COIBUFFER *buffers,\n-\t\t\t\t\t    const COI_ACCESS_FLAGS *access_flags, // Ignored\n-\t\t\t\t\t    uint32_t dependencies_num,\t\t  // Ignored\n-\t\t\t\t\t    const COIEVENT *dependencies,\t  // Ignored\n-\t\t\t\t\t    const void *misc_data,\n-\t\t\t\t\t    uint16_t misc_data_len,\n-\t\t\t\t\t    void *return_data,\n-\t\t\t\t\t    uint16_t return_data_len,\n-\t\t\t\t\t    COIEVENT *completion)\t\t  // Ignored\n+SYMBOL_VERSION (COIPipelineDestroy, 1) (COIPIPELINE in_Pipeline)\n {\n-  COITRACE (\"COIPipelineRunFunction\");\n+  COITRACE (\"COIPipelineDestroy\");\n \n-  cmd_t cmd = CMD_RUN_FUNCTION;\n-  int ret_len;\n-  uint32_t i;\n-  uint64_t size;\n-  void *ptr;\n+  assert (in_Pipeline != NULL);\n \n   /* Convert input arguments.  */\n-  Buffer **bufs = (Buffer **) buffers;\n-  Function *func = (Function *) function;\n-  Pipeline *pipe = (Pipeline *) pipeline;\n+  Pipeline *pipeline = (Pipeline *) in_Pipeline;\n \n-  /* Start critical section.  */\n-  if (pthread_mutex_lock (&mutex) != 0)\n-    COIERROR (\"Cannot lock mutex.\");\n+  start_critical_section ();\n+  /* Remove pipeline from the set of undestroyed pipelines.  */\n+  pipelines.erase (pipeline);\n \n-  /* Send data to target.  */\n-  WRITE (pipe->pipe_target, &cmd, sizeof (cmd_t));\n-  WRITE (pipe->pipe_target, &(func->ptr), sizeof (void *));\n-  WRITE (pipe->pipe_target, &buffers_num, sizeof (uint32_t));\n-  for (i = 0; i < buffers_num; i++)\n+  /* Exit pipeline thread.  */\n+  pipeline->destroy = true;\n+  finish_critical_section ();\n+\n+  while (!pipeline_is_destroyed (pipeline))\n+    usleep (1000);\n+\n+  /* Join with a destroyed thread.  */\n+  if (pthread_join (pipeline->thread, NULL))\n+    COIERROR (\"Cannot join with a thread.\");\n+\n+  delete pipeline;\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIPipelineRunFunction, 1) (COIPIPELINE in_Pipeline,\n+\t\t\t\t\t    COIFUNCTION in_Function,\n+\t\t\t\t\t    uint32_t in_NumBuffers,\n+\t\t\t\t\t    const COIBUFFER *in_Buffers,\n+\t\t\t\t\t    const COI_ACCESS_FLAGS *in_pBufferAccessFlags, // Ignored\n+\t\t\t\t\t    uint32_t in_NumDependencies,\n+\t\t\t\t\t    const COIEVENT *in_pDependencies,\t\t   // Ignored\n+\t\t\t\t\t    const void *in_pMiscData,\n+\t\t\t\t\t    uint16_t in_MiscDataLen,\n+\t\t\t\t\t    void *out_pAsyncReturnValue,\n+\t\t\t\t\t    uint16_t in_AsyncReturnValueLen,\n+\t\t\t\t\t    COIEVENT *out_pCompletion)\n+{\n+  COITRACE (\"COIPipelineRunFunction\");\n+\n+  /* Features of liboffloadmic.  */\n+  assert (in_Pipeline != NULL);\n+  assert (in_Function != NULL);\n+  assert (in_NumDependencies == 0);\n+\n+  Function func;\n+  func.ptr = (void *) in_Function;\n+  func.num_buffers = in_NumBuffers;\n+  func.bufs_size = new uint64_t [in_NumBuffers];\n+  func.bufs_data_target = new void * [in_NumBuffers];\n+  for (uint32_t i = 0; i < in_NumBuffers; i++)\n     {\n-      WRITE (pipe->pipe_target, &(bufs[i]->size), sizeof (uint64_t));\n-      WRITE (pipe->pipe_target, &(bufs[i]->data_target), sizeof (void *));\n+      Buffer **bufs = (Buffer **) in_Buffers;\n+      func.bufs_size[i] = bufs[i]->size;\n+      func.bufs_data_target[i] = bufs[i]->data_target;\n     }\n-  WRITE (pipe->pipe_target, &misc_data_len, sizeof (uint16_t));\n-  if (misc_data_len > 0)\n-    WRITE (pipe->pipe_target, misc_data, misc_data_len);\n-  WRITE (pipe->pipe_target, &return_data_len, sizeof (uint16_t));\n-\n-  /* Receive data from target.  In emulator we don't need any asynchronous data\n-     transfer, so we wait for target process whether it has any data or not.  */\n-  ret_len = read (pipe->pipe_host, return_data_len > 0 ? return_data : &cmd,\n-\treturn_data_len > 0 ? return_data_len : sizeof (cmd_t));\n-  if (ret_len == 0)\n-    return COI_PROCESS_DIED;\n-  else if (ret_len != (return_data_len > 0 ? return_data_len : sizeof (cmd_t)))\n-    COIERROR (\"Cannot read from pipe.\");\n-\n-  /* Finish critical section.  */\n-  if (pthread_mutex_unlock (&mutex) != 0)\n-    COIERROR (\"Cannot unlock mutex.\");\n+  func.misc_data = (void *) in_pMiscData;\n+  func.misc_data_len = in_MiscDataLen;\n+  func.return_value = out_pAsyncReturnValue;\n+  func.return_value_len = in_AsyncReturnValueLen;\n+\n+  start_critical_section ();\n+  func.completion_event.opaque[0] = max_event_num++;\n+  non_signalled_events.insert (func.completion_event.opaque[0]);\n+  ((Pipeline *) in_Pipeline)->queue.push (func);\n+  finish_critical_section ();\n+\n+  /* In case of synchronous execution we have to wait for target.  */\n+  if (out_pCompletion == NULL)\n+    COIEventWait (1, &func.completion_event, -1, 1, NULL, NULL);\n+  else\n+    *out_pCompletion = func.completion_event;\n \n   return COI_SUCCESS;\n }\n \n \n COIRESULT\n-SYMBOL_VERSION (COIProcessCreateFromMemory, 1) (COIENGINE engine,\n-\t\t\t\t\t\tconst char *bin_name,\n-\t\t\t\t\t\tconst void *bin_buffer,\n-\t\t\t\t\t\tuint64_t bin_buffer_len,\n-\t\t\t\t\t\tint argc,\n-\t\t\t\t\t\tconst char **argv,\n-\t\t\t\t\t\tuint8_t inherit_env,\n-\t\t\t\t\t\tconst char **additional_env,\n-\t\t\t\t\t\tuint8_t proxy_active,\t\t  // Ignored\n-\t\t\t\t\t\tconst char *proxyfs_root,\t  // Ignored\n-\t\t\t\t\t\tuint64_t buffer_space,\t\t  // Ignored\n-\t\t\t\t\t\tconst char *lib_search_path,\n-\t\t\t\t\t\tconst char *file_of_origin,       // Ignored\n-\t\t\t\t\t\tuint64_t file_of_origin_offset,   // Ignored\n-\t\t\t\t\t\tCOIPROCESS *process)\n+SYMBOL_VERSION (COIProcessCreateFromMemory, 1) (COIENGINE in_Engine,\n+\t\t\t\t\t\tconst char *in_pBinaryName,\n+\t\t\t\t\t\tconst void *in_pBinaryBuffer,\n+\t\t\t\t\t\tuint64_t in_BinaryBufferLength,\n+\t\t\t\t\t\tint in_Argc,\n+\t\t\t\t\t\tconst char **in_ppArgv,\n+\t\t\t\t\t\tuint8_t in_DupEnv,\n+\t\t\t\t\t\tconst char **in_ppAdditionalEnv,\n+\t\t\t\t\t\tuint8_t in_ProxyActive,\t\t// Ignored\n+\t\t\t\t\t\tconst char *in_Reserved,\t// Ignored\n+\t\t\t\t\t\tuint64_t in_InitialBufferSpace,\t// Ignored\n+\t\t\t\t\t\tconst char *in_LibrarySearchPath,\n+\t\t\t\t\t\tconst char *in_FileOfOrigin,    // Ignored\n+\t\t\t\t\t\tuint64_t in_FileOfOriginOffset,\t// Ignored\n+\t\t\t\t\t\tCOIPROCESS *out_pProcess)\n {\n   COITRACE (\"COIProcessCreateFromMemory\");\n \n   const int run_max_args_num = 128;\n-  char **envp;\n   char *run_argv[run_max_args_num];\n   char *emul_run = getenv (OFFLOAD_EMUL_RUN_ENV);\n-  char *env_name, *tok;\n-  char *pipe_host_path, *pipe_target_path, *pipes_path, *target_exe;\n-  FILE *file;\n-  int fd;\n-  int i, j, env_i, env_num;\n-  int pipe_host, pipe_target;\n   const int uint_max_len = 11;\n-  pid_t pid;\n-  Pipeline *pipeline;\n-  Process *proc;\n \n-  /* Features of liboffload.  */\n-  assert (argc == 0);\n-  assert (argv == 0);\n+  /* Features of liboffloadmic.  */\n+  assert (in_Engine != NULL);\n+  assert (in_pBinaryName != NULL);\n+  assert (in_pBinaryBuffer != NULL);\n+  assert (in_Argc == 0);\n+  assert (in_ppArgv == NULL);\n+  assert (in_ppAdditionalEnv == NULL);\n+  assert (in_LibrarySearchPath != NULL);\n+  assert (out_pProcess != NULL);\n \n   /* Convert input arguments.  */\n-  Engine *eng = (Engine *) engine;\n+  Engine *eng = (Engine *) in_Engine;\n \n   /* Create temporary directory for engine files.  */\n   assert (eng->dir == NULL);\n@@ -869,15 +1205,17 @@ SYMBOL_VERSION (COIProcessCreateFromMemory, 1) (COIENGINE engine,\n   STRDUP (tmp_dirs[tmp_dirs_num - 1], eng->dir);\n \n   /* Create target executable file.  */\n-  MALLOC (char *, target_exe, strlen (eng->dir) + strlen (bin_name) + 2);\n-  sprintf (target_exe, \"%s/%s\", eng->dir, bin_name);\n-  fd = open (target_exe, O_CLOEXEC | O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR);\n+  char *target_exe;\n+  MALLOC (char *, target_exe, strlen (eng->dir) + strlen (in_pBinaryName) + 2);\n+  sprintf (target_exe, \"%s/%s\", eng->dir, in_pBinaryName);\n+  int fd = open (target_exe, O_CLOEXEC | O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR);\n   if (fd < 0)\n     COIERROR (\"Cannot create file %s.\", target_exe);\n-  file = fdopen (fd, \"wb\");\n+  FILE *file = fdopen (fd, \"wb\");\n   if (file == NULL)\n     COIERROR (\"Cannot associate stream with file descriptor.\");\n-  if (fwrite (bin_buffer, 1, bin_buffer_len, file) != bin_buffer_len)\n+  if (fwrite (in_pBinaryBuffer, 1, in_BinaryBufferLength, file)\n+      != in_BinaryBufferLength)\n     COIERROR (\"Cannot write in file %s.\", target_exe);\n   if (fclose (file) != 0)\n     COIERROR (\"Cannot close file %s.\", target_exe);\n@@ -887,24 +1225,24 @@ SYMBOL_VERSION (COIProcessCreateFromMemory, 1) (COIENGINE engine,\n     COIERROR (\"Cannot change permissions for file %s.\", target_exe);\n \n   /* Create directory for pipes to prevent names collision.  */\n-  MALLOC (char *, pipes_path, strlen (PIPES_PATH) + strlen (eng->dir) + 1);\n+  char *pipes_path;\n+  MALLOC (char *, pipes_path, strlen (eng->dir) + sizeof (PIPES_PATH));\n   sprintf (pipes_path, \"%s\" PIPES_PATH, eng->dir);\n   if (mkdir (pipes_path, S_IRWXU) < 0)\n     COIERROR (\"Cannot create folder %s.\", pipes_path);\n \n-  /* Create pipes.  */\n-  MALLOC (char *, pipe_host_path,\n-\t  strlen (PIPE_HOST_PATH) + strlen (eng->dir) + 1);\n-  MALLOC (char *, pipe_target_path,\n-\t  strlen (PIPE_TARGET_PATH) + strlen (eng->dir) + 1);\n-  if (pipe_target_path == NULL)\n-    COIERROR (\"Cannot allocate memory.\");\n-  sprintf (pipe_host_path, \"%s\" PIPE_HOST_PATH, eng->dir);\n-  sprintf (pipe_target_path, \"%s\" PIPE_TARGET_PATH, eng->dir);\n-  if (mkfifo (pipe_host_path, S_IRUSR | S_IWUSR) < 0)\n-    COIERROR (\"Cannot create pipe %s.\", pipe_host_path);\n-  if (mkfifo (pipe_target_path, S_IRUSR | S_IWUSR) < 0)\n-    COIERROR (\"Cannot create pipe %s.\", pipe_target_path);\n+  /* Create 2 main pipes for inter-process communication.  */\n+  char *pipe_host2tgt_path, *pipe_tgt2host_path;\n+  MALLOC (char *, pipe_host2tgt_path,\n+\t  strlen (eng->dir) + sizeof (PIPE_HOST2TGT_NAME \"mainpipe\"));\n+  MALLOC (char *, pipe_tgt2host_path,\n+\t  strlen (eng->dir) + sizeof (PIPE_TGT2HOST_NAME \"mainpipe\"));\n+  sprintf (pipe_host2tgt_path, \"%s\" PIPE_HOST2TGT_NAME \"mainpipe\", eng->dir);\n+  sprintf (pipe_tgt2host_path, \"%s\" PIPE_TGT2HOST_NAME \"mainpipe\", eng->dir);\n+  if (mkfifo (pipe_host2tgt_path, S_IRUSR | S_IWUSR) < 0)\n+    COIERROR (\"Cannot create main pipe %s.\", pipe_host2tgt_path);\n+  if (mkfifo (pipe_tgt2host_path, S_IRUSR | S_IWUSR) < 0)\n+    COIERROR (\"Cannot create main pipe %s.\", pipe_tgt2host_path);\n \n   /* Prepare argv.  */\n   if (emul_run == NULL || strcmp (emul_run, \"\") == 0)\n@@ -915,9 +1253,9 @@ SYMBOL_VERSION (COIProcessCreateFromMemory, 1) (COIENGINE engine,\n   else\n     {\n       char *ptr, *tmp;\n-      i = 0;\n+      int i = 0;\n       STRDUP (tmp, emul_run);\n-      tok = strtok_r (tmp, \" \", &ptr);\n+      char *tok = strtok_r (tmp, \" \", &ptr);\n       while (tok != NULL)\n \t{\n \t  if (i >= run_max_args_num)\n@@ -926,25 +1264,25 @@ SYMBOL_VERSION (COIProcessCreateFromMemory, 1) (COIENGINE engine,\n \t  tok = strtok_r (NULL, \" \", &ptr);\n \t}\n       STRDUP (run_argv[i], target_exe);\n-      run_argv[i+1] = (char *) NULL;\n+      run_argv[i + 1] = (char *) NULL;\n       free (tmp);\n     }\n \n   /* Prepare envp.  */\n-  /* FIXME: take into account additional_env.  */\n-  assert (additional_env == NULL);\n-\n-  env_num = 0;\n-  if (inherit_env == true)\n+  int env_num = 0;\n+  if (in_DupEnv == true)\n     while (environ[env_num++]);\n   env_num += 4; // LD_LIBRARY_PATH, MIC_DIR, MIC_INDEX, NULL\n \n+  char **envp;\n   MALLOC (char **, envp, env_num * sizeof (char *));\n \n-  env_i = 0;\n-  if (inherit_env == true)\n-    for (i = 0; environ[i] != NULL; i++)\n+  int env_i = 0;\n+  if (in_DupEnv == true)\n+    for (unsigned i = 0; environ[i] != NULL; i++)\n       {\n+\tunsigned j;\n+\tchar *env_name;\n \tSTRDUP (env_name, environ[i]);\n \tfor (j = 0; env_name[j] != '=' && env_name[j] != '\\0'; j++);\n \tenv_name[j] = '\\0';\n@@ -958,17 +1296,17 @@ SYMBOL_VERSION (COIProcessCreateFromMemory, 1) (COIENGINE engine,\n   MALLOC (char *, envp[env_i], strlen (MIC_DIR_ENV) + strlen (eng->dir) + 2);\n   sprintf (envp[env_i], \"%s=%s\", MIC_DIR_ENV, eng->dir);\n \n-  MALLOC (char *, envp[env_i+1], strlen (MIC_INDEX_ENV) + uint_max_len + 1);\n-  sprintf (envp[env_i+1], \"%s=%u\", MIC_INDEX_ENV, eng->index);\n+  MALLOC (char *, envp[env_i + 1], strlen (MIC_INDEX_ENV) + uint_max_len + 1);\n+  sprintf (envp[env_i + 1], \"%s=%u\", MIC_INDEX_ENV, eng->index);\n \n-  MALLOC (char *, envp[env_i+2],\n-\t  strlen (\"LD_LIBRARY_PATH=\") + strlen (lib_search_path) + 1);\n-  sprintf (envp[env_i+2], \"LD_LIBRARY_PATH=%s\", lib_search_path);\n+  MALLOC (char *, envp[env_i + 2],\n+\t  strlen (\"LD_LIBRARY_PATH=\") + strlen (in_LibrarySearchPath) + 1);\n+  sprintf (envp[env_i + 2], \"LD_LIBRARY_PATH=%s\", in_LibrarySearchPath);\n \n-  envp[env_i+3] = (char *) NULL;\n+  envp[env_i + 3] = (char *) NULL;\n \n   /* Create target process.  */\n-  pid = vfork ();\n+  pid_t pid = vfork ();\n   if (pid < 0)\n     COIERROR (\"Cannot create child process.\");\n \n@@ -979,37 +1317,33 @@ SYMBOL_VERSION (COIProcessCreateFromMemory, 1) (COIENGINE engine,\n \tCOIERROR (\"Cannot execute file %s.\", target_exe);\n     }\n \n-  /* Open pipes.  */\n-  pipe_host = open (pipe_host_path, O_CLOEXEC | O_RDONLY);\n-  if (pipe_host < 0)\n-    COIERROR (\"Cannot open target-to-host pipe.\");\n-  pipe_target = open (pipe_target_path, O_CLOEXEC | O_WRONLY);\n-  if (pipe_target < 0)\n-    COIERROR (\"Cannot open host-to-target pipe.\");\n-\n-  /* Create pipeline handle.  */\n-  MALLOC (Pipeline *, pipeline, sizeof (Pipeline));\n-  pipeline->pipe_host = pipe_host;\n-  pipeline->pipe_target = pipe_target;\n+  /* Open main pipes.  */\n+  int pipe_host2tgt = open (pipe_host2tgt_path, O_CLOEXEC | O_WRONLY);\n+  if (pipe_host2tgt < 0)\n+    COIERROR (\"Cannot open host-to-target main pipe.\");\n+  int pipe_tgt2host = open (pipe_tgt2host_path, O_CLOEXEC | O_RDONLY);\n+  if (pipe_tgt2host < 0)\n+    COIERROR (\"Cannot open target-to-host main pipe.\");\n \n   /* Create process handle.  */\n-  MALLOC (Process *, proc, sizeof (Process));\n+  Process *proc = new Process;\n   proc->pid = pid;\n+  proc->pipe_host2tgt = pipe_host2tgt;\n+  proc->pipe_tgt2host = pipe_tgt2host;\n   proc->engine = eng;\n-  proc->functions = 0;\n-  proc->pipeline = pipeline;\n+  proc->functions = NULL;\n \n   /* Prepare output arguments.  */\n-  *process = (COIPROCESS) proc;\n+  *out_pProcess = (COIPROCESS) proc;\n \n   /* Clean up.  */\n-  for (i = 0; run_argv[i] != NULL; i++)\n+  for (unsigned i = 0; run_argv[i] != NULL; i++)\n     free (run_argv[i]);\n-  for (i = 0; envp[i] != NULL; i++)\n+  for (unsigned i = 0; envp[i] != NULL; i++)\n     free (envp[i]);\n   free (envp);\n-  free (pipe_host_path);\n-  free (pipe_target_path);\n+  free (pipe_host2tgt_path);\n+  free (pipe_tgt2host_path);\n   free (pipes_path);\n   free (target_exe);\n \n@@ -1039,109 +1373,101 @@ SYMBOL_VERSION (COIProcessCreateFromFile, 1) (COIENGINE in_Engine,\n \n \n COIRESULT\n-SYMBOL_VERSION (COIProcessDestroy, 1) (COIPROCESS process,\n-\t\t\t\t       int32_t wait_timeout,      // Ignored\n-\t\t\t\t       uint8_t force,\n-\t\t\t\t       int8_t *proc_return,\n-\t\t\t\t       uint32_t *reason)\n+SYMBOL_VERSION (COIProcessDestroy, 1) (COIPROCESS in_Process,\n+\t\t\t\t       int32_t in_WaitForMainTimeout, // Ignored\n+\t\t\t\t       uint8_t in_ForceDestroy,\n+\t\t\t\t       int8_t *out_pProcessReturn,\n+\t\t\t\t       uint32_t *out_pTerminationCode)\n {\n   COITRACE (\"COIProcessDestroy\");\n \n-  int i;\n+  assert (in_Process != NULL);\n+  assert (out_pProcessReturn != NULL);\n+  assert (out_pTerminationCode != NULL);\n \n   /* Convert input arguments.  */\n-  Process *proc = (Process *) process;\n+  Process *proc = (Process *) in_Process;\n \n-  /* Close pipeline.  */\n-  if (close (proc->pipeline->pipe_host) < 0)\n-    COIERROR (\"Cannot close target-to-host pipe.\");\n-  if (close (proc->pipeline->pipe_target) < 0)\n-    COIERROR (\"Cannot close host-to-target pipe.\");\n-  free (proc->pipeline);\n+  /* Destroy all undestroyed pipelines.  */\n+  while (!pipelines.empty ())\n+    {\n+      std::set<Pipeline *>::iterator p = pipelines.begin ();\n+      COIPipelineDestroy ((COIPIPELINE) *p);\n+    }\n+\n+  /* Close main pipes.  */\n+  if (close (proc->pipe_host2tgt) < 0)\n+    COIERROR (\"Cannot close host-to-target main pipe.\");\n+  if (close (proc->pipe_tgt2host) < 0)\n+    COIERROR (\"Cannot close target-to-host main pipe.\");\n \n   /* Shutdown target process by force.  */\n-  if (force)\n+  if (in_ForceDestroy)\n     kill (proc->pid, SIGTERM);\n \n   /* Clean up.  */\n-  for (i = 0; proc->functions[i] != 0; i++)\n-    {\n-      free (proc->functions[i]->name);\n-      free (proc->functions[i]);\n-    }\n   free (proc->engine->dir);\n-  free (proc->engine);\n   free (proc->functions);\n-  free (proc);\n+  delete proc->engine;\n+  delete proc;\n \n   /* Prepare output arguments.  */\n-  *proc_return = 0;\n-  *reason = 0;\n+  *out_pProcessReturn = 0;\n+  *out_pTerminationCode = 0;\n \n   return COI_SUCCESS;\n }\n \n \n COIRESULT\n-SYMBOL_VERSION (COIProcessGetFunctionHandles, 1) (COIPROCESS process,\n-\t\t\t\t\t\t  uint32_t functions_num,\n-\t\t\t\t\t\t  const char **function_names,\n-\t\t\t\t\t\t  COIFUNCTION *function_handles)\n+SYMBOL_VERSION (COIProcessGetFunctionHandles, 1) (COIPROCESS in_Process,\n+\t\t\t\t\t\t  uint32_t in_NumFunctions,\n+\t\t\t\t\t\t  const char **in_ppFunctionNameArray,\n+\t\t\t\t\t\t  COIFUNCTION *out_pFunctionHandleArray)\n {\n   COITRACE (\"COIProcessGetFunctionHandles\");\n \n-  cmd_t cmd = CMD_GET_FUNCTION_HANDLE;\n-  Function *function;\n-  size_t len;\n-  void *ptr;\n-  uint32_t i;\n+  assert (in_Process != NULL);\n+  assert (in_ppFunctionNameArray != NULL);\n+  assert (out_pFunctionHandleArray != NULL);\n \n   /* Convert input arguments.  */\n-  Process *proc = (Process *) process;\n+  Process *proc = (Process *) in_Process;\n \n   /* This function should be called once for the process.  */\n-  assert (proc->functions == 0);\n+  assert (proc->functions == NULL);\n \n-  /* Create array of function pointers.  Last element is 0, what shows\n-     the end of the array.  This array is used to free memory when process\n-     is destroyed.  */\n-  proc->functions = (Function **) calloc (functions_num + 1,\n-\t\t\t\t\t  sizeof (Function *));\n+  /* Create array of function pointers.  Last element is 0, what shows the end\n+     of the array.  This array is used to free memory when process is\n+     destroyed.  */\n+  proc->functions = (void **) calloc (in_NumFunctions + 1, sizeof (void *));\n   if (proc->functions == NULL)\n     COIERROR (\"Cannot allocate memory.\");\n \n   /* Get handles for functions.  */\n-  for (i = 0; i < functions_num; i++)\n+  for (uint32_t i = 0; i < in_NumFunctions; i++)\n     {\n-      MALLOC (Function *, function, sizeof (Function));\n-\n-      len = strlen (function_names[i]) + 1;\n+      size_t len = strlen (in_ppFunctionNameArray[i]) + 1;\n \n-      /* Start critical section.  */\n-      if (pthread_mutex_lock (&mutex) != 0)\n-\tCOIERROR (\"Cannot lock mutex.\");\n+      start_critical_section ();\n \n       /* Send data to target.  */\n-      WRITE (proc->pipeline->pipe_target, &cmd, sizeof (cmd_t));\n-      WRITE (proc->pipeline->pipe_target, &len, sizeof (size_t));\n-      WRITE (proc->pipeline->pipe_target, function_names[i], len);\n+      const cmd_t cmd = CMD_GET_FUNCTION_HANDLE;\n+      WRITE (proc->pipe_host2tgt, &cmd, sizeof (cmd_t));\n+      WRITE (proc->pipe_host2tgt, &len, sizeof (size_t));\n+      WRITE (proc->pipe_host2tgt, in_ppFunctionNameArray[i], len);\n \n-      /* Receive data from  target.  */\n-      READ (proc->pipeline->pipe_host, &ptr, sizeof (void *));\n+      /* Receive data from target.  */\n+      void *fn_ptr;\n+      READ (proc->pipe_tgt2host, &fn_ptr, sizeof (void *));\n \n-      /* Finish critical section.  */\n-      if (pthread_mutex_unlock (&mutex) != 0)\n-\tCOIERROR (\"Cannot unlock mutex.\");\n-\n-      /* Prepare output arguments.  */\n-      STRDUP (function->name, function_names[i]);\n-      if (function->name == NULL)\n-\tCOIERROR (\"Cannot allocate memory.\");\n-      function->ptr = ptr;\n-      function_handles[i] = (COIFUNCTION) function;\n+      finish_critical_section ();\n \n       /* Save function pointer.  */\n-      proc->functions[i] = function;\n+      proc->functions[i] = fn_ptr;\n+\n+      /* Prepare output arguments.  */\n+      out_pFunctionHandleArray[i] = (COIFUNCTION) fn_ptr;\n     }\n \n   return COI_SUCCESS;\n@@ -1161,23 +1487,22 @@ SYMBOL_VERSION (COIProcessLoadLibraryFromMemory, 2) (COIPROCESS in_Process,\n {\n   COITRACE (\"COIProcessLoadLibraryFromMemory\");\n \n-  const cmd_t cmd = CMD_OPEN_LIBRARY;\n-  char *lib_path;\n-  int fd;\n-  FILE *file;\n-  size_t len;\n+  assert (in_Process != NULL);\n+  assert (in_pLibraryBuffer != NULL);\n+  assert (out_pLibrary != NULL);\n \n   /* Convert input arguments.  */\n   Process *proc = (Process *) in_Process;\n \n   /* Create target library file.  */\n-  MALLOC (char *, lib_path,\n-\t  strlen (proc->engine->dir) + strlen (in_pLibraryName) + 2);\n+  char *lib_path;\n+  size_t len = strlen (proc->engine->dir) + strlen (in_pLibraryName) + 2;\n+  MALLOC (char *, lib_path, len);\n   sprintf (lib_path, \"%s/%s\", proc->engine->dir, in_pLibraryName);\n-  fd = open (lib_path, O_CLOEXEC | O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR);\n+  int fd = open (lib_path, O_CLOEXEC | O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR);\n   if (fd < 0)\n     COIERROR (\"Cannot create file %s.\", lib_path);\n-  file = fdopen (fd, \"wb\");\n+  FILE *file = fdopen (fd, \"wb\");\n   if (file == NULL)\n     COIERROR (\"Cannot associate stream with file descriptor.\");\n   if (fwrite (in_pLibraryBuffer, 1, in_LibraryBufferLength, file)\n@@ -1186,24 +1511,19 @@ SYMBOL_VERSION (COIProcessLoadLibraryFromMemory, 2) (COIPROCESS in_Process,\n   if (fclose (file) != 0)\n     COIERROR (\"Cannot close file %s.\", lib_path);\n \n-  len = strlen (lib_path) + 1;\n-\n-  /* Start critical section.  */\n-  if (pthread_mutex_lock (&mutex) != 0)\n-    COIERROR (\"Cannot lock mutex.\");\n+  start_critical_section ();\n \n   /* Make target open library.  */\n-  WRITE (proc->pipeline->pipe_target, &cmd, sizeof (cmd_t));\n-  WRITE (proc->pipeline->pipe_target, &len, sizeof (size_t));\n-  WRITE (proc->pipeline->pipe_target, lib_path, len);\n+  const cmd_t cmd = CMD_OPEN_LIBRARY;\n+  WRITE (proc->pipe_host2tgt, &cmd, sizeof (cmd_t));\n+  WRITE (proc->pipe_host2tgt, &len, sizeof (size_t));\n+  WRITE (proc->pipe_host2tgt, lib_path, len);\n \n   /* Receive data from target.  */\n   void *handle;\n-  READ (proc->pipeline->pipe_host, &handle, sizeof (void *));\n+  READ (proc->pipe_tgt2host, &handle, sizeof (void *));\n \n-  /* Finish critical section.  */\n-  if (pthread_mutex_unlock (&mutex) != 0)\n-    COIERROR (\"Cannot unlock mutex.\");\n+  finish_critical_section ();\n \n   /* Clean up.  */\n   free (lib_path);\n@@ -1214,11 +1534,11 @@ SYMBOL_VERSION (COIProcessLoadLibraryFromMemory, 2) (COIPROCESS in_Process,\n \n \n COIRESULT\n-SYMBOL_VERSION (COIProcessRegisterLibraries, 1) (uint32_t libraries_num,\n-\t\t\t\t\t\t const void **libraries,\n-\t\t\t\t\t\t const uint64_t *library_sizes,\n-\t\t\t\t\t\t const char **files_of_origin,\n-\t\t\t\t\t\t const uint64_t *file_of_origin_offsets)\n+SYMBOL_VERSION (COIProcessRegisterLibraries, 1) (uint32_t in_NumLibraries,\t\t      // Ignored\n+\t\t\t\t\t\t const void **in_ppLibraryArray,\t      // Ignored\n+\t\t\t\t\t\t const uint64_t *in_pLibrarySizeArray,\t      // Ignored\n+\t\t\t\t\t\t const char **in_ppFileOfOriginArray,\t      // Ignored\n+\t\t\t\t\t\t const uint64_t *in_pFileOfOriginOffSetArray) // Ignored\n {\n   COITRACE (\"COIProcessRegisterLibraries\");\n \n@@ -1234,22 +1554,21 @@ SYMBOL_VERSION (COIProcessUnloadLibrary, 1) (COIPROCESS in_Process,\n {\n   COITRACE (\"COIProcessUnloadLibrary\");\n \n+  assert (in_Process != NULL);\n+  assert (in_Library != NULL);\n+\n   const cmd_t cmd = CMD_CLOSE_LIBRARY;\n \n   /* Convert input arguments.  */\n   Process *proc = (Process *) in_Process;\n \n-  /* Start critical section.  */\n-  if (pthread_mutex_lock (&mutex) != 0)\n-    COIERROR (\"Cannot lock mutex.\");\n+  start_critical_section ();\n \n   /* Make target close library.  */\n-  WRITE (proc->pipeline->pipe_target, &cmd, sizeof (cmd_t));\n-  WRITE (proc->pipeline->pipe_target, &in_Library, sizeof (void *));\n+  WRITE (proc->pipe_host2tgt, &cmd, sizeof (cmd_t));\n+  WRITE (proc->pipe_host2tgt, &in_Library, sizeof (void *));\n \n-  /* Finish critical section.  */\n-  if (pthread_mutex_unlock (&mutex) != 0)\n-    COIERROR (\"Cannot unlock mutex.\");\n+  finish_critical_section ();\n \n   return COI_SUCCESS;\n }\n@@ -1290,12 +1609,14 @@ SYMBOL_VERSION (COIPipelineSetCPUMask, 1) (COIPROCESS in_Process,\n \n \n COIRESULT\n-SYMBOL_VERSION (COIEngineGetInfo, 1) (COIENGINE in_EngineHandle,\n-\t\t\t\t      uint32_t in_EngineInfoSize,\n+SYMBOL_VERSION (COIEngineGetInfo, 1) (COIENGINE in_EngineHandle,  // Ignored\n+\t\t\t\t      uint32_t in_EngineInfoSize, // Ignored\n \t\t\t\t      COI_ENGINE_INFO *out_pEngineInfo)\n {\n   COITRACE (\"COIEngineGetInfo\");\n \n+  assert (out_pEngineInfo != NULL);\n+\n   out_pEngineInfo->ISA = COI_ISA_x86_64;\n   out_pEngineInfo->NumCores = 1;\n   out_pEngineInfo->NumThreads = 8;"}, {"sha": "38ea274dbe7f02afc6a31e2b47918c2d930b9688", "filename": "liboffloadmic/runtime/emulator/coi_host.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44799f87c36be1a05c9b314e00a767c43b3c3190/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44799f87c36be1a05c9b314e00a767c43b3c3190/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.h?ref=44799f87c36be1a05c9b314e00a767c43b3c3190", "patch": "@@ -41,6 +41,16 @@\n   return COI_ERROR;\t\t\t  \\\n }\n \n+/* Like COIERROR, but return NULL instead of COIRESULT.  */\n+#define COIERRORN(...)\t\t\t  \\\n+{\t\t\t\t\t  \\\n+  fprintf (stderr, \"COI ERROR - HOST: \"); \\\n+  fprintf (stderr, __VA_ARGS__);\t  \\\n+  fprintf (stderr, \"\\n\");\t\t  \\\n+  perror (NULL);\t\t\t  \\\n+  return NULL;\t\t\t\t  \\\n+}\n+\n #ifdef DEBUG\n   #define COITRACE(...)\t\t\t    \\\n   {\t\t\t\t\t    \\"}]}