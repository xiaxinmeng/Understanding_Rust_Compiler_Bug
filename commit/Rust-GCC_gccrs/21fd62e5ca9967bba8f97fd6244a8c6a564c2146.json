{"sha": "21fd62e5ca9967bba8f97fd6244a8c6a564c2146", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFmZDYyZTVjYTk5NjdiYmE4Zjk3ZmQ2MjQ0YThjNmE1NjRjMjE0Ng==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-08-12T00:59:53Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-08-12T00:59:53Z"}, "message": "c++: constexpr std::construct_at on empty field [PR101663]\n\nHere during constexpr evaluation of\n\n  std::construct_at(&a._M_value)\n\nwe find ourselves in cxx_eval_store_expression where the target object\nis 'a._M_value' and the initializer is {}.  Since _M_value is an empty\n[[no_unique_address]] member we don't create a sub-CONSTRUCTOR for it,\nso we end up in the early exit code path for empty stores with mismatched\ntypes and trip over the assert therein\n\n  gcc_assert (is_empty_class (TREE_TYPE (init)) && !lval);\n\nbecause lval is true.  The reason it's true is because the INIT_EXPR in\nquestion is the LHS of a COMPOUND_EXPR, and evaluation of the LHS is\nalways performed with lval=true (to indicate there's no lvalue-to-rvalue\nconversion).\n\nThis patch makes the code path in question handle the lval=true case\nappropriately rather than asserting.  In passing, it also consolidates\nthe duplicate implementations of std::construct_at/destroy_at in some\nof the C++20 constexpr tests into a common header file.\n\n\tPR c++/101663\n\ngcc/cp/ChangeLog:\n\n\t* constexpr.c (cxx_eval_store_expression): Handle the lval=true\n\tcase in the early exit code path for empty stores with mismatched\n\ttypes.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/construct_at.h: New convenience header file that\n\tdefines minimal implementations of std::construct_at/destroy_at,\n\tsplit out from ...\n\t* g++.dg/cpp2a/constexpr-new5.C: ... here.\n\t* g++.dg/cpp2a/constexpr-new6.C: Use the header.\n\t* g++.dg/cpp2a/constexpr-new14.C: Likewise.\n\t* g++.dg/cpp2a/constexpr-new20.C: New test.", "tree": {"sha": "80d182ca1748b98e17fe080b965816a359436027", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80d182ca1748b98e17fe080b965816a359436027"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21fd62e5ca9967bba8f97fd6244a8c6a564c2146", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21fd62e5ca9967bba8f97fd6244a8c6a564c2146", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21fd62e5ca9967bba8f97fd6244a8c6a564c2146", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21fd62e5ca9967bba8f97fd6244a8c6a564c2146/comments", "author": null, "committer": null, "parents": [{"sha": "58f87503427e27bb069bd1841100f3c53440d51a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58f87503427e27bb069bd1841100f3c53440d51a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58f87503427e27bb069bd1841100f3c53440d51a"}], "stats": {"total": 268, "additions": 85, "deletions": 183}, "files": [{"sha": "25d84a377d8a711941bba3d02abf24d5caf5a674", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21fd62e5ca9967bba8f97fd6244a8c6a564c2146/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21fd62e5ca9967bba8f97fd6244a8c6a564c2146/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=21fd62e5ca9967bba8f97fd6244a8c6a564c2146", "patch": "@@ -5588,8 +5588,8 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \t   argument, which has the derived type rather than the base type.  In\n \t   this situation, just evaluate the initializer and return, since\n \t   there's no actual data to store.  */\n-\t  gcc_assert (is_empty_class (TREE_TYPE (init)) && !lval);\n-\t  return init;\n+\t  gcc_assert (is_empty_class (TREE_TYPE (init)));\n+\t  return lval ? target : init;\n \t}\n       CONSTRUCTOR_ELTS (*valp) = CONSTRUCTOR_ELTS (init);\n       TREE_CONSTANT (*valp) = TREE_CONSTANT (init);"}, {"sha": "26037397b1d4f5ad23785df3ef83720a6e798ce7", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-new14.C", "status": "modified", "additions": 1, "deletions": 59, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21fd62e5ca9967bba8f97fd6244a8c6a564c2146/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21fd62e5ca9967bba8f97fd6244a8c6a564c2146/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new14.C?ref=21fd62e5ca9967bba8f97fd6244a8c6a564c2146", "patch": "@@ -1,65 +1,7 @@\n // PR c++/97195\n // { dg-do compile { target c++20 } }\n \n-namespace std\n-{\n-  typedef __SIZE_TYPE__ size_t;\n-\n-  template <typename T>\n-  struct allocator\n-  {\n-    constexpr allocator () noexcept {}\n-\n-    constexpr T *allocate (size_t n)\n-    { return static_cast<T *> (::operator new (n * sizeof(T))); }\n-\n-    constexpr void\n-    deallocate (T *p, size_t n)\n-    { ::operator delete (p); }\n-  };\n-\n-  template <typename T, typename U = T &&>\n-  U __declval (int);\n-  template <typename T>\n-  T __declval (long);\n-  template <typename T>\n-  auto declval () noexcept -> decltype (__declval<T> (0));\n-\n-  template <typename T>\n-  struct remove_reference\n-  { typedef T type; };\n-  template <typename T>\n-  struct remove_reference<T &>\n-  { typedef T type; };\n-  template <typename T>\n-  struct remove_reference<T &&>\n-  { typedef T type; };\n-\n-  template <typename T>\n-  constexpr T &&\n-  forward (typename std::remove_reference<T>::type &t) noexcept\n-  { return static_cast<T&&> (t); }\n-\n-  template<typename T>\n-  constexpr T &&\n-  forward (typename std::remove_reference<T>::type &&t) noexcept\n-  { return static_cast<T&&> (t); }\n-\n-  template <typename T, typename... A>\n-  constexpr auto\n-  construct_at (T *l, A &&... a)\n-  noexcept (noexcept (::new ((void *) 0) T (std::declval<A> ()...)))\n-  -> decltype (::new ((void *) 0) T (std::declval<A> ()...))\n-  { return ::new ((void *) l) T (std::forward<A> (a)...); }\n-\n-  template <typename T>\n-  constexpr inline void\n-  destroy_at (T *l)\n-  { l->~T (); }\n-}\n-\n-inline void *operator new (std::size_t, void *p) noexcept\n-{ return p; }\n+#include \"construct_at.h\"\n \n constexpr bool\n foo ()"}, {"sha": "88bc4429a8adb8322151bc61f777d7e2fac9222c", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-new20.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21fd62e5ca9967bba8f97fd6244a8c6a564c2146/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21fd62e5ca9967bba8f97fd6244a8c6a564c2146/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new20.C?ref=21fd62e5ca9967bba8f97fd6244a8c6a564c2146", "patch": "@@ -0,0 +1,18 @@\n+// PR c++/101663\n+// { dg-do compile { target c++20 } }\n+\n+#include \"construct_at.h\"\n+\n+template <typename _Tp> struct __box {\n+  [[no_unique_address]] _Tp _M_value;\n+};\n+\n+struct Empty {};\n+\n+constexpr bool test() {\n+  __box<Empty> a;\n+  std::construct_at(&a._M_value);\n+  return true;\n+}\n+\n+static_assert(test());"}, {"sha": "eeaee969266a26ac918ca778498bdf76114d0fdd", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-new5.C", "status": "modified", "additions": 1, "deletions": 59, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21fd62e5ca9967bba8f97fd6244a8c6a564c2146/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21fd62e5ca9967bba8f97fd6244a8c6a564c2146/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new5.C?ref=21fd62e5ca9967bba8f97fd6244a8c6a564c2146", "patch": "@@ -1,65 +1,7 @@\n // P0784R7\n // { dg-do compile { target c++20 } }\n \n-namespace std\n-{\n-  typedef __SIZE_TYPE__ size_t;\n-\n-  template <typename T>\n-  struct allocator\n-  {\n-    constexpr allocator () noexcept {}\n-\n-    constexpr T *allocate (size_t n)\n-    { return static_cast<T *> (::operator new (n * sizeof(T))); }\n-\n-    constexpr void\n-    deallocate (T *p, size_t n)\n-    { ::operator delete (p); }\n-  };\n-\n-  template <typename T, typename U = T &&>\n-  U __declval (int);\n-  template <typename T>\n-  T __declval (long);\n-  template <typename T>\n-  auto declval () noexcept -> decltype (__declval<T> (0));\n-\n-  template <typename T>\n-  struct remove_reference\n-  { typedef T type; };\n-  template <typename T>\n-  struct remove_reference<T &>\n-  { typedef T type; };\n-  template <typename T>\n-  struct remove_reference<T &&>\n-  { typedef T type; };\n-\n-  template <typename T>\n-  constexpr T &&\n-  forward (typename std::remove_reference<T>::type &t) noexcept\n-  { return static_cast<T&&> (t); }\n-\n-  template<typename T>\n-  constexpr T &&\n-  forward (typename std::remove_reference<T>::type &&t) noexcept\n-  { return static_cast<T&&> (t); }\n-\n-  template <typename T, typename... A>\n-  constexpr auto\n-  construct_at (T *l, A &&... a)\n-  noexcept (noexcept (::new ((void *) 0) T (std::declval<A> ()...)))\n-  -> decltype (::new ((void *) 0) T (std::declval<A> ()...))\n-  { return ::new ((void *) l) T (std::forward<A> (a)...); }\n-\n-  template <typename T>\n-  constexpr inline void\n-  destroy_at (T *l)\n-  { l->~T (); }\n-}\n-\n-inline void *operator new (std::size_t, void *p) noexcept\n-{ return p; }\n+#include \"construct_at.h\"\n \n constexpr bool\n foo ()"}, {"sha": "eeaee969266a26ac918ca778498bdf76114d0fdd", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-new6.C", "status": "modified", "additions": 1, "deletions": 63, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21fd62e5ca9967bba8f97fd6244a8c6a564c2146/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21fd62e5ca9967bba8f97fd6244a8c6a564c2146/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new6.C?ref=21fd62e5ca9967bba8f97fd6244a8c6a564c2146", "patch": "@@ -1,69 +1,7 @@\n // P0784R7\n // { dg-do compile { target c++20 } }\n \n-namespace std\n-{\n-  inline namespace _8 { }\n-  namespace _8 {\n-\n-    typedef __SIZE_TYPE__ size_t;\n-\n-    template <typename T>\n-    struct allocator\n-    {\n-      constexpr allocator () noexcept {}\n-\n-      constexpr T *allocate (size_t n)\n-      { return static_cast<T *> (::operator new (n * sizeof(T))); }\n-\n-      constexpr void\n-      deallocate (T *p, size_t n)\n-      { ::operator delete (p); }\n-    };\n-\n-    template <typename T, typename U = T &&>\n-    U __declval (int);\n-    template <typename T>\n-    T __declval (long);\n-    template <typename T>\n-    auto declval () noexcept -> decltype (__declval<T> (0));\n-\n-    template <typename T>\n-    struct remove_reference\n-    { typedef T type; };\n-    template <typename T>\n-    struct remove_reference<T &>\n-    { typedef T type; };\n-    template <typename T>\n-    struct remove_reference<T &&>\n-    { typedef T type; };\n-\n-    template <typename T>\n-    constexpr T &&\n-    forward (typename std::remove_reference<T>::type &t) noexcept\n-    { return static_cast<T&&> (t); }\n-\n-    template<typename T>\n-    constexpr T &&\n-    forward (typename std::remove_reference<T>::type &&t) noexcept\n-    { return static_cast<T&&> (t); }\n-\n-    template <typename T, typename... A>\n-    constexpr auto\n-    construct_at (T *l, A &&... a)\n-    noexcept (noexcept (::new ((void *) 0) T (std::declval<A> ()...)))\n-    -> decltype (::new ((void *) 0) T (std::declval<A> ()...))\n-    { return ::new ((void *) l) T (std::forward<A> (a)...); }\n-\n-    template <typename T>\n-    constexpr inline void\n-    destroy_at (T *l)\n-    { l->~T (); }\n-  }\n-}\n-\n-inline void *operator new (std::size_t, void *p) noexcept\n-{ return p; }\n+#include \"construct_at.h\"\n \n constexpr bool\n foo ()"}, {"sha": "27e92cbb28c5bb84a7f21b453a3014e1e1acb090", "filename": "gcc/testsuite/g++.dg/cpp2a/construct_at.h", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21fd62e5ca9967bba8f97fd6244a8c6a564c2146/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstruct_at.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21fd62e5ca9967bba8f97fd6244a8c6a564c2146/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstruct_at.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstruct_at.h?ref=21fd62e5ca9967bba8f97fd6244a8c6a564c2146", "patch": "@@ -0,0 +1,62 @@\n+// A minimal conforming implementation of std::construct_at/destroy_at,\n+// used by some C++20 constexpr tests to avoid including all of <memory>.\n+\n+namespace std\n+{\n+  typedef __SIZE_TYPE__ size_t;\n+\n+  template <typename T>\n+  struct allocator\n+  {\n+    constexpr allocator () noexcept {}\n+\n+    constexpr T *allocate (size_t n)\n+    { return static_cast<T *> (::operator new (n * sizeof(T))); }\n+\n+    constexpr void\n+    deallocate (T *p, size_t n)\n+    { ::operator delete (p); }\n+  };\n+\n+  template <typename T, typename U = T &&>\n+  U __declval (int);\n+  template <typename T>\n+  T __declval (long);\n+  template <typename T>\n+  auto declval () noexcept -> decltype (__declval<T> (0));\n+\n+  template <typename T>\n+  struct remove_reference\n+  { typedef T type; };\n+  template <typename T>\n+  struct remove_reference<T &>\n+  { typedef T type; };\n+  template <typename T>\n+  struct remove_reference<T &&>\n+  { typedef T type; };\n+\n+  template <typename T>\n+  constexpr T &&\n+  forward (typename std::remove_reference<T>::type &t) noexcept\n+  { return static_cast<T&&> (t); }\n+\n+  template<typename T>\n+  constexpr T &&\n+  forward (typename std::remove_reference<T>::type &&t) noexcept\n+  { return static_cast<T&&> (t); }\n+\n+  template <typename T, typename... A>\n+  constexpr auto\n+  construct_at (T *l, A &&... a)\n+  noexcept (noexcept (::new ((void *) 0) T (std::declval<A> ()...)))\n+  -> decltype (::new ((void *) 0) T (std::declval<A> ()...))\n+  { return ::new ((void *) l) T (std::forward<A> (a)...); }\n+\n+  template <typename T>\n+  constexpr inline void\n+  destroy_at (T *l)\n+  { l->~T (); }\n+}\n+\n+inline void *operator new (std::size_t, void *p) noexcept\n+{ return p; }"}]}