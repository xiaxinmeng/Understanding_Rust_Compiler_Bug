{"sha": "4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE3ODdmYThiZmMwMTFlOWNkMmY4ZDJiNGViNmFlYWRjZjc3YmViMg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-06-12T08:10:24Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-06-12T08:10:24Z"}, "message": "[multiple changes]\n\n2004-06-12  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/ext/algorithm: Trivial formatting fixes.\n\t* include/ext/functional: Likewise.\n\t* include/ext/hash_fun.h: Likewise.\n\t* include/ext/iterator: Likewise.\n\n2004-06-12  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/basic_string.tcc (find(const _CharT*, size_type,\n\tsize_type)): Reimplement using std::search.\n\t* src/string-inst.cc: Instantiate std::search for char/wchar_t.\n\n2004-06-12  Dhruv Matani  <dhruvbird@gmx.net>\n\n\t* testsuite/performance/21_strings/string_find.cc: New.\n\nFrom-SVN: r83022", "tree": {"sha": "d3f42a3c1845cabd339039399a6b2c942a135e9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3f42a3c1845cabd339039399a6b2c942a135e9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2/comments", "author": null, "committer": null, "parents": [{"sha": "019c8e808737da10aefd430d55d4a96695a8859e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/019c8e808737da10aefd430d55d4a96695a8859e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/019c8e808737da10aefd430d55d4a96695a8859e"}], "stats": {"total": 1113, "additions": 670, "deletions": 443}, "files": [{"sha": "d1cde4bc43250008dae37901e80a878761e03422", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2", "patch": "@@ -1,3 +1,20 @@\n+2004-06-12  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/ext/algorithm: Trivial formatting fixes.\n+\t* include/ext/functional: Likewise.\n+\t* include/ext/hash_fun.h: Likewise.\n+\t* include/ext/iterator: Likewise.\n+\n+2004-06-12  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/basic_string.tcc (find(const _CharT*, size_type,\n+\tsize_type)): Reimplement using std::search.\n+\t* src/string-inst.cc: Instantiate std::search for char/wchar_t.\n+\n+2004-06-12  Dhruv Matani  <dhruvbird@gmx.net>\n+\n+\t* testsuite/performance/21_strings/string_find.cc: New.\n+\n 2004-06-10  Aaron W. LaFramboise  <aaronraolete36@aaronwl.com>\n \n \t* include/bits/istream.tcc (istream::ignore): Fix for -Wuninitialized."}, {"sha": "7d27aab970cc3e0b39ed62d5245ddef114c189eb", "filename": "libstdc++-v3/include/bits/basic_string.tcc", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc?ref=4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2", "patch": "@@ -685,21 +685,26 @@ namespace std\n     find(const _CharT* __s, size_type __pos, size_type __n) const\n     {\n       __glibcxx_requires_string_len(__s, __n);\n+      size_type __ret = npos;\n       const size_type __size = this->size();\n-      const _CharT* __data = _M_data();\n-      for (; __pos + __n <= __size; ++__pos)\n-\tif (traits_type::compare(__data + __pos, __s, __n) == 0)\n-\t  return __pos;\n-      return npos;\n+      if (__pos + __n <= __size)\n+\t{\n+\t  const _CharT* __data = _M_data();\n+\t  const _CharT* __p = std::search(__data + __pos, __data + __size,\n+\t\t\t\t\t  __s, __s + __n, traits_type::eq);\n+\t  if (__p != __data + __size || __n == 0)\n+\t    __ret = __p - __data;\n+\t}\n+      return __ret;\n     }\n \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     typename basic_string<_CharT, _Traits, _Alloc>::size_type\n     basic_string<_CharT, _Traits, _Alloc>::\n     find(_CharT __c, size_type __pos) const\n     {\n-      const size_type __size = this->size();\n       size_type __ret = npos;\n+      const size_type __size = this->size();\n       if (__pos < __size)\n \t{\n \t  const _CharT* __data = _M_data();"}, {"sha": "5cf001b2539d3bd5d82555392dffe5c87523aaa4", "filename": "libstdc++-v3/include/ext/algorithm", "status": "modified", "additions": 83, "deletions": 74, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2/libstdc%2B%2B-v3%2Finclude%2Fext%2Falgorithm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2/libstdc%2B%2B-v3%2Finclude%2Fext%2Falgorithm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Falgorithm?ref=4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2", "patch": "@@ -1,6 +1,6 @@\n // Algorithm extensions -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -84,11 +84,12 @@ namespace __gnu_cxx\n \t     _OutputIterator __result,\n \t     input_iterator_tag)\n     {\n-      for ( ; __count > 0; --__count) {\n-\t*__result = *__first;\n-\t++__first;\n-\t++__result;\n-      }\n+      for ( ; __count > 0; --__count)\n+\t{\n+\t  *__result = *__first;\n+\t  ++__first;\n+\t  ++__result;\n+\t}\n       return pair<_InputIterator, _OutputIterator>(__first, __result);\n     }\n \n@@ -99,8 +100,9 @@ namespace __gnu_cxx\n \t     random_access_iterator_tag)\n     {\n       _RAIterator __last = __first + __count;\n-      return pair<_RAIterator, _OutputIterator>(__last,\n-\t\t\t\t\tstd::copy(__first, __last, __result));\n+      return pair<_RAIterator, _OutputIterator>(__last, std::copy(__first,\n+\t\t\t\t\t\t\t\t  __last,\n+\t\t\t\t\t\t\t\t  __result));\n     }\n \n   /**\n@@ -132,23 +134,24 @@ namespace __gnu_cxx\n \n   template<typename _InputIterator1, typename _InputIterator2>\n     int\n-    __lexicographical_compare_3way(_InputIterator1 __first1, _InputIterator1 __last1,\n-\t\t\t\t   _InputIterator2 __first2, _InputIterator2 __last2)\n+    __lexicographical_compare_3way(_InputIterator1 __first1,\n+\t\t\t\t   _InputIterator1 __last1,\n+\t\t\t\t   _InputIterator2 __first2,\n+\t\t\t\t   _InputIterator2 __last2)\n     {\n-      while (__first1 != __last1 && __first2 != __last2) {\n-\tif (*__first1 < *__first2)\n-\t  return -1;\n-\tif (*__first2 < *__first1)\n-\t  return 1;\n-\t++__first1;\n-\t++__first2;\n-      }\n-      if (__first2 == __last2) {\n+      while (__first1 != __last1 && __first2 != __last2)\n+\t{\n+\t  if (*__first1 < *__first2)\n+\t    return -1;\n+\t  if (*__first2 < *__first1)\n+\t    return 1;\n+\t  ++__first1;\n+\t  ++__first2;\n+\t}\n+      if (__first2 == __last2)\n \treturn !(__first1 == __last1);\n-      }\n-      else {\n+      else\n \treturn -1;\n-      }\n     }\n \n   inline int\n@@ -169,11 +172,10 @@ namespace __gnu_cxx\n \t\t\t\t const char* __first2, const char* __last2)\n   {\n #if CHAR_MAX == SCHAR_MAX\n-    return __lexicographical_compare_3way(\n-\t\t\t\t  (const signed char*) __first1,\n-\t\t\t\t  (const signed char*) __last1,\n-\t\t\t\t  (const signed char*) __first2,\n-\t\t\t\t  (const signed char*) __last2);\n+    return __lexicographical_compare_3way((const signed char*) __first1,\n+\t\t\t\t\t  (const signed char*) __last1,\n+\t\t\t\t\t  (const signed char*) __first2,\n+\t\t\t\t\t  (const signed char*) __last2);\n #else\n     return __lexicographical_compare_3way((const unsigned char*) __first1,\n \t\t\t\t\t  (const unsigned char*) __last1,\n@@ -198,8 +200,10 @@ namespace __gnu_cxx\n   */\n   template<typename _InputIterator1, typename _InputIterator2>\n     int\n-    lexicographical_compare_3way(_InputIterator1 __first1, _InputIterator1 __last1,\n-\t\t\t\t _InputIterator2 __first2, _InputIterator2 __last2)\n+    lexicographical_compare_3way(_InputIterator1 __first1,\n+\t\t\t\t _InputIterator1 __last1,\n+\t\t\t\t _InputIterator2 __first2,\n+\t\t\t\t _InputIterator2 __last2)\n     {\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)\n@@ -211,12 +215,12 @@ namespace __gnu_cxx\n       __glibcxx_requires_valid_range(__first1, __last1);\n       __glibcxx_requires_valid_range(__first2, __last2);\n \n-      return __lexicographical_compare_3way(__first1, __last1, __first2, __last2);\n+      return __lexicographical_compare_3way(__first1, __last1, __first2,\n+\t\t\t\t\t    __last2);\n     }\n \n   // count and count_if: this version, whose return type is void, was present\n   // in the HP STL, and is retained as an extension for backward compatibility.\n-\n   template<typename _InputIterator, typename _Tp, typename _Size>\n     void\n     count(_InputIterator __first, _InputIterator __last,\n@@ -259,7 +263,8 @@ namespace __gnu_cxx\n    *  @ingroup SGIextensions\n    *  @doctodo\n   */\n-  template<typename _ForwardIterator, typename _OutputIterator, typename _Distance>\n+  template<typename _ForwardIterator, typename _OutputIterator,\n+\t   typename _Distance>\n     _OutputIterator\n     random_sample_n(_ForwardIterator __first, _ForwardIterator __last,\n                     _OutputIterator __out, const _Distance __n)\n@@ -273,16 +278,17 @@ namespace __gnu_cxx\n       _Distance __remaining = std::distance(__first, __last);\n       _Distance __m = min(__n, __remaining);\n \n-      while (__m > 0) {\n-\tif ((std::rand() % __remaining) < __m) {\n+      while (__m > 0)\n+\t{\n+\t  if ((std::rand() % __remaining) < __m)\n+\t    {\n \t      *__out = *__first;\n \t      ++__out;\n \t      --__m;\n+\t    }\n+\t  --__remaining;\n+\t  ++__first;\n \t}\n-\n-\t--__remaining;\n-\t++__first;\n-      }\n       return __out;\n     }\n \n@@ -291,8 +297,8 @@ namespace __gnu_cxx\n    *  @ingroup SGIextensions\n    *  @doctodo\n   */\n-  template<typename _ForwardIterator, typename _OutputIterator, typename _Distance,\n-\t   typename _RandomNumberGenerator>\n+  template<typename _ForwardIterator, typename _OutputIterator,\n+\t   typename _Distance, typename _RandomNumberGenerator>\n     _OutputIterator\n     random_sample_n(_ForwardIterator __first, _ForwardIterator __last,\n                    _OutputIterator __out, const _Distance __n,\n@@ -309,20 +315,22 @@ namespace __gnu_cxx\n       _Distance __remaining = std::distance(__first, __last);\n       _Distance __m = min(__n, __remaining);\n \n-      while (__m > 0) {\n-\tif (__rand(__remaining) < __m) {\n+      while (__m > 0)\n+\t{\n+\t  if (__rand(__remaining) < __m)\n+\t    {\n \t      *__out = *__first;\n \t      ++__out;\n \t      --__m;\n+\t    }\n+\t  --__remaining;\n+\t  ++__first;\n \t}\n-\n-\t--__remaining;\n-\t++__first;\n-      }\n       return __out;\n     }\n \n-  template<typename _InputIterator, typename _RandomAccessIterator, typename _Distance>\n+  template<typename _InputIterator, typename _RandomAccessIterator,\n+\t   typename _Distance>\n     _RandomAccessIterator\n     __random_sample(_InputIterator __first, _InputIterator __last,\n \t\t    _RandomAccessIterator __out,\n@@ -333,14 +341,14 @@ namespace __gnu_cxx\n       for ( ; __first != __last && __m < __n; ++__m, ++__first)\n \t__out[__m] = *__first;\n \n-      while (__first != __last) {\n-\t++__t;\n-\t_Distance __M = std::rand() % (__t);\n-\tif (__M < __n)\n-\t  __out[__M] = *__first;\n-\t++__first;\n-      }\n-\n+      while (__first != __last)\n+\t{\n+\t  ++__t;\n+\t  _Distance __M = std::rand() % (__t);\n+\t  if (__M < __n)\n+\t    __out[__M] = *__first;\n+\t  ++__first;\n+\t}\n       return __out + __m;\n     }\n \n@@ -361,14 +369,14 @@ namespace __gnu_cxx\n       for ( ; __first != __last && __m < __n; ++__m, ++__first)\n \t__out[__m] = *__first;\n \n-      while (__first != __last) {\n-\t++__t;\n-\t_Distance __M = __rand(__t);\n-\tif (__M < __n)\n-\t  __out[__M] = *__first;\n-\t++__first;\n-      }\n-\n+      while (__first != __last)\n+\t{\n+\t  ++__t;\n+\t  _Distance __M = __rand(__t);\n+\t  if (__M < __n)\n+\t    __out[__M] = *__first;\n+\t  ++__first;\n+\t}\n       return __out + __m;\n     }\n \n@@ -380,7 +388,8 @@ namespace __gnu_cxx\n   template<typename _InputIterator, typename _RandomAccessIterator>\n     inline _RandomAccessIterator\n     random_sample(_InputIterator __first, _InputIterator __last,\n-\t\t  _RandomAccessIterator __out_first, _RandomAccessIterator __out_last)\n+\t\t  _RandomAccessIterator __out_first,\n+\t\t  _RandomAccessIterator __out_last)\n     {\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n@@ -402,7 +411,8 @@ namespace __gnu_cxx\n \t   typename _RandomNumberGenerator>\n     inline _RandomAccessIterator\n     random_sample(_InputIterator __first, _InputIterator __last,\n-\t\t  _RandomAccessIterator __out_first, _RandomAccessIterator __out_last,\n+\t\t  _RandomAccessIterator __out_first,\n+\t\t  _RandomAccessIterator __out_last,\n \t\t  _RandomNumberGenerator& __rand)\n     {\n       // concept requirements\n@@ -427,7 +437,8 @@ namespace __gnu_cxx\n     is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n     {\n       // concept requirements\n-      __glibcxx_function_requires(_RandomAccessIteratorConcept<_RandomAccessIterator>)\n+      __glibcxx_function_requires(_RandomAccessIteratorConcept<\n+\t\t\t\t  _RandomAccessIterator>)\n       __glibcxx_function_requires(_LessThanComparableConcept<\n \t    typename iterator_traits<_RandomAccessIterator>::value_type>)\n       __glibcxx_requires_valid_range(__first, __last);\n@@ -446,7 +457,8 @@ namespace __gnu_cxx\n \t    _StrictWeakOrdering __comp)\n     {\n       // concept requirements\n-      __glibcxx_function_requires(_RandomAccessIteratorConcept<_RandomAccessIterator>)\n+      __glibcxx_function_requires(_RandomAccessIteratorConcept<\n+\t\t\t\t  _RandomAccessIterator>)\n       __glibcxx_function_requires(_BinaryPredicateConcept<_StrictWeakOrdering,\n \t    typename iterator_traits<_RandomAccessIterator>::value_type,\n \t    typename iterator_traits<_RandomAccessIterator>::value_type>)\n@@ -478,11 +490,9 @@ namespace __gnu_cxx\n \treturn true;\n \n       _ForwardIterator __next = __first;\n-      for (++__next; __next != __last; __first = __next, ++__next) {\n+      for (++__next; __next != __last; __first = __next, ++__next)\n \tif (*__next < *__first)\n \t  return false;\n-      }\n-\n       return true;\n     }\n \n@@ -493,7 +503,8 @@ namespace __gnu_cxx\n   */\n   template<typename _ForwardIterator, typename _StrictWeakOrdering>\n     bool\n-    is_sorted(_ForwardIterator __first, _ForwardIterator __last, _StrictWeakOrdering __comp)\n+    is_sorted(_ForwardIterator __first, _ForwardIterator __last,\n+\t      _StrictWeakOrdering __comp)\n     {\n       // concept requirements\n       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)\n@@ -506,11 +517,9 @@ namespace __gnu_cxx\n \treturn true;\n \n       _ForwardIterator __next = __first;\n-      for (++__next; __next != __last; __first = __next, ++__next) {\n+      for (++__next; __next != __last; __first = __next, ++__next)\n \tif (__comp(*__next, *__first))\n \t  return false;\n-      }\n-\n       return true;\n     }\n } // namespace __gnu_cxx"}, {"sha": "e57d871158264335d76fb022ae67b6fe258fef0f", "filename": "libstdc++-v3/include/ext/functional", "status": "modified", "additions": 350, "deletions": 319, "changes": 669, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2/libstdc%2B%2B-v3%2Finclude%2Fext%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2/libstdc%2B%2B-v3%2Finclude%2Fext%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Ffunctional?ref=4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2", "patch": "@@ -1,6 +1,6 @@\n // Functional extensions -*- C++ -*-\n \n-// Copyright (C) 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -68,328 +68,359 @@\n \n namespace __gnu_cxx\n {\n-using std::unary_function;\n-using std::binary_function;\n-using std::mem_fun1_t;\n-using std::const_mem_fun1_t;\n-using std::mem_fun1_ref_t;\n-using std::const_mem_fun1_ref_t;\n-\n-/** The @c identity_element functions are not part of the C++ standard; SGI\n- *  provided them as an extension.  Its argument is an operation, and its\n- *  return value is the identity element for that operation.  It is overloaded\n- *  for addition and multiplication, and you can overload it for your own\n- *  nefarious operations.\n- *\n- *  @addtogroup SGIextensions\n- *  @{\n-*/\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Tp> inline _Tp identity_element(std::plus<_Tp>) {\n-  return _Tp(0);\n-}\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Tp> inline _Tp identity_element(std::multiplies<_Tp>) {\n-  return _Tp(1);\n-}\n-/** @}  */\n-\n-/** As an extension to the binders, SGI provided composition functors and\n- *  wrapper functions to aid in their creation.  The @c unary_compose\n- *  functor is constructed from two functions/functors, @c f and @c g.\n- *  Calling @c operator() with a single argument @c x returns @c f(g(x)).\n- *  The function @c compose1 takes the two functions and constructs a\n- *  @c unary_compose variable for you.\n- *\n- *  @c binary_compose is constructed from three functors, @c f, @c g1,\n- *  and @c g2.  Its @c operator() returns @c f(g1(x),g2(x)).  The function\n- *  @compose2 takes f, g1, and g2, and constructs the @c binary_compose\n- *  instance for you.  For example, if @c f returns an int, then\n- *  \\code\n- *  int answer = (compose2(f,g1,g2))(x);\n- *  \\endcode\n- *  is equivalent to\n- *  \\code\n- *  int temp1 = g1(x);\n- *  int temp2 = g2(x);\n- *  int answer = f(temp1,temp2);\n- *  \\endcode\n- *  But the first form is more compact, and can be passed around as a\n- *  functor to other algorithms.\n- *\n- *  @addtogroup SGIextensions\n- *  @{\n-*/\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Operation1, class _Operation2>\n-class unary_compose\n-  : public unary_function<typename _Operation2::argument_type,\n-\t\t       typename _Operation1::result_type>\n-{\n-protected:\n-  _Operation1 _M_fn1;\n-  _Operation2 _M_fn2;\n-public:\n-  unary_compose(const _Operation1& __x, const _Operation2& __y)\n-    : _M_fn1(__x), _M_fn2(__y) {}\n-  typename _Operation1::result_type\n-  operator()(const typename _Operation2::argument_type& __x) const {\n-    return _M_fn1(_M_fn2(__x));\n-  }\n-};\n-\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Operation1, class _Operation2>\n-inline unary_compose<_Operation1,_Operation2>\n-compose1(const _Operation1& __fn1, const _Operation2& __fn2)\n-{\n-  return unary_compose<_Operation1,_Operation2>(__fn1, __fn2);\n-}\n-\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Operation1, class _Operation2, class _Operation3>\n-class binary_compose\n-  : public unary_function<typename _Operation2::argument_type,\n-                          typename _Operation1::result_type> {\n-protected:\n-  _Operation1 _M_fn1;\n-  _Operation2 _M_fn2;\n-  _Operation3 _M_fn3;\n-public:\n-  binary_compose(const _Operation1& __x, const _Operation2& __y,\n-                 const _Operation3& __z)\n-    : _M_fn1(__x), _M_fn2(__y), _M_fn3(__z) { }\n-  typename _Operation1::result_type\n-  operator()(const typename _Operation2::argument_type& __x) const {\n-    return _M_fn1(_M_fn2(__x), _M_fn3(__x));\n-  }\n-};\n-\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Operation1, class _Operation2, class _Operation3>\n-inline binary_compose<_Operation1, _Operation2, _Operation3>\n-compose2(const _Operation1& __fn1, const _Operation2& __fn2,\n-         const _Operation3& __fn3)\n-{\n-  return binary_compose<_Operation1,_Operation2,_Operation3>\n-    (__fn1, __fn2, __fn3);\n-}\n-/** @}  */\n-\n-/** As an extension, SGI provided a functor called @c identity.  When a\n- *  functor is required but no operations are desired, this can be used as a\n- *  pass-through.  Its @c operator() returns its argument unchanged.\n- *\n- *  @addtogroup SGIextensions\n-*/\n-template <class _Tp> struct identity : public std::_Identity<_Tp> {};\n-\n-/** @c select1st and @c select2nd are extensions provided by SGI.  Their\n- *  @c operator()s\n- *  take a @c std::pair as an argument, and return either the first member\n- *  or the second member, respectively.  They can be used (especially with\n- *  the composition functors) to \"strip\" data from a sequence before\n- *  performing the remainder of an algorithm.\n- *\n- *  @addtogroup SGIextensions\n- *  @{\n-*/\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Pair> struct select1st : public std::_Select1st<_Pair> {};\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Pair> struct select2nd : public std::_Select2nd<_Pair> {};\n-/** @}  */\n-\n-// extension documented next\n-template <class _Arg1, class _Arg2>\n-struct _Project1st : public binary_function<_Arg1, _Arg2, _Arg1> {\n-  _Arg1 operator()(const _Arg1& __x, const _Arg2&) const { return __x; }\n-};\n-\n-template <class _Arg1, class _Arg2>\n-struct _Project2nd : public binary_function<_Arg1, _Arg2, _Arg2> {\n-  _Arg2 operator()(const _Arg1&, const _Arg2& __y) const { return __y; }\n-};\n-\n-/** The @c operator() of the @c project1st functor takes two arbitrary\n- *  arguments and returns the first one, while @c project2nd returns the\n- *  second one.  They are extensions provided by SGI.\n- *\n- *  @addtogroup SGIextensions\n- *  @{\n-*/\n-\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Arg1, class _Arg2>\n-struct project1st : public _Project1st<_Arg1, _Arg2> {};\n-\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Arg1, class _Arg2>\n-struct project2nd : public _Project2nd<_Arg1, _Arg2> {};\n-/** @}  */\n-\n-// extension documented next\n-template <class _Result>\n-struct _Constant_void_fun {\n-  typedef _Result result_type;\n-  result_type _M_val;\n-\n-  _Constant_void_fun(const result_type& __v) : _M_val(__v) {}\n-  const result_type& operator()() const { return _M_val; }\n-};\n-\n-template <class _Result, class _Argument>\n-struct _Constant_unary_fun {\n-  typedef _Argument argument_type;\n-  typedef  _Result  result_type;\n-  result_type _M_val;\n-\n-  _Constant_unary_fun(const result_type& __v) : _M_val(__v) {}\n-  const result_type& operator()(const _Argument&) const { return _M_val; }\n-};\n-\n-template <class _Result, class _Arg1, class _Arg2>\n-struct _Constant_binary_fun {\n-  typedef  _Arg1   first_argument_type;\n-  typedef  _Arg2   second_argument_type;\n-  typedef  _Result result_type;\n-  _Result _M_val;\n-\n-  _Constant_binary_fun(const _Result& __v) : _M_val(__v) {}\n-  const result_type& operator()(const _Arg1&, const _Arg2&) const {\n-    return _M_val;\n-  }\n-};\n-\n-/** These three functors are each constructed from a single arbitrary\n- *  variable/value.  Later, their @c operator()s completely ignore any\n- *  arguments passed, and return the stored value.\n- *  - @c constant_void_fun's @c operator() takes no arguments\n- *  - @c constant_unary_fun's @c operator() takes one argument (ignored)\n- *  - @c constant_binary_fun's @c operator() takes two arguments (ignored)\n- *\n- *  The helper creator functions @c constant0, @c constant1, and\n- *  @c constant2 each take a \"result\" argument and construct variables of\n- *  the appropriate functor type.\n- *\n- *  @addtogroup SGIextensions\n- *  @{\n-*/\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Result>\n-struct constant_void_fun : public _Constant_void_fun<_Result> {\n-  constant_void_fun(const _Result& __v) : _Constant_void_fun<_Result>(__v) {}\n-};\n-\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Result,\n-          class _Argument = _Result>\n-struct constant_unary_fun : public _Constant_unary_fun<_Result, _Argument>\n-{\n-  constant_unary_fun(const _Result& __v)\n-    : _Constant_unary_fun<_Result, _Argument>(__v) {}\n-};\n-\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Result,\n-          class _Arg1 = _Result,\n-          class _Arg2 = _Arg1>\n-struct constant_binary_fun\n-  : public _Constant_binary_fun<_Result, _Arg1, _Arg2>\n-{\n-  constant_binary_fun(const _Result& __v)\n-    : _Constant_binary_fun<_Result, _Arg1, _Arg2>(__v) {}\n-};\n-\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Result>\n-inline constant_void_fun<_Result> constant0(const _Result& __val)\n-{\n-  return constant_void_fun<_Result>(__val);\n-}\n-\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Result>\n-inline constant_unary_fun<_Result,_Result> constant1(const _Result& __val)\n-{\n-  return constant_unary_fun<_Result,_Result>(__val);\n-}\n-\n-/// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Result>\n-inline constant_binary_fun<_Result,_Result,_Result>\n-constant2(const _Result& __val)\n-{\n-  return constant_binary_fun<_Result,_Result,_Result>(__val);\n-}\n-/** @}  */\n-\n-/** The @c subtractive_rng class is documented on\n- *  <a href=\"http://www.sgi.com/tech/stl/\">SGI's site</a>.\n- *  Note that this code assumes that @c int is 32 bits.\n- *\n- *  @ingroup SGIextensions\n-*/\n-class subtractive_rng : public unary_function<unsigned int, unsigned int> {\n-private:\n-  unsigned int _M_table[55];\n-  size_t _M_index1;\n-  size_t _M_index2;\n-public:\n-  /// Returns a number less than the argument.\n-  unsigned int operator()(unsigned int __limit) {\n-    _M_index1 = (_M_index1 + 1) % 55;\n-    _M_index2 = (_M_index2 + 1) % 55;\n-    _M_table[_M_index1] = _M_table[_M_index1] - _M_table[_M_index2];\n-    return _M_table[_M_index1] % __limit;\n-  }\n-\n-  void _M_initialize(unsigned int __seed)\n+  using std::unary_function;\n+  using std::binary_function;\n+  using std::mem_fun1_t;\n+  using std::const_mem_fun1_t;\n+  using std::mem_fun1_ref_t;\n+  using std::const_mem_fun1_ref_t;\n+\n+  /** The @c identity_element functions are not part of the C++ standard; SGI\n+   *  provided them as an extension.  Its argument is an operation, and its\n+   *  return value is the identity element for that operation.  It is overloaded\n+   *  for addition and multiplication, and you can overload it for your own\n+   *  nefarious operations.\n+   *\n+   *  @addtogroup SGIextensions\n+   *  @{\n+   */\n+  /// An \\link SGIextensions SGI extension \\endlink.\n+  template <class _Tp>\n+    inline _Tp\n+    identity_element(std::plus<_Tp>)\n+    { return _Tp(0); }\n+\n+  /// An \\link SGIextensions SGI extension \\endlink.\n+  template <class _Tp>\n+    inline _Tp\n+    identity_element(std::multiplies<_Tp>)\n+    { return _Tp(1); }\n+  /** @}  */\n+  \n+  /** As an extension to the binders, SGI provided composition functors and\n+   *  wrapper functions to aid in their creation.  The @c unary_compose\n+   *  functor is constructed from two functions/functors, @c f and @c g.\n+   *  Calling @c operator() with a single argument @c x returns @c f(g(x)).\n+   *  The function @c compose1 takes the two functions and constructs a\n+   *  @c unary_compose variable for you.\n+   *\n+   *  @c binary_compose is constructed from three functors, @c f, @c g1,\n+   *  and @c g2.  Its @c operator() returns @c f(g1(x),g2(x)).  The function\n+   *  @compose2 takes f, g1, and g2, and constructs the @c binary_compose\n+   *  instance for you.  For example, if @c f returns an int, then\n+   *  \\code\n+   *  int answer = (compose2(f,g1,g2))(x);\n+   *  \\endcode\n+   *  is equivalent to\n+   *  \\code\n+   *  int temp1 = g1(x);\n+   *  int temp2 = g2(x);\n+   *  int answer = f(temp1,temp2);\n+   *  \\endcode\n+   *  But the first form is more compact, and can be passed around as a\n+   *  functor to other algorithms.\n+   *\n+   *  @addtogroup SGIextensions\n+   *  @{\n+   */\n+  /// An \\link SGIextensions SGI extension \\endlink.\n+  template <class _Operation1, class _Operation2>\n+    class unary_compose\n+    : public unary_function<typename _Operation2::argument_type,\n+\t\t\t    typename _Operation1::result_type>\n+    {\n+    protected:\n+      _Operation1 _M_fn1;\n+      _Operation2 _M_fn2;\n+\n+    public:\n+      unary_compose(const _Operation1& __x, const _Operation2& __y)\n+      : _M_fn1(__x), _M_fn2(__y) {}\n+\n+      typename _Operation1::result_type\n+      operator()(const typename _Operation2::argument_type& __x) const\n+      { return _M_fn1(_M_fn2(__x)); }\n+    };\n+\n+  /// An \\link SGIextensions SGI extension \\endlink.\n+  template <class _Operation1, class _Operation2>\n+    inline unary_compose<_Operation1, _Operation2>\n+    compose1(const _Operation1& __fn1, const _Operation2& __fn2)\n+    { return unary_compose<_Operation1,_Operation2>(__fn1, __fn2); }\n+\n+  /// An \\link SGIextensions SGI extension \\endlink.\n+  template <class _Operation1, class _Operation2, class _Operation3>\n+    class binary_compose\n+    : public unary_function<typename _Operation2::argument_type,\n+\t\t\t    typename _Operation1::result_type>\n+    {\n+    protected:\n+      _Operation1 _M_fn1;\n+      _Operation2 _M_fn2;\n+      _Operation3 _M_fn3;\n+      \n+    public:\n+      binary_compose(const _Operation1& __x, const _Operation2& __y,\n+\t\t     const _Operation3& __z)\n+      : _M_fn1(__x), _M_fn2(__y), _M_fn3(__z) { }\n+\n+      typename _Operation1::result_type\n+      operator()(const typename _Operation2::argument_type& __x) const\n+      { return _M_fn1(_M_fn2(__x), _M_fn3(__x)); }\n+    };\n+\n+  /// An \\link SGIextensions SGI extension \\endlink.\n+  template <class _Operation1, class _Operation2, class _Operation3>\n+    inline binary_compose<_Operation1, _Operation2, _Operation3>\n+    compose2(const _Operation1& __fn1, const _Operation2& __fn2,\n+\t     const _Operation3& __fn3)\n+    { return binary_compose<_Operation1, _Operation2, _Operation3>\n+\t(__fn1, __fn2, __fn3); }\n+  /** @}  */\n+\n+  /** As an extension, SGI provided a functor called @c identity.  When a\n+   *  functor is required but no operations are desired, this can be used as a\n+   *  pass-through.  Its @c operator() returns its argument unchanged.\n+   *\n+   *  @addtogroup SGIextensions\n+   */\n+  template <class _Tp>\n+    struct identity : public std::_Identity<_Tp> {};\n+\n+  /** @c select1st and @c select2nd are extensions provided by SGI.  Their\n+   *  @c operator()s\n+   *  take a @c std::pair as an argument, and return either the first member\n+   *  or the second member, respectively.  They can be used (especially with\n+   *  the composition functors) to \"strip\" data from a sequence before\n+   *  performing the remainder of an algorithm.\n+   *\n+   *  @addtogroup SGIextensions\n+   *  @{\n+   */\n+  /// An \\link SGIextensions SGI extension \\endlink.\n+  template <class _Pair>\n+    struct select1st : public std::_Select1st<_Pair> {};\n+\n+  /// An \\link SGIextensions SGI extension \\endlink.\n+  template <class _Pair>\n+    struct select2nd : public std::_Select2nd<_Pair> {};\n+  /** @}  */\n+\n+  // extension documented next\n+  template <class _Arg1, class _Arg2>\n+    struct _Project1st : public binary_function<_Arg1, _Arg2, _Arg1>\n+    {\n+      _Arg1\n+      operator()(const _Arg1& __x, const _Arg2&) const\n+      { return __x; }\n+    };\n+\n+  template <class _Arg1, class _Arg2>\n+    struct _Project2nd : public binary_function<_Arg1, _Arg2, _Arg2>\n+    {\n+      _Arg2\n+      operator()(const _Arg1&, const _Arg2& __y) const\n+      { return __y; }\n+    };\n+\n+  /** The @c operator() of the @c project1st functor takes two arbitrary\n+   *  arguments and returns the first one, while @c project2nd returns the\n+   *  second one.  They are extensions provided by SGI.\n+   *\n+   *  @addtogroup SGIextensions\n+   *  @{\n+   */\n+\n+  /// An \\link SGIextensions SGI extension \\endlink.\n+  template <class _Arg1, class _Arg2>\n+    struct project1st : public _Project1st<_Arg1, _Arg2> {};\n+\n+  /// An \\link SGIextensions SGI extension \\endlink.\n+  template <class _Arg1, class _Arg2>\n+    struct project2nd : public _Project2nd<_Arg1, _Arg2> {};\n+  /** @}  */\n+\n+  // extension documented next\n+  template <class _Result>\n+    struct _Constant_void_fun\n+    {\n+      typedef _Result result_type;\n+      result_type _M_val;\n+\n+      _Constant_void_fun(const result_type& __v) : _M_val(__v) {}\n+\n+      const result_type&\n+      operator()() const\n+      { return _M_val; }\n+    };\n+\n+  template <class _Result, class _Argument>\n+    struct _Constant_unary_fun\n+    {\n+      typedef _Argument argument_type;\n+      typedef  _Result  result_type;\n+      result_type _M_val;\n+      \n+      _Constant_unary_fun(const result_type& __v) : _M_val(__v) {}\n+\n+      const result_type&\n+      operator()(const _Argument&) const\n+      { return _M_val; }\n+    };\n+\n+  template <class _Result, class _Arg1, class _Arg2>\n+    struct _Constant_binary_fun\n+    {\n+      typedef  _Arg1   first_argument_type;\n+      typedef  _Arg2   second_argument_type;\n+      typedef  _Result result_type;\n+      _Result _M_val;\n+\n+      _Constant_binary_fun(const _Result& __v) : _M_val(__v) {}\n+      \n+      const result_type&\n+      operator()(const _Arg1&, const _Arg2&) const\n+      { return _M_val; }\n+    };\n+\n+  /** These three functors are each constructed from a single arbitrary\n+   *  variable/value.  Later, their @c operator()s completely ignore any\n+   *  arguments passed, and return the stored value.\n+   *  - @c constant_void_fun's @c operator() takes no arguments\n+   *  - @c constant_unary_fun's @c operator() takes one argument (ignored)\n+   *  - @c constant_binary_fun's @c operator() takes two arguments (ignored)\n+   *\n+   *  The helper creator functions @c constant0, @c constant1, and\n+   *  @c constant2 each take a \"result\" argument and construct variables of\n+   *  the appropriate functor type.\n+   *\n+   *  @addtogroup SGIextensions\n+   *  @{\n+   */\n+  /// An \\link SGIextensions SGI extension \\endlink.\n+  template <class _Result>\n+    struct constant_void_fun\n+    : public _Constant_void_fun<_Result>\n+    {\n+      constant_void_fun(const _Result& __v)\n+      : _Constant_void_fun<_Result>(__v) {}\n+    };\n+\n+  /// An \\link SGIextensions SGI extension \\endlink.\n+  template <class _Result, class _Argument = _Result>\n+    struct constant_unary_fun : public _Constant_unary_fun<_Result, _Argument>\n+    {\n+      constant_unary_fun(const _Result& __v)\n+      : _Constant_unary_fun<_Result, _Argument>(__v) {}\n+    };\n+\n+  /// An \\link SGIextensions SGI extension \\endlink.\n+  template <class _Result, class _Arg1 = _Result, class _Arg2 = _Arg1>\n+    struct constant_binary_fun\n+    : public _Constant_binary_fun<_Result, _Arg1, _Arg2>\n+    {\n+      constant_binary_fun(const _Result& __v)\n+      : _Constant_binary_fun<_Result, _Arg1, _Arg2>(__v) {}\n+    };\n+\n+  /// An \\link SGIextensions SGI extension \\endlink.\n+  template <class _Result>\n+    inline constant_void_fun<_Result>\n+    constant0(const _Result& __val)\n+    { return constant_void_fun<_Result>(__val); }\n+\n+  /// An \\link SGIextensions SGI extension \\endlink.\n+  template <class _Result>\n+    inline constant_unary_fun<_Result, _Result>\n+    constant1(const _Result& __val)\n+    { return constant_unary_fun<_Result, _Result>(__val); }\n+\n+  /// An \\link SGIextensions SGI extension \\endlink.\n+  template <class _Result>\n+    inline constant_binary_fun<_Result,_Result,_Result>\n+    constant2(const _Result& __val)\n+    { return constant_binary_fun<_Result, _Result, _Result>(__val); }\n+  /** @}  */\n+\n+  /** The @c subtractive_rng class is documented on\n+   *  <a href=\"http://www.sgi.com/tech/stl/\">SGI's site</a>.\n+   *  Note that this code assumes that @c int is 32 bits.\n+   *\n+   *  @ingroup SGIextensions\n+   */\n+  class subtractive_rng\n+  : public unary_function<unsigned int, unsigned int>\n   {\n-    unsigned int __k = 1;\n-    _M_table[54] = __seed;\n-    size_t __i;\n-    for (__i = 0; __i < 54; __i++) {\n-        size_t __ii = (21 * (__i + 1) % 55) - 1;\n-        _M_table[__ii] = __k;\n-        __k = __seed - __k;\n-        __seed = _M_table[__ii];\n+  private:\n+    unsigned int _M_table[55];\n+    size_t _M_index1;\n+    size_t _M_index2;\n+\n+  public:\n+    /// Returns a number less than the argument.\n+    unsigned int\n+    operator()(unsigned int __limit)\n+    {\n+      _M_index1 = (_M_index1 + 1) % 55;\n+      _M_index2 = (_M_index2 + 1) % 55;\n+      _M_table[_M_index1] = _M_table[_M_index1] - _M_table[_M_index2];\n+      return _M_table[_M_index1] % __limit;\n     }\n-    for (int __loop = 0; __loop < 4; __loop++) {\n-        for (__i = 0; __i < 55; __i++)\n+\n+    void\n+    _M_initialize(unsigned int __seed)\n+    {\n+      unsigned int __k = 1;\n+      _M_table[54] = __seed;\n+      size_t __i;\n+      for (__i = 0; __i < 54; __i++)\n+\t{\n+\t  size_t __ii = (21 * (__i + 1) % 55) - 1;\n+\t  _M_table[__ii] = __k;\n+\t  __k = __seed - __k;\n+\t  __seed = _M_table[__ii];\n+\t}\n+      for (int __loop = 0; __loop < 4; __loop++)\n+\t{\n+\t  for (__i = 0; __i < 55; __i++)\n             _M_table[__i] = _M_table[__i] - _M_table[(1 + __i + 30) % 55];\n+\t}\n+      _M_index1 = 0;\n+      _M_index2 = 31;\n     }\n-    _M_index1 = 0;\n-    _M_index2 = 31;\n-  }\n-\n-  /// Ctor allowing you to initialize the seed.\n-  subtractive_rng(unsigned int __seed) { _M_initialize(__seed); }\n-  /// Default ctor; initializes its state with some number you don't see.\n-  subtractive_rng() { _M_initialize(161803398u); }\n-};\n-\n-// Mem_fun adaptor helper functions mem_fun1 and mem_fun1_ref,\n-// provided for backward compatibility, they are no longer part of\n-// the C++ standard.\n-\n-template <class _Ret, class _Tp, class _Arg>\n-inline mem_fun1_t<_Ret,_Tp,_Arg> mem_fun1(_Ret (_Tp::*__f)(_Arg))\n-  { return mem_fun1_t<_Ret,_Tp,_Arg>(__f); }\n-\n-template <class _Ret, class _Tp, class _Arg>\n-inline const_mem_fun1_t<_Ret,_Tp,_Arg> mem_fun1(_Ret (_Tp::*__f)(_Arg) const)\n-  { return const_mem_fun1_t<_Ret,_Tp,_Arg>(__f); }\n-\n-template <class _Ret, class _Tp, class _Arg>\n-inline mem_fun1_ref_t<_Ret,_Tp,_Arg> mem_fun1_ref(_Ret (_Tp::*__f)(_Arg))\n-  { return mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }\n-\n-template <class _Ret, class _Tp, class _Arg>\n-inline const_mem_fun1_ref_t<_Ret,_Tp,_Arg>\n-mem_fun1_ref(_Ret (_Tp::*__f)(_Arg) const)\n-  { return const_mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }\n-} // namespace __gnu_cxx\n \n+    /// Ctor allowing you to initialize the seed.\n+    subtractive_rng(unsigned int __seed)\n+    { _M_initialize(__seed); }\n+\n+    /// Default ctor; initializes its state with some number you don't see.\n+    subtractive_rng()\n+    { _M_initialize(161803398u); }\n+  };\n+\n+  // Mem_fun adaptor helper functions mem_fun1 and mem_fun1_ref,\n+  // provided for backward compatibility, they are no longer part of\n+  // the C++ standard.\n+  \n+  template <class _Ret, class _Tp, class _Arg>\n+    inline mem_fun1_t<_Ret, _Tp, _Arg>\n+    mem_fun1(_Ret (_Tp::*__f)(_Arg))\n+    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }\n+\n+  template <class _Ret, class _Tp, class _Arg>\n+    inline const_mem_fun1_t<_Ret, _Tp, _Arg>\n+    mem_fun1(_Ret (_Tp::*__f)(_Arg) const)\n+    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }\n+\n+  template <class _Ret, class _Tp, class _Arg>\n+    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>\n+    mem_fun1_ref(_Ret (_Tp::*__f)(_Arg))\n+    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }\n+\n+  template <class _Ret, class _Tp, class _Arg>\n+    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>\n+    mem_fun1_ref(_Ret (_Tp::*__f)(_Arg) const)\n+    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }\n+} // namespace __gnu_cxx\n #endif\n "}, {"sha": "65d8a36c1cb0e0941ccdf402ee2eca84af59bb82", "filename": "libstdc++-v3/include/ext/hash_fun.h", "status": "modified", "additions": 91, "deletions": 41, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_fun.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_fun.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_fun.h?ref=4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2", "patch": "@@ -1,6 +1,6 @@\n // 'struct hash' from SGI -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -68,55 +68,105 @@ namespace __gnu_cxx\n {\n   using std::size_t;\n \n-  template <class _Key> struct hash { };\n+  template<class _Key>\n+    struct hash { };\n \n   inline size_t\n   __stl_hash_string(const char* __s)\n   {\n     unsigned long __h = 0;\n     for ( ; *__s; ++__s)\n-      __h = 5*__h + *__s;\n+      __h = 5 * __h + *__s;\n     return size_t(__h);\n   }\n \n-  template<> struct hash<char*>\n-  {\n-    size_t operator()(const char* __s) const\n-    { return __stl_hash_string(__s); }\n-  };\n-\n-  template<> struct hash<const char*>\n-  {\n-    size_t operator()(const char* __s) const\n-    { return __stl_hash_string(__s); }\n-  };\n-\n-  template<> struct hash<char>\n-  { size_t operator()(char __x) const { return __x; } };\n-\n-  template<> struct hash<unsigned char>\n-  { size_t operator()(unsigned char __x) const { return __x; } };\n-\n-  template<> struct hash<signed char>\n-  { size_t operator()(unsigned char __x) const { return __x; } };\n-\n-  template<> struct hash<short>\n-  { size_t operator()(short __x) const { return __x; } };\n-\n-  template<> struct hash<unsigned short>\n-  { size_t operator()(unsigned short __x) const { return __x; } };\n-\n-  template<> struct hash<int>\n-  { size_t operator()(int __x) const { return __x; } };\n-\n-  template<> struct hash<unsigned int>\n-  { size_t operator()(unsigned int __x) const { return __x; } };\n-\n-  template<> struct hash<long>\n-  { size_t operator()(long __x) const { return __x; } };\n-\n-  template<> struct hash<unsigned long>\n-  { size_t operator()(unsigned long __x) const { return __x; } };\n+  template<>\n+    struct hash<char*>\n+    {\n+      size_t\n+      operator()(const char* __s) const\n+      { return __stl_hash_string(__s); }\n+    };\n+\n+  template<>\n+    struct hash<const char*>\n+    {\n+      size_t\n+      operator()(const char* __s) const\n+      { return __stl_hash_string(__s); }\n+    };\n+\n+  template<>\n+    struct hash<char>\n+    { \n+      size_t\n+      operator()(char __x) const\n+      { return __x; }\n+    };\n+\n+  template<>\n+    struct hash<unsigned char>\n+    { \n+      size_t\n+      operator()(unsigned char __x) const\n+      { return __x; }\n+    };\n+\n+  template<>\n+    struct hash<signed char>\n+    {\n+      size_t\n+      operator()(unsigned char __x) const\n+      { return __x; }\n+    };\n+\n+  template<>\n+    struct hash<short>\n+    {\n+      size_t\n+      operator()(short __x) const\n+      { return __x; }\n+    };\n+\n+  template<>\n+    struct hash<unsigned short>\n+    {\n+      size_t\n+      operator()(unsigned short __x) const\n+      { return __x; }\n+    };\n+\n+  template<>\n+    struct hash<int>\n+    { \n+      size_t \n+      operator()(int __x) const \n+      { return __x; }\n+    };\n+\n+  template<>\n+    struct hash<unsigned int>\n+    { \n+      size_t\n+      operator()(unsigned int __x) const\n+      { return __x; }\n+    };\n+\n+  template<>\n+    struct hash<long>\n+    {\n+      size_t\n+      operator()(long __x) const\n+      { return __x; }\n+    };\n+\n+  template<>\n+    struct hash<unsigned long>\n+    {\n+      size_t\n+      operator()(unsigned long __x) const\n+      { return __x; }\n+    };\n } // namespace __gnu_cxx\n \n #endif"}, {"sha": "12edab969c51e4f9bf5fc65035152b4e3e1b2f7e", "filename": "libstdc++-v3/include/ext/iterator", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2/libstdc%2B%2B-v3%2Finclude%2Fext%2Fiterator", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2/libstdc%2B%2B-v3%2Finclude%2Fext%2Fiterator", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fiterator?ref=4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2", "patch": "@@ -1,6 +1,6 @@\n // HP/SGI iterator extensions -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -81,7 +81,11 @@ namespace __gnu_cxx\n     {\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n-      while (__first != __last) { ++__first; ++__n; }\n+      while (__first != __last)\n+\t{\n+\t  ++__first;\n+\t  ++__n;\n+\t}\n     }\n \n   template<typename _RandomAccessIterator, typename _Distance>\n@@ -90,7 +94,8 @@ namespace __gnu_cxx\n \t       _Distance& __n, std::random_access_iterator_tag)\n     {\n       // concept requirements\n-      __glibcxx_function_requires(_RandomAccessIteratorConcept<_RandomAccessIterator>)\n+      __glibcxx_function_requires(_RandomAccessIteratorConcept<\n+\t\t\t\t  _RandomAccessIterator>)\n       __n += __last - __first;\n     }\n "}, {"sha": "4c49453232a2c7bb4218476b3d897d8abe459b43", "filename": "libstdc++-v3/src/string-inst.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2/libstdc%2B%2B-v3%2Fsrc%2Fstring-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2/libstdc%2B%2B-v3%2Fsrc%2Fstring-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fstring-inst.cc?ref=4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2", "patch": "@@ -76,6 +76,11 @@ namespace std\n     C*\n     S::_S_construct(const C*, const C*, const allocator<C>&,\n \t\t    forward_iterator_tag);\n+\n+  // Used in str::find.\n+  template\n+    const C*\n+    search(const C*, const C*, const C*, const C*, bool(*)(const C&, const C&));\n } // namespace std\n \n namespace __gnu_cxx"}, {"sha": "94259fa1438357818b63f54424f07ee9c9115ada", "filename": "libstdc++-v3/testsuite/performance/21_strings/string_find.cc", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F21_strings%2Fstring_find.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F21_strings%2Fstring_find.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F21_strings%2Fstring_find.cc?ref=4a787fa8bfc011e9cd2f8d2b4eb6aeadcf77beb2", "patch": "@@ -0,0 +1,105 @@\n+ // Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <string>\n+#include <testsuite_performance.h>\n+\n+void\n+test_pair(const std::string& s, const std::string& f, int n)\n+{\n+  std::string::size_type sz = 0;\n+\n+  for (int i = 0; i < n; ++i)\n+    sz = s.find(f);\n+}\n+\n+int main()\n+{\n+  using namespace std;\n+  using namespace __gnu_test;\n+\n+  time_counter time;\n+  resource_counter resource;\n+\n+  const unsigned int iterations = 2000000;\n+\n+  string s, f;\n+  s = \"aabbaabbaaxd adbffdadgaxaabbbddhatyaaaabbbaabbaabbcsy\";\n+  f = \"aabbaabbc\";\n+  start_counters(time, resource);\n+  test_pair(s, f, iterations);\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"1\", time, resource);\n+  clear_counters(time, resource);\n+\n+  f = \"aabbb\";\n+  start_counters(time, resource);\n+  test_pair(s, f, iterations);\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"2\", time, resource);\n+  clear_counters(time, resource);\n+\n+  f = \"xd\";\n+  start_counters(time, resource);\n+  test_pair(s, f, iterations);\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"3\", time, resource);\n+  clear_counters(time, resource);\n+\n+  s = \"dhruv is a very very good boy ;-)\";\n+  f = \"very\";\n+  start_counters(time, resource);\n+  test_pair(s, f, iterations);\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"4\", time, resource);\n+  clear_counters(time, resource);\n+\n+  f = \"bad\";\n+  start_counters(time, resource);\n+  test_pair(s, f, iterations);\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"5\", time, resource);\n+  clear_counters(time, resource);\n+\n+  f = \"extra irritating\";\n+  start_counters(time, resource);\n+  test_pair(s, f, iterations);\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"6\", time, resource);\n+  clear_counters(time, resource);\n+\n+  s = \"this is a very this is a very this is a verty this is a very \"\n+      \"this is a very long sentence\";\n+  f = \"this is a very long sentence\";\n+  start_counters(time, resource);\n+  test_pair(s, f, iterations);\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"7\", time, resource);\n+  clear_counters(time, resource);\n+\n+  return 0;\n+}"}]}