{"sha": "c3d321205faccb3dc6c1360fe96b80b44f0682ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNkMzIxMjA1ZmFjY2IzZGM2YzEzNjBmZTk2YjgwYjQ0ZjA2ODJhYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-11-18T19:36:01Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-11-18T19:36:01Z"}, "message": "tree.h (TYPE_ALIGN_OK): New flag.\n\n\t* tree.h (TYPE_ALIGN_OK): New flag.\n\t* emit-rtl.c (set_mem_attributes): Handle it.\n\t* expr.c (emit_single_push_insn): Only set to alias set 0 if\n\tdoing sibcall optimization.\n\t(expand_expr, case COMPONENT_REF): Call set_mem_attributes on case\n\twhen make temporary.\n\t(expand_expr, case CONVERT_EXPR): Simplify convert-to-union case.\n\t(expand_expr, case ADDR_EXPR): Abort if TYPE_ALIGN_OK and need copy.\n\nFrom-SVN: r47149", "tree": {"sha": "e65409914fec6e66c9baf2b8cc7705fd81ee165a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e65409914fec6e66c9baf2b8cc7705fd81ee165a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3d321205faccb3dc6c1360fe96b80b44f0682ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3d321205faccb3dc6c1360fe96b80b44f0682ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3d321205faccb3dc6c1360fe96b80b44f0682ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3d321205faccb3dc6c1360fe96b80b44f0682ab/comments", "author": null, "committer": null, "parents": [{"sha": "69deb6e055c718a94929ffd3012b149c461bb9a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69deb6e055c718a94929ffd3012b149c461bb9a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69deb6e055c718a94929ffd3012b149c461bb9a0"}], "stats": {"total": 66, "additions": 46, "deletions": 20}, "files": [{"sha": "06c94373b0d4978cb3b341bc008f354ac5b96e03", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3d321205faccb3dc6c1360fe96b80b44f0682ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3d321205faccb3dc6c1360fe96b80b44f0682ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c3d321205faccb3dc6c1360fe96b80b44f0682ab", "patch": "@@ -1,5 +1,14 @@\n Sun Nov 18 14:13:52 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* tree.h (TYPE_ALIGN_OK): New flag.\n+\t* emit-rtl.c (set_mem_attributes): Handle it.\n+\t* expr.c (emit_single_push_insn): Only set to alias set 0 if\n+\tdoing sibcall optimization.\n+\t(expand_expr, case COMPONENT_REF): Call set_mem_attributes on case\n+\twhen make temporary.\n+\t(expand_expr, case CONVERT_EXPR): Simplify convert-to-union case.\n+\t(expand_expr, case ADDR_EXPR): Abort if TYPE_ALIGN_OK and need copy.\n+\n \t* sdbout.c (sdbout_symbol): Avoid warning due to &DECL_RTL.\n \n 2001-11-18  Joseph S. Myers  <jsm28@cam.ac.uk>"}, {"sha": "ec2e4f372e13f753959ff519f5e00522f6fc4189", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3d321205faccb3dc6c1360fe96b80b44f0682ab/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3d321205faccb3dc6c1360fe96b80b44f0682ab/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=c3d321205faccb3dc6c1360fe96b80b44f0682ab", "patch": "@@ -1699,10 +1699,10 @@ set_mem_attributes (ref, t, objectp)\n   if ((objectp || DECL_P (t)) && ! AGGREGATE_TYPE_P (type))\n     MEM_SCALAR_P (ref) = 1;\n \n-  /* We can set the alignment from the type if we are makign an object or\n-     if this is an INDIRECT_REF.  */\n-  if (objectp || TREE_CODE (t) == INDIRECT_REF)\n-    align = TYPE_ALIGN (type);\n+  /* We can set the alignment from the type if we are making an object,\n+     this is an INDIRECT_REF, or if TYPE_ALIGN_OK.  */\n+  if (objectp || TREE_CODE (t) == INDIRECT_REF || TYPE_ALIGN_OK (type))\n+    align = MAX (align, TYPE_ALIGN (type));\n \n   /* If the size is known, we can set that.  */\n   if (TYPE_SIZE_UNIT (type) && host_integerp (TYPE_SIZE_UNIT (type), 1))"}, {"sha": "5d933b29543e860ca645224a6edc9651338d5441", "filename": "gcc/expr.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3d321205faccb3dc6c1360fe96b80b44f0682ab/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3d321205faccb3dc6c1360fe96b80b44f0682ab/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c3d321205faccb3dc6c1360fe96b80b44f0682ab", "patch": "@@ -3199,11 +3199,13 @@ emit_single_push_insn (mode, x, type)\n   if (type != 0)\n     {\n       set_mem_attributes (dest, type, 1);\n-      /* Function incoming arguments may overlap with sibling call\n-         outgoing arguments and we cannot allow reordering of reads\n-         from function arguments with stores to outgoing arguments\n-         of sibling calls.  */\n-      set_mem_alias_set (dest, 0);\n+\n+      if (flag_optimize_sibling_calls)\n+\t/* Function incoming arguments may overlap with sibling call\n+\t   outgoing arguments and we cannot allow reordering of reads\n+\t   from function arguments with stores to outgoing arguments\n+\t   of sibling calls.  */\n+\tset_mem_alias_set (dest, 0);\n     }\n   emit_move_insn (dest, x);\n }\n@@ -7180,13 +7182,14 @@ expand_expr (exp, target, tmode, modifier)\n \n \t    if (mode == BLKmode)\n \t      {\n-\t\ttree nt = build_qualified_type (type_for_mode (ext_mode, 0),\n-\t\t\t\t\t\tTYPE_QUAL_CONST);\n-\t\trtx new = assign_temp (nt, 0, 1, 1);\n+\t\trtx new = assign_temp (build_qualified_type\n+\t\t\t\t       (type_for_mode (ext_mode, 0),\n+\t\t\t\t\tTYPE_QUAL_CONST), 0, 1, 1);\n \n \t\temit_move_insn (new, op0);\n \t\top0 = copy_rtx (new);\n \t\tPUT_MODE (op0, BLKmode);\n+\t\tset_mem_attributes (op0, exp, 1);\n \t      }\n \n \t    return op0;\n@@ -7423,14 +7426,17 @@ expand_expr (exp, target, tmode, modifier)\n \t{\n \t  tree valtype = TREE_TYPE (TREE_OPERAND (exp, 0));\n \n-\t  /* If both input and output are BLKmode, this conversion\n-\t     isn't actually doing anything unless we need to make the\n-\t     alignment stricter.  */\n-\t  if (mode == BLKmode && TYPE_MODE (valtype) == BLKmode\n-\t      && (TYPE_ALIGN (type) <= TYPE_ALIGN (valtype)\n-\t\t  || TYPE_ALIGN (type) >= BIGGEST_ALIGNMENT))\n-\t    return expand_expr (TREE_OPERAND (exp, 0), target, tmode,\n-\t\t\t\tmodifier);\n+\t  /* If both input and output are BLKmode, this conversion isn't doing\n+\t     anything except possibly changing memory attribute.  */\n+\t  if (mode == BLKmode && TYPE_MODE (valtype) == BLKmode)\n+\t    {\n+\t      rtx result = expand_expr (TREE_OPERAND (exp, 0), target, tmode,\n+\t\t\t\t\tmodifier);\n+\n+\t      result = copy_rtx (result);\n+\t      set_mem_attributes (result, exp, 0);\n+\t      return result;\n+\t    }\n \n \t  if (target == 0)\n \t    target = assign_temp (type, 0, 1, 1);\n@@ -8673,6 +8679,9 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t\t    (TYPE_QUALS (inner_type)\n \t\t\t\t\t     | TYPE_QUAL_CONST)));\n \n+\t      if (TYPE_ALIGN_OK (inner_type))\n+\t\tabort ();\n+\n \t      emit_block_move (new, op0, expr_size (TREE_OPERAND (exp, 0)));\n \t      op0 = new;\n \t    }"}, {"sha": "9c45fb851adaa8f917765194060510d00725f8be", "filename": "gcc/tree.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3d321205faccb3dc6c1360fe96b80b44f0682ab/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3d321205faccb3dc6c1360fe96b80b44f0682ab/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c3d321205faccb3dc6c1360fe96b80b44f0682ab", "patch": "@@ -596,6 +596,14 @@ extern void tree_class_check_failed PARAMS ((const tree, int,\n    an exception.  In a CALL_EXPR, nonzero means the call cannot throw.  */\n #define TREE_NOTHROW(NODE) ((NODE)->common.nothrow_flag)\n \n+/* In a type, nonzero means that all objects of the type are guaranteed by the\n+   language or front-end to be properly aligned, so we can indicate that a MEM\n+   of this type is aligned at least to the alignment of the type, even if it\n+   doesn't appear that it is.  We see this, for example, in object-oriented\n+   languages where a tag field may show this is an object of a more-aligned\n+   variant of the more generic type.  */\n+#define TYPE_ALIGN_OK(NODE) (TYPE_CHECK (NODE)->common.nothrow_flag)\n+\n /* Used in classes in C++.  */\n #define TREE_PRIVATE(NODE) ((NODE)->common.private_flag)\n /* Used in classes in C++."}]}