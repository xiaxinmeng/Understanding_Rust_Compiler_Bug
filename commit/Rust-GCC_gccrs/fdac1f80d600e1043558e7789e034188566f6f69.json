{"sha": "fdac1f80d600e1043558e7789e034188566f6f69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRhYzFmODBkNjAwZTEwNDM1NThlNzc4OWUwMzQxODg1NjZmNmY2OQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-07T15:46:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-07T15:46:23Z"}, "message": "[multiple changes]\n\n2009-04-07  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch3.adb (Build_Derived_Record_Type): When processing a tagged\n\tderived type that has discriminants, propagate the list of interfaces\n\tto the corresponding new base type. In addition, propagate also\n\tattribute Limited_Present (found working in this patch).\n\n2009-04-07  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb: Rewrite concatenation expansion.\n\nFrom-SVN: r145684", "tree": {"sha": "206324f14c85f24ce9fc54205a2b2565f5d55ba9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/206324f14c85f24ce9fc54205a2b2565f5d55ba9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdac1f80d600e1043558e7789e034188566f6f69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdac1f80d600e1043558e7789e034188566f6f69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdac1f80d600e1043558e7789e034188566f6f69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdac1f80d600e1043558e7789e034188566f6f69/comments", "author": null, "committer": null, "parents": [{"sha": "8dbd1460a4fb14cf71da3294b4ccc86432e9ae15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dbd1460a4fb14cf71da3294b4ccc86432e9ae15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dbd1460a4fb14cf71da3294b4ccc86432e9ae15"}], "stats": {"total": 1022, "additions": 296, "deletions": 726}, "files": [{"sha": "7c2c32ab5822d74ec1d75e6edb6e7a283a9d5e0c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdac1f80d600e1043558e7789e034188566f6f69/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdac1f80d600e1043558e7789e034188566f6f69/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fdac1f80d600e1043558e7789e034188566f6f69", "patch": "@@ -1,3 +1,14 @@\n+2009-04-07  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch3.adb (Build_Derived_Record_Type): When processing a tagged\n+\tderived type that has discriminants, propagate the list of interfaces\n+\tto the corresponding new base type. In addition, propagate also\n+\tattribute Limited_Present (found working in this patch).\n+\n+2009-04-07  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb: Rewrite concatenation expansion.\n+\n 2009-04-07  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch8.adb (Restore_Scope_Stack): First_Private_Entity is only"}, {"sha": "fec4c84faf9e814862c9e5e41290dc3aee2f1afe", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 277, "deletions": 720, "changes": 997, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdac1f80d600e1043558e7789e034188566f6f69/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdac1f80d600e1043558e7789e034188566f6f69/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=fdac1f80d600e1043558e7789e034188566f6f69", "patch": "@@ -139,16 +139,11 @@ package body Exp_Ch4 is\n    --  are the left and right sides for the comparison, and Typ is the type of\n    --  the arrays to compare.\n \n-   procedure Expand_Concatenate_Other (Cnode : Node_Id; Opnds : List_Id);\n-   --  This routine handles expansion of concatenation operations, where N is\n-   --  the N_Op_Concat node being expanded and Operands is the list of operands\n-   --  (at least two are present). The caller has dealt with converting any\n-   --  singleton operands into singleton aggregates.\n-\n-   procedure Expand_Concatenate_String (Cnode : Node_Id; Opnds : List_Id);\n-   --  Routine to expand concatenation a sequence of two or more operands (in\n-   --  the list Operands) and replace node Cnode with the result of the\n-   --  concatenation. The operands can be of type String or Character.\n+   procedure Expand_Concatenate (Cnode : Node_Id; Opnds : List_Id);\n+   --  Routine to expand concatenation of a sequence of two or more operands\n+   --  (in the list Operands) and replace node Cnode with the result of the\n+   --  concatenation. The operands can be of any appropriate type, and can\n+   --  include both arrays and singleton elements.\n \n    procedure Fixup_Universal_Fixed_Operation (N : Node_Id);\n    --  N is a N_Op_Divide or N_Op_Multiply node whose result is universal\n@@ -2138,632 +2133,33 @@ package body Exp_Ch4 is\n       end if;\n    end Expand_Composite_Equality;\n \n-   ------------------------------\n-   -- Expand_Concatenate_Other --\n-   ------------------------------\n-\n-   --  Let n be the number of array operands to be concatenated, Base_Typ their\n-   --  base type, Ind_Typ their index type, and Arr_Typ the original array type\n-   --  to which the concatenation operator applies, then the following\n-   --  subprogram is constructed:\n-\n-   --  [function Cnn (S1 : Base_Typ; ...; Sn : Base_Typ) return Base_Typ is\n-   --      L : Ind_Typ;\n-   --   begin\n-   --      if S1'Length /= 0 then\n-   --         L := XXX;   -->  XXX = S1'First       if Arr_Typ is unconstrained\n-   --                          XXX = Arr_Typ'First  otherwise\n-   --      elsif S2'Length /= 0 then\n-   --         L := YYY;   -->  YYY = S2'First       if Arr_Typ is unconstrained\n-   --                          YYY = Arr_Typ'First  otherwise\n-   --      ...\n-   --      elsif Sn-1'Length /= 0 then\n-   --         L := ZZZ;   -->  ZZZ = Sn-1'First     if Arr_Typ is unconstrained\n-   --                          ZZZ = Arr_Typ'First  otherwise\n-   --      else\n-   --         return Sn;\n-   --      end if;\n-\n-   --      declare\n-   --         P : Ind_Typ;\n-   --         H : Ind_Typ :=\n-   --          Ind_Typ'Val ((((S1'Length - 1) + S2'Length) + ... + Sn'Length)\n-   --                       + Ind_Typ'Pos (L));\n-   --         R : Base_Typ (L .. H);\n-   --      begin\n-   --         if S1'Length /= 0 then\n-   --            P := S1'First;\n-   --            loop\n-   --               R (L) := S1 (P);\n-   --               L := Ind_Typ'Succ (L);\n-   --               exit when P = S1'Last;\n-   --               P := Ind_Typ'Succ (P);\n-   --            end loop;\n-   --         end if;\n-   --\n-   --         if S2'Length /= 0 then\n-   --            L := Ind_Typ'Succ (L);\n-   --            loop\n-   --               R (L) := S2 (P);\n-   --               L := Ind_Typ'Succ (L);\n-   --               exit when P = S2'Last;\n-   --               P := Ind_Typ'Succ (P);\n-   --            end loop;\n-   --         end if;\n-\n-   --         ...\n-\n-   --         if Sn'Length /= 0 then\n-   --            P := Sn'First;\n-   --            loop\n-   --               R (L) := Sn (P);\n-   --               L := Ind_Typ'Succ (L);\n-   --               exit when P = Sn'Last;\n-   --               P := Ind_Typ'Succ (P);\n-   --            end loop;\n-   --         end if;\n-\n-   --         return R;\n-   --      end;\n-   --   end Cnn;]\n-\n-   procedure Expand_Concatenate_Other (Cnode : Node_Id; Opnds : List_Id) is\n-      Loc      : constant Source_Ptr := Sloc (Cnode);\n-      Nb_Opnds : constant Nat        := List_Length (Opnds);\n-\n-      Arr_Typ  : constant Entity_Id := Etype (Entity (Cnode));\n-      Base_Typ : constant Entity_Id := Base_Type (Etype (Cnode));\n-      Ind_Typ  : constant Entity_Id := Etype (First_Index (Base_Typ));\n-\n-      Func_Id     : Node_Id;\n-      Func_Spec   : Node_Id;\n-      Param_Specs : List_Id;\n-\n-      Func_Body  : Node_Id;\n-      Func_Decls : List_Id;\n-      Func_Stmts : List_Id;\n-\n-      L_Decl     : Node_Id;\n-\n-      If_Stmt    : Node_Id;\n-      Elsif_List : List_Id;\n-\n-      Declare_Block : Node_Id;\n-      Declare_Decls : List_Id;\n-      Declare_Stmts : List_Id;\n-\n-      H_Decl   : Node_Id;\n-      I_Decl   : Node_Id;\n-      H_Init   : Node_Id;\n-      P_Decl   : Node_Id;\n-      R_Decl   : Node_Id;\n-      R_Constr : Node_Id;\n-      R_Range  : Node_Id;\n-\n-      Params  : List_Id;\n-      Operand : Node_Id;\n-\n-      function Copy_Into_R_S (I : Nat; Last : Boolean) return List_Id;\n-      --  Builds the sequence of statement:\n-      --    P := Si'First;\n-      --    loop\n-      --       R (L) := Si (P);\n-      --       L := Ind_Typ'Succ (L);\n-      --       exit when P = Si'Last;\n-      --       P := Ind_Typ'Succ (P);\n-      --    end loop;\n-      --\n-      --  where i is the input parameter I given.\n-      --  If the flag Last is true, the exit statement is emitted before\n-      --  incrementing the lower bound, to prevent the creation out of\n-      --  bound values.\n-\n-      function Init_L (I : Nat) return Node_Id;\n-      --  Builds the statement:\n-      --    L := Arr_Typ'First;  If Arr_Typ is constrained\n-      --    L := Si'First;       otherwise (where I is the input param given)\n-\n-      function H return Node_Id;\n-      --  Builds reference to identifier H\n-\n-      function Ind_Val (E : Node_Id) return Node_Id;\n-      --  Builds expression Ind_Typ'Val (E);\n-\n-      function L return Node_Id;\n-      --  Builds reference to identifier L\n-\n-      function L_Pos return Node_Id;\n-      --  Builds expression Integer_Type'(Ind_Typ'Pos (L)). We qualify the\n-      --  expression to avoid universal_integer computations whenever possible,\n-      --  in the expression for the upper bound H.\n-\n-      function L_Succ return Node_Id;\n-      --  Builds expression Ind_Typ'Succ (L)\n-\n-      function One return Node_Id;\n-      --  Builds integer literal one\n-\n-      function P return Node_Id;\n-      --  Builds reference to identifier P\n-\n-      function P_Succ return Node_Id;\n-      --  Builds expression Ind_Typ'Succ (P)\n-\n-      function R return Node_Id;\n-      --  Builds reference to identifier R\n-\n-      function S (I : Nat) return Node_Id;\n-      --  Builds reference to identifier Si, where I is the value given\n-\n-      function S_First (I : Nat) return Node_Id;\n-      --  Builds expression Si'First, where I is the value given\n-\n-      function S_Last (I : Nat) return Node_Id;\n-      --  Builds expression Si'Last, where I is the value given\n-\n-      function S_Length (I : Nat) return Node_Id;\n-      --  Builds expression Si'Length, where I is the value given\n-\n-      function S_Length_Test (I : Nat) return Node_Id;\n-      --  Builds expression Si'Length /= 0, where I is the value given\n-\n-      -------------------\n-      -- Copy_Into_R_S --\n-      -------------------\n-\n-      function Copy_Into_R_S (I : Nat; Last : Boolean) return List_Id is\n-         Stmts     : constant List_Id := New_List;\n-         P_Start   : Node_Id;\n-         Loop_Stmt : Node_Id;\n-         R_Copy    : Node_Id;\n-         Exit_Stmt : Node_Id;\n-         L_Inc     : Node_Id;\n-         P_Inc     : Node_Id;\n-\n-      begin\n-         --  First construct the initializations\n-\n-         P_Start := Make_Assignment_Statement (Loc,\n-                      Name       => P,\n-                      Expression => S_First (I));\n-         Append_To (Stmts, P_Start);\n-\n-         --  Then build the loop\n-\n-         R_Copy := Make_Assignment_Statement (Loc,\n-                     Name       => Make_Indexed_Component (Loc,\n-                                     Prefix      => R,\n-                                     Expressions => New_List (L)),\n-                     Expression => Make_Indexed_Component (Loc,\n-                                     Prefix      => S (I),\n-                                     Expressions => New_List (P)));\n-\n-         L_Inc := Make_Assignment_Statement (Loc,\n-                    Name       => L,\n-                    Expression => L_Succ);\n-\n-         Exit_Stmt := Make_Exit_Statement (Loc,\n-                        Condition => Make_Op_Eq (Loc, P, S_Last (I)));\n-\n-         P_Inc := Make_Assignment_Statement (Loc,\n-                    Name       => P,\n-                    Expression => P_Succ);\n-\n-         if Last then\n-            Loop_Stmt :=\n-              Make_Implicit_Loop_Statement (Cnode,\n-                Statements => New_List (R_Copy, Exit_Stmt, L_Inc, P_Inc));\n-         else\n-            Loop_Stmt :=\n-              Make_Implicit_Loop_Statement (Cnode,\n-                Statements => New_List (R_Copy, L_Inc, Exit_Stmt, P_Inc));\n-         end if;\n-\n-         Append_To (Stmts, Loop_Stmt);\n-\n-         return Stmts;\n-      end Copy_Into_R_S;\n-\n-      -------\n-      -- H --\n-      -------\n-\n-      function H return Node_Id is\n-      begin\n-         return Make_Identifier (Loc, Name_uH);\n-      end H;\n-\n-      -------------\n-      -- Ind_Val --\n-      -------------\n-\n-      function Ind_Val (E : Node_Id) return Node_Id is\n-      begin\n-         return\n-           Make_Attribute_Reference (Loc,\n-             Prefix         => New_Reference_To (Ind_Typ, Loc),\n-             Attribute_Name => Name_Val,\n-             Expressions    => New_List (E));\n-      end Ind_Val;\n-\n-      ------------\n-      -- Init_L --\n-      ------------\n-\n-      function Init_L (I : Nat) return Node_Id is\n-         E : Node_Id;\n-\n-      begin\n-         if Is_Constrained (Arr_Typ) then\n-            E := Make_Attribute_Reference (Loc,\n-                   Prefix         => New_Reference_To (Arr_Typ, Loc),\n-                   Attribute_Name => Name_First);\n-\n-         else\n-            E := S_First (I);\n-         end if;\n-\n-         return Make_Assignment_Statement (Loc, Name => L, Expression => E);\n-      end Init_L;\n-\n-      -------\n-      -- L --\n-      -------\n-\n-      function L return Node_Id is\n-      begin\n-         return Make_Identifier (Loc, Name_uL);\n-      end L;\n-\n-      -----------\n-      -- L_Pos --\n-      -----------\n-\n-      function L_Pos return Node_Id is\n-         Target_Type : Entity_Id;\n-\n-      begin\n-         --  If the index type is an enumeration type, the computation can be\n-         --  done in standard integer. Otherwise, choose a large enough integer\n-         --  type to accommodate the index type computation.\n-\n-         if Is_Enumeration_Type (Ind_Typ)\n-           or else Root_Type (Ind_Typ) = Standard_Integer\n-           or else Root_Type (Ind_Typ) = Standard_Short_Integer\n-           or else Root_Type (Ind_Typ) = Standard_Short_Short_Integer\n-           or else Is_Modular_Integer_Type (Ind_Typ)\n-         then\n-            Target_Type := Standard_Integer;\n-         else\n-            Target_Type := Root_Type (Ind_Typ);\n-         end if;\n-\n-         return\n-           Make_Qualified_Expression (Loc,\n-              Subtype_Mark => New_Reference_To (Target_Type, Loc),\n-              Expression   =>\n-                Make_Attribute_Reference (Loc,\n-                  Prefix         => New_Reference_To (Ind_Typ, Loc),\n-                  Attribute_Name => Name_Pos,\n-                  Expressions    => New_List (L)));\n-      end L_Pos;\n-\n-      ------------\n-      -- L_Succ --\n-      ------------\n-\n-      function L_Succ return Node_Id is\n-      begin\n-         return\n-           Make_Attribute_Reference (Loc,\n-             Prefix         => New_Reference_To (Ind_Typ, Loc),\n-             Attribute_Name => Name_Succ,\n-             Expressions    => New_List (L));\n-      end L_Succ;\n-\n-      ---------\n-      -- One --\n-      ---------\n-\n-      function One return Node_Id is\n-      begin\n-         return Make_Integer_Literal (Loc, 1);\n-      end One;\n-\n-      -------\n-      -- P --\n-      -------\n-\n-      function P return Node_Id is\n-      begin\n-         return Make_Identifier (Loc, Name_uP);\n-      end P;\n-\n-      ------------\n-      -- P_Succ --\n-      ------------\n-\n-      function P_Succ return Node_Id is\n-      begin\n-         return\n-           Make_Attribute_Reference (Loc,\n-             Prefix         => New_Reference_To (Ind_Typ, Loc),\n-             Attribute_Name => Name_Succ,\n-             Expressions    => New_List (P));\n-      end P_Succ;\n-\n-      -------\n-      -- R --\n-      -------\n-\n-      function R return Node_Id is\n-      begin\n-         return Make_Identifier (Loc, Name_uR);\n-      end R;\n-\n-      -------\n-      -- S --\n-      -------\n-\n-      function S (I : Nat) return Node_Id is\n-      begin\n-         return Make_Identifier (Loc, New_External_Name ('S', I));\n-      end S;\n-\n-      -------------\n-      -- S_First --\n-      -------------\n-\n-      function S_First (I : Nat) return Node_Id is\n-      begin\n-         return Make_Attribute_Reference (Loc,\n-                  Prefix         => S (I),\n-                  Attribute_Name => Name_First);\n-      end S_First;\n-\n-      ------------\n-      -- S_Last --\n-      ------------\n-\n-      function S_Last (I : Nat) return Node_Id is\n-      begin\n-         return Make_Attribute_Reference (Loc,\n-                  Prefix         => S (I),\n-                  Attribute_Name => Name_Last);\n-      end S_Last;\n-\n-      --------------\n-      -- S_Length --\n-      --------------\n-\n-      function S_Length (I : Nat) return Node_Id is\n-      begin\n-         return Make_Attribute_Reference (Loc,\n-                  Prefix         => S (I),\n-                  Attribute_Name => Name_Length);\n-      end S_Length;\n-\n-      -------------------\n-      -- S_Length_Test --\n-      -------------------\n-\n-      function S_Length_Test (I : Nat) return Node_Id is\n-      begin\n-         return\n-           Make_Op_Ne (Loc,\n-             Left_Opnd  => S_Length (I),\n-             Right_Opnd => Make_Integer_Literal (Loc, 0));\n-      end S_Length_Test;\n-\n-   --  Start of processing for Expand_Concatenate_Other\n-\n-   begin\n-      --  Construct the parameter specs and the overall function spec\n-\n-      Param_Specs := New_List;\n-      for I in 1 .. Nb_Opnds loop\n-         Append_To\n-           (Param_Specs,\n-            Make_Parameter_Specification (Loc,\n-              Defining_Identifier =>\n-                Make_Defining_Identifier (Loc, New_External_Name ('S', I)),\n-              Parameter_Type      => New_Reference_To (Base_Typ, Loc)));\n-      end loop;\n-\n-      Func_Id := Make_Defining_Identifier (Loc, New_Internal_Name ('C'));\n-      Func_Spec :=\n-        Make_Function_Specification (Loc,\n-          Defining_Unit_Name       => Func_Id,\n-          Parameter_Specifications => Param_Specs,\n-          Result_Definition        => New_Reference_To (Base_Typ, Loc));\n-\n-      --  Construct L's object declaration\n-\n-      L_Decl :=\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Make_Defining_Identifier (Loc, Name_uL),\n-          Object_Definition   => New_Reference_To (Ind_Typ, Loc));\n-\n-      Func_Decls := New_List (L_Decl);\n-\n-      --  Construct the if-then-elsif statements\n-\n-      Elsif_List := New_List;\n-      for I in 2 .. Nb_Opnds - 1 loop\n-         Append_To (Elsif_List, Make_Elsif_Part (Loc,\n-                                  Condition       => S_Length_Test (I),\n-                                  Then_Statements => New_List (Init_L (I))));\n-      end loop;\n-\n-      If_Stmt :=\n-        Make_Implicit_If_Statement (Cnode,\n-          Condition       => S_Length_Test (1),\n-          Then_Statements => New_List (Init_L (1)),\n-          Elsif_Parts     => Elsif_List,\n-          Else_Statements => New_List (Make_Simple_Return_Statement (Loc,\n-                                         Expression => S (Nb_Opnds))));\n-\n-      --  Construct the declaration for H\n-\n-      P_Decl :=\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Make_Defining_Identifier (Loc, Name_uP),\n-          Object_Definition   => New_Reference_To (Ind_Typ, Loc));\n-\n-      H_Init := Make_Op_Subtract (Loc, S_Length (1), One);\n-      for I in 2 .. Nb_Opnds loop\n-         H_Init := Make_Op_Add (Loc, H_Init, S_Length (I));\n-      end loop;\n-\n-      --  If the index type is small modular type, we need to perform an\n-      --  additional check that the upper bound fits in the index type.\n-      --  Otherwise the computation of the upper bound can wrap around\n-      --  and yield meaningless results. The constraint check has to be\n-      --  explicit in the code, because the generated function is compiled\n-      --  with checks disabled, for efficiency.\n-\n-      if Is_Modular_Integer_Type (Ind_Typ)\n-        and then Esize (Ind_Typ) < Esize (Standard_Integer)\n-      then\n-         I_Decl :=\n-            Make_Object_Declaration (Loc,\n-             Defining_Identifier => Make_Defining_Identifier (Loc, Name_uI),\n-             Object_Definition   => New_Reference_To (Standard_Integer, Loc),\n-             Expression          =>\n-               Make_Type_Conversion (Loc,\n-                  New_Reference_To (Standard_Integer, Loc),\n-                  Make_Op_Add (Loc, H_Init, L_Pos)));\n-\n-         H_Init :=\n-           Ind_Val (\n-             Make_Type_Conversion (Loc,\n-               New_Reference_To (Ind_Typ, Loc),\n-               New_Reference_To (Defining_Identifier (I_Decl), Loc)));\n-\n-      --  For other index types, computation is safe\n-\n-      else\n-         H_Init := Ind_Val (Make_Op_Add (Loc, H_Init, L_Pos));\n-      end if;\n-\n-      H_Decl :=\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Make_Defining_Identifier (Loc, Name_uH),\n-          Object_Definition   => New_Reference_To (Ind_Typ, Loc),\n-          Expression          => H_Init);\n-\n-      --  Construct the declaration for R\n-\n-      R_Range := Make_Range (Loc, Low_Bound => L, High_Bound => H);\n-      R_Constr :=\n-        Make_Index_Or_Discriminant_Constraint (Loc,\n-          Constraints => New_List (R_Range));\n-\n-      R_Decl :=\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Make_Defining_Identifier (Loc, Name_uR),\n-          Object_Definition   =>\n-            Make_Subtype_Indication (Loc,\n-               Subtype_Mark => New_Reference_To (Base_Typ, Loc),\n-               Constraint   => R_Constr));\n-\n-      --  Construct the declarations for the declare block\n-\n-      Declare_Decls := New_List (P_Decl, H_Decl, R_Decl);\n-\n-      --  Add constraint check for the modular index case\n-\n-      if Is_Modular_Integer_Type (Ind_Typ)\n-        and then Esize (Ind_Typ) < Esize (Standard_Integer)\n-      then\n-         Insert_After (P_Decl, I_Decl);\n-\n-         Insert_After (I_Decl,\n-            Make_Raise_Constraint_Error (Loc,\n-               Condition =>\n-                  Make_Op_Gt (Loc,\n-                     Left_Opnd =>\n-                       New_Reference_To (Defining_Identifier (I_Decl), Loc),\n-                     Right_Opnd =>\n-                       Make_Type_Conversion (Loc,\n-                          New_Reference_To (Standard_Integer, Loc),\n-                          Make_Attribute_Reference (Loc,\n-                             Prefix => New_Reference_To (Ind_Typ, Loc),\n-                             Attribute_Name => Name_Last))),\n-                Reason => CE_Range_Check_Failed));\n-      end if;\n-\n-      --  Construct list of statements for the declare block\n-\n-      Declare_Stmts := New_List;\n-      for I in 1 .. Nb_Opnds loop\n-         Append_To (Declare_Stmts,\n-                    Make_Implicit_If_Statement (Cnode,\n-                      Condition       => S_Length_Test (I),\n-                      Then_Statements => Copy_Into_R_S (I, I = Nb_Opnds)));\n-      end loop;\n-\n-      Append_To\n-        (Declare_Stmts, Make_Simple_Return_Statement (Loc, Expression => R));\n-\n-      --  Construct the declare block\n-\n-      Declare_Block := Make_Block_Statement (Loc,\n-        Declarations               => Declare_Decls,\n-        Handled_Statement_Sequence =>\n-          Make_Handled_Sequence_Of_Statements (Loc, Declare_Stmts));\n-\n-      --  Construct the list of function statements\n-\n-      Func_Stmts := New_List (If_Stmt, Declare_Block);\n-\n-      --  Construct the function body\n-\n-      Func_Body :=\n-        Make_Subprogram_Body (Loc,\n-          Specification              => Func_Spec,\n-          Declarations               => Func_Decls,\n-          Handled_Statement_Sequence =>\n-            Make_Handled_Sequence_Of_Statements (Loc, Func_Stmts));\n-\n-      --  Insert the newly generated function in the code. This is analyzed\n-      --  with all checks off, since we have completed all the checks.\n-\n-      --  Note that this does *not* fix the array concatenation bug when the\n-      --  low bound is Integer'first sibce that bug comes from the pointer\n-      --  dereferencing an unconstrained array. And there we need a constraint\n-      --  check to make sure the length of the concatenated array is ok. ???\n-\n-      Insert_Action (Cnode, Func_Body, Suppress => All_Checks);\n-\n-      --  Construct list of arguments for the function call\n+   ------------------------\n+   -- Expand_Concatenate --\n+   ------------------------\n \n-      Params := New_List;\n-      Operand  := First (Opnds);\n-      for I in 1 .. Nb_Opnds loop\n-         Append_To (Params, Relocate_Node (Operand));\n-         Next (Operand);\n-      end loop;\n+   procedure Expand_Concatenate (Cnode : Node_Id; Opnds : List_Id) is\n+      Loc : constant Source_Ptr := Sloc (Cnode);\n \n-      --  Insert the function call\n+      Atyp : constant Entity_Id := Base_Type (Etype (Cnode));\n+      --  Result type of concatenation\n \n-      Rewrite\n-        (Cnode,\n-         Make_Function_Call (Loc, New_Reference_To (Func_Id, Loc), Params));\n+      Ctyp : constant Entity_Id := Base_Type (Component_Type (Etype (Cnode)));\n+      --  Component type. Elements of this component type can appear as one\n+      --  of the operands of concatenation as well as arrays.\n \n-      Analyze_And_Resolve (Cnode, Base_Typ);\n-      Set_Is_Inlined (Func_Id);\n-   end Expand_Concatenate_Other;\n+      Ityp : constant Entity_Id := Etype (First_Index (Atyp));\n+      --  Index type\n \n-   -------------------------------\n-   -- Expand_Concatenate_String --\n-   -------------------------------\n+      Intyp : Entity_Id;\n+      --  This is the type we use to do arithmetic to compute the bounds and\n+      --  lengths of operands. The choice of this type is a little subtle and\n+      --  is discussed in a separate section at the start of the body code.\n \n-   procedure Expand_Concatenate_String (Cnode : Node_Id; Opnds : List_Id) is\n-      Loc : constant Source_Ptr := Sloc (Cnode);\n+      Concatenation_Error : exception;\n+      --  Raised if concatenation is sure to raise a CE\n \n       N : constant Nat := List_Length (Opnds);\n-      --  Number of concatenation operands including nulls\n+      --  Number of concatenation operands including possibly null operands\n \n       NN : Nat := 0;\n       --  Number of operands excluding any known to be null\n@@ -2778,14 +2174,12 @@ package body Exp_Ch4 is\n       --  Set to the corresponding entry in the Opnds list\n \n       Fixed_Length : array (1 .. N) of Uint;\n-      --  Set to length of operand. Entries in this array are set only if\n-      --  the corresponding entry in Is_Fixed_Length is True. Note that the\n-      --  values in this array are always greater than zero, since we exclude\n-      --  any\n+      --  Set to length of operand. Entries in this array are set only if the\n+      --  corresponding entry in Is_Fixed_Length is True.\n \n       Fixed_Low_Bound : array (1 .. N) of Uint;\n       --  Set to lower bound of operand. Entries in this array are set only\n-      --  if the corresponding entry in Is_Fixed_Length are True.\n+      --  if the corresponding entry in Is_Fixed_Length is True.\n \n       Var_Length : array (1 .. N) of Entity_Id;\n       --  Set to an entity of type Natural that contains the length of an\n@@ -2794,11 +2188,11 @@ package body Exp_Ch4 is\n       --  is False.\n \n       Aggr_Length : array (0 .. N) of Node_Id;\n-      --  The J'th entry in an expression node that represents the total\n-      --  length of operands 1 through J. It is either an integer literal\n-      --  node, or a reference to a constant entity with the right value,\n-      --  so it is fine to just do a Copy_Node to get an appropriate copy.\n-      --  The extra zero'th entry always is set to zero.\n+      --  The J'th entry in an expression node that represents the total length\n+      --  of operands 1 through J. It is either an integer literal node, or a\n+      --  reference to a constant entity with the right value, so it is fine\n+      --  to just do a Copy_Node to get an appropriate copy. The extra zero'th\n+      --  entry always is set to zero.\n \n       Low_Bound : Node_Id;\n       --  An tree node representing the low bound of the result. This is either\n@@ -2808,6 +2202,90 @@ package body Exp_Ch4 is\n       Result : Node_Id;\n       --  Result of the concatenation\n \n+      function To_Intyp (X : Node_Id) return Node_Id;\n+      --  Given a node of type Ityp, returns the corresponding value of type\n+      --  Intyp. For non-enumeration types, this is the identity. For enum\n+      --  types. the Pos of the value is returned.\n+\n+      function To_Ityp (X : Node_Id) return Node_Id;\n+      --  The inverse function (uses Val in the case of enumeration types\n+\n+      --------------\n+      -- To_Intyp --\n+      --------------\n+\n+      function To_Intyp (X : Node_Id) return Node_Id is\n+      begin\n+         if Ityp = Intyp then\n+            return X;\n+\n+         elsif Is_Enumeration_Type (Ityp) then\n+            return\n+              Make_Attribute_Reference (Loc,\n+                Prefix         => New_Occurrence_Of (Ityp, Loc),\n+                Attribute_Name => Name_Pos,\n+                Expressions    => New_List (X));\n+\n+         else\n+            return Convert_To (Intyp, X);\n+         end if;\n+      end To_Intyp;\n+\n+      -------------\n+      -- To_Ityp --\n+      -------------\n+\n+      function To_Ityp (X : Node_Id) return Node_Id is\n+      begin\n+         if Intyp = Ityp then\n+            return X;\n+\n+         elsif Is_Enumeration_Type (Ityp) then\n+            return\n+              Make_Attribute_Reference (Loc,\n+                Prefix         => New_Occurrence_Of (Ityp, Loc),\n+                Attribute_Name => Name_Val,\n+                Expressions    => New_List (X));\n+\n+         --  Case where we will do a type conversion\n+\n+         else\n+            --  If the value is known at compile time, and known to be out\n+            --  of range of the index type or the base type, we can signal\n+            --  that we are sure to have a constraint error at run time.\n+\n+            --  There are two reasons for doing this. First of all, it is of\n+            --  course nice to detect situations of certain exceptions, and\n+            --  generate a warning. But there is a more important reason. If\n+            --  the high bound is out of range of the base type, and is a\n+            --  literal, then that would cause a compilation illegality when\n+            --  we analyzed and resolved the expression.\n+\n+            Set_Parent (X, Cnode);\n+            Analyze_And_Resolve (X, Intyp);\n+\n+            if Compile_Time_Compare\n+                 (X, Type_High_Bound (Ityp),\n+                  Assume_Valid => False) = GT\n+              or else\n+               Compile_Time_Compare\n+                 (X, Type_High_Bound (Base_Type (Ityp)),\n+                  Assume_Valid => False) = GT\n+            then\n+               Apply_Compile_Time_Constraint_Error\n+                 (N      => Cnode,\n+                  Msg    => \"concatenation result upper bound out of range?\",\n+                  Reason => CE_Range_Check_Failed);\n+               raise Concatenation_Error;\n+\n+            else\n+               return Convert_To (Ityp, X);\n+            end if;\n+         end if;\n+      end To_Ityp;\n+\n+      --  Local Declarations\n+\n       Opnd : Node_Id;\n       Ent  : Entity_Id;\n       Len  : Uint;\n@@ -2818,29 +2296,119 @@ package body Exp_Ch4 is\n    begin\n       Aggr_Length (0) := Make_Integer_Literal (Loc, 0);\n \n-      --  Go through operands settinn up the above arrays\n+      --  Choose an appropriate computational type\n+\n+      --  We will be doing calculations of lengths and bounds in this routine\n+      --  and computing one from the other in some cases, e.g. getting the high\n+      --  bound by adding the length-1 to the low bound.\n+\n+      --  We can't just use the index type, or even its base type for this\n+      --  purpose for two reasons. First it might be an enumeration type which\n+      --  is not suitable fo computations of any kind, and second it may simply\n+      --  not have enough range. For example if the index type is -128..+127\n+      --  then lengths can be up to 256, which is out of range of the type.\n+\n+      --  For enumeration types, we can simply use Standard_Integer, this is\n+      --  sufficient since the actual number of enumeration literals cannot\n+      --  possibly exceed the range of integer (remember we will be doing the\n+      --  arithmetic with POS values, not represaentation values).\n+\n+      if Is_Enumeration_Type (Ityp) then\n+         Intyp := Standard_Integer;\n+\n+      elsif Atyp = Standard_String then\n+         Intyp := Standard_Natural;\n+\n+      --  For unsigned types, we can safely use a 32-bit unsigned type for any\n+      --  type whose size is in the range 1-31 bits, and we can safely use a\n+      --  64-bit unsigned type for any type whose size is in the range 33-63\n+      --  bits. So those case are easy. For 64-bit unsigned types, there is no\n+      --  possible type to use, since the maximum length is 2**64 which is not\n+      --  representable in any type. We just use a 64-bit unsigned type anyway,\n+      --  and won't be able to handle objects that big, which is no loss in\n+      --  practice (we will raise CE in this case).\n+\n+      --  32-bit unsigned types are a bit of a problem. If we are on a 64-bit\n+      --  machine where 64-bit arithmetic is presumably efficient, then we can\n+      --  just use the 64-bit type. But we really hate to do that on a 32-bit\n+      --  machine since it could be quite inefficient. So on a 32-bit machine,\n+      --  we use the 32-bit unsigned type, and too bad if we can't handle\n+      --  arrays with 2**32 elements (the programmer can always get around\n+      --  this by using a 64-bit type as an index).\n+\n+      elsif Is_Unsigned_Type (Ityp) then\n+         if RM_Size (Ityp) < RM_Size (Standard_Unsigned) then\n+            Intyp := Standard_Unsigned;\n+\n+         elsif RM_Size (Ityp) = RM_Size (Standard_Unsigned)\n+           and then System_Address_Size = 32\n+         then\n+            Intyp := Ityp;\n+\n+         else\n+            Intyp := RTE (RE_Long_Long_Unsigned);\n+         end if;\n+\n+      --  For signed types, the considerations are similar to the unsigned case\n+      --  for types with sizes in the range 1-30 or 33-64, but now 30 and 31\n+      --  are both problems (the 31-bit type can have a length of 2**31 which\n+      --  is out of the range of standard integer), but again, we don't want\n+      --  the inefficiency of using 64-bit arithmetic on a 32-bit machine.\n+\n+      else\n+         if RM_Size (Ityp) < (RM_Size (Standard_Integer) - 1)\n+           or (RM_Size (Ityp) = (RM_Size (Standard_Integer) - 1)\n+                and then System_Address_Size = 32)\n+         then\n+            Intyp := Standard_Integer;\n+\n+         elsif RM_Size (Ityp) = RM_Size (Standard_Integer)\n+           and then System_Address_Size = 32\n+         then\n+            Intyp := Ityp;\n+\n+         else\n+            Intyp := Standard_Long_Long_Integer;\n+         end if;\n+      end if;\n+\n+      --  Go through operands setting up the above arrays\n \n       J := 1;\n       while J <= N loop\n          Opnd := Remove_Head (Opnds);\n+\n+         --  The parent got messed up when we put the operands in a list,\n+         --  so now put back the proper parent for the saved operand.\n+\n          Set_Parent (Opnd, Parent (Cnode));\n+\n+         --  Set will be True when we have setup one entry in the array\n+\n          Set := False;\n \n-         --  Character or Character literal case\n+         --  Singleton element (or character literal) case\n \n-         if Base_Type (Etype (Opnd)) = Standard_Character then\n+         if Base_Type (Etype (Opnd)) = Ctyp then\n             NN := NN + 1;\n             Operands (NN) := Opnd;\n             Is_Fixed_Length (NN) := True;\n             Fixed_Length (NN) := Uint_1;\n+\n+            --  Set lower bound to 1, that's right for characters, but is\n+            --  it really right for other types ???\n+\n             Fixed_Low_Bound (NN) := Uint_1;\n             Set := True;\n \n-         --  String literal case\n+         --  String literal case (can only occur for strings of course)\n \n          elsif Nkind (Opnd) = N_String_Literal then\n             Len := UI_From_Int (String_Length (Strval (Opnd)));\n \n+            --  We can safely skip null string literals, since they are\n+            --  considered to have a lower bound of 1.\n+\n             if Len = 0 then\n                goto Continue;\n             end if;\n@@ -2866,8 +2434,8 @@ package body Exp_Ch4 is\n                   Hi       : constant Node_Id   := Type_High_Bound (Indx_Typ);\n \n                begin\n-                  --  Fixed length constrained string type with known at\n-                  --  compile time bounds is last case of fixed length\n+                  --  Fixed length constrained array type with known at compile\n+                  --  time bounds is last case of fixed length operand.\n \n                   if Compile_Time_Known_Value (Lo)\n                        and then\n@@ -2881,13 +2449,15 @@ package body Exp_Ch4 is\n \n                      begin\n                         --  Exclude the null length case where the lower bound\n-                        --  is other than 1 because annoyingly we need to keep\n-                        --  such an operand around in case it is the one that\n-                        --  supplies a lower bound to the result.\n+                        --  is other than 1 or the type is other than string,\n+                        --  because annoyingly we need to keep such an operand\n+                        --  around in case it is the one that supplies a lower\n+                        --  bound to the result.\n \n-                        if Loval = 1 or Len > 0 then\n-\n-                           --  Skip null case (we know that low bound is 1)\n+                        if (Loval = 1 and then Atyp = Standard_String)\n+                          or Len > 0\n+                        then\n+                           --  Skip null string case (lower bound = 1)\n \n                            if Len = 0 then\n                               goto Continue;\n@@ -2905,10 +2475,10 @@ package body Exp_Ch4 is\n                end;\n             end if;\n \n-            --  All cases where the length is not known at compile time, or the\n-            --  special case of an operand which is known to be null but has a\n-            --  lower bound other than 1. Capture length of operand in entity.\n-            --  separate entities\n+            --  All cases where the length is not known at compile time, or\n+            --  the special case of an operand which is known to be null but\n+            --  has a lower bound other than 1 or is other than a string type.\n+            --  Capture length of operand in entity.\n \n             if not Set then\n                NN := NN + 1;\n@@ -2925,7 +2495,7 @@ package body Exp_Ch4 is\n                    Constant_Present    => True,\n \n                    Object_Definition   =>\n-                     New_Occurrence_Of (Standard_Natural, Loc),\n+                     New_Occurrence_Of (Intyp, Loc),\n \n                    Expression          =>\n                      Make_Attribute_Reference (Loc,\n@@ -2982,7 +2552,7 @@ package body Exp_Ch4 is\n                 Constant_Present    => True,\n \n                 Object_Definition   =>\n-                  New_Occurrence_Of (Standard_Natural, Loc),\n+                  New_Occurrence_Of (Intyp, Loc),\n \n                 Expression          =>\n                   Make_Op_Add (Loc,\n@@ -3000,9 +2570,10 @@ package body Exp_Ch4 is\n          J := J + 1;\n       end loop;\n \n-      --  If we have only null operands, return a null string literal. Note\n-      --  that this means the lower bound is 1, but we retained any known null\n-      --  operands whose lower bound was not 1, so this is legitimate.\n+      --  If we have only skipped null operands, return a null string literal.\n+      --  Note that this means the lower bound is 1 and the type is string,\n+      --  since we retained any null operands with a type other than string,\n+      --  or a lower bound other than one, so this is a legitimate assumption.\n \n       if NN = 0 then\n          Start_String;\n@@ -3014,27 +2585,40 @@ package body Exp_Ch4 is\n \n       --  If we have only one non-null operand, return it and we are done.\n       --  There is one case in which this cannot be done, and that is when\n-      --  the sole operand is of a character type, in which case it must be\n-      --  converted to a string, and the easiest way of doing that is to go\n+      --  the sole operand is of the element type, in which case it must be\n+      --  converted to an array, and the easiest way of doing that is to go\n       --  through the normal general circuit.\n \n       if NN = 1\n-        and then Base_Type (Etype (Operands (1))) /= Standard_Character\n+        and then Base_Type (Etype (Operands (1))) /= Ctyp\n       then\n          Result := Operands (1);\n          goto Done;\n       end if;\n \n       --  Cases where we have a real concatenation\n \n-      --  Next step is to find the low bound for the result string that we\n-      --  will allocate. Annoyingly this is not simply the low bound of the\n-      --  first argument, because of the darned null string special exception.\n+      --  Next step is to find the low bound for the result array that we\n+      --  will allocate. The rules for this are in (RM 4.5.6(5-7)).\n+\n+      --  If the ultimate ancestor of the index subtype is a constrained array\n+      --  definition, then the lower bound is that of the index subtype as\n+      --  specified by (RM 4.5.3(6)).\n+\n+      --  The right test here is to go to the root type, and then the ultimate\n+      --  ancestor is the first subtype of this root type.\n+\n+      if Is_Constrained (First_Subtype (Root_Type (Atyp))) then\n+         Low_Bound := To_Intyp (\n+           Make_Attribute_Reference (Loc,\n+             Prefix         =>\n+               New_Occurrence_Of (First_Subtype (Root_Type (Atyp)), Loc),\n+             Attribute_Name => Name_First));\n \n       --  If the first operand in the list has known length we know that\n       --  the lower bound of the result is the lower bound of this operand.\n \n-      if Is_Fixed_Length (1) then\n+      elsif Is_Fixed_Length (1) then\n          Low_Bound :=\n            Make_Integer_Literal (Loc,\n              Intval => Fixed_Low_Bound (1));\n@@ -3074,11 +2658,11 @@ package body Exp_Ch4 is\n                       Intval => Fixed_Low_Bound (J));\n                end if;\n \n-               Lo :=\n+               Lo := To_Intyp (\n                  Make_Attribute_Reference (Loc,\n                    Prefix =>\n                      Duplicate_Subexpr (Operands (J), Name_Req => True),\n-                   Attribute_Name => Name_First);\n+                   Attribute_Name => Name_First));\n \n                if J = NN then\n                   return Lo;\n@@ -3107,15 +2691,15 @@ package body Exp_Ch4 is\n                 Defining_Identifier => Ent,\n                 Constant_Present    => True,\n                 Object_Definition   =>\n-                  New_Occurrence_Of (Standard_Natural, Loc),\n+                  New_Occurrence_Of (Intyp, Loc),\n                 Expression          => Get_Known_Bound (1)),\n               Suppress => All_Checks);\n \n             Low_Bound := New_Reference_To (Ent, Loc);\n          end;\n       end if;\n \n-      --  Now we build the result, which is a reference to the string entity\n+      --  Now we build the result, which is a reference to the array entity\n       --  we will construct with appropriate bounds.\n \n       Ent :=\n@@ -3128,20 +2712,21 @@ package body Exp_Ch4 is\n \n           Object_Definition   =>\n             Make_Subtype_Indication (Loc,\n-              Subtype_Mark => New_Occurrence_Of (Standard_String, Loc),\n+              Subtype_Mark => New_Occurrence_Of (Atyp, Loc),\n               Constraint   =>\n                 Make_Index_Or_Discriminant_Constraint (Loc,\n                   Constraints => New_List (\n                     Make_Range (Loc,\n-                      Low_Bound => New_Copy (Low_Bound),\n-                      High_Bound =>\n+                      Low_Bound => To_Ityp (New_Copy (Low_Bound)),\n+                      High_Bound => To_Ityp (\n                         Make_Op_Add (Loc,\n                           Left_Opnd  => New_Copy (Low_Bound),\n                           Right_Opnd =>\n                             Make_Op_Subtract (Loc,\n                               Left_Opnd  => New_Copy (Aggr_Length (NN)),\n                               Right_Opnd =>\n-                                Make_Integer_Literal (Loc, 1)))))))),\n+                                Make_Integer_Literal (Loc,\n+                                  Intval => Uint_1))))))))),\n \n         Suppress => All_Checks);\n \n@@ -3160,19 +2745,25 @@ package body Exp_Ch4 is\n                      Right_Opnd =>\n                        Make_Op_Subtract (Loc,\n                          Left_Opnd  => Aggr_Length (J),\n-                         Right_Opnd => Make_Integer_Literal (Loc, 1)));\n+                         Right_Opnd =>\n+                           Make_Integer_Literal (Loc,\n+                             Intval => 1)));\n \n          begin\n-            if Base_Type (Etype (Operands (J))) = Standard_Character then\n+            --  Singleton case, simple assignment\n+\n+            if Base_Type (Etype (Operands (J))) = Ctyp then\n                Insert_Action (Cnode,\n                  Make_Assignment_Statement (Loc,\n                    Name       =>\n                      Make_Indexed_Component (Loc,\n                        Prefix      => New_Occurrence_Of (Ent, Loc),\n-                       Expressions => New_List (Lo)),\n+                       Expressions => New_List (To_Ityp (Lo))),\n                    Expression => Operands (J)),\n                  Suppress => All_Checks);\n \n+            --  Array case, slice assignment\n+\n             else\n                Insert_Action (Cnode,\n                  Make_Assignment_Statement (Loc,\n@@ -3181,8 +2772,8 @@ package body Exp_Ch4 is\n                        Prefix         => New_Occurrence_Of (Ent, Loc),\n                        Discrete_Range =>\n                          Make_Range (Loc,\n-                           Low_Bound  => Lo,\n-                           High_Bound => Hi)),\n+                           Low_Bound  => To_Ityp (Lo),\n+                           High_Bound => To_Ityp (Hi))),\n                    Expression => Operands (J)),\n                  Suppress => All_Checks);\n             end if;\n@@ -3193,8 +2784,12 @@ package body Exp_Ch4 is\n \n    <<Done>>\n       Rewrite (Cnode, Result);\n-      Analyze_And_Resolve (Cnode, Standard_String);\n-   end Expand_Concatenate_String;\n+      Analyze_And_Resolve (Cnode, Atyp);\n+\n+   exception\n+      when Concatenation_Error =>\n+         Set_Etype (Cnode, Atyp);\n+   end Expand_Concatenate;\n \n    ------------------------\n    -- Expand_N_Allocator --\n@@ -4909,19 +4504,10 @@ package body Exp_Ch4 is\n       Opnds : List_Id;\n       --  List of operands to be concatenated\n \n-      Opnd  : Node_Id;\n-      --  Single operand for concatenation\n-\n       Cnode : Node_Id;\n       --  Node which is to be replaced by the result of concatenating the nodes\n       --  in the list Opnds.\n \n-      Atyp : Entity_Id;\n-      --  Array type of concatenation result type\n-\n-      Ctyp : Entity_Id;\n-      --  Component type of concatenation represented by Cnode\n-\n    begin\n       --  Ensure validity of both operands\n \n@@ -4968,36 +4554,7 @@ package body Exp_Ch4 is\n             Append (Right_Opnd (Cnode), Opnds);\n          end loop Inner;\n \n-         --  Here we process the collected operands. First convert singleton\n-         --  operands to singleton aggregates. This is skipped however for\n-         --  the case of operands of type Character/String since the string\n-         --  concatenation routine can handle these special cases.\n-\n-         Atyp := Base_Type (Etype (Cnode));\n-         Ctyp := Base_Type (Component_Type (Etype (Cnode)));\n-\n-         if Atyp /= Standard_String then\n-            Opnd := First (Opnds);\n-            loop\n-               if Base_Type (Etype (Opnd)) = Ctyp then\n-                  Rewrite (Opnd,\n-                    Make_Aggregate (Sloc (Cnode),\n-                      Expressions => New_List (Relocate_Node (Opnd))));\n-                  Analyze_And_Resolve (Opnd, Atyp);\n-               end if;\n-\n-               Next (Opnd);\n-               exit when No (Opnd);\n-            end loop;\n-         end if;\n-\n-         --  Now call appropriate continuation routine\n-\n-         if Atyp = Standard_String then\n-            Expand_Concatenate_String (Cnode, Opnds);\n-         else\n-            Expand_Concatenate_Other (Cnode, Opnds);\n-         end if;\n+         Expand_Concatenate (Cnode, Opnds);\n \n          exit Outer when Cnode = N;\n          Cnode := Parent (Cnode);"}, {"sha": "97fbb8198e0d4b6d516f75b1a92dbbe82f499f95", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdac1f80d600e1043558e7789e034188566f6f69/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdac1f80d600e1043558e7789e034188566f6f69/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=fdac1f80d600e1043558e7789e034188566f6f69", "patch": "@@ -5772,10 +5772,10 @@ package body Sem_Ch3 is\n \n    --  The representation clauses for T can specify a completely different\n    --  record layout from R's. Hence the same component can be placed in two\n-   --  very different positions in objects of type T and R. If R and are tagged\n-   --  types, representation clauses for T can only specify the layout of non\n-   --  inherited components, thus components that are common in R and T have\n-   --  the same position in objects of type R and T.\n+   --  very different positions in objects of type T and R. If R and T are\n+   --  tagged types, representation clauses for T can only specify the layout\n+   --  of non inherited components, thus components that are common in R and T\n+   --  have the same position in objects of type R and T.\n \n    --  This has two implications. The first is that the entire tree for R's\n    --  declaration needs to be copied for T in the untagged case, so that T\n@@ -6392,10 +6392,12 @@ package body Sem_Ch3 is\n               Type_Definition     =>\n                 Make_Derived_Type_Definition (Loc,\n                   Abstract_Present      => Abstract_Present (Type_Def),\n+                  Limited_Present       => Limited_Present (Type_Def),\n                   Subtype_Indication    =>\n                     New_Occurrence_Of (Parent_Base, Loc),\n                   Record_Extension_Part =>\n-                    Relocate_Node (Record_Extension_Part (Type_Def))));\n+                    Relocate_Node (Record_Extension_Part (Type_Def)),\n+                  Interface_List        => Interface_List (Type_Def)));\n \n          Set_Parent (New_Decl, Parent (N));\n          Mark_Rewrite_Insertion (New_Decl);\n@@ -6465,7 +6467,7 @@ package body Sem_Ch3 is\n          --  could still refer to the full type prior the change to the new\n          --  subtype and hence would not match the new base type created here.\n \n-         Derive_Subprograms (Parent_Type, Derived_Type);\n+         Derive_Subprograms (Parent_Type, Base_Type (Derived_Type));\n \n          --  For tagged types the Discriminant_Constraint of the new base itype\n          --  is inherited from the first subtype so that no subtype conformance"}]}