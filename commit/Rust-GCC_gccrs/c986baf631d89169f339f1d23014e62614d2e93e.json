{"sha": "c986baf631d89169f339f1d23014e62614d2e93e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk4NmJhZjYzMWQ4OTE2OWYzMzlmMWQyMzAxNGU2MjYxNGQyZTkzZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-11-18T19:30:34Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-11-18T19:30:34Z"}, "message": "calls.c (alloca_call_p): New global function.\n\n\t* calls.c (alloca_call_p): New global function.\n\t* tree.h (alloca_call_p): New.\n\t* tree-inline.c (inlinable_function_p):  Do not inline when\n\tfunction calls alloca.\n\t(find_alloca_call, find_alloca_call_1): New functions.\n\nFrom-SVN: r59228", "tree": {"sha": "b27ad2e3073c9b341aab81f1ef722dd6924c452c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b27ad2e3073c9b341aab81f1ef722dd6924c452c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c986baf631d89169f339f1d23014e62614d2e93e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c986baf631d89169f339f1d23014e62614d2e93e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c986baf631d89169f339f1d23014e62614d2e93e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c986baf631d89169f339f1d23014e62614d2e93e/comments", "author": null, "committer": null, "parents": [{"sha": "5602b49d692730366a6e554b52fefa604459d136", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5602b49d692730366a6e554b52fefa604459d136", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5602b49d692730366a6e554b52fefa604459d136"}], "stats": {"total": 54, "additions": 54, "deletions": 0}, "files": [{"sha": "9bfbfae6fa92c578d0a69ac45e191733f34b0b27", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c986baf631d89169f339f1d23014e62614d2e93e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c986baf631d89169f339f1d23014e62614d2e93e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c986baf631d89169f339f1d23014e62614d2e93e", "patch": "@@ -1,3 +1,11 @@\n+Sun Nov 17 00:01:28 CET 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* calls.c (alloca_call_p): New global function.\n+\t* tree.h (alloca_call_p): New.\n+\t* tree-inline.c (inlinable_function_p):  Do not inline when\n+\tfunction calls alloca.\n+\t(find_alloca_call, find_alloca_call_1): New functions.\n+\n 2002-11-18  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.md (*andorqi3): Use bor between bld and"}, {"sha": "99722b5da2e356a4a8461282f0ba084a7abe0af3", "filename": "gcc/calls.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c986baf631d89169f339f1d23014e62614d2e93e/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c986baf631d89169f339f1d23014e62614d2e93e/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=c986baf631d89169f339f1d23014e62614d2e93e", "patch": "@@ -801,6 +801,21 @@ setjmp_call_p (fndecl)\n   return special_function_p (fndecl, 0) & ECF_RETURNS_TWICE;\n }\n \n+/* Return true when exp contains alloca call.  */\n+bool\n+alloca_call_p (exp)\n+     tree exp;\n+{\n+  if (TREE_CODE (exp) == CALL_EXPR\n+      && TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n+      && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n+\t  == FUNCTION_DECL)\n+      && (special_function_p (TREE_OPERAND (TREE_OPERAND (exp, 0), 0),\n+\t\t\t      0) & ECF_MAY_BE_ALLOCA))\n+    return true;\n+  return false;\n+}\n+\n /* Detect flags (function attributes) from the function decl or type node.  */\n \n static int"}, {"sha": "73ba48ae51c3ce3d13a3700c35e99187ad8131ba", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c986baf631d89169f339f1d23014e62614d2e93e/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c986baf631d89169f339f1d23014e62614d2e93e/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=c986baf631d89169f339f1d23014e62614d2e93e", "patch": "@@ -122,6 +122,8 @@ static void copy_scope_stmt PARAMS ((tree *, int *, inline_data *));\n static tree initialize_inlined_parameters PARAMS ((inline_data *, tree, tree, tree));\n static void remap_block PARAMS ((tree *, tree, inline_data *));\n static tree add_stmt_to_compound PARAMS ((tree, tree, tree));\n+static tree find_alloca_call_1 PARAMS ((tree *, int *, void *));\n+static tree find_alloca_call PARAMS ((tree));\n #endif /* INLINER_FOR_JAVA */\n \n /* The approximate number of instructions per statement.  This number\n@@ -857,6 +859,27 @@ tree_inlinable_function_p (fn)\n   return inlinable_function_p (fn, NULL);\n }\n \n+/* if *TP is possibly call to alloca, return nonzero.  */\n+static tree\n+find_alloca_call_1 (tp, walk_subtrees, data)\n+     tree *tp;\n+     int *walk_subtrees ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  if (alloca_call_p (*tp))\n+    return *tp;\n+  return NULL;\n+}\n+\n+/* Return subexpression representing possible alloca call,\n+   if any.  */\n+static tree\n+find_alloca_call (exp)\n+     tree exp;\n+{\n+  return walk_tree (&exp, find_alloca_call_1, NULL, NULL);\n+}\n+\n /* Returns nonzero if FN is a function that can be inlined into the\n    inlining context ID_.  If ID_ is NULL, check whether the function\n    can be inlined at all.  */\n@@ -897,6 +920,13 @@ inlinable_function_p (fn, id)\n   else if (! (*lang_hooks.tree_inlining.disregard_inline_limits) (fn)\n \t   && currfn_insns > MAX_INLINE_INSNS_SINGLE)\n     ;\n+  /* Refuse to inline alloca call unless user explicitly forced so as this may\n+     change program's memory overhead drastically when the function using alloca\n+     is called in loop.  In GCC present in SPEC2000 inlining into schedule_block\n+     cause it to require 2GB of ram instead of 256MB.  */\n+  else if (lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)) == NULL\n+\t   && find_alloca_call (DECL_SAVED_TREE (fn)))\n+    ;\n   /* All is well.  We can inline this function.  Traditionally, GCC\n      has refused to inline functions using alloca, or functions whose\n      values are returned in a PARALLEL, and a few other such obscure"}, {"sha": "fc405173fac4b4b8bcad0bbf8b5162e9753c09db", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c986baf631d89169f339f1d23014e62614d2e93e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c986baf631d89169f339f1d23014e62614d2e93e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c986baf631d89169f339f1d23014e62614d2e93e", "patch": "@@ -3018,6 +3018,7 @@ extern rtx emit_line_note\t\tPARAMS ((const char *, int));\n /* In calls.c */\n \n extern int setjmp_call_p\t\tPARAMS ((tree));\n+extern bool alloca_call_p\t\tPARAMS ((tree));\n \n /* In attribs.c.  */\n "}]}