{"sha": "0eadc0917ab47b272102e3f337045c7fe8437a38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVhZGMwOTE3YWI0N2IyNzIxMDJlM2YzMzcwNDVjN2ZlODQzN2EzOA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2007-01-20T20:05:24Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2007-01-20T20:05:24Z"}, "message": "trans-intrinsic.c (gfc_conv_intrinsic_sign): New branchless implementation for the SIGN intrinsic with integral operands.\n\n\n\t* trans-intrinsic.c (gfc_conv_intrinsic_sign): New branchless\n\timplementation for the SIGN intrinsic with integral operands.\n\t(gfc_conv_intrinsic_minmax): Fix whitespace.\n\n\t* gfortran.dg/intrinsic_sign_1.f90: New test case.\n\t* gfortran.dg/intrinsic_sign_2.f90: Likewise.\n\n\nCo-Authored-By: Brooks Moses <brooks.moses@codesourcery.com>\nCo-Authored-By: Francois-Xavier Coudert <coudert@clipper.ens.fr>\n\nFrom-SVN: r121009", "tree": {"sha": "90d206fc8528acd0669bab17edc55d351ff105f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90d206fc8528acd0669bab17edc55d351ff105f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0eadc0917ab47b272102e3f337045c7fe8437a38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eadc0917ab47b272102e3f337045c7fe8437a38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0eadc0917ab47b272102e3f337045c7fe8437a38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eadc0917ab47b272102e3f337045c7fe8437a38/comments", "author": null, "committer": null, "parents": [{"sha": "ca6c6f643add73b49f45743974da5b80c5f74347", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca6c6f643add73b49f45743974da5b80c5f74347", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca6c6f643add73b49f45743974da5b80c5f74347"}], "stats": {"total": 134, "additions": 120, "deletions": 14}, "files": [{"sha": "0b738bac2dbd5fca1b00d8f0a6dfbe7e50620695", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eadc0917ab47b272102e3f337045c7fe8437a38/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eadc0917ab47b272102e3f337045c7fe8437a38/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0eadc0917ab47b272102e3f337045c7fe8437a38", "patch": "@@ -1,3 +1,9 @@\n+2007-01-20  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_sign): New branchless\n+\timplementation for the SIGN intrinsic with integral operands.\n+\t(gfc_conv_intrinsic_minmax): Fix whitespace.\n+\n 2007-01-20  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \t* gfortran.h (gfc_options_t): Add flag_allow_leading_underscore."}, {"sha": "6c321f1c60939d18caa8de275e8aea5ac4ab59e4", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eadc0917ab47b272102e3f337045c7fe8437a38/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eadc0917ab47b272102e3f337045c7fe8437a38/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=0eadc0917ab47b272102e3f337045c7fe8437a38", "patch": "@@ -1,5 +1,6 @@\n /* Intrinsic translation\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n    and Steven Bosscher <s.bosscher@student.tudelft.nl>\n \n@@ -1130,7 +1131,7 @@ gfc_conv_intrinsic_dim (gfc_se * se, gfc_expr * expr)\n /* SIGN(A, B) is absolute value of A times sign of B.\n    The real value versions use library functions to ensure the correct\n    handling of negative zero.  Integer case implemented as:\n-   SIGN(A, B) = ((a >= 0) .xor. (b >= 0)) ? a : -a\n+   SIGN(A, B) = { tmp = (A ^ B) >> C; (A + tmp) ^ tmp }\n   */\n \n static void\n@@ -1140,10 +1141,6 @@ gfc_conv_intrinsic_sign (gfc_se * se, gfc_expr * expr)\n   tree arg;\n   tree arg2;\n   tree type;\n-  tree zero;\n-  tree testa;\n-  tree testb;\n-\n \n   arg = gfc_conv_intrinsic_function_args (se, expr);\n   if (expr->ts.type == BT_REAL)\n@@ -1167,16 +1164,27 @@ gfc_conv_intrinsic_sign (gfc_se * se, gfc_expr * expr)\n       return;\n     }\n \n+  /* Having excluded floating point types, we know we are now dealing\n+     with signed integer types.  */\n   arg2 = TREE_VALUE (TREE_CHAIN (arg));\n   arg = TREE_VALUE (arg);\n   type = TREE_TYPE (arg);\n-  zero = gfc_build_const (type, integer_zero_node);\n \n-  testa = fold_build2 (GE_EXPR, boolean_type_node, arg, zero);\n-  testb = fold_build2 (GE_EXPR, boolean_type_node, arg2, zero);\n-  tmp = fold_build2 (TRUTH_XOR_EXPR, boolean_type_node, testa, testb);\n-  se->expr = fold_build3 (COND_EXPR, type, tmp,\n-\t\t\t  build1 (NEGATE_EXPR, type, arg), arg);\n+  /* Arg is used multiple times below.  */\n+  arg = gfc_evaluate_now (arg, &se->pre);\n+\n+  /* Construct (A ^ B) >> 31, which generates a bit mask of all zeros if\n+     the signs of A and B are the same, and of all ones if they differ.  */\n+  tmp = fold_build2 (BIT_XOR_EXPR, type, arg, arg2);\n+  tmp = fold_build2 (RSHIFT_EXPR, type, tmp,\n+\t\t     build_int_cst (type, TYPE_PRECISION (type) - 1));\n+  tmp = gfc_evaluate_now (tmp, &se->pre);\n+\n+  /* Construct (A + tmp) ^ tmp, which is A if tmp is zero, and -A if tmp]\n+     is all ones (i.e. -1).  */\n+  se->expr = fold_build2 (BIT_XOR_EXPR, type,\n+\t\t\t  fold_build2 (PLUS_EXPR, type, arg, tmp),\n+\t\t\t  tmp);\n }\n \n \n@@ -1385,7 +1393,7 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, int op)\n     limit = convert (type, limit);\n   /* Only evaluate the argument once.  */\n   if (TREE_CODE (limit) != VAR_DECL && !TREE_CONSTANT (limit))\n-    limit = gfc_evaluate_now(limit, &se->pre);\n+    limit = gfc_evaluate_now (limit, &se->pre);\n \n   mvar = gfc_create_var (type, \"M\");\n   elsecase = build2_v (MODIFY_EXPR, mvar, limit);\n@@ -1397,7 +1405,7 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, int op)\n \n       /* Only evaluate the argument once.  */\n       if (TREE_CODE (val) != VAR_DECL && !TREE_CONSTANT (val))\n-        val = gfc_evaluate_now(val, &se->pre);\n+        val = gfc_evaluate_now (val, &se->pre);\n \n       thencase = build2_v (MODIFY_EXPR, mvar, convert (type, val));\n "}, {"sha": "d1b2ddb6533701963afd6347f61ace0463bf14f8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eadc0917ab47b272102e3f337045c7fe8437a38/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eadc0917ab47b272102e3f337045c7fe8437a38/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0eadc0917ab47b272102e3f337045c7fe8437a38", "patch": "@@ -1,3 +1,10 @@\n+2007-01-20  Roger Sayle  <roger@eyesopen.com>\n+\t    Brooks Moses  <brooks.moses@codesourcery.com>\n+\t    Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\t* gfortran.dg/intrinsic_sign_1.f90: New test case.\n+\t* gfortran.dg/intrinsic_sign_2.f90: Likewise.\n+\n 2007-01-19  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.dg/torture/builtin-math-3.c: Test fdim."}, {"sha": "03addde78c402c429c7635c72b2b4d4bffc12d44", "filename": "gcc/testsuite/gfortran.dg/intrinsic_sign_1.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eadc0917ab47b272102e3f337045c7fe8437a38/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_sign_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eadc0917ab47b272102e3f337045c7fe8437a38/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_sign_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_sign_1.f90?ref=0eadc0917ab47b272102e3f337045c7fe8437a38", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! At one point, SIGN() evaluated its first argument twice.\n+! Contributed by Brooks Moses <brooks.moses@codesourcery.com>\n+program sign1\n+  integer :: i\n+  i = 1\n+  if (sign(foo(i), 1) /= 1) call abort\n+  i = 1\n+  if (sign(foo(i), -1) /= -1) call abort\n+contains\n+  integer function foo(i)\n+    integer :: i\n+    foo = i\n+    i = i + 1\n+  end function\n+end"}, {"sha": "0bc9b07b87c614b894b2331e0609cceac5bcc29b", "filename": "gcc/testsuite/gfortran.dg/intrinsic_sign_2.f90", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eadc0917ab47b272102e3f337045c7fe8437a38/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_sign_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eadc0917ab47b272102e3f337045c7fe8437a38/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_sign_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_sign_2.f90?ref=0eadc0917ab47b272102e3f337045c7fe8437a38", "patch": "@@ -0,0 +1,69 @@\n+! { dg-do run }\n+! Testcase for SIGN() with integer arguments\n+! Check that:\n+!   + SIGN() evaluates its arguments only once\n+!   + SIGN() works on large values\n+!   + SIGN() works with parameter arguments\n+! Contributed by FX Coudert <fxcoudert@gmail.com>\n+program sign1\n+  implicit none\n+  integer(kind=1), parameter :: one1 = 1_1, mone1 = -1_1\n+  integer(kind=2), parameter :: one2 = 1_2, mone2 = -1_2\n+  integer(kind=4), parameter :: one4 = 1_4, mone4 = -1_4\n+  integer(kind=8), parameter :: one8 = 1_8, mone8 = -1_8\n+  integer(kind=1) :: i1, j1\n+  integer(kind=2) :: i2, j2\n+  integer(kind=4) :: i4, j4\n+  integer(kind=8) :: i8, j8\n+  integer :: i = 1\n+\n+  i1 = huge(0_1) ; j1 = -huge(0_1)\n+  if (sign(i1, j1) /= j1) call abort()\n+  if (sign(j1, i1) /= i1) call abort()\n+  if (sign(i1,one1) /= i1 .or. sign(j1,one1) /= i1) call abort()\n+  if (sign(i1,mone1) /= j1 .or. sign(j1,mone1) /= j1) call abort()\n+\n+  i2 = huge(0_2) ; j2 = -huge(0_2)\n+  if (sign(i2, j2) /= j2) call abort()\n+  if (sign(j2, i2) /= i2) call abort()\n+  if (sign(i2,one2) /= i2 .or. sign(j2,one2) /= i2) call abort()\n+  if (sign(i2,mone2) /= j2 .or. sign(j2,mone2) /= j2) call abort()\n+\n+  i4 = huge(0_4) ; j4 = -huge(0_4)\n+  if (sign(i4, j4) /= j4) call abort()\n+  if (sign(j4, i4) /= i4) call abort()\n+  if (sign(i4,one4) /= i4 .or. sign(j4,one4) /= i4) call abort()\n+  if (sign(i4,mone4) /= j4 .or. sign(j4,mone4) /= j4) call abort()\n+\n+  i8 = huge(0_8) ; j8 = -huge(0_8)\n+  if (sign(i8, j8) /= j8) call abort()\n+  if (sign(j8, i8) /= i8) call abort()\n+  if (sign(i8,one8) /= i8 .or. sign(j8,one8) /= i8) call abort()\n+  if (sign(i8,mone8) /= j8 .or. sign(j8,mone8) /= j8) call abort()\n+\n+  if (sign(foo(i), 1) /= 1) call abort\n+  if (sign(foo(i), -1) /= -2) call abort\n+  if (sign(42, foo(i)) /= 42) call abort\n+  if (sign(42, -foo(i)) /= -42) call abort\n+  if (i /= 5) call abort\n+\n+  if (sign(bar(), 1) /= 1) call abort\n+  if (sign(bar(), -1) /= -2) call abort\n+  if (sign(17, bar()) /= 17) call abort\n+  if (sign(17, -bar()) /= -17) call abort\n+  if (bar() /= 5) call abort\n+\n+contains\n+\n+  integer function foo(i)\n+    integer :: i\n+    foo = i\n+    i = i + 1\n+  end function\n+\n+  integer function bar()\n+    integer, save :: i = 0\n+    i = i + 1\n+    bar = i\n+  end function\n+end"}]}