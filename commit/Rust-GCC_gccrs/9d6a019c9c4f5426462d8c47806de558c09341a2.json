{"sha": "9d6a019c9c4f5426462d8c47806de558c09341a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ2YTAxOWM5YzRmNTQyNjQ2MmQ4YzQ3ODA2ZGU1NThjMDkzNDFhMg==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-06-03T20:46:04Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-06-03T20:46:04Z"}, "message": "class.c (struct vtbl_init_data_s): Remove last_init field.\n\n\t* class.c (struct vtbl_init_data_s): Remove last_init field.\n\t(struct secondary_vptr_vtt_init_data_s): Change type of inits field\n\tto a VEC.\n\t(finish_vtbls): Use a VEC rather than a TREE_LIST for the accumulated\n\tinitializers.\n\t(build_vtt): Likewise.\n\t(initialize_vtable): Take a VEC instead of a tree.\n\t(build_vtt_inits): Change return type to void.  Take a VEC **\n\tinstead of a tree *; accumulate results into said VEC.\n\t(build_ctor_vtbl_group): Use a VEC rather than a TREE_LIST for the\n\taccumulated initializers.  Pass the vtable to accumulate_vtbl_inits.\n\t(accumulate_vtbl_inits): Add extra vtable tree parameter; take a VEC\n\tinstead of a tree.\n\t(dfs_accumulate_vtbl_inits): Likewise.  Change return type to void.\n\t(build_vtbl_initializer): Add VEC parameter; accumulate initializers\n\tinto it.\n\t(dfs_build_secondary_vptr_vtt_inits): Use CONSTRUCTOR_APPEND_ELT\n\trather than tree_cons.\n\t(build_vbase_offset_vtbl_entries): Likewise.\n\t(add_vcall_offset): Likewise.\n\t(build_rtti_vtbl_entries): Likewise.\n\t* cp-tree.h (initialize_artificial_var): Take a VEC instead of a tree.\n\t* decl.c (initialize_artificial_var): Use build_constructor instead\n\tof build_constructor_from_list.\n\nFrom-SVN: r160233", "tree": {"sha": "09b9d1ee22c81f28e2b2d5f91625cfa97a976951", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09b9d1ee22c81f28e2b2d5f91625cfa97a976951"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d6a019c9c4f5426462d8c47806de558c09341a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d6a019c9c4f5426462d8c47806de558c09341a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d6a019c9c4f5426462d8c47806de558c09341a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d6a019c9c4f5426462d8c47806de558c09341a2/comments", "author": null, "committer": null, "parents": [{"sha": "8eee0b8f763aaae1c2c5a9c56b8d7657249be1a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8eee0b8f763aaae1c2c5a9c56b8d7657249be1a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8eee0b8f763aaae1c2c5a9c56b8d7657249be1a1"}], "stats": {"total": 262, "additions": 141, "deletions": 121}, "files": [{"sha": "b2f6cd1de99d04bf625ab2c39a8600bc89cd95b3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a019c9c4f5426462d8c47806de558c09341a2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a019c9c4f5426462d8c47806de558c09341a2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9d6a019c9c4f5426462d8c47806de558c09341a2", "patch": "@@ -1,3 +1,30 @@\n+2010-06-03  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* class.c (struct vtbl_init_data_s): Remove last_init field.\n+\t(struct secondary_vptr_vtt_init_data_s): Change type of inits field\n+\tto a VEC.\n+\t(finish_vtbls): Use a VEC rather than a TREE_LIST for the accumulated\n+\tinitializers.\n+\t(build_vtt): Likewise.\n+\t(initialize_vtable): Take a VEC instead of a tree.\n+\t(build_vtt_inits): Change return type to void.  Take a VEC **\n+\tinstead of a tree *; accumulate results into said VEC.\n+\t(build_ctor_vtbl_group): Use a VEC rather than a TREE_LIST for the\n+\taccumulated initializers.  Pass the vtable to accumulate_vtbl_inits.\n+\t(accumulate_vtbl_inits): Add extra vtable tree parameter; take a VEC\n+\tinstead of a tree.\n+\t(dfs_accumulate_vtbl_inits): Likewise.  Change return type to void.\n+\t(build_vtbl_initializer): Add VEC parameter; accumulate initializers\n+\tinto it.\n+\t(dfs_build_secondary_vptr_vtt_inits): Use CONSTRUCTOR_APPEND_ELT\n+\trather than tree_cons.\n+\t(build_vbase_offset_vtbl_entries): Likewise.\n+\t(add_vcall_offset): Likewise.\n+\t(build_rtti_vtbl_entries): Likewise.\n+\t* cp-tree.h (initialize_artificial_var): Take a VEC instead of a tree.\n+\t* decl.c (initialize_artificial_var): Use build_constructor instead\n+\tof build_constructor_from_list.\n+\n 2010-06-03  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR c++/44294"}, {"sha": "2ee779299fe3382882480bbeb439ca7542b20bcd", "filename": "gcc/cp/class.c", "status": "modified", "additions": 109, "deletions": 115, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a019c9c4f5426462d8c47806de558c09341a2/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a019c9c4f5426462d8c47806de558c09341a2/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9d6a019c9c4f5426462d8c47806de558c09341a2", "patch": "@@ -77,9 +77,7 @@ typedef struct vtbl_init_data_s\n   tree rtti_binfo;\n   /* The negative-index vtable initializers built up so far.  These\n      are in order from least negative index to most negative index.  */\n-  tree inits;\n-  /* The last (i.e., most negative) entry in INITS.  */\n-  tree* last_init;\n+  VEC(constructor_elt,gc) *inits;\n   /* The binfo for the virtual base for which we're building\n      vcall offset initializers.  */\n   tree vbase;\n@@ -136,7 +134,8 @@ static void add_implicitly_declared_members (tree, int, int);\n static tree fixed_type_or_null (tree, int *, int *);\n static tree build_simple_base_path (tree expr, tree binfo);\n static tree build_vtbl_ref_1 (tree, tree);\n-static tree build_vtbl_initializer (tree, tree, tree, tree, int *);\n+static void build_vtbl_initializer (tree, tree, tree, tree, int *,\n+\t\t\t\t    VEC(constructor_elt,gc) **);\n static int count_fields (tree);\n static int add_fields_to_record_type (tree, struct sorted_fields_type*, int);\n static bool check_bitfield_decl (tree);\n@@ -173,14 +172,15 @@ static void dump_vtable (tree, tree, tree);\n static void dump_vtt (tree, tree);\n static void dump_thunk (FILE *, int, tree);\n static tree build_vtable (tree, tree, tree);\n-static void initialize_vtable (tree, tree);\n+static void initialize_vtable (tree, VEC(constructor_elt,gc) *);\n static void layout_nonempty_base_or_field (record_layout_info,\n \t\t\t\t\t   tree, tree, splay_tree);\n static tree end_of_class (tree, int);\n static bool layout_empty_base (record_layout_info, tree, tree, splay_tree);\n-static void accumulate_vtbl_inits (tree, tree, tree, tree, tree);\n-static tree dfs_accumulate_vtbl_inits (tree, tree, tree, tree,\n-\t\t\t\t\t       tree);\n+static void accumulate_vtbl_inits (tree, tree, tree, tree, tree,\n+\t\t\t\t   VEC(constructor_elt,gc) **);\n+static void dfs_accumulate_vtbl_inits (tree, tree, tree, tree, tree,\n+\t\t\t\t       VEC(constructor_elt,gc) **);\n static void build_rtti_vtbl_entries (tree, vtbl_init_data *);\n static void build_vcall_and_vbase_vtbl_entries (tree, vtbl_init_data *);\n static void clone_constructors_and_destructors (tree);\n@@ -189,7 +189,7 @@ static void update_vtable_entry_for_fn (tree, tree, tree, tree *, unsigned);\n static void build_ctor_vtbl_group (tree, tree);\n static void build_vtt (tree);\n static tree binfo_ctor_vtable (tree);\n-static tree *build_vtt_inits (tree, tree, tree *, tree *);\n+static void build_vtt_inits (tree, tree, VEC(constructor_elt,gc) **, tree *);\n static tree dfs_build_secondary_vptr_vtt_inits (tree, void *);\n static tree dfs_fixup_binfo_vtbls (tree, void *);\n static int record_subobject_offset (tree, tree, splay_tree);\n@@ -7042,36 +7042,36 @@ debug_thunks (tree fn)\n static void\n finish_vtbls (tree t)\n {\n-  tree list;\n   tree vbase;\n+  VEC(constructor_elt,gc) *v = NULL;\n+  tree vtable = BINFO_VTABLE (TYPE_BINFO (t));\n \n   /* We lay out the primary and secondary vtables in one contiguous\n      vtable.  The primary vtable is first, followed by the non-virtual\n      secondary vtables in inheritance graph order.  */\n-  list = build_tree_list (BINFO_VTABLE (TYPE_BINFO (t)), NULL_TREE);\n-  accumulate_vtbl_inits (TYPE_BINFO (t), TYPE_BINFO (t),\n-\t\t\t TYPE_BINFO (t), t, list);\n+  accumulate_vtbl_inits (TYPE_BINFO (t), TYPE_BINFO (t), TYPE_BINFO (t),\n+\t\t\t vtable, t, &v);\n \n   /* Then come the virtual bases, also in inheritance graph order.  */\n   for (vbase = TYPE_BINFO (t); vbase; vbase = TREE_CHAIN (vbase))\n     {\n       if (!BINFO_VIRTUAL_P (vbase))\n \tcontinue;\n-      accumulate_vtbl_inits (vbase, vbase, TYPE_BINFO (t), t, list);\n+      accumulate_vtbl_inits (vbase, vbase, TYPE_BINFO (t), vtable, t, &v);\n     }\n \n   if (BINFO_VTABLE (TYPE_BINFO (t)))\n-    initialize_vtable (TYPE_BINFO (t), TREE_VALUE (list));\n+    initialize_vtable (TYPE_BINFO (t), v);\n }\n \n /* Initialize the vtable for BINFO with the INITS.  */\n \n static void\n-initialize_vtable (tree binfo, tree inits)\n+initialize_vtable (tree binfo, VEC(constructor_elt,gc) *inits)\n {\n   tree decl;\n \n-  layout_vtable_decl (binfo, list_length (inits));\n+  layout_vtable_decl (binfo, VEC_length (constructor_elt, inits));\n   decl = get_vtbl_decl_for_binfo (binfo);\n   initialize_artificial_var (decl, inits);\n   dump_vtable (BINFO_TYPE (binfo), binfo, decl);\n@@ -7093,13 +7093,13 @@ initialize_vtable (tree binfo, tree inits)\n static void\n build_vtt (tree t)\n {\n-  tree inits;\n   tree type;\n   tree vtt;\n   tree index;\n+  VEC(constructor_elt,gc) *inits;\n \n   /* Build up the initializers for the VTT.  */\n-  inits = NULL_TREE;\n+  inits = NULL;\n   index = size_zero_node;\n   build_vtt_inits (TYPE_BINFO (t), t, &inits, &index);\n \n@@ -7108,7 +7108,7 @@ build_vtt (tree t)\n     return;\n \n   /* Figure out the type of the VTT.  */\n-  type = build_index_type (size_int (list_length (inits) - 1));\n+  type = build_index_type (size_int (VEC_length (constructor_elt, inits) - 1));\n   type = build_cplus_array_type (const_ptr_type_node, type);\n \n   /* Now, build the VTT object itself.  */\n@@ -7154,8 +7154,8 @@ typedef struct secondary_vptr_vtt_init_data_s\n   /* Current index into the VTT.  */\n   tree index;\n \n-  /* TREE_LIST of initializers built up.  */\n-  tree inits;\n+  /* Vector of initializers built up.  */\n+  VEC(constructor_elt,gc) *inits;\n \n   /* The type being constructed by this secondary VTT.  */\n   tree type_being_constructed;\n@@ -7169,19 +7169,18 @@ typedef struct secondary_vptr_vtt_init_data_s\n    for virtual bases of T. When it is not so, we build the constructor\n    vtables for the BINFO-in-T variant.  */\n \n-static tree *\n-build_vtt_inits (tree binfo, tree t, tree *inits, tree *index)\n+static void\n+build_vtt_inits (tree binfo, tree t, VEC(constructor_elt,gc) **inits, tree *index)\n {\n   int i;\n   tree b;\n   tree init;\n-  tree secondary_vptrs;\n   secondary_vptr_vtt_init_data data;\n   int top_level_p = SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), t);\n \n   /* We only need VTTs for subobjects with virtual bases.  */\n   if (!CLASSTYPE_VBASECLASSES (BINFO_TYPE (binfo)))\n-    return inits;\n+    return;\n \n   /* We need to use a construction vtable if this is not the primary\n      VTT.  */\n@@ -7195,8 +7194,7 @@ build_vtt_inits (tree binfo, tree t, tree *inits, tree *index)\n \n   /* Add the address of the primary vtable for the complete object.  */\n   init = binfo_ctor_vtable (binfo);\n-  *inits = build_tree_list (NULL_TREE, init);\n-  inits = &TREE_CHAIN (*inits);\n+  CONSTRUCTOR_APPEND_ELT (*inits, NULL_TREE, init);\n   if (top_level_p)\n     {\n       gcc_assert (!BINFO_VPTR_INDEX (binfo));\n@@ -7207,30 +7205,23 @@ build_vtt_inits (tree binfo, tree t, tree *inits, tree *index)\n   /* Recursively add the secondary VTTs for non-virtual bases.  */\n   for (i = 0; BINFO_BASE_ITERATE (binfo, i, b); ++i)\n     if (!BINFO_VIRTUAL_P (b))\n-      inits = build_vtt_inits (b, t, inits, index);\n+      build_vtt_inits (b, t, inits, index);\n \n   /* Add secondary virtual pointers for all subobjects of BINFO with\n      either virtual bases or reachable along a virtual path, except\n      subobjects that are non-virtual primary bases.  */\n   data.top_level_p = top_level_p;\n   data.index = *index;\n-  data.inits = NULL;\n+  data.inits = *inits;\n   data.type_being_constructed = BINFO_TYPE (binfo);\n \n   dfs_walk_once (binfo, dfs_build_secondary_vptr_vtt_inits, NULL, &data);\n \n   *index = data.index;\n \n-  /* The secondary vptrs come back in reverse order.  After we reverse\n-     them, and add the INITS, the last init will be the first element\n-     of the chain.  */\n-  secondary_vptrs = data.inits;\n-  if (secondary_vptrs)\n-    {\n-      *inits = nreverse (secondary_vptrs);\n-      inits = &TREE_CHAIN (secondary_vptrs);\n-      gcc_assert (*inits == NULL_TREE);\n-    }\n+  /* data.inits might have grown as we added secondary virtual pointers.\n+     Make sure our caller knows about the new vector.  */\n+  *inits = data.inits;\n \n   if (top_level_p)\n     /* Add the secondary VTTs for virtual bases in inheritance graph\n@@ -7240,13 +7231,11 @@ build_vtt_inits (tree binfo, tree t, tree *inits, tree *index)\n \tif (!BINFO_VIRTUAL_P (b))\n \t  continue;\n \n-\tinits = build_vtt_inits (b, t, inits, index);\n+\tbuild_vtt_inits (b, t, inits, index);\n       }\n   else\n     /* Remove the ctor vtables we created.  */\n     dfs_walk_all (binfo, dfs_fixup_binfo_vtbls, NULL, binfo);\n-\n-  return inits;\n }\n \n /* Called from build_vtt_inits via dfs_walk.  BINFO is the binfo for the base\n@@ -7294,7 +7283,7 @@ dfs_build_secondary_vptr_vtt_inits (tree binfo, void *data_)\n     }\n \n   /* Add the initializer for the secondary vptr itself.  */\n-  data->inits = tree_cons (NULL_TREE, binfo_ctor_vtable (binfo), data->inits);\n+  CONSTRUCTOR_APPEND_ELT (data->inits, NULL_TREE, binfo_ctor_vtable (binfo));\n \n   /* Advance the vtt index.  */\n   data->index = size_binop (PLUS_EXPR, data->index,\n@@ -7337,12 +7326,11 @@ dfs_fixup_binfo_vtbls (tree binfo, void* data)\n static void\n build_ctor_vtbl_group (tree binfo, tree t)\n {\n-  tree list;\n   tree type;\n   tree vtbl;\n-  tree inits;\n   tree id;\n   tree vbase;\n+  VEC(constructor_elt,gc) *v;\n \n   /* See if we've already created this construction vtable group.  */\n   id = mangle_ctor_vtbl_for_type (t, binfo);\n@@ -7355,9 +7343,10 @@ build_ctor_vtbl_group (tree binfo, tree t)\n      construction vtable group.  */\n   vtbl = build_vtable (t, id, ptr_type_node);\n   DECL_CONSTRUCTION_VTABLE_P (vtbl) = 1;\n-  list = build_tree_list (vtbl, NULL_TREE);\n+\n+  v = NULL;\n   accumulate_vtbl_inits (binfo, TYPE_BINFO (TREE_TYPE (binfo)),\n-\t\t\t binfo, t, list);\n+\t\t\t binfo, vtbl, t, &v);\n \n   /* Add the vtables for each of our virtual bases using the vbase in T\n      binfo.  */\n@@ -7371,12 +7360,11 @@ build_ctor_vtbl_group (tree binfo, tree t)\n \tcontinue;\n       b = copied_binfo (vbase, binfo);\n \n-      accumulate_vtbl_inits (b, vbase, binfo, t, list);\n+      accumulate_vtbl_inits (b, vbase, binfo, vtbl, t, &v);\n     }\n-  inits = TREE_VALUE (list);\n \n   /* Figure out the type of the construction vtable.  */\n-  type = build_index_type (size_int (list_length (inits) - 1));\n+  type = build_index_type (size_int (VEC_length (constructor_elt, v) - 1));\n   type = build_cplus_array_type (vtable_entry_type, type);\n   layout_type (type);\n   TREE_TYPE (vtbl) = type;\n@@ -7385,7 +7373,7 @@ build_ctor_vtbl_group (tree binfo, tree t)\n \n   /* Initialize the construction vtable.  */\n   CLASSTYPE_VTABLES (t) = chainon (CLASSTYPE_VTABLES (t), vtbl);\n-  initialize_artificial_var (vtbl, inits);\n+  initialize_artificial_var (vtbl, v);\n   dump_vtable (t, binfo, vtbl);\n }\n \n@@ -7403,8 +7391,9 @@ static void\n accumulate_vtbl_inits (tree binfo,\n \t\t       tree orig_binfo,\n \t\t       tree rtti_binfo,\n+\t\t       tree vtbl,\n \t\t       tree t,\n-\t\t       tree inits)\n+\t\t       VEC(constructor_elt,gc) **inits)\n {\n   int i;\n   tree base_binfo;\n@@ -7424,10 +7413,7 @@ accumulate_vtbl_inits (tree binfo,\n     return;\n \n   /* Build the initializers for the BINFO-in-T vtable.  */\n-  TREE_VALUE (inits)\n-    = chainon (TREE_VALUE (inits),\n-\t       dfs_accumulate_vtbl_inits (binfo, orig_binfo,\n-\t\t\t\t\t  rtti_binfo, t, inits));\n+  dfs_accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, vtbl, t, inits);\n \n   /* Walk the BINFO and its bases.  We walk in preorder so that as we\n      initialize each vtable we can figure out at what offset the\n@@ -7441,24 +7427,25 @@ accumulate_vtbl_inits (tree binfo,\n \tcontinue;\n       accumulate_vtbl_inits (base_binfo,\n \t\t\t     BINFO_BASE_BINFO (orig_binfo, i),\n-\t\t\t     rtti_binfo, t,\n+\t\t\t     rtti_binfo, vtbl, t,\n \t\t\t     inits);\n     }\n }\n \n-/* Called from accumulate_vtbl_inits.  Returns the initializers for\n-   the BINFO vtable.  */\n+/* Called from accumulate_vtbl_inits.  Adds the initializers for the\n+   BINFO vtable to L.  */\n \n-static tree\n+static void\n dfs_accumulate_vtbl_inits (tree binfo,\n \t\t\t   tree orig_binfo,\n \t\t\t   tree rtti_binfo,\n+\t\t\t   tree orig_vtbl,\n \t\t\t   tree t,\n-\t\t\t   tree l)\n+\t\t\t   VEC(constructor_elt,gc) **l)\n {\n-  tree inits = NULL_TREE;\n   tree vtbl = NULL_TREE;\n   int ctor_vtbl_p = !SAME_BINFO_TYPE_P (BINFO_TYPE (rtti_binfo), t);\n+  int n_inits;\n \n   if (ctor_vtbl_p\n       && BINFO_VIRTUAL_P (orig_binfo) && BINFO_PRIMARY_P (orig_binfo))\n@@ -7512,23 +7499,24 @@ dfs_accumulate_vtbl_inits (tree binfo,\n       /* Otherwise, this is case 3 and we get our own.  */\n     }\n   else if (!BINFO_NEW_VTABLE_MARKED (orig_binfo))\n-    return inits;\n+    return;\n+\n+  n_inits = VEC_length (constructor_elt, *l);\n \n   if (!vtbl)\n     {\n       tree index;\n       int non_fn_entries;\n \n-      /* Compute the initializer for this vtable.  */\n-      inits = build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo,\n-\t\t\t\t      &non_fn_entries);\n+      /* Add the initializer for this vtable.  */\n+      build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo,\n+                              &non_fn_entries, l);\n \n       /* Figure out the position to which the VPTR should point.  */\n-      vtbl = TREE_PURPOSE (l);\n-      vtbl = build1 (ADDR_EXPR, vtbl_ptr_type_node, vtbl);\n+      vtbl = build1 (ADDR_EXPR, vtbl_ptr_type_node, orig_vtbl);\n       index = size_binop (PLUS_EXPR,\n \t\t\t  size_int (non_fn_entries),\n-\t\t\t  size_int (list_length (TREE_VALUE (l))));\n+\t\t\t  size_int (n_inits));\n       index = size_binop (MULT_EXPR,\n \t\t\t  TYPE_SIZE_UNIT (vtable_entry_type),\n \t\t\t  index);\n@@ -7541,12 +7529,11 @@ dfs_accumulate_vtbl_inits (tree binfo,\n        straighten this out.  */\n     BINFO_VTABLE (binfo) = tree_cons (rtti_binfo, vtbl, BINFO_VTABLE (binfo));\n   else if (BINFO_PRIMARY_P (binfo) && BINFO_VIRTUAL_P (binfo))\n-    inits = NULL_TREE;\n+    /* Throw away any unneeded intializers.  */\n+    VEC_truncate (constructor_elt, *l, n_inits);\n   else\n      /* For an ordinary vtable, set BINFO_VTABLE.  */\n     BINFO_VTABLE (binfo) = vtbl;\n-\n-  return inits;\n }\n \n static GTY(()) tree abort_fndecl_addr;\n@@ -7574,26 +7561,26 @@ static GTY(()) tree abort_fndecl_addr;\n    primary bases; we need these while the primary base is being\n    constructed.  */\n \n-static tree\n+static void\n build_vtbl_initializer (tree binfo,\n \t\t\ttree orig_binfo,\n \t\t\ttree t,\n \t\t\ttree rtti_binfo,\n-\t\t\tint* non_fn_entries_p)\n+\t\t\tint* non_fn_entries_p,\n+\t\t\tVEC(constructor_elt,gc) **inits)\n {\n   tree v, b;\n-  tree vfun_inits;\n   vtbl_init_data vid;\n-  unsigned ix;\n+  unsigned ix, jx;\n   tree vbinfo;\n   VEC(tree,gc) *vbases;\n+  constructor_elt *e;\n \n   /* Initialize VID.  */\n   memset (&vid, 0, sizeof (vid));\n   vid.binfo = binfo;\n   vid.derived = t;\n   vid.rtti_binfo = rtti_binfo;\n-  vid.last_init = &vid.inits;\n   vid.primary_vtbl_p = SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), t);\n   vid.ctor_vtbl_p = !SAME_BINFO_TYPE_P (BINFO_TYPE (rtti_binfo), t);\n   vid.generate_vcall_entries = true;\n@@ -7619,28 +7606,51 @@ build_vtbl_initializer (tree binfo,\n   /* If the target requires padding between data entries, add that now.  */\n   if (TARGET_VTABLE_DATA_ENTRY_DISTANCE > 1)\n     {\n-      tree cur, *prev;\n+      int n_entries = VEC_length (constructor_elt, vid.inits);\n+\n+      VEC_safe_grow (constructor_elt, gc, vid.inits,\n+\t\t     TARGET_VTABLE_DATA_ENTRY_DISTANCE * n_entries);\n \n-      for (prev = &vid.inits; (cur = *prev); prev = &TREE_CHAIN (cur))\n+      /* Move data entries into their new positions and add padding\n+\t after the new positions.  Iterate backwards so we don't\n+\t overwrite entries that we would need to process later.  */\n+      for (ix = n_entries - 1;\n+\t   VEC_iterate (constructor_elt, vid.inits, ix, e);\n+\t   ix--)\n \t{\n-\t  tree add = cur;\n-\t  int i;\n+\t  int j;\n+\t  int new_position = TARGET_VTABLE_DATA_ENTRY_DISTANCE * ix;\n+\n+\t  VEC_replace (constructor_elt, vid.inits, new_position, e);\n \n-\t  for (i = 1; i < TARGET_VTABLE_DATA_ENTRY_DISTANCE; ++i)\n-\t    add = tree_cons (NULL_TREE,\n-\t\t\t     build1 (NOP_EXPR, vtable_entry_type,\n-\t\t\t\t     null_pointer_node),\n-\t\t\t     add);\n-\t  *prev = add;\n+\t  for (j = 1; j < TARGET_VTABLE_DATA_ENTRY_DISTANCE; ++j)\n+\t    {\n+\t      constructor_elt *f = VEC_index (constructor_elt, *inits,\n+\t\t\t\t\t      new_position + j);\n+\t      f->index = NULL_TREE;\n+\t      f->value = build1 (NOP_EXPR, vtable_entry_type,\n+\t\t\t\t null_pointer_node);\n+\t    }\n \t}\n     }\n \n   if (non_fn_entries_p)\n-    *non_fn_entries_p = list_length (vid.inits);\n+    *non_fn_entries_p = VEC_length (constructor_elt, vid.inits);\n+\n+  /* The initializers for virtual functions were built up in reverse\n+     order.  Straighten them out and add them to the running list in one\n+     step.  */\n+  jx = VEC_length (constructor_elt, *inits);\n+  VEC_safe_grow (constructor_elt, gc, *inits,\n+\t\t (jx + VEC_length (constructor_elt, vid.inits)));\n+\n+  for (ix = VEC_length (constructor_elt, vid.inits) - 1;\n+       VEC_iterate (constructor_elt, vid.inits, ix, e);\n+       ix--, jx++)\n+    VEC_replace (constructor_elt, *inits, jx, e);\n \n   /* Go through all the ordinary virtual functions, building up\n      initializers.  */\n-  vfun_inits = NULL_TREE;\n   for (v = BINFO_VIRTUALS (orig_binfo); v; v = TREE_CHAIN (v))\n     {\n       tree delta;\n@@ -7726,7 +7736,7 @@ build_vtbl_initializer (tree binfo,\n \t  int i;\n \t  if (init == size_zero_node)\n \t    for (i = 0; i < TARGET_VTABLE_USES_DESCRIPTORS; ++i)\n-\t      vfun_inits = tree_cons (NULL_TREE, init, vfun_inits);\n+\t      CONSTRUCTOR_APPEND_ELT (*inits, NULL_TREE, init);\n \t  else\n \t    for (i = 0; i < TARGET_VTABLE_USES_DESCRIPTORS; ++i)\n \t      {\n@@ -7735,22 +7745,12 @@ build_vtbl_initializer (tree binfo,\n \t\t\t\t     build_int_cst (NULL_TREE, i));\n \t\tTREE_CONSTANT (fdesc) = 1;\n \n-\t\tvfun_inits = tree_cons (NULL_TREE, fdesc, vfun_inits);\n+\t\tCONSTRUCTOR_APPEND_ELT (*inits, NULL_TREE, fdesc);\n \t      }\n \t}\n       else\n-\tvfun_inits = tree_cons (NULL_TREE, init, vfun_inits);\n+\tCONSTRUCTOR_APPEND_ELT (*inits, NULL_TREE, init);\n     }\n-\n-  /* The initializers for virtual functions were built up in reverse\n-     order; straighten them out now.  */\n-  vfun_inits = nreverse (vfun_inits);\n-\n-  /* The negative offset initializers are also in reverse order.  */\n-  vid.inits = nreverse (vid.inits);\n-\n-  /* Chain the two together.  */\n-  return chainon (vid.inits, vfun_inits);\n }\n \n /* Adds to vid->inits the initializers for the vbase and vcall\n@@ -7860,12 +7860,9 @@ build_vbase_offset_vtbl_entries (tree binfo, vtbl_init_data* vid)\n       delta = size_diffop_loc (input_location,\n \t\t\t   BINFO_OFFSET (b), BINFO_OFFSET (non_primary_binfo));\n \n-      *vid->last_init\n-\t= build_tree_list (NULL_TREE,\n-\t\t\t   fold_build1_loc (input_location, NOP_EXPR,\n-\t\t\t\t\tvtable_entry_type,\n-\t\t\t\t\tdelta));\n-      vid->last_init = &TREE_CHAIN (*vid->last_init);\n+      CONSTRUCTOR_APPEND_ELT (vid->inits, NULL_TREE,\n+\t\t\t      fold_build1_loc (input_location, NOP_EXPR,\n+\t\t\t\t\t       vtable_entry_type, delta));\n     }\n }\n \n@@ -8100,8 +8097,7 @@ add_vcall_offset (tree orig_fn, tree binfo, vtbl_init_data *vid)\n \t\t\t\t      vcall_offset);\n \t}\n       /* Add the initializer to the vtable.  */\n-      *vid->last_init = build_tree_list (NULL_TREE, vcall_offset);\n-      vid->last_init = &TREE_CHAIN (*vid->last_init);\n+      CONSTRUCTOR_APPEND_ELT (vid->inits, NULL_TREE, vcall_offset);\n     }\n }\n \n@@ -8145,15 +8141,13 @@ build_rtti_vtbl_entries (tree binfo, vtbl_init_data* vid)\n   /* Convert the declaration to a type that can be stored in the\n      vtable.  */\n   init = build_nop (vfunc_ptr_type_node, decl);\n-  *vid->last_init = build_tree_list (NULL_TREE, init);\n-  vid->last_init = &TREE_CHAIN (*vid->last_init);\n+  CONSTRUCTOR_APPEND_ELT (vid->inits, NULL_TREE, init);\n \n   /* Add the offset-to-top entry.  It comes earlier in the vtable than\n      the typeinfo entry.  Convert the offset to look like a\n      function pointer, so that we can put it in the vtable.  */\n   init = build_nop (vfunc_ptr_type_node, offset);\n-  *vid->last_init = build_tree_list (NULL_TREE, init);\n-  vid->last_init = &TREE_CHAIN (*vid->last_init);\n+  CONSTRUCTOR_APPEND_ELT (vid->inits, NULL_TREE, init);\n }\n \n /* Fold a OBJ_TYPE_REF expression to the address of a function."}, {"sha": "89a3b7c3d964ebcfcabbd4939d8c1058347e01b8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a019c9c4f5426462d8c47806de558c09341a2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a019c9c4f5426462d8c47806de558c09341a2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9d6a019c9c4f5426462d8c47806de558c09341a2", "patch": "@@ -4743,7 +4743,7 @@ extern tree check_elaborated_type_specifier\t(enum tag_types, tree, bool);\n extern void warn_extern_redeclared_static\t(tree, tree);\n extern tree cxx_comdat_group\t\t\t(tree);\n extern bool cp_missing_noreturn_ok_p\t\t(tree);\n-extern void initialize_artificial_var\t\t(tree, tree);\n+extern void initialize_artificial_var\t\t(tree, VEC(constructor_elt,gc) *);\n extern tree check_var_type\t\t\t(tree, tree);\n extern tree reshape_init (tree, tree);\n extern tree next_initializable_field (tree);"}, {"sha": "390519618c1abcb9c1efeeaf4ebfddd061d3e3b3", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a019c9c4f5426462d8c47806de558c09341a2/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a019c9c4f5426462d8c47806de558c09341a2/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9d6a019c9c4f5426462d8c47806de558c09341a2", "patch": "@@ -5542,16 +5542,15 @@ initialize_local_var (tree decl, tree init)\n \n /* DECL is a VAR_DECL for a compiler-generated variable with static\n    storage duration (like a virtual table) whose initializer is a\n-   compile-time constant.  INIT must be either a TREE_LIST of values,\n-   or a CONSTRUCTOR.  Initialize the variable and provide it to the\n+   compile-time constant.  Initialize the variable and provide it to the\n    back end.  */\n \n void\n-initialize_artificial_var (tree decl, tree init)\n+initialize_artificial_var (tree decl, VEC(constructor_elt,gc) *v)\n {\n+  tree init;\n   gcc_assert (DECL_ARTIFICIAL (decl));\n-  if (TREE_CODE (init) == TREE_LIST)\n-    init = build_constructor_from_list (TREE_TYPE (decl), init);\n+  init = build_constructor (TREE_TYPE (decl), v);\n   gcc_assert (TREE_CODE (init) == CONSTRUCTOR);\n   DECL_INITIAL (decl) = init;\n   DECL_INITIALIZED_P (decl) = 1;"}]}