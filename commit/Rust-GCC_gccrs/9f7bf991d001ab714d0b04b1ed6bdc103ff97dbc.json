{"sha": "9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY3YmY5OTFkMDAxYWI3MTRkMGIwNGIxZWQ2YmRjMTAzZmY5N2RiYw==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2005-02-16T21:57:10Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2005-02-16T21:57:10Z"}, "message": "re PR target/19162 (ICE while building libobjc's sendmsg.c)\n\n\t* PR target/19162\n\t* arm.c (arm_apply_result_size): New function.\n\t* arm.h (APPLY_RESULT_SIZE): Define.\n\t* arm-protos.h (arm_apply_result_size): Add prototype.\n\t* arm.md (RO_REGNUM, FPA_F0_REGNUM, FPA_F7_REGNUM): New constants.\n\t(movxf): New expand.\n\t(ldmsi_postinc4_thumb, stmsi_postinc4_thumb): New patterns for Thumb.\n\t(call_value_symbol): Remove predicate for operand 0.\n\t(call_value_insn, sibcall_value, sibcall_value_insn): Likewise.\n\t(untyped_call): Rework to correclty return values for any type.\n\t(untyped_return): New expand.\n\t* fpa.md (movxf_fpa): Simplify and use sfm/lfm when appropriate.\n\nFrom-SVN: r95119", "tree": {"sha": "1e6918c3c499f243a354c79d10416cd754625864", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e6918c3c499f243a354c79d10416cd754625864"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc/comments", "author": null, "committer": null, "parents": [{"sha": "f0b81cbc9f1eca010fed269e210f776186629d6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0b81cbc9f1eca010fed269e210f776186629d6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0b81cbc9f1eca010fed269e210f776186629d6c"}], "stats": {"total": 239, "additions": 209, "deletions": 30}, "files": [{"sha": "379b422014ac3318e2e8de2d280502aa33769063", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc", "patch": "@@ -1,3 +1,18 @@\n+2005-02-16  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* PR target/19162\n+\t* arm.c (arm_apply_result_size): New function.\n+\t* arm.h (APPLY_RESULT_SIZE): Define.\n+\t* arm-protos.h (arm_apply_result_size): Add prototype.\n+\t* arm.md (RO_REGNUM, FPA_F0_REGNUM, FPA_F7_REGNUM): New constants.\n+\t(movxf): New expand.\n+\t(ldmsi_postinc4_thumb, stmsi_postinc4_thumb): New patterns for Thumb.\n+\t(call_value_symbol): Remove predicate for operand 0.\n+\t(call_value_insn, sibcall_value, sibcall_value_insn): Likewise.\n+\t(untyped_call): Rework to correclty return values for any type.\n+\t(untyped_return): New expand.\n+\t* fpa.md (movxf_fpa): Simplify and use sfm/lfm when appropriate.\n+\n 2005-02-16  Stan Shebs  <shebs@apple.com>\n \n \t* config.gcc (powerpc-*-darwin*): Use fragment for Darwin 8 or later."}, {"sha": "e7811ca8c8ef8ff44eef0f023da14c82a6f2d2eb", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc", "patch": "@@ -123,6 +123,7 @@ extern void arm_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);\n extern bool arm_needs_doubleword_align (enum machine_mode, tree);\n extern rtx arm_function_value(tree, tree);\n #endif\n+extern int arm_apply_result_size (void);\n \n #if defined AOF_ASSEMBLER\n extern rtx aof_pic_entry (rtx);"}, {"sha": "7c614fd53963c6c44df13a9d4c0f16dfde858408", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc", "patch": "@@ -2283,7 +2283,8 @@ arm_canonicalize_comparison (enum rtx_code code, rtx * op1)\n \n /* Define how to find the value returned by a function.  */\n \n-rtx arm_function_value(tree type, tree func ATTRIBUTE_UNUSED)\n+rtx\n+arm_function_value(tree type, tree func ATTRIBUTE_UNUSED)\n {\n   enum machine_mode mode;\n   int unsignedp ATTRIBUTE_UNUSED;\n@@ -2297,6 +2298,28 @@ rtx arm_function_value(tree type, tree func ATTRIBUTE_UNUSED)\n   return LIBCALL_VALUE(mode);\n }\n \n+/* Determine the amount of memory needed to store the possible return \n+   registers of an untyped call.  */\n+int\n+arm_apply_result_size (void)\n+{\n+  int size = 16;\n+\n+  if (TARGET_ARM)\n+    {\n+      if (TARGET_HARD_FLOAT_ABI)\n+\t{\n+\t  if (TARGET_FPA)\n+\t    size += 12;\n+\t  if (TARGET_MAVERICK)\n+\t    size += 8;\n+\t}\n+      if (TARGET_IWMMXT_ABI)\n+\tsize += 8;\n+    }\n+\n+  return size;\n+}\n \n /* Decide whether a type should be returned in memory (true)\n    or in a register (false).  This is called by the macro"}, {"sha": "2db95373c9fd7f894d6fe95ec3a36964a0eeab50", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc", "patch": "@@ -1617,6 +1617,10 @@ enum reg_class\n    || (TARGET_ARM && ((REGNO) == FIRST_FPA_REGNUM)\t\t\t\\\n        && TARGET_HARD_FLOAT_ABI && TARGET_FPA))\n \n+/* Amount of memory needed for an untyped call to save all possible return\n+   registers.  */\n+#define APPLY_RESULT_SIZE arm_apply_result_size()\n+\n /* How large values are returned */\n /* A C expression which can inhibit the returning of certain function values\n    in registers, based on the type of value.  */"}, {"sha": "f25846675eeed696dbf5e15d119ad15fde97124c", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 149, "deletions": 10, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc", "patch": "@@ -30,12 +30,15 @@\n \n ;; Register numbers\n (define_constants\n-  [(IP_REGNUM\t    12)\t\t; Scratch register\n+  [(R0_REGNUM        0)\t\t; First CORE register\n+   (IP_REGNUM\t    12)\t\t; Scratch register\n    (SP_REGNUM\t    13)\t\t; Stack pointer\n    (LR_REGNUM       14)\t\t; Return address register\n    (PC_REGNUM\t    15)\t\t; Program counter\n    (CC_REGNUM       24)\t\t; Condition code pseudo register\n-   (LAST_ARM_REGNUM 15)\n+   (LAST_ARM_REGNUM 15)\t\t;\n+   (FPA_F0_REGNUM   16)\t\t; FIRST_FPA_REGNUM\n+   (FPA_F7_REGNUM   23)\t\t; LAST_FPA_REGNUM\n   ]\n )\n ;; 3rd operand to select_dominance_cc_mode\n@@ -5216,6 +5219,16 @@\n    (set_attr \"pool_range\" \"*,*,*,1020,*,*\")]\n )\n \n+(define_expand \"movxf\"\n+  [(set (match_operand:XF 0 \"general_operand\" \"\")\n+\t(match_operand:XF 1 \"general_operand\" \"\"))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n+  \"\n+  if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (XFmode, operands[1]);\n+  \"\n+)\n+\n ;; Vector Moves\n (define_expand \"movv2si\"\n   [(set (match_operand:V2SI 0 \"nonimmediate_operand\" \"\")\n@@ -5288,6 +5301,24 @@\n    (set_attr \"predicable\" \"yes\")]\n )\n \n+(define_insn \"*ldmsi_postinc4_thumb\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 1 \"s_register_operand\" \"=l\")\n+\t  (plus:SI (match_operand:SI 2 \"s_register_operand\" \"1\")\n+\t\t   (const_int 16)))\n+     (set (match_operand:SI 3 \"arm_hard_register_operand\" \"\")\n+\t  (mem:SI (match_dup 2)))\n+     (set (match_operand:SI 4 \"arm_hard_register_operand\" \"\")\n+\t  (mem:SI (plus:SI (match_dup 2) (const_int 4))))\n+     (set (match_operand:SI 5 \"arm_hard_register_operand\" \"\")\n+\t  (mem:SI (plus:SI (match_dup 2) (const_int 8))))\n+     (set (match_operand:SI 6 \"arm_hard_register_operand\" \"\")\n+\t  (mem:SI (plus:SI (match_dup 2) (const_int 12))))])]\n+  \"TARGET_THUMB && XVECLEN (operands[0], 0) == 5\"\n+  \"ldmia\\\\t%1!, {%3, %4, %5, %6}\"\n+  [(set_attr \"type\" \"load4\")]\n+)\n+\n (define_insn \"*ldmsi_postinc3\"\n   [(match_parallel 0 \"load_multiple_operation\"\n     [(set (match_operand:SI 1 \"s_register_operand\" \"=r\")\n@@ -5409,6 +5440,24 @@\n    (set_attr \"type\" \"store4\")]\n )\n \n+(define_insn \"*stmsi_postinc4_thumb\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+    [(set (match_operand:SI 1 \"s_register_operand\" \"=l\")\n+\t  (plus:SI (match_operand:SI 2 \"s_register_operand\" \"1\")\n+\t\t   (const_int 16)))\n+     (set (mem:SI (match_dup 2))\n+\t  (match_operand:SI 3 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 2) (const_int 4)))\n+\t  (match_operand:SI 4 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 2) (const_int 8)))\n+\t  (match_operand:SI 5 \"arm_hard_register_operand\" \"\"))\n+     (set (mem:SI (plus:SI (match_dup 2) (const_int 12)))\n+\t  (match_operand:SI 6 \"arm_hard_register_operand\" \"\"))])]\n+  \"TARGET_THUMB && XVECLEN (operands[0], 0) == 5\"\n+  \"stmia\\\\t%1!, {%3, %4, %5, %6}\"\n+  [(set_attr \"type\" \"store4\")]\n+)\n+\n (define_insn \"*stmsi_postinc3\"\n   [(match_parallel 0 \"store_multiple_operation\"\n     [(set (match_operand:SI 1 \"s_register_operand\" \"=r\")\n@@ -7560,7 +7609,7 @@\n )\n \n (define_insn \"*call_value_symbol\"\n-  [(set (match_operand 0 \"s_register_operand\" \"\")\n+  [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand:SI 1 \"\" \"\"))\n \t(match_operand:SI 2 \"\" \"\")))\n    (use (match_operand 3 \"\" \"\"))\n@@ -7589,7 +7638,7 @@\n )\n \n (define_insn \"*call_value_insn\"\n-  [(set (match_operand 0 \"register_operand\" \"\")\n+  [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand 1 \"\" \"\"))\n \t      (match_operand 2 \"\" \"\")))\n    (use (match_operand 3 \"\" \"\"))\n@@ -7617,7 +7666,7 @@\n )\n \n (define_expand \"sibcall_value\"\n-  [(parallel [(set (match_operand 0 \"register_operand\" \"\")\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n \t\t   (call (match_operand 1 \"memory_operand\" \"\")\n \t\t\t (match_operand 2 \"general_operand\" \"\")))\n \t      (return)\n@@ -7643,7 +7692,7 @@\n )\n \n (define_insn \"*sibcall_value_insn\"\n- [(set (match_operand 0 \"s_register_operand\" \"\")\n+ [(set (match_operand 0 \"\" \"\")\n        (call (mem:SI (match_operand:SI 1 \"\" \"X\"))\n \t     (match_operand 2 \"\" \"\")))\n   (return)\n@@ -7749,18 +7798,59 @@\n \t\t    (const_int 0))\n \t      (match_operand 1 \"\" \"\")\n \t      (match_operand 2 \"\" \"\")])]\n-  \"TARGET_ARM\"\n+  \"TARGET_EITHER\"\n   \"\n   {\n     int i;\n+    rtx par = gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\trtvec_alloc (XVECLEN (operands[2], 0)));\n+    rtx addr = gen_reg_rtx (Pmode);\n+    rtx mem;\n+    int size = 0;\n \n-    emit_call_insn (GEN_CALL (operands[0], const0_rtx, NULL, const0_rtx));\n+    emit_move_insn (addr, XEXP (operands[1], 0));\n+    mem = change_address (operands[1], BLKmode, addr);\n \n     for (i = 0; i < XVECLEN (operands[2], 0); i++)\n       {\n-\trtx set = XVECEXP (operands[2], 0, i);\n+\trtx src = SET_SRC (XVECEXP (operands[2], 0, i));\n \n-\temit_move_insn (SET_DEST (set), SET_SRC (set));\n+\t/* Default code only uses r0 as a return value, but we could\n+\t   be using anything up to 4 registers.  */\n+\tif (REGNO (src) == R0_REGNUM)\n+\t  src = gen_rtx_REG (TImode, R0_REGNUM);\n+\n+        XVECEXP (par, 0, i) = gen_rtx_EXPR_LIST (VOIDmode, src,\n+\t\t\t\t\t\t GEN_INT (size));\n+        size += GET_MODE_SIZE (GET_MODE (src));\n+      }\n+\n+    emit_call_insn (GEN_CALL_VALUE (par, operands[0], const0_rtx, NULL,\n+\t\t\t\t    const0_rtx));\n+\n+    size = 0;\n+\n+    for (i = 0; i < XVECLEN (par, 0); i++)\n+      {\n+\tHOST_WIDE_INT offset = 0;\n+\trtx reg = XEXP (XVECEXP (par, 0, i), 0);\n+\n+\tif (size != 0)\n+\t  emit_move_insn (addr, plus_constant (addr, size));\n+\n+\tmem = change_address (mem, GET_MODE (reg), NULL);\n+\tif (REGNO (reg) == R0_REGNUM)\n+\t  {\n+\t    /* On thumb we have to use a write-back instruction.  */\n+\t    emit_insn (arm_gen_store_multiple (R0_REGNUM, 4, addr, TRUE,\n+\t\t\tTARGET_THUMB ? TRUE : FALSE, mem, &offset));\n+\t    size = TARGET_ARM ? 16 : 0;\n+\t  }\n+\telse\n+\t  {\n+\t    emit_move_insn (mem, reg);\n+\t    size = GET_MODE_SIZE (GET_MODE (reg));\n+\t  }\n       }\n \n     /* The optimizer does not know that the call sets the function value\n@@ -7773,6 +7863,55 @@\n   }\"\n )\n \n+(define_expand \"untyped_return\"\n+  [(match_operand:BLK 0 \"memory_operand\" \"\")\n+   (match_operand 1 \"\" \"\")]\n+  \"TARGET_EITHER\"\n+  \"\n+  {\n+    int i;\n+    rtx addr = gen_reg_rtx (Pmode);\n+    rtx mem;\n+    int size = 0;\n+\n+    emit_move_insn (addr, XEXP (operands[0], 0));\n+    mem = change_address (operands[0], BLKmode, addr);\n+\n+    for (i = 0; i < XVECLEN (operands[1], 0); i++)\n+      {\n+\tHOST_WIDE_INT offset = 0;\n+\trtx reg = SET_DEST (XVECEXP (operands[1], 0, i));\n+\n+\tif (size != 0)\n+\t  emit_move_insn (addr, plus_constant (addr, size));\n+\n+\tmem = change_address (mem, GET_MODE (reg), NULL);\n+\tif (REGNO (reg) == R0_REGNUM)\n+\t  {\n+\t    /* On thumb we have to use a write-back instruction.  */\n+\t    emit_insn (arm_gen_load_multiple (R0_REGNUM, 4, addr, TRUE,\n+\t\t\tTARGET_THUMB ? TRUE : FALSE, mem, &offset));\n+\t    size = TARGET_ARM ? 16 : 0;\n+\t  }\n+\telse\n+\t  {\n+\t    emit_move_insn (reg, mem);\n+\t    size = GET_MODE_SIZE (GET_MODE (reg));\n+\t  }\n+      }\n+\n+    /* Emit USE insns before the return.  */\n+    for (i = 0; i < XVECLEN (operands[1], 0); i++)\n+      emit_insn (gen_rtx_USE (VOIDmode,\n+\t\t\t      SET_DEST (XVECEXP (operands[1], 0, i))));\n+\n+    /* Construct the return.  */\n+    expand_naked_return ();\n+\n+    DONE;\n+  }\"\n+)\n+\n ;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n ;; all of memory.  This blocks insns from being moved across this point.\n "}, {"sha": "54e1319097d19652a262839779f1f942f7af3248", "filename": "gcc/config/arm/fpa.md", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc/gcc%2Fconfig%2Farm%2Ffpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc/gcc%2Fconfig%2Farm%2Ffpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ffpa.md?ref=9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc", "patch": "@@ -581,33 +581,31 @@\n    (set_attr \"neg_pool_range\" \"*,*,*,*,1008,*,*,1008,*,*,*\")]\n )\n \n-;; Saving and restoring the floating point registers in the prologue should\n-;; be done in XFmode, even though we don't support that for anything else\n-;; (Well, strictly it's 'internal representation', but that's effectively\n-;; XFmode).\n-\n+;; We treat XFmode as meaning 'internal format'.  It's the right size and we\n+;; don't use it for anything else.  We only support moving between FPA\n+;; registers and moving an FPA register to/from memory.\n (define_insn \"*movxf_fpa\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,f,f,m,f,r,r\")\n-\t(match_operand:XF 1 \"general_operand\" \"fG,H,m,f,r,f,r\"))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA && reload_completed\"\n+  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,f,m\")\n+\t(match_operand:XF 1 \"general_operand\" \"f,m,f\"))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\n+   && (register_operand (operands[0], XFmode)\n+       || register_operand (operands[1], XFmode))\"\n   \"*\n   switch (which_alternative)\n     {\n     default:\n     case 0: return \\\"mvf%?e\\\\t%0, %1\\\";\n-    case 1: return \\\"mnf%?e\\\\t%0, #%N1\\\";\n-    case 2: return \\\"ldf%?e\\\\t%0, %1\\\";\n-    case 3: return \\\"stf%?e\\\\t%1, %0\\\";\n-    case 4: return output_mov_long_double_fpa_from_arm (operands);\n-    case 5: return output_mov_long_double_arm_from_fpa (operands);\n-    case 6: return output_mov_long_double_arm_from_arm (operands);\n+    case 1: if (arm_fpu_arch == FPUTYPE_FPA_EMU2)\n+\t      return \\\"ldf%?e\\\\t%0, %1\\\";\n+\t    return \\\"lfm%?\\\\t%0, 1, %1\\\";\n+    case 2: if (arm_fpu_arch == FPUTYPE_FPA_EMU2)\n+\t      return \\\"stf%?e\\\\t%1, %0\\\";\n+\t    return \\\"sfm%?\\\\t%1, 1, %0\\\";\n     }\n   \"\n-  [(set_attr \"length\" \"4,4,4,4,8,8,12\")\n+  [(set_attr \"length\" \"4,4,4\")\n    (set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"ffarith,ffarith,f_load,f_store,r_mem_f,f_mem_r,*\")\n-   (set_attr \"pool_range\" \"*,*,1024,*,*,*,*\")\n-   (set_attr \"neg_pool_range\" \"*,*,1004,*,*,*,*\")]\n+   (set_attr \"type\" \"ffarith,f_load,f_store\")]\n )\n \n (define_insn \"*cmpsf_fpa\"\n@@ -749,4 +747,3 @@\n    (set_attr \"type\" \"ffarith\")\n    (set_attr \"conds\" \"use\")]\n )\n-"}]}