{"sha": "407f03b8d71c2869f66877df32c9395c8e4fde18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA3ZjAzYjhkNzFjMjg2OWY2Njg3N2RmMzJjOTM5NWM4ZTRmZGUxOA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-03-14T01:29:36Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-03-14T01:29:36Z"}, "message": "decl.c (duplicate_decls): Use same_type_p.\n\n\t* decl.c (duplicate_decls): Use same_type_p.\n\t* method.c (try_old_backref): Renamed from flush_repeats.  Use\n\tsame_type_p.  Don't try to handle repeats.  Return success.\n\t(is_back_referenceable_type): Return 0 if TYPE_FOR_JAVA.  Support\n\tcalls from old-style code, too.\n\t(check_ktype): Use same_type_p.\n\t(check_btype): Use same_type_p.  Don't pull out TYPE_MAIN_VARIANT.\n\t(build_qualified_name): Simplify logic.\n\t(build_mangled_name_for_type_with_Gcode): Remove call to\n\ttype_canonical_variant.\n\t(process_overload_item): Strip typedefs and quals at the top.\n\t(build_mangled_name): Likewise.  Remove support for old-style\n\trepeats, which have been disabled since 2.7.2.  Don't mess with\n\tTREE_USED.\n\t(build_decl_overload_real): Don't mess with TREE_USED.\n\nFrom-SVN: r25758", "tree": {"sha": "45e7638ad30668c4227f064885621d3e26c31758", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45e7638ad30668c4227f064885621d3e26c31758"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/407f03b8d71c2869f66877df32c9395c8e4fde18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/407f03b8d71c2869f66877df32c9395c8e4fde18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/407f03b8d71c2869f66877df32c9395c8e4fde18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/407f03b8d71c2869f66877df32c9395c8e4fde18/comments", "author": null, "committer": null, "parents": [{"sha": "54206178b9468daa7639803e124bf662f1bf0b70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54206178b9468daa7639803e124bf662f1bf0b70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54206178b9468daa7639803e124bf662f1bf0b70"}], "stats": {"total": 208, "additions": 97, "deletions": 111}, "files": [{"sha": "b988aec2519ad8c527cf03a4d2c8a3448c661d64", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/407f03b8d71c2869f66877df32c9395c8e4fde18/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/407f03b8d71c2869f66877df32c9395c8e4fde18/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=407f03b8d71c2869f66877df32c9395c8e4fde18", "patch": "@@ -1,3 +1,21 @@\n+1999-03-13  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (duplicate_decls): Use same_type_p.\n+\t* method.c (try_old_backref): Renamed from flush_repeats.  Use\n+\tsame_type_p.  Don't try to handle repeats.  Return success.\n+\t(is_back_referenceable_type): Return 0 if TYPE_FOR_JAVA.  Support\n+\tcalls from old-style code, too.\n+\t(check_ktype): Use same_type_p.\n+\t(check_btype): Use same_type_p.  Don't pull out TYPE_MAIN_VARIANT.\n+\t(build_qualified_name): Simplify logic.\n+\t(build_mangled_name_for_type_with_Gcode): Remove call to\n+\ttype_canonical_variant.\n+\t(process_overload_item): Strip typedefs and quals at the top.\n+\t(build_mangled_name): Likewise.  Remove support for old-style \n+\trepeats, which have been disabled since 2.7.2.  Don't mess with \n+\tTREE_USED.\n+\t(build_decl_overload_real): Don't mess with TREE_USED.\n+\n 1999-03-13  Nathan Sidwell  <nathan@acm.org>\n \n \t* error.c (cp_printers): Add 'F' escape character."}, {"sha": "2e7a94a725cc41e0f3ad020f1c6a42714d217994", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/407f03b8d71c2869f66877df32c9395c8e4fde18/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/407f03b8d71c2869f66877df32c9395c8e4fde18/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=407f03b8d71c2869f66877df32c9395c8e4fde18", "patch": "@@ -3242,7 +3242,7 @@ duplicate_decls (newdecl, olddecl)\n       TREE_TYPE (newdecl) = TREE_TYPE (olddecl) = newtype;\n \n       /* Lay the type out, unless already done.  */\n-      if (newtype != canonical_type_variant (oldtype)\n+      if (! same_type_p (newtype, oldtype)\n \t  && TREE_TYPE (newdecl) != error_mark_node\n \t  && !(processing_template_decl && uses_template_parms (newdecl)))\n \tlayout_type (TREE_TYPE (newdecl));"}, {"sha": "369dec62d6c5722cb8bcaeec3d765cfa50a0986d", "filename": "gcc/cp/method.c", "status": "modified", "additions": 78, "deletions": 110, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/407f03b8d71c2869f66877df32c9395c8e4fde18/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/407f03b8d71c2869f66877df32c9395c8e4fde18/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=407f03b8d71c2869f66877df32c9395c8e4fde18", "patch": "@@ -57,7 +57,7 @@ static char *scratch_firstobj;\n \n static void icat PROTO((HOST_WIDE_INT));\n static void dicat PROTO((HOST_WIDE_INT, HOST_WIDE_INT));\n-static void flush_repeats PROTO((int, tree));\n+static int try_old_backref PROTO((tree));\n static void build_overload_identifier PROTO((tree));\n static void build_overload_nested_name PROTO((tree));\n static void build_overload_int PROTO((tree, int));\n@@ -299,28 +299,33 @@ dicat (lo, hi)\n   OB_PUTC ('0' + ulo);\n }\n \n-static __inline void\n-flush_repeats (nrepeats, type)\n-     int nrepeats;\n+/* Old mangling style:  If TYPE has already been used in the parameter list,\n+   emit a backward reference and return non-zero; otherwise, return 0.  */\n+\n+static __inline int\n+try_old_backref (type)\n      tree type;\n {\n   int tindex = 0;\n \n-  while (typevec[tindex] != type)\n-    tindex++;\n+  if (! is_back_referenceable_type (type))\n+    return 0;\n \n-  if (nrepeats > 1)\n-    {\n-      OB_PUTC ('N');\n-      icat (nrepeats);\n-      if (nrepeats > 9)\n-\tOB_PUTC ('_');\n-    }\n-  else\n-    OB_PUTC ('T');\n+  /* The entry for this parm is at maxtype-1, so don't look there for\n+     something to repeat.  */\n+  for (tindex = 0; tindex < maxtype - 1; ++tindex)\n+    if (same_type_p (typevec[tindex], type))\n+      break;\n+\n+  if (tindex == maxtype - 1)\n+    return 0;\n+\n+  OB_PUTC ('T');\n   icat (tindex);\n   if (tindex > 9)\n     OB_PUTC ('_');\n+\n+  return 1;\n }\n \n /* Returns nonzero iff this is a type to which we will want to make\n@@ -330,8 +335,8 @@ static int\n is_back_referenceable_type (type)\n      tree type;\n {\n-  if (btypelist == NULL)\n-    /* We're not generating any back-references.  */\n+  /* For some reason, the Java folks don't want back refs on these.  */\n+  if (TYPE_FOR_JAVA (type))\n     return 0;\n \n   switch (TREE_CODE (type)) \n@@ -377,8 +382,10 @@ issue_nrepeats (nrepeats, type)\n     }\n }\n \n-/* Check to see if a tree node has been entered into the Kcode typelist    */\n-/* if not, add it. Return -1 if it isn't found, otherwise return the index */\n+/* Check to see if a tree node has been entered into the Kcode typelist.\n+   If not, add it.  Returns -1 if it isn't found, otherwise returns the\n+   index.  */\n+\n static int\n check_ktype (node, add)\n      tree node;\n@@ -395,10 +402,10 @@ check_ktype (node, add)\n \n   for (x=0; x < maxktype; x++)\n     {\n-      if (localnode == ktypelist[x])\n-        return x ;\n+      if (same_type_p (localnode, ktypelist[x]))\n+        return x;\n     }\n-  /* Didn't find it, so add it here */\n+  /* Didn't find it, so add it here.  */\n   if (add)\n     {\n       if (maxksize <= maxktype)\n@@ -864,7 +871,7 @@ build_overload_value (type, value, in_template)\n \n \n /* Add encodings for the declaration of template template parameters.\n-   PARMLIST must be a TREE_VEC */\n+   PARMLIST must be a TREE_VEC.  */\n \n static void\n build_template_template_parm_names (parmlist)\n@@ -921,17 +928,18 @@ build_template_parm_names (parmlist, arglist)\n \t}\n       else if (TREE_CODE (parm) == TEMPLATE_DECL)\n \t{\n-\t  /* This parameter is a template. */\n+\t  /* This parameter is a template.  */\n \t  if (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n-\t    /* Output parameter declaration, argument index and level */\n+\t    /* Output parameter declaration, argument index and level.  */\n \t    build_mangled_name_for_type (arg);\n \t  else\n \t    {\n \t      /* A TEMPLATE_DECL node, output the parameter declaration \n \t\t and template name */\n \n \t      OB_PUTC ('z');\n-\t      build_template_template_parm_names (DECL_INNERMOST_TEMPLATE_PARMS (parm));\n+\t      build_template_template_parm_names\n+\t\t(DECL_INNERMOST_TEMPLATE_PARMS (parm));\n \t      icat (IDENTIFIER_LENGTH (DECL_NAME (arg)));\n \t      OB_PUTID (DECL_NAME (arg));\n \t    }\n@@ -1012,15 +1020,18 @@ build_qualified_name (decl)\n     }\n \n   context = decl;\n-  /* if we can't find a Ktype, do it the hard way */\n+  /* If we can't find a Ktype, do it the hard way.  */\n   if (check_ktype (context, FALSE) == -1)\n     {\n-      /* count type and namespace scopes */\n-      while (DECL_CONTEXT (context) && DECL_CONTEXT (context) != global_namespace)\n+      /* Count type and namespace scopes.  */\n+      while (1)\n \t{\n+\t  context = CP_DECL_CONTEXT (context);\n+\t  if (context == global_namespace)\n+\t    break;\n \t  i += 1;\n-\t  context = DECL_CONTEXT (context);\n-\t  if (check_ktype (context, FALSE) != -1)  /* found it! */\n+\t  if (check_ktype (context, FALSE) != -1)\n+\t    /* Found one!  */\n \t    break;\n \t  if (TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n \t    context = TYPE_NAME (context);\n@@ -1047,7 +1058,6 @@ build_mangled_name_for_type_with_Gcode (type, extra_Gcode)\n {\n   if (TYPE_PTRMEMFUNC_P (type))\n     type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n-  type = canonical_type_variant (type);\n   process_modifiers (type);\n   process_overload_item (type, extra_Gcode);\n }\n@@ -1111,70 +1121,45 @@ build_mangled_name (parmtypes, begin, end)\n       for (; parmtypes && parmtypes != void_list_node;\n \t   parmtypes = TREE_CHAIN (parmtypes))\n \t{\n-\t  tree parmtype = canonical_type_variant (TREE_VALUE (parmtypes));\n+\t  /* We used to call canonical_type_variant here, but that isn't\n+\t     good enough; it doesn't handle pointers to typedef types.  So\n+\t     we can't just set TREE_USED to say we've seen a type already;\n+\t     we have to check each of the earlier types with same_type_p.  */\n+\t  tree parmtype = TREE_VALUE (parmtypes);\n \n \t  if (old_style_repeats)\n \t    {\n+\t      /* Note that for bug-compatibility with 2.7.2, we can't build\n+\t\t up repeats.  So we call try_old_backref (formerly\n+\t\t flush_repeats) every round, and only emit Tn codes.  */\n+\n \t      /* Every argument gets counted.  */\n \t      my_friendly_assert (maxtype < typevec_size, 387);\n \t      typevec[maxtype++] = parmtype;\n \t    }\n-\n-\t  if (parmtype == last_type)\n+\t  else if (flag_do_squangling)\n \t    {\n-\t      if (flag_do_squangling \n-\t\t  || (old_style_repeats && TREE_USED (parmtype)\n-\t\t      && !TYPE_FOR_JAVA (parmtype)))\n+\t      if (last_type && same_type_p (parmtype, last_type))\n \t\t{\n \t\t  /* The next type is the same as this one.  Keep\n \t\t     track of the repetition, and output the repeat\n \t\t     count later.  */\n \t\t  nrepeats++;\n \t\t  continue;\n \t\t}\n-\t    }\n-\t  else if (nrepeats != 0)\n-\t    {\n-\t      /* Indicate how many times the previous parameter was\n-\t\t repeated.  */\n-\t      if (old_style_repeats)\n-\t\tflush_repeats (nrepeats, last_type);\n-\t      else\n-\t\tissue_nrepeats (nrepeats, last_type);\n-\t      nrepeats = 0;\n-\t    }\n-\t  \n-\t  last_type = parmtype;\n-\n-\t  if (old_style_repeats)\n-\t    {\n-\t      if (nrepeats)\n-\t\t{\n-\t\t  flush_repeats (nrepeats, last_type);\n-\t\t  nrepeats = 0;\n-\t\t}\n-\n-\t      if (TREE_USED (parmtype))\n+\t      else if (nrepeats != 0)\n \t\t{\n-#if 0\n-\t\t  /* We can turn this on at some point when we want\n-\t\t     improved symbol mangling.  */\n-\t\t  nrepeats++;\n-#else\n-\t\t  /* This is bug compatible with 2.7.x  */\n-\t\t  flush_repeats (nrepeats, parmtype);\n-#endif\n+\t\t  /* Indicate how many times the previous parameter was\n+\t\t     repeated.  */\n+\t\t  issue_nrepeats (nrepeats, last_type);\n \t\t  nrepeats = 0;\n-\t\t  continue;\n \t\t}\n-\t      \n-\t      /* Only cache types which take more than one character.  */\n-\t      if ((parmtype != TYPE_MAIN_VARIANT (parmtype)\n-\t\t   || (TREE_CODE (parmtype) != INTEGER_TYPE\n-\t\t       && TREE_CODE (parmtype) != REAL_TYPE))\n-\t\t  && ! TYPE_FOR_JAVA (parmtype))\n-\t\tTREE_USED (parmtype) = 1;\n \t    }\n+\t  \n+\t  last_type = parmtype;\n+\n+\t  if (old_style_repeats && try_old_backref (parmtype))\n+\t    continue;\n \n \t  /* Output the PARMTYPE.  */\n \t  build_mangled_name_for_type_with_Gcode (parmtype, 1);\n@@ -1184,10 +1169,7 @@ build_mangled_name (parmtypes, begin, end)\n \t necessary.  */\n       if (nrepeats != 0)\n \t{\n-\t  if (old_style_repeats)\n-\t    flush_repeats (nrepeats, last_type);\n-\t  else\n-\t    issue_nrepeats (nrepeats, last_type);\n+\t  issue_nrepeats (nrepeats, last_type);\n \t  nrepeats = 0;\n \t}\n \n@@ -1243,12 +1225,8 @@ check_btype (type)\n   if (!is_back_referenceable_type (type))\n     return 0;\n \n-  /* We assume that our caller has put out any necessary\n-     qualifiers.  */\n-  type = TYPE_MAIN_VARIANT (type);\n-\n   for (x = 0; x < maxbtype; x++) \n-    if (type == btypelist[x]) \n+    if (same_type_p (type, btypelist[x]))\n       {\n \tOB_PUTC ('B');\n \ticat (x);\n@@ -1279,6 +1257,14 @@ process_overload_item (parmtype, extra_Gcode)\n {\n   numeric_output_need_bar = 0;\n \n+  /* Our caller should have already handed any qualifiers, so pull out the\n+     TYPE_MAIN_VARIANT to avoid typedef confusion.  Except we can't do that\n+     for arrays, because they are transparent to qualifiers.  Sigh.  */\n+  if (TREE_CODE (parmtype) == ARRAY_TYPE)\n+    parmtype = canonical_type_variant (parmtype);\n+  else\n+    parmtype = TYPE_MAIN_VARIANT (parmtype);\n+\n   /* These tree types are considered modifiers for B code squangling,\n      and therefore should not get entries in the Btypelist.  They are,\n      however, repeatable types.  */\n@@ -1382,7 +1368,6 @@ process_overload_item (parmtype, extra_Gcode)\n       }\n \n     case INTEGER_TYPE:\n-      parmtype = TYPE_MAIN_VARIANT (parmtype);\n       if (parmtype == integer_type_node\n           || parmtype == unsigned_type_node\n \t  || parmtype == java_int_type_node)\n@@ -1431,7 +1416,6 @@ process_overload_item (parmtype, extra_Gcode)\n       break;\n \n     case REAL_TYPE:\n-      parmtype = TYPE_MAIN_VARIANT (parmtype);\n       if (parmtype == long_double_type_node)\n         OB_PUTC ('r');\n       else if (parmtype == double_type_node\n@@ -1609,12 +1593,13 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n     OB_PUTC ('v');\n   else\n     {\n-      if (!flag_do_squangling)    /* Allocate typevec array. */\n+      if (!flag_do_squangling)\n         {\n+\t  /* Allocate typevec array.  */\n           maxtype = 0;\n \t  typevec_size = list_length (parms);\n \t  if (!for_method && current_namespace != global_namespace)\n-\t    /* the namespace of a global function needs one slot */\n+\t    /* The namespace of a global function needs one slot.  */\n \t    typevec_size++;\n           typevec = (tree *)alloca (typevec_size * sizeof (tree));\n         }\n@@ -1635,12 +1620,6 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n \t    {\n \t      my_friendly_assert (maxtype < typevec_size, 387);\n \t      typevec[maxtype++] = this_type;\n-\t      TREE_USED (this_type) = 1;\n-\n-\t      /* By setting up PARMS in this way, the loop below will\n-\t\t automatically clear TREE_USED on THIS_TYPE.  */\n-\t      parms = temp_tree_cons (NULL_TREE, this_type,\n-\t\t\t\t      TREE_CHAIN (parms));\n \t    }\n \n \t  if (TREE_CHAIN (parms))\n@@ -1661,20 +1640,9 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n \t  build_mangled_name (parms, 0, 0);\n \t}\n \n-      if (!flag_do_squangling)     /* Deallocate typevec array */\n-        {\n-          tree t = parms;\n-          typevec = NULL;\n-          while (t)\n-            {\n-              tree temp = TREE_VALUE (t);\n-              TREE_USED (temp) = 0;\n-              /* clear out the type variant in case we used it */\n-              temp = canonical_type_variant (temp);\n-              TREE_USED (temp) = 0;\n-              t = TREE_CHAIN (t);\n-            }\n-        }\n+      if (!flag_do_squangling)\n+\t/* Deallocate typevec array.  */\n+\ttypevec = NULL;\n     }\n \n   if (ret_type != NULL_TREE && for_method != 2)"}]}