{"sha": "6c136d53e89e32fe9d22e41e5df89c08d3470049", "node_id": "C_kwDOANBUbNoAKDZjMTM2ZDUzZTg5ZTMyZmU5ZDIyZTQxZTVkZjg5YzA4ZDM0NzAwNDk", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-08-17T17:36:52Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-08-17T17:36:52Z"}, "message": "c++: Extend -Wredundant-move for const-qual objects [PR90428]\n\nIn this PR, Jon suggested extending the -Wredundant-move warning\nto warn when the user is moving a const object as in:\n\n  struct T { };\n\n  T f(const T& t)\n  {\n    return std::move(t);\n  }\n\nwhere the std::move is redundant, because T does not have\na T(const T&&) constructor (which is very unlikely).  Even with\nthe std::move, T(T&&) would not be used because it would mean\nlosing the const.  Instead, T(const T&) will be called.\n\nI had to restructure the function a bit, but it's better now.  This patch\ndepends on my other recent patches to maybe_warn_pessimizing_move.\n\n\tPR c++/90428\n\ngcc/cp/ChangeLog:\n\n\t* typeck.cc (can_do_rvo_p): Rename to ...\n\t(can_elide_copy_prvalue_p): ... this.\n\t(maybe_warn_pessimizing_move): Extend the\n\t-Wredundant-move warning to warn about std::move on a\n\tconst-qualified object.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/Wredundant-move1.C: Adjust dg-warning.\n\t* g++.dg/cpp0x/Wredundant-move9.C: Likewise.\n\t* g++.dg/cpp0x/Wredundant-move10.C: New test.", "tree": {"sha": "99a2a10d5bd94b903952239db63a15fe0a3c4201", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99a2a10d5bd94b903952239db63a15fe0a3c4201"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c136d53e89e32fe9d22e41e5df89c08d3470049", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c136d53e89e32fe9d22e41e5df89c08d3470049", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c136d53e89e32fe9d22e41e5df89c08d3470049", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c136d53e89e32fe9d22e41e5df89c08d3470049/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6602a2b2dee16af6e2d451c704789356042b5881", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6602a2b2dee16af6e2d451c704789356042b5881", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6602a2b2dee16af6e2d451c704789356042b5881"}], "stats": {"total": 222, "additions": 162, "deletions": 60}, "files": [{"sha": "992ebfd99fb62418301709521988c59d3cccbf1e", "filename": "gcc/cp/typeck.cc", "status": "modified", "additions": 97, "deletions": 58, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c136d53e89e32fe9d22e41e5df89c08d3470049/gcc%2Fcp%2Ftypeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c136d53e89e32fe9d22e41e5df89c08d3470049/gcc%2Fcp%2Ftypeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.cc?ref=6c136d53e89e32fe9d22e41e5df89c08d3470049", "patch": "@@ -10301,7 +10301,7 @@ can_do_nrvo_p (tree retval, tree functype)\n    prvalue.  */\n \n static bool\n-can_do_rvo_p (tree retval, tree functype)\n+can_elide_copy_prvalue_p (tree retval, tree functype)\n {\n   if (functype == error_mark_node)\n     return false;\n@@ -10415,70 +10415,109 @@ maybe_warn_pessimizing_move (tree expr, tree type, bool return_p)\n \treturn;\n     }\n \n-  /* We're looking for *std::move<T&> ((T &) &arg).  */\n-  if (REFERENCE_REF_P (expr)\n-      && TREE_CODE (TREE_OPERAND (expr, 0)) == CALL_EXPR)\n+  /* First, check if this is a call to std::move.  */\n+  if (!REFERENCE_REF_P (expr)\n+      || TREE_CODE (TREE_OPERAND (expr, 0)) != CALL_EXPR)\n+    return;\n+  tree fn = TREE_OPERAND (expr, 0);\n+  if (!is_std_move_p (fn))\n+    return;\n+  tree arg = CALL_EXPR_ARG (fn, 0);\n+  if (TREE_CODE (arg) != NOP_EXPR)\n+    return;\n+  /* If we're looking at *std::move<T&> ((T &) &arg), do the pessimizing N/RVO\n+     and implicitly-movable warnings.  */\n+  if (TREE_CODE (TREE_OPERAND (arg, 0)) == ADDR_EXPR)\n     {\n-      tree fn = TREE_OPERAND (expr, 0);\n-      if (is_std_move_p (fn))\n+      arg = TREE_OPERAND (arg, 0);\n+      arg = TREE_OPERAND (arg, 0);\n+      arg = convert_from_reference (arg);\n+      if (can_elide_copy_prvalue_p (arg, type))\n \t{\n-\t  tree arg = CALL_EXPR_ARG (fn, 0);\n-\t  tree moved;\n-\t  if (TREE_CODE (arg) != NOP_EXPR)\n-\t    return;\n-\t  arg = TREE_OPERAND (arg, 0);\n-\t  if (TREE_CODE (arg) != ADDR_EXPR)\n-\t    return;\n-\t  arg = TREE_OPERAND (arg, 0);\n-\t  arg = convert_from_reference (arg);\n-\t  if (can_do_rvo_p (arg, type))\n-\t    {\n-\t      auto_diagnostic_group d;\n-\t      if (warning_at (loc, OPT_Wpessimizing_move,\n-\t\t\t      \"moving a temporary object prevents copy \"\n-\t\t\t      \"elision\"))\n-\t\tinform (loc, \"remove %<std::move%> call\");\n-\t    }\n-\t  /* The rest of the warnings is only relevant for when we are\n-\t     returning from a function.  */\n-\t  else if (!return_p)\n-\t    return;\n-\t  /* Warn if we could do copy elision were it not for the move.  */\n-\t  else if (can_do_nrvo_p (arg, type))\n+\t  auto_diagnostic_group d;\n+\t  if (warning_at (loc, OPT_Wpessimizing_move,\n+\t\t\t  \"moving a temporary object prevents copy elision\"))\n+\t    inform (loc, \"remove %<std::move%> call\");\n+\t}\n+      /* The rest of the warnings is only relevant for when we are returning\n+\t from a function.  */\n+      if (!return_p)\n+\treturn;\n+\n+      tree moved;\n+      /* Warn if we could do copy elision were it not for the move.  */\n+      if (can_do_nrvo_p (arg, type))\n+\t{\n+\t  auto_diagnostic_group d;\n+\t  if (!warning_suppressed_p (expr, OPT_Wpessimizing_move)\n+\t      && warning_at (loc, OPT_Wpessimizing_move,\n+\t\t\t     \"moving a local object in a return statement \"\n+\t\t\t     \"prevents copy elision\"))\n+\t    inform (loc, \"remove %<std::move%> call\");\n+\t}\n+      /* Warn if the move is redundant.  It is redundant when we would\n+\t do maybe-rvalue overload resolution even without std::move.  */\n+      else if (warn_redundant_move\n+\t       && !warning_suppressed_p (expr, OPT_Wredundant_move)\n+\t       && (moved = treat_lvalue_as_rvalue_p (arg, /*return*/true)))\n+\t{\n+\t  /* Make sure that overload resolution would actually succeed\n+\t     if we removed the std::move call.  */\n+\t  tree t = convert_for_initialization (NULL_TREE, type,\n+\t\t\t\t\t       moved,\n+\t\t\t\t\t       (LOOKUP_NORMAL\n+\t\t\t\t\t\t| LOOKUP_ONLYCONVERTING\n+\t\t\t\t\t\t| LOOKUP_PREFER_RVALUE),\n+\t\t\t\t\t       ICR_RETURN, NULL_TREE, 0,\n+\t\t\t\t\t       tf_none);\n+\t  /* If this worked, implicit rvalue would work, so the call to\n+\t     std::move is redundant.  */\n+\t  if (t != error_mark_node\n+\t      /* Trying to move something const will never succeed unless\n+\t\t there's T(const T&&), which it almost never is, and if\n+\t\t so, T wouldn't be error_mark_node now: the above convert_\n+\t\t call with LOOKUP_PREFER_RVALUE returns an error if a const T&\n+\t\t overload is selected.  */\n+\t      || (CP_TYPE_CONST_P (TREE_TYPE (arg))\n+\t\t  && same_type_ignoring_top_level_qualifiers_p\n+\t\t  (TREE_TYPE (arg), type)))\n \t    {\n \t      auto_diagnostic_group d;\n-\t      if (!warning_suppressed_p (expr, OPT_Wpessimizing_move)\n-\t\t  && warning_at (loc, OPT_Wpessimizing_move,\n-\t\t\t\t \"moving a local object in a return statement \"\n-\t\t\t\t \"prevents copy elision\"))\n+\t      if (warning_at (loc, OPT_Wredundant_move,\n+\t\t\t      \"redundant move in return statement\"))\n \t\tinform (loc, \"remove %<std::move%> call\");\n \t    }\n-\t  /* Warn if the move is redundant.  It is redundant when we would\n-\t     do maybe-rvalue overload resolution even without std::move.  */\n-\t  else if (warn_redundant_move\n-\t\t   && !warning_suppressed_p (expr, OPT_Wredundant_move)\n-\t\t   && (moved = treat_lvalue_as_rvalue_p (arg, /*return*/true)))\n-\t    {\n-\t      /* Make sure that overload resolution would actually succeed\n-\t\t if we removed the std::move call.  */\n-\t      tree t = convert_for_initialization (NULL_TREE, type,\n-\t\t\t\t\t\t   moved,\n-\t\t\t\t\t\t   (LOOKUP_NORMAL\n-\t\t\t\t\t\t    | LOOKUP_ONLYCONVERTING\n-\t\t\t\t\t\t    | LOOKUP_PREFER_RVALUE),\n-\t\t\t\t\t\t   ICR_RETURN, NULL_TREE, 0,\n-\t\t\t\t\t\t   tf_none);\n-\t      /* If this worked, implicit rvalue would work, so the call to\n-\t\t std::move is redundant.  */\n-\t      if (t != error_mark_node)\n-\t\t{\n-\t\t  auto_diagnostic_group d;\n-\t\t  if (warning_at (loc, OPT_Wredundant_move,\n-\t\t\t\t  \"redundant move in return statement\"))\n-\t\t    inform (loc, \"remove %<std::move%> call\");\n-\t\t}\n-\t    }\n \t}\n+     }\n+  /* Also try to warn about redundant std::move in code such as\n+      T f (const T& t)\n+      {\n+\treturn std::move(t);\n+      }\n+    for which EXPR will be something like\n+      *std::move<const T&> ((const struct T &) (const struct T *) t)\n+     and where the std::move does nothing if T does not have a T(const T&&)\n+     constructor, because the argument is const.  It will not use T(T&&)\n+     because that would mean losing the const.  */\n+  else if (TYPE_REF_P (TREE_TYPE (arg))\n+\t   && CP_TYPE_CONST_P (TREE_TYPE (TREE_TYPE (arg))))\n+    {\n+      tree rtype = TREE_TYPE (TREE_TYPE (arg));\n+      if (!same_type_ignoring_top_level_qualifiers_p (rtype, type))\n+\treturn;\n+      /* Check for the unlikely case there's T(const T&&) (we don't care if\n+\t it's deleted).  */\n+      for (tree fn : ovl_range (CLASSTYPE_CONSTRUCTORS (rtype)))\n+\tif (move_fn_p (fn))\n+\t  {\n+\t    tree t = TREE_VALUE (FUNCTION_FIRST_USER_PARMTYPE (fn));\n+\t    if (UNLIKELY (CP_TYPE_CONST_P (TREE_TYPE (t))))\n+\t      return;\n+\t  }\n+      auto_diagnostic_group d;\n+      if (warning_at (loc, OPT_Wredundant_move,\n+\t\t      \"redundant move in return statement\"))\n+\tinform (loc, \"remove %<std::move%> call\");\n     }\n }\n "}, {"sha": "c227019cce1cb7d919bb9118e58c7001437e1215", "filename": "gcc/testsuite/g++.dg/cpp0x/Wredundant-move1.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c136d53e89e32fe9d22e41e5df89c08d3470049/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c136d53e89e32fe9d22e41e5df89c08d3470049/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move1.C?ref=6c136d53e89e32fe9d22e41e5df89c08d3470049", "patch": "@@ -60,7 +60,8 @@ fn4 (const T t)\n {\n   // t is const: will decay into copy despite std::move, so it's redundant.\n   // We used to warn about this, but no longer since c++/87378.\n-  return std::move (t);\t // { dg-warning \"redundant move\" \"\" { target c++20 } }\n+  // Now we warn again since c++/90428.\n+  return std::move (t);\t // { dg-warning \"redundant move\" }\n }\n \n int"}, {"sha": "a215a4774d67364a687a44803cbad512281c613e", "filename": "gcc/testsuite/g++.dg/cpp0x/Wredundant-move10.C", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c136d53e89e32fe9d22e41e5df89c08d3470049/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c136d53e89e32fe9d22e41e5df89c08d3470049/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move10.C?ref=6c136d53e89e32fe9d22e41e5df89c08d3470049", "patch": "@@ -0,0 +1,61 @@\n+// PR c++/90428\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-Wredundant-move\" }\n+\n+// Define std::move.\n+namespace std {\n+  template<typename _Tp>\n+    struct remove_reference\n+    { typedef _Tp   type; };\n+\n+  template<typename _Tp>\n+    struct remove_reference<_Tp&>\n+    { typedef _Tp   type; };\n+\n+  template<typename _Tp>\n+    struct remove_reference<_Tp&&>\n+    { typedef _Tp   type; };\n+\n+  template<typename _Tp>\n+    constexpr typename std::remove_reference<_Tp>::type&&\n+    move(_Tp&& __t) noexcept\n+    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }\n+}\n+\n+struct T { T(); T(const T&); T(T&&) = delete; };\n+struct S : T { };\n+struct W { W(const W&); W(W&&) = delete; W(const W&&); };\n+\n+T f1(T t)\n+{\n+  const T& rt = t;\n+  return std::move(rt); // { dg-warning \"redundant move\" }\n+}\n+\n+T f2(const T& t)\n+{\n+  return std::move(t); // { dg-warning \"redundant move\" }\n+}\n+\n+W f3(const W& w)\n+{\n+  return std::move(w);\n+}\n+\n+T f4(const S& s)\n+{\n+  return std::move(s);\n+}\n+\n+T f5(const T t)\n+{\n+  return std::move(t); // { dg-warning \"redundant move\" }\n+}\n+\n+struct S1 { S1(S1 &&) = delete; S1(const S1&); };\n+struct S2: S1 {};\n+\n+S1 f3(const S2 s)\n+{\n+  return std::move(s); // { dg-warning \"redundant move\" \"\" { target c++20 } }\n+}"}, {"sha": "489ecd2b9c9b370d9954882df4c19b06d6bab56e", "filename": "gcc/testsuite/g++.dg/cpp0x/Wredundant-move9.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c136d53e89e32fe9d22e41e5df89c08d3470049/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c136d53e89e32fe9d22e41e5df89c08d3470049/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move9.C?ref=6c136d53e89e32fe9d22e41e5df89c08d3470049", "patch": "@@ -61,7 +61,8 @@ fn4 (const T<int> t)\n {\n   // t is const: will decay into copy despite std::move, so it's redundant.\n   // We used to warn about this, but no longer since c++/87378.\n-  return std::move (t);\t // { dg-warning \"redundant move\" \"\" { target c++20 } }\n+  // Now we warn again since c++/90428.\n+  return std::move (t);\t // { dg-warning \"redundant move\" }\n }\n \n int"}]}