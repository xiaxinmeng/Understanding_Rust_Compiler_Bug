{"sha": "f34312c23cde2f7cb65ad7e7a7e996278d4d1566", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM0MzEyYzIzY2RlMmY3Y2I2NWFkN2U3YTdlOTk2Mjc4ZDRkMTU2Ng==", "commit": {"author": {"name": "Carlos O'Donell", "email": "carlos@codesourcery.com", "date": "2006-01-30T19:58:57Z"}, "committer": {"name": "Carlos O'Donell", "email": "carlos@gcc.gnu.org", "date": "2006-01-30T19:58:57Z"}, "message": "optabs.c (prepare_cmp_insn): If unbaised and unsigned then bias the comparison routine return.\n\ngcc/\n\n2006-01-30  Carlos O'Donell  <carlos@codesourcery.com>\n\n\t* optabs.c (prepare_cmp_insn): If unbaised and unsigned then bias\n\tthe comparison routine return.\n\ngcc/testsuite/\n\n2006-01-30  Carlos O'Donell  <carlos@codesourcery.com>\n\n\t* gcc.dg/unsigned-long-compare.c: New test.\n\nFrom-SVN: r110409", "tree": {"sha": "871296de6da055e93d32b7275c42ab6acba8cf73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/871296de6da055e93d32b7275c42ab6acba8cf73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f34312c23cde2f7cb65ad7e7a7e996278d4d1566", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f34312c23cde2f7cb65ad7e7a7e996278d4d1566", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f34312c23cde2f7cb65ad7e7a7e996278d4d1566", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f34312c23cde2f7cb65ad7e7a7e996278d4d1566/comments", "author": null, "committer": null, "parents": [{"sha": "b39f98f94d48be5ff106436b5ddc289e77e9d7e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b39f98f94d48be5ff106436b5ddc289e77e9d7e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b39f98f94d48be5ff106436b5ddc289e77e9d7e5"}], "stats": {"total": 57, "additions": 48, "deletions": 9}, "files": [{"sha": "ede7d94ca6b30ab56ebac2c181e72d62245817ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f34312c23cde2f7cb65ad7e7a7e996278d4d1566/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f34312c23cde2f7cb65ad7e7a7e996278d4d1566/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f34312c23cde2f7cb65ad7e7a7e996278d4d1566", "patch": "@@ -1,3 +1,8 @@\n+2006-01-30  Carlos O'Donell  <carlos@codesourcery.com>\n+\n+\t* optabs.c (prepare_cmp_insn): If unbaised and unsigned then bias\n+\tthe comparison routine return.\n+\n 2006-01-30  Michael Matz  <matz@suse.de>\n \n \t* global.c (find_reg): Only evict for global regs."}, {"sha": "bdbb88cce33b32773b0963d9af69ab957202be47", "filename": "gcc/optabs.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f34312c23cde2f7cb65ad7e7a7e996278d4d1566/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f34312c23cde2f7cb65ad7e7a7e996278d4d1566/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=f34312c23cde2f7cb65ad7e7a7e996278d4d1566", "patch": "@@ -3711,18 +3711,24 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n       result = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST_MAKE_BLOCK,\n \t\t\t\t\tword_mode, 2, x, mode, y, mode);\n \n+      /* There are two kinds of comparison routines. Biased routines\n+\t return 0/1/2, and unbiased routines return -1/0/1. Other parts\n+\t of gcc expect that the comparison operation is equivalent\n+\t to the modified comparison. For signed comparisons compare the \n+\t result against 1 in the biased case, and zero in the unbiased\n+\t case. For unsigned comparisons always compare against 1 after\n+\t biasing the unbased result by adding 1. This gives us a way to\n+\t represent LTU. */\n       *px = result;\n       *pmode = word_mode;\n-      if (TARGET_LIB_INT_CMP_BIASED)\n-\t/* Integer comparison returns a result that must be compared\n-\t   against 1, so that even if we do an unsigned compare\n-\t   afterward, there is still a value that can represent the\n-\t   result \"less than\".  */\n-\t*py = const1_rtx;\n-      else\n+      *py = const1_rtx;\n+\n+      if (!TARGET_LIB_INT_CMP_BIASED)\n \t{\n-\t  *py = const0_rtx;\n-\t  *punsignedp = 1;\n+\t  if (*punsignedp)\n+\t    *px = plus_constant (result, 1);  \n+\t  else\n+\t    *py = const0_rtx;\n \t}\n       return;\n     }"}, {"sha": "1aea281d1cc0fa92338606ae0a2da172dc145bda", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f34312c23cde2f7cb65ad7e7a7e996278d4d1566/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f34312c23cde2f7cb65ad7e7a7e996278d4d1566/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f34312c23cde2f7cb65ad7e7a7e996278d4d1566", "patch": "@@ -1,3 +1,7 @@\n+2006-01-30  Carlos O'Donell  <carlos@codesourcery.com>\n+\n+\t* gcc.dg/unsigned-long-compare.c: New test.\n+\n 2006-01-30  Steve Ellcey  <sje@cup.hp.com>\n \n \tPR testsuite/25318"}, {"sha": "1c5c69cf038af9749a8f0e19debc96911aff00c2", "filename": "gcc/testsuite/gcc.dg/unsigned-long-compare.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f34312c23cde2f7cb65ad7e7a7e996278d4d1566/gcc%2Ftestsuite%2Fgcc.dg%2Funsigned-long-compare.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f34312c23cde2f7cb65ad7e7a7e996278d4d1566/gcc%2Ftestsuite%2Fgcc.dg%2Funsigned-long-compare.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funsigned-long-compare.c?ref=f34312c23cde2f7cb65ad7e7a7e996278d4d1566", "patch": "@@ -0,0 +1,24 @@\n+/* Copyright (C) 2006 Free Software Foundation, Inc. */\n+/* Contributed by Carlos O'Donell on 2006-01-30 */\n+\n+/* Test a division corner case where the expression simplifies\n+   to a comparison, and the optab expansion is wrong. The optab \n+   expansion emits a function whose return is unbiased and needs\n+   adjustment. */\n+/* Origin: Carlos O'Donell <carlos@codesourcery.com> */\n+/* { dg-do run { target arm-*-*eabi* } } */\n+/* { dg-options \"\" } */\n+#include <stdlib.h>\n+\n+#define BIG_CONSTANT 0xFFFFFFFF80000000ULL\n+\n+int main (void)\n+{\n+  unsigned long long OneULL = 1ULL;\n+  unsigned long long result;\n+\n+  result = OneULL / BIG_CONSTANT; \n+  if (result)\n+    abort ();\n+  exit (0);\n+}"}]}