{"sha": "1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2", "node_id": "C_kwDOANBUbNoAKDFiYjlhMjk2ODhhYjRkZGZlYzdmOGQzNmNhMmNlZTYzYzVmMjU4ZDI", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-17T16:04:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-17T16:04:23Z"}, "message": "Merge #1029\n\n1029: Macro in trait impl r=CohenArthur a=CohenArthur\n\nNeeds #1028 \r\n\r\nYou can just review the last commit to avoid reviewing twice. Sorry about that!\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "7fb389c42bf54536a486bd5713ef64f9623a2d82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fb389c42bf54536a486bd5713ef64f9623a2d82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiM1wHCRBK7hj4Ov3rIwAALm8IAJWud/Zp34jcN+iJTFhUZpiq\nbccmfGiTKyVLSPx3RrR2YviSBtv1mydykHzjn9dwCXXL+YtZRUn+3ejzyRDk5Lx4\ngoO2LwQVjH51WATx9EqaAK6Tjji9qe32FfNhJUaJbN4XBGqXdZiFDBI6M6CWbBFz\nk4eMxmmQPLLFtU3gmBkoxlEhZsV4zOxvK5+g7nzlofkArOZaM7gASlYqW132ZKsX\n8M9Sjf2wlmRCzuhMYgMhY2pPPryC0A5hyKY4JY9Z75Fgt91PaH7d2t6nJuD209RJ\nsKiyP1GILdU0vzEWw+IuMK4ZdRhOP5TaXkwvsE+e5nJmI0PLmMZLMED/kWXFsYE=\n=V399\n-----END PGP SIGNATURE-----\n", "payload": "tree 7fb389c42bf54536a486bd5713ef64f9623a2d82\nparent 1a14348afefc62313e38156fde768744378f9ebf\nparent a7ef6f98be0e25187ad1690428aafc17e19b5751\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1647533063 +0000\ncommitter GitHub <noreply@github.com> 1647533063 +0000\n\nMerge #1029\n\n1029: Macro in trait impl r=CohenArthur a=CohenArthur\n\nNeeds #1028 \r\n\r\nYou can just review the last commit to avoid reviewing twice. Sorry about that!\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a14348afefc62313e38156fde768744378f9ebf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a14348afefc62313e38156fde768744378f9ebf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a14348afefc62313e38156fde768744378f9ebf"}, {"sha": "a7ef6f98be0e25187ad1690428aafc17e19b5751", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7ef6f98be0e25187ad1690428aafc17e19b5751", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7ef6f98be0e25187ad1690428aafc17e19b5751"}], "stats": {"total": 526, "additions": 432, "deletions": 94}, "files": [{"sha": "a22c2d1ad1d88bdc32f674f2919cbfaf7ed08fc6", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 131, "deletions": 16, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2", "patch": "@@ -1511,18 +1511,51 @@ class SingleASTNode\n     EXPRESSION,\n     ITEM,\n     STMT,\n+    EXTERN,\n+    TRAIT,\n+    IMPL,\n+    TRAIT_IMPL,\n   };\n \n+private:\n+  NodeType kind;\n+\n+  // FIXME make this a union\n+  std::unique_ptr<Expr> expr;\n+  std::unique_ptr<Item> item;\n+  std::unique_ptr<Stmt> stmt;\n+  std::unique_ptr<ExternalItem> external_item;\n+  std::unique_ptr<TraitItem> trait_item;\n+  std::unique_ptr<InherentImplItem> impl_item;\n+  std::unique_ptr<TraitImplItem> trait_impl_item;\n+\n+public:\n   SingleASTNode (std::unique_ptr<Expr> expr)\n-    : kind (EXPRESSION), expr (std::move (expr)), item (nullptr), stmt (nullptr)\n+    : kind (EXPRESSION), expr (std::move (expr))\n   {}\n \n   SingleASTNode (std::unique_ptr<Item> item)\n-    : kind (ITEM), expr (nullptr), item (std::move (item)), stmt (nullptr)\n+    : kind (ITEM), item (std::move (item))\n   {}\n \n   SingleASTNode (std::unique_ptr<Stmt> stmt)\n-    : kind (STMT), expr (nullptr), item (nullptr), stmt (std::move (stmt))\n+    : kind (STMT), stmt (std::move (stmt))\n+  {}\n+\n+  SingleASTNode (std::unique_ptr<ExternalItem> item)\n+    : kind (EXTERN), external_item (std::move (item))\n+  {}\n+\n+  SingleASTNode (std::unique_ptr<TraitItem> item)\n+    : kind (TRAIT), trait_item (std::move (item))\n+  {}\n+\n+  SingleASTNode (std::unique_ptr<InherentImplItem> item)\n+    : kind (IMPL), impl_item (std::move (item))\n+  {}\n+\n+  SingleASTNode (std::unique_ptr<TraitImplItem> trait_impl_item)\n+    : kind (TRAIT_IMPL), trait_impl_item (std::move (trait_impl_item))\n   {}\n \n   SingleASTNode (SingleASTNode const &other)\n@@ -1541,6 +1574,22 @@ class SingleASTNode\n       case STMT:\n \tstmt = other.stmt->clone_stmt ();\n \tbreak;\n+\n+      case EXTERN:\n+\texternal_item = other.external_item->clone_external_item ();\n+\tbreak;\n+\n+      case TRAIT:\n+\ttrait_item = other.trait_item->clone_trait_item ();\n+\tbreak;\n+\n+      case IMPL:\n+\timpl_item = other.impl_item->clone_inherent_impl_item ();\n+\tbreak;\n+\n+      case TRAIT_IMPL:\n+\ttrait_impl_item = other.trait_impl_item->clone_trait_impl_item ();\n+\tbreak;\n       }\n   }\n \n@@ -1560,6 +1609,22 @@ class SingleASTNode\n       case STMT:\n \tstmt = other.stmt->clone_stmt ();\n \tbreak;\n+\n+      case EXTERN:\n+\texternal_item = other.external_item->clone_external_item ();\n+\tbreak;\n+\n+      case TRAIT:\n+\ttrait_item = other.trait_item->clone_trait_item ();\n+\tbreak;\n+\n+      case IMPL:\n+\timpl_item = other.impl_item->clone_inherent_impl_item ();\n+\tbreak;\n+\n+      case TRAIT_IMPL:\n+\ttrait_impl_item = other.trait_impl_item->clone_trait_impl_item ();\n+\tbreak;\n       }\n     return *this;\n   }\n@@ -1569,7 +1634,7 @@ class SingleASTNode\n \n   NodeType get_kind () const { return kind; }\n \n-  std::unique_ptr<Expr> &get_inner ()\n+  std::unique_ptr<Expr> &get_expr ()\n   {\n     rust_assert (kind == EXPRESSION);\n     return expr;\n@@ -1610,6 +1675,30 @@ class SingleASTNode\n     return std::move (item);\n   }\n \n+  std::unique_ptr<TraitItem> take_trait_item ()\n+  {\n+    rust_assert (!is_error ());\n+    return std::move (trait_item);\n+  }\n+\n+  std::unique_ptr<ExternalItem> take_external_item ()\n+  {\n+    rust_assert (!is_error ());\n+    return std::move (external_item);\n+  }\n+\n+  std::unique_ptr<InherentImplItem> take_impl_item ()\n+  {\n+    rust_assert (!is_error ());\n+    return std::move (impl_item);\n+  }\n+\n+  std::unique_ptr<TraitImplItem> take_trait_impl_item ()\n+  {\n+    rust_assert (!is_error ());\n+    return std::move (trait_impl_item);\n+  }\n+\n   void accept_vis (ASTVisitor &vis)\n   {\n     switch (kind)\n@@ -1625,6 +1714,22 @@ class SingleASTNode\n       case STMT:\n \tstmt->accept_vis (vis);\n \tbreak;\n+\n+      case EXTERN:\n+\texternal_item->accept_vis (vis);\n+\tbreak;\n+\n+      case TRAIT:\n+\ttrait_item->accept_vis (vis);\n+\tbreak;\n+\n+      case IMPL:\n+\timpl_item->accept_vis (vis);\n+\tbreak;\n+\n+      case TRAIT_IMPL:\n+\ttrait_impl_item->accept_vis (vis);\n+\tbreak;\n       }\n   }\n \n@@ -1638,9 +1743,18 @@ class SingleASTNode\n \treturn item == nullptr;\n       case STMT:\n \treturn stmt == nullptr;\n-      default:\n-\treturn true;\n+      case EXTERN:\n+\treturn external_item == nullptr;\n+      case TRAIT:\n+\treturn trait_item == nullptr;\n+      case IMPL:\n+\treturn impl_item == nullptr;\n+      case TRAIT_IMPL:\n+\treturn trait_impl_item == nullptr;\n       }\n+\n+    gcc_unreachable ();\n+    return true;\n   }\n \n   std::string as_string ()\n@@ -1653,18 +1767,19 @@ class SingleASTNode\n \treturn \"Item: \" + item->as_string ();\n       case STMT:\n \treturn \"Stmt: \" + stmt->as_string ();\n-      default:\n-\treturn \"\";\n+      case EXTERN:\n+\treturn \"External Item: \" + external_item->as_string ();\n+      case TRAIT:\n+\treturn \"Trait Item: \" + trait_item->as_string ();\n+      case IMPL:\n+\treturn \"Impl Item: \" + impl_item->as_string ();\n+      case TRAIT_IMPL:\n+\treturn \"Trait Impl Item: \" + impl_item->as_string ();\n       }\n-  }\n \n-private:\n-  NodeType kind;\n-\n-  // FIXME make this a union\n-  std::unique_ptr<Expr> expr;\n-  std::unique_ptr<Item> item;\n-  std::unique_ptr<Stmt> stmt;\n+    gcc_unreachable ();\n+    return \"\";\n+  }\n };\n \n /* Basically, a \"fragment\" that can be incorporated into the AST, created as"}, {"sha": "5ecd5d7261192a16a355d3120ed3f295744721a0", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2", "patch": "@@ -460,6 +460,7 @@ class MacroInvocation : public TypeNoBounds,\n \t\t\tpublic TraitItem,\n \t\t\tpublic TraitImplItem,\n \t\t\tpublic InherentImplItem,\n+\t\t\tpublic ExternalItem,\n \t\t\tpublic ExprWithoutBlock\n {\n   std::vector<Attribute> outer_attrs;\n@@ -537,6 +538,11 @@ class MacroInvocation : public TypeNoBounds,\n     return clone_macro_invocation_impl ();\n   }\n \n+  MacroInvocation *clone_external_item_impl () const final override\n+  {\n+    return clone_macro_invocation_impl ();\n+  }\n+\n   /*virtual*/ MacroInvocation *clone_macro_invocation_impl () const\n   {\n     return new MacroInvocation (*this);"}, {"sha": "3de660897ca71f1cefaec5d349054280724e7d1f", "filename": "gcc/rust/expand/rust-attribute-visitor.cc", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc?ref=1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2", "patch": "@@ -1114,8 +1114,6 @@ AttrVisitor::visit (AST::ClosureExprInner &expr)\n void\n AttrVisitor::visit (AST::BlockExpr &expr)\n {\n-  expander.push_context (MacroExpander::BLOCK);\n-\n   // initial strip test based on outer attrs\n   expander.expand_cfg_attrs (expr.get_outer_attrs ());\n   if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n@@ -1135,31 +1133,13 @@ AttrVisitor::visit (AST::BlockExpr &expr)\n       return;\n     }\n \n-  // strip all statements\n-  auto &stmts = expr.get_statements ();\n-  for (auto it = stmts.begin (); it != stmts.end ();)\n-    {\n-      auto &stmt = *it;\n-\n-      stmt->accept_vis (*this);\n+  std::function<std::unique_ptr<AST::Stmt> (AST::SingleASTNode)> extractor\n+    = [] (AST::SingleASTNode node) { return node.take_stmt (); };\n \n-      auto fragment = expander.take_expanded_fragment (*this);\n-      if (fragment.should_expand ())\n-\t{\n-\t  // Remove the current expanded invocation\n-\t  it = stmts.erase (it);\n-\t  for (auto &node : fragment.get_nodes ())\n-\t    {\n-\t      it = stmts.insert (it, node.take_stmt ());\n-\t      it++;\n-\t    }\n-\t}\n+  expand_macro_children (MacroExpander::BLOCK, expr.get_statements (),\n+\t\t\t extractor);\n \n-      else if (stmt->is_marked_for_strip ())\n-\tit = stmts.erase (it);\n-      else\n-\tit++;\n-    }\n+  expander.push_context (MacroExpander::BLOCK);\n \n   // strip tail expression if exists - can actually fully remove it\n   if (expr.has_tail_expr ())\n@@ -2489,8 +2469,11 @@ AttrVisitor::visit (AST::Trait &trait)\n   if (trait.has_where_clause ())\n     expand_where_clause (trait.get_where_clause ());\n \n-  // strip trait items if required\n-  expand_pointer_allow_strip (trait.get_trait_items ());\n+  std::function<std::unique_ptr<AST::TraitItem> (AST::SingleASTNode)> extractor\n+    = [] (AST::SingleASTNode node) { return node.take_trait_item (); };\n+\n+  expand_macro_children (MacroExpander::TRAIT, trait.get_trait_items (),\n+\t\t\t extractor);\n }\n void\n AttrVisitor::visit (AST::InherentImpl &impl)\n@@ -2523,8 +2506,11 @@ AttrVisitor::visit (AST::InherentImpl &impl)\n   if (impl.has_where_clause ())\n     expand_where_clause (impl.get_where_clause ());\n \n-  // strip inherent impl items if required\n-  expand_pointer_allow_strip (impl.get_impl_items ());\n+  std::function<std::unique_ptr<AST::InherentImplItem> (AST::SingleASTNode)>\n+    extractor = [] (AST::SingleASTNode node) { return node.take_impl_item (); };\n+\n+  expand_macro_children (MacroExpander::IMPL, impl.get_impl_items (),\n+\t\t\t extractor);\n }\n void\n AttrVisitor::visit (AST::TraitImpl &impl)\n@@ -2563,8 +2549,12 @@ AttrVisitor::visit (AST::TraitImpl &impl)\n   if (impl.has_where_clause ())\n     expand_where_clause (impl.get_where_clause ());\n \n-  // strip trait impl items if required\n-  expand_pointer_allow_strip (impl.get_impl_items ());\n+  std::function<std::unique_ptr<AST::TraitImplItem> (AST::SingleASTNode)>\n+    extractor\n+    = [] (AST::SingleASTNode node) { return node.take_trait_impl_item (); };\n+\n+  expand_macro_children (MacroExpander::TRAIT_IMPL, impl.get_impl_items (),\n+\t\t\t extractor);\n }\n void\n AttrVisitor::visit (AST::ExternalStaticItem &item)\n@@ -2659,8 +2649,12 @@ AttrVisitor::visit (AST::ExternBlock &block)\n       return;\n     }\n \n-  // strip external items if required\n-  expand_pointer_allow_strip (block.get_extern_items ());\n+  std::function<std::unique_ptr<AST::ExternalItem> (AST::SingleASTNode)>\n+    extractor\n+    = [] (AST::SingleASTNode node) { return node.take_external_item (); };\n+\n+  expand_macro_children (MacroExpander::EXTERN, block.get_extern_items (),\n+\t\t\t extractor);\n }\n \n // I don't think it would be possible to strip macros without expansion"}, {"sha": "6da6583030c593fd929111811497d533e30020de", "filename": "gcc/rust/expand/rust-attribute-visitor.h", "status": "modified", "additions": 54, "deletions": 3, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.h?ref=1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2", "patch": "@@ -40,19 +40,70 @@ class AttrVisitor : public AST::ASTVisitor\n   void expand_trait_function_decl (AST::TraitFunctionDecl &decl);\n   void expand_trait_method_decl (AST::TraitMethodDecl &decl);\n \n-  template <typename T> void expand_pointer_allow_strip (T &values)\n+  /**\n+   * Expand a set of values, erasing them if they are marked for strip, and\n+   * replacing them with expanded macro nodes if necessary.\n+   * This function is slightly different from `expand_pointer_allow_strip` as\n+   * it can only be called in certain expansion contexts - where macro\n+   * invocations are allowed.\n+   *\n+   * @param ctx Context to use for macro expansion\n+   * @param values Iterable reference over values to replace or erase\n+   * @param extractor Function to call when replacing values with the content\n+   * \t\tof an expanded AST node\n+   */\n+  template <typename T, typename U>\n+  void expand_macro_children (MacroExpander::ContextType ctx, T &values,\n+\t\t\t      std::function<U (AST::SingleASTNode)> extractor)\n   {\n+    expander.push_context (ctx);\n+\n     for (auto it = values.begin (); it != values.end ();)\n       {\n \tauto &value = *it;\n \n \t// mark for stripping if required\n \tvalue->accept_vis (*this);\n \n+\tauto fragment = expander.take_expanded_fragment (*this);\n+\tif (fragment.should_expand ())\n+\t  {\n+\t    it = values.erase (it);\n+\t    for (auto &node : fragment.get_nodes ())\n+\t      {\n+\t\tit = values.insert (it, extractor (node));\n+\t\tit++;\n+\t      }\n+\t  }\n+\telse if (value->is_marked_for_strip ())\n+\t  {\n+\t    it = values.erase (it);\n+\t  }\n+\telse\n+\t  {\n+\t    ++it;\n+\t  }\n+      }\n+\n+    expander.pop_context ();\n+  }\n+\n+  template <typename T> void expand_pointer_allow_strip (T &values)\n+  {\n+    for (auto it = values.begin (); it != values.end ();)\n+      {\n+\tauto &value = *it;\n+\n+\t// mark for stripping if required\n+\tvalue->accept_vis (*this);\n \tif (value->is_marked_for_strip ())\n-\t  it = values.erase (it);\n+\t  {\n+\t    it = values.erase (it);\n+\t  }\n \telse\n-\t  ++it;\n+\t  {\n+\t    ++it;\n+\t  }\n       }\n   }\n "}, {"sha": "3bdb8c685e666fafcf3fc32a1abbaa58fb8c0997", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 123, "deletions": 35, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2", "patch": "@@ -786,7 +786,6 @@ parse_many (Parser<MacroInvocLexer> &parser, TokenId &delimiter,\n \t    std::function<AST::SingleASTNode ()> parse_fn)\n {\n   std::vector<AST::SingleASTNode> nodes;\n-\n   while (true)\n     {\n       if (parser.peek_current_token ()->get_id () == delimiter)\n@@ -814,6 +813,68 @@ transcribe_many_items (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n   });\n }\n \n+/**\n+ * Transcribe 0 or more external items from a macro invocation\n+ *\n+ * @param parser Parser to extract items from\n+ * @param delimiter Id of the token on which parsing should stop\n+ */\n+static std::vector<AST::SingleASTNode>\n+transcribe_many_ext (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n+{\n+  return parse_many (parser, delimiter, [&parser] () {\n+    auto item = parser.parse_external_item ();\n+    return AST::SingleASTNode (std::move (item));\n+  });\n+}\n+\n+/**\n+ * Transcribe 0 or more trait items from a macro invocation\n+ *\n+ * @param parser Parser to extract items from\n+ * @param delimiter Id of the token on which parsing should stop\n+ */\n+static std::vector<AST::SingleASTNode>\n+transcribe_many_trait_items (Parser<MacroInvocLexer> &parser,\n+\t\t\t     TokenId &delimiter)\n+{\n+  return parse_many (parser, delimiter, [&parser] () {\n+    auto item = parser.parse_trait_item ();\n+    return AST::SingleASTNode (std::move (item));\n+  });\n+}\n+\n+/**\n+ * Transcribe 0 or more impl items from a macro invocation\n+ *\n+ * @param parser Parser to extract items from\n+ * @param delimiter Id of the token on which parsing should stop\n+ */\n+static std::vector<AST::SingleASTNode>\n+transcribe_many_impl_items (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n+{\n+  return parse_many (parser, delimiter, [&parser] () {\n+    auto item = parser.parse_inherent_impl_item ();\n+    return AST::SingleASTNode (std::move (item));\n+  });\n+}\n+\n+/**\n+ * Transcribe 0 or more trait impl items from a macro invocation\n+ *\n+ * @param parser Parser to extract items from\n+ * @param delimiter Id of the token on which parsing should stop\n+ */\n+static std::vector<AST::SingleASTNode>\n+transcribe_many_trait_impl_items (Parser<MacroInvocLexer> &parser,\n+\t\t\t\t  TokenId &delimiter)\n+{\n+  return parse_many (parser, delimiter, [&parser] () {\n+    auto item = parser.parse_trait_impl_item ();\n+    return AST::SingleASTNode (std::move (item));\n+  });\n+}\n+\n /**\n  * Transcribe 0 or more statements from a macro invocation\n  *\n@@ -845,6 +906,60 @@ transcribe_expression (Parser<MacroInvocLexer> &parser)\n   return {AST::SingleASTNode (std::move (expr))};\n }\n \n+static std::vector<AST::SingleASTNode>\n+transcribe_on_delimiter (Parser<MacroInvocLexer> &parser, bool semicolon,\n+\t\t\t AST::DelimType delimiter, TokenId last_token_id)\n+{\n+  if (semicolon || delimiter == AST::DelimType::CURLY)\n+    return transcribe_many_stmts (parser, last_token_id);\n+  else\n+    return transcribe_expression (parser);\n+} // namespace Rust\n+\n+static std::vector<AST::SingleASTNode>\n+transcribe_context (MacroExpander::ContextType ctx,\n+\t\t    Parser<MacroInvocLexer> &parser, bool semicolon,\n+\t\t    AST::DelimType delimiter, TokenId last_token_id)\n+{\n+  // The flow-chart in order to choose a parsing function is as follows:\n+  //\n+  // [switch special context]\n+  //     -- Item --> parser.parse_item();\n+  //     -- Trait --> parser.parse_trait_item();\n+  //     -- Impl --> parser.parse_impl_item();\n+  //     -- Extern --> parser.parse_extern_item();\n+  //     -- None --> [has semicolon?]\n+  //                 -- Yes --> parser.parse_stmt();\n+  //                 -- No --> [switch invocation.delimiter()]\n+  //                             -- { } --> parser.parse_stmt();\n+  //                             -- _ --> parser.parse_expr(); // once!\n+\n+  // If there is a semicolon OR we are expanding a MacroInvocationSemi, then\n+  // we can parse multiple items. Otherwise, parse *one* expression\n+\n+  switch (ctx)\n+    {\n+    case MacroExpander::ContextType::ITEM:\n+      return transcribe_many_items (parser, last_token_id);\n+      break;\n+    case MacroExpander::ContextType::TRAIT:\n+      return transcribe_many_trait_items (parser, last_token_id);\n+      break;\n+    case MacroExpander::ContextType::IMPL:\n+      return transcribe_many_impl_items (parser, last_token_id);\n+      break;\n+    case MacroExpander::ContextType::TRAIT_IMPL:\n+      return transcribe_many_trait_impl_items (parser, last_token_id);\n+      break;\n+    case MacroExpander::ContextType::EXTERN:\n+      return transcribe_many_ext (parser, last_token_id);\n+      break;\n+    default:\n+      return transcribe_on_delimiter (parser, semicolon, delimiter,\n+\t\t\t\t      last_token_id);\n+    }\n+}\n+\n AST::ASTFragment\n MacroExpander::transcribe_rule (\n   AST::MacroRule &match_rule, AST::DelimTokenTree &invoc_token_tree,\n@@ -864,18 +979,15 @@ MacroExpander::transcribe_rule (\n   std::vector<std::unique_ptr<AST::Token>> substituted_tokens\n     = substitute_context.substitute_tokens ();\n \n+  // handy for debugging\n+  // for (auto &tok : substituted_tokens)\n+  //   rust_debug (\"[tok] %s\", tok->as_string ().c_str ());\n+\n   // parse it to an ASTFragment\n   MacroInvocLexer lex (std::move (substituted_tokens));\n   Parser<MacroInvocLexer> parser (std::move (lex));\n \n-  // handy for debugging\n-  // for (auto &tok : substituted_tokens)\n-  //   {\n-  //     rust_debug (\"tok: [%s]\", tok->as_string ().c_str ());\n-  //   }\n-\n   auto last_token_id = TokenId::RIGHT_CURLY;\n-  std::vector<AST::SingleASTNode> nodes;\n \n   // this is used so we can check that we delimit the stream correctly.\n   switch (transcribe_tree.get_delim_type ())\n@@ -905,33 +1017,9 @@ MacroExpander::transcribe_rule (\n   //   as a statement (either via ExpressionStatement or\n   //   MacroInvocationWithSemi)\n \n-  // The flow-chart in order to choose a parsing function is as follows:\n-  //\n-  // [is in item context?]\n-  //     -- Yes --> parser.parse_item();\n-  //     -- No --> [has semicolon?]\n-  //                 -- Yes --> parser.parse_stmt();\n-  //                 -- No --> [switch invocation.delimiter()]\n-  //                             -- { } --> parser.parse_stmt();\n-  //                             -- _ --> parser.parse_expr();\n-\n-  // If there is a semicolon OR we are expanding a MacroInvocationSemi, then\n-  // we can parse multiple items. Otherwise, parse *one* expression\n-\n-  if (ctx == ContextType::ITEM)\n-    nodes = transcribe_many_items (parser, last_token_id);\n-  else if (semicolon)\n-    nodes = transcribe_many_stmts (parser, last_token_id);\n-  else\n-    switch (invoc_token_tree.get_delim_type ())\n-      {\n-      case AST::CURLY:\n-\tnodes = transcribe_many_stmts (parser, last_token_id);\n-\tbreak;\n-      default:\n-\tnodes = transcribe_expression (parser);\n-\tbreak;\n-      }\n+  auto nodes\n+    = transcribe_context (ctx, parser, semicolon,\n+\t\t\t  invoc_token_tree.get_delim_type (), last_token_id);\n \n   // emit any errors\n   if (parser.has_errors ())"}, {"sha": "f08525fd4e8a3540ddb6b3dac582a079f277d530", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2", "patch": "@@ -187,6 +187,10 @@ struct MacroExpander\n   {\n     ITEM,\n     BLOCK,\n+    EXTERN,\n+    TRAIT,\n+    IMPL,\n+    TRAIT_IMPL,\n   };\n \n   ExpansionCfg cfg;"}, {"sha": "82e7e249531fc1e76a535fc7594e1f2d7f574f21", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2", "patch": "@@ -5251,12 +5251,11 @@ Parser<ManagedTokenSource>::parse_inherent_impl_item ()\n   switch (t->get_id ())\n     {\n     case IDENTIFIER:\n+      // FIXME: Arthur: Do we need to some lookahead here?\n+      return parse_macro_invocation_semi (outer_attrs);\n     case SUPER:\n     case SELF:\n     case CRATE:\n-    case DOLLAR_SIGN:\n-      // these seem to be SimplePath tokens, so this is a macro invocation semi\n-      return parse_macro_invocation_semi (std::move (outer_attrs));\n       case PUB: {\n \t// visibility, so not a macro invocation semi - must be constant,\n \t// function, or method\n@@ -5813,6 +5812,8 @@ Parser<ManagedTokenSource>::parse_external_item ()\n   const_TokenPtr t = lexer.peek_token ();\n   switch (t->get_id ())\n     {\n+    case IDENTIFIER:\n+      return parse_macro_invocation_semi (outer_attrs);\n       case STATIC_TOK: {\n \t// parse extern static item\n \tlexer.skip_token ();"}, {"sha": "588061629e9265e1be29cbe04cd3181793b2cfd5", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2", "patch": "@@ -135,6 +135,10 @@ template <typename ManagedTokenSource> class Parser\n    */\n   std::unique_ptr<AST::Stmt> parse_stmt (bool allow_no_semi = false);\n   std::unique_ptr<AST::Type> parse_type ();\n+  std::unique_ptr<AST::ExternalItem> parse_external_item ();\n+  std::unique_ptr<AST::TraitItem> parse_trait_item ();\n+  std::unique_ptr<AST::InherentImplItem> parse_inherent_impl_item ();\n+  std::unique_ptr<AST::TraitImplItem> parse_trait_impl_item ();\n   AST::PathInExpression parse_path_in_expression ();\n   std::vector<std::unique_ptr<AST::LifetimeParam> > parse_lifetime_params ();\n   AST::Visibility parse_visibility ();\n@@ -285,25 +289,21 @@ template <typename ManagedTokenSource> class Parser\n \t\t\t\t\t\t      AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::Trait> parse_trait (AST::Visibility vis,\n \t\t\t\t\t   AST::AttrVec outer_attrs);\n-  std::unique_ptr<AST::TraitItem> parse_trait_item ();\n   std::unique_ptr<AST::TraitItemType>\n   parse_trait_type (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::TraitItemConst>\n   parse_trait_const (AST::AttrVec outer_attrs);\n   AST::SelfParam parse_self_param ();\n   std::unique_ptr<AST::Impl> parse_impl (AST::Visibility vis,\n \t\t\t\t\t AST::AttrVec outer_attrs);\n-  std::unique_ptr<AST::InherentImplItem> parse_inherent_impl_item ();\n   std::unique_ptr<AST::InherentImplItem>\n   parse_inherent_impl_function_or_method (AST::Visibility vis,\n \t\t\t\t\t  AST::AttrVec outer_attrs);\n-  std::unique_ptr<AST::TraitImplItem> parse_trait_impl_item ();\n   std::unique_ptr<AST::TraitImplItem>\n   parse_trait_impl_function_or_method (AST::Visibility vis,\n \t\t\t\t       AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::ExternBlock>\n   parse_extern_block (AST::Visibility vis, AST::AttrVec outer_attrs);\n-  std::unique_ptr<AST::ExternalItem> parse_external_item ();\n   AST::NamedFunctionParam parse_named_function_param (AST::AttrVec outer_attrs\n \t\t\t\t\t\t      = AST::AttrVec ());\n   AST::Method parse_method ();"}, {"sha": "9f3cbca012ceb5beddf97417f983d1f169cfea74", "filename": "gcc/testsuite/rust/compile/macro20.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro20.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro20.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro20.rs?ref=1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2", "patch": "@@ -0,0 +1,16 @@\n+macro_rules! define_trait {\n+    ($assoc:ident, $i:item) => {\n+        type $assoc;\n+\n+        $i\n+    };\n+}\n+\n+trait DefinedThroughMacros {\n+    define_trait!(\n+        Inner,\n+        fn takes_inner(i: Self::Inner) -> Self::Inner {\n+            i\n+        }\n+    );\n+}"}, {"sha": "9a1d773ec4b07835bf8e728fa3698eb77ba2ffdb", "filename": "gcc/testsuite/rust/compile/macro21.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro21.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro21.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro21.rs?ref=1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2", "patch": "@@ -0,0 +1,9 @@\n+macro_rules! c_fn {\n+    {$name:ident ($($arg_name:ident $arg_ty:ty),*) -> $ret_ty:ty} => {\n+        fn $name($($arg_name: $arg_ty)*) -> $ret_ty;\n+    };\n+}\n+\n+extern \"C\" {\n+    c_fn! {puts (s *const i8) -> i64}\n+}"}, {"sha": "bdc4bada2704bafadb8bdb7e32935bdfc584b8dc", "filename": "gcc/testsuite/rust/compile/macro22.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro22.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro22.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro22.rs?ref=1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2", "patch": "@@ -0,0 +1,10 @@\n+macro_rules! print {\n+    () => {\n+        fn puts(s: *const i8);\n+        fn printf(fmt: *const i8, ...);\n+    };\n+}\n+\n+extern \"C\" {\n+    print! {}\n+}"}, {"sha": "afaca9bc96b1f104f7b78ae993c2e7ab6ee00acf", "filename": "gcc/testsuite/rust/compile/macro23.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro23.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro23.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro23.rs?ref=1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2", "patch": "@@ -0,0 +1,25 @@\n+macro_rules! maybe_impl {\n+    ($left:ident, $right:ident, $l_fn:ident, $r_fn:ident) => {\n+        fn $l_fn(value: T) -> Maybe<T> {\n+            Maybe::$left(value)\n+        }\n+\n+        fn $r_fn() -> Maybe<T> {\n+            Maybe::$right\n+        }\n+    };\n+}\n+\n+enum Maybe<T> {\n+    Just(T),\n+    Nothing,\n+}\n+\n+impl<T> Maybe<T> {\n+    maybe_impl!(Just, Nothing, just, nothing);\n+}\n+\n+fn main() {\n+    let _ = Maybe::just(14);\n+    let _: Maybe<i32> = Maybe::nothing();\n+}"}, {"sha": "846352d048742a802b71ba47613dafdf04022d57", "filename": "gcc/testsuite/rust/execute/torture/macros23.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros23.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros23.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros23.rs?ref=1bb9a29688ab4ddfec7f8d36ca2cee63c5f258d2", "patch": "@@ -0,0 +1,19 @@\n+trait Valuable {\n+    const VALUE: i32;\n+}\n+\n+struct Something;\n+\n+macro_rules! implement {\n+    () => {\n+        const VALUE: i32 = 18;\n+    };\n+}\n+\n+impl Valuable for Something {\n+    implement!();\n+}\n+\n+fn main() -> i32 {\n+    Something::VALUE - 18\n+}"}]}