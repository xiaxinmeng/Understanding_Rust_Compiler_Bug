{"sha": "ebd34478e30a770aa741cf345f08278090770ded", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJkMzQ0NzhlMzBhNzcwYWE3NDFjZjM0NWYwODI3ODA5MDc3MGRlZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-01-26T09:42:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-01-26T09:42:04Z"}, "message": "[multiple changes]\n\n2010-01-26  Robert Dewar  <dewar@adacore.com>\n\n\t* s-commun.ads, s-osprim-mingw.adb, s-stchop-vxworks.adb, sem_aggr.adb,\n\ts-vxwext.adb, sem_ch10.adb, sem_eval.adb, sem_prag.adb: Minor\n\treformatting.\n\n2010-01-26  Vasiliy Fofanov  <fofanov@adacore.com>\n\n\t* g-regist.adb, g-regist.ads (For_Every_Key): New generic procedure\n\tthat allows to iterate over all subkeys of a key.\n\n2010-01-26  Ed Falis  <falis@adacore.com>\n\n\t* sysdep.c: enable NFS for VxWorks MILS\n\t* env.c: enable __gnat_environ for VxWorks MILS\n\t* gcc-interface/Makefile.in: Add VxWorks MILS target pairs.\n\nFrom-SVN: r156233", "tree": {"sha": "a7c7f6dd56455799bb7e32780d5f809be7a4beb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7c7f6dd56455799bb7e32780d5f809be7a4beb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebd34478e30a770aa741cf345f08278090770ded", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebd34478e30a770aa741cf345f08278090770ded", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebd34478e30a770aa741cf345f08278090770ded", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebd34478e30a770aa741cf345f08278090770ded/comments", "author": null, "committer": null, "parents": [{"sha": "d0709b6aeec6b00e71011502fa311751fc138147", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0709b6aeec6b00e71011502fa311751fc138147", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0709b6aeec6b00e71011502fa311751fc138147"}], "stats": {"total": 340, "additions": 254, "deletions": 86}, "files": [{"sha": "2beda2988da075deb20567b47a871f68e0c09027", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ebd34478e30a770aa741cf345f08278090770ded", "patch": "@@ -1,3 +1,20 @@\n+2010-01-26  Robert Dewar  <dewar@adacore.com>\n+\n+\t* s-commun.ads, s-osprim-mingw.adb, s-stchop-vxworks.adb, sem_aggr.adb,\n+\ts-vxwext.adb, sem_ch10.adb, sem_eval.adb, sem_prag.adb: Minor\n+\treformatting.\n+\n+2010-01-26  Vasiliy Fofanov  <fofanov@adacore.com>\n+\n+\t* g-regist.adb, g-regist.ads (For_Every_Key): New generic procedure\n+\tthat allows to iterate over all subkeys of a key.\n+\n+2010-01-26  Ed Falis  <falis@adacore.com>\n+\n+\t* sysdep.c: enable NFS for VxWorks MILS\n+\t* env.c: enable __gnat_environ for VxWorks MILS\n+\t* gcc-interface/Makefile.in: Add VxWorks MILS target pairs.\n+\n 2010-01-25  Bob Duff  <duff@adacore.com>\n \n \t* sem_aggr.adb (Resolve_Array_Aggregate): Check for the case where this"}, {"sha": "c8b49ebe122ccd7684fe28e0e6f7d205b83b91fa", "filename": "gcc/ada/env.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fenv.c?ref=ebd34478e30a770aa741cf345f08278090770ded", "patch": "@@ -52,7 +52,8 @@\n #include <stdlib.h>\n #endif\n \n-#if defined (__vxworks) && ! (defined (__RTP__) || defined (__COREOS__))\n+#if defined (__vxworks) \\\n+  && ! (defined (__RTP__) || defined (__COREOS__) || defined (__VXWORKSMILS__))\n #include \"envLib.h\"\n extern char** ppGlobalEnviron;\n #endif\n@@ -198,7 +199,8 @@ __gnat_setenv (char *name, char *value)\n char **\n __gnat_environ (void)\n {\n-#if defined (VMS) || defined (RTX) || defined (VTHREADS)\n+#if defined (VMS) || defined (RTX) \\\n+   || (defined (VTHREADS) && ! defined (__VXWORKSMILS__))\n   /* Not implemented */\n   return NULL;\n #elif defined (__APPLE__)\n@@ -210,9 +212,11 @@ __gnat_environ (void)\n   extern char **_environ;\n   return _environ;\n #else\n-#if ! (defined (__vxworks) && ! (defined (__RTP__) || defined (__COREOS__)))\n+#if ! (defined (__vxworks) \\\n+   && ! (defined (__RTP__) || defined (__COREOS__) \\\n+   || defined (__VXWORKSMILS__)))\n   /* in VxWorks kernel mode environ is macro and not a variable */\n-  /* same thing on 653 in the CoreOS */\n+  /* same thing on 653 in the CoreOS and for VxWorks MILS vThreads */\n   extern char **environ;\n #endif\n   return environ;"}, {"sha": "44dd8db15645d2a4197e20f09c5c6b1a18e5dbad", "filename": "gcc/ada/g-regist.adb", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fg-regist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fg-regist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-regist.adb?ref=ebd34478e30a770aa741cf345f08278090770ded", "patch": "@@ -122,6 +122,13 @@ package body GNAT.Registry is\n       cbData      : DWORD) return LONG;\n    pragma Import (Stdcall, RegSetValueEx, \"RegSetValueExA\");\n \n+   function RegEnumKey\n+     (Key         : HKEY;\n+      dwIndex     : DWORD;\n+      lpName      : Address;\n+      cchName     : DWORD) return LONG;\n+   pragma Import (Stdcall, RegEnumKey, \"RegEnumKeyA\");\n+\n    ---------------------\n    -- Local Constants --\n    ---------------------\n@@ -231,6 +238,75 @@ package body GNAT.Registry is\n       Check_Result (Result, \"Delete_Value \" & Sub_Key);\n    end Delete_Value;\n \n+   -------------------\n+   -- For_Every_Key --\n+   -------------------\n+\n+   procedure For_Every_Key\n+     (From_Key : HKEY;\n+      Recursive : Boolean := False)\n+   is\n+      procedure Recursive_For_Every_Key\n+        (From_Key  : HKEY;\n+         Recursive : Boolean := False;\n+         Quit      : in out Boolean);\n+\n+      procedure Recursive_For_Every_Key\n+        (From_Key : HKEY;\n+         Recursive : Boolean := False;\n+         Quit      : in out Boolean)\n+      is\n+\n+         use type LONG;\n+         use type ULONG;\n+\n+         Index  : ULONG := 0;\n+         Result : LONG;\n+\n+         Sub_Key : Interfaces.C.char_array (1 .. Max_Key_Size);\n+         pragma Warnings (Off, Sub_Key);\n+\n+         Size_Sub_Key : aliased ULONG;\n+         Sub_Hkey     : HKEY;\n+\n+         function Current_Name return String;\n+\n+         function Current_Name return String is\n+         begin\n+            return Interfaces.C.To_Ada (Sub_Key);\n+         end Current_Name;\n+\n+      begin\n+         loop\n+            Size_Sub_Key := Sub_Key'Length;\n+\n+            Result :=\n+              RegEnumKey\n+                (From_Key, Index, Sub_Key (1)'Address, Size_Sub_Key);\n+\n+            exit when not (Result = ERROR_SUCCESS);\n+\n+            Action (Natural (Index) + 1, From_Key, Current_Name, Quit);\n+\n+            exit when Quit;\n+\n+            if Recursive then\n+               Sub_Hkey := Open_Key (From_Key, Interfaces.C.To_Ada (Sub_Key));\n+               Recursive_For_Every_Key (Sub_Hkey, True, Quit);\n+               Close_Key (Sub_Hkey);\n+            end if;\n+\n+            exit when Quit;\n+\n+            Index := Index + 1;\n+         end loop;\n+      end Recursive_For_Every_Key;\n+\n+      Quit : Boolean := False;\n+   begin\n+      Recursive_For_Every_Key (From_Key, Recursive, Quit);\n+   end For_Every_Key;\n+\n    -------------------------\n    -- For_Every_Key_Value --\n    -------------------------\n@@ -394,7 +470,8 @@ package body GNAT.Registry is\n \n       if Type_Value = REG_EXPAND_SZ and then Expand then\n          return Directory_Operations.Expand_Path\n-           (Value (1 .. Integer (Size_Value - 1)), Directory_Operations.DOS);\n+           (Value (1 .. Integer (Size_Value - 1)),\n+            Directory_Operations.DOS);\n       else\n          return Value (1 .. Integer (Size_Value - 1));\n       end if;"}, {"sha": "52dc6aadb3f89f6905f9410bee417f44d67e31c7", "filename": "gcc/ada/g-regist.ads", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fg-regist.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fg-regist.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-regist.ads?ref=ebd34478e30a770aa741cf345f08278090770ded", "patch": "@@ -108,6 +108,19 @@ package GNAT.Registry is\n    procedure Delete_Value (From_Key : HKEY; Sub_Key : String);\n    --  Remove the named value Sub_Key from the registry key From_Key\n \n+   generic\n+      with procedure Action\n+        (Index    : Positive;\n+         Key      : HKEY;\n+         Key_Name : String;\n+         Quit     : in out Boolean);\n+   procedure For_Every_Key (From_Key : HKEY; Recursive : Boolean := False);\n+   --  Iterates over all the keys registered under From_Key, recursively if\n+   --  Recursive is set to True. Index will be set to 1 for the first key and\n+   --  will be incremented by one in each iteration. The current key of an\n+   --  iteration is set in Key, and its name - in Key_Name. Quit can be set\n+   --  to True to stop iteration; its initial value is False.\n+\n    generic\n       with procedure Action\n         (Index   : Positive;\n@@ -126,6 +139,9 @@ package GNAT.Registry is\n    --  with this case. Furthermore, if Expand is set to True and the Sub_Key\n    --  is a REG_EXPAND_SZ the returned value will have the %name% variables\n    --  replaced by the corresponding environment variable value.\n+   --\n+   --  This iterator can be used in conjunction with For_Every_Key in\n+   --  order to analyze all subkeys and values of a given registry key.\n \n private\n "}, {"sha": "53200a338170260f9cf7c1d098a747f2f77b0891", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 54, "deletions": 4, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=ebd34478e30a770aa741cf345f08278090770ded", "patch": "@@ -536,7 +536,7 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworks,$(targ))),)\n   EXTRA_LIBGNAT_OBJS+=vx_stack_info.o\n endif\n \n-# vxworksae / vxworks 653\n+# vxworks 653\n ifeq ($(strip $(filter-out powerpc% wrs vxworksae,$(targ))),)\n   # target pairs for vthreads runtime\n   LIBGNAT_TARGET_PAIRS = \\\n@@ -599,8 +599,59 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworksae,$(targ))),)\n   endif\n endif\n \n-# vxworksae / vxworks 653 for x86 (vxsim)\n-ifeq ($(strip $(filter-out %86 wrs vxworksae,$(targ))),)\n+# vxworks MILS\n+ifeq ($(strip $(filter-out powerpc% wrs vxworksmils,$(targ))),)\n+  # target pairs for vthreads runtime\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-vxworks.ads \\\n+  a-numaux.ads<a-numaux-vxworks.ads \\\n+  g-io.adb<g-io-vxworks-ppc-cert.adb \\\n+  g-io.ads<g-io-vxworks-ppc-cert.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-interr.adb<s-interr-hwint.adb \\\n+  s-intman.ads<s-intman-vxworks.ads \\\n+  s-intman.adb<s-intman-vxworks.adb \\\n+  s-osinte.adb<s-osinte-vxworks.adb \\\n+  s-osinte.ads<s-osinte-vxworks.ads \\\n+  s-osprim.adb<s-osprim-vxworks.adb \\\n+  s-parame.ads<s-parame-ae653.ads \\\n+  s-parame.adb<s-parame-vxworks.adb \\\n+  s-stchop.adb<s-stchop-vxworks.adb \\\n+  s-stchop.ads<s-stchop-limit.ads \\\n+  s-taprop.adb<s-taprop-vxworks.adb \\\n+  s-tasinf.ads<s-tasinf-vxworks.ads \\\n+  s-taspri.ads<s-taspri-vxworks.ads \\\n+  s-thread.adb<s-thread-ae653.adb \\\n+  s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n+  s-vxwork.ads<s-vxwork-ppc.ads \\\n+  g-trasym.ads<g-trasym-unimplemented.ads \\\n+  g-trasym.adb<g-trasym-unimplemented.adb \\\n+  system.ads<system-vxworks-ppc.ads \\\n+  $(DUMMY_SOCKETS_TARGET_PAIRS)\n+\n+  TOOLS_TARGET_PAIRS=\\\n+  mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb \\\n+  indepsw.adb<indepsw-gnu.adb\n+\n+  EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o s-thread.o s-vxwexc.o\n+  EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o s-vxwext.o\n+\n+  EXTRA_LIBGNAT_SRCS+=vx_stack_info.c\n+  EXTRA_LIBGNAT_OBJS+=vx_stack_info.o\n+  GNATRTL_SOCKETS_OBJS =\n+\n+  ifeq ($(strip $(filter-out yes,$(TRACE))),)\n+    LIBGNAT_TARGET_PAIRS += \\\n+    s-traces.adb<s-traces-default.adb \\\n+    s-trafor.adb<s-trafor-default.adb \\\n+    s-trafor.ads<s-trafor-default.ads \\\n+    s-tratas.adb<s-tratas-default.adb \\\n+    s-tfsetr.adb<s-tfsetr-vxworks.adb\n+  endif\n+endif\n+\n+# vxworksae / vxworks 653 for x86 (vxsim) - ?? vxworksmils not implemented\n+ifeq ($(strip $(filter-out %86 wrs vxworksae vxworksmils,$(targ))),)\n   # target pairs for kernel + vthreads runtime\n   LIBGNAT_TARGET_PAIRS = \\\n   a-elchha.adb<a-elchha-vxworks-ppc-full.adb \\\n@@ -623,7 +674,6 @@ ifeq ($(strip $(filter-out %86 wrs vxworksae,$(targ))),)\n   s-taprop.adb<s-taprop-vxworks.adb \\\n   s-tasinf.ads<s-tasinf-vxworks.ads \\\n   s-taspri.ads<s-taspri-vxworks.ads \\\n-  s-thread.adb<s-thread-ae653.adb \\\n   s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n   s-vxwext.adb<s-vxwext-noints.adb \\\n   s-vxwext.ads<s-vxwext-vthreads.ads \\"}, {"sha": "c59a2c7e4dc66e21f10bfb32f06bc8ef17a52679", "filename": "gcc/ada/s-commun.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fs-commun.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fs-commun.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-commun.ads?ref=ebd34478e30a770aa741cf345f08278090770ded", "patch": "@@ -41,6 +41,7 @@ package System.Communication is\n       Count : CRTL.size_t) return Ada.Streams.Stream_Element_Offset;\n    --  Compute the Last OUT parameter for the various Read / Receive\n    --  subprograms: returns First + Count - 1.\n+   --\n    --  When First = Stream_Element_Offset'First and Res = 0, Constraint_Error\n    --  is raised. This is consistent with the semantics of stream operations\n    --  as clarified in AI95-227."}, {"sha": "fc286e67b3037d1069af417b0b78d63661711e16", "filename": "gcc/ada/s-osprim-mingw.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fs-osprim-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fs-osprim-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osprim-mingw.adb?ref=ebd34478e30a770aa741cf345f08278090770ded", "patch": "@@ -199,12 +199,14 @@ package body System.OS_Primitives is\n \n          loop\n             GetSystemTimeAsFileTime (Loc_Time'Access);\n+\n             if QueryPerformanceCounter (Ctrl_Ticks'Access) = Win32.FALSE then\n                pragma Assert\n                  (Standard.False,\n                   \"Could not query high performance counter in Clock\");\n                null;\n             end if;\n+\n             exit when Loc_Time /= Ctrl_Time;\n             Loc_Ticks := Ctrl_Ticks;\n          end loop;\n@@ -218,7 +220,9 @@ package body System.OS_Primitives is\n             Base_Time   := Loc_Time;\n             Base_Ticks  := Loc_Ticks;\n             Current_Max := Elapsed;\n+\n             --  Exit the loop when we have reached the expected precision\n+\n             exit when Elapsed <= Max_Elapsed;\n          end if;\n       end loop;"}, {"sha": "ffdba814a430e3d99a71af00fd67a4d252b87c5a", "filename": "gcc/ada/s-stchop-vxworks.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fs-stchop-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fs-stchop-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stchop-vxworks.adb?ref=ebd34478e30a770aa741cf345f08278090770ded", "patch": "@@ -29,9 +29,10 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is the VxWorks version of this package.\n+--  This is the verson for VxWorks 5 and VxWorks MILS\n+\n --  This file should be kept synchronized with the general implementation\n---  provided by s-stchop.adb. This version is for VxWorks 5 and VxWorks MILS.\n+--  provided by s-stchop.adb.\n \n pragma Restrictions (No_Elaboration_Code);\n --  We want to guarantee the absence of elaboration code because the"}, {"sha": "710ff271aed7959eeaee28c1d409aaec364042f1", "filename": "gcc/ada/s-vxwext.adb", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fs-vxwext.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fs-vxwext.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vxwext.adb?ref=ebd34478e30a770aa741cf345f08278090770ded", "patch": "@@ -28,9 +28,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package provides vxworks specific support functions needed\n---  by System.OS_Interface.\n-\n --  This is the VxWorks 5 and VxWorks MILS version of this package\n \n package body System.VxWorks.Ext is"}, {"sha": "3b0bda0753a61c6a23590d07687c4453adde75d5", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=ebd34478e30a770aa741cf345f08278090770ded", "patch": "@@ -1936,9 +1936,8 @@ package body Sem_Aggr is\n                     and then Compile_Time_Known_Value (Choices_Low)\n                     and then Compile_Time_Known_Value (Choices_High)\n                   then\n-\n                      --  If the bounds have semantic errors, do not attempt\n-                     --  further resolution to prevent cascaded errors..\n+                     --  further resolution to prevent cascaded errors.\n \n                      if Error_Posted (Choices_Low)\n                        or else Error_Posted (Choices_High)\n@@ -1955,7 +1954,7 @@ package body Sem_Aggr is\n                         Ent : Entity_Id;\n \n                      begin\n-                        --  Warning case one, missing values at start/end. Only\n+                        --  Warning case 1, missing values at start/end. Only\n                         --  do the check if the number of entries is too small.\n \n                         if (Enumeration_Pos (CHi) - Enumeration_Pos (CLo))\n@@ -2067,14 +2066,14 @@ package body Sem_Aggr is\n                Check_Can_Never_Be_Null (Etype (N), Expression (Assoc));\n             end if;\n \n-            --  Ada 2005 (AI-287): In case of default initialized component\n+            --  Ada 2005 (AI-287): In case of default initialized component,\n             --  we delay the resolution to the expansion phase.\n \n             if Box_Present (Assoc) then\n \n-               --  Ada 2005 (AI-287): In case of default initialization\n-               --  of a component the expander will generate calls to\n-               --  the corresponding initialization subprogram.\n+               --  Ada 2005 (AI-287): In case of default initialization of a\n+               --  component the expander will generate calls to the\n+               --  corresponding initialization subprogram.\n \n                null;\n \n@@ -2162,7 +2161,7 @@ package body Sem_Aggr is\n \n       --  Do not duplicate Aggr_High if Aggr_High = Aggr_Low + Nb_Elements\n       --  since the addition node returned by Add is not yet analyzed. Attach\n-      --  to tree and analyze first. Reset analyzed flag to insure it will get\n+      --  to tree and analyze first. Reset analyzed flag to ensure it will get\n       --  analyzed when it is a literal bound whose type must be properly set.\n \n       if Others_Present or else Nb_Discrete_Choices > 0 then\n@@ -2179,7 +2178,7 @@ package body Sem_Aggr is\n       --  bounds.\n \n       if Present (Aggregate_Bounds (N)) and then not Others_Allowed then\n-         Aggr_Low := Low_Bound (Aggregate_Bounds (N));\n+         Aggr_Low  := Low_Bound  (Aggregate_Bounds (N));\n          Aggr_High := High_Bound (Aggregate_Bounds (N));\n       end if;\n \n@@ -2208,20 +2207,20 @@ package body Sem_Aggr is\n \n    --  There are two cases to consider:\n \n-   --  a) If the ancestor part is a type mark, the components needed are\n-   --  the difference between the components of the expected type and the\n+   --  a) If the ancestor part is a type mark, the components needed are the\n+   --  difference between the components of the expected type and the\n    --  components of the given type mark.\n \n-   --  b) If the ancestor part is an expression, it must be unambiguous,\n-   --  and once we have its type we can also compute the needed  components\n-   --  as in the previous case. In both cases, if the ancestor type is not\n-   --  the immediate ancestor, we have to build this ancestor recursively.\n+   --  b) If the ancestor part is an expression, it must be unambiguous, and\n+   --  once we have its type we can also compute the needed  components as in\n+   --  the previous case. In both cases, if the ancestor type is not the\n+   --  immediate ancestor, we have to build this ancestor recursively.\n \n-   --  In both cases discriminants of the ancestor type do not play a\n-   --  role in the resolution of the needed components, because inherited\n-   --  discriminants cannot be used in a type extension. As a result we can\n-   --  compute independently the list of components of the ancestor type and\n-   --  of the expected type.\n+   --  In both cases discriminants of the ancestor type do not play a role in\n+   --  the resolution of the needed components, because inherited discriminants\n+   --  cannot be used in a type extension. As a result we can compute\n+   --  independently the list of components of the ancestor type and of the\n+   --  expected type.\n \n    procedure Resolve_Extension_Aggregate (N : Node_Id; Typ : Entity_Id) is\n       A      : constant Node_Id := Ancestor_Part (N);\n@@ -2231,8 +2230,8 @@ package body Sem_Aggr is\n \n       function Valid_Limited_Ancestor (Anc : Node_Id) return Boolean;\n       --  If the type is limited, verify that the ancestor part is a legal\n-      --  expression (aggregate or function call, including 'Input)) that\n-      --  does not require a copy, as specified in 7.5 (2).\n+      --  expression (aggregate or function call, including 'Input)) that does\n+      --  not require a copy, as specified in 7.5(2).\n \n       function Valid_Ancestor_Type return Boolean;\n       --  Verify that the type of the ancestor part is a non-private ancestor\n@@ -2257,9 +2256,7 @@ package body Sem_Aggr is\n          then\n             return True;\n \n-         elsif\n-           Nkind (Anc) = N_Qualified_Expression\n-         then\n+         elsif Nkind (Anc) = N_Qualified_Expression then\n             return Valid_Limited_Ancestor (Expression (Anc));\n \n          else\n@@ -2281,9 +2278,9 @@ package body Sem_Aggr is\n                return True;\n \n             --  The base type of the parent type may appear as  a private\n-            --  extension if it is declared as such in a parent unit of\n-            --  the current one. For consistency of the subsequent analysis\n-            --  use the partial view for the ancestor part.\n+            --  extension if it is declared as such in a parent unit of the\n+            --  current one. For consistency of the subsequent analysis use\n+            --  the partial view for the ancestor part.\n \n             elsif Is_Private_Type (Etype (Imm_Type))\n               and then Present (Full_View (Etype (Imm_Type)))\n@@ -2305,8 +2302,8 @@ package body Sem_Aggr is\n    --  Start of processing for Resolve_Extension_Aggregate\n \n    begin\n-      --  Analyze the ancestor part and account for the case where it's\n-      --  a parameterless function call.\n+      --  Analyze the ancestor part and account for the case where it is a\n+      --  parameterless function call.\n \n       Analyze (A);\n       Check_Parameterless_Call (A);\n@@ -2410,14 +2407,14 @@ package body Sem_Aggr is\n               and then Nkind (Original_Node (A)) = N_Function_Call\n             then\n                --  If the ancestor part is a dispatching call, it appears\n-               --  statically to be a legal ancestor, but it yields any\n-               --  member of the class, and it is not possible to determine\n-               --  whether it is an ancestor of the extension aggregate (much\n-               --  less which ancestor). It is not possible to determine the\n-               --  required components of the extension part.\n+               --  statically to be a legal ancestor, but it yields any member\n+               --  of the class, and it is not possible to determine whether\n+               --  it is an ancestor of the extension aggregate (much less\n+               --  which ancestor). It is not possible to determine the\n+               --  components of the extension part.\n \n-               --  This check implements AI-306, which in fact was motivated\n-               --  by an ACT query to the ARG after this test was added.\n+               --  This check implements AI-306, which in fact was motivated by\n+               --  an AdaCore query to the ARG after this test was added.\n \n                Error_Msg_N (\"ancestor part must be statically tagged\", A);\n             else\n@@ -2444,16 +2441,16 @@ package body Sem_Aggr is\n       Component_Elmt  : Elmt_Id;\n \n       Components : constant Elist_Id := New_Elmt_List;\n-      --  Components is the list of the record components whose value must\n-      --  be provided in the aggregate. This list does include discriminants.\n+      --  Components is the list of the record components whose value must be\n+      --  provided in the aggregate. This list does include discriminants.\n \n       New_Assoc_List : constant List_Id := New_List;\n       New_Assoc      : Node_Id;\n       --  New_Assoc_List is the newly built list of N_Component_Association\n       --  nodes. New_Assoc is one such N_Component_Association node in it.\n-      --  Please note that while Assoc and New_Assoc contain the same\n-      --  kind of nodes, they are used to iterate over two different\n-      --  N_Component_Association lists.\n+      --  Note that while Assoc and New_Assoc contain the same kind of nodes,\n+      --  they are used to iterate over two different N_Component_Association\n+      --  lists.\n \n       Others_Etype : Entity_Id := Empty;\n       --  This variable is used to save the Etype of the last record component\n@@ -2464,7 +2461,7 @@ package body Sem_Aggr is\n       --    (b) make sure the type of all the components whose value is\n       --        subsumed by the others choice are the same.\n       --\n-      --  This variable is updated as a side effect of function Get_Value\n+      --  This variable is updated as a side effect of function Get_Value.\n \n       Is_Box_Present : Boolean := False;\n       Others_Box     : Boolean := False;\n@@ -2480,40 +2477,43 @@ package body Sem_Aggr is\n          Expr           : Node_Id;\n          Assoc_List     : List_Id;\n          Is_Box_Present : Boolean := False);\n-      --  Builds a new N_Component_Association node which associates\n-      --  Component to expression Expr and adds it to the association\n-      --  list being built, either New_Assoc_List, or the association\n-      --  being built for an inner aggregate.\n+      --  Builds a new N_Component_Association node which associates Component\n+      --  to expression Expr and adds it to the association list being built,\n+      --  either New_Assoc_List, or the association being built for an inner\n+      --  aggregate.\n \n       function Discr_Present (Discr : Entity_Id) return Boolean;\n       --  If aggregate N is a regular aggregate this routine will return True.\n       --  Otherwise, if N is an extension aggregate, Discr is a discriminant\n-      --  whose value may already have been specified by N's ancestor part,\n-      --  this routine checks whether this is indeed the case and if so\n-      --  returns False, signaling that no value for Discr should appear in the\n-      --  N's aggregate part. Also, in this case, the routine appends to\n+      --  whose value may already have been specified by N's ancestor part.\n+      --  This routine checks whether this is indeed the case and if so returns\n+      --  False, signaling that no value for Discr should appear in N's\n+      --  aggregate part. Also, in this case, the routine appends\n       --  New_Assoc_List Discr the discriminant value specified in the ancestor\n       --  part.\n+      --  Can't parse previous sentence, appends what where???\n \n       function Get_Value\n         (Compon                 : Node_Id;\n          From                   : List_Id;\n          Consider_Others_Choice : Boolean := False)\n          return                   Node_Id;\n-      --  Given a record component stored in parameter Compon, the\n-      --  following function returns its value as it appears in the list\n-      --  From, which is a list of N_Component_Association nodes. If no\n-      --  component association has a choice for the searched component,\n-      --  the value provided by the others choice is returned, if there\n-      --  is  one and Consider_Others_Choice is set to true. Otherwise\n-      --  Empty is returned. If there is more than one component association\n-      --  giving a value for the searched record component, an error message\n-      --  is emitted and the first found value is returned.\n+      --  Given a record component stored in parameter Compon, the following\n+      --  function returns its value as it appears in the list From, which is\n+      --  a list of N_Component_Association nodes.\n+      --  What is this referring to??? There is no \"following function\" in\n+      --  sight???\n+      --  If no component association has a choice for the searched component,\n+      --  the value provided by the others choice is returned, if there is one,\n+      --  and Consider_Others_Choice is set to true. Otherwise Empty is\n+      --  returned. If there is more than one component association giving a\n+      --  value for the searched record component, an error message is emitted\n+      --  and the first found value is returned.\n       --\n       --  If Consider_Others_Choice is set and the returned expression comes\n       --  from the others choice, then Others_Etype is set as a side effect.\n-      --  An error message is emitted if the components taking their value\n-      --  from the others choice do not have same type.\n+      --  An error message is emitted if the components taking their value from\n+      --  the others choice do not have same type.\n \n       procedure Resolve_Aggr_Expr (Expr : Node_Id; Component : Node_Id);\n       --  Analyzes and resolves expression Expr against the Etype of the\n@@ -2613,7 +2613,7 @@ package body Sem_Aggr is\n          D := First_Discriminant (Ancestor_Typ);\n          while Present (D) loop\n \n-            --  If Ancestor has already specified Disc value than insert its\n+            --  If Ancestor has already specified Disc value then insert its\n             --  value in the final aggregate.\n \n             if Original_Record_Component (D) = Orig_Discr then"}, {"sha": "8a53d5891b6c40d6dc6b3507fb65b2dca0e34660", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=ebd34478e30a770aa741cf345f08278090770ded", "patch": "@@ -4015,6 +4015,10 @@ package body Sem_Ch10 is\n                   --  a with_clause on the same unit as a private with-clause\n                   --  on a parent, in which case child unit is visible.\n \n+                  ----------------\n+                  -- In_Context --\n+                  ----------------\n+\n                   function In_Context return Boolean is\n                   begin\n                      Clause :="}, {"sha": "f38e0595e451a12256d229fe703c0775fc92f747", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=ebd34478e30a770aa741cf345f08278090770ded", "patch": "@@ -1915,9 +1915,7 @@ package body Sem_Eval is\n             --  are error cases where this is not the case), then see if we\n             --  can do a constant evaluation of the array reference.\n \n-            if Is_Array_Type (Atyp)\n-              and then Atyp /= Any_Composite\n-            then\n+            if Is_Array_Type (Atyp) and then Atyp /= Any_Composite then\n                if Ekind (Atyp) = E_String_Literal_Subtype then\n                   Lbd := String_Literal_Low_Bound (Atyp);\n                else"}, {"sha": "d49ebd10f1e8c2dbe19f402158f145fd15aea2d3", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=ebd34478e30a770aa741cf345f08278090770ded", "patch": "@@ -5265,16 +5265,15 @@ package body Sem_Prag is\n                      if Is_Entity_Name (Exp) then\n                         null;\n \n-                     --  Determine the string type from the presence\n-                     --  Wide (_Wide) characters.\n+                     --  For string literals, we assume Standard_String as the\n+                     --  type, unless the string contains wide or wide_wide\n+                     --  characters.\n \n                      elsif Nkind (Exp) = N_String_Literal then\n                         if Has_Wide_Wide_Character (Exp) then\n                            Resolve (Exp, Standard_Wide_Wide_String);\n-\n                         elsif Has_Wide_Character (Exp) then\n                            Resolve (Exp, Standard_Wide_String);\n-\n                         else\n                            Resolve (Exp, Standard_String);\n                         end if;"}, {"sha": "5af4299e88c56d1b37b1319f5bdf683e0efd4666", "filename": "gcc/ada/sysdep.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fsysdep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd34478e30a770aa741cf345f08278090770ded/gcc%2Fada%2Fsysdep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsysdep.c?ref=ebd34478e30a770aa741cf345f08278090770ded", "patch": "@@ -37,7 +37,7 @@\n #if ! defined (__VXWORKSMILS__)\n #include \"dosFsLib.h\"\n #endif\n-#if ! defined (__RTP__) && ! defined (VTHREADS)\n+#if ! defined (__RTP__) && (! defined (VTHREADS) || defined (__VXWORKSMILS__))\n # include \"nfsLib.h\"\n #endif\n #include \"selectLib.h\"\n@@ -990,7 +990,7 @@ __gnat_is_file_not_found_error (int errno_val) {\n #if ! defined (__VXWORKSMILS__)\n       case S_dosFsLib_FILE_NOT_FOUND:\n #endif\n-#if ! defined (__RTP__) && ! defined (VTHREADS)\n+#if ! defined (__RTP__) && (! defined (VTHREADS) || defined (__VXWORKSMILS__))\n       case S_nfsLib_NFSERR_NOENT:\n #endif\n #endif"}]}