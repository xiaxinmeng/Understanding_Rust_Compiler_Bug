{"sha": "7660e67ec675e809eb65f7c0337172c9b7cc1df3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY2MGU2N2VjNjc1ZTgwOWViNjVmN2MwMzM3MTcyYzliN2NjMWRmMw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2003-05-12T09:46:25Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2003-05-12T09:46:25Z"}, "message": "cgraphunit.c (cgraph_create_edges): Drop walk_tree in favor of walk_tree_without_duplicates.\n\n2003-05-10  Steven Bosscher  <steven@gcc.gnu.org>\n\n\t* cgraphunit.c (cgraph_create_edges): Drop walk_tree in\n\tfavor of walk_tree_without_duplicates.  Add comments.\n\nFrom-SVN: r66712", "tree": {"sha": "9a89831e027520254aa69db4a0236a7f5148425c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a89831e027520254aa69db4a0236a7f5148425c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7660e67ec675e809eb65f7c0337172c9b7cc1df3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7660e67ec675e809eb65f7c0337172c9b7cc1df3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7660e67ec675e809eb65f7c0337172c9b7cc1df3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7660e67ec675e809eb65f7c0337172c9b7cc1df3/comments", "author": null, "committer": null, "parents": [{"sha": "76abd4c674a0278f0d75f7bb635f89bf17c3b91a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76abd4c674a0278f0d75f7bb635f89bf17c3b91a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76abd4c674a0278f0d75f7bb635f89bf17c3b91a"}], "stats": {"total": 79, "additions": 55, "deletions": 24}, "files": [{"sha": "82ddb33172be3860816ef8e2d39eddb0ea99bac9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7660e67ec675e809eb65f7c0337172c9b7cc1df3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7660e67ec675e809eb65f7c0337172c9b7cc1df3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7660e67ec675e809eb65f7c0337172c9b7cc1df3", "patch": "@@ -1,3 +1,8 @@\n+2003-05-10  Steven Bosscher  <steven@gcc.gnu.org> \n+\n+\t* cgraphunit.c (cgraph_create_edges): Drop walk_tree in\n+\tfavor of walk_tree_without_duplicates.  Add comments.\n+\n 2003-05-12  Josef Zlomek  <zlomekj@suse.cz>\n \n \t* alloc-pool.h (ALLOC_POOL_ID_TYPE): New type."}, {"sha": "a306908ac8e4fd4708735d0d96aee81a5135e6da", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 50, "deletions": 24, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7660e67ec675e809eb65f7c0337172c9b7cc1df3/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7660e67ec675e809eb65f7c0337172c9b7cc1df3/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=7660e67ec675e809eb65f7c0337172c9b7cc1df3", "patch": "@@ -68,6 +68,7 @@ static struct cgraph_node *queue = NULL;\n \n /* Notify finalize_compilation_unit that given node is reachable\n    or needed.  */\n+\n void\n cgraph_mark_needed_node (node, needed)\n      struct cgraph_node *node;\n@@ -107,6 +108,11 @@ record_call_1 (tp, walk_subtrees, data)\n     }\n   else if (TREE_CODE (*tp) == CALL_EXPR)\n     {\n+      /* We cannot use get_callee_fndecl here because it actually tries\n+\t too hard to get the function declaration, looking for indirect\n+\t references and stripping NOPS.  As a result, get_callee_fndecl\n+\t finds calls that shouldn't be in the call graph.  */\n+\n       tree decl = TREE_OPERAND (*tp, 0);\n       if (TREE_CODE (decl) == ADDR_EXPR)\n \tdecl = TREE_OPERAND (decl, 0);\n@@ -115,21 +121,31 @@ record_call_1 (tp, walk_subtrees, data)\n \t  if (DECL_BUILT_IN (decl))\n \t    return NULL;\n \t  cgraph_record_call (data, decl);\n+\t     \n+\t  /* When we see a function call, we don't want to look at the\n+\t     function reference in the ADDR_EXPR that is hanging from\n+\t     the CALL_EXPR we're examining here, because we would\n+\t     conclude incorrectly that the function's address could be\n+\t     taken by something that is not a function call.  So only\n+\t     walk the function parameter list, skip the other subtrees.  */\n+\n \t  walk_tree (&TREE_OPERAND (*tp, 1), record_call_1, data, NULL);\n \t  *walk_subtrees = 0;\n \t}\n     }\n   return NULL;\n }\n \n-/* Create cgraph edges for function calles via BODY.  */\n+/* Create cgraph edges for function calls inside BODY from DECL.  */\n \n void\n cgraph_create_edges (decl, body)\n      tree decl;\n      tree body;\n {\n-  walk_tree (&body, record_call_1, decl, NULL);\n+  /* The nodes we're interested in are never shared, so walk\n+     the tree ignoring duplicates.  */\n+  walk_tree_without_duplicates (&body, record_call_1, decl);\n }\n \n /* Analyze the whole compilation unit once it is parsed completely.  */\n@@ -155,14 +171,16 @@ cgraph_finalize_compilation_unit ()\n \t  || (DECL_ASSEMBLER_NAME_SET_P (decl)\n \t      && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n \t{\n-          cgraph_mark_needed_node (node, 1);\n+\t  /* This function can be called from outside this compliation\n+\t     unit, so it most definitely is needed.  */\n+\t  cgraph_mark_needed_node (node, 1);\n \t}\n     }\n \n-  /*  Propagate reachability flag and lower representation of all reachable\n-      functions.  In the future, lowering will introduce new functions and\n-      new entry points on the way (by template instantiation and virtual\n-      method table generation for instance).  */\n+  /* Propagate reachability flag and lower representation of all reachable\n+     functions.  In the future, lowering will introduce new functions and\n+     new entry points on the way (by template instantiation and virtual\n+     method table generation for instance).  */\n   while (queue)\n     {\n       tree decl = queue->decl;\n@@ -184,6 +202,7 @@ cgraph_finalize_compilation_unit ()\n \n       if (lang_hooks.callgraph.lower_function)\n \t(*lang_hooks.callgraph.lower_function) (decl);\n+\n       /* First kill forward declaration so reverse inling works properly.  */\n       cgraph_create_edges (decl, DECL_SAVED_TREE (decl));\n \n@@ -194,6 +213,7 @@ cgraph_finalize_compilation_unit ()\n \t}\n       node->lowered = true;\n     }\n+\n   if (!quiet_flag)\n     fprintf (stderr, \"\\n\\nReclaiming functions:\");\n \n@@ -217,11 +237,13 @@ cgraph_mark_functions_to_output ()\n {\n   struct cgraph_node *node;\n \n-  /* Figure out functions we want to assemble.  */\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       tree decl = node->decl;\n \n+      /* We need to output all local functions that are used and not\n+\t always inlined, as well as those that are reachable from\n+\t outside the current compilation unit.  */\n       if (DECL_SAVED_TREE (decl)\n \t  && (node->needed\n \t      || (!node->local.inline_many && !node->global.inline_once\n@@ -234,6 +256,7 @@ cgraph_mark_functions_to_output ()\n }\n \n /* Optimize the function before expansion.  */\n+\n static void\n cgraph_optimize_function (node)\n      struct cgraph_node *node;\n@@ -250,6 +273,7 @@ cgraph_optimize_function (node)\n }\n \n /* Expand function specified by NODE.  */\n+\n static void\n cgraph_expand_function (node)\n      struct cgraph_node *node;\n@@ -260,11 +284,12 @@ cgraph_expand_function (node)\n \n   cgraph_optimize_function (node);\n \n-  /* Avoid RTL inlining from taking place.  */\n+  /* Generate RTL for the body of DECL.  Nested functions are expanded\n+     via lang_expand_decl_stmt.  */\n   (*lang_hooks.callgraph.expand_function) (decl);\n \n-  /* When we decided to inline the function once, we never ever should need to\n-     output it separately.  */\n+  /* When we decided to inline the function once, we never ever should\n+     need to output it separately.  */\n   if (node->global.inline_once)\n     abort ();\n   if (!node->local.inline_many\n@@ -277,11 +302,12 @@ cgraph_expand_function (node)\n /* Expand all functions that must be output. \n   \n    Attempt to topologically sort the nodes so function is output when\n-   all called functions are already assembled to allow data to be propagated\n-   accross the callgraph.  Use stack to get smaller distance between function\n-   and it's callees (later we may use more sophisticated algorithm for\n-   function reordering, we will likely want to use subsections to make output\n-   functions to appear in top-down order, not bottom-up they are assembled).  */\n+   all called functions are already assembled to allow data to be\n+   propagated accross the callgraph.  Use a stack to get smaller distance\n+   between a function and it's callees (later we may choose to use a more\n+   sophisticated algorithm for function reordering; we will likely want\n+   to use subsections to make the output functions appear in top-down\n+   order.  */\n \n static void\n cgraph_expand_functions ()\n@@ -298,10 +324,10 @@ cgraph_expand_functions ()\n \n   cgraph_mark_functions_to_output ();\n \n-  /*  We have to deal with cycles nicely, so use depth first traversal\n-      algorithm.  Ignore the fact that some functions won't need to be output\n-      and put them into order as well, so we get dependencies right trought inlined\n-      functions.  */\n+  /* We have to deal with cycles nicely, so use a depth first traversal\n+     output algorithm.  Ignore the fact that some functions won't need\n+     to be output and put them into order as well, so we get dependencies\n+     right through intline functions.  */\n   for (node = cgraph_nodes; node; node = node->next)\n     node->aux = NULL;\n   for (node = cgraph_nodes; node; node = node->next)\n@@ -380,8 +406,8 @@ cgraph_mark_local_functions ()\n     }\n }\n \n-/*  Decide what function should be inlined because they are invoked once\n-    (so inlining won't result in duplication of the code).  */\n+/* Decide what function should be inlined because they are invoked once\n+   (so inlining won't result in duplication of the code).  */\n \n static void\n cgraph_mark_functions_to_inline_once ()\n@@ -391,8 +417,8 @@ cgraph_mark_functions_to_inline_once ()\n   if (!quiet_flag)\n     fprintf (stderr, \"\\n\\nMarking functions to inline once:\");\n \n-  /* Now look for function called only once and mark them to inline.  From this\n-     point number of calls to given function won't grow.  */\n+  /* Now look for function called only once and mark them to inline.\n+     From this point number of calls to given function won't grow.  */\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       if (node->callers && !node->callers->next_caller && !node->needed"}]}