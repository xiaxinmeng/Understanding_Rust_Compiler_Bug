{"sha": "f83adb68ed9cef1fbd4c16447eb4e89676df9f62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgzYWRiNjhlZDljZWYxZmJkNGMxNjQ0N2ViNGU4OTY3NmRmOWY2Mg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-04-18T10:22:21Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-04-18T10:23:10Z"}, "message": "c++: spec_hasher::equal and PARM_DECLs [PR94632]\n\nIn the testcase below, during specialization of c<int>::d, we build two\nidentical specializations of the parameter type b<decltype(e)::k> -- one when\nsubstituting into c<int>::d's TYPE_ARG_TYPES and another when substituting into\nc<int>::d's DECL_ARGUMENTS.\n\nWe don't reuse the first specialization the second time around as a consequence\nof the fix for PR c++/56247 which made PARM_DECLs always compare different from\none another during spec_hasher::equal.  As a result, when looking up existing\nspecializations of 'b', spec_hasher::equal considers the template argument\ndecltype(e')::k to be different from decltype(e'')::k, where e' and e'' are the\nresult of two calls to tsubst_copy on the PARM_DECL e.\n\nSince the two specializations are considered different due to the mentioned fix,\ntheir TYPE_CANONICAL points to themselves even though they are otherwise\nidentical types, and this triggers an ICE in maybe_rebuild_function_decl_type\nwhen comparing the TYPE_ARG_TYPES of c<int>::d to its DECL_ARGUMENTS.\n\nThis patch fixes this issue at the spec_hasher::equal level by ignoring the\n'comparing_specializations' flag in cp_tree_equal whenever the DECL_CONTEXTs of\nthe two parameters are identical.  This seems to be a sufficient condition to be\nable to correctly compare PARM_DECLs structurally.  (This also subsumes the\nCONSTRAINT_VAR_P check since constraint variables all have empty, and therefore\nidentical, DECL_CONTEXTs.)\n\ngcc/cp/ChangeLog:\n\n\tPR c++/94632\n\t* tree.c (cp_tree_equal) <case PARM_DECL>: Ignore\n\tcomparing_specializations if the parameters' contexts are identical.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/94632\n\t* g++.dg/template/canon-type-14.C: New test.", "tree": {"sha": "97bb61c32c64d9d0a95801581efccfae9a5b7831", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97bb61c32c64d9d0a95801581efccfae9a5b7831"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f83adb68ed9cef1fbd4c16447eb4e89676df9f62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f83adb68ed9cef1fbd4c16447eb4e89676df9f62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f83adb68ed9cef1fbd4c16447eb4e89676df9f62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f83adb68ed9cef1fbd4c16447eb4e89676df9f62/comments", "author": null, "committer": null, "parents": [{"sha": "e43b28ae7f09c0b7a30ab0dd976db761eeb1b0f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e43b28ae7f09c0b7a30ab0dd976db761eeb1b0f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e43b28ae7f09c0b7a30ab0dd976db761eeb1b0f9"}], "stats": {"total": 20, "additions": 18, "deletions": 2}, "files": [{"sha": "9533cca713702cc3213e3ec4544343b23f117c02", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f83adb68ed9cef1fbd4c16447eb4e89676df9f62/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f83adb68ed9cef1fbd4c16447eb4e89676df9f62/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f83adb68ed9cef1fbd4c16447eb4e89676df9f62", "patch": "@@ -1,5 +1,9 @@\n 2020-04-18  Patrick Palka  <ppalka@redhat.com>\n \n+\tPR c++/94632\n+\t* tree.c (cp_tree_equal) <case PARM_DECL>: Ignore\n+\tcomparing_specializations if the parameters' contexts are identical.\n+\n \tPR c++/92187\n \t* pt.c (splice_late_return_type): Propagate cv-qualifiers and\n \tPLACEHOLDER_TYPE_CONSTRAINTS from the original auto node to the new one."}, {"sha": "dc4f1f48d3c5cd6eae4f9bc5207d72286c517ab4", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f83adb68ed9cef1fbd4c16447eb4e89676df9f62/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f83adb68ed9cef1fbd4c16447eb4e89676df9f62/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=f83adb68ed9cef1fbd4c16447eb4e89676df9f62", "patch": "@@ -3723,11 +3723,12 @@ cp_tree_equal (tree t1, tree t2)\n \t up for expressions that involve 'this' in a member function\n \t template.  */\n \n-      if (comparing_specializations && !CONSTRAINT_VAR_P (t1))\n+      if (comparing_specializations\n+\t  && DECL_CONTEXT (t1) != DECL_CONTEXT (t2))\n \t/* When comparing hash table entries, only an exact match is\n \t   good enough; we don't want to replace 'this' with the\n \t   version from another function.  But be more flexible\n-\t   with local parameters in a requires-expression.  */\n+\t   with parameters with identical contexts.  */\n \treturn false;\n \n       if (same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))"}, {"sha": "a41cc03f6fa2b1761618c62c9a8b9995737d5cac", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f83adb68ed9cef1fbd4c16447eb4e89676df9f62/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f83adb68ed9cef1fbd4c16447eb4e89676df9f62/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f83adb68ed9cef1fbd4c16447eb4e89676df9f62", "patch": "@@ -1,5 +1,8 @@\n 2020-04-18  Patrick Palka  <ppalka@redhat.com>\n \n+\tPR c++/94632\n+\t* g++.dg/template/canon-type-14.C: New test.\n+\n \tPR c++/92187\n \t* g++.dg/concepts/abbrev5.C: New test.\n \t* g++.dg/concepts/abbrev6.C: New test."}, {"sha": "fa05bdb9a74eda233ce0b436abad3e5b05a3f598", "filename": "gcc/testsuite/g++.dg/template/canon-type-14.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f83adb68ed9cef1fbd4c16447eb4e89676df9f62/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcanon-type-14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f83adb68ed9cef1fbd4c16447eb4e89676df9f62/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcanon-type-14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcanon-type-14.C?ref=f83adb68ed9cef1fbd4c16447eb4e89676df9f62", "patch": "@@ -0,0 +1,8 @@\n+// PR c++/94632\n+// { dg-do compile { target c++11 } }\n+\n+template <bool> struct b;\n+template <typename> class c {\n+  template <typename f> static void d(f e, b<decltype(e)::k>);\n+};\n+template class c<int>;"}]}