{"sha": "3814652309edac1154ee3c7e40ff65ff861d17f3", "node_id": "C_kwDOANBUbNoAKDM4MTQ2NTIzMDllZGFjMTE1NGVlM2M3ZTQwZmY2NWZmODYxZDE3ZjM", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2021-11-30T14:11:32Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-01-05T11:32:35Z"}, "message": "[Ada] Proof of runtime units for integer exponentiation (checks on)\n\ngcc/ada/\n\n\t* libgnat/s-expint.ads: Mark in SPARK. Adapt to change to\n\tpackage.\n\t* libgnat/s-explli.ads: Likewise.\n\t* libgnat/s-expllli.ads: Likewise.\n\t* libgnat/s-expont.adb: Add lemmas and ghost code.\n\t* libgnat/s-expont.ads: Add functional contract.", "tree": {"sha": "29548a7b4dc8172b97ada4a08ec366c955150414", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29548a7b4dc8172b97ada4a08ec366c955150414"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3814652309edac1154ee3c7e40ff65ff861d17f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3814652309edac1154ee3c7e40ff65ff861d17f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3814652309edac1154ee3c7e40ff65ff861d17f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3814652309edac1154ee3c7e40ff65ff861d17f3/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1702fb6bf95de5461f896cf69832edc0e2e40cc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1702fb6bf95de5461f896cf69832edc0e2e40cc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1702fb6bf95de5461f896cf69832edc0e2e40cc5"}], "stats": {"total": 287, "additions": 261, "deletions": 26}, "files": [{"sha": "b44cae5535da47aa59487019220fd677ae70331d", "filename": "gcc/ada/libgnat/s-expint.ads", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3814652309edac1154ee3c7e40ff65ff861d17f3/gcc%2Fada%2Flibgnat%2Fs-expint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3814652309edac1154ee3c7e40ff65ff861d17f3/gcc%2Fada%2Flibgnat%2Fs-expint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-expint.ads?ref=3814652309edac1154ee3c7e40ff65ff861d17f3", "patch": "@@ -31,11 +31,26 @@\n \n --  Integer exponentiation (checks on)\n \n+--  Preconditions, postconditions, ghost code, loop invariants and assertions\n+--  in this unit are meant for analysis only, not for run-time checking, as it\n+--  would be too costly otherwise. This is enforced by setting the assertion\n+--  policy to Ignore.\n+\n+pragma Assertion_Policy (Pre            => Ignore,\n+                         Post           => Ignore,\n+                         Ghost          => Ignore,\n+                         Loop_Invariant => Ignore,\n+                         Assert         => Ignore);\n+\n with System.Expont;\n \n-package System.Exp_Int is\n+package System.Exp_Int\n+  with SPARK_Mode\n+is\n+\n+   package Expont_Integer is new Expont (Integer);\n \n-   function Exp_Integer is new Expont (Integer);\n-   pragma Pure_Function (Exp_Integer);\n+   function Exp_Integer (Left : Integer; Right : Natural) return Integer\n+     renames Expont_Integer.Expon;\n \n end System.Exp_Int;"}, {"sha": "ebf579473e3f66d09ceeb994c5e15547fe955adf", "filename": "gcc/ada/libgnat/s-explli.ads", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3814652309edac1154ee3c7e40ff65ff861d17f3/gcc%2Fada%2Flibgnat%2Fs-explli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3814652309edac1154ee3c7e40ff65ff861d17f3/gcc%2Fada%2Flibgnat%2Fs-explli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-explli.ads?ref=3814652309edac1154ee3c7e40ff65ff861d17f3", "patch": "@@ -31,11 +31,27 @@\n \n --  Long_Long_Integer exponentiation (checks on)\n \n+--  Preconditions, postconditions, ghost code, loop invariants and assertions\n+--  in this unit are meant for analysis only, not for run-time checking, as it\n+--  would be too costly otherwise. This is enforced by setting the assertion\n+--  policy to Ignore.\n+\n+pragma Assertion_Policy (Pre            => Ignore,\n+                         Post           => Ignore,\n+                         Ghost          => Ignore,\n+                         Loop_Invariant => Ignore,\n+                         Assert         => Ignore);\n+\n with System.Expont;\n \n-package System.Exp_LLI is\n+package System.Exp_LLI\n+  with SPARK_Mode\n+is\n+\n+   package Expont_Integer is new Expont (Long_Long_Integer);\n \n-   function Exp_Long_Long_Integer is new Expont (Long_Long_Integer);\n-   pragma Pure_Function (Exp_Long_Long_Integer);\n+   function Exp_Long_Long_Integer\n+     (Left : Long_Long_Integer; Right : Natural) return Long_Long_Integer\n+     renames Expont_Integer.Expon;\n \n end System.Exp_LLI;"}, {"sha": "3c009bcac9400b65cda5016504c1ceeff5abfb93", "filename": "gcc/ada/libgnat/s-expllli.ads", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3814652309edac1154ee3c7e40ff65ff861d17f3/gcc%2Fada%2Flibgnat%2Fs-expllli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3814652309edac1154ee3c7e40ff65ff861d17f3/gcc%2Fada%2Flibgnat%2Fs-expllli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-expllli.ads?ref=3814652309edac1154ee3c7e40ff65ff861d17f3", "patch": "@@ -31,11 +31,28 @@\n \n --  Long_Long_Long_Integer exponentiation (checks on)\n \n+--  Preconditions, postconditions, ghost code, loop invariants and assertions\n+--  in this unit are meant for analysis only, not for run-time checking, as it\n+--  would be too costly otherwise. This is enforced by setting the assertion\n+--  policy to Ignore.\n+\n+pragma Assertion_Policy (Pre            => Ignore,\n+                         Post           => Ignore,\n+                         Ghost          => Ignore,\n+                         Loop_Invariant => Ignore,\n+                         Assert         => Ignore);\n+\n with System.Expont;\n \n-package System.Exp_LLLI is\n+package System.Exp_LLLI\n+  with SPARK_Mode\n+is\n+\n+   package Expont_Integer is new Expont (Long_Long_Long_Integer);\n \n-   function Exp_Long_Long_Long_Integer is new Expont (Long_Long_Long_Integer);\n-   pragma Pure_Function (Exp_Long_Long_Long_Integer);\n+   function Exp_Long_Long_Long_Integer\n+     (Left : Long_Long_Long_Integer; Right : Natural)\n+      return Long_Long_Long_Integer\n+     renames Expont_Integer.Expon;\n \n end System.Exp_LLLI;"}, {"sha": "dc1586b4c2313a83f98d5f6baacae84dad10c8ce", "filename": "gcc/ada/libgnat/s-expont.adb", "status": "modified", "additions": 170, "deletions": 16, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3814652309edac1154ee3c7e40ff65ff861d17f3/gcc%2Fada%2Flibgnat%2Fs-expont.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3814652309edac1154ee3c7e40ff65ff861d17f3/gcc%2Fada%2Flibgnat%2Fs-expont.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-expont.adb?ref=3814652309edac1154ee3c7e40ff65ff861d17f3", "patch": "@@ -29,44 +29,198 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-function System.Expont (Left : Int; Right : Natural) return Int is\n+package body System.Expont\n+  with SPARK_Mode\n+is\n \n-   --  Note that negative exponents get a constraint error because the\n-   --  subtype of the Right argument (the exponent) is Natural.\n+   --  Preconditions, postconditions, ghost code, loop invariants and\n+   --  assertions in this unit are meant for analysis only, not for run-time\n+   --  checking, as it would be too costly otherwise. This is enforced by\n+   --  setting the assertion policy to Ignore.\n \n-   Result : Int     := 1;\n-   Factor : Int     := Left;\n-   Exp    : Natural := Right;\n+   pragma Assertion_Policy (Pre            => Ignore,\n+                            Post           => Ignore,\n+                            Ghost          => Ignore,\n+                            Loop_Invariant => Ignore,\n+                            Assert         => Ignore);\n \n-begin\n-   --  We use the standard logarithmic approach, Exp gets shifted right\n-   --  testing successive low order bits and Factor is the value of the\n-   --  base raised to the next power of 2.\n+   --  Local lemmas\n \n-   --  Note: it is not worth special casing base values -1, 0, +1 since\n-   --  the expander does this when the base is a literal, and other cases\n-   --  will be extremely rare.\n+   procedure Lemma_Exp_Expand (A : Big_Integer; Exp : Natural)\n+   with\n+     Ghost,\n+     Pre  => A /= 0,\n+     Post =>\n+       (if Exp rem 2 = 0 then\n+          A ** Exp = A ** (Exp / 2) * A ** (Exp / 2)\n+        else\n+          A ** Exp = A ** (Exp / 2) * A ** (Exp / 2) * A);\n+\n+   procedure Lemma_Exp_In_Range (A : Big_Integer; Exp : Positive)\n+   with\n+     Ghost,\n+     Pre  => In_Int_Range (A ** Exp * A ** Exp),\n+     Post => In_Int_Range (A * A);\n+\n+   procedure Lemma_Exp_Not_Zero (A : Big_Integer; Exp : Natural)\n+   with\n+     Ghost,\n+     Pre  => A /= 0,\n+     Post => A ** Exp /= 0;\n+\n+   procedure Lemma_Exp_Positive (A : Big_Integer; Exp : Natural)\n+   with\n+     Ghost,\n+     Pre  => A /= 0\n+       and then Exp rem 2 = 0,\n+     Post => A ** Exp > 0;\n+\n+   procedure Lemma_Mult_In_Range (X, Y, Z : Big_Integer)\n+   with\n+     Ghost,\n+     Pre  => Y /= 0\n+       and then not (X = -Big (Int'First) and Y = -1)\n+       and then X * Y = Z\n+       and then In_Int_Range (Z),\n+     Post => In_Int_Range (X);\n+\n+   -----------------------------\n+   -- Local lemma null bodies --\n+   -----------------------------\n+\n+   procedure Lemma_Exp_Not_Zero (A : Big_Integer; Exp : Natural) is null;\n+   procedure Lemma_Mult_In_Range (X, Y, Z : Big_Integer) is null;\n+\n+   -----------\n+   -- Expon --\n+   -----------\n+\n+   function Expon (Left : Int; Right : Natural) return Int is\n+\n+      --  Note that negative exponents get a constraint error because the\n+      --  subtype of the Right argument (the exponent) is Natural.\n+\n+      Result : Int     := 1;\n+      Factor : Int     := Left;\n+      Exp    : Natural := Right;\n+\n+      Rest : Big_Integer with Ghost;\n+      --  Ghost variable to hold Factor**Exp between Exp and Factor updates\n+\n+   begin\n+      --  We use the standard logarithmic approach, Exp gets shifted right\n+      --  testing successive low order bits and Factor is the value of the\n+      --  base raised to the next power of 2.\n+\n+      --  Note: for compilation only, it is not worth special casing base\n+      --  values -1, 0, +1 since the expander does this when the base is a\n+      --  literal, and other cases will be extremely rare. But for proof,\n+      --  special casing zero in both positions makes ghost code and lemmas\n+      --  simpler, so we do it.\n+\n+      if Right = 0 then\n+         return 1;\n+      elsif Left = 0 then\n+         return 0;\n+      end if;\n \n-   if Exp /= 0 then\n       loop\n+         pragma Loop_Invariant (Exp > 0);\n+         pragma Loop_Invariant (Factor /= 0);\n+         pragma Loop_Invariant\n+           (Big (Result) * Big (Factor) ** Exp = Big (Left) ** Right);\n+         pragma Loop_Variant (Decreases => Exp);\n+         pragma Annotate\n+           (CodePeer, False_Positive,\n+            \"validity check\", \"confusion on generated code\");\n+\n          if Exp rem 2 /= 0 then\n             declare\n                pragma Unsuppress (Overflow_Check);\n             begin\n+               pragma Assert\n+                 (Big (Factor) ** Exp\n+                  = Big (Factor) * Big (Factor) ** (Exp - 1));\n+               Lemma_Exp_Positive (Big (Factor), Exp - 1);\n+               Lemma_Mult_In_Range (Big (Result) * Big (Factor),\n+                                    Big (Factor) ** (Exp - 1),\n+                                    Big (Left) ** Right);\n+\n                Result := Result * Factor;\n             end;\n          end if;\n \n+         Lemma_Exp_Expand (Big (Factor), Exp);\n+\n          Exp := Exp / 2;\n          exit when Exp = 0;\n \n+         Rest := Big (Factor) ** Exp;\n+         pragma Assert\n+           (Big (Result) * (Rest * Rest) = Big (Left) ** Right);\n+\n          declare\n             pragma Unsuppress (Overflow_Check);\n          begin\n+            Lemma_Mult_In_Range (Rest * Rest,\n+                                 Big (Result),\n+                                 Big (Left) ** Right);\n+            Lemma_Exp_In_Range (Big (Factor), Exp);\n+\n             Factor := Factor * Factor;\n          end;\n+\n+         pragma Assert (Big (Factor) ** Exp = Rest * Rest);\n       end loop;\n-   end if;\n \n-   return Result;\n+      pragma Assert (Big (Result) = Big (Left) ** Right);\n+\n+      return Result;\n+   end Expon;\n+\n+   ----------------------\n+   -- Lemma_Exp_Expand --\n+   ----------------------\n+\n+   procedure Lemma_Exp_Expand (A : Big_Integer; Exp : Natural) is\n+   begin\n+      if Exp rem 2 = 0 then\n+         pragma Assert (Exp = Exp / 2 + Exp / 2);\n+      else\n+         pragma Assert (Exp = Exp / 2 + Exp / 2 + 1);\n+         pragma Assert (A ** Exp = A ** (Exp / 2) * A ** (Exp / 2 + 1));\n+         pragma Assert (A ** (Exp / 2 + 1) = A ** (Exp / 2) * A);\n+         pragma Assert (A ** Exp = A ** (Exp / 2) * A ** (Exp / 2) * A);\n+      end if;\n+   end Lemma_Exp_Expand;\n+\n+   ------------------------\n+   -- Lemma_Exp_In_Range --\n+   ------------------------\n+\n+   procedure Lemma_Exp_In_Range (A : Big_Integer; Exp : Positive) is\n+   begin\n+      if A /= 0 and Exp /= 1 then\n+         pragma Assert (A ** Exp = A * A ** (Exp - 1));\n+         Lemma_Mult_In_Range\n+           (A * A, A ** (Exp - 1) * A ** (Exp - 1), A ** Exp * A ** Exp);\n+      end if;\n+   end Lemma_Exp_In_Range;\n+\n+   ------------------------\n+   -- Lemma_Exp_Positive --\n+   ------------------------\n+\n+   procedure Lemma_Exp_Positive (A : Big_Integer; Exp : Natural) is\n+   begin\n+      if Exp = 0 then\n+         pragma Assert (A ** Exp = 1);\n+      else\n+         pragma Assert (Exp = 2 * (Exp / 2));\n+         pragma Assert (A ** Exp = A ** (Exp / 2) * A ** (Exp / 2));\n+         pragma Assert (A ** Exp = (A ** (Exp / 2)) ** 2);\n+         Lemma_Exp_Not_Zero (A, Exp / 2);\n+      end if;\n+   end Lemma_Exp_Positive;\n+\n end System.Expont;"}, {"sha": "4a62b186af145ed8d5dc04c3ab4bb60840078e37", "filename": "gcc/ada/libgnat/s-expont.ads", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3814652309edac1154ee3c7e40ff65ff861d17f3/gcc%2Fada%2Flibgnat%2Fs-expont.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3814652309edac1154ee3c7e40ff65ff861d17f3/gcc%2Fada%2Flibgnat%2Fs-expont.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-expont.ads?ref=3814652309edac1154ee3c7e40ff65ff861d17f3", "patch": "@@ -31,8 +31,41 @@\n \n --  Signed integer exponentiation (checks on)\n \n+with Ada.Numerics.Big_Numbers.Big_Integers_Ghost;\n+use Ada.Numerics.Big_Numbers.Big_Integers_Ghost;\n+\n generic\n \n    type Int is range <>;\n \n-function System.Expont (Left : Int; Right : Natural) return Int;\n+package System.Expont\n+  with Pure, SPARK_Mode\n+is\n+\n+   --  Preconditions in this unit are meant for analysis only, not for run-time\n+   --  checking, so that the expected exceptions are raised. This is enforced\n+   --  by setting the corresponding assertion policy to Ignore. Postconditions\n+   --  and contract cases should not be executed at runtime as well, in order\n+   --  not to slow down the execution of these functions.\n+\n+   pragma Assertion_Policy (Pre            => Ignore,\n+                            Post           => Ignore,\n+                            Contract_Cases => Ignore,\n+                            Ghost          => Ignore);\n+\n+   package Signed_Conversion is new Signed_Conversions (Int => Int);\n+\n+   function Big (Arg : Int) return Big_Integer is\n+     (Signed_Conversion.To_Big_Integer (Arg))\n+   with Ghost;\n+\n+   function In_Int_Range (Arg : Big_Integer) return Boolean is\n+     (In_Range (Arg, Big (Int'First), Big (Int'Last)))\n+   with Ghost;\n+\n+   function Expon (Left : Int; Right : Natural) return Int\n+   with\n+     Pre  => In_Int_Range (Big (Left) ** Right),\n+     Post => Expon'Result = Left ** Right;\n+\n+end System.Expont;"}]}