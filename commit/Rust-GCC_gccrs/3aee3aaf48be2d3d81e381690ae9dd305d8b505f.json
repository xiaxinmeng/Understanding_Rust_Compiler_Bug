{"sha": "3aee3aaf48be2d3d81e381690ae9dd305d8b505f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FlZTNhYWY0OGJlMmQzZDgxZTM4MTY5MGFlOWRkMzA1ZDhiNTA1Zg==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2020-06-26T16:07:58Z"}, "committer": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2020-09-08T20:26:42Z"}, "message": "openacc: Fix mkoffload SGPR/VGPR count parsing for HSACO v3\n\nIf an offload kernel uses a large number of VGPRs, AMD GCN hardware may\nneed to limit the number of threads/workers launched for that kernel.\nThe number of SGPRs/VGPRs in use is detected by mkoffload and recorded in\nthe processed output.  The patterns emitted detailing SGPR/VGPR occupancy\nchanged between HSACO v2 and v3 though, so this patch updates parsing\nto account for that.\n\n2020-09-08  Julian Brown  <julian@codesourcery.com>\n\ngcc/\n\t* config/gcn/mkoffload.c (process_asm): Initialise regcount.  Update\n\tscanning for SGPR/VGPR usage for HSACO v3.", "tree": {"sha": "64b508de14dca98f617aba45634484996b26b7cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64b508de14dca98f617aba45634484996b26b7cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3aee3aaf48be2d3d81e381690ae9dd305d8b505f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aee3aaf48be2d3d81e381690ae9dd305d8b505f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aee3aaf48be2d3d81e381690ae9dd305d8b505f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aee3aaf48be2d3d81e381690ae9dd305d8b505f/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6d9be7c6be1b88f844a49d51302d34efd919a23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6d9be7c6be1b88f844a49d51302d34efd919a23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6d9be7c6be1b88f844a49d51302d34efd919a23"}], "stats": {"total": 40, "additions": 25, "deletions": 15}, "files": [{"sha": "0983b98e178a7d4168cc92410382625cec6747f3", "filename": "gcc/config/gcn/mkoffload.c", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aee3aaf48be2d3d81e381690ae9dd305d8b505f/gcc%2Fconfig%2Fgcn%2Fmkoffload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aee3aaf48be2d3d81e381690ae9dd305d8b505f/gcc%2Fconfig%2Fgcn%2Fmkoffload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fmkoffload.c?ref=3aee3aaf48be2d3d81e381690ae9dd305d8b505f", "patch": "@@ -432,15 +432,20 @@ process_asm (FILE *in, FILE *out, FILE *cfile)\n     int sgpr_count;\n     int vgpr_count;\n     char *kernel_name;\n-  } regcount;\n+  } regcount = { -1, -1, NULL };\n \n   /* Always add _init_array and _fini_array as kernels.  */\n   obstack_ptr_grow (&fns_os, xstrdup (\"_init_array\"));\n   obstack_ptr_grow (&fns_os, xstrdup (\"_fini_array\"));\n   fn_count += 2;\n \n   char buf[1000];\n-  enum { IN_CODE, IN_AMD_KERNEL_CODE_T, IN_VARS, IN_FUNCS } state = IN_CODE;\n+  enum\n+    { IN_CODE,\n+      IN_METADATA,\n+      IN_VARS,\n+      IN_FUNCS\n+    } state = IN_CODE;\n   while (fgets (buf, sizeof (buf), in))\n     {\n       switch (state)\n@@ -453,21 +458,25 @@ process_asm (FILE *in, FILE *out, FILE *cfile)\n \t\tobstack_grow (&dims_os, &dim, sizeof (dim));\n \t\tdims_count++;\n \t      }\n-\t    else if (sscanf (buf, \" .amdgpu_hsa_kernel %ms\\n\",\n-\t\t\t     &regcount.kernel_name) == 1)\n-\t      break;\n \n \t    break;\n \t  }\n-\tcase IN_AMD_KERNEL_CODE_T:\n+\tcase IN_METADATA:\n \t  {\n-\t    gcc_assert (regcount.kernel_name);\n-\t    if (sscanf (buf, \" wavefront_sgpr_count = %d\\n\",\n-\t\t\t&regcount.sgpr_count) == 1)\n+\t    if (sscanf (buf, \" - .name: %ms\\n\", &regcount.kernel_name) == 1)\n \t      break;\n-\t    else if (sscanf (buf, \" workitem_vgpr_count = %d\\n\",\n+\t    else if (sscanf (buf, \" .sgpr_count: %d\\n\",\n+\t\t\t     &regcount.sgpr_count) == 1)\n+\t      {\n+\t\tgcc_assert (regcount.kernel_name);\n+\t\tbreak;\n+\t      }\n+\t    else if (sscanf (buf, \" .vgpr_count: %d\\n\",\n \t\t\t     &regcount.vgpr_count) == 1)\n-\t      break;\n+\t      {\n+\t\tgcc_assert (regcount.kernel_name);\n+\t\tbreak;\n+\t      }\n \n \t    break;\n \t  }\n@@ -508,9 +517,10 @@ process_asm (FILE *in, FILE *out, FILE *cfile)\n \tstate = IN_VARS;\n       else if (sscanf (buf, \" .section .gnu.offload_funcs%c\", &dummy) > 0)\n \tstate = IN_FUNCS;\n-      else if (sscanf (buf, \" .amd_kernel_code_%c\", &dummy) > 0)\n+      else if (sscanf (buf, \" .amdgpu_metadata%c\", &dummy) > 0)\n \t{\n-\t  state = IN_AMD_KERNEL_CODE_T;\n+\t  state = IN_METADATA;\n+\t  regcount.kernel_name = NULL;\n \t  regcount.sgpr_count = regcount.vgpr_count = -1;\n \t}\n       else if (sscanf (buf, \" .section %c\", &dummy) > 0\n@@ -519,7 +529,7 @@ process_asm (FILE *in, FILE *out, FILE *cfile)\n \t       || sscanf (buf, \" .data%c\", &dummy) > 0\n \t       || sscanf (buf, \" .ident %c\", &dummy) > 0)\n \tstate = IN_CODE;\n-      else if (sscanf (buf, \" .end_amd_kernel_code_%c\", &dummy) > 0)\n+      else if (sscanf (buf, \" .end_amdgpu_metadata%c\", &dummy) > 0)\n \t{\n \t  state = IN_CODE;\n \t  gcc_assert (regcount.kernel_name != NULL\n@@ -531,7 +541,7 @@ process_asm (FILE *in, FILE *out, FILE *cfile)\n \t  regcount.sgpr_count = regcount.vgpr_count = -1;\n \t}\n \n-      if (state == IN_CODE || state == IN_AMD_KERNEL_CODE_T)\n+      if (state == IN_CODE || state == IN_METADATA)\n \tfputs (buf, out);\n     }\n "}]}