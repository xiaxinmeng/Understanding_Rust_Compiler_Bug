{"sha": "efee0113e8539a1f2bbdf149534c2ac0db105a64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZlZTAxMTNlODUzOWExZjJiYmRmMTQ5NTM0YzJhYzBkYjEwNWE2NA==", "commit": {"author": {"name": "Torvald Riegel", "email": "triegel@redhat.com", "date": "2012-02-20T20:56:56Z"}, "committer": {"name": "Torvald Riegel", "email": "torvald@gcc.gnu.org", "date": "2012-02-20T20:56:56Z"}, "message": "libitm: Optimize memory order requiremens in gl_wt pre_write.\n\n\tlibtim/\n\t* method-gl.cc (gl_wt_dispatch::pre_write): Optimize memory orders.\n\nFrom-SVN: r184400", "tree": {"sha": "eecdab57a37716f23f733bcc7296e45e68124beb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eecdab57a37716f23f733bcc7296e45e68124beb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efee0113e8539a1f2bbdf149534c2ac0db105a64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efee0113e8539a1f2bbdf149534c2ac0db105a64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efee0113e8539a1f2bbdf149534c2ac0db105a64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efee0113e8539a1f2bbdf149534c2ac0db105a64/comments", "author": {"login": "triegelrh", "id": 62400967, "node_id": "MDQ6VXNlcjYyNDAwOTY3", "avatar_url": "https://avatars.githubusercontent.com/u/62400967?v=4", "gravatar_id": "", "url": "https://api.github.com/users/triegelrh", "html_url": "https://github.com/triegelrh", "followers_url": "https://api.github.com/users/triegelrh/followers", "following_url": "https://api.github.com/users/triegelrh/following{/other_user}", "gists_url": "https://api.github.com/users/triegelrh/gists{/gist_id}", "starred_url": "https://api.github.com/users/triegelrh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/triegelrh/subscriptions", "organizations_url": "https://api.github.com/users/triegelrh/orgs", "repos_url": "https://api.github.com/users/triegelrh/repos", "events_url": "https://api.github.com/users/triegelrh/events{/privacy}", "received_events_url": "https://api.github.com/users/triegelrh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "33a03827d2a95c00d5294569d428354895378026", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33a03827d2a95c00d5294569d428354895378026", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33a03827d2a95c00d5294569d428354895378026"}], "stats": {"total": 21, "additions": 18, "deletions": 3}, "files": [{"sha": "0a06bfec7f48489fe6cc58c66bff806a25e1d844", "filename": "libitm/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efee0113e8539a1f2bbdf149534c2ac0db105a64/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efee0113e8539a1f2bbdf149534c2ac0db105a64/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=efee0113e8539a1f2bbdf149534c2ac0db105a64", "patch": "@@ -1,3 +1,7 @@\n+2012-02-20  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* method-gl.cc (gl_wt_dispatch::pre_write): Optimize memory orders.\n+\n 2012-02-20  Torvald Riegel  <triegel@redhat.com>\n \n \t* method-gl.cc (gl_wt_dispatch::memtransfer_static): Add missing undo"}, {"sha": "503c19e5921929a6db7b2501b83a3a3a90bb4ed0", "filename": "libitm/method-gl.cc", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efee0113e8539a1f2bbdf149534c2ac0db105a64/libitm%2Fmethod-gl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efee0113e8539a1f2bbdf149534c2ac0db105a64/libitm%2Fmethod-gl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fmethod-gl.cc?ref=efee0113e8539a1f2bbdf149534c2ac0db105a64", "patch": "@@ -104,16 +104,27 @@ class gl_wt_dispatch : public abi_dispatch\n \t  tx->restart(RESTART_VALIDATE_WRITE);\n \n \t// CAS global orec from our snapshot time to the locked state.\n-\t// We need acq_rel memory order here to synchronize with other loads\n-\t// and modifications of orec.\n+        // We need acquire memory order here to synchronize with other\n+        // (ownership) releases of the orec.  We do not need acq_rel order\n+        // because whenever another thread reads from this CAS'\n+        // modification, then it will abort anyway and does not rely on\n+        // any further happens-before relation to be established.\n+\t// Also note that unlike in ml_wt's increase of the global time\n+\t// base (remember that the global orec is used as time base), we do\n+\t// not need require memory order here because we do not need to make\n+\t// prior orec acquisitions visible to other threads that try to\n+\t// extend their snapshot time.\n \tif (!o_gl_mg.orec.compare_exchange_strong (now, gl_mg::set_locked(now),\n-\t\t\t\t\t\t   memory_order_acq_rel))\n+\t\t\t\t\t\t   memory_order_acquire))\n \t  tx->restart(RESTART_LOCKED_WRITE);\n \n \t// We use an explicit fence here to avoid having to use release\n \t// memory order for all subsequent data stores.  This fence will\n \t// synchronize with loads of the data with acquire memory order.  See\n \t// validate() for why this is necessary.\n+        // Adding require memory order to the prior CAS is not sufficient,\n+        // at least according to the Batty et al. formalization of the\n+        // memory model.\n \tatomic_thread_fence(memory_order_release);\n \n \t// Set shared_state to new value."}]}