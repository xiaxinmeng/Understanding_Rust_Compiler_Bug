{"sha": "2084b5f42a4432da8b0625f9c669bf690ec46468", "node_id": "C_kwDOANBUbNoAKDIwODRiNWY0MmE0NDMyZGE4YjA2MjVmOWM2NjliZjY5MGVjNDY0Njg", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-10-27T07:22:07Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-10-27T07:22:07Z"}, "message": "openmp: Allow non-rectangular loops with pointer iterators\n\nThis patch handles pointer iterators for non-rectangular loops.  They are\nmore limited than integral iterators of non-rectangular loops, in particular\nonly var-outer, var-outer + a2, a2 + var-outer or var-outer - a2 can appear\nin lb or ub where a2 is some integral loop invariant expression, so no e.g.\nmultiplication etc.\n\n2021-10-27  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/\n\t* omp-expand.c (expand_omp_for_init_counts): Handle non-rectangular\n\titerators with pointer types.\n\t(expand_omp_for_init_vars, extract_omp_for_update_vars): Likewise.\ngcc/c-family/\n\t* c-omp.c (c_omp_check_loop_iv_r): Don't clear 3rd bit for\n\tPOINTER_PLUS_EXPR.\n\t(c_omp_check_nonrect_loop_iv): Handle POINTER_PLUS_EXPR.\n\t(c_omp_check_loop_iv): Set kind even if the iterator is non-integral.\ngcc/testsuite/\n\t* c-c++-common/gomp/loop-8.c: New test.\n\t* c-c++-common/gomp/loop-9.c: New test.\nlibgomp/\n\t* testsuite/libgomp.c/loop-26.c: New test.\n\t* testsuite/libgomp.c/loop-27.c: New test.", "tree": {"sha": "b600a0ba8491e143aec0a29d2b0a761a02673917", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b600a0ba8491e143aec0a29d2b0a761a02673917"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2084b5f42a4432da8b0625f9c669bf690ec46468", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2084b5f42a4432da8b0625f9c669bf690ec46468", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2084b5f42a4432da8b0625f9c669bf690ec46468", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2084b5f42a4432da8b0625f9c669bf690ec46468/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b0f35299bd1468ebc13b900a73b7cac6181a2aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b0f35299bd1468ebc13b900a73b7cac6181a2aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b0f35299bd1468ebc13b900a73b7cac6181a2aa"}], "stats": {"total": 608, "additions": 562, "deletions": 46}, "files": [{"sha": "fad060670b65f359e59955fcf3bd3a1beb9376bc", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2084b5f42a4432da8b0625f9c669bf690ec46468/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2084b5f42a4432da8b0625f9c669bf690ec46468/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=2084b5f42a4432da8b0625f9c669bf690ec46468", "patch": "@@ -1358,6 +1358,7 @@ c_omp_check_loop_iv_r (tree *tp, int *walk_subtrees, void *data)\n \t   && TREE_CODE (*tp) != PLUS_EXPR\n \t   && TREE_CODE (*tp) != MINUS_EXPR\n \t   && TREE_CODE (*tp) != MULT_EXPR\n+\t   && TREE_CODE (*tp) != POINTER_PLUS_EXPR\n \t   && !CONVERT_EXPR_P (*tp))\n     {\n       *walk_subtrees = 0;\n@@ -1477,6 +1478,18 @@ c_omp_check_nonrect_loop_iv (tree *tp, struct c_omp_check_loop_iv_data *d,\n \t}\n       a2 = integer_zero_node;\n       break;\n+    case POINTER_PLUS_EXPR:\n+      a1 = TREE_OPERAND (t, 0);\n+      a2 = TREE_OPERAND (t, 1);\n+      while (CONVERT_EXPR_P (a1))\n+\ta1 = TREE_OPERAND (a1, 0);\n+      if (DECL_P (a1) && c_omp_is_loop_iterator (a1, d) >= 0)\n+\t{\n+\t  a2 = TREE_OPERAND (t, 1);\n+\t  t = a1;\n+\t  break;\n+\t}\n+      break;\n     default:\n       break;\n     }\n@@ -1599,10 +1612,7 @@ c_omp_check_loop_iv (tree stmt, tree declv, walk_tree_lh lh)\n \t  data.fail = true;\n \t}\n       /* Handle non-rectangular loop nests.  */\n-      if (TREE_CODE (stmt) != OACC_LOOP\n-\t  && (TREE_CODE (TREE_OPERAND (init, 1)) == TREE_VEC\n-\t      || INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (init, 1))))\n-\t  && i > 0)\n+      if (TREE_CODE (stmt) != OACC_LOOP && i > 0)\n \tkind = 4;\n       data.kind = kind;\n       data.idx = i;"}, {"sha": "70957a66da834bf2d86965163001d45bbd71882c", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 124, "deletions": 42, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2084b5f42a4432da8b0625f9c669bf690ec46468/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2084b5f42a4432da8b0625f9c669bf690ec46468/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=2084b5f42a4432da8b0625f9c669bf690ec46468", "patch": "@@ -1975,6 +1975,7 @@ expand_omp_for_init_counts (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t  break;\n       if (i == fd->last_nonrect\n \t  && fd->loops[i].outer == fd->last_nonrect - fd->first_nonrect\n+\t  && !POINTER_TYPE_P (TREE_TYPE (fd->loops[i].v))\n \t  && !TYPE_UNSIGNED (TREE_TYPE (fd->loops[i].v)))\n \t{\n \t  int o = fd->first_nonrect;\n@@ -2250,15 +2251,22 @@ expand_omp_for_init_counts (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t      gsi2 = gsi_after_labels (cur_bb);\n \t      tree n1, n2;\n \t      t = fold_convert (itype, unshare_expr (fd->loops[i].n1));\n-\t      if (fd->loops[i].m1)\n+\t      if (fd->loops[i].m1 == NULL_TREE)\n+\t\tn1 = t;\n+\t      else if (POINTER_TYPE_P (itype))\n+\t\t{\n+\t\t  gcc_assert (integer_onep (fd->loops[i].m1));\n+\t\t  t = fold_convert (sizetype,\n+\t\t\t\t    unshare_expr (fd->loops[i].n1));\n+\t\t  n1 = fold_build_pointer_plus (vs[i - fd->loops[i].outer], t);\n+\t\t}\n+\t      else\n \t\t{\n \t\t  n1 = fold_convert (itype, unshare_expr (fd->loops[i].m1));\n \t\t  n1 = fold_build2 (MULT_EXPR, itype,\n \t\t\t\t    vs[i - fd->loops[i].outer], n1);\n \t\t  n1 = fold_build2 (PLUS_EXPR, itype, n1, t);\n \t\t}\n-\t      else\n-\t\tn1 = t;\n \t      n1 = force_gimple_operand_gsi (&gsi2, n1, true, NULL_TREE,\n \t\t\t\t\t     true, GSI_SAME_STMT);\n \t      if (i < fd->last_nonrect)\n@@ -2267,17 +2275,26 @@ expand_omp_for_init_counts (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t\t  expand_omp_build_assign (&gsi2, vs[i], n1);\n \t\t}\n \t      t = fold_convert (itype, unshare_expr (fd->loops[i].n2));\n-\t      if (fd->loops[i].m2)\n+\t      if (fd->loops[i].m2 == NULL_TREE)\n+\t\tn2 = t;\n+\t      else if (POINTER_TYPE_P (itype))\n+\t\t{\n+\t\t  gcc_assert (integer_onep (fd->loops[i].m2));\n+\t\t  t = fold_convert (sizetype,\n+\t\t\t\t    unshare_expr (fd->loops[i].n2));\n+\t\t  n2 = fold_build_pointer_plus (vs[i - fd->loops[i].outer], t);\n+\t\t}\n+\t      else\n \t\t{\n \t\t  n2 = fold_convert (itype, unshare_expr (fd->loops[i].m2));\n \t\t  n2 = fold_build2 (MULT_EXPR, itype,\n \t\t\t\t    vs[i - fd->loops[i].outer], n2);\n \t\t  n2 = fold_build2 (PLUS_EXPR, itype, n2, t);\n \t\t}\n-\t      else\n-\t\tn2 = t;\n \t      n2 = force_gimple_operand_gsi (&gsi2, n2, true, NULL_TREE,\n \t\t\t\t\t     true, GSI_SAME_STMT);\n+\t      if (POINTER_TYPE_P (itype))\n+\t\titype = signed_type_for (itype);\n \t      if (i == fd->last_nonrect)\n \t\t{\n \t\t  gcond *cond_stmt\n@@ -2295,8 +2312,10 @@ expand_omp_for_init_counts (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t\t\t\t\t     ? -1 : 1));\n \t\t  t = fold_build2 (PLUS_EXPR, itype,\n \t\t\t\t   fold_convert (itype, fd->loops[i].step), t);\n-\t\t  t = fold_build2 (PLUS_EXPR, itype, t, n2);\n-\t\t  t = fold_build2 (MINUS_EXPR, itype, t, n1);\n+\t\t  t = fold_build2 (PLUS_EXPR, itype, t,\n+\t\t\t\t   fold_convert (itype, n2));\n+\t\t  t = fold_build2 (MINUS_EXPR, itype, t,\n+\t\t\t\t   fold_convert (itype, n1));\n \t\t  tree step = fold_convert (itype, fd->loops[i].step);\n \t\t  if (TYPE_UNSIGNED (itype)\n \t\t      && fd->loops[i].cond_code == GT_EXPR)\n@@ -2323,7 +2342,11 @@ expand_omp_for_init_counts (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t      gsi2 = gsi_after_labels (e->dest);\n \t      tree step = fold_convert (itype,\n \t\t\t\t\tunshare_expr (fd->loops[i].step));\n-\t      t = fold_build2 (PLUS_EXPR, itype, vs[i], step);\n+\t      if (POINTER_TYPE_P (TREE_TYPE (vs[i])))\n+\t\tt = fold_build_pointer_plus (vs[i],\n+\t\t\t\t\t     fold_convert (sizetype, step));\n+\t      else\n+\t\tt = fold_build2 (PLUS_EXPR, itype, vs[i], step);\n \t      t = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n \t\t\t\t\t    true, GSI_SAME_STMT);\n \t      expand_omp_build_assign (&gsi2, vs[i], t);\n@@ -2761,17 +2784,22 @@ expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t\t\t     && !fd->loops[j].non_rect_referenced);\n \t      gsi2 = gsi_after_labels (cur_bb);\n \t      t = fold_convert (itype, unshare_expr (fd->loops[j].n1));\n-\t      if (fd->loops[j].m1)\n+\t      if (fd->loops[j].m1 == NULL_TREE)\n+\t\tn1 = rect_p ? build_zero_cst (type) : t;\n+\t      else if (POINTER_TYPE_P (itype))\n+\t\t{\n+\t\t  gcc_assert (integer_onep (fd->loops[j].m1));\n+\t\t  t = fold_convert (sizetype,\n+\t\t\t\t    unshare_expr (fd->loops[j].n1));\n+\t\t  n1 = fold_build_pointer_plus (vs[j - fd->loops[j].outer], t);\n+\t\t}\n+\t      else\n \t\t{\n \t\t  n1 = fold_convert (itype, unshare_expr (fd->loops[j].m1));\n \t\t  n1 = fold_build2 (MULT_EXPR, itype,\n \t\t\t\t    vs[j - fd->loops[j].outer], n1);\n \t\t  n1 = fold_build2 (PLUS_EXPR, itype, n1, t);\n \t\t}\n-\t      else if (rect_p)\n-\t\tn1 = build_zero_cst (type);\n-\t      else\n-\t\tn1 = t;\n \t      n1 = force_gimple_operand_gsi (&gsi2, n1, true, NULL_TREE,\n \t\t\t\t\t     true, GSI_SAME_STMT);\n \t      if (j < fd->last_nonrect)\n@@ -2780,19 +2808,26 @@ expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t\t  expand_omp_build_assign (&gsi2, vs[j], n1);\n \t\t}\n \t      t = fold_convert (itype, unshare_expr (fd->loops[j].n2));\n-\t      if (fd->loops[j].m2)\n+\t      if (fd->loops[j].m2 == NULL_TREE)\n+\t\tn2 = rect_p ? counts[j] : t;\n+\t      else if (POINTER_TYPE_P (itype))\n+\t\t{\n+\t\t  gcc_assert (integer_onep (fd->loops[j].m2));\n+\t\t  t = fold_convert (sizetype,\n+\t\t\t\t    unshare_expr (fd->loops[j].n2));\n+\t\t  n2 = fold_build_pointer_plus (vs[j - fd->loops[j].outer], t);\n+\t\t}\n+\t      else\n \t\t{\n \t\t  n2 = fold_convert (itype, unshare_expr (fd->loops[j].m2));\n \t\t  n2 = fold_build2 (MULT_EXPR, itype,\n \t\t\t\t    vs[j - fd->loops[j].outer], n2);\n \t\t  n2 = fold_build2 (PLUS_EXPR, itype, n2, t);\n \t\t}\n-\t      else if (rect_p)\n-\t\tn2 = counts[j];\n-\t      else\n-\t\tn2 = t;\n \t      n2 = force_gimple_operand_gsi (&gsi2, n2, true, NULL_TREE,\n \t\t\t\t\t     true, GSI_SAME_STMT);\n+\t      if (POINTER_TYPE_P (itype))\n+\t\titype = signed_type_for (itype);\n \t      if (j == fd->last_nonrect)\n \t\t{\n \t\t  gcond *cond_stmt\n@@ -2810,8 +2845,10 @@ expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t\t\t\t\t     ? -1 : 1));\n \t\t  t = fold_build2 (PLUS_EXPR, itype,\n \t\t\t\t   fold_convert (itype, fd->loops[j].step), t);\n-\t\t  t = fold_build2 (PLUS_EXPR, itype, t, n2);\n-\t\t  t = fold_build2 (MINUS_EXPR, itype, t, n1);\n+\t\t  t = fold_build2 (PLUS_EXPR, itype, t,\n+\t\t\t\t   fold_convert (itype, n2));\n+\t\t  t = fold_build2 (MINUS_EXPR, itype, t,\n+\t\t\t\t   fold_convert (itype, n1));\n \t\t  tree step = fold_convert (itype, fd->loops[j].step);\n \t\t  if (TYPE_UNSIGNED (itype)\n \t\t      && fd->loops[j].cond_code == GT_EXPR)\n@@ -2853,7 +2890,11 @@ expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t\t{\n \t\t  tree step\n \t\t    = fold_convert (itype, unshare_expr (fd->loops[j].step));\n-\t\t  t = fold_build2 (PLUS_EXPR, itype, vs[j], step);\n+\t\t  if (POINTER_TYPE_P (vtype))\n+\t\t    t = fold_build_pointer_plus (vs[j], fold_convert (sizetype,\n+\t\t\t\t\t\t\t\t      step));\n+\t\t  else\n+\t\t    t = fold_build2 (PLUS_EXPR, itype, vs[j], step);\n \t\t}\n \t      t = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n \t\t\t\t\t    true, GSI_SAME_STMT);\n@@ -2899,7 +2940,10 @@ expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t    }\n \t  for (int j = fd->last_nonrect; j >= fd->first_nonrect; j--)\n \t    {\n-\t      tree itype = TREE_TYPE (fd->loops[j].v);\n+\t      tree vtype = TREE_TYPE (fd->loops[j].v);\n+\t      tree itype = vtype;\n+\t      if (POINTER_TYPE_P (itype))\n+\t\titype = signed_type_for (itype);\n \t      bool rect_p = (fd->loops[j].m1 == NULL_TREE\n \t\t\t     && fd->loops[j].m2 == NULL_TREE\n \t\t\t     && !fd->loops[j].non_rect_referenced);\n@@ -2910,15 +2954,20 @@ expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t\t  tree t2\n \t\t    = fold_convert (itype, unshare_expr (fd->loops[j].step));\n \t\t  t = fold_build2 (MULT_EXPR, itype, t, t2);\n-\t\t  t = fold_build2 (PLUS_EXPR, itype, n1, t);\n+\t\t  if (POINTER_TYPE_P (vtype))\n+\t\t    t = fold_build_pointer_plus (n1,\n+\t\t\t\t\t\t fold_convert (sizetype, t));\n+\t\t  else\n+\t\t    t = fold_build2 (PLUS_EXPR, itype, n1, t);\n \t\t}\n \t      else if (rect_p)\n \t\t{\n \t\t  t = fold_convert (itype, vs[j]);\n \t\t  t = fold_build2 (MULT_EXPR, itype, t,\n \t\t\t\t   fold_convert (itype, fd->loops[j].step));\n \t\t  if (POINTER_TYPE_P (vtype))\n-\t\t    t = fold_build_pointer_plus (fd->loops[j].n1, t);\n+\t\t    t = fold_build_pointer_plus (fd->loops[j].n1,\n+\t\t\t\t\t\t fold_convert (sizetype, t));\n \t\t  else\n \t\t    t = fold_build2 (PLUS_EXPR, itype, fd->loops[j].n1, t);\n \t\t}\n@@ -2978,12 +3027,23 @@ expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t{\n \t  tree itype = TREE_TYPE (fd->loops[i].v);\n \n-\t  tree t = fold_convert (itype, unshare_expr (fd->loops[i].m2));\n-\t  t = fold_build2 (MULT_EXPR, itype,\n-\t\t\t   fd->loops[i - fd->loops[i].outer].v, t);\n-\t  t = fold_build2 (PLUS_EXPR, itype, t,\n-\t\t\t   fold_convert (itype,\n-\t\t\t\t\t unshare_expr (fd->loops[i].n2)));\n+\t  tree t;\n+\t  if (POINTER_TYPE_P (itype))\n+\t    {\n+\t      gcc_assert (integer_onep (fd->loops[i].m2));\n+\t      t = fold_convert (sizetype, unshare_expr (fd->loops[i].n2));\n+\t      t = fold_build_pointer_plus (fd->loops[i - fd->loops[i].outer].v,\n+\t\t\t\t\t   t);\n+\t    }\n+\t  else\n+\t    {\n+\t      t = fold_convert (itype, unshare_expr (fd->loops[i].m2));\n+\t      t = fold_build2 (MULT_EXPR, itype,\n+\t\t\t       fd->loops[i - fd->loops[i].outer].v, t);\n+\t      t = fold_build2 (PLUS_EXPR, itype, t,\n+\t\t\t       fold_convert (itype,\n+\t\t\t\t\t     unshare_expr (fd->loops[i].n2)));\n+\t    }\n \t  nonrect_bounds[i] = create_tmp_reg (itype, \".bound\");\n \t  t = force_gimple_operand_gsi (gsi, t, false,\n \t\t\t\t\tNULL_TREE, false,\n@@ -3065,10 +3125,16 @@ extract_omp_for_update_vars (struct omp_for_data *fd, tree *nonrect_bounds,\n \t      t = l->n1;\n \t      if (l->m1)\n \t\t{\n-\t\t  tree t2\n-\t\t    = fold_build2 (MULT_EXPR, TREE_TYPE (t),\n-\t\t\t\t   fd->loops[i + 1 - l->outer].v, l->m1);\n-\t\t  t = fold_build2 (PLUS_EXPR, TREE_TYPE (t), t2, t);\n+\t\t  if (POINTER_TYPE_P (TREE_TYPE (l->v)))\n+\t\t    t = fold_build_pointer_plus (fd->loops[i + 1 - l->outer].v,\n+\t\t\t\t\t\t fold_convert (sizetype, t));\n+\t\t  else\n+\t\t    {\n+\t\t      tree t2\n+\t\t\t= fold_build2 (MULT_EXPR, TREE_TYPE (t),\n+\t\t\t\t       fd->loops[i + 1 - l->outer].v, l->m1);\n+\t\t      t = fold_build2 (PLUS_EXPR, TREE_TYPE (t), t2, t);\n+\t\t    }\n \t\t}\n \t      t = force_gimple_operand_gsi (&gsi, t,\n \t\t\t\t\t    DECL_P (l->v)\n@@ -3116,9 +3182,17 @@ extract_omp_for_update_vars (struct omp_for_data *fd, tree *nonrect_bounds,\n \t\t  }\n \t\tif (l->m1)\n \t\t  {\n-\t\t    t = fold_build2 (MULT_EXPR, TREE_TYPE (l->m1), l->m1,\n-\t\t\t\t     fd->loops[i].v);\n-\t\t    t = fold_build2 (PLUS_EXPR, TREE_TYPE (l->v), t, l->n1);\n+\t\t    if (POINTER_TYPE_P (TREE_TYPE (l->v)))\n+\t\t      t = fold_build_pointer_plus (fd->loops[i].v,\n+\t\t\t\t\t\t   fold_convert (sizetype,\n+\t\t\t\t\t\t\t\t l->n1));\n+\t\t    else\n+\t\t      {\n+\t\t\tt = fold_build2 (MULT_EXPR, TREE_TYPE (l->m1), l->m1,\n+\t\t\t\t\t fd->loops[i].v);\n+\t\t\tt = fold_build2 (PLUS_EXPR, TREE_TYPE (l->v),\n+\t\t\t\t\t t, l->n1);\n+\t\t      }\n \t\t    n1 = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n \t\t\t\t\t\t   false,\n \t\t\t\t\t\t   GSI_CONTINUE_LINKING);\n@@ -3132,10 +3206,18 @@ extract_omp_for_update_vars (struct omp_for_data *fd, tree *nonrect_bounds,\n \t\t\t\t\t\t GSI_CONTINUE_LINKING);\n \t\tif (l->m2)\n \t\t  {\n-\t\t    t = fold_build2 (MULT_EXPR, TREE_TYPE (l->m2), l->m2,\n-\t\t\t\t     fd->loops[i].v);\n-\t\t    t = fold_build2 (PLUS_EXPR, TREE_TYPE (nonrect_bounds[j]),\n-\t\t\t\t     t, unshare_expr (l->n2));\n+\t\t    if (POINTER_TYPE_P (TREE_TYPE (l->v)))\n+\t\t      t = fold_build_pointer_plus (fd->loops[i].v,\n+\t\t\t\t\t\t   fold_convert (sizetype,\n+\t\t\t\t\t\t\t\t l->n2));\n+\t\t    else\n+\t\t      {\n+\t\t\tt = fold_build2 (MULT_EXPR, TREE_TYPE (l->m2), l->m2,\n+\t\t\t\t\t fd->loops[i].v);\n+\t\t\tt = fold_build2 (PLUS_EXPR,\n+\t\t\t\t\t TREE_TYPE (nonrect_bounds[j]),\n+\t\t\t\t\t t, unshare_expr (l->n2));\n+\t\t      }\n \t\t    n2 = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n \t\t\t\t\t\t   false,\n \t\t\t\t\t\t   GSI_CONTINUE_LINKING);"}, {"sha": "d66bbcdffacf4e0b1600e426d11337c4ff002715", "filename": "gcc/testsuite/c-c++-common/gomp/loop-8.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2084b5f42a4432da8b0625f9c669bf690ec46468/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2084b5f42a4432da8b0625f9c669bf690ec46468/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-8.c?ref=2084b5f42a4432da8b0625f9c669bf690ec46468", "patch": "@@ -0,0 +1,10 @@\n+void\n+foo (void)\n+{\n+  int a[1024];\n+  int *p, *q;\n+  #pragma omp parallel for collapse(2)\n+  for (p = &a[0]; p < &a[512]; p++)\n+    for (q = p + 64; q < p + 128; q++)\n+      ;\n+}"}, {"sha": "a64ad989b8a2e5276a3b81b94341fe3cc444de7b", "filename": "gcc/testsuite/c-c++-common/gomp/loop-9.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2084b5f42a4432da8b0625f9c669bf690ec46468/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2084b5f42a4432da8b0625f9c669bf690ec46468/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-9.c?ref=2084b5f42a4432da8b0625f9c669bf690ec46468", "patch": "@@ -0,0 +1,38 @@\n+int *qux (int *);\n+\n+void\n+foo (void)\n+{\n+  int a[1024];\n+  int *p;\n+  short *q;\n+  __PTRDIFF_TYPE__ r;\n+  #pragma omp parallel for collapse(2)\n+  for (p = &a[0]; p < &a[512]; p++)\n+    for (q = (short *) p + 64; q < (short *) p + 128; q++)\t/* { dg-error \"outer iteration variable 'p' used in initializer expression has type other than 'short int ?\\\\\\*'\" } */\n+      ;\n+  #pragma omp parallel for collapse(2)\n+  for (p = &a[0]; p < &a[512]; p++)\n+    for (r = &a[32] - p; r < 32; r++)\t\t\t\t/* { dg-error \"initializer expression refers to iteration variable 'p'\" } */\n+      ;\n+  #pragma omp parallel for collapse(2)\n+  for (r = 0; r < 64; r++)\n+    for (p = &a[0] + r; p < &a[32] + 3 * r; p++)\t\t/* { dg-error \"initializer expression refers to iteration variable 'r'\" } */\n+      ;\n+}\n+\n+void\n+bar (void)\n+{\n+  int a[1024];\n+  int *p, *q, *r;\n+  #pragma omp parallel for collapse(2)\n+  for (p = &a[0]; p < &a[512]; p++)\n+    for (q = p + (&a[16] - qux (p)); q < &a[32]; q++)\t\t/* { dg-error \"initializer expression refers to iteration variable 'p'\" } */\n+      ;\n+  #pragma omp parallel for collapse(3)\n+  for (p = &a[0]; p < &a[512]; p++)\n+    for (q = &a[0]; q < &a[512]; q++)\n+      for (r = p; r < q + 32; r++)\t\t\t\t/* { dg-error \"two different outer iteration variables 'p' and 'q' used in a single loop\" } */\n+\t;\n+}"}, {"sha": "5b3021337f5357686f9bacdda021361553263e88", "filename": "libgomp/testsuite/libgomp.c/loop-26.c", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2084b5f42a4432da8b0625f9c669bf690ec46468/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2084b5f42a4432da8b0625f9c669bf690ec46468/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-26.c?ref=2084b5f42a4432da8b0625f9c669bf690ec46468", "patch": "@@ -0,0 +1,196 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+\n+signed char v[5][7][9][21][4][42][3];\n+int a[84];\n+int *volatile zero = &a[42];\n+int *volatile two = &a[42 + 2];\n+int *volatile three = &a[42 + 3];\n+int *volatile five = &a[42 + 5];\n+int *volatile seven = &a[42 + 7];\n+int *volatile nine = &a[42 + 9];\n+int *volatile eleven = &a[42 + 11];\n+int *volatile minusone = &a[42 - 1];\n+volatile int zeroi = 0, onei = 1, twoi = 2, threei = 3, fivei = 5;\n+\n+int\n+main ()\n+{\n+  for (int i = 0; i < 5; i++)\n+  for (int j = 0; j < 7; j++)\n+  for (int k = 0; k < 9; k++)\n+  for (int l = j; l < 5 + j; l++)\n+  for (int m = 7; m < 11; m++)\n+  for (int n = 0; n < l - 2; n++)\n+  for (int o = 0; o < 3; o++)\n+    v[i][j][k][l][m - 7][n][o] = 1;\n+\n+  int niters = 0;\n+  #pragma omp parallel\n+  #pragma omp for collapse(7) reduction(+:niters)\n+  for (int i = 0; i < 5; i++)\n+  for (int *j = &a[42]; j < &a[42 + 7]; j++)\n+  for (int *k = &a[42]; k < &a[42 + 9]; k++)\n+  for (int *l = j; l < 5 + j; l++)\n+  for (int *m = &a[42 + 7]; m < &a[42 + 11]; m++)\n+  for (int *n = &a[42]; n < l - 2; n++)\n+  for (int *o = &a[42]; o < &a[42 + 3]; o++)\n+    {\n+      niters++;\n+      if (i < 0 || i >= 5\n+\t  || j - &a[42] < 0 || j - &a[42] >= 7\n+\t  || k - &a[42] < 0 || k - &a[42] >= 9\n+\t  || l - &a[42] < 0 || l >= j + 5\n+\t  || m - &a[42] < 7 || m - &a[42] >= 11\n+\t  || n - &a[42] < 0 || n >= l - 2\n+\t  || o - &a[42] < 0 || o - &a[42] >= 3)\n+\tabort ();\n+      if (v[i][j - &a[42]][k - &a[42]][l - &a[42]][m - &a[42 + 7]][n - &a[42]][o - &a[42]] != 1)\n+\tabort ();\n+      v[i][j - &a[42]][k - &a[42]][l - &a[42]][m - &a[42 + 7]][n - &a[42]][o - &a[42]]++;\n+    }\n+\n+  if (niters != 58860)\n+    abort ();\n+  int niters2 = 0;\n+  #pragma omp parallel\n+  #pragma omp for collapse(7) reduction(+:niters2)\n+  for (int *i = zero; i < five; i += onei)\n+  for (int *j = seven - onei; j >= zero; j -= onei)\n+  for (int *k = nine - onei; k >= zero; k += -onei)\n+  for (int *l = j + zeroi; l < fivei + j; l += onei)\n+  for (int *m = eleven - onei; m >= seven; m -= onei)\n+  for (int *n = l - threei; n >= zero; n -= onei)\n+  for (int *o = zero; o < three; o += onei)\n+    {\n+      niters2++;\n+      if (i - &a[42] < 0 || i - &a[42] >= 5\n+\t  || j - &a[42] < 0 || j - &a[42] >= 7\n+\t  || k - &a[42] < 0 || k - &a[42] >= 9\n+\t  || l < j || l >= j + 5\n+\t  || m - &a[42] < 7 || m - &a[42] >= 11\n+\t  || n - &a[42] < 0 || n >= l - 2\n+\t  || o - &a[42] < 0 || o - &a[42] >= 3)\n+\tabort ();\n+      if (v[i - &a[42]][j - &a[42]][k - &a[42]][l - &a[42]][m - &a[42 + 7]][n - &a[42]][o - &a[42]] != 2)\n+\tabort ();\n+      v[i - &a[42]][j - &a[42]][k - &a[42]][l - &a[42]][m - &a[42 + 7]][n - &a[42]][o - &a[42]]++;\n+    }\n+\n+  if (niters2 != 58860)\n+    abort ();\n+\n+  for (int i = 0; i < 5; i++)\n+  for (int j = 0; j < 7; j++)\n+  for (int k = 0; k < 9; k++)\n+  for (int l = j; l < 5 + j; l++)\n+  for (int m = 7; m < 11; m++)\n+  for (int n = 0; n < l - 2; n++)\n+  for (int o = 0; o < 3; o++)\n+    if (v[i][j][k][l][m - 7][n][o] != 3)\n+      abort ();\n+\n+  int niters3 = 0;\n+  #pragma omp parallel\n+  #pragma omp for collapse(5) reduction(+:niters3)\n+  for (int *i = &a[42 + 4]; i >= &a[42 + 0]; i--)\n+  for (int *j = &a[42 + 6]; j >= &a[42 + 0]; --j)\n+  for (int *l = j + 4; l >= j; l--)\n+  for (int *n = l - 3; n >= &a[42]; --n)\n+  for (int *o = &a[42 + 2]; o >= &a[42 + 0]; o--)\n+    {\n+      niters3++;\n+      if (i - &a[42] < 0 || i - &a[42] >= 5\n+\t  || j - &a[42] < 0 || j - &a[42] >= 7\n+\t  || l < j || l >= j + 5\n+\t  || n - &a[42] < 0 || n >= l - 2\n+\t  || o - &a[42] < 0 || o - &a[42] >= 3)\n+\tabort ();\n+      if (v[i - &a[42]][j - &a[42]][0][l - &a[42]][0][n - &a[42]][o - &a[42]] != 3)\n+\tabort ();\n+      v[i - &a[42]][j - &a[42]][0][l - &a[42]][0][n - &a[42]][o - &a[42]]++;\n+    }\n+\n+  if (niters3 != 1635)\n+    abort ();\n+\n+  int niters4 = 0;\n+  #pragma omp parallel\n+  #pragma omp for collapse(5) reduction(+:niters4)\n+  for (int *i = zero; i < five; i += onei)\n+  for (int *j = zero; j <= seven - onei; j += onei)\n+  for (int *l = zeroi + j; l < j + fivei; l += onei)\n+  for (int *n = zero; n <= l - threei; n += onei)\n+  for (int o = zeroi; o < threei; o += onei)\n+    {\n+      niters4++;\n+      if (i - &a[42] < 0 || i - &a[42] >= 5\n+\t  || j - &a[42] < 0 || j - &a[42] >= 7\n+\t  || l < j || l >= j + 5\n+\t  || n - &a[42] < 0 || n >= l - 2\n+\t  || o < 0 || o >= 3)\n+\tabort ();\n+      if (v[i - &a[42]][j - &a[42]][0][l - &a[42]][0][n - &a[42]][o] != 4)\n+\tabort ();\n+      v[i - &a[42]][j - &a[42]][0][l - &a[42]][0][n - &a[42]][o]++;\n+    }\n+\n+  if (niters4 != 1635)\n+    abort ();\n+\n+  for (int i = 0; i < 5; i++)\n+  for (int j = 0; j < 7; j++)\n+  for (int l = j; l < j + 5; l++)\n+  for (int n = 0; n < l - 2; n++)\n+  for (int o = 0; o < 3; o++)\n+    if (v[i][j][0][l][0][n][o] != 5)\n+      abort ();\n+\n+  int niters5 = 0;\n+  #pragma omp parallel\n+  #pragma omp for collapse(3) reduction(+:niters5)\n+  for (int *j = &a[42 + 6]; j >= &a[42]; --j)\n+  for (int *l = j + 0; l <= j + 4; l++)\n+  for (int *n = l - 3; n > &a[42 - 1]; --n)\n+    {\n+      niters5++;\n+      if (j - &a[42] < 0 || j - &a[42] >= 7\n+\t  || l < j || l >= j + 5\n+\t  || n < &a[42] || n >= l - 2)\n+\tabort ();\n+      if (v[0][j - &a[42]][0][l - &a[42]][0][n - &a[42]][0] != 5)\n+\tabort ();\n+      v[0][j - &a[42]][0][l - &a[42]][0][n - &a[42]][0]++;\n+    }\n+\n+  if (niters5 != 109)\n+    abort ();\n+\n+  int niters6 = 0;\n+  #pragma omp parallel\n+  #pragma omp for collapse(3) reduction(+:niters6)\n+  for (int *j = seven - onei; j > minusone; j -= onei)\n+  for (int *l = j + threei + onei; l >= j; l += -onei)\n+  for (int *n = l - threei; n > minusone; n -= onei)\n+    {\n+      niters6++;\n+      if (j - &a[42] < 0 || j - &a[42] >= 7\n+\t  || l < j || l >= j + 5\n+\t  || n < &a[42] || n >= l - 2)\n+\tabort ();\n+      if (v[0][j - &a[42]][0][l - &a[42]][0][n - &a[42]][0] != 6)\n+\tabort ();\n+      v[0][j - &a[42]][0][l - &a[42]][0][n - &a[42]][0]++;\n+    }\n+\n+  if (niters6 != 109)\n+    abort ();\n+\n+  for (int j = 0; j < 7; j++)\n+  for (int l = j; l < j + 5; l++)\n+  for (int n = 0; n < l - 2; n++)\n+    if (v[0][j][0][l][0][n][0] != 7)\n+      abort ();\n+  return 0;\n+}"}, {"sha": "3353b8777ccf98a849952512f6c2602a3d856242", "filename": "libgomp/testsuite/libgomp.c/loop-27.c", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2084b5f42a4432da8b0625f9c669bf690ec46468/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2084b5f42a4432da8b0625f9c669bf690ec46468/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-27.c?ref=2084b5f42a4432da8b0625f9c669bf690ec46468", "patch": "@@ -0,0 +1,180 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+\n+int x;\n+short *i, *j;\n+int ii, jj;\n+short *volatile a;\n+short *volatile b;\n+volatile int c, e, f, g;\n+short *volatile d;\n+int k[11][20];\n+short v[84];\n+\n+int\n+main ()\n+{\n+  int niters;\n+  for (ii = 1; ii <= 10; ii++)\n+    for (jj = 1; jj <= ii + 5; jj++)\n+      k[ii][jj] = 1;\n+  a = &v[42 + 1]; b = &v[42 + 11]; c = 1; d = &v[42 + 1]; e = 6; f = 1;\n+  niters = 0; i = &v[0]; j = &v[0]; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = &v[42 + 1]; i <= &v[42 + 10]; i++)\n+    for (j = &v[42 + 1]; j <= i + 5; j++)\n+      {\n+\tif (i < &v[42 + 1] || i > &v[42 + 10] || j < &v[42 + 1] || j > i + 5 || k[i - &v[42]][j - &v[42]] != 1)\n+\t  abort ();\n+\tk[i - &v[42]][j - &v[42]]++;\n+\tx = (i - &v[42]) * 1024 + ((j - &v[42]) & 1023);\n+\tniters++;\n+      }\n+  if (i != &v[42 + 11] || j != &v[42 + 16] || x != 10255 || niters != 105)\n+    abort ();\n+  niters = 0; i = &v[0]; j = &v[0]; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = a; i < b; i += c)\n+    for (j = d; j < e + i; j += f)\n+      {\n+\tif (i < &v[42 + 1] || i > &v[42 + 10] || j < &v[42 + 1] || j > i + 5 || k[i - &v[42]][j - &v[42]] != 2)\n+\t  abort ();\n+\tk[i - &v[42]][j - &v[42]]++;\n+\tx = (i - &v[42]) * 1024 + ((j - &v[42]) & 1023);\n+\tniters++;\n+      }\n+  if (i != &v[42 + 11] || j != &v[42 + 16] || x != 10255 || niters != 105)\n+    abort ();\n+  for (ii = 1; ii <= 10; ii++)\n+    for (jj = 1; jj <= ii + 5; jj++)\n+      if (k[ii][jj] == 3)\n+\tk[ii][jj] = 0;\n+      else\n+\tabort ();\n+  for (ii = 0; ii < 11; ii++)\n+    for (jj = 0; jj < 20; jj++)\n+      if (k[ii][jj] != 0)\n+\tabort ();\n+  for (ii = 0; ii < 10; ii++)\n+    for (jj = 0; jj < ii; jj++)\n+      k[ii][jj] = 1;\n+  a = &v[42]; b = &v[42 + 10]; c = 1; d = &v[42]; e = 0; f = 1;\n+  niters = 0; i = &v[0]; j = &v[0]; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = &v[42]; i < &v[42 + 10]; i++)\n+    for (j = &v[42]; j < i; j++)\n+      {\n+\tif (i < &v[42] || i >= &v[42 + 10] || j < &v[42] || j >= i || k[i - &v[42]][j - &v[42]] != 1)\n+\t  abort ();\n+\tk[i - &v[42]][j - &v[42]]++;\n+\tx = (i - &v[42]) * 1024 + ((j - &v[42]) & 1023);\n+\tniters++;\n+      }\n+  if (i != &v[42 + 10] || j != &v[42 + 9] || x != 9224 || niters != 45)\n+    abort ();\n+  niters = 0; i = &v[0]; j = &v[0]; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = a; i < b; i += c)\n+    for (j = d; j < i - e; j += f)\n+      {\n+\tif (i < &v[42] || i >= &v[42 + 10] || j < &v[42] || j >= i || k[i - &v[42]][j - &v[42]] != 2)\n+\t  abort ();\n+\tk[i - &v[42]][j - &v[42]]++;\n+\tx = (i - &v[42]) * 1024 + ((j - &v[42]) & 1023);\n+\tniters++;\n+      }\n+  if (i != &v[42 + 10] || j != &v[42 + 9] || x != 9224 || niters != 45)\n+    abort ();\n+  for (ii = 0; ii < 10; ii++)\n+    for (jj = 0; jj < ii; jj++)\n+      if (k[ii][jj] == 3)\n+\tk[ii][jj] = 0;\n+      else\n+\tabort ();\n+  for (ii = 0; ii < 11; ii++)\n+    for (jj = 0; jj < 20; jj++)\n+      if (k[ii][jj] != 0)\n+\tabort ();\n+  for (ii = 0; ii < 10; ii++)\n+    for (jj = ii + 1; jj < ii + 4; jj++)\n+      k[ii][jj] = 1;\n+  a = &v[42]; b = &v[42 + 10]; c = 1; e = 1; f = 1; g = -4;\n+  niters = 0; i = &v[0]; j = &v[0]; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = &v[42]; i < &v[42 + 10]; i++)\n+    for (j = i + 1; j < i + 4; j++)\n+      {\n+\tif (i < &v[42] || i >= &v[42 + 10] || j < i + 1 || j >= i + 4 || k[i - &v[42]][j - &v[42]] != 1)\n+\t  abort ();\n+\tk[i - &v[42]][j - &v[42]]++;\n+\tx = (i - &v[42]) * 1024 + ((j - &v[42]) & 1023);\n+\tniters++;\n+      }\n+  if (i != &v[42 + 10] || j != &v[42 + 13] || x != 9228 || niters != 30)\n+    abort ();\n+  niters = 0; i = &v[0]; j = &v[0]; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = a; i < b; i += c)\n+    for (j = i + e; j < i - g; j += f)\n+      {\n+\tif (i < &v[42] || i >= &v[42 + 10] || j < i + 1 || j >= i + 4 || k[i - &v[42]][j - &v[42]] != 2)\n+\t  abort ();\n+\tk[i - &v[42]][j - &v[42]]++;\n+\tx = (i - &v[42]) * 1024 + ((j - &v[42]) & 1023);\n+\tniters++;\n+      }\n+  if (i != &v[42 + 10] || j != &v[42 + 13] || x != 9228 || niters != 30)\n+    abort ();\n+  for (ii = 0; ii < 10; ii++)\n+    for (jj = ii + 1; jj < ii + 4; jj++)\n+      if (k[ii][jj] == 3)\n+\tk[ii][jj] = 0;\n+      else\n+\tabort ();\n+  for (ii = 0; ii < 11; ii++)\n+    for (jj = 0; jj < 20; jj++)\n+      if (k[ii][jj] != 0)\n+\tabort ();\n+  for (ii = 1; ii < 10; ii += 2)\n+    for (jj = 1; jj < ii + 1; jj++)\n+      k[ii][jj] = 1;\n+  a = &v[42 + 1]; b = &v[42 + 10]; c = 2; d = &v[42 + 1]; e = 1; f = 1;\n+  niters = 0; i = &v[0]; j = &v[0]; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = &v[42 + 1]; i < &v[42 + 10]; i += 2)\n+    for (j = &v[42 + 1]; j < i + 1; j++)\n+      {\n+\tif (i < &v[42 + 1] || i >= &v[42 + 10] || j < &v[42 + 1] || j >= i + 1 || k[i - &v[42]][j - &v[42]] != 1)\n+\t  abort ();\n+\tk[i - &v[42]][j - &v[42]]++;\n+\tx = (i - &v[42]) * 1024 + ((j - &v[42]) & 1023);\n+\tniters++;\n+      }\n+  if (i != &v[42 + 11] || j != &v[42 + 10] || x != 9225 || niters != 25)\n+    abort ();\n+  niters = 0; i = &v[0]; j = &v[0]; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = a; i < b; i += c)\n+    for (j = d; j < i + e; j += f)\n+      {\n+\tif (i < &v[42 + 1] || i >= &v[42 + 10] || j < &v[42 + 1] || j >= i + 1 || k[i - &v[42]][j - &v[42]] != 2)\n+\t  abort ();\n+\tk[i - &v[42]][j - &v[42]]++;\n+\tx = (i - &v[42]) * 1024 + ((j - &v[42]) & 1023);\n+\tniters++;\n+      }\n+  if (i != &v[42 + 11] || j != &v[42 + 10] || x != 9225 || niters != 25)\n+    abort ();\n+  for (ii = 1; ii < 10; ii += 2)\n+    for (jj = 1; jj < ii + 1; jj++)\n+      if (k[ii][jj] == 3)\n+\tk[ii][jj] = 0;\n+      else\n+\tabort ();\n+  for (ii = 0; ii < 11; ii++)\n+    for (jj = 0; jj < 20; jj++)\n+      if (k[ii][jj] != 0)\n+\tabort ();\n+  return 0;\n+}"}]}