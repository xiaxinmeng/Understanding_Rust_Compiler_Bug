{"sha": "b9820f7b84d491adfec2f56f5ef58702510cd9e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk4MjBmN2I4NGQ0OTFhZGZlYzJmNTZmNWVmNTg3MDI1MTBjZDllMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-29T11:09:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-29T11:09:46Z"}, "message": "[multiple changes]\n\n2012-10-29  Tristan Gingold  <gingold@adacore.com>\n\n\t* gnat_rm.texi: Document implementation advice for Pragma\n\tPartition_Elaboration_Policy.\n\n2012-10-29  Yannick Moy  <moy@adacore.com>\n\n\t* s-bignum.adb (Div_Rem): Reference that Algorithm_D is from\n\tthe second edition of TAOCP from Knuth, since the algo changed\n\tin the third edition. Also correct the definition of 'd' which\n\tcould overflow.\n\n2012-10-29  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch3.adb (Build_Initialization_Call): Create static strings\n\twhich denote entry [family] names and associate them with the\n\tobject's Protection_Entries or ATCB.\n\t(Build_Init_Statements):\n\tRemove local variable Names. Do not generate the entry [family]\n\tnames inside the init proc because they are now static.\n\t* exp_ch9.adb (Build_Entry_Names): Reimplemented. The strings\n\twhich denote entry [family] names are now generated statically\n\tand associated with the concurrent object's Protection_Entries\n\tor ATCB during initialization.\n\t* exp_ch9.ads (Build_Entry_Names): Change subprogram profile\n\tand associated comment on usage.\n\t* rtsfind.ads: Add the following entries to tables RE_Id and\n\tRE_Unit_Table:\n\n\tRE_Protected_Entry_Names_Array RE_Task_Entry_Names_Array\n\tRO_PE_Number_Of_Entries RO_PE_Set_Entry_Names\n\tRO_ST_Number_Of_Entries RO_ST_Set_Entry_Names\n\n\tRemove the following entries from tables RE_Id and RE_Unit_Table:\n\n\tRO_PE_Set_Entry_Name RO_TS_Set_Entry_Name\n\n\t* s-taskin.adb: Remove with clause for Ada.Unchecked_Deallocation.\n\t(Free_Entry_Names_Array): Removed.\n\t(Number_Of_Entries): New routine.\n\t(Set_Entry_Names): New routine.\n\t* s-taskin.ads: Rename type Entry_Names_Array to\n\tTask_Entry_Names_Array. Rename type Entry_Names_Array_Access\n\tto Task_Entry_Names_Access. Update the type of ACTB field\n\tEntry_Names and add a comment on its protection status.\n\t(Free_Entry_Names_Array): Removed.\n\t(Number_Of_Entries): New routine.\n\t(Set_Entry_Names): New routine.\n\t* s-tassta.adb (Create_Task): Remove formal parameter\n\tBuild_Entry_Names. Do not allocate an array to hold the\n\tstring names of entries and families.\n\t(Free_Entry_Names): Removed.\n\t(Free_Task): Remove the call to Free_Entry_Names.\n\t(Set_Entry_Name): Removed.\n\t(Vulnerable_Free_Task): Remove the call to Free_Entry_Names.\n\t* s-tassta.ads (Create_Task): Remove formal parameter\n\tBuild_Entry_Names along with associated comment.\n\t(Set_Entry_Name): Removed.\n\t* s-tpoben.adb: Remove with clause for Ada.Unchecked_Deallocation.\n\t(Finalize): Remove the call to Free_Entry_Names.\n\t(Free_Entry_Names): Removed.\n\t(Initialize_Protection_Entries):\n\tRemove formal parameter Build_Entry_Names. Do not allocate\n\tan array to hold the string names of entries and families.\n\t(Number_Of_Entries): New routine.\n\t(Set_Entry_Name): Removed.\n\t(Set_Entry_Names): New routine.\n\t* s-tpoben.ads: Add types Protected_Entry_Names_Array and\n\tProtected_Entry_Names_Access. Update the type of Protection_Enties\n\tfield Entry_Names.\n\t(Initialize_Protection_Entries): Remove\n\tformal parameter Build_Entry_Names along with associated comment.\n\t(Number_Of_Entries): New routine.\n\t(Set_Entry_Name): Removed.\n\t(Set_Entry_Names): New routine.\n\n2012-10-29  Arnaud Charlet  <charlet@adacore.com>\n\n\t* gnat_ugn.texi: Minor typo fix.\n\nFrom-SVN: r192933", "tree": {"sha": "c6f72c04618eb46b19778035ec894212166d8ea2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6f72c04618eb46b19778035ec894212166d8ea2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9820f7b84d491adfec2f56f5ef58702510cd9e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9820f7b84d491adfec2f56f5ef58702510cd9e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9820f7b84d491adfec2f56f5ef58702510cd9e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9820f7b84d491adfec2f56f5ef58702510cd9e1/comments", "author": null, "committer": null, "parents": [{"sha": "8d9ef58eb842796ac219ad123d0a55efabf64131", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d9ef58eb842796ac219ad123d0a55efabf64131", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d9ef58eb842796ac219ad123d0a55efabf64131"}], "stats": {"total": 945, "additions": 515, "deletions": 430}, "files": [{"sha": "f83800cb018aceeaf429bcdfebda40b0be629c6e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b9820f7b84d491adfec2f56f5ef58702510cd9e1", "patch": "@@ -1,3 +1,82 @@\n+2012-10-29  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* gnat_rm.texi: Document implementation advice for Pragma\n+\tPartition_Elaboration_Policy.\n+\n+2012-10-29  Yannick Moy  <moy@adacore.com>\n+\n+\t* s-bignum.adb (Div_Rem): Reference that Algorithm_D is from\n+\tthe second edition of TAOCP from Knuth, since the algo changed\n+\tin the third edition. Also correct the definition of 'd' which\n+\tcould overflow.\n+\n+2012-10-29  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch3.adb (Build_Initialization_Call): Create static strings\n+\twhich denote entry [family] names and associate them with the\n+\tobject's Protection_Entries or ATCB.\n+\t(Build_Init_Statements):\n+\tRemove local variable Names. Do not generate the entry [family]\n+\tnames inside the init proc because they are now static.\n+\t* exp_ch9.adb (Build_Entry_Names): Reimplemented. The strings\n+\twhich denote entry [family] names are now generated statically\n+\tand associated with the concurrent object's Protection_Entries\n+\tor ATCB during initialization.\n+\t* exp_ch9.ads (Build_Entry_Names): Change subprogram profile\n+\tand associated comment on usage.\n+\t* rtsfind.ads: Add the following entries to tables RE_Id and\n+\tRE_Unit_Table:\n+\n+\tRE_Protected_Entry_Names_Array RE_Task_Entry_Names_Array\n+\tRO_PE_Number_Of_Entries RO_PE_Set_Entry_Names\n+\tRO_ST_Number_Of_Entries RO_ST_Set_Entry_Names\n+\n+\tRemove the following entries from tables RE_Id and RE_Unit_Table:\n+\n+\tRO_PE_Set_Entry_Name RO_TS_Set_Entry_Name\n+\n+\t* s-taskin.adb: Remove with clause for Ada.Unchecked_Deallocation.\n+\t(Free_Entry_Names_Array): Removed.\n+\t(Number_Of_Entries): New routine.\n+\t(Set_Entry_Names): New routine.\n+\t* s-taskin.ads: Rename type Entry_Names_Array to\n+\tTask_Entry_Names_Array. Rename type Entry_Names_Array_Access\n+\tto Task_Entry_Names_Access. Update the type of ACTB field\n+\tEntry_Names and add a comment on its protection status.\n+\t(Free_Entry_Names_Array): Removed.\n+\t(Number_Of_Entries): New routine.\n+\t(Set_Entry_Names): New routine.\n+\t* s-tassta.adb (Create_Task): Remove formal parameter\n+\tBuild_Entry_Names. Do not allocate an array to hold the\n+\tstring names of entries and families.\n+\t(Free_Entry_Names): Removed.\n+\t(Free_Task): Remove the call to Free_Entry_Names.\n+\t(Set_Entry_Name): Removed.\n+\t(Vulnerable_Free_Task): Remove the call to Free_Entry_Names.\n+\t* s-tassta.ads (Create_Task): Remove formal parameter\n+\tBuild_Entry_Names along with associated comment.\n+\t(Set_Entry_Name): Removed.\n+\t* s-tpoben.adb: Remove with clause for Ada.Unchecked_Deallocation.\n+\t(Finalize): Remove the call to Free_Entry_Names.\n+\t(Free_Entry_Names): Removed.\n+\t(Initialize_Protection_Entries):\n+\tRemove formal parameter Build_Entry_Names. Do not allocate\n+\tan array to hold the string names of entries and families.\n+\t(Number_Of_Entries): New routine.\n+\t(Set_Entry_Name): Removed.\n+\t(Set_Entry_Names): New routine.\n+\t* s-tpoben.ads: Add types Protected_Entry_Names_Array and\n+\tProtected_Entry_Names_Access. Update the type of Protection_Enties\n+\tfield Entry_Names.\n+\t(Initialize_Protection_Entries): Remove\n+\tformal parameter Build_Entry_Names along with associated comment.\n+\t(Number_Of_Entries): New routine.\n+\t(Set_Entry_Name): Removed.\n+\t(Set_Entry_Names): New routine.\n+\n+2012-10-29  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* gnat_ugn.texi: Minor typo fix.\n 2012-10-29  Yannick Moy  <moy@adacore.com>\n \n \t* debug.adb Associate debug switch -gnatd.V to extensions for"}, {"sha": "fdf3185cede4c4622f3f493ff5b329bbe12f4ff7", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=b9820f7b84d491adfec2f56f5ef58702510cd9e1", "patch": "@@ -1704,6 +1704,18 @@ package body Exp_Ch3 is\n          end if;\n       end if;\n \n+      --  When the object is either protected or a task, create static strings\n+      --  which denote the names of entries and families. Associate the strings\n+      --  with the concurrent object's Protection_Entries or ATCB. This is a\n+      --  VMS Debug feature.\n+\n+      if OpenVMS_On_Target\n+        and then Is_Concurrent_Type (Typ)\n+        and then Entry_Names_OK\n+      then\n+         Build_Entry_Names (Id_Ref, Typ, Res);\n+      end if;\n+\n       return Res;\n \n    exception\n@@ -2665,7 +2677,6 @@ package body Exp_Ch3 is\n          Decl       : Node_Id;\n          Has_POC    : Boolean;\n          Id         : Entity_Id;\n-         Names      : Node_Id;\n          Stmts      : List_Id;\n          Typ        : Entity_Id;\n \n@@ -3009,17 +3020,6 @@ package body Exp_Ch3 is\n \n             Append_To (Stmts, Make_Task_Create_Call (Rec_Type));\n \n-            --  Generate the statements which map a string entry name to a\n-            --  task entry index. Note that the task may not have entries.\n-\n-            if Entry_Names_OK then\n-               Names := Build_Entry_Names (Rec_Type);\n-\n-               if Present (Names) then\n-                  Append_To (Stmts, Names);\n-               end if;\n-            end if;\n-\n             declare\n                Task_Type : constant Entity_Id :=\n                              Corresponding_Concurrent_Type (Rec_Type);\n@@ -3073,18 +3073,6 @@ package body Exp_Ch3 is\n          if Is_Protected_Record_Type (Rec_Type) then\n             Append_List_To (Stmts,\n               Make_Initialize_Protection (Rec_Type));\n-\n-            --  Generate the statements which map a string entry name to a\n-            --  protected entry index. Note that the protected type may not\n-            --  have entries.\n-\n-            if Entry_Names_OK then\n-               Names := Build_Entry_Names (Rec_Type);\n-\n-               if Present (Names) then\n-                  Append_To (Stmts, Names);\n-               end if;\n-            end if;\n          end if;\n \n          --  Second pass: components with per-object constraints"}, {"sha": "77397c65927890d2b48544a1f920ffbcff55ee50", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 285, "deletions": 230, "changes": 515, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=b9820f7b84d491adfec2f56f5ef58702510cd9e1", "patch": "@@ -1363,59 +1363,54 @@ package body Exp_Ch9 is\n    -- Build_Entry_Names --\n    -----------------------\n \n-   function Build_Entry_Names (Conc_Typ : Entity_Id) return Node_Id is\n-      Loc       : constant Source_Ptr := Sloc (Conc_Typ);\n-      B_Decls   : List_Id;\n-      B_Stmts   : List_Id;\n-      Comp      : Node_Id;\n-      Index     : Entity_Id;\n-      Index_Typ : RE_Id;\n-      Typ       : Entity_Id := Conc_Typ;\n-\n-      procedure Build_Entry_Family_Name (Id : Entity_Id);\n-      --  Generate:\n-      --    for Lnn in Family_Low .. Family_High loop\n-      --       Inn := Inn + 1;\n-      --       Set_Entry_Name\n-      --         (_init._object <or> _init._task_id,\n-      --          Inn,\n-      --          new String (\"<Entry name>(\" & Lnn'Img & \")\"));\n-      --    end loop;\n-      --  Note that the bounds of the range may reference discriminants. The\n-      --  above construct is added directly to the statements of the block.\n-\n-      procedure Build_Entry_Name (Id : Entity_Id);\n-      --  Generate:\n-      --    Inn := Inn + 1;\n-      --    Set_Entry_Name\n-      --      (_init._object <or>_init._task_id,\n-      --       Inn,\n-      --       new String (\"<Entry name>\");\n-      --  The above construct is added directly to the statements of the block.\n-\n-      function Build_Set_Entry_Name_Call (Arg3 : Node_Id) return Node_Id;\n-      --  Generate the call to the runtime routine Set_Entry_Name with actuals\n-      --  _init._task_id or _init._object, Inn and Arg3.\n-\n-      procedure Increment_Index (Stmts : List_Id);\n-      --  Generate the following and add it to Stmts\n-      --    Inn := Inn + 1;\n-\n-      -----------------------------\n-      -- Build_Entry_Family_Name --\n-      -----------------------------\n-\n-      procedure Build_Entry_Family_Name (Id : Entity_Id) is\n-         Def     : constant Node_Id :=\n-                     Discrete_Subtype_Definition (Parent (Id));\n-         L_Id    : constant Entity_Id := Make_Temporary (Loc, 'L');\n-         L_Stmts : constant List_Id := New_List;\n-         Val     : Node_Id;\n+   procedure Build_Entry_Names\n+     (Obj_Ref : Node_Id;\n+      Obj_Typ : Entity_Id;\n+      Stmts   : List_Id)\n+   is\n+      Loc   : constant Source_Ptr := Sloc (Obj_Ref);\n+      Data  : Entity_Id := Empty;\n+      Index : Entity_Id := Empty;\n+      Typ   : Entity_Id := Obj_Typ;\n+\n+      procedure Build_Entry_Name (Comp_Id : Entity_Id);\n+      --  Given an entry [family], create a static string which denotes the\n+      --  name of Comp_Id and assign it to the underlying data structure which\n+      --  contains the entry names of a concurrent object.\n+\n+      function Object_Reference return Node_Id;\n+      --  Return a reference to field _object or _task_id depending on the\n+      --  concurrent object being processed.\n+\n+      ----------------------\n+      -- Build_Entry_Name --\n+      ----------------------\n \n+      procedure Build_Entry_Name (Comp_Id : Entity_Id) is\n          function Build_Range (Def : Node_Id) return Node_Id;\n          --  Given a discrete subtype definition of an entry family, generate a\n          --  range node which covers the range of Def's type.\n \n+         procedure Create_Index_And_Data;\n+         --  Generate the declarations of variables Index and Data. Subsequent\n+         --  calls do nothing.\n+\n+         function Increment_Index return Node_Id;\n+         --  Increment the index used in the assignment of string names to the\n+         --  Data array.\n+\n+         function Name_Declaration (Def_Id : Entity_Id) return Node_Id;\n+         --  Given the name of a temporary variable, create the following\n+         --  declaration for it:\n+         --\n+         --    Def_Id : aliased constant String := <String_Name_From_Buffer>;\n+\n+         function Set_Entry_Name (Def_Id : Entity_Id) return Node_Id;\n+         --  Given the name of a temporary variable, place it in the array of\n+         --  string names. Generate:\n+         --\n+         --    Data (Index) := Def_Id'Unchecked_Access;\n+\n          -----------------\n          -- Build_Range --\n          -----------------\n@@ -1432,15 +1427,21 @@ package body Exp_Ch9 is\n             if Is_Entity_Name (Low)\n               and then Ekind (Entity (Low)) = E_Discriminant\n             then\n-               Low := Make_Identifier (Loc, Chars (Low));\n+               Low :=\n+                 Make_Selected_Component (Loc,\n+                   Prefix        => New_Copy_Tree (Obj_Ref),\n+                   Selector_Name => Make_Identifier (Loc, Chars (Low)));\n             else\n                Low := New_Copy_Tree (Low);\n             end if;\n \n             if Is_Entity_Name (High)\n               and then Ekind (Entity (High)) = E_Discriminant\n             then\n-               High := Make_Identifier (Loc, Chars (High));\n+               High :=\n+                 Make_Selected_Component (Loc,\n+                   Prefix        => New_Copy_Tree (Obj_Ref),\n+                   Selector_Name => Make_Identifier (Loc, Chars (High)));\n             else\n                High := New_Copy_Tree (High);\n             end if;\n@@ -1451,150 +1452,239 @@ package body Exp_Ch9 is\n                 High_Bound => High);\n          end Build_Range;\n \n-      --  Start of processing for Build_Entry_Family_Name\n+         ---------------------------\n+         -- Create_Index_And_Data --\n+         ---------------------------\n \n-      begin\n-         Get_Name_String (Chars (Id));\n+         procedure Create_Index_And_Data is\n+         begin\n+            if No (Index) and then No (Data) then\n+               declare\n+                  Count     : RE_Id;\n+                  Data_Typ  : RE_Id;\n+                  Index_Typ : RE_Id;\n+                  Size      : Entity_Id;\n \n-         --  Add a leading '('\n+               begin\n+                  if Is_Protected_Type (Typ) then\n+                     Count     := RO_PE_Number_Of_Entries;\n+                     Data_Typ  := RE_Protected_Entry_Names_Array;\n+                     Index_Typ := RE_Protected_Entry_Index;\n+                  else\n+                     Count     := RO_ST_Number_Of_Entries;\n+                     Data_Typ  := RE_Task_Entry_Names_Array;\n+                     Index_Typ := RE_Task_Entry_Index;\n+                  end if;\n \n-         Add_Char_To_Name_Buffer ('(');\n+                  --  Step 1: Generate the declaration of the index variable:\n \n-         --  Generate:\n-         --    new String'(\"<Entry name>(\" & Lnn'Img & \")\");\n+                  --    Index : <Index_Typ> := 1;\n \n-         --  This is an implicit heap allocation, and Comes_From_Source is\n-         --  False, which ensures that it will get flagged as a violation of\n-         --  No_Implicit_Heap_Allocations when that restriction applies.\n+                  Index := Make_Temporary (Loc, 'I');\n \n-         Val :=\n-           Make_Allocator (Loc,\n-             Make_Qualified_Expression (Loc,\n-               Subtype_Mark =>\n-                 New_Reference_To (Standard_String, Loc),\n-               Expression =>\n-                 Make_Op_Concat (Loc,\n-                   Left_Opnd =>\n-                     Make_Op_Concat (Loc,\n-                       Left_Opnd =>\n-                         Make_String_Literal (Loc,\n-                           Strval => String_From_Name_Buffer),\n-                       Right_Opnd =>\n-                         Make_Attribute_Reference (Loc,\n-                           Prefix =>\n-                             New_Reference_To (L_Id, Loc),\n-                               Attribute_Name => Name_Img)),\n-                   Right_Opnd =>\n-                     Make_String_Literal (Loc,\n-                       Strval => \")\"))));\n+                  Append_To (Stmts,\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Index,\n+                      Object_Definition   =>\n+                        New_Reference_To (RTE (Index_Typ), Loc),\n+                      Expression          => Make_Integer_Literal (Loc, 1)));\n \n-         Increment_Index (L_Stmts);\n-         Append_To (L_Stmts, Build_Set_Entry_Name_Call (Val));\n+                  --  Step 2: Generate the declaration of an array to house all\n+                  --  names:\n \n-         --  Generate:\n-         --    for Lnn in Family_Low .. Family_High loop\n-         --       Inn := Inn + 1;\n-         --       Set_Entry_Name\n-         --         (_init._object <or> _init._task_id, Inn, <Val>);\n-         --    end loop;\n+                  --    Size : constant <Index_Typ> := <Count> (Obj_Ref);\n+                  --    Data : aliased <Data_Typ> := (1 .. Size => null);\n \n-         Append_To (B_Stmts,\n-           Make_Loop_Statement (Loc,\n-             Iteration_Scheme =>\n-               Make_Iteration_Scheme (Loc,\n-                 Loop_Parameter_Specification =>\n-                   Make_Loop_Parameter_Specification (Loc,\n-                    Defining_Identifier         => L_Id,\n-                    Discrete_Subtype_Definition => Build_Range (Def))),\n-             Statements => L_Stmts,\n-             End_Label => Empty));\n-      end Build_Entry_Family_Name;\n+                  Size := Make_Temporary (Loc, 'S');\n \n-      ----------------------\n-      -- Build_Entry_Name --\n-      ----------------------\n+                  Append_To (Stmts,\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Size,\n+                      Constant_Present    => True,\n+                      Object_Definition   =>\n+                        New_Reference_To (RTE (Index_Typ), Loc),\n+                      Expression          =>\n+                        Make_Function_Call (Loc,\n+                          Name                   =>\n+                            New_Reference_To (RTE (Count), Loc),\n+                          Parameter_Associations =>\n+                            New_List (Object_Reference))));\n+\n+                  Data := Make_Temporary (Loc, 'A');\n+\n+                  Append_To (Stmts,\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Data,\n+                      Aliased_Present     => True,\n+                      Object_Definition   =>\n+                        New_Reference_To (RTE (Data_Typ), Loc),\n+                      Expression          =>\n+                        Make_Aggregate (Loc,\n+                          Component_Associations => New_List (\n+                            Make_Component_Association (Loc,\n+                              Choices    => New_List (\n+                                Make_Range (Loc,\n+                                  Low_Bound  => Make_Integer_Literal (Loc, 1),\n+                                  High_Bound => New_Reference_To (Size, Loc))),\n+                              Expression => Make_Null (Loc))))));\n+               end;\n+            end if;\n+         end Create_Index_And_Data;\n+\n+         ---------------------\n+         -- Increment_Index --\n+         ---------------------\n+\n+         function Increment_Index return Node_Id is\n+         begin\n+            return\n+              Make_Assignment_Statement (Loc,\n+                Name       => New_Reference_To (Index, Loc),\n+                Expression =>\n+                  Make_Op_Add (Loc,\n+                    Left_Opnd  => New_Reference_To (Index, Loc),\n+                    Right_Opnd => Make_Integer_Literal (Loc, 1)));\n+         end Increment_Index;\n \n-      procedure Build_Entry_Name (Id : Entity_Id) is\n-         Val : Node_Id;\n+         ----------------------\n+         -- Name_Declaration --\n+         ----------------------\n+\n+         function Name_Declaration (Def_Id : Entity_Id) return Node_Id is\n+         begin\n+            return\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Def_Id,\n+                Aliased_Present     => True,\n+                Constant_Present    => True,\n+                Object_Definition   => New_Reference_To (Standard_String, Loc),\n+                Expression          =>\n+                  Make_String_Literal (Loc, String_From_Name_Buffer));\n+         end Name_Declaration;\n+\n+         --------------------\n+         -- Set_Entry_Name --\n+         --------------------\n+\n+         function Set_Entry_Name (Def_Id : Entity_Id) return Node_Id is\n+         begin\n+            return\n+              Make_Assignment_Statement (Loc,\n+                Name       =>\n+                  Make_Indexed_Component (Loc,\n+                    Prefix      => New_Reference_To (Data, Loc),\n+                    Expressions => New_List (New_Reference_To (Index, Loc))),\n+\n+                Expression =>\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix         => New_Reference_To (Def_Id, Loc),\n+                    Attribute_Name => Name_Unchecked_Access));\n+         end Set_Entry_Name;\n+\n+         --  Local variables\n+\n+         Temp_Id  : Entity_Id;\n+         Subt_Def : Node_Id;\n+\n+      --  Start of processing for Build_Entry_Name\n \n       begin\n-         Get_Name_String (Chars (Id));\n+         if Ekind (Comp_Id) = E_Entry_Family then\n+            Subt_Def := Discrete_Subtype_Definition (Parent (Comp_Id));\n \n-         --  This is an implicit heap allocation, and Comes_From_Source is\n-         --  False, which ensures that it will get flagged as a violation of\n-         --  No_Implicit_Heap_Allocations when that restriction applies.\n+            Create_Index_And_Data;\n \n-         Val :=\n-           Make_Allocator (Loc,\n-             Make_Qualified_Expression (Loc,\n-               Subtype_Mark =>\n-                 New_Reference_To (Standard_String, Loc),\n-               Expression =>\n-                 Make_String_Literal (Loc,\n-                   String_From_Name_Buffer)));\n+            --  Step 1: Create the string name of the entry family.\n+            --  Generate:\n+            --    Temp : aliased constant String := \"name ()\";\n+\n+            Temp_Id := Make_Temporary (Loc, 'S');\n+            Get_Name_String (Chars (Comp_Id));\n+            Add_Char_To_Name_Buffer (' ');\n+            Add_Char_To_Name_Buffer ('(');\n+            Add_Char_To_Name_Buffer (')');\n+\n+            Append_To (Stmts, Name_Declaration (Temp_Id));\n+\n+            --  Generate:\n+            --    for Member in Family_Low .. Family_High loop\n+            --       Set_Entry_Name (...);\n+            --       Index := Index + 1;\n+            --    end loop;\n+\n+            Append_To (Stmts,\n+              Make_Loop_Statement (Loc,\n+                Iteration_Scheme =>\n+                  Make_Iteration_Scheme (Loc,\n+                    Loop_Parameter_Specification =>\n+                      Make_Loop_Parameter_Specification (Loc,\n+                        Defining_Identifier         =>\n+                          Make_Temporary (Loc, 'L'),\n+                        Discrete_Subtype_Definition =>\n+                          Build_Range (Subt_Def))),\n+\n+                Statements       => New_List (\n+                  Set_Entry_Name (Temp_Id),\n+                  Increment_Index),\n+                End_Label        => Empty));\n+\n+         --  Entry\n+\n+         else\n+            Create_Index_And_Data;\n+\n+            --  Step 1: Create the string name of the entry. Generate:\n+            --    Temp : aliased constant String := \"name\";\n+\n+            Temp_Id := Make_Temporary (Loc, 'S');\n+            Get_Name_String (Chars (Comp_Id));\n+\n+            Append_To (Stmts, Name_Declaration (Temp_Id));\n+\n+            --  Step 2: Associate the string name with the underlying data\n+            --  structure.\n \n-         Increment_Index (B_Stmts);\n-         Append_To (B_Stmts, Build_Set_Entry_Name_Call (Val));\n+            Append_To (Stmts, Set_Entry_Name (Temp_Id));\n+            Append_To (Stmts, Increment_Index);\n+         end if;\n       end Build_Entry_Name;\n \n-      -------------------------------\n-      -- Build_Set_Entry_Name_Call --\n-      -------------------------------\n+      ----------------------\n+      -- Object_Reference --\n+      ----------------------\n \n-      function Build_Set_Entry_Name_Call (Arg3 : Node_Id) return Node_Id is\n-         Arg1 : Name_Id;\n-         Proc : RE_Id;\n+      function Object_Reference return Node_Id is\n+         Conc_Typ : constant Entity_Id := Corresponding_Record_Type (Typ);\n+         Field    : Name_Id;\n+         Ref      : Node_Id;\n \n       begin\n-         --  Determine the proper name for the first argument and the RTS\n-         --  routine to call.\n-\n          if Is_Protected_Type (Typ) then\n-            Arg1 := Name_uObject;\n-            Proc := RO_PE_Set_Entry_Name;\n-\n-         else pragma Assert (Is_Task_Type (Typ));\n-            Arg1 := Name_uTask_Id;\n-            Proc := RO_TS_Set_Entry_Name;\n+            Field := Name_uObject;\n+         else\n+            Field := Name_uTask_Id;\n          end if;\n \n-         --  Generate:\n-         --    Set_Entry_Name (_init.Arg1, Inn, Arg3);\n+         Ref :=\n+           Make_Selected_Component (Loc,\n+             Prefix        =>\n+               Unchecked_Convert_To (Conc_Typ, New_Copy_Tree (Obj_Ref)),\n+             Selector_Name => Make_Identifier (Loc, Field));\n \n-         return\n-           Make_Procedure_Call_Statement (Loc,\n-             Name =>\n-               New_Reference_To (RTE (Proc), Loc),\n-             Parameter_Associations => New_List (\n-               Make_Selected_Component (Loc,              --  _init._object\n-                 Prefix =>                                --  _init._task_id\n-                   Make_Identifier (Loc, Name_uInit),\n-                 Selector_Name =>\n-                   Make_Identifier (Loc, Arg1)),\n-               New_Reference_To (Index, Loc),             --  Inn\n-               Arg3));                                    --  Val\n-      end Build_Set_Entry_Name_Call;\n+         if Is_Protected_Type (Typ) then\n+            Ref :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix         => Ref,\n+                Attribute_Name => Name_Unchecked_Access);\n+         end if;\n \n-      ---------------------\n-      -- Increment_Index --\n-      ---------------------\n+         return Ref;\n+      end Object_Reference;\n \n-      procedure Increment_Index (Stmts : List_Id) is\n-      begin\n-         --  Generate:\n-         --    Inn := Inn + 1;\n+      --  Local variables\n \n-         Append_To (Stmts,\n-           Make_Assignment_Statement (Loc,\n-             Name =>\n-               New_Reference_To (Index, Loc),\n-             Expression =>\n-               Make_Op_Add (Loc,\n-                 Left_Opnd =>\n-                   New_Reference_To (Index, Loc),\n-                 Right_Opnd =>\n-                   Make_Integer_Literal (Loc, 1))));\n-      end Increment_Index;\n+      Comp : Node_Id;\n+      Proc : RE_Id;\n \n    --  Start of processing for Build_Entry_Names\n \n@@ -1605,67 +1695,57 @@ package body Exp_Ch9 is\n          Typ := Corresponding_Concurrent_Type (Typ);\n       end if;\n \n-      pragma Assert (Is_Protected_Type (Typ) or else Is_Task_Type (Typ));\n+      pragma Assert (Is_Concurrent_Type (Typ));\n \n       --  Nothing to do if the type has no entries\n \n       if not Has_Entries (Typ) then\n-         return Empty;\n+         return;\n       end if;\n \n       --  Avoid generating entry names for a protected type with only one entry\n \n       if Is_Protected_Type (Typ)\n-        and then Find_Protection_Type (Typ) /= RTE (RE_Protection_Entries)\n+        and then Find_Protection_Type (Base_Type (Typ)) /=\n+                   RTE (RE_Protection_Entries)\n       then\n-         return Empty;\n-      end if;\n-\n-      Index := Make_Temporary (Loc, 'I');\n-\n-      --  Step 1: Generate the declaration of the index variable:\n-      --    Inn : Protected_Entry_Index := 0;\n-      --      or\n-      --    Inn : Task_Entry_Index := 0;\n-\n-      if Is_Protected_Type (Typ) then\n-         Index_Typ := RE_Protected_Entry_Index;\n-      else\n-         Index_Typ := RE_Task_Entry_Index;\n+         return;\n       end if;\n \n-      B_Decls := New_List;\n-      Append_To (B_Decls,\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Index,\n-          Object_Definition   => New_Reference_To (RTE (Index_Typ), Loc),\n-          Expression          => Make_Integer_Literal (Loc, 0)));\n-\n-      B_Stmts := New_List;\n-\n-      --  Step 2: Generate a call to Set_Entry_Name for each entry and entry\n-      --  family member.\n+      --  Step 1: Populate the array with statically generated strings denoting\n+      --  entries and entry family names.\n \n       Comp := First_Entity (Typ);\n       while Present (Comp) loop\n-         if Ekind (Comp) = E_Entry then\n+         if Comes_From_Source (Comp)\n+           and then Ekind_In (Comp, E_Entry, E_Entry_Family)\n+         then\n             Build_Entry_Name (Comp);\n-\n-         elsif Ekind (Comp) = E_Entry_Family then\n-            Build_Entry_Family_Name (Comp);\n          end if;\n \n          Next_Entity (Comp);\n       end loop;\n \n-      --  Step 3: Wrap the statements in a block\n+      --  Step 2: Associate the array with the related concurrent object:\n \n-      return\n-        Make_Block_Statement (Loc,\n-          Declarations => B_Decls,\n-          Handled_Statement_Sequence =>\n-            Make_Handled_Sequence_Of_Statements (Loc,\n-              Statements => B_Stmts));\n+      --    Set_Entry_Names (Obj_Ref, <Data>'Unchecked_Access);\n+\n+      if Present (Data) then\n+         if Is_Protected_Type (Typ) then\n+            Proc := RO_PE_Set_Entry_Names;\n+         else\n+            Proc := RO_ST_Set_Entry_Names;\n+         end if;\n+\n+         Append_To (Stmts,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   => New_Reference_To (RTE (Proc), Loc),\n+             Parameter_Associations => New_List (\n+               Object_Reference,\n+               Make_Attribute_Reference (Loc,\n+                 Prefix         => New_Reference_To (Data, Loc),\n+                 Attribute_Name => Name_Unchecked_Access))));\n+      end if;\n    end Build_Entry_Names;\n \n    ---------------------------\n@@ -13505,20 +13585,6 @@ package body Exp_Ch9 is\n                        Make_Attribute_Reference (Loc,\n                          Prefix         => New_Reference_To (P_Arr, Loc),\n                          Attribute_Name => Name_Unrestricted_Access));\n-\n-                     --  Build_Entry_Names generation flag. When set to true,\n-                     --  the runtime will allocate an array to hold the string\n-                     --  names of protected entries.\n-\n-                     if not Restricted_Profile then\n-                        if Entry_Names_OK then\n-                           Append_To (Args,\n-                             New_Reference_To (Standard_True, Loc));\n-                        else\n-                           Append_To (Args,\n-                             New_Reference_To (Standard_False, Loc));\n-                        end if;\n-                     end if;\n                   end if;\n \n                elsif Pkg_Id =\n@@ -13529,7 +13595,6 @@ package body Exp_Ch9 is\n                elsif Pkg_Id = System_Tasking_Protected_Objects_Entries then\n                   Append_To (Args, Make_Null (Loc));\n                   Append_To (Args, Make_Null (Loc));\n-                  Append_To (Args, New_Reference_To (Standard_False, Loc));\n                end if;\n \n                Append_To (L,\n@@ -13953,16 +14018,6 @@ package body Exp_Ch9 is\n           Prefix        => Make_Identifier (Loc, Name_uInit),\n           Selector_Name => Make_Identifier (Loc, Name_uTask_Id)));\n \n-      --  Build_Entry_Names generation flag. When set to true, the runtime\n-      --  will allocate an array to hold the string names of task entries.\n-\n-      if not Restricted_Profile then\n-         Append_To (Args,\n-           New_Reference_To\n-             (Boolean_Literals (Has_Entries (Ttyp) and then Entry_Names_OK),\n-              Loc));\n-      end if;\n-\n       if Restricted_Profile then\n          Name := New_Reference_To (RTE (RE_Create_Restricted_Task), Loc);\n       else"}, {"sha": "65b0c1953024fed8363494c6c0fd79a4702c35c0", "filename": "gcc/ada/exp_ch9.ads", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fexp_ch9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fexp_ch9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.ads?ref=b9820f7b84d491adfec2f56f5ef58702510cd9e1", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -55,10 +55,15 @@ package Exp_Ch9 is\n    --  interface, ensure that the designated type has a _master and generate\n    --  a renaming of the said master to service the access type.\n \n-   function Build_Entry_Names (Conc_Typ : Entity_Id) return Node_Id;\n-   --  Create the statements which populate the entry names array of a task or\n-   --  protected type. The statements are wrapped inside a block due to a local\n-   --  declaration.\n+   procedure Build_Entry_Names\n+     (Obj_Ref : Node_Id;\n+      Obj_Typ : Entity_Id;\n+      Stmts   : List_Id);\n+   --  Given a concurrent object, create static string names for all entries\n+   --  and entry families. Associate each name with the Protection_Entries or\n+   --  ATCB field of the object. Obj_Ref is a reference to the concurrent\n+   --  object. Obj_Typ is the type of the object. Stmts is the list where all\n+   --  generated code is attached.\n \n    procedure Build_Master_Entity (Obj_Or_Typ : Entity_Id);\n    --  Given the name of an object or a type which is either a task, contains"}, {"sha": "c084b1cdcd4e7e024a4132e2cd0e3982c0a1729c", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=b9820f7b84d491adfec2f56f5ef58702510cd9e1", "patch": "@@ -9422,6 +9422,18 @@ accuracy in some portions of the domain.\n @end cartouche\n Followed.\n \n+@cindex Sequential elaboration policy\n+@unnumberedsec H.6(15/2): Pragma Partition_Elaboration_Policy\n+\n+@sp 1\n+@cartouche\n+If the partition elaboration policy is @code{Sequential} and the\n+Environment task becomes permanently blocked during elaboration then the\n+partition is deadlocked and it is recommended that the partition be\n+immediately terminated.\n+@end cartouche\n+Not followed.\n+\n @c -----------------------------------------\n @node Implementation Defined Characteristics\n @chapter Implementation Defined Characteristics"}, {"sha": "b1e723920c35d76e5ca94dde5db1be75f8fa8962", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=b9820f7b84d491adfec2f56f5ef58702510cd9e1", "patch": "@@ -19150,7 +19150,7 @@ only.\n \n @item -fada-spec-parent=@var{unit}\n @cindex -fada-spec-parent (@command{gcc})\n-Specifies that all files generated by @option{-fdump-ada-spec-slim} are\n+Specifies that all files generated by @option{-fdump-ada-spec*} are\n to be child units of the specified parent unit.\n \n @item -C"}, {"sha": "63ff87cb33acc9da834f83d9d17f4f5004d707a3", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=b9820f7b84d491adfec2f56f5ef58702510cd9e1", "patch": "@@ -1502,6 +1502,9 @@ package Rtsfind is\n      RE_Unspecified_Task_Info,           -- System.Task_Info\n \n      RE_Task_Procedure_Access,           -- System.Tasking\n+     RE_Task_Entry_Names_Array,          -- System.Tasking\n+     RO_ST_Number_Of_Entries,            -- System.Tasking\n+     RO_ST_Set_Entry_Names,              -- System.Tasking\n \n      RO_ST_Task_Id,                      -- System.Tasking\n      RO_ST_Null_Task,                    -- System.Tasking\n@@ -1687,14 +1690,16 @@ package Rtsfind is\n      RE_Dispatching_Domain,              -- Dispatching_Domains\n \n      RE_Protected_Entry_Body_Array,      -- Tasking.Protected_Objects.Entries\n+     RE_Protected_Entry_Names_Array,     -- Tasking.Protected_Objects.Entries\n      RE_Protection_Entries,              -- Tasking.Protected_Objects.Entries\n      RE_Protection_Entries_Access,       -- Tasking.Protected_Objects.Entries\n      RE_Initialize_Protection_Entries,   -- Tasking.Protected_Objects.Entries\n      RE_Lock_Entries,                    -- Tasking.Protected_Objects.Entries\n+     RE_Unlock_Entries,                  -- Tasking.Protected_Objects.Entries\n      RO_PE_Get_Ceiling,                  -- Tasking.Protected_Objects.Entries\n+     RO_PE_Number_Of_Entries,            -- Tasking.Protected_Objects.Entries\n      RO_PE_Set_Ceiling,                  -- Tasking.Protected_Objects.Entries\n-     RO_PE_Set_Entry_Name,               -- Tasking.Protected_Objects.Entries\n-     RE_Unlock_Entries,                  -- Tasking.Protected_Objects.Entries\n+     RO_PE_Set_Entry_Names,              -- Tasking.Protected_Objects.Entries\n \n      RE_Communication_Block,             -- Protected_Objects.Operations\n      RE_Protected_Entry_Call,            -- Protected_Objects.Operations\n@@ -1769,7 +1774,6 @@ package Rtsfind is\n      RE_Free_Task,                       -- System.Tasking.Stages\n      RE_Expunge_Unactivated_Tasks,       -- System.Tasking.Stages\n      RE_Move_Activation_Chain,           -- System_Tasking_Stages\n-     RO_TS_Set_Entry_Name,               -- System.Tasking.Stages\n      RE_Terminated);                     -- System.Tasking.Stages\n \n    --  The following declarations build a table that is indexed by the RTE\n@@ -2749,6 +2753,9 @@ package Rtsfind is\n      RE_Unspecified_Task_Info            => System_Task_Info,\n \n      RE_Task_Procedure_Access            => System_Tasking,\n+     RE_Task_Entry_Names_Array           => System_Tasking,\n+     RO_ST_Number_Of_Entries             => System_Tasking,\n+     RO_ST_Set_Entry_Names               => System_Tasking,\n \n      RO_ST_Task_Id                       => System_Tasking,\n      RO_ST_Null_Task                     => System_Tasking,\n@@ -2937,6 +2944,8 @@ package Rtsfind is\n \n      RE_Protected_Entry_Body_Array       =>\n        System_Tasking_Protected_Objects_Entries,\n+     RE_Protected_Entry_Names_Array      =>\n+       System_Tasking_Protected_Objects_Entries,\n      RE_Protection_Entries               =>\n        System_Tasking_Protected_Objects_Entries,\n      RE_Protection_Entries_Access        =>\n@@ -2945,13 +2954,15 @@ package Rtsfind is\n        System_Tasking_Protected_Objects_Entries,\n      RE_Lock_Entries                     =>\n        System_Tasking_Protected_Objects_Entries,\n+     RE_Unlock_Entries                   =>\n+       System_Tasking_Protected_Objects_Entries,\n      RO_PE_Get_Ceiling                   =>\n        System_Tasking_Protected_Objects_Entries,\n-     RO_PE_Set_Ceiling                   =>\n+     RO_PE_Number_Of_Entries             =>\n        System_Tasking_Protected_Objects_Entries,\n-     RO_PE_Set_Entry_Name                =>\n+     RO_PE_Set_Ceiling                   =>\n        System_Tasking_Protected_Objects_Entries,\n-     RE_Unlock_Entries                   =>\n+     RO_PE_Set_Entry_Names               =>\n        System_Tasking_Protected_Objects_Entries,\n \n      RE_Communication_Block              =>\n@@ -3054,7 +3065,6 @@ package Rtsfind is\n      RE_Free_Task                        => System_Tasking_Stages,\n      RE_Expunge_Unactivated_Tasks        => System_Tasking_Stages,\n      RE_Move_Activation_Chain            => System_Tasking_Stages,\n-     RO_TS_Set_Entry_Name                => System_Tasking_Stages,\n      RE_Terminated                       => System_Tasking_Stages);\n \n    --------------------------------"}, {"sha": "955df4277c2ac7cd586734ec99abaf1a34cd0a34", "filename": "gcc/ada/s-bignum.adb", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fs-bignum.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fs-bignum.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-bignum.adb?ref=b9820f7b84d491adfec2f56f5ef58702510cd9e1", "patch": "@@ -728,8 +728,9 @@ package body System.Bignums is\n \n       --  The complex full multi-precision case. We will employ algorithm\n       --  D defined in the section \"The Classical Algorithms\" (sec. 4.3.1)\n-      --  of Donald Knuth's \"The Art of Computer Programming\", Vol. 2. The\n-      --  terminology is adjusted for this section to match that reference.\n+      --  of Donald Knuth's \"The Art of Computer Programming\", Vol. 2, 2nd\n+      --  edition. The terminology is adjusted for this section to match that\n+      --  reference.\n \n       --  We are dividing X.Len digits of X (called u here) by Y.Len digits\n       --  of Y (called v here), developing the quotient and remainder. The\n@@ -775,12 +776,12 @@ package body System.Bignums is\n             v (J) := Y.D (J);\n          end loop;\n \n-         --  [Division of nonnegative integers]. Given nonnegative integers u\n+         --  [Division of nonnegative integers.] Given nonnegative integers u\n          --  = (ul,u2..um+n) and v = (v1,v2..vn), where v1 /= 0 and n > 1, we\n          --  form the quotient u / v = (q0,ql..qm) and the remainder u mod v =\n          --  (r1,r2..rn).\n \n-         pragma Assert (v (1) /= 0);\n+         pragma Assert (v1 /= 0);\n          pragma Assert (n > 1);\n \n          --  Dl. [Normalize.] Set d = b/(vl + 1). Then set (u0,u1,u2..um+n)\n@@ -789,7 +790,7 @@ package body System.Bignums is\n          --  u0 at the left of u1; if d = 1 all we need to do in this step is\n          --  to set u0 = 0.\n \n-         d := b / DD (v1 + 1);\n+         d := b / (DD (v1) + 1);\n \n          if d = 1 then\n             u0 := 0;\n@@ -826,15 +827,15 @@ package body System.Bignums is\n \n          --  D2. [Initialize j.] Set j = 0. The loop on j, steps D2 through D7,\n          --  will be essentially a division of (uj, uj+1..uj+n) by (v1,v2..vn)\n-         --  to get a single quotient digit qj;\n+         --  to get a single quotient digit qj.\n \n          j := 0;\n \n          --  Loop through digits\n \n          loop\n-            --  D3. [Calculate qhat] If uj = v1, set qhat to b-l; otherwise set\n-            --  qhat to (uj,uj+1)/v1.\n+            --  D3. [Calculate qhat.] If uj = v1, set qhat to b-l; otherwise\n+            --  set qhat to (uj,uj+1)/v1.\n \n             if u (j) = v1 then\n                qhat := -1;"}, {"sha": "00c54ed9e471e7c43ef20b61253635915c2db3a1", "filename": "gcc/ada/s-taskin.adb", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fs-taskin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fs-taskin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.adb?ref=b9820f7b84d491adfec2f56f5ef58702510cd9e1", "patch": "@@ -33,28 +33,13 @@ pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during tasking\n --  operations. It causes infinite loops and other problems.\n \n-with Ada.Unchecked_Deallocation;\n-\n with System.Task_Primitives.Operations;\n with System.Storage_Elements;\n \n package body System.Tasking is\n \n    package STPO renames System.Task_Primitives.Operations;\n \n-   ----------------------------\n-   -- Free_Entry_Names_Array --\n-   ----------------------------\n-\n-   procedure Free_Entry_Names_Array (Obj : in out Entry_Names_Array) is\n-      procedure Free_String is new\n-        Ada.Unchecked_Deallocation (String, String_Access);\n-   begin\n-      for Index in Obj'Range loop\n-         Free_String (Obj (Index));\n-      end loop;\n-   end Free_Entry_Names_Array;\n-\n    ---------------------\n    -- Detect_Blocking --\n    ---------------------\n@@ -70,6 +55,15 @@ package body System.Tasking is\n       return GL_Detect_Blocking = 1;\n    end Detect_Blocking;\n \n+   -----------------------\n+   -- Number_Of_Entries --\n+   -----------------------\n+\n+   function Number_Of_Entries (Self_Id : Task_Id) return Task_Entry_Index is\n+   begin\n+      return Self_Id.Entry_Num;\n+   end Number_Of_Entries;\n+\n    ----------\n    -- Self --\n    ----------\n@@ -257,4 +251,16 @@ package body System.Tasking is\n       T.Entry_Calls (1).Self := T;\n    end Initialize;\n \n+   ---------------------\n+   -- Set_Entry_Names --\n+   ---------------------\n+\n+   procedure Set_Entry_Names\n+     (Self_Id : Task_Id;\n+      Names   : Task_Entry_Names_Access)\n+   is\n+   begin\n+      Self_Id.Entry_Names := Names;\n+   end Set_Entry_Names;\n+\n end System.Tasking;"}, {"sha": "9584901d3e7c9a200f05517fa20f737403ef64b1", "filename": "gcc/ada/s-taskin.ads", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fs-taskin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fs-taskin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.ads?ref=b9820f7b84d491adfec2f56f5ef58702510cd9e1", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -252,13 +252,10 @@ package System.Tasking is\n \n    type String_Access is access all String;\n \n-   type Entry_Names_Array is\n-     array (Entry_Index range <>) of String_Access;\n+   type Task_Entry_Names_Array is\n+     array (Task_Entry_Index range <>) of String_Access;\n \n-   type Entry_Names_Array_Access is access all Entry_Names_Array;\n-\n-   procedure Free_Entry_Names_Array (Obj : in out Entry_Names_Array);\n-   --  Deallocate all string names contained in an entry names array\n+   type Task_Entry_Names_Access is access all Task_Entry_Names_Array;\n \n    ----------------------------------\n    -- Entry_Call_Record definition --\n@@ -968,10 +965,13 @@ package System.Tasking is\n       --  associated with protected objects or task entries, and are protected\n       --  by the protected object lock or Acceptor.L, respectively.\n \n-      Entry_Names : Entry_Names_Array_Access := null;\n+      Entry_Names : Task_Entry_Names_Access := null;\n       --  An array of string names which denotes entry [family member] names.\n       --  The structure is indexed by task entry index and contains Entry_Num\n       --  components.\n+      --\n+      --  Protection: The array is populated during task initialization, before\n+      --  the task has been activated. No protection is required in this case.\n \n       New_Base_Priority : System.Any_Priority;\n       --  New value for Base_Priority (for dynamic priorities package)\n@@ -1203,4 +1203,13 @@ private\n    --  registered for removal (Expunge_Unactivated_Tasks). The \"limited\" forces\n    --  Activation_Chain to be a by-reference type; see RM-6.2(4).\n \n+   function Number_Of_Entries (Self_Id : Task_Id) return Task_Entry_Index;\n+   --  Given a task, return the number of entries it contains\n+\n+   procedure Set_Entry_Names\n+     (Self_Id : Task_Id;\n+      Names   : Task_Entry_Names_Access);\n+   --  Associate an array of string that denote entry [family] names with a\n+   --  task.\n+\n end System.Tasking;"}, {"sha": "cf63a304546cd89d67ac446d7e5082968ede3d9e", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 1, "deletions": 52, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=b9820f7b84d491adfec2f56f5ef58702510cd9e1", "patch": "@@ -91,9 +91,6 @@ package body System.Tasking.Stages is\n    procedure Free is new\n      Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n-   procedure Free_Entry_Names (T : Task_Id);\n-   --  Deallocate all string names associated with task entries\n-\n    procedure Trace_Unhandled_Exception_In_Task (Self_Id : Task_Id);\n    --  This procedure outputs the task specific message for exception\n    --  tracing purposes.\n@@ -487,8 +484,7 @@ package body System.Tasking.Stages is\n       Elaborated        : Access_Boolean;\n       Chain             : in out Activation_Chain;\n       Task_Image        : String;\n-      Created_Task      : out Task_Id;\n-      Build_Entry_Names : Boolean)\n+      Created_Task      : out Task_Id)\n    is\n       T, P          : Task_Id;\n       Self_ID       : constant Task_Id := STPO.Self;\n@@ -706,14 +702,6 @@ package body System.Tasking.Stages is\n            Dispatching_Domain_Tasks (Base_CPU) + 1;\n       end if;\n \n-      --  Note: we should not call 'new' while holding locks since new may use\n-      --  locks (e.g. RTS_Lock under Windows) itself and cause a deadlock.\n-\n-      if Build_Entry_Names then\n-         T.Entry_Names :=\n-           new Entry_Names_Array (1 .. Entry_Index (Num_Entries));\n-      end if;\n-\n       --  Create TSD as early as possible in the creation of a task, since it\n       --  may be used by the operation of Ada code within the task.\n \n@@ -942,26 +930,6 @@ package body System.Tasking.Stages is\n \n    end Finalize_Global_Tasks;\n \n-   ----------------------\n-   -- Free_Entry_Names --\n-   ----------------------\n-\n-   procedure Free_Entry_Names (T : Task_Id) is\n-      Names : Entry_Names_Array_Access := T.Entry_Names;\n-\n-      procedure Free_Entry_Names_Array_Access is new\n-        Ada.Unchecked_Deallocation\n-          (Entry_Names_Array, Entry_Names_Array_Access);\n-\n-   begin\n-      if Names = null then\n-         return;\n-      end if;\n-\n-      Free_Entry_Names_Array (Names.all);\n-      Free_Entry_Names_Array_Access (Names);\n-   end Free_Entry_Names;\n-\n    ---------------\n    -- Free_Task --\n    ---------------\n@@ -983,7 +951,6 @@ package body System.Tasking.Stages is\n \n          Initialization.Task_Unlock (Self_Id);\n \n-         Free_Entry_Names (T);\n          System.Task_Primitives.Operations.Finalize_TCB (T);\n \n       else\n@@ -1041,23 +1008,6 @@ package body System.Tasking.Stages is\n       Initialization.Undefer_Abort (Self_ID);\n    end Move_Activation_Chain;\n \n-   --  Compiler interface only. Do not call from within the RTS\n-\n-   --------------------\n-   -- Set_Entry_Name --\n-   --------------------\n-\n-   procedure Set_Entry_Name\n-     (T   : Task_Id;\n-      Pos : Task_Entry_Index;\n-      Val : String_Access)\n-   is\n-   begin\n-      pragma Assert (T.Entry_Names /= null);\n-\n-      T.Entry_Names (Entry_Index (Pos)) := Val;\n-   end Set_Entry_Name;\n-\n    ------------------\n    -- Task_Wrapper --\n    ------------------\n@@ -2119,7 +2069,6 @@ package body System.Tasking.Stages is\n          Unlock_RTS;\n       end if;\n \n-      Free_Entry_Names (T);\n       System.Task_Primitives.Operations.Finalize_TCB (T);\n    end Vulnerable_Free_Task;\n "}, {"sha": "e37fd59b66515735f1abbcd6855a0973d8f5126f", "filename": "gcc/ada/s-tassta.ads", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fs-tassta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fs-tassta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.ads?ref=b9820f7b84d491adfec2f56f5ef58702510cd9e1", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -180,8 +180,7 @@ package System.Tasking.Stages is\n       Elaborated        : Access_Boolean;\n       Chain             : in out Activation_Chain;\n       Task_Image        : String;\n-      Created_Task      : out Task_Id;\n-      Build_Entry_Names : Boolean);\n+      Created_Task      : out Task_Id);\n    --  Compiler interface only. Do not call from within the RTS.\n    --  This must be called to create a new task.\n    --\n@@ -212,8 +211,6 @@ package System.Tasking.Stages is\n    --   run time can store to ease the debugging and the\n    --   Ada.Task_Identification facility.\n    --  Created_Task is the resulting task.\n-   --  Build_Entry_Names is a flag which controls the allocation of the data\n-   --   structure which stores all entry names.\n    --\n    --  This procedure can raise Storage_Error if the task creation failed.\n \n@@ -285,13 +282,6 @@ package System.Tasking.Stages is\n    --  that doesn't happen, they will never be activated, and will become\n    --  terminated on leaving the return statement.\n \n-   procedure Set_Entry_Name\n-     (T   : Task_Id;\n-      Pos : Task_Entry_Index;\n-      Val : String_Access);\n-   --  This is called by the compiler to map a string which denotes an entry\n-   --  name to a task entry index.\n-\n    function Terminated (T : Task_Id) return Boolean;\n    --  This is called by the compiler to implement the 'Terminated attribute.\n    --  Though is not required to be so by the ARM, we choose to synchronize"}, {"sha": "f535a067bf7609a3487dfa6973c6c109f9371309", "filename": "gcc/ada/s-tpoben.adb", "status": "modified", "additions": 25, "deletions": 54, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fs-tpoben.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fs-tpoben.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpoben.adb?ref=b9820f7b84d491adfec2f56f5ef58702510cd9e1", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                               B o d y                                    --\n --                                                                          --\n---          Copyright (C) 1998-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,8 +41,6 @@\n \n --  Note: the compiler generates direct calls to this interface, via Rtsfind\n \n-with Ada.Unchecked_Deallocation;\n-\n with System.Task_Primitives.Operations;\n with System.Restrictions;\n with System.Parameters;\n@@ -58,13 +56,6 @@ package body System.Tasking.Protected_Objects.Entries is\n    use Parameters;\n    use Task_Primitives.Operations;\n \n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Free_Entry_Names (Object : Protection_Entries);\n-   --  Deallocate all string names associated with protected entries\n-\n    ----------------\n    -- Local Data --\n    ----------------\n@@ -141,8 +132,6 @@ package body System.Tasking.Protected_Objects.Entries is\n          end loop;\n       end loop;\n \n-      Free_Entry_Names (Object);\n-\n       Object.Finalized := True;\n \n       if Single_Lock then\n@@ -154,26 +143,6 @@ package body System.Tasking.Protected_Objects.Entries is\n       STPO.Finalize_Lock (Object.L'Unrestricted_Access);\n    end Finalize;\n \n-   ----------------------\n-   -- Free_Entry_Names --\n-   ----------------------\n-\n-   procedure Free_Entry_Names (Object : Protection_Entries) is\n-      Names : Entry_Names_Array_Access := Object.Entry_Names;\n-\n-      procedure Free_Entry_Names_Array_Access is new\n-        Ada.Unchecked_Deallocation\n-          (Entry_Names_Array, Entry_Names_Array_Access);\n-\n-   begin\n-      if Names = null then\n-         return;\n-      end if;\n-\n-      Free_Entry_Names_Array (Names.all);\n-      Free_Entry_Names_Array_Access (Names);\n-   end Free_Entry_Names;\n-\n    -----------------\n    -- Get_Ceiling --\n    -----------------\n@@ -202,12 +171,11 @@ package body System.Tasking.Protected_Objects.Entries is\n    -----------------------------------\n \n    procedure Initialize_Protection_Entries\n-     (Object            : Protection_Entries_Access;\n-      Ceiling_Priority  : Integer;\n-      Compiler_Info     : System.Address;\n-      Entry_Bodies      : Protected_Entry_Body_Access;\n-      Find_Body_Index   : Find_Body_Index_Access;\n-      Build_Entry_Names : Boolean)\n+     (Object           : Protection_Entries_Access;\n+      Ceiling_Priority : Integer;\n+      Compiler_Info    : System.Address;\n+      Entry_Bodies     : Protected_Entry_Body_Access;\n+      Find_Body_Index  : Find_Body_Index_Access)\n    is\n       Init_Priority : Integer := Ceiling_Priority;\n       Self_ID       : constant Task_Id := STPO.Self;\n@@ -250,11 +218,6 @@ package body System.Tasking.Protected_Objects.Entries is\n          Object.Entry_Queues (E).Head := null;\n          Object.Entry_Queues (E).Tail := null;\n       end loop;\n-\n-      if Build_Entry_Names then\n-         Object.Entry_Names :=\n-           new Entry_Names_Array (1 .. Entry_Index (Object.Num_Entries));\n-      end if;\n    end Initialize_Protection_Entries;\n \n    ------------------\n@@ -391,6 +354,17 @@ package body System.Tasking.Protected_Objects.Entries is\n       end if;\n    end Lock_Read_Only_Entries;\n \n+   -----------------------\n+   -- Number_Of_Entries --\n+   -----------------------\n+\n+   function Number_Of_Entries\n+     (Object : Protection_Entries_Access) return Protected_Entry_Index\n+   is\n+   begin\n+      return Object.Num_Entries;\n+   end Number_Of_Entries;\n+\n    -----------------\n    -- Set_Ceiling --\n    -----------------\n@@ -402,20 +376,17 @@ package body System.Tasking.Protected_Objects.Entries is\n       Object.New_Ceiling := Prio;\n    end Set_Ceiling;\n \n-   --------------------\n-   -- Set_Entry_Name --\n-   --------------------\n+   ---------------------\n+   -- Set_Entry_Names --\n+   ---------------------\n \n-   procedure Set_Entry_Name\n-     (Object : Protection_Entries'Class;\n-      Pos    : Protected_Entry_Index;\n-      Val    : String_Access)\n+   procedure Set_Entry_Names\n+     (Object : Protection_Entries_Access;\n+      Names  : Protected_Entry_Names_Access)\n    is\n    begin\n-      pragma Assert (Object.Entry_Names /= null);\n-\n-      Object.Entry_Names (Entry_Index (Pos)) := Val;\n-   end Set_Entry_Name;\n+      Object.Entry_Names := Names;\n+   end Set_Entry_Names;\n \n    --------------------\n    -- Unlock_Entries --"}, {"sha": "acdf69fbee92082b46fe9c08b7fbcfaf5e60f304", "filename": "gcc/ada/s-tpoben.ads", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fs-tpoben.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9820f7b84d491adfec2f56f5ef58702510cd9e1/gcc%2Fada%2Fs-tpoben.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpoben.ads?ref=b9820f7b84d491adfec2f56f5ef58702510cd9e1", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -67,6 +67,14 @@ package System.Tasking.Protected_Objects.Entries is\n    type Protected_Entry_Queue_Array is\n      array (Protected_Entry_Index range <>) of Entry_Queue;\n \n+   --  A data structure which contains the string names of entries and entry\n+   --  family members.\n+\n+   type Protected_Entry_Names_Array is\n+     array (Protected_Entry_Index range <>) of String_Access;\n+\n+   type Protected_Entry_Names_Access is access all Protected_Entry_Names_Array;\n+\n    --  This type contains the GNARL state of a protected object. The\n    --  application-defined portion of the state (i.e. private objects)\n    --  is maintained by the compiler-generated code.\n@@ -136,7 +144,7 @@ package System.Tasking.Protected_Objects.Entries is\n \n       Entry_Queues : Protected_Entry_Queue_Array (1 .. Num_Entries);\n \n-      Entry_Names : Entry_Names_Array_Access := null;\n+      Entry_Names : Protected_Entry_Names_Access := null;\n       --  An array of string names which denotes entry [family member] names.\n       --  The structure is indexed by protected entry index and contains Num_\n       --  Entries components.\n@@ -167,12 +175,11 @@ package System.Tasking.Protected_Objects.Entries is\n    --  System.Tasking.Protected_Objects.Initialize_Protection.\n \n    procedure Initialize_Protection_Entries\n-     (Object            : Protection_Entries_Access;\n-      Ceiling_Priority  : Integer;\n-      Compiler_Info     : System.Address;\n-      Entry_Bodies      : Protected_Entry_Body_Access;\n-      Find_Body_Index   : Find_Body_Index_Access;\n-      Build_Entry_Names : Boolean);\n+     (Object           : Protection_Entries_Access;\n+      Ceiling_Priority : Integer;\n+      Compiler_Info    : System.Address;\n+      Entry_Bodies     : Protected_Entry_Body_Access;\n+      Find_Body_Index  : Find_Body_Index_Access);\n    --  Initialize the Object parameter so that it can be used by the runtime\n    --  to keep track of the runtime state of a protected object.\n \n@@ -201,17 +208,20 @@ package System.Tasking.Protected_Objects.Entries is\n    --  possible future use. At the current time, everyone uses Lock for both\n    --  read and write locks.\n \n+   function Number_Of_Entries\n+     (Object : Protection_Entries_Access) return Protected_Entry_Index;\n+   --  Return the number of entries of a protected object\n+\n    procedure Set_Ceiling\n      (Object : Protection_Entries_Access;\n       Prio   : System.Any_Priority);\n    --  Sets the new ceiling priority of the protected object\n \n-   procedure Set_Entry_Name\n-     (Object : Protection_Entries'Class;\n-      Pos    : Protected_Entry_Index;\n-      Val    : String_Access);\n-   --  This is called by the compiler to map a string which denotes an entry\n-   --  name to a protected entry index.\n+   procedure Set_Entry_Names\n+     (Object : Protection_Entries_Access;\n+      Names  : Protected_Entry_Names_Access);\n+   --  Associate an array of string that denote entry [family] names with a\n+   --  protected object.\n \n    procedure Unlock_Entries (Object : Protection_Entries_Access);\n    --  Relinquish ownership of the lock for the object represented by the"}]}