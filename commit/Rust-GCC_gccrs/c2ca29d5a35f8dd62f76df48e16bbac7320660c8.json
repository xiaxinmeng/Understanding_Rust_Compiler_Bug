{"sha": "c2ca29d5a35f8dd62f76df48e16bbac7320660c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJjYTI5ZDVhMzVmOGRkNjJmNzZkZjQ4ZTE2YmJhYzczMjA2NjBjOA==", "commit": {"author": {"name": "Jozef Lawrynowicz", "email": "jozefl@gcc.gnu.org", "date": "2018-11-07T22:06:26Z"}, "committer": {"name": "Jozef Lawrynowicz", "email": "jozefl@gcc.gnu.org", "date": "2018-11-07T22:06:26Z"}, "message": "re PR c/87691 (transparent_union attribute does not work with MODE_PARTIAL_INT)\n\n2018-11-07  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n\n\tPR c/87691\n\t\n\tgcc/ChangeLog:\n\t* stor-layout.c (compute_record_mode): Set TYPE_MODE of UNION_TYPE\n\tto the mode of the widest field iff the widest field has mode class\n\tMODE_INT, or MODE_PARTIAL_INT and the union would be passed by\n\treference.\n\n\tgcc/testsuite/ChangeLog:\n\t* gcc.target/msp430/pr87691.c: New test.\n\nFrom-SVN: r265894", "tree": {"sha": "1ca8080d96fb6d191045c84771064ac19c0dd628", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ca8080d96fb6d191045c84771064ac19c0dd628"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2ca29d5a35f8dd62f76df48e16bbac7320660c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2ca29d5a35f8dd62f76df48e16bbac7320660c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2ca29d5a35f8dd62f76df48e16bbac7320660c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2ca29d5a35f8dd62f76df48e16bbac7320660c8/comments", "author": null, "committer": null, "parents": [{"sha": "e217792beda1ca48daea497c00694a3924f992c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e217792beda1ca48daea497c00694a3924f992c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e217792beda1ca48daea497c00694a3924f992c5"}], "stats": {"total": 89, "additions": 78, "deletions": 11}, "files": [{"sha": "c1eef4c1aa92a1a18579ba4bc4b66619ee171d70", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ca29d5a35f8dd62f76df48e16bbac7320660c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ca29d5a35f8dd62f76df48e16bbac7320660c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c2ca29d5a35f8dd62f76df48e16bbac7320660c8", "patch": "@@ -1,9 +1,17 @@\n-2018-11-17  Nikolai Merinov <n.merinov@inango-systems.com>\n+2018-11-07  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n \n-         * common.opt: Add -Wattribute-warning.\n-         * doc/invoke.texi: Add documentation for -Wno-attribute-warning.\n-         * expr.c (expand_expr_real_1): Add new attribute to warning_at\n-         call to allow user configure behavior of \"warning\" attribute.\n+\tPR c/87691\n+\t* stor-layout.c (compute_record_mode): Set TYPE_MODE of UNION_TYPE\n+\tto the mode of the widest field iff the widest field has mode class\n+\tMODE_INT, or MODE_PARTIAL_INT and the union would be passed by\n+\treference.\n+\n+2018-11-07  Nikolai Merinov  <n.merinov@inango-systems.com>\n+\n+\t* common.opt: Add -Wattribute-warning.\n+\t* doc/invoke.texi: Add documentation for -Wno-attribute-warning.\n+\t* expr.c (expand_expr_real_1): Add new attribute to warning_at\n+\tcall to allow user configure behavior of \"warning\" attribute.\n \n 2018-11-07  Segher Boessenkool  <segher@kernel.crashing.org>\n "}, {"sha": "4f323171397b8366ed8f4d83ffda08e6bdefff8e", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ca29d5a35f8dd62f76df48e16bbac7320660c8/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ca29d5a35f8dd62f76df48e16bbac7320660c8/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=c2ca29d5a35f8dd62f76df48e16bbac7320660c8", "patch": "@@ -1834,7 +1834,13 @@ compute_record_mode (tree type)\n       /* If this field is the whole struct, remember its mode so\n \t that, say, we can put a double in a class into a DF\n \t register instead of forcing it to live in the stack.  */\n-      if (simple_cst_equal (TYPE_SIZE (type), DECL_SIZE (field)))\n+      if (simple_cst_equal (TYPE_SIZE (type), DECL_SIZE (field))\n+\t  /* Partial int types (e.g. __int20) may have TYPE_SIZE equal to\n+\t     wider types (e.g. int32), despite precision being less.  Ensure\n+\t     that the TYPE_MODE of the struct does not get set to the partial\n+\t     int mode if there is a wider type also in the struct.  */\n+\t  && known_gt (GET_MODE_PRECISION (DECL_MODE (field)),\n+\t\t       GET_MODE_PRECISION (mode)))\n \tmode = DECL_MODE (field);\n \n       /* With some targets, it is sub-optimal to access an aligned\n@@ -1844,10 +1850,17 @@ compute_record_mode (tree type)\n     }\n \n   /* If we only have one real field; use its mode if that mode's size\n-     matches the type's size.  This only applies to RECORD_TYPE.  This\n-     does not apply to unions.  */\n+     matches the type's size.  This generally only applies to RECORD_TYPE.\n+     For UNION_TYPE, if the widest field is MODE_INT then use that mode.\n+     If the widest field is MODE_PARTIAL_INT, and the union will be passed\n+     by reference, then use that mode.  */\n   poly_uint64 type_size;\n-  if (TREE_CODE (type) == RECORD_TYPE\n+  if ((TREE_CODE (type) == RECORD_TYPE\n+       || (TREE_CODE (type) == UNION_TYPE\n+\t   && (GET_MODE_CLASS (mode) == MODE_INT\n+\t       || (GET_MODE_CLASS (mode) == MODE_PARTIAL_INT\n+\t\t   && targetm.calls.pass_by_reference (pack_cumulative_args (0),\n+\t\t\t\t\t\t       mode, type, 0)))))\n       && mode != VOIDmode\n       && poly_int_tree_p (TYPE_SIZE (type), &type_size)\n       && known_eq (GET_MODE_BITSIZE (mode), type_size))"}, {"sha": "51f1b6085f886db8f13be3d5be2ceb856e98da2e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ca29d5a35f8dd62f76df48e16bbac7320660c8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ca29d5a35f8dd62f76df48e16bbac7320660c8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c2ca29d5a35f8dd62f76df48e16bbac7320660c8", "patch": "@@ -1,6 +1,11 @@\n-2018-11-17  Nikolai Merinov <n.merinov@inango-systems.com>\n+2018-11-07  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n \n-         * gcc.dg/Wno-attribute-warning.c: New test.\n+\tPR c/87691\n+\t* gcc.target/msp430/pr87691.c: New test.\n+\n+2018-11-07  Nikolai Merinov  <n.merinov@inango-systems.com>\n+\n+\t* gcc.dg/Wno-attribute-warning.c: New test.\n \n 2018-11-07  Nathan Sidwell  <nathan@acm.org>\n "}, {"sha": "c00425d2452c6a613dab60526e4cf85a83702861", "filename": "gcc/testsuite/gcc.target/msp430/pr87691.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ca29d5a35f8dd62f76df48e16bbac7320660c8/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fpr87691.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ca29d5a35f8dd62f76df48e16bbac7320660c8/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fpr87691.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fpr87691.c?ref=c2ca29d5a35f8dd62f76df48e16bbac7320660c8", "patch": "@@ -0,0 +1,41 @@\n+/* PR 87691 - Test that a union containing __int20 and a float is not treated as\n+   20-bits in size.  */\n+\n+/* { dg-do compile } */\n+/* { dg-skip-if \"no __int20 for mcpu=msp430\" { *-*-* } { \"-mcpu=msp430\" } { \"\" } } */\n+/* { dg-final { scan-assembler-not \"MOVX.A\" } } */\n+\n+/* To move a 20-bit value from memory (using indexed or indirect register\n+   mode), onto the stack (also addressed using indexed or indirect register\n+   mode), MOVX.A must be used. MOVA does not support these addressing modes.\n+   Therefore, to check that the union is not manipulated as a 20-bit type,\n+   test that no MOVX.A instructions are present in the assembly.\n+\n+   MOVA is used to fill/spill u.i, but if the union is treated as 20 bits in\n+   size, MOVX.A would be used. No other __int20 operations are present\n+   in the source, so there will be no valid uses of MOVX.A in the resulting\n+   assembly.  */\n+\n+union U1\n+{\n+  float f;\n+  __int20 i;\n+};\n+\n+union U2\n+{\n+  __int20 i;\n+  float f;\n+};\n+\n+float foo1 (union U1 u)\n+{\n+  u.i += 42;\n+  return u.f;\n+}\n+\n+float foo2 (union U2 u)\n+{\n+  u.i += 42;\n+  return u.f;\n+}"}]}