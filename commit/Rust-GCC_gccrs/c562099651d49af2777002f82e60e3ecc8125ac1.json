{"sha": "c562099651d49af2777002f82e60e3ecc8125ac1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU2MjA5OTY1MWQ0OWFmMjc3NzAwMmY4MmU2MGUzZWNjODEyNWFjMQ==", "commit": {"author": {"name": "Geoff Keating", "email": "geoffk@cygnus.com", "date": "2000-10-06T04:51:47Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2000-10-06T04:51:47Z"}, "message": "tree.c (tree_size): New function split out of copy_node.\n\n        * tree.c (tree_size): New function split out of copy_node.\n        (make_node): Remove obstack handling.  Use tree_size.\n        (copy_node): Use tree_size.\n        * tree.h: Prototype tree_size.\n\nFrom-SVN: r36742", "tree": {"sha": "3106595f245243c7928a9e3c10c5acdec022b2e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3106595f245243c7928a9e3c10c5acdec022b2e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c562099651d49af2777002f82e60e3ecc8125ac1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c562099651d49af2777002f82e60e3ecc8125ac1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c562099651d49af2777002f82e60e3ecc8125ac1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c562099651d49af2777002f82e60e3ecc8125ac1/comments", "author": null, "committer": null, "parents": [{"sha": "37dad58d3ceb6a8e06c6d0b2196555356ac02c4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37dad58d3ceb6a8e06c6d0b2196555356ac02c4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37dad58d3ceb6a8e06c6d0b2196555356ac02c4a"}], "stats": {"total": 229, "additions": 90, "deletions": 139}, "files": [{"sha": "85e2b6336ec46b39fdee3b20d5bc47b9ba5918f9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c562099651d49af2777002f82e60e3ecc8125ac1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c562099651d49af2777002f82e60e3ecc8125ac1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c562099651d49af2777002f82e60e3ecc8125ac1", "patch": "@@ -1,3 +1,10 @@\n+2000-10-05  Geoff Keating  <geoffk@cygnus.com>\n+\n+\t* tree.c (tree_size): New function split out of copy_node.\n+\t(make_node): Remove obstack handling.  Use tree_size.\n+\t(copy_node): Use tree_size.\n+\t* tree.h: Prototype tree_size.\n+\n 2000-10-05  Richard Henderson  <rth@cygnus.com>\n \n \t* diagnostic.c (output_format): Add missing break."}, {"sha": "8def9fd6a634cbf17de5a52de05e2d2260aeb9a4", "filename": "gcc/tree.c", "status": "modified", "additions": 78, "deletions": 139, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c562099651d49af2777002f82e60e3ecc8125ac1/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c562099651d49af2777002f82e60e3ecc8125ac1/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=c562099651d49af2777002f82e60e3ecc8125ac1", "patch": "@@ -897,6 +897,63 @@ init_tree_codes ()\n   ggc_add_string_root (&built_in_filename, 1);\n }\n \n+/* Compute the number of bytes occupied by 'node'.  This routine only\n+   looks at TREE_CODE and, if the code is TREE_VEC, TREE_VEC_LENGTH.  */\n+size_t\n+tree_size (node)\n+     tree node;\n+{\n+  enum tree_code code = TREE_CODE (node);\n+\n+  switch (TREE_CODE_CLASS (code))\n+    {\n+    case 'd':  /* A decl node */\n+      return sizeof (struct tree_decl);\n+\n+    case 't':  /* a type node */\n+      return sizeof (struct tree_type);\n+\n+    case 'b':  /* a lexical block node */\n+      return sizeof (struct tree_block);\n+\n+    case 'r':  /* a reference */\n+    case 'e':  /* an expression */\n+    case 's':  /* an expression with side effects */\n+    case '<':  /* a comparison expression */\n+    case '1':  /* a unary arithmetic expression */\n+    case '2':  /* a binary arithmetic expression */\n+      return (sizeof (struct tree_exp)\n+\t      + (TREE_CODE_LENGTH (code) - 1) * sizeof (char *));\n+\n+    case 'c':  /* a constant */\n+      /* We can't use TREE_CODE_LENGTH for INTEGER_CST, since the number of\n+\t words is machine-dependent due to varying length of HOST_WIDE_INT,\n+\t which might be wider than a pointer (e.g., long long).  Similarly\n+\t for REAL_CST, since the number of words is machine-dependent due\n+\t to varying size and alignment of `double'.  */\n+      if (code == INTEGER_CST)\n+\treturn sizeof (struct tree_int_cst);\n+      else if (code == REAL_CST)\n+\treturn sizeof (struct tree_real_cst);\n+      else\n+\treturn (sizeof (struct tree_common)\n+\t\t+ TREE_CODE_LENGTH (code) * sizeof (char *));\n+\n+    case 'x':  /* something random, like an identifier.  */\n+      {\n+\t  size_t length;\n+\t  length = (sizeof (struct tree_common)\n+\t\t    + TREE_CODE_LENGTH (code) * sizeof (char *));\n+\t  if (code == TREE_VEC)\n+\t    length += (TREE_VEC_LENGTH (node) - 1) * sizeof (char *);\n+\t  return length;\n+      }\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n /* Return a newly allocated node of code CODE.\n    Initialize the node's unique id and its TREE_PERMANENT flag.\n    Note that if garbage collection is in use, TREE_PERMANENT will\n@@ -912,117 +969,55 @@ make_node (code)\n {\n   register tree t;\n   register int type = TREE_CODE_CLASS (code);\n-  register int length = 0;\n-  register struct obstack *obstack = current_obstack;\n+  register size_t length;\n #ifdef GATHER_STATISTICS\n   register tree_node_kind kind;\n #endif\n+  struct tree_common ttmp;\n+  \n+  /* We can't allocate a TREE_VEC without knowing how many elements\n+     it will have.  */\n+  if (code == TREE_VEC)\n+    abort ();\n+  \n+  TREE_SET_CODE ((tree)&ttmp, code);\n+  length = tree_size ((tree)&ttmp);\n \n+#ifdef GATHER_STATISTICS\n   switch (type)\n     {\n     case 'd':  /* A decl node */\n-#ifdef GATHER_STATISTICS\n       kind = d_kind;\n-#endif\n-      length = sizeof (struct tree_decl);\n-      /* All decls in an inline function need to be saved.  */\n-      if (obstack != &permanent_obstack)\n-\tobstack = saveable_obstack;\n-\n-      /* PARM_DECLs go on the context of the parent. If this is a nested\n-\t function, then we must allocate the PARM_DECL on the parent's\n-\t obstack, so that they will live to the end of the parent's\n-\t closing brace.  This is necessary in case we try to inline the\n-\t function into its parent.\n-\n-\t PARM_DECLs of top-level functions do not have this problem.  However,\n-\t we allocate them where we put the FUNCTION_DECL for languages such as\n-\t Ada that need to consult some flags in the PARM_DECLs of the function\n-\t when calling it.\n-\n-\t See comment in restore_tree_status for why we can't put this\n-\t in function_obstack.  */\n-      if (code == PARM_DECL && obstack != &permanent_obstack)\n-\t{\n-\t  tree context = 0;\n-\t  if (current_function_decl)\n-\t    context = decl_function_context (current_function_decl);\n-\n-\t  if (context)\n-\t    obstack\n-\t      = find_function_data (context)->function_maybepermanent_obstack;\n-\t}\n       break;\n \n     case 't':  /* a type node */\n-#ifdef GATHER_STATISTICS\n       kind = t_kind;\n-#endif\n-      length = sizeof (struct tree_type);\n-      /* All data types are put where we can preserve them if nec.  */\n-      if (obstack != &permanent_obstack)\n-\tobstack = all_types_permanent ? &permanent_obstack : saveable_obstack;\n       break;\n \n     case 'b':  /* a lexical block */\n-#ifdef GATHER_STATISTICS\n       kind = b_kind;\n-#endif\n-      length = sizeof (struct tree_block);\n-      /* All BLOCK nodes are put where we can preserve them if nec.  */\n-      if (obstack != &permanent_obstack)\n-\tobstack = saveable_obstack;\n       break;\n \n     case 's':  /* an expression with side effects */\n-#ifdef GATHER_STATISTICS\n       kind = s_kind;\n-      goto usual_kind;\n-#endif\n+      break;\n+\n     case 'r':  /* a reference */\n-#ifdef GATHER_STATISTICS\n       kind = r_kind;\n-      goto usual_kind;\n-#endif\n+      break;\n+\n     case 'e':  /* an expression */\n     case '<':  /* a comparison expression */\n     case '1':  /* a unary arithmetic expression */\n     case '2':  /* a binary arithmetic expression */\n-#ifdef GATHER_STATISTICS\n       kind = e_kind;\n-    usual_kind:\n-#endif\n-      obstack = expression_obstack;\n-      /* All BIND_EXPR nodes are put where we can preserve them if nec.  */\n-      if (code == BIND_EXPR && obstack != &permanent_obstack)\n-\tobstack = saveable_obstack;\n-      length = sizeof (struct tree_exp)\n-\t+ (TREE_CODE_LENGTH (code) - 1) * sizeof (char *);\n       break;\n \n     case 'c':  /* a constant */\n-#ifdef GATHER_STATISTICS\n       kind = c_kind;\n-#endif\n-      obstack = expression_obstack;\n-\n-      /* We can't use TREE_CODE_LENGTH for INTEGER_CST, since the number of\n-\t words is machine-dependent due to varying length of HOST_WIDE_INT,\n-\t which might be wider than a pointer (e.g., long long).  Similarly\n-\t for REAL_CST, since the number of words is machine-dependent due\n-\t to varying size and alignment of `double'.  */\n-\n-      if (code == INTEGER_CST)\n-\tlength = sizeof (struct tree_int_cst);\n-      else if (code == REAL_CST)\n-\tlength = sizeof (struct tree_real_cst);\n-      else\n-\tlength = sizeof (struct tree_common)\n-\t  + TREE_CODE_LENGTH (code) * sizeof (char *);\n       break;\n \n     case 'x':  /* something random, like an identifier.  */\n-#ifdef GATHER_STATISTICS\n       if (code == IDENTIFIER_NODE)\n \tkind = id_kind;\n       else if (code == OP_IDENTIFIER)\n@@ -1031,30 +1026,20 @@ make_node (code)\n \tkind = vec_kind;\n       else\n \tkind = x_kind;\n-#endif\n-      length = sizeof (struct tree_common)\n-\t+ TREE_CODE_LENGTH (code) * sizeof (char *);\n-      /* Identifier nodes are always permanent since they are\n-\t unique in a compiler run.  */\n-      if (code == IDENTIFIER_NODE) obstack = &permanent_obstack;\n       break;\n \n     default:\n       abort ();\n     }\n \n-  if (ggc_p)\n-    t = ggc_alloc_tree (length);\n-  else\n-    t = (tree) obstack_alloc (obstack, length);\n-\n-  memset ((PTR) t, 0, length);\n-\n-#ifdef GATHER_STATISTICS\n   tree_node_counts[(int) kind]++;\n   tree_node_sizes[(int) kind] += length;\n #endif\n \n+  t = ggc_alloc_tree (length);\n+\n+  memset ((PTR) t, 0, length);\n+\n   TREE_SET_CODE (t, code);\n   TREE_SET_PERMANENT (t);\n \n@@ -1084,7 +1069,6 @@ make_node (code)\n       TYPE_ALIGN (t) = 1;\n       TYPE_USER_ALIGN (t) = 0;\n       TYPE_MAIN_VARIANT (t) = t;\n-      TYPE_OBSTACK (t) = obstack;\n       TYPE_ATTRIBUTES (t) = NULL_TREE;\n #ifdef SET_DEFAULT_TYPE_ATTRIBUTES\n       SET_DEFAULT_TYPE_ATTRIBUTES (t);\n@@ -1150,54 +1134,9 @@ copy_node (node)\n {\n   register tree t;\n   register enum tree_code code = TREE_CODE (node);\n-  register int length = 0;\n-\n-  switch (TREE_CODE_CLASS (code))\n-    {\n-    case 'd':  /* A decl node */\n-      length = sizeof (struct tree_decl);\n-      break;\n-\n-    case 't':  /* a type node */\n-      length = sizeof (struct tree_type);\n-      break;\n-\n-    case 'b':  /* a lexical block node */\n-      length = sizeof (struct tree_block);\n-      break;\n-\n-    case 'r':  /* a reference */\n-    case 'e':  /* an expression */\n-    case 's':  /* an expression with side effects */\n-    case '<':  /* a comparison expression */\n-    case '1':  /* a unary arithmetic expression */\n-    case '2':  /* a binary arithmetic expression */\n-      length = sizeof (struct tree_exp)\n-\t+ (TREE_CODE_LENGTH (code) - 1) * sizeof (char *);\n-      break;\n-\n-    case 'c':  /* a constant */\n-      /* We can't use TREE_CODE_LENGTH for INTEGER_CST, since the number of\n-\t words is machine-dependent due to varying length of HOST_WIDE_INT,\n-\t which might be wider than a pointer (e.g., long long).  Similarly\n-\t for REAL_CST, since the number of words is machine-dependent due\n-\t to varying size and alignment of `double'.  */\n-      if (code == INTEGER_CST)\n-\tlength = sizeof (struct tree_int_cst);\n-      else if (code == REAL_CST)\n-\tlength = sizeof (struct tree_real_cst);\n-      else\n-\tlength = (sizeof (struct tree_common)\n-\t\t  + TREE_CODE_LENGTH (code) * sizeof (char *));\n-      break;\n-\n-    case 'x':  /* something random, like an identifier.  */\n-      length = sizeof (struct tree_common)\n-\t+ TREE_CODE_LENGTH (code) * sizeof (char *);\n-      if (code == TREE_VEC)\n-\tlength += (TREE_VEC_LENGTH (node) - 1) * sizeof (char *);\n-    }\n+  register size_t length;\n \n+  length = tree_size (node);\n   if (ggc_p)\n     t = ggc_alloc_tree (length);\n   else"}, {"sha": "74c566c85d64d4e69d9e666cb7fe1e2790b4806c", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c562099651d49af2777002f82e60e3ecc8125ac1/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c562099651d49af2777002f82e60e3ecc8125ac1/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c562099651d49af2777002f82e60e3ecc8125ac1", "patch": "@@ -1863,6 +1863,11 @@ extern char *permalloc\t\t\tPARAMS ((int));\n extern char *savealloc\t\t\tPARAMS ((int));\n extern char *expralloc\t\t\tPARAMS ((int));\n \n+/* Compute the number of bytes occupied by 'node'.  This routine only\n+   looks at TREE_CODE and, if the code is TREE_VEC, TREE_VEC_LENGTH.  */\n+\n+extern size_t tree_size\t\t\tPARAMS ((tree));\n+\n /* Lowest level primitive for allocating a node.\n    The TREE_CODE is the only argument.  Contents are initialized\n    to zero except for a few of the common fields.  */"}]}