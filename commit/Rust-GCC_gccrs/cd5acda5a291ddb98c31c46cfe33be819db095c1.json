{"sha": "cd5acda5a291ddb98c31c46cfe33be819db095c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q1YWNkYTVhMjkxZGRiOThjMzFjNDZjZmUzM2JlODE5ZGIwOTVjMQ==", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2017-04-27T10:14:56Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T10:14:56Z"}, "message": "exp_util.ads, [...] (Evaluate_Name): Force evaluation of expression being qualified...\n\n2017-04-27  Yannick Moy  <moy@adacore.com>\n\n\t* exp_util.ads, exp_util.adb (Evaluate_Name): Force evaluation\n\tof expression being qualified, when not an object name, or else\n\tevaluate the underlying name.\n\nFrom-SVN: r247311", "tree": {"sha": "d9f5bcbde030c8aa3a65ec97230e933f221bb923", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9f5bcbde030c8aa3a65ec97230e933f221bb923"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd5acda5a291ddb98c31c46cfe33be819db095c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd5acda5a291ddb98c31c46cfe33be819db095c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd5acda5a291ddb98c31c46cfe33be819db095c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd5acda5a291ddb98c31c46cfe33be819db095c1/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7e6060af807ad72d199506f9f61a8a70a27eccda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e6060af807ad72d199506f9f61a8a70a27eccda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e6060af807ad72d199506f9f61a8a70a27eccda"}], "stats": {"total": 124, "additions": 73, "deletions": 51}, "files": [{"sha": "2362ccf55c206b0ce12d05caa6cd1c89827635ba", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5acda5a291ddb98c31c46cfe33be819db095c1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5acda5a291ddb98c31c46cfe33be819db095c1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=cd5acda5a291ddb98c31c46cfe33be819db095c1", "patch": "@@ -1,3 +1,9 @@\n+2017-04-27  Yannick Moy  <moy@adacore.com>\n+\n+\t* exp_util.ads, exp_util.adb (Evaluate_Name): Force evaluation\n+\tof expression being qualified, when not an object name, or else\n+\tevaluate the underlying name.\n+\n 2017-04-27  Jerome Lambourg  <lambourg@adacore.com>\n \n \t* bindusg.adb, bindgen.adb, gnatbind.adb, opt.ads: add -nognarl switch."}, {"sha": "c80cd39a885e0519b6ec5d5e376d0431d0ad5dc1", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 62, "deletions": 49, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5acda5a291ddb98c31c46cfe33be819db095c1/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5acda5a291ddb98c31c46cfe33be819db095c1/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=cd5acda5a291ddb98c31c46cfe33be819db095c1", "patch": "@@ -4724,72 +4724,85 @@ package body Exp_Util is\n    -------------------\n \n    procedure Evaluate_Name (Nam : Node_Id) is\n-      K : constant Node_Kind := Nkind (Nam);\n-\n    begin\n-      --  For an explicit dereference, we simply force the evaluation of the\n-      --  name expression. The dereference provides a value that is the address\n-      --  for the renamed object, and it is precisely this value that we want\n-      --  to preserve.\n+      --  For an attribute reference or an indexed component, evaluate the\n+      --  prefix, which is itself a name, recursively, and then force the\n+      --  evaluation of all the subscripts (or attribute expressions).\n \n-      if K = N_Explicit_Dereference then\n-         Force_Evaluation (Prefix (Nam));\n+      case Nkind (Nam) is\n+         when N_Attribute_Reference\n+            | N_Indexed_Component\n+         =>\n+            Evaluate_Name (Prefix (Nam));\n \n-      --  For a selected component, we simply evaluate the prefix\n+            declare\n+               E : Node_Id;\n \n-      elsif K = N_Selected_Component then\n-         Evaluate_Name (Prefix (Nam));\n+            begin\n+               E := First (Expressions (Nam));\n+               while Present (E) loop\n+                  Force_Evaluation (E);\n \n-      --  For an indexed component, or an attribute reference, we evaluate the\n-      --  prefix, which is itself a name, recursively, and then force the\n-      --  evaluation of all the subscripts (or attribute expressions).\n+                  if Original_Node (E) /= E then\n+                     Set_Do_Range_Check (E,\n+                                         Do_Range_Check (Original_Node (E)));\n+                  end if;\n \n-      elsif Nkind_In (K, N_Indexed_Component, N_Attribute_Reference) then\n-         Evaluate_Name (Prefix (Nam));\n+                  Next (E);\n+               end loop;\n+            end;\n \n-         declare\n-            E : Node_Id;\n+         --  For an explicit dereference, we simply force the evaluation of\n+         --  the name expression. The dereference provides a value that is the\n+         --  address for the renamed object, and it is precisely this value\n+         --  that we want to preserve.\n \n-         begin\n-            E := First (Expressions (Nam));\n-            while Present (E) loop\n-               Force_Evaluation (E);\n+         when N_Explicit_Dereference =>\n+            Force_Evaluation (Prefix (Nam));\n \n-               if Original_Node (E) /= E then\n-                  Set_Do_Range_Check (E, Do_Range_Check (Original_Node (E)));\n-               end if;\n+         --  For a function call, we evaluate the call\n \n-               Next (E);\n-            end loop;\n-         end;\n+         when N_Function_Call =>\n+            Force_Evaluation (Nam);\n \n-      --  For a slice, we evaluate the prefix, as for the indexed component\n-      --  case and then, if there is a range present, either directly or as the\n-      --  constraint of a discrete subtype indication, we evaluate the two\n-      --  bounds of this range.\n+         --  For a qualified expression, we evaluate the underlying object\n+         --  name if any, otherwise we force the evaluation of the underlying\n+         --  expression.\n \n-      elsif K = N_Slice then\n-         Evaluate_Name (Prefix (Nam));\n-         Evaluate_Slice_Bounds (Nam);\n+         when N_Qualified_Expression =>\n+            if Is_Object_Reference (Expression (Nam)) then\n+               Evaluate_Name (Expression (Nam));\n+            else\n+               Force_Evaluation (Expression (Nam));\n+            end if;\n \n-      --  For a type conversion, the expression of the conversion must be the\n-      --  name of an object, and we simply need to evaluate this name.\n+         --  For a selected component, we simply evaluate the prefix\n \n-      elsif K = N_Type_Conversion then\n-         Evaluate_Name (Expression (Nam));\n+         when N_Selected_Component =>\n+            Evaluate_Name (Prefix (Nam));\n \n-      --  For a function call, we evaluate the call\n+         --  For a slice, we evaluate the prefix, as for the indexed component\n+         --  case and then, if there is a range present, either directly or as\n+         --  the constraint of a discrete subtype indication, we evaluate the\n+         --  two bounds of this range.\n \n-      elsif K = N_Function_Call then\n-         Force_Evaluation (Nam);\n+         when N_Slice =>\n+            Evaluate_Name (Prefix (Nam));\n+            Evaluate_Slice_Bounds (Nam);\n \n-      --  The remaining cases are direct name, operator symbol and character\n-      --  literal. In all these cases, we do nothing, since we want to\n-      --  reevaluate each time the renamed object is used.\n+         --  For a type conversion, the expression of the conversion must be\n+         --  the name of an object, and we simply need to evaluate this name.\n \n-      else\n-         return;\n-      end if;\n+         when N_Type_Conversion =>\n+            Evaluate_Name (Expression (Nam));\n+\n+         --  The remaining cases are direct name, operator symbol and character\n+         --  literal. In all these cases, we do nothing, since we want to\n+         --  reevaluate each time the renamed object is used.\n+\n+         when others =>\n+            null;\n+      end case;\n    end Evaluate_Name;\n \n    ---------------------------\n@@ -6933,7 +6946,7 @@ package body Exp_Util is\n             --  existing actions of the expression with actions, and should\n             --  never reach here: if actions are inserted on a statement\n             --  within the Actions of an expression with actions, or on some\n-            --  sub-expression of such a statement, then the outermost proper\n+            --  subexpression of such a statement, then the outermost proper\n             --  insertion point is right before the statement, and we should\n             --  never climb up as far as the N_Expression_With_Actions itself.\n "}, {"sha": "e5fff4002e294aa85d093bde8327376742f243f5", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5acda5a291ddb98c31c46cfe33be819db095c1/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5acda5a291ddb98c31c46cfe33be819db095c1/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=cd5acda5a291ddb98c31c46cfe33be819db095c1", "patch": "@@ -518,8 +518,11 @@ package Exp_Util is\n \n    procedure Evaluate_Name (Nam : Node_Id);\n    --  Remove all side effects from a name which appears as part of an object\n-   --  renaming declaration. More comments are needed here that explain how\n-   --  this differs from Force_Evaluation and Remove_Side_Effects ???\n+   --  renaming declaration. Similarly to Force_Evaluation, it removes the\n+   --  side effects and captures the values of the variables, except for the\n+   --  variable being renamed. Hence this differs from Force_Evaluation and\n+   --  Remove_Side_Effects (but it calls Force_Evaluation on subexpressions\n+   --  whose value needs to be fixed).\n \n    procedure Evolve_And_Then (Cond : in out Node_Id; Cond1 : Node_Id);\n    --  Rewrites Cond with the expression: Cond and then Cond1. If Cond is"}]}