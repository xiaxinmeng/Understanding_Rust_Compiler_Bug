{"sha": "24012539ae3410174b3e755b580a16de826d56a6", "node_id": "C_kwDOANBUbNoAKDI0MDEyNTM5YWUzNDEwMTc0YjNlNzU1YjU4MGExNmRlODI2ZDU2YTY", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-07-25T14:47:48Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-08-02T12:50:26Z"}, "message": "Implement basic range operators to enable floating point VRP.\n\nWithout further ado, here is the implementation for floating point\nrange operators, plus the switch to enable all ranger clients to\nhandle floats.\n\nThese are bare bone implementations good enough for relation operators\nto work, while keeping the NAN bits up to date in the frange.  There\nis also minimal support for keeping track of +-INF when it is obvious.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* range-op-float.cc (finite_operands_p): New.\n\t(frelop_early_resolve): New.\n\t(default_frelop_fold_range): New.\n\t(class foperator_equal): New.\n\t(class foperator_not_equal): New.\n\t(class foperator_lt): New.\n\t(class foperator_le): New.\n\t(class foperator_gt): New.\n\t(class foperator_ge): New.\n\t(class foperator_unordered): New.\n\t(class foperator_ordered): New.\n\t(class foperator_relop_unknown): New.\n\t(floating_op_table::floating_op_table): Add above classes to\n\tfloating op table.\n\t* value-range.h (frange::supports_p): Enable.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/opt/pr94589-2.C: XFAIL.\n\t* gcc.dg/tree-ssa/vrp-float-1.c: New test.\n\t* gcc.dg/tree-ssa/vrp-float-11.c: New test.\n\t* gcc.dg/tree-ssa/vrp-float-3.c: New test.\n\t* gcc.dg/tree-ssa/vrp-float-4.c: New test.\n\t* gcc.dg/tree-ssa/vrp-float-6.c: New test.\n\t* gcc.dg/tree-ssa/vrp-float-7.c: New test.\n\t* gcc.dg/tree-ssa/vrp-float-8.c: New test.", "tree": {"sha": "7dfdd51c10536f6853c7ac7854adac53ea6d0a93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7dfdd51c10536f6853c7ac7854adac53ea6d0a93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24012539ae3410174b3e755b580a16de826d56a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24012539ae3410174b3e755b580a16de826d56a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24012539ae3410174b3e755b580a16de826d56a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24012539ae3410174b3e755b580a16de826d56a6/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f7e187e7fa4175204dac0d2f9d468d61762c11b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f7e187e7fa4175204dac0d2f9d468d61762c11b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f7e187e7fa4175204dac0d2f9d468d61762c11b"}], "stats": {"total": 708, "additions": 705, "deletions": 3}, "files": [{"sha": "4fbd96a74797426d0017ba072f3b21395021c21e", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 564, "deletions": 0, "changes": 564, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24012539ae3410174b3e755b580a16de826d56a6/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24012539ae3410174b3e755b580a16de826d56a6/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=24012539ae3410174b3e755b580a16de826d56a6", "patch": "@@ -150,6 +150,50 @@ range_operator_float::op1_op2_relation (const irange &lhs ATTRIBUTE_UNUSED) cons\n   return VREL_VARYING;\n }\n \n+// Return TRUE if OP1 and OP2 are known to be free of NANs.\n+\n+static inline bool\n+finite_operands_p (const frange &op1, const frange &op2)\n+{\n+  return (flag_finite_math_only\n+\t  || (op1.get_nan ().no_p ()\n+\t      && op2.get_nan ().no_p ()));\n+}\n+\n+// Floating version of relop_early_resolve that takes into account NAN\n+// and -ffinite-math-only.\n+\n+inline bool\n+frelop_early_resolve (irange &r, tree type,\n+\t\t      const frange &op1, const frange &op2,\n+\t\t      relation_kind rel, relation_kind my_rel)\n+{\n+  // If either operand is undefined, return VARYING.\n+  if (empty_range_varying (r, type, op1, op2))\n+    return true;\n+\n+  // We can fold relations from the oracle when we know both operands\n+  // are free of NANs, or when -ffinite-math-only.\n+  return (finite_operands_p (op1, op2)\n+\t  && relop_early_resolve (r, type, op1, op2, rel, my_rel));\n+}\n+\n+// Default implementation of fold_range for relational operators.\n+// This amounts to passing on any known relations from the oracle, iff\n+// we know the operands are not NAN or -ffinite-math-only holds.\n+\n+static inline bool\n+default_frelop_fold_range (irange &r, tree type,\n+\t\t\t  const frange &op1, const frange &op2,\n+\t\t\t  relation_kind rel, relation_kind my_rel)\n+{\n+  if (frelop_early_resolve (r, type, op1, op2, rel, my_rel))\n+    return true;\n+\n+  r.set_varying (type);\n+  return true;\n+}\n+\n class foperator_identity : public range_operator_float\n {\n   using range_operator_float::fold_range;\n@@ -172,6 +216,509 @@ class foperator_identity : public range_operator_float\n public:\n } fop_identity;\n \n+class foperator_equal : public range_operator_float\n+{\n+  using range_operator_float::fold_range;\n+  using range_operator_float::op1_range;\n+  using range_operator_float::op2_range;\n+\n+  bool fold_range (irange &r, tree type,\n+\t\t   const frange &op1, const frange &op2,\n+\t\t   relation_kind rel) const final override\n+  {\n+    return default_frelop_fold_range (r, type, op1, op2, rel, VREL_EQ);\n+  }\n+  relation_kind op1_op2_relation (const irange &lhs) const final override\n+  {\n+    return equal_op1_op2_relation (lhs);\n+  }\n+  bool op1_range (frange &r, tree type,\n+\t\t  const irange &lhs, const frange &op2,\n+\t\t  relation_kind rel) const final override;\n+  bool op2_range (frange &r, tree type,\n+\t\t  const irange &lhs, const frange &op1,\n+\t\t  relation_kind rel) const final override\n+  {\n+    return op1_range (r, type, lhs, op1, rel);\n+  }\n+} fop_equal;\n+\n+bool\n+foperator_equal::op1_range (frange &r, tree type,\n+\t\t\t    const irange &lhs,\n+\t\t\t    const frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t    relation_kind rel) const\n+{\n+  switch (get_bool_state (r, lhs, type))\n+    {\n+    case BRS_TRUE:\n+      r.set_varying (type);\n+      // The TRUE side of op1 == op2 implies op1 is !NAN.\n+      r.set_nan (fp_prop::NO);\n+      break;\n+\n+    case BRS_FALSE:\n+      r.set_varying (type);\n+      // The FALSE side of op1 == op1 implies op1 is a NAN.\n+      if (rel == VREL_EQ)\n+\tr.set_nan (fp_prop::YES);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return true;\n+}\n+\n+class foperator_not_equal : public range_operator_float\n+{\n+  using range_operator_float::fold_range;\n+  using range_operator_float::op1_range;\n+\n+  bool fold_range (irange &r, tree type,\n+\t\t   const frange &op1, const frange &op2,\n+\t\t   relation_kind rel) const final override\n+  {\n+    return default_frelop_fold_range (r, type, op1, op2, rel, VREL_NE);\n+  }\n+  relation_kind op1_op2_relation (const irange &lhs) const final override\n+  {\n+    return not_equal_op1_op2_relation (lhs);\n+  }\n+  bool op1_range (frange &r, tree type,\n+\t\t  const irange &lhs, const frange &op2,\n+\t\t  relation_kind rel) const final override;\n+} fop_not_equal;\n+\n+bool\n+foperator_not_equal::op1_range (frange &r, tree type,\n+\t\t\t\tconst irange &lhs,\n+\t\t\t\tconst frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t\trelation_kind) const\n+{\n+  switch (get_bool_state (r, lhs, type))\n+    {\n+    case BRS_TRUE:\n+      r.set_varying (type);\n+      break;\n+\n+    case BRS_FALSE:\n+      r.set_varying (type);\n+      // The FALSE side of op1 != op2 implies op1 is !NAN.\n+      r.set_nan (fp_prop::NO);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return true;\n+}\n+\n+class foperator_lt : public range_operator_float\n+{\n+  using range_operator_float::fold_range;\n+  using range_operator_float::op1_range;\n+  using range_operator_float::op2_range;\n+\n+  bool fold_range (irange &r, tree type,\n+\t\t   const frange &op1, const frange &op2,\n+\t\t   relation_kind rel) const final override\n+  {\n+    return default_frelop_fold_range (r, type, op1, op2, rel, VREL_LT);\n+  }\n+  relation_kind op1_op2_relation (const irange &lhs) const final override\n+  {\n+    return lt_op1_op2_relation (lhs);\n+  }\n+  bool op1_range (frange &r, tree type,\n+\t\t  const irange &lhs, const frange &op2,\n+\t\t  relation_kind rel) const final override;\n+  bool op2_range (frange &r, tree type,\n+\t\t  const irange &lhs, const frange &op1,\n+\t\t  relation_kind rel) const final override;\n+} fop_lt;\n+\n+bool\n+foperator_lt::op1_range (frange &r,\n+\t\t\t tree type,\n+\t\t\t const irange &lhs,\n+\t\t\t const frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t relation_kind) const\n+{\n+  switch (get_bool_state (r, lhs, type))\n+    {\n+    case BRS_TRUE:\n+      r.set_varying (type);\n+      // The TRUE side of op1 < op2 implies op1 is !NAN and !INF.\n+      r.set_nan (fp_prop::NO);\n+      r.set_inf (fp_prop::NO);\n+      break;\n+\n+    case BRS_FALSE:\n+      r.set_varying (type);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return true;\n+}\n+\n+bool\n+foperator_lt::op2_range (frange &r,\n+\t\t\t tree type,\n+\t\t\t const irange &lhs,\n+\t\t\t const frange &op1 ATTRIBUTE_UNUSED,\n+\t\t\t relation_kind) const\n+{\n+  switch (get_bool_state (r, lhs, type))\n+    {\n+    case BRS_TRUE:\n+      r.set_varying (type);\n+      // The TRUE side of op1 < op2 implies op2 is !NAN and !NINF.\n+      r.set_nan (fp_prop::NO);\n+      r.set_ninf (fp_prop::NO);\n+      break;\n+\n+    case BRS_FALSE:\n+      r.set_varying (type);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return true;\n+}\n+\n+class foperator_le : public range_operator_float\n+{\n+  using range_operator_float::fold_range;\n+  using range_operator_float::op1_range;\n+  using range_operator_float::op2_range;\n+\n+  bool fold_range (irange &r, tree type,\n+\t\t   const frange &op1, const frange &op2,\n+\t\t   relation_kind rel) const final override\n+  {\n+    return default_frelop_fold_range (r, type, op1, op2, rel, VREL_LE);\n+  }\n+  relation_kind op1_op2_relation (const irange &lhs) const final override\n+  {\n+    return le_op1_op2_relation (lhs);\n+  }\n+  bool op1_range (frange &r, tree type,\n+\t\t  const irange &lhs, const frange &op2,\n+\t\t  relation_kind rel) const final override;\n+  bool op2_range (frange &r, tree type,\n+\t\t  const irange &lhs, const frange &op1,\n+\t\t  relation_kind rel) const final override\n+  {\n+    return op1_range (r, type, lhs, op1, rel);\n+  }\n+} fop_le;\n+\n+bool\n+foperator_le::op1_range (frange &r,\n+\t\t\t tree type,\n+\t\t\t const irange &lhs,\n+\t\t\t const frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t relation_kind) const\n+{\n+  switch (get_bool_state (r, lhs, type))\n+    {\n+    case BRS_TRUE:\n+      r.set_varying (type);\n+      // The TRUE side of op1 <= op2 implies op1 is !NAN.\n+      r.set_nan (fp_prop::NO);\n+      break;\n+\n+    case BRS_FALSE:\n+      r.set_varying (type);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return true;\n+}\n+\n+class foperator_gt : public range_operator_float\n+{\n+  using range_operator_float::fold_range;\n+  using range_operator_float::op1_range;\n+  using range_operator_float::op2_range;\n+\n+  bool fold_range (irange &r, tree type,\n+\t\t   const frange &op1, const frange &op2,\n+\t\t   relation_kind rel) const final override\n+  {\n+    return default_frelop_fold_range (r, type, op1, op2, rel, VREL_GT);\n+  }\n+  relation_kind op1_op2_relation (const irange &lhs) const final override\n+  {\n+    return gt_op1_op2_relation (lhs);\n+  }\n+  bool op1_range (frange &r, tree type,\n+\t\t  const irange &lhs, const frange &op2,\n+\t\t  relation_kind rel) const final override;\n+  bool op2_range (frange &r, tree type,\n+\t\t  const irange &lhs, const frange &op1,\n+\t\t  relation_kind rel) const final override;\n+} fop_gt;\n+\n+bool\n+foperator_gt::op1_range (frange &r,\n+\t\t\t tree type,\n+\t\t\t const irange &lhs,\n+\t\t\t const frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t relation_kind) const\n+{\n+  switch (get_bool_state (r, lhs, type))\n+    {\n+    case BRS_TRUE:\n+      r.set_varying (type);\n+      // The TRUE side of op1 > op2 implies op1 is !NAN and !NINF.\n+      r.set_nan (fp_prop::NO);\n+      r.set_ninf (fp_prop::NO);\n+      break;\n+\n+    case BRS_FALSE:\n+      r.set_varying (type);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return true;\n+}\n+\n+bool\n+foperator_gt::op2_range (frange &r,\n+\t\t\t tree type,\n+\t\t\t const irange &lhs,\n+\t\t\t const frange &op1 ATTRIBUTE_UNUSED,\n+\t\t\t relation_kind) const\n+{\n+  switch (get_bool_state (r, lhs, type))\n+    {\n+    case BRS_TRUE:\n+      r.set_varying (type);\n+      // The TRUE side of op1 > op2 implies op2 is !NAN and !INF.\n+      r.set_nan (fp_prop::NO);\n+      r.set_inf (fp_prop::NO);\n+      break;\n+\n+    case BRS_FALSE:\n+      r.set_varying (type);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return true;\n+}\n+\n+class foperator_ge : public range_operator_float\n+{\n+  using range_operator_float::fold_range;\n+  using range_operator_float::op1_range;\n+  using range_operator_float::op2_range;\n+\n+  bool fold_range (irange &r, tree type,\n+\t\t   const frange &op1, const frange &op2,\n+\t\t   relation_kind rel) const final override\n+  {\n+    return default_frelop_fold_range (r, type, op1, op2, rel, VREL_GE);\n+  }\n+  relation_kind op1_op2_relation (const irange &lhs) const final override\n+  {\n+    return ge_op1_op2_relation (lhs);\n+  }\n+  bool op1_range (frange &r, tree type,\n+\t\t  const irange &lhs, const frange &op2,\n+\t\t  relation_kind rel) const final override;\n+  bool op2_range (frange &r, tree type,\n+\t\t  const irange &lhs, const frange &op1,\n+\t\t  relation_kind rel) const final override\n+  {\n+    return op1_range (r, type, lhs, op1, rel);\n+  }\n+} fop_ge;\n+\n+bool\n+foperator_ge::op1_range (frange &r,\n+\t\t\t tree type,\n+\t\t\t const irange &lhs,\n+\t\t\t const frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t relation_kind) const\n+{\n+  switch (get_bool_state (r, lhs, type))\n+    {\n+    case BRS_TRUE:\n+      r.set_varying (type);\n+      // The TRUE side of op1 >= op2 implies op1 is !NAN.\n+      r.set_nan (fp_prop::NO);\n+      break;\n+\n+    case BRS_FALSE:\n+      r.set_varying (type);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return true;\n+}\n+\n+// UNORDERED_EXPR comparison.\n+\n+class foperator_unordered : public range_operator_float\n+{\n+  using range_operator_float::fold_range;\n+  using range_operator_float::op1_range;\n+  using range_operator_float::op2_range;\n+\n+public:\n+  bool fold_range (irange &r, tree type,\n+\t\t   const frange &op1, const frange &op2,\n+\t\t   relation_kind rel) const final override;\n+  bool op1_range (frange &r, tree type,\n+\t\t  const irange &lhs, const frange &op2,\n+\t\t  relation_kind rel) const final override;\n+  bool op2_range (frange &r, tree type,\n+\t\t  const irange &lhs, const frange &op1,\n+\t\t  relation_kind rel) const final override\n+  {\n+    return op1_range (r, type, lhs, op1, rel);\n+  }\n+} fop_unordered;\n+\n+bool\n+foperator_unordered::fold_range (irange &r, tree type,\n+\t\t\t\t const frange &op1, const frange &op2,\n+\t\t\t\t relation_kind) const\n+{\n+  // UNORDERED is TRUE if either operand is a NAN.\n+  if (op1.get_nan ().yes_p () || op2.get_nan ().yes_p ())\n+    r = range_true (type);\n+  // UNORDERED is FALSE if neither operand is a NAN.\n+  else if (op1.get_nan ().no_p () && op2.get_nan ().no_p ())\n+    r = range_false (type);\n+  else\n+    r = range_true_and_false (type);\n+  return true;\n+}\n+\n+bool\n+foperator_unordered::op1_range (frange &r, tree type,\n+\t\t\t\tconst irange &lhs,\n+\t\t\t\tconst frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t\trelation_kind) const\n+{\n+  switch (get_bool_state (r, lhs, type))\n+    {\n+    case BRS_TRUE:\n+      r.set_varying (type);\n+      // Since at least one operand must be NAN, if one of them is\n+      // not, the other must be.\n+      if (op2.get_nan ().no_p ())\n+\tr.set_nan (fp_prop::YES);\n+      break;\n+\n+    case BRS_FALSE:\n+      r.set_varying (type);\n+      // A false UNORDERED means both operands are !NAN.\n+      r.set_nan (fp_prop::NO);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return true;\n+}\n+\n+// ORDERED_EXPR comparison.\n+\n+class foperator_ordered : public range_operator_float\n+{\n+  using range_operator_float::fold_range;\n+  using range_operator_float::op1_range;\n+  using range_operator_float::op2_range;\n+\n+public:\n+  bool fold_range (irange &r, tree type,\n+\t\t   const frange &op1, const frange &op2,\n+\t\t   relation_kind rel) const final override;\n+  bool op1_range (frange &r, tree type,\n+\t\t  const irange &lhs, const frange &op2,\n+\t\t  relation_kind rel) const final override;\n+  bool op2_range (frange &r, tree type,\n+\t\t  const irange &lhs, const frange &op1,\n+\t\t  relation_kind rel) const final override\n+  {\n+    return op1_range (r, type, lhs, op1, rel);\n+  }\n+} fop_ordered;\n+\n+bool\n+foperator_ordered::fold_range (irange &r, tree type,\n+\t\t\t       const frange &op1, const frange &op2,\n+\t\t\t       relation_kind) const\n+{\n+  // ORDERED is TRUE if neither operand is a NAN.\n+  if (op1.get_nan ().no_p () && op2.get_nan ().no_p ())\n+    r = range_true (type);\n+  // ORDERED is FALSE if either operand is a NAN.\n+  else if (op1.get_nan ().yes_p () || op2.get_nan ().yes_p ())\n+    r = range_false (type);\n+  else\n+    r = range_true_and_false (type);\n+  return true;\n+}\n+\n+bool\n+foperator_ordered::op1_range (frange &r, tree type,\n+\t\t\t      const irange &lhs,\n+\t\t\t      const frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t      relation_kind rel) const\n+{\n+  switch (get_bool_state (r, lhs, type))\n+    {\n+    case BRS_TRUE:\n+      r.set_varying (type);\n+      // The TRUE side of op1 ORDERED op2 implies op1 is !NAN.\n+      r.set_nan (fp_prop::NO);\n+      break;\n+\n+    case BRS_FALSE:\n+      r.set_varying (type);\n+      // The FALSE side of op1 ORDERED op1 implies op1 is !NAN.\n+      if (rel == VREL_EQ)\n+\tr.set_nan (fp_prop::NO);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return true;\n+}\n+\n+// Placeholder for unimplemented relational operators.\n+\n+class foperator_relop_unknown : public range_operator_float\n+{\n+  using range_operator_float::fold_range;\n+\n+public:\n+  bool fold_range (irange &r, tree type,\n+\t\t   const frange &, const frange &,\n+\t\t   relation_kind) const final override\n+  {\n+    r.set_varying (type);\n+    return true;\n+  }\n+} fop_relop_unknown;\n+\n \n // Instantiate a range_op_table for floating point operations.\n static floating_op_table global_floating_table;\n@@ -185,6 +732,23 @@ floating_op_table::floating_op_table ()\n   set (PAREN_EXPR, fop_identity);\n   set (OBJ_TYPE_REF, fop_identity);\n   set (REAL_CST, fop_identity);\n+\n+  // All the relational operators are expected to work, because the\n+  // calculation of ranges on outgoing edges expect the handlers to be\n+  // present.\n+  set (EQ_EXPR, fop_equal);\n+  set (NE_EXPR, fop_not_equal);\n+  set (LT_EXPR, fop_lt);\n+  set (LE_EXPR, fop_le);\n+  set (GT_EXPR, fop_gt);\n+  set (GE_EXPR, fop_ge);\n+  set (UNLE_EXPR, fop_relop_unknown);\n+  set (UNLT_EXPR, fop_relop_unknown);\n+  set (UNGE_EXPR, fop_relop_unknown);\n+  set (UNGT_EXPR, fop_relop_unknown);\n+  set (UNEQ_EXPR, fop_relop_unknown);\n+  set (ORDERED_EXPR, fop_ordered);\n+  set (UNORDERED_EXPR, fop_unordered);\n }\n \n // Return a pointer to the range_operator_float instance, if there is"}, {"sha": "370deea9218b5ccabbd69c683f67beee85f23ed1", "filename": "gcc/testsuite/g++.dg/opt/pr94589-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24012539ae3410174b3e755b580a16de826d56a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr94589-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24012539ae3410174b3e755b580a16de826d56a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr94589-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr94589-2.C?ref=24012539ae3410174b3e755b580a16de826d56a6", "patch": "@@ -1,7 +1,7 @@\n // PR tree-optimization/94589\n // { dg-do compile { target c++20 } }\n // { dg-options \"-O2 -g0 -ffast-math -fdump-tree-optimized\" }\n-// { dg-final { scan-tree-dump-times \"\\[ij]_\\[0-9]+\\\\(D\\\\) (?:<|<=|==|!=|>|>=) \\[ij]_\\[0-9]+\\\\(D\\\\)\" 12 \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"\\[ij]_\\[0-9]+\\\\(D\\\\) (?:<|<=|==|!=|>|>=) \\[ij]_\\[0-9]+\\\\(D\\\\)\" 12 \"optimized\" { xfail *-*-* } } }\n // { dg-final { scan-tree-dump-times \"i_\\[0-9]+\\\\(D\\\\) (?:<|<=|==|!=|>|>=) 5\\\\.0\" 12 \"optimized\" } }\n \n #include <compare>"}, {"sha": "88faf72ac42578d1602dc38dcc1ef3775d9ed0aa", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp-float-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24012539ae3410174b3e755b580a16de826d56a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24012539ae3410174b3e755b580a16de826d56a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-1.c?ref=24012539ae3410174b3e755b580a16de826d56a6", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fdisable-tree-ethread -fdisable-tree-fre1 -fdump-tree-evrp\" }\n+\n+void bar ();\n+void george ();\n+\n+float\n+foo (float x, float y)\n+{\n+  if (x == x)\n+    {\n+      if (x > y)\n+        bar();\n+      if (x == x)\n+        george();\n+    }\n+}\n+\n+// { dg-final { scan-tree-dump-times \"Folding predicate x_*to 1\" \"evrp\" 1 } }"}, {"sha": "2f4dc8757a3b1ad213b8291ce967aa03534d0cf1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp-float-11.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24012539ae3410174b3e755b580a16de826d56a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24012539ae3410174b3e755b580a16de826d56a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-11.c?ref=24012539ae3410174b3e755b580a16de826d56a6", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fno-thread-jumps -fdump-tree-evrp\" }\n+\n+extern void link_error ();\n+\n+void fast_sqrt (float);\n+\n+float test (float x)\n+{\n+  float y = x*x;\n+  if (y >= 0.f)\n+    { \n+      if (__builtin_isnan (y))\n+\tlink_error ();\n+      else\n+\tfast_sqrt (y);\n+\n+      if (!__builtin_isnan (y))\n+\tfast_sqrt (y);\n+      else\n+\tlink_error ();\n+    }\n+}\n+\n+// { dg-final { scan-tree-dump-times \"fast_sqrt\" 2 \"evrp\" } }\n+// { dg-final { scan-tree-dump-not \"link_error\" \"evrp\" } }"}, {"sha": "c659abb6cc0dcb3d6b15fcb3cddac0b6f398e1d5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp-float-3.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24012539ae3410174b3e755b580a16de826d56a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24012539ae3410174b3e755b580a16de826d56a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-3.c?ref=24012539ae3410174b3e755b580a16de826d56a6", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fdisable-tree-ethread -fdump-tree-evrp\" }\n+\n+void link_error ();\n+\n+void\n+foo (double x, double y)\n+{\n+  if (x == y)\n+    {\n+      if (__builtin_isnan (x))\n+        link_error ();\n+      if (__builtin_isnan (y))\n+        link_error ();\n+    }\n+}\n+\n+// { dg-final { scan-tree-dump-not \"link_error\" \"evrp\" } }"}, {"sha": "86436742e0a0d52c53246843929da0d316dd2e07", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp-float-4.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24012539ae3410174b3e755b580a16de826d56a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24012539ae3410174b3e755b580a16de826d56a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-4.c?ref=24012539ae3410174b3e755b580a16de826d56a6", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fdisable-tree-ethread -fdump-tree-evrp\" }\n+\n+void link_error ();\n+\n+void\n+foo (double x, double y)\n+{\n+  if (x > y)\n+    {\n+      if (__builtin_isnan (x) || __builtin_isnan (y))\n+        link_error ();\n+    }\n+}\n+\n+// { dg-final { scan-tree-dump-not \"link_error\" \"evrp\" } }"}, {"sha": "145d1861804e188b5a13addbeed3802991f43cc9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp-float-6.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24012539ae3410174b3e755b580a16de826d56a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24012539ae3410174b3e755b580a16de826d56a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-6.c?ref=24012539ae3410174b3e755b580a16de826d56a6", "patch": "@@ -0,0 +1,20 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fdisable-tree-ethread -fdump-tree-evrp\" }\n+\n+void bar ();\n+\n+void\n+foo (double x, double y)\n+{\n+      if (x > y)\n+\t;\n+      else if (!__builtin_isnan (x) && !__builtin_isnan (y))\n+\t{\n+\t  // If x and y are not NAN, the x <= y relationship holds, and the\n+\t  // following conditional can be folded away.\n+\t  if (x <= y)\n+\t    bar ();\n+\t}\n+}\n+\n+// { dg-final { scan-tree-dump-times \"Folding predicate x_.* <= y_.* to 1\" 1 \"evrp\" } }"}, {"sha": "92af87091a89df8a04c81ea6d68d3c105c8138a9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp-float-7.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24012539ae3410174b3e755b580a16de826d56a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24012539ae3410174b3e755b580a16de826d56a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-7.c?ref=24012539ae3410174b3e755b580a16de826d56a6", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fno-tree-forwprop -fno-tree-ccp -fno-tree-fre -fdump-tree-evrp\" }\n+\n+extern void link_error ();\n+\n+void\n+foo ()\n+{\n+  float z = 0.0;\n+  if (__builtin_isnan (z))\n+    link_error ();\n+}\n+\n+// { dg-final { scan-tree-dump-not \"link_error\" \"evrp\" } }"}, {"sha": "9170150d453f0cca2e93ac1244729ab6516b810b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp-float-8.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24012539ae3410174b3e755b580a16de826d56a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24012539ae3410174b3e755b580a16de826d56a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-8.c?ref=24012539ae3410174b3e755b580a16de826d56a6", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fno-thread-jumps -fdump-tree-evrp\" }\n+\n+extern void link_error ();\n+\n+void fast_sqrt (float);\n+\n+float test (float x)\n+{\n+    float y = x*x;\n+    if (y >= 0.f)\n+      { \n+        if (__builtin_isnan (y))\n+         link_error ();\n+        else\n+          fast_sqrt (y);\n+\n+       if (!__builtin_isnan (y))\n+         fast_sqrt (y);\n+       else\n+         link_error ();\n+      }\n+}\n+\n+// { dg-final { scan-tree-dump-times \"fast_sqrt\" 2 \"evrp\" } }\n+// { dg-final { scan-tree-dump-not \"link_error\" \"evrp\" } }"}, {"sha": "305e2cae7e62f30a0dcca3f41e5c5eafc2e3d5a5", "filename": "gcc/value-range.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24012539ae3410174b3e755b580a16de826d56a6/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24012539ae3410174b3e755b580a16de826d56a6/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=24012539ae3410174b3e755b580a16de826d56a6", "patch": "@@ -338,8 +338,7 @@ class frange : public vrange\n   frange (const frange &);\n   static bool supports_p (const_tree type)\n   {\n-    // Disabled until floating point range-ops come live.\n-    return 0 && SCALAR_FLOAT_TYPE_P (type);\n+    return SCALAR_FLOAT_TYPE_P (type);\n   }\n   virtual tree type () const override;\n   virtual void set (tree, tree, value_range_kind = VR_RANGE) override;"}]}