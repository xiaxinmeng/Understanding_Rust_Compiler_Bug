{"sha": "4ebeb3165cfdaa1b95ed39779760b634974a80e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGViZWIzMTY1Y2ZkYWExYjk1ZWQzOTc3OTc2MGI2MzQ5NzRhODBlNQ==", "commit": {"author": {"name": "Yizhe", "email": "yizhe@pku.edu.cn", "date": "2021-02-26T08:56:17Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-03-01T10:42:27Z"}, "message": "Modify the parser to use the new enums", "tree": {"sha": "d01fc3707cd3ee6ce777afc29fe07949a50e6afe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d01fc3707cd3ee6ce777afc29fe07949a50e6afe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ebeb3165cfdaa1b95ed39779760b634974a80e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ebeb3165cfdaa1b95ed39779760b634974a80e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ebeb3165cfdaa1b95ed39779760b634974a80e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ebeb3165cfdaa1b95ed39779760b634974a80e5/comments", "author": {"login": "YizhePKU", "id": 42838469, "node_id": "MDQ6VXNlcjQyODM4NDY5", "avatar_url": "https://avatars.githubusercontent.com/u/42838469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/YizhePKU", "html_url": "https://github.com/YizhePKU", "followers_url": "https://api.github.com/users/YizhePKU/followers", "following_url": "https://api.github.com/users/YizhePKU/following{/other_user}", "gists_url": "https://api.github.com/users/YizhePKU/gists{/gist_id}", "starred_url": "https://api.github.com/users/YizhePKU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/YizhePKU/subscriptions", "organizations_url": "https://api.github.com/users/YizhePKU/orgs", "repos_url": "https://api.github.com/users/YizhePKU/repos", "events_url": "https://api.github.com/users/YizhePKU/events{/privacy}", "received_events_url": "https://api.github.com/users/YizhePKU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "875bda0637f587ded1a4e8bfab1703b54eee2b2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/875bda0637f587ded1a4e8bfab1703b54eee2b2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/875bda0637f587ded1a4e8bfab1703b54eee2b2e"}], "stats": {"total": 164, "additions": 82, "deletions": 82}, "files": [{"sha": "012564936c647d03e298baeeabf8e7979a5e2a6a", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ebeb3165cfdaa1b95ed39779760b634974a80e5/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ebeb3165cfdaa1b95ed39779760b634974a80e5/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=4ebeb3165cfdaa1b95ed39779760b634974a80e5", "patch": "@@ -12271,7 +12271,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \t/* FIXME: allow outer attributes on these expressions by having an outer\n \t * attrs parameter in function*/\n \treturn std::unique_ptr<AST::NegationExpr> (\n-\t  new AST::NegationExpr (std::move (expr), AST::NegationExpr::NEGATE,\n+\t  new AST::NegationExpr (std::move (expr), NegationOperator::NEGATE,\n \t\t\t\t std::move (outer_attrs), tok->get_locus ()));\n       }\n       case EXCLAM: { // logical or bitwise not\n@@ -12294,7 +12294,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \n \t// FIXME: allow outer attributes on these expressions\n \treturn std::unique_ptr<AST::NegationExpr> (\n-\t  new AST::NegationExpr (std::move (expr), AST::NegationExpr::NOT,\n+\t  new AST::NegationExpr (std::move (expr), NegationOperator::NOT,\n \t\t\t\t std::move (outer_attrs), tok->get_locus ()));\n       }\n       case ASTERISK: {\n@@ -12530,77 +12530,77 @@ Parser<ManagedTokenSource>::left_denotation (\n \t\t\t\t     std::move (outer_attrs), restrictions);*/\n       return parse_arithmetic_or_logical_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n-\tAST::ArithmeticOrLogicalExpr::ADD, restrictions);\n+\tArithmeticOrLogicalOperator::ADD, restrictions);\n     case MINUS:\n       // difference expression - binary infix\n       /*return parse_binary_minus_expr (tok, std::move (left),\n \t\t\t\t      std::move (outer_attrs), restrictions);*/\n       return parse_arithmetic_or_logical_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n-\tAST::ArithmeticOrLogicalExpr::SUBTRACT, restrictions);\n+\tArithmeticOrLogicalOperator::SUBTRACT, restrictions);\n     case ASTERISK:\n       // product expression - binary infix\n       /*return parse_binary_mult_expr (tok, std::move (left),\n \t\t\t\t     std::move (outer_attrs), restrictions);*/\n       return parse_arithmetic_or_logical_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n-\tAST::ArithmeticOrLogicalExpr::MULTIPLY, restrictions);\n+\tArithmeticOrLogicalOperator::MULTIPLY, restrictions);\n     case DIV:\n       // quotient expression - binary infix\n       /*return parse_binary_div_expr (tok, std::move (left),\n \t\t\t\t    std::move (outer_attrs), restrictions);*/\n       return parse_arithmetic_or_logical_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n-\tAST::ArithmeticOrLogicalExpr::DIVIDE, restrictions);\n+\tArithmeticOrLogicalOperator::DIVIDE, restrictions);\n     case PERCENT:\n       // modulo expression - binary infix\n       /*return parse_binary_mod_expr (tok, std::move (left),\n \t\t\t\t    std::move (outer_attrs), restrictions);*/\n       return parse_arithmetic_or_logical_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n-\tAST::ArithmeticOrLogicalExpr::MODULUS, restrictions);\n+\tArithmeticOrLogicalOperator::MODULUS, restrictions);\n     case AMP:\n       // logical or bitwise and expression - binary infix\n       /*return parse_bitwise_and_expr (tok, std::move (left),\n \t\t\t\t     std::move (outer_attrs), restrictions);*/\n       return parse_arithmetic_or_logical_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n-\tAST::ArithmeticOrLogicalExpr::BITWISE_AND, restrictions);\n+\tArithmeticOrLogicalOperator::BITWISE_AND, restrictions);\n     case PIPE:\n       // logical or bitwise or expression - binary infix\n       /*return parse_bitwise_or_expr (tok, std::move (left),\n \t\t\t\t    std::move (outer_attrs), restrictions);*/\n       return parse_arithmetic_or_logical_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n-\tAST::ArithmeticOrLogicalExpr::BITWISE_OR, restrictions);\n+\tArithmeticOrLogicalOperator::BITWISE_OR, restrictions);\n     case CARET:\n       // logical or bitwise xor expression - binary infix\n       /*return parse_bitwise_xor_expr (tok, std::move (left),\n \t\t\t\t     std::move (outer_attrs), restrictions);*/\n       return parse_arithmetic_or_logical_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n-\tAST::ArithmeticOrLogicalExpr::BITWISE_XOR, restrictions);\n+\tArithmeticOrLogicalOperator::BITWISE_XOR, restrictions);\n     case LEFT_SHIFT:\n       // left shift expression - binary infix\n       /*return parse_left_shift_expr (tok, std::move (left),\n \t\t\t\t    std::move (outer_attrs), restrictions);*/\n       return parse_arithmetic_or_logical_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n-\tAST::ArithmeticOrLogicalExpr::LEFT_SHIFT, restrictions);\n+\tArithmeticOrLogicalOperator::LEFT_SHIFT, restrictions);\n     case RIGHT_SHIFT:\n       // right shift expression - binary infix\n       /*return parse_right_shift_expr (tok, std::move (left),\n \t\t\t\t     std::move (outer_attrs), restrictions);*/\n       return parse_arithmetic_or_logical_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n-\tAST::ArithmeticOrLogicalExpr::RIGHT_SHIFT, restrictions);\n+\tArithmeticOrLogicalOperator::RIGHT_SHIFT, restrictions);\n     case EQUAL_EQUAL:\n       // equal to expression - binary infix (no associativity)\n       /*return parse_binary_equal_expr (tok, std::move (left),\n \t\t\t\t      std::move (outer_attrs), restrictions);*/\n       return parse_comparison_expr (tok, std::move (left),\n \t\t\t\t    std::move (outer_attrs),\n-\t\t\t\t    AST::ComparisonExpr::ExprType::EQUAL,\n+\t\t\t\t    ComparisonOperator::EQUAL,\n \t\t\t\t    restrictions);\n     case NOT_EQUAL:\n       // not equal to expression - binary infix (no associativity)\n@@ -12609,7 +12609,7 @@ Parser<ManagedTokenSource>::left_denotation (\n \t\t\t\t\t  restrictions);*/\n       return parse_comparison_expr (tok, std::move (left),\n \t\t\t\t    std::move (outer_attrs),\n-\t\t\t\t    AST::ComparisonExpr::ExprType::NOT_EQUAL,\n+\t\t\t\t    ComparisonOperator::NOT_EQUAL,\n \t\t\t\t    restrictions);\n     case RIGHT_ANGLE:\n       // greater than expression - binary infix (no associativity)\n@@ -12618,7 +12618,7 @@ Parser<ManagedTokenSource>::left_denotation (\n \t\t\t\t\t     restrictions);*/\n       return parse_comparison_expr (tok, std::move (left),\n \t\t\t\t    std::move (outer_attrs),\n-\t\t\t\t    AST::ComparisonExpr::ExprType::GREATER_THAN,\n+\t\t\t\t    ComparisonOperator::GREATER_THAN,\n \t\t\t\t    restrictions);\n     case LEFT_ANGLE:\n       // less than expression - binary infix (no associativity)\n@@ -12627,7 +12627,7 @@ Parser<ManagedTokenSource>::left_denotation (\n \t\t\t\t\t  restrictions);*/\n       return parse_comparison_expr (tok, std::move (left),\n \t\t\t\t    std::move (outer_attrs),\n-\t\t\t\t    AST::ComparisonExpr::ExprType::LESS_THAN,\n+\t\t\t\t    ComparisonOperator::LESS_THAN,\n \t\t\t\t    restrictions);\n     case GREATER_OR_EQUAL:\n       // greater than or equal to expression - binary infix (no associativity)\n@@ -12636,15 +12636,15 @@ Parser<ManagedTokenSource>::left_denotation (\n \t\t\t\t\t      restrictions);*/\n       return parse_comparison_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n-\tAST::ComparisonExpr::ExprType::GREATER_OR_EQUAL, restrictions);\n+\tComparisonOperator::GREATER_OR_EQUAL, restrictions);\n     case LESS_OR_EQUAL:\n       // less than or equal to expression - binary infix (no associativity)\n       /*return parse_binary_less_equal_expr (tok, std::move (left),\n \t\t\t\t\t   std::move (outer_attrs),\n \t\t\t\t\t   restrictions);*/\n       return parse_comparison_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n-\tAST::ComparisonExpr::ExprType::LESS_OR_EQUAL, restrictions);\n+\tComparisonOperator::LESS_OR_EQUAL, restrictions);\n     case OR:\n       // lazy logical or expression - binary infix\n       return parse_lazy_or_expr (tok, std::move (left), std::move (outer_attrs),\n@@ -12669,7 +12669,7 @@ Parser<ManagedTokenSource>::left_denotation (\n \t\t\t\t    std::move (outer_attrs), restrictions);*/\n       return parse_compound_assignment_expr (tok, std::move (left),\n \t\t\t\t\t     std::move (outer_attrs),\n-\t\t\t\t\t     AST::CompoundAssignmentExpr::ADD,\n+\t\t\t\t\t     CompoundAssignmentOperator::ADD,\n \t\t\t\t\t     restrictions);\n     case MINUS_EQ:\n       /* minus-assignment expression - binary infix (note right-to-left\n@@ -12678,55 +12678,55 @@ Parser<ManagedTokenSource>::left_denotation (\n \t\t\t\t     std::move (outer_attrs), restrictions);*/\n       return parse_compound_assignment_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n-\tAST::CompoundAssignmentExpr::SUBTRACT, restrictions);\n+\tCompoundAssignmentOperator::SUBTRACT, restrictions);\n     case ASTERISK_EQ:\n       /* multiply-assignment expression - binary infix (note right-to-left\n        * associativity) */\n       /*return parse_mult_assig_expr (tok, std::move (left),\n \t\t\t\t    std::move (outer_attrs), restrictions);*/\n       return parse_compound_assignment_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n-\tAST::CompoundAssignmentExpr::MULTIPLY, restrictions);\n+\tCompoundAssignmentOperator::MULTIPLY, restrictions);\n     case DIV_EQ:\n       /* division-assignment expression - binary infix (note right-to-left\n        * associativity) */\n       /*return parse_div_assig_expr (tok, std::move (left),\n \t\t\t\t   std::move (outer_attrs), restrictions);*/\n       return parse_compound_assignment_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n-\tAST::CompoundAssignmentExpr::DIVIDE, restrictions);\n+\tCompoundAssignmentOperator::DIVIDE, restrictions);\n     case PERCENT_EQ:\n       /* modulo-assignment expression - binary infix (note right-to-left\n        * associativity) */\n       /*return parse_mod_assig_expr (tok, std::move (left),\n \t\t\t\t   std::move (outer_attrs), restrictions);*/\n       return parse_compound_assignment_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n-\tAST::CompoundAssignmentExpr::MODULUS, restrictions);\n+\tCompoundAssignmentOperator::MODULUS, restrictions);\n     case AMP_EQ:\n       /* bitwise and-assignment expression - binary infix (note right-to-left\n        * associativity) */\n       /*return parse_and_assig_expr (tok, std::move (left),\n \t\t\t\t   std::move (outer_attrs), restrictions);*/\n       return parse_compound_assignment_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n-\tAST::CompoundAssignmentExpr::BITWISE_AND, restrictions);\n+\tCompoundAssignmentOperator::BITWISE_AND, restrictions);\n     case PIPE_EQ:\n       /* bitwise or-assignment expression - binary infix (note right-to-left\n        * associativity) */\n       /*return parse_or_assig_expr (tok, std::move (left),\n \t\t\t\t  std::move (outer_attrs), restrictions);*/\n       return parse_compound_assignment_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n-\tAST::CompoundAssignmentExpr::BITWISE_OR, restrictions);\n+\tCompoundAssignmentOperator::BITWISE_OR, restrictions);\n     case CARET_EQ:\n       /* bitwise xor-assignment expression - binary infix (note right-to-left\n        * associativity) */\n       /*return parse_xor_assig_expr (tok, std::move (left),\n \t\t\t\t   std::move (outer_attrs), restrictions);*/\n       return parse_compound_assignment_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n-\tAST::CompoundAssignmentExpr::BITWISE_XOR, restrictions);\n+\tCompoundAssignmentOperator::BITWISE_XOR, restrictions);\n     case LEFT_SHIFT_EQ:\n       /* left shift-assignment expression - binary infix (note right-to-left\n        * associativity) */\n@@ -12735,7 +12735,7 @@ Parser<ManagedTokenSource>::left_denotation (\n \t\t\t\t\t  restrictions);*/\n       return parse_compound_assignment_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n-\tAST::CompoundAssignmentExpr::LEFT_SHIFT, restrictions);\n+\tCompoundAssignmentOperator::LEFT_SHIFT, restrictions);\n     case RIGHT_SHIFT_EQ:\n       /* right shift-assignment expression - binary infix (note right-to-left\n        * associativity) */\n@@ -12744,7 +12744,7 @@ Parser<ManagedTokenSource>::left_denotation (\n \t\t\t\t\t   restrictions);*/\n       return parse_compound_assignment_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n-\tAST::CompoundAssignmentExpr::RIGHT_SHIFT, restrictions);\n+\tCompoundAssignmentOperator::RIGHT_SHIFT, restrictions);\n     case DOT_DOT:\n       /* range exclusive expression - binary infix (no associativity)\n        * either \"range\" or \"range from\" */\n@@ -12830,25 +12830,25 @@ get_lbp_for_arithmetic_or_logical_expr (\n {\n   switch (expr_type)\n     {\n-    case AST::ArithmeticOrLogicalExpr::ADD:\n+    case ArithmeticOrLogicalOperator::ADD:\n       return LBP_PLUS;\n-    case AST::ArithmeticOrLogicalExpr::SUBTRACT:\n+    case ArithmeticOrLogicalOperator::SUBTRACT:\n       return LBP_MINUS;\n-    case AST::ArithmeticOrLogicalExpr::MULTIPLY:\n+    case ArithmeticOrLogicalOperator::MULTIPLY:\n       return LBP_MUL;\n-    case AST::ArithmeticOrLogicalExpr::DIVIDE:\n+    case ArithmeticOrLogicalOperator::DIVIDE:\n       return LBP_DIV;\n-    case AST::ArithmeticOrLogicalExpr::MODULUS:\n+    case ArithmeticOrLogicalOperator::MODULUS:\n       return LBP_MOD;\n-    case AST::ArithmeticOrLogicalExpr::BITWISE_AND:\n+    case ArithmeticOrLogicalOperator::BITWISE_AND:\n       return LBP_AMP;\n-    case AST::ArithmeticOrLogicalExpr::BITWISE_OR:\n+    case ArithmeticOrLogicalOperator::BITWISE_OR:\n       return LBP_PIPE;\n-    case AST::ArithmeticOrLogicalExpr::BITWISE_XOR:\n+    case ArithmeticOrLogicalOperator::BITWISE_XOR:\n       return LBP_CARET;\n-    case AST::ArithmeticOrLogicalExpr::LEFT_SHIFT:\n+    case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n       return LBP_L_SHIFT;\n-    case AST::ArithmeticOrLogicalExpr::RIGHT_SHIFT:\n+    case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n       return LBP_R_SHIFT;\n     default:\n       // WTF? should not happen, this is an error\n@@ -12901,7 +12901,7 @@ Parser<ManagedTokenSource>::parse_binary_plus_expr (\n \n   return std::unique_ptr<AST::ArithmeticOrLogicalExpr> (\n     new AST::ArithmeticOrLogicalExpr (std::move (left), std::move (right),\n-\t\t\t\t      AST::ArithmeticOrLogicalExpr::ADD,\n+\t\t\t\t      ArithmeticOrLogicalOperator::ADD,\n \t\t\t\t      locus));\n }\n \n@@ -12924,7 +12924,7 @@ Parser<ManagedTokenSource>::parse_binary_minus_expr (\n \n   return std::unique_ptr<AST::ArithmeticOrLogicalExpr> (\n     new AST::ArithmeticOrLogicalExpr (std::move (left), std::move (right),\n-\t\t\t\t      AST::ArithmeticOrLogicalExpr::SUBTRACT,\n+\t\t\t\t      ArithmeticOrLogicalOperator::SUBTRACT,\n \t\t\t\t      locus));\n }\n \n@@ -12947,7 +12947,7 @@ Parser<ManagedTokenSource>::parse_binary_mult_expr (\n \n   return std::unique_ptr<AST::ArithmeticOrLogicalExpr> (\n     new AST::ArithmeticOrLogicalExpr (std::move (left), std::move (right),\n-\t\t\t\t      AST::ArithmeticOrLogicalExpr::MULTIPLY,\n+\t\t\t\t      ArithmeticOrLogicalOperator::MULTIPLY,\n \t\t\t\t      locus));\n }\n \n@@ -12970,7 +12970,7 @@ Parser<ManagedTokenSource>::parse_binary_div_expr (\n \n   return std::unique_ptr<AST::ArithmeticOrLogicalExpr> (\n     new AST::ArithmeticOrLogicalExpr (std::move (left), std::move (right),\n-\t\t\t\t      AST::ArithmeticOrLogicalExpr::DIVIDE,\n+\t\t\t\t      ArithmeticOrLogicalOperator::DIVIDE,\n \t\t\t\t      locus));\n }\n \n@@ -12993,7 +12993,7 @@ Parser<ManagedTokenSource>::parse_binary_mod_expr (\n \n   return std::unique_ptr<AST::ArithmeticOrLogicalExpr> (\n     new AST::ArithmeticOrLogicalExpr (std::move (left), std::move (right),\n-\t\t\t\t      AST::ArithmeticOrLogicalExpr::MODULUS,\n+\t\t\t\t      ArithmeticOrLogicalOperator::MODULUS,\n \t\t\t\t      locus));\n }\n \n@@ -13017,7 +13017,7 @@ Parser<ManagedTokenSource>::parse_bitwise_and_expr (\n \n   return std::unique_ptr<AST::ArithmeticOrLogicalExpr> (\n     new AST::ArithmeticOrLogicalExpr (std::move (left), std::move (right),\n-\t\t\t\t      AST::ArithmeticOrLogicalExpr::BITWISE_AND,\n+\t\t\t\t      ArithmeticOrLogicalOperator::BITWISE_AND,\n \t\t\t\t      locus));\n }\n \n@@ -13041,7 +13041,7 @@ Parser<ManagedTokenSource>::parse_bitwise_or_expr (\n \n   return std::unique_ptr<AST::ArithmeticOrLogicalExpr> (\n     new AST::ArithmeticOrLogicalExpr (std::move (left), std::move (right),\n-\t\t\t\t      AST::ArithmeticOrLogicalExpr::BITWISE_OR,\n+\t\t\t\t      ArithmeticOrLogicalOperator::BITWISE_OR,\n \t\t\t\t      locus));\n }\n \n@@ -13065,7 +13065,7 @@ Parser<ManagedTokenSource>::parse_bitwise_xor_expr (\n \n   return std::unique_ptr<AST::ArithmeticOrLogicalExpr> (\n     new AST::ArithmeticOrLogicalExpr (std::move (left), std::move (right),\n-\t\t\t\t      AST::ArithmeticOrLogicalExpr::BITWISE_XOR,\n+\t\t\t\t      ArithmeticOrLogicalOperator::BITWISE_XOR,\n \t\t\t\t      locus));\n }\n \n@@ -13088,7 +13088,7 @@ Parser<ManagedTokenSource>::parse_left_shift_expr (\n \n   return std::unique_ptr<AST::ArithmeticOrLogicalExpr> (\n     new AST::ArithmeticOrLogicalExpr (std::move (left), std::move (right),\n-\t\t\t\t      AST::ArithmeticOrLogicalExpr::LEFT_SHIFT,\n+\t\t\t\t      ArithmeticOrLogicalOperator::LEFT_SHIFT,\n \t\t\t\t      locus));\n }\n \n@@ -13111,7 +13111,7 @@ Parser<ManagedTokenSource>::parse_right_shift_expr (\n \n   return std::unique_ptr<AST::ArithmeticOrLogicalExpr> (\n     new AST::ArithmeticOrLogicalExpr (std::move (left), std::move (right),\n-\t\t\t\t      AST::ArithmeticOrLogicalExpr::RIGHT_SHIFT,\n+\t\t\t\t      ArithmeticOrLogicalOperator::RIGHT_SHIFT,\n \t\t\t\t      locus));\n }\n \n@@ -13122,17 +13122,17 @@ get_lbp_for_comparison_expr (AST::ComparisonExpr::ExprType expr_type)\n {\n   switch (expr_type)\n     {\n-    case AST::ComparisonExpr::EQUAL:\n+    case ComparisonOperator::EQUAL:\n       return LBP_EQUAL;\n-    case AST::ComparisonExpr::NOT_EQUAL:\n+    case ComparisonOperator::NOT_EQUAL:\n       return LBP_NOT_EQUAL;\n-    case AST::ComparisonExpr::GREATER_THAN:\n+    case ComparisonOperator::GREATER_THAN:\n       return LBP_GREATER_THAN;\n-    case AST::ComparisonExpr::LESS_THAN:\n+    case ComparisonOperator::LESS_THAN:\n       return LBP_SMALLER_THAN;\n-    case AST::ComparisonExpr::GREATER_OR_EQUAL:\n+    case ComparisonOperator::GREATER_OR_EQUAL:\n       return LBP_GREATER_EQUAL;\n-    case AST::ComparisonExpr::LESS_OR_EQUAL:\n+    case ComparisonOperator::LESS_OR_EQUAL:\n       return LBP_SMALLER_EQUAL;\n     default:\n       // WTF? should not happen, this is an error\n@@ -13185,7 +13185,7 @@ Parser<ManagedTokenSource>::parse_binary_equal_expr (\n \n   return std::unique_ptr<AST::ComparisonExpr> (\n     new AST::ComparisonExpr (std::move (left), std::move (right),\n-\t\t\t     AST::ComparisonExpr::EQUAL, locus));\n+\t\t\t     ComparisonOperator::EQUAL, locus));\n }\n \n // Parses a binary not equal to expression (with Pratt parsing).\n@@ -13207,7 +13207,7 @@ Parser<ManagedTokenSource>::parse_binary_not_equal_expr (\n \n   return std::unique_ptr<AST::ComparisonExpr> (\n     new AST::ComparisonExpr (std::move (left), std::move (right),\n-\t\t\t     AST::ComparisonExpr::NOT_EQUAL, locus));\n+\t\t\t     ComparisonOperator::NOT_EQUAL, locus));\n }\n \n // Parses a binary greater than expression (with Pratt parsing).\n@@ -13230,7 +13230,7 @@ Parser<ManagedTokenSource>::parse_binary_greater_than_expr (\n \n   return std::unique_ptr<AST::ComparisonExpr> (\n     new AST::ComparisonExpr (std::move (left), std::move (right),\n-\t\t\t     AST::ComparisonExpr::GREATER_THAN, locus));\n+\t\t\t     ComparisonOperator::GREATER_THAN, locus));\n }\n \n // Parses a binary less than expression (with Pratt parsing).\n@@ -13253,7 +13253,7 @@ Parser<ManagedTokenSource>::parse_binary_less_than_expr (\n \n   return std::unique_ptr<AST::ComparisonExpr> (\n     new AST::ComparisonExpr (std::move (left), std::move (right),\n-\t\t\t     AST::ComparisonExpr::LESS_THAN, locus));\n+\t\t\t     ComparisonOperator::LESS_THAN, locus));\n }\n \n // Parses a binary greater than or equal to expression (with Pratt parsing).\n@@ -13276,7 +13276,7 @@ Parser<ManagedTokenSource>::parse_binary_greater_equal_expr (\n \n   return std::unique_ptr<AST::ComparisonExpr> (\n     new AST::ComparisonExpr (std::move (left), std::move (right),\n-\t\t\t     AST::ComparisonExpr::GREATER_OR_EQUAL, locus));\n+\t\t\t     ComparisonOperator::GREATER_OR_EQUAL, locus));\n }\n \n // Parses a binary less than or equal to expression (with Pratt parsing).\n@@ -13299,7 +13299,7 @@ Parser<ManagedTokenSource>::parse_binary_less_equal_expr (\n \n   return std::unique_ptr<AST::ComparisonExpr> (\n     new AST::ComparisonExpr (std::move (left), std::move (right),\n-\t\t\t     AST::ComparisonExpr::LESS_OR_EQUAL, locus));\n+\t\t\t     ComparisonOperator::LESS_OR_EQUAL, locus));\n }\n \n // Parses a binary lazy boolean or expression (with Pratt parsing).\n@@ -13321,7 +13321,7 @@ Parser<ManagedTokenSource>::parse_lazy_or_expr (\n \n   return std::unique_ptr<AST::LazyBooleanExpr> (\n     new AST::LazyBooleanExpr (std::move (left), std::move (right),\n-\t\t\t      AST::LazyBooleanExpr::LOGICAL_OR, locus));\n+\t\t\t      LazyBooleanOperator::LOGICAL_OR, locus));\n }\n \n // Parses a binary lazy boolean and expression (with Pratt parsing).\n@@ -13344,7 +13344,7 @@ Parser<ManagedTokenSource>::parse_lazy_and_expr (\n \n   return std::unique_ptr<AST::LazyBooleanExpr> (\n     new AST::LazyBooleanExpr (std::move (left), std::move (right),\n-\t\t\t      AST::LazyBooleanExpr::LOGICAL_AND, locus));\n+\t\t\t      LazyBooleanOperator::LOGICAL_AND, locus));\n }\n \n // Parses a pseudo-binary infix type cast expression (with Pratt parsing).\n@@ -13398,25 +13398,25 @@ get_lbp_for_compound_assignment_expr (\n {\n   switch (expr_type)\n     {\n-    case AST::CompoundAssignmentExpr::ADD:\n+    case CompoundAssignmentOperator::ADD:\n       return LBP_PLUS;\n-    case AST::CompoundAssignmentExpr::SUBTRACT:\n+    case CompoundAssignmentOperator::SUBTRACT:\n       return LBP_MINUS;\n-    case AST::CompoundAssignmentExpr::MULTIPLY:\n+    case CompoundAssignmentOperator::MULTIPLY:\n       return LBP_MUL;\n-    case AST::CompoundAssignmentExpr::DIVIDE:\n+    case CompoundAssignmentOperator::DIVIDE:\n       return LBP_DIV;\n-    case AST::CompoundAssignmentExpr::MODULUS:\n+    case CompoundAssignmentOperator::MODULUS:\n       return LBP_MOD;\n-    case AST::CompoundAssignmentExpr::BITWISE_AND:\n+    case CompoundAssignmentOperator::BITWISE_AND:\n       return LBP_AMP;\n-    case AST::CompoundAssignmentExpr::BITWISE_OR:\n+    case CompoundAssignmentOperator::BITWISE_OR:\n       return LBP_PIPE;\n-    case AST::CompoundAssignmentExpr::BITWISE_XOR:\n+    case CompoundAssignmentOperator::BITWISE_XOR:\n       return LBP_CARET;\n-    case AST::CompoundAssignmentExpr::LEFT_SHIFT:\n+    case CompoundAssignmentOperator::LEFT_SHIFT:\n       return LBP_L_SHIFT;\n-    case AST::CompoundAssignmentExpr::RIGHT_SHIFT:\n+    case CompoundAssignmentOperator::RIGHT_SHIFT:\n       return LBP_R_SHIFT;\n     default:\n       // WTF? should not happen, this is an error\n@@ -13472,7 +13472,7 @@ Parser<ManagedTokenSource>::parse_plus_assig_expr (\n \n   return std::unique_ptr<AST::CompoundAssignmentExpr> (\n     new AST::CompoundAssignmentExpr (std::move (left), std::move (right),\n-\t\t\t\t     AST::CompoundAssignmentExpr::ADD, locus));\n+\t\t\t\t     CompoundAssignmentOperator::ADD, locus));\n }\n \n // Parses a binary minus-assignment expression (with Pratt parsing).\n@@ -13496,7 +13496,7 @@ Parser<ManagedTokenSource>::parse_minus_assig_expr (\n \n   return std::unique_ptr<AST::CompoundAssignmentExpr> (\n     new AST::CompoundAssignmentExpr (std::move (left), std::move (right),\n-\t\t\t\t     AST::CompoundAssignmentExpr::SUBTRACT,\n+\t\t\t\t     CompoundAssignmentOperator::SUBTRACT,\n \t\t\t\t     locus));\n }\n \n@@ -13521,7 +13521,7 @@ Parser<ManagedTokenSource>::parse_mult_assig_expr (\n \n   return std::unique_ptr<AST::CompoundAssignmentExpr> (\n     new AST::CompoundAssignmentExpr (std::move (left), std::move (right),\n-\t\t\t\t     AST::CompoundAssignmentExpr::MULTIPLY,\n+\t\t\t\t     CompoundAssignmentOperator::MULTIPLY,\n \t\t\t\t     locus));\n }\n \n@@ -13546,7 +13546,7 @@ Parser<ManagedTokenSource>::parse_div_assig_expr (\n \n   return std::unique_ptr<AST::CompoundAssignmentExpr> (\n     new AST::CompoundAssignmentExpr (std::move (left), std::move (right),\n-\t\t\t\t     AST::CompoundAssignmentExpr::DIVIDE,\n+\t\t\t\t     CompoundAssignmentOperator::DIVIDE,\n \t\t\t\t     locus));\n }\n \n@@ -13571,7 +13571,7 @@ Parser<ManagedTokenSource>::parse_mod_assig_expr (\n \n   return std::unique_ptr<AST::CompoundAssignmentExpr> (\n     new AST::CompoundAssignmentExpr (std::move (left), std::move (right),\n-\t\t\t\t     AST::CompoundAssignmentExpr::MODULUS,\n+\t\t\t\t     CompoundAssignmentOperator::MODULUS,\n \t\t\t\t     locus));\n }\n \n@@ -13596,7 +13596,7 @@ Parser<ManagedTokenSource>::parse_and_assig_expr (\n \n   return std::unique_ptr<AST::CompoundAssignmentExpr> (\n     new AST::CompoundAssignmentExpr (std::move (left), std::move (right),\n-\t\t\t\t     AST::CompoundAssignmentExpr::BITWISE_AND,\n+\t\t\t\t     CompoundAssignmentOperator::BITWISE_AND,\n \t\t\t\t     locus));\n }\n \n@@ -13621,7 +13621,7 @@ Parser<ManagedTokenSource>::parse_or_assig_expr (\n \n   return std::unique_ptr<AST::CompoundAssignmentExpr> (\n     new AST::CompoundAssignmentExpr (std::move (left), std::move (right),\n-\t\t\t\t     AST::CompoundAssignmentExpr::BITWISE_OR,\n+\t\t\t\t     CompoundAssignmentOperator::BITWISE_OR,\n \t\t\t\t     locus));\n }\n \n@@ -13646,7 +13646,7 @@ Parser<ManagedTokenSource>::parse_xor_assig_expr (\n \n   return std::unique_ptr<AST::CompoundAssignmentExpr> (\n     new AST::CompoundAssignmentExpr (std::move (left), std::move (right),\n-\t\t\t\t     AST::CompoundAssignmentExpr::BITWISE_XOR,\n+\t\t\t\t     CompoundAssignmentOperator::BITWISE_XOR,\n \t\t\t\t     locus));\n }\n \n@@ -13671,7 +13671,7 @@ Parser<ManagedTokenSource>::parse_left_shift_assig_expr (\n \n   return std::unique_ptr<AST::CompoundAssignmentExpr> (\n     new AST::CompoundAssignmentExpr (std::move (left), std::move (right),\n-\t\t\t\t     AST::CompoundAssignmentExpr::LEFT_SHIFT,\n+\t\t\t\t     CompoundAssignmentOperator::LEFT_SHIFT,\n \t\t\t\t     locus));\n }\n \n@@ -13696,7 +13696,7 @@ Parser<ManagedTokenSource>::parse_right_shift_assig_expr (\n \n   return std::unique_ptr<AST::CompoundAssignmentExpr> (\n     new AST::CompoundAssignmentExpr (std::move (left), std::move (right),\n-\t\t\t\t     AST::CompoundAssignmentExpr::RIGHT_SHIFT,\n+\t\t\t\t     CompoundAssignmentOperator::RIGHT_SHIFT,\n \t\t\t\t     locus));\n }\n "}]}