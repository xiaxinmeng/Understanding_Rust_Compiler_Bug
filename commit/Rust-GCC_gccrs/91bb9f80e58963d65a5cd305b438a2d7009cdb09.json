{"sha": "91bb9f80e58963d65a5cd305b438a2d7009cdb09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFiYjlmODBlNTg5NjNkNjVhNWNkMzA1YjQzOGEyZDcwMDljZGIwOQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2016-05-18T16:38:56Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2016-05-18T16:38:56Z"}, "message": "Indirect inlining of targets from references of global constants\n\n2016-05-18  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/69708\n\t* cgraph.h (cgraph_indirect_call_info): New field\n\tguaranteed_unmodified.\n\t* ipa-cp.c (ipa_get_indirect_edge_target_1): Also pass parameter value\n\tto ipa_find_agg_cst_for_param, check guaranteed_unmodified when\n\tappropriate.\n\t* ipa-inline-analysis.c (evaluate_conditions_for_known_args): Also\n\tpass the parameter value to ipa_find_agg_cst_for_param.\n\t* ipa-prop.c (ipa_load_from_parm_agg): New parameter\n\tguaranteed_unmodified, store AA results there instead of bailing out\n\tif present.\n\t(ipa_note_param_call): Also initialize guaranteed_unmodified flag.\n\t(ipa_analyze_indirect_call_uses): Also set guaranteed_unmodified flag.\n\t(find_constructor_constant_at_offset): New function.\n\t(ipa_find_agg_cst_from_init): Likewise.\n\t(ipa_find_agg_cst_for_param): Also seearch for aggregate values in\n\tstatic initializers of contants, report back through a new paameter\n\tfrom_global_constant if that was the case.\n\t(try_make_edge_direct_simple_call): Also pass parameter value to\n\tipa_find_agg_cst_for_param, check guaranteed_unmodified when\n\tappropriate.\n\t(ipa_write_indirect_edge_info): Stream new flag guaranteed_unmodified.\n\t(ipa_read_indirect_edge_info): Likewise.\n\t* ipa-prop.h (ipa_find_agg_cst_for_param): Update declaration.\n\t(ipa_load_from_parm_agg): Likewise.\n\ntestsuite/\n\t* gcc.dg/ipa/iinline-cstagg-1.c: New test.\n\t* gcc.dg/ipa/ipcp-cstagg-1.c: Likewise.\n\t* gcc.dg/ipa/ipcp-cstagg-2.c: Likewise.\n\t* gcc.dg/ipa/ipcp-cstagg-3.c: Likewise.\n\t* gcc.dg/ipa/ipcp-cstagg-4.c: Likewise.\n\nFrom-SVN: r236416", "tree": {"sha": "857c7ed3fa77c5bf5bc4f278c87060f145482f7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/857c7ed3fa77c5bf5bc4f278c87060f145482f7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91bb9f80e58963d65a5cd305b438a2d7009cdb09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91bb9f80e58963d65a5cd305b438a2d7009cdb09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91bb9f80e58963d65a5cd305b438a2d7009cdb09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91bb9f80e58963d65a5cd305b438a2d7009cdb09/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c584aca60cbface2621ebf1ccc943df1b7af52ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c584aca60cbface2621ebf1ccc943df1b7af52ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c584aca60cbface2621ebf1ccc943df1b7af52ca"}], "stats": {"total": 514, "additions": 476, "deletions": 38}, "files": [{"sha": "3a8e9a76373b81bb1fcc9a9616f3e0561cd199a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91bb9f80e58963d65a5cd305b438a2d7009cdb09", "patch": "@@ -1,3 +1,31 @@\n+2016-05-18  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/69708\n+\t* cgraph.h (cgraph_indirect_call_info): New field\n+\tguaranteed_unmodified.\n+\t* ipa-cp.c (ipa_get_indirect_edge_target_1): Also pass parameter value\n+\tto ipa_find_agg_cst_for_param, check guaranteed_unmodified when\n+\tappropriate.\n+\t* ipa-inline-analysis.c (evaluate_conditions_for_known_args): Also\n+\tpass the parameter value to ipa_find_agg_cst_for_param.\n+\t* ipa-prop.c (ipa_load_from_parm_agg): New parameter\n+\tguaranteed_unmodified, store AA results there instead of bailing out\n+\tif present.\n+\t(ipa_note_param_call): Also initialize guaranteed_unmodified flag.\n+\t(ipa_analyze_indirect_call_uses): Also set guaranteed_unmodified flag.\n+\t(find_constructor_constant_at_offset): New function.\n+\t(ipa_find_agg_cst_from_init): Likewise.\n+\t(ipa_find_agg_cst_for_param): Also seearch for aggregate values in\n+\tstatic initializers of contants, report back through a new paameter\n+\tfrom_global_constant if that was the case.\n+\t(try_make_edge_direct_simple_call): Also pass parameter value to\n+\tipa_find_agg_cst_for_param, check guaranteed_unmodified when\n+\tappropriate.\n+\t(ipa_write_indirect_edge_info): Stream new flag guaranteed_unmodified.\n+\t(ipa_read_indirect_edge_info): Likewise.\n+\t* ipa-prop.h (ipa_find_agg_cst_for_param): Update declaration.\n+\t(ipa_load_from_parm_agg): Likewise.\n+\n 2016-05-18  Jiong Wang  <jiong.wang@arm.com>\n \n \tPR rtl-optimization/71150"}, {"sha": "ecafe63a5363e5b47ac4e670d73d77b2bfcb8b4b", "filename": "gcc/cgraph.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=91bb9f80e58963d65a5cd305b438a2d7009cdb09", "patch": "@@ -1579,9 +1579,14 @@ struct GTY(()) cgraph_indirect_call_info\n   unsigned agg_contents : 1;\n   /* Set when this is a call through a member pointer.  */\n   unsigned member_ptr : 1;\n-  /* When the previous bit is set, this one determines whether the destination\n-     is loaded from a parameter passed by reference. */\n+  /* When the agg_contents bit is set, this one determines whether the\n+     destination is loaded from a parameter passed by reference. */\n   unsigned by_ref : 1;\n+  /* When the agg_contents bit is set, this one determines whether we can\n+     deduce from the function body that the loaded value from the reference is\n+     never modified between the invocation of the function and the load\n+     point.  */\n+  unsigned guaranteed_unmodified : 1;\n   /* For polymorphic calls this specify whether the virtual table pointer\n      may have changed in between function entry and the call.  */\n   unsigned vptr_changed : 1;"}, {"sha": "2183da07b68b1ad340397f4fb42a8b1469f614d8", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=91bb9f80e58963d65a5cd305b438a2d7009cdb09", "patch": "@@ -1999,9 +1999,9 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n \n       if (ie->indirect_info->agg_contents)\n \t{\n-\t  if (agg_reps)\n+\t  t = NULL;\n+\t  if (agg_reps && ie->indirect_info->guaranteed_unmodified)\n \t    {\n-\t      t = NULL;\n \t      while (agg_reps)\n \t\t{\n \t\t  if (agg_reps->index == param_index\n@@ -2014,15 +2014,22 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n \t\t  agg_reps = agg_reps->next;\n \t\t}\n \t    }\n-\t  else if (known_aggs.length () > (unsigned int) param_index)\n+\t  if (!t)\n \t    {\n \t      struct ipa_agg_jump_function *agg;\n-\t      agg = known_aggs[param_index];\n-\t      t = ipa_find_agg_cst_for_param (agg, ie->indirect_info->offset,\n-\t\t\t\t\t      ie->indirect_info->by_ref);\n+\t      if (known_aggs.length () > (unsigned int) param_index)\n+\t\tagg = known_aggs[param_index];\n+\t      else\n+\t\tagg = NULL;\n+\t      bool from_global_constant;\n+\t      t = ipa_find_agg_cst_for_param (agg, known_csts[param_index],\n+\t\t\t\t\t      ie->indirect_info->offset,\n+\t\t\t\t\t      ie->indirect_info->by_ref,\n+\t\t\t\t\t      &from_global_constant);\n+\t      if (!from_global_constant\n+\t\t  && !ie->indirect_info->guaranteed_unmodified)\n+\t\tt = NULL_TREE;\n \t    }\n-\t  else\n-\t    t = NULL;\n \t}\n       else\n \tt = known_csts[param_index];\n@@ -2066,7 +2073,8 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n     {\n        struct ipa_agg_jump_function *agg;\n        agg = known_aggs[param_index];\n-       t = ipa_find_agg_cst_for_param (agg, ie->indirect_info->offset,\n+       t = ipa_find_agg_cst_for_param (agg, known_csts[param_index],\n+\t\t\t\t       ie->indirect_info->offset,\n \t\t\t\t       true);\n     }\n "}, {"sha": "5d6721813d8100eec3a6e3d1bbb5dd633db2003d", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=91bb9f80e58963d65a5cd305b438a2d7009cdb09", "patch": "@@ -853,7 +853,8 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t  if (known_aggs.exists ())\n \t    {\n \t      agg = known_aggs[c->operand_num];\n-\t      val = ipa_find_agg_cst_for_param (agg, c->offset, c->by_ref);\n+\t      val = ipa_find_agg_cst_for_param (agg, known_vals[c->operand_num],\n+\t\t\t\t\t\tc->offset, c->by_ref);\n \t    }\n \t  else\n \t    val = NULL_TREE;"}, {"sha": "785f2f43ab74c8813854a66491d3aa9f3aaef0c1", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 158, "deletions": 21, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=91bb9f80e58963d65a5cd305b438a2d7009cdb09", "patch": "@@ -930,10 +930,15 @@ parm_ref_data_pass_through_p (struct ipa_func_body_info *fbi, int index,\n   return !modified;\n }\n \n-/* Return true if we can prove that OP is a memory reference loading unmodified\n-   data from an aggregate passed as a parameter and if the aggregate is passed\n-   by reference, that the alias type of the load corresponds to the type of the\n-   formal parameter (so that we can rely on this type for TBAA in callers).\n+/* Return true if we can prove that OP is a memory reference loading\n+   data from an aggregate passed as a parameter.\n+\n+   The function works in two modes.  If GUARANTEED_UNMODIFIED is NULL, it return\n+   false if it cannot prove that the value has not been modified before the\n+   load in STMT.  If GUARANTEED_UNMODIFIED is not NULL, it will return true even\n+   if it cannot prove the value has not been modified, in that case it will\n+   store false to *GUARANTEED_UNMODIFIED, otherwise it will store true there.\n+\n    INFO and PARMS_AINFO describe parameters of the current function (but the\n    latter can be NULL), STMT is the load statement.  If function returns true,\n    *INDEX_P, *OFFSET_P and *BY_REF is filled with the parameter index, offset\n@@ -945,7 +950,7 @@ ipa_load_from_parm_agg (struct ipa_func_body_info *fbi,\n \t\t\tvec<ipa_param_descriptor> descriptors,\n \t\t\tgimple *stmt, tree op, int *index_p,\n \t\t\tHOST_WIDE_INT *offset_p, HOST_WIDE_INT *size_p,\n-\t\t\tbool *by_ref_p)\n+\t\t\tbool *by_ref_p, bool *guaranteed_unmodified)\n {\n   int index;\n   HOST_WIDE_INT size, max_size;\n@@ -966,6 +971,8 @@ ipa_load_from_parm_agg (struct ipa_func_body_info *fbi,\n \t  *by_ref_p = false;\n \t  if (size_p)\n \t    *size_p = size;\n+\t  if (guaranteed_unmodified)\n+\t    *guaranteed_unmodified = true;\n \t  return true;\n \t}\n       return false;\n@@ -1002,13 +1009,18 @@ ipa_load_from_parm_agg (struct ipa_func_body_info *fbi,\n       index = load_from_unmodified_param (fbi, descriptors, def);\n     }\n \n-  if (index >= 0\n-      && parm_ref_data_preserved_p (fbi, index, stmt, op))\n+  if (index >= 0)\n     {\n+      bool data_preserved = parm_ref_data_preserved_p (fbi, index, stmt, op);\n+      if (!data_preserved && !guaranteed_unmodified)\n+\treturn false;\n+\n       *index_p = index;\n       *by_ref_p = true;\n       if (size_p)\n \t*size_p = size;\n+      if (guaranteed_unmodified)\n+\t*guaranteed_unmodified = data_preserved;\n       return true;\n     }\n   return false;\n@@ -1824,6 +1836,7 @@ ipa_note_param_call (struct cgraph_node *node, int param_index,\n   cs->indirect_info->param_index = param_index;\n   cs->indirect_info->agg_contents = 0;\n   cs->indirect_info->member_ptr = 0;\n+  cs->indirect_info->guaranteed_unmodified = 0;\n   return cs;\n }\n \n@@ -1905,15 +1918,17 @@ ipa_analyze_indirect_call_uses (struct ipa_func_body_info *fbi, gcall *call,\n \n   int index;\n   gimple *def = SSA_NAME_DEF_STMT (target);\n+  bool guaranteed_unmodified;\n   if (gimple_assign_single_p (def)\n       && ipa_load_from_parm_agg (fbi, info->descriptors, def,\n \t\t\t\t gimple_assign_rhs1 (def), &index, &offset,\n-\t\t\t\t NULL, &by_ref))\n+\t\t\t\t NULL, &by_ref, &guaranteed_unmodified))\n     {\n       struct cgraph_edge *cs = ipa_note_param_call (fbi->node, index, call);\n       cs->indirect_info->offset = offset;\n       cs->indirect_info->agg_contents = 1;\n       cs->indirect_info->by_ref = by_ref;\n+      cs->indirect_info->guaranteed_unmodified = guaranteed_unmodified;\n       return;\n     }\n \n@@ -2014,6 +2029,7 @@ ipa_analyze_indirect_call_uses (struct ipa_func_body_info *fbi, gcall *call,\n       cs->indirect_info->offset = offset;\n       cs->indirect_info->agg_contents = 1;\n       cs->indirect_info->member_ptr = 1;\n+      cs->indirect_info->guaranteed_unmodified = 1;\n     }\n \n   return;\n@@ -2701,18 +2717,125 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n   return ie;\n }\n \n-/* Retrieve value from aggregate jump function AGG for the given OFFSET or\n-   return NULL if there is not any.  BY_REF specifies whether the value has to\n-   be passed by reference or by value.  */\n+/* Attempt to locate an interprocedural constant at a given REQ_OFFSET in\n+   CONSTRUCTOR and return it.  Return NULL if the search fails for some\n+   reason.  */\n+\n+static tree\n+find_constructor_constant_at_offset (tree constructor, HOST_WIDE_INT req_offset)\n+{\n+  tree type = TREE_TYPE (constructor);\n+  if (TREE_CODE (type) != ARRAY_TYPE\n+      && TREE_CODE (type) != RECORD_TYPE)\n+    return NULL;\n+\n+  unsigned ix;\n+  tree index, val;\n+  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (constructor), ix, index, val)\n+    {\n+      HOST_WIDE_INT elt_offset;\n+      if (TREE_CODE (type) == ARRAY_TYPE)\n+       {\n+         offset_int off;\n+         tree unit_size = TYPE_SIZE_UNIT (TREE_TYPE (type));\n+         gcc_assert (TREE_CODE (unit_size) == INTEGER_CST);\n+\n+         if (index)\n+           {\n+             off = wi::to_offset (index);\n+             if (TYPE_DOMAIN (type) && TYPE_MIN_VALUE (TYPE_DOMAIN (type)))\n+               {\n+                 tree low_bound = TYPE_MIN_VALUE (TYPE_DOMAIN (type));\n+                 gcc_assert (TREE_CODE (unit_size) == INTEGER_CST);\n+                 off = wi::sext (off - wi::to_offset (low_bound),\n+                                 TYPE_PRECISION (TREE_TYPE (index)));\n+               }\n+             off *= wi::to_offset (unit_size);\n+           }\n+         else\n+           off = wi::to_offset (unit_size) * ix;\n+\n+         off = wi::lshift (off, LOG2_BITS_PER_UNIT);\n+         if (!wi::fits_shwi_p (off) || wi::neg_p (off))\n+           continue;\n+         elt_offset = off.to_shwi ();\n+       }\n+      else if (TREE_CODE (type) == RECORD_TYPE)\n+       {\n+         gcc_checking_assert (index && TREE_CODE (index) == FIELD_DECL);\n+         if (DECL_BIT_FIELD (index))\n+           continue;\n+         elt_offset = int_bit_position (index);\n+       }\n+      else\n+       gcc_unreachable ();\n+\n+      if (elt_offset > req_offset)\n+\treturn NULL;\n+\n+      if (TREE_CODE (val) == CONSTRUCTOR)\n+\treturn find_constructor_constant_at_offset (val,\n+\t\t\t\t\t\t    req_offset - elt_offset);\n+\n+      if (elt_offset == req_offset\n+\t  && is_gimple_reg_type (TREE_TYPE (val))\n+\t  && is_gimple_ip_invariant (val))\n+\treturn val;\n+    }\n+  return NULL;\n+}\n+\n+/* Check whether SCALAR could be used to look up an aggregate interprocedural\n+   invariant from a static constructor and if so, return it.  Otherwise return\n+   NULL. */\n+\n+static tree\n+ipa_find_agg_cst_from_init (tree scalar, HOST_WIDE_INT offset, bool by_ref)\n+{\n+  if (by_ref)\n+    {\n+      if (TREE_CODE (scalar) != ADDR_EXPR)\n+\treturn NULL;\n+      scalar = TREE_OPERAND (scalar, 0);\n+    }\n+\n+  if (TREE_CODE (scalar) != VAR_DECL\n+      || !is_global_var (scalar)\n+      || !TREE_READONLY (scalar)\n+      || !DECL_INITIAL (scalar)\n+      || TREE_CODE (DECL_INITIAL (scalar)) != CONSTRUCTOR)\n+    return NULL;\n+\n+  return find_constructor_constant_at_offset (DECL_INITIAL (scalar), offset);\n+}\n+\n+/* Retrieve value from aggregate jump function AGG or static initializer of\n+   SCALAR (which can be NULL) for the given OFFSET or return NULL if there is\n+   none.  BY_REF specifies whether the value has to be passed by reference or\n+   by value.  If FROM_GLOBAL_CONSTANT is non-NULL, then the boolean it points\n+   to is set to true if the value comes from an initializer of a constant.  */\n \n tree\n-ipa_find_agg_cst_for_param (struct ipa_agg_jump_function *agg,\n-\t\t\t    HOST_WIDE_INT offset, bool by_ref)\n+ipa_find_agg_cst_for_param (struct ipa_agg_jump_function *agg, tree scalar,\n+\t\t\t    HOST_WIDE_INT offset, bool by_ref,\n+\t\t\t    bool *from_global_constant)\n {\n   struct ipa_agg_jf_item *item;\n   int i;\n \n-  if (by_ref != agg->by_ref)\n+  if (scalar)\n+    {\n+      tree res = ipa_find_agg_cst_from_init (scalar, offset, by_ref);\n+      if (res)\n+\t{\n+\t  if (from_global_constant)\n+\t    *from_global_constant = true;\n+\t  return res;\n+\t}\n+    }\n+\n+  if (!agg\n+      || by_ref != agg->by_ref)\n     return NULL;\n \n   FOR_EACH_VEC_SAFE_ELT (agg->items, i, item)\n@@ -2721,6 +2844,8 @@ ipa_find_agg_cst_for_param (struct ipa_agg_jump_function *agg,\n \t/* Currently we do not have clobber values, return NULL for them once\n \t   we do.  */\n \tgcc_checking_assert (is_gimple_ip_invariant (item->value));\n+\tif (from_global_constant)\n+\t  *from_global_constant = false;\n \treturn item->value;\n       }\n   return NULL;\n@@ -2819,13 +2944,21 @@ try_make_edge_direct_simple_call (struct cgraph_edge *ie,\n   struct cgraph_edge *cs;\n   tree target;\n   bool agg_contents = ie->indirect_info->agg_contents;\n-\n-  if (ie->indirect_info->agg_contents)\n-    target = ipa_find_agg_cst_for_param (&jfunc->agg,\n-\t\t\t\t\t ie->indirect_info->offset,\n-\t\t\t\t\t ie->indirect_info->by_ref);\n+  tree scalar = ipa_value_from_jfunc (new_root_info, jfunc);\n+  if (agg_contents)\n+    {\n+      bool from_global_constant;\n+      target = ipa_find_agg_cst_for_param (&jfunc->agg, scalar,\n+\t\t\t\t\t   ie->indirect_info->offset,\n+\t\t\t\t\t   ie->indirect_info->by_ref,\n+\t\t\t\t\t   &from_global_constant);\n+      if (target\n+\t  && !from_global_constant\n+\t  && !ie->indirect_info->guaranteed_unmodified)\n+\treturn NULL;\n+    }\n   else\n-    target = ipa_value_from_jfunc (new_root_info, jfunc);\n+    target = scalar;\n   if (!target)\n     return NULL;\n   cs = ipa_make_edge_direct_to_target (ie, target);\n@@ -2893,7 +3026,9 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n     {\n       tree vtable;\n       unsigned HOST_WIDE_INT offset;\n-      tree t = ipa_find_agg_cst_for_param (&jfunc->agg,\n+      tree scalar = (jfunc->type == IPA_JF_CONST) ? ipa_get_jf_constant (jfunc)\n+\t: NULL;\n+      tree t = ipa_find_agg_cst_for_param (&jfunc->agg, scalar,\n \t\t\t\t\t   ie->indirect_info->offset,\n \t\t\t\t\t   true);\n       if (t && vtable_pointer_value_to_vtable (t, &vtable, &offset))\n@@ -4560,6 +4695,7 @@ ipa_write_indirect_edge_info (struct output_block *ob,\n   bp_pack_value (&bp, ii->agg_contents, 1);\n   bp_pack_value (&bp, ii->member_ptr, 1);\n   bp_pack_value (&bp, ii->by_ref, 1);\n+  bp_pack_value (&bp, ii->guaranteed_unmodified, 1);\n   bp_pack_value (&bp, ii->vptr_changed, 1);\n   streamer_write_bitpack (&bp);\n   if (ii->agg_contents || ii->polymorphic)\n@@ -4592,6 +4728,7 @@ ipa_read_indirect_edge_info (struct lto_input_block *ib,\n   ii->agg_contents = bp_unpack_value (&bp, 1);\n   ii->member_ptr = bp_unpack_value (&bp, 1);\n   ii->by_ref = bp_unpack_value (&bp, 1);\n+  ii->guaranteed_unmodified = bp_unpack_value (&bp, 1);\n   ii->vptr_changed = bp_unpack_value (&bp, 1);\n   if (ii->agg_contents || ii->polymorphic)\n     ii->offset = (HOST_WIDE_INT) streamer_read_hwi (ib);"}, {"sha": "e32d078edb3502d06fa02b7f205c0b55cb113b02", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=91bb9f80e58963d65a5cd305b438a2d7009cdb09", "patch": "@@ -636,11 +636,14 @@ tree ipa_impossible_devirt_target (struct cgraph_edge *, tree);\n void ipa_analyze_node (struct cgraph_node *);\n \n /* Aggregate jump function related functions.  */\n-tree ipa_find_agg_cst_for_param (struct ipa_agg_jump_function *, HOST_WIDE_INT,\n-\t\t\t\t bool);\n-bool ipa_load_from_parm_agg (struct ipa_func_body_info *,\n-\t\t\t     vec<ipa_param_descriptor>, gimple *, tree, int *,\n-\t\t\t     HOST_WIDE_INT *, HOST_WIDE_INT *, bool *);\n+tree ipa_find_agg_cst_for_param (struct ipa_agg_jump_function *agg, tree scalar,\n+\t\t\t\t HOST_WIDE_INT offset, bool by_ref,\n+\t\t\t\t bool *from_global_constant = NULL);\n+bool ipa_load_from_parm_agg (struct ipa_func_body_info *fbi,\n+\t\t\t     vec<ipa_param_descriptor> descriptors,\n+\t\t\t     gimple *stmt, tree op, int *index_p,\n+\t\t\t     HOST_WIDE_INT *offset_p, HOST_WIDE_INT *size_p,\n+\t\t\t     bool *by_ref, bool *guaranteed_unmodified = NULL);\n \n /* Debugging interface.  */\n void ipa_print_node_params (FILE *, struct cgraph_node *node);"}, {"sha": "d7dc01607da1a754fbfd25399a13a39153945147", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=91bb9f80e58963d65a5cd305b438a2d7009cdb09", "patch": "@@ -1,3 +1,12 @@\n+2016-05-18  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/69708\n+\t* gcc.dg/ipa/iinline-cstagg-1.c: New test.\n+\t* gcc.dg/ipa/ipcp-cstagg-1.c: Likewise.\n+\t* gcc.dg/ipa/ipcp-cstagg-2.c: Likewise.\n+\t* gcc.dg/ipa/ipcp-cstagg-3.c: Likewise.\n+\t* gcc.dg/ipa/ipcp-cstagg-4.c: Likewise.\n+\n 2016-05-18  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/69793"}, {"sha": "8656cb336fa794232d3a8b7daf0223ed93c84ae8", "filename": "gcc/testsuite/gcc.dg/ipa/iinline-cstagg-1.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-cstagg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-cstagg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-cstagg-1.c?ref=91bb9f80e58963d65a5cd305b438a2d7009cdb09", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-ipa-inline-details -fno-early-inlining -fno-ipa-sra -fno-ipa-cp\" } */\n+\n+typedef struct S\n+{\n+  int add_offset;\n+  int (*call)(int);\n+} S;\n+\n+static int\n+bar (const S *f, int x)\n+{\n+  x = f->call(x);\n+  return x;\n+}\n+\n+static int\n+thisisthetarget (int x)\n+{\n+  return x * x;\n+}\n+\n+static const S s = {16, thisisthetarget};\n+\n+int\n+outerfunction (int x)\n+{\n+  return bar (&s, x);\n+}\n+\n+int\n+obfuscate (int x)\n+{\n+  return bar ((S *) 0, x);\n+}\n+\n+/* { dg-final { scan-ipa-dump \"thisisthetarget\\[^\\\\n\\]*inline copy in outerfunction\"  \"inline\"  } } */"}, {"sha": "4d64ea7d4cec5311dcb61454c322c367a277edde", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-cstagg-1.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-cstagg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-cstagg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-cstagg-1.c?ref=91bb9f80e58963d65a5cd305b438a2d7009cdb09", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-ipa-cp-details\" } */\n+\n+typedef struct S\n+{\n+  int add_offset;\n+  int (*call)(int);\n+} S;\n+\n+extern const S *gs;\n+\n+static int __attribute__((noinline))\n+bar (const S *f, int x)\n+{\n+  x = f->call(x);\n+  x = f->call(x);\n+  x = f->call(x);\n+  gs = f;\n+  return x;\n+}\n+\n+static int\n+sq (int x)\n+{\n+  return x * x;\n+}\n+\n+static const S s = {16, sq};\n+\n+int\n+g (int x)\n+{\n+  return bar (&s, x);\n+}\n+\n+int\n+obfuscate (int x)\n+{\n+  return bar ((S *) 0, x);\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"Discovered an indirect call to a known target\" 3 \"cp\" } } */"}, {"sha": "f82014024d4c0bf1b337b24ec2f6dc5f447dafd2", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-cstagg-2.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-cstagg-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-cstagg-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-cstagg-2.c?ref=91bb9f80e58963d65a5cd305b438a2d7009cdb09", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-ipa-cp-details\" } */\n+\n+typedef struct S\n+{\n+  int (*call)(int);\n+} S;\n+\n+static int __attribute__((noinline))\n+bar (const S *f, int x)\n+{\n+  x = f->call(x);\n+  return x;\n+}\n+\n+extern void impossible_aa (void);\n+\n+static int __attribute__((noinline))\n+baz (const S *f, int x)\n+{\n+  impossible_aa ();\n+  return bar (f, x);\n+}\n+\n+static int\n+sq (int x)\n+{\n+  return x * x;\n+}\n+\n+static const S s = {sq};\n+\n+int\n+g (int x)\n+{\n+  return baz (&s, x);\n+}\n+\n+int\n+obfuscate (int x)\n+{\n+  return baz ((S *) 0, x);\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Discovered an indirect call to a known target\" \"cp\" } } */\n+"}, {"sha": "917f1389f3efa6a0dfa25e229230457fe034c82e", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-cstagg-3.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-cstagg-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-cstagg-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-cstagg-3.c?ref=91bb9f80e58963d65a5cd305b438a2d7009cdb09", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-ipa-cp-details\" } */\n+\n+#define N 4\n+\n+typedef int (* const A[N])(int);\n+\n+extern const A *ga;\n+\n+static int  __attribute__((noinline))\n+bar (const A *f, int x)\n+{\n+  x = (*f)[2](x);\n+  x = (*f)[2](x);\n+  x = (*f)[2](x);\n+  ga = f;\n+  return x;\n+}\n+\n+static int\n+zero (int x)\n+{\n+  return 0;\n+}\n+\n+static int\n+addone (int x)\n+{\n+  return x + 1;\n+}\n+\n+static int\n+sq (int x)\n+{\n+  return x * x;\n+}\n+\n+static int\n+cube (int x)\n+{\n+  return x * x * x;\n+}\n+\n+static const A a = {zero, addone, sq, cube};\n+\n+int\n+g (int x)\n+{\n+  return bar (&a, x);\n+}\n+\n+int\n+obfuscate (int x)\n+{\n+  return bar ((A *) 0, x);\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"Discovered an indirect call to a known target\" 3 \"cp\" } } */"}, {"sha": "7458402c88e6592461a80f586a5725018db7509b", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-cstagg-4.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-cstagg-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bb9f80e58963d65a5cd305b438a2d7009cdb09/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-cstagg-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-cstagg-4.c?ref=91bb9f80e58963d65a5cd305b438a2d7009cdb09", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-ipa-cp-details\" } */\n+\n+#define N 4\n+\n+typedef int (* const A[N])(int);\n+\n+typedef struct S\n+{\n+  int add_offset;\n+  A a;\n+} S;\n+\n+extern const S *gs;\n+\n+static int  __attribute__((noinline))\n+bar (const S *f, int x)\n+{\n+  gs = f;\n+  x = f->a[2](x);\n+  x = f->a[2](x);\n+  x = f->a[2](x);\n+  return x;\n+}\n+\n+static int\n+zero (int x)\n+{\n+  return 0;\n+}\n+\n+static int\n+addone (int x)\n+{\n+  return x + 1;\n+}\n+\n+static int\n+sq (int x)\n+{\n+  return x * x;\n+}\n+\n+static int\n+cube (int x)\n+{\n+  return x * x * x;\n+}\n+\n+static const S s = {64, {zero, addone, sq, cube}};\n+\n+int\n+g (int x)\n+{\n+  return bar (&s, x);\n+}\n+\n+int\n+obfuscate (int x)\n+{\n+  return bar ((S *) 0, x);\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"Discovered an indirect call to a known target\" 3 \"cp\" } } */"}]}