{"sha": "4054bc52d6c353aceeb7a9312347c2c98e837783", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA1NGJjNTJkNmMzNTNhY2VlYjdhOTMxMjM0N2MyYzk4ZTgzNzc4Mw==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2011-07-07T12:46:18Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-07-07T12:46:18Z"}, "message": "trans.c (gfc_allocate_with_status): Call _gfortran_caf_register with NULL arguments for (new) stat=/errmsg= arguments.\n\n2011-07-07  Tobias Burnus  <burnus@net-b.de>\n\n        * trans.c (gfc_allocate_with_status): Call _gfortran_caf_register\n        with NULL arguments for (new) stat=/errmsg= arguments.\n\n2011-07-07  Tobias Burnus  <burnus@net-b.de>\n\n        * libcaf.h (__attribute__, unlikely, likely): New macros.\n        (caf_register_t): Update comment.\n        (_gfortran_caf_register): Add stat, errmsg, errmsg_len arguments.\n        * single.c (_gfortran_caf_register): Ditto; add error diagnostics.\n        * mpi.c (_gfortran_caf_register): Ditto.\n        (caf_is_finalized): New global variable.\n        (_gfortran_caf_finalize): Use it.\n\nFrom-SVN: r175966", "tree": {"sha": "b37e5a976d269b3995d6bf2d0549805071b660ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b37e5a976d269b3995d6bf2d0549805071b660ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4054bc52d6c353aceeb7a9312347c2c98e837783", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4054bc52d6c353aceeb7a9312347c2c98e837783", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4054bc52d6c353aceeb7a9312347c2c98e837783", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4054bc52d6c353aceeb7a9312347c2c98e837783/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3c3ab6c5e1ef023b0c75a2dd36dc3c36cb840e33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c3ab6c5e1ef023b0c75a2dd36dc3c36cb840e33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c3ab6c5e1ef023b0c75a2dd36dc3c36cb840e33"}], "stats": {"total": 125, "additions": 115, "deletions": 10}, "files": [{"sha": "267c81e3076b74add8edb5ab8d76a2de1d2b9b5d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4054bc52d6c353aceeb7a9312347c2c98e837783/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4054bc52d6c353aceeb7a9312347c2c98e837783/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4054bc52d6c353aceeb7a9312347c2c98e837783", "patch": "@@ -1,3 +1,8 @@\n+2011-07-07  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* trans.c (gfc_allocate_with_status): Call _gfortran_caf_register\n+\twith NULL arguments for (new) stat=/errmsg= arguments.\n+\n 2011-07-06  Daniel Carrera <dcarrera@gmail.com>\n \n \t* trans-array.c (gfc_array_allocate): Rename allocatable_array to"}, {"sha": "4043df287f1d8edaae575a99984c5faf95c4a7ab", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4054bc52d6c353aceeb7a9312347c2c98e837783/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4054bc52d6c353aceeb7a9312347c2c98e837783/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=4054bc52d6c353aceeb7a9312347c2c98e837783", "patch": "@@ -622,13 +622,16 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status,\n       gfc_add_modify (&alloc_block, res,\n \t      fold_convert (prvoid_type_node,\n \t\t    build_call_expr_loc (input_location,\n-\t\t\t gfor_fndecl_caf_register, 3,\n+\t\t\t gfor_fndecl_caf_register, 6,\n \t\t\t fold_build2_loc (input_location,\n \t\t\t\t  MAX_EXPR, size_type_node, size,\n \t\t\t\t  build_int_cst (size_type_node, 1)),\n \t\t\t build_int_cst (integer_type_node,\n \t\t\t\t\tGFC_CAF_COARRAY_ALLOC),\n-\t\t\t null_pointer_node)));  /* Token */\n+\t\t\t null_pointer_node,  /* token  */\n+\t\t\t null_pointer_node,  /* stat  */\n+\t\t\t null_pointer_node,  /* errmsg, errmsg_len  */\n+\t\t\t build_int_cst (integer_type_node, 0))));\n     }\n   else\n     {"}, {"sha": "b7114e9dbae32c24f1e090f120a5ee6b55c5bac7", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4054bc52d6c353aceeb7a9312347c2c98e837783/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4054bc52d6c353aceeb7a9312347c2c98e837783/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=4054bc52d6c353aceeb7a9312347c2c98e837783", "patch": "@@ -1,3 +1,13 @@\n+2011-07-07  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* libcaf.h (__attribute__, unlikely, likely): New macros.\n+\t(caf_register_t): Update comment.\n+\t(_gfortran_caf_register): Add stat, errmsg, errmsg_len arguments.\n+\t* single.c (_gfortran_caf_register): Ditto; add error diagnostics.\n+\t* mpi.c (_gfortran_caf_register): Ditto.\n+\t(caf_is_finalized): New global variable.\n+\t(_gfortran_caf_finalize): Use it.\n+\n 2011-07-05  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \t* runtime/memory.c (internal_malloc_size):  If size is zero,"}, {"sha": "4fe09e4c8a0d4571359ccd0554919253749597c7", "filename": "libgfortran/caf/libcaf.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4054bc52d6c353aceeb7a9312347c2c98e837783/libgfortran%2Fcaf%2Flibcaf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4054bc52d6c353aceeb7a9312347c2c98e837783/libgfortran%2Fcaf%2Flibcaf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Flibcaf.h?ref=4054bc52d6c353aceeb7a9312347c2c98e837783", "patch": "@@ -30,6 +30,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <stdint.h>\t/* For int32_t.  */\n #include <stddef.h>\t/* For ptrdiff_t.  */\n \n+#ifndef __GNUC__\n+#define __attribute__(x)\n+#define likely(x)       (x)\n+#define unlikely(x)     (x)\n+#else\n+#define likely(x)       __builtin_expect(!!(x), 1)\n+#define unlikely(x)     __builtin_expect(!!(x), 0)\n+#endif\n \n /* Definitions of the Fortran 2008 standard; need to kept in sync with\n    ISO_FORTRAN_ENV, cf. libgfortran.h.  */\n@@ -38,7 +46,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define STAT_LOCKED_OTHER_IMAGE\t2\n #define STAT_STOPPED_IMAGE \t3\n \n-/* Describes what type of array we are registerring.  */\n+/* Describes what type of array we are registerring. Keep in sync with\n+   gcc/fortran/trans.h.  */\n typedef enum caf_register_t {\n   CAF_REGTYPE_COARRAY_STATIC,\n   CAF_REGTYPE_COARRAY_ALLOC,\n@@ -58,7 +67,8 @@ caf_static_t;\n void _gfortran_caf_init (int *, char ***, int *, int *);\n void _gfortran_caf_finalize (void);\n \n-void * _gfortran_caf_register (ptrdiff_t, caf_register_t, void **);\n+void * _gfortran_caf_register (ptrdiff_t, caf_register_t, void **, int *,\n+\t\t\t       char *, int);\n int _gfortran_caf_deregister (void **);\n \n "}, {"sha": "4e3a7eb359ca9b309fab6e9b3108d00e9c69e900", "filename": "libgfortran/caf/mpi.c", "status": "modified", "additions": 54, "deletions": 4, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4054bc52d6c353aceeb7a9312347c2c98e837783/libgfortran%2Fcaf%2Fmpi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4054bc52d6c353aceeb7a9312347c2c98e837783/libgfortran%2Fcaf%2Fmpi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Fmpi.c?ref=4054bc52d6c353aceeb7a9312347c2c98e837783", "patch": "@@ -41,6 +41,7 @@ static void error_stop (int error) __attribute__ ((noreturn));\n static int caf_mpi_initialized;\n static int caf_this_image;\n static int caf_num_images;\n+static int caf_is_finalized;\n \n caf_static_t *caf_static_list = NULL;\n \n@@ -87,14 +88,20 @@ _gfortran_caf_finalize (void)\n \n   if (!caf_mpi_initialized)\n     MPI_Finalize ();\n+\n+  caf_is_finalized = 1;\n }\n \n \n void *\n-_gfortran_caf_register (ptrdiff_t size, caf_register_t type,\n-                        void **token)\n+_gfortran_caf_register (ptrdiff_t size, caf_register_t type, void **token,\n+\t\t\tint *stat, char *errmsg, int errmsg_len)\n {\n   void *local;\n+  int err;\n+\n+  if (unlikely (caf_is_finalized))\n+    goto error;\n \n   /* Start MPI if not already started.  */\n   if (caf_num_images == 0)\n@@ -104,9 +111,18 @@ _gfortran_caf_register (ptrdiff_t size, caf_register_t type,\n   local = malloc (size);\n   token = malloc (sizeof (void*) * caf_num_images);\n \n+  if (unlikely (local == NULL || token == NULL))\n+    goto error;\n+\n   /* token[img-1] is the address of the token in image \"img\".  */\n-  MPI_Allgather (&local, sizeof (void*), MPI_BYTE,\n-\t\t token,  sizeof (void*), MPI_BYTE, MPI_COMM_WORLD);\n+  err = MPI_Allgather (&local, sizeof (void*), MPI_BYTE, token,\n+\t\t       sizeof (void*), MPI_BYTE, MPI_COMM_WORLD);\n+  if (unlikely (err))\n+    {\n+      free (local);\n+      free (token);\n+      goto error;\n+    }\n \n   if (type == CAF_REGTYPE_COARRAY_STATIC)\n     {\n@@ -115,7 +131,41 @@ _gfortran_caf_register (ptrdiff_t size, caf_register_t type,\n       tmp->token = token;\n       caf_static_list = tmp;\n     }\n+\n+  if (stat)\n+    *stat = 0;\n+\n   return local;\n+\n+error:\n+  if (stat)\n+    {\n+      *stat = caf_is_finalized ? STAT_STOPPED_IMAGE : 1;\n+      if (errmsg_len > 0)\n+\t{\n+\t  char *msg;\n+\t  if (caf_is_finalized)\n+\t    msg = \"Failed to allocate coarray - stopped images\";\n+\t  else\n+\t    msg = \"Failed to allocate coarray\";\n+\t  int len = ((int) strlen (msg) > errmsg_len) ? errmsg_len\n+\t\t\t\t\t\t      : (int) strlen (msg);\n+\t  memcpy (errmsg, msg, len);\n+\t  if (errmsg_len > len)\n+\t    memset (&errmsg[len], ' ', errmsg_len-len);\n+\t}\n+      return NULL;\n+    }\n+  else\n+    {\n+      if (caf_is_finalized)\n+\tfprintf (stderr, \"ERROR: Image %d is stopped, failed to allocate \"\n+\t\t \"coarray\", caf_this_image);\n+      else\n+\tfprintf (stderr, \"ERROR: Failed to allocate coarray on image %d\\n\",\n+\t\t caf_this_image);\n+      error_stop (1);\n+    }\n }\n \n "}, {"sha": "603a910aeb3c102e592464008977ce0c71dcba0c", "filename": "libgfortran/caf/single.c", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4054bc52d6c353aceeb7a9312347c2c98e837783/libgfortran%2Fcaf%2Fsingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4054bc52d6c353aceeb7a9312347c2c98e837783/libgfortran%2Fcaf%2Fsingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Fsingle.c?ref=4054bc52d6c353aceeb7a9312347c2c98e837783", "patch": "@@ -27,6 +27,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libcaf.h\"\n #include <stdio.h>  /* For fputs and fprintf.  */\n #include <stdlib.h> /* For exit and malloc.  */\n+#include <string.h> /* For memcpy and memset.  */\n \n /* Define GFC_CAF_CHECK to enable run-time checking.  */\n /* #define GFC_CAF_CHECK  1  */\n@@ -61,15 +62,41 @@ _gfortran_caf_finalize (void)\n \n \n void *\n-_gfortran_caf_register (ptrdiff_t size, caf_register_t type,\n-\t\t\tvoid **token)\n+_gfortran_caf_register (ptrdiff_t size, caf_register_t type, void **token,\n+\t\t\tint *stat, char *errmsg, int errmsg_len)\n {\n   void *local;\n \n   local = malloc (size);\n   token = malloc (sizeof (void*) * 1);\n   token[0] = local;\n \n+  if (unlikely (local == NULL || token == NULL))\n+    {\n+      if (stat)\n+\t{\n+\t  *stat = 1;\n+\t  if (errmsg_len > 0)\n+\t    {\n+\t      const char msg[] = \"Failed to allocate coarray\";\n+\t      int len = ((int) sizeof (msg) > errmsg_len) ? errmsg_len\n+\t\t\t\t\t\t\t  : (int) sizeof (msg);\n+\t      memcpy (errmsg, msg, len);\n+\t      if (errmsg_len > len)\n+\t\tmemset (&errmsg[len], ' ', errmsg_len-len);\n+\t    }\n+\t  return NULL;\n+\t}\n+      else\n+\t{\n+\t  fprintf (stderr, \"ERROR: Failed to allocate coarray\");\n+\t  exit (1);\n+\t}\n+    }\n+\n+  if (stat)\n+    *stat = 0;\n+\n   if (type == CAF_REGTYPE_COARRAY_STATIC)\n     {\n       caf_static_t *tmp = malloc (sizeof (caf_static_t));"}]}