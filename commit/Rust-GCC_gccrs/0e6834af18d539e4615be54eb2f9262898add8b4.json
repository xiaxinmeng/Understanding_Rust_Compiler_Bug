{"sha": "0e6834af18d539e4615be54eb2f9262898add8b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU2ODM0YWYxOGQ1MzllNDYxNWJlNTRlYjJmOTI2Mjg5OGFkZDhiNA==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael.morin@tele2.fr", "date": "2008-10-31T15:37:17Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2008-10-31T15:37:17Z"}, "message": "[multiple changes]\n\n\n2008-10-31  Mikael Morin  <mikael.morin@tele2.fr>\n\n\tPR fortran/35820\n\t* resolve.c (gfc_count_forall_iterators): New function.\n\t(gfc_resolve_forall): Use gfc_count_forall_iterators to evaluate \n\tthe needed memory amount to allocate. Don't forget to free allocated \n\tmemory.  Add an assertion to check for memory leaks. \n\n2008-10-16  Mikael Morin  <mikael.morin@tele2.fr>\n\n\tPR fortran/35820\n\t* gfortran.dg/nested_forall_1.f: New test.\n\nFrom-SVN: r141496", "tree": {"sha": "cc77f0252a3e696614d3c0628d79d9fdf56725e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc77f0252a3e696614d3c0628d79d9fdf56725e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e6834af18d539e4615be54eb2f9262898add8b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e6834af18d539e4615be54eb2f9262898add8b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e6834af18d539e4615be54eb2f9262898add8b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e6834af18d539e4615be54eb2f9262898add8b4/comments", "author": null, "committer": null, "parents": [{"sha": "798c19f8557f4600cab847999a3f70a0ff3763f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/798c19f8557f4600cab847999a3f70a0ff3763f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/798c19f8557f4600cab847999a3f70a0ff3763f3"}], "stats": {"total": 122, "additions": 107, "deletions": 15}, "files": [{"sha": "1075d98025fd90e70a056d9568b0920c92af5ae4", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6834af18d539e4615be54eb2f9262898add8b4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6834af18d539e4615be54eb2f9262898add8b4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0e6834af18d539e4615be54eb2f9262898add8b4", "patch": "@@ -1,3 +1,11 @@\n+2008-10-31  Mikael Morin  <mikael.morin@tele2.fr>\n+\n+\tPR fortran/35820\n+\t* resolve.c (gfc_count_forall_iterators): New function.\n+\t(gfc_resolve_forall): Use gfc_count_forall_iterators to evaluate \n+\tthe needed memory amount to allocate. Don't forget to free allocated \n+\tmemory.  Add an assertion to check for memory leaks. \n+\n 2008-10-30  Steven G. Kargl  <kargls@comcast.net>\n \n \tPR fortran/37930"}, {"sha": "3cd6899faae8455ea1c0142c5d911478c227369e", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 56, "deletions": 15, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6834af18d539e4615be54eb2f9262898add8b4/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6834af18d539e4615be54eb2f9262898add8b4/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=0e6834af18d539e4615be54eb2f9262898add8b4", "patch": "@@ -6215,6 +6215,40 @@ gfc_resolve_forall_body (gfc_code *code, int nvar, gfc_expr **var_expr)\n }\n \n \n+/* Counts the number of iterators needed inside a forall construct, including\n+   nested forall constructs. This is used to allocate the needed memory \n+   in gfc_resolve_forall.  */\n+\n+static int \n+gfc_count_forall_iterators (gfc_code *code)\n+{\n+  int max_iters, sub_iters, current_iters;\n+  gfc_forall_iterator *fa;\n+\n+  gcc_assert(code->op == EXEC_FORALL);\n+  max_iters = 0;\n+  current_iters = 0;\n+\n+  for (fa = code->ext.forall_iterator; fa; fa = fa->next)\n+    current_iters ++;\n+  \n+  code = code->block->next;\n+\n+  while (code)\n+    {          \n+      if (code->op == EXEC_FORALL)\n+        {\n+          sub_iters = gfc_count_forall_iterators (code);\n+          if (sub_iters > max_iters)\n+            max_iters = sub_iters;\n+        }\n+      code = code->next;\n+    }\n+\n+  return current_iters + max_iters;\n+}\n+\n+\n /* Given a FORALL construct, first resolve the FORALL iterator, then call\n    gfc_resolve_forall_body to resolve the FORALL body.  */\n \n@@ -6224,22 +6258,18 @@ gfc_resolve_forall (gfc_code *code, gfc_namespace *ns, int forall_save)\n   static gfc_expr **var_expr;\n   static int total_var = 0;\n   static int nvar = 0;\n+  int old_nvar, tmp;\n   gfc_forall_iterator *fa;\n-  gfc_code *next;\n   int i;\n \n+  old_nvar = nvar;\n+\n   /* Start to resolve a FORALL construct   */\n   if (forall_save == 0)\n     {\n       /* Count the total number of FORALL index in the nested FORALL\n-\t construct in order to allocate the VAR_EXPR with proper size.  */\n-      next = code;\n-      while ((next != NULL) && (next->op == EXEC_FORALL))\n-\t{\n-\t  for (fa = next->ext.forall_iterator; fa; fa = fa->next)\n-\t    total_var ++;\n-\t  next = next->block->next;\n-\t}\n+         construct in order to allocate the VAR_EXPR with proper size.  */\n+      total_var = gfc_count_forall_iterators (code);\n \n       /* Allocate VAR_EXPR with NUMBER_OF_FORALL_INDEX elements.  */\n       var_expr = (gfc_expr **) gfc_getmem (total_var * sizeof (gfc_expr *));\n@@ -6264,6 +6294,9 @@ gfc_resolve_forall (gfc_code *code, gfc_namespace *ns, int forall_save)\n       var_expr[nvar] = gfc_copy_expr (fa->var);\n \n       nvar++;\n+\n+      /* No memory leak.  */\n+      gcc_assert (nvar <= total_var);\n     }\n \n   /* Resolve the FORALL body.  */\n@@ -6272,13 +6305,21 @@ gfc_resolve_forall (gfc_code *code, gfc_namespace *ns, int forall_save)\n   /* May call gfc_resolve_forall to resolve the inner FORALL loop.  */\n   gfc_resolve_blocks (code->block, ns);\n \n-  /* Free VAR_EXPR after the whole FORALL construct resolved.  */\n-  for (i = 0; i < total_var; i++)\n-    gfc_free_expr (var_expr[i]);\n+  tmp = nvar;\n+  nvar = old_nvar;\n+  /* Free only the VAR_EXPRs allocated in this frame.  */\n+  for (i = nvar; i < tmp; i++)\n+     gfc_free_expr (var_expr[i]);\n \n-  /* Reset the counters.  */\n-  total_var = 0;\n-  nvar = 0;\n+  if (nvar == 0)\n+    {\n+      /* We are in the outermost FORALL construct.  */\n+      gcc_assert (forall_save == 0);\n+\n+      /* VAR_EXPR is not needed any more.  */\n+      gfc_free (var_expr);\n+      total_var = 0;\n+    }\n }\n \n "}, {"sha": "d0d12425f3c0abfdf665f6fa4a5244e05fffb407", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6834af18d539e4615be54eb2f9262898add8b4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6834af18d539e4615be54eb2f9262898add8b4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0e6834af18d539e4615be54eb2f9262898add8b4", "patch": "@@ -1,3 +1,8 @@\n+2008-10-16  Mikael Morin  <mikael.morin@tele2.fr>\n+\n+\tPR fortran/35820\n+\t* gfortran.dg/nested_forall_1.f: New test.\n+\n 2008-10-30  Steven G. Kargl  <kargls@comcast.net>\n \n \tPR fortran/37930"}, {"sha": "6aa66ee97a7cca3dd5c67901a2939cf468bda204", "filename": "gcc/testsuite/gfortran.dg/nested_forall_1.f", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6834af18d539e4615be54eb2f9262898add8b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_forall_1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6834af18d539e4615be54eb2f9262898add8b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_forall_1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_forall_1.f?ref=0e6834af18d539e4615be54eb2f9262898add8b4", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do compile }\n+!\n+! PR fortran/35820\n+! \n+! Memory leak(s) while resolving forall constructs.\n+! \n+! Contributed by Dick Hendrickson <dick.hendrickson@gmail.com>\n+\n+      MODULE TESTS\n+      INTEGER,PARAMETER,PUBLIC  ::  I1_KV = KIND(1)\n+      INTEGER,PARAMETER,PUBLIC  ::  R1_KV = KIND(1.0)\n+      INTEGER, PRIVATE :: J1,J2\n+      INTEGER,PARAMETER,PUBLIC  ::  S1 = 10, S2 = 9\n+      CONTAINS\n+      SUBROUTINE SA0136(RDA,IDA,BDA)\n+      REAL(R1_KV) RDA(S1)\n+      INTEGER(I1_KV) IDA(S1,S2)\n+      INTEGER(I1_KV) ICA(S1,S2)\n+      REAL(R1_KV) RCA(S1)\n+!  T E S T  S T A T E M E N T S\n+      FORALL (J1 = 1:S1)\n+        RDA(J1) = RCA(J1) + 1.0_R1_KV\n+        FORALL (J2 = 1:S2)\n+          IDA(J1,J2) = ICA(J1,J2) + 1\n+        END FORALL\n+        FORALL (J2 = 1:S2)\n+          IDA(J1,J2) = ICA(J1,J2)\n+        END FORALL\n+      ENDFORALL\n+      FORALL (J1 = 1:S1)\n+        RDA(J1) = RCA(J1)\n+        FORALL (J2 = 1:S2)\n+          IDA(J1,J2) = ICA(J1,J2)\n+        END FORALL\n+      END FORALL\n+      END SUBROUTINE\n+      END MODULE TESTS\n+! { dg-final { cleanup-modules \"tests\" } }"}]}