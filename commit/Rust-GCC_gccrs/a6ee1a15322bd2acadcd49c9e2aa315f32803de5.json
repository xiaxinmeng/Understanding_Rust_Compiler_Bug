{"sha": "a6ee1a15322bd2acadcd49c9e2aa315f32803de5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZlZTFhMTUzMjJiZDJhY2FkY2Q0OWM5ZTJhYTMxNWYzMjgwM2RlNQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-14T17:43:01Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-14T17:43:01Z"}, "message": "basic-block.h: Update the prototypes of cached_make_edge and rtl_make_eh_edge.\n\n\t* basic-block.h: Update the prototypes of cached_make_edge and\n\trtl_make_eh_edge.\n\t* cfg.c (cached_make_edge): Take edge_cache representing one\n\trow of the adjacency matrix of edges.\n\t* cfgbuild.c (make_label_edge, rtl_make_eh_edge): Likewise.\n\t(make_edges): Initialize edge_cache to represent one row of\n\tthe adjacency matrix of edges.\n\nFrom-SVN: r96440", "tree": {"sha": "7a6695b3b563544db8a32ee9bf5feb671e54c6b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a6695b3b563544db8a32ee9bf5feb671e54c6b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6ee1a15322bd2acadcd49c9e2aa315f32803de5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6ee1a15322bd2acadcd49c9e2aa315f32803de5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6ee1a15322bd2acadcd49c9e2aa315f32803de5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6ee1a15322bd2acadcd49c9e2aa315f32803de5/comments", "author": null, "committer": null, "parents": [{"sha": "8eaa0f34a3387db91dd66466d201930e83332300", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8eaa0f34a3387db91dd66466d201930e83332300", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8eaa0f34a3387db91dd66466d201930e83332300"}], "stats": {"total": 63, "additions": 34, "deletions": 29}, "files": [{"sha": "53f5d5c3185564930a4e2c4fc44c1eb80aff0b56", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ee1a15322bd2acadcd49c9e2aa315f32803de5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ee1a15322bd2acadcd49c9e2aa315f32803de5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6ee1a15322bd2acadcd49c9e2aa315f32803de5", "patch": "@@ -1,3 +1,13 @@\n+2005-03-14  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* basic-block.h: Update the prototypes of cached_make_edge and\n+\trtl_make_eh_edge.\n+\t* cfg.c (cached_make_edge): Take edge_cache representing one\n+\trow of the adjacency matrix of edges.\n+\t* cfgbuild.c (make_label_edge, rtl_make_eh_edge): Likewise.\n+\t(make_edges): Initialize edge_cache to represent one row of\n+\tthe adjacency matrix of edges.\n+\n 2005-03-14  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* tree-ssa-phiopt.c (minmax_replacement, blocks_in_phiopt_order):"}, {"sha": "45c511a1975a1e7c9b1aaede0fbae4652d184f4c", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ee1a15322bd2acadcd49c9e2aa315f32803de5/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ee1a15322bd2acadcd49c9e2aa315f32803de5/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=a6ee1a15322bd2acadcd49c9e2aa315f32803de5", "patch": "@@ -449,7 +449,7 @@ extern void remove_fake_exit_edges (void);\n extern void add_noreturn_fake_exit_edges (void);\n extern void connect_infinite_loops_to_exit (void);\n extern edge unchecked_make_edge (basic_block, basic_block, int);\n-extern edge cached_make_edge (sbitmap *, basic_block, basic_block, int);\n+extern edge cached_make_edge (sbitmap, basic_block, basic_block, int);\n extern edge make_edge (basic_block, basic_block, int);\n extern edge make_single_succ_edge (basic_block, basic_block, int);\n extern void remove_edge (edge);\n@@ -817,7 +817,7 @@ extern bool forwarder_block_p (basic_block);\n extern bool purge_all_dead_edges (int);\n extern bool purge_dead_edges (basic_block);\n extern void find_many_sub_basic_blocks (sbitmap);\n-extern void rtl_make_eh_edge (sbitmap *, basic_block, rtx);\n+extern void rtl_make_eh_edge (sbitmap, basic_block, rtx);\n extern bool can_fallthru (basic_block, basic_block);\n extern bool could_fall_through (basic_block, basic_block);\n extern void flow_nodes_print (const char *, const sbitmap, FILE *);"}, {"sha": "03f1ee1f9d2e158a857e6d96ed6fa80572bca415", "filename": "gcc/cfg.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ee1a15322bd2acadcd49c9e2aa315f32803de5/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ee1a15322bd2acadcd49c9e2aa315f32803de5/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=a6ee1a15322bd2acadcd49c9e2aa315f32803de5", "patch": "@@ -327,19 +327,19 @@ unchecked_make_edge (basic_block src, basic_block dst, int flags)\n    edge cache CACHE.  Return the new edge, NULL if already exist.  */\n \n edge\n-cached_make_edge (sbitmap *edge_cache, basic_block src, basic_block dst, int flags)\n+cached_make_edge (sbitmap edge_cache, basic_block src, basic_block dst, int flags)\n {\n   if (edge_cache == NULL\n       || src == ENTRY_BLOCK_PTR\n       || dst == EXIT_BLOCK_PTR)\n     return make_edge (src, dst, flags);\n \n   /* Does the requested edge already exist?  */\n-  if (! TEST_BIT (edge_cache[src->index], dst->index))\n+  if (! TEST_BIT (edge_cache, dst->index))\n     {\n       /* The edge does not exist.  Create one and update the\n \t cache.  */\n-      SET_BIT (edge_cache[src->index], dst->index);\n+      SET_BIT (edge_cache, dst->index);\n       return unchecked_make_edge (src, dst, flags);\n     }\n "}, {"sha": "88a10450270318208f031346956c74c217eeb490", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ee1a15322bd2acadcd49c9e2aa315f32803de5/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ee1a15322bd2acadcd49c9e2aa315f32803de5/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=a6ee1a15322bd2acadcd49c9e2aa315f32803de5", "patch": "@@ -49,7 +49,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n static int count_basic_blocks (rtx);\n static void find_basic_blocks_1 (rtx);\n static void make_edges (basic_block, basic_block, int);\n-static void make_label_edge (sbitmap *, basic_block, rtx, int);\n+static void make_label_edge (sbitmap, basic_block, rtx, int);\n static void find_bb_boundaries (basic_block);\n static void compute_outgoing_frequencies (basic_block);\n \f\n@@ -179,7 +179,7 @@ count_basic_blocks (rtx f)\n /* Create an edge from a basic block to a label.  */\n \n static void\n-make_label_edge (sbitmap *edge_cache, basic_block src, rtx label, int flags)\n+make_label_edge (sbitmap edge_cache, basic_block src, rtx label, int flags)\n {\n   gcc_assert (LABEL_P (label));\n \n@@ -197,7 +197,7 @@ make_label_edge (sbitmap *edge_cache, basic_block src, rtx label, int flags)\n /* Create the edges generated by INSN in REGION.  */\n \n void\n-rtl_make_eh_edge (sbitmap *edge_cache, basic_block src, rtx insn)\n+rtl_make_eh_edge (sbitmap edge_cache, basic_block src, rtx insn)\n {\n   int is_call = CALL_P (insn) ? EDGE_ABNORMAL_CALL : 0;\n   rtx handlers, i;\n@@ -233,46 +233,41 @@ static void\n make_edges (basic_block min, basic_block max, int update_p)\n {\n   basic_block bb;\n-  sbitmap *edge_cache = NULL;\n+  sbitmap edge_cache = NULL;\n \n   /* Heavy use of computed goto in machine-generated code can lead to\n      nearly fully-connected CFGs.  In that case we spend a significant\n      amount of time searching the edge lists for duplicates.  */\n   if (forced_labels || cfun->max_jumptable_ents > 100)\n-    {\n-      edge_cache = sbitmap_vector_alloc (last_basic_block, last_basic_block);\n-      sbitmap_vector_zero (edge_cache, last_basic_block);\n-\n-      if (update_p)\n-\t{\n-\t  FOR_BB_BETWEEN (bb, min, max->next_bb, next_bb)\n-\t    if (STATE (bb) != BLOCK_ORIGINAL)\n-\t      {\n-\t\tedge e;\n-\t\tedge_iterator ei;\n-\t\t\n-\t\tFOR_EACH_EDGE (e, ei, bb->succs)\n-\t\t  if (e->dest != EXIT_BLOCK_PTR)\n-\t\t    SET_BIT (edge_cache[bb->index], e->dest->index);\n-\t      }\n-\t}\n-    }\n+    edge_cache = sbitmap_alloc (last_basic_block);\n \n   /* By nature of the way these get numbered, ENTRY_BLOCK_PTR->next_bb block\n      is always the entry.  */\n   if (min == ENTRY_BLOCK_PTR->next_bb)\n-    cached_make_edge (edge_cache, ENTRY_BLOCK_PTR, min,\n-\t\t      EDGE_FALLTHRU);\n+    make_edge (ENTRY_BLOCK_PTR, min, EDGE_FALLTHRU);\n \n   FOR_BB_BETWEEN (bb, min, max->next_bb, next_bb)\n     {\n       rtx insn, x;\n       enum rtx_code code;\n       edge e;\n+      edge_iterator ei;\n \n       if (STATE (bb) == BLOCK_ORIGINAL)\n \tcontinue;\n \n+      /* If we have an edge cache, cache edges going out of BB.  */\n+      if (edge_cache)\n+\t{\n+\t  sbitmap_zero (edge_cache);\n+\t  if (update_p)\n+\t    {\n+\t      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t\tif (e->dest != EXIT_BLOCK_PTR)\n+\t\t  SET_BIT (edge_cache, e->dest->index);\n+\t    }\n+\t}\n+\n       if (LABEL_P (BB_HEAD (bb))\n \t  && LABEL_ALT_ENTRY_P (BB_HEAD (bb)))\n \tcached_make_edge (NULL, ENTRY_BLOCK_PTR, bb, 0);"}]}