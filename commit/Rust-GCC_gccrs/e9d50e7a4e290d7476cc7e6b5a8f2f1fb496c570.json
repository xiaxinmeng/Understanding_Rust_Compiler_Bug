{"sha": "e9d50e7a4e290d7476cc7e6b5a8f2f1fb496c570", "node_id": "C_kwDOANBUbNoAKGU5ZDUwZTdhNGUyOTBkNzQ3NmNjN2U2YjVhOGYyZjFmYjQ5NmM1NzA", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-10-05T18:22:38Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-10-06T06:21:41Z"}, "message": "Setting explicit NANs sets UNDEFINED for -ffinite-math-only.\n\nWe recently agreed that setting a range of NAN should instead set\nUNDEFINED for -ffinite-math-only.  This patch makes that change to\nfrange::set_nan() directly.  Also, calling frange::update_nan() will now\nbe a nop for !HONOR_NANS.\n\nDoing this in the setters simplifies everywhere we set NANs, as it keeps\nus from introducing NANs by mistake.\n\ngcc/ChangeLog:\n\n\t* value-range.cc (frange::set): Call set_nan unconditionally.\n\t(range_tests_nan): Adjust tests.\n\t(range_tests_signed_zeros): Same.\n\t(range_tests_floats): Same.\n\t* value-range.h (frange::update_nan): Guard with HONOR_NANS.\n\t(frange::set_nan): Set undefined if !HONOR_NANS.", "tree": {"sha": "0db52705e95413668e60b84b211f9cdcf8f9cae8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0db52705e95413668e60b84b211f9cdcf8f9cae8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9d50e7a4e290d7476cc7e6b5a8f2f1fb496c570", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d50e7a4e290d7476cc7e6b5a8f2f1fb496c570", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9d50e7a4e290d7476cc7e6b5a8f2f1fb496c570", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d50e7a4e290d7476cc7e6b5a8f2f1fb496c570/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9eab8e45dd106ee6b9ca9fa9ec46876b0bb7f482", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eab8e45dd106ee6b9ca9fa9ec46876b0bb7f482", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eab8e45dd106ee6b9ca9fa9ec46876b0bb7f482"}], "stats": {"total": 119, "additions": 67, "deletions": 52}, "files": [{"sha": "87239fafa77dd1a65a60767253ca26e983d8bb6a", "filename": "gcc/value-range.cc", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d50e7a4e290d7476cc7e6b5a8f2f1fb496c570/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d50e7a4e290d7476cc7e6b5a8f2f1fb496c570/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=e9d50e7a4e290d7476cc7e6b5a8f2f1fb496c570", "patch": "@@ -304,13 +304,8 @@ frange::set (tree type,\n   if (real_isnan (&min) || real_isnan (&max))\n     {\n       gcc_checking_assert (real_identical (&min, &max));\n-      if (HONOR_NANS (type))\n-\t{\n-\t  bool sign = real_isneg (&min);\n-\t  set_nan (type, sign);\n-\t}\n-      else\n-\tset_undefined ();\n+      bool sign = real_isneg (&min);\n+      set_nan (type, sign);\n       return;\n     }\n \n@@ -3624,6 +3619,7 @@ range_tests_nan ()\n {\n   frange r0, r1;\n   REAL_VALUE_TYPE q, r;\n+  bool signbit;\n \n   // Equal ranges but with differing NAN bits are not equal.\n   if (HONOR_NANS (float_type_node))\n@@ -3735,14 +3731,33 @@ range_tests_nan ()\n   r0.set_nan (float_type_node);\n   r0.clear_nan ();\n   ASSERT_TRUE (r0.undefined_p ());\n+\n+  // [10,20] NAN ^ [21,25] NAN = [NAN]\n+  r0 = frange_float (\"10\", \"20\");\n+  r0.update_nan ();\n+  r1 = frange_float (\"21\", \"25\");\n+  r1.update_nan ();\n+  r0.intersect (r1);\n+  ASSERT_TRUE (r0.known_isnan ());\n+\n+  // NAN U [5,6] should be [5,6] +-NAN.\n+  r0.set_nan (float_type_node);\n+  r1 = frange_float (\"5\", \"6\");\n+  r1.clear_nan ();\n+  r0.union_ (r1);\n+  real_from_string (&q, \"5\");\n+  real_from_string (&r, \"6\");\n+  ASSERT_TRUE (real_identical (&q, &r0.lower_bound ()));\n+  ASSERT_TRUE (real_identical (&r, &r0.upper_bound ()));\n+  ASSERT_TRUE (!r0.signbit_p (signbit));\n+  ASSERT_TRUE (r0.maybe_isnan ());\n }\n \n static void\n range_tests_signed_zeros ()\n {\n   tree zero = build_zero_cst (float_type_node);\n   tree neg_zero = fold_build1 (NEGATE_EXPR, float_type_node, zero);\n-  REAL_VALUE_TYPE q, r;\n   frange r0, r1;\n   bool signbit;\n \n@@ -3788,18 +3803,6 @@ range_tests_signed_zeros ()\n   r0.intersect (r1);\n   ASSERT_TRUE (r0.zero_p ());\n \n-  // NAN U [5,6] should be [5,6] NAN.\n-  r0.set_nan (float_type_node);\n-  r1 = frange_float (\"5\", \"6\");\n-  r1.clear_nan ();\n-  r0.union_ (r1);\n-  real_from_string (&q, \"5\");\n-  real_from_string (&r, \"6\");\n-  ASSERT_TRUE (real_identical (&q, &r0.lower_bound ()));\n-  ASSERT_TRUE (real_identical (&r, &r0.upper_bound ()));\n-  ASSERT_TRUE (!r0.signbit_p (signbit));\n-  ASSERT_TRUE (r0.maybe_isnan ());\n-\n   r0 = frange_float (\"+0\", \"5\");\n   r0.clear_nan ();\n   ASSERT_TRUE (r0.signbit_p (signbit) && !signbit);\n@@ -3823,7 +3826,10 @@ range_tests_signed_zeros ()\n   r1 = frange_float (\"0\", \"0\");\n   r1.update_nan ();\n   r0.intersect (r1);\n-  ASSERT_TRUE (r0.known_isnan ());\n+  if (HONOR_NANS (float_type_node))\n+    ASSERT_TRUE (r0.known_isnan ());\n+  else\n+    ASSERT_TRUE (r0.undefined_p ());\n \n   r0.set_nonnegative (float_type_node);\n   ASSERT_TRUE (r0.signbit_p (signbit) && !signbit);\n@@ -3863,7 +3869,8 @@ range_tests_floats ()\n {\n   frange r0, r1;\n \n-  range_tests_nan ();\n+  if (HONOR_NANS (float_type_node))\n+    range_tests_nan ();\n   range_tests_signbit ();\n \n   if (HONOR_SIGNED_ZEROS (float_type_node))\n@@ -3936,14 +3943,6 @@ range_tests_floats ()\n   r0.intersect (r1);\n   ASSERT_EQ (r0, frange_float (\"15\", \"20\"));\n \n-  // [10,20] NAN ^ [21,25] NAN = [NAN]\n-  r0 = frange_float (\"10\", \"20\");\n-  r0.update_nan ();\n-  r1 = frange_float (\"21\", \"25\");\n-  r1.update_nan ();\n-  r0.intersect (r1);\n-  ASSERT_TRUE (r0.known_isnan ());\n-\n   // [10,20] ^ [21,25] = []\n   r0 = frange_float (\"10\", \"20\");\n   r0.clear_nan ();"}, {"sha": "b06ca7477cd60df996350a52dfc89b96aedfe1a1", "filename": "gcc/value-range.h", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d50e7a4e290d7476cc7e6b5a8f2f1fb496c570/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d50e7a4e290d7476cc7e6b5a8f2f1fb496c570/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=e9d50e7a4e290d7476cc7e6b5a8f2f1fb496c570", "patch": "@@ -1111,11 +1111,14 @@ inline void\n frange::update_nan ()\n {\n   gcc_checking_assert (!undefined_p ());\n-  m_pos_nan = true;\n-  m_neg_nan = true;\n-  normalize_kind ();\n-  if (flag_checking)\n-    verify_range ();\n+  if (HONOR_NANS (m_type))\n+    {\n+      m_pos_nan = true;\n+      m_neg_nan = true;\n+      normalize_kind ();\n+      if (flag_checking)\n+\tverify_range ();\n+    }\n }\n \n // Like above, but set the sign of the NAN.\n@@ -1124,11 +1127,14 @@ inline void\n frange::update_nan (bool sign)\n {\n   gcc_checking_assert (!undefined_p ());\n-  m_pos_nan = !sign;\n-  m_neg_nan = sign;\n-  normalize_kind ();\n-  if (flag_checking)\n-    verify_range ();\n+  if (HONOR_NANS (m_type))\n+    {\n+      m_pos_nan = !sign;\n+      m_neg_nan = sign;\n+      normalize_kind ();\n+      if (flag_checking)\n+\tverify_range ();\n+    }\n }\n \n // Clear the NAN bit and adjust the range.\n@@ -1213,25 +1219,35 @@ frange_val_is_max (const REAL_VALUE_TYPE &r, const_tree type)\n inline void\n frange::set_nan (tree type)\n {\n-  m_kind = VR_NAN;\n-  m_type = type;\n-  m_pos_nan = true;\n-  m_neg_nan = true;\n-  if (flag_checking)\n-    verify_range ();\n+  if (HONOR_NANS (type))\n+    {\n+      m_kind = VR_NAN;\n+      m_type = type;\n+      m_pos_nan = true;\n+      m_neg_nan = true;\n+      if (flag_checking)\n+\tverify_range ();\n+    }\n+  else\n+    set_undefined ();\n }\n \n // Build a NAN of type TYPE with SIGN.\n \n inline void\n frange::set_nan (tree type, bool sign)\n {\n-  m_kind = VR_NAN;\n-  m_type = type;\n-  m_neg_nan = sign;\n-  m_pos_nan = !sign;\n-  if (flag_checking)\n-    verify_range ();\n+  if (HONOR_NANS (type))\n+    {\n+      m_kind = VR_NAN;\n+      m_type = type;\n+      m_neg_nan = sign;\n+      m_pos_nan = !sign;\n+      if (flag_checking)\n+\tverify_range ();\n+    }\n+  else\n+    set_undefined ();\n }\n \n // Return TRUE if range is known to be finite."}]}