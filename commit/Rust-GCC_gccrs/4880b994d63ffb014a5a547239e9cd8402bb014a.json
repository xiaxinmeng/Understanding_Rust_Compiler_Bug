{"sha": "4880b994d63ffb014a5a547239e9cd8402bb014a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg4MGI5OTRkNjNmZmIwMTRhNWE1NDcyMzllOWNkODQwMmJiMDE0YQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2018-01-24T23:50:09Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-24T23:50:09Z"}, "message": "compiler: rationalize external symbol names\n    \n    Encode all external symbol names using only ASCII alphanumeric\n    characters, underscore, and dot.  Use a scheme that can be reliably\n    demangled to a somewhat readable version as described in the long\n    comment in names.cc.\n    \n    A minor cleanup discovered during this was that we were treating\n    function types as different if one had a NULL parameters_ field and\n    another has a non-NULL parameters_ field that has no parameters.  This\n    worked because we mangled them slightly differently.  We now mangle\n    them the same, so we treat them as equal, as we should anyhow.\n    \n    Reviewed-on: https://go-review.googlesource.com/89555\n\n\t* go.go-torture/execute/names-1.go: New test.\n\nFrom-SVN: r257033", "tree": {"sha": "a782ef29045ab50de17cac215b8c30c9a3b61aa2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a782ef29045ab50de17cac215b8c30c9a3b61aa2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4880b994d63ffb014a5a547239e9cd8402bb014a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4880b994d63ffb014a5a547239e9cd8402bb014a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4880b994d63ffb014a5a547239e9cd8402bb014a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4880b994d63ffb014a5a547239e9cd8402bb014a/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d3719ee2c078a1518c9e21efae0cf438d4ffb8d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3719ee2c078a1518c9e21efae0cf438d4ffb8d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3719ee2c078a1518c9e21efae0cf438d4ffb8d6"}], "stats": {"total": 1300, "additions": 924, "deletions": 376}, "files": [{"sha": "0430961f7bcec93ddf0ab81d15f8321c39c10a21", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=4880b994d63ffb014a5a547239e9cd8402bb014a", "patch": "@@ -1,4 +1,4 @@\n-3488a401e50835de5de5c4f153772ac2798d0e71\n+0bbc03f81c862fb35be3edee9824698a7892a17e\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "e15e85f3082c05d4fae25ecd136cd85973c4e831", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 22, "deletions": 31, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=4880b994d63ffb014a5a547239e9cd8402bb014a", "patch": "@@ -686,42 +686,33 @@ debug_function_name(Named_object* fn)\n \n   if (!fn->is_function())\n     return Gogo::unpack_hidden_name(fn->name());\n-  if (fn->func_value()->enclosing() == NULL)\n+\n+  std::string fnname = Gogo::unpack_hidden_name(fn->name());\n+  if (fn->func_value()->is_method())\n     {\n-      std::string fnname = Gogo::unpack_hidden_name(fn->name());\n-      if (fn->func_value()->is_method())\n-        {\n-          // Methods in gc compiler are named \"T.m\" or \"(*T).m\" where\n-          // T is the receiver type. Add the receiver here.\n-          Type* rt = fn->func_value()->type()->receiver()->type();\n-          switch (rt->classification())\n-            {\n-              case Type::TYPE_NAMED:\n-                fnname = rt->named_type()->name() + \".\" + fnname;\n-                break;\n+      // Methods in gc compiler are named \"T.m\" or \"(*T).m\" where\n+      // T is the receiver type. Add the receiver here.\n+      Type* rt = fn->func_value()->type()->receiver()->type();\n+      switch (rt->classification())\n+\t{\n+\tcase Type::TYPE_NAMED:\n+\t  fnname = rt->named_type()->name() + \".\" + fnname;\n+\t  break;\n \n-              case Type::TYPE_POINTER:\n-                {\n-                  Named_type* nt = rt->points_to()->named_type();\n-                  if (nt != NULL)\n-                    fnname = \"(*\" + nt->name() + \").\" + fnname;\n-                  break;\n-                }\n+\tcase Type::TYPE_POINTER:\n+\t  {\n+\t    Named_type* nt = rt->points_to()->named_type();\n+\t    if (nt != NULL)\n+\t      fnname = \"(*\" + nt->name() + \").\" + fnname;\n+\t    break;\n+\t  }\n \n-              default:\n-                break;\n-            }\n-        }\n-      return fnname;\n+\tdefault:\n+\t  break;\n+\t}\n     }\n \n-  // Closures are named \".$nested#\" where # is a global counter. Add outer\n-  // function name for better distinguishing. This is also closer to what\n-  // gc compiler prints, \"outer.func#\".\n-  Named_object* enclosing = fn->func_value()->enclosing();\n-  std::string name = Gogo::unpack_hidden_name(fn->name());\n-  std::string outer_name = Gogo::unpack_hidden_name(enclosing->name());\n-  return outer_name + \".\" + name;\n+  return fnname;\n }\n \n // Return the name of the current function."}, {"sha": "0701cb045187f1aedbd786616aac39809c14d764", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=4880b994d63ffb014a5a547239e9cd8402bb014a", "patch": "@@ -1310,6 +1310,16 @@ Func_descriptor_expression::do_get_backend(Translate_context* context)\n       && Linemap::is_predeclared_location(no->location()))\n     is_descriptor = true;\n \n+  // The runtime package implements some functions defined in the\n+  // syscall package.  Let the syscall package define the descriptor\n+  // in this case.\n+  if (gogo->compiling_runtime()\n+      && gogo->package_name() == \"runtime\"\n+      && no->is_function()\n+      && !no->func_value()->asm_name().empty()\n+      && no->func_value()->asm_name().compare(0, 8, \"syscall.\") == 0)\n+    is_descriptor = true;\n+\n   Btype* btype = this->type()->get_backend(gogo);\n \n   Bvariable* bvar;\n@@ -6845,16 +6855,17 @@ Bound_method_expression::create_thunk(Gogo* gogo, const Method* method,\n \n   if (orig_fntype == NULL || !orig_fntype->is_method())\n     {\n-      ins.first->second = Named_object::make_erroneous_name(Gogo::thunk_name());\n+      ins.first->second =\n+\tNamed_object::make_erroneous_name(gogo->thunk_name());\n       return ins.first->second;\n     }\n \n   Struct_field_list* sfl = new Struct_field_list();\n   // The type here is wrong--it should be the C function type.  But it\n   // doesn't really matter.\n   Type* vt = Type::make_pointer_type(Type::make_void_type());\n-  sfl->push_back(Struct_field(Typed_identifier(\"fn.0\", vt, loc)));\n-  sfl->push_back(Struct_field(Typed_identifier(\"val.1\",\n+  sfl->push_back(Struct_field(Typed_identifier(\"fn\", vt, loc)));\n+  sfl->push_back(Struct_field(Typed_identifier(\"val\",\n \t\t\t\t\t       orig_fntype->receiver()->type(),\n \t\t\t\t\t       loc)));\n   Struct_type* st = Type::make_struct_type(sfl, loc);\n@@ -6863,7 +6874,7 @@ Bound_method_expression::create_thunk(Gogo* gogo, const Method* method,\n \n   Function_type* new_fntype = orig_fntype->copy_with_names();\n \n-  std::string thunk_name = Gogo::thunk_name();\n+  std::string thunk_name = gogo->thunk_name();\n   Named_object* new_no = gogo->start_function(thunk_name, new_fntype,\n \t\t\t\t\t      false, loc);\n \n@@ -7009,10 +7020,10 @@ Bound_method_expression::do_flatten(Gogo* gogo, Named_object*,\n   // away with this.\n \n   Struct_field_list* fields = new Struct_field_list();\n-  fields->push_back(Struct_field(Typed_identifier(\"fn.0\",\n+  fields->push_back(Struct_field(Typed_identifier(\"fn\",\n \t\t\t\t\t\t  thunk->func_value()->type(),\n \t\t\t\t\t\t  loc)));\n-  fields->push_back(Struct_field(Typed_identifier(\"val.1\", val->type(), loc)));\n+  fields->push_back(Struct_field(Typed_identifier(\"val\", val->type(), loc)));\n   Struct_type* st = Type::make_struct_type(fields, loc);\n   st->set_is_struct_incomparable();\n \n@@ -11889,25 +11900,25 @@ Interface_field_reference_expression::create_thunk(Gogo* gogo,\n \n   const Typed_identifier* method_id = type->find_method(name);\n   if (method_id == NULL)\n-    return Named_object::make_erroneous_name(Gogo::thunk_name());\n+    return Named_object::make_erroneous_name(gogo->thunk_name());\n \n   Function_type* orig_fntype = method_id->type()->function_type();\n   if (orig_fntype == NULL)\n-    return Named_object::make_erroneous_name(Gogo::thunk_name());\n+    return Named_object::make_erroneous_name(gogo->thunk_name());\n \n   Struct_field_list* sfl = new Struct_field_list();\n   // The type here is wrong--it should be the C function type.  But it\n   // doesn't really matter.\n   Type* vt = Type::make_pointer_type(Type::make_void_type());\n-  sfl->push_back(Struct_field(Typed_identifier(\"fn.0\", vt, loc)));\n-  sfl->push_back(Struct_field(Typed_identifier(\"val.1\", type, loc)));\n+  sfl->push_back(Struct_field(Typed_identifier(\"fn\", vt, loc)));\n+  sfl->push_back(Struct_field(Typed_identifier(\"val\", type, loc)));\n   Struct_type* st = Type::make_struct_type(sfl, loc);\n   st->set_is_struct_incomparable();\n   Type* closure_type = Type::make_pointer_type(st);\n \n   Function_type* new_fntype = orig_fntype->copy_with_names();\n \n-  std::string thunk_name = Gogo::thunk_name();\n+  std::string thunk_name = gogo->thunk_name();\n   Named_object* new_no = gogo->start_function(thunk_name, new_fntype,\n \t\t\t\t\t      false, loc);\n \n@@ -11995,10 +12006,10 @@ Interface_field_reference_expression::do_get_backend(Translate_context* context)\n   Location loc = this->location();\n \n   Struct_field_list* fields = new Struct_field_list();\n-  fields->push_back(Struct_field(Typed_identifier(\"fn.0\",\n+  fields->push_back(Struct_field(Typed_identifier(\"fn\",\n \t\t\t\t\t\t  thunk->func_value()->type(),\n \t\t\t\t\t\t  loc)));\n-  fields->push_back(Struct_field(Typed_identifier(\"val.1\",\n+  fields->push_back(Struct_field(Typed_identifier(\"val\",\n \t\t\t\t\t\t  this->expr_->type(),\n \t\t\t\t\t\t  loc)));\n   Struct_type* st = Type::make_struct_type(fields, loc);\n@@ -12247,7 +12258,7 @@ Selector_expression::lower_method_expression(Gogo* gogo)\n       return f;\n     }\n \n-  Named_object* no = gogo->start_function(Gogo::thunk_name(), fntype, false,\n+  Named_object* no = gogo->start_function(gogo->thunk_name(), fntype, false,\n \t\t\t\t\t  location);\n \n   Named_object* vno = gogo->lookup(receiver_name, NULL);"}, {"sha": "ec5c37fc40ec5a7ab3bbe19b4949572aff5bec85", "filename": "gcc/go/gofrontend/go-encode-id.cc", "status": "modified", "additions": 72, "deletions": 12, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.cc?ref=4880b994d63ffb014a5a547239e9cd8402bb014a", "patch": "@@ -4,11 +4,16 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+#include \"go-system.h\"\n+\n+#include \"gogo.h\"\n #include \"go-location.h\"\n #include \"go-linemap.h\"\n #include \"go-encode-id.h\"\n+#include \"lex.h\"\n \n-// Return whether the character c is OK to use in the assembler.\n+// Return whether the character c is OK to use in the assembler.  We\n+// only permit ASCII alphanumeric characters, underscore, and dot.\n \n static bool\n char_needs_encoding(char c)\n@@ -27,7 +32,7 @@ char_needs_encoding(char c)\n     case 'y': case 'z':\n     case '0': case '1': case '2': case '3': case '4':\n     case '5': case '6': case '7': case '8': case '9':\n-    case '_': case '.': case '$': case '/':\n+    case '_': case '.':\n       return false;\n     default:\n       return true;\n@@ -77,28 +82,51 @@ fetch_utf8_char(const char* p, unsigned int* pc)\n   return len;\n }\n \n-// Encode an identifier using ASCII characters.\n+// Encode an identifier using ASCII characters.  The encoding is\n+// described in detail near the end of the long comment at the start\n+// of names.cc.  Short version: translate all non-ASCII-alphanumeric\n+// characters into ..uXXXX or ..UXXXXXXXX.\n \n std::string\n go_encode_id(const std::string &id)\n {\n+  if (Lex::is_invalid_identifier(id))\n+    {\n+      go_assert(saw_errors());\n+      return id;\n+    }\n+\n+  // The encoding is only unambiguous if the input string does not\n+  // contain ..u or ..U.\n+  go_assert(id.find(\"..u\") == std::string::npos);\n+  go_assert(id.find(\"..U\") == std::string::npos);\n+\n   std::string ret;\n   const char* p = id.c_str();\n   const char* pend = p + id.length();\n   while (p < pend)\n     {\n       unsigned int c;\n       size_t len = fetch_utf8_char(p, &c);\n-      if (len == 1 && !char_needs_encoding(c))\n-        ret += c;\n+      if (len == 1)\n+\t{\n+\t  // At this point we should only be seeing alphanumerics or\n+\t  // underscore or dot.\n+\t  go_assert(!char_needs_encoding(c));\n+\t  ret += c;\n+\t}\n+      else if (c < 0x10000)\n+\t{\n+\t  char buf[16];\n+\t  snprintf(buf, sizeof buf, \"..u%04x\", c);\n+\t  ret += buf;\n+\t}\n       else\n-        {\n-          ret += \"$U\";\n-          char buf[30];\n-          snprintf(buf, sizeof buf, \"%x\", c);\n-          ret += buf;\n-          ret += \"$\";\n-        }\n+\t{\n+\t  char buf[16];\n+\t  snprintf(buf, sizeof buf, \"..U%08x\", c);\n+\t  ret += buf;\n+\t}\n       p += len;\n     }\n   return ret;\n@@ -111,3 +139,35 @@ go_selectively_encode_id(const std::string &id)\n     return go_encode_id(id);\n   return std::string();\n }\n+\n+// Encode a struct field tag.  This is only used when we need to\n+// create a type descriptor for an anonymous struct type with field\n+// tags.  This mangling is applied before go_encode_id.  We skip\n+// alphanumerics and underscore, replace every other single byte\n+// character with .xNN, and leave larger UTF-8 characters for\n+// go_encode_id.\n+\n+std::string\n+go_mangle_struct_tag(const std::string& tag)\n+{\n+  std::string ret;\n+  const char* p = tag.c_str();\n+  const char* pend = p + tag.length();\n+  while (p < pend)\n+    {\n+      unsigned int c;\n+      size_t len = fetch_utf8_char(p, &c);\n+      if (len > 1)\n+\tret.append(p, len);\n+      else if (!char_needs_encoding(c) && c != '.')\n+\tret += c;\n+      else\n+\t{\n+\t  char buf[16];\n+\t  snprintf(buf, sizeof buf, \".x%02x\", c);\n+\t  ret += buf;\n+\t}\n+      p += len;\n+    }\n+  return ret;\n+}"}, {"sha": "ec81b63a1821e3757baa01ea4a855804c716016b", "filename": "gcc/go/gofrontend/go-encode-id.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.h?ref=4880b994d63ffb014a5a547239e9cd8402bb014a", "patch": "@@ -9,10 +9,9 @@\n \n #include \"backend.h\"\n \n-// Given an identifier corresponding to a function or variable,\n-// this helper returns TRUE if the identifier needs special\n-// encoding to be used as an ASM name (symbol), FALSE if the name\n-// is OK as is.\n+// Given an identifier that will appear in assembly code, this helper\n+// returns TRUE if the identifier needs special encoding to be used as\n+// an ASM name, FALSE if the name is OK as is.\n extern bool\n go_id_needs_encoding(const std::string& str);\n \n@@ -22,9 +21,12 @@ extern std::string\n go_encode_id(const std::string &id);\n \n // Returns the empty string if the specified name needs encoding,\n-// otherwise invokes go_encode_id() on the name and returns the\n-// result.\n+// otherwise invokes go_encode_id on the name and returns the result.\n extern std::string\n go_selectively_encode_id(const std::string &id);\n \n+// Encodes a struct tag that appears in a type literal encoding.\n+extern std::string\n+go_mangle_struct_tag(const std::string& tag);\n+\n #endif // !defined(GO_ENCODE_ID_H)"}, {"sha": "83be6176ae7e04e63aed9585b0a548f96f07f8a6", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=4880b994d63ffb014a5a547239e9cd8402bb014a", "patch": "@@ -1758,7 +1758,7 @@ Gogo::start_function(const std::string& name, Function_type* type,\n   else\n     {\n       // Invent a name for a nested function.\n-      nested_name = this->nested_function_name();\n+      nested_name = this->nested_function_name(enclosing);\n       pname = &nested_name;\n     }\n \n@@ -4821,9 +4821,9 @@ Function::Function(Function_type* type, Named_object* enclosing, Block* block,\n   : type_(type), enclosing_(enclosing), results_(NULL),\n     closure_var_(NULL), block_(block), location_(location), labels_(),\n     local_type_count_(0), descriptor_(NULL), fndecl_(NULL), defer_stack_(NULL),\n-    pragmas_(0), is_sink_(false), results_are_named_(false),\n-    is_unnamed_type_stub_method_(false), calls_recover_(false),\n-    is_recover_thunk_(false), has_recover_thunk_(false),\n+    pragmas_(0), nested_functions_(0), is_sink_(false),\n+    results_are_named_(false), is_unnamed_type_stub_method_(false),\n+    calls_recover_(false), is_recover_thunk_(false), has_recover_thunk_(false),\n     calls_defer_retaddr_(false), is_type_specific_function_(false),\n     in_unique_section_(false)\n {\n@@ -4948,7 +4948,7 @@ Function::set_closure_type()\n   // The first field of a closure is always a pointer to the function\n   // code.\n   Type* voidptr_type = Type::make_pointer_type(Type::make_void_type());\n-  st->push_field(Struct_field(Typed_identifier(\".$f\", voidptr_type,\n+  st->push_field(Struct_field(Typed_identifier(\".f\", voidptr_type,\n \t\t\t\t\t       this->location_)));\n \n   unsigned int index = 1;"}, {"sha": "5135042763d7c73d47f7ab0ed15ea865e291bd48", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=4880b994d63ffb014a5a547239e9cd8402bb014a", "patch": "@@ -801,7 +801,7 @@ class Gogo\n \n   // Return the name to use for a generated stub method.\n   std::string\n-  stub_method_name(const std::string& method_name);\n+  stub_method_name(const Package*, const std::string& method_name);\n \n   // Return the names of the hash and equality functions for TYPE.\n   void\n@@ -826,7 +826,7 @@ class Gogo\n   // Return a name to use for a thunk function.  A thunk function is\n   // one we create during the compilation, for a go statement or a\n   // defer statement or a method expression.\n-  static std::string\n+  std::string\n   thunk_name();\n \n   // Return whether an object is a thunk.\n@@ -838,8 +838,8 @@ class Gogo\n   init_function_name();\n \n   // Return the name to use for a nested function.\n-  static std::string\n-  nested_function_name();\n+  std::string\n+  nested_function_name(Named_object* enclosing);\n \n   // Return the name to use for a sink funciton.\n   std::string\n@@ -887,6 +887,12 @@ class Gogo\n   std::string\n   interface_method_table_name(Interface_type*, Type*, bool is_pointer);\n \n+  // Return whether NAME is a special name that can not be passed to\n+  // unpack_hidden_name.  This is needed because various special names\n+  // use \"..SUFFIX\", but unpack_hidden_name just looks for '.'.\n+  static bool\n+  is_special_name(const std::string& name);\n+\n  private:\n   // During parsing, we keep a stack of functions.  Each function on\n   // the stack is one that we are currently parsing.  For each\n@@ -1233,6 +1239,11 @@ class Function\n   results_are_named() const\n   { return this->results_are_named_; }\n \n+  // Return the assembler name.\n+  const std::string&\n+  asm_name() const\n+  { return this->asm_name_; }\n+\n   // Set the assembler name.\n   void\n   set_asm_name(const std::string& asm_name)\n@@ -1250,6 +1261,14 @@ class Function\n     this->pragmas_ = pragmas;\n   }\n \n+  // Return the index to use for a nested function.\n+  unsigned int\n+  next_nested_function_index()\n+  {\n+    ++this->nested_functions_;\n+    return this->nested_functions_;\n+  }\n+\n   // Whether this method should not be included in the type\n   // descriptor.\n   bool\n@@ -1510,6 +1529,8 @@ class Function\n   Temporary_statement* defer_stack_;\n   // Pragmas for this function.  This is a set of GOPRAGMA bits.\n   unsigned int pragmas_;\n+  // Number of nested functions defined within this function.\n+  unsigned int nested_functions_;\n   // True if this function is sink-named.  No code is generated.\n   bool is_sink_ : 1;\n   // True if the result variables are named."}, {"sha": "560f5f9d34d2bd3828166732c9804896570af1f5", "filename": "gcc/go/gofrontend/lex.cc", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2Flex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2Flex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Flex.cc?ref=4880b994d63ffb014a5a547239e9cd8402bb014a", "patch": "@@ -2761,16 +2761,19 @@ bool\n Lex::is_exported_name(const std::string& name)\n {\n   unsigned char c = name[0];\n-  if (c != '$')\n+  if (c != '.')\n     return c >= 'A' && c <= 'Z';\n   else\n     {\n       const char* p = name.data();\n       size_t len = name.length();\n-      if (len < 2 || p[1] != 'U')\n+      if (len < 4 || p[1] != '.' || (p[2] != 'u' && p[2] != 'U'))\n \treturn false;\n       unsigned int ci = 0;\n-      for (size_t i = 2; i < len && p[i] != '$'; ++i)\n+      size_t want = (p[2] == 'u' ? 4 : 8);\n+      if (len < want + 3)\n+\treturn false;\n+      for (size_t i = 3; i < want; ++i)\n \t{\n \t  c = p[i];\n \t  if (!Lex::is_hex_digit(c))"}, {"sha": "eb18f81cc1688aaee7afc3bf44442eda33766a35", "filename": "gcc/go/gofrontend/names.cc", "status": "modified", "additions": 515, "deletions": 263, "changes": 778, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2Fnames.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2Fnames.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fnames.cc?ref=4880b994d63ffb014a5a547239e9cd8402bb014a", "patch": "@@ -15,6 +15,190 @@\n // assembly code.  This is not used for names that appear only in the\n // debug info.\n \n+// Our external names contain only ASCII alphanumeric characters,\n+// underscore, and dot.  (According to the GCC sources, dot is not\n+// permitted in assembler symbols on VxWorks and MMIX.  We will not\n+// support those systems.)  Go names can not contain dot, so we rely\n+// on using dot to encode Unicode characters, and to separate Go\n+// symbols by package, and so forth.  We assume that none of the\n+// non-Go symbols in the final link will contain a dot, so we don't\n+// worry about conflicts.\n+//\n+// We first describe the basic symbol names, used to represent Go\n+// functions and variables.  These never start with a dot, never end\n+// with a dot, never contain two consecutive dots, and never contain a\n+// dot followed by a digit.\n+//\n+// The external name for a normal Go symbol NAME, a function or\n+// variable, is simply \"PKGPATH.NAME\".  Note that NAME is not the\n+// packed form used for the \"hidden\" name internally in the compiler;\n+// it is the name that appears in the source code.  PKGPATH is the\n+// -fgo-pkgpath option as adjusted by Gogo::pkgpath_for_symbol.  Note\n+// that PKGPATH can not contain a dot and neither can NAME.  Also,\n+// NAME may not begin with a digit.  NAME may require further encoding\n+// for non-ASCII characters as described below, but until that\n+// encoding these symbols contain exactly one dot, and they do not\n+// start with a dot.\n+//\n+// The external name for a method NAME for a named type TYPE is\n+// \"PKGPATH.TYPE.NAME\".  Unlike the gc compiler, the external name\n+// does not indicate whether this is a pointer method or a value\n+// method; a named type can not have both a pointer and value method\n+// with the same name, so there is no ambiguity.  PKGPATH is the\n+// package path of the package in which TYPE is defined.  Here none of\n+// PKGPATH, TYPE, or NAME can be empty or contain a dot, and neither\n+// TYPE nor NAME may begin with a digit.  Before encoding these names\n+// contain exactly two dots, not consecutive, and they do not start\n+// with a dot.\n+//\n+// It's uncommon, but the use of type literals with embedded fields\n+// can cause us to have methods on unnamed types.  The external names\n+// for these are also PKGPATH.TYPE.NAME, where TYPE is an\n+// approximately readable version of the type literal, described\n+// below.  As the type literal encoding always contains multiple dots,\n+// these names always contain more than two dots.  Although the type\n+// literal encoding contains dots, neither PKGPATH nor NAME can\n+// contain a dot, and neither TYPE nor NAME can begin with a digit.\n+// The effect is that PKGPATH is always the portion of the name before\n+// the first dot and NAME is always the portion after the last dot.\n+// There is no ambiguity as long as encoded type literals are\n+// unambiguous.\n+//\n+// Also uncommon is an external name that must refer to a named type\n+// defined within a function.  While such a type can not have methods\n+// itself, it can pick up embedded methods, and those methods need\n+// names.  These are treated as a kind of type literal written as,\n+// before type literal encoding, FNNAME.TYPENAME(INDEX) or, for a\n+// method, TYPE.MNAME.TYPENAME(INDEX).  INDEX is the index of that\n+// named type within the function, as a single function can have\n+// multiple types with the same name.  This is unambiguous as\n+// parentheses can not appear in a type literal in this form (they can\n+// only appear in interface method declarations).\n+//\n+// That is the end of the list of basic names.  The remaining names\n+// exist for special purposes, and are differentiated from the basic\n+// names by containing two consecutive dots.\n+//\n+// The hash function for a type is treated as a method whose name is\n+// \".hash\".  That is, the method name begins with a dot.  The effect\n+// is that there will be two consecutive dots in the name; the name\n+// will always end with \"..hash\".\n+//\n+// Similarly the equality function for a type is treated as a method\n+// whose name is \".eq\".\n+//\n+// The function descriptor for a function is the same as the name of\n+// the function with an added suffix \"..f\".\n+//\n+// A thunk for a go or defer statement is treated as a function whose\n+// name is \".thunkNN\" where NN is a sequence of digits (these\n+// functions are never globally visible).  Thus the final name of a\n+// thunk will be PKGPATH..thunkNN.\n+//\n+// An init function is treated as a function whose name is \".initNN\"\n+// where NN is a sequence of digits (these functions are never\n+// globally visible).  Thus the final name of an init function will be\n+// PKGPATH..initNN.\n+//\n+// A nested function is given the name of outermost enclosing function\n+// or method with an added suffix \"..funcNN\" where NN is a sequence of\n+// digits.  Note that the function descriptor of a nested function, if\n+// needed, will end with \"..funcNN..f\".\n+//\n+// A recover thunk is the same as the name of the function with an\n+// added suffix \"..r\".\n+//\n+// The name of a type descriptor for a named type is PKGPATH.TYPE..d.\n+//\n+// The name of a type descriptor for an unnamed type is type..TYPE.\n+// That is, the string \"type..\" followed by the type literal encoding.\n+// These names are common symbols, in the linker's sense of the word\n+// common: in the final executable there is only one instance of the\n+// type descriptor for a given unnamed type.  The type literal\n+// encoding can never start with a digit or with 'u' or 'U'.\n+//\n+// The name of the GC symbol for a named type is PKGPATH.TYPE..g.\n+//\n+// The name of the GC symbol for an unnamed type is typeg..TYPE.\n+// These are common symbols.\n+//\n+// The name of a ptrmask symbol is gcbits..B32 where B32 is an\n+// encoding of the ptrmask bits using only ASCII letters without 'u'\n+// or 'U'.  These are common symbols.\n+//\n+// An interface method table for assigning the non-interface type TYPE\n+// to the interface type ITYPE is named imt..ITYPE..TYPE.  If ITYPE or\n+// TYPE is a named type, they are written as PKGPATH.TYPE.  Otherwise\n+// they are written as a type literal.  An interface method table for\n+// a pointer method set uses pimt instead of imt.\n+//\n+// The names of composite literal initializers, including the GC root\n+// variable, are not referenced.  They must not conflict with any C\n+// language names, but the names are otherwise unimportant.  They are\n+// named \"go..CNN\" where NN is a sequence of digits.  The names do not\n+// include the PKGPATH.\n+//\n+// The map zero value, a common symbol that represents the zero value\n+// of a map, is named simply \"go..zerovalue\".  The name does not\n+// include the PKGPATH.\n+//\n+// The import function for the main package is referenced by C code,\n+// and is named __go_init_main.  For other packages it is\n+// PKGPATH..import.\n+//\n+// The type literal encoding is essentially a single line version of\n+// the type literal, such as \"struct { pkgpath.i int; J int }\".  In\n+// this representation unexported names use their pkgpath, exported\n+// names omit it.\n+//\n+// The type literal encoding is not quite valid Go, as some aspects of\n+// compiler generated types can not be represented.  For example,\n+// incomparable struct types have an extra field \"{x}\".  Struct tags\n+// are quoted inside curly braces, rather than introduce an encoding\n+// for quotes.  Struct tags can contain any character, so any single\n+// byte Unicode character that is not alphanumeric or underscore is\n+// replaced with .xNN where NN is the hex encoding.\n+//\n+// There is a simple encoding for glue characters in type literals:\n+//   .0 - ' '\n+//   .1 - '*'\n+//   .2 - ';'\n+//   .3 - ','\n+//   .4 - '{'\n+//   .5 - '}'\n+//   .6 - '['\n+//   .7 - ']'\n+//   .8 - '('\n+//   .9 - ')'\n+// This is unambiguous as, although the type literal can contain a dot\n+// as shown above, those dots are always followed by a name and names\n+// can not begin with a digit.  A dot is always followed by a name or\n+// a digit, and a type literal can neither start nor end with a dot,\n+// so this never introduces consecutive dots.\n+//\n+// Struct tags can contain any character, so they need special\n+// treatment.  Alphanumerics, underscores, and Unicode characters that\n+// require more than a single byte are left alone (Unicode characters\n+// will be encoded later, as described below).  Other single bytes\n+// characters are replace with .xNN where NN is the hex encoding.\n+//\n+// Since Go identifiers can contain Unicode characters, we must encode\n+// them into ASCII.  We do this last, after the name is generated as\n+// described above and after type literals are encoded.  To make the\n+// encoding unambiguous, we introduce it with two consecutive dots.\n+// This is followed by the letter u and four hex digits or the letter\n+// U and eight digits, just as in the language only using ..u and ..U\n+// instead of \\u and \\U.  Since before this encoding names can never\n+// contain consecutive dots followed by 'u' or 'U', and after this\n+// encoding \"..u\" and \"..U\" are followed by a known number of\n+// characters, this is unambiguous.\n+//\n+// Demangling these names is straightforward:\n+//  - replace ..uXXXX with a unicode character\n+//  - replace ..UXXXXXXXX with a unicode character\n+//  - replace .D, where D is a digit, with the character from the above\n+// That will get you as close as possible to a readable name.\n+\n // Return the assembler name to use for an exported function, a\n // method, or a function/method declaration.  This is not called if\n // the function has been given an explicit name via a magic //extern\n@@ -27,30 +211,20 @@ std::string\n Gogo::function_asm_name(const std::string& go_name, const Package* package,\n \t\t\tconst Type* rtype)\n {\n-  std::string ret = (package == NULL\n-\t\t     ? this->pkgpath_symbol()\n-\t\t     : package->pkgpath_symbol());\n-\n-  if (rtype != NULL\n-      && Gogo::is_hidden_name(go_name)\n-      && Gogo::hidden_name_pkgpath(go_name) != this->pkgpath())\n-    {\n-      // This is a method created for an unexported method of an\n-      // imported embedded type.  Use the pkgpath of the imported\n-      // package.\n-      std::string p = Gogo::hidden_name_pkgpath(go_name);\n-      ret = this->pkgpath_symbol_for_package(p);\n-    }\n-\n-  ret.append(1, '.');\n-  ret.append(Gogo::unpack_hidden_name(go_name));\n-\n+  std::string ret;\n   if (rtype != NULL)\n-    {\n-      ret.append(1, '.');\n-      ret.append(rtype->mangled_name(this));\n-    }\n-\n+    ret = rtype->mangled_name(this);\n+  else if (package == NULL)\n+    ret = this->pkgpath_symbol();\n+  else\n+    ret = package->pkgpath_symbol();\n+  ret.push_back('.');\n+  // Check for special names that will break if we use\n+  // Gogo::unpack_hidden_name.\n+  if (Gogo::is_special_name(go_name))\n+    ret.append(go_name);\n+  else\n+    ret.append(Gogo::unpack_hidden_name(go_name));\n   return go_encode_id(ret);\n }\n \n@@ -60,41 +234,45 @@ Gogo::function_asm_name(const std::string& go_name, const Package* package,\n std::string\n Gogo::function_descriptor_name(Named_object* no)\n {\n-  std::string var_name;\n-  if (no->is_function_declaration()\n-      && !no->func_declaration_value()->asm_name().empty()\n-      && Linemap::is_predeclared_location(no->location()))\n-    {\n-      if (no->func_declaration_value()->asm_name().substr(0, 8) != \"runtime.\")\n-\tvar_name = no->func_declaration_value()->asm_name() + \"_descriptor\";\n-      else\n-\tvar_name = no->func_declaration_value()->asm_name() + \"$descriptor\";\n-    }\n-  else\n-    {\n-      if (no->package() == NULL)\n-\tvar_name = this->pkgpath_symbol();\n-      else\n-\tvar_name = no->package()->pkgpath_symbol();\n-      var_name.push_back('.');\n-      var_name.append(Gogo::unpack_hidden_name(no->name()));\n-      var_name.append(\"$descriptor\");\n-    }\n-  return var_name;\n+  if (no->is_function() && !no->func_value()->asm_name().empty())\n+    return no->func_value()->asm_name() + \"..f\";\n+  else if (no->is_function_declaration()\n+\t   && !no->func_declaration_value()->asm_name().empty())\n+    return no->func_declaration_value()->asm_name() + \"..f\";\n+  std::string ret = this->function_asm_name(no->name(), no->package(), NULL);\n+  ret.append(\"..f\");\n+  return ret;\n }\n \n // Return the name to use for a generated stub method.  MNAME is the\n-// method name.  These functions are globally visible.  Note that this\n-// is the function name that corresponds to the name used for the\n-// method in Go source code, if this stub method were written in Go.\n-// The assembler name will be generated by Gogo::function_asm_name,\n-// and because this is a method that name will include the receiver\n-// type.\n+// method name.  PACKAGE is the package where the type that needs this\n+// stub method is defined.  These functions are globally visible.\n+// Note that this is the function name that corresponds to the name\n+// used for the method in Go source code, if this stub method were\n+// written in Go.  The assembler name will be generated by\n+// Gogo::function_asm_name, and because this is a method that name\n+// will include the receiver type.\n \n std::string\n-Gogo::stub_method_name(const std::string& mname)\n+Gogo::stub_method_name(const Package* package, const std::string& mname)\n {\n-  return mname + \"$stub\";\n+  if (!Gogo::is_hidden_name(mname))\n+    return mname + \"..stub\";\n+\n+  const std::string& ppkgpath(package == NULL\n+\t\t\t      ? this->pkgpath()\n+\t\t\t      : package->pkgpath());\n+  std::string mpkgpath = Gogo::hidden_name_pkgpath(mname);\n+  if (mpkgpath == ppkgpath)\n+    return Gogo::unpack_hidden_name(mname) + \"..stub\";\n+\n+  // We are creating a stub method for an unexported method of an\n+  // imported embedded type.  We need to disambiguate the method name.\n+  std::string ret = this->pkgpath_symbol_for_package(mpkgpath);\n+  ret.push_back('.');\n+  ret.append(Gogo::unpack_hidden_name(mname));\n+  ret.append(\"..stub\");\n+  return ret;\n }\n \n // Return the names of the hash and equality functions for TYPE.  If\n@@ -106,48 +284,12 @@ Gogo::specific_type_function_names(const Type* type, const Named_type* name,\n \t\t\t\t   std::string *hash_name,\n \t\t\t\t   std::string *equal_name)\n {\n-  std::string base_name;\n-  if (name == NULL)\n-    {\n-      // Mangled names can have '.' if they happen to refer to named\n-      // types in some way.  That's fine if this is simply a named\n-      // type, but otherwise it will confuse the code that builds\n-      // function identifiers.  Remove '.' when necessary.\n-      base_name = type->mangled_name(this);\n-      size_t i;\n-      while ((i = base_name.find('.')) != std::string::npos)\n-\tbase_name[i] = '$';\n-      base_name = this->pack_hidden_name(base_name, false);\n-    }\n-  else\n-    {\n-      // This name is already hidden or not as appropriate.\n-      base_name = name->name();\n-      unsigned int index;\n-      const Named_object* in_function = name->in_function(&index);\n-      if (in_function != NULL)\n-\t{\n-\t  base_name.append(1, '$');\n-\t  const Typed_identifier* rcvr =\n-\t    in_function->func_value()->type()->receiver();\n-\t  if (rcvr != NULL)\n-\t    {\n-\t      Named_type* rcvr_type = rcvr->type()->deref()->named_type();\n-\t      base_name.append(Gogo::unpack_hidden_name(rcvr_type->name()));\n-\t      base_name.append(1, '$');\n-\t    }\n-\t  base_name.append(Gogo::unpack_hidden_name(in_function->name()));\n-\t  if (index > 0)\n-\t    {\n-\t      char buf[30];\n-\t      snprintf(buf, sizeof buf, \"%u\", index);\n-\t      base_name += '$';\n-\t      base_name += buf;\n-\t    }\n-\t}\n-    }\n-  *hash_name = base_name + \"$hash\";\n-  *equal_name = base_name + \"$equal\";\n+  const Type* rtype = type;\n+  if (name != NULL)\n+    rtype = name;\n+  std::string tname = rtype->mangled_name(this);\n+  *hash_name = tname + \"..hash\";\n+  *equal_name = tname + \"..eq\";\n }\n \n // Return the assembler name to use for a global variable.  GO_NAME is\n@@ -158,10 +300,12 @@ Gogo::specific_type_function_names(const Type* type, const Named_type* name,\n std::string\n Gogo::global_var_asm_name(const std::string& go_name, const Package* package)\n {\n-  std::string ret = (package != NULL\n-\t\t     ? package->pkgpath_symbol()\n-\t\t     : this->pkgpath_symbol());\n-  ret.push_back('.');\n+  std::string ret;\n+  if (package == NULL)\n+    ret = this->pkgpath_symbol();\n+  else\n+    ret = package->pkgpath_symbol();\n+  ret.append(1, '.');\n   ret.append(Gogo::unpack_hidden_name(go_name));\n   return go_encode_id(ret);\n }\n@@ -172,9 +316,10 @@ Gogo::global_var_asm_name(const std::string& go_name, const Package* package)\n std::string\n Gogo::erroneous_name()\n {\n+  go_assert(saw_errors());\n   static int erroneous_count;\n   char name[50];\n-  snprintf(name, sizeof name, \"$erroneous%d\", erroneous_count);\n+  snprintf(name, sizeof name, \".erroneous%d\", erroneous_count);\n   ++erroneous_count;\n   return name;\n }\n@@ -184,7 +329,7 @@ Gogo::erroneous_name()\n bool\n Gogo::is_erroneous_name(const std::string& name)\n {\n-  return name.compare(0, 10, \"$erroneous\") == 0;\n+  return name.compare(0, 10, \".erroneous\") == 0;\n }\n \n // Return a name for a thunk object.\n@@ -194,17 +339,25 @@ Gogo::thunk_name()\n {\n   static int thunk_count;\n   char thunk_name[50];\n-  snprintf(thunk_name, sizeof thunk_name, \"$thunk%d\", thunk_count);\n+  snprintf(thunk_name, sizeof thunk_name, \"..thunk%d\", thunk_count);\n   ++thunk_count;\n-  return thunk_name;\n+  std::string ret = this->pkgpath_symbol();\n+  return ret + thunk_name;\n }\n \n // Return whether a function is a thunk.\n \n bool\n Gogo::is_thunk(const Named_object* no)\n {\n-  return no->name().compare(0, 6, \"$thunk\") == 0;\n+  const std::string& name(no->name());\n+  size_t i = name.find(\"..thunk\");\n+  if (i == std::string::npos)\n+    return false;\n+  for (i += 7; i < name.size(); ++i)\n+    if (name[i] < '0' || name[i] > '9')\n+      return false;\n+  return true;\n }\n \n // Return the name to use for an init function.  There can be multiple\n@@ -215,21 +368,50 @@ Gogo::init_function_name()\n {\n   static int init_count;\n   char buf[30];\n-  snprintf(buf, sizeof buf, \".$init%d\", init_count);\n+  snprintf(buf, sizeof buf, \"..init%d\", init_count);\n   ++init_count;\n-  return buf;\n+  std::string ret = this->pkgpath_symbol();\n+  return ret + buf;\n }\n \n // Return the name to use for a nested function.\n \n std::string\n-Gogo::nested_function_name()\n+Gogo::nested_function_name(Named_object* enclosing)\n {\n-  static int nested_count;\n+  std::string prefix;\n+  unsigned int index;\n+  if (enclosing == NULL)\n+    {\n+      // A function literal at top level, as in\n+      // var f = func() {}\n+      static unsigned int toplevel_index;\n+      ++toplevel_index;\n+      index = toplevel_index;\n+      prefix = \".go\";\n+    }\n+  else\n+    {\n+      while (true)\n+\t{\n+\t  Named_object* parent = enclosing->func_value()->enclosing();\n+\t  if (parent == NULL)\n+\t    break;\n+\t  enclosing = parent;\n+\t}\n+      const Typed_identifier* rcvr =\n+\tenclosing->func_value()->type()->receiver();\n+      if (rcvr != NULL)\n+\t{\n+\t  prefix = rcvr->type()->mangled_name(this);\n+\t  prefix.push_back('.');\n+\t}\n+      prefix.append(Gogo::unpack_hidden_name(enclosing->name()));\n+      index = enclosing->func_value()->next_nested_function_index();\n+    }\n   char buf[30];\n-  snprintf(buf, sizeof buf, \".$nested%d\", nested_count);\n-  ++nested_count;\n-  return buf;\n+  snprintf(buf, sizeof buf, \"..func%u\", index);\n+  return prefix + buf;\n }\n \n // Return the name to use for a sink function, a function whose name\n@@ -241,7 +423,7 @@ Gogo::sink_function_name()\n {\n   static int sink_count;\n   char buf[30];\n-  snprintf(buf, sizeof buf, \".$sink%d\", sink_count);\n+  snprintf(buf, sizeof buf, \".sink%d\", sink_count);\n   ++sink_count;\n   return buf;\n }\n@@ -255,7 +437,7 @@ Gogo::redefined_function_name()\n {\n   static int redefinition_count;\n   char buf[30];\n-  snprintf(buf, sizeof buf, \".$redefined%d\", redefinition_count);\n+  snprintf(buf, sizeof buf, \".redefined%d\", redefinition_count);\n   ++redefinition_count;\n   return buf;\n }\n@@ -266,13 +448,17 @@ Gogo::redefined_function_name()\n std::string\n Gogo::recover_thunk_name(const std::string& name, const Type* rtype)\n {\n-  std::string ret(name);\n+  std::string ret;\n   if (rtype != NULL)\n     {\n-      ret.push_back('$');\n-      ret.append(rtype->mangled_name(this));\n+      ret = rtype->mangled_name(this);\n+      ret.append(1, '.');\n     }\n-  ret.append(\"$recover\");\n+  if (Gogo::is_special_name(name))\n+    ret.append(name);\n+  else\n+    ret.append(Gogo::unpack_hidden_name(name));\n+  ret.append(\"..r\");\n   return ret;\n }\n \n@@ -284,7 +470,7 @@ Gogo::recover_thunk_name(const std::string& name, const Type* rtype)\n std::string\n Gogo::gc_root_name()\n {\n-  return \"gc0\";\n+  return \"go..C0\";\n }\n \n // Return the name to use for a composite literal or string\n@@ -296,8 +482,8 @@ Gogo::initializer_name()\n {\n   static unsigned int counter;\n   char buf[30];\n-  snprintf(buf, sizeof buf, \"C%u\", counter);\n   ++counter;\n+  snprintf(buf, sizeof buf, \"go..C%u\", counter);\n   return buf;\n }\n \n@@ -307,7 +493,7 @@ Gogo::initializer_name()\n std::string\n Gogo::map_zero_value_name()\n {\n-  return \"go$zerovalue\";\n+  return \"go..zerovalue\";\n }\n \n // Return the name to use for the import control function.\n@@ -343,11 +529,50 @@ Type::mangled_name(Gogo* gogo) const\n {\n   std::string ret;\n \n-  // The do_mangled_name virtual function should set RET to the\n-  // mangled name.  For a composite type it should append a code for\n-  // the composition and then call do_mangled_name on the components.\n+  // The do_mangled_name virtual function will set RET to the mangled\n+  // name before glue character mapping.\n   this->do_mangled_name(gogo, &ret);\n \n+  // Type descriptor names and interface method table names use a \"..\"\n+  // before the mangled name of a type, so to avoid ambiguity the\n+  // mangled name must not start with 'u' or 'U' or a digit.\n+  go_assert((ret[0] < '0' || ret[0] > '9') && ret[0] != ' ');\n+  if (ret[0] == 'u' || ret[0] == 'U')\n+    ret = \" \" + ret;\n+\n+  // Map glue characters as described above.\n+\n+  // The mapping is only unambiguous if there is no .DIGIT in the\n+  // string, so check that.\n+  for (size_t i = ret.find('.');\n+       i != std::string::npos;\n+       i = ret.find('.', i + 1))\n+    {\n+      if (i + 1 < ret.size())\n+\t{\n+\t  char c = ret[i + 1];\n+\t  go_assert(c < '0' || c > '9');\n+\t}\n+    }\n+\n+  // The order of these characters is the replacement code.\n+  const char * const replace = \" *;,{}[]()\";\n+\n+  const size_t rlen = strlen(replace);\n+  char buf[2];\n+  buf[0] = '.';\n+  for (size_t ri = 0; ri < rlen; ++ri)\n+    {\n+      buf[1] = '0' + ri;\n+      while (true)\n+\t{\n+\t  size_t i = ret.find(replace[ri]);\n+\t  if (i == std::string::npos)\n+\t    break;\n+\t  ret.replace(i, 1, buf, 2);\n+\t}\n+    }\n+\n   return ret;\n }\n \n@@ -357,27 +582,27 @@ Type::mangled_name(Gogo* gogo) const\n void\n Error_type::do_mangled_name(Gogo*, std::string* ret) const\n {\n-  ret->push_back('E');\n+  ret->append(\"{error}\");\n }\n \n void\n Void_type::do_mangled_name(Gogo*, std::string* ret) const\n {\n-  ret->push_back('v');\n+  ret->append(\"{void}\");\n }\n \n void\n Boolean_type::do_mangled_name(Gogo*, std::string* ret) const\n {\n-  ret->push_back('b');\n+  ret->append(\"bool\");\n }\n \n void\n Integer_type::do_mangled_name(Gogo*, std::string* ret) const\n {\n   char buf[100];\n-  snprintf(buf, sizeof buf, \"i%s%s%de\",\n-\t   this->is_abstract_ ? \"a\" : \"\",\n+  snprintf(buf, sizeof buf, \"%s%si%d\",\n+\t   this->is_abstract_ ? \"{abstract}\" : \"\",\n \t   this->is_unsigned_ ? \"u\" : \"\",\n \t   this->bits_);\n   ret->append(buf);\n@@ -387,8 +612,8 @@ void\n Float_type::do_mangled_name(Gogo*, std::string* ret) const\n {\n   char buf[100];\n-  snprintf(buf, sizeof buf, \"f%s%de\",\n-\t   this->is_abstract_ ? \"a\" : \"\",\n+  snprintf(buf, sizeof buf, \"%sfloat%d\",\n+\t   this->is_abstract_ ? \"{abstract}\" : \"\",\n \t   this->bits_);\n   ret->append(buf);\n }\n@@ -397,92 +622,112 @@ void\n Complex_type::do_mangled_name(Gogo*, std::string* ret) const\n {\n   char buf[100];\n-  snprintf(buf, sizeof buf, \"c%s%de\",\n-\t   this->is_abstract_ ? \"a\" : \"\",\n+  snprintf(buf, sizeof buf, \"%sc%d\",\n+\t   this->is_abstract_ ? \"{abstract}\" : \"\",\n \t   this->bits_);\n   ret->append(buf);\n }\n \n void\n String_type::do_mangled_name(Gogo*, std::string* ret) const\n {\n-  ret->push_back('z');\n+  ret->append(\"string\");\n }\n \n void\n Function_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n {\n-  ret->push_back('F');\n+  ret->append(\"func\");\n \n   if (this->receiver_ != NULL)\n     {\n-      ret->push_back('m');\n+      ret->push_back('(');\n       this->append_mangled_name(this->receiver_->type(), gogo, ret);\n+      ret->append(\")\");\n     }\n \n+  ret->push_back('(');\n   const Typed_identifier_list* params = this->parameters();\n   if (params != NULL)\n     {\n-      ret->push_back('p');\n+      bool first = true;\n       for (Typed_identifier_list::const_iterator p = params->begin();\n \t   p != params->end();\n \t   ++p)\n-\tthis->append_mangled_name(p->type(), gogo, ret);\n-      if (this->is_varargs_)\n-\tret->push_back('V');\n-      ret->push_back('e');\n+\t{\n+\t  if (first)\n+\t    first = false;\n+\t  else\n+\t    ret->push_back(',');\n+\t  if (this->is_varargs_ && p + 1 == params->end())\n+\t    {\n+\t      // We can't use \"...\" here because the mangled name\n+\t      // might start with 'u' or 'U', which would be ambiguous\n+\t      // with the encoding of Unicode characters.\n+\t      ret->append(\",,,\");\n+\t    }\n+\t  this->append_mangled_name(p->type(), gogo, ret);\n+\t}\n     }\n+  ret->push_back(')');\n \n+  ret->push_back('(');\n   const Typed_identifier_list* results = this->results();\n   if (results != NULL)\n     {\n-      ret->push_back('r');\n+      bool first = true;\n       for (Typed_identifier_list::const_iterator p = results->begin();\n \t   p != results->end();\n \t   ++p)\n-\tthis->append_mangled_name(p->type(), gogo, ret);\n-      ret->push_back('e');\n+\t{\n+\t  if (first)\n+\t    first = false;\n+\t  else\n+\t    ret->append(\",\");\n+\t  this->append_mangled_name(p->type(), gogo, ret);\n+\t}\n     }\n-\n-  ret->push_back('e');\n+  ret->push_back(')');\n }\n \n void\n Pointer_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n {\n-  ret->push_back('p');\n+  ret->push_back('*');\n   this->append_mangled_name(this->to_type_, gogo, ret);\n }\n \n void\n Nil_type::do_mangled_name(Gogo*, std::string* ret) const\n {\n-  ret->push_back('n');\n+  ret->append(\"{nil}\");\n }\n \n void\n Struct_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n {\n-  ret->push_back('S');\n+  ret->append(\"struct{\");\n+\n+  if (this->is_struct_incomparable_)\n+    ret->append(\"{x}\");\n \n   const Struct_field_list* fields = this->fields_;\n   if (fields != NULL)\n     {\n+      bool first = true;\n       for (Struct_field_list::const_iterator p = fields->begin();\n \t   p != fields->end();\n \t   ++p)\n \t{\n-\t  if (p->is_anonymous())\n-\t    ret->append(\"0_\");\n+\t  if (first)\n+\t    first = false;\n \t  else\n-            {\n-\n-              std::string n(Gogo::mangle_possibly_hidden_name(p->field_name()));\n-\t      char buf[20];\n-\t      snprintf(buf, sizeof buf, \"%u_\",\n-\t\t       static_cast<unsigned int>(n.length()));\n-\t      ret->append(buf);\n-\t      ret->append(n);\n+\t    ret->push_back(';');\n+\n+\t  if (!p->is_anonymous())\n+\t    {\n+\t      ret->append(Gogo::mangle_possibly_hidden_name(p->field_name()));\n+\t      ret->push_back(' ');\n \t    }\n \n \t  // For an anonymous field with an alias type, the field name\n@@ -493,44 +738,26 @@ Struct_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n \t    p->type()->named_type()->append_mangled_type_name(gogo, true, ret);\n \t  else\n \t    this->append_mangled_name(p->type(), gogo, ret);\n+\n \t  if (p->has_tag())\n \t    {\n-\t      const std::string& tag(p->tag());\n-\t      std::string out;\n-\t      for (std::string::const_iterator p = tag.begin();\n-\t\t   p != tag.end();\n-\t\t   ++p)\n-\t\t{\n-\t\t  if (ISALNUM(*p) || *p == '_')\n-\t\t    out.push_back(*p);\n-\t\t  else\n-\t\t    {\n-\t\t      char buf[20];\n-\t\t      snprintf(buf, sizeof buf, \".%x.\",\n-\t\t\t       static_cast<unsigned int>(*p));\n-\t\t      out.append(buf);\n-\t\t    }\n-\t\t}\n-\t      char buf[20];\n-\t      snprintf(buf, sizeof buf, \"T%u_\",\n-\t\t       static_cast<unsigned int>(out.length()));\n-\t      ret->append(buf);\n-\t      ret->append(out);\n+\t      // Use curly braces around a struct tag, since they are\n+\t      // unambiguous here and we have no encoding for\n+\t      // quotation marks.\n+\t      ret->push_back('{');\n+\t      ret->append(go_mangle_struct_tag(p->tag()));\n+\t      ret->push_back('}');\n \t    }\n \t}\n     }\n \n-  if (this->is_struct_incomparable_)\n-    ret->push_back('x');\n-\n-  ret->push_back('e');\n+  ret->push_back('}');\n }\n \n void\n Array_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n {\n-  ret->push_back('A');\n-  this->append_mangled_name(this->element_type_, gogo, ret);\n+  ret->push_back('[');\n   if (this->length_ != NULL)\n     {\n       Numeric_constant nc;\n@@ -550,62 +777,66 @@ Array_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n       free(s);\n       mpz_clear(val);\n       if (this->is_array_incomparable_)\n-\tret->push_back('x');\n+\tret->append(\"x\");\n     }\n-  ret->push_back('e');\n+  ret->push_back(']');\n+  this->append_mangled_name(this->element_type_, gogo, ret);\n }\n \n void\n Map_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n {\n-  ret->push_back('M');\n+  ret->append(\"map[\");\n   this->append_mangled_name(this->key_type_, gogo, ret);\n-  ret->append(\"__\");\n+  ret->push_back(']');\n   this->append_mangled_name(this->val_type_, gogo, ret);\n }\n \n void\n Channel_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n {\n-  ret->push_back('C');\n+  if (!this->may_send_)\n+    ret->append(\"{}\");\n+  ret->append(\"chan\");\n+  if (!this->may_receive_)\n+    ret->append(\"{}\");\n+  ret->push_back(' ');\n   this->append_mangled_name(this->element_type_, gogo, ret);\n-  if (this->may_send_)\n-    ret->push_back('s');\n-  if (this->may_receive_)\n-    ret->push_back('r');\n-  ret->push_back('e');\n }\n \n void\n Interface_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n {\n   go_assert(this->methods_are_finalized_);\n \n-  ret->push_back('I');\n+  ret->append(\"interface{\");\n \n   const Typed_identifier_list* methods = this->all_methods_;\n   if (methods != NULL && !this->seen_)\n     {\n       this->seen_ = true;\n+      bool first = true;\n       for (Typed_identifier_list::const_iterator p = methods->begin();\n \t   p != methods->end();\n \t   ++p)\n \t{\n+\t  if (first)\n+\t    first = false;\n+\t  else\n+\t    ret->push_back(';');\n+\n \t  if (!p->name().empty())\n \t    {\n-\t      std::string n(Gogo::mangle_possibly_hidden_name(p->name()));\n-\t      char buf[20];\n-\t      snprintf(buf, sizeof buf, \"%u_\",\n-\t\t       static_cast<unsigned int>(n.length()));\n-\t      ret->append(buf);\n-\t      ret->append(n);\n+\t      ret->append(Gogo::mangle_possibly_hidden_name(p->name()));\n+\t      ret->push_back(' ');\n \t    }\n+\n \t  this->append_mangled_name(p->type(), gogo, ret);\n \t}\n       this->seen_ = false;\n     }\n \n-  ret->push_back('e');\n+  ret->push_back('}');\n }\n \n void\n@@ -622,18 +853,12 @@ Forward_declaration_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n   else\n     {\n       const Named_object* no = this->named_object();\n-      std::string name;\n       if (no->package() == NULL)\n-\tname = gogo->pkgpath_symbol();\n+\tret->append(gogo->pkgpath_symbol());\n       else\n-\tname = no->package()->pkgpath_symbol();\n-      name += '.';\n-      name += Gogo::unpack_hidden_name(no->name());\n-      char buf[20];\n-      snprintf(buf, sizeof buf, \"N%u_\",\n-\t       static_cast<unsigned int>(name.length()));\n-      ret->append(buf);\n-      ret->append(name);\n+\tret->append(no->package()->pkgpath_symbol());\n+      ret->push_back('.');\n+      ret->append(Gogo::unpack_hidden_name(no->name()));\n     }\n }\n \n@@ -662,37 +887,44 @@ Named_type::append_mangled_type_name(Gogo* gogo, bool use_alias,\n     go_assert(this->in_function_ == NULL);\n   else\n     {\n-      const std::string& pkgpath(no->package() == NULL\n-\t\t\t\t ? gogo->pkgpath_symbol()\n-\t\t\t\t : no->package()->pkgpath_symbol());\n-      name = pkgpath;\n-      name.append(1, '.');\n       if (this->in_function_ != NULL)\n \t{\n \t  const Typed_identifier* rcvr =\n \t    this->in_function_->func_value()->type()->receiver();\n \t  if (rcvr != NULL)\n \t    {\n-\t      Named_type* rcvr_type = rcvr->type()->deref()->named_type();\n-\t      name.append(Gogo::unpack_hidden_name(rcvr_type->name()));\n-\t      name.append(1, '.');\n-\t    }\n-\t  name.append(Gogo::unpack_hidden_name(this->in_function_->name()));\n-\t  name.append(1, '$');\n-\t  if (this->in_function_index_ > 0)\n-\t    {\n-\t      char buf[30];\n-\t      snprintf(buf, sizeof buf, \"%u\", this->in_function_index_);\n-\t      name.append(buf);\n-\t      name.append(1, '$');\n+\t      std::string m = rcvr->type()->mangled_name(gogo);\n+\t      // Turn a leading \".1\" back into \"*\" since we are going\n+\t      // to type-mangle this name again.\n+\t      if (m.compare(0, 2, \".1\") == 0)\n+\t\tm = \"*\" + m.substr(2);\n+\t      ret->append(m);\n \t    }\n+\t  else if (this->in_function_->package() == NULL)\n+\t    ret->append(gogo->pkgpath_symbol());\n+\t  else\n+\t    ret->append(this->in_function_->package()->pkgpath_symbol());\n+\t  ret->push_back('.');\n+\t  ret->append(Gogo::unpack_hidden_name(this->in_function_->name()));\n+\t}\n+      else\n+\t{\n+\t  if (no->package() == NULL)\n+\t    ret->append(gogo->pkgpath_symbol());\n+\t  else\n+\t    ret->append(no->package()->pkgpath_symbol());\n \t}\n+      ret->push_back('.');\n+    }\n+\n+  ret->append(Gogo::unpack_hidden_name(no->name()));\n+\n+  if (this->in_function_ != NULL && this->in_function_index_ > 0)\n+    {\n+      char buf[30];\n+      snprintf(buf, sizeof buf, \"..i%u\", this->in_function_index_);\n+      ret->append(buf);\n     }\n-  name.append(Gogo::unpack_hidden_name(no->name()));\n-  char buf[20];\n-  snprintf(buf, sizeof buf, \"N%u_\", static_cast<unsigned int>(name.length()));\n-  ret->append(buf);\n-  ret->append(name);\n }\n \n // Return the name for the type descriptor symbol for TYPE.  This can\n@@ -704,50 +936,53 @@ Gogo::type_descriptor_name(Type* type, Named_type* nt)\n {\n   // The type descriptor symbol for the unsafe.Pointer type is defined\n   // in libgo/runtime/go-unsafe-pointer.c, so just use a reference to\n-  // that symbol.\n+  // that symbol for all unsafe pointer types.\n   if (type->is_unsafe_pointer_type())\n-    return \"__go_tdn_unsafe.Pointer\";\n+    return \"unsafe.Pointer..d\";\n \n   if (nt == NULL)\n-    return \"__go_td_\" + type->mangled_name(this);\n+    return \"type..\" + type->mangled_name(this);\n \n+  std::string ret;\n   Named_object* no = nt->named_object();\n   unsigned int index;\n   const Named_object* in_function = nt->in_function(&index);\n-  std::string ret = \"__go_tdn_\";\n   if (nt->is_builtin())\n     go_assert(in_function == NULL);\n   else\n     {\n-      const std::string& pkgpath(no->package() == NULL\n-\t\t\t\t ? this->pkgpath_symbol()\n-\t\t\t\t : no->package()->pkgpath_symbol());\n-      ret.append(pkgpath);\n-      ret.append(1, '.');\n       if (in_function != NULL)\n \t{\n \t  const Typed_identifier* rcvr =\n \t    in_function->func_value()->type()->receiver();\n \t  if (rcvr != NULL)\n-\t    {\n-\t      Named_type* rcvr_type = rcvr->type()->deref()->named_type();\n-\t      ret.append(Gogo::unpack_hidden_name(rcvr_type->name()));\n-\t      ret.append(1, '.');\n-\t    }\n+\t    ret.append(rcvr->type()->mangled_name(this));\n+\t  else if (in_function->package() == NULL)\n+\t    ret.append(this->pkgpath_symbol());\n+\t  else\n+\t    ret.append(in_function->package()->pkgpath_symbol());\n+\t  ret.push_back('.');\n \t  ret.append(Gogo::unpack_hidden_name(in_function->name()));\n-\t  ret.append(1, '.');\n-\t  if (index > 0)\n-\t    {\n-\t      char buf[30];\n-\t      snprintf(buf, sizeof buf, \"%u\", index);\n-\t      ret.append(buf);\n-\t      ret.append(1, '.');\n-\t    }\n+\t  ret.push_back('.');\n \t}\n+\n+      if (no->package() == NULL)\n+\tret.append(this->pkgpath_symbol());\n+      else\n+\tret.append(no->package()->pkgpath_symbol());\n+      ret.push_back('.');\n+    }\n+\n+  ret.append(Gogo::mangle_possibly_hidden_name(no->name()));\n+\n+  if (in_function != NULL && index > 0)\n+    {\n+      char buf[30];\n+      snprintf(buf, sizeof buf, \"..i%u\", index);\n+      ret.append(buf);\n     }\n \n-  std::string mname(Gogo::mangle_possibly_hidden_name(no->name()));\n-  ret.append(mname);\n+  ret.append(\"..d\");\n \n   return ret;\n }\n@@ -761,11 +996,11 @@ Gogo::type_descriptor_name(Type* type, Named_type* nt)\n std::string\n Gogo::gc_symbol_name(Type* type)\n {\n-  return this->type_descriptor_name(type, type->named_type()) + \"$gc\";\n+  return this->type_descriptor_name(type, type->named_type()) + \"..g\";\n }\n \n // Return the name for a ptrmask variable.  PTRMASK_SYM_NAME is a\n-// base64 string encoding the ptrmask (as returned by Ptrmask::symname\n+// base32 string encoding the ptrmask (as returned by Ptrmask::symname\n // in types.cc).  This name is used to intialize the gcdata field of a\n // type descriptor.  These names are globally visible.  (Note that\n // some type descriptors will initialize the gcdata field with a name\n@@ -774,7 +1009,7 @@ Gogo::gc_symbol_name(Type* type)\n std::string\n Gogo::ptrmask_symbol_name(const std::string& ptrmask_sym_name)\n {\n-  return \"runtime.gcbits.\" + ptrmask_sym_name;\n+  return \"gcbits..\" + ptrmask_sym_name;\n }\n \n // Return the name to use for an interface method table used for the\n@@ -786,8 +1021,25 @@ std::string\n Gogo::interface_method_table_name(Interface_type* itype, Type* type,\n \t\t\t\t  bool is_pointer)\n {\n-  return ((is_pointer ? \"__go_pimt__\" : \"__go_imt_\")\n+  return ((is_pointer ? \"pimt..\" : \"imt..\")\n \t  + itype->mangled_name(this)\n-\t  + \"__\"\n+\t  + \"..\"\n \t  + type->mangled_name(this));\n }\n+\n+// Return whether NAME is a special name that can not be passed to\n+// unpack_hidden_name.  This is needed because various special names\n+// use \"..SUFFIX\", but unpack_hidden_name just looks for '.'.\n+\n+bool\n+Gogo::is_special_name(const std::string& name)\n+{\n+  return (name.find(\"..hash\") != std::string::npos\n+\t  || name.find(\"..eq\") != std::string::npos\n+\t  || name.find(\"..stub\") != std::string::npos\n+\t  || name.find(\"..func\") != std::string::npos\n+\t  || name.find(\"..r\") != std::string::npos\n+\t  || name.find(\"..init\") != std::string::npos\n+\t  || name.find(\"..thunk\") != std::string::npos\n+\t  || name.find(\"..import\") != std::string::npos);\n+}"}, {"sha": "094966592f6159b88fb8ae7fb6717001a5ed8ab3", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=4880b994d63ffb014a5a547239e9cd8402bb014a", "patch": "@@ -2120,7 +2120,7 @@ Thunk_statement::simplify_statement(Gogo* gogo, Named_object* function,\n       fn = Expression::make_temporary_reference(fn_temp, location);\n     }\n \n-  std::string thunk_name = Gogo::thunk_name();\n+  std::string thunk_name = gogo->thunk_name();\n \n   // Build the thunk.\n   this->build_thunk(gogo, thunk_name);"}, {"sha": "28eef8e9ed9d0e84565d7645f40466bd08e9d70f", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=4880b994d63ffb014a5a547239e9cd8402bb014a", "patch": "@@ -2654,14 +2654,14 @@ Ptrmask::set_from(Gogo* gogo, Type* type, int64_t ptrsize, int64_t offset)\n // Return a symbol name for this ptrmask.  This is used to coalesce\n // identical ptrmasks, which are common.  The symbol name must use\n // only characters that are valid in symbols.  It's nice if it's\n-// short.  We convert it to a base64 string.\n+// short.  We convert it to a string that uses only 32 characters,\n+// avoiding digits and u and U.\n \n std::string\n Ptrmask::symname() const\n {\n-  const char chars[65] =\n-    \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_.\";\n-  go_assert(chars[64] == '\\0');\n+  const char chars[33] = \"abcdefghijklmnopqrstvwxyzABCDEFG\";\n+  go_assert(chars[32] == '\\0');\n   std::string ret;\n   unsigned int b = 0;\n   int remaining = 0;\n@@ -2671,18 +2671,18 @@ Ptrmask::symname() const\n     {\n       b |= *p << remaining;\n       remaining += 8;\n-      while (remaining >= 6)\n+      while (remaining >= 5)\n \t{\n-\t  ret += chars[b & 0x3f];\n-\t  b >>= 6;\n-\t  remaining -= 6;\n+\t  ret += chars[b & 0x1f];\n+\t  b >>= 5;\n+\t  remaining -= 5;\n \t}\n     }\n   while (remaining > 0)\n     {\n-      ret += chars[b & 0x3f];\n-      b >>= 6;\n-      remaining -= 6;\n+      ret += chars[b & 0x1f];\n+      b >>= 5;\n+      remaining -= 5;\n     }\n   return ret;\n }\n@@ -4447,7 +4447,11 @@ Function_type::is_identical(const Function_type* t, bool ignore_receiver,\n     }\n \n   const Typed_identifier_list* parms1 = this->parameters();\n+  if (parms1 != NULL && parms1->empty())\n+    parms1 = NULL;\n   const Typed_identifier_list* parms2 = t->parameters();\n+  if (parms2 != NULL && parms2->empty())\n+    parms2 = NULL;\n   if ((parms1 != NULL) != (parms2 != NULL))\n     {\n       if (reason != NULL)\n@@ -4492,7 +4496,11 @@ Function_type::is_identical(const Function_type* t, bool ignore_receiver,\n     }\n \n   const Typed_identifier_list* results1 = this->results();\n+  if (results1 != NULL && results1->empty())\n+    results1 = NULL;\n   const Typed_identifier_list* results2 = t->results();\n+  if (results2 != NULL && results2->empty())\n+    results2 = NULL;\n   if ((results1 != NULL) != (results2 != NULL))\n     {\n       if (reason != NULL)\n@@ -11144,7 +11152,7 @@ Type::build_stub_methods(Gogo* gogo, const Type* type, const Methods* methods,\n \tpackage = NULL;\n       else\n \tpackage = type->named_type()->named_object()->package();\n-      std::string stub_name = gogo->stub_method_name(name);\n+      std::string stub_name = gogo->stub_method_name(package, name);\n       Named_object* stub;\n       if (package != NULL)\n \tstub = Named_object::make_function_declaration(stub_name, package,"}, {"sha": "bdc01f7cfc1e0c3f3169fc164cb09fd18d3e1a5e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4880b994d63ffb014a5a547239e9cd8402bb014a", "patch": "@@ -1,3 +1,7 @@\n+2018-01-24  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* go.go-torture/execute/names-1.go: New test.\n+\n 2018-01-19  Jeff Law  <law@redhat.com>\n \n \tPR target/83994"}, {"sha": "bac91945bc76c20ebf00b8f1e76ec59f17b0854b", "filename": "gcc/testsuite/go.go-torture/execute/names-1.go", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fnames-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880b994d63ffb014a5a547239e9cd8402bb014a/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fnames-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fnames-1.go?ref=4880b994d63ffb014a5a547239e9cd8402bb014a", "patch": "@@ -0,0 +1,195 @@\n+// names-1 is a change detector for Go symbol names.  We don't want\n+// the name mangling to change silently.\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"debug/elf\"\n+\t\"debug/macho\"\n+\t\"debug/pe\"\n+\t\"debug/xcoff\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"strings\"\n+)\n+\n+type Type int\n+type Alias = int\n+\n+//go:noinline\n+func Function1(out *bytes.Buffer) int {\n+\tvar f2 func(int) int\n+\tf1 := func(i int) int {\n+\t\tif i == 0 {\n+\t\t\treturn 0\n+\t\t}\n+\t\ttype NestedType struct { a int }\n+\t\tt := NestedType{f2(i-1)}\n+\t\tfmt.Fprint(out, t)\n+\t\treturn t.a\n+\t}\n+\tf2 = func(i int) int {\n+\t\tif i == 0 {\n+\t\t\treturn 0\n+\t\t}\n+\t\ttype NestedType struct { a int }\n+\t\tt := NestedType{f1(i-1)}\n+\t\tfmt.Fprint(out, t)\n+\t\treturn t.a\n+\t}\n+\treturn f1(10) + f2(10)\n+}\n+\n+//go:noinline\n+func Function2(out *bytes.Buffer) {\n+\t{\n+\t\ttype T struct { b int }\n+\t\tfmt.Fprint(out, T{1})\n+\t}\n+\t{\n+\t\ttype T struct { b int }\n+\t\tfmt.Fprint(out, T{2})\n+\t}\n+}\n+\n+func (t Type) M(bool, int8, float32, complex64, string, func(), func(int16) (float64, complex128), *byte, struct { f int \"tag #$%^&{}: \u4e16\u754c\" }, []int32, [24]int64, map[uint8]uint16, chan uint32, <-chan uint64, chan <- uintptr, Type, Alias) {\n+}\n+\n+//go:noinline\n+func Function3(out *bytes.Buffer) {\n+\tfmt.Fprintf(out, \"%T\", Type(0))\n+}\n+\n+func main() {\n+\tvar b bytes.Buffer\n+\tFunction1(&b)\n+\tFunction2(&b)\n+\tFunction3(&b)\n+\t_ = len(b.String())\n+\n+\tfor _, n := range []string{\"/proc/self/exe\", os.Args[0]} {\n+\t\tif f, err := os.Open(n); err == nil {\n+\t\t\tcheckFile(f)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tfmt.Println(\"checksyms: could not find executable\")\n+\tfmt.Println(\"UNSUPPORTED: checksyms\")\n+}\n+\n+func checkFile(f *os.File) {\n+\tvar syms []string\n+\tif ef, err := elf.NewFile(f); err == nil {\n+\t\tesyms, err := ef.Symbols()\n+\t\tif err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t\tfor _, esym := range esyms {\n+\t\t\tsyms = append(syms, esym.Name)\n+\t\t}\n+\t} else if mf, err := macho.NewFile(f); err == nil {\n+\t\tfor _, msym := range mf.Symtab.Syms {\n+\t\t\tsyms = append(syms, msym.Name)\n+\t\t}\n+\t} else if pf, err := pe.NewFile(f); err == nil {\n+\t\tfor _, psym := range pf.Symbols {\n+\t\t\tsyms = append(syms, psym.Name)\n+\t\t}\n+\t} else if xf, err := xcoff.NewFile(f); err == nil {\n+\t\tfor _, xsym := range xf.Symbols {\n+\t\t\tsyms = append(syms, xsym.Name)\n+\t\t}\n+\t} else {\n+\t\tfmt.Println(\"checksyms: could not parse executable\")\n+\t\tfmt.Println(\"UNSUPPORTED: checksyms\")\n+\t\treturn\n+\t}\n+\tcheckSyms(syms)\n+}\n+\n+var want = []string{\n+\t\"main.Function1\",\n+\t\"main.Function1..f\",\n+\t\"main.Function1..func1\",\n+\t\"main.Function1..func1.main.NestedType..d\",\n+\t\"main.Function1..func2\",\n+\t\"main.Function1..func2.main.NestedType..d\",\n+\t\"main.Function2\",\n+\t\"main.Function2..f\",\n+\t\"main.Function2.main.T..d\",\n+\t\"main.Function2.main.T..i1..d\",\n+\t\"main.Function3\",\n+\t\"main.Function3..f\",\n+\t\"main.Type..d\",\n+\t\"main.Type.M\",\n+\t\"main.main\",\n+\t\"main.want\",\n+\t\"type...1.1main.Type\",  // Why is this here?\n+\t\"type...1main.Function1..func1.NestedType\",\n+\t\"type...1main.Function1..func2.NestedType\",\n+\t\"type...1main.Function2.T\",\n+\t\"type...1main.Function2.T..i1\",\n+\t\"type...1main.Type\",\n+\t\"type..func.8.1main.Type.3bool.3int8.3float32.3complex64.3string.3func.8.9.8.9.3func.8int16.9.8float64.3complex128.9.3.1uint8.3struct.4.main.f.0int.4tag.x20.x23.x24.x25.x5e.x26.x7b.x7d.x3a.x20..u4e16..u754c.5.5.3.6.7int32.3.624.7int64.3map.6uint8.7uint16.3chan.0uint32.3.4.5chan.0uint64.3chan.4.5.0uintptr.3main.Type.3int.9.8.9\",\n+\t\"type..func.8bool.3int8.3float32.3complex64.3string.3func.8.9.8.9.3func.8int16.9.8float64.3complex128.9.3.1uint8.3struct.4.main.f.0int.4tag.x20.x23.x24.x25.x5e.x26.x7b.x7d.x3a.x20..u4e16..u754c.5.5.3.6.7int32.3.624.7int64.3map.6uint8.7uint16.3chan.0uint32.3.4.5chan.0uint64.3chan.4.5.0uintptr.3main.Type.3int.9.8.9\",\n+\t\"type..func.8main.Type.3bool.3int8.3float32.3complex64.3string.3func.8.9.8.9.3func.8int16.9.8float64.3complex128.9.3.1uint8.3struct.4.main.f.0int.4tag.x20.x23.x24.x25.x5e.x26.x7b.x7d.x3a.x20..u4e16..u754c.5.5.3.6.7int32.3.624.7int64.3map.6uint8.7uint16.3chan.0uint32.3.4.5chan.0uint64.3chan.4.5.0uintptr.3main.Type.3int.9.8.9\",\n+\t\"type..struct.4.main.f.0int.4tag.x20.x23.x24.x25.x5e.x26.x7b.x7d.x3a.x20..u4e16..u754c.5.5\",\n+}\n+\n+func checkSyms(syms []string) {\n+\tm := make(map[string]bool)\n+\tfor _, sym := range syms {\n+\t\tif strings.Contains(sym, \".\") {\n+\t\t\tm[sym] = true\n+\t\t}\n+\t}\n+\n+\tok := true\n+\tfor _, w := range want {\n+\t\tif m[w] {\n+\t\t\tdelete(m, w)\n+\t\t} else {\n+\t\t\tfmt.Printf(\"checksyms: missing expected symbol %q\\n\", w)\n+\t\t\tok = false\n+\t\t}\n+\t}\n+\n+\tfor sym := range m {\n+\t\tif !strings.Contains(sym, \"main\") {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Skip some symbols we may see but know are unimportant.\n+\t\tif sym == \"go-main.c\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif strings.HasPrefix(sym, \"runtime.\") {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// We can see a lot of spurious .eq and .hash\n+\t\t// functions for types defined in other packages.\n+\t\t// This is a bug but skip them for now.\n+\t\tif strings.Contains(sym, \"..eq\") || strings.Contains(sym, \"..hash\") {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Skip closure types by skipping incomparable structs.\n+\t\t// This may be a bug, not sure.\n+\t\tif strings.Contains(sym, \".4x.5\") {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// These functions may be inlined.\n+\t\tif sym == \"main.checkFile\" || sym == \"main.checkSyms\" {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tfmt.Printf(\"checksyms: found unexpected symbol %q\\n\", sym)\n+\t\tok = false\n+\t}\n+\n+\tif !ok  {\n+\t\tfmt.Println(\"FAIL: checksyms\")\n+\t}\n+}"}, {"sha": "06200c7303b99310ac1685535c7ff9c90c4ebabb", "filename": "libgo/go/runtime/crash_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880b994d63ffb014a5a547239e9cd8402bb014a/libgo%2Fgo%2Fruntime%2Fcrash_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880b994d63ffb014a5a547239e9cd8402bb014a/libgo%2Fgo%2Fruntime%2Fcrash_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcrash_test.go?ref=4880b994d63ffb014a5a547239e9cd8402bb014a", "patch": "@@ -425,7 +425,7 @@ func TestPanicTraceback(t *testing.T) {\n \t// Check functions in the traceback.\n \tfns := []string{\"main.pt1.func1\", \"panic\", \"main.pt2.func1\", \"panic\", \"main.pt2\", \"main.pt1\"}\n \tif runtime.Compiler == \"gccgo\" {\n-\t\tfns = []string{\"main.$nested\", \"panic\", \"main.$nested\", \"panic\", \"main.pt2\", \"main.pt1\"}\n+\t\tfns = []string{\"main.pt1..func1\", \"panic\", \"main.pt2..func1\", \"panic\", \"main.pt2\", \"main.pt1\"}\n \t}\n \tfor _, fn := range fns {\n \t\tvar re *regexp.Regexp\n@@ -570,7 +570,7 @@ func TestPanicInlined(t *testing.T) {\n \t\tbuf = buf[:n]\n \t\twant := []byte(\"(*point).negate(\")\n \t\tif runtime.Compiler == \"gccgo\" {\n-\t\t\twant = []byte(\"negate.pN18_runtime_test.point\")\n+\t\t\twant = []byte(\"point.negate\")\n \t\t}\n \t\tif !bytes.Contains(buf, want) {\n \t\t\tt.Logf(\"%s\", buf)"}, {"sha": "24d78eca62d33f62efee4f8f1c3f7b1c591ba683", "filename": "libgo/go/runtime/panic.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880b994d63ffb014a5a547239e9cd8402bb014a/libgo%2Fgo%2Fruntime%2Fpanic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880b994d63ffb014a5a547239e9cd8402bb014a/libgo%2Fgo%2Fruntime%2Fpanic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpanic.go?ref=4880b994d63ffb014a5a547239e9cd8402bb014a", "patch": "@@ -656,7 +656,7 @@ func canrecover(retaddr uintptr) bool {\n \t\t}\n \n \t\t// Ignore other functions in the reflect package.\n-\t\tif hasprefix(name, \"reflect.\") {\n+\t\tif hasprefix(name, \"reflect.\") || hasprefix(name, \".1reflect.\") {\n \t\t\tcontinue\n \t\t}\n "}, {"sha": "ae6ec6d0cfc8169cb383a41e5dd643b7ce56ef48", "filename": "libgo/go/runtime/pprof/pprof_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880b994d63ffb014a5a547239e9cd8402bb014a/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880b994d63ffb014a5a547239e9cd8402bb014a/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go?ref=4880b994d63ffb014a5a547239e9cd8402bb014a", "patch": "@@ -730,7 +730,7 @@ func TestMutexProfile(t *testing.T) {\n \t\tstks := stacks(p)\n \t\tfor _, want := range [][]string{\n \t\t\t// {\"sync.(*Mutex).Unlock\", \"pprof.blockMutex.func1\"},\n-\t\t\t{\"sync.Unlock.pN10_sync.Mutex\", \"pprof.$nested17\"},\n+\t\t\t{\".1sync.Mutex.Unlock\", \"pprof.blockMutex..func1\"},\n \t\t} {\n \t\t\tif !containsStack(stks, want) {\n \t\t\t\tt.Errorf(\"No matching stack entry for %+v\", want)"}, {"sha": "c0c5cca39af5d8ed355444183fbbd0a4672b229a", "filename": "libgo/go/syscall/wait.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880b994d63ffb014a5a547239e9cd8402bb014a/libgo%2Fgo%2Fsyscall%2Fwait.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880b994d63ffb014a5a547239e9cd8402bb014a/libgo%2Fgo%2Fsyscall%2Fwait.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fwait.c?ref=4880b994d63ffb014a5a547239e9cd8402bb014a", "patch": "@@ -17,7 +17,7 @@\n #endif\n \n extern _Bool Exited (uint32_t *w)\n-  __asm__ (GOSYM_PREFIX \"syscall.Exited.N18_syscall.WaitStatus\");\n+  __asm__ (GOSYM_PREFIX \"syscall.WaitStatus.Exited\");\n \n _Bool\n Exited (uint32_t *w)\n@@ -26,7 +26,7 @@ Exited (uint32_t *w)\n }\n \n extern _Bool Signaled (uint32_t *w)\n-  __asm__ (GOSYM_PREFIX \"syscall.Signaled.N18_syscall.WaitStatus\");\n+  __asm__ (GOSYM_PREFIX \"syscall.WaitStatus.Signaled\");\n \n _Bool\n Signaled (uint32_t *w)\n@@ -35,7 +35,7 @@ Signaled (uint32_t *w)\n }\n \n extern _Bool Stopped (uint32_t *w)\n-  __asm__ (GOSYM_PREFIX \"syscall.Stopped.N18_syscall.WaitStatus\");\n+  __asm__ (GOSYM_PREFIX \"syscall.WaitStatus.Stopped\");\n \n _Bool\n Stopped (uint32_t *w)\n@@ -44,7 +44,7 @@ Stopped (uint32_t *w)\n }\n \n extern _Bool Continued (uint32_t *w)\n-  __asm__ (GOSYM_PREFIX \"syscall.Continued.N18_syscall.WaitStatus\");\n+  __asm__ (GOSYM_PREFIX \"syscall.WaitStatus.Continued\");\n \n _Bool\n Continued (uint32_t *w)\n@@ -53,7 +53,7 @@ Continued (uint32_t *w)\n }\n \n extern _Bool CoreDump (uint32_t *w)\n-  __asm__ (GOSYM_PREFIX \"syscall.CoreDump.N18_syscall.WaitStatus\");\n+  __asm__ (GOSYM_PREFIX \"syscall.WaitStatus.CoreDump\");\n \n _Bool\n CoreDump (uint32_t *w)\n@@ -62,7 +62,7 @@ CoreDump (uint32_t *w)\n }\n \n extern int ExitStatus (uint32_t *w)\n-  __asm__ (GOSYM_PREFIX \"syscall.ExitStatus.N18_syscall.WaitStatus\");\n+  __asm__ (GOSYM_PREFIX \"syscall.WaitStatus.ExitStatus\");\n \n int\n ExitStatus (uint32_t *w)\n@@ -73,7 +73,7 @@ ExitStatus (uint32_t *w)\n }\n \n extern int Signal (uint32_t *w)\n-  __asm__ (GOSYM_PREFIX \"syscall.Signal.N18_syscall.WaitStatus\");\n+  __asm__ (GOSYM_PREFIX \"syscall.WaitStatus.Signal\");\n \n int\n Signal (uint32_t *w)\n@@ -84,7 +84,7 @@ Signal (uint32_t *w)\n }\n \n extern int StopSignal (uint32_t *w)\n-  __asm__ (GOSYM_PREFIX \"syscall.StopSignal.N18_syscall.WaitStatus\");\n+  __asm__ (GOSYM_PREFIX \"syscall.WaitStatus.StopSignal\");\n \n int\n StopSignal (uint32_t *w)\n@@ -95,7 +95,7 @@ StopSignal (uint32_t *w)\n }\n \n extern int TrapCause (uint32_t *w)\n-  __asm__ (GOSYM_PREFIX \"syscall.TrapCause.N18_syscall.WaitStatus\");\n+  __asm__ (GOSYM_PREFIX \"syscall.WaitStatus.TrapCause\");\n \n int\n TrapCause (uint32_t *w __attribute__ ((unused)))"}, {"sha": "2eaac68277979f6a161f554f3434cc9df4daf1b1", "filename": "libgo/runtime/go-callers.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880b994d63ffb014a5a547239e9cd8402bb014a/libgo%2Fruntime%2Fgo-callers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880b994d63ffb014a5a547239e9cd8402bb014a/libgo%2Fruntime%2Fgo-callers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-callers.c?ref=4880b994d63ffb014a5a547239e9cd8402bb014a", "patch": "@@ -68,13 +68,14 @@ callback (void *data, uintptr_t pc, const char *filename, int lineno,\n     {\n       const char *p;\n \n-      p = __builtin_strchr (function, '.');\n-      if (p != NULL && __builtin_strncmp (p + 1, \"$thunk\", 6) == 0)\n+      p = function + __builtin_strlen (function);\n+      while (p > function && p[-1] >= '0' && p[-1] <= '9')\n+\t--p;\n+      if (p - function > 7 && __builtin_strncmp (p - 7, \"..thunk\", 7) == 0)\n \treturn 0;\n-      p = __builtin_strrchr (function, '$');\n-      if (p != NULL && __builtin_strcmp(p, \"$recover\") == 0)\n+      if (p - function > 3 && __builtin_strcmp (p - 3, \"..r\") == 0)\n \treturn 0;\n-      if (p != NULL && __builtin_strncmp(p, \"$stub\", 5) == 0)\n+      if (p - function > 6 && __builtin_strcmp (p - 6, \"..stub\") == 0)\n \treturn 0;\n     }\n "}, {"sha": "5afd0112fe2a2c51ee665a7b31c101ca19705bf6", "filename": "libgo/runtime/go-unsafe-pointer.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880b994d63ffb014a5a547239e9cd8402bb014a/libgo%2Fruntime%2Fgo-unsafe-pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880b994d63ffb014a5a547239e9cd8402bb014a/libgo%2Fruntime%2Fgo-unsafe-pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-unsafe-pointer.c?ref=4880b994d63ffb014a5a547239e9cd8402bb014a", "patch": "@@ -15,10 +15,10 @@\n    descriptor.  */\n \n extern const struct __go_type_descriptor unsafe_Pointer\n-  __asm__ (GOSYM_PREFIX \"__go_tdn_unsafe.Pointer\");\n+  __asm__ (GOSYM_PREFIX \"unsafe.Pointer..d\");\n \n extern const byte unsafe_Pointer_gc[]\n-  __asm__ (GOSYM_PREFIX \"__go_tdn_unsafe.Pointer$gc\");\n+  __asm__ (GOSYM_PREFIX \"unsafe.Pointer..g\");\n \n /* Used to determine the field alignment.  */\n struct field_align\n@@ -38,9 +38,9 @@ static const String reflection_string =\n const byte unsafe_Pointer_gc[] = { 1 };\n \n extern const FuncVal runtime_pointerhash_descriptor\n-  __asm__ (GOSYM_PREFIX \"runtime.pointerhash$descriptor\");\n+  __asm__ (GOSYM_PREFIX \"runtime.pointerhash..f\");\n extern const FuncVal runtime_pointerequal_descriptor\n-  __asm__ (GOSYM_PREFIX \"runtime.pointerequal$descriptor\");\n+  __asm__ (GOSYM_PREFIX \"runtime.pointerequal..f\");\n \n const struct __go_type_descriptor unsafe_Pointer =\n {\n@@ -75,7 +75,7 @@ const struct __go_type_descriptor unsafe_Pointer =\n    it to be defined elsewhere.  */\n \n extern const struct __go_ptr_type pointer_unsafe_Pointer\n-  __asm__ (GOSYM_PREFIX \"__go_td_pN14_unsafe.Pointer\");\n+  __asm__ (GOSYM_PREFIX \"type...1unsafe.Pointer\");\n \n /* The reflection string.  */\n #define PREFLECTION \"*unsafe.Pointer\"\n@@ -86,7 +86,7 @@ static const String preflection_string =\n };\n \n extern const byte pointer_unsafe_Pointer_gc[]\n-  __asm__ (GOSYM_PREFIX \"__go_td_pN14_unsafe.Pointer$gc\");\n+  __asm__ (GOSYM_PREFIX \"type...1unsafe.Pointer..g\");\n \n const byte pointer_unsafe_Pointer_gc[] = { 1 };\n "}]}