{"sha": "72eb311da1b77bfbfefcd830a49a0368b2b5919d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJlYjMxMWRhMWI3N2JmYmZlZmNkODMwYTQ5YTAzNjhiMmI1OTE5ZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-11-12T14:29:14Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-11-12T14:29:14Z"}, "message": "[multiple changes]\n\n2014-11-12  Richard Biener  <rguenther@suse.de>\n\n\tMerge from match-and-simplify branch\n\t2014-11-04  Prathamesh Kulkarni  <bilbotheelffriend@gmail.com>\n\n\t* genmatch.c (user_id): Add new member is_oper_list.\n\t(user_id::user_id): Add new default argument.\n\t(parser::parse_operator_list): New function.\n\t(parser::parse_for): Allow operator-list.\n\t(parser::parse_pattern): Call parser::parse_operator_list.\n\t(parser::parse_operation): Reject operator-list.\n\t* match-builtin.pd: Define operator lists POWs, CBRTs and SQRTs.\n\n\t2014-10-31  Prathamesh Kulkarni  <bilbotheelffriend@gmail.com>\n\n\t* genmatch.c (parser::parse_c_expr): Mark user-defined ops as used.\n\n\t2014-10-30  Prathamesh Kulkarni  <bilbotheelffriend@gmail.com>\n\n\t* genmatch.c (parser::parse_op): Check if predicate is used in\n\tresult operand.\n\n\t2014-10-29  Prathamesh Kulkarni  <bilbotheelffriend@gmail.com>\n\n\t* genmatch.c (parser::parse_for): Make sure to have a valid\n\ttoken to report errors at.\n\n\t2014-10-28  Prathamesh Kulkarni  <bilbotheelffriend@gmail.com>\n\n\t* genmatch.c (parser): Add new member parsing_match_operand.\n\t(parser::parse_operation): Check for conditional convert in result\n\toperand.\n\t(parser::parse_expr): Check for commutative operator in result operand.\n\tCheck for :type in match operand.\n\t(parser::parse_simplify): Set/unset parsing_match_operand.\n\t(parser::parser): Initialize parsing_match_operand.\n\n\t2014-10-28  Richard Biener  <rguenther@suse.de>\n\n\t* genmatch.c (parser::parse_for): Properly check for already\n\tdefined operators.\n\n\t2014-10-28  Prathamesh Kulkarni  <bilbotheelffriend@gmail.com>\n\n\t* genmatch.c (error_cb): Adjust for printing warnings.\n\t(warning_at): New function.\n\t(user_id): Add new member used.\n\t(get_operator): Mark user_id as used.\n\t(parse_for): Warn for unused operators.\n\nFrom-SVN: r217422", "tree": {"sha": "a4bfc2288e99d53baf918b58cbcc8b5582f318e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4bfc2288e99d53baf918b58cbcc8b5582f318e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72eb311da1b77bfbfefcd830a49a0368b2b5919d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72eb311da1b77bfbfefcd830a49a0368b2b5919d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72eb311da1b77bfbfefcd830a49a0368b2b5919d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72eb311da1b77bfbfefcd830a49a0368b2b5919d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eaeba53a031a1ea6ab493fc752acec00889d4f0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaeba53a031a1ea6ab493fc752acec00889d4f0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaeba53a031a1ea6ab493fc752acec00889d4f0b"}], "stats": {"total": 200, "additions": 185, "deletions": 15}, "files": [{"sha": "92e704cd2a45f69599ecd4fc049e01f7080c3a5c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72eb311da1b77bfbfefcd830a49a0368b2b5919d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72eb311da1b77bfbfefcd830a49a0368b2b5919d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72eb311da1b77bfbfefcd830a49a0368b2b5919d", "patch": "@@ -1,3 +1,53 @@\n+2014-11-12  Richard Biener  <rguenther@suse.de>\n+\n+\tMerge from match-and-simplify branch\n+\t2014-11-04  Prathamesh Kulkarni  <bilbotheelffriend@gmail.com>\n+\n+\t* genmatch.c (user_id): Add new member is_oper_list.\n+\t(user_id::user_id): Add new default argument.\n+\t(parser::parse_operator_list): New function.\n+\t(parser::parse_for): Allow operator-list.\n+\t(parser::parse_pattern): Call parser::parse_operator_list.\n+\t(parser::parse_operation): Reject operator-list.\n+\t* match-builtin.pd: Define operator lists POWs, CBRTs and SQRTs.\n+\n+\t2014-10-31  Prathamesh Kulkarni  <bilbotheelffriend@gmail.com>\n+\n+\t* genmatch.c (parser::parse_c_expr): Mark user-defined ops as used.\n+\n+\t2014-10-30  Prathamesh Kulkarni  <bilbotheelffriend@gmail.com>\n+\n+\t* genmatch.c (parser::parse_op): Check if predicate is used in\n+\tresult operand.\n+\n+\t2014-10-29  Prathamesh Kulkarni  <bilbotheelffriend@gmail.com>\n+\n+\t* genmatch.c (parser::parse_for): Make sure to have a valid\n+\ttoken to report errors at.\n+\n+\t2014-10-28  Prathamesh Kulkarni  <bilbotheelffriend@gmail.com>\n+\n+\t* genmatch.c (parser): Add new member parsing_match_operand.\n+\t(parser::parse_operation): Check for conditional convert in result\n+\toperand.\n+\t(parser::parse_expr): Check for commutative operator in result operand.\n+\tCheck for :type in match operand.\n+\t(parser::parse_simplify): Set/unset parsing_match_operand.\n+\t(parser::parser): Initialize parsing_match_operand.\n+\n+\t2014-10-28  Richard Biener  <rguenther@suse.de>\n+\n+\t* genmatch.c (parser::parse_for): Properly check for already\n+\tdefined operators.\n+\n+\t2014-10-28  Prathamesh Kulkarni  <bilbotheelffriend@gmail.com>\n+\n+\t* genmatch.c (error_cb): Adjust for printing warnings.\n+\t(warning_at): New function.\n+\t(user_id): Add new member used.\n+\t(get_operator): Mark user_id as used.\n+\t(parse_for): Warn for unused operators.\n+\n 2014-11-12  Richard Biener  <rguenther@suse.de>\n \n \t* match.pd: Implement simple complex operations cancelling."}, {"sha": "0e4208f17e7dda72a70df7e23d08fcc8b9450263", "filename": "gcc/genmatch.c", "status": "modified", "additions": 135, "deletions": 15, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72eb311da1b77bfbfefcd830a49a0368b2b5919d/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72eb311da1b77bfbfefcd830a49a0368b2b5919d/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=72eb311da1b77bfbfefcd830a49a0368b2b5919d", "patch": "@@ -54,13 +54,14 @@ static bool\n #if GCC_VERSION >= 4001\n __attribute__((format (printf, 6, 0)))\n #endif\n-error_cb (cpp_reader *, int, int, source_location location,\n+error_cb (cpp_reader *, int errtype, int, source_location location,\n \t  unsigned int, const char *msg, va_list *ap)\n {\n   const line_map *map;\n   linemap_resolve_location (line_table, location, LRK_SPELLING_LOCATION, &map);\n   expanded_location loc = linemap_expand_location (line_table, map, location);\n-  fprintf (stderr, \"%s:%d:%d error: \", loc.file, loc.line, loc.column);\n+  fprintf (stderr, \"%s:%d:%d %s: \", loc.file, loc.line, loc.column,\n+\t   (errtype == CPP_DL_WARNING) ? \"warning\" : \"error\");\n   vfprintf (stderr, msg, *ap);\n   fprintf (stderr, \"\\n\");\n   FILE *f = fopen (loc.file, \"r\");\n@@ -86,7 +87,10 @@ error_cb (cpp_reader *, int, int, source_location location,\n notfound:\n       fclose (f);\n     }\n-  exit (1);\n+\n+  if (errtype == CPP_DL_FATAL)\n+    exit (1);\n+  return false;\n }\n \n static void\n@@ -101,6 +105,18 @@ fatal_at (const cpp_token *tk, const char *msg, ...)\n   va_end (ap);\n }\n \n+static void\n+#if GCC_VERSION >= 4001\n+__attribute__((format (printf, 2, 3)))\n+#endif\n+warning_at (const cpp_token *tk, const char *msg, ...)\n+{\n+  va_list ap;\n+  va_start (ap, msg);\n+  error_cb (NULL, CPP_DL_WARNING, 0, tk->src_loc, 0, msg, &ap);\n+  va_end (ap);\n+}\n+\n static void\n output_line_directive (FILE *f, source_location location,\n \t\t       bool dumpfile = false)\n@@ -228,9 +244,12 @@ struct predicate_id : public id_base\n \n struct user_id : public id_base\n {\n-  user_id (const char *id_)\n-    : id_base (id_base::USER, id_), substitutes (vNULL) {}\n+  user_id (const char *id_, bool is_oper_list_ = false)\n+    : id_base (id_base::USER, id_), substitutes (vNULL),\n+      used (false), is_oper_list (is_oper_list_) {}\n   vec<id_base *> substitutes;\n+  bool used;\n+  bool is_oper_list;\n };\n \n template<>\n@@ -331,7 +350,12 @@ get_operator (const char *id)\n \n   id_base *op = operators->find_with_hash (&tem, tem.hashval);\n   if (op)\n-    return op;\n+    {\n+      /* If this is a user-defined identifier track whether it was used.  */\n+      if (user_id *uid = dyn_cast<user_id *> (op))\n+\tuid->used = true;\n+      return op;\n+    }\n \n   /* Try all-uppercase.  */\n   char *id2 = xstrdup (id);\n@@ -2650,6 +2674,7 @@ class parser\n   void parse_for (source_location);\n   void parse_if (source_location);\n   void parse_predicates (source_location);\n+  void parse_operator_list (source_location);\n \n   cpp_reader *r;\n   vec<if_or_with> active_ifs;\n@@ -2660,6 +2685,7 @@ class parser\n public:\n   vec<simplify *> simplifiers;\n   vec<predicate_id *> user_predicates;\n+  bool parsing_match_operand;\n };\n \n /* Lexing helpers.  */\n@@ -2805,6 +2831,10 @@ parser::parse_operation ()\n \t;\n       else\n \tfatal_at (id_tok, \"non-convert operator conditionalized\");\n+\n+      if (!parsing_match_operand)\n+\tfatal_at (id_tok, \"conditional convert can only be used in \"\n+\t\t  \"match expression\");\n       eat_token (CPP_QUERY);\n     }\n   else if (strcmp  (id, \"convert1\") == 0\n@@ -2813,6 +2843,11 @@ parser::parse_operation ()\n   id_base *op = get_operator (id);\n   if (!op)\n     fatal_at (id_tok, \"unknown operator %s\", id);\n+\n+  user_id *p = dyn_cast<user_id *> (op);\n+  if (p && p->is_oper_list)\n+    fatal_at (id_tok, \"operator-list not allowed in expression\");\n+\n   return op;\n }\n \n@@ -2824,7 +2859,7 @@ parser::parse_capture (operand *op)\n {\n   eat_token (CPP_ATSIGN);\n   const cpp_token *token = peek ();\n-  const char *id;\n+  const char *id = NULL;\n   if (token->type == CPP_NUMBER)\n     id = get_number ();\n   else if (token->type == CPP_NAME)\n@@ -2861,11 +2896,21 @@ parser::parse_expr ()\n \t{\n \t  const char *s = get_ident ();\n \t  if (s[0] == 'c' && !s[1])\n-\t    is_commutative = true;\n+\t    {\n+\t      if (!parsing_match_operand)\n+\t\tfatal_at (token,\n+\t\t\t  \"flag 'c' can only be used in match expression\");\n+\t      is_commutative = true;\n+\t    }\n \t  else if (s[1] != '\\0')\n-\t    expr_type = s;\n+\t    {\n+\t      if (parsing_match_operand)\n+\t\tfatal_at (token, \"type can only be used in result expression\");\n+\t      expr_type = s;\n+\t    }\n \t  else\n \t    fatal_at (token, \"flag %s not recognized\", s);\n+\n \t  token = peek ();\n \t}\n       else\n@@ -2937,6 +2982,11 @@ parser::parse_c_expr (cpp_ttype start)\n       if (token->type == CPP_SEMICOLON)\n \tnr_stmts++;\n \n+      /* If this is possibly a user-defined identifier mark it used.  */\n+      if (token->type == CPP_NAME)\n+\tget_operator ((const char *)CPP_HASHNODE\n+\t\t        (token->val.node.node)->ident.str);\n+\n       /* Record the token.  */\n       code.safe_push (*token);\n     }\n@@ -2984,6 +3034,8 @@ parser::parse_op ()\n \t    op = new predicate (p);\n \t  else\n \t    fatal_at (token, \"using an unsupported operator as predicate\");\n+\t  if (!parsing_match_operand)\n+\t    fatal_at (token, \"predicates are only allowed in match expression\");\n \t  token = peek ();\n \t  if (token->flags & PREV_WHITE)\n \t    return op;\n@@ -3020,7 +3072,9 @@ parser::parse_simplify (source_location match_location,\n   capture_ids = new cid_map_t;\n \n   const cpp_token *loc = peek ();\n+  parsing_match_operand = true;\n   struct operand *match = parse_op ();\n+  parsing_match_operand = false;\n   if (match->type == operand::OP_CAPTURE && !matcher)\n     fatal_at (loc, \"outermost expression cannot be captured\");\n   if (match->type == operand::OP_EXPR\n@@ -3138,24 +3192,26 @@ parser::parse_simplify (source_location match_location,\n void\n parser::parse_for (source_location)\n {\n+  auto_vec<const cpp_token *> user_id_tokens;\n   vec<user_id *> user_ids = vNULL;\n   const cpp_token *token;\n   unsigned min_n_opers = 0, max_n_opers = 0;\n \n   while (1)\n     {\n-      token = peek_ident ();\n-      if (token == 0)\n+      token = peek ();\n+      if (token->type != CPP_NAME)\n \tbreak;\n \n       /* Insert the user defined operators into the operator hash.  */\n       const char *id = get_ident ();\n+      if (get_operator (id) != NULL)\n+\tfatal_at (token, \"operator already defined\");\n       user_id *op = new user_id (id);\n       id_base **slot = operators->find_slot_with_hash (op, op->hashval, INSERT);\n-      if (*slot)\n-\tfatal_at (token, \"operator already defined\");\n       *slot = op;\n       user_ids.safe_push (op);\n+      user_id_tokens.safe_push (token);\n \n       eat_token (CPP_OPEN_PAREN);\n \n@@ -3177,7 +3233,11 @@ parser::parse_for (source_location)\n \t    fatal_at (token, \"operator '%s' with arity %d does not match \"\n \t\t      \"others with arity %d\", oper, idb->nargs, arity);\n \n-\t  op->substitutes.safe_push (idb);\n+\t  user_id *p = dyn_cast<user_id *> (idb);\n+\t  if (p && p->is_oper_list)\n+\t    op->substitutes.safe_splice (p->substitutes);\n+\t  else \n+\t    op->substitutes.safe_push (idb);\n \t}\n       op->nargs = arity;\n       token = expect (CPP_CLOSE_PAREN);\n@@ -3225,7 +3285,59 @@ parser::parse_for (source_location)\n \n   /* Remove user-defined operators from the hash again.  */\n   for (unsigned i = 0; i < user_ids.length (); ++i)\n-    operators->remove_elt (user_ids[i]);\n+    {\n+      if (!user_ids[i]->used)\n+\twarning_at (user_id_tokens[i],\n+\t\t    \"operator %s defined but not used\", user_ids[i]->id);\n+      operators->remove_elt (user_ids[i]);\n+    }\n+}\n+\n+/* Parse an identifier associated with a list of operators.\n+     oprs = '(' 'define_operator_list' <ident> <ident>... ')'  */\n+\n+void\n+parser::parse_operator_list (source_location)\n+{\n+  const cpp_token *token = peek (); \n+  const char *id = get_ident ();\n+\n+  if (get_operator (id) != 0)\n+    fatal_at (token, \"operator %s already defined\", id);\n+\n+  user_id *op = new user_id (id, true);\n+  int arity = -1;\n+  \n+  while ((token = peek_ident ()) != 0)\n+    {\n+      token = peek (); \n+      const char *oper = get_ident ();\n+      id_base *idb = get_operator (oper);\n+      \n+      if (idb == 0)\n+\tfatal_at (token, \"no such operator '%s'\", oper);\n+\n+      if (arity == -1)\n+\tarity = idb->nargs;\n+      else if (idb->nargs == -1)\n+\t;\n+      else if (arity != idb->nargs)\n+\tfatal_at (token, \"operator '%s' with arity %d does not match \"\n+\t\t\t \"others with arity %d\", oper, idb->nargs, arity);\n+\n+      /* We allow composition of multiple operator lists.  */\n+      if (user_id *p = dyn_cast<user_id *> (idb))\n+\top->substitutes.safe_splice (p->substitutes);\n+      else\n+\top->substitutes.safe_push (idb);\n+    }\n+\n+  if (op->substitutes.length () == 0)\n+    fatal_at (token, \"operator-list cannot be empty\");\n+\n+  op->nargs = arity;\n+  id_base **slot = operators->find_slot_with_hash (op, op->hashval, INSERT);\n+  *slot = op;\n }\n \n /* Parse an outer if expression.\n@@ -3328,6 +3440,13 @@ parser::parse_pattern ()\n \tfatal_at (token, \"define_predicates inside if or for is not supported\");\n       parse_predicates (token->src_loc);\n     }\n+  else if (strcmp (id, \"define_operator_list\") == 0)\n+    {\n+      if (active_ifs.length () > 0\n+\t  || active_fors.length () > 0)\n+\tfatal_at (token, \"operator-list inside if or for is not supported\");\n+      parse_operator_list (token->src_loc);\n+    }\n   else\n     fatal_at (token, \"expected %s'simplify', 'match', 'for' or 'if'\",\n \t      active_ifs.length () == 0 && active_fors.length () == 0\n@@ -3345,6 +3464,7 @@ parser::parser (cpp_reader *r_)\n   active_fors = vNULL;\n   simplifiers = vNULL;\n   user_predicates = vNULL;\n+  parsing_match_operand = false;\n \n   const cpp_token *token = next ();\n   while (token->type != CPP_EOF)"}]}