{"sha": "bd28782c2f0a7ed7c3ccb2381d1f688e1ffdd8f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQyODc4MmMyZjBhN2VkN2MzY2NiMjM4MWQxZjY4OGUxZmZkZDhmNg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-08-14T08:41:57Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:41:57Z"}, "message": "exp_ch5.adb (Expand_Assign_Array): If source or target of assignment is a variable that renames a slice...\n\n2007-08-14  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch5.adb (Expand_Assign_Array): If source or target of assignment\n\tis a variable that renames a slice, use the variable itself in the\n\texpannsion when the renamed expression itself may be modified between\n\tthe declaration of the renaming and the array assignment.\n\nFrom-SVN: r127430", "tree": {"sha": "bee5452e3a6b8a5733fe027c5cd5b432156cff10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bee5452e3a6b8a5733fe027c5cd5b432156cff10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd28782c2f0a7ed7c3ccb2381d1f688e1ffdd8f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd28782c2f0a7ed7c3ccb2381d1f688e1ffdd8f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd28782c2f0a7ed7c3ccb2381d1f688e1ffdd8f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd28782c2f0a7ed7c3ccb2381d1f688e1ffdd8f6/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fa57ac97e9e50108ba984a0a6bfe3d54d339f059", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa57ac97e9e50108ba984a0a6bfe3d54d339f059", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa57ac97e9e50108ba984a0a6bfe3d54d339f059"}], "stats": {"total": 614, "additions": 105, "deletions": 509}, "files": [{"sha": "de3b135dfb46e14adb3d08320ea41c4116cb1560", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 105, "deletions": 509, "changes": 614, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd28782c2f0a7ed7c3ccb2381d1f688e1ffdd8f6/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd28782c2f0a7ed7c3ccb2381d1f688e1ffdd8f6/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=bd28782c2f0a7ed7c3ccb2381d1f688e1ffdd8f6", "patch": "@@ -64,12 +64,6 @@ with Validsw;  use Validsw;\n \n package body Exp_Ch5 is\n \n-   Enable_New_Return_Processing : constant Boolean := True;\n-   --  ??? This flag is temporary. False causes the compiler to use the old\n-   --  version of Analyze_Return_Statement; True, the new version, which does\n-   --  not yet work. We probably want this to match the corresponding thing\n-   --  in sem_ch6.adb.\n-\n    function Change_Of_Representation (N : Node_Id) return Boolean;\n    --  Determine if the right hand side of the assignment N is a type\n    --  conversion which requires a change of representation. Called\n@@ -110,17 +104,15 @@ package body Exp_Ch5 is\n    --  of representation.\n \n    procedure Expand_Non_Function_Return (N : Node_Id);\n-   --  Called by Expand_Simple_Return in case we're returning from a procedure\n-   --  body, entry body, accept statement, or extended returns statement.\n-   --  Note that all non-function returns are simple return statements.\n+   --  Called by Expand_N_Simple_Return_Statement in case we're returning from\n+   --  a procedure body, entry body, accept statement, or extended return\n+   --  statement.  Note that all non-function returns are simple return\n+   --  statements.\n \n    procedure Expand_Simple_Function_Return (N : Node_Id);\n-   --  Expand simple return from function. Called by Expand_Simple_Return in\n-   --  case we're returning from a function body.\n-\n-   procedure Expand_Simple_Return (N : Node_Id);\n-   --  Expansion for simple return statements. Calls either\n-   --  Expand_Simple_Function_Return or Expand_Non_Function_Return.\n+   --  Expand simple return from function. Called by\n+   --  Expand_N_Simple_Return_Statement in case we're returning from a function\n+   --  body.\n \n    function Make_Tag_Ctrl_Assignment (N : Node_Id) return List_Id;\n    --  Generate the necessary code for controlled and tagged assignment,\n@@ -179,7 +171,7 @@ package body Exp_Ch5 is\n       --  This switch is set to True if the array move must be done using\n       --  an explicit front end generated loop.\n \n-      procedure Apply_Dereference (Arg : in out Node_Id);\n+      procedure Apply_Dereference (Arg : Node_Id);\n       --  If the argument is an access to an array, and the assignment is\n       --  converted into a procedure call, apply explicit dereference.\n \n@@ -202,7 +194,7 @@ package body Exp_Ch5 is\n       -- Apply_Dereference --\n       -----------------------\n \n-      procedure Apply_Dereference (Arg : in out Node_Id) is\n+      procedure Apply_Dereference (Arg : Node_Id) is\n          Typ : constant Entity_Id := Etype (Arg);\n       begin\n          if Is_Access_Type (Typ) then\n@@ -260,31 +252,26 @@ package body Exp_Ch5 is\n    --  Start of processing for Expand_Assign_Array\n \n    begin\n-      --  Deal with length check, note that the length check is done with\n+      --  Deal with length check. Note that the length check is done with\n       --  respect to the right hand side as given, not a possible underlying\n       --  renamed object, since this would generate incorrect extra checks.\n \n       Apply_Length_Check (Rhs, L_Type);\n \n-      --  We start by assuming that the move can be done in either\n-      --  direction, i.e. that the two sides are completely disjoint.\n+      --  We start by assuming that the move can be done in either direction,\n+      --  i.e. that the two sides are completely disjoint.\n \n       Set_Forwards_OK  (N, True);\n       Set_Backwards_OK (N, True);\n \n       --  Normally it is only the slice case that can lead to overlap, and\n       --  explicit checks for slices are made below. But there is one case\n-      --  where the slice can be implicit and invisible to us and that is the\n-      --  case where we have a one dimensional array, and either both operands\n-      --  are parameters, or one is a parameter and the other is a global\n-      --  variable. In this case the parameter could be a slice that overlaps\n-      --  with the other parameter.\n-\n-      --  Check for the case of slices requiring an explicit loop. Normally it\n-      --  is only the explicit slice cases that bother us, but in the case of\n-      --  one dimensional arrays, parameters can be slices that are passed by\n-      --  reference, so we can have aliasing for assignments from one parameter\n-      --  to another, or assignments between parameters and nonlocal variables.\n+      --  where the slice can be implicit and invisible to us: when we have a\n+      --  one dimensional array, and either both operands are parameters, or\n+      --  one is a parameter (which can be a slice passed by reference) and the\n+      --  other is a non-local variable. In this case the parameter could be a\n+      --  slice that overlaps with the other operand.\n+\n       --  However, if the array subtype is a constrained first subtype in the\n       --  parameter case, then we don't have to worry about overlap, since\n       --  slice assignments aren't possible (other than for a slice denoting\n@@ -340,8 +327,8 @@ package body Exp_Ch5 is\n       then\n          Loop_Required := True;\n \n-      --  Arrays with controlled components are expanded into a loop\n-      --  to force calls to adjust at the component level.\n+      --  Arrays with controlled components are expanded into a loop to force\n+      --  calls to Adjust at the component level.\n \n       elsif Has_Controlled_Component (L_Type) then\n          Loop_Required := True;\n@@ -378,8 +365,8 @@ package body Exp_Ch5 is\n          --  do this, we get the wrong length computed for the array to be\n          --  moved. The two cases we need to worry about are:\n \n-         --  Explicit deference of an unconstrained packed array type as\n-         --  in the following example:\n+         --  Explicit deference of an unconstrained packed array type as in the\n+         --  following example:\n \n          --    procedure C52 is\n          --       type BITS is array(INTEGER range <>) of BOOLEAN;\n@@ -401,7 +388,7 @@ package body Exp_Ch5 is\n          --       File.Storage := Contents;\n          --    end Write_All;\n \n-         --  We expand to a loop in either of these two cases\n+         --  We expand to a loop in either of these two cases.\n \n          --  Question for future thought. Another potentially more efficient\n          --  approach would be to create the actual subtype, and then do an\n@@ -411,7 +398,7 @@ package body Exp_Ch5 is\n \n             function Is_UBPA_Reference (Opnd : Node_Id) return Boolean;\n             --  Function to perform required test for the first case, above\n-            --  (dereference of an unconstrained bit packed array)\n+            --  (dereference of an unconstrained bit packed array).\n \n             -----------------------\n             -- Is_UBPA_Reference --\n@@ -470,14 +457,14 @@ package body Exp_Ch5 is\n       --  The back end can always handle the assignment if the right side is a\n       --  string literal (note that overlap is definitely impossible in this\n       --  case). If the type is packed, a string literal is always converted\n-      --  into aggregate, except in the case of a null slice, for which no\n+      --  into an aggregate, except in the case of a null slice, for which no\n       --  aggregate can be written. In that case, rewrite the assignment as a\n       --  null statement, a length check has already been emitted to verify\n       --  that the range of the left-hand side is empty.\n \n-      --  Note that this code is not executed if we had an assignment of a\n+      --  Note that this code is not executed if we have an assignment of a\n       --  string literal to a non-bit aligned component of a record, a case\n-      --  which cannot be handled by the backend\n+      --  which cannot be handled by the backend.\n \n       elsif Nkind (Rhs) = N_String_Literal then\n          if String_Length (Strval (Rhs)) = 0\n@@ -600,8 +587,8 @@ package body Exp_Ch5 is\n          end if;\n \n          --  If both sides are slices, we must figure out whether it is safe\n-         --  to do the move in one direction or the other It is always safe if\n-         --  there is a change of representation since obviously two arrays\n+         --  to do the move in one direction or the other. It is always safe\n+         --  if there is a change of representation since obviously two arrays\n          --  with different representations cannot possibly overlap.\n \n          if (not Crep) and L_Slice and R_Slice then\n@@ -708,6 +695,31 @@ package body Exp_Ch5 is\n          --         <code for Backwards_OK = True above>\n          --      end if;\n \n+         --  In order to detect possible aliasing, we examine the renamed\n+         --  expression when the source or target is a renaming. However,\n+         --  the renaming may be intended to capture an address that may be\n+         --  affected by subsequent code, and therefore we must recover\n+         --  the actual entity for the expansion that follows, not the\n+         --  object it renames. In particular, if source or target designate\n+         --  a portion of a dynamically allocated object, the pointer to it\n+         --  may be reassigned but the renaming preserves the proper location.\n+\n+         if Is_Entity_Name (Rhs)\n+           and then\n+             Nkind (Parent (Entity (Rhs))) = N_Object_Renaming_Declaration\n+           and then Nkind (Act_Rhs) = N_Slice\n+         then\n+            Rarray := Rhs;\n+         end if;\n+\n+         if Is_Entity_Name (Lhs)\n+           and then\n+             Nkind (Parent (Entity (Lhs))) = N_Object_Renaming_Declaration\n+           and then Nkind (Act_Lhs) = N_Slice\n+         then\n+            Larray := Lhs;\n+         end if;\n+\n          --  Cases where either Forwards_OK or Backwards_OK is true\n \n          if Forwards_OK (N) or else Backwards_OK (N) then\n@@ -1697,7 +1709,7 @@ package body Exp_Ch5 is\n \n                begin\n                   C_Es :=\n-                    Range_Check\n+                    Get_Range_Checks\n                       (Lhs,\n                        Target_Typ,\n                        Etype (Designated_Type (Etype (Lhs))));\n@@ -2340,9 +2352,8 @@ package body Exp_Ch5 is\n \n    --  That is, we need to have a reified return object if there are statements\n    --  (which might refer to it) or if we're doing build-in-place (so we can\n-   --  set its address to the final resting place -- but that key part is not\n-   --  yet implemented) or if there is no expression (in which case default\n-   --  initial values might need to be set).\n+   --  set its address to the final resting place or if there is no expression\n+   --  (in which case default initial values might need to be set).\n \n    procedure Expand_N_Extended_Return_Statement (N : Node_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n@@ -2420,21 +2431,25 @@ package body Exp_Ch5 is\n       ---------------------\n \n       function Move_Final_List return Node_Id is\n-         Flist             : constant Entity_Id  :=\n-                               Finalization_Chain_Entity\n-                                 (Return_Statement_Entity (N));\n+         Flist : constant Entity_Id  :=\n+                   Finalization_Chain_Entity (Return_Statement_Entity (N));\n \n-         From              : constant Node_Id :=\n-                               New_Reference_To (Flist, Loc);\n+         From : constant Node_Id := New_Reference_To (Flist, Loc);\n \n          Caller_Final_List : constant Entity_Id :=\n                                Build_In_Place_Formal\n                                  (Parent_Function, BIP_Final_List);\n \n-         To                : constant Node_Id :=\n-                               New_Reference_To (Caller_Final_List, Loc);\n+         To : constant Node_Id := New_Reference_To (Caller_Final_List, Loc);\n \n       begin\n+         --  Catch cases where a finalization chain entity has not been\n+         --  associated with the return statement entity.\n+\n+         pragma Assert (Present (Flist));\n+\n+         --  Build required call\n+\n          return\n            Make_If_Statement (Loc,\n              Condition =>\n@@ -2526,7 +2541,7 @@ package body Exp_Ch5 is\n          --  Build a simple_return_statement that returns the return object\n \n          Return_Stm :=\n-           Make_Return_Statement (Loc,\n+           Make_Simple_Return_Statement (Loc,\n              Expression => New_Occurrence_Of (Return_Object_Entity, Loc));\n          Append_To (Statements, Return_Stm);\n \n@@ -2926,7 +2941,7 @@ package body Exp_Ch5 is\n \n          --  Build simple_return_statement that returns the expression directly\n \n-         Return_Stm := Make_Return_Statement (Loc, Expression => Exp);\n+         Return_Stm := Make_Simple_Return_Statement (Loc, Expression => Exp);\n \n          Result := Return_Stm;\n       end if;\n@@ -2991,6 +3006,12 @@ package body Exp_Ch5 is\n       E      : Node_Id;\n       New_If : Node_Id;\n \n+      Warn_If_Deleted : constant Boolean :=\n+                          Warn_On_Deleted_Code and then Comes_From_Source (N);\n+      --  Indicates whether we want warnings when we delete branches of the\n+      --  if statement based on constant condition analysis. We never want\n+      --  these warnings for expander generated code.\n+\n    begin\n       Adjust_Condition (Condition (N));\n \n@@ -3007,8 +3028,8 @@ package body Exp_Ch5 is\n \n             --  All the else parts can be killed\n \n-            Kill_Dead_Code (Elsif_Parts (N), Warn_On_Deleted_Code);\n-            Kill_Dead_Code (Else_Statements (N), Warn_On_Deleted_Code);\n+            Kill_Dead_Code (Elsif_Parts (N), Warn_If_Deleted);\n+            Kill_Dead_Code (Else_Statements (N), Warn_If_Deleted);\n \n             Hed := Remove_Head (Then_Statements (N));\n             Insert_List_After (N, Then_Statements (N));\n@@ -3028,7 +3049,7 @@ package body Exp_Ch5 is\n                Kill_Dead_Code (Condition (N));\n             end if;\n \n-            Kill_Dead_Code (Then_Statements (N), Warn_On_Deleted_Code);\n+            Kill_Dead_Code (Then_Statements (N), Warn_If_Deleted);\n \n             --  If there are no elsif statements, then we simply replace the\n             --  entire if statement by the sequence of else statements.\n@@ -3173,9 +3194,9 @@ package body Exp_Ch5 is\n             Else_Stm : constant Node_Id := First (Else_Statements (N));\n \n          begin\n-            if Nkind (Then_Stm) = N_Return_Statement\n+            if Nkind (Then_Stm) = N_Simple_Return_Statement\n                  and then\n-               Nkind (Else_Stm) = N_Return_Statement\n+               Nkind (Else_Stm) = N_Simple_Return_Statement\n             then\n                declare\n                   Then_Expr : constant Node_Id := Expression (Then_Stm);\n@@ -3190,7 +3211,7 @@ package body Exp_Ch5 is\n                        and then Entity (Else_Expr) = Standard_False\n                      then\n                         Rewrite (N,\n-                          Make_Return_Statement (Loc,\n+                          Make_Simple_Return_Statement (Loc,\n                             Expression => Relocate_Node (Condition (N))));\n                         Analyze (N);\n                         return;\n@@ -3199,7 +3220,7 @@ package body Exp_Ch5 is\n                        and then Entity (Else_Expr) = Standard_True\n                      then\n                         Rewrite (N,\n-                          Make_Return_Statement (Loc,\n+                          Make_Simple_Return_Statement (Loc,\n                             Expression =>\n                               Make_Op_Not (Loc,\n                                 Right_Opnd => Relocate_Node (Condition (N)))));\n@@ -3412,430 +3433,35 @@ package body Exp_Ch5 is\n       end if;\n    end Expand_N_Loop_Statement;\n \n-   -------------------------------\n-   -- Expand_N_Return_Statement --\n-   -------------------------------\n-\n-   procedure Expand_N_Return_Statement (N : Node_Id) is\n-      Loc         : constant Source_Ptr := Sloc (N);\n-      Exp         : constant Node_Id    := Expression (N);\n-      Exptyp      : Entity_Id;\n-      T           : Entity_Id;\n-      Utyp        : Entity_Id;\n-      Scope_Id    : Entity_Id;\n-      Kind        : Entity_Kind;\n-      Call        : Node_Id;\n-      Acc_Stat    : Node_Id;\n-      Goto_Stat   : Node_Id;\n-      Lab_Node    : Node_Id;\n-      Cur_Idx     : Nat;\n-      Return_Type : Entity_Id;\n-      Result_Exp  : Node_Id;\n-      Result_Id   : Entity_Id;\n-      Result_Obj  : Node_Id;\n+   --------------------------------------\n+   -- Expand_N_Simple_Return_Statement --\n+   --------------------------------------\n \n+   procedure Expand_N_Simple_Return_Statement (N : Node_Id) is\n    begin\n-      if Enable_New_Return_Processing then --  ???Temporary hack\n-         Expand_Simple_Return (N);\n-         return;\n-      end if;\n-\n-      --  Case where returned expression is present\n-\n-      if Present (Exp) then\n-\n-         --  Always normalize C/Fortran boolean result. This is not always\n-         --  necessary, but it seems a good idea to minimize the passing\n-         --  around of non-normalized values, and in any case this handles\n-         --  the processing of barrier functions for protected types, which\n-         --  turn the condition into a return statement.\n-\n-         Exptyp := Etype (Exp);\n-\n-         if Is_Boolean_Type (Exptyp)\n-           and then Nonzero_Is_True (Exptyp)\n-         then\n-            Adjust_Condition (Exp);\n-            Adjust_Result_Type (Exp, Exptyp);\n-         end if;\n-\n-         --  Do validity check if enabled for returns\n-\n-         if Validity_Checks_On\n-           and then Validity_Check_Returns\n-         then\n-            Ensure_Valid (Exp);\n-         end if;\n-      end if;\n-\n-      --  Find relevant enclosing scope from which return is returning\n-\n-      Cur_Idx := Scope_Stack.Last;\n-      loop\n-         Scope_Id := Scope_Stack.Table (Cur_Idx).Entity;\n-\n-         if Ekind (Scope_Id) /= E_Block\n-           and then Ekind (Scope_Id) /= E_Loop\n-         then\n-            exit;\n-\n-         else\n-            Cur_Idx := Cur_Idx - 1;\n-            pragma Assert (Cur_Idx >= 0);\n-         end if;\n-      end loop;\n-      --  ???I believe the above code is no longer necessary\n-      pragma Assert (Scope_Id =\n-                       Return_Applies_To (Return_Statement_Entity (N)));\n-\n-      if No (Exp) then\n-         Kind := Ekind (Scope_Id);\n-\n-         --  If it is a return from procedures do no extra steps\n-\n-         if Kind = E_Procedure or else Kind = E_Generic_Procedure then\n-            return;\n-         end if;\n-\n-         pragma Assert (Is_Entry (Scope_Id));\n-\n-         --  Look at the enclosing block to see whether the return is from an\n-         --  accept statement or an entry body.\n-\n-         for J in reverse 0 .. Cur_Idx loop\n-            Scope_Id := Scope_Stack.Table (J).Entity;\n-            exit when Is_Concurrent_Type (Scope_Id);\n-         end loop;\n-\n-         --  If it is a return from accept statement it should be expanded\n-         --  as a call to RTS Complete_Rendezvous and a goto to the end of\n-         --  the accept body.\n-\n-         --  (cf : Expand_N_Accept_Statement, Expand_N_Selective_Accept,\n-         --   Expand_N_Accept_Alternative in exp_ch9.adb)\n-\n-         if Is_Task_Type (Scope_Id) then\n-\n-            Call := (Make_Procedure_Call_Statement (Loc,\n-                      Name => New_Reference_To\n-                        (RTE (RE_Complete_Rendezvous), Loc)));\n-            Insert_Before (N, Call);\n-            --  why not insert actions here???\n-            Analyze (Call);\n-\n-            Acc_Stat := Parent (N);\n-            while Nkind (Acc_Stat) /= N_Accept_Statement loop\n-               Acc_Stat := Parent (Acc_Stat);\n-            end loop;\n-\n-            Lab_Node := Last (Statements\n-              (Handled_Statement_Sequence (Acc_Stat)));\n-\n-            Goto_Stat := Make_Goto_Statement (Loc,\n-              Name => New_Occurrence_Of\n-                (Entity (Identifier (Lab_Node)), Loc));\n-\n-            Set_Analyzed (Goto_Stat);\n-\n-            Rewrite (N, Goto_Stat);\n-            Analyze (N);\n-\n-         --  If it is a return from an entry body, put a Complete_Entry_Body\n-         --  call in front of the return.\n-\n-         elsif Is_Protected_Type (Scope_Id) then\n-\n-            Call :=\n-              Make_Procedure_Call_Statement (Loc,\n-                Name => New_Reference_To\n-                  (RTE (RE_Complete_Entry_Body), Loc),\n-                Parameter_Associations => New_List\n-                  (Make_Attribute_Reference (Loc,\n-                    Prefix =>\n-                      New_Reference_To\n-                        (Object_Ref\n-                           (Corresponding_Body (Parent (Scope_Id))),\n-                        Loc),\n-                    Attribute_Name => Name_Unchecked_Access)));\n-\n-            Insert_Before (N, Call);\n-            Analyze (Call);\n-         end if;\n-\n-         return;\n-      end if;\n-\n-      T := Etype (Exp);\n-      Return_Type := Etype (Scope_Id);\n-      Utyp := Underlying_Type (Return_Type);\n-\n-      --  Check the result expression of a scalar function against the subtype\n-      --  of the function by inserting a conversion. This conversion must\n-      --  eventually be performed for other classes of types, but for now it's\n-      --  only done for scalars. ???\n-\n-      if Is_Scalar_Type (T) then\n-         Rewrite (Exp, Convert_To (Return_Type, Exp));\n-         Analyze (Exp);\n-      end if;\n-\n-      --  Deal with returning variable length objects and controlled types\n-\n-      --  Nothing to do if we are returning by reference, or this is not type\n-      --  that requires special processing (indicated by the fact that it\n-      --  requires a cleanup scope for the secondary stack case).\n-\n-      if Is_Inherently_Limited_Type (T) then\n-         null;\n-\n-      elsif not Requires_Transient_Scope (Return_Type) then\n-\n-         --  Mutable records with no variable length components are not\n-         --  returned on the sec-stack, so we need to make sure that the\n-         --  backend will only copy back the size of the actual value, and not\n-         --  the maximum size. We create an actual subtype for this purpose.\n-\n-         declare\n-            Ubt  : constant Entity_Id := Underlying_Type (Base_Type (T));\n-            Decl : Node_Id;\n-            Ent  : Entity_Id;\n-\n-         begin\n-            if Has_Discriminants (Ubt)\n-              and then not Is_Constrained (Ubt)\n-              and then not Has_Unchecked_Union (Ubt)\n-            then\n-               Decl := Build_Actual_Subtype (Ubt, Exp);\n-               Ent := Defining_Identifier (Decl);\n-               Insert_Action (Exp, Decl);\n-\n-               Rewrite (Exp, Unchecked_Convert_To (Ent, Exp));\n-               Analyze_And_Resolve (Exp);\n-            end if;\n-         end;\n-\n-      --  Here if secondary stack is used\n-\n-      else\n-         --  Make sure that no surrounding block will reclaim the secondary\n-         --  stack on which we are going to put the result. Not only may this\n-         --  introduce secondary stack leaks but worse, if the reclamation is\n-         --  done too early, then the result we are returning may get\n-         --  clobbered. See example in 7417-003.\n-\n-         declare\n-            S : Entity_Id := Current_Scope;\n-\n-         begin\n-            while Ekind (S) = E_Block or else Ekind (S) = E_Loop loop\n-               Set_Sec_Stack_Needed_For_Return (S, True);\n-               S := Enclosing_Dynamic_Scope (S);\n-            end loop;\n-         end;\n-\n-         --  Optimize the case where the result is a function call. In this\n-         --  case either the result is already on the secondary stack, or is\n-         --  already being returned with the stack pointer depressed and no\n-         --  further processing is required except to set the By_Ref flag to\n-         --  ensure that gigi does not attempt an extra unnecessary copy\n-         --  (actually not just unnecessary but harmfully wrong in the case of\n-         --  a controlled type, where gigi does not know how to do a copy). To\n-         --  make up for a gcc 2.8.1 deficiency (???), we perform the copy for\n-         --  array types if the constrained status of the target type is\n-         --  different from that of the expression.\n-\n-         if Requires_Transient_Scope (T)\n-           and then\n-              (not Is_Array_Type (T)\n-                or else Is_Constrained (T) = Is_Constrained (Return_Type)\n-                or else Is_Class_Wide_Type (Utyp)\n-                or else Controlled_Type (T))\n-           and then Nkind (Exp) = N_Function_Call\n-         then\n-            Set_By_Ref (N);\n-\n-            --  Remove side effects from the expression now so that other parts\n-            --  of the expander do not have to reanalyze the node without this\n-            --  optimization.\n-\n-            Rewrite (Exp, Duplicate_Subexpr_No_Checks (Exp));\n-\n-         --  For controlled types, do the allocation on the secondary stack\n-         --  manually in order to call adjust at the right time:\n-\n-         --    type Anon1 is access Return_Type;\n-         --    for Anon1'Storage_pool use ss_pool;\n-         --    Anon2 : anon1 := new Return_Type'(expr);\n-         --    return Anon2.all;\n-\n-         --  We do the same for classwide types that are not potentially\n-         --  controlled (by the virtue of restriction No_Finalization) because\n-         --  gigi is not able to properly allocate class-wide types.\n-\n-         elsif CW_Or_Controlled_Type (Utyp) then\n-            declare\n-               Loc        : constant Source_Ptr := Sloc (N);\n-               Temp       : constant Entity_Id :=\n-                              Make_Defining_Identifier (Loc,\n-                                Chars => New_Internal_Name ('R'));\n-               Acc_Typ    : constant Entity_Id :=\n-                              Make_Defining_Identifier (Loc,\n-                                Chars => New_Internal_Name ('A'));\n-               Alloc_Node : Node_Id;\n-\n-            begin\n-               Set_Ekind (Acc_Typ, E_Access_Type);\n-\n-               Set_Associated_Storage_Pool (Acc_Typ, RTE (RE_SS_Pool));\n-\n-               Alloc_Node :=\n-                 Make_Allocator (Loc,\n-                   Expression =>\n-                     Make_Qualified_Expression (Loc,\n-                       Subtype_Mark => New_Reference_To (Etype (Exp), Loc),\n-                       Expression => Relocate_Node (Exp)));\n-\n-               Insert_List_Before_And_Analyze (N, New_List (\n-                 Make_Full_Type_Declaration (Loc,\n-                   Defining_Identifier => Acc_Typ,\n-                   Type_Definition     =>\n-                     Make_Access_To_Object_Definition (Loc,\n-                       Subtype_Indication =>\n-                          New_Reference_To (Return_Type, Loc))),\n-\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Temp,\n-                   Object_Definition   => New_Reference_To (Acc_Typ, Loc),\n-                   Expression          => Alloc_Node)));\n-\n-               Rewrite (Exp,\n-                 Make_Explicit_Dereference (Loc,\n-                 Prefix => New_Reference_To (Temp, Loc)));\n-\n-               Analyze_And_Resolve (Exp, Return_Type);\n-            end;\n-\n-         --  Otherwise use the gigi mechanism to allocate result on the\n-         --  secondary stack.\n-\n-         else\n-            Set_Storage_Pool      (N, RTE (RE_SS_Pool));\n-\n-            --  If we are generating code for the VM do not use\n-            --  SS_Allocate since everything is heap-allocated anyway.\n-\n-            if VM_Target = No_VM then\n-               Set_Procedure_To_Call (N, RTE (RE_SS_Allocate));\n-            end if;\n-         end if;\n-      end if;\n-\n-      --  Implement the rules of 6.5(8-10), which require a tag check in the\n-      --  case of a limited tagged return type, and tag reassignment for\n-      --  nonlimited tagged results. These actions are needed when the return\n-      --  type is a specific tagged type and the result expression is a\n-      --  conversion or a formal parameter, because in that case the tag of the\n-      --  expression might differ from the tag of the specific result type.\n-\n-      if Is_Tagged_Type (Utyp)\n-        and then not Is_Class_Wide_Type (Utyp)\n-        and then (Nkind (Exp) = N_Type_Conversion\n-                    or else Nkind (Exp) = N_Unchecked_Type_Conversion\n-                    or else (Is_Entity_Name (Exp)\n-                               and then Ekind (Entity (Exp)) in Formal_Kind))\n-      then\n-         --  When the return type is limited, perform a check that the tag of\n-         --  the result is the same as the tag of the return type.\n-\n-         if Is_Limited_Type (Return_Type) then\n-            Insert_Action (Exp,\n-              Make_Raise_Constraint_Error (Loc,\n-                Condition =>\n-                  Make_Op_Ne (Loc,\n-                    Left_Opnd =>\n-                      Make_Selected_Component (Loc,\n-                        Prefix => Duplicate_Subexpr (Exp),\n-                        Selector_Name =>\n-                          New_Reference_To (First_Tag_Component (Utyp), Loc)),\n-                    Right_Opnd =>\n-                      Unchecked_Convert_To (RTE (RE_Tag),\n-                        New_Reference_To\n-                          (Node (First_Elmt\n-                                  (Access_Disp_Table (Base_Type (Utyp)))),\n-                           Loc))),\n-                Reason => CE_Tag_Check_Failed));\n-\n-         --  If the result type is a specific nonlimited tagged type, then we\n-         --  have to ensure that the tag of the result is that of the result\n-         --  type. This is handled by making a copy of the expression in the\n-         --  case where it might have a different tag, namely when the\n-         --  expression is a conversion or a formal parameter. We create a new\n-         --  object of the result type and initialize it from the expression,\n-         --  which will implicitly force the tag to be set appropriately.\n-\n-         else\n-            Result_Id :=\n-              Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n-            Result_Exp := New_Reference_To (Result_Id, Loc);\n-\n-            Result_Obj :=\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Result_Id,\n-                Object_Definition   => New_Reference_To (Return_Type, Loc),\n-                Constant_Present    => True,\n-                Expression          => Relocate_Node (Exp));\n-\n-            Set_Assignment_OK (Result_Obj);\n-            Insert_Action (Exp, Result_Obj);\n+      --  Distinguish the function and non-function cases:\n \n-            Rewrite (Exp, Result_Exp);\n-            Analyze_And_Resolve (Exp, Return_Type);\n-         end if;\n+      case Ekind (Return_Applies_To (Return_Statement_Entity (N))) is\n \n-      --  Ada 2005 (AI-344): If the result type is class-wide, then insert\n-      --  a check that the level of the return expression's underlying type\n-      --  is not deeper than the level of the master enclosing the function.\n-      --  Always generate the check when the type of the return expression\n-      --  is class-wide, when it's a type conversion, or when it's a formal\n-      --  parameter. Otherwise, suppress the check in the case where the\n-      --  return expression has a specific type whose level is known not to\n-      --  be statically deeper than the function's result type.\n+         when E_Function          |\n+              E_Generic_Function  =>\n+            Expand_Simple_Function_Return (N);\n \n-      --  Note: accessibility check is skipped in the VM case, since there\n-      --  does not seem to be any practical way to implement this check.\n+         when E_Procedure         |\n+              E_Generic_Procedure |\n+              E_Entry             |\n+              E_Entry_Family      |\n+              E_Return_Statement =>\n+            Expand_Non_Function_Return (N);\n \n-      elsif Ada_Version >= Ada_05\n-        and then VM_Target = No_VM\n-        and then Is_Class_Wide_Type (Return_Type)\n-        and then not Scope_Suppress (Accessibility_Check)\n-        and then\n-          (Is_Class_Wide_Type (Etype (Exp))\n-            or else Nkind (Exp) = N_Type_Conversion\n-            or else Nkind (Exp) = N_Unchecked_Type_Conversion\n-            or else (Is_Entity_Name (Exp)\n-                       and then Ekind (Entity (Exp)) in Formal_Kind)\n-            or else Scope_Depth (Enclosing_Dynamic_Scope (Etype (Exp))) >\n-                      Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))\n-      then\n-         Insert_Action (Exp,\n-           Make_Raise_Program_Error (Loc,\n-             Condition =>\n-               Make_Op_Gt (Loc,\n-                 Left_Opnd =>\n-                   Build_Get_Access_Level (Loc,\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix => Duplicate_Subexpr (Exp),\n-                       Attribute_Name => Name_Tag)),\n-                 Right_Opnd =>\n-                   Make_Integer_Literal (Loc,\n-                     Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))),\n-             Reason => PE_Accessibility_Check_Failed));\n-      end if;\n+         when others =>\n+            raise Program_Error;\n+      end case;\n \n    exception\n       when RE_Not_Available =>\n          return;\n-   end Expand_N_Return_Statement;\n+   end Expand_N_Simple_Return_Statement;\n \n    --------------------------------\n    -- Expand_Non_Function_Return --\n@@ -3854,7 +3480,7 @@ package body Exp_Ch5 is\n       Lab_Node    : Node_Id;\n \n    begin\n-      --  If it is a return from procedures do no extra steps\n+      --  If it is a return from a procedure do no extra steps\n \n       if Kind = E_Procedure or else Kind = E_Generic_Procedure then\n          return;\n@@ -3864,7 +3490,7 @@ package body Exp_Ch5 is\n \n       elsif Kind = E_Return_Statement then\n          Rewrite (N,\n-           Make_Return_Statement (Loc,\n+           Make_Simple_Return_Statement (Loc,\n              Expression =>\n                New_Occurrence_Of (First_Entity (Scope_Id), Loc)));\n          Set_Comes_From_Extended_Return_Statement (N);\n@@ -3938,36 +3564,6 @@ package body Exp_Ch5 is\n       end if;\n    end Expand_Non_Function_Return;\n \n-   --------------------------\n-   -- Expand_Simple_Return --\n-   --------------------------\n-\n-   procedure Expand_Simple_Return (N : Node_Id) is\n-   begin\n-      --  Distinguish the function and non-function cases:\n-\n-      case Ekind (Return_Applies_To (Return_Statement_Entity (N))) is\n-\n-         when E_Function          |\n-              E_Generic_Function  =>\n-            Expand_Simple_Function_Return (N);\n-\n-         when E_Procedure         |\n-              E_Generic_Procedure |\n-              E_Entry             |\n-              E_Entry_Family      |\n-              E_Return_Statement =>\n-            Expand_Non_Function_Return (N);\n-\n-         when others =>\n-            raise Program_Error;\n-      end case;\n-\n-   exception\n-      when RE_Not_Available =>\n-         return;\n-   end Expand_Simple_Return;\n-\n    -----------------------------------\n    -- Expand_Simple_Function_Return --\n    -----------------------------------\n@@ -4128,7 +3724,7 @@ package body Exp_Ch5 is\n          --  stack on which we are going to put the result. Not only may this\n          --  introduce secondary stack leaks but worse, if the reclamation is\n          --  done too early, then the result we are returning may get\n-         --  clobbered. See example in 7417-003.\n+         --  clobbered.\n \n          declare\n             S : Entity_Id;"}]}