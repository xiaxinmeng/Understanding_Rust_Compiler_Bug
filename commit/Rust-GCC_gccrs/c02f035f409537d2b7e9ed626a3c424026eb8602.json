{"sha": "c02f035f409537d2b7e9ed626a3c424026eb8602", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAyZjAzNWY0MDk1MzdkMmI3ZTllZDYyNmEzYzQyNDAyNmViODYwMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1997-09-29T06:21:18Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-29T06:21:18Z"}, "message": "alias.c (base_alias_check): Two symbols can conflict if they are accessed via AND.\n\n        * alias.c (base_alias_check): Two symbols can conflict if they\n        are accessed via AND.\n        (memrefs_conflict_p): Likewise.\n\nFrom-SVN: r15785", "tree": {"sha": "33bc77de6f63a4cf00f5abbd1a153f9f54852633", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33bc77de6f63a4cf00f5abbd1a153f9f54852633"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c02f035f409537d2b7e9ed626a3c424026eb8602", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c02f035f409537d2b7e9ed626a3c424026eb8602", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c02f035f409537d2b7e9ed626a3c424026eb8602", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c02f035f409537d2b7e9ed626a3c424026eb8602/comments", "author": null, "committer": null, "parents": [{"sha": "7a14fdc538690adb6b78c265ade1774b52930c54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a14fdc538690adb6b78c265ade1774b52930c54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a14fdc538690adb6b78c265ade1774b52930c54"}], "stats": {"total": 44, "additions": 33, "deletions": 11}, "files": [{"sha": "513abf58a5e99bb4d4ed8195727a36bb978b7ff0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02f035f409537d2b7e9ed626a3c424026eb8602/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02f035f409537d2b7e9ed626a3c424026eb8602/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c02f035f409537d2b7e9ed626a3c424026eb8602", "patch": "@@ -1,5 +1,9 @@\n Mon Sep 29 00:18:16 1997  Richard Henderson  (rth@cygnus.com)\n \n+\t* alias.c (base_alias_check): Two symbols can conflict if they\n+\tare accessed via AND.\n+\t(memrefs_conflict_p): Likewise.\n+\n \t* alpha.h (SETUP_INCOMING_VARARGS): Emit a blockage insn\n \tafter flushing argument registers to the stack.\n "}, {"sha": "eb28526c8d243c0b142aa5bd1b4e1a47d251caaf", "filename": "gcc/alias.c", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02f035f409537d2b7e9ed626a3c424026eb8602/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02f035f409537d2b7e9ed626a3c424026eb8602/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=c02f035f409537d2b7e9ed626a3c424026eb8602", "patch": "@@ -509,10 +509,17 @@ base_alias_check (x, y)\n     return 1;\n \n   /* The base addresses of the read and write are different\n-     expressions.  If they are both symbols there is no\n-     conflict.  */\n+     expressions.  If they are both symbols and they are not accessed\n+     via AND, there is no conflict.  */\n+  /* XXX: We can bring knowledge of object alignment and offset into \n+     play here.  For example, on alpha, \"char a, b;\" can alias one\n+     another, though \"char a; long b;\" cannot.  Similarly, offsets\n+     into strutures may be brought into play.  Given \"char a, b[40];\",\n+     a and b[1] may overlap, but a and b[20] do not.  */\n   if (GET_CODE (x_base) != ADDRESS && GET_CODE (y_base) != ADDRESS)\n-    return 0;\n+    {\n+      return GET_CODE (x) == AND || GET_CODE (y) == AND;\n+    }\n \n   /* If one address is a stack reference there can be no alias:\n      stack references using different base registers do not alias,\n@@ -542,6 +549,10 @@ base_alias_check (x, y)\n    referenced (the reference was BLKmode), so make the most pessimistic\n    assumptions.\n \n+   If XSIZE or YSIZE is negative, we may access memory outside the object\n+   being referenced as a side effect.  This can happen when using AND to\n+   align memory references, as is done on the Alpha.\n+\n    We recognize the following cases of non-conflicting memory:\n \n \t(1) addresses involving the frame pointer cannot conflict\n@@ -573,7 +584,7 @@ memrefs_conflict_p (xsize, x, ysize, y, c)\n \n   if (rtx_equal_for_memref_p (x, y))\n     {\n-      if (xsize == 0 || ysize == 0)\n+      if (xsize <= 0 || ysize <= 0)\n \treturn 1;\n       if (c >= 0 && xsize > c)\n \treturn 1;\n@@ -605,7 +616,7 @@ memrefs_conflict_p (xsize, x, ysize, y, c)\n \t  && GET_CODE (y1) == CONST_INT)\n \t{\n \t  c += INTVAL (y1);\n-\t  return (xsize == 0 || ysize == 0\n+\t  return (xsize <= 0 || ysize <= 0\n \t\t  || (c >= 0 && xsize > c) || (c < 0 && ysize+c > 0));\n \t}\n \n@@ -703,16 +714,22 @@ memrefs_conflict_p (xsize, x, ysize, y, c)\n   /* Treat an access through an AND (e.g. a subword access on an Alpha)\n      as an access with indeterminate size.  */\n   if (GET_CODE (x) == AND && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-    return memrefs_conflict_p (0, XEXP (x, 0), ysize, y, c);\n+    return memrefs_conflict_p (-1, XEXP (x, 0), ysize, y, c);\n   if (GET_CODE (y) == AND && GET_CODE (XEXP (y, 1)) == CONST_INT)\n-    return memrefs_conflict_p (xsize, x, 0, XEXP (y, 0), c);\n+    {\n+      /* XXX: If we are indexing far enough into the array/structure, we\n+\t may yet be able to determine that we can not overlap.  But we \n+\t also need to that we are far enough from the end not to overlap\n+\t a following reference, so we do nothing for now.  */\n+      return memrefs_conflict_p (xsize, x, -1, XEXP (y, 0), c);\n+    }\n \n   if (CONSTANT_P (x))\n     {\n       if (GET_CODE (x) == CONST_INT && GET_CODE (y) == CONST_INT)\n \t{\n \t  c += (INTVAL (y) - INTVAL (x));\n-\t  return (xsize == 0 || ysize == 0\n+\t  return (xsize <= 0 || ysize <= 0\n \t\t  || (c >= 0 && xsize > c) || (c < 0 && ysize+c > 0));\n \t}\n \n@@ -730,9 +747,10 @@ memrefs_conflict_p (xsize, x, ysize, y, c)\n \t\t\t\t   canon_rtx (XEXP (y, 0)), c);\n \n       if (CONSTANT_P (y))\n-\treturn (rtx_equal_for_memref_p (x, y)\n-\t\t&& (xsize == 0 || ysize == 0\n-\t\t    || (c >= 0 && xsize > c) || (c < 0 && ysize+c > 0)));\n+\treturn (xsize < 0 || ysize < 0\n+\t\t|| (rtx_equal_for_memref_p (x, y)\n+\t\t    && (xsize == 0 || ysize == 0\n+\t\t        || (c >= 0 && xsize > c) || (c < 0 && ysize+c > 0))));\n \n       return 1;\n     }"}]}