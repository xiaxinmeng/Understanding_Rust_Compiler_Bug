{"sha": "88d3b7f03d06f58d34f4b8fbaa25e469bec792c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhkM2I3ZjAzZDA2ZjU4ZDM0ZjRiOGZiYWEyNWU0NjliZWM3OTJjMQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-26T01:53:32Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-26T01:53:32Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r835", "tree": {"sha": "919ab141dbbcbbd954000e303d409f80896ee530", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/919ab141dbbcbbd954000e303d409f80896ee530"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88d3b7f03d06f58d34f4b8fbaa25e469bec792c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88d3b7f03d06f58d34f4b8fbaa25e469bec792c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88d3b7f03d06f58d34f4b8fbaa25e469bec792c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88d3b7f03d06f58d34f4b8fbaa25e469bec792c1/comments", "author": null, "committer": null, "parents": [{"sha": "a8481f2b7e0aaf2b3aa6cd334e56adbfea51144d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8481f2b7e0aaf2b3aa6cd334e56adbfea51144d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8481f2b7e0aaf2b3aa6cd334e56adbfea51144d"}], "stats": {"total": 19, "additions": 14, "deletions": 5}, "files": [{"sha": "5629ba90a66c27c9e278dc333cc25bf1b84fe390", "filename": "gcc/expr.c", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d3b7f03d06f58d34f4b8fbaa25e469bec792c1/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d3b7f03d06f58d34f4b8fbaa25e469bec792c1/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=88d3b7f03d06f58d34f4b8fbaa25e469bec792c1", "patch": "@@ -6490,7 +6490,7 @@ do_store_flag (exp, target, mode, only_cheap)\n \n /* INDEX is the value being switched on, with the lowest value\n    in the table already subtracted.\n-   MODE is its expected mode (needed if INDEX is ever constant).\n+   MODE is its expected mode (needed if INDEX is constant).\n    RANGE is the length of the jump table.\n    TABLE_LABEL is a CODE_LABEL rtx for the table itself.\n \n@@ -6504,13 +6504,22 @@ do_tablejump (index, mode, range, table_label, default_label)\n {\n   register rtx temp, vector;\n \n-  /* Code below assumes that MODE is Pmode,\n-     but I think that is a mistake.  Let's see if that is true.  */\n-  if (mode != Pmode)\n-    abort ();\n+  /* Do an unsigned comparison (in the proper mode) between the index\n+     expression and the value which represents the length of the range.\n+     Since we just finished subtracting the lower bound of the range\n+     from the index expression, this comparison allows us to simultaneously\n+     check that the original index expression value is both greater than\n+     or equal to the minimum value of the range and less than or equal to\n+     the maximum value of the range.  */\n \n   emit_cmp_insn (range, index, LTU, 0, mode, 0, 0);\n   emit_jump_insn (gen_bltu (default_label));\n+\n+  /* If index is in range, it must fit in Pmode.\n+     Convert to Pmode so we can index with it.  */\n+  if (mode != Pmode)\n+    index = convert_to_mode (Pmode, index, 1);\n+\n   /* If flag_force_addr were to affect this address\n      it could interfere with the tricky assumptions made\n      about addresses that contain label-refs,"}]}