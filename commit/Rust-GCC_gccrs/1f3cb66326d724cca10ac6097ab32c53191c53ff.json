{"sha": "1f3cb66326d724cca10ac6097ab32c53191c53ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYzY2I2NjMyNmQ3MjRjY2ExMGFjNjA5N2FiMzJjNTMxOTFjNTNmZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-05-16T11:50:44Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-05-16T11:50:44Z"}, "message": "Handle vector boolean types when calculating the SLP unroll factor\n\nThe SLP unrolling factor is calculated by finding the smallest\nscalar type for each SLP statement and taking the number of required\nlanes from the vector versions of those scalar types.  E.g. for an\nint32->int64 conversion, it's the vector of int32s rather than the\nvector of int64s that determines the unroll factor.\n\nWe rely on tree-vect-patterns.c to replace boolean operations like:\n\n   bool a, b, c;\n   a = b & c;\n\nwith integer operations of whatever the best size is in context.\nE.g. if b and c are fed by comparisons of ints, a, b and c will become\nthe appropriate size for an int comparison.  For most targets this means\nthat a, b and c will end up as int-sized themselves, but on targets like\nSVE and AVX512 with packed vector booleans, they'll instead become a\nsmall bitfield like :1, padded to a byte for memory purposes.\nThe SLP code would then take these scalar types and try to calculate\nthe vector type for them, causing the unroll factor to be much higher\nthan necessary.\n\nThis patch tries to make the SLP code use the same approach as the\nloop vectorizer, by splitting out the code that calculates the\nstatement vector type and the vector type that should be used for\nthe number of units.\n\n2018-05-16  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree-vectorizer.h (vect_get_vector_types_for_stmt): Declare.\n\t(vect_get_mask_type_for_stmt): Likewise.\n\t* tree-vect-slp.c (vect_two_operations_perm_ok_p): New function,\n\tsplit out from...\n\t(vect_build_slp_tree_1): ...here.  Use vect_get_vector_types_for_stmt\n\tto determine the statement's vector type and the vector type that\n\tshould be used for calculating nunits.  Deal with cases in which\n\tthe type has to be deferred.\n\t(vect_slp_analyze_node_operations): Use vect_get_vector_types_for_stmt\n\tand vect_get_mask_type_for_stmt to calculate STMT_VINFO_VECTYPE.\n\t* tree-vect-loop.c (vect_determine_vf_for_stmt_1)\n\t(vect_determine_vf_for_stmt): New functions, split out from...\n\t(vect_determine_vectorization_factor): ...here.\n\t* tree-vect-stmts.c (vect_get_vector_types_for_stmt)\n\t(vect_get_mask_type_for_stmt): New functions, split out from\n\tvect_determine_vectorization_factor.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/vcond_10.c: New test.\n\t* gcc.target/aarch64/sve/vcond_10_run.c: Likewise.\n\t* gcc.target/aarch64/sve/vcond_11.c: Likewise.\n\t* gcc.target/aarch64/sve/vcond_11_run.c: Likewise.\n\nFrom-SVN: r260287", "tree": {"sha": "1694c0be101b9998ee5b4b8a8082de6d8c95c76b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1694c0be101b9998ee5b4b8a8082de6d8c95c76b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f3cb66326d724cca10ac6097ab32c53191c53ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f3cb66326d724cca10ac6097ab32c53191c53ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f3cb66326d724cca10ac6097ab32c53191c53ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f3cb66326d724cca10ac6097ab32c53191c53ff/comments", "author": null, "committer": null, "parents": [{"sha": "c448fedea9abae497aaebccf55d1b1db2c3e5593", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c448fedea9abae497aaebccf55d1b1db2c3e5593", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c448fedea9abae497aaebccf55d1b1db2c3e5593"}], "stats": {"total": 1110, "additions": 637, "deletions": 473}, "files": [{"sha": "95e966a19360f7c07e8a1b0aed87907f0b43f40f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3cb66326d724cca10ac6097ab32c53191c53ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3cb66326d724cca10ac6097ab32c53191c53ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f3cb66326d724cca10ac6097ab32c53191c53ff", "patch": "@@ -1,3 +1,22 @@\n+2018-05-16  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-vectorizer.h (vect_get_vector_types_for_stmt): Declare.\n+\t(vect_get_mask_type_for_stmt): Likewise.\n+\t* tree-vect-slp.c (vect_two_operations_perm_ok_p): New function,\n+\tsplit out from...\n+\t(vect_build_slp_tree_1): ...here.  Use vect_get_vector_types_for_stmt\n+\tto determine the statement's vector type and the vector type that\n+\tshould be used for calculating nunits.  Deal with cases in which\n+\tthe type has to be deferred.\n+\t(vect_slp_analyze_node_operations): Use vect_get_vector_types_for_stmt\n+\tand vect_get_mask_type_for_stmt to calculate STMT_VINFO_VECTYPE.\n+\t* tree-vect-loop.c (vect_determine_vf_for_stmt_1)\n+\t(vect_determine_vf_for_stmt): New functions, split out from...\n+\t(vect_determine_vectorization_factor): ...here.\n+\t* tree-vect-stmts.c (vect_get_vector_types_for_stmt)\n+\t(vect_get_mask_type_for_stmt): New functions, split out from\n+\tvect_determine_vectorization_factor.\n+\n 2018-05-16  Richard Biener  <rguenther@suse.de>\n \n \t* tree-cfg.c (verify_gimple_assign_ternary): Properly"}, {"sha": "7e32f600729002bad380b0f585959fae694bc5da", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3cb66326d724cca10ac6097ab32c53191c53ff/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3cb66326d724cca10ac6097ab32c53191c53ff/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1f3cb66326d724cca10ac6097ab32c53191c53ff", "patch": "@@ -1,3 +1,10 @@\n+2018-05-16  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gcc.target/aarch64/sve/vcond_10.c: New test.\n+\t* gcc.target/aarch64/sve/vcond_10_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/vcond_11.c: Likewise.\n+\t* gcc.target/aarch64/sve/vcond_11_run.c: Likewise.\n+\n 2018-05-15  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/85753"}, {"sha": "76babbd554b920f0118a8fa50428658c31db49ec", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_10.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3cb66326d724cca10ac6097ab32c53191c53ff/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3cb66326d724cca10ac6097ab32c53191c53ff/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_10.c?ref=1f3cb66326d724cca10ac6097ab32c53191c53ff", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -march=armv8-a+sve\" } */\n+\n+#include <stdint.h>\n+\n+#define DEF_LOOP(TYPE)\t\t\t\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+  test_##TYPE (TYPE *a, TYPE a1, TYPE a2, TYPE a3, TYPE a4, int n)\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; i += 2)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\ta[i] = a[i] >= 1 && a[i] != 3 ? a1 : a2;\t\t\t\\\n+\ta[i + 1] = a[i + 1] >= 1 && a[i + 1] != 3 ? a3 : a4;\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define FOR_EACH_TYPE(T) \\\n+  T (int8_t) \\\n+  T (uint8_t) \\\n+  T (int16_t) \\\n+  T (uint16_t) \\\n+  T (int32_t) \\\n+  T (uint32_t) \\\n+  T (int64_t) \\\n+  T (uint64_t) \\\n+  T (_Float16) \\\n+  T (float) \\\n+  T (double)\n+\n+FOR_EACH_TYPE (DEF_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tld1b\\t} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tsel\\tz[0-9]} 11 } } */"}, {"sha": "3e841f131215b5e8f7fea7532d1d5aeb9bd531b1", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_10_run.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3cb66326d724cca10ac6097ab32c53191c53ff/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_10_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3cb66326d724cca10ac6097ab32c53191c53ff/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_10_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_10_run.c?ref=1f3cb66326d724cca10ac6097ab32c53191c53ff", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize -march=armv8-a+sve\" } */\n+\n+#include \"vcond_10.c\"\n+\n+#define N 133\n+\n+#define TEST_LOOP(TYPE)\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE a[N];\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\t\\\n+      a[i] = i % 7;\t\t\t\t\t\t\t\\\n+    test_##TYPE (a, 10, 11, 12, 13, N);\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\t\\\n+      if (a[i] != 10 + (i & 1) * 2 + (i % 7 == 0 || i % 7 == 3))\t\\\n+\t__builtin_abort ();\t\t\t\t\t\t\\\n+  }\n+\n+int\n+main (void)\n+{\n+  FOR_EACH_TYPE (TEST_LOOP);\n+  return 0;\n+}"}, {"sha": "3c9e340475a3f16035934f3a23f1d9837b1aa971", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_11.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3cb66326d724cca10ac6097ab32c53191c53ff/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3cb66326d724cca10ac6097ab32c53191c53ff/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_11.c?ref=1f3cb66326d724cca10ac6097ab32c53191c53ff", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -march=armv8-a+sve\" } */\n+\n+#include <stdint.h>\n+\n+#define DEF_LOOP(TYPE)\t\t\t\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+  test_##TYPE (int *restrict a, TYPE *restrict b, int a1, int a2,\t\\\n+\t       int a3, int a4, int n)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; i += 2)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\ta[i] = a[i] >= 1 & b[i] != 3 ? a1 : a2;\t\t\t\t\\\n+\ta[i + 1] = a[i + 1] >= 1 & b[i + 1] != 3 ? a3 : a4;\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define FOR_EACH_TYPE(T) \\\n+  T (int8_t) \\\n+  T (uint8_t) \\\n+  T (int16_t) \\\n+  T (uint16_t) \\\n+  T (int64_t) \\\n+  T (uint64_t) \\\n+  T (double)\n+\n+FOR_EACH_TYPE (DEF_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tld1b\\t} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\t} 2 } } */\n+/* 4 for each 8-bit function, 2 for each 16-bit function, 1 for\n+   each 64-bit function.  */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 15 } } */\n+/* 3 64-bit functions * 2 64-bit vectors per 32-bit vector.  */\n+/* { dg-final { scan-assembler-times {\\tld1d\\t} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tsel\\tz[0-9]} 15 } } */"}, {"sha": "9a4edb81448296eaa9186ad8103d1d06a3564fe5", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_11_run.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3cb66326d724cca10ac6097ab32c53191c53ff/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_11_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3cb66326d724cca10ac6097ab32c53191c53ff/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_11_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_11_run.c?ref=1f3cb66326d724cca10ac6097ab32c53191c53ff", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize -march=armv8-a+sve\" } */\n+\n+#include \"vcond_11.c\"\n+\n+#define N 133\n+\n+#define TEST_LOOP(TYPE)\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int a[N];\t\t\t\t\t\t\t\t\\\n+    TYPE b[N];\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\ta[i] = i % 5;\t\t\t\t\t\t\t\\\n+\tb[i] = i % 7;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    test_##TYPE (a, b, 10, 11, 12, 13, N);\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\t\\\n+      if (a[i] != 10 + (i & 1) * 2 + (i % 5 == 0 || i % 7 == 3))\t\\\n+\t__builtin_abort ();\t\t\t\t\t\t\\\n+  }\n+\n+int\n+main (void)\n+{\n+  FOR_EACH_TYPE (TEST_LOOP);\n+  return 0;\n+}"}, {"sha": "fb217b8597445164217dd1f1c2ca922a24d934f8", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 113, "deletions": 416, "changes": 529, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3cb66326d724cca10ac6097ab32c53191c53ff/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3cb66326d724cca10ac6097ab32c53191c53ff/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=1f3cb66326d724cca10ac6097ab32c53191c53ff", "patch": "@@ -155,6 +155,108 @@ along with GCC; see the file COPYING3.  If not see\n \n static void vect_estimate_min_profitable_iters (loop_vec_info, int *, int *);\n \n+/* Subroutine of vect_determine_vf_for_stmt that handles only one\n+   statement.  VECTYPE_MAYBE_SET_P is true if STMT_VINFO_VECTYPE\n+   may already be set for general statements (not just data refs).  */\n+\n+static bool\n+vect_determine_vf_for_stmt_1 (stmt_vec_info stmt_info,\n+\t\t\t      bool vectype_maybe_set_p,\n+\t\t\t      poly_uint64 *vf,\n+\t\t\t      vec<stmt_vec_info > *mask_producers)\n+{\n+  gimple *stmt = stmt_info->stmt;\n+\n+  if ((!STMT_VINFO_RELEVANT_P (stmt_info)\n+       && !STMT_VINFO_LIVE_P (stmt_info))\n+      || gimple_clobber_p (stmt))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"skip.\\n\");\n+      return true;\n+    }\n+\n+  tree stmt_vectype, nunits_vectype;\n+  if (!vect_get_vector_types_for_stmt (stmt_info, &stmt_vectype,\n+\t\t\t\t       &nunits_vectype))\n+    return false;\n+\n+  if (stmt_vectype)\n+    {\n+      if (STMT_VINFO_VECTYPE (stmt_info))\n+\t/* The only case when a vectype had been already set is for stmts\n+\t   that contain a data ref, or for \"pattern-stmts\" (stmts generated\n+\t   by the vectorizer to represent/replace a certain idiom).  */\n+\tgcc_assert ((STMT_VINFO_DATA_REF (stmt_info)\n+\t\t     || vectype_maybe_set_p)\n+\t\t    && STMT_VINFO_VECTYPE (stmt_info) == stmt_vectype);\n+      else if (stmt_vectype == boolean_type_node)\n+\tmask_producers->safe_push (stmt_info);\n+      else\n+\tSTMT_VINFO_VECTYPE (stmt_info) = stmt_vectype;\n+    }\n+\n+  if (nunits_vectype)\n+    vect_update_max_nunits (vf, nunits_vectype);\n+\n+  return true;\n+}\n+\n+/* Subroutine of vect_determine_vectorization_factor.  Set the vector\n+   types of STMT_INFO and all attached pattern statements and update\n+   the vectorization factor VF accordingly.  If some of the statements\n+   produce a mask result whose vector type can only be calculated later,\n+   add them to MASK_PRODUCERS.  Return true on success or false if\n+   something prevented vectorization.  */\n+\n+static bool\n+vect_determine_vf_for_stmt (stmt_vec_info stmt_info, poly_uint64 *vf,\n+\t\t\t    vec<stmt_vec_info > *mask_producers)\n+{\n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location, \"==> examining statement: \");\n+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_info->stmt, 0);\n+    }\n+  if (!vect_determine_vf_for_stmt_1 (stmt_info, false, vf, mask_producers))\n+    return false;\n+\n+  if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n+      && STMT_VINFO_RELATED_STMT (stmt_info))\n+    {\n+      stmt_info = vinfo_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info));\n+\n+      /* If a pattern statement has def stmts, analyze them too.  */\n+      gimple *pattern_def_seq = STMT_VINFO_PATTERN_DEF_SEQ (stmt_info);\n+      for (gimple_stmt_iterator si = gsi_start (pattern_def_seq);\n+\t   !gsi_end_p (si); gsi_next (&si))\n+\t{\n+\t  stmt_vec_info def_stmt_info = vinfo_for_stmt (gsi_stmt (si));\n+\t  if (dump_enabled_p ())\n+\t    {\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"==> examining pattern def stmt: \");\n+\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM,\n+\t\t\t\tdef_stmt_info->stmt, 0);\n+\t    }\n+\t  if (!vect_determine_vf_for_stmt_1 (def_stmt_info, true,\n+\t\t\t\t\t     vf, mask_producers))\n+\t    return false;\n+\t}\n+\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"==> examining pattern statement: \");\n+\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt_info->stmt, 0);\n+\t}\n+      if (!vect_determine_vf_for_stmt_1 (stmt_info, true, vf, mask_producers))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n /* Function vect_determine_vectorization_factor\n \n    Determine the vectorization factor (VF).  VF is the number of data elements\n@@ -192,12 +294,6 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n   tree vectype;\n   stmt_vec_info stmt_info;\n   unsigned i;\n-  HOST_WIDE_INT dummy;\n-  gimple *stmt, *pattern_stmt = NULL;\n-  gimple_seq pattern_def_seq = NULL;\n-  gimple_stmt_iterator pattern_def_si = gsi_none ();\n-  bool analyze_pattern_stmt = false;\n-  bool bool_result;\n   auto_vec<stmt_vec_info> mask_producers;\n \n   if (dump_enabled_p ())\n@@ -269,304 +365,13 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t    }\n \t}\n \n-      for (gimple_stmt_iterator si = gsi_start_bb (bb);\n-\t   !gsi_end_p (si) || analyze_pattern_stmt;)\n-        {\n-          tree vf_vectype;\n-\n-          if (analyze_pattern_stmt)\n-\t    stmt = pattern_stmt;\n-          else\n-            stmt = gsi_stmt (si);\n-\n-          stmt_info = vinfo_for_stmt (stmt);\n-\n-\t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-                               \"==> examining statement: \");\n-\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n-\t    }\n-\n-\t  gcc_assert (stmt_info);\n-\n-\t  /* Skip stmts which do not need to be vectorized.  */\n-\t  if ((!STMT_VINFO_RELEVANT_P (stmt_info)\n-\t       && !STMT_VINFO_LIVE_P (stmt_info))\n-\t      || gimple_clobber_p (stmt))\n-            {\n-              if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n-                  && (pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info))\n-                  && (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_stmt))\n-                      || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_stmt))))\n-                {\n-                  stmt = pattern_stmt;\n-                  stmt_info = vinfo_for_stmt (pattern_stmt);\n-                  if (dump_enabled_p ())\n-                    {\n-                      dump_printf_loc (MSG_NOTE, vect_location,\n-                                       \"==> examining pattern statement: \");\n-                      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n-                    }\n-                }\n-              else\n-\t        {\n-\t          if (dump_enabled_p ())\n-\t            dump_printf_loc (MSG_NOTE, vect_location, \"skip.\\n\");\n-                  gsi_next (&si);\n-\t          continue;\n-                }\n-\t    }\n-          else if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n-                   && (pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info))\n-                   && (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_stmt))\n-                       || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_stmt))))\n-            analyze_pattern_stmt = true;\n-\n-\t  /* If a pattern statement has def stmts, analyze them too.  */\n-\t  if (is_pattern_stmt_p (stmt_info))\n-\t    {\n-\t      if (pattern_def_seq == NULL)\n-\t\t{\n-\t\t  pattern_def_seq = STMT_VINFO_PATTERN_DEF_SEQ (stmt_info);\n-\t\t  pattern_def_si = gsi_start (pattern_def_seq);\n-\t\t}\n-\t      else if (!gsi_end_p (pattern_def_si))\n-\t\tgsi_next (&pattern_def_si);\n-\t      if (pattern_def_seq != NULL)\n-\t\t{\n-\t\t  gimple *pattern_def_stmt = NULL;\n-\t\t  stmt_vec_info pattern_def_stmt_info = NULL;\n-\n-\t\t  while (!gsi_end_p (pattern_def_si))\n-\t\t    {\n-\t\t      pattern_def_stmt = gsi_stmt (pattern_def_si);\n-\t\t      pattern_def_stmt_info\n-\t\t\t= vinfo_for_stmt (pattern_def_stmt);\n-\t\t      if (STMT_VINFO_RELEVANT_P (pattern_def_stmt_info)\n-\t\t\t  || STMT_VINFO_LIVE_P (pattern_def_stmt_info))\n-\t\t\tbreak;\n-\t\t      gsi_next (&pattern_def_si);\n-\t\t    }\n-\n-\t\t  if (!gsi_end_p (pattern_def_si))\n-\t\t    {\n-\t\t      if (dump_enabled_p ())\n-\t\t\t{\n-\t\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n-                                           \"==> examining pattern def stmt: \");\n-\t\t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM,\n-                                            pattern_def_stmt, 0);\n-\t\t\t}\n-\n-\t\t      stmt = pattern_def_stmt;\n-\t\t      stmt_info = pattern_def_stmt_info;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      pattern_def_si = gsi_none ();\n-\t\t      analyze_pattern_stmt = false;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\tanalyze_pattern_stmt = false;\n-\t    }\n-\n-\t  if (gimple_get_lhs (stmt) == NULL_TREE\n-\t      /* MASK_STORE has no lhs, but is ok.  */\n-\t      && (!is_gimple_call (stmt)\n-\t\t  || !gimple_call_internal_p (stmt)\n-\t\t  || gimple_call_internal_fn (stmt) != IFN_MASK_STORE))\n-\t    {\n-\t      if (is_gimple_call (stmt))\n-\t\t{\n-\t\t  /* Ignore calls with no lhs.  These must be calls to\n-\t\t     #pragma omp simd functions, and what vectorization factor\n-\t\t     it really needs can't be determined until\n-\t\t     vectorizable_simd_clone_call.  */\n-\t\t  if (!analyze_pattern_stmt && gsi_end_p (pattern_def_si))\n-\t\t    {\n-\t\t      pattern_def_seq = NULL;\n-\t\t      gsi_next (&si);\n-\t\t    }\n-\t\t  continue;\n-\t\t}\n-\t      if (dump_enabled_p ())\n-\t\t{\n-\t          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                   \"not vectorized: irregular stmt.\");\n-\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION,  TDF_SLIM, stmt,\n-                                    0);\n-\t\t}\n-\t      return false;\n-\t    }\n-\n-\t  if (VECTOR_MODE_P (TYPE_MODE (gimple_expr_type (stmt))))\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t        {\n-\t          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                   \"not vectorized: vector stmt in loop:\");\n-\t          dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-\t        }\n-\t      return false;\n-\t    }\n-\n-\t  bool_result = false;\n-\n-\t  if (STMT_VINFO_VECTYPE (stmt_info))\n-\t    {\n-\t      /* The only case when a vectype had been already set is for stmts\n-\t         that contain a dataref, or for \"pattern-stmts\" (stmts\n-\t\t generated by the vectorizer to represent/replace a certain\n-\t\t idiom).  */\n-\t      gcc_assert (STMT_VINFO_DATA_REF (stmt_info)\n-\t\t\t  || is_pattern_stmt_p (stmt_info)\n-\t\t\t  || !gsi_end_p (pattern_def_si));\n-\t      vectype = STMT_VINFO_VECTYPE (stmt_info);\n-\t    }\n-\t  else\n-\t    {\n-\t      gcc_assert (!STMT_VINFO_DATA_REF (stmt_info));\n-\t      if (gimple_call_internal_p (stmt, IFN_MASK_STORE))\n-\t\tscalar_type = TREE_TYPE (gimple_call_arg (stmt, 3));\n-\t      else\n-\t\tscalar_type = TREE_TYPE (gimple_get_lhs (stmt));\n-\n-\t      /* Bool ops don't participate in vectorization factor\n-\t\t computation.  For comparison use compared types to\n-\t\t compute a factor.  */\n-\t      if (VECT_SCALAR_BOOLEAN_TYPE_P (scalar_type)\n-\t\t  && is_gimple_assign (stmt)\n-\t\t  && gimple_assign_rhs_code (stmt) != COND_EXPR)\n-\t\t{\n-\t\t  if (STMT_VINFO_RELEVANT_P (stmt_info)\n-\t\t      || STMT_VINFO_LIVE_P (stmt_info))\n-\t\t    mask_producers.safe_push (stmt_info);\n-\t\t  bool_result = true;\n-\n-\t\t  if (TREE_CODE_CLASS (gimple_assign_rhs_code (stmt))\n-\t\t      == tcc_comparison\n-\t\t      && !VECT_SCALAR_BOOLEAN_TYPE_P\n-\t\t\t    (TREE_TYPE (gimple_assign_rhs1 (stmt))))\n-\t\t    scalar_type = TREE_TYPE (gimple_assign_rhs1 (stmt));\n-\t\t  else\n-\t\t    {\n-\t\t      if (!analyze_pattern_stmt && gsi_end_p (pattern_def_si))\n-\t\t\t{\n-\t\t\t  pattern_def_seq = NULL;\n-\t\t\t  gsi_next (&si);\n-\t\t\t}\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\n-\t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n-                                   \"get vectype for scalar type:  \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, scalar_type);\n-                  dump_printf (MSG_NOTE, \"\\n\");\n-\t\t}\n-\t      vectype = get_vectype_for_scalar_type (scalar_type);\n-\t      if (!vectype)\n-\t\t{\n-\t\t  if (dump_enabled_p ())\n-\t\t    {\n-\t\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                       \"not vectorized: unsupported \"\n-                                       \"data-type \");\n-\t\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-                                         scalar_type);\n-                      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t\t    }\n-\t\t  return false;\n-\t\t}\n-\n-\t      if (!bool_result)\n-\t\tSTMT_VINFO_VECTYPE (stmt_info) = vectype;\n-\n-\t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_NOTE, vect_location, \"vectype: \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, vectype);\n-                  dump_printf (MSG_NOTE, \"\\n\");\n-\t\t}\n-            }\n-\n-\t  /* Don't try to compute VF out scalar types if we stmt\n-\t     produces boolean vector.  Use result vectype instead.  */\n-\t  if (VECTOR_BOOLEAN_TYPE_P (vectype))\n-\t    vf_vectype = vectype;\n-\t  else\n-\t    {\n-\t      /* The vectorization factor is according to the smallest\n-\t\t scalar type (or the largest vector size, but we only\n-\t\t support one vector size per loop).  */\n-\t      if (!bool_result)\n-\t\tscalar_type = vect_get_smallest_scalar_type (stmt, &dummy,\n-\t\t\t\t\t\t\t     &dummy);\n-\t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t   \"get vectype for scalar type:  \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, scalar_type);\n-\t\t  dump_printf (MSG_NOTE, \"\\n\");\n-\t\t}\n-\t      vf_vectype = get_vectype_for_scalar_type (scalar_type);\n-\t    }\n-\t  if (!vf_vectype)\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                   \"not vectorized: unsupported data-type \");\n-\t\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-                                     scalar_type);\n-                  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t\t}\n-\t      return false;\n-\t    }\n-\n-\t  if (maybe_ne (GET_MODE_SIZE (TYPE_MODE (vectype)),\n-\t\t\tGET_MODE_SIZE (TYPE_MODE (vf_vectype))))\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                   \"not vectorized: different sized vector \"\n-                                   \"types in statement, \");\n-\t\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-                                     vectype);\n-\t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n-\t\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-                                     vf_vectype);\n-                  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t\t}\n-\t      return false;\n-\t    }\n-\n-\t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location, \"vectype: \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, vf_vectype);\n-              dump_printf (MSG_NOTE, \"\\n\");\n-\t    }\n-\n-\t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location, \"nunits = \");\n-\t      dump_dec (MSG_NOTE, TYPE_VECTOR_SUBPARTS (vf_vectype));\n-\t      dump_printf (MSG_NOTE, \"\\n\");\n-\t    }\n-\n-\t  vect_update_max_nunits (&vectorization_factor, vf_vectype);\n-\n-\t  if (!analyze_pattern_stmt && gsi_end_p (pattern_def_si))\n-\t    {\n-\t      pattern_def_seq = NULL;\n-\t      gsi_next (&si);\n-\t    }\n+      for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n+\t   gsi_next (&si))\n+\t{\n+\t  stmt_info = vinfo_for_stmt (gsi_stmt (si));\n+\t  if (!vect_determine_vf_for_stmt (stmt_info, &vectorization_factor,\n+\t\t\t\t\t   &mask_producers))\n+\t    return false;\n         }\n     }\n \n@@ -589,119 +394,11 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \n   for (i = 0; i < mask_producers.length (); i++)\n     {\n-      tree mask_type = NULL;\n-\n-      stmt = STMT_VINFO_STMT (mask_producers[i]);\n-\n-      if (is_gimple_assign (stmt)\n-\t  && TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)) == tcc_comparison\n-\t  && !VECT_SCALAR_BOOLEAN_TYPE_P\n-\t\t\t\t      (TREE_TYPE (gimple_assign_rhs1 (stmt))))\n-\t{\n-\t  scalar_type = TREE_TYPE (gimple_assign_rhs1 (stmt));\n-\t  mask_type = get_mask_type_for_scalar_type (scalar_type);\n-\n-\t  if (!mask_type)\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"not vectorized: unsupported mask\\n\");\n-\t      return false;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  tree rhs;\n-\t  ssa_op_iter iter;\n-\t  gimple *def_stmt;\n-\t  enum vect_def_type dt;\n-\n-\t  FOR_EACH_SSA_TREE_OPERAND (rhs, stmt, iter, SSA_OP_USE)\n-\t    {\n-\t      if (!vect_is_simple_use (rhs, mask_producers[i]->vinfo,\n-\t\t\t\t       &def_stmt, &dt, &vectype))\n-\t\t{\n-\t\t  if (dump_enabled_p ())\n-\t\t    {\n-\t\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t       \"not vectorized: can't compute mask type \"\n-\t\t\t\t       \"for statement, \");\n-\t\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION,  TDF_SLIM, stmt,\n-\t\t\t\t\t0);\n-\t\t    }\n-\t\t  return false;\n-\t\t}\n-\n-\t      /* No vectype probably means external definition.\n-\t\t Allow it in case there is another operand which\n-\t\t allows to determine mask type.  */\n-\t      if (!vectype)\n-\t\tcontinue;\n-\n-\t      if (!mask_type)\n-\t\tmask_type = vectype;\n-\t      else if (maybe_ne (TYPE_VECTOR_SUBPARTS (mask_type),\n-\t\t\t\t TYPE_VECTOR_SUBPARTS (vectype)))\n-\t\t{\n-\t\t  if (dump_enabled_p ())\n-\t\t    {\n-\t\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t       \"not vectorized: different sized masks \"\n-\t\t\t\t       \"types in statement, \");\n-\t\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t\t mask_type);\n-\t\t      dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n-\t\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t\t vectype);\n-\t\t      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t\t    }\n-\t\t  return false;\n-\t\t}\n-\t      else if (VECTOR_BOOLEAN_TYPE_P (mask_type)\n-\t\t       != VECTOR_BOOLEAN_TYPE_P (vectype))\n-\t\t{\n-\t\t  if (dump_enabled_p ())\n-\t\t    {\n-\t\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t       \"not vectorized: mixed mask and \"\n-\t\t\t\t       \"nonmask vector types in statement, \");\n-\t\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t\t mask_type);\n-\t\t      dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n-\t\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t\t vectype);\n-\t\t      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t\t    }\n-\t\t  return false;\n-\t\t}\n-\t    }\n-\n-\t  /* We may compare boolean value loaded as vector of integers.\n-\t     Fix mask_type in such case.  */\n-\t  if (mask_type\n-\t      && !VECTOR_BOOLEAN_TYPE_P (mask_type)\n-\t      && gimple_code (stmt) == GIMPLE_ASSIGN\n-\t      && TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)) == tcc_comparison)\n-\t    mask_type = build_same_sized_truth_vector_type (mask_type);\n-\t}\n-\n-      /* No mask_type should mean loop invariant predicate.\n-\t This is probably a subject for optimization in\n-\t if-conversion.  */\n+      stmt_info = mask_producers[i];\n+      tree mask_type = vect_get_mask_type_for_stmt (stmt_info);\n       if (!mask_type)\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t       \"not vectorized: can't compute mask type \"\n-\t\t\t       \"for statement, \");\n-\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION,  TDF_SLIM, stmt,\n-\t\t\t\t0);\n-\t    }\n-\t  return false;\n-\t}\n-\n-      STMT_VINFO_VECTYPE (mask_producers[i]) = mask_type;\n+\treturn false;\n+      STMT_VINFO_VECTYPE (stmt_info) = mask_type;\n     }\n \n   return true;"}, {"sha": "aa239b9c48c50ba8013553c220cb4f7d7578d8e8", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 64, "deletions": 57, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3cb66326d724cca10ac6097ab32c53191c53ff/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3cb66326d724cca10ac6097ab32c53191c53ff/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=1f3cb66326d724cca10ac6097ab32c53191c53ff", "patch": "@@ -608,6 +608,33 @@ vect_record_max_nunits (vec_info *vinfo, gimple *stmt, unsigned int group_size,\n   return true;\n }\n \n+/* STMTS is a group of GROUP_SIZE SLP statements in which some\n+   statements do the same operation as the first statement and in which\n+   the others do ALT_STMT_CODE.  Return true if we can take one vector\n+   of the first operation and one vector of the second and permute them\n+   to get the required result.  VECTYPE is the type of the vector that\n+   would be permuted.  */\n+\n+static bool\n+vect_two_operations_perm_ok_p (vec<gimple *> stmts, unsigned int group_size,\n+\t\t\t       tree vectype, tree_code alt_stmt_code)\n+{\n+  unsigned HOST_WIDE_INT count;\n+  if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant (&count))\n+    return false;\n+\n+  vec_perm_builder sel (count, count, 1);\n+  for (unsigned int i = 0; i < count; ++i)\n+    {\n+      unsigned int elt = i;\n+      if (gimple_assign_rhs_code (stmts[i % group_size]) == alt_stmt_code)\n+\telt += count;\n+      sel.quick_push (elt);\n+    }\n+  vec_perm_indices indices (sel, 2, count);\n+  return can_vec_perm_const_p (TYPE_MODE (vectype), indices);\n+}\n+\n /* Verify if the scalar stmts STMTS are isomorphic, require data\n    permutation or are of unsupported types of operation.  Return\n    true if they are, otherwise return false and indicate in *MATCHES\n@@ -636,17 +663,17 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n   enum tree_code first_cond_code = ERROR_MARK;\n   tree lhs;\n   bool need_same_oprnds = false;\n-  tree vectype = NULL_TREE, scalar_type, first_op1 = NULL_TREE;\n+  tree vectype = NULL_TREE, first_op1 = NULL_TREE;\n   optab optab;\n   int icode;\n   machine_mode optab_op2_mode;\n   machine_mode vec_mode;\n-  HOST_WIDE_INT dummy;\n   gimple *first_load = NULL, *prev_first_load = NULL;\n \n   /* For every stmt in NODE find its def stmt/s.  */\n   FOR_EACH_VEC_ELT (stmts, i, stmt)\n     {\n+      stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n       swap[i] = 0;\n       matches[i] = false;\n \n@@ -685,15 +712,19 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t  return false;\n \t}\n \n-      scalar_type = vect_get_smallest_scalar_type (stmt, &dummy, &dummy);\n-      vectype = get_vectype_for_scalar_type (scalar_type);\n-      if (!vect_record_max_nunits (vinfo, stmt, group_size, vectype,\n-\t\t\t\t   max_nunits))\n+      tree nunits_vectype;\n+      if (!vect_get_vector_types_for_stmt (stmt_info, &vectype,\n+\t\t\t\t\t   &nunits_vectype)\n+\t  || (nunits_vectype\n+\t      && !vect_record_max_nunits (vinfo, stmt, group_size,\n+\t\t\t\t\t  nunits_vectype, max_nunits)))\n \t{\n \t  /* Fatal mismatch.  */\n \t  matches[0] = false;\n-          return false;\n-        }\n+\t  return false;\n+\t}\n+\n+      gcc_assert (vectype);\n \n       if (gcall *call_stmt = dyn_cast <gcall *> (stmt))\n \t{\n@@ -730,6 +761,17 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t      || rhs_code == LROTATE_EXPR\n \t      || rhs_code == RROTATE_EXPR)\n \t    {\n+\t      if (vectype == boolean_type_node)\n+\t\t{\n+\t\t  if (dump_enabled_p ())\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"Build SLP failed: shift of a\"\n+\t\t\t\t     \" boolean.\\n\");\n+\t\t  /* Fatal mismatch.  */\n+\t\t  matches[0] = false;\n+\t\t  return false;\n+\t\t}\n+\n \t      vec_mode = TYPE_MODE (vectype);\n \n \t      /* First see if we have a vector/vector shift.  */\n@@ -973,29 +1015,12 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \n   /* If we allowed a two-operation SLP node verify the target can cope\n      with the permute we are going to use.  */\n-  poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   if (alt_stmt_code != ERROR_MARK\n       && TREE_CODE_CLASS (alt_stmt_code) != tcc_reference)\n     {\n-      unsigned HOST_WIDE_INT count;\n-      if (!nunits.is_constant (&count))\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"Build SLP failed: different operations \"\n-\t\t\t     \"not allowed with variable-length SLP.\\n\");\n-\t  return false;\n-\t}\n-      vec_perm_builder sel (count, count, 1);\n-      for (i = 0; i < count; ++i)\n-\t{\n-\t  unsigned int elt = i;\n-\t  if (gimple_assign_rhs_code (stmts[i % group_size]) == alt_stmt_code)\n-\t    elt += count;\n-\t  sel.quick_push (elt);\n-\t}\n-      vec_perm_indices indices (sel, 2, count);\n-      if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n+      if (vectype == boolean_type_node\n+\t  || !vect_two_operations_perm_ok_p (stmts, group_size,\n+\t\t\t\t\t     vectype, alt_stmt_code))\n \t{\n \t  for (i = 0; i < group_size; ++i)\n \t    if (gimple_assign_rhs_code (stmts[i]) == alt_stmt_code)\n@@ -2759,36 +2784,18 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n   if (bb_vinfo\n       && ! STMT_VINFO_DATA_REF (stmt_info))\n     {\n-      gcc_assert (PURE_SLP_STMT (stmt_info));\n-\n-      tree scalar_type = TREE_TYPE (gimple_get_lhs (stmt));\n-      if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"get vectype for scalar type:  \");\n-\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, scalar_type);\n-\t  dump_printf (MSG_NOTE, \"\\n\");\n-\t}\n-\n-      tree vectype = get_vectype_for_scalar_type (scalar_type);\n-      if (!vectype)\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t       \"not SLPed: unsupported data-type \");\n-\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t scalar_type);\n-\t      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t    }\n-\t  return false;\n-\t}\n-\n-      if (dump_enabled_p ())\n+      tree vectype, nunits_vectype;\n+      if (!vect_get_vector_types_for_stmt (stmt_info, &vectype,\n+\t\t\t\t\t   &nunits_vectype))\n+\t/* We checked this when building the node.  */\n+\tgcc_unreachable ();\n+      if (vectype == boolean_type_node)\n \t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location, \"vectype:  \");\n-\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, vectype);\n-\t  dump_printf (MSG_NOTE, \"\\n\");\n+\t  vectype = vect_get_mask_type_for_stmt (stmt_info);\n+\t  if (!vectype)\n+\t    /* vect_get_mask_type_for_stmt has already explained the\n+\t       failure.  */\n+\t    return false;\n \t}\n \n       gimple *sstmt;"}, {"sha": "0fd94105a562a37d2e70fb186bd4468171cb1c31", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 308, "deletions": 0, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3cb66326d724cca10ac6097ab32c53191c53ff/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3cb66326d724cca10ac6097ab32c53191c53ff/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=1f3cb66326d724cca10ac6097ab32c53191c53ff", "patch": "@@ -10520,3 +10520,311 @@ vect_gen_while_not (gimple_seq *seq, tree mask_type, tree start_index,\n   gimple_seq_add_stmt (seq, call);\n   return gimple_build (seq, BIT_NOT_EXPR, mask_type, tmp);\n }\n+\n+/* Try to compute the vector types required to vectorize STMT_INFO,\n+   returning true on success and false if vectorization isn't possible.\n+\n+   On success:\n+\n+   - Set *STMT_VECTYPE_OUT to:\n+     - NULL_TREE if the statement doesn't need to be vectorized;\n+     - boolean_type_node if the statement is a boolean operation whose\n+       vector type can only be determined once all the other vector types\n+       are known; and\n+     - the equivalent of STMT_VINFO_VECTYPE otherwise.\n+\n+   - Set *NUNITS_VECTYPE_OUT to the vector type that contains the maximum\n+     number of units needed to vectorize STMT_INFO, or NULL_TREE if the\n+     statement does not help to determine the overall number of units.  */\n+\n+bool\n+vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n+\t\t\t\ttree *stmt_vectype_out,\n+\t\t\t\ttree *nunits_vectype_out)\n+{\n+  gimple *stmt = stmt_info->stmt;\n+\n+  *stmt_vectype_out = NULL_TREE;\n+  *nunits_vectype_out = NULL_TREE;\n+\n+  if (gimple_get_lhs (stmt) == NULL_TREE\n+      /* MASK_STORE has no lhs, but is ok.  */\n+      && !gimple_call_internal_p (stmt, IFN_MASK_STORE))\n+    {\n+      if (is_a <gcall *> (stmt))\n+\t{\n+\t  /* Ignore calls with no lhs.  These must be calls to\n+\t     #pragma omp simd functions, and what vectorization factor\n+\t     it really needs can't be determined until\n+\t     vectorizable_simd_clone_call.  */\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"defer to SIMD clone analysis.\\n\");\n+\t  return true;\n+\t}\n+\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"not vectorized: irregular stmt.\");\n+\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+\t}\n+      return false;\n+    }\n+\n+  if (VECTOR_MODE_P (TYPE_MODE (gimple_expr_type (stmt))))\n+    {\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"not vectorized: vector stmt in loop:\");\n+\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+\t}\n+      return false;\n+    }\n+\n+  tree vectype;\n+  tree scalar_type = NULL_TREE;\n+  if (STMT_VINFO_VECTYPE (stmt_info))\n+    *stmt_vectype_out = vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  else\n+    {\n+      gcc_assert (!STMT_VINFO_DATA_REF (stmt_info));\n+      if (gimple_call_internal_p (stmt, IFN_MASK_STORE))\n+\tscalar_type = TREE_TYPE (gimple_call_arg (stmt, 3));\n+      else\n+\tscalar_type = TREE_TYPE (gimple_get_lhs (stmt));\n+\n+      /* Pure bool ops don't participate in number-of-units computation.\n+\t For comparisons use the types being compared.  */\n+      if (VECT_SCALAR_BOOLEAN_TYPE_P (scalar_type)\n+\t  && is_gimple_assign (stmt)\n+\t  && gimple_assign_rhs_code (stmt) != COND_EXPR)\n+\t{\n+\t  *stmt_vectype_out = boolean_type_node;\n+\n+\t  tree rhs1 = gimple_assign_rhs1 (stmt);\n+\t  if (TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)) == tcc_comparison\n+\t      && !VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (rhs1)))\n+\t    scalar_type = TREE_TYPE (rhs1);\n+\t  else\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"pure bool operation.\\n\");\n+\t      return true;\n+\t    }\n+\t}\n+\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"get vectype for scalar type:  \");\n+\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, scalar_type);\n+\t  dump_printf (MSG_NOTE, \"\\n\");\n+\t}\n+      vectype = get_vectype_for_scalar_type (scalar_type);\n+      if (!vectype)\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    {\n+\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t       \"not vectorized: unsupported data-type \");\n+\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\t scalar_type);\n+\t      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n+\t    }\n+\t  return false;\n+\t}\n+\n+      if (!*stmt_vectype_out)\n+\t*stmt_vectype_out = vectype;\n+\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_NOTE, vect_location, \"vectype: \");\n+\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, vectype);\n+\t  dump_printf (MSG_NOTE, \"\\n\");\n+\t}\n+    }\n+\n+  /* Don't try to compute scalar types if the stmt produces a boolean\n+     vector; use the existing vector type instead.  */\n+  tree nunits_vectype;\n+  if (VECTOR_BOOLEAN_TYPE_P (vectype))\n+    nunits_vectype = vectype;\n+  else\n+    {\n+      /* The number of units is set according to the smallest scalar\n+\t type (or the largest vector size, but we only support one\n+\t vector size per vectorization).  */\n+      if (*stmt_vectype_out != boolean_type_node)\n+\t{\n+\t  HOST_WIDE_INT dummy;\n+\t  scalar_type = vect_get_smallest_scalar_type (stmt, &dummy, &dummy);\n+\t}\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"get vectype for scalar type:  \");\n+\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, scalar_type);\n+\t  dump_printf (MSG_NOTE, \"\\n\");\n+\t}\n+      nunits_vectype = get_vectype_for_scalar_type (scalar_type);\n+    }\n+  if (!nunits_vectype)\n+    {\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"not vectorized: unsupported data-type \");\n+\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, scalar_type);\n+\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n+\t}\n+      return false;\n+    }\n+\n+  if (maybe_ne (GET_MODE_SIZE (TYPE_MODE (vectype)),\n+\t\tGET_MODE_SIZE (TYPE_MODE (nunits_vectype))))\n+    {\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"not vectorized: different sized vector \"\n+\t\t\t   \"types in statement, \");\n+\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, vectype);\n+\t  dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n+\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, nunits_vectype);\n+\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n+\t}\n+      return false;\n+    }\n+\n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location, \"vectype: \");\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, nunits_vectype);\n+      dump_printf (MSG_NOTE, \"\\n\");\n+\n+      dump_printf_loc (MSG_NOTE, vect_location, \"nunits = \");\n+      dump_dec (MSG_NOTE, TYPE_VECTOR_SUBPARTS (nunits_vectype));\n+      dump_printf (MSG_NOTE, \"\\n\");\n+    }\n+\n+  *nunits_vectype_out = nunits_vectype;\n+  return true;\n+}\n+\n+/* Try to determine the correct vector type for STMT_INFO, which is a\n+   statement that produces a scalar boolean result.  Return the vector\n+   type on success, otherwise return NULL_TREE.  */\n+\n+tree\n+vect_get_mask_type_for_stmt (stmt_vec_info stmt_info)\n+{\n+  gimple *stmt = stmt_info->stmt;\n+  tree mask_type = NULL;\n+  tree vectype, scalar_type;\n+\n+  if (is_gimple_assign (stmt)\n+      && TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)) == tcc_comparison\n+      && !VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (stmt))))\n+    {\n+      scalar_type = TREE_TYPE (gimple_assign_rhs1 (stmt));\n+      mask_type = get_mask_type_for_scalar_type (scalar_type);\n+\n+      if (!mask_type)\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: unsupported mask\\n\");\n+\t  return NULL_TREE;\n+\t}\n+    }\n+  else\n+    {\n+      tree rhs;\n+      ssa_op_iter iter;\n+      gimple *def_stmt;\n+      enum vect_def_type dt;\n+\n+      FOR_EACH_SSA_TREE_OPERAND (rhs, stmt, iter, SSA_OP_USE)\n+\t{\n+\t  if (!vect_is_simple_use (rhs, stmt_info->vinfo,\n+\t\t\t\t   &def_stmt, &dt, &vectype))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\t{\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t   \"not vectorized: can't compute mask type \"\n+\t\t\t\t   \"for statement, \");\n+\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt,\n+\t\t\t\t    0);\n+\t\t}\n+\t      return NULL_TREE;\n+\t    }\n+\n+\t  /* No vectype probably means external definition.\n+\t     Allow it in case there is another operand which\n+\t     allows to determine mask type.  */\n+\t  if (!vectype)\n+\t    continue;\n+\n+\t  if (!mask_type)\n+\t    mask_type = vectype;\n+\t  else if (maybe_ne (TYPE_VECTOR_SUBPARTS (mask_type),\n+\t\t\t     TYPE_VECTOR_SUBPARTS (vectype)))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\t{\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t   \"not vectorized: different sized masks \"\n+\t\t\t\t   \"types in statement, \");\n+\t\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\t     mask_type);\n+\t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n+\t\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\t     vectype);\n+\t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n+\t\t}\n+\t      return NULL_TREE;\n+\t    }\n+\t  else if (VECTOR_BOOLEAN_TYPE_P (mask_type)\n+\t\t   != VECTOR_BOOLEAN_TYPE_P (vectype))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\t{\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t   \"not vectorized: mixed mask and \"\n+\t\t\t\t   \"nonmask vector types in statement, \");\n+\t\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\t     mask_type);\n+\t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n+\t\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\t     vectype);\n+\t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n+\t\t}\n+\t      return NULL_TREE;\n+\t    }\n+\t}\n+\n+      /* We may compare boolean value loaded as vector of integers.\n+\t Fix mask_type in such case.  */\n+      if (mask_type\n+\t  && !VECTOR_BOOLEAN_TYPE_P (mask_type)\n+\t  && gimple_code (stmt) == GIMPLE_ASSIGN\n+\t  && TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)) == tcc_comparison)\n+\tmask_type = build_same_sized_truth_vector_type (mask_type);\n+    }\n+\n+  /* No mask_type should mean loop invariant predicate.\n+     This is probably a subject for optimization in if-conversion.  */\n+  if (!mask_type && dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t       \"not vectorized: can't compute mask type \"\n+\t\t       \"for statement, \");\n+      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+    }\n+  return mask_type;\n+}"}, {"sha": "049e3dd9c9c6a8077ae6c13cd02d9bda11d87ec0", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3cb66326d724cca10ac6097ab32c53191c53ff/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3cb66326d724cca10ac6097ab32c53191c53ff/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=1f3cb66326d724cca10ac6097ab32c53191c53ff", "patch": "@@ -1467,6 +1467,8 @@ extern tree vect_gen_perm_mask_checked (tree, const vec_perm_indices &);\n extern void optimize_mask_stores (struct loop*);\n extern gcall *vect_gen_while (tree, tree, tree);\n extern tree vect_gen_while_not (gimple_seq *, tree, tree, tree);\n+extern bool vect_get_vector_types_for_stmt (stmt_vec_info, tree *, tree *);\n+extern tree vect_get_mask_type_for_stmt (stmt_vec_info);\n \n /* In tree-vect-data-refs.c.  */\n extern bool vect_can_force_dr_alignment_p (const_tree, unsigned int);"}]}