{"sha": "f165ef89c08ddabb19583e45e8a6819f810d95ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE2NWVmODljMDhkZGFiYjE5NTgzZTQ1ZThhNjgxOWY4MTBkOTVhYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-10-28T09:28:18Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-10-28T09:29:09Z"}, "message": "lto: LTO cgraph support for late declare variant resolution [PR96680]\n\n> I've tried to add the saving/restoring next to ipa refs saving/restoring, as\n> the declare variant alt stuff is kind of extension of those, unfortunately\n> following doesn't compile, because I need to also write or read a tree there\n> (ctx is a portion of DECL_ATTRIBUTES of the base function), but the ipa refs\n> write/read back functions don't have arguments that can be used for that.\n\nThis patch adds the streaming out and in of those omp_declare_variant_alt\nhash table on the side data for the declare_variant_alt cgraph_nodes and\ntreats for LTO purposes the declare_variant_alt nodes (which have no body)\nas if they contained a body that calls all the possible variants.\nAfter IPA all the calls to these magic declare_variant_alt calls are\nreplaced with call to one of the variant depending on which one has the\nhighest score in the context.\n\n2020-10-28  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR lto/96680\ngcc/\n\t* lto-streamer.h (omp_lto_output_declare_variant_alt,\n\tomp_lto_input_declare_variant_alt): Declare variant.\n\t* symtab.c (symtab_node::get_partitioning_class): Return\n\tSYMBOL_DUPLICATE for declare_variant_alt nodes.\n\t* passes.c (ipa_write_summaries): Add declare_variant_alt to\n\tpartition.\n\t* lto-cgraph.c (output_refs): Call omp_lto_output_declare_variant_alt\n\ton declare_variant_alt nodes.\n\t(input_refs): Call omp_lto_input_declare_variant_alt on\n\tdeclare_variant_alt nodes.\n\t* lto-streamer-out.c (output_function): Don't call\n\tcollect_block_tree_leafs if DECL_INITIAL is error_mark_node.\n\t(lto_output): Call output_function even for declare_variant_alt\n\tnodes.\n\t* omp-general.c (omp_lto_output_declare_variant_alt,\n\tomp_lto_input_declare_variant_alt): New functions.\ngcc/lto/\n\t* lto-common.c (lto_fixup_prevailing_decls): Don't use\n\tLTO_NO_PREVAIL on TREE_LIST's TREE_PURPOSE.\n\t* lto-partition.c (lto_balanced_map): Treat declare_variant_alt\n\tnodes like definitions.\nlibgomp/\n\t* testsuite/libgomp.c/declare-variant-1.c: New test.", "tree": {"sha": "27d05b9d41f4df1998e9b8e04745d4f32bb7d54a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27d05b9d41f4df1998e9b8e04745d4f32bb7d54a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f165ef89c08ddabb19583e45e8a6819f810d95ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f165ef89c08ddabb19583e45e8a6819f810d95ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f165ef89c08ddabb19583e45e8a6819f810d95ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f165ef89c08ddabb19583e45e8a6819f810d95ab/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "279a9ce9d545f65a0bb1bc4564abafabfc25f82d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/279a9ce9d545f65a0bb1bc4564abafabfc25f82d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/279a9ce9d545f65a0bb1bc4564abafabfc25f82d"}], "stats": {"total": 203, "additions": 196, "deletions": 7}, "files": [{"sha": "91900a12fa27cd487fba6640e94ad1fd5e92ff14", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f165ef89c08ddabb19583e45e8a6819f810d95ab/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f165ef89c08ddabb19583e45e8a6819f810d95ab/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=f165ef89c08ddabb19583e45e8a6819f810d95ab", "patch": "@@ -767,6 +767,9 @@ output_refs (lto_symtab_encoder_t encoder)\n \t  for (int i = 0; node->iterate_reference (i, ref); i++)\n \t    lto_output_ref (ob, ref, encoder);\n \t}\n+      if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n+\tif (cnode->declare_variant_alt)\n+\t  omp_lto_output_declare_variant_alt (ob, cnode, encoder);\n     }\n \n   streamer_write_uhwi_stream (ob->main_stream, 0);\n@@ -1608,6 +1611,9 @@ input_refs (class lto_input_block *ib,\n \t  input_ref (ib, node, nodes);\n \t  count--;\n \t}\n+      if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n+\tif (cnode->declare_variant_alt)\n+\t  omp_lto_input_declare_variant_alt (ib, cnode, nodes);\n     }\n }\n \t    "}, {"sha": "0ca2796da9c976e4e87c15b3623049853586d36f", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f165ef89c08ddabb19583e45e8a6819f810d95ab/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f165ef89c08ddabb19583e45e8a6819f810d95ab/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=f165ef89c08ddabb19583e45e8a6819f810d95ab", "patch": "@@ -2424,7 +2424,7 @@ output_function (struct cgraph_node *node)\n   /* As we do not recurse into BLOCK_SUBBLOCKS but only BLOCK_SUPERCONTEXT\n      collect block tree leafs and stream those.  */\n   auto_vec<tree> block_tree_leafs;\n-  if (DECL_INITIAL (function))\n+  if (DECL_INITIAL (function) && DECL_INITIAL (function) != error_mark_node)\n     collect_block_tree_leafs (DECL_INITIAL (function), block_tree_leafs);\n   streamer_write_uhwi (ob, block_tree_leafs.length ());\n   for (unsigned i = 0; i < block_tree_leafs.length (); ++i)\n@@ -2788,7 +2788,8 @@ lto_output (void)\n \t\t  && flag_incremental_link != INCREMENTAL_LINK_LTO)\n \t      /* Thunks have no body but they may be synthetized\n \t\t at WPA time.  */\n-\t      || DECL_ARGUMENTS (cnode->decl)))\n+\t      || DECL_ARGUMENTS (cnode->decl)\n+\t      || cnode->declare_variant_alt))\n \toutput_function (cnode);\n       else if ((vnode = dyn_cast <varpool_node *> (snode))\n \t       && (DECL_INITIAL (vnode->decl) != error_mark_node"}, {"sha": "c75a8b2cc4a593c5aee7c8584d55edf2d1433fe1", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f165ef89c08ddabb19583e45e8a6819f810d95ab/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f165ef89c08ddabb19583e45e8a6819f810d95ab/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=f165ef89c08ddabb19583e45e8a6819f810d95ab", "patch": "@@ -927,6 +927,12 @@ bool reachable_from_this_partition_p (struct cgraph_node *,\n lto_symtab_encoder_t compute_ltrans_boundary (lto_symtab_encoder_t encoder);\n void select_what_to_stream (void);\n \n+/* In omp-general.c.  */\n+void omp_lto_output_declare_variant_alt (lto_simple_output_block *,\n+\t\t\t\t\t cgraph_node *, lto_symtab_encoder_t);\n+void omp_lto_input_declare_variant_alt (lto_input_block *, cgraph_node *,\n+\t\t\t\t\tvec<symtab_node *>);\n+\n /* In options-save.c.  */\n void cl_target_option_stream_out (struct output_block *, struct bitpack_d *,\n \t\t\t\t  struct cl_target_option *);"}, {"sha": "6944c469f89708ce5ed1877ea3cbf316bfa4727c", "filename": "gcc/lto/lto-common.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f165ef89c08ddabb19583e45e8a6819f810d95ab/gcc%2Flto%2Flto-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f165ef89c08ddabb19583e45e8a6819f810d95ab/gcc%2Flto%2Flto-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-common.c?ref=f165ef89c08ddabb19583e45e8a6819f810d95ab", "patch": "@@ -2592,7 +2592,6 @@ lto_fixup_prevailing_decls (tree t)\n \tcase TREE_LIST:\n \t  LTO_SET_PREVAIL (TREE_VALUE (t));\n \t  LTO_SET_PREVAIL (TREE_PURPOSE (t));\n-\t  LTO_NO_PREVAIL (TREE_PURPOSE (t));\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();"}, {"sha": "cc721f9158673564af48f251eca3a8cb9a85f555", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f165ef89c08ddabb19583e45e8a6819f810d95ab/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f165ef89c08ddabb19583e45e8a6819f810d95ab/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=f165ef89c08ddabb19583e45e8a6819f810d95ab", "patch": "@@ -593,7 +593,8 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \n \t      last_visited_node++;\n \n-\t      gcc_assert (node->definition || node->weakref);\n+\t      gcc_assert (node->definition || node->weakref\n+\t\t\t  || node->declare_variant_alt);\n \n \t      /* Compute boundary cost of callgraph edges.  */\n \t      for (edge = node->callees; edge; edge = edge->next_callee)\n@@ -704,7 +705,7 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t\tint index;\n \n \t\tnode = dyn_cast <cgraph_node *> (ref->referring);\n-\t\tgcc_assert (node->definition);\n+\t\tgcc_assert (node->definition || node->declare_variant_alt);\n \t\tindex = lto_symtab_encoder_lookup (partition->encoder,\n \t\t\t\t\t\t   node);\n \t\tif (index != LCC_NOT_FOUND"}, {"sha": "b66dfb58257812139687334aafd18d89b29345d3", "filename": "gcc/omp-general.c", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f165ef89c08ddabb19583e45e8a6819f810d95ab/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f165ef89c08ddabb19583e45e8a6819f810d95ab/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=f165ef89c08ddabb19583e45e8a6819f810d95ab", "patch": "@@ -42,6 +42,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"omp-device-properties.h\"\n #include \"tree-iterator.h\"\n+#include \"data-streamer.h\"\n+#include \"streamer-hooks.h\"\n \n enum omp_requires omp_requires_mask;\n \n@@ -2337,6 +2339,125 @@ omp_resolve_declare_variant (tree base)\n \t  ? TREE_PURPOSE (TREE_VALUE (variant1)) : base);\n }\n \n+void\n+omp_lto_output_declare_variant_alt (lto_simple_output_block *ob,\n+\t\t\t\t    cgraph_node *node,\n+\t\t\t\t    lto_symtab_encoder_t encoder)\n+{\n+  gcc_assert (node->declare_variant_alt);\n+\n+  omp_declare_variant_base_entry entry;\n+  entry.base = NULL;\n+  entry.node = node;\n+  entry.variants = NULL;\n+  omp_declare_variant_base_entry *entryp\n+    = omp_declare_variant_alt->find_with_hash (&entry, DECL_UID (node->decl));\n+  gcc_assert (entryp);\n+\n+  int nbase = lto_symtab_encoder_lookup (encoder, entryp->base);\n+  gcc_assert (nbase != LCC_NOT_FOUND);\n+  streamer_write_hwi_stream (ob->main_stream, nbase);\n+\n+  streamer_write_hwi_stream (ob->main_stream, entryp->variants->length ());\n+\n+  unsigned int i;\n+  omp_declare_variant_entry *varentry;\n+  FOR_EACH_VEC_SAFE_ELT (entryp->variants, i, varentry)\n+    {\n+      int nvar = lto_symtab_encoder_lookup (encoder, varentry->variant);\n+      gcc_assert (nvar != LCC_NOT_FOUND);\n+      streamer_write_hwi_stream (ob->main_stream, nvar);\n+\n+      for (widest_int *w = &varentry->score; ;\n+\t   w = &varentry->score_in_declare_simd_clone)\n+\t{\n+\t  unsigned len = w->get_len ();\n+\t  streamer_write_hwi_stream (ob->main_stream, len);\n+\t  const HOST_WIDE_INT *val = w->get_val ();\n+\t  for (unsigned j = 0; j < len; j++)\n+\t    streamer_write_hwi_stream (ob->main_stream, val[j]);\n+\t  if (w == &varentry->score_in_declare_simd_clone)\n+\t    break;\n+\t}\n+\n+      HOST_WIDE_INT cnt = -1;\n+      HOST_WIDE_INT i = varentry->matches ? 1 : 0;\n+      for (tree attr = DECL_ATTRIBUTES (entryp->base->decl);\n+\t   attr; attr = TREE_CHAIN (attr), i += 2)\n+\t{\n+\t  attr = lookup_attribute (\"omp declare variant base\", attr);\n+\t  if (attr == NULL_TREE)\n+\t    break;\n+\n+\t  if (varentry->ctx == TREE_VALUE (TREE_VALUE (attr)))\n+\t    {\n+\t      cnt = i;\n+\t      break;\n+\t    }\n+\t}\n+\n+      gcc_assert (cnt != -1);\n+      streamer_write_hwi_stream (ob->main_stream, cnt);\n+    }\n+}\n+\n+void\n+omp_lto_input_declare_variant_alt (lto_input_block *ib, cgraph_node *node,\n+\t\t\t\t   vec<symtab_node *> nodes)\n+{\n+  gcc_assert (node->declare_variant_alt);\n+  omp_declare_variant_base_entry *entryp\n+    = ggc_cleared_alloc<omp_declare_variant_base_entry> ();\n+  entryp->base = dyn_cast<cgraph_node *> (nodes[streamer_read_hwi (ib)]);\n+  entryp->node = node;\n+  unsigned int len = streamer_read_hwi (ib);\n+  vec_alloc (entryp->variants, len);\n+\n+  for (unsigned int i = 0; i < len; i++)\n+    {\n+      omp_declare_variant_entry varentry;\n+      varentry.variant\n+\t= dyn_cast<cgraph_node *> (nodes[streamer_read_hwi (ib)]);\n+      for (widest_int *w = &varentry.score; ;\n+\t   w = &varentry.score_in_declare_simd_clone)\n+\t{\n+\t  unsigned len2 = streamer_read_hwi (ib);\n+\t  HOST_WIDE_INT arr[WIDE_INT_MAX_ELTS];\n+\t  gcc_assert (len2 <= WIDE_INT_MAX_ELTS);\n+\t  for (unsigned int j = 0; j < len2; j++)\n+\t    arr[j] = streamer_read_hwi (ib);\n+\t  *w = widest_int::from_array (arr, len2, true);\n+\t  if (w == &varentry.score_in_declare_simd_clone)\n+\t    break;\n+\t}\n+\n+      HOST_WIDE_INT cnt = streamer_read_hwi (ib);\n+      HOST_WIDE_INT j = 0;\n+      varentry.ctx = NULL_TREE;\n+      varentry.matches = (cnt & 1) ? true : false;\n+      cnt &= ~HOST_WIDE_INT_1;\n+      for (tree attr = DECL_ATTRIBUTES (entryp->base->decl);\n+\t   attr; attr = TREE_CHAIN (attr), j += 2)\n+\t{\n+\t  attr = lookup_attribute (\"omp declare variant base\", attr);\n+\t  if (attr == NULL_TREE)\n+\t    break;\n+\n+\t  if (cnt == j)\n+\t    {\n+\t      varentry.ctx = TREE_VALUE (TREE_VALUE (attr));\n+\t      break;\n+\t    }\n+\t}\n+      gcc_assert (varentry.ctx != NULL_TREE);\n+      entryp->variants->quick_push (varentry);\n+    }\n+  if (omp_declare_variant_alt == NULL)\n+    omp_declare_variant_alt\n+      = hash_table<omp_declare_variant_alt_hasher>::create_ggc (64);\n+  *omp_declare_variant_alt->find_slot_with_hash (entryp, DECL_UID (node->decl),\n+\t\t\t\t\t\t INSERT) = entryp;\n+}\n \n /* Encode an oacc launch argument.  This matches the GOMP_LAUNCH_PACK\n    macro on gomp-constants.h.  We do not check for overflow.  */"}, {"sha": "079ad1a88f7f18f655ba0bcfa9680d22eebdbefb", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f165ef89c08ddabb19583e45e8a6819f810d95ab/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f165ef89c08ddabb19583e45e8a6819f810d95ab/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=f165ef89c08ddabb19583e45e8a6819f810d95ab", "patch": "@@ -2731,7 +2731,8 @@ ipa_write_summaries (void)\n     {\n       struct cgraph_node *node = order[i];\n \n-      if (node->definition && node->need_lto_streaming)\n+      if ((node->definition || node->declare_variant_alt)\n+\t  && node->need_lto_streaming)\n \t{\n \t  if (gimple_has_body_p (node->decl))\n \t    lto_prepare_function_for_streaming (node);"}, {"sha": "9db88fa8531d4946cf17f5c2cb07ebd8ddb64865", "filename": "gcc/symtab.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f165ef89c08ddabb19583e45e8a6819f810d95ab/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f165ef89c08ddabb19583e45e8a6819f810d95ab/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=f165ef89c08ddabb19583e45e8a6819f810d95ab", "patch": "@@ -2006,7 +2006,7 @@ symtab_node::get_partitioning_class (void)\n   if (DECL_ABSTRACT_P (decl))\n     return SYMBOL_EXTERNAL;\n \n-  if (cnode && cnode->inlined_to)\n+  if (cnode && (cnode->inlined_to || cnode->declare_variant_alt))\n     return SYMBOL_DUPLICATE;\n \n   /* Transparent aliases are always duplicated.  */"}, {"sha": "d16608f7e6dd45ea58ca6a0adef7ab56048ab1fd", "filename": "libgomp/testsuite/libgomp.c/declare-variant-1.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f165ef89c08ddabb19583e45e8a6819f810d95ab/libgomp%2Ftestsuite%2Flibgomp.c%2Fdeclare-variant-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f165ef89c08ddabb19583e45e8a6819f810d95ab/libgomp%2Ftestsuite%2Flibgomp.c%2Fdeclare-variant-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fdeclare-variant-1.c?ref=f165ef89c08ddabb19583e45e8a6819f810d95ab", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do link { target vect_simd_clones } } */\n+/* { dg-require-effective-target lto } */\n+/* { dg-require-effective-target fpic } */\n+/* { dg-require-effective-target shared } */\n+/* { dg-additional-options \"-fdump-tree-gimple -fdump-tree-optimized -O2 -fPIC -shared -flto -flto-partition=one\" } */\n+/* { dg-additional-options \"-mno-sse3\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+int\n+f01 (int a)\n+{\n+  asm volatile (\"\" : \"+g\" (a) : \"g\" (1) : \"memory\");\n+  return a;\n+}\n+\n+int\n+f02 (int a)\n+{\n+  asm volatile (\"\" : \"+g\" (a) : \"g\" (2) : \"memory\");\n+  return a;\n+}\n+\n+int\n+f03 (int a)\n+{\n+  asm volatile (\"\" : \"+g\" (a) : \"g\" (3) : \"memory\");\n+  return a;\n+}\n+\n+#pragma omp declare variant (f01) match (device={isa(\"avx512f\")}) /* 4 or 8 */\n+#pragma omp declare variant (f02) match (implementation={vendor(score(3):gnu)},device={kind(cpu)}) /* (1 or 2) + 3 */\n+#pragma omp declare variant (f03) match (implementation={vendor(score(5):gnu)},device={kind(host)}) /* (1 or 2) + 5 */\n+int\n+f04 (int a)\n+{\n+  asm volatile (\"\" : \"+g\" (a) : \"g\" (4) : \"memory\");\n+  return a;\n+}\n+\n+#pragma omp declare simd\n+int\n+test1 (int x)\n+{\n+  /* At gimplification time, we can't decide yet which function to call.  */\n+  /* { dg-final { scan-tree-dump-times \"f04 \\\\\\(x\" 2 \"gimple\" } } */\n+  /* After simd clones are created, the original non-clone test1 shall\n+     call f03 (score 6), the sse2/avx/avx2 clones too, but avx512f clones\n+     shall call f01 with score 8.  */\n+  /* { dg-final { scan-ltrans-tree-dump-not \"f04 \\\\\\(x\" \"optimized\" } } */\n+  /* { dg-final { scan-ltrans-tree-dump-times \"f03 \\\\\\(x\" 14 \"optimized\" } } */\n+  /* { dg-final { scan-ltrans-tree-dump-times \"f01 \\\\\\(x\" 4 \"optimized\" } } */\n+  int a = f04 (x);\n+  int b = f04 (x);\n+  return a + b;\n+}"}]}