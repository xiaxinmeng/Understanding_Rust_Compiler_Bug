{"sha": "fada196198e4c9350a78fe08c7a132bb4055ba05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFkYTE5NjE5OGU0YzkzNTBhNzhmZTA4YzdhMTMyYmI0MDU1YmEwNQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2003-07-16T21:41:20Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2003-07-16T21:41:20Z"}, "message": "prologue / epilogue / warning patches:\n\n2003-07-16  J\"orn Rennecke <joern.rennecke@superh.com>\n\t    Con Bradley <con.bradley@superh.com>\n\n\t* sh-protos.h (sh_get_pr_initial_val): Declare.\n\t* sh.c (regno_reg_class): Make its elements type enum reg_class.\n\t(output_stack_adjust): Remove emit_fn argument.  Add epilogue_p\n\tand live_regs_mask arguments.  Changed all callers.\n\t(save_schedule_s): New structure.\n\t(save_schedule): New typedef.\n\t(scavenge_reg, sh5_schedule_saves, sh5_schedule_saves): New functions.\n\t(calc_live_regs): For TARGET_SHMEDIA, use leaf_function_p.\n\tIn interrupts handlers, also save registers that are usually\n\tpartially saved, and make sure there is at least one general purpose\n\tregister saved if a target register needs saving.\n\tAdd casts in comparisons to avoid warnings.\n\t(sh_media_register_for_return): return -1 for interrupt handlers.\n\t(MAX_SAVED_REGS, MAX_TEMPS): New defines.\n\t(sh_expand_prologue): Use sh5_schedule_saves.  Check that any temp\n\tregisters used are available.\n\tSet RTX_FRAME_RELATED_P where appropriate.\n\tAdd an REG_FRAME_RELATED_EXPR for r0 + offset addressing.\n\t(sh_expand_epilogue, sh_set_return_address): Use sh5_schedule_saves.\n\t(initial_elimination_offset): Likewise.\n\t* sh.h (DWARF_CIE_DATA_ALIGNMENT): Set to -4.\n\t(LOCAL_ALIGNMENT, GENERAL_REGISTER_P): Add casts to avoid warnings.\n\t(FP_REGISTER_P): Add casts to fix broken handling of unsigned REGNO.\n\t(XD_REGISTER_P, TARGET_REGISTER_P): Likewise.\n\t(HARD_REGNO_CALL_PART_CLOBBERED): Also yield nonzero for r15,\n\tand for target registers.\n\t(RETURN_IN_MEMORY): Add parentheses to avoid warnings.\n\t(regno_reg_class): Make its elements type enum reg_class.\n\t(CONSTRAINT_LEN): Don't use isdigit.\n\t(FUNCTION_ARG_REGNO_P): Add casts to avoid warnings.\n\t(FUNCTION_ARG): Add parentheses to avoid warnings.\n\t(RETURN_ADDR_RTX): Use sh_get_pr_initial_val.\n\t(RETURN_ADDR_OFFSET): Define to -1 for TARGET_SH5.\n\t(SH_DBX_REGISTER_NUMBER): Add casts to avoid warnings.\n\t(EH_RETURN_DATA_REGNO): Use unsigned constants to avoid warnings.\n\t* sh.md (xordi3+1): Remove unused variable regno.\n\t(return_media): Check that tr0 is available before using it.\n\nCo-Authored-By: Con Bradley <con.bradley@superh.com>\n\nFrom-SVN: r69480", "tree": {"sha": "6bdbd9cf60de950e5058b8fdfbdd21aeb5837078", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bdbd9cf60de950e5058b8fdfbdd21aeb5837078"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fada196198e4c9350a78fe08c7a132bb4055ba05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fada196198e4c9350a78fe08c7a132bb4055ba05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fada196198e4c9350a78fe08c7a132bb4055ba05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fada196198e4c9350a78fe08c7a132bb4055ba05/comments", "author": null, "committer": null, "parents": [{"sha": "1f8ae5cd7aa54d337c20920c282af5faa40b89d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f8ae5cd7aa54d337c20920c282af5faa40b89d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f8ae5cd7aa54d337c20920c282af5faa40b89d3"}], "stats": {"total": 919, "additions": 558, "deletions": 361}, "files": [{"sha": "40f776f66d9ab846eef2afebf6b80f9bfc6f9e48", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fada196198e4c9350a78fe08c7a132bb4055ba05/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fada196198e4c9350a78fe08c7a132bb4055ba05/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fada196198e4c9350a78fe08c7a132bb4055ba05", "patch": "@@ -1,3 +1,44 @@\n+2003-07-16  J\"orn Rennecke <joern.rennecke@superh.com>\n+\t    Con Bradley <con.bradley@superh.com>\n+\n+\t* sh-protos.h (sh_get_pr_initial_val): Declare.\n+\t* sh.c (regno_reg_class): Make its elements type enum reg_class.\n+\t(output_stack_adjust): Remove emit_fn argument.  Add epilogue_p\n+\tand live_regs_mask arguments.  Changed all callers.\n+\t(save_schedule_s): New structure.\n+\t(save_schedule): New typedef.\n+\t(scavenge_reg, sh5_schedule_saves, sh5_schedule_saves): New functions.\n+\t(calc_live_regs): For TARGET_SHMEDIA, use leaf_function_p.\n+\tIn interrupts handlers, also save registers that are usually\n+\tpartially saved, and make sure there is at least one general purpose\n+\tregister saved if a target register needs saving.\n+\tAdd casts in comparisons to avoid warnings.\n+\t(sh_media_register_for_return): return -1 for interrupt handlers.\n+\t(MAX_SAVED_REGS, MAX_TEMPS): New defines.\n+\t(sh_expand_prologue): Use sh5_schedule_saves.  Check that any temp\n+\tregisters used are available.\n+\tSet RTX_FRAME_RELATED_P where appropriate.\n+\tAdd an REG_FRAME_RELATED_EXPR for r0 + offset addressing.\n+\t(sh_expand_epilogue, sh_set_return_address): Use sh5_schedule_saves.\n+\t(initial_elimination_offset): Likewise.\n+\t* sh.h (DWARF_CIE_DATA_ALIGNMENT): Set to -4.\n+\t(LOCAL_ALIGNMENT, GENERAL_REGISTER_P): Add casts to avoid warnings.\n+\t(FP_REGISTER_P): Add casts to fix broken handling of unsigned REGNO.\n+\t(XD_REGISTER_P, TARGET_REGISTER_P): Likewise.\n+\t(HARD_REGNO_CALL_PART_CLOBBERED): Also yield nonzero for r15,\n+\tand for target registers.\n+\t(RETURN_IN_MEMORY): Add parentheses to avoid warnings.\n+\t(regno_reg_class): Make its elements type enum reg_class.\n+\t(CONSTRAINT_LEN): Don't use isdigit.\n+\t(FUNCTION_ARG_REGNO_P): Add casts to avoid warnings.\n+\t(FUNCTION_ARG): Add parentheses to avoid warnings.\n+\t(RETURN_ADDR_RTX): Use sh_get_pr_initial_val.\n+\t(RETURN_ADDR_OFFSET): Define to -1 for TARGET_SH5.\n+\t(SH_DBX_REGISTER_NUMBER): Add casts to avoid warnings.\n+\t(EH_RETURN_DATA_REGNO): Use unsigned constants to avoid warnings.\n+\t* sh.md (xordi3+1): Remove unused variable regno.\n+\t(return_media): Check that tr0 is available before using it.\n+\n 2003-07-16  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* c.opt: Document more options."}, {"sha": "e046206dc393d045c2e95a8997e06634e1588d8d", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fada196198e4c9350a78fe08c7a132bb4055ba05/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fada196198e4c9350a78fe08c7a132bb4055ba05/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=fada196198e4c9350a78fe08c7a132bb4055ba05", "patch": "@@ -136,5 +136,6 @@ extern void sh_pr_interrupt PARAMS ((struct cpp_reader *));\n extern void sh_pr_trapa PARAMS ((struct cpp_reader *));\n extern void sh_pr_nosave_low_regs PARAMS ((struct cpp_reader *));\n extern rtx function_symbol (const char *);\n+extern rtx sh_get_pr_initial_val (void);\n \n #endif /* ! GCC_SH_PROTOS_H */"}, {"sha": "cc75c2f58993d7fdccd945ee931703947acd810b", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 466, "deletions": 332, "changes": 798, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fada196198e4c9350a78fe08c7a132bb4055ba05/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fada196198e4c9350a78fe08c7a132bb4055ba05/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=fada196198e4c9350a78fe08c7a132bb4055ba05", "patch": "@@ -108,7 +108,7 @@ rtx sh_compare_op1;\n /* Provides the class number of the smallest class containing\n    reg number.  */\n \n-int regno_reg_class[FIRST_PSEUDO_REGISTER] =\n+enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER] =\n {\n   R0_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n   GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n@@ -190,7 +190,7 @@ static rtx find_barrier PARAMS ((int, rtx, rtx));\n static int noncall_uses_reg PARAMS ((rtx, rtx, rtx *));\n static rtx gen_block_redirect PARAMS ((rtx, int, int));\n static void sh_reorg PARAMS ((void));\n-static void output_stack_adjust PARAMS ((int, rtx, int, rtx (*) (rtx)));\n+static void output_stack_adjust (int, rtx, int, HARD_REG_SET *);\n static rtx frame_insn PARAMS ((rtx));\n static rtx push PARAMS ((int));\n static void pop PARAMS ((int));\n@@ -234,6 +234,10 @@ static int sh_address_cost PARAMS ((rtx));\n static int shmedia_target_regs_stack_space (HARD_REG_SET *);\n static int shmedia_reserve_space_for_target_registers_p (int, HARD_REG_SET *);\n static int shmedia_target_regs_stack_adjust (HARD_REG_SET *);\n+static int scavenge_reg (HARD_REG_SET *s);\n+struct save_schedule_s;\n+static struct save_entry_s *sh5_schedule_saves (HARD_REG_SET *,\n+\t\t\t\t\t\tstruct save_schedule_s *, int);\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ATTRIBUTE_TABLE\n@@ -4558,17 +4562,16 @@ output_jump_label_table ()\n \n static int extra_push;\n \n-/* Adjust the stack by SIZE bytes.  REG holds the rtl of the register\n-  to be adjusted, and TEMP, if nonnegative, holds the register number\n-  of a general register that we may clobber.  */\n+/* Adjust the stack by SIZE bytes.  REG holds the rtl of the register to be\n+   adjusted.  If epilogue_p is zero, this is for a prologue; otherwise, it's\n+   for an epilogue.  If LIVE_REGS_MASK is nonzero, it points to a HARD_REG_SET\n+   of all the registers that are about to be restored, and hence dead.  */\n \n static void\n-output_stack_adjust (size, reg, temp, emit_fn)\n-     int size;\n-     rtx reg;\n-     int temp;\n-     rtx (*emit_fn) PARAMS ((rtx));\n+output_stack_adjust (int size, rtx reg, int epilogue_p,\n+\t\t     HARD_REG_SET *live_regs_mask)\n {\n+  rtx (*emit_fn) (rtx) = epilogue_p ? &emit_insn : &frame_insn;\n   if (size)\n     {\n       HOST_WIDE_INT align = STACK_BOUNDARY / BITS_PER_UNIT;\n@@ -4591,10 +4594,43 @@ output_stack_adjust (size, reg, temp, emit_fn)\n \t{\n \t  rtx const_reg;\n \t  rtx insn;\n+\t  int temp = epilogue_p ? 7 : (TARGET_SH5 ? 0 : 1);\n+\t  int i;\n \n \t  /* If TEMP is invalid, we could temporarily save a general\n \t     register to MACL.  However, there is currently no need\n \t     to handle this case, so just abort when we see it.  */\n+\t  if (current_function_interrupt\n+\t      || ! call_used_regs[temp] || fixed_regs[temp])\n+\t    temp = -1;\n+\t  if (temp < 0 && ! current_function_interrupt)\n+\t    {\n+\t      HARD_REG_SET temps;\n+\t      COPY_HARD_REG_SET (temps, call_used_reg_set);\n+\t      AND_COMPL_HARD_REG_SET (temps, call_fixed_reg_set);\n+\t      if (epilogue_p)\n+\t\t{\n+\t\t  for (i = 0; i < HARD_REGNO_NREGS (FIRST_RET_REG, DImode); i++)\n+\t\t    CLEAR_HARD_REG_BIT (temps, FIRST_RET_REG + i);\n+\t\t  if (current_function_calls_eh_return)\n+\t\t    {\n+\t\t      CLEAR_HARD_REG_BIT (temps, EH_RETURN_STACKADJ_REGNO);\n+\t\t      for (i = 0; i <= 3; i++)\n+\t\t\tCLEAR_HARD_REG_BIT (temps, EH_RETURN_DATA_REGNO (i));\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  for (i = FIRST_PARM_REG;\n+\t\t       i < FIRST_PARM_REG + NPARM_REGS (SImode); i++)\n+\t\t    CLEAR_HARD_REG_BIT (temps, i);\n+\t\t  if (current_function_needs_context)\n+\t\t    CLEAR_HARD_REG_BIT (temps, STATIC_CHAIN_REGNUM);\n+\t\t}\n+\t      temp = scavenge_reg (&temps);\n+\t    }\n+\t  if (temp < 0 && live_regs_mask)\n+\t    temp = scavenge_reg (live_regs_mask);\n \t  if (temp < 0)\n \t    abort ();\n \t  const_reg = gen_rtx_REG (GET_MODE (reg), temp);\n@@ -4612,7 +4648,7 @@ output_stack_adjust (size, reg, temp, emit_fn)\n \t      emit_insn (GEN_MOV (const_reg, GEN_INT (size)));\n \t      insn = emit_fn (GEN_ADD3 (reg, reg, const_reg));\n \t    }\n-\t  if (emit_fn == frame_insn)\n+\t  if (! epilogue_p)\n \t    REG_NOTES (insn)\n \t      = (gen_rtx_EXPR_LIST\n \t\t (REG_FRAME_RELATED_EXPR,\n@@ -4789,12 +4825,11 @@ calc_live_regs (live_regs_mask)\n   int reg;\n   int count;\n   int interrupt_handler;\n-  int pr_live;\n+  int pr_live, has_call;\n \n   interrupt_handler = sh_cfun_interrupt_handler_p ();\n \n-  for (count = 0; 32 * count < FIRST_PSEUDO_REGISTER; count++)\n-    CLEAR_HARD_REG_SET (*live_regs_mask);\n+  CLEAR_HARD_REG_SET (*live_regs_mask);\n   if (TARGET_SH4 && TARGET_FMOVD && interrupt_handler\n       && regs_ever_live[FPSCR_REG])\n     target_flags &= ~FPU_SINGLE_BIT;\n@@ -4829,16 +4864,19 @@ calc_live_regs (live_regs_mask)\n \t   & ~ CALL_COOKIE_RET_TRAMP (1))\n \t  || current_function_has_nonlocal_label))\n     pr_live = 1;\n+  has_call = TARGET_SHMEDIA ? ! leaf_function_p () : pr_live;\n   for (count = 0, reg = FIRST_PSEUDO_REGISTER - 1; reg >= 0; reg--)\n     {\n-      if (reg == (TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG)\n+      if ((! TARGET_SHMEDIA && reg == PR_REG)\n \t  ? pr_live\n \t  : (interrupt_handler && ! pragma_trapa)\n \t  ? (/* Need to save all the regs ever live.  */\n \t     (regs_ever_live[reg]\n \t      || (call_used_regs[reg]\n \t\t  && (! fixed_regs[reg] || reg == MACH_REG || reg == MACL_REG)\n-\t\t  && pr_live))\n+\t\t  && has_call)\n+\t      || (has_call && REGISTER_NATURAL_MODE (reg) == SImode\n+\t\t  && (GENERAL_REGISTER_P (reg) || TARGET_REGISTER_P (reg))))\n \t     && reg != STACK_POINTER_REGNUM && reg != ARG_POINTER_REGNUM\n \t     && reg != RETURN_ADDRESS_POINTER_REGNUM\n \t     && reg != T_REG && reg != GBR_REG\n@@ -4848,13 +4886,13 @@ calc_live_regs (live_regs_mask)\n \t     (TARGET_SHCOMPACT\n \t      && flag_pic\n \t      && current_function_args_info.call_cookie\n-\t      && reg == PIC_OFFSET_TABLE_REGNUM)\n+\t      && reg == (int) PIC_OFFSET_TABLE_REGNUM)\n \t     || (regs_ever_live[reg] && ! call_used_regs[reg])\n \t     || (current_function_calls_eh_return\n-\t\t && (reg == EH_RETURN_DATA_REGNO (0)\n-\t\t     || reg == EH_RETURN_DATA_REGNO (1)\n-\t\t     || reg == EH_RETURN_DATA_REGNO (2)\n-\t\t     || reg == EH_RETURN_DATA_REGNO (3)))))\n+\t\t && (reg == (int) EH_RETURN_DATA_REGNO (0)\n+\t\t     || reg == (int) EH_RETURN_DATA_REGNO (1)\n+\t\t     || reg == (int) EH_RETURN_DATA_REGNO (2)\n+\t\t     || reg == (int) EH_RETURN_DATA_REGNO (3)))))\n \t{\n \t  SET_HARD_REG_BIT (*live_regs_mask, reg);\n \t  count += GET_MODE_SIZE (REGISTER_NATURAL_MODE (reg));\n@@ -4891,6 +4929,19 @@ calc_live_regs (live_regs_mask)\n \t  SET_HARD_REG_BIT (*live_regs_mask, reg);\n \t  count += GET_MODE_SIZE (REGISTER_NATURAL_MODE (reg));\n \t}\n+  /* If this is an interrupt handler, we don't have any call-clobbered\n+     registers we can conveniently use for target register save/restore.\n+     Make sure we save at least one general purpose register when we need\n+     to save target registers.  */\n+  if (interrupt_handler\n+      && hard_regs_intersect_p (live_regs_mask,\n+\t\t\t\t&reg_class_contents[TARGET_REGS])\n+      && ! hard_regs_intersect_p (live_regs_mask,\n+\t\t\t\t  &reg_class_contents[GENERAL_REGS]))\n+    {\n+      SET_HARD_REG_BIT (*live_regs_mask, R0_REG);\n+      count += GET_MODE_SIZE (REGISTER_NATURAL_MODE (R0_REG));\n+    }\n \n   return count;\n }\n@@ -4921,6 +4972,9 @@ sh_media_register_for_return ()\n \n   if (! current_function_is_leaf)\n     return -1;\n+  if (lookup_attribute (\"interrupt_handler\",\n+\t\t\tDECL_ATTRIBUTES (current_function_decl)))\n+    return -1;\n \n   tr0_used = flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM];\n \n@@ -4931,6 +4985,130 @@ sh_media_register_for_return ()\n   return -1;\n }\n \n+/* The maximum registers we need to save are:\n+   - 62 general purpose registers (r15 is stack pointer, r63 is zero)\n+   - 32 floating point registers (for each pair, we save none,\n+         one single precision value, or a double precision value).\n+   -  8 target registers\n+   -  add 1 entry for a delimiter.  */\n+#define MAX_SAVED_REGS (62+32+8)\n+\n+typedef struct save_entry_s\n+{\n+  unsigned char reg;\n+  unsigned char mode;\n+  short offset;\n+} save_entry;\n+\n+#define MAX_TEMPS 4\n+\n+/* There will be a delimiter entry with VOIDmode both at the start and the\n+   end of a filled in schedule.  The end delimiter has the offset of the\n+   save with the smallest (i.e. most negative) offset.  */\n+typedef struct save_schedule_s\n+{\n+  save_entry entries[MAX_SAVED_REGS + 2];\n+  int temps[MAX_TEMPS+1];\n+} save_schedule;\n+\n+/* Fill in SCHEDULE according to LIVE_REGS_MASK.  If RESTORE is nonzero,\n+   use reverse order.  Returns the last entry written to (not counting\n+   the delimiter).  OFFSET_BASE is a number to be added to all offset\n+   entries.  */\n+   \n+static save_entry *\n+sh5_schedule_saves (HARD_REG_SET *live_regs_mask, save_schedule *schedule,\n+\t\t    int offset_base)\n+{\n+  int align, i;\n+  save_entry *entry = schedule->entries;\n+  int tmpx = 0;\n+  int offset;\n+\n+  if (! current_function_interrupt)\n+    for (i = FIRST_GENERAL_REG; tmpx < MAX_TEMPS && i <= LAST_GENERAL_REG; i++)\n+      if (call_used_regs[i] && ! fixed_regs[i]\n+\t  && ! FUNCTION_ARG_REGNO_P (i)\n+\t  && i != FIRST_RET_REG\n+\t  && ! (current_function_needs_context && i == STATIC_CHAIN_REGNUM)\n+\t  && ! (current_function_calls_eh_return\n+\t\t&& (i == EH_RETURN_STACKADJ_REGNO\n+\t\t    || ((unsigned)i <= EH_RETURN_DATA_REGNO (0)\n+\t\t\t&& (unsigned)i >= EH_RETURN_DATA_REGNO (3)))))\n+\tschedule->temps[tmpx++] = i;\n+  entry->reg = -1;\n+  entry->mode = VOIDmode;\n+  entry->offset = offset_base;\n+  entry++;\n+  /* We loop twice: first, we save 8-byte aligned registers in the\n+     higher addresses, that are known to be aligned.  Then, we\n+     proceed to saving 32-bit registers that don't need 8-byte\n+     alignment.\n+     If this is an interrupt function, all registers that need saving\n+     need to be saved in full.  moreover, we need to postpone saving\n+     target registers till we have saved some general purpose registers\n+     we can then use as scratch registers.  */\n+  offset = offset_base;\n+  for (align = 1; align >= 0; align--)\n+    {\n+      for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n+\tif (TEST_HARD_REG_BIT (*live_regs_mask, i))\n+\t  {\n+\t    enum machine_mode mode = REGISTER_NATURAL_MODE (i);\n+\t    int reg = i;\n+\n+\t    if (current_function_interrupt)\n+\t      {\n+\t\tif (TARGET_REGISTER_P (i))\n+\t\t  continue;\n+\t\tif (GENERAL_REGISTER_P (i))\n+\t\t  mode = DImode;\n+\t      }\n+\t    if (mode == SFmode && (i % 2) == 1\n+\t\t&& ! TARGET_FPU_SINGLE && FP_REGISTER_P (i)\n+\t\t&& (TEST_HARD_REG_BIT (*live_regs_mask, (i ^ 1))))\n+\t      {\n+\t\tmode = DFmode;\n+\t\ti--;\n+\t\treg--;\n+\t      }\n+\n+\t    /* If we're doing the aligned pass and this is not aligned,\n+\t       or we're doing the unaligned pass and this is aligned,\n+\t       skip it.  */\n+\t    if ((GET_MODE_SIZE (mode) % (STACK_BOUNDARY / BITS_PER_UNIT) == 0)\n+\t\t!= align)\n+\t      continue;\n+\n+\t    if (current_function_interrupt\n+\t\t&& GENERAL_REGISTER_P (i)\n+\t\t&& tmpx < MAX_TEMPS)\n+\t      schedule->temps[tmpx++] = i;\n+\n+\t    offset -= GET_MODE_SIZE (mode);\n+\t    entry->reg = i;\n+\t    entry->mode = mode;\n+\t    entry->offset = offset;\n+\t    entry++;\n+\t  }\n+      if (align && current_function_interrupt)\n+\tfor (i = LAST_TARGET_REG; i >= FIRST_TARGET_REG; i--)\n+\t  if (TEST_HARD_REG_BIT (*live_regs_mask, i))\n+\t    {\n+\t      offset -= GET_MODE_SIZE (DImode);\n+\t      entry->reg = i;\n+\t      entry->mode = DImode;\n+\t      entry->offset = offset;\n+\t      entry++;\n+\t    }\n+    }\n+  entry->reg = -1;\n+  entry->mode = VOIDmode;\n+  entry->offset = offset;\n+  schedule->temps[tmpx] = -1;\n+  return entry - 1;\n+}\n+\n void\n sh_expand_prologue ()\n {\n@@ -4945,7 +5123,7 @@ sh_expand_prologue ()\n      and partially on the stack, e.g. a large structure.  */\n   output_stack_adjust (-current_function_pretend_args_size\n \t\t       - current_function_args_info.stack_regs * 8,\n-\t\t       stack_pointer_rtx, TARGET_SH5 ? 0 : 1, frame_insn);\n+\t\t       stack_pointer_rtx, 0, NULL);\n \n   extra_push = 0;\n \n@@ -5034,14 +5212,19 @@ sh_expand_prologue ()\n     \n   if (TARGET_SH5)\n     {\n-      int i;\n-      int offset;\n-      int align;\n-      rtx r0 = gen_rtx_REG (Pmode, R0_REG);\n+      int offset_base, offset;\n+      rtx r0 = NULL_RTX;\n       int offset_in_r0 = -1;\n       int sp_in_r0 = 0;\n       int tregs_space = shmedia_target_regs_stack_adjust (&live_regs_mask);\n       int total_size, save_size;\n+      save_schedule schedule;\n+      save_entry *entry;\n+      int *tmp_pnt;\n+\n+      if (call_used_regs[R0_REG] && ! fixed_regs[R0_REG]\n+\t  && ! current_function_interrupt)\n+\tr0 = gen_rtx_REG (Pmode, R0_REG);\n \n       /* D is the actual number of bytes that we need for saving registers,\n \t however, in initial_elimination_offset we have committed to using\n@@ -5067,146 +5250,153 @@ sh_expand_prologue ()\n \t\t  && total_size <= 2044)))\n \td_rounding = total_size - save_size;\n \n-      offset = d + d_rounding;\n+      offset_base = d + d_rounding;\n \n       output_stack_adjust (-(save_size + d_rounding), stack_pointer_rtx,\n-\t\t\t   1, frame_insn);\n-\n-      /* We loop twice: first, we save 8-byte aligned registers in the\n-\t higher addresses, that are known to be aligned.  Then, we\n-\t proceed to saving 32-bit registers that don't need 8-byte\n-\t alignment.  */\n-      /* Note that if you change this code in a way that affects where\n-\t the return register is saved, you have to update not only\n-\t sh_expand_epilogue, but also sh_set_return_address.  */\n-      for (align = 1; align >= 0; align--)\n-\tfor (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n-\t  if (TEST_HARD_REG_BIT (live_regs_mask, i))\n-\t    {\n-\t      enum machine_mode mode = REGISTER_NATURAL_MODE (i);\n-\t      int reg = i;\n-\t      rtx reg_rtx, mem_rtx, pre_dec = NULL_RTX;\n+\t\t\t   0, NULL);\n \n-\t      if (mode == SFmode && (i % 2) == 1\n-\t\t  && ! TARGET_FPU_SINGLE && FP_REGISTER_P (i)\n-\t\t  && (TEST_HARD_REG_BIT (live_regs_mask, (i ^ 1))))\n-\t\t{\n-\t\t  mode = DFmode;\n-\t\t  i--;\n-\t\t  reg--;\n-\t\t}\n-\t\t\n-\t      /* If we're doing the aligned pass and this is not aligned,\n-\t\t or we're doing the unaligned pass and this is aligned,\n-\t\t skip it.  */\n-\t      if ((GET_MODE_SIZE (mode) % (STACK_BOUNDARY / BITS_PER_UNIT)\n-\t\t   == 0) != align)\n-\t\tcontinue;\n+      sh5_schedule_saves (&live_regs_mask, &schedule, offset_base);\n+      tmp_pnt = schedule.temps;\n+      for (entry = &schedule.entries[1]; entry->mode != VOIDmode; entry++)\n+        {\n+\t  enum machine_mode mode = entry->mode;\n+\t  int reg = entry->reg;\n+\t  rtx reg_rtx, mem_rtx, pre_dec = NULL_RTX;\n \n-\t      offset -= GET_MODE_SIZE (mode);\n+\t  offset = entry->offset;\n \n-\t      reg_rtx = gen_rtx_REG (mode, reg);\n+\t  reg_rtx = gen_rtx_REG (mode, reg);\n \n-\t      mem_rtx = gen_rtx_MEM (mode,\n-\t\t\t\t     gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t\t   stack_pointer_rtx,\n-\t\t\t\t\t\t   GEN_INT (offset)));\n+\t  mem_rtx = gen_rtx_MEM (mode,\n+\t\t\t\t gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t       stack_pointer_rtx,\n+\t\t\t\t\t       GEN_INT (offset)));\n \n-\t      GO_IF_LEGITIMATE_ADDRESS (mode, XEXP (mem_rtx, 0), try_pre_dec);\n+\t  GO_IF_LEGITIMATE_ADDRESS (mode, XEXP (mem_rtx, 0), try_pre_dec);\n \n-\t      mem_rtx = NULL_RTX;\n+\t  if (! r0)\n+\t    abort ();\n+\t  mem_rtx = NULL_RTX;\n \n-\t    try_pre_dec:\n-\t      do\n-\t\tif (HAVE_PRE_DECREMENT\n-\t\t    && (offset_in_r0 - offset == GET_MODE_SIZE (mode)\n-\t\t\t|| mem_rtx == NULL_RTX\n-\t\t\t|| i == PR_REG || SPECIAL_REGISTER_P (i)))\n-\t\t  {\n-\t\t    pre_dec = gen_rtx_MEM (mode,\n-\t\t\t\t\t   gen_rtx_PRE_DEC (Pmode, r0));\n+\ttry_pre_dec:\n+\t  do\n+\t    if (HAVE_PRE_DECREMENT\n+\t\t&& (offset_in_r0 - offset == GET_MODE_SIZE (mode)\n+\t\t    || mem_rtx == NULL_RTX\n+\t\t    || reg == PR_REG || SPECIAL_REGISTER_P (reg)))\n+\t      {\n+\t\tpre_dec = gen_rtx_MEM (mode,\n+\t\t\t\t       gen_rtx_PRE_DEC (Pmode, r0));\n \n-\t\t    GO_IF_LEGITIMATE_ADDRESS (mode, XEXP (pre_dec, 0),\n-\t\t\t\t\t      pre_dec_ok);\n+\t\tGO_IF_LEGITIMATE_ADDRESS (mode, XEXP (pre_dec, 0),\n+\t\t\t\t\t  pre_dec_ok);\n \n-\t\t    pre_dec = NULL_RTX;\n+\t\tpre_dec = NULL_RTX;\n \n-\t\t    break;\n+\t\tbreak;\n \n-\t\t  pre_dec_ok:\n-\t\t    mem_rtx = NULL_RTX;\n-\t\t    offset += GET_MODE_SIZE (mode);\n-\t\t  }\n-\t      while (0);\n+\t      pre_dec_ok:\n+\t\tmem_rtx = NULL_RTX;\n+\t\toffset += GET_MODE_SIZE (mode);\n+\t      }\n+\t  while (0);\n \n-\t      if (mem_rtx != NULL_RTX)\n-\t\tgoto addr_ok;\n+\t  if (mem_rtx != NULL_RTX)\n+\t    goto addr_ok;\n \n-\t      if (offset_in_r0 == -1)\n-\t\t{\n-\t\t  emit_move_insn (r0, GEN_INT (offset));\n-\t\t  offset_in_r0 = offset;\n-\t\t}\n-\t      else if (offset != offset_in_r0)\n+\t  if (offset_in_r0 == -1)\n+\t    {\n+\t      emit_move_insn (r0, GEN_INT (offset));\n+\t      offset_in_r0 = offset;\n+\t    }\n+\t  else if (offset != offset_in_r0)\n+\t    {\n+\t      emit_move_insn (r0,\n+\t\t\t      gen_rtx_PLUS\n+\t\t\t      (Pmode, r0,\n+\t\t\t       GEN_INT (offset - offset_in_r0)));\n+\t      offset_in_r0 += offset - offset_in_r0;\n+\t    }\n+\t\t\t\t\t      \n+\t  if (pre_dec != NULL_RTX)\n+\t    {\n+\t      if (! sp_in_r0)\n \t\t{\n \t\t  emit_move_insn (r0,\n \t\t\t\t  gen_rtx_PLUS\n-\t\t\t\t  (Pmode, r0,\n-\t\t\t\t   GEN_INT (offset - offset_in_r0)));\n-\t\t  offset_in_r0 += offset - offset_in_r0;\n+\t\t\t\t  (Pmode, r0, stack_pointer_rtx));\n+\t\t  sp_in_r0 = 1;\n \t\t}\n-\t\t\t\t\t\t  \n-\t      if (pre_dec != NULL_RTX)\n-\t\t{\n-\t\t  if (! sp_in_r0)\n-\t\t    {\n-\t\t      emit_move_insn (r0,\n-\t\t\t\t      gen_rtx_PLUS\n-\t\t\t\t      (Pmode, r0, stack_pointer_rtx));\n-\t\t      sp_in_r0 = 1;\n-\t\t    }\n \n-\t\t  offset -= GET_MODE_SIZE (mode);\n-\t\t  offset_in_r0 -= GET_MODE_SIZE (mode);\n+\t      offset -= GET_MODE_SIZE (mode);\n+\t      offset_in_r0 -= GET_MODE_SIZE (mode);\n \n-\t\t  mem_rtx = pre_dec;\n-\t\t}\n-\t      else if (sp_in_r0)\n-\t\tmem_rtx = gen_rtx_MEM (mode, r0);\n-\t      else\n-\t\tmem_rtx = gen_rtx_MEM (mode,\n-\t\t\t\t       gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t\t     stack_pointer_rtx,\n-\t\t\t\t\t\t     r0));\n-\n-\t      /* We must not use an r0-based address for target-branch\n-\t\t registers or for special registers without pre-dec\n-\t\t memory addresses, since we store their values in r0\n-\t\t first.  */\n-\t      if (TARGET_REGISTER_P (i)\n-\t\t  || ((i == PR_REG || SPECIAL_REGISTER_P (i))\n-\t\t      && mem_rtx != pre_dec))\n-\t\tabort ();\n-\n-\t    addr_ok:\n-\t      if (TARGET_REGISTER_P (i)\n-\t\t  || ((i == PR_REG || SPECIAL_REGISTER_P (i))\n-\t\t      && mem_rtx != pre_dec))\n-\t\t{\n-\t\t  rtx r0mode = gen_rtx_REG (GET_MODE (reg_rtx), R0_REG);\n+\t      mem_rtx = pre_dec;\n+\t    }\n+\t  else if (sp_in_r0)\n+\t    mem_rtx = gen_rtx_MEM (mode, r0);\n+\t  else\n+\t    mem_rtx = gen_rtx_MEM (mode,\n+\t\t\t\t   gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t\t r0));\n+\n+\t  /* We must not use an r0-based address for target-branch\n+\t     registers or for special registers without pre-dec\n+\t     memory addresses, since we store their values in r0\n+\t     first.  */\n+\t  if (TARGET_REGISTER_P (reg)\n+\t      || ((reg == PR_REG || SPECIAL_REGISTER_P (reg))\n+\t\t  && mem_rtx != pre_dec))\n+\t    abort ();\n+\n+\taddr_ok:\n+\t  if (TARGET_REGISTER_P (reg)\n+\t      || ((reg == PR_REG || SPECIAL_REGISTER_P (reg))\n+\t\t  && mem_rtx != pre_dec))\n+\t    {\n+\t      rtx tmp_reg = gen_rtx_REG (GET_MODE (reg_rtx), *tmp_pnt);\n \n-\t\t  emit_move_insn (r0mode, reg_rtx);\n+\t      emit_move_insn (tmp_reg, reg_rtx);\n \n+\t      if (REGNO (tmp_reg) == R0_REG)\n+\t\t{\n \t\t  offset_in_r0 = -1;\n \t\t  sp_in_r0 = 0;\n-\n-\t\t  reg_rtx = r0mode;\n+\t\t  if (refers_to_regno_p (R0_REG, R0_REG+1, mem_rtx, (rtx *) 0))\n+\t\t    abort ();\n \t\t}\n \n-\t      emit_move_insn (mem_rtx, reg_rtx);\n+\t      if (*++tmp_pnt <= 0)\n+\t\ttmp_pnt = schedule.temps;\n+\n+\t      reg_rtx = tmp_reg;\n \t    }\n+\t  {\n+\t    rtx insn;\n+\n+\t    /* Mark as interesting for dwarf cfi generator */\n+\t    insn = emit_move_insn (mem_rtx, reg_rtx);\n+\t    RTX_FRAME_RELATED_P (insn) = 1;\n+\n+\t    if (TARGET_SHCOMPACT && (offset_in_r0 != -1)) \n+\t      {\n+\t\trtx reg_rtx = gen_rtx_REG (mode, reg);\n+\t\trtx set, note_rtx;\n+\t\trtx mem_rtx = gen_rtx_MEM (mode,\n+\t\t\t\t\t   gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t\t\t GEN_INT (offset)));\n+\n+\t\tset = gen_rtx_SET (VOIDmode, mem_rtx, reg_rtx);\n+\t\tnote_rtx = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, set,\n+\t\t\t\t\t      REG_NOTES (insn));\n+\t\tREG_NOTES (insn) = note_rtx;\n+\t      }\n+\t  }\n+\t}\n \n-      if (offset != d_rounding)\n+      if (entry->offset != d_rounding)\n \tabort ();\n     }\n   else\n@@ -5258,7 +5448,7 @@ sh_expand_prologue ()\n   target_flags = save_flags;\n \n   output_stack_adjust (-rounded_frame_size (d) + d_rounding,\n-\t\t       stack_pointer_rtx, TARGET_SH5 ? 0 : 1, frame_insn);\n+\t\t       stack_pointer_rtx, 0, NULL);\n \n   if (frame_pointer_needed)\n     frame_insn (GEN_MOV (frame_pointer_rtx, stack_pointer_rtx));\n@@ -5318,7 +5508,7 @@ sh_expand_epilogue ()\n \n   if (frame_pointer_needed)\n     {\n-      output_stack_adjust (frame_size, frame_pointer_rtx, 7, emit_insn);\n+      output_stack_adjust (frame_size, frame_pointer_rtx, 1, &live_regs_mask);\n \n       /* We must avoid moving the stack pointer adjustment past code\n \t which reads from the local frame, else an interrupt could\n@@ -5334,7 +5524,7 @@ sh_expand_epilogue ()\n \t occur after the SP adjustment and clobber data in the local\n \t frame.  */\n       emit_insn (gen_blockage ());\n-      output_stack_adjust (frame_size, stack_pointer_rtx, 7, emit_insn);\n+      output_stack_adjust (frame_size, stack_pointer_rtx, 1, &live_regs_mask);\n     }\n \n   if (SHMEDIA_REGS_STACK_ADJUST ())\n@@ -5355,143 +5545,126 @@ sh_expand_epilogue ()\n     emit_insn (gen_toggle_sz ());\n   if (TARGET_SH5)\n     {\n-      int offset = d_rounding;\n+      int offset_base, offset;\n       int offset_in_r0 = -1;\n       int sp_in_r0 = 0;\n-      int align;\n       rtx r0 = gen_rtx_REG (Pmode, R0_REG);\n-      int tmp_regno = R20_REG;\n+      save_schedule schedule;\n+      save_entry *entry;\n+      int *tmp_pnt;\n       \n-      /* We loop twice: first, we save 8-byte aligned registers in the\n-\t higher addresses, that are known to be aligned.  Then, we\n-\t proceed to saving 32-bit registers that don't need 8-byte\n-\t alignment.  */\n-      for (align = 0; align <= 1; align++)\n-\tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t  if (TEST_HARD_REG_BIT (live_regs_mask, i))\n-\t    {\n-\t      enum machine_mode mode = REGISTER_NATURAL_MODE (i);\n-\t      int reg = i;\n-\t      rtx reg_rtx, mem_rtx, post_inc = NULL_RTX, insn;\n+      entry = sh5_schedule_saves (&live_regs_mask, &schedule, d_rounding);\n+      offset_base = -entry[1].offset + d_rounding;\n+      tmp_pnt = schedule.temps;\n+      for (; entry->mode != VOIDmode; entry--)\n+\t{\n+\t  enum machine_mode mode = entry->mode;\n+\t  int reg = entry->reg;\n+\t  rtx reg_rtx, mem_rtx, post_inc = NULL_RTX, insn;\n \n-\t      if (mode == SFmode && (i % 2) == 0\n-\t\t  && ! TARGET_FPU_SINGLE && FP_REGISTER_P (i)\n-\t\t  && (TEST_HARD_REG_BIT (live_regs_mask, (i ^ 1))))\n-\t\t{\n-\t\t  mode = DFmode;\n-\t\t  i++;\n-\t\t}\n+\t  offset = offset_base + entry->offset;\n+\t  reg_rtx = gen_rtx_REG (mode, reg);\n \n-\t      /* If we're doing the aligned pass and this is not aligned,\n-\t\t or we're doing the unaligned pass and this is aligned,\n-\t\t skip it.  */\n-\t      if ((GET_MODE_SIZE (mode) % (STACK_BOUNDARY / BITS_PER_UNIT)\n-\t\t   == 0) != align)\n-\t\tcontinue;\n+\t  mem_rtx = gen_rtx_MEM (mode,\n+\t\t\t\t gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t       stack_pointer_rtx,\n+\t\t\t\t\t       GEN_INT (offset)));\n \n-\t      reg_rtx = gen_rtx_REG (mode, reg);\n+\t  GO_IF_LEGITIMATE_ADDRESS (mode, XEXP (mem_rtx, 0), try_post_inc);\n \n-\t      mem_rtx = gen_rtx_MEM (mode,\n-\t\t\t\t     gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t\t   stack_pointer_rtx,\n-\t\t\t\t\t\t   GEN_INT (offset)));\n+\t  mem_rtx = NULL_RTX;\n \n-\t      GO_IF_LEGITIMATE_ADDRESS (mode, XEXP (mem_rtx, 0), try_post_inc);\n+\ttry_post_inc:\n+\t  do\n+\t    if (HAVE_POST_INCREMENT\n+\t\t&& (offset == offset_in_r0\n+\t\t    || (offset + GET_MODE_SIZE (mode) != d + d_rounding\n+\t\t\t&& mem_rtx == NULL_RTX)\n+\t\t    || reg == PR_REG || SPECIAL_REGISTER_P (reg)))\n+\t      {\n+\t\tpost_inc = gen_rtx_MEM (mode,\n+\t\t\t\t\tgen_rtx_POST_INC (Pmode, r0));\n \n-\t      mem_rtx = NULL_RTX;\n+\t\tGO_IF_LEGITIMATE_ADDRESS (mode, XEXP (post_inc, 0),\n+\t\t\t\t\t  post_inc_ok);\n \n-\t    try_post_inc:\n-\t      do\n-\t\tif (HAVE_POST_INCREMENT\n-\t\t    && (offset == offset_in_r0\n-\t\t\t|| (offset + GET_MODE_SIZE (mode) != d + d_rounding\n-\t\t\t    && mem_rtx == NULL_RTX)\n-\t\t\t|| i == PR_REG || SPECIAL_REGISTER_P (i)))\n-\t\t  {\n-\t\t    post_inc = gen_rtx_MEM (mode,\n-\t\t\t\t\t    gen_rtx_POST_INC (Pmode, r0));\n-\n-\t\t    GO_IF_LEGITIMATE_ADDRESS (mode, XEXP (post_inc, 0),\n-\t\t\t\t\t      post_inc_ok);\n+\t\tpost_inc = NULL_RTX;\n \n-\t\t    post_inc = NULL_RTX;\n+\t\tbreak;\n+\t\t\n+\t      post_inc_ok:\n+\t\tmem_rtx = NULL_RTX;\n+\t      }\n+\t  while (0);\n+\t  \n+\t  if (mem_rtx != NULL_RTX)\n+\t    goto addr_ok;\n \n-\t\t    break;\n-\t\t    \n-\t\t  post_inc_ok:\n-\t\t    mem_rtx = NULL_RTX;\n-\t\t  }\n-\t      while (0);\n+\t  if (offset_in_r0 == -1)\n+\t    {\n+\t      emit_move_insn (r0, GEN_INT (offset));\n+\t      offset_in_r0 = offset;\n+\t    }\n+\t  else if (offset != offset_in_r0)\n+\t    {\n+\t      emit_move_insn (r0,\n+\t\t\t      gen_rtx_PLUS\n+\t\t\t      (Pmode, r0,\n+\t\t\t       GEN_INT (offset - offset_in_r0)));\n+\t      offset_in_r0 += offset - offset_in_r0;\n+\t    }\n \t      \n-\t      if (mem_rtx != NULL_RTX)\n-\t\tgoto addr_ok;\n-\n-\t      if (offset_in_r0 == -1)\n-\t\t{\n-\t\t  emit_move_insn (r0, GEN_INT (offset));\n-\t\t  offset_in_r0 = offset;\n-\t\t}\n-\t      else if (offset != offset_in_r0)\n+\t  if (post_inc != NULL_RTX)\n+\t    {\n+\t      if (! sp_in_r0)\n \t\t{\n \t\t  emit_move_insn (r0,\n \t\t\t\t  gen_rtx_PLUS\n-\t\t\t\t  (Pmode, r0,\n-\t\t\t\t   GEN_INT (offset - offset_in_r0)));\n-\t\t  offset_in_r0 += offset - offset_in_r0;\n+\t\t\t\t  (Pmode, r0, stack_pointer_rtx));\n+\t\t  sp_in_r0 = 1;\n \t\t}\n-\t\t  \n-\t      if (post_inc != NULL_RTX)\n-\t\t{\n-\t\t  if (! sp_in_r0)\n-\t\t    {\n-\t\t      emit_move_insn (r0,\n-\t\t\t\t      gen_rtx_PLUS\n-\t\t\t\t      (Pmode, r0, stack_pointer_rtx));\n-\t\t      sp_in_r0 = 1;\n-\t\t    }\n-\t\t  \n-\t\t  mem_rtx = post_inc;\n+\t      \n+\t      mem_rtx = post_inc;\n \n-\t\t  offset_in_r0 += GET_MODE_SIZE (mode);\n-\t\t}\n-\t      else if (sp_in_r0)\n-\t\tmem_rtx = gen_rtx_MEM (mode, r0);\n-\t      else\n-\t\tmem_rtx = gen_rtx_MEM (mode,\n-\t\t\t\t       gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t\t     stack_pointer_rtx,\n-\t\t\t\t\t\t     r0));\n-\n-\t      if ((i == PR_REG || SPECIAL_REGISTER_P (i))\n-\t\t  && mem_rtx != post_inc)\n-\t\tabort ();\n-\n-\t    addr_ok:\n-\t      if ((i == PR_REG || SPECIAL_REGISTER_P (i))\n-\t\t  && mem_rtx != post_inc)\n-\t\t{\n-\t\t  insn = emit_move_insn (r0, mem_rtx);\n-\t\t  mem_rtx = r0;\n-\t\t}\n-\t      else if (TARGET_REGISTER_P (i))\n-\t\t{\n-\t\t  rtx tmp_reg = gen_rtx_REG (mode, tmp_regno);\n-\n-\t\t  /* Give the scheduler a bit of freedom by using R20..R23\n-\t\t     in a round-robin fashion.  Don't use R1 here because\n-\t\t     we want to use it for EH_RETURN_STACKADJ_RTX.  */\n-\t\t  insn = emit_move_insn (tmp_reg, mem_rtx);\n-\t\t  mem_rtx = tmp_reg;\n-\t\t  if (++tmp_regno > R23_REG)\n-\t\t    tmp_regno = R20_REG;\n-\t\t}\n+\t      offset_in_r0 += GET_MODE_SIZE (mode);\n+\t    }\n+\t  else if (sp_in_r0)\n+\t    mem_rtx = gen_rtx_MEM (mode, r0);\n+\t  else\n+\t    mem_rtx = gen_rtx_MEM (mode,\n+\t\t\t\t   gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t\t r0));\n \n-\t      insn = emit_move_insn (reg_rtx, mem_rtx);\n+\t  if ((reg == PR_REG || SPECIAL_REGISTER_P (reg))\n+\t      && mem_rtx != post_inc)\n+\t    abort ();\n \n-\t      offset += GET_MODE_SIZE (mode);\n+\taddr_ok:\n+\t  if ((reg == PR_REG || SPECIAL_REGISTER_P (reg))\n+\t      && mem_rtx != post_inc)\n+\t    {\n+\t      insn = emit_move_insn (r0, mem_rtx);\n+\t      mem_rtx = r0;\n+\t    }\n+\t  else if (TARGET_REGISTER_P (reg))\n+\t    {\n+\t      rtx tmp_reg = gen_rtx_REG (mode, *tmp_pnt);\n+\n+\t      /* Give the scheduler a bit of freedom by using up to\n+\t\t MAX_TEMPS registers in a round-robin fashion.  */\n+\t      insn = emit_move_insn (tmp_reg, mem_rtx);\n+\t      mem_rtx = tmp_reg;\n+\t      if (*++tmp_pnt < 0)\n+\t\ttmp_pnt = schedule.temps;\n \t    }\n \n-      if (offset != d + d_rounding)\n+\t  insn = emit_move_insn (reg_rtx, mem_rtx);\n+\n+\t  offset += GET_MODE_SIZE (mode);\n+\t}\n+\n+      if (entry->offset + offset_base != d + d_rounding)\n \tabort ();\n     }\n   else /* ! TARGET_SH5 */\n@@ -5521,7 +5694,7 @@ sh_expand_epilogue ()\n   output_stack_adjust (extra_push + current_function_pretend_args_size\n \t\t       + save_size + d_rounding\n \t\t       + current_function_args_info.stack_regs * 8,\n-\t\t       stack_pointer_rtx, 7, emit_insn);\n+\t\t       stack_pointer_rtx, 1, NULL);\n \n   if (current_function_calls_eh_return)\n     emit_insn (GEN_ADD3 (stack_pointer_rtx, stack_pointer_rtx,\n@@ -5566,7 +5739,6 @@ sh_set_return_address (ra, tmp)\n {\n   HARD_REG_SET live_regs_mask;\n   int d;\n-  int d_rounding = 0;\n   int pr_reg = TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG;\n   int pr_offset;\n \n@@ -5598,56 +5770,26 @@ sh_set_return_address (ra, tmp)\n \n   if (TARGET_SH5)\n     {\n-      int i;\n       int offset;\n-      int align;\n+      save_schedule schedule;\n+      save_entry *entry;\n       \n-      if (d % (STACK_BOUNDARY / BITS_PER_UNIT))\n-\td_rounding = ((STACK_BOUNDARY / BITS_PER_UNIT)\n-\t\t      - d % (STACK_BOUNDARY / BITS_PER_UNIT));\n-\n-      offset = 0;\n-\n-      /* We loop twice: first, we save 8-byte aligned registers in the\n-\t higher addresses, that are known to be aligned.  Then, we\n-\t proceed to saving 32-bit registers that don't need 8-byte\n-\t alignment.  */\n-      for (align = 0; align <= 1; align++)\n-\tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t  if (TEST_HARD_REG_BIT (live_regs_mask, i))\n-\t    {\n-\t      enum machine_mode mode = REGISTER_NATURAL_MODE (i);\n-\n-\t      if (mode == SFmode && (i % 2) == 0\n-\t\t  && ! TARGET_FPU_SINGLE && FP_REGISTER_P (i)\n-\t\t  && (TEST_HARD_REG_BIT (live_regs_mask, (i ^ 1))))\n-\t\t{\n-\t\t  mode = DFmode;\n-\t\t  i++;\n-\t\t}\n-\n-\t      /* If we're doing the aligned pass and this is not aligned,\n-\t\t or we're doing the unaligned pass and this is aligned,\n-\t\t skip it.  */\n-\t      if ((GET_MODE_SIZE (mode) % (STACK_BOUNDARY / BITS_PER_UNIT)\n-\t\t   == 0) != align)\n-\t\tcontinue;\n-\n-\t      if (i == pr_reg)\n-\t\tgoto found;\n-\n-\t      offset += GET_MODE_SIZE (mode);\n-\t    }\n+      entry = sh5_schedule_saves (&live_regs_mask, &schedule, 0);\n+      offset = entry[1].offset;\n+      for (; entry->mode != VOIDmode; entry--)\n+\tif (entry->reg == pr_reg)\n+\t  goto found;\n \n       /* We can't find pr register.  */\n       abort ();\n \n     found:\n-      pr_offset = (rounded_frame_size (d) - d_rounding + offset\n+      offset = entry->offset - offset;\n+      pr_offset = (rounded_frame_size (d) + offset\n \t\t   + SHMEDIA_REGS_STACK_ADJUST ());\n     }\n   else\n-    pr_offset = rounded_frame_size (d) - d_rounding;\n+    pr_offset = rounded_frame_size (d);\n \n   emit_insn (GEN_MOV (tmp, GEN_INT (pr_offset)));\n   emit_insn (GEN_ADD3 (tmp, tmp, frame_pointer_rtx));\n@@ -6188,9 +6330,10 @@ initial_elimination_offset (from, to)\n     {\n       if (TARGET_SH5)\n \t{\n-\t  int i, n = total_saved_regs_space;\n-\t  int align;\n+\t  int n = total_saved_regs_space;\n \t  int pr_reg = TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG;\n+\t  save_schedule schedule;\n+\t  save_entry *entry;\n \t  \n \t  n += total_auto_space;\n \n@@ -6200,40 +6343,13 @@ initial_elimination_offset (from, to)\n \n \t  target_flags = copy_flags;\n \n-\t  /* We loop twice: first, check 8-byte aligned registers,\n-\t     that are stored in the higher addresses, that are known\n-\t     to be aligned.  Then, check 32-bit registers that don't\n-\t     need 8-byte alignment.  */\n-\t  for (align = 1; align >= 0; align--)\n-\t    for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n-\t      if (TEST_HARD_REG_BIT (live_regs_mask, i))\n-\t\t{\n-\t\t  enum machine_mode mode = REGISTER_NATURAL_MODE (i);\n-\n-\t\t  if (mode == SFmode && (i % 2) == 1\n-\t\t      && ! TARGET_FPU_SINGLE && FP_REGISTER_P (i)\n-\t\t      && TEST_HARD_REG_BIT (live_regs_mask, (i ^ 1)))\n-\t\t    {\n-\t\t      mode = DFmode;\n-\t\t      i--;\n-\t\t    }\n-\t\t\n-\t\t  /* If we're doing the aligned pass and this is not aligned,\n-\t\t     or we're doing the unaligned pass and this is aligned,\n-\t\t     skip it.  */\n-\t\t  if ((GET_MODE_SIZE (mode) % (STACK_BOUNDARY / BITS_PER_UNIT)\n-\t\t       == 0) != align)\n-\t\t    continue;\n-\n-\t\t  n -= GET_MODE_SIZE (mode);\n-\n-\t\t  if (i == pr_reg)\n-\t\t    {\n-\t\t      target_flags = save_flags;\n-\t\t      return n;\n-\t\t    }\n-\t\t}\n-\n+\t  sh5_schedule_saves (&live_regs_mask, &schedule, n);\n+\t  for (entry = &schedule.entries[1]; entry->mode != VOIDmode; entry++)\n+\t    if (entry->reg == pr_reg)\n+\t      {\n+\t\ttarget_flags = save_flags;\n+\t\treturn entry->offset;\n+\t      }\n \t  abort ();\n \t}\n       else\n@@ -8705,4 +8821,22 @@ function_symbol (const char *name)\n   return sym;\n }\n \n+/* Find the number of a general purpose register in S.  */\n+static int\n+scavenge_reg (HARD_REG_SET *s)\n+{\n+  int r;\n+  for (r = FIRST_GENERAL_REG; r <= LAST_GENERAL_REG; r++)\n+    if (TEST_HARD_REG_BIT (*s, r))\n+      return r;\n+  return -1;\n+}\n+\n+rtx\n+sh_get_pr_initial_val (void)\n+{\n+  return\n+    get_hard_reg_initial_val (Pmode, TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG);\n+}\n+\n #include \"gt-sh.h\""}, {"sha": "cf97d9129bc559181b740c899e3675b61c511cb6", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 47, "deletions": 28, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fada196198e4c9350a78fe08c7a132bb4055ba05/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fada196198e4c9350a78fe08c7a132bb4055ba05/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=fada196198e4c9350a78fe08c7a132bb4055ba05", "patch": "@@ -591,6 +591,13 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define UNITS_PER_WORD\t(TARGET_SHMEDIA ? 8 : 4)\n #define MIN_UNITS_PER_WORD 4\n \n+/* Scaling factor for Dwarf data offsets for CFI information.\n+   The dwarf2out.c default would use -UNITS_PER_WORD, which is -8 for\n+   SHmedia; however, since we do partial register saves for the registers\n+   visible to SHcompact, and for target registers for SHMEDIA32, we have\n+   to allow saves that are only 4-byte aligned.  */\n+#define DWARF_CIE_DATA_ALIGNMENT -4\n+\n /* Width in bits of a pointer.\n    See also the macro `Pmode' defined below.  */\n #define POINTER_SIZE  (TARGET_SHMEDIA64 ? 64 : 32)\n@@ -639,8 +646,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define LOCAL_ALIGNMENT(TYPE, ALIGN) \\\n   ((GET_MODE_CLASS (TYPE_MODE (TYPE)) == MODE_COMPLEX_INT \\\n     || GET_MODE_CLASS (TYPE_MODE (TYPE)) == MODE_COMPLEX_FLOAT) \\\n-   ? MIN (BIGGEST_ALIGNMENT, GET_MODE_BITSIZE (TYPE_MODE (TYPE))) \\\n-   : ALIGN)\n+   ? (unsigned) MIN (BIGGEST_ALIGNMENT, GET_MODE_BITSIZE (TYPE_MODE (TYPE))) \\\n+   : (unsigned) ALIGN)\n \n /* Make arrays of chars word-aligned for the same reasons.  */\n #define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n@@ -816,16 +823,18 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n #define LAST_TARGET_REG  (FIRST_TARGET_REG + (TARGET_SHMEDIA ? 7 : -1))\n \n #define GENERAL_REGISTER_P(REGNO) \\\n-  IN_RANGE ((REGNO), FIRST_GENERAL_REG, LAST_GENERAL_REG)\n+  IN_RANGE ((REGNO), \\\n+\t    (unsigned HOST_WIDE_INT) FIRST_GENERAL_REG, \\\n+\t    (unsigned HOST_WIDE_INT) LAST_GENERAL_REG)\n \n #define GENERAL_OR_AP_REGISTER_P(REGNO) \\\n   (GENERAL_REGISTER_P (REGNO) || ((REGNO) == AP_REG))\n \n #define FP_REGISTER_P(REGNO) \\\n-  ((REGNO) >= FIRST_FP_REG && (REGNO) <= LAST_FP_REG)\n+  ((int) (REGNO) >= FIRST_FP_REG && (int) (REGNO) <= LAST_FP_REG)\n \n #define XD_REGISTER_P(REGNO) \\\n-  ((REGNO) >= FIRST_XD_REG && (REGNO) <= LAST_XD_REG)\n+  ((int) (REGNO) >= FIRST_XD_REG && (int) (REGNO) <= LAST_XD_REG)\n \n #define FP_OR_XD_REGISTER_P(REGNO) \\\n   (FP_REGISTER_P (REGNO) || XD_REGISTER_P (REGNO))\n@@ -838,7 +847,7 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n    || (REGNO) == MACH_REG || (REGNO) == MACL_REG)\n \n #define TARGET_REGISTER_P(REGNO) \\\n-  ((REGNO) >= FIRST_TARGET_REG && (REGNO) <= LAST_TARGET_REG)\n+  ((int) (REGNO) >= FIRST_TARGET_REG && (int) (REGNO) <= LAST_TARGET_REG)\n \n #define SHMEDIA_REGISTER_P(REGNO) \\\n   (GENERAL_REGISTER_P (REGNO) || FP_REGISTER_P (REGNO) \\\n@@ -951,7 +960,8 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n   (TARGET_SHMEDIA32 \\\n    && GET_MODE_SIZE (MODE) > 4 \\\n    && (((REGNO) >= FIRST_GENERAL_REG + 10 \\\n-        && (REGNO) <= FIRST_GENERAL_REG + 14) \\\n+        && (REGNO) <= FIRST_GENERAL_REG + 15) \\\n+       || TARGET_REGISTER_P (REGNO) \\\n        || (REGNO) == PR_MEDIA_REG))\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n@@ -1137,7 +1147,7 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n        ? (unsigned HOST_WIDE_INT) int_size_in_bytes (TYPE) \\\n        : GET_MODE_SIZE (TYPE_MODE (TYPE))) > 8) \\\n    : (TYPE_MODE (TYPE) == BLKmode \\\n-      || TARGET_HITACHI && TREE_CODE (TYPE) == RECORD_TYPE))\n+      || (TARGET_HITACHI && TREE_CODE (TYPE) == RECORD_TYPE)))\n \n /* Don't default to pcc-struct-return, because we have already specified\n    exactly how to return structures in the RETURN_IN_MEMORY macro.  */\n@@ -1273,7 +1283,7 @@ enum reg_class\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n \n-extern int regno_reg_class[FIRST_PSEUDO_REGISTER];\n+extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n #define REGNO_REG_CLASS(REGNO) regno_reg_class[(REGNO)]\n \n /* When defined, the compiler allows registers explicitly used in the\n@@ -1363,7 +1373,9 @@ extern enum reg_class reg_class_from_letter[];\n #define CONSTRAINT_LEN(C,STR) \\\n   (((C) == 'L' || (C) == 'O' || (C) == 'D' || (C) == 'T' || (C) == 'U' \\\n     || (C) == 'Y' \\\n-    || ((C) == 'I' && (((STR)[1] != '0' && (STR)[1] != '1') || ! isdigit ((STR)[2]))) \\\n+    || ((C) == 'I' \\\n+        && (((STR)[1] != '0' && (STR)[1] != '1') \\\n+\t    || (STR)[2] < '0' || (STR)[2] > '9')) \\\n     || ((C) == 'B' && ((STR)[1] != 's' || (STR)[2] != 'c')) \\\n     || ((C) == 'J' && ((STR)[1] != '1' || (STR)[2] != '6')) \\\n     || ((C) == 'K' && ((STR)[1] != '0' || (STR)[2] != '8')) \\\n@@ -1667,12 +1679,15 @@ extern enum reg_class reg_class_from_letter[];\n    || (TARGET_SHMEDIA_FPU && (REGNO) == FIRST_FP_RET_REG))\n \n /* 1 if N is a possible register number for function argument passing.  */\n+/* ??? There are some callers that pass REGNO as int, and others that pass\n+   it as unsigned.  We get warnings unless we do casts everywhere.  */\n #define FUNCTION_ARG_REGNO_P(REGNO) \\\n-  (((REGNO) >= FIRST_PARM_REG && (REGNO) < (FIRST_PARM_REG\t\t\\\n-\t\t\t\t\t    + NPARM_REGS (SImode)))\t\\\n+  (((unsigned) (REGNO) >= (unsigned) FIRST_PARM_REG\t\t\t\\\n+    && (unsigned) (REGNO) < (unsigned) (FIRST_PARM_REG + NPARM_REGS (SImode)))\\\n    || (TARGET_FPU_ANY                                                   \\\n-       && (REGNO) >= FIRST_FP_PARM_REG && (REGNO) < (FIRST_FP_PARM_REG\t\\\n-\t\t\t\t\t\t     + NPARM_REGS (SFmode))))\n+       && (unsigned) (REGNO) >= (unsigned) FIRST_FP_PARM_REG\t\t\\\n+       && (unsigned) (REGNO) < (unsigned) (FIRST_FP_PARM_REG\t\t\\\n+\t\t\t\t\t   + NPARM_REGS (SFmode))))\n \f\n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should\n@@ -2057,13 +2072,13 @@ struct sh_args {\n \t     (VOIDmode,\t\t\t\t\t\t\t\\\n \t      gen_rtx_REG (SFmode,\t\t\t\t\t\\\n \t\t\t   BASE_ARG_REG (MODE)\t\t\t\t\\\n-\t\t\t   + ROUND_REG ((CUM), (MODE)) ^ 1),\t\t\\\n+\t\t\t   + (ROUND_REG ((CUM), (MODE)) ^ 1)),\t\t\\\n \t      const0_rtx)),\t\t\t\t\t\t\\\n \t    (gen_rtx_EXPR_LIST\t\t\t\t\t\t\\\n \t     (VOIDmode,\t\t\t\t\t\t\t\\\n \t      gen_rtx_REG (SFmode,\t\t\t\t\t\\\n \t\t\t   BASE_ARG_REG (MODE)\t\t\t\t\\\n-\t\t\t   + (ROUND_REG ((CUM), (MODE)) + 1) ^ 1),\t\\\n+\t\t\t   + ((ROUND_REG ((CUM), (MODE)) + 1) ^ 1)),\t\\\n \t      GEN_INT (4)))))))\t\t\t\t\t\t\\\n       : gen_rtx_REG ((MODE),\t\t\t\t\t\t\\\n \t\t     ((BASE_ARG_REG (MODE) + ROUND_REG ((CUM), (MODE))) \\\n@@ -2311,9 +2326,7 @@ while (0)\n    can ignore COUNT.  */\n \n #define RETURN_ADDR_RTX(COUNT, FRAME)\t\\\n-  (((COUNT) == 0)\t\t\t\t\\\n-   ? get_hard_reg_initial_val (Pmode, TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG) \\\n-   : (rtx) 0)\n+  (((COUNT) == 0) ? sh_get_pr_initial_val () : (rtx) 0)\n \n /* A C expression whose value is RTL representing the location of the\n    incoming return address at the beginning of any function, before the\n@@ -2322,6 +2335,11 @@ while (0)\n    the stack.  */\n #define INCOMING_RETURN_ADDR_RTX \\\n   gen_rtx_REG (Pmode, TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG)\n+\n+/* libstdc++-v3/libsupc++/eh_personality.cc:__gxx_personality_v0\n+   can get confused by SHmedia return addresses when it does:\n+   ip = _Unwind_GetIP (context) - 1;  */\n+#define RETURN_ADDR_OFFSET (TARGET_SH5 ? -1 : 0)\n \f\n /* Generate necessary RTL for __builtin_saveregs().  */\n #define EXPAND_BUILTIN_SAVEREGS() sh_builtin_saveregs ()\n@@ -3085,18 +3103,18 @@ while (0)\n \n #define SH_DBX_REGISTER_NUMBER(REGNO) \\\n   (GENERAL_REGISTER_P (REGNO) \\\n-   ? ((REGNO) - FIRST_GENERAL_REG) \\\n+   ? ((unsigned) (REGNO) - FIRST_GENERAL_REG) \\\n    : FP_REGISTER_P (REGNO) \\\n-   ? ((REGNO) - FIRST_FP_REG + (TARGET_SH5 ? (TARGET_SHCOMPACT ? 245 \\\n-\t\t\t\t\t      : 77) : 25)) \\\n+   ? ((unsigned) (REGNO) - FIRST_FP_REG \\\n+      + (TARGET_SH5 ? (TARGET_SHCOMPACT ? 245 : 77) : 25)) \\\n    : XD_REGISTER_P (REGNO) \\\n-   ? ((REGNO) - FIRST_XD_REG + (TARGET_SH5 ? 289 : 87)) \\\n+   ? ((unsigned) (REGNO) - FIRST_XD_REG + (TARGET_SH5 ? 289 : 87)) \\\n    : TARGET_REGISTER_P (REGNO) \\\n-   ? ((REGNO) - FIRST_TARGET_REG + 68) \\\n+   ? ((unsigned) (REGNO) - FIRST_TARGET_REG + 68) \\\n    : (REGNO) == PR_REG \\\n    ? (TARGET_SH5 ? 241 : 17) \\\n    : (REGNO) == PR_MEDIA_REG \\\n-   ? (TARGET_SH5 ? 18 : -1) \\\n+   ? (TARGET_SH5 ? 18 : (unsigned) -1) \\\n    : (REGNO) == T_REG \\\n    ? (TARGET_SH5 ? 242 : 18) \\\n    : (REGNO) == GBR_REG \\\n@@ -3107,7 +3125,7 @@ while (0)\n    ? (TARGET_SH5 ? 240 : 21) \\\n    : (REGNO) == FPUL_REG \\\n    ? (TARGET_SH5 ? 244 : 23) \\\n-   : -1)\n+   : (unsigned) -1)\n \n /* This is how to output a reference to a symbol_ref.  On SH5,\n    references to non-code symbols must be preceded by `datalabel'.  */\n@@ -3449,9 +3467,10 @@ extern int rtx_equal_function_value_matters;\n   (TARGET_SH5 ? DWARF_FRAME_REGNUM (PR_MEDIA_REG) : DWARF_FRAME_REGNUM (PR_REG))\n \n #define EH_RETURN_DATA_REGNO(N)\t\\\n-  ((N) < 4 ? (N) + (TARGET_SH5 ? 2 : 4) : INVALID_REGNUM)\n+  ((N) < 4 ? (N) + (TARGET_SH5 ? 2U : 4U) : INVALID_REGNUM)\n \n-#define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM)\n+#define EH_RETURN_STACKADJ_REGNO STATIC_CHAIN_REGNUM\n+#define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, EH_RETURN_STACKADJ_REGNO)\n \n #if (defined CRT_BEGIN || defined CRT_END) && ! __SHMEDIA__\n /* SH constant pool breaks the devices in crtstuff.c to control section"}, {"sha": "8e012d75f7b294aeaef87aac395227fa1fb7127c", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fada196198e4c9350a78fe08c7a132bb4055ba05/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fada196198e4c9350a78fe08c7a132bb4055ba05/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=fada196198e4c9350a78fe08c7a132bb4055ba05", "patch": "@@ -2052,7 +2052,7 @@\n \"\n {\n   enum machine_mode inmode = GET_MODE (operands[1]);\n-  int regno, offset = 0;\n+  int offset = 0;\n \n   if (GET_CODE (operands[0]) == SUBREG)\n     {\n@@ -7247,6 +7247,8 @@ mov.l\\\\t1f,r0\\\\n\\\\\n     {\n       rtx r18 = gen_rtx_REG (DImode, PR_MEDIA_REG);\n \n+      if (! call_used_regs[TR0_REG] || fixed_regs[TR0_REG])\n+\tabort ();\n       tr_regno = TR0_REG;\n       tr = gen_rtx_REG (DImode, tr_regno);\n       emit_move_insn (tr, r18);"}]}