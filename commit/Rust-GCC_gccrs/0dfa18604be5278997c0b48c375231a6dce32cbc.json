{"sha": "0dfa18604be5278997c0b48c375231a6dce32cbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRmYTE4NjA0YmU1Mjc4OTk3YzBiNDhjMzc1MjMxYTZkY2UzMmNiYw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@cygnus.com", "date": "1998-05-13T21:13:47Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-05-13T21:13:47Z"}, "message": "Makefile.in (HOST_RTL): Add $(HOST_PREFIX)bitmap.o.\n\n        * Makefile.in (HOST_RTL): Add $(HOST_PREFIX)bitmap.o.\n        (rtl.o, emit-rtl.o): Add dependency on bitmap.h.\n        ($(HOST_PREFIX_1)rtl.o): Likewise.\n        ($(HOST_PREFIX_1)bitmap.o): New host object.\n        * emit-rtl.c (toplevel): Include bitmap.h.\n        (gen_rtx): Handle 't' and 'b' nodes.\n        * print-rtl.c (print_rtx): Handle printing NOTE_INSN_LIVE notes.\n        Print block number for block begin/end notes.  Print 't' type\n        nodes as a pointer.  Know that the 3rd argument of live range\n        start/stop notes is really a range_info rtx.  If type is 'b', print\n        out argument as a bitmap.\n        * rtl.c: Include bitmap.c.\n        (copy_rtx): Copy tree nodes as is.  Copy bitmaps if type is 'b'.\n        (note_insn_name): Add NOTE_INSN_RANGE_{START,END}, NOTE_INSN_LIVE.\n        * rtl.def (RANGE_LIVE): New node to hold live information while we\n        recalculate the basic blocks.\n        (RANGE_REG, RANGE_INFO): New rtl types for live range splitting.\n        (RANGE_VAR): New node, to hold information saved in symbol node for New\n        communicating live range information to the debug output functions.\n        * rtl.h (rtunion_def): Add rttree and rtbit fields.\n        (XBITMAP, XTREE): New accessor macros.\n        (NOTE_LIVE_INFO): Overload NOTE_SOURCE_FILE for NOTE_INSN_LIVE notes.\n        (NOTE_RANGE_INFO): Similarly for NOTE_INSN_RANGE_{START,END} notes.\n        (NOTE_BLOCK_LIVE_RANGE_BLOCK): Define.\n        (NOTE_INSN_RANGE_START, NOTE_INSN_RANGE_END, NOTE_INSN_LIVE): New notes.\n        (RANGE_LIVE_{BITMAP,ORIG_BLOCK}): New accessor macros.\n        (RANGE_REG_{SYMBOL,BLOCK}_NODE, RANGE_VAR_*): New accessor macros.\n        (RANGE_INFO_*): Likewise.\n        * sched.c (sched_analyze): Keep live range start/stop notes.\n        (unlink_other_notes): Likewise.\n        * haifa-sched.c (sched_analyze): Keep live range start/stop notes.\n        (unlink_other_notes): Likewise.\n        * tree.h (BLOCK_LIVE_RANGE_{START,END,VAR_FLAG}): New accessor macros.\n        (BLOCK_LIVE_RANGE_FLAG): Likewise.\n        (DECL_LIVE_RANGE_RTL): Likewise.\n        (struct tree_block): Add live_range_flag, live_range_var_flag,\n        live_range_start and live_range_end.\n        (struct tree_decl): Add live_range_rtl field.\n        * gengenrtl.c (type_from_format): Handle 'b' and 't'.\n        (accessor_from_format): Likewise.\n\nCo-Authored-By: Jeffrey A Law <law@cygnus.com>\n\nFrom-SVN: r19727", "tree": {"sha": "0572802e1e05e433b41457699177ccc9b910db73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0572802e1e05e433b41457699177ccc9b910db73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0dfa18604be5278997c0b48c375231a6dce32cbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dfa18604be5278997c0b48c375231a6dce32cbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dfa18604be5278997c0b48c375231a6dce32cbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dfa18604be5278997c0b48c375231a6dce32cbc/comments", "author": null, "committer": null, "parents": [{"sha": "efdb35902230f6f365283407d2f558b891e15e71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efdb35902230f6f365283407d2f558b891e15e71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efdb35902230f6f365283407d2f558b891e15e71"}], "stats": {"total": 327, "additions": 315, "deletions": 12}, "files": [{"sha": "ee3f8c5abf082c4c9a9826e25719b3f3de6f2a5d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0dfa18604be5278997c0b48c375231a6dce32cbc", "patch": "@@ -23,6 +23,48 @@ Wed May 13 13:09:19 1998  Jim Wilson  <wilson@cygnus.com>\n \tTARGET_CMOVE support.\n \n Wed May 13 15:28:59 1998  Michael Meissner  <meissner@cygnus.com>\n+\t\t\t  Jeff Law <law@cygnus.com>\n+\n+\t* Makefile.in (HOST_RTL): Add $(HOST_PREFIX)bitmap.o.\n+\t(rtl.o, emit-rtl.o): Add dependency on bitmap.h.\n+\t($(HOST_PREFIX_1)rtl.o): Likewise.\n+\t($(HOST_PREFIX_1)bitmap.o): New host object.\n+\t* emit-rtl.c (toplevel): Include bitmap.h.\n+\t(gen_rtx): Handle 't' and 'b' nodes.\n+\t* print-rtl.c (print_rtx): Handle printing NOTE_INSN_LIVE notes.\n+\tPrint block number for block begin/end notes.  Print 't' type\n+\tnodes as a pointer.  Know that the 3rd argument of live range\n+\tstart/stop notes is really a range_info rtx.  If type is 'b', print\n+\tout argument as a bitmap.\n+\t* rtl.c: Include bitmap.c.\n+\t(copy_rtx): Copy tree nodes as is.  Copy bitmaps if type is 'b'.\n+\t(note_insn_name): Add NOTE_INSN_RANGE_{START,END}, NOTE_INSN_LIVE.\n+\t* rtl.def (RANGE_LIVE): New node to hold live information while we\n+\trecalculate the basic blocks.\n+\t(RANGE_REG, RANGE_INFO): New rtl types for live range splitting.\n+        (RANGE_VAR): New node, to hold information saved in symbol node for New \n+        communicating live range information to the debug output functions.\n+\t* rtl.h (rtunion_def): Add rttree and rtbit fields.\n+\t(XBITMAP, XTREE): New accessor macros.\n+ \t(NOTE_LIVE_INFO): Overload NOTE_SOURCE_FILE for NOTE_INSN_LIVE notes.\n+\t(NOTE_RANGE_INFO): Similarly for NOTE_INSN_RANGE_{START,END} notes.\n+\t(NOTE_BLOCK_LIVE_RANGE_BLOCK): Define.\n+\t(NOTE_INSN_RANGE_START, NOTE_INSN_RANGE_END, NOTE_INSN_LIVE): New notes.\n+\t(RANGE_LIVE_{BITMAP,ORIG_BLOCK}): New accessor macros.\n+\t(RANGE_REG_{SYMBOL,BLOCK}_NODE, RANGE_VAR_*): New accessor macros.\n+\t(RANGE_INFO_*): Likewise.\n+\t* sched.c (sched_analyze): Keep live range start/stop notes.\n+\t(unlink_other_notes): Likewise.\n+\t* haifa-sched.c (sched_analyze): Keep live range start/stop notes.\n+\t(unlink_other_notes): Likewise.\n+\t* tree.h (BLOCK_LIVE_RANGE_{START,END,VAR_FLAG}): New accessor macros.\n+\t(BLOCK_LIVE_RANGE_FLAG): Likewise.\n+\t(DECL_LIVE_RANGE_RTL): Likewise.\n+\t(struct tree_block): Add live_range_flag, live_range_var_flag,\n+\tlive_range_start and live_range_end.\n+\t(struct tree_decl): Add live_range_rtl field.\n+\t* gengenrtl.c (type_from_format): Handle 'b' and 't'.\n+\t(accessor_from_format): Likewise.\n \n \t* haifa-sched.c (schedule_block): Make verbose output line up.\n \tAlso add a blank line in printing the individual ready lists."}, {"sha": "0b787453de4adcb44ce93e4651f9dceeddc97089", "filename": "gcc/Makefile.in", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0dfa18604be5278997c0b48c375231a6dce32cbc", "patch": "@@ -521,7 +521,7 @@ LIBS = $(OBSTACK) $(USE_ALLOCA) $(MALLOC) $(VFPRINTF) $(DOPRINT) $(CLIB)\n HOST_LIBS = $(USE_HOST_OBSTACK) $(USE_HOST_ALLOCA) $(USE_HOST_MALLOC)  \\\n \t    $(USE_HOST_VFPRINTF) $(USE_HOST_DOPRINT) $(HOST_CLIB)\n \n-HOST_RTL = $(HOST_PREFIX)rtl.o\n+HOST_RTL = $(HOST_PREFIX)rtl.o $(HOST_PREFIX)bitmap.o\n HOST_RTLANAL = $(HOST_PREFIX)rtlanal.o\n HOST_PRINT = $(HOST_PREFIX)print-rtl.o\n \n@@ -1342,7 +1342,7 @@ toplev.o : toplev.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) \\\n \t  -DTARGET_NAME=\\\"$(target_alias)\\\" \\\n \t  -c `echo $(srcdir)/toplev.c | sed 's,^\\./,,'`\n \n-rtl.o : rtl.c $(CONFIG_H) system.h $(RTL_H)\n+rtl.o : rtl.c $(CONFIG_H) system.h $(RTL_H) bitmap.h\n \n print-rtl.o : print-rtl.c $(CONFIG_H) system.h $(RTL_H)\n rtlanal.o : rtlanal.c $(CONFIG_H) system.h $(RTL_H)\n@@ -1384,7 +1384,7 @@ xcoffout.o : xcoffout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) xcoffout.h \\\n    flags.h\n emit-rtl.o : emit-rtl.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    except.h function.h regs.h insn-config.h insn-codes.h $(RECOG_H) real.h \\\n-   expr.h obstack.h hard-reg-set.h\n+   expr.h obstack.h hard-reg-set.h bitmap.h\n real.o : real.c $(CONFIG_H) system.h $(TREE_H) toplev.h\n getpwd.o : getpwd.c $(CONFIG_H) system.h\n \n@@ -1716,7 +1716,7 @@ gengenrtl.o : gengenrtl.c $(RTL_BASE_H) system.h\n # If we are not cross-building, gen* use the same .o's that cc1 will use,\n # and HOST_PREFIX_1 is `foobar', just to ensure these rules don't conflict\n # with the rules for rtl.o, alloca.o, etc.\n-$(HOST_PREFIX_1)rtl.o: $(srcdir)/rtl.c $(CONFIG_H) $(RTL_H)\n+$(HOST_PREFIX_1)rtl.o: $(srcdir)/rtl.c $(CONFIG_H) system.h $(RTL_H) bitmap.h\n \trm -f $(HOST_PREFIX)rtl.c\n \tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/rtl.c > $(HOST_PREFIX)rtl.c\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)rtl.c\n@@ -1726,6 +1726,12 @@ $(HOST_PREFIX_1)print-rtl.o: $(srcdir)/print-rtl.c $(CONFIG_H) $(RTL_H)\n \tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/print-rtl.c > $(HOST_PREFIX)print-rtl.c\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)print-rtl.c\n \n+$(HOST_PREFIX_1)bitmap.o: $(srcdir)/bitmap.c $(CONFIG_H) system.h $(RTL_H) \\\n+  flags.h $(BASIC_BLOCK_H) regs.h\n+\trm -f $(HOST_PREFIX)bitmap.c\n+\tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/bitmap.c > $(HOST_PREFIX)bitmap.c\n+\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)bitmap.c\n+\n $(HOST_PREFIX_1)rtlanal.o: $(srcdir)/rtlanal.c $(CONFIG_H) $(RTL_H)\n \trm -f $(HOST_PREFIX)rtlanal.c\n \tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/rtlanal.c > $(HOST_PREFIX)rtlanal.c"}, {"sha": "854b9892e2b7331e5965b24e89b20b4e24f1f573", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=0dfa18604be5278997c0b48c375231a6dce32cbc", "patch": "@@ -53,6 +53,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"real.h\"\n #include \"obstack.h\"\n+#include \"bitmap.h\"\n \n /* Commonly used modes.  */\n \n@@ -384,6 +385,14 @@ gen_rtx VPROTO((enum rtx_code code, enum machine_mode mode, ...))\n \t      XVEC (rt_val, i) = va_arg (p, rtvec);\n \t      break;\n \n+\t    case 'b':           /* A bitmap? */\n+\t      XBITMAP (rt_val, i) = va_arg (p, bitmap);\n+\t      break;\n+\n+\t    case 't':           /* A tree? */\n+\t      XTREE (rt_val, i) = va_arg (p, tree);\n+\t      break;\n+\n \t    default:\n \t      abort ();\n \t    }"}, {"sha": "d9e55eb016460068961b30ad8c253c391af4fdee", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=0dfa18604be5278997c0b48c375231a6dce32cbc", "patch": "@@ -73,6 +73,16 @@ type_from_format (c)\n       return \"rtx\";\n     case 'E':\n       return \"rtvec\";\n+    /* ?!? These should be bitmap and tree respectively, but those types\n+       are not available in many of the files which include the output\n+       of gengenrtl.\n+\n+       These are only used in prototypes, so I think we can assume that\n+       void * is useable.  */\n+    case 'b':\n+      return \"void *\";\n+    case 't':\n+      return \"void *\";\n     default:\n       abort ();\n     }\n@@ -95,6 +105,10 @@ accessor_from_format (c)\n       return \"XEXP\";\n     case 'E':\n       return \"XVEC\";\n+    case 'b':\n+      return \"XBITMAP\";\n+    case 't':\n+      return \"XTREE\";\n     default:\n       abort ();\n     }"}, {"sha": "d10a743f46a98274158c9e8bba255df5fb1072d7", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=0dfa18604be5278997c0b48c375231a6dce32cbc", "patch": "@@ -3899,6 +3899,8 @@ sched_analyze (head, tail)\n \t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END\n \t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG\n \t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END\n+\t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_RANGE_START\n+\t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_RANGE_END\n \t\t   || (NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP\n \t\t       && GET_CODE (PREV_INSN (insn)) != CALL_INSN)))\n \t{\n@@ -4656,6 +4658,8 @@ unlink_other_notes (insn, tail)\n       if (NOTE_LINE_NUMBER (insn) != NOTE_INSN_SETJMP\n \t  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_BEG\n \t  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_END\n+\t  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_RANGE_START\n+\t  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_RANGE_END\n \t  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_EH_REGION_BEG\n \t  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_EH_REGION_END)\n \t{"}, {"sha": "ba239d19d0009d427daa501248e973fb7ec34ab5", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=0dfa18604be5278997c0b48c375231a6dce32cbc", "patch": "@@ -110,12 +110,37 @@ print_rtx (in_rtx)\n       case 's':\n \tif (i == 3 && GET_CODE (in_rtx) == NOTE\n \t    && (NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_EH_REGION_BEG\n-\t\t|| NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_EH_REGION_END))\n+\t\t|| NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_EH_REGION_END\n+\t\t|| NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_BLOCK_BEG\n+\t\t|| NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_BLOCK_END))\n \t  {\n \t    fprintf (outfile, \" %d\", NOTE_BLOCK_NUMBER (in_rtx));\n \t    sawclose = 1;\n \t    break;\n \t  }\n+\n+\tif (i == 3 && GET_CODE (in_rtx) == NOTE\n+\t    && (NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_RANGE_START\n+\t\t|| NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_RANGE_END))\n+\t  {\n+\t    indent += 2;\n+\t    if (!sawclose)\n+\t      fprintf (outfile, \" \");\n+\t    print_rtx (NOTE_RANGE_INFO (in_rtx));\n+\t    indent -= 2;\n+\t    break;\n+\t  }\n+\n+\tif (i == 3 && GET_CODE (in_rtx) == NOTE\n+\t    && NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_LIVE)\n+\t  {\n+\t    if (XBITMAP (in_rtx, i) == NULL)\n+\t      fprintf (outfile, \" {null}\");\n+\t    else\n+\t      bitmap_print (outfile, XBITMAP (in_rtx, i), \" {\", \"}\");\n+\t    sawclose = 0;\n+\t  }\n+\n \tif (XSTR (in_rtx, i) == 0)\n \t  fprintf (outfile, \" \\\"\\\"\");\n \telse\n@@ -207,6 +232,20 @@ print_rtx (in_rtx)\n \tsawclose = 0;\n \tbreak;\n \n+      case 'b':\n+\tif (XBITMAP (in_rtx, i) == NULL)\n+\t  fprintf (outfile, \" {null}\");\n+\telse\n+\t  bitmap_print (outfile, XBITMAP (in_rtx, i), \" {\", \"}\");\n+\tsawclose = 0;\n+\tbreak;\n+\n+      case 't':\n+\tputc (' ', outfile);\n+\tfprintf (outfile, HOST_WIDE_INT_PRINT_HEX,\n+\t\t (HOST_WIDE_INT) XTREE (in_rtx, i));\n+\tbreak;\n+\n       case '*':\n \tfprintf (outfile, \" Unknown\");\n \tsawclose = 0;"}, {"sha": "396566d36a7933d969e1a25a65f787aed71ed77c", "filename": "gcc/rtl.c", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=0dfa18604be5278997c0b48c375231a6dce32cbc", "patch": "@@ -23,6 +23,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"rtl.h\"\n #include \"real.h\"\n+#include \"bitmap.h\"\n \n #include \"obstack.h\"\n #define\tobstack_chunk_alloc\txmalloc\n@@ -143,7 +144,9 @@ char *rtx_format[] = {\n      \"V\" like \"E\", but optional:\n \t the containing rtx may end before this operand\n      \"u\" a pointer to another insn\n-         prints the uid of the insn.  */\n+         prints the uid of the insn.\n+     \"b\" is a pointer to a bitmap header.\n+     \"t\" is a tree pointer. */\n \n #define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)   FORMAT ,\n #include \"rtl.def\"\t\t/* rtl expressions are defined here */\n@@ -169,7 +172,8 @@ char *note_insn_name[] = { 0                    , \"NOTE_INSN_DELETED\",\n \t\t\t   \"NOTE_INSN_PROLOGUE_END\", \"NOTE_INSN_EPILOGUE_BEG\",\n \t\t\t   \"NOTE_INSN_DELETED_LABEL\", \"NOTE_INSN_FUNCTION_BEG\",\n \t\t\t   \"NOTE_INSN_EH_REGION_BEG\", \"NOTE_INSN_EH_REGION_END\",\n-\t\t\t   \"NOTE_REPEATED_LINE_NUMBER\" };\n+\t\t\t   \"NOTE_REPEATED_LINE_NUMBER\", \"NOTE_INSN_RANGE_START\",\n+\t\t\t   \"NOTE_INSN_RANGE_END\", \"NOTE_INSN_LIVE\" };\n \n char *reg_note_name[] = { \"\", \"REG_DEAD\", \"REG_INC\", \"REG_EQUIV\", \"REG_WAS_0\",\n \t\t\t  \"REG_EQUAL\", \"REG_RETVAL\", \"REG_LIBCALL\",\n@@ -338,6 +342,18 @@ copy_rtx (orig)\n \t    }\n \t  break;\n \n+\tcase 'b':\n+\t  {\n+\t    bitmap new_bits = BITMAP_OBSTACK_ALLOC (rtl_obstack);\n+\t    bitmap_copy (new_bits, XBITMAP (orig, i));\n+\t    XBITMAP (copy, i) = new_bits;\n+\t    break;\n+\t  }\n+\n+\tcase 't':\n+\t  XTREE (copy, i) = XTREE (orig, i);\n+\t  break;\n+\n \tcase 'w':\n \t  XWINT (copy, i) = XWINT (orig, i);\n \t  break;"}, {"sha": "6d02c61e29eef293d6ecee3c1b39b9ea74e12603", "filename": "gcc/rtl.def", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=0dfa18604be5278997c0b48c375231a6dce32cbc", "patch": "@@ -796,6 +796,44 @@ DEF_RTL_EXPR(HIGH, \"high\", \"e\", 'o')\n    of a constant expression.  */\n DEF_RTL_EXPR(LO_SUM, \"lo_sum\", \"ee\", 'o')\n \n+/* Header for range information.  Operand 0 is the NOTE_INSN_RANGE_START insn.\n+   Operand 1 is the NOTE_INSN_RANGE_END insn.  Operand 2 is a vector of all of\n+   the registers that can be substituted within this range.  Operand 3 is the\n+   number of calls in the range.  Operand 4 is the number of insns in the\n+   range.  Operand 5 is the unique range number for this range.  Operand 6 is\n+   the basic block # of the start of the live range.  Operand 7 is the basic\n+   block # of the end of the live range.  Operand 8 is the loop depth.  Operand\n+   9 is a bitmap of the registers live at the start of the range.  Operand 10\n+   is a bitmap of the registers live at the end of the range.  Operand 11 is\n+   marker number for the start of the range.  Operand 12 is the marker number\n+   for the end of the range.  */\n+DEF_RTL_EXPR(RANGE_INFO, \"range_info\", \"uuEiiiiiibbii\", 'x')\n+\n+/* Registers that can be substituted within the range.  Operand 0 is the\n+   original pseudo register number.  Operand 1 will be filled in with the\n+   pseudo register the value is copied for the duration of the range.  Operand\n+   2 is the number of references within the range to the register.  Operand 3\n+   is the number of sets or clobbers of the register in the range.  Operand 4\n+   is the number of deaths the register has.  Operand 5 is the copy flags that\n+   give the status of whether a copy is needed from the original register to\n+   the new register at the beginning of the range, or whether a copy from the\n+   new register back to the original at the end of the range.  Operand 6 is the\n+   live length.  Operand 7 is the number of calls that this register is live\n+   across.  Operand 8 is the symbol node of the variable if the register is a\n+   user variable.  Operand 9 is the block node that the variable is declared\n+   in if the register is a user variable. */\n+DEF_RTL_EXPR(RANGE_REG, \"range_reg\", \"iiiiiiiitt\", 'x')\n+\n+/* Information about a local variable's ranges.  Operand 0 is an EXPR_LIST of\n+   the different ranges a variable is in where it is copied to a different\n+   pseudo register.  Operand 1 is the block that the variable is declared in.\n+   Operand 2 is the number of distinct ranges.  */\n+DEF_RTL_EXPR(RANGE_VAR, \"range_var\", \"eti\", 'x')\n+\n+/* Information about the registers that are live at the current point.  Operand\n+   0 is the live bitmap.  Operand 1 is the original block number.  */\n+DEF_RTL_EXPR(RANGE_LIVE, \"range_live\", \"bi\", 'x')\n+\n /*\n Local variables:\n mode:c"}, {"sha": "597b79f07b6976d826160fe014df9b06b91facab", "filename": "gcc/rtl.h", "status": "modified", "additions": 116, "deletions": 5, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=0dfa18604be5278997c0b48c375231a6dce32cbc", "patch": "@@ -89,6 +89,8 @@ typedef union rtunion_def\n   struct rtvec_def *rtvec;\n   enum machine_mode rttype;\n   addr_diff_vec_flags rt_addr_diff_vec_flags;\n+  struct bitmap_head_def *rtbit;\n+  union tree_node *rttree;\n } rtunion;\n \n /* RTL expression (\"rtx\").  */\n@@ -228,6 +230,9 @@ typedef struct rtvec_def{\n #define XVEC(RTX, N)\t((RTX)->fld[N].rtvec)\n #define XVECLEN(RTX, N)\t((RTX)->fld[N].rtvec->num_elem)\n #define XVECEXP(RTX,N,M)((RTX)->fld[N].rtvec->elem[M].rtx)\n+#define XBITMAP(RTX, N) ((RTX)->fld[N].rtbit)\n+#define XTREE(RTX, N)   ((RTX)->fld[N].rttree)\n+\n \f\n /* ACCESS MACROS for particular fields of insns.  */\n \n@@ -375,14 +380,21 @@ extern char *reg_note_name[];\n \n #define LINE_NUMBER NOTE\n \n-/* In a NOTE that is a line number, this is a string for the file name\n-   that the line is in.  We use the same field to record block numbers\n-   temporarily in NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes.\n-   (We avoid lots of casts between ints and pointers if we use a\n-   different macro for the bock number.)  */\n+/* In a NOTE that is a line number, this is a string for the file name that the\n+   line is in.  We use the same field to record block numbers temporarily in\n+   NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes.  (We avoid lots of casts\n+   between ints and pointers if we use a different macro for the block number.)\n+   The NOTE_INSN_RANGE_{START,END} and NOTE_INSN_LIVE notes record their\n+   information as a rtx in the field.  */\n \n #define NOTE_SOURCE_FILE(INSN)  ((INSN)->fld[3].rtstr)\n #define NOTE_BLOCK_NUMBER(INSN) ((INSN)->fld[3].rtint)\n+#define NOTE_RANGE_INFO(INSN)   ((INSN)->fld[3].rtx)\n+#define NOTE_LIVE_INFO(INSN)    ((INSN)->fld[3].rtx)\n+\n+/* If the NOTE_BLOCK_NUMBER field gets a -1, it means create a new\n+   block node for a live range block.  */\n+#define NOTE_BLOCK_LIVE_RANGE_BLOCK -1\n \n /* In a NOTE that is a line number, this is the line number.\n    Other kinds of NOTEs are identified by negative numbers here.  */\n@@ -438,6 +450,12 @@ extern char *reg_note_name[];\n    the line containing the inline call from being counted twice in gcov. */\n #define NOTE_REPEATED_LINE_NUMBER -16\n \n+/* Start/end of a live range region, where pseudos allocated on the stack can\n+   be allocated to temporary registers.  */\n+#define NOTE_INSN_RANGE_START -17\n+#define NOTE_INSN_RANGE_END -18\n+/* Record which registers are currently live.  */\n+#define NOTE_INSN_LIVE -19\n \n #if 0 /* These are not used, and I don't know what they were for. --rms.  */\n #define NOTE_DECL_NAME(INSN) ((INSN)->fld[3].rtstr)\n@@ -666,6 +684,99 @@ extern char *note_insn_name[];\n #if (defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT) || defined (HAVE_POST_INCREMENT) || defined (HAVE_POST_DECREMENT))\n #define AUTO_INC_DEC\n #endif\n+\n+/* Accessors for RANGE_INFO.  */\n+/* For RANGE_{START,END} notes return the RANGE_START note.  */\n+#define RANGE_INFO_NOTE_START(INSN) (XEXP (INSN, 0))\n+\n+/* For RANGE_{START,END} notes return the RANGE_START note.  */\n+#define RANGE_INFO_NOTE_END(INSN) (XEXP (INSN, 1))\n+\n+/* For RANGE_{START,END} notes, return the vector containing the registers used\n+   in the range.  */\n+#define RANGE_INFO_REGS(INSN) (XVEC (INSN, 2))\n+#define RANGE_INFO_REGS_REG(INSN, N) (XVECEXP (INSN, 2, N))\n+#define RANGE_INFO_NUM_REGS(INSN) (XVECLEN (INSN, 2))\n+\n+/* For RANGE_{START,END} notes, the number of calls within the range.  */\n+#define RANGE_INFO_NCALLS(INSN) (XINT (INSN, 3))\n+\n+/* For RANGE_{START,END} notes, the number of insns within the range.  */\n+#define RANGE_INFO_NINSNS(INSN) (XINT (INSN, 4))\n+\n+/* For RANGE_{START,END} notes, a unique # to identify this range.  */\n+#define RANGE_INFO_UNIQUE(INSN) (XINT (INSN, 5))\n+\n+/* For RANGE_{START,END} notes, the basic block # the range starts with. */\n+#define RANGE_INFO_BB_START(INSN) (XINT (INSN, 6))\n+\n+/* For RANGE_{START,END} notes, the basic block # the range ends with. */\n+#define RANGE_INFO_BB_END(INSN) (XINT (INSN, 7))\n+\n+/* For RANGE_{START,END} notes, the loop depth the range is in.  */\n+#define RANGE_INFO_LOOP_DEPTH(INSN) (XINT (INSN, 8))\n+\n+/* For RANGE_{START,END} notes, the bitmap of live registers at the start\n+   of the range.  */\n+#define RANGE_INFO_LIVE_START(INSN) (XBITMAP (INSN, 9))\n+\n+/* For RANGE_{START,END} notes, the bitmap of live registers at the end\n+   of the range.  */\n+#define RANGE_INFO_LIVE_END(INSN) (XBITMAP (INSN, 10))\n+\n+/* For RANGE_START notes, the marker # of the start of the range.  */\n+#define RANGE_INFO_MARKER_START(INSN) (XINT (INSN, 11))\n+\n+/* For RANGE_START notes, the marker # of the end of the range.  */\n+#define RANGE_INFO_MARKER_END(INSN) (XINT (INSN, 12))\n+\n+/* Original pseudo register # for a live range note.  */\n+#define RANGE_REG_PSEUDO(INSN,N) (XINT (XVECEXP (INSN, 2, N), 0))\n+\n+/* Pseudo register # original register is copied into or -1.  */\n+#define RANGE_REG_COPY(INSN,N) (XINT (XVECEXP (INSN, 2, N), 1))\n+\n+/* How many times a register in a live range note was referenced.  */\n+#define RANGE_REG_REFS(INSN,N) (XINT (XVECEXP (INSN, 2, N), 2))\n+\n+/* How many times a register in a live range note was set.  */\n+#define RANGE_REG_SETS(INSN,N) (XINT (XVECEXP (INSN, 2, N), 3))\n+\n+/* How many times a register in a live range note died.  */\n+#define RANGE_REG_DEATHS(INSN,N) (XINT (XVECEXP (INSN, 2, N), 4))\n+\n+/* Whether the original value is needed to be copied into the range register at\n+   the start of the range. */\n+#define RANGE_REG_COPY_FLAGS(INSN,N) (XINT (XVECEXP (INSN, 2, N), 5))\n+\n+/* # of insns the register copy is live over.  */\n+#define RANGE_REG_LIVE_LENGTH(INSN,N) (XINT (XVECEXP (INSN, 2, N), 6))\n+\n+/* # of calls the register copy is live over.  */\n+#define RANGE_REG_N_CALLS(INSN,N) (XINT (XVECEXP (INSN, 2, N), 7))\n+\n+/* DECL_NODE pointer of the declaration if the register is a user defined\n+   variable.  */\n+#define RANGE_REG_SYMBOL_NODE(INSN,N) (XTREE (XVECEXP (INSN, 2, N), 8))\n+\n+/* BLOCK_NODE pointer to the block the variable is declared in if the\n+   register is a user defined variable.  */\n+#define RANGE_REG_BLOCK_NODE(INSN,N) (XTREE (XVECEXP (INSN, 2, N), 9))\n+\n+/* EXPR_LIST of the distinct ranges a variable is in.  */\n+#define RANGE_VAR_LIST(INSN) (XEXP (INSN, 0))\n+\n+/* Block a variable is declared in.  */\n+#define RANGE_VAR_BLOCK(INSN) (XTREE (INSN, 1))\n+\n+/* # of distinct ranges a variable is in.  */\n+#define RANGE_VAR_NUM(INSN) (XINT (INSN, 2))\n+\n+/* For a NOTE_INSN_LIVE note, the registers which are currently live.  */\n+#define RANGE_LIVE_BITMAP(INSN) (XBITMAP (INSN, 0))\n+\n+/* For a NOTE_INSN_LIVE note, the original basic block number.  */\n+#define RANGE_LIVE_ORIG_BLOCK(INSN) (XINT (INSN, 1))\n \f\n /* Generally useful functions.  */\n "}, {"sha": "2cd9d12911c7789a06e7e05d07c907f53a9f6cf1", "filename": "gcc/sched.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=0dfa18604be5278997c0b48c375231a6dce32cbc", "patch": "@@ -1737,6 +1737,8 @@ sched_analyze (head, tail)\n \t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END\n \t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG\n \t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END\n+\t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_RANGE_START\n+\t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_RANGE_END\n \t\t   || (NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP\n \t\t       && GET_CODE (PREV_INSN (insn)) != CALL_INSN)))\n \t{\n@@ -2516,6 +2518,8 @@ unlink_notes (insn, tail)\n       else if (NOTE_LINE_NUMBER (insn) != NOTE_INSN_SETJMP\n \t       && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_BEG\n \t       && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_END\n+\t       && NOTE_LINE_NUMBER (insn) != NOTE_INSN_RANGE_START\n+\t       && NOTE_LINE_NUMBER (insn) != NOTE_INSN_RANGE_END\n \t       && NOTE_LINE_NUMBER (insn) != NOTE_INSN_EH_REGION_BEG\n \t       && NOTE_LINE_NUMBER (insn) != NOTE_INSN_EH_REGION_END)\n \t{"}, {"sha": "7b7e4cf8215e528840ba0b7df41b00b69c3b58b4", "filename": "gcc/tree.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dfa18604be5278997c0b48c375231a6dce32cbc/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0dfa18604be5278997c0b48c375231a6dce32cbc", "patch": "@@ -671,6 +671,18 @@ struct tree_exp\n #define BLOCK_ABSTRACT_ORIGIN(NODE) ((NODE)->block.abstract_origin)\n #define BLOCK_ABSTRACT(NODE) ((NODE)->block.abstract_flag)\n #define BLOCK_END_NOTE(NODE) ((NODE)->block.end_note)\n+/* Nonzero means that this block has separate live range regions */\n+#define BLOCK_LIVE_RANGE_FLAG(NOTE) ((NOTE)->block.live_range_flag)\n+\n+/* Nonzero means that this block has a variable declared in it\n+   that is split into separate live ranges.  */\n+#define BLOCK_LIVE_RANGE_VAR_FLAG(NOTE) ((NOTE)->block.live_range_var_flag)\n+\n+/* Index for marking the start of the block for live ranges.  */\n+#define BLOCK_LIVE_RANGE_START(NOTE) ((NOTE)->block.live_range_start)\n+\n+/* Index for marking the end of the block for live ranges.  */\n+#define BLOCK_LIVE_RANGE_END(NOTE) ((NOTE)->block.live_range_end)\n \n /* Nonzero means that this block is prepared to handle exceptions\n    listed in the BLOCK_VARS slot.  */\n@@ -682,13 +694,17 @@ struct tree_block\n \n   unsigned handler_block_flag : 1;\n   unsigned abstract_flag : 1;\n+  unsigned live_range_flag : 1;\n+  unsigned live_range_var_flag : 1;\n \n   union tree_node *vars;\n   union tree_node *type_tags;\n   union tree_node *subblocks;\n   union tree_node *supercontext;\n   union tree_node *abstract_origin;\n   struct rtx_def *end_note;\n+  int live_range_start;\n+  int live_range_end;\n };\n \f\n /* Define fields and accessors for nodes representing data types.  */\n@@ -971,6 +987,9 @@ struct tree_type\n    to the variable's data type, while the mode\n    of DECL_RTL is the mode actually used to contain the data.  */\n #define DECL_RTL(NODE) ((NODE)->decl.rtl)\n+/* Holds an INSN_LIST of all of the live ranges in which the variable\n+   has been moved to a possibly different register.  */\n+#define DECL_LIVE_RANGE_RTL(NODE) ((NODE)->decl.live_range_rtl)\n /* For PARM_DECL, holds an RTL for the stack slot or register\n    where the data was actually passed.  */\n #define DECL_INCOMING_RTL(NODE) ((NODE)->decl.saved_insns.r)\n@@ -1191,6 +1210,7 @@ struct tree_decl\n   union tree_node *machine_attributes;\n   struct rtx_def *rtl;\t/* acts as link to register transfer language\n \t\t\t\t   (rtl) info */\n+  struct rtx_def *live_range_rtl;\n   /* For FUNCTION_DECLs: points to insn that constitutes its definition\n      on the permanent obstack.  For FIELD_DECL, this is DECL_FIELD_SIZE.  */\n   union {"}]}