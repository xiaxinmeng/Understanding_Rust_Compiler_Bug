{"sha": "b4c70e89da092f437f0b1b8b97d5beef454d5198", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRjNzBlODlkYTA5MmY0MzdmMGIxYjhiOTdkNWJlZWY0NTRkNTE5OA==", "commit": {"author": {"name": "Gawain Bolton", "email": "gp.bolton@computer.org", "date": "2003-07-30T15:01:58Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-07-30T15:01:58Z"}, "message": "re PR libstdc++/11504 (-Wcast-qual vs. stl_tree)\n\n\n2003-07-30  Gawain Bolton  <gp.bolton@computer.org>\n\n\tPR libstdc++/11504.\n\t* include/bits/stl_tree.h: Replace C-style casts with C++-style\n\tcasts.  Changes to avoid casting away constness.  Eliminate\n\t_Rb_tree_base_iterator class.  Change _Rb_tree_iterator to use\n\tinitialization lists.  Move out implementation of __black_count()\n\tto...\n        * src/stl_tree.cc: ...here and rename _Rb_tree_black_count().\n        Rename_Rb_tree_base_iterator::_M_increment() to\n        _Rb_tree_increment and _Rb_tree_base_iterator::_M_decrement() to\n        _Rb_tree_decrement.\n        * config/linker-map.gnu: Add and change symbols here.\n\nFrom-SVN: r69958", "tree": {"sha": "00301e8c804e89e1256ed1e02e5f3faea56ed554", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00301e8c804e89e1256ed1e02e5f3faea56ed554"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4c70e89da092f437f0b1b8b97d5beef454d5198", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4c70e89da092f437f0b1b8b97d5beef454d5198", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4c70e89da092f437f0b1b8b97d5beef454d5198", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4c70e89da092f437f0b1b8b97d5beef454d5198/comments", "author": null, "committer": null, "parents": [{"sha": "cf68fdb19bc8881ab06046f3fd8ac5da49770bc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf68fdb19bc8881ab06046f3fd8ac5da49770bc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf68fdb19bc8881ab06046f3fd8ac5da49770bc4"}], "stats": {"total": 340, "additions": 203, "deletions": 137}, "files": [{"sha": "4dc6b15de449566e5154d5888e13107c1e218b22", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c70e89da092f437f0b1b8b97d5beef454d5198/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c70e89da092f437f0b1b8b97d5beef454d5198/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b4c70e89da092f437f0b1b8b97d5beef454d5198", "patch": "@@ -1,3 +1,17 @@\n+2003-07-30  Gawain Bolton  <gp.bolton@computer.org>\n+\n+\tPR libstdc++/11504.  \n+\t* include/bits/stl_tree.h: Replace C-style casts with C++-style\n+\tcasts.  Changes to avoid casting away constness.  Eliminate\n+\t_Rb_tree_base_iterator class.  Change _Rb_tree_iterator to use\n+\tinitialization lists.  Move out implementation of __black_count()\n+\tto...\n+        * src/stl_tree.cc: ...here and rename _Rb_tree_black_count().\n+        Rename_Rb_tree_base_iterator::_M_increment() to\n+        _Rb_tree_increment and _Rb_tree_base_iterator::_M_decrement() to\n+        _Rb_tree_decrement.\n+        * config/linker-map.gnu: Add and change symbols here.\n+\n 2003-07-30  Jonathan Wakely  <redi@gcc.gnu.org>\n \n \t* docs/html/22_locale/howto.html: Use locale::classic() instead"}, {"sha": "fa54dcf1a05ed793abf94a05d50705a9c6220c0e", "filename": "libstdc++-v3/config/linker-map.gnu", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c70e89da092f437f0b1b8b97d5beef454d5198/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c70e89da092f437f0b1b8b97d5beef454d5198/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu?ref=b4c70e89da092f437f0b1b8b97d5beef454d5198", "patch": "@@ -76,9 +76,10 @@ GLIBCXX_3.4 {\n     _ZSt9has_facet*;\n \n     # _Rb_tree\n-    _ZNSt22_Rb_tree_base_iterator12_M_decrementEv;\n-    _ZNSt22_Rb_tree_base_iterator12_M_incrementEv;\n+    _ZSt18_Rb_tree_decrementPSt18_Rb_tree_node_base;\n+    _ZSt18_Rb_tree_incrementPSt18_Rb_tree_node_base;\n     _ZSt18_Rb_tree_rebalancePSt18_Rb_tree_node_baseRS0_;\n+    _ZSt20_Rb_tree_black_countPKSt18_Rb_tree_node_baseS1_;\n     _ZSt20_Rb_tree_rotate_leftPSt18_Rb_tree_node_baseRS0_;\n     _ZSt21_Rb_tree_rotate_rightPSt18_Rb_tree_node_baseRS0_;\n     _ZSt28_Rb_tree_rebalance_for_erasePSt18_Rb_tree_node_baseRS_;"}, {"sha": "fd81a6755cd7245f2b90b3b6329da32eef463b2c", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 142, "deletions": 112, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c70e89da092f437f0b1b8b97d5beef454d5198/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c70e89da092f437f0b1b8b97d5beef454d5198/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=b4c70e89da092f437f0b1b8b97d5beef454d5198", "patch": "@@ -95,6 +95,7 @@ namespace std\n   struct _Rb_tree_node_base\n   {\n     typedef _Rb_tree_node_base* _Base_ptr;\n+    typedef const _Rb_tree_node_base* _Const_Base_ptr;\n     \n     _Rb_tree_color \t_M_color; \n     _Base_ptr \t\t_M_parent;\n@@ -108,12 +109,26 @@ namespace std\n       return __x;\n     }\n \n+    static _Const_Base_ptr\n+    _S_minimum(_Const_Base_ptr __x)\n+    {\n+      while (__x->_M_left != 0) __x = __x->_M_left;\n+      return __x;\n+    }\n+\n     static _Base_ptr \n     _S_maximum(_Base_ptr __x)\n     {\n       while (__x->_M_right != 0) __x = __x->_M_right;\n       return __x;\n     }\n+\n+    static _Const_Base_ptr\n+    _S_maximum(_Const_Base_ptr __x)\n+    {\n+      while (__x->_M_right != 0) __x = __x->_M_right;\n+      return __x;\n+    }\n   };\n \n   template<typename _Val>\n@@ -123,68 +138,78 @@ namespace std\n       _Val _M_value_field;\n     };\n   \n-  struct _Rb_tree_base_iterator\n-  {\n-    typedef _Rb_tree_node_base::_Base_ptr \t_Base_ptr;\n-    typedef bidirectional_iterator_tag \t\titerator_category;\n-    typedef ptrdiff_t \t\t\t\tdifference_type;\n-\n-    _Base_ptr _M_node;\n-\n-    void \n-    _M_increment();\n+  _Rb_tree_node_base*\n+  _Rb_tree_increment(_Rb_tree_node_base* __x);\n \n-    void \n-    _M_decrement();\n-  };\n+  _Rb_tree_node_base*\n+  _Rb_tree_decrement(_Rb_tree_node_base* __x);\n \n   template<typename _Val, typename _Ref, typename _Ptr>\n-    struct _Rb_tree_iterator : public _Rb_tree_base_iterator\n+    struct _Rb_tree_iterator\n     {\n       typedef _Val value_type;\n       typedef _Ref reference;\n       typedef _Ptr pointer;\n       typedef _Rb_tree_iterator<_Val, _Val&, _Val*> iterator;\n       typedef _Rb_tree_iterator<_Val, const _Val&, const _Val*> \n       const_iterator;\n+      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;\n+      typedef bidirectional_iterator_tag iterator_category;\n+      typedef ptrdiff_t difference_type;\n       typedef _Rb_tree_iterator<_Val, _Ref, _Ptr> _Self;\n       typedef _Rb_tree_node<_Val>* _Link_type;\n+      typedef const _Rb_tree_node<_Val>* _Const_Link_type;\n       \n       _Rb_tree_iterator() {}\n-      _Rb_tree_iterator(_Rb_tree_node_base* __x) { _M_node = __x; }\n-      _Rb_tree_iterator(const iterator& __it) { _M_node = __it._M_node; }\n+\n+      _Rb_tree_iterator(_Link_type __x)\n+      : _M_node(__x) {}\n+\n+      _Rb_tree_iterator(_Const_Link_type __x)\n+      : _M_node(const_cast<_Link_type>(__x)) {}\n+\n+      _Rb_tree_iterator(const iterator& __it)\n+      : _M_node(__it._M_node) {}\n \n       reference \n-      operator*() const { return _Link_type(_M_node)->_M_value_field; }\n+      operator*() const\n+      { return static_cast<_Link_type>(_M_node)->_M_value_field; }\n \n       pointer \n-      operator->() const { return &(operator*()); }\n+      operator->() const\n+      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }\n \n       _Self& \n       operator++() \n       { \n-\t_M_increment(); \n+\t_M_node = _Rb_tree_increment(_M_node);\n \treturn *this; \n       }\n \n       _Self \n       operator++(int) \n       {\n \t_Self __tmp = *this;\n-\t_M_increment();\n+\t_M_node = _Rb_tree_increment(_M_node);\n \treturn __tmp;\n       }\n     \n       _Self& \n-      operator--() { _M_decrement(); return *this; }\n+      operator--()\n+      {\n+\t_M_node = _Rb_tree_decrement(_M_node);\n+\treturn *this;\n+      }\n \n       _Self \n       operator--(int) \n       {\n \t_Self __tmp = *this;\n-\t_M_decrement();\n+\t_M_node = _Rb_tree_decrement(_M_node);\n \treturn __tmp;\n       }\n+\n+      _Base_ptr _M_node;\n   };\n \n   template<typename _Val, typename _Ref, typename _Ptr>\n@@ -312,6 +337,7 @@ namespace std\n       \n     protected:\n       typedef _Rb_tree_node_base* _Base_ptr;\n+      typedef const _Rb_tree_node_base* _Const_Base_ptr;\n       typedef _Rb_tree_node<_Val> _Rb_tree_node;\n       \n     public:\n@@ -322,6 +348,7 @@ namespace std\n       typedef value_type& reference;\n       typedef const value_type& const_reference;\n       typedef _Rb_tree_node* _Link_type;\n+      typedef const _Rb_tree_node* _Const_Link_type;\n       typedef size_t size_type;\n       typedef ptrdiff_t difference_type;\n       \n@@ -348,7 +375,7 @@ namespace std\n       }\n       \n       _Link_type \n-      _M_clone_node(_Link_type __x)\n+      _M_clone_node(_Const_Link_type __x)\n       {\n \t_Link_type __tmp = _M_create_node(__x->_M_value_field);\n \t__tmp->_M_color = __x->_M_color;\n@@ -367,58 +394,75 @@ namespace std\n       size_type _M_node_count; // keeps track of size of tree\n       _Compare _M_key_compare;\n \n-      _Link_type& \n-      _M_root() const { return (_Link_type&) this->_M_header._M_parent; }\n+      _Base_ptr&\n+      _M_root() { return this->_M_header._M_parent; }\n \n-      _Link_type& \n-      _M_leftmost() const { return (_Link_type&) this->_M_header._M_left; }\n+      _Const_Base_ptr\n+      _M_root() const { return this->_M_header._M_parent; }\n \n-      _Link_type& \n-      _M_rightmost() const { return (_Link_type&) this->_M_header._M_right; }\n+      _Base_ptr&\n+      _M_leftmost() { return this->_M_header._M_left; }\n+\n+      _Const_Base_ptr\n+      _M_leftmost() const { return this->_M_header._M_left; }\n+\n+      _Base_ptr&\n+      _M_rightmost() { return this->_M_header._M_right; }\n+\n+      _Const_Base_ptr\n+      _M_rightmost() const { return this->_M_header._M_right; }\n \n       _Link_type\n-      _M_end() const { return (_Link_type) &this->_M_header; }\n-      \n-      static _Link_type& \n-      _S_left(_Link_type __x) { return (_Link_type&)(__x->_M_left); }\n+      _M_begin() { return static_cast<_Link_type>(this->_M_header._M_parent); }\n+\n+      _Const_Link_type\n+      _M_begin() const { return static_cast<_Const_Link_type>(this->_M_header._M_parent); }\n \n-      static _Link_type& \n-      _S_right(_Link_type __x) { return (_Link_type&)(__x->_M_right); }\n+      _Link_type\n+      _M_end() { return static_cast<_Link_type>(&this->_M_header); }\n \n-      static _Link_type& \n-      _S_parent(_Link_type __x) { return (_Link_type&)(__x->_M_parent); }\n+      _Const_Link_type\n+      _M_end() const { return static_cast<_Const_Link_type>(&this->_M_header); }\n \n-      static reference \n-      _S_value(_Link_type __x) { return __x->_M_value_field; }\n+      static const_reference \n+      _S_value(_Const_Link_type __x) { return __x->_M_value_field; }\n \n       static const _Key& \n-      _S_key(_Link_type __x) { return _KeyOfValue()(_S_value(__x)); }\n+      _S_key(_Const_Link_type __x) { return _KeyOfValue()(_S_value(__x)); }\n+\n+      static _Link_type\n+      _S_left(_Base_ptr __x) { return static_cast<_Link_type>(__x->_M_left); }\n \n-      static _Link_type& \n-      _S_left(_Base_ptr __x) { return (_Link_type&)(__x->_M_left); }\n+      static _Const_Link_type\n+      _S_left(_Const_Base_ptr __x) { return static_cast<_Const_Link_type>(__x->_M_left); }\n \n-      static _Link_type& \n-      _S_right(_Base_ptr __x) { return (_Link_type&)(__x->_M_right); }\n+      static _Link_type\n+      _S_right(_Base_ptr __x) { return static_cast<_Link_type>(__x->_M_right); }\n \n-      static _Link_type& \n-      _S_parent(_Base_ptr __x) { return (_Link_type&)(__x->_M_parent); }\n+      static _Const_Link_type\n+      _S_right(_Const_Base_ptr __x) { return static_cast<_Const_Link_type>(__x->_M_right); }\n \n-      static reference \n-      _S_value(_Base_ptr __x) { return ((_Link_type)__x)->_M_value_field; }\n+      static const_reference\n+      _S_value(_Const_Base_ptr __x) { return static_cast<_Const_Link_type>(__x)->_M_value_field; }\n \n       static const _Key& \n-      _S_key(_Base_ptr __x) { return _KeyOfValue()(_S_value(_Link_type(__x)));} \n+      _S_key(_Const_Base_ptr __x) { return _KeyOfValue()(_S_value(__x)); }\n+\n+      static _Base_ptr \n+      _S_minimum(_Base_ptr __x) \n+      { return _Rb_tree_node_base::_S_minimum(__x); }\n \n-      static _Rb_tree_color&\n-      _S_color(_Base_ptr __x) { return __x->_M_color; }\n+      static _Const_Base_ptr\n+      _S_minimum(_Const_Base_ptr __x)\n+      { return _Rb_tree_node_base::_S_minimum(__x); }\n \n-      static _Link_type \n-      _S_minimum(_Link_type __x) \n-      { return (_Link_type)  _Rb_tree_node_base::_S_minimum(__x); }\n+      static _Base_ptr\n+      _S_maximum(_Base_ptr __x)\n+      { return _Rb_tree_node_base::_S_maximum(__x); }\n \n-      static _Link_type \n-      _S_maximum(_Link_type __x)\n-      { return (_Link_type) _Rb_tree_node_base::_S_maximum(__x); }\n+      static _Const_Base_ptr\n+      _S_maximum(_Const_Base_ptr __x)\n+      { return _Rb_tree_node_base::_S_maximum(__x); }\n \n     public:\n       typedef _Rb_tree_iterator<value_type, reference, pointer> iterator;\n@@ -433,7 +477,7 @@ namespace std\n       _M_insert(_Base_ptr __x, _Base_ptr __y, const value_type& __v);\n \n       _Link_type \n-      _M_copy(_Link_type __x, _Link_type __p);\n+      _M_copy(_Const_Link_type __x, _Link_type __p);\n \n       void \n       _M_erase(_Link_type __x);\n@@ -460,8 +504,8 @@ namespace std\n \t  _M_empty_initialize();\n \telse \n \t  {\n-\t    _S_color(&this->_M_header) = _S_red;\n-\t    _M_root() = _M_copy(__x._M_root(), _M_end());\n+\t    this->_M_header._M_color = _S_red;\n+\t    _M_root() = _M_copy(__x._M_begin(), _M_end());\n \t    _M_leftmost() = _S_minimum(_M_root());\n \t    _M_rightmost() = _S_maximum(_M_root());\n \t  }\n@@ -477,7 +521,7 @@ namespace std\n       void _M_empty_initialize() \n       {\n \t// Used to distinguish header from __root, in iterator.operator++.\n-\t_S_color(&this->_M_header) = _S_red; \n+\tthis->_M_header._M_color = _S_red; \n \t_M_root() = 0;\n \t_M_leftmost() = _M_end();\n \t_M_rightmost() = _M_end();\n@@ -489,16 +533,16 @@ namespace std\n       key_comp() const { return _M_key_compare; }\n \n       iterator \n-      begin() { return _M_leftmost(); }\n+      begin() { return static_cast<_Link_type>(this->_M_header._M_left); }\n \n       const_iterator \n-      begin() const { return _M_leftmost(); }\n+      begin() const { return static_cast<_Const_Link_type>(this->_M_header._M_left); }\n \n       iterator \n-      end() { return &this->_M_header; }\n+      end() { return static_cast<_Link_type>(&this->_M_header); }\n \n       const_iterator\n-      end() const { return const_cast<_Base_ptr>(&this->_M_header); }\n+      end() const { return static_cast<_Const_Link_type>(&this->_M_header); }\n \n       reverse_iterator \n       rbegin() { return reverse_iterator(end()); }\n@@ -562,7 +606,7 @@ namespace std\n       {\n \tif (_M_node_count != 0) \n \t  {\n-\t    _M_erase(_M_root());\n+\t    _M_erase(_M_begin());\n \t    _M_leftmost() = _M_end();\n \t    _M_root() = 0;\n \t    _M_rightmost() = _M_end();\n@@ -678,7 +722,7 @@ namespace std\n \t    }\n \t  else \n \t    {\n-\t      _M_root() = _M_copy(__x._M_root(), _M_end());\n+\t      _M_root() = _M_copy(__x._M_begin(), _M_end());\n \t      _M_leftmost() = _S_minimum(_M_root());\n \t      _M_rightmost() = _S_maximum(_M_root());\n \t      _M_node_count = __x._M_node_count;\n@@ -693,15 +737,15 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     _M_insert(_Base_ptr __x_, _Base_ptr __y_, const _Val& __v)\n     {\n-      _Link_type __x = (_Link_type) __x_;\n-      _Link_type __y = (_Link_type) __y_;\n+      _Link_type __x = static_cast<_Link_type>(__x_);\n+      _Link_type __y = static_cast<_Link_type>(__y_);\n       _Link_type __z;\n       \n       if (__y == &this->_M_header || __x != 0 || \n \t  _M_key_compare(_KeyOfValue()(__v), _S_key(__y))) \n \t{\n \t  __z = _M_create_node(__v);\n-\t  _S_left(__y) = __z;               // also makes _M_leftmost() = __z \n+\t  __y->_M_left = __z;               // also makes _M_leftmost() = __z\n \t  //    when __y == &_M_header\n \t  if (__y == &this->_M_header) \n \t    {\n@@ -714,14 +758,14 @@ namespace std\n       else \n \t{\n \t  __z = _M_create_node(__v);\n-\t  _S_right(__y) = __z;\n+\t  __y->_M_right = __z;\n \t  // Maintain _M_rightmost() pointing to max node.\n \t  if (__y == _M_rightmost())\n \t    _M_rightmost() = __z; \n \t}\n-      _S_parent(__z) = __y;\n-      _S_left(__z) = 0;\n-      _S_right(__z) = 0;\n+      __z->_M_parent = __y;\n+      __z->_M_left = 0;\n+      __z->_M_right = 0;\n       _Rb_tree_rebalance(__z, this->_M_header._M_parent);\n       ++_M_node_count;\n       return iterator(__z);\n@@ -733,8 +777,8 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     insert_equal(const _Val& __v)\n     {\n+      _Link_type __x = _M_begin();\n       _Link_type __y = _M_end();\n-      _Link_type __x = _M_root();\n       while (__x != 0) \n \t{\n \t  __y = __x;\n@@ -796,8 +840,8 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     insert_unique(const _Val& __v)\n     {\n+      _Link_type __x = _M_begin();\n       _Link_type __y = _M_end();\n-      _Link_type __x = _M_root();\n       bool __comp = true;\n       while (__x != 0) \n \t{\n@@ -930,8 +974,8 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::erase(iterator __position)\n     {\n       _Link_type __y = \n-\t(_Link_type) _Rb_tree_rebalance_for_erase(__position._M_node,\n-\t\t\t\t\t\t  this->_M_header);\n+\tstatic_cast<_Link_type>(_Rb_tree_rebalance_for_erase(__position._M_node,\n+\t\t\t\t\t\t\t     this->_M_header));\n       destroy_node(__y);\n       --_M_node_count;\n     }\n@@ -951,7 +995,7 @@ namespace std\n            typename _Compare, typename _Alloc>\n     typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type \n     _Rb_tree<_Key,_Val,_KoV,_Compare,_Alloc>::\n-    _M_copy(_Link_type __x, _Link_type __p)\n+    _M_copy(_Const_Link_type __x, _Link_type __p)\n     {\n       // Structural copy.  __x and __p must be non-null.\n       _Link_type __top = _M_clone_node(__x);\n@@ -1025,8 +1069,8 @@ namespace std\n     typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator \n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::find(const _Key& __k)\n     {\n-      _Link_type __y = _M_end(); // Last node which is not less than __k. \n-      _Link_type __x = _M_root(); // Current node. \n+      _Link_type __x = _M_begin(); // Current node.\n+      _Link_type __y = _M_end(); // Last node which is not less than __k.\n       \n       while (__x != 0) \n \tif (!_M_key_compare(_S_key(__x), __k))\n@@ -1045,8 +1089,8 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     find(const _Key& __k) const\n     {\n-      _Link_type __y = _M_end(); // Last node which is not less than __k. \n-      _Link_type __x = _M_root(); // Current node. \n+      _Const_Link_type __x = _M_begin(); // Current node.\n+      _Const_Link_type __y = _M_end(); // Last node which is not less than __k.\n  \n      while (__x != 0) \n        {\n@@ -1077,8 +1121,8 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     lower_bound(const _Key& __k)\n     {\n-      _Link_type __y = _M_end(); // Last node which is not less than __k\n-      _Link_type __x = _M_root(); // Current node.\n+      _Link_type __x = _M_begin(); // Current node.\n+      _Link_type __y = _M_end(); // Last node which is not less than __k.\n       \n       while (__x != 0) \n \tif (!_M_key_compare(_S_key(__x), __k))\n@@ -1095,8 +1139,8 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     lower_bound(const _Key& __k) const\n     {\n-      _Link_type __y = _M_end(); // Last node which is not less than __k.\n-      _Link_type __x = _M_root(); // Current node.\n+      _Const_Link_type __x = _M_begin(); // Current node.\n+      _Const_Link_type __y = _M_end(); // Last node which is not less than __k.\n       \n       while (__x != 0) \n \tif (!_M_key_compare(_S_key(__x), __k))\n@@ -1113,8 +1157,8 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     upper_bound(const _Key& __k)\n     {\n+      _Link_type __x = _M_begin(); // Current node.\n       _Link_type __y = _M_end(); // Last node which is greater than __k.\n-      _Link_type __x = _M_root(); // Current node.\n       \n       while (__x != 0) \n \tif (_M_key_compare(__k, _S_key(__x)))\n@@ -1131,8 +1175,8 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     upper_bound(const _Key& __k) const\n     {\n-      _Link_type __y = _M_end(); // Last node which is greater than __k.\n-      _Link_type __x = _M_root(); // Current node.\n+      _Const_Link_type __x = _M_begin(); // Current node.\n+      _Const_Link_type __y = _M_end(); // Last node which is greater than __k.\n       \n       while (__x != 0) \n \tif (_M_key_compare(__k, _S_key(__x)))\n@@ -1164,23 +1208,9 @@ namespace std\n \t\t\t\t\t       upper_bound(__k));\n   }\n \n-  inline int\n-  __black_count(_Rb_tree_node_base* __node, _Rb_tree_node_base* __root)\n-  {\n-    if (__node == 0)\n-      return 0;\n-    int __sum = 0;\n-    do \n-      {\n-\tif (__node->_M_color == _S_black) \n-\t  ++__sum;\n-\tif (__node == __root) \n-\t  break;\n-\t__node = __node->_M_parent;\n-      } \n-    while (1);\n-    return __sum;\n-  }\n+  unsigned int\n+  _Rb_tree_black_count(const _Rb_tree_node_base* __node,\n+                       const _Rb_tree_node_base* __root);\n \n   template<typename _Key, typename _Val, typename _KeyOfValue, \n            typename _Compare, typename _Alloc>\n@@ -1192,12 +1222,12 @@ namespace std\n \tthis->_M_header._M_left == &this->_M_header &&\n \tthis->_M_header._M_right == &this->_M_header;\n   \n-    int __len = __black_count(_M_leftmost(), _M_root());\n+    unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());\n     for (const_iterator __it = begin(); __it != end(); ++__it) \n       {\n-\t_Link_type __x = (_Link_type) __it._M_node;\n-\t_Link_type __L = _S_left(__x);\n-\t_Link_type __R = _S_right(__x);\n+\t_Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);\n+\t_Const_Link_type __L = _S_left(__x);\n+\t_Const_Link_type __R = _S_right(__x);\n \t\n \tif (__x->_M_color == _S_red)\n \t  if ((__L && __L->_M_color == _S_red) \n@@ -1209,7 +1239,7 @@ namespace std\n \tif (__R && _M_key_compare(_S_key(__R), _S_key(__x)))\n \t  return false;\n \n-\tif (!__L && !__R && __black_count(__x, _M_root()) != __len)\n+\tif (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)\n \t  return false;\n       }\n     "}, {"sha": "eac141f0f79049b6d1c2c1216dde365eea35064c", "filename": "libstdc++-v3/src/stl_tree.cc", "status": "modified", "additions": 44, "deletions": 23, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c70e89da092f437f0b1b8b97d5beef454d5198/libstdc%2B%2B-v3%2Fsrc%2Fstl_tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c70e89da092f437f0b1b8b97d5beef454d5198/libstdc%2B%2B-v3%2Fsrc%2Fstl_tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fstl_tree.cc?ref=b4c70e89da092f437f0b1b8b97d5beef454d5198", "patch": "@@ -59,51 +59,53 @@\n \n namespace std\n {\n-  void \n-  _Rb_tree_base_iterator::_M_increment()\n+  _Rb_tree_node_base*\n+  _Rb_tree_increment(_Rb_tree_node_base* __x)\n   {\n-    if (_M_node->_M_right != 0) \n+    if (__x->_M_right != 0) \n       {\n-        _M_node = _M_node->_M_right;\n-        while (_M_node->_M_left != 0)\n-          _M_node = _M_node->_M_left;\n+        __x = __x->_M_right;\n+        while (__x->_M_left != 0)\n+          __x = __x->_M_left;\n       }\n     else \n       {\n-        _Base_ptr __y = _M_node->_M_parent;\n-        while (_M_node == __y->_M_right) \n+        _Rb_tree_node_base* __y = __x->_M_parent;\n+        while (__x == __y->_M_right) \n           {\n-            _M_node = __y;\n+            __x = __y;\n             __y = __y->_M_parent;\n           }\n-        if (_M_node->_M_right != __y)\n-          _M_node = __y;\n+        if (__x->_M_right != __y)\n+          __x = __y;\n       }\n+    return __x;\n   }\n \n-  void \n-  _Rb_tree_base_iterator::_M_decrement()\n+  _Rb_tree_node_base*\n+  _Rb_tree_decrement(_Rb_tree_node_base* __x)\n   {\n-    if (_M_node->_M_color == _S_red \n-        && _M_node->_M_parent->_M_parent == _M_node)\n-      _M_node = _M_node->_M_right;\n-    else if (_M_node->_M_left != 0) \n+    if (__x->_M_color == _S_red \n+        && __x->_M_parent->_M_parent == __x)\n+      __x = __x->_M_right;\n+    else if (__x->_M_left != 0) \n       {\n-        _Base_ptr __y = _M_node->_M_left;\n+        _Rb_tree_node_base* __y = __x->_M_left;\n         while (__y->_M_right != 0)\n           __y = __y->_M_right;\n-        _M_node = __y;\n+        __x = __y;\n       }\n     else \n       {\n-        _Base_ptr __y = _M_node->_M_parent;\n-        while (_M_node == __y->_M_left) \n+        _Rb_tree_node_base* __y = __x->_M_parent;\n+        while (__x == __y->_M_left) \n           {\n-            _M_node = __y;\n+            __x = __y;\n             __y = __y->_M_parent;\n           }\n-        _M_node = __y;\n+        __x = __y;\n       }\n+    return __x;\n   }\n \n   void \n@@ -362,4 +364,23 @@ namespace std\n       }\n     return __y;\n   }\n+\n+  unsigned int\n+  _Rb_tree_black_count(const _Rb_tree_node_base* __node,\n+                       const _Rb_tree_node_base* __root)\n+  {\n+    if (__node == 0)\n+      return 0;\n+    unsigned int __sum = 0;\n+    do \n+      {\n+\tif (__node->_M_color == _S_black) \n+\t  ++__sum;\n+\tif (__node == __root) \n+\t  break;\n+\t__node = __node->_M_parent;\n+      } \n+    while (1);\n+    return __sum;\n+  }\n } // namespace std "}]}