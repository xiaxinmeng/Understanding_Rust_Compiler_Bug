{"sha": "71cf0d44d3fceb235c95d5acaf92b498f8cf923b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFjZjBkNDRkM2ZjZWIyMzVjOTVkNWFjYWY5MmI0OThmOGNmOTIzYg==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-11T18:45:21Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-19T13:36:11Z"}, "message": "Add support for optional trait functions in method calls\n\nThis adds compilation support for optional trait functions with a function\nblock. This does not support constants or default types yet.\n\nTrait references must do type resolution of their block, but this is only\nperformed once a trait is resolved. In order to avoid recursive trait\nresolution we use a on_resolved callback to invoke this to occur. The trait\nresolver works as a query based system so you have to avoid the case of\nrecursively resolving the trait untill it is stored in the internal\nmappings.\n\nAddresses #542", "tree": {"sha": "4586cb6d436eeda82408da48709647f9f0cc5eb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4586cb6d436eeda82408da48709647f9f0cc5eb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71cf0d44d3fceb235c95d5acaf92b498f8cf923b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71cf0d44d3fceb235c95d5acaf92b498f8cf923b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71cf0d44d3fceb235c95d5acaf92b498f8cf923b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71cf0d44d3fceb235c95d5acaf92b498f8cf923b/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f877a690dccd5faf5b75ad7b75e0bd85f0a5be4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f877a690dccd5faf5b75ad7b75e0bd85f0a5be4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f877a690dccd5faf5b75ad7b75e0bd85f0a5be4"}], "stats": {"total": 424, "additions": 419, "deletions": 5}, "files": [{"sha": "e446cf9dc01402918e392e08fc589c17ff9b782c", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71cf0d44d3fceb235c95d5acaf92b498f8cf923b/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71cf0d44d3fceb235c95d5acaf92b498f8cf923b/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=71cf0d44d3fceb235c95d5acaf92b498f8cf923b", "patch": "@@ -297,6 +297,219 @@ class CompileInherentImplItem : public HIRCompileBase\n   TyTy::BaseType *concrete;\n };\n \n+class CompileTraitItem : public HIRCompileBase\n+{\n+  using Rust::Compile::HIRCompileBase::visit;\n+\n+public:\n+  static void Compile (TyTy::BaseType *self, HIR::TraitItem *item, Context *ctx,\n+\t\t       TyTy::BaseType *concrete)\n+  {\n+    CompileTraitItem compiler (self, ctx, concrete);\n+    item->accept_vis (compiler);\n+  }\n+\n+  void visit (HIR::TraitItemFunc &func) override\n+  {\n+    rust_assert (func.has_block_defined ());\n+\n+    rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n+    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (concrete);\n+\n+    // items can be forward compiled which means we may not need to invoke this\n+    // code. We might also have already compiled this generic function as well.\n+    Bfunction *lookup = nullptr;\n+    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup, fntype))\n+      {\n+\t// has this been added to the list then it must be finished\n+\tif (ctx->function_completed (lookup))\n+\t  {\n+\t    Bfunction *dummy = nullptr;\n+\t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n+\t      ctx->insert_function_decl (fntype->get_ty_ref (), lookup, fntype);\n+\n+\t    return;\n+\t  }\n+      }\n+\n+    if (fntype->has_subsititions_defined ())\n+      {\n+\t// override the Hir Lookups for the substituions in this context\n+\tfntype->override_context ();\n+      }\n+\n+    // convert to the actual function type\n+    ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+\n+    HIR::TraitFunctionDecl &function = func.get_decl ();\n+    unsigned int flags = 0;\n+\n+    const Resolver::CanonicalPath *canonical_path = nullptr;\n+    rust_assert (ctx->get_mappings ()->lookup_canonical_path (\n+      func.get_mappings ().get_crate_num (), func.get_mappings ().get_nodeid (),\n+      &canonical_path));\n+\n+    std::string fn_identifier = canonical_path->get ();\n+    std::string asm_name\n+      = ctx->mangle_impl_item (self, fntype, function.get_function_name ());\n+\n+    Bfunction *fndecl\n+      = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n+\t\t\t\t       asm_name, flags, func.get_locus ());\n+    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl, fntype);\n+\n+    // setup the params\n+    TyTy::BaseType *tyret = fntype->get_return_type ();\n+    std::vector<Bvariable *> param_vars;\n+\n+    if (function.is_method ())\n+      {\n+\t// insert self\n+\tTyTy::BaseType *self_tyty_lookup = nullptr;\n+\tif (!ctx->get_tyctx ()->lookup_type (\n+\t      function.get_self ().get_mappings ().get_hirid (),\n+\t      &self_tyty_lookup))\n+\t  {\n+\t    rust_error_at (function.get_self ().get_locus (),\n+\t\t\t   \"failed to lookup self param type\");\n+\t    return;\n+\t  }\n+\n+\tBtype *self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n+\tif (self_type == nullptr)\n+\t  {\n+\t    rust_error_at (function.get_self ().get_locus (),\n+\t\t\t   \"failed to compile self param type\");\n+\t    return;\n+\t  }\n+\n+\tBvariable *compiled_self_param\n+\t  = CompileSelfParam::compile (ctx, fndecl, function.get_self (),\n+\t\t\t\t       self_type,\n+\t\t\t\t       function.get_self ().get_locus ());\n+\tif (compiled_self_param == nullptr)\n+\t  {\n+\t    rust_error_at (function.get_self ().get_locus (),\n+\t\t\t   \"failed to compile self param variable\");\n+\t    return;\n+\t  }\n+\n+\tparam_vars.push_back (compiled_self_param);\n+\tctx->insert_var_decl (function.get_self ().get_mappings ().get_hirid (),\n+\t\t\t      compiled_self_param);\n+      }\n+\n+    // offset from + 1 for the TyTy::FnType being used when this is a method to\n+    // skip over Self on the FnType\n+    size_t i = function.is_method () ? 1 : 0;\n+    for (auto referenced_param : function.get_function_params ())\n+      {\n+\tauto tyty_param = fntype->param_at (i);\n+\tauto param_tyty = tyty_param.second;\n+\n+\tauto compiled_param_type\n+\t  = TyTyResolveCompile::compile (ctx, param_tyty);\n+\tif (compiled_param_type == nullptr)\n+\t  {\n+\t    rust_error_at (referenced_param.get_locus (),\n+\t\t\t   \"failed to compile parameter type\");\n+\t    return;\n+\t  }\n+\n+\tLocation param_locus\n+\t  = ctx->get_mappings ()->lookup_location (param_tyty->get_ref ());\n+\tBvariable *compiled_param_var\n+\t  = CompileFnParam::compile (ctx, fndecl, &referenced_param,\n+\t\t\t\t     compiled_param_type, param_locus);\n+\tif (compiled_param_var == nullptr)\n+\t  {\n+\t    rust_error_at (param_locus, \"Failed to compile parameter variable\");\n+\t    return;\n+\t  }\n+\n+\tparam_vars.push_back (compiled_param_var);\n+\n+\tctx->insert_var_decl (referenced_param.get_mappings ().get_hirid (),\n+\t\t\t      compiled_param_var);\n+\ti++;\n+      }\n+\n+    if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+      {\n+\trust_fatal_error (func.get_locus (),\n+\t\t\t  \"failed to setup parameter variables\");\n+\treturn;\n+      }\n+\n+    // lookup locals\n+    auto block_expr = func.get_block_expr ().get ();\n+    auto body_mappings = block_expr->get_mappings ();\n+\n+    Resolver::Rib *rib = nullptr;\n+    if (!ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (),\n+\t\t\t\t\t      &rib))\n+      {\n+\trust_fatal_error (func.get_locus (),\n+\t\t\t  \"failed to setup locals per block\");\n+\treturn;\n+      }\n+\n+    std::vector<Bvariable *> locals;\n+    bool ok = compile_locals_for_block (*rib, fndecl, locals);\n+    rust_assert (ok);\n+\n+    Bblock *enclosing_scope = NULL;\n+    HIR::BlockExpr *function_body = func.get_block_expr ().get ();\n+    Location start_location = function_body->get_locus ();\n+    Location end_location = function_body->get_closing_locus ();\n+\n+    Bblock *code_block\n+      = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t    start_location, end_location);\n+    ctx->push_block (code_block);\n+\n+    Bvariable *return_address = nullptr;\n+    if (function.has_return_type ())\n+      {\n+\tBtype *return_type = TyTyResolveCompile::compile (ctx, tyret);\n+\n+\tbool address_is_taken = false;\n+\tBstatement *ret_var_stmt = nullptr;\n+\n+\treturn_address = ctx->get_backend ()->temporary_variable (\n+\t  fndecl, code_block, return_type, NULL, address_is_taken,\n+\t  func.get_locus (), &ret_var_stmt);\n+\n+\tctx->add_statement (ret_var_stmt);\n+      }\n+\n+    ctx->push_fn (fndecl, return_address);\n+\n+    compile_function_body (fndecl, func.get_block_expr (),\n+\t\t\t   function.has_return_type ());\n+\n+    ctx->pop_block ();\n+    auto body = ctx->get_backend ()->block_statement (code_block);\n+    if (!ctx->get_backend ()->function_set_body (fndecl, body))\n+      {\n+\trust_error_at (func.get_locus (), \"failed to set body to function\");\n+\treturn;\n+      }\n+\n+    ctx->pop_fn ();\n+    ctx->push_function (fndecl);\n+  }\n+\n+private:\n+  CompileTraitItem (TyTy::BaseType *self, Context *ctx,\n+\t\t    TyTy::BaseType *concrete)\n+    : HIRCompileBase (ctx), self (self), concrete (concrete)\n+  {}\n+\n+  TyTy::BaseType *self;\n+  TyTy::BaseType *concrete;\n+};\n+\n } // namespace Compile\n } // namespace Rust\n "}, {"sha": "97ba15dabafdb8675ebbeafc4f0e93e00d29bf64", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71cf0d44d3fceb235c95d5acaf92b498f8cf923b/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71cf0d44d3fceb235c95d5acaf92b498f8cf923b/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=71cf0d44d3fceb235c95d5acaf92b498f8cf923b", "patch": "@@ -138,8 +138,35 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \t\t{\n \t\t  // this means we are defaulting back to the trait_item if\n \t\t  // possible\n-\t\t  // TODO\n-\t\t  gcc_unreachable ();\n+\t\t  Resolver::TraitItemReference *trait_item_ref = nullptr;\n+\t\t  bool ok = trait_ref->lookup_hir_trait_item (*trait_item,\n+\t\t\t\t\t\t\t      &trait_item_ref);\n+\t\t  rust_assert (ok); // found\n+\t\t  rust_assert (\n+\t\t    trait_item_ref->is_optional ()); // has definition\n+\n+\t\t  // FIXME\n+\t\t  // TyTy::BaseType *self_type = nullptr;\n+\t\t  // if (!ctx->get_tyctx ()->lookup_type (\n+\t\t  //       expr.get_receiver ()->get_mappings ().get_hirid (),\n+\t\t  //       &self_type))\n+\t\t  //   {\n+\t\t  //     rust_error_at (expr.get_locus (),\n+\t\t  //       \t     \"failed to resolve type for self param\");\n+\t\t  //     return;\n+\t\t  //   }\n+\n+\t\t  // CompileTraitItem::Compile (\n+\t\t  //   self_type, trait_item_ref->get_hir_trait_item (), ctx,\n+\t\t  //   fntype);\n+\t\t  // if (!ctx->lookup_function_decl (fntype->get_ty_ref (),\n+\t\t  // &fn))\n+\t\t  //   {\n+\t\t  //     translated = ctx->get_backend ()->error_expression ();\n+\t\t  //     rust_error_at (expr.get_locus (),\n+\t\t  //       \t     \"forward declaration was not compiled\");\n+\t\t  //     return;\n+\t\t  //   }\n \t\t}\n \t      else\n \t\t{"}, {"sha": "c36f848f376333189ee2fc387fd4643c868b7c8c", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71cf0d44d3fceb235c95d5acaf92b498f8cf923b/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71cf0d44d3fceb235c95d5acaf92b498f8cf923b/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=71cf0d44d3fceb235c95d5acaf92b498f8cf923b", "patch": "@@ -181,8 +181,32 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \t    {\n \t      // this means we are defaulting back to the trait_item if\n \t      // possible\n-\t      // TODO\n-\t      gcc_unreachable ();\n+\t      Resolver::TraitItemReference *trait_item_ref = nullptr;\n+\t      bool ok = trait_ref->lookup_hir_trait_item (*trait_item,\n+\t\t\t\t\t\t\t  &trait_item_ref);\n+\t      rust_assert (ok);\t\t\t\t    // found\n+\t      rust_assert (trait_item_ref->is_optional ()); // has definition\n+\n+\t      TyTy::BaseType *self_type = nullptr;\n+\t      if (!ctx->get_tyctx ()->lookup_type (\n+\t\t    expr.get_receiver ()->get_mappings ().get_hirid (),\n+\t\t    &self_type))\n+\t\t{\n+\t\t  rust_error_at (expr.get_locus (),\n+\t\t\t\t \"failed to resolve type for self param\");\n+\t\t  return;\n+\t\t}\n+\n+\t      CompileTraitItem::Compile (self_type,\n+\t\t\t\t\t trait_item_ref->get_hir_trait_item (),\n+\t\t\t\t\t ctx, fntype);\n+\t      if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n+\t\t{\n+\t\t  translated = ctx->get_backend ()->error_expression ();\n+\t\t  rust_error_at (expr.get_locus (),\n+\t\t\t\t \"forward declaration was not compiled\");\n+\t\t  return;\n+\t\t}\n \t    }\n \t  else\n \t    {"}, {"sha": "718b3cec3a3123c2fda948b730d3aa55d2592e86", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71cf0d44d3fceb235c95d5acaf92b498f8cf923b/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71cf0d44d3fceb235c95d5acaf92b498f8cf923b/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=71cf0d44d3fceb235c95d5acaf92b498f8cf923b", "patch": "@@ -111,9 +111,11 @@ class TraitItemReference\n \n   const HIR::TraitItem *get_hir_trait_item () const { return hir_trait_item; }\n \n+  HIR::TraitItem *get_hir_trait_item () { return hir_trait_item; }\n+\n   Location get_locus () const { return locus; }\n \n-  const Analysis::NodeMapping &get_mappings () const\n+  const Analysis::NodeMapping get_mappings () const\n   {\n     return hir_trait_item->get_mappings ();\n   }\n@@ -146,6 +148,13 @@ class TraitItemReference\n     return get_error ();\n   }\n \n+  // this is called when the trait is completed resolution and gives the items a\n+  // chance to run their specific type resolution passes. If we call their\n+  // resolution on construction it can lead to a case where the trait being\n+  // resolved recursively trying to resolve the trait itself infinitely since\n+  // the trait will not be stored in its own map yet\n+  void on_resolved ();\n+\n private:\n   TyTy::ErrorType *get_error () const\n   {\n@@ -160,6 +169,11 @@ class TraitItemReference\n \n   TyTy::BaseType *get_type_from_fn (/*const*/ HIR::TraitItemFunc &fn) const;\n \n+  bool is_item_resolved () const;\n+  void resolve_item (HIR::TraitItemType &type);\n+  void resolve_item (HIR::TraitItemConst &constant);\n+  void resolve_item (HIR::TraitItemFunc &func);\n+\n   std::string identifier;\n   bool optional_flag;\n   TraitItemType type;\n@@ -233,6 +247,31 @@ class TraitReference\n     return hir_trait_ref->get_mappings ();\n   }\n \n+  bool lookup_hir_trait_item (const HIR::TraitItem &item,\n+\t\t\t      TraitItemReference **ref)\n+  {\n+    return lookup_trait_item (item.trait_identifier (), ref);\n+  }\n+\n+  bool lookup_trait_item (const std::string &ident, TraitItemReference **ref)\n+  {\n+    for (auto &item : item_refs)\n+      {\n+\tif (ident.compare (item.get_identifier ()) == 0)\n+\t  {\n+\t    *ref = &item;\n+\t    return true;\n+\t  }\n+      }\n+    return false;\n+  }\n+\n+  bool lookup_hir_trait_item (const HIR::TraitItem &item,\n+\t\t\t      const TraitItemReference **ref) const\n+  {\n+    return lookup_trait_item (item.trait_identifier (), ref);\n+  }\n+\n   bool lookup_trait_item (const std::string &ident,\n \t\t\t  const TraitItemReference **ref) const\n   {\n@@ -269,6 +308,14 @@ class TraitReference\n     return item_refs;\n   }\n \n+  void on_resolved ()\n+  {\n+    for (auto &item : item_refs)\n+      {\n+\titem.on_resolved ();\n+      }\n+  }\n+\n private:\n   const HIR::Trait *hir_trait_ref;\n   std::vector<TraitItemReference> item_refs;"}, {"sha": "d760709c3f18f1612c8b33785374d5279cd56449", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71cf0d44d3fceb235c95d5acaf92b498f8cf923b/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71cf0d44d3fceb235c95d5acaf92b498f8cf923b/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=71cf0d44d3fceb235c95d5acaf92b498f8cf923b", "patch": "@@ -17,6 +17,7 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-type-check-expr.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -64,5 +65,68 @@ ResolveTraitItemToRef::visit (HIR::TraitItemFunc &fn)\n \t\t\t\t self, substitutions, locus);\n }\n \n+// TraitItemReference items\n+\n+void\n+TraitItemReference::on_resolved ()\n+{\n+  switch (type)\n+    {\n+    case CONST:\n+      resolve_item (static_cast<HIR::TraitItemConst &> (*hir_trait_item));\n+      break;\n+\n+    case TYPE:\n+      resolve_item (static_cast<HIR::TraitItemType &> (*hir_trait_item));\n+      break;\n+\n+    case FN:\n+      resolve_item (static_cast<HIR::TraitItemFunc &> (*hir_trait_item));\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+void\n+TraitItemReference::resolve_item (HIR::TraitItemType &type)\n+{\n+  // TODO\n+}\n+\n+void\n+TraitItemReference::resolve_item (HIR::TraitItemConst &constant)\n+{\n+  // TODO\n+}\n+\n+void\n+TraitItemReference::resolve_item (HIR::TraitItemFunc &func)\n+{\n+  if (!is_optional ())\n+    return;\n+\n+  TyTy::BaseType *item_tyty = get_tyty ();\n+  if (item_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  // check the block and return types\n+  rust_assert (item_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+\n+  // need to get the return type from this\n+  TyTy::FnType *resolved_fn_type = static_cast<TyTy::FnType *> (item_tyty);\n+  auto expected_ret_tyty = resolved_fn_type->get_return_type ();\n+  context->push_return_type (expected_ret_tyty);\n+\n+  auto block_expr_ty\n+    = TypeCheckExpr::Resolve (func.get_block_expr ().get (), false);\n+\n+  context->pop_return_type ();\n+\n+  if (block_expr_ty->get_kind () != TyTy::NEVER)\n+    expected_ret_tyty->unify (block_expr_ty);\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "6874a3af05ae85e21101f93185e24e7a3aa861c7", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71cf0d44d3fceb235c95d5acaf92b498f8cf923b/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71cf0d44d3fceb235c95d5acaf92b498f8cf923b/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=71cf0d44d3fceb235c95d5acaf92b498f8cf923b", "patch": "@@ -154,6 +154,11 @@ class TraitResolver : public TypeCheckBase\n       trait_reference->get_mappings ().get_defid (), &tref);\n     rust_assert (ok);\n \n+    // hook to allow the trait to resolve its optional item blocks, we cant\n+    // resolve the blocks of functions etc because it can end up in a recursive\n+    // loop of trying to resolve traits as required by the types\n+    tref->on_resolved ();\n+\n     return tref;\n   }\n "}, {"sha": "3e47b1b53e69bbcafdbd4cbc35381da063062c09", "filename": "gcc/testsuite/rust/compile/torture/traits10.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71cf0d44d3fceb235c95d5acaf92b498f8cf923b/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits10.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71cf0d44d3fceb235c95d5acaf92b498f8cf923b/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits10.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits10.rs?ref=71cf0d44d3fceb235c95d5acaf92b498f8cf923b", "patch": "@@ -0,0 +1,32 @@\n+trait Foo\n+where\n+    Self: Sized,\n+{\n+    fn get(self) -> i32;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    fn test(self) -> i32 {\n+        self.get()\n+    }\n+}\n+\n+struct Bar(i32);\n+impl Foo for Bar {\n+    fn get(self) -> i32 {\n+        self.0\n+    }\n+}\n+\n+fn main() {\n+    let a;\n+    a = Bar(123);\n+\n+    let b;\n+    b = Bar::get(a);\n+\n+    let a;\n+    a = Bar(123);\n+\n+    let b;\n+    b = a.test();\n+}"}, {"sha": "355064eec1a9521484798c2a0c59d26cb0df16a1", "filename": "gcc/testsuite/rust/compile/traits1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71cf0d44d3fceb235c95d5acaf92b498f8cf923b/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71cf0d44d3fceb235c95d5acaf92b498f8cf923b/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits1.rs?ref=71cf0d44d3fceb235c95d5acaf92b498f8cf923b", "patch": "@@ -1,5 +1,6 @@\n trait Foo {\n     fn Bar() -> i32 {}\n+    // { dg-error \"expected .i32. got .().\" \"\" { target *-*-* } .-1 }\n }\n \n struct Baz;"}, {"sha": "7357c22f7d67ed4963386cfe521c45f61ce146d6", "filename": "gcc/testsuite/rust/compile/traits2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71cf0d44d3fceb235c95d5acaf92b498f8cf923b/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71cf0d44d3fceb235c95d5acaf92b498f8cf923b/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits2.rs?ref=71cf0d44d3fceb235c95d5acaf92b498f8cf923b", "patch": "@@ -1,5 +1,6 @@\n trait Foo {\n     fn Bar() -> i32 {}\n+    // { dg-error \"expected .i32. got .().\" \"\" { target *-*-* } .-1 }\n }\n \n struct Baz;"}]}