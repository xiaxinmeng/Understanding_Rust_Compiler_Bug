{"sha": "7815214ef7ef13a7a3244c6452124b7ea074284f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzgxNTIxNGVmN2VmMTNhN2EzMjQ0YzY0NTIxMjRiN2VhMDc0Mjg0Zg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-08-02T17:14:33Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-08-02T17:14:33Z"}, "message": "(expand_call): If -fcheck-memory-usage...\n\n(expand_call): If -fcheck-memory-usage, use pseudo-register, check\nindirectly called function is executable, and set rights of memory for\naggregate as write only.\n(store_one_arg): If -fcheck-memory-usage, set rights for pushed stack\nargument.\n\nFrom-SVN: r14608", "tree": {"sha": "534f4c15e119aac9bb72f881fa3b543277b985cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/534f4c15e119aac9bb72f881fa3b543277b985cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7815214ef7ef13a7a3244c6452124b7ea074284f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7815214ef7ef13a7a3244c6452124b7ea074284f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7815214ef7ef13a7a3244c6452124b7ea074284f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7815214ef7ef13a7a3244c6452124b7ea074284f/comments", "author": null, "committer": null, "parents": [{"sha": "ca20456a3333ffd33890445ea045d083fe760167", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca20456a3333ffd33890445ea045d083fe760167", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca20456a3333ffd33890445ea045d083fe760167"}], "stats": {"total": 38, "additions": 36, "deletions": 2}, "files": [{"sha": "2ae1b31d2cc9535560e74e9cff1c22abff1aa1e6", "filename": "gcc/calls.c", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7815214ef7ef13a7a3244c6452124b7ea074284f/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7815214ef7ef13a7a3244c6452124b7ea074284f/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=7815214ef7ef13a7a3244c6452124b7ea074284f", "patch": "@@ -594,6 +594,13 @@ expand_call (exp, target, ignore)\n   register tree p;\n   register int i, j;\n \n+  /* The value of the function call can be put in a hard register.  But\n+     if -fcheck-memory-usage, code which invokes functions (and thus\n+     damages some hard registers) can be inserted before using the value.\n+     So, target is always a pseudo-register in that case.  */\n+  if (flag_check_memory_usage)\n+    target = 0;\n+\n   /* See if we can find a DECL-node for the actual function.\n      As a result, decide whether this is a call to an integrable function.  */\n \n@@ -1595,6 +1602,12 @@ expand_call (exp, target, ignore)\n       push_temp_slots ();\n       funexp = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n       pop_temp_slots ();\t/* FUNEXP can't be BLKmode */\n+\n+      /* Check the function is executable.  */\n+      if (flag_check_memory_usage)\n+\temit_library_call (chkr_check_exec_libfunc, 1,\n+\t\t\t   VOIDmode, 1,\n+\t\t\t   funexp, ptr_mode);\n       emit_queue ();\n     }\n \n@@ -1838,6 +1851,15 @@ expand_call (exp, target, ignore)\n \t\t      force_reg (Pmode,\n \t\t\t\t force_operand (structure_value_addr,\n \t\t\t\t\t\tNULL_RTX)));\n+\n+      /* Mark the memory for the aggregate as write-only.  */\n+      if (flag_check_memory_usage)\n+\temit_library_call (chkr_set_right_libfunc, 1,\n+\t\t\t   VOIDmode, 3,\n+\t\t\t   structure_value_addr, ptr_mode, \n+\t\t\t   GEN_INT (struct_value_size), TYPE_MODE (sizetype),\n+\t\t\t   GEN_INT (MEMORY_USE_WO), QImode);\n+\n       if (GET_CODE (struct_value_rtx) == REG)\n \t  use_reg (&call_fusage, struct_value_rtx);\n     }\n@@ -3531,8 +3553,20 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl,\n     do_pending_stack_adjust ();\n \n   if (arg->value == arg->stack)\n-    /* If the value is already in the stack slot, we are done.  */\n-    ;\n+    {\n+      /* If the value is already in the stack slot, we are done.  */\n+      if (flag_check_memory_usage && GET_CODE (arg->stack) == MEM)\n+\t{\n+\t  if (arg->mode == BLKmode)\n+\t    abort ();\n+\n+\t  emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n+\t\t\t     XEXP (arg->stack, 0), ptr_mode, \n+\t\t\t     GEN_INT (GET_MODE_SIZE (arg->mode)),\n+\t\t\t     TYPE_MODE (sizetype),\n+\t\t\t     GEN_INT (MEMORY_USE_RW), QImode);\n+\t}\n+    }\n   else if (arg->mode != BLKmode)\n     {\n       register int size;"}]}