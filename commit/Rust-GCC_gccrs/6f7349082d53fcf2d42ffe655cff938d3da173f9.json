{"sha": "6f7349082d53fcf2d42ffe655cff938d3da173f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY3MzQ5MDgyZDUzZmNmMmQ0MmZmZTY1NWNmZjkzOGQzZGExNzNmOQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "1998-04-08T06:19:00Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "1998-04-08T06:19:00Z"}, "message": "* arm.h (LEGITIMIZE_RELOAD_ADDRESS): Define.\n\nFrom-SVN: r19039", "tree": {"sha": "4f60f1c7a4f7acdcb97f22d0b15bf952aa23b9fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f60f1c7a4f7acdcb97f22d0b15bf952aa23b9fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f7349082d53fcf2d42ffe655cff938d3da173f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f7349082d53fcf2d42ffe655cff938d3da173f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f7349082d53fcf2d42ffe655cff938d3da173f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f7349082d53fcf2d42ffe655cff938d3da173f9/comments", "author": null, "committer": null, "parents": [{"sha": "56c0e996b8de532db95bbca19548ffb92e242a0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56c0e996b8de532db95bbca19548ffb92e242a0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56c0e996b8de532db95bbca19548ffb92e242a0b"}], "stats": {"total": 57, "additions": 57, "deletions": 0}, "files": [{"sha": "5707a6d3922c39caac913ca385f1c3c33afb0f28", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f7349082d53fcf2d42ffe655cff938d3da173f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f7349082d53fcf2d42ffe655cff938d3da173f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f7349082d53fcf2d42ffe655cff938d3da173f9", "patch": "@@ -1,3 +1,7 @@\n+Wed Apr  8 06:16:45 1998  Richard Earnshaw (rearnsha@arm.com)\n+\n+\t* arm.h (LEGITIMIZE_RELOAD_ADDRESS): Define.\n+\n Wed Apr  8 00:44:18 1998  Bernd Schmidt (crux@pool.informatik.rwth-aachen.de>\n \n \t* c-lex.c (is_class_name): Delete declaration."}, {"sha": "dab507f2e79cd6b178d16cc32ff67762f5b8ec7c", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f7349082d53fcf2d42ffe655cff938d3da173f9/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f7349082d53fcf2d42ffe655cff938d3da173f9/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=6f7349082d53fcf2d42ffe655cff938d3da173f9", "patch": "@@ -877,6 +877,59 @@ enum reg_class\n   (((MODE) == HImode && TARGET_SHORT_BY_BYTES && true_regnum (X) == -1)\t\\\n    ? GENERAL_REGS : NO_REGS)\n \n+/* Try a machine-dependent way of reloading an illegitimate address\n+   operand.  If we find one, push the reload and jump to WIN.  This\n+   macro is used in only one place: `find_reloads_address' in reload.c.\n+\n+   For the ARM, we wish to handle large displacements off a base\n+   register by splitting the addend across a MOV and the mem insn.\n+   This can cut the number of reloads needed. */\n+#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+      && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n+      && REGNO (XEXP (X, 0)) < FIRST_PSEUDO_REGISTER\t\t\t\\\n+      && REG_MODE_OK_FOR_BASE_P (XEXP (X, 0), MODE)\t\t\t\\\n+      && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      HOST_WIDE_INT val = INTVAL (XEXP (X, 1));\t\t\t\t\\\n+      HOST_WIDE_INT low, high;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (MODE == DImode || (TARGET_SOFT_FLOAT && MODE == DFmode))\t\\\n+\tlow = ((val & 0xf) ^ 0x8) - 0x8;\t\t\t\t\\\n+      else if (MODE == SImode || MODE == QImode\t\t\t\t\\\n+\t       || (MODE == SFmode && TARGET_SOFT_FLOAT)\t\t\t\\\n+\t       || (MODE == HImode && ! arm_arch4))\t\t\t\\\n+\t/* Need to be careful, -4096 is not a valid offset */\t\t\\\n+\tlow = val >= 0 ? (val & 0xfff) : -((-val) & 0xfff);\t\t\\\n+      else if (MODE == HImode && arm_arch4)\t\t\t\t\\\n+\t/* Need to be careful, -256 is not a valid offset */\t\t\\\n+\tlow = val >= 0 ? (val & 0xff) : -((-val) & 0xff);\t\t\\\n+      else if (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\\\n+\t       && TARGET_HARD_FLOAT)\t\t\t\t\t\\\n+\t/* Need to be careful, -1024 is not a valid offset */\t\t\\\n+\tlow = val >= 0 ? (val & 0x3ff) : -((-val) & 0x3ff);\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      high = ((((val - low) & 0xffffffff) ^ 0x80000000) - 0x80000000);\t\\\n+      /* Check for overflow or zero */\t\t\t\t\t\\\n+      if (low == 0 || high == 0 || (high + low != val))\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      /* Reload the high part into a base reg; leave the low part\t\\\n+\t in the mem.  */\t\t\t\t\t\t\\\n+      X = gen_rtx_PLUS (GET_MODE (X),\t\t\t\t\t\\\n+\t\t\tgen_rtx_PLUS (GET_MODE (X), XEXP (X, 0),\t\\\n+\t\t\t\t      GEN_INT (high)),\t\t\t\\\n+\t\t\tGEN_INT (low));\t\t\t\t\t\\\n+      push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL_PTR,\t\\\n+\t\t   BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,\t\\\n+\t\t   OPNUM, TYPE);\t\t\t\t\t\\\n+      goto WIN;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.\n    ARM regs are UNITS_PER_WORD bits while FPU regs can hold any FP mode */"}]}