{"sha": "f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFkMmFjNGY4NGI0YjUzNTQ3NzliM2IwYTBlMTI1YjgzMDJlYmI0OQ==", "commit": {"author": {"name": "Chris Manghane", "email": "cmang@google.com", "date": "2014-09-03T22:56:09Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-09-03T22:56:09Z"}, "message": "compiler: Add precise type information on the heap.\n\n\t* go-gcc.cc (Gcc_backend::implicit_variable): Remove init\n\tparameter.  Add is_hidden parameter.\n\t(Gcc_backend::implicit_variable_set_init): New method.\n\t(Gcc_backend::implicit_variable_reference): New method.\n\nFrom-SVN: r214894", "tree": {"sha": "ba1dd2b0b5d5bd16e9bc5c7dce503f320e8a896a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba1dd2b0b5d5bd16e9bc5c7dce503f320e8a896a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/comments", "author": null, "committer": null, "parents": [{"sha": "d2e4feca24b91fd1a3e4e42f8ef82b19d0df5853", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2e4feca24b91fd1a3e4e42f8ef82b19d0df5853", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2e4feca24b91fd1a3e4e42f8ef82b19d0df5853"}], "stats": {"total": 986, "additions": 891, "deletions": 95}, "files": [{"sha": "9a759ac0af852a5333af280a3808881afe1f9f07", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49", "patch": "@@ -1,3 +1,10 @@\n+2014-09-03  Chris Manghane  <cmang@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::implicit_variable): Remove init\n+\tparameter.  Add is_hidden parameter.\n+\t(Gcc_backend::implicit_variable_set_init): New method.\n+\t(Gcc_backend::implicit_variable_reference): New method.\n+\n 2014-08-08  Ian Lance Taylor  <iant@google.com>\n \n \t* go-gcc.cc (Gcc_backend::compound_statement): Don't return"}, {"sha": "6bac84f2565f3c0a9a98280573968f926966b02c", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 77, "deletions": 14, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49", "patch": "@@ -389,9 +389,16 @@ class Gcc_backend : public Backend\n \t\t     Location, Bstatement**);\n \n   Bvariable*\n-  implicit_variable(const std::string&, Btype*, Bexpression*, bool, bool,\n+  implicit_variable(const std::string&, Btype*, bool, bool, bool,\n \t\t    size_t);\n \n+  void\n+  implicit_variable_set_init(Bvariable*, const std::string&, Btype*,\n+\t\t\t     bool, bool, bool, Bexpression*);\n+\n+  Bvariable*\n+  implicit_variable_reference(const std::string&, Btype*);\n+\n   Bvariable*\n   immutable_struct(const std::string&, bool, bool, Btype*, Location);\n \n@@ -2505,45 +2512,101 @@ Gcc_backend::temporary_variable(Bfunction* function, Bblock* bblock,\n \n Bvariable*\n Gcc_backend::implicit_variable(const std::string& name, Btype* type,\n-\t\t\t       Bexpression* init, bool is_constant,\n+\t\t\t       bool is_hidden, bool is_constant,\n \t\t\t       bool is_common, size_t alignment)\n {\n   tree type_tree = type->get_tree();\n-  tree init_tree;\n-  if (init == NULL)\n-    init_tree = NULL_TREE;\n-  else\n-    init_tree = init->get_tree();\n-  if (type_tree == error_mark_node || init_tree == error_mark_node)\n+  if (type_tree == error_mark_node)\n     return this->error_variable();\n \n   tree decl = build_decl(BUILTINS_LOCATION, VAR_DECL,\n                          get_identifier_from_string(name), type_tree);\n   DECL_EXTERNAL(decl) = 0;\n-  TREE_PUBLIC(decl) = 0;\n+  TREE_PUBLIC(decl) = !is_hidden;\n   TREE_STATIC(decl) = 1;\n+  TREE_USED(decl) = 1;\n   DECL_ARTIFICIAL(decl) = 1;\n   if (is_common)\n     {\n       DECL_COMMON(decl) = 1;\n-      TREE_PUBLIC(decl) = 1;\n-      gcc_assert(init_tree == NULL_TREE);\n+\n+      // When the initializer for one implicit_variable refers to another,\n+      // it needs to know the visibility of the referenced struct so that\n+      // compute_reloc_for_constant will return the right value.  On many\n+      // systems calling make_decl_one_only will mark the decl as weak,\n+      // which will change the return value of compute_reloc_for_constant.\n+      // We can't reliably call make_decl_one_only yet, because we don't\n+      // yet know the initializer.  This issue doesn't arise in C because\n+      // Go initializers, unlike C initializers, can be indirectly\n+      // recursive.  To ensure that compute_reloc_for_constant computes\n+      // the right value if some other initializer refers to this one, we\n+      // mark this symbol as weak here.  We undo that below in\n+      // immutable_struct_set_init before calling mark_decl_one_only.\n+      DECL_WEAK(decl) = 1;\n     }\n-  else if (is_constant)\n+  if (is_constant)\n     {\n       TREE_READONLY(decl) = 1;\n       TREE_CONSTANT(decl) = 1;\n     }\n-  DECL_INITIAL(decl) = init_tree;\n-\n   if (alignment != 0)\n     {\n       DECL_ALIGN(decl) = alignment * BITS_PER_UNIT;\n       DECL_USER_ALIGN(decl) = 1;\n     }\n \n+  go_preserve_from_gc(decl);\n+  return new Bvariable(decl);\n+}\n+\n+// Set the initalizer for a variable created by implicit_variable.\n+// This is where we finish compiling the variable.\n+\n+void\n+Gcc_backend::implicit_variable_set_init(Bvariable* var, const std::string&,\n+\t\t\t\t\tBtype*, bool, bool, bool is_common,\n+\t\t\t\t\tBexpression* init)\n+{\n+  tree decl = var->get_tree();\n+  tree init_tree;\n+  if (init == NULL)\n+    init_tree = NULL_TREE;\n+  else\n+    init_tree = init->get_tree();\n+  if (decl == error_mark_node || init_tree == error_mark_node)\n+    return;\n+\n+  DECL_INITIAL(decl) = init_tree;\n+\n+  // Now that DECL_INITIAL is set, we can't call make_decl_one_only.\n+  // See the comment where DECL_WEAK is set in implicit_variable.\n+  if (is_common)\n+    {\n+      DECL_WEAK(decl) = 0;\n+      make_decl_one_only(decl, DECL_ASSEMBLER_NAME(decl));\n+    }\n+\n+  resolve_unique_section(decl, 2, 1);\n+\n   rest_of_decl_compilation(decl, 1, 0);\n+}\n \n+// Return a reference to an implicit variable defined in another package.\n+\n+Bvariable*\n+Gcc_backend::implicit_variable_reference(const std::string& name, Btype* btype)\n+{\n+  tree type_tree = btype->get_tree();\n+  if (type_tree == error_mark_node)\n+    return this->error_variable();\n+\n+  tree decl = build_decl(BUILTINS_LOCATION, VAR_DECL,\n+                         get_identifier_from_string(name), type_tree);\n+  DECL_EXTERNAL(decl) = 0;\n+  TREE_PUBLIC(decl) = 1;\n+  TREE_STATIC(decl) = 1;\n+  DECL_ARTIFICIAL(decl) = 1;\n+  go_preserve_from_gc(decl);\n   return new Bvariable(decl);\n }\n "}, {"sha": "98c36c1f5f881259004ee6e0fcf06e110b530f4b", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 43, "deletions": 12, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49", "patch": "@@ -545,24 +545,55 @@ class Backend\n \t\t     Bstatement** pstatement) = 0;\n \n   // Create an implicit variable that is compiler-defined.  This is\n-  // used when generating GC root variables, when storing the values\n-  // of a slice constructor, and for the zero value of types.  NAME is\n-  // the name of the variable, either gc# for GC roots or C# for slice\n-  // initializers.  TYPE is the type of the implicit variable with an\n-  // initial value INIT.  IS_CONSTANT is true if the implicit variable\n-  // should be treated like it is immutable.  For slice initializers,\n-  // if the values must be copied to the heap, the variable\n-  // IS_CONSTANT.  IS_COMMON is true if the implicit variable should\n+  // used when generating GC data and roots, when storing the values\n+  // of a slice constructor, and for the zero value of types.  This returns a\n+  // Bvariable because it corresponds to an initialized variable in C.\n+  //\n+  // NAME is the name to use for the initialized variable this will create.\n+  //\n+  // TYPE is the type of the implicit variable. \n+  //\n+  // IS_HIDDEN will be true if the descriptor should only be visible\n+  // within the current object.\n+  //\n+  // IS_CONSTANT is true if the implicit variable should be treated like it is\n+  // immutable.  For slice initializers, if the values must be copied to the\n+  // heap, the variable IS_CONSTANT.\n+  //\n+  // IS_COMMON is true if the implicit variable should\n   // be treated as a common variable (multiple definitions with\n   // different sizes permitted in different object files, all merged\n   // into the largest definition at link time); this will be true for\n-  // the zero value.  If IS_COMMON is true, INIT will be NULL, and the\n-  // variable should be initialized to all zeros.  If ALIGNMENT is not\n-  // zero, it is the desired alignment of the variable.\n+  // the zero value.  IS_HIDDEN and IS_COMMON will never both be true.\n+  //\n+  // If ALIGNMENT is not zero, it is the desired alignment of the variable.\n   virtual Bvariable*\n-  implicit_variable(const std::string& name, Btype* type, Bexpression* init,\n+  implicit_variable(const std::string& name, Btype* type, bool is_hidden,\n \t\t    bool is_constant, bool is_common, size_t alignment) = 0;\n \n+\n+  // Set the initial value of a variable created by implicit_variable.\n+  // This must be called even if there is no initializer, i.e., INIT is NULL.\n+  // The NAME, TYPE, IS_HIDDEN, IS_CONSTANT, and IS_COMMON parameters are\n+  // the same ones passed to implicit_variable.  INIT will be a composite\n+  // literal of type TYPE.  It will not contain any function calls or anything\n+  // else that can not be put into a read-only data section.\n+  // It may contain the address of variables created by implicit_variable.\n+  //\n+  // If IS_COMMON is true, INIT will be NULL, and the\n+  // variable should be initialized to all zeros.\n+  virtual void\n+  implicit_variable_set_init(Bvariable*, const std::string& name, Btype* type,\n+\t\t\t     bool is_hidden, bool is_constant, bool is_common,\n+\t\t\t     Bexpression* init) = 0;\n+\n+  // Create a reference to a named implicit variable defined in some other\n+  // package.  This will be a variable created by a call to implicit_variable\n+  // with the same NAME and TYPE and with IS_COMMON passed as false.  This\n+  // corresponds to an extern global variable in C.\n+  virtual Bvariable*\n+  implicit_variable_reference(const std::string& name, Btype* type) = 0;\n+\n   // Create a named immutable initialized data structure.  This is\n   // used for type descriptors, map descriptors, and function\n   // descriptors.  This returns a Bvariable because it corresponds to"}, {"sha": "df1650a172a6af6f877fd922018862f34de121b8", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49", "patch": "@@ -3440,6 +3440,9 @@ class Unsafe_type_conversion_expression : public Expression\n   int\n   do_traverse(Traverse* traverse);\n \n+  bool\n+  do_is_immutable() const;\n+\n   Type*\n   do_type()\n   { return this->type_; }\n@@ -3480,6 +3483,27 @@ Unsafe_type_conversion_expression::do_traverse(Traverse* traverse)\n   return TRAVERSE_CONTINUE;\n }\n \n+// Return whether an unsafe type conversion is immutable.\n+\n+bool\n+Unsafe_type_conversion_expression::do_is_immutable() const\n+{\n+  Type* type = this->type_;\n+  Type* expr_type = this->expr_->type();\n+\n+  if (type->interface_type() != NULL\n+      || expr_type->interface_type() != NULL)\n+    return false;\n+\n+  if (!this->expr_->is_immutable())\n+    return false;\n+\n+  if (Type::are_convertible(type, expr_type, NULL))\n+    return true;\n+\n+  return type->is_basic_type() && expr_type->is_basic_type();\n+}\n+\n // Convert to backend representation.\n \n Bexpression*\n@@ -4115,8 +4139,11 @@ Unary_expression::do_get_backend(Translate_context* context)\n \t\t\t      && !context->is_const());\n \t    }\n \t  Bvariable* implicit =\n-\t    gogo->backend()->implicit_variable(buf, btype, bexpr, copy_to_heap,\n+\t    gogo->backend()->implicit_variable(buf, btype, true, copy_to_heap,\n \t\t\t\t\t       false, 0);\n+\t  gogo->backend()->implicit_variable_set_init(implicit, buf, btype,\n+\t\t\t\t\t\t      true, copy_to_heap, false,\n+\t\t\t\t\t\t      bexpr);\n \t  bexpr = gogo->backend()->var_expression(implicit, loc);\n \t}\n       else if ((this->expr_->is_composite_literal()\n@@ -13987,6 +14014,65 @@ Expression::make_type_descriptor(Type* type, Location location)\n   return new Type_descriptor_expression(type, location);\n }\n \n+// An expression which evaluates to a pointer to the Garbage Collection symbol\n+// of a type.\n+\n+class GC_symbol_expression : public Expression\n+{\n+ public:\n+  GC_symbol_expression(Type* type)\n+    : Expression(EXPRESSION_GC_SYMBOL, Linemap::predeclared_location()),\n+      type_(type)\n+  {}\n+\n+ protected:\n+  Type*\n+  do_type()\n+  { return Type::make_pointer_type(Type::make_void_type()); }\n+\n+  bool\n+  do_is_immutable() const\n+  { return true; }\n+\n+  void\n+  do_determine_type(const Type_context*)\n+  { }\n+\n+  Expression*\n+  do_copy()\n+  { return this; }\n+\n+  Bexpression*\n+  do_get_backend(Translate_context* context)\n+  { return this->type_->gc_symbol_pointer(context->gogo()); }\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+ private:\n+  // The type which this gc symbol describes.\n+  Type* type_;\n+};\n+\n+// Dump ast representation for a gc symbol expression.\n+\n+void\n+GC_symbol_expression::do_dump_expression(\n+    Ast_dump_context* ast_dump_context) const\n+{\n+  ast_dump_context->ostream() << \"gcdata(\";\n+  ast_dump_context->dump_type(this->type_);\n+  ast_dump_context->ostream() << \")\";\n+}\n+\n+// Make a gc symbol expression.\n+\n+Expression*\n+Expression::make_gc_symbol(Type* type)\n+{\n+  return new GC_symbol_expression(type);\n+}\n+\n // An expression which evaluates to some characteristic of a type.\n // This is only used to initialize fields of a type descriptor.  Using\n // a new expression class is slightly inefficient but gives us a good"}, {"sha": "77153dbd58f678fa4988bbb62247f0ddceab73db", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49", "patch": "@@ -103,6 +103,7 @@ class Expression\n     EXPRESSION_HEAP,\n     EXPRESSION_RECEIVE,\n     EXPRESSION_TYPE_DESCRIPTOR,\n+    EXPRESSION_GC_SYMBOL,\n     EXPRESSION_TYPE_INFO,\n     EXPRESSION_SLICE_INFO,\n     EXPRESSION_SLICE_VALUE,\n@@ -349,6 +350,11 @@ class Expression\n   static Expression*\n   make_type_descriptor(Type* type, Location);\n \n+  // Make an expression which evaluates to the address of the gc\n+  // symbol for TYPE.\n+  static Expression*\n+  make_gc_symbol(Type* type);\n+\n   // Make an expression which evaluates to some characteristic of a\n   // type.  These are only used for type descriptors, so there is no\n   // location parameter.\n@@ -1512,6 +1518,10 @@ class Binary_expression : public Expression\n   do_is_constant() const\n   { return this->left_->is_constant() && this->right_->is_constant(); }\n \n+  bool\n+  do_is_immutable() const\n+  { return this->left_->is_immutable() && this->right_->is_immutable(); }\n+\n   bool\n   do_numeric_constant_value(Numeric_constant*) const;\n "}, {"sha": "dcc2ae64961a0e581b76ae7c4f018e5f5a1033c3", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49", "patch": "@@ -655,9 +655,13 @@ Gogo::backend_zero_value()\n \n   Btype* barray_type = this->backend()->array_type(bbtype_type, blength);\n \n-  return this->backend()->implicit_variable(this->zero_value_->name(),\n-\t\t\t\t\t    barray_type, NULL, true, true,\n-\t\t\t\t\t    this->zero_value_align_);\n+  std::string zname = this->zero_value_->name();\n+  Bvariable* zvar =\n+    this->backend()->implicit_variable(zname, barray_type, false,\n+\t\t\t\t       true, true, this->zero_value_align_);\n+  this->backend()->implicit_variable_set_init(zvar, zname, barray_type,\n+\t\t\t\t\t      false, true, true, NULL);\n+  return zvar;\n }\n \n // Add statements to INIT_STMTS which run the initialization\n@@ -6837,8 +6841,10 @@ Named_object::get_backend(Gogo* gogo, std::vector<Bexpression*>& const_decls,\n           {\n             named_type->\n                 type_descriptor_pointer(gogo, Linemap::predeclared_location());\n+\t    named_type->gc_symbol_pointer(gogo);\n             Type* pn = Type::make_pointer_type(named_type);\n             pn->type_descriptor_pointer(gogo, Linemap::predeclared_location());\n+\t    pn->gc_symbol_pointer(gogo);\n           }\n       }\n       break;"}, {"sha": "302faeee3538aa04bfcff62fcbe0589b0d772912", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 465, "deletions": 5, "changes": 470, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49", "patch": "@@ -36,7 +36,8 @@ get_backend_interface_fields(Gogo* gogo, Interface_type* type,\n // Class Type.\n \n Type::Type(Type_classification classification)\n-  : classification_(classification), btype_(NULL), type_descriptor_var_(NULL)\n+  : classification_(classification), btype_(NULL), type_descriptor_var_(NULL),\n+    gc_symbol_var_(NULL)\n {\n }\n \n@@ -1236,7 +1237,7 @@ Type::make_type_descriptor_var(Gogo* gogo)\n \tType::type_descriptor_vars.insert(std::make_pair(this, bvnull));\n       if (!ins.second)\n \t{\n-\t  // We've already build a type descriptor for this type.\n+\t  // We've already built a type descriptor for this type.\n \t  this->type_descriptor_var_ = ins.first->second;\n \t  return;\n \t}\n@@ -1405,6 +1406,18 @@ Type::named_type_descriptor(Gogo* gogo, Type* type, Named_type* name)\n   return type->do_type_descriptor(gogo, name);\n }\n \n+// Generate the GC symbol for this TYPE.  VALS is the data so far in this\n+// symbol; extra values will be appended in do_gc_symbol.  OFFSET is the\n+// offset into the symbol where the GC data is located.  STACK_SIZE is the\n+// size of the GC stack when dealing with array types.\n+\n+void\n+Type::gc_symbol(Gogo* gogo, Type* type, Expression_list** vals,\n+\t\tExpression** offset, int stack_size)\n+{\n+  type->do_gc_symbol(gogo, vals, offset, stack_size);\n+}\n+\n // Make a builtin struct type from a list of fields.  The fields are\n // pairs of a name and a type.\n \n@@ -1519,14 +1532,15 @@ Type::make_type_descriptor_type()\n       // The type descriptor type.\n \n       Struct_type* type_descriptor_type =\n-\tType::make_builtin_struct_type(11,\n-\t\t\t\t       \"Kind\", uint8_type,\n+\tType::make_builtin_struct_type(12,\n+\t\t\t\t       \"kind\", uint8_type,\n \t\t\t\t       \"align\", uint8_type,\n \t\t\t\t       \"fieldAlign\", uint8_type,\n \t\t\t\t       \"size\", uintptr_type,\n \t\t\t\t       \"hash\", uint32_type,\n \t\t\t\t       \"hashfn\", uintptr_type,\n \t\t\t\t       \"equalfn\", uintptr_type,\n+\t\t\t\t       \"gc\", unsafe_pointer_type,\n \t\t\t\t       \"string\", pointer_string_type,\n \t\t\t\t       \"\", pointer_uncommon_type,\n \t\t\t\t       \"ptrToThis\",\n@@ -1973,7 +1987,7 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n   if (!this->has_pointer())\n     runtime_type_kind |= RUNTIME_TYPE_KIND_NO_POINTERS;\n   Struct_field_list::const_iterator p = fields->begin();\n-  go_assert(p->is_field_name(\"Kind\"));\n+  go_assert(p->is_field_name(\"kind\"));\n   mpz_t iv;\n   mpz_init_set_ui(iv, runtime_type_kind);\n   vals->push_back(Expression::make_integer(&iv, p->type(), bloc));\n@@ -2018,6 +2032,10 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n   vals->push_back(Expression::make_func_code_reference(hash_fn, bloc));\n   vals->push_back(Expression::make_func_code_reference(equal_fn, bloc));\n \n+  ++p;\n+  go_assert(p->is_field_name(\"gc\"));\n+  vals->push_back(Expression::make_gc_symbol(this));\n+\n   ++p;\n   go_assert(p->is_field_name(\"string\"));\n   Expression* s = Expression::make_string((name != NULL\n@@ -2067,6 +2085,160 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n   return Expression::make_struct_composite_literal(td_type, vals, bloc);\n }\n \n+// Return a pointer to the Garbage Collection information for this type.\n+\n+Bexpression*\n+Type::gc_symbol_pointer(Gogo* gogo)\n+{\n+  Type* t = this->forwarded();\n+  if (t->named_type() != NULL && t->named_type()->is_alias())\n+    t = t->named_type()->real_type();\n+  if (t->gc_symbol_var_ == NULL)\n+    {\n+      t->make_gc_symbol_var(gogo);\n+      go_assert(t->gc_symbol_var_ != NULL);\n+    }\n+  Location bloc = Linemap::predeclared_location();\n+  Bexpression* var_expr =\n+      gogo->backend()->var_expression(t->gc_symbol_var_, bloc);\n+  return gogo->backend()->address_expression(var_expr, bloc);\n+}\n+\n+// A mapping from unnamed types to GC symbol variables.\n+\n+Type::GC_symbol_vars Type::gc_symbol_vars;\n+\n+// Build the GC symbol for this type.\n+\n+void\n+Type::make_gc_symbol_var(Gogo* gogo)\n+{\n+  go_assert(this->gc_symbol_var_ == NULL);\n+\n+  Named_type* nt = this->named_type();\n+\n+  // We can have multiple instances of unnamed types and similar to type\n+  // descriptors, we only want to the emit the GC data once, so we use a\n+  // hash table.\n+  Bvariable** phash = NULL;\n+  if (nt == NULL)\n+    {\n+      Bvariable* bvnull = NULL;\n+      std::pair<GC_symbol_vars::iterator, bool> ins =\n+\tType::gc_symbol_vars.insert(std::make_pair(this, bvnull));\n+      if (!ins.second)\n+\t{\n+\t  // We've already built a gc symbol for this type.\n+\t  this->gc_symbol_var_ = ins.first->second;\n+\t  return;\n+\t}\n+      phash = &ins.first->second;\n+    }\n+\n+  std::string sym_name = this->type_descriptor_var_name(gogo, nt) + \"$gc\";\n+\n+  // Build the contents of the gc symbol.\n+  Expression* sym_init = this->gc_symbol_constructor(gogo);\n+  Btype* sym_btype = sym_init->type()->get_backend(gogo);\n+\n+  // If the type descriptor for this type is defined somewhere else, so is the\n+  // GC symbol.\n+  const Package* dummy;\n+  if (this->type_descriptor_defined_elsewhere(nt, &dummy))\n+    {\n+      this->gc_symbol_var_ =\n+\tgogo->backend()->implicit_variable_reference(sym_name, sym_btype);\n+      if (phash != NULL)\n+\t*phash = this->gc_symbol_var_;\n+      return;\n+    }\n+\n+  // See if this gc symbol can appear in multiple packages.\n+  bool is_common = false;\n+  if (nt != NULL)\n+    {\n+      // We create the symbol for a builtin type whenever we need\n+      // it.\n+      is_common = nt->is_builtin();\n+    }\n+  else\n+    {\n+      // This is an unnamed type.  The descriptor could be defined in\n+      // any package where it is needed, and the linker will pick one\n+      // descriptor to keep.\n+      is_common = true;\n+    }\n+\n+  // Since we are building the GC symbol in this package, we must create the\n+  // variable before converting the initializer to its backend representation\n+  // because the initializer may refer to the GC symbol for this type.\n+  this->gc_symbol_var_ =\n+    gogo->backend()->implicit_variable(sym_name, sym_btype, false, true, is_common, 0);\n+  if (phash != NULL)\n+    *phash = this->gc_symbol_var_;\n+\n+  Translate_context context(gogo, NULL, NULL, NULL);\n+  context.set_is_const();\n+  Bexpression* sym_binit = sym_init->get_backend(&context);\n+  gogo->backend()->implicit_variable_set_init(this->gc_symbol_var_, sym_name,\n+\t\t\t\t\t      sym_btype, false, true, is_common,\n+\t\t\t\t\t      sym_binit);\n+}\n+\n+// Return an array literal for the Garbage Collection information for this type.\n+\n+Expression*\n+Type::gc_symbol_constructor(Gogo* gogo)\n+{\n+  Location bloc = Linemap::predeclared_location();\n+\n+  // The common GC Symbol data starts with the width of the type and ends\n+  // with the GC Opcode GC_END.\n+  // However, for certain types, the GC symbol may include extra information\n+  // before the ending opcode, so we pass the expression list into\n+  // Type::gc_symbol to allow it to add extra information as is necessary.\n+  Expression_list* vals = new Expression_list;\n+\n+  Type* uintptr_t = Type::lookup_integer_type(\"uintptr\");\n+  // width\n+  vals->push_back(Expression::make_type_info(this,\n+\t\t\t\t\t     Expression::TYPE_INFO_SIZE));\n+\n+  mpz_t off;\n+  mpz_init_set_ui(off, 0UL);\n+  Expression* offset = Expression::make_integer(&off, uintptr_t, bloc);\n+  mpz_clear(off);\n+\n+  this->do_gc_symbol(gogo, &vals, &offset, 0);\n+\n+  mpz_t end;\n+  mpz_init_set_ui(end, GC_END);\n+  vals->push_back(Expression::make_integer(&end, uintptr_t, bloc));\n+  mpz_clear(end);\n+\n+  mpz_t lenval;\n+  mpz_init_set_ui(lenval, vals->size() + 1);\n+  Expression* len = Expression::make_integer(&lenval, NULL, bloc);\n+  mpz_clear(lenval);\n+\n+  Array_type* gc_symbol_type = Type::make_array_type(uintptr_t, len);\n+  return Expression::make_array_composite_literal(gc_symbol_type, vals, bloc);\n+}\n+\n+// Advance the OFFSET of the GC symbol by this type's width.\n+\n+void\n+Type::advance_gc_offset(Expression** offset)\n+{\n+  if (this->is_error_type())\n+    return;\n+\n+  Location bloc = Linemap::predeclared_location();\n+  Expression* width =\n+    Expression::make_type_info(this, Expression::TYPE_INFO_SIZE);\n+  *offset = Expression::make_binary(OPERATOR_PLUS, *offset, width, bloc);\n+}\n+\n // Return a composite literal for the uncommon type information for\n // this type.  UNCOMMON_STRUCT_TYPE is the type of the uncommon type\n // struct.  If name is not NULL, it is the name of the type.  If\n@@ -2497,6 +2669,10 @@ class Error_type : public Type\n   do_reflection(Gogo*, std::string*) const\n   { go_assert(saw_errors()); }\n \n+  void\n+  do_gc_symbol(Gogo*, Expression_list**, Expression**, int)\n+  { go_assert(saw_errors()); }\n+\n   void\n   do_mangled_name(Gogo*, std::string* ret) const\n   { ret->push_back('E'); }\n@@ -2535,6 +2711,10 @@ class Void_type : public Type\n   do_reflection(Gogo*, std::string*) const\n   { }\n \n+  void\n+  do_gc_symbol(Gogo*, Expression_list**, Expression**, int)\n+  { }\n+\n   void\n   do_mangled_name(Gogo*, std::string* ret) const\n   { ret->push_back('v'); }\n@@ -2573,6 +2753,9 @@ class Boolean_type : public Type\n   do_reflection(Gogo*, std::string* ret) const\n   { ret->append(\"bool\"); }\n \n+  void\n+  do_gc_symbol(Gogo*, Expression_list**, Expression**, int);\n+\n   void\n   do_mangled_name(Gogo*, std::string* ret) const\n   { ret->push_back('b'); }\n@@ -2593,6 +2776,12 @@ Boolean_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n     }\n }\n \n+// Update the offset of the GC symbol.\n+\n+void\n+Boolean_type::do_gc_symbol(Gogo*, Expression_list**, Expression** offset, int)\n+{ this->advance_gc_offset(offset); }\n+\n Type*\n Type::make_boolean_type()\n {\n@@ -3102,6 +3291,22 @@ String_type::do_reflection(Gogo*, std::string* ret) const\n   ret->append(\"string\");\n }\n \n+// Generate GC symbol for strings.\n+\n+void\n+String_type::do_gc_symbol(Gogo*, Expression_list** vals,\n+\t\t\t  Expression** offset, int)\n+{\n+  Location bloc = Linemap::predeclared_location();\n+  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+  mpz_t opval;\n+  mpz_init_set_ui(opval, GC_STRING);\n+  (*vals)->push_back(Expression::make_integer(&opval, uintptr_type, bloc));\n+  mpz_clear(opval);\n+  (*vals)->push_back(*offset);\n+  this->advance_gc_offset(offset);\n+}\n+\n // Mangled name of a string type.\n \n void\n@@ -3172,6 +3377,10 @@ class Sink_type : public Type\n   do_reflection(Gogo*, std::string*) const\n   { go_unreachable(); }\n \n+  void\n+  do_gc_symbol(Gogo*, Expression_list**, Expression**, int)\n+  { go_unreachable(); }\n+\n   void\n   do_mangled_name(Gogo*, std::string*) const\n   { go_unreachable(); }\n@@ -3754,6 +3963,25 @@ Function_type::do_reflection(Gogo* gogo, std::string* ret) const\n     }\n }\n \n+// Generate GC symbol for a function type.\n+\n+void\n+Function_type::do_gc_symbol(Gogo*, Expression_list** vals,\n+\t\t\t    Expression** offset, int)\n+{\n+  Location bloc = Linemap::predeclared_location();\n+  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+\n+  // We use GC_APTR here because we do not currently have a way to describe the\n+  // the type of the possible function closure.  FIXME.\n+  mpz_t opval;\n+  mpz_init_set_ui(opval, GC_APTR);\n+  (*vals)->push_back(Expression::make_integer(&opval, uintptr_type, bloc));\n+  mpz_clear(opval);\n+  (*vals)->push_back(*offset);\n+  this->advance_gc_offset(offset);\n+}\n+\n // Mangled name.\n \n void\n@@ -4156,6 +4384,26 @@ Pointer_type::do_reflection(Gogo* gogo, std::string* ret) const\n   this->append_reflection(this->to_type_, gogo, ret);\n }\n \n+// Generate GC symbol for pointer types.\n+\n+void\n+Pointer_type::do_gc_symbol(Gogo*, Expression_list** vals,\n+\t\t\t   Expression** offset, int)\n+{\n+  Location loc = Linemap::predeclared_location();\n+  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+\n+  mpz_t opval;\n+  mpz_init_set_ui(opval, this->to_type_->has_pointer() ? GC_PTR : GC_APTR);\n+  (*vals)->push_back(Expression::make_integer(&opval, uintptr_type, loc));\n+  mpz_clear(opval);\n+  (*vals)->push_back(*offset);\n+\n+  if (this->to_type_->has_pointer())\n+    (*vals)->push_back(Expression::make_gc_symbol(this->to_type_));\n+  this->advance_gc_offset(offset);\n+}\n+\n // Mangled name.\n \n void\n@@ -4235,6 +4483,10 @@ class Nil_type : public Type\n   do_reflection(Gogo*, std::string*) const\n   { go_unreachable(); }\n \n+  void\n+  do_gc_symbol(Gogo*, Expression_list**, Expression**, int)\n+  { go_unreachable(); }\n+\n   void\n   do_mangled_name(Gogo*, std::string* ret) const\n   { ret->push_back('n'); }\n@@ -4292,6 +4544,10 @@ class Call_multiple_result_type : public Type\n   do_reflection(Gogo*, std::string*) const\n   { go_assert(saw_errors()); }\n \n+  void\n+  do_gc_symbol(Gogo*, Expression_list**, Expression**, int)\n+  { go_unreachable(); }\n+\n   void\n   do_mangled_name(Gogo*, std::string*) const\n   { go_assert(saw_errors()); }\n@@ -5319,6 +5575,27 @@ Struct_type::do_reflection(Gogo* gogo, std::string* ret) const\n   ret->push_back('}');\n }\n \n+// Generate GC symbol for struct types.\n+\n+void\n+Struct_type::do_gc_symbol(Gogo* gogo, Expression_list** vals,\n+\t\t\t  Expression** offset, int stack_size)\n+{\n+  Location bloc = Linemap::predeclared_location();\n+  const Struct_field_list* sfl = this->fields();\n+  for (Struct_field_list::const_iterator p = sfl->begin();\n+       p != sfl->end();\n+       ++p)\n+    {\n+      Expression* field_offset =\n+  \tExpression::make_struct_field_offset(this, &*p);\n+      Expression* o =\n+  \tExpression::make_binary(OPERATOR_PLUS, *offset, field_offset, bloc);\n+      Type::gc_symbol(gogo, p->type(), vals, &o, stack_size);\n+    }\n+  this->advance_gc_offset(offset);\n+}\n+\n // Mangled name.\n \n void\n@@ -6204,6 +6481,115 @@ Array_type::do_reflection(Gogo* gogo, std::string* ret) const\n   this->append_reflection(this->element_type_, gogo, ret);\n }\n \n+// GC Symbol construction for array types.\n+\n+void\n+Array_type::do_gc_symbol(Gogo* gogo, Expression_list** vals,\n+\t\t\t Expression** offset, int stack_size)\n+{\n+  if (this->length_ == NULL)\n+    this->slice_gc_symbol(gogo, vals, offset, stack_size);\n+  else\n+    this->array_gc_symbol(gogo, vals, offset, stack_size);\n+}\n+\n+// Generate the GC Symbol for a slice.\n+\n+void\n+Array_type::slice_gc_symbol(Gogo* gogo, Expression_list** vals,\n+\t\t\t    Expression** offset, int)\n+{\n+  Location bloc = Linemap::predeclared_location();\n+\n+  // Differentiate between slices with zero-length and non-zero-length values.\n+  Type* element_type = this->element_type();\n+  Btype* ebtype = element_type->get_backend(gogo);\n+  size_t element_size = gogo->backend()->type_size(ebtype);\n+\n+  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+  mpz_t opval;\n+  mpz_init_set_ui(opval, element_size == 0 ? GC_APTR : GC_SLICE);\n+  (*vals)->push_back(Expression::make_integer(&opval, uintptr_type, bloc));\n+  mpz_clear(opval);\n+  (*vals)->push_back(*offset);\n+\n+  if (element_size != 0)\n+    (*vals)->push_back(Expression::make_gc_symbol(element_type));\n+  this->advance_gc_offset(offset);\n+}\n+\n+// Generate the GC symbol for an array.\n+\n+void\n+Array_type::array_gc_symbol(Gogo* gogo, Expression_list** vals,\n+\t\t\t    Expression** offset, int stack_size)\n+{\n+  Location bloc = Linemap::predeclared_location();\n+\n+  Numeric_constant nc;\n+  unsigned long bound;\n+  if (!this->length_->numeric_constant_value(&nc)\n+      || nc.to_unsigned_long(&bound) == Numeric_constant::NC_UL_NOTINT)\n+    go_assert(saw_errors());\n+\n+  Btype* pbtype = gogo->backend()->pointer_type(gogo->backend()->void_type());\n+  size_t pwidth = gogo->backend()->type_size(pbtype);\n+  size_t iwidth = gogo->backend()->type_size(this->get_backend(gogo));\n+\n+  Type* element_type = this->element_type();\n+  if (bound < 1 || !element_type->has_pointer())\n+    this->advance_gc_offset(offset);\n+  else if (bound == 1 || iwidth <= 4 * pwidth)\n+    {\n+      for (unsigned int i = 0; i < bound; ++i)\n+\tType::gc_symbol(gogo, element_type, vals, offset, stack_size);\n+    }\n+  else\n+    {\n+      Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+\n+      mpz_t op;\n+      if (stack_size < GC_STACK_CAPACITY)\n+  \t{\n+  \t  mpz_init_set_ui(op, GC_ARRAY_START);\n+  \t  (*vals)->push_back(Expression::make_integer(&op, uintptr_type, bloc));\n+  \t  mpz_clear(op);\n+  \t  (*vals)->push_back(*offset);\n+\t  Expression* uintptr_len =\n+\t    Expression::make_cast(uintptr_type, this->length_, bloc);\n+  \t  (*vals)->push_back(uintptr_len);\n+\n+\t  Expression* width =\n+\t    Expression::make_type_info(element_type,\n+\t\t\t\t       Expression::TYPE_INFO_SIZE);\n+  \t  (*vals)->push_back(width);\n+\n+  \t  mpz_t zero;\n+  \t  mpz_init_set_ui(zero, 0UL);\n+  \t  Expression* offset2 =\n+  \t    Expression::make_integer(&zero, uintptr_type, bloc);\n+  \t  mpz_clear(zero);\n+\n+\t  Type::gc_symbol(gogo, element_type, vals, &offset2, stack_size + 1);\n+  \t  mpz_init_set_ui(op, GC_ARRAY_NEXT);\n+  \t  (*vals)->push_back(Expression::make_integer(&op, uintptr_type, bloc));\n+  \t}\n+      else\n+  \t{\n+  \t  mpz_init_set_ui(op, GC_REGION);\n+  \t  (*vals)->push_back(Expression::make_integer(&op, uintptr_type, bloc));\n+\t  (*vals)->push_back(*offset);\n+\n+\t  Expression* width =\n+\t    Expression::make_type_info(this, Expression::TYPE_INFO_SIZE);\n+  \t  (*vals)->push_back(width);\n+\t  (*vals)->push_back(Expression::make_gc_symbol(this));\n+  \t}\n+      mpz_clear(op);\n+      this->advance_gc_offset(offset);\n+    }\n+}\n+\n // Mangled name.\n \n void\n@@ -6513,6 +6899,24 @@ Map_type::do_reflection(Gogo* gogo, std::string* ret) const\n   this->append_reflection(this->val_type_, gogo, ret);\n }\n \n+// Generate GC symbol for a map.\n+\n+void\n+Map_type::do_gc_symbol(Gogo*, Expression_list** vals,\n+\t\t       Expression** offset, int)\n+{\n+  // TODO(cmang): Generate GC data for the Map elements.\n+  Location bloc = Linemap::predeclared_location();\n+  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+\n+  mpz_t opval;\n+  mpz_init_set_ui(opval, GC_APTR);\n+  (*vals)->push_back(Expression::make_integer(&opval, uintptr_type, bloc));\n+  mpz_clear(opval);\n+  (*vals)->push_back(*offset);\n+  this->advance_gc_offset(offset);\n+}\n+\n // Mangled name for a map.\n \n void\n@@ -6686,6 +7090,30 @@ Channel_type::do_reflection(Gogo* gogo, std::string* ret) const\n   this->append_reflection(this->element_type_, gogo, ret);\n }\n \n+// Generate GC symbol for channels.\n+\n+void\n+Channel_type::do_gc_symbol(Gogo*, Expression_list** vals,\n+\t\t\t   Expression** offset, int)\n+{\n+  Location bloc = Linemap::predeclared_location();\n+  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+\n+  mpz_t opval;\n+  mpz_init_set_ui(opval, GC_CHAN_PTR);\n+  (*vals)->push_back(Expression::make_integer(&opval, uintptr_type, bloc));\n+  mpz_clear(opval);\n+  (*vals)->push_back(*offset);\n+ \n+  Type* unsafeptr_type = Type::make_pointer_type(Type::make_void_type());\n+  Expression* type_descriptor =\n+    Expression::make_type_descriptor(this, bloc);\n+  type_descriptor =\n+    Expression::make_unsafe_cast(unsafeptr_type, type_descriptor, bloc);\n+  (*vals)->push_back(type_descriptor);\n+  this->advance_gc_offset(offset);\n+}\n+\n // Mangled name.\n \n void\n@@ -7574,6 +8002,24 @@ Interface_type::do_reflection(Gogo* gogo, std::string* ret) const\n   ret->append(\"}\");\n }\n \n+// Generate GC symbol for interface types.\n+\n+void\n+Interface_type::do_gc_symbol(Gogo*, Expression_list** vals,\n+\t\t\t     Expression** offset, int)\n+{\n+  Location bloc = Linemap::predeclared_location();\n+  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+\n+  mpz_t opval;\n+  mpz_init_set_ui(opval, this->is_empty() ? GC_EFACE : GC_IFACE);\n+  (*vals)->push_back(Expression::make_integer(&opval, uintptr_type,\n+\t\t\t\t\t      bloc));\n+  mpz_clear(opval);\n+  (*vals)->push_back(*offset);\n+  this->advance_gc_offset(offset);\n+}\n+\n // Mangled name.\n \n void\n@@ -8810,6 +9256,20 @@ Named_type::do_reflection(Gogo* gogo, std::string* ret) const\n   ret->append(Gogo::unpack_hidden_name(this->named_object_->name()));\n }\n \n+// Generate GC symbol for named types.\n+\n+void\n+Named_type::do_gc_symbol(Gogo* gogo, Expression_list** vals,\n+\t\t\t Expression** offset, int stack)\n+{\n+  if (!this->seen_)\n+    {\n+      this->seen_ = true;\n+      Type::gc_symbol(gogo, this->real_type(), vals, offset, stack);\n+      this->seen_ = false;\n+    }\n+}\n+\n // Get the mangled name.\n \n void"}, {"sha": "447861c4846842259d8f1537d27ca8ba679d1ebc", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49", "patch": "@@ -83,6 +83,28 @@ static const int RUNTIME_TYPE_KIND_UNSAFE_POINTER = 26;\n \n static const int RUNTIME_TYPE_KIND_NO_POINTERS = (1 << 7);\n \n+// GC instruction opcodes.  These must match the values in libgo/runtime/mgc0.h.\n+enum GC_Opcode\n+{\n+  GC_END = 0,     // End of object, loop or subroutine.\n+  GC_PTR,         // A typed pointer.\n+  GC_APTR,        // Pointer to an arbitrary object.\n+  GC_ARRAY_START, // Start an array with a fixed length.\n+  GC_ARRAY_NEXT,  // The next element of an array.\n+  GC_CALL,        // Call a subroutine.\n+  GC_CHAN_PTR,    // Go channel.\n+  GC_STRING,      // Go string.\n+  GC_EFACE,       // interface{}.\n+  GC_IFACE,       // interface{...}.\n+  GC_SLICE,       // Go slice.\n+  GC_REGION,      // A region/part of the current object.\n+\n+  GC_NUM_INSTR    // Number of instruction opcodes\n+};\n+\n+// The GC Stack Capacity must match the value in libgo/runtime/mgc0.h.\n+static const int GC_STACK_CAPACITY = 8;\n+\n // To build the complete list of methods for a named type we need to\n // gather all methods from anonymous fields.  Those methods may\n // require an arbitrary set of indirections and field offsets.  There\n@@ -911,6 +933,10 @@ class Type\n   Bexpression*\n   type_descriptor_pointer(Gogo* gogo, Location);\n \n+  // Build the Garbage Collection symbol for this type.  Return a pointer to it.\n+  Bexpression*\n+  gc_symbol_pointer(Gogo* gogo);\n+\n   // Return the type reflection string for this type.\n   std::string\n   reflection(Gogo*) const;\n@@ -995,6 +1021,9 @@ class Type\n   virtual Expression*\n   do_type_descriptor(Gogo*, Named_type* name) = 0;\n \n+  virtual void\n+  do_gc_symbol(Gogo*, Expression_list**, Expression**, int) = 0;\n+\n   virtual void\n   do_reflection(Gogo*, std::string*) const = 0;\n \n@@ -1050,6 +1079,22 @@ class Type\n   type_descriptor_constructor(Gogo*, int runtime_type_kind, Named_type*,\n \t\t\t      const Methods*, bool only_value_methods);\n \n+  // Generate the GC symbol for this TYPE.  VALS is the data so far in this\n+  // symbol; extra values will be appended in do_gc_symbol.  OFFSET is the\n+  // offset into the symbol where the GC data is located.  STACK_SIZE is the\n+  // size of the GC stack when dealing with array types.\n+  static void\n+  gc_symbol(Gogo*, Type* type, Expression_list** vals, Expression** offset,\n+\t    int stack_size);\n+\n+  // Build a composite literal for the GC symbol of this type.\n+  Expression*\n+  gc_symbol_constructor(Gogo*);\n+\n+  // Advance the OFFSET of the GC symbol by the size of this type.\n+  void\n+  advance_gc_offset(Expression** offset);\n+\n   // For the benefit of child class reflection string generation.\n   void\n   append_reflection(const Type* type, Gogo* gogo, std::string* ret) const\n@@ -1126,6 +1171,16 @@ class Type\n   void\n   make_type_descriptor_var(Gogo*);\n \n+  // Map unnamed types to type descriptor decls.\n+  typedef Unordered_map_hash(const Type*, Bvariable*, Type_hash_identical,\n+\t\t\t     Type_identical) GC_symbol_vars;\n+\n+  static GC_symbol_vars gc_symbol_vars;\n+\n+  // Build the GC symbol for this type.\n+  void\n+  make_gc_symbol_var(Gogo*);\n+\n   // Return the name of the type descriptor variable.  If NAME is not\n   // NULL, it is the name to use.\n   std::string\n@@ -1253,6 +1308,9 @@ class Type\n   // The type descriptor for this type.  This starts out as NULL and\n   // is filled in as needed.\n   Bvariable* type_descriptor_var_;\n+  // The GC symbol for this type.  This starts out as NULL and\n+  // is filled in as needed.\n+  Bvariable* gc_symbol_var_;\n };\n \n // Type hash table operations.\n@@ -1506,6 +1564,10 @@ class Integer_type : public Type\n   void\n   do_reflection(Gogo*, std::string*) const;\n \n+  void\n+  do_gc_symbol(Gogo*, Expression_list**, Expression** offset, int)\n+  { this->advance_gc_offset(offset); }\n+\n   void\n   do_mangled_name(Gogo*, std::string*) const;\n \n@@ -1583,6 +1645,10 @@ class Float_type : public Type\n   void\n   do_reflection(Gogo*, std::string*) const;\n \n+  void\n+  do_gc_symbol(Gogo*, Expression_list**, Expression** offset, int)\n+  { this->advance_gc_offset(offset); }\n+\n   void\n   do_mangled_name(Gogo*, std::string*) const;\n \n@@ -1652,6 +1718,10 @@ class Complex_type : public Type\n   void\n   do_reflection(Gogo*, std::string*) const;\n \n+  void\n+  do_gc_symbol(Gogo*, Expression_list**, Expression** offset, int)\n+  { this->advance_gc_offset(offset); }\n+\n   void\n   do_mangled_name(Gogo*, std::string*) const;\n \n@@ -1701,6 +1771,9 @@ class String_type : public Type\n   void\n   do_reflection(Gogo*, std::string*) const;\n \n+  void\n+  do_gc_symbol(Gogo*, Expression_list**, Expression**, int);\n+\n   void\n   do_mangled_name(Gogo*, std::string* ret) const;\n \n@@ -1836,6 +1909,9 @@ class Function_type : public Type\n   void\n   do_reflection(Gogo*, std::string*) const;\n \n+  void\n+  do_gc_symbol(Gogo*, Expression_list**, Expression**, int);\n+\n   void\n   do_mangled_name(Gogo*, std::string*) const;\n \n@@ -1952,6 +2028,9 @@ class Pointer_type : public Type\n   void\n   do_reflection(Gogo*, std::string*) const;\n \n+  void\n+  do_gc_symbol(Gogo*, Expression_list**, Expression**, int);\n+\n   void\n   do_mangled_name(Gogo*, std::string*) const;\n \n@@ -2250,6 +2329,9 @@ class Struct_type : public Type\n   void\n   do_reflection(Gogo*, std::string*) const;\n \n+  void\n+  do_gc_symbol(Gogo*, Expression_list**, Expression**, int);\n+\n   void\n   do_mangled_name(Gogo*, std::string*) const;\n \n@@ -2392,6 +2474,9 @@ class Array_type : public Type\n   void\n   do_reflection(Gogo*, std::string*) const;\n \n+  void\n+  do_gc_symbol(Gogo*, Expression_list**, Expression**, int);\n+\n   void\n   do_mangled_name(Gogo*, std::string*) const;\n \n@@ -2408,6 +2493,12 @@ class Array_type : public Type\n   Expression*\n   slice_type_descriptor(Gogo*, Named_type*);\n \n+  void\n+  slice_gc_symbol(Gogo*, Expression_list**, Expression**, int);\n+\n+  void\n+  array_gc_symbol(Gogo*, Expression_list**, Expression**, int);\n+\n   // The type of elements of the array.\n   Type* element_type_;\n   // The number of elements.  This may be NULL.\n@@ -2484,6 +2575,9 @@ class Map_type : public Type\n   void\n   do_reflection(Gogo*, std::string*) const;\n \n+  void\n+  do_gc_symbol(Gogo*, Expression_list**, Expression**, int);\n+\n   void\n   do_mangled_name(Gogo*, std::string*) const;\n \n@@ -2570,6 +2664,9 @@ class Channel_type : public Type\n   void\n   do_reflection(Gogo*, std::string*) const;\n \n+  void\n+  do_gc_symbol(Gogo*, Expression_list**, Expression**, int);\n+\n   void\n   do_mangled_name(Gogo*, std::string*) const;\n \n@@ -2703,6 +2800,9 @@ class Interface_type : public Type\n   void\n   do_reflection(Gogo*, std::string*) const;\n \n+  void\n+  do_gc_symbol(Gogo*, Expression_list**, Expression**, int);\n+\n   void\n   do_mangled_name(Gogo*, std::string*) const;\n \n@@ -2988,6 +3088,10 @@ class Named_type : public Type\n   void\n   do_reflection(Gogo*, std::string*) const;\n \n+  void\n+  do_gc_symbol(Gogo* gogo, Expression_list** vals, Expression** offset,\n+\t       int stack);\n+\n   void\n   do_mangled_name(Gogo*, std::string* ret) const;\n \n@@ -3132,6 +3236,11 @@ class Forward_declaration_type : public Type\n   void\n   do_reflection(Gogo*, std::string*) const;\n \n+  void\n+  do_gc_symbol(Gogo* gogo, Expression_list** vals, Expression** offset,\n+\t       int stack_size)\n+  { Type::gc_symbol(gogo, this->real_type(), vals, offset, stack_size); }\n+\n   void\n   do_mangled_name(Gogo*, std::string* ret) const;\n "}, {"sha": "91697c4b56b608f671ed5e4cedb6fe39e3cf0c83", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49", "patch": "@@ -255,6 +255,7 @@ type rtype struct {\n \thashfn  uintptr // hash function code\n \tequalfn uintptr // equality function code\n \n+\tgc            unsafe.Pointer // garbage collection data\n \tstring        *string        // string form; unnecessary  but undeniably useful\n \t*uncommonType                // (relatively) uncommon fields\n \tptrToThis     *rtype         // type for pointer to this type, if used in binary or has methods\n@@ -1130,6 +1131,18 @@ func (t *rtype) ptrTo() *rtype {\n \tp.zero = unsafe.Pointer(&make([]byte, p.size)[0])\n \tp.elem = t\n \n+\tif t.kind&kindNoPointers != 0 {\n+\t\tp.gc = unsafe.Pointer(&ptrDataGCProg)\n+\t} else {\n+\t\tp.gc = unsafe.Pointer(&ptrGC{\n+\t\t\twidth:  p.size,\n+\t\t\top:     _GC_PTR,\n+\t\t\toff:    0,\n+\t\t\telemgc: t.gc,\n+\t\t\tend:    _GC_END,\n+\t\t})\n+\t}\n+\n \tq := canonicalize(&p.rtype)\n \tp = (*ptrType)(unsafe.Pointer(q.(*rtype)))\n \n@@ -1471,8 +1484,16 @@ func ChanOf(dir ChanDir, t Type) Type {\n \tch.ptrToThis = nil\n \tch.zero = unsafe.Pointer(&make([]byte, ch.size)[0])\n \n+\tch.gc = unsafe.Pointer(&chanGC{\n+\t\twidth: ch.size,\n+\t\top:    _GC_CHAN_PTR,\n+\t\toff:   0,\n+\t\ttyp:   &ch.rtype,\n+\t\tend:   _GC_END,\n+\t})\n+\n \t// INCORRECT. Uncomment to check that TestChanOfGC fails when ch.gc is wrong.\n-\t//ch.gc = unsafe.Pointer(&badGC{width: ch.size, end: _GC_END})\n+\t// ch.gc = unsafe.Pointer(&badGC{width: ch.size, end: _GC_END})\n \n \treturn cachePut(ckey, &ch.rtype)\n }\n@@ -1524,10 +1545,13 @@ func MapOf(key, elem Type) Type {\n \t// \twidth:  unsafe.Sizeof(uintptr(0)),\n \t// \top:     _GC_PTR,\n \t// \toff:    0,\n-\t// \telemgc: mt.hmap.gc,\n+\t// \telemgc: nil,\n \t// \tend:    _GC_END,\n \t// })\n \n+\t// TODO(cmang): Generate GC data for Map elements.\n+\tmt.gc = unsafe.Pointer(&ptrDataGCProg)\n+\n \t// INCORRECT. Uncomment to check that TestMapOfGC and TestMapOfGCValues\n \t// fail when mt.gc is wrong.\n \t//mt.gc = unsafe.Pointer(&badGC{width: mt.size, end: _GC_END})\n@@ -1593,8 +1617,7 @@ func bucketOf(ktyp, etyp *rtype) *rtype {\n \n // Take the GC program for \"t\" and append it to the GC program \"gc\".\n func appendGCProgram(gc []uintptr, t *rtype) []uintptr {\n-\t// p := t.gc\n-\tvar p unsafe.Pointer\n+\tp := t.gc\n \tp = unsafe.Pointer(uintptr(p) + unsafe.Sizeof(uintptr(0))) // skip size\n loop:\n \tfor {\n@@ -1707,8 +1730,20 @@ func SliceOf(t Type) Type {\n \tslice.ptrToThis = nil\n \tslice.zero = unsafe.Pointer(&make([]byte, slice.size)[0])\n \n+\tif typ.size == 0 {\n+\t\tslice.gc = unsafe.Pointer(&sliceEmptyGCProg)\n+\t} else {\n+\t\tslice.gc = unsafe.Pointer(&sliceGC{\n+\t\t\twidth:  slice.size,\n+\t\t\top:     _GC_SLICE,\n+\t\t\toff:    0,\n+\t\t\telemgc: typ.gc,\n+\t\t\tend:    _GC_END,\n+\t\t})\n+\t}\n+\n \t// INCORRECT. Uncomment to check that TestSliceOfOfGC fails when slice.gc is wrong.\n-\t//slice.gc = unsafe.Pointer(&badGC{width: slice.size, end: _GC_END})\n+\t// slice.gc = unsafe.Pointer(&badGC{width: slice.size, end: _GC_END})\n \n \treturn cachePut(ckey, &slice.rtype)\n }"}, {"sha": "a5ed8af7a85071f6ab38edc90cc004766d587635", "filename": "libgo/go/runtime/type.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/libgo%2Fgo%2Fruntime%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/libgo%2Fgo%2Fruntime%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftype.go?ref=f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49", "patch": "@@ -15,7 +15,7 @@ package runtime\n import \"unsafe\"\n \n type rtype struct {\n-\tKind       uint8\n+\tkind       uint8\n \talign      uint8\n \tfieldAlign uint8\n \tsize       uintptr\n@@ -24,6 +24,7 @@ type rtype struct {\n \thashfn  func(unsafe.Pointer, uintptr) uintptr\n \tequalfn func(unsafe.Pointer, unsafe.Pointer, uintptr) bool\n \n+\tgc     unsafe.Pointer\n \tstring *string\n \t*uncommonType\n \tptrToThis *rtype"}, {"sha": "74e8340059844f0df699b7d6aeef35e7493a679d", "filename": "libgo/runtime/go-type.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/libgo%2Fruntime%2Fgo-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/libgo%2Fruntime%2Fgo-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type.h?ref=f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49", "patch": "@@ -59,7 +59,7 @@ struct String;\n #define GO_CODE_MASK 0x7f\n \n /* For each Go type the compiler constructs one of these structures.\n-   This is used for type reflectin, interfaces, maps, and reference\n+   This is used for type reflection, interfaces, maps, and reference\n    counting.  */\n \n struct __go_type_descriptor\n@@ -93,6 +93,9 @@ struct __go_type_descriptor\n      size of this type, and returns whether the values are equal.  */\n   _Bool (*__equalfn) (const void *, const void *, uintptr_t);\n \n+  /* The garbage collection data. */\n+  const uintptr *__gc;\n+\n   /* A string describing this type.  This is only used for\n      debugging.  */\n   const struct String *__reflection;"}, {"sha": "67b2999df5db89df3750119ceb01ba251f4d58f3", "filename": "libgo/runtime/go-unsafe-pointer.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/libgo%2Fruntime%2Fgo-unsafe-pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/libgo%2Fruntime%2Fgo-unsafe-pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-unsafe-pointer.c?ref=f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49", "patch": "@@ -8,6 +8,7 @@\n \n #include \"runtime.h\"\n #include \"go-type.h\"\n+#include \"mgc0.h\"\n \n /* A pointer with a zero value.  */\n static void *zero_pointer;\n@@ -20,6 +21,9 @@ static void *zero_pointer;\n extern const struct __go_type_descriptor unsafe_Pointer\n   __asm__ (GOSYM_PREFIX \"__go_tdn_unsafe.Pointer\");\n \n+extern const uintptr unsafe_Pointer_gc[]\n+  __asm__ (GOSYM_PREFIX \"__go_tdn_unsafe.Pointer$gc\");\n+\n /* Used to determine the field alignment.  */\n struct field_align\n {\n@@ -35,6 +39,8 @@ static const String reflection_string =\n   sizeof REFLECTION - 1\n };\n \n+const uintptr unsafe_Pointer_gc[] = {8, GC_APTR, 0, GC_END};\n+\n const struct __go_type_descriptor unsafe_Pointer =\n {\n   /* __code */\n@@ -51,6 +57,8 @@ const struct __go_type_descriptor unsafe_Pointer =\n   __go_type_hash_identity,\n   /* __equalfn */\n   __go_type_equal_identity,\n+  /* __gc */\n+  unsafe_Pointer_gc,\n   /* __reflection */\n   &reflection_string,\n   /* __uncommon */\n@@ -94,6 +102,8 @@ const struct __go_ptr_type pointer_unsafe_Pointer =\n     __go_type_hash_identity,\n     /* __equalfn */\n     __go_type_equal_identity,\n+    /* __gc */\n+    unsafe_Pointer_gc,\n     /* __reflection */\n     &preflection_string,\n     /* __uncommon */"}, {"sha": "6864a833dc46ef2b630747a99edcc1cbd43539f8", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 27, "deletions": 52, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49", "patch": "@@ -181,7 +181,7 @@ struct Finalizer\n \tFuncVal *fn;\n \tvoid *arg;\n \tconst struct __go_func_type *ft;\n-\tconst struct __go_ptr_type *ot;\n+\tconst PtrType *ot;\n };\n \n typedef struct FinBlock FinBlock;\n@@ -403,8 +403,6 @@ struct BufferList\n };\n static BufferList bufferList[MaxGcproc];\n \n-static Type *itabtype;\n-\n static void enqueue(Obj obj, Workbuf **_wbuf, Obj **_wp, uintptr *_nobj);\n \n // flushptrbuf moves data from the PtrTarget buffer to the work buffer.\n@@ -649,23 +647,22 @@ flushobjbuf(Scanbuf *sbuf)\n // Program that scans the whole block and treats every block element as a potential pointer\n static uintptr defaultProg[2] = {PtrSize, GC_DEFAULT_PTR};\n \n-#if 0\n // Hchan program\n static uintptr chanProg[2] = {0, GC_CHAN};\n-#endif\n \n // Local variables of a program fragment or loop\n typedef struct Frame Frame;\n struct Frame {\n \tuintptr count, elemsize, b;\n-\tuintptr *loop_or_ret;\n+\tconst uintptr *loop_or_ret;\n };\n \n // Sanity check for the derived type info objti.\n static void\n checkptr(void *obj, uintptr objti)\n {\n-\tuintptr type, tisize, i, x;\n+\tuintptr *pc1, type, tisize, i, j, x;\n+\tconst uintptr *pc2;\n \tbyte *objstart;\n \tType *t;\n \tMSpan *s;\n@@ -703,9 +700,8 @@ checkptr(void *obj, uintptr objti)\n \t\t(runtime_strcmp((const char *)t->string->str, (const char*)\"unsafe.Pointer\") &&\n \t\t// Runtime and gc think differently about closures.\n \t\t runtime_strstr((const char *)t->string->str, (const char*)\"struct { F uintptr\") != (const char *)t->string->str)) {\n-#if 0\n \t\tpc1 = (uintptr*)objti;\n-\t\tpc2 = (uintptr*)t->gc;\n+\t\tpc2 = (const uintptr*)t->__gc;\n \t\t// A simple best-effort check until first GC_END.\n \t\tfor(j = 1; pc1[j] != GC_END && pc2[j] != GC_END; j++) {\n \t\t\tif(pc1[j] != pc2[j]) {\n@@ -714,7 +710,6 @@ checkptr(void *obj, uintptr objti)\n \t\t\t\truntime_throw(\"invalid gc type info\");\n \t\t\t}\n \t\t}\n-#endif\n \t}\n }\t\t\t\t\t\n \n@@ -728,11 +723,10 @@ static void\n scanblock(Workbuf *wbuf, bool keepworking)\n {\n \tbyte *b, *arena_start, *arena_used;\n-\tuintptr n, i, end_b, elemsize, size, ti, objti, count, /* type, */ nobj;\n-\tuintptr *pc, precise_type, nominal_size;\n-#if 0\n-\tuintptr *chan_ret, chancap;\n-#endif\n+\tuintptr n, i, end_b, elemsize, size, ti, objti, count, type, nobj;\n+\tuintptr precise_type, nominal_size;\n+\tconst uintptr *pc, *chan_ret;\n+\tuintptr chancap;\n \tvoid *obj;\n \tconst Type *t, *et;\n \tSlice *sliceptr;\n@@ -742,10 +736,8 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \tScanbuf sbuf;\n \tEface *eface;\n \tIface *iface;\n-#if 0\n \tHchan *chan;\n-\tChanType *chantype;\n-#endif\n+\tconst ChanType *chantype;\n \tObj *wp;\n \n \tif(sizeof(Workbuf) % WorkbufSize != 0)\n@@ -782,11 +774,9 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \tsbuf.nobj = nobj;\n \n \t// (Silence the compiler)\n-#if 0\n \tchan = nil;\n \tchantype = nil;\n \tchan_ret = nil;\n-#endif\n \n \tgoto next_block;\n \n@@ -800,7 +790,7 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\t\truntime_xadd64(&gcstats.obj.cnt, 1);\n \t\t}\n \n-\t\tif(ti != 0 && false) {\n+\t\tif(ti != 0) {\n \t\t\tif(Debug > 1) {\n \t\t\t\truntime_printf(\"scanblock %p %D ti %p\\n\", b, (int64)n, ti);\n \t\t\t}\n@@ -826,11 +816,10 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\t\t\t\truntime_throw(\"invalid gc type info\");\n \t\t\t\t}\n \t\t\t}\n-\t\t} else if(UseSpanType && false) {\n+\t\t} else if(UseSpanType) {\n \t\t\tif(CollectStats)\n \t\t\t\truntime_xadd64(&gcstats.obj.notype, 1);\n \n-#if 0\n \t\t\ttype = runtime_gettype(b);\n \t\t\tif(type != 0) {\n \t\t\t\tif(CollectStats)\n@@ -839,13 +828,13 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\t\t\tt = (Type*)(type & ~(uintptr)(PtrSize-1));\n \t\t\t\tswitch(type & (PtrSize-1)) {\n \t\t\t\tcase TypeInfo_SingleObject:\n-\t\t\t\t\tpc = (uintptr*)t->gc;\n+\t\t\t\t\tpc = (const uintptr*)t->__gc;\n \t\t\t\t\tprecise_type = true;  // type information about 'b' is precise\n \t\t\t\t\tstack_top.count = 1;\n \t\t\t\t\tstack_top.elemsize = pc[0];\n \t\t\t\t\tbreak;\n \t\t\t\tcase TypeInfo_Array:\n-\t\t\t\t\tpc = (uintptr*)t->gc;\n+\t\t\t\t\tpc = (const uintptr*)t->__gc;\n \t\t\t\t\tif(pc[0] == 0)\n \t\t\t\t\t\tgoto next_block;\n \t\t\t\t\tprecise_type = true;  // type information about 'b' is precise\n@@ -855,7 +844,7 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\t\t\t\tbreak;\n \t\t\t\tcase TypeInfo_Chan:\n \t\t\t\t\tchan = (Hchan*)b;\n-\t\t\t\t\tchantype = (ChanType*)t;\n+\t\t\t\t\tchantype = (const ChanType*)t;\n \t\t\t\t\tchan_ret = nil;\n \t\t\t\t\tpc = chanProg;\n \t\t\t\t\tbreak;\n@@ -872,7 +861,6 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\t\t\tif(Debug > 1)\n \t\t\t\t\truntime_printf(\"scanblock %p %D unknown type\\n\", b, (int64)n);\n \t\t\t}\n-#endif\n \t\t} else {\n \t\t\tpc = defaultProg;\n \t\t\tif(Debug > 1)\n@@ -954,7 +942,7 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \n \t\t\t// eface->__object\n \t\t\tif((byte*)eface->__object >= arena_start && (byte*)eface->__object < arena_used) {\n-\t\t\t\tif(t->__size <= sizeof(void*)) {\n+\t\t\t\tif(__go_is_pointer_type(t)) {\n \t\t\t\t\tif((t->__code & KindNoPointers))\n \t\t\t\t\t\tcontinue;\n \n@@ -965,13 +953,11 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\t\t\t\t\t// dgcsym1 in case TPTR32/case TPTR64. See rationale there.\n \t\t\t\t\t\tet = ((const PtrType*)t)->elem;\n \t\t\t\t\t\tif(!(et->__code & KindNoPointers))\n-\t\t\t\t\t\t\t// objti = (uintptr)((const PtrType*)t)->elem->gc;\n-\t\t\t\t\t\t\tobjti = 0;\n+\t\t\t\t\t\t\tobjti = (uintptr)((const PtrType*)t)->elem->__gc;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tobj = eface->__object;\n-\t\t\t\t\t// objti = (uintptr)t->gc;\n-\t\t\t\t\tobjti = 0;\n+\t\t\t\t\tobjti = (uintptr)t->__gc;\n \t\t\t\t}\n \t\t\t}\n \t\t\tbreak;\n@@ -986,16 +972,15 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\t\t\n \t\t\t// iface->tab\n \t\t\tif((byte*)iface->tab >= arena_start && (byte*)iface->tab < arena_used) {\n-\t\t\t\t*sbuf.ptr.pos++ = (PtrTarget){iface->tab, /* (uintptr)itabtype->gc */ 0};\n+\t\t\t\t*sbuf.ptr.pos++ = (PtrTarget){iface->tab, 0};\n \t\t\t\tif(sbuf.ptr.pos == sbuf.ptr.end)\n \t\t\t\t\tflushptrbuf(&sbuf);\n \t\t\t}\n \n \t\t\t// iface->data\n \t\t\tif((byte*)iface->__object >= arena_start && (byte*)iface->__object < arena_used) {\n-\t\t\t\t// t = iface->tab->type;\n-\t\t\t\tt = nil;\n-\t\t\t\tif(t->__size <= sizeof(void*)) {\n+\t\t\t\tt = (const Type*)iface->tab[0];\n+\t\t\t\tif(__go_is_pointer_type(t)) {\n \t\t\t\t\tif((t->__code & KindNoPointers))\n \t\t\t\t\t\tcontinue;\n \n@@ -1006,13 +991,11 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\t\t\t\t\t// dgcsym1 in case TPTR32/case TPTR64. See rationale there.\n \t\t\t\t\t\tet = ((const PtrType*)t)->elem;\n \t\t\t\t\t\tif(!(et->__code & KindNoPointers))\n-\t\t\t\t\t\t\t// objti = (uintptr)((const PtrType*)t)->elem->gc;\n-\t\t\t\t\t\t\tobjti = 0;\n+\t\t\t\t\t\t\tobjti = (uintptr)((const PtrType*)t)->elem->__gc;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tobj = iface->__object;\n-\t\t\t\t\t// objti = (uintptr)t->gc;\n-\t\t\t\t\tobjti = 0;\n+\t\t\t\t\tobjti = (uintptr)t->__gc;\n \t\t\t\t}\n \t\t\t}\n \t\t\tbreak;\n@@ -1092,7 +1075,7 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\t\t// Stack push.\n \t\t\t*stack_ptr-- = stack_top;\n \t\t\tstack_top = (Frame){1, 0, stack_top.b + pc[1], pc+3 /*return address*/};\n-\t\t\tpc = (uintptr*)((byte*)pc + *(int32*)(pc+2));  // target of the CALL instruction\n+\t\t\tpc = (const uintptr*)((const byte*)pc + *(const int32*)(pc+2));  // target of the CALL instruction\n \t\t\tcontinue;\n \n \t\tcase GC_REGION:\n@@ -1108,7 +1091,6 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\t\t\tflushobjbuf(&sbuf);\n \t\t\tcontinue;\n \n-#if 0\n \t\tcase GC_CHAN_PTR:\n \t\t\tchan = *(Hchan**)(stack_top.b + pc[1]);\n \t\t\tif(Debug > 2 && chan != nil)\n@@ -1141,8 +1123,8 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\t\t\t\t// in-use part of the circular buffer is scanned.\n \t\t\t\t\t// (Channel routines zero the unused part, so the current\n \t\t\t\t\t// code does not lead to leaks, it's just a little inefficient.)\n-\t\t\t\t\t*sbuf.obj.pos++ = (Obj){(byte*)chan+runtime_Hchansize, chancap*chantype->elem->size,\n-\t\t\t\t\t\t(uintptr)chantype->elem->gc | PRECISE | LOOP};\n+\t\t\t\t\t*sbuf.obj.pos++ = (Obj){(byte*)chan+runtime_Hchansize, chancap*chantype->elem->__size,\n+\t\t\t\t\t\t(uintptr)chantype->elem->__gc | PRECISE | LOOP};\n \t\t\t\t\tif(sbuf.obj.pos == sbuf.obj.end)\n \t\t\t\t\t\tflushobjbuf(&sbuf);\n \t\t\t\t}\n@@ -1151,7 +1133,6 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\t\t\tgoto next_block;\n \t\t\tpc = chan_ret;\n \t\t\tcontinue;\n-#endif\n \n \t\tdefault:\n \t\t\truntime_printf(\"runtime: invalid GC instruction %p at %p\\n\", pc[0], pc);\n@@ -1828,7 +1809,7 @@ runtime_MSpan_Sweep(MSpan *s)\n }\n \n // State of background sweep.\n-// Pretected by gclock.\n+// Protected by gclock.\n static struct\n {\n \tG*\tg;\n@@ -2260,12 +2241,6 @@ gc(struct gc_args *args)\n \t\twork.markfor = runtime_parforalloc(MaxGcproc);\n \tm->locks--;\n \n-\tif(itabtype == nil) {\n-\t\t// get C pointer to the Go type \"itab\"\n-\t\t// runtime_gc_itab_ptr(&eface);\n-\t\t// itabtype = ((PtrType*)eface.__type_descriptor)->elem;\n-\t}\n-\n \tt1 = 0;\n \tif(runtime_debug.gctrace)\n \t\tt1 = runtime_nanotime();"}, {"sha": "c96290a0b066b7fc43693a64661537e58fa986eb", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=f1d2ac4f84b4b5354779b3b0a0e125b8302ebb49", "patch": "@@ -800,7 +800,7 @@ uintptr\truntime_memlimit(void);\n \n enum\n {\n-\tUseSpanType = 0,\n+\tUseSpanType = 1,\n };\n \n #define runtime_setitimer setitimer"}]}