{"sha": "26e46e4b94267360451114c8fc1ec5ee6ef5e6a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZlNDZlNGI5NDI2NzM2MDQ1MTExNGM4ZmMxZWM1ZWU2ZWY1ZTZhNg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-06-11T15:49:32Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-06-11T15:49:32Z"}, "message": "re PR fortran/66079 (memory leak with source allocation in internal subprogram)\n\n2015-06-11  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/66079\n\t* trans-expr.c (gfc_conv_procedure_call): Allocatable scalar\n\tfunction results must be freed and nullified after use. Create\n\ta temporary to hold the result to prevent duplicate calls.\n\t* trans-stmt.c (gfc_trans_allocate): Rename temporary variable\n\tas 'source'. Deallocate allocatable components of non-variable\n\t'source's.\n\n2015-06-11  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/66079\n\t* gfortran.dg/allocatable_scalar_13.f90: New test\n\nFrom-SVN: r224383", "tree": {"sha": "772bb92e54ad124ab4c61669c427440420730654", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/772bb92e54ad124ab4c61669c427440420730654"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26e46e4b94267360451114c8fc1ec5ee6ef5e6a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26e46e4b94267360451114c8fc1ec5ee6ef5e6a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26e46e4b94267360451114c8fc1ec5ee6ef5e6a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26e46e4b94267360451114c8fc1ec5ee6ef5e6a6/comments", "author": null, "committer": null, "parents": [{"sha": "133bc698cb8f42e3655fc68fee19c62fd18d98f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/133bc698cb8f42e3655fc68fee19c62fd18d98f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/133bc698cb8f42e3655fc68fee19c62fd18d98f7"}], "stats": {"total": 118, "additions": 115, "deletions": 3}, "files": [{"sha": "662e3d2f98a5f1bb8bdf0635c4ce6ba91a262c89", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26e46e4b94267360451114c8fc1ec5ee6ef5e6a6/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26e46e4b94267360451114c8fc1ec5ee6ef5e6a6/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=26e46e4b94267360451114c8fc1ec5ee6ef5e6a6", "patch": "@@ -1,3 +1,13 @@\n+2015-06-11  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/66079\n+\t* trans-expr.c (gfc_conv_procedure_call): Allocatable scalar\n+\tfunction results must be freed and nullified after use. Create\n+\ta temporary to hold the result to prevent duplicate calls.\n+\t* trans-stmt.c (gfc_trans_allocate): Rename temporary variable\n+\tas 'source'. Deallocate allocatable components of non-variable\n+\t'source's.\n+\n 2015-06-11  Pierre-Marie de Rodat  <derodat@adacore.com>\n \n \t* f95-lang.c (gfc_create_decls): Register the main translation unit\n@@ -258,7 +268,7 @@\n \n \tPR fortran/66044\n \t* decl.c(gfc_match_entry):  Change a gfc_internal_error() into\n-\ta gfc_error() \n+\ta gfc_error()\n \n 2015-05-18  Steven G. Kargl  <kargl@gcc.gnu.org>\n "}, {"sha": "e3f49f597036cd73fed974a40a4495006fdaddc3", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26e46e4b94267360451114c8fc1ec5ee6ef5e6a6/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26e46e4b94267360451114c8fc1ec5ee6ef5e6a6/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=26e46e4b94267360451114c8fc1ec5ee6ef5e6a6", "patch": "@@ -5871,6 +5871,20 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   fntype = TREE_TYPE (TREE_TYPE (se->expr));\n   se->expr = build_call_vec (TREE_TYPE (fntype), se->expr, arglist);\n \n+  /* Allocatable scalar function results must be freed and nullified\n+     after use. This necessitates the creation of a temporary to\n+     hold the result to prevent duplicate calls.  */\n+  if (!byref && sym->ts.type != BT_CHARACTER\n+      && sym->attr.allocatable && !sym->attr.dimension)\n+    {\n+      tmp = gfc_create_var (TREE_TYPE (se->expr), NULL);\n+      gfc_add_modify (&se->pre, tmp, se->expr);\n+      se->expr = tmp;\n+      tmp = gfc_call_free (tmp);\n+      gfc_add_expr_to_block (&post, tmp);\n+      gfc_add_modify (&post, se->expr, build_int_cst (TREE_TYPE (se->expr), 0));\n+    }\n+\n   /* If we have a pointer function, but we don't want a pointer, e.g.\n      something like\n         x = f()"}, {"sha": "69750dfa01030814a0f14e7893f5b892f8974a1a", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26e46e4b94267360451114c8fc1ec5ee6ef5e6a6/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26e46e4b94267360451114c8fc1ec5ee6ef5e6a6/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=26e46e4b94267360451114c8fc1ec5ee6ef5e6a6", "patch": "@@ -5207,6 +5207,7 @@ gfc_trans_allocate (gfc_code * code)\n \t\t\t\t     false, false);\n \t  gfc_add_block_to_block (&block, &se.pre);\n \t  gfc_add_block_to_block (&post, &se.post);\n+\n \t  /* Prevent aliasing, i.e., se.expr may be already a\n \t\t variable declaration.  */\n \t  if (!VAR_P (se.expr))\n@@ -5216,8 +5217,20 @@ gfc_trans_allocate (gfc_code * code)\n \t\t\t\t\t\t se.expr);\n \t      /* We need a regular (non-UID) symbol here, therefore give a\n \t\t prefix.  */\n-\t      var = gfc_create_var (TREE_TYPE (tmp), \"atmp\");\n+\t      var = gfc_create_var (TREE_TYPE (tmp), \"source\");\n \t      gfc_add_modify_loc (input_location, &block, var, tmp);\n+\n+\t      /* Deallocate any allocatable components after all the allocations\n+\t\t and assignments of expr3 have been completed.  */\n+\t      if (code->expr3->ts.type == BT_DERIVED\n+\t\t  && code->expr3->rank == 0\n+\t\t  && code->expr3->ts.u.derived->attr.alloc_comp)\n+\t\t{\n+\t\t  tmp = gfc_deallocate_alloc_comp (code->expr3->ts.u.derived,\n+\t\t\t\t\t\t   var, 0);\n+\t\t  gfc_add_expr_to_block (&post, tmp);\n+\t\t}\n+\n \t      tmp = var;\n \t    }\n \t  else"}, {"sha": "d46ba74e5001920ba8a5e4e5a8bd7c70fce90cd7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26e46e4b94267360451114c8fc1ec5ee6ef5e6a6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26e46e4b94267360451114c8fc1ec5ee6ef5e6a6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=26e46e4b94267360451114c8fc1ec5ee6ef5e6a6", "patch": "@@ -1,3 +1,8 @@\n+2015-06-11  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/66079\n+\t* gfortran.dg/allocatable_scalar_13.f90: New test\n+\n 2015-06-11  Marek Polacek  <polacek@redhat.com>\n \n \t* gcc.dg/fold-xor-3.c: New test.\n@@ -666,7 +671,7 @@\n 2015-05-27  Honggyu Kim  <hong.gyu.kim@lge.com>\n \n \tPR target/65358\n-\t* gcc.dg/pr65358.c: New test. \n+\t* gcc.dg/pr65358.c: New test.\n \n 2015-05-27  Andre Vehreschild  <vehre@gmx.de>\n "}, {"sha": "bc6f01739f59993ff22e764232ec319c53bf135a", "filename": "gcc/testsuite/gfortran.dg/allocatable_scalar_13.f90", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26e46e4b94267360451114c8fc1ec5ee6ef5e6a6/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_scalar_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26e46e4b94267360451114c8fc1ec5ee6ef5e6a6/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_scalar_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_scalar_13.f90?ref=26e46e4b94267360451114c8fc1ec5ee6ef5e6a6", "patch": "@@ -0,0 +1,70 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! Test the fix for PR66079. The original problem was with the first\n+! allocate statement. The rest of this testcase fixes problems found\n+! whilst working on it!\n+!\n+! Reported by Damian Rouson  <damian@sourceryinstitute.org>\n+!\n+  type subdata\n+    integer, allocatable :: b\n+  endtype\n+!  block\n+    call newRealVec\n+!  end block\n+contains\n+  subroutine newRealVec\n+    type(subdata), allocatable :: d, e, f\n+    character(:), allocatable :: g, h, i\n+    character(8), allocatable :: j\n+    allocate(d,source=subdata(1)) ! memory was lost, now OK\n+    allocate(e,source=d) ! OK\n+    allocate(f,source=create (99)) ! memory was lost, now OK\n+    if (d%b .ne. 1) call abort\n+    if (e%b .ne. 1) call abort\n+    if (f%b .ne. 99) call abort\n+    allocate (g, source = greeting1(\"good day\"))\n+    if (g .ne. \"good day\") call abort\n+    allocate (h, source = greeting2(\"hello\"))\n+    if (h .ne. \"hello\") call abort\n+    allocate (i, source = greeting3(\"hiya!\"))\n+    if (i .ne. \"hiya!\") call abort\n+    call greeting4 (j, \"Goodbye \") ! Test that dummy arguments are OK\n+    if (j .ne. \"Goodbye \") call abort\n+  end subroutine\n+\n+  function create (arg) result(res)\n+    integer :: arg\n+    type(subdata), allocatable :: res, res1\n+    allocate(res, res1, source = subdata(arg))\n+  end function\n+\n+  function greeting1 (arg) result(res) ! memory was lost, now OK\n+    character(*) :: arg\n+    Character(:), allocatable :: res\n+    allocate(res, source = arg)\n+  end function\n+\n+  function greeting2 (arg) result(res)\n+    character(5) :: arg\n+    Character(:), allocatable :: res\n+    allocate(res, source = arg)\n+  end function\n+\n+  function greeting3 (arg) result(res)\n+    character(5) :: arg\n+    Character(5), allocatable :: res, res1\n+    allocate(res, res1, source = arg) ! Caused an ICE\n+    if (res1 .ne. res) call abort\n+  end function\n+\n+  subroutine greeting4 (res, arg)\n+    character(8), intent(in) :: arg\n+    Character(8), allocatable, intent(out) :: res\n+    allocate(res, source = arg) ! Caused an ICE\n+  end subroutine\n+end\n+! { dg-final { scan-tree-dump-times \"builtin_malloc\" 20 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"builtin_free\" 21 \"original\" } }\n+"}]}