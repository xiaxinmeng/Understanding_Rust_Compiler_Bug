{"sha": "a1c65f9f4f4673cab2f40a4b02bbb7445edc1b81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFjNjVmOWY0ZjQ2NzNjYWIyZjQwYTRiMDJiYmI3NDQ1ZWRjMWI4MQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-09-13T11:33:47Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-09-13T11:33:47Z"}, "message": "decl.c: Fix comment formatting.\n\n\t* decl.c: Fix comment formatting.\n\t* decl2.c: Likewise.\n\nFrom-SVN: r57104", "tree": {"sha": "1a05c18930f1bc39db222cf8f86f7ea398939ce2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a05c18930f1bc39db222cf8f86f7ea398939ce2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1c65f9f4f4673cab2f40a4b02bbb7445edc1b81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1c65f9f4f4673cab2f40a4b02bbb7445edc1b81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1c65f9f4f4673cab2f40a4b02bbb7445edc1b81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1c65f9f4f4673cab2f40a4b02bbb7445edc1b81/comments", "author": null, "committer": null, "parents": [{"sha": "4456530dac41a092820e996fe25250edbad2b1ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4456530dac41a092820e996fe25250edbad2b1ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4456530dac41a092820e996fe25250edbad2b1ad"}], "stats": {"total": 277, "additions": 141, "deletions": 136}, "files": [{"sha": "5048f985470e44c7379e3df6ec723d61eab04822", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c65f9f4f4673cab2f40a4b02bbb7445edc1b81/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c65f9f4f4673cab2f40a4b02bbb7445edc1b81/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a1c65f9f4f4673cab2f40a4b02bbb7445edc1b81", "patch": "@@ -1,3 +1,8 @@\n+2002-09-13  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* decl.c: Fix comment formatting.\n+\t* decl2.c: Likewise.\n+\n 2002-09-12  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* call.c: Fix comment formatting."}, {"sha": "a18a5856d4830cb9404194b351c58ace01acc4a1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 73, "deletions": 73, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c65f9f4f4673cab2f40a4b02bbb7445edc1b81/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c65f9f4f4673cab2f40a4b02bbb7445edc1b81/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a1c65f9f4f4673cab2f40a4b02bbb7445edc1b81", "patch": "@@ -203,7 +203,7 @@ tree cp_global_trees[CPTI_MAX];\n \n static GTY(()) tree global_type_node;\n \n-/* Expect only namespace names now. */\n+/* Expect only namespace names now.  */\n static int only_namespace_names;\n \n /* Used only for jumps to as-yet undefined labels, since jumps to\n@@ -329,11 +329,11 @@ struct cp_binding_level GTY(())\n        component_bindings.  */\n     tree tags;\n \n-    /* A list of USING_DECL nodes. */\n+    /* A list of USING_DECL nodes.  */\n     tree usings;\n \n     /* A list of used namespaces. PURPOSE is the namespace,\n-       VALUE the common ancestor with this binding_level's namespace. */\n+       VALUE the common ancestor with this binding_level's namespace.  */\n     tree using_directives;\n \n     /* If this binding level is the binding level for a class, then\n@@ -576,7 +576,7 @@ resume_binding_level (b)\n      struct cp_binding_level *b;\n {\n   /* Resuming binding levels is meant only for namespaces,\n-     and those cannot nest into classes. */\n+     and those cannot nest into classes.  */\n   my_friendly_assert(!class_binding_level, 386);\n   /* Also, resuming a non-directly nested namespace is a no-no.  */\n   my_friendly_assert(b->level_chain == current_binding_level, 386);\n@@ -2053,11 +2053,11 @@ print_binding_stack ()\n /* Namespace binding access routines: The namespace_bindings field of\n    the identifier is polymorphic, with three possible values:\n    NULL_TREE, a list of CPLUS_BINDINGS, or any other tree_node\n-   indicating the BINDING_VALUE of global_namespace. */\n+   indicating the BINDING_VALUE of global_namespace.  */\n \n /* Check whether the a binding for the name to scope is known.\n    Assumes that the bindings of the name are already a list\n-   of bindings. Returns the binding found, or NULL_TREE. */\n+   of bindings. Returns the binding found, or NULL_TREE.  */\n \n static tree\n find_binding (name, scope)\n@@ -2075,7 +2075,7 @@ find_binding (name, scope)\n       if (BINDING_SCOPE (iter) == scope)\n \t{\n \t  /* Move binding found to the front of the list, so\n-             subsequent lookups will find it faster. */\n+             subsequent lookups will find it faster.  */\n \t  if (prev)\n \t    {\n \t      TREE_CHAIN (prev) = TREE_CHAIN (iter);\n@@ -2091,7 +2091,7 @@ find_binding (name, scope)\n \n /* Always returns a binding for name in scope. If the\n    namespace_bindings is not a list, convert it to one first.\n-   If no binding is found, make a new one. */\n+   If no binding is found, make a new one.  */\n \n tree\n binding_for_name (name, scope)\n@@ -2105,14 +2105,14 @@ binding_for_name (name, scope)\n \n   if (b && TREE_CODE (b) != CPLUS_BINDING)\n     {\n-      /* Get rid of optimization for global scope. */\n+      /* Get rid of optimization for global scope.  */\n       IDENTIFIER_NAMESPACE_BINDINGS (name) = NULL_TREE;\n       BINDING_VALUE (binding_for_name (name, global_namespace)) = b;\n       b = IDENTIFIER_NAMESPACE_BINDINGS (name);\n     }\n   if (b && (result = find_binding (name, scope)))\n     return result;\n-  /* Not found, make a new one. */\n+  /* Not found, make a new one.  */\n   result = make_node (CPLUS_BINDING);\n   TREE_CHAIN (result) = b;\n   IDENTIFIER_NAMESPACE_BINDINGS (name) = result;\n@@ -2123,7 +2123,7 @@ binding_for_name (name, scope)\n }\n \n /* Return the binding value for name in scope, considering that\n-   namespace_binding may or may not be a list of CPLUS_BINDINGS. */\n+   namespace_binding may or may not be a list of CPLUS_BINDINGS.  */\n \n tree\n namespace_binding (name, scope)\n@@ -2144,7 +2144,7 @@ namespace_binding (name, scope)\n }\n \n /* Set the binding value for name in scope. If modifying the binding\n-   of global_namespace is attempted, try to optimize it. */\n+   of global_namespace is attempted, try to optimize it.  */\n \n void\n set_namespace_binding (name, scope, val)\n@@ -2183,7 +2183,7 @@ push_namespace (name)\n   int global = 0;\n   if (!global_namespace)\n     {\n-      /* This must be ::. */\n+      /* This must be ::.  */\n       my_friendly_assert (name == get_identifier (\"::\"), 377);\n       global = 1;\n     }\n@@ -2202,7 +2202,7 @@ push_namespace (name)\n     }\n   else\n     {\n-      /* Check whether this is an extended namespace definition. */\n+      /* Check whether this is an extended namespace definition.  */\n       d = IDENTIFIER_NAMESPACE_VALUE (name);\n       if (d != NULL_TREE && TREE_CODE (d) == NAMESPACE_DECL)\n         {\n@@ -2218,7 +2218,7 @@ push_namespace (name)\n \n   if (need_new)\n     {\n-      /* Make a new namespace, binding the name to it. */\n+      /* Make a new namespace, binding the name to it.  */\n       d = build_lang_decl (NAMESPACE_DECL, name, void_type_node);\n       /* The global namespace is not pushed, and the global binding\n \t level is set elsewhere.  */\n@@ -2236,7 +2236,7 @@ push_namespace (name)\n \n   if (implicit_use)\n     do_using_directive (d);\n-  /* Enter the name space. */\n+  /* Enter the name space.  */\n   current_namespace = d;\n }\n \n@@ -2455,7 +2455,7 @@ set_identifier_type_value_with_scope (id, type, b)\n   if (!b->namespace_p)\n     {\n       /* Shadow the marker, not the real thing, so that the marker\n-\t gets restored later. */\n+\t gets restored later.  */\n       tree old_type_value = REAL_IDENTIFIER_TYPE_VALUE (id);\n       b->type_shadowed\n \t= tree_cons (id, old_type_value, b->type_shadowed);\n@@ -2464,7 +2464,7 @@ set_identifier_type_value_with_scope (id, type, b)\n     {\n       tree binding = binding_for_name (id, current_namespace);\n       BINDING_TYPE (binding) = type;\n-      /* Store marker instead of real type. */\n+      /* Store marker instead of real type.  */\n       type = global_type_node;\n     }\n   SET_IDENTIFIER_TYPE_VALUE (id, type);\n@@ -2480,20 +2480,20 @@ set_identifier_type_value (id, type)\n   set_identifier_type_value_with_scope (id, type, current_binding_level);\n }\n \n-/* Return the type associated with id. */\n+/* Return the type associated with id.  */\n \n tree\n identifier_type_value (id)\n      tree id;\n {\n-  /* There is no type with that name, anywhere. */\n+  /* There is no type with that name, anywhere.  */\n   if (REAL_IDENTIFIER_TYPE_VALUE (id) == NULL_TREE)\n     return NULL_TREE;\n-  /* This is not the type marker, but the real thing. */\n+  /* This is not the type marker, but the real thing.  */\n   if (REAL_IDENTIFIER_TYPE_VALUE (id) != global_type_node)\n     return REAL_IDENTIFIER_TYPE_VALUE (id);\n   /* Have to search for it. It must be on the global level, now.\n-     Ask lookup_name not to return non-types. */\n+     Ask lookup_name not to return non-types.  */\n   id = lookup_name_real (id, 2, 1, 0);\n   if (id)\n     return TREE_TYPE (id);\n@@ -2666,7 +2666,7 @@ pushtag (name, type, globalize)\n \t\t /* We may be defining a new type in the initializer\n \t\t    of a static member variable. We allow this when\n \t\t    not pedantic, and it is particularly useful for\n-\t\t    type punning via an anonymous union. */\n+\t\t    type punning via an anonymous union.  */\n \t\t || COMPLETE_TYPE_P (b->this_class))))\n     b = b->level_chain;\n \n@@ -3025,7 +3025,7 @@ duplicate_decls (newdecl, olddecl)\n \t}\n     }\n \n-  /* Check for redeclaration and other discrepancies. */\n+  /* Check for redeclaration and other discrepancies.  */\n   if (TREE_CODE (olddecl) == FUNCTION_DECL\n       && DECL_ARTIFICIAL (olddecl))\n     {\n@@ -3227,7 +3227,7 @@ duplicate_decls (newdecl, olddecl)\n   else if (TREE_CODE (newdecl) == NAMESPACE_DECL\n            && DECL_NAMESPACE_ALIAS (newdecl)\n            && DECL_NAMESPACE_ALIAS (newdecl) == DECL_NAMESPACE_ALIAS (olddecl))\n-    /* Redeclaration of namespace alias, ignore it. */\n+    /* Redeclaration of namespace alias, ignore it.  */\n     return 1;\n   else\n     {\n@@ -3357,9 +3357,9 @@ duplicate_decls (newdecl, olddecl)\n          definition.  */\n       if (warn_redundant_decls && ! DECL_ARTIFICIAL (olddecl)\n \t  && !(new_defines_function && DECL_INITIAL (olddecl) == NULL_TREE)\n-\t  /* Don't warn about extern decl followed by definition. */\n+\t  /* Don't warn about extern decl followed by definition.  */\n \t  && !(DECL_EXTERNAL (olddecl) && ! DECL_EXTERNAL (newdecl))\n-\t  /* Don't warn about friends, let add_friend take care of it. */\n+\t  /* Don't warn about friends, let add_friend take care of it.  */\n \t  && ! (DECL_FRIEND_P (newdecl) || DECL_FRIEND_P (olddecl)))\n \t{\n \t  warning (\"redundant redeclaration of `%D' in same scope\", newdecl);\n@@ -3860,7 +3860,7 @@ pushdecl (x)\n \t  else if ((DECL_EXTERN_C_FUNCTION_P (x)\n \t\t    || DECL_FUNCTION_TEMPLATE_P (x))\n \t\t   && is_overloaded_fn (t))\n-\t    /* Don't do anything just yet. */;\n+\t    /* Don't do anything just yet.  */;\n \t  else if (t == wchar_decl_node)\n \t    {\n \t      if (pedantic && ! DECL_IN_SYSTEM_HEADER (x))\n@@ -3931,7 +3931,7 @@ pushdecl (x)\n \n       /* If declaring a type as a typedef, copy the type (unless we're\n \t at line 0), and install this TYPE_DECL as the new type's typedef\n-\t name.  See the extensive comment in ../c-decl.c (pushdecl). */\n+\t name.  See the extensive comment in ../c-decl.c (pushdecl).  */\n       if (TREE_CODE (x) == TYPE_DECL)\n \t{\n \t  tree type = TREE_TYPE (x);\n@@ -4301,7 +4301,7 @@ maybe_push_decl (decl)\n       || (TREE_CODE (decl) != PARM_DECL\n \t  && DECL_CONTEXT (decl) != NULL_TREE\n \t  /* Definitions of namespace members outside their namespace are\n-\t     possible. */\n+\t     possible.  */\n \t  && TREE_CODE (DECL_CONTEXT (decl)) != NAMESPACE_DECL)\n       || (TREE_CODE (decl) == TEMPLATE_DECL && !namespace_bindings_p ())\n       || TREE_CODE (type) == UNKNOWN_TYPE\n@@ -4431,11 +4431,11 @@ push_using_directive (used)\n   tree ud = current_binding_level->using_directives;\n   tree iter, ancestor;\n \n-  /* Check if we already have this. */\n+  /* Check if we already have this.  */\n   if (purpose_member (used, ud) != NULL_TREE)\n     return NULL_TREE;\n \n-  /* Recursively add all namespaces used. */\n+  /* Recursively add all namespaces used.  */\n   for (iter = DECL_NAMESPACE_USING (used); iter; iter = TREE_CHAIN (iter))\n     push_using_directive (TREE_PURPOSE (iter));\n \n@@ -4643,7 +4643,7 @@ redeclaration_error_message (newdecl, olddecl)\n \treturn 0;\n \n       /* If both functions come from different namespaces, this is not\n-\t a redeclaration - this is a conflict with a used function. */\n+\t a redeclaration - this is a conflict with a used function.  */\n       if (DECL_NAMESPACE_SCOPE_P (olddecl)\n \t  && DECL_CONTEXT (olddecl) != DECL_CONTEXT (newdecl))\n \treturn \"`%D' conflicts with used function\";\n@@ -5273,7 +5273,7 @@ lookup_tag (form, name, binding_level, thislevel_only)\n \t      return TREE_VALUE (tail);\n \t  }\n       else if (level->namespace_p)\n-\t/* Do namespace lookup. */\n+\t/* Do namespace lookup.  */\n \tfor (tail = current_namespace; 1; tail = CP_DECL_CONTEXT (tail))\n \t  {\n \t    tree old = binding_for_name (name, tail);\n@@ -5402,7 +5402,7 @@ lookup_namespace_name (namespace, name)\n   my_friendly_assert (TREE_CODE (namespace) == NAMESPACE_DECL, 370);\n \n   if (TREE_CODE (name) == NAMESPACE_DECL)\n-    /* This happens for A::B<int> when B is a namespace. */\n+    /* This happens for A::B<int> when B is a namespace.  */\n     return name;\n   else if (TREE_CODE (name) == TEMPLATE_DECL)\n     {\n@@ -5750,7 +5750,7 @@ make_unbound_class_template (context, name, complain)\n   return t;\n }\n \n-/* Select the right _DECL from multiple choices. */\n+/* Select the right _DECL from multiple choices.  */\n \n static tree\n select_decl (binding, flags)\n@@ -5762,7 +5762,7 @@ select_decl (binding, flags)\n \n   if (LOOKUP_NAMESPACES_ONLY (flags))\n     {\n-      /* We are not interested in types. */\n+      /* We are not interested in types.  */\n       if (val && TREE_CODE (val) == NAMESPACE_DECL)\n         return val;\n       return NULL_TREE;\n@@ -5774,7 +5774,7 @@ select_decl (binding, flags)\n       && (!val || ((flags & LOOKUP_PREFER_TYPES)\n                    && TREE_CODE (val) != TYPE_DECL)))\n     val = TYPE_STUB_DECL (BINDING_TYPE (binding));\n-  /* Don't return non-types if we really prefer types. */\n+  /* Don't return non-types if we really prefer types.  */\n   else if (val && LOOKUP_TYPES_ONLY (flags)  && TREE_CODE (val) != TYPE_DECL\n \t   && (TREE_CODE (val) != TEMPLATE_DECL\n \t       || !DECL_CLASS_TEMPLATE_P (val)))\n@@ -5820,28 +5820,28 @@ unqualified_namespace_lookup (name, flags, spacesp)\n         }\n       else\n         {\n-          /* Initialize binding for this context. */\n+          /* Initialize binding for this context.  */\n           BINDING_VALUE (b) = BINDING_VALUE (val);\n           BINDING_TYPE (b) = BINDING_TYPE (val);\n         }\n \n-      /* Add all _DECLs seen through local using-directives. */\n+      /* Add all _DECLs seen through local using-directives.  */\n       for (level = current_binding_level;\n \t   !level->namespace_p;\n \t   level = level->level_chain)\n \tif (!lookup_using_namespace (name, b, level->using_directives,\n                                      scope, flags, spacesp))\n-\t  /* Give up because of error. */\n+\t  /* Give up because of error.  */\n \t  return error_mark_node;\n \n-      /* Add all _DECLs seen through global using-directives. */\n-      /* XXX local and global using lists should work equally. */\n+      /* Add all _DECLs seen through global using-directives.  */\n+      /* XXX local and global using lists should work equally.  */\n       siter = initial;\n       while (1)\n \t{\n \t  if (!lookup_using_namespace (name, b, DECL_NAMESPACE_USING (siter),\n \t\t\t\t       scope, flags, spacesp))\n-\t    /* Give up because of error. */\n+\t    /* Give up because of error.  */\n \t    return error_mark_node;\n \t  if (siter == scope) break;\n \t  siter = CP_DECL_CONTEXT (siter);\n@@ -6002,7 +6002,7 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n   int flags;\n   int val_is_implicit_typename = 0;\n \n-  /* Hack: copy flag set by parser, if set. */\n+  /* Hack: copy flag set by parser, if set.  */\n   if (only_namespace_names)\n     namespaces_only = 1;\n \n@@ -6015,7 +6015,7 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n       prefer_type = looking_for_typename;\n \n       flags = lookup_flags (prefer_type, namespaces_only);\n-      /* If the next thing is '<', class templates are types. */\n+      /* If the next thing is '<', class templates are types.  */\n       if (looking_for_template)\n         flags |= LOOKUP_TEMPLATES_EXPECTED;\n \n@@ -6086,7 +6086,7 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n   else\n     {\n       flags = lookup_flags (prefer_type, namespaces_only);\n-      /* If we're not parsing, we need to complain. */\n+      /* If we're not parsing, we need to complain.  */\n       flags |= LOOKUP_COMPLAIN;\n     }\n \n@@ -6310,7 +6310,7 @@ record_builtin_type (rid_index, name, type)\n       tdecl = pushdecl (build_decl (TYPE_DECL, tname, type));\n       set_identifier_type_value (tname, NULL_TREE);\n       if ((int) rid_index < (int) RID_MAX)\n-\t/* Built-in types live in the global namespace. */\n+\t/* Built-in types live in the global namespace.  */\n \tSET_IDENTIFIER_GLOBAL_VALUE (tname, tdecl);\n     }\n   if (rname != NULL_TREE)\n@@ -6342,12 +6342,12 @@ record_builtin_java_type (name, size)\n   if (size > 0)\n     type = make_signed_type (size);\n   else if (size > -32)\n-    { /* \"__java_char\" or \"\"__java_boolean\". */\n+    { /* \"__java_char\" or \"\"__java_boolean\".  */\n       type = make_unsigned_type (-size);\n       /*if (size == -1)\tTREE_SET_CODE (type, BOOLEAN_TYPE);*/\n     }\n   else\n-    { /* \"__java_float\" or \"\"__java_double\". */\n+    { /* \"__java_float\" or \"\"__java_double\".  */\n       type = make_node (REAL_TYPE);\n       TYPE_PRECISION (type) = - size;\n       layout_type (type);\n@@ -6357,14 +6357,14 @@ record_builtin_java_type (name, size)\n \n   /* Suppress generate debug symbol entries for these types,\n      since for normal C++ they are just clutter.\n-     However, push_lang_context undoes this if extern \"Java\" is seen. */\n+     However, push_lang_context undoes this if extern \"Java\" is seen.  */\n   DECL_IGNORED_P (decl) = 1;\n \n   TYPE_FOR_JAVA (type) = 1;\n   return type;\n }\n \n-/* Push a type into the namespace so that the back-ends ignore it. */\n+/* Push a type into the namespace so that the back-ends ignore it.  */\n \n static void\n record_unknown_type (type, name)\n@@ -6452,7 +6452,7 @@ cxx_init_decl_processing ()\n   /* Create the global variables.  */\n   push_to_top_level ();\n \n-  /* Enter the global namespace. */\n+  /* Enter the global namespace.  */\n   my_friendly_assert (global_namespace == NULL_TREE, 375);\n   push_namespace (get_identifier (\"::\"));\n   global_namespace = current_namespace;\n@@ -6637,7 +6637,7 @@ cxx_init_decl_processing ()\n \n /* Generate an initializer for a function naming variable from\n    NAME. NAME may be NULL, in which case we generate a special\n-   ERROR_MARK node which should be replaced later. */\n+   ERROR_MARK node which should be replaced later.  */\n \n tree\n cp_fname_init (name)\n@@ -6662,7 +6662,7 @@ cp_fname_init (name)\n     TREE_TYPE (init) = type;\n   else\n     /* We don't know the value until instantiation time. Make\n-       something which will be digested now, but replaced later. */\n+       something which will be digested now, but replaced later.  */\n     init = build (ERROR_MARK, type);\n   \n   return init;\n@@ -6684,7 +6684,7 @@ cp_make_fname_decl (id, type_dep)\n   tree init = cp_fname_init (name);\n   tree decl = build_decl (VAR_DECL, id, TREE_TYPE (init));\n \n-  /* As we don't push the decl here, we must set the context. */\n+  /* As we don't push the decl here, we must set the context.  */\n   DECL_CONTEXT (decl) = current_function_decl;\n   DECL_PRETTY_FUNCTION_P (decl) = type_dep;\n       \n@@ -7231,11 +7231,11 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n       && context != current_namespace && TREE_CODE (decl) == VAR_DECL)\n     {\n       /* When parsing the initializer, lookup should use the object's\n-\t namespace. */\n+\t namespace.  */\n       push_decl_namespace (context);\n     }\n \n-  /* We are only interested in class contexts, later. */\n+  /* We are only interested in class contexts, later.  */\n   if (context && TREE_CODE (context) == NAMESPACE_DECL)\n     context = NULL_TREE;\n \n@@ -8141,7 +8141,7 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n       && DECL_CONTEXT (decl) != current_namespace\n       && init)\n     {\n-      /* Leave the namespace of the object. */\n+      /* Leave the namespace of the object.  */\n       pop_decl_namespace ();\n     }\n \n@@ -8874,7 +8874,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n     type = build_exception_variant (type, raises);\n \n   decl = build_lang_decl (FUNCTION_DECL, declarator, type);\n-  /* Propagate volatile out from type to decl. */\n+  /* Propagate volatile out from type to decl.  */\n   if (TYPE_VOLATILE (type))\n     TREE_THIS_VOLATILE (decl) = 1;\n \n@@ -9025,7 +9025,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n               /* Due to bison parser ickiness, we will have already looked\n                  up an operator_name or PFUNCNAME within the current class\n                  (see template_id in parse.y). If the current class contains\n-                 such a name, we'll get a COMPONENT_REF here. Undo that. */\n+                 such a name, we'll get a COMPONENT_REF here. Undo that.  */\n \n               my_friendly_assert (TREE_TYPE (TREE_OPERAND (fns, 0))\n                                   == current_class_type, 20001120);\n@@ -9400,7 +9400,7 @@ compute_array_index_type (name, size)\n \t\t\t\t\t  size, integer_one_node));\n     }\n \n-  /* The size might be the result of a cast. */\n+  /* The size might be the result of a cast.  */\n   STRIP_TYPE_NOPS (size);\n \n   /* It might be a const variable or enumeration constant.  */\n@@ -9805,7 +9805,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    break;\n \n \t  case ADDR_EXPR:\t/* C++ reference declaration */\n-\t    /* Fall through. */\n+\t    /* Fall through.  */\n \t  case ARRAY_REF:\n \t  case INDIRECT_REF:\n \t    ctype = NULL_TREE;\n@@ -9893,7 +9893,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t    dname = DECL_NAME (get_first_fn (dname));\n \t\t  }\n \t      }\n-\t  /* Fall through. */\n+\t  /* Fall through.  */\n \n \t  case IDENTIFIER_NODE:\n \t    if (TREE_CODE (decl) == IDENTIFIER_NODE)\n@@ -10692,15 +10692,15 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \t    type = create_array_type_for_decl (dname, type, size);\n \n-\t    /* VLAs never work as fields. */\n+\t    /* VLAs never work as fields.  */\n \t    if (decl_context == FIELD && !processing_template_decl\n \t\t&& TREE_CODE (type) == ARRAY_TYPE\n \t\t&& TYPE_DOMAIN (type) != NULL_TREE\n \t\t&& !TREE_CONSTANT (TYPE_MAX_VALUE (TYPE_DOMAIN (type))))\n \t      {\n \t\terror (\"size of member `%D' is not constant\", dname);\n \t\t/* Proceed with arbitrary constant size, so that offset\n-\t\t   computations don't get confused. */\n+\t\t   computations don't get confused.  */\n \t\ttype = create_array_type_for_decl (dname, TREE_TYPE (type),\n \t\t\t\t\t\t   integer_one_node);\n \t      }\n@@ -11009,7 +11009,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      /* This needs to be here, in case we are called\n \t\t multiple times.  */ ;\n \t    else if (TREE_COMPLEXITY (declarator) == -1)\n-\t      /* Namespace member. */\n+\t      /* Namespace member.  */\n \t      pop_decl_namespace ();\n \t    else if (friendp && (TREE_COMPLEXITY (declarator) < 2))\n \t      /* Don't fall out into global scope. Hides real bug? --eichin */ ;\n@@ -12168,7 +12168,7 @@ grokparms (first_parm)\n \t      TREE_TYPE (decl) = type;\n \t    }\n \t  else if (abstract_virtuals_error (decl, type))\n-\t    any_error = 1;  /* Seems like a good idea. */\n+\t    any_error = 1;  /* Seems like a good idea.  */\n \t  else if (POINTER_TYPE_P (type))\n \t    {\n \t      /* [dcl.fct]/6, parameter types cannot contain pointers\n@@ -12531,7 +12531,7 @@ grok_op_properties (decl, friendp)\n \t}\n \n       if (operator_code == CALL_EXPR)\n-\treturn;\t\t\t/* No restrictions on args. */\n+\treturn;\t\t\t/* No restrictions on args.  */\n \n       if (IDENTIFIER_TYPENAME_P (name) && ! DECL_TEMPLATE_INFO (decl))\n \t{\n@@ -12795,7 +12795,7 @@ xref_tag (enum tag_types tag_code, tree name, tree attributes,\n \t\t    TYPE_IDENTIFIER (t));\n \n       /* We need to remove the class scope binding for the\n-         TYPENAME_TYPE as otherwise poplevel_class gets confused. */\n+         TYPENAME_TYPE as otherwise poplevel_class gets confused.  */\n       for (shadowed = b->class_shadowed;\n \t   shadowed;\n \t   shadowed = TREE_CHAIN (shadowed))\n@@ -13356,7 +13356,7 @@ build_enumerator (name, value, enumtype)\n \n \t  if (TYPE_VALUES (enumtype))\n \t    {\n-\t      /* The next value is the previous value ... */\n+\t      /* The next value is the previous value ...  */\n \t      prev_value = DECL_INITIAL (TREE_VALUE (TYPE_VALUES (enumtype)));\n \t      /* ... plus one.  */\n \t      value = cp_build_binary_op (PLUS_EXPR,\n@@ -13406,7 +13406,7 @@ build_enumerator (name, value, enumtype)\n       initializing value.\n \n     In finish_enum we will reset the type.  Of course, if we're\n-    processing a template, there may be no value.   */\n+    processing a template, there may be no value.  */\n   type = value ? TREE_TYPE (value) : NULL_TREE;\n \n   if (context && context == current_class_type)\n@@ -13715,7 +13715,7 @@ start_function (declspecs, declarator, attrs, flags)\n \tdecl1 = pushdecl (decl1);\n       else\n \t{\n-\t  /* We need to set the DECL_CONTEXT. */\n+\t  /* We need to set the DECL_CONTEXT.  */\n \t  if (!DECL_CONTEXT (decl1) && DECL_TEMPLATE_INFO (decl1))\n \t    DECL_CONTEXT (decl1) = DECL_CONTEXT (DECL_TI_TEMPLATE (decl1));\n \t  /* And make sure we have enough default args.  */"}, {"sha": "8529176a8810e11433093d30f0d036c86017ba8d", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c65f9f4f4673cab2f40a4b02bbb7445edc1b81/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c65f9f4f4673cab2f40a4b02bbb7445edc1b81/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=a1c65f9f4f4673cab2f40a4b02bbb7445edc1b81", "patch": "@@ -117,7 +117,7 @@ int at_eof;\n tree static_ctors;\n tree static_dtors;\n \n-/* The :: namespace. */\n+/* The :: namespace.  */\n \n tree global_namespace;\n \f\n@@ -580,7 +580,7 @@ check_member_template (tmpl)\n       if (current_function_decl)\n \t/* 14.5.2.2 [temp.mem]\n \t   \n-\t   A local class shall not have member templates. */\n+\t   A local class shall not have member templates.  */\n \terror (\"invalid declaration of member template `%#D' in local class\",\n \t\t  decl);\n       \n@@ -603,7 +603,7 @@ check_member_template (tmpl)\n     error (\"template declaration of `%#D'\", decl);\n }\n \n-/* Return true iff TYPE is a valid Java parameter or return type. */\n+/* Return true iff TYPE is a valid Java parameter or return type.  */\n \n static int\n acceptable_java_type (type)\n@@ -1370,7 +1370,7 @@ finish_anon_union (anon_union_decl)\n   int static_p = TREE_STATIC (anon_union_decl);\n   int external_p = DECL_EXTERNAL (anon_union_decl);\n \n-  /* The VAR_DECL's context is the same as the TYPE's context. */\n+  /* The VAR_DECL's context is the same as the TYPE's context.  */\n   DECL_CONTEXT (anon_union_decl) = DECL_CONTEXT (TYPE_NAME (type));\n   \n   if (TYPE_FIELDS (type) == NULL_TREE)\n@@ -1611,7 +1611,7 @@ maybe_make_one_only (decl)\n      one.  However, that's not actually the case in SVR4; a strong definition\n      after a weak one is an error.  Also, not making explicit\n      instantiations one_only means that we can end up with two copies of\n-     some template instantiations. */\n+     some template instantiations.  */\n   if (! flag_weak)\n     return;\n \n@@ -1981,7 +1981,7 @@ import_export_tinfo (decl, type, is_in_library)\n       DECL_COMDAT (decl) = 1;\n     }\n \n-  /* Now override some cases. */\n+  /* Now override some cases.  */\n   if (flag_weak)\n     DECL_COMDAT (decl) = 1;\n   else if (is_in_library)\n@@ -2031,7 +2031,7 @@ get_guard (decl)\n       guard_type = long_long_integer_type_node;\n       guard = build_decl (VAR_DECL, sname, guard_type);\n       \n-      /* The guard should have the same linkage as what it guards. */\n+      /* The guard should have the same linkage as what it guards.  */\n       TREE_PUBLIC (guard) = TREE_PUBLIC (decl);\n       TREE_STATIC (guard) = TREE_STATIC (decl);\n       DECL_COMMON (guard) = DECL_COMMON (decl);\n@@ -2275,7 +2275,7 @@ start_static_storage_duration_function ()\n       VARRAY_TREE_INIT (ssdf_decls, 32, \"ssdf_decls\");\n \n       /* Take this opportunity to initialize the map from priority\n-\t numbers to information about that priority level. */\n+\t numbers to information about that priority level.  */\n       priority_info_map = splay_tree_new (splay_tree_compare_ints,\n \t\t\t\t\t  /*delete_key_fn=*/0,\n \t\t\t\t\t  /*delete_value_fn=*/\n@@ -2868,7 +2868,7 @@ finish_file ()\n \t This is done in a separate for cycle, because if some deferred\n \t function is contained in another deferred function later in\n \t deferred_fns varray, rest_of_compilation would skip this\n-\t function and we really cannot expand the same function twice. */\n+\t function and we really cannot expand the same function twice.  */\n       for (i = 0; i < deferred_fns_used; ++i)\n \t{\n \t  tree decl = VARRAY_TREE (deferred_fns, i);\n@@ -2972,7 +2972,7 @@ finish_file ()\n   finish_repo ();\n \n   /* The entire file is now complete.  If requested, dump everything\n-     to a file.   */\n+     to a file.  */\n   {\n     int flags;\n     FILE *stream = dump_begin (TDI_all, &flags);\n@@ -3317,7 +3317,7 @@ build_expr_from_tree (t)\n               && (!current_class_type\n                   || !lookup_member (current_class_type, id, 0, 0)))\n             {\n-              /* Do Koenig lookup if there are no class members. */\n+              /* Do Koenig lookup if there are no class members.  */\n               name = do_identifier (id, 0, args);\n             }\n           else if (TREE_CODE (name) == TEMPLATE_ID_EXPR\n@@ -3588,7 +3588,7 @@ finish_decl_parsing (decl)\n     }\n }\n \n-/* Return 1 if root encloses child. */\n+/* Return 1 if root encloses child.  */\n \n static int\n is_namespace_ancestor (root, child)\n@@ -3605,7 +3605,7 @@ is_namespace_ancestor (root, child)\n   \n \n /* Return the namespace that is the common ancestor \n-   of two given namespaces. */\n+   of two given namespaces.  */\n \n tree\n namespace_ancestor (ns1, ns2)\n@@ -3626,38 +3626,38 @@ add_using_namespace (user, used, indirect)\n      int indirect;\n {\n   tree t;\n-  /* Using oneself is a no-op. */\n+  /* Using oneself is a no-op.  */\n   if (user == used)\n     return;\n   my_friendly_assert (TREE_CODE (user) == NAMESPACE_DECL, 380);\n   my_friendly_assert (TREE_CODE (used) == NAMESPACE_DECL, 380);\n-  /* Check if we already have this. */\n+  /* Check if we already have this.  */\n   t = purpose_member (used, DECL_NAMESPACE_USING (user));\n   if (t != NULL_TREE)\n     {\n       if (!indirect)\n-\t/* Promote to direct usage. */\n+\t/* Promote to direct usage.  */\n \tTREE_INDIRECT_USING (t) = 0;\n       return;\n     }\n \n-  /* Add used to the user's using list. */\n+  /* Add used to the user's using list.  */\n   DECL_NAMESPACE_USING (user) \n     = tree_cons (used, namespace_ancestor (user, used), \n \t\t DECL_NAMESPACE_USING (user));\n \n   TREE_INDIRECT_USING (DECL_NAMESPACE_USING (user)) = indirect;\n \n-  /* Add user to the used's users list. */\n+  /* Add user to the used's users list.  */\n   DECL_NAMESPACE_USERS (used)\n     = tree_cons (user, 0, DECL_NAMESPACE_USERS (used));\n \n-  /* Recursively add all namespaces used. */\n+  /* Recursively add all namespaces used.  */\n   for (t = DECL_NAMESPACE_USING (used); t; t = TREE_CHAIN (t))\n     /* indirect usage */\n     add_using_namespace (user, TREE_PURPOSE (t), 1);\n \n-  /* Tell everyone using us about the new used namespaces. */\n+  /* Tell everyone using us about the new used namespaces.  */\n   for (t = DECL_NAMESPACE_USERS (user); t; t = TREE_CHAIN (t))\n     add_using_namespace (TREE_PURPOSE (t), used, 1);\n }\n@@ -3717,14 +3717,14 @@ ambiguous_decl (name, old, new, flags)\n {\n   tree val, type;\n   my_friendly_assert (old != NULL_TREE, 393);\n-  /* Copy the value. */\n+  /* Copy the value.  */\n   val = BINDING_VALUE (new);\n   if (val)\n     switch (TREE_CODE (val))\n       {\n       case TEMPLATE_DECL:\n         /* If we expect types or namespaces, and not templates,\n-           or this is not a template class. */\n+           or this is not a template class.  */\n         if (LOOKUP_QUALIFIERS_ONLY (flags)\n             && !DECL_CLASS_TEMPLATE_P (val))\n           val = NULL_TREE;\n@@ -3759,7 +3759,7 @@ ambiguous_decl (name, old, new, flags)\n \t}\n       else\n \t{\n-\t  /* Some declarations are functions, some are not. */\n+\t  /* Some declarations are functions, some are not.  */\n           if (flags & LOOKUP_COMPLAIN)\n             {\n \t      /* If we've already given this error for this lookup,\n@@ -3776,7 +3776,7 @@ ambiguous_decl (name, old, new, flags)\n \t  BINDING_VALUE (old) = error_mark_node;\n \t}\n     }\n-  /* ... and copy the type. */\n+  /* ... and copy the type.  */\n   type = BINDING_TYPE (new);\n   if (LOOKUP_NAMESPACES_ONLY (flags))\n     type = NULL_TREE;\n@@ -3799,7 +3799,7 @@ ambiguous_decl (name, old, new, flags)\n    We are currently looking for names in namespace SCOPE, so we\n    look through USINGS for using-directives of namespaces\n    which have SCOPE as a common ancestor with the current scope.\n-   Returns zero on errors. */\n+   Returns zero on errors.  */\n \n int\n lookup_using_namespace (name, val, usings, scope, flags, spacesp)\n@@ -3810,15 +3810,15 @@ lookup_using_namespace (name, val, usings, scope, flags, spacesp)\n   tree iter;\n   tree val1;\n   /* Iterate over all used namespaces in current, searching for using\n-     directives of scope. */\n+     directives of scope.  */\n   for (iter = usings; iter; iter = TREE_CHAIN (iter))\n     if (TREE_VALUE (iter) == scope)\n       {\n \tif (spacesp)\n \t  *spacesp = tree_cons (TREE_PURPOSE (iter), NULL_TREE,\n \t\t\t\t*spacesp);\n \tval1 = binding_for_name (name, TREE_PURPOSE (iter));\n-\t/* Resolve ambiguities. */\n+\t/* Resolve ambiguities.  */\n \tval = ambiguous_decl (name, val, val1, flags);\n       }\n   return BINDING_VALUE (val) != error_mark_node;\n@@ -3827,7 +3827,7 @@ lookup_using_namespace (name, val, usings, scope, flags, spacesp)\n /* [namespace.qual]\n    Accepts the NAME to lookup and its qualifying SCOPE.\n    Returns the name/type pair found into the CPLUS_BINDING RESULT,\n-   or 0 on error. */\n+   or 0 on error.  */\n \n int\n qualified_lookup_using_namespace (name, scope, result, flags)\n@@ -3836,9 +3836,9 @@ qualified_lookup_using_namespace (name, scope, result, flags)\n      tree result;\n      int flags;\n {\n-  /* Maintain a list of namespaces visited... */\n+  /* Maintain a list of namespaces visited...  */\n   tree seen = NULL_TREE;\n-  /* ... and a list of namespace yet to see. */\n+  /* ... and a list of namespace yet to see.  */\n   tree todo = NULL_TREE;\n   tree usings;\n   /* Look through namespace aliases.  */\n@@ -3849,10 +3849,10 @@ qualified_lookup_using_namespace (name, scope, result, flags)\n       result = ambiguous_decl (name, result,\n                                binding_for_name (name, scope), flags);\n       if (!BINDING_VALUE (result) && !BINDING_TYPE (result))\n-\t/* Consider using directives. */\n+\t/* Consider using directives.  */\n \tfor (usings = DECL_NAMESPACE_USING (scope); usings;\n \t     usings = TREE_CHAIN (usings))\n-\t  /* If this was a real directive, and we have not seen it. */\n+\t  /* If this was a real directive, and we have not seen it.  */\n \t  if (!TREE_INDIRECT_USING (usings)\n \t      && !purpose_member (TREE_PURPOSE (usings), seen))\n \t    todo = tree_cons (TREE_PURPOSE (usings), NULL_TREE, todo);\n@@ -3862,15 +3862,15 @@ qualified_lookup_using_namespace (name, scope, result, flags)\n \t  todo = TREE_CHAIN (todo);\n \t}\n       else\n-\tscope = NULL_TREE; /* If there never was a todo list. */\n+\tscope = NULL_TREE; /* If there never was a todo list.  */\n     }\n   return result != error_mark_node;\n }\n \n /* [namespace.memdef]/2 */\n \n /* Set the context of a declaration to scope. Complain if we are not\n-   outside scope. */\n+   outside scope.  */\n \n void\n set_decl_namespace (decl, scope, friendp)\n@@ -3880,7 +3880,7 @@ set_decl_namespace (decl, scope, friendp)\n {\n   tree old;\n   \n-  /* Get rid of namespace aliases. */\n+  /* Get rid of namespace aliases.  */\n   scope = ORIGINAL_NAMESPACE (scope);\n   \n   /* It is ok for friends to be qualified in parallel space.  */\n@@ -3890,10 +3890,10 @@ set_decl_namespace (decl, scope, friendp)\n   DECL_CONTEXT (decl) = FROB_CONTEXT (scope);\n   if (scope != current_namespace)\n     {\n-      /* See whether this has been declared in the namespace. */\n+      /* See whether this has been declared in the namespace.  */\n       old = namespace_binding (DECL_NAME (decl), scope);\n       if (!old)\n-\t/* No old declaration at all. */\n+\t/* No old declaration at all.  */\n \tgoto complain;\n       /* A template can be explicitly specialized in any namespace.  */\n       if (processing_explicit_instantiation)\n@@ -3903,7 +3903,7 @@ set_decl_namespace (decl, scope, friendp)\n \t   since it can't check for the correct constness at this\n \t   point. pushdecl will find those errors later.  */\n \treturn;\n-      /* Since decl is a function, old should contain a function decl. */\n+      /* Since decl is a function, old should contain a function decl.  */\n       if (!is_overloaded_fn (old))\n \tgoto complain;\n       if (processing_template_decl || processing_specialization)\n@@ -3923,7 +3923,7 @@ set_decl_namespace (decl, scope, friendp)\n \t    decl, scope);\n } \n \n-/* Compute the namespace where a declaration is defined. */\n+/* Compute the namespace where a declaration is defined.  */\n \n static tree\n decl_namespace (decl)\n@@ -3944,13 +3944,13 @@ decl_namespace (decl)\n   return global_namespace;\n }\n \n-/* Return the namespace where the current declaration is declared. */\n+/* Return the namespace where the current declaration is declared.  */\n \n tree\n current_decl_namespace ()\n {\n   tree result;\n-  /* If we have been pushed into a different namespace, use it. */\n+  /* If we have been pushed into a different namespace, use it.  */\n   if (decl_namespace_list)\n     return TREE_PURPOSE (decl_namespace_list);\n \n@@ -3963,7 +3963,7 @@ current_decl_namespace ()\n   return result;\n }\n \n-/* Temporarily set the namespace for the current declaration. */\n+/* Temporarily set the namespace for the current declaration.  */\n \n void\n push_decl_namespace (decl)\n@@ -3981,7 +3981,7 @@ pop_decl_namespace ()\n   decl_namespace_list = TREE_CHAIN (decl_namespace_list);\n }\n \n-/* Enter a class or namespace scope. */\n+/* Enter a class or namespace scope.  */\n \n void\n push_scope (t)\n@@ -3993,7 +3993,7 @@ push_scope (t)\n     pushclass (t, 2);\n }\n \n-/* Leave scope pushed by push_scope. */\n+/* Leave scope pushed by push_scope.  */\n \n void\n pop_scope (t)\n@@ -4039,7 +4039,7 @@ add_function (k, fn)\n      total number of functions being compared, which should usually be the\n      case.  */\n \n-  /* We must find only functions, or exactly one non-function. */\n+  /* We must find only functions, or exactly one non-function.  */\n   if (!k->functions) \n     k->functions = fn;\n   else if (is_overloaded_fn (k->functions) && is_overloaded_fn (fn))\n@@ -4153,19 +4153,19 @@ arg_assoc_class (k, type)\n   if (arg_assoc_namespace (k, context))\n     return 1;\n   \n-  /* Process baseclasses. */\n+  /* Process baseclasses.  */\n   for (i = 0; i < CLASSTYPE_N_BASECLASSES (type); i++)\n     if (arg_assoc_class (k, TYPE_BINFO_BASETYPE (type, i)))\n       return 1;\n   \n-  /* Process friends. */\n+  /* Process friends.  */\n   for (list = DECL_FRIENDLIST (TYPE_MAIN_DECL (type)); list; \n        list = TREE_CHAIN (list))\n     if (k->name == TREE_PURPOSE (list))\n       for (friends = TREE_VALUE (list); friends; \n \t   friends = TREE_CHAIN (friends))\n \t/* Only interested in global functions with potentially hidden\n-           (i.e. unqualified) declarations. */\n+           (i.e. unqualified) declarations.  */\n \tif (TREE_PURPOSE (friends) == error_mark_node && TREE_VALUE (friends)\n \t    && decl_namespace (TREE_VALUE (friends)) == context)\n \t  if (add_function (k, TREE_VALUE (friends)))\n@@ -4212,18 +4212,18 @@ arg_assoc_type (k, type)\n     case ENUMERAL_TYPE:\n       return arg_assoc_namespace (k, decl_namespace (TYPE_MAIN_DECL (type)));\n     case OFFSET_TYPE:\n-      /* Pointer to member: associate class type and value type. */\n+      /* Pointer to member: associate class type and value type.  */\n       if (arg_assoc_type (k, TYPE_OFFSET_BASETYPE (type)))\n \treturn 1;\n       return arg_assoc_type (k, TREE_TYPE (type));\n     case METHOD_TYPE:\n       /* The basetype is referenced in the first arg type, so just\n \t fall through.  */\n     case FUNCTION_TYPE:\n-      /* Associate the parameter types. */\n+      /* Associate the parameter types.  */\n       if (arg_assoc_args (k, TYPE_ARG_TYPES (type)))\n \treturn 1;\n-      /* Associate the return type. */\n+      /* Associate the return type.  */\n       return arg_assoc_type (k, TREE_TYPE (type));\n     case TEMPLATE_TYPE_PARM:\n     case BOUND_TEMPLATE_TEMPLATE_PARM:\n@@ -4332,7 +4332,7 @@ arg_assoc (k, n)\n }\n \n /* Performs Koenig lookup depending on arguments, where fns\n-   are the functions found in normal lookup. */\n+   are the functions found in normal lookup.  */\n \n tree\n lookup_arg_dependent (name, fns, args)\n@@ -4360,29 +4360,29 @@ lookup_arg_dependent (name, fns, args)\n   return k.functions;\n }\n \n-/* Process a namespace-alias declaration. */\n+/* Process a namespace-alias declaration.  */\n \n void\n do_namespace_alias (alias, namespace)\n      tree alias, namespace;\n {\n   if (TREE_CODE (namespace) != NAMESPACE_DECL)\n     {\n-      /* The parser did not find it, so it's not there. */\n+      /* The parser did not find it, so it's not there.  */\n       error (\"unknown namespace `%D'\", namespace);\n       return;\n     }\n \n   namespace = ORIGINAL_NAMESPACE (namespace);\n \n-  /* Build the alias. */\n+  /* Build the alias.  */\n   alias = build_lang_decl (NAMESPACE_DECL, alias, void_type_node);     \n   DECL_NAMESPACE_ALIAS (alias) = namespace;\n   pushdecl (alias);\n }\n \n /* Check a non-member using-declaration. Return the name and scope\n-   being used, and the USING_DECL, or NULL_TREE on failure. */\n+   being used, and the USING_DECL, or NULL_TREE on failure.  */\n \n static tree\n validate_nonmember_using_decl (decl, scope, name)\n@@ -4435,11 +4435,11 @@ validate_nonmember_using_decl (decl, scope, name)\n     abort ();\n   if (DECL_P (*name))\n     *name = DECL_NAME (*name);\n-  /* Make a USING_DECL. */\n+  /* Make a USING_DECL.  */\n   return push_using_decl (*scope, *name);\n }\n \n-/* Process local and global using-declarations. */\n+/* Process local and global using-declarations.  */\n \n static void\n do_nonmember_using_decl (scope, name, oldval, oldtype, newval, newtype)\n@@ -4461,7 +4461,7 @@ do_nonmember_using_decl (scope, name, oldval, oldtype, newval, newtype)\n       return;\n     }\n \n-  /* Check for using functions. */\n+  /* Check for using functions.  */\n   if (BINDING_VALUE (decls) && is_overloaded_fn (BINDING_VALUE (decls)))\n     {\n       tree tmp, tmp1;\n@@ -4541,7 +4541,7 @@ do_nonmember_using_decl (scope, name, oldval, oldtype, newval, newtype)\n     }\n }\n \n-/* Process a using-declaration not appearing in class or local scope. */\n+/* Process a using-declaration not appearing in class or local scope.  */\n \n void\n do_toplevel_using_decl (decl)\n@@ -4561,7 +4561,7 @@ do_toplevel_using_decl (decl)\n \n   do_nonmember_using_decl (scope, name, oldval, oldtype, &newval, &newtype);\n \n-  /* Copy declarations found. */\n+  /* Copy declarations found.  */\n   if (newval)\n     BINDING_VALUE (binding) = newval;\n   if (newtype)\n@@ -4658,7 +4658,7 @@ do_class_using_decl (decl)\n   return value;\n }\n \n-/* Process a using-directive. */\n+/* Process a using-directive.  */\n \n void\n do_using_directive (namespace)\n@@ -4672,7 +4672,7 @@ do_using_directive (namespace)\n       namespace = TREE_OPERAND (namespace, 1);\n   if (TREE_CODE (namespace) == IDENTIFIER_NODE)\n     {\n-      /* Lookup in lexer did not find a namespace. */\n+      /* Lookup in lexer did not find a namespace.  */\n       if (!processing_template_decl)\n \terror (\"namespace `%T' undeclared\", namespace);\n       return;"}]}