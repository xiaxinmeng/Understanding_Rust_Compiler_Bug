{"sha": "b6c24eab08d9649b4229b4b0396ce91f97f88dfb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZjMjRlYWIwOGQ5NjQ5YjQyMjliNGIwMzk2Y2U5MWY5N2Y4OGRmYg==", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2020-03-02T09:29:15Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-09-18T07:00:11Z"}, "message": "AVX512FP16: Add testcase for vfmaddsub[132,213,231]ph/vfmsubadd[132,213,231]ph.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/i386/avx512fp16-vfmaddsubXXXph-1a.c: New test.\n\t* gcc.target/i386/avx512fp16-vfmaddsubXXXph-1b.c: Ditto.\n\t* gcc.target/i386/avx512fp16-vfmsubaddXXXph-1a.c: Ditto.\n\t* gcc.target/i386/avx512fp16-vfmsubaddXXXph-1b.c: Ditto.\n\t* gcc.target/i386/avx512fp16vl-vfmaddsubXXXph-1a.c: Ditto.\n\t* gcc.target/i386/avx512fp16vl-vfmaddsubXXXph-1b.c: Ditto.\n\t* gcc.target/i386/avx512fp16vl-vfmsubaddXXXph-1a.c: Ditto.\n\t* gcc.target/i386/avx512fp16vl-vfmsubaddXXXph-1b.c: Ditto.", "tree": {"sha": "ad2408ece8cbc6fe9612c2642e75045b5fce00a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad2408ece8cbc6fe9612c2642e75045b5fce00a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6c24eab08d9649b4229b4b0396ce91f97f88dfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6c24eab08d9649b4229b4b0396ce91f97f88dfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6c24eab08d9649b4229b4b0396ce91f97f88dfb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6c24eab08d9649b4229b4b0396ce91f97f88dfb/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e6850841fb52252a7e793ac6fd70a8daa1c8860", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e6850841fb52252a7e793ac6fd70a8daa1c8860", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e6850841fb52252a7e793ac6fd70a8daa1c8860"}], "stats": {"total": 488, "additions": 488, "deletions": 0}, "files": [{"sha": "7063646ef58d72ef5023b479d958fa7339e18afe", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-vfmaddsubXXXph-1a.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c24eab08d9649b4229b4b0396ce91f97f88dfb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vfmaddsubXXXph-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c24eab08d9649b4229b4b0396ce91f97f88dfb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vfmaddsubXXXph-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vfmaddsubXXXph-1a.c?ref=b6c24eab08d9649b4229b4b0396ce91f97f88dfb", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512fp16 -O2\" } */\n+/* { dg-final { scan-assembler-times \"vfmaddsub...ph\\[ \\\\t\\]+\\[^\\{\\n\\]*%zmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+/* { dg-final { scan-assembler-times \"vfmaddsub...ph\\[ \\\\t\\]+\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\"  2 } } */\n+/* { dg-final { scan-assembler-times \"vfmaddsub231ph\\[ \\\\t\\]+\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+/* { dg-final { scan-assembler-times \"vfmaddsub...ph\\[ \\\\t\\]+\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\{%k\\[1-7\\]\\}\\{z\\}(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+/* { dg-final { scan-assembler-times \"vfmaddsub...ph\\[ \\\\t\\]+\\[^\\n\\]*\\{rn-sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vfmaddsub...ph\\[ \\\\t\\]+\\[^\\n\\]*\\{rd-sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vfmaddsub231ph\\[ \\\\t\\]+\\[^\\n\\]*\\{ru-sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vfmaddsub...ph\\[ \\\\t\\]+\\[^\\n\\]*\\{rz-sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\{%k\\[1-7\\]\\}\\{z\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+\n+#include <immintrin.h>\n+\n+volatile __m512h x1, x2, x3;\n+volatile __mmask32 m;\n+\n+void extern\n+avx512f_test (void)\n+{\n+  x1 = _mm512_fmaddsub_ph (x1, x2, x3);\n+  x1 = _mm512_mask_fmaddsub_ph (x1, m, x2, x3);\n+  x3 = _mm512_mask3_fmaddsub_ph (x1, x2, x3, m);\n+  x1 = _mm512_maskz_fmaddsub_ph (m, x1, x2, x3);\n+  x1 = _mm512_fmaddsub_round_ph (x1, x2, x3, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n+  x1 = _mm512_mask_fmaddsub_round_ph (x1, m, x2, x3, _MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC);\n+  x3 = _mm512_mask3_fmaddsub_round_ph (x1, x2, x3, m, _MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC);\n+  x1 = _mm512_maskz_fmaddsub_round_ph (m, x1, x2, x3, _MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC);\n+}"}, {"sha": "16cf0af19d6ceb689e465ea748a7edd6b43d32ae", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-vfmaddsubXXXph-1b.c", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c24eab08d9649b4229b4b0396ce91f97f88dfb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vfmaddsubXXXph-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c24eab08d9649b4229b4b0396ce91f97f88dfb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vfmaddsubXXXph-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vfmaddsubXXXph-1b.c?ref=b6c24eab08d9649b4229b4b0396ce91f97f88dfb", "patch": "@@ -0,0 +1,171 @@\n+/* { dg-do run { target avx512fp16 } } */\n+/* { dg-options \"-O2 -mavx512fp16 -mavx512dq\" } */\n+\n+\n+#define AVX512FP16\n+#include \"avx512fp16-helper.h\"\n+\n+#define N_ELEMS (AVX512F_LEN / 16)\n+\n+void NOINLINE\n+EMULATE(fmaddsub_ph) (V512 * dest, V512 op1, V512 op2,\n+                    __mmask32 k, int zero_mask)\n+{\n+    V512 v1, v2, v3, v4, v5, v6, v7, v8;\n+    int i;\n+    __mmask16 m1, m2;\n+\n+    m1 = k & 0xffff;\n+    m2 = (k >> 16) & 0xffff;\n+\n+    unpack_ph_2twops(op1, &v1, &v2);\n+    unpack_ph_2twops(op2, &v3, &v4);\n+    unpack_ph_2twops(*dest, &v7, &v8);\n+\n+    for (i = 0; i < 16; i++) {\n+        if (((1 << i) & m1) == 0) {\n+            if (zero_mask) {\n+                v5.f32[i] = 0;\n+            }\n+            else {\n+                v5.u32[i] = v7.u32[i];\n+            }\n+        }\n+        else {\n+            if (i % 2 == 1) {\n+                v5.f32[i] = v1.f32[i] * v3.f32[i] + v7.f32[i];\n+            }\n+            else {\n+                v5.f32[i] = v1.f32[i] * v3.f32[i] - v7.f32[i];\n+            }\n+        }\n+\n+        if (((1 << i) & m2) == 0) {\n+            if (zero_mask) {\n+                v6.f32[i] = 0;\n+            }\n+            else {\n+                v6.u32[i] = v8.u32[i];\n+            }\n+        }\n+        else {\n+            if (i % 2 == 1) {\n+                v6.f32[i] = v2.f32[i] * v4.f32[i] + v8.f32[i];\n+            }\n+            else {\n+                v6.f32[i] = v2.f32[i] * v4.f32[i] - v8.f32[i];\n+            }\n+        }\n+    }\n+    *dest = pack_twops_2ph(v5, v6);\n+}\n+\n+void NOINLINE\n+EMULATE(m_fmaddsub_ph) (V512 * dest, V512 op1, V512 op2,\n+                    __mmask32 k, int zero_mask)\n+{\n+    V512 v1, v2, v3, v4, v5, v6, v7, v8;\n+    int i;\n+    __mmask16 m1, m2;\n+\n+    m1 = k & 0xffff;\n+    m2 = (k >> 16) & 0xffff;\n+\n+    unpack_ph_2twops(op1, &v1, &v2);\n+    unpack_ph_2twops(op2, &v3, &v4);\n+    unpack_ph_2twops(*dest, &v7, &v8);\n+\n+    for (i = 0; i < 16; i++) {\n+        if (((1 << i) & m1) == 0) {\n+            if (zero_mask) {\n+                v5.f32[i] = 0;\n+            }\n+            else {\n+                v5.u32[i] = v7.u32[i];\n+            }\n+        }\n+        else {\n+            if (i % 2 == 1) {\n+                v5.f32[i] = v1.f32[i] * v7.f32[i] + v3.f32[i];\n+            }\n+            else {\n+                v5.f32[i] = v1.f32[i] * v7.f32[i] - v3.f32[i];\n+            }\n+        }\n+\n+        if (((1 << i) & m2) == 0) {\n+            if (zero_mask) {\n+                v6.f32[i] = 0;\n+            }\n+            else {\n+                v6.u32[i] = v8.u32[i];\n+            }\n+        }\n+        else {\n+            if (i % 2 == 1) {\n+                v6.f32[i] = v2.f32[i] * v8.f32[i] + v4.f32[i];\n+            }\n+            else {\n+                v6.f32[i] = v2.f32[i] * v8.f32[i] - v4.f32[i];\n+            }\n+        }\n+    }\n+    *dest = pack_twops_2ph(v5, v6);\n+}\n+\n+void\n+TEST (void)\n+{\n+  V512 res;\n+  V512 exp;\n+\n+  init_src();\n+\n+  init_dest(&res, &exp);\n+  EMULATE(fmaddsub_ph)(&exp, src1, src2,  NET_MASK, 0);\n+  HF(res) = INTRINSIC (_fmaddsub_ph) (HF(src1), HF(src2), HF(res));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _fmaddsub_ph);\n+  init_dest(&res, &exp);\n+  EMULATE(fmaddsub_ph)(&exp, src1, src2,  MASK_VALUE, 0);\n+  HF(res) = INTRINSIC (_mask3_fmaddsub_ph) (HF(src1), HF(src2),\n+\t\t\t\t      HF(res), MASK_VALUE);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mask3_fmaddsub_ph);\n+  init_dest(&res, &exp);\n+  EMULATE(m_fmaddsub_ph)(&exp, src1, src2,  MASK_VALUE, 0);\n+  HF(res) = INTRINSIC (_mask_fmaddsub_ph) (HF(res), MASK_VALUE,\n+\t\t\t\t     HF(src1), HF(src2));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mask_fmaddsub_ph);\n+  init_dest(&res, &exp);\n+  EMULATE(fmaddsub_ph)(&exp, src1, src2,  ZMASK_VALUE, 1);\n+  HF(res) = INTRINSIC (_maskz_fmaddsub_ph) (ZMASK_VALUE, HF(src1),\n+\t\t\t\t      HF(src2), HF(res));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _maskz_fmaddsub_ph);\n+\n+  init_dest(&res, &exp);\n+#if AVX512F_LEN == 512\n+  EMULATE(fmaddsub_ph)(&exp, src1, src2,  NET_MASK, 0);\n+  HF(res) = INTRINSIC (_fmaddsub_round_ph) (HF(src1), HF(src2),\n+\t\t\t\t      HF(res), _ROUND_NINT);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _fmaddsub_ph);\n+  init_dest(&res, &exp);\n+  EMULATE(fmaddsub_ph)(&exp, src1, src2,  MASK_VALUE, 0);\n+  HF(res) = INTRINSIC (_mask3_fmaddsub_round_ph) (HF(src1), HF(src2),\n+\t\t\t\t\t    HF(res), MASK_VALUE, _ROUND_NINT);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mask3_fmaddsub_ph);\n+  init_dest(&res, &exp);\n+  EMULATE(m_fmaddsub_ph)(&exp, src1, src2,  MASK_VALUE, 0);\n+  HF(res) = INTRINSIC (_mask_fmaddsub_round_ph) (HF(res), MASK_VALUE,\n+\t\t\t\t\t   HF(src1), HF(src2), _ROUND_NINT);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mask_fmaddsub_ph);\n+  init_dest(&res, &exp);\n+  EMULATE(fmaddsub_ph)(&exp, src1, src2,  ZMASK_VALUE, 1);\n+  HF(res) = INTRINSIC (_maskz_fmaddsub_round_ph) (ZMASK_VALUE, HF(src1),\n+\t\t\t\t\t    HF(src2), HF(res), _ROUND_NINT);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _maskz_fmaddsub_ph);\n+#endif\n+\n+  if (n_errs != 0) {\n+      abort ();\n+  }\n+}\n+"}, {"sha": "87087c9fb42449cbcfc13379d9f220845c6f6c45", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-vfmsubaddXXXph-1a.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c24eab08d9649b4229b4b0396ce91f97f88dfb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vfmsubaddXXXph-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c24eab08d9649b4229b4b0396ce91f97f88dfb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vfmsubaddXXXph-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vfmsubaddXXXph-1a.c?ref=b6c24eab08d9649b4229b4b0396ce91f97f88dfb", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512fp16 -O2\" } */\n+/* { dg-final { scan-assembler-times \"vfmsubadd...ph\\[ \\\\t\\]+\\[^\\{\\n\\]*%zmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+/* { dg-final { scan-assembler-times \"vfmsubadd...ph\\[ \\\\t\\]+\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\"  2 } } */\n+/* { dg-final { scan-assembler-times \"vfmsubadd231ph\\[ \\\\t\\]+\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+/* { dg-final { scan-assembler-times \"vfmsubadd...ph\\[ \\\\t\\]+\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\{%k\\[1-7\\]\\}\\{z\\}(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+/* { dg-final { scan-assembler-times \"vfmsubadd...ph\\[ \\\\t\\]+\\[^\\n\\]*\\{rn-sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vfmsubadd...ph\\[ \\\\t\\]+\\[^\\n\\]*\\{rd-sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vfmsubadd231ph\\[ \\\\t\\]+\\[^\\n\\]*\\{ru-sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vfmsubadd...ph\\[ \\\\t\\]+\\[^\\n\\]*\\{rz-sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\{%k\\[1-7\\]\\}\\{z\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+\n+#include <immintrin.h>\n+\n+volatile __m512h x1, x2, x3;\n+volatile __mmask32 m;\n+\n+void extern\n+avx512f_test (void)\n+{\n+  x1 = _mm512_fmsubadd_ph (x1, x2, x3);\n+  x1 = _mm512_mask_fmsubadd_ph (x1, m, x2, x3);\n+  x3 = _mm512_mask3_fmsubadd_ph (x1, x2, x3, m);\n+  x1 = _mm512_maskz_fmsubadd_ph (m, x1, x2, x3);\n+  x1 = _mm512_fmsubadd_round_ph (x1, x2, x3, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n+  x1 = _mm512_mask_fmsubadd_round_ph (x1, m, x2, x3, _MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC);\n+  x3 = _mm512_mask3_fmsubadd_round_ph (x1, x2, x3, m, _MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC);\n+  x1 = _mm512_maskz_fmsubadd_round_ph (m, x1, x2, x3, _MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC);\n+}"}, {"sha": "159cae4bb26f981b96a9547a6f4e563d4e53fe37", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-vfmsubaddXXXph-1b.c", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c24eab08d9649b4229b4b0396ce91f97f88dfb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vfmsubaddXXXph-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c24eab08d9649b4229b4b0396ce91f97f88dfb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vfmsubaddXXXph-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vfmsubaddXXXph-1b.c?ref=b6c24eab08d9649b4229b4b0396ce91f97f88dfb", "patch": "@@ -0,0 +1,175 @@\n+/* { dg-do run { target avx512fp16 } } */\n+/* { dg-options \"-O2 -mavx512fp16 -mavx512dq\" } */\n+\n+\n+#define AVX512FP16\n+#include \"avx512fp16-helper.h\"\n+\n+#define N_ELEMS (AVX512F_LEN / 16)\n+\n+void NOINLINE\n+EMULATE(fmsubadd_ph) (V512 * dest, V512 op1, V512 op2,\n+                    __mmask32 k, int zero_mask)\n+{\n+    V512 v1, v2, v3, v4, v5, v6, v7, v8;\n+    int i;\n+    __mmask16 m1, m2;\n+\n+    m1 = k & 0xffff;\n+    m2 = (k >> 16) & 0xffff;\n+\n+    unpack_ph_2twops(op1, &v1, &v2);\n+    unpack_ph_2twops(op2, &v3, &v4);\n+    unpack_ph_2twops(*dest, &v7, &v8);\n+\n+    for (i = 0; i < 16; i++) {\n+        if (((1 << i) & m1) == 0) {\n+            if (zero_mask) {\n+               v5.f32[i] = 0;\n+            }\n+            else {\n+                v5.u32[i] = v7.u32[i];\n+            }\n+        }\n+        else {\n+            if (i % 2 == 1) {\n+                v5.f32[i] = v1.f32[i] * v3.f32[i] - v7.f32[i];\n+            }\n+            else {\n+                v5.f32[i] = v1.f32[i] * v3.f32[i] + v7.f32[i];\n+            }\n+        }\n+\n+        if (((1 << i) & m2) == 0) {\n+            if (zero_mask) {\n+               v6.f32[i] = 0;\n+            }\n+            else {\n+                v6.u32[i] = v8.u32[i];\n+            }\n+        }\n+        else {\n+            if (i % 2 == 1) {\n+                v6.f32[i] = v2.f32[i] * v4.f32[i] - v8.f32[i];\n+            }\n+            else {\n+                v6.f32[i] = v2.f32[i] * v4.f32[i] + v8.f32[i];\n+            }\n+        }\n+    }\n+    *dest = pack_twops_2ph(v5, v6);\n+}\n+\n+void NOINLINE\n+EMULATE(m_fmsubadd_ph) (V512 * dest, V512 op1, V512 op2,\n+                    __mmask32 k, int zero_mask)\n+{\n+    V512 v1, v2, v3, v4, v5, v6, v7, v8;\n+    int i;\n+    __mmask16 m1, m2;\n+\n+    m1 = k & 0xffff;\n+    m2 = (k >> 16) & 0xffff;\n+\n+    unpack_ph_2twops(op1, &v1, &v2);\n+    unpack_ph_2twops(op2, &v3, &v4);\n+    unpack_ph_2twops(*dest, &v7, &v8);\n+\n+    for (i = 0; i < 16; i++) {\n+        if (((1 << i) & m1) == 0) {\n+            if (zero_mask) {\n+               v5.f32[i] = 0;\n+            }\n+            else {\n+                v5.u32[i] = v7.u32[i];\n+            }\n+        }\n+        else {\n+            if (i % 2 == 1) {\n+                v5.f32[i] = v1.f32[i] * v7.f32[i] - v3.f32[i];\n+            }\n+            else {\n+                v5.f32[i] = v1.f32[i] * v7.f32[i] + v3.f32[i];\n+            }\n+        }\n+\n+        if (((1 << i) & m2) == 0) {\n+            if (zero_mask) {\n+               v6.f32[i] = 0;\n+            }\n+            else {\n+                v6.u32[i] = v8.u32[i];\n+            }\n+        }\n+        else {\n+            if (i % 2 == 1) {\n+                v6.f32[i] = v2.f32[i] * v8.f32[i] - v4.f32[i];\n+            }\n+            else {\n+                v6.f32[i] = v2.f32[i] * v8.f32[i] + v4.f32[i];\n+            }\n+        }\n+    }\n+    *dest = pack_twops_2ph(v5, v6);\n+}\n+\n+void\n+TEST (void)\n+{\n+  V512 res;\n+  V512 exp;\n+\n+  init_src();\n+\n+  init_dest(&res, &exp);\n+  EMULATE(fmsubadd_ph)(&exp, src1, src2,  NET_MASK, 0);\n+  HF(res) = INTRINSIC (_fmsubadd_ph) (HF(src1), HF(src2), HF(res));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _fmsubadd_ph);\n+  init_dest(&res, &exp);\n+  EMULATE(fmsubadd_ph)(&exp, src1, src2,  MASK_VALUE, 0);\n+  HF(res) = INTRINSIC (_mask3_fmsubadd_ph) (HF(src1), HF(src2),\n+\t\t\t\t      HF(res), MASK_VALUE);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mask3_fmsubadd_ph);\n+  init_dest(&res, &exp);\n+  EMULATE(m_fmsubadd_ph)(&exp, src1, src2,  MASK_VALUE, 0);\n+  HF(res) = INTRINSIC (_mask_fmsubadd_ph) (HF(res), MASK_VALUE,\n+\t\t\t\t     HF(src1), HF(src2));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mask_fmsubadd_ph);\n+  init_dest(&res, &exp);\n+  EMULATE(fmsubadd_ph)(&exp, src1, src2,  ZMASK_VALUE, 1);\n+  HF(res) = INTRINSIC (_maskz_fmsubadd_ph) (ZMASK_VALUE, HF(src1),\n+\t\t\t\t      HF(src2), HF(res));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _maskz_fmsubadd_ph);\n+\n+  init_dest(&res, &exp);\n+#if AVX512F_LEN == 512\n+  EMULATE(fmsubadd_ph)(&exp, src1, src2,  NET_MASK, 0);\n+  HF(res) = INTRINSIC (_fmsubadd_round_ph) (HF(src1), HF(src2),\n+\t\t\t\t      HF(res), _ROUND_NINT);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _fmsubadd_ph);\n+  init_dest(&res, &exp);\n+  EMULATE(fmsubadd_ph)(&exp, src1, src2,  MASK_VALUE, 0);\n+  HF(res) = INTRINSIC (_mask3_fmsubadd_round_ph) (HF(src1), HF(src2),\n+\t\t\t\t\t    HF(res), MASK_VALUE,\n+\t\t\t\t\t    _ROUND_NINT);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mask3_fmsubadd_ph);\n+  init_dest(&res, &exp);\n+  EMULATE(m_fmsubadd_ph)(&exp, src1, src2,  MASK_VALUE, 0);\n+  HF(res) = INTRINSIC (_mask_fmsubadd_round_ph) (HF(res), MASK_VALUE,\n+\t\t\t\t\t   HF(src1), HF(src2),\n+\t\t\t\t\t   _ROUND_NINT);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mask_fmsubadd_ph);\n+  init_dest(&res, &exp);\n+  EMULATE(fmsubadd_ph)(&exp, src1, src2,  ZMASK_VALUE, 1);\n+  HF(res) = INTRINSIC (_maskz_fmsubadd_round_ph) (ZMASK_VALUE, HF(src1),\n+\t\t\t\t\t    HF(src2), HF(res),\n+\t\t\t\t\t    _ROUND_NINT);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _maskz_fmsubadd_ph);\n+#endif\n+\n+  if (n_errs != 0) {\n+    abort ();\n+  }\n+}\n+\n+"}, {"sha": "963fbb6af905b5cf211bc285584951aba0881c1a", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16vl-vfmaddsubXXXph-1a.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c24eab08d9649b4229b4b0396ce91f97f88dfb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vfmaddsubXXXph-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c24eab08d9649b4229b4b0396ce91f97f88dfb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vfmaddsubXXXph-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vfmaddsubXXXph-1a.c?ref=b6c24eab08d9649b4229b4b0396ce91f97f88dfb", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512vl -mavx512fp16 -O2\" } */\n+/* { dg-final { scan-assembler-times \"vfmaddsub...ph\\[ \\\\t\\]+\\[^\\{\\n\\]*%ymm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\"  2 } } */\n+/* { dg-final { scan-assembler-times \"vfmaddsub...ph\\[ \\\\t\\]+\\[^\\{\\n\\]*%xmm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\"  2 } } */\n+/* { dg-final { scan-assembler-times \"vfmaddsub231ph\\[ \\\\t\\]+\\[^\\{\\n\\]*%ymm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vfmaddsub231ph\\[ \\\\t\\]+\\[^\\{\\n\\]*%xmm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vfmaddsub...ph\\[ \\\\t\\]+\\[^\\{\\n\\]*%ymm\\[0-9\\]+\\{%k\\[1-7\\]\\}\\{z\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vfmaddsub...ph\\[ \\\\t\\]+\\[^\\{\\n\\]*%xmm\\[0-9\\]+\\{%k\\[1-7\\]\\}\\{z\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+\n+#include <immintrin.h>\n+\n+volatile __m256h yy, y2, y3;\n+volatile __m128h xx, x2, x3;\n+volatile __mmask8 m;\n+volatile __mmask16 m16;\n+\n+void extern\n+avx512vl_test (void)\n+{\n+  yy = _mm256_mask_fmaddsub_ph (yy, m16, y2, y3);\n+  xx = _mm_mask_fmaddsub_ph (xx, m, x2, x3);\n+\n+  y3 = _mm256_mask3_fmaddsub_ph (yy, y2, y3, m16);\n+  x3 = _mm_mask3_fmaddsub_ph (xx, x2, x3, m);\n+\n+  yy = _mm256_maskz_fmaddsub_ph (m16, yy, y2, y3);\n+  xx = _mm_maskz_fmaddsub_ph (m, xx, x2, x3);\n+}"}, {"sha": "7f9748b7e26ebb045207218ee83e5cc1f7b449f6", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16vl-vfmaddsubXXXph-1b.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c24eab08d9649b4229b4b0396ce91f97f88dfb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vfmaddsubXXXph-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c24eab08d9649b4229b4b0396ce91f97f88dfb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vfmaddsubXXXph-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vfmaddsubXXXph-1b.c?ref=b6c24eab08d9649b4229b4b0396ce91f97f88dfb", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do run { target avx512fp16 } } */\n+/* { dg-options \"-O2 -mavx512fp16 -mavx512vl -mavx512dq\" } */\n+\n+#define AVX512VL\n+#define AVX512F_LEN 256      \n+#define AVX512F_LEN_HALF 128 \n+#include \"avx512fp16-vfmaddsubXXXph-1b.c\"\n+                             \n+#undef AVX512F_LEN           \n+#undef AVX512F_LEN_HALF      \n+                             \n+#define AVX512F_LEN 128      \n+#define AVX512F_LEN_HALF 128 \n+#include \"avx512fp16-vfmaddsubXXXph-1b.c\"\n+"}, {"sha": "0316b8e0714dff10daee0de9f14d07f8b4e24df2", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16vl-vfmsubaddXXXph-1a.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c24eab08d9649b4229b4b0396ce91f97f88dfb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vfmsubaddXXXph-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c24eab08d9649b4229b4b0396ce91f97f88dfb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vfmsubaddXXXph-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vfmsubaddXXXph-1a.c?ref=b6c24eab08d9649b4229b4b0396ce91f97f88dfb", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512vl -mavx512fp16 -O2\" } */\n+/* { dg-final { scan-assembler-times \"vfmsubadd...ph\\[ \\\\t\\]+\\[^\\{\\n\\]*%ymm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\"  2 } } */\n+/* { dg-final { scan-assembler-times \"vfmsubadd...ph\\[ \\\\t\\]+\\[^\\{\\n\\]*%xmm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\"  2 } } */\n+/* { dg-final { scan-assembler-times \"vfmsubadd231ph\\[ \\\\t\\]+\\[^\\{\\n\\]*%ymm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vfmsubadd231ph\\[ \\\\t\\]+\\[^\\{\\n\\]*%xmm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vfmsubadd...ph\\[ \\\\t\\]+\\[^\\{\\n\\]*%ymm\\[0-9\\]+\\{%k\\[1-7\\]\\}\\{z\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vfmsubadd...ph\\[ \\\\t\\]+\\[^\\{\\n\\]*%xmm\\[0-9\\]+\\{%k\\[1-7\\]\\}\\{z\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+\n+#include <immintrin.h>\n+\n+volatile __m256h yy, y2, y3;\n+volatile __m128h xx, x2, x3;\n+volatile __mmask8 m;\n+volatile __mmask16 m16;\n+\n+void extern\n+avx512vl_test (void)\n+{\n+  yy = _mm256_mask_fmsubadd_ph (yy, m16, y2, y3);\n+  xx = _mm_mask_fmsubadd_ph (xx, m, x2, x3);\n+\n+  y3 = _mm256_mask3_fmsubadd_ph (yy, y2, y3, m16);\n+  x3 = _mm_mask3_fmsubadd_ph (xx, x2, x3, m);\n+\n+  yy = _mm256_maskz_fmsubadd_ph (m16, yy, y2, y3);\n+  xx = _mm_maskz_fmsubadd_ph (m, xx, x2, x3);\n+}"}, {"sha": "c8caca105ada063c5b886d7f7183387e55932652", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16vl-vfmsubaddXXXph-1b.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c24eab08d9649b4229b4b0396ce91f97f88dfb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vfmsubaddXXXph-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c24eab08d9649b4229b4b0396ce91f97f88dfb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vfmsubaddXXXph-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vfmsubaddXXXph-1b.c?ref=b6c24eab08d9649b4229b4b0396ce91f97f88dfb", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do run { target avx512fp16 } } */\n+/* { dg-options \"-O2 -mavx512fp16 -mavx512vl -mavx512dq\" } */\n+\n+#define AVX512VL\n+#define AVX512F_LEN 256      \n+#define AVX512F_LEN_HALF 128 \n+#include \"avx512fp16-vfmsubaddXXXph-1b.c\"\n+                             \n+#undef AVX512F_LEN           \n+#undef AVX512F_LEN_HALF      \n+                             \n+#define AVX512F_LEN 128      \n+#define AVX512F_LEN_HALF 128 \n+#include \"avx512fp16-vfmsubaddXXXph-1b.c\"\n+"}]}