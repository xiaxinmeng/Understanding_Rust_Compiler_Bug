{"sha": "694a4f61a759b021a7120dcb145e9afffdead582", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk0YTRmNjFhNzU5YjAyMWE3MTIwZGNiMTQ1ZTlhZmZmZGVhZDU4Mg==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2010-10-05T12:01:29Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2010-10-05T12:01:29Z"}, "message": "re PR tree-optimization/45752 (ICE in ix86_vectorize_builtin_vec_perm_ok)\n\n\n\tPR tree-optimization/45752\n\t* tree-vect-slp.c (vect_get_mask_element): Remove static\n\tvariables, make them function arguments.\n\t(vect_transform_slp_perm_load): Pass new arguments to\n\tvect_get_mask_element.\n\nFrom-SVN: r164987", "tree": {"sha": "ffdd26c4b4ea0f145864d8ad756a501f256b8d9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffdd26c4b4ea0f145864d8ad756a501f256b8d9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/694a4f61a759b021a7120dcb145e9afffdead582", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/694a4f61a759b021a7120dcb145e9afffdead582", "html_url": "https://github.com/Rust-GCC/gccrs/commit/694a4f61a759b021a7120dcb145e9afffdead582", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/694a4f61a759b021a7120dcb145e9afffdead582/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4d3814a514c4854cdc44242d383ea245c413b1d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d3814a514c4854cdc44242d383ea245c413b1d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d3814a514c4854cdc44242d383ea245c413b1d5"}], "stats": {"total": 157, "additions": 141, "deletions": 16}, "files": [{"sha": "9d8e45cd1ba75472bca7c4a5816c3cd53816e686", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/694a4f61a759b021a7120dcb145e9afffdead582/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/694a4f61a759b021a7120dcb145e9afffdead582/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=694a4f61a759b021a7120dcb145e9afffdead582", "patch": "@@ -1,3 +1,11 @@\n+2010-10-05  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/45752\n+\t* tree-vect-slp.c (vect_get_mask_element): Remove static\n+\tvariables, make them function arguments.\n+\t(vect_transform_slp_perm_load): Pass new arguments to\n+\tvect_get_mask_element.\n+\n 2010-10-05  Richard Guenther  <rguenther@suse.de>\n \n \t* value-prof.c (gimple_divmod_fixed_value): Work on SSA form."}, {"sha": "b94bb6995a5729becaa55ae1010bbf1f0fdf7567", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/694a4f61a759b021a7120dcb145e9afffdead582/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/694a4f61a759b021a7120dcb145e9afffdead582/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=694a4f61a759b021a7120dcb145e9afffdead582", "patch": "@@ -1,3 +1,8 @@\n+2010-10-05  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/45752\n+\t* gcc.dg/vect/pr45752.c: New test.\n+\n 2010-10-05  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/tree-prof/val-prof-1.c: Adjust."}, {"sha": "b04caa126553ee5153881945cf21a2035838b955", "filename": "gcc/testsuite/gcc.dg/vect/pr45752.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/694a4f61a759b021a7120dcb145e9afffdead582/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr45752.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/694a4f61a759b021a7120dcb145e9afffdead582/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr45752.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr45752.c?ref=694a4f61a759b021a7120dcb145e9afffdead582", "patch": "@@ -0,0 +1,109 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define M00 100\n+#define M10 216\n+#define M20 23\n+#define M30 237\n+#define M40 437\n+\n+#define M01 1322\n+#define M11 13\n+#define M21 27271\n+#define M31 2280\n+#define M41 284\n+\n+#define M02 74\n+#define M12 191\n+#define M22 500\n+#define M32 111\n+#define M42 1114\n+\n+#define M03 134\n+#define M13 117\n+#define M23 11\n+#define M33 771\n+#define M43 71\n+\n+#define M04 334\n+#define M14 147\n+#define M24 115\n+#define M34 7716\n+#define M44 16\n+\n+#define N 16\n+\n+void foo (unsigned int *__restrict__ pInput,\n+          unsigned int *__restrict__ pOutput,\n+          unsigned int *__restrict__ pInput2,\n+          unsigned int *__restrict__ pOutput2)\n+{\n+  unsigned int i, a, b, c, d, e;\n+\n+  for (i = 0; i < N / 5; i++)\n+    {\n+       a = *pInput++;\n+       b = *pInput++;\n+       c = *pInput++;\n+       d = *pInput++;\n+       e = *pInput++;\n+\n+       *pOutput++ = M00 * a + M01 * b + M02 * c + M03 * d + M04 * e;\n+       *pOutput++ = M10 * a + M11 * b + M12 * c + M13 * d + M14 * e;\n+       *pOutput++ = M20 * a + M21 * b + M22 * c + M23 * d + M24 * e;\n+       *pOutput++ = M30 * a + M31 * b + M32 * c + M33 * d + M34 * e;\n+       *pOutput++ = M40 * a + M41 * b + M42 * c + M43 * d + M44 * e;\n+\n+\n+       a = *pInput2++;\n+       b = *pInput2++;\n+       c = *pInput2++;\n+       d = *pInput2++;\n+       e = *pInput2++;\n+\n+       *pOutput2++ = M00 * a + M01 * b + M02 * c + M03 * d + M04 * e;\n+       *pOutput2++ = M10 * a + M11 * b + M12 * c + M13 * d + M14 * e;\n+       *pOutput2++ = M20 * a + M21 * b + M22 * c + M23 * d + M24 * e;\n+       *pOutput2++ = M30 * a + M31 * b + M32 * c + M33 * d + M34 * e;\n+       *pOutput2++ = M40 * a + M41 * b + M42 * c + M43 * d + M44 * e;\n+\n+    }\n+}\n+\n+int main (int argc, const char* argv[])\n+{\n+  unsigned int input[N], output[N], i, input2[N], output2[N];\n+  unsigned int check_results[N] = {3208, 1334, 28764, 35679, 2789, 13028,\n+    4754, 168364, 91254, 12399, 22848, 8174, 307964, 146829, 22009, 0};\n+  unsigned int check_results2[N] = {7136, 2702, 84604, 57909, 6633, 16956,\n+    6122, 224204, 113484, 16243, 26776, 9542, 363804, 169059, 25853, 0};\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      input[i] = i%256;\n+      input2[i] = i + 2;\n+      output[i] = 0;\n+      output2[i] = 0;\n+      __asm__ volatile (\"\");\n+    }\n+\n+  foo (input, output, input2, output2);\n+\n+  for (i = 0; i < N; i++)\n+    if (output[i] != check_results[i]\n+        || output2[i] != check_results2[i])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"permutation requires at least three vectors\" 2 \"vect\" { target vect_perm } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "4739538348cd6779e598816120374c6e0e5fdb9e", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/694a4f61a759b021a7120dcb145e9afffdead582/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/694a4f61a759b021a7120dcb145e9afffdead582/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=694a4f61a759b021a7120dcb145e9afffdead582", "patch": "@@ -2177,20 +2177,18 @@ static bool\n vect_get_mask_element (gimple stmt, int first_mask_element, int m,\n                        int mask_nunits, bool only_one_vec, int index,\n                        int *mask, int *current_mask_element,\n-                       bool *need_next_vector)\n+                       bool *need_next_vector, int *number_of_mask_fixes,\n+                       bool *mask_fixed, bool *needs_first_vector)\n {\n   int i;\n-  static int number_of_mask_fixes = 1;\n-  static bool mask_fixed = false;\n-  static bool needs_first_vector = false;\n \n   /* Convert to target specific representation.  */\n   *current_mask_element = first_mask_element + m;\n   /* Adjust the value in case it's a mask for second and third vectors.  */\n-  *current_mask_element -= mask_nunits * (number_of_mask_fixes - 1);\n+  *current_mask_element -= mask_nunits * (*number_of_mask_fixes - 1);\n \n   if (*current_mask_element < mask_nunits)\n-    needs_first_vector = true;\n+    *needs_first_vector = true;\n \n   /* We have only one input vector to permute but the mask accesses values in\n      the next vector as well.  */\n@@ -2208,7 +2206,7 @@ vect_get_mask_element (gimple stmt, int first_mask_element, int m,\n   /* The mask requires the next vector.  */\n   if (*current_mask_element >= mask_nunits * 2)\n     {\n-      if (needs_first_vector || mask_fixed)\n+      if (*needs_first_vector || *mask_fixed)\n         {\n           /* We either need the first vector too or have already moved to the\n              next vector. In both cases, this permutation needs three\n@@ -2226,23 +2224,23 @@ vect_get_mask_element (gimple stmt, int first_mask_element, int m,\n       /* We move to the next vector, dropping the first one and working with\n          the second and the third - we need to adjust the values of the mask\n          accordingly.  */\n-      *current_mask_element -= mask_nunits * number_of_mask_fixes;\n+      *current_mask_element -= mask_nunits * *number_of_mask_fixes;\n \n       for (i = 0; i < index; i++)\n-        mask[i] -= mask_nunits * number_of_mask_fixes;\n+        mask[i] -= mask_nunits * *number_of_mask_fixes;\n \n-      (number_of_mask_fixes)++;\n-      mask_fixed = true;\n+      (*number_of_mask_fixes)++;\n+      *mask_fixed = true;\n     }\n \n-  *need_next_vector = mask_fixed;\n+  *need_next_vector = *mask_fixed;\n \n   /* This was the last element of this mask. Start a new one.  */\n   if (index == mask_nunits - 1)\n     {\n-      number_of_mask_fixes = 1;\n-      mask_fixed = false;\n-      needs_first_vector = false;\n+      *number_of_mask_fixes = 1;\n+      *mask_fixed = false;\n+      *needs_first_vector = false;\n     }\n \n   return true;\n@@ -2268,6 +2266,9 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n   int index, unroll_factor, *mask, current_mask_element, ncopies;\n   bool only_one_vec = false, need_next_vector = false;\n   int first_vec_index, second_vec_index, orig_vec_stmts_num, vect_stmts_counter;\n+  int number_of_mask_fixes = 1;\n+  bool mask_fixed = false;\n+  bool needs_first_vector = false;\n \n   if (!targetm.vectorize.builtin_vec_perm)\n     {\n@@ -2351,7 +2352,9 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n                 {\n                   if (!vect_get_mask_element (stmt, first_mask_element, m,\n                                    mask_nunits, only_one_vec, index, mask,\n-                                   &current_mask_element, &need_next_vector))\n+                                   &current_mask_element, &need_next_vector,\n+                                   &number_of_mask_fixes, &mask_fixed,\n+                                   &needs_first_vector))\n                     return false;\n \n                   mask[index++] = current_mask_element;"}]}