{"sha": "8e3f90945d7686914c31a21fcd6cf7b3a5901753", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUzZjkwOTQ1ZDc2ODY5MTRjMzFhMjFmY2Q2Y2Y3YjNhNTkwMTc1Mw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-04-12T01:38:15Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-04-12T01:38:15Z"}, "message": "flow.c (struct propagate_block_info): Add new_dead, new_live.\n\n        * flow.c (struct propagate_block_info): Add new_dead, new_live.\n        (propagate_block): Initialize them.  Use them in parallel instead\n        of one tmp variable, ie revert much of the 0408 and 0407 functional\n        changes, but keep the structural changes.\n        (mark_set_regs): Take new_dead from propagate_block_info instead.\n        (mark_set_1, mark_set_reg): Likewise.\n        (mark_used_regs): Likewise with new_live.\n        (mark_used_reg): Likewise.  Revert 0408 change.\n\nFrom-SVN: r33089", "tree": {"sha": "4e02eb320efa26f69680fcb024580460412817f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e02eb320efa26f69680fcb024580460412817f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e3f90945d7686914c31a21fcd6cf7b3a5901753", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e3f90945d7686914c31a21fcd6cf7b3a5901753", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e3f90945d7686914c31a21fcd6cf7b3a5901753", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e3f90945d7686914c31a21fcd6cf7b3a5901753/comments", "author": null, "committer": null, "parents": [{"sha": "34600701596c5a34d8bc88e84f49d2bbc76c84f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34600701596c5a34d8bc88e84f49d2bbc76c84f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34600701596c5a34d8bc88e84f49d2bbc76c84f8"}], "stats": {"total": 219, "additions": 110, "deletions": 109}, "files": [{"sha": "d10c3ce38b46279ec71324d5f9ea16040d25a17f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3f90945d7686914c31a21fcd6cf7b3a5901753/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3f90945d7686914c31a21fcd6cf7b3a5901753/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e3f90945d7686914c31a21fcd6cf7b3a5901753", "patch": "@@ -1,3 +1,14 @@\n+2000-04-11  Richard Henderson  <rth@cygnus.com>\n+\n+\t* flow.c (struct propagate_block_info): Add new_dead, new_live.\n+\t(propagate_block): Initialize them.  Use them in parallel instead\n+\tof one tmp variable, ie revert much of the 0408 and 0407 functional\n+\tchanges, but keep the structural changes.\n+\t(mark_set_regs): Take new_dead from propagate_block_info instead.\n+\t(mark_set_1, mark_set_reg): Likewise.\n+\t(mark_used_regs): Likewise with new_live.\n+\t(mark_used_reg): Likewise.  Revert 0408 change.\n+\n 2000-04-11  Nick Clifton  <nickc@cygnus.com>\n \n \t* config/arm/arm.h: (INCOMING_RETURN_ADDR_RTX): Remove Dwarf2"}, {"sha": "a0b1266b032e16430ce6130b5630b4e9b8ea2bec", "filename": "gcc/flow.c", "status": "modified", "additions": 99, "deletions": 109, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3f90945d7686914c31a21fcd6cf7b3a5901753/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3f90945d7686914c31a21fcd6cf7b3a5901753/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=8e3f90945d7686914c31a21fcd6cf7b3a5901753", "patch": "@@ -268,6 +268,12 @@ struct propagate_block_info\n   /* Bit N is set if register N is conditionally or unconditionally live.  */\n   regset reg_live;\n \n+  /* Bit N is set if register N is unconditionally dead this insn.  */\n+  regset new_dead;\n+\n+  /* Bit N is set if register N is live this insn.  */\n+  regset new_live;\n+\n   /* Element N is the next insn that uses (hard or pseudo) register N\n      within the current basic block; or zero, if there is no such insn.  */\n   rtx *reg_next_use;\n@@ -335,12 +341,11 @@ static int insn_dead_p\t\t\tPARAMS ((struct propagate_block_info *,\n static int libcall_dead_p\t\tPARAMS ((struct propagate_block_info *,\n \t\t\t\t\t\t rtx, rtx, rtx));\n static void mark_set_regs\t\tPARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t regset, rtx, rtx));\n+\t\t\t\t\t\t rtx, rtx));\n static void mark_set_1\t\t\tPARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t regset, rtx, rtx, rtx));\n+\t\t\t\t\t\t rtx, rtx, rtx));\n static int mark_set_reg\t\t\tPARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t regset, rtx, rtx,\n-\t\t\t\t\t\t int *, int *));\n+\t\t\t\t\t\t rtx, rtx, int *, int *));\n #ifdef AUTO_INC_DEC\n static void find_auto_inc\t\tPARAMS ((struct propagate_block_info *,\n \t\t\t\t\t\t rtx, rtx));\n@@ -349,9 +354,9 @@ static int try_pre_increment_1\t\tPARAMS ((struct propagate_block_info *,\n static int try_pre_increment\t\tPARAMS ((rtx, rtx, HOST_WIDE_INT));\n #endif\n static void mark_used_reg\t\tPARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t regset, rtx, rtx, rtx));\n+\t\t\t\t\t\t rtx, rtx, rtx));\n static void mark_used_regs\t\tPARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t regset, rtx, rtx, rtx));\n+\t\t\t\t\t\t rtx, rtx, rtx));\n void dump_flow_info\t\t\tPARAMS ((FILE *));\n void debug_flow_info\t\t\tPARAMS ((void));\n static void dump_edge_info\t\tPARAMS ((FILE *, edge, int));\n@@ -3313,8 +3318,7 @@ propagate_block (bb, live, local_set, flags)\n {\n   struct propagate_block_info pbi;\n   rtx insn, prev;\n-  regset_head tmp_head;\n-  regset tmp;\n+  regset_head new_live_head, new_dead_head;\n   \n   pbi.bb = bb;\n   pbi.reg_live = live;\n@@ -3328,7 +3332,8 @@ propagate_block (bb, live, local_set, flags)\n   else\n     pbi.reg_next_use = NULL;\n \n-  tmp = INITIALIZE_REG_SET (tmp_head);\n+  pbi.new_live = INITIALIZE_REG_SET (new_live_head);\n+  pbi.new_dead = INITIALIZE_REG_SET (new_dead_head);\n \n   if (flags & PROP_REG_INFO)\n     {\n@@ -3443,7 +3448,8 @@ propagate_block (bb, live, local_set, flags)\n \t  }\n #endif /* AUTO_INC_DEC */\n \n-\t  CLEAR_REG_SET (tmp);\n+\t  CLEAR_REG_SET (pbi.new_live);\n+\t  CLEAR_REG_SET (pbi.new_dead);\n \n \t  /* If this is not the final pass, and this insn is copying the\n \t     value of a library call and it's dead, don't scan the\n@@ -3452,8 +3458,7 @@ propagate_block (bb, live, local_set, flags)\n \t  if (libcall_is_dead)\n \t    {\n \t      /* Record the death of the dest reg.  */\n-\t      mark_set_regs (&pbi, tmp, PATTERN (insn), insn);\n-\t      AND_COMPL_REG_SET (pbi.reg_live, tmp);\n+\t      mark_set_regs (&pbi, PATTERN (insn), insn);\n \n \t      insn = XEXP (note, 0);\n \t      prev = PREV_INSN (insn);\n@@ -3482,16 +3487,28 @@ propagate_block (bb, live, local_set, flags)\n \t      /* Record sets.  Do this even for dead instructions,\n \t\t since they would have killed the values if they hadn't\n \t\t been deleted.  */\n-\t      mark_set_regs (&pbi, tmp, PATTERN (insn), insn);\n+\t      mark_set_regs (&pbi, PATTERN (insn), insn);\n \n-\t      /* Each call clobbers all call-clobbered regs that are not\n-\t\t global or fixed.  Note that the function-value reg is a\n-\t\t call-clobbered reg, and mark_set_regs has already had\n-\t\t a chance to handle it.  */\n-\t      if (GET_CODE (insn) == CALL_INSN)\n+\t      /* If an insn doesn't use CC0, it becomes dead since we \n+\t\t assume that every insn clobbers it.  So show it dead here;\n+\t\t mark_used_regs will set it live if it is referenced.  */\n+\t      pbi.cc0_live = 0;\n+\n+\t      /* Record uses.  */\n+\t      if (! insn_is_dead)\n+\t\tmark_used_regs (&pbi, PATTERN (insn), NULL_RTX, insn);\n+\n+\t      /* Sometimes we may have inserted something before INSN\n+\t\t (such as a move) when we make an auto-inc.  So ensure\n+\t\t we will scan those insns.  */\n+#ifdef AUTO_INC_DEC\n+\t      prev = PREV_INSN (insn);\n+#endif\n+\n+\t      if (! insn_is_dead && GET_CODE (insn) == CALL_INSN)\n \t\t{\n \t\t  register int i;\n-\t\t  rtx cond;\n+\t\t  rtx note, cond;\n \n \t\t  cond = NULL_RTX;\n \t\t  if (GET_CODE (PATTERN (insn)) == COND_EXEC)\n@@ -3506,7 +3523,7 @@ propagate_block (bb, live, local_set, flags)\n \t\t       note;\n \t\t       note = XEXP (note, 1))\n \t\t    if (GET_CODE (XEXP (note, 0)) == CLOBBER)\n-\t\t      mark_set_1 (&pbi, tmp, XEXP (XEXP (note, 0), 0),\n+\t\t      mark_set_1 (&pbi, XEXP (XEXP (note, 0), 0),\n \t\t\t\t  cond, insn);\n \n \t\t  /* Calls change all call-used and global registers.  */\n@@ -3515,64 +3532,34 @@ propagate_block (bb, live, local_set, flags)\n \t\t\t&& ! fixed_regs[i])\n \t\t      {\n \t\t\tint dummy;\n-\t\t        mark_set_reg (&pbi, tmp,\n-\t\t\t\t      gen_rtx_REG (reg_raw_mode[i], i),\n+\t\t        mark_set_reg (&pbi, gen_rtx_REG (reg_raw_mode[i], i),\n \t\t\t\t      cond, &dummy, &dummy);\n \t\t      }\n-\t\t}\n-\n-\t      /* Update live for the registers killed.  */\n-\t      AND_COMPL_REG_SET (pbi.reg_live, tmp);\n-\t      CLEAR_REG_SET (tmp);\n-\n-\t      /* If an insn doesn't use CC0, it becomes dead since we \n-\t\t assume that every insn clobbers it.  So show it dead here;\n-\t\t mark_used_regs will set it live if it is referenced.  */\n-\t      pbi.cc0_live = 0;\n-\n-\t      /* Record uses.  */\n-\t      if (! insn_is_dead)\n-\t\tmark_used_regs (&pbi, tmp, PATTERN (insn), NULL_RTX, insn);\n-\n-\t      /* Sometimes we may have inserted something before INSN\n-\t\t (such as a move) when we make an auto-inc.  So ensure\n-\t\t we will scan those insns.  */\n-#ifdef AUTO_INC_DEC\n-\t      prev = PREV_INSN (insn);\n-#endif\n-\n-\t      if (! insn_is_dead && GET_CODE (insn) == CALL_INSN)\n-\t\t{\n-\t\t  register int i;\n-\t\t  rtx note, cond;\n-\n-\t\t  cond = NULL_RTX;\n-\t\t  if (GET_CODE (PATTERN (insn)) == COND_EXEC)\n-\t\t    cond = COND_EXEC_TEST (PATTERN (insn));\n \n+\t\t  /* Calls use their arguments.  */\n \t          for (note = CALL_INSN_FUNCTION_USAGE (insn);\n \t\t       note;\n \t\t       note = XEXP (note, 1))\n \t\t    if (GET_CODE (XEXP (note, 0)) == USE)\n-\t\t      mark_used_regs (&pbi, tmp, XEXP (XEXP (note, 0), 0),\n+\t\t      mark_used_regs (&pbi, XEXP (XEXP (note, 0), 0),\n \t\t\t\t      cond, insn);\n \n \t\t  /* The stack ptr is used (honorarily) by a CALL insn.  */\n-\t\t  SET_REGNO_REG_SET (tmp, STACK_POINTER_REGNUM);\n+\t\t  SET_REGNO_REG_SET (pbi.new_live, STACK_POINTER_REGNUM);\n \n \t\t  /* Calls may also reference any of the global registers,\n \t\t     so they are made live.  */\n \t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t\t    if (global_regs[i])\n-\t\t      mark_used_reg (&pbi, tmp,\n-\t\t\t\t     gen_rtx_REG (reg_raw_mode[i], i),\n+\t\t      mark_used_reg (&pbi, gen_rtx_REG (reg_raw_mode[i], i),\n \t\t\t\t     cond, insn);\n \t\t}\n-\n-\t      /* Update live for the registers used.  */\n-\t      IOR_REG_SET (pbi.reg_live, tmp);\n \t    }\n \n+\t  /* Update reg_live for the registers killed and used.  */\n+\t  AND_COMPL_REG_SET (pbi.reg_live, pbi.new_dead);\n+\t  IOR_REG_SET (pbi.reg_live, pbi.new_live);\n+\n \t  /* On final pass, update counts of how many insns in which\n \t     each reg is live.  */\n \t  if (flags & PROP_REG_INFO)\n@@ -3584,7 +3571,8 @@ propagate_block (bb, live, local_set, flags)\n \tbreak;\n     }\n \n-  FREE_REG_SET (tmp);\n+  FREE_REG_SET (pbi.new_live);\n+  FREE_REG_SET (pbi.new_dead);\n   free_EXPR_LIST_list (&pbi.mem_set_list);\n \n   if (pbi.reg_next_use)\n@@ -3905,9 +3893,8 @@ invalidate_mems_from_autoinc (pbi, insn)\n    FLAGS is the set of operations to perform.  */\n \n static void\n-mark_set_regs (pbi, new_dead, x, insn)\n+mark_set_regs (pbi, x, insn)\n      struct propagate_block_info *pbi;\n-     regset new_dead;\n      rtx x, insn;\n {\n   rtx cond = NULL_RTX;\n@@ -3917,7 +3904,7 @@ mark_set_regs (pbi, new_dead, x, insn)\n     {\n     case SET:\n     case CLOBBER:\n-      mark_set_1 (pbi, new_dead, SET_DEST (x), cond, insn);\n+      mark_set_1 (pbi, SET_DEST (x), cond, insn);\n       return;\n \n     case COND_EXEC:\n@@ -3945,7 +3932,7 @@ mark_set_regs (pbi, new_dead, x, insn)\n \n \t      case SET:\n \t      case CLOBBER:\n-\t\tmark_set_1 (pbi, new_dead, SET_DEST (sub), cond, insn);\n+\t\tmark_set_1 (pbi, SET_DEST (sub), cond, insn);\n \t\tbreak;\n \n \t      default:\n@@ -3963,9 +3950,8 @@ mark_set_regs (pbi, new_dead, x, insn)\n /* Process a single SET rtx, X.  */\n \n static void\n-mark_set_1 (pbi, new_dead, reg, cond, insn)\n+mark_set_1 (pbi, reg, cond, insn)\n      struct propagate_block_info *pbi;\n-     regset new_dead;\n      rtx reg, cond, insn;\n {\n   register int regno = -1;\n@@ -3980,21 +3966,25 @@ mark_set_1 (pbi, new_dead, reg, cond, insn)\n       register int i;\n \n       for (i = XVECLEN (reg, 0) - 1; i >= 0; i--)\n-\tmark_set_1 (pbi, new_dead, XVECEXP (reg, 0, i), cond, insn);\n+\tmark_set_1 (pbi, XVECEXP (reg, 0, i), cond, insn);\n       return;\n     }\n \n-  /* Modifying just one hardware register of a multi-reg value\n-     or just a byte field of a register\n-     does not mean the value from before this insn is now dead.\n-     But it does mean liveness of that register at the end of the block\n-     is significant.\n+  /* Modifying just one hardware register of a multi-reg value or just a\n+     byte field of a register does not mean the value from before this insn\n+     is now dead.  But it does mean liveness of that register at the end of\n+     the block is significant.\n+\n+     Within mark_set_1, however, we treat it as if the register is indeed\n+     modified.  mark_used_regs will, however, also treat this register as\n+     being used.  Thus, we treat these insns as setting a new value for the\n+     register as a function of its old value.  This cases LOG_LINKS to be\n+     made appropriately and this will help combine. \n \n-     Within mark_set_1, however, we treat it as if the register is\n-     indeed modified.  mark_used_regs will, however, also treat this\n-     register as being used.  Thus, we treat these insns as setting a\n-     new value for the register as a function of its old value.  This\n-     cases LOG_LINKS to be made appropriately and this will help combine.  */\n+     ??? This is all done incorrectly.  We should not be setting bits in\n+     new_dead for these registers, since, as we just explained, they are\n+     not dead.  We should be setting bits in local_set, and updating\n+     LOG_LINKS, but that is different.  */\n \n   while (GET_CODE (reg) == SUBREG || GET_CODE (reg) == ZERO_EXTRACT\n \t || GET_CODE (reg) == SIGN_EXTRACT\n@@ -4065,8 +4055,7 @@ mark_set_1 (pbi, new_dead, reg, cond, insn)\n       int some_was_live, some_was_dead;\n \n       /* Perform the pbi datastructure update.  */\n-      if (! mark_set_reg (pbi, new_dead, reg, cond,\n-\t\t\t  &some_was_live, &some_was_dead))\n+      if (! mark_set_reg (pbi, reg, cond, &some_was_live, &some_was_dead))\n \treturn;\n \n       /* Additional data to record if this is the final pass.  */\n@@ -4210,9 +4199,8 @@ mark_set_1 (pbi, new_dead, reg, cond, insn)\n    Return true if REG is now unconditionally dead.  */\n \n static int\n-mark_set_reg (pbi, new_dead, reg, cond, p_some_was_live, p_some_was_dead)\n+mark_set_reg (pbi, reg, cond, p_some_was_live, p_some_was_dead)\n      struct propagate_block_info *pbi;\n-     regset new_dead;\n      rtx reg;\n      rtx cond ATTRIBUTE_UNUSED;\n      int *p_some_was_live, *p_some_was_dead;\n@@ -4252,12 +4240,12 @@ mark_set_reg (pbi, new_dead, reg, cond, p_some_was_live, p_some_was_dead)\n     return 0;\n \n   /* Mark it as dead before this insn.  */\n-  SET_REGNO_REG_SET (new_dead, regno);\n+  SET_REGNO_REG_SET (pbi->new_dead, regno);\n   if (regno < FIRST_PSEUDO_REGISTER)\n     {\n       int n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n       while (--n > 0)\n-\tSET_REGNO_REG_SET (new_dead, regno + n);\n+\tSET_REGNO_REG_SET (pbi->new_dead, regno + n);\n     }\n \n   /* Unconditionally dead.  */\n@@ -4444,9 +4432,8 @@ find_auto_inc (pbi, x, insn)\n #endif /* AUTO_INC_DEC */\n \f\n static void\n-mark_used_reg (pbi, new_live, reg, cond, insn)\n+mark_used_reg (pbi, reg, cond, insn)\n      struct propagate_block_info *pbi;\n-     regset new_live;\n      rtx reg;\n      rtx cond ATTRIBUTE_UNUSED;\n      rtx insn;\n@@ -4455,7 +4442,7 @@ mark_used_reg (pbi, new_live, reg, cond, insn)\n   int some_was_live = REGNO_REG_SET_P (pbi->reg_live, regno);\n   int some_was_dead = ! some_was_live;\n \n-  SET_REGNO_REG_SET (new_live, regno);\n+  SET_REGNO_REG_SET (pbi->new_live, regno);\n \n   /* A hard reg in a wide mode may really be multiple registers.\n      If so, mark all of them just like the first.  */\n@@ -4467,7 +4454,7 @@ mark_used_reg (pbi, new_live, reg, cond, insn)\n \t  int regno_n = regno + n;\n \t  int needed_regno = REGNO_REG_SET_P (pbi->reg_live, regno_n);\n \n-\t  SET_REGNO_REG_SET (new_live, regno_n);\n+\t  SET_REGNO_REG_SET (pbi->new_live, regno_n);\n \t  some_was_live |= needed_regno;\n \t  some_was_dead |= ! needed_regno;\n \t}\n@@ -4520,17 +4507,24 @@ mark_used_reg (pbi, new_live, reg, cond, insn)\n \n   /* Record and count the insns in which a reg dies.  If it is used in\n      this insn and was dead below the insn then it dies in this insn.\n-\n      If it was set in this insn, we do not make a REG_DEAD note;\n-     likewise if we already made such a note.  Recall that dead_or_set_p\n-     checks for complete overlap, and thus is not suitable for the first\n-     case.  But it does handle the existing note case.  Also recall that\n-     reg_set_p, when presented with the complete insn, will try to infer\n-     things about a call_insn that we do not wish.  */\n+     likewise if we already made such a note. \n+\n+     ??? This could be done better.  In new_dead we have a record of \n+     which registers are set or clobbered this insn (which in itself is\n+     slightly incorrect, see the commentary near strict_low_part in\n+     mark_set_1), which should be the set of registers that we do not\n+     wish to create death notes for under the above rule.  Note that\n+     we have not yet processed the call-clobbered/call-used registers,\n+     and they do not quite follow the above rule, since we do want death\n+     notes for call-clobbered register arguments.  Which begs the whole\n+     question of whether we should in fact have death notes for registers\n+     used and clobbered (but not set) in the same insn.  The only useful\n+     thing we ought to be getting from dead_or_set_p is detection of\n+     duplicate death notes.  */\n \n   if ((pbi->flags & PROP_DEATH_NOTES)\n       && some_was_dead\n-      && ! reg_set_p (reg, PATTERN (insn))\n       && ! dead_or_set_p (insn, reg))\n     {\n       int n;\n@@ -4578,9 +4572,8 @@ mark_used_reg (pbi, new_live, reg, cond, insn)\n    is not called.  */\n \n static void\n-mark_used_regs (pbi, new_live, x, cond, insn)\n+mark_used_regs (pbi, x, cond, insn)\n      struct propagate_block_info *pbi;\n-     regset new_live;\n      rtx x, cond, insn;\n {\n   register RTX_CODE code;\n@@ -4611,7 +4604,7 @@ mark_used_regs (pbi, new_live, x, cond, insn)\n       /* If we are clobbering a MEM, mark any registers inside the address\n \t as being used.  */\n       if (GET_CODE (XEXP (x, 0)) == MEM)\n-\tmark_used_regs (pbi, new_live, XEXP (XEXP (x, 0), 0), cond, insn);\n+\tmark_used_regs (pbi, XEXP (XEXP (x, 0), 0), cond, insn);\n       return;\n \n     case MEM:\n@@ -4676,7 +4669,7 @@ mark_used_regs (pbi, new_live, x, cond, insn)\n \n     case REG:\n       /* See a register other than being set => mark it as needed.  */\n-      mark_used_reg (pbi, new_live, x, cond, insn);\n+      mark_used_reg (pbi, x, cond, insn);\n       return;\n \n     case SET:\n@@ -4692,8 +4685,8 @@ mark_used_regs (pbi, new_live, x, cond, insn)\n \t    if (flags & PROP_AUTOINC)\n \t      find_auto_inc (pbi, testreg, insn);\n #endif\n-\t    mark_used_regs (pbi, new_live, XEXP (testreg, 0), cond, insn);\n-\t    mark_used_regs (pbi, new_live, SET_SRC (x), cond, insn);\n+\t    mark_used_regs (pbi, XEXP (testreg, 0), cond, insn);\n+\t    mark_used_regs (pbi, SET_SRC (x), cond, insn);\n \t    return;\n \t  }\n \t    \n@@ -4745,12 +4738,10 @@ mark_used_regs (pbi, new_live, x, cond, insn)\n \t\t&& ! (regno == ARG_POINTER_REGNUM && fixed_regs[regno])\n #endif\n \t\t))\n-\t  /* We used to exclude global_regs here, but that seems wrong.\n-\t     Storing in them is like storing in mem.  */\n \t  {\n-\t    mark_used_regs (pbi, new_live, SET_SRC (x), cond, insn);\n \t    if (mark_dest)\n-\t      mark_used_regs (pbi, new_live, SET_DEST (x), cond, insn);\n+\t      mark_used_regs (pbi, SET_DEST (x), cond, insn);\n+\t    mark_used_regs (pbi, SET_SRC (x), cond, insn);\n \t    return;\n \t  }\n       }\n@@ -4787,8 +4778,7 @@ mark_used_regs (pbi, new_live, x, cond, insn)\n \t    int j;\n \n \t    for (j = 0; j < ASM_OPERANDS_INPUT_LENGTH (x); j++)\n-\t      mark_used_regs (pbi, new_live, ASM_OPERANDS_INPUT (x, j),\n-\t\t\t      cond, insn);\n+\t      mark_used_regs (pbi, ASM_OPERANDS_INPUT (x, j), cond, insn);\n \t  }\n \tbreak;\n       }\n@@ -4797,7 +4787,7 @@ mark_used_regs (pbi, new_live, x, cond, insn)\n       if (cond != NULL_RTX)\n \tabort ();\n \n-      mark_used_regs (pbi, new_live, COND_EXEC_TEST (x), NULL_RTX, insn);\n+      mark_used_regs (pbi, COND_EXEC_TEST (x), NULL_RTX, insn);\n \n       cond = COND_EXEC_TEST (x);\n       x = COND_EXEC_CODE (x);\n@@ -4831,13 +4821,13 @@ mark_used_regs (pbi, new_live, x, cond, insn)\n \t\tx = XEXP (x, 0);\n \t\tgoto retry;\n \t      }\n-\t    mark_used_regs (pbi, new_live, XEXP (x, i), cond, insn);\n+\t    mark_used_regs (pbi, XEXP (x, i), cond, insn);\n \t  }\n \telse if (fmt[i] == 'E')\n \t  {\n \t    register int j;\n \t    for (j = 0; j < XVECLEN (x, i); j++)\n-\t      mark_used_regs (pbi, new_live, XVECEXP (x, i, j), cond, insn);\n+\t      mark_used_regs (pbi, XVECEXP (x, i, j), cond, insn);\n \t  }\n       }\n   }"}]}