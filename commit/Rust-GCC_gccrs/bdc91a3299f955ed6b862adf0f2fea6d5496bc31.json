{"sha": "bdc91a3299f955ed6b862adf0f2fea6d5496bc31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRjOTFhMzI5OWY5NTVlZDZiODYyYWRmMGYyZmVhNmQ1NDk2YmMzMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-09-12T12:48:43Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-09-12T12:48:43Z"}, "message": "re PR tree-optimization/91750 (Induction vectorization introduces signed overflows)\n\n2019-09-12  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/91750\n\t* tree-vect-loop.c (vectorizable_induction): Compute IV increments\n\tin the type of the evolution.\n\n\t* gcc.dg/vect/pr91750.c: New testcase.\n\nFrom-SVN: r275685", "tree": {"sha": "f2c9d12477a656f7eb9eb58f6bf0675542611051", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2c9d12477a656f7eb9eb58f6bf0675542611051"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdc91a3299f955ed6b862adf0f2fea6d5496bc31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdc91a3299f955ed6b862adf0f2fea6d5496bc31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdc91a3299f955ed6b862adf0f2fea6d5496bc31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdc91a3299f955ed6b862adf0f2fea6d5496bc31/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "52f6afe06dd86a25b41688ad12dd124b23f27833", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52f6afe06dd86a25b41688ad12dd124b23f27833", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52f6afe06dd86a25b41688ad12dd124b23f27833"}], "stats": {"total": 118, "additions": 77, "deletions": 41}, "files": [{"sha": "e91cba1b1241bd95129e7c74bc4646c0fa85e09e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdc91a3299f955ed6b862adf0f2fea6d5496bc31/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdc91a3299f955ed6b862adf0f2fea6d5496bc31/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bdc91a3299f955ed6b862adf0f2fea6d5496bc31", "patch": "@@ -1,3 +1,9 @@\n+2019-09-12  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/91750\n+\t* tree-vect-loop.c (vectorizable_induction): Compute IV increments\n+\tin the type of the evolution.\n+\n 2019-09-12  Yuliang Wang  <yuliang.wang@arm.com>\n \n \tPR tree-optimization/89386"}, {"sha": "8d82d65b025cc7dfbe46f44db1dee5357e3666f6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdc91a3299f955ed6b862adf0f2fea6d5496bc31/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdc91a3299f955ed6b862adf0f2fea6d5496bc31/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bdc91a3299f955ed6b862adf0f2fea6d5496bc31", "patch": "@@ -1,3 +1,8 @@\n+2019-09-12  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/91750\n+\t* gcc.dg/vect/pr91750.c: New testcase.\n+\n 2019-09-11  Sandra Loosemore  <sandra@codesourcery.com>\n \n \tPR testsuite/83889"}, {"sha": "fe914b2d93954fbc2514df2afc140063de20217b", "filename": "gcc/testsuite/gcc.dg/vect/pr91750.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdc91a3299f955ed6b862adf0f2fea6d5496bc31/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr91750.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdc91a3299f955ed6b862adf0f2fea6d5496bc31/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr91750.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr91750.c?ref=bdc91a3299f955ed6b862adf0f2fea6d5496bc31", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+int val[1024];\n+void\n+foo (int n)\n+{\n+  int i;\n+  for (int j = 0, i = n; j < 1024; ++j, i=(unsigned)i+1)\n+    val[j] = i;\n+}\n+\n+/* Make sure the induction IV uses an unsigned increment.  */\n+/* { dg-final { scan-tree-dump \"vector\\\\\\(\\[0-9\\]*\\\\\\) unsigned int\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"LOOP VECTORIZED\" \"vect\" } } */"}, {"sha": "d8546ff8935ae29dd2366ef7450bc1b1a3fdc95a", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 51, "deletions": 41, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdc91a3299f955ed6b862adf0f2fea6d5496bc31/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdc91a3299f955ed6b862adf0f2fea6d5496bc31/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=bdc91a3299f955ed6b862adf0f2fea6d5496bc31", "patch": "@@ -7605,6 +7605,7 @@ vectorizable_induction (stmt_vec_info stmt_info,\n \n   step_expr = STMT_VINFO_LOOP_PHI_EVOLUTION_PART (stmt_info);\n   gcc_assert (step_expr != NULL_TREE);\n+  tree step_vectype = get_same_sized_vectype (TREE_TYPE (step_expr), vectype);\n \n   pe = loop_preheader_edge (iv_loop);\n   init_expr = PHI_ARG_DEF_FROM_EDGE (phi,\n@@ -7613,8 +7614,8 @@ vectorizable_induction (stmt_vec_info stmt_info,\n   stmts = NULL;\n   if (!nested_in_vect_loop)\n     {\n-      /* Convert the initial value to the desired type.  */\n-      tree new_type = TREE_TYPE (vectype);\n+      /* Convert the initial value to the IV update type.  */\n+      tree new_type = TREE_TYPE (step_expr);\n       init_expr = gimple_convert (&stmts, new_type, init_expr);\n \n       /* If we are using the loop mask to \"peel\" for alignment then we need\n@@ -7634,9 +7635,6 @@ vectorizable_induction (stmt_vec_info stmt_info,\n \t}\n     }\n \n-  /* Convert the step to the desired type.  */\n-  step_expr = gimple_convert (&stmts, TREE_TYPE (vectype), step_expr);\n-\n   if (stmts)\n     {\n       new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n@@ -7669,8 +7667,8 @@ vectorizable_induction (stmt_vec_info stmt_info,\n       if (! CONSTANT_CLASS_P (new_name))\n \tnew_name = vect_init_vector (stmt_info, new_name,\n \t\t\t\t     TREE_TYPE (step_expr), NULL);\n-      new_vec = build_vector_from_val (vectype, new_name);\n-      vec_step = vect_init_vector (stmt_info, new_vec, vectype, NULL);\n+      new_vec = build_vector_from_val (step_vectype, new_name);\n+      vec_step = vect_init_vector (stmt_info, new_vec, step_vectype, NULL);\n \n       /* Now generate the IVs.  */\n       unsigned group_size = SLP_TREE_SCALAR_STMTS (slp_node).length ();\n@@ -7683,7 +7681,7 @@ vectorizable_induction (stmt_vec_info stmt_info,\n       unsigned ivn;\n       for (ivn = 0; ivn < nivs; ++ivn)\n \t{\n-\t  tree_vector_builder elts (vectype, const_nunits, 1);\n+\t  tree_vector_builder elts (step_vectype, const_nunits, 1);\n \t  stmts = NULL;\n \t  for (unsigned eltn = 0; eltn < const_nunits; ++eltn)\n \t    {\n@@ -7694,6 +7692,7 @@ vectorizable_induction (stmt_vec_info stmt_info,\n \t      elts.quick_push (elt);\n \t    }\n \t  vec_init = gimple_build_vector (&stmts, &elts);\n+\t  vec_init = gimple_convert (&stmts, vectype, vec_init);\n \t  if (stmts)\n \t    {\n \t      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n@@ -7708,10 +7707,13 @@ vectorizable_induction (stmt_vec_info stmt_info,\n \t  induc_def = PHI_RESULT (induction_phi);\n \n \t  /* Create the iv update inside the loop  */\n-\t  vec_def = make_ssa_name (vec_dest);\n-\t  new_stmt = gimple_build_assign (vec_def, PLUS_EXPR, induc_def, vec_step);\n-\t  gsi_insert_before (&si, new_stmt, GSI_SAME_STMT);\n-\t  loop_vinfo->add_stmt (new_stmt);\n+\t  gimple_seq stmts = NULL;\n+\t  vec_def = gimple_convert (&stmts, step_vectype, induc_def);\n+\t  vec_def = gimple_build (&stmts,\n+\t\t\t\t  PLUS_EXPR, step_vectype, vec_def, vec_step);\n+\t  vec_def = gimple_convert (&stmts, vectype, vec_def);\n+\t  loop_vinfo->add_stmt (SSA_NAME_DEF_STMT (vec_def));\n+\t  gsi_insert_seq_before (&si, stmts, GSI_SAME_STMT);\n \n \t  /* Set the arguments of the phi node:  */\n \t  add_phi_arg (induction_phi, vec_init, pe, UNKNOWN_LOCATION);\n@@ -7739,8 +7741,8 @@ vectorizable_induction (stmt_vec_info stmt_info,\n \t  if (! CONSTANT_CLASS_P (new_name))\n \t    new_name = vect_init_vector (stmt_info, new_name,\n \t\t\t\t\t TREE_TYPE (step_expr), NULL);\n-\t  new_vec = build_vector_from_val (vectype, new_name);\n-\t  vec_step = vect_init_vector (stmt_info, new_vec, vectype, NULL);\n+\t  new_vec = build_vector_from_val (step_vectype, new_name);\n+\t  vec_step = vect_init_vector (stmt_info, new_vec, step_vectype, NULL);\n \t  for (; ivn < nvects; ++ivn)\n \t    {\n \t      gimple *iv = SLP_TREE_VEC_STMTS (slp_node)[ivn - nivs]->stmt;\n@@ -7749,18 +7751,20 @@ vectorizable_induction (stmt_vec_info stmt_info,\n \t\tdef = gimple_phi_result (iv);\n \t      else\n \t\tdef = gimple_assign_lhs (iv);\n-\t      new_stmt = gimple_build_assign (make_ssa_name (vectype),\n-\t\t\t\t\t      PLUS_EXPR,\n-\t\t\t\t\t      def, vec_step);\n+\t      gimple_seq stmts = NULL;\n+\t      def = gimple_convert (&stmts, step_vectype, def);\n+\t      def = gimple_build (&stmts,\n+\t\t\t\t  PLUS_EXPR, step_vectype, def, vec_step);\n+\t      def = gimple_convert (&stmts, vectype, def);\n \t      if (gimple_code (iv) == GIMPLE_PHI)\n-\t\tgsi_insert_before (&si, new_stmt, GSI_SAME_STMT);\n+\t\tgsi_insert_seq_before (&si, stmts, GSI_SAME_STMT);\n \t      else\n \t\t{\n \t\t  gimple_stmt_iterator tgsi = gsi_for_stmt (iv);\n-\t\t  gsi_insert_after (&tgsi, new_stmt, GSI_CONTINUE_LINKING);\n+\t\t  gsi_insert_seq_after (&tgsi, stmts, GSI_CONTINUE_LINKING);\n \t\t}\n \t      SLP_TREE_VEC_STMTS (slp_node).quick_push\n-\t\t(loop_vinfo->add_stmt (new_stmt));\n+\t\t(loop_vinfo->add_stmt (SSA_NAME_DEF_STMT (def)));\n \t    }\n \t}\n \n@@ -7796,12 +7800,12 @@ vectorizable_induction (stmt_vec_info stmt_info,\n       /* iv_loop is the loop to be vectorized. Create:\n \t vec_init = [X, X+S, X+2*S, X+3*S] (S = step_expr, X = init_expr)  */\n       stmts = NULL;\n-      new_name = gimple_convert (&stmts, TREE_TYPE (vectype), init_expr);\n+      new_name = gimple_convert (&stmts, TREE_TYPE (step_expr), init_expr);\n \n       unsigned HOST_WIDE_INT const_nunits;\n       if (nunits.is_constant (&const_nunits))\n \t{\n-\t  tree_vector_builder elts (vectype, const_nunits, 1);\n+\t  tree_vector_builder elts (step_vectype, const_nunits, 1);\n \t  elts.quick_push (new_name);\n \t  for (i = 1; i < const_nunits; i++)\n \t    {\n@@ -7816,7 +7820,7 @@ vectorizable_induction (stmt_vec_info stmt_info,\n \t}\n       else if (INTEGRAL_TYPE_P (TREE_TYPE (step_expr)))\n \t/* Build the initial value directly from a VEC_SERIES_EXPR.  */\n-\tvec_init = gimple_build (&stmts, VEC_SERIES_EXPR, vectype,\n+\tvec_init = gimple_build (&stmts, VEC_SERIES_EXPR, step_vectype,\n \t\t\t\t new_name, step_expr);\n       else\n \t{\n@@ -7825,17 +7829,18 @@ vectorizable_induction (stmt_vec_info stmt_info,\n \t\t+ (vectype) [0, 1, 2, ...] * [step, step, step, ...].  */\n \t  gcc_assert (SCALAR_FLOAT_TYPE_P (TREE_TYPE (step_expr)));\n \t  gcc_assert (flag_associative_math);\n-\t  tree index = build_index_vector (vectype, 0, 1);\n-\t  tree base_vec = gimple_build_vector_from_val (&stmts, vectype,\n+\t  tree index = build_index_vector (step_vectype, 0, 1);\n+\t  tree base_vec = gimple_build_vector_from_val (&stmts, step_vectype,\n \t\t\t\t\t\t\tnew_name);\n-\t  tree step_vec = gimple_build_vector_from_val (&stmts, vectype,\n+\t  tree step_vec = gimple_build_vector_from_val (&stmts, step_vectype,\n \t\t\t\t\t\t\tstep_expr);\n-\t  vec_init = gimple_build (&stmts, FLOAT_EXPR, vectype, index);\n-\t  vec_init = gimple_build (&stmts, MULT_EXPR, vectype,\n+\t  vec_init = gimple_build (&stmts, FLOAT_EXPR, step_vectype, index);\n+\t  vec_init = gimple_build (&stmts, MULT_EXPR, step_vectype,\n \t\t\t\t   vec_init, step_vec);\n-\t  vec_init = gimple_build (&stmts, PLUS_EXPR, vectype,\n+\t  vec_init = gimple_build (&stmts, PLUS_EXPR, step_vectype,\n \t\t\t\t   vec_init, base_vec);\n \t}\n+      vec_init = gimple_convert (&stmts, vectype, vec_init);\n \n       if (stmts)\n \t{\n@@ -7874,8 +7879,8 @@ vectorizable_induction (stmt_vec_info stmt_info,\n   t = unshare_expr (new_name);\n   gcc_assert (CONSTANT_CLASS_P (new_name)\n \t      || TREE_CODE (new_name) == SSA_NAME);\n-  new_vec = build_vector_from_val (vectype, t);\n-  vec_step = vect_init_vector (stmt_info, new_vec, vectype, NULL);\n+  new_vec = build_vector_from_val (step_vectype, t);\n+  vec_step = vect_init_vector (stmt_info, new_vec, step_vectype, NULL);\n \n \n   /* Create the following def-use cycle:\n@@ -7896,9 +7901,12 @@ vectorizable_induction (stmt_vec_info stmt_info,\n   induc_def = PHI_RESULT (induction_phi);\n \n   /* Create the iv update inside the loop  */\n-  vec_def = make_ssa_name (vec_dest);\n-  new_stmt = gimple_build_assign (vec_def, PLUS_EXPR, induc_def, vec_step);\n-  gsi_insert_before (&si, new_stmt, GSI_SAME_STMT);\n+  stmts = NULL;\n+  vec_def = gimple_convert (&stmts, step_vectype, induc_def);\n+  vec_def = gimple_build (&stmts, PLUS_EXPR, step_vectype, vec_def, vec_step);\n+  vec_def = gimple_convert (&stmts, vectype, vec_def);\n+  gsi_insert_seq_before (&si, stmts, GSI_SAME_STMT);\n+  new_stmt = SSA_NAME_DEF_STMT (vec_def);\n   stmt_vec_info new_stmt_info = loop_vinfo->add_stmt (new_stmt);\n \n   /* Set the arguments of the phi node:  */\n@@ -7940,20 +7948,22 @@ vectorizable_induction (stmt_vec_info stmt_info,\n       t = unshare_expr (new_name);\n       gcc_assert (CONSTANT_CLASS_P (new_name)\n \t\t  || TREE_CODE (new_name) == SSA_NAME);\n-      new_vec = build_vector_from_val (vectype, t);\n-      vec_step = vect_init_vector (stmt_info, new_vec, vectype, NULL);\n+      new_vec = build_vector_from_val (step_vectype, t);\n+      vec_step = vect_init_vector (stmt_info, new_vec, step_vectype, NULL);\n \n       vec_def = induc_def;\n       prev_stmt_vinfo = induction_phi_info;\n       for (i = 1; i < ncopies; i++)\n \t{\n \t  /* vec_i = vec_prev + vec_step  */\n-\t  new_stmt = gimple_build_assign (vec_dest, PLUS_EXPR,\n-\t\t\t\t\t  vec_def, vec_step);\n-\t  vec_def = make_ssa_name (vec_dest, new_stmt);\n-\t  gimple_assign_set_lhs (new_stmt, vec_def);\n+\t  gimple_seq stmts = NULL;\n+\t  vec_def = gimple_convert (&stmts, step_vectype, vec_def);\n+\t  vec_def = gimple_build (&stmts,\n+\t\t\t\t  PLUS_EXPR, step_vectype, vec_def, vec_step);\n+\t  vec_def = gimple_convert (&stmts, vectype, vec_def);\n  \n-\t  gsi_insert_before (&si, new_stmt, GSI_SAME_STMT);\n+\t  gsi_insert_seq_before (&si, stmts, GSI_SAME_STMT);\n+\t  new_stmt = SSA_NAME_DEF_STMT (vec_def);\n \t  new_stmt_info = loop_vinfo->add_stmt (new_stmt);\n \t  STMT_VINFO_RELATED_STMT (prev_stmt_vinfo) = new_stmt_info;\n \t  prev_stmt_vinfo = new_stmt_info;"}]}