{"sha": "00efe3ea3c907b4d7b090da19add210432b3de2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBlZmUzZWEzYzkwN2I0ZDdiMDkwZGExOWFkZDIxMDQzMmIzZGUyYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-11-28T20:13:22Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-11-28T20:13:22Z"}, "message": "re PR middle-end/55438 (tmpdir-gcc.dg-struct-layout-1/t001 - t028,  gcc.c-torture/execute/991118-1.c, gcc.c-torture/execute/bf64-1.c, ICE)\n\ngcc/\n\tPR middle-end/55438\n\t* expmed.c (simple_mem_bitfield_p): New function, extracted from\n\tstore_bit_field_1 and extract_bit_field_1.  Use GET_MODE_ALIGNMENT\n\trather than bitsize when checking the alignment.\n\t(store_bit_field_1, extract_bit_field_1): Call it.\n\t* stor-layout.c (bit_field_mode_iterator::bit_field_mode_iterator):\n\tDon't limit ALIGN_.  Assume that memory is mapped in chunks of at\n\tleast word size, regardless of BIGGEST_ALIGNMENT.\n\t(bit_field_mode_iterator::get_mode): Use GET_MODE_ALIGNMENT rather\n\tthan unit when checking the alignment.\n\t(get_best_mode): Use GET_MODE_ALIGNMENT.\n\nFrom-SVN: r193905", "tree": {"sha": "aaafc068a028daa1ab2ecddaa3afa63e83019d13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aaafc068a028daa1ab2ecddaa3afa63e83019d13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00efe3ea3c907b4d7b090da19add210432b3de2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00efe3ea3c907b4d7b090da19add210432b3de2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00efe3ea3c907b4d7b090da19add210432b3de2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00efe3ea3c907b4d7b090da19add210432b3de2c/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1099bb0a712134f8a43e06407292aa95f27c0e54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1099bb0a712134f8a43e06407292aa95f27c0e54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1099bb0a712134f8a43e06407292aa95f27c0e54"}], "stats": {"total": 63, "additions": 43, "deletions": 20}, "files": [{"sha": "5350355484cab7a79aac2565be11740bc7dcdf53", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00efe3ea3c907b4d7b090da19add210432b3de2c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00efe3ea3c907b4d7b090da19add210432b3de2c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00efe3ea3c907b4d7b090da19add210432b3de2c", "patch": "@@ -1,3 +1,17 @@\n+2012-11-28  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\tPR middle-end/55438\n+\t* expmed.c (simple_mem_bitfield_p): New function, extracted from\n+\tstore_bit_field_1 and extract_bit_field_1.  Use GET_MODE_ALIGNMENT\n+\trather than bitsize when checking the alignment.\n+\t(store_bit_field_1, extract_bit_field_1): Call it.\n+\t* stor-layout.c (bit_field_mode_iterator::bit_field_mode_iterator):\n+\tDon't limit ALIGN_.  Assume that memory is mapped in chunks of at\n+\tleast word size, regardless of BIGGEST_ALIGNMENT.\n+\t(bit_field_mode_iterator::get_mode): Use GET_MODE_ALIGNMENT rather\n+\tthan unit when checking the alignment.\n+\t(get_best_mode): Use GET_MODE_ALIGNMENT.\n+\n 2012-11-28  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/55512"}, {"sha": "d75f031a8c377693c7cf54803568d224a80509c3", "filename": "gcc/expmed.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00efe3ea3c907b4d7b090da19add210432b3de2c/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00efe3ea3c907b4d7b090da19add210432b3de2c/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=00efe3ea3c907b4d7b090da19add210432b3de2c", "patch": "@@ -416,6 +416,21 @@ lowpart_bit_field_p (unsigned HOST_WIDE_INT bitnum,\n   else\n     return bitnum % BITS_PER_WORD == 0;\n }\n+\n+/* Return true if OP is a memory and if a bitfield of size BITSIZE at\n+   bit number BITNUM can be treated as a simple value of mode MODE.  */\n+\n+static bool\n+simple_mem_bitfield_p (rtx op0, unsigned HOST_WIDE_INT bitsize,\n+\t\t       unsigned HOST_WIDE_INT bitnum, enum machine_mode mode)\n+{\n+  return (MEM_P (op0)\n+\t  && bitnum % BITS_PER_UNIT == 0\n+\t  && bitsize == GET_MODE_BITSIZE (mode)\n+\t  && (!SLOW_UNALIGNED_ACCESS (mode, MEM_ALIGN (op0))\n+\t      || (bitnum % GET_MODE_ALIGNMENT (mode) == 0\n+\t\t  && MEM_ALIGN (op0) >= GET_MODE_ALIGNMENT (mode))));\n+}\n \f\n /* Try to use instruction INSV to store VALUE into a field of OP0.\n    BITSIZE and BITNUM are as for store_bit_field.  */\n@@ -624,12 +639,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   /* If the target is memory, storing any naturally aligned field can be\n      done with a simple store.  For targets that support fast unaligned\n      memory, any naturally sized, unit aligned field can be done directly.  */\n-  if (MEM_P (op0)\n-      && bitnum % BITS_PER_UNIT == 0\n-      && bitsize == GET_MODE_BITSIZE (fieldmode)\n-      && (!SLOW_UNALIGNED_ACCESS (fieldmode, MEM_ALIGN (op0))\n-\t  || (bitnum % bitsize == 0\n-\t      && MEM_ALIGN (op0) % bitsize == 0)))\n+  if (simple_mem_bitfield_p (op0, bitsize, bitnum, fieldmode))\n     {\n       op0 = adjust_bitfield_address (op0, fieldmode, bitnum / BITS_PER_UNIT);\n       emit_move_insn (op0, value);\n@@ -1455,12 +1465,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n   /* Extraction of a full MODE1 value can be done with a load as long as\n      the field is on a byte boundary and is sufficiently aligned.  */\n-  if (MEM_P (op0)\n-      && bitnum % BITS_PER_UNIT == 0\n-      && bitsize == GET_MODE_BITSIZE (mode1)\n-      && (!SLOW_UNALIGNED_ACCESS (mode1, MEM_ALIGN (op0))\n-\t  || (bitnum % bitsize == 0\n-\t      && MEM_ALIGN (op0) % bitsize == 0)))\n+  if (simple_mem_bitfield_p (op0, bitsize, bitnum, mode1))\n     {\n       op0 = adjust_bitfield_address (op0, mode1, bitnum / BITS_PER_UNIT);\n       return convert_extracted_bit_field (op0, mode, tmode, unsignedp);"}, {"sha": "3d97796da5c8e5b082adb4fb4d833d06a63b2e82", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00efe3ea3c907b4d7b090da19add210432b3de2c/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00efe3ea3c907b4d7b090da19add210432b3de2c/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=00efe3ea3c907b4d7b090da19add210432b3de2c", "patch": "@@ -2643,15 +2643,17 @@ ::bit_field_mode_iterator (HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t\t\t   unsigned int align, bool volatilep)\n : mode_ (GET_CLASS_NARROWEST_MODE (MODE_INT)), bitsize_ (bitsize),\n   bitpos_ (bitpos), bitregion_start_ (bitregion_start),\n-  bitregion_end_ (bitregion_end), align_ (MIN (align, BIGGEST_ALIGNMENT)),\n+  bitregion_end_ (bitregion_end), align_ (align),\n   volatilep_ (volatilep), count_ (0)\n {\n   if (!bitregion_end_)\n     {\n-      /* We can assume that any aligned chunk of ALIGN_ bits that overlaps\n+      /* We can assume that any aligned chunk of UNITS bits that overlaps\n \t the bitfield is mapped and won't trap.  */\n-      bitregion_end_ = bitpos + bitsize + align_ - 1;\n-      bitregion_end_ -= bitregion_end_ % align_ + 1;\n+      unsigned HOST_WIDE_INT units = MIN (align, MAX (BIGGEST_ALIGNMENT,\n+\t\t\t\t\t\t      BITS_PER_WORD));\n+      bitregion_end_ = bitpos + bitsize + units - 1;\n+      bitregion_end_ -= bitregion_end_ % units + 1;\n     }\n }\n \n@@ -2694,7 +2696,8 @@ bit_field_mode_iterator::next_mode (enum machine_mode *out_mode)\n \tbreak;\n \n       /* Stop if the mode requires too much alignment.  */\n-      if (unit > align_ && SLOW_UNALIGNED_ACCESS (mode_, align_))\n+      if (GET_MODE_ALIGNMENT (mode_) > align_\n+\t  && SLOW_UNALIGNED_ACCESS (mode_, align_))\n \tbreak;\n \n       *out_mode = mode_;\n@@ -2753,8 +2756,9 @@ get_best_mode (int bitsize, int bitpos,\n   enum machine_mode widest_mode = VOIDmode;\n   enum machine_mode mode;\n   while (iter.next_mode (&mode)\n-\t /* ??? For historical reasons, reject modes that are wider than\n-\t    the alignment.  This has both advantages and disadvantages.\n+\t /* ??? For historical reasons, reject modes that would normally\n+\t    receive greater alignment, even if unaligned accesses are\n+\t    acceptable.  This has both advantages and disadvantages.\n \t    Removing this check means that something like:\n \n \t       struct s { unsigned int x; unsigned int y; };\n@@ -2808,7 +2812,7 @@ get_best_mode (int bitsize, int bitpos,\n \t    causes store_bit_field to keep a 128-bit memory reference,\n \t    so that the final bitfield reference still has a MEM_EXPR\n \t    and MEM_OFFSET.  */\n-\t && GET_MODE_BITSIZE (mode) <= align\n+\t && GET_MODE_ALIGNMENT (mode) <= align\n \t && (largest_mode == VOIDmode\n \t     || GET_MODE_SIZE (mode) <= GET_MODE_SIZE (largest_mode)))\n     {"}]}