{"sha": "d01b568a78351beb6b693b613e6b48bcb2475eae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDAxYjU2OGE3ODM1MWJlYjZiNjkzYjYxM2U2YjQ4YmNiMjQ3NWVhZQ==", "commit": {"author": {"name": "Bernd Edlinger", "email": "bernd.edlinger@hotmail.de", "date": "2018-09-14T01:49:38Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-09-14T01:49:38Z"}, "message": "builtins.c (c_strlen): Handle not zero terminated STRING_CSTs correctly.\n\n\t* builtins.c (c_strlen): Handle not zero terminated STRING_CSTs\n\tcorrectly.\n\t* fold-const.c (c_getstr): Fix function comment.  Remove unused third\n\targument.  Fix range checks.\n\t* fold-const.h (c_getstr): Adjust protoype.\n\t* gimple-fold.c (gimple_fold_builtin_memory_op): Avoid folding when\n\tstring is constant but contains no NUL byte.\n\nFrom-SVN: r264301", "tree": {"sha": "bd7da348cd6459bb6656e42300e83dcf9f2ac2c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd7da348cd6459bb6656e42300e83dcf9f2ac2c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d01b568a78351beb6b693b613e6b48bcb2475eae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d01b568a78351beb6b693b613e6b48bcb2475eae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d01b568a78351beb6b693b613e6b48bcb2475eae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d01b568a78351beb6b693b613e6b48bcb2475eae/comments", "author": {"login": "bernd-edlinger", "id": 17638929, "node_id": "MDQ6VXNlcjE3NjM4OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/17638929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bernd-edlinger", "html_url": "https://github.com/bernd-edlinger", "followers_url": "https://api.github.com/users/bernd-edlinger/followers", "following_url": "https://api.github.com/users/bernd-edlinger/following{/other_user}", "gists_url": "https://api.github.com/users/bernd-edlinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/bernd-edlinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bernd-edlinger/subscriptions", "organizations_url": "https://api.github.com/users/bernd-edlinger/orgs", "repos_url": "https://api.github.com/users/bernd-edlinger/repos", "events_url": "https://api.github.com/users/bernd-edlinger/events{/privacy}", "received_events_url": "https://api.github.com/users/bernd-edlinger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9a9f692b6c0c8b93b7fda00c60c6e30c2e6551ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a9f692b6c0c8b93b7fda00c60c6e30c2e6551ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a9f692b6c0c8b93b7fda00c60c6e30c2e6551ce"}], "stats": {"total": 98, "additions": 50, "deletions": 48}, "files": [{"sha": "038aa27f8ede5bea3aaac70eebb40710d0ffa050", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d01b568a78351beb6b693b613e6b48bcb2475eae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d01b568a78351beb6b693b613e6b48bcb2475eae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d01b568a78351beb6b693b613e6b48bcb2475eae", "patch": "@@ -1,5 +1,13 @@\n 2018-09-13  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n+\t* builtins.c (c_strlen): Handle not zero terminated STRING_CSTs\n+\tcorrectly.\n+\t* fold-const.c (c_getstr): Fix function comment.  Remove unused third\n+\targument.  Fix range checks.\n+\t* fold-const.h (c_getstr): Adjust protoype.\n+\t* gimple-fold.c (gimple_fold_builtin_memory_op): Avoid folding when\n+\tstring is constant but contains no NUL byte.\n+\n \t* expr.c (string_constant): Adjust function comment.\n \tRemove bogus check for zero termination.\n "}, {"sha": "bef3ad2850997f616ceaa32cec026f3fbe02fc92", "filename": "gcc/builtins.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d01b568a78351beb6b693b613e6b48bcb2475eae/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d01b568a78351beb6b693b613e6b48bcb2475eae/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=d01b568a78351beb6b693b613e6b48bcb2475eae", "patch": "@@ -604,23 +604,19 @@ c_strlen (tree src, int only_value, unsigned eltsize)\n      In that case, the elements of the array after the terminating NUL are\n      all NUL.  */\n   HOST_WIDE_INT strelts = TREE_STRING_LENGTH (src);\n-  strelts = strelts / eltsize - 1;\n+  strelts = strelts / eltsize;\n \n   if (!tree_fits_uhwi_p (memsize))\n     return NULL_TREE;\n \n-  HOST_WIDE_INT maxelts = tree_to_uhwi (memsize) / eltsize - 1;\n+  HOST_WIDE_INT maxelts = tree_to_uhwi (memsize) / eltsize;\n \n   /* PTR can point to the byte representation of any string type, including\n      char* and wchar_t*.  */\n   const char *ptr = TREE_STRING_POINTER (src);\n \n   if (byteoff && TREE_CODE (byteoff) != INTEGER_CST)\n     {\n-      /* For empty strings the result should be zero.  */\n-      if (maxelts == 0)\n-\treturn ssize_int (0);\n-\n       /* The code below works only for single byte character types.  */\n       if (eltsize != 1)\n \treturn NULL_TREE;\n@@ -632,9 +628,13 @@ c_strlen (tree src, int only_value, unsigned eltsize)\n       unsigned len = string_length (ptr, eltsize, strelts);\n \n       /* Return when an embedded null character is found or none at all.  */\n-      if (len < strelts || len > maxelts)\n+      if (len + 1 < strelts || len >= maxelts)\n \treturn NULL_TREE;\n \n+      /* For empty strings the result should be zero.  */\n+      if (len == 0)\n+\treturn ssize_int (0);\n+\n       /* We don't know the starting offset, but we do know that the string\n \t has no internal zero bytes.  If the offset falls within the bounds\n \t of the string subtract the offset from the length of the string,\n@@ -644,7 +644,7 @@ c_strlen (tree src, int only_value, unsigned eltsize)\n       offsave = fold_convert (ssizetype, offsave);\n       tree condexp = fold_build2_loc (loc, LE_EXPR, boolean_type_node, offsave,\n \t\t\t\t      build_int_cst (ssizetype, len));\n-      tree lenexp = size_diffop_loc (loc, ssize_int (strelts), offsave);\n+      tree lenexp = size_diffop_loc (loc, ssize_int (len), offsave);\n       return fold_build3_loc (loc, COND_EXPR, ssizetype, condexp, lenexp,\n \t\t\t      build_zero_cst (ssizetype));\n     }\n@@ -663,7 +663,7 @@ c_strlen (tree src, int only_value, unsigned eltsize)\n \n   /* If the offset is known to be out of bounds, warn, and call strlen at\n      runtime.  */\n-  if (eltoff < 0 || eltoff > maxelts)\n+  if (eltoff < 0 || eltoff >= maxelts)\n     {\n      /* Suppress multiple warnings for propagated constant strings.  */\n       if (only_value != 2\n@@ -691,9 +691,9 @@ c_strlen (tree src, int only_value, unsigned eltsize)\n   unsigned len = string_length (ptr + eltoff * eltsize, eltsize,\n \t\t\t\tstrelts - eltoff);\n \n-  /* Don't know what to return if there was no zero termination. \n+  /* Don't know what to return if there was no zero termination.\n      Ideally this would turn into a gcc_checking_assert over time.  */\n-  if (len > maxelts - eltoff)\n+  if (len >= maxelts - eltoff)\n     return NULL_TREE;\n \n   return ssize_int (len);"}, {"sha": "e18ee28fe6327208033c253f8a44daaa42eb6ec0", "filename": "gcc/fold-const.c", "status": "modified", "additions": 25, "deletions": 34, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d01b568a78351beb6b693b613e6b48bcb2475eae/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d01b568a78351beb6b693b613e6b48bcb2475eae/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=d01b568a78351beb6b693b613e6b48bcb2475eae", "patch": "@@ -14560,23 +14560,20 @@ fold_build_pointer_plus_hwi_loc (location_t loc, tree ptr, HOST_WIDE_INT off)\n /* Return a pointer P to a NUL-terminated string representing the sequence\n    of constant characters referred to by SRC (or a subsequence of such\n    characters within it if SRC is a reference to a string plus some\n-   constant offset).  If STRLEN is non-null, store stgrlen(P) in *STRLEN.\n-   If STRSIZE is non-null, store in *STRSIZE the size of the array\n-   the string is stored in; in that case, even though P points to a NUL\n-   terminated string, SRC need not refer to one.  This can happen when\n-   SRC refers to a constant character array initialized to all non-NUL\n-   values, as in the C declaration: char a[4] = \"1234\";  */\n+   constant offset).  If STRLEN is non-null, store the number of bytes\n+   in the string constant including the terminating NUL char.  *STRLEN is\n+   typically strlen(P) + 1 in the absence of embedded NUL characters.  */\n \n const char *\n-c_getstr (tree src, unsigned HOST_WIDE_INT *strlen /* = NULL */,\n-\t  unsigned HOST_WIDE_INT *strsize /* = NULL */)\n+c_getstr (tree src, unsigned HOST_WIDE_INT *strlen /* = NULL */)\n {\n   tree offset_node;\n+  tree mem_size;\n \n   if (strlen)\n     *strlen = 0;\n \n-  src = string_constant (src, &offset_node, NULL, NULL);\n+  src = string_constant (src, &offset_node, &mem_size, NULL);\n   if (src == 0)\n     return NULL;\n \n@@ -14589,25 +14586,14 @@ c_getstr (tree src, unsigned HOST_WIDE_INT *strlen /* = NULL */,\n \toffset = tree_to_uhwi (offset_node);\n     }\n \n+  if (!tree_fits_uhwi_p (mem_size))\n+    return NULL;\n+\n   /* STRING_LENGTH is the size of the string literal, including any\n      embedded NULs.  STRING_SIZE is the size of the array the string\n      literal is stored in.  */\n   unsigned HOST_WIDE_INT string_length = TREE_STRING_LENGTH (src);\n-  unsigned HOST_WIDE_INT string_size = string_length;\n-  tree type = TREE_TYPE (src);\n-  if (tree size = TYPE_SIZE_UNIT (type))\n-    if (tree_fits_shwi_p (size))\n-      string_size = tree_to_uhwi (size);\n-\n-  if (strlen)\n-    {\n-      /* Compute and store the length of the substring at OFFSET.\n-\t All offsets past the initial length refer to null strings.  */\n-      if (offset <= string_length)\n-\t*strlen = string_length - offset;\n-      else\n-\t*strlen = 0;\n-    }\n+  unsigned HOST_WIDE_INT string_size = tree_to_uhwi (mem_size);\n \n   const char *string = TREE_STRING_POINTER (src);\n \n@@ -14619,21 +14605,26 @@ c_getstr (tree src, unsigned HOST_WIDE_INT *strlen /* = NULL */,\n       || offset >= string_size)\n     return NULL;\n \n-  if (strsize)\n+  if (strlen)\n     {\n-      /* Support even constant character arrays that aren't proper\n-\t NUL-terminated strings.  */\n-      *strsize = string_size;\n+      /* Compute and store the length of the substring at OFFSET.\n+\t All offsets past the initial length refer to null strings.  */\n+      if (offset < string_length)\n+\t*strlen = string_length - offset;\n+      else\n+\t*strlen = 1;\n     }\n-  else if (string[string_length - 1] != '\\0')\n+  else\n     {\n-      /* Support only properly NUL-terminated strings but handle\n-\t consecutive strings within the same array, such as the six\n-\t substrings in \"1\\0002\\0003\".  */\n-      return NULL;\n+      tree eltype = TREE_TYPE (TREE_TYPE (src));\n+      /* Support only properly NUL-terminated single byte strings.  */\n+      if (tree_to_uhwi (TYPE_SIZE_UNIT (eltype)) != 1)\n+\treturn NULL;\n+      if (string[string_length - 1] != '\\0')\n+\treturn NULL;\n     }\n \n-  return offset <= string_length ? string + offset : \"\";\n+  return offset < string_length ? string + offset : \"\";\n }\n \n /* Given a tree T, compute which bits in T may be nonzero.  */"}, {"sha": "ca6d47bba346c1ae3c7aa8ca6a986c04f53f2cf6", "filename": "gcc/fold-const.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d01b568a78351beb6b693b613e6b48bcb2475eae/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d01b568a78351beb6b693b613e6b48bcb2475eae/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=d01b568a78351beb6b693b613e6b48bcb2475eae", "patch": "@@ -187,8 +187,7 @@ extern bool expr_not_equal_to (tree t, const wide_int &);\n extern tree const_unop (enum tree_code, tree, tree);\n extern tree const_binop (enum tree_code, tree, tree, tree);\n extern bool negate_mathfn_p (combined_fn);\n-extern const char *c_getstr (tree, unsigned HOST_WIDE_INT * = NULL,\n-\t\t\t     unsigned HOST_WIDE_INT * = NULL);\n+extern const char *c_getstr (tree, unsigned HOST_WIDE_INT * = NULL);\n extern wide_int tree_nonzero_bits (const_tree);\n \n /* Return OFF converted to a pointer offset type suitable as offset for"}, {"sha": "83230512e71b9e0afeffb2fc90bdd6c8174a16d8", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d01b568a78351beb6b693b613e6b48bcb2475eae/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d01b568a78351beb6b693b613e6b48bcb2475eae/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=d01b568a78351beb6b693b613e6b48bcb2475eae", "patch": "@@ -725,6 +725,8 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n       tree srctype, desttype;\n       unsigned int src_align, dest_align;\n       tree off0;\n+      const char *tmp_str;\n+      unsigned HOST_WIDE_INT tmp_len;\n \n       /* Build accesses at offset zero with a ref-all character type.  */\n       off0 = build_int_cst (build_pointer_type_for_mode (char_type_node,\n@@ -742,7 +744,9 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n \t     confuses the tree-ssa-strlen.c.  This doesn't handle\n \t     the case in gcc.dg/strlenopt-8.c which is XFAILed for that\n \t     reason.  */\n-\t  && !c_strlen (src, 2))\n+\t  && !c_strlen (src, 2)\n+\t  && !((tmp_str = c_getstr (src, &tmp_len)) != NULL\n+\t       && memchr (tmp_str, 0, tmp_len) == NULL))\n \t{\n \t  unsigned ilen = tree_to_uhwi (len);\n \t  if (pow2p_hwi (ilen))"}]}