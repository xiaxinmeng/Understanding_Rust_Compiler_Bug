{"sha": "e4ad100384a5caeec738636d22d5f3988e418347", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRhZDEwMDM4NGE1Y2FlZWM3Mzg2MzZkMjJkNWYzOTg4ZTQxODM0Nw==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "1999-04-08T03:19:00Z"}, "committer": {"name": "John Wehle", "email": "wehle@gcc.gnu.org", "date": "1999-04-08T03:19:00Z"}, "message": "i386.md (truncdfsf2, [...]): Rewrite using a splitter.\n\n\t* i386.md (truncdfsf2, truncxfsf2,\n\ttruncxfdf2): Rewrite using a splitter.\n\nFrom-SVN: r26288", "tree": {"sha": "d91161ac54d6f73734e0312f02e3e1f97514cbf3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d91161ac54d6f73734e0312f02e3e1f97514cbf3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4ad100384a5caeec738636d22d5f3988e418347", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4ad100384a5caeec738636d22d5f3988e418347", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4ad100384a5caeec738636d22d5f3988e418347", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4ad100384a5caeec738636d22d5f3988e418347/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8f401e4fe30d9c699d810092075e469663eedd62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f401e4fe30d9c699d810092075e469663eedd62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f401e4fe30d9c699d810092075e469663eedd62"}], "stats": {"total": 258, "additions": 190, "deletions": 68}, "files": [{"sha": "8bcadbe73e61074b4bc7b6ca10ad9b052d5131ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ad100384a5caeec738636d22d5f3988e418347/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ad100384a5caeec738636d22d5f3988e418347/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e4ad100384a5caeec738636d22d5f3988e418347", "patch": "@@ -1,3 +1,8 @@\n+Thu Apr  8 06:16:14 EDT 1999  John Wehle  (john@feith.com)\n+\n+\t* i386.md (truncdfsf2, truncxfsf2,\n+\ttruncxfdf2): Rewrite using a splitter.\n+\n Thu Apr  8 01:26:05 1999  Arg Haas (ahaas@neosoft.com)\n \t\t\t  Jeffrey A Law  (law@cygnus.com)\n "}, {"sha": "3ec8875e71158b12ce865d199a4642ce6a43de9c", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 185, "deletions": 68, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ad100384a5caeec738636d22d5f3988e418347/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ad100384a5caeec738636d22d5f3988e418347/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=e4ad100384a5caeec738636d22d5f3988e418347", "patch": "@@ -2287,103 +2287,220 @@\n   operands[2] = (rtx) assign_386_stack_local (SFmode, 0);\n }\")\n \n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,m,!*r\")\n+\t(float_truncate:SF\n+\t  (match_operand:DF 1 \"register_operand\" \"0,f,f\")))\n+   (clobber (match_operand:SF 2 \"memory_operand\" \"m,m,m\"))]\n+  \"TARGET_80387\"\n+  \"*\n+{\n+  int stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n+  rtx xops[1];\n+\n+  xops[0] = GET_CODE (operands[0]) == MEM ? operands[0] : operands[2];\n+\n+  if (stack_top_dies || STACK_REG_P (operands[0]))\n+    output_asm_insn (AS1 (fstp%z0,%0), xops);\n+  else\n+    output_asm_insn (AS1 (fst%z0,%0), xops);\n+\n+  if (STACK_REG_P (operands[0]))\n+    return AS1 (fld%z2,%2);\n+  else if (NON_STACK_REG_P (operands[0]))\n+    return AS2 (mov%L0,%2,%0);\n+\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\" \"fpop\")])\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"\")))\n+   (clobber (match_operand:SF 2 \"memory_operand\" \"\"))]\n+  \"TARGET_80387 && reload_completed\"\n+  [(set (match_dup 2)\n+\t(float_truncate:SF (match_dup 1)))\n+   (set (match_dup 0)\n+\t(match_dup 2))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"memory_operand\" \"\")\n+\t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"\")))\n+   (clobber (match_operand:SF 2 \"memory_operand\" \"\"))]\n+  \"TARGET_80387 && reload_completed\"\n+  [(set (match_dup 0)\n+\t(float_truncate:SF (match_dup 1)))]\n+  \"\")\n+\n ;; This cannot output into an f-reg because there is no way to be sure\n-;; of truncating in that case.  Otherwise this is just like a simple move\n-;; insn.  So we pretend we can output to a reg in order to get better\n-;; register preferencing, but we really use a stack slot.\n+;; of truncating in that case.\n \n (define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,m\")\n-\t(float_truncate:SF\n-\t (match_operand:DF 1 \"register_operand\" \"0,f\")))\n-   (clobber (match_operand:SF 2 \"memory_operand\" \"m,m\"))]\n+  [(set (match_operand:SF 0 \"memory_operand\" \"=m\")\n+\t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"f\")))]\n   \"TARGET_80387\"\n   \"*\n {\n   int stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n \n-  if (GET_CODE (operands[0]) == MEM)\n-    {\n-      if (stack_top_dies)\n-\treturn AS1 (fstp%z0,%0);\n-      else\n-        return AS1 (fst%z0,%0);\n-    }\n-  else if (STACK_TOP_P (operands[0]))\n-    {\n-      output_asm_insn (AS1 (fstp%z2,%y2), operands);\n-      return AS1 (fld%z2,%y2);\n-    }\n+  if (stack_top_dies)\n+    return AS1 (fstp%z0,%0);\n   else\n-    abort ();\n+    return AS1 (fst%z0,%0);\n+}\"\n+  [(set_attr \"type\" \"fpop\")])\n+\n+(define_expand \"truncxfsf2\"\n+  [(parallel [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n+\t\t   (float_truncate:SF\n+\t\t    (match_operand:XF 1 \"register_operand\" \"\")))\n+\t      (clobber (match_dup 2))])]\n+  \"TARGET_80387\"\n+  \"\n+{\n+  operands[2] = (rtx) assign_386_stack_local (SFmode, 0);\n }\")\n \n-(define_insn \"truncxfsf2\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=m,!*r\")\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,m,!*r\")\n \t(float_truncate:SF\n-\t (match_operand:XF 1 \"register_operand\" \"f,f\")))]\n+\t  (match_operand:XF 1 \"register_operand\" \"0,f,f\")))\n+   (clobber (match_operand:SF 2 \"memory_operand\" \"m,m,m\"))]\n   \"TARGET_80387\"\n   \"*\n {\n   int stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n+  rtx xops[1];\n \n-  if (NON_STACK_REG_P (operands[0]))\n-    {\n-      if (stack_top_dies == 0)\n-\t{\n-\t  output_asm_insn (AS1 (fld,%y1), operands);\n-\t  stack_top_dies = 1;\n-\t}\n-      output_to_reg (operands[0], stack_top_dies, 0);\n-      RET;\n-    }\n-  else if (GET_CODE (operands[0]) == MEM)\n-    {\n-      if (stack_top_dies)\n-\treturn AS1 (fstp%z0,%0);\n-      else\n-\t{\n-\t  output_asm_insn (AS1 (fld,%y1), operands);\n-\t  return AS1 (fstp%z0,%0);\n-\t}\n-    }\n+  xops[0] = GET_CODE (operands[0]) == MEM ? operands[0] : operands[2];\n+\n+  if (stack_top_dies || STACK_REG_P (operands[0]))\n+    output_asm_insn (AS1 (fstp%z0,%0), xops);\n   else\n-    abort ();\n+    output_asm_insn (AS1 (fst%z0,%0), xops);\n+\n+  if (STACK_REG_P (operands[0]))\n+    return AS1 (fld%z2,%2);\n+  else if (NON_STACK_REG_P (operands[0]))\n+    return AS2 (mov%L0,%2,%0);\n+\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\" \"fpop\")])\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(float_truncate:SF (match_operand:XF 1 \"register_operand\" \"\")))\n+   (clobber (match_operand:SF 2 \"memory_operand\" \"\"))]\n+  \"TARGET_80387 && reload_completed\"\n+  [(set (match_dup 2)\n+\t(float_truncate:SF (match_dup 1)))\n+   (set (match_dup 0)\n+\t(match_dup 2))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"memory_operand\" \"\")\n+\t(float_truncate:SF (match_operand:XF 1 \"register_operand\" \"\")))\n+   (clobber (match_operand:SF 2 \"memory_operand\" \"\"))]\n+  \"TARGET_80387 && reload_completed\"\n+  [(set (match_dup 0)\n+\t(float_truncate:SF (match_dup 1)))]\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"memory_operand\" \"=m\")\n+\t(float_truncate:SF (match_operand:XF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_80387\"\n+  \"*\n+{\n+  int stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n+\n+  if (stack_top_dies)\n+    return AS1 (fstp%z0,%0);\n+  else\n+    return AS1 (fst%z0,%0);\n+}\"\n+  [(set_attr \"type\" \"fpop\")])\n+\n+(define_expand \"truncxfdf2\"\n+  [(parallel [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n+\t\t   (float_truncate:DF\n+\t\t    (match_operand:XF 1 \"register_operand\" \"\")))\n+\t      (clobber (match_dup 2))])]\n+  \"TARGET_80387\"\n+  \"\n+{\n+  operands[2] = (rtx) assign_386_stack_local (DFmode, 0);\n }\")\n \n-(define_insn \"truncxfdf2\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=m,!*r\")\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,m,!*r\")\n \t(float_truncate:DF\n-\t (match_operand:XF 1 \"register_operand\" \"f,f\")))]\n+\t  (match_operand:XF 1 \"register_operand\" \"0,f,f\")))\n+   (clobber (match_operand:DF 2 \"memory_operand\" \"m,m,o\"))]\n   \"TARGET_80387\"\n   \"*\n {\n   int stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n+  rtx xops[2];\n \n-  if (NON_STACK_REG_P (operands[0]))\n-    {\n-      if (stack_top_dies == 0)\n-\t{\n-\t  output_asm_insn (AS1 (fld,%y1), operands);\n-\t  stack_top_dies = 1;\n-\t}\n-      output_to_reg (operands[0], stack_top_dies, 0);\n-      RET;\n-    }\n-  else if (GET_CODE (operands[0]) == MEM)\n+  xops[0] = GET_CODE (operands[0]) == MEM ? operands[0] : operands[2];\n+\n+  if (stack_top_dies || STACK_REG_P (operands[0]))\n+    output_asm_insn (AS1 (fstp%z0,%0), xops);\n+  else\n+    output_asm_insn (AS1 (fst%z0,%0), xops);\n+\n+  if (STACK_REG_P (operands[0]))\n+    return AS1 (fld%z2,%2);\n+  else if (NON_STACK_REG_P (operands[0]))\n     {\n-      if (stack_top_dies)\n-\treturn AS1 (fstp%z0,%0);\n-      else\n-\t{\n-\t  output_asm_insn (AS1 (fld,%y1), operands);\n-\t  return AS1 (fstp%z0,%0);\n-\t}\n+    xops[0] = operands[0];\n+    xops[1] = operands[2];\n+    return output_move_double (xops);\n     }\n-  else\n-    abort ();\n-}\")\n \n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\" \"fpop\")])\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(float_truncate:DF (match_operand:XF 1 \"register_operand\" \"\")))\n+   (clobber (match_operand:DF 2 \"memory_operand\" \"\"))]\n+  \"TARGET_80387 && reload_completed\"\n+  [(set (match_dup 2)\n+\t(float_truncate:DF (match_dup 1)))\n+   (set (match_dup 0)\n+\t(match_dup 2))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"memory_operand\" \"\")\n+\t(float_truncate:DF (match_operand:XF 1 \"register_operand\" \"\")))\n+   (clobber (match_operand:DF 2 \"memory_operand\" \"\"))]\n+  \"TARGET_80387 && reload_completed\"\n+  [(set (match_dup 0)\n+\t(float_truncate:DF (match_dup 1)))]\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"memory_operand\" \"=m\")\n+\t(float_truncate:DF (match_operand:XF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_80387\"\n+  \"*\n+{\n+  int stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n+\n+  if (stack_top_dies)\n+    return AS1 (fstp%z0,%0);\n+  else\n+    return AS1 (fst%z0,%0);\n+}\"\n+  [(set_attr \"type\" \"fpop\")])\n \f\n ;; The 387 requires that the stack top dies after converting to DImode.\n "}]}