{"sha": "00b9ce5c19db7e191b04084d4402a30cabc5f8f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBiOWNlNWMxOWRiN2UxOTFiMDQwODRkNDQwMmEzMGNhYmM1ZjhmMg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2005-05-27T01:58:07Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2005-05-27T01:58:07Z"}, "message": "reg-stack.c (convert_regs_entry, [...]): Delete prototypes.\n\n\n\t* reg-stack.c (convert_regs_entry, convert_regs_exit,\n\tconvert_regs_1, convert_regs_2, convert_regs): Delete prototypes.\n\t(reg_to_stack): Move to end of the file.  Initialize the per\n\tbasic block information here, instead of...\n\t(convert_regs_entry): Here.\n\t(convert_regs): Change unused return type to void.\n\nFrom-SVN: r100238", "tree": {"sha": "7925bfa3102671db3e3e84e32dfbe1821a732c37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7925bfa3102671db3e3e84e32dfbe1821a732c37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00b9ce5c19db7e191b04084d4402a30cabc5f8f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00b9ce5c19db7e191b04084d4402a30cabc5f8f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00b9ce5c19db7e191b04084d4402a30cabc5f8f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00b9ce5c19db7e191b04084d4402a30cabc5f8f2/comments", "author": null, "committer": null, "parents": [{"sha": "6f43e0a2010809db2229b3ba371d1d367b1eac21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f43e0a2010809db2229b3ba371d1d367b1eac21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f43e0a2010809db2229b3ba371d1d367b1eac21"}], "stats": {"total": 238, "additions": 117, "deletions": 121}, "files": [{"sha": "433b0f0b5f3e3dacf52e4ccb61762a8c3fdd52bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b9ce5c19db7e191b04084d4402a30cabc5f8f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b9ce5c19db7e191b04084d4402a30cabc5f8f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00b9ce5c19db7e191b04084d4402a30cabc5f8f2", "patch": "@@ -1,3 +1,12 @@\n+2005-05-26  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* reg-stack.c (convert_regs_entry, convert_regs_exit,\n+\tconvert_regs_1, convert_regs_2, convert_regs): Delete prototypes.\n+\t(reg_to_stack): Move to end of the file.  Initialize the per\n+\tbasic block information here, instead of...\n+\t(convert_regs_entry): Here.\n+\t(convert_regs): Change unused return type to void.\n+\n 2005-05-27  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* c-pch.c, timevar.c, timevar.h, unwind-compat.c,"}, {"sha": "173918727ec43ccd7eef3e5b03faf51fb24f1569", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 108, "deletions": 121, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b9ce5c19db7e191b04084d4402a30cabc5f8f2/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b9ce5c19db7e191b04084d4402a30cabc5f8f2/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=00b9ce5c19db7e191b04084d4402a30cabc5f8f2", "patch": "@@ -259,11 +259,6 @@ static bool subst_stack_regs_pat (rtx, stack, rtx);\n static void subst_asm_stack_regs (rtx, stack);\n static bool subst_stack_regs (rtx, stack);\n static void change_stack (rtx, stack, stack, enum emit_where);\n-static int convert_regs_entry (void);\n-static void convert_regs_exit (void);\n-static int convert_regs_1 (FILE *, basic_block);\n-static int convert_regs_2 (FILE *, basic_block);\n-static int convert_regs (FILE *);\n static void print_stack (FILE *, stack);\n static rtx next_flags_user (rtx);\n static bool compensate_edge (edge, FILE *);\n@@ -397,101 +392,6 @@ pop_stack (stack regstack, int regno)\n \t  }\n     }\n }\n-\f\n-/* Convert register usage from \"flat\" register file usage to a \"stack\n-   register file.  FILE is the dump file, if used.\n-\n-   Construct a CFG and run life analysis.  Then convert each insn one\n-   by one.  Run a last cleanup_cfg pass, if optimizing, to eliminate\n-   code duplication created when the converter inserts pop insns on\n-   the edges.  */\n-\n-bool\n-reg_to_stack (FILE *file)\n-{\n-  basic_block bb;\n-  int i;\n-  int max_uid;\n-\n-  /* Clean up previous run.  */\n-  stack_regs_mentioned_data = 0;\n-\n-  /* See if there is something to do.  Flow analysis is quite\n-     expensive so we might save some compilation time.  */\n-  for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n-    if (regs_ever_live[i])\n-      break;\n-  if (i > LAST_STACK_REG)\n-    return false;\n-\n-  /* Ok, floating point instructions exist.  If not optimizing,\n-     build the CFG and run life analysis.\n-     Also need to rebuild life when superblock scheduling is done\n-     as it don't update liveness yet.  */\n-  if (!optimize\n-      || (flag_sched2_use_superblocks\n-\t  && flag_schedule_insns_after_reload))\n-    {\n-      count_or_remove_death_notes (NULL, 1);\n-      life_analysis (file, PROP_DEATH_NOTES);\n-    }\n-  mark_dfs_back_edges ();\n-\n-  /* Set up block info for each basic block.  */\n-  alloc_aux_for_blocks (sizeof (struct block_info_def));\n-  FOR_EACH_BB_REVERSE (bb)\n-    {\n-      edge e;\n-      edge_iterator ei;\n-\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\tif (!(e->flags & EDGE_DFS_BACK)\n-\t    && e->src != ENTRY_BLOCK_PTR)\n-\t  BLOCK_INFO (bb)->predecessors++;\n-    }\n-\n-  /* Create the replacement registers up front.  */\n-  for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n-    {\n-      enum machine_mode mode;\n-      for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);\n-\t   mode != VOIDmode;\n-\t   mode = GET_MODE_WIDER_MODE (mode))\n-\tFP_MODE_REG (i, mode) = gen_rtx_REG (mode, i);\n-      for (mode = GET_CLASS_NARROWEST_MODE (MODE_COMPLEX_FLOAT);\n-\t   mode != VOIDmode;\n-\t   mode = GET_MODE_WIDER_MODE (mode))\n-\tFP_MODE_REG (i, mode) = gen_rtx_REG (mode, i);\n-    }\n-\n-  ix86_flags_rtx = gen_rtx_REG (CCmode, FLAGS_REG);\n-\n-  /* A QNaN for initializing uninitialized variables.\n-\n-     ??? We can't load from constant memory in PIC mode, because\n-     we're inserting these instructions before the prologue and\n-     the PIC register hasn't been set up.  In that case, fall back\n-     on zero, which we can get from `ldz'.  */\n-\n-  if (flag_pic)\n-    not_a_num = CONST0_RTX (SFmode);\n-  else\n-    {\n-      not_a_num = gen_lowpart (SFmode, GEN_INT (0x7fc00000));\n-      not_a_num = force_const_mem (SFmode, not_a_num);\n-    }\n-\n-  /* Allocate a cache for stack_regs_mentioned.  */\n-  max_uid = get_max_uid ();\n-  VARRAY_CHAR_INIT (stack_regs_mentioned_data, max_uid + 1,\n-\t\t    \"stack_regs_mentioned cache\");\n-\n-  convert_regs (file);\n-\n-  free_aux_for_blocks ();\n-  return true;\n-}\n-\n \f\n /* Return a pointer to the REG expression within PAT.  If PAT is not a\n    REG, possible enclosed by a conversion rtx, return the inner part of\n@@ -2608,25 +2508,6 @@ convert_regs_entry (void)\n   int inserted = 0;\n   edge e;\n   edge_iterator ei;\n-  basic_block block;\n-\n-  FOR_EACH_BB_REVERSE (block)\n-    {\n-      block_info bi = BLOCK_INFO (block);\n-      int reg;\n-\n-      /* Set current register status at last instruction `uninitialized'.  */\n-      bi->stack_in.top = -2;\n-\n-      /* Copy live_at_end and live_at_start into temporaries.  */\n-      for (reg = FIRST_STACK_REG; reg <= LAST_STACK_REG; reg++)\n-\t{\n-\t  if (REGNO_REG_SET_P (block->global_live_at_end, reg))\n-\t    SET_HARD_REG_BIT (bi->out_reg_set, reg);\n-\t  if (REGNO_REG_SET_P (block->global_live_at_start, reg))\n-\t    SET_HARD_REG_BIT (bi->stack_in.reg_set, reg);\n-\t}\n-    }\n \n   /* Load something into each stack register live at function entry.\n      Such live registers can be caused by uninitialized variables or\n@@ -3082,7 +2963,7 @@ convert_regs_2 (FILE *file, basic_block block)\n    references in each insn from the \"flat\" register file that gcc uses,\n    to the stack-like registers the 387 uses.  */\n \n-static int\n+static void\n convert_regs (FILE *file)\n {\n   int inserted;\n@@ -3122,8 +3003,114 @@ convert_regs (FILE *file)\n \n   if (file)\n     fputc ('\\n', file);\n+}\n+\f\n+/* Convert register usage from \"flat\" register file usage to a \"stack\n+   register file.  FILE is the dump file, if used.\n \n-  return inserted;\n+   Construct a CFG and run life analysis.  Then convert each insn one\n+   by one.  Run a last cleanup_cfg pass, if optimizing, to eliminate\n+   code duplication created when the converter inserts pop insns on\n+   the edges.  */\n+\n+bool\n+reg_to_stack (FILE *file)\n+{\n+  basic_block bb;\n+  int i;\n+  int max_uid;\n+\n+  /* Clean up previous run.  */\n+  stack_regs_mentioned_data = 0;\n+\n+  /* See if there is something to do.  Flow analysis is quite\n+     expensive so we might save some compilation time.  */\n+  for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n+    if (regs_ever_live[i])\n+      break;\n+  if (i > LAST_STACK_REG)\n+    return false;\n+\n+  /* Ok, floating point instructions exist.  If not optimizing,\n+     build the CFG and run life analysis.\n+     Also need to rebuild life when superblock scheduling is done\n+     as it don't update liveness yet.  */\n+  if (!optimize\n+      || (flag_sched2_use_superblocks\n+\t  && flag_schedule_insns_after_reload))\n+    {\n+      count_or_remove_death_notes (NULL, 1);\n+      life_analysis (file, PROP_DEATH_NOTES);\n+    }\n+  mark_dfs_back_edges ();\n+\n+  /* Set up block info for each basic block.  */\n+  alloc_aux_for_blocks (sizeof (struct block_info_def));\n+  FOR_EACH_BB_REVERSE (bb)\n+    {\n+      block_info bi = BLOCK_INFO (bb);\n+      edge_iterator ei;\n+      edge e;\n+      int reg;\n+\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tif (!(e->flags & EDGE_DFS_BACK)\n+\t    && e->src != ENTRY_BLOCK_PTR)\n+\t  bi->predecessors++;\n+\n+      /* Set current register status at last instruction `uninitialized'.  */\n+      bi->stack_in.top = -2;\n+\n+      /* Copy live_at_end and live_at_start into temporaries.  */\n+      for (reg = FIRST_STACK_REG; reg <= LAST_STACK_REG; reg++)\n+\t{\n+\t  if (REGNO_REG_SET_P (bb->global_live_at_end, reg))\n+\t    SET_HARD_REG_BIT (bi->out_reg_set, reg);\n+\t  if (REGNO_REG_SET_P (bb->global_live_at_start, reg))\n+\t    SET_HARD_REG_BIT (bi->stack_in.reg_set, reg);\n+\t}\n+    }\n+\n+  /* Create the replacement registers up front.  */\n+  for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n+    {\n+      enum machine_mode mode;\n+      for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);\n+\t   mode != VOIDmode;\n+\t   mode = GET_MODE_WIDER_MODE (mode))\n+\tFP_MODE_REG (i, mode) = gen_rtx_REG (mode, i);\n+      for (mode = GET_CLASS_NARROWEST_MODE (MODE_COMPLEX_FLOAT);\n+\t   mode != VOIDmode;\n+\t   mode = GET_MODE_WIDER_MODE (mode))\n+\tFP_MODE_REG (i, mode) = gen_rtx_REG (mode, i);\n+    }\n+\n+  ix86_flags_rtx = gen_rtx_REG (CCmode, FLAGS_REG);\n+\n+  /* A QNaN for initializing uninitialized variables.\n+\n+     ??? We can't load from constant memory in PIC mode, because\n+     we're inserting these instructions before the prologue and\n+     the PIC register hasn't been set up.  In that case, fall back\n+     on zero, which we can get from `ldz'.  */\n+\n+  if (flag_pic)\n+    not_a_num = CONST0_RTX (SFmode);\n+  else\n+    {\n+      not_a_num = gen_lowpart (SFmode, GEN_INT (0x7fc00000));\n+      not_a_num = force_const_mem (SFmode, not_a_num);\n+    }\n+\n+  /* Allocate a cache for stack_regs_mentioned.  */\n+  max_uid = get_max_uid ();\n+  VARRAY_CHAR_INIT (stack_regs_mentioned_data, max_uid + 1,\n+\t\t    \"stack_regs_mentioned cache\");\n+\n+  convert_regs (file);\n+\n+  free_aux_for_blocks ();\n+  return true;\n }\n #endif /* STACK_REGS */\n "}]}