{"sha": "9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIxNmNiNTdkZWRlYzNkN2ZiNjkwYWQ3NzcwZjJjYTljYTg1ZjU4Ng==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2012-10-02T08:48:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-02T08:48:27Z"}, "message": "par_sco.adb, [...]: Change name Conditional_Expression to If_Expression.\n\n2012-10-02  Robert Dewar  <dewar@adacore.com>\n\n\t* par_sco.adb, sem_ch3.adb, layout.adb, exp_ch7.adb, exp_imgv.adb,\n\texp_util.adb, exp_util.ads, exp_attr.adb, sinfo.adb, sinfo.ads,\n\texp_ch9.adb, style.ads, scos.ads, debug.adb, einfo.ads, scng.adb,\n\tchecks.adb, checks.ads, sem.adb, par-ch4.adb, sem_util.adb, types.h,\n\tsem_res.adb, expander.adb, scans.ads, par.adb, exp_ch2.adb,\n\tgnat1drv.adb, stylesw.ads, sem_elab.adb, exp_ch4.adb, exp_ch4.ads,\n\texp_ch6.adb, sem_ch4.adb, sem_ch4.ads, sem_ch6.adb,\n\topt.ads, sem_eval.adb, sem_eval.ads, exp_intr.adb, sprint.adb,\n\tsprint.ads, styleg.ads: Change name Conditional_Expression to\n\tIf_Expression.\n\t* gcc-interface/trans.c (gnat_to_gnu): Replace\n\tN_Conditional_Expression by N_If_Expression.\n\t* gcc-interface/Make-lang.in: Update dependencies.\n\nFrom-SVN: r191967", "tree": {"sha": "427db6631f4424c39ebbfe7c953d008cfee86519", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/427db6631f4424c39ebbfe7c953d008cfee86519"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/comments", "author": null, "committer": null, "parents": [{"sha": "cb42ba5d667142c60c27fadd8efba35e0e18e797", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb42ba5d667142c60c27fadd8efba35e0e18e797", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb42ba5d667142c60c27fadd8efba35e0e18e797"}], "stats": {"total": 1562, "additions": 795, "deletions": 767}, "files": [{"sha": "8fd7724cb8570fa035d4c867b5d67526125f11c1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -1,3 +1,19 @@\n+2012-10-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par_sco.adb, sem_ch3.adb, layout.adb, exp_ch7.adb, exp_imgv.adb,\n+\texp_util.adb, exp_util.ads, exp_attr.adb, sinfo.adb, sinfo.ads,\n+\texp_ch9.adb, style.ads, scos.ads, debug.adb, einfo.ads, scng.adb,\n+\tchecks.adb, checks.ads, sem.adb, par-ch4.adb, sem_util.adb, types.h,\n+\tsem_res.adb, expander.adb, scans.ads, par.adb, exp_ch2.adb,\n+\tgnat1drv.adb, stylesw.ads, sem_elab.adb, exp_ch4.adb, exp_ch4.ads,\n+\texp_ch6.adb, sem_ch4.adb, sem_ch4.ads, sem_ch6.adb,\n+\topt.ads, sem_eval.adb, sem_eval.ads, exp_intr.adb, sprint.adb,\n+\tsprint.ads, styleg.ads: Change name Conditional_Expression to\n+\tIf_Expression.\n+\t* gcc-interface/trans.c (gnat_to_gnu): Replace\n+\tN_Conditional_Expression by N_If_Expression.\n+\t* gcc-interface/Make-lang.in: Update dependencies.\n+\n 2012-10-02  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch4.adb (Expand_N_Op_Expon): Use expression with actions"}, {"sha": "a31e87b0a3ce994f04600ef6c72bf758e43747fc", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -197,13 +197,14 @@ package body Checks is\n    --  Used to apply arithmetic overflow checks for all cases except operators\n    --  on signed arithmetic types in Minimized/Eliminate case (for which we\n    --  call Apply_Arithmetic_Overflow_Minimized_Eliminated below). N is always\n-   --  a signed integer arithmetic operator (conditional expression excluded).\n+   --  a signed integer arithmetic operator (if and case expressions are not\n+   --  included for this case).\n \n    procedure Apply_Arithmetic_Overflow_Minimized_Eliminated (Op : Node_Id);\n    --  Used to apply arithmetic overflow checks for the case where the overflow\n    --  checking mode is Minimized or Eliminated (and the Do_Overflow_Check flag\n    --  is known to be set) and we have an signed integer arithmetic op (which\n-   --  includes the case of conditional expressions).\n+   --  includes the case of if and case expressions).\n \n    procedure Apply_Division_Check\n      (N   : Node_Id;\n@@ -6258,8 +6259,7 @@ package body Checks is\n               N_Op_Rem   | N_Op_Subtract =>\n             return Is_Signed_Integer_Type (Etype (N));\n \n-         when N_Conditional_Expression |\n-              N_Case_Expression        =>\n+         when N_If_Expression | N_Case_Expression =>\n             return Is_Signed_Integer_Type (Etype (N));\n \n          when N_Case_Expression_Alternative =>\n@@ -6338,19 +6338,19 @@ package body Checks is\n                   return False;\n                end if;\n \n-               --  Similarly, if we are in a conditional expression and not\n-               --  part of the condition, then we return False, since neither\n-               --  the THEN or ELSE expressions will always be elaborated.\n+               --  Similarly, if we are in an if expression and not part of the\n+               --  condition, then we return False, since neither the THEN or\n+               --  ELSE dependent expressions will always be elaborated.\n \n-               if Nkind (P) = N_Conditional_Expression\n+               if Nkind (P) = N_If_Expression\n                  and then N /= First (Expressions (P))\n                then\n                   return False;\n                end if;\n \n                --  If we are in a case expression, and not part of the\n                --  expression, then we return False, since a particular\n-               --  branch may not always be elaborated\n+               --  dependent expression may not always be elaborated\n \n                if Nkind (P) = N_Case_Expression\n                  and then N /= Expression (P)\n@@ -6805,7 +6805,7 @@ package body Checks is\n \n       --  Processing for if expression\n \n-      elsif Nkind (N) = N_Conditional_Expression then\n+      elsif Nkind (N) = N_If_Expression then\n          declare\n             Then_DE : constant Node_Id := Next (First (Expressions (N)));\n             Else_DE : constant Node_Id := Next (Then_DE);\n@@ -6840,7 +6840,7 @@ package body Checks is\n \n             if Bignum_Operands then\n                Rewrite (N,\n-                 Make_Conditional_Expression (Loc,\n+                 Make_If_Expression (Loc,\n                    Expressions => New_List (\n                      Remove_Head (Expressions (N)),\n                      Convert_To_Bignum (Then_DE),\n@@ -8021,10 +8021,10 @@ package body Checks is\n       if Is_Array_Type (T_Typ) and then Is_Array_Type (S_Typ) then\n          if Is_Constrained (T_Typ) then\n \n-            --  The checking code to be generated will freeze the\n-            --  corresponding array type. However, we must freeze the\n-            --  type now, so that the freeze node does not appear within\n-            --  the generated conditional expression, but ahead of it.\n+            --  The checking code to be generated will freeze the corresponding\n+            --  array type. However, we must freeze the type now, so that the\n+            --  freeze node does not appear within the generated if expression,\n+            --  but ahead of it.\n \n             Freeze_Before (Ck_Node, T_Typ);\n "}, {"sha": "6478eeca64811ed6c260dec1e93498a0cc2c4bdb", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -138,7 +138,7 @@ package Checks is\n    --  Handle overflow checking for an arithmetic operator. Also handles the\n    --  cases of ELIMINATED and MINIMIZED overflow checking mode. If the mode\n    --  is one of the latter two, then this routine can also be called with\n-   --  a conditional expression node to make sure that we properly handle\n+   --  an if or case expression node to make sure that we properly handle\n    --  overflow checking for dependent expressions. This routine handles\n    --  front end vs back end overflow checks (in the front end case it expands\n    --  the necessary check). Note that divide is handled separately using"}, {"sha": "f6f24f9c7bfad172ee1ed02b5cabee67d0b71e76", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -129,7 +129,7 @@ package body Debug is\n    --  d.I  SCIL generation mode\n    --  d.J  Disable parallel SCIL generation mode\n    --  d.K  Alfa detection only mode for gnat2why\n-   --  d.L  Depend on back end for limited types in conditional expressions\n+   --  d.L  Depend on back end for limited types in if and case expressions\n    --  d.M\n    --  d.N  Add node to all entities\n    --  d.O  Dump internal SCO tables"}, {"sha": "bf360161bcf9e54563b056fdb70827ecd9882797", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -3681,7 +3681,7 @@ package Einfo is\n --    Status_Flag_Or_Transient_Decl (Node15)\n --       Present in variables and constants. Applies to objects that require\n --       special treatment by the finalization machinery. Such examples are\n---       extended return results, conditional expression results and objects\n+--       extended return results, if and case expression results and objects\n --       inside N_Expression_With_Actions nodes. The attribute contains the\n --       entity of a flag which specifies particular behavior over a region\n --       of code or the declaration of a \"hook\" object."}, {"sha": "04930a9bd7cb5fb372580e93156d7ea65e815dd3", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -3324,13 +3324,13 @@ package body Exp_Attr is\n          --    Furthermore, (-value - 1) can be expressed as -(value + 1)\n          --    which we can compute using the integer base type.\n \n-         --  Once this is done we analyze the conditional expression without\n-         --  range checks, because we know everything is in range, and we\n-         --  want to prevent spurious warnings on either branch.\n+         --  Once this is done we analyze the if expression without range\n+         --  checks, because we know everything is in range, and we want\n+         --  to prevent spurious warnings on either branch.\n \n          else\n             Rewrite (N,\n-              Make_Conditional_Expression (Loc,\n+              Make_If_Expression (Loc,\n                 Expressions => New_List (\n                   Make_Op_Ge (Loc,\n                     Left_Opnd  => Duplicate_Subexpr (Arg),\n@@ -3500,7 +3500,7 @@ package body Exp_Attr is\n               Right_Opnd => Y_Addr);\n \n          Rewrite (N,\n-           Make_Conditional_Expression (Loc,\n+           Make_If_Expression (Loc,\n              New_List (\n                Cond,\n \n@@ -5643,8 +5643,8 @@ package body Exp_Attr is\n \n             Analyze_And_Resolve (N, Standard_Boolean);\n \n-         --  For record types, we build a big conditional expression, applying\n-         --  Valid or Valid_Scalars as appropriate to all relevant components.\n+         --  For record types, we build a big if expression, applying Valid or\n+         --  Valid_Scalars as appropriate to all relevant components.\n \n          elsif (Is_Record_Type (Ptyp) or else Has_Discriminants (Ptyp))\n            and then not No_Scalar_Parts (Ptyp)"}, {"sha": "37a5bda65274590126219b97247df47f1a42f08e", "filename": "gcc/ada/exp_ch2.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -177,7 +177,7 @@ package body Exp_Ch2 is\n          if Nkind (CV) in N_Subexpr then\n             Val := CV;\n \n-         --  Case of Current_Value is a conditional expression reference\n+         --  Case of Current_Value is an if expression reference\n \n          else\n             Get_Current_Value_Condition (N, Op, Val);"}, {"sha": "9a07c6027bb8cc2c02172f688207f6443528bbb5", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 190, "deletions": 190, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -3391,7 +3391,7 @@ package body Exp_Ch4 is\n          Low_Bound := Opnd_Low_Bound (1);\n \n       --  OK, we don't know the lower bound, we have to build a horrible\n-      --  conditional expression node of the form\n+      --  if expression node of the form\n \n       --     if Cond1'Length /= 0 then\n       --        Opnd1 low bound\n@@ -3422,7 +3422,7 @@ package body Exp_Ch4 is\n \n                else\n                   return\n-                    Make_Conditional_Expression (Loc,\n+                    Make_If_Expression (Loc,\n                       Expressions => New_List (\n \n                         Make_Op_Ne (Loc,\n@@ -3476,7 +3476,7 @@ package body Exp_Ch4 is\n \n       if Result_May_Be_Null then\n          Low_Bound :=\n-           Make_Conditional_Expression (Loc,\n+           Make_If_Expression (Loc,\n              Expressions => New_List (\n                Make_Op_Eq (Loc,\n                  Left_Opnd  => New_Copy (Aggr_Length (NN)),\n@@ -3485,7 +3485,7 @@ package body Exp_Ch4 is\n                Low_Bound));\n \n          High_Bound :=\n-           Make_Conditional_Expression (Loc,\n+           Make_If_Expression (Loc,\n              Expressions => New_List (\n                Make_Op_Eq (Loc,\n                  Left_Opnd  => New_Copy (Aggr_Length (NN)),\n@@ -4630,8 +4630,8 @@ package body Exp_Ch4 is\n                end;\n \n                --  We set the allocator as analyzed so that when we analyze\n-               --  the conditional expression node, we do not get an unwanted\n-               --  recursive expansion of the allocator expression.\n+               --  the if expression node, we do not get an unwanted recursive\n+               --  expansion of the allocator expression.\n \n                Set_Analyzed (N, True);\n                Nod := Relocate_Node (N);\n@@ -4918,21 +4918,188 @@ package body Exp_Ch4 is\n       Analyze_And_Resolve (N, Typ);\n    end Expand_N_Case_Expression;\n \n-   -------------------------------------\n-   -- Expand_N_Conditional_Expression --\n-   -------------------------------------\n+   -----------------------------------\n+   -- Expand_N_Explicit_Dereference --\n+   -----------------------------------\n+\n+   procedure Expand_N_Explicit_Dereference (N : Node_Id) is\n+   begin\n+      --  Insert explicit dereference call for the checked storage pool case\n+\n+      Insert_Dereference_Action (Prefix (N));\n+\n+      --  If the type is an Atomic type for which Atomic_Sync is enabled, then\n+      --  we set the atomic sync flag.\n+\n+      if Is_Atomic (Etype (N))\n+        and then not Atomic_Synchronization_Disabled (Etype (N))\n+      then\n+         Activate_Atomic_Synchronization (N);\n+      end if;\n+   end Expand_N_Explicit_Dereference;\n+\n+   --------------------------------------\n+   -- Expand_N_Expression_With_Actions --\n+   --------------------------------------\n+\n+   procedure Expand_N_Expression_With_Actions (N : Node_Id) is\n+\n+      procedure Process_Transient_Object (Decl : Node_Id);\n+      --  Given the declaration of a controlled transient declared inside the\n+      --  Actions list of an Expression_With_Actions, generate all necessary\n+      --  types and hooks in order to properly finalize the transient. This\n+      --  mechanism works in conjunction with Build_Finalizer.\n+\n+      ------------------------------\n+      -- Process_Transient_Object --\n+      ------------------------------\n+\n+      procedure Process_Transient_Object (Decl : Node_Id) is\n+\n+         function Find_Insertion_Node return Node_Id;\n+         --  Complex conditions in if statements may be converted into nested\n+         --  EWAs. In this case, any generated code must be inserted before the\n+         --  if statement to ensure proper visibility of the hook objects. This\n+         --  routine returns the top most short circuit operator or the parent\n+         --  of the EWA if no nesting was detected.\n+\n+         -------------------------\n+         -- Find_Insertion_Node --\n+         -------------------------\n+\n+         function Find_Insertion_Node return Node_Id is\n+            Par : Node_Id;\n+\n+         begin\n+            --  Climb up the branches of a complex condition\n+\n+            Par := N;\n+            while Nkind_In (Parent (Par), N_And_Then, N_Op_Not, N_Or_Else) loop\n+               Par := Parent (Par);\n+            end loop;\n+\n+            return Par;\n+         end Find_Insertion_Node;\n+\n+         --  Local variables\n+\n+         Ins_Node  : constant Node_Id    := Find_Insertion_Node;\n+         Loc       : constant Source_Ptr := Sloc (Decl);\n+         Obj_Id    : constant Entity_Id  := Defining_Identifier (Decl);\n+         Obj_Typ   : constant Entity_Id  := Etype (Obj_Id);\n+         Desig_Typ : Entity_Id;\n+         Expr      : Node_Id;\n+         Ptr_Decl  : Node_Id;\n+         Ptr_Id    : Entity_Id;\n+         Temp_Decl : Node_Id;\n+         Temp_Id   : Node_Id;\n+\n+      --  Start of processing for Process_Transient_Object\n+\n+      begin\n+         --  Step 1: Create the access type which provides a reference to the\n+         --  transient object.\n+\n+         if Is_Access_Type (Obj_Typ) then\n+            Desig_Typ := Directly_Designated_Type (Obj_Typ);\n+         else\n+            Desig_Typ := Obj_Typ;\n+         end if;\n+\n+         --  Generate:\n+         --    Ann : access [all] <Desig_Typ>;\n+\n+         Ptr_Id := Make_Temporary (Loc, 'A');\n+\n+         Ptr_Decl :=\n+           Make_Full_Type_Declaration (Loc,\n+             Defining_Identifier => Ptr_Id,\n+             Type_Definition     =>\n+               Make_Access_To_Object_Definition (Loc,\n+                 All_Present        =>\n+                   Ekind (Obj_Typ) = E_General_Access_Type,\n+                 Subtype_Indication => New_Reference_To (Desig_Typ, Loc)));\n+\n+         Insert_Action (Ins_Node, Ptr_Decl);\n+         Analyze (Ptr_Decl);\n+\n+         --  Step 2: Create a temporary which acts as a hook to the transient\n+         --  object. Generate:\n+\n+         --    Temp : Ptr_Id := null;\n+\n+         Temp_Id := Make_Temporary (Loc, 'T');\n+\n+         Temp_Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Temp_Id,\n+             Object_Definition   => New_Reference_To (Ptr_Id, Loc));\n+\n+         Insert_Action (Ins_Node, Temp_Decl);\n+         Analyze (Temp_Decl);\n+\n+         --  Mark this temporary as created for the purposes of exporting the\n+         --  transient declaration out of the Actions list. This signals the\n+         --  machinery in Build_Finalizer to recognize this special case.\n+\n+         Set_Status_Flag_Or_Transient_Decl (Temp_Id, Decl);\n+\n+         --  Step 3: Hook the transient object to the temporary\n+\n+         if Is_Access_Type (Obj_Typ) then\n+            Expr := Convert_To (Ptr_Id, New_Reference_To (Obj_Id, Loc));\n+         else\n+            Expr :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix         => New_Reference_To (Obj_Id, Loc),\n+                Attribute_Name => Name_Unrestricted_Access);\n+         end if;\n+\n+         --  Generate:\n+         --    Temp := Ptr_Id (Obj_Id);\n+         --      <or>\n+         --    Temp := Obj_Id'Unrestricted_Access;\n+\n+         Insert_After_And_Analyze (Decl,\n+           Make_Assignment_Statement (Loc,\n+             Name       => New_Reference_To (Temp_Id, Loc),\n+             Expression => Expr));\n+      end Process_Transient_Object;\n+\n+      --  Local variables\n+\n+      Decl : Node_Id;\n+\n+   --  Start of processing for Expand_N_Expression_With_Actions\n+\n+   begin\n+      Decl := First (Actions (N));\n+      while Present (Decl) loop\n+         if Nkind (Decl) = N_Object_Declaration\n+           and then Is_Finalizable_Transient (Decl, N)\n+         then\n+            Process_Transient_Object (Decl);\n+         end if;\n+\n+         Next (Decl);\n+      end loop;\n+   end Expand_N_Expression_With_Actions;\n+\n+   ----------------------------\n+   -- Expand_N_If_Expression --\n+   ----------------------------\n \n    --  Deal with limited types and condition actions\n \n-   procedure Expand_N_Conditional_Expression (N : Node_Id) is\n+   procedure Expand_N_If_Expression (N : Node_Id) is\n       function Create_Alternative\n         (Loc     : Source_Ptr;\n          Temp_Id : Entity_Id;\n          Flag_Id : Entity_Id;\n          Expr    : Node_Id) return List_Id;\n-      --  Build the statements of a \"then\" or \"else\" conditional expression\n-      --  alternative. Temp_Id is the conditional expression result, Flag_Id\n-      --  is a finalization flag created to service expression Expr.\n+      --  Build the statements of a \"then\" or \"else\" dependent expression\n+      --  alternative. Temp_Id is the if expression result, Flag_Id is a\n+      --  finalization flag created to service expression Expr.\n \n       function Is_Controlled_Function_Call (Expr : Node_Id) return Boolean;\n       --  Determine if expression Expr is a rewritten controlled function call\n@@ -5004,9 +5171,9 @@ package body Exp_Ch4 is\n \n    begin\n       --  Fold at compile time if condition known. We have already folded\n-      --  static conditional expressions, but it is possible to fold any\n-      --  case in which the condition is known at compile time, even though\n-      --  the result is non-static.\n+      --  static if expressions, but it is possible to fold any case in which\n+      --  the condition is known at compile time, even though the result is\n+      --  non-static.\n \n       --  Note that we don't do the fold of such cases in Sem_Elab because\n       --  it can cause infinite loops with the expander adding a conditional\n@@ -5043,7 +5210,7 @@ package body Exp_Ch4 is\n          end if;\n \n          --  Note that the result is never static (legitimate cases of static\n-         --  conditional expressions were folded in Sem_Eval).\n+         --  if expressions were folded in Sem_Eval).\n \n          Set_Is_Static_Expression (N, False);\n          return;\n@@ -5067,7 +5234,7 @@ package body Exp_Ch4 is\n       --         Cnn := else-expr'Unrestricted_Access;\n       --      end if;\n \n-      --  and replace the conditional expression by a reference to Cnn.all.\n+      --  and replace the if expression by a reference to Cnn.all.\n \n       --  This special case can be skipped if the back end handles limited\n       --  types properly and ensures that no incorrect copies are made.\n@@ -5082,7 +5249,7 @@ package body Exp_Ch4 is\n          begin\n             Flag_Id := Empty;\n \n-            --  At least one of the conditional expression alternatives uses a\n+            --  At least one of the if expression dependent expressions uses a\n             --  controlled function to provide the result. Create a status flag\n             --  to signal the finalization machinery that Cnn needs special\n             --  handling.\n@@ -5182,7 +5349,7 @@ package body Exp_Ch4 is\n             --         Cnn := else-expr\n             --      end if;\n \n-            --  and replace the conditional expression by a reference to Cnn\n+            --  and replace the if expression by a reference to Cnn\n \n          else\n             Cnn := Make_Temporary (Loc, 'C', N);\n@@ -5258,174 +5425,7 @@ package body Exp_Ch4 is\n       Insert_Action (N, New_If);\n       Rewrite (N, New_N);\n       Analyze_And_Resolve (N, Typ);\n-   end Expand_N_Conditional_Expression;\n-\n-   -----------------------------------\n-   -- Expand_N_Explicit_Dereference --\n-   -----------------------------------\n-\n-   procedure Expand_N_Explicit_Dereference (N : Node_Id) is\n-   begin\n-      --  Insert explicit dereference call for the checked storage pool case\n-\n-      Insert_Dereference_Action (Prefix (N));\n-\n-      --  If the type is an Atomic type for which Atomic_Sync is enabled, then\n-      --  we set the atomic sync flag.\n-\n-      if Is_Atomic (Etype (N))\n-        and then not Atomic_Synchronization_Disabled (Etype (N))\n-      then\n-         Activate_Atomic_Synchronization (N);\n-      end if;\n-   end Expand_N_Explicit_Dereference;\n-\n-   --------------------------------------\n-   -- Expand_N_Expression_With_Actions --\n-   --------------------------------------\n-\n-   procedure Expand_N_Expression_With_Actions (N : Node_Id) is\n-\n-      procedure Process_Transient_Object (Decl : Node_Id);\n-      --  Given the declaration of a controlled transient declared inside the\n-      --  Actions list of an Expression_With_Actions, generate all necessary\n-      --  types and hooks in order to properly finalize the transient. This\n-      --  mechanism works in conjunction with Build_Finalizer.\n-\n-      ------------------------------\n-      -- Process_Transient_Object --\n-      ------------------------------\n-\n-      procedure Process_Transient_Object (Decl : Node_Id) is\n-\n-         function Find_Insertion_Node return Node_Id;\n-         --  Complex conditions in if statements may be converted into nested\n-         --  EWAs. In this case, any generated code must be inserted before the\n-         --  if statement to ensure proper visibility of the hook objects. This\n-         --  routine returns the top most short circuit operator or the parent\n-         --  of the EWA if no nesting was detected.\n-\n-         -------------------------\n-         -- Find_Insertion_Node --\n-         -------------------------\n-\n-         function Find_Insertion_Node return Node_Id is\n-            Par : Node_Id;\n-\n-         begin\n-            --  Climb up the branches of a complex condition\n-\n-            Par := N;\n-            while Nkind_In (Parent (Par), N_And_Then, N_Op_Not, N_Or_Else) loop\n-               Par := Parent (Par);\n-            end loop;\n-\n-            return Par;\n-         end Find_Insertion_Node;\n-\n-         --  Local variables\n-\n-         Ins_Node  : constant Node_Id    := Find_Insertion_Node;\n-         Loc       : constant Source_Ptr := Sloc (Decl);\n-         Obj_Id    : constant Entity_Id  := Defining_Identifier (Decl);\n-         Obj_Typ   : constant Entity_Id  := Etype (Obj_Id);\n-         Desig_Typ : Entity_Id;\n-         Expr      : Node_Id;\n-         Ptr_Decl  : Node_Id;\n-         Ptr_Id    : Entity_Id;\n-         Temp_Decl : Node_Id;\n-         Temp_Id   : Node_Id;\n-\n-      --  Start of processing for Process_Transient_Object\n-\n-      begin\n-         --  Step 1: Create the access type which provides a reference to the\n-         --  transient object.\n-\n-         if Is_Access_Type (Obj_Typ) then\n-            Desig_Typ := Directly_Designated_Type (Obj_Typ);\n-         else\n-            Desig_Typ := Obj_Typ;\n-         end if;\n-\n-         --  Generate:\n-         --    Ann : access [all] <Desig_Typ>;\n-\n-         Ptr_Id := Make_Temporary (Loc, 'A');\n-\n-         Ptr_Decl :=\n-           Make_Full_Type_Declaration (Loc,\n-             Defining_Identifier => Ptr_Id,\n-             Type_Definition     =>\n-               Make_Access_To_Object_Definition (Loc,\n-                 All_Present        =>\n-                   Ekind (Obj_Typ) = E_General_Access_Type,\n-                 Subtype_Indication => New_Reference_To (Desig_Typ, Loc)));\n-\n-         Insert_Action (Ins_Node, Ptr_Decl);\n-         Analyze (Ptr_Decl);\n-\n-         --  Step 2: Create a temporary which acts as a hook to the transient\n-         --  object. Generate:\n-\n-         --    Temp : Ptr_Id := null;\n-\n-         Temp_Id := Make_Temporary (Loc, 'T');\n-\n-         Temp_Decl :=\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Temp_Id,\n-             Object_Definition   => New_Reference_To (Ptr_Id, Loc));\n-\n-         Insert_Action (Ins_Node, Temp_Decl);\n-         Analyze (Temp_Decl);\n-\n-         --  Mark this temporary as created for the purposes of exporting the\n-         --  transient declaration out of the Actions list. This signals the\n-         --  machinery in Build_Finalizer to recognize this special case.\n-\n-         Set_Status_Flag_Or_Transient_Decl (Temp_Id, Decl);\n-\n-         --  Step 3: Hook the transient object to the temporary\n-\n-         if Is_Access_Type (Obj_Typ) then\n-            Expr := Convert_To (Ptr_Id, New_Reference_To (Obj_Id, Loc));\n-         else\n-            Expr :=\n-              Make_Attribute_Reference (Loc,\n-                Prefix         => New_Reference_To (Obj_Id, Loc),\n-                Attribute_Name => Name_Unrestricted_Access);\n-         end if;\n-\n-         --  Generate:\n-         --    Temp := Ptr_Id (Obj_Id);\n-         --      <or>\n-         --    Temp := Obj_Id'Unrestricted_Access;\n-\n-         Insert_After_And_Analyze (Decl,\n-           Make_Assignment_Statement (Loc,\n-             Name       => New_Reference_To (Temp_Id, Loc),\n-             Expression => Expr));\n-      end Process_Transient_Object;\n-\n-      --  Local variables\n-\n-      Decl : Node_Id;\n-\n-   --  Start of processing for Expand_N_Expression_With_Actions\n-\n-   begin\n-      Decl := First (Actions (N));\n-      while Present (Decl) loop\n-         if Nkind (Decl) = N_Object_Declaration\n-           and then Is_Finalizable_Transient (Decl, N)\n-         then\n-            Process_Transient_Object (Decl);\n-         end if;\n-\n-         Next (Decl);\n-      end loop;\n-   end Expand_N_Expression_With_Actions;\n+   end Expand_N_If_Expression;\n \n    -----------------\n    -- Expand_N_In --\n@@ -7918,7 +7918,7 @@ package body Exp_Ch4 is\n                 ((not LOK) or else (Llo = LLB))\n             then\n                Rewrite (N,\n-                 Make_Conditional_Expression (Loc,\n+                 Make_If_Expression (Loc,\n                    Expressions => New_List (\n                      Make_Op_Eq (Loc,\n                        Left_Opnd => Duplicate_Subexpr (Right),\n@@ -8552,7 +8552,7 @@ package body Exp_Ch4 is\n \n       if Lneg and Rneg then\n          Rewrite (N,\n-           Make_Conditional_Expression (Loc,\n+           Make_If_Expression (Loc,\n              Expressions => New_List (\n                Make_Op_Eq (Loc,\n                  Left_Opnd  => Duplicate_Subexpr (Right),"}, {"sha": "277a7550aa7679b51bbf90eeb60c30a267d42272", "filename": "gcc/ada/exp_ch4.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_ch4.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_ch4.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.ads?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,9 +32,9 @@ package Exp_Ch4 is\n    procedure Expand_N_Allocator                   (N : Node_Id);\n    procedure Expand_N_And_Then                    (N : Node_Id);\n    procedure Expand_N_Case_Expression             (N : Node_Id);\n-   procedure Expand_N_Conditional_Expression      (N : Node_Id);\n    procedure Expand_N_Explicit_Dereference        (N : Node_Id);\n    procedure Expand_N_Expression_With_Actions     (N : Node_Id);\n+   procedure Expand_N_If_Expression               (N : Node_Id);\n    procedure Expand_N_In                          (N : Node_Id);\n    procedure Expand_N_Indexed_Component           (N : Node_Id);\n    procedure Expand_N_Not_In                      (N : Node_Id);"}, {"sha": "85b1c5204e776cd53cdf0d800bde7de9d388a2e6", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -4049,7 +4049,10 @@ package body Exp_Ch6 is\n          Context := Parent (N);\n          while Present (Context) loop\n \n-            if Nkind (Context) = N_Conditional_Expression then\n+            --  The following could use a comment (and why is N_Case_Expression\n+            --  not treated in a similar manner ???\n+\n+            if Nkind (Context) = N_If_Expression then\n                exit;\n \n             --  Stop the search when reaching any statement because we have\n@@ -4092,13 +4095,15 @@ package body Exp_Ch6 is\n \n       Remove_Side_Effects (N);\n \n-      --  The function call is part of a conditional expression alternative.\n-      --  The temporary result must live as long as the conditional expression\n-      --  itself, otherwise it will be finalized too early. Mark the transient\n-      --  as processed to avoid untimely finalization.\n+      --  The function call is part of an if expression dependent expression.\n+      --  The temporary result must live as long as the if expression itself,\n+      --  otherwise it will be finalized too early. Mark the transient as\n+      --  processed to avoid untimely finalization.\n+\n+      --  Why no special handling for case expressions here ???\n \n       if Present (Context)\n-        and then Nkind (Context) = N_Conditional_Expression\n+        and then Nkind (Context) = N_If_Expression\n         and then Nkind (N) = N_Explicit_Dereference\n       then\n          Set_Is_Processed_Transient (Entity (Prefix (N)));"}, {"sha": "78ad5d27d674ce1534259dc350ef8da6068e25f3", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -1892,8 +1892,8 @@ package body Exp_Ch7 is\n                then\n                   Processing_Actions (Has_No_Init => True);\n \n-               --  Process intermediate results of conditional expression with\n-               --  one of the alternatives using a controlled function call.\n+               --  Process intermediate results of an if expression with one\n+               --  of the alternatives using a controlled function call.\n \n                elsif Is_Access_Type (Obj_Typ)\n                  and then Present (Status_Flag_Or_Transient_Decl (Obj_Id))"}, {"sha": "8a7089eff06490c3980dc7bcc53fbc6084226a8f", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -10194,7 +10194,7 @@ package body Exp_Ch9 is\n \n          if Present (Condition (Alt)) then\n             Expr :=\n-              Make_Conditional_Expression (Eloc, New_List (\n+              Make_If_Expression (Eloc, New_List (\n                 Condition (Alt),\n                 Entry_Index_Expression (Eloc, Eent, Index, Scope (Eent)),\n                 New_Reference_To (RTE (RE_Null_Task_Entry), Eloc)));\n@@ -10582,7 +10582,7 @@ package body Exp_Ch9 is\n       --  In the above declaration, null-body is True if the corresponding\n       --  accept has no body, and false otherwise. The entry is either the\n       --  entry index expression if there is no guard, or if a guard is\n-      --  present, then a conditional expression of the form:\n+      --  present, then an if expression of the form:\n \n       --    (if guard then entry-index else Null_Task_Entry)\n \n@@ -10753,7 +10753,7 @@ package body Exp_Ch9 is\n          --  Simple_Mode; otherwise use Terminate_Mode.\n \n          if Present (Condition (Terminate_Alt)) then\n-            Select_Mode := Make_Conditional_Expression (Loc,\n+            Select_Mode := Make_If_Expression (Loc,\n               New_List (Condition (Terminate_Alt),\n                         New_Reference_To (RTE (RE_Terminate_Mode), Loc),\n                         New_Reference_To (RTE (RE_Simple_Mode), Loc)));"}, {"sha": "5da403bb35d60f50c10993eed28edfb4d6f285ad", "filename": "gcc/ada/exp_imgv.adb", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_imgv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_imgv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1063,9 +1063,9 @@ package body Exp_Imgv is\n    --  for depending on the element type for typI.\n \n    --  Finally if Discard_Names is in effect for an enumeration type, then\n-   --  a special conditional expression is built that yields the space needed\n-   --  for the decimal representation of the largest pos value in the subtype.\n-   --  See code below for details.\n+   --  a special if expression is built that yields the space needed for the\n+   --  decimal representation of the largest pos value in the subtype. See\n+   --  code below for details.\n \n    procedure Expand_Width_Attribute (N : Node_Id; Attr : Atype := Normal) is\n       Loc     : constant Source_Ptr := Sloc (N);\n@@ -1134,7 +1134,7 @@ package body Exp_Imgv is\n \n       elsif Is_Real_Type (Rtyp) then\n          Rewrite (N,\n-           Make_Conditional_Expression (Loc,\n+           Make_If_Expression (Loc,\n              Expressions => New_List (\n \n                Make_Op_Gt (Loc,\n@@ -1214,8 +1214,8 @@ package body Exp_Imgv is\n                              Prefix         => New_Occurrence_Of (Ptyp, Loc),\n                              Attribute_Name => Name_Last))))));\n \n-               --  OK, now we need to build the conditional expression. First\n-               --  get the value of M, the largest possible value needed.\n+               --  OK, now we need to build the if expression. First get the\n+               --  value of M, the largest possible value needed.\n \n                P := UI_To_Int\n                       (Enumeration_Pos (Entity (Type_High_Bound (Rtyp))));\n@@ -1238,7 +1238,7 @@ package body Exp_Imgv is\n                   K := K - 1;\n \n                   Cexpr :=\n-                    Make_Conditional_Expression (Loc,\n+                    Make_If_Expression (Loc,\n                       Expressions => New_List (\n                         Make_Op_Lt (Loc,\n                           Left_Opnd  => New_Occurrence_Of (Tnn, Loc),\n@@ -1252,7 +1252,7 @@ package body Exp_Imgv is\n \n                Rewrite (N,\n                  Convert_To (Typ,\n-                   Make_Conditional_Expression (Loc,\n+                   Make_If_Expression (Loc,\n                      Expressions => New_List (\n                        Make_Op_Eq (Loc,\n                          Left_Opnd  =>"}, {"sha": "bc43a4b4e06a7a67657606c9985907f1e4e467c4", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -603,15 +603,15 @@ package body Exp_Intr is\n       --    end if;\n \n       Rewrite (N,\n-        Make_Conditional_Expression (Loc,\n+        Make_If_Expression (Loc,\n           Expressions => New_List (\n             Make_Op_Lt (Loc,\n               Left_Opnd  => Duplicate_Subexpr (Opnd),\n               Right_Opnd => Make_Real_Literal (Loc, Ureal_0)),\n \n             New_Occurrence_Of (Standard_True, Loc),\n \n-            Make_Conditional_Expression (Loc,\n+            Make_If_Expression (Loc,\n              Expressions => New_List (\n                Make_Op_Gt (Loc,\n                  Left_Opnd  => Duplicate_Subexpr_No_Checks (Opnd),\n@@ -1311,7 +1311,7 @@ package body Exp_Intr is\n       Obj := Make_Explicit_Dereference (Loc, Relocate_Node (Arg));\n \n       Rewrite (N,\n-        Make_Conditional_Expression (Loc,\n+        Make_If_Expression (Loc,\n           Expressions => New_List (\n             Make_Op_Eq (Loc,\n               Left_Opnd => New_Copy_Tree (Arg),"}, {"sha": "cb397a24d7144e975df03587674242346c1f7f53", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -3293,11 +3293,11 @@ package body Exp_Util is\n                   return;\n                end if;\n \n-            --  Then or Else operand of conditional expression. Add actions to\n-            --  Then_Actions or Else_Actions field as appropriate. The actions\n-            --  will be moved further out when the conditional is expanded.\n+            --  Then or Else dependent expression of an if expression. Add\n+            --  actions to Then_Actions or Else_Actions field as appropriate.\n+            --  The actions will be moved further out when the if is expanded.\n \n-            when N_Conditional_Expression =>\n+            when N_If_Expression =>\n                declare\n                   ThenX : constant Node_Id := Next (First (Expressions (P)));\n                   ElseX : constant Node_Id := Next (ThenX);\n@@ -3311,9 +3311,9 @@ package body Exp_Util is\n                      null;\n \n                   --  Actions belong to the then expression, temporarily place\n-                  --  them as Then_Actions of the conditional expr. They will\n-                  --  be moved to the proper place later when the conditional\n-                  --  expression is expanded.\n+                  --  them as Then_Actions of the if expression. They will be\n+                  --  moved to the proper place later when the if expression\n+                  --  is expanded.\n \n                   elsif N = ThenX then\n                      if Present (Then_Actions (P)) then\n@@ -3326,10 +3326,10 @@ package body Exp_Util is\n \n                      return;\n \n-                  --  Actions belong to the else expression, temporarily\n-                  --  place them as Else_Actions of the conditional expr.\n-                  --  They will be moved to the proper place later when\n-                  --  the conditional expression is expanded.\n+                  --  Actions belong to the else expression, temporarily place\n+                  --  them as Else_Actions of the if expression. They will be\n+                  --  moved to the proper place later when the if expression\n+                  --  is expanded.\n \n                   elsif N = ElseX then\n                      if Present (Else_Actions (P)) then\n@@ -7187,8 +7187,8 @@ package body Exp_Util is\n             then\n                return True;\n \n-            --  Processing for intermediate results of conditional expressions\n-            --  where one of the alternatives uses a controlled function call.\n+            --  Processing for intermediate results of if expressions where\n+            --  one of the alternatives uses a controlled function call.\n \n             elsif Is_Access_Type (Obj_Typ)\n               and then Present (Status_Flag_Or_Transient_Decl (Obj_Id))"}, {"sha": "f89a0ac1642b6db26473cd08d74cc2faae971d49", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -72,8 +72,8 @@ package Exp_Util is\n    --    For actions appearing in the then or else expression of a conditional\n    --    expression, these actions are similarly placed in the node, using the\n    --    Then_Actions or Else_Actions field as appropriate. Once again the\n-   --    expansion of the N_Conditional_Expression node rewrites the node so\n-   --    that the actions can be normally positioned.\n+   --    expansion of the N_If_Expression node rewrites the node so that the\n+   --    actions can be positioned normally.\n \n    --  Basically what we do is to climb up to the tree looking for the\n    --  proper insertion point, as described by one of the above cases,"}, {"sha": "af367d9512d816f321c1c5f83cca027165f8661a", "filename": "gcc/ada/expander.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexpander.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fexpander.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexpander.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -182,9 +182,6 @@ package body Expander is\n                   when N_Conditional_Entry_Call =>\n                      Expand_N_Conditional_Entry_Call (N);\n \n-                  when N_Conditional_Expression =>\n-                     Expand_N_Conditional_Expression (N);\n-\n                   when N_Delay_Relative_Statement =>\n                      Expand_N_Delay_Relative_Statement (N);\n \n@@ -248,6 +245,9 @@ package body Expander is\n                   when N_Identifier =>\n                      Expand_N_Identifier (N);\n \n+                  when N_If_Expression =>\n+                     Expand_N_If_Expression (N);\n+\n                   when N_Indexed_Component =>\n                      Expand_N_Indexed_Component (N);\n "}, {"sha": "27c98238597bbf928cb860b32a3f3fc891330458", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 119, "deletions": 108, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -1257,29 +1257,33 @@ ada/checks.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/csets.ads ada/debug.ads ada/einfo.ads ada/einfo.adb ada/elists.ads \\\n    ada/elists.adb ada/err_vars.ads ada/errout.ads ada/erroutc.ads \\\n    ada/eval_fat.ads ada/exp_aggr.ads ada/exp_ch11.ads ada/exp_ch2.ads \\\n-   ada/exp_ch4.ads ada/exp_ch6.ads ada/exp_ch7.ads ada/exp_dist.ads \\\n-   ada/exp_pakd.ads ada/exp_tss.ads ada/exp_util.ads ada/exp_util.adb \\\n-   ada/fname.ads ada/fname-uf.ads ada/freeze.ads ada/get_targ.ads \\\n-   ada/gnat.ads ada/g-hesorg.ads ada/g-htable.ads ada/gnatvsn.ads \\\n-   ada/hostparm.ads ada/inline.ads ada/itypes.ads ada/lib.ads ada/lib.adb \\\n-   ada/lib-list.adb ada/lib-load.ads ada/lib-sort.adb ada/namet.ads \\\n+   ada/exp_ch4.ads ada/exp_ch6.ads ada/exp_ch7.ads ada/exp_disp.ads \\\n+   ada/exp_dist.ads ada/exp_pakd.ads ada/exp_tss.ads ada/exp_util.ads \\\n+   ada/exp_util.adb ada/fname.ads ada/fname-uf.ads ada/freeze.ads \\\n+   ada/get_targ.ads ada/gnat.ads ada/g-hesorg.ads ada/g-htable.ads \\\n+   ada/gnatvsn.ads ada/hostparm.ads ada/inline.ads ada/itypes.ads \\\n+   ada/lib.ads ada/lib.adb ada/lib-list.adb ada/lib-load.ads \\\n+   ada/lib-sort.adb ada/lib-util.ads ada/lib-xref.ads ada/namet.ads \\\n    ada/nlists.ads ada/nlists.adb ada/nmake.ads ada/nmake.adb ada/opt.ads \\\n-   ada/opt.adb ada/output.ads ada/restrict.ads ada/restrict.adb \\\n-   ada/rident.ads ada/rtsfind.ads ada/rtsfind.adb ada/sem.ads \\\n-   ada/sem_aux.ads ada/sem_cat.ads ada/sem_ch3.ads ada/sem_ch6.ads \\\n-   ada/sem_ch7.ads ada/sem_ch8.ads ada/sem_dist.ads ada/sem_eval.ads \\\n+   ada/opt.adb ada/output.ads ada/put_alfa.ads ada/restrict.ads \\\n+   ada/restrict.adb ada/rident.ads ada/rtsfind.ads ada/rtsfind.adb \\\n+   ada/scans.ads ada/sem.ads ada/sem_attr.ads ada/sem_aux.ads \\\n+   ada/sem_cat.ads ada/sem_ch3.ads ada/sem_ch6.ads ada/sem_ch7.ads \\\n+   ada/sem_ch8.ads ada/sem_disp.ads ada/sem_dist.ads ada/sem_eval.ads \\\n    ada/sem_eval.adb ada/sem_prag.ads ada/sem_res.ads ada/sem_type.ads \\\n-   ada/sem_util.ads ada/sem_warn.ads ada/sinfo.ads ada/sinfo.adb \\\n-   ada/sinput.ads ada/snames.ads ada/sprint.ads ada/stand.ads \\\n-   ada/stringt.ads ada/system.ads ada/s-exctab.ads ada/s-htable.ads \\\n-   ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n-   ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads \\\n-   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads \\\n-   ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads \\\n-   ada/table.adb ada/targparm.ads ada/tbuild.ads ada/tbuild.adb \\\n-   ada/tree_io.ads ada/ttypes.ads ada/types.ads ada/uintp.ads \\\n-   ada/uintp.adb ada/uname.ads ada/unchconv.ads ada/unchdeal.ads \\\n-   ada/urealp.ads ada/urealp.adb ada/validsw.ads ada/widechar.ads \n+   ada/sem_util.ads ada/sem_util.adb ada/sem_warn.ads ada/sinfo.ads \\\n+   ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/sprint.ads \\\n+   ada/stand.ads ada/stringt.ads ada/style.ads ada/styleg.ads \\\n+   ada/styleg.adb ada/stylesw.ads ada/system.ads ada/s-exctab.ads \\\n+   ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n+   ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads \\\n+   ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n+   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads \\\n+   ada/table.ads ada/table.adb ada/targparm.ads ada/tbuild.ads \\\n+   ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads ada/types.ads \\\n+   ada/uintp.ads ada/uintp.adb ada/uname.ads ada/unchconv.ads \\\n+   ada/unchdeal.ads ada/urealp.ads ada/urealp.adb ada/validsw.ads \\\n+   ada/widechar.ads \n \n ada/comperr.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/aspects.ads ada/atree.ads \\\n@@ -2486,22 +2490,23 @@ ada/lib-load.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/atree.adb ada/casing.ads ada/csets.ads ada/debug.ads ada/einfo.ads \\\n    ada/einfo.adb ada/elists.ads ada/err_vars.ads ada/errout.ads \\\n    ada/erroutc.ads ada/fname.ads ada/fname-uf.ads ada/gnat.ads \\\n-   ada/g-hesorg.ads ada/hostparm.ads ada/interfac.ads ada/lib.ads \\\n-   ada/lib.adb ada/lib-list.adb ada/lib-load.ads ada/lib-load.adb \\\n-   ada/lib-sort.adb ada/namet.ads ada/nlists.ads ada/nmake.ads \\\n-   ada/nmake.adb ada/opt.ads ada/osint.ads ada/osint-c.ads ada/output.ads \\\n-   ada/par.ads ada/restrict.ads ada/rident.ads ada/scans.ads ada/scn.ads \\\n-   ada/scng.ads ada/scng.adb ada/sem_aux.ads ada/sinfo.ads ada/sinfo.adb \\\n-   ada/sinput.ads ada/sinput-l.ads ada/snames.ads ada/stand.ads \\\n-   ada/stringt.ads ada/style.ads ada/styleg.ads ada/styleg.adb \\\n-   ada/stylesw.ads ada/system.ads ada/s-crc32.ads ada/s-exctab.ads \\\n-   ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n-   ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads \\\n-   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads \\\n-   ada/s-traent.ads ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads \\\n-   ada/table.ads ada/table.adb ada/tbuild.ads ada/tbuild.adb \\\n-   ada/tree_io.ads ada/types.ads ada/uintp.ads ada/uname.ads \\\n-   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n+   ada/g-byorma.ads ada/g-hesorg.ads ada/hostparm.ads ada/interfac.ads \\\n+   ada/lib.ads ada/lib.adb ada/lib-list.adb ada/lib-load.ads \\\n+   ada/lib-load.adb ada/lib-sort.adb ada/namet.ads ada/nlists.ads \\\n+   ada/nmake.ads ada/nmake.adb ada/opt.ads ada/osint.ads ada/osint-c.ads \\\n+   ada/output.ads ada/par.ads ada/restrict.ads ada/rident.ads \\\n+   ada/scans.ads ada/scn.ads ada/scng.ads ada/scng.adb ada/sem_aux.ads \\\n+   ada/sinfo.ads ada/sinfo.adb ada/sinput.ads ada/sinput.adb \\\n+   ada/sinput-l.ads ada/snames.ads ada/stand.ads ada/stringt.ads \\\n+   ada/style.ads ada/styleg.ads ada/styleg.adb ada/stylesw.ads \\\n+   ada/system.ads ada/s-crc32.ads ada/s-exctab.ads ada/s-imenne.ads \\\n+   ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads \\\n+   ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n+   ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads \\\n+   ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads ada/table.ads \\\n+   ada/table.adb ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads \\\n+   ada/types.ads ada/uintp.ads ada/uname.ads ada/unchconv.ads \\\n+   ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n \n ada/lib-util.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/debug.ads ada/hostparm.ads \\\n@@ -3116,21 +3121,21 @@ ada/sem_aggr.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/put_alfa.ads ada/restrict.ads ada/rident.ads ada/rtsfind.ads \\\n    ada/scans.ads ada/sem.ads ada/sem_aggr.ads ada/sem_aggr.adb \\\n    ada/sem_attr.ads ada/sem_aux.ads ada/sem_cat.ads ada/sem_ch13.ads \\\n-   ada/sem_ch3.ads ada/sem_ch6.ads ada/sem_ch8.ads ada/sem_disp.ads \\\n-   ada/sem_eval.ads ada/sem_eval.adb ada/sem_prag.ads ada/sem_res.ads \\\n-   ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb ada/sem_warn.ads \\\n-   ada/sinfo.ads ada/sinfo.adb ada/sinput.ads ada/snames.ads \\\n-   ada/sprint.ads ada/stand.ads ada/stringt.ads ada/stringt.adb \\\n-   ada/style.ads ada/styleg.ads ada/styleg.adb ada/stylesw.ads \\\n-   ada/system.ads ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads \\\n-   ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads \\\n-   ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n-   ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads \\\n-   ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n-   ada/targparm.ads ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads \\\n-   ada/ttypes.ads ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n-   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/validsw.ads \\\n-   ada/widechar.ads \n+   ada/sem_ch3.ads ada/sem_ch6.ads ada/sem_ch8.ads ada/sem_dim.ads \\\n+   ada/sem_disp.ads ada/sem_eval.ads ada/sem_eval.adb ada/sem_prag.ads \\\n+   ada/sem_res.ads ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb \\\n+   ada/sem_warn.ads ada/sinfo.ads ada/sinfo.adb ada/sinput.ads \\\n+   ada/snames.ads ada/sprint.ads ada/stand.ads ada/stringt.ads \\\n+   ada/stringt.adb ada/style.ads ada/styleg.ads ada/styleg.adb \\\n+   ada/stylesw.ads ada/system.ads ada/s-exctab.ads ada/s-htable.ads \\\n+   ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n+   ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads \\\n+   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads \\\n+   ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads \\\n+   ada/table.adb ada/targparm.ads ada/tbuild.ads ada/tbuild.adb \\\n+   ada/tree_io.ads ada/ttypes.ads ada/types.ads ada/uintp.ads \\\n+   ada/uintp.adb ada/uname.ads ada/unchconv.ads ada/unchdeal.ads \\\n+   ada/urealp.ads ada/validsw.ads ada/widechar.ads \n \n ada/sem_attr.o : ada/ada.ads ada/a-charac.ads ada/a-chlat1.ads \\\n    ada/a-except.ads ada/a-unccon.ads ada/a-uncdea.ads ada/alloc.ads \\\n@@ -3611,26 +3616,32 @@ ada/sem_ch9.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n \n ada/sem_dim.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/aspects.ads ada/atree.ads \\\n-   ada/atree.adb ada/casing.ads ada/csets.ads ada/debug.ads ada/einfo.ads \\\n-   ada/einfo.adb ada/elists.ads ada/err_vars.ads ada/errout.ads \\\n-   ada/erroutc.ads ada/exp_dist.ads ada/exp_tss.ads ada/fname.ads \\\n-   ada/fname-uf.ads ada/gnat.ads ada/g-hesorg.ads ada/g-htable.ads \\\n-   ada/hostparm.ads ada/lib.ads ada/lib.adb ada/lib-list.adb \\\n-   ada/lib-load.ads ada/lib-sort.adb ada/namet.ads ada/nlists.ads \\\n-   ada/nlists.adb ada/nmake.ads ada/nmake.adb ada/opt.ads ada/output.ads \\\n-   ada/restrict.ads ada/rident.ads ada/rtsfind.ads ada/rtsfind.adb \\\n-   ada/sem.ads ada/sem_aux.ads ada/sem_ch7.ads ada/sem_dim.ads \\\n-   ada/sem_dim.adb ada/sem_dist.ads ada/sem_eval.ads ada/sem_res.ads \\\n-   ada/sem_util.ads ada/sinfo.ads ada/sinfo.adb ada/sinput.ads \\\n-   ada/snames.ads ada/stand.ads ada/stringt.ads ada/stringt.adb \\\n-   ada/system.ads ada/s-exctab.ads ada/s-htable.ads ada/s-htable.adb \\\n-   ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n-   ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads \\\n-   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-strhas.ads \\\n-   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads \\\n-   ada/table.ads ada/table.adb ada/tbuild.ads ada/tbuild.adb \\\n-   ada/tree_io.ads ada/types.ads ada/uintp.ads ada/uname.ads \\\n-   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n+   ada/atree.adb ada/casing.ads ada/checks.ads ada/csets.ads ada/debug.ads \\\n+   ada/einfo.ads ada/einfo.adb ada/elists.ads ada/err_vars.ads \\\n+   ada/errout.ads ada/erroutc.ads ada/exp_ch11.ads ada/exp_disp.ads \\\n+   ada/exp_dist.ads ada/exp_tss.ads ada/exp_util.ads ada/fname.ads \\\n+   ada/fname-uf.ads ada/freeze.ads ada/get_targ.ads ada/gnat.ads \\\n+   ada/g-byorma.ads ada/g-hesorg.ads ada/g-htable.ads ada/hostparm.ads \\\n+   ada/lib.ads ada/lib.adb ada/lib-list.adb ada/lib-load.ads \\\n+   ada/lib-sort.adb ada/lib-util.ads ada/lib-xref.ads ada/namet.ads \\\n+   ada/nlists.ads ada/nlists.adb ada/nmake.ads ada/nmake.adb ada/opt.ads \\\n+   ada/output.ads ada/put_alfa.ads ada/restrict.ads ada/rident.ads \\\n+   ada/rtsfind.ads ada/rtsfind.adb ada/scans.ads ada/sem.ads \\\n+   ada/sem_attr.ads ada/sem_aux.ads ada/sem_ch7.ads ada/sem_ch8.ads \\\n+   ada/sem_dim.ads ada/sem_dim.adb ada/sem_disp.ads ada/sem_dist.ads \\\n+   ada/sem_eval.ads ada/sem_res.ads ada/sem_type.ads ada/sem_util.ads \\\n+   ada/sem_util.adb ada/sinfo.ads ada/sinfo.adb ada/sinput.ads \\\n+   ada/sinput.adb ada/snames.ads ada/stand.ads ada/stringt.ads \\\n+   ada/stringt.adb ada/style.ads ada/styleg.ads ada/styleg.adb \\\n+   ada/stylesw.ads ada/system.ads ada/s-exctab.ads ada/s-htable.ads \\\n+   ada/s-htable.adb ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n+   ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads \\\n+   ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n+   ada/s-strhas.ads ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads \\\n+   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/targparm.ads \\\n+   ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads \\\n+   ada/types.ads ada/uintp.ads ada/uname.ads ada/unchconv.ads \\\n+   ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n \n ada/sem_disp.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/aspects.ads ada/atree.ads \\\n@@ -3685,27 +3696,26 @@ ada/sem_elab.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/err_vars.ads ada/errout.ads ada/erroutc.ads ada/exp_ch11.ads \\\n    ada/exp_disp.ads ada/exp_tss.ads ada/exp_util.ads ada/expander.ads \\\n    ada/fname.ads ada/fname-uf.ads ada/freeze.ads ada/get_targ.ads \\\n-   ada/gnat.ads ada/g-byorma.ads ada/g-hesorg.ads ada/g-htable.ads \\\n-   ada/hostparm.ads ada/lib.ads ada/lib.adb ada/lib-list.adb \\\n-   ada/lib-load.ads ada/lib-sort.adb ada/lib-util.ads ada/lib-xref.ads \\\n-   ada/namet.ads ada/nlists.ads ada/nlists.adb ada/nmake.ads ada/nmake.adb \\\n-   ada/opt.ads ada/output.ads ada/put_alfa.ads ada/restrict.ads \\\n-   ada/restrict.adb ada/rident.ads ada/rtsfind.ads ada/scans.ads \\\n-   ada/sem.ads ada/sem_attr.ads ada/sem_aux.ads ada/sem_cat.ads \\\n-   ada/sem_ch7.ads ada/sem_ch8.ads ada/sem_disp.ads ada/sem_elab.ads \\\n-   ada/sem_elab.adb ada/sem_eval.ads ada/sem_res.ads ada/sem_type.ads \\\n-   ada/sem_util.ads ada/sem_util.adb ada/sinfo.ads ada/sinfo.adb \\\n-   ada/sinput.ads ada/sinput.adb ada/snames.ads ada/stand.ads \\\n-   ada/stringt.ads ada/style.ads ada/styleg.ads ada/styleg.adb \\\n-   ada/stylesw.ads ada/system.ads ada/s-exctab.ads ada/s-htable.ads \\\n-   ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n-   ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads \\\n-   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads \\\n-   ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads \\\n-   ada/table.adb ada/targparm.ads ada/tbuild.ads ada/tbuild.adb \\\n-   ada/tree_io.ads ada/ttypes.ads ada/types.ads ada/uintp.ads \\\n-   ada/uname.ads ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads \\\n-   ada/widechar.ads \n+   ada/gnat.ads ada/g-hesorg.ads ada/g-htable.ads ada/hostparm.ads \\\n+   ada/lib.ads ada/lib.adb ada/lib-list.adb ada/lib-load.ads \\\n+   ada/lib-sort.adb ada/lib-util.ads ada/lib-xref.ads ada/namet.ads \\\n+   ada/nlists.ads ada/nlists.adb ada/nmake.ads ada/nmake.adb ada/opt.ads \\\n+   ada/output.ads ada/put_alfa.ads ada/restrict.ads ada/restrict.adb \\\n+   ada/rident.ads ada/rtsfind.ads ada/scans.ads ada/sem.ads \\\n+   ada/sem_attr.ads ada/sem_aux.ads ada/sem_cat.ads ada/sem_ch7.ads \\\n+   ada/sem_ch8.ads ada/sem_disp.ads ada/sem_elab.ads ada/sem_elab.adb \\\n+   ada/sem_eval.ads ada/sem_res.ads ada/sem_type.ads ada/sem_util.ads \\\n+   ada/sem_util.adb ada/sinfo.ads ada/sinfo.adb ada/sinput.ads \\\n+   ada/snames.ads ada/stand.ads ada/stringt.ads ada/style.ads \\\n+   ada/styleg.ads ada/styleg.adb ada/stylesw.ads ada/system.ads \\\n+   ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads \\\n+   ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads \\\n+   ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads \\\n+   ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads \\\n+   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/targparm.ads \\\n+   ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads \\\n+   ada/types.ads ada/uintp.ads ada/uname.ads ada/unchconv.ads \\\n+   ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n \n ada/sem_elim.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/aspects.ads ada/atree.ads \\\n@@ -4054,22 +4064,23 @@ ada/sinput-d.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n ada/sinput-l.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/aspects.ads ada/atree.ads \\\n    ada/atree.adb ada/casing.ads ada/csets.ads ada/debug.ads ada/einfo.ads \\\n-   ada/err_vars.ads ada/errout.ads ada/erroutc.ads ada/fname.ads \\\n-   ada/gnat.ads ada/g-byorma.ads ada/g-dyntab.ads ada/g-dyntab.adb \\\n-   ada/g-hesorg.ads ada/hostparm.ads ada/interfac.ads ada/lib.ads \\\n-   ada/namet.ads ada/nlists.ads ada/opt.ads ada/osint.ads ada/output.ads \\\n-   ada/prep.ads ada/prepcomp.ads ada/restrict.ads ada/rident.ads \\\n-   ada/scans.ads ada/scn.ads ada/scng.ads ada/scng.adb ada/sinfo.ads \\\n+   ada/einfo.adb ada/err_vars.ads ada/errout.ads ada/erroutc.ads \\\n+   ada/exp_tss.ads ada/fname.ads ada/gnat.ads ada/g-byorma.ads \\\n+   ada/g-dyntab.ads ada/g-dyntab.adb ada/g-hesorg.ads ada/hostparm.ads \\\n+   ada/interfac.ads ada/lib.ads ada/namet.ads ada/nlists.ads ada/nmake.ads \\\n+   ada/opt.ads ada/osint.ads ada/output.ads ada/prep.ads ada/prepcomp.ads \\\n+   ada/restrict.ads ada/rident.ads ada/scans.ads ada/scn.ads ada/scng.ads \\\n+   ada/scng.adb ada/sem_aux.ads ada/sem_util.ads ada/sinfo.ads \\\n    ada/sinfo.adb ada/sinput.ads ada/sinput.adb ada/sinput-l.ads \\\n-   ada/sinput-l.adb ada/snames.ads ada/stringt.ads ada/style.ads \\\n-   ada/styleg.ads ada/styleg.adb ada/stylesw.ads ada/system.ads \\\n-   ada/s-crc32.ads ada/s-exctab.ads ada/s-imenne.ads ada/s-memory.ads \\\n-   ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads \\\n-   ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads \\\n-   ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads \\\n-   ada/s-utf_32.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n-   ada/tree_io.ads ada/types.ads ada/uintp.ads ada/unchconv.ads \\\n-   ada/unchdeal.ads ada/urealp.ads ada/widechar.ads ada/nmake.ads\n+   ada/sinput-l.adb ada/snames.ads ada/stand.ads ada/stringt.ads \\\n+   ada/style.ads ada/styleg.ads ada/styleg.adb ada/stylesw.ads \\\n+   ada/system.ads ada/s-crc32.ads ada/s-exctab.ads ada/s-imenne.ads \\\n+   ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads \\\n+   ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n+   ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads \\\n+   ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads ada/table.ads \\\n+   ada/table.adb ada/tree_io.ads ada/types.ads ada/uintp.ads \\\n+   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n \n ada/sinput.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/aspects.ads ada/atree.ads \\"}, {"sha": "c3e833e408aed48b5b28e3ce36e935e3f462a247", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -5977,7 +5977,7 @@ gnat_to_gnu (Node_Id gnat_node)\n       }\n       break;\n \n-    case N_Conditional_Expression:\n+    case N_If_Expression:\n       {\n \ttree gnu_cond = gnat_to_gnu (First (Expressions (gnat_node)));\n \ttree gnu_true = gnat_to_gnu (Next (First (Expressions (gnat_node))));"}, {"sha": "d6b188337fd5aa4652fca7a37327e5e1169da9d3", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -381,7 +381,7 @@ procedure Gnat1drv is\n \n       --  Set switch indicating if back end can handle limited types, and\n       --  guarantee that no incorrect copies are made (e.g. in the context\n-      --  of a conditional expression).\n+      --  of an if or case expression).\n \n       --  Debug flag -gnatd.L decisively sets usage on\n "}, {"sha": "1f44196bded4702ebb1979542a79dd43624d14c5", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -1964,11 +1964,11 @@ package body Layout is\n          pragma Warnings (Off, SO_Ref);\n \n          RM_Siz_Expr : Node_Id := Empty;\n-         --  Expression for the evolving RM_Siz value. This is typically a\n-         --  conditional expression which involves tests of discriminant values\n-         --  that are formed as references to the entity V. At the end of\n-         --  scanning all the components, a suitable function is constructed\n-         --  in which V is the parameter.\n+         --  Expression for the evolving RM_Siz value. This is typically an if\n+         --  expression which involves tests of discriminant values that are\n+         --  formed as references to the entity V. At the end of scanning all\n+         --  the components, a suitable function is constructed in which V is\n+         --  the parameter.\n \n          -----------------------\n          -- Local Subprograms --\n@@ -2212,7 +2212,7 @@ package body Layout is\n                         end if;\n \n                         RM_Siz_Expr :=\n-                          Make_Conditional_Expression (Loc,\n+                          Make_If_Expression (Loc,\n                             Expressions =>\n                               New_List\n                                 (Dtest, Bits_To_SU (RM_SizV), RM_Siz_Expr));"}, {"sha": "184b09758a350a8a78a7dd3b9c566cc94703932f", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -230,11 +230,12 @@ package Opt is\n    Back_End_Handles_Limited_Types : Boolean;\n    --  This flag is set true if the back end can properly handle limited or\n    --  other by reference types, and avoid copies. If this flag is False, then\n-   --  the front end does special expansion for conditional expressions to make\n+   --  the front end does special expansion for if/case expressions to make\n    --  sure that no copy occurs. If the flag is True, then the expansion for\n-   --  conditional expressions relies on the back end properly handling things.\n+   --  if and case expressions relies on the back end properly handling things.\n    --  Currently the default is False for all cases (set in gnat1drv). The\n-   --  default can be modified using -gnatd.L (sets the flag True).\n+   --  default can be modified using -gnatd.L (sets the flag True). This is\n+   --  used to test the possibility of having the backend handle this.\n \n    Bind_Alternate_Main_Name : Boolean := False;\n    --  GNATBIND"}, {"sha": "df13d005855d8b339004a882cbad7672861338df", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 33, "deletions": 37, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -553,7 +553,7 @@ package body Ch4 is\n          --      case of a name which can be extended in the normal manner.\n          --      This case is handled by LP_State_Name or LP_State_Expr.\n \n-         --      Note: conditional expressions (without an extra level of\n+         --      Note: if and case expressions (without an extra level of\n          --      parentheses) are permitted in this context).\n \n          --   (..., identifier => expression , ...)\n@@ -1233,21 +1233,21 @@ package body Ch4 is\n       Lparen_Sloc := Token_Ptr;\n       T_Left_Paren;\n \n-      --  Conditional expression case\n+      --  If expression\n \n       if Token = Tok_If then\n-         Expr_Node := P_Conditional_Expression;\n+         Expr_Node := P_If_Expression;\n          T_Right_Paren;\n          return Expr_Node;\n \n-      --  Case expression case\n+      --  Case expression\n \n       elsif Token = Tok_Case then\n          Expr_Node := P_Case_Expression;\n          T_Right_Paren;\n          return Expr_Node;\n \n-      --  Quantified expression case\n+      --  Quantified expression\n \n       elsif Token = Tok_For then\n          Expr_Node := P_Quantified_Expression;\n@@ -1258,12 +1258,12 @@ package body Ch4 is\n       --  is distinctly unpleasant, but it saves a lot of fiddling in scanning\n       --  out the discrete choice list.\n \n-      --  Deal with expression and extension aggregate cases first\n+      --  Deal with expression and extension aggregates first\n \n       elsif Token /= Tok_Others then\n          Save_Scan_State (Scan_State); -- at start of expression\n \n-         --  Deal with (NULL RECORD) case\n+         --  Deal with (NULL RECORD)\n \n          if Token = Tok_Null then\n             Scan; -- past NULL\n@@ -1287,7 +1287,7 @@ package body Ch4 is\n             Expr_Node := P_Expression_Or_Range_Attribute_If_OK;\n          end if;\n \n-         --  Extension aggregate case\n+         --  Extension aggregate\n \n          if Token = Tok_With then\n             if Nkind (Expr_Node) = N_Attribute_Reference\n@@ -1329,7 +1329,7 @@ package body Ch4 is\n                Expr_Node := Empty;\n             end if;\n \n-         --  Expression case\n+         --  Expression\n \n          elsif Token = Tok_Right_Paren or else Token in Token_Class_Eterm then\n             if Nkind (Expr_Node) = N_Attribute_Reference\n@@ -1350,13 +1350,13 @@ package body Ch4 is\n             T_Right_Paren; -- past right paren (error message if none)\n             return Expr_Node;\n \n-         --  Normal aggregate case\n+         --  Normal aggregate\n \n          else\n             Aggregate_Node := New_Node (N_Aggregate, Lparen_Sloc);\n          end if;\n \n-      --  Others case\n+      --  Others\n \n       else\n          Aggregate_Node := New_Node (N_Aggregate, Lparen_Sloc);\n@@ -2454,15 +2454,15 @@ package body Ch4 is\n             when Tok_Pragma =>\n                P_Pragmas_Misplaced;\n \n-            --  Deal with IF (possible unparenthesized conditional expression)\n+            --  Deal with IF (possible unparenthesized if expression)\n \n             when Tok_If =>\n \n                --  If this looks like a real if, defined as an IF appearing at\n                --  the start of a new line, then we consider we have a missing\n                --  operand. If in Ada 2012 and the IF is not properly indented\n                --  for a statement, we prefer to issue a message about an ill-\n-               --  parenthesized conditional expression.\n+               --  parenthesized if expression.\n \n                if Token_Is_At_Start_Of_Line\n                  and then not\n@@ -2473,13 +2473,12 @@ package body Ch4 is\n                   Error_Msg_AP (\"missing operand\");\n                   return Error;\n \n-               --  If this looks like a conditional expression, then treat it\n-               --  that way with an error message.\n+               --  If this looks like an if expression, then treat it that way\n+               --  with an error message.\n \n                elsif Ada_Version >= Ada_2012 then\n-                  Error_Msg_SC\n-                    (\"conditional expression must be parenthesized\");\n-                  return P_Conditional_Expression;\n+                  Error_Msg_SC (\"if expression must be parenthesized\");\n+                  return P_If_Expression;\n \n                --  Otherwise treat as misused identifier\n \n@@ -2974,21 +2973,21 @@ package body Ch4 is\n       return Case_Alt_Node;\n    end P_Case_Expression_Alternative;\n \n-   ------------------------------\n-   -- P_Conditional_Expression --\n-   ------------------------------\n+   ---------------------\n+   -- P_If_Expression --\n+   ---------------------\n \n-   function P_Conditional_Expression return Node_Id is\n+   function P_If_Expression return Node_Id is\n       Exprs : constant List_Id    := New_List;\n       Loc   : constant Source_Ptr := Token_Ptr;\n       Expr  : Node_Id;\n       State : Saved_Scan_State;\n \n    begin\n-      Inside_Conditional_Expression := Inside_Conditional_Expression + 1;\n+      Inside_If_Expression := Inside_If_Expression + 1;\n \n       if Token = Tok_If and then Ada_Version < Ada_2012 then\n-         Error_Msg_SC (\"|conditional expression is an Ada 2012 feature\");\n+         Error_Msg_SC (\"|if expression is an Ada 2012 feature\");\n          Error_Msg_SC (\"\\|unit must be compiled with -gnat2012 switch\");\n       end if;\n \n@@ -3017,7 +3016,7 @@ package body Ch4 is\n       --  Scan out ELSIF sequence if present\n \n       if Token = Tok_Elsif then\n-         Expr := P_Conditional_Expression;\n+         Expr := P_If_Expression;\n          Set_Is_Elsif (Expr);\n          Append_To (Exprs, Expr);\n \n@@ -3039,23 +3038,22 @@ package body Ch4 is\n       --  If we have an END IF, diagnose as not needed\n \n       if Token = Tok_End then\n-         Error_Msg_SC\n-           (\"`END IF` not allowed at end of conditional expression\");\n+         Error_Msg_SC (\"`END IF` not allowed at end of if expression\");\n          Scan; -- past END\n \n          if Token = Tok_If then\n             Scan; -- past IF;\n          end if;\n       end if;\n \n-      Inside_Conditional_Expression := Inside_Conditional_Expression - 1;\n+      Inside_If_Expression := Inside_If_Expression - 1;\n \n-      --  Return the Conditional_Expression node\n+      --  Return the If_Expression node\n \n       return\n-        Make_Conditional_Expression (Loc,\n+        Make_If_Expression (Loc,\n           Expressions => Exprs);\n-   end P_Conditional_Expression;\n+   end P_If_Expression;\n \n    -----------------------\n    -- P_Membership_Test --\n@@ -3113,18 +3111,16 @@ package body Ch4 is\n          Result := P_Case_Expression;\n \n          if not (Lparen and then Token = Tok_Right_Paren) then\n-            Error_Msg_N\n-              (\"case expression must be parenthesized!\", Result);\n+            Error_Msg_N (\"case expression must be parenthesized!\", Result);\n          end if;\n \n-      --  Conditional expression\n+      --  If expression\n \n       elsif Token = Tok_If then\n-         Result := P_Conditional_Expression;\n+         Result := P_If_Expression;\n \n          if not (Lparen and then Token = Tok_Right_Paren) then\n-            Error_Msg_N\n-              (\"conditional expression must be parenthesized!\", Result);\n+            Error_Msg_N (\"if expression must be parenthesized!\", Result);\n          end if;\n \n       --  Quantified expression"}, {"sha": "486c0f3da65ed0709e668c198254e70411eb99db", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -694,17 +694,12 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  keyword, and returns pointing to the terminating right parent,\n       --  semicolon, or comma, but does not consume this terminating token.\n \n-      function P_Conditional_Expression return Node_Id;\n-      --  Scans out a conditional expression. Called with Token pointing to\n-      --  the IF keyword, and returns pointing to the terminating right paren,\n-      --  semicolon or comma, but does not consume this terminating token.\n-\n       function P_Expression_If_OK return Node_Id;\n       --  Scans out an expression allowing an unparenthesized case expression,\n-      --  conditional expression, or quantified expression to appear without\n-      --  enclosing parentheses. However, if such an expression is not preceded\n-      --  by a left paren, and followed by a right paren, an error message will\n-      --  be output noting that parenthesization is required.\n+      --  if expression, or quantified expression to appear without enclosing\n+      --  parentheses. However, if such an expression is not preceded by a left\n+      --  paren, and followed by a right paren, an error message will be output\n+      --  noting that parenthesization is required.\n \n       function P_Expression_No_Right_Paren return Node_Id;\n       --  Scans out an expression in contexts where the expression cannot be\n@@ -718,6 +713,11 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  followed by a right paren, an error message will be output noting\n       --  that parenthesization is required.\n \n+      function P_If_Expression return Node_Id;\n+      --  Scans out an if expression. Called with Token pointing to the\n+      --  IF keyword, and returns pointing to the terminating right paren,\n+      --  semicolon or comma, but does not consume this terminating token.\n+\n       function P_Qualified_Expression (Subtype_Mark : Node_Id) return Node_Id;\n       --  This routine scans out a qualified expression when the caller has\n       --  already scanned out the name and apostrophe of the construct."}, {"sha": "be258bfb8b01cac1f785586185cf90d32d2c25c5", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -112,9 +112,9 @@ package body Par_SCO is\n    --  If N is Empty, has no effect. Otherwise scans the tree for the node N,\n    --  to output any decisions it contains. T is one of IEGPWX (for context of\n    --  expression: if/exit when/entry guard/pragma/while/expression). If T is\n-   --  other than X, the node N is the conditional expression involved, and a\n-   --  decision is always present (at the very least a simple decision is\n-   --  present at the top level).\n+   --  other than X, the node N is the if expression involved, and a decision\n+   --  is always present (at the very least a simple decision is present at the\n+   --  top level).\n \n    procedure Process_Decisions\n      (L           : List_Id;\n@@ -614,12 +614,15 @@ package body Par_SCO is\n \n             --  Case expression\n \n+            --  Really hard to believe this is correct given the special\n+            --  handling for if expressions below ???\n+\n             when N_Case_Expression =>\n                return OK; -- ???\n \n-            --  Conditional expression, processed like an if statement\n+            --  If expression, processed like an if statement\n \n-            when N_Conditional_Expression =>\n+            when N_If_Expression =>\n                declare\n                   Cond : constant Node_Id := First (Expressions (N));\n                   Thnx : constant Node_Id := Next (Cond);"}, {"sha": "eb062af42cf69dfabee0e1d5cd06a5f8a16126c6", "filename": "gcc/ada/scans.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fscans.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fscans.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscans.ads?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -464,8 +464,8 @@ package Scans is\n    --  Is it really right for this to be a Name rather than a String, what\n    --  about the case of Wide_Wide_Characters???\n \n-   Inside_Conditional_Expression : Nat := 0;\n-   --  This is a counter that is set non-zero while scanning out a conditional\n+   Inside_If_Expression : Nat := 0;\n+   --  This is a counter that is set non-zero while scanning out an if\n    --  expression (incremented on entry, decremented on exit). It is used to\n    --  disconnect format checks that normally apply to keywords THEN, ELSE etc.\n "}, {"sha": "ce644bc095292f4dd725fca6b8265c3410da154d", "filename": "gcc/ada/scng.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fscng.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fscng.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscng.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -2742,13 +2742,13 @@ package body Scng is\n                end if;\n \n                --  Check THEN/ELSE style rules. These do not apply to AND THEN\n-               --  or OR ELSE, and do not apply in conditional expressions.\n+               --  or OR ELSE, and do not apply in if expressions.\n \n                if (Token = Tok_Then and then Prev_Token /= Tok_And)\n                     or else\n                   (Token = Tok_Else and then Prev_Token /= Tok_Or)\n                then\n-                  if Inside_Conditional_Expression = 0 then\n+                  if Inside_If_Expression = 0 then\n                      Style.Check_Separate_Stmt_Lines;\n                   end if;\n                end if;"}, {"sha": "076a66ef3c96c164ad03bd21ce8963170ad657f8", "filename": "gcc/ada/scos.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fscos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fscos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscos.ads?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -252,7 +252,7 @@ package SCOs is\n \n    --      E  decision in EXIT WHEN statement\n    --      G  decision in entry guard\n-   --      I  decision in IF statement or conditional expression\n+   --      I  decision in IF statement or if expression\n    --      P  decision in pragma Assert/Check/Pre_Condition/Post_Condition\n    --      W  decision in WHILE iteration scheme\n    --      X  decision appearing in some other expression context"}, {"sha": "6aafad8e059bf0999c74db16b2dcc06648162176", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -168,9 +168,6 @@ package body Sem is\n          when N_Component_Declaration =>\n             Analyze_Component_Declaration (N);\n \n-         when N_Conditional_Expression =>\n-            Analyze_Conditional_Expression (N);\n-\n          when N_Conditional_Entry_Call =>\n             Analyze_Conditional_Entry_Call (N);\n \n@@ -279,6 +276,9 @@ package body Sem is\n          when N_Identifier =>\n             Analyze_Identifier (N);\n \n+         when N_If_Expression =>\n+            Analyze_If_Expression (N);\n+\n          when N_If_Statement =>\n             Analyze_If_Statement (N);\n "}, {"sha": "cb54be102151aec1ed73cb38e439a508a39294d8", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -17029,18 +17029,7 @@ package body Sem_Ch3 is\n          when N_Attribute_Reference =>\n             return Attribute_Name (Original_Node (Exp)) = Name_Input;\n \n-         --  For a conditional expression, all dependent expressions must be\n-         --  legal constructs.\n-\n-         when N_Conditional_Expression =>\n-            declare\n-               Then_Expr : constant Node_Id :=\n-                             Next (First (Expressions (Original_Node (Exp))));\n-               Else_Expr : constant Node_Id := Next (Then_Expr);\n-            begin\n-               return OK_For_Limited_Init_In_05 (Typ, Then_Expr)\n-                 and then OK_For_Limited_Init_In_05 (Typ, Else_Expr);\n-            end;\n+         --  For a case expression, all dependent expressions must be legal\n \n          when N_Case_Expression =>\n             declare\n@@ -17059,6 +17048,19 @@ package body Sem_Ch3 is\n                return True;\n             end;\n \n+         --  For an if expression, all dependent expressions must be legal\n+\n+         when N_If_Expression =>\n+            declare\n+               Then_Expr : constant Node_Id :=\n+                             Next (First (Expressions (Original_Node (Exp))));\n+               Else_Expr : constant Node_Id := Next (Then_Expr);\n+            begin\n+               return OK_For_Limited_Init_In_05 (Typ, Then_Expr)\n+                        and then\n+                      OK_For_Limited_Init_In_05 (Typ, Else_Expr);\n+            end;\n+\n          when others =>\n             return False;\n       end case;"}, {"sha": "64b40e6a397cdd3919a19ec27cdf6ee3595aad45", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 73, "deletions": 73, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -1570,79 +1570,6 @@ package body Sem_Ch4 is\n       Operator_Check (N);\n    end Analyze_Concatenation_Rest;\n \n-   ------------------------------------\n-   -- Analyze_Conditional_Expression --\n-   ------------------------------------\n-\n-   procedure Analyze_Conditional_Expression (N : Node_Id) is\n-      Condition : constant Node_Id := First (Expressions (N));\n-      Then_Expr : constant Node_Id := Next (Condition);\n-      Else_Expr : Node_Id;\n-\n-   begin\n-      --  Defend against error of missing expressions from previous error\n-\n-      if No (Then_Expr) then\n-         return;\n-      end if;\n-\n-      Check_SPARK_Restriction (\"conditional expression is not allowed\", N);\n-\n-      Else_Expr := Next (Then_Expr);\n-\n-      if Comes_From_Source (N) then\n-         Check_Compiler_Unit (N);\n-      end if;\n-\n-      Analyze_Expression (Condition);\n-      Analyze_Expression (Then_Expr);\n-\n-      if Present (Else_Expr) then\n-         Analyze_Expression (Else_Expr);\n-      end if;\n-\n-      --  If then expression not overloaded, then that decides the type\n-\n-      if not Is_Overloaded (Then_Expr) then\n-         Set_Etype (N, Etype (Then_Expr));\n-\n-      --  Case where then expression is overloaded\n-\n-      else\n-         declare\n-            I  : Interp_Index;\n-            It : Interp;\n-\n-         begin\n-            Set_Etype (N, Any_Type);\n-\n-            --  Shouldn't the following statement be down in the ELSE of the\n-            --  following loop? ???\n-\n-            Get_First_Interp (Then_Expr, I, It);\n-\n-            --  if no Else_Expression the conditional must be boolean\n-\n-            if No (Else_Expr) then\n-               Set_Etype (N, Standard_Boolean);\n-\n-            --  Else_Expression Present. For each possible intepretation of\n-            --  the Then_Expression, add it only if the Else_Expression has\n-            --  a compatible type.\n-\n-            else\n-               while Present (It.Nam) loop\n-                  if Has_Compatible_Type (Else_Expr, It.Typ) then\n-                     Add_One_Interp (N, It.Typ, It.Typ);\n-                  end if;\n-\n-                  Get_Next_Interp (I, It);\n-               end loop;\n-            end if;\n-         end;\n-      end if;\n-   end Analyze_Conditional_Expression;\n-\n    -------------------------\n    -- Analyze_Equality_Op --\n    -------------------------\n@@ -1981,6 +1908,79 @@ package body Sem_Ch4 is\n       Set_Etype (N, Etype (Expression (N)));\n    end Analyze_Expression_With_Actions;\n \n+   ---------------------------\n+   -- Analyze_If_Expression --\n+   ---------------------------\n+\n+   procedure Analyze_If_Expression (N : Node_Id) is\n+      Condition : constant Node_Id := First (Expressions (N));\n+      Then_Expr : constant Node_Id := Next (Condition);\n+      Else_Expr : Node_Id;\n+\n+   begin\n+      --  Defend against error of missing expressions from previous error\n+\n+      if No (Then_Expr) then\n+         return;\n+      end if;\n+\n+      Check_SPARK_Restriction (\"if expression is not allowed\", N);\n+\n+      Else_Expr := Next (Then_Expr);\n+\n+      if Comes_From_Source (N) then\n+         Check_Compiler_Unit (N);\n+      end if;\n+\n+      Analyze_Expression (Condition);\n+      Analyze_Expression (Then_Expr);\n+\n+      if Present (Else_Expr) then\n+         Analyze_Expression (Else_Expr);\n+      end if;\n+\n+      --  If then expression not overloaded, then that decides the type\n+\n+      if not Is_Overloaded (Then_Expr) then\n+         Set_Etype (N, Etype (Then_Expr));\n+\n+      --  Case where then expression is overloaded\n+\n+      else\n+         declare\n+            I  : Interp_Index;\n+            It : Interp;\n+\n+         begin\n+            Set_Etype (N, Any_Type);\n+\n+            --  Shouldn't the following statement be down in the ELSE of the\n+            --  following loop? ???\n+\n+            Get_First_Interp (Then_Expr, I, It);\n+\n+            --  if no Else_Expression the conditional must be boolean\n+\n+            if No (Else_Expr) then\n+               Set_Etype (N, Standard_Boolean);\n+\n+            --  Else_Expression Present. For each possible intepretation of\n+            --  the Then_Expression, add it only if the Else_Expression has\n+            --  a compatible type.\n+\n+            else\n+               while Present (It.Nam) loop\n+                  if Has_Compatible_Type (Else_Expr, It.Typ) then\n+                     Add_One_Interp (N, It.Typ, It.Typ);\n+                  end if;\n+\n+                  Get_Next_Interp (I, It);\n+               end loop;\n+            end if;\n+         end;\n+      end if;\n+   end Analyze_If_Expression;\n+\n    ------------------------------------\n    -- Analyze_Indexed_Component_Form --\n    ------------------------------------"}, {"sha": "0a196439fb1fe051df4562e77aec463226c276be", "filename": "gcc/ada/sem_ch4.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsem_ch4.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsem_ch4.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.ads?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -33,10 +33,10 @@ package Sem_Ch4  is\n    procedure Analyze_Case_Expression           (N : Node_Id);\n    procedure Analyze_Comparison_Op             (N : Node_Id);\n    procedure Analyze_Concatenation             (N : Node_Id);\n-   procedure Analyze_Conditional_Expression    (N : Node_Id);\n    procedure Analyze_Equality_Op               (N : Node_Id);\n    procedure Analyze_Explicit_Dereference      (N : Node_Id);\n    procedure Analyze_Expression_With_Actions   (N : Node_Id);\n+   procedure Analyze_If_Expression             (N : Node_Id);\n    procedure Analyze_Logical_Op                (N : Node_Id);\n    procedure Analyze_Membership_Op             (N : Node_Id);\n    procedure Analyze_Mod                       (N : Node_Id);"}, {"sha": "2afc4eef15f20240399d30bf1b9cc13d4ab05a93", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -8659,10 +8659,6 @@ package body Sem_Ch6 is\n                    and then\n                  FCE (Expression (E1), Expression (E2));\n \n-            when N_Conditional_Expression =>\n-               return\n-                 FCL (Expressions (E1), Expressions (E2));\n-\n             when N_Explicit_Dereference =>\n                return\n                  FCE (Prefix (E1), Prefix (E2));\n@@ -8682,6 +8678,10 @@ package body Sem_Ch6 is\n                  FCL (Parameter_Associations (E1),\n                       Parameter_Associations (E2));\n \n+            when N_If_Expression =>\n+               return\n+                 FCL (Expressions (E1), Expressions (E2));\n+\n             when N_Indexed_Component =>\n                return\n                  FCE (Prefix (E1), Prefix (E2))"}, {"sha": "be3d7c5f98d5ba811b02d016a7f70e805cd2d0d0", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -1188,7 +1188,7 @@ package body Sem_Elab is\n \n       --  Nothing to do if this is a call already rewritten for elab checking\n \n-      elsif Nkind (Parent (N)) = N_Conditional_Expression then\n+      elsif Nkind (Parent (N)) = N_If_Expression then\n          return;\n \n       --  Nothing to do if inside a generic template\n@@ -2935,7 +2935,8 @@ package body Sem_Elab is\n       --  the context of the call has already been analyzed, an insertion\n       --  will not work if it depends on subsequent expansion (e.g. a call in\n       --  a branch of a short-circuit). In that case we replace the call with\n-      --  a conditional expression, or with a Raise if it is unconditional.\n+      --  an if expression, or with a Raise if it is unconditional.\n+\n       --  Unfortunately this does not work if the call has a dynamic size,\n       --  because gigi regards it as a dynamic-sized temporary. If such a call\n       --  appears in a short-circuit expression, the elaboration check will be\n@@ -2972,14 +2973,14 @@ package body Sem_Elab is\n                   Reloc_N := Relocate_Node (N);\n                   Save_Interps (N, Reloc_N);\n                   Rewrite (N,\n-                    Make_Conditional_Expression (Loc,\n+                    Make_If_Expression (Loc,\n                       Expressions => New_List (C, Reloc_N, R)));\n                end if;\n \n                Analyze_And_Resolve (N, Typ);\n \n                --  If the original call requires a range check, so does the\n-               --  conditional expression.\n+               --  if expression.\n \n                if Chk then\n                   Enable_Range_Check (N);"}, {"sha": "3d13e9c548f5802d4e912cb729a16260af1370ba", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -1872,15 +1872,74 @@ package body Sem_Eval is\n       end;\n    end Eval_Concatenation;\n \n-   ---------------------------------\n-   -- Eval_Conditional_Expression --\n-   ---------------------------------\n+   ----------------------\n+   -- Eval_Entity_Name --\n+   ----------------------\n+\n+   --  This procedure is used for identifiers and expanded names other than\n+   --  named numbers (see Eval_Named_Integer, Eval_Named_Real. These are\n+   --  static if they denote a static constant (RM 4.9(6)) or if the name\n+   --  denotes an enumeration literal (RM 4.9(22)).\n+\n+   procedure Eval_Entity_Name (N : Node_Id) is\n+      Def_Id : constant Entity_Id := Entity (N);\n+      Val    : Node_Id;\n+\n+   begin\n+      --  Enumeration literals are always considered to be constants\n+      --  and cannot raise constraint error (RM 4.9(22)).\n+\n+      if Ekind (Def_Id) = E_Enumeration_Literal then\n+         Set_Is_Static_Expression (N);\n+         return;\n+\n+      --  A name is static if it denotes a static constant (RM 4.9(5)), and\n+      --  we also copy Raise_Constraint_Error. Notice that even if non-static,\n+      --  it does not violate 10.2.1(8) here, since this is not a variable.\n+\n+      elsif Ekind (Def_Id) = E_Constant then\n+\n+         --  Deferred constants must always be treated as nonstatic\n+         --  outside the scope of their full view.\n+\n+         if Present (Full_View (Def_Id))\n+           and then not In_Open_Scopes (Scope (Def_Id))\n+         then\n+            Val := Empty;\n+         else\n+            Val := Constant_Value (Def_Id);\n+         end if;\n+\n+         if Present (Val) then\n+            Set_Is_Static_Expression\n+              (N, Is_Static_Expression (Val)\n+                    and then Is_Static_Subtype (Etype (Def_Id)));\n+            Set_Raises_Constraint_Error (N, Raises_Constraint_Error (Val));\n+\n+            if not Is_Static_Expression (N)\n+              and then not Is_Generic_Type (Etype (N))\n+            then\n+               Validate_Static_Object_Name (N);\n+            end if;\n+\n+            return;\n+         end if;\n+      end if;\n+\n+      --  Fall through if the name is not static\n+\n+      Validate_Static_Object_Name (N);\n+   end Eval_Entity_Name;\n+\n+   ------------------------\n+   -- Eval_If_Expression --\n+   ------------------------\n \n-   --  We can fold to a static expression if the condition and both constituent\n+   --  We can fold to a static expression if the condition and both dependent\n    --  expressions are static. Otherwise, the only required processing is to do\n    --  the check for non-static context for the then and else expressions.\n \n-   procedure Eval_Conditional_Expression (N : Node_Id) is\n+   procedure Eval_If_Expression (N : Node_Id) is\n       Condition  : constant Node_Id := First (Expressions (N));\n       Then_Expr  : constant Node_Id := Next (Condition);\n       Else_Expr  : constant Node_Id := Next (Then_Expr);\n@@ -1949,66 +2008,7 @@ package body Sem_Eval is\n       end if;\n \n       Set_Is_Static_Expression (N, Rstat);\n-   end Eval_Conditional_Expression;\n-\n-   ----------------------\n-   -- Eval_Entity_Name --\n-   ----------------------\n-\n-   --  This procedure is used for identifiers and expanded names other than\n-   --  named numbers (see Eval_Named_Integer, Eval_Named_Real. These are\n-   --  static if they denote a static constant (RM 4.9(6)) or if the name\n-   --  denotes an enumeration literal (RM 4.9(22)).\n-\n-   procedure Eval_Entity_Name (N : Node_Id) is\n-      Def_Id : constant Entity_Id := Entity (N);\n-      Val    : Node_Id;\n-\n-   begin\n-      --  Enumeration literals are always considered to be constants\n-      --  and cannot raise constraint error (RM 4.9(22)).\n-\n-      if Ekind (Def_Id) = E_Enumeration_Literal then\n-         Set_Is_Static_Expression (N);\n-         return;\n-\n-      --  A name is static if it denotes a static constant (RM 4.9(5)), and\n-      --  we also copy Raise_Constraint_Error. Notice that even if non-static,\n-      --  it does not violate 10.2.1(8) here, since this is not a variable.\n-\n-      elsif Ekind (Def_Id) = E_Constant then\n-\n-         --  Deferred constants must always be treated as nonstatic\n-         --  outside the scope of their full view.\n-\n-         if Present (Full_View (Def_Id))\n-           and then not In_Open_Scopes (Scope (Def_Id))\n-         then\n-            Val := Empty;\n-         else\n-            Val := Constant_Value (Def_Id);\n-         end if;\n-\n-         if Present (Val) then\n-            Set_Is_Static_Expression\n-              (N, Is_Static_Expression (Val)\n-                    and then Is_Static_Subtype (Etype (Def_Id)));\n-            Set_Raises_Constraint_Error (N, Raises_Constraint_Error (Val));\n-\n-            if not Is_Static_Expression (N)\n-              and then not Is_Generic_Type (Etype (N))\n-            then\n-               Validate_Static_Object_Name (N);\n-            end if;\n-\n-            return;\n-         end if;\n-      end if;\n-\n-      --  Fall through if the name is not static\n-\n-      Validate_Static_Object_Name (N);\n-   end Eval_Entity_Name;\n+   end Eval_If_Expression;\n \n    ----------------------------\n    -- Eval_Indexed_Component --"}, {"sha": "06607d77897b2c53ff7d0bbe1beab35c67427b27", "filename": "gcc/ada/sem_eval.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -296,8 +296,8 @@ package Sem_Eval is\n    procedure Eval_Case_Expression        (N : Node_Id);\n    procedure Eval_Character_Literal      (N : Node_Id);\n    procedure Eval_Concatenation          (N : Node_Id);\n-   procedure Eval_Conditional_Expression (N : Node_Id);\n    procedure Eval_Entity_Name            (N : Node_Id);\n+   procedure Eval_If_Expression          (N : Node_Id);\n    procedure Eval_Indexed_Component      (N : Node_Id);\n    procedure Eval_Integer_Literal        (N : Node_Id);\n    procedure Eval_Logical_Op             (N : Node_Id);\n@@ -439,7 +439,7 @@ private\n    pragma Inline (Eval_Actual);\n    pragma Inline (Eval_Allocator);\n    pragma Inline (Eval_Character_Literal);\n-   pragma Inline (Eval_Conditional_Expression);\n+   pragma Inline (Eval_If_Expression);\n    pragma Inline (Eval_Indexed_Component);\n    pragma Inline (Eval_Named_Integer);\n    pragma Inline (Eval_Named_Real);"}, {"sha": "e50bcc9740447cae9b65f61e24e4c6c5ea26cc1e", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 96, "deletions": 94, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -178,11 +178,11 @@ package body Sem_Res is\n    procedure Resolve_Case_Expression           (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Character_Literal         (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Comparison_Op             (N : Node_Id; Typ : Entity_Id);\n-   procedure Resolve_Conditional_Expression    (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Entity_Name               (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Equality_Op               (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Explicit_Dereference      (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Expression_With_Actions   (N : Node_Id; Typ : Entity_Id);\n+   procedure Resolve_If_Expression             (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Indexed_Component         (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Integer_Literal           (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Logical_Op                (N : Node_Id; Typ : Entity_Id);\n@@ -834,7 +834,7 @@ package body Sem_Res is\n                          N_And_Then,\n                          N_Case_Expression,\n                          N_Case_Statement,\n-                         N_Conditional_Expression,\n+                         N_If_Expression,\n                          N_If_Statement)\n          then\n             return False;\n@@ -2342,7 +2342,7 @@ package body Sem_Res is\n                elsif Nkind (N) = N_Character_Literal then\n                   Set_Etype (N, Expr_Type);\n \n-               elsif Nkind (N) = N_Conditional_Expression then\n+               elsif Nkind (N) = N_If_Expression then\n                   Set_Etype (N, Expr_Type);\n \n                --  AI05-0139-2: Expression is overloaded because type has\n@@ -2744,9 +2744,6 @@ package body Sem_Res is\n             when N_Character_Literal\n                              => Resolve_Character_Literal        (N, Ctx_Type);\n \n-            when N_Conditional_Expression\n-                             => Resolve_Conditional_Expression   (N, Ctx_Type);\n-\n             when N_Expanded_Name\n                              => Resolve_Entity_Name              (N, Ctx_Type);\n \n@@ -2765,6 +2762,9 @@ package body Sem_Res is\n             when N_Identifier\n                              => Resolve_Entity_Name              (N, Ctx_Type);\n \n+            when N_If_Expression\n+                             => Resolve_If_Expression            (N, Ctx_Type);\n+\n             when N_Indexed_Component\n                              => Resolve_Indexed_Component        (N, Ctx_Type);\n \n@@ -6128,75 +6128,6 @@ package body Sem_Res is\n       Eval_Relational_Op (N);\n    end Resolve_Comparison_Op;\n \n-   ------------------------------------\n-   -- Resolve_Conditional_Expression --\n-   ------------------------------------\n-\n-   procedure Resolve_Conditional_Expression (N : Node_Id; Typ : Entity_Id) is\n-      Condition : constant Node_Id := First (Expressions (N));\n-      Then_Expr : constant Node_Id := Next (Condition);\n-      Else_Expr : Node_Id          := Next (Then_Expr);\n-      Else_Typ  : Entity_Id;\n-      Then_Typ  : Entity_Id;\n-\n-   begin\n-      Resolve (Condition, Any_Boolean);\n-      Resolve (Then_Expr, Typ);\n-      Then_Typ := Etype (Then_Expr);\n-\n-      --  When the \"then\" expression is of a scalar type different from the\n-      --  result type, then insert a conversion to ensure the generation of\n-      --  a constraint check.\n-\n-      if Is_Scalar_Type (Then_Typ)\n-        and then Then_Typ /= Typ\n-      then\n-         Rewrite (Then_Expr, Convert_To (Typ, Then_Expr));\n-         Analyze_And_Resolve (Then_Expr, Typ);\n-      end if;\n-\n-      --  If ELSE expression present, just resolve using the determined type\n-\n-      if Present (Else_Expr) then\n-         Resolve (Else_Expr, Typ);\n-         Else_Typ := Etype (Else_Expr);\n-\n-         if Is_Scalar_Type (Else_Typ)\n-           and then Else_Typ /= Typ\n-         then\n-            Rewrite (Else_Expr, Convert_To (Typ, Else_Expr));\n-            Analyze_And_Resolve (Else_Expr, Typ);\n-         end if;\n-\n-      --  If no ELSE expression is present, root type must be Standard.Boolean\n-      --  and we provide a Standard.True result converted to the appropriate\n-      --  Boolean type (in case it is a derived boolean type).\n-\n-      elsif Root_Type (Typ) = Standard_Boolean then\n-         Else_Expr :=\n-           Convert_To (Typ, New_Occurrence_Of (Standard_True, Sloc (N)));\n-         Analyze_And_Resolve (Else_Expr, Typ);\n-         Append_To (Expressions (N), Else_Expr);\n-\n-      else\n-         Error_Msg_N (\"can only omit ELSE expression in Boolean case\", N);\n-         Append_To (Expressions (N), Error);\n-      end if;\n-\n-      Set_Etype (N, Typ);\n-      Eval_Conditional_Expression (N);\n-\n-      --  If we still have a conditional expression, and overflow checks are\n-      --  enabled in MINIMIZED or ELIMINATED modes, then set Do_Overflow_Check\n-      --  to ensure that we handle overflow for dependent expressions.\n-\n-      if Nkind (N) = N_Conditional_Expression\n-        and then Overflow_Check_Mode (Typ) in Minimized_Or_Eliminated\n-      then\n-         Set_Do_Overflow_Check (N);\n-      end if;\n-   end Resolve_Conditional_Expression;\n-\n    -----------------------------------------\n    -- Resolve_Discrete_Subtype_Indication --\n    -----------------------------------------\n@@ -6863,40 +6794,39 @@ package body Sem_Res is\n       R : constant Node_Id   := Right_Opnd (N);\n       T : Entity_Id := Find_Unique_Type (L, R);\n \n-      procedure Check_Conditional_Expression (Cond : Node_Id);\n-      --  The resolution rule for conditional expressions requires that each\n-      --  such must have a unique type. This means that if several dependent\n-      --  expressions are of a non-null anonymous access type, and the context\n-      --  does not impose an expected type (as can be the case in an equality\n-      --  operation) the expression must be rejected.\n+      procedure Check_If_Expression (Cond : Node_Id);\n+      --  The resolution rule for if expressions requires that each such must\n+      --  have a unique type. This means that if several dependent expressions\n+      --  are of a non-null anonymous access type, and the context does not\n+      --  impose an expected type (as can be the case in an equality operation)\n+      --  the expression must be rejected.\n \n       function Find_Unique_Access_Type return Entity_Id;\n       --  In the case of allocators, make a last-ditch attempt to find a single\n       --  access type with the right designated type. This is semantically\n       --  dubious, and of no interest to any real code, but c48008a makes it\n       --  all worthwhile.\n \n-      ----------------------------------\n-      -- Check_Conditional_Expression --\n-      ----------------------------------\n+      -------------------------\n+      -- Check_If_Expression --\n+      -------------------------\n \n-      procedure Check_Conditional_Expression (Cond : Node_Id) is\n+      procedure Check_If_Expression (Cond : Node_Id) is\n          Then_Expr : Node_Id;\n          Else_Expr : Node_Id;\n \n       begin\n-         if Nkind (Cond) = N_Conditional_Expression then\n+         if Nkind (Cond) = N_If_Expression then\n             Then_Expr := Next (First (Expressions (Cond)));\n             Else_Expr := Next (Then_Expr);\n \n             if Nkind (Then_Expr) /= N_Null\n               and then Nkind (Else_Expr) /= N_Null\n             then\n-               Error_Msg_N\n-                 (\"cannot determine type of conditional expression\", Cond);\n+               Error_Msg_N (\"cannot determine type of if expression\", Cond);\n             end if;\n          end if;\n-      end Check_Conditional_Expression;\n+      end Check_If_Expression;\n \n       -----------------------------\n       -- Find_Unique_Access_Type --\n@@ -6972,18 +6902,20 @@ package body Sem_Res is\n                return;\n             end if;\n \n-         --  Conditional expressions must have a single type, and if the\n-         --  context does not impose one the dependent expressions cannot\n-         --  be anonymous access types.\n+         --  If expressions must have a single type, and if the context does\n+         --  not impose one the dependent expressions cannot be anonymous\n+         --  access types.\n+\n+         --  Why no similar processing for case expressions???\n \n          elsif Ada_Version >= Ada_2012\n            and then Ekind_In (Etype (L), E_Anonymous_Access_Type,\n                                          E_Anonymous_Access_Subprogram_Type)\n            and then Ekind_In (Etype (R), E_Anonymous_Access_Type,\n                                          E_Anonymous_Access_Subprogram_Type)\n          then\n-            Check_Conditional_Expression (L);\n-            Check_Conditional_Expression (R);\n+            Check_If_Expression (L);\n+            Check_If_Expression (R);\n          end if;\n \n          Resolve (L, T);\n@@ -6994,6 +6926,7 @@ package body Sem_Res is\n          --  operands have equal static bounds.\n \n          if Is_Array_Type (T) then\n+\n             --  Protect call to Matching_Static_Array_Bounds to avoid costly\n             --  operation if not needed.\n \n@@ -7208,6 +7141,75 @@ package body Sem_Res is\n       Set_Etype (N, Typ);\n    end Resolve_Expression_With_Actions;\n \n+   ---------------------------\n+   -- Resolve_If_Expression --\n+   ---------------------------\n+\n+   procedure Resolve_If_Expression (N : Node_Id; Typ : Entity_Id) is\n+      Condition : constant Node_Id := First (Expressions (N));\n+      Then_Expr : constant Node_Id := Next (Condition);\n+      Else_Expr : Node_Id          := Next (Then_Expr);\n+      Else_Typ  : Entity_Id;\n+      Then_Typ  : Entity_Id;\n+\n+   begin\n+      Resolve (Condition, Any_Boolean);\n+      Resolve (Then_Expr, Typ);\n+      Then_Typ := Etype (Then_Expr);\n+\n+      --  When the \"then\" expression is of a scalar type different from the\n+      --  result type, then insert a conversion to ensure the generation of\n+      --  a constraint check.\n+\n+      if Is_Scalar_Type (Then_Typ)\n+        and then Then_Typ /= Typ\n+      then\n+         Rewrite (Then_Expr, Convert_To (Typ, Then_Expr));\n+         Analyze_And_Resolve (Then_Expr, Typ);\n+      end if;\n+\n+      --  If ELSE expression present, just resolve using the determined type\n+\n+      if Present (Else_Expr) then\n+         Resolve (Else_Expr, Typ);\n+         Else_Typ := Etype (Else_Expr);\n+\n+         if Is_Scalar_Type (Else_Typ)\n+           and then Else_Typ /= Typ\n+         then\n+            Rewrite (Else_Expr, Convert_To (Typ, Else_Expr));\n+            Analyze_And_Resolve (Else_Expr, Typ);\n+         end if;\n+\n+      --  If no ELSE expression is present, root type must be Standard.Boolean\n+      --  and we provide a Standard.True result converted to the appropriate\n+      --  Boolean type (in case it is a derived boolean type).\n+\n+      elsif Root_Type (Typ) = Standard_Boolean then\n+         Else_Expr :=\n+           Convert_To (Typ, New_Occurrence_Of (Standard_True, Sloc (N)));\n+         Analyze_And_Resolve (Else_Expr, Typ);\n+         Append_To (Expressions (N), Else_Expr);\n+\n+      else\n+         Error_Msg_N (\"can only omit ELSE expression in Boolean case\", N);\n+         Append_To (Expressions (N), Error);\n+      end if;\n+\n+      Set_Etype (N, Typ);\n+      Eval_If_Expression (N);\n+\n+      --  If we still have a if expression, and overflow checks are enabled in\n+      --  MINIMIZED or ELIMINATED modes, then set Do_Overflow_Check to ensure\n+      --  that we handle overflow for dependent expressions.\n+\n+      if Nkind (N) = N_If_Expression\n+        and then Overflow_Check_Mode (Typ) in Minimized_Or_Eliminated\n+      then\n+         Set_Do_Overflow_Check (N);\n+      end if;\n+   end Resolve_If_Expression;\n+\n    -------------------------------\n    -- Resolve_Indexed_Component --\n    -------------------------------"}, {"sha": "ef6b0cbcbc22c619a3d5dfba6902db141892f337", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -2250,9 +2250,9 @@ package body Sem_Util is\n                Msgs := False;\n                exit;\n \n-            --  Conditional expression\n+            --  If expression\n \n-            elsif Nkind (P) = N_Conditional_Expression then\n+            elsif Nkind (P) = N_If_Expression then\n                declare\n                   Cond : constant Node_Id := First (Expressions (P));\n                   Texp : constant Node_Id := Next (Cond);\n@@ -12146,13 +12146,15 @@ package body Sem_Util is\n       begin\n          Desc := N;\n \n+         --  Seems dubious that case expressions are not handled here ???\n+\n          P := Parent (N);\n          while Present (P) loop\n             if         Nkind (P) = N_If_Statement\n               or else  Nkind (P) = N_Case_Statement\n               or else (Nkind (P) in N_Short_Circuit\n                          and then Desc = Right_Opnd (P))\n-              or else (Nkind (P) = N_Conditional_Expression\n+              or else (Nkind (P) = N_If_Expression\n                          and then Desc /= First (Expressions (P)))\n               or else  Nkind (P) = N_Exception_Handler\n               or else  Nkind (P) = N_Selective_Accept"}, {"sha": "7b349de859815e1678e3f7011b4b1befa743d254", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -928,7 +928,7 @@ package body Sinfo is\n         or else NT (N).Nkind in N_Op\n         or else NT (N).Nkind = N_Attribute_Reference\n         or else NT (N).Nkind = N_Case_Expression\n-        or else NT (N).Nkind = N_Conditional_Expression\n+        or else NT (N).Nkind = N_If_Expression\n         or else NT (N).Nkind = N_Type_Conversion);\n       return Flag17 (N);\n    end Do_Overflow_Check;\n@@ -1008,7 +1008,7 @@ package body Sinfo is\n       (N : Node_Id) return List_Id is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Conditional_Expression);\n+        or else NT (N).Nkind = N_If_Expression);\n       return List3 (N);\n    end Else_Actions;\n \n@@ -1247,8 +1247,8 @@ package body Sinfo is\n       pragma Assert (False\n         or else NT (N).Nkind = N_Aggregate\n         or else NT (N).Nkind = N_Attribute_Reference\n-        or else NT (N).Nkind = N_Conditional_Expression\n         or else NT (N).Nkind = N_Extension_Aggregate\n+        or else NT (N).Nkind = N_If_Expression\n         or else NT (N).Nkind = N_Indexed_Component);\n       return List1 (N);\n    end Expressions;\n@@ -1745,7 +1745,7 @@ package body Sinfo is\n      (N : Node_Id) return Boolean is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Conditional_Expression);\n+        or else NT (N).Nkind = N_If_Expression);\n       return Flag13 (N);\n    end Is_Elsif;\n \n@@ -2990,7 +2990,7 @@ package body Sinfo is\n       (N : Node_Id) return List_Id is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Conditional_Expression);\n+        or else NT (N).Nkind = N_If_Expression);\n       return List2 (N);\n    end Then_Actions;\n \n@@ -4001,7 +4001,7 @@ package body Sinfo is\n         or else NT (N).Nkind in N_Op\n         or else NT (N).Nkind = N_Attribute_Reference\n         or else NT (N).Nkind = N_Case_Expression\n-        or else NT (N).Nkind = N_Conditional_Expression\n+        or else NT (N).Nkind = N_If_Expression\n         or else NT (N).Nkind = N_Type_Conversion);\n       Set_Flag17 (N, Val);\n    end Set_Do_Overflow_Check;\n@@ -4081,7 +4081,7 @@ package body Sinfo is\n       (N : Node_Id; Val : List_Id) is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Conditional_Expression);\n+        or else NT (N).Nkind = N_If_Expression);\n       Set_List3 (N, Val); -- semantic field, no parent set\n    end Set_Else_Actions;\n \n@@ -4311,8 +4311,8 @@ package body Sinfo is\n       pragma Assert (False\n         or else NT (N).Nkind = N_Aggregate\n         or else NT (N).Nkind = N_Attribute_Reference\n-        or else NT (N).Nkind = N_Conditional_Expression\n         or else NT (N).Nkind = N_Extension_Aggregate\n+        or else NT (N).Nkind = N_If_Expression\n         or else NT (N).Nkind = N_Indexed_Component);\n       Set_List1_With_Parent (N, Val);\n    end Set_Expressions;\n@@ -4809,7 +4809,7 @@ package body Sinfo is\n      (N : Node_Id; Val : Boolean := True) is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Conditional_Expression);\n+        or else NT (N).Nkind = N_If_Expression);\n       Set_Flag13 (N, Val);\n    end Set_Is_Elsif;\n \n@@ -6054,7 +6054,7 @@ package body Sinfo is\n       (N : Node_Id; Val : List_Id) is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Conditional_Expression);\n+        or else NT (N).Nkind = N_If_Expression);\n       Set_List2 (N, Val); -- semantic field, no parent set\n    end Set_Then_Actions;\n "}, {"sha": "a0f5b52a65f52539835e58705d4f3996e3be66d0", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 21, "deletions": 32, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -824,7 +824,7 @@ package Sinfo is\n    --    attribute references which use this flag are Pred and Succ, where it\n    --    means that the result should be checked for going outside the base\n    --    range. Note that this flag is not set for modular types. This flag is\n-   --    also set on conditional expression nodes if we are operating in either\n+   --    also set on if and case expression nodes if we are operating in either\n    --    MINIMIZED or ELIMINATED overflow checking mode (to make sure that we\n    --    properly process overflow checking for dependent expressions).\n \n@@ -908,12 +908,12 @@ package Sinfo is\n    --    boolean is required.\n \n    --  Else_Actions (List3-Sem)\n-   --    This field is present in conditional expression nodes. During code\n+   --    This field is present in if expression nodes. During code\n    --    expansion we use the Insert_Actions procedure (in Exp_Util) to insert\n    --    actions at an appropriate place in the tree to get elaborated at the\n-   --    right time. For conditional expressions, we have to be sure that the\n-   --    actions for the Else branch are only elaborated if the condition is\n-   --    False. The Else_Actions field is used as a temporary parking place for\n+   --    right time. For if expressions, we have to be sure that the actions\n+   --    for the Else branch are only elaborated if the condition is False.\n+   --    The Else_Actions field is used as a temporary parking place for\n    --    these actions. The final tree is always rewritten to eliminate the\n    --    need for this field, so in the tree passed to Gigi, this field is\n    --    always set to No_List.\n@@ -1761,12 +1761,12 @@ package Sinfo is\n    --    do size validation for.\n \n    --  Then_Actions (List3-Sem)\n-   --    This field is present in conditional expression nodes. During code\n-   --    expansion we use the Insert_Actions procedure (in Exp_Util) to insert\n-   --    actions at an appropriate place in the tree to get elaborated at the\n-   --    right time. For conditional expressions, we have to be sure that the\n-   --    actions for the Then branch are only elaborated if the condition is\n-   --    True. The Then_Actions field is used as a temporary parking place for\n+   --    This field is present in if expression nodes. During code expansion\n+   --    we use the Insert_Actions procedure (in Exp_Util) to insert actions\n+   --    at an appropriate place in the tree to get elaborated at the right\n+   --    time. For if expressions, we have to be sure that the actions for\n+   --    for the Then branch are only elaborated if the condition is True.\n+   --    The Then_Actions field is used as a temporary parking place for\n    --    these actions. The final tree is always rewritten to eliminate the\n    --    need for this field, so in the tree passed to Gigi, this field is\n    --    always set to No_List.\n@@ -3885,15 +3885,9 @@ package Sinfo is\n \n       --  Note: if we have (IF x1 THEN x2 ELSIF x3 THEN x4 ELSE x5) then it\n       --  is represented as (IF x1 THEN x2 ELSE (IF x3 THEN x4 ELSE x5)) and\n-      --  the Is_Elsif flag is set on the inner conditional expression.\n-\n-      --  Note: to be consistent with the grammar, the following node should\n-      --  really be named N_If_Expression, but historically it was always\n-      --  N_Conditional_Expression, so it would be a bit of an earthquake\n-      --  to change, and actually conditional expression seems a bit clearer\n-      --  than if expression in typical contexts, so we decide to leave it!\n+      --  the Is_Elsif flag is set on the inner if expression.\n \n-      --  N_Conditional_Expression\n+      --  N_If_Expression\n       --  Sloc points to IF or ELSIF keyword\n       --  Expressions (List1)\n       --  Then_Actions (List2-Sem)\n@@ -6952,11 +6946,6 @@ package Sinfo is\n    --  reconstructed tree printed by Sprint, and the node descriptions here\n    --  show this syntax.\n \n-   --  Note: Case_Expression and Conditional_Expression is in this section for\n-   --  historical reasons, since they were initially extensions. Now that they\n-   --  are an official part of Ada 2012, we should move them to the appropriate\n-   --  section of this package. ???\n-\n       --------------\n       -- Contract --\n       --------------\n@@ -7639,19 +7628,16 @@ package Sinfo is\n       N_And_Then,\n       N_Or_Else,\n \n-      --  N_Subexpr, N_Has_Etype\n-\n-      N_Conditional_Expression,\n-      N_Explicit_Dereference,\n-      N_Expression_With_Actions,\n-\n       --  N_Subexpr, N_Has_Etype, N_Subprogram_Call\n \n       N_Function_Call,\n       N_Procedure_Call_Statement,\n \n       --  N_Subexpr, N_Has_Etype\n \n+      N_Explicit_Dereference,\n+      N_Expression_With_Actions,\n+      N_If_Expression,\n       N_Indexed_Component,\n       N_Integer_Literal,\n       N_Null,\n@@ -11586,7 +11572,7 @@ package Sinfo is\n         4 => True,    --  Pragmas_Before (List4)\n         5 => False),  --  unused\n \n-     N_Conditional_Expression =>\n+     N_If_Expression =>\n        (1 => True,    --  Expressions (List1)\n         2 => False,   --  Then_Actions (List2-Sem)\n         3 => False,   --  Else_Actions (List3-Sem)\n@@ -12454,6 +12440,9 @@ package Sinfo is\n    --  should refer to N_Simple_Return_Statement.\n \n    N_Parameterized_Expression : constant Node_Kind := N_Expression_Function;\n-   --  Old name for expression functions (used during Ada 2012 transition)\n+   --  Old name for expression function (used during Ada 2012 transition)\n+\n+   N_Conditional_Expression : Node_Kind renames N_If_Expression;\n+   --  Old name for if expression (used during Ada 2012 transition)\n \n end Sinfo;"}, {"sha": "0eee5d5404b95e321fdfa687c3be442e241e693b", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -1320,27 +1320,6 @@ package body Sprint is\n             Sprint_Indented_List (Else_Statements (Node));\n             Write_Indent_Str (\"end select;\");\n \n-         when N_Conditional_Expression =>\n-            declare\n-               Condition : constant Node_Id := First (Expressions (Node));\n-               Then_Expr : constant Node_Id := Next (Condition);\n-\n-            begin\n-               Write_Str_With_Col_Check_Sloc (\"(if \");\n-               Sprint_Node (Condition);\n-               Write_Str_With_Col_Check (\" then \");\n-\n-               --  Defense against junk here!\n-\n-               if Present (Then_Expr) then\n-                  Sprint_Node (Then_Expr);\n-                  Write_Str_With_Col_Check (\" else \");\n-                  Sprint_Node (Next (Then_Expr));\n-               end if;\n-\n-               Write_Char (')');\n-            end;\n-\n          when N_Constrained_Array_Definition =>\n             Write_Str_With_Col_Check_Sloc (\"array \");\n             Sprint_Paren_Comma_List (Discrete_Subtype_Definitions (Node));\n@@ -1978,6 +1957,27 @@ package body Sprint is\n             Set_Debug_Sloc;\n             Write_Id (Node);\n \n+         when N_If_Expression =>\n+            declare\n+               Condition : constant Node_Id := First (Expressions (Node));\n+               Then_Expr : constant Node_Id := Next (Condition);\n+\n+            begin\n+               Write_Str_With_Col_Check_Sloc (\"(if \");\n+               Sprint_Node (Condition);\n+               Write_Str_With_Col_Check (\" then \");\n+\n+               --  Defense against junk here!\n+\n+               if Present (Then_Expr) then\n+                  Sprint_Node (Then_Expr);\n+                  Write_Str_With_Col_Check (\" else \");\n+                  Sprint_Node (Next (Then_Expr));\n+               end if;\n+\n+               Write_Char (')');\n+            end;\n+\n          when N_If_Statement =>\n             Write_Indent_Str_Sloc (\"if \");\n             Sprint_Node (Condition (Node));"}, {"sha": "173d148677d37b3ec71c316d179b984460f31820", "filename": "gcc/ada/sprint.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsprint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fsprint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.ads?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -48,7 +48,6 @@ package Sprint is\n \n    --    Allocator                           new xxx [storage_pool = xxx]\n    --    Cleanup action                      at end procedure name;\n-   --    Conditional expression              (if expr then expr else expr)\n    --    Conversion wi Float_Truncate        target^(source)\n    --    Convert wi Conversion_OK            target?(source)\n    --    Convert wi Rounded_Result           target@(source)"}, {"sha": "b52a8fb1227203c29c53448d1c3e7bb685c784a7", "filename": "gcc/ada/style.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fstyle.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fstyle.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstyle.ads?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -190,8 +190,8 @@ package Style is\n \n    procedure Check_Xtra_Parens (Loc : Source_Ptr)\n      renames Style_Inst.Check_Xtra_Parens;\n-   --  Called after scanning a conditional expression that has at least one\n-   --  level of parentheses around the entire expression.\n+   --  Called after scanning an if, case or quantified expression that has at\n+   --  least one level of parentheses around the entire expression.\n \n    function Mode_In_Check return Boolean\n      renames Style_Inst.Mode_In_Check;"}, {"sha": "06e55341bf1ca3253487715eb136fd0b453bf3a4", "filename": "gcc/ada/styleg.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fstyleg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fstyleg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstyleg.ads?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -151,8 +151,8 @@ package Styleg is\n    --  Called after scanning a vertical bar to check spacing\n \n    procedure Check_Xtra_Parens (Loc : Source_Ptr);\n-   --  Called after scanning a conditional expression that has at least one\n-   --  level of parentheses around the entire expression.\n+   --  Called after scanning an if, case, or quantified expression that has at\n+   --  least one level of parentheses around the entire expression.\n \n    function Mode_In_Check return Boolean;\n    pragma Inline (Mode_In_Check);"}, {"sha": "26fa48097e70f71ac9a96431b654324901911d94", "filename": "gcc/ada/stylesw.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fstylesw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Fstylesw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstylesw.ads?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -268,8 +268,8 @@ package Stylesw is\n \n    Style_Check_Xtra_Parens : Boolean := False;\n    --  This can be set True by using the -gnatyx switch. If true, then it is\n-   --  not allowed to enclose entire conditional expressions in parentheses\n-   --  (C style).\n+   --  not allowed to enclose entire expressions in tests in parentheses\n+   --  (C style), e.g. if (x = y) then ... is not allowed.\n \n    Style_Max_Line_Length : Int := 0;\n    --  Value used to check maximum line length. Gets reset as a result of"}, {"sha": "bd1ef6219560030a59de6632b51eefea6561996d", "filename": "gcc/ada/types.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b16cb57dedec3d7fb690ad7770f2ca9ca85f586/gcc%2Fada%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.h?ref=9b16cb57dedec3d7fb690ad7770f2ca9ca85f586", "patch": "@@ -384,3 +384,4 @@ typedef Int Mechanism_Type;\n #define SE_Object_Too_Large                34\n \n #define LAST_REASON_CODE                   34\n+"}]}