{"sha": "cde34caf144722a64dcda3438eecffa6eb8e7a20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RlMzRjYWYxNDQ3MjJhNjRkY2RhMzQzOGVlY2ZmYTZlYjhlN2EyMA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2001-11-09T18:37:42Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2001-11-09T18:37:42Z"}, "message": "convex.c: Fix comment formatting.\n\n\t* config/convex/convex.c: Fix comment formatting.\n\t* config/convex/convex.h: Likewise.\n\nFrom-SVN: r46886", "tree": {"sha": "12aa743d2771bce26250c8a0e1c728a5938d3c6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12aa743d2771bce26250c8a0e1c728a5938d3c6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cde34caf144722a64dcda3438eecffa6eb8e7a20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cde34caf144722a64dcda3438eecffa6eb8e7a20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cde34caf144722a64dcda3438eecffa6eb8e7a20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cde34caf144722a64dcda3438eecffa6eb8e7a20/comments", "author": null, "committer": null, "parents": [{"sha": "6ca224d34d851d608b4e29da9ff8514a2a850a01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ca224d34d851d608b4e29da9ff8514a2a850a01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ca224d34d851d608b4e29da9ff8514a2a850a01"}], "stats": {"total": 143, "additions": 74, "deletions": 69}, "files": [{"sha": "948f2aa72c809d729a20e4b67c68130eaee1e5a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cde34caf144722a64dcda3438eecffa6eb8e7a20/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cde34caf144722a64dcda3438eecffa6eb8e7a20/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cde34caf144722a64dcda3438eecffa6eb8e7a20", "patch": "@@ -1,3 +1,8 @@\n+2001-11-09  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* config/convex/convex.c: Fix comment formatting.\n+\t* config/convex/convex.h: Likewise.\n+\n 2001-11-08  Zack Weinberg  <zack@codesourcery.com>\n \n \t* Makefile.in (.po.pox): Look both in srcdir and builddir"}, {"sha": "f77ed67efd11e08e5d845f5a88b96b5a56eb9522", "filename": "gcc/config/convex/convex.c", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cde34caf144722a64dcda3438eecffa6eb8e7a20/gcc%2Fconfig%2Fconvex%2Fconvex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cde34caf144722a64dcda3438eecffa6eb8e7a20/gcc%2Fconfig%2Fconvex%2Fconvex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.c?ref=cde34caf144722a64dcda3438eecffa6eb8e7a20", "patch": "@@ -42,16 +42,16 @@ char regno_ok_for_index_p_base[1 + LAST_VIRTUAL_REGISTER + 1];\n enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n enum reg_class reg_class_from_letter[256];\n \n-/* Target cpu index. */\n+/* Target cpu index.  */\n \n int target_cpu;\n \n /* Boolean to keep track of whether the current section is .text or not.\n-   Used by .align handler in convex.h. */\n+   Used by .align handler in convex.h.  */\n \n int current_section_is_text;\n \n-/* Communication between output_compare and output_condjump. */\n+/* Communication between output_compare and output_condjump.  */\n \n static rtx cmp_operand0, cmp_operand1;\n static char cmp_modech;\n@@ -107,26 +107,26 @@ convex_output_function_prologue (file, size)\n    The function epilogue should not depend on the current stack\n    pointer!  It should use the frame pointer only.  This is mandatory\n    because of alloca; we also take advantage of it to omit stack\n-   adjustments before returning. */\n+   adjustments before returning.  */\n \n static void\n convex_output_function_epilogue (file, size)\n      FILE *file;\n      HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n-  /* Follow function with a zero to stop c34 icache prefetching. */\n+  /* Follow function with a zero to stop c34 icache prefetching.  */\n   fprintf (file, \"\\tds.h 0\\n\");\n }\n \n-/* Adjust the cost of dependences. */\n+/* Adjust the cost of dependences.  */\n static int\n convex_adjust_cost (insn, link, dep, cost)\n      rtx insn;\n      rtx link;\n      rtx dep;\n      int cost;\n {\n-  /* Antidependencies don't block issue. */\n+  /* Antidependencies don't block issue.  */\n   if (REG_NOTE_KIND (link) != 0)\n     cost = 0;\n   /* C38 situations where delay depends on context */\n@@ -155,14 +155,14 @@ convex_adjust_cost (insn, link, dep, cost)\n \n \n \n-/* Here from OVERRIDE_OPTIONS at startup.  Initialize constant tables. */\n+/* Here from OVERRIDE_OPTIONS at startup.  Initialize constant tables.  */\n \n void\n init_convex ()\n {\n   int regno;\n \n-  /* Set A and S reg classes. */\n+  /* Set A and S reg classes.  */\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (A_REGNO_P (regno))\n       {\n@@ -175,7 +175,7 @@ init_convex ()\n \tregno_reg_class[regno] = S_REGS;\n       }\n \n-  /* Can't index off the stack pointer, register 0. */\n+  /* Can't index off the stack pointer, register 0.  */\n   regno_ok_for_index_p[STACK_POINTER_REGNUM] = 0;\n   regno_reg_class[STACK_POINTER_REGNUM] = SP_REGS;\n \n@@ -193,7 +193,7 @@ init_convex ()\n   reg_class_from_letter['A'] = INDEX_REGS;\n   reg_class_from_letter['d'] = S_REGS;\n \n-  /* Turn off floating point exception enables in the psw. */\n+  /* Turn off floating point exception enables in the psw.  */\n   psw_disable_float ();\n }\n \n@@ -212,7 +212,7 @@ psw_disable_float ()\n }\n \f\n /* Here to output code for a compare insn.  Output nothing, just\n-   record the operands and their mode. */\n+   record the operands and their mode.  */\n \n const char *\n output_cmp (operand0, operand1, modech)\n@@ -250,7 +250,7 @@ output_condjump (label, cond, jbr_sense)\n   /* [BL] mean the value is being compared against immediate 0.\n      Use neg.x, which produces the same carry that eq.x #0 would if it\n      existed.  In this case operands[1] is a scratch register, not a\n-     compare operand. */\n+     compare operand.  */\n \n   if (cmp_modech == 'B' || cmp_modech == 'L')\n     {\n@@ -260,7 +260,7 @@ output_condjump (label, cond, jbr_sense)\n \n   /* [WH] mean the value being compared resulted from \"add.[wh] #-1,rk\"\n      when rk was nonnegative -- we can omit equality compares against -1\n-     or inequality compares against 0. */\n+     or inequality compares against 0.  */\n \n   else if (cmp_modech == 'W' || cmp_modech == 'H')\n     {\n@@ -274,7 +274,7 @@ output_condjump (label, cond, jbr_sense)\n \n   /* Constant must be first; swap operands if necessary.\n      If lt, le, ltu, leu are swapped, change to le, lt, leu, ltu\n-     and reverse the sense of the jump. */\n+     and reverse the sense of the jump.  */\n \n   if (! REG_P (cmp_operand1))\n     {\n@@ -313,7 +313,7 @@ output_condjump (label, cond, jbr_sense)\n /* Return 1 if OP is valid for cmpsf.\n    In IEEE mode, +/- zero compares are not handled by \n      the immediate versions of eq.s and on some machines, lt.s, and le.s.  \n-   So disallow 0.0 as the immediate operand of xx.s compares in IEEE mode. */\n+   So disallow 0.0 as the immediate operand of xx.s compares in IEEE mode.  */\n \n int\n nonmemory_cmpsf_operand (op, mode)\n@@ -329,7 +329,7 @@ nonmemory_cmpsf_operand (op, mode)\n }\n \f\n /* Convex /bin/as does not like unary minus in some contexts.\n-   Simplify CONST addresses to remove it. */\n+   Simplify CONST addresses to remove it.  */\n \n rtx\n simplify_for_convex (x)\n@@ -355,7 +355,7 @@ simplify_for_convex (x)\n   return x;\n }\n \f\n-/* Routines to separate CONST_DOUBLEs into component parts. */\n+/* Routines to separate CONST_DOUBLEs into component parts.  */\n \n int\n const_double_high_int (x)\n@@ -377,7 +377,7 @@ const_double_low_int (x)\n     return CONST_DOUBLE_LOW (x);\n }\n \f\n-/* Inline block copy. */\n+/* Inline block copy.  */\n \n void\n expand_movstr (operands)\n@@ -394,29 +394,29 @@ expand_movstr (operands)\n \n   /* Decide how many regs to use, depending on load latency, and what\n      size pieces to move, depending on whether machine does unaligned\n-     loads and stores efficiently. */\n+     loads and stores efficiently.  */\n \n   if (TARGET_C1)\n     {\n-      /* ld.l latency is 4, no alignment problems. */\n+      /* ld.l latency is 4, no alignment problems.  */\n       nregs = 3, maxsize = 8;\n     }\n   else if (TARGET_C2)\n     {\n-      /* loads are latency 2 if we avoid ld.l not at least word aligned. */\n+      /* loads are latency 2 if we avoid ld.l not at least word aligned.  */\n       if (align >= 4)\n \tnregs = 2, maxsize = 8;\n       else\n \tnregs = 2, maxsize = 4;\n     }\n   else if (TARGET_C34)\n     {\n-      /* latency is 4 if aligned, horrible if not. */\n+      /* latency is 4 if aligned, horrible if not.  */\n       nregs = 3, maxsize = align;\n     }\n   else if (TARGET_C38)\n     {\n-      /* latency is 2 if at least word aligned, 3 or 4 if unaligned. */\n+      /* latency is 2 if at least word aligned, 3 or 4 if unaligned.  */\n       if (align >= 4)\n \tnregs = 2, maxsize = 8;\n       else\n@@ -426,7 +426,7 @@ expand_movstr (operands)\n     abort ();\n \n   /* Caller is not necessarily prepared for us to fail in this\n-     expansion.  So fall back by generating memcpy call here. */\n+     expansion.  So fall back by generating memcpy call here.  */\n \n   if (GET_CODE (operands[2]) != CONST_INT\n       || (len = INTVAL (operands[2])) > (unsigned) 32 * maxsize)\n@@ -465,7 +465,7 @@ expand_movstr (operands)\n       store = gen_rtx_SET (VOIDmode, dest, reg);\n \n       /* Emit the load and the store from last time. \n-\t When we emit a store, we can reuse its temp reg. */\n+\t When we emit a store, we can reuse its temp reg.  */\n       emit_insn (load);\n       if (prev_store)\n \t{\n@@ -475,20 +475,20 @@ expand_movstr (operands)\n       else\n \treg = 0;\n \n-      /* Queue up the store, for next time or the time after that. */\n+      /* Queue up the store, for next time or the time after that.  */\n       if (nregs == 2)\n \tprev_store = store;\n       else\n \tprev_store = prev_store_2, prev_store_2 = store;\n \n-      /* Advance to next piece. */\n+      /* Advance to next piece.  */\n       size = GET_MODE_SIZE (mode);\n       src = adjust_address (src, mode, size);\n       dest = adjust_address (dest, mode, size);\n       len -= size;\n     }\n \n-  /* Finally, emit the last stores. */\n+  /* Finally, emit the last stores.  */\n   if (prev_store)\n     emit_insn (prev_store);\n   if (prev_store_2)\n@@ -554,7 +554,7 @@ check_float_value (mode, dp, overflow)\n \f\n /* Output the label at the start of a function.\n    Precede it with the number of formal args so debuggers will have\n-   some idea of how many args to print. */\n+   some idea of how many args to print.  */\n \n void\n asm_declare_function_name (file, name, decl)\n@@ -591,7 +591,7 @@ asm_declare_function_name (file, name, decl)\n \f\n /* Print an instruction operand X on file FILE.\n    CODE is the code from the %-spec that requested printing this operand;\n-   if `%z3' was used to print operand 3, then CODE is 'z'. */\n+   if `%z3' was used to print operand 3, then CODE is 'z'.  */\n /* Convex codes:\n     %u prints a CONST_DOUBLE's high word\n     %v prints a CONST_DOUBLE's low word\n@@ -670,7 +670,7 @@ print_operand (file, x, code)\n     }\n }\n \n-/* Print a memory operand whose address is X, on file FILE. */\n+/* Print a memory operand whose address is X, on file FILE.  */\n \n void\n print_operand_address (file, addr)\n@@ -718,7 +718,7 @@ print_operand_address (file, addr)\n }\n \n /* Output a float to FILE, value VALUE, format FMT, preceded by PFX\n-   and followed by SFX. */\n+   and followed by SFX.  */\n \n void\n outfloat (file, value, fmt, pfx, sfx)\n@@ -743,7 +743,7 @@ outfloat (file, value, fmt, pfx, sfx)\n void\n replace_arg_pushes ()\n {\n-  /* Doesn't work yet. */\n+  /* Doesn't work yet.  */\n }\n \n /* Output the insns needed to do a call.  operands[] are\n@@ -777,11 +777,11 @@ output_call (insn, operands)\n }\n \n \n-/* Here after reloading, before the second scheduling pass. */\n+/* Here after reloading, before the second scheduling pass.  */\n \n void\n emit_ap_optimizations ()\n {\n-  /* Removed for now. */\n+  /* Removed for now.  */\n }\n "}, {"sha": "a69d9d2328a1044d07a249893fb8b66943d6e536", "filename": "gcc/config/convex/convex.h", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cde34caf144722a64dcda3438eecffa6eb8e7a20/gcc%2Fconfig%2Fconvex%2Fconvex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cde34caf144722a64dcda3438eecffa6eb8e7a20/gcc%2Fconfig%2Fconvex%2Fconvex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.h?ref=cde34caf144722a64dcda3438eecffa6eb8e7a20", "patch": "@@ -19,7 +19,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n \n-/* Standard GCC variables that we reference. */\n+/* Standard GCC variables that we reference.  */\n \n extern int target_flags;\n \n@@ -107,7 +107,7 @@ extern int target_flags;\n /* Target-dependent specs.\n    Some libraries come in c1 and c2+ versions; use the appropriate ones.\n    Make a target-dependent __convex_cxx__ define to relay the target cpu\n-   to the program being compiled. */\n+   to the program being compiled.  */\n \n #if (TARGET_DEFAULT | TARGET_CPU_DEFAULT) & 1\n \n@@ -416,12 +416,12 @@ extern int target_flags;\n \n #endif\n \n-/* Use /path/libgcc.a instead of -lgcc, makes bootstrap work more smoothly. */\n+/* Use /path/libgcc.a instead of -lgcc, makes bootstrap work more smoothly.  */\n \n #define LINK_LIBGCC_SPECIAL_1\n \n /* Since IEEE support was added to gcc, most things seem to like it\n-   better if we disable exceptions and check afterward for infinity. */\n+   better if we disable exceptions and check afterward for infinity.  */\n \n #if __convex__\n #if _IEEE_FLOAT_\n@@ -436,7 +436,7 @@ extern int target_flags;\n /* Target machine storage layout */\n \n /* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields. */\n+   in instructions that operate on numbered bit-fields.  */\n #define BITS_BIG_ENDIAN 1\n \n /* Define this if most significant byte of a word is the lowest numbered.  */\n@@ -531,19 +531,19 @@ extern int target_flags;\n \n /* List the order in which to allocate registers.  Each register must be\n    listed once, even those in FIXED_REGISTERS.\n-   For Convex, put S0 (the return register) last. */\n+   For Convex, put S0 (the return register) last.  */\n #define REG_ALLOC_ORDER \\\n   { 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 0, 8, 14, 15 }\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n    This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers. */\n+   but can be less for certain modes in special long registers.  */\n #define HARD_REGNO_NREGS(REGNO, MODE) \\\n    ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On Convex, S registers can hold any type, A registers any nonfloat. */\n+   On Convex, S registers can hold any type, A registers any nonfloat.  */\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n   (S_REGNO_P (REGNO)\t\t\t\t\t\t\t\\\n    || (GET_MODE_SIZE (MODE) <= 4 && (MODE) != SFmode))\n@@ -608,7 +608,7 @@ extern int target_flags;\n    \n /* Convex has classes A (address) and S (scalar).\n    A is further divided into SP_REGS (stack pointer) and INDEX_REGS.\n-   SI_REGS is S_REGS + INDEX_REGS -- all the regs except SP. */\n+   SI_REGS is S_REGS + INDEX_REGS -- all the regs except SP.  */\n \n enum reg_class {\n   NO_REGS, S_REGS, INDEX_REGS, SP_REGS, A_REGS, SI_REGS,\n@@ -667,7 +667,7 @@ enum reg_class {\n    C is the letter, and VALUE is a constant value.\n    Return 1 if VALUE is in the range specified by C.  */\n /* 'I' is used to pass any CONST_INT and reject any CONST_DOUBLE.\n-   CONST_DOUBLE integers are handled by G and H constraint chars. */\n+   CONST_DOUBLE integers are handled by G and H constraint chars.  */\n \n #define CONST_OK_FOR_LETTER_P(VALUE, C)  1\n \n@@ -689,7 +689,7 @@ enum reg_class {\n \n /* Optional extra constraints for this machine.\n    For Convex, 'Q' means that OP is a volatile MEM.\n-   For volatile scalars, we use instructions that bypass the data cache. */\n+   For volatile scalars, we use instructions that bypass the data cache.  */\n \n #define EXTRA_CONSTRAINT(OP, C) \\\n   ((C) == 'Q' ? (GET_CODE (OP) == MEM && MEM_VOLATILE_P (OP)\t\t\\\n@@ -701,7 +701,7 @@ enum reg_class {\n    In general this is just CLASS; but on some machines\n    in some cases it is preferable to use a more restrictive class.  */\n \n-/* Put 2-word constants that can't be immediate operands into memory. */\n+/* Put 2-word constants that can't be immediate operands into memory.  */\n \n #define PREFERRED_RELOAD_CLASS(X,CLASS)\t\\\n   ((GET_CODE (X) != CONST_DOUBLE\t\t\t\t\t\\\n@@ -734,7 +734,7 @@ enum reg_class {\n #define STARTING_FRAME_OFFSET 0\n \n /* If we generate an insn to push BYTES bytes,\n-   this says how many the stack pointer really advances by. */\n+   this says how many the stack pointer really advances by.  */\n #define PUSH_ROUNDING(BYTES) (((BYTES) + 3) & ~3)\n \n /* Offset of first parameter from the argument pointer register value.  */\n@@ -772,22 +772,22 @@ enum reg_class {\n \n #define FUNCTION_VALUE_REGNO_P(N) ((N) == S0_REGNUM)\n \n-/* 1 if N is a possible register number for function argument passing. */\n+/* 1 if N is a possible register number for function argument passing.  */\n \n #define FUNCTION_ARG_REGNO_P(N) 0\n \f\n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should\n    hold all necessary information about the function itself\n    and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go. */\n-/* On convex, simply count the arguments in case TARGET_ARGCOUNT is set. */\n+   such as FUNCTION_ARG to determine where the next arg should go.  */\n+/* On convex, simply count the arguments in case TARGET_ARGCOUNT is set.  */\n \n #define CUMULATIVE_ARGS int\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0. */\n+   For a library call, FNTYPE is 0.  */\n \n #define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT) \\\n   ((CUM) = 0)\n@@ -906,7 +906,7 @@ enum reg_class {\n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n \n-/* For convex, bounce 2-word constants that can't be immediate operands. */\n+/* For convex, bounce 2-word constants that can't be immediate operands.  */\n \n #define LEGITIMATE_CONSTANT_P(X) \\\n   (GET_CODE (X) != CONST_DOUBLE\t\t\t\t\t\t\\\n@@ -958,7 +958,7 @@ enum reg_class {\n        const, reg, (PLUS reg const)\n \n    We don't use indirection since with insn scheduling, load + indexing\n-   is better. */\n+   is better.  */\n \n /* 1 if X is an address that we could indirect through.  */\n #define INDIRECTABLE_ADDRESS_P(X)  \\\n@@ -973,7 +973,7 @@ enum reg_class {\n        && REG_OK_FOR_BASE_P (XEXP (X, 1))\t\t\t\t\\\n        && CONSTANT_ADDRESS_P (XEXP (X, 0))))\n \n-/* Go to ADDR if X is a valid address. */\n+/* Go to ADDR if X is a valid address.  */\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n { register rtx xfoob = (X);\t\t\t\t\t\t\\\n   if (INDIRECTABLE_ADDRESS_P (xfoob))\t\t\t\t\t\\\n@@ -1000,7 +1000,7 @@ enum reg_class {\n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)  {}\n \n /* Go to LABEL if ADDR (a legitimate address expression)\n-   has an effect that depends on the machine mode it is used for. */\n+   has an effect that depends on the machine mode it is used for.  */\n \n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  {}\n \f\n@@ -1011,7 +1011,7 @@ enum reg_class {\n /* Define as C expression which evaluates to nonzero if the tablejump\n    instruction expects the table to contain offsets from the address of the\n    table.\n-   Do not define this if the table should contain absolute addresses. */\n+   Do not define this if the table should contain absolute addresses.  */\n /* #define CASE_VECTOR_PC_RELATIVE 1 */\n \n /* Define this if the case instruction drops through after the table\n@@ -1052,7 +1052,7 @@ enum reg_class {\n #define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n \n /* On Convex, it is as good to call a constant function address as to\n-   call an address kept in a register. */\n+   call an address kept in a register.  */\n #define NO_FUNCTION_CSE\n \n /* When a prototype says `char' or `short', really pass an `int'.  */\n@@ -1116,7 +1116,7 @@ enum reg_class {\n #define BRANCH_COST 0\n \n /* Convex uses VAX or IEEE floats.\n-   Follow the host format. */\n+   Follow the host format.  */\n #define TARGET_FLOAT_FORMAT HOST_FLOAT_FORMAT\n \n /* But must prevent real.c from constructing VAX dfloats */\n@@ -1204,7 +1204,7 @@ enum reg_class {\n \n #define DBX_DEBUGGING_INFO\n \n-/* How to renumber registers for dbx and gdb. */\n+/* How to renumber registers for dbx and gdb.  */\n \n #define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n \n@@ -1217,7 +1217,7 @@ enum reg_class {\n \n #define DBX_CONTIN_CHAR '?'\n \n-/* Don't use stab extensions until GDB v4 port is available for convex. */\n+/* Don't use stab extensions until GDB v4 port is available for convex.  */\n \n #define DEFAULT_GDB_EXTENSIONS 0\n #define DBX_NO_XREFS\n@@ -1234,7 +1234,7 @@ enum reg_class {\n #define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n   do { fputs (\".globl \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n \n-/* The prefix to add to user-visible assembler symbols. */\n+/* The prefix to add to user-visible assembler symbols.  */\n \n #define USER_LABEL_PREFIX \"_\"\n \n@@ -1342,7 +1342,7 @@ enum reg_class {\n \t    S_REGNO_P (REGNO) ? 'l' : 'w',\t\\\n \t    reg_names[REGNO])\n \n-/* This is how to output an element of a case-vector that is absolute. */\n+/* This is how to output an element of a case-vector that is absolute.  */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n   fprintf (FILE, \"\\tds.w L%d\\n\", VALUE)\n@@ -1383,19 +1383,19 @@ enum reg_class {\n ( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n   sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n \n-/* Output an arg count before function entries. */\n+/* Output an arg count before function entries.  */\n \n #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\\\n   asm_declare_function_name (FILE, NAME, DECL)\n \n /* Print an instruction operand X on file FILE.\n    CODE is the code from the %-spec that requested printing this operand;\n-   if `%z3' was used to print operand 3, then CODE is 'z'. */\n+   if `%z3' was used to print operand 3, then CODE is 'z'.  */\n \n #define PRINT_OPERAND(FILE, X, CODE)  \\\n     print_operand (FILE, X, CODE)\n \n-/* Print a memory operand whose address is X, on file FILE. */\n+/* Print a memory operand whose address is X, on file FILE.  */\n \n #define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\t\t\t\\\n     print_operand_address (FILE, ADDR)\n@@ -1406,7 +1406,7 @@ enum reg_class {\n #define FASCIST_ASSEMBLER\n \n /* __gcc_cleanup is loader-aliased to __ap$do_registered_functions if we\n-   are linking against standard libc, 0 if old (-traditional) libc. */\n+   are linking against standard libc, 0 if old (-traditional) libc.  */\n \n #define EXIT_BODY \\\n {\t\t\t\t\t\t\t\t\t\\\n@@ -1417,7 +1417,7 @@ enum reg_class {\n }\n \f\n /* Header for convex.c.\n-   Here at the end so we can use types defined above. */\n+   Here at the end so we can use types defined above.  */\n \n extern int target_cpu;\n extern int current_section_is_text;"}]}