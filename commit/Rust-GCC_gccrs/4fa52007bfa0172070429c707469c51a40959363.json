{"sha": "4fa52007bfa0172070429c707469c51a40959363", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZhNTIwMDdiZmEwMTcyMDcwNDI5YzcwNzQ2OWM1MWE0MDk1OTM2Mw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-06-28T11:20:11Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-06-28T11:20:11Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1320", "tree": {"sha": "4c4e3aa0305589612135a557cdd32938c5b9119b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c4e3aa0305589612135a557cdd32938c5b9119b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fa52007bfa0172070429c707469c51a40959363", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fa52007bfa0172070429c707469c51a40959363", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fa52007bfa0172070429c707469c51a40959363", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fa52007bfa0172070429c707469c51a40959363/comments", "author": null, "committer": null, "parents": [{"sha": "7d8d3e323818c04f8e2e68694d6300300c86c524", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d8d3e323818c04f8e2e68694d6300300c86c524", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d8d3e323818c04f8e2e68694d6300300c86c524"}], "stats": {"total": 61, "additions": 60, "deletions": 1}, "files": [{"sha": "5da6892213f9a2cb479e6b78b097045431a2c6b9", "filename": "gcc/expr.c", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fa52007bfa0172070429c707469c51a40959363/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fa52007bfa0172070429c707469c51a40959363/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4fa52007bfa0172070429c707469c51a40959363", "patch": "@@ -102,6 +102,13 @@ static void do_jump_by_parts_equality ();\n static void do_jump_by_parts_equality_rtx ();\n static void do_jump_by_parts_greater ();\n \n+/* Record for each mode whether we can move a register directly to or\n+   from an object of that mode in memory.  If we can't, we won't try\n+   to use that mode directly when accessing a field of that mode.  */\n+\n+static char direct_load[NUM_MACHINE_MODES];\n+static char direct_store[NUM_MACHINE_MODES];\n+\n /* MOVE_RATIO is the number of move instructions that is better than\n    a block move.  */\n \n@@ -121,6 +128,52 @@ static void do_jump_by_parts_greater ();\n #define SLOW_UNALIGNED_ACCESS 0\n #endif\n \f\n+/* This is run once per compilation to set up which modes can be used\n+   directly in memory.  */\n+\n+void\n+init_expr_once ()\n+{\n+  rtx insn, pat;\n+  enum machine_mode mode;\n+  rtx mem = gen_rtx (MEM, VOIDmode, stack_pointer_rtx);\n+\n+  start_sequence ();\n+  insn = emit_insn (gen_rtx (SET, 0, 0));\n+  pat = PATTERN (insn);\n+\n+  for (mode = VOIDmode; (int) mode < NUM_MACHINE_MODES;\n+       mode = (enum machine_mode) ((int) mode + 1))\n+    {\n+      int regno;\n+      rtx reg;\n+      int num_clobbers;\n+\n+      direct_load[(int) mode] = direct_store[(int) mode] = 0;\n+      PUT_MODE (mem, mode);\n+\n+      /* Find a register that can be used in this mode, if any.  */\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\tif (HARD_REGNO_MODE_OK (regno, mode))\n+\t  break;\n+\n+      if (regno == FIRST_PSEUDO_REGISTER)\n+\tcontinue;\n+\n+      reg = gen_rtx (REG, mode, regno);\n+\n+      SET_SRC (pat) = mem;\n+      SET_DEST (pat) = reg;\n+      direct_load[(int) mode] = (recog (pat, insn, &num_clobbers)) >= 0;\n+\n+      SET_SRC (pat) = reg;\n+      SET_DEST (pat) = mem;\n+      direct_store[(int) mode] = (recog (pat, insn, &num_clobbers)) >= 0;\n+    }\n+\n+  end_sequence ();\n+}\n+      \n /* This is run at the start of compiling a function.  */\n \n void\n@@ -635,6 +688,7 @@ convert_move (to, from, unsignedp)\n \t\t\t\tGET_MODE_BITSIZE (from_mode))\n       && ((GET_CODE (from) == MEM\n \t   && ! MEM_VOLATILE_P (from)\n+\t   && direct_load[(int) to_mode]\n \t   && ! mode_dependent_address_p (XEXP (from, 0)))\n \t  || GET_CODE (from) == REG\n \t  || GET_CODE (from) == SUBREG))\n@@ -811,6 +865,7 @@ convert_to_mode (mode, x, unsignedp)\n \t  && (GET_CODE (x) == CONST_DOUBLE\n \t      || (GET_MODE_SIZE (mode) <= GET_MODE_SIZE (GET_MODE (x))\n \t\t  && ((GET_CODE (x) == MEM && ! MEM_VOLATILE_P (x))\n+\t\t      && direct_load[(int) mode]\n \t\t      || GET_CODE (x) == REG)))))\n     return gen_lowpart (mode, x);\n \n@@ -2496,7 +2551,9 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n      is a bit field, we cannot use addressing to access it.\n      Use bit-field techniques or SUBREG to store in it.  */\n \n-  if (mode == VOIDmode || GET_CODE (target) == REG\n+  if (mode == VOIDmode\n+      || (mode != BLKmode && ! direct_store[(int) mode])\n+      || GET_CODE (target) == REG\n       || GET_CODE (target) == SUBREG)\n     {\n       rtx temp = expand_expr (exp, 0, VOIDmode, 0);\n@@ -3587,6 +3644,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  }\n \n \tif (mode1 == VOIDmode\n+\t    || (mode1 != BLKmode && ! direct_load[(int) mode1])\n \t    || GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG)\n \t  {\n \t    /* In cases where an aligned union has an unaligned object"}, {"sha": "5c6dae117790aa176752b8744ba1549723767385", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fa52007bfa0172070429c707469c51a40959363/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fa52007bfa0172070429c707469c51a40959363/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=4fa52007bfa0172070429c707469c51a40959363", "patch": "@@ -1380,6 +1380,7 @@ compile_file (name)\n   init_optabs ();\n   init_stmt ();\n   init_expmed ();\n+  init_expr_once ();\n   init_loop ();\n   init_reload ();\n "}]}