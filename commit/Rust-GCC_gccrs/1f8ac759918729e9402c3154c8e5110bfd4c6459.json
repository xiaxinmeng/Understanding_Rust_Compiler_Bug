{"sha": "1f8ac759918729e9402c3154c8e5110bfd4c6459", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY4YWM3NTk5MTg3MjllOTQwMmMzMTU0YzhlNTExMGJmZDRjNjQ1OQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-11-17T16:01:50Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-11-17T16:10:56Z"}, "message": "preprocessor: module line maps\n\nThis patch adds LC_MODULE as a map kind, used to indicate a c++\nmodule.  Unlike a regular source file, it only contains a single\nlocation, and the source locations in that module are represented by\nordinary locations whose 'included_from' location is the module.\n\nIt also exposes some entry points that modules will use to create\nblocks of line maps.\n\nIn the original posting, I'd missed the deletion of the\nlinemap_enter_macro from internal.h.  That's included here.\n\n\tlibcpp/\n\t* include/line-map.h (enum lc_reason): Add LC_MODULE.\n\t(MAP_MODULE_P): New.\n\t(line_map_new_raw): Declare.\n\t(linemap_enter_macro): Move declaration from internal.h\n\t(linemap_module_loc, linemap_module_reparent)\n\t(linemap_module_restore): Declare.\n\t(linemap_lookup_macro_indec): Declare.\n\t* internal.h (linemap_enter_macro): Moved to line-map.h.\n\t* line-map.c (linemap_new_raw): New, broken out of ...\n\t(new_linemap): ... here.  Call it.\n\t(LAST_SOURCE_LINE_LOCATION): New.\n\t(liemap_module_loc, linemap_module_reparent)\n\t(linemap_module_restore): New.\n\t(linemap_lookup_macro_index): New, broken out of ...\n\t(linemap_macro_map_lookup): ... here.  Call it.\n\t(linemap_dump): Add module dump.", "tree": {"sha": "0ede00b154e9db9f3f6ff98ce76a902bfaa0d86b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ede00b154e9db9f3f6ff98ce76a902bfaa0d86b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f8ac759918729e9402c3154c8e5110bfd4c6459", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f8ac759918729e9402c3154c8e5110bfd4c6459", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f8ac759918729e9402c3154c8e5110bfd4c6459", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f8ac759918729e9402c3154c8e5110bfd4c6459/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b91b3e9df171970a907638d9b2e0bca1e792975", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b91b3e9df171970a907638d9b2e0bca1e792975", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b91b3e9df171970a907638d9b2e0bca1e792975"}], "stats": {"total": 191, "additions": 150, "deletions": 41}, "files": [{"sha": "50b2e4ff91ad26f777f055662efc2e07fedaeaac", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8ac759918729e9402c3154c8e5110bfd4c6459/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8ac759918729e9402c3154c8e5110bfd4c6459/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=1f8ac759918729e9402c3154c8e5110bfd4c6459", "patch": "@@ -72,6 +72,7 @@ enum lc_reason\n   LC_RENAME,\t\t/* Other reason for name change.  */\n   LC_RENAME_VERBATIM,\t/* Likewise, but \"\" != stdin.  */\n   LC_ENTER_MACRO,\t/* Begin macro expansion.  */\n+  LC_MODULE,\t\t/* A (C++) Module.  */\n   /* FIXME: add support for stringize and paste.  */\n   LC_HWM /* High Water Mark.  */\n };\n@@ -439,7 +440,8 @@ struct GTY((tag (\"1\"))) line_map_ordinary : public line_map {\n \n   /* Location from whence this line map was included.  For regular\n      #includes, this location will be the last location of a map.  For\n-     outermost file, this is 0.  */\n+     outermost file, this is 0.  For modules it could be anywhere\n+     within a map.  */\n   location_t included_from;\n \n   /* Size is 20 or 24 bytes, no padding  */\n@@ -662,6 +664,15 @@ ORDINARY_MAP_IN_SYSTEM_HEADER_P (const line_map_ordinary *ord_map)\n   return ord_map->sysp;\n }\n \n+/* TRUE if this line map is for a module (not a source file).  */\n+\n+inline bool\n+MAP_MODULE_P (const line_map *map)\n+{\n+  return (MAP_ORDINARY_P (map)\n+\t  && linemap_check_ordinary (map)->reason == LC_MODULE);\n+}\n+\n /* Get the filename of ordinary map MAP.  */\n \n inline const char *\n@@ -1076,6 +1087,9 @@ extern void linemap_check_files_exited (class line_maps *);\n extern location_t linemap_line_start\n (class line_maps *set, linenum_type to_line,  unsigned int max_column_hint);\n \n+/* Allocate a raw block of line maps, zero initialized.  */\n+extern line_map *line_map_new_raw (line_maps *, bool, unsigned);\n+\n /* Add a mapping of logical source line to physical source file and\n    line number. This function creates an \"ordinary map\", which is a\n    map that records locations of tokens that are not part of macro\n@@ -1093,6 +1107,39 @@ extern const line_map *linemap_add\n   (class line_maps *, enum lc_reason, unsigned int sysp,\n    const char *to_file, linenum_type to_line);\n \n+/* Create a macro map.  A macro map encodes source locations of tokens\n+   that are part of a macro replacement-list, at a macro expansion\n+   point. See the extensive comments of struct line_map and struct\n+   line_map_macro, in line-map.h.\n+\n+   This map shall be created when the macro is expanded. The map\n+   encodes the source location of the expansion point of the macro as\n+   well as the \"original\" source location of each token that is part\n+   of the macro replacement-list. If a macro is defined but never\n+   expanded, it has no macro map.  SET is the set of maps the macro\n+   map should be part of.  MACRO_NODE is the macro which the new macro\n+   map should encode source locations for.  EXPANSION is the location\n+   of the expansion point of MACRO. For function-like macros\n+   invocations, it's best to make it point to the closing parenthesis\n+   of the macro, rather than the the location of the first character\n+   of the macro.  NUM_TOKENS is the number of tokens that are part of\n+   the replacement-list of MACRO.  */\n+const line_map_macro *linemap_enter_macro (line_maps *, cpp_hashnode *,\n+\t\t\t\t\t   location_t, unsigned int);\n+\n+/* Create a source location for a module.  The creator must either do\n+   this after the TU is tokenized, or deal with saving and restoring\n+   map state.  */\n+\n+extern location_t linemap_module_loc\n+  (line_maps *, location_t from, const char *name);\n+extern void linemap_module_reparent\n+  (line_maps *, location_t loc, location_t new_parent);\n+\n+/* Restore the linemap state such that the map at LWM-1 continues.  */\n+extern void linemap_module_restore\n+  (line_maps *, unsigned lwm);\n+\n /* Given a logical source location, returns the map which the\n    corresponding (source file, line, column) triplet can be deduced\n    from. Since the set is built chronologically, the logical lines are\n@@ -1102,6 +1149,8 @@ extern const line_map *linemap_add\n extern const line_map *linemap_lookup\n   (const line_maps *, location_t);\n \n+unsigned linemap_lookup_macro_index (const line_maps *, location_t);\n+\n /* Returns TRUE if the line table set tracks token locations across\n    macro expansion, FALSE otherwise.  */\n bool linemap_tracks_macro_expansion_locs_p (class line_maps *);"}, {"sha": "3f5bafbccde03ca611d916fd7da331181c1de23b", "filename": "libcpp/internal.h", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8ac759918729e9402c3154c8e5110bfd4c6459/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8ac759918729e9402c3154c8e5110bfd4c6459/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=1f8ac759918729e9402c3154c8e5110bfd4c6459", "patch": "@@ -868,29 +868,7 @@ ufputs (const unsigned char *s, FILE *f)\n   return fputs ((const char *)s, f);\n }\n \n-  /* In line-map.c.  */\n-\n-/* Create a macro map.  A macro map encodes source locations of tokens\n-   that are part of a macro replacement-list, at a macro expansion\n-   point. See the extensive comments of struct line_map and struct\n-   line_map_macro, in line-map.h.\n-\n-   This map shall be created when the macro is expanded. The map\n-   encodes the source location of the expansion point of the macro as\n-   well as the \"original\" source location of each token that is part\n-   of the macro replacement-list. If a macro is defined but never\n-   expanded, it has no macro map.  SET is the set of maps the macro\n-   map should be part of.  MACRO_NODE is the macro which the new macro\n-   map should encode source locations for.  EXPANSION is the location\n-   of the expansion point of MACRO. For function-like macros\n-   invocations, it's best to make it point to the closing parenthesis\n-   of the macro, rather than the the location of the first character\n-   of the macro.  NUM_TOKENS is the number of tokens that are part of\n-   the replacement-list of MACRO.  */\n-const line_map_macro *linemap_enter_macro (class line_maps *,\n-\t\t\t\t\t   struct cpp_hashnode*,\n-\t\t\t\t\t   location_t,\n-\t\t\t\t\t   unsigned int);\n+/* In line-map.c.  */\n \n /* Create and return a virtual location for a token that is part of a\n    macro expansion-list at a macro expansion point.  See the comment"}, {"sha": "bbb6963b8d90f0afe8804f7d286cecf09c685cdb", "filename": "libcpp/line-map.c", "status": "modified", "additions": 99, "deletions": 17, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f8ac759918729e9402c3154c8e5110bfd4c6459/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f8ac759918729e9402c3154c8e5110bfd4c6459/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=1f8ac759918729e9402c3154c8e5110bfd4c6459", "patch": "@@ -378,23 +378,21 @@ linemap_check_files_exited (line_maps *set)\n \t     ORDINARY_MAP_FILE_NAME (map));\n }\n \n-/* Create a new line map in the line map set SET, and return it.\n-   REASON is the reason of creating the map. It determines the type\n-   of map created (ordinary or macro map). Note that ordinary maps and\n-   macro maps are allocated in different memory location.  */\n+/* Create NUM zero-initialized maps of type MACRO_P.  */\n \n-static struct line_map *\n-new_linemap (line_maps *set,  location_t start_location)\n+line_map *\n+line_map_new_raw (line_maps *set, bool macro_p, unsigned num)\n {\n-  bool macro_p = start_location >= LINE_MAP_MAX_LOCATION;\n   unsigned num_maps_allocated = LINEMAPS_ALLOCATED (set, macro_p);\n   unsigned num_maps_used = LINEMAPS_USED (set, macro_p);\n-\n-  if (num_maps_used == num_maps_allocated)\n+  \n+  if (num > num_maps_allocated - num_maps_used)\n     {\n       /* We need more space!  */\n       if (!num_maps_allocated)\n \tnum_maps_allocated = 128;\n+      if (num_maps_allocated < num_maps_used + num)\n+\tnum_maps_allocated = num_maps_used + num;\n       num_maps_allocated *= 2;\n \n       size_t size_of_a_map;\n@@ -436,13 +434,39 @@ new_linemap (line_maps *set,  location_t start_location)\n \n   line_map *result = (macro_p ? (line_map *)&set->info_macro.maps[num_maps_used]\n \t\t      : (line_map *)&set->info_ordinary.maps[num_maps_used]);\n-  LINEMAPS_USED (set, macro_p)++;\n+  LINEMAPS_USED (set, macro_p) += num;\n+\n+  return result;\n+}\n+\n+/* Create a new line map in the line map set SET, and return it.\n+   REASON is the reason of creating the map. It determines the type\n+   of map created (ordinary or macro map). Note that ordinary maps and\n+   macro maps are allocated in different memory location.  */\n+\n+static struct line_map *\n+new_linemap (line_maps *set, location_t start_location)\n+{\n+  line_map *result = line_map_new_raw (set,\n+\t\t\t\t       start_location >= LINE_MAP_MAX_LOCATION,\n+\t\t\t\t       1);\n \n   result->start_location = start_location;\n \n   return result;\n }\n \n+/* Return the location of the last source line within an ordinary\n+   map.  */\n+inline location_t\n+LAST_SOURCE_LINE_LOCATION (const line_map_ordinary *map)\n+{\n+  return (((map[1].start_location - 1\n+\t    - map->start_location)\n+\t   & ~((1 << map->m_column_and_range_bits) - 1))\n+\t  + map->start_location);\n+}\n+\n /* Add a mapping of logical source line to physical source file and\n    line number.\n \n@@ -570,6 +594,56 @@ linemap_add (line_maps *set, enum lc_reason reason,\n   return map;\n }\n \n+/* Create a location for a module NAME imported at FROM.  */\n+\n+location_t\n+linemap_module_loc (line_maps *set, location_t from, const char *name)\n+{\n+  const line_map_ordinary *map\n+    = linemap_check_ordinary (linemap_add (set, LC_MODULE, false, name, 0));\n+  const_cast <line_map_ordinary *> (map)->included_from = from;\n+\n+  location_t loc = linemap_line_start (set, 0, 0);\n+\n+  return loc;\n+}\n+\n+/* The linemap containing LOC is being reparented to be\n+   imported/included from ADOPTOR.  This can happen when an\n+   indirectly imported module is then directly imported, or when\n+   partitions are involved.  */\n+\n+void\n+linemap_module_reparent (line_maps *set, location_t loc, location_t adoptor)\n+{\n+  const line_map_ordinary *map = linemap_ordinary_map_lookup (set, loc);\n+  const_cast<line_map_ordinary *> (map)->included_from = adoptor;\n+}\n+\n+/* A linemap at LWM-1 was interrupted to insert module locations & imports.\n+   Append a new map, continuing the interrupted one.  */\n+\n+void\n+linemap_module_restore (line_maps *set, unsigned lwm)\n+{\n+  if (lwm && lwm != LINEMAPS_USED (set, false))\n+    {\n+      const line_map_ordinary *pre_map\n+\t= linemap_check_ordinary (LINEMAPS_MAP_AT (set, false, lwm - 1));\n+      unsigned src_line = SOURCE_LINE (pre_map,\n+\t\t\t\t       LAST_SOURCE_LINE_LOCATION (pre_map));\n+      location_t inc_at = pre_map->included_from;\n+      if (const line_map_ordinary *post_map\n+\t  = (linemap_check_ordinary\n+\t     (linemap_add (set, LC_RENAME_VERBATIM,\n+\t\t\t   ORDINARY_MAP_IN_SYSTEM_HEADER_P (pre_map),\n+\t\t\t   ORDINARY_MAP_FILE_NAME (pre_map), src_line))))\n+\t/* linemap_add will think we were included from the same as\n+\t   the preceeding map.  */\n+\tconst_cast <line_map_ordinary *> (post_map)->included_from = inc_at;\n+    }\n+}\n+\n /* Returns TRUE if the line table set tracks token locations across\n    macro expansion, FALSE otherwise.  */\n \n@@ -1003,14 +1077,25 @@ linemap_macro_map_lookup (const line_maps *set, location_t line)\n   if (set == NULL)\n     return NULL;\n \n+  unsigned ix = linemap_lookup_macro_index (set, line);\n+  const struct line_map_macro *result = LINEMAPS_MACRO_MAP_AT (set, ix);\n+  linemap_assert (MAP_START_LOCATION (result) <= line);\n+\n+  return result;\n+}\n+\n+unsigned\n+linemap_lookup_macro_index (const line_maps *set, location_t line)\n+{\n   unsigned mn = LINEMAPS_MACRO_CACHE (set);\n   unsigned mx = LINEMAPS_MACRO_USED (set);\n   const struct line_map_macro *cached = LINEMAPS_MACRO_MAP_AT (set, mn);\n \n   if (line >= MAP_START_LOCATION (cached))\n     {\n-      if (mn == 0 || line < MAP_START_LOCATION (&cached[-1]))\n-\treturn cached;\n+      if (line < (MAP_START_LOCATION (cached)\n+\t\t  + MACRO_MAP_NUM_MACRO_TOKENS (cached)))\n+\treturn mn;\n       mx = mn - 1;\n       mn = 0;\n     }\n@@ -1025,10 +1110,7 @@ linemap_macro_map_lookup (const line_maps *set, location_t line)\n     }\n \n   LINEMAPS_MACRO_CACHE (set) = mx;\n-  const struct line_map_macro *result = LINEMAPS_MACRO_MAP_AT (set, mx);\n-  linemap_assert (MAP_START_LOCATION (result) <= line);\n-\n-  return result;\n+  return mx;\n }\n \n /* Return TRUE if MAP encodes locations coming from a macro\n@@ -1747,7 +1829,7 @@ linemap_dump (FILE *stream, class line_maps *set, unsigned ix, bool is_macro)\n {\n   const char *const lc_reasons_v[LC_HWM]\n       = { \"LC_ENTER\", \"LC_LEAVE\", \"LC_RENAME\", \"LC_RENAME_VERBATIM\",\n-\t  \"LC_ENTER_MACRO\" };\n+\t  \"LC_ENTER_MACRO\", \"LC_MODULE\" };\n   const line_map *map;\n   unsigned reason;\n "}]}