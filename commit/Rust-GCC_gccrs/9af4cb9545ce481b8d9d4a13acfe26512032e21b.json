{"sha": "9af4cb9545ce481b8d9d4a13acfe26512032e21b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFmNGNiOTU0NWNlNDgxYjhkOWQ0YTEzYWNmZTI2NTEyMDMyZTIxYg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-02-01T19:26:59Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-02-01T19:26:59Z"}, "message": "libgo: Update to weekly.2012-01-27.\n\nFrom-SVN: r183810", "tree": {"sha": "7e7e6083ebe59999943a211a17f8ef6f07f17c2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e7e6083ebe59999943a211a17f8ef6f07f17c2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9af4cb9545ce481b8d9d4a13acfe26512032e21b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9af4cb9545ce481b8d9d4a13acfe26512032e21b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9af4cb9545ce481b8d9d4a13acfe26512032e21b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9af4cb9545ce481b8d9d4a13acfe26512032e21b/comments", "author": null, "committer": null, "parents": [{"sha": "6b6cd722f329a168f98d1f421834cf40bb33a77d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b6cd722f329a168f98d1f421834cf40bb33a77d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b6cd722f329a168f98d1f421834cf40bb33a77d"}], "stats": {"total": 40285, "additions": 15442, "deletions": 24843}, "files": [{"sha": "b9b249315a6d2854301bcf9b65ae57a26701ee77", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -1,4 +1,4 @@\n-9f2be4fbbf69\n+1107a7d3cb07\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "3f5bb2ff5b2c2ba71b2f605c6f4f730b24f9f7bd", "filename": "libgo/Makefile.am", "status": "modified", "additions": 30, "deletions": 395, "changes": 425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -116,7 +116,6 @@ toolexeclibgo_DATA = \\\n \tmime.gox \\\n \tnet.gox \\\n \tos.gox \\\n-\tpatch.gox \\\n \tpath.gox \\\n \treflect.gox \\\n \tregexp.gox \\\n@@ -128,8 +127,7 @@ toolexeclibgo_DATA = \\\n \tsyscall.gox \\\n \ttesting.gox \\\n \ttime.gox \\\n-\tunicode.gox \\\n-\twebsocket.gox\n+\tunicode.gox\n \n toolexeclibgoarchivedir = $(toolexeclibgodir)/archive\n \n@@ -157,40 +155,22 @@ toolexeclibgocryptodir = $(toolexeclibgodir)/crypto\n \n toolexeclibgocrypto_DATA = \\\n \tcrypto/aes.gox \\\n-\tcrypto/bcrypt.gox \\\n-\tcrypto/blowfish.gox \\\n-\tcrypto/cast5.gox \\\n \tcrypto/cipher.gox \\\n \tcrypto/des.gox \\\n \tcrypto/dsa.gox \\\n \tcrypto/ecdsa.gox \\\n \tcrypto/elliptic.gox \\\n \tcrypto/hmac.gox \\\n-\tcrypto/md4.gox \\\n \tcrypto/md5.gox \\\n-\tcrypto/ocsp.gox \\\n-\tcrypto/openpgp.gox \\\n \tcrypto/rand.gox \\\n \tcrypto/rc4.gox \\\n-\tcrypto/ripemd160.gox \\\n \tcrypto/rsa.gox \\\n \tcrypto/sha1.gox \\\n \tcrypto/sha256.gox \\\n \tcrypto/sha512.gox \\\n \tcrypto/subtle.gox \\\n \tcrypto/tls.gox \\\n-\tcrypto/twofish.gox \\\n-\tcrypto/x509.gox \\\n-\tcrypto/xtea.gox\n-\n-toolexeclibgocryptoopenpgpdir = $(toolexeclibgocryptodir)/openpgp\n-\n-toolexeclibgocryptoopenpgp_DATA = \\\n-\tcrypto/openpgp/armor.gox \\\n-\tcrypto/openpgp/elgamal.gox \\\n-\tcrypto/openpgp/errors.gox \\\n-\tcrypto/openpgp/packet.gox \\\n-\tcrypto/openpgp/s2k.gox\n+\tcrypto/x509.gox\n \n toolexeclibgocryptox509dir = $(toolexeclibgocryptodir)/x509\n \n@@ -225,7 +205,6 @@ toolexeclibgoencoding_DATA = \\\n \tencoding/base64.gox \\\n \tencoding/binary.gox \\\n \tencoding/csv.gox \\\n-\tencoding/git85.gox \\\n \tencoding/gob.gox \\\n \tencoding/hex.gox \\\n \tencoding/json.gox \\\n@@ -243,11 +222,10 @@ toolexeclibgoexpdir = $(toolexeclibgodir)/exp\n \n toolexeclibgoexp_DATA = \\\n \texp/ebnf.gox \\\n+\texp/html.gox \\\n \t$(exp_inotify_gox) \\\n \texp/norm.gox \\\n \texp/proxy.gox \\\n-\texp/spdy.gox \\\n-\texp/ssh.gox \\\n \texp/terminal.gox \\\n \texp/types.gox \\\n \texp/utf8string.gox\n@@ -317,7 +295,6 @@ toolexeclibgomime_DATA = \\\n toolexeclibgonetdir = $(toolexeclibgodir)/net\n \n toolexeclibgonet_DATA = \\\n-\tnet/dict.gox \\\n \tnet/http.gox \\\n \tnet/mail.gox \\\n \tnet/rpc.gox \\\n@@ -577,16 +554,8 @@ go_hash_files = \\\n \tgo/hash/hash.go\n \n go_html_files = \\\n-\tgo/html/const.go \\\n-\tgo/html/doc.go \\\n-\tgo/html/doctype.go \\\n \tgo/html/entity.go \\\n-\tgo/html/escape.go \\\n-\tgo/html/foreign.go \\\n-\tgo/html/node.go \\\n-\tgo/html/parse.go \\\n-\tgo/html/render.go \\\n-\tgo/html/token.go\n+\tgo/html/escape.go\n \n go_image_files = \\\n \tgo/image/format.go \\\n@@ -821,12 +790,6 @@ go_os_files = \\\n \tgo/os/types.go \\\n \tsignal_unix.go\n \n-go_patch_files = \\\n-\tgo/patch/apply.go \\\n-\tgo/patch/git.go \\\n-\tgo/patch/patch.go \\\n-\tgo/patch/textdiff.go\n-\n go_path_files = \\\n \tgo/path/match.go \\\n \tgo/path/path.go\n@@ -929,13 +892,6 @@ go_unicode_files = \\\n \tgo/unicode/letter.go \\\n \tgo/unicode/tables.go\n \n-go_websocket_files = \\\n-\tgo/websocket/client.go \\\n-\tgo/websocket/hixie.go \\\n-\tgo/websocket/hybi.go \\\n-\tgo/websocket/server.go \\\n-\tgo/websocket/websocket.go\n-\n \n go_archive_tar_files = \\\n \tgo/archive/tar/common.go \\\n@@ -959,8 +915,7 @@ go_compress_flate_files = \\\n \tgo/compress/flate/huffman_code.go \\\n \tgo/compress/flate/inflate.go \\\n \tgo/compress/flate/reverse_bits.go \\\n-\tgo/compress/flate/token.go \\\n-\tgo/compress/flate/util.go\n+\tgo/compress/flate/token.go\n \n go_compress_gzip_files = \\\n \tgo/compress/gzip/gzip.go \\\n@@ -987,15 +942,6 @@ go_crypto_aes_files = \\\n \tgo/crypto/aes/block.go \\\n \tgo/crypto/aes/cipher.go \\\n \tgo/crypto/aes/const.go\n-go_crypto_bcrypt_files = \\\n-\tgo/crypto/bcrypt/base64.go \\\n-\tgo/crypto/bcrypt/bcrypt.go\n-go_crypto_blowfish_files = \\\n-\tgo/crypto/blowfish/block.go \\\n-\tgo/crypto/blowfish/const.go \\\n-\tgo/crypto/blowfish/cipher.go\n-go_crypto_cast5_files = \\\n-\tgo/crypto/cast5/cast5.go\n go_crypto_cipher_files = \\\n \tgo/crypto/cipher/cbc.go \\\n \tgo/crypto/cipher/cfb.go \\\n@@ -1017,28 +963,15 @@ go_crypto_elliptic_files = \\\n \tgo/crypto/elliptic/p224.go\n go_crypto_hmac_files = \\\n \tgo/crypto/hmac/hmac.go\n-go_crypto_md4_files = \\\n-\tgo/crypto/md4/md4.go \\\n-\tgo/crypto/md4/md4block.go\n go_crypto_md5_files = \\\n \tgo/crypto/md5/md5.go \\\n \tgo/crypto/md5/md5block.go\n-go_crypto_ocsp_files = \\\n-\tgo/crypto/ocsp/ocsp.go\n-go_crypto_openpgp_files = \\\n-\tgo/crypto/openpgp/canonical_text.go \\\n-\tgo/crypto/openpgp/keys.go \\\n-\tgo/crypto/openpgp/read.go \\\n-\tgo/crypto/openpgp/write.go\n go_crypto_rand_files = \\\n \tgo/crypto/rand/rand.go \\\n \tgo/crypto/rand/rand_unix.go \\\n \tgo/crypto/rand/util.go\n go_crypto_rc4_files = \\\n \tgo/crypto/rc4/rc4.go\n-go_crypto_ripemd160_files = \\\n-\tgo/crypto/ripemd160/ripemd160.go \\\n-\tgo/crypto/ripemd160/ripemd160block.go\n go_crypto_rsa_files = \\\n \tgo/crypto/rsa/pkcs1v15.go \\\n \tgo/crypto/rsa/rsa.go\n@@ -1065,40 +998,12 @@ go_crypto_tls_files = \\\n \tgo/crypto/tls/prf.go \\\n \tgo/crypto/tls/root_unix.go \\\n \tgo/crypto/tls/tls.go\n-go_crypto_twofish_files = \\\n-\tgo/crypto/twofish/twofish.go\n go_crypto_x509_files = \\\n \tgo/crypto/x509/cert_pool.go \\\n \tgo/crypto/x509/pkcs1.go \\\n \tgo/crypto/x509/pkcs8.go \\\n \tgo/crypto/x509/verify.go \\\n \tgo/crypto/x509/x509.go\n-go_crypto_xtea_files = \\\n-\tgo/crypto/xtea/block.go \\\n-\tgo/crypto/xtea/cipher.go\n-\n-go_crypto_openpgp_armor_files = \\\n-\tgo/crypto/openpgp/armor/armor.go \\\n-\tgo/crypto/openpgp/armor/encode.go\n-go_crypto_openpgp_elgamal_files = \\\n-\tgo/crypto/openpgp/elgamal/elgamal.go\n-go_crypto_openpgp_errors_files = \\\n-\tgo/crypto/openpgp/errors/errors.go\n-go_crypto_openpgp_packet_files = \\\n-\tgo/crypto/openpgp/packet/compressed.go \\\n-\tgo/crypto/openpgp/packet/encrypted_key.go \\\n-\tgo/crypto/openpgp/packet/literal.go \\\n-\tgo/crypto/openpgp/packet/one_pass_signature.go \\\n-\tgo/crypto/openpgp/packet/packet.go \\\n-\tgo/crypto/openpgp/packet/private_key.go \\\n-\tgo/crypto/openpgp/packet/public_key.go \\\n-\tgo/crypto/openpgp/packet/reader.go \\\n-\tgo/crypto/openpgp/packet/signature.go \\\n-\tgo/crypto/openpgp/packet/symmetric_key_encrypted.go \\\n-\tgo/crypto/openpgp/packet/symmetrically_encrypted.go \\\n-\tgo/crypto/openpgp/packet/userid.go\n-go_crypto_openpgp_s2k_files = \\\n-\tgo/crypto/openpgp/s2k/s2k.go\n \n go_crypto_x509_pkix_files = \\\n \tgo/crypto/x509/pkix/pkix.go\n@@ -1147,8 +1052,6 @@ go_encoding_binary_files = \\\n go_encoding_csv_files = \\\n \tgo/encoding/csv/reader.go \\\n \tgo/encoding/csv/writer.go\n-go_encoding_git85_files = \\\n-\tgo/encoding/git85/git.go\n go_encoding_gob_files = \\\n \tgo/encoding/gob/decode.go \\\n \tgo/encoding/gob/decoder.go \\\n@@ -1177,6 +1080,17 @@ go_encoding_xml_files = \\\n go_exp_ebnf_files = \\\n \tgo/exp/ebnf/ebnf.go \\\n \tgo/exp/ebnf/parser.go\n+go_exp_html_files = \\\n+\tgo/exp/html/const.go \\\n+\tgo/exp/html/doc.go \\\n+\tgo/exp/html/doctype.go \\\n+\tgo/exp/html/entity.go \\\n+\tgo/exp/html/escape.go \\\n+\tgo/exp/html/foreign.go \\\n+\tgo/exp/html/node.go \\\n+\tgo/exp/html/parse.go \\\n+\tgo/exp/html/render.go \\\n+\tgo/exp/html/token.go\n go_exp_inotify_files = \\\n \tgo/exp/inotify/inotify_linux.go\n go_exp_norm_files = \\\n@@ -1192,23 +1106,6 @@ go_exp_proxy_files = \\\n \tgo/exp/proxy/per_host.go \\\n \tgo/exp/proxy/proxy.go \\\n \tgo/exp/proxy/socks5.go\n-go_exp_spdy_files = \\\n-\tgo/exp/spdy/read.go \\\n-\tgo/exp/spdy/types.go \\\n-\tgo/exp/spdy/write.go\n-go_exp_ssh_files = \\\n-\tgo/exp/ssh/channel.go \\\n-\tgo/exp/ssh/cipher.go \\\n-\tgo/exp/ssh/client.go \\\n-\tgo/exp/ssh/client_auth.go \\\n-\tgo/exp/ssh/common.go \\\n-\tgo/exp/ssh/doc.go \\\n-\tgo/exp/ssh/messages.go \\\n-\tgo/exp/ssh/server.go \\\n-\tgo/exp/ssh/server_terminal.go \\\n-\tgo/exp/ssh/session.go \\\n-\tgo/exp/ssh/tcpip.go \\\n-\tgo/exp/ssh/transport.go\n go_exp_terminal_files = \\\n \tgo/exp/terminal/terminal.go \\\n \tgo/exp/terminal/util.go\n@@ -1351,8 +1248,6 @@ go_mime_multipart_files = \\\n \tgo/mime/multipart/multipart.go \\\n \tgo/mime/multipart/writer.go\n \n-go_net_dict_files = \\\n-\tgo/net/dict/dict.go\n go_net_http_files = \\\n \tgo/net/http/chunked.go \\\n \tgo/net/http/client.go \\\n@@ -1717,7 +1612,6 @@ libgo_go_objs = \\\n \tnet/net.lo \\\n \tos/exec.lo \\\n \tos/os.lo \\\n-\tpatch/patch.lo \\\n \tpath/path.lo \\\n \treflect/reflect.lo \\\n \tregexp/regexp.lo \\\n@@ -1728,7 +1622,6 @@ libgo_go_objs = \\\n \tsync/sync.lo \\\n \ttime/time.lo \\\n \tunicode/unicode.lo \\\n-\twebsocket/websocket.lo \\\n \tarchive/tar.lo \\\n \tarchive/zip.lo \\\n \tcompress/bzip2.lo \\\n@@ -1740,36 +1633,22 @@ libgo_go_objs = \\\n \tcontainer/list.lo \\\n \tcontainer/ring.lo \\\n \tcrypto/aes.lo \\\n-\tcrypto/bcrypt.lo \\\n-\tcrypto/blowfish.lo \\\n-\tcrypto/cast5.lo \\\n \tcrypto/cipher.lo \\\n \tcrypto/des.lo \\\n \tcrypto/dsa.lo \\\n \tcrypto/ecdsa.lo \\\n \tcrypto/elliptic.lo \\\n \tcrypto/hmac.lo \\\n-\tcrypto/md4.lo \\\n \tcrypto/md5.lo \\\n-\tcrypto/ocsp.lo \\\n-\tcrypto/openpgp.lo \\\n \tcrypto/rand.lo \\\n \tcrypto/rc4.lo \\\n-\tcrypto/ripemd160.lo \\\n \tcrypto/rsa.lo \\\n \tcrypto/sha1.lo \\\n \tcrypto/sha256.lo \\\n \tcrypto/sha512.lo \\\n \tcrypto/subtle.lo \\\n \tcrypto/tls.lo \\\n-\tcrypto/twofish.lo \\\n \tcrypto/x509.lo \\\n-\tcrypto/xtea.lo \\\n-\tcrypto/openpgp/armor.lo \\\n-\tcrypto/openpgp/elgamal.lo \\\n-\tcrypto/openpgp/errors.lo \\\n-\tcrypto/openpgp/packet.lo \\\n-\tcrypto/openpgp/s2k.lo \\\n \tcrypto/x509/pkix.lo \\\n \tdatabase/sql.lo \\\n \tdatabase/sql/driver.lo \\\n@@ -1784,17 +1663,15 @@ libgo_go_objs = \\\n \tencoding/base64.lo \\\n \tencoding/binary.lo \\\n \tencoding/csv.lo \\\n-\tencoding/git85.lo \\\n \tencoding/gob.lo \\\n \tencoding/hex.lo \\\n \tencoding/json.lo \\\n \tencoding/pem.lo \\\n \tencoding/xml.lo \\\n \texp/ebnf.lo \\\n+\texp/html.lo \\\n \texp/norm.lo \\\n \texp/proxy.lo \\\n-\texp/spdy.lo \\\n-\texp/ssh.lo \\\n \texp/terminal.lo \\\n \texp/types.lo \\\n \texp/utf8string.lo \\\n@@ -1831,7 +1708,6 @@ libgo_go_objs = \\\n \tmath/rand.lo \\\n \tmime/mime.lo \\\n \tmime/multipart.lo \\\n-\tnet/dict.lo \\\n \tnet/http.lo \\\n \tnet/mail.lo \\\n \tnet/rpc.lo \\\n@@ -1946,7 +1822,6 @@ CHECK_DEPS = libgo.la libgobegin.a \\\n \t$(toolexeclibgocompress_DATA) \\\n \t$(toolexeclibgocontainer_DATA) \\\n \t$(toolexeclibgocrypto_DATA) \\\n-\t$(toolexeclibgocryptoopenpgp_DATA) \\\n \t$(toolexeclibgodebug_DATA) \\\n \t$(toolexeclibgoencoding_DATA) \\\n \t$(toolexeclibgoexp_DATA) \\\n@@ -2120,15 +1995,6 @@ signal_unix.go: $(srcdir)/go/os/mkunixsignals.sh sysinfo.go\n \t$(SHELL) $(srcdir)/go/os/mkunixsignals.sh sysinfo.go > $@.tmp\n \tmv -f $@.tmp $@\n \n-@go_include@ patch/patch.lo.dep\n-patch/patch.lo.dep: $(go_patch_files)\n-\t$(BUILDDEPS)\n-patch/patch.lo: $(go_patch_files)\n-\t$(BUILDPACKAGE)\n-patch/check: $(CHECK_DEPS)\n-\t@$(CHECK)\n-.PHONY: patch/check\n-\n @go_include@ path/path.lo.dep\n path/path.lo.dep: $(go_path_files)\n \t$(BUILDDEPS)\n@@ -2238,15 +2104,6 @@ unicode/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: unicode/check\n \n-@go_include@ websocket/websocket.lo.dep\n-websocket/websocket.lo.dep: $(go_websocket_files)\n-\t$(BUILDDEPS)\n-websocket/websocket.lo: $(go_websocket_files)\n-\t$(BUILDPACKAGE)\n-websocket/check: $(CHECK_DEPS)\n-\t@$(CHECK)\n-.PHONY: websocket/check\n-\n @go_include@ archive/tar.lo.dep\n archive/tar.lo.dep: $(go_archive_tar_files)\n \t$(BUILDDEPS)\n@@ -2357,36 +2214,6 @@ crypto/aes/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/aes/check\n \n-@go_include@ crypto/bcrypt.lo.dep\n-crypto/bcrypt.lo.dep: $(go_crypto_bcrypt_files)\n-\t$(BUILDDEPS)\n-crypto/bcrypt.lo: $(go_crypto_bcrypt_files)\n-\t$(BUILDPACKAGE)\n-crypto/bcrypt/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/bcrypt\n-\t@$(CHECK)\n-.PHONY: crypto/bcrypt/check\n-\n-@go_include@ crypto/blowfish.lo.dep\n-crypto/blowfish.lo.dep: $(go_crypto_blowfish_files)\n-\t$(BUILDDEPS)\n-crypto/blowfish.lo: $(go_crypto_blowfish_files)\n-\t$(BUILDPACKAGE)\n-crypto/blowfish/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/blowfish\n-\t@$(CHECK)\n-.PHONY: crypto/blowfish/check\n-\n-@go_include@ crypto/cast5.lo.dep\n-crypto/cast5.lo.dep: $(go_crypto_cast5_files)\n-\t$(BUILDDEPS)\n-crypto/cast5.lo: $(go_crypto_cast5_files)\n-\t$(BUILDPACKAGE)\n-crypto/cast5/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/cast5\n-\t@$(CHECK)\n-.PHONY: crypto/cast5/check\n-\n @go_include@ crypto/cipher.lo.dep\n crypto/cipher.lo.dep: $(go_crypto_cipher_files)\n \t$(BUILDDEPS)\n@@ -2447,16 +2274,6 @@ crypto/hmac/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/hmac/check\n \n-@go_include@ crypto/md4.lo.dep\n-crypto/md4.lo.dep: $(go_crypto_md4_files)\n-\t$(BUILDDEPS)\n-crypto/md4.lo: $(go_crypto_md4_files)\n-\t$(BUILDPACKAGE)\n-crypto/md4/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/md4\n-\t@$(CHECK)\n-.PHONY: crypto/md4/check\n-\n @go_include@ crypto/md5.lo.dep\n crypto/md5.lo.dep: $(go_crypto_md5_files)\n \t$(BUILDDEPS)\n@@ -2467,26 +2284,6 @@ crypto/md5/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/md5/check\n \n-@go_include@ crypto/ocsp.lo.dep\n-crypto/ocsp.lo.dep: $(go_crypto_ocsp_files)\n-\t$(BUILDDEPS)\n-crypto/ocsp.lo: $(go_crypto_ocsp_files)\n-\t$(BUILDPACKAGE)\n-crypto/ocsp/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/ocsp\n-\t@$(CHECK)\n-.PHONY: crypto/ocsp/check\n-\n-@go_include@ crypto/openpgp.lo.dep\n-crypto/openpgp.lo.dep: $(go_crypto_openpgp_files)\n-\t$(BUILDDEPS)\n-crypto/openpgp.lo: $(go_crypto_openpgp_files)\n-\t$(BUILDPACKAGE)\n-crypto/openpgp/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/openpgp\n-\t@$(CHECK)\n-.PHONY: crypto/openpgp/check\n-\n @go_include@ crypto/rand.lo.dep\n crypto/rand.lo.dep: $(go_crypto_rand_files)\n \t$(BUILDDEPS)\n@@ -2507,16 +2304,6 @@ crypto/rc4/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/rc4/check\n \n-@go_include@ crypto/ripemd160.lo.dep\n-crypto/ripemd160.lo.dep: $(go_crypto_ripemd160_files)\n-\t$(BUILDDEPS)\n-crypto/ripemd160.lo: $(go_crypto_ripemd160_files)\n-\t$(BUILDPACKAGE)\n-crypto/ripemd160/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/ripemd160\n-\t@$(CHECK)\n-.PHONY: crypto/ripemd160/check\n-\n @go_include@ crypto/rsa.lo.dep\n crypto/rsa.lo.dep: $(go_crypto_rsa_files)\n \t$(BUILDDEPS)\n@@ -2577,16 +2364,6 @@ crypto/tls/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/tls/check\n \n-@go_include@ crypto/twofish.lo.dep\n-crypto/twofish.lo.dep: $(go_crypto_twofish_files)\n-\t$(BUILDDEPS)\n-crypto/twofish.lo: $(go_crypto_twofish_files)\n-\t$(BUILDPACKAGE)\n-crypto/twofish/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/twofish\n-\t@$(CHECK)\n-.PHONY: crypto/twofish/check\n-\n @go_include@ crypto/x509.lo.dep\n crypto/x509.lo.dep: $(go_crypto_x509_files)\n \t$(BUILDDEPS)\n@@ -2597,66 +2374,6 @@ crypto/x509/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/x509/check\n \n-@go_include@ crypto/xtea.lo.dep\n-crypto/xtea.lo.dep: $(go_crypto_xtea_files)\n-\t$(BUILDDEPS)\n-crypto/xtea.lo: $(go_crypto_xtea_files)\n-\t$(BUILDPACKAGE)\n-crypto/xtea/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/xtea\n-\t@$(CHECK)\n-.PHONY: crypto/xtea/check\n-\n-@go_include@ crypto/openpgp/armor.lo.dep\n-crypto/openpgp/armor.lo.dep: $(go_crypto_openpgp_armor_files)\n-\t$(BUILDDEPS)\n-crypto/openpgp/armor.lo: $(go_crypto_openpgp_armor_files)\n-\t$(BUILDPACKAGE)\n-crypto/openpgp/armor/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/openpgp/armor\n-\t@$(CHECK)\n-.PHONY: crypto/openpgp/armor/check\n-\n-@go_include@ crypto/openpgp/elgamal.lo.dep\n-crypto/openpgp/elgamal.lo.dep: $(go_crypto_openpgp_elgamal_files)\n-\t$(BUILDDEPS)\n-crypto/openpgp/elgamal.lo: $(go_crypto_openpgp_elgamal_files)\n-\t$(BUILDPACKAGE)\n-crypto/openpgp/elgamal/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/openpgp/elgamal\n-\t@$(CHECK)\n-.PHONY: crypto/openpgp/elgamal/check\n-\n-@go_include@ crypto/openpgp/errors.lo.dep\n-crypto/openpgp/errors.lo.dep: $(go_crypto_openpgp_errors_files)\n-\t$(BUILDDEPS)\n-crypto/openpgp/errors.lo: $(go_crypto_openpgp_errors_files)\n-\t$(BUILDPACKAGE)\n-crypto/openpgp/errors/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/openpgp/errors\n-\t@$(CHECK)\n-.PHONY: crypto/openpgp/errors/check\n-\n-@go_include@ crypto/openpgp/packet.lo.dep\n-crypto/openpgp/packet.lo.dep: $(go_crypto_openpgp_packet_files)\n-\t$(BUILDDEPS)\n-crypto/openpgp/packet.lo: $(go_crypto_openpgp_packet_files)\n-\t$(BUILDPACKAGE)\n-crypto/openpgp/packet/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/openpgp/packet\n-\t@$(CHECK)\n-.PHONY: crypto/openpgp/packet/check\n-\n-@go_include@ crypto/openpgp/s2k.lo.dep\n-crypto/openpgp/s2k.lo.dep: $(go_crypto_openpgp_s2k_files)\n-\t$(BUILDDEPS)\n-crypto/openpgp/s2k.lo: $(go_crypto_openpgp_s2k_files)\n-\t$(BUILDPACKAGE)\n-crypto/openpgp/s2k/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/openpgp/s2k\n-\t@$(CHECK)\n-.PHONY: crypto/openpgp/s2k/check\n-\n @go_include@ crypto/x509/pkix.lo.dep\n crypto/x509/pkix.lo.dep: $(go_crypto_x509_pkix_files)\n \t$(BUILDDEPS)\n@@ -2797,16 +2514,6 @@ encoding/csv/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: encoding/csv/check\n \n-@go_include@ encoding/git85.lo.dep\n-encoding/git85.lo.dep: $(go_encoding_git85_files)\n-\t$(BUILDDEPS)\n-encoding/git85.lo: $(go_encoding_git85_files)\n-\t$(BUILDPACKAGE)\n-encoding/git85/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) encoding/git85\n-\t@$(CHECK)\n-.PHONY: encoding/git85/check\n-\n @go_include@ encoding/gob.lo.dep\n encoding/gob.lo.dep: $(go_encoding_gob_files)\n \t$(BUILDDEPS)\n@@ -2867,6 +2574,16 @@ exp/ebnf/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/ebnf/check\n \n+@go_include@ exp/html.lo.dep\n+exp/html.lo.dep: $(go_exp_html_files)\n+\t$(BUILDDEPS)\n+exp/html.lo: $(go_exp_html_files)\n+\t$(BUILDPACKAGE)\n+exp/html/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/html\n+\t@$(CHECK)\n+.PHONY: exp/html/check\n+\n @go_include@ exp/norm.lo.dep\n exp/norm.lo.dep: $(go_exp_norm_files)\n \t$(BUILDDEPS)\n@@ -2887,26 +2604,6 @@ exp/proxy/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/proxy/check\n \n-@go_include@ exp/spdy.lo.dep\n-exp/spdy.lo.dep: $(go_exp_spdy_files)\n-\t$(BUILDDEPS)\n-exp/spdy.lo: $(go_exp_spdy_files)\n-\t$(BUILDPACKAGE)\n-exp/spdy/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/spdy\n-\t@$(CHECK)\n-.PHONY: exp/spdy/check\n-\n-@go_include@ exp/ssh.lo.dep\n-exp/ssh.lo.dep: $(go_exp_ssh_files)\n-\t$(BUILDDEPS)\n-exp/ssh.lo: $(go_exp_ssh_files)\n-\t$(BUILDPACKAGE)\n-exp/ssh/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/ssh\n-\t@$(CHECK)\n-.PHONY: exp/ssh/check\n-\n @go_include@ exp/terminal.lo.dep\n exp/terminal.lo.dep: $(go_exp_terminal_files)\n \t$(BUILDDEPS)\n@@ -3218,12 +2915,6 @@ mime/multipart/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: mime/multipart/check\n \n-@go_include@ net/dict.lo.dep\n-net/dict.lo.dep: $(go_net_dict_files)\n-\t$(BUILDDEPS)\n-net/dict.lo: $(go_net_dict_files)\n-\t$(BUILDPACKAGE)\n-\n @go_include@ net/http.lo.dep\n net/http.lo.dep: $(go_net_http_files)\n \t$(BUILDDEPS)\n@@ -3582,8 +3273,6 @@ net.gox: net/net.lo\n \t$(BUILDGOX)\n os.gox: os/os.lo\n \t$(BUILDGOX)\n-patch.gox: patch/patch.lo\n-\t$(BUILDGOX)\n path.gox: path/path.lo\n \t$(BUILDGOX)\n reflect.gox: reflect/reflect.lo\n@@ -3608,8 +3297,6 @@ time.gox: time/time.lo\n \t$(BUILDGOX)\n unicode.gox: unicode/unicode.lo\n \t$(BUILDGOX)\n-websocket.gox: websocket/websocket.lo\n-\t$(BUILDGOX)\n \n archive/tar.gox: archive/tar.lo\n \t$(BUILDGOX)\n@@ -3636,12 +3323,6 @@ container/ring.gox: container/ring.lo\n \n crypto/aes.gox: crypto/aes.lo\n \t$(BUILDGOX)\n-crypto/bcrypt.gox: crypto/bcrypt.lo\n-\t$(BUILDGOX)\n-crypto/blowfish.gox: crypto/blowfish.lo\n-\t$(BUILDGOX)\n-crypto/cast5.gox: crypto/cast5.lo\n-\t$(BUILDGOX)\n crypto/cipher.gox: crypto/cipher.lo\n \t$(BUILDGOX)\n crypto/des.gox: crypto/des.lo\n@@ -3654,20 +3335,12 @@ crypto/elliptic.gox: crypto/elliptic.lo\n \t$(BUILDGOX)\n crypto/hmac.gox: crypto/hmac.lo\n \t$(BUILDGOX)\n-crypto/md4.gox: crypto/md4.lo\n-\t$(BUILDGOX)\n crypto/md5.gox: crypto/md5.lo\n \t$(BUILDGOX)\n-crypto/ocsp.gox: crypto/ocsp.lo\n-\t$(BUILDGOX)\n-crypto/openpgp.gox: crypto/openpgp.lo\n-\t$(BUILDGOX)\n crypto/rand.gox: crypto/rand.lo\n \t$(BUILDGOX)\n crypto/rc4.gox: crypto/rc4.lo\n \t$(BUILDGOX)\n-crypto/ripemd160.gox: crypto/ripemd160.lo\n-\t$(BUILDGOX)\n crypto/rsa.gox: crypto/rsa.lo\n \t$(BUILDGOX)\n crypto/sha1.gox: crypto/sha1.lo\n@@ -3680,23 +3353,8 @@ crypto/subtle.gox: crypto/subtle.lo\n \t$(BUILDGOX)\n crypto/tls.gox: crypto/tls.lo\n \t$(BUILDGOX)\n-crypto/twofish.gox: crypto/twofish.lo\n-\t$(BUILDGOX)\n crypto/x509.gox: crypto/x509.lo\n \t$(BUILDGOX)\n-crypto/xtea.gox: crypto/xtea.lo\n-\t$(BUILDGOX)\n-\n-crypto/openpgp/armor.gox: crypto/openpgp/armor.lo\n-\t$(BUILDGOX)\n-crypto/openpgp/elgamal.gox: crypto/openpgp/elgamal.lo\n-\t$(BUILDGOX)\n-crypto/openpgp/errors.gox: crypto/openpgp/errors.lo\n-\t$(BUILDGOX)\n-crypto/openpgp/packet.gox: crypto/openpgp/packet.lo\n-\t$(BUILDGOX)\n-crypto/openpgp/s2k.gox: crypto/openpgp/s2k.lo\n-\t$(BUILDGOX)\n \n crypto/x509/pkix.gox: crypto/x509/pkix.lo\n \t$(BUILDGOX)\n@@ -3730,8 +3388,6 @@ encoding/binary.gox: encoding/binary.lo\n \t$(BUILDGOX)\n encoding/csv.gox: encoding/csv.lo\n \t$(BUILDGOX)\n-encoding/git85.gox: encoding/git85.lo\n-\t$(BUILDGOX)\n encoding/gob.gox: encoding/gob.lo\n \t$(BUILDGOX)\n encoding/hex.gox: encoding/hex.lo\n@@ -3745,16 +3401,14 @@ encoding/xml.gox: encoding/xml.lo\n \n exp/ebnf.gox: exp/ebnf.lo\n \t$(BUILDGOX)\n+exp/html.gox: exp/html.lo\n+\t$(BUILDGOX)\n exp/inotify.gox: exp/inotify.lo\n \t$(BUILDGOX)\n exp/norm.gox: exp/norm.lo\n \t$(BUILDGOX)\n exp/proxy.gox: exp/proxy.lo\n \t$(BUILDGOX)\n-exp/spdy.gox: exp/spdy.lo\n-\t$(BUILDGOX)\n-exp/ssh.gox: exp/ssh.lo\n-\t$(BUILDGOX)\n exp/terminal.gox: exp/terminal.lo\n \t$(BUILDGOX)\n exp/types.gox: exp/types.lo\n@@ -3823,8 +3477,6 @@ math/rand.gox: math/rand.lo\n mime/multipart.gox: mime/multipart.lo\n \t$(BUILDGOX)\n \n-net/dict.gox: net/dict.lo\n-\t$(BUILDGOX)\n net/http.gox: net/http.lo\n \t$(BUILDGOX)\n net/mail.gox: net/mail.lo\n@@ -3923,7 +3575,6 @@ TEST_PACKAGES = \\\n \tmime/check \\\n \tnet/check \\\n \tos/check \\\n-\tpatch/check \\\n \tpath/check \\\n \treflect/check \\\n \tregexp/check \\\n@@ -3934,7 +3585,6 @@ TEST_PACKAGES = \\\n \tsync/check \\\n \ttime/check \\\n \tunicode/check \\\n-\twebsocket/check \\\n \tarchive/tar/check \\\n \tarchive/zip/check \\\n \tcompress/bzip2/check \\\n@@ -3946,35 +3596,22 @@ TEST_PACKAGES = \\\n \tcontainer/list/check \\\n \tcontainer/ring/check \\\n \tcrypto/aes/check \\\n-\tcrypto/bcrypt/check \\\n-\tcrypto/blowfish/check \\\n-\tcrypto/cast5/check \\\n \tcrypto/cipher/check \\\n \tcrypto/des/check \\\n \tcrypto/dsa/check \\\n \tcrypto/ecdsa/check \\\n \tcrypto/elliptic/check \\\n \tcrypto/hmac/check \\\n-\tcrypto/md4/check \\\n \tcrypto/md5/check \\\n-\tcrypto/ocsp/check \\\n-\tcrypto/openpgp/check \\\n \tcrypto/rand/check \\\n \tcrypto/rc4/check \\\n-\tcrypto/ripemd160/check \\\n \tcrypto/rsa/check \\\n \tcrypto/sha1/check \\\n \tcrypto/sha256/check \\\n \tcrypto/sha512/check \\\n \tcrypto/subtle/check \\\n \tcrypto/tls/check \\\n-\tcrypto/twofish/check \\\n \tcrypto/x509/check \\\n-\tcrypto/xtea/check \\\n-\tcrypto/openpgp/armor/check \\\n-\tcrypto/openpgp/elgamal/check \\\n-\tcrypto/openpgp/packet/check \\\n-\tcrypto/openpgp/s2k/check \\\n \tdatabase/sql/check \\\n \tdatabase/sql/driver/check \\\n \tdebug/dwarf/check \\\n@@ -3987,18 +3624,16 @@ TEST_PACKAGES = \\\n \tencoding/base64/check \\\n \tencoding/binary/check \\\n \tencoding/csv/check \\\n-\tencoding/git85/check \\\n \tencoding/gob/check \\\n \tencoding/hex/check \\\n \tencoding/json/check \\\n \tencoding/pem/check \\\n \tencoding/xml/check \\\n \texp/ebnf/check \\\n+\texp/html/check \\\n \t$(exp_inotify_check) \\\n \texp/norm/check \\\n \texp/proxy/check \\\n-\texp/spdy/check \\\n-\texp/ssh/check \\\n \texp/terminal/check \\\n \texp/utf8string/check \\\n \thtml/template/check \\"}, {"sha": "4aebb2d6fd7dfecb31a2657c5983c99b329a1bbd", "filename": "libgo/Makefile.in", "status": "modified", "additions": 62, "deletions": 474, "changes": 536, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -97,7 +97,6 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgocompressdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgocontainerdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgocryptodir)\" \\\n-\t\"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgodatabasedir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgodatabasesqldir)\" \\\n@@ -138,31 +137,24 @@ am__DEPENDENCIES_2 = bufio/bufio.lo bytes/bytes.lo bytes/index.lo \\\n \tcrypto/crypto.lo errors/errors.lo expvar/expvar.lo \\\n \tflag/flag.lo fmt/fmt.lo hash/hash.lo html/html.lo \\\n \timage/image.lo io/io.lo log/log.lo math/math.lo net/net.lo \\\n-\tos/exec.lo os/os.lo patch/patch.lo path/path.lo \\\n-\treflect/reflect.lo regexp/regexp.lo runtime/runtime.lo \\\n-\tsort/sort.lo strconv/strconv.lo strings/strings.lo \\\n-\tsync/sync.lo time/time.lo unicode/unicode.lo \\\n-\twebsocket/websocket.lo archive/tar.lo archive/zip.lo \\\n+\tos/exec.lo os/os.lo path/path.lo reflect/reflect.lo \\\n+\tregexp/regexp.lo runtime/runtime.lo sort/sort.lo \\\n+\tstrconv/strconv.lo strings/strings.lo sync/sync.lo \\\n+\ttime/time.lo unicode/unicode.lo archive/tar.lo archive/zip.lo \\\n \tcompress/bzip2.lo compress/flate.lo compress/gzip.lo \\\n \tcompress/lzw.lo compress/zlib.lo container/heap.lo \\\n \tcontainer/list.lo container/ring.lo crypto/aes.lo \\\n-\tcrypto/bcrypt.lo crypto/blowfish.lo crypto/cast5.lo \\\n \tcrypto/cipher.lo crypto/des.lo crypto/dsa.lo crypto/ecdsa.lo \\\n-\tcrypto/elliptic.lo crypto/hmac.lo crypto/md4.lo crypto/md5.lo \\\n-\tcrypto/ocsp.lo crypto/openpgp.lo crypto/rand.lo crypto/rc4.lo \\\n-\tcrypto/ripemd160.lo crypto/rsa.lo crypto/sha1.lo \\\n-\tcrypto/sha256.lo crypto/sha512.lo crypto/subtle.lo \\\n-\tcrypto/tls.lo crypto/twofish.lo crypto/x509.lo crypto/xtea.lo \\\n-\tcrypto/openpgp/armor.lo crypto/openpgp/elgamal.lo \\\n-\tcrypto/openpgp/errors.lo crypto/openpgp/packet.lo \\\n-\tcrypto/openpgp/s2k.lo crypto/x509/pkix.lo database/sql.lo \\\n-\tdatabase/sql/driver.lo debug/dwarf.lo debug/elf.lo \\\n-\tdebug/gosym.lo debug/macho.lo debug/pe.lo encoding/ascii85.lo \\\n-\tencoding/asn1.lo encoding/base32.lo encoding/base64.lo \\\n-\tencoding/binary.lo encoding/csv.lo encoding/git85.lo \\\n-\tencoding/gob.lo encoding/hex.lo encoding/json.lo \\\n-\tencoding/pem.lo encoding/xml.lo exp/ebnf.lo exp/norm.lo \\\n-\texp/proxy.lo exp/spdy.lo exp/ssh.lo exp/terminal.lo \\\n+\tcrypto/elliptic.lo crypto/hmac.lo crypto/md5.lo crypto/rand.lo \\\n+\tcrypto/rc4.lo crypto/rsa.lo crypto/sha1.lo crypto/sha256.lo \\\n+\tcrypto/sha512.lo crypto/subtle.lo crypto/tls.lo crypto/x509.lo \\\n+\tcrypto/x509/pkix.lo database/sql.lo database/sql/driver.lo \\\n+\tdebug/dwarf.lo debug/elf.lo debug/gosym.lo debug/macho.lo \\\n+\tdebug/pe.lo encoding/ascii85.lo encoding/asn1.lo \\\n+\tencoding/base32.lo encoding/base64.lo encoding/binary.lo \\\n+\tencoding/csv.lo encoding/gob.lo encoding/hex.lo \\\n+\tencoding/json.lo encoding/pem.lo encoding/xml.lo exp/ebnf.lo \\\n+\texp/html.lo exp/norm.lo exp/proxy.lo exp/terminal.lo \\\n \texp/types.lo exp/utf8string.lo html/template.lo go/ast.lo \\\n \tgo/build.lo go/doc.lo go/parser.lo go/printer.lo go/scanner.lo \\\n \tgo/token.lo hash/adler32.lo hash/crc32.lo hash/crc64.lo \\\n@@ -172,7 +164,7 @@ am__DEPENDENCIES_2 = bufio/bufio.lo bytes/bytes.lo bytes/index.lo \\\n \timage/jpeg.lo image/png.lo image/tiff.lo index/suffixarray.lo \\\n \tio/ioutil.lo log/syslog.lo log/syslog/syslog_c.lo math/big.lo \\\n \tmath/cmplx.lo math/rand.lo mime/mime.lo mime/multipart.lo \\\n-\tnet/dict.lo net/http.lo net/mail.lo net/rpc.lo net/smtp.lo \\\n+\tnet/http.lo net/mail.lo net/rpc.lo net/smtp.lo \\\n \tnet/textproto.lo net/url.lo old/netchan.lo old/regexp.lo \\\n \told/template.lo $(am__DEPENDENCIES_1) os/user.lo os/signal.lo \\\n \tpath/filepath.lo regexp/syntax.lo net/rpc/jsonrpc.lo \\\n@@ -289,21 +281,21 @@ RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \\\n \tps-recursive uninstall-recursive\n DATA = $(toolexeclibgo_DATA) $(toolexeclibgoarchive_DATA) \\\n \t$(toolexeclibgocompress_DATA) $(toolexeclibgocontainer_DATA) \\\n-\t$(toolexeclibgocrypto_DATA) $(toolexeclibgocryptoopenpgp_DATA) \\\n-\t$(toolexeclibgocryptox509_DATA) $(toolexeclibgodatabase_DATA) \\\n-\t$(toolexeclibgodatabasesql_DATA) $(toolexeclibgodebug_DATA) \\\n-\t$(toolexeclibgoencoding_DATA) $(toolexeclibgoexp_DATA) \\\n-\t$(toolexeclibgogo_DATA) $(toolexeclibgohash_DATA) \\\n-\t$(toolexeclibgohtml_DATA) $(toolexeclibgoimage_DATA) \\\n-\t$(toolexeclibgoindex_DATA) $(toolexeclibgoio_DATA) \\\n-\t$(toolexeclibgolog_DATA) $(toolexeclibgomath_DATA) \\\n-\t$(toolexeclibgomime_DATA) $(toolexeclibgonet_DATA) \\\n-\t$(toolexeclibgonethttp_DATA) $(toolexeclibgonetrpc_DATA) \\\n-\t$(toolexeclibgoold_DATA) $(toolexeclibgoos_DATA) \\\n-\t$(toolexeclibgopath_DATA) $(toolexeclibgoregexp_DATA) \\\n-\t$(toolexeclibgoruntime_DATA) $(toolexeclibgosync_DATA) \\\n-\t$(toolexeclibgotesting_DATA) $(toolexeclibgotext_DATA) \\\n-\t$(toolexeclibgotexttemplate_DATA) $(toolexeclibgounicode_DATA)\n+\t$(toolexeclibgocrypto_DATA) $(toolexeclibgocryptox509_DATA) \\\n+\t$(toolexeclibgodatabase_DATA) $(toolexeclibgodatabasesql_DATA) \\\n+\t$(toolexeclibgodebug_DATA) $(toolexeclibgoencoding_DATA) \\\n+\t$(toolexeclibgoexp_DATA) $(toolexeclibgogo_DATA) \\\n+\t$(toolexeclibgohash_DATA) $(toolexeclibgohtml_DATA) \\\n+\t$(toolexeclibgoimage_DATA) $(toolexeclibgoindex_DATA) \\\n+\t$(toolexeclibgoio_DATA) $(toolexeclibgolog_DATA) \\\n+\t$(toolexeclibgomath_DATA) $(toolexeclibgomime_DATA) \\\n+\t$(toolexeclibgonet_DATA) $(toolexeclibgonethttp_DATA) \\\n+\t$(toolexeclibgonetrpc_DATA) $(toolexeclibgoold_DATA) \\\n+\t$(toolexeclibgoos_DATA) $(toolexeclibgopath_DATA) \\\n+\t$(toolexeclibgoregexp_DATA) $(toolexeclibgoruntime_DATA) \\\n+\t$(toolexeclibgosync_DATA) $(toolexeclibgotesting_DATA) \\\n+\t$(toolexeclibgotext_DATA) $(toolexeclibgotexttemplate_DATA) \\\n+\t$(toolexeclibgounicode_DATA)\n RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n   distclean-recursive maintainer-clean-recursive\n AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n@@ -587,7 +579,6 @@ toolexeclibgo_DATA = \\\n \tmime.gox \\\n \tnet.gox \\\n \tos.gox \\\n-\tpatch.gox \\\n \tpath.gox \\\n \treflect.gox \\\n \tregexp.gox \\\n@@ -599,8 +590,7 @@ toolexeclibgo_DATA = \\\n \tsyscall.gox \\\n \ttesting.gox \\\n \ttime.gox \\\n-\tunicode.gox \\\n-\twebsocket.gox\n+\tunicode.gox\n \n toolexeclibgoarchivedir = $(toolexeclibgodir)/archive\n toolexeclibgoarchive_DATA = \\\n@@ -624,39 +614,22 @@ toolexeclibgocontainer_DATA = \\\n toolexeclibgocryptodir = $(toolexeclibgodir)/crypto\n toolexeclibgocrypto_DATA = \\\n \tcrypto/aes.gox \\\n-\tcrypto/bcrypt.gox \\\n-\tcrypto/blowfish.gox \\\n-\tcrypto/cast5.gox \\\n \tcrypto/cipher.gox \\\n \tcrypto/des.gox \\\n \tcrypto/dsa.gox \\\n \tcrypto/ecdsa.gox \\\n \tcrypto/elliptic.gox \\\n \tcrypto/hmac.gox \\\n-\tcrypto/md4.gox \\\n \tcrypto/md5.gox \\\n-\tcrypto/ocsp.gox \\\n-\tcrypto/openpgp.gox \\\n \tcrypto/rand.gox \\\n \tcrypto/rc4.gox \\\n-\tcrypto/ripemd160.gox \\\n \tcrypto/rsa.gox \\\n \tcrypto/sha1.gox \\\n \tcrypto/sha256.gox \\\n \tcrypto/sha512.gox \\\n \tcrypto/subtle.gox \\\n \tcrypto/tls.gox \\\n-\tcrypto/twofish.gox \\\n-\tcrypto/x509.gox \\\n-\tcrypto/xtea.gox\n-\n-toolexeclibgocryptoopenpgpdir = $(toolexeclibgocryptodir)/openpgp\n-toolexeclibgocryptoopenpgp_DATA = \\\n-\tcrypto/openpgp/armor.gox \\\n-\tcrypto/openpgp/elgamal.gox \\\n-\tcrypto/openpgp/errors.gox \\\n-\tcrypto/openpgp/packet.gox \\\n-\tcrypto/openpgp/s2k.gox\n+\tcrypto/x509.gox\n \n toolexeclibgocryptox509dir = $(toolexeclibgocryptodir)/x509\n toolexeclibgocryptox509_DATA = \\\n@@ -686,7 +659,6 @@ toolexeclibgoencoding_DATA = \\\n \tencoding/base64.gox \\\n \tencoding/binary.gox \\\n \tencoding/csv.gox \\\n-\tencoding/git85.gox \\\n \tencoding/gob.gox \\\n \tencoding/hex.gox \\\n \tencoding/json.gox \\\n@@ -700,11 +672,10 @@ toolexeclibgoencoding_DATA = \\\n toolexeclibgoexpdir = $(toolexeclibgodir)/exp\n toolexeclibgoexp_DATA = \\\n \texp/ebnf.gox \\\n+\texp/html.gox \\\n \t$(exp_inotify_gox) \\\n \texp/norm.gox \\\n \texp/proxy.gox \\\n-\texp/spdy.gox \\\n-\texp/ssh.gox \\\n \texp/terminal.gox \\\n \texp/types.gox \\\n \texp/utf8string.gox\n@@ -764,7 +735,6 @@ toolexeclibgomime_DATA = \\\n \n toolexeclibgonetdir = $(toolexeclibgodir)/net\n toolexeclibgonet_DATA = \\\n-\tnet/dict.gox \\\n \tnet/http.gox \\\n \tnet/mail.gox \\\n \tnet/rpc.gox \\\n@@ -963,16 +933,8 @@ go_hash_files = \\\n \tgo/hash/hash.go\n \n go_html_files = \\\n-\tgo/html/const.go \\\n-\tgo/html/doc.go \\\n-\tgo/html/doctype.go \\\n \tgo/html/entity.go \\\n-\tgo/html/escape.go \\\n-\tgo/html/foreign.go \\\n-\tgo/html/node.go \\\n-\tgo/html/parse.go \\\n-\tgo/html/render.go \\\n-\tgo/html/token.go\n+\tgo/html/escape.go\n \n go_image_files = \\\n \tgo/image/format.go \\\n@@ -1146,12 +1108,6 @@ go_os_files = \\\n \tgo/os/types.go \\\n \tsignal_unix.go\n \n-go_patch_files = \\\n-\tgo/patch/apply.go \\\n-\tgo/patch/git.go \\\n-\tgo/patch/patch.go \\\n-\tgo/patch/textdiff.go\n-\n go_path_files = \\\n \tgo/path/match.go \\\n \tgo/path/path.go\n@@ -1237,13 +1193,6 @@ go_unicode_files = \\\n \tgo/unicode/letter.go \\\n \tgo/unicode/tables.go\n \n-go_websocket_files = \\\n-\tgo/websocket/client.go \\\n-\tgo/websocket/hixie.go \\\n-\tgo/websocket/hybi.go \\\n-\tgo/websocket/server.go \\\n-\tgo/websocket/websocket.go\n-\n go_archive_tar_files = \\\n \tgo/archive/tar/common.go \\\n \tgo/archive/tar/reader.go \\\n@@ -1266,8 +1215,7 @@ go_compress_flate_files = \\\n \tgo/compress/flate/huffman_code.go \\\n \tgo/compress/flate/inflate.go \\\n \tgo/compress/flate/reverse_bits.go \\\n-\tgo/compress/flate/token.go \\\n-\tgo/compress/flate/util.go\n+\tgo/compress/flate/token.go\n \n go_compress_gzip_files = \\\n \tgo/compress/gzip/gzip.go \\\n@@ -1295,18 +1243,6 @@ go_crypto_aes_files = \\\n \tgo/crypto/aes/cipher.go \\\n \tgo/crypto/aes/const.go\n \n-go_crypto_bcrypt_files = \\\n-\tgo/crypto/bcrypt/base64.go \\\n-\tgo/crypto/bcrypt/bcrypt.go\n-\n-go_crypto_blowfish_files = \\\n-\tgo/crypto/blowfish/block.go \\\n-\tgo/crypto/blowfish/const.go \\\n-\tgo/crypto/blowfish/cipher.go\n-\n-go_crypto_cast5_files = \\\n-\tgo/crypto/cast5/cast5.go\n-\n go_crypto_cipher_files = \\\n \tgo/crypto/cipher/cbc.go \\\n \tgo/crypto/cipher/cfb.go \\\n@@ -1334,23 +1270,10 @@ go_crypto_elliptic_files = \\\n go_crypto_hmac_files = \\\n \tgo/crypto/hmac/hmac.go\n \n-go_crypto_md4_files = \\\n-\tgo/crypto/md4/md4.go \\\n-\tgo/crypto/md4/md4block.go\n-\n go_crypto_md5_files = \\\n \tgo/crypto/md5/md5.go \\\n \tgo/crypto/md5/md5block.go\n \n-go_crypto_ocsp_files = \\\n-\tgo/crypto/ocsp/ocsp.go\n-\n-go_crypto_openpgp_files = \\\n-\tgo/crypto/openpgp/canonical_text.go \\\n-\tgo/crypto/openpgp/keys.go \\\n-\tgo/crypto/openpgp/read.go \\\n-\tgo/crypto/openpgp/write.go\n-\n go_crypto_rand_files = \\\n \tgo/crypto/rand/rand.go \\\n \tgo/crypto/rand/rand_unix.go \\\n@@ -1359,10 +1282,6 @@ go_crypto_rand_files = \\\n go_crypto_rc4_files = \\\n \tgo/crypto/rc4/rc4.go\n \n-go_crypto_ripemd160_files = \\\n-\tgo/crypto/ripemd160/ripemd160.go \\\n-\tgo/crypto/ripemd160/ripemd160block.go\n-\n go_crypto_rsa_files = \\\n \tgo/crypto/rsa/pkcs1v15.go \\\n \tgo/crypto/rsa/rsa.go\n@@ -1395,47 +1314,13 @@ go_crypto_tls_files = \\\n \tgo/crypto/tls/root_unix.go \\\n \tgo/crypto/tls/tls.go\n \n-go_crypto_twofish_files = \\\n-\tgo/crypto/twofish/twofish.go\n-\n go_crypto_x509_files = \\\n \tgo/crypto/x509/cert_pool.go \\\n \tgo/crypto/x509/pkcs1.go \\\n \tgo/crypto/x509/pkcs8.go \\\n \tgo/crypto/x509/verify.go \\\n \tgo/crypto/x509/x509.go\n \n-go_crypto_xtea_files = \\\n-\tgo/crypto/xtea/block.go \\\n-\tgo/crypto/xtea/cipher.go\n-\n-go_crypto_openpgp_armor_files = \\\n-\tgo/crypto/openpgp/armor/armor.go \\\n-\tgo/crypto/openpgp/armor/encode.go\n-\n-go_crypto_openpgp_elgamal_files = \\\n-\tgo/crypto/openpgp/elgamal/elgamal.go\n-\n-go_crypto_openpgp_errors_files = \\\n-\tgo/crypto/openpgp/errors/errors.go\n-\n-go_crypto_openpgp_packet_files = \\\n-\tgo/crypto/openpgp/packet/compressed.go \\\n-\tgo/crypto/openpgp/packet/encrypted_key.go \\\n-\tgo/crypto/openpgp/packet/literal.go \\\n-\tgo/crypto/openpgp/packet/one_pass_signature.go \\\n-\tgo/crypto/openpgp/packet/packet.go \\\n-\tgo/crypto/openpgp/packet/private_key.go \\\n-\tgo/crypto/openpgp/packet/public_key.go \\\n-\tgo/crypto/openpgp/packet/reader.go \\\n-\tgo/crypto/openpgp/packet/signature.go \\\n-\tgo/crypto/openpgp/packet/symmetric_key_encrypted.go \\\n-\tgo/crypto/openpgp/packet/symmetrically_encrypted.go \\\n-\tgo/crypto/openpgp/packet/userid.go\n-\n-go_crypto_openpgp_s2k_files = \\\n-\tgo/crypto/openpgp/s2k/s2k.go\n-\n go_crypto_x509_pkix_files = \\\n \tgo/crypto/x509/pkix/pkix.go\n \n@@ -1493,9 +1378,6 @@ go_encoding_csv_files = \\\n \tgo/encoding/csv/reader.go \\\n \tgo/encoding/csv/writer.go\n \n-go_encoding_git85_files = \\\n-\tgo/encoding/git85/git.go\n-\n go_encoding_gob_files = \\\n \tgo/encoding/gob/decode.go \\\n \tgo/encoding/gob/decoder.go \\\n@@ -1529,6 +1411,18 @@ go_exp_ebnf_files = \\\n \tgo/exp/ebnf/ebnf.go \\\n \tgo/exp/ebnf/parser.go\n \n+go_exp_html_files = \\\n+\tgo/exp/html/const.go \\\n+\tgo/exp/html/doc.go \\\n+\tgo/exp/html/doctype.go \\\n+\tgo/exp/html/entity.go \\\n+\tgo/exp/html/escape.go \\\n+\tgo/exp/html/foreign.go \\\n+\tgo/exp/html/node.go \\\n+\tgo/exp/html/parse.go \\\n+\tgo/exp/html/render.go \\\n+\tgo/exp/html/token.go\n+\n go_exp_inotify_files = \\\n \tgo/exp/inotify/inotify_linux.go\n \n@@ -1547,25 +1441,6 @@ go_exp_proxy_files = \\\n \tgo/exp/proxy/proxy.go \\\n \tgo/exp/proxy/socks5.go\n \n-go_exp_spdy_files = \\\n-\tgo/exp/spdy/read.go \\\n-\tgo/exp/spdy/types.go \\\n-\tgo/exp/spdy/write.go\n-\n-go_exp_ssh_files = \\\n-\tgo/exp/ssh/channel.go \\\n-\tgo/exp/ssh/cipher.go \\\n-\tgo/exp/ssh/client.go \\\n-\tgo/exp/ssh/client_auth.go \\\n-\tgo/exp/ssh/common.go \\\n-\tgo/exp/ssh/doc.go \\\n-\tgo/exp/ssh/messages.go \\\n-\tgo/exp/ssh/server.go \\\n-\tgo/exp/ssh/server_terminal.go \\\n-\tgo/exp/ssh/session.go \\\n-\tgo/exp/ssh/tcpip.go \\\n-\tgo/exp/ssh/transport.go\n-\n go_exp_terminal_files = \\\n \tgo/exp/terminal/terminal.go \\\n \tgo/exp/terminal/util.go\n@@ -1721,9 +1596,6 @@ go_mime_multipart_files = \\\n \tgo/mime/multipart/multipart.go \\\n \tgo/mime/multipart/writer.go\n \n-go_net_dict_files = \\\n-\tgo/net/dict/dict.go\n-\n go_net_http_files = \\\n \tgo/net/http/chunked.go \\\n \tgo/net/http/client.go \\\n@@ -1988,7 +1860,6 @@ libgo_go_objs = \\\n \tnet/net.lo \\\n \tos/exec.lo \\\n \tos/os.lo \\\n-\tpatch/patch.lo \\\n \tpath/path.lo \\\n \treflect/reflect.lo \\\n \tregexp/regexp.lo \\\n@@ -1999,7 +1870,6 @@ libgo_go_objs = \\\n \tsync/sync.lo \\\n \ttime/time.lo \\\n \tunicode/unicode.lo \\\n-\twebsocket/websocket.lo \\\n \tarchive/tar.lo \\\n \tarchive/zip.lo \\\n \tcompress/bzip2.lo \\\n@@ -2011,36 +1881,22 @@ libgo_go_objs = \\\n \tcontainer/list.lo \\\n \tcontainer/ring.lo \\\n \tcrypto/aes.lo \\\n-\tcrypto/bcrypt.lo \\\n-\tcrypto/blowfish.lo \\\n-\tcrypto/cast5.lo \\\n \tcrypto/cipher.lo \\\n \tcrypto/des.lo \\\n \tcrypto/dsa.lo \\\n \tcrypto/ecdsa.lo \\\n \tcrypto/elliptic.lo \\\n \tcrypto/hmac.lo \\\n-\tcrypto/md4.lo \\\n \tcrypto/md5.lo \\\n-\tcrypto/ocsp.lo \\\n-\tcrypto/openpgp.lo \\\n \tcrypto/rand.lo \\\n \tcrypto/rc4.lo \\\n-\tcrypto/ripemd160.lo \\\n \tcrypto/rsa.lo \\\n \tcrypto/sha1.lo \\\n \tcrypto/sha256.lo \\\n \tcrypto/sha512.lo \\\n \tcrypto/subtle.lo \\\n \tcrypto/tls.lo \\\n-\tcrypto/twofish.lo \\\n \tcrypto/x509.lo \\\n-\tcrypto/xtea.lo \\\n-\tcrypto/openpgp/armor.lo \\\n-\tcrypto/openpgp/elgamal.lo \\\n-\tcrypto/openpgp/errors.lo \\\n-\tcrypto/openpgp/packet.lo \\\n-\tcrypto/openpgp/s2k.lo \\\n \tcrypto/x509/pkix.lo \\\n \tdatabase/sql.lo \\\n \tdatabase/sql/driver.lo \\\n@@ -2055,17 +1911,15 @@ libgo_go_objs = \\\n \tencoding/base64.lo \\\n \tencoding/binary.lo \\\n \tencoding/csv.lo \\\n-\tencoding/git85.lo \\\n \tencoding/gob.lo \\\n \tencoding/hex.lo \\\n \tencoding/json.lo \\\n \tencoding/pem.lo \\\n \tencoding/xml.lo \\\n \texp/ebnf.lo \\\n+\texp/html.lo \\\n \texp/norm.lo \\\n \texp/proxy.lo \\\n-\texp/spdy.lo \\\n-\texp/ssh.lo \\\n \texp/terminal.lo \\\n \texp/types.lo \\\n \texp/utf8string.lo \\\n@@ -2102,7 +1956,6 @@ libgo_go_objs = \\\n \tmath/rand.lo \\\n \tmime/mime.lo \\\n \tmime/multipart.lo \\\n-\tnet/dict.lo \\\n \tnet/http.lo \\\n \tnet/mail.lo \\\n \tnet/rpc.lo \\\n@@ -2211,7 +2064,6 @@ CHECK_DEPS = libgo.la libgobegin.a \\\n \t$(toolexeclibgocompress_DATA) \\\n \t$(toolexeclibgocontainer_DATA) \\\n \t$(toolexeclibgocrypto_DATA) \\\n-\t$(toolexeclibgocryptoopenpgp_DATA) \\\n \t$(toolexeclibgodebug_DATA) \\\n \t$(toolexeclibgoencoding_DATA) \\\n \t$(toolexeclibgoexp_DATA) \\\n@@ -2260,7 +2112,6 @@ TEST_PACKAGES = \\\n \tmime/check \\\n \tnet/check \\\n \tos/check \\\n-\tpatch/check \\\n \tpath/check \\\n \treflect/check \\\n \tregexp/check \\\n@@ -2271,7 +2122,6 @@ TEST_PACKAGES = \\\n \tsync/check \\\n \ttime/check \\\n \tunicode/check \\\n-\twebsocket/check \\\n \tarchive/tar/check \\\n \tarchive/zip/check \\\n \tcompress/bzip2/check \\\n@@ -2283,35 +2133,22 @@ TEST_PACKAGES = \\\n \tcontainer/list/check \\\n \tcontainer/ring/check \\\n \tcrypto/aes/check \\\n-\tcrypto/bcrypt/check \\\n-\tcrypto/blowfish/check \\\n-\tcrypto/cast5/check \\\n \tcrypto/cipher/check \\\n \tcrypto/des/check \\\n \tcrypto/dsa/check \\\n \tcrypto/ecdsa/check \\\n \tcrypto/elliptic/check \\\n \tcrypto/hmac/check \\\n-\tcrypto/md4/check \\\n \tcrypto/md5/check \\\n-\tcrypto/ocsp/check \\\n-\tcrypto/openpgp/check \\\n \tcrypto/rand/check \\\n \tcrypto/rc4/check \\\n-\tcrypto/ripemd160/check \\\n \tcrypto/rsa/check \\\n \tcrypto/sha1/check \\\n \tcrypto/sha256/check \\\n \tcrypto/sha512/check \\\n \tcrypto/subtle/check \\\n \tcrypto/tls/check \\\n-\tcrypto/twofish/check \\\n \tcrypto/x509/check \\\n-\tcrypto/xtea/check \\\n-\tcrypto/openpgp/armor/check \\\n-\tcrypto/openpgp/elgamal/check \\\n-\tcrypto/openpgp/packet/check \\\n-\tcrypto/openpgp/s2k/check \\\n \tdatabase/sql/check \\\n \tdatabase/sql/driver/check \\\n \tdebug/dwarf/check \\\n@@ -2324,18 +2161,16 @@ TEST_PACKAGES = \\\n \tencoding/base64/check \\\n \tencoding/binary/check \\\n \tencoding/csv/check \\\n-\tencoding/git85/check \\\n \tencoding/gob/check \\\n \tencoding/hex/check \\\n \tencoding/json/check \\\n \tencoding/pem/check \\\n \tencoding/xml/check \\\n \texp/ebnf/check \\\n+\texp/html/check \\\n \t$(exp_inotify_check) \\\n \texp/norm/check \\\n \texp/proxy/check \\\n-\texp/spdy/check \\\n-\texp/ssh/check \\\n \texp/terminal/check \\\n \texp/utf8string/check \\\n \thtml/template/check \\\n@@ -3353,26 +3188,6 @@ uninstall-toolexeclibgocryptoDATA:\n \ttest -n \"$$files\" || exit 0; \\\n \techo \" ( cd '$(DESTDIR)$(toolexeclibgocryptodir)' && rm -f\" $$files \")\"; \\\n \tcd \"$(DESTDIR)$(toolexeclibgocryptodir)\" && rm -f $$files\n-install-toolexeclibgocryptoopenpgpDATA: $(toolexeclibgocryptoopenpgp_DATA)\n-\t@$(NORMAL_INSTALL)\n-\ttest -z \"$(toolexeclibgocryptoopenpgpdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\"\n-\t@list='$(toolexeclibgocryptoopenpgp_DATA)'; test -n \"$(toolexeclibgocryptoopenpgpdir)\" || list=; \\\n-\tfor p in $$list; do \\\n-\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n-\t  echo \"$$d$$p\"; \\\n-\tdone | $(am__base_list) | \\\n-\twhile read files; do \\\n-\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)'\"; \\\n-\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" || exit $$?; \\\n-\tdone\n-\n-uninstall-toolexeclibgocryptoopenpgpDATA:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(toolexeclibgocryptoopenpgp_DATA)'; test -n \"$(toolexeclibgocryptoopenpgpdir)\" || list=; \\\n-\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n-\ttest -n \"$$files\" || exit 0; \\\n-\techo \" ( cd '$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)' && rm -f\" $$files \")\"; \\\n-\tcd \"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" && rm -f $$files\n install-toolexeclibgocryptox509DATA: $(toolexeclibgocryptox509_DATA)\n \t@$(NORMAL_INSTALL)\n \ttest -z \"$(toolexeclibgocryptox509dir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgocryptox509dir)\"\n@@ -4250,7 +4065,7 @@ all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) all-multi $(DATA) \\\n \t\tconfig.h\n installdirs: installdirs-recursive\n installdirs-am:\n-\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \"$(DESTDIR)$(toolexeclibgodatabasedir)\" \"$(DESTDIR)$(toolexeclibgodatabasesqldir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohtmldir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgologdir)\" \"$(DESTDIR)$(toolexeclibgomathdir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgonethttpdir)\" \"$(DESTDIR)$(toolexeclibgonetrpcdir)\" \"$(DESTDIR)$(toolexeclibgoolddir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgopathdir)\" \"$(DESTDIR)$(toolexeclibgoregexpdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\" \"$(DESTDIR)$(toolexeclibgotextdir)\" \"$(DESTDIR)$(toolexeclibgotexttemplatedir)\" \"$(DESTDIR)$(toolexeclibgounicodedir)\"; do \\\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \"$(DESTDIR)$(toolexeclibgodatabasedir)\" \"$(DESTDIR)$(toolexeclibgodatabasesqldir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohtmldir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgologdir)\" \"$(DESTDIR)$(toolexeclibgomathdir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgonethttpdir)\" \"$(DESTDIR)$(toolexeclibgonetrpcdir)\" \"$(DESTDIR)$(toolexeclibgoolddir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgopathdir)\" \"$(DESTDIR)$(toolexeclibgoregexpdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\" \"$(DESTDIR)$(toolexeclibgotextdir)\" \"$(DESTDIR)$(toolexeclibgotexttemplatedir)\" \"$(DESTDIR)$(toolexeclibgounicodedir)\"; do \\\n \t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n \tdone\n install: install-recursive\n@@ -4316,7 +4131,6 @@ install-exec-am: install-multi install-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgocompressDATA \\\n \tinstall-toolexeclibgocontainerDATA \\\n \tinstall-toolexeclibgocryptoDATA \\\n-\tinstall-toolexeclibgocryptoopenpgpDATA \\\n \tinstall-toolexeclibgocryptox509DATA \\\n \tinstall-toolexeclibgodatabaseDATA \\\n \tinstall-toolexeclibgodatabasesqlDATA \\\n@@ -4382,7 +4196,6 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgocompressDATA \\\n \tuninstall-toolexeclibgocontainerDATA \\\n \tuninstall-toolexeclibgocryptoDATA \\\n-\tuninstall-toolexeclibgocryptoopenpgpDATA \\\n \tuninstall-toolexeclibgocryptox509DATA \\\n \tuninstall-toolexeclibgodatabaseDATA \\\n \tuninstall-toolexeclibgodatabasesqlDATA \\\n@@ -4431,7 +4244,6 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgocompressDATA \\\n \tinstall-toolexeclibgocontainerDATA \\\n \tinstall-toolexeclibgocryptoDATA \\\n-\tinstall-toolexeclibgocryptoopenpgpDATA \\\n \tinstall-toolexeclibgocryptox509DATA \\\n \tinstall-toolexeclibgodatabaseDATA \\\n \tinstall-toolexeclibgodatabasesqlDATA \\\n@@ -4461,7 +4273,6 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgocompressDATA \\\n \tuninstall-toolexeclibgocontainerDATA \\\n \tuninstall-toolexeclibgocryptoDATA \\\n-\tuninstall-toolexeclibgocryptoopenpgpDATA \\\n \tuninstall-toolexeclibgocryptox509DATA \\\n \tuninstall-toolexeclibgodatabaseDATA \\\n \tuninstall-toolexeclibgodatabasesqlDATA \\\n@@ -4737,15 +4548,6 @@ signal_unix.go: $(srcdir)/go/os/mkunixsignals.sh sysinfo.go\n \t$(SHELL) $(srcdir)/go/os/mkunixsignals.sh sysinfo.go > $@.tmp\n \tmv -f $@.tmp $@\n \n-@go_include@ patch/patch.lo.dep\n-patch/patch.lo.dep: $(go_patch_files)\n-\t$(BUILDDEPS)\n-patch/patch.lo: $(go_patch_files)\n-\t$(BUILDPACKAGE)\n-patch/check: $(CHECK_DEPS)\n-\t@$(CHECK)\n-.PHONY: patch/check\n-\n @go_include@ path/path.lo.dep\n path/path.lo.dep: $(go_path_files)\n \t$(BUILDDEPS)\n@@ -4855,15 +4657,6 @@ unicode/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: unicode/check\n \n-@go_include@ websocket/websocket.lo.dep\n-websocket/websocket.lo.dep: $(go_websocket_files)\n-\t$(BUILDDEPS)\n-websocket/websocket.lo: $(go_websocket_files)\n-\t$(BUILDPACKAGE)\n-websocket/check: $(CHECK_DEPS)\n-\t@$(CHECK)\n-.PHONY: websocket/check\n-\n @go_include@ archive/tar.lo.dep\n archive/tar.lo.dep: $(go_archive_tar_files)\n \t$(BUILDDEPS)\n@@ -4974,36 +4767,6 @@ crypto/aes/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/aes/check\n \n-@go_include@ crypto/bcrypt.lo.dep\n-crypto/bcrypt.lo.dep: $(go_crypto_bcrypt_files)\n-\t$(BUILDDEPS)\n-crypto/bcrypt.lo: $(go_crypto_bcrypt_files)\n-\t$(BUILDPACKAGE)\n-crypto/bcrypt/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/bcrypt\n-\t@$(CHECK)\n-.PHONY: crypto/bcrypt/check\n-\n-@go_include@ crypto/blowfish.lo.dep\n-crypto/blowfish.lo.dep: $(go_crypto_blowfish_files)\n-\t$(BUILDDEPS)\n-crypto/blowfish.lo: $(go_crypto_blowfish_files)\n-\t$(BUILDPACKAGE)\n-crypto/blowfish/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/blowfish\n-\t@$(CHECK)\n-.PHONY: crypto/blowfish/check\n-\n-@go_include@ crypto/cast5.lo.dep\n-crypto/cast5.lo.dep: $(go_crypto_cast5_files)\n-\t$(BUILDDEPS)\n-crypto/cast5.lo: $(go_crypto_cast5_files)\n-\t$(BUILDPACKAGE)\n-crypto/cast5/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/cast5\n-\t@$(CHECK)\n-.PHONY: crypto/cast5/check\n-\n @go_include@ crypto/cipher.lo.dep\n crypto/cipher.lo.dep: $(go_crypto_cipher_files)\n \t$(BUILDDEPS)\n@@ -5064,16 +4827,6 @@ crypto/hmac/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/hmac/check\n \n-@go_include@ crypto/md4.lo.dep\n-crypto/md4.lo.dep: $(go_crypto_md4_files)\n-\t$(BUILDDEPS)\n-crypto/md4.lo: $(go_crypto_md4_files)\n-\t$(BUILDPACKAGE)\n-crypto/md4/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/md4\n-\t@$(CHECK)\n-.PHONY: crypto/md4/check\n-\n @go_include@ crypto/md5.lo.dep\n crypto/md5.lo.dep: $(go_crypto_md5_files)\n \t$(BUILDDEPS)\n@@ -5084,26 +4837,6 @@ crypto/md5/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/md5/check\n \n-@go_include@ crypto/ocsp.lo.dep\n-crypto/ocsp.lo.dep: $(go_crypto_ocsp_files)\n-\t$(BUILDDEPS)\n-crypto/ocsp.lo: $(go_crypto_ocsp_files)\n-\t$(BUILDPACKAGE)\n-crypto/ocsp/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/ocsp\n-\t@$(CHECK)\n-.PHONY: crypto/ocsp/check\n-\n-@go_include@ crypto/openpgp.lo.dep\n-crypto/openpgp.lo.dep: $(go_crypto_openpgp_files)\n-\t$(BUILDDEPS)\n-crypto/openpgp.lo: $(go_crypto_openpgp_files)\n-\t$(BUILDPACKAGE)\n-crypto/openpgp/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/openpgp\n-\t@$(CHECK)\n-.PHONY: crypto/openpgp/check\n-\n @go_include@ crypto/rand.lo.dep\n crypto/rand.lo.dep: $(go_crypto_rand_files)\n \t$(BUILDDEPS)\n@@ -5124,16 +4857,6 @@ crypto/rc4/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/rc4/check\n \n-@go_include@ crypto/ripemd160.lo.dep\n-crypto/ripemd160.lo.dep: $(go_crypto_ripemd160_files)\n-\t$(BUILDDEPS)\n-crypto/ripemd160.lo: $(go_crypto_ripemd160_files)\n-\t$(BUILDPACKAGE)\n-crypto/ripemd160/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/ripemd160\n-\t@$(CHECK)\n-.PHONY: crypto/ripemd160/check\n-\n @go_include@ crypto/rsa.lo.dep\n crypto/rsa.lo.dep: $(go_crypto_rsa_files)\n \t$(BUILDDEPS)\n@@ -5194,16 +4917,6 @@ crypto/tls/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/tls/check\n \n-@go_include@ crypto/twofish.lo.dep\n-crypto/twofish.lo.dep: $(go_crypto_twofish_files)\n-\t$(BUILDDEPS)\n-crypto/twofish.lo: $(go_crypto_twofish_files)\n-\t$(BUILDPACKAGE)\n-crypto/twofish/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/twofish\n-\t@$(CHECK)\n-.PHONY: crypto/twofish/check\n-\n @go_include@ crypto/x509.lo.dep\n crypto/x509.lo.dep: $(go_crypto_x509_files)\n \t$(BUILDDEPS)\n@@ -5214,66 +4927,6 @@ crypto/x509/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/x509/check\n \n-@go_include@ crypto/xtea.lo.dep\n-crypto/xtea.lo.dep: $(go_crypto_xtea_files)\n-\t$(BUILDDEPS)\n-crypto/xtea.lo: $(go_crypto_xtea_files)\n-\t$(BUILDPACKAGE)\n-crypto/xtea/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/xtea\n-\t@$(CHECK)\n-.PHONY: crypto/xtea/check\n-\n-@go_include@ crypto/openpgp/armor.lo.dep\n-crypto/openpgp/armor.lo.dep: $(go_crypto_openpgp_armor_files)\n-\t$(BUILDDEPS)\n-crypto/openpgp/armor.lo: $(go_crypto_openpgp_armor_files)\n-\t$(BUILDPACKAGE)\n-crypto/openpgp/armor/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/openpgp/armor\n-\t@$(CHECK)\n-.PHONY: crypto/openpgp/armor/check\n-\n-@go_include@ crypto/openpgp/elgamal.lo.dep\n-crypto/openpgp/elgamal.lo.dep: $(go_crypto_openpgp_elgamal_files)\n-\t$(BUILDDEPS)\n-crypto/openpgp/elgamal.lo: $(go_crypto_openpgp_elgamal_files)\n-\t$(BUILDPACKAGE)\n-crypto/openpgp/elgamal/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/openpgp/elgamal\n-\t@$(CHECK)\n-.PHONY: crypto/openpgp/elgamal/check\n-\n-@go_include@ crypto/openpgp/errors.lo.dep\n-crypto/openpgp/errors.lo.dep: $(go_crypto_openpgp_errors_files)\n-\t$(BUILDDEPS)\n-crypto/openpgp/errors.lo: $(go_crypto_openpgp_errors_files)\n-\t$(BUILDPACKAGE)\n-crypto/openpgp/errors/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/openpgp/errors\n-\t@$(CHECK)\n-.PHONY: crypto/openpgp/errors/check\n-\n-@go_include@ crypto/openpgp/packet.lo.dep\n-crypto/openpgp/packet.lo.dep: $(go_crypto_openpgp_packet_files)\n-\t$(BUILDDEPS)\n-crypto/openpgp/packet.lo: $(go_crypto_openpgp_packet_files)\n-\t$(BUILDPACKAGE)\n-crypto/openpgp/packet/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/openpgp/packet\n-\t@$(CHECK)\n-.PHONY: crypto/openpgp/packet/check\n-\n-@go_include@ crypto/openpgp/s2k.lo.dep\n-crypto/openpgp/s2k.lo.dep: $(go_crypto_openpgp_s2k_files)\n-\t$(BUILDDEPS)\n-crypto/openpgp/s2k.lo: $(go_crypto_openpgp_s2k_files)\n-\t$(BUILDPACKAGE)\n-crypto/openpgp/s2k/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/openpgp/s2k\n-\t@$(CHECK)\n-.PHONY: crypto/openpgp/s2k/check\n-\n @go_include@ crypto/x509/pkix.lo.dep\n crypto/x509/pkix.lo.dep: $(go_crypto_x509_pkix_files)\n \t$(BUILDDEPS)\n@@ -5414,16 +5067,6 @@ encoding/csv/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: encoding/csv/check\n \n-@go_include@ encoding/git85.lo.dep\n-encoding/git85.lo.dep: $(go_encoding_git85_files)\n-\t$(BUILDDEPS)\n-encoding/git85.lo: $(go_encoding_git85_files)\n-\t$(BUILDPACKAGE)\n-encoding/git85/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) encoding/git85\n-\t@$(CHECK)\n-.PHONY: encoding/git85/check\n-\n @go_include@ encoding/gob.lo.dep\n encoding/gob.lo.dep: $(go_encoding_gob_files)\n \t$(BUILDDEPS)\n@@ -5484,6 +5127,16 @@ exp/ebnf/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/ebnf/check\n \n+@go_include@ exp/html.lo.dep\n+exp/html.lo.dep: $(go_exp_html_files)\n+\t$(BUILDDEPS)\n+exp/html.lo: $(go_exp_html_files)\n+\t$(BUILDPACKAGE)\n+exp/html/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/html\n+\t@$(CHECK)\n+.PHONY: exp/html/check\n+\n @go_include@ exp/norm.lo.dep\n exp/norm.lo.dep: $(go_exp_norm_files)\n \t$(BUILDDEPS)\n@@ -5504,26 +5157,6 @@ exp/proxy/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/proxy/check\n \n-@go_include@ exp/spdy.lo.dep\n-exp/spdy.lo.dep: $(go_exp_spdy_files)\n-\t$(BUILDDEPS)\n-exp/spdy.lo: $(go_exp_spdy_files)\n-\t$(BUILDPACKAGE)\n-exp/spdy/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/spdy\n-\t@$(CHECK)\n-.PHONY: exp/spdy/check\n-\n-@go_include@ exp/ssh.lo.dep\n-exp/ssh.lo.dep: $(go_exp_ssh_files)\n-\t$(BUILDDEPS)\n-exp/ssh.lo: $(go_exp_ssh_files)\n-\t$(BUILDPACKAGE)\n-exp/ssh/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/ssh\n-\t@$(CHECK)\n-.PHONY: exp/ssh/check\n-\n @go_include@ exp/terminal.lo.dep\n exp/terminal.lo.dep: $(go_exp_terminal_files)\n \t$(BUILDDEPS)\n@@ -5835,12 +5468,6 @@ mime/multipart/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: mime/multipart/check\n \n-@go_include@ net/dict.lo.dep\n-net/dict.lo.dep: $(go_net_dict_files)\n-\t$(BUILDDEPS)\n-net/dict.lo: $(go_net_dict_files)\n-\t$(BUILDPACKAGE)\n-\n @go_include@ net/http.lo.dep\n net/http.lo.dep: $(go_net_http_files)\n \t$(BUILDDEPS)\n@@ -6194,8 +5821,6 @@ net.gox: net/net.lo\n \t$(BUILDGOX)\n os.gox: os/os.lo\n \t$(BUILDGOX)\n-patch.gox: patch/patch.lo\n-\t$(BUILDGOX)\n path.gox: path/path.lo\n \t$(BUILDGOX)\n reflect.gox: reflect/reflect.lo\n@@ -6220,8 +5845,6 @@ time.gox: time/time.lo\n \t$(BUILDGOX)\n unicode.gox: unicode/unicode.lo\n \t$(BUILDGOX)\n-websocket.gox: websocket/websocket.lo\n-\t$(BUILDGOX)\n \n archive/tar.gox: archive/tar.lo\n \t$(BUILDGOX)\n@@ -6248,12 +5871,6 @@ container/ring.gox: container/ring.lo\n \n crypto/aes.gox: crypto/aes.lo\n \t$(BUILDGOX)\n-crypto/bcrypt.gox: crypto/bcrypt.lo\n-\t$(BUILDGOX)\n-crypto/blowfish.gox: crypto/blowfish.lo\n-\t$(BUILDGOX)\n-crypto/cast5.gox: crypto/cast5.lo\n-\t$(BUILDGOX)\n crypto/cipher.gox: crypto/cipher.lo\n \t$(BUILDGOX)\n crypto/des.gox: crypto/des.lo\n@@ -6266,20 +5883,12 @@ crypto/elliptic.gox: crypto/elliptic.lo\n \t$(BUILDGOX)\n crypto/hmac.gox: crypto/hmac.lo\n \t$(BUILDGOX)\n-crypto/md4.gox: crypto/md4.lo\n-\t$(BUILDGOX)\n crypto/md5.gox: crypto/md5.lo\n \t$(BUILDGOX)\n-crypto/ocsp.gox: crypto/ocsp.lo\n-\t$(BUILDGOX)\n-crypto/openpgp.gox: crypto/openpgp.lo\n-\t$(BUILDGOX)\n crypto/rand.gox: crypto/rand.lo\n \t$(BUILDGOX)\n crypto/rc4.gox: crypto/rc4.lo\n \t$(BUILDGOX)\n-crypto/ripemd160.gox: crypto/ripemd160.lo\n-\t$(BUILDGOX)\n crypto/rsa.gox: crypto/rsa.lo\n \t$(BUILDGOX)\n crypto/sha1.gox: crypto/sha1.lo\n@@ -6292,23 +5901,8 @@ crypto/subtle.gox: crypto/subtle.lo\n \t$(BUILDGOX)\n crypto/tls.gox: crypto/tls.lo\n \t$(BUILDGOX)\n-crypto/twofish.gox: crypto/twofish.lo\n-\t$(BUILDGOX)\n crypto/x509.gox: crypto/x509.lo\n \t$(BUILDGOX)\n-crypto/xtea.gox: crypto/xtea.lo\n-\t$(BUILDGOX)\n-\n-crypto/openpgp/armor.gox: crypto/openpgp/armor.lo\n-\t$(BUILDGOX)\n-crypto/openpgp/elgamal.gox: crypto/openpgp/elgamal.lo\n-\t$(BUILDGOX)\n-crypto/openpgp/errors.gox: crypto/openpgp/errors.lo\n-\t$(BUILDGOX)\n-crypto/openpgp/packet.gox: crypto/openpgp/packet.lo\n-\t$(BUILDGOX)\n-crypto/openpgp/s2k.gox: crypto/openpgp/s2k.lo\n-\t$(BUILDGOX)\n \n crypto/x509/pkix.gox: crypto/x509/pkix.lo\n \t$(BUILDGOX)\n@@ -6342,8 +5936,6 @@ encoding/binary.gox: encoding/binary.lo\n \t$(BUILDGOX)\n encoding/csv.gox: encoding/csv.lo\n \t$(BUILDGOX)\n-encoding/git85.gox: encoding/git85.lo\n-\t$(BUILDGOX)\n encoding/gob.gox: encoding/gob.lo\n \t$(BUILDGOX)\n encoding/hex.gox: encoding/hex.lo\n@@ -6357,16 +5949,14 @@ encoding/xml.gox: encoding/xml.lo\n \n exp/ebnf.gox: exp/ebnf.lo\n \t$(BUILDGOX)\n+exp/html.gox: exp/html.lo\n+\t$(BUILDGOX)\n exp/inotify.gox: exp/inotify.lo\n \t$(BUILDGOX)\n exp/norm.gox: exp/norm.lo\n \t$(BUILDGOX)\n exp/proxy.gox: exp/proxy.lo\n \t$(BUILDGOX)\n-exp/spdy.gox: exp/spdy.lo\n-\t$(BUILDGOX)\n-exp/ssh.gox: exp/ssh.lo\n-\t$(BUILDGOX)\n exp/terminal.gox: exp/terminal.lo\n \t$(BUILDGOX)\n exp/types.gox: exp/types.lo\n@@ -6435,8 +6025,6 @@ math/rand.gox: math/rand.lo\n mime/multipart.gox: mime/multipart.lo\n \t$(BUILDGOX)\n \n-net/dict.gox: net/dict.lo\n-\t$(BUILDGOX)\n net/http.gox: net/http.lo\n \t$(BUILDGOX)\n net/mail.gox: net/mail.lo"}, {"sha": "755a730c8b4f98ddca28cc18c3a9c3c4199d62ca", "filename": "libgo/go/archive/tar/reader.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -18,7 +18,7 @@ import (\n )\n \n var (\n-\tHeaderError = errors.New(\"invalid tar header\")\n+\tErrHeader = errors.New(\"invalid tar header\")\n )\n \n // A Reader provides sequential access to the contents of a tar archive.\n@@ -123,13 +123,13 @@ func (tr *Reader) readHeader() *Header {\n \t\tif bytes.Equal(header, zeroBlock[0:blockSize]) {\n \t\t\ttr.err = io.EOF\n \t\t} else {\n-\t\t\ttr.err = HeaderError // zero block and then non-zero block\n+\t\t\ttr.err = ErrHeader // zero block and then non-zero block\n \t\t}\n \t\treturn nil\n \t}\n \n \tif !tr.verifyChecksum(header) {\n-\t\ttr.err = HeaderError\n+\t\ttr.err = ErrHeader\n \t\treturn nil\n \t}\n \n@@ -188,7 +188,7 @@ func (tr *Reader) readHeader() *Header {\n \t}\n \n \tif tr.err != nil {\n-\t\ttr.err = HeaderError\n+\t\ttr.err = ErrHeader\n \t\treturn nil\n \t}\n "}, {"sha": "0a8646c393fdc3cc85bc9193a18d46f0aa1dc33b", "filename": "libgo/go/archive/tar/reader_test.go", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -240,31 +240,20 @@ func TestNonSeekable(t *testing.T) {\n \t}\n \tdefer f.Close()\n \n-\t// pipe the data in\n-\tr, w, err := os.Pipe()\n-\tif err != nil {\n-\t\tt.Fatalf(\"Unexpected error %s\", err)\n+\ttype readerOnly struct {\n+\t\tio.Reader\n \t}\n-\tgo func() {\n-\t\trdbuf := make([]uint8, 1<<16)\n-\t\tfor {\n-\t\t\tnr, err := f.Read(rdbuf)\n-\t\t\tw.Write(rdbuf[0:nr])\n-\t\t\tif err == io.EOF {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t\tw.Close()\n-\t}()\n-\n-\ttr := NewReader(r)\n+\ttr := NewReader(readerOnly{f})\n \tnread := 0\n \n \tfor ; ; nread++ {\n-\t\thdr, err := tr.Next()\n-\t\tif hdr == nil || err == io.EOF {\n+\t\t_, err := tr.Next()\n+\t\tif err == io.EOF {\n \t\t\tbreak\n \t\t}\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"Unexpected error: %v\", err)\n+\t\t}\n \t}\n \n \tif nread != len(test.headers) {"}, {"sha": "4dd0f4f434421a8d8b1f473ffa1086e4a0f1c0c0", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -17,9 +17,9 @@ import (\n )\n \n var (\n-\tFormatError       = errors.New(\"zip: not a valid zip file\")\n-\tUnsupportedMethod = errors.New(\"zip: unsupported compression algorithm\")\n-\tChecksumError     = errors.New(\"zip: checksum error\")\n+\tErrFormat    = errors.New(\"zip: not a valid zip file\")\n+\tErrAlgorithm = errors.New(\"zip: unsupported compression algorithm\")\n+\tErrChecksum  = errors.New(\"zip: checksum error\")\n )\n \n type Reader struct {\n@@ -90,12 +90,12 @@ func (z *Reader) init(r io.ReaderAt, size int64) error {\n \n \t// The count of files inside a zip is truncated to fit in a uint16.\n \t// Gloss over this by reading headers until we encounter\n-\t// a bad one, and then only report a FormatError or UnexpectedEOF if\n+\t// a bad one, and then only report a ErrFormat or UnexpectedEOF if\n \t// the file count modulo 65536 is incorrect.\n \tfor {\n \t\tf := &File{zipr: r, zipsize: size}\n \t\terr = readDirectoryHeader(f, buf)\n-\t\tif err == FormatError || err == io.ErrUnexpectedEOF {\n+\t\tif err == ErrFormat || err == io.ErrUnexpectedEOF {\n \t\t\tbreak\n \t\t}\n \t\tif err != nil {\n@@ -135,7 +135,7 @@ func (f *File) Open() (rc io.ReadCloser, err error) {\n \tcase Deflate:\n \t\trc = flate.NewReader(r)\n \tdefault:\n-\t\terr = UnsupportedMethod\n+\t\terr = ErrAlgorithm\n \t}\n \tif rc != nil {\n \t\trc = &checksumReader{rc, crc32.NewIEEE(), f, r}\n@@ -162,7 +162,7 @@ func (r *checksumReader) Read(b []byte) (n int, err error) {\n \t\t}\n \t}\n \tif r.hash.Sum32() != r.f.CRC32 {\n-\t\terr = ChecksumError\n+\t\terr = ErrChecksum\n \t}\n \treturn\n }\n@@ -176,7 +176,7 @@ func readFileHeader(f *File, r io.Reader) error {\n \t}\n \tc := binary.LittleEndian\n \tif sig := c.Uint32(b[:4]); sig != fileHeaderSignature {\n-\t\treturn FormatError\n+\t\treturn ErrFormat\n \t}\n \tf.ReaderVersion = c.Uint16(b[4:6])\n \tf.Flags = c.Uint16(b[6:8])\n@@ -207,7 +207,7 @@ func (f *File) findBodyOffset() (int64, error) {\n \t}\n \tc := binary.LittleEndian\n \tif sig := c.Uint32(b[:4]); sig != fileHeaderSignature {\n-\t\treturn 0, FormatError\n+\t\treturn 0, ErrFormat\n \t}\n \tfilenameLen := int(c.Uint16(b[26:28]))\n \textraLen := int(c.Uint16(b[28:30]))\n@@ -216,15 +216,15 @@ func (f *File) findBodyOffset() (int64, error) {\n \n // readDirectoryHeader attempts to read a directory header from r.\n // It returns io.ErrUnexpectedEOF if it cannot read a complete header,\n-// and FormatError if it doesn't find a valid header signature.\n+// and ErrFormat if it doesn't find a valid header signature.\n func readDirectoryHeader(f *File, r io.Reader) error {\n \tvar b [directoryHeaderLen]byte\n \tif _, err := io.ReadFull(r, b[:]); err != nil {\n \t\treturn err\n \t}\n \tc := binary.LittleEndian\n \tif sig := c.Uint32(b[:4]); sig != directoryHeaderSignature {\n-\t\treturn FormatError\n+\t\treturn ErrFormat\n \t}\n \tf.CreatorVersion = c.Uint16(b[4:6])\n \tf.ReaderVersion = c.Uint16(b[6:8])\n@@ -280,7 +280,7 @@ func readDirectoryEnd(r io.ReaderAt, size int64) (dir *directoryEnd, err error)\n \t\t\tbreak\n \t\t}\n \t\tif i == 1 || bLen == size {\n-\t\t\treturn nil, FormatError\n+\t\t\treturn nil, ErrFormat\n \t\t}\n \t}\n "}, {"sha": "9407e35d5c08ce4a7bbacfad0e3ec7ed2bde02c9", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -70,7 +70,7 @@ var tests = []ZipTest{\n \t\t},\n \t},\n \t{Name: \"readme.zip\"},\n-\t{Name: \"readme.notzip\", Error: FormatError},\n+\t{Name: \"readme.notzip\", Error: ErrFormat},\n \t{\n \t\tName: \"dd.zip\",\n \t\tFile: []ZipTestFile{\n@@ -131,7 +131,7 @@ func readTestZip(t *testing.T, zt ZipTest) {\n \t}\n \n \t// bail if file is not zip\n-\tif err == FormatError {\n+\tif err == ErrFormat {\n \t\treturn\n \t}\n \tdefer func() {\n@@ -184,8 +184,8 @@ func readTestZip(t *testing.T, zt ZipTest) {\n \t\t}\n \t\tvar b bytes.Buffer\n \t\t_, err = io.Copy(&b, r)\n-\t\tif err != ChecksumError {\n-\t\t\tt.Errorf(\"%s: copy error=%v, want %v\", z.File[0].Name, err, ChecksumError)\n+\t\tif err != ErrChecksum {\n+\t\t\tt.Errorf(\"%s: copy error=%v, want %v\", z.File[0].Name, err, ErrChecksum)\n \t\t}\n \t}\n }\n@@ -250,13 +250,9 @@ func readTestFile(t *testing.T, ft ZipTestFile, f *File) {\n }\n \n func testFileMode(t *testing.T, f *File, want os.FileMode) {\n-\tmode, err := f.Mode()\n+\tmode := f.Mode()\n \tif want == 0 {\n-\t\tif err == nil {\n-\t\t\tt.Errorf(\"%s mode: got %v, want none\", f.Name, mode)\n-\t\t}\n-\t} else if err != nil {\n-\t\tt.Errorf(\"%s mode: %s\", f.Name, err)\n+\t\tt.Errorf(\"%s mode: got %v, want none\", f.Name, mode)\n \t} else if mode != want {\n \t\tt.Errorf(\"%s mode: want %v, got %v\", f.Name, want, mode)\n \t}\n@@ -268,8 +264,8 @@ func TestInvalidFiles(t *testing.T) {\n \n \t// zeroes\n \t_, err := NewReader(sliceReaderAt(b), size)\n-\tif err != FormatError {\n-\t\tt.Errorf(\"zeroes: error=%v, want %v\", err, FormatError)\n+\tif err != ErrFormat {\n+\t\tt.Errorf(\"zeroes: error=%v, want %v\", err, ErrFormat)\n \t}\n \n \t// repeated directoryEndSignatures\n@@ -279,8 +275,8 @@ func TestInvalidFiles(t *testing.T) {\n \t\tcopy(b[i:i+4], sig)\n \t}\n \t_, err = NewReader(sliceReaderAt(b), size)\n-\tif err != FormatError {\n-\t\tt.Errorf(\"sigs: error=%v, want %v\", err, FormatError)\n+\tif err != ErrFormat {\n+\t\tt.Errorf(\"sigs: error=%v, want %v\", err, ErrFormat)\n \t}\n }\n "}, {"sha": "67e9658629419a06bdbf064254735012fdd71372", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -12,6 +12,7 @@ This package does not support ZIP64 or disk spanning.\n package zip\n \n import (\n+\t\"errors\"\n \t\"os\"\n \t\"time\"\n )\n@@ -55,6 +56,38 @@ type FileHeader struct {\n \tComment          string\n }\n \n+// FileInfo returns an os.FileInfo for the FileHeader.\n+func (fh *FileHeader) FileInfo() os.FileInfo {\n+\treturn headerFileInfo{fh}\n+}\n+\n+// headerFileInfo implements os.FileInfo.\n+type headerFileInfo struct {\n+\tfh *FileHeader\n+}\n+\n+func (fi headerFileInfo) Name() string       { return fi.fh.Name }\n+func (fi headerFileInfo) Size() int64        { return int64(fi.fh.UncompressedSize) }\n+func (fi headerFileInfo) IsDir() bool        { return fi.Mode().IsDir() }\n+func (fi headerFileInfo) ModTime() time.Time { return fi.fh.ModTime() }\n+func (fi headerFileInfo) Mode() os.FileMode  { return fi.fh.Mode() }\n+\n+// FileInfoHeader creates a partially-populated FileHeader from an\n+// os.FileInfo.\n+func FileInfoHeader(fi os.FileInfo) (*FileHeader, error) {\n+\tsize := fi.Size()\n+\tif size > (1<<32 - 1) {\n+\t\treturn nil, errors.New(\"zip: file over 4GB\")\n+\t}\n+\tfh := &FileHeader{\n+\t\tName:             fi.Name(),\n+\t\tUncompressedSize: uint32(size),\n+\t}\n+\tfh.SetModTime(fi.ModTime())\n+\tfh.SetMode(fi.Mode())\n+\treturn fh, nil\n+}\n+\n type directoryEnd struct {\n \tdiskNbr            uint16 // unused\n \tdirDiskNbr         uint16 // unused\n@@ -131,8 +164,7 @@ const (\n )\n \n // Mode returns the permission and mode bits for the FileHeader.\n-// An error is returned in case the information is not available.\n-func (h *FileHeader) Mode() (mode os.FileMode, err error) {\n+func (h *FileHeader) Mode() (mode os.FileMode) {\n \tswitch h.CreatorVersion >> 8 {\n \tcase creatorUnix, creatorMacOSX:\n \t\tmode = unixModeToFileMode(h.ExternalAttrs >> 16)\n@@ -142,7 +174,7 @@ func (h *FileHeader) Mode() (mode os.FileMode, err error) {\n \tif len(h.Name) > 0 && h.Name[len(h.Name)-1] == '/' {\n \t\tmode |= os.ModeDir\n \t}\n-\treturn mode, nil\n+\treturn mode\n }\n \n // SetMode changes the permission and mode bits for the FileHeader."}, {"sha": "b1b128e2a7da406c7ef11d91e5ba9734a71b2859", "filename": "libgo/go/archive/zip/writer.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -129,7 +129,7 @@ func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error) {\n \tcase Deflate:\n \t\tfw.comp = flate.NewWriter(fw.compCount, 5)\n \tdefault:\n-\t\treturn nil, UnsupportedMethod\n+\t\treturn nil, ErrAlgorithm\n \t}\n \tfw.rawCount = &countWriter{w: fw.comp}\n "}, {"sha": "acd3d938218eddb9399408320a7e6a694d9e9e4a", "filename": "libgo/go/archive/zip/zip_test.go", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"bytes\"\n \t\"fmt\"\n \t\"io\"\n+\t\"reflect\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -66,3 +67,22 @@ func TestModTime(t *testing.T) {\n \t\tt.Errorf(\"times don't match: got %s, want %s\", outTime, testTime)\n \t}\n }\n+\n+func TestFileHeaderRoundTrip(t *testing.T) {\n+\tfh := &FileHeader{\n+\t\tName:             \"foo.txt\",\n+\t\tUncompressedSize: 987654321,\n+\t\tModifiedTime:     1234,\n+\t\tModifiedDate:     5678,\n+\t}\n+\tfi := fh.FileInfo()\n+\tfh2, err := FileInfoHeader(fi)\n+\n+\t// Ignore these fields:\n+\tfh2.CreatorVersion = 0\n+\tfh2.ExternalAttrs = 0\n+\n+\tif !reflect.DeepEqual(fh, fh2) {\n+\t\tt.Errorf(\"mismatch\\n input=%#v\\noutput=%#v\\nerr=%v\", fh, fh2, err)\n+\t}\n+}"}, {"sha": "2c3eb6a596bb8e57dc95d5bb15497a6882d66dce", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -33,6 +33,9 @@ const (\n \topRead                   // Any other read operation.\n )\n \n+// ErrTooLarge is passed to panic if memory cannot be allocated to store data in a buffer.\n+var ErrTooLarge = errors.New(\"bytes.Buffer: too large\")\n+\n // Bytes returns a slice of the contents of the unread portion of the buffer;\n // len(b.Bytes()) == b.Len().  If the caller changes the contents of the\n // returned slice, the contents of the buffer will change provided there\n@@ -68,8 +71,9 @@ func (b *Buffer) Truncate(n int) {\n // b.Reset() is the same as b.Truncate(0).\n func (b *Buffer) Reset() { b.Truncate(0) }\n \n-// Grow buffer to guarantee space for n more bytes.\n-// Return index where bytes should be written.\n+// grow grows the buffer to guarantee space for n more bytes.\n+// It returns the index where bytes should be written.\n+// If the buffer can't grow it will panic with ErrTooLarge.\n func (b *Buffer) grow(n int) int {\n \tm := b.Len()\n \t// If buffer is empty, reset to recover space.\n@@ -82,7 +86,7 @@ func (b *Buffer) grow(n int) int {\n \t\t\tbuf = b.bootstrap[0:]\n \t\t} else {\n \t\t\t// not enough space anywhere\n-\t\t\tbuf = make([]byte, 2*cap(b.buf)+n)\n+\t\t\tbuf = makeSlice(2*cap(b.buf) + n)\n \t\t\tcopy(buf, b.buf[b.off:])\n \t\t}\n \t\tb.buf = buf\n@@ -94,6 +98,8 @@ func (b *Buffer) grow(n int) int {\n \n // Write appends the contents of p to the buffer.  The return\n // value n is the length of p; err is always nil.\n+// If the buffer becomes too large, Write will panic with\n+// ErrTooLarge.\n func (b *Buffer) Write(p []byte) (n int, err error) {\n \tb.lastRead = opInvalid\n \tm := b.grow(len(p))\n@@ -102,6 +108,8 @@ func (b *Buffer) Write(p []byte) (n int, err error) {\n \n // WriteString appends the contents of s to the buffer.  The return\n // value n is the length of s; err is always nil.\n+// If the buffer becomes too large, WriteString will panic with\n+// ErrTooLarge.\n func (b *Buffer) WriteString(s string) (n int, err error) {\n \tb.lastRead = opInvalid\n \tm := b.grow(len(s))\n@@ -118,25 +126,25 @@ const MinRead = 512\n // The return value n is the number of bytes read.\n // Any error except io.EOF encountered during the read\n // is also returned.\n+// If the buffer becomes too large, ReadFrom will panic with\n+// ErrTooLarge.\n func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error) {\n \tb.lastRead = opInvalid\n \t// If buffer is empty, reset to recover space.\n \tif b.off >= len(b.buf) {\n \t\tb.Truncate(0)\n \t}\n \tfor {\n-\t\tif cap(b.buf)-len(b.buf) < MinRead {\n-\t\t\tvar newBuf []byte\n-\t\t\t// can we get space without allocation?\n-\t\t\tif b.off+cap(b.buf)-len(b.buf) >= MinRead {\n-\t\t\t\t// reuse beginning of buffer\n-\t\t\t\tnewBuf = b.buf[0 : len(b.buf)-b.off]\n-\t\t\t} else {\n-\t\t\t\t// not enough space at end; put space on end\n-\t\t\t\tnewBuf = make([]byte, len(b.buf)-b.off, 2*(cap(b.buf)-b.off)+MinRead)\n+\t\tif free := cap(b.buf) - len(b.buf); free < MinRead {\n+\t\t\t// not enough space at end\n+\t\t\tnewBuf := b.buf\n+\t\t\tif b.off+free < MinRead {\n+\t\t\t\t// not enough space using beginning of buffer;\n+\t\t\t\t// double buffer capacity\n+\t\t\t\tnewBuf = makeSlice(2*cap(b.buf) + MinRead)\n \t\t\t}\n \t\t\tcopy(newBuf, b.buf[b.off:])\n-\t\t\tb.buf = newBuf\n+\t\t\tb.buf = newBuf[:len(b.buf)-b.off]\n \t\t\tb.off = 0\n \t\t}\n \t\tm, e := r.Read(b.buf[len(b.buf):cap(b.buf)])\n@@ -152,6 +160,18 @@ func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error) {\n \treturn n, nil // err is EOF, so return nil explicitly\n }\n \n+// makeSlice allocates a slice of size n. If the allocation fails, it panics\n+// with ErrTooLarge.\n+func makeSlice(n int) []byte {\n+\t// If the make fails, give a known error.\n+\tdefer func() {\n+\t\tif recover() != nil {\n+\t\t\tpanic(ErrTooLarge)\n+\t\t}\n+\t}()\n+\treturn make([]byte, n)\n+}\n+\n // WriteTo writes data to w until the buffer is drained or an error\n // occurs. The return value n is the number of bytes written; it always\n // fits into an int, but it is int64 to match the io.WriterTo interface.\n@@ -176,6 +196,8 @@ func (b *Buffer) WriteTo(w io.Writer) (n int64, err error) {\n // WriteByte appends the byte c to the buffer.\n // The returned error is always nil, but is included\n // to match bufio.Writer's WriteByte.\n+// If the buffer becomes too large, WriteByte will panic with\n+// ErrTooLarge.\n func (b *Buffer) WriteByte(c byte) error {\n \tb.lastRead = opInvalid\n \tm := b.grow(1)\n@@ -187,6 +209,8 @@ func (b *Buffer) WriteByte(c byte) error {\n // code point r to the buffer, returning its length and\n // an error, which is always nil but is included\n // to match bufio.Writer's WriteRune.\n+// If the buffer becomes too large, WriteRune will panic with\n+// ErrTooLarge.\n func (b *Buffer) WriteRune(r rune) (n int, err error) {\n \tif r < utf8.RuneSelf {\n \t\tb.WriteByte(byte(r))"}, {"sha": "1e725890b731e555fbdfd8dce9733b16a771bc7e", "filename": "libgo/go/compress/flate/deflate.go", "status": "modified", "additions": 45, "deletions": 60, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -27,10 +27,12 @@ const (\n \t// stop things from getting too large.\n \tmaxFlateBlockTokens = 1 << 14\n \tmaxStoreBlockSize   = 65535\n-\thashBits            = 15\n+\thashBits            = 17\n \thashSize            = 1 << hashBits\n \thashMask            = (1 << hashBits) - 1\n \thashShift           = (hashBits + minMatchLength - 1) / minMatchLength\n+\n+\tskipNever = math.MaxInt32\n )\n \n type compressionLevel struct {\n@@ -45,12 +47,12 @@ var levels = []compressionLevel{\n \t{3, 0, 32, 32, 6},\n \t// Levels 4-9 use increasingly more lazy matching\n \t// and increasingly stringent conditions for \"good enough\".\n-\t{4, 4, 16, 16, math.MaxInt32},\n-\t{8, 16, 32, 32, math.MaxInt32},\n-\t{8, 16, 128, 128, math.MaxInt32},\n-\t{8, 32, 128, 256, math.MaxInt32},\n-\t{32, 128, 258, 1024, math.MaxInt32},\n-\t{32, 258, 258, 4096, math.MaxInt32},\n+\t{4, 4, 16, 16, skipNever},\n+\t{8, 16, 32, 32, skipNever},\n+\t{8, 16, 128, 128, skipNever},\n+\t{8, 32, 128, 256, skipNever},\n+\t{32, 128, 258, 1024, skipNever},\n+\t{32, 258, 258, 4096, skipNever},\n }\n \n type compressor struct {\n@@ -68,9 +70,10 @@ type compressor struct {\n \t// If hashHead[hashValue] is within the current window, then\n \t// hashPrev[hashHead[hashValue] & windowMask] contains the previous index\n \t// with the same hash value.\n-\tchainHead int\n-\thashHead  []int\n-\thashPrev  []int\n+\tchainHead  int\n+\thashHead   []int\n+\thashPrev   []int\n+\thashOffset int\n \n \t// input window: unprocessed data is window[index:windowEnd]\n \tindex         int\n@@ -79,9 +82,8 @@ type compressor struct {\n \tblockStart    int  // window index where current tokens start\n \tbyteAvailable bool // if true, still need to process window[index-1].\n \n-\t// queued output tokens: tokens[:ti]\n+\t// queued output tokens\n \ttokens []token\n-\tti     int\n \n \t// deflate state\n \tlength         int\n@@ -100,22 +102,9 @@ func (d *compressor) fillDeflate(b []byte) int {\n \t\tif d.blockStart >= windowSize {\n \t\t\td.blockStart -= windowSize\n \t\t} else {\n-\t\t\td.blockStart = math.MaxInt32\n-\t\t}\n-\t\tfor i, h := range d.hashHead {\n-\t\t\tv := h - windowSize\n-\t\t\tif v < -1 {\n-\t\t\t\tv = -1\n-\t\t\t}\n-\t\t\td.hashHead[i] = v\n-\t\t}\n-\t\tfor i, h := range d.hashPrev {\n-\t\t\tv := -h - windowSize\n-\t\t\tif v < -1 {\n-\t\t\t\tv = -1\n-\t\t\t}\n-\t\t\td.hashPrev[i] = v\n+\t\t\td.blockStart = skipNever\n \t\t}\n+\t\td.hashOffset += windowSize\n \t}\n \tn := copy(d.window[d.windowEnd:], b)\n \td.windowEnd += n\n@@ -186,7 +175,7 @@ func (d *compressor) findMatch(pos int, prevHead int, prevLength int, lookahead\n \t\t\t// hashPrev[i & windowMask] has already been overwritten, so stop now.\n \t\t\tbreak\n \t\t}\n-\t\tif i = d.hashPrev[i&windowMask]; i < minIndex || i < 0 {\n+\t\tif i = d.hashPrev[i&windowMask] - d.hashOffset; i < minIndex || i < 0 {\n \t\t\tbreak\n \t\t}\n \t}\n@@ -205,13 +194,12 @@ func (d *compressor) initDeflate() {\n \td.hashHead = make([]int, hashSize)\n \td.hashPrev = make([]int, windowSize)\n \td.window = make([]byte, 2*windowSize)\n-\tfillInts(d.hashHead, -1)\n-\td.tokens = make([]token, maxFlateBlockTokens, maxFlateBlockTokens+1)\n+\td.hashOffset = 1\n+\td.tokens = make([]token, 0, maxFlateBlockTokens+1)\n \td.length = minMatchLength - 1\n \td.offset = 0\n \td.byteAvailable = false\n \td.index = 0\n-\td.ti = 0\n \td.hash = 0\n \td.chainHead = -1\n }\n@@ -243,15 +231,14 @@ Loop:\n \t\t\t\t// Flush current output block if any.\n \t\t\t\tif d.byteAvailable {\n \t\t\t\t\t// There is still one pending token that needs to be flushed\n-\t\t\t\t\td.tokens[d.ti] = literalToken(uint32(d.window[d.index-1]))\n-\t\t\t\t\td.ti++\n+\t\t\t\t\td.tokens = append(d.tokens, literalToken(uint32(d.window[d.index-1])))\n \t\t\t\t\td.byteAvailable = false\n \t\t\t\t}\n-\t\t\t\tif d.ti > 0 {\n-\t\t\t\t\tif d.err = d.writeBlock(d.tokens[0:d.ti], d.index, false); d.err != nil {\n+\t\t\t\tif len(d.tokens) > 0 {\n+\t\t\t\t\tif d.err = d.writeBlock(d.tokens, d.index, false); d.err != nil {\n \t\t\t\t\t\treturn\n \t\t\t\t\t}\n-\t\t\t\t\td.ti = 0\n+\t\t\t\t\td.tokens = d.tokens[:0]\n \t\t\t\t}\n \t\t\t\tbreak Loop\n \t\t\t}\n@@ -261,7 +248,7 @@ Loop:\n \t\t\td.hash = (d.hash<<hashShift + int(d.window[d.index+2])) & hashMask\n \t\t\td.chainHead = d.hashHead[d.hash]\n \t\t\td.hashPrev[d.index&windowMask] = d.chainHead\n-\t\t\td.hashHead[d.hash] = d.index\n+\t\t\td.hashHead[d.hash] = d.index + d.hashOffset\n \t\t}\n \t\tprevLength := d.length\n \t\tprevOffset := d.offset\n@@ -272,34 +259,33 @@ Loop:\n \t\t\tminIndex = 0\n \t\t}\n \n-\t\tif d.chainHead >= minIndex &&\n-\t\t\t(d.fastSkipHashing != 0 && lookahead > minMatchLength-1 ||\n-\t\t\t\td.fastSkipHashing == 0 && lookahead > prevLength && prevLength < d.lazy) {\n-\t\t\tif newLength, newOffset, ok := d.findMatch(d.index, d.chainHead, minMatchLength-1, lookahead); ok {\n+\t\tif d.chainHead-d.hashOffset >= minIndex &&\n+\t\t\t(d.fastSkipHashing != skipNever && lookahead > minMatchLength-1 ||\n+\t\t\t\td.fastSkipHashing == skipNever && lookahead > prevLength && prevLength < d.lazy) {\n+\t\t\tif newLength, newOffset, ok := d.findMatch(d.index, d.chainHead-d.hashOffset, minMatchLength-1, lookahead); ok {\n \t\t\t\td.length = newLength\n \t\t\t\td.offset = newOffset\n \t\t\t}\n \t\t}\n-\t\tif d.fastSkipHashing != 0 && d.length >= minMatchLength ||\n-\t\t\td.fastSkipHashing == 0 && prevLength >= minMatchLength && d.length <= prevLength {\n+\t\tif d.fastSkipHashing != skipNever && d.length >= minMatchLength ||\n+\t\t\td.fastSkipHashing == skipNever && prevLength >= minMatchLength && d.length <= prevLength {\n \t\t\t// There was a match at the previous step, and the current match is\n \t\t\t// not better. Output the previous match.\n-\t\t\tif d.fastSkipHashing != 0 {\n-\t\t\t\td.tokens[d.ti] = matchToken(uint32(d.length-minMatchLength), uint32(d.offset-minOffsetSize))\n+\t\t\tif d.fastSkipHashing != skipNever {\n+\t\t\t\td.tokens = append(d.tokens, matchToken(uint32(d.length-minMatchLength), uint32(d.offset-minOffsetSize)))\n \t\t\t} else {\n-\t\t\t\td.tokens[d.ti] = matchToken(uint32(prevLength-minMatchLength), uint32(prevOffset-minOffsetSize))\n+\t\t\t\td.tokens = append(d.tokens, matchToken(uint32(prevLength-minMatchLength), uint32(prevOffset-minOffsetSize)))\n \t\t\t}\n-\t\t\td.ti++\n \t\t\t// Insert in the hash table all strings up to the end of the match.\n \t\t\t// index and index-1 are already inserted. If there is not enough\n \t\t\t// lookahead, the last two strings are not inserted into the hash\n \t\t\t// table.\n \t\t\tif d.length <= d.fastSkipHashing {\n \t\t\t\tvar newIndex int\n-\t\t\t\tif d.fastSkipHashing != 0 {\n+\t\t\t\tif d.fastSkipHashing != skipNever {\n \t\t\t\t\tnewIndex = d.index + d.length\n \t\t\t\t} else {\n-\t\t\t\t\tnewIndex = prevLength - 1\n+\t\t\t\t\tnewIndex = d.index + prevLength - 1\n \t\t\t\t}\n \t\t\t\tfor d.index++; d.index < newIndex; d.index++ {\n \t\t\t\t\tif d.index < d.maxInsertIndex {\n@@ -308,10 +294,10 @@ Loop:\n \t\t\t\t\t\t// Our chain should point to the previous value.\n \t\t\t\t\t\td.hashPrev[d.index&windowMask] = d.hashHead[d.hash]\n \t\t\t\t\t\t// Set the head of the hash chain to us.\n-\t\t\t\t\t\td.hashHead[d.hash] = d.index\n+\t\t\t\t\t\td.hashHead[d.hash] = d.index + d.hashOffset\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tif d.fastSkipHashing == 0 {\n+\t\t\t\tif d.fastSkipHashing == skipNever {\n \t\t\t\t\td.byteAvailable = false\n \t\t\t\t\td.length = minMatchLength - 1\n \t\t\t\t}\n@@ -323,30 +309,29 @@ Loop:\n \t\t\t\t\td.hash = (int(d.window[d.index])<<hashShift + int(d.window[d.index+1]))\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif d.ti == maxFlateBlockTokens {\n+\t\t\tif len(d.tokens) == maxFlateBlockTokens {\n \t\t\t\t// The block includes the current character\n \t\t\t\tif d.err = d.writeBlock(d.tokens, d.index, false); d.err != nil {\n \t\t\t\t\treturn\n \t\t\t\t}\n-\t\t\t\td.ti = 0\n+\t\t\t\td.tokens = d.tokens[:0]\n \t\t\t}\n \t\t} else {\n-\t\t\tif d.fastSkipHashing != 0 || d.byteAvailable {\n+\t\t\tif d.fastSkipHashing != skipNever || d.byteAvailable {\n \t\t\t\ti := d.index - 1\n-\t\t\t\tif d.fastSkipHashing != 0 {\n+\t\t\t\tif d.fastSkipHashing != skipNever {\n \t\t\t\t\ti = d.index\n \t\t\t\t}\n-\t\t\t\td.tokens[d.ti] = literalToken(uint32(d.window[i]))\n-\t\t\t\td.ti++\n-\t\t\t\tif d.ti == maxFlateBlockTokens {\n+\t\t\t\td.tokens = append(d.tokens, literalToken(uint32(d.window[i])))\n+\t\t\t\tif len(d.tokens) == maxFlateBlockTokens {\n \t\t\t\t\tif d.err = d.writeBlock(d.tokens, i+1, false); d.err != nil {\n \t\t\t\t\t\treturn\n \t\t\t\t\t}\n-\t\t\t\t\td.ti = 0\n+\t\t\t\t\td.tokens = d.tokens[:0]\n \t\t\t\t}\n \t\t\t}\n \t\t\td.index++\n-\t\t\tif d.fastSkipHashing == 0 {\n+\t\t\tif d.fastSkipHashing == skipNever {\n \t\t\t\td.byteAvailable = true\n \t\t\t}\n \t\t}"}, {"sha": "24881d31c069ff7e5f9fd72c6ffee29e21f4597f", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -225,10 +225,17 @@ func testSync(t *testing.T, level int, input []byte, name string) {\n }\n \n func testToFromWithLevel(t *testing.T, level int, input []byte, name string) error {\n+\treturn testToFromWithLevelAndLimit(t, level, input, name, -1)\n+}\n+\n+func testToFromWithLevelAndLimit(t *testing.T, level int, input []byte, name string, limit int) error {\n \tbuffer := bytes.NewBuffer(nil)\n \tw := NewWriter(buffer, level)\n \tw.Write(input)\n \tw.Close()\n+\tif limit > 0 && buffer.Len() > limit {\n+\t\tt.Errorf(\"level: %d, len(compress(data)) = %d > limit = %d\", level, buffer.Len(), limit)\n+\t}\n \tr := NewReader(buffer)\n \tout, err := ioutil.ReadAll(r)\n \tif err != nil {\n@@ -244,12 +251,16 @@ func testToFromWithLevel(t *testing.T, level int, input []byte, name string) err\n \treturn nil\n }\n \n-func testToFrom(t *testing.T, input []byte, name string) {\n+func testToFromWithLimit(t *testing.T, input []byte, name string, limit [10]int) {\n \tfor i := 0; i < 10; i++ {\n-\t\ttestToFromWithLevel(t, i, input, name)\n+\t\ttestToFromWithLevelAndLimit(t, i, input, name, limit[i])\n \t}\n }\n \n+func testToFrom(t *testing.T, input []byte, name string) {\n+\ttestToFromWithLimit(t, input, name, [10]int{})\n+}\n+\n func TestDeflateInflate(t *testing.T) {\n \tfor i, h := range deflateInflateTests {\n \t\ttestToFrom(t, h.in, fmt.Sprintf(\"#%d\", i))\n@@ -265,12 +276,33 @@ func TestReverseBits(t *testing.T) {\n \t}\n }\n \n+type deflateInflateStringTest struct {\n+\tfilename string\n+\tlabel    string\n+\tlimit    [10]int\n+}\n+\n+var deflateInflateStringTests = []deflateInflateStringTest{\n+\t{\n+\t\t\"../testdata/e.txt\",\n+\t\t\"2.718281828...\",\n+\t\t[...]int{10013, 5065, 5096, 5115, 5093, 5079, 5079, 5079, 5079, 5079},\n+\t},\n+\t{\n+\t\t\"../testdata/Mark.Twain-Tom.Sawyer.txt\",\n+\t\t\"Mark.Twain-Tom.Sawyer\",\n+\t\t[...]int{407330, 187598, 180361, 172974, 169160, 163476, 160936, 160506, 160295, 160295},\n+\t},\n+}\n+\n func TestDeflateInflateString(t *testing.T) {\n-\tgold, err := ioutil.ReadFile(\"../testdata/e.txt\")\n-\tif err != nil {\n-\t\tt.Error(err)\n+\tfor _, test := range deflateInflateStringTests {\n+\t\tgold, err := ioutil.ReadFile(test.filename)\n+\t\tif err != nil {\n+\t\t\tt.Error(err)\n+\t\t}\n+\t\ttestToFromWithLimit(t, gold, test.label, test.limit)\n \t}\n-\ttestToFromWithLevel(t, 1, gold, \"2.718281828...\")\n }\n \n func TestReaderDict(t *testing.T) {"}, {"sha": "57b56b5c96d5ff6fbb2b61fbb18ef29f12c521c2", "filename": "libgo/go/compress/flate/huffman_bit_writer.go", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -193,15 +193,17 @@ func (w *huffmanBitWriter) writeBytes(bytes []byte) {\n //  numLiterals      The number of literals in literalEncoding\n //  numOffsets       The number of offsets in offsetEncoding\n func (w *huffmanBitWriter) generateCodegen(numLiterals int, numOffsets int) {\n-\tfillInt32s(w.codegenFreq, 0)\n+\tfor i := range w.codegenFreq {\n+\t\tw.codegenFreq[i] = 0\n+\t}\n \t// Note that we are using codegen both as a temporary variable for holding\n \t// a copy of the frequencies, and as the place where we put the result.\n \t// This is fine because the output is always shorter than the input used\n \t// so far.\n \tcodegen := w.codegen // cache\n \t// Copy the concatenated code sizes to codegen.  Put a marker at the end.\n-\tcopyUint8s(codegen[0:numLiterals], w.literalEncoding.codeBits)\n-\tcopyUint8s(codegen[numLiterals:numLiterals+numOffsets], w.offsetEncoding.codeBits)\n+\tcopy(codegen[0:numLiterals], w.literalEncoding.codeBits)\n+\tcopy(codegen[numLiterals:numLiterals+numOffsets], w.offsetEncoding.codeBits)\n \tcodegen[numLiterals+numOffsets] = badCode\n \n \tsize := codegen[0]\n@@ -222,7 +224,10 @@ func (w *huffmanBitWriter) generateCodegen(numLiterals int, numOffsets int) {\n \t\t\tw.codegenFreq[size]++\n \t\t\tcount--\n \t\t\tfor count >= 3 {\n-\t\t\t\tn := min(count, 6)\n+\t\t\t\tn := 6\n+\t\t\t\tif n > count {\n+\t\t\t\t\tn = count\n+\t\t\t\t}\n \t\t\t\tcodegen[outIndex] = 16\n \t\t\t\toutIndex++\n \t\t\t\tcodegen[outIndex] = uint8(n - 3)\n@@ -232,7 +237,10 @@ func (w *huffmanBitWriter) generateCodegen(numLiterals int, numOffsets int) {\n \t\t\t}\n \t\t} else {\n \t\t\tfor count >= 11 {\n-\t\t\t\tn := min(count, 138)\n+\t\t\t\tn := 138\n+\t\t\t\tif n > count {\n+\t\t\t\t\tn = count\n+\t\t\t\t}\n \t\t\t\tcodegen[outIndex] = 18\n \t\t\t\toutIndex++\n \t\t\t\tcodegen[outIndex] = uint8(n - 11)\n@@ -351,8 +359,12 @@ func (w *huffmanBitWriter) writeBlock(tokens []token, eof bool, input []byte) {\n \tif w.err != nil {\n \t\treturn\n \t}\n-\tfillInt32s(w.literalFreq, 0)\n-\tfillInt32s(w.offsetFreq, 0)\n+\tfor i := range w.literalFreq {\n+\t\tw.literalFreq[i] = 0\n+\t}\n+\tfor i := range w.offsetFreq {\n+\t\tw.offsetFreq[i] = 0\n+\t}\n \n \tn := len(tokens)\n \ttokens = tokens[0 : n+1]"}, {"sha": "4873b0fce36ed8be4f3a30c6f26c8d25d2c27125", "filename": "libgo/go/compress/flate/huffman_code.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_code.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_code.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_code.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -195,7 +195,9 @@ func (h *huffmanEncoder) bitCounts(list []literalNode, maxBits int32) []int32 {\n \n \t// The tree can't have greater depth than n - 1, no matter what.  This\n \t// saves a little bit of work in some small cases\n-\tmaxBits = minInt32(maxBits, n-1)\n+\tif maxBits > n-1 {\n+\t\tmaxBits = n - 1\n+\t}\n \n \t// Create information about each of the levels.\n \t// A bogus \"Level 0\" whose sole purpose is so that"}, {"sha": "aca5c78b2d41ac7e1494d785eee8b97764deaee7", "filename": "libgo/go/compress/flate/util.go", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcompress%2Fflate%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcompress%2Fflate%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Futil.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,72 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package flate\n-\n-func min(left int, right int) int {\n-\tif left < right {\n-\t\treturn left\n-\t}\n-\treturn right\n-}\n-\n-func minInt32(left int32, right int32) int32 {\n-\tif left < right {\n-\t\treturn left\n-\t}\n-\treturn right\n-}\n-\n-func max(left int, right int) int {\n-\tif left > right {\n-\t\treturn left\n-\t}\n-\treturn right\n-}\n-\n-func fillInts(a []int, value int) {\n-\tfor i := range a {\n-\t\ta[i] = value\n-\t}\n-}\n-\n-func fillInt32s(a []int32, value int32) {\n-\tfor i := range a {\n-\t\ta[i] = value\n-\t}\n-}\n-\n-func fillBytes(a []byte, value byte) {\n-\tfor i := range a {\n-\t\ta[i] = value\n-\t}\n-}\n-\n-func fillInt8s(a []int8, value int8) {\n-\tfor i := range a {\n-\t\ta[i] = value\n-\t}\n-}\n-\n-func fillUint8s(a []uint8, value uint8) {\n-\tfor i := range a {\n-\t\ta[i] = value\n-\t}\n-}\n-\n-func copyInt8s(dst []int8, src []int8) int {\n-\tcnt := min(len(dst), len(src))\n-\tfor i := 0; i < cnt; i++ {\n-\t\tdst[i] = src[i]\n-\t}\n-\treturn cnt\n-}\n-\n-func copyUint8s(dst []uint8, src []uint8) int {\n-\tcnt := min(len(dst), len(src))\n-\tfor i := 0; i < cnt; i++ {\n-\t\tdst[i] = src[i]\n-\t}\n-\treturn cnt\n-}"}, {"sha": "d3743105d187abb6e2bcd39387ba9278aa359b9f", "filename": "libgo/go/compress/gzip/gunzip.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -37,8 +37,8 @@ func makeReader(r io.Reader) flate.Reader {\n \treturn bufio.NewReader(r)\n }\n \n-var HeaderError = errors.New(\"invalid gzip header\")\n-var ChecksumError = errors.New(\"gzip checksum error\")\n+var ErrHeader = errors.New(\"invalid gzip header\")\n+var ErrChecksum = errors.New(\"gzip checksum error\")\n \n // The gzip file stores a header giving metadata about the compressed file.\n // That header is exposed as the fields of the Compressor and Decompressor structs.\n@@ -59,7 +59,7 @@ type Header struct {\n // Only the first header is recorded in the Decompressor fields.\n //\n // Gzip files store a length and checksum of the uncompressed data.\n-// The Decompressor will return a ChecksumError when Read\n+// The Decompressor will return a ErrChecksum when Read\n // reaches the end of the uncompressed data if it does not\n // have the expected length or checksum.  Clients should treat data\n // returned by Read as tentative until they receive the successful\n@@ -99,7 +99,7 @@ func (z *Decompressor) readString() (string, error) {\n \tneedconv := false\n \tfor i := 0; ; i++ {\n \t\tif i >= len(z.buf) {\n-\t\t\treturn \"\", HeaderError\n+\t\t\treturn \"\", ErrHeader\n \t\t}\n \t\tz.buf[i], err = z.r.ReadByte()\n \t\tif err != nil {\n@@ -137,7 +137,7 @@ func (z *Decompressor) readHeader(save bool) error {\n \t\treturn err\n \t}\n \tif z.buf[0] != gzipID1 || z.buf[1] != gzipID2 || z.buf[2] != gzipDeflate {\n-\t\treturn HeaderError\n+\t\treturn ErrHeader\n \t}\n \tz.flg = z.buf[3]\n \tif save {\n@@ -188,7 +188,7 @@ func (z *Decompressor) readHeader(save bool) error {\n \t\t}\n \t\tsum := z.digest.Sum32() & 0xFFFF\n \t\tif n != sum {\n-\t\t\treturn HeaderError\n+\t\t\treturn ErrHeader\n \t\t}\n \t}\n \n@@ -221,7 +221,7 @@ func (z *Decompressor) Read(p []byte) (n int, err error) {\n \tcrc32, isize := get4(z.buf[0:4]), get4(z.buf[4:8])\n \tsum := z.digest.Sum32()\n \tif sum != crc32 || isize != z.size {\n-\t\tz.err = ChecksumError\n+\t\tz.err = ErrChecksum\n \t\treturn 0, z.err\n \t}\n "}, {"sha": "a1333580dc006c62fb6589e608b2a97e28fcfa75", "filename": "libgo/go/compress/gzip/gunzip_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -232,7 +232,7 @@ var gunzipTests = []gunzipTest{\n \t\t\t0x02, 0x00, 0x2d, 0x3b, 0x08, 0xaf, 0x0c, 0x00,\n \t\t\t0x00, 0x00, 'g', 'a', 'r', 'b', 'a', 'g', 'e', '!', '!', '!',\n \t\t},\n-\t\tHeaderError,\n+\t\tErrHeader,\n \t},\n \t{ // has 1 non-empty fixed huffman block not enough header\n \t\t\"hello.txt\",\n@@ -260,7 +260,7 @@ var gunzipTests = []gunzipTest{\n \t\t\t0x02, 0x00, 0xff, 0xff, 0xff, 0xff, 0x0c, 0x00,\n \t\t\t0x00, 0x00,\n \t\t},\n-\t\tChecksumError,\n+\t\tErrChecksum,\n \t},\n \t{ // has 1 non-empty fixed huffman block but corrupt size\n \t\t\"hello.txt\",\n@@ -274,7 +274,7 @@ var gunzipTests = []gunzipTest{\n \t\t\t0x02, 0x00, 0x2d, 0x3b, 0x08, 0xaf, 0xff, 0x00,\n \t\t\t0x00, 0x00,\n \t\t},\n-\t\tChecksumError,\n+\t\tErrChecksum,\n \t},\n }\n "}, {"sha": "8d0ff4e65ce7ef1c2a84cce0e1014ad5e18934a7", "filename": "libgo/go/compress/testdata/Mark.Twain-Tom.Sawyer.txt", "status": "added", "additions": 8858, "deletions": 0, "changes": 8858, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcompress%2Ftestdata%2FMark.Twain-Tom.Sawyer.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcompress%2Ftestdata%2FMark.Twain-Tom.Sawyer.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Ftestdata%2FMark.Twain-Tom.Sawyer.txt?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "4638a6548425bb44bb86db2f5682a54472a42bdb", "filename": "libgo/go/compress/zlib/reader.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -34,9 +34,9 @@ import (\n \n const zlibDeflate = 8\n \n-var ChecksumError = errors.New(\"zlib checksum error\")\n-var HeaderError = errors.New(\"invalid zlib header\")\n-var DictionaryError = errors.New(\"invalid zlib dictionary\")\n+var ErrChecksum = errors.New(\"zlib checksum error\")\n+var ErrHeader = errors.New(\"invalid zlib header\")\n+var ErrDictionary = errors.New(\"invalid zlib dictionary\")\n \n type reader struct {\n \tr            flate.Reader\n@@ -68,7 +68,7 @@ func NewReaderDict(r io.Reader, dict []byte) (io.ReadCloser, error) {\n \t}\n \th := uint(z.scratch[0])<<8 | uint(z.scratch[1])\n \tif (z.scratch[0]&0x0f != zlibDeflate) || (h%31 != 0) {\n-\t\treturn nil, HeaderError\n+\t\treturn nil, ErrHeader\n \t}\n \tif z.scratch[1]&0x20 != 0 {\n \t\t_, err = io.ReadFull(z.r, z.scratch[0:4])\n@@ -77,7 +77,7 @@ func NewReaderDict(r io.Reader, dict []byte) (io.ReadCloser, error) {\n \t\t}\n \t\tchecksum := uint32(z.scratch[0])<<24 | uint32(z.scratch[1])<<16 | uint32(z.scratch[2])<<8 | uint32(z.scratch[3])\n \t\tif checksum != adler32.Checksum(dict) {\n-\t\t\treturn nil, DictionaryError\n+\t\t\treturn nil, ErrDictionary\n \t\t}\n \t\tz.decompressor = flate.NewReaderDict(z.r, dict)\n \t} else {\n@@ -110,7 +110,7 @@ func (z *reader) Read(p []byte) (n int, err error) {\n \t// ZLIB (RFC 1950) is big-endian, unlike GZIP (RFC 1952).\n \tchecksum := uint32(z.scratch[0])<<24 | uint32(z.scratch[1])<<16 | uint32(z.scratch[2])<<8 | uint32(z.scratch[3])\n \tif checksum != z.digest.Sum32() {\n-\t\tz.err = ChecksumError\n+\t\tz.err = ErrChecksum\n \t\treturn 0, z.err\n \t}\n \treturn"}, {"sha": "3b02a086845806222e48910920b50c855092a02e", "filename": "libgo/go/compress/zlib/reader_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcompress%2Fzlib%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcompress%2Fzlib%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Freader_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -45,14 +45,14 @@ var zlibTests = []zlibTest{\n \t\t\"\",\n \t\t[]byte{0x78, 0x9f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01},\n \t\tnil,\n-\t\tHeaderError,\n+\t\tErrHeader,\n \t},\n \t{\n \t\t\"bad checksum\",\n \t\t\"\",\n \t\t[]byte{0x78, 0x9c, 0x03, 0x00, 0x00, 0x00, 0x00, 0xff},\n \t\tnil,\n-\t\tChecksumError,\n+\t\tErrChecksum,\n \t},\n \t{\n \t\t\"not enough data\",\n@@ -95,7 +95,7 @@ var zlibTests = []zlibTest{\n \t\t[]byte{\n \t\t\t0x48, 0x65, 0x6c, 0x6c,\n \t\t},\n-\t\tDictionaryError,\n+\t\tErrDictionary,\n \t},\n }\n "}, {"sha": "fc311609081849d379013a25310456fbb1a6e66a", "filename": "libgo/go/crypto/bcrypt/base64.go", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbase64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbase64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbase64.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,35 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package bcrypt\n-\n-import \"encoding/base64\"\n-\n-const alphabet = \"./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n-\n-var bcEncoding = base64.NewEncoding(alphabet)\n-\n-func base64Encode(src []byte) []byte {\n-\tn := bcEncoding.EncodedLen(len(src))\n-\tdst := make([]byte, n)\n-\tbcEncoding.Encode(dst, src)\n-\tfor dst[n-1] == '=' {\n-\t\tn--\n-\t}\n-\treturn dst[:n]\n-}\n-\n-func base64Decode(src []byte) ([]byte, error) {\n-\tnumOfEquals := 4 - (len(src) % 4)\n-\tfor i := 0; i < numOfEquals; i++ {\n-\t\tsrc = append(src, '=')\n-\t}\n-\n-\tdst := make([]byte, bcEncoding.DecodedLen(len(src)))\n-\tn, err := bcEncoding.Decode(dst, src)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn dst[:n], nil\n-}"}, {"sha": "362b2eb53cb23a1cee45e671a0e744549cb25d75", "filename": "libgo/go/crypto/bcrypt/bcrypt.go", "status": "removed", "additions": 0, "deletions": 282, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,282 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package bcrypt implements Provos and Mazi\u00e8res's bcrypt adaptive hashing\n-// algorithm. See http://www.usenix.org/event/usenix99/provos/provos.pdf\n-package bcrypt\n-\n-// The code is a port of Provos and Mazi\u00e8res's C implementation. \n-import (\n-\t\"crypto/blowfish\"\n-\t\"crypto/rand\"\n-\t\"crypto/subtle\"\n-\t\"errors\"\n-\t\"fmt\"\n-\t\"io\"\n-\t\"strconv\"\n-)\n-\n-const (\n-\tMinCost     int = 4  // the minimum allowable cost as passed in to GenerateFromPassword\n-\tMaxCost     int = 31 // the maximum allowable cost as passed in to GenerateFromPassword\n-\tDefaultCost int = 10 // the cost that will actually be set if a cost below MinCost is passed into GenerateFromPassword\n-)\n-\n-// The error returned from CompareHashAndPassword when a password and hash do\n-// not match.\n-var MismatchedHashAndPasswordError = errors.New(\"crypto/bcrypt: hashedPassword is not the hash of the given password\")\n-\n-// The error returned from CompareHashAndPassword when a hash is too short to\n-// be a bcrypt hash.\n-var HashTooShortError = errors.New(\"crypto/bcrypt: hashedSecret too short to be a bcrypted password\")\n-\n-// The error returned from CompareHashAndPassword when a hash was created with\n-// a bcrypt algorithm newer than this implementation.\n-type HashVersionTooNewError byte\n-\n-func (hv HashVersionTooNewError) Error() string {\n-\treturn fmt.Sprintf(\"crypto/bcrypt: bcrypt algorithm version '%c' requested is newer than current version '%c'\", byte(hv), majorVersion)\n-}\n-\n-// The error returned from CompareHashAndPassword when a hash starts with something other than '$'\n-type InvalidHashPrefixError byte\n-\n-func (ih InvalidHashPrefixError) Error() string {\n-\treturn fmt.Sprintf(\"crypto/bcrypt: bcrypt hashes must start with '$', but hashedSecret started with '%c'\", byte(ih))\n-}\n-\n-type InvalidCostError int\n-\n-func (ic InvalidCostError) Error() string {\n-\treturn fmt.Sprintf(\"crypto/bcrypt: cost %d is outside allowed range (%d,%d)\", int(ic), int(MinCost), int(MaxCost))\n-}\n-\n-const (\n-\tmajorVersion       = '2'\n-\tminorVersion       = 'a'\n-\tmaxSaltSize        = 16\n-\tmaxCryptedHashSize = 23\n-\tencodedSaltSize    = 22\n-\tencodedHashSize    = 31\n-\tminHashSize        = 59\n-)\n-\n-// magicCipherData is an IV for the 64 Blowfish encryption calls in\n-// bcrypt(). It's the string \"OrpheanBeholderScryDoubt\" in big-endian bytes.\n-var magicCipherData = []byte{\n-\t0x4f, 0x72, 0x70, 0x68,\n-\t0x65, 0x61, 0x6e, 0x42,\n-\t0x65, 0x68, 0x6f, 0x6c,\n-\t0x64, 0x65, 0x72, 0x53,\n-\t0x63, 0x72, 0x79, 0x44,\n-\t0x6f, 0x75, 0x62, 0x74,\n-}\n-\n-type hashed struct {\n-\thash  []byte\n-\tsalt  []byte\n-\tcost  uint32 // allowed range is MinCost to MaxCost\n-\tmajor byte\n-\tminor byte\n-}\n-\n-// GenerateFromPassword returns the bcrypt hash of the password at the given\n-// cost. If the cost given is less than MinCost, the cost will be set to\n-// MinCost, instead. Use CompareHashAndPassword, as defined in this package,\n-// to compare the returned hashed password with its cleartext version.\n-func GenerateFromPassword(password []byte, cost int) ([]byte, error) {\n-\tp, err := newFromPassword(password, cost)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn p.Hash(), nil\n-}\n-\n-// CompareHashAndPassword compares a bcrypt hashed password with its possible\n-// plaintext equivalent. Note: Using bytes.Equal for this job is\n-// insecure. Returns nil on success, or an error on failure.\n-func CompareHashAndPassword(hashedPassword, password []byte) error {\n-\tp, err := newFromHash(hashedPassword)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\totherHash, err := bcrypt(password, p.cost, p.salt)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\totherP := &hashed{otherHash, p.salt, p.cost, p.major, p.minor}\n-\tif subtle.ConstantTimeCompare(p.Hash(), otherP.Hash()) == 1 {\n-\t\treturn nil\n-\t}\n-\n-\treturn MismatchedHashAndPasswordError\n-}\n-\n-func newFromPassword(password []byte, cost int) (*hashed, error) {\n-\tif cost < MinCost {\n-\t\tcost = DefaultCost\n-\t}\n-\tp := new(hashed)\n-\tp.major = majorVersion\n-\tp.minor = minorVersion\n-\n-\terr := checkCost(cost)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tp.cost = uint32(cost)\n-\n-\tunencodedSalt := make([]byte, maxSaltSize)\n-\t_, err = io.ReadFull(rand.Reader, unencodedSalt)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tp.salt = base64Encode(unencodedSalt)\n-\thash, err := bcrypt(password, p.cost, p.salt)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tp.hash = hash\n-\treturn p, err\n-}\n-\n-func newFromHash(hashedSecret []byte) (*hashed, error) {\n-\tif len(hashedSecret) < minHashSize {\n-\t\treturn nil, HashTooShortError\n-\t}\n-\tp := new(hashed)\n-\tn, err := p.decodeVersion(hashedSecret)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\thashedSecret = hashedSecret[n:]\n-\tn, err = p.decodeCost(hashedSecret)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\thashedSecret = hashedSecret[n:]\n-\n-\t// The \"+2\" is here because we'll have to append at most 2 '=' to the salt\n-\t// when base64 decoding it in expensiveBlowfishSetup().\n-\tp.salt = make([]byte, encodedSaltSize, encodedSaltSize+2)\n-\tcopy(p.salt, hashedSecret[:encodedSaltSize])\n-\n-\thashedSecret = hashedSecret[encodedSaltSize:]\n-\tp.hash = make([]byte, len(hashedSecret))\n-\tcopy(p.hash, hashedSecret)\n-\n-\treturn p, nil\n-}\n-\n-func bcrypt(password []byte, cost uint32, salt []byte) ([]byte, error) {\n-\tcipherData := make([]byte, len(magicCipherData))\n-\tcopy(cipherData, magicCipherData)\n-\n-\tc, err := expensiveBlowfishSetup(password, cost, salt)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tfor i := 0; i < 24; i += 8 {\n-\t\tfor j := 0; j < 64; j++ {\n-\t\t\tc.Encrypt(cipherData[i:i+8], cipherData[i:i+8])\n-\t\t}\n-\t}\n-\n-\t// Bug compatibility with C bcrypt implementations. We only encode 23 of\n-\t// the 24 bytes encrypted.\n-\thsh := base64Encode(cipherData[:maxCryptedHashSize])\n-\treturn hsh, nil\n-}\n-\n-func expensiveBlowfishSetup(key []byte, cost uint32, salt []byte) (*blowfish.Cipher, error) {\n-\n-\tcsalt, err := base64Decode(salt)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\t// Bug compatibility with C bcrypt implementations. They use the trailing\n-\t// NULL in the key string during expansion.\n-\tckey := append(key, 0)\n-\n-\tc, err := blowfish.NewSaltedCipher(ckey, csalt)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\trounds := 1 << cost\n-\tfor i := 0; i < rounds; i++ {\n-\t\tblowfish.ExpandKey(ckey, c)\n-\t\tblowfish.ExpandKey(csalt, c)\n-\t}\n-\n-\treturn c, nil\n-}\n-\n-func (p *hashed) Hash() []byte {\n-\tarr := make([]byte, 60)\n-\tarr[0] = '$'\n-\tarr[1] = p.major\n-\tn := 2\n-\tif p.minor != 0 {\n-\t\tarr[2] = p.minor\n-\t\tn = 3\n-\t}\n-\tarr[n] = '$'\n-\tn += 1\n-\tcopy(arr[n:], []byte(fmt.Sprintf(\"%02d\", p.cost)))\n-\tn += 2\n-\tarr[n] = '$'\n-\tn += 1\n-\tcopy(arr[n:], p.salt)\n-\tn += encodedSaltSize\n-\tcopy(arr[n:], p.hash)\n-\tn += encodedHashSize\n-\treturn arr[:n]\n-}\n-\n-func (p *hashed) decodeVersion(sbytes []byte) (int, error) {\n-\tif sbytes[0] != '$' {\n-\t\treturn -1, InvalidHashPrefixError(sbytes[0])\n-\t}\n-\tif sbytes[1] > majorVersion {\n-\t\treturn -1, HashVersionTooNewError(sbytes[1])\n-\t}\n-\tp.major = sbytes[1]\n-\tn := 3\n-\tif sbytes[2] != '$' {\n-\t\tp.minor = sbytes[2]\n-\t\tn++\n-\t}\n-\treturn n, nil\n-}\n-\n-// sbytes should begin where decodeVersion left off.\n-func (p *hashed) decodeCost(sbytes []byte) (int, error) {\n-\tcost, err := strconv.Atoi(string(sbytes[0:2]))\n-\tif err != nil {\n-\t\treturn -1, err\n-\t}\n-\terr = checkCost(cost)\n-\tif err != nil {\n-\t\treturn -1, err\n-\t}\n-\tp.cost = uint32(cost)\n-\treturn 3, nil\n-}\n-\n-func (p *hashed) String() string {\n-\treturn fmt.Sprintf(\"&{hash: %#v, salt: %#v, cost: %d, major: %c, minor: %c}\", string(p.hash), p.salt, p.cost, p.major, p.minor)\n-}\n-\n-func checkCost(cost int) error {\n-\tif cost < MinCost || cost > MaxCost {\n-\t\treturn InvalidCostError(cost)\n-\t}\n-\treturn nil\n-}"}, {"sha": "a3155c5cc728d933911f1d571e50a8062cc6525e", "filename": "libgo/go/crypto/bcrypt/bcrypt_test.go", "status": "removed", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,194 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package bcrypt\n-\n-import (\n-\t\"bytes\"\n-\t\"testing\"\n-)\n-\n-func TestBcryptingIsEasy(t *testing.T) {\n-\tpass := []byte(\"mypassword\")\n-\thp, err := GenerateFromPassword(pass, 0)\n-\tif err != nil {\n-\t\tt.Fatalf(\"GenerateFromPassword error: %s\", err)\n-\t}\n-\n-\tif CompareHashAndPassword(hp, pass) != nil {\n-\t\tt.Errorf(\"%v should hash %s correctly\", hp, pass)\n-\t}\n-\n-\tnotPass := \"notthepass\"\n-\terr = CompareHashAndPassword(hp, []byte(notPass))\n-\tif err != MismatchedHashAndPasswordError {\n-\t\tt.Errorf(\"%v and %s should be mismatched\", hp, notPass)\n-\t}\n-}\n-\n-func TestBcryptingIsCorrect(t *testing.T) {\n-\tpass := []byte(\"allmine\")\n-\tsalt := []byte(\"XajjQvNhvvRt5GSeFk1xFe\")\n-\texpectedHash := []byte(\"$2a$10$XajjQvNhvvRt5GSeFk1xFeyqRrsxkhBkUiQeg0dt.wU1qD4aFDcga\")\n-\n-\thash, err := bcrypt(pass, 10, salt)\n-\tif err != nil {\n-\t\tt.Fatalf(\"bcrypt blew up: %v\", err)\n-\t}\n-\tif !bytes.HasSuffix(expectedHash, hash) {\n-\t\tt.Errorf(\"%v should be the suffix of %v\", hash, expectedHash)\n-\t}\n-\n-\th, err := newFromHash(expectedHash)\n-\tif err != nil {\n-\t\tt.Errorf(\"Unable to parse %s: %v\", string(expectedHash), err)\n-\t}\n-\n-\t// This is not the safe way to compare these hashes. We do this only for\n-\t// testing clarity. Use bcrypt.CompareHashAndPassword()\n-\tif err == nil && !bytes.Equal(expectedHash, h.Hash()) {\n-\t\tt.Errorf(\"Parsed hash %v should equal %v\", h.Hash(), expectedHash)\n-\t}\n-}\n-\n-func TestTooLongPasswordsWork(t *testing.T) {\n-\tsalt := []byte(\"XajjQvNhvvRt5GSeFk1xFe\")\n-\t// One byte over the usual 56 byte limit that blowfish has\n-\ttooLongPass := []byte(\"012345678901234567890123456789012345678901234567890123456\")\n-\ttooLongExpected := []byte(\"$2a$10$XajjQvNhvvRt5GSeFk1xFe5l47dONXg781AmZtd869sO8zfsHuw7C\")\n-\thash, err := bcrypt(tooLongPass, 10, salt)\n-\tif err != nil {\n-\t\tt.Fatalf(\"bcrypt blew up on long password: %v\", err)\n-\t}\n-\tif !bytes.HasSuffix(tooLongExpected, hash) {\n-\t\tt.Errorf(\"%v should be the suffix of %v\", hash, tooLongExpected)\n-\t}\n-}\n-\n-type InvalidHashTest struct {\n-\terr  error\n-\thash []byte\n-}\n-\n-var invalidTests = []InvalidHashTest{\n-\t{HashTooShortError, []byte(\"$2a$10$fooo\")},\n-\t{HashTooShortError, []byte(\"$2a\")},\n-\t{HashVersionTooNewError('3'), []byte(\"$3a$10$sssssssssssssssssssssshhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\")},\n-\t{InvalidHashPrefixError('%'), []byte(\"%2a$10$sssssssssssssssssssssshhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\")},\n-\t{InvalidCostError(32), []byte(\"$2a$32$sssssssssssssssssssssshhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\")},\n-}\n-\n-func TestInvalidHashErrors(t *testing.T) {\n-\tcheck := func(name string, expected, err error) {\n-\t\tif err == nil {\n-\t\t\tt.Errorf(\"%s: Should have returned an error\", name)\n-\t\t}\n-\t\tif err != nil && err != expected {\n-\t\t\tt.Errorf(\"%s gave err %v but should have given %v\", name, err, expected)\n-\t\t}\n-\t}\n-\tfor _, iht := range invalidTests {\n-\t\t_, err := newFromHash(iht.hash)\n-\t\tcheck(\"newFromHash\", iht.err, err)\n-\t\terr = CompareHashAndPassword(iht.hash, []byte(\"anything\"))\n-\t\tcheck(\"CompareHashAndPassword\", iht.err, err)\n-\t}\n-}\n-\n-func TestUnpaddedBase64Encoding(t *testing.T) {\n-\toriginal := []byte{101, 201, 101, 75, 19, 227, 199, 20, 239, 236, 133, 32, 30, 109, 243, 30}\n-\tencodedOriginal := []byte(\"XajjQvNhvvRt5GSeFk1xFe\")\n-\n-\tencoded := base64Encode(original)\n-\n-\tif !bytes.Equal(encodedOriginal, encoded) {\n-\t\tt.Errorf(\"Encoded %v should have equaled %v\", encoded, encodedOriginal)\n-\t}\n-\n-\tdecoded, err := base64Decode(encodedOriginal)\n-\tif err != nil {\n-\t\tt.Fatalf(\"base64Decode blew up: %s\", err)\n-\t}\n-\n-\tif !bytes.Equal(decoded, original) {\n-\t\tt.Errorf(\"Decoded %v should have equaled %v\", decoded, original)\n-\t}\n-}\n-\n-func TestCost(t *testing.T) {\n-\tif testing.Short() {\n-\t\treturn\n-\t}\n-\n-\tpass := []byte(\"mypassword\")\n-\n-\tfor c := 0; c < MinCost; c++ {\n-\t\tp, _ := newFromPassword(pass, c)\n-\t\tif p.cost != uint32(DefaultCost) {\n-\t\t\tt.Errorf(\"newFromPassword should default costs below %d to %d, but was %d\", MinCost, DefaultCost, p.cost)\n-\t\t}\n-\t}\n-\n-\tp, _ := newFromPassword(pass, 14)\n-\tif p.cost != 14 {\n-\t\tt.Errorf(\"newFromPassword should default cost to 14, but was %d\", p.cost)\n-\t}\n-\n-\thp, _ := newFromHash(p.Hash())\n-\tif p.cost != hp.cost {\n-\t\tt.Errorf(\"newFromHash should maintain the cost at %d, but was %d\", p.cost, hp.cost)\n-\t}\n-\n-\t_, err := newFromPassword(pass, 32)\n-\tif err == nil {\n-\t\tt.Fatalf(\"newFromPassword: should return a cost error\")\n-\t}\n-\tif err != InvalidCostError(32) {\n-\t\tt.Errorf(\"newFromPassword: should return cost error, got %#v\", err)\n-\t}\n-}\n-\n-func TestCostReturnsWithLeadingZeroes(t *testing.T) {\n-\thp, _ := newFromPassword([]byte(\"abcdefgh\"), 7)\n-\tcost := hp.Hash()[4:7]\n-\texpected := []byte(\"07$\")\n-\n-\tif !bytes.Equal(expected, cost) {\n-\t\tt.Errorf(\"single digit costs in hash should have leading zeros: was %v instead of %v\", cost, expected)\n-\t}\n-}\n-\n-func TestMinorNotRequired(t *testing.T) {\n-\tnoMinorHash := []byte(\"$2$10$XajjQvNhvvRt5GSeFk1xFeyqRrsxkhBkUiQeg0dt.wU1qD4aFDcga\")\n-\th, err := newFromHash(noMinorHash)\n-\tif err != nil {\n-\t\tt.Fatalf(\"No minor hash blew up: %s\", err)\n-\t}\n-\tif h.minor != 0 {\n-\t\tt.Errorf(\"Should leave minor version at 0, but was %d\", h.minor)\n-\t}\n-\n-\tif !bytes.Equal(noMinorHash, h.Hash()) {\n-\t\tt.Errorf(\"Should generate hash %v, but created %v\", noMinorHash, h.Hash())\n-\t}\n-}\n-\n-func BenchmarkEqual(b *testing.B) {\n-\tb.StopTimer()\n-\tpasswd := []byte(\"somepasswordyoulike\")\n-\thash, _ := GenerateFromPassword(passwd, 10)\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\tCompareHashAndPassword(hash, passwd)\n-\t}\n-}\n-\n-func BenchmarkGeneration(b *testing.B) {\n-\tb.StopTimer()\n-\tpasswd := []byte(\"mylongpassword1234\")\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\tGenerateFromPassword(passwd, 10)\n-\t}\n-}"}, {"sha": "326292dfc3c294e0d324280463597535d1c29173", "filename": "libgo/go/crypto/blowfish/block.go", "status": "removed", "additions": 0, "deletions": 192, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fblock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fblock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fblock.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,192 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package blowfish\n-\n-// ExpandKey performs a key expansion on the given *Cipher. Specifically, it\n-// performs the Blowfish algorithm's key schedule which sets up the *Cipher's\n-// pi and substitution tables for calls to Encrypt. This is used, primarily,\n-// by the bcrypt package to reuse the Blowfish key schedule during its\n-// set up. It's unlikely that you need to use this directly.\n-func ExpandKey(key []byte, c *Cipher) {\n-\tj := 0\n-\tfor i := 0; i < 18; i++ {\n-\t\tvar d uint32\n-\t\tfor k := 0; k < 4; k++ {\n-\t\t\td = d<<8 | uint32(key[j])&0x000000FF\n-\t\t\tj++\n-\t\t\tif j >= len(key) {\n-\t\t\t\tj = 0\n-\t\t\t}\n-\t\t}\n-\t\tc.p[i] ^= d\n-\t}\n-\n-\tvar l, r uint32\n-\tfor i := 0; i < 18; i += 2 {\n-\t\tl, r = encryptBlock(l, r, c)\n-\t\tc.p[i], c.p[i+1] = l, r\n-\t}\n-\n-\tfor i := 0; i < 256; i += 2 {\n-\t\tl, r = encryptBlock(l, r, c)\n-\t\tc.s0[i], c.s0[i+1] = l, r\n-\t}\n-\tfor i := 0; i < 256; i += 2 {\n-\t\tl, r = encryptBlock(l, r, c)\n-\t\tc.s1[i], c.s1[i+1] = l, r\n-\t}\n-\tfor i := 0; i < 256; i += 2 {\n-\t\tl, r = encryptBlock(l, r, c)\n-\t\tc.s2[i], c.s2[i+1] = l, r\n-\t}\n-\tfor i := 0; i < 256; i += 2 {\n-\t\tl, r = encryptBlock(l, r, c)\n-\t\tc.s3[i], c.s3[i+1] = l, r\n-\t}\n-}\n-\n-// This is similar to ExpandKey, but folds the salt during the key\n-// schedule. While ExpandKey is essentially expandKeyWithSalt with an all-zero\n-// salt passed in, reusing ExpandKey turns out to be a place of inefficiency\n-// and specializing it here is useful.\n-func expandKeyWithSalt(key []byte, salt []byte, c *Cipher) {\n-\tj := 0\n-\texpandedKey := make([]uint32, 18)\n-\tfor i := 0; i < 18; i++ {\n-\t\tvar d uint32\n-\t\tfor k := 0; k < 4; k++ {\n-\t\t\td = d<<8 | uint32(key[j])&0x000000FF\n-\t\t\tj++\n-\t\t\tif j >= len(key) {\n-\t\t\t\tj = 0\n-\t\t\t}\n-\t\t}\n-\t\texpandedKey[i] = d\n-\t\tc.p[i] ^= d\n-\t}\n-\n-\tj = 0\n-\texpandedSalt := make([]uint32, 18)\n-\tfor i := 0; i < 18; i++ {\n-\t\tvar d uint32\n-\t\tfor k := 0; k < 4; k++ {\n-\t\t\td = d<<8 | uint32(salt[j])&0x000000FF\n-\t\t\tj++\n-\t\t\tif j >= len(salt) {\n-\t\t\t\tj = 0\n-\t\t\t}\n-\t\t}\n-\t\texpandedSalt[i] = d\n-\t}\n-\n-\tvar l, r uint32\n-\tfor i := 0; i < 18; i += 2 {\n-\t\tl ^= expandedSalt[i&2]\n-\t\tr ^= expandedSalt[(i&2)+1]\n-\t\tl, r = encryptBlock(l, r, c)\n-\t\tc.p[i], c.p[i+1] = l, r\n-\t}\n-\n-\tfor i := 0; i < 256; i += 4 {\n-\t\tl ^= expandedSalt[2]\n-\t\tr ^= expandedSalt[3]\n-\t\tl, r = encryptBlock(l, r, c)\n-\t\tc.s0[i], c.s0[i+1] = l, r\n-\n-\t\tl ^= expandedSalt[0]\n-\t\tr ^= expandedSalt[1]\n-\t\tl, r = encryptBlock(l, r, c)\n-\t\tc.s0[i+2], c.s0[i+3] = l, r\n-\n-\t}\n-\n-\tfor i := 0; i < 256; i += 4 {\n-\t\tl ^= expandedSalt[2]\n-\t\tr ^= expandedSalt[3]\n-\t\tl, r = encryptBlock(l, r, c)\n-\t\tc.s1[i], c.s1[i+1] = l, r\n-\n-\t\tl ^= expandedSalt[0]\n-\t\tr ^= expandedSalt[1]\n-\t\tl, r = encryptBlock(l, r, c)\n-\t\tc.s1[i+2], c.s1[i+3] = l, r\n-\t}\n-\n-\tfor i := 0; i < 256; i += 4 {\n-\t\tl ^= expandedSalt[2]\n-\t\tr ^= expandedSalt[3]\n-\t\tl, r = encryptBlock(l, r, c)\n-\t\tc.s2[i], c.s2[i+1] = l, r\n-\n-\t\tl ^= expandedSalt[0]\n-\t\tr ^= expandedSalt[1]\n-\t\tl, r = encryptBlock(l, r, c)\n-\t\tc.s2[i+2], c.s2[i+3] = l, r\n-\t}\n-\n-\tfor i := 0; i < 256; i += 4 {\n-\t\tl ^= expandedSalt[2]\n-\t\tr ^= expandedSalt[3]\n-\t\tl, r = encryptBlock(l, r, c)\n-\t\tc.s3[i], c.s3[i+1] = l, r\n-\n-\t\tl ^= expandedSalt[0]\n-\t\tr ^= expandedSalt[1]\n-\t\tl, r = encryptBlock(l, r, c)\n-\t\tc.s3[i+2], c.s3[i+3] = l, r\n-\t}\n-}\n-\n-func encryptBlock(l, r uint32, c *Cipher) (uint32, uint32) {\n-\txl, xr := l, r\n-\txl ^= c.p[0]\n-\txr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[1]\n-\txl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[2]\n-\txr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[3]\n-\txl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[4]\n-\txr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[5]\n-\txl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[6]\n-\txr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[7]\n-\txl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[8]\n-\txr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[9]\n-\txl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[10]\n-\txr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[11]\n-\txl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[12]\n-\txr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[13]\n-\txl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[14]\n-\txr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[15]\n-\txl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[16]\n-\txr ^= c.p[17]\n-\treturn xr, xl\n-}\n-\n-func decryptBlock(l, r uint32, c *Cipher) (uint32, uint32) {\n-\txl, xr := l, r\n-\txl ^= c.p[17]\n-\txr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[16]\n-\txl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[15]\n-\txr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[14]\n-\txl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[13]\n-\txr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[12]\n-\txl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[11]\n-\txr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[10]\n-\txl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[9]\n-\txr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[8]\n-\txl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[7]\n-\txr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[6]\n-\txl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[5]\n-\txr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[4]\n-\txl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[3]\n-\txr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[2]\n-\txl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[1]\n-\txr ^= c.p[0]\n-\treturn xr, xl\n-}\n-\n-func zero(x []uint32) {\n-\tfor i := range x {\n-\t\tx[i] = 0\n-\t}\n-}"}, {"sha": "1038d2e39eed798256433114ecbfc350f9784ba1", "filename": "libgo/go/crypto/blowfish/blowfish_test.go", "status": "removed", "additions": 0, "deletions": 210, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fblowfish_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fblowfish_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fblowfish_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,210 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package blowfish\n-\n-import (\n-\t\"testing\"\n-)\n-\n-type CryptTest struct {\n-\tkey []byte\n-\tin  []byte\n-\tout []byte\n-}\n-\n-// Test vector values are from http://www.schneier.com/code/vectors.txt.\n-var encryptTests = []CryptTest{\n-\t{\n-\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n-\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n-\t\t[]byte{0x4E, 0xF9, 0x97, 0x45, 0x61, 0x98, 0xDD, 0x78}},\n-\t{\n-\t\t[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},\n-\t\t[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},\n-\t\t[]byte{0x51, 0x86, 0x6F, 0xD5, 0xB8, 0x5E, 0xCB, 0x8A}},\n-\t{\n-\t\t[]byte{0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n-\t\t[]byte{0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},\n-\t\t[]byte{0x7D, 0x85, 0x6F, 0x9A, 0x61, 0x30, 0x63, 0xF2}},\n-\t{\n-\t\t[]byte{0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11},\n-\t\t[]byte{0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11},\n-\t\t[]byte{0x24, 0x66, 0xDD, 0x87, 0x8B, 0x96, 0x3C, 0x9D}},\n-\n-\t{\n-\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF},\n-\t\t[]byte{0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11},\n-\t\t[]byte{0x61, 0xF9, 0xC3, 0x80, 0x22, 0x81, 0xB0, 0x96}},\n-\t{\n-\t\t[]byte{0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11},\n-\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF},\n-\t\t[]byte{0x7D, 0x0C, 0xC6, 0x30, 0xAF, 0xDA, 0x1E, 0xC7}},\n-\t{\n-\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n-\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n-\t\t[]byte{0x4E, 0xF9, 0x97, 0x45, 0x61, 0x98, 0xDD, 0x78}},\n-\t{\n-\t\t[]byte{0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10},\n-\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF},\n-\t\t[]byte{0x0A, 0xCE, 0xAB, 0x0F, 0xC6, 0xA0, 0xA2, 0x8D}},\n-\t{\n-\t\t[]byte{0x7C, 0xA1, 0x10, 0x45, 0x4A, 0x1A, 0x6E, 0x57},\n-\t\t[]byte{0x01, 0xA1, 0xD6, 0xD0, 0x39, 0x77, 0x67, 0x42},\n-\t\t[]byte{0x59, 0xC6, 0x82, 0x45, 0xEB, 0x05, 0x28, 0x2B}},\n-\t{\n-\t\t[]byte{0x01, 0x31, 0xD9, 0x61, 0x9D, 0xC1, 0x37, 0x6E},\n-\t\t[]byte{0x5C, 0xD5, 0x4C, 0xA8, 0x3D, 0xEF, 0x57, 0xDA},\n-\t\t[]byte{0xB1, 0xB8, 0xCC, 0x0B, 0x25, 0x0F, 0x09, 0xA0}},\n-\t{\n-\t\t[]byte{0x07, 0xA1, 0x13, 0x3E, 0x4A, 0x0B, 0x26, 0x86},\n-\t\t[]byte{0x02, 0x48, 0xD4, 0x38, 0x06, 0xF6, 0x71, 0x72},\n-\t\t[]byte{0x17, 0x30, 0xE5, 0x77, 0x8B, 0xEA, 0x1D, 0xA4}},\n-\t{\n-\t\t[]byte{0x38, 0x49, 0x67, 0x4C, 0x26, 0x02, 0x31, 0x9E},\n-\t\t[]byte{0x51, 0x45, 0x4B, 0x58, 0x2D, 0xDF, 0x44, 0x0A},\n-\t\t[]byte{0xA2, 0x5E, 0x78, 0x56, 0xCF, 0x26, 0x51, 0xEB}},\n-\t{\n-\t\t[]byte{0x04, 0xB9, 0x15, 0xBA, 0x43, 0xFE, 0xB5, 0xB6},\n-\t\t[]byte{0x42, 0xFD, 0x44, 0x30, 0x59, 0x57, 0x7F, 0xA2},\n-\t\t[]byte{0x35, 0x38, 0x82, 0xB1, 0x09, 0xCE, 0x8F, 0x1A}},\n-\t{\n-\t\t[]byte{0x01, 0x13, 0xB9, 0x70, 0xFD, 0x34, 0xF2, 0xCE},\n-\t\t[]byte{0x05, 0x9B, 0x5E, 0x08, 0x51, 0xCF, 0x14, 0x3A},\n-\t\t[]byte{0x48, 0xF4, 0xD0, 0x88, 0x4C, 0x37, 0x99, 0x18}},\n-\t{\n-\t\t[]byte{0x01, 0x70, 0xF1, 0x75, 0x46, 0x8F, 0xB5, 0xE6},\n-\t\t[]byte{0x07, 0x56, 0xD8, 0xE0, 0x77, 0x47, 0x61, 0xD2},\n-\t\t[]byte{0x43, 0x21, 0x93, 0xB7, 0x89, 0x51, 0xFC, 0x98}},\n-\t{\n-\t\t[]byte{0x43, 0x29, 0x7F, 0xAD, 0x38, 0xE3, 0x73, 0xFE},\n-\t\t[]byte{0x76, 0x25, 0x14, 0xB8, 0x29, 0xBF, 0x48, 0x6A},\n-\t\t[]byte{0x13, 0xF0, 0x41, 0x54, 0xD6, 0x9D, 0x1A, 0xE5}},\n-\t{\n-\t\t[]byte{0x07, 0xA7, 0x13, 0x70, 0x45, 0xDA, 0x2A, 0x16},\n-\t\t[]byte{0x3B, 0xDD, 0x11, 0x90, 0x49, 0x37, 0x28, 0x02},\n-\t\t[]byte{0x2E, 0xED, 0xDA, 0x93, 0xFF, 0xD3, 0x9C, 0x79}},\n-\t{\n-\t\t[]byte{0x04, 0x68, 0x91, 0x04, 0xC2, 0xFD, 0x3B, 0x2F},\n-\t\t[]byte{0x26, 0x95, 0x5F, 0x68, 0x35, 0xAF, 0x60, 0x9A},\n-\t\t[]byte{0xD8, 0x87, 0xE0, 0x39, 0x3C, 0x2D, 0xA6, 0xE3}},\n-\t{\n-\t\t[]byte{0x37, 0xD0, 0x6B, 0xB5, 0x16, 0xCB, 0x75, 0x46},\n-\t\t[]byte{0x16, 0x4D, 0x5E, 0x40, 0x4F, 0x27, 0x52, 0x32},\n-\t\t[]byte{0x5F, 0x99, 0xD0, 0x4F, 0x5B, 0x16, 0x39, 0x69}},\n-\t{\n-\t\t[]byte{0x1F, 0x08, 0x26, 0x0D, 0x1A, 0xC2, 0x46, 0x5E},\n-\t\t[]byte{0x6B, 0x05, 0x6E, 0x18, 0x75, 0x9F, 0x5C, 0xCA},\n-\t\t[]byte{0x4A, 0x05, 0x7A, 0x3B, 0x24, 0xD3, 0x97, 0x7B}},\n-\t{\n-\t\t[]byte{0x58, 0x40, 0x23, 0x64, 0x1A, 0xBA, 0x61, 0x76},\n-\t\t[]byte{0x00, 0x4B, 0xD6, 0xEF, 0x09, 0x17, 0x60, 0x62},\n-\t\t[]byte{0x45, 0x20, 0x31, 0xC1, 0xE4, 0xFA, 0xDA, 0x8E}},\n-\t{\n-\t\t[]byte{0x02, 0x58, 0x16, 0x16, 0x46, 0x29, 0xB0, 0x07},\n-\t\t[]byte{0x48, 0x0D, 0x39, 0x00, 0x6E, 0xE7, 0x62, 0xF2},\n-\t\t[]byte{0x75, 0x55, 0xAE, 0x39, 0xF5, 0x9B, 0x87, 0xBD}},\n-\t{\n-\t\t[]byte{0x49, 0x79, 0x3E, 0xBC, 0x79, 0xB3, 0x25, 0x8F},\n-\t\t[]byte{0x43, 0x75, 0x40, 0xC8, 0x69, 0x8F, 0x3C, 0xFA},\n-\t\t[]byte{0x53, 0xC5, 0x5F, 0x9C, 0xB4, 0x9F, 0xC0, 0x19}},\n-\t{\n-\t\t[]byte{0x4F, 0xB0, 0x5E, 0x15, 0x15, 0xAB, 0x73, 0xA7},\n-\t\t[]byte{0x07, 0x2D, 0x43, 0xA0, 0x77, 0x07, 0x52, 0x92},\n-\t\t[]byte{0x7A, 0x8E, 0x7B, 0xFA, 0x93, 0x7E, 0x89, 0xA3}},\n-\t{\n-\t\t[]byte{0x49, 0xE9, 0x5D, 0x6D, 0x4C, 0xA2, 0x29, 0xBF},\n-\t\t[]byte{0x02, 0xFE, 0x55, 0x77, 0x81, 0x17, 0xF1, 0x2A},\n-\t\t[]byte{0xCF, 0x9C, 0x5D, 0x7A, 0x49, 0x86, 0xAD, 0xB5}},\n-\t{\n-\t\t[]byte{0x01, 0x83, 0x10, 0xDC, 0x40, 0x9B, 0x26, 0xD6},\n-\t\t[]byte{0x1D, 0x9D, 0x5C, 0x50, 0x18, 0xF7, 0x28, 0xC2},\n-\t\t[]byte{0xD1, 0xAB, 0xB2, 0x90, 0x65, 0x8B, 0xC7, 0x78}},\n-\t{\n-\t\t[]byte{0x1C, 0x58, 0x7F, 0x1C, 0x13, 0x92, 0x4F, 0xEF},\n-\t\t[]byte{0x30, 0x55, 0x32, 0x28, 0x6D, 0x6F, 0x29, 0x5A},\n-\t\t[]byte{0x55, 0xCB, 0x37, 0x74, 0xD1, 0x3E, 0xF2, 0x01}},\n-\t{\n-\t\t[]byte{0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01},\n-\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF},\n-\t\t[]byte{0xFA, 0x34, 0xEC, 0x48, 0x47, 0xB2, 0x68, 0xB2}},\n-\t{\n-\t\t[]byte{0x1F, 0x1F, 0x1F, 0x1F, 0x0E, 0x0E, 0x0E, 0x0E},\n-\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF},\n-\t\t[]byte{0xA7, 0x90, 0x79, 0x51, 0x08, 0xEA, 0x3C, 0xAE}},\n-\t{\n-\t\t[]byte{0xE0, 0xFE, 0xE0, 0xFE, 0xF1, 0xFE, 0xF1, 0xFE},\n-\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF},\n-\t\t[]byte{0xC3, 0x9E, 0x07, 0x2D, 0x9F, 0xAC, 0x63, 0x1D}},\n-\t{\n-\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n-\t\t[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},\n-\t\t[]byte{0x01, 0x49, 0x33, 0xE0, 0xCD, 0xAF, 0xF6, 0xE4}},\n-\t{\n-\t\t[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},\n-\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n-\t\t[]byte{0xF2, 0x1E, 0x9A, 0x77, 0xB7, 0x1C, 0x49, 0xBC}},\n-\t{\n-\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF},\n-\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n-\t\t[]byte{0x24, 0x59, 0x46, 0x88, 0x57, 0x54, 0x36, 0x9A}},\n-\t{\n-\t\t[]byte{0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10},\n-\t\t[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},\n-\t\t[]byte{0x6B, 0x5C, 0x5A, 0x9C, 0x5D, 0x9E, 0x0A, 0x5A}},\n-}\n-\n-func TestCipherEncrypt(t *testing.T) {\n-\tfor i, tt := range encryptTests {\n-\t\tc, err := NewCipher(tt.key)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"NewCipher(%d bytes) = %s\", len(tt.key), err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tct := make([]byte, len(tt.out))\n-\t\tc.Encrypt(ct, tt.in)\n-\t\tfor j, v := range ct {\n-\t\t\tif v != tt.out[j] {\n-\t\t\t\tt.Errorf(\"Cipher.Encrypt, test vector #%d: cipher-text[%d] = %#x, expected %#x\", i, j, v, tt.out[j])\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-func TestCipherDecrypt(t *testing.T) {\n-\tfor i, tt := range encryptTests {\n-\t\tc, err := NewCipher(tt.key)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"NewCipher(%d bytes) = %s\", len(tt.key), err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tpt := make([]byte, len(tt.in))\n-\t\tc.Decrypt(pt, tt.out)\n-\t\tfor j, v := range pt {\n-\t\t\tif v != tt.in[j] {\n-\t\t\t\tt.Errorf(\"Cipher.Decrypt, test vector #%d: plain-text[%d] = %#x, expected %#x\", i, j, v, tt.in[j])\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-func TestSaltedCipherKeyLength(t *testing.T) {\n-\tvar key []byte\n-\tfor i := 0; i < 4; i++ {\n-\t\t_, err := NewSaltedCipher(key, []byte{'a'})\n-\t\tif err != KeySizeError(i) {\n-\t\t\tt.Errorf(\"NewSaltedCipher with short key, gave error %#v, expected %#v\", err, KeySizeError(i))\n-\t\t}\n-\t\tkey = append(key, 'a')\n-\t}\n-\n-\t// A 57-byte key. One over the typical blowfish restriction.\n-\tkey = []byte(\"012345678901234567890123456789012345678901234567890123456\")\n-\t_, err := NewSaltedCipher(key, []byte{'a'})\n-\tif err != nil {\n-\t\tt.Errorf(\"NewSaltedCipher with long key, gave error %#v\", err)\n-\t}\n-}"}, {"sha": "94e10f0e267cce2ad76ba9f80c85cb4300208eed", "filename": "libgo/go/crypto/blowfish/cipher.go", "status": "removed", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fcipher.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,100 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package blowfish implements Bruce Schneier's Blowfish encryption algorithm.\n-package blowfish\n-\n-// The code is a port of Bruce Schneier's C implementation.\n-// See http://www.schneier.com/blowfish.html.\n-\n-import \"strconv\"\n-\n-// The Blowfish block size in bytes.\n-const BlockSize = 8\n-\n-// A Cipher is an instance of Blowfish encryption using a particular key.\n-type Cipher struct {\n-\tp              [18]uint32\n-\ts0, s1, s2, s3 [256]uint32\n-}\n-\n-type KeySizeError int\n-\n-func (k KeySizeError) Error() string {\n-\treturn \"crypto/blowfish: invalid key size \" + strconv.Itoa(int(k))\n-}\n-\n-// NewCipher creates and returns a Cipher.\n-// The key argument should be the Blowfish key, 4 to 56 bytes.\n-func NewCipher(key []byte) (*Cipher, error) {\n-\tvar result Cipher\n-\tk := len(key)\n-\tif k < 4 || k > 56 {\n-\t\treturn nil, KeySizeError(k)\n-\t}\n-\tinitCipher(key, &result)\n-\tExpandKey(key, &result)\n-\treturn &result, nil\n-}\n-\n-// NewSaltedCipher creates a returns a Cipher that folds a salt into its key\n-// schedule. For most purposes, NewCipher, instead of NewSaltedCipher, is\n-// sufficient and desirable. For bcrypt compatiblity, the key can be over 56\n-// bytes.\n-func NewSaltedCipher(key, salt []byte) (*Cipher, error) {\n-\tvar result Cipher\n-\tk := len(key)\n-\tif k < 4 {\n-\t\treturn nil, KeySizeError(k)\n-\t}\n-\tinitCipher(key, &result)\n-\texpandKeyWithSalt(key, salt, &result)\n-\treturn &result, nil\n-}\n-\n-// BlockSize returns the Blowfish block size, 8 bytes.\n-// It is necessary to satisfy the Block interface in the\n-// package \"crypto/cipher\".\n-func (c *Cipher) BlockSize() int { return BlockSize }\n-\n-// Encrypt encrypts the 8-byte buffer src using the key k\n-// and stores the result in dst.\n-// Note that for amounts of data larger than a block,\n-// it is not safe to just call Encrypt on successive blocks;\n-// instead, use an encryption mode like CBC (see crypto/cipher/cbc.go).\n-func (c *Cipher) Encrypt(dst, src []byte) {\n-\tl := uint32(src[0])<<24 | uint32(src[1])<<16 | uint32(src[2])<<8 | uint32(src[3])\n-\tr := uint32(src[4])<<24 | uint32(src[5])<<16 | uint32(src[6])<<8 | uint32(src[7])\n-\tl, r = encryptBlock(l, r, c)\n-\tdst[0], dst[1], dst[2], dst[3] = byte(l>>24), byte(l>>16), byte(l>>8), byte(l)\n-\tdst[4], dst[5], dst[6], dst[7] = byte(r>>24), byte(r>>16), byte(r>>8), byte(r)\n-}\n-\n-// Decrypt decrypts the 8-byte buffer src using the key k\n-// and stores the result in dst.\n-func (c *Cipher) Decrypt(dst, src []byte) {\n-\tl := uint32(src[0])<<24 | uint32(src[1])<<16 | uint32(src[2])<<8 | uint32(src[3])\n-\tr := uint32(src[4])<<24 | uint32(src[5])<<16 | uint32(src[6])<<8 | uint32(src[7])\n-\tl, r = decryptBlock(l, r, c)\n-\tdst[0], dst[1], dst[2], dst[3] = byte(l>>24), byte(l>>16), byte(l>>8), byte(l)\n-\tdst[4], dst[5], dst[6], dst[7] = byte(r>>24), byte(r>>16), byte(r>>8), byte(r)\n-}\n-\n-// Reset zeros the key data, so that it will no longer\n-// appear in the process's memory.\n-func (c *Cipher) Reset() {\n-\tzero(c.p[0:])\n-\tzero(c.s0[0:])\n-\tzero(c.s1[0:])\n-\tzero(c.s2[0:])\n-\tzero(c.s3[0:])\n-}\n-\n-func initCipher(key []byte, c *Cipher) {\n-\tcopy(c.p[0:], p[0:])\n-\tcopy(c.s0[0:], s0[0:])\n-\tcopy(c.s1[0:], s1[0:])\n-\tcopy(c.s2[0:], s2[0:])\n-\tcopy(c.s3[0:], s3[0:])\n-}"}, {"sha": "8c5ee4cb08a19a6623182ccc7b5d0de6bd06838c", "filename": "libgo/go/crypto/blowfish/const.go", "status": "removed", "additions": 0, "deletions": 199, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fconst.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,199 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// The startup permutation array and substitution boxes.\n-// They are the hexadecimal digits of PI; see:\n-// http://www.schneier.com/code/constants.txt.\n-\n-package blowfish\n-\n-var s0 = [256]uint32{\n-\t0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96,\n-\t0xba7c9045, 0xf12c7f99, 0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16,\n-\t0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e, 0x0d95748f, 0x728eb658,\n-\t0x718bcd58, 0x82154aee, 0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013,\n-\t0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef, 0x8e79dcb0, 0x603a180e,\n-\t0x6c9e0e8b, 0xb01e8a3e, 0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60,\n-\t0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440, 0x55ca396a, 0x2aab10b6,\n-\t0xb4cc5c34, 0x1141e8ce, 0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a,\n-\t0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e, 0xafd6ba33, 0x6c24cf5c,\n-\t0x7a325381, 0x28958677, 0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193,\n-\t0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032, 0xef845d5d, 0xe98575b1,\n-\t0xdc262302, 0xeb651b88, 0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,\n-\t0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e, 0x21c66842, 0xf6e96c9a,\n-\t0x670c9c61, 0xabd388f0, 0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3,\n-\t0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98, 0xa1f1651d, 0x39af0176,\n-\t0x66ca593e, 0x82430e88, 0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe,\n-\t0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6, 0x4ed3aa62, 0x363f7706,\n-\t0x1bfedf72, 0x429b023d, 0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b,\n-\t0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7, 0xe3fe501a, 0xb6794c3b,\n-\t0x976ce0bd, 0x04c006ba, 0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,\n-\t0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f, 0x6dfc511f, 0x9b30952c,\n-\t0xcc814544, 0xaf5ebd09, 0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3,\n-\t0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb, 0x5579c0bd, 0x1a60320a,\n-\t0xd6a100c6, 0x402c7279, 0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8,\n-\t0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab, 0x323db5fa, 0xfd238760,\n-\t0x53317b48, 0x3e00df82, 0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db,\n-\t0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573, 0x695b27b0, 0xbbca58c8,\n-\t0xe1ffa35d, 0xb8f011a0, 0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b,\n-\t0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790, 0xe1ddf2da, 0xa4cb7e33,\n-\t0x62fb1341, 0xcee4c6e8, 0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4,\n-\t0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0, 0xd08ed1d0, 0xafc725e0,\n-\t0x8e3c5b2f, 0x8e7594b7, 0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c,\n-\t0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad, 0x2f2f2218, 0xbe0e1777,\n-\t0xea752dfe, 0x8b021fa1, 0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299,\n-\t0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9, 0x165fa266, 0x80957705,\n-\t0x93cc7314, 0x211a1477, 0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,\n-\t0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49, 0x00250e2d, 0x2071b35e,\n-\t0x226800bb, 0x57b8e0af, 0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa,\n-\t0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5, 0x83260376, 0x6295cfa9,\n-\t0x11c81968, 0x4e734a41, 0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,\n-\t0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400, 0x08ba6fb5, 0x571be91f,\n-\t0xf296ec6b, 0x2a0dd915, 0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664,\n-\t0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a,\n-}\n-\n-var s1 = [256]uint32{\n-\t0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623, 0xad6ea6b0, 0x49a7df7d,\n-\t0x9cee60b8, 0x8fedb266, 0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1,\n-\t0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e, 0x3f54989a, 0x5b429d65,\n-\t0x6b8fe4d6, 0x99f73fd6, 0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,\n-\t0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e, 0x09686b3f, 0x3ebaefc9,\n-\t0x3c971814, 0x6b6a70a1, 0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737,\n-\t0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8, 0xb03ada37, 0xf0500c0d,\n-\t0xf01c1f04, 0x0200b3ff, 0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd,\n-\t0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701, 0x3ae5e581, 0x37c2dadc,\n-\t0xc8b57634, 0x9af3dda7, 0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41,\n-\t0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331, 0x4e548b38, 0x4f6db908,\n-\t0x6f420d03, 0xf60a04bf, 0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af,\n-\t0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e, 0x5512721f, 0x2e6b7124,\n-\t0x501adde6, 0x9f84cd87, 0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c,\n-\t0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2, 0xef1c1847, 0x3215d908,\n-\t0xdd433b37, 0x24c2ba16, 0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd,\n-\t0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b, 0x043556f1, 0xd7a3c76b,\n-\t0x3c11183b, 0x5924a509, 0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e,\n-\t0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3, 0x771fe71c, 0x4e3d06fa,\n-\t0x2965dcb9, 0x99e71d0f, 0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a,\n-\t0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4, 0xf2f74ea7, 0x361d2b3d,\n-\t0x1939260f, 0x19c27960, 0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66,\n-\t0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28, 0xc332ddef, 0xbe6c5aa5,\n-\t0x65582185, 0x68ab9802, 0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,\n-\t0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510, 0x13cca830, 0xeb61bd96,\n-\t0x0334fe1e, 0xaa0363cf, 0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14,\n-\t0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e, 0x648b1eaf, 0x19bdf0ca,\n-\t0xa02369b9, 0x655abb50, 0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7,\n-\t0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8, 0xf837889a, 0x97e32d77,\n-\t0x11ed935f, 0x16681281, 0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99,\n-\t0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696, 0xcdb30aeb, 0x532e3054,\n-\t0x8fd948e4, 0x6dbc3128, 0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73,\n-\t0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0, 0x45eee2b6, 0xa3aaabea,\n-\t0xdb6c4f15, 0xfacb4fd0, 0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105,\n-\t0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250, 0xcf62a1f2, 0x5b8d2646,\n-\t0xfc8883a0, 0xc1c7b6a3, 0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285,\n-\t0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00, 0x58428d2a, 0x0c55f5ea,\n-\t0x1dadf43e, 0x233f7061, 0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb,\n-\t0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e, 0xa6078084, 0x19f8509e,\n-\t0xe8efd855, 0x61d99735, 0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc,\n-\t0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9, 0xdb73dbd3, 0x105588cd,\n-\t0x675fda79, 0xe3674340, 0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20,\n-\t0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7,\n-}\n-\n-var s2 = [256]uint32{\n-\t0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934, 0x411520f7, 0x7602d4f7,\n-\t0xbcf46b2e, 0xd4a20068, 0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af,\n-\t0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840, 0x4d95fc1d, 0x96b591af,\n-\t0x70f4ddd3, 0x66a02f45, 0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504,\n-\t0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a, 0x28507825, 0x530429f4,\n-\t0x0a2c86da, 0xe9b66dfb, 0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee,\n-\t0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6, 0xaace1e7c, 0xd3375fec,\n-\t0xce78a399, 0x406b2a42, 0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,\n-\t0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2, 0x3a6efa74, 0xdd5b4332,\n-\t0x6841e7f7, 0xca7820fb, 0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527,\n-\t0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b, 0x55a867bc, 0xa1159a58,\n-\t0xcca92963, 0x99e1db33, 0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c,\n-\t0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3, 0x95c11548, 0xe4c66d22,\n-\t0x48c1133f, 0xc70f86dc, 0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17,\n-\t0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564, 0x257b7834, 0x602a9c60,\n-\t0xdff8e8a3, 0x1f636c1b, 0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115,\n-\t0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922, 0x85b2a20e, 0xe6ba0d99,\n-\t0xde720c8c, 0x2da2f728, 0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0,\n-\t0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e, 0x0a476341, 0x992eff74,\n-\t0x3a6f6eab, 0xf4f8fd37, 0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d,\n-\t0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804, 0xf1290dc7, 0xcc00ffa3,\n-\t0xb5390f92, 0x690fed0b, 0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3,\n-\t0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb, 0x37392eb3, 0xcc115979,\n-\t0x8026e297, 0xf42e312d, 0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c,\n-\t0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350, 0x1a6b1018, 0x11caedfa,\n-\t0x3d25bdd8, 0xe2e1c3c9, 0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a,\n-\t0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe, 0x9dbc8057, 0xf0f7c086,\n-\t0x60787bf8, 0x6003604d, 0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc,\n-\t0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f, 0x77a057be, 0xbde8ae24,\n-\t0x55464299, 0xbf582e61, 0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2,\n-\t0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9, 0x7aeb2661, 0x8b1ddf84,\n-\t0x846a0e79, 0x915f95e2, 0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c,\n-\t0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e, 0xb77f19b6, 0xe0a9dc09,\n-\t0x662d09a1, 0xc4324633, 0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10,\n-\t0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169, 0xdcb7da83, 0x573906fe,\n-\t0xa1e2ce9b, 0x4fcd7f52, 0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027,\n-\t0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5, 0xf0177a28, 0xc0f586e0,\n-\t0x006058aa, 0x30dc7d62, 0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634,\n-\t0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76, 0x6f05e409, 0x4b7c0188,\n-\t0x39720a3d, 0x7c927c24, 0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc,\n-\t0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4, 0x1e50ef5e, 0xb161e6f8,\n-\t0xa28514d9, 0x6c51133c, 0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837,\n-\t0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0,\n-}\n-\n-var s3 = [256]uint32{\n-\t0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b, 0x5cb0679e, 0x4fa33742,\n-\t0xd3822740, 0x99bc9bbe, 0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b,\n-\t0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4, 0x5748ab2f, 0xbc946e79,\n-\t0xc6a376d2, 0x6549c2c8, 0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6,\n-\t0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304, 0xa1fad5f0, 0x6a2d519a,\n-\t0x63ef8ce2, 0x9a86ee22, 0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4,\n-\t0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6, 0x2826a2f9, 0xa73a3ae1,\n-\t0x4ba99586, 0xef5562e9, 0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59,\n-\t0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593, 0xe990fd5a, 0x9e34d797,\n-\t0x2cf0b7d9, 0x022b8b51, 0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28,\n-\t0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c, 0xe029ac71, 0xe019a5e6,\n-\t0x47b0acfd, 0xed93fa9b, 0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,\n-\t0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c, 0x15056dd4, 0x88f46dba,\n-\t0x03a16125, 0x0564f0bd, 0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a,\n-\t0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319, 0x7533d928, 0xb155fdf5,\n-\t0x03563482, 0x8aba3cbb, 0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f,\n-\t0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991, 0xea7a90c2, 0xfb3e7bce,\n-\t0x5121ce64, 0x774fbe32, 0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680,\n-\t0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166, 0xb39a460a, 0x6445c0dd,\n-\t0x586cdecf, 0x1c20c8ae, 0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb,\n-\t0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5, 0x72eacea8, 0xfa6484bb,\n-\t0x8d6612ae, 0xbf3c6f47, 0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370,\n-\t0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d, 0x4040cb08, 0x4eb4e2cc,\n-\t0x34d2466a, 0x0115af84, 0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,\n-\t0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8, 0x611560b1, 0xe7933fdc,\n-\t0xbb3a792b, 0x344525bd, 0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9,\n-\t0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7, 0x1a908749, 0xd44fbd9a,\n-\t0xd0dadecb, 0xd50ada38, 0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f,\n-\t0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c, 0xbf97222c, 0x15e6fc2a,\n-\t0x0f91fc71, 0x9b941525, 0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1,\n-\t0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442, 0xe0ec6e0e, 0x1698db3b,\n-\t0x4c98a0be, 0x3278e964, 0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,\n-\t0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8, 0xdf359f8d, 0x9b992f2e,\n-\t0xe60b6f47, 0x0fe3f11d, 0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f,\n-\t0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299, 0xf523f357, 0xa6327623,\n-\t0x93a83531, 0x56cccd02, 0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc,\n-\t0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614, 0xe6c6c7bd, 0x327a140a,\n-\t0x45e1d006, 0xc3f27b9a, 0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6,\n-\t0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b, 0x53113ec0, 0x1640e3d3,\n-\t0x38abbd60, 0x2547adf0, 0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060,\n-\t0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e, 0x1948c25c, 0x02fb8a8c,\n-\t0x01c36ae4, 0xd6ebe1f9, 0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f,\n-\t0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6,\n-}\n-\n-var p = [18]uint32{\n-\t0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822, 0x299f31d0,\n-\t0x082efa98, 0xec4e6c89, 0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c,\n-\t0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917, 0x9216d5d9, 0x8979fb1b,\n-}"}, {"sha": "889a13cb1f7eba11e653d9338aeb3937dc5324e2", "filename": "libgo/go/crypto/cast5/cast5.go", "status": "removed", "additions": 0, "deletions": 534, "changes": 534, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fcast5%2Fcast5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fcast5%2Fcast5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcast5%2Fcast5.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,534 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package cast5 implements CAST5, as defined in RFC 2144. CAST5 is a common\n-// OpenPGP cipher.\n-package cast5\n-\n-import \"errors\"\n-\n-const BlockSize = 8\n-const KeySize = 16\n-\n-type Cipher struct {\n-\tmasking [16]uint32\n-\trotate  [16]uint8\n-}\n-\n-func NewCipher(key []byte) (c *Cipher, err error) {\n-\tif len(key) != KeySize {\n-\t\treturn nil, errors.New(\"CAST5: keys must be 16 bytes\")\n-\t}\n-\n-\tc = new(Cipher)\n-\tc.keySchedule(key)\n-\treturn\n-}\n-\n-func (c *Cipher) BlockSize() int {\n-\treturn BlockSize\n-}\n-\n-// Reset zeros the key material in memory.\n-func (c *Cipher) Reset() {\n-\tfor i := 0; i < 16; i++ {\n-\t\tc.masking[i] = 0\n-\t\tc.rotate[i] = 0\n-\t}\n-}\n-\n-func (c *Cipher) Encrypt(dst, src []byte) {\n-\tl := uint32(src[0])<<24 | uint32(src[1])<<16 | uint32(src[2])<<8 | uint32(src[3])\n-\tr := uint32(src[4])<<24 | uint32(src[5])<<16 | uint32(src[6])<<8 | uint32(src[7])\n-\n-\tl, r = r, l^f1(r, c.masking[0], c.rotate[0])\n-\tl, r = r, l^f2(r, c.masking[1], c.rotate[1])\n-\tl, r = r, l^f3(r, c.masking[2], c.rotate[2])\n-\tl, r = r, l^f1(r, c.masking[3], c.rotate[3])\n-\n-\tl, r = r, l^f2(r, c.masking[4], c.rotate[4])\n-\tl, r = r, l^f3(r, c.masking[5], c.rotate[5])\n-\tl, r = r, l^f1(r, c.masking[6], c.rotate[6])\n-\tl, r = r, l^f2(r, c.masking[7], c.rotate[7])\n-\n-\tl, r = r, l^f3(r, c.masking[8], c.rotate[8])\n-\tl, r = r, l^f1(r, c.masking[9], c.rotate[9])\n-\tl, r = r, l^f2(r, c.masking[10], c.rotate[10])\n-\tl, r = r, l^f3(r, c.masking[11], c.rotate[11])\n-\n-\tl, r = r, l^f1(r, c.masking[12], c.rotate[12])\n-\tl, r = r, l^f2(r, c.masking[13], c.rotate[13])\n-\tl, r = r, l^f3(r, c.masking[14], c.rotate[14])\n-\tl, r = r, l^f1(r, c.masking[15], c.rotate[15])\n-\n-\tdst[0] = uint8(r >> 24)\n-\tdst[1] = uint8(r >> 16)\n-\tdst[2] = uint8(r >> 8)\n-\tdst[3] = uint8(r)\n-\tdst[4] = uint8(l >> 24)\n-\tdst[5] = uint8(l >> 16)\n-\tdst[6] = uint8(l >> 8)\n-\tdst[7] = uint8(l)\n-}\n-\n-func (c *Cipher) Decrypt(dst, src []byte) {\n-\tl := uint32(src[0])<<24 | uint32(src[1])<<16 | uint32(src[2])<<8 | uint32(src[3])\n-\tr := uint32(src[4])<<24 | uint32(src[5])<<16 | uint32(src[6])<<8 | uint32(src[7])\n-\n-\tl, r = r, l^f1(r, c.masking[15], c.rotate[15])\n-\tl, r = r, l^f3(r, c.masking[14], c.rotate[14])\n-\tl, r = r, l^f2(r, c.masking[13], c.rotate[13])\n-\tl, r = r, l^f1(r, c.masking[12], c.rotate[12])\n-\n-\tl, r = r, l^f3(r, c.masking[11], c.rotate[11])\n-\tl, r = r, l^f2(r, c.masking[10], c.rotate[10])\n-\tl, r = r, l^f1(r, c.masking[9], c.rotate[9])\n-\tl, r = r, l^f3(r, c.masking[8], c.rotate[8])\n-\n-\tl, r = r, l^f2(r, c.masking[7], c.rotate[7])\n-\tl, r = r, l^f1(r, c.masking[6], c.rotate[6])\n-\tl, r = r, l^f3(r, c.masking[5], c.rotate[5])\n-\tl, r = r, l^f2(r, c.masking[4], c.rotate[4])\n-\n-\tl, r = r, l^f1(r, c.masking[3], c.rotate[3])\n-\tl, r = r, l^f3(r, c.masking[2], c.rotate[2])\n-\tl, r = r, l^f2(r, c.masking[1], c.rotate[1])\n-\tl, r = r, l^f1(r, c.masking[0], c.rotate[0])\n-\n-\tdst[0] = uint8(r >> 24)\n-\tdst[1] = uint8(r >> 16)\n-\tdst[2] = uint8(r >> 8)\n-\tdst[3] = uint8(r)\n-\tdst[4] = uint8(l >> 24)\n-\tdst[5] = uint8(l >> 16)\n-\tdst[6] = uint8(l >> 8)\n-\tdst[7] = uint8(l)\n-}\n-\n-type keyScheduleA [4][7]uint8\n-type keyScheduleB [4][5]uint8\n-\n-// keyScheduleRound contains the magic values for a round of the key schedule.\n-// The keyScheduleA deals with the lines like:\n-//   z0z1z2z3 = x0x1x2x3 ^ S5[xD] ^ S6[xF] ^ S7[xC] ^ S8[xE] ^ S7[x8]\n-// Conceptually, both x and z are in the same array, x first. The first\n-// element describes which word of this array gets written to and the\n-// second, which word gets read. So, for the line above, it's \"4, 0\", because\n-// it's writing to the first word of z, which, being after x, is word 4, and\n-// reading from the first word of x: word 0.\n-//\n-// Next are the indexes into the S-boxes. Now the array is treated as bytes. So\n-// \"xD\" is 0xd. The first byte of z is written as \"16 + 0\", just to be clear\n-// that it's z that we're indexing.\n-//\n-// keyScheduleB deals with lines like:\n-//   K1 = S5[z8] ^ S6[z9] ^ S7[z7] ^ S8[z6] ^ S5[z2]\n-// \"K1\" is ignored because key words are always written in order. So the five\n-// elements are the S-box indexes. They use the same form as in keyScheduleA,\n-// above.\n-\n-type keyScheduleRound struct{}\n-type keySchedule []keyScheduleRound\n-\n-var schedule = []struct {\n-\ta keyScheduleA\n-\tb keyScheduleB\n-}{\n-\t{\n-\t\tkeyScheduleA{\n-\t\t\t{4, 0, 0xd, 0xf, 0xc, 0xe, 0x8},\n-\t\t\t{5, 2, 16 + 0, 16 + 2, 16 + 1, 16 + 3, 0xa},\n-\t\t\t{6, 3, 16 + 7, 16 + 6, 16 + 5, 16 + 4, 9},\n-\t\t\t{7, 1, 16 + 0xa, 16 + 9, 16 + 0xb, 16 + 8, 0xb},\n-\t\t},\n-\t\tkeyScheduleB{\n-\t\t\t{16 + 8, 16 + 9, 16 + 7, 16 + 6, 16 + 2},\n-\t\t\t{16 + 0xa, 16 + 0xb, 16 + 5, 16 + 4, 16 + 6},\n-\t\t\t{16 + 0xc, 16 + 0xd, 16 + 3, 16 + 2, 16 + 9},\n-\t\t\t{16 + 0xe, 16 + 0xf, 16 + 1, 16 + 0, 16 + 0xc},\n-\t\t},\n-\t},\n-\t{\n-\t\tkeyScheduleA{\n-\t\t\t{0, 6, 16 + 5, 16 + 7, 16 + 4, 16 + 6, 16 + 0},\n-\t\t\t{1, 4, 0, 2, 1, 3, 16 + 2},\n-\t\t\t{2, 5, 7, 6, 5, 4, 16 + 1},\n-\t\t\t{3, 7, 0xa, 9, 0xb, 8, 16 + 3},\n-\t\t},\n-\t\tkeyScheduleB{\n-\t\t\t{3, 2, 0xc, 0xd, 8},\n-\t\t\t{1, 0, 0xe, 0xf, 0xd},\n-\t\t\t{7, 6, 8, 9, 3},\n-\t\t\t{5, 4, 0xa, 0xb, 7},\n-\t\t},\n-\t},\n-\t{\n-\t\tkeyScheduleA{\n-\t\t\t{4, 0, 0xd, 0xf, 0xc, 0xe, 8},\n-\t\t\t{5, 2, 16 + 0, 16 + 2, 16 + 1, 16 + 3, 0xa},\n-\t\t\t{6, 3, 16 + 7, 16 + 6, 16 + 5, 16 + 4, 9},\n-\t\t\t{7, 1, 16 + 0xa, 16 + 9, 16 + 0xb, 16 + 8, 0xb},\n-\t\t},\n-\t\tkeyScheduleB{\n-\t\t\t{16 + 3, 16 + 2, 16 + 0xc, 16 + 0xd, 16 + 9},\n-\t\t\t{16 + 1, 16 + 0, 16 + 0xe, 16 + 0xf, 16 + 0xc},\n-\t\t\t{16 + 7, 16 + 6, 16 + 8, 16 + 9, 16 + 2},\n-\t\t\t{16 + 5, 16 + 4, 16 + 0xa, 16 + 0xb, 16 + 6},\n-\t\t},\n-\t},\n-\t{\n-\t\tkeyScheduleA{\n-\t\t\t{0, 6, 16 + 5, 16 + 7, 16 + 4, 16 + 6, 16 + 0},\n-\t\t\t{1, 4, 0, 2, 1, 3, 16 + 2},\n-\t\t\t{2, 5, 7, 6, 5, 4, 16 + 1},\n-\t\t\t{3, 7, 0xa, 9, 0xb, 8, 16 + 3},\n-\t\t},\n-\t\tkeyScheduleB{\n-\t\t\t{8, 9, 7, 6, 3},\n-\t\t\t{0xa, 0xb, 5, 4, 7},\n-\t\t\t{0xc, 0xd, 3, 2, 8},\n-\t\t\t{0xe, 0xf, 1, 0, 0xd},\n-\t\t},\n-\t},\n-}\n-\n-func (c *Cipher) keySchedule(in []byte) {\n-\tvar t [8]uint32\n-\tvar k [32]uint32\n-\n-\tfor i := 0; i < 4; i++ {\n-\t\tj := i * 4\n-\t\tt[i] = uint32(in[j])<<24 | uint32(in[j+1])<<16 | uint32(in[j+2])<<8 | uint32(in[j+3])\n-\t}\n-\n-\tx := []byte{6, 7, 4, 5}\n-\tki := 0\n-\n-\tfor half := 0; half < 2; half++ {\n-\t\tfor _, round := range schedule {\n-\t\t\tfor j := 0; j < 4; j++ {\n-\t\t\t\tvar a [7]uint8\n-\t\t\t\tcopy(a[:], round.a[j][:])\n-\t\t\t\tw := t[a[1]]\n-\t\t\t\tw ^= sBox[4][(t[a[2]>>2]>>(24-8*(a[2]&3)))&0xff]\n-\t\t\t\tw ^= sBox[5][(t[a[3]>>2]>>(24-8*(a[3]&3)))&0xff]\n-\t\t\t\tw ^= sBox[6][(t[a[4]>>2]>>(24-8*(a[4]&3)))&0xff]\n-\t\t\t\tw ^= sBox[7][(t[a[5]>>2]>>(24-8*(a[5]&3)))&0xff]\n-\t\t\t\tw ^= sBox[x[j]][(t[a[6]>>2]>>(24-8*(a[6]&3)))&0xff]\n-\t\t\t\tt[a[0]] = w\n-\t\t\t}\n-\n-\t\t\tfor j := 0; j < 4; j++ {\n-\t\t\t\tvar b [5]uint8\n-\t\t\t\tcopy(b[:], round.b[j][:])\n-\t\t\t\tw := sBox[4][(t[b[0]>>2]>>(24-8*(b[0]&3)))&0xff]\n-\t\t\t\tw ^= sBox[5][(t[b[1]>>2]>>(24-8*(b[1]&3)))&0xff]\n-\t\t\t\tw ^= sBox[6][(t[b[2]>>2]>>(24-8*(b[2]&3)))&0xff]\n-\t\t\t\tw ^= sBox[7][(t[b[3]>>2]>>(24-8*(b[3]&3)))&0xff]\n-\t\t\t\tw ^= sBox[4+j][(t[b[4]>>2]>>(24-8*(b[4]&3)))&0xff]\n-\t\t\t\tk[ki] = w\n-\t\t\t\tki++\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tfor i := 0; i < 16; i++ {\n-\t\tc.masking[i] = k[i]\n-\t\tc.rotate[i] = uint8(k[16+i] & 0x1f)\n-\t}\n-}\n-\n-// These are the three 'f' functions. See RFC 2144, section 2.2.\n-func f1(d, m uint32, r uint8) uint32 {\n-\tt := m + d\n-\tI := (t << r) | (t >> (32 - r))\n-\treturn ((sBox[0][I>>24] ^ sBox[1][(I>>16)&0xff]) - sBox[2][(I>>8)&0xff]) + sBox[3][I&0xff]\n-}\n-\n-func f2(d, m uint32, r uint8) uint32 {\n-\tt := m ^ d\n-\tI := (t << r) | (t >> (32 - r))\n-\treturn ((sBox[0][I>>24] - sBox[1][(I>>16)&0xff]) + sBox[2][(I>>8)&0xff]) ^ sBox[3][I&0xff]\n-}\n-\n-func f3(d, m uint32, r uint8) uint32 {\n-\tt := m - d\n-\tI := (t << r) | (t >> (32 - r))\n-\treturn ((sBox[0][I>>24] + sBox[1][(I>>16)&0xff]) ^ sBox[2][(I>>8)&0xff]) - sBox[3][I&0xff]\n-}\n-\n-var sBox = [8][256]uint32{\n-\t{\n-\t\t0x30fb40d4, 0x9fa0ff0b, 0x6beccd2f, 0x3f258c7a, 0x1e213f2f, 0x9c004dd3, 0x6003e540, 0xcf9fc949,\n-\t\t0xbfd4af27, 0x88bbbdb5, 0xe2034090, 0x98d09675, 0x6e63a0e0, 0x15c361d2, 0xc2e7661d, 0x22d4ff8e,\n-\t\t0x28683b6f, 0xc07fd059, 0xff2379c8, 0x775f50e2, 0x43c340d3, 0xdf2f8656, 0x887ca41a, 0xa2d2bd2d,\n-\t\t0xa1c9e0d6, 0x346c4819, 0x61b76d87, 0x22540f2f, 0x2abe32e1, 0xaa54166b, 0x22568e3a, 0xa2d341d0,\n-\t\t0x66db40c8, 0xa784392f, 0x004dff2f, 0x2db9d2de, 0x97943fac, 0x4a97c1d8, 0x527644b7, 0xb5f437a7,\n-\t\t0xb82cbaef, 0xd751d159, 0x6ff7f0ed, 0x5a097a1f, 0x827b68d0, 0x90ecf52e, 0x22b0c054, 0xbc8e5935,\n-\t\t0x4b6d2f7f, 0x50bb64a2, 0xd2664910, 0xbee5812d, 0xb7332290, 0xe93b159f, 0xb48ee411, 0x4bff345d,\n-\t\t0xfd45c240, 0xad31973f, 0xc4f6d02e, 0x55fc8165, 0xd5b1caad, 0xa1ac2dae, 0xa2d4b76d, 0xc19b0c50,\n-\t\t0x882240f2, 0x0c6e4f38, 0xa4e4bfd7, 0x4f5ba272, 0x564c1d2f, 0xc59c5319, 0xb949e354, 0xb04669fe,\n-\t\t0xb1b6ab8a, 0xc71358dd, 0x6385c545, 0x110f935d, 0x57538ad5, 0x6a390493, 0xe63d37e0, 0x2a54f6b3,\n-\t\t0x3a787d5f, 0x6276a0b5, 0x19a6fcdf, 0x7a42206a, 0x29f9d4d5, 0xf61b1891, 0xbb72275e, 0xaa508167,\n-\t\t0x38901091, 0xc6b505eb, 0x84c7cb8c, 0x2ad75a0f, 0x874a1427, 0xa2d1936b, 0x2ad286af, 0xaa56d291,\n-\t\t0xd7894360, 0x425c750d, 0x93b39e26, 0x187184c9, 0x6c00b32d, 0x73e2bb14, 0xa0bebc3c, 0x54623779,\n-\t\t0x64459eab, 0x3f328b82, 0x7718cf82, 0x59a2cea6, 0x04ee002e, 0x89fe78e6, 0x3fab0950, 0x325ff6c2,\n-\t\t0x81383f05, 0x6963c5c8, 0x76cb5ad6, 0xd49974c9, 0xca180dcf, 0x380782d5, 0xc7fa5cf6, 0x8ac31511,\n-\t\t0x35e79e13, 0x47da91d0, 0xf40f9086, 0xa7e2419e, 0x31366241, 0x051ef495, 0xaa573b04, 0x4a805d8d,\n-\t\t0x548300d0, 0x00322a3c, 0xbf64cddf, 0xba57a68e, 0x75c6372b, 0x50afd341, 0xa7c13275, 0x915a0bf5,\n-\t\t0x6b54bfab, 0x2b0b1426, 0xab4cc9d7, 0x449ccd82, 0xf7fbf265, 0xab85c5f3, 0x1b55db94, 0xaad4e324,\n-\t\t0xcfa4bd3f, 0x2deaa3e2, 0x9e204d02, 0xc8bd25ac, 0xeadf55b3, 0xd5bd9e98, 0xe31231b2, 0x2ad5ad6c,\n-\t\t0x954329de, 0xadbe4528, 0xd8710f69, 0xaa51c90f, 0xaa786bf6, 0x22513f1e, 0xaa51a79b, 0x2ad344cc,\n-\t\t0x7b5a41f0, 0xd37cfbad, 0x1b069505, 0x41ece491, 0xb4c332e6, 0x032268d4, 0xc9600acc, 0xce387e6d,\n-\t\t0xbf6bb16c, 0x6a70fb78, 0x0d03d9c9, 0xd4df39de, 0xe01063da, 0x4736f464, 0x5ad328d8, 0xb347cc96,\n-\t\t0x75bb0fc3, 0x98511bfb, 0x4ffbcc35, 0xb58bcf6a, 0xe11f0abc, 0xbfc5fe4a, 0xa70aec10, 0xac39570a,\n-\t\t0x3f04442f, 0x6188b153, 0xe0397a2e, 0x5727cb79, 0x9ceb418f, 0x1cacd68d, 0x2ad37c96, 0x0175cb9d,\n-\t\t0xc69dff09, 0xc75b65f0, 0xd9db40d8, 0xec0e7779, 0x4744ead4, 0xb11c3274, 0xdd24cb9e, 0x7e1c54bd,\n-\t\t0xf01144f9, 0xd2240eb1, 0x9675b3fd, 0xa3ac3755, 0xd47c27af, 0x51c85f4d, 0x56907596, 0xa5bb15e6,\n-\t\t0x580304f0, 0xca042cf1, 0x011a37ea, 0x8dbfaadb, 0x35ba3e4a, 0x3526ffa0, 0xc37b4d09, 0xbc306ed9,\n-\t\t0x98a52666, 0x5648f725, 0xff5e569d, 0x0ced63d0, 0x7c63b2cf, 0x700b45e1, 0xd5ea50f1, 0x85a92872,\n-\t\t0xaf1fbda7, 0xd4234870, 0xa7870bf3, 0x2d3b4d79, 0x42e04198, 0x0cd0ede7, 0x26470db8, 0xf881814c,\n-\t\t0x474d6ad7, 0x7c0c5e5c, 0xd1231959, 0x381b7298, 0xf5d2f4db, 0xab838653, 0x6e2f1e23, 0x83719c9e,\n-\t\t0xbd91e046, 0x9a56456e, 0xdc39200c, 0x20c8c571, 0x962bda1c, 0xe1e696ff, 0xb141ab08, 0x7cca89b9,\n-\t\t0x1a69e783, 0x02cc4843, 0xa2f7c579, 0x429ef47d, 0x427b169c, 0x5ac9f049, 0xdd8f0f00, 0x5c8165bf,\n-\t},\n-\t{\n-\t\t0x1f201094, 0xef0ba75b, 0x69e3cf7e, 0x393f4380, 0xfe61cf7a, 0xeec5207a, 0x55889c94, 0x72fc0651,\n-\t\t0xada7ef79, 0x4e1d7235, 0xd55a63ce, 0xde0436ba, 0x99c430ef, 0x5f0c0794, 0x18dcdb7d, 0xa1d6eff3,\n-\t\t0xa0b52f7b, 0x59e83605, 0xee15b094, 0xe9ffd909, 0xdc440086, 0xef944459, 0xba83ccb3, 0xe0c3cdfb,\n-\t\t0xd1da4181, 0x3b092ab1, 0xf997f1c1, 0xa5e6cf7b, 0x01420ddb, 0xe4e7ef5b, 0x25a1ff41, 0xe180f806,\n-\t\t0x1fc41080, 0x179bee7a, 0xd37ac6a9, 0xfe5830a4, 0x98de8b7f, 0x77e83f4e, 0x79929269, 0x24fa9f7b,\n-\t\t0xe113c85b, 0xacc40083, 0xd7503525, 0xf7ea615f, 0x62143154, 0x0d554b63, 0x5d681121, 0xc866c359,\n-\t\t0x3d63cf73, 0xcee234c0, 0xd4d87e87, 0x5c672b21, 0x071f6181, 0x39f7627f, 0x361e3084, 0xe4eb573b,\n-\t\t0x602f64a4, 0xd63acd9c, 0x1bbc4635, 0x9e81032d, 0x2701f50c, 0x99847ab4, 0xa0e3df79, 0xba6cf38c,\n-\t\t0x10843094, 0x2537a95e, 0xf46f6ffe, 0xa1ff3b1f, 0x208cfb6a, 0x8f458c74, 0xd9e0a227, 0x4ec73a34,\n-\t\t0xfc884f69, 0x3e4de8df, 0xef0e0088, 0x3559648d, 0x8a45388c, 0x1d804366, 0x721d9bfd, 0xa58684bb,\n-\t\t0xe8256333, 0x844e8212, 0x128d8098, 0xfed33fb4, 0xce280ae1, 0x27e19ba5, 0xd5a6c252, 0xe49754bd,\n-\t\t0xc5d655dd, 0xeb667064, 0x77840b4d, 0xa1b6a801, 0x84db26a9, 0xe0b56714, 0x21f043b7, 0xe5d05860,\n-\t\t0x54f03084, 0x066ff472, 0xa31aa153, 0xdadc4755, 0xb5625dbf, 0x68561be6, 0x83ca6b94, 0x2d6ed23b,\n-\t\t0xeccf01db, 0xa6d3d0ba, 0xb6803d5c, 0xaf77a709, 0x33b4a34c, 0x397bc8d6, 0x5ee22b95, 0x5f0e5304,\n-\t\t0x81ed6f61, 0x20e74364, 0xb45e1378, 0xde18639b, 0x881ca122, 0xb96726d1, 0x8049a7e8, 0x22b7da7b,\n-\t\t0x5e552d25, 0x5272d237, 0x79d2951c, 0xc60d894c, 0x488cb402, 0x1ba4fe5b, 0xa4b09f6b, 0x1ca815cf,\n-\t\t0xa20c3005, 0x8871df63, 0xb9de2fcb, 0x0cc6c9e9, 0x0beeff53, 0xe3214517, 0xb4542835, 0x9f63293c,\n-\t\t0xee41e729, 0x6e1d2d7c, 0x50045286, 0x1e6685f3, 0xf33401c6, 0x30a22c95, 0x31a70850, 0x60930f13,\n-\t\t0x73f98417, 0xa1269859, 0xec645c44, 0x52c877a9, 0xcdff33a6, 0xa02b1741, 0x7cbad9a2, 0x2180036f,\n-\t\t0x50d99c08, 0xcb3f4861, 0xc26bd765, 0x64a3f6ab, 0x80342676, 0x25a75e7b, 0xe4e6d1fc, 0x20c710e6,\n-\t\t0xcdf0b680, 0x17844d3b, 0x31eef84d, 0x7e0824e4, 0x2ccb49eb, 0x846a3bae, 0x8ff77888, 0xee5d60f6,\n-\t\t0x7af75673, 0x2fdd5cdb, 0xa11631c1, 0x30f66f43, 0xb3faec54, 0x157fd7fa, 0xef8579cc, 0xd152de58,\n-\t\t0xdb2ffd5e, 0x8f32ce19, 0x306af97a, 0x02f03ef8, 0x99319ad5, 0xc242fa0f, 0xa7e3ebb0, 0xc68e4906,\n-\t\t0xb8da230c, 0x80823028, 0xdcdef3c8, 0xd35fb171, 0x088a1bc8, 0xbec0c560, 0x61a3c9e8, 0xbca8f54d,\n-\t\t0xc72feffa, 0x22822e99, 0x82c570b4, 0xd8d94e89, 0x8b1c34bc, 0x301e16e6, 0x273be979, 0xb0ffeaa6,\n-\t\t0x61d9b8c6, 0x00b24869, 0xb7ffce3f, 0x08dc283b, 0x43daf65a, 0xf7e19798, 0x7619b72f, 0x8f1c9ba4,\n-\t\t0xdc8637a0, 0x16a7d3b1, 0x9fc393b7, 0xa7136eeb, 0xc6bcc63e, 0x1a513742, 0xef6828bc, 0x520365d6,\n-\t\t0x2d6a77ab, 0x3527ed4b, 0x821fd216, 0x095c6e2e, 0xdb92f2fb, 0x5eea29cb, 0x145892f5, 0x91584f7f,\n-\t\t0x5483697b, 0x2667a8cc, 0x85196048, 0x8c4bacea, 0x833860d4, 0x0d23e0f9, 0x6c387e8a, 0x0ae6d249,\n-\t\t0xb284600c, 0xd835731d, 0xdcb1c647, 0xac4c56ea, 0x3ebd81b3, 0x230eabb0, 0x6438bc87, 0xf0b5b1fa,\n-\t\t0x8f5ea2b3, 0xfc184642, 0x0a036b7a, 0x4fb089bd, 0x649da589, 0xa345415e, 0x5c038323, 0x3e5d3bb9,\n-\t\t0x43d79572, 0x7e6dd07c, 0x06dfdf1e, 0x6c6cc4ef, 0x7160a539, 0x73bfbe70, 0x83877605, 0x4523ecf1,\n-\t},\n-\t{\n-\t\t0x8defc240, 0x25fa5d9f, 0xeb903dbf, 0xe810c907, 0x47607fff, 0x369fe44b, 0x8c1fc644, 0xaececa90,\n-\t\t0xbeb1f9bf, 0xeefbcaea, 0xe8cf1950, 0x51df07ae, 0x920e8806, 0xf0ad0548, 0xe13c8d83, 0x927010d5,\n-\t\t0x11107d9f, 0x07647db9, 0xb2e3e4d4, 0x3d4f285e, 0xb9afa820, 0xfade82e0, 0xa067268b, 0x8272792e,\n-\t\t0x553fb2c0, 0x489ae22b, 0xd4ef9794, 0x125e3fbc, 0x21fffcee, 0x825b1bfd, 0x9255c5ed, 0x1257a240,\n-\t\t0x4e1a8302, 0xbae07fff, 0x528246e7, 0x8e57140e, 0x3373f7bf, 0x8c9f8188, 0xa6fc4ee8, 0xc982b5a5,\n-\t\t0xa8c01db7, 0x579fc264, 0x67094f31, 0xf2bd3f5f, 0x40fff7c1, 0x1fb78dfc, 0x8e6bd2c1, 0x437be59b,\n-\t\t0x99b03dbf, 0xb5dbc64b, 0x638dc0e6, 0x55819d99, 0xa197c81c, 0x4a012d6e, 0xc5884a28, 0xccc36f71,\n-\t\t0xb843c213, 0x6c0743f1, 0x8309893c, 0x0feddd5f, 0x2f7fe850, 0xd7c07f7e, 0x02507fbf, 0x5afb9a04,\n-\t\t0xa747d2d0, 0x1651192e, 0xaf70bf3e, 0x58c31380, 0x5f98302e, 0x727cc3c4, 0x0a0fb402, 0x0f7fef82,\n-\t\t0x8c96fdad, 0x5d2c2aae, 0x8ee99a49, 0x50da88b8, 0x8427f4a0, 0x1eac5790, 0x796fb449, 0x8252dc15,\n-\t\t0xefbd7d9b, 0xa672597d, 0xada840d8, 0x45f54504, 0xfa5d7403, 0xe83ec305, 0x4f91751a, 0x925669c2,\n-\t\t0x23efe941, 0xa903f12e, 0x60270df2, 0x0276e4b6, 0x94fd6574, 0x927985b2, 0x8276dbcb, 0x02778176,\n-\t\t0xf8af918d, 0x4e48f79e, 0x8f616ddf, 0xe29d840e, 0x842f7d83, 0x340ce5c8, 0x96bbb682, 0x93b4b148,\n-\t\t0xef303cab, 0x984faf28, 0x779faf9b, 0x92dc560d, 0x224d1e20, 0x8437aa88, 0x7d29dc96, 0x2756d3dc,\n-\t\t0x8b907cee, 0xb51fd240, 0xe7c07ce3, 0xe566b4a1, 0xc3e9615e, 0x3cf8209d, 0x6094d1e3, 0xcd9ca341,\n-\t\t0x5c76460e, 0x00ea983b, 0xd4d67881, 0xfd47572c, 0xf76cedd9, 0xbda8229c, 0x127dadaa, 0x438a074e,\n-\t\t0x1f97c090, 0x081bdb8a, 0x93a07ebe, 0xb938ca15, 0x97b03cff, 0x3dc2c0f8, 0x8d1ab2ec, 0x64380e51,\n-\t\t0x68cc7bfb, 0xd90f2788, 0x12490181, 0x5de5ffd4, 0xdd7ef86a, 0x76a2e214, 0xb9a40368, 0x925d958f,\n-\t\t0x4b39fffa, 0xba39aee9, 0xa4ffd30b, 0xfaf7933b, 0x6d498623, 0x193cbcfa, 0x27627545, 0x825cf47a,\n-\t\t0x61bd8ba0, 0xd11e42d1, 0xcead04f4, 0x127ea392, 0x10428db7, 0x8272a972, 0x9270c4a8, 0x127de50b,\n-\t\t0x285ba1c8, 0x3c62f44f, 0x35c0eaa5, 0xe805d231, 0x428929fb, 0xb4fcdf82, 0x4fb66a53, 0x0e7dc15b,\n-\t\t0x1f081fab, 0x108618ae, 0xfcfd086d, 0xf9ff2889, 0x694bcc11, 0x236a5cae, 0x12deca4d, 0x2c3f8cc5,\n-\t\t0xd2d02dfe, 0xf8ef5896, 0xe4cf52da, 0x95155b67, 0x494a488c, 0xb9b6a80c, 0x5c8f82bc, 0x89d36b45,\n-\t\t0x3a609437, 0xec00c9a9, 0x44715253, 0x0a874b49, 0xd773bc40, 0x7c34671c, 0x02717ef6, 0x4feb5536,\n-\t\t0xa2d02fff, 0xd2bf60c4, 0xd43f03c0, 0x50b4ef6d, 0x07478cd1, 0x006e1888, 0xa2e53f55, 0xb9e6d4bc,\n-\t\t0xa2048016, 0x97573833, 0xd7207d67, 0xde0f8f3d, 0x72f87b33, 0xabcc4f33, 0x7688c55d, 0x7b00a6b0,\n-\t\t0x947b0001, 0x570075d2, 0xf9bb88f8, 0x8942019e, 0x4264a5ff, 0x856302e0, 0x72dbd92b, 0xee971b69,\n-\t\t0x6ea22fde, 0x5f08ae2b, 0xaf7a616d, 0xe5c98767, 0xcf1febd2, 0x61efc8c2, 0xf1ac2571, 0xcc8239c2,\n-\t\t0x67214cb8, 0xb1e583d1, 0xb7dc3e62, 0x7f10bdce, 0xf90a5c38, 0x0ff0443d, 0x606e6dc6, 0x60543a49,\n-\t\t0x5727c148, 0x2be98a1d, 0x8ab41738, 0x20e1be24, 0xaf96da0f, 0x68458425, 0x99833be5, 0x600d457d,\n-\t\t0x282f9350, 0x8334b362, 0xd91d1120, 0x2b6d8da0, 0x642b1e31, 0x9c305a00, 0x52bce688, 0x1b03588a,\n-\t\t0xf7baefd5, 0x4142ed9c, 0xa4315c11, 0x83323ec5, 0xdfef4636, 0xa133c501, 0xe9d3531c, 0xee353783,\n-\t},\n-\t{\n-\t\t0x9db30420, 0x1fb6e9de, 0xa7be7bef, 0xd273a298, 0x4a4f7bdb, 0x64ad8c57, 0x85510443, 0xfa020ed1,\n-\t\t0x7e287aff, 0xe60fb663, 0x095f35a1, 0x79ebf120, 0xfd059d43, 0x6497b7b1, 0xf3641f63, 0x241e4adf,\n-\t\t0x28147f5f, 0x4fa2b8cd, 0xc9430040, 0x0cc32220, 0xfdd30b30, 0xc0a5374f, 0x1d2d00d9, 0x24147b15,\n-\t\t0xee4d111a, 0x0fca5167, 0x71ff904c, 0x2d195ffe, 0x1a05645f, 0x0c13fefe, 0x081b08ca, 0x05170121,\n-\t\t0x80530100, 0xe83e5efe, 0xac9af4f8, 0x7fe72701, 0xd2b8ee5f, 0x06df4261, 0xbb9e9b8a, 0x7293ea25,\n-\t\t0xce84ffdf, 0xf5718801, 0x3dd64b04, 0xa26f263b, 0x7ed48400, 0x547eebe6, 0x446d4ca0, 0x6cf3d6f5,\n-\t\t0x2649abdf, 0xaea0c7f5, 0x36338cc1, 0x503f7e93, 0xd3772061, 0x11b638e1, 0x72500e03, 0xf80eb2bb,\n-\t\t0xabe0502e, 0xec8d77de, 0x57971e81, 0xe14f6746, 0xc9335400, 0x6920318f, 0x081dbb99, 0xffc304a5,\n-\t\t0x4d351805, 0x7f3d5ce3, 0xa6c866c6, 0x5d5bcca9, 0xdaec6fea, 0x9f926f91, 0x9f46222f, 0x3991467d,\n-\t\t0xa5bf6d8e, 0x1143c44f, 0x43958302, 0xd0214eeb, 0x022083b8, 0x3fb6180c, 0x18f8931e, 0x281658e6,\n-\t\t0x26486e3e, 0x8bd78a70, 0x7477e4c1, 0xb506e07c, 0xf32d0a25, 0x79098b02, 0xe4eabb81, 0x28123b23,\n-\t\t0x69dead38, 0x1574ca16, 0xdf871b62, 0x211c40b7, 0xa51a9ef9, 0x0014377b, 0x041e8ac8, 0x09114003,\n-\t\t0xbd59e4d2, 0xe3d156d5, 0x4fe876d5, 0x2f91a340, 0x557be8de, 0x00eae4a7, 0x0ce5c2ec, 0x4db4bba6,\n-\t\t0xe756bdff, 0xdd3369ac, 0xec17b035, 0x06572327, 0x99afc8b0, 0x56c8c391, 0x6b65811c, 0x5e146119,\n-\t\t0x6e85cb75, 0xbe07c002, 0xc2325577, 0x893ff4ec, 0x5bbfc92d, 0xd0ec3b25, 0xb7801ab7, 0x8d6d3b24,\n-\t\t0x20c763ef, 0xc366a5fc, 0x9c382880, 0x0ace3205, 0xaac9548a, 0xeca1d7c7, 0x041afa32, 0x1d16625a,\n-\t\t0x6701902c, 0x9b757a54, 0x31d477f7, 0x9126b031, 0x36cc6fdb, 0xc70b8b46, 0xd9e66a48, 0x56e55a79,\n-\t\t0x026a4ceb, 0x52437eff, 0x2f8f76b4, 0x0df980a5, 0x8674cde3, 0xedda04eb, 0x17a9be04, 0x2c18f4df,\n-\t\t0xb7747f9d, 0xab2af7b4, 0xefc34d20, 0x2e096b7c, 0x1741a254, 0xe5b6a035, 0x213d42f6, 0x2c1c7c26,\n-\t\t0x61c2f50f, 0x6552daf9, 0xd2c231f8, 0x25130f69, 0xd8167fa2, 0x0418f2c8, 0x001a96a6, 0x0d1526ab,\n-\t\t0x63315c21, 0x5e0a72ec, 0x49bafefd, 0x187908d9, 0x8d0dbd86, 0x311170a7, 0x3e9b640c, 0xcc3e10d7,\n-\t\t0xd5cad3b6, 0x0caec388, 0xf73001e1, 0x6c728aff, 0x71eae2a1, 0x1f9af36e, 0xcfcbd12f, 0xc1de8417,\n-\t\t0xac07be6b, 0xcb44a1d8, 0x8b9b0f56, 0x013988c3, 0xb1c52fca, 0xb4be31cd, 0xd8782806, 0x12a3a4e2,\n-\t\t0x6f7de532, 0x58fd7eb6, 0xd01ee900, 0x24adffc2, 0xf4990fc5, 0x9711aac5, 0x001d7b95, 0x82e5e7d2,\n-\t\t0x109873f6, 0x00613096, 0xc32d9521, 0xada121ff, 0x29908415, 0x7fbb977f, 0xaf9eb3db, 0x29c9ed2a,\n-\t\t0x5ce2a465, 0xa730f32c, 0xd0aa3fe8, 0x8a5cc091, 0xd49e2ce7, 0x0ce454a9, 0xd60acd86, 0x015f1919,\n-\t\t0x77079103, 0xdea03af6, 0x78a8565e, 0xdee356df, 0x21f05cbe, 0x8b75e387, 0xb3c50651, 0xb8a5c3ef,\n-\t\t0xd8eeb6d2, 0xe523be77, 0xc2154529, 0x2f69efdf, 0xafe67afb, 0xf470c4b2, 0xf3e0eb5b, 0xd6cc9876,\n-\t\t0x39e4460c, 0x1fda8538, 0x1987832f, 0xca007367, 0xa99144f8, 0x296b299e, 0x492fc295, 0x9266beab,\n-\t\t0xb5676e69, 0x9bd3ddda, 0xdf7e052f, 0xdb25701c, 0x1b5e51ee, 0xf65324e6, 0x6afce36c, 0x0316cc04,\n-\t\t0x8644213e, 0xb7dc59d0, 0x7965291f, 0xccd6fd43, 0x41823979, 0x932bcdf6, 0xb657c34d, 0x4edfd282,\n-\t\t0x7ae5290c, 0x3cb9536b, 0x851e20fe, 0x9833557e, 0x13ecf0b0, 0xd3ffb372, 0x3f85c5c1, 0x0aef7ed2,\n-\t},\n-\t{\n-\t\t0x7ec90c04, 0x2c6e74b9, 0x9b0e66df, 0xa6337911, 0xb86a7fff, 0x1dd358f5, 0x44dd9d44, 0x1731167f,\n-\t\t0x08fbf1fa, 0xe7f511cc, 0xd2051b00, 0x735aba00, 0x2ab722d8, 0x386381cb, 0xacf6243a, 0x69befd7a,\n-\t\t0xe6a2e77f, 0xf0c720cd, 0xc4494816, 0xccf5c180, 0x38851640, 0x15b0a848, 0xe68b18cb, 0x4caadeff,\n-\t\t0x5f480a01, 0x0412b2aa, 0x259814fc, 0x41d0efe2, 0x4e40b48d, 0x248eb6fb, 0x8dba1cfe, 0x41a99b02,\n-\t\t0x1a550a04, 0xba8f65cb, 0x7251f4e7, 0x95a51725, 0xc106ecd7, 0x97a5980a, 0xc539b9aa, 0x4d79fe6a,\n-\t\t0xf2f3f763, 0x68af8040, 0xed0c9e56, 0x11b4958b, 0xe1eb5a88, 0x8709e6b0, 0xd7e07156, 0x4e29fea7,\n-\t\t0x6366e52d, 0x02d1c000, 0xc4ac8e05, 0x9377f571, 0x0c05372a, 0x578535f2, 0x2261be02, 0xd642a0c9,\n-\t\t0xdf13a280, 0x74b55bd2, 0x682199c0, 0xd421e5ec, 0x53fb3ce8, 0xc8adedb3, 0x28a87fc9, 0x3d959981,\n-\t\t0x5c1ff900, 0xfe38d399, 0x0c4eff0b, 0x062407ea, 0xaa2f4fb1, 0x4fb96976, 0x90c79505, 0xb0a8a774,\n-\t\t0xef55a1ff, 0xe59ca2c2, 0xa6b62d27, 0xe66a4263, 0xdf65001f, 0x0ec50966, 0xdfdd55bc, 0x29de0655,\n-\t\t0x911e739a, 0x17af8975, 0x32c7911c, 0x89f89468, 0x0d01e980, 0x524755f4, 0x03b63cc9, 0x0cc844b2,\n-\t\t0xbcf3f0aa, 0x87ac36e9, 0xe53a7426, 0x01b3d82b, 0x1a9e7449, 0x64ee2d7e, 0xcddbb1da, 0x01c94910,\n-\t\t0xb868bf80, 0x0d26f3fd, 0x9342ede7, 0x04a5c284, 0x636737b6, 0x50f5b616, 0xf24766e3, 0x8eca36c1,\n-\t\t0x136e05db, 0xfef18391, 0xfb887a37, 0xd6e7f7d4, 0xc7fb7dc9, 0x3063fcdf, 0xb6f589de, 0xec2941da,\n-\t\t0x26e46695, 0xb7566419, 0xf654efc5, 0xd08d58b7, 0x48925401, 0xc1bacb7f, 0xe5ff550f, 0xb6083049,\n-\t\t0x5bb5d0e8, 0x87d72e5a, 0xab6a6ee1, 0x223a66ce, 0xc62bf3cd, 0x9e0885f9, 0x68cb3e47, 0x086c010f,\n-\t\t0xa21de820, 0xd18b69de, 0xf3f65777, 0xfa02c3f6, 0x407edac3, 0xcbb3d550, 0x1793084d, 0xb0d70eba,\n-\t\t0x0ab378d5, 0xd951fb0c, 0xded7da56, 0x4124bbe4, 0x94ca0b56, 0x0f5755d1, 0xe0e1e56e, 0x6184b5be,\n-\t\t0x580a249f, 0x94f74bc0, 0xe327888e, 0x9f7b5561, 0xc3dc0280, 0x05687715, 0x646c6bd7, 0x44904db3,\n-\t\t0x66b4f0a3, 0xc0f1648a, 0x697ed5af, 0x49e92ff6, 0x309e374f, 0x2cb6356a, 0x85808573, 0x4991f840,\n-\t\t0x76f0ae02, 0x083be84d, 0x28421c9a, 0x44489406, 0x736e4cb8, 0xc1092910, 0x8bc95fc6, 0x7d869cf4,\n-\t\t0x134f616f, 0x2e77118d, 0xb31b2be1, 0xaa90b472, 0x3ca5d717, 0x7d161bba, 0x9cad9010, 0xaf462ba2,\n-\t\t0x9fe459d2, 0x45d34559, 0xd9f2da13, 0xdbc65487, 0xf3e4f94e, 0x176d486f, 0x097c13ea, 0x631da5c7,\n-\t\t0x445f7382, 0x175683f4, 0xcdc66a97, 0x70be0288, 0xb3cdcf72, 0x6e5dd2f3, 0x20936079, 0x459b80a5,\n-\t\t0xbe60e2db, 0xa9c23101, 0xeba5315c, 0x224e42f2, 0x1c5c1572, 0xf6721b2c, 0x1ad2fff3, 0x8c25404e,\n-\t\t0x324ed72f, 0x4067b7fd, 0x0523138e, 0x5ca3bc78, 0xdc0fd66e, 0x75922283, 0x784d6b17, 0x58ebb16e,\n-\t\t0x44094f85, 0x3f481d87, 0xfcfeae7b, 0x77b5ff76, 0x8c2302bf, 0xaaf47556, 0x5f46b02a, 0x2b092801,\n-\t\t0x3d38f5f7, 0x0ca81f36, 0x52af4a8a, 0x66d5e7c0, 0xdf3b0874, 0x95055110, 0x1b5ad7a8, 0xf61ed5ad,\n-\t\t0x6cf6e479, 0x20758184, 0xd0cefa65, 0x88f7be58, 0x4a046826, 0x0ff6f8f3, 0xa09c7f70, 0x5346aba0,\n-\t\t0x5ce96c28, 0xe176eda3, 0x6bac307f, 0x376829d2, 0x85360fa9, 0x17e3fe2a, 0x24b79767, 0xf5a96b20,\n-\t\t0xd6cd2595, 0x68ff1ebf, 0x7555442c, 0xf19f06be, 0xf9e0659a, 0xeeb9491d, 0x34010718, 0xbb30cab8,\n-\t\t0xe822fe15, 0x88570983, 0x750e6249, 0xda627e55, 0x5e76ffa8, 0xb1534546, 0x6d47de08, 0xefe9e7d4,\n-\t},\n-\t{\n-\t\t0xf6fa8f9d, 0x2cac6ce1, 0x4ca34867, 0xe2337f7c, 0x95db08e7, 0x016843b4, 0xeced5cbc, 0x325553ac,\n-\t\t0xbf9f0960, 0xdfa1e2ed, 0x83f0579d, 0x63ed86b9, 0x1ab6a6b8, 0xde5ebe39, 0xf38ff732, 0x8989b138,\n-\t\t0x33f14961, 0xc01937bd, 0xf506c6da, 0xe4625e7e, 0xa308ea99, 0x4e23e33c, 0x79cbd7cc, 0x48a14367,\n-\t\t0xa3149619, 0xfec94bd5, 0xa114174a, 0xeaa01866, 0xa084db2d, 0x09a8486f, 0xa888614a, 0x2900af98,\n-\t\t0x01665991, 0xe1992863, 0xc8f30c60, 0x2e78ef3c, 0xd0d51932, 0xcf0fec14, 0xf7ca07d2, 0xd0a82072,\n-\t\t0xfd41197e, 0x9305a6b0, 0xe86be3da, 0x74bed3cd, 0x372da53c, 0x4c7f4448, 0xdab5d440, 0x6dba0ec3,\n-\t\t0x083919a7, 0x9fbaeed9, 0x49dbcfb0, 0x4e670c53, 0x5c3d9c01, 0x64bdb941, 0x2c0e636a, 0xba7dd9cd,\n-\t\t0xea6f7388, 0xe70bc762, 0x35f29adb, 0x5c4cdd8d, 0xf0d48d8c, 0xb88153e2, 0x08a19866, 0x1ae2eac8,\n-\t\t0x284caf89, 0xaa928223, 0x9334be53, 0x3b3a21bf, 0x16434be3, 0x9aea3906, 0xefe8c36e, 0xf890cdd9,\n-\t\t0x80226dae, 0xc340a4a3, 0xdf7e9c09, 0xa694a807, 0x5b7c5ecc, 0x221db3a6, 0x9a69a02f, 0x68818a54,\n-\t\t0xceb2296f, 0x53c0843a, 0xfe893655, 0x25bfe68a, 0xb4628abc, 0xcf222ebf, 0x25ac6f48, 0xa9a99387,\n-\t\t0x53bddb65, 0xe76ffbe7, 0xe967fd78, 0x0ba93563, 0x8e342bc1, 0xe8a11be9, 0x4980740d, 0xc8087dfc,\n-\t\t0x8de4bf99, 0xa11101a0, 0x7fd37975, 0xda5a26c0, 0xe81f994f, 0x9528cd89, 0xfd339fed, 0xb87834bf,\n-\t\t0x5f04456d, 0x22258698, 0xc9c4c83b, 0x2dc156be, 0x4f628daa, 0x57f55ec5, 0xe2220abe, 0xd2916ebf,\n-\t\t0x4ec75b95, 0x24f2c3c0, 0x42d15d99, 0xcd0d7fa0, 0x7b6e27ff, 0xa8dc8af0, 0x7345c106, 0xf41e232f,\n-\t\t0x35162386, 0xe6ea8926, 0x3333b094, 0x157ec6f2, 0x372b74af, 0x692573e4, 0xe9a9d848, 0xf3160289,\n-\t\t0x3a62ef1d, 0xa787e238, 0xf3a5f676, 0x74364853, 0x20951063, 0x4576698d, 0xb6fad407, 0x592af950,\n-\t\t0x36f73523, 0x4cfb6e87, 0x7da4cec0, 0x6c152daa, 0xcb0396a8, 0xc50dfe5d, 0xfcd707ab, 0x0921c42f,\n-\t\t0x89dff0bb, 0x5fe2be78, 0x448f4f33, 0x754613c9, 0x2b05d08d, 0x48b9d585, 0xdc049441, 0xc8098f9b,\n-\t\t0x7dede786, 0xc39a3373, 0x42410005, 0x6a091751, 0x0ef3c8a6, 0x890072d6, 0x28207682, 0xa9a9f7be,\n-\t\t0xbf32679d, 0xd45b5b75, 0xb353fd00, 0xcbb0e358, 0x830f220a, 0x1f8fb214, 0xd372cf08, 0xcc3c4a13,\n-\t\t0x8cf63166, 0x061c87be, 0x88c98f88, 0x6062e397, 0x47cf8e7a, 0xb6c85283, 0x3cc2acfb, 0x3fc06976,\n-\t\t0x4e8f0252, 0x64d8314d, 0xda3870e3, 0x1e665459, 0xc10908f0, 0x513021a5, 0x6c5b68b7, 0x822f8aa0,\n-\t\t0x3007cd3e, 0x74719eef, 0xdc872681, 0x073340d4, 0x7e432fd9, 0x0c5ec241, 0x8809286c, 0xf592d891,\n-\t\t0x08a930f6, 0x957ef305, 0xb7fbffbd, 0xc266e96f, 0x6fe4ac98, 0xb173ecc0, 0xbc60b42a, 0x953498da,\n-\t\t0xfba1ae12, 0x2d4bd736, 0x0f25faab, 0xa4f3fceb, 0xe2969123, 0x257f0c3d, 0x9348af49, 0x361400bc,\n-\t\t0xe8816f4a, 0x3814f200, 0xa3f94043, 0x9c7a54c2, 0xbc704f57, 0xda41e7f9, 0xc25ad33a, 0x54f4a084,\n-\t\t0xb17f5505, 0x59357cbe, 0xedbd15c8, 0x7f97c5ab, 0xba5ac7b5, 0xb6f6deaf, 0x3a479c3a, 0x5302da25,\n-\t\t0x653d7e6a, 0x54268d49, 0x51a477ea, 0x5017d55b, 0xd7d25d88, 0x44136c76, 0x0404a8c8, 0xb8e5a121,\n-\t\t0xb81a928a, 0x60ed5869, 0x97c55b96, 0xeaec991b, 0x29935913, 0x01fdb7f1, 0x088e8dfa, 0x9ab6f6f5,\n-\t\t0x3b4cbf9f, 0x4a5de3ab, 0xe6051d35, 0xa0e1d855, 0xd36b4cf1, 0xf544edeb, 0xb0e93524, 0xbebb8fbd,\n-\t\t0xa2d762cf, 0x49c92f54, 0x38b5f331, 0x7128a454, 0x48392905, 0xa65b1db8, 0x851c97bd, 0xd675cf2f,\n-\t},\n-\t{\n-\t\t0x85e04019, 0x332bf567, 0x662dbfff, 0xcfc65693, 0x2a8d7f6f, 0xab9bc912, 0xde6008a1, 0x2028da1f,\n-\t\t0x0227bce7, 0x4d642916, 0x18fac300, 0x50f18b82, 0x2cb2cb11, 0xb232e75c, 0x4b3695f2, 0xb28707de,\n-\t\t0xa05fbcf6, 0xcd4181e9, 0xe150210c, 0xe24ef1bd, 0xb168c381, 0xfde4e789, 0x5c79b0d8, 0x1e8bfd43,\n-\t\t0x4d495001, 0x38be4341, 0x913cee1d, 0x92a79c3f, 0x089766be, 0xbaeeadf4, 0x1286becf, 0xb6eacb19,\n-\t\t0x2660c200, 0x7565bde4, 0x64241f7a, 0x8248dca9, 0xc3b3ad66, 0x28136086, 0x0bd8dfa8, 0x356d1cf2,\n-\t\t0x107789be, 0xb3b2e9ce, 0x0502aa8f, 0x0bc0351e, 0x166bf52a, 0xeb12ff82, 0xe3486911, 0xd34d7516,\n-\t\t0x4e7b3aff, 0x5f43671b, 0x9cf6e037, 0x4981ac83, 0x334266ce, 0x8c9341b7, 0xd0d854c0, 0xcb3a6c88,\n-\t\t0x47bc2829, 0x4725ba37, 0xa66ad22b, 0x7ad61f1e, 0x0c5cbafa, 0x4437f107, 0xb6e79962, 0x42d2d816,\n-\t\t0x0a961288, 0xe1a5c06e, 0x13749e67, 0x72fc081a, 0xb1d139f7, 0xf9583745, 0xcf19df58, 0xbec3f756,\n-\t\t0xc06eba30, 0x07211b24, 0x45c28829, 0xc95e317f, 0xbc8ec511, 0x38bc46e9, 0xc6e6fa14, 0xbae8584a,\n-\t\t0xad4ebc46, 0x468f508b, 0x7829435f, 0xf124183b, 0x821dba9f, 0xaff60ff4, 0xea2c4e6d, 0x16e39264,\n-\t\t0x92544a8b, 0x009b4fc3, 0xaba68ced, 0x9ac96f78, 0x06a5b79a, 0xb2856e6e, 0x1aec3ca9, 0xbe838688,\n-\t\t0x0e0804e9, 0x55f1be56, 0xe7e5363b, 0xb3a1f25d, 0xf7debb85, 0x61fe033c, 0x16746233, 0x3c034c28,\n-\t\t0xda6d0c74, 0x79aac56c, 0x3ce4e1ad, 0x51f0c802, 0x98f8f35a, 0x1626a49f, 0xeed82b29, 0x1d382fe3,\n-\t\t0x0c4fb99a, 0xbb325778, 0x3ec6d97b, 0x6e77a6a9, 0xcb658b5c, 0xd45230c7, 0x2bd1408b, 0x60c03eb7,\n-\t\t0xb9068d78, 0xa33754f4, 0xf430c87d, 0xc8a71302, 0xb96d8c32, 0xebd4e7be, 0xbe8b9d2d, 0x7979fb06,\n-\t\t0xe7225308, 0x8b75cf77, 0x11ef8da4, 0xe083c858, 0x8d6b786f, 0x5a6317a6, 0xfa5cf7a0, 0x5dda0033,\n-\t\t0xf28ebfb0, 0xf5b9c310, 0xa0eac280, 0x08b9767a, 0xa3d9d2b0, 0x79d34217, 0x021a718d, 0x9ac6336a,\n-\t\t0x2711fd60, 0x438050e3, 0x069908a8, 0x3d7fedc4, 0x826d2bef, 0x4eeb8476, 0x488dcf25, 0x36c9d566,\n-\t\t0x28e74e41, 0xc2610aca, 0x3d49a9cf, 0xbae3b9df, 0xb65f8de6, 0x92aeaf64, 0x3ac7d5e6, 0x9ea80509,\n-\t\t0xf22b017d, 0xa4173f70, 0xdd1e16c3, 0x15e0d7f9, 0x50b1b887, 0x2b9f4fd5, 0x625aba82, 0x6a017962,\n-\t\t0x2ec01b9c, 0x15488aa9, 0xd716e740, 0x40055a2c, 0x93d29a22, 0xe32dbf9a, 0x058745b9, 0x3453dc1e,\n-\t\t0xd699296e, 0x496cff6f, 0x1c9f4986, 0xdfe2ed07, 0xb87242d1, 0x19de7eae, 0x053e561a, 0x15ad6f8c,\n-\t\t0x66626c1c, 0x7154c24c, 0xea082b2a, 0x93eb2939, 0x17dcb0f0, 0x58d4f2ae, 0x9ea294fb, 0x52cf564c,\n-\t\t0x9883fe66, 0x2ec40581, 0x763953c3, 0x01d6692e, 0xd3a0c108, 0xa1e7160e, 0xe4f2dfa6, 0x693ed285,\n-\t\t0x74904698, 0x4c2b0edd, 0x4f757656, 0x5d393378, 0xa132234f, 0x3d321c5d, 0xc3f5e194, 0x4b269301,\n-\t\t0xc79f022f, 0x3c997e7e, 0x5e4f9504, 0x3ffafbbd, 0x76f7ad0e, 0x296693f4, 0x3d1fce6f, 0xc61e45be,\n-\t\t0xd3b5ab34, 0xf72bf9b7, 0x1b0434c0, 0x4e72b567, 0x5592a33d, 0xb5229301, 0xcfd2a87f, 0x60aeb767,\n-\t\t0x1814386b, 0x30bcc33d, 0x38a0c07d, 0xfd1606f2, 0xc363519b, 0x589dd390, 0x5479f8e6, 0x1cb8d647,\n-\t\t0x97fd61a9, 0xea7759f4, 0x2d57539d, 0x569a58cf, 0xe84e63ad, 0x462e1b78, 0x6580f87e, 0xf3817914,\n-\t\t0x91da55f4, 0x40a230f3, 0xd1988f35, 0xb6e318d2, 0x3ffa50bc, 0x3d40f021, 0xc3c0bdae, 0x4958c24c,\n-\t\t0x518f36b2, 0x84b1d370, 0x0fedce83, 0x878ddada, 0xf2a279c7, 0x94e01be8, 0x90716f4b, 0x954b8aa3,\n-\t},\n-\t{\n-\t\t0xe216300d, 0xbbddfffc, 0xa7ebdabd, 0x35648095, 0x7789f8b7, 0xe6c1121b, 0x0e241600, 0x052ce8b5,\n-\t\t0x11a9cfb0, 0xe5952f11, 0xece7990a, 0x9386d174, 0x2a42931c, 0x76e38111, 0xb12def3a, 0x37ddddfc,\n-\t\t0xde9adeb1, 0x0a0cc32c, 0xbe197029, 0x84a00940, 0xbb243a0f, 0xb4d137cf, 0xb44e79f0, 0x049eedfd,\n-\t\t0x0b15a15d, 0x480d3168, 0x8bbbde5a, 0x669ded42, 0xc7ece831, 0x3f8f95e7, 0x72df191b, 0x7580330d,\n-\t\t0x94074251, 0x5c7dcdfa, 0xabbe6d63, 0xaa402164, 0xb301d40a, 0x02e7d1ca, 0x53571dae, 0x7a3182a2,\n-\t\t0x12a8ddec, 0xfdaa335d, 0x176f43e8, 0x71fb46d4, 0x38129022, 0xce949ad4, 0xb84769ad, 0x965bd862,\n-\t\t0x82f3d055, 0x66fb9767, 0x15b80b4e, 0x1d5b47a0, 0x4cfde06f, 0xc28ec4b8, 0x57e8726e, 0x647a78fc,\n-\t\t0x99865d44, 0x608bd593, 0x6c200e03, 0x39dc5ff6, 0x5d0b00a3, 0xae63aff2, 0x7e8bd632, 0x70108c0c,\n-\t\t0xbbd35049, 0x2998df04, 0x980cf42a, 0x9b6df491, 0x9e7edd53, 0x06918548, 0x58cb7e07, 0x3b74ef2e,\n-\t\t0x522fffb1, 0xd24708cc, 0x1c7e27cd, 0xa4eb215b, 0x3cf1d2e2, 0x19b47a38, 0x424f7618, 0x35856039,\n-\t\t0x9d17dee7, 0x27eb35e6, 0xc9aff67b, 0x36baf5b8, 0x09c467cd, 0xc18910b1, 0xe11dbf7b, 0x06cd1af8,\n-\t\t0x7170c608, 0x2d5e3354, 0xd4de495a, 0x64c6d006, 0xbcc0c62c, 0x3dd00db3, 0x708f8f34, 0x77d51b42,\n-\t\t0x264f620f, 0x24b8d2bf, 0x15c1b79e, 0x46a52564, 0xf8d7e54e, 0x3e378160, 0x7895cda5, 0x859c15a5,\n-\t\t0xe6459788, 0xc37bc75f, 0xdb07ba0c, 0x0676a3ab, 0x7f229b1e, 0x31842e7b, 0x24259fd7, 0xf8bef472,\n-\t\t0x835ffcb8, 0x6df4c1f2, 0x96f5b195, 0xfd0af0fc, 0xb0fe134c, 0xe2506d3d, 0x4f9b12ea, 0xf215f225,\n-\t\t0xa223736f, 0x9fb4c428, 0x25d04979, 0x34c713f8, 0xc4618187, 0xea7a6e98, 0x7cd16efc, 0x1436876c,\n-\t\t0xf1544107, 0xbedeee14, 0x56e9af27, 0xa04aa441, 0x3cf7c899, 0x92ecbae6, 0xdd67016d, 0x151682eb,\n-\t\t0xa842eedf, 0xfdba60b4, 0xf1907b75, 0x20e3030f, 0x24d8c29e, 0xe139673b, 0xefa63fb8, 0x71873054,\n-\t\t0xb6f2cf3b, 0x9f326442, 0xcb15a4cc, 0xb01a4504, 0xf1e47d8d, 0x844a1be5, 0xbae7dfdc, 0x42cbda70,\n-\t\t0xcd7dae0a, 0x57e85b7a, 0xd53f5af6, 0x20cf4d8c, 0xcea4d428, 0x79d130a4, 0x3486ebfb, 0x33d3cddc,\n-\t\t0x77853b53, 0x37effcb5, 0xc5068778, 0xe580b3e6, 0x4e68b8f4, 0xc5c8b37e, 0x0d809ea2, 0x398feb7c,\n-\t\t0x132a4f94, 0x43b7950e, 0x2fee7d1c, 0x223613bd, 0xdd06caa2, 0x37df932b, 0xc4248289, 0xacf3ebc3,\n-\t\t0x5715f6b7, 0xef3478dd, 0xf267616f, 0xc148cbe4, 0x9052815e, 0x5e410fab, 0xb48a2465, 0x2eda7fa4,\n-\t\t0xe87b40e4, 0xe98ea084, 0x5889e9e1, 0xefd390fc, 0xdd07d35b, 0xdb485694, 0x38d7e5b2, 0x57720101,\n-\t\t0x730edebc, 0x5b643113, 0x94917e4f, 0x503c2fba, 0x646f1282, 0x7523d24a, 0xe0779695, 0xf9c17a8f,\n-\t\t0x7a5b2121, 0xd187b896, 0x29263a4d, 0xba510cdf, 0x81f47c9f, 0xad1163ed, 0xea7b5965, 0x1a00726e,\n-\t\t0x11403092, 0x00da6d77, 0x4a0cdd61, 0xad1f4603, 0x605bdfb0, 0x9eedc364, 0x22ebe6a8, 0xcee7d28a,\n-\t\t0xa0e736a0, 0x5564a6b9, 0x10853209, 0xc7eb8f37, 0x2de705ca, 0x8951570f, 0xdf09822b, 0xbd691a6c,\n-\t\t0xaa12e4f2, 0x87451c0f, 0xe0f6a27a, 0x3ada4819, 0x4cf1764f, 0x0d771c2b, 0x67cdb156, 0x350d8384,\n-\t\t0x5938fa0f, 0x42399ef3, 0x36997b07, 0x0e84093d, 0x4aa93e61, 0x8360d87b, 0x1fa98b0c, 0x1149382c,\n-\t\t0xe97625a5, 0x0614d1b7, 0x0e25244b, 0x0c768347, 0x589e8d82, 0x0d2059d1, 0xa466bb1e, 0xf8da0a82,\n-\t\t0x04f19130, 0xba6e4ec0, 0x99265164, 0x1ee7230d, 0x50b2ad80, 0xeaee6801, 0x8db2a283, 0xea8bf59e,\n-\t},\n-}"}, {"sha": "5f7025ff24cb7aba2d598a8b27a643ab6492081a", "filename": "libgo/go/crypto/cast5/cast5_test.go", "status": "removed", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fcast5%2Fcast5_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fcast5%2Fcast5_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcast5%2Fcast5_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,104 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package cast5\n-\n-import (\n-\t\"bytes\"\n-\t\"encoding/hex\"\n-\t\"testing\"\n-)\n-\n-// This test vector is taken from RFC 2144, App B.1.\n-// Since the other two test vectors are for reduced-round variants, we can't\n-// use them.\n-var basicTests = []struct {\n-\tkey, plainText, cipherText string\n-}{\n-\t{\n-\t\t\"0123456712345678234567893456789a\",\n-\t\t\"0123456789abcdef\",\n-\t\t\"238b4fe5847e44b2\",\n-\t},\n-}\n-\n-func TestBasic(t *testing.T) {\n-\tfor i, test := range basicTests {\n-\t\tkey, _ := hex.DecodeString(test.key)\n-\t\tplainText, _ := hex.DecodeString(test.plainText)\n-\t\texpected, _ := hex.DecodeString(test.cipherText)\n-\n-\t\tc, err := NewCipher(key)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"#%d: failed to create Cipher: %s\", i, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tvar cipherText [BlockSize]byte\n-\t\tc.Encrypt(cipherText[:], plainText)\n-\t\tif !bytes.Equal(cipherText[:], expected) {\n-\t\t\tt.Errorf(\"#%d: got:%x want:%x\", i, cipherText, expected)\n-\t\t}\n-\n-\t\tvar plainTextAgain [BlockSize]byte\n-\t\tc.Decrypt(plainTextAgain[:], cipherText[:])\n-\t\tif !bytes.Equal(plainTextAgain[:], plainText) {\n-\t\t\tt.Errorf(\"#%d: got:%x want:%x\", i, plainTextAgain, plainText)\n-\t\t}\n-\t}\n-}\n-\n-// TestFull performs the test specified in RFC 2144, App B.2.\n-// However, due to the length of time taken, it's disabled here and a more\n-// limited version is included, below.\n-func TestFull(t *testing.T) {\n-\t// This is too slow for normal testing\n-\treturn\n-\n-\ta, b := iterate(1000000)\n-\n-\tconst expectedA = \"eea9d0a249fd3ba6b3436fb89d6dca92\"\n-\tconst expectedB = \"b2c95eb00c31ad7180ac05b8e83d696e\"\n-\n-\tif hex.EncodeToString(a) != expectedA {\n-\t\tt.Errorf(\"a: got:%x want:%s\", a, expectedA)\n-\t}\n-\tif hex.EncodeToString(b) != expectedB {\n-\t\tt.Errorf(\"b: got:%x want:%s\", b, expectedB)\n-\t}\n-}\n-\n-func iterate(iterations int) ([]byte, []byte) {\n-\tconst initValueHex = \"0123456712345678234567893456789a\"\n-\n-\tinitValue, _ := hex.DecodeString(initValueHex)\n-\n-\tvar a, b [16]byte\n-\tcopy(a[:], initValue)\n-\tcopy(b[:], initValue)\n-\n-\tfor i := 0; i < iterations; i++ {\n-\t\tc, _ := NewCipher(b[:])\n-\t\tc.Encrypt(a[:8], a[:8])\n-\t\tc.Encrypt(a[8:], a[8:])\n-\t\tc, _ = NewCipher(a[:])\n-\t\tc.Encrypt(b[:8], b[:8])\n-\t\tc.Encrypt(b[8:], b[8:])\n-\t}\n-\n-\treturn a[:], b[:]\n-}\n-\n-func TestLimited(t *testing.T) {\n-\ta, b := iterate(1000)\n-\n-\tconst expectedA = \"23f73b14b02a2ad7dfb9f2c35644798d\"\n-\tconst expectedB = \"e5bf37eff14c456a40b21ce369370a9f\"\n-\n-\tif hex.EncodeToString(a) != expectedA {\n-\t\tt.Errorf(\"a: got:%x want:%s\", a, expectedA)\n-\t}\n-\tif hex.EncodeToString(b) != expectedB {\n-\t\tt.Errorf(\"b: got:%x want:%s\", b, expectedB)\n-\t}\n-}"}, {"sha": "7aaad1ca19954e53f07cebd14426795125efafeb", "filename": "libgo/go/crypto/dsa/dsa.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -35,11 +35,11 @@ func (invalidPublicKeyError) Error() string {\n \treturn \"crypto/dsa: invalid public key\"\n }\n \n-// InvalidPublicKeyError results when a public key is not usable by this code.\n+// ErrInvalidPublicKey results when a public key is not usable by this code.\n // FIPS is quite strict about the format of DSA keys, but other code may be\n // less so. Thus, when using keys which may have been generated by other code,\n // this error must be handled.\n-var InvalidPublicKeyError = invalidPublicKeyError(0)\n+var ErrInvalidPublicKey error = invalidPublicKeyError(0)\n \n // ParameterSizes is a enumeration of the acceptable bit lengths of the primes\n // in a set of DSA parameters. See FIPS 186-3, section 4.2.\n@@ -194,7 +194,7 @@ func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err err\n \n \tn := priv.Q.BitLen()\n \tif n&7 != 0 {\n-\t\terr = InvalidPublicKeyError\n+\t\terr = ErrInvalidPublicKey\n \t\treturn\n \t}\n \tn >>= 3"}, {"sha": "c5f7c57d16e05a7a1c817ad01e01ac4780b3d5ac", "filename": "libgo/go/crypto/md4/md4.go", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,118 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package md4 implements the MD4 hash algorithm as defined in RFC 1320.\n-package md4\n-\n-import (\n-\t\"crypto\"\n-\t\"hash\"\n-)\n-\n-func init() {\n-\tcrypto.RegisterHash(crypto.MD4, New)\n-}\n-\n-// The size of an MD4 checksum in bytes.\n-const Size = 16\n-\n-// The blocksize of MD4 in bytes.\n-const BlockSize = 64\n-\n-const (\n-\t_Chunk = 64\n-\t_Init0 = 0x67452301\n-\t_Init1 = 0xEFCDAB89\n-\t_Init2 = 0x98BADCFE\n-\t_Init3 = 0x10325476\n-)\n-\n-// digest represents the partial evaluation of a checksum.\n-type digest struct {\n-\ts   [4]uint32\n-\tx   [_Chunk]byte\n-\tnx  int\n-\tlen uint64\n-}\n-\n-func (d *digest) Reset() {\n-\td.s[0] = _Init0\n-\td.s[1] = _Init1\n-\td.s[2] = _Init2\n-\td.s[3] = _Init3\n-\td.nx = 0\n-\td.len = 0\n-}\n-\n-// New returns a new hash.Hash computing the MD4 checksum.\n-func New() hash.Hash {\n-\td := new(digest)\n-\td.Reset()\n-\treturn d\n-}\n-\n-func (d *digest) Size() int { return Size }\n-\n-func (d *digest) BlockSize() int { return BlockSize }\n-\n-func (d *digest) Write(p []byte) (nn int, err error) {\n-\tnn = len(p)\n-\td.len += uint64(nn)\n-\tif d.nx > 0 {\n-\t\tn := len(p)\n-\t\tif n > _Chunk-d.nx {\n-\t\t\tn = _Chunk - d.nx\n-\t\t}\n-\t\tfor i := 0; i < n; i++ {\n-\t\t\td.x[d.nx+i] = p[i]\n-\t\t}\n-\t\td.nx += n\n-\t\tif d.nx == _Chunk {\n-\t\t\t_Block(d, d.x[0:])\n-\t\t\td.nx = 0\n-\t\t}\n-\t\tp = p[n:]\n-\t}\n-\tn := _Block(d, p)\n-\tp = p[n:]\n-\tif len(p) > 0 {\n-\t\td.nx = copy(d.x[:], p)\n-\t}\n-\treturn\n-}\n-\n-func (d0 *digest) Sum(in []byte) []byte {\n-\t// Make a copy of d0, so that caller can keep writing and summing.\n-\td := new(digest)\n-\t*d = *d0\n-\n-\t// Padding.  Add a 1 bit and 0 bits until 56 bytes mod 64.\n-\tlen := d.len\n-\tvar tmp [64]byte\n-\ttmp[0] = 0x80\n-\tif len%64 < 56 {\n-\t\td.Write(tmp[0 : 56-len%64])\n-\t} else {\n-\t\td.Write(tmp[0 : 64+56-len%64])\n-\t}\n-\n-\t// Length in bits.\n-\tlen <<= 3\n-\tfor i := uint(0); i < 8; i++ {\n-\t\ttmp[i] = byte(len >> (8 * i))\n-\t}\n-\td.Write(tmp[0:8])\n-\n-\tif d.nx != 0 {\n-\t\tpanic(\"d.nx != 0\")\n-\t}\n-\n-\tfor _, s := range d.s {\n-\t\tin = append(in, byte(s>>0))\n-\t\tin = append(in, byte(s>>8))\n-\t\tin = append(in, byte(s>>16))\n-\t\tin = append(in, byte(s>>24))\n-\t}\n-\treturn in\n-}"}, {"sha": "b56edd7875d8b6655cc07ccec0f65d8171d74680", "filename": "libgo/go/crypto/md4/md4_test.go", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,71 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package md4\n-\n-import (\n-\t\"fmt\"\n-\t\"io\"\n-\t\"testing\"\n-)\n-\n-type md4Test struct {\n-\tout string\n-\tin  string\n-}\n-\n-var golden = []md4Test{\n-\t{\"31d6cfe0d16ae931b73c59d7e0c089c0\", \"\"},\n-\t{\"bde52cb31de33e46245e05fbdbd6fb24\", \"a\"},\n-\t{\"ec388dd78999dfc7cf4632465693b6bf\", \"ab\"},\n-\t{\"a448017aaf21d8525fc10ae87aa6729d\", \"abc\"},\n-\t{\"41decd8f579255c5200f86a4bb3ba740\", \"abcd\"},\n-\t{\"9803f4a34e8eb14f96adba49064a0c41\", \"abcde\"},\n-\t{\"804e7f1c2586e50b49ac65db5b645131\", \"abcdef\"},\n-\t{\"752f4adfe53d1da0241b5bc216d098fc\", \"abcdefg\"},\n-\t{\"ad9daf8d49d81988590a6f0e745d15dd\", \"abcdefgh\"},\n-\t{\"1e4e28b05464316b56402b3815ed2dfd\", \"abcdefghi\"},\n-\t{\"dc959c6f5d6f9e04e4380777cc964b3d\", \"abcdefghij\"},\n-\t{\"1b5701e265778898ef7de5623bbe7cc0\", \"Discard medicine more than two years old.\"},\n-\t{\"d7f087e090fe7ad4a01cb59dacc9a572\", \"He who has a shady past knows that nice guys finish last.\"},\n-\t{\"a6f8fd6df617c72837592fc3570595c9\", \"I wouldn't marry him with a ten foot pole.\"},\n-\t{\"c92a84a9526da8abc240c05d6b1a1ce0\", \"Free! Free!/A trip/to Mars/for 900/empty jars/Burma Shave\"},\n-\t{\"f6013160c4dcb00847069fee3bb09803\", \"The days of the digital watch are numbered.  -Tom Stoppard\"},\n-\t{\"2c3bb64f50b9107ed57640fe94bec09f\", \"Nepal premier won't resign.\"},\n-\t{\"45b7d8a32c7806f2f7f897332774d6e4\", \"For every action there is an equal and opposite government program.\"},\n-\t{\"b5b4f9026b175c62d7654bdc3a1cd438\", \"His money is twice tainted: 'taint yours and 'taint mine.\"},\n-\t{\"caf44e80f2c20ce19b5ba1cab766e7bd\", \"There is no reason for any individual to have a computer in their home. -Ken Olsen, 1977\"},\n-\t{\"191fae6707f496aa54a6bce9f2ecf74d\", \"It's a tiny change to the code and not completely disgusting. - Bob Manchek\"},\n-\t{\"9ddc753e7a4ccee6081cd1b45b23a834\", \"size:  a.out:  bad magic\"},\n-\t{\"8d050f55b1cadb9323474564be08a521\", \"The major problem is with sendmail.  -Mark Horton\"},\n-\t{\"ad6e2587f74c3e3cc19146f6127fa2e3\", \"Give me a rock, paper and scissors and I will move the world.  CCFestoon\"},\n-\t{\"1d616d60a5fabe85589c3f1566ca7fca\", \"If the enemy is within range, then so are you.\"},\n-\t{\"aec3326a4f496a2ced65a1963f84577f\", \"It's well we cannot hear the screams/That we create in others' dreams.\"},\n-\t{\"77b4fd762d6b9245e61c50bf6ebf118b\", \"You remind me of a TV show, but that's all right: I watch it anyway.\"},\n-\t{\"e8f48c726bae5e516f6ddb1a4fe62438\", \"C is as portable as Stonehedge!!\"},\n-\t{\"a3a84366e7219e887423b01f9be7166e\", \"Even if I could be Shakespeare, I think I should still choose to be Faraday. - A. Huxley\"},\n-\t{\"a6b7aa35157e984ef5d9b7f32e5fbb52\", \"The fugacity of a constituent in a mixture of gases at a given temperature is proportional to its mole fraction.  Lewis-Randall Rule\"},\n-\t{\"75661f0545955f8f9abeeb17845f3fd6\", \"How can you write a big system without C++?  -Paul Glick\"},\n-}\n-\n-func TestGolden(t *testing.T) {\n-\tfor i := 0; i < len(golden); i++ {\n-\t\tg := golden[i]\n-\t\tc := New()\n-\t\tfor j := 0; j < 3; j++ {\n-\t\t\tif j < 2 {\n-\t\t\t\tio.WriteString(c, g.in)\n-\t\t\t} else {\n-\t\t\t\tio.WriteString(c, g.in[0:len(g.in)/2])\n-\t\t\t\tc.Sum(nil)\n-\t\t\t\tio.WriteString(c, g.in[len(g.in)/2:])\n-\t\t\t}\n-\t\t\ts := fmt.Sprintf(\"%x\", c.Sum(nil))\n-\t\t\tif s != g.out {\n-\t\t\t\tt.Fatalf(\"md4[%d](%s) = %s want %s\", j, g.in, s, g.out)\n-\t\t\t}\n-\t\t\tc.Reset()\n-\t\t}\n-\t}\n-}"}, {"sha": "3fed475f3f600440f0e99b91dffbb9663ae0056c", "filename": "libgo/go/crypto/md4/md4block.go", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4block.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4block.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4block.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,89 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// MD4 block step.\n-// In its own file so that a faster assembly or C version\n-// can be substituted easily.\n-\n-package md4\n-\n-var shift1 = []uint{3, 7, 11, 19}\n-var shift2 = []uint{3, 5, 9, 13}\n-var shift3 = []uint{3, 9, 11, 15}\n-\n-var xIndex2 = []uint{0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15}\n-var xIndex3 = []uint{0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}\n-\n-func _Block(dig *digest, p []byte) int {\n-\ta := dig.s[0]\n-\tb := dig.s[1]\n-\tc := dig.s[2]\n-\td := dig.s[3]\n-\tn := 0\n-\tvar X [16]uint32\n-\tfor len(p) >= _Chunk {\n-\t\taa, bb, cc, dd := a, b, c, d\n-\n-\t\tj := 0\n-\t\tfor i := 0; i < 16; i++ {\n-\t\t\tX[i] = uint32(p[j]) | uint32(p[j+1])<<8 | uint32(p[j+2])<<16 | uint32(p[j+3])<<24\n-\t\t\tj += 4\n-\t\t}\n-\n-\t\t// If this needs to be made faster in the future,\n-\t\t// the usual trick is to unroll each of these\n-\t\t// loops by a factor of 4; that lets you replace\n-\t\t// the shift[] lookups with constants and,\n-\t\t// with suitable variable renaming in each\n-\t\t// unrolled body, delete the a, b, c, d = d, a, b, c\n-\t\t// (or you can let the optimizer do the renaming).\n-\t\t//\n-\t\t// The index variables are uint so that % by a power\n-\t\t// of two can be optimized easily by a compiler.\n-\n-\t\t// Round 1.\n-\t\tfor i := uint(0); i < 16; i++ {\n-\t\t\tx := i\n-\t\t\ts := shift1[i%4]\n-\t\t\tf := ((c ^ d) & b) ^ d\n-\t\t\ta += f + X[x]\n-\t\t\ta = a<<s | a>>(32-s)\n-\t\t\ta, b, c, d = d, a, b, c\n-\t\t}\n-\n-\t\t// Round 2.\n-\t\tfor i := uint(0); i < 16; i++ {\n-\t\t\tx := xIndex2[i]\n-\t\t\ts := shift2[i%4]\n-\t\t\tg := (b & c) | (b & d) | (c & d)\n-\t\t\ta += g + X[x] + 0x5a827999\n-\t\t\ta = a<<s | a>>(32-s)\n-\t\t\ta, b, c, d = d, a, b, c\n-\t\t}\n-\n-\t\t// Round 3.\n-\t\tfor i := uint(0); i < 16; i++ {\n-\t\t\tx := xIndex3[i]\n-\t\t\ts := shift3[i%4]\n-\t\t\th := b ^ c ^ d\n-\t\t\ta += h + X[x] + 0x6ed9eba1\n-\t\t\ta = a<<s | a>>(32-s)\n-\t\t\ta, b, c, d = d, a, b, c\n-\t\t}\n-\n-\t\ta += aa\n-\t\tb += bb\n-\t\tc += cc\n-\t\td += dd\n-\n-\t\tp = p[_Chunk:]\n-\t\tn += _Chunk\n-\t}\n-\n-\tdig.s[0] = a\n-\tdig.s[1] = b\n-\tdig.s[2] = c\n-\tdig.s[3] = d\n-\treturn n\n-}"}, {"sha": "b9dfdf94e319a9567610c8c3868203d83e19bbf5", "filename": "libgo/go/crypto/ocsp/ocsp.go", "status": "removed", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,191 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package ocsp parses OCSP responses as specified in RFC 2560. OCSP responses\n-// are signed messages attesting to the validity of a certificate for a small\n-// period of time. This is used to manage revocation for X.509 certificates.\n-package ocsp\n-\n-import (\n-\t\"crypto\"\n-\t\"crypto/rsa\"\n-\t_ \"crypto/sha1\"\n-\t\"crypto/x509\"\n-\t\"crypto/x509/pkix\"\n-\t\"encoding/asn1\"\n-\t\"time\"\n-)\n-\n-var idPKIXOCSPBasic = asn1.ObjectIdentifier([]int{1, 3, 6, 1, 5, 5, 7, 48, 1, 1})\n-var idSHA1WithRSA = asn1.ObjectIdentifier([]int{1, 2, 840, 113549, 1, 1, 5})\n-\n-// These are internal structures that reflect the ASN.1 structure of an OCSP\n-// response. See RFC 2560, section 4.2.\n-\n-const (\n-\tocspSuccess       = 0\n-\tocspMalformed     = 1\n-\tocspInternalError = 2\n-\tocspTryLater      = 3\n-\tocspSigRequired   = 4\n-\tocspUnauthorized  = 5\n-)\n-\n-type certID struct {\n-\tHashAlgorithm pkix.AlgorithmIdentifier\n-\tNameHash      []byte\n-\tIssuerKeyHash []byte\n-\tSerialNumber  asn1.RawValue\n-}\n-\n-type responseASN1 struct {\n-\tStatus   asn1.Enumerated\n-\tResponse responseBytes `asn1:\"explicit,tag:0\"`\n-}\n-\n-type responseBytes struct {\n-\tResponseType asn1.ObjectIdentifier\n-\tResponse     []byte\n-}\n-\n-type basicResponse struct {\n-\tTBSResponseData    responseData\n-\tSignatureAlgorithm pkix.AlgorithmIdentifier\n-\tSignature          asn1.BitString\n-\tCertificates       []asn1.RawValue `asn1:\"explicit,tag:0,optional\"`\n-}\n-\n-type responseData struct {\n-\tRaw           asn1.RawContent\n-\tVersion       int              `asn1:\"optional,default:1,explicit,tag:0\"`\n-\tRequestorName pkix.RDNSequence `asn1:\"optional,explicit,tag:1\"`\n-\tKeyHash       []byte           `asn1:\"optional,explicit,tag:2\"`\n-\tProducedAt    time.Time\n-\tResponses     []singleResponse\n-}\n-\n-type singleResponse struct {\n-\tCertID     certID\n-\tGood       asn1.Flag   `asn1:\"explicit,tag:0,optional\"`\n-\tRevoked    revokedInfo `asn1:\"explicit,tag:1,optional\"`\n-\tUnknown    asn1.Flag   `asn1:\"explicit,tag:2,optional\"`\n-\tThisUpdate time.Time\n-\tNextUpdate time.Time `asn1:\"explicit,tag:0,optional\"`\n-}\n-\n-type revokedInfo struct {\n-\tRevocationTime time.Time\n-\tReason         int `asn1:\"explicit,tag:0,optional\"`\n-}\n-\n-// This is the exposed reflection of the internal OCSP structures.\n-\n-const (\n-\t// Good means that the certificate is valid.\n-\tGood = iota\n-\t// Revoked means that the certificate has been deliberately revoked.\n-\tRevoked = iota\n-\t// Unknown means that the OCSP responder doesn't know about the certificate.\n-\tUnknown = iota\n-\t// ServerFailed means that the OCSP responder failed to process the request.\n-\tServerFailed = iota\n-)\n-\n-// Response represents an OCSP response. See RFC 2560.\n-type Response struct {\n-\t// Status is one of {Good, Revoked, Unknown, ServerFailed}\n-\tStatus                                        int\n-\tSerialNumber                                  []byte\n-\tProducedAt, ThisUpdate, NextUpdate, RevokedAt time.Time\n-\tRevocationReason                              int\n-\tCertificate                                   *x509.Certificate\n-}\n-\n-// ParseError results from an invalid OCSP response.\n-type ParseError string\n-\n-func (p ParseError) Error() string {\n-\treturn string(p)\n-}\n-\n-// ParseResponse parses an OCSP response in DER form. It only supports\n-// responses for a single certificate and only those using RSA signatures.\n-// Non-RSA responses will result in an x509.UnsupportedAlgorithmError.\n-// Signature errors or parse failures will result in a ParseError.\n-func ParseResponse(bytes []byte) (*Response, error) {\n-\tvar resp responseASN1\n-\trest, err := asn1.Unmarshal(bytes, &resp)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tif len(rest) > 0 {\n-\t\treturn nil, ParseError(\"trailing data in OCSP response\")\n-\t}\n-\n-\tret := new(Response)\n-\tif resp.Status != ocspSuccess {\n-\t\tret.Status = ServerFailed\n-\t\treturn ret, nil\n-\t}\n-\n-\tif !resp.Response.ResponseType.Equal(idPKIXOCSPBasic) {\n-\t\treturn nil, ParseError(\"bad OCSP response type\")\n-\t}\n-\n-\tvar basicResp basicResponse\n-\trest, err = asn1.Unmarshal(resp.Response.Response, &basicResp)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tif len(basicResp.Certificates) != 1 {\n-\t\treturn nil, ParseError(\"OCSP response contains bad number of certificates\")\n-\t}\n-\n-\tif len(basicResp.TBSResponseData.Responses) != 1 {\n-\t\treturn nil, ParseError(\"OCSP response contains bad number of responses\")\n-\t}\n-\n-\tret.Certificate, err = x509.ParseCertificate(basicResp.Certificates[0].FullBytes)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tif ret.Certificate.PublicKeyAlgorithm != x509.RSA || !basicResp.SignatureAlgorithm.Algorithm.Equal(idSHA1WithRSA) {\n-\t\treturn nil, x509.UnsupportedAlgorithmError{}\n-\t}\n-\n-\thashType := crypto.SHA1\n-\th := hashType.New()\n-\n-\tpub := ret.Certificate.PublicKey.(*rsa.PublicKey)\n-\th.Write(basicResp.TBSResponseData.Raw)\n-\tdigest := h.Sum(nil)\n-\tsignature := basicResp.Signature.RightAlign()\n-\n-\tif rsa.VerifyPKCS1v15(pub, hashType, digest, signature) != nil {\n-\t\treturn nil, ParseError(\"bad OCSP signature\")\n-\t}\n-\n-\tr := basicResp.TBSResponseData.Responses[0]\n-\n-\tret.SerialNumber = r.CertID.SerialNumber.Bytes\n-\n-\tswitch {\n-\tcase bool(r.Good):\n-\t\tret.Status = Good\n-\tcase bool(r.Unknown):\n-\t\tret.Status = Unknown\n-\tdefault:\n-\t\tret.Status = Revoked\n-\t\tret.RevokedAt = r.Revoked.RevocationTime\n-\t\tret.RevocationReason = r.Revoked.Reason\n-\t}\n-\n-\tret.ProducedAt = basicResp.TBSResponseData.ProducedAt\n-\tret.ThisUpdate = r.ThisUpdate\n-\tret.NextUpdate = r.NextUpdate\n-\n-\treturn ret, nil\n-}"}, {"sha": "f0e9f94ee7fc4ec163dccc6085a51f645af1ba81", "filename": "libgo/go/crypto/ocsp/ocsp_test.go", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,107 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package ocsp\n-\n-import (\n-\t\"bytes\"\n-\t\"encoding/hex\"\n-\t\"reflect\"\n-\t\"testing\"\n-\t\"time\"\n-)\n-\n-func TestOCSPDecode(t *testing.T) {\n-\tresponseBytes, _ := hex.DecodeString(ocspResponseHex)\n-\tresp, err := ParseResponse(responseBytes)\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t}\n-\n-\texpected := Response{\n-\t\tStatus:           0,\n-\t\tSerialNumber:     []byte{0x1, 0xd0, 0xfa},\n-\t\tRevocationReason: 0,\n-\t\tThisUpdate:       time.Date(2010, 7, 7, 15, 1, 5, 0, time.UTC),\n-\t\tNextUpdate:       time.Date(2010, 7, 7, 18, 35, 17, 0, time.UTC),\n-\t}\n-\n-\tif !reflect.DeepEqual(resp.ThisUpdate, expected.ThisUpdate) {\n-\t\tt.Errorf(\"resp.ThisUpdate: got %d, want %d\", resp.ThisUpdate, expected.ThisUpdate)\n-\t}\n-\n-\tif !reflect.DeepEqual(resp.NextUpdate, expected.NextUpdate) {\n-\t\tt.Errorf(\"resp.NextUpdate: got %d, want %d\", resp.NextUpdate, expected.NextUpdate)\n-\t}\n-\n-\tif resp.Status != expected.Status {\n-\t\tt.Errorf(\"resp.Status: got %d, want %d\", resp.Status, expected.Status)\n-\t}\n-\n-\tif !bytes.Equal(resp.SerialNumber, expected.SerialNumber) {\n-\t\tt.Errorf(\"resp.SerialNumber: got %x, want %x\", resp.SerialNumber, expected.SerialNumber)\n-\t}\n-\n-\tif resp.RevocationReason != expected.RevocationReason {\n-\t\tt.Errorf(\"resp.RevocationReason: got %d, want %d\", resp.RevocationReason, expected.RevocationReason)\n-\t}\n-}\n-\n-// This OCSP response was taken from Thawte's public OCSP responder.\n-// To recreate:\n-//   $ openssl s_client -tls1 -showcerts -servername www.google.com -connect www.google.com:443\n-// Copy and paste the first certificate into /tmp/cert.crt and the second into\n-// /tmp/intermediate.crt\n-//   $ openssl ocsp -issuer /tmp/intermediate.crt -cert /tmp/cert.crt -url http://ocsp.thawte.com -resp_text -respout /tmp/ocsp.der\n-// Then hex encode the result:\n-//   $ python -c 'print file(\"/tmp/ocsp.der\", \"r\").read().encode(\"hex\")'\n-\n-const ocspResponseHex = \"308206bc0a0100a08206b5308206b106092b0601050507300101048206a23082069e3081\" +\n-\t\"c9a14e304c310b300906035504061302494c31163014060355040a130d5374617274436f\" +\n-\t\"6d204c74642e312530230603550403131c5374617274436f6d20436c6173732031204f43\" +\n-\t\"5350205369676e6572180f32303130303730373137333531375a30663064303c30090605\" +\n-\t\"2b0e03021a050004146568874f40750f016a3475625e1f5c93e5a26d580414eb4234d098\" +\n-\t\"b0ab9ff41b6b08f7cc642eef0e2c45020301d0fa8000180f323031303037303731353031\" +\n-\t\"30355aa011180f32303130303730373138333531375a300d06092a864886f70d01010505\" +\n-\t\"000382010100ab557ff070d1d7cebbb5f0ec91a15c3fed22eb2e1b8244f1b84545f013a4\" +\n-\t\"fb46214c5e3fbfbebb8a56acc2b9db19f68fd3c3201046b3824d5ba689f99864328710cb\" +\n-\t\"467195eb37d84f539e49f859316b32964dc3e47e36814ce94d6c56dd02733b1d0802f7ff\" +\n-\t\"4eebdbbd2927dcf580f16cbc290f91e81b53cb365e7223f1d6e20a88ea064104875e0145\" +\n-\t\"672b20fc14829d51ca122f5f5d77d3ad6c83889c55c7dc43680ba2fe3cef8b05dbcabdc0\" +\n-\t\"d3e09aaf9725597f8c858c2fa38c0d6aed2e6318194420dd1a1137445d13e1c97ab47896\" +\n-\t\"17a4e08925f46f867b72e3a4dc1f08cb870b2b0717f7207faa0ac512e628a029aba7457a\" +\n-\t\"e63dcf3281e2162d9349a08204ba308204b6308204b23082039aa003020102020101300d\" +\n-\t\"06092a864886f70d010105050030818c310b300906035504061302494c31163014060355\" +\n-\t\"040a130d5374617274436f6d204c74642e312b3029060355040b13225365637572652044\" +\n-\t\"69676974616c204365727469666963617465205369676e696e6731383036060355040313\" +\n-\t\"2f5374617274436f6d20436c6173732031205072696d61727920496e7465726d65646961\" +\n-\t\"746520536572766572204341301e170d3037313032353030323330365a170d3132313032\" +\n-\t\"333030323330365a304c310b300906035504061302494c31163014060355040a130d5374\" +\n-\t\"617274436f6d204c74642e312530230603550403131c5374617274436f6d20436c617373\" +\n-\t\"2031204f435350205369676e657230820122300d06092a864886f70d0101010500038201\" +\n-\t\"0f003082010a0282010100b9561b4c45318717178084e96e178df2255e18ed8d8ecc7c2b\" +\n-\t\"7b51a6c1c2e6bf0aa3603066f132fe10ae97b50e99fa24b83fc53dd2777496387d14e1c3\" +\n-\t\"a9b6a4933e2ac12413d085570a95b8147414a0bc007c7bcf222446ef7f1a156d7ea1c577\" +\n-\t\"fc5f0facdfd42eb0f5974990cb2f5cefebceef4d1bdc7ae5c1075c5a99a93171f2b0845b\" +\n-\t\"4ff0864e973fcfe32f9d7511ff87a3e943410c90a4493a306b6944359340a9ca96f02b66\" +\n-\t\"ce67f028df2980a6aaee8d5d5d452b8b0eb93f923cc1e23fcccbdbe7ffcb114d08fa7a6a\" +\n-\t\"3c404f825d1a0e715935cf623a8c7b59670014ed0622f6089a9447a7a19010f7fe58f841\" +\n-\t\"29a2765ea367824d1c3bb2fda308530203010001a382015c30820158300c0603551d1301\" +\n-\t\"01ff04023000300b0603551d0f0404030203a8301e0603551d250417301506082b060105\" +\n-\t\"0507030906092b0601050507300105301d0603551d0e0416041445e0a36695414c5dd449\" +\n-\t\"bc00e33cdcdbd2343e173081a80603551d230481a030819d8014eb4234d098b0ab9ff41b\" +\n-\t\"6b08f7cc642eef0e2c45a18181a47f307d310b300906035504061302494c311630140603\" +\n-\t\"55040a130d5374617274436f6d204c74642e312b3029060355040b132253656375726520\" +\n-\t\"4469676974616c204365727469666963617465205369676e696e67312930270603550403\" +\n-\t\"13205374617274436f6d2043657274696669636174696f6e20417574686f726974798201\" +\n-\t\"0a30230603551d12041c301a8618687474703a2f2f7777772e737461727473736c2e636f\" +\n-\t\"6d2f302c06096086480186f842010d041f161d5374617274436f6d205265766f63617469\" +\n-\t\"6f6e20417574686f72697479300d06092a864886f70d01010505000382010100182d2215\" +\n-\t\"8f0fc0291324fa8574c49bb8ff2835085adcbf7b7fc4191c397ab6951328253fffe1e5ec\" +\n-\t\"2a7da0d50fca1a404e6968481366939e666c0a6209073eca57973e2fefa9ed1718e8176f\" +\n-\t\"1d85527ff522c08db702e3b2b180f1cbff05d98128252cf0f450f7dd2772f4188047f19d\" +\n-\t\"c85317366f94bc52d60f453a550af58e308aaab00ced33040b62bf37f5b1ab2a4f7f0f80\" +\n-\t\"f763bf4d707bc8841d7ad9385ee2a4244469260b6f2bf085977af9074796048ecc2f9d48\" +\n-\t\"a1d24ce16e41a9941568fec5b42771e118f16c106a54ccc339a4b02166445a167902e75e\" +\n-\t\"6d8620b0825dcd18a069b90fd851d10fa8effd409deec02860d26d8d833f304b10669b42\""}, {"sha": "96957ab1b483e31210583776abbb4e116db185e3", "filename": "libgo/go/crypto/openpgp/armor/armor.go", "status": "removed", "additions": 0, "deletions": 219, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,219 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package armor implements OpenPGP ASCII Armor, see RFC 4880. OpenPGP Armor is\n-// very similar to PEM except that it has an additional CRC checksum.\n-package armor\n-\n-import (\n-\t\"bufio\"\n-\t\"bytes\"\n-\t\"crypto/openpgp/errors\"\n-\t\"encoding/base64\"\n-\t\"io\"\n-)\n-\n-// A Block represents an OpenPGP armored structure.\n-//\n-// The encoded form is:\n-//    -----BEGIN Type-----\n-//    Headers\n-//\n-//    base64-encoded Bytes\n-//    '=' base64 encoded checksum\n-//    -----END Type-----\n-// where Headers is a possibly empty sequence of Key: Value lines.\n-//\n-// Since the armored data can be very large, this package presents a streaming\n-// interface.\n-type Block struct {\n-\tType    string            // The type, taken from the preamble (i.e. \"PGP SIGNATURE\").\n-\tHeader  map[string]string // Optional headers.\n-\tBody    io.Reader         // A Reader from which the contents can be read\n-\tlReader lineReader\n-\toReader openpgpReader\n-}\n-\n-var ArmorCorrupt error = errors.StructuralError(\"armor invalid\")\n-\n-const crc24Init = 0xb704ce\n-const crc24Poly = 0x1864cfb\n-const crc24Mask = 0xffffff\n-\n-// crc24 calculates the OpenPGP checksum as specified in RFC 4880, section 6.1\n-func crc24(crc uint32, d []byte) uint32 {\n-\tfor _, b := range d {\n-\t\tcrc ^= uint32(b) << 16\n-\t\tfor i := 0; i < 8; i++ {\n-\t\t\tcrc <<= 1\n-\t\t\tif crc&0x1000000 != 0 {\n-\t\t\t\tcrc ^= crc24Poly\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn crc\n-}\n-\n-var armorStart = []byte(\"-----BEGIN \")\n-var armorEnd = []byte(\"-----END \")\n-var armorEndOfLine = []byte(\"-----\")\n-\n-// lineReader wraps a line based reader. It watches for the end of an armor\n-// block and records the expected CRC value.\n-type lineReader struct {\n-\tin  *bufio.Reader\n-\tbuf []byte\n-\teof bool\n-\tcrc uint32\n-}\n-\n-func (l *lineReader) Read(p []byte) (n int, err error) {\n-\tif l.eof {\n-\t\treturn 0, io.EOF\n-\t}\n-\n-\tif len(l.buf) > 0 {\n-\t\tn = copy(p, l.buf)\n-\t\tl.buf = l.buf[n:]\n-\t\treturn\n-\t}\n-\n-\tline, isPrefix, err := l.in.ReadLine()\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tif isPrefix {\n-\t\treturn 0, ArmorCorrupt\n-\t}\n-\n-\tif len(line) == 5 && line[0] == '=' {\n-\t\t// This is the checksum line\n-\t\tvar expectedBytes [3]byte\n-\t\tvar m int\n-\t\tm, err = base64.StdEncoding.Decode(expectedBytes[0:], line[1:])\n-\t\tif m != 3 || err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tl.crc = uint32(expectedBytes[0])<<16 |\n-\t\t\tuint32(expectedBytes[1])<<8 |\n-\t\t\tuint32(expectedBytes[2])\n-\n-\t\tline, _, err = l.in.ReadLine()\n-\t\tif err != nil && err != io.EOF {\n-\t\t\treturn\n-\t\t}\n-\t\tif !bytes.HasPrefix(line, armorEnd) {\n-\t\t\treturn 0, ArmorCorrupt\n-\t\t}\n-\n-\t\tl.eof = true\n-\t\treturn 0, io.EOF\n-\t}\n-\n-\tif len(line) > 64 {\n-\t\treturn 0, ArmorCorrupt\n-\t}\n-\n-\tn = copy(p, line)\n-\tbytesToSave := len(line) - n\n-\tif bytesToSave > 0 {\n-\t\tif cap(l.buf) < bytesToSave {\n-\t\t\tl.buf = make([]byte, 0, bytesToSave)\n-\t\t}\n-\t\tl.buf = l.buf[0:bytesToSave]\n-\t\tcopy(l.buf, line[n:])\n-\t}\n-\n-\treturn\n-}\n-\n-// openpgpReader passes Read calls to the underlying base64 decoder, but keeps\n-// a running CRC of the resulting data and checks the CRC against the value\n-// found by the lineReader at EOF.\n-type openpgpReader struct {\n-\tlReader    *lineReader\n-\tb64Reader  io.Reader\n-\tcurrentCRC uint32\n-}\n-\n-func (r *openpgpReader) Read(p []byte) (n int, err error) {\n-\tn, err = r.b64Reader.Read(p)\n-\tr.currentCRC = crc24(r.currentCRC, p[:n])\n-\n-\tif err == io.EOF {\n-\t\tif r.lReader.crc != uint32(r.currentCRC&crc24Mask) {\n-\t\t\treturn 0, ArmorCorrupt\n-\t\t}\n-\t}\n-\n-\treturn\n-}\n-\n-// Decode reads a PGP armored block from the given Reader. It will ignore\n-// leading garbage. If it doesn't find a block, it will return nil, io.EOF. The\n-// given Reader is not usable after calling this function: an arbitrary amount\n-// of data may have been read past the end of the block.\n-func Decode(in io.Reader) (p *Block, err error) {\n-\tr, _ := bufio.NewReaderSize(in, 100)\n-\tvar line []byte\n-\tignoreNext := false\n-\n-TryNextBlock:\n-\tp = nil\n-\n-\t// Skip leading garbage\n-\tfor {\n-\t\tignoreThis := ignoreNext\n-\t\tline, ignoreNext, err = r.ReadLine()\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tif ignoreNext || ignoreThis {\n-\t\t\tcontinue\n-\t\t}\n-\t\tline = bytes.TrimSpace(line)\n-\t\tif len(line) > len(armorStart)+len(armorEndOfLine) && bytes.HasPrefix(line, armorStart) {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\n-\tp = new(Block)\n-\tp.Type = string(line[len(armorStart) : len(line)-len(armorEndOfLine)])\n-\tp.Header = make(map[string]string)\n-\tnextIsContinuation := false\n-\tvar lastKey string\n-\n-\t// Read headers\n-\tfor {\n-\t\tisContinuation := nextIsContinuation\n-\t\tline, nextIsContinuation, err = r.ReadLine()\n-\t\tif err != nil {\n-\t\t\tp = nil\n-\t\t\treturn\n-\t\t}\n-\t\tif isContinuation {\n-\t\t\tp.Header[lastKey] += string(line)\n-\t\t\tcontinue\n-\t\t}\n-\t\tline = bytes.TrimSpace(line)\n-\t\tif len(line) == 0 {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\ti := bytes.Index(line, []byte(\": \"))\n-\t\tif i == -1 {\n-\t\t\tgoto TryNextBlock\n-\t\t}\n-\t\tlastKey = string(line[:i])\n-\t\tp.Header[lastKey] = string(line[i+2:])\n-\t}\n-\n-\tp.lReader.in = r\n-\tp.oReader.currentCRC = crc24Init\n-\tp.oReader.lReader = &p.lReader\n-\tp.oReader.b64Reader = base64.NewDecoder(base64.StdEncoding, &p.lReader)\n-\tp.Body = &p.oReader\n-\n-\treturn\n-}"}, {"sha": "9334e94e96cdd01c35180f88b2d81a667bb35ab5", "filename": "libgo/go/crypto/openpgp/armor/armor_test.go", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,95 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package armor\n-\n-import (\n-\t\"bytes\"\n-\t\"hash/adler32\"\n-\t\"io/ioutil\"\n-\t\"testing\"\n-)\n-\n-func TestDecodeEncode(t *testing.T) {\n-\tbuf := bytes.NewBuffer([]byte(armorExample1))\n-\tresult, err := Decode(buf)\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t}\n-\texpectedType := \"PGP SIGNATURE\"\n-\tif result.Type != expectedType {\n-\t\tt.Errorf(\"result.Type: got:%s want:%s\", result.Type, expectedType)\n-\t}\n-\tif len(result.Header) != 1 {\n-\t\tt.Errorf(\"len(result.Header): got:%d want:1\", len(result.Header))\n-\t}\n-\tv, ok := result.Header[\"Version\"]\n-\tif !ok || v != \"GnuPG v1.4.10 (GNU/Linux)\" {\n-\t\tt.Errorf(\"result.Header: got:%#v\", result.Header)\n-\t}\n-\n-\tcontents, err := ioutil.ReadAll(result.Body)\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t}\n-\n-\tif adler32.Checksum(contents) != 0x27b144be {\n-\t\tt.Errorf(\"contents: got: %x\", contents)\n-\t}\n-\n-\tbuf = bytes.NewBuffer(nil)\n-\tw, err := Encode(buf, result.Type, result.Header)\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t}\n-\t_, err = w.Write(contents)\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t}\n-\tw.Close()\n-\n-\tif !bytes.Equal(buf.Bytes(), []byte(armorExample1)) {\n-\t\tt.Errorf(\"got: %s\\nwant: %s\", string(buf.Bytes()), armorExample1)\n-\t}\n-}\n-\n-func TestLongHeader(t *testing.T) {\n-\tbuf := bytes.NewBuffer([]byte(armorLongLine))\n-\tresult, err := Decode(buf)\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t\treturn\n-\t}\n-\tvalue, ok := result.Header[\"Version\"]\n-\tif !ok {\n-\t\tt.Errorf(\"missing Version header\")\n-\t}\n-\tif value != longValueExpected {\n-\t\tt.Errorf(\"got: %s want: %s\", value, longValueExpected)\n-\t}\n-}\n-\n-const armorExample1 = `-----BEGIN PGP SIGNATURE-----\n-Version: GnuPG v1.4.10 (GNU/Linux)\n-\n-iJwEAAECAAYFAk1Fv/0ACgkQo01+GMIMMbsYTwQAiAw+QAaNfY6WBdplZ/uMAccm\n-4g+81QPmTSGHnetSb6WBiY13kVzK4HQiZH8JSkmmroMLuGeJwsRTEL4wbjRyUKEt\n-p1xwUZDECs234F1xiG5enc5SGlRtP7foLBz9lOsjx+LEcA4sTl5/2eZR9zyFZqWW\n-TxRjs+fJCIFuo71xb1g=\n-=/teI\n------END PGP SIGNATURE-----`\n-\n-const armorLongLine = `-----BEGIN PGP SIGNATURE-----\n-Version: 0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz\n-\n-iQEcBAABAgAGBQJMtFESAAoJEKsQXJGvOPsVj40H/1WW6jaMXv4BW+1ueDSMDwM8\n-kx1fLOXbVM5/Kn5LStZNt1jWWnpxdz7eq3uiqeCQjmqUoRde3YbB2EMnnwRbAhpp\n-cacnAvy9ZQ78OTxUdNW1mhX5bS6q1MTEJnl+DcyigD70HG/yNNQD7sOPMdYQw0TA\n-byQBwmLwmTsuZsrYqB68QyLHI+DUugn+kX6Hd2WDB62DKa2suoIUIHQQCd/ofwB3\n-WfCYInXQKKOSxu2YOg2Eb4kLNhSMc1i9uKUWAH+sdgJh7NBgdoE4MaNtBFkHXRvv\n-okWuf3+xA9ksp1npSY/mDvgHijmjvtpRDe6iUeqfCn8N9u9CBg8geANgaG8+QA4=\n-=wfQG\n------END PGP SIGNATURE-----`\n-\n-const longValueExpected = \"0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz\""}, {"sha": "6f07582c37cea69c0f972ccd1f3d53f9a5fe1d02", "filename": "libgo/go/crypto/openpgp/armor/encode.go", "status": "removed", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Fencode.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,160 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package armor\n-\n-import (\n-\t\"encoding/base64\"\n-\t\"io\"\n-)\n-\n-var armorHeaderSep = []byte(\": \")\n-var blockEnd = []byte(\"\\n=\")\n-var newline = []byte(\"\\n\")\n-var armorEndOfLineOut = []byte(\"-----\\n\")\n-\n-// writeSlices writes its arguments to the given Writer.\n-func writeSlices(out io.Writer, slices ...[]byte) (err error) {\n-\tfor _, s := range slices {\n-\t\t_, err = out.Write(s)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-// lineBreaker breaks data across several lines, all of the same byte length\n-// (except possibly the last). Lines are broken with a single '\\n'.\n-type lineBreaker struct {\n-\tlineLength  int\n-\tline        []byte\n-\tused        int\n-\tout         io.Writer\n-\thaveWritten bool\n-}\n-\n-func newLineBreaker(out io.Writer, lineLength int) *lineBreaker {\n-\treturn &lineBreaker{\n-\t\tlineLength: lineLength,\n-\t\tline:       make([]byte, lineLength),\n-\t\tused:       0,\n-\t\tout:        out,\n-\t}\n-}\n-\n-func (l *lineBreaker) Write(b []byte) (n int, err error) {\n-\tn = len(b)\n-\n-\tif n == 0 {\n-\t\treturn\n-\t}\n-\n-\tif l.used == 0 && l.haveWritten {\n-\t\t_, err = l.out.Write([]byte{'\\n'})\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\n-\tif l.used+len(b) < l.lineLength {\n-\t\tl.used += copy(l.line[l.used:], b)\n-\t\treturn\n-\t}\n-\n-\tl.haveWritten = true\n-\t_, err = l.out.Write(l.line[0:l.used])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\texcess := l.lineLength - l.used\n-\tl.used = 0\n-\n-\t_, err = l.out.Write(b[0:excess])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\t_, err = l.Write(b[excess:])\n-\treturn\n-}\n-\n-func (l *lineBreaker) Close() (err error) {\n-\tif l.used > 0 {\n-\t\t_, err = l.out.Write(l.line[0:l.used])\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\n-\treturn\n-}\n-\n-// encoding keeps track of a running CRC24 over the data which has been written\n-// to it and outputs a OpenPGP checksum when closed, followed by an armor\n-// trailer.\n-//\n-// It's built into a stack of io.Writers:\n-//    encoding -> base64 encoder -> lineBreaker -> out\n-type encoding struct {\n-\tout       io.Writer\n-\tbreaker   *lineBreaker\n-\tb64       io.WriteCloser\n-\tcrc       uint32\n-\tblockType []byte\n-}\n-\n-func (e *encoding) Write(data []byte) (n int, err error) {\n-\te.crc = crc24(e.crc, data)\n-\treturn e.b64.Write(data)\n-}\n-\n-func (e *encoding) Close() (err error) {\n-\terr = e.b64.Close()\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\te.breaker.Close()\n-\n-\tvar checksumBytes [3]byte\n-\tchecksumBytes[0] = byte(e.crc >> 16)\n-\tchecksumBytes[1] = byte(e.crc >> 8)\n-\tchecksumBytes[2] = byte(e.crc)\n-\n-\tvar b64ChecksumBytes [4]byte\n-\tbase64.StdEncoding.Encode(b64ChecksumBytes[:], checksumBytes[:])\n-\n-\treturn writeSlices(e.out, blockEnd, b64ChecksumBytes[:], newline, armorEnd, e.blockType, armorEndOfLine)\n-}\n-\n-// Encode returns a WriteCloser which will encode the data written to it in\n-// OpenPGP armor.\n-func Encode(out io.Writer, blockType string, headers map[string]string) (w io.WriteCloser, err error) {\n-\tbType := []byte(blockType)\n-\terr = writeSlices(out, armorStart, bType, armorEndOfLineOut)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tfor k, v := range headers {\n-\t\terr = writeSlices(out, []byte(k), armorHeaderSep, []byte(v), newline)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\n-\t_, err = out.Write(newline)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\te := &encoding{\n-\t\tout:       out,\n-\t\tbreaker:   newLineBreaker(out, 64),\n-\t\tcrc:       crc24Init,\n-\t\tblockType: bType,\n-\t}\n-\te.b64 = base64.NewEncoder(base64.StdEncoding, e.breaker)\n-\treturn e, nil\n-}"}, {"sha": "e601e389f1299cd0f02e3a11f0f5e42ca8bb6e22", "filename": "libgo/go/crypto/openpgp/canonical_text.go", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,59 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package openpgp\n-\n-import \"hash\"\n-\n-// NewCanonicalTextHash reformats text written to it into the canonical\n-// form and then applies the hash h.  See RFC 4880, section 5.2.1.\n-func NewCanonicalTextHash(h hash.Hash) hash.Hash {\n-\treturn &canonicalTextHash{h, 0}\n-}\n-\n-type canonicalTextHash struct {\n-\th hash.Hash\n-\ts int\n-}\n-\n-var newline = []byte{'\\r', '\\n'}\n-\n-func (cth *canonicalTextHash) Write(buf []byte) (int, error) {\n-\tstart := 0\n-\n-\tfor i, c := range buf {\n-\t\tswitch cth.s {\n-\t\tcase 0:\n-\t\t\tif c == '\\r' {\n-\t\t\t\tcth.s = 1\n-\t\t\t} else if c == '\\n' {\n-\t\t\t\tcth.h.Write(buf[start:i])\n-\t\t\t\tcth.h.Write(newline)\n-\t\t\t\tstart = i + 1\n-\t\t\t}\n-\t\tcase 1:\n-\t\t\tcth.s = 0\n-\t\t}\n-\t}\n-\n-\tcth.h.Write(buf[start:])\n-\treturn len(buf), nil\n-}\n-\n-func (cth *canonicalTextHash) Sum(in []byte) []byte {\n-\treturn cth.h.Sum(in)\n-}\n-\n-func (cth *canonicalTextHash) Reset() {\n-\tcth.h.Reset()\n-\tcth.s = 0\n-}\n-\n-func (cth *canonicalTextHash) Size() int {\n-\treturn cth.h.Size()\n-}\n-\n-func (cth *canonicalTextHash) BlockSize() int {\n-\treturn cth.h.BlockSize()\n-}"}, {"sha": "8f3ba2a8814ea9c48b0d34fa6018c5aa5468d283", "filename": "libgo/go/crypto/openpgp/canonical_text_test.go", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,52 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package openpgp\n-\n-import (\n-\t\"bytes\"\n-\t\"testing\"\n-)\n-\n-type recordingHash struct {\n-\tbuf *bytes.Buffer\n-}\n-\n-func (r recordingHash) Write(b []byte) (n int, err error) {\n-\treturn r.buf.Write(b)\n-}\n-\n-func (r recordingHash) Sum(in []byte) []byte {\n-\treturn append(in, r.buf.Bytes()...)\n-}\n-\n-func (r recordingHash) Reset() {\n-\tpanic(\"shouldn't be called\")\n-}\n-\n-func (r recordingHash) Size() int {\n-\tpanic(\"shouldn't be called\")\n-}\n-\n-func (r recordingHash) BlockSize() int {\n-\tpanic(\"shouldn't be called\")\n-}\n-\n-func testCanonicalText(t *testing.T, input, expected string) {\n-\tr := recordingHash{bytes.NewBuffer(nil)}\n-\tc := NewCanonicalTextHash(r)\n-\tc.Write([]byte(input))\n-\tresult := c.Sum(nil)\n-\tif expected != string(result) {\n-\t\tt.Errorf(\"input: %x got: %x want: %x\", input, result, expected)\n-\t}\n-}\n-\n-func TestCanonicalText(t *testing.T) {\n-\ttestCanonicalText(t, \"foo\\n\", \"foo\\r\\n\")\n-\ttestCanonicalText(t, \"foo\", \"foo\")\n-\ttestCanonicalText(t, \"foo\\r\\n\", \"foo\\r\\n\")\n-\ttestCanonicalText(t, \"foo\\r\\nbar\", \"foo\\r\\nbar\")\n-\ttestCanonicalText(t, \"foo\\r\\nbar\\n\\n\", \"foo\\r\\nbar\\r\\n\\r\\n\")\n-}"}, {"sha": "a553bdee8dd6ab7e216a55b9611051a26fc45d46", "filename": "libgo/go/crypto/openpgp/elgamal/elgamal.go", "status": "removed", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Felgamal%2Felgamal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Felgamal%2Felgamal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Felgamal%2Felgamal.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,122 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package elgamal implements ElGamal encryption, suitable for OpenPGP,\n-// as specified in \"A Public-Key Cryptosystem and a Signature Scheme Based on\n-// Discrete Logarithms,\" IEEE Transactions on Information Theory, v. IT-31,\n-// n. 4, 1985, pp. 469-472.\n-//\n-// This form of ElGamal embeds PKCS#1 v1.5 padding, which may make it\n-// unsuitable for other protocols. RSA should be used in preference in any\n-// case.\n-package elgamal\n-\n-import (\n-\t\"crypto/rand\"\n-\t\"crypto/subtle\"\n-\t\"errors\"\n-\t\"io\"\n-\t\"math/big\"\n-)\n-\n-// PublicKey represents an ElGamal public key.\n-type PublicKey struct {\n-\tG, P, Y *big.Int\n-}\n-\n-// PrivateKey represents an ElGamal private key.\n-type PrivateKey struct {\n-\tPublicKey\n-\tX *big.Int\n-}\n-\n-// Encrypt encrypts the given message to the given public key. The result is a\n-// pair of integers. Errors can result from reading random, or because msg is\n-// too large to be encrypted to the public key.\n-func Encrypt(random io.Reader, pub *PublicKey, msg []byte) (c1, c2 *big.Int, err error) {\n-\tpLen := (pub.P.BitLen() + 7) / 8\n-\tif len(msg) > pLen-11 {\n-\t\terr = errors.New(\"elgamal: message too long\")\n-\t\treturn\n-\t}\n-\n-\t// EM = 0x02 || PS || 0x00 || M\n-\tem := make([]byte, pLen-1)\n-\tem[0] = 2\n-\tps, mm := em[1:len(em)-len(msg)-1], em[len(em)-len(msg):]\n-\terr = nonZeroRandomBytes(ps, random)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tem[len(em)-len(msg)-1] = 0\n-\tcopy(mm, msg)\n-\n-\tm := new(big.Int).SetBytes(em)\n-\n-\tk, err := rand.Int(random, pub.P)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tc1 = new(big.Int).Exp(pub.G, k, pub.P)\n-\ts := new(big.Int).Exp(pub.Y, k, pub.P)\n-\tc2 = s.Mul(s, m)\n-\tc2.Mod(c2, pub.P)\n-\n-\treturn\n-}\n-\n-// Decrypt takes two integers, resulting from an ElGamal encryption, and\n-// returns the plaintext of the message. An error can result only if the\n-// ciphertext is invalid. Users should keep in mind that this is a padding\n-// oracle and thus, if exposed to an adaptive chosen ciphertext attack, can\n-// be used to break the cryptosystem.  See ``Chosen Ciphertext Attacks\n-// Against Protocols Based on the RSA Encryption Standard PKCS #1'', Daniel\n-// Bleichenbacher, Advances in Cryptology (Crypto '98),\n-func Decrypt(priv *PrivateKey, c1, c2 *big.Int) (msg []byte, err error) {\n-\ts := new(big.Int).Exp(c1, priv.X, priv.P)\n-\ts.ModInverse(s, priv.P)\n-\ts.Mul(s, c2)\n-\ts.Mod(s, priv.P)\n-\tem := s.Bytes()\n-\n-\tfirstByteIsTwo := subtle.ConstantTimeByteEq(em[0], 2)\n-\n-\t// The remainder of the plaintext must be a string of non-zero random\n-\t// octets, followed by a 0, followed by the message.\n-\t//   lookingForIndex: 1 iff we are still looking for the zero.\n-\t//   index: the offset of the first zero byte.\n-\tvar lookingForIndex, index int\n-\tlookingForIndex = 1\n-\n-\tfor i := 1; i < len(em); i++ {\n-\t\tequals0 := subtle.ConstantTimeByteEq(em[i], 0)\n-\t\tindex = subtle.ConstantTimeSelect(lookingForIndex&equals0, i, index)\n-\t\tlookingForIndex = subtle.ConstantTimeSelect(equals0, 0, lookingForIndex)\n-\t}\n-\n-\tif firstByteIsTwo != 1 || lookingForIndex != 0 || index < 9 {\n-\t\treturn nil, errors.New(\"elgamal: decryption error\")\n-\t}\n-\treturn em[index+1:], nil\n-}\n-\n-// nonZeroRandomBytes fills the given slice with non-zero random octets.\n-func nonZeroRandomBytes(s []byte, rand io.Reader) (err error) {\n-\t_, err = io.ReadFull(rand, s)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tfor i := 0; i < len(s); i++ {\n-\t\tfor s[i] == 0 {\n-\t\t\t_, err = io.ReadFull(rand, s[i:i+1])\n-\t\t\tif err != nil {\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\treturn\n-}"}, {"sha": "c4f99f5c48cd21ff31eb21353ffb76617aa5523b", "filename": "libgo/go/crypto/openpgp/elgamal/elgamal_test.go", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Felgamal%2Felgamal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Felgamal%2Felgamal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Felgamal%2Felgamal_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,49 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package elgamal\n-\n-import (\n-\t\"bytes\"\n-\t\"crypto/rand\"\n-\t\"math/big\"\n-\t\"testing\"\n-)\n-\n-// This is the 1024-bit MODP group from RFC 5114, section 2.1:\n-const primeHex = \"B10B8F96A080E01DDE92DE5EAE5D54EC52C99FBCFB06A3C69A6A9DCA52D23B616073E28675A23D189838EF1E2EE652C013ECB4AEA906112324975C3CD49B83BFACCBDD7D90C4BD7098488E9C219A73724EFFD6FAE5644738FAA31A4FF55BCCC0A151AF5F0DC8B4BD45BF37DF365C1A65E68CFDA76D4DA708DF1FB2BC2E4A4371\"\n-\n-const generatorHex = \"A4D1CBD5C3FD34126765A442EFB99905F8104DD258AC507FD6406CFF14266D31266FEA1E5C41564B777E690F5504F213160217B4B01B886A5E91547F9E2749F4D7FBD7D3B9A92EE1909D0D2263F80A76A6A24C087A091F531DBF0A0169B6A28AD662A4D18E73AFA32D779D5918D08BC8858F4DCEF97C2A24855E6EEB22B3B2E5\"\n-\n-func fromHex(hex string) *big.Int {\n-\tn, ok := new(big.Int).SetString(hex, 16)\n-\tif !ok {\n-\t\tpanic(\"failed to parse hex number\")\n-\t}\n-\treturn n\n-}\n-\n-func TestEncryptDecrypt(t *testing.T) {\n-\tpriv := &PrivateKey{\n-\t\tPublicKey: PublicKey{\n-\t\t\tG: fromHex(generatorHex),\n-\t\t\tP: fromHex(primeHex),\n-\t\t},\n-\t\tX: fromHex(\"42\"),\n-\t}\n-\tpriv.Y = new(big.Int).Exp(priv.G, priv.X, priv.P)\n-\n-\tmessage := []byte(\"hello world\")\n-\tc1, c2, err := Encrypt(rand.Reader, &priv.PublicKey, message)\n-\tif err != nil {\n-\t\tt.Errorf(\"error encrypting: %s\", err)\n-\t}\n-\tmessage2, err := Decrypt(priv, c1, c2)\n-\tif err != nil {\n-\t\tt.Errorf(\"error decrypting: %s\", err)\n-\t}\n-\tif !bytes.Equal(message2, message) {\n-\t\tt.Errorf(\"decryption failed, got: %x, want: %x\", message2, message)\n-\t}\n-}"}, {"sha": "c434b764c9b2a621814be42ef537ce8aa5a44b63", "filename": "libgo/go/crypto/openpgp/errors/errors.go", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Ferrors%2Ferrors.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Ferrors%2Ferrors.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Ferrors%2Ferrors.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,64 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package errors contains common error types for the OpenPGP packages.\n-package errors\n-\n-import (\n-\t\"strconv\"\n-)\n-\n-// A StructuralError is returned when OpenPGP data is found to be syntactically\n-// invalid.\n-type StructuralError string\n-\n-func (s StructuralError) Error() string {\n-\treturn \"OpenPGP data invalid: \" + string(s)\n-}\n-\n-// UnsupportedError indicates that, although the OpenPGP data is valid, it\n-// makes use of currently unimplemented features.\n-type UnsupportedError string\n-\n-func (s UnsupportedError) Error() string {\n-\treturn \"OpenPGP feature unsupported: \" + string(s)\n-}\n-\n-// InvalidArgumentError indicates that the caller is in error and passed an\n-// incorrect value.\n-type InvalidArgumentError string\n-\n-func (i InvalidArgumentError) Error() string {\n-\treturn \"OpenPGP argument invalid: \" + string(i)\n-}\n-\n-// SignatureError indicates that a syntactically valid signature failed to\n-// validate.\n-type SignatureError string\n-\n-func (b SignatureError) Error() string {\n-\treturn \"OpenPGP signature invalid: \" + string(b)\n-}\n-\n-type keyIncorrectError int\n-\n-func (ki keyIncorrectError) Error() string {\n-\treturn \"the given key was incorrect\"\n-}\n-\n-var KeyIncorrectError = keyIncorrectError(0)\n-\n-type unknownIssuerError int\n-\n-func (unknownIssuerError) Error() string {\n-\treturn \"signature make by unknown entity\"\n-}\n-\n-var UnknownIssuerError = unknownIssuerError(0)\n-\n-type UnknownPacketTypeError uint8\n-\n-func (upte UnknownPacketTypeError) Error() string {\n-\treturn \"unknown OpenPGP packet type: \" + strconv.Itoa(int(upte))\n-}"}, {"sha": "624a5ea8a769c6481458ef0a2baec21a5874db2f", "filename": "libgo/go/crypto/openpgp/keys.go", "status": "removed", "additions": 0, "deletions": 546, "changes": 546, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,546 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package openpgp\n-\n-import (\n-\t\"crypto\"\n-\t\"crypto/openpgp/armor\"\n-\t\"crypto/openpgp/errors\"\n-\t\"crypto/openpgp/packet\"\n-\t\"crypto/rand\"\n-\t\"crypto/rsa\"\n-\t\"io\"\n-\t\"time\"\n-)\n-\n-// PublicKeyType is the armor type for a PGP public key.\n-var PublicKeyType = \"PGP PUBLIC KEY BLOCK\"\n-\n-// PrivateKeyType is the armor type for a PGP private key.\n-var PrivateKeyType = \"PGP PRIVATE KEY BLOCK\"\n-\n-// An Entity represents the components of an OpenPGP key: a primary public key\n-// (which must be a signing key), one or more identities claimed by that key,\n-// and zero or more subkeys, which may be encryption keys.\n-type Entity struct {\n-\tPrimaryKey *packet.PublicKey\n-\tPrivateKey *packet.PrivateKey\n-\tIdentities map[string]*Identity // indexed by Identity.Name\n-\tSubkeys    []Subkey\n-}\n-\n-// An Identity represents an identity claimed by an Entity and zero or more\n-// assertions by other entities about that claim.\n-type Identity struct {\n-\tName          string // by convention, has the form \"Full Name (comment) <email@example.com>\"\n-\tUserId        *packet.UserId\n-\tSelfSignature *packet.Signature\n-\tSignatures    []*packet.Signature\n-}\n-\n-// A Subkey is an additional public key in an Entity. Subkeys can be used for\n-// encryption.\n-type Subkey struct {\n-\tPublicKey  *packet.PublicKey\n-\tPrivateKey *packet.PrivateKey\n-\tSig        *packet.Signature\n-}\n-\n-// A Key identifies a specific public key in an Entity. This is either the\n-// Entity's primary key or a subkey.\n-type Key struct {\n-\tEntity        *Entity\n-\tPublicKey     *packet.PublicKey\n-\tPrivateKey    *packet.PrivateKey\n-\tSelfSignature *packet.Signature\n-}\n-\n-// A KeyRing provides access to public and private keys.\n-type KeyRing interface {\n-\t// KeysById returns the set of keys that have the given key id.\n-\tKeysById(id uint64) []Key\n-\t// DecryptionKeys returns all private keys that are valid for\n-\t// decryption.\n-\tDecryptionKeys() []Key\n-}\n-\n-// primaryIdentity returns the Identity marked as primary or the first identity\n-// if none are so marked.\n-func (e *Entity) primaryIdentity() *Identity {\n-\tvar firstIdentity *Identity\n-\tfor _, ident := range e.Identities {\n-\t\tif firstIdentity == nil {\n-\t\t\tfirstIdentity = ident\n-\t\t}\n-\t\tif ident.SelfSignature.IsPrimaryId != nil && *ident.SelfSignature.IsPrimaryId {\n-\t\t\treturn ident\n-\t\t}\n-\t}\n-\treturn firstIdentity\n-}\n-\n-// encryptionKey returns the best candidate Key for encrypting a message to the\n-// given Entity.\n-func (e *Entity) encryptionKey() Key {\n-\tcandidateSubkey := -1\n-\n-\tfor i, subkey := range e.Subkeys {\n-\t\tif subkey.Sig.FlagsValid && subkey.Sig.FlagEncryptCommunications && subkey.PublicKey.PubKeyAlgo.CanEncrypt() {\n-\t\t\tcandidateSubkey = i\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\n-\ti := e.primaryIdentity()\n-\n-\tif e.PrimaryKey.PubKeyAlgo.CanEncrypt() {\n-\t\t// If we don't have any candidate subkeys for encryption and\n-\t\t// the primary key doesn't have any usage metadata then we\n-\t\t// assume that the primary key is ok. Or, if the primary key is\n-\t\t// marked as ok to encrypt to, then we can obviously use it.\n-\t\tif candidateSubkey == -1 && !i.SelfSignature.FlagsValid || i.SelfSignature.FlagEncryptCommunications && i.SelfSignature.FlagsValid {\n-\t\t\treturn Key{e, e.PrimaryKey, e.PrivateKey, i.SelfSignature}\n-\t\t}\n-\t}\n-\n-\tif candidateSubkey != -1 {\n-\t\tsubkey := e.Subkeys[candidateSubkey]\n-\t\treturn Key{e, subkey.PublicKey, subkey.PrivateKey, subkey.Sig}\n-\t}\n-\n-\t// This Entity appears to be signing only.\n-\treturn Key{}\n-}\n-\n-// signingKey return the best candidate Key for signing a message with this\n-// Entity.\n-func (e *Entity) signingKey() Key {\n-\tcandidateSubkey := -1\n-\n-\tfor i, subkey := range e.Subkeys {\n-\t\tif subkey.Sig.FlagsValid && subkey.Sig.FlagSign && subkey.PublicKey.PubKeyAlgo.CanSign() {\n-\t\t\tcandidateSubkey = i\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\n-\ti := e.primaryIdentity()\n-\n-\t// If we have no candidate subkey then we assume that it's ok to sign\n-\t// with the primary key.\n-\tif candidateSubkey == -1 || i.SelfSignature.FlagsValid && i.SelfSignature.FlagSign {\n-\t\treturn Key{e, e.PrimaryKey, e.PrivateKey, i.SelfSignature}\n-\t}\n-\n-\tsubkey := e.Subkeys[candidateSubkey]\n-\treturn Key{e, subkey.PublicKey, subkey.PrivateKey, subkey.Sig}\n-}\n-\n-// An EntityList contains one or more Entities.\n-type EntityList []*Entity\n-\n-// KeysById returns the set of keys that have the given key id.\n-func (el EntityList) KeysById(id uint64) (keys []Key) {\n-\tfor _, e := range el {\n-\t\tif e.PrimaryKey.KeyId == id {\n-\t\t\tvar selfSig *packet.Signature\n-\t\t\tfor _, ident := range e.Identities {\n-\t\t\t\tif selfSig == nil {\n-\t\t\t\t\tselfSig = ident.SelfSignature\n-\t\t\t\t} else if ident.SelfSignature.IsPrimaryId != nil && *ident.SelfSignature.IsPrimaryId {\n-\t\t\t\t\tselfSig = ident.SelfSignature\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tkeys = append(keys, Key{e, e.PrimaryKey, e.PrivateKey, selfSig})\n-\t\t}\n-\n-\t\tfor _, subKey := range e.Subkeys {\n-\t\t\tif subKey.PublicKey.KeyId == id {\n-\t\t\t\tkeys = append(keys, Key{e, subKey.PublicKey, subKey.PrivateKey, subKey.Sig})\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-// DecryptionKeys returns all private keys that are valid for decryption.\n-func (el EntityList) DecryptionKeys() (keys []Key) {\n-\tfor _, e := range el {\n-\t\tfor _, subKey := range e.Subkeys {\n-\t\t\tif subKey.PrivateKey != nil && (!subKey.Sig.FlagsValid || subKey.Sig.FlagEncryptStorage || subKey.Sig.FlagEncryptCommunications) {\n-\t\t\t\tkeys = append(keys, Key{e, subKey.PublicKey, subKey.PrivateKey, subKey.Sig})\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-// ReadArmoredKeyRing reads one or more public/private keys from an armor keyring file.\n-func ReadArmoredKeyRing(r io.Reader) (EntityList, error) {\n-\tblock, err := armor.Decode(r)\n-\tif err == io.EOF {\n-\t\treturn nil, errors.InvalidArgumentError(\"no armored data found\")\n-\t}\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tif block.Type != PublicKeyType && block.Type != PrivateKeyType {\n-\t\treturn nil, errors.InvalidArgumentError(\"expected public or private key block, got: \" + block.Type)\n-\t}\n-\n-\treturn ReadKeyRing(block.Body)\n-}\n-\n-// ReadKeyRing reads one or more public/private keys. Unsupported keys are\n-// ignored as long as at least a single valid key is found.\n-func ReadKeyRing(r io.Reader) (el EntityList, err error) {\n-\tpackets := packet.NewReader(r)\n-\tvar lastUnsupportedError error\n-\n-\tfor {\n-\t\tvar e *Entity\n-\t\te, err = readEntity(packets)\n-\t\tif err != nil {\n-\t\t\tif _, ok := err.(errors.UnsupportedError); ok {\n-\t\t\t\tlastUnsupportedError = err\n-\t\t\t\terr = readToNextPublicKey(packets)\n-\t\t\t}\n-\t\t\tif err == io.EOF {\n-\t\t\t\terr = nil\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tif err != nil {\n-\t\t\t\tel = nil\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t} else {\n-\t\t\tel = append(el, e)\n-\t\t}\n-\t}\n-\n-\tif len(el) == 0 && err == nil {\n-\t\terr = lastUnsupportedError\n-\t}\n-\treturn\n-}\n-\n-// readToNextPublicKey reads packets until the start of the entity and leaves\n-// the first packet of the new entity in the Reader.\n-func readToNextPublicKey(packets *packet.Reader) (err error) {\n-\tvar p packet.Packet\n-\tfor {\n-\t\tp, err = packets.Next()\n-\t\tif err == io.EOF {\n-\t\t\treturn\n-\t\t} else if err != nil {\n-\t\t\tif _, ok := err.(errors.UnsupportedError); ok {\n-\t\t\t\terr = nil\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\treturn\n-\t\t}\n-\n-\t\tif pk, ok := p.(*packet.PublicKey); ok && !pk.IsSubkey {\n-\t\t\tpackets.Unread(p)\n-\t\t\treturn\n-\t\t}\n-\t}\n-\n-\tpanic(\"unreachable\")\n-}\n-\n-// readEntity reads an entity (public key, identities, subkeys etc) from the\n-// given Reader.\n-func readEntity(packets *packet.Reader) (*Entity, error) {\n-\te := new(Entity)\n-\te.Identities = make(map[string]*Identity)\n-\n-\tp, err := packets.Next()\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tvar ok bool\n-\tif e.PrimaryKey, ok = p.(*packet.PublicKey); !ok {\n-\t\tif e.PrivateKey, ok = p.(*packet.PrivateKey); !ok {\n-\t\t\tpackets.Unread(p)\n-\t\t\treturn nil, errors.StructuralError(\"first packet was not a public/private key\")\n-\t\t} else {\n-\t\t\te.PrimaryKey = &e.PrivateKey.PublicKey\n-\t\t}\n-\t}\n-\n-\tif !e.PrimaryKey.PubKeyAlgo.CanSign() {\n-\t\treturn nil, errors.StructuralError(\"primary key cannot be used for signatures\")\n-\t}\n-\n-\tvar current *Identity\n-EachPacket:\n-\tfor {\n-\t\tp, err := packets.Next()\n-\t\tif err == io.EOF {\n-\t\t\tbreak\n-\t\t} else if err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\tswitch pkt := p.(type) {\n-\t\tcase *packet.UserId:\n-\t\t\tcurrent = new(Identity)\n-\t\t\tcurrent.Name = pkt.Id\n-\t\t\tcurrent.UserId = pkt\n-\t\t\te.Identities[pkt.Id] = current\n-\n-\t\t\tfor {\n-\t\t\t\tp, err = packets.Next()\n-\t\t\t\tif err == io.EOF {\n-\t\t\t\t\treturn nil, io.ErrUnexpectedEOF\n-\t\t\t\t} else if err != nil {\n-\t\t\t\t\treturn nil, err\n-\t\t\t\t}\n-\n-\t\t\t\tsig, ok := p.(*packet.Signature)\n-\t\t\t\tif !ok {\n-\t\t\t\t\treturn nil, errors.StructuralError(\"user ID packet not followed by self-signature\")\n-\t\t\t\t}\n-\n-\t\t\t\tif (sig.SigType == packet.SigTypePositiveCert || sig.SigType == packet.SigTypeGenericCert) && sig.IssuerKeyId != nil && *sig.IssuerKeyId == e.PrimaryKey.KeyId {\n-\t\t\t\t\tif err = e.PrimaryKey.VerifyUserIdSignature(pkt.Id, sig); err != nil {\n-\t\t\t\t\t\treturn nil, errors.StructuralError(\"user ID self-signature invalid: \" + err.Error())\n-\t\t\t\t\t}\n-\t\t\t\t\tcurrent.SelfSignature = sig\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t\tcurrent.Signatures = append(current.Signatures, sig)\n-\t\t\t}\n-\t\tcase *packet.Signature:\n-\t\t\tif current == nil {\n-\t\t\t\treturn nil, errors.StructuralError(\"signature packet found before user id packet\")\n-\t\t\t}\n-\t\t\tcurrent.Signatures = append(current.Signatures, pkt)\n-\t\tcase *packet.PrivateKey:\n-\t\t\tif pkt.IsSubkey == false {\n-\t\t\t\tpackets.Unread(p)\n-\t\t\t\tbreak EachPacket\n-\t\t\t}\n-\t\t\terr = addSubkey(e, packets, &pkt.PublicKey, pkt)\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\tcase *packet.PublicKey:\n-\t\t\tif pkt.IsSubkey == false {\n-\t\t\t\tpackets.Unread(p)\n-\t\t\t\tbreak EachPacket\n-\t\t\t}\n-\t\t\terr = addSubkey(e, packets, pkt, nil)\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\tdefault:\n-\t\t\t// we ignore unknown packets\n-\t\t}\n-\t}\n-\n-\tif len(e.Identities) == 0 {\n-\t\treturn nil, errors.StructuralError(\"entity without any identities\")\n-\t}\n-\n-\treturn e, nil\n-}\n-\n-func addSubkey(e *Entity, packets *packet.Reader, pub *packet.PublicKey, priv *packet.PrivateKey) error {\n-\tvar subKey Subkey\n-\tsubKey.PublicKey = pub\n-\tsubKey.PrivateKey = priv\n-\tp, err := packets.Next()\n-\tif err == io.EOF {\n-\t\treturn io.ErrUnexpectedEOF\n-\t}\n-\tif err != nil {\n-\t\treturn errors.StructuralError(\"subkey signature invalid: \" + err.Error())\n-\t}\n-\tvar ok bool\n-\tsubKey.Sig, ok = p.(*packet.Signature)\n-\tif !ok {\n-\t\treturn errors.StructuralError(\"subkey packet not followed by signature\")\n-\t}\n-\tif subKey.Sig.SigType != packet.SigTypeSubkeyBinding {\n-\t\treturn errors.StructuralError(\"subkey signature with wrong type\")\n-\t}\n-\terr = e.PrimaryKey.VerifyKeySignature(subKey.PublicKey, subKey.Sig)\n-\tif err != nil {\n-\t\treturn errors.StructuralError(\"subkey signature invalid: \" + err.Error())\n-\t}\n-\te.Subkeys = append(e.Subkeys, subKey)\n-\treturn nil\n-}\n-\n-const defaultRSAKeyBits = 2048\n-\n-// NewEntity returns an Entity that contains a fresh RSA/RSA keypair with a\n-// single identity composed of the given full name, comment and email, any of\n-// which may be empty but must not contain any of \"()<>\\x00\".\n-func NewEntity(rand io.Reader, currentTime time.Time, name, comment, email string) (*Entity, error) {\n-\tuid := packet.NewUserId(name, comment, email)\n-\tif uid == nil {\n-\t\treturn nil, errors.InvalidArgumentError(\"user id field contained invalid characters\")\n-\t}\n-\tsigningPriv, err := rsa.GenerateKey(rand, defaultRSAKeyBits)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tencryptingPriv, err := rsa.GenerateKey(rand, defaultRSAKeyBits)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\te := &Entity{\n-\t\tPrimaryKey: packet.NewRSAPublicKey(currentTime, &signingPriv.PublicKey),\n-\t\tPrivateKey: packet.NewRSAPrivateKey(currentTime, signingPriv),\n-\t\tIdentities: make(map[string]*Identity),\n-\t}\n-\tisPrimaryId := true\n-\te.Identities[uid.Id] = &Identity{\n-\t\tName:   uid.Name,\n-\t\tUserId: uid,\n-\t\tSelfSignature: &packet.Signature{\n-\t\t\tCreationTime: currentTime,\n-\t\t\tSigType:      packet.SigTypePositiveCert,\n-\t\t\tPubKeyAlgo:   packet.PubKeyAlgoRSA,\n-\t\t\tHash:         crypto.SHA256,\n-\t\t\tIsPrimaryId:  &isPrimaryId,\n-\t\t\tFlagsValid:   true,\n-\t\t\tFlagSign:     true,\n-\t\t\tFlagCertify:  true,\n-\t\t\tIssuerKeyId:  &e.PrimaryKey.KeyId,\n-\t\t},\n-\t}\n-\n-\te.Subkeys = make([]Subkey, 1)\n-\te.Subkeys[0] = Subkey{\n-\t\tPublicKey:  packet.NewRSAPublicKey(currentTime, &encryptingPriv.PublicKey),\n-\t\tPrivateKey: packet.NewRSAPrivateKey(currentTime, encryptingPriv),\n-\t\tSig: &packet.Signature{\n-\t\t\tCreationTime:              currentTime,\n-\t\t\tSigType:                   packet.SigTypeSubkeyBinding,\n-\t\t\tPubKeyAlgo:                packet.PubKeyAlgoRSA,\n-\t\t\tHash:                      crypto.SHA256,\n-\t\t\tFlagsValid:                true,\n-\t\t\tFlagEncryptStorage:        true,\n-\t\t\tFlagEncryptCommunications: true,\n-\t\t\tIssuerKeyId:               &e.PrimaryKey.KeyId,\n-\t\t},\n-\t}\n-\te.Subkeys[0].PublicKey.IsSubkey = true\n-\te.Subkeys[0].PrivateKey.IsSubkey = true\n-\n-\treturn e, nil\n-}\n-\n-// SerializePrivate serializes an Entity, including private key material, to\n-// the given Writer. For now, it must only be used on an Entity returned from\n-// NewEntity.\n-func (e *Entity) SerializePrivate(w io.Writer) (err error) {\n-\terr = e.PrivateKey.Serialize(w)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tfor _, ident := range e.Identities {\n-\t\terr = ident.UserId.Serialize(w)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\terr = ident.SelfSignature.SignUserId(rand.Reader, ident.UserId.Id, e.PrimaryKey, e.PrivateKey)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\terr = ident.SelfSignature.Serialize(w)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\tfor _, subkey := range e.Subkeys {\n-\t\terr = subkey.PrivateKey.Serialize(w)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\terr = subkey.Sig.SignKey(rand.Reader, subkey.PublicKey, e.PrivateKey)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\terr = subkey.Sig.Serialize(w)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\treturn nil\n-}\n-\n-// Serialize writes the public part of the given Entity to w. (No private\n-// key material will be output).\n-func (e *Entity) Serialize(w io.Writer) error {\n-\terr := e.PrimaryKey.Serialize(w)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tfor _, ident := range e.Identities {\n-\t\terr = ident.UserId.Serialize(w)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\terr = ident.SelfSignature.Serialize(w)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tfor _, sig := range ident.Signatures {\n-\t\t\terr = sig.Serialize(w)\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t}\n-\t}\n-\tfor _, subkey := range e.Subkeys {\n-\t\terr = subkey.PublicKey.Serialize(w)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\terr = subkey.Sig.Serialize(w)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\treturn nil\n-}\n-\n-// SignIdentity adds a signature to e, from signer, attesting that identity is\n-// associated with e. The provided identity must already be an element of\n-// e.Identities and the private key of signer must have been decrypted if\n-// necessary.\n-func (e *Entity) SignIdentity(identity string, signer *Entity) error {\n-\tif signer.PrivateKey == nil {\n-\t\treturn errors.InvalidArgumentError(\"signing Entity must have a private key\")\n-\t}\n-\tif signer.PrivateKey.Encrypted {\n-\t\treturn errors.InvalidArgumentError(\"signing Entity's private key must be decrypted\")\n-\t}\n-\tident, ok := e.Identities[identity]\n-\tif !ok {\n-\t\treturn errors.InvalidArgumentError(\"given identity string not found in Entity\")\n-\t}\n-\n-\tsig := &packet.Signature{\n-\t\tSigType:      packet.SigTypeGenericCert,\n-\t\tPubKeyAlgo:   signer.PrivateKey.PubKeyAlgo,\n-\t\tHash:         crypto.SHA256,\n-\t\tCreationTime: time.Now(),\n-\t\tIssuerKeyId:  &signer.PrivateKey.KeyId,\n-\t}\n-\tif err := sig.SignKey(rand.Reader, e.PrimaryKey, signer.PrivateKey); err != nil {\n-\t\treturn err\n-\t}\n-\tident.Signatures = append(ident.Signatures, sig)\n-\treturn nil\n-}"}, {"sha": "36736e34a0edcd7a153fc8c38a2000a77ca5cd47", "filename": "libgo/go/crypto/openpgp/packet/compressed.go", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fcompressed.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fcompressed.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fcompressed.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,38 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package packet\n-\n-import (\n-\t\"compress/flate\"\n-\t\"compress/zlib\"\n-\t\"crypto/openpgp/errors\"\n-\t\"io\"\n-\t\"strconv\"\n-)\n-\n-// Compressed represents a compressed OpenPGP packet. The decompressed contents\n-// will contain more OpenPGP packets. See RFC 4880, section 5.6.\n-type Compressed struct {\n-\tBody io.Reader\n-}\n-\n-func (c *Compressed) parse(r io.Reader) error {\n-\tvar buf [1]byte\n-\t_, err := readFull(r, buf[:])\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\tswitch buf[0] {\n-\tcase 1:\n-\t\tc.Body = flate.NewReader(r)\n-\tcase 2:\n-\t\tc.Body, err = zlib.NewReader(r)\n-\tdefault:\n-\t\terr = errors.UnsupportedError(\"unknown compression algorithm: \" + strconv.Itoa(int(buf[0])))\n-\t}\n-\n-\treturn err\n-}"}, {"sha": "cb2d70bd411a131bdae47e94aade6594d443b440", "filename": "libgo/go/crypto/openpgp/packet/compressed_test.go", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fcompressed_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fcompressed_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fcompressed_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,41 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package packet\n-\n-import (\n-\t\"bytes\"\n-\t\"encoding/hex\"\n-\t\"io\"\n-\t\"io/ioutil\"\n-\t\"testing\"\n-)\n-\n-func TestCompressed(t *testing.T) {\n-\tpacket, err := Read(readerFromHex(compressedHex))\n-\tif err != nil {\n-\t\tt.Errorf(\"failed to read Compressed: %s\", err)\n-\t\treturn\n-\t}\n-\n-\tc, ok := packet.(*Compressed)\n-\tif !ok {\n-\t\tt.Error(\"didn't find Compressed packet\")\n-\t\treturn\n-\t}\n-\n-\tcontents, err := ioutil.ReadAll(c.Body)\n-\tif err != nil && err != io.EOF {\n-\t\tt.Error(err)\n-\t\treturn\n-\t}\n-\n-\texpected, _ := hex.DecodeString(compressedExpectedHex)\n-\tif !bytes.Equal(expected, contents) {\n-\t\tt.Errorf(\"got:%x want:%x\", contents, expected)\n-\t}\n-}\n-\n-const compressedHex = \"a3013b2d90c4e02b72e25f727e5e496a5e49b11e1700\"\n-const compressedExpectedHex = \"cb1062004d14c8fe636f6e74656e74732e0a\""}, {"sha": "479a643935ed1aae47333ae08616c0447ac99f5f", "filename": "libgo/go/crypto/openpgp/packet/encrypted_key.go", "status": "removed", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,167 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package packet\n-\n-import (\n-\t\"crypto/openpgp/elgamal\"\n-\t\"crypto/openpgp/errors\"\n-\t\"crypto/rand\"\n-\t\"crypto/rsa\"\n-\t\"encoding/binary\"\n-\t\"io\"\n-\t\"math/big\"\n-\t\"strconv\"\n-)\n-\n-const encryptedKeyVersion = 3\n-\n-// EncryptedKey represents a public-key encrypted session key. See RFC 4880,\n-// section 5.1.\n-type EncryptedKey struct {\n-\tKeyId      uint64\n-\tAlgo       PublicKeyAlgorithm\n-\tCipherFunc CipherFunction // only valid after a successful Decrypt\n-\tKey        []byte         // only valid after a successful Decrypt\n-\n-\tencryptedMPI1, encryptedMPI2 []byte\n-}\n-\n-func (e *EncryptedKey) parse(r io.Reader) (err error) {\n-\tvar buf [10]byte\n-\t_, err = readFull(r, buf[:])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tif buf[0] != encryptedKeyVersion {\n-\t\treturn errors.UnsupportedError(\"unknown EncryptedKey version \" + strconv.Itoa(int(buf[0])))\n-\t}\n-\te.KeyId = binary.BigEndian.Uint64(buf[1:9])\n-\te.Algo = PublicKeyAlgorithm(buf[9])\n-\tswitch e.Algo {\n-\tcase PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly:\n-\t\te.encryptedMPI1, _, err = readMPI(r)\n-\tcase PubKeyAlgoElGamal:\n-\t\te.encryptedMPI1, _, err = readMPI(r)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\te.encryptedMPI2, _, err = readMPI(r)\n-\t}\n-\t_, err = consumeAll(r)\n-\treturn\n-}\n-\n-func checksumKeyMaterial(key []byte) uint16 {\n-\tvar checksum uint16\n-\tfor _, v := range key {\n-\t\tchecksum += uint16(v)\n-\t}\n-\treturn checksum\n-}\n-\n-// Decrypt decrypts an encrypted session key with the given private key. The\n-// private key must have been decrypted first.\n-func (e *EncryptedKey) Decrypt(priv *PrivateKey) error {\n-\tvar err error\n-\tvar b []byte\n-\n-\t// TODO(agl): use session key decryption routines here to avoid\n-\t// padding oracle attacks.\n-\tswitch priv.PubKeyAlgo {\n-\tcase PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly:\n-\t\tb, err = rsa.DecryptPKCS1v15(rand.Reader, priv.PrivateKey.(*rsa.PrivateKey), e.encryptedMPI1)\n-\tcase PubKeyAlgoElGamal:\n-\t\tc1 := new(big.Int).SetBytes(e.encryptedMPI1)\n-\t\tc2 := new(big.Int).SetBytes(e.encryptedMPI2)\n-\t\tb, err = elgamal.Decrypt(priv.PrivateKey.(*elgamal.PrivateKey), c1, c2)\n-\tdefault:\n-\t\terr = errors.InvalidArgumentError(\"cannot decrypted encrypted session key with private key of type \" + strconv.Itoa(int(priv.PubKeyAlgo)))\n-\t}\n-\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\te.CipherFunc = CipherFunction(b[0])\n-\te.Key = b[1 : len(b)-2]\n-\texpectedChecksum := uint16(b[len(b)-2])<<8 | uint16(b[len(b)-1])\n-\tchecksum := checksumKeyMaterial(e.Key)\n-\tif checksum != expectedChecksum {\n-\t\treturn errors.StructuralError(\"EncryptedKey checksum incorrect\")\n-\t}\n-\n-\treturn nil\n-}\n-\n-// SerializeEncryptedKey serializes an encrypted key packet to w that contains\n-// key, encrypted to pub.\n-func SerializeEncryptedKey(w io.Writer, rand io.Reader, pub *PublicKey, cipherFunc CipherFunction, key []byte) error {\n-\tvar buf [10]byte\n-\tbuf[0] = encryptedKeyVersion\n-\tbinary.BigEndian.PutUint64(buf[1:9], pub.KeyId)\n-\tbuf[9] = byte(pub.PubKeyAlgo)\n-\n-\tkeyBlock := make([]byte, 1 /* cipher type */ +len(key)+2 /* checksum */ )\n-\tkeyBlock[0] = byte(cipherFunc)\n-\tcopy(keyBlock[1:], key)\n-\tchecksum := checksumKeyMaterial(key)\n-\tkeyBlock[1+len(key)] = byte(checksum >> 8)\n-\tkeyBlock[1+len(key)+1] = byte(checksum)\n-\n-\tswitch pub.PubKeyAlgo {\n-\tcase PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly:\n-\t\treturn serializeEncryptedKeyRSA(w, rand, buf, pub.PublicKey.(*rsa.PublicKey), keyBlock)\n-\tcase PubKeyAlgoElGamal:\n-\t\treturn serializeEncryptedKeyElGamal(w, rand, buf, pub.PublicKey.(*elgamal.PublicKey), keyBlock)\n-\tcase PubKeyAlgoDSA, PubKeyAlgoRSASignOnly:\n-\t\treturn errors.InvalidArgumentError(\"cannot encrypt to public key of type \" + strconv.Itoa(int(pub.PubKeyAlgo)))\n-\t}\n-\n-\treturn errors.UnsupportedError(\"encrypting a key to public key of type \" + strconv.Itoa(int(pub.PubKeyAlgo)))\n-}\n-\n-func serializeEncryptedKeyRSA(w io.Writer, rand io.Reader, header [10]byte, pub *rsa.PublicKey, keyBlock []byte) error {\n-\tcipherText, err := rsa.EncryptPKCS1v15(rand, pub, keyBlock)\n-\tif err != nil {\n-\t\treturn errors.InvalidArgumentError(\"RSA encryption failed: \" + err.Error())\n-\t}\n-\n-\tpacketLen := 10 /* header length */ + 2 /* mpi size */ + len(cipherText)\n-\n-\terr = serializeHeader(w, packetTypeEncryptedKey, packetLen)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\t_, err = w.Write(header[:])\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn writeMPI(w, 8*uint16(len(cipherText)), cipherText)\n-}\n-\n-func serializeEncryptedKeyElGamal(w io.Writer, rand io.Reader, header [10]byte, pub *elgamal.PublicKey, keyBlock []byte) error {\n-\tc1, c2, err := elgamal.Encrypt(rand, pub, keyBlock)\n-\tif err != nil {\n-\t\treturn errors.InvalidArgumentError(\"ElGamal encryption failed: \" + err.Error())\n-\t}\n-\n-\tpacketLen := 10 /* header length */\n-\tpacketLen += 2 /* mpi size */ + (c1.BitLen()+7)/8\n-\tpacketLen += 2 /* mpi size */ + (c2.BitLen()+7)/8\n-\n-\terr = serializeHeader(w, packetTypeEncryptedKey, packetLen)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\t_, err = w.Write(header[:])\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\terr = writeBig(w, c1)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn writeBig(w, c2)\n-}"}, {"sha": "2b8eff7b3a9a614c8ce7755b69d17c7024e4e6cd", "filename": "libgo/go/crypto/openpgp/packet/encrypted_key_test.go", "status": "removed", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,126 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package packet\n-\n-import (\n-\t\"bytes\"\n-\t\"crypto/rand\"\n-\t\"crypto/rsa\"\n-\t\"fmt\"\n-\t\"math/big\"\n-\t\"testing\"\n-)\n-\n-func bigFromBase10(s string) *big.Int {\n-\tb, ok := new(big.Int).SetString(s, 10)\n-\tif !ok {\n-\t\tpanic(\"bigFromBase10 failed\")\n-\t}\n-\treturn b\n-}\n-\n-var encryptedKeyPub = rsa.PublicKey{\n-\tE: 65537,\n-\tN: bigFromBase10(\"115804063926007623305902631768113868327816898845124614648849934718568541074358183759250136204762053879858102352159854352727097033322663029387610959884180306668628526686121021235757016368038585212410610742029286439607686208110250133174279811431933746643015923132833417396844716207301518956640020862630546868823\"),\n-}\n-\n-var encryptedKeyRSAPriv = &rsa.PrivateKey{\n-\tPublicKey: encryptedKeyPub,\n-\tD:         bigFromBase10(\"32355588668219869544751561565313228297765464314098552250409557267371233892496951383426602439009993875125222579159850054973310859166139474359774543943714622292329487391199285040721944491839695981199720170366763547754915493640685849961780092241140181198779299712578774460837139360803883139311171713302987058393\"),\n-}\n-\n-var encryptedKeyPriv = &PrivateKey{\n-\tPublicKey: PublicKey{\n-\t\tPubKeyAlgo: PubKeyAlgoRSA,\n-\t},\n-\tPrivateKey: encryptedKeyRSAPriv,\n-}\n-\n-func TestDecryptingEncryptedKey(t *testing.T) {\n-\tconst encryptedKeyHex = \"c18c032a67d68660df41c70104005789d0de26b6a50c985a02a13131ca829c413a35d0e6fa8d6842599252162808ac7439c72151c8c6183e76923fe3299301414d0c25a2f06a2257db3839e7df0ec964773f6e4c4ac7ff3b48c444237166dd46ba8ff443a5410dc670cb486672fdbe7c9dfafb75b4fea83af3a204fe2a7dfa86bd20122b4f3d2646cbeecb8f7be8\"\n-\tconst expectedKeyHex = \"d930363f7e0308c333b9618617ea728963d8df993665ae7be1092d4926fd864b\"\n-\n-\tp, err := Read(readerFromHex(encryptedKeyHex))\n-\tif err != nil {\n-\t\tt.Errorf(\"error from Read: %s\", err)\n-\t\treturn\n-\t}\n-\tek, ok := p.(*EncryptedKey)\n-\tif !ok {\n-\t\tt.Errorf(\"didn't parse an EncryptedKey, got %#v\", p)\n-\t\treturn\n-\t}\n-\n-\tif ek.KeyId != 0x2a67d68660df41c7 || ek.Algo != PubKeyAlgoRSA {\n-\t\tt.Errorf(\"unexpected EncryptedKey contents: %#v\", ek)\n-\t\treturn\n-\t}\n-\n-\terr = ek.Decrypt(encryptedKeyPriv)\n-\tif err != nil {\n-\t\tt.Errorf(\"error from Decrypt: %s\", err)\n-\t\treturn\n-\t}\n-\n-\tif ek.CipherFunc != CipherAES256 {\n-\t\tt.Errorf(\"unexpected EncryptedKey contents: %#v\", ek)\n-\t\treturn\n-\t}\n-\n-\tkeyHex := fmt.Sprintf(\"%x\", ek.Key)\n-\tif keyHex != expectedKeyHex {\n-\t\tt.Errorf(\"bad key, got %s want %x\", keyHex, expectedKeyHex)\n-\t}\n-}\n-\n-func TestEncryptingEncryptedKey(t *testing.T) {\n-\tkey := []byte{1, 2, 3, 4}\n-\tconst expectedKeyHex = \"01020304\"\n-\tconst keyId = 42\n-\n-\tpub := &PublicKey{\n-\t\tPublicKey:  &encryptedKeyPub,\n-\t\tKeyId:      keyId,\n-\t\tPubKeyAlgo: PubKeyAlgoRSAEncryptOnly,\n-\t}\n-\n-\tbuf := new(bytes.Buffer)\n-\terr := SerializeEncryptedKey(buf, rand.Reader, pub, CipherAES128, key)\n-\tif err != nil {\n-\t\tt.Errorf(\"error writing encrypted key packet: %s\", err)\n-\t}\n-\n-\tp, err := Read(buf)\n-\tif err != nil {\n-\t\tt.Errorf(\"error from Read: %s\", err)\n-\t\treturn\n-\t}\n-\tek, ok := p.(*EncryptedKey)\n-\tif !ok {\n-\t\tt.Errorf(\"didn't parse an EncryptedKey, got %#v\", p)\n-\t\treturn\n-\t}\n-\n-\tif ek.KeyId != keyId || ek.Algo != PubKeyAlgoRSAEncryptOnly {\n-\t\tt.Errorf(\"unexpected EncryptedKey contents: %#v\", ek)\n-\t\treturn\n-\t}\n-\n-\terr = ek.Decrypt(encryptedKeyPriv)\n-\tif err != nil {\n-\t\tt.Errorf(\"error from Decrypt: %s\", err)\n-\t\treturn\n-\t}\n-\n-\tif ek.CipherFunc != CipherAES128 {\n-\t\tt.Errorf(\"unexpected EncryptedKey contents: %#v\", ek)\n-\t\treturn\n-\t}\n-\n-\tkeyHex := fmt.Sprintf(\"%x\", ek.Key)\n-\tif keyHex != expectedKeyHex {\n-\t\tt.Errorf(\"bad key, got %s want %x\", keyHex, expectedKeyHex)\n-\t}\n-}"}, {"sha": "1a9ec6e51e81d482b056e5fb26bc8b5cd6643ee6", "filename": "libgo/go/crypto/openpgp/packet/literal.go", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fliteral.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fliteral.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fliteral.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,89 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package packet\n-\n-import (\n-\t\"encoding/binary\"\n-\t\"io\"\n-)\n-\n-// LiteralData represents an encrypted file. See RFC 4880, section 5.9.\n-type LiteralData struct {\n-\tIsBinary bool\n-\tFileName string\n-\tTime     uint32 // Unix epoch time. Either creation time or modification time. 0 means undefined.\n-\tBody     io.Reader\n-}\n-\n-// ForEyesOnly returns whether the contents of the LiteralData have been marked\n-// as especially sensitive.\n-func (l *LiteralData) ForEyesOnly() bool {\n-\treturn l.FileName == \"_CONSOLE\"\n-}\n-\n-func (l *LiteralData) parse(r io.Reader) (err error) {\n-\tvar buf [256]byte\n-\n-\t_, err = readFull(r, buf[:2])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tl.IsBinary = buf[0] == 'b'\n-\tfileNameLen := int(buf[1])\n-\n-\t_, err = readFull(r, buf[:fileNameLen])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tl.FileName = string(buf[:fileNameLen])\n-\n-\t_, err = readFull(r, buf[:4])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tl.Time = binary.BigEndian.Uint32(buf[:4])\n-\tl.Body = r\n-\treturn\n-}\n-\n-// SerializeLiteral serializes a literal data packet to w and returns a\n-// WriteCloser to which the data itself can be written and which MUST be closed\n-// on completion. The fileName is truncated to 255 bytes.\n-func SerializeLiteral(w io.WriteCloser, isBinary bool, fileName string, time uint32) (plaintext io.WriteCloser, err error) {\n-\tvar buf [4]byte\n-\tbuf[0] = 't'\n-\tif isBinary {\n-\t\tbuf[0] = 'b'\n-\t}\n-\tif len(fileName) > 255 {\n-\t\tfileName = fileName[:255]\n-\t}\n-\tbuf[1] = byte(len(fileName))\n-\n-\tinner, err := serializeStreamHeader(w, packetTypeLiteralData)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\t_, err = inner.Write(buf[:2])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\t_, err = inner.Write([]byte(fileName))\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tbinary.BigEndian.PutUint32(buf[:], time)\n-\t_, err = inner.Write(buf[:])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tplaintext = inner\n-\treturn\n-}"}, {"sha": "822cfe9b8f64ac559336d4a2771fb7078ffce96f", "filename": "libgo/go/crypto/openpgp/packet/one_pass_signature.go", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fone_pass_signature.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fone_pass_signature.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fone_pass_signature.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,73 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package packet\n-\n-import (\n-\t\"crypto\"\n-\t\"crypto/openpgp/errors\"\n-\t\"crypto/openpgp/s2k\"\n-\t\"encoding/binary\"\n-\t\"io\"\n-\t\"strconv\"\n-)\n-\n-// OnePassSignature represents a one-pass signature packet. See RFC 4880,\n-// section 5.4.\n-type OnePassSignature struct {\n-\tSigType    SignatureType\n-\tHash       crypto.Hash\n-\tPubKeyAlgo PublicKeyAlgorithm\n-\tKeyId      uint64\n-\tIsLast     bool\n-}\n-\n-const onePassSignatureVersion = 3\n-\n-func (ops *OnePassSignature) parse(r io.Reader) (err error) {\n-\tvar buf [13]byte\n-\n-\t_, err = readFull(r, buf[:])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tif buf[0] != onePassSignatureVersion {\n-\t\terr = errors.UnsupportedError(\"one-pass-signature packet version \" + strconv.Itoa(int(buf[0])))\n-\t}\n-\n-\tvar ok bool\n-\tops.Hash, ok = s2k.HashIdToHash(buf[2])\n-\tif !ok {\n-\t\treturn errors.UnsupportedError(\"hash function: \" + strconv.Itoa(int(buf[2])))\n-\t}\n-\n-\tops.SigType = SignatureType(buf[1])\n-\tops.PubKeyAlgo = PublicKeyAlgorithm(buf[3])\n-\tops.KeyId = binary.BigEndian.Uint64(buf[4:12])\n-\tops.IsLast = buf[12] != 0\n-\treturn\n-}\n-\n-// Serialize marshals the given OnePassSignature to w.\n-func (ops *OnePassSignature) Serialize(w io.Writer) error {\n-\tvar buf [13]byte\n-\tbuf[0] = onePassSignatureVersion\n-\tbuf[1] = uint8(ops.SigType)\n-\tvar ok bool\n-\tbuf[2], ok = s2k.HashToHashId(ops.Hash)\n-\tif !ok {\n-\t\treturn errors.UnsupportedError(\"hash type: \" + strconv.Itoa(int(ops.Hash)))\n-\t}\n-\tbuf[3] = uint8(ops.PubKeyAlgo)\n-\tbinary.BigEndian.PutUint64(buf[4:12], ops.KeyId)\n-\tif ops.IsLast {\n-\t\tbuf[12] = 1\n-\t}\n-\n-\tif err := serializeHeader(w, packetTypeOnePassSignature, len(buf)); err != nil {\n-\t\treturn err\n-\t}\n-\t_, err := w.Write(buf[:])\n-\treturn err\n-}"}, {"sha": "f7c1964fd4ca795226019f359e996d22ce2f20f8", "filename": "libgo/go/crypto/openpgp/packet/packet.go", "status": "removed", "additions": 0, "deletions": 482, "changes": 482, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,482 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package packet implements parsing and serialization of OpenPGP packets, as\n-// specified in RFC 4880.\n-package packet\n-\n-import (\n-\t\"crypto/aes\"\n-\t\"crypto/cast5\"\n-\t\"crypto/cipher\"\n-\t\"crypto/openpgp/errors\"\n-\t\"io\"\n-\t\"math/big\"\n-)\n-\n-// readFull is the same as io.ReadFull except that reading zero bytes returns\n-// ErrUnexpectedEOF rather than EOF.\n-func readFull(r io.Reader, buf []byte) (n int, err error) {\n-\tn, err = io.ReadFull(r, buf)\n-\tif err == io.EOF {\n-\t\terr = io.ErrUnexpectedEOF\n-\t}\n-\treturn\n-}\n-\n-// readLength reads an OpenPGP length from r. See RFC 4880, section 4.2.2.\n-func readLength(r io.Reader) (length int64, isPartial bool, err error) {\n-\tvar buf [4]byte\n-\t_, err = readFull(r, buf[:1])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tswitch {\n-\tcase buf[0] < 192:\n-\t\tlength = int64(buf[0])\n-\tcase buf[0] < 224:\n-\t\tlength = int64(buf[0]-192) << 8\n-\t\t_, err = readFull(r, buf[0:1])\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tlength += int64(buf[0]) + 192\n-\tcase buf[0] < 255:\n-\t\tlength = int64(1) << (buf[0] & 0x1f)\n-\t\tisPartial = true\n-\tdefault:\n-\t\t_, err = readFull(r, buf[0:4])\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tlength = int64(buf[0])<<24 |\n-\t\t\tint64(buf[1])<<16 |\n-\t\t\tint64(buf[2])<<8 |\n-\t\t\tint64(buf[3])\n-\t}\n-\treturn\n-}\n-\n-// partialLengthReader wraps an io.Reader and handles OpenPGP partial lengths.\n-// The continuation lengths are parsed and removed from the stream and EOF is\n-// returned at the end of the packet. See RFC 4880, section 4.2.2.4.\n-type partialLengthReader struct {\n-\tr         io.Reader\n-\tremaining int64\n-\tisPartial bool\n-}\n-\n-func (r *partialLengthReader) Read(p []byte) (n int, err error) {\n-\tfor r.remaining == 0 {\n-\t\tif !r.isPartial {\n-\t\t\treturn 0, io.EOF\n-\t\t}\n-\t\tr.remaining, r.isPartial, err = readLength(r.r)\n-\t\tif err != nil {\n-\t\t\treturn 0, err\n-\t\t}\n-\t}\n-\n-\ttoRead := int64(len(p))\n-\tif toRead > r.remaining {\n-\t\ttoRead = r.remaining\n-\t}\n-\n-\tn, err = r.r.Read(p[:int(toRead)])\n-\tr.remaining -= int64(n)\n-\tif n < int(toRead) && err == io.EOF {\n-\t\terr = io.ErrUnexpectedEOF\n-\t}\n-\treturn\n-}\n-\n-// partialLengthWriter writes a stream of data using OpenPGP partial lengths.\n-// See RFC 4880, section 4.2.2.4.\n-type partialLengthWriter struct {\n-\tw          io.WriteCloser\n-\tlengthByte [1]byte\n-}\n-\n-func (w *partialLengthWriter) Write(p []byte) (n int, err error) {\n-\tfor len(p) > 0 {\n-\t\tfor power := uint(14); power < 32; power-- {\n-\t\t\tl := 1 << power\n-\t\t\tif len(p) >= l {\n-\t\t\t\tw.lengthByte[0] = 224 + uint8(power)\n-\t\t\t\t_, err = w.w.Write(w.lengthByte[:])\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t\tvar m int\n-\t\t\t\tm, err = w.w.Write(p[:l])\n-\t\t\t\tn += m\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t\tp = p[l:]\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-func (w *partialLengthWriter) Close() error {\n-\tw.lengthByte[0] = 0\n-\t_, err := w.w.Write(w.lengthByte[:])\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn w.w.Close()\n-}\n-\n-// A spanReader is an io.LimitReader, but it returns ErrUnexpectedEOF if the\n-// underlying Reader returns EOF before the limit has been reached.\n-type spanReader struct {\n-\tr io.Reader\n-\tn int64\n-}\n-\n-func (l *spanReader) Read(p []byte) (n int, err error) {\n-\tif l.n <= 0 {\n-\t\treturn 0, io.EOF\n-\t}\n-\tif int64(len(p)) > l.n {\n-\t\tp = p[0:l.n]\n-\t}\n-\tn, err = l.r.Read(p)\n-\tl.n -= int64(n)\n-\tif l.n > 0 && err == io.EOF {\n-\t\terr = io.ErrUnexpectedEOF\n-\t}\n-\treturn\n-}\n-\n-// readHeader parses a packet header and returns an io.Reader which will return\n-// the contents of the packet. See RFC 4880, section 4.2.\n-func readHeader(r io.Reader) (tag packetType, length int64, contents io.Reader, err error) {\n-\tvar buf [4]byte\n-\t_, err = io.ReadFull(r, buf[:1])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tif buf[0]&0x80 == 0 {\n-\t\terr = errors.StructuralError(\"tag byte does not have MSB set\")\n-\t\treturn\n-\t}\n-\tif buf[0]&0x40 == 0 {\n-\t\t// Old format packet\n-\t\ttag = packetType((buf[0] & 0x3f) >> 2)\n-\t\tlengthType := buf[0] & 3\n-\t\tif lengthType == 3 {\n-\t\t\tlength = -1\n-\t\t\tcontents = r\n-\t\t\treturn\n-\t\t}\n-\t\tlengthBytes := 1 << lengthType\n-\t\t_, err = readFull(r, buf[0:lengthBytes])\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tfor i := 0; i < lengthBytes; i++ {\n-\t\t\tlength <<= 8\n-\t\t\tlength |= int64(buf[i])\n-\t\t}\n-\t\tcontents = &spanReader{r, length}\n-\t\treturn\n-\t}\n-\n-\t// New format packet\n-\ttag = packetType(buf[0] & 0x3f)\n-\tlength, isPartial, err := readLength(r)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tif isPartial {\n-\t\tcontents = &partialLengthReader{\n-\t\t\tremaining: length,\n-\t\t\tisPartial: true,\n-\t\t\tr:         r,\n-\t\t}\n-\t\tlength = -1\n-\t} else {\n-\t\tcontents = &spanReader{r, length}\n-\t}\n-\treturn\n-}\n-\n-// serializeHeader writes an OpenPGP packet header to w. See RFC 4880, section\n-// 4.2.\n-func serializeHeader(w io.Writer, ptype packetType, length int) (err error) {\n-\tvar buf [6]byte\n-\tvar n int\n-\n-\tbuf[0] = 0x80 | 0x40 | byte(ptype)\n-\tif length < 192 {\n-\t\tbuf[1] = byte(length)\n-\t\tn = 2\n-\t} else if length < 8384 {\n-\t\tlength -= 192\n-\t\tbuf[1] = 192 + byte(length>>8)\n-\t\tbuf[2] = byte(length)\n-\t\tn = 3\n-\t} else {\n-\t\tbuf[1] = 255\n-\t\tbuf[2] = byte(length >> 24)\n-\t\tbuf[3] = byte(length >> 16)\n-\t\tbuf[4] = byte(length >> 8)\n-\t\tbuf[5] = byte(length)\n-\t\tn = 6\n-\t}\n-\n-\t_, err = w.Write(buf[:n])\n-\treturn\n-}\n-\n-// serializeStreamHeader writes an OpenPGP packet header to w where the\n-// length of the packet is unknown. It returns a io.WriteCloser which can be\n-// used to write the contents of the packet. See RFC 4880, section 4.2.\n-func serializeStreamHeader(w io.WriteCloser, ptype packetType) (out io.WriteCloser, err error) {\n-\tvar buf [1]byte\n-\tbuf[0] = 0x80 | 0x40 | byte(ptype)\n-\t_, err = w.Write(buf[:])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tout = &partialLengthWriter{w: w}\n-\treturn\n-}\n-\n-// Packet represents an OpenPGP packet. Users are expected to try casting\n-// instances of this interface to specific packet types.\n-type Packet interface {\n-\tparse(io.Reader) error\n-}\n-\n-// consumeAll reads from the given Reader until error, returning the number of\n-// bytes read.\n-func consumeAll(r io.Reader) (n int64, err error) {\n-\tvar m int\n-\tvar buf [1024]byte\n-\n-\tfor {\n-\t\tm, err = r.Read(buf[:])\n-\t\tn += int64(m)\n-\t\tif err == io.EOF {\n-\t\t\terr = nil\n-\t\t\treturn\n-\t\t}\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\n-\tpanic(\"unreachable\")\n-}\n-\n-// packetType represents the numeric ids of the different OpenPGP packet types. See\n-// http://www.iana.org/assignments/pgp-parameters/pgp-parameters.xhtml#pgp-parameters-2\n-type packetType uint8\n-\n-const (\n-\tpacketTypeEncryptedKey              packetType = 1\n-\tpacketTypeSignature                 packetType = 2\n-\tpacketTypeSymmetricKeyEncrypted     packetType = 3\n-\tpacketTypeOnePassSignature          packetType = 4\n-\tpacketTypePrivateKey                packetType = 5\n-\tpacketTypePublicKey                 packetType = 6\n-\tpacketTypePrivateSubkey             packetType = 7\n-\tpacketTypeCompressed                packetType = 8\n-\tpacketTypeSymmetricallyEncrypted    packetType = 9\n-\tpacketTypeLiteralData               packetType = 11\n-\tpacketTypeUserId                    packetType = 13\n-\tpacketTypePublicSubkey              packetType = 14\n-\tpacketTypeSymmetricallyEncryptedMDC packetType = 18\n-)\n-\n-// Read reads a single OpenPGP packet from the given io.Reader. If there is an\n-// error parsing a packet, the whole packet is consumed from the input.\n-func Read(r io.Reader) (p Packet, err error) {\n-\ttag, _, contents, err := readHeader(r)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tswitch tag {\n-\tcase packetTypeEncryptedKey:\n-\t\tp = new(EncryptedKey)\n-\tcase packetTypeSignature:\n-\t\tp = new(Signature)\n-\tcase packetTypeSymmetricKeyEncrypted:\n-\t\tp = new(SymmetricKeyEncrypted)\n-\tcase packetTypeOnePassSignature:\n-\t\tp = new(OnePassSignature)\n-\tcase packetTypePrivateKey, packetTypePrivateSubkey:\n-\t\tpk := new(PrivateKey)\n-\t\tif tag == packetTypePrivateSubkey {\n-\t\t\tpk.IsSubkey = true\n-\t\t}\n-\t\tp = pk\n-\tcase packetTypePublicKey, packetTypePublicSubkey:\n-\t\tpk := new(PublicKey)\n-\t\tif tag == packetTypePublicSubkey {\n-\t\t\tpk.IsSubkey = true\n-\t\t}\n-\t\tp = pk\n-\tcase packetTypeCompressed:\n-\t\tp = new(Compressed)\n-\tcase packetTypeSymmetricallyEncrypted:\n-\t\tp = new(SymmetricallyEncrypted)\n-\tcase packetTypeLiteralData:\n-\t\tp = new(LiteralData)\n-\tcase packetTypeUserId:\n-\t\tp = new(UserId)\n-\tcase packetTypeSymmetricallyEncryptedMDC:\n-\t\tse := new(SymmetricallyEncrypted)\n-\t\tse.MDC = true\n-\t\tp = se\n-\tdefault:\n-\t\terr = errors.UnknownPacketTypeError(tag)\n-\t}\n-\tif p != nil {\n-\t\terr = p.parse(contents)\n-\t}\n-\tif err != nil {\n-\t\tconsumeAll(contents)\n-\t}\n-\treturn\n-}\n-\n-// SignatureType represents the different semantic meanings of an OpenPGP\n-// signature. See RFC 4880, section 5.2.1.\n-type SignatureType uint8\n-\n-const (\n-\tSigTypeBinary        SignatureType = 0\n-\tSigTypeText                        = 1\n-\tSigTypeGenericCert                 = 0x10\n-\tSigTypePersonaCert                 = 0x11\n-\tSigTypeCasualCert                  = 0x12\n-\tSigTypePositiveCert                = 0x13\n-\tSigTypeSubkeyBinding               = 0x18\n-)\n-\n-// PublicKeyAlgorithm represents the different public key system specified for\n-// OpenPGP. See\n-// http://www.iana.org/assignments/pgp-parameters/pgp-parameters.xhtml#pgp-parameters-12\n-type PublicKeyAlgorithm uint8\n-\n-const (\n-\tPubKeyAlgoRSA            PublicKeyAlgorithm = 1\n-\tPubKeyAlgoRSAEncryptOnly PublicKeyAlgorithm = 2\n-\tPubKeyAlgoRSASignOnly    PublicKeyAlgorithm = 3\n-\tPubKeyAlgoElGamal        PublicKeyAlgorithm = 16\n-\tPubKeyAlgoDSA            PublicKeyAlgorithm = 17\n-)\n-\n-// CanEncrypt returns true if it's possible to encrypt a message to a public\n-// key of the given type.\n-func (pka PublicKeyAlgorithm) CanEncrypt() bool {\n-\tswitch pka {\n-\tcase PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoElGamal:\n-\t\treturn true\n-\t}\n-\treturn false\n-}\n-\n-// CanSign returns true if it's possible for a public key of the given type to\n-// sign a message.\n-func (pka PublicKeyAlgorithm) CanSign() bool {\n-\tswitch pka {\n-\tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly, PubKeyAlgoDSA:\n-\t\treturn true\n-\t}\n-\treturn false\n-}\n-\n-// CipherFunction represents the different block ciphers specified for OpenPGP. See\n-// http://www.iana.org/assignments/pgp-parameters/pgp-parameters.xhtml#pgp-parameters-13\n-type CipherFunction uint8\n-\n-const (\n-\tCipherCAST5  CipherFunction = 3\n-\tCipherAES128 CipherFunction = 7\n-\tCipherAES192 CipherFunction = 8\n-\tCipherAES256 CipherFunction = 9\n-)\n-\n-// KeySize returns the key size, in bytes, of cipher.\n-func (cipher CipherFunction) KeySize() int {\n-\tswitch cipher {\n-\tcase CipherCAST5:\n-\t\treturn cast5.KeySize\n-\tcase CipherAES128:\n-\t\treturn 16\n-\tcase CipherAES192:\n-\t\treturn 24\n-\tcase CipherAES256:\n-\t\treturn 32\n-\t}\n-\treturn 0\n-}\n-\n-// blockSize returns the block size, in bytes, of cipher.\n-func (cipher CipherFunction) blockSize() int {\n-\tswitch cipher {\n-\tcase CipherCAST5:\n-\t\treturn 8\n-\tcase CipherAES128, CipherAES192, CipherAES256:\n-\t\treturn 16\n-\t}\n-\treturn 0\n-}\n-\n-// new returns a fresh instance of the given cipher.\n-func (cipher CipherFunction) new(key []byte) (block cipher.Block) {\n-\tswitch cipher {\n-\tcase CipherCAST5:\n-\t\tblock, _ = cast5.NewCipher(key)\n-\tcase CipherAES128, CipherAES192, CipherAES256:\n-\t\tblock, _ = aes.NewCipher(key)\n-\t}\n-\treturn\n-}\n-\n-// readMPI reads a big integer from r. The bit length returned is the bit\n-// length that was specified in r. This is preserved so that the integer can be\n-// reserialized exactly.\n-func readMPI(r io.Reader) (mpi []byte, bitLength uint16, err error) {\n-\tvar buf [2]byte\n-\t_, err = readFull(r, buf[0:])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tbitLength = uint16(buf[0])<<8 | uint16(buf[1])\n-\tnumBytes := (int(bitLength) + 7) / 8\n-\tmpi = make([]byte, numBytes)\n-\t_, err = readFull(r, mpi)\n-\treturn\n-}\n-\n-// mpiLength returns the length of the given *big.Int when serialized as an\n-// MPI.\n-func mpiLength(n *big.Int) (mpiLengthInBytes int) {\n-\tmpiLengthInBytes = 2 /* MPI length */\n-\tmpiLengthInBytes += (n.BitLen() + 7) / 8\n-\treturn\n-}\n-\n-// writeMPI serializes a big integer to w.\n-func writeMPI(w io.Writer, bitLength uint16, mpiBytes []byte) (err error) {\n-\t_, err = w.Write([]byte{byte(bitLength >> 8), byte(bitLength)})\n-\tif err == nil {\n-\t\t_, err = w.Write(mpiBytes)\n-\t}\n-\treturn\n-}\n-\n-// writeBig serializes a *big.Int to w.\n-func writeBig(w io.Writer, i *big.Int) error {\n-\treturn writeMPI(w, uint16(i.BitLen()), i.Bytes())\n-}"}, {"sha": "e4b86914192c7201f8e117bc13398e2e352741e2", "filename": "libgo/go/crypto/openpgp/packet/packet_test.go", "status": "removed", "additions": 0, "deletions": 255, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,255 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package packet\n-\n-import (\n-\t\"bytes\"\n-\t\"crypto/openpgp/errors\"\n-\t\"encoding/hex\"\n-\t\"fmt\"\n-\t\"io\"\n-\t\"io/ioutil\"\n-\t\"testing\"\n-)\n-\n-func TestReadFull(t *testing.T) {\n-\tvar out [4]byte\n-\n-\tb := bytes.NewBufferString(\"foo\")\n-\tn, err := readFull(b, out[:3])\n-\tif n != 3 || err != nil {\n-\t\tt.Errorf(\"full read failed n:%d err:%s\", n, err)\n-\t}\n-\n-\tb = bytes.NewBufferString(\"foo\")\n-\tn, err = readFull(b, out[:4])\n-\tif n != 3 || err != io.ErrUnexpectedEOF {\n-\t\tt.Errorf(\"partial read failed n:%d err:%s\", n, err)\n-\t}\n-\n-\tb = bytes.NewBuffer(nil)\n-\tn, err = readFull(b, out[:3])\n-\tif n != 0 || err != io.ErrUnexpectedEOF {\n-\t\tt.Errorf(\"empty read failed n:%d err:%s\", n, err)\n-\t}\n-}\n-\n-func readerFromHex(s string) io.Reader {\n-\tdata, err := hex.DecodeString(s)\n-\tif err != nil {\n-\t\tpanic(\"readerFromHex: bad input\")\n-\t}\n-\treturn bytes.NewBuffer(data)\n-}\n-\n-var readLengthTests = []struct {\n-\thexInput  string\n-\tlength    int64\n-\tisPartial bool\n-\terr       error\n-}{\n-\t{\"\", 0, false, io.ErrUnexpectedEOF},\n-\t{\"1f\", 31, false, nil},\n-\t{\"c0\", 0, false, io.ErrUnexpectedEOF},\n-\t{\"c101\", 256 + 1 + 192, false, nil},\n-\t{\"e0\", 1, true, nil},\n-\t{\"e1\", 2, true, nil},\n-\t{\"e2\", 4, true, nil},\n-\t{\"ff\", 0, false, io.ErrUnexpectedEOF},\n-\t{\"ff00\", 0, false, io.ErrUnexpectedEOF},\n-\t{\"ff0000\", 0, false, io.ErrUnexpectedEOF},\n-\t{\"ff000000\", 0, false, io.ErrUnexpectedEOF},\n-\t{\"ff00000000\", 0, false, nil},\n-\t{\"ff01020304\", 16909060, false, nil},\n-}\n-\n-func TestReadLength(t *testing.T) {\n-\tfor i, test := range readLengthTests {\n-\t\tlength, isPartial, err := readLength(readerFromHex(test.hexInput))\n-\t\tif test.err != nil {\n-\t\t\tif err != test.err {\n-\t\t\t\tt.Errorf(\"%d: expected different error got:%s want:%s\", i, err, test.err)\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"%d: unexpected error: %s\", i, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif length != test.length || isPartial != test.isPartial {\n-\t\t\tt.Errorf(\"%d: bad result got:(%d,%t) want:(%d,%t)\", i, length, isPartial, test.length, test.isPartial)\n-\t\t}\n-\t}\n-}\n-\n-var partialLengthReaderTests = []struct {\n-\thexInput  string\n-\terr       error\n-\thexOutput string\n-}{\n-\t{\"e0\", io.ErrUnexpectedEOF, \"\"},\n-\t{\"e001\", io.ErrUnexpectedEOF, \"\"},\n-\t{\"e0010102\", nil, \"0102\"},\n-\t{\"ff00000000\", nil, \"\"},\n-\t{\"e10102e1030400\", nil, \"01020304\"},\n-\t{\"e101\", io.ErrUnexpectedEOF, \"\"},\n-}\n-\n-func TestPartialLengthReader(t *testing.T) {\n-\tfor i, test := range partialLengthReaderTests {\n-\t\tr := &partialLengthReader{readerFromHex(test.hexInput), 0, true}\n-\t\tout, err := ioutil.ReadAll(r)\n-\t\tif test.err != nil {\n-\t\t\tif err != test.err {\n-\t\t\t\tt.Errorf(\"%d: expected different error got:%s want:%s\", i, err, test.err)\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"%d: unexpected error: %s\", i, err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tgot := fmt.Sprintf(\"%x\", out)\n-\t\tif got != test.hexOutput {\n-\t\t\tt.Errorf(\"%d: got:%s want:%s\", i, test.hexOutput, got)\n-\t\t}\n-\t}\n-}\n-\n-var readHeaderTests = []struct {\n-\thexInput        string\n-\tstructuralError bool\n-\tunexpectedEOF   bool\n-\ttag             int\n-\tlength          int64\n-\thexOutput       string\n-}{\n-\t{\"\", false, false, 0, 0, \"\"},\n-\t{\"7f\", true, false, 0, 0, \"\"},\n-\n-\t// Old format headers\n-\t{\"80\", false, true, 0, 0, \"\"},\n-\t{\"8001\", false, true, 0, 1, \"\"},\n-\t{\"800102\", false, false, 0, 1, \"02\"},\n-\t{\"81000102\", false, false, 0, 1, \"02\"},\n-\t{\"820000000102\", false, false, 0, 1, \"02\"},\n-\t{\"860000000102\", false, false, 1, 1, \"02\"},\n-\t{\"83010203\", false, false, 0, -1, \"010203\"},\n-\n-\t// New format headers\n-\t{\"c0\", false, true, 0, 0, \"\"},\n-\t{\"c000\", false, false, 0, 0, \"\"},\n-\t{\"c00102\", false, false, 0, 1, \"02\"},\n-\t{\"c0020203\", false, false, 0, 2, \"0203\"},\n-\t{\"c00202\", false, true, 0, 2, \"\"},\n-\t{\"c3020203\", false, false, 3, 2, \"0203\"},\n-}\n-\n-func TestReadHeader(t *testing.T) {\n-\tfor i, test := range readHeaderTests {\n-\t\ttag, length, contents, err := readHeader(readerFromHex(test.hexInput))\n-\t\tif test.structuralError {\n-\t\t\tif _, ok := err.(errors.StructuralError); ok {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tt.Errorf(\"%d: expected StructuralError, got:%s\", i, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif err != nil {\n-\t\t\tif len(test.hexInput) == 0 && err == io.EOF {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tif !test.unexpectedEOF || err != io.ErrUnexpectedEOF {\n-\t\t\t\tt.Errorf(\"%d: unexpected error from readHeader: %s\", i, err)\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\t\tif int(tag) != test.tag || length != test.length {\n-\t\t\tt.Errorf(\"%d: got:(%d,%d) want:(%d,%d)\", i, int(tag), length, test.tag, test.length)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tbody, err := ioutil.ReadAll(contents)\n-\t\tif err != nil {\n-\t\t\tif !test.unexpectedEOF || err != io.ErrUnexpectedEOF {\n-\t\t\t\tt.Errorf(\"%d: unexpected error from contents: %s\", i, err)\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\t\tif test.unexpectedEOF {\n-\t\t\tt.Errorf(\"%d: expected ErrUnexpectedEOF from contents but got no error\", i)\n-\t\t\tcontinue\n-\t\t}\n-\t\tgot := fmt.Sprintf(\"%x\", body)\n-\t\tif got != test.hexOutput {\n-\t\t\tt.Errorf(\"%d: got:%s want:%s\", i, got, test.hexOutput)\n-\t\t}\n-\t}\n-}\n-\n-func TestSerializeHeader(t *testing.T) {\n-\ttag := packetTypePublicKey\n-\tlengths := []int{0, 1, 2, 64, 192, 193, 8000, 8384, 8385, 10000}\n-\n-\tfor _, length := range lengths {\n-\t\tbuf := bytes.NewBuffer(nil)\n-\t\tserializeHeader(buf, tag, length)\n-\t\ttag2, length2, _, err := readHeader(buf)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"length %d, err: %s\", length, err)\n-\t\t}\n-\t\tif tag2 != tag {\n-\t\t\tt.Errorf(\"length %d, tag incorrect (got %d, want %d)\", length, tag2, tag)\n-\t\t}\n-\t\tif int(length2) != length {\n-\t\t\tt.Errorf(\"length %d, length incorrect (got %d)\", length, length2)\n-\t\t}\n-\t}\n-}\n-\n-func TestPartialLengths(t *testing.T) {\n-\tbuf := bytes.NewBuffer(nil)\n-\tw := new(partialLengthWriter)\n-\tw.w = noOpCloser{buf}\n-\n-\tconst maxChunkSize = 64\n-\n-\tvar b [maxChunkSize]byte\n-\tvar n uint8\n-\tfor l := 1; l <= maxChunkSize; l++ {\n-\t\tfor i := 0; i < l; i++ {\n-\t\t\tb[i] = n\n-\t\t\tn++\n-\t\t}\n-\t\tm, err := w.Write(b[:l])\n-\t\tif m != l {\n-\t\t\tt.Errorf(\"short write got: %d want: %d\", m, l)\n-\t\t}\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"error from write: %s\", err)\n-\t\t}\n-\t}\n-\tw.Close()\n-\n-\twant := (maxChunkSize * (maxChunkSize + 1)) / 2\n-\tcopyBuf := bytes.NewBuffer(nil)\n-\tr := &partialLengthReader{buf, 0, true}\n-\tm, err := io.Copy(copyBuf, r)\n-\tif m != int64(want) {\n-\t\tt.Errorf(\"short copy got: %d want: %d\", m, want)\n-\t}\n-\tif err != nil {\n-\t\tt.Errorf(\"error from copy: %s\", err)\n-\t}\n-\n-\tcopyBytes := copyBuf.Bytes()\n-\tfor i := 0; i < want; i++ {\n-\t\tif copyBytes[i] != uint8(i) {\n-\t\t\tt.Errorf(\"bad pattern in copy at %d\", i)\n-\t\t\tbreak\n-\t\t}\n-\t}\n-}"}, {"sha": "5a90d0625fada59b0f237eab48508431b1c8421f", "filename": "libgo/go/crypto/openpgp/packet/private_key.go", "status": "removed", "additions": 0, "deletions": 310, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,310 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package packet\n-\n-import (\n-\t\"bytes\"\n-\t\"crypto/cipher\"\n-\t\"crypto/dsa\"\n-\t\"crypto/openpgp/elgamal\"\n-\t\"crypto/openpgp/errors\"\n-\t\"crypto/openpgp/s2k\"\n-\t\"crypto/rsa\"\n-\t\"crypto/sha1\"\n-\t\"io\"\n-\t\"io/ioutil\"\n-\t\"math/big\"\n-\t\"strconv\"\n-\t\"time\"\n-)\n-\n-// PrivateKey represents a possibly encrypted private key. See RFC 4880,\n-// section 5.5.3.\n-type PrivateKey struct {\n-\tPublicKey\n-\tEncrypted     bool // if true then the private key is unavailable until Decrypt has been called.\n-\tencryptedData []byte\n-\tcipher        CipherFunction\n-\ts2k           func(out, in []byte)\n-\tPrivateKey    interface{} // An *rsa.PrivateKey or *dsa.PrivateKey.\n-\tsha1Checksum  bool\n-\tiv            []byte\n-}\n-\n-func NewRSAPrivateKey(currentTime time.Time, priv *rsa.PrivateKey) *PrivateKey {\n-\tpk := new(PrivateKey)\n-\tpk.PublicKey = *NewRSAPublicKey(currentTime, &priv.PublicKey)\n-\tpk.PrivateKey = priv\n-\treturn pk\n-}\n-\n-func NewDSAPrivateKey(currentTime time.Time, priv *dsa.PrivateKey) *PrivateKey {\n-\tpk := new(PrivateKey)\n-\tpk.PublicKey = *NewDSAPublicKey(currentTime, &priv.PublicKey)\n-\tpk.PrivateKey = priv\n-\treturn pk\n-}\n-\n-func (pk *PrivateKey) parse(r io.Reader) (err error) {\n-\terr = (&pk.PublicKey).parse(r)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tvar buf [1]byte\n-\t_, err = readFull(r, buf[:])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\ts2kType := buf[0]\n-\n-\tswitch s2kType {\n-\tcase 0:\n-\t\tpk.s2k = nil\n-\t\tpk.Encrypted = false\n-\tcase 254, 255:\n-\t\t_, err = readFull(r, buf[:])\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tpk.cipher = CipherFunction(buf[0])\n-\t\tpk.Encrypted = true\n-\t\tpk.s2k, err = s2k.Parse(r)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tif s2kType == 254 {\n-\t\t\tpk.sha1Checksum = true\n-\t\t}\n-\tdefault:\n-\t\treturn errors.UnsupportedError(\"deprecated s2k function in private key\")\n-\t}\n-\n-\tif pk.Encrypted {\n-\t\tblockSize := pk.cipher.blockSize()\n-\t\tif blockSize == 0 {\n-\t\t\treturn errors.UnsupportedError(\"unsupported cipher in private key: \" + strconv.Itoa(int(pk.cipher)))\n-\t\t}\n-\t\tpk.iv = make([]byte, blockSize)\n-\t\t_, err = readFull(r, pk.iv)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\n-\tpk.encryptedData, err = ioutil.ReadAll(r)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tif !pk.Encrypted {\n-\t\treturn pk.parsePrivateKey(pk.encryptedData)\n-\t}\n-\n-\treturn\n-}\n-\n-func mod64kHash(d []byte) uint16 {\n-\tvar h uint16\n-\tfor _, b := range d {\n-\t\th += uint16(b)\n-\t}\n-\treturn h\n-}\n-\n-func (pk *PrivateKey) Serialize(w io.Writer) (err error) {\n-\t// TODO(agl): support encrypted private keys\n-\tbuf := bytes.NewBuffer(nil)\n-\terr = pk.PublicKey.serializeWithoutHeaders(buf)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tbuf.WriteByte(0 /* no encryption */ )\n-\n-\tprivateKeyBuf := bytes.NewBuffer(nil)\n-\n-\tswitch priv := pk.PrivateKey.(type) {\n-\tcase *rsa.PrivateKey:\n-\t\terr = serializeRSAPrivateKey(privateKeyBuf, priv)\n-\tcase *dsa.PrivateKey:\n-\t\terr = serializeDSAPrivateKey(privateKeyBuf, priv)\n-\tdefault:\n-\t\terr = errors.InvalidArgumentError(\"unknown private key type\")\n-\t}\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tptype := packetTypePrivateKey\n-\tcontents := buf.Bytes()\n-\tprivateKeyBytes := privateKeyBuf.Bytes()\n-\tif pk.IsSubkey {\n-\t\tptype = packetTypePrivateSubkey\n-\t}\n-\terr = serializeHeader(w, ptype, len(contents)+len(privateKeyBytes)+2)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\t_, err = w.Write(contents)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\t_, err = w.Write(privateKeyBytes)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tchecksum := mod64kHash(privateKeyBytes)\n-\tvar checksumBytes [2]byte\n-\tchecksumBytes[0] = byte(checksum >> 8)\n-\tchecksumBytes[1] = byte(checksum)\n-\t_, err = w.Write(checksumBytes[:])\n-\n-\treturn\n-}\n-\n-func serializeRSAPrivateKey(w io.Writer, priv *rsa.PrivateKey) error {\n-\terr := writeBig(w, priv.D)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\terr = writeBig(w, priv.Primes[1])\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\terr = writeBig(w, priv.Primes[0])\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn writeBig(w, priv.Precomputed.Qinv)\n-}\n-\n-func serializeDSAPrivateKey(w io.Writer, priv *dsa.PrivateKey) error {\n-\treturn writeBig(w, priv.X)\n-}\n-\n-// Decrypt decrypts an encrypted private key using a passphrase.\n-func (pk *PrivateKey) Decrypt(passphrase []byte) error {\n-\tif !pk.Encrypted {\n-\t\treturn nil\n-\t}\n-\n-\tkey := make([]byte, pk.cipher.KeySize())\n-\tpk.s2k(key, passphrase)\n-\tblock := pk.cipher.new(key)\n-\tcfb := cipher.NewCFBDecrypter(block, pk.iv)\n-\n-\tdata := pk.encryptedData\n-\tcfb.XORKeyStream(data, data)\n-\n-\tif pk.sha1Checksum {\n-\t\tif len(data) < sha1.Size {\n-\t\t\treturn errors.StructuralError(\"truncated private key data\")\n-\t\t}\n-\t\th := sha1.New()\n-\t\th.Write(data[:len(data)-sha1.Size])\n-\t\tsum := h.Sum(nil)\n-\t\tif !bytes.Equal(sum, data[len(data)-sha1.Size:]) {\n-\t\t\treturn errors.StructuralError(\"private key checksum failure\")\n-\t\t}\n-\t\tdata = data[:len(data)-sha1.Size]\n-\t} else {\n-\t\tif len(data) < 2 {\n-\t\t\treturn errors.StructuralError(\"truncated private key data\")\n-\t\t}\n-\t\tvar sum uint16\n-\t\tfor i := 0; i < len(data)-2; i++ {\n-\t\t\tsum += uint16(data[i])\n-\t\t}\n-\t\tif data[len(data)-2] != uint8(sum>>8) ||\n-\t\t\tdata[len(data)-1] != uint8(sum) {\n-\t\t\treturn errors.StructuralError(\"private key checksum failure\")\n-\t\t}\n-\t\tdata = data[:len(data)-2]\n-\t}\n-\n-\treturn pk.parsePrivateKey(data)\n-}\n-\n-func (pk *PrivateKey) parsePrivateKey(data []byte) (err error) {\n-\tswitch pk.PublicKey.PubKeyAlgo {\n-\tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly, PubKeyAlgoRSAEncryptOnly:\n-\t\treturn pk.parseRSAPrivateKey(data)\n-\tcase PubKeyAlgoDSA:\n-\t\treturn pk.parseDSAPrivateKey(data)\n-\tcase PubKeyAlgoElGamal:\n-\t\treturn pk.parseElGamalPrivateKey(data)\n-\t}\n-\tpanic(\"impossible\")\n-}\n-\n-func (pk *PrivateKey) parseRSAPrivateKey(data []byte) (err error) {\n-\trsaPub := pk.PublicKey.PublicKey.(*rsa.PublicKey)\n-\trsaPriv := new(rsa.PrivateKey)\n-\trsaPriv.PublicKey = *rsaPub\n-\n-\tbuf := bytes.NewBuffer(data)\n-\td, _, err := readMPI(buf)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tp, _, err := readMPI(buf)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tq, _, err := readMPI(buf)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\trsaPriv.D = new(big.Int).SetBytes(d)\n-\trsaPriv.Primes = make([]*big.Int, 2)\n-\trsaPriv.Primes[0] = new(big.Int).SetBytes(p)\n-\trsaPriv.Primes[1] = new(big.Int).SetBytes(q)\n-\trsaPriv.Precompute()\n-\tpk.PrivateKey = rsaPriv\n-\tpk.Encrypted = false\n-\tpk.encryptedData = nil\n-\n-\treturn nil\n-}\n-\n-func (pk *PrivateKey) parseDSAPrivateKey(data []byte) (err error) {\n-\tdsaPub := pk.PublicKey.PublicKey.(*dsa.PublicKey)\n-\tdsaPriv := new(dsa.PrivateKey)\n-\tdsaPriv.PublicKey = *dsaPub\n-\n-\tbuf := bytes.NewBuffer(data)\n-\tx, _, err := readMPI(buf)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tdsaPriv.X = new(big.Int).SetBytes(x)\n-\tpk.PrivateKey = dsaPriv\n-\tpk.Encrypted = false\n-\tpk.encryptedData = nil\n-\n-\treturn nil\n-}\n-\n-func (pk *PrivateKey) parseElGamalPrivateKey(data []byte) (err error) {\n-\tpub := pk.PublicKey.PublicKey.(*elgamal.PublicKey)\n-\tpriv := new(elgamal.PrivateKey)\n-\tpriv.PublicKey = *pub\n-\n-\tbuf := bytes.NewBuffer(data)\n-\tx, _, err := readMPI(buf)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tpriv.X = new(big.Int).SetBytes(x)\n-\tpk.PrivateKey = priv\n-\tpk.Encrypted = false\n-\tpk.encryptedData = nil\n-\n-\treturn nil\n-}"}, {"sha": "35d8951a86b05077a3b186796e25e0f74956e686", "filename": "libgo/go/crypto/openpgp/packet/private_key_test.go", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,58 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package packet\n-\n-import (\n-\t\"testing\"\n-\t\"time\"\n-)\n-\n-var privateKeyTests = []struct {\n-\tprivateKeyHex string\n-\tcreationTime  time.Time\n-}{\n-\t{\n-\t\tprivKeyRSAHex,\n-\t\ttime.Unix(0x4cc349a8, 0),\n-\t},\n-\t{\n-\t\tprivKeyElGamalHex,\n-\t\ttime.Unix(0x4df9ee1a, 0),\n-\t},\n-}\n-\n-func TestPrivateKeyRead(t *testing.T) {\n-\tfor i, test := range privateKeyTests {\n-\t\tpacket, err := Read(readerFromHex(test.privateKeyHex))\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"#%d: failed to parse: %s\", i, err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tprivKey := packet.(*PrivateKey)\n-\n-\t\tif !privKey.Encrypted {\n-\t\t\tt.Errorf(\"#%d: private key isn't encrypted\", i)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\terr = privKey.Decrypt([]byte(\"testing\"))\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"#%d: failed to decrypt: %s\", i, err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif !privKey.CreationTime.Equal(test.creationTime) || privKey.Encrypted {\n-\t\t\tt.Errorf(\"#%d: bad result, got: %#v\", i, privKey)\n-\t\t}\n-\t}\n-}\n-\n-// Generated with `gpg --export-secret-keys \"Test Key 2\"`\n-const privKeyRSAHex = \"9501fe044cc349a8010400b70ca0010e98c090008d45d1ee8f9113bd5861fd57b88bacb7c68658747663f1e1a3b5a98f32fda6472373c024b97359cd2efc88ff60f77751adfbf6af5e615e6a1408cfad8bf0cea30b0d5f53aa27ad59089ba9b15b7ebc2777a25d7b436144027e3bcd203909f147d0e332b240cf63d3395f5dfe0df0a6c04e8655af7eacdf0011010001fe0303024a252e7d475fd445607de39a265472aa74a9320ba2dac395faa687e9e0336aeb7e9a7397e511b5afd9dc84557c80ac0f3d4d7bfec5ae16f20d41c8c84a04552a33870b930420e230e179564f6d19bb153145e76c33ae993886c388832b0fa042ddda7f133924f3854481533e0ede31d51278c0519b29abc3bf53da673e13e3e1214b52413d179d7f66deee35cac8eacb060f78379d70ef4af8607e68131ff529439668fc39c9ce6dfef8a5ac234d234802cbfb749a26107db26406213ae5c06d4673253a3cbee1fcbae58d6ab77e38d6e2c0e7c6317c48e054edadb5a40d0d48acb44643d998139a8a66bb820be1f3f80185bc777d14b5954b60effe2448a036d565c6bc0b915fcea518acdd20ab07bc1529f561c58cd044f723109b93f6fd99f876ff891d64306b5d08f48bab59f38695e9109c4dec34013ba3153488ce070268381ba923ee1eb77125b36afcb4347ec3478c8f2735b06ef17351d872e577fa95d0c397c88c71b59629a36aec\"\n-\n-// Generated by `gpg --export-secret-keys` followed by a manual extraction of\n-// the ElGamal subkey from the packets.\n-const privKeyElGamalHex = \"9d0157044df9ee1a100400eb8e136a58ec39b582629cdadf830bc64e0a94ed8103ca8bb247b27b11b46d1d25297ef4bcc3071785ba0c0bedfe89eabc5287fcc0edf81ab5896c1c8e4b20d27d79813c7aede75320b33eaeeaa586edc00fd1036c10133e6ba0ff277245d0d59d04b2b3421b7244aca5f4a8d870c6f1c1fbff9e1c26699a860b9504f35ca1d700030503fd1ededd3b840795be6d9ccbe3c51ee42e2f39233c432b831ddd9c4e72b7025a819317e47bf94f9ee316d7273b05d5fcf2999c3a681f519b1234bbfa6d359b4752bd9c3f77d6b6456cde152464763414ca130f4e91d91041432f90620fec0e6d6b5116076c2985d5aeaae13be492b9b329efcaf7ee25120159a0a30cd976b42d7afe030302dae7eb80db744d4960c4df930d57e87fe81412eaace9f900e6c839817a614ddb75ba6603b9417c33ea7b6c93967dfa2bcff3fa3c74a5ce2c962db65b03aece14c96cbd0038fc\""}, {"sha": "ba178b519ebdaa15c0b709c65ad7d92d66961818", "filename": "libgo/go/crypto/openpgp/packet/public_key.go", "status": "removed", "additions": 0, "deletions": 414, "changes": 414, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,414 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package packet\n-\n-import (\n-\t\"crypto/dsa\"\n-\t\"crypto/openpgp/elgamal\"\n-\t\"crypto/openpgp/errors\"\n-\t\"crypto/rsa\"\n-\t\"crypto/sha1\"\n-\t\"encoding/binary\"\n-\t\"fmt\"\n-\t\"hash\"\n-\t\"io\"\n-\t\"math/big\"\n-\t\"strconv\"\n-\t\"time\"\n-)\n-\n-// PublicKey represents an OpenPGP public key. See RFC 4880, section 5.5.2.\n-type PublicKey struct {\n-\tCreationTime time.Time\n-\tPubKeyAlgo   PublicKeyAlgorithm\n-\tPublicKey    interface{} // Either a *rsa.PublicKey or *dsa.PublicKey\n-\tFingerprint  [20]byte\n-\tKeyId        uint64\n-\tIsSubkey     bool\n-\n-\tn, e, p, q, g, y parsedMPI\n-}\n-\n-func fromBig(n *big.Int) parsedMPI {\n-\treturn parsedMPI{\n-\t\tbytes:     n.Bytes(),\n-\t\tbitLength: uint16(n.BitLen()),\n-\t}\n-}\n-\n-// NewRSAPublicKey returns a PublicKey that wraps the given rsa.PublicKey.\n-func NewRSAPublicKey(creationTime time.Time, pub *rsa.PublicKey) *PublicKey {\n-\tpk := &PublicKey{\n-\t\tCreationTime: creationTime,\n-\t\tPubKeyAlgo:   PubKeyAlgoRSA,\n-\t\tPublicKey:    pub,\n-\t\tn:            fromBig(pub.N),\n-\t\te:            fromBig(big.NewInt(int64(pub.E))),\n-\t}\n-\n-\tpk.setFingerPrintAndKeyId()\n-\treturn pk\n-}\n-\n-// NewDSAPublicKey returns a PublicKey that wraps the given rsa.PublicKey.\n-func NewDSAPublicKey(creationTime time.Time, pub *dsa.PublicKey) *PublicKey {\n-\tpk := &PublicKey{\n-\t\tCreationTime: creationTime,\n-\t\tPubKeyAlgo:   PubKeyAlgoDSA,\n-\t\tPublicKey:    pub,\n-\t\tp:            fromBig(pub.P),\n-\t\tq:            fromBig(pub.Q),\n-\t\tg:            fromBig(pub.G),\n-\t\ty:            fromBig(pub.Y),\n-\t}\n-\n-\tpk.setFingerPrintAndKeyId()\n-\treturn pk\n-}\n-\n-func (pk *PublicKey) parse(r io.Reader) (err error) {\n-\t// RFC 4880, section 5.5.2\n-\tvar buf [6]byte\n-\t_, err = readFull(r, buf[:])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tif buf[0] != 4 {\n-\t\treturn errors.UnsupportedError(\"public key version\")\n-\t}\n-\tpk.CreationTime = time.Unix(int64(uint32(buf[1])<<24|uint32(buf[2])<<16|uint32(buf[3])<<8|uint32(buf[4])), 0)\n-\tpk.PubKeyAlgo = PublicKeyAlgorithm(buf[5])\n-\tswitch pk.PubKeyAlgo {\n-\tcase PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoRSASignOnly:\n-\t\terr = pk.parseRSA(r)\n-\tcase PubKeyAlgoDSA:\n-\t\terr = pk.parseDSA(r)\n-\tcase PubKeyAlgoElGamal:\n-\t\terr = pk.parseElGamal(r)\n-\tdefault:\n-\t\terr = errors.UnsupportedError(\"public key type: \" + strconv.Itoa(int(pk.PubKeyAlgo)))\n-\t}\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tpk.setFingerPrintAndKeyId()\n-\treturn\n-}\n-\n-func (pk *PublicKey) setFingerPrintAndKeyId() {\n-\t// RFC 4880, section 12.2\n-\tfingerPrint := sha1.New()\n-\tpk.SerializeSignaturePrefix(fingerPrint)\n-\tpk.serializeWithoutHeaders(fingerPrint)\n-\tcopy(pk.Fingerprint[:], fingerPrint.Sum(nil))\n-\tpk.KeyId = binary.BigEndian.Uint64(pk.Fingerprint[12:20])\n-}\n-\n-// parseRSA parses RSA public key material from the given Reader. See RFC 4880,\n-// section 5.5.2.\n-func (pk *PublicKey) parseRSA(r io.Reader) (err error) {\n-\tpk.n.bytes, pk.n.bitLength, err = readMPI(r)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tpk.e.bytes, pk.e.bitLength, err = readMPI(r)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tif len(pk.e.bytes) > 3 {\n-\t\terr = errors.UnsupportedError(\"large public exponent\")\n-\t\treturn\n-\t}\n-\trsa := &rsa.PublicKey{\n-\t\tN: new(big.Int).SetBytes(pk.n.bytes),\n-\t\tE: 0,\n-\t}\n-\tfor i := 0; i < len(pk.e.bytes); i++ {\n-\t\trsa.E <<= 8\n-\t\trsa.E |= int(pk.e.bytes[i])\n-\t}\n-\tpk.PublicKey = rsa\n-\treturn\n-}\n-\n-// parseDSA parses DSA public key material from the given Reader. See RFC 4880,\n-// section 5.5.2.\n-func (pk *PublicKey) parseDSA(r io.Reader) (err error) {\n-\tpk.p.bytes, pk.p.bitLength, err = readMPI(r)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tpk.q.bytes, pk.q.bitLength, err = readMPI(r)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tpk.g.bytes, pk.g.bitLength, err = readMPI(r)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tpk.y.bytes, pk.y.bitLength, err = readMPI(r)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tdsa := new(dsa.PublicKey)\n-\tdsa.P = new(big.Int).SetBytes(pk.p.bytes)\n-\tdsa.Q = new(big.Int).SetBytes(pk.q.bytes)\n-\tdsa.G = new(big.Int).SetBytes(pk.g.bytes)\n-\tdsa.Y = new(big.Int).SetBytes(pk.y.bytes)\n-\tpk.PublicKey = dsa\n-\treturn\n-}\n-\n-// parseElGamal parses ElGamal public key material from the given Reader. See\n-// RFC 4880, section 5.5.2.\n-func (pk *PublicKey) parseElGamal(r io.Reader) (err error) {\n-\tpk.p.bytes, pk.p.bitLength, err = readMPI(r)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tpk.g.bytes, pk.g.bitLength, err = readMPI(r)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tpk.y.bytes, pk.y.bitLength, err = readMPI(r)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\telgamal := new(elgamal.PublicKey)\n-\telgamal.P = new(big.Int).SetBytes(pk.p.bytes)\n-\telgamal.G = new(big.Int).SetBytes(pk.g.bytes)\n-\telgamal.Y = new(big.Int).SetBytes(pk.y.bytes)\n-\tpk.PublicKey = elgamal\n-\treturn\n-}\n-\n-// SerializeSignaturePrefix writes the prefix for this public key to the given Writer.\n-// The prefix is used when calculating a signature over this public key. See\n-// RFC 4880, section 5.2.4.\n-func (pk *PublicKey) SerializeSignaturePrefix(h hash.Hash) {\n-\tvar pLength uint16\n-\tswitch pk.PubKeyAlgo {\n-\tcase PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoRSASignOnly:\n-\t\tpLength += 2 + uint16(len(pk.n.bytes))\n-\t\tpLength += 2 + uint16(len(pk.e.bytes))\n-\tcase PubKeyAlgoDSA:\n-\t\tpLength += 2 + uint16(len(pk.p.bytes))\n-\t\tpLength += 2 + uint16(len(pk.q.bytes))\n-\t\tpLength += 2 + uint16(len(pk.g.bytes))\n-\t\tpLength += 2 + uint16(len(pk.y.bytes))\n-\tcase PubKeyAlgoElGamal:\n-\t\tpLength += 2 + uint16(len(pk.p.bytes))\n-\t\tpLength += 2 + uint16(len(pk.g.bytes))\n-\t\tpLength += 2 + uint16(len(pk.y.bytes))\n-\tdefault:\n-\t\tpanic(\"unknown public key algorithm\")\n-\t}\n-\tpLength += 6\n-\th.Write([]byte{0x99, byte(pLength >> 8), byte(pLength)})\n-\treturn\n-}\n-\n-func (pk *PublicKey) Serialize(w io.Writer) (err error) {\n-\tlength := 6 // 6 byte header\n-\n-\tswitch pk.PubKeyAlgo {\n-\tcase PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoRSASignOnly:\n-\t\tlength += 2 + len(pk.n.bytes)\n-\t\tlength += 2 + len(pk.e.bytes)\n-\tcase PubKeyAlgoDSA:\n-\t\tlength += 2 + len(pk.p.bytes)\n-\t\tlength += 2 + len(pk.q.bytes)\n-\t\tlength += 2 + len(pk.g.bytes)\n-\t\tlength += 2 + len(pk.y.bytes)\n-\tcase PubKeyAlgoElGamal:\n-\t\tlength += 2 + len(pk.p.bytes)\n-\t\tlength += 2 + len(pk.g.bytes)\n-\t\tlength += 2 + len(pk.y.bytes)\n-\tdefault:\n-\t\tpanic(\"unknown public key algorithm\")\n-\t}\n-\n-\tpacketType := packetTypePublicKey\n-\tif pk.IsSubkey {\n-\t\tpacketType = packetTypePublicSubkey\n-\t}\n-\terr = serializeHeader(w, packetType, length)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\treturn pk.serializeWithoutHeaders(w)\n-}\n-\n-// serializeWithoutHeaders marshals the PublicKey to w in the form of an\n-// OpenPGP public key packet, not including the packet header.\n-func (pk *PublicKey) serializeWithoutHeaders(w io.Writer) (err error) {\n-\tvar buf [6]byte\n-\tbuf[0] = 4\n-\tt := uint32(pk.CreationTime.Unix())\n-\tbuf[1] = byte(t >> 24)\n-\tbuf[2] = byte(t >> 16)\n-\tbuf[3] = byte(t >> 8)\n-\tbuf[4] = byte(t)\n-\tbuf[5] = byte(pk.PubKeyAlgo)\n-\n-\t_, err = w.Write(buf[:])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tswitch pk.PubKeyAlgo {\n-\tcase PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoRSASignOnly:\n-\t\treturn writeMPIs(w, pk.n, pk.e)\n-\tcase PubKeyAlgoDSA:\n-\t\treturn writeMPIs(w, pk.p, pk.q, pk.g, pk.y)\n-\tcase PubKeyAlgoElGamal:\n-\t\treturn writeMPIs(w, pk.p, pk.g, pk.y)\n-\t}\n-\treturn errors.InvalidArgumentError(\"bad public-key algorithm\")\n-}\n-\n-// CanSign returns true iff this public key can generate signatures\n-func (pk *PublicKey) CanSign() bool {\n-\treturn pk.PubKeyAlgo != PubKeyAlgoRSAEncryptOnly && pk.PubKeyAlgo != PubKeyAlgoElGamal\n-}\n-\n-// VerifySignature returns nil iff sig is a valid signature, made by this\n-// public key, of the data hashed into signed. signed is mutated by this call.\n-func (pk *PublicKey) VerifySignature(signed hash.Hash, sig *Signature) (err error) {\n-\tif !pk.CanSign() {\n-\t\treturn errors.InvalidArgumentError(\"public key cannot generate signatures\")\n-\t}\n-\n-\tsigned.Write(sig.HashSuffix)\n-\thashBytes := signed.Sum(nil)\n-\n-\tif hashBytes[0] != sig.HashTag[0] || hashBytes[1] != sig.HashTag[1] {\n-\t\treturn errors.SignatureError(\"hash tag doesn't match\")\n-\t}\n-\n-\tif pk.PubKeyAlgo != sig.PubKeyAlgo {\n-\t\treturn errors.InvalidArgumentError(\"public key and signature use different algorithms\")\n-\t}\n-\n-\tswitch pk.PubKeyAlgo {\n-\tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:\n-\t\trsaPublicKey, _ := pk.PublicKey.(*rsa.PublicKey)\n-\t\terr = rsa.VerifyPKCS1v15(rsaPublicKey, sig.Hash, hashBytes, sig.RSASignature.bytes)\n-\t\tif err != nil {\n-\t\t\treturn errors.SignatureError(\"RSA verification failure\")\n-\t\t}\n-\t\treturn nil\n-\tcase PubKeyAlgoDSA:\n-\t\tdsaPublicKey, _ := pk.PublicKey.(*dsa.PublicKey)\n-\t\t// Need to truncate hashBytes to match FIPS 186-3 section 4.6.\n-\t\tsubgroupSize := (dsaPublicKey.Q.BitLen() + 7) / 8\n-\t\tif len(hashBytes) > subgroupSize {\n-\t\t\thashBytes = hashBytes[:subgroupSize]\n-\t\t}\n-\t\tif !dsa.Verify(dsaPublicKey, hashBytes, new(big.Int).SetBytes(sig.DSASigR.bytes), new(big.Int).SetBytes(sig.DSASigS.bytes)) {\n-\t\t\treturn errors.SignatureError(\"DSA verification failure\")\n-\t\t}\n-\t\treturn nil\n-\tdefault:\n-\t\tpanic(\"shouldn't happen\")\n-\t}\n-\tpanic(\"unreachable\")\n-}\n-\n-// keySignatureHash returns a Hash of the message that needs to be signed for\n-// pk to assert a subkey relationship to signed.\n-func keySignatureHash(pk, signed *PublicKey, sig *Signature) (h hash.Hash, err error) {\n-\th = sig.Hash.New()\n-\tif h == nil {\n-\t\treturn nil, errors.UnsupportedError(\"hash function\")\n-\t}\n-\n-\t// RFC 4880, section 5.2.4\n-\tpk.SerializeSignaturePrefix(h)\n-\tpk.serializeWithoutHeaders(h)\n-\tsigned.SerializeSignaturePrefix(h)\n-\tsigned.serializeWithoutHeaders(h)\n-\treturn\n-}\n-\n-// VerifyKeySignature returns nil iff sig is a valid signature, made by this\n-// public key, of signed.\n-func (pk *PublicKey) VerifyKeySignature(signed *PublicKey, sig *Signature) (err error) {\n-\th, err := keySignatureHash(pk, signed, sig)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn pk.VerifySignature(h, sig)\n-}\n-\n-// userIdSignatureHash returns a Hash of the message that needs to be signed\n-// to assert that pk is a valid key for id.\n-func userIdSignatureHash(id string, pk *PublicKey, sig *Signature) (h hash.Hash, err error) {\n-\th = sig.Hash.New()\n-\tif h == nil {\n-\t\treturn nil, errors.UnsupportedError(\"hash function\")\n-\t}\n-\n-\t// RFC 4880, section 5.2.4\n-\tpk.SerializeSignaturePrefix(h)\n-\tpk.serializeWithoutHeaders(h)\n-\n-\tvar buf [5]byte\n-\tbuf[0] = 0xb4\n-\tbuf[1] = byte(len(id) >> 24)\n-\tbuf[2] = byte(len(id) >> 16)\n-\tbuf[3] = byte(len(id) >> 8)\n-\tbuf[4] = byte(len(id))\n-\th.Write(buf[:])\n-\th.Write([]byte(id))\n-\n-\treturn\n-}\n-\n-// VerifyUserIdSignature returns nil iff sig is a valid signature, made by this\n-// public key, of id.\n-func (pk *PublicKey) VerifyUserIdSignature(id string, sig *Signature) (err error) {\n-\th, err := userIdSignatureHash(id, pk, sig)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn pk.VerifySignature(h, sig)\n-}\n-\n-// KeyIdString returns the public key's fingerprint in capital hex\n-// (e.g. \"6C7EE1B8621CC013\").\n-func (pk *PublicKey) KeyIdString() string {\n-\treturn fmt.Sprintf(\"%X\", pk.Fingerprint[12:20])\n-}\n-\n-// KeyIdShortString returns the short form of public key's fingerprint\n-// in capital hex, as shown by gpg --list-keys (e.g. \"621CC013\").\n-func (pk *PublicKey) KeyIdShortString() string {\n-\treturn fmt.Sprintf(\"%X\", pk.Fingerprint[16:20])\n-}\n-\n-// A parsedMPI is used to store the contents of a big integer, along with the\n-// bit length that was specified in the original input. This allows the MPI to\n-// be reserialized exactly.\n-type parsedMPI struct {\n-\tbytes     []byte\n-\tbitLength uint16\n-}\n-\n-// writeMPIs is a utility function for serializing several big integers to the\n-// given Writer.\n-func writeMPIs(w io.Writer, mpis ...parsedMPI) (err error) {\n-\tfor _, mpi := range mpis {\n-\t\terr = writeMPI(w, mpi.bitLength, mpi.bytes)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\treturn\n-}"}, {"sha": "72f459f47bf028019844beb764ff4467cd6727f2", "filename": "libgo/go/crypto/openpgp/packet/public_key_test.go", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,99 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package packet\n-\n-import (\n-\t\"bytes\"\n-\t\"encoding/hex\"\n-\t\"testing\"\n-\t\"time\"\n-)\n-\n-var pubKeyTests = []struct {\n-\thexData        string\n-\thexFingerprint string\n-\tcreationTime   time.Time\n-\tpubKeyAlgo     PublicKeyAlgorithm\n-\tkeyId          uint64\n-\tkeyIdString    string\n-\tkeyIdShort     string\n-}{\n-\t{rsaPkDataHex, rsaFingerprintHex, time.Unix(0x4d3c5c10, 0), PubKeyAlgoRSA, 0xa34d7e18c20c31bb, \"A34D7E18C20C31BB\", \"C20C31BB\"},\n-\t{dsaPkDataHex, dsaFingerprintHex, time.Unix(0x4d432f89, 0), PubKeyAlgoDSA, 0x8e8fbe54062f19ed, \"8E8FBE54062F19ED\", \"062F19ED\"},\n-}\n-\n-func TestPublicKeyRead(t *testing.T) {\n-\tfor i, test := range pubKeyTests {\n-\t\tpacket, err := Read(readerFromHex(test.hexData))\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"#%d: Read error: %s\", i, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tpk, ok := packet.(*PublicKey)\n-\t\tif !ok {\n-\t\t\tt.Errorf(\"#%d: failed to parse, got: %#v\", i, packet)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif pk.PubKeyAlgo != test.pubKeyAlgo {\n-\t\t\tt.Errorf(\"#%d: bad public key algorithm got:%x want:%x\", i, pk.PubKeyAlgo, test.pubKeyAlgo)\n-\t\t}\n-\t\tif !pk.CreationTime.Equal(test.creationTime) {\n-\t\t\tt.Errorf(\"#%d: bad creation time got:%v want:%v\", i, pk.CreationTime, test.creationTime)\n-\t\t}\n-\t\texpectedFingerprint, _ := hex.DecodeString(test.hexFingerprint)\n-\t\tif !bytes.Equal(expectedFingerprint, pk.Fingerprint[:]) {\n-\t\t\tt.Errorf(\"#%d: bad fingerprint got:%x want:%x\", i, pk.Fingerprint[:], expectedFingerprint)\n-\t\t}\n-\t\tif pk.KeyId != test.keyId {\n-\t\t\tt.Errorf(\"#%d: bad keyid got:%x want:%x\", i, pk.KeyId, test.keyId)\n-\t\t}\n-\t\tif g, e := pk.KeyIdString(), test.keyIdString; g != e {\n-\t\t\tt.Errorf(\"#%d: bad KeyIdString got:%q want:%q\", i, g, e)\n-\t\t}\n-\t\tif g, e := pk.KeyIdShortString(), test.keyIdShort; g != e {\n-\t\t\tt.Errorf(\"#%d: bad KeyIdShortString got:%q want:%q\", i, g, e)\n-\t\t}\n-\t}\n-}\n-\n-func TestPublicKeySerialize(t *testing.T) {\n-\tfor i, test := range pubKeyTests {\n-\t\tpacket, err := Read(readerFromHex(test.hexData))\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"#%d: Read error: %s\", i, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tpk, ok := packet.(*PublicKey)\n-\t\tif !ok {\n-\t\t\tt.Errorf(\"#%d: failed to parse, got: %#v\", i, packet)\n-\t\t\tcontinue\n-\t\t}\n-\t\tserializeBuf := bytes.NewBuffer(nil)\n-\t\terr = pk.Serialize(serializeBuf)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"#%d: failed to serialize: %s\", i, err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tpacket, err = Read(serializeBuf)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"#%d: Read error (from serialized data): %s\", i, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tpk, ok = packet.(*PublicKey)\n-\t\tif !ok {\n-\t\t\tt.Errorf(\"#%d: failed to parse serialized data, got: %#v\", i, packet)\n-\t\t\tcontinue\n-\t\t}\n-\t}\n-}\n-\n-const rsaFingerprintHex = \"5fb74b1d03b1e3cb31bc2f8aa34d7e18c20c31bb\"\n-\n-const rsaPkDataHex = \"988d044d3c5c10010400b1d13382944bd5aba23a4312968b5095d14f947f600eb478e14a6fcb16b0e0cac764884909c020bc495cfcc39a935387c661507bdb236a0612fb582cac3af9b29cc2c8c70090616c41b662f4da4c1201e195472eb7f4ae1ccbcbf9940fe21d985e379a5563dde5b9a23d35f1cfaa5790da3b79db26f23695107bfaca8e7b5bcd0011010001\"\n-\n-const dsaFingerprintHex = \"eece4c094db002103714c63c8e8fbe54062f19ed\"\n-\n-const dsaPkDataHex = \"9901a2044d432f89110400cd581334f0d7a1e1bdc8b9d6d8c0baf68793632735d2bb0903224cbaa1dfbf35a60ee7a13b92643421e1eb41aa8d79bea19a115a677f6b8ba3c7818ce53a6c2a24a1608bd8b8d6e55c5090cbde09dd26e356267465ae25e69ec8bdd57c7bbb2623e4d73336f73a0a9098f7f16da2e25252130fd694c0e8070c55a812a423ae7f00a0ebf50e70c2f19c3520a551bd4b08d30f23530d3d03ff7d0bf4a53a64a09dc5e6e6e35854b7d70c882b0c60293401958b1bd9e40abec3ea05ba87cf64899299d4bd6aa7f459c201d3fbbd6c82004bdc5e8a9eb8082d12054cc90fa9d4ec251a843236a588bf49552441817436c4f43326966fe85447d4e6d0acf8fa1ef0f014730770603ad7634c3088dc52501c237328417c31c89ed70400b2f1a98b0bf42f11fefc430704bebbaa41d9f355600c3facee1e490f64208e0e094ea55e3a598a219a58500bf78ac677b670a14f4e47e9cf8eab4f368cc1ddcaa18cc59309d4cc62dd4f680e73e6cc3e1ce87a84d0925efbcb26c575c093fc42eecf45135fabf6403a25c2016e1774c0484e440a18319072c617cc97ac0a3bb0\""}, {"sha": "1a3e8e231338528d728ceff26301d422331c6486", "filename": "libgo/go/crypto/openpgp/packet/reader.go", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Freader.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,62 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package packet\n-\n-import (\n-\t\"crypto/openpgp/errors\"\n-\t\"io\"\n-)\n-\n-// Reader reads packets from an io.Reader and allows packets to be 'unread' so\n-// that they result from the next call to Next.\n-type Reader struct {\n-\tq       []Packet\n-\treaders []io.Reader\n-}\n-\n-// Next returns the most recently unread Packet, or reads another packet from\n-// the top-most io.Reader. Unknown packet types are skipped.\n-func (r *Reader) Next() (p Packet, err error) {\n-\tif len(r.q) > 0 {\n-\t\tp = r.q[len(r.q)-1]\n-\t\tr.q = r.q[:len(r.q)-1]\n-\t\treturn\n-\t}\n-\n-\tfor len(r.readers) > 0 {\n-\t\tp, err = Read(r.readers[len(r.readers)-1])\n-\t\tif err == nil {\n-\t\t\treturn\n-\t\t}\n-\t\tif err == io.EOF {\n-\t\t\tr.readers = r.readers[:len(r.readers)-1]\n-\t\t\tcontinue\n-\t\t}\n-\t\tif _, ok := err.(errors.UnknownPacketTypeError); !ok {\n-\t\t\treturn nil, err\n-\t\t}\n-\t}\n-\n-\treturn nil, io.EOF\n-}\n-\n-// Push causes the Reader to start reading from a new io.Reader. When an EOF\n-// error is seen from the new io.Reader, it is popped and the Reader continues\n-// to read from the next most recent io.Reader.\n-func (r *Reader) Push(reader io.Reader) {\n-\tr.readers = append(r.readers, reader)\n-}\n-\n-// Unread causes the given Packet to be returned from the next call to Next.\n-func (r *Reader) Unread(p Packet) {\n-\tr.q = append(r.q, p)\n-}\n-\n-func NewReader(r io.Reader) *Reader {\n-\treturn &Reader{\n-\t\tq:       nil,\n-\t\treaders: []io.Reader{r},\n-\t}\n-}"}, {"sha": "c3ffb3a6fb9e50397bb35133de60edc87170dd7e", "filename": "libgo/go/crypto/openpgp/packet/signature.go", "status": "removed", "additions": 0, "deletions": 611, "changes": 611, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,611 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package packet\n-\n-import (\n-\t\"crypto\"\n-\t\"crypto/dsa\"\n-\t\"crypto/openpgp/errors\"\n-\t\"crypto/openpgp/s2k\"\n-\t\"crypto/rsa\"\n-\t\"encoding/binary\"\n-\t\"hash\"\n-\t\"io\"\n-\t\"strconv\"\n-\t\"time\"\n-)\n-\n-// Signature represents a signature. See RFC 4880, section 5.2.\n-type Signature struct {\n-\tSigType    SignatureType\n-\tPubKeyAlgo PublicKeyAlgorithm\n-\tHash       crypto.Hash\n-\n-\t// HashSuffix is extra data that is hashed in after the signed data.\n-\tHashSuffix []byte\n-\t// HashTag contains the first two bytes of the hash for fast rejection\n-\t// of bad signed data.\n-\tHashTag      [2]byte\n-\tCreationTime time.Time\n-\n-\tRSASignature     parsedMPI\n-\tDSASigR, DSASigS parsedMPI\n-\n-\t// rawSubpackets contains the unparsed subpackets, in order.\n-\trawSubpackets []outputSubpacket\n-\n-\t// The following are optional so are nil when not included in the\n-\t// signature.\n-\n-\tSigLifetimeSecs, KeyLifetimeSecs                        *uint32\n-\tPreferredSymmetric, PreferredHash, PreferredCompression []uint8\n-\tIssuerKeyId                                             *uint64\n-\tIsPrimaryId                                             *bool\n-\n-\t// FlagsValid is set if any flags were given. See RFC 4880, section\n-\t// 5.2.3.21 for details.\n-\tFlagsValid                                                           bool\n-\tFlagCertify, FlagSign, FlagEncryptCommunications, FlagEncryptStorage bool\n-\n-\toutSubpackets []outputSubpacket\n-}\n-\n-func (sig *Signature) parse(r io.Reader) (err error) {\n-\t// RFC 4880, section 5.2.3\n-\tvar buf [5]byte\n-\t_, err = readFull(r, buf[:1])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tif buf[0] != 4 {\n-\t\terr = errors.UnsupportedError(\"signature packet version \" + strconv.Itoa(int(buf[0])))\n-\t\treturn\n-\t}\n-\n-\t_, err = readFull(r, buf[:5])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tsig.SigType = SignatureType(buf[0])\n-\tsig.PubKeyAlgo = PublicKeyAlgorithm(buf[1])\n-\tswitch sig.PubKeyAlgo {\n-\tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly, PubKeyAlgoDSA:\n-\tdefault:\n-\t\terr = errors.UnsupportedError(\"public key algorithm \" + strconv.Itoa(int(sig.PubKeyAlgo)))\n-\t\treturn\n-\t}\n-\n-\tvar ok bool\n-\tsig.Hash, ok = s2k.HashIdToHash(buf[2])\n-\tif !ok {\n-\t\treturn errors.UnsupportedError(\"hash function \" + strconv.Itoa(int(buf[2])))\n-\t}\n-\n-\thashedSubpacketsLength := int(buf[3])<<8 | int(buf[4])\n-\tl := 6 + hashedSubpacketsLength\n-\tsig.HashSuffix = make([]byte, l+6)\n-\tsig.HashSuffix[0] = 4\n-\tcopy(sig.HashSuffix[1:], buf[:5])\n-\thashedSubpackets := sig.HashSuffix[6:l]\n-\t_, err = readFull(r, hashedSubpackets)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\t// See RFC 4880, section 5.2.4\n-\ttrailer := sig.HashSuffix[l:]\n-\ttrailer[0] = 4\n-\ttrailer[1] = 0xff\n-\ttrailer[2] = uint8(l >> 24)\n-\ttrailer[3] = uint8(l >> 16)\n-\ttrailer[4] = uint8(l >> 8)\n-\ttrailer[5] = uint8(l)\n-\n-\terr = parseSignatureSubpackets(sig, hashedSubpackets, true)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\t_, err = readFull(r, buf[:2])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tunhashedSubpacketsLength := int(buf[0])<<8 | int(buf[1])\n-\tunhashedSubpackets := make([]byte, unhashedSubpacketsLength)\n-\t_, err = readFull(r, unhashedSubpackets)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\terr = parseSignatureSubpackets(sig, unhashedSubpackets, false)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\t_, err = readFull(r, sig.HashTag[:2])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tswitch sig.PubKeyAlgo {\n-\tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:\n-\t\tsig.RSASignature.bytes, sig.RSASignature.bitLength, err = readMPI(r)\n-\tcase PubKeyAlgoDSA:\n-\t\tsig.DSASigR.bytes, sig.DSASigR.bitLength, err = readMPI(r)\n-\t\tif err == nil {\n-\t\t\tsig.DSASigS.bytes, sig.DSASigS.bitLength, err = readMPI(r)\n-\t\t}\n-\tdefault:\n-\t\tpanic(\"unreachable\")\n-\t}\n-\treturn\n-}\n-\n-// parseSignatureSubpackets parses subpackets of the main signature packet. See\n-// RFC 4880, section 5.2.3.1.\n-func parseSignatureSubpackets(sig *Signature, subpackets []byte, isHashed bool) (err error) {\n-\tfor len(subpackets) > 0 {\n-\t\tsubpackets, err = parseSignatureSubpacket(sig, subpackets, isHashed)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\n-\tif sig.CreationTime.IsZero() {\n-\t\terr = errors.StructuralError(\"no creation time in signature\")\n-\t}\n-\n-\treturn\n-}\n-\n-type signatureSubpacketType uint8\n-\n-const (\n-\tcreationTimeSubpacket        signatureSubpacketType = 2\n-\tsignatureExpirationSubpacket signatureSubpacketType = 3\n-\tkeyExpirationSubpacket       signatureSubpacketType = 9\n-\tprefSymmetricAlgosSubpacket  signatureSubpacketType = 11\n-\tissuerSubpacket              signatureSubpacketType = 16\n-\tprefHashAlgosSubpacket       signatureSubpacketType = 21\n-\tprefCompressionSubpacket     signatureSubpacketType = 22\n-\tprimaryUserIdSubpacket       signatureSubpacketType = 25\n-\tkeyFlagsSubpacket            signatureSubpacketType = 27\n-)\n-\n-// parseSignatureSubpacket parses a single subpacket. len(subpacket) is >= 1.\n-func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (rest []byte, err error) {\n-\t// RFC 4880, section 5.2.3.1\n-\tvar (\n-\t\tlength     uint32\n-\t\tpacketType signatureSubpacketType\n-\t\tisCritical bool\n-\t)\n-\tswitch {\n-\tcase subpacket[0] < 192:\n-\t\tlength = uint32(subpacket[0])\n-\t\tsubpacket = subpacket[1:]\n-\tcase subpacket[0] < 255:\n-\t\tif len(subpacket) < 2 {\n-\t\t\tgoto Truncated\n-\t\t}\n-\t\tlength = uint32(subpacket[0]-192)<<8 + uint32(subpacket[1]) + 192\n-\t\tsubpacket = subpacket[2:]\n-\tdefault:\n-\t\tif len(subpacket) < 5 {\n-\t\t\tgoto Truncated\n-\t\t}\n-\t\tlength = uint32(subpacket[1])<<24 |\n-\t\t\tuint32(subpacket[2])<<16 |\n-\t\t\tuint32(subpacket[3])<<8 |\n-\t\t\tuint32(subpacket[4])\n-\t\tsubpacket = subpacket[5:]\n-\t}\n-\tif length > uint32(len(subpacket)) {\n-\t\tgoto Truncated\n-\t}\n-\trest = subpacket[length:]\n-\tsubpacket = subpacket[:length]\n-\tif len(subpacket) == 0 {\n-\t\terr = errors.StructuralError(\"zero length signature subpacket\")\n-\t\treturn\n-\t}\n-\tpacketType = signatureSubpacketType(subpacket[0] & 0x7f)\n-\tisCritical = subpacket[0]&0x80 == 0x80\n-\tsubpacket = subpacket[1:]\n-\tsig.rawSubpackets = append(sig.rawSubpackets, outputSubpacket{isHashed, packetType, isCritical, subpacket})\n-\tswitch packetType {\n-\tcase creationTimeSubpacket:\n-\t\tif !isHashed {\n-\t\t\terr = errors.StructuralError(\"signature creation time in non-hashed area\")\n-\t\t\treturn\n-\t\t}\n-\t\tif len(subpacket) != 4 {\n-\t\t\terr = errors.StructuralError(\"signature creation time not four bytes\")\n-\t\t\treturn\n-\t\t}\n-\t\tt := binary.BigEndian.Uint32(subpacket)\n-\t\tsig.CreationTime = time.Unix(int64(t), 0)\n-\tcase signatureExpirationSubpacket:\n-\t\t// Signature expiration time, section 5.2.3.10\n-\t\tif !isHashed {\n-\t\t\treturn\n-\t\t}\n-\t\tif len(subpacket) != 4 {\n-\t\t\terr = errors.StructuralError(\"expiration subpacket with bad length\")\n-\t\t\treturn\n-\t\t}\n-\t\tsig.SigLifetimeSecs = new(uint32)\n-\t\t*sig.SigLifetimeSecs = binary.BigEndian.Uint32(subpacket)\n-\tcase keyExpirationSubpacket:\n-\t\t// Key expiration time, section 5.2.3.6\n-\t\tif !isHashed {\n-\t\t\treturn\n-\t\t}\n-\t\tif len(subpacket) != 4 {\n-\t\t\terr = errors.StructuralError(\"key expiration subpacket with bad length\")\n-\t\t\treturn\n-\t\t}\n-\t\tsig.KeyLifetimeSecs = new(uint32)\n-\t\t*sig.KeyLifetimeSecs = binary.BigEndian.Uint32(subpacket)\n-\tcase prefSymmetricAlgosSubpacket:\n-\t\t// Preferred symmetric algorithms, section 5.2.3.7\n-\t\tif !isHashed {\n-\t\t\treturn\n-\t\t}\n-\t\tsig.PreferredSymmetric = make([]byte, len(subpacket))\n-\t\tcopy(sig.PreferredSymmetric, subpacket)\n-\tcase issuerSubpacket:\n-\t\t// Issuer, section 5.2.3.5\n-\t\tif len(subpacket) != 8 {\n-\t\t\terr = errors.StructuralError(\"issuer subpacket with bad length\")\n-\t\t\treturn\n-\t\t}\n-\t\tsig.IssuerKeyId = new(uint64)\n-\t\t*sig.IssuerKeyId = binary.BigEndian.Uint64(subpacket)\n-\tcase prefHashAlgosSubpacket:\n-\t\t// Preferred hash algorithms, section 5.2.3.8\n-\t\tif !isHashed {\n-\t\t\treturn\n-\t\t}\n-\t\tsig.PreferredHash = make([]byte, len(subpacket))\n-\t\tcopy(sig.PreferredHash, subpacket)\n-\tcase prefCompressionSubpacket:\n-\t\t// Preferred compression algorithms, section 5.2.3.9\n-\t\tif !isHashed {\n-\t\t\treturn\n-\t\t}\n-\t\tsig.PreferredCompression = make([]byte, len(subpacket))\n-\t\tcopy(sig.PreferredCompression, subpacket)\n-\tcase primaryUserIdSubpacket:\n-\t\t// Primary User ID, section 5.2.3.19\n-\t\tif !isHashed {\n-\t\t\treturn\n-\t\t}\n-\t\tif len(subpacket) != 1 {\n-\t\t\terr = errors.StructuralError(\"primary user id subpacket with bad length\")\n-\t\t\treturn\n-\t\t}\n-\t\tsig.IsPrimaryId = new(bool)\n-\t\tif subpacket[0] > 0 {\n-\t\t\t*sig.IsPrimaryId = true\n-\t\t}\n-\tcase keyFlagsSubpacket:\n-\t\t// Key flags, section 5.2.3.21\n-\t\tif !isHashed {\n-\t\t\treturn\n-\t\t}\n-\t\tif len(subpacket) == 0 {\n-\t\t\terr = errors.StructuralError(\"empty key flags subpacket\")\n-\t\t\treturn\n-\t\t}\n-\t\tsig.FlagsValid = true\n-\t\tif subpacket[0]&1 != 0 {\n-\t\t\tsig.FlagCertify = true\n-\t\t}\n-\t\tif subpacket[0]&2 != 0 {\n-\t\t\tsig.FlagSign = true\n-\t\t}\n-\t\tif subpacket[0]&4 != 0 {\n-\t\t\tsig.FlagEncryptCommunications = true\n-\t\t}\n-\t\tif subpacket[0]&8 != 0 {\n-\t\t\tsig.FlagEncryptStorage = true\n-\t\t}\n-\n-\tdefault:\n-\t\tif isCritical {\n-\t\t\terr = errors.UnsupportedError(\"unknown critical signature subpacket type \" + strconv.Itoa(int(packetType)))\n-\t\t\treturn\n-\t\t}\n-\t}\n-\treturn\n-\n-Truncated:\n-\terr = errors.StructuralError(\"signature subpacket truncated\")\n-\treturn\n-}\n-\n-// subpacketLengthLength returns the length, in bytes, of an encoded length value.\n-func subpacketLengthLength(length int) int {\n-\tif length < 192 {\n-\t\treturn 1\n-\t}\n-\tif length < 16320 {\n-\t\treturn 2\n-\t}\n-\treturn 5\n-}\n-\n-// serializeSubpacketLength marshals the given length into to.\n-func serializeSubpacketLength(to []byte, length int) int {\n-\tif length < 192 {\n-\t\tto[0] = byte(length)\n-\t\treturn 1\n-\t}\n-\tif length < 16320 {\n-\t\tlength -= 192\n-\t\tto[0] = byte(length >> 8)\n-\t\tto[1] = byte(length)\n-\t\treturn 2\n-\t}\n-\tto[0] = 255\n-\tto[1] = byte(length >> 24)\n-\tto[2] = byte(length >> 16)\n-\tto[3] = byte(length >> 8)\n-\tto[4] = byte(length)\n-\treturn 5\n-}\n-\n-// subpacketsLength returns the serialized length, in bytes, of the given\n-// subpackets.\n-func subpacketsLength(subpackets []outputSubpacket, hashed bool) (length int) {\n-\tfor _, subpacket := range subpackets {\n-\t\tif subpacket.hashed == hashed {\n-\t\t\tlength += subpacketLengthLength(len(subpacket.contents) + 1)\n-\t\t\tlength += 1 // type byte\n-\t\t\tlength += len(subpacket.contents)\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-// serializeSubpackets marshals the given subpackets into to.\n-func serializeSubpackets(to []byte, subpackets []outputSubpacket, hashed bool) {\n-\tfor _, subpacket := range subpackets {\n-\t\tif subpacket.hashed == hashed {\n-\t\t\tn := serializeSubpacketLength(to, len(subpacket.contents)+1)\n-\t\t\tto[n] = byte(subpacket.subpacketType)\n-\t\t\tto = to[1+n:]\n-\t\t\tn = copy(to, subpacket.contents)\n-\t\t\tto = to[n:]\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-// buildHashSuffix constructs the HashSuffix member of sig in preparation for signing.\n-func (sig *Signature) buildHashSuffix() (err error) {\n-\thashedSubpacketsLen := subpacketsLength(sig.outSubpackets, true)\n-\n-\tvar ok bool\n-\tl := 6 + hashedSubpacketsLen\n-\tsig.HashSuffix = make([]byte, l+6)\n-\tsig.HashSuffix[0] = 4\n-\tsig.HashSuffix[1] = uint8(sig.SigType)\n-\tsig.HashSuffix[2] = uint8(sig.PubKeyAlgo)\n-\tsig.HashSuffix[3], ok = s2k.HashToHashId(sig.Hash)\n-\tif !ok {\n-\t\tsig.HashSuffix = nil\n-\t\treturn errors.InvalidArgumentError(\"hash cannot be represented in OpenPGP: \" + strconv.Itoa(int(sig.Hash)))\n-\t}\n-\tsig.HashSuffix[4] = byte(hashedSubpacketsLen >> 8)\n-\tsig.HashSuffix[5] = byte(hashedSubpacketsLen)\n-\tserializeSubpackets(sig.HashSuffix[6:l], sig.outSubpackets, true)\n-\ttrailer := sig.HashSuffix[l:]\n-\ttrailer[0] = 4\n-\ttrailer[1] = 0xff\n-\ttrailer[2] = byte(l >> 24)\n-\ttrailer[3] = byte(l >> 16)\n-\ttrailer[4] = byte(l >> 8)\n-\ttrailer[5] = byte(l)\n-\treturn\n-}\n-\n-func (sig *Signature) signPrepareHash(h hash.Hash) (digest []byte, err error) {\n-\terr = sig.buildHashSuffix()\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\th.Write(sig.HashSuffix)\n-\tdigest = h.Sum(nil)\n-\tcopy(sig.HashTag[:], digest)\n-\treturn\n-}\n-\n-// Sign signs a message with a private key. The hash, h, must contain\n-// the hash of the message to be signed and will be mutated by this function.\n-// On success, the signature is stored in sig. Call Serialize to write it out.\n-func (sig *Signature) Sign(rand io.Reader, h hash.Hash, priv *PrivateKey) (err error) {\n-\tsig.outSubpackets = sig.buildSubpackets()\n-\tdigest, err := sig.signPrepareHash(h)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tswitch priv.PubKeyAlgo {\n-\tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:\n-\t\tsig.RSASignature.bytes, err = rsa.SignPKCS1v15(rand, priv.PrivateKey.(*rsa.PrivateKey), sig.Hash, digest)\n-\t\tsig.RSASignature.bitLength = uint16(8 * len(sig.RSASignature.bytes))\n-\tcase PubKeyAlgoDSA:\n-\t\tdsaPriv := priv.PrivateKey.(*dsa.PrivateKey)\n-\n-\t\t// Need to truncate hashBytes to match FIPS 186-3 section 4.6.\n-\t\tsubgroupSize := (dsaPriv.Q.BitLen() + 7) / 8\n-\t\tif len(digest) > subgroupSize {\n-\t\t\tdigest = digest[:subgroupSize]\n-\t\t}\n-\t\tr, s, err := dsa.Sign(rand, dsaPriv, digest)\n-\t\tif err == nil {\n-\t\t\tsig.DSASigR.bytes = r.Bytes()\n-\t\t\tsig.DSASigR.bitLength = uint16(8 * len(sig.DSASigR.bytes))\n-\t\t\tsig.DSASigS.bytes = s.Bytes()\n-\t\t\tsig.DSASigS.bitLength = uint16(8 * len(sig.DSASigS.bytes))\n-\t\t}\n-\tdefault:\n-\t\terr = errors.UnsupportedError(\"public key algorithm: \" + strconv.Itoa(int(sig.PubKeyAlgo)))\n-\t}\n-\n-\treturn\n-}\n-\n-// SignUserId computes a signature from priv, asserting that pub is a valid\n-// key for the identity id.  On success, the signature is stored in sig. Call\n-// Serialize to write it out.\n-func (sig *Signature) SignUserId(rand io.Reader, id string, pub *PublicKey, priv *PrivateKey) error {\n-\th, err := userIdSignatureHash(id, pub, sig)\n-\tif err != nil {\n-\t\treturn nil\n-\t}\n-\treturn sig.Sign(rand, h, priv)\n-}\n-\n-// SignKey computes a signature from priv, asserting that pub is a subkey.  On\n-// success, the signature is stored in sig. Call Serialize to write it out.\n-func (sig *Signature) SignKey(rand io.Reader, pub *PublicKey, priv *PrivateKey) error {\n-\th, err := keySignatureHash(&priv.PublicKey, pub, sig)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn sig.Sign(rand, h, priv)\n-}\n-\n-// Serialize marshals sig to w. SignRSA or SignDSA must have been called first.\n-func (sig *Signature) Serialize(w io.Writer) (err error) {\n-\tif len(sig.outSubpackets) == 0 {\n-\t\tsig.outSubpackets = sig.rawSubpackets\n-\t}\n-\tif sig.RSASignature.bytes == nil && sig.DSASigR.bytes == nil {\n-\t\treturn errors.InvalidArgumentError(\"Signature: need to call SignRSA or SignDSA before Serialize\")\n-\t}\n-\n-\tsigLength := 0\n-\tswitch sig.PubKeyAlgo {\n-\tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:\n-\t\tsigLength = 2 + len(sig.RSASignature.bytes)\n-\tcase PubKeyAlgoDSA:\n-\t\tsigLength = 2 + len(sig.DSASigR.bytes)\n-\t\tsigLength += 2 + len(sig.DSASigS.bytes)\n-\tdefault:\n-\t\tpanic(\"impossible\")\n-\t}\n-\n-\tunhashedSubpacketsLen := subpacketsLength(sig.outSubpackets, false)\n-\tlength := len(sig.HashSuffix) - 6 /* trailer not included */ +\n-\t\t2 /* length of unhashed subpackets */ + unhashedSubpacketsLen +\n-\t\t2 /* hash tag */ + sigLength\n-\terr = serializeHeader(w, packetTypeSignature, length)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\t_, err = w.Write(sig.HashSuffix[:len(sig.HashSuffix)-6])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tunhashedSubpackets := make([]byte, 2+unhashedSubpacketsLen)\n-\tunhashedSubpackets[0] = byte(unhashedSubpacketsLen >> 8)\n-\tunhashedSubpackets[1] = byte(unhashedSubpacketsLen)\n-\tserializeSubpackets(unhashedSubpackets[2:], sig.outSubpackets, false)\n-\n-\t_, err = w.Write(unhashedSubpackets)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\t_, err = w.Write(sig.HashTag[:])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tswitch sig.PubKeyAlgo {\n-\tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:\n-\t\terr = writeMPIs(w, sig.RSASignature)\n-\tcase PubKeyAlgoDSA:\n-\t\terr = writeMPIs(w, sig.DSASigR, sig.DSASigS)\n-\tdefault:\n-\t\tpanic(\"impossible\")\n-\t}\n-\treturn\n-}\n-\n-// outputSubpacket represents a subpacket to be marshaled.\n-type outputSubpacket struct {\n-\thashed        bool // true if this subpacket is in the hashed area.\n-\tsubpacketType signatureSubpacketType\n-\tisCritical    bool\n-\tcontents      []byte\n-}\n-\n-func (sig *Signature) buildSubpackets() (subpackets []outputSubpacket) {\n-\tcreationTime := make([]byte, 4)\n-\tbinary.BigEndian.PutUint32(creationTime, uint32(sig.CreationTime.Unix()))\n-\tsubpackets = append(subpackets, outputSubpacket{true, creationTimeSubpacket, false, creationTime})\n-\n-\tif sig.IssuerKeyId != nil {\n-\t\tkeyId := make([]byte, 8)\n-\t\tbinary.BigEndian.PutUint64(keyId, *sig.IssuerKeyId)\n-\t\tsubpackets = append(subpackets, outputSubpacket{true, issuerSubpacket, false, keyId})\n-\t}\n-\n-\tif sig.SigLifetimeSecs != nil && *sig.SigLifetimeSecs != 0 {\n-\t\tsigLifetime := make([]byte, 4)\n-\t\tbinary.BigEndian.PutUint32(sigLifetime, *sig.SigLifetimeSecs)\n-\t\tsubpackets = append(subpackets, outputSubpacket{true, signatureExpirationSubpacket, true, sigLifetime})\n-\t}\n-\n-\t// Key flags may only appear in self-signatures or certification signatures.\n-\n-\tif sig.FlagsValid {\n-\t\tvar flags byte\n-\t\tif sig.FlagCertify {\n-\t\t\tflags |= 1\n-\t\t}\n-\t\tif sig.FlagSign {\n-\t\t\tflags |= 2\n-\t\t}\n-\t\tif sig.FlagEncryptCommunications {\n-\t\t\tflags |= 4\n-\t\t}\n-\t\tif sig.FlagEncryptStorage {\n-\t\t\tflags |= 8\n-\t\t}\n-\t\tsubpackets = append(subpackets, outputSubpacket{true, keyFlagsSubpacket, false, []byte{flags}})\n-\t}\n-\n-\t// The following subpackets may only appear in self-signatures\n-\n-\tif sig.KeyLifetimeSecs != nil && *sig.KeyLifetimeSecs != 0 {\n-\t\tkeyLifetime := make([]byte, 4)\n-\t\tbinary.BigEndian.PutUint32(keyLifetime, *sig.KeyLifetimeSecs)\n-\t\tsubpackets = append(subpackets, outputSubpacket{true, keyExpirationSubpacket, true, keyLifetime})\n-\t}\n-\n-\tif sig.IsPrimaryId != nil && *sig.IsPrimaryId {\n-\t\tsubpackets = append(subpackets, outputSubpacket{true, primaryUserIdSubpacket, false, []byte{1}})\n-\t}\n-\n-\tif len(sig.PreferredSymmetric) > 0 {\n-\t\tsubpackets = append(subpackets, outputSubpacket{true, prefSymmetricAlgosSubpacket, false, sig.PreferredSymmetric})\n-\t}\n-\n-\tif len(sig.PreferredHash) > 0 {\n-\t\tsubpackets = append(subpackets, outputSubpacket{true, prefHashAlgosSubpacket, false, sig.PreferredHash})\n-\t}\n-\n-\tif len(sig.PreferredCompression) > 0 {\n-\t\tsubpackets = append(subpackets, outputSubpacket{true, prefCompressionSubpacket, false, sig.PreferredCompression})\n-\t}\n-\n-\treturn\n-}"}, {"sha": "c1bbde8b0c3b0933b5890af10037664ed576faad", "filename": "libgo/go/crypto/openpgp/packet/signature_test.go", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,42 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package packet\n-\n-import (\n-\t\"bytes\"\n-\t\"crypto\"\n-\t\"encoding/hex\"\n-\t\"testing\"\n-)\n-\n-func TestSignatureRead(t *testing.T) {\n-\tpacket, err := Read(readerFromHex(signatureDataHex))\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t\treturn\n-\t}\n-\tsig, ok := packet.(*Signature)\n-\tif !ok || sig.SigType != SigTypeBinary || sig.PubKeyAlgo != PubKeyAlgoRSA || sig.Hash != crypto.SHA1 {\n-\t\tt.Errorf(\"failed to parse, got: %#v\", packet)\n-\t}\n-}\n-\n-func TestSignatureReserialize(t *testing.T) {\n-\tpacket, _ := Read(readerFromHex(signatureDataHex))\n-\tsig := packet.(*Signature)\n-\tout := new(bytes.Buffer)\n-\terr := sig.Serialize(out)\n-\tif err != nil {\n-\t\tt.Errorf(\"error reserializing: %s\", err)\n-\t\treturn\n-\t}\n-\n-\texpected, _ := hex.DecodeString(signatureDataHex)\n-\tif !bytes.Equal(expected, out.Bytes()) {\n-\t\tt.Errorf(\"output doesn't match input (got vs expected):\\n%s\\n%s\", hex.Dump(out.Bytes()), hex.Dump(expected))\n-\t}\n-}\n-\n-const signatureDataHex = \"c2c05c04000102000605024cb45112000a0910ab105c91af38fb158f8d07ff5596ea368c5efe015bed6e78348c0f033c931d5f2ce5db54ce7f2a7e4b4ad64db758d65a7a71773edeab7ba2a9e0908e6a94a1175edd86c1d843279f045b021a6971a72702fcbd650efc393c5474d5b59a15f96d2eaad4c4c426797e0dcca2803ef41c6ff234d403eec38f31d610c344c06f2401c262f0993b2e66cad8a81ebc4322c723e0d4ba09fe917e8777658307ad8329adacba821420741009dfe87f007759f0982275d028a392c6ed983a0d846f890b36148c7358bdb8a516007fac760261ecd06076813831a36d0459075d1befa245ae7f7fb103d92ca759e9498fe60ef8078a39a3beda510deea251ea9f0a7f0df6ef42060f20780360686f3e400e\""}, {"sha": "94e0705040112f95339a8f57ef1d7b33172f9061", "filename": "libgo/go/crypto/openpgp/packet/symmetric_key_encrypted.go", "status": "removed", "additions": 0, "deletions": 161, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,161 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package packet\n-\n-import (\n-\t\"bytes\"\n-\t\"crypto/cipher\"\n-\t\"crypto/openpgp/errors\"\n-\t\"crypto/openpgp/s2k\"\n-\t\"io\"\n-\t\"strconv\"\n-)\n-\n-// This is the largest session key that we'll support. Since no 512-bit cipher\n-// has even been seriously used, this is comfortably large.\n-const maxSessionKeySizeInBytes = 64\n-\n-// SymmetricKeyEncrypted represents a passphrase protected session key. See RFC\n-// 4880, section 5.3.\n-type SymmetricKeyEncrypted struct {\n-\tCipherFunc   CipherFunction\n-\tEncrypted    bool\n-\tKey          []byte // Empty unless Encrypted is false.\n-\ts2k          func(out, in []byte)\n-\tencryptedKey []byte\n-}\n-\n-const symmetricKeyEncryptedVersion = 4\n-\n-func (ske *SymmetricKeyEncrypted) parse(r io.Reader) (err error) {\n-\t// RFC 4880, section 5.3.\n-\tvar buf [2]byte\n-\t_, err = readFull(r, buf[:])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tif buf[0] != symmetricKeyEncryptedVersion {\n-\t\treturn errors.UnsupportedError(\"SymmetricKeyEncrypted version\")\n-\t}\n-\tske.CipherFunc = CipherFunction(buf[1])\n-\n-\tif ske.CipherFunc.KeySize() == 0 {\n-\t\treturn errors.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(buf[1])))\n-\t}\n-\n-\tske.s2k, err = s2k.Parse(r)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tencryptedKey := make([]byte, maxSessionKeySizeInBytes)\n-\t// The session key may follow. We just have to try and read to find\n-\t// out. If it exists then we limit it to maxSessionKeySizeInBytes.\n-\tn, err := readFull(r, encryptedKey)\n-\tif err != nil && err != io.ErrUnexpectedEOF {\n-\t\treturn\n-\t}\n-\terr = nil\n-\tif n != 0 {\n-\t\tif n == maxSessionKeySizeInBytes {\n-\t\t\treturn errors.UnsupportedError(\"oversized encrypted session key\")\n-\t\t}\n-\t\tske.encryptedKey = encryptedKey[:n]\n-\t}\n-\n-\tske.Encrypted = true\n-\n-\treturn\n-}\n-\n-// Decrypt attempts to decrypt an encrypted session key. If it returns nil,\n-// ske.Key will contain the session key.\n-func (ske *SymmetricKeyEncrypted) Decrypt(passphrase []byte) error {\n-\tif !ske.Encrypted {\n-\t\treturn nil\n-\t}\n-\n-\tkey := make([]byte, ske.CipherFunc.KeySize())\n-\tske.s2k(key, passphrase)\n-\n-\tif len(ske.encryptedKey) == 0 {\n-\t\tske.Key = key\n-\t} else {\n-\t\t// the IV is all zeros\n-\t\tiv := make([]byte, ske.CipherFunc.blockSize())\n-\t\tc := cipher.NewCFBDecrypter(ske.CipherFunc.new(key), iv)\n-\t\tc.XORKeyStream(ske.encryptedKey, ske.encryptedKey)\n-\t\tske.CipherFunc = CipherFunction(ske.encryptedKey[0])\n-\t\tif ske.CipherFunc.blockSize() == 0 {\n-\t\t\treturn errors.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(ske.CipherFunc)))\n-\t\t}\n-\t\tske.CipherFunc = CipherFunction(ske.encryptedKey[0])\n-\t\tske.Key = ske.encryptedKey[1:]\n-\t\tif len(ske.Key)%ske.CipherFunc.blockSize() != 0 {\n-\t\t\tske.Key = nil\n-\t\t\treturn errors.StructuralError(\"length of decrypted key not a multiple of block size\")\n-\t\t}\n-\t}\n-\n-\tske.Encrypted = false\n-\treturn nil\n-}\n-\n-// SerializeSymmetricKeyEncrypted serializes a symmetric key packet to w. The\n-// packet contains a random session key, encrypted by a key derived from the\n-// given passphrase. The session key is returned and must be passed to\n-// SerializeSymmetricallyEncrypted.\n-func SerializeSymmetricKeyEncrypted(w io.Writer, rand io.Reader, passphrase []byte, cipherFunc CipherFunction) (key []byte, err error) {\n-\tkeySize := cipherFunc.KeySize()\n-\tif keySize == 0 {\n-\t\treturn nil, errors.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(cipherFunc)))\n-\t}\n-\n-\ts2kBuf := new(bytes.Buffer)\n-\tkeyEncryptingKey := make([]byte, keySize)\n-\t// s2k.Serialize salts and stretches the passphrase, and writes the\n-\t// resulting key to keyEncryptingKey and the s2k descriptor to s2kBuf.\n-\terr = s2k.Serialize(s2kBuf, keyEncryptingKey, rand, passphrase)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\ts2kBytes := s2kBuf.Bytes()\n-\n-\tpacketLength := 2 /* header */ + len(s2kBytes) + 1 /* cipher type */ + keySize\n-\terr = serializeHeader(w, packetTypeSymmetricKeyEncrypted, packetLength)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tvar buf [2]byte\n-\tbuf[0] = symmetricKeyEncryptedVersion\n-\tbuf[1] = byte(cipherFunc)\n-\t_, err = w.Write(buf[:])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\t_, err = w.Write(s2kBytes)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tsessionKey := make([]byte, keySize)\n-\t_, err = io.ReadFull(rand, sessionKey)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tiv := make([]byte, cipherFunc.blockSize())\n-\tc := cipher.NewCFBEncrypter(cipherFunc.new(keyEncryptingKey), iv)\n-\tencryptedCipherAndKey := make([]byte, keySize+1)\n-\tc.XORKeyStream(encryptedCipherAndKey, buf[1:])\n-\tc.XORKeyStream(encryptedCipherAndKey[1:], sessionKey)\n-\t_, err = w.Write(encryptedCipherAndKey)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tkey = sessionKey\n-\treturn\n-}"}, {"sha": "87690f0b7bfca6e391ef9573259f3bb56fab5582", "filename": "libgo/go/crypto/openpgp/packet/symmetric_key_encrypted_test.go", "status": "removed", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,101 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package packet\n-\n-import (\n-\t\"bytes\"\n-\t\"crypto/rand\"\n-\t\"encoding/hex\"\n-\t\"io\"\n-\t\"io/ioutil\"\n-\t\"testing\"\n-)\n-\n-func TestSymmetricKeyEncrypted(t *testing.T) {\n-\tbuf := readerFromHex(symmetricallyEncryptedHex)\n-\tpacket, err := Read(buf)\n-\tif err != nil {\n-\t\tt.Errorf(\"failed to read SymmetricKeyEncrypted: %s\", err)\n-\t\treturn\n-\t}\n-\tske, ok := packet.(*SymmetricKeyEncrypted)\n-\tif !ok {\n-\t\tt.Error(\"didn't find SymmetricKeyEncrypted packet\")\n-\t\treturn\n-\t}\n-\terr = ske.Decrypt([]byte(\"password\"))\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t\treturn\n-\t}\n-\n-\tpacket, err = Read(buf)\n-\tif err != nil {\n-\t\tt.Errorf(\"failed to read SymmetricallyEncrypted: %s\", err)\n-\t\treturn\n-\t}\n-\tse, ok := packet.(*SymmetricallyEncrypted)\n-\tif !ok {\n-\t\tt.Error(\"didn't find SymmetricallyEncrypted packet\")\n-\t\treturn\n-\t}\n-\tr, err := se.Decrypt(ske.CipherFunc, ske.Key)\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t\treturn\n-\t}\n-\n-\tcontents, err := ioutil.ReadAll(r)\n-\tif err != nil && err != io.EOF {\n-\t\tt.Error(err)\n-\t\treturn\n-\t}\n-\n-\texpectedContents, _ := hex.DecodeString(symmetricallyEncryptedContentsHex)\n-\tif !bytes.Equal(expectedContents, contents) {\n-\t\tt.Errorf(\"bad contents got:%x want:%x\", contents, expectedContents)\n-\t}\n-}\n-\n-const symmetricallyEncryptedHex = \"8c0d04030302371a0b38d884f02060c91cf97c9973b8e58e028e9501708ccfe618fb92afef7fa2d80ddadd93cf\"\n-const symmetricallyEncryptedContentsHex = \"cb1062004d14c4df636f6e74656e74732e0a\"\n-\n-func TestSerializeSymmetricKeyEncrypted(t *testing.T) {\n-\tbuf := bytes.NewBuffer(nil)\n-\tpassphrase := []byte(\"testing\")\n-\tcipherFunc := CipherAES128\n-\n-\tkey, err := SerializeSymmetricKeyEncrypted(buf, rand.Reader, passphrase, cipherFunc)\n-\tif err != nil {\n-\t\tt.Errorf(\"failed to serialize: %s\", err)\n-\t\treturn\n-\t}\n-\n-\tp, err := Read(buf)\n-\tif err != nil {\n-\t\tt.Errorf(\"failed to reparse: %s\", err)\n-\t\treturn\n-\t}\n-\tske, ok := p.(*SymmetricKeyEncrypted)\n-\tif !ok {\n-\t\tt.Errorf(\"parsed a different packet type: %#v\", p)\n-\t\treturn\n-\t}\n-\n-\tif !ske.Encrypted {\n-\t\tt.Errorf(\"SKE not encrypted but should be\")\n-\t}\n-\tif ske.CipherFunc != cipherFunc {\n-\t\tt.Errorf(\"SKE cipher function is %d (expected %d)\", ske.CipherFunc, cipherFunc)\n-\t}\n-\terr = ske.Decrypt(passphrase)\n-\tif err != nil {\n-\t\tt.Errorf(\"failed to decrypt reparsed SKE: %s\", err)\n-\t\treturn\n-\t}\n-\tif !bytes.Equal(key, ske.Key) {\n-\t\tt.Errorf(\"keys don't match after Decrpyt: %x (original) vs %x (parsed)\", key, ske.Key)\n-\t}\n-}"}, {"sha": "e99a23b9fb205ecc8f50152708b9b80286fe002b", "filename": "libgo/go/crypto/openpgp/packet/symmetrically_encrypted.go", "status": "removed", "additions": 0, "deletions": 289, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,289 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package packet\n-\n-import (\n-\t\"crypto/cipher\"\n-\t\"crypto/openpgp/errors\"\n-\t\"crypto/sha1\"\n-\t\"crypto/subtle\"\n-\t\"hash\"\n-\t\"io\"\n-\t\"strconv\"\n-)\n-\n-// SymmetricallyEncrypted represents a symmetrically encrypted byte string. The\n-// encrypted contents will consist of more OpenPGP packets. See RFC 4880,\n-// sections 5.7 and 5.13.\n-type SymmetricallyEncrypted struct {\n-\tMDC      bool // true iff this is a type 18 packet and thus has an embedded MAC.\n-\tcontents io.Reader\n-\tprefix   []byte\n-}\n-\n-const symmetricallyEncryptedVersion = 1\n-\n-func (se *SymmetricallyEncrypted) parse(r io.Reader) error {\n-\tif se.MDC {\n-\t\t// See RFC 4880, section 5.13.\n-\t\tvar buf [1]byte\n-\t\t_, err := readFull(r, buf[:])\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tif buf[0] != symmetricallyEncryptedVersion {\n-\t\t\treturn errors.UnsupportedError(\"unknown SymmetricallyEncrypted version\")\n-\t\t}\n-\t}\n-\tse.contents = r\n-\treturn nil\n-}\n-\n-// Decrypt returns a ReadCloser, from which the decrypted contents of the\n-// packet can be read. An incorrect key can, with high probability, be detected\n-// immediately and this will result in a KeyIncorrect error being returned.\n-func (se *SymmetricallyEncrypted) Decrypt(c CipherFunction, key []byte) (io.ReadCloser, error) {\n-\tkeySize := c.KeySize()\n-\tif keySize == 0 {\n-\t\treturn nil, errors.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(c)))\n-\t}\n-\tif len(key) != keySize {\n-\t\treturn nil, errors.InvalidArgumentError(\"SymmetricallyEncrypted: incorrect key length\")\n-\t}\n-\n-\tif se.prefix == nil {\n-\t\tse.prefix = make([]byte, c.blockSize()+2)\n-\t\t_, err := readFull(se.contents, se.prefix)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t} else if len(se.prefix) != c.blockSize()+2 {\n-\t\treturn nil, errors.InvalidArgumentError(\"can't try ciphers with different block lengths\")\n-\t}\n-\n-\tocfbResync := cipher.OCFBResync\n-\tif se.MDC {\n-\t\t// MDC packets use a different form of OCFB mode.\n-\t\tocfbResync = cipher.OCFBNoResync\n-\t}\n-\n-\ts := cipher.NewOCFBDecrypter(c.new(key), se.prefix, ocfbResync)\n-\tif s == nil {\n-\t\treturn nil, errors.KeyIncorrectError\n-\t}\n-\n-\tplaintext := cipher.StreamReader{S: s, R: se.contents}\n-\n-\tif se.MDC {\n-\t\t// MDC packets have an embedded hash that we need to check.\n-\t\th := sha1.New()\n-\t\th.Write(se.prefix)\n-\t\treturn &seMDCReader{in: plaintext, h: h}, nil\n-\t}\n-\n-\t// Otherwise, we just need to wrap plaintext so that it's a valid ReadCloser.\n-\treturn seReader{plaintext}, nil\n-}\n-\n-// seReader wraps an io.Reader with a no-op Close method.\n-type seReader struct {\n-\tin io.Reader\n-}\n-\n-func (ser seReader) Read(buf []byte) (int, error) {\n-\treturn ser.in.Read(buf)\n-}\n-\n-func (ser seReader) Close() error {\n-\treturn nil\n-}\n-\n-const mdcTrailerSize = 1 /* tag byte */ + 1 /* length byte */ + sha1.Size\n-\n-// An seMDCReader wraps an io.Reader, maintains a running hash and keeps hold\n-// of the most recent 22 bytes (mdcTrailerSize). Upon EOF, those bytes form an\n-// MDC packet containing a hash of the previous contents which is checked\n-// against the running hash. See RFC 4880, section 5.13.\n-type seMDCReader struct {\n-\tin          io.Reader\n-\th           hash.Hash\n-\ttrailer     [mdcTrailerSize]byte\n-\tscratch     [mdcTrailerSize]byte\n-\ttrailerUsed int\n-\terror       bool\n-\teof         bool\n-}\n-\n-func (ser *seMDCReader) Read(buf []byte) (n int, err error) {\n-\tif ser.error {\n-\t\terr = io.ErrUnexpectedEOF\n-\t\treturn\n-\t}\n-\tif ser.eof {\n-\t\terr = io.EOF\n-\t\treturn\n-\t}\n-\n-\t// If we haven't yet filled the trailer buffer then we must do that\n-\t// first.\n-\tfor ser.trailerUsed < mdcTrailerSize {\n-\t\tn, err = ser.in.Read(ser.trailer[ser.trailerUsed:])\n-\t\tser.trailerUsed += n\n-\t\tif err == io.EOF {\n-\t\t\tif ser.trailerUsed != mdcTrailerSize {\n-\t\t\t\tn = 0\n-\t\t\t\terr = io.ErrUnexpectedEOF\n-\t\t\t\tser.error = true\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tser.eof = true\n-\t\t\tn = 0\n-\t\t\treturn\n-\t\t}\n-\n-\t\tif err != nil {\n-\t\t\tn = 0\n-\t\t\treturn\n-\t\t}\n-\t}\n-\n-\t// If it's a short read then we read into a temporary buffer and shift\n-\t// the data into the caller's buffer.\n-\tif len(buf) <= mdcTrailerSize {\n-\t\tn, err = readFull(ser.in, ser.scratch[:len(buf)])\n-\t\tcopy(buf, ser.trailer[:n])\n-\t\tser.h.Write(buf[:n])\n-\t\tcopy(ser.trailer[:], ser.trailer[n:])\n-\t\tcopy(ser.trailer[mdcTrailerSize-n:], ser.scratch[:])\n-\t\tif n < len(buf) {\n-\t\t\tser.eof = true\n-\t\t\terr = io.EOF\n-\t\t}\n-\t\treturn\n-\t}\n-\n-\tn, err = ser.in.Read(buf[mdcTrailerSize:])\n-\tcopy(buf, ser.trailer[:])\n-\tser.h.Write(buf[:n])\n-\tcopy(ser.trailer[:], buf[n:])\n-\n-\tif err == io.EOF {\n-\t\tser.eof = true\n-\t}\n-\treturn\n-}\n-\n-// This is a new-format packet tag byte for a type 19 (MDC) packet.\n-const mdcPacketTagByte = byte(0x80) | 0x40 | 19\n-\n-func (ser *seMDCReader) Close() error {\n-\tif ser.error {\n-\t\treturn errors.SignatureError(\"error during reading\")\n-\t}\n-\n-\tfor !ser.eof {\n-\t\t// We haven't seen EOF so we need to read to the end\n-\t\tvar buf [1024]byte\n-\t\t_, err := ser.Read(buf[:])\n-\t\tif err == io.EOF {\n-\t\t\tbreak\n-\t\t}\n-\t\tif err != nil {\n-\t\t\treturn errors.SignatureError(\"error during reading\")\n-\t\t}\n-\t}\n-\n-\tif ser.trailer[0] != mdcPacketTagByte || ser.trailer[1] != sha1.Size {\n-\t\treturn errors.SignatureError(\"MDC packet not found\")\n-\t}\n-\tser.h.Write(ser.trailer[:2])\n-\n-\tfinal := ser.h.Sum(nil)\n-\tif subtle.ConstantTimeCompare(final, ser.trailer[2:]) != 1 {\n-\t\treturn errors.SignatureError(\"hash mismatch\")\n-\t}\n-\treturn nil\n-}\n-\n-// An seMDCWriter writes through to an io.WriteCloser while maintains a running\n-// hash of the data written. On close, it emits an MDC packet containing the\n-// running hash.\n-type seMDCWriter struct {\n-\tw io.WriteCloser\n-\th hash.Hash\n-}\n-\n-func (w *seMDCWriter) Write(buf []byte) (n int, err error) {\n-\tw.h.Write(buf)\n-\treturn w.w.Write(buf)\n-}\n-\n-func (w *seMDCWriter) Close() (err error) {\n-\tvar buf [mdcTrailerSize]byte\n-\n-\tbuf[0] = mdcPacketTagByte\n-\tbuf[1] = sha1.Size\n-\tw.h.Write(buf[:2])\n-\tdigest := w.h.Sum(nil)\n-\tcopy(buf[2:], digest)\n-\n-\t_, err = w.w.Write(buf[:])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\treturn w.w.Close()\n-}\n-\n-// noOpCloser is like an ioutil.NopCloser, but for an io.Writer.\n-type noOpCloser struct {\n-\tw io.Writer\n-}\n-\n-func (c noOpCloser) Write(data []byte) (n int, err error) {\n-\treturn c.w.Write(data)\n-}\n-\n-func (c noOpCloser) Close() error {\n-\treturn nil\n-}\n-\n-// SerializeSymmetricallyEncrypted serializes a symmetrically encrypted packet\n-// to w and returns a WriteCloser to which the to-be-encrypted packets can be\n-// written.\n-func SerializeSymmetricallyEncrypted(w io.Writer, rand io.Reader, c CipherFunction, key []byte) (contents io.WriteCloser, err error) {\n-\tif c.KeySize() != len(key) {\n-\t\treturn nil, errors.InvalidArgumentError(\"SymmetricallyEncrypted.Serialize: bad key length\")\n-\t}\n-\twriteCloser := noOpCloser{w}\n-\tciphertext, err := serializeStreamHeader(writeCloser, packetTypeSymmetricallyEncryptedMDC)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\t_, err = ciphertext.Write([]byte{symmetricallyEncryptedVersion})\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tblock := c.new(key)\n-\tblockSize := block.BlockSize()\n-\tiv := make([]byte, blockSize)\n-\t_, err = rand.Read(iv)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\ts, prefix := cipher.NewOCFBEncrypter(block, iv, cipher.OCFBNoResync)\n-\t_, err = ciphertext.Write(prefix)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tplaintext := cipher.StreamWriter{S: s, W: ciphertext}\n-\n-\th := sha1.New()\n-\th.Write(iv)\n-\th.Write(iv[blockSize-2:])\n-\tcontents = &seMDCWriter{w: plaintext, h: h}\n-\treturn\n-}"}, {"sha": "f7d133d0bbeeb6fbe467c77b7cd4a344fc87afb5", "filename": "libgo/go/crypto/openpgp/packet/symmetrically_encrypted_test.go", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,124 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package packet\n-\n-import (\n-\t\"bytes\"\n-\t\"crypto/openpgp/errors\"\n-\t\"crypto/rand\"\n-\t\"crypto/sha1\"\n-\t\"encoding/hex\"\n-\t\"io\"\n-\t\"io/ioutil\"\n-\t\"testing\"\n-)\n-\n-// TestReader wraps a []byte and returns reads of a specific length.\n-type testReader struct {\n-\tdata   []byte\n-\tstride int\n-}\n-\n-func (t *testReader) Read(buf []byte) (n int, err error) {\n-\tn = t.stride\n-\tif n > len(t.data) {\n-\t\tn = len(t.data)\n-\t}\n-\tif n > len(buf) {\n-\t\tn = len(buf)\n-\t}\n-\tcopy(buf, t.data)\n-\tt.data = t.data[n:]\n-\tif len(t.data) == 0 {\n-\t\terr = io.EOF\n-\t}\n-\treturn\n-}\n-\n-func testMDCReader(t *testing.T) {\n-\tmdcPlaintext, _ := hex.DecodeString(mdcPlaintextHex)\n-\n-\tfor stride := 1; stride < len(mdcPlaintext)/2; stride++ {\n-\t\tr := &testReader{data: mdcPlaintext, stride: stride}\n-\t\tmdcReader := &seMDCReader{in: r, h: sha1.New()}\n-\t\tbody, err := ioutil.ReadAll(mdcReader)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"stride: %d, error: %s\", stride, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif !bytes.Equal(body, mdcPlaintext[:len(mdcPlaintext)-22]) {\n-\t\t\tt.Errorf(\"stride: %d: bad contents %x\", stride, body)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\terr = mdcReader.Close()\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"stride: %d, error on Close: %s\", stride, err)\n-\t\t}\n-\t}\n-\n-\tmdcPlaintext[15] ^= 80\n-\n-\tr := &testReader{data: mdcPlaintext, stride: 2}\n-\tmdcReader := &seMDCReader{in: r, h: sha1.New()}\n-\t_, err := ioutil.ReadAll(mdcReader)\n-\tif err != nil {\n-\t\tt.Errorf(\"corruption test, error: %s\", err)\n-\t\treturn\n-\t}\n-\terr = mdcReader.Close()\n-\tif err == nil {\n-\t\tt.Error(\"corruption: no error\")\n-\t} else if _, ok := err.(*errors.SignatureError); !ok {\n-\t\tt.Errorf(\"corruption: expected SignatureError, got: %s\", err)\n-\t}\n-}\n-\n-const mdcPlaintextHex = \"a302789c3b2d93c4e0eb9aba22283539b3203335af44a134afb800c849cb4c4de10200aff40b45d31432c80cb384299a0655966d6939dfdeed1dddf980\"\n-\n-func TestSerialize(t *testing.T) {\n-\tbuf := bytes.NewBuffer(nil)\n-\tc := CipherAES128\n-\tkey := make([]byte, c.KeySize())\n-\n-\tw, err := SerializeSymmetricallyEncrypted(buf, rand.Reader, c, key)\n-\tif err != nil {\n-\t\tt.Errorf(\"error from SerializeSymmetricallyEncrypted: %s\", err)\n-\t\treturn\n-\t}\n-\n-\tcontents := []byte(\"hello world\\n\")\n-\n-\tw.Write(contents)\n-\tw.Close()\n-\n-\tp, err := Read(buf)\n-\tif err != nil {\n-\t\tt.Errorf(\"error from Read: %s\", err)\n-\t\treturn\n-\t}\n-\n-\tse, ok := p.(*SymmetricallyEncrypted)\n-\tif !ok {\n-\t\tt.Errorf(\"didn't read a *SymmetricallyEncrypted\")\n-\t\treturn\n-\t}\n-\n-\tr, err := se.Decrypt(c, key)\n-\tif err != nil {\n-\t\tt.Errorf(\"error from Decrypt: %s\", err)\n-\t\treturn\n-\t}\n-\n-\tcontentsCopy := bytes.NewBuffer(nil)\n-\t_, err = io.Copy(contentsCopy, r)\n-\tif err != nil {\n-\t\tt.Errorf(\"error from io.Copy: %s\", err)\n-\t\treturn\n-\t}\n-\tif !bytes.Equal(contentsCopy.Bytes(), contents) {\n-\t\tt.Errorf(\"contents not equal got: %x want: %x\", contentsCopy.Bytes(), contents)\n-\t}\n-}"}, {"sha": "d6bea7d4acc076fa2fc8753af6724e0fb0095e2f", "filename": "libgo/go/crypto/openpgp/packet/userid.go", "status": "removed", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fuserid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fuserid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fuserid.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,160 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package packet\n-\n-import (\n-\t\"io\"\n-\t\"io/ioutil\"\n-\t\"strings\"\n-)\n-\n-// UserId contains text that is intended to represent the name and email\n-// address of the key holder. See RFC 4880, section 5.11. By convention, this\n-// takes the form \"Full Name (Comment) <email@example.com>\"\n-type UserId struct {\n-\tId string // By convention, this takes the form \"Full Name (Comment) <email@example.com>\" which is split out in the fields below.\n-\n-\tName, Comment, Email string\n-}\n-\n-func hasInvalidCharacters(s string) bool {\n-\tfor _, c := range s {\n-\t\tswitch c {\n-\t\tcase '(', ')', '<', '>', 0:\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\treturn false\n-}\n-\n-// NewUserId returns a UserId or nil if any of the arguments contain invalid\n-// characters. The invalid characters are '\\x00', '(', ')', '<' and '>'\n-func NewUserId(name, comment, email string) *UserId {\n-\t// RFC 4880 doesn't deal with the structure of userid strings; the\n-\t// name, comment and email form is just a convention. However, there's\n-\t// no convention about escaping the metacharacters and GPG just refuses\n-\t// to create user ids where, say, the name contains a '('. We mirror\n-\t// this behaviour.\n-\n-\tif hasInvalidCharacters(name) || hasInvalidCharacters(comment) || hasInvalidCharacters(email) {\n-\t\treturn nil\n-\t}\n-\n-\tuid := new(UserId)\n-\tuid.Name, uid.Comment, uid.Email = name, comment, email\n-\tuid.Id = name\n-\tif len(comment) > 0 {\n-\t\tif len(uid.Id) > 0 {\n-\t\t\tuid.Id += \" \"\n-\t\t}\n-\t\tuid.Id += \"(\"\n-\t\tuid.Id += comment\n-\t\tuid.Id += \")\"\n-\t}\n-\tif len(email) > 0 {\n-\t\tif len(uid.Id) > 0 {\n-\t\t\tuid.Id += \" \"\n-\t\t}\n-\t\tuid.Id += \"<\"\n-\t\tuid.Id += email\n-\t\tuid.Id += \">\"\n-\t}\n-\treturn uid\n-}\n-\n-func (uid *UserId) parse(r io.Reader) (err error) {\n-\t// RFC 4880, section 5.11\n-\tb, err := ioutil.ReadAll(r)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tuid.Id = string(b)\n-\tuid.Name, uid.Comment, uid.Email = parseUserId(uid.Id)\n-\treturn\n-}\n-\n-// Serialize marshals uid to w in the form of an OpenPGP packet, including\n-// header.\n-func (uid *UserId) Serialize(w io.Writer) error {\n-\terr := serializeHeader(w, packetTypeUserId, len(uid.Id))\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\t_, err = w.Write([]byte(uid.Id))\n-\treturn err\n-}\n-\n-// parseUserId extracts the name, comment and email from a user id string that\n-// is formatted as \"Full Name (Comment) <email@example.com>\".\n-func parseUserId(id string) (name, comment, email string) {\n-\tvar n, c, e struct {\n-\t\tstart, end int\n-\t}\n-\tvar state int\n-\n-\tfor offset, rune := range id {\n-\t\tswitch state {\n-\t\tcase 0:\n-\t\t\t// Entering name\n-\t\t\tn.start = offset\n-\t\t\tstate = 1\n-\t\t\tfallthrough\n-\t\tcase 1:\n-\t\t\t// In name\n-\t\t\tif rune == '(' {\n-\t\t\t\tstate = 2\n-\t\t\t\tn.end = offset\n-\t\t\t} else if rune == '<' {\n-\t\t\t\tstate = 5\n-\t\t\t\tn.end = offset\n-\t\t\t}\n-\t\tcase 2:\n-\t\t\t// Entering comment\n-\t\t\tc.start = offset\n-\t\t\tstate = 3\n-\t\t\tfallthrough\n-\t\tcase 3:\n-\t\t\t// In comment\n-\t\t\tif rune == ')' {\n-\t\t\t\tstate = 4\n-\t\t\t\tc.end = offset\n-\t\t\t}\n-\t\tcase 4:\n-\t\t\t// Between comment and email\n-\t\t\tif rune == '<' {\n-\t\t\t\tstate = 5\n-\t\t\t}\n-\t\tcase 5:\n-\t\t\t// Entering email\n-\t\t\te.start = offset\n-\t\t\tstate = 6\n-\t\t\tfallthrough\n-\t\tcase 6:\n-\t\t\t// In email\n-\t\t\tif rune == '>' {\n-\t\t\t\tstate = 7\n-\t\t\t\te.end = offset\n-\t\t\t}\n-\t\tdefault:\n-\t\t\t// After email\n-\t\t}\n-\t}\n-\tswitch state {\n-\tcase 1:\n-\t\t// ended in the name\n-\t\tn.end = len(id)\n-\tcase 3:\n-\t\t// ended in comment\n-\t\tc.end = len(id)\n-\tcase 6:\n-\t\t// ended in email\n-\t\te.end = len(id)\n-\t}\n-\n-\tname = strings.TrimSpace(id[n.start:n.end])\n-\tcomment = strings.TrimSpace(id[c.start:c.end])\n-\temail = strings.TrimSpace(id[e.start:e.end])\n-\treturn\n-}"}, {"sha": "29681938938c687b9e6ef78b17761925042d8cad", "filename": "libgo/go/crypto/openpgp/packet/userid_test.go", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fuserid_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fuserid_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fuserid_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,87 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package packet\n-\n-import (\n-\t\"testing\"\n-)\n-\n-var userIdTests = []struct {\n-\tid                   string\n-\tname, comment, email string\n-}{\n-\t{\"\", \"\", \"\", \"\"},\n-\t{\"John Smith\", \"John Smith\", \"\", \"\"},\n-\t{\"John Smith ()\", \"John Smith\", \"\", \"\"},\n-\t{\"John Smith () <>\", \"John Smith\", \"\", \"\"},\n-\t{\"(comment\", \"\", \"comment\", \"\"},\n-\t{\"(comment)\", \"\", \"comment\", \"\"},\n-\t{\"<email\", \"\", \"\", \"email\"},\n-\t{\"<email>   sdfk\", \"\", \"\", \"email\"},\n-\t{\"  John Smith  (  Comment ) asdkflj < email > lksdfj\", \"John Smith\", \"Comment\", \"email\"},\n-\t{\"  John Smith  < email > lksdfj\", \"John Smith\", \"\", \"email\"},\n-\t{\"(<foo\", \"\", \"<foo\", \"\"},\n-\t{\"Ren\u00e9 Descartes (\u0627\u0644\u0639\u0631\u0628\u064a)\", \"Ren\u00e9 Descartes\", \"\u0627\u0644\u0639\u0631\u0628\u064a\", \"\"},\n-}\n-\n-func TestParseUserId(t *testing.T) {\n-\tfor i, test := range userIdTests {\n-\t\tname, comment, email := parseUserId(test.id)\n-\t\tif name != test.name {\n-\t\t\tt.Errorf(\"%d: name mismatch got:%s want:%s\", i, name, test.name)\n-\t\t}\n-\t\tif comment != test.comment {\n-\t\t\tt.Errorf(\"%d: comment mismatch got:%s want:%s\", i, comment, test.comment)\n-\t\t}\n-\t\tif email != test.email {\n-\t\t\tt.Errorf(\"%d: email mismatch got:%s want:%s\", i, email, test.email)\n-\t\t}\n-\t}\n-}\n-\n-var newUserIdTests = []struct {\n-\tname, comment, email, id string\n-}{\n-\t{\"foo\", \"\", \"\", \"foo\"},\n-\t{\"\", \"bar\", \"\", \"(bar)\"},\n-\t{\"\", \"\", \"baz\", \"<baz>\"},\n-\t{\"foo\", \"bar\", \"\", \"foo (bar)\"},\n-\t{\"foo\", \"\", \"baz\", \"foo <baz>\"},\n-\t{\"\", \"bar\", \"baz\", \"(bar) <baz>\"},\n-\t{\"foo\", \"bar\", \"baz\", \"foo (bar) <baz>\"},\n-}\n-\n-func TestNewUserId(t *testing.T) {\n-\tfor i, test := range newUserIdTests {\n-\t\tuid := NewUserId(test.name, test.comment, test.email)\n-\t\tif uid == nil {\n-\t\t\tt.Errorf(\"#%d: returned nil\", i)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif uid.Id != test.id {\n-\t\t\tt.Errorf(\"#%d: got '%s', want '%s'\", i, uid.Id, test.id)\n-\t\t}\n-\t}\n-}\n-\n-var invalidNewUserIdTests = []struct {\n-\tname, comment, email string\n-}{\n-\t{\"foo(\", \"\", \"\"},\n-\t{\"foo<\", \"\", \"\"},\n-\t{\"\", \"bar)\", \"\"},\n-\t{\"\", \"bar<\", \"\"},\n-\t{\"\", \"\", \"baz>\"},\n-\t{\"\", \"\", \"baz)\"},\n-\t{\"\", \"\", \"baz\\x00\"},\n-}\n-\n-func TestNewUserIdWithInvalidInput(t *testing.T) {\n-\tfor i, test := range invalidNewUserIdTests {\n-\t\tif uid := NewUserId(test.name, test.comment, test.email); uid != nil {\n-\t\t\tt.Errorf(\"#%d: returned non-nil value: %#v\", i, uid)\n-\t\t}\n-\t}\n-}"}, {"sha": "1d2343470412309278305b952cbec34b818d836f", "filename": "libgo/go/crypto/openpgp/read.go", "status": "removed", "additions": 0, "deletions": 414, "changes": 414, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,414 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package openpgp implements high level operations on OpenPGP messages.\n-package openpgp\n-\n-import (\n-\t\"crypto\"\n-\t\"crypto/openpgp/armor\"\n-\t\"crypto/openpgp/errors\"\n-\t\"crypto/openpgp/packet\"\n-\t_ \"crypto/sha256\"\n-\t\"hash\"\n-\t\"io\"\n-\t\"strconv\"\n-)\n-\n-// SignatureType is the armor type for a PGP signature.\n-var SignatureType = \"PGP SIGNATURE\"\n-\n-// readArmored reads an armored block with the given type.\n-func readArmored(r io.Reader, expectedType string) (body io.Reader, err error) {\n-\tblock, err := armor.Decode(r)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tif block.Type != expectedType {\n-\t\treturn nil, errors.InvalidArgumentError(\"expected '\" + expectedType + \"', got: \" + block.Type)\n-\t}\n-\n-\treturn block.Body, nil\n-}\n-\n-// MessageDetails contains the result of parsing an OpenPGP encrypted and/or\n-// signed message.\n-type MessageDetails struct {\n-\tIsEncrypted              bool                // true if the message was encrypted.\n-\tEncryptedToKeyIds        []uint64            // the list of recipient key ids.\n-\tIsSymmetricallyEncrypted bool                // true if a passphrase could have decrypted the message.\n-\tDecryptedWith            Key                 // the private key used to decrypt the message, if any.\n-\tIsSigned                 bool                // true if the message is signed.\n-\tSignedByKeyId            uint64              // the key id of the signer, if any.\n-\tSignedBy                 *Key                // the key of the signer, if available.\n-\tLiteralData              *packet.LiteralData // the metadata of the contents\n-\tUnverifiedBody           io.Reader           // the contents of the message.\n-\n-\t// If IsSigned is true and SignedBy is non-zero then the signature will\n-\t// be verified as UnverifiedBody is read. The signature cannot be\n-\t// checked until the whole of UnverifiedBody is read so UnverifiedBody\n-\t// must be consumed until EOF before the data can trusted. Even if a\n-\t// message isn't signed (or the signer is unknown) the data may contain\n-\t// an authentication code that is only checked once UnverifiedBody has\n-\t// been consumed. Once EOF has been seen, the following fields are\n-\t// valid. (An authentication code failure is reported as a\n-\t// SignatureError error when reading from UnverifiedBody.)\n-\tSignatureError error             // nil if the signature is good.\n-\tSignature      *packet.Signature // the signature packet itself.\n-\n-\tdecrypted io.ReadCloser\n-}\n-\n-// A PromptFunction is used as a callback by functions that may need to decrypt\n-// a private key, or prompt for a passphrase. It is called with a list of\n-// acceptable, encrypted private keys and a boolean that indicates whether a\n-// passphrase is usable. It should either decrypt a private key or return a\n-// passphrase to try. If the decrypted private key or given passphrase isn't\n-// correct, the function will be called again, forever. Any error returned will\n-// be passed up.\n-type PromptFunction func(keys []Key, symmetric bool) ([]byte, error)\n-\n-// A keyEnvelopePair is used to store a private key with the envelope that\n-// contains a symmetric key, encrypted with that key.\n-type keyEnvelopePair struct {\n-\tkey          Key\n-\tencryptedKey *packet.EncryptedKey\n-}\n-\n-// ReadMessage parses an OpenPGP message that may be signed and/or encrypted.\n-// The given KeyRing should contain both public keys (for signature\n-// verification) and, possibly encrypted, private keys for decrypting.\n-func ReadMessage(r io.Reader, keyring KeyRing, prompt PromptFunction) (md *MessageDetails, err error) {\n-\tvar p packet.Packet\n-\n-\tvar symKeys []*packet.SymmetricKeyEncrypted\n-\tvar pubKeys []keyEnvelopePair\n-\tvar se *packet.SymmetricallyEncrypted\n-\n-\tpackets := packet.NewReader(r)\n-\tmd = new(MessageDetails)\n-\tmd.IsEncrypted = true\n-\n-\t// The message, if encrypted, starts with a number of packets\n-\t// containing an encrypted decryption key. The decryption key is either\n-\t// encrypted to a public key, or with a passphrase. This loop\n-\t// collects these packets.\n-ParsePackets:\n-\tfor {\n-\t\tp, err = packets.Next()\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tswitch p := p.(type) {\n-\t\tcase *packet.SymmetricKeyEncrypted:\n-\t\t\t// This packet contains the decryption key encrypted with a passphrase.\n-\t\t\tmd.IsSymmetricallyEncrypted = true\n-\t\t\tsymKeys = append(symKeys, p)\n-\t\tcase *packet.EncryptedKey:\n-\t\t\t// This packet contains the decryption key encrypted to a public key.\n-\t\t\tmd.EncryptedToKeyIds = append(md.EncryptedToKeyIds, p.KeyId)\n-\t\t\tswitch p.Algo {\n-\t\t\tcase packet.PubKeyAlgoRSA, packet.PubKeyAlgoRSAEncryptOnly, packet.PubKeyAlgoElGamal:\n-\t\t\t\tbreak\n-\t\t\tdefault:\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tvar keys []Key\n-\t\t\tif p.KeyId == 0 {\n-\t\t\t\tkeys = keyring.DecryptionKeys()\n-\t\t\t} else {\n-\t\t\t\tkeys = keyring.KeysById(p.KeyId)\n-\t\t\t}\n-\t\t\tfor _, k := range keys {\n-\t\t\t\tpubKeys = append(pubKeys, keyEnvelopePair{k, p})\n-\t\t\t}\n-\t\tcase *packet.SymmetricallyEncrypted:\n-\t\t\tse = p\n-\t\t\tbreak ParsePackets\n-\t\tcase *packet.Compressed, *packet.LiteralData, *packet.OnePassSignature:\n-\t\t\t// This message isn't encrypted.\n-\t\t\tif len(symKeys) != 0 || len(pubKeys) != 0 {\n-\t\t\t\treturn nil, errors.StructuralError(\"key material not followed by encrypted message\")\n-\t\t\t}\n-\t\t\tpackets.Unread(p)\n-\t\t\treturn readSignedMessage(packets, nil, keyring)\n-\t\t}\n-\t}\n-\n-\tvar candidates []Key\n-\tvar decrypted io.ReadCloser\n-\n-\t// Now that we have the list of encrypted keys we need to decrypt at\n-\t// least one of them or, if we cannot, we need to call the prompt\n-\t// function so that it can decrypt a key or give us a passphrase.\n-FindKey:\n-\tfor {\n-\t\t// See if any of the keys already have a private key available\n-\t\tcandidates = candidates[:0]\n-\t\tcandidateFingerprints := make(map[string]bool)\n-\n-\t\tfor _, pk := range pubKeys {\n-\t\t\tif pk.key.PrivateKey == nil {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tif !pk.key.PrivateKey.Encrypted {\n-\t\t\t\tif len(pk.encryptedKey.Key) == 0 {\n-\t\t\t\t\tpk.encryptedKey.Decrypt(pk.key.PrivateKey)\n-\t\t\t\t}\n-\t\t\t\tif len(pk.encryptedKey.Key) == 0 {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\tdecrypted, err = se.Decrypt(pk.encryptedKey.CipherFunc, pk.encryptedKey.Key)\n-\t\t\t\tif err != nil && err != errors.KeyIncorrectError {\n-\t\t\t\t\treturn nil, err\n-\t\t\t\t}\n-\t\t\t\tif decrypted != nil {\n-\t\t\t\t\tmd.DecryptedWith = pk.key\n-\t\t\t\t\tbreak FindKey\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tfpr := string(pk.key.PublicKey.Fingerprint[:])\n-\t\t\t\tif v := candidateFingerprints[fpr]; v {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\tcandidates = append(candidates, pk.key)\n-\t\t\t\tcandidateFingerprints[fpr] = true\n-\t\t\t}\n-\t\t}\n-\n-\t\tif len(candidates) == 0 && len(symKeys) == 0 {\n-\t\t\treturn nil, errors.KeyIncorrectError\n-\t\t}\n-\n-\t\tif prompt == nil {\n-\t\t\treturn nil, errors.KeyIncorrectError\n-\t\t}\n-\n-\t\tpassphrase, err := prompt(candidates, len(symKeys) != 0)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\t// Try the symmetric passphrase first\n-\t\tif len(symKeys) != 0 && passphrase != nil {\n-\t\t\tfor _, s := range symKeys {\n-\t\t\t\terr = s.Decrypt(passphrase)\n-\t\t\t\tif err == nil && !s.Encrypted {\n-\t\t\t\t\tdecrypted, err = se.Decrypt(s.CipherFunc, s.Key)\n-\t\t\t\t\tif err != nil && err != errors.KeyIncorrectError {\n-\t\t\t\t\t\treturn nil, err\n-\t\t\t\t\t}\n-\t\t\t\t\tif decrypted != nil {\n-\t\t\t\t\t\tbreak FindKey\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tmd.decrypted = decrypted\n-\tpackets.Push(decrypted)\n-\treturn readSignedMessage(packets, md, keyring)\n-}\n-\n-// readSignedMessage reads a possibly signed message if mdin is non-zero then\n-// that structure is updated and returned. Otherwise a fresh MessageDetails is\n-// used.\n-func readSignedMessage(packets *packet.Reader, mdin *MessageDetails, keyring KeyRing) (md *MessageDetails, err error) {\n-\tif mdin == nil {\n-\t\tmdin = new(MessageDetails)\n-\t}\n-\tmd = mdin\n-\n-\tvar p packet.Packet\n-\tvar h hash.Hash\n-\tvar wrappedHash hash.Hash\n-FindLiteralData:\n-\tfor {\n-\t\tp, err = packets.Next()\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tswitch p := p.(type) {\n-\t\tcase *packet.Compressed:\n-\t\t\tpackets.Push(p.Body)\n-\t\tcase *packet.OnePassSignature:\n-\t\t\tif !p.IsLast {\n-\t\t\t\treturn nil, errors.UnsupportedError(\"nested signatures\")\n-\t\t\t}\n-\n-\t\t\th, wrappedHash, err = hashForSignature(p.Hash, p.SigType)\n-\t\t\tif err != nil {\n-\t\t\t\tmd = nil\n-\t\t\t\treturn\n-\t\t\t}\n-\n-\t\t\tmd.IsSigned = true\n-\t\t\tmd.SignedByKeyId = p.KeyId\n-\t\t\tkeys := keyring.KeysById(p.KeyId)\n-\t\t\tfor i, key := range keys {\n-\t\t\t\tif key.SelfSignature.FlagsValid && !key.SelfSignature.FlagSign {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\tmd.SignedBy = &keys[i]\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\tcase *packet.LiteralData:\n-\t\t\tmd.LiteralData = p\n-\t\t\tbreak FindLiteralData\n-\t\t}\n-\t}\n-\n-\tif md.SignedBy != nil {\n-\t\tmd.UnverifiedBody = &signatureCheckReader{packets, h, wrappedHash, md}\n-\t} else if md.decrypted != nil {\n-\t\tmd.UnverifiedBody = checkReader{md}\n-\t} else {\n-\t\tmd.UnverifiedBody = md.LiteralData.Body\n-\t}\n-\n-\treturn md, nil\n-}\n-\n-// hashForSignature returns a pair of hashes that can be used to verify a\n-// signature. The signature may specify that the contents of the signed message\n-// should be preprocessed (i.e. to normalize line endings). Thus this function\n-// returns two hashes. The second should be used to hash the message itself and\n-// performs any needed preprocessing.\n-func hashForSignature(hashId crypto.Hash, sigType packet.SignatureType) (hash.Hash, hash.Hash, error) {\n-\th := hashId.New()\n-\tif h == nil {\n-\t\treturn nil, nil, errors.UnsupportedError(\"hash not available: \" + strconv.Itoa(int(hashId)))\n-\t}\n-\n-\tswitch sigType {\n-\tcase packet.SigTypeBinary:\n-\t\treturn h, h, nil\n-\tcase packet.SigTypeText:\n-\t\treturn h, NewCanonicalTextHash(h), nil\n-\t}\n-\n-\treturn nil, nil, errors.UnsupportedError(\"unsupported signature type: \" + strconv.Itoa(int(sigType)))\n-}\n-\n-// checkReader wraps an io.Reader from a LiteralData packet. When it sees EOF\n-// it closes the ReadCloser from any SymmetricallyEncrypted packet to trigger\n-// MDC checks.\n-type checkReader struct {\n-\tmd *MessageDetails\n-}\n-\n-func (cr checkReader) Read(buf []byte) (n int, err error) {\n-\tn, err = cr.md.LiteralData.Body.Read(buf)\n-\tif err == io.EOF {\n-\t\tmdcErr := cr.md.decrypted.Close()\n-\t\tif mdcErr != nil {\n-\t\t\terr = mdcErr\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-// signatureCheckReader wraps an io.Reader from a LiteralData packet and hashes\n-// the data as it is read. When it sees an EOF from the underlying io.Reader\n-// it parses and checks a trailing Signature packet and triggers any MDC checks.\n-type signatureCheckReader struct {\n-\tpackets        *packet.Reader\n-\th, wrappedHash hash.Hash\n-\tmd             *MessageDetails\n-}\n-\n-func (scr *signatureCheckReader) Read(buf []byte) (n int, err error) {\n-\tn, err = scr.md.LiteralData.Body.Read(buf)\n-\tscr.wrappedHash.Write(buf[:n])\n-\tif err == io.EOF {\n-\t\tvar p packet.Packet\n-\t\tp, scr.md.SignatureError = scr.packets.Next()\n-\t\tif scr.md.SignatureError != nil {\n-\t\t\treturn\n-\t\t}\n-\n-\t\tvar ok bool\n-\t\tif scr.md.Signature, ok = p.(*packet.Signature); !ok {\n-\t\t\tscr.md.SignatureError = errors.StructuralError(\"LiteralData not followed by Signature\")\n-\t\t\treturn\n-\t\t}\n-\n-\t\tscr.md.SignatureError = scr.md.SignedBy.PublicKey.VerifySignature(scr.h, scr.md.Signature)\n-\n-\t\t// The SymmetricallyEncrypted packet, if any, might have an\n-\t\t// unsigned hash of its own. In order to check this we need to\n-\t\t// close that Reader.\n-\t\tif scr.md.decrypted != nil {\n-\t\t\tmdcErr := scr.md.decrypted.Close()\n-\t\t\tif mdcErr != nil {\n-\t\t\t\terr = mdcErr\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-// CheckDetachedSignature takes a signed file and a detached signature and\n-// returns the signer if the signature is valid. If the signer isn't know,\n-// UnknownIssuerError is returned.\n-func CheckDetachedSignature(keyring KeyRing, signed, signature io.Reader) (signer *Entity, err error) {\n-\tp, err := packet.Read(signature)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tsig, ok := p.(*packet.Signature)\n-\tif !ok {\n-\t\treturn nil, errors.StructuralError(\"non signature packet found\")\n-\t}\n-\n-\tif sig.IssuerKeyId == nil {\n-\t\treturn nil, errors.StructuralError(\"signature doesn't have an issuer\")\n-\t}\n-\n-\tkeys := keyring.KeysById(*sig.IssuerKeyId)\n-\tif len(keys) == 0 {\n-\t\treturn nil, errors.UnknownIssuerError\n-\t}\n-\n-\th, wrappedHash, err := hashForSignature(sig.Hash, sig.SigType)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\t_, err = io.Copy(wrappedHash, signed)\n-\tif err != nil && err != io.EOF {\n-\t\treturn\n-\t}\n-\n-\tfor _, key := range keys {\n-\t\tif key.SelfSignature.FlagsValid && !key.SelfSignature.FlagSign {\n-\t\t\tcontinue\n-\t\t}\n-\t\terr = key.PublicKey.VerifySignature(h, sig)\n-\t\tif err == nil {\n-\t\t\treturn key.Entity, nil\n-\t\t}\n-\t}\n-\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\treturn nil, errors.UnknownIssuerError\n-}\n-\n-// CheckArmoredDetachedSignature performs the same actions as\n-// CheckDetachedSignature but expects the signature to be armored.\n-func CheckArmoredDetachedSignature(keyring KeyRing, signed, signature io.Reader) (signer *Entity, err error) {\n-\tbody, err := readArmored(signature, SignatureType)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\treturn CheckDetachedSignature(keyring, signed, body)\n-}"}, {"sha": "d1ecad3817958cff067ffc8ff60771c2da05ec78", "filename": "libgo/go/crypto/openpgp/read_test.go", "status": "removed", "additions": 0, "deletions": 372, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,372 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package openpgp\n-\n-import (\n-\t\"bytes\"\n-\t\"crypto/openpgp/errors\"\n-\t_ \"crypto/sha512\"\n-\t\"encoding/hex\"\n-\t\"io\"\n-\t\"io/ioutil\"\n-\t\"testing\"\n-)\n-\n-func readerFromHex(s string) io.Reader {\n-\tdata, err := hex.DecodeString(s)\n-\tif err != nil {\n-\t\tpanic(\"readerFromHex: bad input\")\n-\t}\n-\treturn bytes.NewBuffer(data)\n-}\n-\n-func TestReadKeyRing(t *testing.T) {\n-\tkring, err := ReadKeyRing(readerFromHex(testKeys1And2Hex))\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t\treturn\n-\t}\n-\tif len(kring) != 2 || uint32(kring[0].PrimaryKey.KeyId) != 0xC20C31BB || uint32(kring[1].PrimaryKey.KeyId) != 0x1E35246B {\n-\t\tt.Errorf(\"bad keyring: %#v\", kring)\n-\t}\n-}\n-\n-func TestRereadKeyRing(t *testing.T) {\n-\tkring, err := ReadKeyRing(readerFromHex(testKeys1And2Hex))\n-\tif err != nil {\n-\t\tt.Errorf(\"error in initial parse: %s\", err)\n-\t\treturn\n-\t}\n-\tout := new(bytes.Buffer)\n-\terr = kring[0].Serialize(out)\n-\tif err != nil {\n-\t\tt.Errorf(\"error in serialization: %s\", err)\n-\t\treturn\n-\t}\n-\tkring, err = ReadKeyRing(out)\n-\tif err != nil {\n-\t\tt.Errorf(\"error in second parse: %s\", err)\n-\t\treturn\n-\t}\n-\n-\tif len(kring) != 1 || uint32(kring[0].PrimaryKey.KeyId) != 0xC20C31BB {\n-\t\tt.Errorf(\"bad keyring: %#v\", kring)\n-\t}\n-}\n-\n-func TestReadPrivateKeyRing(t *testing.T) {\n-\tkring, err := ReadKeyRing(readerFromHex(testKeys1And2PrivateHex))\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t\treturn\n-\t}\n-\tif len(kring) != 2 || uint32(kring[0].PrimaryKey.KeyId) != 0xC20C31BB || uint32(kring[1].PrimaryKey.KeyId) != 0x1E35246B || kring[0].PrimaryKey == nil {\n-\t\tt.Errorf(\"bad keyring: %#v\", kring)\n-\t}\n-}\n-\n-func TestReadDSAKey(t *testing.T) {\n-\tkring, err := ReadKeyRing(readerFromHex(dsaTestKeyHex))\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t\treturn\n-\t}\n-\tif len(kring) != 1 || uint32(kring[0].PrimaryKey.KeyId) != 0x0CCC0360 {\n-\t\tt.Errorf(\"bad parse: %#v\", kring)\n-\t}\n-}\n-\n-func TestDSAHashTruncatation(t *testing.T) {\n-\t// dsaKeyWithSHA512 was generated with GnuPG and --cert-digest-algo\n-\t// SHA512 in order to require DSA hash truncation to verify correctly.\n-\t_, err := ReadKeyRing(readerFromHex(dsaKeyWithSHA512))\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t}\n-}\n-\n-func TestGetKeyById(t *testing.T) {\n-\tkring, _ := ReadKeyRing(readerFromHex(testKeys1And2Hex))\n-\n-\tkeys := kring.KeysById(0xa34d7e18c20c31bb)\n-\tif len(keys) != 1 || keys[0].Entity != kring[0] {\n-\t\tt.Errorf(\"bad result for 0xa34d7e18c20c31bb: %#v\", keys)\n-\t}\n-\n-\tkeys = kring.KeysById(0xfd94408d4543314f)\n-\tif len(keys) != 1 || keys[0].Entity != kring[0] {\n-\t\tt.Errorf(\"bad result for 0xa34d7e18c20c31bb: %#v\", keys)\n-\t}\n-}\n-\n-func checkSignedMessage(t *testing.T, signedHex, expected string) {\n-\tkring, _ := ReadKeyRing(readerFromHex(testKeys1And2Hex))\n-\n-\tmd, err := ReadMessage(readerFromHex(signedHex), kring, nil)\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t\treturn\n-\t}\n-\n-\tif !md.IsSigned || md.SignedByKeyId != 0xa34d7e18c20c31bb || md.SignedBy == nil || md.IsEncrypted || md.IsSymmetricallyEncrypted || len(md.EncryptedToKeyIds) != 0 || md.IsSymmetricallyEncrypted {\n-\t\tt.Errorf(\"bad MessageDetails: %#v\", md)\n-\t}\n-\n-\tcontents, err := ioutil.ReadAll(md.UnverifiedBody)\n-\tif err != nil {\n-\t\tt.Errorf(\"error reading UnverifiedBody: %s\", err)\n-\t}\n-\tif string(contents) != expected {\n-\t\tt.Errorf(\"bad UnverifiedBody got:%s want:%s\", string(contents), expected)\n-\t}\n-\tif md.SignatureError != nil || md.Signature == nil {\n-\t\tt.Errorf(\"failed to validate: %s\", md.SignatureError)\n-\t}\n-}\n-\n-func TestSignedMessage(t *testing.T) {\n-\tcheckSignedMessage(t, signedMessageHex, signedInput)\n-}\n-\n-func TestTextSignedMessage(t *testing.T) {\n-\tcheckSignedMessage(t, signedTextMessageHex, signedTextInput)\n-}\n-\n-var signedEncryptedMessageTests = []struct {\n-\tkeyRingHex       string\n-\tmessageHex       string\n-\tsignedByKeyId    uint64\n-\tencryptedToKeyId uint64\n-}{\n-\t{\n-\t\ttestKeys1And2PrivateHex,\n-\t\tsignedEncryptedMessageHex,\n-\t\t0xa34d7e18c20c31bb,\n-\t\t0x2a67d68660df41c7,\n-\t},\n-\t{\n-\t\tdsaElGamalTestKeysHex,\n-\t\tsignedEncryptedMessage2Hex,\n-\t\t0x33af447ccd759b09,\n-\t\t0xcf6a7abcd43e3673,\n-\t},\n-}\n-\n-func TestSignedEncryptedMessage(t *testing.T) {\n-\tfor i, test := range signedEncryptedMessageTests {\n-\t\texpected := \"Signed and encrypted message\\n\"\n-\t\tkring, _ := ReadKeyRing(readerFromHex(test.keyRingHex))\n-\t\tprompt := func(keys []Key, symmetric bool) ([]byte, error) {\n-\t\t\tif symmetric {\n-\t\t\t\tt.Errorf(\"prompt: message was marked as symmetrically encrypted\")\n-\t\t\t\treturn nil, errors.KeyIncorrectError\n-\t\t\t}\n-\n-\t\t\tif len(keys) == 0 {\n-\t\t\t\tt.Error(\"prompt: no keys requested\")\n-\t\t\t\treturn nil, errors.KeyIncorrectError\n-\t\t\t}\n-\n-\t\t\terr := keys[0].PrivateKey.Decrypt([]byte(\"passphrase\"))\n-\t\t\tif err != nil {\n-\t\t\t\tt.Errorf(\"prompt: error decrypting key: %s\", err)\n-\t\t\t\treturn nil, errors.KeyIncorrectError\n-\t\t\t}\n-\n-\t\t\treturn nil, nil\n-\t\t}\n-\n-\t\tmd, err := ReadMessage(readerFromHex(test.messageHex), kring, prompt)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"#%d: error reading message: %s\", i, err)\n-\t\t\treturn\n-\t\t}\n-\n-\t\tif !md.IsSigned || md.SignedByKeyId != test.signedByKeyId || md.SignedBy == nil || !md.IsEncrypted || md.IsSymmetricallyEncrypted || len(md.EncryptedToKeyIds) == 0 || md.EncryptedToKeyIds[0] != test.encryptedToKeyId {\n-\t\t\tt.Errorf(\"#%d: bad MessageDetails: %#v\", i, md)\n-\t\t}\n-\n-\t\tcontents, err := ioutil.ReadAll(md.UnverifiedBody)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"#%d: error reading UnverifiedBody: %s\", i, err)\n-\t\t}\n-\t\tif string(contents) != expected {\n-\t\t\tt.Errorf(\"#%d: bad UnverifiedBody got:%s want:%s\", i, string(contents), expected)\n-\t\t}\n-\n-\t\tif md.SignatureError != nil || md.Signature == nil {\n-\t\t\tt.Errorf(\"#%d: failed to validate: %s\", i, md.SignatureError)\n-\t\t}\n-\t}\n-}\n-\n-func TestUnspecifiedRecipient(t *testing.T) {\n-\texpected := \"Recipient unspecified\\n\"\n-\tkring, _ := ReadKeyRing(readerFromHex(testKeys1And2PrivateHex))\n-\n-\tmd, err := ReadMessage(readerFromHex(recipientUnspecifiedHex), kring, nil)\n-\tif err != nil {\n-\t\tt.Errorf(\"error reading message: %s\", err)\n-\t\treturn\n-\t}\n-\n-\tcontents, err := ioutil.ReadAll(md.UnverifiedBody)\n-\tif err != nil {\n-\t\tt.Errorf(\"error reading UnverifiedBody: %s\", err)\n-\t}\n-\tif string(contents) != expected {\n-\t\tt.Errorf(\"bad UnverifiedBody got:%s want:%s\", string(contents), expected)\n-\t}\n-}\n-\n-func TestSymmetricallyEncrypted(t *testing.T) {\n-\texpected := \"Symmetrically encrypted.\\n\"\n-\n-\tprompt := func(keys []Key, symmetric bool) ([]byte, error) {\n-\t\tif len(keys) != 0 {\n-\t\t\tt.Errorf(\"prompt: len(keys) = %d (want 0)\", len(keys))\n-\t\t}\n-\n-\t\tif !symmetric {\n-\t\t\tt.Errorf(\"symmetric is not set\")\n-\t\t}\n-\n-\t\treturn []byte(\"password\"), nil\n-\t}\n-\n-\tmd, err := ReadMessage(readerFromHex(symmetricallyEncryptedCompressedHex), nil, prompt)\n-\tif err != nil {\n-\t\tt.Errorf(\"ReadMessage: %s\", err)\n-\t\treturn\n-\t}\n-\n-\tcontents, err := ioutil.ReadAll(md.UnverifiedBody)\n-\tif err != nil {\n-\t\tt.Errorf(\"ReadAll: %s\", err)\n-\t}\n-\n-\texpectedCreationTime := uint32(1295992998)\n-\tif md.LiteralData.Time != expectedCreationTime {\n-\t\tt.Errorf(\"LiteralData.Time is %d, want %d\", md.LiteralData.Time, expectedCreationTime)\n-\t}\n-\n-\tif string(contents) != expected {\n-\t\tt.Errorf(\"contents got: %s want: %s\", string(contents), expected)\n-\t}\n-}\n-\n-func testDetachedSignature(t *testing.T, kring KeyRing, signature io.Reader, sigInput, tag string, expectedSignerKeyId uint64) {\n-\tsigned := bytes.NewBufferString(sigInput)\n-\tsigner, err := CheckDetachedSignature(kring, signed, signature)\n-\tif err != nil {\n-\t\tt.Errorf(\"%s: signature error: %s\", tag, err)\n-\t\treturn\n-\t}\n-\tif signer == nil {\n-\t\tt.Errorf(\"%s: signer is nil\", tag)\n-\t\treturn\n-\t}\n-\tif signer.PrimaryKey.KeyId != expectedSignerKeyId {\n-\t\tt.Errorf(\"%s: wrong signer got:%x want:%x\", tag, signer.PrimaryKey.KeyId, expectedSignerKeyId)\n-\t}\n-}\n-\n-func TestDetachedSignature(t *testing.T) {\n-\tkring, _ := ReadKeyRing(readerFromHex(testKeys1And2Hex))\n-\ttestDetachedSignature(t, kring, readerFromHex(detachedSignatureHex), signedInput, \"binary\", testKey1KeyId)\n-\ttestDetachedSignature(t, kring, readerFromHex(detachedSignatureTextHex), signedInput, \"text\", testKey1KeyId)\n-}\n-\n-func TestDetachedSignatureDSA(t *testing.T) {\n-\tkring, _ := ReadKeyRing(readerFromHex(dsaTestKeyHex))\n-\ttestDetachedSignature(t, kring, readerFromHex(detachedSignatureDSAHex), signedInput, \"binary\", testKey3KeyId)\n-}\n-\n-func TestReadingArmoredPrivateKey(t *testing.T) {\n-\tel, err := ReadArmoredKeyRing(bytes.NewBufferString(armoredPrivateKeyBlock))\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t}\n-\tif len(el) != 1 {\n-\t\tt.Errorf(\"got %d entities, wanted 1\\n\", len(el))\n-\t}\n-}\n-\n-func TestNoArmoredData(t *testing.T) {\n-\t_, err := ReadArmoredKeyRing(bytes.NewBufferString(\"foo\"))\n-\tif _, ok := err.(errors.InvalidArgumentError); !ok {\n-\t\tt.Errorf(\"error was not an InvalidArgumentError: %s\", err)\n-\t}\n-}\n-\n-const testKey1KeyId = 0xA34D7E18C20C31BB\n-const testKey3KeyId = 0x338934250CCC0360\n-\n-const signedInput = \"Signed message\\nline 2\\nline 3\\n\"\n-const signedTextInput = \"Signed message\\r\\nline 2\\r\\nline 3\\r\\n\"\n-\n-const recipientUnspecifiedHex = \"848c0300000000000000000103ff62d4d578d03cf40c3da998dfe216c074fa6ddec5e31c197c9666ba292830d91d18716a80f699f9d897389a90e6d62d0238f5f07a5248073c0f24920e4bc4a30c2d17ee4e0cae7c3d4aaa4e8dced50e3010a80ee692175fa0385f62ecca4b56ee6e9980aa3ec51b61b077096ac9e800edaf161268593eedb6cc7027ff5cb32745d250010d407a6221ae22ef18469b444f2822478c4d190b24d36371a95cb40087cdd42d9399c3d06a53c0673349bfb607927f20d1e122bde1e2bf3aa6cae6edf489629bcaa0689539ae3b718914d88ededc3b\"\n-\n-const detachedSignatureHex = \"889c04000102000605024d449cd1000a0910a34d7e18c20c31bb167603ff57718d09f28a519fdc7b5a68b6a3336da04df85e38c5cd5d5bd2092fa4629848a33d85b1729402a2aab39c3ac19f9d573f773cc62c264dc924c067a79dfd8a863ae06c7c8686120760749f5fd9b1e03a64d20a7df3446ddc8f0aeadeaeba7cbaee5c1e366d65b6a0c6cc749bcb912d2f15013f812795c2e29eb7f7b77f39ce77\"\n-\n-const detachedSignatureTextHex = \"889c04010102000605024d449d21000a0910a34d7e18c20c31bbc8c60400a24fbef7342603a41cb1165767bd18985d015fb72fe05db42db36cfb2f1d455967f1e491194fbf6cf88146222b23bf6ffbd50d17598d976a0417d3192ff9cc0034fd00f287b02e90418bbefe609484b09231e4e7a5f3562e199bf39909ab5276c4d37382fe088f6b5c3426fc1052865da8b3ab158672d58b6264b10823dc4b39\"\n-\n-const detachedSignatureDSAHex = \"884604001102000605024d6c4eac000a0910338934250ccc0360f18d00a087d743d6405ed7b87755476629600b8b694a39e900a0abff8126f46faf1547c1743c37b21b4ea15b8f83\"\n-\n-const testKeys1And2Hex = \"988d044d3c5c10010400b1d13382944bd5aba23a4312968b5095d14f947f600eb478e14a6fcb16b0e0cac764884909c020bc495cfcc39a935387c661507bdb236a0612fb582cac3af9b29cc2c8c70090616c41b662f4da4c1201e195472eb7f4ae1ccbcbf9940fe21d985e379a5563dde5b9a23d35f1cfaa5790da3b79db26f23695107bfaca8e7b5bcd0011010001b41054657374204b6579203120285253412988b804130102002205024d3c5c10021b03060b090807030206150802090a0b0416020301021e01021780000a0910a34d7e18c20c31bbb5b304009cc45fe610b641a2c146331be94dade0a396e73ca725e1b25c21708d9cab46ecca5ccebc23055879df8f99eea39b377962a400f2ebdc36a7c99c333d74aeba346315137c3ff9d0a09b0273299090343048afb8107cf94cbd1400e3026f0ccac7ecebbc4d78588eb3e478fe2754d3ca664bcf3eac96ca4a6b0c8d7df5102f60f6b0020003b88d044d3c5c10010400b201df61d67487301f11879d514f4248ade90c8f68c7af1284c161098de4c28c2850f1ec7b8e30f959793e571542ffc6532189409cb51c3d30dad78c4ad5165eda18b20d9826d8707d0f742e2ab492103a85bbd9ddf4f5720f6de7064feb0d39ee002219765bb07bcfb8b877f47abe270ddeda4f676108cecb6b9bb2ad484a4f0011010001889f04180102000905024d3c5c10021b0c000a0910a34d7e18c20c31bb1a03040085c8d62e16d05dc4e9dad64953c8a2eed8b6c12f92b1575eeaa6dcf7be9473dd5b24b37b6dffbb4e7c99ed1bd3cb11634be19b3e6e207bed7505c7ca111ccf47cb323bf1f8851eb6360e8034cbff8dd149993c959de89f8f77f38e7e98b8e3076323aa719328e2b408db5ec0d03936efd57422ba04f925cdc7b4c1af7590e40ab0020003988d044d3c5c33010400b488c3e5f83f4d561f317817538d9d0397981e9aef1321ca68ebfae1cf8b7d388e19f4b5a24a82e2fbbf1c6c26557a6c5845307a03d815756f564ac7325b02bc83e87d5480a8fae848f07cb891f2d51ce7df83dcafdc12324517c86d472cc0ee10d47a68fd1d9ae49a6c19bbd36d82af597a0d88cc9c49de9df4e696fc1f0b5d0011010001b42754657374204b6579203220285253412c20656e637279707465642070726976617465206b65792988b804130102002205024d3c5c33021b03060b090807030206150802090a0b0416020301021e01021780000a0910d4984f961e35246b98940400908a73b6a6169f700434f076c6c79015a49bee37130eaf23aaa3cfa9ce60bfe4acaa7bc95f1146ada5867e0079babb38804891f4f0b8ebca57a86b249dee786161a755b7a342e68ccf3f78ed6440a93a6626beb9a37aa66afcd4f888790cb4bb46d94a4ae3eb3d7d3e6b00f6bfec940303e89ec5b32a1eaaacce66497d539328b0020003b88d044d3c5c33010400a4e913f9442abcc7f1804ccab27d2f787ffa592077ca935a8bb23165bd8d57576acac647cc596b2c3f814518cc8c82953c7a4478f32e0cf645630a5ba38d9618ef2bc3add69d459ae3dece5cab778938d988239f8c5ae437807075e06c828019959c644ff05ef6a5a1dab72227c98e3a040b0cf219026640698d7a13d8538a570011010001889f04180102000905024d3c5c33021b0c000a0910d4984f961e35246b26c703ff7ee29ef53bc1ae1ead533c408fa136db508434e233d6e62be621e031e5940bbd4c08142aed0f82217e7c3e1ec8de574bc06ccf3c36633be41ad78a9eacd209f861cae7b064100758545cc9dd83db71806dc1cfd5fb9ae5c7474bba0c19c44034ae61bae5eca379383339dece94ff56ff7aa44a582f3e5c38f45763af577c0934b0020003\"\n-\n-const testKeys1And2PrivateHex = \"9501d8044d3c5c10010400b1d13382944bd5aba23a4312968b5095d14f947f600eb478e14a6fcb16b0e0cac764884909c020bc495cfcc39a935387c661507bdb236a0612fb582cac3af9b29cc2c8c70090616c41b662f4da4c1201e195472eb7f4ae1ccbcbf9940fe21d985e379a5563dde5b9a23d35f1cfaa5790da3b79db26f23695107bfaca8e7b5bcd00110100010003ff4d91393b9a8e3430b14d6209df42f98dc927425b881f1209f319220841273a802a97c7bdb8b3a7740b3ab5866c4d1d308ad0d3a79bd1e883aacf1ac92dfe720285d10d08752a7efe3c609b1d00f17f2805b217be53999a7da7e493bfc3e9618fd17018991b8128aea70a05dbce30e4fbe626aa45775fa255dd9177aabf4df7cf0200c1ded12566e4bc2bb590455e5becfb2e2c9796482270a943343a7835de41080582c2be3caf5981aa838140e97afa40ad652a0b544f83eb1833b0957dce26e47b0200eacd6046741e9ce2ec5beb6fb5e6335457844fb09477f83b050a96be7da043e17f3a9523567ed40e7a521f818813a8b8a72209f1442844843ccc7eb9805442570200bdafe0438d97ac36e773c7162028d65844c4d463e2420aa2228c6e50dc2743c3d6c72d0d782a5173fe7be2169c8a9f4ef8a7cf3e37165e8c61b89c346cdc6c1799d2b41054657374204b6579203120285253412988b804130102002205024d3c5c10021b03060b090807030206150802090a0b0416020301021e01021780000a0910a34d7e18c20c31bbb5b304009cc45fe610b641a2c146331be94dade0a396e73ca725e1b25c21708d9cab46ecca5ccebc23055879df8f99eea39b377962a400f2ebdc36a7c99c333d74aeba346315137c3ff9d0a09b0273299090343048afb8107cf94cbd1400e3026f0ccac7ecebbc4d78588eb3e478fe2754d3ca664bcf3eac96ca4a6b0c8d7df5102f60f6b00200009d01d8044d3c5c10010400b201df61d67487301f11879d514f4248ade90c8f68c7af1284c161098de4c28c2850f1ec7b8e30f959793e571542ffc6532189409cb51c3d30dad78c4ad5165eda18b20d9826d8707d0f742e2ab492103a85bbd9ddf4f5720f6de7064feb0d39ee002219765bb07bcfb8b877f47abe270ddeda4f676108cecb6b9bb2ad484a4f00110100010003fd17a7490c22a79c59281fb7b20f5e6553ec0c1637ae382e8adaea295f50241037f8997cf42c1ce26417e015091451b15424b2c59eb8d4161b0975630408e394d3b00f88d4b4e18e2cc85e8251d4753a27c639c83f5ad4a571c4f19d7cd460b9b73c25ade730c99df09637bd173d8e3e981ac64432078263bb6dc30d3e974150dd0200d0ee05be3d4604d2146fb0457f31ba17c057560785aa804e8ca5530a7cd81d3440d0f4ba6851efcfd3954b7e68908fc0ba47f7ac37bf559c6c168b70d3a7c8cd0200da1c677c4bce06a068070f2b3733b0a714e88d62aa3f9a26c6f5216d48d5c2b5624144f3807c0df30be66b3268eeeca4df1fbded58faf49fc95dc3c35f134f8b01fd1396b6c0fc1b6c4f0eb8f5e44b8eace1e6073e20d0b8bc5385f86f1cf3f050f66af789f3ef1fc107b7f4421e19e0349c730c68f0a226981f4e889054fdb4dc149e8e889f04180102000905024d3c5c10021b0c000a0910a34d7e18c20c31bb1a03040085c8d62e16d05dc4e9dad64953c8a2eed8b6c12f92b1575eeaa6dcf7be9473dd5b24b37b6dffbb4e7c99ed1bd3cb11634be19b3e6e207bed7505c7ca111ccf47cb323bf1f8851eb6360e8034cbff8dd149993c959de89f8f77f38e7e98b8e3076323aa719328e2b408db5ec0d03936efd57422ba04f925cdc7b4c1af7590e40ab00200009501fe044d3c5c33010400b488c3e5f83f4d561f317817538d9d0397981e9aef1321ca68ebfae1cf8b7d388e19f4b5a24a82e2fbbf1c6c26557a6c5845307a03d815756f564ac7325b02bc83e87d5480a8fae848f07cb891f2d51ce7df83dcafdc12324517c86d472cc0ee10d47a68fd1d9ae49a6c19bbd36d82af597a0d88cc9c49de9df4e696fc1f0b5d0011010001fe030302e9030f3c783e14856063f16938530e148bc57a7aa3f3e4f90df9dceccdc779bc0835e1ad3d006e4a8d7b36d08b8e0de5a0d947254ecfbd22037e6572b426bcfdc517796b224b0036ff90bc574b5509bede85512f2eefb520fb4b02aa523ba739bff424a6fe81c5041f253f8d757e69a503d3563a104d0d49e9e890b9d0c26f96b55b743883b472caa7050c4acfd4a21f875bdf1258d88bd61224d303dc9df77f743137d51e6d5246b88c406780528fd9a3e15bab5452e5b93970d9dcc79f48b38651b9f15bfbcf6da452837e9cc70683d1bdca94507870f743e4ad902005812488dd342f836e72869afd00ce1850eea4cfa53ce10e3608e13d3c149394ee3cbd0e23d018fcbcb6e2ec5a1a22972d1d462ca05355d0d290dd2751e550d5efb38c6c89686344df64852bf4ff86638708f644e8ec6bd4af9b50d8541cb91891a431326ab2e332faa7ae86cfb6e0540aa63160c1e5cdd5a4add518b303fff0a20117c6bc77f7cfbaf36b04c865c6c2b42754657374204b6579203220285253412c20656e637279707465642070726976617465206b65792988b804130102002205024d3c5c33021b03060b090807030206150802090a0b0416020301021e01021780000a0910d4984f961e35246b98940400908a73b6a6169f700434f076c6c79015a49bee37130eaf23aaa3cfa9ce60bfe4acaa7bc95f1146ada5867e0079babb38804891f4f0b8ebca57a86b249dee786161a755b7a342e68ccf3f78ed6440a93a6626beb9a37aa66afcd4f888790cb4bb46d94a4ae3eb3d7d3e6b00f6bfec940303e89ec5b32a1eaaacce66497d539328b00200009d01fe044d3c5c33010400a4e913f9442abcc7f1804ccab27d2f787ffa592077ca935a8bb23165bd8d57576acac647cc596b2c3f814518cc8c82953c7a4478f32e0cf645630a5ba38d9618ef2bc3add69d459ae3dece5cab778938d988239f8c5ae437807075e06c828019959c644ff05ef6a5a1dab72227c98e3a040b0cf219026640698d7a13d8538a570011010001fe030302e9030f3c783e148560f936097339ae381d63116efcf802ff8b1c9360767db5219cc987375702a4123fd8657d3e22700f23f95020d1b261eda5257e9a72f9a918e8ef22dd5b3323ae03bbc1923dd224db988cadc16acc04b120a9f8b7e84da9716c53e0334d7b66586ddb9014df604b41be1e960dcfcbc96f4ed150a1a0dd070b9eb14276b9b6be413a769a75b519a53d3ecc0c220e85cd91ca354d57e7344517e64b43b6e29823cbd87eae26e2b2e78e6dedfbb76e3e9f77bcb844f9a8932eb3db2c3f9e44316e6f5d60e9e2a56e46b72abe6b06dc9a31cc63f10023d1f5e12d2a3ee93b675c96f504af0001220991c88db759e231b3320dcedf814dcf723fd9857e3d72d66a0f2af26950b915abdf56c1596f46a325bf17ad4810d3535fb02a259b247ac3dbd4cc3ecf9c51b6c07cebb009c1506fba0a89321ec8683e3fd009a6e551d50243e2d5092fefb3321083a4bad91320dc624bd6b5dddf93553e3d53924c05bfebec1fb4bd47e89a1a889f04180102000905024d3c5c33021b0c000a0910d4984f961e35246b26c703ff7ee29ef53bc1ae1ead533c408fa136db508434e233d6e62be621e031e5940bbd4c08142aed0f82217e7c3e1ec8de574bc06ccf3c36633be41ad78a9eacd209f861cae7b064100758545cc9dd83db71806dc1cfd5fb9ae5c7474bba0c19c44034ae61bae5eca379383339dece94ff56ff7aa44a582f3e5c38f45763af577c0934b0020000\"\n-\n-const dsaElGamalTestKeysHex = \"9501e1044dfcb16a110400aa3e5c1a1f43dd28c2ffae8abf5cfce555ee874134d8ba0a0f7b868ce2214beddc74e5e1e21ded354a95d18acdaf69e5e342371a71fbb9093162e0c5f3427de413a7f2c157d83f5cd2f9d791256dc4f6f0e13f13c3302af27f2384075ab3021dff7a050e14854bbde0a1094174855fc02f0bae8e00a340d94a1f22b32e48485700a0cec672ac21258fb95f61de2ce1af74b2c4fa3e6703ff698edc9be22c02ae4d916e4fa223f819d46582c0516235848a77b577ea49018dcd5e9e15cff9dbb4663a1ae6dd7580fa40946d40c05f72814b0f88481207e6c0832c3bded4853ebba0a7e3bd8e8c66df33d5a537cd4acf946d1080e7a3dcea679cb2b11a72a33a2b6a9dc85f466ad2ddf4c3db6283fa645343286971e3dd700703fc0c4e290d45767f370831a90187e74e9972aae5bff488eeff7d620af0362bfb95c1a6c3413ab5d15a2e4139e5d07a54d72583914661ed6a87cce810be28a0aa8879a2dd39e52fb6fe800f4f181ac7e328f740cde3d09a05cecf9483e4cca4253e60d4429ffd679d9996a520012aad119878c941e3cf151459873bdfc2a9563472fe0303027a728f9feb3b864260a1babe83925ce794710cfd642ee4ae0e5b9d74cee49e9c67b6cd0ea5dfbb582132195a121356a1513e1bca73e5b80c58c7ccb4164453412f456c47616d616c2054657374204b65792031886204131102002205024dfcb16a021b03060b090807030206150802090a0b0416020301021e01021780000a091033af447ccd759b09fadd00a0b8fd6f5a790bad7e9f2dbb7632046dc4493588db009c087c6a9ba9f7f49fab221587a74788c00db4889ab00200009d0157044dfcb16a1004008dec3f9291205255ccff8c532318133a6840739dd68b03ba942676f9038612071447bf07d00d559c5c0875724ea16a4c774f80d8338b55fca691a0522e530e604215b467bbc9ccfd483a1da99d7bc2648b4318fdbd27766fc8bfad3fddb37c62b8ae7ccfe9577e9b8d1e77c1d417ed2c2ef02d52f4da11600d85d3229607943700030503ff506c94c87c8cab778e963b76cf63770f0a79bf48fb49d3b4e52234620fc9f7657f9f8d56c96a2b7c7826ae6b57ebb2221a3fe154b03b6637cea7e6d98e3e45d87cf8dc432f723d3d71f89c5192ac8d7290684d2c25ce55846a80c9a7823f6acd9bb29fa6cd71f20bc90eccfca20451d0c976e460e672b000df49466408d527affe0303027a728f9feb3b864260abd761730327bca2aaa4ea0525c175e92bf240682a0e83b226f97ecb2e935b62c9a133858ce31b271fa8eb41f6a1b3cd72a63025ce1a75ee4180dcc284884904181102000905024dfcb16a021b0c000a091033af447ccd759b09dd0b009e3c3e7296092c81bee5a19929462caaf2fff3ae26009e218c437a2340e7ea628149af1ec98ec091a43992b00200009501e1044dfcb1be1104009f61faa61aa43df75d128cbe53de528c4aec49ce9360c992e70c77072ad5623de0a3a6212771b66b39a30dad6781799e92608316900518ec01184a85d872365b7d2ba4bacfb5882ea3c2473d3750dc6178cc1cf82147fb58caa28b28e9f12f6d1efcb0534abed644156c91cca4ab78834268495160b2400bc422beb37d237c2300a0cac94911b6d493bda1e1fbc6feeca7cb7421d34b03fe22cec6ccb39675bb7b94a335c2b7be888fd3906a1125f33301d8aa6ec6ee6878f46f73961c8d57a3e9544d8ef2a2cbfd4d52da665b1266928cfe4cb347a58c412815f3b2d2369dec04b41ac9a71cc9547426d5ab941cccf3b18575637ccfb42df1a802df3cfe0a999f9e7109331170e3a221991bf868543960f8c816c28097e503fe319db10fb98049f3a57d7c80c420da66d56f3644371631fad3f0ff4040a19a4fedc2d07727a1b27576f75a4d28c47d8246f27071e12d7a8de62aad216ddbae6aa02efd6b8a3e2818cda48526549791ab277e447b3a36c57cefe9b592f5eab73959743fcc8e83cbefec03a329b55018b53eec196765ae40ef9e20521a603c551efe0303020950d53a146bf9c66034d00c23130cce95576a2ff78016ca471276e8227fb30b1ffbd92e61804fb0c3eff9e30b1a826ee8f3e4730b4d86273ca977b4164453412f456c47616d616c2054657374204b65792032886204131102002205024dfcb1be021b03060b090807030206150802090a0b0416020301021e01021780000a0910a86bf526325b21b22bd9009e34511620415c974750a20df5cb56b182f3b48e6600a0a9466cb1a1305a84953445f77d461593f1d42bc1b00200009d0157044dfcb1be1004009565a951da1ee87119d600c077198f1c1bceb0f7aa54552489298e41ff788fa8f0d43a69871f0f6f77ebdfb14a4260cf9fbeb65d5844b4272a1904dd95136d06c3da745dc46327dd44a0f16f60135914368c8039a34033862261806bb2c5ce1152e2840254697872c85441ccb7321431d75a747a4bfb1d2c66362b51ce76311700030503fc0ea76601c196768070b7365a200e6ddb09307f262d5f39eec467b5f5784e22abdf1aa49226f59ab37cb49969d8f5230ea65caf56015abda62604544ed526c5c522bf92bed178a078789f6c807b6d34885688024a5bed9e9f8c58d11d4b82487b44c5f470c5606806a0443b79cadb45e0f897a561a53f724e5349b9267c75ca17fe0303020950d53a146bf9c660bc5f4ce8f072465e2d2466434320c1e712272fafc20e342fe7608101580fa1a1a367e60486a7cd1246b7ef5586cf5e10b32762b710a30144f12dd17dd4884904181102000905024dfcb1be021b0c000a0910a86bf526325b21b2904c00a0b2b66b4b39ccffda1d10f3ea8d58f827e30a8b8e009f4255b2d8112a184e40cde43a34e8655ca7809370b0020000\"\n-\n-const signedMessageHex = \"a3019bc0cbccc0c4b8d8b74ee2108fe16ec6d3ca490cbe362d3f8333d3f352531472538b8b13d353b97232f352158c20943157c71c16064626063656269052062e4e01987e9b6fccff4b7df3a34c534b23e679cbec3bc0f8f6e64dfb4b55fe3f8efa9ce110ddb5cd79faf1d753c51aecfa669f7e7aa043436596cccc3359cb7dd6bbe9ecaa69e5989d9e57209571edc0b2fa7f57b9b79a64ee6e99ce1371395fee92fec2796f7b15a77c386ff668ee27f6d38f0baa6c438b561657377bf6acff3c5947befd7bf4c196252f1d6e5c524d0300\"\n-\n-const signedTextMessageHex = \"a3019bc0cbccc8c4b8d8b74ee2108fe16ec6d36a250cbece0c178233d3f352531472538b8b13d35379b97232f352158ca0b4312f57c71c1646462606365626906a062e4e019811591798ff99bf8afee860b0d8a8c2a85c3387e3bcf0bb3b17987f2bbcfab2aa526d930cbfd3d98757184df3995c9f3e7790e36e3e9779f06089d4c64e9e47dd6202cb6e9bc73c5d11bb59fbaf89d22d8dc7cf199ddf17af96e77c5f65f9bbed56f427bd8db7af37f6c9984bf9385efaf5f184f986fb3e6adb0ecfe35bbf92d16a7aa2a344fb0bc52fb7624f0200\"\n-\n-const signedEncryptedMessageHex = \"848c032a67d68660df41c70103ff5789d0de26b6a50c985a02a13131ca829c413a35d0e6fa8d6842599252162808ac7439c72151c8c6183e76923fe3299301414d0c25a2f06a2257db3839e7df0ec964773f6e4c4ac7ff3b48c444237166dd46ba8ff443a5410dc670cb486672fdbe7c9dfafb75b4fea83af3a204fe2a7dfa86bd20122b4f3d2646cbeecb8f7be8d2c03b018bd210b1d3791e1aba74b0f1034e122ab72e760492c192383cf5e20b5628bd043272d63df9b923f147eb6091cd897553204832aba48fec54aa447547bb16305a1024713b90e77fd0065f1918271947549205af3c74891af22ee0b56cd29bfec6d6e351901cd4ab3ece7c486f1e32a792d4e474aed98ee84b3f591c7dff37b64e0ecd68fd036d517e412dcadf85840ce184ad7921ad446c4ee28db80447aea1ca8d4f574db4d4e37688158ddd19e14ee2eab4873d46947d65d14a23e788d912cf9a19624ca7352469b72a83866b7c23cb5ace3deab3c7018061b0ba0f39ed2befe27163e5083cf9b8271e3e3d52cc7ad6e2a3bd81d4c3d7022f8d\"\n-\n-const signedEncryptedMessage2Hex = \"85010e03cf6a7abcd43e36731003fb057f5495b79db367e277cdbe4ab90d924ddee0c0381494112ff8c1238fb0184af35d1731573b01bc4c55ecacd2aafbe2003d36310487d1ecc9ac994f3fada7f9f7f5c3a64248ab7782906c82c6ff1303b69a84d9a9529c31ecafbcdb9ba87e05439897d87e8a2a3dec55e14df19bba7f7bd316291c002ae2efd24f83f9e3441203fc081c0c23dc3092a454ca8a082b27f631abf73aca341686982e8fbda7e0e7d863941d68f3de4a755c2964407f4b5e0477b3196b8c93d551dd23c8beef7d0f03fbb1b6066f78907faf4bf1677d8fcec72651124080e0b7feae6b476e72ab207d38d90b958759fdedfc3c6c35717c9dbfc979b3cfbbff0a76d24a5e57056bb88acbd2a901ef64bc6e4db02adc05b6250ff378de81dca18c1910ab257dff1b9771b85bb9bbe0a69f5989e6d1710a35e6dfcceb7d8fb5ccea8db3932b3d9ff3fe0d327597c68b3622aec8e3716c83a6c93f497543b459b58ba504ed6bcaa747d37d2ca746fe49ae0a6ce4a8b694234e941b5159ff8bd34b9023da2814076163b86f40eed7c9472f81b551452d5ab87004a373c0172ec87ea6ce42ccfa7dbdad66b745496c4873d8019e8c28d6b3\"\n-\n-const symmetricallyEncryptedCompressedHex = \"8c0d04030302eb4a03808145d0d260c92f714339e13de5a79881216431925bf67ee2898ea61815f07894cd0703c50d0a76ef64d482196f47a8bc729af9b80bb6\"\n-\n-const dsaTestKeyHex = \"9901a2044d6c49de110400cb5ce438cf9250907ac2ba5bf6547931270b89f7c4b53d9d09f4d0213a5ef2ec1f26806d3d259960f872a4a102ef1581ea3f6d6882d15134f21ef6a84de933cc34c47cc9106efe3bd84c6aec12e78523661e29bc1a61f0aab17fa58a627fd5fd33f5149153fbe8cd70edf3d963bc287ef875270ff14b5bfdd1bca4483793923b00a0fe46d76cb6e4cbdc568435cd5480af3266d610d303fe33ae8273f30a96d4d34f42fa28ce1112d425b2e3bf7ea553d526e2db6b9255e9dc7419045ce817214d1a0056dbc8d5289956a4b1b69f20f1105124096e6a438f41f2e2495923b0f34b70642607d45559595c7fe94d7fa85fc41bf7d68c1fd509ebeaa5f315f6059a446b9369c277597e4f474a9591535354c7e7f4fd98a08aa60400b130c24ff20bdfbf683313f5daebf1c9b34b3bdadfc77f2ddd72ee1fb17e56c473664bc21d66467655dd74b9005e3a2bacce446f1920cd7017231ae447b67036c9b431b8179deacd5120262d894c26bc015bffe3d827ba7087ad9b700d2ca1f6d16cc1786581e5dd065f293c31209300f9b0afcc3f7c08dd26d0a22d87580b4db41054657374204b65792033202844534129886204131102002205024d6c49de021b03060b090807030206150802090a0b0416020301021e01021780000a0910338934250ccc03607e0400a0bdb9193e8a6b96fc2dfc108ae848914b504481f100a09c4dc148cb693293a67af24dd40d2b13a9e36794\"\n-\n-const dsaTestKeyPrivateHex = \"9501bb044d6c49de110400cb5ce438cf9250907ac2ba5bf6547931270b89f7c4b53d9d09f4d0213a5ef2ec1f26806d3d259960f872a4a102ef1581ea3f6d6882d15134f21ef6a84de933cc34c47cc9106efe3bd84c6aec12e78523661e29bc1a61f0aab17fa58a627fd5fd33f5149153fbe8cd70edf3d963bc287ef875270ff14b5bfdd1bca4483793923b00a0fe46d76cb6e4cbdc568435cd5480af3266d610d303fe33ae8273f30a96d4d34f42fa28ce1112d425b2e3bf7ea553d526e2db6b9255e9dc7419045ce817214d1a0056dbc8d5289956a4b1b69f20f1105124096e6a438f41f2e2495923b0f34b70642607d45559595c7fe94d7fa85fc41bf7d68c1fd509ebeaa5f315f6059a446b9369c277597e4f474a9591535354c7e7f4fd98a08aa60400b130c24ff20bdfbf683313f5daebf1c9b34b3bdadfc77f2ddd72ee1fb17e56c473664bc21d66467655dd74b9005e3a2bacce446f1920cd7017231ae447b67036c9b431b8179deacd5120262d894c26bc015bffe3d827ba7087ad9b700d2ca1f6d16cc1786581e5dd065f293c31209300f9b0afcc3f7c08dd26d0a22d87580b4d00009f592e0619d823953577d4503061706843317e4fee083db41054657374204b65792033202844534129886204131102002205024d6c49de021b03060b090807030206150802090a0b0416020301021e01021780000a0910338934250ccc03607e0400a0bdb9193e8a6b96fc2dfc108ae848914b504481f100a09c4dc148cb693293a67af24dd40d2b13a9e36794\"\n-\n-const armoredPrivateKeyBlock = `-----BEGIN PGP PRIVATE KEY BLOCK-----\n-Version: GnuPG v1.4.10 (GNU/Linux)\n-\n-lQHYBE2rFNoBBADFwqWQIW/DSqcB4yCQqnAFTJ27qS5AnB46ccAdw3u4Greeu3Bp\n-idpoHdjULy7zSKlwR1EA873dO/k/e11Ml3dlAFUinWeejWaK2ugFP6JjiieSsrKn\n-vWNicdCS4HTWn0X4sjl0ZiAygw6GNhqEQ3cpLeL0g8E9hnYzJKQ0LWJa0QARAQAB\n-AAP/TB81EIo2VYNmTq0pK1ZXwUpxCrvAAIG3hwKjEzHcbQznsjNvPUihZ+NZQ6+X\n-0HCfPAdPkGDCLCb6NavcSW+iNnLTrdDnSI6+3BbIONqWWdRDYJhqZCkqmG6zqSfL\n-IdkJgCw94taUg5BWP/AAeQrhzjChvpMQTVKQL5mnuZbUCeMCAN5qrYMP2S9iKdnk\n-VANIFj7656ARKt/nf4CBzxcpHTyB8+d2CtPDKCmlJP6vL8t58Jmih+kHJMvC0dzn\n-gr5f5+sCAOOe5gt9e0am7AvQWhdbHVfJU0TQJx+m2OiCJAqGTB1nvtBLHdJnfdC9\n-TnXXQ6ZXibqLyBies/xeY2sCKL5qtTMCAKnX9+9d/5yQxRyrQUHt1NYhaXZnJbHx\n-q4ytu0eWz+5i68IYUSK69jJ1NWPM0T6SkqpB3KCAIv68VFm9PxqG1KmhSrQIVGVz\n-dCBLZXmIuAQTAQIAIgUCTasU2gIbAwYLCQgHAwIGFQgCCQoLBBYCAwECHgECF4AA\n-CgkQO9o98PRieSoLhgQAkLEZex02Qt7vGhZzMwuN0R22w3VwyYyjBx+fM3JFETy1\n-ut4xcLJoJfIaF5ZS38UplgakHG0FQ+b49i8dMij0aZmDqGxrew1m4kBfjXw9B/v+\n-eIqpODryb6cOSwyQFH0lQkXC040pjq9YqDsO5w0WYNXYKDnzRV0p4H1pweo2VDid\n-AdgETasU2gEEAN46UPeWRqKHvA99arOxee38fBt2CI08iiWyI8T3J6ivtFGixSqV\n-bRcPxYO/qLpVe5l84Nb3X71GfVXlc9hyv7CD6tcowL59hg1E/DC5ydI8K8iEpUmK\n-/UnHdIY5h8/kqgGxkY/T/hgp5fRQgW1ZoZxLajVlMRZ8W4tFtT0DeA+JABEBAAEA\n-A/0bE1jaaZKj6ndqcw86jd+QtD1SF+Cf21CWRNeLKnUds4FRRvclzTyUMuWPkUeX\n-TaNNsUOFqBsf6QQ2oHUBBK4VCHffHCW4ZEX2cd6umz7mpHW6XzN4DECEzOVksXtc\n-lUC1j4UB91DC/RNQqwX1IV2QLSwssVotPMPqhOi0ZLNY7wIA3n7DWKInxYZZ4K+6\n-rQ+POsz6brEoRHwr8x6XlHenq1Oki855pSa1yXIARoTrSJkBtn5oI+f8AzrnN0BN\n-oyeQAwIA/7E++3HDi5aweWrViiul9cd3rcsS0dEnksPhvS0ozCJiHsq/6GFmy7J8\n-QSHZPteedBnZyNp5jR+H7cIfVN3KgwH/Skq4PsuPhDq5TKK6i8Pc1WW8MA6DXTdU\n-nLkX7RGmMwjC0DBf7KWAlPjFaONAX3a8ndnz//fy1q7u2l9AZwrj1qa1iJ8EGAEC\n-AAkFAk2rFNoCGwwACgkQO9o98PRieSo2/QP/WTzr4ioINVsvN1akKuekmEMI3LAp\n-BfHwatufxxP1U+3Si/6YIk7kuPB9Hs+pRqCXzbvPRrI8NHZBmc8qIGthishdCYad\n-AHcVnXjtxrULkQFGbGvhKURLvS9WnzD/m1K2zzwxzkPTzT9/Yf06O6Mal5AdugPL\n-VrM0m72/jnpKo04=\n-=zNCn\n------END PGP PRIVATE KEY BLOCK-----`\n-\n-const dsaKeyWithSHA512 = `9901a2044f04b07f110400db244efecc7316553ee08d179972aab87bb1214de7692593fcf5b6feb1c80fba268722dd464748539b85b81d574cd2d7ad0ca2444de4d849b8756bad7768c486c83a824f9bba4af773d11742bdfb4ac3b89ef8cc9452d4aad31a37e4b630d33927bff68e879284a1672659b8b298222fc68f370f3e24dccacc4a862442b9438b00a0ea444a24088dc23e26df7daf8f43cba3bffc4fe703fe3d6cd7fdca199d54ed8ae501c30e3ec7871ea9cdd4cf63cfe6fc82281d70a5b8bb493f922cd99fba5f088935596af087c8d818d5ec4d0b9afa7f070b3d7c1dd32a84fca08d8280b4890c8da1dde334de8e3cad8450eed2a4a4fcc2db7b8e5528b869a74a7f0189e11ef097ef1253582348de072bb07a9fa8ab838e993cef0ee203ff49298723e2d1f549b00559f886cd417a41692ce58d0ac1307dc71d85a8af21b0cf6eaa14baf2922d3a70389bedf17cc514ba0febbd107675a372fe84b90162a9e88b14d4b1c6be855b96b33fb198c46f058568817780435b6936167ebb3724b680f32bf27382ada2e37a879b3d9de2abe0c3f399350afd1ad438883f4791e2e3b4184453412068617368207472756e636174696f6e207465737488620413110a002205024f04b07f021b03060b090807030206150802090a0b0416020301021e01021780000a0910ef20e0cefca131581318009e2bf3bf047a44d75a9bacd00161ee04d435522397009a03a60d51bd8a568c6c021c8d7cf1be8d990d6417b0020003`"}, {"sha": "39479a1f1c6c10b887ef64a7e9b8112b8cd7b83e", "filename": "libgo/go/crypto/openpgp/s2k/s2k.go", "status": "removed", "additions": 0, "deletions": 183, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,183 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package s2k implements the various OpenPGP string-to-key transforms as\n-// specified in RFC 4800 section 3.7.1.\n-package s2k\n-\n-import (\n-\t\"crypto\"\n-\t\"crypto/openpgp/errors\"\n-\t\"hash\"\n-\t\"io\"\n-\t\"strconv\"\n-)\n-\n-// Simple writes to out the result of computing the Simple S2K function (RFC\n-// 4880, section 3.7.1.1) using the given hash and input passphrase.\n-func Simple(out []byte, h hash.Hash, in []byte) {\n-\tSalted(out, h, in, nil)\n-}\n-\n-var zero [1]byte\n-\n-// Salted writes to out the result of computing the Salted S2K function (RFC\n-// 4880, section 3.7.1.2) using the given hash, input passphrase and salt.\n-func Salted(out []byte, h hash.Hash, in []byte, salt []byte) {\n-\tdone := 0\n-\tvar digest []byte\n-\n-\tfor i := 0; done < len(out); i++ {\n-\t\th.Reset()\n-\t\tfor j := 0; j < i; j++ {\n-\t\t\th.Write(zero[:])\n-\t\t}\n-\t\th.Write(salt)\n-\t\th.Write(in)\n-\t\tdigest = h.Sum(digest[:0])\n-\t\tn := copy(out[done:], digest)\n-\t\tdone += n\n-\t}\n-}\n-\n-// Iterated writes to out the result of computing the Iterated and Salted S2K\n-// function (RFC 4880, section 3.7.1.3) using the given hash, input passphrase,\n-// salt and iteration count.\n-func Iterated(out []byte, h hash.Hash, in []byte, salt []byte, count int) {\n-\tcombined := make([]byte, len(in)+len(salt))\n-\tcopy(combined, salt)\n-\tcopy(combined[len(salt):], in)\n-\n-\tif count < len(combined) {\n-\t\tcount = len(combined)\n-\t}\n-\n-\tdone := 0\n-\tvar digest []byte\n-\tfor i := 0; done < len(out); i++ {\n-\t\th.Reset()\n-\t\tfor j := 0; j < i; j++ {\n-\t\t\th.Write(zero[:])\n-\t\t}\n-\t\twritten := 0\n-\t\tfor written < count {\n-\t\t\tif written+len(combined) > count {\n-\t\t\t\ttodo := count - written\n-\t\t\t\th.Write(combined[:todo])\n-\t\t\t\twritten = count\n-\t\t\t} else {\n-\t\t\t\th.Write(combined)\n-\t\t\t\twritten += len(combined)\n-\t\t\t}\n-\t\t}\n-\t\tdigest = h.Sum(digest[:0])\n-\t\tn := copy(out[done:], digest)\n-\t\tdone += n\n-\t}\n-}\n-\n-// Parse reads a binary specification for a string-to-key transformation from r\n-// and returns a function which performs that transform.\n-func Parse(r io.Reader) (f func(out, in []byte), err error) {\n-\tvar buf [9]byte\n-\n-\t_, err = io.ReadFull(r, buf[:2])\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\thash, ok := HashIdToHash(buf[1])\n-\tif !ok {\n-\t\treturn nil, errors.UnsupportedError(\"hash for S2K function: \" + strconv.Itoa(int(buf[1])))\n-\t}\n-\th := hash.New()\n-\tif h == nil {\n-\t\treturn nil, errors.UnsupportedError(\"hash not available: \" + strconv.Itoa(int(hash)))\n-\t}\n-\n-\tswitch buf[0] {\n-\tcase 1:\n-\t\tf := func(out, in []byte) {\n-\t\t\tSimple(out, h, in)\n-\t\t}\n-\t\treturn f, nil\n-\tcase 2:\n-\t\t_, err = io.ReadFull(r, buf[:8])\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tf := func(out, in []byte) {\n-\t\t\tSalted(out, h, in, buf[:8])\n-\t\t}\n-\t\treturn f, nil\n-\tcase 3:\n-\t\t_, err = io.ReadFull(r, buf[:9])\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tcount := (16 + int(buf[8]&15)) << (uint32(buf[8]>>4) + 6)\n-\t\tf := func(out, in []byte) {\n-\t\t\tIterated(out, h, in, buf[:8], count)\n-\t\t}\n-\t\treturn f, nil\n-\t}\n-\n-\treturn nil, errors.UnsupportedError(\"S2K function\")\n-}\n-\n-// Serialize salts and stretches the given passphrase and writes the resulting\n-// key into key. It also serializes an S2K descriptor to w.\n-func Serialize(w io.Writer, key []byte, rand io.Reader, passphrase []byte) error {\n-\tvar buf [11]byte\n-\tbuf[0] = 3 /* iterated and salted */\n-\tbuf[1], _ = HashToHashId(crypto.SHA1)\n-\tsalt := buf[2:10]\n-\tif _, err := io.ReadFull(rand, salt); err != nil {\n-\t\treturn err\n-\t}\n-\tconst count = 65536 // this is the default in gpg\n-\tbuf[10] = 96        // 65536 iterations\n-\tif _, err := w.Write(buf[:]); err != nil {\n-\t\treturn err\n-\t}\n-\n-\tIterated(key, crypto.SHA1.New(), passphrase, salt, count)\n-\treturn nil\n-}\n-\n-// hashToHashIdMapping contains pairs relating OpenPGP's hash identifier with\n-// Go's crypto.Hash type. See RFC 4880, section 9.4.\n-var hashToHashIdMapping = []struct {\n-\tid   byte\n-\thash crypto.Hash\n-}{\n-\t{1, crypto.MD5},\n-\t{2, crypto.SHA1},\n-\t{3, crypto.RIPEMD160},\n-\t{8, crypto.SHA256},\n-\t{9, crypto.SHA384},\n-\t{10, crypto.SHA512},\n-\t{11, crypto.SHA224},\n-}\n-\n-// HashIdToHash returns a crypto.Hash which corresponds to the given OpenPGP\n-// hash id.\n-func HashIdToHash(id byte) (h crypto.Hash, ok bool) {\n-\tfor _, m := range hashToHashIdMapping {\n-\t\tif m.id == id {\n-\t\t\treturn m.hash, true\n-\t\t}\n-\t}\n-\treturn 0, false\n-}\n-\n-// HashIdToHash returns an OpenPGP hash id which corresponds the given Hash.\n-func HashToHashId(h crypto.Hash) (id byte, ok bool) {\n-\tfor _, m := range hashToHashIdMapping {\n-\t\tif m.hash == h {\n-\t\t\treturn m.id, true\n-\t\t}\n-\t}\n-\treturn 0, false\n-}"}, {"sha": "3a094a10f1f5d2a165e63f0f08a7e39d56085470", "filename": "libgo/go/crypto/openpgp/s2k/s2k_test.go", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,118 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package s2k\n-\n-import (\n-\t\"bytes\"\n-\t\"crypto/rand\"\n-\t\"crypto/sha1\"\n-\t\"encoding/hex\"\n-\t\"testing\"\n-)\n-\n-var saltedTests = []struct {\n-\tin, out string\n-}{\n-\t{\"hello\", \"10295ac1\"},\n-\t{\"world\", \"ac587a5e\"},\n-\t{\"foo\", \"4dda8077\"},\n-\t{\"bar\", \"bd8aac6b9ea9cae04eae6a91c6133b58b5d9a61c14f355516ed9370456\"},\n-\t{\"x\", \"f1d3f289\"},\n-\t{\"xxxxxxxxxxxxxxxxxxxxxxx\", \"e00d7b45\"},\n-}\n-\n-func TestSalted(t *testing.T) {\n-\th := sha1.New()\n-\tsalt := [4]byte{1, 2, 3, 4}\n-\n-\tfor i, test := range saltedTests {\n-\t\texpected, _ := hex.DecodeString(test.out)\n-\t\tout := make([]byte, len(expected))\n-\t\tSalted(out, h, []byte(test.in), salt[:])\n-\t\tif !bytes.Equal(expected, out) {\n-\t\t\tt.Errorf(\"#%d, got: %x want: %x\", i, out, expected)\n-\t\t}\n-\t}\n-}\n-\n-var iteratedTests = []struct {\n-\tin, out string\n-}{\n-\t{\"hello\", \"83126105\"},\n-\t{\"world\", \"6fa317f9\"},\n-\t{\"foo\", \"8fbc35b9\"},\n-\t{\"bar\", \"2af5a99b54f093789fd657f19bd245af7604d0f6ae06f66602a46a08ae\"},\n-\t{\"x\", \"5a684dfe\"},\n-\t{\"xxxxxxxxxxxxxxxxxxxxxxx\", \"18955174\"},\n-}\n-\n-func TestIterated(t *testing.T) {\n-\th := sha1.New()\n-\tsalt := [4]byte{4, 3, 2, 1}\n-\n-\tfor i, test := range iteratedTests {\n-\t\texpected, _ := hex.DecodeString(test.out)\n-\t\tout := make([]byte, len(expected))\n-\t\tIterated(out, h, []byte(test.in), salt[:], 31)\n-\t\tif !bytes.Equal(expected, out) {\n-\t\t\tt.Errorf(\"#%d, got: %x want: %x\", i, out, expected)\n-\t\t}\n-\t}\n-}\n-\n-var parseTests = []struct {\n-\tspec, in, out string\n-}{\n-\t/* Simple with SHA1 */\n-\t{\"0102\", \"hello\", \"aaf4c61d\"},\n-\t/* Salted with SHA1 */\n-\t{\"02020102030405060708\", \"hello\", \"f4f7d67e\"},\n-\t/* Iterated with SHA1 */\n-\t{\"03020102030405060708f1\", \"hello\", \"f2a57b7c\"},\n-}\n-\n-func TestParse(t *testing.T) {\n-\tfor i, test := range parseTests {\n-\t\tspec, _ := hex.DecodeString(test.spec)\n-\t\tbuf := bytes.NewBuffer(spec)\n-\t\tf, err := Parse(buf)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"%d: Parse returned error: %s\", i, err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\texpected, _ := hex.DecodeString(test.out)\n-\t\tout := make([]byte, len(expected))\n-\t\tf(out, []byte(test.in))\n-\t\tif !bytes.Equal(out, expected) {\n-\t\t\tt.Errorf(\"%d: output got: %x want: %x\", i, out, expected)\n-\t\t}\n-\t\tif testing.Short() {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-}\n-\n-func TestSerialize(t *testing.T) {\n-\tbuf := bytes.NewBuffer(nil)\n-\tkey := make([]byte, 16)\n-\tpassphrase := []byte(\"testing\")\n-\terr := Serialize(buf, key, rand.Reader, passphrase)\n-\tif err != nil {\n-\t\tt.Errorf(\"failed to serialize: %s\", err)\n-\t\treturn\n-\t}\n-\n-\tf, err := Parse(buf)\n-\tif err != nil {\n-\t\tt.Errorf(\"failed to reparse: %s\", err)\n-\t\treturn\n-\t}\n-\tkey2 := make([]byte, len(key))\n-\tf(key2, passphrase)\n-\tif !bytes.Equal(key2, key) {\n-\t\tt.Errorf(\"keys don't match: %x (serialied) vs %x (parsed)\", key, key2)\n-\t}\n-}"}, {"sha": "73daa11312119cd2f8be27a1dcc083ef6bcf29bc", "filename": "libgo/go/crypto/openpgp/write.go", "status": "removed", "additions": 0, "deletions": 315, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,315 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package openpgp\n-\n-import (\n-\t\"crypto\"\n-\t\"crypto/openpgp/armor\"\n-\t\"crypto/openpgp/errors\"\n-\t\"crypto/openpgp/packet\"\n-\t\"crypto/openpgp/s2k\"\n-\t\"crypto/rand\"\n-\t_ \"crypto/sha256\"\n-\t\"hash\"\n-\t\"io\"\n-\t\"strconv\"\n-\t\"time\"\n-)\n-\n-// DetachSign signs message with the private key from signer (which must\n-// already have been decrypted) and writes the signature to w.\n-func DetachSign(w io.Writer, signer *Entity, message io.Reader) error {\n-\treturn detachSign(w, signer, message, packet.SigTypeBinary)\n-}\n-\n-// ArmoredDetachSign signs message with the private key from signer (which\n-// must already have been decrypted) and writes an armored signature to w.\n-func ArmoredDetachSign(w io.Writer, signer *Entity, message io.Reader) (err error) {\n-\treturn armoredDetachSign(w, signer, message, packet.SigTypeBinary)\n-}\n-\n-// DetachSignText signs message (after canonicalising the line endings) with\n-// the private key from signer (which must already have been decrypted) and\n-// writes the signature to w.\n-func DetachSignText(w io.Writer, signer *Entity, message io.Reader) error {\n-\treturn detachSign(w, signer, message, packet.SigTypeText)\n-}\n-\n-// ArmoredDetachSignText signs message (after canonicalising the line endings)\n-// with the private key from signer (which must already have been decrypted)\n-// and writes an armored signature to w.\n-func ArmoredDetachSignText(w io.Writer, signer *Entity, message io.Reader) error {\n-\treturn armoredDetachSign(w, signer, message, packet.SigTypeText)\n-}\n-\n-func armoredDetachSign(w io.Writer, signer *Entity, message io.Reader, sigType packet.SignatureType) (err error) {\n-\tout, err := armor.Encode(w, SignatureType, nil)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\terr = detachSign(out, signer, message, sigType)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\treturn out.Close()\n-}\n-\n-func detachSign(w io.Writer, signer *Entity, message io.Reader, sigType packet.SignatureType) (err error) {\n-\tif signer.PrivateKey == nil {\n-\t\treturn errors.InvalidArgumentError(\"signing key doesn't have a private key\")\n-\t}\n-\tif signer.PrivateKey.Encrypted {\n-\t\treturn errors.InvalidArgumentError(\"signing key is encrypted\")\n-\t}\n-\n-\tsig := new(packet.Signature)\n-\tsig.SigType = sigType\n-\tsig.PubKeyAlgo = signer.PrivateKey.PubKeyAlgo\n-\tsig.Hash = crypto.SHA256\n-\tsig.CreationTime = time.Now()\n-\tsig.IssuerKeyId = &signer.PrivateKey.KeyId\n-\n-\th, wrappedHash, err := hashForSignature(sig.Hash, sig.SigType)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tio.Copy(wrappedHash, message)\n-\n-\terr = sig.Sign(rand.Reader, h, signer.PrivateKey)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\treturn sig.Serialize(w)\n-}\n-\n-// FileHints contains metadata about encrypted files. This metadata is, itself,\n-// encrypted.\n-type FileHints struct {\n-\t// IsBinary can be set to hint that the contents are binary data.\n-\tIsBinary bool\n-\t// FileName hints at the name of the file that should be written. It's\n-\t// truncated to 255 bytes if longer. It may be empty to suggest that the\n-\t// file should not be written to disk. It may be equal to \"_CONSOLE\" to\n-\t// suggest the data should not be written to disk.\n-\tFileName string\n-\t// ModTime contains the modification time of the file, or the zero time if not applicable.\n-\tModTime time.Time\n-}\n-\n-// SymmetricallyEncrypt acts like gpg -c: it encrypts a file with a passphrase.\n-// The resulting WriteCloser must be closed after the contents of the file have\n-// been written.\n-func SymmetricallyEncrypt(ciphertext io.Writer, passphrase []byte, hints *FileHints) (plaintext io.WriteCloser, err error) {\n-\tif hints == nil {\n-\t\thints = &FileHints{}\n-\t}\n-\n-\tkey, err := packet.SerializeSymmetricKeyEncrypted(ciphertext, rand.Reader, passphrase, packet.CipherAES128)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tw, err := packet.SerializeSymmetricallyEncrypted(ciphertext, rand.Reader, packet.CipherAES128, key)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tvar epochSeconds uint32\n-\tif !hints.ModTime.IsZero() {\n-\t\tepochSeconds = uint32(hints.ModTime.Unix())\n-\t}\n-\treturn packet.SerializeLiteral(w, hints.IsBinary, hints.FileName, epochSeconds)\n-}\n-\n-// intersectPreferences mutates and returns a prefix of a that contains only\n-// the values in the intersection of a and b. The order of a is preserved.\n-func intersectPreferences(a []uint8, b []uint8) (intersection []uint8) {\n-\tvar j int\n-\tfor _, v := range a {\n-\t\tfor _, v2 := range b {\n-\t\t\tif v == v2 {\n-\t\t\t\ta[j] = v\n-\t\t\t\tj++\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\treturn a[:j]\n-}\n-\n-func hashToHashId(h crypto.Hash) uint8 {\n-\tv, ok := s2k.HashToHashId(h)\n-\tif !ok {\n-\t\tpanic(\"tried to convert unknown hash\")\n-\t}\n-\treturn v\n-}\n-\n-// Encrypt encrypts a message to a number of recipients and, optionally, signs\n-// it. hints contains optional information, that is also encrypted, that aids\n-// the recipients in processing the message. The resulting WriteCloser must\n-// be closed after the contents of the file have been written.\n-func Encrypt(ciphertext io.Writer, to []*Entity, signed *Entity, hints *FileHints) (plaintext io.WriteCloser, err error) {\n-\tvar signer *packet.PrivateKey\n-\tif signed != nil {\n-\t\tsigner = signed.signingKey().PrivateKey\n-\t\tif signer == nil || signer.Encrypted {\n-\t\t\treturn nil, errors.InvalidArgumentError(\"signing key must be decrypted\")\n-\t\t}\n-\t}\n-\n-\t// These are the possible ciphers that we'll use for the message.\n-\tcandidateCiphers := []uint8{\n-\t\tuint8(packet.CipherAES128),\n-\t\tuint8(packet.CipherAES256),\n-\t\tuint8(packet.CipherCAST5),\n-\t}\n-\t// These are the possible hash functions that we'll use for the signature.\n-\tcandidateHashes := []uint8{\n-\t\thashToHashId(crypto.SHA256),\n-\t\thashToHashId(crypto.SHA512),\n-\t\thashToHashId(crypto.SHA1),\n-\t\thashToHashId(crypto.RIPEMD160),\n-\t}\n-\t// In the event that a recipient doesn't specify any supported ciphers\n-\t// or hash functions, these are the ones that we assume that every\n-\t// implementation supports.\n-\tdefaultCiphers := candidateCiphers[len(candidateCiphers)-1:]\n-\tdefaultHashes := candidateHashes[len(candidateHashes)-1:]\n-\n-\tencryptKeys := make([]Key, len(to))\n-\tfor i := range to {\n-\t\tencryptKeys[i] = to[i].encryptionKey()\n-\t\tif encryptKeys[i].PublicKey == nil {\n-\t\t\treturn nil, errors.InvalidArgumentError(\"cannot encrypt a message to key id \" + strconv.FormatUint(to[i].PrimaryKey.KeyId, 16) + \" because it has no encryption keys\")\n-\t\t}\n-\n-\t\tsig := to[i].primaryIdentity().SelfSignature\n-\n-\t\tpreferredSymmetric := sig.PreferredSymmetric\n-\t\tif len(preferredSymmetric) == 0 {\n-\t\t\tpreferredSymmetric = defaultCiphers\n-\t\t}\n-\t\tpreferredHashes := sig.PreferredHash\n-\t\tif len(preferredHashes) == 0 {\n-\t\t\tpreferredHashes = defaultHashes\n-\t\t}\n-\t\tcandidateCiphers = intersectPreferences(candidateCiphers, preferredSymmetric)\n-\t\tcandidateHashes = intersectPreferences(candidateHashes, preferredHashes)\n-\t}\n-\n-\tif len(candidateCiphers) == 0 || len(candidateHashes) == 0 {\n-\t\treturn nil, errors.InvalidArgumentError(\"cannot encrypt because recipient set shares no common algorithms\")\n-\t}\n-\n-\tcipher := packet.CipherFunction(candidateCiphers[0])\n-\thash, _ := s2k.HashIdToHash(candidateHashes[0])\n-\tsymKey := make([]byte, cipher.KeySize())\n-\tif _, err := io.ReadFull(rand.Reader, symKey); err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tfor _, key := range encryptKeys {\n-\t\tif err := packet.SerializeEncryptedKey(ciphertext, rand.Reader, key.PublicKey, cipher, symKey); err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t}\n-\n-\tencryptedData, err := packet.SerializeSymmetricallyEncrypted(ciphertext, rand.Reader, cipher, symKey)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tif signer != nil {\n-\t\tops := &packet.OnePassSignature{\n-\t\t\tSigType:    packet.SigTypeBinary,\n-\t\t\tHash:       hash,\n-\t\t\tPubKeyAlgo: signer.PubKeyAlgo,\n-\t\t\tKeyId:      signer.KeyId,\n-\t\t\tIsLast:     true,\n-\t\t}\n-\t\tif err := ops.Serialize(encryptedData); err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t}\n-\n-\tif hints == nil {\n-\t\thints = &FileHints{}\n-\t}\n-\n-\tw := encryptedData\n-\tif signer != nil {\n-\t\t// If we need to write a signature packet after the literal\n-\t\t// data then we need to stop literalData from closing\n-\t\t// encryptedData.\n-\t\tw = noOpCloser{encryptedData}\n-\n-\t}\n-\tvar epochSeconds uint32\n-\tif !hints.ModTime.IsZero() {\n-\t\tepochSeconds = uint32(hints.ModTime.Unix())\n-\t}\n-\tliteralData, err := packet.SerializeLiteral(w, hints.IsBinary, hints.FileName, epochSeconds)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tif signer != nil {\n-\t\treturn signatureWriter{encryptedData, literalData, hash, hash.New(), signer}, nil\n-\t}\n-\treturn literalData, nil\n-}\n-\n-// signatureWriter hashes the contents of a message while passing it along to\n-// literalData. When closed, it closes literalData, writes a signature packet\n-// to encryptedData and then also closes encryptedData.\n-type signatureWriter struct {\n-\tencryptedData io.WriteCloser\n-\tliteralData   io.WriteCloser\n-\thashType      crypto.Hash\n-\th             hash.Hash\n-\tsigner        *packet.PrivateKey\n-}\n-\n-func (s signatureWriter) Write(data []byte) (int, error) {\n-\ts.h.Write(data)\n-\treturn s.literalData.Write(data)\n-}\n-\n-func (s signatureWriter) Close() error {\n-\tsig := &packet.Signature{\n-\t\tSigType:      packet.SigTypeBinary,\n-\t\tPubKeyAlgo:   s.signer.PubKeyAlgo,\n-\t\tHash:         s.hashType,\n-\t\tCreationTime: time.Now(),\n-\t\tIssuerKeyId:  &s.signer.KeyId,\n-\t}\n-\n-\tif err := sig.Sign(rand.Reader, s.h, s.signer); err != nil {\n-\t\treturn err\n-\t}\n-\tif err := s.literalData.Close(); err != nil {\n-\t\treturn err\n-\t}\n-\tif err := sig.Serialize(s.encryptedData); err != nil {\n-\t\treturn err\n-\t}\n-\treturn s.encryptedData.Close()\n-}\n-\n-// noOpCloser is like an ioutil.NopCloser, but for an io.Writer.\n-// TODO: we have two of these in OpenPGP packages alone. This probably needs\n-// to be promoted somewhere more common.\n-type noOpCloser struct {\n-\tw io.Writer\n-}\n-\n-func (c noOpCloser) Write(data []byte) (n int, err error) {\n-\treturn c.w.Write(data)\n-}\n-\n-func (c noOpCloser) Close() error {\n-\treturn nil\n-}"}, {"sha": "7df02e7bd134198d3c7d829387c7e2561813b21e", "filename": "libgo/go/crypto/openpgp/write_test.go", "status": "removed", "additions": 0, "deletions": 232, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,232 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package openpgp\n-\n-import (\n-\t\"bytes\"\n-\t\"crypto/rand\"\n-\t\"io\"\n-\t\"io/ioutil\"\n-\t\"testing\"\n-\t\"time\"\n-)\n-\n-func TestSignDetached(t *testing.T) {\n-\tkring, _ := ReadKeyRing(readerFromHex(testKeys1And2PrivateHex))\n-\tout := bytes.NewBuffer(nil)\n-\tmessage := bytes.NewBufferString(signedInput)\n-\terr := DetachSign(out, kring[0], message)\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t}\n-\n-\ttestDetachedSignature(t, kring, out, signedInput, \"check\", testKey1KeyId)\n-}\n-\n-func TestSignTextDetached(t *testing.T) {\n-\tkring, _ := ReadKeyRing(readerFromHex(testKeys1And2PrivateHex))\n-\tout := bytes.NewBuffer(nil)\n-\tmessage := bytes.NewBufferString(signedInput)\n-\terr := DetachSignText(out, kring[0], message)\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t}\n-\n-\ttestDetachedSignature(t, kring, out, signedInput, \"check\", testKey1KeyId)\n-}\n-\n-func TestSignDetachedDSA(t *testing.T) {\n-\tkring, _ := ReadKeyRing(readerFromHex(dsaTestKeyPrivateHex))\n-\tout := bytes.NewBuffer(nil)\n-\tmessage := bytes.NewBufferString(signedInput)\n-\terr := DetachSign(out, kring[0], message)\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t}\n-\n-\ttestDetachedSignature(t, kring, out, signedInput, \"check\", testKey3KeyId)\n-}\n-\n-func TestNewEntity(t *testing.T) {\n-\tif testing.Short() {\n-\t\treturn\n-\t}\n-\n-\te, err := NewEntity(rand.Reader, time.Now(), \"Test User\", \"test\", \"test@example.com\")\n-\tif err != nil {\n-\t\tt.Errorf(\"failed to create entity: %s\", err)\n-\t\treturn\n-\t}\n-\n-\tw := bytes.NewBuffer(nil)\n-\tif err := e.SerializePrivate(w); err != nil {\n-\t\tt.Errorf(\"failed to serialize entity: %s\", err)\n-\t\treturn\n-\t}\n-\tserialized := w.Bytes()\n-\n-\tel, err := ReadKeyRing(w)\n-\tif err != nil {\n-\t\tt.Errorf(\"failed to reparse entity: %s\", err)\n-\t\treturn\n-\t}\n-\n-\tif len(el) != 1 {\n-\t\tt.Errorf(\"wrong number of entities found, got %d, want 1\", len(el))\n-\t}\n-\n-\tw = bytes.NewBuffer(nil)\n-\tif err := e.SerializePrivate(w); err != nil {\n-\t\tt.Errorf(\"failed to serialize entity second time: %s\", err)\n-\t\treturn\n-\t}\n-\n-\tif !bytes.Equal(w.Bytes(), serialized) {\n-\t\tt.Errorf(\"results differed\")\n-\t}\n-}\n-\n-func TestSymmetricEncryption(t *testing.T) {\n-\tbuf := new(bytes.Buffer)\n-\tplaintext, err := SymmetricallyEncrypt(buf, []byte(\"testing\"), nil)\n-\tif err != nil {\n-\t\tt.Errorf(\"error writing headers: %s\", err)\n-\t\treturn\n-\t}\n-\tmessage := []byte(\"hello world\\n\")\n-\t_, err = plaintext.Write(message)\n-\tif err != nil {\n-\t\tt.Errorf(\"error writing to plaintext writer: %s\", err)\n-\t}\n-\terr = plaintext.Close()\n-\tif err != nil {\n-\t\tt.Errorf(\"error closing plaintext writer: %s\", err)\n-\t}\n-\n-\tmd, err := ReadMessage(buf, nil, func(keys []Key, symmetric bool) ([]byte, error) {\n-\t\treturn []byte(\"testing\"), nil\n-\t})\n-\tif err != nil {\n-\t\tt.Errorf(\"error rereading message: %s\", err)\n-\t}\n-\tmessageBuf := bytes.NewBuffer(nil)\n-\t_, err = io.Copy(messageBuf, md.UnverifiedBody)\n-\tif err != nil {\n-\t\tt.Errorf(\"error rereading message: %s\", err)\n-\t}\n-\tif !bytes.Equal(message, messageBuf.Bytes()) {\n-\t\tt.Errorf(\"recovered message incorrect got '%s', want '%s'\", messageBuf.Bytes(), message)\n-\t}\n-}\n-\n-var testEncryptionTests = []struct {\n-\tkeyRingHex string\n-\tisSigned   bool\n-}{\n-\t{\n-\t\ttestKeys1And2PrivateHex,\n-\t\tfalse,\n-\t},\n-\t{\n-\t\ttestKeys1And2PrivateHex,\n-\t\ttrue,\n-\t},\n-\t{\n-\t\tdsaElGamalTestKeysHex,\n-\t\tfalse,\n-\t},\n-\t{\n-\t\tdsaElGamalTestKeysHex,\n-\t\ttrue,\n-\t},\n-}\n-\n-func TestEncryption(t *testing.T) {\n-\tfor i, test := range testEncryptionTests {\n-\t\tkring, _ := ReadKeyRing(readerFromHex(test.keyRingHex))\n-\n-\t\tpassphrase := []byte(\"passphrase\")\n-\t\tfor _, entity := range kring {\n-\t\t\tif entity.PrivateKey != nil && entity.PrivateKey.Encrypted {\n-\t\t\t\terr := entity.PrivateKey.Decrypt(passphrase)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tt.Errorf(\"#%d: failed to decrypt key\", i)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tfor _, subkey := range entity.Subkeys {\n-\t\t\t\tif subkey.PrivateKey != nil && subkey.PrivateKey.Encrypted {\n-\t\t\t\t\terr := subkey.PrivateKey.Decrypt(passphrase)\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\tt.Errorf(\"#%d: failed to decrypt subkey\", i)\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tvar signed *Entity\n-\t\tif test.isSigned {\n-\t\t\tsigned = kring[0]\n-\t\t}\n-\n-\t\tbuf := new(bytes.Buffer)\n-\t\tw, err := Encrypt(buf, kring[:1], signed, nil /* no hints */ )\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"#%d: error in Encrypt: %s\", i, err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tconst message = \"testing\"\n-\t\t_, err = w.Write([]byte(message))\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"#%d: error writing plaintext: %s\", i, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\terr = w.Close()\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"#%d: error closing WriteCloser: %s\", i, err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tmd, err := ReadMessage(buf, kring, nil /* no prompt */ )\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"#%d: error reading message: %s\", i, err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif test.isSigned {\n-\t\t\texpectedKeyId := kring[0].signingKey().PublicKey.KeyId\n-\t\t\tif md.SignedByKeyId != expectedKeyId {\n-\t\t\t\tt.Errorf(\"#%d: message signed by wrong key id, got: %d, want: %d\", i, *md.SignedBy, expectedKeyId)\n-\t\t\t}\n-\t\t\tif md.SignedBy == nil {\n-\t\t\t\tt.Errorf(\"#%d: failed to find the signing Entity\", i)\n-\t\t\t}\n-\t\t}\n-\n-\t\tplaintext, err := ioutil.ReadAll(md.UnverifiedBody)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"#%d: error reading encrypted contents: %s\", i, err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\texpectedKeyId := kring[0].encryptionKey().PublicKey.KeyId\n-\t\tif len(md.EncryptedToKeyIds) != 1 || md.EncryptedToKeyIds[0] != expectedKeyId {\n-\t\t\tt.Errorf(\"#%d: expected message to be encrypted to %v, but got %#v\", i, expectedKeyId, md.EncryptedToKeyIds)\n-\t\t}\n-\n-\t\tif string(plaintext) != message {\n-\t\t\tt.Errorf(\"#%d: got: %s, want: %s\", i, string(plaintext), message)\n-\t\t}\n-\n-\t\tif test.isSigned {\n-\t\t\tif md.SignatureError != nil {\n-\t\t\t\tt.Errorf(\"#%d: signature error: %s\", i, md.SignatureError)\n-\t\t\t}\n-\t\t\tif md.Signature == nil {\n-\t\t\t\tt.Error(\"signature missing\")\n-\t\t\t}\n-\t\t}\n-\t}\n-}"}, {"sha": "da690f0b92f52f5b1b7f983f3198f2697b14dc85", "filename": "libgo/go/crypto/ripemd160/ripemd160.go", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,120 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package ripemd160 implements the RIPEMD-160 hash algorithm.\n-package ripemd160\n-\n-// RIPEMD-160 is designed by by Hans Dobbertin, Antoon Bosselaers, and Bart\n-// Preneel with specifications available at:\n-// http://homes.esat.kuleuven.be/~cosicart/pdf/AB-9601/AB-9601.pdf.\n-\n-import (\n-\t\"crypto\"\n-\t\"hash\"\n-)\n-\n-func init() {\n-\tcrypto.RegisterHash(crypto.RIPEMD160, New)\n-}\n-\n-// The size of the checksum in bytes.\n-const Size = 20\n-\n-// The block size of the hash algorithm in bytes.\n-const BlockSize = 64\n-\n-const (\n-\t_s0 = 0x67452301\n-\t_s1 = 0xefcdab89\n-\t_s2 = 0x98badcfe\n-\t_s3 = 0x10325476\n-\t_s4 = 0xc3d2e1f0\n-)\n-\n-// digest represents the partial evaluation of a checksum.\n-type digest struct {\n-\ts  [5]uint32       // running context\n-\tx  [BlockSize]byte // temporary buffer\n-\tnx int             // index into x\n-\ttc uint64          // total count of bytes processed\n-}\n-\n-func (d *digest) Reset() {\n-\td.s[0], d.s[1], d.s[2], d.s[3], d.s[4] = _s0, _s1, _s2, _s3, _s4\n-\td.nx = 0\n-\td.tc = 0\n-}\n-\n-// New returns a new hash.Hash computing the checksum.\n-func New() hash.Hash {\n-\tresult := new(digest)\n-\tresult.Reset()\n-\treturn result\n-}\n-\n-func (d *digest) Size() int { return Size }\n-\n-func (d *digest) BlockSize() int { return BlockSize }\n-\n-func (d *digest) Write(p []byte) (nn int, err error) {\n-\tnn = len(p)\n-\td.tc += uint64(nn)\n-\tif d.nx > 0 {\n-\t\tn := len(p)\n-\t\tif n > BlockSize-d.nx {\n-\t\t\tn = BlockSize - d.nx\n-\t\t}\n-\t\tfor i := 0; i < n; i++ {\n-\t\t\td.x[d.nx+i] = p[i]\n-\t\t}\n-\t\td.nx += n\n-\t\tif d.nx == BlockSize {\n-\t\t\t_Block(d, d.x[0:])\n-\t\t\td.nx = 0\n-\t\t}\n-\t\tp = p[n:]\n-\t}\n-\tn := _Block(d, p)\n-\tp = p[n:]\n-\tif len(p) > 0 {\n-\t\td.nx = copy(d.x[:], p)\n-\t}\n-\treturn\n-}\n-\n-func (d0 *digest) Sum(in []byte) []byte {\n-\t// Make a copy of d0 so that caller can keep writing and summing.\n-\td := *d0\n-\n-\t// Padding.  Add a 1 bit and 0 bits until 56 bytes mod 64.\n-\ttc := d.tc\n-\tvar tmp [64]byte\n-\ttmp[0] = 0x80\n-\tif tc%64 < 56 {\n-\t\td.Write(tmp[0 : 56-tc%64])\n-\t} else {\n-\t\td.Write(tmp[0 : 64+56-tc%64])\n-\t}\n-\n-\t// Length in bits.\n-\ttc <<= 3\n-\tfor i := uint(0); i < 8; i++ {\n-\t\ttmp[i] = byte(tc >> (8 * i))\n-\t}\n-\td.Write(tmp[0:8])\n-\n-\tif d.nx != 0 {\n-\t\tpanic(\"d.nx != 0\")\n-\t}\n-\n-\tvar digest [Size]byte\n-\tfor i, s := range d.s {\n-\t\tdigest[i*4] = byte(s)\n-\t\tdigest[i*4+1] = byte(s >> 8)\n-\t\tdigest[i*4+2] = byte(s >> 16)\n-\t\tdigest[i*4+3] = byte(s >> 24)\n-\t}\n-\n-\treturn append(in, digest[:]...)\n-}"}, {"sha": "5df1b2593d2c16aa5bef5a54cb8fd18d0d895fa7", "filename": "libgo/go/crypto/ripemd160/ripemd160_test.go", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,64 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package ripemd160\n-\n-// Test vectors are from:\n-// http://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n-\n-import (\n-\t\"fmt\"\n-\t\"io\"\n-\t\"testing\"\n-)\n-\n-type mdTest struct {\n-\tout string\n-\tin  string\n-}\n-\n-var vectors = [...]mdTest{\n-\t{\"9c1185a5c5e9fc54612808977ee8f548b2258d31\", \"\"},\n-\t{\"0bdc9d2d256b3ee9daae347be6f4dc835a467ffe\", \"a\"},\n-\t{\"8eb208f7e05d987a9b044a8e98c6b087f15a0bfc\", \"abc\"},\n-\t{\"5d0689ef49d2fae572b881b123a85ffa21595f36\", \"message digest\"},\n-\t{\"f71c27109c692c1b56bbdceb5b9d2865b3708dbc\", \"abcdefghijklmnopqrstuvwxyz\"},\n-\t{\"12a053384a9c0c88e405a06c27dcf49ada62eb2b\", \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"},\n-\t{\"b0e20b6e3116640286ed3a87a5713079b21f5189\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"},\n-\t{\"9b752e45573d4b39f4dbd3323cab82bf63326bfb\", \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"},\n-}\n-\n-func TestVectors(t *testing.T) {\n-\tfor i := 0; i < len(vectors); i++ {\n-\t\ttv := vectors[i]\n-\t\tmd := New()\n-\t\tfor j := 0; j < 3; j++ {\n-\t\t\tif j < 2 {\n-\t\t\t\tio.WriteString(md, tv.in)\n-\t\t\t} else {\n-\t\t\t\tio.WriteString(md, tv.in[0:len(tv.in)/2])\n-\t\t\t\tmd.Sum(nil)\n-\t\t\t\tio.WriteString(md, tv.in[len(tv.in)/2:])\n-\t\t\t}\n-\t\t\ts := fmt.Sprintf(\"%x\", md.Sum(nil))\n-\t\t\tif s != tv.out {\n-\t\t\t\tt.Fatalf(\"RIPEMD-160[%d](%s) = %s, expected %s\", j, tv.in, s, tv.out)\n-\t\t\t}\n-\t\t\tmd.Reset()\n-\t\t}\n-\t}\n-}\n-\n-func TestMillionA(t *testing.T) {\n-\tmd := New()\n-\tfor i := 0; i < 100000; i++ {\n-\t\tio.WriteString(md, \"aaaaaaaaaa\")\n-\t}\n-\tout := \"52783243c1697bdbe16d37f97f68f08325dc1528\"\n-\ts := fmt.Sprintf(\"%x\", md.Sum(nil))\n-\tif s != out {\n-\t\tt.Fatalf(\"RIPEMD-160 (1 million 'a') = %s, expected %s\", s, out)\n-\t}\n-\tmd.Reset()\n-}"}, {"sha": "7bc8e6c485e53c6b55dfd2f16c2d93b84b2b4bee", "filename": "libgo/go/crypto/ripemd160/ripemd160block.go", "status": "removed", "additions": 0, "deletions": 161, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160block.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160block.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160block.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,161 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// RIPEMD-160 block step.\n-// In its own file so that a faster assembly or C version\n-// can be substituted easily.\n-\n-package ripemd160\n-\n-// work buffer indices and roll amounts for one line\n-var _n = [80]uint{\n-\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n-\t7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n-\t3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\n-\t1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n-\t4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,\n-}\n-\n-var _r = [80]uint{\n-\t11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\n-\t7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\n-\t11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\n-\t11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\n-\t9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6,\n-}\n-\n-// same for the other parallel one\n-var n_ = [80]uint{\n-\t5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\n-\t6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\n-\t15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\n-\t8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\n-\t12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11,\n-}\n-\n-var r_ = [80]uint{\n-\t8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\n-\t9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\n-\t9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\n-\t15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\n-\t8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11,\n-}\n-\n-func _Block(md *digest, p []byte) int {\n-\tn := 0\n-\tvar x [16]uint32\n-\tvar alpha, beta uint32\n-\tfor len(p) >= BlockSize {\n-\t\ta, b, c, d, e := md.s[0], md.s[1], md.s[2], md.s[3], md.s[4]\n-\t\taa, bb, cc, dd, ee := a, b, c, d, e\n-\t\tj := 0\n-\t\tfor i := 0; i < 16; i++ {\n-\t\t\tx[i] = uint32(p[j]) | uint32(p[j+1])<<8 | uint32(p[j+2])<<16 | uint32(p[j+3])<<24\n-\t\t\tj += 4\n-\t\t}\n-\n-\t\t// round 1\n-\t\ti := 0\n-\t\tfor i < 16 {\n-\t\t\talpha = a + (b ^ c ^ d) + x[_n[i]]\n-\t\t\ts := _r[i]\n-\t\t\talpha = (alpha<<s | alpha>>(32-s)) + e\n-\t\t\tbeta = c<<10 | c>>22\n-\t\t\ta, b, c, d, e = e, alpha, b, beta, d\n-\n-\t\t\t// parallel line\n-\t\t\talpha = aa + (bb ^ (cc | ^dd)) + x[n_[i]] + 0x50a28be6\n-\t\t\ts = r_[i]\n-\t\t\talpha = (alpha<<s | alpha>>(32-s)) + ee\n-\t\t\tbeta = cc<<10 | cc>>22\n-\t\t\taa, bb, cc, dd, ee = ee, alpha, bb, beta, dd\n-\n-\t\t\ti++\n-\t\t}\n-\n-\t\t// round 2\n-\t\tfor i < 32 {\n-\t\t\talpha = a + (b&c | ^b&d) + x[_n[i]] + 0x5a827999\n-\t\t\ts := _r[i]\n-\t\t\talpha = (alpha<<s | alpha>>(32-s)) + e\n-\t\t\tbeta = c<<10 | c>>22\n-\t\t\ta, b, c, d, e = e, alpha, b, beta, d\n-\n-\t\t\t// parallel line\n-\t\t\talpha = aa + (bb&dd | cc&^dd) + x[n_[i]] + 0x5c4dd124\n-\t\t\ts = r_[i]\n-\t\t\talpha = (alpha<<s | alpha>>(32-s)) + ee\n-\t\t\tbeta = cc<<10 | cc>>22\n-\t\t\taa, bb, cc, dd, ee = ee, alpha, bb, beta, dd\n-\n-\t\t\ti++\n-\t\t}\n-\n-\t\t// round 3\n-\t\tfor i < 48 {\n-\t\t\talpha = a + (b | ^c ^ d) + x[_n[i]] + 0x6ed9eba1\n-\t\t\ts := _r[i]\n-\t\t\talpha = (alpha<<s | alpha>>(32-s)) + e\n-\t\t\tbeta = c<<10 | c>>22\n-\t\t\ta, b, c, d, e = e, alpha, b, beta, d\n-\n-\t\t\t// parallel line\n-\t\t\talpha = aa + (bb | ^cc ^ dd) + x[n_[i]] + 0x6d703ef3\n-\t\t\ts = r_[i]\n-\t\t\talpha = (alpha<<s | alpha>>(32-s)) + ee\n-\t\t\tbeta = cc<<10 | cc>>22\n-\t\t\taa, bb, cc, dd, ee = ee, alpha, bb, beta, dd\n-\n-\t\t\ti++\n-\t\t}\n-\n-\t\t// round 4\n-\t\tfor i < 64 {\n-\t\t\talpha = a + (b&d | c&^d) + x[_n[i]] + 0x8f1bbcdc\n-\t\t\ts := _r[i]\n-\t\t\talpha = (alpha<<s | alpha>>(32-s)) + e\n-\t\t\tbeta = c<<10 | c>>22\n-\t\t\ta, b, c, d, e = e, alpha, b, beta, d\n-\n-\t\t\t// parallel line\n-\t\t\talpha = aa + (bb&cc | ^bb&dd) + x[n_[i]] + 0x7a6d76e9\n-\t\t\ts = r_[i]\n-\t\t\talpha = (alpha<<s | alpha>>(32-s)) + ee\n-\t\t\tbeta = cc<<10 | cc>>22\n-\t\t\taa, bb, cc, dd, ee = ee, alpha, bb, beta, dd\n-\n-\t\t\ti++\n-\t\t}\n-\n-\t\t// round 5\n-\t\tfor i < 80 {\n-\t\t\talpha = a + (b ^ (c | ^d)) + x[_n[i]] + 0xa953fd4e\n-\t\t\ts := _r[i]\n-\t\t\talpha = (alpha<<s | alpha>>(32-s)) + e\n-\t\t\tbeta = c<<10 | c>>22\n-\t\t\ta, b, c, d, e = e, alpha, b, beta, d\n-\n-\t\t\t// parallel line\n-\t\t\talpha = aa + (bb ^ cc ^ dd) + x[n_[i]]\n-\t\t\ts = r_[i]\n-\t\t\talpha = (alpha<<s | alpha>>(32-s)) + ee\n-\t\t\tbeta = cc<<10 | cc>>22\n-\t\t\taa, bb, cc, dd, ee = ee, alpha, bb, beta, dd\n-\n-\t\t\ti++\n-\t\t}\n-\n-\t\t// combine results\n-\t\tdd += c + md.s[1]\n-\t\tmd.s[1] = md.s[2] + d + ee\n-\t\tmd.s[2] = md.s[3] + e + aa\n-\t\tmd.s[3] = md.s[4] + a + bb\n-\t\tmd.s[4] = md.s[0] + b + cc\n-\t\tmd.s[0] = dd\n-\n-\t\tp = p[BlockSize:]\n-\t\tn += BlockSize\n-\t}\n-\treturn n\n-}"}, {"sha": "ee2c3e01795677cd81c79cb9dd860002cd2d5ed7", "filename": "libgo/go/crypto/tls/root_stub.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_stub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_stub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_stub.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build plan9 darwin/nocgo\n+// +build plan9 darwin,!cgo\n \n package tls\n "}, {"sha": "0616e7b82863735ab646734b3c024ffd54104c13", "filename": "libgo/go/crypto/twofish/twofish.go", "status": "removed", "additions": 0, "deletions": 355, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Ftwofish%2Ftwofish.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Ftwofish%2Ftwofish.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftwofish%2Ftwofish.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,355 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package twofish implements Bruce Schneier's Twofish encryption algorithm.\n-package twofish\n-\n-// Twofish is defined in http://www.schneier.com/paper-twofish-paper.pdf [TWOFISH]\n-\n-// This code is a port of the LibTom C implementation.\n-// See http://libtom.org/?page=features&newsitems=5&whatfile=crypt.\n-// LibTomCrypt is free for all purposes under the public domain.\n-// It was heavily inspired by the go blowfish package.\n-\n-import \"strconv\"\n-\n-// BlockSize is the constant block size of Twofish.\n-const BlockSize = 16\n-\n-const mdsPolynomial = 0x169 // x^8 + x^6 + x^5 + x^3 + 1, see [TWOFISH] 4.2\n-const rsPolynomial = 0x14d  // x^8 + x^6 + x^3 + x^2 + 1, see [TWOFISH] 4.3\n-\n-// A Cipher is an instance of Twofish encryption using a particular key.\n-type Cipher struct {\n-\ts [4][256]uint32\n-\tk [40]uint32\n-}\n-\n-type KeySizeError int\n-\n-func (k KeySizeError) Error() string {\n-\treturn \"crypto/twofish: invalid key size \" + strconv.Itoa(int(k))\n-}\n-\n-// NewCipher creates and returns a Cipher.\n-// The key argument should be the Twofish key, 16, 24 or 32 bytes.\n-func NewCipher(key []byte) (*Cipher, error) {\n-\tkeylen := len(key)\n-\n-\tif keylen != 16 && keylen != 24 && keylen != 32 {\n-\t\treturn nil, KeySizeError(keylen)\n-\t}\n-\n-\t// k is the number of 64 bit words in key\n-\tk := keylen / 8\n-\n-\t// Create the S[..] words\n-\tvar S [4 * 4]byte\n-\tfor i := 0; i < k; i++ {\n-\t\t// Computes [y0 y1 y2 y3] = rs . [x0 x1 x2 x3 x4 x5 x6 x7]\n-\t\tfor j, rsRow := range rs {\n-\t\t\tfor k, rsVal := range rsRow {\n-\t\t\t\tS[4*i+j] ^= gfMult(key[8*i+k], rsVal, rsPolynomial)\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// Calculate subkeys\n-\tc := new(Cipher)\n-\tvar tmp [4]byte\n-\tfor i := byte(0); i < 20; i++ {\n-\t\t// A = h(p * 2x, Me)\n-\t\tfor j := range tmp {\n-\t\t\ttmp[j] = 2 * i\n-\t\t}\n-\t\tA := h(tmp[:], key, 0)\n-\n-\t\t// B = rolc(h(p * (2x + 1), Mo), 8)\n-\t\tfor j := range tmp {\n-\t\t\ttmp[j] = 2*i + 1\n-\t\t}\n-\t\tB := h(tmp[:], key, 1)\n-\t\tB = rol(B, 8)\n-\n-\t\tc.k[2*i] = A + B\n-\n-\t\t// K[2i+1] = (A + 2B) <<< 9\n-\t\tc.k[2*i+1] = rol(2*B+A, 9)\n-\t}\n-\n-\t// Calculate sboxes\n-\tswitch k {\n-\tcase 2:\n-\t\tfor i := range c.s[0] {\n-\t\t\tc.s[0][i] = mdsColumnMult(sbox[1][sbox[0][sbox[0][byte(i)]^S[0]]^S[4]], 0)\n-\t\t\tc.s[1][i] = mdsColumnMult(sbox[0][sbox[0][sbox[1][byte(i)]^S[1]]^S[5]], 1)\n-\t\t\tc.s[2][i] = mdsColumnMult(sbox[1][sbox[1][sbox[0][byte(i)]^S[2]]^S[6]], 2)\n-\t\t\tc.s[3][i] = mdsColumnMult(sbox[0][sbox[1][sbox[1][byte(i)]^S[3]]^S[7]], 3)\n-\t\t}\n-\tcase 3:\n-\t\tfor i := range c.s[0] {\n-\t\t\tc.s[0][i] = mdsColumnMult(sbox[1][sbox[0][sbox[0][sbox[1][byte(i)]^S[0]]^S[4]]^S[8]], 0)\n-\t\t\tc.s[1][i] = mdsColumnMult(sbox[0][sbox[0][sbox[1][sbox[1][byte(i)]^S[1]]^S[5]]^S[9]], 1)\n-\t\t\tc.s[2][i] = mdsColumnMult(sbox[1][sbox[1][sbox[0][sbox[0][byte(i)]^S[2]]^S[6]]^S[10]], 2)\n-\t\t\tc.s[3][i] = mdsColumnMult(sbox[0][sbox[1][sbox[1][sbox[0][byte(i)]^S[3]]^S[7]]^S[11]], 3)\n-\t\t}\n-\tdefault:\n-\t\tfor i := range c.s[0] {\n-\t\t\tc.s[0][i] = mdsColumnMult(sbox[1][sbox[0][sbox[0][sbox[1][sbox[1][byte(i)]^S[0]]^S[4]]^S[8]]^S[12]], 0)\n-\t\t\tc.s[1][i] = mdsColumnMult(sbox[0][sbox[0][sbox[1][sbox[1][sbox[0][byte(i)]^S[1]]^S[5]]^S[9]]^S[13]], 1)\n-\t\t\tc.s[2][i] = mdsColumnMult(sbox[1][sbox[1][sbox[0][sbox[0][sbox[0][byte(i)]^S[2]]^S[6]]^S[10]]^S[14]], 2)\n-\t\t\tc.s[3][i] = mdsColumnMult(sbox[0][sbox[1][sbox[1][sbox[0][sbox[1][byte(i)]^S[3]]^S[7]]^S[11]]^S[15]], 3)\n-\t\t}\n-\t}\n-\n-\treturn c, nil\n-}\n-\n-// Reset zeros the key data, so that it will no longer appear in the process's\n-// memory.\n-func (c *Cipher) Reset() {\n-\tfor i := range c.k {\n-\t\tc.k[i] = 0\n-\t}\n-\tfor i := range c.s {\n-\t\tfor j := 0; j < 256; j++ {\n-\t\t\tc.s[i][j] = 0\n-\t\t}\n-\t}\n-}\n-\n-// BlockSize returns the Twofish block size, 16 bytes.\n-func (c *Cipher) BlockSize() int { return BlockSize }\n-\n-// store32l stores src in dst in little-endian form.\n-func store32l(dst []byte, src uint32) {\n-\tdst[0] = byte(src)\n-\tdst[1] = byte(src >> 8)\n-\tdst[2] = byte(src >> 16)\n-\tdst[3] = byte(src >> 24)\n-\treturn\n-}\n-\n-// load32l reads a little-endian uint32 from src.\n-func load32l(src []byte) uint32 {\n-\treturn uint32(src[0]) | uint32(src[1])<<8 | uint32(src[2])<<16 | uint32(src[3])<<24\n-}\n-\n-// rol returns x after a left circular rotation of y bits.\n-func rol(x, y uint32) uint32 {\n-\treturn (x << (y & 31)) | (x >> (32 - (y & 31)))\n-}\n-\n-// ror returns x after a right circular rotation of y bits.\n-func ror(x, y uint32) uint32 {\n-\treturn (x >> (y & 31)) | (x << (32 - (y & 31)))\n-}\n-\n-// The RS matrix. See [TWOFISH] 4.3\n-var rs = [4][8]byte{\n-\t{0x01, 0xA4, 0x55, 0x87, 0x5A, 0x58, 0xDB, 0x9E},\n-\t{0xA4, 0x56, 0x82, 0xF3, 0x1E, 0xC6, 0x68, 0xE5},\n-\t{0x02, 0xA1, 0xFC, 0xC1, 0x47, 0xAE, 0x3D, 0x19},\n-\t{0xA4, 0x55, 0x87, 0x5A, 0x58, 0xDB, 0x9E, 0x03},\n-}\n-\n-// sbox tables\n-var sbox = [2][256]byte{\n-\t{\n-\t\t0xa9, 0x67, 0xb3, 0xe8, 0x04, 0xfd, 0xa3, 0x76, 0x9a, 0x92, 0x80, 0x78, 0xe4, 0xdd, 0xd1, 0x38,\n-\t\t0x0d, 0xc6, 0x35, 0x98, 0x18, 0xf7, 0xec, 0x6c, 0x43, 0x75, 0x37, 0x26, 0xfa, 0x13, 0x94, 0x48,\n-\t\t0xf2, 0xd0, 0x8b, 0x30, 0x84, 0x54, 0xdf, 0x23, 0x19, 0x5b, 0x3d, 0x59, 0xf3, 0xae, 0xa2, 0x82,\n-\t\t0x63, 0x01, 0x83, 0x2e, 0xd9, 0x51, 0x9b, 0x7c, 0xa6, 0xeb, 0xa5, 0xbe, 0x16, 0x0c, 0xe3, 0x61,\n-\t\t0xc0, 0x8c, 0x3a, 0xf5, 0x73, 0x2c, 0x25, 0x0b, 0xbb, 0x4e, 0x89, 0x6b, 0x53, 0x6a, 0xb4, 0xf1,\n-\t\t0xe1, 0xe6, 0xbd, 0x45, 0xe2, 0xf4, 0xb6, 0x66, 0xcc, 0x95, 0x03, 0x56, 0xd4, 0x1c, 0x1e, 0xd7,\n-\t\t0xfb, 0xc3, 0x8e, 0xb5, 0xe9, 0xcf, 0xbf, 0xba, 0xea, 0x77, 0x39, 0xaf, 0x33, 0xc9, 0x62, 0x71,\n-\t\t0x81, 0x79, 0x09, 0xad, 0x24, 0xcd, 0xf9, 0xd8, 0xe5, 0xc5, 0xb9, 0x4d, 0x44, 0x08, 0x86, 0xe7,\n-\t\t0xa1, 0x1d, 0xaa, 0xed, 0x06, 0x70, 0xb2, 0xd2, 0x41, 0x7b, 0xa0, 0x11, 0x31, 0xc2, 0x27, 0x90,\n-\t\t0x20, 0xf6, 0x60, 0xff, 0x96, 0x5c, 0xb1, 0xab, 0x9e, 0x9c, 0x52, 0x1b, 0x5f, 0x93, 0x0a, 0xef,\n-\t\t0x91, 0x85, 0x49, 0xee, 0x2d, 0x4f, 0x8f, 0x3b, 0x47, 0x87, 0x6d, 0x46, 0xd6, 0x3e, 0x69, 0x64,\n-\t\t0x2a, 0xce, 0xcb, 0x2f, 0xfc, 0x97, 0x05, 0x7a, 0xac, 0x7f, 0xd5, 0x1a, 0x4b, 0x0e, 0xa7, 0x5a,\n-\t\t0x28, 0x14, 0x3f, 0x29, 0x88, 0x3c, 0x4c, 0x02, 0xb8, 0xda, 0xb0, 0x17, 0x55, 0x1f, 0x8a, 0x7d,\n-\t\t0x57, 0xc7, 0x8d, 0x74, 0xb7, 0xc4, 0x9f, 0x72, 0x7e, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34,\n-\t\t0x6e, 0x50, 0xde, 0x68, 0x65, 0xbc, 0xdb, 0xf8, 0xc8, 0xa8, 0x2b, 0x40, 0xdc, 0xfe, 0x32, 0xa4,\n-\t\t0xca, 0x10, 0x21, 0xf0, 0xd3, 0x5d, 0x0f, 0x00, 0x6f, 0x9d, 0x36, 0x42, 0x4a, 0x5e, 0xc1, 0xe0,\n-\t},\n-\t{\n-\t\t0x75, 0xf3, 0xc6, 0xf4, 0xdb, 0x7b, 0xfb, 0xc8, 0x4a, 0xd3, 0xe6, 0x6b, 0x45, 0x7d, 0xe8, 0x4b,\n-\t\t0xd6, 0x32, 0xd8, 0xfd, 0x37, 0x71, 0xf1, 0xe1, 0x30, 0x0f, 0xf8, 0x1b, 0x87, 0xfa, 0x06, 0x3f,\n-\t\t0x5e, 0xba, 0xae, 0x5b, 0x8a, 0x00, 0xbc, 0x9d, 0x6d, 0xc1, 0xb1, 0x0e, 0x80, 0x5d, 0xd2, 0xd5,\n-\t\t0xa0, 0x84, 0x07, 0x14, 0xb5, 0x90, 0x2c, 0xa3, 0xb2, 0x73, 0x4c, 0x54, 0x92, 0x74, 0x36, 0x51,\n-\t\t0x38, 0xb0, 0xbd, 0x5a, 0xfc, 0x60, 0x62, 0x96, 0x6c, 0x42, 0xf7, 0x10, 0x7c, 0x28, 0x27, 0x8c,\n-\t\t0x13, 0x95, 0x9c, 0xc7, 0x24, 0x46, 0x3b, 0x70, 0xca, 0xe3, 0x85, 0xcb, 0x11, 0xd0, 0x93, 0xb8,\n-\t\t0xa6, 0x83, 0x20, 0xff, 0x9f, 0x77, 0xc3, 0xcc, 0x03, 0x6f, 0x08, 0xbf, 0x40, 0xe7, 0x2b, 0xe2,\n-\t\t0x79, 0x0c, 0xaa, 0x82, 0x41, 0x3a, 0xea, 0xb9, 0xe4, 0x9a, 0xa4, 0x97, 0x7e, 0xda, 0x7a, 0x17,\n-\t\t0x66, 0x94, 0xa1, 0x1d, 0x3d, 0xf0, 0xde, 0xb3, 0x0b, 0x72, 0xa7, 0x1c, 0xef, 0xd1, 0x53, 0x3e,\n-\t\t0x8f, 0x33, 0x26, 0x5f, 0xec, 0x76, 0x2a, 0x49, 0x81, 0x88, 0xee, 0x21, 0xc4, 0x1a, 0xeb, 0xd9,\n-\t\t0xc5, 0x39, 0x99, 0xcd, 0xad, 0x31, 0x8b, 0x01, 0x18, 0x23, 0xdd, 0x1f, 0x4e, 0x2d, 0xf9, 0x48,\n-\t\t0x4f, 0xf2, 0x65, 0x8e, 0x78, 0x5c, 0x58, 0x19, 0x8d, 0xe5, 0x98, 0x57, 0x67, 0x7f, 0x05, 0x64,\n-\t\t0xaf, 0x63, 0xb6, 0xfe, 0xf5, 0xb7, 0x3c, 0xa5, 0xce, 0xe9, 0x68, 0x44, 0xe0, 0x4d, 0x43, 0x69,\n-\t\t0x29, 0x2e, 0xac, 0x15, 0x59, 0xa8, 0x0a, 0x9e, 0x6e, 0x47, 0xdf, 0x34, 0x35, 0x6a, 0xcf, 0xdc,\n-\t\t0x22, 0xc9, 0xc0, 0x9b, 0x89, 0xd4, 0xed, 0xab, 0x12, 0xa2, 0x0d, 0x52, 0xbb, 0x02, 0x2f, 0xa9,\n-\t\t0xd7, 0x61, 0x1e, 0xb4, 0x50, 0x04, 0xf6, 0xc2, 0x16, 0x25, 0x86, 0x56, 0x55, 0x09, 0xbe, 0x91,\n-\t},\n-}\n-\n-// gfMult returns a\u00b7b in GF(2^8)/p\n-func gfMult(a, b byte, p uint32) byte {\n-\tB := [2]uint32{0, uint32(b)}\n-\tP := [2]uint32{0, p}\n-\tvar result uint32\n-\n-\t// branchless GF multiplier\n-\tfor i := 0; i < 7; i++ {\n-\t\tresult ^= B[a&1]\n-\t\ta >>= 1\n-\t\tB[1] = P[B[1]>>7] ^ (B[1] << 1)\n-\t}\n-\tresult ^= B[a&1]\n-\treturn byte(result)\n-}\n-\n-// mdsColumnMult calculates y{col} where [y0 y1 y2 y3] = MDS \u00b7 [x0]\n-func mdsColumnMult(in byte, col int) uint32 {\n-\tmul01 := in\n-\tmul5B := gfMult(in, 0x5B, mdsPolynomial)\n-\tmulEF := gfMult(in, 0xEF, mdsPolynomial)\n-\n-\tswitch col {\n-\tcase 0:\n-\t\treturn uint32(mul01) | uint32(mul5B)<<8 | uint32(mulEF)<<16 | uint32(mulEF)<<24\n-\tcase 1:\n-\t\treturn uint32(mulEF) | uint32(mulEF)<<8 | uint32(mul5B)<<16 | uint32(mul01)<<24\n-\tcase 2:\n-\t\treturn uint32(mul5B) | uint32(mulEF)<<8 | uint32(mul01)<<16 | uint32(mulEF)<<24\n-\tcase 3:\n-\t\treturn uint32(mul5B) | uint32(mul01)<<8 | uint32(mulEF)<<16 | uint32(mul5B)<<24\n-\t}\n-\n-\tpanic(\"unreachable\")\n-}\n-\n-// h implements the S-box generation function. See [TWOFISH] 4.3.5\n-func h(in, key []byte, offset int) uint32 {\n-\tvar y [4]byte\n-\tfor x := range y {\n-\t\ty[x] = in[x]\n-\t}\n-\tswitch len(key) / 8 {\n-\tcase 4:\n-\t\ty[0] = sbox[1][y[0]] ^ key[4*(6+offset)+0]\n-\t\ty[1] = sbox[0][y[1]] ^ key[4*(6+offset)+1]\n-\t\ty[2] = sbox[0][y[2]] ^ key[4*(6+offset)+2]\n-\t\ty[3] = sbox[1][y[3]] ^ key[4*(6+offset)+3]\n-\t\tfallthrough\n-\tcase 3:\n-\t\ty[0] = sbox[1][y[0]] ^ key[4*(4+offset)+0]\n-\t\ty[1] = sbox[1][y[1]] ^ key[4*(4+offset)+1]\n-\t\ty[2] = sbox[0][y[2]] ^ key[4*(4+offset)+2]\n-\t\ty[3] = sbox[0][y[3]] ^ key[4*(4+offset)+3]\n-\t\tfallthrough\n-\tcase 2:\n-\t\ty[0] = sbox[1][sbox[0][sbox[0][y[0]]^key[4*(2+offset)+0]]^key[4*(0+offset)+0]]\n-\t\ty[1] = sbox[0][sbox[0][sbox[1][y[1]]^key[4*(2+offset)+1]]^key[4*(0+offset)+1]]\n-\t\ty[2] = sbox[1][sbox[1][sbox[0][y[2]]^key[4*(2+offset)+2]]^key[4*(0+offset)+2]]\n-\t\ty[3] = sbox[0][sbox[1][sbox[1][y[3]]^key[4*(2+offset)+3]]^key[4*(0+offset)+3]]\n-\t}\n-\t// [y0 y1 y2 y3] = MDS . [x0 x1 x2 x3]\n-\tvar mdsMult uint32\n-\tfor i := range y {\n-\t\tmdsMult ^= mdsColumnMult(y[i], i)\n-\t}\n-\treturn mdsMult\n-}\n-\n-// Encrypt encrypts a 16-byte block from src to dst, which may overlap.\n-// Note that for amounts of data larger than a block,\n-// it is not safe to just call Encrypt on successive blocks;\n-// instead, use an encryption mode like CBC (see crypto/cipher/cbc.go).\n-func (c *Cipher) Encrypt(dst, src []byte) {\n-\tS1 := c.s[0]\n-\tS2 := c.s[1]\n-\tS3 := c.s[2]\n-\tS4 := c.s[3]\n-\n-\t// Load input\n-\tia := load32l(src[0:4])\n-\tib := load32l(src[4:8])\n-\tic := load32l(src[8:12])\n-\tid := load32l(src[12:16])\n-\n-\t// Pre-whitening\n-\tia ^= c.k[0]\n-\tib ^= c.k[1]\n-\tic ^= c.k[2]\n-\tid ^= c.k[3]\n-\n-\tfor i := 0; i < 8; i++ {\n-\t\tk := c.k[8+i*4 : 12+i*4]\n-\t\tt2 := S2[byte(ib)] ^ S3[byte(ib>>8)] ^ S4[byte(ib>>16)] ^ S1[byte(ib>>24)]\n-\t\tt1 := S1[byte(ia)] ^ S2[byte(ia>>8)] ^ S3[byte(ia>>16)] ^ S4[byte(ia>>24)] + t2\n-\t\tic = ror(ic^(t1+k[0]), 1)\n-\t\tid = rol(id, 1) ^ (t2 + t1 + k[1])\n-\n-\t\tt2 = S2[byte(id)] ^ S3[byte(id>>8)] ^ S4[byte(id>>16)] ^ S1[byte(id>>24)]\n-\t\tt1 = S1[byte(ic)] ^ S2[byte(ic>>8)] ^ S3[byte(ic>>16)] ^ S4[byte(ic>>24)] + t2\n-\t\tia = ror(ia^(t1+k[2]), 1)\n-\t\tib = rol(ib, 1) ^ (t2 + t1 + k[3])\n-\t}\n-\n-\t// Output with \"undo last swap\"\n-\tta := ic ^ c.k[4]\n-\ttb := id ^ c.k[5]\n-\ttc := ia ^ c.k[6]\n-\ttd := ib ^ c.k[7]\n-\n-\tstore32l(dst[0:4], ta)\n-\tstore32l(dst[4:8], tb)\n-\tstore32l(dst[8:12], tc)\n-\tstore32l(dst[12:16], td)\n-}\n-\n-// Decrypt decrypts a 16-byte block from src to dst, which may overlap.\n-func (c *Cipher) Decrypt(dst, src []byte) {\n-\tS1 := c.s[0]\n-\tS2 := c.s[1]\n-\tS3 := c.s[2]\n-\tS4 := c.s[3]\n-\n-\t// Load input\n-\tta := load32l(src[0:4])\n-\ttb := load32l(src[4:8])\n-\ttc := load32l(src[8:12])\n-\ttd := load32l(src[12:16])\n-\n-\t// Undo undo final swap\n-\tia := tc ^ c.k[6]\n-\tib := td ^ c.k[7]\n-\tic := ta ^ c.k[4]\n-\tid := tb ^ c.k[5]\n-\n-\tfor i := 8; i > 0; i-- {\n-\t\tk := c.k[4+i*4 : 8+i*4]\n-\t\tt2 := S2[byte(id)] ^ S3[byte(id>>8)] ^ S4[byte(id>>16)] ^ S1[byte(id>>24)]\n-\t\tt1 := S1[byte(ic)] ^ S2[byte(ic>>8)] ^ S3[byte(ic>>16)] ^ S4[byte(ic>>24)] + t2\n-\t\tia = rol(ia, 1) ^ (t1 + k[2])\n-\t\tib = ror(ib^(t2+t1+k[3]), 1)\n-\n-\t\tt2 = S2[byte(ib)] ^ S3[byte(ib>>8)] ^ S4[byte(ib>>16)] ^ S1[byte(ib>>24)]\n-\t\tt1 = S1[byte(ia)] ^ S2[byte(ia>>8)] ^ S3[byte(ia>>16)] ^ S4[byte(ia>>24)] + t2\n-\t\tic = rol(ic, 1) ^ (t1 + k[0])\n-\t\tid = ror(id^(t2+t1+k[1]), 1)\n-\t}\n-\n-\t// Undo pre-whitening\n-\tia ^= c.k[0]\n-\tib ^= c.k[1]\n-\tic ^= c.k[2]\n-\tid ^= c.k[3]\n-\n-\tstore32l(dst[0:4], ia)\n-\tstore32l(dst[4:8], ib)\n-\tstore32l(dst[8:12], ic)\n-\tstore32l(dst[12:16], id)\n-}"}, {"sha": "303081f3f28a3a1549da91979479f5c186448a8f", "filename": "libgo/go/crypto/twofish/twofish_test.go", "status": "removed", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Ftwofish%2Ftwofish_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Ftwofish%2Ftwofish_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftwofish%2Ftwofish_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,129 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package twofish\n-\n-import (\n-\t\"bytes\"\n-\t\"testing\"\n-)\n-\n-var qbox = [2][4][16]byte{\n-\t{\n-\t\t{0x8, 0x1, 0x7, 0xD, 0x6, 0xF, 0x3, 0x2, 0x0, 0xB, 0x5, 0x9, 0xE, 0xC, 0xA, 0x4},\n-\t\t{0xE, 0xC, 0xB, 0x8, 0x1, 0x2, 0x3, 0x5, 0xF, 0x4, 0xA, 0x6, 0x7, 0x0, 0x9, 0xD},\n-\t\t{0xB, 0xA, 0x5, 0xE, 0x6, 0xD, 0x9, 0x0, 0xC, 0x8, 0xF, 0x3, 0x2, 0x4, 0x7, 0x1},\n-\t\t{0xD, 0x7, 0xF, 0x4, 0x1, 0x2, 0x6, 0xE, 0x9, 0xB, 0x3, 0x0, 0x8, 0x5, 0xC, 0xA},\n-\t},\n-\t{\n-\t\t{0x2, 0x8, 0xB, 0xD, 0xF, 0x7, 0x6, 0xE, 0x3, 0x1, 0x9, 0x4, 0x0, 0xA, 0xC, 0x5},\n-\t\t{0x1, 0xE, 0x2, 0xB, 0x4, 0xC, 0x3, 0x7, 0x6, 0xD, 0xA, 0x5, 0xF, 0x9, 0x0, 0x8},\n-\t\t{0x4, 0xC, 0x7, 0x5, 0x1, 0x6, 0x9, 0xA, 0x0, 0xE, 0xD, 0x8, 0x2, 0xB, 0x3, 0xF},\n-\t\t{0xB, 0x9, 0x5, 0x1, 0xC, 0x3, 0xD, 0xE, 0x6, 0x4, 0x7, 0xF, 0x2, 0x0, 0x8, 0xA},\n-\t},\n-}\n-\n-// genSbox generates the variable sbox\n-func genSbox(qi int, x byte) byte {\n-\ta0, b0 := x/16, x%16\n-\tfor i := 0; i < 2; i++ {\n-\t\ta1 := a0 ^ b0\n-\t\tb1 := (a0 ^ ((b0 << 3) | (b0 >> 1)) ^ (a0 << 3)) & 15\n-\t\ta0 = qbox[qi][2*i][a1]\n-\t\tb0 = qbox[qi][2*i+1][b1]\n-\t}\n-\treturn (b0 << 4) + a0\n-}\n-\n-func TestSbox(t *testing.T) {\n-\tfor n := range sbox {\n-\t\tfor m := range sbox[n] {\n-\t\t\tif genSbox(n, byte(m)) != sbox[n][m] {\n-\t\t\t\tt.Errorf(\"#%d|%d: sbox value = %d want %d\", n, m, sbox[n][m], genSbox(n, byte(m)))\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-var testVectors = []struct {\n-\tkey []byte\n-\tdec []byte\n-\tenc []byte\n-}{\n-\t// These tests are extracted from LibTom\n-\t{\n-\t\t[]byte{0x9F, 0x58, 0x9F, 0x5C, 0xF6, 0x12, 0x2C, 0x32, 0xB6, 0xBF, 0xEC, 0x2F, 0x2A, 0xE8, 0xC3, 0x5A},\n-\t\t[]byte{0xD4, 0x91, 0xDB, 0x16, 0xE7, 0xB1, 0xC3, 0x9E, 0x86, 0xCB, 0x08, 0x6B, 0x78, 0x9F, 0x54, 0x19},\n-\t\t[]byte{0x01, 0x9F, 0x98, 0x09, 0xDE, 0x17, 0x11, 0x85, 0x8F, 0xAA, 0xC3, 0xA3, 0xBA, 0x20, 0xFB, 0xC3},\n-\t},\n-\t{\n-\t\t[]byte{0x88, 0xB2, 0xB2, 0x70, 0x6B, 0x10, 0x5E, 0x36, 0xB4, 0x46, 0xBB, 0x6D, 0x73, 0x1A, 0x1E, 0x88,\n-\t\t\t0xEF, 0xA7, 0x1F, 0x78, 0x89, 0x65, 0xBD, 0x44},\n-\t\t[]byte{0x39, 0xDA, 0x69, 0xD6, 0xBA, 0x49, 0x97, 0xD5, 0x85, 0xB6, 0xDC, 0x07, 0x3C, 0xA3, 0x41, 0xB2},\n-\t\t[]byte{0x18, 0x2B, 0x02, 0xD8, 0x14, 0x97, 0xEA, 0x45, 0xF9, 0xDA, 0xAC, 0xDC, 0x29, 0x19, 0x3A, 0x65},\n-\t},\n-\t{\n-\t\t[]byte{0xD4, 0x3B, 0xB7, 0x55, 0x6E, 0xA3, 0x2E, 0x46, 0xF2, 0xA2, 0x82, 0xB7, 0xD4, 0x5B, 0x4E, 0x0D,\n-\t\t\t0x57, 0xFF, 0x73, 0x9D, 0x4D, 0xC9, 0x2C, 0x1B, 0xD7, 0xFC, 0x01, 0x70, 0x0C, 0xC8, 0x21, 0x6F},\n-\t\t[]byte{0x90, 0xAF, 0xE9, 0x1B, 0xB2, 0x88, 0x54, 0x4F, 0x2C, 0x32, 0xDC, 0x23, 0x9B, 0x26, 0x35, 0xE6},\n-\t\t[]byte{0x6C, 0xB4, 0x56, 0x1C, 0x40, 0xBF, 0x0A, 0x97, 0x05, 0x93, 0x1C, 0xB6, 0xD4, 0x08, 0xE7, 0xFA},\n-\t},\n-\t// These test are derived from http://www.schneier.com/code/ecb_ival.txt\n-\t{\n-\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n-\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n-\t\t[]byte{0x9F, 0x58, 0x9F, 0x5C, 0xF6, 0x12, 0x2C, 0x32, 0xB6, 0xBF, 0xEC, 0x2F, 0x2A, 0xE8, 0xC3, 0x5A},\n-\t},\n-\t{\n-\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,\n-\t\t\t0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n-\t\t},\n-\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n-\t\t[]byte{0xCF, 0xD1, 0xD2, 0xE5, 0xA9, 0xBE, 0x9C, 0xDF, 0x50, 0x1F, 0x13, 0xB8, 0x92, 0xBD, 0x22, 0x48},\n-\t},\n-\t{\n-\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,\n-\t\t\t0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,\n-\t\t},\n-\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n-\t\t[]byte{0x37, 0x52, 0x7B, 0xE0, 0x05, 0x23, 0x34, 0xB8, 0x9F, 0x0C, 0xFC, 0xCA, 0xE8, 0x7C, 0xFA, 0x20},\n-\t},\n-}\n-\n-func TestCipher(t *testing.T) {\n-\tfor n, tt := range testVectors {\n-\t\t// Test if the plaintext (dec) is encrypts to the given\n-\t\t// ciphertext (enc) using the given key. Test also if enc can\n-\t\t// be decrypted again into dec.\n-\t\tc, err := NewCipher(tt.key)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"#%d: NewCipher: %v\", n, err)\n-\t\t\treturn\n-\t\t}\n-\n-\t\tbuf := make([]byte, 16)\n-\t\tc.Encrypt(buf, tt.dec)\n-\t\tif !bytes.Equal(buf, tt.enc) {\n-\t\t\tt.Errorf(\"#%d: encrypt = %x want %x\", n, buf, tt.enc)\n-\t\t}\n-\t\tc.Decrypt(buf, tt.enc)\n-\t\tif !bytes.Equal(buf, tt.dec) {\n-\t\t\tt.Errorf(\"#%d: decrypt = %x want %x\", n, buf, tt.dec)\n-\t\t}\n-\n-\t\t// Test that 16 zero bytes, encrypted 1000 times then decrypted\n-\t\t// 1000 times results in zero bytes again.\n-\t\tzero := make([]byte, 16)\n-\t\tbuf = make([]byte, 16)\n-\t\tfor i := 0; i < 1000; i++ {\n-\t\t\tc.Encrypt(buf, buf)\n-\t\t}\n-\t\tfor i := 0; i < 1000; i++ {\n-\t\t\tc.Decrypt(buf, buf)\n-\t\t}\n-\t\tif !bytes.Equal(buf, zero) {\n-\t\t\tt.Errorf(\"#%d: encrypt/decrypt 1000: have %x want %x\", n, buf, zero)\n-\t\t}\n-\t}\n-}"}, {"sha": "bf5d245992d99dfba447c1b4e52b811a7e7653a6", "filename": "libgo/go/crypto/xtea/block.go", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fxtea%2Fblock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fxtea%2Fblock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fxtea%2Fblock.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,66 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-/*\n-\tImplementation adapted from Needham and Wheeler's paper:\n-\thttp://www.cix.co.uk/~klockstone/xtea.pdf\n-\n-\tA precalculated look up table is used during encryption/decryption for values that are based purely on the key.\n-*/\n-\n-package xtea\n-\n-// XTEA is based on 64 rounds.\n-const numRounds = 64\n-\n-// blockToUint32 reads an 8 byte slice into two uint32s.\n-// The block is treated as big endian.\n-func blockToUint32(src []byte) (uint32, uint32) {\n-\tr0 := uint32(src[0])<<24 | uint32(src[1])<<16 | uint32(src[2])<<8 | uint32(src[3])\n-\tr1 := uint32(src[4])<<24 | uint32(src[5])<<16 | uint32(src[6])<<8 | uint32(src[7])\n-\treturn r0, r1\n-}\n-\n-// uint32ToBlock writes two uint32s into an 8 byte data block.\n-// Values are written as big endian.\n-func uint32ToBlock(v0, v1 uint32, dst []byte) {\n-\tdst[0] = byte(v0 >> 24)\n-\tdst[1] = byte(v0 >> 16)\n-\tdst[2] = byte(v0 >> 8)\n-\tdst[3] = byte(v0)\n-\tdst[4] = byte(v1 >> 24)\n-\tdst[5] = byte(v1 >> 16)\n-\tdst[6] = byte(v1 >> 8)\n-\tdst[7] = byte(v1 >> 0)\n-}\n-\n-// encryptBlock encrypts a single 8 byte block using XTEA.\n-func encryptBlock(c *Cipher, dst, src []byte) {\n-\tv0, v1 := blockToUint32(src)\n-\n-\t// Two rounds of XTEA applied per loop\n-\tfor i := 0; i < numRounds; {\n-\t\tv0 += ((v1<<4 ^ v1>>5) + v1) ^ c.table[i]\n-\t\ti++\n-\t\tv1 += ((v0<<4 ^ v0>>5) + v0) ^ c.table[i]\n-\t\ti++\n-\t}\n-\n-\tuint32ToBlock(v0, v1, dst)\n-}\n-\n-// decryptBlock decrypt a single 8 byte block using XTEA.\n-func decryptBlock(c *Cipher, dst, src []byte) {\n-\tv0, v1 := blockToUint32(src)\n-\n-\t// Two rounds of XTEA applied per loop\n-\tfor i := numRounds; i > 0; {\n-\t\ti--\n-\t\tv1 -= ((v0<<4 ^ v0>>5) + v0) ^ c.table[i]\n-\t\ti--\n-\t\tv0 -= ((v1<<4 ^ v1>>5) + v1) ^ c.table[i]\n-\t}\n-\n-\tuint32ToBlock(v0, v1, dst)\n-}"}, {"sha": "3ed05814a3b76163ee0f8774479b46a7d7e5964b", "filename": "libgo/go/crypto/xtea/cipher.go", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fxtea%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fxtea%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fxtea%2Fcipher.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,89 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package xtea implements XTEA encryption, as defined in Needham and Wheeler's\n-// 1997 technical report, \"Tea extensions.\"\n-package xtea\n-\n-// For details, see http://www.cix.co.uk/~klockstone/xtea.pdf\n-\n-import \"strconv\"\n-\n-// The XTEA block size in bytes.\n-const BlockSize = 8\n-\n-// A Cipher is an instance of an XTEA cipher using a particular key.\n-// table contains a series of precalculated values that are used each round.\n-type Cipher struct {\n-\ttable [64]uint32\n-}\n-\n-type KeySizeError int\n-\n-func (k KeySizeError) Error() string {\n-\treturn \"crypto/xtea: invalid key size \" + strconv.Itoa(int(k))\n-}\n-\n-// NewCipher creates and returns a new Cipher.\n-// The key argument should be the XTEA key.\n-// XTEA only supports 128 bit (16 byte) keys.\n-func NewCipher(key []byte) (*Cipher, error) {\n-\tk := len(key)\n-\tswitch k {\n-\tdefault:\n-\t\treturn nil, KeySizeError(k)\n-\tcase 16:\n-\t\tbreak\n-\t}\n-\n-\tc := new(Cipher)\n-\tinitCipher(c, key)\n-\n-\treturn c, nil\n-}\n-\n-// BlockSize returns the XTEA block size, 8 bytes.\n-// It is necessary to satisfy the Block interface in the\n-// package \"crypto/cipher\".\n-func (c *Cipher) BlockSize() int { return BlockSize }\n-\n-// Encrypt encrypts the 8 byte buffer src using the key and stores the result in dst.\n-// Note that for amounts of data larger than a block,\n-// it is not safe to just call Encrypt on successive blocks;\n-// instead, use an encryption mode like CBC (see crypto/cipher/cbc.go).\n-func (c *Cipher) Encrypt(dst, src []byte) { encryptBlock(c, dst, src) }\n-\n-// Decrypt decrypts the 8 byte buffer src using the key k and stores the result in dst.\n-func (c *Cipher) Decrypt(dst, src []byte) { decryptBlock(c, dst, src) }\n-\n-// Reset zeros the table, so that it will no longer appear in the process's memory.\n-func (c *Cipher) Reset() {\n-\tfor i := 0; i < len(c.table); i++ {\n-\t\tc.table[i] = 0\n-\t}\n-}\n-\n-// initCipher initializes the cipher context by creating a look up table\n-// of precalculated values that are based on the key.\n-func initCipher(c *Cipher, key []byte) {\n-\t// Load the key into four uint32s\n-\tvar k [4]uint32\n-\tfor i := 0; i < len(k); i++ {\n-\t\tj := i << 2 // Multiply by 4\n-\t\tk[i] = uint32(key[j+0])<<24 | uint32(key[j+1])<<16 | uint32(key[j+2])<<8 | uint32(key[j+3])\n-\t}\n-\n-\t// Precalculate the table\n-\tconst delta = 0x9E3779B9\n-\tvar sum uint32 = 0\n-\n-\t// Two rounds of XTEA applied per loop\n-\tfor i := 0; i < numRounds; {\n-\t\tc.table[i] = sum + k[sum&3]\n-\t\ti++\n-\t\tsum += delta\n-\t\tc.table[i] = sum + k[(sum>>11)&3]\n-\t\ti++\n-\t}\n-}"}, {"sha": "217d96adc2099756981bbfc75a306b8a54144d30", "filename": "libgo/go/crypto/xtea/xtea_test.go", "status": "removed", "additions": 0, "deletions": 246, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fxtea%2Fxtea_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fcrypto%2Fxtea%2Fxtea_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fxtea%2Fxtea_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,246 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package xtea\n-\n-import (\n-\t\"testing\"\n-)\n-\n-// A sample test key for when we just want to initialize a cipher\n-var testKey = []byte{0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF}\n-\n-// Test that the block size for XTEA is correct\n-func TestBlocksize(t *testing.T) {\n-\tif BlockSize != 8 {\n-\t\tt.Errorf(\"BlockSize constant - expected 8, got %d\", BlockSize)\n-\t\treturn\n-\t}\n-\n-\tc, err := NewCipher(testKey)\n-\tif err != nil {\n-\t\tt.Errorf(\"NewCipher(%d bytes) = %s\", len(testKey), err)\n-\t\treturn\n-\t}\n-\n-\tresult := c.BlockSize()\n-\tif result != 8 {\n-\t\tt.Errorf(\"BlockSize function - expected 8, got %d\", result)\n-\t\treturn\n-\t}\n-}\n-\n-// A series of test values to confirm that the Cipher.table array was initialized correctly\n-var testTable = []uint32{\n-\t0x00112233, 0x6B1568B8, 0xE28CE030, 0xC5089E2D, 0xC5089E2D, 0x1EFBD3A2, 0xA7845C2A, 0x78EF0917,\n-\t0x78EF0917, 0x172682D0, 0x5B6AC714, 0x822AC955, 0x3DE68511, 0xDC1DFECA, 0x2062430E, 0x3611343F,\n-\t0xF1CCEFFB, 0x900469B4, 0xD448ADF8, 0x2E3BE36D, 0xB6C46BF5, 0x994029F2, 0x994029F2, 0xF3335F67,\n-\t0x6AAAD6DF, 0x4D2694DC, 0x4D2694DC, 0xEB5E0E95, 0x2FA252D9, 0x4551440A, 0x121E10D6, 0xB0558A8F,\n-\t0xE388BDC3, 0x0A48C004, 0xC6047BC0, 0x643BF579, 0xA88039BD, 0x02736F32, 0x8AFBF7BA, 0x5C66A4A7,\n-\t0x5C66A4A7, 0xC76AEB2C, 0x3EE262A4, 0x215E20A1, 0x215E20A1, 0x7B515616, 0x03D9DE9E, 0x1988CFCF,\n-\t0xD5448B8B, 0x737C0544, 0xB7C04988, 0xDE804BC9, 0x9A3C0785, 0x3873813E, 0x7CB7C582, 0xD6AAFAF7,\n-\t0x4E22726F, 0x309E306C, 0x309E306C, 0x8A9165E1, 0x1319EE69, 0xF595AC66, 0xF595AC66, 0x4F88E1DB,\n-}\n-\n-// Test that the cipher context is initialized correctly\n-func TestCipherInit(t *testing.T) {\n-\tc, err := NewCipher(testKey)\n-\tif err != nil {\n-\t\tt.Errorf(\"NewCipher(%d bytes) = %s\", len(testKey), err)\n-\t\treturn\n-\t}\n-\n-\tfor i := 0; i < len(c.table); i++ {\n-\t\tif c.table[i] != testTable[i] {\n-\t\t\tt.Errorf(\"NewCipher() failed to initialize Cipher.table[%d] correctly. Expected %08X, got %08X\", i, testTable[i], c.table[i])\n-\t\t\tbreak\n-\t\t}\n-\t}\n-}\n-\n-// Test that invalid key sizes return an error\n-func TestInvalidKeySize(t *testing.T) {\n-\t// Test a long key\n-\tkey := []byte{\n-\t\t0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,\n-\t\t0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,\n-\t}\n-\n-\t_, err := NewCipher(key)\n-\tif err == nil {\n-\t\tt.Errorf(\"Invalid key size %d didn't result in an error.\", len(key))\n-\t}\n-\n-\t// Test a short key\n-\tkey = []byte{0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77}\n-\n-\t_, err = NewCipher(key)\n-\tif err == nil {\n-\t\tt.Errorf(\"Invalid key size %d didn't result in an error.\", len(key))\n-\t}\n-}\n-\n-// Test that we can correctly decode some bytes we have encoded\n-func TestEncodeDecode(t *testing.T) {\n-\toriginal := []byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF}\n-\tinput := original\n-\toutput := make([]byte, BlockSize)\n-\n-\tc, err := NewCipher(testKey)\n-\tif err != nil {\n-\t\tt.Errorf(\"NewCipher(%d bytes) = %s\", len(testKey), err)\n-\t\treturn\n-\t}\n-\n-\t// Encrypt the input block\n-\tc.Encrypt(output, input)\n-\n-\t// Check that the output does not match the input\n-\tdiffers := false\n-\tfor i := 0; i < len(input); i++ {\n-\t\tif output[i] != input[i] {\n-\t\t\tdiffers = true\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tif differs == false {\n-\t\tt.Error(\"Cipher.Encrypt: Failed to encrypt the input block.\")\n-\t\treturn\n-\t}\n-\n-\t// Decrypt the block we just encrypted\n-\tinput = output\n-\toutput = make([]byte, BlockSize)\n-\tc.Decrypt(output, input)\n-\n-\t// Check that the output from decrypt matches our initial input\n-\tfor i := 0; i < len(input); i++ {\n-\t\tif output[i] != original[i] {\n-\t\t\tt.Errorf(\"Decrypted byte %d differed. Expected %02X, got %02X\\n\", i, original[i], output[i])\n-\t\t\treturn\n-\t\t}\n-\t}\n-}\n-\n-// Test Vectors\n-type CryptTest struct {\n-\tkey        []byte\n-\tplainText  []byte\n-\tcipherText []byte\n-}\n-\n-var CryptTests = []CryptTest{\n-\t// These were sourced from http://www.freemedialibrary.com/index.php/XTEA_test_vectors\n-\t{\n-\t\t[]byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f},\n-\t\t[]byte{0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48},\n-\t\t[]byte{0x49, 0x7d, 0xf3, 0xd0, 0x72, 0x61, 0x2c, 0xb5},\n-\t},\n-\t{\n-\t\t[]byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f},\n-\t\t[]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41},\n-\t\t[]byte{0xe7, 0x8f, 0x2d, 0x13, 0x74, 0x43, 0x41, 0xd8},\n-\t},\n-\t{\n-\t\t[]byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f},\n-\t\t[]byte{0x5a, 0x5b, 0x6e, 0x27, 0x89, 0x48, 0xd7, 0x7f},\n-\t\t[]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41},\n-\t},\n-\t{\n-\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n-\t\t[]byte{0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48},\n-\t\t[]byte{0xa0, 0x39, 0x05, 0x89, 0xf8, 0xb8, 0xef, 0xa5},\n-\t},\n-\t{\n-\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n-\t\t[]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41},\n-\t\t[]byte{0xed, 0x23, 0x37, 0x5a, 0x82, 0x1a, 0x8c, 0x2d},\n-\t},\n-\t{\n-\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n-\t\t[]byte{0x70, 0xe1, 0x22, 0x5d, 0x6e, 0x4e, 0x76, 0x55},\n-\t\t[]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41},\n-\t},\n-\n-\t// These vectors are from http://wiki.secondlife.com/wiki/XTEA_Strong_Encryption_Implementation#Bouncy_Castle_C.23_API\n-\t{\n-\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n-\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n-\t\t[]byte{0xDE, 0xE9, 0xD4, 0xD8, 0xF7, 0x13, 0x1E, 0xD9},\n-\t},\n-\t{\n-\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n-\t\t[]byte{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08},\n-\t\t[]byte{0x06, 0x5C, 0x1B, 0x89, 0x75, 0xC6, 0xA8, 0x16},\n-\t},\n-\t{\n-\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x12, 0x34, 0x56, 0x78, 0x23, 0x45, 0x67, 0x89, 0x34, 0x56, 0x78, 0x9A},\n-\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n-\t\t[]byte{0x1F, 0xF9, 0xA0, 0x26, 0x1A, 0xC6, 0x42, 0x64},\n-\t},\n-\t{\n-\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x12, 0x34, 0x56, 0x78, 0x23, 0x45, 0x67, 0x89, 0x34, 0x56, 0x78, 0x9A},\n-\t\t[]byte{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08},\n-\t\t[]byte{0x8C, 0x67, 0x15, 0x5B, 0x2E, 0xF9, 0x1E, 0xAD},\n-\t},\n-}\n-\n-// Test encryption\n-func TestCipherEncrypt(t *testing.T) {\n-\tfor i, tt := range CryptTests {\n-\t\tc, err := NewCipher(tt.key)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"NewCipher(%d bytes), vector %d = %s\", len(tt.key), i, err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tout := make([]byte, len(tt.plainText))\n-\t\tc.Encrypt(out, tt.plainText)\n-\n-\t\tfor j := 0; j < len(out); j++ {\n-\t\t\tif out[j] != tt.cipherText[j] {\n-\t\t\t\tt.Errorf(\"Cipher.Encrypt %d: out[%d] = %02X, expected %02X\", i, j, out[j], tt.cipherText[j])\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-// Test decryption\n-func TestCipherDecrypt(t *testing.T) {\n-\tfor i, tt := range CryptTests {\n-\t\tc, err := NewCipher(tt.key)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"NewCipher(%d bytes), vector %d = %s\", len(tt.key), i, err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tout := make([]byte, len(tt.cipherText))\n-\t\tc.Decrypt(out, tt.cipherText)\n-\n-\t\tfor j := 0; j < len(out); j++ {\n-\t\t\tif out[j] != tt.plainText[j] {\n-\t\t\t\tt.Errorf(\"Cipher.Decrypt %d: out[%d] = %02X, expected %02X\", i, j, out[j], tt.plainText[j])\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-// Test resetting the cipher context\n-func TestReset(t *testing.T) {\n-\tc, err := NewCipher(testKey)\n-\tif err != nil {\n-\t\tt.Errorf(\"NewCipher(%d bytes) = %s\", len(testKey), err)\n-\t\treturn\n-\t}\n-\n-\tc.Reset()\n-\tfor i := 0; i < len(c.table); i++ {\n-\t\tif c.table[i] != 0 {\n-\t\t\tt.Errorf(\"Cipher.Reset: Failed to clear Cipher.table[%d]. expected 0, got %08X\", i, c.table[i])\n-\t\t\treturn\n-\t\t}\n-\t}\n-}"}, {"sha": "e80420e5bb3aa1726f2f031161e18865a16ca123", "filename": "libgo/go/database/sql/convert.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -40,6 +40,9 @@ func convertAssign(dest, src interface{}) error {\n \t\tcase *string:\n \t\t\t*d = s\n \t\t\treturn nil\n+\t\tcase *[]byte:\n+\t\t\t*d = []byte(s)\n+\t\t\treturn nil\n \t\t}\n \tcase []byte:\n \t\tswitch d := dest.(type) {\n@@ -50,6 +53,12 @@ func convertAssign(dest, src interface{}) error {\n \t\t\t*d = s\n \t\t\treturn nil\n \t\t}\n+\tcase nil:\n+\t\tswitch d := dest.(type) {\n+\t\tcase *[]byte:\n+\t\t\t*d = nil\n+\t\t\treturn nil\n+\t\t}\n \t}\n \n \tvar sv reflect.Value"}, {"sha": "df25023e1273f9397ea5522ce2629991592b504c", "filename": "libgo/go/database/sql/fakedb_test.go", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -585,12 +585,26 @@ func converterForType(typ string) driver.ValueConverter {\n \tswitch typ {\n \tcase \"bool\":\n \t\treturn driver.Bool\n+\tcase \"nullbool\":\n+\t\treturn driver.Null{driver.Bool}\n \tcase \"int32\":\n \t\treturn driver.Int32\n \tcase \"string\":\n \t\treturn driver.NotNull{driver.String}\n \tcase \"nullstring\":\n \t\treturn driver.Null{driver.String}\n+\tcase \"int64\":\n+\t\t// TODO(coopernurse): add type-specific converter\n+\t\treturn driver.NotNull{driver.DefaultParameterConverter}\n+\tcase \"nullint64\":\n+\t\t// TODO(coopernurse): add type-specific converter\n+\t\treturn driver.Null{driver.DefaultParameterConverter}\n+\tcase \"float64\":\n+\t\t// TODO(coopernurse): add type-specific converter\n+\t\treturn driver.NotNull{driver.DefaultParameterConverter}\n+\tcase \"nullfloat64\":\n+\t\t// TODO(coopernurse): add type-specific converter\n+\t\treturn driver.Null{driver.DefaultParameterConverter}\n \tcase \"datetime\":\n \t\treturn driver.DefaultParameterConverter\n \t}"}, {"sha": "34a76521050d7600b8f401839a761041eed10b71", "filename": "libgo/go/database/sql/sql.go", "status": "modified", "additions": 101, "deletions": 19, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -47,7 +47,6 @@ type RawBytes []byte\n //     // NULL value\n //  }\n //\n-// TODO(bradfitz): add other types.\n type NullString struct {\n \tString string\n \tValid  bool // Valid is true if String is not NULL\n@@ -71,6 +70,84 @@ func (ns NullString) SubsetValue() (interface{}, error) {\n \treturn ns.String, nil\n }\n \n+// NullInt64 represents an int64 that may be null.\n+// NullInt64 implements the ScannerInto interface so\n+// it can be used as a scan destination, similar to NullString.\n+type NullInt64 struct {\n+\tInt64 int64\n+\tValid bool // Valid is true if Int64 is not NULL\n+}\n+\n+// ScanInto implements the ScannerInto interface.\n+func (n *NullInt64) ScanInto(value interface{}) error {\n+\tif value == nil {\n+\t\tn.Int64, n.Valid = 0, false\n+\t\treturn nil\n+\t}\n+\tn.Valid = true\n+\treturn convertAssign(&n.Int64, value)\n+}\n+\n+// SubsetValue implements the driver SubsetValuer interface.\n+func (n NullInt64) SubsetValue() (interface{}, error) {\n+\tif !n.Valid {\n+\t\treturn nil, nil\n+\t}\n+\treturn n.Int64, nil\n+}\n+\n+// NullFloat64 represents a float64 that may be null.\n+// NullFloat64 implements the ScannerInto interface so\n+// it can be used as a scan destination, similar to NullString.\n+type NullFloat64 struct {\n+\tFloat64 float64\n+\tValid   bool // Valid is true if Float64 is not NULL\n+}\n+\n+// ScanInto implements the ScannerInto interface.\n+func (n *NullFloat64) ScanInto(value interface{}) error {\n+\tif value == nil {\n+\t\tn.Float64, n.Valid = 0, false\n+\t\treturn nil\n+\t}\n+\tn.Valid = true\n+\treturn convertAssign(&n.Float64, value)\n+}\n+\n+// SubsetValue implements the driver SubsetValuer interface.\n+func (n NullFloat64) SubsetValue() (interface{}, error) {\n+\tif !n.Valid {\n+\t\treturn nil, nil\n+\t}\n+\treturn n.Float64, nil\n+}\n+\n+// NullBool represents a bool that may be null.\n+// NullBool implements the ScannerInto interface so\n+// it can be used as a scan destination, similar to NullString.\n+type NullBool struct {\n+\tBool  bool\n+\tValid bool // Valid is true if Bool is not NULL\n+}\n+\n+// ScanInto implements the ScannerInto interface.\n+func (n *NullBool) ScanInto(value interface{}) error {\n+\tif value == nil {\n+\t\tn.Bool, n.Valid = false, false\n+\t\treturn nil\n+\t}\n+\tn.Valid = true\n+\treturn convertAssign(&n.Bool, value)\n+}\n+\n+// SubsetValue implements the driver SubsetValuer interface.\n+func (n NullBool) SubsetValue() (interface{}, error) {\n+\tif !n.Valid {\n+\t\treturn nil, nil\n+\t}\n+\treturn n.Bool, nil\n+}\n+\n // ScannerInto is an interface used by Scan.\n type ScannerInto interface {\n \t// ScanInto assigns a value from a database driver.\n@@ -479,8 +556,11 @@ func (tx *Tx) Query(query string, args ...interface{}) (*Rows, error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tdefer stmt.Close()\n-\treturn stmt.Query(args...)\n+\trows, err := stmt.Query(args...)\n+\tif err == nil {\n+\t\trows.closeStmt = stmt\n+\t}\n+\treturn rows, err\n }\n \n // QueryRow executes a query that is expected to return at most one row.\n@@ -824,6 +904,12 @@ func (rs *Rows) Scan(dest ...interface{}) error {\n \t\tif !ok {\n \t\t\tcontinue\n \t\t}\n+\t\tif *b == nil {\n+\t\t\t// If the []byte is now nil (for a NULL value),\n+\t\t\t// don't fall through to below which would\n+\t\t\t// turn it into a non-nil 0-length byte slice\n+\t\t\tcontinue\n+\t\t}\n \t\tif _, ok = dp.(*RawBytes); ok {\n \t\t\tcontinue\n \t\t}\n@@ -865,17 +951,10 @@ func (r *Row) Scan(dest ...interface{}) error {\n \tif r.err != nil {\n \t\treturn r.err\n \t}\n-\tdefer r.rows.Close()\n-\tif !r.rows.Next() {\n-\t\treturn ErrNoRows\n-\t}\n-\terr := r.rows.Scan(dest...)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n \n \t// TODO(bradfitz): for now we need to defensively clone all\n-\t// []byte that the driver returned, since we're about to close\n+\t// []byte that the driver returned (not permitting \n+\t// *RawBytes in Rows.Scan), since we're about to close\n \t// the Rows in our defer, when we return from this function.\n \t// the contract with the driver.Next(...) interface is that it\n \t// can return slices into read-only temporary memory that's\n@@ -890,14 +969,17 @@ func (r *Row) Scan(dest ...interface{}) error {\n \t\tif _, ok := dp.(*RawBytes); ok {\n \t\t\treturn errors.New(\"sql: RawBytes isn't allowed on Row.Scan\")\n \t\t}\n-\t\tb, ok := dp.(*[]byte)\n-\t\tif !ok {\n-\t\t\tcontinue\n-\t\t}\n-\t\tclone := make([]byte, len(*b))\n-\t\tcopy(clone, *b)\n-\t\t*b = clone\n \t}\n+\n+\tdefer r.rows.Close()\n+\tif !r.rows.Next() {\n+\t\treturn ErrNoRows\n+\t}\n+\terr := r.rows.Scan(dest...)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n \treturn nil\n }\n "}, {"sha": "c5cadad84999a18c5b5d48d971352d161652796e", "filename": "libgo/go/database/sql/sql_test.go", "status": "modified", "additions": 151, "deletions": 36, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -5,6 +5,7 @@\n package sql\n \n import (\n+\t\"fmt\"\n \t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n@@ -310,6 +311,40 @@ func TestTxStmt(t *testing.T) {\n \t}\n }\n \n+// Issue: http://golang.org/issue/2784\n+// This test didn't fail before because we got luckly with the fakedb driver.\n+// It was failing, and now not, in github.com/bradfitz/go-sql-test\n+func TestTxQuery(t *testing.T) {\n+\tdb := newTestDB(t, \"\")\n+\tdefer closeDB(t, db)\n+\texec(t, db, \"CREATE|t1|name=string,age=int32,dead=bool\")\n+\texec(t, db, \"INSERT|t1|name=Alice\")\n+\n+\ttx, err := db.Begin()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer tx.Rollback()\n+\n+\tr, err := tx.Query(\"SELECT|t1|name|\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tif !r.Next() {\n+\t\tif r.Err() != nil {\n+\t\t\tt.Fatal(r.Err())\n+\t\t}\n+\t\tt.Fatal(\"expected one row\")\n+\t}\n+\n+\tvar x string\n+\terr = r.Scan(&x)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}\n+\n // Tests fix for issue 2542, that we release a lock when querying on\n // a closed connection.\n func TestIssue2542Deadlock(t *testing.T) {\n@@ -323,6 +358,34 @@ func TestIssue2542Deadlock(t *testing.T) {\n \t}\n }\n \n+// Tests fix for issue 2788, that we bind nil to a []byte if the\n+// value in the column is sql null\n+func TestNullByteSlice(t *testing.T) {\n+\tdb := newTestDB(t, \"\")\n+\tdefer closeDB(t, db)\n+\texec(t, db, \"CREATE|t|id=int32,name=nullstring\")\n+\texec(t, db, \"INSERT|t|id=10,name=?\", nil)\n+\n+\tvar name []byte\n+\n+\terr := db.QueryRow(\"SELECT|t|name|id=?\", 10).Scan(&name)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif name != nil {\n+\t\tt.Fatalf(\"name []byte should be nil for null column value, got: %#v\", name)\n+\t}\n+\n+\texec(t, db, \"INSERT|t|id=11,name=?\", \"bob\")\n+\terr = db.QueryRow(\"SELECT|t|name|id=?\", 11).Scan(&name)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif string(name) != \"bob\" {\n+\t\tt.Fatalf(\"name []byte should be bob, got: %q\", string(name))\n+\t}\n+}\n+\n func TestQueryRowClosingStmt(t *testing.T) {\n \tdb := newTestDB(t, \"people\")\n \tdefer closeDB(t, db)\n@@ -341,64 +404,116 @@ func TestQueryRowClosingStmt(t *testing.T) {\n \t}\n }\n \n+type nullTestRow struct {\n+\tnullParam    interface{}\n+\tnotNullParam interface{}\n+\tscanNullVal  interface{}\n+}\n+\n+type nullTestSpec struct {\n+\tnullType    string\n+\tnotNullType string\n+\trows        [6]nullTestRow\n+}\n+\n func TestNullStringParam(t *testing.T) {\n+\tspec := nullTestSpec{\"nullstring\", \"string\", [6]nullTestRow{\n+\t\tnullTestRow{NullString{\"aqua\", true}, \"\", NullString{\"aqua\", true}},\n+\t\tnullTestRow{NullString{\"brown\", false}, \"\", NullString{\"\", false}},\n+\t\tnullTestRow{\"chartreuse\", \"\", NullString{\"chartreuse\", true}},\n+\t\tnullTestRow{NullString{\"darkred\", true}, \"\", NullString{\"darkred\", true}},\n+\t\tnullTestRow{NullString{\"eel\", false}, \"\", NullString{\"\", false}},\n+\t\tnullTestRow{\"foo\", NullString{\"black\", false}, nil},\n+\t}}\n+\tnullTestRun(t, spec)\n+}\n+\n+func TestNullInt64Param(t *testing.T) {\n+\tspec := nullTestSpec{\"nullint64\", \"int64\", [6]nullTestRow{\n+\t\tnullTestRow{NullInt64{31, true}, 1, NullInt64{31, true}},\n+\t\tnullTestRow{NullInt64{-22, false}, 1, NullInt64{0, false}},\n+\t\tnullTestRow{22, 1, NullInt64{22, true}},\n+\t\tnullTestRow{NullInt64{33, true}, 1, NullInt64{33, true}},\n+\t\tnullTestRow{NullInt64{222, false}, 1, NullInt64{0, false}},\n+\t\tnullTestRow{0, NullInt64{31, false}, nil},\n+\t}}\n+\tnullTestRun(t, spec)\n+}\n+\n+func TestNullFloat64Param(t *testing.T) {\n+\tspec := nullTestSpec{\"nullfloat64\", \"float64\", [6]nullTestRow{\n+\t\tnullTestRow{NullFloat64{31.2, true}, 1, NullFloat64{31.2, true}},\n+\t\tnullTestRow{NullFloat64{13.1, false}, 1, NullFloat64{0, false}},\n+\t\tnullTestRow{-22.9, 1, NullFloat64{-22.9, true}},\n+\t\tnullTestRow{NullFloat64{33.81, true}, 1, NullFloat64{33.81, true}},\n+\t\tnullTestRow{NullFloat64{222, false}, 1, NullFloat64{0, false}},\n+\t\tnullTestRow{10, NullFloat64{31.2, false}, nil},\n+\t}}\n+\tnullTestRun(t, spec)\n+}\n+\n+func TestNullBoolParam(t *testing.T) {\n+\tspec := nullTestSpec{\"nullbool\", \"bool\", [6]nullTestRow{\n+\t\tnullTestRow{NullBool{false, true}, true, NullBool{false, true}},\n+\t\tnullTestRow{NullBool{true, false}, false, NullBool{false, false}},\n+\t\tnullTestRow{true, true, NullBool{true, true}},\n+\t\tnullTestRow{NullBool{true, true}, false, NullBool{true, true}},\n+\t\tnullTestRow{NullBool{true, false}, true, NullBool{false, false}},\n+\t\tnullTestRow{true, NullBool{true, false}, nil},\n+\t}}\n+\tnullTestRun(t, spec)\n+}\n+\n+func nullTestRun(t *testing.T, spec nullTestSpec) {\n \tdb := newTestDB(t, \"\")\n \tdefer closeDB(t, db)\n-\texec(t, db, \"CREATE|t|id=int32,name=string,favcolor=nullstring\")\n+\texec(t, db, fmt.Sprintf(\"CREATE|t|id=int32,name=string,nullf=%s,notnullf=%s\", spec.nullType, spec.notNullType))\n \n \t// Inserts with db.Exec:\n-\texec(t, db, \"INSERT|t|id=?,name=?,favcolor=?\", 1, \"alice\", NullString{\"aqua\", true})\n-\texec(t, db, \"INSERT|t|id=?,name=?,favcolor=?\", 2, \"bob\", NullString{\"brown\", false})\n-\n-\t_, err := db.Exec(\"INSERT|t|id=?,name=?,favcolor=?\", 999, nil, nil)\n-\tif err == nil {\n-\t\t// TODO: this test fails, but it's just because\n-\t\t// fakeConn implements the optional Execer interface,\n-\t\t// so arguably this is the correct behavior.  But\n-\t\t// maybe I should flesh out the fakeConn.Exec\n-\t\t// implementation so this properly fails.\n-\t\t// t.Errorf(\"expected error inserting nil name with Exec\")\n-\t}\n+\texec(t, db, \"INSERT|t|id=?,name=?,nullf=?,notnullf=?\", 1, \"alice\", spec.rows[0].nullParam, spec.rows[0].notNullParam)\n+\texec(t, db, \"INSERT|t|id=?,name=?,nullf=?,notnullf=?\", 2, \"bob\", spec.rows[1].nullParam, spec.rows[1].notNullParam)\n \n \t// Inserts with a prepared statement:\n-\tstmt, err := db.Prepare(\"INSERT|t|id=?,name=?,favcolor=?\")\n+\tstmt, err := db.Prepare(\"INSERT|t|id=?,name=?,nullf=?,notnullf=?\")\n \tif err != nil {\n \t\tt.Fatalf(\"prepare: %v\", err)\n \t}\n-\tif _, err := stmt.Exec(3, \"chris\", \"chartreuse\"); err != nil {\n+\tif _, err := stmt.Exec(3, \"chris\", spec.rows[2].nullParam, spec.rows[2].notNullParam); err != nil {\n \t\tt.Errorf(\"exec insert chris: %v\", err)\n \t}\n-\tif _, err := stmt.Exec(4, \"dave\", NullString{\"darkred\", true}); err != nil {\n+\tif _, err := stmt.Exec(4, \"dave\", spec.rows[3].nullParam, spec.rows[3].notNullParam); err != nil {\n \t\tt.Errorf(\"exec insert dave: %v\", err)\n \t}\n-\tif _, err := stmt.Exec(5, \"eleanor\", NullString{\"eel\", false}); err != nil {\n-\t\tt.Errorf(\"exec insert dave: %v\", err)\n+\tif _, err := stmt.Exec(5, \"eleanor\", spec.rows[4].nullParam, spec.rows[4].notNullParam); err != nil {\n+\t\tt.Errorf(\"exec insert eleanor: %v\", err)\n \t}\n \n-\t// Can't put null name into non-nullstring column,\n-\tif _, err := stmt.Exec(5, NullString{\"\", false}, nil); err == nil {\n-\t\tt.Errorf(\"expected error inserting nil name with prepared statement Exec\")\n+\t// Can't put null val into non-null col\n+\tif _, err := stmt.Exec(6, \"bob\", spec.rows[5].nullParam, spec.rows[5].notNullParam); err == nil {\n+\t\tt.Errorf(\"expected error inserting nil val with prepared statement Exec\")\n \t}\n \n-\ttype nameColor struct {\n-\t\tname     string\n-\t\tfavColor NullString\n+\t_, err = db.Exec(\"INSERT|t|id=?,name=?,nullf=?\", 999, nil, nil)\n+\tif err == nil {\n+\t\t// TODO: this test fails, but it's just because\n+\t\t// fakeConn implements the optional Execer interface,\n+\t\t// so arguably this is the correct behavior.  But\n+\t\t// maybe I should flesh out the fakeConn.Exec\n+\t\t// implementation so this properly fails.\n+\t\t// t.Errorf(\"expected error inserting nil name with Exec\")\n \t}\n \n-\twantMap := map[int]nameColor{\n-\t\t1: nameColor{\"alice\", NullString{\"aqua\", true}},\n-\t\t2: nameColor{\"bob\", NullString{\"\", false}},\n-\t\t3: nameColor{\"chris\", NullString{\"chartreuse\", true}},\n-\t\t4: nameColor{\"dave\", NullString{\"darkred\", true}},\n-\t\t5: nameColor{\"eleanor\", NullString{\"\", false}},\n-\t}\n-\tfor id, want := range wantMap {\n-\t\tvar got nameColor\n-\t\tif err := db.QueryRow(\"SELECT|t|name,favcolor|id=?\", id).Scan(&got.name, &got.favColor); err != nil {\n+\tparamtype := reflect.TypeOf(spec.rows[0].nullParam)\n+\tbindVal := reflect.New(paramtype).Interface()\n+\n+\tfor i := 0; i < 5; i++ {\n+\t\tid := i + 1\n+\t\tif err := db.QueryRow(\"SELECT|t|nullf|id=?\", id).Scan(bindVal); err != nil {\n \t\t\tt.Errorf(\"id=%d Scan: %v\", id, err)\n \t\t}\n-\t\tif got != want {\n-\t\t\tt.Errorf(\"id=%d got %#v, want %#v\", id, got, want)\n+\t\tbindValDeref := reflect.ValueOf(bindVal).Elem().Interface()\n+\t\tif !reflect.DeepEqual(bindValDeref, spec.rows[i].scanNullVal) {\n+\t\t\tt.Errorf(\"id=%d got %#v, want %#v\", id, bindValDeref, spec.rows[i].scanNullVal)\n \t\t}\n \t}\n }"}, {"sha": "b756afdd0400cccbdd839c8907490c0e42befa98", "filename": "libgo/go/encoding/binary/varint.go", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -37,6 +37,7 @@ const (\n )\n \n // PutUvarint encodes a uint64 into buf and returns the number of bytes written.\n+// If the buffer is too small, PutUvarint will panic.\n func PutUvarint(buf []byte, x uint64) int {\n \ti := 0\n \tfor x >= 0x80 {\n@@ -73,6 +74,7 @@ func Uvarint(buf []byte) (uint64, int) {\n }\n \n // PutVarint encodes an int64 into buf and returns the number of bytes written.\n+// If the buffer is too small, PutVarint will panic.\n func PutVarint(buf []byte, x int64) int {\n \tux := uint64(x) << 1\n \tif x < 0 {\n@@ -98,14 +100,6 @@ func Varint(buf []byte) (int64, int) {\n \treturn x, n\n }\n \n-// WriteUvarint encodes x and writes the result to w.\n-func WriteUvarint(w io.Writer, x uint64) error {\n-\tvar buf [MaxVarintLen64]byte\n-\tn := PutUvarint(buf[:], x)\n-\t_, err := w.Write(buf[0:n])\n-\treturn err\n-}\n-\n var overflow = errors.New(\"binary: varint overflows a 64-bit integer\")\n \n // ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.\n@@ -129,15 +123,6 @@ func ReadUvarint(r io.ByteReader) (uint64, error) {\n \tpanic(\"unreachable\")\n }\n \n-// WriteVarint encodes x and writes the result to w.\n-func WriteVarint(w io.Writer, x int64) error {\n-\tux := uint64(x) << 1\n-\tif x < 0 {\n-\t\tux = ^ux\n-\t}\n-\treturn WriteUvarint(w, ux)\n-}\n-\n // ReadVarint reads an encoded unsigned integer from r and returns it as a uint64.\n func ReadVarint(r io.ByteReader) (int64, error) {\n \tux, err := ReadUvarint(r) // ok to continue in presence of error"}, {"sha": "9476bd5fb7a6d7ac69d905895a3fbaec81a02895", "filename": "libgo/go/encoding/binary/varint_test.go", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -25,25 +25,17 @@ func TestConstants(t *testing.T) {\n }\n \n func testVarint(t *testing.T, x int64) {\n-\tbuf1 := make([]byte, MaxVarintLen64)\n-\tn := PutVarint(buf1[:], x)\n-\ty, m := Varint(buf1[0:n])\n+\tbuf := make([]byte, MaxVarintLen64)\n+\tn := PutVarint(buf, x)\n+\ty, m := Varint(buf[0:n])\n \tif x != y {\n \t\tt.Errorf(\"Varint(%d): got %d\", x, y)\n \t}\n \tif n != m {\n \t\tt.Errorf(\"Varint(%d): got n = %d; want %d\", x, m, n)\n \t}\n \n-\tvar buf2 bytes.Buffer\n-\terr := WriteVarint(&buf2, x)\n-\tif err != nil {\n-\t\tt.Errorf(\"WriteVarint(%d): %s\", x, err)\n-\t}\n-\tif n != buf2.Len() {\n-\t\tt.Errorf(\"WriteVarint(%d): got n = %d; want %d\", x, buf2.Len(), n)\n-\t}\n-\ty, err = ReadVarint(&buf2)\n+\ty, err := ReadVarint(bytes.NewBuffer(buf))\n \tif err != nil {\n \t\tt.Errorf(\"ReadVarint(%d): %s\", x, err)\n \t}\n@@ -53,25 +45,17 @@ func testVarint(t *testing.T, x int64) {\n }\n \n func testUvarint(t *testing.T, x uint64) {\n-\tbuf1 := make([]byte, MaxVarintLen64)\n-\tn := PutUvarint(buf1[:], x)\n-\ty, m := Uvarint(buf1[0:n])\n+\tbuf := make([]byte, MaxVarintLen64)\n+\tn := PutUvarint(buf, x)\n+\ty, m := Uvarint(buf[0:n])\n \tif x != y {\n \t\tt.Errorf(\"Uvarint(%d): got %d\", x, y)\n \t}\n \tif n != m {\n \t\tt.Errorf(\"Uvarint(%d): got n = %d; want %d\", x, m, n)\n \t}\n \n-\tvar buf2 bytes.Buffer\n-\terr := WriteUvarint(&buf2, x)\n-\tif err != nil {\n-\t\tt.Errorf(\"WriteUvarint(%d): %s\", x, err)\n-\t}\n-\tif n != buf2.Len() {\n-\t\tt.Errorf(\"WriteUvarint(%d): got n = %d; want %d\", x, buf2.Len(), n)\n-\t}\n-\ty, err = ReadUvarint(&buf2)\n+\ty, err := ReadUvarint(bytes.NewBuffer(buf))\n \tif err != nil {\n \t\tt.Errorf(\"ReadUvarint(%d): %s\", x, err)\n \t}"}, {"sha": "d383213ce8734084ace0e94f13a117a754a256ea", "filename": "libgo/go/encoding/git85/git.go", "status": "removed", "additions": 0, "deletions": 276, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fencoding%2Fgit85%2Fgit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fencoding%2Fgit85%2Fgit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgit85%2Fgit.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,276 +0,0 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package git85 implements the radix 85 data encoding\n-// used in the Git version control system.\n-package git85\n-\n-import (\n-\t\"bytes\"\n-\t\"io\"\n-\t\"strconv\"\n-)\n-\n-type CorruptInputError int64\n-\n-func (e CorruptInputError) Error() string {\n-\treturn \"illegal git85 data at input byte \" + strconv.FormatInt(int64(e), 10)\n-}\n-\n-const encode = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~\"\n-\n-// The decodings are 1+ the actual value, so that the\n-// default zero value can be used to mean \"not valid\".\n-var decode = [256]uint8{\n-\t'0': 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n-\t'A': 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n-\t24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,\n-\t'a': 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\n-\t50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,\n-\t'!': 63,\n-\t'#': 64, 65, 66, 67,\n-\t'(': 68, 69, 70, 71,\n-\t'-': 72,\n-\t';': 73,\n-\t'<': 74, 75, 76, 77,\n-\t'@': 78,\n-\t'^': 79, 80, 81,\n-\t'{': 82, 83, 84, 85,\n-}\n-\n-// Encode encodes src into EncodedLen(len(src))\n-// bytes of dst.  As a convenience, it returns the number\n-// of bytes written to dst, but this value is always EncodedLen(len(src)).\n-// Encode implements the radix 85 encoding used in the\n-// Git version control tool.\n-//\n-// The encoding splits src into chunks of at most 52 bytes\n-// and encodes each chunk on its own line.\n-func Encode(dst, src []byte) int {\n-\tndst := 0\n-\tfor len(src) > 0 {\n-\t\tn := len(src)\n-\t\tif n > 52 {\n-\t\t\tn = 52\n-\t\t}\n-\t\tif n <= 27 {\n-\t\t\tdst[ndst] = byte('A' + n - 1)\n-\t\t} else {\n-\t\t\tdst[ndst] = byte('a' + n - 26 - 1)\n-\t\t}\n-\t\tndst++\n-\t\tfor i := 0; i < n; i += 4 {\n-\t\t\tvar v uint32\n-\t\t\tfor j := 0; j < 4 && i+j < n; j++ {\n-\t\t\t\tv |= uint32(src[i+j]) << uint(24-j*8)\n-\t\t\t}\n-\t\t\tfor j := 4; j >= 0; j-- {\n-\t\t\t\tdst[ndst+j] = encode[v%85]\n-\t\t\t\tv /= 85\n-\t\t\t}\n-\t\t\tndst += 5\n-\t\t}\n-\t\tdst[ndst] = '\\n'\n-\t\tndst++\n-\t\tsrc = src[n:]\n-\t}\n-\treturn ndst\n-}\n-\n-// EncodedLen returns the length of an encoding of n source bytes.\n-func EncodedLen(n int) int {\n-\tif n == 0 {\n-\t\treturn 0\n-\t}\n-\t// 5 bytes per 4 bytes of input, rounded up.\n-\t// 2 extra bytes for each line of 52 src bytes, rounded up.\n-\treturn (n+3)/4*5 + (n+51)/52*2\n-}\n-\n-var newline = []byte{'\\n'}\n-\n-// Decode decodes src into at most MaxDecodedLen(len(src))\n-// bytes, returning the actual number of bytes written to dst.\n-//\n-// If Decode encounters invalid input, it returns a CorruptInputError.\n-//\n-func Decode(dst, src []byte) (n int, err error) {\n-\tndst := 0\n-\tnsrc := 0\n-\tfor nsrc < len(src) {\n-\t\tvar l int\n-\t\tswitch ch := int(src[nsrc]); {\n-\t\tcase 'A' <= ch && ch <= 'Z':\n-\t\t\tl = ch - 'A' + 1\n-\t\tcase 'a' <= ch && ch <= 'z':\n-\t\t\tl = ch - 'a' + 26 + 1\n-\t\tdefault:\n-\t\t\treturn ndst, CorruptInputError(nsrc)\n-\t\t}\n-\t\tif nsrc+1+l > len(src) {\n-\t\t\treturn ndst, CorruptInputError(nsrc)\n-\t\t}\n-\t\tel := (l + 3) / 4 * 5 // encoded len\n-\t\tif nsrc+1+el+1 > len(src) || src[nsrc+1+el] != '\\n' {\n-\t\t\treturn ndst, CorruptInputError(nsrc)\n-\t\t}\n-\t\tline := src[nsrc+1 : nsrc+1+el]\n-\t\tfor i := 0; i < el; i += 5 {\n-\t\t\tvar v uint32\n-\t\t\tfor j := 0; j < 5; j++ {\n-\t\t\t\tch := decode[line[i+j]]\n-\t\t\t\tif ch == 0 {\n-\t\t\t\t\treturn ndst, CorruptInputError(nsrc + 1 + i + j)\n-\t\t\t\t}\n-\t\t\t\tv = v*85 + uint32(ch-1)\n-\t\t\t}\n-\t\t\tfor j := 0; j < 4; j++ {\n-\t\t\t\tdst[ndst] = byte(v >> 24)\n-\t\t\t\tv <<= 8\n-\t\t\t\tndst++\n-\t\t\t}\n-\t\t}\n-\t\t// Last fragment may have run too far (but there was room in dst).\n-\t\t// Back up.\n-\t\tif l%4 != 0 {\n-\t\t\tndst -= 4 - l%4\n-\t\t}\n-\t\tnsrc += 1 + el + 1\n-\t}\n-\treturn ndst, nil\n-}\n-\n-func MaxDecodedLen(n int) int { return n / 5 * 4 }\n-\n-// NewEncoder returns a new Git base85 stream encoder.  Data written to\n-// the returned writer will be encoded and then written to w.\n-// The Git encoding operates on 52-byte blocks; when finished\n-// writing, the caller must Close the returned encoder to flush any\n-// partially written blocks.\n-func NewEncoder(w io.Writer) io.WriteCloser { return &encoder{w: w} }\n-\n-type encoder struct {\n-\tw    io.Writer\n-\terr  error\n-\tbuf  [52]byte\n-\tnbuf int\n-\tout  [1024]byte\n-\tnout int\n-}\n-\n-func (e *encoder) Write(p []byte) (n int, err error) {\n-\tif e.err != nil {\n-\t\treturn 0, e.err\n-\t}\n-\n-\t// Leading fringe.\n-\tif e.nbuf > 0 {\n-\t\tvar i int\n-\t\tfor i = 0; i < len(p) && e.nbuf < 52; i++ {\n-\t\t\te.buf[e.nbuf] = p[i]\n-\t\t\te.nbuf++\n-\t\t}\n-\t\tn += i\n-\t\tp = p[i:]\n-\t\tif e.nbuf < 52 {\n-\t\t\treturn\n-\t\t}\n-\t\tnout := Encode(e.out[0:], e.buf[0:])\n-\t\tif _, e.err = e.w.Write(e.out[0:nout]); e.err != nil {\n-\t\t\treturn n, e.err\n-\t\t}\n-\t\te.nbuf = 0\n-\t}\n-\n-\t// Large interior chunks.\n-\tfor len(p) >= 52 {\n-\t\tnn := len(e.out) / (1 + 52/4*5 + 1) * 52\n-\t\tif nn > len(p) {\n-\t\t\tnn = len(p) / 52 * 52\n-\t\t}\n-\t\tif nn > 0 {\n-\t\t\tnout := Encode(e.out[0:], p[0:nn])\n-\t\t\tif _, e.err = e.w.Write(e.out[0:nout]); e.err != nil {\n-\t\t\t\treturn n, e.err\n-\t\t\t}\n-\t\t}\n-\t\tn += nn\n-\t\tp = p[nn:]\n-\t}\n-\n-\t// Trailing fringe.\n-\tfor i := 0; i < len(p); i++ {\n-\t\te.buf[i] = p[i]\n-\t}\n-\te.nbuf = len(p)\n-\tn += len(p)\n-\treturn\n-}\n-\n-func (e *encoder) Close() error {\n-\t// If there's anything left in the buffer, flush it out\n-\tif e.err == nil && e.nbuf > 0 {\n-\t\tnout := Encode(e.out[0:], e.buf[0:e.nbuf])\n-\t\te.nbuf = 0\n-\t\t_, e.err = e.w.Write(e.out[0:nout])\n-\t}\n-\treturn e.err\n-}\n-\n-// NewDecoder returns a new Git base85 stream decoder.\n-func NewDecoder(r io.Reader) io.Reader { return &decoder{r: r} }\n-\n-type decoder struct {\n-\tr       io.Reader\n-\terr     error\n-\treadErr error\n-\tbuf     [1024]byte\n-\tnbuf    int\n-\tout     []byte\n-\toutbuf  [1024]byte\n-\toff     int64\n-}\n-\n-func (d *decoder) Read(p []byte) (n int, err error) {\n-\tif len(p) == 0 {\n-\t\treturn 0, nil\n-\t}\n-\n-\tfor {\n-\t\t// Copy leftover output from last decode.\n-\t\tif len(d.out) > 0 {\n-\t\t\tn = copy(p, d.out)\n-\t\t\td.out = d.out[n:]\n-\t\t\treturn\n-\t\t}\n-\n-\t\t// Out of decoded output.  Check errors.\n-\t\tif d.err != nil {\n-\t\t\treturn 0, d.err\n-\t\t}\n-\t\tif d.readErr != nil {\n-\t\t\td.err = d.readErr\n-\t\t\treturn 0, d.err\n-\t\t}\n-\n-\t\t// Read and decode more input.\n-\t\tvar nn int\n-\t\tnn, d.readErr = d.r.Read(d.buf[d.nbuf:])\n-\t\td.nbuf += nn\n-\n-\t\t// Send complete lines to Decode.\n-\t\tnl := bytes.LastIndex(d.buf[0:d.nbuf], newline)\n-\t\tif nl < 0 {\n-\t\t\tcontinue\n-\t\t}\n-\t\tnn, d.err = Decode(d.outbuf[0:], d.buf[0:nl+1])\n-\t\tif e, ok := d.err.(CorruptInputError); ok {\n-\t\t\td.err = CorruptInputError(int64(e) + d.off)\n-\t\t}\n-\t\td.out = d.outbuf[0:nn]\n-\t\td.nbuf = copy(d.buf[0:], d.buf[nl+1:d.nbuf])\n-\t\td.off += int64(nl + 1)\n-\t}\n-\tpanic(\"unreachable\")\n-}"}, {"sha": "81f5b0e32993bde88ff5ae6d72dc2d2460a80925", "filename": "libgo/go/encoding/git85/git_test.go", "status": "removed", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fencoding%2Fgit85%2Fgit_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fencoding%2Fgit85%2Fgit_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgit85%2Fgit_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,194 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package git85\n-\n-import (\n-\t\"bytes\"\n-\t\"io\"\n-\t\"io/ioutil\"\n-\t\"testing\"\n-)\n-\n-type testpair struct {\n-\tdecoded, encoded string\n-}\n-\n-func testEqual(t *testing.T, msg string, args ...interface{}) bool {\n-\tif args[len(args)-2] != args[len(args)-1] {\n-\t\tt.Errorf(msg, args...)\n-\t\treturn false\n-\t}\n-\treturn true\n-}\n-\n-func TestGitTable(t *testing.T) {\n-\tvar saw [256]bool\n-\tfor i, c := range encode {\n-\t\tif decode[c] != uint8(i+1) {\n-\t\t\tt.Errorf(\"decode['%c'] = %d, want %d\", c, decode[c], i+1)\n-\t\t}\n-\t\tsaw[c] = true\n-\t}\n-\tfor i, b := range saw {\n-\t\tif !b && decode[i] != 0 {\n-\t\t\tt.Errorf(\"decode[%d] = %d, want 0\", i, decode[i])\n-\t\t}\n-\t}\n-}\n-\n-var gitPairs = []testpair{\n-\t// Wikipedia example, adapted.\n-\t{\n-\t\t\"Man is distinguished, not only by his reason, but by this singular passion from \" +\n-\t\t\t\"other animals, which is a lust of the mind, that by a perseverance of delight in \" +\n-\t\t\t\"the continued and indefatigable generation of knowledge, exceeds the short \" +\n-\t\t\t\"vehemence of any carnal pleasure.\",\n-\n-\t\t\"zO<`^zX>%ZCX>)XGZfA9Ab7*B`EFf-gbRchTY<VDJc_3(Mb0BhMVRLV8EFfZabRc4R\\n\" +\n-\t\t\t\"zAarPHb0BkRZfA9DVR9gFVRLh7Z*CxFa&K)QZ**v7av))DX>DO_b1WctXlY|;AZc?T\\n\" +\n-\t\t\t\"zVIXXEb95kYW*~HEWgu;7Ze%PVbZB98AYyqSVIXj2a&u*NWpZI|V`U(3W*}r`Y-wj`\\n\" +\n-\t\t\t\"zbRcPNAarPDAY*TCbZKsNWn>^>Ze$>7Ze(R<VRUI{VPb4$AZKN6WpZJ3X>V>IZ)PBC\\n\" +\n-\t\t\t\"zZf|#NWn^b%EFfigV`XJzb0BnRWgv5CZ*p`Xc4cT~ZDnp_Wgu^6AYpEKAY);2ZeeU7\\n\" +\n-\t\t\t\"IaBO8^b9HiME&u=k\\n\",\n-\t},\n-}\n-\n-var gitBigtest = gitPairs[len(gitPairs)-1]\n-\n-func TestEncode(t *testing.T) {\n-\tfor _, p := range gitPairs {\n-\t\tbuf := make([]byte, EncodedLen(len(p.decoded)))\n-\t\tn := Encode(buf, []byte(p.decoded))\n-\t\tif n != len(buf) {\n-\t\t\tt.Errorf(\"EncodedLen does not agree with Encode\")\n-\t\t}\n-\t\tbuf = buf[0:n]\n-\t\ttestEqual(t, \"Encode(%q) = %q, want %q\", p.decoded, string(buf), p.encoded)\n-\t}\n-}\n-\n-func TestEncoder(t *testing.T) {\n-\tfor _, p := range gitPairs {\n-\t\tbb := &bytes.Buffer{}\n-\t\tencoder := NewEncoder(bb)\n-\t\tencoder.Write([]byte(p.decoded))\n-\t\tencoder.Close()\n-\t\ttestEqual(t, \"Encode(%q) = %q, want %q\", p.decoded, bb.String(), p.encoded)\n-\t}\n-}\n-\n-func TestEncoderBuffering(t *testing.T) {\n-\tinput := []byte(gitBigtest.decoded)\n-\tfor bs := 1; bs <= 12; bs++ {\n-\t\tbb := &bytes.Buffer{}\n-\t\tencoder := NewEncoder(bb)\n-\t\tfor pos := 0; pos < len(input); pos += bs {\n-\t\t\tend := pos + bs\n-\t\t\tif end > len(input) {\n-\t\t\t\tend = len(input)\n-\t\t\t}\n-\t\t\tn, err := encoder.Write(input[pos:end])\n-\t\t\ttestEqual(t, \"Write(%q) gave error %v, want %v\", input[pos:end], err, error(nil))\n-\t\t\ttestEqual(t, \"Write(%q) gave length %v, want %v\", input[pos:end], n, end-pos)\n-\t\t}\n-\t\terr := encoder.Close()\n-\t\ttestEqual(t, \"Close gave error %v, want %v\", err, error(nil))\n-\t\ttestEqual(t, \"Encoding/%d of %q = %q, want %q\", bs, gitBigtest.decoded, bb.String(), gitBigtest.encoded)\n-\t}\n-}\n-\n-func TestDecode(t *testing.T) {\n-\tfor _, p := range gitPairs {\n-\t\tdbuf := make([]byte, 4*len(p.encoded))\n-\t\tndst, err := Decode(dbuf, []byte(p.encoded))\n-\t\ttestEqual(t, \"Decode(%q) = error %v, want %v\", p.encoded, err, error(nil))\n-\t\ttestEqual(t, \"Decode(%q) = ndst %v, want %v\", p.encoded, ndst, len(p.decoded))\n-\t\ttestEqual(t, \"Decode(%q) = %q, want %q\", p.encoded, string(dbuf[0:ndst]), p.decoded)\n-\t}\n-}\n-\n-func TestDecoder(t *testing.T) {\n-\tfor _, p := range gitPairs {\n-\t\tdecoder := NewDecoder(bytes.NewBufferString(p.encoded))\n-\t\tdbuf, err := ioutil.ReadAll(decoder)\n-\t\tif err != nil {\n-\t\t\tt.Fatal(\"Read failed\", err)\n-\t\t}\n-\t\ttestEqual(t, \"Read from %q = length %v, want %v\", p.encoded, len(dbuf), len(p.decoded))\n-\t\ttestEqual(t, \"Decoding of %q = %q, want %q\", p.encoded, string(dbuf), p.decoded)\n-\t\tif err != nil {\n-\t\t\ttestEqual(t, \"Read from %q = %v, want %v\", p.encoded, err, io.EOF)\n-\t\t}\n-\t}\n-}\n-\n-func TestDecoderBuffering(t *testing.T) {\n-\tfor bs := 1; bs <= 12; bs++ {\n-\t\tdecoder := NewDecoder(bytes.NewBufferString(gitBigtest.encoded))\n-\t\tbuf := make([]byte, len(gitBigtest.decoded)+12)\n-\t\tvar total int\n-\t\tfor total = 0; total < len(gitBigtest.decoded); {\n-\t\t\tn, err := decoder.Read(buf[total : total+bs])\n-\t\t\ttestEqual(t, \"Read from %q at pos %d = %d, %v, want _, %v\", gitBigtest.encoded, total, n, err, error(nil))\n-\t\t\ttotal += n\n-\t\t}\n-\t\ttestEqual(t, \"Decoding/%d of %q = %q, want %q\", bs, gitBigtest.encoded, string(buf[0:total]), gitBigtest.decoded)\n-\t}\n-}\n-\n-func TestDecodeCorrupt(t *testing.T) {\n-\ttype corrupt struct {\n-\t\te string\n-\t\tp int\n-\t}\n-\texamples := []corrupt{\n-\t\t{\"v\", 0},\n-\t\t{\"!z!!!!!!!!!\", 0},\n-\t}\n-\n-\tfor _, e := range examples {\n-\t\tdbuf := make([]byte, 2*len(e.e))\n-\t\t_, err := Decode(dbuf, []byte(e.e))\n-\t\tswitch err := err.(type) {\n-\t\tcase CorruptInputError:\n-\t\t\ttestEqual(t, \"Corruption in %q at offset %v, want %v\", e.e, int(err), e.p)\n-\t\tdefault:\n-\t\t\tt.Error(\"Decoder failed to detect corruption in\", e)\n-\t\t}\n-\t}\n-}\n-\n-func TestGitBig(t *testing.T) {\n-\tn := 3*1000 + 1\n-\traw := make([]byte, n)\n-\tconst alpha = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n-\tfor i := 0; i < n; i++ {\n-\t\traw[i] = alpha[i%len(alpha)]\n-\t}\n-\tencoded := new(bytes.Buffer)\n-\tw := NewEncoder(encoded)\n-\tnn, err := w.Write(raw)\n-\tif nn != n || err != nil {\n-\t\tt.Fatalf(\"Encoder.Write(raw) = %d, %v want %d, nil\", nn, err, n)\n-\t}\n-\terr = w.Close()\n-\tif err != nil {\n-\t\tt.Fatalf(\"Encoder.Close() = %v want nil\", err)\n-\t}\n-\tdecoded, err := ioutil.ReadAll(NewDecoder(encoded))\n-\tif err != nil {\n-\t\tt.Fatalf(\"ioutil.ReadAll(NewDecoder(...)): %v\", err)\n-\t}\n-\n-\tif !bytes.Equal(raw, decoded) {\n-\t\tvar i int\n-\t\tfor i = 0; i < len(decoded) && i < len(raw); i++ {\n-\t\t\tif decoded[i] != raw[i] {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t\tt.Errorf(\"Decode(Encode(%d-byte string)) failed at offset %d\", n, i)\n-\t}\n-}"}, {"sha": "6dc7fc9aca0604d523ee262ce55328fe6004fad0", "filename": "libgo/go/encoding/gob/debug.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fgob%2Fdebug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fgob%2Fdebug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdebug.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -2,6 +2,9 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// Delete the next line to include this file in the gob package.\n+// +build ignore\n+\n package gob\n \n // This file is not normally included in the gob package.  Used only for debugging the package itself."}, {"sha": "fb28c8caf53561f24791fbef614e5d4a168d3947", "filename": "libgo/go/encoding/gob/decoder.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fgob%2Fdecoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fgob%2Fdecoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdecoder.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -75,7 +75,9 @@ func (dec *Decoder) recvMessage() bool {\n \t\tdec.err = err\n \t\treturn false\n \t}\n-\tif nbytes >= 1<<31 {\n+\t// Upper limit of 1GB, allowing room to grow a little without overflow.\n+\t// TODO: We might want more control over this limit.\n+\tif nbytes >= 1<<30 {\n \t\tdec.err = errBadCount\n \t\treturn false\n \t}"}, {"sha": "83644c0331b426437888e3579dba1e3a760fac57", "filename": "libgo/go/encoding/gob/gobencdec_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fgob%2Fgobencdec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fgob%2Fgobencdec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fgobencdec_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -547,7 +547,6 @@ func (a isZeroBugArray) GobEncode() (b []byte, e error) {\n }\n \n func (a *isZeroBugArray) GobDecode(data []byte) error {\n-\tprintln(\"DECODE\")\n \tif len(data) != len(a) {\n \t\treturn io.EOF\n \t}"}, {"sha": "7a05a1bb10e711696920b4095dde5cc08ae5a7c2", "filename": "libgo/go/encoding/xml/marshal.go", "status": "modified", "additions": 70, "deletions": 59, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -15,26 +15,13 @@ import (\n )\n \n const (\n-\t// A generic XML header suitable for use with the output of Marshal and\n-\t// MarshalIndent.  This is not automatically added to any output of this\n-\t// package, it is provided as a convenience.\n+\t// A generic XML header suitable for use with the output of Marshal.\n+\t// This is not automatically added to any output of this package,\n+\t// it is provided as a convenience.\n \tHeader = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>` + \"\\n\"\n )\n \n-// A Marshaler can produce well-formatted XML representing its internal state.\n-// It is used by both Marshal and MarshalIndent.\n-type Marshaler interface {\n-\tMarshalXML() ([]byte, error)\n-}\n-\n-type printer struct {\n-\t*bufio.Writer\n-}\n-\n-// Marshal writes an XML-formatted representation of v to w.\n-//\n-// If v implements Marshaler, then Marshal calls its MarshalXML method.\n-// Otherwise, Marshal uses the following procedure to create the XML.\n+// Marshal returns the XML encoding of v.\n //\n // Marshal handles an array or slice by marshalling each of the elements.\n // Marshal handles a pointer by marshalling the value it points at or, if the\n@@ -53,6 +40,7 @@ type printer struct {\n // The XML element for a struct contains marshalled elements for each of the\n // exported fields of the struct, with these exceptions:\n //     - the XMLName field, described above, is omitted.\n+//     - a field with tag \"-\" is omitted.\n //     - a field with tag \"name,attr\" becomes an attribute with\n //       the given name in the XML element.\n //     - a field with tag \",attr\" becomes an attribute with the\n@@ -77,7 +65,7 @@ type printer struct {\n //\t\tAge       int      `xml:\"person>age\"`\n //\t}\n //\n-//\txml.Marshal(w, &Result{Id: 13, FirstName: \"John\", LastName: \"Doe\", Age: 42})\n+//\txml.Marshal(&Result{Id: 13, FirstName: \"John\", LastName: \"Doe\", Age: 42})\n //\n // would be marshalled as:\n //\n@@ -92,13 +80,38 @@ type printer struct {\n //\t</result>\n //\n // Marshal will return an error if asked to marshal a channel, function, or map.\n-func Marshal(w io.Writer, v interface{}) (err error) {\n-\tp := &printer{bufio.NewWriter(w)}\n-\terr = p.marshalValue(reflect.ValueOf(v), nil)\n-\tp.Flush()\n+func Marshal(v interface{}) ([]byte, error) {\n+\tvar b bytes.Buffer\n+\tif err := NewEncoder(&b).Encode(v); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn b.Bytes(), nil\n+}\n+\n+// An Encoder writes XML data to an output stream.\n+type Encoder struct {\n+\tprinter\n+}\n+\n+// NewEncoder returns a new encoder that writes to w.\n+func NewEncoder(w io.Writer) *Encoder {\n+\treturn &Encoder{printer{bufio.NewWriter(w)}}\n+}\n+\n+// Encode writes the XML encoding of v to the stream.\n+//\n+// See the documentation for Marshal for details about the conversion\n+// of Go values to XML.\n+func (enc *Encoder) Encode(v interface{}) error {\n+\terr := enc.marshalValue(reflect.ValueOf(v), nil)\n+\tenc.Flush()\n \treturn err\n }\n \n+type printer struct {\n+\t*bufio.Writer\n+}\n+\n func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo) error {\n \tif !val.IsValid() {\n \t\treturn nil\n@@ -107,18 +120,6 @@ func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo) error {\n \tkind := val.Kind()\n \ttyp := val.Type()\n \n-\t// Try Marshaler\n-\tif typ.NumMethod() > 0 {\n-\t\tif marshaler, ok := val.Interface().(Marshaler); ok {\n-\t\t\tbytes, err := marshaler.MarshalXML()\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\tp.Write(bytes)\n-\t\t\treturn nil\n-\t\t}\n-\t}\n-\n \t// Drill into pointers/interfaces\n \tif kind == reflect.Ptr || kind == reflect.Interface {\n \t\tif val.IsNil() {\n@@ -181,30 +182,51 @@ func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo) error {\n \t\tif finfo.flags&fAttr == 0 {\n \t\t\tcontinue\n \t\t}\n-\t\tvar str string\n-\t\tif fv := val.FieldByIndex(finfo.idx); fv.Kind() == reflect.String {\n-\t\t\tstr = fv.String()\n-\t\t} else {\n-\t\t\tstr = fmt.Sprint(fv.Interface())\n+\t\tfv := val.FieldByIndex(finfo.idx)\n+\t\tswitch fv.Kind() {\n+\t\tcase reflect.String, reflect.Array, reflect.Slice:\n+\t\t\t// TODO: Should we really do this once ,omitempty is in?\n+\t\t\tif fv.Len() == 0 {\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t}\n-\t\tif str != \"\" {\n-\t\t\tp.WriteByte(' ')\n-\t\t\tp.WriteString(finfo.name)\n-\t\t\tp.WriteString(`=\"`)\n-\t\t\tEscape(p, []byte(str))\n-\t\t\tp.WriteByte('\"')\n+\t\tp.WriteByte(' ')\n+\t\tp.WriteString(finfo.name)\n+\t\tp.WriteString(`=\"`)\n+\t\tif err := p.marshalSimple(fv.Type(), fv); err != nil {\n+\t\t\treturn err\n \t\t}\n+\t\tp.WriteByte('\"')\n \t}\n \tp.WriteByte('>')\n \n-\tswitch k := val.Kind(); k {\n+\tif val.Kind() == reflect.Struct {\n+\t\terr = p.marshalStruct(tinfo, val)\n+\t} else {\n+\t\terr = p.marshalSimple(typ, val)\n+\t}\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tp.WriteByte('<')\n+\tp.WriteByte('/')\n+\tp.WriteString(name)\n+\tp.WriteByte('>')\n+\n+\treturn nil\n+}\n+\n+func (p *printer) marshalSimple(typ reflect.Type, val reflect.Value) error {\n+\tswitch val.Kind() {\n \tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n \t\tp.WriteString(strconv.FormatInt(val.Int(), 10))\n \tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n \t\tp.WriteString(strconv.FormatUint(val.Uint(), 10))\n \tcase reflect.Float32, reflect.Float64:\n \t\tp.WriteString(strconv.FormatFloat(val.Float(), 'g', -1, 64))\n \tcase reflect.String:\n+\t\t// TODO: Add EscapeString.\n \t\tEscape(p, []byte(val.String()))\n \tcase reflect.Bool:\n \t\tp.WriteString(strconv.FormatBool(val.Bool()))\n@@ -217,21 +239,10 @@ func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo) error {\n \t\tEscape(p, bytes)\n \tcase reflect.Slice:\n \t\t// will be []byte\n-\t\tbytes := val.Interface().([]byte)\n-\t\tEscape(p, bytes)\n-\tcase reflect.Struct:\n-\t\tif err := p.marshalStruct(tinfo, val); err != nil {\n-\t\t\treturn err\n-\t\t}\n+\t\tEscape(p, val.Bytes())\n \tdefault:\n \t\treturn &UnsupportedTypeError{typ}\n \t}\n-\n-\tp.WriteByte('<')\n-\tp.WriteByte('/')\n-\tp.WriteString(name)\n-\tp.WriteByte('>')\n-\n \treturn nil\n }\n \n@@ -358,7 +369,7 @@ func (s *parentStack) push(parents []string) {\n \ts.stack = append(s.stack, parents...)\n }\n \n-// A MarshalXMLError is returned when Marshal or MarshalIndent encounter a type\n+// A MarshalXMLError is returned when Marshal encounters a type\n // that cannot be converted into XML.\n type UnsupportedTypeError struct {\n \tType reflect.Type"}, {"sha": "e0be33200864e9af9ffcc346963057f644fd0b6d", "filename": "libgo/go/encoding/xml/marshal_test.go", "status": "modified", "additions": 76, "deletions": 26, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -5,7 +5,6 @@\n package xml\n \n import (\n-\t\"bytes\"\n \t\"reflect\"\n \t\"strconv\"\n \t\"strings\"\n@@ -35,12 +34,6 @@ type Ship struct {\n \tsecret    string\n }\n \n-type RawXML string\n-\n-func (rx RawXML) MarshalXML() ([]byte, error) {\n-\treturn []byte(rx), nil\n-}\n-\n type NamedType string\n \n type Port struct {\n@@ -184,6 +177,22 @@ type RecurseB struct {\n \tB string\n }\n \n+type PresenceTest struct {\n+\tExists *struct{}\n+}\n+\n+type IgnoreTest struct {\n+\tPublicSecret string `xml:\"-\"`\n+}\n+\n+type MyBytes []byte\n+\n+type Data struct {\n+\tBytes  []byte\n+\tAttr   []byte `xml:\",attr\"`\n+\tCustom MyBytes\n+}\n+\n type Plain struct {\n \tV interface{}\n }\n@@ -225,6 +234,44 @@ var marshalTests = []struct {\n \t{Value: &Plain{[]int{1, 2, 3}}, ExpectXML: `<Plain><V>1</V><V>2</V><V>3</V></Plain>`},\n \t{Value: &Plain{[3]int{1, 2, 3}}, ExpectXML: `<Plain><V>1</V><V>2</V><V>3</V></Plain>`},\n \n+\t// A pointer to struct{} may be used to test for an element's presence.\n+\t{\n+\t\tValue:     &PresenceTest{new(struct{})},\n+\t\tExpectXML: `<PresenceTest><Exists></Exists></PresenceTest>`,\n+\t},\n+\t{\n+\t\tValue:     &PresenceTest{},\n+\t\tExpectXML: `<PresenceTest></PresenceTest>`,\n+\t},\n+\n+\t// A pointer to struct{} may be used to test for an element's presence.\n+\t{\n+\t\tValue:     &PresenceTest{new(struct{})},\n+\t\tExpectXML: `<PresenceTest><Exists></Exists></PresenceTest>`,\n+\t},\n+\t{\n+\t\tValue:     &PresenceTest{},\n+\t\tExpectXML: `<PresenceTest></PresenceTest>`,\n+\t},\n+\n+\t// A []byte field is only nil if the element was not found.\n+\t{\n+\t\tValue:         &Data{},\n+\t\tExpectXML:     `<Data></Data>`,\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tValue:         &Data{Bytes: []byte{}, Custom: MyBytes{}, Attr: []byte{}},\n+\t\tExpectXML:     `<Data Attr=\"\"><Bytes></Bytes><Custom></Custom></Data>`,\n+\t\tUnmarshalOnly: true,\n+\t},\n+\n+\t// Check that []byte works, including named []byte types.\n+\t{\n+\t\tValue:     &Data{Bytes: []byte(\"ab\"), Custom: MyBytes(\"cd\"), Attr: []byte{'v'}},\n+\t\tExpectXML: `<Data Attr=\"v\"><Bytes>ab</Bytes><Custom>cd</Custom></Data>`,\n+\t},\n+\n \t// Test innerxml\n \t{\n \t\tValue: &SecretAgent{\n@@ -245,13 +292,6 @@ var marshalTests = []struct {\n \t\tUnmarshalOnly: true,\n \t},\n \n-\t// Test marshaller interface\n-\t{\n-\t\tValue:       RawXML(\"</>\"),\n-\t\tExpectXML:   `</>`,\n-\t\tMarshalOnly: true,\n-\t},\n-\n \t// Test structs\n \t{Value: &Port{Type: \"ssl\", Number: \"443\"}, ExpectXML: `<port type=\"ssl\">443</port>`},\n \t{Value: &Port{Number: \"443\"}, ExpectXML: `<port>443</port>`},\n@@ -542,20 +582,35 @@ var marshalTests = []struct {\n \t\t},\n \t\tExpectXML: `<RecurseA><A>a1</A><B><A><A>a2</A></A><B>b1</B></B></RecurseA>`,\n \t},\n+\n+\t// Test ignoring fields via \"-\" tag\n+\t{\n+\t\tExpectXML: `<IgnoreTest></IgnoreTest>`,\n+\t\tValue:     &IgnoreTest{},\n+\t},\n+\t{\n+\t\tExpectXML:   `<IgnoreTest></IgnoreTest>`,\n+\t\tValue:       &IgnoreTest{PublicSecret: \"can't tell\"},\n+\t\tMarshalOnly: true,\n+\t},\n+\t{\n+\t\tExpectXML:     `<IgnoreTest><PublicSecret>ignore me</PublicSecret></IgnoreTest>`,\n+\t\tValue:         &IgnoreTest{},\n+\t\tUnmarshalOnly: true,\n+\t},\n }\n \n func TestMarshal(t *testing.T) {\n \tfor idx, test := range marshalTests {\n \t\tif test.UnmarshalOnly {\n \t\t\tcontinue\n \t\t}\n-\t\tbuf := bytes.NewBuffer(nil)\n-\t\terr := Marshal(buf, test.Value)\n+\t\tdata, err := Marshal(test.Value)\n \t\tif err != nil {\n \t\t\tt.Errorf(\"#%d: Error: %s\", idx, err)\n \t\t\tcontinue\n \t\t}\n-\t\tif got, want := buf.String(), test.ExpectXML; got != want {\n+\t\tif got, want := string(data), test.ExpectXML; got != want {\n \t\t\tif strings.Contains(want, \"\\n\") {\n \t\t\t\tt.Errorf(\"#%d: marshal(%#v):\\nHAVE:\\n%s\\nWANT:\\n%s\", idx, test.Value, got, want)\n \t\t\t} else {\n@@ -596,8 +651,7 @@ var marshalErrorTests = []struct {\n \n func TestMarshalErrors(t *testing.T) {\n \tfor idx, test := range marshalErrorTests {\n-\t\tbuf := bytes.NewBuffer(nil)\n-\t\terr := Marshal(buf, test.Value)\n+\t\t_, err := Marshal(test.Value)\n \t\tif err == nil || err.Error() != test.Err {\n \t\t\tt.Errorf(\"#%d: marshal(%#v) = [error] %v, want %v\", idx, test.Value, err, test.Err)\n \t\t}\n@@ -621,8 +675,7 @@ func TestUnmarshal(t *testing.T) {\n \n \t\tvt := reflect.TypeOf(test.Value)\n \t\tdest := reflect.New(vt.Elem()).Interface()\n-\t\tbuffer := bytes.NewBufferString(test.ExpectXML)\n-\t\terr := Unmarshal(buffer, dest)\n+\t\terr := Unmarshal([]byte(test.ExpectXML), dest)\n \n \t\tswitch fix := dest.(type) {\n \t\tcase *Feed:\n@@ -641,17 +694,14 @@ func TestUnmarshal(t *testing.T) {\n }\n \n func BenchmarkMarshal(b *testing.B) {\n-\tbuf := bytes.NewBuffer(nil)\n \tfor i := 0; i < b.N; i++ {\n-\t\tMarshal(buf, atomValue)\n-\t\tbuf.Truncate(0)\n+\t\tMarshal(atomValue)\n \t}\n }\n \n func BenchmarkUnmarshal(b *testing.B) {\n \txml := []byte(atomXml)\n \tfor i := 0; i < b.N; i++ {\n-\t\tbuffer := bytes.NewBuffer(xml)\n-\t\tUnmarshal(buffer, &Feed{})\n+\t\tUnmarshal(xml, &Feed{})\n \t}\n }"}, {"sha": "871fe059cfa1880d0cf1790368b77048deb1bbff", "filename": "libgo/go/encoding/xml/read.go", "status": "modified", "additions": 39, "deletions": 41, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -7,7 +7,6 @@ package xml\n import (\n \t\"bytes\"\n \t\"errors\"\n-\t\"io\"\n \t\"reflect\"\n \t\"strconv\"\n \t\"strings\"\n@@ -20,10 +19,10 @@ import (\n // See package json for a textual representation more suitable\n // to data structures.\n \n-// Unmarshal parses an XML element from r and uses the\n-// reflect library to fill in an arbitrary struct, slice, or string\n-// pointed at by val.  Well-formed data that does not fit\n-// into val is discarded.\n+// Unmarshal parses the XML-encoded data and stores the result in\n+// the value pointed to by v, which must be an arbitrary struct,\n+// slice, or string. Well-formed data that does not fit into v is\n+// discarded.\n //\n // For example, given these definitions:\n //\n@@ -59,7 +58,7 @@ import (\n //\t\t<address>123 Main Street</address>\n //\t</result>\n //\n-// via Unmarshal(r, &result) is equivalent to assigning\n+// via Unmarshal(data, &result) is equivalent to assigning\n //\n //\tr = Result{\n //\t\txml.Name{Local: \"result\"},\n@@ -78,8 +77,9 @@ import (\n // field tag.\n //\n // Because Unmarshal uses the reflect package, it can only assign\n-// to exported (upper case) fields.  Unmarshal uses a case-insensitive\n-// comparison to match XML element names to struct field names.\n+// to exported (upper case) fields.  Unmarshal uses a case-sensitive\n+// comparison to match XML element names to tag values and struct\n+// field names.\n //\n // Unmarshal maps an XML element to a struct using the following rules.\n // In the rules, the tag of a field refers to the value associated with the\n@@ -132,9 +132,11 @@ import (\n //      of the above rules and the struct has a field with tag \",any\",\n //      unmarshal maps the sub-element to that struct field.\n //\n+//   * A struct field with tag \"-\" is never unmarshalled into.\n+//\n // Unmarshal maps an XML element to a string or []byte by saving the\n // concatenation of that element's character data in the string or\n-// []byte.\n+// []byte. The saved []byte is never nil.\n //\n // Unmarshal maps an attribute value to a string or []byte by saving\n // the value in the string or slice.\n@@ -156,41 +158,35 @@ import (\n // Unmarshal maps an XML element to a pointer by setting the pointer\n // to a freshly allocated value and then mapping the element to that value.\n //\n-func Unmarshal(r io.Reader, val interface{}) error {\n-\tv := reflect.ValueOf(val)\n-\tif v.Kind() != reflect.Ptr {\n+func Unmarshal(data []byte, v interface{}) error {\n+\treturn NewDecoder(bytes.NewBuffer(data)).Decode(v)\n+}\n+\n+// Decode works like xml.Unmarshal, except it reads the decoder\n+// stream to find the start element.\n+func (d *Decoder) Decode(v interface{}) error {\n+\treturn d.DecodeElement(v, nil)\n+}\n+\n+// DecodeElement works like xml.Unmarshal except that it takes\n+// a pointer to the start XML element to decode into v.\n+// It is useful when a client reads some raw XML tokens itself\n+// but also wants to defer to Unmarshal for some elements.\n+func (d *Decoder) DecodeElement(v interface{}, start *StartElement) error {\n+\tval := reflect.ValueOf(v)\n+\tif val.Kind() != reflect.Ptr {\n \t\treturn errors.New(\"non-pointer passed to Unmarshal\")\n \t}\n-\tp := NewParser(r)\n-\telem := v.Elem()\n-\terr := p.unmarshal(elem, nil)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n+\treturn d.unmarshal(val.Elem(), start)\n }\n \n // An UnmarshalError represents an error in the unmarshalling process.\n type UnmarshalError string\n \n func (e UnmarshalError) Error() string { return string(e) }\n \n-// The Parser's Unmarshal method is like xml.Unmarshal\n-// except that it can be passed a pointer to the initial start element,\n-// useful when a client reads some raw XML tokens itself\n-// but also defers to Unmarshal for some elements.\n-// Passing a nil start element indicates that Unmarshal should\n-// read the token stream to find the start element.\n-func (p *Parser) Unmarshal(val interface{}, start *StartElement) error {\n-\tv := reflect.ValueOf(val)\n-\tif v.Kind() != reflect.Ptr {\n-\t\treturn errors.New(\"non-pointer passed to Unmarshal\")\n-\t}\n-\treturn p.unmarshal(v.Elem(), start)\n-}\n-\n // Unmarshal a single XML element into val.\n-func (p *Parser) unmarshal(val reflect.Value, start *StartElement) error {\n+func (p *Decoder) unmarshal(val reflect.Value, start *StartElement) error {\n \t// Find start element if we need it.\n \tif start == nil {\n \t\tfor {\n@@ -309,14 +305,12 @@ func (p *Parser) unmarshal(val reflect.Value, start *StartElement) error {\n \t\t\tcase fAttr:\n \t\t\t\tstrv := sv.FieldByIndex(finfo.idx)\n \t\t\t\t// Look for attribute.\n-\t\t\t\tval := \"\"\n \t\t\t\tfor _, a := range start.Attr {\n \t\t\t\t\tif a.Name.Local == finfo.name {\n-\t\t\t\t\t\tval = a.Value\n+\t\t\t\t\t\tcopyValue(strv, []byte(a.Value))\n \t\t\t\t\t\tbreak\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tcopyValue(strv, []byte(val))\n \n \t\t\tcase fCharData:\n \t\t\t\tif !saveData.IsValid() {\n@@ -473,17 +467,21 @@ func copyValue(dst reflect.Value, src []byte) (err error) {\n \tcase reflect.String:\n \t\tt.SetString(string(src))\n \tcase reflect.Slice:\n-\t\tt.Set(reflect.ValueOf(src))\n+\t\tif len(src) == 0 {\n+\t\t\t// non-nil to flag presence\n+\t\t\tsrc = []byte{}\n+\t\t}\n+\t\tt.SetBytes(src)\n \t}\n \treturn nil\n }\n \n // unmarshalPath walks down an XML structure looking for wanted\n // paths, and calls unmarshal on them.\n // The consumed result tells whether XML elements have been consumed\n-// from the Parser until start's matching end element, or if it's\n+// from the Decoder until start's matching end element, or if it's\n // still untouched because start is uninteresting for sv's fields.\n-func (p *Parser) unmarshalPath(tinfo *typeInfo, sv reflect.Value, parents []string, start *StartElement) (consumed bool, err error) {\n+func (p *Decoder) unmarshalPath(tinfo *typeInfo, sv reflect.Value, parents []string, start *StartElement) (consumed bool, err error) {\n \trecurse := false\n Loop:\n \tfor i := range tinfo.fields {\n@@ -547,7 +545,7 @@ Loop:\n // Read tokens until we find the end element.\n // Token is taking care of making sure the\n // end element matches the start element we saw.\n-func (p *Parser) Skip() error {\n+func (p *Decoder) Skip() error {\n \tfor {\n \t\ttok, err := p.Token()\n \t\tif err != nil {"}, {"sha": "833eafc9a586909637a626eb902e0894e1ce589b", "filename": "libgo/go/encoding/xml/read_test.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fxml%2Fread_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fxml%2Fread_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fread_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -6,15 +6,14 @@ package xml\n \n import (\n \t\"reflect\"\n-\t\"strings\"\n \t\"testing\"\n )\n \n // Stripped down Atom feed data structures.\n \n func TestUnmarshalFeed(t *testing.T) {\n \tvar f Feed\n-\tif err := Unmarshal(strings.NewReader(atomFeedString), &f); err != nil {\n+\tif err := Unmarshal([]byte(atomFeedString), &f); err != nil {\n \t\tt.Fatalf(\"Unmarshal: %s\", err)\n \t}\n \tif !reflect.DeepEqual(f, atomFeed) {\n@@ -281,7 +280,7 @@ var pathTests = []interface{}{\n func TestUnmarshalPaths(t *testing.T) {\n \tfor _, pt := range pathTests {\n \t\tv := reflect.New(reflect.TypeOf(pt).Elem()).Interface()\n-\t\tif err := Unmarshal(strings.NewReader(pathTestString), v); err != nil {\n+\t\tif err := Unmarshal([]byte(pathTestString), v); err != nil {\n \t\t\tt.Fatalf(\"Unmarshal: %s\", err)\n \t\t}\n \t\tif !reflect.DeepEqual(v, pt) {\n@@ -331,7 +330,7 @@ var badPathTests = []struct {\n \n func TestUnmarshalBadPaths(t *testing.T) {\n \tfor _, tt := range badPathTests {\n-\t\terr := Unmarshal(strings.NewReader(pathTestString), tt.v)\n+\t\terr := Unmarshal([]byte(pathTestString), tt.v)\n \t\tif !reflect.DeepEqual(err, tt.e) {\n \t\t\tt.Fatalf(\"Unmarshal with %#v didn't fail properly:\\nhave %#v,\\nwant %#v\", tt.v, err, tt.e)\n \t\t}\n@@ -350,7 +349,7 @@ type TestThree struct {\n \n func TestUnmarshalWithoutNameType(t *testing.T) {\n \tvar x TestThree\n-\tif err := Unmarshal(strings.NewReader(withoutNameTypeData), &x); err != nil {\n+\tif err := Unmarshal([]byte(withoutNameTypeData), &x); err != nil {\n \t\tt.Fatalf(\"Unmarshal: %s\", err)\n \t}\n \tif x.Attr != OK {"}, {"sha": "2bf2c6b3032e98d580e7fabc62c6b6dc3f9db16d", "filename": "libgo/go/encoding/xml/typeinfo.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -37,7 +37,6 @@ const (\n \tfAny\n \n \t// TODO:\n-\t//fIgnore\n \t//fOmitEmpty\n \n \tfMode = fElement | fAttr | fCharData | fInnerXml | fComment | fAny\n@@ -62,7 +61,7 @@ func getTypeInfo(typ reflect.Type) (*typeInfo, error) {\n \t\tn := typ.NumField()\n \t\tfor i := 0; i < n; i++ {\n \t\t\tf := typ.Field(i)\n-\t\t\tif f.PkgPath != \"\" {\n+\t\t\tif f.PkgPath != \"\" || f.Tag.Get(\"xml\") == \"-\" {\n \t\t\t\tcontinue // Private field\n \t\t\t}\n "}, {"sha": "5066f5c01067f9bc69d324bc997644b5fd893e64", "filename": "libgo/go/encoding/xml/xml.go", "status": "modified", "additions": 241, "deletions": 241, "changes": 482, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -36,7 +36,7 @@ func (e *SyntaxError) Error() string {\n \n // A Name represents an XML name (Local) annotated\n // with a name space identifier (Space).\n-// In tokens returned by Parser.Token, the Space identifier\n+// In tokens returned by Decoder.Token, the Space identifier\n // is given as a canonical URL, not the short prefix used\n // in the document being parsed.\n type Name struct {\n@@ -124,9 +124,9 @@ func CopyToken(t Token) Token {\n \treturn t\n }\n \n-// A Parser represents an XML parser reading a particular input stream.\n+// A Decoder represents an XML parser reading a particular input stream.\n // The parser assumes that its input is encoded in UTF-8.\n-type Parser struct {\n+type Decoder struct {\n \t// Strict defaults to true, enforcing the requirements\n \t// of the XML specification.\n \t// If set to false, the parser allows input containing common\n@@ -139,9 +139,9 @@ type Parser struct {\n \t//\n \t// Setting:\n \t//\n-\t//\tp.Strict = false;\n-\t//\tp.AutoClose = HTMLAutoClose;\n-\t//\tp.Entity = HTMLEntity\n+\t//\td.Strict = false;\n+\t//\td.AutoClose = HTMLAutoClose;\n+\t//\td.Entity = HTMLEntity\n \t//\n \t// creates a parser that can handle typical HTML.\n \tStrict bool\n@@ -184,16 +184,16 @@ type Parser struct {\n \ttmp       [32]byte\n }\n \n-// NewParser creates a new XML parser reading from r.\n-func NewParser(r io.Reader) *Parser {\n-\tp := &Parser{\n+// NewDecoder creates a new XML parser reading from r.\n+func NewDecoder(r io.Reader) *Decoder {\n+\td := &Decoder{\n \t\tns:       make(map[string]string),\n \t\tnextByte: -1,\n \t\tline:     1,\n \t\tStrict:   true,\n \t}\n-\tp.switchToReader(r)\n-\treturn p\n+\td.switchToReader(r)\n+\treturn d\n }\n \n // Token returns the next XML token in the input stream.\n@@ -218,17 +218,17 @@ func NewParser(r io.Reader) *Parser {\n // set to the URL identifying its name space when known.\n // If Token encounters an unrecognized name space prefix,\n // it uses the prefix as the Space rather than report an error.\n-func (p *Parser) Token() (t Token, err error) {\n-\tif p.nextToken != nil {\n-\t\tt = p.nextToken\n-\t\tp.nextToken = nil\n-\t} else if t, err = p.RawToken(); err != nil {\n+func (d *Decoder) Token() (t Token, err error) {\n+\tif d.nextToken != nil {\n+\t\tt = d.nextToken\n+\t\td.nextToken = nil\n+\t} else if t, err = d.RawToken(); err != nil {\n \t\treturn\n \t}\n \n-\tif !p.Strict {\n-\t\tif t1, ok := p.autoClose(t); ok {\n-\t\t\tp.nextToken = t\n+\tif !d.Strict {\n+\t\tif t1, ok := d.autoClose(t); ok {\n+\t\t\td.nextToken = t\n \t\t\tt = t1\n \t\t}\n \t}\n@@ -240,29 +240,29 @@ func (p *Parser) Token() (t Token, err error) {\n \t\t// the translations first.\n \t\tfor _, a := range t1.Attr {\n \t\t\tif a.Name.Space == \"xmlns\" {\n-\t\t\t\tv, ok := p.ns[a.Name.Local]\n-\t\t\t\tp.pushNs(a.Name.Local, v, ok)\n-\t\t\t\tp.ns[a.Name.Local] = a.Value\n+\t\t\t\tv, ok := d.ns[a.Name.Local]\n+\t\t\t\td.pushNs(a.Name.Local, v, ok)\n+\t\t\t\td.ns[a.Name.Local] = a.Value\n \t\t\t}\n \t\t\tif a.Name.Space == \"\" && a.Name.Local == \"xmlns\" {\n \t\t\t\t// Default space for untagged names\n-\t\t\t\tv, ok := p.ns[\"\"]\n-\t\t\t\tp.pushNs(\"\", v, ok)\n-\t\t\t\tp.ns[\"\"] = a.Value\n+\t\t\t\tv, ok := d.ns[\"\"]\n+\t\t\t\td.pushNs(\"\", v, ok)\n+\t\t\t\td.ns[\"\"] = a.Value\n \t\t\t}\n \t\t}\n \n-\t\tp.translate(&t1.Name, true)\n+\t\td.translate(&t1.Name, true)\n \t\tfor i := range t1.Attr {\n-\t\t\tp.translate(&t1.Attr[i].Name, false)\n+\t\t\td.translate(&t1.Attr[i].Name, false)\n \t\t}\n-\t\tp.pushElement(t1.Name)\n+\t\td.pushElement(t1.Name)\n \t\tt = t1\n \n \tcase EndElement:\n-\t\tp.translate(&t1.Name, true)\n-\t\tif !p.popElement(&t1) {\n-\t\t\treturn nil, p.err\n+\t\td.translate(&t1.Name, true)\n+\t\tif !d.popElement(&t1) {\n+\t\t\treturn nil, d.err\n \t\t}\n \t\tt = t1\n \t}\n@@ -272,7 +272,7 @@ func (p *Parser) Token() (t Token, err error) {\n // Apply name space translation to name n.\n // The default name space (for Space==\"\")\n // applies only to element names, not to attribute names.\n-func (p *Parser) translate(n *Name, isElementName bool) {\n+func (d *Decoder) translate(n *Name, isElementName bool) {\n \tswitch {\n \tcase n.Space == \"xmlns\":\n \t\treturn\n@@ -281,20 +281,20 @@ func (p *Parser) translate(n *Name, isElementName bool) {\n \tcase n.Space == \"\" && n.Local == \"xmlns\":\n \t\treturn\n \t}\n-\tif v, ok := p.ns[n.Space]; ok {\n+\tif v, ok := d.ns[n.Space]; ok {\n \t\tn.Space = v\n \t}\n }\n \n-func (p *Parser) switchToReader(r io.Reader) {\n+func (d *Decoder) switchToReader(r io.Reader) {\n \t// Get efficient byte at a time reader.\n \t// Assume that if reader has its own\n \t// ReadByte, it's efficient enough.\n \t// Otherwise, use bufio.\n \tif rb, ok := r.(io.ByteReader); ok {\n-\t\tp.r = rb\n+\t\td.r = rb\n \t} else {\n-\t\tp.r = bufio.NewReader(r)\n+\t\td.r = bufio.NewReader(r)\n \t}\n }\n \n@@ -314,47 +314,47 @@ const (\n \tstkNs\n )\n \n-func (p *Parser) push(kind int) *stack {\n-\ts := p.free\n+func (d *Decoder) push(kind int) *stack {\n+\ts := d.free\n \tif s != nil {\n-\t\tp.free = s.next\n+\t\td.free = s.next\n \t} else {\n \t\ts = new(stack)\n \t}\n-\ts.next = p.stk\n+\ts.next = d.stk\n \ts.kind = kind\n-\tp.stk = s\n+\td.stk = s\n \treturn s\n }\n \n-func (p *Parser) pop() *stack {\n-\ts := p.stk\n+func (d *Decoder) pop() *stack {\n+\ts := d.stk\n \tif s != nil {\n-\t\tp.stk = s.next\n-\t\ts.next = p.free\n-\t\tp.free = s\n+\t\td.stk = s.next\n+\t\ts.next = d.free\n+\t\td.free = s\n \t}\n \treturn s\n }\n \n // Record that we are starting an element with the given name.\n-func (p *Parser) pushElement(name Name) {\n-\ts := p.push(stkStart)\n+func (d *Decoder) pushElement(name Name) {\n+\ts := d.push(stkStart)\n \ts.name = name\n }\n \n // Record that we are changing the value of ns[local].\n // The old value is url, ok.\n-func (p *Parser) pushNs(local string, url string, ok bool) {\n-\ts := p.push(stkNs)\n+func (d *Decoder) pushNs(local string, url string, ok bool) {\n+\ts := d.push(stkNs)\n \ts.name.Local = local\n \ts.name.Space = url\n \ts.ok = ok\n }\n \n // Creates a SyntaxError with the current line number.\n-func (p *Parser) syntaxError(msg string) error {\n-\treturn &SyntaxError{Msg: msg, Line: p.line}\n+func (d *Decoder) syntaxError(msg string) error {\n+\treturn &SyntaxError{Msg: msg, Line: d.line}\n }\n \n // Record that we are ending an element with the given name.\n@@ -363,36 +363,36 @@ func (p *Parser) syntaxError(msg string) error {\n // After popping the element, apply any undo records from\n // the stack to restore the name translations that existed\n // before we saw this element.\n-func (p *Parser) popElement(t *EndElement) bool {\n-\ts := p.pop()\n+func (d *Decoder) popElement(t *EndElement) bool {\n+\ts := d.pop()\n \tname := t.Name\n \tswitch {\n \tcase s == nil || s.kind != stkStart:\n-\t\tp.err = p.syntaxError(\"unexpected end element </\" + name.Local + \">\")\n+\t\td.err = d.syntaxError(\"unexpected end element </\" + name.Local + \">\")\n \t\treturn false\n \tcase s.name.Local != name.Local:\n-\t\tif !p.Strict {\n-\t\t\tp.needClose = true\n-\t\t\tp.toClose = t.Name\n+\t\tif !d.Strict {\n+\t\t\td.needClose = true\n+\t\t\td.toClose = t.Name\n \t\t\tt.Name = s.name\n \t\t\treturn true\n \t\t}\n-\t\tp.err = p.syntaxError(\"element <\" + s.name.Local + \"> closed by </\" + name.Local + \">\")\n+\t\td.err = d.syntaxError(\"element <\" + s.name.Local + \"> closed by </\" + name.Local + \">\")\n \t\treturn false\n \tcase s.name.Space != name.Space:\n-\t\tp.err = p.syntaxError(\"element <\" + s.name.Local + \"> in space \" + s.name.Space +\n+\t\td.err = d.syntaxError(\"element <\" + s.name.Local + \"> in space \" + s.name.Space +\n \t\t\t\"closed by </\" + name.Local + \"> in space \" + name.Space)\n \t\treturn false\n \t}\n \n \t// Pop stack until a Start is on the top, undoing the\n \t// translations that were associated with the element we just closed.\n-\tfor p.stk != nil && p.stk.kind != stkStart {\n-\t\ts := p.pop()\n+\tfor d.stk != nil && d.stk.kind != stkStart {\n+\t\ts := d.pop()\n \t\tif s.ok {\n-\t\t\tp.ns[s.name.Local] = s.name.Space\n+\t\t\td.ns[s.name.Local] = s.name.Space\n \t\t} else {\n-\t\t\tdelete(p.ns, s.name.Local)\n+\t\t\tdelete(d.ns, s.name.Local)\n \t\t}\n \t}\n \n@@ -401,17 +401,17 @@ func (p *Parser) popElement(t *EndElement) bool {\n \n // If the top element on the stack is autoclosing and\n // t is not the end tag, invent the end tag.\n-func (p *Parser) autoClose(t Token) (Token, bool) {\n-\tif p.stk == nil || p.stk.kind != stkStart {\n+func (d *Decoder) autoClose(t Token) (Token, bool) {\n+\tif d.stk == nil || d.stk.kind != stkStart {\n \t\treturn nil, false\n \t}\n-\tname := strings.ToLower(p.stk.name.Local)\n-\tfor _, s := range p.AutoClose {\n+\tname := strings.ToLower(d.stk.name.Local)\n+\tfor _, s := range d.AutoClose {\n \t\tif strings.ToLower(s) == name {\n \t\t\t// This one should be auto closed if t doesn't close it.\n \t\t\tet, ok := t.(EndElement)\n \t\t\tif !ok || et.Name.Local != name {\n-\t\t\t\treturn EndElement{p.stk.name}, true\n+\t\t\t\treturn EndElement{d.stk.name}, true\n \t\t\t}\n \t\t\tbreak\n \t\t}\n@@ -422,53 +422,53 @@ func (p *Parser) autoClose(t Token) (Token, bool) {\n // RawToken is like Token but does not verify that\n // start and end elements match and does not translate\n // name space prefixes to their corresponding URLs.\n-func (p *Parser) RawToken() (Token, error) {\n-\tif p.err != nil {\n-\t\treturn nil, p.err\n+func (d *Decoder) RawToken() (Token, error) {\n+\tif d.err != nil {\n+\t\treturn nil, d.err\n \t}\n-\tif p.needClose {\n+\tif d.needClose {\n \t\t// The last element we read was self-closing and\n \t\t// we returned just the StartElement half.\n \t\t// Return the EndElement half now.\n-\t\tp.needClose = false\n-\t\treturn EndElement{p.toClose}, nil\n+\t\td.needClose = false\n+\t\treturn EndElement{d.toClose}, nil\n \t}\n \n-\tb, ok := p.getc()\n+\tb, ok := d.getc()\n \tif !ok {\n-\t\treturn nil, p.err\n+\t\treturn nil, d.err\n \t}\n \n \tif b != '<' {\n \t\t// Text section.\n-\t\tp.ungetc(b)\n-\t\tdata := p.text(-1, false)\n+\t\td.ungetc(b)\n+\t\tdata := d.text(-1, false)\n \t\tif data == nil {\n-\t\t\treturn nil, p.err\n+\t\t\treturn nil, d.err\n \t\t}\n \t\treturn CharData(data), nil\n \t}\n \n-\tif b, ok = p.mustgetc(); !ok {\n-\t\treturn nil, p.err\n+\tif b, ok = d.mustgetc(); !ok {\n+\t\treturn nil, d.err\n \t}\n \tswitch b {\n \tcase '/':\n \t\t// </: End element\n \t\tvar name Name\n-\t\tif name, ok = p.nsname(); !ok {\n-\t\t\tif p.err == nil {\n-\t\t\t\tp.err = p.syntaxError(\"expected element name after </\")\n+\t\tif name, ok = d.nsname(); !ok {\n+\t\t\tif d.err == nil {\n+\t\t\t\td.err = d.syntaxError(\"expected element name after </\")\n \t\t\t}\n-\t\t\treturn nil, p.err\n+\t\t\treturn nil, d.err\n \t\t}\n-\t\tp.space()\n-\t\tif b, ok = p.mustgetc(); !ok {\n-\t\t\treturn nil, p.err\n+\t\td.space()\n+\t\tif b, ok = d.mustgetc(); !ok {\n+\t\t\treturn nil, d.err\n \t\t}\n \t\tif b != '>' {\n-\t\t\tp.err = p.syntaxError(\"invalid characters between </\" + name.Local + \" and >\")\n-\t\t\treturn nil, p.err\n+\t\t\td.err = d.syntaxError(\"invalid characters between </\" + name.Local + \" and >\")\n+\t\t\treturn nil, d.err\n \t\t}\n \t\treturn EndElement{name}, nil\n \n@@ -477,114 +477,114 @@ func (p *Parser) RawToken() (Token, error) {\n \t\t// TODO(rsc): Should parse the <?xml declaration to make sure\n \t\t// the version is 1.0 and the encoding is UTF-8.\n \t\tvar target string\n-\t\tif target, ok = p.name(); !ok {\n-\t\t\tif p.err == nil {\n-\t\t\t\tp.err = p.syntaxError(\"expected target name after <?\")\n+\t\tif target, ok = d.name(); !ok {\n+\t\t\tif d.err == nil {\n+\t\t\t\td.err = d.syntaxError(\"expected target name after <?\")\n \t\t\t}\n-\t\t\treturn nil, p.err\n+\t\t\treturn nil, d.err\n \t\t}\n-\t\tp.space()\n-\t\tp.buf.Reset()\n+\t\td.space()\n+\t\td.buf.Reset()\n \t\tvar b0 byte\n \t\tfor {\n-\t\t\tif b, ok = p.mustgetc(); !ok {\n-\t\t\t\treturn nil, p.err\n+\t\t\tif b, ok = d.mustgetc(); !ok {\n+\t\t\t\treturn nil, d.err\n \t\t\t}\n-\t\t\tp.buf.WriteByte(b)\n+\t\t\td.buf.WriteByte(b)\n \t\t\tif b0 == '?' && b == '>' {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tb0 = b\n \t\t}\n-\t\tdata := p.buf.Bytes()\n+\t\tdata := d.buf.Bytes()\n \t\tdata = data[0 : len(data)-2] // chop ?>\n \n \t\tif target == \"xml\" {\n \t\t\tenc := procInstEncoding(string(data))\n \t\t\tif enc != \"\" && enc != \"utf-8\" && enc != \"UTF-8\" {\n-\t\t\t\tif p.CharsetReader == nil {\n-\t\t\t\t\tp.err = fmt.Errorf(\"xml: encoding %q declared but Parser.CharsetReader is nil\", enc)\n-\t\t\t\t\treturn nil, p.err\n+\t\t\t\tif d.CharsetReader == nil {\n+\t\t\t\t\td.err = fmt.Errorf(\"xml: encoding %q declared but Decoder.CharsetReader is nil\", enc)\n+\t\t\t\t\treturn nil, d.err\n \t\t\t\t}\n-\t\t\t\tnewr, err := p.CharsetReader(enc, p.r.(io.Reader))\n+\t\t\t\tnewr, err := d.CharsetReader(enc, d.r.(io.Reader))\n \t\t\t\tif err != nil {\n-\t\t\t\t\tp.err = fmt.Errorf(\"xml: opening charset %q: %v\", enc, err)\n-\t\t\t\t\treturn nil, p.err\n+\t\t\t\t\td.err = fmt.Errorf(\"xml: opening charset %q: %v\", enc, err)\n+\t\t\t\t\treturn nil, d.err\n \t\t\t\t}\n \t\t\t\tif newr == nil {\n \t\t\t\t\tpanic(\"CharsetReader returned a nil Reader for charset \" + enc)\n \t\t\t\t}\n-\t\t\t\tp.switchToReader(newr)\n+\t\t\t\td.switchToReader(newr)\n \t\t\t}\n \t\t}\n \t\treturn ProcInst{target, data}, nil\n \n \tcase '!':\n \t\t// <!: Maybe comment, maybe CDATA.\n-\t\tif b, ok = p.mustgetc(); !ok {\n-\t\t\treturn nil, p.err\n+\t\tif b, ok = d.mustgetc(); !ok {\n+\t\t\treturn nil, d.err\n \t\t}\n \t\tswitch b {\n \t\tcase '-': // <!-\n \t\t\t// Probably <!-- for a comment.\n-\t\t\tif b, ok = p.mustgetc(); !ok {\n-\t\t\t\treturn nil, p.err\n+\t\t\tif b, ok = d.mustgetc(); !ok {\n+\t\t\t\treturn nil, d.err\n \t\t\t}\n \t\t\tif b != '-' {\n-\t\t\t\tp.err = p.syntaxError(\"invalid sequence <!- not part of <!--\")\n-\t\t\t\treturn nil, p.err\n+\t\t\t\td.err = d.syntaxError(\"invalid sequence <!- not part of <!--\")\n+\t\t\t\treturn nil, d.err\n \t\t\t}\n \t\t\t// Look for terminator.\n-\t\t\tp.buf.Reset()\n+\t\t\td.buf.Reset()\n \t\t\tvar b0, b1 byte\n \t\t\tfor {\n-\t\t\t\tif b, ok = p.mustgetc(); !ok {\n-\t\t\t\t\treturn nil, p.err\n+\t\t\t\tif b, ok = d.mustgetc(); !ok {\n+\t\t\t\t\treturn nil, d.err\n \t\t\t\t}\n-\t\t\t\tp.buf.WriteByte(b)\n+\t\t\t\td.buf.WriteByte(b)\n \t\t\t\tif b0 == '-' && b1 == '-' && b == '>' {\n \t\t\t\t\tbreak\n \t\t\t\t}\n \t\t\t\tb0, b1 = b1, b\n \t\t\t}\n-\t\t\tdata := p.buf.Bytes()\n+\t\t\tdata := d.buf.Bytes()\n \t\t\tdata = data[0 : len(data)-3] // chop -->\n \t\t\treturn Comment(data), nil\n \n \t\tcase '[': // <![\n \t\t\t// Probably <![CDATA[.\n \t\t\tfor i := 0; i < 6; i++ {\n-\t\t\t\tif b, ok = p.mustgetc(); !ok {\n-\t\t\t\t\treturn nil, p.err\n+\t\t\t\tif b, ok = d.mustgetc(); !ok {\n+\t\t\t\t\treturn nil, d.err\n \t\t\t\t}\n \t\t\t\tif b != \"CDATA[\"[i] {\n-\t\t\t\t\tp.err = p.syntaxError(\"invalid <![ sequence\")\n-\t\t\t\t\treturn nil, p.err\n+\t\t\t\t\td.err = d.syntaxError(\"invalid <![ sequence\")\n+\t\t\t\t\treturn nil, d.err\n \t\t\t\t}\n \t\t\t}\n \t\t\t// Have <![CDATA[.  Read text until ]]>.\n-\t\t\tdata := p.text(-1, true)\n+\t\t\tdata := d.text(-1, true)\n \t\t\tif data == nil {\n-\t\t\t\treturn nil, p.err\n+\t\t\t\treturn nil, d.err\n \t\t\t}\n \t\t\treturn CharData(data), nil\n \t\t}\n \n \t\t// Probably a directive: <!DOCTYPE ...>, <!ENTITY ...>, etc.\n \t\t// We don't care, but accumulate for caller. Quoted angle\n \t\t// brackets do not count for nesting.\n-\t\tp.buf.Reset()\n-\t\tp.buf.WriteByte(b)\n+\t\td.buf.Reset()\n+\t\td.buf.WriteByte(b)\n \t\tinquote := uint8(0)\n \t\tdepth := 0\n \t\tfor {\n-\t\t\tif b, ok = p.mustgetc(); !ok {\n-\t\t\t\treturn nil, p.err\n+\t\t\tif b, ok = d.mustgetc(); !ok {\n+\t\t\t\treturn nil, d.err\n \t\t\t}\n \t\t\tif inquote == 0 && b == '>' && depth == 0 {\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tp.buf.WriteByte(b)\n+\t\t\td.buf.WriteByte(b)\n \t\t\tswitch {\n \t\t\tcase b == inquote:\n \t\t\t\tinquote = 0\n@@ -602,45 +602,45 @@ func (p *Parser) RawToken() (Token, error) {\n \t\t\t\tdepth++\n \t\t\t}\n \t\t}\n-\t\treturn Directive(p.buf.Bytes()), nil\n+\t\treturn Directive(d.buf.Bytes()), nil\n \t}\n \n \t// Must be an open element like <a href=\"foo\">\n-\tp.ungetc(b)\n+\td.ungetc(b)\n \n \tvar (\n \t\tname  Name\n \t\tempty bool\n \t\tattr  []Attr\n \t)\n-\tif name, ok = p.nsname(); !ok {\n-\t\tif p.err == nil {\n-\t\t\tp.err = p.syntaxError(\"expected element name after <\")\n+\tif name, ok = d.nsname(); !ok {\n+\t\tif d.err == nil {\n+\t\t\td.err = d.syntaxError(\"expected element name after <\")\n \t\t}\n-\t\treturn nil, p.err\n+\t\treturn nil, d.err\n \t}\n \n \tattr = make([]Attr, 0, 4)\n \tfor {\n-\t\tp.space()\n-\t\tif b, ok = p.mustgetc(); !ok {\n-\t\t\treturn nil, p.err\n+\t\td.space()\n+\t\tif b, ok = d.mustgetc(); !ok {\n+\t\t\treturn nil, d.err\n \t\t}\n \t\tif b == '/' {\n \t\t\tempty = true\n-\t\t\tif b, ok = p.mustgetc(); !ok {\n-\t\t\t\treturn nil, p.err\n+\t\t\tif b, ok = d.mustgetc(); !ok {\n+\t\t\t\treturn nil, d.err\n \t\t\t}\n \t\t\tif b != '>' {\n-\t\t\t\tp.err = p.syntaxError(\"expected /> in element\")\n-\t\t\t\treturn nil, p.err\n+\t\t\t\td.err = d.syntaxError(\"expected /> in element\")\n+\t\t\t\treturn nil, d.err\n \t\t\t}\n \t\t\tbreak\n \t\t}\n \t\tif b == '>' {\n \t\t\tbreak\n \t\t}\n-\t\tp.ungetc(b)\n+\t\td.ungetc(b)\n \n \t\tn := len(attr)\n \t\tif n >= cap(attr) {\n@@ -650,145 +650,145 @@ func (p *Parser) RawToken() (Token, error) {\n \t\t}\n \t\tattr = attr[0 : n+1]\n \t\ta := &attr[n]\n-\t\tif a.Name, ok = p.nsname(); !ok {\n-\t\t\tif p.err == nil {\n-\t\t\t\tp.err = p.syntaxError(\"expected attribute name in element\")\n+\t\tif a.Name, ok = d.nsname(); !ok {\n+\t\t\tif d.err == nil {\n+\t\t\t\td.err = d.syntaxError(\"expected attribute name in element\")\n \t\t\t}\n-\t\t\treturn nil, p.err\n+\t\t\treturn nil, d.err\n \t\t}\n-\t\tp.space()\n-\t\tif b, ok = p.mustgetc(); !ok {\n-\t\t\treturn nil, p.err\n+\t\td.space()\n+\t\tif b, ok = d.mustgetc(); !ok {\n+\t\t\treturn nil, d.err\n \t\t}\n \t\tif b != '=' {\n-\t\t\tif p.Strict {\n-\t\t\t\tp.err = p.syntaxError(\"attribute name without = in element\")\n-\t\t\t\treturn nil, p.err\n+\t\t\tif d.Strict {\n+\t\t\t\td.err = d.syntaxError(\"attribute name without = in element\")\n+\t\t\t\treturn nil, d.err\n \t\t\t} else {\n-\t\t\t\tp.ungetc(b)\n+\t\t\t\td.ungetc(b)\n \t\t\t\ta.Value = a.Name.Local\n \t\t\t}\n \t\t} else {\n-\t\t\tp.space()\n-\t\t\tdata := p.attrval()\n+\t\t\td.space()\n+\t\t\tdata := d.attrval()\n \t\t\tif data == nil {\n-\t\t\t\treturn nil, p.err\n+\t\t\t\treturn nil, d.err\n \t\t\t}\n \t\t\ta.Value = string(data)\n \t\t}\n \t}\n \tif empty {\n-\t\tp.needClose = true\n-\t\tp.toClose = name\n+\t\td.needClose = true\n+\t\td.toClose = name\n \t}\n \treturn StartElement{name, attr}, nil\n }\n \n-func (p *Parser) attrval() []byte {\n-\tb, ok := p.mustgetc()\n+func (d *Decoder) attrval() []byte {\n+\tb, ok := d.mustgetc()\n \tif !ok {\n \t\treturn nil\n \t}\n \t// Handle quoted attribute values\n \tif b == '\"' || b == '\\'' {\n-\t\treturn p.text(int(b), false)\n+\t\treturn d.text(int(b), false)\n \t}\n \t// Handle unquoted attribute values for strict parsers\n-\tif p.Strict {\n-\t\tp.err = p.syntaxError(\"unquoted or missing attribute value in element\")\n+\tif d.Strict {\n+\t\td.err = d.syntaxError(\"unquoted or missing attribute value in element\")\n \t\treturn nil\n \t}\n \t// Handle unquoted attribute values for unstrict parsers\n-\tp.ungetc(b)\n-\tp.buf.Reset()\n+\td.ungetc(b)\n+\td.buf.Reset()\n \tfor {\n-\t\tb, ok = p.mustgetc()\n+\t\tb, ok = d.mustgetc()\n \t\tif !ok {\n \t\t\treturn nil\n \t\t}\n \t\t// http://www.w3.org/TR/REC-html40/intro/sgmltut.html#h-3.2.2\n \t\tif 'a' <= b && b <= 'z' || 'A' <= b && b <= 'Z' ||\n \t\t\t'0' <= b && b <= '9' || b == '_' || b == ':' || b == '-' {\n-\t\t\tp.buf.WriteByte(b)\n+\t\t\td.buf.WriteByte(b)\n \t\t} else {\n-\t\t\tp.ungetc(b)\n+\t\t\td.ungetc(b)\n \t\t\tbreak\n \t\t}\n \t}\n-\treturn p.buf.Bytes()\n+\treturn d.buf.Bytes()\n }\n \n // Skip spaces if any\n-func (p *Parser) space() {\n+func (d *Decoder) space() {\n \tfor {\n-\t\tb, ok := p.getc()\n+\t\tb, ok := d.getc()\n \t\tif !ok {\n \t\t\treturn\n \t\t}\n \t\tswitch b {\n \t\tcase ' ', '\\r', '\\n', '\\t':\n \t\tdefault:\n-\t\t\tp.ungetc(b)\n+\t\t\td.ungetc(b)\n \t\t\treturn\n \t\t}\n \t}\n }\n \n // Read a single byte.\n // If there is no byte to read, return ok==false\n-// and leave the error in p.err.\n+// and leave the error in d.err.\n // Maintain line number.\n-func (p *Parser) getc() (b byte, ok bool) {\n-\tif p.err != nil {\n+func (d *Decoder) getc() (b byte, ok bool) {\n+\tif d.err != nil {\n \t\treturn 0, false\n \t}\n-\tif p.nextByte >= 0 {\n-\t\tb = byte(p.nextByte)\n-\t\tp.nextByte = -1\n+\tif d.nextByte >= 0 {\n+\t\tb = byte(d.nextByte)\n+\t\td.nextByte = -1\n \t} else {\n-\t\tb, p.err = p.r.ReadByte()\n-\t\tif p.err != nil {\n+\t\tb, d.err = d.r.ReadByte()\n+\t\tif d.err != nil {\n \t\t\treturn 0, false\n \t\t}\n-\t\tif p.saved != nil {\n-\t\t\tp.saved.WriteByte(b)\n+\t\tif d.saved != nil {\n+\t\t\td.saved.WriteByte(b)\n \t\t}\n \t}\n \tif b == '\\n' {\n-\t\tp.line++\n+\t\td.line++\n \t}\n \treturn b, true\n }\n \n // Return saved offset.\n // If we did ungetc (nextByte >= 0), have to back up one.\n-func (p *Parser) savedOffset() int {\n-\tn := p.saved.Len()\n-\tif p.nextByte >= 0 {\n+func (d *Decoder) savedOffset() int {\n+\tn := d.saved.Len()\n+\tif d.nextByte >= 0 {\n \t\tn--\n \t}\n \treturn n\n }\n \n // Must read a single byte.\n // If there is no byte to read,\n-// set p.err to SyntaxError(\"unexpected EOF\")\n+// set d.err to SyntaxError(\"unexpected EOF\")\n // and return ok==false\n-func (p *Parser) mustgetc() (b byte, ok bool) {\n-\tif b, ok = p.getc(); !ok {\n-\t\tif p.err == io.EOF {\n-\t\t\tp.err = p.syntaxError(\"unexpected EOF\")\n+func (d *Decoder) mustgetc() (b byte, ok bool) {\n+\tif b, ok = d.getc(); !ok {\n+\t\tif d.err == io.EOF {\n+\t\t\td.err = d.syntaxError(\"unexpected EOF\")\n \t\t}\n \t}\n \treturn\n }\n \n // Unread a single byte.\n-func (p *Parser) ungetc(b byte) {\n+func (d *Decoder) ungetc(b byte) {\n \tif b == '\\n' {\n-\t\tp.line--\n+\t\td.line--\n \t}\n-\tp.nextByte = int(b)\n+\td.nextByte = int(b)\n }\n \n var entity = map[string]int{\n@@ -802,18 +802,18 @@ var entity = map[string]int{\n // Read plain text section (XML calls it character data).\n // If quote >= 0, we are in a quoted string and need to find the matching quote.\n // If cdata == true, we are in a <![CDATA[ section and need to find ]]>.\n-// On failure return nil and leave the error in p.err.\n-func (p *Parser) text(quote int, cdata bool) []byte {\n+// On failure return nil and leave the error in d.err.\n+func (d *Decoder) text(quote int, cdata bool) []byte {\n \tvar b0, b1 byte\n \tvar trunc int\n-\tp.buf.Reset()\n+\td.buf.Reset()\n Input:\n \tfor {\n-\t\tb, ok := p.getc()\n+\t\tb, ok := d.getc()\n \t\tif !ok {\n \t\t\tif cdata {\n-\t\t\t\tif p.err == io.EOF {\n-\t\t\t\t\tp.err = p.syntaxError(\"unexpected EOF in CDATA section\")\n+\t\t\t\tif d.err == io.EOF {\n+\t\t\t\t\td.err = d.syntaxError(\"unexpected EOF in CDATA section\")\n \t\t\t\t}\n \t\t\t\treturn nil\n \t\t\t}\n@@ -827,17 +827,17 @@ Input:\n \t\t\t\ttrunc = 2\n \t\t\t\tbreak Input\n \t\t\t}\n-\t\t\tp.err = p.syntaxError(\"unescaped ]]> not in CDATA section\")\n+\t\t\td.err = d.syntaxError(\"unescaped ]]> not in CDATA section\")\n \t\t\treturn nil\n \t\t}\n \n \t\t// Stop reading text if we see a <.\n \t\tif b == '<' && !cdata {\n \t\t\tif quote >= 0 {\n-\t\t\t\tp.err = p.syntaxError(\"unescaped < inside quoted string\")\n+\t\t\t\td.err = d.syntaxError(\"unescaped < inside quoted string\")\n \t\t\t\treturn nil\n \t\t\t}\n-\t\t\tp.ungetc('<')\n+\t\t\td.ungetc('<')\n \t\t\tbreak Input\n \t\t}\n \t\tif quote >= 0 && b == byte(quote) {\n@@ -850,16 +850,16 @@ Input:\n \t\t\t// Parsers are required to recognize lt, gt, amp, apos, and quot\n \t\t\t// even if they have not been declared.  That's all we allow.\n \t\t\tvar i int\n-\t\t\tfor i = 0; i < len(p.tmp); i++ {\n+\t\t\tfor i = 0; i < len(d.tmp); i++ {\n \t\t\t\tvar ok bool\n-\t\t\t\tp.tmp[i], ok = p.getc()\n+\t\t\t\td.tmp[i], ok = d.getc()\n \t\t\t\tif !ok {\n-\t\t\t\t\tif p.err == io.EOF {\n-\t\t\t\t\t\tp.err = p.syntaxError(\"unexpected EOF\")\n+\t\t\t\t\tif d.err == io.EOF {\n+\t\t\t\t\t\td.err = d.syntaxError(\"unexpected EOF\")\n \t\t\t\t\t}\n \t\t\t\t\treturn nil\n \t\t\t\t}\n-\t\t\t\tc := p.tmp[i]\n+\t\t\t\tc := d.tmp[i]\n \t\t\t\tif c == ';' {\n \t\t\t\t\tbreak\n \t\t\t\t}\n@@ -869,18 +869,18 @@ Input:\n \t\t\t\t\tc == '_' || c == '#' {\n \t\t\t\t\tcontinue\n \t\t\t\t}\n-\t\t\t\tp.ungetc(c)\n+\t\t\t\td.ungetc(c)\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\ts := string(p.tmp[0:i])\n-\t\t\tif i >= len(p.tmp) {\n-\t\t\t\tif !p.Strict {\n+\t\t\ts := string(d.tmp[0:i])\n+\t\t\tif i >= len(d.tmp) {\n+\t\t\t\tif !d.Strict {\n \t\t\t\t\tb0, b1 = 0, 0\n-\t\t\t\t\tp.buf.WriteByte('&')\n-\t\t\t\t\tp.buf.Write(p.tmp[0:i])\n+\t\t\t\t\td.buf.WriteByte('&')\n+\t\t\t\t\td.buf.Write(d.tmp[0:i])\n \t\t\t\t\tcontinue Input\n \t\t\t\t}\n-\t\t\t\tp.err = p.syntaxError(\"character entity expression &\" + s + \"... too long\")\n+\t\t\t\td.err = d.syntaxError(\"character entity expression &\" + s + \"... too long\")\n \t\t\t\treturn nil\n \t\t\t}\n \t\t\tvar haveText bool\n@@ -901,41 +901,41 @@ Input:\n \t\t\t\tif r, ok := entity[s]; ok {\n \t\t\t\t\ttext = string(r)\n \t\t\t\t\thaveText = true\n-\t\t\t\t} else if p.Entity != nil {\n-\t\t\t\t\ttext, haveText = p.Entity[s]\n+\t\t\t\t} else if d.Entity != nil {\n+\t\t\t\t\ttext, haveText = d.Entity[s]\n \t\t\t\t}\n \t\t\t}\n \t\t\tif !haveText {\n-\t\t\t\tif !p.Strict {\n+\t\t\t\tif !d.Strict {\n \t\t\t\t\tb0, b1 = 0, 0\n-\t\t\t\t\tp.buf.WriteByte('&')\n-\t\t\t\t\tp.buf.Write(p.tmp[0:i])\n+\t\t\t\t\td.buf.WriteByte('&')\n+\t\t\t\t\td.buf.Write(d.tmp[0:i])\n \t\t\t\t\tcontinue Input\n \t\t\t\t}\n-\t\t\t\tp.err = p.syntaxError(\"invalid character entity &\" + s + \";\")\n+\t\t\t\td.err = d.syntaxError(\"invalid character entity &\" + s + \";\")\n \t\t\t\treturn nil\n \t\t\t}\n-\t\t\tp.buf.Write([]byte(text))\n+\t\t\td.buf.Write([]byte(text))\n \t\t\tb0, b1 = 0, 0\n \t\t\tcontinue Input\n \t\t}\n-\t\tp.buf.WriteByte(b)\n+\t\td.buf.WriteByte(b)\n \t\tb0, b1 = b1, b\n \t}\n-\tdata := p.buf.Bytes()\n+\tdata := d.buf.Bytes()\n \tdata = data[0 : len(data)-trunc]\n \n \t// Inspect each rune for being a disallowed character.\n \tbuf := data\n \tfor len(buf) > 0 {\n \t\tr, size := utf8.DecodeRune(buf)\n \t\tif r == utf8.RuneError && size == 1 {\n-\t\t\tp.err = p.syntaxError(\"invalid UTF-8\")\n+\t\t\td.err = d.syntaxError(\"invalid UTF-8\")\n \t\t\treturn nil\n \t\t}\n \t\tbuf = buf[size:]\n \t\tif !isInCharacterRange(r) {\n-\t\t\tp.err = p.syntaxError(fmt.Sprintf(\"illegal character code %U\", r))\n+\t\t\td.err = d.syntaxError(fmt.Sprintf(\"illegal character code %U\", r))\n \t\t\treturn nil\n \t\t}\n \t}\n@@ -970,8 +970,8 @@ func isInCharacterRange(r rune) (inrange bool) {\n \n // Get name space name: name with a : stuck in the middle.\n // The part before the : is the name space identifier.\n-func (p *Parser) nsname() (name Name, ok bool) {\n-\ts, ok := p.name()\n+func (d *Decoder) nsname() (name Name, ok bool) {\n+\ts, ok := d.name()\n \tif !ok {\n \t\treturn\n \t}\n@@ -986,37 +986,37 @@ func (p *Parser) nsname() (name Name, ok bool) {\n }\n \n // Get name: /first(first|second)*/\n-// Do not set p.err if the name is missing (unless unexpected EOF is received):\n+// Do not set d.err if the name is missing (unless unexpected EOF is received):\n // let the caller provide better context.\n-func (p *Parser) name() (s string, ok bool) {\n+func (d *Decoder) name() (s string, ok bool) {\n \tvar b byte\n-\tif b, ok = p.mustgetc(); !ok {\n+\tif b, ok = d.mustgetc(); !ok {\n \t\treturn\n \t}\n \n \t// As a first approximation, we gather the bytes [A-Za-z_:.-\\x80-\\xFF]*\n \tif b < utf8.RuneSelf && !isNameByte(b) {\n-\t\tp.ungetc(b)\n+\t\td.ungetc(b)\n \t\treturn \"\", false\n \t}\n-\tp.buf.Reset()\n-\tp.buf.WriteByte(b)\n+\td.buf.Reset()\n+\td.buf.WriteByte(b)\n \tfor {\n-\t\tif b, ok = p.mustgetc(); !ok {\n+\t\tif b, ok = d.mustgetc(); !ok {\n \t\t\treturn\n \t\t}\n \t\tif b < utf8.RuneSelf && !isNameByte(b) {\n-\t\t\tp.ungetc(b)\n+\t\t\td.ungetc(b)\n \t\t\tbreak\n \t\t}\n-\t\tp.buf.WriteByte(b)\n+\t\td.buf.WriteByte(b)\n \t}\n \n \t// Then we check the characters.\n-\ts = p.buf.String()\n+\ts = d.buf.String()\n \tfor i, c := range s {\n \t\tif !unicode.Is(first, c) && (i == 0 || !unicode.Is(second, c)) {\n-\t\t\tp.err = p.syntaxError(\"invalid XML name: \" + s)\n+\t\t\td.err = d.syntaxError(\"invalid XML name: \" + s)\n \t\t\treturn \"\", false\n \t\t}\n \t}"}, {"sha": "1d0696ce087b3446a7df588103f284f6eb1ed8b5", "filename": "libgo/go/encoding/xml/xml_test.go", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -5,7 +5,6 @@\n package xml\n \n import (\n-\t\"bytes\"\n \t\"io\"\n \t\"reflect\"\n \t\"strings\"\n@@ -155,8 +154,8 @@ var xmlInput = []string{\n }\n \n func TestRawToken(t *testing.T) {\n-\tp := NewParser(strings.NewReader(testInput))\n-\ttestRawToken(t, p, rawTokens)\n+\td := NewDecoder(strings.NewReader(testInput))\n+\ttestRawToken(t, d, rawTokens)\n }\n \n type downCaser struct {\n@@ -179,27 +178,27 @@ func (d *downCaser) Read(p []byte) (int, error) {\n \n func TestRawTokenAltEncoding(t *testing.T) {\n \tsawEncoding := \"\"\n-\tp := NewParser(strings.NewReader(testInputAltEncoding))\n-\tp.CharsetReader = func(charset string, input io.Reader) (io.Reader, error) {\n+\td := NewDecoder(strings.NewReader(testInputAltEncoding))\n+\td.CharsetReader = func(charset string, input io.Reader) (io.Reader, error) {\n \t\tsawEncoding = charset\n \t\tif charset != \"x-testing-uppercase\" {\n \t\t\tt.Fatalf(\"unexpected charset %q\", charset)\n \t\t}\n \t\treturn &downCaser{t, input.(io.ByteReader)}, nil\n \t}\n-\ttestRawToken(t, p, rawTokensAltEncoding)\n+\ttestRawToken(t, d, rawTokensAltEncoding)\n }\n \n func TestRawTokenAltEncodingNoConverter(t *testing.T) {\n-\tp := NewParser(strings.NewReader(testInputAltEncoding))\n-\ttoken, err := p.RawToken()\n+\td := NewDecoder(strings.NewReader(testInputAltEncoding))\n+\ttoken, err := d.RawToken()\n \tif token == nil {\n \t\tt.Fatalf(\"expected a token on first RawToken call\")\n \t}\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n-\ttoken, err = p.RawToken()\n+\ttoken, err = d.RawToken()\n \tif token != nil {\n \t\tt.Errorf(\"expected a nil token; got %#v\", token)\n \t}\n@@ -213,9 +212,9 @@ func TestRawTokenAltEncodingNoConverter(t *testing.T) {\n \t}\n }\n \n-func testRawToken(t *testing.T, p *Parser, rawTokens []Token) {\n+func testRawToken(t *testing.T, d *Decoder, rawTokens []Token) {\n \tfor i, want := range rawTokens {\n-\t\thave, err := p.RawToken()\n+\t\thave, err := d.RawToken()\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"token %d: unexpected error: %s\", i, err)\n \t\t}\n@@ -258,10 +257,10 @@ var nestedDirectivesTokens = []Token{\n }\n \n func TestNestedDirectives(t *testing.T) {\n-\tp := NewParser(strings.NewReader(nestedDirectivesInput))\n+\td := NewDecoder(strings.NewReader(nestedDirectivesInput))\n \n \tfor i, want := range nestedDirectivesTokens {\n-\t\thave, err := p.Token()\n+\t\thave, err := d.Token()\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"token %d: unexpected error: %s\", i, err)\n \t\t}\n@@ -272,10 +271,10 @@ func TestNestedDirectives(t *testing.T) {\n }\n \n func TestToken(t *testing.T) {\n-\tp := NewParser(strings.NewReader(testInput))\n+\td := NewDecoder(strings.NewReader(testInput))\n \n \tfor i, want := range cookedTokens {\n-\t\thave, err := p.Token()\n+\t\thave, err := d.Token()\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"token %d: unexpected error: %s\", i, err)\n \t\t}\n@@ -287,9 +286,9 @@ func TestToken(t *testing.T) {\n \n func TestSyntax(t *testing.T) {\n \tfor i := range xmlInput {\n-\t\tp := NewParser(strings.NewReader(xmlInput[i]))\n+\t\td := NewDecoder(strings.NewReader(xmlInput[i]))\n \t\tvar err error\n-\t\tfor _, err = p.Token(); err == nil; _, err = p.Token() {\n+\t\tfor _, err = d.Token(); err == nil; _, err = d.Token() {\n \t\t}\n \t\tif _, ok := err.(*SyntaxError); !ok {\n \t\t\tt.Fatalf(`xmlInput \"%s\": expected SyntaxError not received`, xmlInput[i])\n@@ -368,8 +367,7 @@ const testScalarsInput = `<allscalars>\n \n func TestAllScalars(t *testing.T) {\n \tvar a allScalars\n-\tbuf := bytes.NewBufferString(testScalarsInput)\n-\terr := Unmarshal(buf, &a)\n+\terr := Unmarshal([]byte(testScalarsInput), &a)\n \n \tif err != nil {\n \t\tt.Fatal(err)\n@@ -386,8 +384,7 @@ type item struct {\n func TestIssue569(t *testing.T) {\n \tdata := `<item><Field_a>abcd</Field_a></item>`\n \tvar i item\n-\tbuf := bytes.NewBufferString(data)\n-\terr := Unmarshal(buf, &i)\n+\terr := Unmarshal([]byte(data), &i)\n \n \tif err != nil || i.Field_a != \"abcd\" {\n \t\tt.Fatal(\"Expecting abcd\")\n@@ -396,9 +393,9 @@ func TestIssue569(t *testing.T) {\n \n func TestUnquotedAttrs(t *testing.T) {\n \tdata := \"<tag attr=azAZ09:-_\\t>\"\n-\tp := NewParser(strings.NewReader(data))\n-\tp.Strict = false\n-\ttoken, err := p.Token()\n+\td := NewDecoder(strings.NewReader(data))\n+\td.Strict = false\n+\ttoken, err := d.Token()\n \tif _, ok := err.(*SyntaxError); ok {\n \t\tt.Errorf(\"Unexpected error: %v\", err)\n \t}\n@@ -422,9 +419,9 @@ func TestValuelessAttrs(t *testing.T) {\n \t\t{\"<input checked />\", \"input\", \"checked\"},\n \t}\n \tfor _, test := range tests {\n-\t\tp := NewParser(strings.NewReader(test[0]))\n-\t\tp.Strict = false\n-\t\ttoken, err := p.Token()\n+\t\td := NewDecoder(strings.NewReader(test[0]))\n+\t\td.Strict = false\n+\t\ttoken, err := d.Token()\n \t\tif _, ok := err.(*SyntaxError); ok {\n \t\t\tt.Errorf(\"Unexpected error: %v\", err)\n \t\t}\n@@ -472,9 +469,9 @@ func TestCopyTokenStartElement(t *testing.T) {\n \n func TestSyntaxErrorLineNum(t *testing.T) {\n \ttestInput := \"<P>Foo<P>\\n\\n<P>Bar</>\\n\"\n-\tp := NewParser(strings.NewReader(testInput))\n+\td := NewDecoder(strings.NewReader(testInput))\n \tvar err error\n-\tfor _, err = p.Token(); err == nil; _, err = p.Token() {\n+\tfor _, err = d.Token(); err == nil; _, err = d.Token() {\n \t}\n \tsynerr, ok := err.(*SyntaxError)\n \tif !ok {\n@@ -487,41 +484,41 @@ func TestSyntaxErrorLineNum(t *testing.T) {\n \n func TestTrailingRawToken(t *testing.T) {\n \tinput := `<FOO></FOO>  `\n-\tp := NewParser(strings.NewReader(input))\n+\td := NewDecoder(strings.NewReader(input))\n \tvar err error\n-\tfor _, err = p.RawToken(); err == nil; _, err = p.RawToken() {\n+\tfor _, err = d.RawToken(); err == nil; _, err = d.RawToken() {\n \t}\n \tif err != io.EOF {\n-\t\tt.Fatalf(\"p.RawToken() = _, %v, want _, io.EOF\", err)\n+\t\tt.Fatalf(\"d.RawToken() = _, %v, want _, io.EOF\", err)\n \t}\n }\n \n func TestTrailingToken(t *testing.T) {\n \tinput := `<FOO></FOO>  `\n-\tp := NewParser(strings.NewReader(input))\n+\td := NewDecoder(strings.NewReader(input))\n \tvar err error\n-\tfor _, err = p.Token(); err == nil; _, err = p.Token() {\n+\tfor _, err = d.Token(); err == nil; _, err = d.Token() {\n \t}\n \tif err != io.EOF {\n-\t\tt.Fatalf(\"p.Token() = _, %v, want _, io.EOF\", err)\n+\t\tt.Fatalf(\"d.Token() = _, %v, want _, io.EOF\", err)\n \t}\n }\n \n func TestEntityInsideCDATA(t *testing.T) {\n \tinput := `<test><![CDATA[ &val=foo ]]></test>`\n-\tp := NewParser(strings.NewReader(input))\n+\td := NewDecoder(strings.NewReader(input))\n \tvar err error\n-\tfor _, err = p.Token(); err == nil; _, err = p.Token() {\n+\tfor _, err = d.Token(); err == nil; _, err = d.Token() {\n \t}\n \tif err != io.EOF {\n-\t\tt.Fatalf(\"p.Token() = _, %v, want _, io.EOF\", err)\n+\t\tt.Fatalf(\"d.Token() = _, %v, want _, io.EOF\", err)\n \t}\n }\n \n // The last three tests (respectively one for characters in attribute\n // names and two for character entities) pass not because of code\n // changed for issue 1259, but instead pass with the given messages\n-// from other parts of xml.Parser.  I provide these to note the\n+// from other parts of xml.Decoder.  I provide these to note the\n // current behavior of situations where one might think that character\n // range checking would detect the error, but it does not in fact.\n \n@@ -541,15 +538,15 @@ var characterTests = []struct {\n func TestDisallowedCharacters(t *testing.T) {\n \n \tfor i, tt := range characterTests {\n-\t\tp := NewParser(strings.NewReader(tt.in))\n+\t\td := NewDecoder(strings.NewReader(tt.in))\n \t\tvar err error\n \n \t\tfor err == nil {\n-\t\t\t_, err = p.Token()\n+\t\t\t_, err = d.Token()\n \t\t}\n \t\tsynerr, ok := err.(*SyntaxError)\n \t\tif !ok {\n-\t\t\tt.Fatalf(\"input %d p.Token() = _, %v, want _, *SyntaxError\", i, err)\n+\t\t\tt.Fatalf(\"input %d d.Token() = _, %v, want _, *SyntaxError\", i, err)\n \t\t}\n \t\tif synerr.Msg != tt.err {\n \t\t\tt.Fatalf(\"input %d synerr.Msg wrong: want '%s', got '%s'\", i, tt.err, synerr.Msg)"}, {"sha": "2cb5aa6ed6c83115e387aadefc91d7ee2458db5e", "filename": "libgo/go/exp/ebnflint/ebnflint.go", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Febnflint%2Febnflint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Febnflint%2Febnflint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Febnflint%2Febnflint.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"fmt\"\n \t\"go/scanner\"\n \t\"go/token\"\n+\t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n@@ -76,34 +77,46 @@ func main() {\n \tflag.Parse()\n \n \tvar (\n-\t\tfilename string\n-\t\tsrc      []byte\n-\t\terr      error\n+\t\tname string\n+\t\tr    io.Reader\n \t)\n \tswitch flag.NArg() {\n \tcase 0:\n-\t\tfilename = \"<stdin>\"\n-\t\tsrc, err = ioutil.ReadAll(os.Stdin)\n+\t\tname, r = \"<stdin>\", os.Stdin\n \tcase 1:\n-\t\tfilename = flag.Arg(0)\n-\t\tsrc, err = ioutil.ReadFile(filename)\n+\t\tname = flag.Arg(0)\n \tdefault:\n \t\tusage()\n \t}\n-\tif err != nil {\n+\n+\tif err := verify(name, *start, r); err != nil {\n \t\treport(err)\n \t}\n+}\n \n-\tif filepath.Ext(filename) == \".html\" || bytes.Index(src, open) >= 0 {\n-\t\tsrc = extractEBNF(src)\n+func verify(name, start string, r io.Reader) error {\n+\tif r == nil {\n+\t\tf, err := os.Open(name)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tdefer f.Close()\n+\t\tr = f\n \t}\n \n-\tgrammar, err := ebnf.Parse(filename, bytes.NewBuffer(src))\n+\tsrc, err := ioutil.ReadAll(r)\n \tif err != nil {\n-\t\treport(err)\n+\t\treturn err\n \t}\n \n-\tif err = ebnf.Verify(grammar, *start); err != nil {\n-\t\treport(err)\n+\tif filepath.Ext(name) == \".html\" || bytes.Index(src, open) >= 0 {\n+\t\tsrc = extractEBNF(src)\n+\t}\n+\n+\tgrammar, err := ebnf.Parse(name, bytes.NewBuffer(src))\n+\tif err != nil {\n+\t\treturn err\n \t}\n+\n+\treturn ebnf.Verify(grammar, start)\n }"}, {"sha": "875dbc19aca0976be38f90fd28443ad291be18ef", "filename": "libgo/go/exp/ebnflint/ebnflint_test.go", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Febnflint%2Febnflint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Febnflint%2Febnflint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Febnflint%2Febnflint_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"runtime\"\n+\t\"testing\"\n+)\n+\n+func TestSpec(t *testing.T) {\n+\tif err := verify(runtime.GOROOT()+\"/doc/go_spec.html\", \"SourceFile\", nil); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}"}, {"sha": "d7cc8bb9a9931f33a925b98c3a2930ddf112bf82", "filename": "libgo/go/exp/html/const.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fconst.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/const.go"}, {"sha": "56b194ffb9080c3ec6d77784a47403e9ddb7ce5c", "filename": "libgo/go/exp/html/doc.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fdoc.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/doc.go"}, {"sha": "f692061a551f7ac6df4a8571dd238de4e45b294a", "filename": "libgo/go/exp/html/doctype.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Fdoctype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Fdoctype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fdoctype.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/doctype.go"}, {"sha": "bd83075235999368865ad74c31314ef16c1ed6d7", "filename": "libgo/go/exp/html/entity.go", "status": "added", "additions": 2253, "deletions": 0, "changes": 2253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Fentity.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Fentity.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fentity.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "b53f866fa2ddff6f22e9c9c831c8eabb1d7197b2", "filename": "libgo/go/exp/html/entity_test.go", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Fentity_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Fentity_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fentity_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package html\n+\n+import (\n+\t\"testing\"\n+\t\"unicode/utf8\"\n+)\n+\n+func TestEntityLength(t *testing.T) {\n+\t// We verify that the length of UTF-8 encoding of each value is <= 1 + len(key).\n+\t// The +1 comes from the leading \"&\". This property implies that the length of\n+\t// unescaped text is <= the length of escaped text.\n+\tfor k, v := range entity {\n+\t\tif 1+len(k) < utf8.RuneLen(v) {\n+\t\t\tt.Error(\"escaped entity &\" + k + \" is shorter than its UTF-8 encoding \" + string(v))\n+\t\t}\n+\t\tif len(k) > longestEntityWithoutSemicolon && k[len(k)-1] != ';' {\n+\t\t\tt.Errorf(\"entity name %s is %d characters, but longestEntityWithoutSemicolon=%d\", k, len(k), longestEntityWithoutSemicolon)\n+\t\t}\n+\t}\n+\tfor k, v := range entity2 {\n+\t\tif 1+len(k) < utf8.RuneLen(v[0])+utf8.RuneLen(v[1]) {\n+\t\t\tt.Error(\"escaped entity &\" + k + \" is shorter than its UTF-8 encoding \" + string(v[0]) + string(v[1]))\n+\t\t}\n+\t}\n+}"}, {"sha": "42be865ef080ad0b7c2a843da63dac852f40f25c", "filename": "libgo/go/exp/html/escape.go", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fescape.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -0,0 +1,253 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package html\n+\n+import (\n+\t\"bytes\"\n+\t\"strings\"\n+\t\"unicode/utf8\"\n+)\n+\n+// These replacements permit compatibility with old numeric entities that \n+// assumed Windows-1252 encoding.\n+// http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html#consume-a-character-reference\n+var replacementTable = [...]rune{\n+\t'\\u20AC', // First entry is what 0x80 should be replaced with.\n+\t'\\u0081',\n+\t'\\u201A',\n+\t'\\u0192',\n+\t'\\u201E',\n+\t'\\u2026',\n+\t'\\u2020',\n+\t'\\u2021',\n+\t'\\u02C6',\n+\t'\\u2030',\n+\t'\\u0160',\n+\t'\\u2039',\n+\t'\\u0152',\n+\t'\\u008D',\n+\t'\\u017D',\n+\t'\\u008F',\n+\t'\\u0090',\n+\t'\\u2018',\n+\t'\\u2019',\n+\t'\\u201C',\n+\t'\\u201D',\n+\t'\\u2022',\n+\t'\\u2013',\n+\t'\\u2014',\n+\t'\\u02DC',\n+\t'\\u2122',\n+\t'\\u0161',\n+\t'\\u203A',\n+\t'\\u0153',\n+\t'\\u009D',\n+\t'\\u017E',\n+\t'\\u0178', // Last entry is 0x9F.\n+\t// 0x00->'\\uFFFD' is handled programmatically. \n+\t// 0x0D->'\\u000D' is a no-op.\n+}\n+\n+// unescapeEntity reads an entity like \"&lt;\" from b[src:] and writes the\n+// corresponding \"<\" to b[dst:], returning the incremented dst and src cursors.\n+// Precondition: b[src] == '&' && dst <= src.\n+// attribute should be true if parsing an attribute value.\n+func unescapeEntity(b []byte, dst, src int, attribute bool) (dst1, src1 int) {\n+\t// http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html#consume-a-character-reference\n+\n+\t// i starts at 1 because we already know that s[0] == '&'.\n+\ti, s := 1, b[src:]\n+\n+\tif len(s) <= 1 {\n+\t\tb[dst] = b[src]\n+\t\treturn dst + 1, src + 1\n+\t}\n+\n+\tif s[i] == '#' {\n+\t\tif len(s) <= 3 { // We need to have at least \"&#.\".\n+\t\t\tb[dst] = b[src]\n+\t\t\treturn dst + 1, src + 1\n+\t\t}\n+\t\ti++\n+\t\tc := s[i]\n+\t\thex := false\n+\t\tif c == 'x' || c == 'X' {\n+\t\t\thex = true\n+\t\t\ti++\n+\t\t}\n+\n+\t\tx := '\\x00'\n+\t\tfor i < len(s) {\n+\t\t\tc = s[i]\n+\t\t\ti++\n+\t\t\tif hex {\n+\t\t\t\tif '0' <= c && c <= '9' {\n+\t\t\t\t\tx = 16*x + rune(c) - '0'\n+\t\t\t\t\tcontinue\n+\t\t\t\t} else if 'a' <= c && c <= 'f' {\n+\t\t\t\t\tx = 16*x + rune(c) - 'a' + 10\n+\t\t\t\t\tcontinue\n+\t\t\t\t} else if 'A' <= c && c <= 'F' {\n+\t\t\t\t\tx = 16*x + rune(c) - 'A' + 10\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t} else if '0' <= c && c <= '9' {\n+\t\t\t\tx = 10*x + rune(c) - '0'\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif c != ';' {\n+\t\t\t\ti--\n+\t\t\t}\n+\t\t\tbreak\n+\t\t}\n+\n+\t\tif i <= 3 { // No characters matched.\n+\t\t\tb[dst] = b[src]\n+\t\t\treturn dst + 1, src + 1\n+\t\t}\n+\n+\t\tif 0x80 <= x && x <= 0x9F {\n+\t\t\t// Replace characters from Windows-1252 with UTF-8 equivalents.\n+\t\t\tx = replacementTable[x-0x80]\n+\t\t} else if x == 0 || (0xD800 <= x && x <= 0xDFFF) || x > 0x10FFFF {\n+\t\t\t// Replace invalid characters with the replacement character.\n+\t\t\tx = '\\uFFFD'\n+\t\t}\n+\n+\t\treturn dst + utf8.EncodeRune(b[dst:], x), src + i\n+\t}\n+\n+\t// Consume the maximum number of characters possible, with the\n+\t// consumed characters matching one of the named references.\n+\n+\tfor i < len(s) {\n+\t\tc := s[i]\n+\t\ti++\n+\t\t// Lower-cased characters are more common in entities, so we check for them first.\n+\t\tif 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z' || '0' <= c && c <= '9' {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif c != ';' {\n+\t\t\ti--\n+\t\t}\n+\t\tbreak\n+\t}\n+\n+\tentityName := string(s[1:i])\n+\tif entityName == \"\" {\n+\t\t// No-op.\n+\t} else if attribute && entityName[len(entityName)-1] != ';' && len(s) > i && s[i] == '=' {\n+\t\t// No-op.\n+\t} else if x := entity[entityName]; x != 0 {\n+\t\treturn dst + utf8.EncodeRune(b[dst:], x), src + i\n+\t} else if x := entity2[entityName]; x[0] != 0 {\n+\t\tdst1 := dst + utf8.EncodeRune(b[dst:], x[0])\n+\t\treturn dst1 + utf8.EncodeRune(b[dst1:], x[1]), src + i\n+\t} else if !attribute {\n+\t\tmaxLen := len(entityName) - 1\n+\t\tif maxLen > longestEntityWithoutSemicolon {\n+\t\t\tmaxLen = longestEntityWithoutSemicolon\n+\t\t}\n+\t\tfor j := maxLen; j > 1; j-- {\n+\t\t\tif x := entity[entityName[:j]]; x != 0 {\n+\t\t\t\treturn dst + utf8.EncodeRune(b[dst:], x), src + j + 1\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tdst1, src1 = dst+i, src+i\n+\tcopy(b[dst:dst1], b[src:src1])\n+\treturn dst1, src1\n+}\n+\n+// unescape unescapes b's entities in-place, so that \"a&lt;b\" becomes \"a<b\".\n+func unescape(b []byte) []byte {\n+\tfor i, c := range b {\n+\t\tif c == '&' {\n+\t\t\tdst, src := unescapeEntity(b, i, i, false)\n+\t\t\tfor src < len(b) {\n+\t\t\t\tc := b[src]\n+\t\t\t\tif c == '&' {\n+\t\t\t\t\tdst, src = unescapeEntity(b, dst, src, false)\n+\t\t\t\t} else {\n+\t\t\t\t\tb[dst] = c\n+\t\t\t\t\tdst, src = dst+1, src+1\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn b[0:dst]\n+\t\t}\n+\t}\n+\treturn b\n+}\n+\n+// lower lower-cases the A-Z bytes in b in-place, so that \"aBc\" becomes \"abc\".\n+func lower(b []byte) []byte {\n+\tfor i, c := range b {\n+\t\tif 'A' <= c && c <= 'Z' {\n+\t\t\tb[i] = c + 'a' - 'A'\n+\t\t}\n+\t}\n+\treturn b\n+}\n+\n+const escapedChars = `&'<>\"`\n+\n+func escape(w writer, s string) error {\n+\ti := strings.IndexAny(s, escapedChars)\n+\tfor i != -1 {\n+\t\tif _, err := w.WriteString(s[:i]); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tvar esc string\n+\t\tswitch s[i] {\n+\t\tcase '&':\n+\t\t\tesc = \"&amp;\"\n+\t\tcase '\\'':\n+\t\t\tesc = \"&apos;\"\n+\t\tcase '<':\n+\t\t\tesc = \"&lt;\"\n+\t\tcase '>':\n+\t\t\tesc = \"&gt;\"\n+\t\tcase '\"':\n+\t\t\tesc = \"&quot;\"\n+\t\tdefault:\n+\t\t\tpanic(\"unrecognized escape character\")\n+\t\t}\n+\t\ts = s[i+1:]\n+\t\tif _, err := w.WriteString(esc); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\ti = strings.IndexAny(s, escapedChars)\n+\t}\n+\t_, err := w.WriteString(s)\n+\treturn err\n+}\n+\n+// EscapeString escapes special characters like \"<\" to become \"&lt;\". It\n+// escapes only five such characters: amp, apos, lt, gt and quot.\n+// UnescapeString(EscapeString(s)) == s always holds, but the converse isn't\n+// always true.\n+func EscapeString(s string) string {\n+\tif strings.IndexAny(s, escapedChars) == -1 {\n+\t\treturn s\n+\t}\n+\tbuf := bytes.NewBuffer(nil)\n+\tescape(buf, s)\n+\treturn buf.String()\n+}\n+\n+// UnescapeString unescapes entities like \"&lt;\" to become \"<\". It unescapes a\n+// larger range of entities than EscapeString escapes. For example, \"&aacute;\"\n+// unescapes to \"\u00e1\", as does \"&#225;\" and \"&xE1;\".\n+// UnescapeString(EscapeString(s)) == s always holds, but the converse isn't\n+// always true.\n+func UnescapeString(s string) string {\n+\tfor _, c := range s {\n+\t\tif c == '&' {\n+\t\t\treturn string(unescape([]byte(s)))\n+\t\t}\n+\t}\n+\treturn s\n+}"}, {"sha": "3ba81ce4d6f1655b32a0b6bae1f5a7d97b389f9e", "filename": "libgo/go/exp/html/foreign.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Fforeign.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Fforeign.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fforeign.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/foreign.go"}, {"sha": "83f17308b18a10de4f0162bdd7621a87a57a2eb1", "filename": "libgo/go/exp/html/node.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Fnode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Fnode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fnode.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/node.go"}, {"sha": "04f4ae7533494312ae79bf591ff33902daa3bceb", "filename": "libgo/go/exp/html/parse.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fparse.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/parse.go"}, {"sha": "1528dffaafa1533304fdba8022b3db5f4b0aa648", "filename": "libgo/go/exp/html/parse_test.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fparse_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/parse_test.go"}, {"sha": "07859faa7dd833df71f5410bdf67e044ec3aa437", "filename": "libgo/go/exp/html/render.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Frender.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Frender.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Frender.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/render.go"}, {"sha": "0584f35abdb264de4d0c18a5bef7b9cd2572292d", "filename": "libgo/go/exp/html/render_test.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Frender_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Frender_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Frender_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/render_test.go"}, {"sha": "9b4c2d8be0a2dfe7e7f2ab87bb116b5ab5adeced", "filename": "libgo/go/exp/html/testdata/webkit/README", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2FREADME?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/README"}, {"sha": "787e1b01e193b68d0d85ba0047f6343b40d566e1", "filename": "libgo/go/exp/html/testdata/webkit/adoption01.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fadoption01.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fadoption01.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fadoption01.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/adoption01.dat"}, {"sha": "d18151b44f0e3a034278d9c7120119db084e832d", "filename": "libgo/go/exp/html/testdata/webkit/adoption02.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fadoption02.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fadoption02.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fadoption02.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/adoption02.dat"}, {"sha": "44f187683004b904f06f92f1ca31cbd7641ae1dd", "filename": "libgo/go/exp/html/testdata/webkit/comments01.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fcomments01.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fcomments01.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fcomments01.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/comments01.dat"}, {"sha": "ae457328a45338ed78e9d4d778906b25129e7c65", "filename": "libgo/go/exp/html/testdata/webkit/doctype01.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fdoctype01.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fdoctype01.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fdoctype01.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/doctype01.dat"}, {"sha": "c8073b7810b8dcc0340db720af2a83c9b0195db2", "filename": "libgo/go/exp/html/testdata/webkit/entities01.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fentities01.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fentities01.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fentities01.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/entities01.dat"}, {"sha": "e2fb42a078b227abc2fddc545e07404a343bae07", "filename": "libgo/go/exp/html/testdata/webkit/entities02.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fentities02.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fentities02.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fentities02.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/entities02.dat"}, {"sha": "d7cb71db0547b7816b66349d686111410a06d24a", "filename": "libgo/go/exp/html/testdata/webkit/html5test-com.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fhtml5test-com.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fhtml5test-com.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fhtml5test-com.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/html5test-com.dat"}, {"sha": "3f2bd374c033be8a0320cbac18bdce10268f6b1f", "filename": "libgo/go/exp/html/testdata/webkit/inbody01.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Finbody01.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Finbody01.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Finbody01.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/inbody01.dat"}, {"sha": "88325ffe64c5c7c83ab101b45da9e89bf3f9b73b", "filename": "libgo/go/exp/html/testdata/webkit/isindex.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fisindex.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fisindex.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fisindex.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/isindex.dat"}, {"sha": "a5ebb1eb285116af391137bc94beac0c8a6834b4", "filename": "libgo/go/exp/html/testdata/webkit/pending-spec-changes-plain-text-unsafe.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fpending-spec-changes-plain-text-unsafe.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fpending-spec-changes-plain-text-unsafe.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fpending-spec-changes-plain-text-unsafe.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/pending-spec-changes-plain-text-unsafe.dat"}, {"sha": "e00ee85d3bf4010acd0129a590a86a365cf883aa", "filename": "libgo/go/exp/html/testdata/webkit/pending-spec-changes.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fpending-spec-changes.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fpending-spec-changes.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fpending-spec-changes.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/pending-spec-changes.dat"}, {"sha": "2f40e83babcdf5d287c0bf9463388fd7c2399e7f", "filename": "libgo/go/exp/html/testdata/webkit/plain-text-unsafe.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fplain-text-unsafe.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fplain-text-unsafe.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fplain-text-unsafe.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/plain-text-unsafe.dat"}, {"sha": "76b67f4ba6085d177f0afae2eca5877d84c20984", "filename": "libgo/go/exp/html/testdata/webkit/scriptdata01.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fscriptdata01.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fscriptdata01.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fscriptdata01.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/scriptdata01.dat"}, {"sha": "4e08d0e84a0731e092670d0219934bf8f3d8ee95", "filename": "libgo/go/exp/html/testdata/webkit/scripted/adoption01.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fscripted%2Fadoption01.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fscripted%2Fadoption01.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fscripted%2Fadoption01.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/scripted/adoption01.dat"}, {"sha": "ef4a41ca00ba2396e64b838876d33ed7edd6c587", "filename": "libgo/go/exp/html/testdata/webkit/scripted/webkit01.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fscripted%2Fwebkit01.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fscripted%2Fwebkit01.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fscripted%2Fwebkit01.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/scripted/webkit01.dat"}, {"sha": "88ef1fe2ee9e85ed566f0ed4888730a1389179ca", "filename": "libgo/go/exp/html/testdata/webkit/tables01.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftables01.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftables01.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftables01.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tables01.dat"}, {"sha": "cbf8bdda638502131b08c8297bbf4f97ef250efe", "filename": "libgo/go/exp/html/testdata/webkit/tests1.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests1.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests1.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests1.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests1.dat"}, {"sha": "4f8df86f208a01514d619fe6da43ce4d519f66e5", "filename": "libgo/go/exp/html/testdata/webkit/tests10.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests10.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests10.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests10.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests10.dat"}, {"sha": "638cde479f7674a3d76b8e91b73b9470fa226894", "filename": "libgo/go/exp/html/testdata/webkit/tests11.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests11.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests11.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests11.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests11.dat"}, {"sha": "63107d277b6a7f1597155ad2527868bbc2c323de", "filename": "libgo/go/exp/html/testdata/webkit/tests12.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests12.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests12.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests12.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests12.dat"}, {"sha": "b8713f88582c2c3c11596ac1b178d4bbd1ba7c70", "filename": "libgo/go/exp/html/testdata/webkit/tests14.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests14.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests14.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests14.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests14.dat"}, {"sha": "6ce1c0d166320448002292397d28f210d2debceb", "filename": "libgo/go/exp/html/testdata/webkit/tests15.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests15.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests15.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests15.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests15.dat"}, {"sha": "937dba9f42f2261b0b93cc731cab79daba532d36", "filename": "libgo/go/exp/html/testdata/webkit/tests16.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests16.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests16.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests16.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests16.dat"}, {"sha": "7b555f888dede982c223a33f15cbcb5f382a9d83", "filename": "libgo/go/exp/html/testdata/webkit/tests17.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests17.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests17.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests17.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests17.dat"}, {"sha": "680e1f068a650d6dcee7c97c834c5cb506523328", "filename": "libgo/go/exp/html/testdata/webkit/tests18.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests18.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests18.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests18.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests18.dat"}, {"sha": "06222f5b9db0b7bb661109cb22059a6a8bc53453", "filename": "libgo/go/exp/html/testdata/webkit/tests19.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests19.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests19.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests19.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests19.dat"}, {"sha": "60d859221624e13b9b2c50b69c715a9590ba8b02", "filename": "libgo/go/exp/html/testdata/webkit/tests2.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests2.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests2.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests2.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests2.dat"}, {"sha": "6bd825608f16ba9adb89a23e91112cf19b093e9a", "filename": "libgo/go/exp/html/testdata/webkit/tests20.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests20.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests20.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests20.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests20.dat"}, {"sha": "1260ec03e2029443b1566cd9dbe80fe9b4a9c142", "filename": "libgo/go/exp/html/testdata/webkit/tests21.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests21.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests21.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests21.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests21.dat"}, {"sha": "aab27b2e904b8e2672c9a4b92305ea99b3e04587", "filename": "libgo/go/exp/html/testdata/webkit/tests22.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests22.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests22.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests22.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests22.dat"}, {"sha": "34d2a73f1c75ed52c555689d5dcfbb15a1d08987", "filename": "libgo/go/exp/html/testdata/webkit/tests23.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests23.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests23.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests23.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests23.dat"}, {"sha": "f6dc7eb48a53d7417418f8827c9a24031b5edcd7", "filename": "libgo/go/exp/html/testdata/webkit/tests24.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests24.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests24.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests24.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests24.dat"}, {"sha": "00de7295b71d411377f94fe8330be41f6a34d246", "filename": "libgo/go/exp/html/testdata/webkit/tests25.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests25.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests25.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests25.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests25.dat"}, {"sha": "da128e7794bfe159e581c62bac0bbc9dd7e48aee", "filename": "libgo/go/exp/html/testdata/webkit/tests26.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests26.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests26.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests26.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests26.dat"}, {"sha": "38dc501be352ae2a11b509e448c1bf64bbcf5307", "filename": "libgo/go/exp/html/testdata/webkit/tests3.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests3.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests3.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests3.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests3.dat"}, {"sha": "3c506326d1f1318e1955e0a60a5bb968513d422a", "filename": "libgo/go/exp/html/testdata/webkit/tests4.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests4.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests4.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests4.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests4.dat"}, {"sha": "d7b5128a44d89a4cc5244073a3f13c53a0666466", "filename": "libgo/go/exp/html/testdata/webkit/tests5.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests5.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests5.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests5.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests5.dat"}, {"sha": "f28ece4fb007f0fe0a03f93a4b0714fc3c8cc59c", "filename": "libgo/go/exp/html/testdata/webkit/tests6.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests6.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests6.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests6.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests6.dat"}, {"sha": "f5193c660bcac9e815344046edcca5212bd550c5", "filename": "libgo/go/exp/html/testdata/webkit/tests7.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests7.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests7.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests7.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests7.dat"}, {"sha": "90e6c919e8463a1e2c53df1ba3a67b4f166342f0", "filename": "libgo/go/exp/html/testdata/webkit/tests8.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests8.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests8.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests8.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests8.dat"}, {"sha": "554e27aecf6ded5bdb2d247d7550fbd05d57c262", "filename": "libgo/go/exp/html/testdata/webkit/tests9.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests9.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests9.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests9.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests9.dat"}, {"sha": "052fac7d5541fdf434529df1d5cf237ef2e45a7d", "filename": "libgo/go/exp/html/testdata/webkit/tests_innerHTML_1.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests_innerHTML_1.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests_innerHTML_1.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftests_innerHTML_1.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tests_innerHTML_1.dat"}, {"sha": "0841992448623b2730c58be384ba1112f15f0bf5", "filename": "libgo/go/exp/html/testdata/webkit/tricky01.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftricky01.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftricky01.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Ftricky01.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/tricky01.dat"}, {"sha": "4101b216e18bcfddc15f7c39f4b0019af81729e7", "filename": "libgo/go/exp/html/testdata/webkit/webkit01.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fwebkit01.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fwebkit01.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fwebkit01.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/webkit01.dat"}, {"sha": "2218f4298c5ff47f03746d415ac7c48392306a65", "filename": "libgo/go/exp/html/testdata/webkit/webkit02.dat", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fwebkit02.dat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fwebkit02.dat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftestdata%2Fwebkit%2Fwebkit02.dat?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/testdata/webkit/webkit02.dat"}, {"sha": "5a385a1b5c544df4fd762e0e6e7c926d4a825b4e", "filename": "libgo/go/exp/html/token.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/token.go"}, {"sha": "672d60c420940b558f85822013faa9b82d0e80ed", "filename": "libgo/go/exp/html/token_test.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/html/token_test.go"}, {"sha": "9044a72fd476ffd31caad9e6372c29639f867ca7", "filename": "libgo/go/exp/norm/tables.go", "status": "modified", "additions": 52, "deletions": 57, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -2804,12 +2804,12 @@ var nfcDecompSparseValues = [341]valueRange{\n \t{value: 0x0005, lo: 0x01},\n \t{value: 0x068d, lo: 0xa2, hi: 0xa6},\n \t// Block 0xc, offset 0xd\n-\t{value: 0x0005, lo: 0x03},\n+\t{value: 0x0000, lo: 0x03},\n \t{value: 0x06ba, lo: 0x80, hi: 0x80},\n \t{value: 0x06bf, lo: 0x82, hi: 0x82},\n \t{value: 0x06c4, lo: 0x93, hi: 0x93},\n \t// Block 0xd, offset 0xe\n-\t{value: 0x0007, lo: 0x03},\n+\t{value: 0x0000, lo: 0x03},\n \t{value: 0x06c9, lo: 0xa9, hi: 0xa9},\n \t{value: 0x06d0, lo: 0xb1, hi: 0xb1},\n \t{value: 0x06d7, lo: 0xb4, hi: 0xb4},\n@@ -2822,7 +2822,7 @@ var nfcDecompSparseValues = [341]valueRange{\n \t{value: 0x0724, lo: 0x9c, hi: 0x9d},\n \t{value: 0x0732, lo: 0x9f, hi: 0x9f},\n \t// Block 0x10, offset 0x11\n-\t{value: 0x0007, lo: 0x02},\n+\t{value: 0x0000, lo: 0x02},\n \t{value: 0x0739, lo: 0xb3, hi: 0xb3},\n \t{value: 0x0740, lo: 0xb6, hi: 0xb6},\n \t// Block 0x11, offset 0x12\n@@ -2868,7 +2868,7 @@ var nfcDecompSparseValues = [341]valueRange{\n \t{value: 0x0854, lo: 0xb5, hi: 0xb6},\n \t{value: 0x086c, lo: 0xb8, hi: 0xb8},\n \t// Block 0x1a, offset 0x1b\n-\t{value: 0x0007, lo: 0x07},\n+\t{value: 0x0000, lo: 0x07},\n \t{value: 0x087d, lo: 0x81, hi: 0x81},\n \t{value: 0x0884, lo: 0x93, hi: 0x93},\n \t{value: 0x088b, lo: 0x9d, hi: 0x9d},\n@@ -2880,7 +2880,7 @@ var nfcDecompSparseValues = [341]valueRange{\n \t{value: 0x0000, lo: 0x01},\n \t{value: 0x08ae, lo: 0xa6, hi: 0xa6},\n \t// Block 0x1c, offset 0x1d\n-\t{value: 0x0007, lo: 0x08},\n+\t{value: 0x0000, lo: 0x08},\n \t{value: 0x08b9, lo: 0x86, hi: 0x86},\n \t{value: 0x08c0, lo: 0x88, hi: 0x88},\n \t{value: 0x08c7, lo: 0x8a, hi: 0x8a},\n@@ -2924,7 +2924,7 @@ var nfcDecompSparseValues = [341]valueRange{\n \t{value: 0x0006, lo: 0x01},\n \t{value: 0x15b1, lo: 0x8d, hi: 0x8f},\n \t// Block 0x23, offset 0x24\n-\t{value: 0x0006, lo: 0x05},\n+\t{value: 0x0000, lo: 0x05},\n \t{value: 0x15c3, lo: 0x84, hi: 0x84},\n \t{value: 0x15c9, lo: 0x89, hi: 0x89},\n \t{value: 0x15cf, lo: 0x8c, hi: 0x8c},\n@@ -2960,7 +2960,7 @@ var nfcDecompSparseValues = [341]valueRange{\n \t{value: 0x0000, lo: 0x01},\n \t{value: 0x1814, lo: 0x9c, hi: 0x9c},\n \t// Block 0x29, offset 0x2a\n-\t{value: 0x0007, lo: 0x0c},\n+\t{value: 0x0000, lo: 0x0c},\n \t{value: 0x1c39, lo: 0x94, hi: 0x94},\n \t{value: 0x1c4a, lo: 0x9e, hi: 0x9e},\n \t{value: 0x1c58, lo: 0xac, hi: 0xac},\n@@ -3084,7 +3084,7 @@ var nfcDecompSparseValues = [341]valueRange{\n \t{value: 0x3191, lo: 0x83, hi: 0x84},\n \t{value: 0x319b, lo: 0x86, hi: 0x8e},\n \t// Block 0x33, offset 0x34\n-\t{value: 0x0009, lo: 0x03},\n+\t{value: 0x0000, lo: 0x03},\n \t{value: 0x3a73, lo: 0x9a, hi: 0x9a},\n \t{value: 0x3a7c, lo: 0x9c, hi: 0x9c},\n \t{value: 0x3a85, lo: 0xab, hi: 0xab},\n@@ -3897,10 +3897,10 @@ var nfkcDecompValues = [4224]uint16{\n }\n \n // nfkcDecompSparseOffset: 93 entries, 186 bytes\n-var nfkcDecompSparseOffset = []uint16{0x0, 0xc, 0x16, 0x1e, 0x24, 0x27, 0x31, 0x37, 0x3e, 0x44, 0x4c, 0x59, 0x60, 0x66, 0x6e, 0x70, 0x72, 0x74, 0x78, 0x7c, 0x7e, 0x82, 0x85, 0x88, 0x8c, 0x8e, 0x90, 0x92, 0x96, 0x98, 0x9c, 0x9e, 0xa0, 0xa2, 0xa4, 0xae, 0xb6, 0xb8, 0xba, 0xc3, 0xc6, 0xcd, 0xd8, 0xe6, 0xf4, 0xfe, 0x102, 0x104, 0x10e, 0x11a, 0x11f, 0x122, 0x124, 0x126, 0x129, 0x12b, 0x12d, 0x12f, 0x131, 0x133, 0x135, 0x137, 0x139, 0x13b, 0x140, 0x14f, 0x15d, 0x15f, 0x161, 0x169, 0x179, 0x17b, 0x186, 0x18d, 0x198, 0x1a4, 0x1b5, 0x1c6, 0x1cd, 0x1de, 0x1ec, 0x1fa, 0x209, 0x21a, 0x21f, 0x22c, 0x230, 0x234, 0x238, 0x23a, 0x249, 0x24b, 0x24f}\n+var nfkcDecompSparseOffset = []uint16{0x0, 0xc, 0x16, 0x1e, 0x24, 0x27, 0x31, 0x37, 0x3e, 0x44, 0x4c, 0x59, 0x60, 0x66, 0x6e, 0x70, 0x72, 0x74, 0x78, 0x7c, 0x7e, 0x82, 0x85, 0x88, 0x8c, 0x8e, 0x90, 0x92, 0x96, 0x98, 0x9c, 0x9e, 0xa0, 0xa2, 0xa4, 0xae, 0xb6, 0xb8, 0xba, 0xc3, 0xc6, 0xcd, 0xd8, 0xe6, 0xf4, 0xfe, 0x102, 0x104, 0x10c, 0x118, 0x11d, 0x120, 0x122, 0x124, 0x127, 0x129, 0x12b, 0x12d, 0x12f, 0x131, 0x133, 0x135, 0x137, 0x139, 0x13e, 0x14d, 0x15b, 0x15d, 0x15f, 0x167, 0x177, 0x179, 0x184, 0x18b, 0x196, 0x1a2, 0x1b3, 0x1c4, 0x1cb, 0x1dc, 0x1ea, 0x1f8, 0x207, 0x218, 0x21d, 0x22a, 0x22e, 0x232, 0x236, 0x238, 0x247, 0x249, 0x24d}\n \n-// nfkcDecompSparseValues: 605 entries, 2420 bytes\n-var nfkcDecompSparseValues = [605]valueRange{\n+// nfkcDecompSparseValues: 603 entries, 2412 bytes\n+var nfkcDecompSparseValues = [603]valueRange{\n \t// Block 0x0, offset 0x1\n \t{value: 0x0002, lo: 0x0b},\n \t{value: 0x0001, lo: 0xa0, hi: 0xa0},\n@@ -4035,12 +4035,12 @@ var nfkcDecompSparseValues = [605]valueRange{\n \t{value: 0x0005, lo: 0x01},\n \t{value: 0x06a6, lo: 0xb5, hi: 0xb8},\n \t// Block 0x11, offset 0x12\n-\t{value: 0x0005, lo: 0x03},\n+\t{value: 0x0000, lo: 0x03},\n \t{value: 0x06ba, lo: 0x80, hi: 0x80},\n \t{value: 0x06bf, lo: 0x82, hi: 0x82},\n \t{value: 0x06c4, lo: 0x93, hi: 0x93},\n \t// Block 0x12, offset 0x13\n-\t{value: 0x0007, lo: 0x03},\n+\t{value: 0x0000, lo: 0x03},\n \t{value: 0x06c9, lo: 0xa9, hi: 0xa9},\n \t{value: 0x06d0, lo: 0xb1, hi: 0xb1},\n \t{value: 0x06d7, lo: 0xb4, hi: 0xb4},\n@@ -4053,7 +4053,7 @@ var nfkcDecompSparseValues = [605]valueRange{\n \t{value: 0x0724, lo: 0x9c, hi: 0x9d},\n \t{value: 0x0732, lo: 0x9f, hi: 0x9f},\n \t// Block 0x15, offset 0x16\n-\t{value: 0x0007, lo: 0x02},\n+\t{value: 0x0000, lo: 0x02},\n \t{value: 0x0739, lo: 0xb3, hi: 0xb3},\n \t{value: 0x0740, lo: 0xb6, hi: 0xb6},\n \t// Block 0x16, offset 0x17\n@@ -4111,7 +4111,7 @@ var nfkcDecompSparseValues = [605]valueRange{\n \t{value: 0x0854, lo: 0xb5, hi: 0xb7},\n \t{value: 0x086c, lo: 0xb8, hi: 0xb9},\n \t// Block 0x23, offset 0x24\n-\t{value: 0x0007, lo: 0x07},\n+\t{value: 0x0000, lo: 0x07},\n \t{value: 0x087d, lo: 0x81, hi: 0x81},\n \t{value: 0x0884, lo: 0x93, hi: 0x93},\n \t{value: 0x088b, lo: 0x9d, hi: 0x9d},\n@@ -4126,7 +4126,7 @@ var nfkcDecompSparseValues = [605]valueRange{\n \t{value: 0x0000, lo: 0x01},\n \t{value: 0x08b5, lo: 0xbc, hi: 0xbc},\n \t// Block 0x26, offset 0x27\n-\t{value: 0x0007, lo: 0x08},\n+\t{value: 0x0000, lo: 0x08},\n \t{value: 0x08b9, lo: 0x86, hi: 0x86},\n \t{value: 0x08c0, lo: 0x88, hi: 0x88},\n \t{value: 0x08c7, lo: 0x8a, hi: 0x8a},\n@@ -4209,16 +4209,14 @@ var nfkcDecompSparseValues = [605]valueRange{\n \t{value: 0x0006, lo: 0x01},\n \t{value: 0x15b1, lo: 0x8d, hi: 0x8f},\n \t// Block 0x2f, offset 0x30\n-\t{value: 0x0006, lo: 0x09},\n+\t{value: 0x0007, lo: 0x07},\n \t{value: 0x15c3, lo: 0x84, hi: 0x84},\n \t{value: 0x15c9, lo: 0x89, hi: 0x89},\n \t{value: 0x15cf, lo: 0x8c, hi: 0x8c},\n \t{value: 0x15d5, lo: 0xa4, hi: 0xa4},\n \t{value: 0x15db, lo: 0xa6, hi: 0xa6},\n-\t{value: 0x15e1, lo: 0xac, hi: 0xac},\n-\t{value: 0x15e8, lo: 0xad, hi: 0xad},\n-\t{value: 0x15f2, lo: 0xaf, hi: 0xaf},\n-\t{value: 0x15f9, lo: 0xb0, hi: 0xb0},\n+\t{value: 0x15e1, lo: 0xac, hi: 0xad},\n+\t{value: 0x15f2, lo: 0xaf, hi: 0xb0},\n \t// Block 0x30, offset 0x31\n \t{value: 0x0006, lo: 0x0b},\n \t{value: 0x1603, lo: 0x81, hi: 0x81},\n@@ -4249,9 +4247,9 @@ var nfkcDecompSparseValues = [605]valueRange{\n \t{value: 0x0000, lo: 0x01},\n \t{value: 0x17fc, lo: 0x8c, hi: 0x8c},\n \t// Block 0x35, offset 0x36\n-\t{value: 0x0004, lo: 0x02},\n-\t{value: 0x1809, lo: 0xb4, hi: 0xb5},\n-\t{value: 0x1810, lo: 0xb6, hi: 0xb6},\n+\t{value: 0x0003, lo: 0x02},\n+\t{value: 0x1809, lo: 0xb4, hi: 0xb4},\n+\t{value: 0x180d, lo: 0xb5, hi: 0xb6},\n \t// Block 0x36, offset 0x37\n \t{value: 0x0000, lo: 0x01},\n \t{value: 0x1814, lo: 0x9c, hi: 0x9c},\n@@ -4280,17 +4278,17 @@ var nfkcDecompSparseValues = [605]valueRange{\n \t{value: 0x0004, lo: 0x01},\n \t{value: 0x1b26, lo: 0x80, hi: 0x95},\n \t// Block 0x3f, offset 0x40\n-\t{value: 0x0300, lo: 0x04},\n+\t{value: 0x0004, lo: 0x04},\n \t{value: 0x0001, lo: 0x80, hi: 0x80},\n \t{value: 0x1b7e, lo: 0xb6, hi: 0xb6},\n-\t{value: 0x1882, lo: 0xb8, hi: 0xb9},\n-\t{value: 0x1b86, lo: 0xba, hi: 0xba},\n+\t{value: 0x1882, lo: 0xb8, hi: 0xb8},\n+\t{value: 0x1b82, lo: 0xb9, hi: 0xba},\n \t// Block 0x40, offset 0x41\n-\t{value: 0x0007, lo: 0x0e},\n+\t{value: 0x0005, lo: 0x0e},\n \t{value: 0x1c39, lo: 0x94, hi: 0x94},\n-\t{value: 0x1c40, lo: 0x9b, hi: 0x9b},\n-\t{value: 0x1c45, lo: 0x9c, hi: 0x9c},\n-\t{value: 0x1c4a, lo: 0x9e, hi: 0x9f},\n+\t{value: 0x1c40, lo: 0x9b, hi: 0x9c},\n+\t{value: 0x1c4a, lo: 0x9e, hi: 0x9e},\n+\t{value: 0x1c51, lo: 0x9f, hi: 0x9f},\n \t{value: 0x1c58, lo: 0xac, hi: 0xac},\n \t{value: 0x1c5f, lo: 0xae, hi: 0xae},\n \t{value: 0x1c66, lo: 0xb0, hi: 0xb0},\n@@ -4543,7 +4541,7 @@ var nfkcDecompSparseValues = [605]valueRange{\n \t{value: 0x3a53, lo: 0xa6, hi: 0xa6},\n \t{value: 0x3a57, lo: 0xa8, hi: 0xae},\n \t// Block 0x55, offset 0x56\n-\t{value: 0x0009, lo: 0x03},\n+\t{value: 0x0000, lo: 0x03},\n \t{value: 0x3a73, lo: 0x9a, hi: 0x9a},\n \t{value: 0x3a7c, lo: 0x9c, hi: 0x9c},\n \t{value: 0x3a85, lo: 0xab, hi: 0xab},\n@@ -5760,10 +5758,10 @@ var charInfoValues = [1024]uint16{\n }\n \n // charInfoSparseOffset: 156 entries, 312 bytes\n-var charInfoSparseOffset = []uint16{0x0, 0x8, 0x13, 0x21, 0x25, 0x2f, 0x36, 0x39, 0x3c, 0x4a, 0x56, 0x58, 0x62, 0x67, 0x6e, 0x7d, 0x8a, 0x92, 0x96, 0x9b, 0x9d, 0xa5, 0xab, 0xae, 0xb5, 0xb9, 0xbd, 0xbf, 0xc1, 0xc8, 0xcc, 0xd1, 0xd7, 0xda, 0xe3, 0xe5, 0xed, 0xf1, 0xf3, 0xf6, 0xf9, 0xff, 0x10f, 0x11b, 0x11d, 0x123, 0x125, 0x127, 0x129, 0x12b, 0x12d, 0x12f, 0x131, 0x134, 0x137, 0x139, 0x13c, 0x13f, 0x143, 0x152, 0x15a, 0x15c, 0x15f, 0x161, 0x16a, 0x16e, 0x172, 0x174, 0x183, 0x187, 0x18d, 0x195, 0x199, 0x1a2, 0x1ab, 0x1b6, 0x1bc, 0x1c0, 0x1ce, 0x1dd, 0x1e1, 0x1e8, 0x1ed, 0x1fc, 0x208, 0x20b, 0x20d, 0x20f, 0x211, 0x213, 0x215, 0x217, 0x219, 0x21b, 0x21d, 0x220, 0x222, 0x224, 0x226, 0x228, 0x231, 0x233, 0x236, 0x239, 0x23c, 0x23e, 0x241, 0x243, 0x245, 0x247, 0x24a, 0x24c, 0x24e, 0x250, 0x252, 0x258, 0x25a, 0x25c, 0x25e, 0x260, 0x262, 0x26c, 0x26f, 0x271, 0x27b, 0x280, 0x282, 0x284, 0x286, 0x288, 0x28b, 0x28e, 0x292, 0x29a, 0x29c, 0x29e, 0x2a5, 0x2a7, 0x2ae, 0x2b6, 0x2bd, 0x2c3, 0x2c5, 0x2c7, 0x2ca, 0x2d3, 0x2d6, 0x2dd, 0x2e2, 0x2e5, 0x2e8, 0x2ec, 0x2ee, 0x2f0, 0x2f3, 0x2f6}\n+var charInfoSparseOffset = []uint16{0x0, 0x8, 0x13, 0x21, 0x25, 0x2f, 0x36, 0x39, 0x3c, 0x4a, 0x56, 0x58, 0x62, 0x67, 0x6e, 0x7d, 0x8a, 0x92, 0x96, 0x9b, 0x9d, 0xa5, 0xab, 0xae, 0xb5, 0xb9, 0xbd, 0xbf, 0xc1, 0xc8, 0xcc, 0xd1, 0xd6, 0xd9, 0xe2, 0xe4, 0xec, 0xf0, 0xf2, 0xf5, 0xf8, 0xfe, 0x10e, 0x11a, 0x11c, 0x122, 0x124, 0x126, 0x128, 0x12a, 0x12c, 0x12e, 0x130, 0x133, 0x136, 0x138, 0x13b, 0x13e, 0x142, 0x151, 0x159, 0x15b, 0x15e, 0x160, 0x169, 0x16d, 0x171, 0x173, 0x182, 0x186, 0x18c, 0x194, 0x198, 0x1a1, 0x1aa, 0x1b5, 0x1bb, 0x1bf, 0x1cd, 0x1dc, 0x1e0, 0x1e7, 0x1ec, 0x1fa, 0x206, 0x209, 0x20b, 0x20d, 0x20f, 0x211, 0x213, 0x215, 0x217, 0x219, 0x21b, 0x21e, 0x220, 0x222, 0x224, 0x226, 0x22f, 0x231, 0x234, 0x237, 0x23a, 0x23c, 0x23f, 0x241, 0x243, 0x245, 0x248, 0x24a, 0x24c, 0x24e, 0x250, 0x256, 0x258, 0x25a, 0x25c, 0x25e, 0x260, 0x26a, 0x26d, 0x26f, 0x279, 0x27e, 0x280, 0x282, 0x284, 0x286, 0x289, 0x28c, 0x290, 0x298, 0x29a, 0x29c, 0x2a3, 0x2a5, 0x2ab, 0x2b3, 0x2ba, 0x2c0, 0x2c2, 0x2c4, 0x2c7, 0x2d0, 0x2d3, 0x2da, 0x2df, 0x2e2, 0x2e5, 0x2e9, 0x2eb, 0x2ed, 0x2f0, 0x2f3}\n \n-// charInfoSparseValues: 760 entries, 3040 bytes\n-var charInfoSparseValues = [760]valueRange{\n+// charInfoSparseValues: 757 entries, 3028 bytes\n+var charInfoSparseValues = [757]valueRange{\n \t// Block 0x0, offset 0x1\n \t{value: 0x0000, lo: 0x07},\n \t{value: 0x3000, lo: 0xa0, hi: 0xa0},\n@@ -5942,7 +5940,7 @@ var charInfoSparseValues = [760]valueRange{\n \t{value: 0x0000, lo: 0x01},\n \t{value: 0x00dc, lo: 0x99, hi: 0x9b},\n \t// Block 0x14, offset 0x15\n-\t{value: 0x7700, lo: 0x07},\n+\t{value: 0x0000, lo: 0x07},\n \t{value: 0x8800, lo: 0xa8, hi: 0xa8},\n \t{value: 0x1100, lo: 0xa9, hi: 0xa9},\n \t{value: 0x8800, lo: 0xb0, hi: 0xb0},\n@@ -5958,7 +5956,7 @@ var charInfoSparseValues = [760]valueRange{\n \t{value: 0x00e6, lo: 0x93, hi: 0x94},\n \t{value: 0x3300, lo: 0x98, hi: 0x9f},\n \t// Block 0x16, offset 0x17\n-\t{value: 0x65f9, lo: 0x02},\n+\t{value: 0x0000, lo: 0x02},\n \t{value: 0x0007, lo: 0xbc, hi: 0xbc},\n \t{value: 0x6600, lo: 0xbe, hi: 0xbe},\n \t// Block 0x17, offset 0x18\n@@ -5994,7 +5992,7 @@ var charInfoSparseValues = [760]valueRange{\n \t{value: 0x6600, lo: 0x96, hi: 0x97},\n \t{value: 0x3300, lo: 0x9c, hi: 0x9d},\n \t// Block 0x1d, offset 0x1e\n-\t{value: 0x5500, lo: 0x03},\n+\t{value: 0x0000, lo: 0x03},\n \t{value: 0x8800, lo: 0x92, hi: 0x92},\n \t{value: 0x1100, lo: 0x94, hi: 0x94},\n \t{value: 0x6600, lo: 0xbe, hi: 0xbe},\n@@ -6005,14 +6003,13 @@ var charInfoSparseValues = [760]valueRange{\n \t{value: 0x0009, lo: 0x8d, hi: 0x8d},\n \t{value: 0x6600, lo: 0x97, hi: 0x97},\n \t// Block 0x1f, offset 0x20\n-\t{value: 0x004b, lo: 0x05},\n+\t{value: 0x6607, lo: 0x04},\n \t{value: 0x8800, lo: 0x86, hi: 0x86},\n \t{value: 0x1100, lo: 0x88, hi: 0x88},\n \t{value: 0x0009, lo: 0x8d, hi: 0x8d},\n-\t{value: 0x0054, lo: 0x95, hi: 0x95},\n-\t{value: 0x665b, lo: 0x96, hi: 0x96},\n+\t{value: 0x0054, lo: 0x95, hi: 0x96},\n \t// Block 0x20, offset 0x21\n-\t{value: 0x87f9, lo: 0x02},\n+\t{value: 0x0000, lo: 0x02},\n \t{value: 0x0007, lo: 0xbc, hi: 0xbc},\n \t{value: 0x8800, lo: 0xbf, hi: 0xbf},\n \t// Block 0x21, offset 0x22\n@@ -6126,7 +6123,7 @@ var charInfoSparseValues = [760]valueRange{\n \t{value: 0x0009, lo: 0x94, hi: 0x94},\n \t{value: 0x0009, lo: 0xb4, hi: 0xb4},\n \t// Block 0x35, offset 0x36\n-\t{value: 0x00dd, lo: 0x02},\n+\t{value: 0x0000, lo: 0x02},\n \t{value: 0x0009, lo: 0x92, hi: 0x92},\n \t{value: 0x00e6, lo: 0x9d, hi: 0x9d},\n \t// Block 0x36, offset 0x37\n@@ -6340,20 +6337,19 @@ var charInfoSparseValues = [760]valueRange{\n \t{value: 0x8800, lo: 0x92, hi: 0x92},\n \t{value: 0x8800, lo: 0x94, hi: 0x94},\n \t// Block 0x52, offset 0x53\n-\t{value: 0x7700, lo: 0x0e},\n+\t{value: 0x0000, lo: 0x0d},\n \t{value: 0x8800, lo: 0x83, hi: 0x83},\n \t{value: 0x1100, lo: 0x84, hi: 0x84},\n \t{value: 0x8800, lo: 0x88, hi: 0x88},\n \t{value: 0x1100, lo: 0x89, hi: 0x89},\n \t{value: 0x8800, lo: 0x8b, hi: 0x8b},\n \t{value: 0x1100, lo: 0x8c, hi: 0x8c},\n \t{value: 0x8800, lo: 0xa3, hi: 0xa3},\n-\t{value: 0x1100, lo: 0xa4, hi: 0xa5},\n+\t{value: 0x1100, lo: 0xa4, hi: 0xa4},\n+\t{value: 0x8800, lo: 0xa5, hi: 0xa5},\n \t{value: 0x1100, lo: 0xa6, hi: 0xa6},\n-\t{value: 0x3000, lo: 0xac, hi: 0xac},\n-\t{value: 0x3000, lo: 0xad, hi: 0xad},\n-\t{value: 0x3000, lo: 0xaf, hi: 0xaf},\n-\t{value: 0x3000, lo: 0xb0, hi: 0xb0},\n+\t{value: 0x3000, lo: 0xac, hi: 0xad},\n+\t{value: 0x3000, lo: 0xaf, hi: 0xb0},\n \t{value: 0x8800, lo: 0xbc, hi: 0xbc},\n \t// Block 0x53, offset 0x54\n \t{value: 0x0000, lo: 0x0b},\n@@ -6581,22 +6577,21 @@ var charInfoSparseValues = [760]valueRange{\n \t{value: 0x0000, lo: 0x01},\n \t{value: 0x00dc, lo: 0xbd, hi: 0xbd},\n \t// Block 0x89, offset 0x8a\n-\t{value: 0x0000, lo: 0x06},\n+\t{value: 0x00db, lo: 0x05},\n \t{value: 0x00dc, lo: 0x8d, hi: 0x8d},\n \t{value: 0x00e6, lo: 0x8f, hi: 0x8f},\n \t{value: 0x00e6, lo: 0xb8, hi: 0xb8},\n-\t{value: 0x0001, lo: 0xb9, hi: 0xb9},\n-\t{value: 0x00dc, lo: 0xba, hi: 0xba},\n+\t{value: 0x0001, lo: 0xb9, hi: 0xba},\n \t{value: 0x0009, lo: 0xbf, hi: 0xbf},\n \t// Block 0x8a, offset 0x8b\n-\t{value: 0x7700, lo: 0x07},\n+\t{value: 0x65fe, lo: 0x07},\n \t{value: 0x8800, lo: 0x99, hi: 0x99},\n-\t{value: 0x1100, lo: 0x9a, hi: 0x9b},\n+\t{value: 0x1100, lo: 0x9a, hi: 0x9a},\n+\t{value: 0x8800, lo: 0x9b, hi: 0x9b},\n \t{value: 0x1100, lo: 0x9c, hi: 0x9c},\n \t{value: 0x8800, lo: 0xa5, hi: 0xa5},\n \t{value: 0x1100, lo: 0xab, hi: 0xab},\n-\t{value: 0x0009, lo: 0xb9, hi: 0xb9},\n-\t{value: 0x6607, lo: 0xba, hi: 0xba},\n+\t{value: 0x0009, lo: 0xb9, hi: 0xba},\n \t// Block 0x8b, offset 0x8c\n \t{value: 0x0000, lo: 0x06},\n \t{value: 0x3300, lo: 0x9e, hi: 0xa4},\n@@ -6768,4 +6763,4 @@ var charInfoLookup = [1152]uint8{\n \n var charInfoTrie = trie{charInfoLookup[:], charInfoValues[:], charInfoSparseValues[:], charInfoSparseOffset[:], 16}\n \n-// Total size of tables: 48KB (48756 bytes)\n+// Total size of tables: 48KB (48736 bytes)"}, {"sha": "4ad9e0e057c7cb3063bc70185d62e6e76dcb6a8f", "filename": "libgo/go/exp/norm/triegen.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fnorm%2Ftriegen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fexp%2Fnorm%2Ftriegen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftriegen.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "patch": "@@ -65,11 +65,13 @@ func (n trieNode) mostFrequentStride() int {\n \t\t\t\tcounts[stride]++\n \t\t\t}\n \t\t\tv = t.value\n+\t\t} else {\n+\t\t\tv = 0\n \t\t}\n \t}\n \tvar maxs, maxc int\n \tfor stride, cnt := range counts {\n-\t\tif cnt > maxc {\n+\t\tif cnt > maxc || (cnt == maxc && stride < maxs) {\n \t\t\tmaxs, maxc = stride, cnt\n \t\t}\n \t}"}, {"sha": "4830a1d6bfd3ae02a4771bd59b0c0b8f247baefd", "filename": "libgo/go/exp/spdy/read.go", "status": "removed", "additions": 0, "deletions": 312, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fspdy%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fspdy%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fspdy%2Fread.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,312 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package spdy\n-\n-import (\n-\t\"compress/zlib\"\n-\t\"encoding/binary\"\n-\t\"io\"\n-\t\"net/http\"\n-\t\"strings\"\n-)\n-\n-func (frame *SynStreamFrame) read(h ControlFrameHeader, f *Framer) error {\n-\treturn f.readSynStreamFrame(h, frame)\n-}\n-\n-func (frame *SynReplyFrame) read(h ControlFrameHeader, f *Framer) error {\n-\treturn f.readSynReplyFrame(h, frame)\n-}\n-\n-func (frame *RstStreamFrame) read(h ControlFrameHeader, f *Framer) error {\n-\tframe.CFHeader = h\n-\tif err := binary.Read(f.r, binary.BigEndian, &frame.StreamId); err != nil {\n-\t\treturn err\n-\t}\n-\tif err := binary.Read(f.r, binary.BigEndian, &frame.Status); err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-\n-func (frame *SettingsFrame) read(h ControlFrameHeader, f *Framer) error {\n-\tframe.CFHeader = h\n-\tvar numSettings uint32\n-\tif err := binary.Read(f.r, binary.BigEndian, &numSettings); err != nil {\n-\t\treturn err\n-\t}\n-\tframe.FlagIdValues = make([]SettingsFlagIdValue, numSettings)\n-\tfor i := uint32(0); i < numSettings; i++ {\n-\t\tif err := binary.Read(f.r, binary.BigEndian, &frame.FlagIdValues[i].Id); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tframe.FlagIdValues[i].Flag = SettingsFlag((frame.FlagIdValues[i].Id & 0xff000000) >> 24)\n-\t\tframe.FlagIdValues[i].Id &= 0xffffff\n-\t\tif err := binary.Read(f.r, binary.BigEndian, &frame.FlagIdValues[i].Value); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\treturn nil\n-}\n-\n-func (frame *NoopFrame) read(h ControlFrameHeader, f *Framer) error {\n-\tframe.CFHeader = h\n-\treturn nil\n-}\n-\n-func (frame *PingFrame) read(h ControlFrameHeader, f *Framer) error {\n-\tframe.CFHeader = h\n-\tif err := binary.Read(f.r, binary.BigEndian, &frame.Id); err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-\n-func (frame *GoAwayFrame) read(h ControlFrameHeader, f *Framer) error {\n-\tframe.CFHeader = h\n-\tif err := binary.Read(f.r, binary.BigEndian, &frame.LastGoodStreamId); err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-\n-func (frame *HeadersFrame) read(h ControlFrameHeader, f *Framer) error {\n-\treturn f.readHeadersFrame(h, frame)\n-}\n-\n-func newControlFrame(frameType ControlFrameType) (controlFrame, error) {\n-\tctor, ok := cframeCtor[frameType]\n-\tif !ok {\n-\t\treturn nil, &Error{Err: InvalidControlFrame}\n-\t}\n-\treturn ctor(), nil\n-}\n-\n-var cframeCtor = map[ControlFrameType]func() controlFrame{\n-\tTypeSynStream: func() controlFrame { return new(SynStreamFrame) },\n-\tTypeSynReply:  func() controlFrame { return new(SynReplyFrame) },\n-\tTypeRstStream: func() controlFrame { return new(RstStreamFrame) },\n-\tTypeSettings:  func() controlFrame { return new(SettingsFrame) },\n-\tTypeNoop:      func() controlFrame { return new(NoopFrame) },\n-\tTypePing:      func() controlFrame { return new(PingFrame) },\n-\tTypeGoAway:    func() controlFrame { return new(GoAwayFrame) },\n-\tTypeHeaders:   func() controlFrame { return new(HeadersFrame) },\n-\t// TODO(willchan): Add TypeWindowUpdate\n-}\n-\n-func (f *Framer) uncorkHeaderDecompressor(payloadSize int64) error {\n-\tif f.headerDecompressor != nil {\n-\t\tf.headerReader.N = payloadSize\n-\t\treturn nil\n-\t}\n-\tf.headerReader = io.LimitedReader{R: f.r, N: payloadSize}\n-\tdecompressor, err := zlib.NewReaderDict(&f.headerReader, []byte(HeaderDictionary))\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tf.headerDecompressor = decompressor\n-\treturn nil\n-}\n-\n-// ReadFrame reads SPDY encoded data and returns a decompressed Frame.\n-func (f *Framer) ReadFrame() (Frame, error) {\n-\tvar firstWord uint32\n-\tif err := binary.Read(f.r, binary.BigEndian, &firstWord); err != nil {\n-\t\treturn nil, err\n-\t}\n-\tif (firstWord & 0x80000000) != 0 {\n-\t\tframeType := ControlFrameType(firstWord & 0xffff)\n-\t\tversion := uint16(0x7fff & (firstWord >> 16))\n-\t\treturn f.parseControlFrame(version, frameType)\n-\t}\n-\treturn f.parseDataFrame(firstWord & 0x7fffffff)\n-}\n-\n-func (f *Framer) parseControlFrame(version uint16, frameType ControlFrameType) (Frame, error) {\n-\tvar length uint32\n-\tif err := binary.Read(f.r, binary.BigEndian, &length); err != nil {\n-\t\treturn nil, err\n-\t}\n-\tflags := ControlFlags((length & 0xff000000) >> 24)\n-\tlength &= 0xffffff\n-\theader := ControlFrameHeader{version, frameType, flags, length}\n-\tcframe, err := newControlFrame(frameType)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tif err = cframe.read(header, f); err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn cframe, nil\n-}\n-\n-func parseHeaderValueBlock(r io.Reader, streamId uint32) (http.Header, error) {\n-\tvar numHeaders uint16\n-\tif err := binary.Read(r, binary.BigEndian, &numHeaders); err != nil {\n-\t\treturn nil, err\n-\t}\n-\tvar e error\n-\th := make(http.Header, int(numHeaders))\n-\tfor i := 0; i < int(numHeaders); i++ {\n-\t\tvar length uint16\n-\t\tif err := binary.Read(r, binary.BigEndian, &length); err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tnameBytes := make([]byte, length)\n-\t\tif _, err := io.ReadFull(r, nameBytes); err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tname := string(nameBytes)\n-\t\tif name != strings.ToLower(name) {\n-\t\t\te = &Error{UnlowercasedHeaderName, streamId}\n-\t\t\tname = strings.ToLower(name)\n-\t\t}\n-\t\tif h[name] != nil {\n-\t\t\te = &Error{DuplicateHeaders, streamId}\n-\t\t}\n-\t\tif err := binary.Read(r, binary.BigEndian, &length); err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tvalue := make([]byte, length)\n-\t\tif _, err := io.ReadFull(r, value); err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tvalueList := strings.Split(string(value), \"\\x00\")\n-\t\tfor _, v := range valueList {\n-\t\t\th.Add(name, v)\n-\t\t}\n-\t}\n-\tif e != nil {\n-\t\treturn h, e\n-\t}\n-\treturn h, nil\n-}\n-\n-func (f *Framer) readSynStreamFrame(h ControlFrameHeader, frame *SynStreamFrame) error {\n-\tframe.CFHeader = h\n-\tvar err error\n-\tif err = binary.Read(f.r, binary.BigEndian, &frame.StreamId); err != nil {\n-\t\treturn err\n-\t}\n-\tif err = binary.Read(f.r, binary.BigEndian, &frame.AssociatedToStreamId); err != nil {\n-\t\treturn err\n-\t}\n-\tif err = binary.Read(f.r, binary.BigEndian, &frame.Priority); err != nil {\n-\t\treturn err\n-\t}\n-\tframe.Priority >>= 14\n-\n-\treader := f.r\n-\tif !f.headerCompressionDisabled {\n-\t\tf.uncorkHeaderDecompressor(int64(h.length - 10))\n-\t\treader = f.headerDecompressor\n-\t}\n-\n-\tframe.Headers, err = parseHeaderValueBlock(reader, frame.StreamId)\n-\tif !f.headerCompressionDisabled && ((err == io.EOF && f.headerReader.N == 0) || f.headerReader.N != 0) {\n-\t\terr = &Error{WrongCompressedPayloadSize, 0}\n-\t}\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\t// Remove this condition when we bump Version to 3.\n-\tif Version >= 3 {\n-\t\tfor h := range frame.Headers {\n-\t\t\tif invalidReqHeaders[h] {\n-\t\t\t\treturn &Error{InvalidHeaderPresent, frame.StreamId}\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn nil\n-}\n-\n-func (f *Framer) readSynReplyFrame(h ControlFrameHeader, frame *SynReplyFrame) error {\n-\tframe.CFHeader = h\n-\tvar err error\n-\tif err = binary.Read(f.r, binary.BigEndian, &frame.StreamId); err != nil {\n-\t\treturn err\n-\t}\n-\tvar unused uint16\n-\tif err = binary.Read(f.r, binary.BigEndian, &unused); err != nil {\n-\t\treturn err\n-\t}\n-\treader := f.r\n-\tif !f.headerCompressionDisabled {\n-\t\tf.uncorkHeaderDecompressor(int64(h.length - 6))\n-\t\treader = f.headerDecompressor\n-\t}\n-\tframe.Headers, err = parseHeaderValueBlock(reader, frame.StreamId)\n-\tif !f.headerCompressionDisabled && ((err == io.EOF && f.headerReader.N == 0) || f.headerReader.N != 0) {\n-\t\terr = &Error{WrongCompressedPayloadSize, 0}\n-\t}\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\t// Remove this condition when we bump Version to 3.\n-\tif Version >= 3 {\n-\t\tfor h := range frame.Headers {\n-\t\t\tif invalidRespHeaders[h] {\n-\t\t\t\treturn &Error{InvalidHeaderPresent, frame.StreamId}\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn nil\n-}\n-\n-func (f *Framer) readHeadersFrame(h ControlFrameHeader, frame *HeadersFrame) error {\n-\tframe.CFHeader = h\n-\tvar err error\n-\tif err = binary.Read(f.r, binary.BigEndian, &frame.StreamId); err != nil {\n-\t\treturn err\n-\t}\n-\tvar unused uint16\n-\tif err = binary.Read(f.r, binary.BigEndian, &unused); err != nil {\n-\t\treturn err\n-\t}\n-\treader := f.r\n-\tif !f.headerCompressionDisabled {\n-\t\tf.uncorkHeaderDecompressor(int64(h.length - 6))\n-\t\treader = f.headerDecompressor\n-\t}\n-\tframe.Headers, err = parseHeaderValueBlock(reader, frame.StreamId)\n-\tif !f.headerCompressionDisabled && ((err == io.EOF && f.headerReader.N == 0) || f.headerReader.N != 0) {\n-\t\terr = &Error{WrongCompressedPayloadSize, 0}\n-\t}\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\t// Remove this condition when we bump Version to 3.\n-\tif Version >= 3 {\n-\t\tvar invalidHeaders map[string]bool\n-\t\tif frame.StreamId%2 == 0 {\n-\t\t\tinvalidHeaders = invalidReqHeaders\n-\t\t} else {\n-\t\t\tinvalidHeaders = invalidRespHeaders\n-\t\t}\n-\t\tfor h := range frame.Headers {\n-\t\t\tif invalidHeaders[h] {\n-\t\t\t\treturn &Error{InvalidHeaderPresent, frame.StreamId}\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn nil\n-}\n-\n-func (f *Framer) parseDataFrame(streamId uint32) (*DataFrame, error) {\n-\tvar length uint32\n-\tif err := binary.Read(f.r, binary.BigEndian, &length); err != nil {\n-\t\treturn nil, err\n-\t}\n-\tvar frame DataFrame\n-\tframe.StreamId = streamId\n-\tframe.Flags = DataFlags(length >> 24)\n-\tlength &= 0xffffff\n-\tframe.Data = make([]byte, length)\n-\tif _, err := io.ReadFull(f.r, frame.Data); err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn &frame, nil\n-}"}, {"sha": "c1cad4b37c6b3c1f22fb36a23771f209996f9e05", "filename": "libgo/go/exp/spdy/spdy_test.go", "status": "removed", "additions": 0, "deletions": 497, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fspdy%2Fspdy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fspdy%2Fspdy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fspdy%2Fspdy_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,497 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package spdy\n-\n-import (\n-\t\"bytes\"\n-\t\"io\"\n-\t\"net/http\"\n-\t\"reflect\"\n-\t\"testing\"\n-)\n-\n-func TestHeaderParsing(t *testing.T) {\n-\theaders := http.Header{\n-\t\t\"Url\":     []string{\"http://www.google.com/\"},\n-\t\t\"Method\":  []string{\"get\"},\n-\t\t\"Version\": []string{\"http/1.1\"},\n-\t}\n-\tvar headerValueBlockBuf bytes.Buffer\n-\twriteHeaderValueBlock(&headerValueBlockBuf, headers)\n-\n-\tconst bogusStreamId = 1\n-\tnewHeaders, err := parseHeaderValueBlock(&headerValueBlockBuf, bogusStreamId)\n-\tif err != nil {\n-\t\tt.Fatal(\"parseHeaderValueBlock:\", err)\n-\t}\n-\n-\tif !reflect.DeepEqual(headers, newHeaders) {\n-\t\tt.Fatal(\"got: \", newHeaders, \"\\nwant: \", headers)\n-\t}\n-}\n-\n-func TestCreateParseSynStreamFrame(t *testing.T) {\n-\tbuffer := new(bytes.Buffer)\n-\tframer := &Framer{\n-\t\theaderCompressionDisabled: true,\n-\t\tw:                         buffer,\n-\t\theaderBuf:                 new(bytes.Buffer),\n-\t\tr:                         buffer,\n-\t}\n-\tsynStreamFrame := SynStreamFrame{\n-\t\tCFHeader: ControlFrameHeader{\n-\t\t\tversion:   Version,\n-\t\t\tframeType: TypeSynStream,\n-\t\t},\n-\t\tHeaders: http.Header{\n-\t\t\t\"Url\":     []string{\"http://www.google.com/\"},\n-\t\t\t\"Method\":  []string{\"get\"},\n-\t\t\t\"Version\": []string{\"http/1.1\"},\n-\t\t},\n-\t}\n-\tif err := framer.WriteFrame(&synStreamFrame); err != nil {\n-\t\tt.Fatal(\"WriteFrame without compression:\", err)\n-\t}\n-\tframe, err := framer.ReadFrame()\n-\tif err != nil {\n-\t\tt.Fatal(\"ReadFrame without compression:\", err)\n-\t}\n-\tparsedSynStreamFrame, ok := frame.(*SynStreamFrame)\n-\tif !ok {\n-\t\tt.Fatal(\"Parsed incorrect frame type:\", frame)\n-\t}\n-\tif !reflect.DeepEqual(synStreamFrame, *parsedSynStreamFrame) {\n-\t\tt.Fatal(\"got: \", *parsedSynStreamFrame, \"\\nwant: \", synStreamFrame)\n-\t}\n-\n-\t// Test again with compression\n-\tbuffer.Reset()\n-\tframer, err = NewFramer(buffer, buffer)\n-\tif err != nil {\n-\t\tt.Fatal(\"Failed to create new framer:\", err)\n-\t}\n-\tif err := framer.WriteFrame(&synStreamFrame); err != nil {\n-\t\tt.Fatal(\"WriteFrame with compression:\", err)\n-\t}\n-\tframe, err = framer.ReadFrame()\n-\tif err != nil {\n-\t\tt.Fatal(\"ReadFrame with compression:\", err)\n-\t}\n-\tparsedSynStreamFrame, ok = frame.(*SynStreamFrame)\n-\tif !ok {\n-\t\tt.Fatal(\"Parsed incorrect frame type:\", frame)\n-\t}\n-\tif !reflect.DeepEqual(synStreamFrame, *parsedSynStreamFrame) {\n-\t\tt.Fatal(\"got: \", *parsedSynStreamFrame, \"\\nwant: \", synStreamFrame)\n-\t}\n-}\n-\n-func TestCreateParseSynReplyFrame(t *testing.T) {\n-\tbuffer := new(bytes.Buffer)\n-\tframer := &Framer{\n-\t\theaderCompressionDisabled: true,\n-\t\tw:                         buffer,\n-\t\theaderBuf:                 new(bytes.Buffer),\n-\t\tr:                         buffer,\n-\t}\n-\tsynReplyFrame := SynReplyFrame{\n-\t\tCFHeader: ControlFrameHeader{\n-\t\t\tversion:   Version,\n-\t\t\tframeType: TypeSynReply,\n-\t\t},\n-\t\tHeaders: http.Header{\n-\t\t\t\"Url\":     []string{\"http://www.google.com/\"},\n-\t\t\t\"Method\":  []string{\"get\"},\n-\t\t\t\"Version\": []string{\"http/1.1\"},\n-\t\t},\n-\t}\n-\tif err := framer.WriteFrame(&synReplyFrame); err != nil {\n-\t\tt.Fatal(\"WriteFrame without compression:\", err)\n-\t}\n-\tframe, err := framer.ReadFrame()\n-\tif err != nil {\n-\t\tt.Fatal(\"ReadFrame without compression:\", err)\n-\t}\n-\tparsedSynReplyFrame, ok := frame.(*SynReplyFrame)\n-\tif !ok {\n-\t\tt.Fatal(\"Parsed incorrect frame type:\", frame)\n-\t}\n-\tif !reflect.DeepEqual(synReplyFrame, *parsedSynReplyFrame) {\n-\t\tt.Fatal(\"got: \", *parsedSynReplyFrame, \"\\nwant: \", synReplyFrame)\n-\t}\n-\n-\t// Test again with compression\n-\tbuffer.Reset()\n-\tframer, err = NewFramer(buffer, buffer)\n-\tif err != nil {\n-\t\tt.Fatal(\"Failed to create new framer:\", err)\n-\t}\n-\tif err := framer.WriteFrame(&synReplyFrame); err != nil {\n-\t\tt.Fatal(\"WriteFrame with compression:\", err)\n-\t}\n-\tframe, err = framer.ReadFrame()\n-\tif err != nil {\n-\t\tt.Fatal(\"ReadFrame with compression:\", err)\n-\t}\n-\tparsedSynReplyFrame, ok = frame.(*SynReplyFrame)\n-\tif !ok {\n-\t\tt.Fatal(\"Parsed incorrect frame type:\", frame)\n-\t}\n-\tif !reflect.DeepEqual(synReplyFrame, *parsedSynReplyFrame) {\n-\t\tt.Fatal(\"got: \", *parsedSynReplyFrame, \"\\nwant: \", synReplyFrame)\n-\t}\n-}\n-\n-func TestCreateParseRstStream(t *testing.T) {\n-\tbuffer := new(bytes.Buffer)\n-\tframer, err := NewFramer(buffer, buffer)\n-\tif err != nil {\n-\t\tt.Fatal(\"Failed to create new framer:\", err)\n-\t}\n-\trstStreamFrame := RstStreamFrame{\n-\t\tCFHeader: ControlFrameHeader{\n-\t\t\tversion:   Version,\n-\t\t\tframeType: TypeRstStream,\n-\t\t},\n-\t\tStreamId: 1,\n-\t\tStatus:   InvalidStream,\n-\t}\n-\tif err := framer.WriteFrame(&rstStreamFrame); err != nil {\n-\t\tt.Fatal(\"WriteFrame:\", err)\n-\t}\n-\tframe, err := framer.ReadFrame()\n-\tif err != nil {\n-\t\tt.Fatal(\"ReadFrame:\", err)\n-\t}\n-\tparsedRstStreamFrame, ok := frame.(*RstStreamFrame)\n-\tif !ok {\n-\t\tt.Fatal(\"Parsed incorrect frame type:\", frame)\n-\t}\n-\tif !reflect.DeepEqual(rstStreamFrame, *parsedRstStreamFrame) {\n-\t\tt.Fatal(\"got: \", *parsedRstStreamFrame, \"\\nwant: \", rstStreamFrame)\n-\t}\n-}\n-\n-func TestCreateParseSettings(t *testing.T) {\n-\tbuffer := new(bytes.Buffer)\n-\tframer, err := NewFramer(buffer, buffer)\n-\tif err != nil {\n-\t\tt.Fatal(\"Failed to create new framer:\", err)\n-\t}\n-\tsettingsFrame := SettingsFrame{\n-\t\tCFHeader: ControlFrameHeader{\n-\t\t\tversion:   Version,\n-\t\t\tframeType: TypeSettings,\n-\t\t},\n-\t\tFlagIdValues: []SettingsFlagIdValue{\n-\t\t\t{FlagSettingsPersistValue, SettingsCurrentCwnd, 10},\n-\t\t\t{FlagSettingsPersisted, SettingsUploadBandwidth, 1},\n-\t\t},\n-\t}\n-\tif err := framer.WriteFrame(&settingsFrame); err != nil {\n-\t\tt.Fatal(\"WriteFrame:\", err)\n-\t}\n-\tframe, err := framer.ReadFrame()\n-\tif err != nil {\n-\t\tt.Fatal(\"ReadFrame:\", err)\n-\t}\n-\tparsedSettingsFrame, ok := frame.(*SettingsFrame)\n-\tif !ok {\n-\t\tt.Fatal(\"Parsed incorrect frame type:\", frame)\n-\t}\n-\tif !reflect.DeepEqual(settingsFrame, *parsedSettingsFrame) {\n-\t\tt.Fatal(\"got: \", *parsedSettingsFrame, \"\\nwant: \", settingsFrame)\n-\t}\n-}\n-\n-func TestCreateParseNoop(t *testing.T) {\n-\tbuffer := new(bytes.Buffer)\n-\tframer, err := NewFramer(buffer, buffer)\n-\tif err != nil {\n-\t\tt.Fatal(\"Failed to create new framer:\", err)\n-\t}\n-\tnoopFrame := NoopFrame{\n-\t\tCFHeader: ControlFrameHeader{\n-\t\t\tversion:   Version,\n-\t\t\tframeType: TypeNoop,\n-\t\t},\n-\t}\n-\tif err := framer.WriteFrame(&noopFrame); err != nil {\n-\t\tt.Fatal(\"WriteFrame:\", err)\n-\t}\n-\tframe, err := framer.ReadFrame()\n-\tif err != nil {\n-\t\tt.Fatal(\"ReadFrame:\", err)\n-\t}\n-\tparsedNoopFrame, ok := frame.(*NoopFrame)\n-\tif !ok {\n-\t\tt.Fatal(\"Parsed incorrect frame type:\", frame)\n-\t}\n-\tif !reflect.DeepEqual(noopFrame, *parsedNoopFrame) {\n-\t\tt.Fatal(\"got: \", *parsedNoopFrame, \"\\nwant: \", noopFrame)\n-\t}\n-}\n-\n-func TestCreateParsePing(t *testing.T) {\n-\tbuffer := new(bytes.Buffer)\n-\tframer, err := NewFramer(buffer, buffer)\n-\tif err != nil {\n-\t\tt.Fatal(\"Failed to create new framer:\", err)\n-\t}\n-\tpingFrame := PingFrame{\n-\t\tCFHeader: ControlFrameHeader{\n-\t\t\tversion:   Version,\n-\t\t\tframeType: TypePing,\n-\t\t},\n-\t\tId: 31337,\n-\t}\n-\tif err := framer.WriteFrame(&pingFrame); err != nil {\n-\t\tt.Fatal(\"WriteFrame:\", err)\n-\t}\n-\tframe, err := framer.ReadFrame()\n-\tif err != nil {\n-\t\tt.Fatal(\"ReadFrame:\", err)\n-\t}\n-\tparsedPingFrame, ok := frame.(*PingFrame)\n-\tif !ok {\n-\t\tt.Fatal(\"Parsed incorrect frame type:\", frame)\n-\t}\n-\tif !reflect.DeepEqual(pingFrame, *parsedPingFrame) {\n-\t\tt.Fatal(\"got: \", *parsedPingFrame, \"\\nwant: \", pingFrame)\n-\t}\n-}\n-\n-func TestCreateParseGoAway(t *testing.T) {\n-\tbuffer := new(bytes.Buffer)\n-\tframer, err := NewFramer(buffer, buffer)\n-\tif err != nil {\n-\t\tt.Fatal(\"Failed to create new framer:\", err)\n-\t}\n-\tgoAwayFrame := GoAwayFrame{\n-\t\tCFHeader: ControlFrameHeader{\n-\t\t\tversion:   Version,\n-\t\t\tframeType: TypeGoAway,\n-\t\t},\n-\t\tLastGoodStreamId: 31337,\n-\t}\n-\tif err := framer.WriteFrame(&goAwayFrame); err != nil {\n-\t\tt.Fatal(\"WriteFrame:\", err)\n-\t}\n-\tframe, err := framer.ReadFrame()\n-\tif err != nil {\n-\t\tt.Fatal(\"ReadFrame:\", err)\n-\t}\n-\tparsedGoAwayFrame, ok := frame.(*GoAwayFrame)\n-\tif !ok {\n-\t\tt.Fatal(\"Parsed incorrect frame type:\", frame)\n-\t}\n-\tif !reflect.DeepEqual(goAwayFrame, *parsedGoAwayFrame) {\n-\t\tt.Fatal(\"got: \", *parsedGoAwayFrame, \"\\nwant: \", goAwayFrame)\n-\t}\n-}\n-\n-func TestCreateParseHeadersFrame(t *testing.T) {\n-\tbuffer := new(bytes.Buffer)\n-\tframer := &Framer{\n-\t\theaderCompressionDisabled: true,\n-\t\tw:                         buffer,\n-\t\theaderBuf:                 new(bytes.Buffer),\n-\t\tr:                         buffer,\n-\t}\n-\theadersFrame := HeadersFrame{\n-\t\tCFHeader: ControlFrameHeader{\n-\t\t\tversion:   Version,\n-\t\t\tframeType: TypeHeaders,\n-\t\t},\n-\t}\n-\theadersFrame.Headers = http.Header{\n-\t\t\"Url\":     []string{\"http://www.google.com/\"},\n-\t\t\"Method\":  []string{\"get\"},\n-\t\t\"Version\": []string{\"http/1.1\"},\n-\t}\n-\tif err := framer.WriteFrame(&headersFrame); err != nil {\n-\t\tt.Fatal(\"WriteFrame without compression:\", err)\n-\t}\n-\tframe, err := framer.ReadFrame()\n-\tif err != nil {\n-\t\tt.Fatal(\"ReadFrame without compression:\", err)\n-\t}\n-\tparsedHeadersFrame, ok := frame.(*HeadersFrame)\n-\tif !ok {\n-\t\tt.Fatal(\"Parsed incorrect frame type:\", frame)\n-\t}\n-\tif !reflect.DeepEqual(headersFrame, *parsedHeadersFrame) {\n-\t\tt.Fatal(\"got: \", *parsedHeadersFrame, \"\\nwant: \", headersFrame)\n-\t}\n-\n-\t// Test again with compression\n-\tbuffer.Reset()\n-\tframer, err = NewFramer(buffer, buffer)\n-\tif err := framer.WriteFrame(&headersFrame); err != nil {\n-\t\tt.Fatal(\"WriteFrame with compression:\", err)\n-\t}\n-\tframe, err = framer.ReadFrame()\n-\tif err != nil {\n-\t\tt.Fatal(\"ReadFrame with compression:\", err)\n-\t}\n-\tparsedHeadersFrame, ok = frame.(*HeadersFrame)\n-\tif !ok {\n-\t\tt.Fatal(\"Parsed incorrect frame type:\", frame)\n-\t}\n-\tif !reflect.DeepEqual(headersFrame, *parsedHeadersFrame) {\n-\t\tt.Fatal(\"got: \", *parsedHeadersFrame, \"\\nwant: \", headersFrame)\n-\t}\n-}\n-\n-func TestCreateParseDataFrame(t *testing.T) {\n-\tbuffer := new(bytes.Buffer)\n-\tframer, err := NewFramer(buffer, buffer)\n-\tif err != nil {\n-\t\tt.Fatal(\"Failed to create new framer:\", err)\n-\t}\n-\tdataFrame := DataFrame{\n-\t\tStreamId: 1,\n-\t\tData:     []byte{'h', 'e', 'l', 'l', 'o'},\n-\t}\n-\tif err := framer.WriteFrame(&dataFrame); err != nil {\n-\t\tt.Fatal(\"WriteFrame:\", err)\n-\t}\n-\tframe, err := framer.ReadFrame()\n-\tif err != nil {\n-\t\tt.Fatal(\"ReadFrame:\", err)\n-\t}\n-\tparsedDataFrame, ok := frame.(*DataFrame)\n-\tif !ok {\n-\t\tt.Fatal(\"Parsed incorrect frame type:\", frame)\n-\t}\n-\tif !reflect.DeepEqual(dataFrame, *parsedDataFrame) {\n-\t\tt.Fatal(\"got: \", *parsedDataFrame, \"\\nwant: \", dataFrame)\n-\t}\n-}\n-\n-func TestCompressionContextAcrossFrames(t *testing.T) {\n-\tbuffer := new(bytes.Buffer)\n-\tframer, err := NewFramer(buffer, buffer)\n-\tif err != nil {\n-\t\tt.Fatal(\"Failed to create new framer:\", err)\n-\t}\n-\theadersFrame := HeadersFrame{\n-\t\tCFHeader: ControlFrameHeader{\n-\t\t\tversion:   Version,\n-\t\t\tframeType: TypeHeaders,\n-\t\t},\n-\t\tHeaders: http.Header{\n-\t\t\t\"Url\":     []string{\"http://www.google.com/\"},\n-\t\t\t\"Method\":  []string{\"get\"},\n-\t\t\t\"Version\": []string{\"http/1.1\"},\n-\t\t},\n-\t}\n-\tif err := framer.WriteFrame(&headersFrame); err != nil {\n-\t\tt.Fatal(\"WriteFrame (HEADERS):\", err)\n-\t}\n-\tsynStreamFrame := SynStreamFrame{ControlFrameHeader{Version, TypeSynStream, 0, 0}, 0, 0, 0, nil}\n-\tsynStreamFrame.Headers = http.Header{\n-\t\t\"Url\":     []string{\"http://www.google.com/\"},\n-\t\t\"Method\":  []string{\"get\"},\n-\t\t\"Version\": []string{\"http/1.1\"},\n-\t}\n-\tif err := framer.WriteFrame(&synStreamFrame); err != nil {\n-\t\tt.Fatal(\"WriteFrame (SYN_STREAM):\", err)\n-\t}\n-\tframe, err := framer.ReadFrame()\n-\tif err != nil {\n-\t\tt.Fatal(\"ReadFrame (HEADERS):\", err, buffer.Bytes())\n-\t}\n-\tparsedHeadersFrame, ok := frame.(*HeadersFrame)\n-\tif !ok {\n-\t\tt.Fatalf(\"expected HeadersFrame; got %T %v\", frame, frame)\n-\t}\n-\tif !reflect.DeepEqual(headersFrame, *parsedHeadersFrame) {\n-\t\tt.Fatal(\"got: \", *parsedHeadersFrame, \"\\nwant: \", headersFrame)\n-\t}\n-\tframe, err = framer.ReadFrame()\n-\tif err != nil {\n-\t\tt.Fatal(\"ReadFrame (SYN_STREAM):\", err, buffer.Bytes())\n-\t}\n-\tparsedSynStreamFrame, ok := frame.(*SynStreamFrame)\n-\tif !ok {\n-\t\tt.Fatalf(\"expected SynStreamFrame; got %T %v\", frame, frame)\n-\t}\n-\tif !reflect.DeepEqual(synStreamFrame, *parsedSynStreamFrame) {\n-\t\tt.Fatal(\"got: \", *parsedSynStreamFrame, \"\\nwant: \", synStreamFrame)\n-\t}\n-}\n-\n-func TestMultipleSPDYFrames(t *testing.T) {\n-\t// Initialize the framers.\n-\tpr1, pw1 := io.Pipe()\n-\tpr2, pw2 := io.Pipe()\n-\twriter, err := NewFramer(pw1, pr2)\n-\tif err != nil {\n-\t\tt.Fatal(\"Failed to create writer:\", err)\n-\t}\n-\treader, err := NewFramer(pw2, pr1)\n-\tif err != nil {\n-\t\tt.Fatal(\"Failed to create reader:\", err)\n-\t}\n-\n-\t// Set up the frames we're actually transferring.\n-\theadersFrame := HeadersFrame{\n-\t\tCFHeader: ControlFrameHeader{\n-\t\t\tversion:   Version,\n-\t\t\tframeType: TypeHeaders,\n-\t\t},\n-\t\tHeaders: http.Header{\n-\t\t\t\"Url\":     []string{\"http://www.google.com/\"},\n-\t\t\t\"Method\":  []string{\"get\"},\n-\t\t\t\"Version\": []string{\"http/1.1\"},\n-\t\t},\n-\t}\n-\tsynStreamFrame := SynStreamFrame{\n-\t\tCFHeader: ControlFrameHeader{\n-\t\t\tversion:   Version,\n-\t\t\tframeType: TypeSynStream,\n-\t\t},\n-\t\tHeaders: http.Header{\n-\t\t\t\"Url\":     []string{\"http://www.google.com/\"},\n-\t\t\t\"Method\":  []string{\"get\"},\n-\t\t\t\"Version\": []string{\"http/1.1\"},\n-\t\t},\n-\t}\n-\n-\t// Start the goroutines to write the frames.\n-\tgo func() {\n-\t\tif err := writer.WriteFrame(&headersFrame); err != nil {\n-\t\t\tt.Fatal(\"WriteFrame (HEADERS): \", err)\n-\t\t}\n-\t\tif err := writer.WriteFrame(&synStreamFrame); err != nil {\n-\t\t\tt.Fatal(\"WriteFrame (SYN_STREAM): \", err)\n-\t\t}\n-\t}()\n-\n-\t// Read the frames and verify they look as expected.\n-\tframe, err := reader.ReadFrame()\n-\tif err != nil {\n-\t\tt.Fatal(\"ReadFrame (HEADERS): \", err)\n-\t}\n-\tparsedHeadersFrame, ok := frame.(*HeadersFrame)\n-\tif !ok {\n-\t\tt.Fatal(\"Parsed incorrect frame type:\", frame)\n-\t}\n-\tif !reflect.DeepEqual(headersFrame, *parsedHeadersFrame) {\n-\t\tt.Fatal(\"got: \", *parsedHeadersFrame, \"\\nwant: \", headersFrame)\n-\t}\n-\tframe, err = reader.ReadFrame()\n-\tif err != nil {\n-\t\tt.Fatal(\"ReadFrame (SYN_STREAM):\", err)\n-\t}\n-\tparsedSynStreamFrame, ok := frame.(*SynStreamFrame)\n-\tif !ok {\n-\t\tt.Fatal(\"Parsed incorrect frame type.\")\n-\t}\n-\tif !reflect.DeepEqual(synStreamFrame, *parsedSynStreamFrame) {\n-\t\tt.Fatal(\"got: \", *parsedSynStreamFrame, \"\\nwant: \", synStreamFrame)\n-\t}\n-}"}, {"sha": "2648c4f75f93fc08a9e5209c8ec48a9db65cad87", "filename": "libgo/go/exp/spdy/types.go", "status": "removed", "additions": 0, "deletions": 369, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fspdy%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fspdy%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fspdy%2Ftypes.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,369 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package spdy\n-\n-import (\n-\t\"bytes\"\n-\t\"compress/zlib\"\n-\t\"io\"\n-\t\"net/http\"\n-)\n-\n-//  Data Frame Format\n-//  +----------------------------------+\n-//  |0|       Stream-ID (31bits)       |\n-//  +----------------------------------+\n-//  | flags (8)  |  Length (24 bits)   |\n-//  +----------------------------------+\n-//  |               Data               |\n-//  +----------------------------------+\n-//\n-//  Control Frame Format\n-//  +----------------------------------+\n-//  |1| Version(15bits) | Type(16bits) |\n-//  +----------------------------------+\n-//  | flags (8)  |  Length (24 bits)   |\n-//  +----------------------------------+\n-//  |               Data               |\n-//  +----------------------------------+\n-//\n-//  Control Frame: SYN_STREAM\n-//  +----------------------------------+\n-//  |1|000000000000001|0000000000000001|\n-//  +----------------------------------+\n-//  | flags (8)  |  Length (24 bits)   |  >= 12\n-//  +----------------------------------+\n-//  |X|       Stream-ID(31bits)        |\n-//  +----------------------------------+\n-//  |X|Associated-To-Stream-ID (31bits)|\n-//  +----------------------------------+\n-//  |Pri| unused      | Length (16bits)|\n-//  +----------------------------------+\n-//\n-//  Control Frame: SYN_REPLY\n-//  +----------------------------------+\n-//  |1|000000000000001|0000000000000010|\n-//  +----------------------------------+\n-//  | flags (8)  |  Length (24 bits)   |  >= 8\n-//  +----------------------------------+\n-//  |X|       Stream-ID(31bits)        |\n-//  +----------------------------------+\n-//  | unused (16 bits)| Length (16bits)|\n-//  +----------------------------------+\n-//\n-//  Control Frame: RST_STREAM\n-//  +----------------------------------+\n-//  |1|000000000000001|0000000000000011|\n-//  +----------------------------------+\n-//  | flags (8)  |  Length (24 bits)   |  >= 4\n-//  +----------------------------------+\n-//  |X|       Stream-ID(31bits)        |\n-//  +----------------------------------+\n-//  |        Status code (32 bits)     |\n-//  +----------------------------------+\n-//\n-//  Control Frame: SETTINGS\n-//  +----------------------------------+\n-//  |1|000000000000001|0000000000000100|\n-//  +----------------------------------+\n-//  | flags (8)  |  Length (24 bits)   |\n-//  +----------------------------------+\n-//  |        # of entries (32)         |\n-//  +----------------------------------+\n-//\n-//  Control Frame: NOOP\n-//  +----------------------------------+\n-//  |1|000000000000001|0000000000000101|\n-//  +----------------------------------+\n-//  | flags (8)  |  Length (24 bits)   | = 0\n-//  +----------------------------------+\n-//\n-//  Control Frame: PING\n-//  +----------------------------------+\n-//  |1|000000000000001|0000000000000110|\n-//  +----------------------------------+\n-//  | flags (8)  |  Length (24 bits)   | = 4\n-//  +----------------------------------+\n-//  |        Unique id (32 bits)       |\n-//  +----------------------------------+\n-//\n-//  Control Frame: GOAWAY\n-//  +----------------------------------+\n-//  |1|000000000000001|0000000000000111|\n-//  +----------------------------------+\n-//  | flags (8)  |  Length (24 bits)   | = 4\n-//  +----------------------------------+\n-//  |X|  Last-accepted-stream-id       |\n-//  +----------------------------------+\n-//\n-//  Control Frame: HEADERS\n-//  +----------------------------------+\n-//  |1|000000000000001|0000000000001000|\n-//  +----------------------------------+\n-//  | flags (8)  |  Length (24 bits)   | >= 8\n-//  +----------------------------------+\n-//  |X|      Stream-ID (31 bits)       |\n-//  +----------------------------------+\n-//  | unused (16 bits)| Length (16bits)|\n-//  +----------------------------------+\n-//\n-//  Control Frame: WINDOW_UPDATE\n-//  +----------------------------------+\n-//  |1|000000000000001|0000000000001001|\n-//  +----------------------------------+\n-//  | flags (8)  |  Length (24 bits)   | = 8\n-//  +----------------------------------+\n-//  |X|      Stream-ID (31 bits)       |\n-//  +----------------------------------+\n-//  |   Delta-Window-Size (32 bits)    |\n-//  +----------------------------------+\n-\n-// Version is the protocol version number that this package implements.\n-const Version = 2\n-\n-// ControlFrameType stores the type field in a control frame header.\n-type ControlFrameType uint16\n-\n-// Control frame type constants\n-const (\n-\tTypeSynStream    ControlFrameType = 0x0001\n-\tTypeSynReply                      = 0x0002\n-\tTypeRstStream                     = 0x0003\n-\tTypeSettings                      = 0x0004\n-\tTypeNoop                          = 0x0005\n-\tTypePing                          = 0x0006\n-\tTypeGoAway                        = 0x0007\n-\tTypeHeaders                       = 0x0008\n-\tTypeWindowUpdate                  = 0x0009\n-)\n-\n-// ControlFlags are the flags that can be set on a control frame.\n-type ControlFlags uint8\n-\n-const (\n-\tControlFlagFin ControlFlags = 0x01\n-)\n-\n-// DataFlags are the flags that can be set on a data frame.\n-type DataFlags uint8\n-\n-const (\n-\tDataFlagFin        DataFlags = 0x01\n-\tDataFlagCompressed           = 0x02\n-)\n-\n-// MaxDataLength is the maximum number of bytes that can be stored in one frame.\n-const MaxDataLength = 1<<24 - 1\n-\n-// Frame is a single SPDY frame in its unpacked in-memory representation. Use\n-// Framer to read and write it.\n-type Frame interface {\n-\twrite(f *Framer) error\n-}\n-\n-// ControlFrameHeader contains all the fields in a control frame header,\n-// in its unpacked in-memory representation.\n-type ControlFrameHeader struct {\n-\t// Note, high bit is the \"Control\" bit.\n-\tversion   uint16\n-\tframeType ControlFrameType\n-\tFlags     ControlFlags\n-\tlength    uint32\n-}\n-\n-type controlFrame interface {\n-\tFrame\n-\tread(h ControlFrameHeader, f *Framer) error\n-}\n-\n-// SynStreamFrame is the unpacked, in-memory representation of a SYN_STREAM\n-// frame.\n-type SynStreamFrame struct {\n-\tCFHeader             ControlFrameHeader\n-\tStreamId             uint32\n-\tAssociatedToStreamId uint32\n-\t// Note, only 2 highest bits currently used\n-\t// Rest of Priority is unused.\n-\tPriority uint16\n-\tHeaders  http.Header\n-}\n-\n-// SynReplyFrame is the unpacked, in-memory representation of a SYN_REPLY frame.\n-type SynReplyFrame struct {\n-\tCFHeader ControlFrameHeader\n-\tStreamId uint32\n-\tHeaders  http.Header\n-}\n-\n-// StatusCode represents the status that led to a RST_STREAM\n-type StatusCode uint32\n-\n-const (\n-\tProtocolError      StatusCode = 1\n-\tInvalidStream                 = 2\n-\tRefusedStream                 = 3\n-\tUnsupportedVersion            = 4\n-\tCancel                        = 5\n-\tInternalError                 = 6\n-\tFlowControlError              = 7\n-)\n-\n-// RstStreamFrame is the unpacked, in-memory representation of a RST_STREAM\n-// frame.\n-type RstStreamFrame struct {\n-\tCFHeader ControlFrameHeader\n-\tStreamId uint32\n-\tStatus   StatusCode\n-}\n-\n-// SettingsFlag represents a flag in a SETTINGS frame.\n-type SettingsFlag uint8\n-\n-const (\n-\tFlagSettingsPersistValue SettingsFlag = 0x1\n-\tFlagSettingsPersisted                 = 0x2\n-)\n-\n-// SettingsFlag represents the id of an id/value pair in a SETTINGS frame.\n-type SettingsId uint32\n-\n-const (\n-\tSettingsUploadBandwidth      SettingsId = 1\n-\tSettingsDownloadBandwidth               = 2\n-\tSettingsRoundTripTime                   = 3\n-\tSettingsMaxConcurrentStreams            = 4\n-\tSettingsCurrentCwnd                     = 5\n-)\n-\n-// SettingsFlagIdValue is the unpacked, in-memory representation of the\n-// combined flag/id/value for a setting in a SETTINGS frame.\n-type SettingsFlagIdValue struct {\n-\tFlag  SettingsFlag\n-\tId    SettingsId\n-\tValue uint32\n-}\n-\n-// SettingsFrame is the unpacked, in-memory representation of a SPDY\n-// SETTINGS frame.\n-type SettingsFrame struct {\n-\tCFHeader     ControlFrameHeader\n-\tFlagIdValues []SettingsFlagIdValue\n-}\n-\n-// NoopFrame is the unpacked, in-memory representation of a NOOP frame.\n-type NoopFrame struct {\n-\tCFHeader ControlFrameHeader\n-}\n-\n-// PingFrame is the unpacked, in-memory representation of a PING frame.\n-type PingFrame struct {\n-\tCFHeader ControlFrameHeader\n-\tId       uint32\n-}\n-\n-// GoAwayFrame is the unpacked, in-memory representation of a GOAWAY frame.\n-type GoAwayFrame struct {\n-\tCFHeader         ControlFrameHeader\n-\tLastGoodStreamId uint32\n-}\n-\n-// HeadersFrame is the unpacked, in-memory representation of a HEADERS frame.\n-type HeadersFrame struct {\n-\tCFHeader ControlFrameHeader\n-\tStreamId uint32\n-\tHeaders  http.Header\n-}\n-\n-// DataFrame is the unpacked, in-memory representation of a DATA frame.\n-type DataFrame struct {\n-\t// Note, high bit is the \"Control\" bit. Should be 0 for data frames.\n-\tStreamId uint32\n-\tFlags    DataFlags\n-\tData     []byte\n-}\n-\n-// HeaderDictionary is the dictionary sent to the zlib compressor/decompressor.\n-// Even though the specification states there is no null byte at the end, Chrome sends it.\n-const HeaderDictionary = \"optionsgetheadpostputdeletetrace\" +\n-\t\"acceptaccept-charsetaccept-encodingaccept-languageauthorizationexpectfromhost\" +\n-\t\"if-modified-sinceif-matchif-none-matchif-rangeif-unmodifiedsince\" +\n-\t\"max-forwardsproxy-authorizationrangerefererteuser-agent\" +\n-\t\"100101200201202203204205206300301302303304305306307400401402403404405406407408409410411412413414415416417500501502503504505\" +\n-\t\"accept-rangesageetaglocationproxy-authenticatepublicretry-after\" +\n-\t\"servervarywarningwww-authenticateallowcontent-basecontent-encodingcache-control\" +\n-\t\"connectiondatetrailertransfer-encodingupgradeviawarning\" +\n-\t\"content-languagecontent-lengthcontent-locationcontent-md5content-rangecontent-typeetagexpireslast-modifiedset-cookie\" +\n-\t\"MondayTuesdayWednesdayThursdayFridaySaturdaySunday\" +\n-\t\"JanFebMarAprMayJunJulAugSepOctNovDec\" +\n-\t\"chunkedtext/htmlimage/pngimage/jpgimage/gifapplication/xmlapplication/xhtmltext/plainpublicmax-age\" +\n-\t\"charset=iso-8859-1utf-8gzipdeflateHTTP/1.1statusversionurl\\x00\"\n-\n-// A SPDY specific error.\n-type ErrorCode string\n-\n-const (\n-\tUnlowercasedHeaderName     ErrorCode = \"header was not lowercased\"\n-\tDuplicateHeaders           ErrorCode = \"multiple headers with same name\"\n-\tWrongCompressedPayloadSize ErrorCode = \"compressed payload size was incorrect\"\n-\tUnknownFrameType           ErrorCode = \"unknown frame type\"\n-\tInvalidControlFrame        ErrorCode = \"invalid control frame\"\n-\tInvalidDataFrame           ErrorCode = \"invalid data frame\"\n-\tInvalidHeaderPresent       ErrorCode = \"frame contained invalid header\"\n-)\n-\n-// Error contains both the type of error and additional values. StreamId is 0\n-// if Error is not associated with a stream.\n-type Error struct {\n-\tErr      ErrorCode\n-\tStreamId uint32\n-}\n-\n-func (e *Error) Error() string {\n-\treturn string(e.Err)\n-}\n-\n-var invalidReqHeaders = map[string]bool{\n-\t\"Connection\":        true,\n-\t\"Keep-Alive\":        true,\n-\t\"Proxy-Connection\":  true,\n-\t\"Transfer-Encoding\": true,\n-}\n-\n-var invalidRespHeaders = map[string]bool{\n-\t\"Connection\":        true,\n-\t\"Keep-Alive\":        true,\n-\t\"Transfer-Encoding\": true,\n-}\n-\n-// Framer handles serializing/deserializing SPDY frames, including compressing/\n-// decompressing payloads.\n-type Framer struct {\n-\theaderCompressionDisabled bool\n-\tw                         io.Writer\n-\theaderBuf                 *bytes.Buffer\n-\theaderCompressor          *zlib.Writer\n-\tr                         io.Reader\n-\theaderReader              io.LimitedReader\n-\theaderDecompressor        io.ReadCloser\n-}\n-\n-// NewFramer allocates a new Framer for a given SPDY connection, repesented by\n-// a io.Writer and io.Reader. Note that Framer will read and write individual fields \n-// from/to the Reader and Writer, so the caller should pass in an appropriately \n-// buffered implementation to optimize performance.\n-func NewFramer(w io.Writer, r io.Reader) (*Framer, error) {\n-\tcompressBuf := new(bytes.Buffer)\n-\tcompressor, err := zlib.NewWriterDict(compressBuf, zlib.BestCompression, []byte(HeaderDictionary))\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tframer := &Framer{\n-\t\tw:                w,\n-\t\theaderBuf:        compressBuf,\n-\t\theaderCompressor: compressor,\n-\t\tr:                r,\n-\t}\n-\treturn framer, nil\n-}"}, {"sha": "3dd2ca1d5d8ef644bed70ea7ddbc280ccabf289b", "filename": "libgo/go/exp/spdy/write.go", "status": "removed", "additions": 0, "deletions": 285, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fspdy%2Fwrite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fspdy%2Fwrite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fspdy%2Fwrite.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,285 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package spdy\n-\n-import (\n-\t\"encoding/binary\"\n-\t\"io\"\n-\t\"net/http\"\n-\t\"strings\"\n-)\n-\n-func (frame *SynStreamFrame) write(f *Framer) error {\n-\treturn f.writeSynStreamFrame(frame)\n-}\n-\n-func (frame *SynReplyFrame) write(f *Framer) error {\n-\treturn f.writeSynReplyFrame(frame)\n-}\n-\n-func (frame *RstStreamFrame) write(f *Framer) (err error) {\n-\tframe.CFHeader.version = Version\n-\tframe.CFHeader.frameType = TypeRstStream\n-\tframe.CFHeader.length = 8\n-\n-\t// Serialize frame to Writer\n-\tif err = writeControlFrameHeader(f.w, frame.CFHeader); err != nil {\n-\t\treturn\n-\t}\n-\tif err = binary.Write(f.w, binary.BigEndian, frame.StreamId); err != nil {\n-\t\treturn\n-\t}\n-\tif err = binary.Write(f.w, binary.BigEndian, frame.Status); err != nil {\n-\t\treturn\n-\t}\n-\treturn\n-}\n-\n-func (frame *SettingsFrame) write(f *Framer) (err error) {\n-\tframe.CFHeader.version = Version\n-\tframe.CFHeader.frameType = TypeSettings\n-\tframe.CFHeader.length = uint32(len(frame.FlagIdValues)*8 + 4)\n-\n-\t// Serialize frame to Writer\n-\tif err = writeControlFrameHeader(f.w, frame.CFHeader); err != nil {\n-\t\treturn\n-\t}\n-\tif err = binary.Write(f.w, binary.BigEndian, uint32(len(frame.FlagIdValues))); err != nil {\n-\t\treturn\n-\t}\n-\tfor _, flagIdValue := range frame.FlagIdValues {\n-\t\tflagId := (uint32(flagIdValue.Flag) << 24) | uint32(flagIdValue.Id)\n-\t\tif err = binary.Write(f.w, binary.BigEndian, flagId); err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tif err = binary.Write(f.w, binary.BigEndian, flagIdValue.Value); err != nil {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-func (frame *NoopFrame) write(f *Framer) error {\n-\tframe.CFHeader.version = Version\n-\tframe.CFHeader.frameType = TypeNoop\n-\n-\t// Serialize frame to Writer\n-\treturn writeControlFrameHeader(f.w, frame.CFHeader)\n-}\n-\n-func (frame *PingFrame) write(f *Framer) (err error) {\n-\tframe.CFHeader.version = Version\n-\tframe.CFHeader.frameType = TypePing\n-\tframe.CFHeader.length = 4\n-\n-\t// Serialize frame to Writer\n-\tif err = writeControlFrameHeader(f.w, frame.CFHeader); err != nil {\n-\t\treturn\n-\t}\n-\tif err = binary.Write(f.w, binary.BigEndian, frame.Id); err != nil {\n-\t\treturn\n-\t}\n-\treturn\n-}\n-\n-func (frame *GoAwayFrame) write(f *Framer) (err error) {\n-\tframe.CFHeader.version = Version\n-\tframe.CFHeader.frameType = TypeGoAway\n-\tframe.CFHeader.length = 4\n-\n-\t// Serialize frame to Writer\n-\tif err = writeControlFrameHeader(f.w, frame.CFHeader); err != nil {\n-\t\treturn\n-\t}\n-\tif err = binary.Write(f.w, binary.BigEndian, frame.LastGoodStreamId); err != nil {\n-\t\treturn\n-\t}\n-\treturn nil\n-}\n-\n-func (frame *HeadersFrame) write(f *Framer) error {\n-\treturn f.writeHeadersFrame(frame)\n-}\n-\n-func (frame *DataFrame) write(f *Framer) error {\n-\treturn f.writeDataFrame(frame)\n-}\n-\n-// WriteFrame writes a frame.\n-func (f *Framer) WriteFrame(frame Frame) error {\n-\treturn frame.write(f)\n-}\n-\n-func writeControlFrameHeader(w io.Writer, h ControlFrameHeader) error {\n-\tif err := binary.Write(w, binary.BigEndian, 0x8000|h.version); err != nil {\n-\t\treturn err\n-\t}\n-\tif err := binary.Write(w, binary.BigEndian, h.frameType); err != nil {\n-\t\treturn err\n-\t}\n-\tflagsAndLength := (uint32(h.Flags) << 24) | h.length\n-\tif err := binary.Write(w, binary.BigEndian, flagsAndLength); err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-\n-func writeHeaderValueBlock(w io.Writer, h http.Header) (n int, err error) {\n-\tn = 0\n-\tif err = binary.Write(w, binary.BigEndian, uint16(len(h))); err != nil {\n-\t\treturn\n-\t}\n-\tn += 2\n-\tfor name, values := range h {\n-\t\tif err = binary.Write(w, binary.BigEndian, uint16(len(name))); err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tn += 2\n-\t\tname = strings.ToLower(name)\n-\t\tif _, err = io.WriteString(w, name); err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tn += len(name)\n-\t\tv := strings.Join(values, \"\\x00\")\n-\t\tif err = binary.Write(w, binary.BigEndian, uint16(len(v))); err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tn += 2\n-\t\tif _, err = io.WriteString(w, v); err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tn += len(v)\n-\t}\n-\treturn\n-}\n-\n-func (f *Framer) writeSynStreamFrame(frame *SynStreamFrame) (err error) {\n-\t// Marshal the headers.\n-\tvar writer io.Writer = f.headerBuf\n-\tif !f.headerCompressionDisabled {\n-\t\twriter = f.headerCompressor\n-\t}\n-\tif _, err = writeHeaderValueBlock(writer, frame.Headers); err != nil {\n-\t\treturn\n-\t}\n-\tif !f.headerCompressionDisabled {\n-\t\tf.headerCompressor.Flush()\n-\t}\n-\n-\t// Set ControlFrameHeader\n-\tframe.CFHeader.version = Version\n-\tframe.CFHeader.frameType = TypeSynStream\n-\tframe.CFHeader.length = uint32(len(f.headerBuf.Bytes()) + 10)\n-\n-\t// Serialize frame to Writer\n-\tif err = writeControlFrameHeader(f.w, frame.CFHeader); err != nil {\n-\t\treturn err\n-\t}\n-\tif err = binary.Write(f.w, binary.BigEndian, frame.StreamId); err != nil {\n-\t\treturn err\n-\t}\n-\tif err = binary.Write(f.w, binary.BigEndian, frame.AssociatedToStreamId); err != nil {\n-\t\treturn err\n-\t}\n-\tif err = binary.Write(f.w, binary.BigEndian, frame.Priority<<14); err != nil {\n-\t\treturn err\n-\t}\n-\tif _, err = f.w.Write(f.headerBuf.Bytes()); err != nil {\n-\t\treturn err\n-\t}\n-\tf.headerBuf.Reset()\n-\treturn nil\n-}\n-\n-func (f *Framer) writeSynReplyFrame(frame *SynReplyFrame) (err error) {\n-\t// Marshal the headers.\n-\tvar writer io.Writer = f.headerBuf\n-\tif !f.headerCompressionDisabled {\n-\t\twriter = f.headerCompressor\n-\t}\n-\tif _, err = writeHeaderValueBlock(writer, frame.Headers); err != nil {\n-\t\treturn\n-\t}\n-\tif !f.headerCompressionDisabled {\n-\t\tf.headerCompressor.Flush()\n-\t}\n-\n-\t// Set ControlFrameHeader\n-\tframe.CFHeader.version = Version\n-\tframe.CFHeader.frameType = TypeSynReply\n-\tframe.CFHeader.length = uint32(len(f.headerBuf.Bytes()) + 6)\n-\n-\t// Serialize frame to Writer\n-\tif err = writeControlFrameHeader(f.w, frame.CFHeader); err != nil {\n-\t\treturn\n-\t}\n-\tif err = binary.Write(f.w, binary.BigEndian, frame.StreamId); err != nil {\n-\t\treturn\n-\t}\n-\tif err = binary.Write(f.w, binary.BigEndian, uint16(0)); err != nil {\n-\t\treturn\n-\t}\n-\tif _, err = f.w.Write(f.headerBuf.Bytes()); err != nil {\n-\t\treturn\n-\t}\n-\tf.headerBuf.Reset()\n-\treturn\n-}\n-\n-func (f *Framer) writeHeadersFrame(frame *HeadersFrame) (err error) {\n-\t// Marshal the headers.\n-\tvar writer io.Writer = f.headerBuf\n-\tif !f.headerCompressionDisabled {\n-\t\twriter = f.headerCompressor\n-\t}\n-\tif _, err = writeHeaderValueBlock(writer, frame.Headers); err != nil {\n-\t\treturn\n-\t}\n-\tif !f.headerCompressionDisabled {\n-\t\tf.headerCompressor.Flush()\n-\t}\n-\n-\t// Set ControlFrameHeader\n-\tframe.CFHeader.version = Version\n-\tframe.CFHeader.frameType = TypeHeaders\n-\tframe.CFHeader.length = uint32(len(f.headerBuf.Bytes()) + 6)\n-\n-\t// Serialize frame to Writer\n-\tif err = writeControlFrameHeader(f.w, frame.CFHeader); err != nil {\n-\t\treturn\n-\t}\n-\tif err = binary.Write(f.w, binary.BigEndian, frame.StreamId); err != nil {\n-\t\treturn\n-\t}\n-\tif err = binary.Write(f.w, binary.BigEndian, uint16(0)); err != nil {\n-\t\treturn\n-\t}\n-\tif _, err = f.w.Write(f.headerBuf.Bytes()); err != nil {\n-\t\treturn\n-\t}\n-\tf.headerBuf.Reset()\n-\treturn\n-}\n-\n-func (f *Framer) writeDataFrame(frame *DataFrame) (err error) {\n-\t// Validate DataFrame\n-\tif frame.StreamId&0x80000000 != 0 || len(frame.Data) >= 0x0f000000 {\n-\t\treturn &Error{InvalidDataFrame, frame.StreamId}\n-\t}\n-\n-\t// Serialize frame to Writer\n-\tif err = binary.Write(f.w, binary.BigEndian, frame.StreamId); err != nil {\n-\t\treturn\n-\t}\n-\tflagsAndLength := (uint32(frame.Flags) << 24) | uint32(len(frame.Data))\n-\tif err = binary.Write(f.w, binary.BigEndian, flagsAndLength); err != nil {\n-\t\treturn\n-\t}\n-\tif _, err = f.w.Write(frame.Data); err != nil {\n-\t\treturn\n-\t}\n-\n-\treturn nil\n-}"}, {"sha": "9d75f37de748fe35fef2f9f0bf38bb80a0ffef6c", "filename": "libgo/go/exp/ssh/channel.go", "status": "removed", "additions": 0, "deletions": 318, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fchannel.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fchannel.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fchannel.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,318 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package ssh\n-\n-import (\n-\t\"errors\"\n-\t\"io\"\n-\t\"sync\"\n-)\n-\n-// A Channel is an ordered, reliable, duplex stream that is multiplexed over an\n-// SSH connection.\n-type Channel interface {\n-\t// Accept accepts the channel creation request.\n-\tAccept() error\n-\t// Reject rejects the channel creation request. After calling this, no\n-\t// other methods on the Channel may be called. If they are then the\n-\t// peer is likely to signal a protocol error and drop the connection.\n-\tReject(reason RejectionReason, message string) error\n-\n-\t// Read may return a ChannelRequest as an error.\n-\tRead(data []byte) (int, error)\n-\tWrite(data []byte) (int, error)\n-\tClose() error\n-\n-\t// AckRequest either sends an ack or nack to the channel request.\n-\tAckRequest(ok bool) error\n-\n-\t// ChannelType returns the type of the channel, as supplied by the\n-\t// client.\n-\tChannelType() string\n-\t// ExtraData returns the arbitary payload for this channel, as supplied\n-\t// by the client. This data is specific to the channel type.\n-\tExtraData() []byte\n-}\n-\n-// ChannelRequest represents a request sent on a channel, outside of the normal\n-// stream of bytes. It may result from calling Read on a Channel.\n-type ChannelRequest struct {\n-\tRequest   string\n-\tWantReply bool\n-\tPayload   []byte\n-}\n-\n-func (c ChannelRequest) Error() string {\n-\treturn \"channel request received\"\n-}\n-\n-// RejectionReason is an enumeration used when rejecting channel creation\n-// requests. See RFC 4254, section 5.1.\n-type RejectionReason int\n-\n-const (\n-\tProhibited RejectionReason = iota + 1\n-\tConnectionFailed\n-\tUnknownChannelType\n-\tResourceShortage\n-)\n-\n-type channel struct {\n-\t// immutable once created\n-\tchanType  string\n-\textraData []byte\n-\n-\ttheyClosed  bool\n-\ttheySentEOF bool\n-\tweClosed    bool\n-\tdead        bool\n-\n-\tserverConn            *ServerConn\n-\tmyId, theirId         uint32\n-\tmyWindow, theirWindow uint32\n-\tmaxPacketSize         uint32\n-\terr                   error\n-\n-\tpendingRequests []ChannelRequest\n-\tpendingData     []byte\n-\thead, length    int\n-\n-\t// This lock is inferior to serverConn.lock\n-\tlock sync.Mutex\n-\tcond *sync.Cond\n-}\n-\n-func (c *channel) Accept() error {\n-\tc.serverConn.lock.Lock()\n-\tdefer c.serverConn.lock.Unlock()\n-\n-\tif c.serverConn.err != nil {\n-\t\treturn c.serverConn.err\n-\t}\n-\n-\tconfirm := channelOpenConfirmMsg{\n-\t\tPeersId:       c.theirId,\n-\t\tMyId:          c.myId,\n-\t\tMyWindow:      c.myWindow,\n-\t\tMaxPacketSize: c.maxPacketSize,\n-\t}\n-\treturn c.serverConn.writePacket(marshal(msgChannelOpenConfirm, confirm))\n-}\n-\n-func (c *channel) Reject(reason RejectionReason, message string) error {\n-\tc.serverConn.lock.Lock()\n-\tdefer c.serverConn.lock.Unlock()\n-\n-\tif c.serverConn.err != nil {\n-\t\treturn c.serverConn.err\n-\t}\n-\n-\treject := channelOpenFailureMsg{\n-\t\tPeersId:  c.theirId,\n-\t\tReason:   uint32(reason),\n-\t\tMessage:  message,\n-\t\tLanguage: \"en\",\n-\t}\n-\treturn c.serverConn.writePacket(marshal(msgChannelOpenFailure, reject))\n-}\n-\n-func (c *channel) handlePacket(packet interface{}) {\n-\tc.lock.Lock()\n-\tdefer c.lock.Unlock()\n-\n-\tswitch packet := packet.(type) {\n-\tcase *channelRequestMsg:\n-\t\treq := ChannelRequest{\n-\t\t\tRequest:   packet.Request,\n-\t\t\tWantReply: packet.WantReply,\n-\t\t\tPayload:   packet.RequestSpecificData,\n-\t\t}\n-\n-\t\tc.pendingRequests = append(c.pendingRequests, req)\n-\t\tc.cond.Signal()\n-\tcase *channelCloseMsg:\n-\t\tc.theyClosed = true\n-\t\tc.cond.Signal()\n-\tcase *channelEOFMsg:\n-\t\tc.theySentEOF = true\n-\t\tc.cond.Signal()\n-\tdefault:\n-\t\tpanic(\"unknown packet type\")\n-\t}\n-}\n-\n-func (c *channel) handleData(data []byte) {\n-\tc.lock.Lock()\n-\tdefer c.lock.Unlock()\n-\n-\t// The other side should never send us more than our window.\n-\tif len(data)+c.length > len(c.pendingData) {\n-\t\t// TODO(agl): we should tear down the channel with a protocol\n-\t\t// error.\n-\t\treturn\n-\t}\n-\n-\tc.myWindow -= uint32(len(data))\n-\tfor i := 0; i < 2; i++ {\n-\t\ttail := c.head + c.length\n-\t\tif tail > len(c.pendingData) {\n-\t\t\ttail -= len(c.pendingData)\n-\t\t}\n-\t\tn := copy(c.pendingData[tail:], data)\n-\t\tdata = data[n:]\n-\t\tc.length += n\n-\t}\n-\n-\tc.cond.Signal()\n-}\n-\n-func (c *channel) Read(data []byte) (n int, err error) {\n-\tc.lock.Lock()\n-\tdefer c.lock.Unlock()\n-\n-\tif c.err != nil {\n-\t\treturn 0, c.err\n-\t}\n-\n-\tif c.myWindow <= uint32(len(c.pendingData))/2 {\n-\t\tpacket := marshal(msgChannelWindowAdjust, windowAdjustMsg{\n-\t\t\tPeersId:         c.theirId,\n-\t\t\tAdditionalBytes: uint32(len(c.pendingData)) - c.myWindow,\n-\t\t})\n-\t\tif err := c.serverConn.writePacket(packet); err != nil {\n-\t\t\treturn 0, err\n-\t\t}\n-\t}\n-\n-\tfor {\n-\t\tif c.theySentEOF || c.theyClosed || c.dead {\n-\t\t\treturn 0, io.EOF\n-\t\t}\n-\n-\t\tif len(c.pendingRequests) > 0 {\n-\t\t\treq := c.pendingRequests[0]\n-\t\t\tif len(c.pendingRequests) == 1 {\n-\t\t\t\tc.pendingRequests = nil\n-\t\t\t} else {\n-\t\t\t\toldPendingRequests := c.pendingRequests\n-\t\t\t\tc.pendingRequests = make([]ChannelRequest, len(oldPendingRequests)-1)\n-\t\t\t\tcopy(c.pendingRequests, oldPendingRequests[1:])\n-\t\t\t}\n-\n-\t\t\treturn 0, req\n-\t\t}\n-\n-\t\tif c.length > 0 {\n-\t\t\ttail := c.head + c.length\n-\t\t\tif tail > len(c.pendingData) {\n-\t\t\t\ttail -= len(c.pendingData)\n-\t\t\t}\n-\t\t\tn = copy(data, c.pendingData[c.head:tail])\n-\t\t\tc.head += n\n-\t\t\tc.length -= n\n-\t\t\tif c.head == len(c.pendingData) {\n-\t\t\t\tc.head = 0\n-\t\t\t}\n-\t\t\treturn\n-\t\t}\n-\n-\t\tc.cond.Wait()\n-\t}\n-\n-\tpanic(\"unreachable\")\n-}\n-\n-func (c *channel) Write(data []byte) (n int, err error) {\n-\tfor len(data) > 0 {\n-\t\tc.lock.Lock()\n-\t\tif c.dead || c.weClosed {\n-\t\t\treturn 0, io.EOF\n-\t\t}\n-\n-\t\tif c.theirWindow == 0 {\n-\t\t\tc.cond.Wait()\n-\t\t\tcontinue\n-\t\t}\n-\t\tc.lock.Unlock()\n-\n-\t\ttodo := data\n-\t\tif uint32(len(todo)) > c.theirWindow {\n-\t\t\ttodo = todo[:c.theirWindow]\n-\t\t}\n-\n-\t\tpacket := make([]byte, 1+4+4+len(todo))\n-\t\tpacket[0] = msgChannelData\n-\t\tpacket[1] = byte(c.theirId >> 24)\n-\t\tpacket[2] = byte(c.theirId >> 16)\n-\t\tpacket[3] = byte(c.theirId >> 8)\n-\t\tpacket[4] = byte(c.theirId)\n-\t\tpacket[5] = byte(len(todo) >> 24)\n-\t\tpacket[6] = byte(len(todo) >> 16)\n-\t\tpacket[7] = byte(len(todo) >> 8)\n-\t\tpacket[8] = byte(len(todo))\n-\t\tcopy(packet[9:], todo)\n-\n-\t\tc.serverConn.lock.Lock()\n-\t\tif err = c.serverConn.writePacket(packet); err != nil {\n-\t\t\tc.serverConn.lock.Unlock()\n-\t\t\treturn\n-\t\t}\n-\t\tc.serverConn.lock.Unlock()\n-\n-\t\tn += len(todo)\n-\t\tdata = data[len(todo):]\n-\t}\n-\n-\treturn\n-}\n-\n-func (c *channel) Close() error {\n-\tc.serverConn.lock.Lock()\n-\tdefer c.serverConn.lock.Unlock()\n-\n-\tif c.serverConn.err != nil {\n-\t\treturn c.serverConn.err\n-\t}\n-\n-\tif c.weClosed {\n-\t\treturn errors.New(\"ssh: channel already closed\")\n-\t}\n-\tc.weClosed = true\n-\n-\tcloseMsg := channelCloseMsg{\n-\t\tPeersId: c.theirId,\n-\t}\n-\treturn c.serverConn.writePacket(marshal(msgChannelClose, closeMsg))\n-}\n-\n-func (c *channel) AckRequest(ok bool) error {\n-\tc.serverConn.lock.Lock()\n-\tdefer c.serverConn.lock.Unlock()\n-\n-\tif c.serverConn.err != nil {\n-\t\treturn c.serverConn.err\n-\t}\n-\n-\tif ok {\n-\t\tack := channelRequestSuccessMsg{\n-\t\t\tPeersId: c.theirId,\n-\t\t}\n-\t\treturn c.serverConn.writePacket(marshal(msgChannelSuccess, ack))\n-\t} else {\n-\t\tack := channelRequestFailureMsg{\n-\t\t\tPeersId: c.theirId,\n-\t\t}\n-\t\treturn c.serverConn.writePacket(marshal(msgChannelFailure, ack))\n-\t}\n-\tpanic(\"unreachable\")\n-}\n-\n-func (c *channel) ChannelType() string {\n-\treturn c.chanType\n-}\n-\n-func (c *channel) ExtraData() []byte {\n-\treturn c.extraData\n-}"}, {"sha": "d91929aa99adb5e001aec5e7603804acd698fc89", "filename": "libgo/go/exp/ssh/cipher.go", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fcipher.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,88 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package ssh\n-\n-import (\n-\t\"crypto/aes\"\n-\t\"crypto/cipher\"\n-\t\"crypto/rc4\"\n-)\n-\n-// streamDump is used to dump the initial keystream for stream ciphers. It is a\n-// a write-only buffer, and not intended for reading so do not require a mutex.\n-var streamDump [512]byte\n-\n-// noneCipher implements cipher.Stream and provides no encryption. It is used\n-// by the transport before the first key-exchange.\n-type noneCipher struct{}\n-\n-func (c noneCipher) XORKeyStream(dst, src []byte) {\n-\tcopy(dst, src)\n-}\n-\n-func newAESCTR(key, iv []byte) (cipher.Stream, error) {\n-\tc, err := aes.NewCipher(key)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn cipher.NewCTR(c, iv), nil\n-}\n-\n-func newRC4(key, iv []byte) (cipher.Stream, error) {\n-\treturn rc4.NewCipher(key)\n-}\n-\n-type cipherMode struct {\n-\tkeySize  int\n-\tivSize   int\n-\tskip     int\n-\tcreateFn func(key, iv []byte) (cipher.Stream, error)\n-}\n-\n-func (c *cipherMode) createCipher(key, iv []byte) (cipher.Stream, error) {\n-\tif len(key) < c.keySize {\n-\t\tpanic(\"ssh: key length too small for cipher\")\n-\t}\n-\tif len(iv) < c.ivSize {\n-\t\tpanic(\"ssh: iv too small for cipher\")\n-\t}\n-\n-\tstream, err := c.createFn(key[:c.keySize], iv[:c.ivSize])\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tfor remainingToDump := c.skip; remainingToDump > 0; {\n-\t\tdumpThisTime := remainingToDump\n-\t\tif dumpThisTime > len(streamDump) {\n-\t\t\tdumpThisTime = len(streamDump)\n-\t\t}\n-\t\tstream.XORKeyStream(streamDump[:dumpThisTime], streamDump[:dumpThisTime])\n-\t\tremainingToDump -= dumpThisTime\n-\t}\n-\n-\treturn stream, nil\n-}\n-\n-// Specifies a default set of ciphers and a preference order. This is based on\n-// OpenSSH's default client preference order, minus algorithms that are not\n-// implemented.\n-var DefaultCipherOrder = []string{\n-\t\"aes128-ctr\", \"aes192-ctr\", \"aes256-ctr\",\n-\t\"arcfour256\", \"arcfour128\",\n-}\n-\n-var cipherModes = map[string]*cipherMode{\n-\t// Ciphers from RFC4344, which introduced many CTR-based ciphers. Algorithms\n-\t// are defined in the order specified in the RFC.\n-\t\"aes128-ctr\": {16, aes.BlockSize, 0, newAESCTR},\n-\t\"aes192-ctr\": {24, aes.BlockSize, 0, newAESCTR},\n-\t\"aes256-ctr\": {32, aes.BlockSize, 0, newAESCTR},\n-\n-\t// Ciphers from RFC4345, which introduces security-improved arcfour ciphers.\n-\t// They are defined in the order specified in the RFC.\n-\t\"arcfour128\": {16, 0, 1536, newRC4},\n-\t\"arcfour256\": {32, 0, 1536, newRC4},\n-}"}, {"sha": "ea27bd8a8035fe94dbe4e4824707b39c86cfd9e2", "filename": "libgo/go/exp/ssh/cipher_test.go", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fcipher_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fcipher_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fcipher_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,62 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package ssh\n-\n-import (\n-\t\"bytes\"\n-\t\"testing\"\n-)\n-\n-// TestCipherReversal tests that each cipher factory produces ciphers that can\n-// encrypt and decrypt some data successfully.\n-func TestCipherReversal(t *testing.T) {\n-\ttestData := []byte(\"abcdefghijklmnopqrstuvwxyz012345\")\n-\ttestKey := []byte(\"AbCdEfGhIjKlMnOpQrStUvWxYz012345\")\n-\ttestIv := []byte(\"sdflkjhsadflkjhasdflkjhsadfklhsa\")\n-\n-\tcryptBuffer := make([]byte, 32)\n-\n-\tfor name, cipherMode := range cipherModes {\n-\t\tencrypter, err := cipherMode.createCipher(testKey, testIv)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"failed to create encrypter for %q: %s\", name, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tdecrypter, err := cipherMode.createCipher(testKey, testIv)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"failed to create decrypter for %q: %s\", name, err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tcopy(cryptBuffer, testData)\n-\n-\t\tencrypter.XORKeyStream(cryptBuffer, cryptBuffer)\n-\t\tif name == \"none\" {\n-\t\t\tif !bytes.Equal(cryptBuffer, testData) {\n-\t\t\t\tt.Errorf(\"encryption made change with 'none' cipher\")\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif bytes.Equal(cryptBuffer, testData) {\n-\t\t\t\tt.Errorf(\"encryption made no change with %q\", name)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t}\n-\n-\t\tdecrypter.XORKeyStream(cryptBuffer, cryptBuffer)\n-\t\tif !bytes.Equal(cryptBuffer, testData) {\n-\t\t\tt.Errorf(\"decrypted bytes not equal to input with %q\", name)\n-\t\t\tcontinue\n-\t\t}\n-\t}\n-}\n-\n-func TestDefaultCiphersExist(t *testing.T) {\n-\tfor _, cipherAlgo := range DefaultCipherOrder {\n-\t\tif _, ok := cipherModes[cipherAlgo]; !ok {\n-\t\t\tt.Errorf(\"default cipher %q is unknown\", cipherAlgo)\n-\t\t}\n-\t}\n-}"}, {"sha": "eb6c0352210fa7b00b30fde74f4da951923f338b", "filename": "libgo/go/exp/ssh/client.go", "status": "removed", "additions": 0, "deletions": 505, "changes": 505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,505 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package ssh\n-\n-import (\n-\t\"crypto\"\n-\t\"crypto/rand\"\n-\t\"errors\"\n-\t\"fmt\"\n-\t\"io\"\n-\t\"math/big\"\n-\t\"net\"\n-\t\"sync\"\n-)\n-\n-// clientVersion is the fixed identification string that the client will use.\n-var clientVersion = []byte(\"SSH-2.0-Go\\r\\n\")\n-\n-// ClientConn represents the client side of an SSH connection.\n-type ClientConn struct {\n-\t*transport\n-\tconfig *ClientConfig\n-\tchanlist\n-}\n-\n-// Client returns a new SSH client connection using c as the underlying transport.\n-func Client(c net.Conn, config *ClientConfig) (*ClientConn, error) {\n-\tconn := &ClientConn{\n-\t\ttransport: newTransport(c, config.rand()),\n-\t\tconfig:    config,\n-\t}\n-\tif err := conn.handshake(); err != nil {\n-\t\tconn.Close()\n-\t\treturn nil, err\n-\t}\n-\tgo conn.mainLoop()\n-\treturn conn, nil\n-}\n-\n-// handshake performs the client side key exchange. See RFC 4253 Section 7.\n-func (c *ClientConn) handshake() error {\n-\tvar magics handshakeMagics\n-\n-\tif _, err := c.Write(clientVersion); err != nil {\n-\t\treturn err\n-\t}\n-\tif err := c.Flush(); err != nil {\n-\t\treturn err\n-\t}\n-\tmagics.clientVersion = clientVersion[:len(clientVersion)-2]\n-\n-\t// read remote server version\n-\tversion, err := readVersion(c)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tmagics.serverVersion = version\n-\tclientKexInit := kexInitMsg{\n-\t\tKexAlgos:                supportedKexAlgos,\n-\t\tServerHostKeyAlgos:      supportedHostKeyAlgos,\n-\t\tCiphersClientServer:     c.config.Crypto.ciphers(),\n-\t\tCiphersServerClient:     c.config.Crypto.ciphers(),\n-\t\tMACsClientServer:        supportedMACs,\n-\t\tMACsServerClient:        supportedMACs,\n-\t\tCompressionClientServer: supportedCompressions,\n-\t\tCompressionServerClient: supportedCompressions,\n-\t}\n-\tkexInitPacket := marshal(msgKexInit, clientKexInit)\n-\tmagics.clientKexInit = kexInitPacket\n-\n-\tif err := c.writePacket(kexInitPacket); err != nil {\n-\t\treturn err\n-\t}\n-\tpacket, err := c.readPacket()\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\tmagics.serverKexInit = packet\n-\n-\tvar serverKexInit kexInitMsg\n-\tif err = unmarshal(&serverKexInit, packet, msgKexInit); err != nil {\n-\t\treturn err\n-\t}\n-\n-\tkexAlgo, hostKeyAlgo, ok := findAgreedAlgorithms(c.transport, &clientKexInit, &serverKexInit)\n-\tif !ok {\n-\t\treturn errors.New(\"ssh: no common algorithms\")\n-\t}\n-\n-\tif serverKexInit.FirstKexFollows && kexAlgo != serverKexInit.KexAlgos[0] {\n-\t\t// The server sent a Kex message for the wrong algorithm,\n-\t\t// which we have to ignore.\n-\t\tif _, err := c.readPacket(); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\n-\tvar H, K []byte\n-\tvar hashFunc crypto.Hash\n-\tswitch kexAlgo {\n-\tcase kexAlgoDH14SHA1:\n-\t\thashFunc = crypto.SHA1\n-\t\tdhGroup14Once.Do(initDHGroup14)\n-\t\tH, K, err = c.kexDH(dhGroup14, hashFunc, &magics, hostKeyAlgo)\n-\tdefault:\n-\t\terr = fmt.Errorf(\"ssh: unexpected key exchange algorithm %v\", kexAlgo)\n-\t}\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\tif err = c.writePacket([]byte{msgNewKeys}); err != nil {\n-\t\treturn err\n-\t}\n-\tif err = c.transport.writer.setupKeys(clientKeys, K, H, H, hashFunc); err != nil {\n-\t\treturn err\n-\t}\n-\tif packet, err = c.readPacket(); err != nil {\n-\t\treturn err\n-\t}\n-\tif packet[0] != msgNewKeys {\n-\t\treturn UnexpectedMessageError{msgNewKeys, packet[0]}\n-\t}\n-\tif err := c.transport.reader.setupKeys(serverKeys, K, H, H, hashFunc); err != nil {\n-\t\treturn err\n-\t}\n-\treturn c.authenticate(H)\n-}\n-\n-// kexDH performs Diffie-Hellman key agreement on a ClientConn. The\n-// returned values are given the same names as in RFC 4253, section 8.\n-func (c *ClientConn) kexDH(group *dhGroup, hashFunc crypto.Hash, magics *handshakeMagics, hostKeyAlgo string) ([]byte, []byte, error) {\n-\tx, err := rand.Int(c.config.rand(), group.p)\n-\tif err != nil {\n-\t\treturn nil, nil, err\n-\t}\n-\tX := new(big.Int).Exp(group.g, x, group.p)\n-\tkexDHInit := kexDHInitMsg{\n-\t\tX: X,\n-\t}\n-\tif err := c.writePacket(marshal(msgKexDHInit, kexDHInit)); err != nil {\n-\t\treturn nil, nil, err\n-\t}\n-\n-\tpacket, err := c.readPacket()\n-\tif err != nil {\n-\t\treturn nil, nil, err\n-\t}\n-\n-\tvar kexDHReply = new(kexDHReplyMsg)\n-\tif err = unmarshal(kexDHReply, packet, msgKexDHReply); err != nil {\n-\t\treturn nil, nil, err\n-\t}\n-\n-\tif kexDHReply.Y.Sign() == 0 || kexDHReply.Y.Cmp(group.p) >= 0 {\n-\t\treturn nil, nil, errors.New(\"server DH parameter out of bounds\")\n-\t}\n-\n-\tkInt := new(big.Int).Exp(kexDHReply.Y, x, group.p)\n-\th := hashFunc.New()\n-\twriteString(h, magics.clientVersion)\n-\twriteString(h, magics.serverVersion)\n-\twriteString(h, magics.clientKexInit)\n-\twriteString(h, magics.serverKexInit)\n-\twriteString(h, kexDHReply.HostKey)\n-\twriteInt(h, X)\n-\twriteInt(h, kexDHReply.Y)\n-\tK := make([]byte, intLength(kInt))\n-\tmarshalInt(K, kInt)\n-\th.Write(K)\n-\n-\tH := h.Sum(nil)\n-\n-\treturn H, K, nil\n-}\n-\n-// mainLoop reads incoming messages and routes channel messages\n-// to their respective ClientChans.\n-func (c *ClientConn) mainLoop() {\n-\t// TODO(dfc) signal the underlying close to all channels\n-\tdefer c.Close()\n-\tfor {\n-\t\tpacket, err := c.readPacket()\n-\t\tif err != nil {\n-\t\t\tbreak\n-\t\t}\n-\t\t// TODO(dfc) A note on blocking channel use.\n-\t\t// The msg, win, data and dataExt channels of a clientChan can\n-\t\t// cause this loop to block indefinately if the consumer does\n-\t\t// not service them.\n-\t\tswitch packet[0] {\n-\t\tcase msgChannelData:\n-\t\t\tif len(packet) < 9 {\n-\t\t\t\t// malformed data packet\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tpeersId := uint32(packet[1])<<24 | uint32(packet[2])<<16 | uint32(packet[3])<<8 | uint32(packet[4])\n-\t\t\tif length := int(packet[5])<<24 | int(packet[6])<<16 | int(packet[7])<<8 | int(packet[8]); length > 0 {\n-\t\t\t\tpacket = packet[9:]\n-\t\t\t\tc.getChan(peersId).stdout.handleData(packet[:length])\n-\t\t\t}\n-\t\tcase msgChannelExtendedData:\n-\t\t\tif len(packet) < 13 {\n-\t\t\t\t// malformed data packet\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tpeersId := uint32(packet[1])<<24 | uint32(packet[2])<<16 | uint32(packet[3])<<8 | uint32(packet[4])\n-\t\t\tdatatype := uint32(packet[5])<<24 | uint32(packet[6])<<16 | uint32(packet[7])<<8 | uint32(packet[8])\n-\t\t\tif length := int(packet[9])<<24 | int(packet[10])<<16 | int(packet[11])<<8 | int(packet[12]); length > 0 {\n-\t\t\t\tpacket = packet[13:]\n-\t\t\t\t// RFC 4254 5.2 defines data_type_code 1 to be data destined\n-\t\t\t\t// for stderr on interactive sessions. Other data types are\n-\t\t\t\t// silently discarded.\n-\t\t\t\tif datatype == 1 {\n-\t\t\t\t\tc.getChan(peersId).stderr.handleData(packet[:length])\n-\t\t\t\t}\n-\t\t\t}\n-\t\tdefault:\n-\t\t\tswitch msg := decode(packet).(type) {\n-\t\t\tcase *channelOpenMsg:\n-\t\t\t\tc.getChan(msg.PeersId).msg <- msg\n-\t\t\tcase *channelOpenConfirmMsg:\n-\t\t\t\tc.getChan(msg.PeersId).msg <- msg\n-\t\t\tcase *channelOpenFailureMsg:\n-\t\t\t\tc.getChan(msg.PeersId).msg <- msg\n-\t\t\tcase *channelCloseMsg:\n-\t\t\t\tch := c.getChan(msg.PeersId)\n-\t\t\t\tch.theyClosed = true\n-\t\t\t\tclose(ch.stdin.win)\n-\t\t\t\tch.stdout.eof()\n-\t\t\t\tch.stderr.eof()\n-\t\t\t\tclose(ch.msg)\n-\t\t\t\tif !ch.weClosed {\n-\t\t\t\t\tch.weClosed = true\n-\t\t\t\t\tch.sendClose()\n-\t\t\t\t}\n-\t\t\t\tc.chanlist.remove(msg.PeersId)\n-\t\t\tcase *channelEOFMsg:\n-\t\t\t\tch := c.getChan(msg.PeersId)\n-\t\t\t\tch.stdout.eof()\n-\t\t\t\t// RFC 4254 is mute on how EOF affects dataExt messages but\n-\t\t\t\t// it is logical to signal EOF at the same time.\n-\t\t\t\tch.stderr.eof()\n-\t\t\tcase *channelRequestSuccessMsg:\n-\t\t\t\tc.getChan(msg.PeersId).msg <- msg\n-\t\t\tcase *channelRequestFailureMsg:\n-\t\t\t\tc.getChan(msg.PeersId).msg <- msg\n-\t\t\tcase *channelRequestMsg:\n-\t\t\t\tc.getChan(msg.PeersId).msg <- msg\n-\t\t\tcase *windowAdjustMsg:\n-\t\t\t\tc.getChan(msg.PeersId).stdin.win <- int(msg.AdditionalBytes)\n-\t\t\tcase *disconnectMsg:\n-\t\t\t\tbreak\n-\t\t\tdefault:\n-\t\t\t\tfmt.Printf(\"mainLoop: unhandled message %T: %v\\n\", msg, msg)\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-// Dial connects to the given network address using net.Dial and\n-// then initiates a SSH handshake, returning the resulting client connection.\n-func Dial(network, addr string, config *ClientConfig) (*ClientConn, error) {\n-\tconn, err := net.Dial(network, addr)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn Client(conn, config)\n-}\n-\n-// A ClientConfig structure is used to configure a ClientConn. After one has\n-// been passed to an SSH function it must not be modified.\n-type ClientConfig struct {\n-\t// Rand provides the source of entropy for key exchange. If Rand is\n-\t// nil, the cryptographic random reader in package crypto/rand will\n-\t// be used.\n-\tRand io.Reader\n-\n-\t// The username to authenticate.\n-\tUser string\n-\n-\t// A slice of ClientAuth methods. Only the first instance\n-\t// of a particular RFC 4252 method will be used during authentication.\n-\tAuth []ClientAuth\n-\n-\t// Cryptographic-related configuration.\n-\tCrypto CryptoConfig\n-}\n-\n-func (c *ClientConfig) rand() io.Reader {\n-\tif c.Rand == nil {\n-\t\treturn rand.Reader\n-\t}\n-\treturn c.Rand\n-}\n-\n-// A clientChan represents a single RFC 4254 channel that is multiplexed\n-// over a single SSH connection.\n-type clientChan struct {\n-\tpacketWriter\n-\tid, peersId uint32\n-\tstdin       *chanWriter      // receives window adjustments\n-\tstdout      *chanReader      // receives the payload of channelData messages\n-\tstderr      *chanReader      // receives the payload of channelExtendedData messages\n-\tmsg         chan interface{} // incoming messages\n-\ttheyClosed  bool             // indicates the close msg has been received from the remote side\n-\tweClosed    bool             // incidates the close msg has been sent from our side\n-}\n-\n-// newClientChan returns a partially constructed *clientChan\n-// using the local id provided. To be usable clientChan.peersId\n-// needs to be assigned once known.\n-func newClientChan(t *transport, id uint32) *clientChan {\n-\tc := &clientChan{\n-\t\tpacketWriter: t,\n-\t\tid:           id,\n-\t\tmsg:          make(chan interface{}, 16),\n-\t}\n-\tc.stdin = &chanWriter{\n-\t\twin:        make(chan int, 16),\n-\t\tclientChan: c,\n-\t}\n-\tc.stdout = &chanReader{\n-\t\tdata:       make(chan []byte, 16),\n-\t\tclientChan: c,\n-\t}\n-\tc.stderr = &chanReader{\n-\t\tdata:       make(chan []byte, 16),\n-\t\tclientChan: c,\n-\t}\n-\treturn c\n-}\n-\n-// waitForChannelOpenResponse, if successful, fills out\n-// the peerId and records any initial window advertisement.\n-func (c *clientChan) waitForChannelOpenResponse() error {\n-\tswitch msg := (<-c.msg).(type) {\n-\tcase *channelOpenConfirmMsg:\n-\t\t// fixup peersId field\n-\t\tc.peersId = msg.MyId\n-\t\tc.stdin.win <- int(msg.MyWindow)\n-\t\treturn nil\n-\tcase *channelOpenFailureMsg:\n-\t\treturn errors.New(safeString(msg.Message))\n-\t}\n-\treturn errors.New(\"unexpected packet\")\n-}\n-\n-// sendEOF sends EOF to the server. RFC 4254 Section 5.3\n-func (c *clientChan) sendEOF() error {\n-\treturn c.writePacket(marshal(msgChannelEOF, channelEOFMsg{\n-\t\tPeersId: c.peersId,\n-\t}))\n-}\n-\n-// sendClose signals the intent to close the channel.\n-func (c *clientChan) sendClose() error {\n-\treturn c.writePacket(marshal(msgChannelClose, channelCloseMsg{\n-\t\tPeersId: c.peersId,\n-\t}))\n-}\n-\n-// Close closes the channel. This does not close the underlying connection.\n-func (c *clientChan) Close() error {\n-\tif !c.weClosed {\n-\t\tc.weClosed = true\n-\t\treturn c.sendClose()\n-\t}\n-\treturn nil\n-}\n-\n-// Thread safe channel list.\n-type chanlist struct {\n-\t// protects concurrent access to chans\n-\tsync.Mutex\n-\t// chans are indexed by the local id of the channel, clientChan.id.\n-\t// The PeersId value of messages received by ClientConn.mainLoop is\n-\t// used to locate the right local clientChan in this slice.\n-\tchans []*clientChan\n-}\n-\n-// Allocate a new ClientChan with the next avail local id.\n-func (c *chanlist) newChan(t *transport) *clientChan {\n-\tc.Lock()\n-\tdefer c.Unlock()\n-\tfor i := range c.chans {\n-\t\tif c.chans[i] == nil {\n-\t\t\tch := newClientChan(t, uint32(i))\n-\t\t\tc.chans[i] = ch\n-\t\t\treturn ch\n-\t\t}\n-\t}\n-\ti := len(c.chans)\n-\tch := newClientChan(t, uint32(i))\n-\tc.chans = append(c.chans, ch)\n-\treturn ch\n-}\n-\n-func (c *chanlist) getChan(id uint32) *clientChan {\n-\tc.Lock()\n-\tdefer c.Unlock()\n-\treturn c.chans[int(id)]\n-}\n-\n-func (c *chanlist) remove(id uint32) {\n-\tc.Lock()\n-\tdefer c.Unlock()\n-\tc.chans[int(id)] = nil\n-}\n-\n-// A chanWriter represents the stdin of a remote process.\n-type chanWriter struct {\n-\twin        chan int    // receives window adjustments\n-\trwin       int         // current rwin size\n-\tclientChan *clientChan // the channel backing this writer\n-}\n-\n-// Write writes data to the remote process's standard input.\n-func (w *chanWriter) Write(data []byte) (written int, err error) {\n-\tfor len(data) > 0 {\n-\t\tfor w.rwin < 1 {\n-\t\t\twin, ok := <-w.win\n-\t\t\tif !ok {\n-\t\t\t\treturn 0, io.EOF\n-\t\t\t}\n-\t\t\tw.rwin += win\n-\t\t}\n-\t\tn := min(len(data), w.rwin)\n-\t\tpeersId := w.clientChan.peersId\n-\t\tpacket := []byte{\n-\t\t\tmsgChannelData,\n-\t\t\tbyte(peersId >> 24), byte(peersId >> 16), byte(peersId >> 8), byte(peersId),\n-\t\t\tbyte(n >> 24), byte(n >> 16), byte(n >> 8), byte(n),\n-\t\t}\n-\t\tif err = w.clientChan.writePacket(append(packet, data[:n]...)); err != nil {\n-\t\t\tbreak\n-\t\t}\n-\t\tdata = data[n:]\n-\t\tw.rwin -= n\n-\t\twritten += n\n-\t}\n-\treturn\n-}\n-\n-func min(a, b int) int {\n-\tif a < b {\n-\t\treturn a\n-\t}\n-\treturn b\n-}\n-\n-func (w *chanWriter) Close() error {\n-\treturn w.clientChan.sendEOF()\n-}\n-\n-// A chanReader represents stdout or stderr of a remote process.\n-type chanReader struct {\n-\t// TODO(dfc) a fixed size channel may not be the right data structure.\n-\t// If writes to this channel block, they will block mainLoop, making\n-\t// it unable to receive new messages from the remote side.\n-\tdata       chan []byte // receives data from remote\n-\tdataClosed bool        // protects data from being closed twice\n-\tclientChan *clientChan // the channel backing this reader\n-\tbuf        []byte\n-}\n-\n-// eof signals to the consumer that there is no more data to be received.\n-func (r *chanReader) eof() {\n-\tif !r.dataClosed {\n-\t\tr.dataClosed = true\n-\t\tclose(r.data)\n-\t}\n-}\n-\n-// handleData sends buf to the reader's consumer. If r.data is closed\n-// the data will be silently discarded\n-func (r *chanReader) handleData(buf []byte) {\n-\tif !r.dataClosed {\n-\t\tr.data <- buf\n-\t}\n-}\n-\n-// Read reads data from the remote process's stdout or stderr.\n-func (r *chanReader) Read(data []byte) (int, error) {\n-\tvar ok bool\n-\tfor {\n-\t\tif len(r.buf) > 0 {\n-\t\t\tn := copy(data, r.buf)\n-\t\t\tr.buf = r.buf[n:]\n-\t\t\tmsg := windowAdjustMsg{\n-\t\t\t\tPeersId:         r.clientChan.peersId,\n-\t\t\t\tAdditionalBytes: uint32(n),\n-\t\t\t}\n-\t\t\treturn n, r.clientChan.writePacket(marshal(msgChannelWindowAdjust, msg))\n-\t\t}\n-\t\tr.buf, ok = <-r.data\n-\t\tif !ok {\n-\t\t\treturn 0, io.EOF\n-\t\t}\n-\t}\n-\tpanic(\"unreachable\")\n-}"}, {"sha": "3a7e9fb98017681e6da7e4dfdd3dd333d35f4067", "filename": "libgo/go/exp/ssh/client_auth.go", "status": "removed", "additions": 0, "deletions": 316, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d", "patch": "@@ -1,316 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package ssh\n-\n-import (\n-\t\"errors\"\n-\t\"io\"\n-)\n-\n-// authenticate authenticates with the remote server. See RFC 4252.\n-func (c *ClientConn) authenticate(session []byte) error {\n-\t// initiate user auth session\n-\tif err := c.writePacket(marshal(msgServiceRequest, serviceRequestMsg{serviceUserAuth})); err != nil {\n-\t\treturn err\n-\t}\n-\tpacket, err := c.readPacket()\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tvar serviceAccept serviceAcceptMsg\n-\tif err := unmarshal(&serviceAccept, packet, msgServiceAccept); err != nil {\n-\t\treturn err\n-\t}\n-\t// during the authentication phase the client first attempts the \"none\" method\n-\t// then any untried methods suggested by the server.\n-\ttried, remain := make(map[string]bool), make(map[string]bool)\n-\tfor auth := ClientAuth(new(noneAuth)); auth != nil; {\n-\t\tok, methods, err := auth.auth(session, c.config.User, c.transport, c.config.rand())\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tif ok {\n-\t\t\t// success\n-\t\t\treturn nil\n-\t\t}\n-\t\ttried[auth.method()] = true\n-\t\tdelete(remain, auth.method())\n-\t\tfor _, meth := range methods {\n-\t\t\tif tried[meth] {\n-\t\t\t\t// if we've tried meth already, skip it.\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tremain[meth] = true\n-\t\t}\n-\t\tauth = nil\n-\t\tfor _, a := range c.config.Auth {\n-\t\t\tif remain[a.method()] {\n-\t\t\t\tauth = a\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn errors.New(\"ssh: unable to authenticate, no supported methods remain\")\n-}\n-\n-// A ClientAuth represents an instance of an RFC 4252 authentication method.\n-type ClientAuth interface {\n-\t// auth authenticates user over transport t.\n-\t// Returns true if authentication is successful.\n-\t// If authentication is not successful, a []string of alternative\n-\t// method names is returned.\n-\tauth(session []byte, user string, t *transport, rand io.Reader) (bool, []string, error)\n-\n-\t// method returns the RFC 4252 method name.\n-\tmethod() string\n-}\n-\n-// \"none\" authentication, RFC 4252 section 5.2.\n-type noneAuth int\n-\n-func (n *noneAuth) auth(session []byte, user string, t *transport, rand io.Reader) (bool, []string, error) {\n-\tif err := t.writePacket(marshal(msgUserAuthRequest, userAuthRequestMsg{\n-\t\tUser:    user,\n-\t\tService: serviceSSH,\n-\t\tMethod:  \"none\",\n-\t})); err != nil {\n-\t\treturn false, nil, err\n-\t}\n-\n-\treturn handleAuthResponse(t)\n-}\n-\n-func (n *noneAuth) method() string {\n-\treturn \"none\"\n-}\n-\n-// \"password\" authentication, RFC 4252 Section 8.\n-type passwordAuth struct {\n-\tClientPassword\n-}\n-\n-func (p *passwordAuth) auth(session []byte, user string, t *transport, rand io.Reader) (bool, []string, error) {\n-\ttype passwordAuthMsg struct {\n-\t\tUser     string\n-\t\tService  string\n-\t\tMethod   string\n-\t\tReply    bool\n-\t\tPassword string\n-\t}\n-\n-\tpw, err := p.Password(user)\n-\tif err != nil {\n-\t\treturn false, nil, err\n-\t}\n-\n-\tif err := t.writePacket(marshal(msgUserAuthRequest, passwordAuthMsg{\n-\t\tUser:     user,\n-\t\tService:  serviceSSH,\n-\t\tMethod:   \"password\",\n-\t\tReply:    false,\n-\t\tPassword: pw,\n-\t})); err != nil {\n-\t\treturn false, nil, err\n-\t}\n-\n-\treturn handleAuthResponse(t)\n-}\n-\n-func (p *passwordAuth) method() string {\n-\treturn \"password\"\n-}\n-\n-// A ClientPassword implements access to a client's passwords.\n-type ClientPassword interface {\n-\t// Password returns the password to use for user.\n-\tPassword(user string) (password string, err error)\n-}\n-\n-// ClientAuthPassword returns a ClientAuth using password authentication.\n-func ClientAuthPassword(impl ClientPassword) ClientAuth {\n-\treturn &passwordAuth{impl}\n-}\n-\n-// ClientKeyring implements access to a client key ring.\n-type ClientKeyring interface {\n-\t// Key returns the i'th rsa.Publickey or dsa.Publickey, or nil if\n-\t// no key exists at i.\n-\tKey(i int) (key interface{}, err error)\n-\n-\t// Sign returns a signature of the given data using the i'th key\n-\t// and the supplied random source.\n-\tSign(i int, rand io.Reader, data []byte) (sig []byte, err error)\n-}\n-\n-// \"publickey\" authentication, RFC 4252 Section 7.\n-type publickeyAuth struct {\n-\tClientKeyring\n-}\n-\n-type publickeyAuthMsg struct {\n-\tUser    string\n-\tService string\n-\tMethod  string\n-\t// HasSig indicates to the reciver packet that the auth request is signed and\n-\t// should be used for authentication of the request.\n-\tHasSig   bool\n-\tAlgoname string\n-\tPubkey   string\n-\t// Sig is defined as []byte so marshal will exclude it during validateKey\n-\tSig []byte `ssh:\"rest\"`\n-}\n-\n-func (p *publickeyAuth) auth(session []byte, user string, t *transport, rand io.Reader) (bool, []string, error) {\n-\n-\t// Authentication is performed in two stages. The first stage sends an\n-\t// enquiry to test if each key is acceptable to the remote. The second\n-\t// stage attempts to authenticate with the valid keys obtained in the\n-\t// first stage.\n-\n-\tvar index int\n-\t// a map of public keys to their index in the keyring\n-\tvalidKeys := make(map[int]interface{})\n-\tfor {\n-\t\tkey, err := p.Key(index)\n-\t\tif err != nil {\n-\t\t\treturn false, nil, err\n-\t\t}\n-\t\tif key == nil {\n-\t\t\t// no more keys in the keyring\n-\t\t\tbreak\n-\t\t}\n-\n-\t\tif ok, err := p.validateKey(key, user, t); ok {\n-\t\t\tvalidKeys[index] = key\n-\t\t} else {\n-\t\t\tif err != nil {\n-\t\t\t\treturn false, nil, err\n-\t\t\t}\n-\t\t}\n-\t\tindex++\n-\t}\n-\n-\t// methods that may continue if this auth is not successful.\n-\tvar methods []string\n-\tfor i, key := range validKeys {\n-\t\tpubkey := serializePublickey(key)\n-\t\talgoname := algoName(key)\n-\t\tsign, err := p.Sign(i, rand, buildDataSignedForAuth(session, userAuthRequestMsg{\n-\t\t\tUser:    user,\n-\t\t\tService: serviceSSH,\n-\t\t\tMethod:  p.method(),\n-\t\t}, []byte(algoname), pubkey))\n-\t\tif err != nil {\n-\t\t\treturn false, nil, err\n-\t\t}\n-\t\t// manually wrap the serialized signature in a string\n-\t\ts := serializeSignature(algoname, sign)\n-\t\tsig := make([]byte, stringLength(s))\n-\t\tmarshalString(sig, s)\n-\t\tmsg := publickeyAuthMsg{\n-\t\t\tUser:     user,\n-\t\t\tService:  serviceSSH,\n-\t\t\tMethod:   p.method(),\n-\t\t\tHasSig:   true,\n-\t\t\tAlgoname: algoname,\n-\t\t\tPubkey:   string(pubkey),\n-\t\t\tSig:      sig,\n-\t\t}\n-\t\tp := marshal(msgUserAuthRequest, msg)\n-\t\tif err := t.writePacket(p); err != nil {\n-\t\t\treturn false, nil, err\n-\t\t}\n-\t\tsuccess, methods, err := handleAuthResponse(t)\n-\t\tif err != nil {\n-\t\t\treturn false, nil, err\n-\t\t}\n-\t\tif success {\n-\t\t\treturn success, methods, err\n-\t\t}\n-\t}\n-\treturn false, methods, nil\n-}\n-\n-// validateKey validates the key provided it is acceptable to the server.\n-func (p *publickeyAuth) validateKey(key interface{}, user string, t *transport) (bool, error) {\n-\tpubkey := serializePublickey(key)\n-\talgoname := algoName(key)\n-\tmsg := publickeyAuthMsg{\n-\t\tUser:     user,\n-\t\tService:  serviceSSH,\n-\t\tMethod:   p.method(),\n-\t\tHasSig:   false,\n-\t\tAlgoname: algoname,\n-\t\tPubkey:   string(pubkey),\n-\t}\n-\tif err := t.writePacket(marshal(msgUserAuthRequest, msg)); err != nil {\n-\t\treturn false, err\n-\t}\n-\n-\treturn p.confirmKeyAck(key, t)\n-}\n-\n-func (p *publickeyAuth) confirmKeyAck(key interface{}, t *transport) (bool, error) {\n-\tpubkey := serializePublickey(key)\n-\talgoname := algoName(key)\n-\n-\tfor {\n-\t\tpacket, err := t.readPacket()\n-\t\tif err != nil {\n-\t\t\treturn false, err\n-\t\t}\n-\t\tswitch packet[0] {\n-\t\tcase msgUserAuthBanner:\n-\t\t\t// TODO(gpaul): add callback to present the banner to the user\n-\t\tcase msgUserAuthPubKeyOk:\n-\t\t\tmsg := decode(packet).(*userAuthPubKeyOkMsg)\n-\t\t\tif msg.Algo != algoname || msg.PubKey != string(pubkey) {\n-\t\t\t\treturn false, nil\n-\t\t\t}\n-\t\t\treturn true, nil\n-\t\tcase msgUserAuthFailure:\n-\t\t\treturn false, nil\n-\t\tdefault:\n-\t\t\treturn false, UnexpectedMessageError{msgUserAuthSuccess, packet[0]}\n-\t\t}\n-\t}\n-\tpanic(\"unreachable\")\n-}\n-\n-func (p *publickeyAuth) method() string {\n-\treturn \"publickey\"\n-}\n-\n-// ClientAuthKeyring returns a ClientAuth using public key authentication.\n-func ClientAuthKeyring(impl ClientKeyring) ClientAuth {\n-\treturn &publickeyAuth{impl}\n-}\n-\n-// handleAuthResponse returns whether the preceding authentication request succeeded\n-// along with a list of remaining authentication methods to try next and\n-// an error if an unexpected response was received.\n-func handleAuthResponse(t *transport) (bool, []string, error) {\n-\tfor {\n-\t\tpacket, err := t.readPacket()\n-\t\tif err != nil {\n-\t\t\treturn false, nil, err\n-\t\t}\n-\n-\t\tswitch packet[0] {\n-\t\tcase msgUserAuthBanner:\n-\t\t\t// TODO: add callback to present the banner to the user\n-\t\tcase msgUserAuthFailure:\n-\t\t\tmsg := decode(packet).(*userAuthFailureMsg)\n-\t\t\treturn false, msg.Methods, nil\n-\t\tcase msgUserAuthSuccess:\n-\t\t\treturn true, nil, nil\n-\t\tcase msgDisconnect:\n-\t\t\treturn false, nil, io.EOF\n-\t\tdefault:\n-\t\t\treturn false, nil, UnexpectedMessageError{msgUserAuthSuccess, packet[0]}\n-\t\t}\n-\t}\n-\tpanic(\"unreachable\")\n-}"}, {"sha": "c41a93b5c7dbf91c0de8961b1b2d4907b9036ee7", "filename": "libgo/go/exp/ssh/client_auth_test.go", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "b4bdba95396bcc64c83e33482bd2ef337dff3bac", "filename": "libgo/go/exp/ssh/client_func_test.go", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fclient_func_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fclient_func_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fclient_func_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "6844fb89b792c7824c6ecfc677087f3c3abe6345", "filename": "libgo/go/exp/ssh/common.go", "status": "removed", "additions": 0, "deletions": 239, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fcommon.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "058fb04fe1b482bc751180eedfa613f05f0b3384", "filename": "libgo/go/exp/ssh/common_test.go", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fcommon_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fcommon_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fcommon_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "e7deb5ec168831488a3c9600c77cf1b86ad02c41", "filename": "libgo/go/exp/ssh/doc.go", "status": "removed", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fdoc.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "34ad131ff64e7f5d927857746e94b4c472c0da24", "filename": "libgo/go/exp/ssh/messages.go", "status": "removed", "additions": 0, "deletions": 640, "changes": 640, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fmessages.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fmessages.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fmessages.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "fe4c397dc3a2ccc6bb81c1a474adef54b564874f", "filename": "libgo/go/exp/ssh/messages_test.go", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fmessages_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fmessages_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fmessages_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "31011c6617677658f1b2a4f1138534b49134e8ab", "filename": "libgo/go/exp/ssh/server.go", "status": "removed", "additions": 0, "deletions": 676, "changes": 676, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "708a9159ec8ae5e5641456f779f2d41d00d1ddf4", "filename": "libgo/go/exp/ssh/server_terminal.go", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fserver_terminal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fserver_terminal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fserver_terminal.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "ea4addbd50b074abda90bf3fbb25ebf7fb3d45b5", "filename": "libgo/go/exp/ssh/session.go", "status": "removed", "additions": 0, "deletions": 494, "changes": 494, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fsession.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fsession.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fsession.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "4a3d22bee04f905be3cdf581f7a8a12955892c8b", "filename": "libgo/go/exp/ssh/session_test.go", "status": "removed", "additions": 0, "deletions": 374, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fsession_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Fsession_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fsession_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "e0c47bca1fcd4180dc89b56f73e3091443fdcbc8", "filename": "libgo/go/exp/ssh/tcpip.go", "status": "removed", "additions": 0, "deletions": 132, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "261297241e9edcc41c6f8bb464d8f616d6f9038e", "filename": "libgo/go/exp/ssh/tcpip_func_test.go", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip_func_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip_func_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip_func_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "e21bc4ba2025084bf687e0b2676ab7197f77739a", "filename": "libgo/go/exp/ssh/transport.go", "status": "removed", "additions": 0, "deletions": 369, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "ab9177f0d11fa42e3e80b4f0e7e040e29becbea3", "filename": "libgo/go/exp/ssh/transport_test.go", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fexp%2Fssh%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Ftransport_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "2d4f69aaea6ca0c1776e509006a665ea8d89f51b", "filename": "libgo/go/go/ast/import.go", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fast%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fast%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fimport.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "68e8d34200530753b76c4880a447cd7e9e66dcd8", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 1, "deletions": 424, "changes": 425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "381e2b2d96a2ab433ab30244e660606613911075", "filename": "libgo/go/go/build/build_test.go", "status": "modified", "additions": 23, "deletions": 33, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "d49846f7d4dea114305d2a2da713509e85dcf6cd", "filename": "libgo/go/go/build/dir.go", "status": "modified", "additions": 108, "deletions": 20, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "7e931faff1926a43f36044f9ff8cde7aee6cc919", "filename": "libgo/go/go/build/path.go", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "d4aae8ff05c27a9bbc3410aaa4649bd35235f6e3", "filename": "libgo/go/go/doc/doc.go", "status": "modified", "additions": 41, "deletions": 48, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "d9ffe47b61406ffefc1559238c641e7aab6b4278", "filename": "libgo/go/go/doc/doc_test.go", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "e6f58ccb3507c9afe6cb5498abb9e5a6f971bbb8", "filename": "libgo/go/go/doc/exports.go", "status": "modified", "additions": 57, "deletions": 69, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "02b66ccefafcd5076e3b66cac7f6a353d105e916", "filename": "libgo/go/go/doc/filter.go", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ffilter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ffilter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ffilter.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "9c6f0816b60f81e864accc1ea477e559d63a9ffd", "filename": "libgo/go/go/doc/reader.go", "status": "modified", "additions": 536, "deletions": 493, "changes": 1029, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "24db02d348f5cc81cdabfb978d126d185d74a710", "filename": "libgo/go/go/doc/testdata/a.0.golden", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa.0.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa.0.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa.0.golden?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/go/doc/testdata/a.out"}, {"sha": "24db02d348f5cc81cdabfb978d126d185d74a710", "filename": "libgo/go/go/doc/testdata/a.1.golden", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa.1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa.1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa.1.golden?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "7c33300616d2b87549e6c86a431c3d61a035a8ba", "filename": "libgo/go/go/doc/testdata/b.0.golden", "status": "renamed", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.0.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.0.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.0.golden?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/go/doc/testdata/b.out"}, {"sha": "f30380516bda5bed1153b662377afc5ca7b7a1e1", "filename": "libgo/go/go/doc/testdata/b.1.golden", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.1.golden?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "28660f9be7c73ac095f6c532819b984e41ebe0f5", "filename": "libgo/go/go/doc/testdata/b.go", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "e21959b1950dc58cfc863c4ae96fec3b45ac0bbf", "filename": "libgo/go/go/doc/testdata/c.0.golden", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fc.0.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fc.0.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fc.0.golden?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "e21959b1950dc58cfc863c4ae96fec3b45ac0bbf", "filename": "libgo/go/go/doc/testdata/c.1.golden", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fc.1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fc.1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fc.1.golden?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "e0f39196deea8bfd1afd24ac4acf1d7bcd00f50c", "filename": "libgo/go/go/doc/testdata/c.go", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fc.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "c0051995334af6ae93a4aa150e70a7026d6d9c1b", "filename": "libgo/go/go/doc/testdata/d.0.golden", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fd.0.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fd.0.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fd.0.golden?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "c0051995334af6ae93a4aa150e70a7026d6d9c1b", "filename": "libgo/go/go/doc/testdata/d.1.golden", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fd.1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fd.1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fd.1.golden?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "ebd69419589f1ad038b9aa0cd817313d34a34c36", "filename": "libgo/go/go/doc/testdata/d1.go", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fd1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fd1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fd1.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "2f56f4fa4ca3a14b9e67823d68db03591de7ef91", "filename": "libgo/go/go/doc/testdata/d2.go", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fd2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fd2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fd2.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "3b128f7be8bda3f74c33fbceaefd46a035157048", "filename": "libgo/go/go/doc/testdata/e.0.golden", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.0.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.0.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.0.golden?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "d05602d82cb9dab9ea5c3c9e6692c9539e62656a", "filename": "libgo/go/go/doc/testdata/e.1.golden", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.1.golden?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "8ea6a83b66aaca3f92af772705760556d1e56329", "filename": "libgo/go/go/doc/testdata/e.go", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "15a90398664c504dab7ecfa89c143e8cc2516ac1", "filename": "libgo/go/go/doc/testdata/testing.0.golden", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.0.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.0.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.0.golden?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b", "previous_filename": "libgo/go/go/doc/testdata/testing.out"}, {"sha": "1f92f8fe3e1102589fcfe5cae5d54673a592eaf7", "filename": "libgo/go/go/doc/testdata/testing.1.golden", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.1.golden?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "f1b4ce34d1a04fc33a4c37f735d7b023497c3c06", "filename": "libgo/go/go/parser/interface.go", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "6bee8de9f65e04fc3a95ca9be548d3f6a4cd0502", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "5f3b4d4a740b8dcc58649c710ba2bc0dda625ecf", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 53, "deletions": 37, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "52dfff6f4b369863f55f3197971ea4d4a2f929c9", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "928b8ce0a9f826b1f9bf92b72493cbd82c7c19c0", "filename": "libgo/go/go/printer/testdata/declarations.golden", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "006cf1718483d97da5a9d38d2d5db867a11407ed", "filename": "libgo/go/go/printer/testdata/linebreaks.golden", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Flinebreaks.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Flinebreaks.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Flinebreaks.golden?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "e782bb04443702ecc1d94d2fe8bcab776478d723", "filename": "libgo/go/go/printer/testdata/linebreaks.input", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Flinebreaks.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Flinebreaks.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Flinebreaks.input?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "7c72c0a46b922372165aa1b1f47185962d95ac14", "filename": "libgo/go/go/scanner/scanner.go", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "af45bc5b1c8af8788a4275c07a97def3fd573867", "filename": "libgo/go/go/scanner/scanner_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "c0b5262af83a712ba572982a3daaa8ab6607dd87", "filename": "libgo/go/html/escape.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fhtml%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fhtml%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fescape.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "cbe1a5839df3256c109099b9ece9621d84b2901d", "filename": "libgo/go/io/ioutil/ioutil.go", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "41de17ba416f50bae06bf0f30a70e538ef3e01d8", "filename": "libgo/go/math/big/arith.go", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fmath%2Fbig%2Farith.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fmath%2Fbig%2Farith.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Farith.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "068cc8d93888f82385d614b4e5e023b865707b28", "filename": "libgo/go/math/big/arith_decl.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fmath%2Fbig%2Farith_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fmath%2Fbig%2Farith_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Farith_decl.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "c7e3d284c2de624679f0104b6f1e1963d0790a46", "filename": "libgo/go/math/big/arith_test.go", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fmath%2Fbig%2Farith_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fmath%2Fbig%2Farith_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Farith_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "52e57d7400e075ef3f6ee968bed1616ee93ed792", "filename": "libgo/go/net/cgo_stub.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fcgo_stub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fcgo_stub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fcgo_stub.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "5d596bcb6b4b93bee0f337f5784233bade38cbec", "filename": "libgo/go/net/dial.go", "status": "modified", "additions": 97, "deletions": 84, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fdial.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fdial.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "81750a3d73967b05f29889b9a507d16bc7dfc5a4", "filename": "libgo/go/net/dialgoogle_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "e7f5290f5522ed9dffc05ca946c6faec01b12df9", "filename": "libgo/go/net/dict/dict.go", "status": "removed", "additions": 0, "deletions": 210, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fnet%2Fdict%2Fdict.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fnet%2Fdict%2Fdict.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdict%2Fdict.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "495ef007fe20ea4a2b71efb2bd58f131155fe7ba", "filename": "libgo/go/net/fd.go", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Ffd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Ffd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "f00459f0bafe194f2c483429e2d789b6c34cabac", "filename": "libgo/go/net/fd_windows.go", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Ffd_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Ffd_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_windows.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "c9f024017573ea107bb42443a3b56f80badea05a", "filename": "libgo/go/net/http/client.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "aa0bf4be676a23486a3074f15c93b9aa17a5ce46", "filename": "libgo/go/net/http/client_test.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "2e03c658aa90bdb6ada675e8970c61e558aaf185", "filename": "libgo/go/net/http/readrequest_test.go", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fhttp%2Freadrequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fhttp%2Freadrequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Freadrequest_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "5f8c00086bee74b09b5da98c1b4c1df3f6deab91", "filename": "libgo/go/net/http/request.go", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "7a3556d03674c0ed057eed03ee2dfb29e19dd8b3", "filename": "libgo/go/net/http/request_test.go", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fhttp%2Frequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fhttp%2Frequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequest_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "4de070f01f10d806c71db938b6d2a6ee80ed6b2b", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "321da52e2781ab2b40bc08ebe8e6b89ae26e147f", "filename": "libgo/go/net/http/transport_test.go", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "f9401c1104e37c2b658e79367ddb1b71ff08e3e9", "filename": "libgo/go/net/ipraw_test.go", "status": "modified", "additions": 149, "deletions": 79, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fipraw_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fipraw_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipraw_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "859153c2aad6449d6757bf3bf49434e251863db2", "filename": "libgo/go/net/iprawsock_plan9.go", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "c34ffeb121df042295cddcf586234ed03bf7276f", "filename": "libgo/go/net/iprawsock_posix.go", "status": "modified", "additions": 34, "deletions": 51, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "c0bb9225a7dc862502be3ff00674e431807c86bb", "filename": "libgo/go/net/lookup_plan9.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Flookup_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Flookup_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_plan9.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "abc1e59cd510858c66b3c70ff33c7a9a2af09957", "filename": "libgo/go/net/rpc/client.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Frpc%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Frpc%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Frpc%2Fclient.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "b05c63c0563d747cf4d6be5dc4c33b8d67183025", "filename": "libgo/go/net/rpc/server_test.go", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Frpc%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Frpc%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Frpc%2Fserver_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "867e328f12eb419a78d4f65e4d0798e7ab907d1d", "filename": "libgo/go/net/sock.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "3d0f8dd7a89622ecd6a72ca040b181b1c96b6d94", "filename": "libgo/go/net/sockopt.go", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fsockopt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fsockopt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "f2444a4d96f9c331242ca1c0fc898d46f951e4c9", "filename": "libgo/go/net/tcpsock_plan9.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Ftcpsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Ftcpsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock_plan9.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "65ec493039cbd9a360f99b38cf3f3179b268faf6", "filename": "libgo/go/net/tcpsock_posix.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "bae37c86b2ed3b32fa511b387b5fca94b8f5c2d7", "filename": "libgo/go/net/timeout_test.go", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftimeout_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "6ba762b1f78af65e06773e265f3ec13cdb3eaae4", "filename": "libgo/go/net/udp_test.go", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fudp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fudp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudp_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "573438f85de3ca1c6f2c05d00749ce8f62df96d2", "filename": "libgo/go/net/udpsock_plan9.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fudpsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fudpsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock_plan9.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "fa3d29adfa8cf21826bf2f81288b25b14a6afafc", "filename": "libgo/go/net/udpsock_posix.go", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock_posix.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "e500ddb4e0f30a80ff1280315c58f9bf0b90a155", "filename": "libgo/go/net/unixsock_posix.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Funixsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fnet%2Funixsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funixsock_posix.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "7d136eb36868b8c2fed927c4f8fa14866ebfb3aa", "filename": "libgo/go/os/file_plan9.go", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fos%2Ffile_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fos%2Ffile_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_plan9.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "f731e43740a8d268129e24439c2de2a7b626ed9c", "filename": "libgo/go/os/stat_plan9.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fos%2Fstat_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fos%2Fstat_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fstat_plan9.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "10f5170a9c92666141340fcd50627373ee509871", "filename": "libgo/go/os/user/lookup_stubs.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fos%2Fuser%2Flookup_stubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fos%2Fuser%2Flookup_stubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Flookup_stubs.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "7c4f4ada414b16bc7b5c6ef7608e30cf40e6b5e0", "filename": "libgo/go/patch/apply.go", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fpatch%2Fapply.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fpatch%2Fapply.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpatch%2Fapply.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "5c233fbaebff6f6e66180d344d449a97d52f3541", "filename": "libgo/go/patch/git.go", "status": "removed", "additions": 0, "deletions": 121, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fpatch%2Fgit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fpatch%2Fgit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpatch%2Fgit.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "1d804f3362e864cb898b56b9d55397a2ce08e873", "filename": "libgo/go/patch/patch.go", "status": "removed", "additions": 0, "deletions": 321, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fpatch%2Fpatch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fpatch%2Fpatch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpatch%2Fpatch.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "0a4aef7ea622ef17b2cd80f7b47085c45dbe3032", "filename": "libgo/go/patch/patch_test.go", "status": "removed", "additions": 0, "deletions": 390, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fpatch%2Fpatch_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fpatch%2Fpatch_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpatch%2Fpatch_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "c9cffee11c48fcdef0a7e56381a996c5fd81e427", "filename": "libgo/go/patch/textdiff.go", "status": "removed", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fpatch%2Ftextdiff.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fpatch%2Ftextdiff.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpatch%2Ftextdiff.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "2601d1838487fd2a4c80c6c6c7ac3c193cf9286a", "filename": "libgo/go/path/filepath/path_test.go", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "7aebd3728a3dc5a9da5b1b6661dd52e3a85f96db", "filename": "libgo/go/regexp/regexp.go", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fregexp%2Fregexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fregexp%2Fregexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fregexp.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "eb2c7c60d0cdc0bdeeee8924fa2296b27268d0eb", "filename": "libgo/go/runtime/chan_test.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fruntime%2Fchan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fruntime%2Fchan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fchan_test.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "4f09146fac172640a9acf7280589e41b92d21098", "filename": "libgo/go/runtime/debug.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fruntime%2Fdebug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fruntime%2Fdebug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdebug.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "eafa2f19f19e929ddbaf17617ad49922eba602bd", "filename": "libgo/go/runtime/extern.go", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fruntime%2Fextern.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af4cb9545ce481b8d9d4a13acfe26512032e21b/libgo%2Fgo%2Fruntime%2Fextern.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fextern.go?ref=9af4cb9545ce481b8d9d4a13acfe26512032e21b"}, {"sha": "89cdcda71aeda5bd27947c32cac0a3d15e35a3fc", "filename": "libgo/go/websocket/client.go", "status": "removed", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fwebsocket%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fwebsocket%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fclient.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "22dbc1f8db37f204b16e286e443c010a62224170", "filename": "libgo/go/websocket/hixie.go", "status": "removed", "additions": 0, "deletions": 695, "changes": 695, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fwebsocket%2Fhixie.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fwebsocket%2Fhixie.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fhixie.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "bf537c01b7371586031869076ca1967091edb635", "filename": "libgo/go/websocket/hixie_test.go", "status": "removed", "additions": 0, "deletions": 201, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fwebsocket%2Fhixie_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fwebsocket%2Fhixie_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fhixie_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "6b0c5286f2820a8006a9949fdc34484db76fc22a", "filename": "libgo/go/websocket/hybi.go", "status": "removed", "additions": 0, "deletions": 549, "changes": 549, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fwebsocket%2Fhybi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fwebsocket%2Fhybi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fhybi.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "60375ff32ad276c4415fc4b0d67339bee91d0c8e", "filename": "libgo/go/websocket/hybi_test.go", "status": "removed", "additions": 0, "deletions": 584, "changes": 584, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fwebsocket%2Fhybi_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fwebsocket%2Fhybi_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fhybi_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "63f48e25693c6a30c58e59366c0485075125aa76", "filename": "libgo/go/websocket/server.go", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fwebsocket%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fwebsocket%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fserver.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "f7aabc94b35d1d48dd9c63fa9705a9e3512785be", "filename": "libgo/go/websocket/websocket.go", "status": "removed", "additions": 0, "deletions": 412, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fwebsocket%2Fwebsocket.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fwebsocket%2Fwebsocket.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fwebsocket.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}, {"sha": "f41c355fac262b7659efe007453bfa3dec1361c6", "filename": "libgo/go/websocket/websocket_test.go", "status": "removed", "additions": 0, "deletions": 274, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fwebsocket%2Fwebsocket_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6cd722f329a168f98d1f421834cf40bb33a77d/libgo%2Fgo%2Fwebsocket%2Fwebsocket_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fwebsocket_test.go?ref=6b6cd722f329a168f98d1f421834cf40bb33a77d"}]}