{"sha": "8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGJjZjE1ZjZlYTBiY2Q4ZWNhNzBiYzgzZjUzOTBhN2JmNDY0YzIyMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-08-30T10:38:55Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-08-30T10:38:55Z"}, "message": "parse.c (parse_interface): Silence uninitialized var warning.\n\n\n\t* parse.c (parse_interface): Silence uninitialized var warning.\n\n\t* postreload-gcse.c (gate_handle_gcse2): Disable for functions\n\toptimized for speed.\n\t* final.c (compute_alignments): Use optimize_bb_for_size_p.\n\t* tree-call-cdce.c (gate_call_cdce): Use optimize_function_for_speed_p.\n\t* opts.c (flag_predictive_commoning_set, flag_unswitch_loops_set,\n\tflag_gcse_after_reload_set): New static vars.\n\t(common_handle_option): Enable those flags for profile-use.\n\t(decode_options): Remove optimize_size flags that are handled\n\ton higher granuality.\n\t* tree-vectorizer.c (vectorize_loops): Use\n\toptimize_loop_nest_for_speed_p.\n\t* tree-ssa-pre.c (do_pre): Use optimize_function_for_speed_p.\n\t* tree-predcom.c (tree_predictive_commoning): Use\n\toptimize_loop_for_speed_p.\n\t* varasm.c (assemble_start_function): Use optimize_function_for_speed_p.\n\t* bb-reorder.c (rest_of_handle_reorder_blocks): Likewise.\n\t* predict.c (optimize_loop_for_speed_p): Fix walk.\n\nFrom-SVN: r139801", "tree": {"sha": "bd32e842f1dc6dd55db511672ed8034ae7e0f1f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd32e842f1dc6dd55db511672ed8034ae7e0f1f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/comments", "author": null, "committer": null, "parents": [{"sha": "76718c16d01e0ad14bb682f479f19702d093800d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76718c16d01e0ad14bb682f479f19702d093800d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76718c16d01e0ad14bb682f479f19702d093800d"}], "stats": {"total": 125, "additions": 77, "deletions": 48}, "files": [{"sha": "5a2ec127e49007b4488c424607c879f4182b8751", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223", "patch": "@@ -1,3 +1,23 @@\n+2008-08-30  Jan Hubicka  <jh@suse.cz>\n+\n+\t* postreload-gcse.c (gate_handle_gcse2): Disable for functions\n+\toptimized for speed.\n+\t* final.c (compute_alignments): Use optimize_bb_for_size_p.\n+\t* tree-call-cdce.c (gate_call_cdce): Use optimize_function_for_speed_p.\n+\t* opts.c (flag_predictive_commoning_set, flag_unswitch_loops_set,\n+\tflag_gcse_after_reload_set): New static vars.\n+\t(common_handle_option): Enable those flags for profile-use.\n+\t(decode_options): Remove optimize_size flags that are handled\n+\ton higher granuality.\n+\t* tree-vectorizer.c (vectorize_loops): Use\n+\toptimize_loop_nest_for_speed_p.\n+\t* tree-ssa-pre.c (do_pre): Use optimize_function_for_speed_p.\n+\t* tree-predcom.c (tree_predictive_commoning): Use\n+\toptimize_loop_for_speed_p.\n+\t* varasm.c (assemble_start_function): Use optimize_function_for_speed_p.\n+\t* bb-reorder.c (rest_of_handle_reorder_blocks): Likewise.\n+\t* predict.c (optimize_loop_for_speed_p): Fix walk.\n+\n 2008-08-30  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-inline.c (cgraph_estimate_growth): Discover self recursive"}, {"sha": "b636c1e3a1dfeffd9e15bda33f433d83977f942e", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223", "patch": "@@ -2225,7 +2225,15 @@ rest_of_handle_reorder_blocks (void)\n      splitting possibly introduced more crossjumping opportunities.  */\n   cfg_layout_initialize (CLEANUP_EXPENSIVE);\n \n-  if (flag_reorder_blocks || flag_reorder_blocks_and_partition)\n+  if ((flag_reorder_blocks || flag_reorder_blocks_and_partition)\n+      /* Don't reorder blocks when optimizing for size because extra jump insns may\n+\t be created; also barrier may create extra padding.\n+\n+\t More correctly we should have a block reordering mode that tried to\n+\t minimize the combined size of all the jumps.  This would more or less\n+\t automatically remove extra jumps, but would also try to use more short\n+\t jumps instead of long jumps.  */\n+      && optimize_function_for_speed_p (cfun))\n     {\n       reorder_basic_blocks ();\n       cleanup_cfg (CLEANUP_EXPENSIVE);"}, {"sha": "c1359e8410a6d27624b374408be9a64760644159", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223", "patch": "@@ -707,7 +707,7 @@ compute_alignments (void)\n       edge_iterator ei;\n \n       if (!LABEL_P (label)\n-\t  || probably_never_executed_bb_p (bb))\n+\t  || optimize_bb_for_size_p (bb))\n \t{\n \t  if (dump_file)\n \t    fprintf(dump_file, \"BB %4i freq %4i loop %2i loop_depth %2i skipped.\\n\","}, {"sha": "6a88c38e724fcdb2060e57d945e1d82d54cdbabc", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223", "patch": "@@ -1,6 +1,6 @@\n 2008-08-29  Jan Hubicka  <jh@suse.cz>\n \t\n-\t* parse.c (parse_interface): Likewise.\n+\t* parse.c (parse_interface): Silence uninitialized var warning.\n \n 2008-08-29  Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "621f6b3fff3dc62cd2523a85a48d3ebf027abcc1", "filename": "gcc/opts.c", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223", "patch": "@@ -348,6 +348,7 @@ static bool flag_unroll_loops_set, flag_tracer_set;\n static bool flag_value_profile_transformations_set;\n static bool flag_peel_loops_set, flag_branch_probabilities_set;\n static bool flag_inline_functions_set, flag_ipa_cp_set, flag_ipa_cp_clone_set;\n+static bool flag_predictive_commoning_set, flag_unswitch_loops_set, flag_gcse_after_reload_set;\n \n /* Functions excluded from profiling.  */\n \n@@ -993,37 +994,10 @@ decode_options (unsigned int argc, const char **argv)\n \n   if (optimize_size)\n     {\n-      /* Conditional DCE generates bigger code.  */\n-      flag_tree_builtin_call_dce = 0;\n-\n-      /* PRE tends to generate bigger code.  */\n-      flag_tree_pre = 0;\n-\n-      /* These options are set with -O3, so reset for -Os */\n-      flag_predictive_commoning = 0;\n-      flag_gcse_after_reload = 0;\n-      flag_tree_vectorize = 0;\n-\n-      /* Don't reorder blocks when optimizing for size because extra jump insns may\n-\t be created; also barrier may create extra padding.\n-\n-\t More correctly we should have a block reordering mode that tried to\n-\t minimize the combined size of all the jumps.  This would more or less\n-\t automatically remove extra jumps, but would also try to use more short\n-\t jumps instead of long jumps.  */\n-      flag_reorder_blocks = 0;\n-      flag_reorder_blocks_and_partition = 0;\n-\n       /* Inlining of functions reducing size is a good idea regardless of them\n \t being declared inline.  */\n       flag_inline_functions = 1;\n \n-      /* Don't align code.  */\n-      align_loops = 1;\n-      align_jumps = 1;\n-      align_labels = 1;\n-      align_functions = 1;\n-\n       /* Basic optimization options.  */\n       optimize_size = 1;\n       if (optimize > 2)\n@@ -1839,6 +1813,12 @@ common_handle_option (size_t scode, const char *arg, int value,\n       if (!flag_ipa_cp_clone_set\n \t  && value && flag_ipa_cp)\n \tflag_ipa_cp_clone = value;\n+      if (!flag_predictive_commoning_set)\n+\tflag_predictive_commoning = value;\n+      if (!flag_unswitch_loops_set)\n+\tflag_unswitch_loops = value;\n+      if (!flag_gcse_after_reload_set)\n+\tflag_gcse_after_reload = value;\n       break;\n \n     case OPT_fprofile_generate_:\n@@ -2004,6 +1984,18 @@ common_handle_option (size_t scode, const char *arg, int value,\n       flag_ipa_cp_clone_set = true;\n       break;\n \n+    case OPT_fpredictive_commoning:\n+      flag_predictive_commoning_set = true;\n+      break;\n+\n+    case OPT_funswitch_loops:\n+      flag_unswitch_loops_set = true;\n+      break;\n+\n+    case OPT_fgcse_after_reload:\n+      flag_gcse_after_reload_set = true;\n+      break;\n+\n     case OPT_funroll_loops:\n       flag_unroll_loops_set = true;\n       break;"}, {"sha": "884830abebd2c1c912e13ca7757abf2bda202635", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223", "patch": "@@ -1306,7 +1306,8 @@ gcse_after_reload_main (rtx f ATTRIBUTE_UNUSED)\n static bool\n gate_handle_gcse2 (void)\n {\n-  return (optimize > 0 && flag_gcse_after_reload);\n+  return (optimize > 0 && flag_gcse_after_reload\n+\t  && optimize_function_for_speed_p (cfun));\n }\n \n "}, {"sha": "d5de938ccfaca35704722d64162a18160bd7bbaa", "filename": "gcc/predict.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223", "patch": "@@ -300,7 +300,12 @@ optimize_loop_nest_for_speed_p (struct loop *loop)\n       else if (l->next)\n         l = l->next;\n       else\n-\tl = loop_outer (l);\n+        {\n+\t  while (l != loop && !l->next)\n+\t    l = loop_outer (l);\n+\t  if (l != loop)\n+\t    l = l->next;\n+\t}\n     }\n   return false;\n }"}, {"sha": "f59f083d5c987bc5cc3aeb9feff9d1ecdf91e484", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223", "patch": "@@ -913,7 +913,7 @@ gate_call_cdce (void)\n   /* The limit constants used in the implementation\n      assume IEEE floating point format.  Other formats\n      can be supported in the future if needed.  */\n-  return flag_tree_builtin_call_dce != 0; \n+  return flag_tree_builtin_call_dce != 0 && optimize_function_for_speed_p (cfun); \n }\n \n struct gimple_opt_pass pass_call_cdce ="}, {"sha": "85cfbd66d898dd35a8d7acbd76e36c12b97bf722", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223", "patch": "@@ -2650,9 +2650,10 @@ tree_predictive_commoning (void)\n \n   initialize_original_copy_tables ();\n   FOR_EACH_LOOP (li, loop, LI_ONLY_INNERMOST)\n-    {\n-      unrolled |= tree_predictive_commoning_loop (loop);\n-    }\n+    if (optimize_loop_for_speed_p (loop))\n+      {\n+\tunrolled |= tree_predictive_commoning_loop (loop);\n+      }\n \n   if (unrolled)\n     {"}, {"sha": "8324f09aaa2ae59de382c17ff10350db9d866a44", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223", "patch": "@@ -4230,7 +4230,8 @@ do_pre (void)\n static bool\n gate_pre (void)\n {\n-  return flag_tree_pre != 0;\n+  /* PRE tends to generate bigger code.  */\n+  return flag_tree_pre != 0 && optimize_function_for_speed_p (cfun);\n }\n \n struct gimple_opt_pass pass_pre ="}, {"sha": "474860adedbcbc5f515cd4fb699a5048d5b4064a", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223", "patch": "@@ -2806,19 +2806,20 @@ vectorize_loops (void)\n      than all previously defined loops. This fact allows us to run \n      only over initial loops skipping newly generated ones.  */\n   FOR_EACH_LOOP (li, loop, 0)\n-    {\n-      loop_vec_info loop_vinfo;\n+    if (optimize_loop_nest_for_speed_p (loop))\n+      {\n+\tloop_vec_info loop_vinfo;\n \n-      vect_loop_location = find_loop_location (loop);\n-      loop_vinfo = vect_analyze_loop (loop);\n-      loop->aux = loop_vinfo;\n+\tvect_loop_location = find_loop_location (loop);\n+\tloop_vinfo = vect_analyze_loop (loop);\n+\tloop->aux = loop_vinfo;\n \n-      if (!loop_vinfo || !LOOP_VINFO_VECTORIZABLE_P (loop_vinfo))\n-\tcontinue;\n+\tif (!loop_vinfo || !LOOP_VINFO_VECTORIZABLE_P (loop_vinfo))\n+\t  continue;\n \n-      vect_transform_loop (loop_vinfo);\n-      num_vectorized_loops++;\n-    }\n+\tvect_transform_loop (loop_vinfo);\n+\tnum_vectorized_loops++;\n+      }\n   vect_loop_location = UNKNOWN_LOC;\n \n   statistics_counter_event (cfun, \"Vectorized loops\", num_vectorized_loops);"}, {"sha": "5aa0140e002a071e84683abfb82bb8021a281a37", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=8bcf15f6ea0bcd8eca70bc83f5390a7bf464c223", "patch": "@@ -1723,7 +1723,7 @@ assemble_start_function (tree decl, const char *fnname)\n      because ASM_OUTPUT_MAX_SKIP_ALIGN might not do any alignment at all.  */\n   if (! DECL_USER_ALIGN (decl)\n       && align_functions_log > align\n-      && cfun->function_frequency != FUNCTION_FREQUENCY_UNLIKELY_EXECUTED)\n+      && optimize_function_for_speed_p (cfun))\n     {\n #ifdef ASM_OUTPUT_MAX_SKIP_ALIGN\n       ASM_OUTPUT_MAX_SKIP_ALIGN (asm_out_file,"}]}