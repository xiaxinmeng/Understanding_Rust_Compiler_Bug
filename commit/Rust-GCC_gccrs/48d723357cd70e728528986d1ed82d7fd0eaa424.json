{"sha": "48d723357cd70e728528986d1ed82d7fd0eaa424", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhkNzIzMzU3Y2Q3MGU3Mjg1Mjg5ODZkMWVkODJkN2ZkMGVhYTQyNA==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2005-02-28T19:07:36Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2005-02-28T19:07:36Z"}, "message": "rs6000.c (EASY_VECTOR_15): Remove.\n\n        * config/rs6000/rs6000.c (EASY_VECTOR_15): Remove.\n        (EASY_VECTOR_15_ADD_SELF): Remove.\n        (num_insns_constant_wide): Not static.\n        (validate_condition_mode): Not static.\n        (toc_relative_expr_p): Not static.\n        (legitimate_indirect_address_p): Not static.\n        (macho_lo_sum_memory_operand): Not static.\n        (invalid_e500_subreg): Not static.\n        (easy_vector_same): Not static.\n        (easy_vector_splat_const): Not static.\n        (RS6000_SYMBOL_REF_TLS_P): Remove.\n        (any_operand): Delete.\n        (any_parallel_operand): Delete.\n        (count_register_operand): Delete.\n        (altivec_register_operand): Delete.\n        (xer_operand): Delete.\n        (s8bit_cint_operand): Delete.\n        (short_cint_operand): Delete.\n        (u_short_cint_operand): Delete.\n        (non_short_cint_operand): Delete.\n        (exact_log2_cint_operand): Delete.\n        (gpc_reg_operand): Delete.\n        (cc_reg_operand): Delete.\n        (cc_reg_not_cr0_operand): Delete.\n        (reg_or_short_operand): Delete.\n        (reg_or_neg_short_operand): Delete.\n        (reg_or_aligned_short_operand): Delete.\n        (reg_or_u_short_operand): Delete.\n        (reg_or_cint_operand): Delete.\n        (reg_or_arith_cint_operand): Delete.\n        (reg_or_add_cint64_operand): Delete.\n        (reg_or_sub_cint64_operand): Delete.\n        (reg_or_logical_cint_operand): Delete.\n        (got_operand): Delete.\n        (got_no_const_operand): Delete.\n        (easy_fp_constant): Delete.\n        (easy_vector_constant): Delete.\n        (easy_vector_constant_add_self): Delete.\n        (zero_constant): Delete.\n        (zero_fp_constant): Delete.\n        (volatile_mem_operand): Delete.\n        (offsettable_mem_operand): Delete.\n        (mem_or_easy_const_operand): Delete.\n        (add_operand): Delete.\n        (non_add_cint_operand): Delete.\n        (logical_operand): Delete.\n        (non_logical_cint_operand): Delete.\n        (mask_operand): Delete.\n        (mask_operand_wrap): Delete.\n        (mask64_operand): Delete.\n        (mask64_2_operand): Delete.\n        (and64_operand): Delete.\n        (and64_2_operand): Delete.\n        (and_operand): Delete.\n        (reg_or_mem_operand): Delete.\n        (lwa_operand): Delete.\n        (symbol_ref_operand): Delete.\n        (call_operand): Delete.\n        (current_file_function_operand): Delete.\n        (input_operand): Delete.\n        (rs6000_nonimmediate_operand): Delete.\n        (rs6000_tls_symbol_ref): Delete.\n        (save_world_operation): Delete.\n        (restore_world_operation): Delete.\n        (load_multiple_operation): Delete.\n        (store_multiple_operation): Delete.\n        (vrsave_operation): Delete.\n        (mfcr_operation): Delete.\n        (mtcrf_operation): Delete.\n        (lmw_operation): Delete.\n        (stmw_operation): Delete.\n        (branch_comparison_operator): Delete.\n        (branch_positive_comparison_operator): Delete.\n        (scc_comparison_operator): Delete.\n        (trap_comparison_operator): Delete.\n        (boolean_operator): Delete.\n        (boolean_or_operator): Delete.\n        (min_max_operator): Delete.\n        * config/rs6000/rs6000.h (RS6000_SYMBOL_REF_TLS_P): Move to here.\n        (EASY_VECTOR_15): Moved to here.\n        (EASY_VECTOR_15_ADD_SELF): Move to here.\n        (PREDICATE_CODES): Delete.\n        * config/rs6000/rs6000-protos.h: Delete predicate functions.\n        Declare functions no longer static.\n        * config/rs6000/predicates.md: New.\n        * config/rs6000/rs6000.md: Include predicates.md\n\nFrom-SVN: r95692", "tree": {"sha": "1f8539c6d34bd651421b24d77dda48652523f485", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f8539c6d34bd651421b24d77dda48652523f485"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48d723357cd70e728528986d1ed82d7fd0eaa424", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48d723357cd70e728528986d1ed82d7fd0eaa424", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48d723357cd70e728528986d1ed82d7fd0eaa424", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48d723357cd70e728528986d1ed82d7fd0eaa424/comments", "author": null, "committer": null, "parents": [{"sha": "2203a881041c8ecd559282229f6bc8cd019c4697", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2203a881041c8ecd559282229f6bc8cd019c4697", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2203a881041c8ecd559282229f6bc8cd019c4697"}], "stats": {"total": 2954, "additions": 1328, "deletions": 1626}, "files": [{"sha": "283128ac7033d7c7d217068bfa96d79b240761c3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48d723357cd70e728528986d1ed82d7fd0eaa424/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48d723357cd70e728528986d1ed82d7fd0eaa424/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48d723357cd70e728528986d1ed82d7fd0eaa424", "patch": "@@ -1,3 +1,92 @@\n+2005-02-28  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* config/rs6000/rs6000.c (EASY_VECTOR_15): Remove.\n+\t(EASY_VECTOR_15_ADD_SELF): Remove.\n+\t(num_insns_constant_wide): Not static.\n+\t(validate_condition_mode): Not static.\n+\t(toc_relative_expr_p): Not static.\n+\t(legitimate_indirect_address_p): Not static.\n+\t(macho_lo_sum_memory_operand): Not static.\n+\t(invalid_e500_subreg): Not static.\n+\t(easy_vector_same): Not static.\n+\t(easy_vector_splat_const): Not static.\n+\t(RS6000_SYMBOL_REF_TLS_P): Remove.\n+\t(any_operand): Delete.\n+\t(any_parallel_operand): Delete.\n+\t(count_register_operand): Delete.\n+\t(altivec_register_operand): Delete.\n+\t(xer_operand): Delete.\n+\t(s8bit_cint_operand): Delete.\n+\t(short_cint_operand): Delete.\n+\t(u_short_cint_operand): Delete.\n+\t(non_short_cint_operand): Delete.\n+\t(exact_log2_cint_operand): Delete.\n+\t(gpc_reg_operand): Delete.\n+\t(cc_reg_operand): Delete.\n+\t(cc_reg_not_cr0_operand): Delete.\n+\t(reg_or_short_operand): Delete.\n+\t(reg_or_neg_short_operand): Delete.\n+\t(reg_or_aligned_short_operand): Delete.\n+\t(reg_or_u_short_operand): Delete.\n+\t(reg_or_cint_operand): Delete.\n+\t(reg_or_arith_cint_operand): Delete.\n+\t(reg_or_add_cint64_operand): Delete.\n+\t(reg_or_sub_cint64_operand): Delete.\n+\t(reg_or_logical_cint_operand): Delete.\n+\t(got_operand): Delete.\n+\t(got_no_const_operand): Delete.\n+\t(easy_fp_constant): Delete.\n+\t(easy_vector_constant): Delete.\n+\t(easy_vector_constant_add_self): Delete.\n+\t(zero_constant): Delete.\n+\t(zero_fp_constant): Delete.\n+\t(volatile_mem_operand): Delete.\n+\t(offsettable_mem_operand): Delete.\n+\t(mem_or_easy_const_operand): Delete.\n+\t(add_operand): Delete.\n+\t(non_add_cint_operand): Delete.\n+\t(logical_operand): Delete.\n+\t(non_logical_cint_operand): Delete.\n+\t(mask_operand): Delete.\n+\t(mask_operand_wrap): Delete.\n+\t(mask64_operand): Delete.\n+\t(mask64_2_operand): Delete.\n+\t(and64_operand): Delete.\n+\t(and64_2_operand): Delete.\n+\t(and_operand): Delete.\n+\t(reg_or_mem_operand): Delete.\n+\t(lwa_operand): Delete.\n+\t(symbol_ref_operand): Delete.\n+\t(call_operand): Delete.\n+\t(current_file_function_operand): Delete.\n+\t(input_operand): Delete.\n+\t(rs6000_nonimmediate_operand): Delete.\n+\t(rs6000_tls_symbol_ref): Delete.\n+\t(save_world_operation): Delete.\n+\t(restore_world_operation): Delete.\n+\t(load_multiple_operation): Delete.\n+\t(store_multiple_operation): Delete.\n+\t(vrsave_operation): Delete.\n+\t(mfcr_operation): Delete.\n+\t(mtcrf_operation): Delete.\n+\t(lmw_operation): Delete.\n+\t(stmw_operation): Delete.\n+\t(branch_comparison_operator): Delete.\n+\t(branch_positive_comparison_operator): Delete.\n+\t(scc_comparison_operator): Delete.\n+\t(trap_comparison_operator): Delete.\n+\t(boolean_operator): Delete.\n+\t(boolean_or_operator): Delete.\n+\t(min_max_operator): Delete.\n+\t* config/rs6000/rs6000.h (RS6000_SYMBOL_REF_TLS_P): Move to here.\n+\t(EASY_VECTOR_15): Moved to here.\n+\t(EASY_VECTOR_15_ADD_SELF): Move to here.\n+\t(PREDICATE_CODES): Delete.\n+\t* config/rs6000/rs6000-protos.h: Delete predicate functions.\n+\tDeclare functions no longer static.\n+\t* config/rs6000/predicates.md: New.\n+\t* config/rs6000/rs6000.md: Include predicates.md\n+\n 2005-02-28  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* calls.c (emit_call_1): Don't use  REG_ALWAYS_RETURN."}, {"sha": "10e12af99fe753914d2e8cec80b78d54919a0c79", "filename": "gcc/config/rs6000/predicates.md", "status": "added", "additions": 1206, "deletions": 0, "changes": 1206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48d723357cd70e728528986d1ed82d7fd0eaa424/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48d723357cd70e728528986d1ed82d7fd0eaa424/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=48d723357cd70e728528986d1ed82d7fd0eaa424", "patch": "@@ -0,0 +1,1206 @@\n+;; Predicate definitions for POWER and PowerPC.\n+;; Copyright (C) 2005 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; Return 1 for anything except PARALLEL.\n+(define_predicate \"any_operand\"\n+  (match_code \"const_int,const_double,const,symbol_ref,label_ref,subreg,reg,mem\"))\n+\n+;; Return 1 for any PARALLEL.\n+(define_predicate \"any_parallel_operand\"\n+  (match_code \"parallel\"))\n+\n+;; Return 1 if op is COUNT register.\n+(define_predicate \"count_register_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == COUNT_REGISTER_REGNUM\n+\t\t    || REGNO (op) > LAST_VIRTUAL_REGISTER\")))\n+  \n+;; Return 1 if op is an Altivec register.\n+(define_predicate \"altivec_register_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"ALTIVEC_REGNO_P (REGNO (op))\n+\t\t    || REGNO (op) > LAST_VIRTUAL_REGISTER\")))\n+\n+;; Return 1 if op is XER register.\n+(define_predicate \"xer_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"XER_REGNO_P (REGNO (op))\")))\n+\n+;; Return 1 if op is a signed 8-bit constant integer.\n+;; Integer multiplcation complete more quickly\n+(define_predicate \"s8bit_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) >= -128 && INTVAL (op) <= 127\")))\n+\n+;; Return 1 if op is a constant integer that can fit in a D field.\n+(define_predicate \"short_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"CONST_OK_FOR_LETTER_P (INTVAL (op), 'I')\")))\n+\n+;; Return 1 if op is a constant integer that can fit in an unsigned D field.\n+(define_predicate \"u_short_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"CONST_OK_FOR_LETTER_P (INTVAL (op), 'K')\")))\n+\n+;; Return 1 if op is a constant integer that cannot fit in a signed D field.\n+(define_predicate \"non_short_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(unsigned HOST_WIDE_INT)\n+\t\t    (INTVAL (op) + 0x8000) >= 0x10000\")))\n+\n+;; Return 1 if op is a positive constant integer that is an exact power of 2.\n+(define_predicate \"exact_log2_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) > 0 && exact_log2 (INTVAL (op)) >= 0\")))\n+\n+;; Return 1 if op is a register that is not special.\n+(define_predicate \"gpc_reg_operand\"\n+  (and (match_code \"reg,subreg\")\n+       (and (match_operand 0 \"register_operand\")\n+\t    (match_test \"GET_CODE (op) != REG\n+\t\t\t || (REGNO (op) >= ARG_POINTER_REGNUM\n+\t\t\t     && !XER_REGNO_P (REGNO (op)))\n+\t\t\t || REGNO (op) < MQ_REGNO\"))))\n+\n+;; Return 1 if op is a register that is a condition register field.\n+(define_predicate \"cc_reg_operand\"\n+  (and (match_code \"reg,subreg\")\n+       (and (match_operand 0 \"register_operand\")\n+\t    (match_test \"GET_CODE (op) != REG\n+\t\t\t || REGNO (op) > LAST_VIRTUAL_REGISTER\n+\t\t\t || CR_REGNO_P (REGNO (op))\"))))\n+\n+;; Return 1 if op is a register that is a condition register field not cr0.\n+(define_predicate \"cc_reg_not_cr0_operand\"\n+  (and (match_code \"reg,subreg\")\n+       (and (match_operand 0 \"register_operand\")\n+\t    (match_test \"GET_CODE (op) != REG\n+\t\t\t || REGNO (op) > LAST_VIRTUAL_REGISTER\n+\t\t\t || CR_REGNO_NOT_CR0_P (REGNO (op))\"))))\n+\n+;; Return 1 if op is a constant integer valid for D field\n+;; or non-special register register.\n+(define_predicate \"reg_or_short_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_operand 0 \"short_cint_operand\")\n+    (match_operand 0 \"gpc_reg_operand\")))\n+\n+;; Return 1 if op is a constant integer valid whose negation is valid for\n+;; D field or non-special register register.\n+;; Do not allow a constant zero because all patterns that call this\n+;; predicate use \"addic r1,r2,-const\" to set carry when r2 is greater than\n+;; or equal to const, which does not work for zero.\n+(define_predicate \"reg_or_neg_short_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"CONST_OK_FOR_LETTER_P (INTVAL (op), 'P')\n+\t\t && INTVAL (op) != 0\")\n+    (match_operand 0 \"gpc_reg_operand\")))\n+\n+;; Return 1 if op is a constant integer valid for DS field\n+;; or non-special register.\n+(define_predicate \"reg_or_aligned_short_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (and (match_operand 0 \"short_cint_operand\")\n+\t (match_test \"!(INTVAL (op) & 3)\"))\n+    (match_operand 0 \"gpc_reg_operand\")))\n+\n+;; Return 1 if op is a constant integer whose high-order 16 bits are zero\n+;; or non-special register.\n+(define_predicate \"reg_or_u_short_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_operand 0 \"u_short_cint_operand\")\n+    (match_operand 0 \"gpc_reg_operand\")))\n+\n+;; Return 1 if op is any constant integer \n+;; or non-special register.\n+(define_predicate \"reg_or_cint_operand\"\n+  (ior (match_code \"const_int\")\n+       (match_operand 0 \"gpc_reg_operand\")))\n+\n+;; Return 1 if op is a 32-bit signed constant integer valid for arithmetic\n+;; or non-special register.\n+(define_predicate \"reg_or_arith_cint_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"HOST_BITS_PER_WIDE_INT == 32\n+\t\t || ((unsigned HOST_WIDE_INT) (INTVAL (op) + 0x80000000)\n+\t\t     < (unsigned HOST_WIDE_INT) 0x100000000ll)\")\n+    (match_operand 0 \"gpc_reg_operand\")))\n+\n+;; Return 1 if op is a 32-bit signed constant integer valid for 64-bit addition\n+;; or non-special register.\n+(define_predicate \"reg_or_add_cint64_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"(HOST_BITS_PER_WIDE_INT == 32 && INTVAL (op) < 0x7fff8000)\n+\t\t || ((unsigned HOST_WIDE_INT) (INTVAL (op) + 0x80000000)\n+\t\t     < (unsigned HOST_WIDE_INT) 0x100000000ll)\")\n+    (match_operand 0 \"gpc_reg_operand\")))\n+\n+;; Return 1 if op is a 32-bit constant integer valid for 64-bit subtraction\n+;; or non-special register.\n+(define_predicate \"reg_or_sub_cint64_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"(HOST_BITS_PER_WIDE_INT == 32 && INTVAL (op) < 0x7fff8000)\n+\t\t || ((unsigned HOST_WIDE_INT) ((- INTVAL (op)) + 0x80000000)\n+\t\t     < (unsigned HOST_WIDE_INT) 0x100000000ll)\")\n+    (match_operand 0 \"gpc_reg_operand\")))\n+\n+;; Return 1 if op is any 32-bit unsigned constant integer\n+;; or non-special register.\n+(define_predicate \"reg_or_logical_cint_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"(GET_MODE_BITSIZE (mode) > HOST_BITS_PER_WIDE_INT\n+\t\t  && INTVAL (op) >= 0)\n+\t\t || ((INTVAL (op) & GET_MODE_MASK (mode)\n+\t\t      & (~ (unsigned HOST_WIDE_INT) 0xffffffff)) == 0)\")\n+    (if_then_else (match_code \"const_double\")\n+      (match_test \"GET_MODE_BITSIZE (mode) > HOST_BITS_PER_WIDE_INT\n+\t\t   && mode == DImode\n+\t\t   && CONST_DOUBLE_HIGH (op) == 0\")\n+      (match_operand 0 \"gpc_reg_operand\"))))\n+\n+;; Return 1 if operand is a CONST_DOUBLE that can be set in a register\n+;; with no more than one instruction per word.\n+(define_predicate \"easy_fp_constant\"\n+  (match_code \"const_double\")\n+{\n+  if (GET_MODE (op) != mode\n+      || (GET_MODE_CLASS (mode) != MODE_FLOAT && mode != DImode))\n+    return 0;\n+\n+  /* Consider all constants with -msoft-float to be easy.  */\n+  if ((TARGET_SOFT_FLOAT || TARGET_E500_SINGLE)\n+      && mode != DImode)\n+    return 1;\n+\n+  /* If we are using V.4 style PIC, consider all constants to be hard.  */\n+  if (flag_pic && DEFAULT_ABI == ABI_V4)\n+    return 0;\n+\n+#ifdef TARGET_RELOCATABLE\n+  /* Similarly if we are using -mrelocatable, consider all constants\n+     to be hard.  */\n+  if (TARGET_RELOCATABLE)\n+    return 0;\n+#endif\n+\n+  if (mode == TFmode)\n+    {\n+      long k[4];\n+      REAL_VALUE_TYPE rv;\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n+      REAL_VALUE_TO_TARGET_LONG_DOUBLE (rv, k);\n+\n+      return (num_insns_constant_wide ((HOST_WIDE_INT) k[0]) == 1\n+\t      && num_insns_constant_wide ((HOST_WIDE_INT) k[1]) == 1\n+\t      && num_insns_constant_wide ((HOST_WIDE_INT) k[2]) == 1\n+\t      && num_insns_constant_wide ((HOST_WIDE_INT) k[3]) == 1);\n+    }\n+\n+  else if (mode == DFmode)\n+    {\n+      long k[2];\n+      REAL_VALUE_TYPE rv;\n+\n+      if (TARGET_E500_DOUBLE)\n+\treturn 0;\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n+      REAL_VALUE_TO_TARGET_DOUBLE (rv, k);\n+\n+      return (num_insns_constant_wide ((HOST_WIDE_INT) k[0]) == 1\n+\t      && num_insns_constant_wide ((HOST_WIDE_INT) k[1]) == 1);\n+    }\n+\n+  else if (mode == SFmode)\n+    {\n+      long l;\n+      REAL_VALUE_TYPE rv;\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n+      REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n+\n+      return num_insns_constant_wide (l) == 1;\n+    }\n+\n+  else if (mode == DImode)\n+    return ((TARGET_POWERPC64\n+\t     && GET_CODE (op) == CONST_DOUBLE && CONST_DOUBLE_LOW (op) == 0)\n+\t    || (num_insns_constant (op, DImode) <= 2));\n+\n+  else if (mode == SImode)\n+    return 1;\n+  else\n+    abort ();\n+})\n+\n+;; Return 1 if the operand is a CONST_VECTOR and can be loaded into a\n+;; vector register without using memory.\n+(define_predicate \"easy_vector_constant\"\n+  (match_code \"const_vector\")\n+{\n+  int cst, cst2;\n+\n+  if (!TARGET_ALTIVEC && !TARGET_SPE)\n+    return 0;\n+\n+  if (zero_constant (op, mode)\n+      && ((TARGET_ALTIVEC && ALTIVEC_VECTOR_MODE (mode))\n+\t  || (TARGET_SPE && SPE_VECTOR_MODE (mode))))\n+    return 1;\n+\n+  if (GET_MODE_CLASS (mode) != MODE_VECTOR_INT)\n+    return 0;\n+\n+  if (TARGET_SPE && mode == V1DImode)\n+    return 0;\n+\n+  cst  = INTVAL (CONST_VECTOR_ELT (op, 0));\n+  cst2 = INTVAL (CONST_VECTOR_ELT (op, 1));\n+\n+  /* Limit SPE vectors to 15 bits signed.  These we can generate with:\n+       li r0, CONSTANT1\n+       evmergelo r0, r0, r0\n+       li r0, CONSTANT2\n+\n+     I don't know how efficient it would be to allow bigger constants,\n+     considering we'll have an extra 'ori' for every 'li'.  I doubt 5\n+     instructions is better than a 64-bit memory load, but I don't\n+     have the e500 timing specs.  */\n+  if (TARGET_SPE && mode == V2SImode\n+      && cst  >= -0x7fff && cst <= 0x7fff\n+      && cst2 >= -0x7fff && cst2 <= 0x7fff)\n+    return 1;\n+\n+  if (TARGET_ALTIVEC\n+      && easy_vector_same (op, mode))\n+    {\n+      cst = easy_vector_splat_const (cst, mode);\n+      if (EASY_VECTOR_15_ADD_SELF (cst)\n+\t  || EASY_VECTOR_15 (cst))\n+\treturn 1;\n+    }\n+  return 0;\n+})\n+\n+;; Same as easy_vector_constant but only for EASY_VECTOR_15_ADD_SELF.\n+(define_predicate \"easy_vector_constant_add_self\"\n+  (and (match_code \"const_vector\")\n+       (and (match_test \"TARGET_ALTIVEC\")\n+\t    (and (match_test \"easy_vector_same (op, mode)\")\n+\t\t (match_test \"EASY_VECTOR_15_ADD_SELF\n+\t\t \t\t(easy_vector_splat_const\n+\t\t\t\t  (INTVAL (CONST_VECTOR_ELT (op, 0)),\n+\t\t\t\t   mode))\")))))\n+\n+;; Return 1 if operand is constant zero (scalars and vectors).\n+(define_predicate \"zero_constant\"\n+  (and (match_code \"const_int,const_double,const_vector\")\n+       (match_test \"op == CONST0_RTX (mode)\")))\n+\n+;; Return 1 if operand is 0.0.\n+;; or non-special register register field no cr0\n+(define_predicate \"zero_fp_constant\"\n+  (and (match_code \"const_double\")\n+       (match_test \"GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t\t    && op == CONST0_RTX (mode)\")))\n+\n+;; Return 1 if the operand is in volatile memory.  Note that during the\n+;; RTL generation phase, memory_operand does not return TRUE for volatile\n+;; memory references.  So this function allows us to recognize volatile\n+;; references where its safe.\n+(define_predicate \"volatile_mem_operand\"\n+  (and (and (match_code \"mem\")\n+\t    (match_test \"MEM_VOLATILE_P (op)\"))\n+       (if_then_else (match_test \"reload_completed\")\n+         (match_operand 0 \"memory_operand\")\n+         (if_then_else (match_test \"reload_in_progress\")\n+\t   (match_test \"strict_memory_address_p (mode, XEXP (op, 0))\")\n+\t   (match_test \"memory_address_p (mode, XEXP (op, 0))\")))))\n+\n+;; Return 1 if the operand is an offsettable memory operand.\n+(define_predicate \"offsettable_mem_operand\"\n+  (and (match_code \"mem\")\n+       (match_test \"offsettable_address_p (reload_completed\n+\t\t\t\t\t   || reload_in_progress,\n+\t\t\t\t\t   mode, XEXP (op, 0))\")))\n+\n+;; Return 1 if the operand is either an easy FP constant or memory.\n+(define_predicate \"mem_or_easy_const_operand\"\n+  (if_then_else (match_code \"const_double\")\n+    (match_operand 0 \"easy_fp_constant\")\n+    (match_operand 0 \"memory_operand\")))\n+\n+;; Return 1 if the operand is either a non-special register or can be used\n+;; as the operand of a `mode' add insn.\n+(define_predicate \"add_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"CONST_OK_FOR_LETTER_P (INTVAL (op), 'I')\n+\t\t || CONST_OK_FOR_LETTER_P (INTVAL (op), 'L')\")\n+    (match_operand 0 \"gpc_reg_operand\")))\n+\n+;; Return 1 if OP is a constant but not a valid add_operand.\n+(define_predicate \"non_add_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"!CONST_OK_FOR_LETTER_P (INTVAL (op), 'I')\n+\t\t    && !CONST_OK_FOR_LETTER_P (INTVAL (op), 'L')\")))\n+\n+;; Return 1 if the operand is a non-special register or a constant that\n+;; can be used as the operand of an OR or XOR.\n+(define_predicate \"logical_operand\"\n+  (match_code \"reg,subreg,const_int,const_double\")\n+{\n+  HOST_WIDE_INT opl, oph;\n+\n+  if (gpc_reg_operand (op, mode))\n+    return 1;\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      opl = INTVAL (op) & GET_MODE_MASK (mode);\n+\n+      if (HOST_BITS_PER_WIDE_INT <= 32\n+\t  && GET_MODE_BITSIZE (mode) > HOST_BITS_PER_WIDE_INT && opl < 0)\n+\treturn 0;\n+    }\n+  else if (GET_CODE (op) == CONST_DOUBLE)\n+    {\n+      if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n+\tabort ();\n+\n+      opl = CONST_DOUBLE_LOW (op);\n+      oph = CONST_DOUBLE_HIGH (op);\n+      if (oph != 0)\n+\treturn 0;\n+    }\n+  else\n+    return 0;\n+\n+  return ((opl & ~ (unsigned HOST_WIDE_INT) 0xffff) == 0\n+\t  || (opl & ~ (unsigned HOST_WIDE_INT) 0xffff0000) == 0);\n+})\n+\n+;; Return 1 if op is a constant that is not a logical operand, but could\n+;; be split into one.\n+(define_predicate \"non_logical_cint_operand\"\n+  (and (match_code \"const_int,const_double\")\n+       (and (not (match_operand 0 \"logical_operand\"))\n+\t    (match_operand 0 \"reg_or_logical_cint_operand\"))))\n+\n+;; Return 1 if op is a constant that can be encoded in a 32-bit mask (no\n+;; more than two 1->0 or 0->1 transitions).  Reject all ones and all\n+;; zeros, since these should have been optimized away and confuse the\n+;; making of MB and ME.\n+(define_predicate \"mask_operand\"\n+  (match_code \"const_int\")\n+{\n+  HOST_WIDE_INT c, lsb;\n+\n+  c = INTVAL (op);\n+\n+  /* Fail in 64-bit mode if the mask wraps around because the upper\n+     32-bits of the mask will all be 1s, contrary to GCC's internal view.  */\n+  if (TARGET_POWERPC64 && (c & 0x80000001) == 0x80000001)\n+    return 0;\n+\n+  /* We don't change the number of transitions by inverting,\n+     so make sure we start with the LS bit zero.  */\n+  if (c & 1)\n+    c = ~c;\n+\n+  /* Reject all zeros or all ones.  */\n+  if (c == 0)\n+    return 0;\n+\n+  /* Find the first transition.  */\n+  lsb = c & -c;\n+\n+  /* Invert to look for a second transition.  */\n+  c = ~c;\n+\n+  /* Erase first transition.  */\n+  c &= -lsb;\n+\n+  /* Find the second transition (if any).  */\n+  lsb = c & -c;\n+\n+  /* Match if all the bits above are 1's (or c is zero).  */\n+  return c == -lsb;\n+})\n+\n+;; Return 1 for the PowerPC64 rlwinm corner case.\n+(define_predicate \"mask_operand_wrap\"\n+  (match_code \"const_int\")\n+{\n+  HOST_WIDE_INT c, lsb;\n+\n+  c = INTVAL (op);\n+\n+  if ((c & 0x80000001) != 0x80000001)\n+    return 0;\n+\n+  c = ~c;\n+  if (c == 0)\n+    return 0;\n+\n+  lsb = c & -c;\n+  c = ~c;\n+  c &= -lsb;\n+  lsb = c & -c;\n+  return c == -lsb;\n+})\n+\n+;; Return 1 if the operand is a constant that is a PowerPC64 mask (no more\n+;; than one 1->0 or 0->1 transitions).  Reject all zeros, since zero\n+;; should have been optimized away and confuses the making of MB and ME.\n+(define_predicate \"mask64_operand\"\n+  (match_code \"const_int\")\n+{\n+  HOST_WIDE_INT c, lsb;\n+\n+  c = INTVAL (op);\n+\n+  /* Reject all zeros.  */\n+  if (c == 0)\n+    return 0;\n+\n+  /* We don't change the number of transitions by inverting,\n+     so make sure we start with the LS bit zero.  */\n+  if (c & 1)\n+    c = ~c;\n+\n+  /* Find the transition, and check that all bits above are 1's.  */\n+  lsb = c & -c;\n+\n+  /* Match if all the bits above are 1's (or c is zero).  */\n+  return c == -lsb;\n+})\n+\n+;; Like mask64_operand, but allow up to three transitions.  This\n+;; predicate is used by insn patterns that generate two rldicl or\n+;; rldicr machine insns.\n+(define_predicate \"mask64_2_operand\"\n+  (match_code \"const_int\")\n+{\n+  return mask64_1or2_operand (op, mode, false);\n+})\n+\n+;; Return 1 if the operand is either a non-special register or a constant\n+;; that can be used as the operand of a PowerPC64 logical AND insn.\n+(define_predicate \"and64_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_operand 0 \"mask64_operand\")\n+    (if_then_else (match_test \"fixed_regs[CR0_REGNO]\")\n+      (match_operand 0 \"gpc_reg_operand\")\n+      (match_operand 0 \"logical_operand\"))))\n+\n+;; Like and64_operand, but also match constants that can be implemented\n+;; with two rldicl or rldicr insns.\n+(define_predicate \"and64_2_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"mask64_1or2_operand (op, mode, true)\")\n+    (if_then_else (match_test \"fixed_regs[CR0_REGNO]\")\n+      (match_operand 0 \"gpc_reg_operand\")\n+      (match_operand 0 \"logical_operand\"))))\n+\n+;; Return 1 if the operand is either a non-special register or a\n+;; constant that can be used as the operand of a logical AND.\n+(define_predicate \"and_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_operand 0 \"mask_operand\")\n+    (if_then_else (match_test \"fixed_regs[CR0_REGNO]\")\n+      (match_operand 0 \"gpc_reg_operand\")\n+      (match_operand 0 \"logical_operand\"))))\n+\n+;; Return 1 if the operand is a general non-special register or memory operand.\n+(define_predicate \"reg_or_mem_operand\"\n+  (if_then_else (match_code \"mem\")\n+     (ior (match_operand 0 \"memory_operand\")\n+\t  (ior (match_test \"macho_lo_sum_memory_operand (op, mode)\")\n+\t       (match_operand 0 \"volatile_mem_operand\")))\n+     (match_operand 0 \"gpc_reg_operand\")))\n+\n+;; Return 1 if the operand is a general register or memory operand without\n+;; pre_inc or pre_dec, which produces invalid form of PowerPC lwa\n+;; instruction.\n+(define_predicate \"lwa_operand\"\n+  (match_code \"reg,subreg,mem\")\n+{\n+  rtx inner = op;\n+\n+  if (reload_completed && GET_CODE (inner) == SUBREG)\n+    inner = SUBREG_REG (inner);\n+\n+  return gpc_reg_operand (inner, mode)\n+    || (memory_operand (inner, mode)\n+\t&& GET_CODE (XEXP (inner, 0)) != PRE_INC\n+\t&& GET_CODE (XEXP (inner, 0)) != PRE_DEC\n+\t&& (GET_CODE (XEXP (inner, 0)) != PLUS\n+\t    || GET_CODE (XEXP (XEXP (inner, 0), 1)) != CONST_INT\n+\t    || INTVAL (XEXP (XEXP (inner, 0), 1)) % 4 == 0));\n+})\n+\n+;; Return 1 if the operand, used inside a MEM, is a SYMBOL_REF.\n+(define_predicate \"symbol_ref_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"(mode == VOIDmode || GET_MODE (op) == mode)\n+\t\t    && (DEFAULT_ABI != ABI_AIX || SYMBOL_REF_FUNCTION_P (op))\")))\n+\n+;; Return 1 if op is an operand that can be loaded via the GOT.\n+;; or non-special register register field no cr0\n+(define_predicate \"got_operand\"\n+  (match_code \"symbol_ref,const,label_ref\"))\n+\n+;; Return 1 if op is a simple reference that can be loaded via the GOT,\n+;; exclusing labels involving addition.\n+(define_predicate \"got_no_const_operand\"\n+  (match_code \"symbol_ref,label_ref\"))\n+\n+;; Return 1 if op is a SYMBOL_REF for a TLS symbol.\n+(define_predicate \"rs6000_tls_symbol_ref\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"RS6000_SYMBOL_REF_TLS_P (op)\")))\n+\n+;; Return 1 if the operand, used inside a MEM, is a valid first argument\n+;; to CALL.  This is a SYMBOL_REF, a pseudo-register, LR or CTR.\n+(define_predicate \"call_operand\"\n+  (if_then_else (match_code \"reg\")\n+     (match_test \"REGNO (op) == LINK_REGISTER_REGNUM\n+\t\t  || REGNO (op) == COUNT_REGISTER_REGNUM\n+\t\t  || REGNO (op) >= FIRST_PSEUDO_REGISTER\")\n+     (match_code \"symbol_ref\")))\n+\n+;; Return 1 if the operand is a SYMBOL_REF for a function known to be in\n+;; this file.\n+(define_predicate \"current_file_function_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"(DEFAULT_ABI != ABI_AIX || SYMBOL_REF_FUNCTION_P (op))\n+\t\t    && (SYMBOL_REF_LOCAL_P (op)\n+\t\t        || (op == XEXP (DECL_RTL (current_function_decl),\n+\t\t\t\t\t\t  0)))\")))\n+\n+;; Return 1 if this operand is a valid input for a move insn.\n+(define_predicate \"input_operand\"\n+  (match_code \"label_ref,symbol_ref,const,high,reg,subreg,mem,\n+\t       const_double,const_vector,const_int,plus\")\n+{\n+  /* Memory is always valid.  */\n+  if (memory_operand (op, mode))\n+    return 1;\n+\n+  /* For floating-point, easy constants are valid.  */\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+      && CONSTANT_P (op)\n+      && easy_fp_constant (op, mode))\n+    return 1;\n+\n+  /* Allow any integer constant.  */\n+  if (GET_MODE_CLASS (mode) == MODE_INT\n+      && (GET_CODE (op) == CONST_INT\n+\t  || GET_CODE (op) == CONST_DOUBLE))\n+    return 1;\n+\n+  /* Allow easy vector constants.  */\n+  if (GET_CODE (op) == CONST_VECTOR\n+      && easy_vector_constant (op, mode))\n+    return 1;\n+\n+  /* For floating-point or multi-word mode, the only remaining valid type\n+     is a register.  */\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+      || GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+    return register_operand (op, mode);\n+\n+  /* The only cases left are integral modes one word or smaller (we\n+     do not get called for MODE_CC values).  These can be in any\n+     register.  */\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  /* A SYMBOL_REF referring to the TOC is valid.  */\n+  if (legitimate_constant_pool_address_p (op))\n+    return 1;\n+\n+  /* A constant pool expression (relative to the TOC) is valid */\n+  if (toc_relative_expr_p (op))\n+    return 1;\n+\n+  /* V.4 allows SYMBOL_REFs and CONSTs that are in the small data region\n+     to be valid.  */\n+  if (DEFAULT_ABI == ABI_V4\n+      && (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == CONST)\n+      && small_data_operand (op, Pmode))\n+    return 1;\n+\n+  return 0;\n+})\n+\n+;; Return true if OP is an invalid SUBREG operation on the e500.\n+(define_predicate \"rs6000_nonimmediate_operand\"\n+  (match_code \"reg,subreg,mem\")\n+{\n+  if (TARGET_E500_DOUBLE\n+      && GET_CODE (op) == SUBREG\n+      && invalid_e500_subreg (op, mode))\n+    return 0;\n+\n+  return nonimmediate_operand (op, mode);\n+})\n+\n+;; Return true if operand is boolean operator.\n+(define_predicate \"boolean_operator\"\n+  (match_code \"and,ior,xor\"))\n+\n+;; Return true if operand is OR-form of boolean operator.\n+(define_predicate \"boolean_or_operator\"\n+  (match_code \"ior,xor\"))\n+\n+;; Return true if operand is MIN or MAX operator.\n+(define_predicate \"min_max_operator\"\n+  (match_code \"smin,smax,umin,umax\"))\n+\n+;; Return 1 if OP is a comparison operation that is valid for a branch\n+;; instruction.  We only check the opcode against the mode of the CC value.\n+(define_predicate \"branch_comparison_operator\"\n+  (match_code \"eq,ne,le,lt,ge,gt,leu,ltu,geu,gtu,unordered,ordered,unge,unle\")\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  enum machine_mode cc_mode;\n+\n+  if (!COMPARISON_P (op))\n+    return 0;\n+\n+  cc_mode = GET_MODE (XEXP (op, 0));\n+  if (GET_MODE_CLASS (cc_mode) != MODE_CC)\n+    return 0;\n+\n+  validate_condition_mode (code, cc_mode);\n+\n+  return 1;\n+})\n+\n+;; Return 1 if OP is a comparison operation that is valid for an SCC insn --\n+;; it must be a positive comparison.\n+(define_predicate \"scc_comparison_operator\"\n+  (and (match_code \"eq,lt,gt,ltu,gtu,unordered\")\n+       (match_operand 0 \"branch_comparison_operator\")))\n+\n+;; Return 1 if OP is a comparison operation that is valid for a branch\n+;; insn, which is true if the corresponding bit in the CC register is set.\n+(define_predicate \"branch_positive_comparison_operator\"\n+  (and (match_code \"eq,lt,gt,ltu,gtu,unordered\")\n+       (match_operand 0 \"branch_comparison_operator\")))\n+\n+;; Return 1 is OP is a comparison operation that is valid for a trap insn.\n+(define_predicate \"trap_comparison_operator\"\n+  (and (match_code \"eq,ne,le,lt,ge,gt,leu,ltu,geu,gtu\")\n+       (match_test \"(mode == VOIDmode || mode == GET_MODE (op))\n+\t\t    && COMPARISON_P (op)\")))\n+\n+;; Return 1 if OP is a load multiple operation, known to be a PARALLEL.\n+(define_predicate \"load_multiple_operation\"\n+  (match_code \"parallel\")\n+{\n+  int count = XVECLEN (op, 0);\n+  unsigned int dest_regno;\n+  rtx src_addr;\n+  int i;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != MEM)\n+    return 0;\n+\n+  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n+  src_addr = XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0);\n+\n+  for (i = 1; i < count; i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_DEST (elt)) != REG\n+\t  || GET_MODE (SET_DEST (elt)) != SImode\n+\t  || REGNO (SET_DEST (elt)) != dest_regno + i\n+\t  || GET_CODE (SET_SRC (elt)) != MEM\n+\t  || GET_MODE (SET_SRC (elt)) != SImode\n+\t  || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n+\t  || ! rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n+\t  || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n+\t  || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1)) != i * 4)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+})\n+\n+;; Return 1 if OP is a store multiple operation, known to be a PARALLEL.\n+;; The second vector element is a CLOBBER.\n+(define_predicate \"store_multiple_operation\"\n+  (match_code \"parallel\")\n+{\n+  int count = XVECLEN (op, 0) - 1;\n+  unsigned int src_regno;\n+  rtx dest_addr;\n+  int i;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != MEM\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != REG)\n+    return 0;\n+\n+  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, 0)));\n+  dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, 0)), 0);\n+\n+  for (i = 1; i < count; i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i + 1);\n+\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || GET_MODE (SET_SRC (elt)) != SImode\n+\t  || REGNO (SET_SRC (elt)) != src_regno + i\n+\t  || GET_CODE (SET_DEST (elt)) != MEM\n+\t  || GET_MODE (SET_DEST (elt)) != SImode\n+\t  || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n+\t  || ! rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_addr)\n+\t  || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n+\t  || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1)) != i * 4)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+})\n+\n+;; Return 1 if OP is valid for a save_world call in prologue, known to be\n+;; a PARLLEL.\n+(define_predicate \"save_world_operation\"\n+  (match_code \"parallel\")\n+{\n+  int index;\n+  int i;\n+  rtx elt;\n+  int count = XVECLEN (op, 0);\n+\n+  if (count != 55)\n+    return 0;\n+\n+  index = 0;\n+  if (GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER\n+      || GET_CODE (XVECEXP (op, 0, index++)) != USE)\n+    return 0;\n+\n+  for (i=1; i <= 18; i++)\n+    {\n+      elt = XVECEXP (op, 0, index++);\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_DEST (elt)) != MEM\n+\t  || ! memory_operand (SET_DEST (elt), DFmode)\n+\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || GET_MODE (SET_SRC (elt)) != DFmode)\n+\treturn 0;\n+    }\n+\n+  for (i=1; i <= 12; i++)\n+    {\n+      elt = XVECEXP (op, 0, index++);\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_DEST (elt)) != MEM\n+\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || GET_MODE (SET_SRC (elt)) != V4SImode)\n+\treturn 0;\n+    }\n+\n+  for (i=1; i <= 19; i++)\n+    {\n+      elt = XVECEXP (op, 0, index++);\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_DEST (elt)) != MEM\n+\t  || ! memory_operand (SET_DEST (elt), Pmode)\n+\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || GET_MODE (SET_SRC (elt)) != Pmode)\n+\treturn 0;\n+    }\n+\n+  elt = XVECEXP (op, 0, index++);\n+  if (GET_CODE (elt) != SET\n+      || GET_CODE (SET_DEST (elt)) != MEM\n+      || ! memory_operand (SET_DEST (elt), Pmode)\n+      || GET_CODE (SET_SRC (elt)) != REG\n+      || REGNO (SET_SRC (elt)) != CR2_REGNO\n+      || GET_MODE (SET_SRC (elt)) != Pmode)\n+    return 0;\n+\n+  if (GET_CODE (XVECEXP (op, 0, index++)) != USE\n+      || GET_CODE (XVECEXP (op, 0, index++)) != USE\n+      || GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER)\n+    return 0;\n+  return 1;\n+})\n+\n+;; Return 1 if OP is valid for a restore_world call in epilogue, known to be\n+;; a PARLLEL.\n+(define_predicate \"restore_world_operation\"\n+  (match_code \"parallel\")\n+{\n+  int index;\n+  int i;\n+  rtx elt;\n+  int count = XVECLEN (op, 0);\n+\n+  if (count != 59)\n+    return 0;\n+\n+  index = 0;\n+  if (GET_CODE (XVECEXP (op, 0, index++)) != RETURN\n+      || GET_CODE (XVECEXP (op, 0, index++)) != USE\n+      || GET_CODE (XVECEXP (op, 0, index++)) != USE\n+      || GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER)\n+    return 0;\n+\n+  elt = XVECEXP (op, 0, index++);\n+  if (GET_CODE (elt) != SET\n+      || GET_CODE (SET_SRC (elt)) != MEM\n+      || ! memory_operand (SET_SRC (elt), Pmode)\n+      || GET_CODE (SET_DEST (elt)) != REG\n+      || REGNO (SET_DEST (elt)) != CR2_REGNO\n+      || GET_MODE (SET_DEST (elt)) != Pmode)\n+    return 0;\n+\n+  for (i=1; i <= 19; i++)\n+    {\n+      elt = XVECEXP (op, 0, index++);\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_SRC (elt)) != MEM\n+\t  || ! memory_operand (SET_SRC (elt), Pmode)\n+\t  || GET_CODE (SET_DEST (elt)) != REG\n+\t  || GET_MODE (SET_DEST (elt)) != Pmode)\n+\treturn 0;\n+    }\n+\n+  for (i=1; i <= 12; i++)\n+    {\n+      elt = XVECEXP (op, 0, index++);\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_SRC (elt)) != MEM\n+\t  || GET_CODE (SET_DEST (elt)) != REG\n+\t  || GET_MODE (SET_DEST (elt)) != V4SImode)\n+\treturn 0;\n+    }\n+\n+  for (i=1; i <= 18; i++)\n+    {\n+      elt = XVECEXP (op, 0, index++);\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_SRC (elt)) != MEM\n+\t  || ! memory_operand (SET_SRC (elt), DFmode)\n+\t  || GET_CODE (SET_DEST (elt)) != REG\n+\t  || GET_MODE (SET_DEST (elt)) != DFmode)\n+\treturn 0;\n+    }\n+\n+  if (GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER\n+      || GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER\n+      || GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER\n+      || GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER\n+      || GET_CODE (XVECEXP (op, 0, index++)) != USE)\n+    return 0;\n+  return 1;\n+})\n+\n+;; Return 1 if OP is valid for a vrsave call, known to be a PARALLEL.\n+(define_predicate \"vrsave_operation\"\n+  (match_code \"parallel\")\n+{\n+  int count = XVECLEN (op, 0);\n+  unsigned int dest_regno, src_regno;\n+  int i;\n+\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != UNSPEC_VOLATILE)\n+    return 0;\n+\n+  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n+  src_regno  = REGNO (SET_SRC (XVECEXP (op, 0, 0)));\n+\n+  if (dest_regno != VRSAVE_REGNO\n+      && src_regno != VRSAVE_REGNO)\n+    return 0;\n+\n+  for (i = 1; i < count; i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (elt) != CLOBBER\n+\t  && GET_CODE (elt) != SET)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+})\n+\n+;; Return 1 if OP is valid for mfcr insn, known to be a PARALLEL.\n+(define_predicate \"mfcr_operation\"\n+  (match_code \"parallel\")\n+{\n+  int count = XVECLEN (op, 0);\n+  int i;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count < 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != UNSPEC\n+      || XVECLEN (SET_SRC (XVECEXP (op, 0, 0)), 0) != 2)\n+    return 0;\n+\n+  for (i = 0; i < count; i++)\n+    {\n+      rtx exp = XVECEXP (op, 0, i);\n+      rtx unspec;\n+      int maskval;\n+      rtx src_reg;\n+\n+      src_reg = XVECEXP (SET_SRC (exp), 0, 0);\n+\n+      if (GET_CODE (src_reg) != REG\n+\t  || GET_MODE (src_reg) != CCmode\n+\t  || ! CR_REGNO_P (REGNO (src_reg)))\n+\treturn 0;\n+\n+      if (GET_CODE (exp) != SET\n+\t  || GET_CODE (SET_DEST (exp)) != REG\n+\t  || GET_MODE (SET_DEST (exp)) != SImode\n+\t  || ! INT_REGNO_P (REGNO (SET_DEST (exp))))\n+\treturn 0;\n+      unspec = SET_SRC (exp);\n+      maskval = 1 << (MAX_CR_REGNO - REGNO (src_reg));\n+\n+      if (GET_CODE (unspec) != UNSPEC\n+\t  || XINT (unspec, 1) != UNSPEC_MOVESI_FROM_CR\n+\t  || XVECLEN (unspec, 0) != 2\n+\t  || XVECEXP (unspec, 0, 0) != src_reg\n+\t  || GET_CODE (XVECEXP (unspec, 0, 1)) != CONST_INT\n+\t  || INTVAL (XVECEXP (unspec, 0, 1)) != maskval)\n+\treturn 0;\n+    }\n+  return 1;\n+})\n+\n+;; Return 1 if OP is valid for mtcrf insn, known to be a PARALLEL.\n+(define_predicate \"mtcrf_operation\"\n+  (match_code \"parallel\")\n+{\n+  int count = XVECLEN (op, 0);\n+  int i;\n+  rtx src_reg;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count < 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != UNSPEC\n+      || XVECLEN (SET_SRC (XVECEXP (op, 0, 0)), 0) != 2)\n+    return 0;\n+  src_reg = XVECEXP (SET_SRC (XVECEXP (op, 0, 0)), 0, 0);\n+\n+  if (GET_CODE (src_reg) != REG\n+      || GET_MODE (src_reg) != SImode\n+      || ! INT_REGNO_P (REGNO (src_reg)))\n+    return 0;\n+\n+  for (i = 0; i < count; i++)\n+    {\n+      rtx exp = XVECEXP (op, 0, i);\n+      rtx unspec;\n+      int maskval;\n+\n+      if (GET_CODE (exp) != SET\n+\t  || GET_CODE (SET_DEST (exp)) != REG\n+\t  || GET_MODE (SET_DEST (exp)) != CCmode\n+\t  || ! CR_REGNO_P (REGNO (SET_DEST (exp))))\n+\treturn 0;\n+      unspec = SET_SRC (exp);\n+      maskval = 1 << (MAX_CR_REGNO - REGNO (SET_DEST (exp)));\n+\n+      if (GET_CODE (unspec) != UNSPEC\n+\t  || XINT (unspec, 1) != UNSPEC_MOVESI_TO_CR\n+\t  || XVECLEN (unspec, 0) != 2\n+\t  || XVECEXP (unspec, 0, 0) != src_reg\n+\t  || GET_CODE (XVECEXP (unspec, 0, 1)) != CONST_INT\n+\t  || INTVAL (XVECEXP (unspec, 0, 1)) != maskval)\n+\treturn 0;\n+    }\n+  return 1;\n+})\n+\n+;; Return 1 if OP is valid for lmw insn, known to be a PARALLEL.\n+(define_predicate \"lmw_operation\"\n+  (match_code \"parallel\")\n+{\n+  int count = XVECLEN (op, 0);\n+  unsigned int dest_regno;\n+  rtx src_addr;\n+  unsigned int base_regno;\n+  HOST_WIDE_INT offset;\n+  int i;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != MEM)\n+    return 0;\n+\n+  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n+  src_addr = XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0);\n+\n+  if (dest_regno > 31\n+      || count != 32 - (int) dest_regno)\n+    return 0;\n+\n+  if (legitimate_indirect_address_p (src_addr, 0))\n+    {\n+      offset = 0;\n+      base_regno = REGNO (src_addr);\n+      if (base_regno == 0)\n+\treturn 0;\n+    }\n+  else if (rs6000_legitimate_offset_address_p (SImode, src_addr, 0))\n+    {\n+      offset = INTVAL (XEXP (src_addr, 1));\n+      base_regno = REGNO (XEXP (src_addr, 0));\n+    }\n+  else\n+    return 0;\n+\n+  for (i = 0; i < count; i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i);\n+      rtx newaddr;\n+      rtx addr_reg;\n+      HOST_WIDE_INT newoffset;\n+\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_DEST (elt)) != REG\n+\t  || GET_MODE (SET_DEST (elt)) != SImode\n+\t  || REGNO (SET_DEST (elt)) != dest_regno + i\n+\t  || GET_CODE (SET_SRC (elt)) != MEM\n+\t  || GET_MODE (SET_SRC (elt)) != SImode)\n+\treturn 0;\n+      newaddr = XEXP (SET_SRC (elt), 0);\n+      if (legitimate_indirect_address_p (newaddr, 0))\n+\t{\n+\t  newoffset = 0;\n+\t  addr_reg = newaddr;\n+\t}\n+      else if (rs6000_legitimate_offset_address_p (SImode, newaddr, 0))\n+\t{\n+\t  addr_reg = XEXP (newaddr, 0);\n+\t  newoffset = INTVAL (XEXP (newaddr, 1));\n+\t}\n+      else\n+\treturn 0;\n+      if (REGNO (addr_reg) != base_regno\n+\t  || newoffset != offset + 4 * i)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+})\n+\n+;; Return 1 if OP is valid for stmw insn, known to be a PARALLEL.\n+(define_predicate \"stmw_operation\"\n+  (match_code \"parallel\")\n+{\n+  int count = XVECLEN (op, 0);\n+  unsigned int src_regno;\n+  rtx dest_addr;\n+  unsigned int base_regno;\n+  HOST_WIDE_INT offset;\n+  int i;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != MEM\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != REG)\n+    return 0;\n+\n+  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, 0)));\n+  dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, 0)), 0);\n+\n+  if (src_regno > 31\n+      || count != 32 - (int) src_regno)\n+    return 0;\n+\n+  if (legitimate_indirect_address_p (dest_addr, 0))\n+    {\n+      offset = 0;\n+      base_regno = REGNO (dest_addr);\n+      if (base_regno == 0)\n+\treturn 0;\n+    }\n+  else if (rs6000_legitimate_offset_address_p (SImode, dest_addr, 0))\n+    {\n+      offset = INTVAL (XEXP (dest_addr, 1));\n+      base_regno = REGNO (XEXP (dest_addr, 0));\n+    }\n+  else\n+    return 0;\n+\n+  for (i = 0; i < count; i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i);\n+      rtx newaddr;\n+      rtx addr_reg;\n+      HOST_WIDE_INT newoffset;\n+\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || GET_MODE (SET_SRC (elt)) != SImode\n+\t  || REGNO (SET_SRC (elt)) != src_regno + i\n+\t  || GET_CODE (SET_DEST (elt)) != MEM\n+\t  || GET_MODE (SET_DEST (elt)) != SImode)\n+\treturn 0;\n+      newaddr = XEXP (SET_DEST (elt), 0);\n+      if (legitimate_indirect_address_p (newaddr, 0))\n+\t{\n+\t  newoffset = 0;\n+\t  addr_reg = newaddr;\n+\t}\n+      else if (rs6000_legitimate_offset_address_p (SImode, newaddr, 0))\n+\t{\n+\t  addr_reg = XEXP (newaddr, 0);\n+\t  newoffset = INTVAL (XEXP (newaddr, 1));\n+\t}\n+      else\n+\treturn 0;\n+      if (REGNO (addr_reg) != base_regno\n+\t  || newoffset != offset + 4 * i)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+})"}, {"sha": "efaca4138eba896d59ff48d0bdbbcc82921b5a15", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 14, "deletions": 66, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48d723357cd70e728528986d1ed82d7fd0eaa424/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48d723357cd70e728528986d1ed82d7fd0eaa424/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=48d723357cd70e728528986d1ed82d7fd0eaa424", "patch": "@@ -32,74 +32,29 @@ extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, int, int, int);\n extern void rs6000_va_start (tree, rtx);\n #endif /* TREE_CODE */\n \n+extern int easy_vector_same (rtx, enum machine_mode);\n+extern int easy_vector_splat_const (int, enum machine_mode);\n+extern int mask64_1or2_operand (rtx, enum machine_mode, bool);\n+extern bool macho_lo_sum_memory_operand (rtx, enum machine_mode);\n+extern int num_insns_constant (rtx, enum machine_mode);\n+extern int num_insns_constant_wide (HOST_WIDE_INT);\n+extern int small_data_operand (rtx, enum machine_mode);\n+extern bool toc_relative_expr_p (rtx);\n+extern bool invalid_e500_subreg (rtx, enum machine_mode);\n+extern void validate_condition_mode (enum rtx_code, enum machine_mode);\n+extern bool legitimate_constant_pool_address_p (rtx);\n+extern bool legitimate_indirect_address_p (rtx, int);\n+extern bool rs6000_legitimate_offset_address_p (enum machine_mode, rtx, int);\n+\n extern struct rtx_def *rs6000_got_register (rtx);\n extern struct rtx_def *find_addr_reg (rtx);\n-extern int any_operand (rtx, enum machine_mode);\n-extern int short_cint_operand (rtx, enum machine_mode);\n-extern int u_short_cint_operand (rtx, enum machine_mode);\n-extern int non_short_cint_operand (rtx, enum machine_mode);\n-extern int exact_log2_cint_operand (rtx, enum machine_mode);\n-extern int gpc_reg_operand (rtx, enum machine_mode);\n-extern int cc_reg_operand (rtx, enum machine_mode);\n-extern int cc_reg_not_cr0_operand (rtx, enum machine_mode);\n-extern int reg_or_short_operand (rtx, enum machine_mode);\n-extern int reg_or_neg_short_operand (rtx, enum machine_mode);\n-extern int reg_or_aligned_short_operand (rtx, enum machine_mode);\n-extern int reg_or_u_short_operand (rtx, enum machine_mode);\n-extern int reg_or_cint_operand (rtx, enum machine_mode);\n-extern int reg_or_arith_cint_operand (rtx, enum machine_mode);\n-extern int reg_or_add_cint64_operand (rtx, enum machine_mode);\n-extern int reg_or_sub_cint64_operand (rtx, enum machine_mode);\n-extern int reg_or_logical_cint_operand (rtx, enum machine_mode);\n-extern int got_operand (rtx, enum machine_mode);\n extern int word_offset_memref_operand (rtx, enum machine_mode);\n-extern int got_no_const_operand (rtx, enum machine_mode);\n-extern int num_insns_constant (rtx, enum machine_mode);\n-extern int easy_fp_constant (rtx, enum machine_mode);\n-extern int easy_vector_constant (rtx, enum machine_mode);\n extern rtx gen_easy_vector_constant_add_self (rtx);\n extern const char *output_vec_const_move (rtx *);\n-extern int zero_fp_constant (rtx, enum machine_mode);\n-extern int zero_constant (rtx, enum machine_mode);\n-extern int volatile_mem_operand (rtx, enum machine_mode);\n-extern int offsettable_mem_operand (rtx, enum machine_mode);\n-extern int mem_or_easy_const_operand (rtx, enum machine_mode);\n-extern int add_operand (rtx, enum machine_mode);\n-extern int non_add_cint_operand (rtx, enum machine_mode);\n-extern int non_logical_cint_operand (rtx, enum machine_mode);\n-extern int logical_operand (rtx, enum machine_mode);\n-extern int mask_operand (rtx, enum machine_mode);\n-extern int mask_operand_wrap (rtx, enum machine_mode);\n-extern int mask64_operand (rtx, enum machine_mode);\n-extern int mask64_2_operand (rtx, enum machine_mode);\n extern void build_mask64_2_operands (rtx, rtx *);\n-extern int and64_operand (rtx, enum machine_mode);\n-extern int and64_2_operand (rtx, enum machine_mode);\n-extern int and_operand (rtx, enum machine_mode);\n-extern int count_register_operand (rtx, enum machine_mode);\n-extern int xer_operand (rtx, enum machine_mode);\n-extern int reg_or_mem_operand (rtx, enum machine_mode);\n-extern int lwa_operand (rtx, enum machine_mode);\n-extern int call_operand (rtx, enum machine_mode);\n-extern int current_file_function_operand (rtx, enum machine_mode);\n-extern int input_operand (rtx, enum machine_mode);\n-extern int small_data_operand (rtx, enum machine_mode);\n-extern int s8bit_cint_operand (rtx, enum machine_mode);\n-extern bool legitimate_constant_pool_address_p (rtx);\n extern int expand_block_clear (rtx[]);\n extern int expand_block_move (rtx[]);\n-extern int load_multiple_operation (rtx, enum machine_mode);\n-extern int save_world_operation (rtx, enum machine_mode);\n-extern int restore_world_operation (rtx, enum machine_mode);\n extern const char * rs6000_output_load_multiple (rtx[]);\n-extern int store_multiple_operation (rtx, enum machine_mode);\n-extern int branch_comparison_operator (rtx, enum machine_mode);\n-extern int branch_positive_comparison_operator (rtx, enum machine_mode);\n-extern int scc_comparison_operator (rtx, enum machine_mode);\n-extern int trap_comparison_operator (rtx, enum machine_mode);\n-extern int boolean_operator (rtx, enum machine_mode);\n-extern int boolean_or_operator (rtx, enum machine_mode);\n-extern int min_max_operator (rtx, enum machine_mode);\n extern int includes_lshift_p (rtx, rtx);\n extern int includes_rshift_p (rtx, rtx);\n extern int includes_rldic_lshift_p (rtx, rtx);\n@@ -130,10 +85,6 @@ extern void output_toc (FILE *, rtx, int, enum machine_mode);\n extern void rs6000_initialize_trampoline (rtx, rtx, rtx);\n extern struct rtx_def *rs6000_longcall_ref (rtx);\n extern void rs6000_fatal_bad_address (rtx);\n-extern int stmw_operation (rtx, enum machine_mode);\n-extern int mfcr_operation (rtx, enum machine_mode);\n-extern int mtcrf_operation (rtx, enum machine_mode);\n-extern int lmw_operation (rtx, enum machine_mode);\n extern struct rtx_def *create_TOC_reference (rtx);\n extern void rs6000_split_multireg_move (rtx, rtx);\n extern void rs6000_emit_move (rtx, rtx, enum machine_mode);\n@@ -145,7 +96,6 @@ extern bool rs6000_mode_dependent_address (rtx);\n extern rtx rs6000_return_addr (int, rtx);\n extern void rs6000_output_symbol_ref (FILE*, rtx);\n extern HOST_WIDE_INT rs6000_initial_elimination_offset (int, int);\n-extern bool rs6000_legitimate_offset_address_p (enum machine_mode, rtx, int);\n \n extern rtx rs6000_machopic_legitimize_pic_address (rtx orig,\n \t\t\t\t\t\t   enum machine_mode mode,\n@@ -197,12 +147,10 @@ extern unsigned int rs6000_dbx_register_number (unsigned int);\n extern void rs6000_emit_epilogue (int);\n extern void rs6000_emit_eh_reg_restore (rtx, rtx);\n extern const char * output_isel (rtx *);\n-extern int vrsave_operation (rtx, enum machine_mode);\n extern int rs6000_register_move_cost (enum machine_mode,\n \t\t\t\t      enum reg_class, enum reg_class);\n extern int rs6000_memory_move_cost (enum machine_mode, enum reg_class, int);\n extern bool rs6000_tls_referenced_p (rtx);\n-extern int rs6000_tls_symbol_ref (rtx, enum machine_mode);\n extern void rs6000_output_dwarf_dtprel (FILE*, int, rtx);\n extern int rs6000_hard_regno_nregs (int, enum machine_mode);\n extern void rs6000_conditional_register_usage (void);"}, {"sha": "f0b7c185b4422fef3402057623412ac7d372c7a6", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 9, "deletions": 1479, "changes": 1488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48d723357cd70e728528986d1ed82d7fd0eaa424/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48d723357cd70e728528986d1ed82d7fd0eaa424/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=48d723357cd70e728528986d1ed82d7fd0eaa424", "patch": "@@ -64,9 +64,6 @@\n #define TARGET_NO_PROTOTYPE 0\n #endif\n \n-#define EASY_VECTOR_15(n) ((n) >= -16 && (n) <= 15)\n-#define EASY_VECTOR_15_ADD_SELF(n) ((n) >= 0x10 && (n) <= 0x1e && !((n) & 1))\n-\n #define min(A,B)\t((A) < (B) ? (A) : (B))\n #define max(A,B)\t((A) > (B) ? (A) : (B))\n \n@@ -603,8 +600,6 @@ struct processor_costs power4_cost = {\n \n \f\n static bool rs6000_function_ok_for_sibcall (tree, tree);\n-static int num_insns_constant_wide (HOST_WIDE_INT);\n-static void validate_condition_mode (enum rtx_code, enum machine_mode);\n static rtx rs6000_generate_compare (enum rtx_code);\n static void rs6000_maybe_dead (rtx);\n static void rs6000_emit_stack_tie (void);\n@@ -620,11 +615,8 @@ static unsigned toc_hash_function (const void *);\n static int toc_hash_eq (const void *, const void *);\n static int constant_pool_expr_1 (rtx, int *, int *);\n static bool constant_pool_expr_p (rtx);\n-static bool toc_relative_expr_p (rtx);\n static bool legitimate_small_data_p (enum machine_mode, rtx);\n static bool legitimate_indexed_address_p (rtx, int);\n-static bool legitimate_indirect_address_p (rtx, int);\n-static bool macho_lo_sum_memory_operand (rtx x, enum machine_mode mode);\n static bool legitimate_lo_sum_address_p (enum machine_mode, rtx, int);\n static struct machine_function * rs6000_init_machine_status (void);\n static bool rs6000_assemble_integer (rtx, unsigned int, int);\n@@ -710,7 +702,6 @@ static rtx spe_expand_builtin (tree, rtx, bool *);\n static rtx spe_expand_stv_builtin (enum insn_code, tree);\n static rtx spe_expand_predicate_builtin (enum insn_code, tree, rtx);\n static rtx spe_expand_evsel_builtin (enum insn_code, tree, rtx);\n-static bool invalid_e500_subreg (rtx, enum machine_mode);\n static int rs6000_emit_int_cmove (rtx, rtx, rtx, rtx);\n static rs6000_stack_t *rs6000_stack_info (void);\n static void debug_stack_info (rs6000_stack_t *);\n@@ -735,8 +726,6 @@ static void compute_save_world_info(rs6000_stack_t *info_ptr);\n static void is_altivec_return_reg (rtx, void *);\n static rtx generate_set_vrsave (rtx, rs6000_stack_t *, int);\n int easy_vector_constant (rtx, enum machine_mode);\n-static int easy_vector_same (rtx, enum machine_mode);\n-static int easy_vector_splat_const (int, enum machine_mode);\n static bool is_ev64_opaque_type (tree);\n static rtx rs6000_dwarf_register_span (rtx);\n static rtx rs6000_legitimize_tls_address (rtx, enum tls_model);\n@@ -853,10 +842,6 @@ static const char alt_reg_names[][8] =\n \n /* The VRSAVE bitmask puts bit %v0 as the most significant bit.  */\n #define ALTIVEC_REG_BIT(REGNO) (0x80000000 >> ((REGNO) - FIRST_ALTIVEC_REGNO))\n-\n-/* Return 1 for a symbol ref for a thread-local storage symbol.  */\n-#define RS6000_SYMBOL_REF_TLS_P(RTX) \\\n-  (GET_CODE (RTX) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (RTX) != 0)\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ATTRIBUTE_TABLE\n@@ -1810,312 +1795,10 @@ direct_return (void)\n   return 0;\n }\n \n-/* Returns 1 always.  */\n-\n-int\n-any_operand (rtx op ATTRIBUTE_UNUSED,\n-\t     enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return 1;\n-}\n-\n-/* Returns 1 always.  */\n-\n-int\n-any_parallel_operand (rtx op ATTRIBUTE_UNUSED,\n-\t\t      enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return 1;\n-}\n-\n-/* Returns 1 if op is the count register.  */\n-\n-int\n-count_register_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != REG)\n-    return 0;\n-\n-  if (REGNO (op) == COUNT_REGISTER_REGNUM)\n-    return 1;\n-\n-  if (REGNO (op) > FIRST_PSEUDO_REGISTER)\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Returns 1 if op is an altivec register.  */\n-\n-int\n-altivec_register_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (register_operand (op, mode)\n-\t  && (GET_CODE (op) != REG\n-\t      || REGNO (op) > FIRST_PSEUDO_REGISTER\n-\t      || ALTIVEC_REGNO_P (REGNO (op))));\n-}\n-\n-int\n-xer_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != REG)\n-    return 0;\n-\n-  if (XER_REGNO_P (REGNO (op)))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Return 1 if OP is a signed 8-bit constant.  Int multiplication\n-   by such constants completes more quickly.  */\n-\n-int\n-s8bit_cint_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && (INTVAL (op) >= -128 && INTVAL (op) <= 127));\n-}\n-\n-/* Return 1 if OP is a constant that can fit in a D field.  */\n-\n-int\n-short_cint_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && CONST_OK_FOR_LETTER_P (INTVAL (op), 'I'));\n-}\n-\n-/* Similar for an unsigned D field.  */\n-\n-int\n-u_short_cint_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && CONST_OK_FOR_LETTER_P (INTVAL (op) & GET_MODE_MASK (mode), 'K'));\n-}\n-\n-/* Return 1 if OP is a CONST_INT that cannot fit in a signed D field.  */\n-\n-int\n-non_short_cint_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && (unsigned HOST_WIDE_INT) (INTVAL (op) + 0x8000) >= 0x10000);\n-}\n-\n-/* Returns 1 if OP is a CONST_INT that is a positive value\n-   and an exact power of 2.  */\n-\n-int\n-exact_log2_cint_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && INTVAL (op) > 0\n-\t  && exact_log2 (INTVAL (op)) >= 0);\n-}\n-\n-/* Returns 1 if OP is a register that is not special (i.e., not MQ,\n-   ctr, or lr).  */\n-\n-int\n-gpc_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  return (register_operand (op, mode)\n-\t  && (GET_CODE (op) != REG\n-\t      || (REGNO (op) >= ARG_POINTER_REGNUM\n-\t\t  && !XER_REGNO_P (REGNO (op)))\n-\t      || REGNO (op) < MQ_REGNO));\n-}\n-\n-/* Returns 1 if OP is either a pseudo-register or a register denoting a\n-   CR field.  */\n-\n-int\n-cc_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  return (register_operand (op, mode)\n-\t  && (GET_CODE (op) != REG\n-\t      || REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t      || CR_REGNO_P (REGNO (op))));\n-}\n-\n-/* Returns 1 if OP is either a pseudo-register or a register denoting a\n-   CR field that isn't CR0.  */\n-\n-int\n-cc_reg_not_cr0_operand (rtx op, enum machine_mode mode)\n-{\n-  return (register_operand (op, mode)\n-\t  && (GET_CODE (op) != REG\n-\t      || REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t      || CR_REGNO_NOT_CR0_P (REGNO (op))));\n-}\n-\n-/* Returns 1 if OP is either a constant integer valid for a D-field or\n-   a non-special register.  If a register, it must be in the proper\n-   mode unless MODE is VOIDmode.  */\n-\n-int\n-reg_or_short_operand (rtx op, enum machine_mode mode)\n-{\n-  return short_cint_operand (op, mode) || gpc_reg_operand (op, mode);\n-}\n-\n-/* Similar, except check if the negation of the constant would be\n-   valid for a D-field.  Don't allow a constant zero, since all the\n-   patterns that call this predicate use \"addic r1,r2,-constant\" on\n-   a constant value to set a carry when r2 is greater or equal to\n-   \"constant\".  That doesn't work for zero.  */\n-\n-int\n-reg_or_neg_short_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return CONST_OK_FOR_LETTER_P (INTVAL (op), 'P') && INTVAL (op) != 0;\n-\n-  return gpc_reg_operand (op, mode);\n-}\n-\n-/* Returns 1 if OP is either a constant integer valid for a DS-field or\n-   a non-special register.  If a register, it must be in the proper\n-   mode unless MODE is VOIDmode.  */\n-\n-int\n-reg_or_aligned_short_operand (rtx op, enum machine_mode mode)\n-{\n-  if (gpc_reg_operand (op, mode))\n-    return 1;\n-  else if (short_cint_operand (op, mode) && !(INTVAL (op) & 3))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-\n-/* Return 1 if the operand is either a register or an integer whose\n-   high-order 16 bits are zero.  */\n-\n-int\n-reg_or_u_short_operand (rtx op, enum machine_mode mode)\n-{\n-  return u_short_cint_operand (op, mode) || gpc_reg_operand (op, mode);\n-}\n-\n-/* Return 1 is the operand is either a non-special register or ANY\n-   constant integer.  */\n-\n-int\n-reg_or_cint_operand (rtx op, enum machine_mode mode)\n-{\n-  return (GET_CODE (op) == CONST_INT || gpc_reg_operand (op, mode));\n-}\n-\n-/* Return 1 is the operand is either a non-special register or ANY\n-   32-bit signed constant integer.  */\n-\n-int\n-reg_or_arith_cint_operand (rtx op, enum machine_mode mode)\n-{\n-  return (gpc_reg_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT\n-#if HOST_BITS_PER_WIDE_INT != 32\n-\t      && ((unsigned HOST_WIDE_INT) (INTVAL (op) + 0x80000000)\n-\t\t  < (unsigned HOST_WIDE_INT) 0x100000000ll)\n-#endif\n-\t      ));\n-}\n-\n-/* Return 1 is the operand is either a non-special register or a 32-bit\n-   signed constant integer valid for 64-bit addition.  */\n-\n-int\n-reg_or_add_cint64_operand (rtx op, enum machine_mode mode)\n-{\n-  return (gpc_reg_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT\n-#if HOST_BITS_PER_WIDE_INT == 32\n-\t      && INTVAL (op) < 0x7fff8000\n-#else\n-\t      && ((unsigned HOST_WIDE_INT) (INTVAL (op) + 0x80008000)\n-\t\t  < 0x100000000ll)\n-#endif\n-\t      ));\n-}\n-\n-/* Return 1 is the operand is either a non-special register or a 32-bit\n-   signed constant integer valid for 64-bit subtraction.  */\n-\n-int\n-reg_or_sub_cint64_operand (rtx op, enum machine_mode mode)\n-{\n-  return (gpc_reg_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT\n-#if HOST_BITS_PER_WIDE_INT == 32\n-\t      && (- INTVAL (op)) < 0x7fff8000\n-#else\n-\t      && ((unsigned HOST_WIDE_INT) ((- INTVAL (op)) + 0x80008000)\n-\t\t  < 0x100000000ll)\n-#endif\n-\t      ));\n-}\n-\n-/* Return 1 is the operand is either a non-special register or ANY\n-   32-bit unsigned constant integer.  */\n-\n-int\n-reg_or_logical_cint_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      if (GET_MODE_BITSIZE (mode) > HOST_BITS_PER_WIDE_INT)\n-\t{\n-\t  if (GET_MODE_BITSIZE (mode) <= 32)\n-\t    abort ();\n-\n-\t  if (INTVAL (op) < 0)\n-\t    return 0;\n-\t}\n-\n-      return ((INTVAL (op) & GET_MODE_MASK (mode)\n-\t       & (~ (unsigned HOST_WIDE_INT) 0xffffffff)) == 0);\n-    }\n-  else if (GET_CODE (op) == CONST_DOUBLE)\n-    {\n-      if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t  || mode != DImode)\n-\tabort ();\n-\n-      return CONST_DOUBLE_HIGH (op) == 0;\n-    }\n-  else\n-    return gpc_reg_operand (op, mode);\n-}\n-\n-/* Return 1 if the operand is an operand that can be loaded via the GOT.  */\n-\n-int\n-got_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == SYMBOL_REF\n-\t  || GET_CODE (op) == CONST\n-\t  || GET_CODE (op) == LABEL_REF);\n-}\n-\n-/* Return 1 if the operand is a simple references that can be loaded via\n-   the GOT (labels involving addition aren't allowed).  */\n-\n-int\n-got_no_const_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF);\n-}\n-\n /* Return the number of instructions it takes to form a constant in an\n    integer register.  */\n \n-static int\n+int\n num_insns_constant_wide (HOST_WIDE_INT value)\n {\n   /* signed constant loadable with {cal|addi} */\n@@ -2222,88 +1905,9 @@ num_insns_constant (rtx op, enum machine_mode mode)\n     abort ();\n }\n \n-/* Return 1 if the operand is a CONST_DOUBLE and it can be put into a\n-   register with one instruction per word.  We only do this if we can\n-   safely read CONST_DOUBLE_{LOW,HIGH}.  */\n-\n-int\n-easy_fp_constant (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) != CONST_DOUBLE\n-      || GET_MODE (op) != mode\n-      || (GET_MODE_CLASS (mode) != MODE_FLOAT && mode != DImode))\n-    return 0;\n-\n-  /* Consider all constants with -msoft-float to be easy.  */\n-  if ((TARGET_SOFT_FLOAT || TARGET_E500_SINGLE)\n-      && mode != DImode)\n-    return 1;\n-\n-  /* If we are using V.4 style PIC, consider all constants to be hard.  */\n-  if (flag_pic && DEFAULT_ABI == ABI_V4)\n-    return 0;\n-\n-#ifdef TARGET_RELOCATABLE\n-  /* Similarly if we are using -mrelocatable, consider all constants\n-     to be hard.  */\n-  if (TARGET_RELOCATABLE)\n-    return 0;\n-#endif\n-\n-  if (mode == TFmode)\n-    {\n-      long k[4];\n-      REAL_VALUE_TYPE rv;\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n-      REAL_VALUE_TO_TARGET_LONG_DOUBLE (rv, k);\n-\n-      return (num_insns_constant_wide ((HOST_WIDE_INT) k[0]) == 1\n-\t      && num_insns_constant_wide ((HOST_WIDE_INT) k[1]) == 1\n-\t      && num_insns_constant_wide ((HOST_WIDE_INT) k[2]) == 1\n-\t      && num_insns_constant_wide ((HOST_WIDE_INT) k[3]) == 1);\n-    }\n-\n-  else if (mode == DFmode)\n-    {\n-      long k[2];\n-      REAL_VALUE_TYPE rv;\n-\n-      if (TARGET_E500_DOUBLE)\n-\treturn 0;\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n-      REAL_VALUE_TO_TARGET_DOUBLE (rv, k);\n-\n-      return (num_insns_constant_wide ((HOST_WIDE_INT) k[0]) == 1\n-\t      && num_insns_constant_wide ((HOST_WIDE_INT) k[1]) == 1);\n-    }\n-\n-  else if (mode == SFmode)\n-    {\n-      long l;\n-      REAL_VALUE_TYPE rv;\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n-      REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n-\n-      return num_insns_constant_wide (l) == 1;\n-    }\n-\n-  else if (mode == DImode)\n-    return ((TARGET_POWERPC64\n-\t     && GET_CODE (op) == CONST_DOUBLE && CONST_DOUBLE_LOW (op) == 0)\n-\t    || (num_insns_constant (op, DImode) <= 2));\n-\n-  else if (mode == SImode)\n-    return 1;\n-  else\n-    abort ();\n-}\n-\n /* Returns the constant for the splat instruction, if exists.  */\n \n-static int\n+int\n easy_vector_splat_const (int cst, enum machine_mode mode)\n {\n   switch (mode)\n@@ -2336,10 +1940,9 @@ easy_vector_splat_const (int cst, enum machine_mode mode)\n   return 0;\n }\n \n-\n /* Return nonzero if all elements of a vector have the same value.  */\n \n-static int\n+int\n easy_vector_same (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   int units, i, cst;\n@@ -2355,75 +1958,6 @@ easy_vector_same (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   return 0;\n }\n \n-/* Return 1 if the operand is a CONST_INT and can be put into a\n-   register without using memory.  */\n-\n-int\n-easy_vector_constant (rtx op, enum machine_mode mode)\n-{\n-  int cst, cst2;\n-\n-  if (GET_CODE (op) != CONST_VECTOR\n-      || (!TARGET_ALTIVEC\n-\t  && !TARGET_SPE))\n-    return 0;\n-\n-  if (zero_constant (op, mode)\n-      && ((TARGET_ALTIVEC && ALTIVEC_VECTOR_MODE (mode))\n-\t  || (TARGET_SPE && SPE_VECTOR_MODE (mode))))\n-    return 1;\n-\n-  if (GET_MODE_CLASS (mode) != MODE_VECTOR_INT)\n-    return 0;\n-\n-  if (TARGET_SPE && mode == V1DImode)\n-    return 0;\n-\n-  cst  = INTVAL (CONST_VECTOR_ELT (op, 0));\n-  cst2 = INTVAL (CONST_VECTOR_ELT (op, 1));\n-\n-  /* Limit SPE vectors to 15 bits signed.  These we can generate with:\n-       li r0, CONSTANT1\n-       evmergelo r0, r0, r0\n-       li r0, CONSTANT2\n-\n-     I don't know how efficient it would be to allow bigger constants,\n-     considering we'll have an extra 'ori' for every 'li'.  I doubt 5\n-     instructions is better than a 64-bit memory load, but I don't\n-     have the e500 timing specs.  */\n-  if (TARGET_SPE && mode == V2SImode\n-      && cst  >= -0x7fff && cst <= 0x7fff\n-      && cst2 >= -0x7fff && cst2 <= 0x7fff)\n-    return 1;\n-\n-  if (TARGET_ALTIVEC\n-      && easy_vector_same (op, mode))\n-    {\n-      cst = easy_vector_splat_const (cst, mode);\n-      if (EASY_VECTOR_15_ADD_SELF (cst)\n-\t  || EASY_VECTOR_15 (cst))\n-\treturn 1;\n-    }\n-  return 0;\n-}\n-\n-/* Same as easy_vector_constant but only for EASY_VECTOR_15_ADD_SELF.  */\n-\n-int\n-easy_vector_constant_add_self (rtx op, enum machine_mode mode)\n-{\n-  int cst;\n-  if (TARGET_ALTIVEC\n-      && GET_CODE (op) == CONST_VECTOR\n-      && easy_vector_same (op, mode))\n-    {\n-      cst = easy_vector_splat_const (INTVAL (CONST_VECTOR_ELT (op, 0)), mode);\n-      if (EASY_VECTOR_15_ADD_SELF (cst))\n-\treturn 1;\n-    }\n-  return 0;\n-}\n-\n /* Generate easy_vector_constant out of a easy_vector_constant_add_self.  */\n \n rtx\n@@ -2520,241 +2054,7 @@ output_vec_const_move (rtx *operands)\n   abort ();\n }\n \n-/* Return 1 if the operand is the constant 0.  This works for scalars\n-   as well as vectors.  */\n-int\n-zero_constant (rtx op, enum machine_mode mode)\n-{\n-  return op == CONST0_RTX (mode);\n-}\n-\n-/* Return 1 if the operand is 0.0.  */\n-int\n-zero_fp_constant (rtx op, enum machine_mode mode)\n-{\n-  return GET_MODE_CLASS (mode) == MODE_FLOAT && op == CONST0_RTX (mode);\n-}\n-\n-/* Return 1 if the operand is in volatile memory.  Note that during\n-   the RTL generation phase, memory_operand does not return TRUE for\n-   volatile memory references.  So this function allows us to\n-   recognize volatile references where its safe.  */\n-\n-int\n-volatile_mem_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-\n-  if (!MEM_VOLATILE_P (op))\n-    return 0;\n-\n-  if (mode != GET_MODE (op))\n-    return 0;\n-\n-  if (reload_completed)\n-    return memory_operand (op, mode);\n-\n-  if (reload_in_progress)\n-    return strict_memory_address_p (mode, XEXP (op, 0));\n-\n-  return memory_address_p (mode, XEXP (op, 0));\n-}\n-\n-/* Return 1 if the operand is an offsettable memory operand.  */\n-\n-int\n-offsettable_mem_operand (rtx op, enum machine_mode mode)\n-{\n-  return ((GET_CODE (op) == MEM)\n-\t  && offsettable_address_p (reload_completed || reload_in_progress,\n-\t\t\t\t    mode, XEXP (op, 0)));\n-}\n-\n-/* Return 1 if the operand is either an easy FP constant (see above) or\n-   memory.  */\n-\n-int\n-mem_or_easy_const_operand (rtx op, enum machine_mode mode)\n-{\n-  return memory_operand (op, mode) || easy_fp_constant (op, mode);\n-}\n-\n-/* Return 1 if the operand is either a non-special register or an item\n-   that can be used as the operand of a `mode' add insn.  */\n-\n-int\n-add_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return (CONST_OK_FOR_LETTER_P (INTVAL (op), 'I')\n-\t    || CONST_OK_FOR_LETTER_P (INTVAL (op), 'L'));\n-\n-  return gpc_reg_operand (op, mode);\n-}\n-\n-/* Return 1 if OP is a constant but not a valid add_operand.  */\n-\n-int\n-non_add_cint_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && !CONST_OK_FOR_LETTER_P (INTVAL (op), 'I')\n-\t  && !CONST_OK_FOR_LETTER_P (INTVAL (op), 'L'));\n-}\n-\n-/* Return 1 if the operand is a non-special register or a constant that\n-   can be used as the operand of an OR or XOR insn on the RS/6000.  */\n-\n-int\n-logical_operand (rtx op, enum machine_mode mode)\n-{\n-  HOST_WIDE_INT opl, oph;\n-\n-  if (gpc_reg_operand (op, mode))\n-    return 1;\n-\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      opl = INTVAL (op) & GET_MODE_MASK (mode);\n-\n-#if HOST_BITS_PER_WIDE_INT <= 32\n-      if (GET_MODE_BITSIZE (mode) > HOST_BITS_PER_WIDE_INT && opl < 0)\n-\treturn 0;\n-#endif\n-    }\n-  else if (GET_CODE (op) == CONST_DOUBLE)\n-    {\n-      if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n-\tabort ();\n-\n-      opl = CONST_DOUBLE_LOW (op);\n-      oph = CONST_DOUBLE_HIGH (op);\n-      if (oph != 0)\n-\treturn 0;\n-    }\n-  else\n-    return 0;\n-\n-  return ((opl & ~ (unsigned HOST_WIDE_INT) 0xffff) == 0\n-\t  || (opl & ~ (unsigned HOST_WIDE_INT) 0xffff0000) == 0);\n-}\n-\n-/* Return 1 if C is a constant that is not a logical operand (as\n-   above), but could be split into one.  */\n-\n-int\n-non_logical_cint_operand (rtx op, enum machine_mode mode)\n-{\n-  return ((GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_DOUBLE)\n-\t  && ! logical_operand (op, mode)\n-\t  && reg_or_logical_cint_operand (op, mode));\n-}\n-\n-/* Return 1 if C is a constant that can be encoded in a 32-bit mask on the\n-   RS/6000.  It is if there are no more than two 1->0 or 0->1 transitions.\n-   Reject all ones and all zeros, since these should have been optimized\n-   away and confuse the making of MB and ME.  */\n-\n-int\n-mask_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  HOST_WIDE_INT c, lsb;\n-\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-\n-  c = INTVAL (op);\n-\n-  /* Fail in 64-bit mode if the mask wraps around because the upper\n-     32-bits of the mask will all be 1s, contrary to GCC's internal view.  */\n-  if (TARGET_POWERPC64 && (c & 0x80000001) == 0x80000001)\n-    return 0;\n-\n-  /* We don't change the number of transitions by inverting,\n-     so make sure we start with the LS bit zero.  */\n-  if (c & 1)\n-    c = ~c;\n-\n-  /* Reject all zeros or all ones.  */\n-  if (c == 0)\n-    return 0;\n-\n-  /* Find the first transition.  */\n-  lsb = c & -c;\n-\n-  /* Invert to look for a second transition.  */\n-  c = ~c;\n-\n-  /* Erase first transition.  */\n-  c &= -lsb;\n-\n-  /* Find the second transition (if any).  */\n-  lsb = c & -c;\n-\n-  /* Match if all the bits above are 1's (or c is zero).  */\n-  return c == -lsb;\n-}\n-\n-/* Return 1 for the PowerPC64 rlwinm corner case.  */\n-\n-int\n-mask_operand_wrap (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  HOST_WIDE_INT c, lsb;\n-\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-\n-  c = INTVAL (op);\n-\n-  if ((c & 0x80000001) != 0x80000001)\n-    return 0;\n-\n-  c = ~c;\n-  if (c == 0)\n-    return 0;\n-\n-  lsb = c & -c;\n-  c = ~c;\n-  c &= -lsb;\n-  lsb = c & -c;\n-  return c == -lsb;\n-}\n-\n-/* Return 1 if the operand is a constant that is a PowerPC64 mask.\n-   It is if there are no more than one 1->0 or 0->1 transitions.\n-   Reject all zeros, since zero should have been optimized away and\n-   confuses the making of MB and ME.  */\n-\n int\n-mask64_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      HOST_WIDE_INT c, lsb;\n-\n-      c = INTVAL (op);\n-\n-      /* Reject all zeros.  */\n-      if (c == 0)\n-\treturn 0;\n-\n-      /* We don't change the number of transitions by inverting,\n-\t so make sure we start with the LS bit zero.  */\n-      if (c & 1)\n-\tc = ~c;\n-\n-      /* Find the transition, and check that all bits above are 1's.  */\n-      lsb = c & -c;\n-\n-      /* Match if all the bits above are 1's (or c is zero).  */\n-      return c == -lsb;\n-    }\n-  return 0;\n-}\n-\n-static int\n mask64_1or2_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t       bool allow_one)\n {\n@@ -2809,14 +2109,6 @@ mask64_1or2_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED,\n   return 0;\n }\n \n-/* Like mask64_operand, but allow up to three transitions.  This\n-   predicate is used by insn patterns that generate two rldicl or\n-   rldicr machine insns.   */\n-int mask64_2_operand (rtx op, enum machine_mode mode)\n-{\n-  return mask64_1or2_operand (op, mode, false);\n-}\n-\n /* Generates shifts and masks for a pair of rldicl or rldicr insns to\n    implement ANDing by the mask IN.  */\n void\n@@ -2887,174 +2179,9 @@ build_mask64_2_operands (rtx in, rtx *out)\n #endif\n }\n \n-/* Return 1 if the operand is either a non-special register or a constant\n-   that can be used as the operand of a PowerPC64 logical AND insn.  */\n-\n-int\n-and64_operand (rtx op, enum machine_mode mode)\n-{\n-  if (fixed_regs[CR0_REGNO])\t/* CR0 not available, don't do andi./andis.  */\n-    return (gpc_reg_operand (op, mode) || mask64_operand (op, mode));\n-\n-  return (logical_operand (op, mode) || mask64_operand (op, mode));\n-}\n-\n-/* Like the above, but also match constants that can be implemented\n-   with two rldicl or rldicr insns.  */\n-\n-int\n-and64_2_operand (rtx op, enum machine_mode mode)\n-{\n-  if (fixed_regs[CR0_REGNO])\t/* CR0 not available, don't do andi./andis.  */\n-    return gpc_reg_operand (op, mode) || mask64_1or2_operand (op, mode, true);\n-\n-  return logical_operand (op, mode) || mask64_1or2_operand (op, mode, true);\n-}\n-\n-/* Return 1 if the operand is either a non-special register or a\n-   constant that can be used as the operand of an RS/6000 logical AND insn.  */\n-\n-int\n-and_operand (rtx op, enum machine_mode mode)\n-{\n-  if (fixed_regs[CR0_REGNO])\t/* CR0 not available, don't do andi./andis.  */\n-    return (gpc_reg_operand (op, mode) || mask_operand (op, mode));\n-\n-  return (logical_operand (op, mode) || mask_operand (op, mode));\n-}\n-\n-/* Return 1 if the operand is a general register or memory operand.  */\n-\n-int\n-reg_or_mem_operand (rtx op, enum machine_mode mode)\n-{\n-  return (gpc_reg_operand (op, mode)\n-\t  || memory_operand (op, mode)\n-\t  || macho_lo_sum_memory_operand (op, mode)\n-\t  || volatile_mem_operand (op, mode));\n-}\n-\n-/* Return 1 if the operand is a general register or memory operand without\n-   pre_inc or pre_dec which produces invalid form of PowerPC lwa\n-   instruction.  */\n-\n-int\n-lwa_operand (rtx op, enum machine_mode mode)\n-{\n-  rtx inner = op;\n-\n-  if (reload_completed && GET_CODE (inner) == SUBREG)\n-    inner = SUBREG_REG (inner);\n-\n-  return gpc_reg_operand (inner, mode)\n-    || (memory_operand (inner, mode)\n-\t&& GET_CODE (XEXP (inner, 0)) != PRE_INC\n-\t&& GET_CODE (XEXP (inner, 0)) != PRE_DEC\n-\t&& (GET_CODE (XEXP (inner, 0)) != PLUS\n-\t    || GET_CODE (XEXP (XEXP (inner, 0), 1)) != CONST_INT\n-\t    || INTVAL (XEXP (XEXP (inner, 0), 1)) % 4 == 0));\n-}\n-\n-/* Return 1 if the operand, used inside a MEM, is a SYMBOL_REF.  */\n-\n-int\n-symbol_ref_operand (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && GET_MODE (op) != mode)\n-    return 0;\n-\n-  return (GET_CODE (op) == SYMBOL_REF\n-\t  && (DEFAULT_ABI != ABI_AIX || SYMBOL_REF_FUNCTION_P (op)));\n-}\n-\n-/* Return 1 if the operand, used inside a MEM, is a valid first argument\n-   to CALL.  This is a SYMBOL_REF, a pseudo-register, LR or CTR.  */\n-\n-int\n-call_operand (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && GET_MODE (op) != mode)\n-    return 0;\n-\n-  return (GET_CODE (op) == SYMBOL_REF\n-\t  || (GET_CODE (op) == REG\n-\t      && (REGNO (op) == LINK_REGISTER_REGNUM\n-\t\t  || REGNO (op) == COUNT_REGISTER_REGNUM\n-\t\t  || REGNO (op) >= FIRST_PSEUDO_REGISTER)));\n-}\n-\n-/* Return 1 if the operand is a SYMBOL_REF for a function known to be in\n-   this file.  */\n-\n-int\n-current_file_function_operand (rtx op,\n-\t\t\t       enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == SYMBOL_REF\n-\t  && (DEFAULT_ABI != ABI_AIX || SYMBOL_REF_FUNCTION_P (op))\n-\t  && (SYMBOL_REF_LOCAL_P (op)\n-\t      || (DECL_RTL_SET_P (current_function_decl)\n-\t\t  && op == XEXP (DECL_RTL (current_function_decl), 0))));\n-}\n-\n-/* Return 1 if this operand is a valid input for a move insn.  */\n-\n-int\n-input_operand (rtx op, enum machine_mode mode)\n-{\n-  /* Memory is always valid.  */\n-  if (memory_operand (op, mode))\n-    return 1;\n-\n-  /* For floating-point, easy constants are valid.  */\n-  if (GET_MODE_CLASS (mode) == MODE_FLOAT\n-      && CONSTANT_P (op)\n-      && easy_fp_constant (op, mode))\n-    return 1;\n-\n-  /* Allow any integer constant.  */\n-  if (GET_MODE_CLASS (mode) == MODE_INT\n-      && (GET_CODE (op) == CONST_INT\n-\t  || GET_CODE (op) == CONST_DOUBLE))\n-    return 1;\n-\n-  /* Allow easy vector constants.  */\n-  if (GET_CODE (op) == CONST_VECTOR\n-      && easy_vector_constant (op, mode))\n-    return 1;\n-\n-  /* For floating-point or multi-word mode, the only remaining valid type\n-     is a register.  */\n-  if (GET_MODE_CLASS (mode) == MODE_FLOAT\n-      || GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n-    return register_operand (op, mode);\n-\n-  /* The only cases left are integral modes one word or smaller (we\n-     do not get called for MODE_CC values).  These can be in any\n-     register.  */\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  /* A SYMBOL_REF referring to the TOC is valid.  */\n-  if (legitimate_constant_pool_address_p (op))\n-    return 1;\n-\n-  /* A constant pool expression (relative to the TOC) is valid */\n-  if (toc_relative_expr_p (op))\n-    return 1;\n-\n-  /* V.4 allows SYMBOL_REFs and CONSTs that are in the small data region\n-     to be valid.  */\n-  if (DEFAULT_ABI == ABI_V4\n-      && (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == CONST)\n-      && small_data_operand (op, Pmode))\n-    return 1;\n-\n-  return 0;\n-}\n-\n /* Return TRUE if OP is an invalid SUBREG operation on the e500.  */\n-static bool\n+\n+bool\n invalid_e500_subreg (rtx op, enum machine_mode mode)\n {\n   /* Reject (subreg:SI (reg:DF)).  */\n@@ -3074,19 +2201,6 @@ invalid_e500_subreg (rtx op, enum machine_mode mode)\n   return false;\n }\n \n-/* Just like nonimmediate_operand, but return 0 for invalid SUBREG's\n-   on the e500.  */\n-int\n-rs6000_nonimmediate_operand (rtx op, enum machine_mode mode)\n-{\n-  if (TARGET_E500_DOUBLE\n-      && GET_CODE (op) == SUBREG\n-      && invalid_e500_subreg (op, mode))\n-    return 0;\n-\n-  return nonimmediate_operand (op, mode);\n-}\n-\n /* Darwin, AIX increases natural record alignment to doubleword if the first\n    field is an FP double while the FP fields remain word aligned.  */\n \n@@ -3228,7 +2342,7 @@ constant_pool_expr_p (rtx op)\n   return constant_pool_expr_1 (op, &have_sym, &have_toc) && have_sym;\n }\n \n-static bool\n+bool\n toc_relative_expr_p (rtx op)\n {\n   int have_sym = 0;\n@@ -3351,13 +2465,13 @@ legitimate_indexed_address_p (rtx x, int strict)\n \t      && INT_REG_OK_FOR_INDEX_P (op0, strict)));\n }\n \n-static inline bool\n+inline bool\n legitimate_indirect_address_p (rtx x, int strict)\n {\n   return GET_CODE (x) == REG && INT_REG_OK_FOR_BASE_P (x, strict);\n }\n \n-static bool\n+bool\n macho_lo_sum_memory_operand (rtx x, enum machine_mode mode)\n {\n   if (!TARGET_MACHO || !flag_pic\n@@ -3783,15 +2897,6 @@ rs6000_legitimize_tls_address (rtx addr, enum tls_model model)\n   return dest;\n }\n \n-/* Return 1 if X is a SYMBOL_REF for a TLS symbol.  This is used in\n-   instruction definitions.  */\n-\n-int\n-rs6000_tls_symbol_ref (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return RS6000_SYMBOL_REF_TLS_P (x);\n-}\n-\n /* Return 1 if X contains a thread-local symbol.  */\n \n bool\n@@ -9193,225 +8298,6 @@ expand_block_move (rtx operands[])\n }\n \n \f\n-/* Return 1 if OP is suitable for a save_world call in prologue. It is\n-   known to be a PARALLEL. */\n-int\n-save_world_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  int index;\n-  int i;\n-  rtx elt;\n-  int count = XVECLEN (op, 0);\n-\n-  if (count != 55)\n-    return 0;\n-\n-  index = 0;\n-  if (GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER\n-      || GET_CODE (XVECEXP (op, 0, index++)) != USE)\n-    return 0;\n-\n-  for (i=1; i <= 18; i++)\n-    {\n-      elt = XVECEXP (op, 0, index++);\n-      if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_DEST (elt)) != MEM\n-\t  || ! memory_operand (SET_DEST (elt), DFmode)\n-\t  || GET_CODE (SET_SRC (elt)) != REG\n-\t  || GET_MODE (SET_SRC (elt)) != DFmode)\n-\treturn 0;\n-    }\n-\n-  for (i=1; i <= 12; i++)\n-    {\n-      elt = XVECEXP (op, 0, index++);\n-      if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_DEST (elt)) != MEM\n-\t  || GET_CODE (SET_SRC (elt)) != REG\n-\t  || GET_MODE (SET_SRC (elt)) != V4SImode)\n-\treturn 0;\n-    }\n-\n-  for (i=1; i <= 19; i++)\n-    {\n-      elt = XVECEXP (op, 0, index++);\n-      if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_DEST (elt)) != MEM\n-\t  || ! memory_operand (SET_DEST (elt), Pmode)\n-\t  || GET_CODE (SET_SRC (elt)) != REG\n-\t  || GET_MODE (SET_SRC (elt)) != Pmode)\n-\treturn 0;\n-    }\n-\n-  elt = XVECEXP (op, 0, index++);\n-  if (GET_CODE (elt) != SET\n-      || GET_CODE (SET_DEST (elt)) != MEM\n-      || ! memory_operand (SET_DEST (elt), Pmode)\n-      || GET_CODE (SET_SRC (elt)) != REG\n-      || REGNO (SET_SRC (elt)) != CR2_REGNO\n-      || GET_MODE (SET_SRC (elt)) != Pmode)\n-    return 0;\n-\n-  if (GET_CODE (XVECEXP (op, 0, index++)) != USE\n-      || GET_CODE (XVECEXP (op, 0, index++)) != USE\n-      || GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER)\n-    return 0;\n-  return 1;\n-}\n-\n-/* Return 1 if OP is suitable for a save_world call in prologue. It is\n-   known to be a PARALLEL. */\n-int\n-restore_world_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  int index;\n-  int i;\n-  rtx elt;\n-  int count = XVECLEN (op, 0);\n-\n-  if (count != 59)\n-    return 0;\n-\n-  index = 0;\n-  if (GET_CODE (XVECEXP (op, 0, index++)) != RETURN\n-      || GET_CODE (XVECEXP (op, 0, index++)) != USE\n-      || GET_CODE (XVECEXP (op, 0, index++)) != USE\n-      || GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER)\n-    return 0;\n-\n-  elt = XVECEXP (op, 0, index++);\n-  if (GET_CODE (elt) != SET\n-      || GET_CODE (SET_SRC (elt)) != MEM\n-      || ! memory_operand (SET_SRC (elt), Pmode)\n-      || GET_CODE (SET_DEST (elt)) != REG\n-      || REGNO (SET_DEST (elt)) != CR2_REGNO\n-      || GET_MODE (SET_DEST (elt)) != Pmode)\n-    return 0;\n-\n-  for (i=1; i <= 19; i++)\n-    {\n-      elt = XVECEXP (op, 0, index++);\n-      if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_SRC (elt)) != MEM\n-\t  || ! memory_operand (SET_SRC (elt), Pmode)\n-\t  || GET_CODE (SET_DEST (elt)) != REG\n-\t  || GET_MODE (SET_DEST (elt)) != Pmode)\n-\treturn 0;\n-    }\n-\n-  for (i=1; i <= 12; i++)\n-    {\n-      elt = XVECEXP (op, 0, index++);\n-      if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_SRC (elt)) != MEM\n-\t  || GET_CODE (SET_DEST (elt)) != REG\n-\t  || GET_MODE (SET_DEST (elt)) != V4SImode)\n-\treturn 0;\n-    }\n-\n-  for (i=1; i <= 18; i++)\n-    {\n-      elt = XVECEXP (op, 0, index++);\n-      if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_SRC (elt)) != MEM\n-\t  || ! memory_operand (SET_SRC (elt), DFmode)\n-\t  || GET_CODE (SET_DEST (elt)) != REG\n-\t  || GET_MODE (SET_DEST (elt)) != DFmode)\n-\treturn 0;\n-    }\n-\n-  if (GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER\n-      || GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER\n-      || GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER\n-      || GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER\n-      || GET_CODE (XVECEXP (op, 0, index++)) != USE)\n-    return 0;\n-  return 1;\n-}\n-\n-\f\n-/* Return 1 if OP is a load multiple operation.  It is known to be a\n-   PARALLEL and the first section will be tested.  */\n-\n-int\n-load_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  int count = XVECLEN (op, 0);\n-  unsigned int dest_regno;\n-  rtx src_addr;\n-  int i;\n-\n-  /* Perform a quick check so we don't blow up below.  */\n-  if (count <= 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != MEM)\n-    return 0;\n-\n-  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n-  src_addr = XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0);\n-\n-  for (i = 1; i < count; i++)\n-    {\n-      rtx elt = XVECEXP (op, 0, i);\n-\n-      if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_DEST (elt)) != REG\n-\t  || GET_MODE (SET_DEST (elt)) != SImode\n-\t  || REGNO (SET_DEST (elt)) != dest_regno + i\n-\t  || GET_CODE (SET_SRC (elt)) != MEM\n-\t  || GET_MODE (SET_SRC (elt)) != SImode\n-\t  || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n-\t  || ! rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n-\t  || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n-\t  || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1)) != i * 4)\n-\treturn 0;\n-    }\n-\n-  return 1;\n-}\n-\n-/* Similar, but tests for store multiple.  Here, the second vector element\n-   is a CLOBBER.  It will be tested later.  */\n-\n-int\n-store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  int count = XVECLEN (op, 0) - 1;\n-  unsigned int src_regno;\n-  rtx dest_addr;\n-  int i;\n-\n-  /* Perform a quick check so we don't blow up below.  */\n-  if (count <= 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != MEM\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != REG)\n-    return 0;\n-\n-  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, 0)));\n-  dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, 0)), 0);\n-\n-  for (i = 1; i < count; i++)\n-    {\n-      rtx elt = XVECEXP (op, 0, i + 1);\n-\n-      if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_SRC (elt)) != REG\n-\t  || GET_MODE (SET_SRC (elt)) != SImode\n-\t  || REGNO (SET_SRC (elt)) != src_regno + i\n-\t  || GET_CODE (SET_DEST (elt)) != MEM\n-\t  || GET_MODE (SET_DEST (elt)) != SImode\n-\t  || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n-\t  || ! rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_addr)\n-\t  || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n-\t  || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1)) != i * 4)\n-\treturn 0;\n-    }\n-\n-  return 1;\n-}\n-\n /* Return a string to perform a load_multiple operation.\n    operands[0] is the vector.\n    operands[1] is the source address.\n@@ -9469,292 +8355,12 @@ rs6000_output_load_multiple (rtx operands[3])\n   return \"{lsi|lswi} %2,%1,%N0\";\n }\n \n-/* Return 1 for a parallel vrsave operation.  */\n-\n-int\n-vrsave_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  int count = XVECLEN (op, 0);\n-  unsigned int dest_regno, src_regno;\n-  int i;\n-\n-  if (count <= 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != UNSPEC_VOLATILE)\n-    return 0;\n-\n-  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n-  src_regno  = REGNO (SET_SRC (XVECEXP (op, 0, 0)));\n-\n-  if (dest_regno != VRSAVE_REGNO\n-      && src_regno != VRSAVE_REGNO)\n-    return 0;\n-\n-  for (i = 1; i < count; i++)\n-    {\n-      rtx elt = XVECEXP (op, 0, i);\n-\n-      if (GET_CODE (elt) != CLOBBER\n-\t  && GET_CODE (elt) != SET)\n-\treturn 0;\n-    }\n-\n-  return 1;\n-}\n-\n-/* Return 1 for an PARALLEL suitable for mfcr.  */\n-\n-int\n-mfcr_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  int count = XVECLEN (op, 0);\n-  int i;\n-\n-  /* Perform a quick check so we don't blow up below.  */\n-  if (count < 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != UNSPEC\n-      || XVECLEN (SET_SRC (XVECEXP (op, 0, 0)), 0) != 2)\n-    return 0;\n-\n-  for (i = 0; i < count; i++)\n-    {\n-      rtx exp = XVECEXP (op, 0, i);\n-      rtx unspec;\n-      int maskval;\n-      rtx src_reg;\n-\n-      src_reg = XVECEXP (SET_SRC (exp), 0, 0);\n-\n-      if (GET_CODE (src_reg) != REG\n-\t  || GET_MODE (src_reg) != CCmode\n-\t  || ! CR_REGNO_P (REGNO (src_reg)))\n-\treturn 0;\n-\n-      if (GET_CODE (exp) != SET\n-\t  || GET_CODE (SET_DEST (exp)) != REG\n-\t  || GET_MODE (SET_DEST (exp)) != SImode\n-\t  || ! INT_REGNO_P (REGNO (SET_DEST (exp))))\n-\treturn 0;\n-      unspec = SET_SRC (exp);\n-      maskval = 1 << (MAX_CR_REGNO - REGNO (src_reg));\n-\n-      if (GET_CODE (unspec) != UNSPEC\n-\t  || XINT (unspec, 1) != UNSPEC_MOVESI_FROM_CR\n-\t  || XVECLEN (unspec, 0) != 2\n-\t  || XVECEXP (unspec, 0, 0) != src_reg\n-\t  || GET_CODE (XVECEXP (unspec, 0, 1)) != CONST_INT\n-\t  || INTVAL (XVECEXP (unspec, 0, 1)) != maskval)\n-\treturn 0;\n-    }\n-  return 1;\n-}\n-\n-/* Return 1 for an PARALLEL suitable for mtcrf.  */\n-\n-int\n-mtcrf_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  int count = XVECLEN (op, 0);\n-  int i;\n-  rtx src_reg;\n-\n-  /* Perform a quick check so we don't blow up below.  */\n-  if (count < 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != UNSPEC\n-      || XVECLEN (SET_SRC (XVECEXP (op, 0, 0)), 0) != 2)\n-    return 0;\n-  src_reg = XVECEXP (SET_SRC (XVECEXP (op, 0, 0)), 0, 0);\n-\n-  if (GET_CODE (src_reg) != REG\n-      || GET_MODE (src_reg) != SImode\n-      || ! INT_REGNO_P (REGNO (src_reg)))\n-    return 0;\n-\n-  for (i = 0; i < count; i++)\n-    {\n-      rtx exp = XVECEXP (op, 0, i);\n-      rtx unspec;\n-      int maskval;\n-\n-      if (GET_CODE (exp) != SET\n-\t  || GET_CODE (SET_DEST (exp)) != REG\n-\t  || GET_MODE (SET_DEST (exp)) != CCmode\n-\t  || ! CR_REGNO_P (REGNO (SET_DEST (exp))))\n-\treturn 0;\n-      unspec = SET_SRC (exp);\n-      maskval = 1 << (MAX_CR_REGNO - REGNO (SET_DEST (exp)));\n-\n-      if (GET_CODE (unspec) != UNSPEC\n-\t  || XINT (unspec, 1) != UNSPEC_MOVESI_TO_CR\n-\t  || XVECLEN (unspec, 0) != 2\n-\t  || XVECEXP (unspec, 0, 0) != src_reg\n-\t  || GET_CODE (XVECEXP (unspec, 0, 1)) != CONST_INT\n-\t  || INTVAL (XVECEXP (unspec, 0, 1)) != maskval)\n-\treturn 0;\n-    }\n-  return 1;\n-}\n-\n-/* Return 1 for an PARALLEL suitable for lmw.  */\n-\n-int\n-lmw_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  int count = XVECLEN (op, 0);\n-  unsigned int dest_regno;\n-  rtx src_addr;\n-  unsigned int base_regno;\n-  HOST_WIDE_INT offset;\n-  int i;\n-\n-  /* Perform a quick check so we don't blow up below.  */\n-  if (count <= 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != MEM)\n-    return 0;\n-\n-  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n-  src_addr = XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0);\n-\n-  if (dest_regno > 31\n-      || count != 32 - (int) dest_regno)\n-    return 0;\n-\n-  if (legitimate_indirect_address_p (src_addr, 0))\n-    {\n-      offset = 0;\n-      base_regno = REGNO (src_addr);\n-      if (base_regno == 0)\n-\treturn 0;\n-    }\n-  else if (rs6000_legitimate_offset_address_p (SImode, src_addr, 0))\n-    {\n-      offset = INTVAL (XEXP (src_addr, 1));\n-      base_regno = REGNO (XEXP (src_addr, 0));\n-    }\n-  else\n-    return 0;\n-\n-  for (i = 0; i < count; i++)\n-    {\n-      rtx elt = XVECEXP (op, 0, i);\n-      rtx newaddr;\n-      rtx addr_reg;\n-      HOST_WIDE_INT newoffset;\n-\n-      if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_DEST (elt)) != REG\n-\t  || GET_MODE (SET_DEST (elt)) != SImode\n-\t  || REGNO (SET_DEST (elt)) != dest_regno + i\n-\t  || GET_CODE (SET_SRC (elt)) != MEM\n-\t  || GET_MODE (SET_SRC (elt)) != SImode)\n-\treturn 0;\n-      newaddr = XEXP (SET_SRC (elt), 0);\n-      if (legitimate_indirect_address_p (newaddr, 0))\n-\t{\n-\t  newoffset = 0;\n-\t  addr_reg = newaddr;\n-\t}\n-      else if (rs6000_legitimate_offset_address_p (SImode, newaddr, 0))\n-\t{\n-\t  addr_reg = XEXP (newaddr, 0);\n-\t  newoffset = INTVAL (XEXP (newaddr, 1));\n-\t}\n-      else\n-\treturn 0;\n-      if (REGNO (addr_reg) != base_regno\n-\t  || newoffset != offset + 4 * i)\n-\treturn 0;\n-    }\n-\n-  return 1;\n-}\n-\n-/* Return 1 for an PARALLEL suitable for stmw.  */\n-\n-int\n-stmw_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  int count = XVECLEN (op, 0);\n-  unsigned int src_regno;\n-  rtx dest_addr;\n-  unsigned int base_regno;\n-  HOST_WIDE_INT offset;\n-  int i;\n-\n-  /* Perform a quick check so we don't blow up below.  */\n-  if (count <= 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != MEM\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != REG)\n-    return 0;\n-\n-  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, 0)));\n-  dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, 0)), 0);\n-\n-  if (src_regno > 31\n-      || count != 32 - (int) src_regno)\n-    return 0;\n-\n-  if (legitimate_indirect_address_p (dest_addr, 0))\n-    {\n-      offset = 0;\n-      base_regno = REGNO (dest_addr);\n-      if (base_regno == 0)\n-\treturn 0;\n-    }\n-  else if (rs6000_legitimate_offset_address_p (SImode, dest_addr, 0))\n-    {\n-      offset = INTVAL (XEXP (dest_addr, 1));\n-      base_regno = REGNO (XEXP (dest_addr, 0));\n-    }\n-  else\n-    return 0;\n-\n-  for (i = 0; i < count; i++)\n-    {\n-      rtx elt = XVECEXP (op, 0, i);\n-      rtx newaddr;\n-      rtx addr_reg;\n-      HOST_WIDE_INT newoffset;\n-\n-      if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_SRC (elt)) != REG\n-\t  || GET_MODE (SET_SRC (elt)) != SImode\n-\t  || REGNO (SET_SRC (elt)) != src_regno + i\n-\t  || GET_CODE (SET_DEST (elt)) != MEM\n-\t  || GET_MODE (SET_DEST (elt)) != SImode)\n-\treturn 0;\n-      newaddr = XEXP (SET_DEST (elt), 0);\n-      if (legitimate_indirect_address_p (newaddr, 0))\n-\t{\n-\t  newoffset = 0;\n-\t  addr_reg = newaddr;\n-\t}\n-      else if (rs6000_legitimate_offset_address_p (SImode, newaddr, 0))\n-\t{\n-\t  addr_reg = XEXP (newaddr, 0);\n-\t  newoffset = INTVAL (XEXP (newaddr, 1));\n-\t}\n-      else\n-\treturn 0;\n-      if (REGNO (addr_reg) != base_regno\n-\t  || newoffset != offset + 4 * i)\n-\treturn 0;\n-    }\n-\n-  return 1;\n-}\n \f\n /* A validation routine: say whether CODE, a condition code, and MODE\n    match.  The other alternatives either don't make sense or should\n    never be generated.  */\n \n-static void\n+void\n validate_condition_mode (enum rtx_code code, enum machine_mode mode)\n {\n   if ((GET_RTX_CLASS (code) != RTX_COMPARE\n@@ -9793,82 +8399,6 @@ validate_condition_mode (enum rtx_code code, enum machine_mode mode)\n     abort ();\n }\n \n-/* Return 1 if OP is a comparison operation that is valid for a branch insn.\n-   We only check the opcode against the mode of the CC value here.  */\n-\n-int\n-branch_comparison_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code code = GET_CODE (op);\n-  enum machine_mode cc_mode;\n-\n-  if (!COMPARISON_P (op))\n-    return 0;\n-\n-  cc_mode = GET_MODE (XEXP (op, 0));\n-  if (GET_MODE_CLASS (cc_mode) != MODE_CC)\n-    return 0;\n-\n-  validate_condition_mode (code, cc_mode);\n-\n-  return 1;\n-}\n-\n-/* Return 1 if OP is a comparison operation that is valid for a branch\n-   insn and which is true if the corresponding bit in the CC register\n-   is set.  */\n-\n-int\n-branch_positive_comparison_operator (rtx op, enum machine_mode mode)\n-{\n-  enum rtx_code code;\n-\n-  if (! branch_comparison_operator (op, mode))\n-    return 0;\n-\n-  code = GET_CODE (op);\n-  return (code == EQ || code == LT || code == GT\n-\t  || code == LTU || code == GTU\n-\t  || code == UNORDERED);\n-}\n-\n-/* Return 1 if OP is a comparison operation that is valid for an scc\n-   insn: it must be a positive comparison.  */\n-\n-int\n-scc_comparison_operator (rtx op, enum machine_mode mode)\n-{\n-  return branch_positive_comparison_operator (op, mode);\n-}\n-\n-int\n-trap_comparison_operator (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-  return COMPARISON_P (op);\n-}\n-\n-int\n-boolean_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code code = GET_CODE (op);\n-  return (code == AND || code == IOR || code == XOR);\n-}\n-\n-int\n-boolean_or_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code code = GET_CODE (op);\n-  return (code == IOR || code == XOR);\n-}\n-\n-int\n-min_max_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code code = GET_CODE (op);\n-  return (code == SMIN || code == SMAX || code == UMIN || code == UMAX);\n-}\n \f\n /* Return 1 if ANDOP is a mask that has no bits on that are not in the\n    mask required to convert the result of a rotate insn into a shift"}, {"sha": "9b8f1fd710f5afaf79e6621e6054b8847d62c0bb", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 7, "deletions": 81, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48d723357cd70e728528986d1ed82d7fd0eaa424/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48d723357cd70e728528986d1ed82d7fd0eaa424/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=48d723357cd70e728528986d1ed82d7fd0eaa424", "patch": "@@ -251,6 +251,10 @@ extern int target_flags;\n #define HAVE_AS_TLS 0\n #endif\n \n+/* Return 1 for a symbol ref for a thread-local storage symbol.  */\n+#define RS6000_SYMBOL_REF_TLS_P(RTX) \\\n+  (GET_CODE (RTX) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (RTX) != 0)\n+\n #ifdef IN_LIBGCC2\n /* For libgcc2 we make sure this is a compile time constant */\n #if defined (__64BIT__) || defined (__powerpc64__)\n@@ -1931,6 +1935,9 @@ typedef struct rs6000_args\n     || easy_vector_constant (X, GET_MODE (X)))\t\t\t\\\n    && !rs6000_tls_referenced_p (X))\n \n+#define EASY_VECTOR_15(n) ((n) >= -16 && (n) <= 15)\n+#define EASY_VECTOR_15_ADD_SELF(n) ((n) >= 0x10 && (n) <= 0x1e && !((n) & 1))\n+\n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n    We have two alternate definitions for each of them.\n@@ -2538,87 +2545,6 @@ extern char rs6000_reg_names[][8];\t/* register names (0 vs. %r0).  */\n \n #define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n \n-/* Define the codes that are matched by predicates in rs6000.c.  */\n-\n-#define PREDICATE_CODES\t\t\t\t\t\t\t   \\\n-  {\"any_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\t   \\\n-\t\t   LABEL_REF, SUBREG, REG, MEM}},\t\t\t   \\\n-  {\"any_parallel_operand\", {PARALLEL}},\t\t\t\t\t   \\\n-  {\"zero_constant\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t   \\\n-\t\t    LABEL_REF, SUBREG, REG, MEM}},\t\t\t   \\\n-  {\"short_cint_operand\", {CONST_INT}},\t\t\t\t\t   \\\n-  {\"u_short_cint_operand\", {CONST_INT}},\t\t\t\t   \\\n-  {\"non_short_cint_operand\", {CONST_INT}},\t\t\t\t   \\\n-  {\"exact_log2_cint_operand\", {CONST_INT}},\t\t\t\t   \\\n-  {\"gpc_reg_operand\", {SUBREG, REG}},\t\t\t\t\t   \\\n-  {\"cc_reg_operand\", {SUBREG, REG}},\t\t\t\t\t   \\\n-  {\"cc_reg_not_cr0_operand\", {SUBREG, REG}},\t\t\t\t   \\\n-  {\"reg_or_short_operand\", {SUBREG, REG, CONST_INT}},\t\t\t   \\\n-  {\"reg_or_neg_short_operand\", {SUBREG, REG, CONST_INT}},\t\t   \\\n-  {\"reg_or_aligned_short_operand\", {SUBREG, REG, CONST_INT}},\t\t   \\\n-  {\"reg_or_u_short_operand\", {SUBREG, REG, CONST_INT}},\t\t\t   \\\n-  {\"reg_or_cint_operand\", {SUBREG, REG, CONST_INT}},\t\t\t   \\\n-  {\"reg_or_arith_cint_operand\", {SUBREG, REG, CONST_INT}},\t\t   \\\n-  {\"reg_or_add_cint64_operand\", {SUBREG, REG, CONST_INT}},\t\t   \\\n-  {\"reg_or_sub_cint64_operand\", {SUBREG, REG, CONST_INT}},\t\t   \\\n-  {\"reg_or_logical_cint_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}}, \\\n-  {\"got_operand\", {SYMBOL_REF, CONST, LABEL_REF}},\t\t\t   \\\n-  {\"got_no_const_operand\", {SYMBOL_REF, LABEL_REF}},\t\t\t   \\\n-  {\"easy_fp_constant\", {CONST_DOUBLE}},\t\t\t\t\t   \\\n-  {\"easy_vector_constant\", {CONST_VECTOR}},\t\t\t\t   \\\n-  {\"easy_vector_constant_add_self\", {CONST_VECTOR}},\t\t\t   \\\n-  {\"zero_fp_constant\", {CONST_DOUBLE}},\t\t\t\t\t   \\\n-  {\"reg_or_mem_operand\", {SUBREG, MEM, REG}},\t\t\t\t   \\\n-  {\"lwa_operand\", {SUBREG, MEM, REG}},\t\t\t\t\t   \\\n-  {\"volatile_mem_operand\", {MEM}},\t\t\t\t\t   \\\n-  {\"offsettable_mem_operand\", {MEM}},\t\t\t\t\t   \\\n-  {\"mem_or_easy_const_operand\", {SUBREG, MEM, CONST_DOUBLE}},\t\t   \\\n-  {\"add_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t   \\\n-  {\"non_add_cint_operand\", {CONST_INT}},\t\t\t\t   \\\n-  {\"and_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t   \\\n-  {\"and64_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\t   \\\n-  {\"and64_2_operand\", {SUBREG, REG, CONST_INT}},\t\t\t   \\\n-  {\"logical_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\t   \\\n-  {\"non_logical_cint_operand\", {CONST_INT, CONST_DOUBLE}},\t\t   \\\n-  {\"mask_operand\", {CONST_INT}},\t\t\t\t\t   \\\n-  {\"mask_operand_wrap\", {CONST_INT}},\t\t\t\t\t   \\\n-  {\"mask64_operand\", {CONST_INT}},\t\t\t\t\t   \\\n-  {\"mask64_2_operand\", {CONST_INT}},\t\t\t\t\t   \\\n-  {\"count_register_operand\", {REG}},\t\t\t\t\t   \\\n-  {\"xer_operand\", {REG}},\t\t\t\t\t\t   \\\n-  {\"symbol_ref_operand\", {SYMBOL_REF}},\t\t\t\t\t   \\\n-  {\"rs6000_tls_symbol_ref\", {SYMBOL_REF}},\t\t\t\t   \\\n-  {\"call_operand\", {SYMBOL_REF, REG}},\t\t\t\t\t   \\\n-  {\"current_file_function_operand\", {SYMBOL_REF}},\t\t\t   \\\n-  {\"input_operand\", {SUBREG, MEM, REG, CONST_INT,\t\t\t   \\\n-\t\t     CONST_DOUBLE, SYMBOL_REF}},\t\t\t   \\\n-  {\"rs6000_nonimmediate_operand\", {SUBREG, MEM, REG}},\t\t   \t   \\\n-  {\"load_multiple_operation\", {PARALLEL}},\t\t\t\t   \\\n-  {\"store_multiple_operation\", {PARALLEL}},\t\t\t\t   \\\n-  {\"lmw_operation\", {PARALLEL}},\t\t\t\t\t   \\\n-  {\"stmw_operation\", {PARALLEL}},\t\t\t\t\t   \\\n-  {\"vrsave_operation\", {PARALLEL}},\t\t\t\t\t   \\\n-  {\"save_world_operation\", {PARALLEL}},                                    \\\n-  {\"restore_world_operation\", {PARALLEL}},                                 \\\n-  {\"mfcr_operation\", {PARALLEL}},\t\t\t\t\t   \\\n-  {\"mtcrf_operation\", {PARALLEL}},\t\t\t\t\t   \\\n-  {\"branch_comparison_operator\", {EQ, NE, LE, LT, GE,\t\t\t   \\\n-\t\t\t\t  GT, LEU, LTU, GEU, GTU,\t\t   \\\n-\t\t\t\t  UNORDERED, ORDERED,\t\t\t   \\\n-\t\t\t\t  UNGE, UNLE }},\t\t\t   \\\n-  {\"branch_positive_comparison_operator\", {EQ, LT, GT, LTU, GTU,\t   \\\n-\t\t\t\t\t   UNORDERED }},\t\t   \\\n-  {\"scc_comparison_operator\", {EQ, NE, LE, LT, GE,\t\t\t   \\\n-\t\t\t       GT, LEU, LTU, GEU, GTU,\t\t\t   \\\n-\t\t\t       UNORDERED, ORDERED,\t\t\t   \\\n-\t\t\t       UNGE, UNLE }},\t\t\t\t   \\\n-  {\"trap_comparison_operator\", {EQ, NE, LE, LT, GE,\t\t\t   \\\n-\t\t\t\tGT, LEU, LTU, GEU, GTU}},\t\t   \\\n-  {\"boolean_operator\", {AND, IOR, XOR}},\t\t\t\t   \\\n-  {\"boolean_or_operator\", {IOR, XOR}},\t\t\t\t\t   \\\n-  {\"altivec_register_operand\", {REG}},\t                                   \\\n-  {\"min_max_operator\", {SMIN, SMAX, UMIN, UMAX}},\n-\n /* uncomment for disabling the corresponding default options */\n /* #define  MACHINE_no_sched_interblock */\n /* #define  MACHINE_no_sched_speculative */"}, {"sha": "5f297ccdc6923d73ea1967d74af3ce145dba160b", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48d723357cd70e728528986d1ed82d7fd0eaa424/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48d723357cd70e728528986d1ed82d7fd0eaa424/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=48d723357cd70e728528986d1ed82d7fd0eaa424", "patch": "@@ -101,6 +101,9 @@\n (include \"8540.md\")\n (include \"power4.md\")\n (include \"power5.md\")\n+\n+(include \"predicates.md\")\n+\n (include \"darwin.md\")\n \n \f"}]}