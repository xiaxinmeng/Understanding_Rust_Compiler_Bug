{"sha": "fc7a823e1507110aba804cf94415155a8783e698", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM3YTgyM2UxNTA3MTEwYWJhODA0Y2Y5NDQxNTE1NWE4NzgzZTY5OA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-05-28T15:24:12Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-05-28T15:24:12Z"}, "message": "gigi.h (gnat_stabilize_reference): Adjust.\n\n\t* gcc-interface/gigi.h (gnat_stabilize_reference): Adjust.\n\t(rewrite_fn): Remove third parameter.\n\t(type_is_padding_self_referential): New inline predicate.\n\t(return_type_with_variable_size_p): Likewise.\n\t* gcc-interface/decl.c (allocatable_size_p): More around.\n\t(cannot_be_superflat_p): Rename into...\n\t(cannot_be_superflat ): ...this.\n\t(initial_value_needs_conversion): New predicate.\n\t(gnat_to_gnu_entity): Invoke type_is_padding_self_referential,\n\tinitial_value_needs_conversion and adjust to above renaming.\n\tFor a renaming, force the materialization if the inner expression\n\tis compound.  Adjust calls to elaborate_reference and build a\n\tcompound expression if needed.\n\t(struct er_dat): Add N field.\n\t(elaborate_reference_1): Remove N parameter and adjust.\n\t(elaborate_reference): Add INIT parameter and pass it in the call to\n\tgnat_rewrite_reference.  Adjust initial expression.\n\t* gcc-interface/trans.c (Call_to_gnu): Treat renamings the same way as\n\tregular object declarations when it comes to creating a temporary.\n\tAdjust call to gnat_stabilize_reference and build a compound expression\n \tif needed.  Invoke return_type_with_variable_size_p.\n\t(gnat_to_gnu): Invoke type_is_padding_self_referential.  In case #4,\n\treturn a call to a function unmodified if it returns with variable size\n \tand is also the initial expression in an object declaration.\n\t* gcc-interface/utils2.c (build_binary_op) <INIT_EXPR>: Use the RHS'\n\ttype if it is a call to a function that returns with variable size.\n\t(build_unary_op): Invoke type_is_padding_self_referential.\n\t(gnat_stabilize_reference_1): Remove N parameter and adjust.\n\t(gnat_stabilize_reference): Add INIT parameter and pass it in the call\n\tto gnat_rewrite_reference.\n\t(gnat_rewrite_reference):  Remove N, add INIT parameter and adjust.\n\t<COMPOUND_EXPR>: New case.\n\nFrom-SVN: r223834", "tree": {"sha": "fb09192367caa4ff2977684a039b071404d51421", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb09192367caa4ff2977684a039b071404d51421"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc7a823e1507110aba804cf94415155a8783e698", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc7a823e1507110aba804cf94415155a8783e698", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc7a823e1507110aba804cf94415155a8783e698", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc7a823e1507110aba804cf94415155a8783e698/comments", "author": null, "committer": null, "parents": [{"sha": "318a4e6de8f20670c9f9e9dde02dc639f161f68c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/318a4e6de8f20670c9f9e9dde02dc639f161f68c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/318a4e6de8f20670c9f9e9dde02dc639f161f68c"}], "stats": {"total": 488, "additions": 343, "deletions": 145}, "files": [{"sha": "204f9b99bd301bc350ac356631190fead0422d25", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fc7a823e1507110aba804cf94415155a8783e698", "patch": "@@ -1,3 +1,38 @@\n+2015-05-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (gnat_stabilize_reference): Adjust.\n+\t(rewrite_fn): Remove third parameter.\n+\t(type_is_padding_self_referential): New inline predicate.\n+\t(return_type_with_variable_size_p): Likewise.\n+\t* gcc-interface/decl.c (allocatable_size_p): More around.\n+\t(cannot_be_superflat_p): Rename into...\n+\t(cannot_be_superflat ): ...this.\n+\t(initial_value_needs_conversion): New predicate.\n+\t(gnat_to_gnu_entity): Invoke type_is_padding_self_referential,\n+\tinitial_value_needs_conversion and adjust to above renaming.\n+\tFor a renaming, force the materialization if the inner expression\n+\tis compound.  Adjust calls to elaborate_reference and build a\n+\tcompound expression if needed.\n+\t(struct er_dat): Add N field.\n+\t(elaborate_reference_1): Remove N parameter and adjust.\n+\t(elaborate_reference): Add INIT parameter and pass it in the call to\n+\tgnat_rewrite_reference.  Adjust initial expression.\n+\t* gcc-interface/trans.c (Call_to_gnu): Treat renamings the same way as\n+\tregular object declarations when it comes to creating a temporary.\n+\tAdjust call to gnat_stabilize_reference and build a compound expression\n+ \tif needed.  Invoke return_type_with_variable_size_p.\n+\t(gnat_to_gnu): Invoke type_is_padding_self_referential.  In case #4,\n+\treturn a call to a function unmodified if it returns with variable size\n+ \tand is also the initial expression in an object declaration.\n+\t* gcc-interface/utils2.c (build_binary_op) <INIT_EXPR>: Use the RHS'\n+\ttype if it is a call to a function that returns with variable size.\n+\t(build_unary_op): Invoke type_is_padding_self_referential.\n+\t(gnat_stabilize_reference_1): Remove N parameter and adjust.\n+\t(gnat_stabilize_reference): Add INIT parameter and pass it in the call\n+\tto gnat_rewrite_reference.\n+\t(gnat_rewrite_reference):  Remove N, add INIT parameter and adjust.\n+\t<COMPOUND_EXPR>: New case.\n+\n 2015-05-28  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch3.adb (Is_Visible_Component): Component is visible"}, {"sha": "f955efc8797b12b9822c4ccaf0e855c7ea4529c7", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 97, "deletions": 76, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=fc7a823e1507110aba804cf94415155a8783e698", "patch": "@@ -168,7 +168,6 @@ struct value_annotation_hasher : ggc_cache_hasher<tree_int_map *>\n \n static GTY ((cache)) hash_table<value_annotation_hasher> *annotate_value_cache;\n \n-static bool allocatable_size_p (tree, bool);\n static void prepend_one_attribute (struct attrib **,\n \t\t\t\t   enum attr_type, tree, tree, Node_Id);\n static void prepend_one_attribute_pragma (struct attrib **, Node_Id);\n@@ -179,7 +178,7 @@ static bool type_has_variable_size (tree);\n static tree elaborate_expression_1 (tree, Entity_Id, const char *, bool, bool);\n static tree elaborate_expression_2 (tree, Entity_Id, const char *, bool, bool,\n \t\t\t\t    unsigned int);\n-static tree elaborate_reference (tree, Entity_Id, bool);\n+static tree elaborate_reference (tree, Entity_Id, bool, tree *);\n static tree gnat_to_gnu_component_type (Entity_Id, bool, bool);\n static tree gnat_to_gnu_param (Entity_Id, Mechanism_Type, Entity_Id, bool,\n \t\t\t       bool *);\n@@ -189,8 +188,10 @@ static tree change_qualified_type (tree, int);\n static bool same_discriminant_p (Entity_Id, Entity_Id);\n static bool array_type_has_nonaliased_component (tree, Entity_Id);\n static bool compile_time_known_address_p (Node_Id);\n-static bool cannot_be_superflat_p (Node_Id);\n+static bool cannot_be_superflat (Node_Id);\n static bool constructor_address_p (tree);\n+static bool allocatable_size_p (tree, bool);\n+static bool initial_value_needs_conversion (tree, tree);\n static int compare_field_bitpos (const PTR, const PTR);\n static bool components_to_record (tree, Node_Id, tree, int, bool, bool, bool,\n \t\t\t\t  bool, bool, bool, bool, bool, tree, tree *);\n@@ -957,8 +958,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   to make it more likely to rename the underlying object.  */\n \tif (Present (Renamed_Object (gnat_entity)))\n \t  {\n-\t    /* If the renamed object had padding, strip off the reference\n-\t       to the inner object and reset our type.  */\n+\t    /* If the renamed object had padding, strip off the reference to\n+\t       the inner object and reset our type.  */\n \t    if ((TREE_CODE (gnu_expr) == COMPONENT_REF\n \t\t && TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (gnu_expr, 0))))\n \t\t/* Strip useless conversions around the object.  */\n@@ -970,10 +971,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t    /* Or else, if the renamed object has an unconstrained type with\n \t       default discriminant, use the padded type.  */\n-\t    else if (TYPE_IS_PADDING_P (TREE_TYPE (gnu_expr))\n-\t\t     && TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_expr)))\n-\t\t\t== gnu_type\n-\t\t     && CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type)))\n+\t    else if (type_is_padding_self_referential (TREE_TYPE (gnu_expr)))\n \t      gnu_type = TREE_TYPE (gnu_expr);\n \n \t    /* Case 1: if this is a constant renaming stemming from a function\n@@ -1001,12 +999,20 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    /* Case 2: if the renaming entity need not be materialized, use\n \t       the elaborated renamed expression for the renaming.  But this\n \t       means that the caller is responsible for evaluating the address\n-\t       of the renaming at the correct spot in the definition case to\n+\t       of the renaming in the correct place for the definition case to\n \t       instantiate the SAVE_EXPRs.  */\n-\t    else if (!Materialize_Entity (gnat_entity))\n+\t    else if (TREE_CODE (inner) != COMPOUND_EXPR\n+\t\t     && !Materialize_Entity (gnat_entity))\n \t      {\n+\t\ttree init = NULL_TREE;\n+\n \t\tgnu_decl\n-\t\t  = elaborate_reference (gnu_expr, gnat_entity, definition);\n+\t\t  = elaborate_reference (gnu_expr, gnat_entity, definition,\n+\t\t\t\t\t &init);\n+\n+\t\t/* We cannot evaluate the first arm of a COMPOUND_EXPR in the\n+\t\t   correct place for this case, hence the above test.  */\n+\t\tgcc_assert (init == NULL_TREE);\n \n \t\t/* No DECL_EXPR will be created so the expression needs to be\n \t\t   marked manually because it will likely be shared.  */\n@@ -1039,6 +1045,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       volatility of the renamed object through the indirection.  */\n \t    else\n \t      {\n+\t\ttree init = NULL_TREE;\n+\n \t\tif (TREE_THIS_VOLATILE (gnu_expr) && !TYPE_VOLATILE (gnu_type))\n \t\t  gnu_type\n \t\t    = change_qualified_type (gnu_type, TYPE_QUAL_VOLATILE);\n@@ -1050,7 +1058,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tgnu_size = NULL_TREE;\n \n \t\trenamed_obj\n-\t\t  = elaborate_reference (gnu_expr, gnat_entity, definition);\n+\t\t  = elaborate_reference (gnu_expr, gnat_entity, definition,\n+\t\t\t\t\t &init);\n \n \t\t/* If we are not defining the entity, the expression will not\n \t\t   be attached through DECL_INITIAL so it needs to be marked\n@@ -1064,8 +1073,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    && TREE_CODE (renamed_obj) == ERROR_MARK)\n \t\t  gnu_expr = NULL_TREE;\n \t\telse\n-\t\t  gnu_expr\n-\t\t    = build_unary_op (ADDR_EXPR, gnu_type, renamed_obj);\n+\t\t  {\n+\t\t    gnu_expr\n+\t\t      = build_unary_op (ADDR_EXPR, gnu_type, renamed_obj);\n+\t\t    if (init)\n+\t\t      gnu_expr\n+\t\t\t= build_compound_expr (TREE_TYPE (gnu_expr), init,\n+\t\t\t\t\t       gnu_expr);\n+\t\t  }\n \t      }\n \t  }\n \n@@ -1115,24 +1130,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    gnu_expr = gnat_build_constructor (gnu_type, v);\n \t  }\n \n-\t/* Convert the expression to the type of the object except in the\n-\t   case where the object's type is unconstrained or the object's type\n-\t   is a padded record whose field is of self-referential size.  In\n-\t   the former case, converting will generate unnecessary evaluations\n-\t   of the CONSTRUCTOR to compute the size and in the latter case, we\n-\t   want to only copy the actual data.  Also don't convert to a record\n-\t   type with a variant part from a record type without one, to keep\n-\t   the object simpler.  */\n-\tif (gnu_expr\n-\t    && TREE_CODE (gnu_type) != UNCONSTRAINED_ARRAY_TYPE\n-\t    && !CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type))\n-\t    && !(TYPE_IS_PADDING_P (gnu_type)\n-\t\t && CONTAINS_PLACEHOLDER_P\n-\t\t    (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS (gnu_type)))))\n-\t    && !(TREE_CODE (gnu_type) == RECORD_TYPE\n-\t\t && TREE_CODE (TREE_TYPE (gnu_expr)) == RECORD_TYPE\n-\t\t && get_variant_part (gnu_type) != NULL_TREE\n-\t\t && get_variant_part (TREE_TYPE (gnu_expr)) == NULL_TREE))\n+\t/* Convert the expression to the type of the object if need be.  */\n+\tif (gnu_expr && initial_value_needs_conversion (gnu_type, gnu_expr))\n \t  gnu_expr = convert (gnu_type, gnu_expr);\n \n \t/* If this is a pointer that doesn't have an initializing expression,\n@@ -1380,24 +1379,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (const_flag)\n \t  gnu_type = change_qualified_type (gnu_type, TYPE_QUAL_CONST);\n \n-\t/* Convert the expression to the type of the object except in the\n-\t   case where the object's type is unconstrained or the object's type\n-\t   is a padded record whose field is of self-referential size.  In\n-\t   the former case, converting will generate unnecessary evaluations\n-\t   of the CONSTRUCTOR to compute the size and in the latter case, we\n-\t   want to only copy the actual data.  Also don't convert to a record\n-\t   type with a variant part from a record type without one, to keep\n-\t   the object simpler.  */\n-\tif (gnu_expr\n-\t    && TREE_CODE (gnu_type) != UNCONSTRAINED_ARRAY_TYPE\n-\t    && !CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type))\n-\t    && !(TYPE_IS_PADDING_P (gnu_type)\n-\t\t && CONTAINS_PLACEHOLDER_P\n-\t\t    (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS (gnu_type)))))\n-\t    && !(TREE_CODE (gnu_type) == RECORD_TYPE\n-\t\t && TREE_CODE (TREE_TYPE (gnu_expr)) == RECORD_TYPE\n-\t\t && get_variant_part (gnu_type) != NULL_TREE\n-\t\t && get_variant_part (TREE_TYPE (gnu_expr)) == NULL_TREE))\n+\t/* Convert the expression to the type of the object if need be.  */\n+\tif (gnu_expr && initial_value_needs_conversion (gnu_type, gnu_expr))\n \t  gnu_expr = convert (gnu_type, gnu_expr);\n \n \t/* If this name is external or a name was specified, use it, but don't\n@@ -2334,7 +2317,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t this.  If we can prove that the array can never be superflat,\n \t\t we can just use the high bound of the index type.  */\n \t      else if ((Nkind (gnat_index) == N_Range\n-\t\t        && cannot_be_superflat_p (gnat_index))\n+\t\t        && cannot_be_superflat (gnat_index))\n \t\t       /* Bit-Packed Array Impl. Types are never superflat.  */\n \t\t       || (Is_Packed_Array_Impl_Type (gnat_entity)\n \t\t\t   && Is_Bit_Packed_Array\n@@ -5821,7 +5804,7 @@ compile_time_known_address_p (Node_Id gnat_address)\n    inequality HB >= LB-1 is true.  LB and HB are the low and high bounds.  */\n \n static bool\n-cannot_be_superflat_p (Node_Id gnat_range)\n+cannot_be_superflat (Node_Id gnat_range)\n {\n   Node_Id gnat_lb = Low_Bound (gnat_range), gnat_hb = High_Bound (gnat_range);\n   Node_Id scalar_range;\n@@ -5877,6 +5860,57 @@ constructor_address_p (tree gnu_expr)\n   return (TREE_CODE (gnu_expr) == ADDR_EXPR\n \t  && TREE_CODE (TREE_OPERAND (gnu_expr, 0)) == CONSTRUCTOR);\n }\n+\n+/* Return true if the size in units represented by GNU_SIZE can be handled by\n+   an allocation.  If STATIC_P is true, consider only what can be done with a\n+   static allocation.  */\n+\n+static bool\n+allocatable_size_p (tree gnu_size, bool static_p)\n+{\n+  /* We can allocate a fixed size if it is a valid for the middle-end.  */\n+  if (TREE_CODE (gnu_size) == INTEGER_CST)\n+    return valid_constant_size_p (gnu_size);\n+\n+  /* We can allocate a variable size if this isn't a static allocation.  */\n+  else\n+    return !static_p;\n+}\n+\n+/* Return true if GNU_EXPR needs a conversion to GNU_TYPE when used as the\n+   initial value of an object of GNU_TYPE.  */\n+\n+static bool\n+initial_value_needs_conversion (tree gnu_type, tree gnu_expr)\n+{\n+  /* Do not convert if the object's type is unconstrained because this would\n+     generate useless evaluations of the CONSTRUCTOR to compute the size.  */\n+  if (TREE_CODE (gnu_type) == UNCONSTRAINED_ARRAY_TYPE\n+      || CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type)))\n+    return false;\n+\n+  /* Do not convert if the object's type is a padding record whose field is of\n+     self-referential size because we want to copy only the actual data.  */\n+  if (type_is_padding_self_referential (gnu_type))\n+    return false;\n+\n+  /* Do not convert a call to a function that returns with variable size since\n+     we want to use the return slot optimization in this case.  */\n+  if (TREE_CODE (gnu_expr) == CALL_EXPR\n+      && return_type_with_variable_size_p (TREE_TYPE (gnu_expr)))\n+    return false;\n+\n+  /* Do not convert to a record type with a variant part from a record type\n+     without one, to keep the object simpler.  */\n+  if (TREE_CODE (gnu_type) == RECORD_TYPE\n+      && TREE_CODE (TREE_TYPE (gnu_expr)) == RECORD_TYPE\n+      && get_variant_part (gnu_type) != NULL_TREE\n+      && get_variant_part (TREE_TYPE (gnu_expr)) == NULL_TREE)\n+    return false;\n+\n+  /* In all the other cases, convert the expression to the object's type.  */\n+  return true;\n+}\n \f\n /* Given GNAT_ENTITY, elaborate all expressions that are required to\n    be elaborated at the point of its definition, but do nothing else.  */\n@@ -5935,22 +5969,6 @@ elaborate_entity (Entity_Id gnat_entity)\n     }\n }\n \f\n-/* Return true if the size in units represented by GNU_SIZE can be handled by\n-   an allocation.  If STATIC_P is true, consider only what can be done with a\n-   static allocation.  */\n-\n-static bool\n-allocatable_size_p (tree gnu_size, bool static_p)\n-{\n-  /* We can allocate a fixed size if it is a valid for the middle-end.  */\n-  if (TREE_CODE (gnu_size) == INTEGER_CST)\n-    return valid_constant_size_p (gnu_size);\n-\n-  /* We can allocate a variable size if this isn't a static allocation.  */\n-  else\n-    return !static_p;\n-}\n-\f\n /* Prepend to ATTR_LIST an entry for an attribute with provided TYPE,\n    NAME, ARGS and ERROR_POINT.  */\n \n@@ -6224,12 +6242,13 @@ struct er_data\n {\n   Entity_Id entity;\n   bool definition;\n+  unsigned int n;\n };\n \n /* Wrapper function around elaborate_expression_1 for elaborate_reference.  */\n \n static tree\n-elaborate_reference_1 (tree ref, void *data, int n)\n+elaborate_reference_1 (tree ref, void *data)\n {\n   struct er_data *er = (struct er_data *)data;\n   char suffix[16];\n@@ -6244,22 +6263,24 @@ elaborate_reference_1 (tree ref, void *data, int n)\n   if (TREE_CODE (ref) == COMPONENT_REF\n       && TYPE_IS_FAT_POINTER_P (TREE_TYPE (TREE_OPERAND (ref, 0))))\n     return build3 (COMPONENT_REF, TREE_TYPE (ref),\n-\t\t   elaborate_reference_1 (TREE_OPERAND (ref, 0), data, n),\n+\t\t   elaborate_reference_1 (TREE_OPERAND (ref, 0), data),\n \t\t   TREE_OPERAND (ref, 1), TREE_OPERAND (ref, 2));\n \n-  sprintf (suffix, \"EXP%d\", n);\n+  sprintf (suffix, \"EXP%d\", ++er->n);\n   return\n     elaborate_expression_1 (ref, er->entity, suffix, er->definition, false);\n }\n \n /* Elaborate the reference REF to be used as renamed object for GNAT_ENTITY.\n-   DEFINITION is true if this is done for a definition of GNAT_ENTITY.  */\n+   DEFINITION is true if this is done for a definition of GNAT_ENTITY and\n+   INIT is set to the first arm of a COMPOUND_EXPR present in REF, if any.  */\n \n static tree\n-elaborate_reference (tree ref, Entity_Id gnat_entity, bool definition)\n+elaborate_reference (tree ref, Entity_Id gnat_entity, bool definition,\n+\t\t     tree *init)\n {\n-  struct er_data er = { gnat_entity, definition };\n-  return gnat_rewrite_reference (ref, elaborate_reference_1, &er);\n+  struct er_data er = { gnat_entity, definition, 0 };\n+  return gnat_rewrite_reference (ref, elaborate_reference_1, &er, init);\n }\n \f\n /* Given a GNU tree and a GNAT list of choices, generate an expression to test"}, {"sha": "65f871bf89594defc6c640a53ea04d623f2ef75b", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=fc7a823e1507110aba804cf94415155a8783e698", "patch": "@@ -959,16 +959,16 @@ extern tree gnat_protect_expr (tree exp);\n \n /* This is equivalent to stabilize_reference in tree.c but we know how to\n    handle our own nodes and we take extra arguments.  FORCE says whether to\n-   force evaluation of everything.  */\n-extern tree gnat_stabilize_reference (tree ref, bool force);\n+   force evaluation of everything in REF.  INIT is set to the first arm of\n+   a COMPOUND_EXPR present in REF, if any.  */\n+extern tree gnat_stabilize_reference (tree ref, bool force, tree *init);\n \n /* Rewrite reference REF and call FUNC on each expression within REF in the\n-   process.  DATA is passed unmodified to FUNC and N is bumped each time it\n-   is passed to FUNC, so FUNC is guaranteed to see a given N only once per\n-   reference to be rewritten.  */\n-typedef tree (*rewrite_fn) (tree, void *, int);\n+   process.  DATA is passed unmodified to FUNC.  INIT is set to the first\n+   arm of a COMPOUND_EXPR present in REF, if any.  */\n+typedef tree (*rewrite_fn) (tree, void *);\n extern tree gnat_rewrite_reference (tree ref, rewrite_fn func, void *data,\n-\t\t\t\t    int n = 1);\n+\t\t\t\t    tree *init);\n \n /* This is equivalent to get_inner_reference in expr.c but it returns the\n    ultimate containing object only if the reference (lvalue) is constant,\n@@ -1085,3 +1085,30 @@ call_is_atomic_load (tree exp)\n   enum built_in_function code = DECL_FUNCTION_CODE (fndecl);\n   return BUILT_IN_ATOMIC_LOAD_N <= code && code <= BUILT_IN_ATOMIC_LOAD_16;\n }\n+\n+/* Return true if TYPE is padding a self-referential type.  */\n+\n+static inline bool\n+type_is_padding_self_referential (tree type)\n+{\n+  if (!TYPE_IS_PADDING_P (type))\n+    return false;\n+\n+  return CONTAINS_PLACEHOLDER_P (DECL_SIZE (TYPE_FIELDS (type)));\n+}\n+\n+/* Return true if a function returning TYPE doesn't return a fixed size.  */\n+\n+static inline bool\n+return_type_with_variable_size_p (tree type)\n+{\n+  if (TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+    return true;\n+\n+  /* Return true for an unconstrained type with default discriminant, see\n+     the E_Subprogram_Type case of gnat_to_gnu_entity.  */\n+  if (type_is_padding_self_referential (type))\n+    return true;\n+\n+  return false;\n+}"}, {"sha": "0750051b6a08e413ceb51c2b127556d57667dc04", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=fc7a823e1507110aba804cf94415155a8783e698", "patch": "@@ -4189,9 +4189,9 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t  because we need to preserve the return value before copying back the\n \t  parameters.\n \n-       2. There is no target and this is not an object declaration, and the\n-\t  return type has variable size, because in these cases the gimplifier\n-\t  cannot create the temporary.\n+       2. There is no target and this is neither an object nor a renaming\n+\t  declaration, and the return type has variable size, because in\n+\t  these cases the gimplifier cannot create the temporary.\n \n        3. There is a target and it is a slice or an array with fixed size,\n \t  and the return type has variable size, because the gimplifier\n@@ -4203,6 +4203,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n       && ((!gnu_target && TYPE_CI_CO_LIST (gnu_subprog_type))\n \t  || (!gnu_target\n \t      && Nkind (Parent (gnat_node)) != N_Object_Declaration\n+\t      && Nkind (Parent (gnat_node)) != N_Object_Renaming_Declaration\n \t      && TREE_CODE (TYPE_SIZE (gnu_result_type)) != INTEGER_CST)\n \t  || (gnu_target\n \t      && (TREE_CODE (gnu_target) == ARRAY_RANGE_REF\n@@ -4258,7 +4259,13 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n       if (Ekind (gnat_formal) != E_In_Parameter\n \t  && !is_by_ref_formal_parm\n \t  && TREE_CODE (gnu_name) != NULL_EXPR)\n-\tgnu_name = gnat_stabilize_reference (gnu_name, true);\n+\t{\n+\t  tree init = NULL_TREE;\n+\t  gnu_name = gnat_stabilize_reference (gnu_name, true, &init);\n+\t  if (init)\n+\t    gnu_name\n+\t      = build_compound_expr (TREE_TYPE (gnu_name), init, gnu_name);\n+\t}\n \n       /* If we are passing a non-addressable parameter by reference, pass the\n \t address of a copy.  In the Out or In Out case, set up to copy back\n@@ -4724,12 +4731,8 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \n \t  /* ??? If the return type has variable size, then force the return\n \t     slot optimization as we would not be able to create a temporary.\n-\t     Likewise if it was unconstrained as we would copy too much data.\n \t     That's what has been done historically.  */\n-\t  if (TREE_CODE (TYPE_SIZE (gnu_result_type)) != INTEGER_CST\n-\t      || (TYPE_IS_PADDING_P (gnu_result_type)\n-\t\t  && CONTAINS_PLACEHOLDER_P\n-\t\t     (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS (gnu_result_type))))))\n+\t  if (return_type_with_variable_size_p (gnu_result_type))\n \t    op_code = INIT_EXPR;\n \t  else\n \t    op_code = MODIFY_EXPR;\n@@ -6802,10 +6805,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    /* Do not remove the padding from GNU_RET_VAL if the inner type is\n \t       self-referential since we want to allocate the fixed size.  */\n \t    if (TREE_CODE (gnu_ret_val) == COMPONENT_REF\n-\t\t&& TYPE_IS_PADDING_P\n-\t\t   (TREE_TYPE (TREE_OPERAND (gnu_ret_val, 0)))\n-\t\t&& CONTAINS_PLACEHOLDER_P\n-\t\t   (TYPE_SIZE (TREE_TYPE (gnu_ret_val))))\n+\t\t&& type_is_padding_self_referential\n+\t\t   (TREE_OPERAND (gnu_ret_val, 0)))\n \t      gnu_ret_val = TREE_OPERAND (gnu_ret_val, 0);\n \n \t    /* If the function returns by direct reference, return a pointer\n@@ -7486,7 +7487,7 @@ gnat_to_gnu (Node_Id gnat_node)\n      actual returned object.  We must do this before any conversions.  */\n   if (TREE_SIDE_EFFECTS (gnu_result)\n       && !(TREE_CODE (gnu_result) == CALL_EXPR\n-\t   && TYPE_IS_PADDING_P (TREE_TYPE (gnu_result)))\n+\t   && type_is_padding_self_referential (TREE_TYPE (gnu_result)))\n       && (TREE_CODE (gnu_result_type) == UNCONSTRAINED_ARRAY_TYPE\n \t  || CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_result_type))))\n     gnu_result = gnat_protect_expr (gnu_result);\n@@ -7512,9 +7513,10 @@ gnat_to_gnu (Node_Id gnat_node)\n        3. If the type is void or if we have no result, return error_mark_node\n \t  to show we have no result.\n \n-       4. If this a call to a function that returns an unconstrained type with\n-\t  default discriminant, return the call expression unmodified since we\n-\t  cannot compute the size of the actual returned object.\n+       4. If this is a call to a function that returns with variable size and\n+\t  the call is used as the expression in either an object or a renaming\n+\t  declaration, return the result unmodified because we want to use the\n+\t  return slot optimization in this case.\n \n        5. Finally, if the type of the result is already correct.  */\n \n@@ -7543,9 +7545,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t size: in that case it must be an object of unconstrained type\n \t with a default discriminant and we want to avoid copying too\n \t much data.  */\n-      if (TYPE_IS_PADDING_P (TREE_TYPE (gnu_result))\n-\t  && CONTAINS_PLACEHOLDER_P (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS\n-\t\t\t\t     (TREE_TYPE (gnu_result))))))\n+      if (type_is_padding_self_referential (TREE_TYPE (gnu_result)))\n \tgnu_result = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_result))),\n \t\t\t      gnu_result);\n     }\n@@ -7567,11 +7567,11 @@ gnat_to_gnu (Node_Id gnat_node)\n   else if (gnu_result == error_mark_node || gnu_result_type == void_type_node)\n     gnu_result = error_mark_node;\n \n-  else if (TREE_CODE (gnu_result) == CALL_EXPR\n-\t   && TYPE_IS_PADDING_P (TREE_TYPE (gnu_result))\n-\t   && TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_result)))\n-\t      == gnu_result_type\n-\t   && CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_result_type)))\n+  else if (Present (Parent (gnat_node))\n+\t   && (Nkind (Parent (gnat_node)) == N_Object_Declaration\n+\t       || Nkind (Parent (gnat_node)) == N_Object_Renaming_Declaration)\n+\t   && TREE_CODE (gnu_result) == CALL_EXPR\n+\t   && return_type_with_variable_size_p (TREE_TYPE (gnu_result)))\n     ;\n \n   else if (TREE_TYPE (gnu_result) != gnu_result_type)"}, {"sha": "cc2c645ff4886aa741e8861ee60da01b8fab2fc2", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=fc7a823e1507110aba804cf94415155a8783e698", "patch": "@@ -923,13 +923,10 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t    operation_type = left_type;\n \t}\n \n-      /* If we have a call to a function that returns an unconstrained type\n-\t with default discriminant on the RHS, use the RHS type (which is\n-\t padded) as we cannot compute the size of the actual assignment.  */\n+      /* If we have a call to a function that returns with variable size, use\n+\t the RHS type in case we want to use the return slot optimization.  */\n       else if (TREE_CODE (right_operand) == CALL_EXPR\n-\t       && TYPE_IS_PADDING_P (right_type)\n-\t       && CONTAINS_PLACEHOLDER_P\n-\t\t  (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS (right_type)))))\n+\t       && return_type_with_variable_size_p (right_type))\n \toperation_type = right_type;\n \n       /* Find the best type to use for copying between aggregate types.  */\n@@ -1420,10 +1417,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t      /* If INNER is a padding type whose field has a self-referential\n \t\t size, convert to that inner type.  We know the offset is zero\n \t\t and we need to have that type visible.  */\n-\t      if (TYPE_IS_PADDING_P (TREE_TYPE (inner))\n-\t\t  && CONTAINS_PLACEHOLDER_P\n-\t\t     (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS\n-\t\t\t\t\t    (TREE_TYPE (inner))))))\n+\t      if (type_is_padding_self_referential (TREE_TYPE (inner)))\n \t\tinner = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (inner))),\n \t\t\t\t inner);\n \n@@ -2663,7 +2657,7 @@ gnat_protect_expr (tree exp)\n    argument to force evaluation of everything.  */\n \n static tree\n-gnat_stabilize_reference_1 (tree e, void *data, int n)\n+gnat_stabilize_reference_1 (tree e, void *data)\n {\n   const bool force = *(bool *)data;\n   enum tree_code code = TREE_CODE (e);\n@@ -2688,7 +2682,7 @@ gnat_stabilize_reference_1 (tree e, void *data, int n)\n \t  && TYPE_IS_FAT_POINTER_P (TREE_TYPE (TREE_OPERAND (e, 0))))\n \tresult\n \t  = build3 (code, type,\n-\t\t    gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), data, n),\n+\t\t    gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), data),\n \t\t    TREE_OPERAND (e, 1), TREE_OPERAND (e, 2));\n       /* If the expression has side-effects, then encase it in a SAVE_EXPR\n \t so that it will only be evaluated once.  */\n@@ -2704,15 +2698,15 @@ gnat_stabilize_reference_1 (tree e, void *data, int n)\n       /* Recursively stabilize each operand.  */\n       result\n \t= build2 (code, type,\n-\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), data, n),\n-\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (e, 1), data, n));\n+\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), data),\n+\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (e, 1), data));\n       break;\n \n     case tcc_unary:\n       /* Recursively stabilize each operand.  */\n       result\n \t= build1 (code, type,\n-\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), data, n));\n+\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), data));\n       break;\n \n     default:\n@@ -2728,21 +2722,22 @@ gnat_stabilize_reference_1 (tree e, void *data, int n)\n \n /* This is equivalent to stabilize_reference in tree.c but we know how to\n    handle our own nodes and we take extra arguments.  FORCE says whether to\n-   force evaluation of everything.  */\n+   force evaluation of everything in REF.  INIT is set to the first arm of\n+   a COMPOUND_EXPR present in REF, if any.  */\n \n tree\n-gnat_stabilize_reference (tree ref, bool force)\n+gnat_stabilize_reference (tree ref, bool force, tree *init)\n {\n-  return gnat_rewrite_reference (ref, gnat_stabilize_reference_1, &force);\n+  return\n+    gnat_rewrite_reference (ref, gnat_stabilize_reference_1, &force, init);\n }\n \n /* Rewrite reference REF and call FUNC on each expression within REF in the\n-   process.  DATA is passed unmodified to FUNC and N is bumped each time it\n-   is passed to FUNC, so FUNC is guaranteed to see a given N only once per\n-   reference to be rewritten.  */\n+   process.  DATA is passed unmodified to FUNC.  INIT is set to the first\n+   arm of a COMPOUND_EXPR present in REF, if any.  */\n \n tree\n-gnat_rewrite_reference (tree ref, rewrite_fn func, void *data, int n)\n+gnat_rewrite_reference (tree ref, rewrite_fn func, void *data, tree *init)\n {\n   tree type = TREE_TYPE (ref);\n   enum tree_code code = TREE_CODE (ref);\n@@ -2764,25 +2759,25 @@ gnat_rewrite_reference (tree ref, rewrite_fn func, void *data, int n)\n       result\n \t= build1 (code, type,\n \t\t  gnat_rewrite_reference (TREE_OPERAND (ref, 0), func, data,\n-\t\t\t\t\t  n));\n+\t\t\t\t\t  init));\n       break;\n \n     case INDIRECT_REF:\n     case UNCONSTRAINED_ARRAY_REF:\n-      result = build1 (code, type, func (TREE_OPERAND (ref, 0), data, n));\n+      result = build1 (code, type, func (TREE_OPERAND (ref, 0), data));\n       break;\n \n     case COMPONENT_REF:\n       result = build3 (COMPONENT_REF, type,\n \t\t       gnat_rewrite_reference (TREE_OPERAND (ref, 0), func,\n-\t\t\t\t\t       data, n),\n+\t\t\t\t\t       data, init),\n \t\t       TREE_OPERAND (ref, 1), NULL_TREE);\n       break;\n \n     case BIT_FIELD_REF:\n       result = build3 (BIT_FIELD_REF, type,\n \t\t       gnat_rewrite_reference (TREE_OPERAND (ref, 0), func,\n-\t\t\t\t\t       data, n),\n+\t\t\t\t\t       data, init),\n \t\t       TREE_OPERAND (ref, 1), TREE_OPERAND (ref, 2));\n       break;\n \n@@ -2791,11 +2786,18 @@ gnat_rewrite_reference (tree ref, rewrite_fn func, void *data, int n)\n       result\n \t= build4 (code, type,\n \t\t  gnat_rewrite_reference (TREE_OPERAND (ref, 0), func, data,\n-\t\t\t\t\t  n + 1),\n-\t\t  func (TREE_OPERAND (ref, 1), data, n),\n+\t\t\t\t\t  init),\n+\t\t  func (TREE_OPERAND (ref, 1), data),\n \t\t  TREE_OPERAND (ref, 2), TREE_OPERAND (ref, 3));\n       break;\n \n+    case COMPOUND_EXPR:\n+      gcc_assert (*init == NULL_TREE);\n+      *init = TREE_OPERAND (ref, 0);\n+      /* We expect only the pattern built in Call_to_gnu.  */\n+      gcc_assert (DECL_P (TREE_OPERAND (ref, 1)));\n+      return TREE_OPERAND (ref, 1);\n+\n     case CALL_EXPR:\n       {\n \t/* This can only be an atomic load.  */\n@@ -2808,9 +2810,9 @@ gnat_rewrite_reference (tree ref, rewrite_fn func, void *data, int n)\n \tif (TREE_CODE (t) == ADDR_EXPR)\n \t  t = build1 (ADDR_EXPR, TREE_TYPE (t),\n \t\t      gnat_rewrite_reference (TREE_OPERAND (t, 0), func, data,\n-\t\t\t\t\t      n));\n+\t\t\t\t\t      init));\n \telse\n-\t  t = func (t, data, n);\n+\t  t = func (t, data);\n \tt = fold_convert (TREE_TYPE (CALL_EXPR_ARG (ref, 0)), t);\n \n \tresult = build_call_expr (TREE_OPERAND (CALL_EXPR_FN (ref), 0), 2,"}, {"sha": "282a3bebf0c828ce2c32a43c40f79c652eaddfa5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fc7a823e1507110aba804cf94415155a8783e698", "patch": "@@ -1,3 +1,19 @@\n+2015-05-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/varsize_temp.adb: Rename into...\n+\t* gnat.dg/varsize1.adb: ...this.\n+\t* gnat.dg/varsize_copy.ad[sb]: Rename into...\n+\t* gnat.dg/varsize2.ad[sb]: ...this.\n+\t* gnat.dg/varsize3_1.adb: New test.\n+\t* gnat.dg/varsize3_2.adb: Likewise.\n+\t* gnat.dg/varsize3_3.adb: Likewise.\n+\t* gnat.dg/varsize3_4.adb: Likewise.\n+\t* gnat.dg/varsize3_5.adb: Likewise.\n+\t* gnat.dg/varsize3_6.adb: Likewise.\n+\t* gnat.dg/varsize3_pkg1.ads: New helper.\n+\t* gnat.dg/varsize3_pkg2.ads: Likewise.\n+\t* gnat.dg/varsize3_pkg3.ads: Likewise.\n+\n 2015-05-28  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.dg/vect/slp-reduc-sad.c: New testcase."}, {"sha": "55ee34a500f1df7fc2ed3657f345ba99304ebf41", "filename": "gcc/testsuite/gnat.dg/varsize1.adb", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize1.adb?ref=fc7a823e1507110aba804cf94415155a8783e698", "patch": "@@ -1,6 +1,6 @@\n -- { dg-do compile }\n \n-procedure Varsize_Temp (Nbytes : Natural) is\n+procedure Varsize1 (Nbytes : Natural) is\n \n    type Message_T (Length : Natural) is record\n       case Length is\n@@ -25,5 +25,3 @@ procedure Varsize_Temp (Nbytes : Natural) is\n begin\n    Process (One_Message);\n end;\n-\n-", "previous_filename": "gcc/testsuite/gnat.dg/varsize_temp.adb"}, {"sha": "70a5b0629719e613fb6a44c3b1ee5dec5c8b7f9f", "filename": "gcc/testsuite/gnat.dg/varsize2.adb", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize2.adb?ref=fc7a823e1507110aba804cf94415155a8783e698", "patch": "@@ -1,7 +1,7 @@\n -- { dg-do compile }\n -- { dg-options \"-O -gnatws\" }\n \n-package body Varsize_Copy is\n+package body Varsize2 is\n \n    type Key_Mapping_Type is record\n       Page : Page_Type;\n@@ -21,4 +21,4 @@ package body Varsize_Copy is\n       return S.Key_Mappings (Key).Page;\n    end;\n \n-end Varsize_Copy;\n+end Varsize2;", "previous_filename": "gcc/testsuite/gnat.dg/varsize_copy.adb"}, {"sha": "d9ec1cc3b630f854c99c5a9a74bad02b12d0de40", "filename": "gcc/testsuite/gnat.dg/varsize2.ads", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize2.ads?ref=fc7a823e1507110aba804cf94415155a8783e698", "patch": "@@ -1,4 +1,4 @@\n-package Varsize_Copy is\n+package Varsize2 is\n \n    type Key_Type is\n       (Nul, Cntrl, Stx, Etx, Eot, Enq, Ack, Spad, Clr, Dc_1, Dc_2, Dc_3, Dc_4);\n@@ -27,4 +27,4 @@ package Varsize_Copy is\n \n    function F (Key : Key_Type) return Page_Type;\n \n-end Varsize_Copy;\n+end Varsize2;", "previous_filename": "gcc/testsuite/gnat.dg/varsize_copy.ads"}, {"sha": "841f2cf3ddcb04b135a40e581e140d828a0ed286", "filename": "gcc/testsuite/gnat.dg/varsize3_1.adb", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_1.adb?ref=fc7a823e1507110aba804cf94415155a8783e698", "patch": "@@ -0,0 +1,5 @@\n+-- { dg-do compile }\n+\n+package body Varsize3_1 is\n+\n+end Varsize3_1;"}, {"sha": "16195c24d96af102f3e680d9e7d1c7c776e795d5", "filename": "gcc/testsuite/gnat.dg/varsize3_1.ads", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_1.ads?ref=fc7a823e1507110aba804cf94415155a8783e698", "patch": "@@ -0,0 +1,9 @@\n+with Varsize3_Pkg1; use Varsize3_Pkg1;\n+\n+package Varsize3_1 is\n+\n+  pragma Elaborate_Body;\n+\n+  Filter : constant Object := True;\n+\n+end Varsize3_1;"}, {"sha": "7e565d2c15db5b214e0c40b7dd22764bb479fadb", "filename": "gcc/testsuite/gnat.dg/varsize3_2.adb", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_2.adb?ref=fc7a823e1507110aba804cf94415155a8783e698", "patch": "@@ -0,0 +1,11 @@\n+-- { dg-do compile }\n+\n+with Varsize3_Pkg1; use Varsize3_Pkg1;\n+\n+procedure Varsize3_2 is\n+\n+  Filter : constant Object := True;\n+\n+begin\n+  null;\n+end;"}, {"sha": "a08db64d86256d6798369aa83b6a766267fb13b1", "filename": "gcc/testsuite/gnat.dg/varsize3_3.adb", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_3.adb?ref=fc7a823e1507110aba804cf94415155a8783e698", "patch": "@@ -0,0 +1,11 @@\n+-- { dg-do compile }\n+\n+with Varsize3_Pkg1; use Varsize3_Pkg1;\n+\n+procedure Varsize3_3 is\n+\n+  Filter : Object;\n+\n+begin\n+  Filter := True;\n+end;"}, {"sha": "fe193740968f886b236a259f13da954d316f9af4", "filename": "gcc/testsuite/gnat.dg/varsize3_4.adb", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_4.adb?ref=fc7a823e1507110aba804cf94415155a8783e698", "patch": "@@ -0,0 +1,11 @@\n+-- { dg-do compile }\n+\n+with Varsize3_Pkg1; use Varsize3_Pkg1;\n+\n+procedure Varsize3_4 is\n+\n+  Filter : Object renames True;\n+\n+begin\n+  null;\n+end;"}, {"sha": "2fd44c0893ef63963c759e6536a9cceac9d4ed65", "filename": "gcc/testsuite/gnat.dg/varsize3_5.adb", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_5.adb?ref=fc7a823e1507110aba804cf94415155a8783e698", "patch": "@@ -0,0 +1,11 @@\n+-- { dg-do compile }\n+\n+with Varsize3_Pkg1; use Varsize3_Pkg1;\n+\n+procedure Varsize3_5 is\n+\n+  Filter : constant Arr := True.E;\n+\n+begin\n+  null;\n+end;"}, {"sha": "423e5082429cd3390f03da0043c7307944a14348", "filename": "gcc/testsuite/gnat.dg/varsize3_6.adb", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_6.adb?ref=fc7a823e1507110aba804cf94415155a8783e698", "patch": "@@ -0,0 +1,11 @@\n+-- { dg-do compile }\n+\n+with Varsize3_Pkg1; use Varsize3_Pkg1;\n+\n+procedure Varsize3_6 is\n+\n+  Filter : Arr renames True.E;\n+\n+begin\n+  null;\n+end;"}, {"sha": "ac12b39e9dc248ffbc911fc38e93e7f6d80f7843", "filename": "gcc/testsuite/gnat.dg/varsize3_pkg1.ads", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_pkg1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_pkg1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_pkg1.ads?ref=fc7a823e1507110aba804cf94415155a8783e698", "patch": "@@ -0,0 +1,12 @@\n+with Varsize3_Pkg2;\n+with Varsize3_Pkg3;\n+\n+package Varsize3_Pkg1 is\n+\n+   type Arr is array (Positive range 1 .. Varsize3_Pkg2.Last_Index) of Boolean;\n+\n+   package My_G is new Varsize3_Pkg3 (Arr);\n+\n+   type Object is new My_G.Object;\n+\n+end Varsize3_Pkg1;"}, {"sha": "980c9bdcb89e02e63a8850125de28e9a52ec055c", "filename": "gcc/testsuite/gnat.dg/varsize3_pkg2.ads", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_pkg2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_pkg2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_pkg2.ads?ref=fc7a823e1507110aba804cf94415155a8783e698", "patch": "@@ -0,0 +1,5 @@\n+package Varsize3_Pkg2 is\n+\n+   function Last_Index return Positive;\n+\n+end Varsize3_Pkg2;"}, {"sha": "0cc80e3dbfb7bd11d001737117faadaaa6ccd026", "filename": "gcc/testsuite/gnat.dg/varsize3_pkg3.ads", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_pkg3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7a823e1507110aba804cf94415155a8783e698/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_pkg3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvarsize3_pkg3.ads?ref=fc7a823e1507110aba804cf94415155a8783e698", "patch": "@@ -0,0 +1,13 @@\n+generic\n+\n+   type T is private;\n+\n+package Varsize3_Pkg3 is\n+\n+   type Object is record\n+      E : T;\n+   end record;\n+\n+   function True return Object;\n+\n+end Varsize3_Pkg3;"}]}