{"sha": "8c5b03a08edcee621c86f18bf0c1eb829ea3d12c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM1YjAzYTA4ZWRjZWU2MjFjODZmMThiZjBjMWViODI5ZWEzZDEyYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-01T10:48:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-01T10:48:23Z"}, "message": "[multiple changes]\n\n2011-09-01  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch7.adb (Find_Insertion_List): New routine.\n\t(Process_Transient_Objects): Add code to handle the abnormal\n\tfinalization of a controlled transient associated with a subprogram\n\tcall. Since transients are cleaned up right after the associated\n\tcontext, an exception raised during a subprogram call may bypass the\n\tfinalization code.\n\n2011-09-01  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch6.adb (Expand_Call): Check actual for aliased parameter is\n\taliased.\n\nFrom-SVN: r178403", "tree": {"sha": "cd0809cd44f2c936033a9381e9cc67d622d5ade1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd0809cd44f2c936033a9381e9cc67d622d5ade1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c5b03a08edcee621c86f18bf0c1eb829ea3d12c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c5b03a08edcee621c86f18bf0c1eb829ea3d12c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c5b03a08edcee621c86f18bf0c1eb829ea3d12c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c5b03a08edcee621c86f18bf0c1eb829ea3d12c/comments", "author": null, "committer": null, "parents": [{"sha": "3040dbd48e3f11838cbe6e7d21524f903f7d3a01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3040dbd48e3f11838cbe6e7d21524f903f7d3a01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3040dbd48e3f11838cbe6e7d21524f903f7d3a01"}], "stats": {"total": 245, "additions": 204, "deletions": 41}, "files": [{"sha": "ca4fecd279e666ec438a7e01875c48b619cc16d9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c5b03a08edcee621c86f18bf0c1eb829ea3d12c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c5b03a08edcee621c86f18bf0c1eb829ea3d12c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8c5b03a08edcee621c86f18bf0c1eb829ea3d12c", "patch": "@@ -1,3 +1,17 @@\n+2011-09-01  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch7.adb (Find_Insertion_List): New routine.\n+\t(Process_Transient_Objects): Add code to handle the abnormal\n+\tfinalization of a controlled transient associated with a subprogram\n+\tcall. Since transients are cleaned up right after the associated\n+\tcontext, an exception raised during a subprogram call may bypass the\n+\tfinalization code.\n+\n+2011-09-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Call): Check actual for aliased parameter is\n+\taliased.\n+\n 2011-09-01  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch4.adb, a-exexda.adb: Minor reformatting."}, {"sha": "f9b3ae5993036f9a473ac0af9ea1e161d42cca2c", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c5b03a08edcee621c86f18bf0c1eb829ea3d12c/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c5b03a08edcee621c86f18bf0c1eb829ea3d12c/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=8c5b03a08edcee621c86f18bf0c1eb829ea3d12c", "patch": "@@ -2208,8 +2208,8 @@ package body Exp_Ch6 is\n       --  as we go through the loop, since this is a convenient place to do it.\n       --  (Though it seems that this would be better done in Expand_Actuals???)\n \n-      Formal      := First_Formal (Subp);\n-      Actual      := First_Actual (Call_Node);\n+      Formal := First_Formal (Subp);\n+      Actual := First_Actual (Call_Node);\n       Param_Count := 1;\n       while Present (Formal) loop\n \n@@ -2235,7 +2235,7 @@ package body Exp_Ch6 is\n            CW_Interface_Formals_Present\n              or else\n                (Ekind (Etype (Formal)) = E_Class_Wide_Type\n-                  and then Is_Interface (Etype (Etype (Formal))))\n+                 and then Is_Interface (Etype (Etype (Formal))))\n              or else\n                (Ekind (Etype (Formal)) = E_Anonymous_Access_Type\n                  and then Is_Interface (Directly_Designated_Type\n@@ -2616,6 +2616,15 @@ package body Exp_Ch6 is\n             end if;\n          end if;\n \n+         --  For Ada 2012, if a parameter is aliased, the actual must be an\n+         --  aliased object.\n+\n+         if Is_Aliased (Formal) and then not Is_Aliased_View (Actual) then\n+            Error_Msg_NE\n+              (\"actual for aliased formal& must be aliased object\",\n+               Actual, Formal);\n+         end if;\n+\n          --  For IN OUT and OUT parameters, ensure that subscripts are valid\n          --  since this is a left side reference. We only do this for calls\n          --  from the source program since we assume that compiler generated\n@@ -2667,9 +2676,7 @@ package body Exp_Ch6 is\n                --  or IN OUT parameter! We do reset the Is_Known_Valid flag\n                --  since the subprogram could have returned in invalid value.\n \n-               if (Ekind (Formal) = E_Out_Parameter\n-                     or else\n-                   Ekind (Formal) = E_In_Out_Parameter)\n+               if Ekind_In (Formal, E_Out_Parameter, E_In_Out_Parameter)\n                  and then Is_Assignable (Ent)\n                then\n                   Sav := Last_Assignment (Ent);"}, {"sha": "30abe6c9e6218cb1d0a46e283a16a1e59aefa5f2", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 177, "deletions": 35, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c5b03a08edcee621c86f18bf0c1eb829ea3d12c/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c5b03a08edcee621c86f18bf0c1eb829ea3d12c/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=8c5b03a08edcee621c86f18bf0c1eb829ea3d12c", "patch": "@@ -4198,17 +4198,51 @@ package body Exp_Ch7 is\n          Last_Object  : Node_Id;\n          Related_Node : Node_Id)\n       is\n-         Finalizer_Data  : Finalization_Exception_Data;\n-         Finalizer_Decls : List_Id;\n-         Built           : Boolean := False;\n-         Desig           : Entity_Id;\n-         Fin_Block       : Node_Id;\n-         Last_Fin        : Node_Id := Empty;\n-         Loc             : Source_Ptr;\n-         Obj_Id          : Entity_Id;\n-         Obj_Ref         : Node_Id;\n-         Obj_Typ         : Entity_Id;\n-         Stmt            : Node_Id;\n+         function Find_Insertion_List return List_Id;\n+         --  Return the statement list of the enclosing sequence of statements\n+\n+         -------------------------\n+         -- Find_Insertion_List --\n+         -------------------------\n+\n+         function Find_Insertion_List return List_Id is\n+            Par : Node_Id;\n+\n+         begin\n+            --  Climb up the tree looking for the enclosing sequence of\n+            --  statements.\n+\n+            Par := N;\n+            while Present (Par)\n+              and then Nkind (Par) /= N_Handled_Sequence_Of_Statements\n+            loop\n+               Par := Parent (Par);\n+            end loop;\n+\n+            return Statements (Par);\n+         end Find_Insertion_List;\n+\n+         --  Local variables\n+\n+         Requires_Hooking : constant Boolean :=\n+                              Nkind_In (N, N_Function_Call,\n+                                           N_Procedure_Call_Statement);\n+\n+         Built     : Boolean := False;\n+         Desig_Typ : Entity_Id;\n+         Fin_Block : Node_Id;\n+         Fin_Data  : Finalization_Exception_Data;\n+         Fin_Decls : List_Id;\n+         Last_Fin  : Node_Id := Empty;\n+         Loc       : Source_Ptr;\n+         Obj_Id    : Entity_Id;\n+         Obj_Ref   : Node_Id;\n+         Obj_Typ   : Entity_Id;\n+         Stmt      : Node_Id;\n+         Stmts     : List_Id;\n+         Temp_Id   : Entity_Id;\n+\n+      --  Start of processing for Process_Transient_Objects\n \n       begin\n          --  Examine all objects in the list First_Object .. Last_Object\n@@ -4224,34 +4258,151 @@ package body Exp_Ch7 is\n \n               and then Stmt /= Related_Node\n             then\n-               Loc     := Sloc (Stmt);\n-               Obj_Id  := Defining_Identifier (Stmt);\n-               Obj_Typ := Base_Type (Etype (Obj_Id));\n-               Desig   := Obj_Typ;\n+               Loc       := Sloc (Stmt);\n+               Obj_Id    := Defining_Identifier (Stmt);\n+               Obj_Typ   := Base_Type (Etype (Obj_Id));\n+               Desig_Typ := Obj_Typ;\n \n                Set_Is_Processed_Transient (Obj_Id);\n \n                --  Handle access types\n \n-               if Is_Access_Type (Desig) then\n-                  Desig := Available_View (Designated_Type (Desig));\n+               if Is_Access_Type (Desig_Typ) then\n+                  Desig_Typ := Available_View (Designated_Type (Desig_Typ));\n                end if;\n \n                --  Create the necessary entities and declarations the first\n                --  time around.\n \n                if not Built then\n-                  Finalizer_Decls := New_List;\n-                  Build_Object_Declarations\n-                      (Finalizer_Data, Finalizer_Decls, Loc);\n+                  Fin_Decls := New_List;\n \n-                  Insert_List_Before_And_Analyze\n-                    (First_Object, Finalizer_Decls);\n+                  Build_Object_Declarations (Fin_Data, Fin_Decls, Loc);\n+                  Insert_List_Before_And_Analyze (First_Object, Fin_Decls);\n \n                   Built := True;\n                end if;\n \n+               --  Transient variables associated with subprogram calls need\n+               --  extra processing. These variables are usually created right\n+               --  before the call and finalized immediately after the call.\n+               --  If an exception occurs during the call, the clean up code\n+               --  is skipped due to the sudden change in control and the\n+               --  transient is never finalized.\n+\n+               --  To handle this case, such variables are \"exported\" to the\n+               --  enclosing sequence of statements where their corresponding\n+               --  \"hooks\" are picked up by the finalization machinery.\n+\n+               if Requires_Hooking then\n+                  declare\n+                     Ins_List  : constant List_Id := Find_Insertion_List;\n+                     Expr      : Node_Id;\n+                     Ptr_Decl  : Node_Id;\n+                     Ptr_Id    : Entity_Id;\n+                     Temp_Decl : Node_Id;\n+\n+                  begin\n+                     --  Step 1: Create an access type which provides a\n+                     --  reference to the transient object. Generate:\n+\n+                     --    Ann : access [all] <Desig_Typ>;\n+\n+                     Ptr_Id := Make_Temporary (Loc, 'A');\n+\n+                     Ptr_Decl :=\n+                       Make_Full_Type_Declaration (Loc,\n+                         Defining_Identifier => Ptr_Id,\n+                         Type_Definition     =>\n+                           Make_Access_To_Object_Definition (Loc,\n+                             All_Present        =>\n+                               Ekind (Obj_Typ) = E_General_Access_Type,\n+                             Subtype_Indication =>\n+                               New_Reference_To (Desig_Typ, Loc)));\n+\n+                     --  Step 2: Create a temporary which acts as a hook to\n+                     --  the transient object. Generate:\n+\n+                     --    Temp : Ptr_Id := null;\n+\n+                     Temp_Id := Make_Temporary (Loc, 'T');\n+\n+                     Temp_Decl :=\n+                       Make_Object_Declaration (Loc,\n+                         Defining_Identifier => Temp_Id,\n+                         Object_Definition   =>\n+                           New_Reference_To (Ptr_Id, Loc));\n+\n+                     --  Analyze the access type and the hook declarations\n+\n+                     Prepend_To (Ins_List, Temp_Decl);\n+                     Prepend_To (Ins_List, Ptr_Decl);\n+\n+                     Analyze (Ptr_Decl);\n+                     Analyze (Temp_Decl);\n+\n+                     --  Mark the temporary as a transient hook. This signals\n+                     --  the machinery in Build_Finalizer to recognize this\n+                     --  special case.\n+\n+                     Set_Return_Flag_Or_Transient_Decl (Temp_Id, Stmt);\n+\n+                     --  Step 3: Hook the transient object to the temporary\n+\n+                     if Is_Access_Type (Obj_Typ) then\n+                        Expr :=\n+                          Convert_To (Ptr_Id, New_Reference_To (Obj_Id, Loc));\n+                     else\n+                        Expr :=\n+                          Make_Attribute_Reference (Loc,\n+                            Prefix         => New_Reference_To (Obj_Id, Loc),\n+                            Attribute_Name => Name_Unrestricted_Access);\n+                     end if;\n+\n+                     --  Generate:\n+                     --    Temp := Ptr_Id (Obj_Id);\n+                     --      <or>\n+                     --    Temp := Obj_Id'Unrestricted_Access;\n+\n+                     Insert_After_And_Analyze (Stmt,\n+                       Make_Assignment_Statement (Loc,\n+                         Name       => New_Reference_To (Temp_Id, Loc),\n+                         Expression => Expr));\n+                  end;\n+               end if;\n+\n+               Stmts := New_List;\n+\n+               --  The transient object is about to be finalized by the clean\n+               --  up code following the subprogram call. In order to avoid\n+               --  double finalization, clear the hook.\n+\n+               --  Generate:\n+               --    Temp := null;\n+\n+               if Requires_Hooking then\n+                  Append_To (Stmts,\n+                    Make_Assignment_Statement (Loc,\n+                      Name       => New_Reference_To (Temp_Id, Loc),\n+                      Expression => Make_Null (Loc)));\n+               end if;\n+\n+               --  Generate:\n+               --    [Deep_]Finalize (Obj_Ref);\n+\n+               Obj_Ref := New_Reference_To (Obj_Id, Loc);\n+\n+               if Is_Access_Type (Obj_Typ) then\n+                  Obj_Ref := Make_Explicit_Dereference (Loc, Obj_Ref);\n+               end if;\n+\n+               Append_To (Stmts,\n+                 Make_Final_Call\n+                   (Obj_Ref => Obj_Ref,\n+                    Typ     => Desig_Typ));\n+\n                --  Generate:\n+               --    [Temp := null;]\n                --    begin\n                --       [Deep_]Finalize (Obj_Ref);\n \n@@ -4264,23 +4415,14 @@ package body Exp_Ch7 is\n                --          end if;\n                --    end;\n \n-               Obj_Ref := New_Reference_To (Obj_Id, Loc);\n-\n-               if Is_Access_Type (Obj_Typ) then\n-                  Obj_Ref := Make_Explicit_Dereference (Loc, Obj_Ref);\n-               end if;\n-\n                Fin_Block :=\n                  Make_Block_Statement (Loc,\n                    Handled_Statement_Sequence =>\n                      Make_Handled_Sequence_Of_Statements (Loc,\n-                       Statements => New_List (\n-                         Make_Final_Call\n-                           (Obj_Ref => Obj_Ref,\n-                            Typ     => Desig)),\n-\n+                       Statements => Stmts,\n                        Exception_Handlers => New_List (\n-                         Build_Exception_Handler (Finalizer_Data))));\n+                         Build_Exception_Handler (Fin_Data))));\n+\n                Insert_After_And_Analyze (Last_Object, Fin_Block);\n \n                --  The raise statement must be inserted after all the\n@@ -4345,7 +4487,7 @@ package body Exp_Ch7 is\n            and then Present (Last_Fin)\n          then\n             Insert_After_And_Analyze (Last_Fin,\n-              Build_Raise_Statement (Finalizer_Data));\n+              Build_Raise_Statement (Fin_Data));\n          end if;\n       end Process_Transient_Objects;\n "}]}