{"sha": "8bafc9640f353ff11c0535a03096fb4db9a5bb95", "node_id": "C_kwDOANBUbNoAKDhiYWZjOTY0MGYzNTNmZjExYzA1MzVhMDMwOTZmYjRkYjlhNWJiOTU", "commit": {"author": {"name": "Dimitar Dimitrov", "email": "dimitar@dinux.eu", "date": "2021-08-22T15:49:31Z"}, "committer": {"name": "Dimitar Dimitrov", "email": "dimitar@dinux.eu", "date": "2021-09-25T13:44:54Z"}, "message": "pru: Named address space for R30/R31 I/O access\n\nThe PRU architecture provides single-cycle access to GPIO pins via\nspecial designated CPU registers - R30 and R31. These two registers can\nof course be accessed in C code using inline assembly, but that can be\nintimidating to users.\n\nThe TI proprietary compiler [1] can expose these I/O registers as global\nvolatile registers:\n  volatile register unsigned int __R31;\n\nConsequently, accessing them in user programs is as straightforward as\nusing a regular global variable:\n  __R31 |= (1 << 2);\n\nUnfortunately, global volatile registers are not supported by GCC [2].\nI decided to implement convenient access to __R30 and __R31 using a new\nnamed address space:\n  extern volatile __regio_symbol unsigned int __R30;\nUnlike global registers, volatile global memory variables are well\nsupported in GCC.  Memory writes and reads to the __regio_symbol address\nspace are converted to writes and reads to R30 and R31 CPU registers.\nThe declared variable name determines which of the two registers it is\nrepresenting.\n\nWith an ifdef for the __R30/__R31 declarations, user programs can now\nbe source-compatible with both TI and GCC toolchains.\n\n[1] https://www.ti.com/lit/ug/spruhv7c/spruhv7c.pdf , \"Global Register Variables\"\n[2] https://gcc.gnu.org/ml/gcc-patches/2015-01/msg02241.html\n\ngcc/ChangeLog:\n\n\t* config/pru/constraints.md (Rrio): New constraint.\n\t* config/pru/predicates.md (regio_operand): New predicate.\n\t* config/pru/pru-pragma.c (pru_register_pragmas): Register\n\tthe __regio_symbol address space.\n\t* config/pru/pru-protos.h (pru_symref2ioregno): Declaration.\n\t* config/pru/pru.c (pru_symref2ioregno): New helper function.\n\t(pru_legitimate_address_p): Remove.\n\t(pru_addr_space_legitimate_address_p): Use the address space\n\taware hook variant.\n\t(pru_nongeneric_pointer_addrspace): New helper function.\n\t(pru_insert_attributes): New function to validate __regio_symbol\n\tusage.\n\t(TARGET_INSERT_ATTRIBUTES): New macro.\n\t(TARGET_LEGITIMATE_ADDRESS_P): Remove.\n\t(TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P): New macro.\n\t* config/pru/pru.h (enum reg_class): Add REGIO_REGS class.\n\t* config/pru/pru.md (*regio_readsi): New pattern to read I/O\n\tregisters.\n\t(*regio_nozext_writesi): New pattern to write to I/O registers.\n\t(*regio_zext_write_r30<EQS0:mode>): Ditto.\n\t* doc/extend.texi: Document the new PRU Named Address Space.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/pru/regio-as-pointer.c: New negative test.\n\t* gcc.target/pru/regio-as-pointer-2.c: New negative test.\n\t* gcc.target/pru/regio-decl-2.c: New negative test.\n\t* gcc.target/pru/regio-decl-3.c: New negative test.\n\t* gcc.target/pru/regio-decl-4.c: New negative test.\n\t* gcc.target/pru/regio-decl.c: New negative test.\n\t* gcc.target/pru/regio-di.c: New negative test.\n\t* gcc.target/pru/regio-hi.c: New negative test.\n\t* gcc.target/pru/regio-qi.c: New negative test.\n\t* gcc.target/pru/regio.c: New test.\n\t* gcc.target/pru/regio.h: New helper header.\n\nSigned-off-by: Dimitar Dimitrov <dimitar@dinux.eu>", "tree": {"sha": "ffda3f4fc73f0bc39b064deb503937c679570da5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffda3f4fc73f0bc39b064deb503937c679570da5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8bafc9640f353ff11c0535a03096fb4db9a5bb95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bafc9640f353ff11c0535a03096fb4db9a5bb95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bafc9640f353ff11c0535a03096fb4db9a5bb95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bafc9640f353ff11c0535a03096fb4db9a5bb95/comments", "author": null, "committer": null, "parents": [{"sha": "9a4293ed9bdd029dd44d19b412b1cdf12372801e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a4293ed9bdd029dd44d19b412b1cdf12372801e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a4293ed9bdd029dd44d19b412b1cdf12372801e"}], "stats": {"total": 489, "additions": 478, "deletions": 11}, "files": [{"sha": "1e0e703c39491e65f8740a7efb974e58019b66b9", "filename": "gcc/config/pru/constraints.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Fconfig%2Fpru%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Fconfig%2Fpru%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fconstraints.md?ref=8bafc9640f353ff11c0535a03096fb4db9a5bb95", "patch": "@@ -34,6 +34,7 @@\n ;; The following constraints are intended for internal use only:\n ;;  Rmd0, Rms0, Rms1: Registers for MUL instruction operands.\n ;;  Rsib: Jump address register suitable for sibling calls.\n+;;  Rrio: The R30 and R31 I/O registers.\n ;;  M: -255 to 0 (for converting ADD to SUB with suitable UBYTE OP2).\n ;;  N: -32768 to 32767 (16-bit signed integer).\n ;;  O: -128 to 127 (8-bit signed integer).\n@@ -57,6 +58,10 @@\n   \"@internal\n   The multiply source 1 register.\")\n \n+(define_register_constraint \"Rrio\" \"REGIO_REGS\"\n+  \"@internal\n+  The R30 and R31 I/O registers.\")\n+\n ;; Integer constraints.\n \n (define_constraint \"I\""}, {"sha": "1a4b98eb2160c7df0406de47d75a821ef4f1a6a4", "filename": "gcc/config/pru/predicates.md", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Fconfig%2Fpru%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Fconfig%2Fpru%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpredicates.md?ref=8bafc9640f353ff11c0535a03096fb4db9a5bb95", "patch": "@@ -121,6 +121,25 @@\n   return 0;\n })\n \n+(define_predicate \"regio_operand\"\n+  (match_code \"subreg,reg\")\n+{\n+  if (register_operand (op, mode))\n+    {\n+      int regno;\n+\n+      if (REG_P (op))\n+\tregno = REGNO (op);\n+      else if (GET_CODE (op) == SUBREG && REG_P (SUBREG_REG (op)))\n+\tregno = REGNO (SUBREG_REG (op));\n+      else\n+\treturn 0;\n+\n+      return REGNO_REG_CLASS (regno) == REGIO_REGS;\n+    }\n+  return 0;\n+})\n+\n (define_predicate \"reg_or_const_int_operand\"\n   (ior (match_operand 0 \"const_int_operand\")\n        (match_operand 0 \"register_operand\")))"}, {"sha": "3beec236be12ccc8cfb0dea45f9f4f0ee30f66b0", "filename": "gcc/config/pru/pru-pragma.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Fconfig%2Fpru%2Fpru-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Fconfig%2Fpru%2Fpru-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru-pragma.c?ref=8bafc9640f353ff11c0535a03096fb4db9a5bb95", "patch": "@@ -83,4 +83,6 @@ pru_register_pragmas (void)\n {\n   c_register_pragma (NULL, \"ctable_entry\", pru_pragma_ctable_entry);\n   c_register_pragma (NULL, \"CTABLE_ENTRY\", pru_pragma_ctable_entry);\n+\n+  c_register_addr_space (\"__regio_symbol\", ADDR_SPACE_REGIO);\n }"}, {"sha": "031ea9e2fab7d0c23b1511e0bbfd5b28b7c2c52b", "filename": "gcc/config/pru/pru-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Fconfig%2Fpru%2Fpru-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Fconfig%2Fpru%2Fpru-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru-protos.h?ref=8bafc9640f353ff11c0535a03096fb4db9a5bb95", "patch": "@@ -62,7 +62,10 @@ extern int pru_get_ctable_exact_base_index (unsigned HOST_WIDE_INT caddr);\n extern int pru_get_ctable_base_index (unsigned HOST_WIDE_INT caddr);\n extern int pru_get_ctable_base_offset (unsigned HOST_WIDE_INT caddr);\n \n+extern int pru_symref2ioregno (rtx op);\n+\n extern void pru_register_abicheck_pass (void);\n+\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE"}, {"sha": "9f264b4698d9d9fbf47a43a4e425cd869ffa8e5a", "filename": "gcc/config/pru/pru.c", "status": "modified", "additions": 151, "deletions": 5, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Fconfig%2Fpru%2Fpru.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Fconfig%2Fpru%2Fpru.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru.c?ref=8bafc9640f353ff11c0535a03096fb4db9a5bb95", "patch": "@@ -1403,11 +1403,42 @@ pru_valid_addr_expr_p (machine_mode mode, rtx base, rtx offset, bool strict_p)\n     return false;\n }\n \n-/* Implement TARGET_LEGITIMATE_ADDRESS_P.  */\n+/* Return register number (either for r30 or r31) which maps to the\n+   corresponding symbol OP's name in the __regio_symbol address namespace.\n+\n+   If no mapping can be established (i.e. symbol name is invalid), then\n+   return -1.  */\n+int pru_symref2ioregno (rtx op)\n+{\n+  if (!SYMBOL_REF_P (op))\n+    return -1;\n+\n+  const char *name = XSTR (op, 0);\n+  if (!strcmp (name, \"__R30\"))\n+    return R30_REGNUM;\n+  else if (!strcmp (name, \"__R31\"))\n+    return R31_REGNUM;\n+  else\n+    return -1;\n+}\n+\n+/* Implement TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P.  */\n static bool\n-pru_legitimate_address_p (machine_mode mode,\n-\t\t\t    rtx operand, bool strict_p)\n+pru_addr_space_legitimate_address_p (machine_mode mode, rtx operand,\n+\t\t\t\t     bool strict_p, addr_space_t as)\n {\n+  if (as == ADDR_SPACE_REGIO)\n+    {\n+      /*  Address space constraints for __regio_symbol have been checked in\n+\t  TARGET_INSERT_ATTRIBUTES, and some more checks will be done\n+\t  during RTL expansion of \"mov<mode>\".  */\n+      return true;\n+    }\n+  else if (as != ADDR_SPACE_GENERIC)\n+    {\n+      gcc_unreachable ();\n+    }\n+\n   switch (GET_CODE (operand))\n     {\n     /* Direct.  */\n@@ -2002,6 +2033,117 @@ pru_file_start (void)\n      need to confuse users with this warning.  */\n   fprintf (asm_out_file, \"\\t.set no_warn_regname_label\\n\");\n }\n+\n+/* Scan type TYP for pointer references to address space other than\n+   ADDR_SPACE_GENERIC.  Return true if such reference is found.\n+   Much of this code was taken from the avr port.  */\n+\n+static bool\n+pru_nongeneric_pointer_addrspace (tree typ)\n+{\n+  while (ARRAY_TYPE == TREE_CODE (typ))\n+    typ = TREE_TYPE (typ);\n+\n+  if (POINTER_TYPE_P (typ))\n+    {\n+      addr_space_t as;\n+      tree target = TREE_TYPE (typ);\n+\n+      /* Pointer to function: Test the function's return type.  */\n+      if (FUNCTION_TYPE == TREE_CODE (target))\n+\treturn pru_nongeneric_pointer_addrspace (TREE_TYPE (target));\n+\n+      /* \"Ordinary\" pointers... */\n+\n+      while (TREE_CODE (target) == ARRAY_TYPE)\n+\ttarget = TREE_TYPE (target);\n+\n+      as = TYPE_ADDR_SPACE (target);\n+\n+      if (!ADDR_SPACE_GENERIC_P (as))\n+\treturn true;\n+\n+      /* Scan pointer's target type.  */\n+      return pru_nongeneric_pointer_addrspace (target);\n+    }\n+\n+  return false;\n+}\n+\n+/* Implement `TARGET_INSERT_ATTRIBUTES'.  For PRU it's used as a hook to\n+   provide better diagnostics for some invalid usages of the __regio_symbol\n+   address space.\n+\n+   Any escapes of the following checks are supposed to be caught\n+   during the \"mov<mode>\" pattern expansion.  */\n+\n+static void\n+pru_insert_attributes (tree node, tree *attributes ATTRIBUTE_UNUSED)\n+{\n+\n+  /* Validate __regio_symbol variable declarations.  */\n+  if (VAR_P (node))\n+    {\n+      const char *name = DECL_NAME (node)\n+\t\t\t  ? IDENTIFIER_POINTER (DECL_NAME (node))\n+\t\t\t  : \"<unknown>\";\n+      tree typ = TREE_TYPE (node);\n+      addr_space_t as = TYPE_ADDR_SPACE (typ);\n+\n+      if (as == ADDR_SPACE_GENERIC)\n+\treturn;\n+\n+      if (AGGREGATE_TYPE_P (typ))\n+\t{\n+\t  error (\"aggregate types are prohibited in \"\n+\t\t \"%<__regio_symbol%> address space\");\n+\t  /* Don't bother anymore.  Below checks would pile\n+\t     meaningless errors, which would confuse user.  */\n+\t  return;\n+\t}\n+      if (DECL_INITIAL (node) != NULL_TREE)\n+\terror (\"variables in %<__regio_symbol%> address space \"\n+\t       \"cannot have initial value\");\n+      if (DECL_REGISTER (node))\n+\terror (\"variables in %<__regio_symbol%> address space \"\n+\t       \"cannot be declared %<register%>\");\n+      if (!TYPE_VOLATILE (typ))\n+\terror (\"variables in %<__regio_symbol%> address space \"\n+\t       \"must be declared %<volatile%>\");\n+      if (!DECL_EXTERNAL (node))\n+\terror (\"variables in %<__regio_symbol%> address space \"\n+\t       \"must be declared %<extern%>\");\n+      if (TYPE_MODE (typ) != SImode)\n+\terror (\"only 32-bit access is supported \"\n+\t       \"for %<__regio_symbol%> address space\");\n+      if (strcmp (name, \"__R30\") != 0 && strcmp (name, \"__R31\") != 0)\n+\terror (\"register name %<%s%> not recognized \"\n+\t       \"in %<__regio_symbol%> address space\", name);\n+    }\n+\n+  tree typ = NULL_TREE;\n+\n+  switch (TREE_CODE (node))\n+    {\n+    case FUNCTION_DECL:\n+      typ = TREE_TYPE (TREE_TYPE (node));\n+      break;\n+    case TYPE_DECL:\n+    case RESULT_DECL:\n+    case VAR_DECL:\n+    case FIELD_DECL:\n+    case PARM_DECL:\n+      typ = TREE_TYPE (node);\n+      break;\n+    case POINTER_TYPE:\n+      typ = node;\n+      break;\n+    default:\n+      break;\n+    }\n+  if (typ != NULL_TREE && pru_nongeneric_pointer_addrspace (typ))\n+    error (\"pointers to %<__regio_symbol%> address space are prohibited\");\n+}\n \f\n /* Function argument related.  */\n \n@@ -2933,6 +3075,9 @@ pru_unwind_word_mode (void)\n #undef TARGET_ASM_FILE_START\n #define TARGET_ASM_FILE_START pru_file_start\n \n+#undef  TARGET_INSERT_ATTRIBUTES\n+#define TARGET_INSERT_ATTRIBUTES pru_insert_attributes\n+\n #undef TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS pru_init_builtins\n #undef TARGET_EXPAND_BUILTIN\n@@ -2979,8 +3124,9 @@ pru_unwind_word_mode (void)\n #undef TARGET_MUST_PASS_IN_STACK\n #define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n \n-#undef TARGET_LEGITIMATE_ADDRESS_P\n-#define TARGET_LEGITIMATE_ADDRESS_P pru_legitimate_address_p\n+#undef TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P\n+#define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P \\\n+  pru_addr_space_legitimate_address_p\n \n #undef TARGET_INIT_LIBFUNCS\n #define TARGET_INIT_LIBFUNCS pru_init_libfuncs"}, {"sha": "03f08b1720fab5070defbb771d6b32bf8b9b17f3", "filename": "gcc/config/pru/pru.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Fconfig%2Fpru%2Fpru.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Fconfig%2Fpru%2Fpru.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru.h?ref=8bafc9640f353ff11c0535a03096fb4db9a5bb95", "patch": "@@ -215,6 +215,7 @@ enum reg_class\n   MULDST_REGS,\n   MULSRC0_REGS,\n   MULSRC1_REGS,\n+  REGIO_REGS,\n   GP_REGS,\n   ALL_REGS,\n   LIM_REG_CLASSES\n@@ -229,6 +230,7 @@ enum reg_class\n      \"MULDST_REGS\",\t  \\\n      \"MULSRC0_REGS\",\t  \\\n      \"MULSRC1_REGS\",\t  \\\n+     \"REGIO_REGS\",\t  \\\n      \"GP_REGS\",\t\t  \\\n      \"ALL_REGS\" }\n \n@@ -242,6 +244,7 @@ enum reg_class\n     /* MULDST_REGS    */ { 0, 0, 0, 0x00000f00, 0},\t\t\\\n     /* MULSRC0_REGS   */ { 0, 0, 0, 0x000f0000, 0},\t\t\\\n     /* MULSRC1_REGS   */ { 0, 0, 0, 0x00f00000, 0},\t\t\\\n+    /* REGIO_REGS     */ { 0, 0, 0, 0xff000000, 0},\t\t\\\n     /* GP_REGS\t      */ { ~0, ~0, ~0, ~0, 0},\t\t\t\\\n     /* ALL_REGS\t      */ { ~0,~0, ~0, ~0, ~0}\t\t\t\\\n   }\n@@ -252,6 +255,8 @@ enum reg_class\n \t((REGNO) == MULDST_REGNUM ? MULDST_REGS\t\t\t\t    \\\n \t : (REGNO) == MULSRC0_REGNUM ? MULSRC0_REGS\t\t\t    \\\n \t : (REGNO) == MULSRC1_REGNUM ? MULSRC1_REGS\t\t\t    \\\n+\t : (REGNO) == R30_REGNUM ? REGIO_REGS\t\t\t\t    \\\n+\t : (REGNO) == R31_REGNUM ? REGIO_REGS\t\t\t\t    \\\n \t : (REGNO) >= FIRST_ARG_REGNUM\t\t\t\t\t    \\\n \t    && (REGNO) <= LAST_ARG_REGNUM ? SIB_REGS\t\t\t    \\\n \t : (REGNO) == STATIC_CHAIN_REGNUM ? SIB_REGS\t\t\t    \\"}, {"sha": "c0ded8ea4e59bd2f4a86acb069619f90098e833e", "filename": "gcc/config/pru/pru.md", "status": "modified", "additions": 97, "deletions": 5, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Fconfig%2Fpru%2Fpru.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Fconfig%2Fpru%2Fpru.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru.md?ref=8bafc9640f353ff11c0535a03096fb4db9a5bb95", "patch": "@@ -36,6 +36,8 @@\n    (MULSRC0_REGNUM\t\t112) ; Multiply source register.\n    (MULSRC1_REGNUM\t\t116) ; Multiply source register.\n    (LAST_NONIO_GP_REGNUM\t119) ; Last non-I/O general purpose register.\n+   (R30_REGNUM\t\t\t120) ; R30 I/O register.\n+   (R31_REGNUM\t\t\t124) ; R31 I/O register.\n    (LOOPCNTR_REGNUM\t\t128) ; internal LOOP counter register\n    (LAST_GP_REGNUM\t\t132) ; Last general purpose register.\n \n@@ -49,6 +51,13 @@\n   ]\n )\n \n+;; Enumerate address spaces.\n+(define_constants\n+  [\n+   (ADDR_SPACE_REGIO\t\t1) ; Access to R30 and R31 I/O registers.\n+  ]\n+)\n+\n ;; Enumeration of UNSPECs.\n \n (define_c_enum \"unspec\" [\n@@ -68,6 +77,9 @@\n   UNSPECV_HALT\n \n   UNSPECV_BLOCKAGE\n+\n+  UNSPECV_REGIO_READ\n+  UNSPECV_REGIO_WRITE\n ])\n \f\n ; Length of an instruction (in bytes).\n@@ -129,11 +141,62 @@\n \t(match_operand:MOV8_16_32 1 \"general_operand\"))]\n   \"\"\n {\n-  /* It helps to split constant loading and memory access\n-     early, so that the LDI/LDI32 instructions can be hoisted\n-     outside a loop body.  */\n-  if (MEM_P (operands[0]))\n-    operands[1] = force_reg (<MODE>mode, operands[1]);\n+  if (MEM_P (operands[0])\n+      && MEM_ADDR_SPACE (operands[0]) == ADDR_SPACE_REGIO)\n+\n+    {\n+      /* Intercept writes to the SImode register I/O \"address space\".  */\n+      gcc_assert (<MODE>mode == SImode);\n+\n+      if (!SYMBOL_REF_P (XEXP (operands[0], 0)))\n+\t{\n+\t  error (\"invalid access to %<__regio_symbol%> address space\");\n+\t  FAIL;\n+\t}\n+\n+      if (!REG_P (operands[1]))\n+\toperands[1] = force_reg (<MODE>mode, operands[1]);\n+\n+      int regiono = pru_symref2ioregno (XEXP (operands[0], 0));\n+      gcc_assert (regiono >= 0);\n+      rtx regio = gen_rtx_REG (<MODE>mode, regiono);\n+      rtx unspecv = gen_rtx_UNSPEC_VOLATILE (<MODE>mode,\n+\t\t\t\t\t     gen_rtvec (1, operands[1]),\n+\t\t\t\t\t     UNSPECV_REGIO_WRITE);\n+      emit_insn (gen_rtx_SET (regio, unspecv));\n+      DONE;\n+    }\n+  else if (MEM_P (operands[1])\n+\t   && MEM_ADDR_SPACE (operands[1]) == ADDR_SPACE_REGIO)\n+    {\n+      /* Intercept reads from the SImode register I/O \"address space\".  */\n+      gcc_assert (<MODE>mode == SImode);\n+\n+      if (!SYMBOL_REF_P (XEXP (operands[1], 0)))\n+\t{\n+\t  error (\"invalid access to %<__regio_symbol%> address space\");\n+\t  FAIL;\n+\t}\n+\n+      if (MEM_P (operands[0]))\n+\toperands[0] = force_reg (<MODE>mode, operands[0]);\n+\n+      int regiono = pru_symref2ioregno (XEXP (operands[1], 0));\n+      gcc_assert (regiono >= 0);\n+      rtx regio = gen_rtx_REG (<MODE>mode, regiono);\n+      rtx unspecv = gen_rtx_UNSPEC_VOLATILE (<MODE>mode,\n+\t\t\t\t\t     gen_rtvec (1, regio),\n+\t\t\t\t\t     UNSPECV_REGIO_READ);\n+      emit_insn (gen_rtx_SET (operands[0], unspecv));\n+      DONE;\n+    }\n+  else if (MEM_P (operands[0]))\n+    {\n+    /* It helps to split constant loading and memory access\n+       early, so that the LDI/LDI32 instructions can be hoisted\n+       outside a loop body.  */\n+      operands[1] = force_reg (<MODE>mode, operands[1]);\n+    }\n })\n \n ;; Keep a single pattern for 32 bit MOV operations.  LRA requires that the\n@@ -546,6 +609,35 @@\n \n (include \"alu-zext.md\")\n \f\n+;; Patterns for accessing the R30/R31 I/O registers.\n+\n+(define_insn \"*regio_readsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+    (unspec_volatile:SI\n+      [(match_operand:SI 1 \"regio_operand\" \"Rrio\")]\n+      UNSPECV_REGIO_READ))]\n+  \"\"\n+  \"mov\\\\t%0, %1\"\n+  [(set_attr \"type\"     \"alu\")])\n+\n+(define_insn \"*regio_nozext_writesi\"\n+  [(set (match_operand:SI 0 \"regio_operand\" \"=Rrio\")\n+    (unspec_volatile:SI\n+      [(match_operand:SI 1 \"register_operand\" \"r\")]\n+      UNSPECV_REGIO_WRITE))]\n+  \"\"\n+  \"mov\\\\t%0, %1\"\n+  [(set_attr \"type\"     \"alu\")])\n+\n+(define_insn \"*regio_zext_write_r30<EQS0:mode>\"\n+  [(set (match_operand:SI 0 \"regio_operand\" \"=Rrio\")\n+    (unspec_volatile:SI\n+      [(zero_extend:SI (match_operand:EQS0 1 \"register_operand\" \"r\"))]\n+      UNSPECV_REGIO_WRITE))]\n+  \"\"\n+  \"mov\\\\t%0, %1\"\n+  [(set_attr \"type\"     \"alu\")])\n+\f\n ;; DI logical ops could be automatically split into WORD-mode ops in\n ;; expand_binop().  But then we'll miss an opportunity to use SI mode\n ;; operations, since WORD mode for PRU is QI."}, {"sha": "63be63f091ae3b2b1885bf1cf0836abd7d55d6d5", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=8bafc9640f353ff11c0535a03096fb4db9a5bb95", "patch": "@@ -1406,7 +1406,7 @@ As an extension, GNU C supports named address spaces as\n defined in the N1275 draft of ISO/IEC DTR 18037.  Support for named\n address spaces in GCC will evolve as the draft technical report\n changes.  Calling conventions for any target might also change.  At\n-present, only the AVR, M32C, RL78, and x86 targets support\n+present, only the AVR, M32C, PRU, RL78, and x86 targets support\n address spaces other than the generic address space.\n \n Address space identifiers may be used exactly like any other C type\n@@ -1586,6 +1586,23 @@ order to access memory beyond the first 64@tie{}Ki bytes.  If\n @code{__far} is used with the M32CM or M32C CPU variants, it has no\n effect.\n \n+@subsection PRU Named Address Spaces\n+@cindex @code{__regio_symbol} PRU Named Address Spaces\n+\n+On the PRU target, variables qualified with @code{__regio_symbol} are\n+aliases used to access the special I/O CPU registers.  They must be\n+declared as @code{extern} because such variables will not be allocated in\n+any data memory.  They must also be marked as @code{volatile}, and can\n+only be 32-bit integer types.  The only names those variables can have\n+are @code{__R30} and @code{__R31}, representing respectively the\n+@code{R30} and @code{R31} special I/O CPU registers.  Hence the following\n+example is the only valid usage of @code{__regio_symbol}:\n+\n+@smallexample\n+extern volatile __regio_symbol uint32_t __R30;\n+extern volatile __regio_symbol uint32_t __R31;\n+@end smallexample\n+\n @subsection RL78 Named Address Spaces\n @cindex @code{__far} RL78 Named Address Spaces\n "}, {"sha": "06d9473e9954436688dc437dc8ac625cdc3e3b8e", "filename": "gcc/testsuite/gcc.target/pru/regio-as-pointer-2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-as-pointer-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-as-pointer-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-as-pointer-2.c?ref=8bafc9640f353ff11c0535a03096fb4db9a5bb95", "patch": "@@ -0,0 +1,11 @@\n+/* Test __regio_symbol invalid attempt to get regio variable address.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0\" } */\n+\n+#include \"regio.h\"\n+\n+uint32_t test(void)\n+{\n+  return *(&__R30+1); /* { dg-error \"invalid access to '__regio_symbol' address space\" } */\n+}"}, {"sha": "885464f498d577811bee592d1344cdcf474fc2a5", "filename": "gcc/testsuite/gcc.target/pru/regio-as-pointer.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-as-pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-as-pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-as-pointer.c?ref=8bafc9640f353ff11c0535a03096fb4db9a5bb95", "patch": "@@ -0,0 +1,11 @@\n+/* Test __regio_symbol invalid attempt to get regio variable address.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0\" } */\n+\n+#include \"regio.h\"\n+\n+uint32_t *test(void)\n+{\n+  return &__R31; /* { dg-error \"return from pointer to non-enclosed address space\" } */\n+}"}, {"sha": "9a9338e4b428f21c7cb268cb1376269542b909fe", "filename": "gcc/testsuite/gcc.target/pru/regio-decl-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-decl-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-decl-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-decl-2.c?ref=8bafc9640f353ff11c0535a03096fb4db9a5bb95", "patch": "@@ -0,0 +1,13 @@\n+/* Test __regio_symbol diagnostics for unsupported declarations.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O1\" } */\n+\n+#include <stdint.h>\n+\n+extern volatile __regio_symbol\n+uint32_t __R30[10]; /* { dg-error \"aggregate types are prohibited in '__regio_symbol' address space\" } */\n+\n+/* { dg-warning \"'__R31' initialized and declared 'extern'\" \"\" { target *-*-* } 0 } */\n+extern volatile __regio_symbol\n+uint32_t __R31 = 2; /* { dg-error \"variables in '__regio_symbol' address space cannot have initial value\" } */"}, {"sha": "36fcd8ac730a794421d790ea8e1c40cefddc1bc3", "filename": "gcc/testsuite/gcc.target/pru/regio-decl-3.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-decl-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-decl-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-decl-3.c?ref=8bafc9640f353ff11c0535a03096fb4db9a5bb95", "patch": "@@ -0,0 +1,19 @@\n+/* Test __regio_symbol diagnostics for unsupported declarations.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O1\" } */\n+\n+#include <stdint.h>\n+\n+uint32_t __regio_symbol *test1(void); /* { dg-error \"pointers to '__regio_symbol' address space are prohibited\" } */\n+\n+void test2(uint32_t __regio_symbol __R30); /* { dg-error \"'__regio_symbol' specified for parameter '__R30'\" } */\n+\n+void test3(uint32_t __regio_symbol *__R30); /* { dg-error \"pointers to '__regio_symbol' address space are prohibited\" } */\n+\n+typedef volatile uint32_t __regio_symbol * regio_type1_t; /* { dg-error \"pointers to '__regio_symbol' address space are prohibited\" } */\n+\n+struct A {\n+  uint32_t __regio_symbol *__R30; /* { dg-error \"pointers to '__regio_symbol' address space are prohibited\" } */\n+  uint32_t __regio_symbol __R31; /* { dg-error \"__regio_symbol' specified for structure field '__R31'\" } */\n+};"}, {"sha": "48c45a7c9183a343c607aad03b2d6ca1c81a8008", "filename": "gcc/testsuite/gcc.target/pru/regio-decl-4.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-decl-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-decl-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-decl-4.c?ref=8bafc9640f353ff11c0535a03096fb4db9a5bb95", "patch": "@@ -0,0 +1,17 @@\n+/* Test __regio_symbol diagnostics for unsupported access.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O1\" } */\n+\n+#include <stdint.h>\n+\n+extern volatile uint32_t __regio_symbol *__R30;\n+uint32_t test_r(void)\n+{\n+  return *__R30; /* { dg-error \"invalid access to '__regio_symbol' address space\" } */\n+}\n+\n+void test_w(uint32_t a)\n+{\n+  *__R30 = a; /* { dg-error \"invalid access to '__regio_symbol' address space\" } */\n+}"}, {"sha": "a4962aa449599cf803135866412a5b3987ed1993", "filename": "gcc/testsuite/gcc.target/pru/regio-decl.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-decl.c?ref=8bafc9640f353ff11c0535a03096fb4db9a5bb95", "patch": "@@ -0,0 +1,15 @@\n+/* Test __regio_symbol diagnostics for unsupported declarations.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O1\" } */\n+\n+#include <stdint.h>\n+\n+volatile __regio_symbol\n+uint32_t __R30; /* { dg-error \"variables in '__regio_symbol' address space must be declared 'extern'\" } */\n+\n+extern __regio_symbol\n+uint32_t __R31; /* { dg-error \"variables in '__regio_symbol' address space must be declared 'volatile'\" } */\n+\n+extern volatile\n+__regio_symbol uint32_t __R32; /* { dg-error \"register name '__R32' not recognized in '__regio_symbol' address space\" } */"}, {"sha": "a4226274fc12ddc0a2967409fc25a6d439b445c2", "filename": "gcc/testsuite/gcc.target/pru/regio-di.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-di.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-di.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-di.c?ref=8bafc9640f353ff11c0535a03096fb4db9a5bb95", "patch": "@@ -0,0 +1,9 @@\n+/* Test __regio_symbol invalid access diagnostic for DImode.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O1\" } */\n+\n+#include <stdint.h>\n+\n+extern volatile\n+__regio_symbol uint64_t __R31; /* { dg-error \"only 32-bit access is supported for '__regio_symbol' address space\" } */"}, {"sha": "5b89e8cea96ca07c4e5b816b1733702c235b3de3", "filename": "gcc/testsuite/gcc.target/pru/regio-hi.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-hi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-hi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-hi.c?ref=8bafc9640f353ff11c0535a03096fb4db9a5bb95", "patch": "@@ -0,0 +1,9 @@\n+/* Test __regio_symbol invalid access diagnostic for HImode.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O1\" } */\n+\n+#include <stdint.h>\n+\n+extern volatile __regio_symbol\n+uint16_t __R31; /* { dg-error \"only 32-bit access is supported for '__regio_symbol' address space\" } */"}, {"sha": "a3f63062b067f3dbd50c7383db05077181c7beac", "filename": "gcc/testsuite/gcc.target/pru/regio-qi.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-qi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-qi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio-qi.c?ref=8bafc9640f353ff11c0535a03096fb4db9a5bb95", "patch": "@@ -0,0 +1,9 @@\n+/* Test __regio_symbol invalid access diagnostic for QImode.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O1\" } */\n+\n+#include <stdint.h>\n+\n+extern volatile __regio_symbol\n+uint8_t __R31; /* { dg-error \"only 32-bit access is supported for '__regio_symbol' address space\" } */"}, {"sha": "2f01263b902f5fec20c086a5763bf2c88819b1ce", "filename": "gcc/testsuite/gcc.target/pru/regio.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio.c?ref=8bafc9640f353ff11c0535a03096fb4db9a5bb95", "patch": "@@ -0,0 +1,58 @@\n+/* __regio_symbol operations. */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-Os\" } */\n+\n+#include \"regio.h\"\n+\n+void\n+test_r30_w_const (void)\n+{\n+  /* { dg-final { scan-assembler \"mov\\\\tr30, r\\[012\\]\\[0-9\\]?\" } } */\n+  __R30 = 1;\n+}\n+\n+void\n+test_r31_w_zext_qi (unsigned char val1)\n+{\n+  /* { dg-final { scan-assembler \"mov\\\\tr31, r14.b0\" } } */\n+  __R31 = val1;\n+}\n+\n+void\n+test_r31_w_zext_hi (unsigned short val1)\n+{\n+  /* { dg-final { scan-assembler \"mov\\\\tr31, r14.w0\" } } */\n+  __R31 = val1;\n+}\n+\n+void\n+test_r31_w (unsigned int val1)\n+{\n+  /* { dg-final { scan-assembler \"mov\\\\tr31, r14\" } } */\n+  __R31 = val1;\n+}\n+\n+uint32_t\n+test_r30_r (void)\n+{\n+  /* { dg-final { scan-assembler \"mov\\\\tr14, r30\" } } */\n+  return __R30;\n+}\n+\n+void\n+test_r30_rw (void)\n+{\n+  /* { dg-final { scan-assembler \"mov\\\\tr\\[012\\]\\[0-9\\]?, r30\" } } */\n+  /* { dg-final { scan-assembler \"mov\\\\tr30, r\\[012\\]\\[0-9\\]?\" } } */\n+  __R30 = __R30;\n+}\n+\n+void\n+test_r31_rw (void)\n+{\n+  /* { dg-final { scan-assembler \"mov\\\\tr\\[012\\]\\[0-9\\]?, r31\" } } */\n+  /* { dg-final { scan-assembler \"mov\\\\tr31, r\\[012\\]\\[0-9\\]?\" } } */\n+  __R31 |= 101;\n+}\n+"}, {"sha": "3a120c1d2d1bedf632e38197586a2bf501b937b0", "filename": "gcc/testsuite/gcc.target/pru/regio.h", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bafc9640f353ff11c0535a03096fb4db9a5bb95/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fregio.h?ref=8bafc9640f353ff11c0535a03096fb4db9a5bb95", "patch": "@@ -0,0 +1,7 @@\n+\n+#include <stdint.h>\n+\n+/* Declare the I/O registers.  */\n+extern volatile __regio_symbol uint32_t __R30;\n+extern volatile __regio_symbol uint32_t __R31;\n+"}]}