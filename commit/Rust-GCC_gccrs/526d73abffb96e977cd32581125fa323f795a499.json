{"sha": "526d73abffb96e977cd32581125fa323f795a499", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI2ZDczYWJmZmI5NmU5NzdjZDMyNTgxMTI1ZmEzMjNmNzk1YTQ5OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-03-01T18:47:08Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-03-01T18:47:08Z"}, "message": "re PR debug/39267 (gdb testsuite regressions)\n\n\n\tPR debug/39267\n\t* tree.h (BLOCK_NONLOCALIZED_VARS, BLOCK_NUM_NONLOCALIZED_VARS,\n\tBLOCK_NONLOCALIZED_VAR): New macros.\n\t(tree_block): Add nonlocalized_vars.\n\t* dwarf2out.c (gen_formal_parameter_die, gen_variable_die, gen_decl_die): Add\n\torigin argument; allow generation of die with origin at hand only.\n\t(gen_member_die, gen_type_die_with_usage, force_decl_die,\n\tdeclare_in_namespace, gen_namescpace_die, dwarf2out_decl): Update use of gen_*.\n\t(gen_block_die): Fix checking for unused blocks.\n\t(process_scope_var): Break out from .... ; work with origins only.\n\t(decls_for_scope) ... here; process nonlocalized list.\n\t(dwarf2out_ignore_block): Look for nonlocalized vars.\n\t* tree-ssa-live.c (remove_unused_scope_block_p): Look for nonlocalized vars.\n\t(dump_scope_block): Dump them.\n\t* tree-inline.c (remap_decls): Handle nonlocalized vars.\n\t(remap_block): Likewise.\n\t(can_be_nonlocal): New predicate.\n\t(copy_bind_expr, copy_gimple_bind): Update use of remap_block.\n\nFrom-SVN: r144529", "tree": {"sha": "dccb239dddee2386961ca60f8919f7c0e70cf106", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dccb239dddee2386961ca60f8919f7c0e70cf106"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/526d73abffb96e977cd32581125fa323f795a499", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/526d73abffb96e977cd32581125fa323f795a499", "html_url": "https://github.com/Rust-GCC/gccrs/commit/526d73abffb96e977cd32581125fa323f795a499", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/526d73abffb96e977cd32581125fa323f795a499/comments", "author": null, "committer": null, "parents": [{"sha": "7a9d3fe88632a1b8eff4d574c6c13a363cc2115a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a9d3fe88632a1b8eff4d574c6c13a363cc2115a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a9d3fe88632a1b8eff4d574c6c13a363cc2115a"}], "stats": {"total": 363, "additions": 238, "deletions": 125}, "files": [{"sha": "6f47c0a840e6b6b551de2ec3a79caff316d61489", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/526d73abffb96e977cd32581125fa323f795a499/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/526d73abffb96e977cd32581125fa323f795a499/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=526d73abffb96e977cd32581125fa323f795a499", "patch": "@@ -1,3 +1,24 @@\n+2009-03-01  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR debug/39267\n+\t* tree.h (BLOCK_NONLOCALIZED_VARS, BLOCK_NUM_NONLOCALIZED_VARS,\n+\tBLOCK_NONLOCALIZED_VAR): New macros.\n+\t(tree_block): Add nonlocalized_vars.\n+\t* dwarf2out.c (gen_formal_parameter_die, gen_variable_die, gen_decl_die): Add\n+\torigin argument; allow generation of die with origin at hand only.\n+\t(gen_member_die, gen_type_die_with_usage, force_decl_die,\n+\tdeclare_in_namespace, gen_namescpace_die, dwarf2out_decl): Update use of gen_*.\n+\t(gen_block_die): Fix checking for unused blocks.\n+\t(process_scope_var): Break out from .... ; work with origins only.\n+\t(decls_for_scope) ... here; process nonlocalized list.\n+\t(dwarf2out_ignore_block): Look for nonlocalized vars.\n+\t* tree-ssa-live.c (remove_unused_scope_block_p): Look for nonlocalized vars.\n+\t(dump_scope_block): Dump them.\n+\t* tree-inline.c (remap_decls): Handle nonlocalized vars.\n+\t(remap_block): Likewise.\n+\t(can_be_nonlocal): New predicate.\n+\t(copy_bind_expr, copy_gimple_bind): Update use of remap_block.\n+\n 2009-03-01  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* configure: Regenerate."}, {"sha": "848926b6383178dfa42eaccd4ace3e8198baf353", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 136, "deletions": 103, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/526d73abffb96e977cd32581125fa323f795a499/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/526d73abffb96e977cd32581125fa323f795a499/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=526d73abffb96e977cd32581125fa323f795a499", "patch": "@@ -5153,11 +5153,11 @@ static void gen_inlined_enumeration_type_die (tree, dw_die_ref);\n static void gen_inlined_structure_type_die (tree, dw_die_ref);\n static void gen_inlined_union_type_die (tree, dw_die_ref);\n static dw_die_ref gen_enumeration_type_die (tree, dw_die_ref);\n-static dw_die_ref gen_formal_parameter_die (tree, dw_die_ref);\n+static dw_die_ref gen_formal_parameter_die (tree, tree, dw_die_ref);\n static void gen_unspecified_parameters_die (tree, dw_die_ref);\n static void gen_formal_types_die (tree, dw_die_ref);\n static void gen_subprogram_die (tree, dw_die_ref);\n-static void gen_variable_die (tree, dw_die_ref);\n+static void gen_variable_die (tree, tree, dw_die_ref);\n static void gen_const_die (tree, dw_die_ref);\n static void gen_label_die (tree, dw_die_ref);\n static void gen_lexical_block_die (tree, dw_die_ref, int);\n@@ -5177,7 +5177,7 @@ static void gen_block_die (tree, dw_die_ref, int);\n static void decls_for_scope (tree, dw_die_ref, int);\n static int is_redundant_typedef (const_tree);\n static void gen_namespace_die (tree);\n-static void gen_decl_die (tree, dw_die_ref);\n+static void gen_decl_die (tree, tree, dw_die_ref);\n static dw_die_ref force_decl_die (tree);\n static dw_die_ref force_type_die (tree);\n static dw_die_ref setup_namespace_context (tree, dw_die_ref);\n@@ -13293,16 +13293,17 @@ gen_enumeration_type_die (tree type, dw_die_ref context_die)\n    argument type of some subprogram type.  */\n \n static dw_die_ref\n-gen_formal_parameter_die (tree node, dw_die_ref context_die)\n+gen_formal_parameter_die (tree node, tree origin, dw_die_ref context_die)\n {\n+  tree node_or_origin = node ? node : origin;\n   dw_die_ref parm_die\n     = new_die (DW_TAG_formal_parameter, context_die, node);\n-  tree origin;\n \n-  switch (TREE_CODE_CLASS (TREE_CODE (node)))\n+  switch (TREE_CODE_CLASS (TREE_CODE (node_or_origin)))\n     {\n     case tcc_declaration:\n-      origin = decl_ultimate_origin (node);\n+      if (!origin)\n+        origin = decl_ultimate_origin (node);\n       if (origin != NULL)\n \tadd_abstract_origin_attribute (parm_die, origin);\n       else\n@@ -13321,15 +13322,17 @@ gen_formal_parameter_die (tree node, dw_die_ref context_die)\n \t    add_AT_flag (parm_die, DW_AT_artificial, 1);\n \t}\n \n-      equate_decl_number_to_die (node, parm_die);\n-      if (! DECL_ABSTRACT (node))\n-\tadd_location_or_const_value_attribute (parm_die, node, DW_AT_location);\n+      if (node)\n+        equate_decl_number_to_die (node, parm_die);\n+      if (! DECL_ABSTRACT (node_or_origin))\n+\tadd_location_or_const_value_attribute (parm_die, node_or_origin,\n+\t\t\t\t\t       DW_AT_location);\n \n       break;\n \n     case tcc_type:\n       /* We were called with some kind of a ..._TYPE node.  */\n-      add_type_attribute (parm_die, node, 0, 0, context_die);\n+      add_type_attribute (parm_die, node_or_origin, 0, 0, context_die);\n       break;\n \n     default:\n@@ -13382,7 +13385,7 @@ gen_formal_types_die (tree function_or_method_type, dw_die_ref context_die)\n \tbreak;\n \n       /* Output a (nameless) DIE to represent the formal parameter itself.  */\n-      parm_die = gen_formal_parameter_die (formal_type, context_die);\n+      parm_die = gen_formal_parameter_die (formal_type, NULL, context_die);\n       if ((TREE_CODE (function_or_method_type) == METHOD_TYPE\n \t   && link == first_parm_type)\n \t  || (arg && DECL_ARTIFICIAL (arg)))\n@@ -13442,7 +13445,7 @@ gen_type_die_for_member (tree type, tree member, dw_die_ref context_die)\n \t    }\n \t}\n       else\n-\tgen_variable_die (member, type_die);\n+\tgen_variable_die (member, NULL_TREE, type_die);\n \n       pop_decl_scope ();\n     }\n@@ -13787,7 +13790,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t\t\t    \"__builtin_va_alist\"))\n \t      gen_unspecified_parameters_die (parm, subr_die);\n \t    else\n-\t      gen_decl_die (parm, subr_die);\n+\t      gen_decl_die (parm, NULL, subr_die);\n \t  }\n \n       /* Decide whether we need an unspecified_parameters DIE at the end.\n@@ -13829,7 +13832,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n     {\n       /* Emit a DW_TAG_variable DIE for a named return value.  */\n       if (DECL_NAME (DECL_RESULT (decl)))\n-\tgen_decl_die (DECL_RESULT (decl), subr_die);\n+\tgen_decl_die (DECL_RESULT (decl), NULL, subr_die);\n \n       current_function_has_inlines = 0;\n       decls_for_scope (outer_scope, subr_die, 0);\n@@ -13871,17 +13874,18 @@ common_block_die_table_eq (const void *x, const void *y)\n   return d->decl_id == e->decl_id && d->die_parent == e->die_parent;\n }\n \n-/* Generate a DIE to represent a declared data object.  */\n+/* Generate a DIE to represent a declared data object.\n+   Either DECL or ORIGIN must be non-null.  */\n \n static void\n-gen_variable_die (tree decl, dw_die_ref context_die)\n+gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n {\n   HOST_WIDE_INT off;\n   tree com_decl;\n+  tree decl_or_origin = decl ? decl : origin;\n   dw_die_ref var_die;\n-  tree origin = decl_ultimate_origin (decl);\n-  dw_die_ref old_die = lookup_decl_die (decl);\n-  int declaration = (DECL_EXTERNAL (decl)\n+  dw_die_ref old_die = decl ? lookup_decl_die (decl) : NULL;\n+  int declaration = (DECL_EXTERNAL (decl_or_origin)\n \t\t     /* If DECL is COMDAT and has not actually been\n \t\t\temitted, we cannot take its address; there\n \t\t\tmight end up being no definition anywhere in\n@@ -13899,11 +13903,15 @@ gen_variable_die (tree decl, dw_die_ref context_die)\n \t\t\tHere, S<int>::i is not DECL_EXTERNAL, but no\n \t\t\tdefinition is required, so the compiler will\n \t\t\tnot emit a definition.  */\n-\t\t     || (TREE_CODE (decl) == VAR_DECL\n-\t\t\t && DECL_COMDAT (decl) && !TREE_ASM_WRITTEN (decl))\n+\t\t     || (TREE_CODE (decl_or_origin) == VAR_DECL\n+\t\t\t && DECL_COMDAT (decl_or_origin)\n+\t\t\t && !TREE_ASM_WRITTEN (decl_or_origin))\n \t\t     || class_or_namespace_scope_p (context_die));\n \n-  com_decl = fortran_common (decl, &off);\n+  if (!origin)\n+    origin = decl_ultimate_origin (decl);\n+\n+  com_decl = fortran_common (decl_or_origin, &off);\n \n   /* Symbol in common gets emitted as a child of the common block, in the form\n      of a data member.  */\n@@ -13914,7 +13922,7 @@ gen_variable_die (tree decl, dw_die_ref context_die)\n       dw_loc_descr_ref loc;\n       die_node com_die_arg;\n \n-      var_die = lookup_decl_die (decl);\n+      var_die = lookup_decl_die (decl_or_origin);\n       if (var_die)\n \t{\n \t  if (get_AT (var_die, DW_AT_location) == NULL)\n@@ -14071,20 +14079,22 @@ gen_variable_die (tree decl, dw_die_ref context_die)\n   if (declaration)\n     add_AT_flag (var_die, DW_AT_declaration, 1);\n \n-  if (DECL_ABSTRACT (decl) || declaration)\n+  if (decl && (DECL_ABSTRACT (decl) || declaration))\n     equate_decl_number_to_die (decl, var_die);\n \n-  if (! declaration && ! DECL_ABSTRACT (decl))\n+  if (! declaration && ! DECL_ABSTRACT (decl_or_origin))\n     {\n-      if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl)\n-          && !TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n-\tdefer_location (decl, var_die);\n+      if (TREE_CODE (decl_or_origin) == VAR_DECL && TREE_STATIC (decl_or_origin)\n+          && !TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl_or_origin)))\n+\tdefer_location (decl_or_origin, var_die);\n       else\n-        add_location_or_const_value_attribute (var_die, decl, DW_AT_location);\n-      add_pubname (decl, var_die);\n+        add_location_or_const_value_attribute (var_die,\n+\t\t\t\t\t       decl_or_origin,\n+\t\t\t\t\t       DW_AT_location);\n+      add_pubname (decl_or_origin, var_die);\n     }\n   else\n-    tree_add_const_value_attribute (var_die, decl);\n+    tree_add_const_value_attribute (var_die, decl_or_origin);\n }\n \n /* Generate a DIE to represent a named constant.  */\n@@ -14209,7 +14219,7 @@ gen_lexical_block_die (tree stmt, dw_die_ref context_die, int depth)\n {\n   dw_die_ref stmt_die = new_die (DW_TAG_lexical_block, context_die, stmt);\n \n-  if (! BLOCK_ABSTRACT (stmt))\n+  if (! BLOCK_ABSTRACT (stmt) && TREE_ASM_WRITTEN (stmt))\n     add_high_low_attributes (stmt, stmt_die);\n \n   decls_for_scope (stmt, stmt_die, depth);\n@@ -14234,7 +14244,8 @@ gen_inlined_subroutine_die (tree stmt, dw_die_ref context_die, int depth)\n \t= new_die (DW_TAG_inlined_subroutine, context_die, stmt);\n \n       add_abstract_origin_attribute (subr_die, decl);\n-      add_high_low_attributes (stmt, subr_die);\n+      if (TREE_ASM_WRITTEN (stmt))\n+        add_high_low_attributes (stmt, subr_die);\n       add_call_src_coords_attributes (stmt, subr_die);\n \n       decls_for_scope (stmt, subr_die, depth);\n@@ -14466,7 +14477,7 @@ gen_member_die (tree type, dw_die_ref context_die)\n       if (child)\n \tsplice_child_die (context_die, child);\n       else\n-\tgen_decl_die (member, context_die);\n+\tgen_decl_die (member, NULL, context_die);\n     }\n \n   /* Now output info about the function members (if any).  */\n@@ -14480,7 +14491,7 @@ gen_member_die (tree type, dw_die_ref context_die)\n       if (child)\n \tsplice_child_die (context_die, child);\n       else\n-\tgen_decl_die (member, context_die);\n+\tgen_decl_die (member, NULL, context_die);\n     }\n }\n \n@@ -14655,7 +14666,7 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n       gcc_assert (DECL_ORIGINAL_TYPE (TYPE_NAME (type)) != type);\n \n       TREE_ASM_WRITTEN (type) = 1;\n-      gen_decl_die (TYPE_NAME (type), context_die);\n+      gen_decl_die (TYPE_NAME (type), NULL, context_die);\n       return;\n     }\n \n@@ -14858,7 +14869,6 @@ static void\n gen_block_die (tree stmt, dw_die_ref context_die, int depth)\n {\n   int must_output_die = 0;\n-  tree decl;\n   bool inlined_func;\n \n   /* Ignore blocks that are NULL.  */\n@@ -14893,21 +14903,16 @@ gen_block_die (tree stmt, dw_die_ref context_die, int depth)\n       if (debug_info_level > DINFO_LEVEL_TERSE)\n \t/* We are not in terse mode so *any* local declaration counts\n \t   as being a \"significant\" one.  */\n-\tmust_output_die = (BLOCK_VARS (stmt) != NULL\n+\tmust_output_die = ((BLOCK_VARS (stmt) != NULL\n+\t\t\t    || BLOCK_NUM_NONLOCALIZED_VARS (stmt))\n \t\t\t   && (TREE_USED (stmt)\n \t\t\t       || TREE_ASM_WRITTEN (stmt)\n \t\t\t       || BLOCK_ABSTRACT (stmt)));\n-      else\n-\t/* We are in terse mode, so only local (nested) function\n-\t   definitions count as \"significant\" local declarations.  */\n-\tfor (decl = BLOCK_VARS (stmt);\n-\t     decl != NULL; decl = TREE_CHAIN (decl))\n-\t  if (TREE_CODE (decl) == FUNCTION_DECL\n-\t      && DECL_INITIAL (decl))\n-\t    {\n-\t      must_output_die = 1;\n-\t      break;\n-\t    }\n+      else if ((TREE_USED (stmt)\n+\t\t|| TREE_ASM_WRITTEN (stmt)\n+\t\t|| BLOCK_ABSTRACT (stmt))\n+      \t       && !dwarf2out_ignore_block (stmt))\n+\tmust_output_die = 1;\n     }\n \n   /* It would be a waste of space to generate a Dwarf DW_TAG_lexical_block\n@@ -14928,45 +14933,58 @@ gen_block_die (tree stmt, dw_die_ref context_die, int depth)\n     decls_for_scope (stmt, context_die, depth);\n }\n \n+/* Process variable DECL (or variable with origin ORIGIN) within\n+   block STMT and add it to CONTEXT_DIE.  */\n+static void\n+process_scope_var (tree stmt, tree decl, tree origin, dw_die_ref context_die)\n+{\n+  dw_die_ref die;\n+  tree decl_or_origin = decl ? decl : origin;\n+  tree ultimate_origin = origin ? decl_ultimate_origin (origin) : NULL;\n+\n+  if (ultimate_origin)\n+    origin = ultimate_origin;\n+\n+  if (TREE_CODE (decl_or_origin) == FUNCTION_DECL)\n+    die = lookup_decl_die (decl_or_origin);\n+  else if (TREE_CODE (decl_or_origin) == TYPE_DECL\n+           && TYPE_DECL_IS_STUB (decl_or_origin))\n+    die = lookup_type_die (TREE_TYPE (decl_or_origin));\n+  else\n+    die = NULL;\n+\n+  if (die != NULL && die->die_parent == NULL)\n+    add_child_die (context_die, die);\n+  else if (TREE_CODE (decl_or_origin) == IMPORTED_DECL)\n+    dwarf2out_imported_module_or_decl_1 (decl_or_origin, DECL_NAME (decl_or_origin),\n+\t\t\t\t\t stmt, context_die);\n+  else\n+    gen_decl_die (decl, origin, context_die);\n+}\n+\n /* Generate all of the decls declared within a given scope and (recursively)\n    all of its sub-blocks.  */\n \n static void\n decls_for_scope (tree stmt, dw_die_ref context_die, int depth)\n {\n   tree decl;\n+  unsigned int i;\n   tree subblocks;\n \n   /* Ignore NULL blocks.  */\n   if (stmt == NULL_TREE)\n     return;\n \n-  if (TREE_USED (stmt))\n-    {\n-      /* Output the DIEs to represent all of the data objects and typedefs\n-\t declared directly within this block but not within any nested\n-\t sub-blocks.  Also, nested function and tag DIEs have been\n-\t generated with a parent of NULL; fix that up now.  */\n-      for (decl = BLOCK_VARS (stmt); decl != NULL; decl = TREE_CHAIN (decl))\n-\t{\n-\t  dw_die_ref die;\n-\n-\t  if (TREE_CODE (decl) == FUNCTION_DECL)\n-\t    die = lookup_decl_die (decl);\n-\t  else if (TREE_CODE (decl) == TYPE_DECL && TYPE_DECL_IS_STUB (decl))\n-\t    die = lookup_type_die (TREE_TYPE (decl));\n-\t  else\n-\t    die = NULL;\n-\n-\t  if (die != NULL && die->die_parent == NULL)\n-\t    add_child_die (context_die, die);\n-\t  else if (TREE_CODE (decl) == IMPORTED_DECL)\n-\t    dwarf2out_imported_module_or_decl_1 (decl, DECL_NAME (decl),\n-\t\t\t\t\t\t stmt, context_die);\n-\t  else\n-\t    gen_decl_die (decl, context_die);\n-\t}\n-    }\n+  /* Output the DIEs to represent all of the data objects and typedefs\n+     declared directly within this block but not within any nested\n+     sub-blocks.  Also, nested function and tag DIEs have been\n+     generated with a parent of NULL; fix that up now.  */\n+  for (decl = BLOCK_VARS (stmt); decl != NULL; decl = TREE_CHAIN (decl))\n+    process_scope_var (stmt, decl, NULL_TREE, context_die);\n+  for (i = 0; i < BLOCK_NUM_NONLOCALIZED_VARS (stmt); i++)\n+    process_scope_var (stmt, NULL, BLOCK_NONLOCALIZED_VAR (stmt, i),\n+    \t\t       context_die);\n \n   /* If we're at -g1, we're not interested in subblocks.  */\n   if (debug_info_level <= DINFO_LEVEL_TERSE)\n@@ -15049,7 +15067,7 @@ force_decl_die (tree decl)\n \t   gen_decl_die() call.  */\n \t  saved_external_flag = DECL_EXTERNAL (decl);\n \t  DECL_EXTERNAL (decl) = 1;\n-\t  gen_decl_die (decl, context_die);\n+\t  gen_decl_die (decl, NULL, context_die);\n \t  DECL_EXTERNAL (decl) = saved_external_flag;\n \t  break;\n \n@@ -15132,7 +15150,7 @@ declare_in_namespace (tree thing, dw_die_ref context_die)\n       if (is_fortran ())\n \treturn ns_context;\n       if (DECL_P (thing))\n-\tgen_decl_die (thing, ns_context);\n+\tgen_decl_die (thing, NULL, ns_context);\n       else\n \tgen_type_die (thing, ns_context);\n     }\n@@ -15183,14 +15201,15 @@ gen_namespace_die (tree decl)\n /* Generate Dwarf debug information for a decl described by DECL.  */\n \n static void\n-gen_decl_die (tree decl, dw_die_ref context_die)\n+gen_decl_die (tree decl, tree origin, dw_die_ref context_die)\n {\n-  tree origin;\n+  tree decl_or_origin = decl ? decl : origin;\n+  tree class_origin = NULL;\n \n-  if (DECL_P (decl) && DECL_IGNORED_P (decl))\n+  if (DECL_P (decl_or_origin) && DECL_IGNORED_P (decl_or_origin))\n     return;\n \n-  switch (TREE_CODE (decl))\n+  switch (TREE_CODE (decl_or_origin))\n     {\n     case ERROR_MARK:\n       break;\n@@ -15215,8 +15234,10 @@ gen_decl_die (tree decl, dw_die_ref context_die)\n     case FUNCTION_DECL:\n       /* Don't output any DIEs to represent mere function declarations,\n \t unless they are class members or explicit block externs.  */\n-      if (DECL_INITIAL (decl) == NULL_TREE && DECL_CONTEXT (decl) == NULL_TREE\n-\t  && (current_function_decl == NULL_TREE || DECL_ARTIFICIAL (decl)))\n+      if (DECL_INITIAL (decl_or_origin) == NULL_TREE\n+          && DECL_CONTEXT (decl_or_origin) == NULL_TREE\n+\t  && (current_function_decl == NULL_TREE\n+\t      || DECL_ARTIFICIAL (decl_or_origin)))\n \tbreak;\n \n #if 0\n@@ -15228,8 +15249,8 @@ gen_decl_die (tree decl, dw_die_ref context_die)\n #endif\n \n       /* If we're emitting a clone, emit info for the abstract instance.  */\n-      if (DECL_ORIGIN (decl) != decl)\n-\tdwarf2out_abstract_function (DECL_ABSTRACT_ORIGIN (decl));\n+      if (origin || DECL_ORIGIN (decl) != decl)\n+\tdwarf2out_abstract_function (origin ? origin : DECL_ABSTRACT_ORIGIN (decl));\n \n       /* If we're emitting an out-of-line copy of an inline function,\n \t emit info for the abstract instance and set up to refer to it.  */\n@@ -15257,7 +15278,8 @@ gen_decl_die (tree decl, dw_die_ref context_die)\n \t    gen_type_die (DECL_CONTEXT (decl), context_die);\n \n \t  /* And its containing type.  */\n-\t  origin = decl_class_context (decl);\n+\t  if (!origin)\n+\t    origin = decl_class_context (decl);\n \t  if (origin != NULL_TREE)\n \t    gen_type_die_for_member (origin, decl, context_die);\n \n@@ -15266,7 +15288,8 @@ gen_decl_die (tree decl, dw_die_ref context_die)\n \t}\n \n       /* Now output a DIE to represent the function itself.  */\n-      gen_subprogram_die (decl, context_die);\n+      if (decl)\n+        gen_subprogram_die (decl, context_die);\n       break;\n \n     case TYPE_DECL:\n@@ -15309,28 +15332,30 @@ gen_decl_die (tree decl, dw_die_ref context_die)\n \n       /* Output any DIEs that are needed to specify the type of this data\n \t object.  */\n-      if (TREE_CODE (decl) == RESULT_DECL && DECL_BY_REFERENCE (decl))\n-\tgen_type_die (TREE_TYPE (TREE_TYPE (decl)), context_die);\n+      if (TREE_CODE (decl_or_origin) == RESULT_DECL\n+          && DECL_BY_REFERENCE (decl_or_origin))\n+\tgen_type_die (TREE_TYPE (TREE_TYPE (decl_or_origin)), context_die);\n       else\n-\tgen_type_die (TREE_TYPE (decl), context_die);\n+\tgen_type_die (TREE_TYPE (decl_or_origin), context_die);\n \n       /* And its containing type.  */\n-      origin = decl_class_context (decl);\n-      if (origin != NULL_TREE)\n-\tgen_type_die_for_member (origin, decl, context_die);\n+      class_origin = decl_class_context (decl_or_origin);\n+      if (class_origin != NULL_TREE)\n+\tgen_type_die_for_member (class_origin, decl_or_origin, context_die);\n \n       /* And its containing namespace.  */\n-      context_die = declare_in_namespace (decl, context_die);\n+      context_die = declare_in_namespace (decl_or_origin, context_die);\n \n       /* Now output the DIE to represent the data object itself.  This gets\n \t complicated because of the possibility that the VAR_DECL really\n \t represents an inlined instance of a formal parameter for an inline\n \t function.  */\n-      origin = decl_ultimate_origin (decl);\n+      if (!origin)\n+        origin = decl_ultimate_origin (decl);\n       if (origin != NULL_TREE && TREE_CODE (origin) == PARM_DECL)\n-\tgen_formal_parameter_die (decl, context_die);\n+\tgen_formal_parameter_die (decl, origin, context_die);\n       else\n-\tgen_variable_die (decl, context_die);\n+\tgen_variable_die (decl, origin, context_die);\n       break;\n \n     case FIELD_DECL:\n@@ -15346,11 +15371,11 @@ gen_decl_die (tree decl, dw_die_ref context_die)\n       break;\n \n     case PARM_DECL:\n-      if (DECL_BY_REFERENCE (decl))\n-\tgen_type_die (TREE_TYPE (TREE_TYPE (decl)), context_die);\n+      if (DECL_BY_REFERENCE (decl_or_origin))\n+\tgen_type_die (TREE_TYPE (TREE_TYPE (decl_or_origin)), context_die);\n       else\n-\tgen_type_die (TREE_TYPE (decl), context_die);\n-      gen_formal_parameter_die (decl, context_die);\n+\tgen_type_die (TREE_TYPE (decl_or_origin), context_die);\n+      gen_formal_parameter_die (decl, origin, context_die);\n       break;\n \n     case NAMESPACE_DECL:\n@@ -15641,7 +15666,7 @@ dwarf2out_decl (tree decl)\n       return;\n     }\n \n-  gen_decl_die (decl, context_die);\n+  gen_decl_die (decl, NULL, context_die);\n }\n \n /* Output a marker (i.e. a label) for the beginning of the generated code for\n@@ -15676,11 +15701,19 @@ static bool\n dwarf2out_ignore_block (const_tree block)\n {\n   tree decl;\n+  unsigned int i;\n \n   for (decl = BLOCK_VARS (block); decl; decl = TREE_CHAIN (decl))\n     if (TREE_CODE (decl) == FUNCTION_DECL\n \t|| (TREE_CODE (decl) == TYPE_DECL && TYPE_DECL_IS_STUB (decl)))\n       return 0;\n+  for (i = 0; i < BLOCK_NUM_NONLOCALIZED_VARS (block); i++)\n+    {\n+      decl = BLOCK_NONLOCALIZED_VAR (block, i);\n+      if (TREE_CODE (decl) == FUNCTION_DECL\n+\t  || (TREE_CODE (decl) == TYPE_DECL && TYPE_DECL_IS_STUB (decl)))\n+      return 0;\n+    }\n \n   return 1;\n }"}, {"sha": "88154bf91f388066e91335bc266e58fb206d52f4", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 67, "deletions": 21, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/526d73abffb96e977cd32581125fa323f795a499/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/526d73abffb96e977cd32581125fa323f795a499/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=526d73abffb96e977cd32581125fa323f795a499", "patch": "@@ -122,7 +122,6 @@ eni_weights eni_time_weights;\n static tree declare_return_variable (copy_body_data *, tree, tree, tree *);\n static bool inlinable_function_p (tree);\n static void remap_block (tree *, copy_body_data *);\n-static tree remap_decls (tree, copy_body_data *);\n static void copy_bind_expr (tree *, int *, copy_body_data *);\n static tree mark_local_for_remap_r (tree *, int *, void *);\n static void unsave_expr_1 (tree);\n@@ -427,8 +426,43 @@ remap_type (tree type, copy_body_data *id)\n   return tmp;\n }\n \n+/* Decide if DECL can be put into BLOCK_NONLOCAL_VARs.  */\n+  \n+static bool\n+can_be_nonlocal (tree decl, copy_body_data *id)\n+{\n+  /* We can not duplicate function decls.  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    return true;\n+\n+  /* Local static vars must be non-local or we get multiple declaration\n+     problems.  */\n+  if (TREE_CODE (decl) == VAR_DECL\n+      && !auto_var_in_fn_p (decl, id->src_fn))\n+    return true;\n+\n+  /* At the moment dwarf2out can handle only these types of nodes.  We\n+     can support more later.  */\n+  if (TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != PARM_DECL)\n+    return false;\n+\n+  /* We must use global type.  */\n+  if (TREE_TYPE (decl) != remap_type (TREE_TYPE (decl), id))\n+    return false;\n+\n+  /* Wihtout SSA we can't tell if variable is used.  */\n+  if (!gimple_in_ssa_p (cfun))\n+    return false;\n+\n+  /* Live variables must be copied so we can attach DECL_RTL.  */\n+  if (var_ann (decl))\n+    return false;\n+\n+  return true;\n+}\n+\n static tree\n-remap_decls (tree decls, copy_body_data *id)\n+remap_decls (tree decls, VEC(tree,gc) **nonlocalized_list, copy_body_data *id)\n {\n   tree old_var;\n   tree new_decls = NULL_TREE;\n@@ -437,16 +471,18 @@ remap_decls (tree decls, copy_body_data *id)\n   for (old_var = decls; old_var; old_var = TREE_CHAIN (old_var))\n     {\n       tree new_var;\n+      tree origin_var = DECL_ORIGIN (old_var);\n \n-      /* We cannot chain the local static declarations into the local_decls\n-\t as we can't duplicate them or break one decl rule.  Go ahead\n-\t and link them into local_decls.  */\n-\n-      if (!auto_var_in_fn_p (old_var, id->src_fn)\n-\t  && !DECL_EXTERNAL (old_var))\n+      if (can_be_nonlocal (old_var, id))\n \t{\n-\t  cfun->local_decls = tree_cons (NULL_TREE, old_var,\n-\t\t\t\t\t\t cfun->local_decls);\n+\t  if (TREE_CODE (old_var) == VAR_DECL\n+\t      && (var_ann (old_var) || !gimple_in_ssa_p (cfun)))\n+\t    cfun->local_decls = tree_cons (NULL_TREE, old_var,\n+\t\t\t\t\t\t   cfun->local_decls);\n+\t  if (debug_info_level > DINFO_LEVEL_TERSE\n+\t      && !DECL_IGNORED_P (old_var)\n+\t      && nonlocalized_list)\n+\t    VEC_safe_push (tree, gc, *nonlocalized_list, origin_var);\n \t  continue;\n \t}\n \n@@ -456,8 +492,16 @@ remap_decls (tree decls, copy_body_data *id)\n       /* If we didn't remap this variable, we can't mess with its\n \t TREE_CHAIN.  If we remapped this variable to the return slot, it's\n \t already declared somewhere else, so don't declare it here.  */\n-      if (!new_var || new_var == id->retvar)\n+      \n+      if (new_var == id->retvar)\n \t;\n+      else if (!new_var)\n+        {\n+\t  if (debug_info_level > DINFO_LEVEL_TERSE\n+\t      && !DECL_IGNORED_P (old_var)\n+\t      && nonlocalized_list)\n+\t    VEC_safe_push (tree, gc, *nonlocalized_list, origin_var);\n+\t}\n       else\n \t{\n \t  gcc_assert (DECL_P (new_var));\n@@ -485,10 +529,14 @@ remap_block (tree *block, copy_body_data *id)\n   TREE_USED (new_block) = TREE_USED (old_block);\n   BLOCK_ABSTRACT_ORIGIN (new_block) = old_block;\n   BLOCK_SOURCE_LOCATION (new_block) = BLOCK_SOURCE_LOCATION (old_block);\n+  BLOCK_NONLOCALIZED_VARS (new_block)\n+    = VEC_copy (tree, gc, BLOCK_NONLOCALIZED_VARS (old_block));\n   *block = new_block;\n \n   /* Remap its variables.  */\n-  BLOCK_VARS (new_block) = remap_decls (BLOCK_VARS (old_block), id);\n+  BLOCK_VARS (new_block) = remap_decls (BLOCK_VARS (old_block),\n+  \t\t\t\t\t&BLOCK_NONLOCALIZED_VARS (new_block),\n+\t\t\t\t\tid);\n \n   fn = id->dst_fn;\n \n@@ -549,7 +597,7 @@ copy_bind_expr (tree *tp, int *walk_subtrees, copy_body_data *id)\n   if (BIND_EXPR_VARS (*tp))\n     /* This will remap a lot of the same decls again, but this should be\n        harmless.  */\n-    BIND_EXPR_VARS (*tp) = remap_decls (BIND_EXPR_VARS (*tp), id);\n+    BIND_EXPR_VARS (*tp) = remap_decls (BIND_EXPR_VARS (*tp), NULL, id);\n }\n \n \n@@ -595,7 +643,7 @@ copy_gimple_bind (gimple stmt, copy_body_data *id)\n      harmless.  */\n   new_vars = gimple_bind_vars (stmt);\n   if (new_vars)\n-    new_vars = remap_decls (new_vars, id);\n+    new_vars = remap_decls (new_vars, NULL, id);\n \n   new_bind = gimple_build_bind (new_vars, new_body, new_block);\n \n@@ -3317,11 +3365,9 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n \t    cfun->local_decls = tree_cons (NULL_TREE, var,\n \t\t\t\t\t   cfun->local_decls);\n \t}\n-      else\n-        {\n-\t  cfun->local_decls = tree_cons (NULL_TREE, remap_decl (var, id),\n-\t\t\t\t\t          cfun->local_decls);\n-\t}\n+      else if (!can_be_nonlocal (var, id))\n+\tcfun->local_decls = tree_cons (NULL_TREE, remap_decl (var, id),\n+\t\t\t\t       cfun->local_decls);\n     }\n \n   /* This is it.  Duplicate the callee body.  Assume callee is\n@@ -3911,7 +3957,7 @@ replace_locals_stmt (gimple_stmt_iterator *gsip,\n       /* This will remap a lot of the same decls again, but this should be\n \t harmless.  */\n       if (gimple_bind_vars (stmt))\n-\tgimple_bind_set_vars (stmt, remap_decls (gimple_bind_vars (stmt), id));\n+\tgimple_bind_set_vars (stmt, remap_decls (gimple_bind_vars (stmt), NULL, id));\n     }\n \n   /* Keep iterating.  */\n@@ -4329,7 +4375,7 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n \ttree var = TREE_VALUE (t_step);\n \tif (TREE_STATIC (var) && !TREE_ASM_WRITTEN (var))\n \t  cfun->local_decls = tree_cons (NULL_TREE, var, cfun->local_decls);\n-\telse\n+\telse if (!can_be_nonlocal (var, &id))\n \t  cfun->local_decls =\n \t    tree_cons (NULL_TREE, remap_decl (var, &id),\n \t\t       cfun->local_decls);"}, {"sha": "28a829caedf1af054dcd0b3fc063c322aabce243", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/526d73abffb96e977cd32581125fa323f795a499/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/526d73abffb96e977cd32581125fa323f795a499/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=526d73abffb96e977cd32581125fa323f795a499", "patch": "@@ -583,7 +583,7 @@ remove_unused_scope_block_p (tree scope)\n    else if (debug_info_level == DINFO_LEVEL_NONE\n \t    || debug_info_level == DINFO_LEVEL_TERSE)\n      ;\n-   else if (BLOCK_VARS (scope))\n+   else if (BLOCK_VARS (scope) || BLOCK_NUM_NONLOCALIZED_VARS (scope))\n      unused = false;\n    /* See if this block is important for representation of inlined function.\n       Inlined functions are always represented by block with\n@@ -613,6 +613,7 @@ static void\n dump_scope_block (FILE *file, int indent, tree scope, int flags)\n {\n   tree var, t;\n+  unsigned int i;\n \n   fprintf (file, \"\\n%*s{ Scope block #%i%s%s\",indent, \"\" , BLOCK_NUMBER (scope),\n   \t   TREE_USED (scope) ? \"\" : \" (unused)\",\n@@ -648,6 +649,13 @@ dump_scope_block (FILE *file, int indent, tree scope, int flags)\n       print_generic_decl (file, var, flags);\n       fprintf (file, \"%s\\n\", used ? \"\" : \" (unused)\");\n     }\n+  for (i = 0; i < BLOCK_NUM_NONLOCALIZED_VARS (scope); i++)\n+    {\n+      fprintf (file, \"%*s\",indent, \"\");\n+      print_generic_decl (file, BLOCK_NONLOCALIZED_VAR (scope, i),\n+      \t\t\t  flags);\n+      fprintf (file, \" (nonlocalized)\\n\");\n+    }\n   for (t = BLOCK_SUBBLOCKS (scope); t ; t = BLOCK_CHAIN (t))\n     dump_scope_block (file, indent + 2, t, flags);\n   fprintf (file, \"\\n%*s}\\n\",indent, \"\");"}, {"sha": "761f4af2f7799419bc0e40eb636079b498c732f9", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/526d73abffb96e977cd32581125fa323f795a499/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/526d73abffb96e977cd32581125fa323f795a499/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=526d73abffb96e977cd32581125fa323f795a499", "patch": "@@ -1968,6 +1968,9 @@ struct varray_head_tag;\n \n /* In a BLOCK node.  */\n #define BLOCK_VARS(NODE) (BLOCK_CHECK (NODE)->block.vars)\n+#define BLOCK_NONLOCALIZED_VARS(NODE) (BLOCK_CHECK (NODE)->block.nonlocalized_vars)\n+#define BLOCK_NUM_NONLOCALIZED_VARS(NODE) VEC_length (tree, BLOCK_NONLOCALIZED_VARS (NODE))\n+#define BLOCK_NONLOCALIZED_VAR(NODE,N) VEC_index (tree, BLOCK_NONLOCALIZED_VARS (NODE), N)\n #define BLOCK_SUBBLOCKS(NODE) (BLOCK_CHECK (NODE)->block.subblocks)\n #define BLOCK_SUPERCONTEXT(NODE) (BLOCK_CHECK (NODE)->block.supercontext)\n /* Note: when changing this, make sure to find the places\n@@ -2022,6 +2025,8 @@ struct tree_block GTY(())\n   location_t locus;\n \n   tree vars;\n+  VEC(tree,gc) *nonlocalized_vars;\n+\n   tree subblocks;\n   tree supercontext;\n   tree abstract_origin;"}]}