{"sha": "21392f1922a60cff99a2f8f25852badbc516bd0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjEzOTJmMTkyMmE2MGNmZjk5YTJmOGYyNTg1MmJhZGJjNTE2YmQwZg==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2006-10-19T23:05:53Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2006-10-19T23:05:53Z"}, "message": "Fix PR tree-optimization/28778 Fix PR tree-optimization/29156 Fix PR tree-optimization/29415\n\n2006-10-19  Daniel Berlin  <dberlin@dberlin.org>\n\n\tFix PR tree-optimization/28778\n\tFix PR tree-optimization/29156\n\tFix PR tree-optimization/29415\n\t* tree.h (DECL_PTA_ARTIFICIAL): New macro.\n\t(tree_decl_with_vis): Add artificial_pta_var flag.\n\t* tree-ssa-alias.c (is_escape_site): Remove alias info argument,\n\tpushed into callers.\n\t* tree-ssa-structalias.c (nonlocal_for_type): New variable.\n\t(nonlocal_all): Ditto.\n\t(struct variable_info): Add directly_dereferenced member.\n\t(var_escaped_vars): New variable.\n\t(escaped_vars_tree): Ditto.\n\t(escaped_vars_id): Ditto.\n\t(nonlocal_vars_id): Ditto.\n\t(new_var_info): Set directly_dereferenced.\n\t(graph_size): New variable\n\t(build_constraint_graph): Use graph_size.\n\t(solve_graph): Don't process constraints that cannot change the\n\tsolution, don't try to propagate an empty solution to our\n\tsuccessors.\n\t(process_constraint): Set directly_dereferenced.\n\t(could_have_pointers): New function.\n\t(get_constraint_for_component_ref): Don't process STRING_CST.\n\t(nonlocal_lookup): New function.\n\t(nonlocal_insert): Ditto.\n\t(create_nonlocal_var): Ditto.\n\t(get_nonlocal_id_for_type): Ditto.\n\t(get_constraint_for): Allow results vector to be empty in the case\n\tof string constants.\n\tHandle results of calls properly.\n\t(update_alias_info): Update alias info stats on number and type of\n\tcalls.\n\t(find_func_aliases): Use could_have_pointers.\n\t(make_constraint_from_escaped): Renamed from\n\tmake_constraint_to_anything, and changed to make constraints from\n\tescape variable.\n\t(make_constraint_to_escaped): New function.\n\t(find_global_initializers): Ditto.\n\t(create_variable_info_for): Make constraint from escaped to any\n\tglobal variable, and from any global variable to the set of\n\tescaped vars.\n\t(intra_create_variable_infos): Deal with escaped instead of\n\tpointing to anything.\n\t(set_uids_in_ptset): Do type pruning on directly dereferenced\n\tvariables.\n\t(find_what_p_points_to): Adjust call to set_uids_with_ptset.\n\t(init_base_vars): Fix comment, and initialize escaped_vars.\n\t(need_to_solve): Removed.\n\t(find_escape_constraints): New function.\n\t(expand_nonlocal_solutions): Ditto.\n\t(compute_points_to_sets): Call find_escape_constraints and\n\texpand_nonlocal_solutions.\n\t(delete_points_to_sets): Don't fall off the end of the graph.\n\t(init_alias_heapvars): Initialize nonlocal_for_type and\n\tnonlocal_all.\n\t(delete_alias_heapvars): Free nonlocal_for_type and null out\n\tnonlocal_all.\n\nFrom-SVN: r117891", "tree": {"sha": "3bf6deb6c3a38a049a9a686d850d1314378e5d6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bf6deb6c3a38a049a9a686d850d1314378e5d6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21392f1922a60cff99a2f8f25852badbc516bd0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21392f1922a60cff99a2f8f25852badbc516bd0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21392f1922a60cff99a2f8f25852badbc516bd0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21392f1922a60cff99a2f8f25852badbc516bd0f/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3d894fc3f045e430b67aae82aa68dd818816ac90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d894fc3f045e430b67aae82aa68dd818816ac90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d894fc3f045e430b67aae82aa68dd818816ac90"}], "stats": {"total": 923, "additions": 763, "deletions": 160}, "files": [{"sha": "835baa1e26242a080e1129167e03fe4e58c6889b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21392f1922a60cff99a2f8f25852badbc516bd0f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21392f1922a60cff99a2f8f25852badbc516bd0f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=21392f1922a60cff99a2f8f25852badbc516bd0f", "patch": "@@ -1,3 +1,63 @@\n+2006-10-19  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\tFix PR tree-optimization/28778\n+\tFix PR tree-optimization/29156\n+\tFix PR tree-optimization/29415\n+\t* tree.h (DECL_PTA_ARTIFICIAL): New macro.\n+\t(tree_decl_with_vis): Add artificial_pta_var flag.\n+\t* tree-ssa-alias.c (is_escape_site): Remove alias info argument,\n+\tpushed into callers.\n+\t* tree-ssa-structalias.c (nonlocal_for_type): New variable.\n+\t(nonlocal_all): Ditto.\n+\t(struct variable_info): Add directly_dereferenced member.\n+\t(var_escaped_vars): New variable.\n+\t(escaped_vars_tree): Ditto.\n+\t(escaped_vars_id): Ditto.\n+\t(nonlocal_vars_id): Ditto.\n+\t(new_var_info): Set directly_dereferenced.\n+\t(graph_size): New variable\n+\t(build_constraint_graph): Use graph_size.\n+\t(solve_graph): Don't process constraints that cannot change the\n+\tsolution, don't try to propagate an empty solution to our\n+\tsuccessors.\n+\t(process_constraint): Set directly_dereferenced.\n+\t(could_have_pointers): New function.\n+\t(get_constraint_for_component_ref): Don't process STRING_CST.\n+\t(nonlocal_lookup): New function.\n+\t(nonlocal_insert): Ditto.\n+\t(create_nonlocal_var): Ditto.\n+\t(get_nonlocal_id_for_type): Ditto.\n+\t(get_constraint_for): Allow results vector to be empty in the case\n+\tof string constants.\n+\tHandle results of calls properly.\n+\t(update_alias_info): Update alias info stats on number and type of\n+\tcalls.\n+\t(find_func_aliases): Use could_have_pointers.\n+\t(make_constraint_from_escaped): Renamed from\n+\tmake_constraint_to_anything, and changed to make constraints from\n+\tescape variable.\n+\t(make_constraint_to_escaped): New function.\n+\t(find_global_initializers): Ditto.\n+\t(create_variable_info_for): Make constraint from escaped to any\n+\tglobal variable, and from any global variable to the set of\n+\tescaped vars.\n+\t(intra_create_variable_infos): Deal with escaped instead of\n+\tpointing to anything.\n+\t(set_uids_in_ptset): Do type pruning on directly dereferenced\n+\tvariables.\n+\t(find_what_p_points_to): Adjust call to set_uids_with_ptset.\n+\t(init_base_vars): Fix comment, and initialize escaped_vars.\n+\t(need_to_solve): Removed.\n+\t(find_escape_constraints): New function.\n+\t(expand_nonlocal_solutions): Ditto.\n+\t(compute_points_to_sets): Call find_escape_constraints and\n+\texpand_nonlocal_solutions.\n+\t(delete_points_to_sets): Don't fall off the end of the graph.\n+\t(init_alias_heapvars): Initialize nonlocal_for_type and\n+\tnonlocal_all.\n+\t(delete_alias_heapvars): Free nonlocal_for_type and null out\n+\tnonlocal_all. \n+\n 2006-10-19  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* fold-const.c (add_double): Rename to add_double_with_sign."}, {"sha": "f96a66cd30b7bb54c6d4f0e96b921a7c513deec0", "filename": "gcc/testsuite/gcc.c-torture/execute/pr28778.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21392f1922a60cff99a2f8f25852badbc516bd0f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr28778.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21392f1922a60cff99a2f8f25852badbc516bd0f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr28778.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr28778.c?ref=21392f1922a60cff99a2f8f25852badbc516bd0f", "patch": "@@ -0,0 +1,33 @@\n+extern void abort(void);\n+typedef long GLint;\n+void aglChoosePixelFormat (const GLint *);\n+\n+void\n+find (const int *alistp)\n+{\n+  const int *blist;\n+  int list[32];\n+  if (alistp)\n+    blist = alistp;\n+  else\n+    {\n+      list[3] = 42;\n+      blist = list;\n+    }\n+  aglChoosePixelFormat ((GLint *) blist);\n+}\n+\n+void\n+aglChoosePixelFormat (const GLint * a)\n+{\n+  int *b = (int *) a;\n+  if (b[3] != 42)\n+    abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  find (0);\n+  return 0;\n+}"}, {"sha": "20f5f9979c56041d3f4398db0e8624534a21496c", "filename": "gcc/testsuite/gcc.c-torture/execute/pr29156.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21392f1922a60cff99a2f8f25852badbc516bd0f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr29156.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21392f1922a60cff99a2f8f25852badbc516bd0f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr29156.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr29156.c?ref=21392f1922a60cff99a2f8f25852badbc516bd0f", "patch": "@@ -0,0 +1,32 @@\n+extern void abort(void);\n+struct test1\n+{\n+  int a;\n+  int b;\n+};\n+struct test2\n+{\n+  float d;\n+  struct test1 sub;\n+};\n+\n+int global;\n+\n+int bla(struct test1 *xa, struct test2 *xb)\n+{\n+  global = 1;\n+  xb->sub.a = 1;\n+  xa->a = 8;\n+  return xb->sub.a;\n+}\n+\n+int main(void)\n+{\n+  struct test2 pom;\n+\n+  if (bla (&pom.sub, &pom) != 8)\n+    abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "4a64d2490f4c2054b48b04da180583cb6c7f5942", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pta-fp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21392f1922a60cff99a2f8f25852badbc516bd0f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-fp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21392f1922a60cff99a2f8f25852badbc516bd0f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-fp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-fp.c?ref=21392f1922a60cff99a2f8f25852badbc516bd0f", "patch": "@@ -22,5 +22,5 @@ double f(double a)\n }\n /* The points-to set of the final function pointer should be \"sin cos\" */\n \n-/* { dg-final { scan-tree-dump-times \"sin cos\" 1 \"alias1\"} } */\n+/* { dg-final { scan-tree-dump-times \"{ sin cos }\" 1 \"alias1\"} } */\n /* { dg-final { cleanup-tree-dump \"alias1\" } } */"}, {"sha": "cf317de81fdb07a8d6e65ac837437d19a7f190a7", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21392f1922a60cff99a2f8f25852badbc516bd0f/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21392f1922a60cff99a2f8f25852badbc516bd0f/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=21392f1922a60cff99a2f8f25852badbc516bd0f", "patch": "@@ -2103,24 +2103,17 @@ set_pt_anything (tree ptr)\n \t3- STMT is an assignment to a non-local variable, or\n \t4- STMT is a return statement.\n \n-   AI points to the alias information collected so far.  \n-\n    Return the type of escape site found, if we found one, or NO_ESCAPE\n    if none.  */\n \n enum escape_type\n-is_escape_site (tree stmt, struct alias_info *ai)\n+is_escape_site (tree stmt)\n {\n   tree call = get_call_expr_in (stmt);\n   if (call != NULL_TREE)\n     {\n-      ai->num_calls_found++;\n-\n       if (!TREE_SIDE_EFFECTS (call))\n-\t{\n-\t  ai->num_pure_const_calls_found++;\n-\t  return ESCAPE_TO_PURE_CONST;\n-\t}\n+\treturn ESCAPE_TO_PURE_CONST;\n \n       return ESCAPE_TO_CALL;\n     }"}, {"sha": "0efbe0f3ae28edac6489f92092720b217d092e21", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21392f1922a60cff99a2f8f25852badbc516bd0f/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21392f1922a60cff99a2f8f25852badbc516bd0f/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=21392f1922a60cff99a2f8f25852badbc516bd0f", "patch": "@@ -1053,6 +1053,9 @@ access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n   if (alias == global_var)\n     return true;\n \n+  if (TREE_CODE (alias) == VAR_DECL && DECL_PTA_ARTIFICIAL (alias))\n+    return true;\n+\n   /* If ALIAS is an SFT, it can't be touched if the offset     \n      and size of the access is not overlapping with the SFT offset and\n      size.  This is only true if we are accessing through a pointer"}, {"sha": "b1f125a8679d7c6ed0e2f9c245436ac7e13e415e", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 625, "deletions": 148, "changes": 773, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21392f1922a60cff99a2f8f25852badbc516bd0f/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21392f1922a60cff99a2f8f25852badbc516bd0f/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=21392f1922a60cff99a2f8f25852badbc516bd0f", "patch": "@@ -162,7 +162,17 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n   worth the pain or slowdown.  */\n \n static GTY ((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map))) \n-  htab_t heapvar_for_stmt;\n+htab_t heapvar_for_stmt;\n+\n+\n+/* Represents nonlocals. */\n+static GTY ((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map)))\n+htab_t nonlocal_for_type;\n+\n+/* If strict aliasing is off, we only use one variable to represent\n+   the nonlocal types.  */\n+static GTY (()) tree nonlocal_all;\n+\n static bool use_field_sensitive = true;\n static int in_ipa_mode = 0;\n static bitmap_obstack predbitmap_obstack;\n@@ -223,6 +233,12 @@ struct variable_info\n   /* True if this variable is the target of a dereference.  Needed for\n      variable substitution.  */\n   unsigned int indirect_target:1;\n+  \n+  /* True if the variable is directly the target of a dereference.\n+     This is used to track which variables are *actually* dereferenced\n+     so we can prune their points to listed. This is equivalent to the\n+     indirect_target flag when no merging of variables happens.  */\n+  unsigned int directly_dereferenced:1;\n \n   /* True if this is a variable created by the constraint analysis, such as\n      heap variables and constraints we had to break up.  */\n@@ -312,6 +328,15 @@ static varinfo_t var_integer;\n static tree integer_tree;\n static unsigned int integer_id;\n \n+/* Variable that represents escaped variables.  This is used to give\n+   incoming pointer variables a better set than ANYTHING.  */\n+static varinfo_t var_escaped_vars;\n+static tree escaped_vars_tree;\n+static unsigned int escaped_vars_id;\n+\n+/* Variable that represents non-local variables before we expand it to\n+   one for each type.  */\n+static unsigned int nonlocal_vars_id;\n \n /* Lookup a heap var for FROM, and return it if we find one.  */\n \n@@ -342,7 +367,7 @@ heapvar_insert (tree from, tree to)\n   h->to = to;\n   loc = htab_find_slot_with_hash (heapvar_for_stmt, h, h->hash, INSERT);\n   *(struct tree_map **) loc = h;\n-}  \n+}\n \n /* Return a new variable info structure consisting for a variable\n    named NAME, and using constraint graph node NODE.  */\n@@ -358,6 +383,7 @@ new_var_info (tree t, unsigned int id, const char *name, unsigned int node)\n   ret->node = node;\n   ret->address_taken = false;\n   ret->indirect_target = false;\n+  ret->directly_dereferenced = false;\n   ret->is_artificial_var = false;\n   ret->is_heap_var = false;\n   ret->is_special_var = false;\n@@ -466,6 +492,7 @@ struct constraint_graph\n typedef struct constraint_graph *constraint_graph_t;\n \n static constraint_graph_t graph;\n+static int graph_size;\n \n /* Create a new constraint consisting of LHS and RHS expressions.  */\n \n@@ -1181,10 +1208,11 @@ build_constraint_graph (void)\n   constraint_t c;\n \n   graph = XNEW (struct constraint_graph);\n-  graph->succs = XCNEWVEC (VEC(constraint_edge_t,heap) *, VEC_length (varinfo_t, varmap) + 1);\n-  graph->preds = XCNEWVEC (VEC(constraint_edge_t,heap) *, VEC_length (varinfo_t, varmap) + 1);\n-  graph->zero_weight_succs = XCNEWVEC (bitmap, VEC_length (varinfo_t, varmap) + 1);\n-  graph->zero_weight_preds = XCNEWVEC (bitmap, VEC_length (varinfo_t, varmap) + 1);\n+  graph_size = VEC_length (varinfo_t, varmap) + 1;\n+  graph->succs = XCNEWVEC (VEC(constraint_edge_t,heap) *, graph_size);\n+  graph->preds = XCNEWVEC (VEC(constraint_edge_t,heap) *, graph_size);\n+  graph->zero_weight_succs = XCNEWVEC (bitmap, graph_size);\n+  graph->zero_weight_preds = XCNEWVEC (bitmap, graph_size);\n \n   for (i = 0; VEC_iterate (constraint_t, constraints, i, c); i++)\n     {\n@@ -2027,54 +2055,70 @@ solve_graph (constraint_graph_t graph)\n \t      bitmap_iterator bi;\n \t      VEC(constraint_t,heap) *complex = get_varinfo (i)->complex;\n \t      VEC(constraint_edge_t,heap) *succs;\n+\t      bool solution_empty;\n \n \t      RESET_BIT (changed, i);\n \t      changed_count--;\n \n-\t      /* Process the complex constraints */\n \t      solution = get_varinfo (i)->solution;\n+\t      solution_empty = bitmap_empty_p (solution);\n+\n+\t      /* Process the complex constraints */\n \t      for (j = 0; VEC_iterate (constraint_t, complex, j, c); j++)\n-\t\tdo_complex_constraint (graph, c, solution);\n+\t\t{\n+\t\t  /* The only complex constraint that can change our\n+\t\t     solution to non-empty, given an empty solution,\n+\t\t     is a constraint where the lhs side is receiving\n+\t\t     some set from elsewhere.  */\n+\t\t  if (!solution_empty || c->lhs.type != DEREF)\n+\t\t    do_complex_constraint (graph, c, solution);\n+\t\t}\n \n-\t      /* Propagate solution to all successors.  */\n-\t      succs = graph->succs[i];\n-\t      \n-\t      EXECUTE_IF_IN_NONNULL_BITMAP (graph->zero_weight_succs[i], 0, j, bi)\n+\t      solution_empty = bitmap_empty_p (solution);\n+\n+\t      if (!solution_empty)\n \t\t{\n-\t\t  bitmap tmp = get_varinfo (j)->solution;\n-\t\t  bool flag = false;\n-\t\t  \n-\t\t  flag = set_union_with_increment (tmp, solution, 0);\n+\t\t  /* Propagate solution to all successors.  */\n+\t\t  succs = graph->succs[i];\n \t\t  \n-\t\t  if (flag)\n+\t\t  EXECUTE_IF_IN_NONNULL_BITMAP (graph->zero_weight_succs[i], \n+\t\t\t\t\t\t0, j, bi)\n \t\t    {\n-\t\t      get_varinfo (j)->solution = tmp;\n-\t\t      if (!TEST_BIT (changed, j))\n+\t\t      bitmap tmp = get_varinfo (j)->solution;\n+\t\t      bool flag = false;\n+\t\t  \n+\t\t      flag = set_union_with_increment (tmp, solution, 0);\n+\t\t  \n+\t\t      if (flag)\n \t\t\t{\n-\t\t\t  SET_BIT (changed, j);\n-\t\t\t  changed_count++;\n+\t\t\t  get_varinfo (j)->solution = tmp;\n+\t\t\t  if (!TEST_BIT (changed, j))\n+\t\t\t    {\n+\t\t\t      SET_BIT (changed, j);\n+\t\t\t      changed_count++;\n+\t\t\t    }\n \t\t\t}\n \t\t    }\n-\t\t}\n-\t      for (j = 0; VEC_iterate (constraint_edge_t, succs, j, e); j++)\n-\t\t{\n-\t\t  bitmap tmp = get_varinfo (e->dest)->solution;\n-\t\t  bool flag = false;\n-\t\t  unsigned int k;\n-\t\t  bitmap weights = e->weights;\n-\t\t  bitmap_iterator bi;\n+\t\t  for (j = 0; VEC_iterate (constraint_edge_t, succs, j, e); j++)\n+\t\t    {\n+\t\t      bitmap tmp = get_varinfo (e->dest)->solution;\n+\t\t      bool flag = false;\n+\t\t      unsigned int k;\n+\t\t      bitmap weights = e->weights;\n+\t\t      bitmap_iterator bi;\n \n-\t\t  gcc_assert (weights && !bitmap_empty_p (weights));\n-\t\t  EXECUTE_IF_SET_IN_BITMAP (weights, 0, k, bi)\n-\t\t    flag |= set_union_with_increment (tmp, solution, k);\n+\t\t      gcc_assert (weights && !bitmap_empty_p (weights));\n+\t\t      EXECUTE_IF_SET_IN_BITMAP (weights, 0, k, bi)\n+\t\t\tflag |= set_union_with_increment (tmp, solution, k);\n \n-\t\t  if (flag)\n-\t\t    {\n-\t\t      get_varinfo (e->dest)->solution = tmp;\n-\t\t      if (!TEST_BIT (changed, e->dest))\n+\t\t      if (flag)\n \t\t\t{\n-\t\t\t  SET_BIT (changed, e->dest);\n-\t\t\t  changed_count++;\n+\t\t\t  get_varinfo (e->dest)->solution = tmp;\n+\t\t\t  if (!TEST_BIT (changed, e->dest))\n+\t\t\t    {\n+\t\t\t      SET_BIT (changed, e->dest);\n+\t\t\t      changed_count++;\n+\t\t\t    }\n \t\t\t}\n \t\t    }\n \t\t}\n@@ -2248,6 +2292,11 @@ process_constraint (constraint_t t)\n   gcc_assert (rhs.var < VEC_length (varinfo_t, varmap));\n   gcc_assert (lhs.var < VEC_length (varinfo_t, varmap));\n \n+  if (lhs.type == DEREF)\n+    get_varinfo (lhs.var)->directly_dereferenced = true;\n+  if (rhs.type == DEREF)\n+    get_varinfo (rhs.var)->directly_dereferenced = true;\n+  \n   /* ANYTHING == ANYTHING is pointless.  */\n   if (lhs.var == anything_id && rhs.var == anything_id)\n     return;\n@@ -2297,6 +2346,19 @@ process_constraint (constraint_t t)\n     }\n }\n \n+/* Return true if T is a variable of a type that could contain\n+   pointers.  */\n+\n+static bool\n+could_have_pointers (tree t)\n+{\n+  tree type = TREE_TYPE (t);\n+  \n+  if (POINTER_TYPE_P (type) || AGGREGATE_TYPE_P (type)\n+      || TREE_CODE (type) == COMPLEX_TYPE)\n+    return true;\n+  return false;\n+}\n \n /* Return the position, in bits, of FIELD_DECL from the beginning of its\n    structure.  */\n@@ -2364,6 +2426,12 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results)\n     }\n  \n   t = get_ref_base_and_extent (t, &bitpos, &bitsize, &bitmaxsize);\n+\n+  /* String constants's are readonly, so there is nothing to really do\n+     here.  */\n+  if (TREE_CODE (t) == STRING_CST)\n+    return;\n+\n   get_constraint_for (t, results);\n   result = VEC_last (ce_s, *results);\n   result->offset = bitpos;\n@@ -2448,6 +2516,105 @@ do_deref (VEC (ce_s, heap) **constraints)\n     }\n }\n \n+/* Lookup a nonlocal variable for type FROM, and return it if we find\n+   one.  */\n+\n+static tree \n+nonlocal_lookup (tree from)\n+{\n+  struct tree_map *h, in;\n+  in.from = from;\n+\n+  h = htab_find_with_hash (nonlocal_for_type, &in,\n+\t\t\t   htab_hash_pointer (from));\n+  if (h)\n+    return h->to;\n+  return NULL_TREE;\n+}\n+\n+/* Insert a mapping FROM->TO in the nonlocal variable for type\n+   hashtable.  */\n+\n+static void\n+nonlocal_insert (tree from, tree to)\n+{\n+  struct tree_map *h;\n+  void **loc;\n+\n+  h = ggc_alloc (sizeof (struct tree_map));\n+  h->hash = htab_hash_pointer (from);\n+  h->from = from;\n+  h->to = to;\n+  loc = htab_find_slot_with_hash (nonlocal_for_type, h, h->hash,\n+\t\t\t\t  INSERT);\n+  *(struct tree_map **) loc = h;\n+}\n+\n+/* Create a nonlocal variable of TYPE to represent nonlocals we can\n+   alias.  */\n+\n+static tree\n+create_nonlocal_var (tree type)\n+{\n+  tree nonlocal = create_tmp_var_raw (type, \"NONLOCAL\");\n+  \n+  if (referenced_vars)\n+    add_referenced_var (nonlocal);\n+\n+  DECL_PTA_ARTIFICIAL (nonlocal) = 1;\n+  DECL_EXTERNAL (nonlocal) = 1;\n+  nonlocal_insert (type, nonlocal);\n+  return nonlocal;\n+}\n+\n+/* Get or create a nonlocal variable for TYPE, and return its\n+   variable info id.  */\n+\n+static unsigned int\n+get_nonlocal_id_for_type (tree type)\n+{\n+  tree nonlocal;\n+  unsigned int nonlocal_id;\n+  varinfo_t nonlocal_vi;\n+  \n+  /* For strict aliasing, we have one variable per type. For\n+     non-strict aliasing, we only need one variable.  */\n+  if (flag_strict_aliasing != 0)\n+    {\n+      nonlocal  = nonlocal_lookup (type);\n+    }\n+  else\n+    {\n+      if (!nonlocal_all)\n+\t{\n+\t  nonlocal = create_nonlocal_var (void_type_node);\n+\t  nonlocal_all = nonlocal;\n+\t}\n+      else\n+\tnonlocal = nonlocal_all;\n+    }\n+  \n+  if (nonlocal && lookup_id_for_tree (nonlocal, &nonlocal_id))\n+    return nonlocal_id;\n+\n+  if (!nonlocal)\n+    {\n+      gcc_assert (flag_strict_aliasing != 0);\n+      nonlocal = create_nonlocal_var (type);\n+    }\n+  \n+  /* Create variable info for the nonlocal var if it does not\n+     exist.  */\n+  nonlocal_id = create_variable_info_for (nonlocal,\n+\t\t\t\t\t  get_name (nonlocal));\n+  nonlocal_vi = get_varinfo (nonlocal_id);\n+  nonlocal_vi->is_artificial_var = 1;\n+  nonlocal_vi->is_heap_var = 1; \n+  nonlocal_vi->is_unknown_size_var = 1;\n+  nonlocal_vi->directly_dereferenced = true;\n+\t    \n+  return nonlocal_id;\n+}\n \n /* Given a tree T, return the constraint expression for it.  */\n \n@@ -2507,6 +2674,9 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n \t\t  varinfo_t origvar;\n \t\t  struct constraint_expr tmp;\n \n+\t\t  if (VEC_length (ce_s, *results) == 0)\n+\t\t    return;\n+\t\t  \n \t\t  gcc_assert (VEC_length (ce_s, *results) == 1);\n \t\t  origrhs = VEC_last (ce_s, *results);\n \t\t  tmp = *origrhs;\n@@ -2549,7 +2719,6 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n \t    }\n \t    break;\n \t  case CALL_EXPR:\n-\t    \n \t    /* XXX: In interprocedural mode, if we didn't have the\n \t       body, we would need to do *each pointer argument =\n \t       &ANYTHING added.  */\n@@ -2578,7 +2747,16 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n \t\tVEC_safe_push (ce_s, heap, *results, &temp);\n \t\treturn;\n \t      }\n-\t    /* FALLTHRU */\n+\t    else\n+\t      {\n+\t\ttemp.var = escaped_vars_id;\n+\t\ttemp.type = SCALAR;\n+\t\ttemp.offset = 0;\n+\t\tVEC_safe_push (ce_s, heap, *results, &temp);\n+\t\treturn;\n+\t      }\n+\t    break;\n+\t    \n \t  default:\n \t    {\n \t      temp.type = ADDRESSOF;\n@@ -2974,9 +3152,17 @@ update_alias_info (tree stmt, struct alias_info *ai)\n   bitmap addr_taken;\n   use_operand_p use_p;\n   ssa_op_iter iter;\n-  enum escape_type stmt_escape_type = is_escape_site (stmt, ai);\n+  enum escape_type stmt_escape_type = is_escape_site (stmt);\n   tree op;\n \n+  if (stmt_escape_type == ESCAPE_TO_CALL\n+      || stmt_escape_type == ESCAPE_TO_PURE_CONST)\n+    {\n+      ai->num_calls_found++;\n+      if (stmt_escape_type == ESCAPE_TO_PURE_CONST)\n+\tai->num_pure_const_calls_found++;\n+    }\n+\n   /* Mark all the variables whose address are taken by the statement.  */\n   addr_taken = addresses_taken (stmt);\n   if (addr_taken)\n@@ -3257,8 +3443,7 @@ find_func_aliases (tree origt)\n \n       /* Only care about pointers and structures containing\n \t pointers.  */\n-      if (POINTER_TYPE_P (TREE_TYPE (PHI_RESULT (t)))\n-\t  || TREE_CODE (TREE_TYPE (PHI_RESULT (t))) == COMPLEX_TYPE)\n+      if (could_have_pointers (PHI_RESULT (t)))\n \t{\n \t  int i;\n \t  unsigned int j;\n@@ -3407,9 +3592,7 @@ find_func_aliases (tree origt)\n \t{\n \t  /* Only care about operations with pointers, structures\n \t     containing pointers, dereferences, and call expressions.  */\n-\t  if (POINTER_TYPE_P (TREE_TYPE (lhsop))\n-\t      || AGGREGATE_TYPE_P (TREE_TYPE (lhsop))\n-\t      || TREE_CODE (TREE_TYPE (lhsop)) == COMPLEX_TYPE\n+\t  if (could_have_pointers (lhsop)\n \t      || TREE_CODE (rhsop) == CALL_EXPR)\n \t    {\n \t      get_constraint_for (lhsop, &lhsc);\n@@ -3712,18 +3895,34 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n   return count;\n }\n \n+/* Create a constraint from ESCAPED_VARS variable to VI.  */\n static void\n-make_constraint_to_anything (varinfo_t vi)\n+make_constraint_from_escaped (varinfo_t vi)\n {\n   struct constraint_expr lhs, rhs;\n   \n   lhs.var = vi->id;\n   lhs.offset = 0;\n   lhs.type = SCALAR;\n   \n-  rhs.var = anything_id;\n-  rhs.offset =0 ;\n-  rhs.type = ADDRESSOF;\n+  rhs.var = escaped_vars_id;\n+  rhs.offset = 0;\n+  rhs.type = SCALAR;\n+  process_constraint (new_constraint (lhs, rhs));\n+}\n+\n+/* Create a constraint to the ESCAPED_VARS variable from constraint\n+   expression RHS. */\n+\n+static void\n+make_constraint_to_escaped (struct constraint_expr rhs)\n+{\n+  struct constraint_expr lhs;\n+  \n+  lhs.var = escaped_vars_id;\n+  lhs.offset = 0;\n+  lhs.type = SCALAR;\n+\n   process_constraint (new_constraint (lhs, rhs));\n }\n \n@@ -3876,6 +4075,55 @@ check_for_overlaps (VEC (fieldoff_s,heap) *fieldstack)\n     }\n   return false;\n }\n+\n+/* This function is called through walk_tree to walk global\n+   initializers looking for constraints we need to add to the\n+   constraint list.  */\n+\n+static tree\n+find_global_initializers (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t\t  void *viv)\n+{\n+  varinfo_t vi = (varinfo_t)viv;\n+  tree t = *tp;\n+\n+  switch (TREE_CODE (t))\n+    {\n+      /* Dereferences and addressofs are the only important things\n+\t here, and i don't even remember if dereferences are legal\n+\t here in initializers.  */\n+    case INDIRECT_REF:\n+    case ADDR_EXPR:\n+      {\n+\tstruct constraint_expr *c;\n+\tsize_t i;\n+\t\n+\tVEC(ce_s, heap) *rhsc = NULL;\n+\tget_constraint_for (t, &rhsc);\n+\tfor (i = 0; VEC_iterate (ce_s, rhsc, i, c); i++)\n+\t  {\n+\t    struct constraint_expr lhs;\n+\t    \n+\t    lhs.var = vi->id;\n+\t    lhs.type = SCALAR;\n+\t    lhs.offset = 0;\n+\t    process_constraint (new_constraint (lhs, *c));\n+\t  }\n+\n+\tVEC_free (ce_s, heap, rhsc);\n+      }\n+      break;\n+    case VAR_DECL:\n+      /* We might not have walked this because we skip\n+\t DECL_EXTERNALs during the initial scan.  */\n+      add_referenced_var (t);   \n+      break;\n+    default:\n+      break;\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Create a varinfo structure for NAME and DECL, and add it to VARMAP.\n    This will also create any varinfo structures necessary for fields\n    of DECL.  */\n@@ -3933,7 +4181,27 @@ create_variable_info_for (tree decl, const char *name)\n   insert_id_for_tree (vi->decl, index);  \n   VEC_safe_push (varinfo_t, heap, varmap, vi);\n   if (is_global && (!flag_whole_program || !in_ipa_mode))\n-    make_constraint_to_anything (vi);\n+    {\n+      make_constraint_from_escaped (vi);\n+\n+      /* If the variable can't be aliased, there is no point in\n+\t putting it in the set of nonlocal vars.  */\n+      if (may_be_aliased (vi->decl))\n+\t{\n+\t  struct constraint_expr rhs;\n+\t  rhs.var = index;\n+\t  rhs.type = ADDRESSOF;\n+\t  rhs.offset = 0;\n+\t  make_constraint_to_escaped (rhs);\n+\t} \n+\n+      if (TREE_CODE (decl) != FUNCTION_DECL && DECL_INITIAL (decl))\n+\t{\n+\t  walk_tree_without_duplicates (&DECL_INITIAL (decl),\n+\t\t\t\t\tfind_global_initializers,\n+\t\t\t\t\t(void *)vi);\n+\t}\n+    }\n \n   stats.total_vars++;\n   if (use_field_sensitive \n@@ -4013,8 +4281,21 @@ create_variable_info_for (tree decl, const char *name)\n \t  insert_into_field_list (vi, newvi);\n \t  VEC_safe_push (varinfo_t, heap, varmap, newvi);\n \t  if (is_global && (!flag_whole_program || !in_ipa_mode))\n-\t    make_constraint_to_anything (newvi);\n-\n+\t    {\n+\t      /* If the variable can't be aliased, there is no point in\n+\t\t putting it in the set of nonlocal vars.  */\n+\t      if (may_be_aliased (vi->decl))\n+\t\t{\n+\t\t  struct constraint_expr rhs;\n+\t      \n+\t\t  rhs.var = newindex;\n+\t\t  rhs.type = ADDRESSOF;\n+\t\t  rhs.offset = 0;\n+\t\t  make_constraint_to_escaped (rhs);\n+\t\t} \n+\t      make_constraint_from_escaped (newvi);\n+\t    }\n+\t  \n \t  stats.total_vars++;\n \t}\n       VEC_free (fieldoff_s, heap, fieldstack);\n@@ -4047,25 +4328,27 @@ debug_solution_for_var (unsigned int var)\n   dump_solution_for_var (stdout, var);\n }\n \n-\n /* Create varinfo structures for all of the variables in the\n    function for intraprocedural mode.  */\n \n static void\n intra_create_variable_infos (void)\n {\n   tree t;\n-\n-  /* For each incoming argument arg, ARG = &ANYTHING or a dummy variable if\n-     flag_argument_noalias > 2. */\n+  struct constraint_expr lhs, rhs;\n+  tree nonlocal;\n+  varinfo_t nonlocal_vi;\n+  /* For each incoming pointer argument arg, ARG = ESCAPED_VARS or a\n+     dummy variable if flag_argument_noalias > 2. */\n   for (t = DECL_ARGUMENTS (current_function_decl); t; t = TREE_CHAIN (t))\n     {\n-      struct constraint_expr lhs;\n       varinfo_t p;\n+      unsigned int arg_id;\n+      \n+      if (!could_have_pointers (t))\n+\tcontinue;\n       \n-      lhs.offset = 0;\n-      lhs.type = SCALAR;\n-      lhs.var  = create_variable_info_for (t, alias_get_name (t));\n+      arg_id = get_id_for_tree (t);\n \n       /* With flag_argument_noalias greater than two means that the incoming\n          argument cannot alias anything except for itself so create a HEAP\n@@ -4074,9 +4357,13 @@ intra_create_variable_infos (void)\n \t  && flag_argument_noalias > 2)\n \t{\n \t  varinfo_t vi;\n-\t  struct constraint_expr rhs;\n \t  tree heapvar = heapvar_lookup (t);\n \t  unsigned int id;\n+\t  \n+\t  lhs.offset = 0;\n+\t  lhs.type = SCALAR;\n+\t  lhs.var  = get_id_for_tree (t);\n+\t  \n \t  if (heapvar == NULL_TREE)\n \t    {\n \t      heapvar = create_tmp_var_raw (TREE_TYPE (TREE_TYPE (t)), \n@@ -4086,8 +4373,7 @@ intra_create_variable_infos (void)\n \t\tadd_referenced_var (heapvar);\n \t      heapvar_insert (t, heapvar);\n \t    }\n-\t  id = create_variable_info_for (heapvar,\n-\t\t\t\t\t alias_get_name (heapvar));\n+\t  id = get_id_for_tree (heapvar);\n \t  vi = get_varinfo (id);\n \t  vi->is_artificial_var = 1;\n \t  vi->is_heap_var = 1;\n@@ -4102,25 +4388,54 @@ intra_create_variable_infos (void)\n \t    }\n \t}\n       else      \n-\tfor (p = get_varinfo (lhs.var); p; p = p->next)\n-\t  make_constraint_to_anything (p);\n-    }\t\n+\t{\n+\t  for (p = get_varinfo (arg_id); p; p = p->next)\n+\t    make_constraint_from_escaped (p);\n+\t}\n+    }\n+  nonlocal = create_tmp_var_raw (void_type_node, \"NONLOCAL_ALL\");\n+  \n+  DECL_EXTERNAL (nonlocal) = 1;\n+\n+  /* Create variable info for the nonlocal var if it does not\n+     exist.  */\n+  nonlocal_vars_id = create_variable_info_for (nonlocal,\n+\t\t\t\t\t       get_name (nonlocal));\n+  nonlocal_vi = get_varinfo (nonlocal_vars_id);\n+  nonlocal_vi->is_artificial_var = 1;\n+  nonlocal_vi->is_heap_var = 1; \n+  nonlocal_vi->is_unknown_size_var = 1;\n+  nonlocal_vi->directly_dereferenced = true;\n+\n+  rhs.var = nonlocal_vars_id;\n+  rhs.type = ADDRESSOF;\n+  rhs.offset = 0;\n+  \n+  lhs.var = escaped_vars_id;\n+  lhs.type = SCALAR;\n+  lhs.offset = 0;\n+  \n+  process_constraint (new_constraint (lhs, rhs));\n }\n \n /* Set bits in INTO corresponding to the variable uids in solution set\n-   FROM  */\n+   FROM, which came from variable PTR.\n+   For variables that are actually dereferenced, we also use type\n+   based alias analysis to prune the points-to sets.  */\n \n static void\n-set_uids_in_ptset (bitmap into, bitmap from)\n+set_uids_in_ptset (tree ptr, bitmap into, bitmap from)\n {\n   unsigned int i;\n   bitmap_iterator bi;\n   subvar_t sv;\n+  unsigned HOST_WIDE_INT ptr_alias_set = get_alias_set (TREE_TYPE (ptr));\n \n   EXECUTE_IF_SET_IN_BITMAP (from, 0, i, bi)\n     {\n       varinfo_t vi = get_varinfo (i);\n-\n+      unsigned HOST_WIDE_INT var_alias_set;\n+      \n       /* The only artificial variables that are allowed in a may-alias\n \t set are heap variables.  */\n       if (vi->is_artificial_var && !vi->is_heap_var)\n@@ -4137,18 +4452,32 @@ set_uids_in_ptset (bitmap into, bitmap from)\n \t       || TREE_CODE (vi->decl) == PARM_DECL)\n \t{\n \t  if (var_can_have_subvars (vi->decl)\n-\t\t   && get_subvars_for_var (vi->decl))\n+\t      && get_subvars_for_var (vi->decl))\n \t    {\n \t      /* If VI->DECL is an aggregate for which we created\n \t\t SFTs, add the SFT corresponding to VI->OFFSET.  */\n \t      tree sft = get_subvar_at (vi->decl, vi->offset);\n \t      if (sft)\n-\t\tbitmap_set_bit (into, DECL_UID (sft));\n+\t\t{\n+\t\t  var_alias_set = get_alias_set (sft);\n+\t\t  if (!vi->directly_dereferenced\n+\t\t      || alias_sets_conflict_p (ptr_alias_set, var_alias_set))\n+\t\t    bitmap_set_bit (into, DECL_UID (sft));\n+\t\t}\n \t    }\n \t  else\n \t    {\n-\t      /* Otherwise, just add VI->DECL to the alias set.  */\n-\t      bitmap_set_bit (into, DECL_UID (vi->decl));\n+\t      /* Otherwise, just add VI->DECL to the alias set.\n+\t\t Don't type prune artificial vars.  */\n+\t      if (vi->is_artificial_var)\n+\t\tbitmap_set_bit (into, DECL_UID (vi->decl));\n+\t      else\n+\t\t{\n+\t\t  var_alias_set = get_alias_set (vi->decl);\n+\t\t  if (!vi->directly_dereferenced\n+\t\t      || alias_sets_conflict_p (ptr_alias_set, var_alias_set))\n+\t\t    bitmap_set_bit (into, DECL_UID (vi->decl));\n+\t\t}\n \t    }\n \t}\n     }\n@@ -4179,7 +4508,7 @@ find_what_p_points_to (tree p)\n   if (lookup_id_for_tree (lookup_p, &id))\n     {\n       varinfo_t vi = get_varinfo (id);\n-      \n+\n       if (vi->is_artificial_var)\n \treturn false;\n \n@@ -4233,7 +4562,7 @@ find_what_p_points_to (tree p)\n \t  if (!pi->pt_vars)\n \t    pi->pt_vars = BITMAP_GGC_ALLOC ();\n \n-\t  set_uids_in_ptset (pi->pt_vars, vi->solution);\n+\t  set_uids_in_ptset (vi->decl, pi->pt_vars, vi->solution);\n \n \t  if (bitmap_empty_p (pi->pt_vars))\n \t    pi->pt_vars = NULL;\n@@ -4375,55 +4704,40 @@ init_base_vars (void)\n   integer_id = 3;\n   VEC_safe_push (varinfo_t, heap, varmap, var_integer);\n \n-  /* *INTEGER = ANYTHING, because we don't know where a dereference of a random\n-     integer will point to.  */\n+  /* INTEGER = ANYTHING, because we don't know where a dereference of\n+     a random integer will point to.  */\n   lhs.type = SCALAR;\n   lhs.var = integer_id;\n   lhs.offset = 0;\n   rhs.type = ADDRESSOF;\n   rhs.var = anything_id;\n   rhs.offset = 0;\n   process_constraint (new_constraint (lhs, rhs));\n+  \n+  /* Create the ESCAPED_VARS variable used to represent variables that\n+     escape this function.  */\n+  escaped_vars_tree = create_tmp_var_raw (void_type_node, \"ESCAPED_VARS\");\n+  var_escaped_vars = new_var_info (escaped_vars_tree, 4, \"ESCAPED_VARS\", 4);\n+  insert_id_for_tree (escaped_vars_tree, 4);\n+  var_escaped_vars->is_artificial_var = 1;\n+  var_escaped_vars->size = ~0;\n+  var_escaped_vars->fullsize = ~0;\n+  var_escaped_vars->offset = 0;\n+  var_escaped_vars->next = NULL;\n+  escaped_vars_id = 4;\n+  VEC_safe_push (varinfo_t, heap, varmap, var_escaped_vars);\n+\n+  /* ESCAPED_VARS = *ESCAPED_VARS */\n+  lhs.type = SCALAR;\n+  lhs.var = escaped_vars_id;\n+  lhs.offset = 0;\n+  rhs.type = DEREF;\n+  rhs.var = escaped_vars_id;\n+  rhs.offset = 0;\n+  process_constraint (new_constraint (lhs, rhs));\n+  \n }  \n \n-/* Return true if we actually need to solve the constraint graph in order to\n-   get our points-to sets.  This is false when, for example, no addresses are\n-   taken other than special vars, or all points-to sets with members already\n-   contain the anything variable and there are no predecessors for other\n-   sets.  */\n-\n-static bool\n-need_to_solve (void)\n-{\n-  int i;\n-  varinfo_t v;\n-  bool found_address_taken = false;\n-  bool found_non_anything = false;\n-\n-  for (i = 0; VEC_iterate (varinfo_t, varmap, i, v); i++)\n-    {\n-      if (v->is_special_var)\n-\tcontinue;\n-\n-      if (v->address_taken)\n-\tfound_address_taken = true;\n-\n-      if (v->solution \n-\t  && !bitmap_empty_p (v->solution) \n-\t  && !bitmap_bit_p (v->solution, anything_id))\n-\tfound_non_anything = true;\n-      else if (bitmap_empty_p (v->solution)\n-\t       && (VEC_length (constraint_edge_t, graph->preds[v->id]) != 0\n-\t\t || (graph->zero_weight_preds[v->id] && !bitmap_empty_p (graph->zero_weight_preds[v->id]))))\n-\tfound_non_anything = true;\n-\n-      if (found_address_taken && found_non_anything)\n-\treturn true;\n-    }\n-\n-  return false;\n-}\n-\n /* Initialize things necessary to perform PTA */\n \n static void\n@@ -4447,7 +4761,160 @@ init_alias_vars (void)\n   init_base_vars ();\n }\n \n+/* Given a statement STMT, generate necessary constraints to\n+   escaped_vars for the escaping variables.  */\n+\n+static void\n+find_escape_constraints (tree stmt)\n+{\n+  enum escape_type stmt_escape_type = is_escape_site (stmt);\n+  tree rhs;\n+  VEC(ce_s, heap) *rhsc = NULL;\n+  struct constraint_expr *c;\n+  size_t i;\n+\n+  if (stmt_escape_type == NO_ESCAPE)\n+    return;\n+\n+  if (TREE_CODE (stmt) == RETURN_EXPR)\n+    {\n+      /* Returns are either bare, with an embedded MODIFY_EXPR, or\n+\t just a plain old expression.  */\n+      if (!TREE_OPERAND (stmt, 0))\n+\treturn;\n+      if (TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR)\n+\trhs = TREE_OPERAND (TREE_OPERAND (stmt, 0), 1);\n+      else\n+\trhs = TREE_OPERAND (stmt, 0);\n+\n+      get_constraint_for (rhs, &rhsc);\n+      for (i = 0; VEC_iterate (ce_s, rhsc, i, c); i++)\n+\tmake_constraint_to_escaped (*c);\n+      VEC_free (ce_s, heap, rhsc);\n+      return;\n+    }\n+  else if (TREE_CODE (stmt) == ASM_EXPR)\n+    {\n+      /* Whatever the inputs of the ASM are, escape.  */\n+      tree arg;\n+\n+      for (arg = ASM_INPUTS (stmt); arg; arg = TREE_CHAIN (arg))\n+\t{\n+\t  rhsc = NULL;\n+\t  get_constraint_for (TREE_VALUE (arg), &rhsc);\n+\t  for (i = 0; VEC_iterate (ce_s, rhsc, i, c); i++)\n+\t    make_constraint_to_escaped (*c);\n+\t  VEC_free (ce_s, heap, rhsc);\n+\t}\n+      return;\n+    }\n+  else if (TREE_CODE (stmt) == CALL_EXPR\n+\t   || (TREE_CODE (stmt) == MODIFY_EXPR\n+\t       && TREE_CODE (TREE_OPERAND (stmt, 1)) == CALL_EXPR))\n+    {\n+      /* Calls cause all of the arguments passed in to escape.  */\n+      tree arg;\n+\n+      if (TREE_CODE (stmt) == MODIFY_EXPR)\n+\tstmt = TREE_OPERAND (stmt, 1);\n+      for (arg = TREE_OPERAND (stmt, 1); arg; arg = TREE_CHAIN (arg))\n+\t{\n+\t  if (POINTER_TYPE_P (TREE_TYPE (TREE_VALUE (arg))))\n+\t    {\n+\t      rhsc = NULL;\n+\t      get_constraint_for (TREE_VALUE (arg), &rhsc);\n+\t      for (i = 0; VEC_iterate (ce_s, rhsc, i, c); i++)\n+\t\tmake_constraint_to_escaped (*c);\n+\t      VEC_free (ce_s, heap, rhsc);\n+\t    }\n+\t}\n+      return;\n+    }\n+  else\n+    {\n+      gcc_assert (TREE_CODE (stmt) == MODIFY_EXPR);\n+    }\n+\n+  gcc_assert (stmt_escape_type == ESCAPE_BAD_CAST\n+\t      || stmt_escape_type == ESCAPE_STORED_IN_GLOBAL\n+\t      || stmt_escape_type == ESCAPE_UNKNOWN);\n+  rhs = TREE_OPERAND (stmt, 1);\n+  \n+  /* Look through casts for the real escaping variable.\n+     Constants don't really escape, so ignore them.\n+     Otherwise, whatever escapes must be on our RHS.  */\n+  if (TREE_CODE (rhs) == NOP_EXPR\n+      || TREE_CODE (rhs) == CONVERT_EXPR\n+      || TREE_CODE (rhs) == NON_LVALUE_EXPR)\n+    {\n+      get_constraint_for (TREE_OPERAND (rhs, 0), &rhsc);\n+    }\n+  else if (CONSTANT_CLASS_P (rhs))\n+    return;\n+  else\n+    {\n+      get_constraint_for (rhs, &rhsc);\n+    }\n+  for (i = 0; VEC_iterate (ce_s, rhsc, i, c); i++)\n+    make_constraint_to_escaped (*c);\n+  VEC_free (ce_s, heap, rhsc);\n+}\n+\n+/* Expand the solutions that have nonlocal_id in them to include one\n+   variable for each type that is pointed to by nonlocal and\n+   dereferenced.  */\n+\n+static void\n+expand_nonlocal_solutions (void)\n+{\n+  int i;\n+  varinfo_t v;\n+  bitmap new_nonlocal_solution = BITMAP_ALLOC (&ptabitmap_obstack);\n \n+  /*  We could do this faster by only checking non-collapsed nodes,\n+      unless the node was collapsed to one we would normally ignore in the\n+      rest of the loop.  Logic already seems complicated enough, and\n+      it wasn't a measurable speedup on any testcases i had.  */\n+  for (i = 0; VEC_iterate (varinfo_t, varmap, i, v); i++)\n+    {\n+      /* Where the solution for our variable is, since it may have\n+\t been collapsed to another varinfo.  */\n+      varinfo_t solv = v;\n+      \n+      if (v->is_special_var\n+\t  || v->id == nonlocal_vars_id\n+\t  || v->id == escaped_vars_id\n+\t  || !POINTER_TYPE_P (TREE_TYPE (v->decl)))\n+\tcontinue;\n+      \n+      if (v->node != v->id)\n+\tsolv = get_varinfo (v->node);\n+      if (bitmap_bit_p (solv->solution, nonlocal_vars_id))\n+\t{\n+\t  unsigned int new_nonlocal_id;\n+\t  tree pttype = TREE_TYPE (TREE_TYPE (v->decl));\n+\t  \n+\t  new_nonlocal_id = get_nonlocal_id_for_type (pttype);\n+\t  bitmap_set_bit (new_nonlocal_solution, new_nonlocal_id);\n+\t}\n+    }\n+\n+  if (!bitmap_empty_p (new_nonlocal_solution))\n+    {\n+\n+      for (i = 0; VEC_iterate (varinfo_t, varmap, i, v); i++)\n+\t{\n+\t  if (v->node != v->id)\n+\t    continue;\n+\t  if (bitmap_bit_p (v->solution, nonlocal_vars_id))\n+\t    {\n+\t      bitmap_clear_bit (v->solution, nonlocal_vars_id);\n+\t      bitmap_ior_into (v->solution, new_nonlocal_solution);\n+\t    }\n+\t}\n+    }\n+}\n+\t\t\t  \n /* Create points-to sets for the current function.  See the comments\n    at the start of the file for an algorithmic overview.  */\n \n@@ -4484,11 +4951,13 @@ compute_points_to_sets (struct alias_info *ai)\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n \t{\n \t  tree stmt = bsi_stmt (bsi);\n+\n \t  find_func_aliases (stmt);\n-\t      /* Update various related attributes like escaped\n-\t\t addresses, pointer dereferences for loads and stores.\n-\t\t This is used when creating name tags and alias\n-\t\t sets.  */\n+\t  find_escape_constraints (stmt);\n+\t  /* Update various related attributes like escaped\n+\t     addresses, pointer dereferences for loads and stores.\n+\t     This is used when creating name tags and alias\n+\t     sets.  */\n \t  update_alias_info (stmt, ai);\n \t}\n     }\n@@ -4501,21 +4970,20 @@ compute_points_to_sets (struct alias_info *ai)\n       dump_constraints (dump_file);\n     }\n   \n-  if (1 || need_to_solve ())\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file,\n-\t\t \"\\nCollapsing static cycles and doing variable \"\n-\t\t \"substitution:\\n\");\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"\\nCollapsing static cycles and doing variable \"\n+\t     \"substitution:\\n\");\n       \n-      find_and_collapse_graph_cycles (graph, false);\n-      perform_var_substitution (graph);\n+  find_and_collapse_graph_cycles (graph, false);\n+  perform_var_substitution (graph);\n       \n-      if (dump_file)\n-\tfprintf (dump_file, \"\\nSolving graph:\\n\");\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nSolving graph:\\n\");\n       \n-      solve_graph (graph);\n-    }\n+  solve_graph (graph);\n+  \n+  expand_nonlocal_solutions ();\n   \n   if (dump_file)\n     dump_sa_points_to_info (dump_file);\n@@ -4533,14 +5001,18 @@ delete_points_to_sets (void)\n {\n   varinfo_t v;\n   int i;\n-\n+  \n   htab_delete (id_for_tree);\n   bitmap_obstack_release (&ptabitmap_obstack);\n   bitmap_obstack_release (&predbitmap_obstack);\n   VEC_free (constraint_t, heap, constraints);\n   \n   for (i = 0; VEC_iterate (varinfo_t, varmap, i, v); i++)\n     {\n+      /* Nonlocal vars may add more varinfos.  */\n+      if (i >= graph_size)\n+\tbreak;\n+\n       VEC_free (constraint_edge_t, heap, graph->succs[i]);\n       VEC_free (constraint_edge_t, heap, graph->preds[i]);\n       VEC_free (constraint_t, heap, v->complex);\n@@ -4590,7 +5062,7 @@ ipa_pta_execute (void)\n \t    {\n \t      varinfo_t fi = get_varinfo (varid);\n \t      for (; fi; fi = fi->next)\n-\t\tmake_constraint_to_anything (fi);\n+\t\tmake_constraint_from_escaped (fi);\n \t    }\n \t}\n     }\n@@ -4644,21 +5116,20 @@ ipa_pta_execute (void)\n       dump_constraints (dump_file);\n     }\n   \n-  if (need_to_solve ())\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \n-\t\t \"\\nCollapsing static cycles and doing variable \"\n-\t\t \"substitution:\\n\");\n+  if (dump_file)\n+    fprintf (dump_file, \n+\t     \"\\nCollapsing static cycles and doing variable \"\n+\t     \"substitution:\\n\");\n       \n-      find_and_collapse_graph_cycles (graph, false);\n-      perform_var_substitution (graph);\n+  find_and_collapse_graph_cycles (graph, false);\n+  perform_var_substitution (graph);\n       \n-      if (dump_file)\n-\tfprintf (dump_file, \"\\nSolving graph:\\n\");\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nSolving graph:\\n\");\n       \n-      solve_graph (graph);\n-    }\n+  solve_graph (graph);\n+  \n+  expand_nonlocal_solutions ();\n   \n   if (dump_file)\n     dump_sa_points_to_info (dump_file);\n@@ -4689,13 +5160,19 @@ struct tree_opt_pass pass_ipa_pta =\n void\n init_alias_heapvars (void)\n {\n-  heapvar_for_stmt = htab_create_ggc (11, tree_map_hash, tree_map_eq, NULL);\n+  heapvar_for_stmt = htab_create_ggc (11, tree_map_hash, tree_map_eq,\n+\t\t\t\t      NULL);\n+  nonlocal_for_type = htab_create_ggc (11, tree_map_hash, tree_map_eq,\n+\t\t\t\t       NULL);\n+  nonlocal_all = NULL_TREE;\n }\n \n void\n delete_alias_heapvars (void)\n {\n-  htab_delete (heapvar_for_stmt);  \n+  nonlocal_all = NULL_TREE;\n+  htab_delete (heapvar_for_stmt);\n+  htab_delete (nonlocal_for_type);\n }\n \n   "}, {"sha": "165e5c1b1aef34074d9f3c489da6667184990132", "filename": "gcc/tree-ssa-structalias.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21392f1922a60cff99a2f8f25852badbc516bd0f/gcc%2Ftree-ssa-structalias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21392f1922a60cff99a2f8f25852badbc516bd0f/gcc%2Ftree-ssa-structalias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.h?ref=21392f1922a60cff99a2f8f25852badbc516bd0f", "patch": "@@ -81,7 +81,7 @@ struct alias_info\n #define NUM_REFERENCES_SET(ANN, VAL) (ANN)->common.aux = (void*) ((void *)(VAL))\n \n /* In tree-ssa-alias.c.  */\n-enum escape_type is_escape_site (tree, struct alias_info *);\n+enum escape_type is_escape_site (tree);\n \n /* In tree-ssa-structalias.c.  */\n extern void compute_points_to_sets (struct alias_info *);"}, {"sha": "dddd3863248552016bdab1a8b18c54d24ed51ffb", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21392f1922a60cff99a2f8f25852badbc516bd0f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21392f1922a60cff99a2f8f25852badbc516bd0f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=21392f1922a60cff99a2f8f25852badbc516bd0f", "patch": "@@ -2858,6 +2858,10 @@ extern void decl_restrict_base_insert (tree, tree);\n    multiple translation units should be merged.  */\n #define DECL_ONE_ONLY(NODE) (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.one_only)\n \n+/* Internal to points-to analysis and operand scanning.  Indicates\n+   that this DECL is an artificial points-to variable.  */\n+#define DECL_PTA_ARTIFICIAL(NODE) (VAR_DECL_CHECK (NODE)->decl_with_vis.artificial_pta_var)\n+\n struct tree_decl_with_vis GTY(())\n {\n  struct tree_decl_with_rtl common;\n@@ -2875,6 +2879,7 @@ struct tree_decl_with_vis GTY(())\n  unsigned based_on_restrict_p : 1;\n  /* Used by C++.  Might become a generic decl flag.  */\n  unsigned shadowed_for_var_p : 1;\n+ unsigned artificial_pta_var : 1;\n \n  /* Don't belong to VAR_DECL exclusively.  */\n  unsigned in_system_header_flag : 1;\n@@ -2889,7 +2894,7 @@ struct tree_decl_with_vis GTY(())\n \n  /* Belongs to VAR_DECL exclusively.  */\n  ENUM_BITFIELD(tls_model) tls_model : 3;\n- /* 11 unused bits. */\n+ /* 10 unused bits. */\n };\n \n /* In a VAR_DECL that's static,"}]}