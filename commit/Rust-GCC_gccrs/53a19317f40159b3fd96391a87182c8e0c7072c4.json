{"sha": "53a19317f40159b3fd96391a87182c8e0c7072c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTNhMTkzMTdmNDAxNTliM2ZkOTYzOTFhODcxODJjOGUwYzcwNzJjNA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-07-30T07:56:23Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-07-30T07:56:23Z"}, "message": "genmatch.c (verbose): New global.\n\n2015-07-30  Richard Biener  <rguenther@suse.de>\n\n\t* genmatch.c (verbose): New global.\n\t(warning_at): Add overload with source_location.\n\t(capture_info::capture_info): Add bool whether generating gimple\n\tor generic.  Add gimple member.\n\t(capture_info::cinfo): Add capture member.\n\t(capture_info::walk_match): Record capture.  Warn on\n\tnon-captured leafs.\n\t(capture_info::walk_c_expr): Add more fragments captures cannot\n\tescape through.  Warn on escaped captures.\n\t(dt_simplify::gen_1): Warn on operands we force to have no\n\tside-effects.\n\t(main): Initialize verbose.\n\t* match.pd: Add integer_nonzerop and HONOR_NANS predicates.\n\nFrom-SVN: r226386", "tree": {"sha": "d89770bb87c981380601e6c9a2247a6fee9a02b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d89770bb87c981380601e6c9a2247a6fee9a02b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53a19317f40159b3fd96391a87182c8e0c7072c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53a19317f40159b3fd96391a87182c8e0c7072c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53a19317f40159b3fd96391a87182c8e0c7072c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53a19317f40159b3fd96391a87182c8e0c7072c4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f501d5cd994edf4e82f54d68971fb6b3b0ff37a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f501d5cd994edf4e82f54d68971fb6b3b0ff37a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f501d5cd994edf4e82f54d68971fb6b3b0ff37a3"}], "stats": {"total": 113, "additions": 92, "deletions": 21}, "files": [{"sha": "cebfcdd53d0ca172e02dfa53f499695ce0152f09", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53a19317f40159b3fd96391a87182c8e0c7072c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53a19317f40159b3fd96391a87182c8e0c7072c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=53a19317f40159b3fd96391a87182c8e0c7072c4", "patch": "@@ -1,3 +1,19 @@\n+2015-07-30  Richard Biener  <rguenther@suse.de>\n+\n+\t* genmatch.c (verbose): New global.\n+\t(warning_at): Add overload with source_location.\n+\t(capture_info::capture_info): Add bool whether generating gimple\n+\tor generic.  Add gimple member.\n+\t(capture_info::cinfo): Add capture member.\n+\t(capture_info::walk_match): Record capture.  Warn on\n+\tnon-captured leafs.\n+\t(capture_info::walk_c_expr): Add more fragments captures cannot\n+\tescape through.  Warn on escaped captures.\n+\t(dt_simplify::gen_1): Warn on operands we force to have no\n+\tside-effects.\n+\t(main): Initialize verbose.\n+\t* match.pd: Add integer_nonzerop and HONOR_NANS predicates.\n+\n 2015-07-30  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/67053"}, {"sha": "fc17840ea3550e2ee0d381a424793b13bc6cb739", "filename": "gcc/genmatch.c", "status": "modified", "additions": 73, "deletions": 19, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53a19317f40159b3fd96391a87182c8e0c7072c4/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53a19317f40159b3fd96391a87182c8e0c7072c4/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=53a19317f40159b3fd96391a87182c8e0c7072c4", "patch": "@@ -43,6 +43,12 @@ void ggc_free (void *)\n }\n \n \n+/* Global state.  */\n+\n+/* Verboseness.  0 is quiet, 1 adds some warnings, 2 is for debugging.  */\n+unsigned verbose;\n+\n+\n /* libccp helpers.  */\n \n static struct line_maps *line_table;\n@@ -126,6 +132,18 @@ warning_at (const cpp_token *tk, const char *msg, ...)\n   va_end (ap);\n }\n \n+static void\n+#if GCC_VERSION >= 4001\n+__attribute__((format (printf, 2, 3)))\n+#endif\n+warning_at (source_location loc, const char *msg, ...)\n+{\n+  va_list ap;\n+  va_start (ap, msg);\n+  error_cb (NULL, CPP_DL_WARNING, 0, loc, 0, msg, &ap);\n+  va_end (ap);\n+}\n+\n /* Like fprintf, but print INDENT spaces at the beginning.  */\n \n static void\n@@ -1599,7 +1617,7 @@ decision_tree::print (FILE *f)\n \n struct capture_info\n {\n-  capture_info (simplify *s, operand *);\n+  capture_info (simplify *s, operand *, bool);\n   void walk_match (operand *o, unsigned toplevel_arg, bool, bool);\n   bool walk_result (operand *o, bool, operand *);\n   void walk_c_expr (c_expr *);\n@@ -1614,16 +1632,20 @@ struct capture_info\n       unsigned long toplevel_msk;\n       int result_use_count;\n       unsigned same_as;\n+      capture *c;\n     };\n \n   auto_vec<cinfo> info;\n   unsigned long force_no_side_effects;\n+  bool gimple;\n };\n \n /* Analyze captures in S.  */\n \n-capture_info::capture_info (simplify *s, operand *result)\n+capture_info::capture_info (simplify *s, operand *result, bool gimple_)\n {\n+  gimple = gimple_;\n+\n   expr *e;\n   if (s->kind == simplify::MATCH)\n     {\n@@ -1661,6 +1683,8 @@ capture_info::walk_match (operand *o, unsigned toplevel_arg,\n       info[where].toplevel_msk |= 1 << toplevel_arg;\n       info[where].force_no_side_effects_p |= conditional_p;\n       info[where].cond_expr_cond_p |= cond_expr_cond_p;\n+      if (!info[where].c)\n+\tinfo[where].c = c;\n       if (!c->what)\n \treturn;\n       /* Recurse to exprs and captures.  */\n@@ -1710,6 +1734,10 @@ capture_info::walk_match (operand *o, unsigned toplevel_arg,\n     {\n       /* Mark non-captured leafs toplevel arg for checking.  */\n       force_no_side_effects |= 1 << toplevel_arg;\n+      if (verbose >= 1\n+\t  && !gimple)\n+\twarning_at (o->location,\n+\t\t    \"forcing no side-effects on possibly lost leaf\");\n     }\n   else\n     gcc_unreachable ();\n@@ -1801,15 +1829,25 @@ capture_info::walk_result (operand *o, bool conditional_p, operand *result)\n void\n capture_info::walk_c_expr (c_expr *e)\n {\n-  /* Give up for C exprs mentioning captures not inside TREE_TYPE ().  */\n+  /* Give up for C exprs mentioning captures not inside TREE_TYPE,\n+     TREE_REAL_CST, TREE_CODE or a predicate where they cannot\n+     really escape through.  */\n   unsigned p_depth = 0;\n   for (unsigned i = 0; i < e->code.length (); ++i)\n     {\n       const cpp_token *t = &e->code[i];\n       const cpp_token *n = i < e->code.length () - 1 ? &e->code[i+1] : NULL;\n+      id_base *id;\n       if (t->type == CPP_NAME\n-\t  && strcmp ((const char *)CPP_HASHNODE\n-\t\t       (t->val.node.node)->ident.str, \"TREE_TYPE\") == 0\n+\t  && (strcmp ((const char *)CPP_HASHNODE\n+\t\t      (t->val.node.node)->ident.str, \"TREE_TYPE\") == 0\n+\t      || strcmp ((const char *)CPP_HASHNODE\n+\t\t\t (t->val.node.node)->ident.str, \"TREE_CODE\") == 0\n+\t      || strcmp ((const char *)CPP_HASHNODE\n+\t\t\t (t->val.node.node)->ident.str, \"TREE_REAL_CST\") == 0\n+\t      || ((id = get_operator ((const char *)CPP_HASHNODE\n+\t\t\t\t      (t->val.node.node)->ident.str))\n+\t\t  && is_a <predicate_id *> (id)))\n \t  && n->type == CPP_OPEN_PAREN)\n \tp_depth++;\n       else if (t->type == CPP_CLOSE_PAREN\n@@ -1828,6 +1866,9 @@ capture_info::walk_c_expr (c_expr *e)\n \t    id = (const char *)CPP_HASHNODE (n->val.node.node)->ident.str;\n \t  unsigned where = *e->capture_ids->get(id);\n \t  info[info[where].same_as].force_no_side_effects_p = true;\n+\t  if (verbose >= 1\n+\t      && !gimple)\n+\t    warning_at (t, \"capture escapes\");\n \t}\n     }\n }\n@@ -2662,25 +2703,37 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \n   /* Analyze captures and perform early-outs on the incoming arguments\n      that cover cases we cannot handle.  */\n-  capture_info cinfo (s, result);\n+  capture_info cinfo (s, result, gimple);\n   if (s->kind == simplify::SIMPLIFY)\n     {\n       if (!gimple)\n \t{\n \t  for (unsigned i = 0; i < as_a <expr *> (s->match)->ops.length (); ++i)\n \t    if (cinfo.force_no_side_effects & (1 << i))\n-\t      fprintf_indent (f, indent,\n-\t\t\t      \"if (TREE_SIDE_EFFECTS (op%d)) return NULL_TREE;\\n\",\n-\t\t\t      i);\n+\t      {\n+\t\tfprintf_indent (f, indent,\n+\t\t\t\t\"if (TREE_SIDE_EFFECTS (op%d)) return NULL_TREE;\\n\",\n+\t\t\t\ti);\n+\t\tif (verbose >= 1)\n+\t\t  warning_at (as_a <expr *> (s->match)->ops[i]->location,\n+\t\t\t      \"forcing toplevel operand to have no \"\n+\t\t\t      \"side-effects\");\n+\t      }\n \t  for (int i = 0; i <= s->capture_max; ++i)\n \t    if (cinfo.info[i].cse_p)\n \t      ;\n \t    else if (cinfo.info[i].force_no_side_effects_p\n \t\t     && (cinfo.info[i].toplevel_msk\n \t\t\t & cinfo.force_no_side_effects) == 0)\n-\t      fprintf_indent (f, indent,\n-\t\t\t      \"if (TREE_SIDE_EFFECTS (captures[%d])) \"\n-\t\t\t      \"return NULL_TREE;\\n\", i);\n+\t      {\n+\t\tfprintf_indent (f, indent,\n+\t\t\t\t\"if (TREE_SIDE_EFFECTS (captures[%d])) \"\n+\t\t\t\t\"return NULL_TREE;\\n\", i);\n+\t\tif (verbose >= 1)\n+\t\t  warning_at (cinfo.info[i].c->location,\n+\t\t\t      \"forcing captured operand to have no \"\n+\t\t\t      \"side-effects\");\n+\t      }\n \t    else if ((cinfo.info[i].toplevel_msk\n \t\t      & cinfo.force_no_side_effects) != 0)\n \t      /* Mark capture as having no side-effects if we had to verify\n@@ -4165,7 +4218,6 @@ main (int argc, char **argv)\n     return 1;\n \n   bool gimple = true;\n-  bool verbose = false;\n   char *input = argv[argc-1];\n   for (int i = 1; i < argc - 1; ++i)\n     {\n@@ -4174,11 +4226,13 @@ main (int argc, char **argv)\n       else if (strcmp (argv[i], \"--generic\") == 0)\n \tgimple = false;\n       else if (strcmp (argv[i], \"-v\") == 0)\n-\tverbose = true;\n+\tverbose = 1;\n+      else if (strcmp (argv[i], \"-vv\") == 0)\n+\tverbose = 2;\n       else\n \t{\n \t  fprintf (stderr, \"Usage: genmatch \"\n-\t\t   \"[--gimple] [--generic] [-v] input\\n\");\n+\t\t   \"[--gimple] [--generic] [-v[v]] input\\n\");\n \t  return 1;\n \t}\n     }\n@@ -4235,15 +4289,15 @@ add_operator (VIEW_CONVERT2, \"VIEW_CONVERT2\", \"tcc_unary\", 1);\n       predicate_id *pred = p.user_predicates[i];\n       lower (pred->matchers, gimple);\n \n-      if (verbose)\n+      if (verbose == 2)\n \tfor (unsigned i = 0; i < pred->matchers.length (); ++i)\n \t  print_matches (pred->matchers[i]);\n \n       decision_tree dt;\n       for (unsigned i = 0; i < pred->matchers.length (); ++i)\n \tdt.insert (pred->matchers[i], i);\n \n-      if (verbose)\n+      if (verbose == 2)\n \tdt.print (stderr);\n \n       write_predicate (stdout, pred, dt, gimple);\n@@ -4252,15 +4306,15 @@ add_operator (VIEW_CONVERT2, \"VIEW_CONVERT2\", \"tcc_unary\", 1);\n   /* Lower the main simplifiers and generate code for them.  */\n   lower (p.simplifiers, gimple);\n \n-  if (verbose)\n+  if (verbose == 2)\n     for (unsigned i = 0; i < p.simplifiers.length (); ++i)\n       print_matches (p.simplifiers[i]);\n \n   decision_tree dt;\n   for (unsigned i = 0; i < p.simplifiers.length (); ++i)\n     dt.insert (p.simplifiers[i], i);\n \n-  if (verbose)\n+  if (verbose == 2)\n     dt.print (stderr);\n \n   if (gimple)"}, {"sha": "ad14764814c6b5b1cef8034a555b29d818a67369", "filename": "gcc/match.pd", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53a19317f40159b3fd96391a87182c8e0c7072c4/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53a19317f40159b3fd96391a87182c8e0c7072c4/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=53a19317f40159b3fd96391a87182c8e0c7072c4", "patch": "@@ -26,11 +26,12 @@ along with GCC; see the file COPYING3.  If not see\n /* Generic tree predicates we inherit.  */\n (define_predicates\n    integer_onep integer_zerop integer_all_onesp integer_minus_onep\n-   integer_each_onep integer_truep\n+   integer_each_onep integer_truep integer_nonzerop\n    real_zerop real_onep real_minus_onep\n    CONSTANT_CLASS_P\n    tree_expr_nonnegative_p\n-   integer_pow2p)\n+   integer_pow2p\n+   HONOR_NANS)\n \n /* Operator lists.  */\n (define_operator_list tcc_comparison"}]}