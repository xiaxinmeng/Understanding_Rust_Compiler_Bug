{"sha": "c76bf0bffda065a7364340bf64a9584ec250af7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc2YmYwYmZmZGEwNjVhNzM2NDM0MGJmNjRhOTU4NGVjMjUwYWY3YQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-10T12:32:03Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-10T12:32:03Z"}, "message": "[multiple changes]\n\n2013-10-10  Thomas Quinot  <quinot@adacore.com>\n\n\t* s-taprop-posix.adb: Add missing comment.\n\n2013-10-10  Robert Dewar  <dewar@adacore.com>\n\n\t* freeze.adb (Freeze_Record_Type): Move choice checking to\n\tAnalyze_Freeze_Entity (Freeze_Record_Type): Make sure all choices\n\tare properly frozen\n\t* sem_case.adb (Check_Choices): Remove misguided attempt to\n\tfreeze choices (this is now done in Freeze_Record_Type where\n\tit belongs).\n\t(Check_Choices): Remove some analyze/resolve calls\n\tthat are redundant since they are done in Analyze_Choices.\n\t* sem_ch13.adb (Analyze_Freeze_Entity): Do the error\n\tchecking for choices in variant records here (moved here from\n\tFreeze.Freeze_Record_Type)\n\nFrom-SVN: r203364", "tree": {"sha": "c8e47ec3e82cc0ccb5c0eb27b61cabe61da6c093", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8e47ec3e82cc0ccb5c0eb27b61cabe61da6c093"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c76bf0bffda065a7364340bf64a9584ec250af7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c76bf0bffda065a7364340bf64a9584ec250af7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c76bf0bffda065a7364340bf64a9584ec250af7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c76bf0bffda065a7364340bf64a9584ec250af7a/comments", "author": null, "committer": null, "parents": [{"sha": "58747e480855841d1d510af687f7292c95151d17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58747e480855841d1d510af687f7292c95151d17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58747e480855841d1d510af687f7292c95151d17"}], "stats": {"total": 399, "additions": 248, "deletions": 151}, "files": [{"sha": "1526c73960eea118e89919c85842e475c41d593c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c76bf0bffda065a7364340bf64a9584ec250af7a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c76bf0bffda065a7364340bf64a9584ec250af7a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c76bf0bffda065a7364340bf64a9584ec250af7a", "patch": "@@ -1,3 +1,21 @@\n+2013-10-10  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* s-taprop-posix.adb: Add missing comment.\n+\n+2013-10-10  Robert Dewar  <dewar@adacore.com>\n+\n+\t* freeze.adb (Freeze_Record_Type): Move choice checking to\n+\tAnalyze_Freeze_Entity (Freeze_Record_Type): Make sure all choices\n+\tare properly frozen\n+\t* sem_case.adb (Check_Choices): Remove misguided attempt to\n+\tfreeze choices (this is now done in Freeze_Record_Type where\n+\tit belongs).\n+\t(Check_Choices): Remove some analyze/resolve calls\n+\tthat are redundant since they are done in Analyze_Choices.\n+\t* sem_ch13.adb (Analyze_Freeze_Entity): Do the error\n+\tchecking for choices in variant records here (moved here from\n+\tFreeze.Freeze_Record_Type)\n+\n 2013-10-10  Thomas Quinot  <quinot@adacore.com>\n \n \t* s-oscons-tmplt.c, s-taprop-posix.adb (CLOCK_REALTIME): Always define,"}, {"sha": "7a79d8e791d74269091bd82d11c736915703a628", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 59, "deletions": 134, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c76bf0bffda065a7364340bf64a9584ec250af7a/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c76bf0bffda065a7364340bf64a9584ec250af7a/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=c76bf0bffda065a7364340bf64a9584ec250af7a", "patch": "@@ -46,7 +46,6 @@ with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n-with Sem_Case; use Sem_Case;\n with Sem_Cat;  use Sem_Cat;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch7;  use Sem_Ch7;\n@@ -1995,6 +1994,11 @@ package body Freeze is\n          --  freeze node at some eventual point of call. Protected operations\n          --  are handled elsewhere.\n \n+         procedure Freeze_Choices_In_Variant_Part (VP : Node_Id);\n+         --  Make sure that all types mentioned in Discrete_Choices of the\n+         --  variants referenceed by the Variant_Part VP are frozen. This is\n+         --  a recursive routine to deal with nested variants.\n+\n          ---------------------\n          -- Check_Allocator --\n          ---------------------\n@@ -2047,6 +2051,50 @@ package body Freeze is\n             end if;\n          end Check_Itype;\n \n+         ------------------------------------\n+         -- Freeze_Choices_In_Variant_Part --\n+         ------------------------------------\n+\n+         procedure Freeze_Choices_In_Variant_Part (VP : Node_Id) is\n+            pragma Assert (Nkind (VP) = N_Variant_Part);\n+\n+            Variant : Node_Id;\n+            Choice  : Node_Id;\n+            CL      : Node_Id;\n+\n+         begin\n+            --  Loop through variants\n+\n+            Variant := First_Non_Pragma (Variants (VP));\n+            while Present (Variant) loop\n+\n+               --  Loop through choices, checking that all types are frozen\n+\n+               Choice := First_Non_Pragma (Discrete_Choices (Variant));\n+               while Present (Choice) loop\n+                  if Nkind (Choice) in N_Has_Etype\n+                    and then Present (Etype (Choice))\n+                  then\n+                     Freeze_And_Append (Etype (Choice), N, Result);\n+                  end if;\n+\n+                  Next_Non_Pragma (Choice);\n+               end loop;\n+\n+               --  Check for nested variant part to process\n+\n+               CL := Component_List (Variant);\n+\n+               if not Null_Present (CL) then\n+                  if Present (Variant_Part (CL)) then\n+                     Freeze_Choices_In_Variant_Part (Variant_Part (CL));\n+                  end if;\n+               end if;\n+\n+               Next_Non_Pragma (Variant);\n+            end loop;\n+         end Freeze_Choices_In_Variant_Part;\n+\n       --  Start of processing for Freeze_Record_Type\n \n       begin\n@@ -2627,108 +2675,14 @@ package body Freeze is\n             return;\n          end if;\n \n-         --  Finallly we need to check the variant part to make sure that\n-         --  the set of choices for each variant covers the corresponding\n-         --  discriminant. This check has to be delayed to the freeze point\n-         --  because we may have statically predicated subtypes, whose choice\n-         --  list is not known till the subtype is frozen.\n+         --  Finally we need to check the variant part to make sure that\n+         --  all types within choices are properly frozen as part of the\n+         --  freezing of the record type.\n \n          Check_Variant_Part : declare\n             D : constant Node_Id := Declaration_Node (Rec);\n             T : Node_Id;\n             C : Node_Id;\n-            V : Node_Id;\n-\n-            Others_Present : Boolean;\n-            pragma Warnings (Off, Others_Present);\n-            --  Indicates others present, not used in this case\n-\n-            procedure Non_Static_Choice_Error (Choice : Node_Id);\n-            --  Error routine invoked by the generic instantiation below when\n-            --  the variant part has a non static choice.\n-\n-            procedure Process_Declarations (Variant : Node_Id);\n-            --  Processes declarations associated with a variant. We analyzed\n-            --  the declarations earlier (in Sem_Ch3.Analyze_Variant_Part),\n-            --  but we still need the recursive call to Check_Choices for any\n-            --  nested variant to get its choices properly processed. This is\n-            --  also where we expand out the choices if expansion is active.\n-\n-            package Variant_Choices_Processing is new\n-              Generic_Check_Choices\n-                (Process_Empty_Choice      => No_OP,\n-                 Process_Non_Static_Choice => Non_Static_Choice_Error,\n-                 Process_Associated_Node   => Process_Declarations);\n-            use Variant_Choices_Processing;\n-\n-            -----------------------------\n-            -- Non_Static_Choice_Error --\n-            -----------------------------\n-\n-            procedure Non_Static_Choice_Error (Choice : Node_Id) is\n-            begin\n-               Flag_Non_Static_Expr\n-                 (\"choice given in variant part is not static!\", Choice);\n-            end Non_Static_Choice_Error;\n-\n-            --------------------------\n-            -- Process_Declarations --\n-            --------------------------\n-\n-            procedure Process_Declarations (Variant : Node_Id) is\n-               CL : constant Node_Id := Component_List (Variant);\n-               VP : Node_Id;\n-\n-            begin\n-               --  Check for static predicate present in this variant\n-\n-               if Has_SP_Choice (Variant) then\n-\n-                  --  Here we expand. You might expect to find this call in\n-                  --  Expand_N_Variant_Part, but that is called when we first\n-                  --  see the variant part, and we cannot do this expansion\n-                  --  earlier than the freeze point, since for statically\n-                  --  predicated subtypes, the predicate is not known till\n-                  --  the freeze point.\n-\n-                  --  Furthermore, we do this expansion even if the expander\n-                  --  is not active, because other semantic processing, e.g.\n-                  --  for aggregates, requires the expanded list of choices.\n-\n-                  --  If the expander is not active, then we can't just clobber\n-                  --  the list since it would invalidate the ASIS -gnatct tree.\n-                  --  So we have to rewrite the variant part with a Rewrite\n-                  --  call that replaces it with a copy and clobber the copy.\n-\n-                  if not Expander_Active then\n-                     declare\n-                        NewV : constant Node_Id := New_Copy (Variant);\n-                     begin\n-                        Set_Discrete_Choices\n-                          (NewV, New_Copy_List (Discrete_Choices (Variant)));\n-                        Rewrite (Variant, NewV);\n-                     end;\n-                  end if;\n-\n-                  Expand_Static_Predicates_In_Choices (Variant);\n-               end if;\n-\n-               --  We don't need to worry about the declarations in the variant\n-               --  (since they were analyzed by Analyze_Choices when we first\n-               --  encountered the variant), but we do need to take care of\n-               --  expansion of any nested variants.\n-\n-               if not Null_Present (CL) then\n-                  VP := Variant_Part (CL);\n-\n-                  if Present (VP) then\n-                     Check_Choices\n-                       (VP, Variants (VP), Etype (Name (VP)), Others_Present);\n-                  end if;\n-               end if;\n-            end Process_Declarations;\n-\n-         --  Start of processing for Check_Variant_Part\n \n          begin\n             --  Find component list\n@@ -2751,44 +2705,15 @@ package body Freeze is\n             --  Case of variant part present\n \n             if Present (C) and then Present (Variant_Part (C)) then\n-               V := Variant_Part (C);\n-\n-               --  Check choices\n-\n-               Check_Choices\n-                 (V, Variants (V), Etype (Name (V)), Others_Present);\n-\n-               --  If the last variant does not contain the Others choice,\n-               --  replace it with an N_Others_Choice node since Gigi always\n-               --  wants an Others. Note that we do not bother to call Analyze\n-               --  on the modified variant part, since its only effect would be\n-               --  to compute the Others_Discrete_Choices node laboriously, and\n-               --  of course we already know the list of choices corresponding\n-               --  to the others choice (it's the list we're replacing!)\n-\n-               --  We only want to do this if the expander is active, since\n-               --  we do not want to clobber the ASIS tree!\n-\n-               if Expander_Active then\n-                  declare\n-                     Last_Var : constant Node_Id :=\n-                                     Last_Non_Pragma (Variants (V));\n+               Freeze_Choices_In_Variant_Part (Variant_Part (C));\n+            end if;\n \n-                     Others_Node : Node_Id;\n+            --  Note: we used to call Check_Choices here, but it is too early,\n+            --  since predicated subtypes are frozen here, but their freezing\n+            --  actions are in Analyze_Freeze_Entity, which has not been called\n+            --  yet for entities frozen within this procedure, so we moved that\n+            --  call to the Analyze_Freeze_Entity for the record type.\n \n-                  begin\n-                     if Nkind (First (Discrete_Choices (Last_Var))) /=\n-                                                            N_Others_Choice\n-                     then\n-                        Others_Node := Make_Others_Choice (Sloc (Last_Var));\n-                        Set_Others_Discrete_Choices\n-                          (Others_Node, Discrete_Choices (Last_Var));\n-                        Set_Discrete_Choices\n-                          (Last_Var, New_List (Others_Node));\n-                     end if;\n-                  end;\n-               end if;\n-            end if;\n          end Check_Variant_Part;\n       end Freeze_Record_Type;\n "}, {"sha": "c7747abd27ca8b7606cee1eb607bd9b6b961170c", "filename": "gcc/ada/s-taprop-posix.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c76bf0bffda065a7364340bf64a9584ec250af7a/gcc%2Fada%2Fs-taprop-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c76bf0bffda065a7364340bf64a9584ec250af7a/gcc%2Fada%2Fs-taprop-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-posix.adb?ref=c76bf0bffda065a7364340bf64a9584ec250af7a", "patch": "@@ -183,7 +183,7 @@ package body System.Task_Primitives.Operations is\n       Mode       : ST.Delay_Modes;\n       Check_Time : out Duration;\n       Abs_Time   : out Duration;\n-      Rel_time   : out Duration);\n+      Rel_Time   : out Duration);\n    --  Helper for Timed_Sleep and Timed_Delay: given a deadline specified by\n    --  Time and Mode, compute the current clock reading (Check_Time), and the\n    --  target absolute and relative clock readings (Abs_Time, Rel_Time). The\n@@ -257,7 +257,7 @@ package body System.Task_Primitives.Operations is\n       Mode       : ST.Delay_Modes;\n       Check_Time : out Duration;\n       Abs_Time   : out Duration;\n-      Rel_time   : out Duration)\n+      Rel_Time   : out Duration)\n    is\n    begin\n       Check_Time := Monotonic_Clock;\n@@ -272,7 +272,8 @@ package body System.Task_Primitives.Operations is\n          end if;\n \n          pragma Warnings (Off);\n-         --  Must comment a pragma Warnings (Off) to say why ???\n+         --  Comparison \"OSC.CLOCK_RT_Ada = OSC.CLOCK_REALTIME\" is compile\n+         --  time known.\n \n       --  Absolute deadline specified using the tasking clock (CLOCK_RT_Ada)\n "}, {"sha": "919ac8d937f6009df7a1ac8e669739c220423f40", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c76bf0bffda065a7364340bf64a9584ec250af7a/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c76bf0bffda065a7364340bf64a9584ec250af7a/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=c76bf0bffda065a7364340bf64a9584ec250af7a", "patch": "@@ -26,8 +26,6 @@\n with Atree;    use Atree;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n-with Exp_Util; use Exp_Util;\n-with Freeze;   use Freeze;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -1297,9 +1295,7 @@ package body Sem_Case is\n          --  then don't try any semantic checking on the choices since we have\n          --  a complete mess.\n \n-         if not Is_Discrete_Type (Subtyp)\n-           or else Subtyp = Any_Type\n-         then\n+         if not Is_Discrete_Type (Subtyp) or else Subtyp = Any_Type then\n             return;\n          end if;\n \n@@ -1357,7 +1353,6 @@ package body Sem_Case is\n             else\n                Choice := First (Discrete_Choices (Alt));\n                while Present (Choice) loop\n-                  Analyze (Choice);\n                   Kind := Nkind (Choice);\n \n                   --  Choice is a Range\n@@ -1366,20 +1361,13 @@ package body Sem_Case is\n                     or else (Kind = N_Attribute_Reference\n                               and then Attribute_Name (Choice) = Name_Range)\n                   then\n-                     Resolve (Choice, Expected_Type);\n                      Check (Choice, Low_Bound (Choice), High_Bound (Choice));\n \n                   --  Choice is a subtype name\n \n                   elsif Is_Entity_Name (Choice)\n                     and then Is_Type (Entity (Choice))\n                   then\n-                     --  We have to make sure the subtype is frozen, it must be\n-                     --  before we can do the following analyses on choices!\n-\n-                     Insert_Actions\n-                       (N, Freeze_Entity (Entity (Choice), Choice));\n-\n                      --  Check for inappropriate type\n \n                      if not Covers (Expected_Type, Etype (Choice)) then\n@@ -1505,7 +1493,6 @@ package body Sem_Case is\n                   --  Only other possibility is an expression\n \n                   else\n-                     Resolve (Choice, Expected_Type);\n                      Check (Choice, Choice, Choice);\n                   end if;\n "}, {"sha": "e307e87ec2c0e9bae85622f1bad09e21063dee4b", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c76bf0bffda065a7364340bf64a9584ec250af7a/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c76bf0bffda065a7364340bf64a9584ec250af7a/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=c76bf0bffda065a7364340bf64a9584ec250af7a", "patch": "@@ -44,6 +44,7 @@ with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n+with Sem_Case; use Sem_Case;\n with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n@@ -5239,6 +5240,171 @@ package body Sem_Ch13 is\n \n          Uninstall_Discriminants_And_Pop_Scope (E);\n       end if;\n+\n+      --  For a record type, deal with variant parts. This has to be delayed\n+      --  to this point, because of the issue of statically precicated\n+      --  subtypes, which we have to ensure are frozen before checking\n+      --  choices, since we need to have the static choice list set.\n+\n+      if Is_Record_Type (E) then\n+         Check_Variant_Part : declare\n+            D  : constant Node_Id := Declaration_Node (E);\n+            T  : Node_Id;\n+            C  : Node_Id;\n+            VP : Node_Id;\n+\n+            Others_Present : Boolean;\n+            pragma Warnings (Off, Others_Present);\n+            --  Indicates others present, not used in this case\n+\n+            procedure Non_Static_Choice_Error (Choice : Node_Id);\n+            --  Error routine invoked by the generic instantiation below when\n+            --  the variant part has a non static choice.\n+\n+            procedure Process_Declarations (Variant : Node_Id);\n+            --  Processes declarations associated with a variant. We analyzed\n+            --  the declarations earlier (in Sem_Ch3.Analyze_Variant_Part),\n+            --  but we still need the recursive call to Check_Choices for any\n+            --  nested variant to get its choices properly processed. This is\n+            --  also where we expand out the choices if expansion is active.\n+\n+            package Variant_Choices_Processing is new\n+              Generic_Check_Choices\n+                (Process_Empty_Choice      => No_OP,\n+                 Process_Non_Static_Choice => Non_Static_Choice_Error,\n+                 Process_Associated_Node   => Process_Declarations);\n+            use Variant_Choices_Processing;\n+\n+            -----------------------------\n+            -- Non_Static_Choice_Error --\n+            -----------------------------\n+\n+            procedure Non_Static_Choice_Error (Choice : Node_Id) is\n+            begin\n+               Flag_Non_Static_Expr\n+                 (\"choice given in variant part is not static!\", Choice);\n+            end Non_Static_Choice_Error;\n+\n+            --------------------------\n+            -- Process_Declarations --\n+            --------------------------\n+\n+            procedure Process_Declarations (Variant : Node_Id) is\n+               CL : constant Node_Id := Component_List (Variant);\n+               VP : Node_Id;\n+\n+            begin\n+               --  Check for static predicate present in this variant\n+\n+               if Has_SP_Choice (Variant) then\n+\n+                  --  Here we expand. You might expect to find this call in\n+                  --  Expand_N_Variant_Part, but that is called when we first\n+                  --  see the variant part, and we cannot do this expansion\n+                  --  earlier than the freeze point, since for statically\n+                  --  predicated subtypes, the predicate is not known till\n+                  --  the freeze point.\n+\n+                  --  Furthermore, we do this expansion even if the expander\n+                  --  is not active, because other semantic processing, e.g.\n+                  --  for aggregates, requires the expanded list of choices.\n+\n+                  --  If the expander is not active, then we can't just clobber\n+                  --  the list since it would invalidate the ASIS -gnatct tree.\n+                  --  So we have to rewrite the variant part with a Rewrite\n+                  --  call that replaces it with a copy and clobber the copy.\n+\n+                  if not Expander_Active then\n+                     declare\n+                        NewV : constant Node_Id := New_Copy (Variant);\n+                     begin\n+                        Set_Discrete_Choices\n+                          (NewV, New_Copy_List (Discrete_Choices (Variant)));\n+                        Rewrite (Variant, NewV);\n+                     end;\n+                  end if;\n+\n+                  Expand_Static_Predicates_In_Choices (Variant);\n+               end if;\n+\n+               --  We don't need to worry about the declarations in the variant\n+               --  (since they were analyzed by Analyze_Choices when we first\n+               --  encountered the variant), but we do need to take care of\n+               --  expansion of any nested variants.\n+\n+               if not Null_Present (CL) then\n+                  VP := Variant_Part (CL);\n+\n+                  if Present (VP) then\n+                     Check_Choices\n+                       (VP, Variants (VP), Etype (Name (VP)), Others_Present);\n+                  end if;\n+               end if;\n+            end Process_Declarations;\n+\n+         --  Start of processing for Check_Variant_Part\n+\n+         begin\n+            --  Find component list\n+\n+            C := Empty;\n+\n+            if Nkind (D) = N_Full_Type_Declaration then\n+               T := Type_Definition (D);\n+\n+               if Nkind (T) = N_Record_Definition then\n+                  C := Component_List (T);\n+\n+               elsif Nkind (T) = N_Derived_Type_Definition\n+                 and then Present (Record_Extension_Part (T))\n+               then\n+                  C := Component_List (Record_Extension_Part (T));\n+               end if;\n+            end if;\n+\n+            --  Case of variant part present\n+\n+            if Present (C) and then Present (Variant_Part (C)) then\n+               VP := Variant_Part (C);\n+\n+               --  Check choices\n+\n+               Check_Choices\n+                 (VP, Variants (VP), Etype (Name (VP)), Others_Present);\n+\n+               --  If the last variant does not contain the Others choice,\n+               --  replace it with an N_Others_Choice node since Gigi always\n+               --  wants an Others. Note that we do not bother to call Analyze\n+               --  on the modified variant part, since its only effect would be\n+               --  to compute the Others_Discrete_Choices node laboriously, and\n+               --  of course we already know the list of choices corresponding\n+               --  to the others choice (it's the list we're replacing!)\n+\n+               --  We only want to do this if the expander is active, since\n+               --  we do not want to clobber the ASIS tree!\n+\n+               if Expander_Active then\n+                  declare\n+                     Last_Var : constant Node_Id :=\n+                                     Last_Non_Pragma (Variants (VP));\n+\n+                     Others_Node : Node_Id;\n+\n+                  begin\n+                     if Nkind (First (Discrete_Choices (Last_Var))) /=\n+                                                            N_Others_Choice\n+                     then\n+                        Others_Node := Make_Others_Choice (Sloc (Last_Var));\n+                        Set_Others_Discrete_Choices\n+                          (Others_Node, Discrete_Choices (Last_Var));\n+                        Set_Discrete_Choices\n+                          (Last_Var, New_List (Others_Node));\n+                     end if;\n+                  end;\n+               end if;\n+            end if;\n+         end Check_Variant_Part;\n+      end if;\n    end Analyze_Freeze_Entity;\n \n    ------------------------------------------"}]}