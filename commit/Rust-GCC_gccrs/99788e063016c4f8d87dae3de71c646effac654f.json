{"sha": "99788e063016c4f8d87dae3de71c646effac654f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk3ODhlMDYzMDE2YzRmOGQ4N2RhZTNkZTcxYzY0NmVmZmFjNjU0Zg==", "commit": {"author": {"name": "Alan Hayward", "email": "alan.hayward@arm.com", "date": "2018-08-06T09:54:28Z"}, "committer": {"name": "Alan Hayward", "email": "alahay01@gcc.gnu.org", "date": "2018-08-06T09:54:28Z"}, "message": "cse support for clobber_high\n\ngcc/\n\t* cse.c (invalidate_reg): New function extracted from...\n\t(invalidate): ...here.\n\t(canonicalize_insn): Check for clobber high.\n\t(invalidate_from_clobbers): invalidate clobber highs.\n\t(invalidate_from_sets_and_clobbers): Likewise.\n\t(count_reg_usage): Check for clobber high.\n\t(insn_live_p): Likewise.\n\t* cselib.c (cselib_expand_value_rtx_1):Likewise.\n\t(cselib_invalidate_regno): Check for clobber in setter.\n\t(cselib_invalidate_rtx): Pass through setter.\n\t(cselib_invalidate_rtx_note_stores):\n\t(cselib_process_insn): Check for clobber high.\n\t* cselib.h (cselib_invalidate_rtx): Add operand.\n\nFrom-SVN: r263330", "tree": {"sha": "073666483b43c7890a2cd761d82b0a76d323033a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/073666483b43c7890a2cd761d82b0a76d323033a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99788e063016c4f8d87dae3de71c646effac654f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99788e063016c4f8d87dae3de71c646effac654f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99788e063016c4f8d87dae3de71c646effac654f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99788e063016c4f8d87dae3de71c646effac654f/comments", "author": {"login": "a74nh", "id": 4146708, "node_id": "MDQ6VXNlcjQxNDY3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/4146708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a74nh", "html_url": "https://github.com/a74nh", "followers_url": "https://api.github.com/users/a74nh/followers", "following_url": "https://api.github.com/users/a74nh/following{/other_user}", "gists_url": "https://api.github.com/users/a74nh/gists{/gist_id}", "starred_url": "https://api.github.com/users/a74nh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a74nh/subscriptions", "organizations_url": "https://api.github.com/users/a74nh/orgs", "repos_url": "https://api.github.com/users/a74nh/repos", "events_url": "https://api.github.com/users/a74nh/events{/privacy}", "received_events_url": "https://api.github.com/users/a74nh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "30dc1902a777966dc1d1dad0fb5f19b7a960e5ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30dc1902a777966dc1d1dad0fb5f19b7a960e5ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30dc1902a777966dc1d1dad0fb5f19b7a960e5ca"}], "stats": {"total": 247, "additions": 172, "deletions": 75}, "files": [{"sha": "883399fd2d108752898b56a153a6e6d023833056", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99788e063016c4f8d87dae3de71c646effac654f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99788e063016c4f8d87dae3de71c646effac654f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=99788e063016c4f8d87dae3de71c646effac654f", "patch": "@@ -1,3 +1,19 @@\n+2018-08-06  Alan Hayward  <alan.hayward@arm.com>\n+\n+\t* cse.c (invalidate_reg): New function extracted from...\n+\t(invalidate): ...here.\n+\t(canonicalize_insn): Check for clobber high.\n+\t(invalidate_from_clobbers): invalidate clobber highs.\n+\t(invalidate_from_sets_and_clobbers): Likewise.\n+\t(count_reg_usage): Check for clobber high.\n+\t(insn_live_p): Likewise.\n+\t* cselib.c (cselib_expand_value_rtx_1):Likewise.\n+\t(cselib_invalidate_regno): Check for clobber in setter.\n+\t(cselib_invalidate_rtx): Pass through setter.\n+\t(cselib_invalidate_rtx_note_stores):\n+\t(cselib_process_insn): Check for clobber high.\n+\t* cselib.h (cselib_invalidate_rtx): Add operand.\n+\n 2018-08-06  Alan Hayward  <alan.hayward@arm.com>\n \n \t* lra-eliminations.c (lra_eliminate_regs_1): Check for clobber high."}, {"sha": "3d7888b709375b7ea99eb56a9a61c194307956bc", "filename": "gcc/cse.c", "status": "modified", "additions": 123, "deletions": 64, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99788e063016c4f8d87dae3de71c646effac654f/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99788e063016c4f8d87dae3de71c646effac654f/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=99788e063016c4f8d87dae3de71c646effac654f", "patch": "@@ -559,6 +559,7 @@ static struct table_elt *insert_with_costs (rtx, struct table_elt *, unsigned,\n static struct table_elt *insert (rtx, struct table_elt *, unsigned,\n \t\t\t\t machine_mode);\n static void merge_equiv_classes (struct table_elt *, struct table_elt *);\n+static void invalidate_reg (rtx, bool);\n static void invalidate (rtx, machine_mode);\n static void remove_invalid_refs (unsigned int);\n static void remove_invalid_subreg_refs (unsigned int, poly_uint64,\n@@ -1818,7 +1819,85 @@ check_dependence (const_rtx x, rtx exp, machine_mode mode, rtx addr)\n     }\n   return false;\n }\n-\f\n+\n+/* Remove from the hash table, or mark as invalid, all expressions whose\n+   values could be altered by storing in register X.\n+\n+   CLOBBER_HIGH is set if X was part of a CLOBBER_HIGH expression.  */\n+\n+static void\n+invalidate_reg (rtx x, bool clobber_high)\n+{\n+  gcc_assert (GET_CODE (x) == REG);\n+\n+  /* If X is a register, dependencies on its contents are recorded\n+     through the qty number mechanism.  Just change the qty number of\n+     the register, mark it as invalid for expressions that refer to it,\n+     and remove it itself.  */\n+  unsigned int regno = REGNO (x);\n+  unsigned int hash = HASH (x, GET_MODE (x));\n+\n+  /* Remove REGNO from any quantity list it might be on and indicate\n+     that its value might have changed.  If it is a pseudo, remove its\n+     entry from the hash table.\n+\n+     For a hard register, we do the first two actions above for any\n+     additional hard registers corresponding to X.  Then, if any of these\n+     registers are in the table, we must remove any REG entries that\n+     overlap these registers.  */\n+\n+  delete_reg_equiv (regno);\n+  REG_TICK (regno)++;\n+  SUBREG_TICKED (regno) = -1;\n+\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      gcc_assert (!clobber_high);\n+      remove_pseudo_from_table (x, hash);\n+    }\n+  else\n+    {\n+      HOST_WIDE_INT in_table = TEST_HARD_REG_BIT (hard_regs_in_table, regno);\n+      unsigned int endregno = END_REGNO (x);\n+      unsigned int rn;\n+      struct table_elt *p, *next;\n+\n+      CLEAR_HARD_REG_BIT (hard_regs_in_table, regno);\n+\n+      for (rn = regno + 1; rn < endregno; rn++)\n+\t{\n+\t  in_table |= TEST_HARD_REG_BIT (hard_regs_in_table, rn);\n+\t  CLEAR_HARD_REG_BIT (hard_regs_in_table, rn);\n+\t  delete_reg_equiv (rn);\n+\t  REG_TICK (rn)++;\n+\t  SUBREG_TICKED (rn) = -1;\n+\t}\n+\n+      if (in_table)\n+\tfor (hash = 0; hash < HASH_SIZE; hash++)\n+\t  for (p = table[hash]; p; p = next)\n+\t    {\n+\t      next = p->next_same_hash;\n+\n+\t      if (!REG_P (p->exp) || REGNO (p->exp) >= FIRST_PSEUDO_REGISTER)\n+\t\tcontinue;\n+\n+\t      if (clobber_high)\n+\t\t{\n+\t\t  if (reg_is_clobbered_by_clobber_high (p->exp, x))\n+\t\t    remove_from_table (p, hash);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  unsigned int tregno = REGNO (p->exp);\n+\t\t  unsigned int tendregno = END_REGNO (p->exp);\n+\t\t  if (tendregno > regno && tregno < endregno)\n+\t\t    remove_from_table (p, hash);\n+\t\t}\n+\t    }\n+    }\n+}\n+\n /* Remove from the hash table, or mark as invalid, all expressions whose\n    values could be altered by storing in X.  X is a register, a subreg, or\n    a memory reference with nonvarying address (because, when a memory\n@@ -1841,65 +1920,7 @@ invalidate (rtx x, machine_mode full_mode)\n   switch (GET_CODE (x))\n     {\n     case REG:\n-      {\n-\t/* If X is a register, dependencies on its contents are recorded\n-\t   through the qty number mechanism.  Just change the qty number of\n-\t   the register, mark it as invalid for expressions that refer to it,\n-\t   and remove it itself.  */\n-\tunsigned int regno = REGNO (x);\n-\tunsigned int hash = HASH (x, GET_MODE (x));\n-\n-\t/* Remove REGNO from any quantity list it might be on and indicate\n-\t   that its value might have changed.  If it is a pseudo, remove its\n-\t   entry from the hash table.\n-\n-\t   For a hard register, we do the first two actions above for any\n-\t   additional hard registers corresponding to X.  Then, if any of these\n-\t   registers are in the table, we must remove any REG entries that\n-\t   overlap these registers.  */\n-\n-\tdelete_reg_equiv (regno);\n-\tREG_TICK (regno)++;\n-\tSUBREG_TICKED (regno) = -1;\n-\n-\tif (regno >= FIRST_PSEUDO_REGISTER)\n-\t  remove_pseudo_from_table (x, hash);\n-\telse\n-\t  {\n-\t    HOST_WIDE_INT in_table\n-\t      = TEST_HARD_REG_BIT (hard_regs_in_table, regno);\n-\t    unsigned int endregno = END_REGNO (x);\n-\t    unsigned int tregno, tendregno, rn;\n-\t    struct table_elt *p, *next;\n-\n-\t    CLEAR_HARD_REG_BIT (hard_regs_in_table, regno);\n-\n-\t    for (rn = regno + 1; rn < endregno; rn++)\n-\t      {\n-\t\tin_table |= TEST_HARD_REG_BIT (hard_regs_in_table, rn);\n-\t\tCLEAR_HARD_REG_BIT (hard_regs_in_table, rn);\n-\t\tdelete_reg_equiv (rn);\n-\t\tREG_TICK (rn)++;\n-\t\tSUBREG_TICKED (rn) = -1;\n-\t      }\n-\n-\t    if (in_table)\n-\t      for (hash = 0; hash < HASH_SIZE; hash++)\n-\t\tfor (p = table[hash]; p; p = next)\n-\t\t  {\n-\t\t    next = p->next_same_hash;\n-\n-\t\t    if (!REG_P (p->exp)\n-\t\t\t|| REGNO (p->exp) >= FIRST_PSEUDO_REGISTER)\n-\t\t      continue;\n-\n-\t\t    tregno = REGNO (p->exp);\n-\t\t    tendregno = END_REGNO (p->exp);\n-\t\t    if (tendregno > regno && tregno < endregno)\n-\t\t      remove_from_table (p, hash);\n-\t\t  }\n-\t  }\n-      }\n+      invalidate_reg (x, false);\n       return;\n \n     case SUBREG:\n@@ -4399,6 +4420,8 @@ canonicalize_insn (rtx_insn *insn, struct set **psets, int n_sets)\n       if (MEM_P (XEXP (x, 0)))\n \tcanon_reg (XEXP (x, 0), insn);\n     }\n+  else if (GET_CODE (x) == CLOBBER_HIGH)\n+    gcc_assert (REG_P (XEXP (x, 0)));\n   else if (GET_CODE (x) == USE\n \t   && ! (REG_P (XEXP (x, 0))\n \t\t && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER))\n@@ -4430,6 +4453,8 @@ canonicalize_insn (rtx_insn *insn, struct set **psets, int n_sets)\n \t      if (MEM_P (XEXP (y, 0)))\n \t\tcanon_reg (XEXP (y, 0), insn);\n \t    }\n+\t  else if (GET_CODE (y) == CLOBBER_HIGH)\n+\t    gcc_assert (REG_P (XEXP (y, 0)));\n \t  else if (GET_CODE (y) == USE\n \t\t   && ! (REG_P (XEXP (y, 0))\n \t\t\t && REGNO (XEXP (y, 0)) < FIRST_PSEUDO_REGISTER))\n@@ -6130,6 +6155,12 @@ invalidate_from_clobbers (rtx_insn *insn)\n \t    invalidate (XEXP (ref, 0), GET_MODE (ref));\n \t}\n     }\n+  if (GET_CODE (x) == CLOBBER_HIGH)\n+    {\n+      rtx ref = XEXP (x, 0);\n+      gcc_assert (REG_P (ref));\n+      invalidate_reg (ref, true);\n+    }\n   else if (GET_CODE (x) == PARALLEL)\n     {\n       int i;\n@@ -6146,6 +6177,12 @@ invalidate_from_clobbers (rtx_insn *insn)\n \t\t       || GET_CODE (ref) == ZERO_EXTRACT)\n \t\tinvalidate (XEXP (ref, 0), GET_MODE (ref));\n \t    }\n+\t  else if (GET_CODE (y) == CLOBBER_HIGH)\n+\t    {\n+\t      rtx ref = XEXP (y, 0);\n+\t      gcc_assert (REG_P (ref));\n+\t      invalidate_reg (ref, true);\n+\t    }\n \t}\n     }\n }\n@@ -6163,8 +6200,17 @@ invalidate_from_sets_and_clobbers (rtx_insn *insn)\n   if (CALL_P (insn))\n     {\n       for (tem = CALL_INSN_FUNCTION_USAGE (insn); tem; tem = XEXP (tem, 1))\n-\tif (GET_CODE (XEXP (tem, 0)) == CLOBBER)\n-\t  invalidate (SET_DEST (XEXP (tem, 0)), VOIDmode);\n+\t{\n+\t  rtx temx = XEXP (tem, 0);\n+\t  if (GET_CODE (temx) == CLOBBER)\n+\t    invalidate (SET_DEST (temx), VOIDmode);\n+\t  else if (GET_CODE (temx) == CLOBBER_HIGH)\n+\t    {\n+\t      rtx temref = XEXP (temx, 0);\n+\t      gcc_assert (REG_P (temref));\n+\t      invalidate_reg (temref, true);\n+\t    }\n+\t}\n     }\n \n   /* Ensure we invalidate the destination register of a CALL insn.\n@@ -6191,6 +6237,12 @@ invalidate_from_sets_and_clobbers (rtx_insn *insn)\n \t\t       || GET_CODE (clobbered) == ZERO_EXTRACT)\n \t\tinvalidate (XEXP (clobbered, 0), GET_MODE (clobbered));\n \t    }\n+\t  else if (GET_CODE (y) == CLOBBER_HIGH)\n+\t    {\n+\t      rtx ref = XEXP (y, 0);\n+\t      gcc_assert (REG_P (ref));\n+\t      invalidate_reg (ref, true);\n+\t    }\n \t  else if (GET_CODE (y) == SET && GET_CODE (SET_SRC (y)) == CALL)\n \t    invalidate (SET_DEST (y), VOIDmode);\n \t}\n@@ -6850,6 +6902,10 @@ count_reg_usage (rtx x, int *counts, rtx dest, int incr)\n \tcount_reg_usage (XEXP (XEXP (x, 0), 0), counts, NULL_RTX, incr);\n       return;\n \n+    case CLOBBER_HIGH:\n+      gcc_assert (REG_P ((XEXP (x, 0))));\n+      return;\n+\n     case SET:\n       /* Unless we are setting a REG, count everything in SET_DEST.  */\n       if (!REG_P (SET_DEST (x)))\n@@ -6902,7 +6958,8 @@ count_reg_usage (rtx x, int *counts, rtx dest, int incr)\n \t  || (REG_NOTE_KIND (x) != REG_NONNEG && GET_CODE (XEXP (x,0)) == USE)\n \t  /* FUNCTION_USAGE expression lists may include (CLOBBER (mem /u)),\n \t     involving registers in the address.  */\n-\t  || GET_CODE (XEXP (x, 0)) == CLOBBER)\n+\t  || GET_CODE (XEXP (x, 0)) == CLOBBER\n+\t  || GET_CODE (XEXP (x, 0)) == CLOBBER_HIGH)\n \tcount_reg_usage (XEXP (x, 0), counts, NULL_RTX, incr);\n \n       count_reg_usage (XEXP (x, 1), counts, NULL_RTX, incr);\n@@ -6986,7 +7043,9 @@ insn_live_p (rtx_insn *insn, int *counts)\n \t      if (set_live_p (elt, insn, counts))\n \t\treturn true;\n \t    }\n-\t  else if (GET_CODE (elt) != CLOBBER && GET_CODE (elt) != USE)\n+\t  else if (GET_CODE (elt) != CLOBBER\n+\t\t   && GET_CODE (elt) != CLOBBER_HIGH\n+\t\t   && GET_CODE (elt) != USE)\n \t    return true;\n \t}\n       return false;"}, {"sha": "6d3a4078c689db272f39ed80acbff922c780f906", "filename": "gcc/cselib.c", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99788e063016c4f8d87dae3de71c646effac654f/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99788e063016c4f8d87dae3de71c646effac654f/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=99788e063016c4f8d87dae3de71c646effac654f", "patch": "@@ -54,7 +54,8 @@ static unsigned int cselib_hash_rtx (rtx, int, machine_mode);\n static cselib_val *new_cselib_val (unsigned int, machine_mode, rtx);\n static void add_mem_for_addr (cselib_val *, cselib_val *, rtx);\n static cselib_val *cselib_lookup_mem (rtx, int);\n-static void cselib_invalidate_regno (unsigned int, machine_mode);\n+static void cselib_invalidate_regno (unsigned int, machine_mode,\n+\t\t\t\t     const_rtx = NULL);\n static void cselib_invalidate_mem (rtx);\n static void cselib_record_set (rtx, cselib_val *, cselib_val *);\n static void cselib_record_sets (rtx_insn *);\n@@ -1661,6 +1662,7 @@ cselib_expand_value_rtx_1 (rtx orig, struct expand_value_data *evd,\n       /* SCRATCH must be shared because they represent distinct values.  */\n       return orig;\n     case CLOBBER:\n+    case CLOBBER_HIGH:\n       if (REG_P (XEXP (orig, 0)) && HARD_REGISTER_NUM_P (REGNO (XEXP (orig, 0))))\n \treturn orig;\n       break;\n@@ -2163,7 +2165,8 @@ cselib_lookup (rtx x, machine_mode mode,\n    invalidating call clobbered registers across a call.  */\n \n static void\n-cselib_invalidate_regno (unsigned int regno, machine_mode mode)\n+cselib_invalidate_regno (unsigned int regno, machine_mode mode,\n+\t\t\t const_rtx setter)\n {\n   unsigned int endregno;\n   unsigned int i;\n@@ -2186,6 +2189,9 @@ cselib_invalidate_regno (unsigned int regno, machine_mode mode)\n \ti = regno - max_value_regs;\n \n       endregno = end_hard_regno (mode, regno);\n+\n+      if (setter && GET_CODE (setter) == CLOBBER_HIGH)\n+\tgcc_assert (endregno == regno + 1);\n     }\n   else\n     {\n@@ -2218,6 +2224,19 @@ cselib_invalidate_regno (unsigned int regno, machine_mode mode)\n \t      continue;\n \t    }\n \n+\t  /* Ignore if clobber high and the register isn't clobbered.  */\n+\t  if (setter && GET_CODE (setter) == CLOBBER_HIGH)\n+\t    {\n+\t      gcc_assert (endregno == regno + 1);\n+\t      const_rtx x = XEXP (setter, 0);\n+\t      if (!reg_is_clobbered_by_clobber_high (i, GET_MODE (v->val_rtx),\n+\t\t\t\t\t\t     x))\n+\t\t{\n+\t\t  l = &(*l)->next;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\n \t  /* We have an overlap.  */\n \t  if (*l == REG_VALUES (i))\n \t    {\n@@ -2352,29 +2371,29 @@ cselib_invalidate_mem (rtx mem_rtx)\n   *vp = &dummy_val;\n }\n \n-/* Invalidate DEST, which is being assigned to or clobbered.  */\n+/* Invalidate DEST, which is being assigned to or clobbered by SETTER.  */\n \n void\n-cselib_invalidate_rtx (rtx dest)\n+cselib_invalidate_rtx (rtx dest, const_rtx setter)\n {\n   while (GET_CODE (dest) == SUBREG\n \t || GET_CODE (dest) == ZERO_EXTRACT\n \t || GET_CODE (dest) == STRICT_LOW_PART)\n     dest = XEXP (dest, 0);\n \n   if (REG_P (dest))\n-    cselib_invalidate_regno (REGNO (dest), GET_MODE (dest));\n+    cselib_invalidate_regno (REGNO (dest), GET_MODE (dest), setter);\n   else if (MEM_P (dest))\n     cselib_invalidate_mem (dest);\n }\n \n /* A wrapper for cselib_invalidate_rtx to be called via note_stores.  */\n \n static void\n-cselib_invalidate_rtx_note_stores (rtx dest, const_rtx ignore ATTRIBUTE_UNUSED,\n+cselib_invalidate_rtx_note_stores (rtx dest, const_rtx setter,\n \t\t\t\t   void *data ATTRIBUTE_UNUSED)\n {\n-  cselib_invalidate_rtx (dest);\n+  cselib_invalidate_rtx (dest, setter);\n }\n \n /* Record the result of a SET instruction.  DEST is being set; the source\n@@ -2775,9 +2794,12 @@ cselib_process_insn (rtx_insn *insn)\n   if (CALL_P (insn))\n     {\n       for (x = CALL_INSN_FUNCTION_USAGE (insn); x; x = XEXP (x, 1))\n-\tif (GET_CODE (XEXP (x, 0)) == CLOBBER)\n-\t  cselib_invalidate_rtx (XEXP (XEXP (x, 0), 0));\n-      /* Flush evertything on setjmp.  */\n+\t{\n+\t  gcc_assert (GET_CODE (XEXP (x, 0)) != CLOBBER_HIGH);\n+\t  if (GET_CODE (XEXP (x, 0)) == CLOBBER)\n+\t    cselib_invalidate_rtx (XEXP (XEXP (x, 0), 0));\n+\t}\n+      /* Flush everything on setjmp.  */\n       if (cselib_preserve_constants\n \t  && find_reg_note (insn, REG_SETJMP, NULL))\n \t{"}, {"sha": "0005ad3113cd26126c9014fb064057566b899919", "filename": "gcc/cselib.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99788e063016c4f8d87dae3de71c646effac654f/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99788e063016c4f8d87dae3de71c646effac654f/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=99788e063016c4f8d87dae3de71c646effac654f", "patch": "@@ -92,7 +92,7 @@ extern bool cselib_dummy_expand_value_rtx_cb (rtx, bitmap, int,\n \t\t\t\t\t      cselib_expand_callback, void *);\n extern rtx cselib_subst_to_values (rtx, machine_mode);\n extern rtx cselib_subst_to_values_from_insn (rtx, machine_mode, rtx_insn *);\n-extern void cselib_invalidate_rtx (rtx);\n+extern void cselib_invalidate_rtx (rtx, const_rtx = NULL);\n \n extern void cselib_reset_table (unsigned int);\n extern unsigned int cselib_get_next_uid (void);"}]}