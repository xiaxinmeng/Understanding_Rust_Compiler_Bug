{"sha": "fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM2NjMzZTBjZjU0ZDlkM2E1ZjU3Y2U2ZTMzZGZkMWFmOGE1YWM4MQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-08-30T13:12:14Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-08-30T13:12:14Z"}, "message": "tree.h (BINFO_PRIMARY_BASE_OF): Remove.\n\n\t* tree.h (BINFO_PRIMARY_BASE_OF): Remove.\n\t(struct tree_binfo): Remove primary field.\n\t* cp/cp-tree.h (BINFO_PRIMARY_P): Use a binfo flag.\n\t(BINFO_INDIRECT_PRIMARY_P): Remove.\n\t* cp/class.c (determine_primary_base): Rename to ...\n\t(determine_primary_bases): ... here.  Set all primary bases.\n\t(set_primary_base): Remove.\n\t(mark_primary_bases): Remove.\n\t(build_simple_base_path, walk_subobject_offsets,\n\tpropagate_binfo_offsets, end_of_class): Adjust.\n\t(layout_class_type): Rename determine_primary_base call.\n\t(dump_class_hierarchy_r, dump_vtable): Adjust. Don't pass a binfo\n\tto type_as_string.\n\t(dfs_build_secondary_vptr_vtt_inits, dfs_accumulate_vtbl_inits,\n\tbuild_rtti_vtbl_entries): Adjust.\n\t* cp/init.c (build_vtbl_address): Adjust.\n\nFrom-SVN: r86766", "tree": {"sha": "9371d0d44b6ad4b608ffaecce208e472e1bca5fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9371d0d44b6ad4b608ffaecce208e472e1bca5fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81/comments", "author": null, "committer": null, "parents": [{"sha": "bd8a2e96afaf00312fb3b0c1879e440043cf0e46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd8a2e96afaf00312fb3b0c1879e440043cf0e46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd8a2e96afaf00312fb3b0c1879e440043cf0e46"}], "stats": {"total": 362, "additions": 162, "deletions": 200}, "files": [{"sha": "ba3f8847f7c1f967c8bc8afaff1d1736b738f2d4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81", "patch": "@@ -1,3 +1,8 @@\n+2004-08-30  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* tree.h (BINFO_PRIMARY_BASE_OF): Remove.\n+\t(struct tree_binfo): Remove primary field.\n+\n 2004-08-30  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* configure.ac: Do not run fixincludes after stage1 during\n@@ -9,6 +14,12 @@\n \t* sched-deps.c (get_condition): Partially revert previous, by never\n \ttrying to extract the condition from a condjump.\n \n+2004-08-30  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* c-common.c (c_sizeof_or_alignof_type): Use gcc_assert.\n+\t(handle_visibility_attribute, c_determine_visibility): Likewise.\n+\t* c-common.h (my_friendly_assert): Remove.\n+\n 2004-08-30  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.md (UNSPEC_{RSQRT,RECIP}[12]_{S,D,PS}): Delete."}, {"sha": "fc1afbcb0a7d3458765468ce6144e8d85bc6bd5c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81", "patch": "@@ -1,5 +1,20 @@\n 2004-08-30  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\t* cp-tree.h (BINFO_PRIMARY_P): Use a binfo flag.\n+\t(BINFO_INDIRECT_PRIMARY_P): Remove.\n+\t* class.c (determine_primary_base): Rename to ...\n+\t(determine_primary_bases): ... here.  Set all primary bases.\n+\t(set_primary_base): Remove.\n+\t(mark_primary_bases): Remove.\n+\t(build_simple_base_path, walk_subobject_offsets,\n+\tpropagate_binfo_offsets, end_of_class): Adjust.\n+\t(layout_class_type): Rename determine_primary_base call.\n+\t(dump_class_hierarchy_r, dump_vtable): Adjust. Don't pass a binfo\n+\tto type_as_string.\n+\t(dfs_build_secondary_vptr_vtt_inits, dfs_accumulate_vtbl_inits,\n+\tbuild_rtti_vtbl_entries): Adjust.\n+\t* init.c (build_vtbl_address): Adjust.\n+\n \t* cp-tree.h (SET_BINFO_NEW_VTABLE_MARKED): Use gcc_assert.\n \n 2004-08-28  Ziemowit Laski  <zlaski@apple.com>"}, {"sha": "1007ebbc289e497950aef5034a9ded60a8bdb41e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 129, "deletions": 171, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81", "patch": "@@ -119,7 +119,7 @@ static void handle_using_decl (tree, tree);\n static void check_for_override (tree, tree);\n static tree dfs_modify_vtables (tree, void *);\n static tree modify_all_vtables (tree, tree);\n-static void determine_primary_base (tree);\n+static void determine_primary_bases (tree);\n static void finish_struct_methods (tree);\n static void maybe_warn_about_overly_private_class (tree);\n static int method_name_cmp (const void *, const void *);\n@@ -147,7 +147,6 @@ static void include_empty_classes (record_layout_info);\n static void layout_class_type (tree, tree *);\n static void fixup_pending_inline (tree);\n static void fixup_inline_methods (tree);\n-static void set_primary_base (tree, tree);\n static void propagate_binfo_offsets (tree, tree);\n static void layout_virtual_bases (record_layout_info, splay_tree);\n static void build_vbase_offset_vtbl_entries (tree, vtbl_init_data *);\n@@ -182,7 +181,6 @@ static tree dfs_accumulate_vtbl_inits (tree, tree, tree, tree,\n static void build_rtti_vtbl_entries (tree, vtbl_init_data *);\n static void build_vcall_and_vbase_vtbl_entries (tree, \n \t\t\t\t\t\t\tvtbl_init_data *);\n-static void mark_primary_bases (tree);\n static void clone_constructors_and_destructors (tree);\n static tree build_clone (tree, tree);\n static void update_vtable_entry_for_fn (tree, tree, tree, tree *, unsigned);\n@@ -415,15 +413,9 @@ static tree\n build_simple_base_path (tree expr, tree binfo)\n {\n   tree type = BINFO_TYPE (binfo);\n-  tree d_binfo;\n+  tree d_binfo = BINFO_INHERITANCE_CHAIN (binfo);\n   tree field;\n \n-  /* For primary virtual bases, we can't just follow\n-     BINFO_INHERITANCE_CHAIN.  */\n-  d_binfo = BINFO_PRIMARY_BASE_OF (binfo);\n-  if (d_binfo == NULL_TREE)\n-    d_binfo = BINFO_INHERITANCE_CHAIN (binfo);\n-\n   if (d_binfo == NULL_TREE)\n     {\n       if (TYPE_MAIN_VARIANT (TREE_TYPE (expr)) != type)\n@@ -1254,170 +1246,132 @@ check_bases (tree t,\n     }\n }\n \n-/* Set BINFO_PRIMARY_BASE_OF for all binfos in the hierarchy\n-   dominated by TYPE that are primary bases.  */\n+/* Determine all the primary bases within T.  Sets BINFO_PRIMARY_BASE_P for\n+   those that are primaries.  Sets BINFO_LOST_PRIMARY_P for those\n+   that have had a nearly-empty virtual primary base stolen by some\n+   other base in the heirarchy.  Determines CLASSTYPE_PRIMARY_BASE for\n+   T.  */\n \n static void\n-mark_primary_bases (tree type)\n+determine_primary_bases (tree t)\n {\n-  tree binfo;\n-  \n-  /* Walk the bases in inheritance graph order.  */\n-  for (binfo = TYPE_BINFO (type); binfo; binfo = TREE_CHAIN (binfo))\n+  unsigned i;\n+  tree primary = NULL_TREE;\n+  tree type_binfo = TYPE_BINFO (t);\n+  tree base_binfo;\n+\n+  /* Determine the primary bases of our bases.  */\n+  for (base_binfo = TREE_CHAIN (type_binfo); base_binfo;\n+       base_binfo = TREE_CHAIN (base_binfo))\n     {\n-      tree base_binfo = get_primary_binfo (binfo);\n+      tree primary = CLASSTYPE_PRIMARY_BINFO (BINFO_TYPE (base_binfo));\n \n-      if (!base_binfo)\n-\t/* Not a dynamic base.  */;\n-      else if (BINFO_PRIMARY_P (base_binfo))\n-\tBINFO_LOST_PRIMARY_P (binfo) = 1;\n-      else\n+      /* See if we're the non-virtual primary of our inheritance\n+\t chain.  */\n+      if (!BINFO_VIRTUAL_P (base_binfo))\n \t{\n-\t  BINFO_PRIMARY_BASE_OF (base_binfo) = binfo;\n-\t  /* A virtual binfo might have been copied from within\n-  \t     another hierarchy. As we're about to use it as a primary\n-  \t     base, make sure the offsets match.  */\n-\t  if (BINFO_VIRTUAL_P (base_binfo))\n+\t  tree parent = BINFO_INHERITANCE_CHAIN (base_binfo);\n+\t  tree parent_primary = CLASSTYPE_PRIMARY_BINFO (BINFO_TYPE (parent));\n+\t  \n+\t  if (parent_primary\n+\t      && BINFO_TYPE (base_binfo) == BINFO_TYPE (parent_primary))\n+\t    /* We are the primary binfo.  */\n+\t    BINFO_PRIMARY_P (base_binfo) = 1;\n+\t}\n+      /* Determine if we have a virtual primary base, and mark it so.\n+       */\n+      if (primary && BINFO_VIRTUAL_P (primary))\n+\t{\n+\t  tree this_primary = copied_binfo (primary, base_binfo);\n+\n+\t  if (BINFO_PRIMARY_P (this_primary))\n+\t    /* Someone already claimed this base.  */\n+\t    BINFO_LOST_PRIMARY_P (base_binfo) = 1;\n+\t  else\n \t    {\n-\t      tree delta = size_diffop (convert (ssizetype,\n-\t\t\t\t\t\t BINFO_OFFSET (binfo)),\n-\t\t\t\t\tconvert (ssizetype,\n-\t\t\t\t\t\t BINFO_OFFSET (base_binfo)));\n+\t      tree delta;\n+\t      \n+\t      BINFO_PRIMARY_P (this_primary) = 1;\n+\t      BINFO_INHERITANCE_CHAIN (this_primary) = base_binfo;\n+\t      \n+\t      /* A virtual binfo might have been copied from within\n+  \t         another hierarchy. As we're about to use it as a\n+  \t         primary base, make sure the offsets match.  */\n+\t      delta = size_diffop (convert (ssizetype,\n+\t\t\t\t\t    BINFO_OFFSET (base_binfo)),\n+\t\t\t\t   convert (ssizetype,\n+\t\t\t\t\t    BINFO_OFFSET (this_primary)));\n \t  \n-\t      propagate_binfo_offsets (base_binfo, delta);\n+\t      propagate_binfo_offsets (this_primary, delta);\n \t    }\n \t}\n     }\n-}\n-\n-/* Make the BINFO the primary base of T.  */\n-\n-static void\n-set_primary_base (tree t, tree binfo)\n-{\n-  tree basetype;\n-\n-  CLASSTYPE_PRIMARY_BINFO (t) = binfo;\n-  basetype = BINFO_TYPE (binfo);\n-  BINFO_VTABLE (TYPE_BINFO (t)) = BINFO_VTABLE (TYPE_BINFO (basetype));\n-  BINFO_VIRTUALS (TYPE_BINFO (t)) = BINFO_VIRTUALS (TYPE_BINFO (basetype));\n-  TYPE_VFIELD (t) = TYPE_VFIELD (basetype);\n-}\n-\n-/* Determine the primary class for T.  */\n-\n-static void\n-determine_primary_base (tree t)\n-{\n-  unsigned i, n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (t));\n-  tree type_binfo = TYPE_BINFO (t);\n-  tree vbase_binfo;\n-  tree base_binfo;\n-  VEC(tree) *vbases;\n-\n-  /* If there are no baseclasses, there is certainly no primary base.  */\n-  if (n_baseclasses == 0)\n-    return;\n \n+  /* First look for a dynamic direct non-virtual base.  */\n   for (i = 0; BINFO_BASE_ITERATE (type_binfo, i, base_binfo); i++)\n     {\n       tree basetype = BINFO_TYPE (base_binfo);\n \n-      if (TYPE_CONTAINS_VPTR_P (basetype))\n+      if (TYPE_CONTAINS_VPTR_P (basetype) && !BINFO_VIRTUAL_P (base_binfo))\n \t{\n-\t  /* We prefer a non-virtual base, although a virtual one will\n-\t     do.  */\n-\t  if (BINFO_VIRTUAL_P (base_binfo))\n-\t    continue;\n-\n-\t  if (!CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n-\t    set_primary_base (t, base_binfo);\n-\t}\n-    }\n-\n-  if (!TYPE_VFIELD (t))\n-    CLASSTYPE_PRIMARY_BINFO (t) = NULL_TREE;\n-\n-  /* Find the indirect primary bases - those virtual bases which are primary\n-     bases of something else in this hierarchy.  */\n-  for (vbases = CLASSTYPE_VBASECLASSES (t), i = 0;\n-       VEC_iterate (tree, vbases, i, vbase_binfo); i++)\n-    {\n-      unsigned j;\n-\n-      /* See if this virtual base is an indirect primary base.  To be\n-         so, it must be a primary base within the hierarchy of one of\n-         our direct bases.  */\n-      for (j = 0; BINFO_BASE_ITERATE (type_binfo, j, base_binfo); j++)\n-\t{\n-\t  unsigned k;\n-\t  VEC (tree) *base_vbases;\n-\t  tree base_vbase_binfo;\n-\t  tree basetype = BINFO_TYPE (base_binfo);\n-\t  \n-\t  for (base_vbases = CLASSTYPE_VBASECLASSES (basetype), k = 0;\n-\t       VEC_iterate (tree, base_vbases, k, base_vbase_binfo); k++)\n-\t    {\n-\t      if (BINFO_PRIMARY_P (base_vbase_binfo)\n-\t\t  && same_type_p (BINFO_TYPE (base_vbase_binfo),\n-\t\t\t\t  BINFO_TYPE (vbase_binfo)))\n-\t\t{\n-\t\t  BINFO_INDIRECT_PRIMARY_P (vbase_binfo) = 1;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\n-\t  /* If we've discovered that this virtual base is an indirect\n-\t     primary base, then we can move on to the next virtual\n-\t     base.  */\n-\t  if (BINFO_INDIRECT_PRIMARY_P (vbase_binfo))\n-\t    break;\n+\t  primary = base_binfo;\n+\t  goto found;\n \t}\n     }\n \n   /* A \"nearly-empty\" virtual base class can be the primary base\n-     class, if no non-virtual polymorphic base can be found.  */\n-  if (!CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n+     class, if no non-virtual polymorphic base can be found.  Look for\n+     a nearly-empty virtual dynamic base that is not already a primary\n+     base of something in the heirarchy.  If there is no such base,\n+     just pick the first nearly-empty virtual base.  */\n+\n+  for (base_binfo = TREE_CHAIN (type_binfo); base_binfo;\n+       base_binfo = TREE_CHAIN (base_binfo))\n+    if (BINFO_VIRTUAL_P (base_binfo)\n+\t&& CLASSTYPE_NEARLY_EMPTY_P (BINFO_TYPE (base_binfo)))\n+      {\n+\tif (!BINFO_PRIMARY_P (base_binfo))\n+\t  {\n+\t    /* Found one that is not primary.  */\n+\t    primary = base_binfo;\n+\t    goto found;\n+\t  }\n+\telse if (!primary)\n+\t  /* Remember the first candidate.  */\n+\t  primary = base_binfo;\n+      }\n+  \n+ found:\n+  /* If we've got a primary base, use it.  */\n+  if (primary)\n     {\n-      /* If not NULL, this is the best primary base candidate we have\n-         found so far.  */\n-      tree candidate = NULL_TREE;\n-      tree base_binfo;\n-\n-      /* Loop over the baseclasses.  */\n-      for (base_binfo = TYPE_BINFO (t);\n-\t   base_binfo;\n-\t   base_binfo = TREE_CHAIN (base_binfo))\n+      tree basetype = BINFO_TYPE (primary);\n+      \n+      CLASSTYPE_PRIMARY_BINFO (t) = primary;\n+      if (BINFO_PRIMARY_P (primary))\n+\t/* We are stealing a primary base.  */\n+\tBINFO_LOST_PRIMARY_P (BINFO_INHERITANCE_CHAIN (primary)) = 1;\n+      BINFO_PRIMARY_P (primary) = 1;\n+      if (BINFO_VIRTUAL_P (primary))\n \t{\n-\t  tree basetype = BINFO_TYPE (base_binfo);\n+\t  tree delta;\n \n-\t  if (BINFO_VIRTUAL_P (base_binfo) \n-\t      && CLASSTYPE_NEARLY_EMPTY_P (basetype))\n-\t    {\n-\t      /* If this is not an indirect primary base, then it's\n-\t\t definitely our primary base.  */\n-\t      if (!BINFO_INDIRECT_PRIMARY_P (base_binfo))\n-\t\t{\n-\t\t  candidate = base_binfo;\n-\t\t  break;\n-\t\t}\n-\n-\t      /* If this is an indirect primary base, it still could be\n-\t         our primary base -- unless we later find there's another\n-\t         nearly-empty virtual base that isn't an indirect\n-\t         primary base.  */\n-\t      if (!candidate)\n-\t\tcandidate = base_binfo;\n-\t    }\n+\t  BINFO_INHERITANCE_CHAIN (primary) = type_binfo;\n+\t  /* A virtual binfo might have been copied from within\n+  \t     another hierarchy. As we're about to use it as a primary\n+  \t     base, make sure the offsets match.  */\n+\t  delta = size_diffop (ssize_int (0),\n+\t\t\t       convert (ssizetype, BINFO_OFFSET (primary)));\n+\t  \n+\t  propagate_binfo_offsets (primary, delta);\n \t}\n-\n-      /* If we've got a primary base, use it.  */\n-      if (candidate)\n-\tset_primary_base (t, candidate);\n+      \n+      primary = TYPE_BINFO (basetype);\n+      \n+      TYPE_VFIELD (t) = TYPE_VFIELD (basetype);\n+      BINFO_VTABLE (type_binfo) = BINFO_VTABLE (primary);\n+      BINFO_VIRTUALS (type_binfo) = BINFO_VIRTUALS (primary);\n     }\n-\n-  /* Mark the primary base classes at this point.  */\n-  mark_primary_bases (t);\n }\n \f\n /* Set memoizing fields and bits of T (and its variants) for later\n@@ -3324,7 +3278,8 @@ walk_subobject_offsets (tree type,\n \t      tree vbase = get_primary_binfo (type_binfo);\n \t      \n \t      if (vbase && BINFO_VIRTUAL_P (vbase)\n-\t\t  && BINFO_PRIMARY_BASE_OF (vbase) == type_binfo)\n+\t\t  && BINFO_PRIMARY_P (vbase)\n+\t\t  && BINFO_INHERITANCE_CHAIN (vbase) == type_binfo)\n \t\t{\n \t\t  r = (walk_subobject_offsets \n \t\t       (vbase, f, offset,\n@@ -4346,7 +4301,7 @@ propagate_binfo_offsets (tree binfo, tree offset)\n   /* Find the primary base class.  */\n   primary_binfo = get_primary_binfo (binfo);\n \n-  if (primary_binfo && BINFO_PRIMARY_BASE_OF (primary_binfo) == binfo)\n+  if (primary_binfo && BINFO_INHERITANCE_CHAIN (primary_binfo) == binfo)\n     propagate_binfo_offsets (primary_binfo, offset);\n   \n   /* Scan all of the bases, pushing the BINFO_OFFSET adjust\n@@ -4477,8 +4432,9 @@ end_of_class (tree t, int include_virtuals_p)\n        BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n     {\n       if (!include_virtuals_p\n-\t  && BINFO_VIRTUAL_P (base_binfo) \n-\t  && BINFO_PRIMARY_BASE_OF (base_binfo) != TYPE_BINFO (t))\n+\t  && BINFO_VIRTUAL_P (base_binfo)\n+\t  && (!BINFO_PRIMARY_P (base_binfo)\n+\t      || BINFO_INHERITANCE_CHAIN (base_binfo) != TYPE_BINFO (t)))\n \tcontinue;\n \n       offset = end_of_base (base_binfo);\n@@ -4620,9 +4576,8 @@ layout_class_type (tree t, tree *virtuals_p)\n   /* Start laying out the record.  */\n   rli = start_record_layout (t);\n \n-  /* If possible, we reuse the virtual function table pointer from one\n-     of our base classes.  */\n-  determine_primary_base (t);\n+  /* Mark all the primary bases in the hierarchy.  */\n+  determine_primary_bases (t);\n \n   /* Create a pointer to our virtual function table.  */\n   vptr = create_vtable_ptr (t, virtuals_p);\n@@ -6452,7 +6407,7 @@ dump_class_hierarchy_r (FILE *stream,\n   \n   indented = maybe_indent_hierarchy (stream, indent, 0);\n   fprintf (stream, \"%s (0x%lx) \",\n-\t   type_as_string (binfo, TFF_PLAIN_IDENTIFIER),\n+\t   type_as_string (BINFO_TYPE (binfo), TFF_PLAIN_IDENTIFIER),\n \t   (unsigned long) binfo);\n   if (binfo != igo)\n     {\n@@ -6472,13 +6427,13 @@ dump_class_hierarchy_r (FILE *stream,\n   fprintf (stream, \"\\n\");\n \n   indented = 0;\n-  if (BINFO_PRIMARY_BASE_OF (binfo))\n+  if (BINFO_PRIMARY_P (binfo))\n     {\n       indented = maybe_indent_hierarchy (stream, indent + 3, indented);\n       fprintf (stream, \" primary-for %s (0x%lx)\",\n-\t       type_as_string (BINFO_PRIMARY_BASE_OF (binfo),\n+\t       type_as_string (BINFO_TYPE (BINFO_INHERITANCE_CHAIN (binfo)),\n \t\t\t       TFF_PLAIN_IDENTIFIER),\n-\t       (unsigned long)BINFO_PRIMARY_BASE_OF (binfo));\n+\t       (unsigned long)BINFO_INHERITANCE_CHAIN (binfo));\n     }\n   if (BINFO_LOST_PRIMARY_P (binfo))\n     {\n@@ -6607,7 +6562,7 @@ dump_vtable (tree t, tree binfo, tree vtable)\n       \n       fprintf (stream, \"%s for %s\",\n \t       ctor_vtbl_p ? \"Construction vtable\" : \"Vtable\",\n-\t       type_as_string (binfo, TFF_PLAIN_IDENTIFIER));\n+\t       type_as_string (BINFO_TYPE (binfo), TFF_PLAIN_IDENTIFIER));\n       if (ctor_vtbl_p)\n \t{\n \t  if (!BINFO_VIRTUAL_P (binfo))\n@@ -6962,8 +6917,8 @@ dfs_build_secondary_vptr_vtt_inits (tree binfo, void *data)\n       /* It's a primary virtual base, and this is not the construction\n          vtable. Find the base this is primary of in the inheritance graph,\n          and use that base's vtable now.  */\n-      while (BINFO_PRIMARY_BASE_OF (binfo))\n-        binfo = BINFO_PRIMARY_BASE_OF (binfo);\n+      while (BINFO_PRIMARY_P (binfo))\n+        binfo = BINFO_INHERITANCE_CHAIN (binfo);\n     }\n   init = binfo_ctor_vtable (binfo);\n   TREE_VALUE (l) = tree_cons (NULL_TREE, init, TREE_VALUE (l));\n@@ -7155,24 +7110,26 @@ dfs_accumulate_vtbl_inits (tree binfo,\n \t RTTI_BINFO.\n \t 3) We are primary to something not a base of RTTI_BINFO.  */\n \t  \n-      tree b = BINFO_PRIMARY_BASE_OF (binfo);\n+      tree b;\n       tree last = NULL_TREE;\n \n       /* First, look through the bases we are primary to for RTTI_BINFO\n \t or a virtual base.  */\n-      for (; b; b = BINFO_PRIMARY_BASE_OF (b))\n+      b = binfo;\n+      while (BINFO_PRIMARY_P (b))\n \t{\n+\t  b = BINFO_INHERITANCE_CHAIN (b);\n \t  last = b;\n \t  if (BINFO_VIRTUAL_P (b) || b == rtti_binfo)\n-\t    break;\n+\t    goto found;\n \t}\n       /* If we run out of primary links, keep looking down our\n \t inheritance chain; we might be an indirect primary.  */\n-      if (b == NULL_TREE)\n-\tfor (b = last; b; b = BINFO_INHERITANCE_CHAIN (b))\n-\t  if (BINFO_VIRTUAL_P (b) || b == rtti_binfo)\n-\t    break;\n-\n+      for (b = last; b; b = BINFO_INHERITANCE_CHAIN (b))\n+\tif (BINFO_VIRTUAL_P (b) || b == rtti_binfo)\n+\t  break;\n+    found:\n+      \n       /* If we found RTTI_BINFO, this is case 1.  If we found a virtual\n \t base B and it is a base of RTTI_BINFO, this is case 2.  In\n \t either case, we share our vtable with LAST, i.e. the\n@@ -7790,7 +7747,8 @@ build_rtti_vtbl_entries (tree binfo, vtbl_init_data* vid)\n       tree primary_base;\n \n       primary_base = get_primary_binfo (b);\n-      gcc_assert (BINFO_PRIMARY_BASE_OF (primary_base) == b);\n+      gcc_assert (BINFO_PRIMARY_P (primary_base)\n+\t\t  && BINFO_INHERITANCE_CHAIN (primary_base) == b);\n       b = primary_base;\n     }\n   offset = size_diffop (BINFO_OFFSET (vid->rtti_binfo), BINFO_OFFSET (b));"}, {"sha": "49c9d4714515aeec8e6fc4dcc9f49fb79454cb8e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81", "patch": "@@ -1405,14 +1405,6 @@ struct lang_type GTY(())\n \f\n /* Additional macros for inheritance information.  */\n \n-/* The BINFO_INHERITANCE_CHAIN is used opposite to the description in\n-   gcc/tree.h.  In particular if D is non-virtually derived from B\n-   then the BINFO for B (in D) will have a BINFO_INHERITANCE_CHAIN\n-   pointing to D.  If D is virtually derived, its\n-   BINFO_INHERITANCE_CHAIN will point to the most derived binfo. In\n-   tree.h, this pointer is described as pointing in other\n-   direction.  The binfos of virtual bases are shared.  */\n-\n /* Nonzero means that this class is on a path leading to a new vtable.  */\n #define BINFO_VTABLE_PATH_MARKED(NODE) BINFO_FLAG_1 (NODE)\n \n@@ -1428,11 +1420,6 @@ struct lang_type GTY(())\n    gcc_assert (!BINFO_PRIMARY_P (B) || BINFO_VIRTUAL_P (B)),\t\t \\\n    gcc_assert (TYPE_VFIELD (BINFO_TYPE (B))))\n \n-/* Nonzero if this BINFO is a primary base class.  */\n-\n-#define BINFO_PRIMARY_P(NODE) \\\n-  (BINFO_PRIMARY_BASE_OF (NODE) != NULL_TREE)\n-\n /* Nonzero if this binfo is for a dependent base - one that should not\n    be searched.  */\n #define BINFO_DEPENDENT_BASE_P(NODE) BINFO_FLAG_3 (NODE)\n@@ -1442,10 +1429,8 @@ struct lang_type GTY(())\n    base in the complete hierarchy.  */\n #define BINFO_LOST_PRIMARY_P(NODE) BINFO_FLAG_4 (NODE)\n \n-/* Nonzero if this binfo is an indirect primary base, i.e. a virtual\n-   base that is a primary base of some of other class in the\n-   hierarchy.  */\n-#define BINFO_INDIRECT_PRIMARY_P(NODE) BINFO_FLAG_5 (NODE)\n+/* Nonzero if this BINFO is a primary base class.  */\n+#define BINFO_PRIMARY_P(NODE) BINFO_FLAG_5(NODE)\n \n /* Used by various search routines.  */\n #define IDENTIFIER_MARKED(NODE) TREE_LANG_FLAG_0 (NODE)"}, {"sha": "ea38333d776ae99c5a837db50de6215134bdda8d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81", "patch": "@@ -716,15 +716,14 @@ build_vtbl_address (tree binfo)\n   tree binfo_for = binfo;\n   tree vtbl;\n \n-  if (BINFO_VPTR_INDEX (binfo) && BINFO_VIRTUAL_P (binfo)\n-      && BINFO_PRIMARY_P (binfo))\n+  if (BINFO_VPTR_INDEX (binfo) && BINFO_VIRTUAL_P (binfo))\n     /* If this is a virtual primary base, then the vtable we want to store\n        is that for the base this is being used as the primary base of.  We\n        can't simply skip the initialization, because we may be expanding the\n        inits of a subobject constructor where the virtual base layout\n        can be different.  */\n-    while (BINFO_PRIMARY_BASE_OF (binfo_for))\n-      binfo_for = BINFO_PRIMARY_BASE_OF (binfo_for);\n+    while (BINFO_PRIMARY_P (binfo_for))\n+      binfo_for = BINFO_INHERITANCE_CHAIN (binfo_for);\n \n   /* Figure out what vtable BINFO's vtable is based on, and mark it as\n      used.  */"}, {"sha": "d6b0ba887c282a169d3c1999d1a958126781b7be", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=fc6633e0cf54d9d3a5f57ce6e33dfd1af8a5ac81", "patch": "@@ -1706,15 +1706,10 @@ struct tree_type GTY(())\n    found.  NULL_TREE if there is no secondary vptr in the VTT.  */\n #define BINFO_VPTR_INDEX(NODE) (TREE_BINFO_CHECK(NODE)->binfo.vtt_vptr)\n \n-/* The binfo of which NODE is a primary base.  (This is different from\n-   BINFO_INHERITANCE_CHAIN for virtual base because a virtual base is\n-   sometimes a primary base for a class for which it is not an\n-   immediate base.)  */\n-#define BINFO_PRIMARY_BASE_OF(NODE) (TREE_BINFO_CHECK(NODE)->binfo.primary)\n-\n /* The BINFO_INHERITANCE_CHAIN points at the binfo for the base\n    inheriting this base for non-virtual bases. For virtual bases it\n-   points to the binfo of the most derived type.  */\n+   points either to the binfo for which this is a primary binfo, or to\n+   the binfo of the most derived type.  */\n #define BINFO_INHERITANCE_CHAIN(NODE) \\\n \t(TREE_BINFO_CHECK(NODE)->binfo.inheritance)\n \n@@ -1731,7 +1726,6 @@ struct tree_binfo GTY (())\n \n   tree vtt_subvtt;\n   tree vtt_vptr;\n-  tree primary;\n \n   VEC(tree) base_binfos;\n };"}]}