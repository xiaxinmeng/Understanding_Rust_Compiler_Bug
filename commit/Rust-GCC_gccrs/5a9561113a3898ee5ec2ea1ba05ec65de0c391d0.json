{"sha": "5a9561113a3898ee5ec2ea1ba05ec65de0c391d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE5NTYxMTEzYTM4OThlZTVlYzJlYTFiYTA1ZWM2NWRlMGMzOTFkMA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@gcc.gnu.org", "date": "2016-04-29T19:15:25Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-04-29T19:15:25Z"}, "message": "tree-ssa-threadedge.c (simplify_control_stmt_condition): Split out into ...\n\n2016-04-29  Patrick Palka  <ppalka@gcc.gnu.org>\n\n\t* tree-ssa-threadedge.c (simplify_control_stmt_condition): Split\n\tout into ...\n\t(simplify_control_stmt_condition_1): ... here.  Recurse into\n\tBIT_AND_EXPRs and BIT_IOR_EXPRs.\n\n\t* gcc.dg/tree-ssa/ssa-thread-14.c: New test.\n\t* gcc.dg/tree-ssa/ssa-thread-11.c: Update expected output.\n\nFrom-SVN: r235653", "tree": {"sha": "5fc4528bd0d7e8087d0bf4d57163920283516515", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fc4528bd0d7e8087d0bf4d57163920283516515"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a9561113a3898ee5ec2ea1ba05ec65de0c391d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a9561113a3898ee5ec2ea1ba05ec65de0c391d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a9561113a3898ee5ec2ea1ba05ec65de0c391d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a9561113a3898ee5ec2ea1ba05ec65de0c391d0/comments", "author": null, "committer": null, "parents": [{"sha": "e7ff0319f3736617c70742d8233d73faad523aa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7ff0319f3736617c70742d8233d73faad523aa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7ff0319f3736617c70742d8233d73faad523aa3"}], "stats": {"total": 343, "additions": 297, "deletions": 46}, "files": [{"sha": "e3458cc732a90a620df51706ba568f9688905a4a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9561113a3898ee5ec2ea1ba05ec65de0c391d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9561113a3898ee5ec2ea1ba05ec65de0c391d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a9561113a3898ee5ec2ea1ba05ec65de0c391d0", "patch": "@@ -1,3 +1,10 @@\n+2016-04-29  Patrick Palka  <ppalka@gcc.gnu.org>\n+\n+\t* tree-ssa-threadedge.c (simplify_control_stmt_condition): Split\n+\tout into ...\n+\t(simplify_control_stmt_condition_1): ... here.  Recurse into\n+\tBIT_AND_EXPRs and BIT_IOR_EXPRs.\n+\n 2016-04-29  David Edelsohn  <dje.gcc@gmail.com>\n \n \tPR target/69810"}, {"sha": "0d0f252b4528e4b9604ee24bffcdac7c8c73f05f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9561113a3898ee5ec2ea1ba05ec65de0c391d0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9561113a3898ee5ec2ea1ba05ec65de0c391d0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5a9561113a3898ee5ec2ea1ba05ec65de0c391d0", "patch": "@@ -1,3 +1,8 @@\n+2016-04-29  Patrick Palka  <ppalka@gcc.gnu.org>\n+\n+\t* gcc.dg/tree-ssa/ssa-thread-14.c: New test.\n+\t* gcc.dg/tree-ssa/ssa-thread-11.c: Update expected output.\n+\n 2016-04-29  Cesar Philippidis  <cesar@codesourcery.com>\n \n \tPR middle-end/70626"}, {"sha": "d28a0eb068923a9c9b78ccd4ca402c896ce0c0ea", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-thread-11.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9561113a3898ee5ec2ea1ba05ec65de0c391d0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9561113a3898ee5ec2ea1ba05ec65de0c391d0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-11.c?ref=5a9561113a3898ee5ec2ea1ba05ec65de0c391d0", "patch": "@@ -1,7 +1,6 @@\n /* { dg-do compile { target { ! { logical_op_short_circuit || { m68k*-*-* mep*-*-* bfin*-*-* v850*-*-* moxie*-*-* m32c*-*-* fr30*-*-* mcore*-*-* frv-*-* h8300-*-* m32r-*-* mn10300-*-* msp430-*-* pdp11-*-* rl78-*-* rx-*-* vax-*-*} } } } } */\n /* { dg-options \"-O2 -fdump-tree-vrp2-details\" } */\n /* { dg-final { scan-tree-dump-not \"IRREDUCIBLE_LOOP\" \"vrp2\" } } */\n-/* { dg-final { scan-tree-dump \"FSM\" \"vrp2\" } } */\n \n void abort (void);\n typedef struct bitmap_head_def *bitmap;"}, {"sha": "db9ed3bb0394cc8bed0f5d2e90614f081a655517", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-thread-14.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9561113a3898ee5ec2ea1ba05ec65de0c391d0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9561113a3898ee5ec2ea1ba05ec65de0c391d0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-14.c?ref=5a9561113a3898ee5ec2ea1ba05ec65de0c391d0", "patch": "@@ -0,0 +1,81 @@\n+/* { dg-do compile }  */\n+/* { dg-additional-options \"-O2 -fdump-tree-vrp\" }  */\n+/* { dg-final { scan-tree-dump-times \"Threaded jump\" 8 \"vrp1\" } }  */\n+\n+void foo (void);\n+void bar (void);\n+void blah (void);\n+\n+/* One jump threaded here.  */\n+\n+void\n+baz_1 (int a, int b, int c)\n+{\n+  if (a && b)\n+    foo ();\n+  if (!b && c)\n+    bar ();\n+}\n+\n+/* One jump threaded here.  */\n+\n+void\n+baz_2 (int a, int b, int c)\n+{\n+  if (a && b)\n+    foo ();\n+  if (b || c)\n+    bar ();\n+}\n+\n+/* One jump threaded here.  */\n+\n+void\n+baz_3 (int a, int b, int c)\n+{\n+  if (a && b > 10)\n+    foo ();\n+  if (b < 5 && c)\n+    bar ();\n+}\n+\n+/* Two jumps threaded here.  */\n+\n+void\n+baz_4 (int a, int b, int c)\n+{\n+  if (a && b)\n+    {\n+      foo ();\n+      if (c)\n+        bar ();\n+    }\n+  if (b && c)\n+    blah ();\n+}\n+\n+/* Two jumps threaded here.  */\n+\n+void\n+baz_5 (int a, int b, int c)\n+{\n+  if (a && b)\n+    {\n+      foo ();\n+      if (c)\n+        bar ();\n+    }\n+  if (!b || !c)\n+    blah ();\n+}\n+\n+/* One jump threaded here.  */\n+\n+void\n+baz_6 (int a, int b, int c)\n+{\n+  if (a == 39 && b == 41)\n+    foo ();\n+  if (c == 12 || b == 41)\n+    bar ();\n+}"}, {"sha": "eca3812090f35c7d62504ca9e10239dcf0d80cd1", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 204, "deletions": 45, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9561113a3898ee5ec2ea1ba05ec65de0c391d0/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9561113a3898ee5ec2ea1ba05ec65de0c391d0/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=5a9561113a3898ee5ec2ea1ba05ec65de0c391d0", "patch": "@@ -376,6 +376,12 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n   return stmt;\n }\n \n+static tree simplify_control_stmt_condition_1 (edge, gimple *,\n+\t\t\t\t\t       class avail_exprs_stack *,\n+\t\t\t\t\t       tree, enum tree_code, tree,\n+\t\t\t\t\t       gcond *, pfn_simplify, bool,\n+\t\t\t\t\t       unsigned);\n+\n /* Simplify the control statement at the end of the block E->dest.\n \n    To avoid allocating memory unnecessarily, a scratch GIMPLE_COND\n@@ -436,52 +442,14 @@ simplify_control_stmt_condition (edge e,\n \t    }\n \t}\n \n-      if (handle_dominating_asserts)\n-\t{\n-\t  /* Now see if the operand was consumed by an ASSERT_EXPR\n-\t     which dominates E->src.  If so, we want to replace the\n-\t     operand with the LHS of the ASSERT_EXPR.  */\n-\t  if (TREE_CODE (op0) == SSA_NAME)\n-\t    op0 = lhs_of_dominating_assert (op0, e->src, stmt);\n-\n-\t  if (TREE_CODE (op1) == SSA_NAME)\n-\t    op1 = lhs_of_dominating_assert (op1, e->src, stmt);\n-\t}\n-\n-      /* We may need to canonicalize the comparison.  For\n-\t example, op0 might be a constant while op1 is an\n-\t SSA_NAME.  Failure to canonicalize will cause us to\n-\t miss threading opportunities.  */\n-      if (tree_swap_operands_p (op0, op1, false))\n-\t{\n-\t  cond_code = swap_tree_comparison (cond_code);\n-\t  std::swap (op0, op1);\n-\t}\n+      const unsigned recursion_limit = 4;\n \n-      /* Stuff the operator and operands into our dummy conditional\n-\t expression.  */\n-      gimple_cond_set_code (dummy_cond, cond_code);\n-      gimple_cond_set_lhs (dummy_cond, op0);\n-      gimple_cond_set_rhs (dummy_cond, op1);\n-\n-      /* We absolutely do not care about any type conversions\n-         we only care about a zero/nonzero value.  */\n-      fold_defer_overflow_warnings ();\n-\n-      cached_lhs = fold_binary (cond_code, boolean_type_node, op0, op1);\n-      if (cached_lhs)\n-\twhile (CONVERT_EXPR_P (cached_lhs))\n-          cached_lhs = TREE_OPERAND (cached_lhs, 0);\n-\n-      fold_undefer_overflow_warnings ((cached_lhs\n-                                       && is_gimple_min_invariant (cached_lhs)),\n-\t\t\t\t      stmt, WARN_STRICT_OVERFLOW_CONDITIONAL);\n-\n-      /* If we have not simplified the condition down to an invariant,\n-\t then use the pass specific callback to simplify the condition.  */\n-      if (!cached_lhs\n-          || !is_gimple_min_invariant (cached_lhs))\n-        cached_lhs = (*simplify) (dummy_cond, stmt, avail_exprs_stack);\n+      cached_lhs\n+\t= simplify_control_stmt_condition_1 (e, stmt, avail_exprs_stack,\n+\t\t\t\t\t     op0, cond_code, op1,\n+\t\t\t\t\t     dummy_cond, simplify,\n+\t\t\t\t\t     handle_dominating_asserts,\n+\t\t\t\t\t     recursion_limit);\n \n       /* If we were testing an integer/pointer against a constant, then\n \t we can use the FSM code to trace the value of the SSA_NAME.  If\n@@ -560,6 +528,197 @@ simplify_control_stmt_condition (edge e,\n   return cached_lhs;\n }\n \n+/* Recursive helper for simplify_control_stmt_condition.  */\n+\n+static tree\n+simplify_control_stmt_condition_1 (edge e,\n+\t\t\t\t   gimple *stmt,\n+\t\t\t\t   class avail_exprs_stack *avail_exprs_stack,\n+\t\t\t\t   tree op0,\n+\t\t\t\t   enum tree_code cond_code,\n+\t\t\t\t   tree op1,\n+\t\t\t\t   gcond *dummy_cond,\n+\t\t\t\t   pfn_simplify simplify,\n+\t\t\t\t   bool handle_dominating_asserts,\n+\t\t\t\t   unsigned limit)\n+{\n+  if (limit == 0)\n+    return NULL_TREE;\n+\n+  /* We may need to canonicalize the comparison.  For\n+     example, op0 might be a constant while op1 is an\n+     SSA_NAME.  Failure to canonicalize will cause us to\n+     miss threading opportunities.  */\n+  if (tree_swap_operands_p (op0, op1, false))\n+    {\n+      cond_code = swap_tree_comparison (cond_code);\n+      std::swap (op0, op1);\n+    }\n+\n+  /* If the condition has the form (A & B) CMP 0 or (A | B) CMP 0 then\n+     recurse into the LHS to see if there is a dominating ASSERT_EXPR\n+     of A or of B that makes this condition always true or always false\n+     along the edge E.  */\n+  if (handle_dominating_asserts\n+      && (cond_code == EQ_EXPR || cond_code == NE_EXPR)\n+      && TREE_CODE (op0) == SSA_NAME\n+      && integer_zerop (op1))\n+    {\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (op0);\n+      if (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n+        ;\n+      else if (gimple_assign_rhs_code (def_stmt) == BIT_AND_EXPR\n+\t       || gimple_assign_rhs_code (def_stmt) == BIT_IOR_EXPR)\n+\t{\n+\t  enum tree_code rhs_code = gimple_assign_rhs_code (def_stmt);\n+\t  const tree rhs1 = gimple_assign_rhs1 (def_stmt);\n+\t  const tree rhs2 = gimple_assign_rhs2 (def_stmt);\n+\t  const tree zero_cst = build_zero_cst (TREE_TYPE (op0));\n+\t  const tree one_cst = build_one_cst (TREE_TYPE (op0));\n+\n+\t  /* Is A != 0 ?  */\n+\t  const tree res1\n+\t    = simplify_control_stmt_condition_1 (e, def_stmt, avail_exprs_stack,\n+\t\t\t\t\t\t rhs1, NE_EXPR, op1,\n+\t\t\t\t\t\t dummy_cond, simplify,\n+\t\t\t\t\t\t handle_dominating_asserts,\n+\t\t\t\t\t\t limit - 1);\n+\t  if (res1 == NULL_TREE)\n+\t    ;\n+\t  else if (rhs_code == BIT_AND_EXPR && integer_zerop (res1))\n+\t    {\n+\t      /* If A == 0 then (A & B) != 0 is always false.  */\n+\t      if (cond_code == NE_EXPR)\n+\t        return zero_cst;\n+\t      /* If A == 0 then (A & B) == 0 is always true.  */\n+\t      if (cond_code == EQ_EXPR)\n+\t\treturn one_cst;\n+\t    }\n+\t  else if (rhs_code == BIT_IOR_EXPR && integer_nonzerop (res1))\n+\t    {\n+\t      /* If A != 0 then (A | B) != 0 is always true.  */\n+\t      if (cond_code == NE_EXPR)\n+\t\treturn one_cst;\n+\t      /* If A != 0 then (A | B) == 0 is always false.  */\n+\t      if (cond_code == EQ_EXPR)\n+\t\treturn zero_cst;\n+\t    }\n+\n+\t  /* Is B != 0 ?  */\n+\t  const tree res2\n+\t    = simplify_control_stmt_condition_1 (e, def_stmt, avail_exprs_stack,\n+\t\t\t\t\t\t rhs2, NE_EXPR, op1,\n+\t\t\t\t\t\t dummy_cond, simplify,\n+\t\t\t\t\t\t handle_dominating_asserts,\n+\t\t\t\t\t\t limit - 1);\n+\t  if (res2 == NULL_TREE)\n+\t    ;\n+\t  else if (rhs_code == BIT_AND_EXPR && integer_zerop (res2))\n+\t    {\n+\t      /* If B == 0 then (A & B) != 0 is always false.  */\n+\t      if (cond_code == NE_EXPR)\n+\t        return zero_cst;\n+\t      /* If B == 0 then (A & B) == 0 is always true.  */\n+\t      if (cond_code == EQ_EXPR)\n+\t\treturn one_cst;\n+\t    }\n+\t  else if (rhs_code == BIT_IOR_EXPR && integer_nonzerop (res2))\n+\t    {\n+\t      /* If B != 0 then (A | B) != 0 is always true.  */\n+\t      if (cond_code == NE_EXPR)\n+\t\treturn one_cst;\n+\t      /* If B != 0 then (A | B) == 0 is always false.  */\n+\t      if (cond_code == EQ_EXPR)\n+\t\treturn zero_cst;\n+\t    }\n+\n+\t  if (res1 != NULL_TREE && res2 != NULL_TREE)\n+\t    {\n+\t      if (rhs_code == BIT_AND_EXPR\n+\t\t  && TYPE_PRECISION (TREE_TYPE (op0)) == 1\n+\t\t  && integer_nonzerop (res1)\n+\t\t  && integer_nonzerop (res2))\n+\t\t{\n+\t\t  /* If A != 0 and B != 0 then (bool)(A & B) != 0 is true.  */\n+\t\t  if (cond_code == NE_EXPR)\n+\t\t    return one_cst;\n+\t\t  /* If A != 0 and B != 0 then (bool)(A & B) == 0 is false.  */\n+\t\t  if (cond_code == EQ_EXPR)\n+\t\t    return zero_cst;\n+\t\t}\n+\n+\t      if (rhs_code == BIT_IOR_EXPR\n+\t\t  && integer_zerop (res1)\n+\t\t  && integer_zerop (res2))\n+\t\t{\n+\t\t  /* If A == 0 and B == 0 then (A | B) != 0 is false.  */\n+\t\t  if (cond_code == NE_EXPR)\n+\t\t    return zero_cst;\n+\t\t  /* If A == 0 and B == 0 then (A | B) == 0 is true.  */\n+\t\t  if (cond_code == EQ_EXPR)\n+\t\t    return one_cst;\n+\t\t}\n+\t    }\n+\t}\n+      /* Handle (A CMP B) CMP 0.  */\n+      else if (TREE_CODE_CLASS (gimple_assign_rhs_code (def_stmt))\n+\t       == tcc_comparison)\n+\t{\n+\t  tree rhs1 = gimple_assign_rhs1 (def_stmt);\n+\t  tree rhs2 = gimple_assign_rhs2 (def_stmt);\n+\n+\t  tree_code new_cond = gimple_assign_rhs_code (def_stmt);\n+\t  if (cond_code == EQ_EXPR)\n+\t    new_cond = invert_tree_comparison (new_cond, false);\n+\n+\t  tree res\n+\t    = simplify_control_stmt_condition_1 (e, def_stmt, avail_exprs_stack,\n+\t\t\t\t\t\t rhs1, new_cond, rhs2,\n+\t\t\t\t\t\t dummy_cond, simplify,\n+\t\t\t\t\t\t handle_dominating_asserts,\n+\t\t\t\t\t\t limit - 1);\n+\t  if (res != NULL_TREE && is_gimple_min_invariant (res))\n+\t    return res;\n+\t}\n+    }\n+\n+  if (handle_dominating_asserts)\n+    {\n+      /* Now see if the operand was consumed by an ASSERT_EXPR\n+\t which dominates E->src.  If so, we want to replace the\n+\t operand with the LHS of the ASSERT_EXPR.  */\n+      if (TREE_CODE (op0) == SSA_NAME)\n+\top0 = lhs_of_dominating_assert (op0, e->src, stmt);\n+\n+      if (TREE_CODE (op1) == SSA_NAME)\n+\top1 = lhs_of_dominating_assert (op1, e->src, stmt);\n+    }\n+\n+  gimple_cond_set_code (dummy_cond, cond_code);\n+  gimple_cond_set_lhs (dummy_cond, op0);\n+  gimple_cond_set_rhs (dummy_cond, op1);\n+\n+  /* We absolutely do not care about any type conversions\n+     we only care about a zero/nonzero value.  */\n+  fold_defer_overflow_warnings ();\n+\n+  tree res = fold_binary (cond_code, boolean_type_node, op0, op1);\n+  if (res)\n+    while (CONVERT_EXPR_P (res))\n+      res = TREE_OPERAND (res, 0);\n+\n+  fold_undefer_overflow_warnings ((res && is_gimple_min_invariant (res)),\n+\t\t\t\t  stmt, WARN_STRICT_OVERFLOW_CONDITIONAL);\n+\n+  /* If we have not simplified the condition down to an invariant,\n+     then use the pass specific callback to simplify the condition.  */\n+  if (!res\n+      || !is_gimple_min_invariant (res))\n+    res = (*simplify) (dummy_cond, stmt, avail_exprs_stack);\n+\n+  return res;\n+}\n+\n /* Copy debug stmts from DEST's chain of single predecessors up to\n    SRC, so that we don't lose the bindings as PHI nodes are introduced\n    when DEST gains new predecessors.  */"}]}