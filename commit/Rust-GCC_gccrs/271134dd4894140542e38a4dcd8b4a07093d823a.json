{"sha": "271134dd4894140542e38a4dcd8b4a07093d823a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjcxMTM0ZGQ0ODk0MTQwNTQyZTM4YTRkY2Q4YjRhMDcwOTNkODIzYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-19T11:57:34Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-19T11:57:34Z"}, "message": "Avoid ICE for nested inductions (PR 83914)\n\nThis testcase ICEd because we converted the initial value of an\ninduction to the vector element type even for nested inductions.\nThis isn't necessary because the initial expression is vectorised\nnormally, and it meant that init_expr was no longer the original\nstatement operand by the time we called vect_get_vec_def_for_operand.\n\nAlso, adding the conversion code here made the existing SLP conversion\nredundant.\n\n2018-01-19  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\tPR tree-optimization/83914\n\t* tree-vect-loop.c (vectorizable_induction): Don't convert\n\tinit_expr or apply the peeling adjustment for inductions\n\tthat are nested within the vectorized loop.\n\ngcc/testsuite/\n\tPR tree-optimization/83914\n\t* gcc.dg/vect/pr83914.c: New test.\n\nFrom-SVN: r256884", "tree": {"sha": "c5cf9e658d84fb886f540d045d804e2242056a67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5cf9e658d84fb886f540d045d804e2242056a67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/271134dd4894140542e38a4dcd8b4a07093d823a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/271134dd4894140542e38a4dcd8b4a07093d823a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/271134dd4894140542e38a4dcd8b4a07093d823a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/271134dd4894140542e38a4dcd8b4a07093d823a/comments", "author": null, "committer": null, "parents": [{"sha": "4b04107b254614bd041e61aacb514d19bccba212", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b04107b254614bd041e61aacb514d19bccba212", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b04107b254614bd041e61aacb514d19bccba212"}], "stats": {"total": 77, "additions": 50, "deletions": 27}, "files": [{"sha": "a86ea914ca554ce7589e93fe2cc2b43ab3115b57", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/271134dd4894140542e38a4dcd8b4a07093d823a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/271134dd4894140542e38a4dcd8b4a07093d823a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=271134dd4894140542e38a4dcd8b4a07093d823a", "patch": "@@ -1,3 +1,10 @@\n+2018-01-19  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/83914\n+\t* tree-vect-loop.c (vectorizable_induction): Don't convert\n+\tinit_expr or apply the peeling adjustment for inductions\n+\tthat are nested within the vectorized loop.\n+\n 2018-01-19  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/thumb2.md (*thumb2_negsi2_short): Use RSB mnemonic"}, {"sha": "44080e0b54af607f190658b631fb57800ecf7f5d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/271134dd4894140542e38a4dcd8b4a07093d823a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/271134dd4894140542e38a4dcd8b4a07093d823a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=271134dd4894140542e38a4dcd8b4a07093d823a", "patch": "@@ -1,3 +1,8 @@\n+2018-01-19  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/83914\n+\t* gcc.dg/vect/pr83914.c: New test.\n+\n 2018-01-19  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* gcc.target/arm/negdi-1.c: Remove bogus assembler scan for negs."}, {"sha": "0bef7986bc288744c24c848fab5ad81dc2509a8b", "filename": "gcc/testsuite/gcc.dg/vect/pr83914.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/271134dd4894140542e38a4dcd8b4a07093d823a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr83914.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/271134dd4894140542e38a4dcd8b4a07093d823a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr83914.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr83914.c?ref=271134dd4894140542e38a4dcd8b4a07093d823a", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O3\" } */\n+\n+struct s { struct s *ptrs[16]; } *a, *b;\n+int c;\n+void\n+foo (int n)\n+{\n+  for (; n; a = b, n--)\n+    {\n+      b = a + 1;\n+      for (c = 8; c; c--)\n+\ta->ptrs[c] = b;\n+    }\n+}"}, {"sha": "8b2ecf84e3f652e2a31cbd5bcbb0c34d59f0e6b8", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/271134dd4894140542e38a4dcd8b4a07093d823a/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/271134dd4894140542e38a4dcd8b4a07093d823a/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=271134dd4894140542e38a4dcd8b4a07093d823a", "patch": "@@ -7678,28 +7678,33 @@ vectorizable_induction (gimple *phi,\n   init_expr = PHI_ARG_DEF_FROM_EDGE (phi,\n \t\t\t\t     loop_preheader_edge (iv_loop));\n \n-  /* Convert the initial value and step to the desired type.  */\n   stmts = NULL;\n-  init_expr = gimple_convert (&stmts, TREE_TYPE (vectype), init_expr);\n-  step_expr = gimple_convert (&stmts, TREE_TYPE (vectype), step_expr);\n-\n-  /* If we are using the loop mask to \"peel\" for alignment then we need\n-     to adjust the start value here.  */\n-  tree skip_niters = LOOP_VINFO_MASK_SKIP_NITERS (loop_vinfo);\n-  if (skip_niters != NULL_TREE)\n+  if (!nested_in_vect_loop)\n     {\n-      if (FLOAT_TYPE_P (vectype))\n-\tskip_niters = gimple_build (&stmts, FLOAT_EXPR, TREE_TYPE (vectype),\n-\t\t\t\t    skip_niters);\n-      else\n-\tskip_niters = gimple_convert (&stmts, TREE_TYPE (vectype),\n-\t\t\t\t      skip_niters);\n-      tree skip_step = gimple_build (&stmts, MULT_EXPR, TREE_TYPE (vectype),\n-\t\t\t\t     skip_niters, step_expr);\n-      init_expr = gimple_build (&stmts, MINUS_EXPR, TREE_TYPE (vectype),\n-\t\t\t\tinit_expr, skip_step);\n+      /* Convert the initial value to the desired type.  */\n+      tree new_type = TREE_TYPE (vectype);\n+      init_expr = gimple_convert (&stmts, new_type, init_expr);\n+\n+      /* If we are using the loop mask to \"peel\" for alignment then we need\n+\t to adjust the start value here.  */\n+      tree skip_niters = LOOP_VINFO_MASK_SKIP_NITERS (loop_vinfo);\n+      if (skip_niters != NULL_TREE)\n+\t{\n+\t  if (FLOAT_TYPE_P (vectype))\n+\t    skip_niters = gimple_build (&stmts, FLOAT_EXPR, new_type,\n+\t\t\t\t\tskip_niters);\n+\t  else\n+\t    skip_niters = gimple_convert (&stmts, new_type, skip_niters);\n+\t  tree skip_step = gimple_build (&stmts, MULT_EXPR, new_type,\n+\t\t\t\t\t skip_niters, step_expr);\n+\t  init_expr = gimple_build (&stmts, MINUS_EXPR, new_type,\n+\t\t\t\t    init_expr, skip_step);\n+\t}\n     }\n \n+  /* Convert the step to the desired type.  */\n+  step_expr = gimple_convert (&stmts, TREE_TYPE (vectype), step_expr);\n+\n   if (stmts)\n     {\n       new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n@@ -7718,15 +7723,6 @@ vectorizable_induction (gimple *phi,\n       /* Enforced above.  */\n       unsigned int const_nunits = nunits.to_constant ();\n \n-      /* Convert the init to the desired type.  */\n-      stmts = NULL;\n-      init_expr = gimple_convert (&stmts, TREE_TYPE (vectype), init_expr);\n-      if (stmts)\n-\t{\n-\t  new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n-\t  gcc_assert (!new_bb);\n-\t}\n-\n       /* Generate [VF*S, VF*S, ... ].  */\n       if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (step_expr)))\n \t{"}]}