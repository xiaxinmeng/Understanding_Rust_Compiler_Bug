{"sha": "37d6f666cae62d9d44c5aef4b2185e43635d5091", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdkNmY2NjZjYWU2MmQ5ZDQ0YzVhZWY0YjIxODVlNDM2MzVkNTA5MQ==", "commit": {"author": {"name": "Wei Mi", "email": "wmi@google.com", "date": "2012-11-12T15:51:13Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2012-11-12T15:51:13Z"}, "message": "Initial import of asan from the Google branch\n\nThis patch imports the initial state of asan as it was in the\nGoogle branch.\n\nIt provides basic infrastructure for asan to instrument memory\naccesses on the heap, at -O3.  Note that it supports neither stack nor\nglobal variable protection.\n\nThe rest of the patches of the set is intended to further improve this\nbase.\n\ngcc/ChangeLog\n\n\t* Makefile.in: Add asan.c and its dependencies.\n\t* common.opt: Add -faddress-sanitizer option.\n\t* invoke.texi: Document the new flag.\n\t* passes.c: Add the asan pass.\n\t* toplev.c (compile_file): Call asan_finish_file.\n\t* asan.c: New file.\n\t* asan.h: New file.\n\t* tree-pass.h: Declare pass_asan.\n\nCo-Authored-By: Diego Novillo <dnovillo@google.com>\nCo-Authored-By: Dodji Seketeli <dodji@redhat.com>\n\nFrom-SVN: r193432", "tree": {"sha": "b87fd787f6078b7ba49ca0fefd8a3b30b94d2db9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b87fd787f6078b7ba49ca0fefd8a3b30b94d2db9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37d6f666cae62d9d44c5aef4b2185e43635d5091", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37d6f666cae62d9d44c5aef4b2185e43635d5091", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37d6f666cae62d9d44c5aef4b2185e43635d5091", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37d6f666cae62d9d44c5aef4b2185e43635d5091/comments", "author": {"login": "wmi-11", "id": 59629650, "node_id": "MDQ6VXNlcjU5NjI5NjUw", "avatar_url": "https://avatars.githubusercontent.com/u/59629650?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wmi-11", "html_url": "https://github.com/wmi-11", "followers_url": "https://api.github.com/users/wmi-11/followers", "following_url": "https://api.github.com/users/wmi-11/following{/other_user}", "gists_url": "https://api.github.com/users/wmi-11/gists{/gist_id}", "starred_url": "https://api.github.com/users/wmi-11/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wmi-11/subscriptions", "organizations_url": "https://api.github.com/users/wmi-11/orgs", "repos_url": "https://api.github.com/users/wmi-11/repos", "events_url": "https://api.github.com/users/wmi-11/events{/privacy}", "received_events_url": "https://api.github.com/users/wmi-11/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "abfc73778e24d6e8c407150d8071bc7fed755965", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abfc73778e24d6e8c407150d8071bc7fed755965", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abfc73778e24d6e8c407150d8071bc7fed755965"}], "stats": {"total": 472, "additions": 469, "deletions": 3}, "files": [{"sha": "53dfd9817c821a7c429008e77bd6554445f373b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d6f666cae62d9d44c5aef4b2185e43635d5091/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d6f666cae62d9d44c5aef4b2185e43635d5091/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=37d6f666cae62d9d44c5aef4b2185e43635d5091", "patch": "@@ -1,3 +1,16 @@\n+2012-11-12  Wei Mi <wmi@google.com>\n+\t    Diego Novillo <dnovillo@google.com>\n+\t    Dodji Seketeli <dodji@redhat.com>\n+\n+\t* Makefile.in: Add asan.c and its dependencies.\n+\t* common.opt: Add -faddress-sanitizer option.\n+\t* invoke.texi: Document the new flag.\n+\t* passes.c: Add the asan pass.\n+\t* toplev.c (compile_file): Call asan_finish_file.\n+\t* asan.c: New file.\n+\t* asan.h: New file.\n+\t* tree-pass.h: Declare pass_asan.\n+\n 2012-11-12  Tobias Burnus  <burnus@net-b.de>\n \n \t* diagnostic.c (diagnostic_append_note): Also call va_end when"}, {"sha": "dde9b50a1ae9349886f7d127f04471cbc93a69fd", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d6f666cae62d9d44c5aef4b2185e43635d5091/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d6f666cae62d9d44c5aef4b2185e43635d5091/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=37d6f666cae62d9d44c5aef4b2185e43635d5091", "patch": "@@ -1349,6 +1349,7 @@ OBJS = \\\n \ttracer.o \\\n \ttrans-mem.o \\\n \ttree-affine.o \\\n+\tasan.o \\\n \ttree-call-cdce.o \\\n \ttree-cfg.o \\\n \ttree-cfgcleanup.o \\\n@@ -2207,6 +2208,10 @@ stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(PARAMS_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) $(RTL_H) \\\n    $(GGC_H) $(TM_P_H) $(TARGET_H) langhooks.h $(REGS_H) gt-stor-layout.h \\\n    $(DIAGNOSTIC_CORE_H) $(CGRAPH_H) $(TREE_INLINE_H) $(TREE_DUMP_H) $(GIMPLE_H)\n+asan.o : asan.c asan.h $(CONFIG_H) pointer-set.h \\\n+   $(SYSTEM_H) $(TREE_H) $(GIMPLE_H) \\\n+   output.h $(DIAGNOSTIC_H) coretypes.h $(TREE_DUMP_H) $(FLAGS_H) \\\n+   tree-pretty-print.h\n tree-ssa-tail-merge.o: tree-ssa-tail-merge.c \\\n    $(SYSTEM_H) $(CONFIG_H) coretypes.h $(TM_H) $(BITMAP_H) \\\n    $(FLAGS_H) $(TM_P_H) $(BASIC_BLOCK_H) \\"}, {"sha": "4b07c9646c6accba9651f3eababe3bb7c832ba5d", "filename": "gcc/asan.c", "status": "added", "additions": 404, "deletions": 0, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d6f666cae62d9d44c5aef4b2185e43635d5091/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d6f666cae62d9d44c5aef4b2185e43635d5091/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=37d6f666cae62d9d44c5aef4b2185e43635d5091", "patch": "@@ -0,0 +1,404 @@\n+/* AddressSanitizer, a fast memory error detector.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Contributed by Kostya Serebryany <kcc@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"tm_p.h\"\n+#include \"basic-block.h\"\n+#include \"flags.h\"\n+#include \"function.h\"\n+#include \"tree-inline.h\"\n+#include \"gimple.h\"\n+#include \"tree-iterator.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-dump.h\"\n+#include \"tree-pass.h\"\n+#include \"diagnostic.h\"\n+#include \"demangle.h\"\n+#include \"langhooks.h\"\n+#include \"ggc.h\"\n+#include \"cgraph.h\"\n+#include \"gimple.h\"\n+#include \"asan.h\"\n+#include \"gimple-pretty-print.h\"\n+\n+/*\n+ AddressSanitizer finds out-of-bounds and use-after-free bugs \n+ with <2x slowdown on average.\n+\n+ The tool consists of two parts:\n+ instrumentation module (this file) and a run-time library.\n+ The instrumentation module adds a run-time check before every memory insn.\n+   For a 8- or 16- byte load accessing address X:\n+     ShadowAddr = (X >> 3) + Offset\n+     ShadowValue = *(char*)ShadowAddr;  // *(short*) for 16-byte access.\n+     if (ShadowValue)\n+       __asan_report_load8(X);\n+   For a load of N bytes (N=1, 2 or 4) from address X:\n+     ShadowAddr = (X >> 3) + Offset\n+     ShadowValue = *(char*)ShadowAddr;\n+     if (ShadowValue)\n+       if ((X & 7) + N - 1 > ShadowValue)\n+         __asan_report_loadN(X);\n+ Stores are instrumented similarly, but using __asan_report_storeN functions.\n+ A call too __asan_init() is inserted to the list of module CTORs.\n+\n+ The run-time library redefines malloc (so that redzone are inserted around\n+ the allocated memory) and free (so that reuse of free-ed memory is delayed),\n+ provides __asan_report* and __asan_init functions.\n+\n+ Read more:\n+ http://code.google.com/p/address-sanitizer/wiki/AddressSanitizerAlgorithm\n+\n+ Future work:\n+ The current implementation supports only detection of out-of-bounds and\n+ use-after-free bugs in heap.\n+ In order to support out-of-bounds for stack and globals we will need\n+ to create redzones for stack and global object and poison them.\n+*/\n+\n+/* The shadow address is computed as (X>>asan_scale) + (1<<asan_offset_log).\n+ We may want to add command line flags to change these values.  */\n+\n+static const int asan_scale = 3;\n+static const int asan_offset_log_32 = 29;\n+static const int asan_offset_log_64 = 44;\n+static int asan_offset_log;\n+\n+\n+/* Construct a function tree for __asan_report_{load,store}{1,2,4,8,16}.\n+   IS_STORE is either 1 (for a store) or 0 (for a load).\n+   SIZE_IN_BYTES is one of 1, 2, 4, 8, 16.  */\n+\n+static tree\n+report_error_func (int is_store, int size_in_bytes)\n+{\n+  tree fn_type;\n+  tree def;\n+  char name[100];\n+\n+  sprintf (name, \"__asan_report_%s%d\\n\",\n+           is_store ? \"store\" : \"load\", size_in_bytes);\n+  fn_type = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n+  def = build_fn_decl (name, fn_type);\n+  TREE_NOTHROW (def) = 1;\n+  TREE_THIS_VOLATILE (def) = 1;  /* Attribute noreturn. Surprise!  */\n+  DECL_ATTRIBUTES (def) = tree_cons (get_identifier (\"leaf\"), \n+                                     NULL, DECL_ATTRIBUTES (def));\n+  DECL_ASSEMBLER_NAME (def);\n+  return def;\n+}\n+\n+/* Construct a function tree for __asan_init().  */\n+\n+static tree\n+asan_init_func (void)\n+{\n+  tree fn_type;\n+  tree def;\n+\n+  fn_type = build_function_type_list (void_type_node, NULL_TREE);\n+  def = build_fn_decl (\"__asan_init\", fn_type);\n+  TREE_NOTHROW (def) = 1;\n+  DECL_ASSEMBLER_NAME (def);\n+  return def;\n+}\n+\n+\n+/* Instrument the memory access instruction BASE.\n+   Insert new statements before ITER.\n+   LOCATION is source code location.\n+   IS_STORE is either 1 (for a store) or 0 (for a load).\n+   SIZE_IN_BYTES is one of 1, 2, 4, 8, 16.  */\n+\n+static void\n+build_check_stmt (tree base,\n+                  gimple_stmt_iterator *iter,\n+                  location_t location, int is_store, int size_in_bytes)\n+{\n+  gimple_stmt_iterator gsi;\n+  basic_block cond_bb, then_bb, join_bb;\n+  edge e;\n+  tree cond, t, u;\n+  tree base_addr;\n+  tree shadow_value;\n+  gimple g;\n+  gimple_seq seq, stmts;\n+  tree shadow_type = size_in_bytes == 16 ?\n+      short_integer_type_node : char_type_node;\n+  tree shadow_ptr_type = build_pointer_type (shadow_type);\n+  tree uintptr_type = lang_hooks.types.type_for_mode (ptr_mode,\n+                                                      /*unsignedp=*/true);\n+\n+  /* We first need to split the current basic block, and start altering\n+     the CFG.  This allows us to insert the statements we're about to\n+     construct into the right basic blocks.  */\n+\n+  cond_bb = gimple_bb (gsi_stmt (*iter));\n+  gsi = *iter;\n+  gsi_prev (&gsi);\n+  if (!gsi_end_p (gsi))\n+    e = split_block (cond_bb, gsi_stmt (gsi));\n+  else\n+    e = split_block_after_labels (cond_bb);\n+  cond_bb = e->src;\n+  join_bb = e->dest;\n+\n+  /* A recap at this point: join_bb is the basic block at whose head\n+     is the gimple statement for which this check expression is being\n+     built.  cond_bb is the (possibly new, synthetic) basic block the\n+     end of which will contain the cache-lookup code, and a\n+     conditional that jumps to the cache-miss code or, much more\n+     likely, over to join_bb.  */\n+\n+  /* Create the bb that contains the crash block.  */\n+  then_bb = create_empty_bb (cond_bb);\n+  make_edge (cond_bb, then_bb, EDGE_TRUE_VALUE);\n+  make_single_succ_edge (then_bb, join_bb, EDGE_FALLTHRU);\n+\n+  /* Mark the pseudo-fallthrough edge from cond_bb to join_bb.  */\n+  e = find_edge (cond_bb, join_bb);\n+  e->flags = EDGE_FALSE_VALUE;\n+  e->count = cond_bb->count;\n+  e->probability = REG_BR_PROB_BASE;\n+\n+  /* Update dominance info.  Note that bb_join's data was\n+     updated by split_block.  */\n+  if (dom_info_available_p (CDI_DOMINATORS))\n+    {\n+      set_immediate_dominator (CDI_DOMINATORS, then_bb, cond_bb);\n+      set_immediate_dominator (CDI_DOMINATORS, join_bb, cond_bb);\n+    }\n+\n+  base_addr = create_tmp_reg (uintptr_type, \"__asan_base_addr\");\n+\n+  seq = NULL; \n+  t = fold_convert_loc (location, uintptr_type,\n+                        unshare_expr (base));\n+  t = force_gimple_operand (t, &stmts, false, NULL_TREE);\n+  gimple_seq_add_seq (&seq, stmts);\n+  g = gimple_build_assign (base_addr, t);\n+  gimple_set_location (g, location);\n+  gimple_seq_add_stmt (&seq, g);\n+\n+  /* Build (base_addr >> asan_scale) + (1 << asan_offset_log).  */\n+\n+  t = build2 (RSHIFT_EXPR, uintptr_type, base_addr,\n+              build_int_cst (uintptr_type, asan_scale));\n+  t = build2 (PLUS_EXPR, uintptr_type, t,\n+              build2 (LSHIFT_EXPR, uintptr_type,\n+                      build_int_cst (uintptr_type, 1),\n+                      build_int_cst (uintptr_type, asan_offset_log)\n+                     ));\n+  t = build1 (INDIRECT_REF, shadow_type,\n+              build1 (VIEW_CONVERT_EXPR, shadow_ptr_type, t));\n+  t = force_gimple_operand (t, &stmts, false, NULL_TREE);\n+  gimple_seq_add_seq (&seq, stmts);\n+  shadow_value = create_tmp_reg (shadow_type, \"__asan_shadow\");\n+  g = gimple_build_assign (shadow_value, t);\n+  gimple_set_location (g, location);\n+  gimple_seq_add_stmt (&seq, g);\n+  t = build2 (NE_EXPR, boolean_type_node, shadow_value,\n+              build_int_cst (shadow_type, 0));\n+  if (size_in_bytes < 8)\n+    {\n+\n+      /* Slow path for 1-, 2- and 4- byte accesses.\n+         Build ((base_addr & 7) + (size_in_bytes - 1)) >= shadow_value.  */\n+\n+      u = build2 (BIT_AND_EXPR, uintptr_type,\n+                  base_addr,\n+                  build_int_cst (uintptr_type, 7));\n+      u = build1 (CONVERT_EXPR, shadow_type, u);\n+      u = build2 (PLUS_EXPR, shadow_type, u,\n+                  build_int_cst (shadow_type, size_in_bytes - 1));\n+      u = build2 (GE_EXPR, uintptr_type, u, shadow_value);\n+    }\n+  else\n+      u = build_int_cst (boolean_type_node, 1);\n+  t = build2 (TRUTH_AND_EXPR, boolean_type_node, t, u);\n+  t = force_gimple_operand (t, &stmts, false, NULL_TREE);\n+  gimple_seq_add_seq (&seq, stmts);\n+  cond = create_tmp_reg (boolean_type_node, \"__asan_crash_cond\");\n+  g = gimple_build_assign  (cond, t);\n+  gimple_set_location (g, location);\n+  gimple_seq_add_stmt (&seq, g);\n+  g = gimple_build_cond (NE_EXPR, cond, boolean_false_node, NULL_TREE,\n+                         NULL_TREE);\n+  gimple_set_location (g, location);\n+  gimple_seq_add_stmt (&seq, g);\n+\n+  /* Generate call to the run-time library (e.g. __asan_report_load8).  */\n+\n+  gsi = gsi_last_bb (cond_bb);\n+  gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n+  seq = NULL; \n+  g = gimple_build_call (report_error_func (is_store, size_in_bytes),\n+                         1, base_addr);\n+  gimple_seq_add_stmt (&seq, g);\n+\n+  /* Insert the check code in the THEN block.  */\n+\n+  gsi = gsi_start_bb (then_bb);\n+  gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n+\n+  *iter = gsi_start_bb (join_bb);\n+}\n+\n+/* If T represents a memory access, add instrumentation code before ITER.\n+   LOCATION is source code location.\n+   IS_STORE is either 1 (for a store) or 0 (for a load).  */\n+\n+static void\n+instrument_derefs (gimple_stmt_iterator *iter, tree t,\n+                  location_t location, int is_store)\n+{\n+  tree type, base;\n+  int size_in_bytes;\n+\n+  type = TREE_TYPE (t);\n+  if (type == error_mark_node)\n+    return;\n+  switch (TREE_CODE (t))\n+    {\n+    case ARRAY_REF:\n+    case COMPONENT_REF:\n+    case INDIRECT_REF:\n+    case MEM_REF:\n+      break;\n+    default:\n+      return;\n+    }\n+  size_in_bytes = tree_low_cst (TYPE_SIZE (type), 0) / BITS_PER_UNIT;\n+  if (size_in_bytes != 1 && size_in_bytes != 2 &&\n+      size_in_bytes != 4 && size_in_bytes != 8 && size_in_bytes != 16)\n+      return;\n+  {\n+    /* For now just avoid instrumenting bit field acceses.\n+     Fixing it is doable, but expected to be messy.  */\n+\n+    HOST_WIDE_INT bitsize, bitpos;\n+    tree offset;\n+    enum machine_mode mode;\n+    int volatilep = 0, unsignedp = 0;\n+    get_inner_reference (t, &bitsize, &bitpos, &offset,\n+                         &mode, &unsignedp, &volatilep, false);\n+    if (bitpos != 0 || bitsize != size_in_bytes * BITS_PER_UNIT)\n+        return;\n+  }\n+\n+  base = build_addr (t, current_function_decl);\n+  build_check_stmt (base, iter, location, is_store, size_in_bytes);\n+}\n+\n+/* asan: this looks too complex. Can this be done simpler? */\n+/* Transform\n+   1) Memory references.\n+   2) BUILTIN_ALLOCA calls.\n+*/\n+\n+static void\n+transform_statements (void)\n+{\n+  basic_block bb;\n+  gimple_stmt_iterator i;\n+  int saved_last_basic_block = last_basic_block;\n+  enum gimple_rhs_class grhs_class;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      if (bb->index >= saved_last_basic_block) continue;\n+      for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n+        {\n+          gimple s = gsi_stmt (i);\n+          if (gimple_code (s) != GIMPLE_ASSIGN)\n+              continue;\n+          instrument_derefs (&i, gimple_assign_lhs (s),\n+                             gimple_location (s), 1);\n+          instrument_derefs (&i, gimple_assign_rhs1 (s),\n+                             gimple_location (s), 0);\n+          grhs_class = get_gimple_rhs_class (gimple_assign_rhs_code (s));\n+          if (grhs_class == GIMPLE_BINARY_RHS)\n+            instrument_derefs (&i, gimple_assign_rhs2 (s),\n+                               gimple_location (s), 0);\n+        }\n+    }\n+}\n+\n+/* Module-level instrumentation.\n+   - Insert __asan_init() into the list of CTORs.\n+   - TODO: insert redzones around globals.\n+ */\n+\n+void\n+asan_finish_file (void)\n+{\n+  tree ctor_statements = NULL_TREE;\n+  append_to_statement_list (build_call_expr (asan_init_func (), 0),\n+                            &ctor_statements);\n+  cgraph_build_static_cdtor ('I', ctor_statements,\n+                             MAX_RESERVED_INIT_PRIORITY - 1);\n+}\n+\n+/* Instrument the current function.  */\n+\n+static unsigned int\n+asan_instrument (void)\n+{\n+  struct gimplify_ctx gctx;\n+  tree uintptr_type = lang_hooks.types.type_for_mode (ptr_mode, true);\n+  int is_64 = tree_low_cst (TYPE_SIZE (uintptr_type), 0) == 64;\n+  asan_offset_log = is_64 ? asan_offset_log_64 : asan_offset_log_32;\n+  push_gimplify_context (&gctx);\n+  transform_statements ();\n+  pop_gimplify_context (NULL);\n+  return 0;\n+}\n+\n+static bool\n+gate_asan (void)\n+{\n+  return flag_asan != 0;\n+}\n+\n+struct gimple_opt_pass pass_asan =\n+{\n+ {\n+  GIMPLE_PASS,\n+  \"asan\",                               /* name  */\n+  OPTGROUP_NONE,                        /* optinfo_flags */\n+  gate_asan,                            /* gate  */\n+  asan_instrument,                      /* execute  */\n+  NULL,                                 /* sub  */\n+  NULL,                                 /* next  */\n+  0,                                    /* static_pass_number  */\n+  TV_NONE,                              /* tv_id  */\n+  PROP_ssa | PROP_cfg | PROP_gimple_leh,/* properties_required  */\n+  0,                                    /* properties_provided  */\n+  0,                                    /* properties_destroyed  */\n+  0,                                    /* todo_flags_start  */\n+  TODO_verify_flow | TODO_verify_stmts\n+  | TODO_update_ssa    /* todo_flags_finish  */\n+ }\n+};"}, {"sha": "590cf359bd20265381f8b8aa1324b6684ff16ad4", "filename": "gcc/asan.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d6f666cae62d9d44c5aef4b2185e43635d5091/gcc%2Fasan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d6f666cae62d9d44c5aef4b2185e43635d5091/gcc%2Fasan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.h?ref=37d6f666cae62d9d44c5aef4b2185e43635d5091", "patch": "@@ -0,0 +1,26 @@\n+/* AddressSanitizer, a fast memory error detector.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Contributed by Kostya Serebryany <kcc@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef TREE_ASAN\n+#define TREE_ASAN\n+\n+extern void asan_finish_file(void);\n+\n+#endif /* TREE_ASAN */"}, {"sha": "6088d1a7fec11a827661a7575003fb552dba7b83", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d6f666cae62d9d44c5aef4b2185e43635d5091/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d6f666cae62d9d44c5aef4b2185e43635d5091/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=37d6f666cae62d9d44c5aef4b2185e43635d5091", "patch": "@@ -837,6 +837,10 @@ fargument-noalias-anything\n Common Ignore\n Does nothing. Preserved for backward compatibility.\n \n+faddress-sanitizer\n+Common Report Var(flag_asan)\n+Enable AddressSanitizer, a memory error detector\n+\n fasynchronous-unwind-tables\n Common Report Var(flag_asynchronous_unwind_tables) Optimization\n Generate unwind tables that are exact at each instruction boundary"}, {"sha": "ef2e69ad0913ccbdeb3c281d8da7708760b6e86a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d6f666cae62d9d44c5aef4b2185e43635d5091/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d6f666cae62d9d44c5aef4b2185e43635d5091/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=37d6f666cae62d9d44c5aef4b2185e43635d5091", "patch": "@@ -354,9 +354,10 @@ Objective-C and Objective-C++ Dialects}.\n @item Optimization Options\n @xref{Optimize Options,,Options that Control Optimization}.\n @gccoptlist{-falign-functions[=@var{n}] -falign-jumps[=@var{n}] @gol\n--falign-labels[=@var{n}] -falign-loops[=@var{n}] -fassociative-math @gol\n--fauto-inc-dec -fbranch-probabilities -fbranch-target-load-optimize @gol\n--fbranch-target-load-optimize2 -fbtr-bb-exclusive -fcaller-saves @gol\n+-falign-labels[=@var{n}] -falign-loops[=@var{n}] -faddress-sanitizer @gol\n+--fassociative-math fauto-inc-dec -fbranch-probabilities @gol\n+--fbranch-target-load-optimize fbranch-target-load-optimize2 @gol\n+--fbtr-bb-exclusive -fcaller-saves @gol\n -fcheck-data-deps -fcombine-stack-adjustments -fconserve-stack @gol\n -fcompare-elim -fcprop-registers -fcrossjumping @gol\n -fcse-follow-jumps -fcse-skip-blocks -fcx-fortran-rules @gol\n@@ -6848,6 +6849,12 @@ assumptions based on that.\n \n The default is @option{-fzero-initialized-in-bss}.\n \n+@item -faddress-sanitizer\n+Enable AddressSanitizer, a fast memory error detector.\n+Memory access instructions will be instrumented to detect\n+out-of-bounds and use-after-free bugs. So far only heap bugs will be detected.\n+See @uref{http://code.google.com/p/address-sanitizer/} for more details.\n+\n @item -fmudflap -fmudflapth -fmudflapir\n @opindex fmudflap\n @opindex fmudflapth"}, {"sha": "66a2f74b15ecb92a7456a3be08fb78b2af941780", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d6f666cae62d9d44c5aef4b2185e43635d5091/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d6f666cae62d9d44c5aef4b2185e43635d5091/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=37d6f666cae62d9d44c5aef4b2185e43635d5091", "patch": "@@ -1456,6 +1456,7 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_split_crit_edges);\n       NEXT_PASS (pass_pre);\n       NEXT_PASS (pass_sink_code);\n+      NEXT_PASS (pass_asan);\n       NEXT_PASS (pass_tree_loop);\n \t{\n \t  struct opt_pass **p = &pass_tree_loop.pass.sub;"}, {"sha": "3ca0736995e883c40369ceaa04f0ef0d53d626ff", "filename": "gcc/toplev.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d6f666cae62d9d44c5aef4b2185e43635d5091/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d6f666cae62d9d44c5aef4b2185e43635d5091/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=37d6f666cae62d9d44c5aef4b2185e43635d5091", "patch": "@@ -72,6 +72,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"value-prof.h\"\n #include \"alloc-pool.h\"\n #include \"tree-mudflap.h\"\n+#include \"asan.h\"\n #include \"gimple.h\"\n #include \"tree-ssa-alias.h\"\n #include \"plugin.h\"\n@@ -570,6 +571,10 @@ compile_file (void)\n       if (flag_mudflap)\n \tmudflap_finish_file ();\n \n+      /* File-scope initialization for AddressSanitizer.  */\n+      if (flag_asan)\n+        asan_finish_file ();\n+\n       output_shared_constant_pool ();\n       output_object_blocks ();\n       finish_tm_clone_pairs ();"}, {"sha": "0e618569e650f7dedfaccfb3a3c61f5449d3db94", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d6f666cae62d9d44c5aef4b2185e43635d5091/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d6f666cae62d9d44c5aef4b2185e43635d5091/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=37d6f666cae62d9d44c5aef4b2185e43635d5091", "patch": "@@ -259,6 +259,7 @@ struct register_pass_info\n \n extern struct gimple_opt_pass pass_mudflap_1;\n extern struct gimple_opt_pass pass_mudflap_2;\n+extern struct gimple_opt_pass pass_asan;\n extern struct gimple_opt_pass pass_lower_cf;\n extern struct gimple_opt_pass pass_refactor_eh;\n extern struct gimple_opt_pass pass_lower_eh;"}]}