{"sha": "e6f948e3de96f63c11867bd6d274bfd5b872860d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZmOTQ4ZTNkZTk2ZjYzYzExODY3YmQ2ZDI3NGJmZDViODcyODYwZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-17T00:26:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-17T00:26:58Z"}, "message": "(untyped_call, blockage): New patterns.\n\nFrom-SVN: r4169", "tree": {"sha": "f0bb570e6c5fb54286dfe487dcc1e41f4dc6d517", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0bb570e6c5fb54286dfe487dcc1e41f4dc6d517"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6f948e3de96f63c11867bd6d274bfd5b872860d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6f948e3de96f63c11867bd6d274bfd5b872860d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6f948e3de96f63c11867bd6d274bfd5b872860d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6f948e3de96f63c11867bd6d274bfd5b872860d/comments", "author": null, "committer": null, "parents": [{"sha": "bc3654906f31f7211d19f0887c7e5305116518f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc3654906f31f7211d19f0887c7e5305116518f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc3654906f31f7211d19f0887c7e5305116518f3"}], "stats": {"total": 111, "additions": 111, "deletions": 0}, "files": [{"sha": "ff2309df9b097ec51178069c16491b2cfde5e182", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f948e3de96f63c11867bd6d274bfd5b872860d/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f948e3de96f63c11867bd6d274bfd5b872860d/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=e6f948e3de96f63c11867bd6d274bfd5b872860d", "patch": "@@ -2341,6 +2341,43 @@\n   \"bsr $26,%1..ng\"\n   [(set_attr \"type\" \"ibr\")])\n \n+;; Call subroutine returning any type.\n+\n+(define_expand \"untyped_call\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+\t\t    (const_int 0))\n+\t      (match_operand 1 \"\" \"\")\n+\t      (match_operand 2 \"\" \"\")])]\n+  \"\"\n+  \"\n+{\n+  int i;\n+\n+  emit_call_insn (gen_call (operands[0], const0_rtx, NULL, const0_rtx));\n+\n+  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n+    {\n+      rtx set = XVECEXP (operands[2], 0, i);\n+      emit_move_insn (SET_DEST (set), SET_SRC (set));\n+    }\n+\n+  /* The optimizer does not know that the call sets the function value\n+     registers we stored in the result block.  We avoid problems by\n+     claiming that all hard registers are used and clobbered at this\n+     point.  */\n+  emit_insn (gen_blockage ());\n+\n+  DONE;\n+}\")\n+\n+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n+;; all of memory.  This blocks insns from being moved across this point.\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"\")\n+\n (define_insn \"jump\"\n   [(set (pc)\n \t(label_ref (match_operand 0 \"\" \"\")))]"}, {"sha": "4bdb503aa39cd8ee383b7af1b8dabd520812bfd0", "filename": "gcc/config/romp/romp.md", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f948e3de96f63c11867bd6d274bfd5b872860d/gcc%2Fconfig%2Fromp%2Fromp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f948e3de96f63c11867bd6d274bfd5b872860d/gcc%2Fconfig%2Fromp%2Fromp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.md?ref=e6f948e3de96f63c11867bd6d274bfd5b872860d", "patch": "@@ -1767,6 +1767,43 @@\n   \"bali%# r15,%1\"\n   [(set_attr \"type\" \"call\")])\n \n+;; Call subroutine returning any type.\n+\n+(define_expand \"untyped_call\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+\t\t    (const_int 0))\n+\t      (match_operand 1 \"\" \"\")\n+\t      (match_operand 2 \"\" \"\")])]\n+  \"\"\n+  \"\n+{\n+  int i;\n+\n+  emit_call_insn (gen_call (operands[0], const0_rtx, NULL, const0_rtx));\n+\n+  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n+    {\n+      rtx set = XVECEXP (operands[2], 0, i);\n+      emit_move_insn (SET_DEST (set), SET_SRC (set));\n+    }\n+\n+  /* The optimizer does not know that the call sets the function value\n+     registers we stored in the result block.  We avoid problems by\n+     claiming that all hard registers are used and clobbered at this\n+     point.  */\n+  emit_insn (gen_blockage ());\n+\n+  DONE;\n+}\")\n+\n+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n+;; all of memory.  This blocks insns from being moved across this point.\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"\")\n+\n ;; No operation insn.\n (define_insn \"nop\"\n   [(const_int 0)]"}, {"sha": "347f097fa3b5c7ab9f9d88f2f3a80b9cca73c19b", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f948e3de96f63c11867bd6d274bfd5b872860d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f948e3de96f63c11867bd6d274bfd5b872860d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=e6f948e3de96f63c11867bd6d274bfd5b872860d", "patch": "@@ -3055,6 +3055,43 @@\n   \"@\n    brl\\;l 2,20(1)\n    bl %z1\\;cror 15,15,15\")\n+\n+;; Call subroutine returning any type.\n+\n+(define_expand \"untyped_call\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+\t\t    (const_int 0))\n+\t      (match_operand 1 \"\" \"\")\n+\t      (match_operand 2 \"\" \"\")])]\n+  \"\"\n+  \"\n+{\n+  int i;\n+\n+  emit_call_insn (gen_call (operands[0], const0_rtx, NULL, const0_rtx));\n+\n+  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n+    {\n+      rtx set = XVECEXP (operands[2], 0, i);\n+      emit_move_insn (SET_DEST (set), SET_SRC (set));\n+    }\n+\n+  /* The optimizer does not know that the call sets the function value\n+     registers we stored in the result block.  We avoid problems by\n+     claiming that all hard registers are used and clobbered at this\n+     point.  */\n+  emit_insn (gen_blockage ());\n+\n+  DONE;\n+}\")\n+\n+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n+;; all of memory.  This blocks insns from being moved across this point.\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"\")\n \f\n ;; Compare insns are next.  Note that the RS/6000 has two types of compares,\n ;; signed & unsigned, and one type of branch.  "}]}