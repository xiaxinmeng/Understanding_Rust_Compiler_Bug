{"sha": "140f2c812c50fbe104c3a251c530454a2682c891", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQwZjJjODEyYzUwZmJlMTA0YzNhMjUxYzUzMDQ1NGEyNjgyYzg5MQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2013-11-14T18:40:12Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2013-11-14T18:40:12Z"}, "message": "rs6000.c (rs6000_arg_partial_bytes): Simplify logic by making use of the fact that for vector / floating point...\n\n2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_arg_partial_bytes): Simplify logic\n\tby making use of the fact that for vector / floating point arguments\n\tpassed both in VRs/FPRs and in the fixed parameter area, the partial\n\tbytes mechanism is in fact not used.\n\nFrom-SVN: r204807", "tree": {"sha": "352fd46734142ede2b538e30baf7ebe488007529", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/352fd46734142ede2b538e30baf7ebe488007529"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/140f2c812c50fbe104c3a251c530454a2682c891", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/140f2c812c50fbe104c3a251c530454a2682c891", "html_url": "https://github.com/Rust-GCC/gccrs/commit/140f2c812c50fbe104c3a251c530454a2682c891", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/140f2c812c50fbe104c3a251c530454a2682c891/comments", "author": null, "committer": null, "parents": [{"sha": "98eefff6bc1c3e497f961128240980e6758dec10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98eefff6bc1c3e497f961128240980e6758dec10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98eefff6bc1c3e497f961128240980e6758dec10"}], "stats": {"total": 42, "additions": 31, "deletions": 11}, "files": [{"sha": "6d83b32ce967abd49e933cde887a7b7a00b5b001", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/140f2c812c50fbe104c3a251c530454a2682c891/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/140f2c812c50fbe104c3a251c530454a2682c891/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=140f2c812c50fbe104c3a251c530454a2682c891", "patch": "@@ -1,3 +1,10 @@\n+2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_arg_partial_bytes): Simplify logic\n+\tby making use of the fact that for vector / floating point arguments\n+\tpassed both in VRs/FPRs and in the fixed parameter area, the partial\n+\tbytes mechanism is in fact not used.\n+\n 2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n \n \t* config/rs6000/rs6000.c (rs6000_psave_function_arg): New function."}, {"sha": "039868a1c15dc32eb989a94fa3cf02e92c90659f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/140f2c812c50fbe104c3a251c530454a2682c891/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/140f2c812c50fbe104c3a251c530454a2682c891/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=140f2c812c50fbe104c3a251c530454a2682c891", "patch": "@@ -9840,15 +9840,25 @@ rs6000_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t  tree type, bool named)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+  bool passed_in_gprs = true;\n   int ret = 0;\n   int align_words;\n \n   if (DEFAULT_ABI == ABI_V4)\n     return 0;\n \n-  if (USE_ALTIVEC_FOR_ARG_P (cum, mode, named)\n-      && cum->nargs_prototype >= 0)\n-    return 0;\n+  if (USE_ALTIVEC_FOR_ARG_P (cum, mode, named))\n+    {\n+      /* If we are passing this arg in the fixed parameter save area\n+         (gprs or memory) as well as VRs, we do not use the partial\n+\t bytes mechanism; instead, rs6000_function_arg will return a\n+\t PARALLEL including a memory element as necessary.  */\n+      if (TARGET_64BIT && ! cum->prototype)\n+\treturn 0;\n+\n+      /* Otherwise, we pass in VRs only.  No partial copy possible.  */\n+      passed_in_gprs = false;\n+    }\n \n   /* In this complicated case we just disable the partial_nregs code.  */\n   if (TARGET_MACHO && rs6000_darwin64_struct_check_p (mode, type))\n@@ -9858,24 +9868,27 @@ rs6000_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n \n   if (USE_FP_FOR_ARG_P (cum, mode))\n     {\n+      unsigned long n_fpreg = (GET_MODE_SIZE (mode) + 7) >> 3;\n+\n       /* If we are passing this arg in the fixed parameter save area\n-\t (gprs or memory) as well as fprs, then this function should\n-\t return the number of partial bytes passed in the parameter\n-\t save area rather than partial bytes passed in fprs.  */\n+         (gprs or memory) as well as FPRs, we do not use the partial\n+\t bytes mechanism; instead, rs6000_function_arg will return a\n+\t PARALLEL including a memory element as necessary.  */\n       if (type\n \t  && (cum->nargs_prototype <= 0\n \t      || (DEFAULT_ABI == ABI_AIX\n \t\t  && TARGET_XL_COMPAT\n \t\t  && align_words >= GP_ARG_NUM_REG)))\n \treturn 0;\n-      else if (cum->fregno + ((GET_MODE_SIZE (mode) + 7) >> 3)\n-\t       > FP_ARG_MAX_REG + 1)\n+\n+      /* Otherwise, we pass in FPRs only.  Check for partial copies.  */\n+      passed_in_gprs = false;\n+      if (cum->fregno + n_fpreg > FP_ARG_MAX_REG + 1)\n \tret = (FP_ARG_MAX_REG + 1 - cum->fregno) * 8;\n-      else if (cum->nargs_prototype >= 0)\n-\treturn 0;\n     }\n \n-  if (align_words < GP_ARG_NUM_REG\n+  if (passed_in_gprs\n+      && align_words < GP_ARG_NUM_REG\n       && GP_ARG_NUM_REG < align_words + rs6000_arg_size (mode, type))\n     ret = (GP_ARG_NUM_REG - align_words) * (TARGET_32BIT ? 4 : 8);\n "}]}