{"sha": "e12da14140bd1ec670a97f2e9b147d16e81c8ae4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTEyZGExNDE0MGJkMWVjNjcwYTk3ZjJlOWIxNDdkMTZlODFjOGFlNA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-08-30T13:15:38Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-08-30T13:15:38Z"}, "message": "genautomata.c (NO_COMB_OPTION): New macro.\n\n\t* genautomata.c (NO_COMB_OPTION): New macro.\n\t(no_comb_flag): New static variable.\n\t(gen_automata_option): Handle NO_COMB_OPTION.\n\t(comb_vect_p): False if no_comb_flag.\n\t(add_vect): Move computation of min/max values.  Return early if\n\tno_comb_flag.\n\t* doc/md.texi (automata_option): Document no-comb-vect.\n\nFrom-SVN: r178295", "tree": {"sha": "93799b5becced1916a53de04905e0a7bade2bab6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93799b5becced1916a53de04905e0a7bade2bab6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e12da14140bd1ec670a97f2e9b147d16e81c8ae4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e12da14140bd1ec670a97f2e9b147d16e81c8ae4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e12da14140bd1ec670a97f2e9b147d16e81c8ae4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e12da14140bd1ec670a97f2e9b147d16e81c8ae4/comments", "author": null, "committer": null, "parents": [{"sha": "747de90b1117a02ac82f097c17315ba461dcd2df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/747de90b1117a02ac82f097c17315ba461dcd2df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/747de90b1117a02ac82f097c17315ba461dcd2df"}], "stats": {"total": 45, "additions": 41, "deletions": 4}, "files": [{"sha": "3170e41bf466028caab8f2d903dfb4348824ba15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e12da14140bd1ec670a97f2e9b147d16e81c8ae4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e12da14140bd1ec670a97f2e9b147d16e81c8ae4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e12da14140bd1ec670a97f2e9b147d16e81c8ae4", "patch": "@@ -1,3 +1,13 @@\n+2011-08-30  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* genautomata.c (NO_COMB_OPTION): New macro.\n+\t(no_comb_flag): New static variable.\n+\t(gen_automata_option): Handle NO_COMB_OPTION.\n+\t(comb_vect_p): False if no_comb_flag.\n+\t(add_vect): Move computation of min/max values.  Return early if\n+\tno_comb_flag.\n+\t* doc/md.texi (automata_option): Document no-comb-vect.\n+\n 2011-08-30  Christian Bruel  <christian.bruel@st.com>\n \n \t* coverage.c (coverage_init): Check flag_branch_probabilities instead of"}, {"sha": "24f591c5d9a4dbe3af99362c64e628a7f38c6ab3", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e12da14140bd1ec670a97f2e9b147d16e81c8ae4/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e12da14140bd1ec670a97f2e9b147d16e81c8ae4/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=e12da14140bd1ec670a97f2e9b147d16e81c8ae4", "patch": "@@ -7967,6 +7967,13 @@ verification and debugging.\n @dfn{w} means a generation of warning instead of error for\n non-critical errors.\n \n+@item\n+@dfn{no-comb-vect} prevents the automaton generator from generating\n+two data structures and comparing them for space efficiency.  Using\n+a comb vector to represent transitions may be better, but it can be\n+very expensive to construct.  This option is useful if the build\n+process spends an unacceptably long time in genautomata.\n+\n @item\n @dfn{ndfa} makes nondeterministic finite state automata.  This affects\n the treatment of operator @samp{|} in the regular expressions.  The"}, {"sha": "f331f507dae86bd1138c795f60f39e035cd750c3", "filename": "gcc/genautomata.c", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e12da14140bd1ec670a97f2e9b147d16e81c8ae4/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e12da14140bd1ec670a97f2e9b147d16e81c8ae4/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=e12da14140bd1ec670a97f2e9b147d16e81c8ae4", "patch": "@@ -253,6 +253,7 @@ static arc_t next_out_arc              (arc_t);\n #define W_OPTION \"-w\"\n #define NDFA_OPTION \"-ndfa\"\n #define COLLAPSE_OPTION \"-collapse-ndfa\"\n+#define NO_COMB_OPTION \"-no-comb-vect\"\n #define PROGRESS_OPTION \"-progress\"\n \n /* The following flags are set up by function `initiate_automaton_gen'.  */\n@@ -268,6 +269,9 @@ static int collapse_flag;\n /* Do not make minimization of DFA (`-no-minimization').  */\n static int no_minimization_flag;\n \n+/* Do not try to generate a comb vector (`-no-comb-vect').  */\n+static int no_comb_flag;\n+\n /* Value of this variable is number of automata being generated.  The\n    actual number of automata may be less this value if there is not\n    sufficient number of units.  This value is defined by argument of\n@@ -1539,6 +1543,8 @@ gen_automata_option (rtx def)\n     ndfa_flag = 1;\n   else if (strcmp (XSTR (def, 0), COLLAPSE_OPTION + 1) == 0)\n     collapse_flag = 1;\n+  else if (strcmp (XSTR (def, 0), NO_COMB_OPTION + 1) == 0)\n+    no_comb_flag = 1;\n   else if (strcmp (XSTR (def, 0), PROGRESS_OPTION + 1) == 0)\n     progress_flag = 1;\n   else\n@@ -7251,6 +7257,8 @@ static int undefined_vect_el_value;\n static int\n comb_vect_p (state_ainsn_table_t tab)\n {\n+  if (no_comb_flag)\n+    return false;\n   return  (2 * VEC_length (vect_el_t, tab->full_vect)\n            > 5 * VEC_length (vect_el_t, tab->comb_vect));\n }\n@@ -7369,6 +7377,22 @@ add_vect (state_ainsn_table_t tab, int vect_num, vla_hwint_t vect)\n       VEC_replace (vect_el_t, tab->full_vect, full_base + i,\n \t\t   VEC_index (vect_el_t, vect, i));\n   }\n+\n+  /* The comb_vect min/max values are also used for the full vector, so\n+     compute them now.  */\n+  for (vect_index = 0; vect_index < vect_length; vect_index++)\n+    if (VEC_index (vect_el_t, vect, vect_index) != undefined_vect_el_value)\n+      {\n+\tvect_el_t x = VEC_index (vect_el_t, vect, vect_index);\n+        gcc_assert (x >= 0);\n+        if (tab->max_comb_vect_el_value < x)\n+          tab->max_comb_vect_el_value = x;\n+        if (tab->min_comb_vect_el_value > x)\n+          tab->min_comb_vect_el_value = x;\n+      }\n+  if (no_comb_flag)\n+    return;\n+\n   /* Form comb vector in the table: */\n   gcc_assert (VEC_length (vect_el_t, tab->comb_vect)\n \t      == VEC_length (vect_el_t, tab->check_vect));\n@@ -7478,10 +7502,6 @@ add_vect (state_ainsn_table_t tab, int vect_num, vla_hwint_t vect)\n \t\t\t       comb_vect_index + vect_index)\n \t\t    == undefined_vect_el_value);\n         gcc_assert (x >= 0);\n-        if (tab->max_comb_vect_el_value < x)\n-          tab->max_comb_vect_el_value = x;\n-        if (tab->min_comb_vect_el_value > x)\n-          tab->min_comb_vect_el_value = x;\n \tVEC_replace (vect_el_t, tab->comb_vect,\n \t\t     comb_vect_index + vect_index, x);\n \tVEC_replace (vect_el_t, tab->check_vect,"}]}