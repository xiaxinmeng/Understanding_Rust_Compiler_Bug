{"sha": "ccc2a6139062395fb5747d0846a1ed6de25293c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NjMmE2MTM5MDYyMzk1ZmI1NzQ3ZDA4NDZhMWVkNmRlMjUyOTNjMg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2018-07-16T14:11:52Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-07-16T14:11:52Z"}, "message": "[Ada] Major code cleanup\n\n2018-07-16  Ed Schonberg  <schonberg@adacore.com>\n\ngcc/ada/\n\n\t* einfo.adb (Set_Is_Uplevel_Referenced_Entity): Flag can appear on\n\tloop parameters.\n\t* exp_ch7.adb (Check_Unnesting_Elaboration_Code): Handle subprogram\n\tbodies.\n\t* exp_ch9.adb (Reset_Scopes_To): Set the scopes of entities local to an\n\tentry body to be the corresponding generated subprogram, for correct\n\tanalysis of uplevel references.\n\t* exp_unst.adb (Visit_Node): Handle properly binary and unary operators\n\tIgnore pragmas, fix component associations.\n\t(Register_Subprograms): Subprograms in synchronized types must be\n\ttreated as reachable.\n\nFrom-SVN: r262723", "tree": {"sha": "e7664caba9debf77bbe18083906f927e8d88e4be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7664caba9debf77bbe18083906f927e8d88e4be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ccc2a6139062395fb5747d0846a1ed6de25293c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccc2a6139062395fb5747d0846a1ed6de25293c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccc2a6139062395fb5747d0846a1ed6de25293c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccc2a6139062395fb5747d0846a1ed6de25293c2/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "93bc357b34765dcc12709962a074c8001677c27b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93bc357b34765dcc12709962a074c8001677c27b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93bc357b34765dcc12709962a074c8001677c27b"}], "stats": {"total": 200, "additions": 184, "deletions": 16}, "files": [{"sha": "8a0250d4155c3991409cc180fd9ebcf9a70f8e66", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccc2a6139062395fb5747d0846a1ed6de25293c2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccc2a6139062395fb5747d0846a1ed6de25293c2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ccc2a6139062395fb5747d0846a1ed6de25293c2", "patch": "@@ -1,3 +1,17 @@\n+2018-07-16  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* einfo.adb (Set_Is_Uplevel_Referenced_Entity): Flag can appear on\n+\tloop parameters.\n+\t* exp_ch7.adb (Check_Unnesting_Elaboration_Code): Handle subprogram\n+\tbodies.\n+\t* exp_ch9.adb (Reset_Scopes_To): Set the scopes of entities local to an\n+\tentry body to be the corresponding generated subprogram, for correct\n+\tanalysis of uplevel references.\n+\t* exp_unst.adb (Visit_Node): Handle properly binary and unary operators\n+\tIgnore pragmas, fix component associations.\n+\t(Register_Subprograms): Subprograms in synchronized types must be\n+\ttreated as reachable.\n+\n 2018-07-16  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_util.adb (Check_No_Hidden_State): Ignore internally-generated"}, {"sha": "f7742ecfddcdce0fc7a998e3a4f3634172bee26f", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccc2a6139062395fb5747d0846a1ed6de25293c2/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccc2a6139062395fb5747d0846a1ed6de25293c2/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=ccc2a6139062395fb5747d0846a1ed6de25293c2", "patch": "@@ -5972,7 +5972,7 @@ package body Einfo is\n    procedure Set_Is_Uplevel_Referenced_Entity (Id : E; V : B := True) is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Constant, E_Variable, E_Discriminant)\n+        (Ekind_In (Id, E_Constant, E_Variable, E_Loop_Parameter)\n           or else Is_Formal (Id)\n           or else Is_Type (Id));\n       Set_Flag283 (Id, V);"}, {"sha": "d14cd7ee3b8fa324fc93c912561be56a8548c30a", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccc2a6139062395fb5747d0846a1ed6de25293c2/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccc2a6139062395fb5747d0846a1ed6de25293c2/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=ccc2a6139062395fb5747d0846a1ed6de25293c2", "patch": "@@ -4048,6 +4048,9 @@ package body Exp_Ch7 is\n                  and then Present (Identifier (Stat))\n                then\n                   Set_Scope (Entity (Identifier (Stat)), Elab_Proc);\n+\n+               elsif Nkind (Stat) = N_Subprogram_Body then\n+                  Set_Scope (Defining_Entity (Stat), Elab_Proc);\n                end if;\n \n                Next (Stat);"}, {"sha": "7d1ba3526701336abd3aa5d80df1882a3cf545ed", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 72, "deletions": 2, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccc2a6139062395fb5747d0846a1ed6de25293c2/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccc2a6139062395fb5747d0846a1ed6de25293c2/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=ccc2a6139062395fb5747d0846a1ed6de25293c2", "patch": "@@ -474,6 +474,11 @@ package body Exp_Ch9 is\n    --    ...\n    --    <actualN> := P.<formalN>;\n \n+   procedure Reset_Scopes_To (Proc_Body : Node_Id; E : Entity_Id);\n+   --  Reset the scope of declarations and blocks at the top level of\n+   --  Proc_Body to be E. Used after expanding entry bodies into their\n+   --  corresponding procedures.\n+\n    function Trivial_Accept_OK return Boolean;\n    --  If there is no DO-END block for an accept, or if the DO-END block has\n    --  only null statements, then it is possible to do the Rendezvous with much\n@@ -3558,6 +3563,7 @@ package body Exp_Ch9 is\n       Bod_Stmts : List_Id;\n       Complete  : Node_Id;\n       Ohandle   : Node_Id;\n+      Proc_Body : Node_Id;\n \n       EH_Loc : Source_Ptr;\n       --  Used for the exception handler, inserted at end of the body\n@@ -3670,7 +3676,7 @@ package body Exp_Ch9 is\n          --  Create body of entry procedure. The renaming declarations are\n          --  placed ahead of the block that contains the actual entry body.\n \n-         return\n+         Proc_Body :=\n            Make_Subprogram_Body (Loc,\n              Specification              => Bod_Spec,\n              Declarations               => Bod_Decls,\n@@ -3699,6 +3705,9 @@ package body Exp_Ch9 is\n                              Name =>\n                                New_Occurrence_Of\n                                  (RTE (RE_Get_GNAT_Exception), Loc)))))))));\n+\n+         Reset_Scopes_To (Proc_Body, Bod_Id);\n+         return Proc_Body;\n       end if;\n    end Build_Protected_Entry;\n \n@@ -10554,6 +10563,8 @@ package body Exp_Ch9 is\n          Expr      : Node_Id;\n          Call      : Node_Id;\n \n+         --  Start of processing for Add_Accept\n+\n       begin\n          if No (Ann) then\n             Ann := Node (Last_Elmt (Accept_Address (Eent)));\n@@ -10592,7 +10603,7 @@ package body Exp_Ch9 is\n               Make_Defining_Identifier (Eloc,\n                 New_External_Name (Chars (Ename), 'A', Num_Accept));\n \n-            --  Link the acceptor to the original receiving entry\n+            --  Link the acceptor to the original receiving entry.\n \n             Set_Ekind           (PB_Ent, E_Procedure);\n             Set_Receiving_Entry (PB_Ent, Eent);\n@@ -10610,6 +10621,8 @@ package body Exp_Ch9 is\n                 Handled_Statement_Sequence =>\n                   Build_Accept_Body (Accept_Statement (Alt)));\n \n+            Reset_Scopes_To (Proc_Body, PB_Ent);\n+\n             --  During the analysis of the body of the accept statement, any\n             --  zero cost exception handler records were collected in the\n             --  Accept_Handler_Records field of the N_Accept_Alternative node.\n@@ -14713,6 +14726,63 @@ package body Exp_Ch9 is\n       end if;\n    end Parameter_Block_Unpack;\n \n+   ---------------------\n+   -- Reset_Scopes_To --\n+   ---------------------\n+\n+   procedure Reset_Scopes_To (Proc_Body : Node_Id; E : Entity_Id) is\n+\n+      function Reset_Scope (N : Node_Id) return Traverse_Result;\n+      --  Temporaries may have been declared during expansion of the\n+      --  procedure alternative. Indicate that their scope is the new\n+      --  body, to prevent generation of spurious uplevel references\n+      --  for these entities.\n+\n+      procedure Reset_Scopes is new Traverse_Proc (Reset_Scope);\n+\n+      -----------------\n+      -- Reset_Scope --\n+      -----------------\n+\n+      function Reset_Scope (N : Node_Id) return Traverse_Result is\n+         Decl : Node_Id;\n+\n+      begin\n+         --  If this is a block statement with an Identifier, it forms\n+         --  a scope, so we want to reset its scope but not look inside.\n+\n+         if Nkind (N) = N_Block_Statement and then Present (Identifier (N))\n+         then\n+            Set_Scope (Entity (Identifier (N)), E);\n+            return Skip;\n+\n+         elsif Nkind (N) = N_Package_Declaration then\n+            Set_Scope (Defining_Entity (N), E);\n+            return Skip;\n+\n+         elsif N = Proc_Body then\n+\n+            --  Scan declarations\n+\n+            Decl := First (Declarations (N));\n+            while Present (Decl) loop\n+               Reset_Scopes (Decl);\n+               Next (Decl);\n+            end loop;\n+\n+         elsif N /= Proc_Body and then Nkind (N) in N_Proper_Body then\n+            return Skip;\n+         elsif Nkind (N) = N_Defining_Identifier then\n+            Set_Scope (N, E);\n+         end if;\n+\n+         return OK;\n+      end Reset_Scope;\n+\n+   begin\n+      Reset_Scopes (Proc_Body);\n+   end Reset_Scopes_To;\n+\n    ----------------------\n    -- Set_Discriminals --\n    ----------------------"}, {"sha": "9a2a482f32c343025d33f6b087761fc080727827", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 94, "deletions": 13, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccc2a6139062395fb5747d0846a1ed6de25293c2/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccc2a6139062395fb5747d0846a1ed6de25293c2/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=ccc2a6139062395fb5747d0846a1ed6de25293c2", "patch": "@@ -526,6 +526,23 @@ package body Exp_Unst is\n                         end loop;\n                      end;\n \n+                  --  Binary operator cases. These can apply\n+                  --  to arrays for which we may need bounds.\n+\n+                  elsif Nkind (N) in N_Binary_Op then\n+                     Note_Uplevel_Bound (Left_Opnd (N),  Ref);\n+                     Note_Uplevel_Bound (Right_Opnd (N), Ref);\n+\n+                  --  Unary operator case\n+\n+                  elsif Nkind (N) in N_Unary_Op then\n+                     Note_Uplevel_Bound (Right_Opnd (N), Ref);\n+\n+                  --  Explicit dereference case\n+\n+                  elsif Nkind (N) = N_Explicit_Dereference then\n+                     Note_Uplevel_Bound (Prefix (N), Ref);\n+\n                   --  Conversion case\n \n                   elsif Nkind (N) = N_Type_Conversion then\n@@ -694,12 +711,16 @@ package body Exp_Unst is\n             procedure Register_Subprogram (E : Entity_Id; Bod : Node_Id) is\n                L : constant Nat := Get_Level (Subp, E);\n \n+            --  Subprograms declared in tasks and protected types cannot\n+            --  be eliminated because calls to them may be in other units,\n+            --  so they must be treated as reachable.\n+\n             begin\n                Subps.Append\n                  ((Ent           => E,\n                    Bod           => Bod,\n                    Lev           => L,\n-                   Reachable     => False,\n+                   Reachable     => In_Synchronized_Unit (E),\n                    Uplevel_Ref   => L,\n                    Declares_AREC => False,\n                    Uents         => No_Elist,\n@@ -890,7 +911,9 @@ package body Exp_Unst is\n                --  no relevant code generation.\n \n                when N_Component_Association =>\n-                  if No (Etype (Expression (N))) then\n+                  if No (Expression (N))\n+                    or else No (Etype (Expression (N)))\n+                  then\n                      return Skip;\n                   end if;\n \n@@ -932,6 +955,29 @@ package body Exp_Unst is\n                      end;\n                   end if;\n \n+               --  For EQ/NE comparisons, we need the type of the operands\n+               --  in order to do the comparison, which means we need the\n+               --  bounds.\n+\n+               when N_Op_Eq | N_Op_Ne =>\n+                  declare\n+                     DT : Boolean := False;\n+                  begin\n+                     Check_Static_Type (Etype (Left_Opnd  (N)), Empty, DT);\n+                     Check_Static_Type (Etype (Right_Opnd (N)), Empty, DT);\n+                  end;\n+\n+               --  Likewise we need the sizes to compute how much to move in\n+               --  an assignment.\n+\n+               when N_Assignment_Statement =>\n+                  declare\n+                     DT : Boolean := False;\n+                  begin\n+                     Check_Static_Type (Etype (Name       (N)), Empty, DT);\n+                     Check_Static_Type (Etype (Expression (N)), Empty, DT);\n+                  end;\n+\n                --  Record a subprogram. We record a subprogram body that acts\n                --  as a spec. Otherwise we record a subprogram declaration,\n                --  providing that it has a corresponding body we can get hold\n@@ -1013,6 +1059,11 @@ package body Exp_Unst is\n                      return Skip;\n                   end if;\n \n+               --  Pragmas and component declarations can be ignored.\n+\n+               when N_Pragma | N_Component_Declaration =>\n+                  return Skip;\n+\n                --  Otherwise record an uplevel reference in a local\n                --  identifier.\n \n@@ -1036,7 +1087,8 @@ package body Exp_Unst is\n                         --  references to global declarations.\n \n                        and then\n-                         (Ekind_In (Ent, E_Constant, E_Variable)\n+                         (Ekind_In\n+                           (Ent, E_Constant, E_Variable, E_Loop_Parameter)\n \n                         --  Formals are interesting, but not if being used as\n                         --  mere names of parameters for name notation calls.\n@@ -1222,7 +1274,26 @@ package body Exp_Unst is\n                      --  mark as requiring activation records.\n \n                      exit when No (S);\n-                     Subps.Table (Subp_Index (S)).Declares_AREC := True;\n+\n+                     declare\n+                        SUBI : Subp_Entry renames Subps.Table (Subp_Index (S));\n+                     begin\n+                        SUBI.Declares_AREC := True;\n+\n+                        --  If this entity was marked reachable because it is\n+                        --  in a task or protected type, there may not appear\n+                        --  to be any calls to it, which would normally\n+                        --  adjust the levels of the parent subprograms.\n+                        --  So we need to be sure that the uplevel reference\n+                        --  of that entity takes into account possible calls.\n+\n+                        if In_Synchronized_Unit (SUBF.Ent)\n+                          and then SUBT.Lev < SUBI.Uplevel_Ref\n+                        then\n+                           SUBI.Uplevel_Ref := SUBT.Lev;\n+                        end if;\n+                     end;\n+\n                      exit when S = URJ.Callee;\n                   end loop;\n \n@@ -1272,13 +1343,6 @@ package body Exp_Unst is\n                Decl : Node_Id;\n \n             begin\n-               --  Subprograms declared in tasks and protected types are\n-               --  reachable and cannot be eliminated.\n-\n-               if In_Synchronized_Unit (STJ.Ent) then\n-                  STJ.Reachable := True;\n-               end if;\n-\n                --  Subprogram is reachable, copy and reset index\n \n                if STJ.Reachable then\n@@ -1796,7 +1860,8 @@ package body Exp_Unst is\n                                  --  right after the declaration of ARECnP.\n                                  --  For all other entities, we insert\n                                  --  the assignment immediately after the\n-                                 --  declaration of the entity.\n+                                 --  declaration of the entity or after\n+                                 --  the freeze node if present.\n \n                                  --  Note: we don't need to mark the entity\n                                  --  as being aliased, because the address\n@@ -1805,6 +1870,10 @@ package body Exp_Unst is\n \n                                  if Is_Formal (Ent) then\n                                     Ins := Decl_ARECnP;\n+\n+                                 elsif Has_Delayed_Freeze (Ent) then\n+                                    Ins := Freeze_Node (Ent);\n+\n                                  else\n                                     Ins := Dec;\n                                  end if;\n@@ -1837,7 +1906,19 @@ package body Exp_Unst is\n                                            New_Occurrence_Of (Ent, Loc),\n                                          Attribute_Name => Attr));\n \n-                                 Insert_After (Ins, Asn);\n+                                 --  If we have a loop parameter, we have\n+                                 --  to insert before the first statement\n+                                 --  of the loop. Ins points to the\n+                                 --  N_Loop_Parametrer_Specification.\n+\n+                                 if Ekind (Ent) = E_Loop_Parameter then\n+                                    Ins := First (Statements\n+                                                    (Parent (Parent (Ins))));\n+                                    Insert_Before (Ins, Asn);\n+\n+                                 else\n+                                    Insert_After (Ins, Asn);\n+                                 end if;\n \n                                  --  Analyze the assignment statement. We do\n                                  --  not need to establish the relevant scope"}]}