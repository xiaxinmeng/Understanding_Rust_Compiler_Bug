{"sha": "e0adfeb41a96835d79447e2d091a69749da5230c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBhZGZlYjQxYTk2ODM1ZDc5NDQ3ZTJkMDkxYTY5NzQ5ZGE1MjMwYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-03-30T09:29:15Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-03-30T09:29:15Z"}, "message": "[multiple changes]\n\n2012-03-30  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_util.adb (Is_Secondary_Stack_BIP_Func_Call): Handle a case where\n\ta build-in-place call appears as Prefix'Reference'Reference.\n\n2012-03-30  Yannick Moy  <moy@adacore.com>\n\n\t* lib-xref-alfa.adb: Minor refactoring to remove internal package.\n\n2012-03-30  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch5.adb (Analyze_Iteration_Scheme): Preanalyze the subtype\n\tdefinition of a loop when the context is a quantified expression.\n\n2012-03-30  Vincent Celier  <celier@adacore.com>\n\n\t* prj.ads: Minor comment update.\n\nFrom-SVN: r186005", "tree": {"sha": "9b1f1794a44b4497b0fd1c12472136d877994803", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b1f1794a44b4497b0fd1c12472136d877994803"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0adfeb41a96835d79447e2d091a69749da5230c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0adfeb41a96835d79447e2d091a69749da5230c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0adfeb41a96835d79447e2d091a69749da5230c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0adfeb41a96835d79447e2d091a69749da5230c/comments", "author": null, "committer": null, "parents": [{"sha": "ce5c2061b4af3befc13438b23dad9ad138783b98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce5c2061b4af3befc13438b23dad9ad138783b98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce5c2061b4af3befc13438b23dad9ad138783b98"}], "stats": {"total": 157, "additions": 99, "deletions": 58}, "files": [{"sha": "d3fb75a14bdfda793688854df7d0626ff8086c31", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0adfeb41a96835d79447e2d091a69749da5230c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0adfeb41a96835d79447e2d091a69749da5230c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e0adfeb41a96835d79447e2d091a69749da5230c", "patch": "@@ -1,3 +1,21 @@\n+2012-03-30  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_util.adb (Is_Secondary_Stack_BIP_Func_Call): Handle a case where\n+\ta build-in-place call appears as Prefix'Reference'Reference.\n+\n+2012-03-30  Yannick Moy  <moy@adacore.com>\n+\n+\t* lib-xref-alfa.adb: Minor refactoring to remove internal package.\n+\n+2012-03-30  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch5.adb (Analyze_Iteration_Scheme): Preanalyze the subtype\n+\tdefinition of a loop when the context is a quantified expression.\n+\n+2012-03-30  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj.ads: Minor comment update.\n+\n 2012-03-30  Yannick Moy  <moy@adacore.com>\n \n \t* lib-xref-alfa.adb, alloc.ads, lib-xref.ads: Minor addition of"}, {"sha": "335ba10c9dbf3411b3e7ccb23098368b2bcfa26b", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0adfeb41a96835d79447e2d091a69749da5230c/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0adfeb41a96835d79447e2d091a69749da5230c/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=e0adfeb41a96835d79447e2d091a69749da5230c", "patch": "@@ -4889,11 +4889,13 @@ package body Exp_Util is\n       Call : Node_Id := Expr;\n \n    begin\n-      --  Build-in-place calls usually appear in 'reference format\n+      --  Build-in-place calls usually appear in 'reference format. Note that\n+      --  the accessibility check machinery may add an extra 'reference due to\n+      --  side effect removal.\n \n-      if Nkind (Call) = N_Reference then\n+      while Nkind (Call) = N_Reference loop\n          Call := Prefix (Call);\n-      end if;\n+      end loop;\n \n       if Nkind_In (Call, N_Qualified_Expression,\n                          N_Unchecked_Type_Conversion)"}, {"sha": "7ccacbb07ec175f3540b2805796798924ab6d2b2", "filename": "gcc/ada/lib-xref-alfa.adb", "status": "modified", "additions": 41, "deletions": 50, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0adfeb41a96835d79447e2d091a69749da5230c/gcc%2Fada%2Flib-xref-alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0adfeb41a96835d79447e2d091a69749da5230c/gcc%2Fada%2Flib-xref-alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-alfa.adb?ref=e0adfeb41a96835d79447e2d091a69749da5230c", "patch": "@@ -336,58 +336,31 @@ package body Alfa is\n \n       package Sorting is new GNAT.Heap_Sort_G (Move, Lt);\n \n-      --  Internal package to build a correspondance between entities and scope\n+      function Get_Scope_Num (N : Entity_Id) return Nat;\n+      --  Return the scope number associated to entity N\n+\n+      procedure Set_Scope_Num (N : Entity_Id; Num : Nat);\n+      --  Associate entity N to scope number Num\n+\n+      No_Scope : constant Nat := 0;\n+      --  Initial scope counter\n+\n+      type Scope_Rec is record\n+         Num    : Nat;\n+         Entity : Entity_Id;\n+      end record;\n+      --  Type used to relate an entity and a scope number\n+\n+      package Scopes is new GNAT.HTable.Simple_HTable\n+        (Header_Num => Entity_Hashed_Range,\n+         Element    => Scope_Rec,\n+         No_Element => (Num => No_Scope, Entity => Empty),\n+         Key        => Entity_Id,\n+         Hash       => Entity_Hash,\n+         Equal      => \"=\");\n+      --  Package used to build a correspondance between entities and scope\n       --  numbers used in Alfa cross references.\n \n-      package Scopes is\n-         No_Scope : constant Nat := 0;\n-\n-         function Get_Scope_Num (N : Entity_Id) return Nat;\n-         --  Return the scope number associated to entity N\n-\n-         procedure Set_Scope_Num (N : Entity_Id; Num : Nat);\n-         --  Associate entity N to scope number Num\n-      end Scopes;\n-\n-      ------------\n-      -- Scopes --\n-      ------------\n-\n-      package body Scopes is\n-         type Scope is record\n-            Num    : Nat;\n-            Entity : Entity_Id;\n-         end record;\n-\n-         package Scopes is new GNAT.HTable.Simple_HTable\n-           (Header_Num => Entity_Hashed_Range,\n-            Element    => Scope,\n-            No_Element => (Num => No_Scope, Entity => Empty),\n-            Key        => Entity_Id,\n-            Hash       => Entity_Hash,\n-            Equal      => \"=\");\n-\n-         -------------------\n-         -- Get_Scope_Num --\n-         -------------------\n-\n-         function Get_Scope_Num (N : Entity_Id) return Nat is\n-         begin\n-            return Scopes.Get (N).Num;\n-         end Get_Scope_Num;\n-\n-         -------------------\n-         -- Set_Scope_Num --\n-         -------------------\n-\n-         procedure Set_Scope_Num (N : Entity_Id; Num : Nat) is\n-         begin\n-            Scopes.Set (K => N, E => Scope'(Num => Num, Entity => N));\n-         end Set_Scope_Num;\n-      end Scopes;\n-\n-      use Scopes;\n-\n       Nrefs : Nat := Xrefs.Last;\n       --  Number of references in table. This value may get reset (reduced)\n       --  when we eliminate duplicate reference entries as well as references\n@@ -426,6 +399,15 @@ package body Alfa is\n          end case;\n       end Get_Entity_Type;\n \n+      -------------------\n+      -- Get_Scope_Num --\n+      -------------------\n+\n+      function Get_Scope_Num (N : Entity_Id) return Nat is\n+      begin\n+         return Scopes.Get (N).Num;\n+      end Get_Scope_Num;\n+\n       -----------------------\n       -- Is_Alfa_Reference --\n       -----------------------\n@@ -638,6 +620,15 @@ package body Alfa is\n          Rnums (Nat (To)) := Rnums (Nat (From));\n       end Move;\n \n+      -------------------\n+      -- Set_Scope_Num --\n+      -------------------\n+\n+      procedure Set_Scope_Num (N : Entity_Id; Num : Nat) is\n+      begin\n+         Scopes.Set (K => N, E => Scope_Rec'(Num => Num, Entity => N));\n+      end Set_Scope_Num;\n+\n       ------------------------\n       -- Update_Scope_Range --\n       ------------------------"}, {"sha": "a95ac73281341551b59a77de03df05f2996a6a66", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0adfeb41a96835d79447e2d091a69749da5230c/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0adfeb41a96835d79447e2d091a69749da5230c/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=e0adfeb41a96835d79447e2d091a69749da5230c", "patch": "@@ -298,9 +298,26 @@ package Prj is\n    --  Type for the kind of language. All languages are file based, except Ada\n    --  which is unit based.\n \n-   type Dependency_File_Kind is (None, Makefile, ALI_File, ALI_Closure);\n-   --  Type of dependency to be checked: no dependency file, Makefile fragment\n-   --  or ALI file (for Ada). Please comment ALI_Closure ???\n+   --  Type of dependency to be checked\n+\n+   type Dependency_File_Kind is\n+     (None,\n+      --  There is no dependency file, the source must always be recompiled\n+\n+      Makefile,\n+      --  The dependency file is a Makefile fragment indicating all the files\n+      --  the source depends on. If the object file or the dependency file is\n+      --  more recent than any of these files, the source must be recompiled.\n+\n+      ALI_File,\n+      --  The dependency file is an ALI file and the source must be recompiled\n+      --  if the object or ALI file is more recent than any of the sources\n+      --  listed in the D lines.\n+\n+      ALI_Closure);\n+      --  The dependency file is an ALI file and the source must be recompiled\n+      --  if the object or ALI file is more recent than any source in the full\n+      --  closure.\n \n    Makefile_Dependency_Suffix : constant String := \".d\";\n    ALI_Dependency_Suffix      : constant String := \".ali\";\n@@ -472,6 +489,11 @@ package Prj is\n       --  are used to specify the object file. The object file name is appended\n       --  to the last switch in the list. Example: (\"-o\", \"\").\n \n+      Object_Path_Switches : Name_List_Index := No_Name_List;\n+      --  List of switches to specify to the compiler the path name of a\n+      --  temporary file containing the list of object directories in the\n+      --  correct order.\n+\n       Compilation_PIC_Option : Name_List_Index := No_Name_List;\n       --  The option(s) to compile a source in Position Independent Code for\n       --  shared libraries. Specified in the configuration. When not specified,\n@@ -602,6 +624,7 @@ package Prj is\n                            Source_File_Switches         => No_Name_List,\n                            Object_File_Suffix           => No_Name,\n                            Object_File_Switches         => No_Name_List,\n+                           Object_Path_Switches         => No_Name_List,\n                            Compilation_PIC_Option       => No_Name_List,\n                            Object_Generated             => True,\n                            Objects_Linked               => True,\n@@ -1233,6 +1256,10 @@ package Prj is\n       --  The path name of the exec directory of this project file. Default is\n       --  equal to Object_Directory.\n \n+      Object_Path_File : Path_Name_Type := No_Path;\n+      --  Store the name of the temporary file that contains the list of object\n+      --  directories, when attribute Object_Path_Switches is declared.\n+\n       -------------\n       -- Library --\n       -------------"}, {"sha": "7155ba90177dbe4d12d962eba2951b5e4294b99f", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0adfeb41a96835d79447e2d091a69749da5230c/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0adfeb41a96835d79447e2d091a69749da5230c/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=e0adfeb41a96835d79447e2d091a69749da5230c", "patch": "@@ -1972,11 +1972,14 @@ package body Sem_Ch5 is\n                      N);\n                end if;\n \n-               --  Now analyze the subtype definition. If it is a range, create\n-               --  temporaries for bounds.\n+               --  Analyze the subtype definition and create temporaries for\n+               --  the bounds. Do not evaluate the range when preanalyzing a\n+               --  quantified expression because bounds expressed as function\n+               --  calls with side effects will be erroneously replicated.\n \n                if Nkind (DS) = N_Range\n                  and then Expander_Active\n+                 and then Nkind (Parent (N)) /= N_Quantified_Expression\n                then\n                   Process_Bounds (DS);\n "}]}