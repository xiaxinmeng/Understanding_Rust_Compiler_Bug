{"sha": "2efb237ffc68ec9bb17982434f5941bfa14f8b50", "node_id": "C_kwDOANBUbNoAKDJlZmIyMzdmZmM2OGVjOWJiMTc5ODI0MzRmNTk0MWJmYTE0ZjhiNTA", "commit": {"author": {"name": "Jeff Chapman II", "email": "jchapman@lock3software.com", "date": "2021-06-29T20:52:56Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-11-19T02:41:14Z"}, "message": "c++: implement P1492 contracts\n\nImplement the P1492 versions of contracts, along with extensions that\nsupport the emulation of N4820 and other proposals. This implementation\nassigns a concrete semantic (one of: ignore, assume, enforce, or\nobserve) to each contract attribute depending on its labels and\nconfiguration options.\n\nCo-authored-by: Andrew Sutton  <asutton@lock3software.com>\nCo-authored-by: Andrew Marmaduke <amarmaduke@lock3software.com>\nCo-authored-by: Michael Lopez <mlopez@lock3software.com>\nCo-authored-by: Jason Merrill  <jason@redhat.com>\n\ngcc/ChangeLog:\n\n\t* doc/invoke.texi: Document contracts flags.\n\ngcc/c-family/ChangeLog:\n\n\t* c.opt: Add contracts flags.\n\t* c-cppbuiltin.cc (c_cpp_builtins): Add contracts feature-test\n\tmacros.\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (enum cp_tree_index): Add\n\tCPTI_PSEUDO_CONTRACT_VIOLATION.\n\t(pseudo_contract_violation_type): New macro.\n\t(struct saved_scope): Add x_processing_contract_condition.\n\t(processing_contract_condition): New macro.\n\t(comparing_override_contracts): New variable decl.\n\t(find_contract): New inline.\n\t(set_decl_contracts): New inline.\n\t(get_contract_semantic): New inline.\n\t(set_contract_semantic): New inline.\n\t* constexpr.cc (cxx_eval_assert): Split out from...\n\t(cxx_eval_internal_function): ...here.\n\t(cxx_eval_constant_expression): Use it for contracts.\n\t(potential_constant_expression_1): Handle contracts.\n\t* cp-gimplify.cc (cp_genericize_r): Handle contracts.\n\t* cp-objcp-common.cc (cp_tree_size): Handle contracts.\n\t(cp_common_init_ts): Handle contracts.\n\t(cp_handle_option): Handle contracts.\n\t* decl.cc (duplicate_decls): Handle contracts.\n\t(check_tag_decl): Check for bogus contracts.\n\t(start_decl): Check flag_contracts.\n\t(grokfndecl): Call rebuild_postconditions.\n\t(grokdeclarator): Handle contract attributes.\n\t(start_preparsed_function): Call start_function_contracts.\n\t(finish_function): Call finish_function_contracts.\n\t* decl2.cc (cp_check_const_attributes): Skip contracts.\n\t(comdat_linkage): Handle outlined contracts.\n\t* error.cc (dump_type): Handle null TYPE_IDENTIFIER.\n\t* g++spec.cc (EXPERIMENTAL): New macro.\n\t(lang_specific_driver): Add -lstdc++exp if -fcontracts.\n\t* mangle.cc (write_encoding): Handle outlined contracts.\n\t* module.cc (trees_out::fn_parms_init): Handle outlined contracts.\n\t(trees_in::fn_parms_init): Likewise.\n\t(check_mergeable_decl): Likewise.\n\t(module_state_config::get_dialect): Record -fcontracts.\n\t* parser.h (struct cp_unparsed_functions_entry): Add contracts.\n\t* parser.cc (unparsed_contracts): New macro.\n\t(push_unparsed_function_queues): Adjust.\n\t(contract_attribute_p): New.\n\t(cp_parser_statement): Check contracts.\n\t(cp_parser_decl_specifier_seq): Handle contracts.\n\t(cp_parser_skip_to_closing_square_bracket): Split out...\n\t(cp_parser_skip_up_to_closing_square_bracket): ...this fn.\n\t(cp_parser_class_specifier): Do contract late parsing.\n\t(cp_parser_class_head): Check contracts.\n\t(cp_parser_contract_role): New.\n\t(cp_parser_contract_mode_opt): New.\n\t(find_error, contains_error_p): New.\n\t(cp_parser_contract_attribute_spec): New.\n\t(cp_parser_late_contract_condition): New.\n\t(cp_parser_std_attribute_spec): Handle contracts.\n\t(cp_parser_save_default_args): Also save contracts.\n\t* pt.cc (register_parameter_specializations): No longer static.\n\t(register_local_identity): New.\n\t(check_explicit_specialization): Call remove_contract_attributes.\n\t(tsubst_contract, tsubst_contract_attribute): New.\n\t(tsubst_contract_attributes): New.\n\t(tsubst_attribute): Add comment.\n\t(tsubst_copy): Also allow parm when processing_contract_condition.\n\t(tsubst_expr): Handle contracts.\n\t(regenerate_decl_from_template): Handle contracts.\n\t* search.cc (check_final_overrider): Compare contracts.\n\t* semantics.cc (set_cleanup_locs): Skip POSTCONDITION_STMT.\n\t(finish_non_static_data_member): Check contracts.\n\t(finish_this_expr): Check contracts.\n\t(process_outer_var_ref): Handle contracts.\n\t(finish_id_expression_1): Handle contracts.\n\t(apply_deduced_return_type): Adjust contracts.\n\t* tree.cc (handle_contract_attribute): New.\n\t(get_innermost_component, is_this_expression): New.\n\t(comparing_this_references): New.\n\t(equivalent_member_references): New.\n\t(cp_tree_equal): Check it.\n\t* typeck.cc (check_return_expr): Apply contracts.\n\t* Make-lang.in: Add contracts.o.\n\t* config-lang.in: Add contracts.cc.\n\t* cp-tree.def (ASSERTION_STMT, PRECONDITION_STMT)\n\t(POSTCONDITION_STMT): New.\n\t* contracts.h: New file.\n\t* contracts.cc: New file.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/modules/modules.exp: Pass dg-options to link command.\n\t* lib/g++.exp: Add -L for libstdc++exp.a.\n\t* g++.dg/contracts/backtrace_handler/assert_fail.cpp: New test.\n\t* g++.dg/contracts/backtrace_handler/handle_contract_violation.cpp: New test.\n\t* g++.dg/contracts/contracts-access1.C: New test.\n\t* g++.dg/contracts/contracts-assume1.C: New test.\n\t* g++.dg/contracts/contracts-assume2.C: New test.\n\t* g++.dg/contracts/contracts-assume3.C: New test.\n\t* g++.dg/contracts/contracts-assume4.C: New test.\n\t* g++.dg/contracts/contracts-assume5.C: New test.\n\t* g++.dg/contracts/contracts-assume6.C: New test.\n\t* g++.dg/contracts/contracts-comdat1.C: New test.\n\t* g++.dg/contracts/contracts-config1.C: New test.\n\t* g++.dg/contracts/contracts-constexpr1.C: New test.\n\t* g++.dg/contracts/contracts-constexpr2.C: New test.\n\t* g++.dg/contracts/contracts-constexpr3.C: New test.\n\t* g++.dg/contracts/contracts-conversion1.C: New test.\n\t* g++.dg/contracts/contracts-ctor-dtor1.C: New test.\n\t* g++.dg/contracts/contracts-ctor-dtor2.C: New test.\n\t* g++.dg/contracts/contracts-cv1.C: New test.\n\t* g++.dg/contracts/contracts-deduced1.C: New test.\n\t* g++.dg/contracts/contracts-deduced2.C: New test.\n\t* g++.dg/contracts/contracts-friend1.C: New test.\n\t* g++.dg/contracts/contracts-ft1.C: New test.\n\t* g++.dg/contracts/contracts-ignore1.C: New test.\n\t* g++.dg/contracts/contracts-ignore2.C: New test.\n\t* g++.dg/contracts/contracts-large-return.C: New test.\n\t* g++.dg/contracts/contracts-multiline1.C: New test.\n\t* g++.dg/contracts/contracts-multiple-inheritance1.C: New test.\n\t* g++.dg/contracts/contracts-multiple-inheritance2.C: New test.\n\t* g++.dg/contracts/contracts-nested-class1.C: New test.\n\t* g++.dg/contracts/contracts-nested-class2.C: New test.\n\t* g++.dg/contracts/contracts-nocopy1.C: New test.\n\t* g++.dg/contracts/contracts-override.C: New test.\n\t* g++.dg/contracts/contracts-post1.C: New test.\n\t* g++.dg/contracts/contracts-post2.C: New test.\n\t* g++.dg/contracts/contracts-post3.C: New test.\n\t* g++.dg/contracts/contracts-post4.C: New test.\n\t* g++.dg/contracts/contracts-post5.C: New test.\n\t* g++.dg/contracts/contracts-post6.C: New test.\n\t* g++.dg/contracts/contracts-pre1.C: New test.\n\t* g++.dg/contracts/contracts-pre10.C: New test.\n\t* g++.dg/contracts/contracts-pre2.C: New test.\n\t* g++.dg/contracts/contracts-pre2a1.C: New test.\n\t* g++.dg/contracts/contracts-pre2a2.C: New test.\n\t* g++.dg/contracts/contracts-pre3.C: New test.\n\t* g++.dg/contracts/contracts-pre4.C: New test.\n\t* g++.dg/contracts/contracts-pre5.C: New test.\n\t* g++.dg/contracts/contracts-pre6.C: New test.\n\t* g++.dg/contracts/contracts-pre7.C: New test.\n\t* g++.dg/contracts/contracts-pre9.C: New test.\n\t* g++.dg/contracts/contracts-redecl1.C: New test.\n\t* g++.dg/contracts/contracts-redecl2.C: New test.\n\t* g++.dg/contracts/contracts-redecl3.C: New test.\n\t* g++.dg/contracts/contracts-redecl4.C: New test.\n\t* g++.dg/contracts/contracts-redecl5.C: New test.\n\t* g++.dg/contracts/contracts-redecl6.C: New test.\n\t* g++.dg/contracts/contracts-redecl7.C: New test.\n\t* g++.dg/contracts/contracts-redecl8.C: New test.\n\t* g++.dg/contracts/contracts-tmpl-attr1.C: New test.\n\t* g++.dg/contracts/contracts-tmpl-spec1.C: New test.\n\t* g++.dg/contracts/contracts-tmpl-spec2.C: New test.\n\t* g++.dg/contracts/contracts-tmpl-spec3.C: New test.\n\t* g++.dg/contracts/contracts1.C: New test.\n\t* g++.dg/contracts/contracts10.C: New test.\n\t* g++.dg/contracts/contracts11.C: New test.\n\t* g++.dg/contracts/contracts12.C: New test.\n\t* g++.dg/contracts/contracts13.C: New test.\n\t* g++.dg/contracts/contracts14.C: New test.\n\t* g++.dg/contracts/contracts15.C: New test.\n\t* g++.dg/contracts/contracts16.C: New test.\n\t* g++.dg/contracts/contracts17.C: New test.\n\t* g++.dg/contracts/contracts18.C: New test.\n\t* g++.dg/contracts/contracts19.C: New test.\n\t* g++.dg/contracts/contracts2.C: New test.\n\t* g++.dg/contracts/contracts20.C: New test.\n\t* g++.dg/contracts/contracts22.C: New test.\n\t* g++.dg/contracts/contracts24.C: New test.\n\t* g++.dg/contracts/contracts25.C: New test.\n\t* g++.dg/contracts/contracts3.C: New test.\n\t* g++.dg/contracts/contracts35.C: New test.\n\t* g++.dg/contracts/contracts4.C: New test.\n\t* g++.dg/contracts/contracts5.C: New test.\n\t* g++.dg/contracts/contracts6.C: New test.\n\t* g++.dg/contracts/contracts7.C: New test.\n\t* g++.dg/contracts/contracts8.C: New test.\n\t* g++.dg/contracts/contracts9.C: New test.\n\t* g++.dg/modules/contracts-1_a.C: New test.\n\t* g++.dg/modules/contracts-1_b.C: New test.\n\t* g++.dg/modules/contracts-2_a.C: New test.\n\t* g++.dg/modules/contracts-2_b.C: New test.\n\t* g++.dg/modules/contracts-2_c.C: New test.\n\t* g++.dg/modules/contracts-3_a.C: New test.\n\t* g++.dg/modules/contracts-3_b.C: New test.\n\t* g++.dg/modules/contracts-4_a.C: New test.\n\t* g++.dg/modules/contracts-4_b.C: New test.\n\t* g++.dg/modules/contracts-4_c.C: New test.\n\t* g++.dg/modules/contracts-4_d.C: New test.\n\t* g++.dg/modules/contracts-tpl-friend-1_a.C: New test.\n\t* g++.dg/modules/contracts-tpl-friend-1_b.C: New test.\n\t* g++.dg/contracts/backtrace_handler/Makefile: New test.\n\t* g++.dg/contracts/backtrace_handler/README: New test.\n\t* g++.dg/contracts/backtrace_handler/example_out.txt: New test.\n\t* g++.dg/contracts/backtrace_handler/example_pretty.txt: New test.\n\t* g++.dg/contracts/backtrace_handler/prettytrace.sh: New test.\n\t* g++.dg/contracts/except_preload_handler/Makefile: New test.\n\t* g++.dg/contracts/except_preload_handler/README: New test.\n\t* g++.dg/contracts/except_preload_handler/assert_fail.cpp: New test.\n\t* g++.dg/contracts/except_preload_handler/handle_contract_violation.cpp: New test.\n\t* g++.dg/contracts/noexcept_preload_handler/Makefile: New test.\n\t* g++.dg/contracts/noexcept_preload_handler/README: New test.\n\t* g++.dg/contracts/noexcept_preload_handler/assert_fail.cpp: New test.\n\t* g++.dg/contracts/noexcept_preload_handler/handle_contract_violation.cpp: New test.\n\t* g++.dg/contracts/preload_handler/Makefile: New test.\n\t* g++.dg/contracts/preload_handler/README: New test.\n\t* g++.dg/contracts/preload_handler/assert_fail.cpp: New test.\n\t* g++.dg/contracts/preload_handler/handle_contract_violation.cpp: New test.\n\t* g++.dg/contracts/preload_nocontinue_handler/Makefile: New test.\n\t* g++.dg/contracts/preload_nocontinue_handler/README: New test.\n\t* g++.dg/contracts/preload_nocontinue_handler/assert_fail.cpp: New test.\n\t* g++.dg/contracts/preload_nocontinue_handler/handle_contract_violation.cpp: New test.\n\t* g++.dg/contracts/preload_nocontinue_handler/nocontinue.cpp: New test.", "tree": {"sha": "1c4cc161c09a6cb9a87cd38f752ac9846e86fc54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c4cc161c09a6cb9a87cd38f752ac9846e86fc54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2efb237ffc68ec9bb17982434f5941bfa14f8b50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2efb237ffc68ec9bb17982434f5941bfa14f8b50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2efb237ffc68ec9bb17982434f5941bfa14f8b50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2efb237ffc68ec9bb17982434f5941bfa14f8b50/comments", "author": {"login": "JAChapmanII", "id": 290834, "node_id": "MDQ6VXNlcjI5MDgzNA==", "avatar_url": "https://avatars.githubusercontent.com/u/290834?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JAChapmanII", "html_url": "https://github.com/JAChapmanII", "followers_url": "https://api.github.com/users/JAChapmanII/followers", "following_url": "https://api.github.com/users/JAChapmanII/following{/other_user}", "gists_url": "https://api.github.com/users/JAChapmanII/gists{/gist_id}", "starred_url": "https://api.github.com/users/JAChapmanII/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JAChapmanII/subscriptions", "organizations_url": "https://api.github.com/users/JAChapmanII/orgs", "repos_url": "https://api.github.com/users/JAChapmanII/repos", "events_url": "https://api.github.com/users/JAChapmanII/events{/privacy}", "received_events_url": "https://api.github.com/users/JAChapmanII/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea63396f6b08f88f1cde827e6cab94cd488f7fa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea63396f6b08f88f1cde827e6cab94cd488f7fa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea63396f6b08f88f1cde827e6cab94cd488f7fa7"}], "stats": {"total": 10137, "additions": 10071, "deletions": 66}, "files": [{"sha": "fb11d8754c6b04dee1b5f06bfdf14e7ad40169eb", "filename": "gcc/c-family/c-cppbuiltin.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fc-family%2Fc-cppbuiltin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fc-family%2Fc-cppbuiltin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.cc?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -1087,6 +1087,12 @@ c_cpp_builtins (cpp_reader *pfile)\n           else\n             cpp_define (pfile, \"__cpp_concepts=201507L\");\n         }\n+      if (flag_contracts)\n+\t{\n+\t  cpp_define (pfile, \"__cpp_contracts=201906L\");\n+\t  cpp_define (pfile, \"__cpp_contracts_literal_semantics=201906L\");\n+\t  cpp_define (pfile, \"__cpp_contracts_roles=201906L\");\n+\t}\n       if (flag_modules)\n \t/* The std-defined value is 201907L, but I don't think we can\n \t   claim victory yet.  201810 is the p1103 date. */"}, {"sha": "90088804e6413882543ff92d88062be9ddeebf4f", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -1678,6 +1678,47 @@ fconstexpr-ops-limit=\n C++ ObjC++ Joined RejectNegative Host_Wide_Int Var(constexpr_ops_limit) Init(33554432)\n -fconstexpr-ops-limit=<number>\tSpecify maximum number of constexpr operations during a single constexpr evaluation.\n \n+fcontracts\n+C++ ObjC++ Var(flag_contracts) Init(0)\n+Enable certain features present drafts of C++ Contracts.\n+\n+Enum\n+Name(on_off) Type(int) UnknownError(argument %qs must be either %<on%> or %<off%>)\n+\n+EnumValue\n+Enum(on_off) String(off) Value(0)\n+\n+EnumValue\n+Enum(on_off) String(on) Value(1)\n+\n+fcontract-assumption-mode=\n+C++ Joined\n+-fcontract-assumption-mode=[on|off]\tEnable or disable treating axiom level contracts as assumptions (default on).\n+\n+fcontract-build-level=\n+C++ Joined RejectNegative\n+-fcontract-build-level=[off|default|audit]\tSpecify max contract level to generate runtime checks for\n+\n+fcontract-strict-declarations=\n+C++ Var(flag_contract_strict_declarations) Enum(on_off) Joined Init(0) RejectNegative\n+-fcontract-strict-declarations=[on|off]\tEnable or disable warnings on generalized redeclaration of functions with contracts (default off).\n+\n+fcontract-mode=\n+C++ Var(flag_contract_mode) Enum(on_off) Joined Init(1) RejectNegative\n+-fcontract-mode=[on|off]\tEnable or disable all contract facilities (default on).\n+\n+fcontract-continuation-mode=\n+C++ Joined\n+-fcontract-continuation-mode=[on|off]\tEnable or disable contract continuation mode (default off).\n+\n+fcontract-role=\n+C++ Joined\n+-fcontract-role=<name>:<semantics>\tSpecify the semantics for all levels in a role (default, review), or a custom contract role with given semantics (ex: opt:assume,assume,assume)\n+\n+fcontract-semantic=\n+C++ Joined\n+-fcontract-semantic=<level>:<semantic>\tSpecify the concrete semantics for level\n+\n fcoroutines\n C++ LTO Var(flag_coroutines)\n Enable C++ coroutines (experimental)."}, {"sha": "af25bdc044a85cf3ed4a5e6034e990787f9c018f", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -89,7 +89,7 @@ CXX_AND_OBJCXX_OBJS = \\\n \tcp/call.o cp/class.o cp/constexpr.o cp/constraint.o \\\n \tcp/coroutines.o cp/cp-gimplify.o \\\n \tcp/cp-objcp-common.o cp/cp-ubsan.o \\\n-\tcp/cvt.o cp/cxx-pretty-print.o \\\n+\tcp/cvt.o cp/contracts.o cp/cxx-pretty-print.o \\\n \tcp/decl.o cp/decl2.o cp/dump.o \\\n \tcp/error.o cp/except.o cp/expr.o \\\n \tcp/friend.o cp/init.o \\"}, {"sha": "f9e5f322fbf818c10a78a10380b8ef972fa9e253", "filename": "gcc/cp/config-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconfig-lang.in?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -39,6 +39,7 @@ gtfiles=\"\\\n \\$(srcdir)/c-family/c-common.cc \\$(srcdir)/c-family/c-format.cc \\\n \\$(srcdir)/c-family/c-cppbuiltin.cc \\$(srcdir)/c-family/c-pragma.cc \\\n \\$(srcdir)/cp/call.cc \\$(srcdir)/cp/class.cc \\$(srcdir)/cp/constexpr.cc \\\n+\\$(srcdir)/cp/contracts.cc \\\n \\$(srcdir)/cp/constraint.cc \\$(srcdir)/cp/coroutines.cc \\\n \\$(srcdir)/cp/cp-gimplify.cc \\\n \\$(srcdir)/cp/cp-lang.cc \\$(srcdir)/cp/cp-objcp-common.cc \\"}, {"sha": "ad43897b076c252c24ffe29fdd4ee254408dbb1e", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 86, "deletions": 35, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"fold-const.h\"\n+#include \"intl.h\"\n \n static bool verify_constant (tree, bool, bool *, bool *);\n #define VERIFY_CONSTANT(X)\t\t\t\t\t\t\\\n@@ -1988,6 +1989,61 @@ diagnose_failing_condition (tree bad, location_t cloc, bool show_expr_p,\n     inform (cloc, \"%qE evaluates to false\", bad);\n }\n \n+/* Process an assert/assume of ORIG_ARG.  If it's not supposed to be evaluated,\n+   do it without changing the current evaluation state.  If it evaluates to\n+   false, complain and return false; otherwise, return true.  */\n+\n+static bool\n+cxx_eval_assert (const constexpr_ctx *ctx, tree arg, const char *msg,\n+\t\t location_t loc, bool evaluated,\n+\t\t bool *non_constant_p, bool *overflow_p)\n+{\n+  if (*non_constant_p)\n+    return true;\n+\n+  tree eval;\n+  if (!evaluated)\n+    {\n+      if (!potential_rvalue_constant_expression (arg))\n+\treturn true;\n+\n+      constexpr_ctx new_ctx = *ctx;\n+      new_ctx.quiet = true;\n+      bool new_non_constant_p = false, new_overflow_p = false;\n+      /* Avoid modification of existing values.  */\n+      modifiable_tracker ms (new_ctx.global);\n+      eval = cxx_eval_constant_expression (&new_ctx, arg, vc_prvalue,\n+\t\t\t\t\t   &new_non_constant_p,\n+\t\t\t\t\t   &new_overflow_p);\n+    }\n+  else\n+    eval = cxx_eval_constant_expression (ctx, arg, vc_prvalue,\n+\t\t\t\t\t non_constant_p,\n+\t\t\t\t\t overflow_p);\n+  if (!*non_constant_p && integer_zerop (eval))\n+    {\n+      if (!ctx->quiet)\n+\t{\n+\t  /* See if we can find which clause was failing\n+\t     (for logical AND).  */\n+\t  tree bad = find_failing_clause (ctx, arg);\n+\t  /* If not, or its location is unusable, fall back to the\n+\t     previous location.  */\n+\t  location_t cloc = cp_expr_loc_or_loc (bad, loc);\n+\n+\t  /* Report the error. */\n+\t  auto_diagnostic_group d;\n+\t  error_at (cloc, msg);\n+\t  diagnose_failing_condition (bad, cloc, true, ctx);\n+\t  return bad;\n+\t}\n+      *non_constant_p = true;\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n /* Evaluate a call T to a GCC internal function when possible and return\n    the evaluated result or, under the control of CTX, give an error, set\n    NON_CONSTANT_P, and return the unevaluated call T otherwise.  */\n@@ -2008,41 +2064,11 @@ cxx_eval_internal_function (const constexpr_ctx *ctx, tree t,\n       return void_node;\n \n     case IFN_ASSUME:\n-      if (potential_rvalue_constant_expression (CALL_EXPR_ARG (t, 0)))\n-\t{\n-\t  constexpr_ctx new_ctx = *ctx;\n-\t  new_ctx.quiet = true;\n-\t  tree arg = CALL_EXPR_ARG (t, 0);\n-\t  bool new_non_constant_p = false, new_overflow_p = false;\n-\t  /* Avoid modification of existing values.  */\n-\t  modifiable_tracker ms (new_ctx.global);\n-\t  arg = cxx_eval_constant_expression (&new_ctx, arg, vc_prvalue,\n-\t\t\t\t\t      &new_non_constant_p,\n-\t\t\t\t\t      &new_overflow_p);\n-\t  if (!new_non_constant_p && !new_overflow_p && integer_zerop (arg))\n-\t    {\n-\t      if (!*non_constant_p && !ctx->quiet)\n-\t\t{\n-\t\t  /* See if we can find which clause was failing\n-\t\t     (for logical AND).  */\n-\t\t  tree bad = find_failing_clause (&new_ctx,\n-\t\t\t\t\t\t  CALL_EXPR_ARG (t, 0));\n-\t\t  /* If not, or its location is unusable, fall back to the\n-\t\t     previous location.  */\n-\t\t  location_t cloc = cp_expr_loc_or_loc (bad, EXPR_LOCATION (t));\n-\n-\t\t  auto_diagnostic_group d;\n-\n-\t\t  /* Report the error. */\n-\t\t  error_at (cloc,\n-\t\t\t    \"failed %<assume%> attribute assumption\");\n-\t\t  diagnose_failing_condition (bad, cloc, false, &new_ctx);\n-\t\t}\n-\n-\t      *non_constant_p = true;\n-\t      return t;\n-\t    }\n-\t}\n+      if (!cxx_eval_assert (ctx, CALL_EXPR_ARG (t, 0),\n+\t\t\t    G_(\"failed %<assume%> attribute assumption\"),\n+\t\t\t    EXPR_LOCATION (t), /*eval*/false,\n+\t\t\t    non_constant_p, overflow_p))\n+\treturn t;\n       return void_node;\n \n     case IFN_ADD_OVERFLOW:\n@@ -7901,6 +7927,24 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       r = void_node;\n       break;\n \n+    case ASSERTION_STMT:\n+    case PRECONDITION_STMT:\n+    case POSTCONDITION_STMT:\n+      {\n+\tcontract_semantic semantic = get_contract_semantic (t);\n+\tif (semantic == CCS_IGNORE)\n+\t  break;\n+\n+\tif (!cxx_eval_assert (ctx, CONTRACT_CONDITION (t),\n+\t\t\t      G_(\"contract predicate is false in \"\n+\t\t\t\t \"constant expression\"),\n+\t\t\t      EXPR_LOCATION (t), checked_contract_p (semantic),\n+\t\t\t      non_constant_p, overflow_p))\n+\t  *non_constant_p = true;\n+\tr = void_node;\n+      }\n+      break;\n+\n     case TEMPLATE_ID_EXPR:\n       {\n         /* We can evaluate template-id that refers to a concept only if\n@@ -9894,6 +9938,13 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \treturn false;\n       }\n \n+    case ASSERTION_STMT:\n+    case PRECONDITION_STMT:\n+    case POSTCONDITION_STMT:\n+      if (!checked_contract_p (get_contract_semantic (t)))\n+\treturn true;\n+      return RECUR (CONTRACT_CONDITION (t), rval);\n+\n     case LABEL_EXPR:\n       t = LABEL_EXPR_LABEL (t);\n       if (DECL_ARTIFICIAL (t) || cxx_dialect >= cxx23)"}, {"sha": "263964393616077e6e57caeb24ab31106e2a2344", "filename": "gcc/cp/contracts.cc", "status": "added", "additions": 2240, "deletions": 0, "changes": 2240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fcontracts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fcontracts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcontracts.cc?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,2240 @@\n+/* Definitions for C++ contract levels\n+   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+   Contributed by Jeff Chapman II (jchapman@lock3software.com)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Design Notes\n+\n+   A function is called a \"guarded\" function if it has pre or post contract\n+   attributes. A contract is considered an \"active\" contract if runtime code is\n+   needed for the contract under the current contract configuration.\n+\n+   pre and post contract attributes are parsed and stored in DECL_ATTRIBUTES.\n+   assert contracts are parsed and wrapped in statements. When genericizing, all\n+   active and assumed contracts are transformed into an if block. An observed\n+   contract:\n+\n+     [[ pre: v > 0 ]]\n+\n+   is transformed into:\n+\n+     if (!(v > 0)) {\n+       handle_contract_violation(__pseudo_contract_violation{\n+\t 5, // line_number,\n+\t \"main.cpp\", // file_name,\n+\t \"fun\", // function_name,\n+\t \"v > 0\", // comment,\n+\t \"default\", // assertion_level,\n+\t \"default\", // assertion_role,\n+\t MAYBE_CONTINUE, // continuation_mode\n+       });\n+       terminate (); // if NEVER_CONTINUE\n+     }\n+\n+   We use an internal type with the same layout as contract_violation rather\n+   than try to define the latter internally and somehow deal with its actual\n+   definition in a TU that includes <contract>.\n+\n+   ??? is it worth factoring out the calls to handle_contract_violation and\n+   terminate into a local function?\n+\n+   Assumed contracts use the same implementation as C++23 [[assume]].\n+\n+   Parsing of pre and post contract conditions need to be deferred when the\n+   contracts are attached to a member function. The postcondition identifier\n+   cannot be used before the deduced return type of an auto function is used,\n+   except when used in a defining declaration in which case they conditions are\n+   fully parsed once the body is finished (see cpp2a/contracts-deduced{1,2}.C).\n+\n+   A list of pre and post contracts can either be repeated in their entirety or\n+   completely absent in subsequent declarations. If contract lists appear on two\n+   matching declarations, their contracts have to be equivalent. In general this\n+   means that anything before the colon have to be token equivalent and the\n+   condition must be cp_tree_equal (primarily to allow for parameter renaming).\n+\n+   Contracts on overrides must match those present on (all of) the overridee(s).\n+\n+   Template specializations may have their own contracts. If no contracts are\n+   specified on the initial specialization they're assumed to be the same as\n+   the primary template. Specialization redeclarations must then match either\n+   the primary template (if they were unspecified originally), or those\n+   specified on the specialization.\n+\n+\n+   For non-cdtors two functions are generated for ease of implementation and to\n+   avoid some cases where code bloat may occurr. These are the DECL_PRE_FN and\n+   DECL_POST_FN. Each handles checking either the set of pre or post contracts\n+   of a guarded function.\n+\n+     int fun(int v)\n+       [[ pre: v > 0 ]]\n+       [[ post r: r < 0 ]]\n+     {\n+       return -v;\n+     }\n+\n+   The original decl is left alone and instead calls are generated to pre/post\n+   functions within the body:\n+\n+     void fun.pre(int v)\n+     {\n+       [[ assert: v > 0 ]];\n+     }\n+     int fun.post(int v, int __r)\n+     {\n+       [[ assert: __r < 0 ]];\n+       return __r;\n+     }\n+     int fun(int v)\n+     {\n+       fun.pre(v);\n+       return fun.post(v, -v);\n+     }\n+\n+   If fun returns in memory, the return value is not passed through the post\n+   function; instead, the return object is initialized directly and then passed\n+   to the post function by invisible reference.\n+\n+   This sides steps a number of issues with having to rewrite the bodies or\n+   rewrite the parsed conditions as the parameters to the original function\n+   changes (as happens during redeclaration). The ultimate goal is to get\n+   something that optimizes well along the lines of\n+\n+     int fun(int v)\n+     {\n+       [[ assert: v > 0 ]];\n+       auto &&__r = -v;\n+       goto out;\n+     out:\n+       [[ assert: __r < 0 ]];\n+       return __r;\n+     }\n+\n+   With the idea being that multiple return statements could collapse the\n+   function epilogue after inlining the pre/post functions. clang is able\n+   to collapse common function epilogues, while gcc needs -O3 -Os combined.\n+\n+   Directly laying the pre contracts down in the function body doesn't have\n+   many issues. The post contracts may need to be repeated multiple times, once\n+   for each return, or a goto epilogue would need to be generated.\n+   For this initial implementation, generating function calls and letting\n+   later optimizations decide whether to inline and duplicate the actual\n+   checks or whether to collapse the shared epilogue was chosen.\n+\n+   For cdtors a post contract is implemented using a CLEANUP_STMT.\n+\n+   FIXME the compiler already shores cleanup code on multiple exit paths, so\n+   this outlining seems unnecessary if we represent the postcondition as a\n+   cleanup for all functions.\n+\n+   More helpful for optimization might be to make the contracts a wrapper\n+   function (for non-variadic functions), that could be inlined into a\n+   caller while preserving the call to the actual function?  Either that or\n+   mirror a never-continue post contract with an assume in the caller.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"cp-tree.h\"\n+#include \"stringpool.h\"\n+#include \"diagnostic.h\"\n+#include \"options.h\"\n+#include \"contracts.h\"\n+#include \"tree.h\"\n+#include \"tree-inline.h\"\n+#include \"attribs.h\"\n+#include \"tree-iterator.h\"\n+#include \"print-tree.h\"\n+#include \"stor-layout.h\"\n+\n+const int max_custom_roles = 32;\n+static contract_role contract_build_roles[max_custom_roles] = {\n+};\n+\n+bool valid_configs[CCS_MAYBE + 1][CCS_MAYBE + 1] = {\n+  { 0, 0, 0, 0, 0, },\n+  { 0, 1, 0, 0, 0, },\n+  { 0, 1, 1, 1, 1, },\n+  { 0, 1, 1, 1, 1, },\n+  { 0, 1, 0, 0, 1, },\n+};\n+\n+void\n+validate_contract_role (contract_role *role)\n+{\n+  gcc_assert (role);\n+  if (!unchecked_contract_p (role->axiom_semantic))\n+    error (\"axiom contract semantic must be %<assume%> or %<ignore%>\");\n+\n+  if (!valid_configs[role->default_semantic][role->audit_semantic] )\n+    warning (0, \"the %<audit%> semantic should be at least as strong as \"\n+\t\t\"the %<default%> semantic\");\n+}\n+\n+contract_semantic\n+lookup_concrete_semantic (const char *name)\n+{\n+  if (strcmp (name, \"ignore\") == 0)\n+    return CCS_IGNORE;\n+  if (strcmp (name, \"assume\") == 0)\n+    return CCS_ASSUME;\n+  if (strcmp (name, \"check_never_continue\") == 0\n+      || strcmp (name, \"never\") == 0\n+      || strcmp (name, \"abort\") == 0)\n+    return CCS_NEVER;\n+  if (strcmp (name, \"check_maybe_continue\") == 0\n+      || strcmp (name, \"maybe\") == 0)\n+    return CCS_MAYBE;\n+  error (\"'%s' is not a valid explicit concrete semantic\", name);\n+  return CCS_INVALID;\n+}\n+\n+/* Compare role and name up to either the NUL terminator or the first\n+   occurrence of colon.  */\n+\n+static bool\n+role_name_equal (const char *role, const char *name)\n+{\n+  size_t role_len = strchrnul (role, ':') - role;\n+  size_t name_len = strchrnul (name, ':') - name;\n+  if (role_len != name_len)\n+    return false;\n+  return strncmp (role, name, role_len) == 0;\n+}\n+\n+static bool\n+role_name_equal (contract_role *role, const char *name)\n+{\n+  if (role->name == NULL)\n+    return false;\n+  return role_name_equal (role->name, name);\n+}\n+\n+contract_role *\n+get_contract_role (const char *name)\n+{\n+  for (int i = 0; i < max_custom_roles; ++i)\n+    {\n+      contract_role *potential = contract_build_roles + i;\n+      if (role_name_equal (potential, name))\n+\treturn potential;\n+    }\n+  if (role_name_equal (name, \"default\") || role_name_equal (name, \"review\"))\n+    {\n+      setup_default_contract_role (false);\n+      return get_contract_role (name);\n+    }\n+  return NULL;\n+}\n+\n+contract_role *\n+add_contract_role (const char *name,\n+\t\t   contract_semantic des,\n+\t\t   contract_semantic aus,\n+\t\t   contract_semantic axs,\n+\t\t   bool update)\n+{\n+  for (int i = 0; i < max_custom_roles; ++i)\n+    {\n+      contract_role *potential = contract_build_roles + i;\n+      if (potential->name != NULL\n+\t  && !role_name_equal (potential, name))\n+\tcontinue;\n+      if (potential->name != NULL && !update)\n+\treturn potential;\n+      potential->name = name;\n+      potential->default_semantic = des;\n+      potential->audit_semantic = aus;\n+      potential->axiom_semantic = axs;\n+      return potential;\n+    }\n+  return NULL;\n+}\n+\n+enum contract_build_level { OFF, DEFAULT, AUDIT };\n+static bool flag_contract_continuation_mode = false;\n+static bool flag_contract_assumption_mode = true;\n+static int flag_contract_build_level = DEFAULT;\n+\n+static bool contracts_p1332_default = false, contracts_p1332_review = false,\n+  contracts_std = false, contracts_p1429 = false;\n+\n+static contract_semantic\n+get_concrete_check ()\n+{\n+  return flag_contract_continuation_mode ? CCS_MAYBE : CCS_NEVER;\n+}\n+\n+static contract_semantic\n+get_concrete_axiom_semantic ()\n+{\n+  return flag_contract_assumption_mode ? CCS_ASSUME : CCS_IGNORE;\n+}\n+\n+void\n+setup_default_contract_role (bool update)\n+{\n+  contract_semantic check = get_concrete_check ();\n+  contract_semantic axiom = get_concrete_axiom_semantic ();\n+  switch (flag_contract_build_level)\n+    {\n+      case OFF:\n+\tadd_contract_role (\"default\", CCS_IGNORE, CCS_IGNORE, axiom, update);\n+\tadd_contract_role (\"review\", CCS_IGNORE, CCS_IGNORE, CCS_IGNORE, update);\n+\tbreak;\n+      case DEFAULT:\n+\tadd_contract_role (\"default\", check, CCS_IGNORE, axiom, update);\n+\tadd_contract_role (\"review\", check, CCS_IGNORE, CCS_IGNORE, update);\n+\tbreak;\n+      case AUDIT:\n+\tadd_contract_role (\"default\", check, check, axiom, update);\n+\tadd_contract_role (\"review\", check, check, CCS_IGNORE, update);\n+\tbreak;\n+    }\n+}\n+\n+contract_semantic\n+map_contract_semantic (const char *ident)\n+{\n+  if (strcmp (ident, \"ignore\") == 0)\n+    return CCS_IGNORE;\n+  else if (strcmp (ident, \"assume\") == 0)\n+    return CCS_ASSUME;\n+  else if (strcmp (ident, \"check_never_continue\") == 0)\n+    return CCS_NEVER;\n+  else if (strcmp (ident, \"check_maybe_continue\") == 0)\n+    return CCS_MAYBE;\n+  return CCS_INVALID;\n+}\n+\n+contract_level\n+map_contract_level (const char *ident)\n+{\n+  if (strcmp (ident, \"default\") == 0)\n+    return CONTRACT_DEFAULT;\n+  else if (strcmp (ident, \"audit\") == 0)\n+    return CONTRACT_AUDIT;\n+  else if (strcmp (ident, \"axiom\") == 0)\n+    return CONTRACT_AXIOM;\n+  return CONTRACT_INVALID;\n+}\n+\n+\n+void\n+handle_OPT_fcontract_build_level_ (const char *arg)\n+{\n+  if (contracts_p1332_default || contracts_p1332_review || contracts_p1429)\n+    {\n+      error (\"%<-fcontract-build-level=%> cannot be mixed with p1332/p1429\");\n+      return;\n+    }\n+  else\n+    contracts_std = true;\n+\n+  if (strcmp (arg, \"off\") == 0)\n+    flag_contract_build_level = OFF;\n+  else if (strcmp (arg, \"default\") == 0)\n+    flag_contract_build_level = DEFAULT;\n+  else if (strcmp (arg, \"audit\") == 0)\n+    flag_contract_build_level = AUDIT;\n+  else\n+    error (\"%<-fcontract-build-level=%> must be off|default|audit\");\n+\n+  setup_default_contract_role ();\n+}\n+\n+void\n+handle_OPT_fcontract_assumption_mode_ (const char *arg)\n+{\n+  if (contracts_p1332_default || contracts_p1332_review || contracts_p1429)\n+    {\n+      error (\"%<-fcontract-assumption-mode=%> cannot be mixed with p1332/p1429\");\n+      return;\n+    }\n+  else\n+    contracts_std = true;\n+\n+  if (strcmp (arg, \"on\") == 0)\n+    flag_contract_assumption_mode = true;\n+  else if (strcmp (arg, \"off\") == 0)\n+    flag_contract_assumption_mode = false;\n+  else\n+    error (\"%<-fcontract-assumption-mode=%> must be %<on%> or %<off%>\");\n+\n+  setup_default_contract_role ();\n+}\n+\n+void\n+handle_OPT_fcontract_continuation_mode_ (const char *arg)\n+{\n+  if (contracts_p1332_default || contracts_p1332_review || contracts_p1429)\n+    {\n+      error (\"%<-fcontract-continuation-mode=%> cannot be mixed with p1332/p1429\");\n+      return;\n+    }\n+  else\n+    contracts_std = true;\n+\n+  if (strcmp (arg, \"on\") == 0)\n+    flag_contract_continuation_mode = true;\n+  else if (strcmp (arg, \"off\") == 0)\n+    flag_contract_continuation_mode = false;\n+  else\n+    error (\"%<-fcontract-continuation-mode=%> must be %<on%> or %<off%>\");\n+\n+  setup_default_contract_role ();\n+}\n+\n+void\n+handle_OPT_fcontract_role_ (const char *arg)\n+{\n+  const char *name = arg;\n+  const char *vals = strchr (name, ':');\n+  if (vals == NULL)\n+    {\n+      error (\"%<-fcontract-role=%> must be in the form role:semantics\");\n+      return;\n+    }\n+\n+  contract_semantic dess = CCS_INVALID, auss = CCS_INVALID, axss = CCS_INVALID;\n+  char *des = NULL, *aus = NULL, *axs = NULL;\n+  des = xstrdup (vals + 1);\n+\n+  aus = strchr (des, ',');\n+  if (aus == NULL)\n+    {\n+      error (\"%<-fcontract-role=%> semantics must include default,audit,axiom values\");\n+      goto validate;\n+    }\n+  *aus = '\\0'; // null terminate des\n+  aus = aus + 1; // move past null\n+\n+  axs = strchr (aus, ',');\n+  if (axs == NULL)\n+    {\n+      error (\"%<-fcontract-role=%> semantics must include default,audit,axiom values\");\n+      goto validate;\n+    }\n+  *axs = '\\0'; // null terminate aus\n+  axs = axs + 1; // move past null\n+\n+  dess = lookup_concrete_semantic (des);\n+  auss = lookup_concrete_semantic (aus);\n+  axss = lookup_concrete_semantic (axs);\n+validate:\n+  free (des);\n+  if (dess == CCS_INVALID || auss == CCS_INVALID || axss == CCS_INVALID)\n+    return;\n+\n+  bool is_defalult_role = role_name_equal (name, \"default\");\n+  bool is_review_role = role_name_equal (name, \"review\");\n+  bool is_std_role = is_defalult_role || is_review_role;\n+  if ((contracts_std && is_std_role) || (contracts_p1429 && is_defalult_role))\n+    {\n+      error (\"%<-fcontract-role=%> cannot be mixed with std/p1429 contract flags\");\n+      return;\n+    }\n+  else if (is_std_role)\n+    {\n+      contracts_p1332_default |= is_defalult_role;\n+      contracts_p1332_review |= is_review_role;\n+    }\n+\n+  contract_role *role = add_contract_role (name, dess, auss, axss);\n+\n+  if (role == NULL)\n+    {\n+      // TODO: not enough space?\n+      error (\"%<-fcontract-level=%> too many custom roles\");\n+      return;\n+    }\n+  else\n+    validate_contract_role (role);\n+}\n+\n+void\n+handle_OPT_fcontract_semantic_ (const char *arg)\n+{\n+  if (!strchr (arg, ':'))\n+    {\n+      error (\"%<-fcontract-semantic=%> must be in the form level:semantic\");\n+      return;\n+    }\n+\n+  if (contracts_std || contracts_p1332_default)\n+    {\n+      error (\"%<-fcontract-semantic=%> cannot be mixed with std/p1332 contract flags\");\n+      return;\n+    }\n+  contracts_p1429 = true;\n+\n+  contract_role *role = get_contract_role (\"default\");\n+  if (!role)\n+    {\n+      error (\"%<-fcontract-semantic=%> cannot find default role\");\n+      return;\n+    }\n+\n+  const char *semantic = strchr (arg, ':') + 1;\n+  contract_semantic sem = lookup_concrete_semantic (semantic);\n+  if (sem == CCS_INVALID)\n+    return;\n+\n+  if (strncmp (\"default:\", arg, 8) == 0)\n+    role->default_semantic = sem;\n+  else if (strncmp (\"audit:\", arg, 6) == 0)\n+    role->audit_semantic = sem;\n+  else if (strncmp (\"axiom:\", arg, 6) == 0)\n+    role->axiom_semantic = sem;\n+  else\n+    error (\"%<-fcontract-semantic=%> level must be default, audit, or axiom\");\n+  validate_contract_role (role);\n+}\n+\n+/* Convert a contract CONFIG into a contract_mode.  */\n+\n+static contract_mode\n+contract_config_to_mode (tree config)\n+{\n+  if (config == NULL_TREE)\n+    return contract_mode (CONTRACT_DEFAULT, get_default_contract_role ());\n+\n+  /* TREE_LIST has TREE_VALUE is a level and TREE_PURPOSE is role.  */\n+  if (TREE_CODE (config) == TREE_LIST)\n+    {\n+      contract_role *role = NULL;\n+      if (TREE_PURPOSE (config))\n+\trole = get_contract_role (IDENTIFIER_POINTER (TREE_PURPOSE (config)));\n+      if (!role)\n+\trole = get_default_contract_role ();\n+\n+      contract_level level =\n+\tmap_contract_level (IDENTIFIER_POINTER (TREE_VALUE (config)));\n+      return contract_mode (level, role);\n+    }\n+\n+  /* Literal semantic.  */\n+  gcc_assert (TREE_CODE (config) == IDENTIFIER_NODE);\n+  contract_semantic semantic =\n+    map_contract_semantic (IDENTIFIER_POINTER (config));\n+  return contract_mode (semantic);\n+}\n+\n+/* Convert a contract's config into a concrete semantic using the current\n+   contract semantic mapping.  */\n+\n+static contract_semantic\n+compute_concrete_semantic (tree contract)\n+{\n+  contract_mode mode = contract_config_to_mode (CONTRACT_MODE (contract));\n+  /* Compute the concrete semantic for the contract.  */\n+  if (!flag_contract_mode)\n+    /* If contracts are off, treat all contracts as ignore.  */\n+    return CCS_IGNORE;\n+  else if (mode.kind == contract_mode::cm_invalid)\n+    return CCS_INVALID;\n+  else if (mode.kind == contract_mode::cm_explicit)\n+    return mode.get_semantic ();\n+  else\n+    {\n+      gcc_assert (mode.get_role ());\n+      gcc_assert (mode.get_level () != CONTRACT_INVALID);\n+      contract_level level = mode.get_level ();\n+      contract_role *role = mode.get_role ();\n+      if (level == CONTRACT_DEFAULT)\n+\treturn role->default_semantic;\n+      else if (level == CONTRACT_AUDIT)\n+\treturn role->audit_semantic;\n+      else if (level == CONTRACT_AXIOM)\n+\treturn role->axiom_semantic;\n+    }\n+  gcc_assert (false);\n+}\n+\n+/* Return true if any contract in CONTRACT_ATTRs is not yet parsed.  */\n+\n+bool\n+contract_any_deferred_p (tree contract_attr)\n+{\n+  for (; contract_attr; contract_attr = CONTRACT_CHAIN (contract_attr))\n+    if (CONTRACT_CONDITION_DEFERRED_P (CONTRACT_STATEMENT (contract_attr)))\n+      return true;\n+  return false;\n+}\n+\n+/* Returns true if all attributes are contracts.  */\n+\n+bool\n+all_attributes_are_contracts_p (tree attributes)\n+{\n+  for (; attributes; attributes = TREE_CHAIN (attributes))\n+    if (!cxx_contract_attribute_p (attributes))\n+      return false;\n+  return true;\n+}\n+\n+/* Mark most of a contract as being invalid.  */\n+\n+tree\n+invalidate_contract (tree t)\n+{\n+  if (TREE_CODE (t) == POSTCONDITION_STMT && POSTCONDITION_IDENTIFIER (t))\n+    POSTCONDITION_IDENTIFIER (t) = error_mark_node;\n+  CONTRACT_CONDITION (t) = error_mark_node;\n+  CONTRACT_COMMENT (t) = error_mark_node;\n+  return t;\n+}\n+\n+/* Returns an invented parameter declration of the form 'TYPE ID' for the\n+   purpose of parsing the postcondition.\n+\n+   We use a PARM_DECL instead of a VAR_DECL so that tsubst forces a lookup\n+   in local specializations when we instantiate these things later.  */\n+\n+tree\n+make_postcondition_variable (cp_expr id, tree type)\n+{\n+  if (id == error_mark_node)\n+    return id;\n+\n+  tree decl = build_lang_decl (PARM_DECL, id, type);\n+  DECL_ARTIFICIAL (decl) = true;\n+  DECL_SOURCE_LOCATION (decl) = id.get_location ();\n+\n+  pushdecl (decl);\n+  return decl;\n+}\n+\n+/* As above, except that the type is unknown.  */\n+\n+tree\n+make_postcondition_variable (cp_expr id)\n+{\n+  return make_postcondition_variable (id, make_auto ());\n+}\n+\n+/* Check that the TYPE is valid for a named postcondition variable. Emit a\n+   diagnostic if it is not.  Returns TRUE if the result is OK and false\n+   otherwise.  */\n+\n+bool\n+check_postcondition_result (tree decl, tree type, location_t loc)\n+{\n+  if (VOID_TYPE_P (type))\n+  {\n+    const char* what;\n+    if (DECL_CONSTRUCTOR_P (decl))\n+      what = \"constructor\";\n+    else if (DECL_DESTRUCTOR_P (decl))\n+      what  = \"destructor\";\n+    else\n+      what = \"function\";\n+    error_at (loc, \"%s does not return a value to test\", what);\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+/* Instantiate each postcondition with the return type to finalize the\n+   attribute.  */\n+\n+void\n+rebuild_postconditions (tree decl)\n+{\n+  tree type = TREE_TYPE (TREE_TYPE (decl));\n+  tree attributes = DECL_CONTRACTS (decl);\n+\n+  for (; attributes ; attributes = TREE_CHAIN (attributes))\n+    {\n+      if (!cxx_contract_attribute_p (attributes))\n+\tcontinue;\n+      tree contract = TREE_VALUE (TREE_VALUE (attributes));\n+      if (TREE_CODE (contract) != POSTCONDITION_STMT)\n+\tcontinue;\n+      tree condition = CONTRACT_CONDITION (contract);\n+\n+      /* If any conditions are deferred, they're all deferred.  Note that\n+\t we don't have to instantiate postconditions in that case because\n+\t the type is available through the declaration.  */\n+      if (TREE_CODE (condition) == DEFERRED_PARSE)\n+\treturn;\n+\n+      tree oldvar = POSTCONDITION_IDENTIFIER (contract);\n+      if (!oldvar)\n+\tcontinue;\n+\n+      /* Always update the context of the result variable so that it can\n+\t be remapped by remap_contracts.  */\n+      DECL_CONTEXT (oldvar) = decl;\n+\n+      /* If the return type is undeduced, defer until later.  */\n+      if (TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n+\treturn;\n+\n+      /* Check the postcondition variable.  */\n+      location_t loc = DECL_SOURCE_LOCATION (oldvar);\n+      if (!check_postcondition_result (decl, type, loc))\n+\t{\n+\t  invalidate_contract (contract);\n+\t  continue;\n+\t}\n+\n+      /* \"Instantiate\" the result variable using the known type.  Also update\n+\t  the context so the inliner will actually remap this the parameter when\n+\t  generating contract checks.  */\n+      tree newvar = copy_node (oldvar);\n+      TREE_TYPE (newvar) = type;\n+\n+      /* Make parameters and result available for substitution.  */\n+      local_specialization_stack stack (lss_copy);\n+      for (tree t = DECL_ARGUMENTS (decl); t != NULL_TREE; t = TREE_CHAIN (t))\n+\tregister_local_identity (t);\n+      register_local_specialization (newvar, oldvar);\n+\n+      ++processing_contract_condition;\n+      condition = tsubst_expr (condition, make_tree_vec (0),\n+\t\t\t       tf_warning_or_error, decl);\n+      --processing_contract_condition;\n+\n+      /* Update the contract condition and result.  */\n+      POSTCONDITION_IDENTIFIER (contract) = newvar;\n+      CONTRACT_CONDITION (contract) = finish_contract_condition (condition);\n+    }\n+}\n+\n+static tree\n+build_comment (cp_expr condition)\n+{\n+  /* Try to get the actual source text for the condition; if that fails pretty\n+     print the resulting tree.  */\n+  char *str = get_source_text_between (condition.get_start (),\n+\t\t\t\t       condition.get_finish ());\n+  if (!str)\n+    {\n+      /* FIXME cases where we end up here\n+\t #line macro usage (oof)\n+\t contracts10.C\n+\t contracts11.C  */\n+      const char *str = expr_to_string (condition);\n+      return build_string_literal (strlen (str) + 1, str);\n+    }\n+\n+  tree t = build_string_literal (strlen (str) + 1, str);\n+  free (str);\n+  return t;\n+}\n+\n+/* Build a contract statement.  */\n+\n+tree\n+grok_contract (tree attribute, tree mode, tree result, cp_expr condition,\n+\t       location_t loc)\n+{\n+  tree_code code;\n+  if (is_attribute_p (\"assert\", attribute))\n+    code = ASSERTION_STMT;\n+  else if (is_attribute_p (\"pre\", attribute))\n+    code = PRECONDITION_STMT;\n+  else if (is_attribute_p (\"post\", attribute))\n+    code = POSTCONDITION_STMT;\n+  else\n+    gcc_unreachable ();\n+\n+  /* Build the contract. The condition is added later.  In the case that\n+     the contract is deferred, result an plain identifier, not a result\n+     variable.  */\n+  tree contract;\n+  tree type = void_type_node;\n+  if (code != POSTCONDITION_STMT)\n+    contract = build3_loc (loc, code, type, mode, NULL_TREE, NULL_TREE);\n+  else\n+    contract = build4_loc (loc, code, type, mode, NULL_TREE, NULL_TREE, result);\n+\n+  /* Determine the concrete semantic.  */\n+  set_contract_semantic (contract, compute_concrete_semantic (contract));\n+\n+  /* If the contract is deferred, don't do anything with the condition.  */\n+  if (TREE_CODE (condition) == DEFERRED_PARSE)\n+    {\n+      CONTRACT_CONDITION (contract) = condition;\n+      return contract;\n+    }\n+\n+  /* Generate the comment from the original condition.  */\n+  CONTRACT_COMMENT (contract) = build_comment (condition);\n+\n+  /* The condition is converted to bool.  */\n+  condition = finish_contract_condition (condition);\n+  CONTRACT_CONDITION (contract) = condition;\n+\n+  return contract;\n+}\n+\n+/* Build the contract attribute specifier where IDENTIFIER is one of 'pre',\n+   'post' or 'assert' and CONTRACT is the underlying statement.  */\n+tree\n+finish_contract_attribute (tree identifier, tree contract)\n+{\n+  if (contract == error_mark_node)\n+    return error_mark_node;\n+\n+  tree attribute = build_tree_list (build_tree_list (NULL_TREE, identifier),\n+\t\t\t\t    build_tree_list (NULL_TREE, contract));\n+\n+\n+  /* Mark the attribute as dependent if the condition is dependent.\n+\n+     TODO: I'm not sure this is strictly necessary. It's going to be marked as\n+     such by a subroutine of cplus_decl_attributes. */\n+  tree condition = CONTRACT_CONDITION (contract);\n+  if (TREE_CODE (condition) == DEFERRED_PARSE\n+      || value_dependent_expression_p (condition))\n+    ATTR_IS_DEPENDENT (attribute) = true;\n+\n+  return attribute;\n+}\n+\n+/* Update condition of a late-parsed contract and postcondition variable,\n+   if any.  */\n+\n+void\n+update_late_contract (tree contract, tree result, tree condition)\n+{\n+  if (TREE_CODE (contract) == POSTCONDITION_STMT)\n+    POSTCONDITION_IDENTIFIER (contract) = result;\n+\n+  /* Generate the comment from the original condition.  */\n+  CONTRACT_COMMENT (contract) = build_comment (condition);\n+\n+  /* The condition is converted to bool.  */\n+  condition = finish_contract_condition (condition);\n+  CONTRACT_CONDITION (contract) = condition;\n+}\n+\n+/* Return TRUE iff ATTR has been parsed by the front-end as a c++2a contract\n+   attribute. */\n+\n+bool\n+cxx_contract_attribute_p (const_tree attr)\n+{\n+  if (attr == NULL_TREE\n+      || TREE_CODE (attr) != TREE_LIST)\n+    return false;\n+\n+  if (!TREE_PURPOSE (attr) || TREE_CODE (TREE_PURPOSE (attr)) != TREE_LIST)\n+    return false;\n+  if (!TREE_VALUE (attr) || TREE_CODE (TREE_VALUE (attr)) != TREE_LIST)\n+    return false;\n+  if (!TREE_VALUE (TREE_VALUE (attr)))\n+    return false;\n+\n+  return (TREE_CODE (TREE_VALUE (TREE_VALUE (attr))) == PRECONDITION_STMT\n+      || TREE_CODE (TREE_VALUE (TREE_VALUE (attr))) == POSTCONDITION_STMT\n+      || TREE_CODE (TREE_VALUE (TREE_VALUE (attr))) == ASSERTION_STMT);\n+}\n+\n+/* True if ATTR is an assertion.  */\n+\n+bool\n+cp_contract_assertion_p (const_tree attr)\n+{\n+  /* This is only an assertion if it is a valid cxx contract attribute and the\n+     statement is an ASSERTION_STMT.  */\n+  return cxx_contract_attribute_p (attr)\n+    && TREE_CODE (CONTRACT_STATEMENT (attr)) == ASSERTION_STMT;\n+}\n+\n+/* Remove all c++2a style contract attributes from the DECL_ATTRIBUTEs of the\n+   FUNCTION_DECL FNDECL.  */\n+\n+void\n+remove_contract_attributes (tree fndecl)\n+{\n+  tree list = NULL_TREE;\n+  for (tree p = DECL_ATTRIBUTES (fndecl); p; p = TREE_CHAIN (p))\n+    if (!cxx_contract_attribute_p (p))\n+      list = tree_cons (TREE_PURPOSE (p), TREE_VALUE (p), NULL_TREE);\n+  DECL_ATTRIBUTES (fndecl) = nreverse (list);\n+}\n+\n+static tree find_first_non_contract (tree attributes)\n+{\n+  tree head = attributes;\n+  tree p = find_contract (attributes);\n+\n+  /* There are no contracts.  */\n+  if (!p)\n+    return head;\n+\n+  /* There are leading contracts.  */\n+  if (p == head)\n+    {\n+      while (cxx_contract_attribute_p (p))\n+\tp = TREE_CHAIN (p);\n+      head = p;\n+    }\n+\n+  return head;\n+}\n+\n+/* Remove contracts from ATTRIBUTES.  */\n+\n+tree splice_out_contracts (tree attributes)\n+{\n+  tree head = find_first_non_contract (attributes);\n+  if (!head)\n+    return NULL_TREE;\n+\n+  /* Splice out remaining contracts.  */\n+  tree p = TREE_CHAIN (head);\n+  tree q = head;\n+  while (p)\n+    {\n+      if (cxx_contract_attribute_p (p))\n+\t{\n+\t  /* Skip a sequence of contracts and then link q to the next\n+\t     non-contract attribute.  */\n+\t  do\n+\t    p = TREE_CHAIN (p);\n+\t  while (cxx_contract_attribute_p (p));\n+\t  TREE_CHAIN (q) = p;\n+\t}\n+      else\n+\tp = TREE_CHAIN (p);\n+    }\n+\n+  return head;\n+}\n+\n+/* Copy contract attributes from NEWDECL onto the attribute list of OLDDECL.  */\n+\n+void copy_contract_attributes (tree olddecl, tree newdecl)\n+{\n+  tree attrs = NULL_TREE;\n+  for (tree c = DECL_CONTRACTS (newdecl); c; c = TREE_CHAIN (c))\n+    {\n+      if (!cxx_contract_attribute_p (c))\n+\tcontinue;\n+      attrs = tree_cons (TREE_PURPOSE (c), TREE_VALUE (c), attrs);\n+    }\n+  attrs = chainon (DECL_ATTRIBUTES (olddecl), nreverse (attrs));\n+  DECL_ATTRIBUTES (olddecl) = attrs;\n+\n+  /* And update DECL_CONTEXT of the postcondition result identifier.  */\n+  rebuild_postconditions (olddecl);\n+}\n+\n+/* Returns the parameter corresponding to the return value of a guarded\n+   function D.  Returns NULL_TREE if D has no postconditions or is void.  */\n+\n+static tree\n+get_postcondition_result_parameter (tree d)\n+{\n+  if (!d || d == error_mark_node)\n+    return NULL_TREE;\n+\n+  if (VOID_TYPE_P (TREE_TYPE (TREE_TYPE (d))))\n+    return NULL_TREE;\n+\n+  tree post = DECL_POST_FN (d);\n+  if (!post || post == error_mark_node)\n+    return NULL_TREE;\n+\n+  for (tree arg = DECL_ARGUMENTS (post); arg; arg = TREE_CHAIN (arg))\n+    if (!TREE_CHAIN (arg))\n+      return arg;\n+\n+  return NULL_TREE;\n+}\n+\n+\n+/* For use with the tree inliner. This preserves non-mapped local variables,\n+   such as postcondition result variables, during remapping.  */\n+\n+static tree\n+retain_decl (tree decl, copy_body_data *)\n+{\n+  return decl;\n+}\n+\n+/* Rewrite the condition of contract in place, so that references to SRC's\n+   parameters are updated to refer to DST's parameters. The postcondition\n+   result variable is left unchanged.\n+\n+   This, along with remap_contracts, are subroutines of duplicate_decls.\n+   When declarations are merged, we sometimes need to update contracts to\n+   refer to new parameters.\n+\n+   If DUPLICATE_P is true, this is called by duplicate_decls to rewrite contacts\n+   in terms of a new set of parameters. In this case, we can retain local\n+   variables appearing in the contract because the contract is not being\n+   prepared for insertion into a new function. Importantly, this preserves the\n+   references to postcondition results, which are not replaced during merging.\n+\n+   If false, we're preparing to emit the contract condition into the body\n+   of a new function, so we need to make copies of all local variables\n+   appearing in the contract (e.g., if it includes a lambda expression). Note\n+   that in this case, postcondition results are mapped to the last parameter\n+   of DST.\n+\n+   This is also used to reuse a parent type's contracts on virtual methods.  */\n+\n+static void\n+remap_contract (tree src, tree dst, tree contract, bool duplicate_p)\n+{\n+  copy_body_data id;\n+  hash_map<tree, tree> decl_map;\n+\n+  memset (&id, 0, sizeof (id));\n+  id.src_fn = src;\n+  id.dst_fn = dst;\n+  id.src_cfun = DECL_STRUCT_FUNCTION (src);\n+  id.decl_map = &decl_map;\n+\n+  /* If we're merging contracts, don't copy local variables.  */\n+  id.copy_decl = duplicate_p ? retain_decl : copy_decl_no_change;\n+\n+  id.transform_call_graph_edges = CB_CGE_DUPLICATE;\n+  id.transform_new_cfg = false;\n+  id.transform_return_to_modify = false;\n+  id.transform_parameter = true;\n+\n+  /* Make sure not to unshare trees behind the front-end's back\n+     since front-end specific mechanisms may rely on sharing.  */\n+  id.regimplify = false;\n+  id.do_not_unshare = true;\n+  id.do_not_fold = true;\n+\n+  /* We're not inside any EH region.  */\n+  id.eh_lp_nr = 0;\n+\n+  bool do_remap = false;\n+\n+  /* Insert parameter remappings.  */\n+  if (TREE_CODE (src) == FUNCTION_DECL)\n+    src = DECL_ARGUMENTS (src);\n+  if (TREE_CODE (dst) == FUNCTION_DECL)\n+    dst = DECL_ARGUMENTS (dst);\n+\n+  for (tree sp = src, dp = dst;\n+       sp || dp;\n+       sp = DECL_CHAIN (sp), dp = DECL_CHAIN (dp))\n+    {\n+      if (!sp && dp\n+\t  && TREE_CODE (contract) == POSTCONDITION_STMT\n+\t  && DECL_CHAIN (dp) == NULL_TREE)\n+\t{\n+\t  gcc_assert (!duplicate_p);\n+\t  if (tree result = POSTCONDITION_IDENTIFIER (contract))\n+\t    {\n+\t      gcc_assert (DECL_P (result));\n+\t      insert_decl_map (&id, result, dp);\n+\t      do_remap = true;\n+\t    }\n+\t  break;\n+\t}\n+      gcc_assert (sp && dp);\n+\n+      if (sp == dp)\n+\tcontinue;\n+\n+      insert_decl_map (&id, sp, dp);\n+      do_remap = true;\n+    }\n+  if (!do_remap)\n+    return;\n+\n+  walk_tree (&CONTRACT_CONDITION (contract), copy_tree_body_r, &id, NULL);\n+}\n+\n+/* Rewrite any references to SRC's PARM_DECLs to the corresponding PARM_DECL in\n+   DST in all of the contract attributes in CONTRACTS by calling remap_contract\n+   on each.\n+\n+   This is used for two purposes: to rewrite contract attributes during\n+   duplicate_decls, and to prepare contracts for emission into a function's\n+   respective precondition and postcondition functions. DUPLICATE_P is used\n+   to determine the context in which this function is called. See above for\n+   the behavior described by this flag.  */\n+\n+void\n+remap_contracts (tree src, tree dst, tree contracts, bool duplicate_p)\n+{\n+  for (tree attr = contracts; attr; attr = CONTRACT_CHAIN (attr))\n+    {\n+      if (!cxx_contract_attribute_p (attr))\n+\tcontinue;\n+      tree contract = CONTRACT_STATEMENT (attr);\n+      if (TREE_CODE (CONTRACT_CONDITION (contract)) != DEFERRED_PARSE)\n+\tremap_contract (src, dst, contract, duplicate_p);\n+    }\n+}\n+\n+/* Helper to replace references to dummy this parameters with references to\n+   the first argument of the FUNCTION_DECL DATA.  */\n+\n+static tree\n+remap_dummy_this_1 (tree *tp, int *, void *data)\n+{\n+  if (!is_this_parameter (*tp))\n+    return NULL_TREE;\n+  tree fn = (tree)data;\n+  *tp = DECL_ARGUMENTS (fn);\n+  return NULL_TREE;\n+}\n+\n+/* Replace all references to dummy this parameters in EXPR with references to\n+   the first argument of the FUNCTION_DECL FN.  */\n+\n+static void\n+remap_dummy_this (tree fn, tree *expr)\n+{\n+  walk_tree (expr, remap_dummy_this_1, fn, NULL);\n+}\n+\n+/* Contract matching.  */\n+\n+/* True if the contract is valid.  */\n+\n+static bool\n+contract_valid_p (tree contract)\n+{\n+  return CONTRACT_CONDITION (contract) != error_mark_node;\n+}\n+\n+/* True if the contract attribute is valid.  */\n+\n+static bool\n+contract_attribute_valid_p (tree attribute)\n+{\n+  return contract_valid_p (TREE_VALUE (TREE_VALUE (attribute)));\n+}\n+\n+/* Compare the contract conditions of OLD_ATTR and NEW_ATTR. Returns false\n+   if the conditions are equivalent, and true otherwise.  */\n+\n+static bool\n+check_for_mismatched_contracts (tree old_attr, tree new_attr,\n+\t\t\t       contract_matching_context ctx)\n+{\n+  tree old_contract = CONTRACT_STATEMENT (old_attr);\n+  tree new_contract = CONTRACT_STATEMENT (new_attr);\n+\n+  /* Different kinds of contracts do not match.  */\n+  if (TREE_CODE (old_contract) != TREE_CODE (new_contract))\n+    {\n+      auto_diagnostic_group d;\n+      error_at (EXPR_LOCATION (new_contract),\n+\t\tctx == cmc_declaration\n+\t\t? \"mismatched contract attribute in declaration\"\n+\t\t: \"mismatched contract attribute in override\");\n+      inform (EXPR_LOCATION (old_contract), \"previous contract here\");\n+      return true;\n+    }\n+\n+  /* A deferred contract tentatively matches.  */\n+  if (CONTRACT_CONDITION_DEFERRED_P (new_contract))\n+    return false;\n+\n+  /* Compare the conditions of the contracts.  We fold immediately to avoid\n+     issues comparing contracts on overrides that use parameters -- see\n+     contracts-pre3.  */\n+  tree t1 = cp_fully_fold_init (CONTRACT_CONDITION (old_contract));\n+  tree t2 = cp_fully_fold_init (CONTRACT_CONDITION (new_contract));\n+\n+  /* Compare the contracts. The fold doesn't eliminate conversions to members.\n+     Set the comparing_override_contracts flag to ensure that references\n+     through 'this' are equal if they designate the same member, regardless of\n+     the path those members.  */\n+  bool saved_comparing_contracts = comparing_override_contracts;\n+  comparing_override_contracts = (ctx == cmc_override);\n+  bool matching_p = cp_tree_equal (t1, t2);\n+  comparing_override_contracts = saved_comparing_contracts;\n+\n+  if (!matching_p)\n+    {\n+      auto_diagnostic_group d;\n+      error_at (EXPR_LOCATION (CONTRACT_CONDITION (new_contract)),\n+\t\tctx == cmc_declaration\n+\t\t? \"mismatched contract condition in declaration\"\n+\t\t: \"mismatched contract condition in override\");\n+      inform (EXPR_LOCATION (CONTRACT_CONDITION (old_contract)),\n+\t      \"previous contract here\");\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Compare the contract attributes of OLDDECL and NEWDECL. Returns true\n+   if the contracts match, and false if they differ.  */\n+\n+bool\n+match_contract_conditions (location_t oldloc, tree old_attrs,\n+\t\t\t   location_t newloc, tree new_attrs,\n+\t\t\t   contract_matching_context ctx)\n+{\n+  /* Contracts only match if they are both specified.  */\n+  if (!old_attrs || !new_attrs)\n+    return true;\n+\n+  /* Compare each contract in turn.  */\n+  while (old_attrs && new_attrs)\n+    {\n+      /* If either contract is ill-formed, skip the rest of the comparison,\n+\t since we've already diagnosed an error.  */\n+      if (!contract_attribute_valid_p (new_attrs)\n+\t  || !contract_attribute_valid_p (old_attrs))\n+\treturn false;\n+\n+      if (check_for_mismatched_contracts (old_attrs, new_attrs, ctx))\n+\treturn false;\n+      old_attrs = CONTRACT_CHAIN (old_attrs);\n+      new_attrs = CONTRACT_CHAIN (new_attrs);\n+    }\n+\n+  /* If we didn't compare all attributes, the contracts don't match.  */\n+  if (old_attrs || new_attrs)\n+    {\n+      auto_diagnostic_group d;\n+      error_at (newloc,\n+\t\tctx == cmc_declaration\n+\t\t? \"declaration has a different number of contracts than \"\n+\t\t  \"previously declared\"\n+\t\t: \"override has a different number of contracts than \"\n+\t\t  \"previously declared\");\n+      inform (oldloc,\n+\t      new_attrs\n+\t      ? \"original declaration with fewer contracts here\"\n+\t      : \"original declaration with more contracts here\");\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Deferred contract mapping.\n+\n+   This is used to compare late-parsed contracts on overrides with their\n+   base class functions.\n+\n+   TODO: It seems like this could be replaced by a simple list that maps from\n+   overrides to their base functions. It's not clear that we really need\n+   a map to a function + a list of contracts.   */\n+\n+/* Map from FNDECL to a tree list of contracts that have not been matched or\n+   diagnosed yet.  The TREE_PURPOSE is the basefn we're overriding, and the\n+   TREE_VALUE is the list of contract attrs for BASEFN.  */\n+\n+static hash_map<tree_decl_hash, tree> pending_guarded_decls;\n+\n+void\n+defer_guarded_contract_match (tree fndecl, tree fn, tree contracts)\n+{\n+  if (!pending_guarded_decls.get (fndecl))\n+    {\n+      pending_guarded_decls.put (fndecl, build_tree_list (fn, contracts));\n+      return;\n+    }\n+  for (tree pending = *pending_guarded_decls.get (fndecl);\n+      pending;\n+      pending = TREE_CHAIN (pending))\n+    {\n+      if (TREE_VALUE (pending) == contracts)\n+\treturn;\n+      if (TREE_CHAIN (pending) == NULL_TREE)\n+\tTREE_CHAIN (pending) = build_tree_list (fn, contracts);\n+    }\n+}\n+\n+/* If the FUNCTION_DECL DECL has any contracts that had their matching\n+   deferred earlier, do that checking now.  */\n+\n+void\n+match_deferred_contracts (tree decl)\n+{\n+  tree *tp = pending_guarded_decls.get (decl);\n+  if (!tp)\n+    return;\n+\n+  gcc_assert(!contract_any_deferred_p (DECL_CONTRACTS (decl)));\n+\n+  processing_template_decl_sentinel ptds;\n+  processing_template_decl = uses_template_parms (decl);\n+\n+  /* Do late contract matching.  */\n+  for (tree pending = *tp; pending; pending = TREE_CHAIN (pending))\n+    {\n+      tree new_contracts = TREE_VALUE (pending);\n+      location_t new_loc = CONTRACT_SOURCE_LOCATION (new_contracts);\n+      tree old_contracts = DECL_CONTRACTS (decl);\n+      location_t old_loc = CONTRACT_SOURCE_LOCATION (old_contracts);\n+      tree base = TREE_PURPOSE (pending);\n+      match_contract_conditions (new_loc, new_contracts,\n+\t\t\t\t old_loc, old_contracts,\n+\t\t\t\t base ? cmc_override : cmc_declaration);\n+    }\n+\n+  /* Clear out deferred match list so we don't check it twice.  */\n+  pending_guarded_decls.remove (decl);\n+}\n+\n+/* Map from FUNCTION_DECL to a FUNCTION_DECL for either the PRE_FN or POST_FN.\n+   These are used to parse contract conditions and are called inside the body\n+   of the guarded function.  */\n+static GTY(()) hash_map<tree, tree> *decl_pre_fn;\n+static GTY(()) hash_map<tree, tree> *decl_post_fn;\n+\n+/* Returns the precondition funtion for D, or null if not set.  */\n+\n+tree\n+get_precondition_function (tree d)\n+{\n+  hash_map_maybe_create<hm_ggc> (decl_pre_fn);\n+  tree *result = decl_pre_fn->get (d);\n+  return result ? *result : NULL_TREE;\n+}\n+\n+/* Returns the postcondition funtion for D, or null if not set.  */\n+\n+tree\n+get_postcondition_function (tree d)\n+{\n+  hash_map_maybe_create<hm_ggc> (decl_post_fn);\n+  tree *result = decl_post_fn->get (d);\n+  return result ? *result : NULL_TREE;\n+}\n+\n+/* Makes PRE the precondition function for D.  */\n+\n+void\n+set_precondition_function (tree d, tree pre)\n+{\n+  gcc_assert (pre);\n+  hash_map_maybe_create<hm_ggc> (decl_pre_fn);\n+  gcc_assert (!decl_pre_fn->get (d));\n+  decl_pre_fn->put (d, pre);\n+}\n+\n+/* Makes POST the postcondition function for D.  */\n+\n+void\n+set_postcondition_function (tree d, tree post)\n+{\n+  gcc_assert (post);\n+  hash_map_maybe_create<hm_ggc> (decl_post_fn);\n+  gcc_assert (!decl_post_fn->get (d));\n+  decl_post_fn->put (d, post);\n+}\n+\n+/* Set the PRE and POST functions for D.  Note that PRE and POST can be\n+   null in this case. If so the functions are not recorded.  */\n+\n+void\n+set_contract_functions (tree d, tree pre, tree post)\n+{\n+  if (pre)\n+    set_precondition_function (d, pre);\n+  if (post)\n+    set_postcondition_function (d, post);\n+}\n+\n+/* Return a copy of the FUNCTION_DECL IDECL with its own unshared\n+   PARM_DECL and DECL_ATTRIBUTEs.  */\n+\n+static tree\n+copy_fn_decl (tree idecl)\n+{\n+  tree decl = copy_decl (idecl);\n+  DECL_ATTRIBUTES (decl) = copy_list (DECL_ATTRIBUTES (idecl));\n+\n+  if (DECL_RESULT (idecl))\n+    {\n+      DECL_RESULT (decl) = copy_decl (DECL_RESULT (idecl));\n+      DECL_CONTEXT (DECL_RESULT (decl)) = decl;\n+    }\n+  if (!DECL_ARGUMENTS (idecl) || VOID_TYPE_P (DECL_ARGUMENTS (idecl)))\n+    return decl;\n+\n+  tree last = DECL_ARGUMENTS (decl) = copy_decl (DECL_ARGUMENTS (decl));\n+  DECL_CONTEXT (last) = decl;\n+  for (tree p = TREE_CHAIN (DECL_ARGUMENTS (idecl)); p; p = TREE_CHAIN (p))\n+    {\n+      if (VOID_TYPE_P (p))\n+\t{\n+\t  TREE_CHAIN (last) = void_list_node;\n+\t  break;\n+\t}\n+      last = TREE_CHAIN (last) = copy_decl (p);\n+      DECL_CONTEXT (last) = decl;\n+    }\n+  return decl;\n+}\n+\n+/* Build a declaration for the pre- or postcondition of a guarded FNDECL.  */\n+\n+static tree\n+build_contract_condition_function (tree fndecl, bool pre)\n+{\n+  if (TREE_TYPE (fndecl) == error_mark_node)\n+    return error_mark_node;\n+  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fndecl)\n+      && !TYPE_METHOD_BASETYPE (TREE_TYPE (fndecl)))\n+    return error_mark_node;\n+\n+  /* Create and rename the unchecked function and give an internal name.  */\n+  tree fn = copy_fn_decl (fndecl);\n+  DECL_RESULT (fn) = NULL_TREE;\n+  tree value_type = pre ? void_type_node : TREE_TYPE (TREE_TYPE (fn));\n+\n+  /* Don't propagate declaration attributes to the checking function,\n+     including the original contracts.  */\n+  DECL_ATTRIBUTES (fn) = NULL_TREE;\n+\n+  tree arg_types = NULL_TREE;\n+  tree *last = &arg_types;\n+\n+  /* FIXME will later optimizations delete unused args to prevent extra arg\n+     passing? do we care? */\n+  tree class_type = NULL_TREE;\n+  for (tree arg_type = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+      arg_type && arg_type != void_list_node;\n+      arg_type = TREE_CHAIN (arg_type))\n+    {\n+      if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fndecl)\n+\t  && TYPE_ARG_TYPES (TREE_TYPE (fn)) == arg_type)\n+      {\n+\tclass_type = TREE_TYPE (TREE_VALUE (arg_type));\n+\tcontinue;\n+      }\n+      *last = build_tree_list (TREE_PURPOSE (arg_type), TREE_VALUE (arg_type));\n+      last = &TREE_CHAIN (*last);\n+    }\n+\n+  if (pre || VOID_TYPE_P (value_type))\n+    *last = void_list_node;\n+  else\n+    {\n+      tree name = get_identifier (\"__r\");\n+      tree parm = build_lang_decl (PARM_DECL, name, value_type);\n+      DECL_CONTEXT (parm) = fn;\n+      DECL_ARGUMENTS (fn) = chainon (DECL_ARGUMENTS (fn), parm);\n+\n+      *last = build_tree_list (NULL_TREE, value_type);\n+      TREE_CHAIN (*last) = void_list_node;\n+\n+      if (aggregate_value_p (value_type, fndecl))\n+\t/* If FNDECL returns in memory, don't return the value from the\n+\t   postcondition.  */\n+\tvalue_type = void_type_node;\n+    }\n+\n+  TREE_TYPE (fn) = build_function_type (value_type, arg_types);\n+  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fndecl))\n+    TREE_TYPE (fn) = build_method_type (class_type, TREE_TYPE (fn));\n+\n+  DECL_NAME (fn) = copy_node (DECL_NAME (fn));\n+  DECL_INITIAL (fn) = error_mark_node;\n+  DECL_ABSTRACT_ORIGIN (fn) = fndecl;\n+\n+  IDENTIFIER_VIRTUAL_P (DECL_NAME (fn)) = false;\n+  DECL_VIRTUAL_P (fn) = false;\n+\n+  /* Make these functions internal if we can, i.e. if the guarded function is\n+     not vague linkage, or if we can put them in a comdat group with the\n+     guarded function.  */\n+  if (!DECL_WEAK (fndecl) || HAVE_COMDAT_GROUP)\n+    {\n+      TREE_PUBLIC (fn) = false;\n+      DECL_EXTERNAL (fn) = false;\n+      DECL_WEAK (fn) = false;\n+      DECL_COMDAT (fn) = false;\n+\n+      /* We haven't set the comdat group on the guarded function yet, we'll add\n+\t this to the same group in comdat_linkage later.  */\n+      gcc_assert (!DECL_ONE_ONLY (fndecl));\n+\n+      DECL_INTERFACE_KNOWN (fn) = true;\n+    }\n+\n+  DECL_ARTIFICIAL (fn) = true;\n+\n+  /* Update various inline related declaration properties.  */\n+  //DECL_DECLARED_INLINE_P (fn) = true;\n+  DECL_DISREGARD_INLINE_LIMITS (fn) = true;\n+  TREE_NO_WARNING (fn) = 1;\n+\n+  return fn;\n+}\n+\n+/* Return true if CONTRACT is checked or assumed under the current build\n+   configuration. */\n+\n+bool\n+contract_active_p (tree contract)\n+{\n+  return get_contract_semantic (contract) != CCS_IGNORE;\n+}\n+\n+static bool\n+has_active_contract_condition (tree d, tree_code c)\n+{\n+  for (tree as = DECL_CONTRACTS (d) ; as != NULL_TREE; as = TREE_CHAIN (as))\n+    {\n+      tree contract = TREE_VALUE (TREE_VALUE (as));\n+      if (TREE_CODE (contract) == c && contract_active_p (contract))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* True if D has any checked or assumed preconditions.  */\n+\n+static bool\n+has_active_preconditions (tree d)\n+{\n+  return has_active_contract_condition (d, PRECONDITION_STMT);\n+}\n+\n+/* True if D has any checked or assumed postconditions.  */\n+\n+static bool\n+has_active_postconditions (tree d)\n+{\n+  return has_active_contract_condition (d, POSTCONDITION_STMT);\n+}\n+\n+/* Return true if any contract in the CONTRACT list is checked or assumed\n+   under the current build configuration. */\n+\n+bool\n+contract_any_active_p (tree contract)\n+{\n+  for (; contract != NULL_TREE; contract = CONTRACT_CHAIN (contract))\n+    if (contract_active_p (TREE_VALUE (TREE_VALUE (contract))))\n+      return true;\n+  return false;\n+}\n+\n+/* Do we need to mess with contracts for DECL1?  */\n+\n+static bool\n+handle_contracts_p (tree decl1)\n+{\n+  return (flag_contracts\n+\t  && !processing_template_decl\n+\t  && DECL_ABSTRACT_ORIGIN (decl1) == NULL_TREE\n+\t  && contract_any_active_p (DECL_CONTRACTS (decl1)));\n+}\n+\n+/* Should we break out DECL1's pre/post contracts into separate functions?\n+   FIXME I'd like this to default to 0, but that will need an overhaul to the\n+   return identifier handling to just refer to the RESULT_DECL.  */\n+\n+static bool\n+outline_contracts_p (tree decl1)\n+{\n+  return (!DECL_CONSTRUCTOR_P (decl1)\n+\t  && !DECL_DESTRUCTOR_P (decl1));\n+}\n+\n+/* Build the precondition checking function for D.  */\n+\n+static tree\n+build_precondition_function (tree d)\n+{\n+  if (!has_active_preconditions (d))\n+    return NULL_TREE;\n+\n+  return build_contract_condition_function (d, /*pre=*/true);\n+}\n+\n+/* Build the postcondition checking function for D. If the return\n+   type is undeduced, don't build the function yet. We do that in\n+   apply_deduced_return_type.  */\n+\n+static tree\n+build_postcondition_function (tree d)\n+{\n+  if (!has_active_postconditions (d))\n+    return NULL_TREE;\n+\n+  tree type = TREE_TYPE (TREE_TYPE (d));\n+  if (is_auto (type))\n+    return NULL_TREE;\n+\n+  return build_contract_condition_function (d, /*pre=*/false);\n+}\n+\n+static void\n+build_contract_function_decls (tree d)\n+{\n+  /* Constructors and destructors have their contracts inserted inline.  */\n+  if (!outline_contracts_p (d))\n+    return;\n+\n+  /* Build the pre/post functions (or not).  */\n+  tree pre = build_precondition_function (d);\n+  tree post = build_postcondition_function (d);\n+  set_contract_functions (d, pre, post);\n+}\n+\n+static const char *\n+get_contract_level_name (tree contract)\n+{\n+  if (CONTRACT_LITERAL_MODE_P (contract))\n+    return \"\";\n+  if (tree mode = CONTRACT_MODE (contract))\n+    if (tree level = TREE_VALUE (mode))\n+      return IDENTIFIER_POINTER (level);\n+  return \"default\";\n+}\n+\n+static const char *\n+get_contract_role_name (tree contract)\n+{\n+  if (CONTRACT_LITERAL_MODE_P (contract))\n+    return \"\";\n+  if (tree mode = CONTRACT_MODE (contract))\n+    if (tree role = TREE_PURPOSE (mode))\n+      return IDENTIFIER_POINTER (role);\n+  return \"default\";\n+}\n+\n+/* Build a layout-compatible internal version of std::contract_violation.  */\n+\n+static tree\n+get_pseudo_contract_violation_type ()\n+{\n+  if (!pseudo_contract_violation_type)\n+    {\n+      /* Must match <contract>:\n+\t class contract_violation {\n+\t   const char* _M_file;\n+\t   const char* _M_function;\n+\t   const char* _M_comment;\n+\t   const char* _M_level;\n+\t   const char* _M_role;\n+\t   uint_least32_t _M_line;\n+\t   signed char _M_continue;\n+\t If this changes, also update the initializer in\n+\t build_contract_violation.  */\n+      const tree types[] = { const_string_type_node,\n+\t\t\t     const_string_type_node,\n+\t\t\t     const_string_type_node,\n+\t\t\t     const_string_type_node,\n+\t\t\t     const_string_type_node,\n+\t\t\t     uint_least32_type_node,\n+\t\t\t     signed_char_type_node };\n+      tree fields = NULL_TREE;\n+      for (tree type : types)\n+\t{\n+\t  /* finish_builtin_struct wants fieldss chained in reverse.  */\n+\t  tree next = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n+\t\t\t\t  NULL_TREE, type);\n+\t  DECL_CHAIN (next) = fields;\n+\t  fields = next;\n+\t}\n+      iloc_sentinel ils (input_location);\n+      input_location = BUILTINS_LOCATION;\n+      pseudo_contract_violation_type = make_class_type (RECORD_TYPE);\n+      finish_builtin_struct (pseudo_contract_violation_type,\n+\t\t\t     \"__pseudo_contract_violation\",\n+\t\t\t     fields, NULL_TREE);\n+      CLASSTYPE_AS_BASE (pseudo_contract_violation_type)\n+\t= pseudo_contract_violation_type;\n+      DECL_CONTEXT (TYPE_NAME (pseudo_contract_violation_type))\n+\t= FROB_CONTEXT (global_namespace);\n+      TREE_PUBLIC (TYPE_NAME (pseudo_contract_violation_type)) = true;\n+      CLASSTYPE_LITERAL_P (pseudo_contract_violation_type) = true;\n+      CLASSTYPE_LAZY_COPY_CTOR (pseudo_contract_violation_type) = true;\n+      xref_basetypes (pseudo_contract_violation_type, /*bases=*/NULL_TREE);\n+      pseudo_contract_violation_type\n+\t= cp_build_qualified_type (pseudo_contract_violation_type,\n+\t\t\t\t   TYPE_QUAL_CONST);\n+    }\n+  return pseudo_contract_violation_type;\n+}\n+\n+/* Return a VAR_DECL to pass to handle_contract_violation.  */\n+\n+static tree\n+build_contract_violation (tree contract, contract_continuation cmode)\n+{\n+  expanded_location loc = expand_location (EXPR_LOCATION (contract));\n+  const char *function = fndecl_name (DECL_ORIGIN (current_function_decl));\n+  const char *level = get_contract_level_name (contract);\n+  const char *role = get_contract_role_name (contract);\n+\n+  /* Must match the type layout in get_pseudo_contract_violation_type.  */\n+  tree ctor = build_constructor_va\n+    (init_list_type_node, 7,\n+     NULL_TREE, build_string_literal (loc.file),\n+     NULL_TREE, build_string_literal (function),\n+     NULL_TREE, CONTRACT_COMMENT (contract),\n+     NULL_TREE, build_string_literal (level),\n+     NULL_TREE, build_string_literal (role),\n+     NULL_TREE, build_int_cst (uint_least32_type_node, loc.line),\n+     NULL_TREE, build_int_cst (signed_char_type_node, cmode));\n+\n+  ctor = finish_compound_literal (get_pseudo_contract_violation_type (),\n+\t\t\t\t  ctor, tf_none);\n+  protected_set_expr_location (ctor, EXPR_LOCATION (contract));\n+  return ctor;\n+}\n+\n+/* Return handle_contract_violation(), declaring it if needed.  */\n+\n+static tree\n+declare_handle_contract_violation ()\n+{\n+  tree fnname = get_identifier (\"handle_contract_violation\");\n+  tree viol_name = get_identifier (\"contract_violation\");\n+  tree l = lookup_qualified_name (global_namespace, fnname,\n+\t\t\t\t  LOOK_want::HIDDEN_FRIEND);\n+  for (tree f: lkp_range (l))\n+    if (TREE_CODE (f) == FUNCTION_DECL)\n+\t{\n+\t  tree parms = TYPE_ARG_TYPES (TREE_TYPE (f));\n+\t  if (remaining_arguments (parms) != 1)\n+\t    continue;\n+\t  tree parmtype = non_reference (TREE_VALUE (parms));\n+\t  if (CLASS_TYPE_P (parmtype)\n+\t      && TYPE_IDENTIFIER (parmtype) == viol_name)\n+\t    return f;\n+\t}\n+\n+  tree id_exp = get_identifier (\"experimental\");\n+  tree ns_exp = lookup_qualified_name (std_node, id_exp);\n+\n+  tree violation = error_mark_node;\n+  if (TREE_CODE (ns_exp) == NAMESPACE_DECL)\n+    violation = lookup_qualified_name (ns_exp, viol_name,\n+\t\t\t\t       LOOK_want::TYPE\n+\t\t\t\t       |LOOK_want::HIDDEN_FRIEND);\n+\n+  if (TREE_CODE (violation) == TYPE_DECL)\n+    violation = TREE_TYPE (violation);\n+  else\n+    {\n+      push_nested_namespace (std_node);\n+      push_namespace (id_exp, /*inline*/false);\n+      violation = make_class_type (RECORD_TYPE);\n+      create_implicit_typedef (viol_name, violation);\n+      DECL_SOURCE_LOCATION (TYPE_NAME (violation)) = BUILTINS_LOCATION;\n+      DECL_CONTEXT (TYPE_NAME (violation)) = current_namespace;\n+      pushdecl_namespace_level (TYPE_NAME (violation), /*hidden*/true);\n+      pop_namespace ();\n+      pop_nested_namespace (std_node);\n+    }\n+\n+  tree argtype = cp_build_qualified_type (violation, TYPE_QUAL_CONST);\n+  argtype = cp_build_reference_type (argtype, /*rval*/false);\n+  tree fntype = build_function_type_list (void_type_node, argtype, NULL_TREE);\n+\n+  push_nested_namespace (global_namespace);\n+  tree fn = build_cp_library_fn_ptr (\"handle_contract_violation\", fntype,\n+\t\t\t\t     ECF_COLD);\n+  pushdecl_namespace_level (fn, /*hiding*/true);\n+  pop_nested_namespace (global_namespace);\n+\n+  return fn;\n+}\n+\n+/* Build the call to handle_contract_violation for CONTRACT.  */\n+\n+static void\n+build_contract_handler_call (tree contract,\n+\t\t\t     contract_continuation cmode)\n+{\n+  tree violation = build_contract_violation (contract, cmode);\n+  tree violation_fn = declare_handle_contract_violation ();\n+  tree call = build_call_n (violation_fn, 1, build_address (violation));\n+  finish_expr_stmt (call);\n+}\n+\n+/* Generate the code that checks or assumes a contract, but do not attach\n+   it to the current context.  This is called during genericization.  */\n+\n+tree\n+build_contract_check (tree contract)\n+{\n+  contract_semantic semantic = get_contract_semantic (contract);\n+  if (semantic == CCS_INVALID)\n+    return NULL_TREE;\n+\n+  /* Ignored contracts are never checked or assumed.  */\n+  if (semantic == CCS_IGNORE)\n+    return void_node;\n+\n+  remap_dummy_this (current_function_decl, &CONTRACT_CONDITION (contract));\n+  tree condition = CONTRACT_CONDITION (contract);\n+  if (condition == error_mark_node)\n+    return NULL_TREE;\n+\n+  location_t loc = EXPR_LOCATION (contract);\n+\n+  if (semantic == CCS_ASSUME)\n+    return build_assume_call (loc, condition);\n+\n+  tree if_stmt = begin_if_stmt ();\n+  tree cond = build_x_unary_op (loc,\n+\t\t\t\tTRUTH_NOT_EXPR,\n+\t\t\t\tcondition, NULL_TREE,\n+\t\t\t\ttf_warning_or_error);\n+  finish_if_stmt_cond (cond, if_stmt);\n+\n+  /* Get the continuation mode.  */\n+  contract_continuation cmode;\n+  switch (semantic)\n+    {\n+    case CCS_NEVER: cmode = NEVER_CONTINUE; break;\n+    case CCS_MAYBE: cmode = MAYBE_CONTINUE; break;\n+    default: gcc_unreachable ();\n+    }\n+\n+  build_contract_handler_call (contract, cmode);\n+  if (cmode == NEVER_CONTINUE)\n+    finish_expr_stmt (build_call_a (terminate_fn, 0, nullptr));\n+\n+  finish_then_clause (if_stmt);\n+  tree scope = IF_SCOPE (if_stmt);\n+  IF_SCOPE (if_stmt) = NULL;\n+  return do_poplevel (scope);\n+}\n+\n+/* Add the contract statement CONTRACT to the current block if valid.  */\n+\n+static void\n+emit_contract_statement (tree contract)\n+{\n+  /* Only add valid contracts.  */\n+  if (get_contract_semantic (contract) != CCS_INVALID\n+      && CONTRACT_CONDITION (contract) != error_mark_node)\n+    add_stmt (contract);\n+}\n+\n+/* Generate the statement for the given contract attribute by adding the\n+   statement to the current block. Returns the next contract in the chain.  */\n+\n+static tree\n+emit_contract_attr (tree attr)\n+{\n+  gcc_assert (TREE_CODE (attr) == TREE_LIST);\n+\n+  emit_contract_statement (CONTRACT_STATEMENT (attr));\n+\n+  return CONTRACT_CHAIN (attr);\n+}\n+\n+/* Add the statements of contract attributes ATTRS to the current block.  */\n+\n+static void\n+emit_contract_conditions (tree attrs, tree_code code)\n+{\n+  if (!attrs) return;\n+  gcc_assert (TREE_CODE (attrs) == TREE_LIST);\n+  gcc_assert (code == PRECONDITION_STMT || code == POSTCONDITION_STMT);\n+  while (attrs)\n+    {\n+      tree contract = CONTRACT_STATEMENT (attrs);\n+      if (TREE_CODE (contract) == code)\n+\tattrs = emit_contract_attr (attrs);\n+      else\n+\tattrs = CONTRACT_CHAIN (attrs);\n+    }\n+}\n+\n+/* Emit the statement for an assertion attribute.  */\n+\n+void\n+emit_assertion (tree attr)\n+{\n+  emit_contract_attr (attr);\n+}\n+\n+/* Emit statements for precondition attributes.  */\n+\n+static void\n+emit_preconditions (tree attr)\n+{\n+  return emit_contract_conditions (attr, PRECONDITION_STMT);\n+}\n+\n+/* Emit statements for postcondition attributes.  */\n+\n+static void\n+emit_postconditions_cleanup (tree contracts)\n+{\n+  tree stmts = push_stmt_list ();\n+  emit_contract_conditions (contracts, POSTCONDITION_STMT);\n+  stmts = pop_stmt_list (stmts);\n+  push_cleanup (NULL_TREE, stmts, /*eh_only*/false);\n+}\n+\n+/* We're compiling the pre/postcondition function CONDFN; remap any FN\n+   attributes that match CODE and emit them.  */\n+\n+static void\n+remap_and_emit_conditions (tree fn, tree condfn, tree_code code)\n+{\n+  gcc_assert (code == PRECONDITION_STMT || code == POSTCONDITION_STMT);\n+  for (tree attr = DECL_CONTRACTS (fn); attr;\n+       attr = CONTRACT_CHAIN (attr))\n+    {\n+      tree contract = CONTRACT_STATEMENT (attr);\n+      if (TREE_CODE (contract) == code)\n+\t{\n+\t  contract = copy_node (contract);\n+\t  remap_contract (fn, condfn, contract, /*duplicate_p=*/false);\n+\t  emit_contract_statement (contract);\n+\t}\n+    }\n+}\n+\n+/* Converts a contract condition to bool and ensures it has a locaiton.  */\n+\n+tree\n+finish_contract_condition (cp_expr condition)\n+{\n+  /* Ensure we have the condition location saved in case we later need to\n+     emit a conversion error during template instantiation and wouldn't\n+     otherwise have it.  */\n+  if (!CAN_HAVE_LOCATION_P (condition) || EXCEPTIONAL_CLASS_P (condition))\n+    {\n+      condition = build1_loc (condition.get_location (), VIEW_CONVERT_EXPR,\n+\t\t\t      TREE_TYPE (condition), condition);\n+      EXPR_LOCATION_WRAPPER_P (condition) = 1;\n+    }\n+\n+  if (condition == error_mark_node || type_dependent_expression_p (condition))\n+    return condition;\n+\n+  return condition_conversion (condition);\n+}\n+\n+void\n+maybe_update_postconditions (tree fco)\n+{\n+  /* Update any postconditions and the postcondition checking function\n+     as needed.  If there are postconditions, we'll use those to rewrite\n+     return statements to check postconditions.  */\n+  if (has_active_postconditions (fco))\n+    {\n+      rebuild_postconditions (fco);\n+      tree post = build_postcondition_function (fco);\n+      set_postcondition_function (fco, post);\n+    }\n+}\n+\n+/* Called on attribute lists that must not contain contracts.  If any\n+   contracts are present, issue an error diagnostic and return true.  */\n+\n+bool\n+diagnose_misapplied_contracts (tree attributes)\n+{\n+  if (attributes == NULL_TREE)\n+    return false;\n+\n+  tree contract_attr = find_contract (attributes);\n+  if (!contract_attr)\n+    return false;\n+\n+  error_at (EXPR_LOCATION (CONTRACT_STATEMENT (contract_attr)),\n+\t    \"contracts must appertain to a function type\");\n+\n+  /* Invalidate the contract so we don't treat it as valid later on.  */\n+  invalidate_contract (TREE_VALUE (TREE_VALUE (contract_attr)));\n+\n+  return true;\n+}\n+\n+/* Build and return an argument list containing all the parameters of the\n+   (presumably guarded) FUNCTION_DECL FN.  This can be used to forward all of\n+   FN's arguments to a function taking the same list of arguments -- namely\n+   the unchecked form of FN.\n+\n+   We use CALL_FROM_THUNK_P instead of forward_parm for forwarding\n+   semantics.  */\n+\n+static vec<tree, va_gc> *\n+build_arg_list (tree fn)\n+{\n+  vec<tree, va_gc> *args = make_tree_vector ();\n+  for (tree t = DECL_ARGUMENTS (fn); t; t = DECL_CHAIN (t))\n+    vec_safe_push (args, t);\n+  return args;\n+}\n+\n+void\n+start_function_contracts (tree decl1)\n+{\n+  if (!handle_contracts_p (decl1))\n+    return;\n+\n+  if (!outline_contracts_p (decl1))\n+    {\n+      emit_preconditions (DECL_CONTRACTS (current_function_decl));\n+      emit_postconditions_cleanup (DECL_CONTRACTS (current_function_decl));\n+      return;\n+    }\n+\n+  /* Contracts may have just been added without a chance to parse them, though\n+     we still need the PRE_FN available to generate a call to it.  */\n+  if (!DECL_PRE_FN (decl1))\n+    build_contract_function_decls (decl1);\n+\n+  /* If we're starting a guarded function with valid contracts, we need to\n+     insert a call to the pre function.  */\n+  if (DECL_PRE_FN (decl1)\n+      && DECL_PRE_FN (decl1) != error_mark_node)\n+    {\n+      releasing_vec args = build_arg_list (decl1);\n+      tree call = build_call_a (DECL_PRE_FN (decl1),\n+\t\t\t\targs->length (),\n+\t\t\t\targs->address ());\n+      CALL_FROM_THUNK_P (call) = true;\n+      finish_expr_stmt (call);\n+    }\n+}\n+\n+/* Finish up the pre & post function definitions for a guarded FNDECL,\n+   and compile those functions all the way to assembler language output.  */\n+\n+void\n+finish_function_contracts (tree fndecl)\n+{\n+  if (!handle_contracts_p (fndecl)\n+      || !outline_contracts_p (fndecl))\n+    return;\n+\n+  for (tree ca = DECL_CONTRACTS (fndecl); ca; ca = CONTRACT_CHAIN (ca))\n+    {\n+      tree contract = CONTRACT_STATEMENT (ca);\n+      if (!CONTRACT_CONDITION (contract)\n+\t  || CONTRACT_CONDITION_DEFERRED_P (contract)\n+\t  || CONTRACT_CONDITION (contract) == error_mark_node)\n+\treturn;\n+    }\n+\n+  int flags = SF_DEFAULT | SF_PRE_PARSED;\n+\n+  /* If either the pre or post functions are bad, don't bother emitting\n+     any contracts.  The program is already ill-formed.  */\n+  tree pre = DECL_PRE_FN (fndecl);\n+  tree post = DECL_POST_FN (fndecl);\n+  if (pre == error_mark_node || post == error_mark_node)\n+    return;\n+\n+  if (pre && DECL_INITIAL (fndecl) != error_mark_node)\n+    {\n+      DECL_PENDING_INLINE_P (pre) = false;\n+      start_preparsed_function (pre, DECL_ATTRIBUTES (pre), flags);\n+      remap_and_emit_conditions (fndecl, pre, PRECONDITION_STMT);\n+      tree finished_pre = finish_function (false);\n+      expand_or_defer_fn (finished_pre);\n+    }\n+\n+  if (post && DECL_INITIAL (fndecl) != error_mark_node)\n+    {\n+      DECL_PENDING_INLINE_P (post) = false;\n+      start_preparsed_function (post,\n+\t\t\t\tDECL_ATTRIBUTES (post),\n+\t\t\t\tflags);\n+      remap_and_emit_conditions (fndecl, post, POSTCONDITION_STMT);\n+      if (!VOID_TYPE_P (TREE_TYPE (TREE_TYPE (post))))\n+\tfinish_return_stmt (get_postcondition_result_parameter (fndecl));\n+\n+      tree finished_post = finish_function (false);\n+      expand_or_defer_fn (finished_post);\n+    }\n+}\n+\n+/* Rewrite the expression of a returned expression so that it invokes the\n+   postcondition function as needed.  */\n+\n+tree\n+apply_postcondition_to_return (tree expr)\n+{\n+  tree fn = current_function_decl;\n+  tree post = DECL_POST_FN (fn);\n+  if (!post)\n+    return NULL_TREE;\n+\n+  /* If FN returns in memory, POST has a void return type and we call it when\n+     EXPR is DECL_RESULT (fn).  If FN returns a scalar, POST has the same\n+     return type and we call it when EXPR is the value being returned.  */\n+  if (VOID_TYPE_P (TREE_TYPE (TREE_TYPE (post)))\n+      != (expr == DECL_RESULT (fn)))\n+    return NULL_TREE;\n+\n+  releasing_vec args = build_arg_list (fn);\n+  if (get_postcondition_result_parameter (fn))\n+    vec_safe_push (args, expr);\n+  tree call = build_call_a (post,\n+\t\t\t    args->length (),\n+\t\t\t    args->address ());\n+  CALL_FROM_THUNK_P (call) = true;\n+\n+  return call;\n+}\n+\n+/* A subroutine of duplicate_decls. Diagnose issues in the redeclaration of\n+   guarded functions.  */\n+\n+void\n+duplicate_contracts (tree newdecl, tree olddecl)\n+{\n+  if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n+    newdecl = DECL_TEMPLATE_RESULT (newdecl);\n+  if (TREE_CODE (olddecl) == TEMPLATE_DECL)\n+    olddecl = DECL_TEMPLATE_RESULT (olddecl);\n+\n+  /* Compare contracts to see if they match.    */\n+  tree old_contracts = DECL_CONTRACTS (olddecl);\n+  tree new_contracts = DECL_CONTRACTS (newdecl);\n+\n+  if (!old_contracts && !new_contracts)\n+    return;\n+\n+  location_t old_loc = DECL_SOURCE_LOCATION (olddecl);\n+  location_t new_loc = DECL_SOURCE_LOCATION (newdecl);\n+\n+  /* If both declarations specify contracts, ensure they match.\n+\n+     TODO: This handles a potential error a little oddly. Consider:\n+\n+\tstruct B {\n+\t  virtual void f(int n) [[pre: n == 0]];\n+\t};\n+\tstruct D : B {\n+\t  void f(int n) override; // inherits contracts\n+\t};\n+\tvoid D::f(int n) [[pre: n == 0]] // OK\n+\t{ }\n+\n+    It's okay because we're explicitly restating the inherited contract.\n+    Changing the precondition on the definition D::f causes match_contracts\n+    to complain about the mismatch.\n+\n+    This would previously have been diagnosed as adding contracts to an\n+    override, but this seems like it should be well-formed.  */\n+  if (old_contracts && new_contracts)\n+    {\n+      if (!match_contract_conditions (old_loc, old_contracts,\n+\t\t\t\t      new_loc, new_contracts,\n+\t\t\t\t      cmc_declaration))\n+\treturn;\n+      if (DECL_UNIQUE_FRIEND_P (newdecl))\n+\t/* Newdecl's contracts are still DEFERRED_PARSE, and we're about to\n+\t   collapse it into olddecl, so stash away olddecl's contracts for\n+\t   later comparison.  */\n+\tdefer_guarded_contract_match (olddecl, olddecl, old_contracts);\n+    }\n+\n+  /* Handle cases where contracts are omitted in one or the other\n+     declaration.  */\n+  if (old_contracts)\n+    {\n+      /* Contracts have been previously specified by are no omitted. The\n+\t new declaration inherits the existing contracts. */\n+      if (!new_contracts)\n+\tcopy_contract_attributes (newdecl, olddecl);\n+\n+      /* In all cases, remove existing contracts from OLDDECL to prevent the\n+\t attribute merging function from adding excess contracts.  */\n+      remove_contract_attributes (olddecl);\n+    }\n+  else if (!old_contracts)\n+    {\n+      /* We are adding contracts to a declaration.  */\n+      if (new_contracts)\n+\t{\n+\t  /* We can't add to a previously defined function.  */\n+\t  if (DECL_INITIAL (olddecl))\n+\t    {\n+\t      auto_diagnostic_group d;\n+\t      error_at (new_loc, \"cannot add contracts after definition\");\n+\t      inform (DECL_SOURCE_LOCATION (olddecl), \"original definition here\");\n+\t      return;\n+\t    }\n+\n+\t  /* We can't add to an unguarded virtual function declaration.  */\n+\t  if (DECL_VIRTUAL_P (olddecl) && new_contracts)\n+\t    {\n+\t      auto_diagnostic_group d;\n+\t      error_at (new_loc, \"cannot add contracts to a virtual function\");\n+\t      inform (DECL_SOURCE_LOCATION (olddecl), \"original declaration here\");\n+\t      return;\n+\t    }\n+\n+\t  /* Depending on the \"first declaration\" rule, we may not be able\n+\t     to add contracts to a function after the fact.  */\n+\t  if (flag_contract_strict_declarations)\n+\t    {\n+\t      warning_at (new_loc,\n+\t\t\t  OPT_fcontract_strict_declarations_,\n+\t\t\t  \"declaration adds contracts to %q#D\",\n+\t\t\t  olddecl);\n+\t      return;\n+\t    }\n+\n+\t  /* Copy the contracts from NEWDECL to OLDDECL. We shouldn't need to\n+\t     remap them because NEWDECL's parameters will replace those of\n+\t     OLDDECL.  Remove the contracts from NEWDECL so they aren't\n+\t     cloned when merging.  */\n+\t  copy_contract_attributes (olddecl, newdecl);\n+\t  remove_contract_attributes (newdecl);\n+\t}\n+    }\n+}\n+\n+/* Replace the any contract attributes on OVERRIDER with a copy where any\n+   references to BASEFN's PARM_DECLs have been rewritten to the corresponding\n+   PARM_DECL in OVERRIDER.  */\n+\n+void\n+inherit_base_contracts (tree overrider, tree basefn)\n+{\n+  tree last = NULL_TREE, contract_attrs = NULL_TREE;\n+  for (tree a = DECL_CONTRACTS (basefn);\n+      a != NULL_TREE;\n+      a = CONTRACT_CHAIN (a))\n+    {\n+      tree c = copy_node (a);\n+      TREE_VALUE (c) = build_tree_list (TREE_PURPOSE (TREE_VALUE (c)),\n+\t\t\t\t\tcopy_node (CONTRACT_STATEMENT (c)));\n+\n+      tree src = basefn;\n+      tree dst = overrider;\n+      remap_contract (src, dst, CONTRACT_STATEMENT (c), /*duplicate_p=*/true);\n+\n+      CONTRACT_COMMENT (CONTRACT_STATEMENT (c)) =\n+\tcopy_node (CONTRACT_COMMENT (CONTRACT_STATEMENT (c)));\n+\n+      chainon (last, c);\n+      last = c;\n+      if (!contract_attrs)\n+\tcontract_attrs = c;\n+    }\n+\n+  set_decl_contracts (overrider, contract_attrs);\n+}\n+\n+#include \"gt-cp-contracts.h\""}, {"sha": "4050a38708b46f26a78e2a066d19bde50fe630e7", "filename": "gcc/cp/contracts.h", "status": "added", "additions": 305, "deletions": 0, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fcontracts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fcontracts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcontracts.h?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,305 @@\n+/* Definitions for C++ contract levels.  Implements functionality described in\n+   the N4820 working draft version of contracts, P1290, P1332, and P1429.\n+   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+   Contributed by Jeff Chapman II (jchapman@lock3software.com)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_CP_CONTRACT_H\n+#define GCC_CP_CONTRACT_H\n+\n+/* Contract levels approximate the complexity of the expression.  */\n+\n+enum contract_level\n+{\n+  CONTRACT_INVALID,\n+  CONTRACT_DEFAULT,\n+  CONTRACT_AUDIT,\n+  CONTRACT_AXIOM\n+};\n+\n+/* The concrete semantics determine the behavior of a contract.  */\n+\n+enum contract_semantic\n+{\n+  CCS_INVALID,\n+  CCS_IGNORE,\n+  CCS_ASSUME,\n+  CCS_NEVER,\n+  CCS_MAYBE\n+};\n+\n+/* True if the contract is unchecked.  */\n+\n+inline bool\n+unchecked_contract_p (contract_semantic cs)\n+{\n+  return cs == CCS_IGNORE || cs == CCS_ASSUME;\n+}\n+\n+/* True if the contract is checked.  */\n+\n+inline bool\n+checked_contract_p (contract_semantic cs)\n+{\n+  return cs >= CCS_NEVER;\n+}\n+\n+/* Must match std::contract_violation_continuation_mode in <contract>.  */\n+enum contract_continuation\n+{\n+  NEVER_CONTINUE,\n+  MAYBE_CONTINUE\n+};\n+\n+/* Assertion role info.  */\n+struct contract_role\n+{\n+  const char *name;\n+  contract_semantic default_semantic;\n+  contract_semantic audit_semantic;\n+  contract_semantic axiom_semantic;\n+};\n+\n+/* Information for configured contract semantics.  */\n+\n+struct contract_configuration\n+{\n+  contract_level level;\n+  contract_role* role;\n+};\n+\n+/* A contract mode contains information used to derive the checking\n+   and assumption semantics of a contract. This is either a dynamic\n+   configuration, meaning it derives from the build mode, or it is\n+   explicitly specified.  */\n+\n+struct contract_mode\n+{\n+  contract_mode () : kind(cm_invalid) {}\n+  contract_mode (contract_level level, contract_role *role = NULL)\n+    : kind(cm_dynamic)\n+  {\n+    contract_configuration cc;\n+    cc.level = level;\n+    cc.role = role;\n+    u.config = cc;\n+  }\n+  contract_mode (contract_semantic semantic) : kind(cm_explicit)\n+  {\n+    u.semantic = semantic;\n+  }\n+\n+  contract_level get_level () const\n+  {\n+    gcc_assert (kind == cm_dynamic);\n+    return u.config.level;\n+  }\n+\n+  contract_role *get_role () const\n+  {\n+    gcc_assert (kind == cm_dynamic);\n+    return u.config.role;\n+  }\n+\n+  contract_semantic get_semantic () const\n+  {\n+    gcc_assert (kind == cm_explicit);\n+    return u.semantic;\n+  }\n+\n+  enum { cm_invalid, cm_dynamic, cm_explicit } kind;\n+\n+  union\n+  {\n+    contract_configuration config;\n+    contract_semantic semantic;\n+  } u;\n+};\n+\n+extern contract_role *get_contract_role\t(const char *);\n+extern contract_role *add_contract_role\t(const char *,\n+\t\t\t\t\t contract_semantic,\n+\t\t\t\t\t contract_semantic,\n+\t\t\t\t\t contract_semantic,\n+\t\t\t\t\t bool = true);\n+extern void validate_contract_role\t(contract_role *);\n+extern void setup_default_contract_role\t(bool = true);\n+extern contract_semantic lookup_concrete_semantic (const char *);\n+\n+/* Map a source level semantic or level name to its value, or invalid.  */\n+extern contract_semantic map_contract_semantic\t(const char *);\n+extern contract_level map_contract_level\t(const char *);\n+\n+/* Check if an attribute is a cxx contract attribute.  */\n+extern bool cxx_contract_attribute_p (const_tree);\n+extern bool cp_contract_assertion_p (const_tree);\n+\n+/* Returns the default role.  */\n+\n+inline contract_role *\n+get_default_contract_role ()\n+{\n+  return get_contract_role (\"default\");\n+}\n+\n+/* Handle various command line arguments related to semantic mapping.  */\n+extern void handle_OPT_fcontract_build_level_ (const char *);\n+extern void handle_OPT_fcontract_assumption_mode_ (const char *);\n+extern void handle_OPT_fcontract_continuation_mode_ (const char *);\n+extern void handle_OPT_fcontract_role_ (const char *);\n+extern void handle_OPT_fcontract_semantic_ (const char *);\n+\n+enum contract_matching_context\n+{\n+  cmc_declaration,\n+  cmc_override\n+};\n+\n+/* True if NODE is any kind of contract.  */\n+#define CONTRACT_P(NODE)\t\t\t\\\n+  (TREE_CODE (NODE) == ASSERTION_STMT\t\t\\\n+   || TREE_CODE (NODE) == PRECONDITION_STMT\t\\\n+   || TREE_CODE (NODE) == POSTCONDITION_STMT)\n+\n+/* True if NODE is a contract condition.  */\n+#define CONTRACT_CONDITION_P(NODE)\t\t\\\n+  (TREE_CODE (NODE) == PRECONDITION_STMT\t\\\n+   || TREE_CODE (NODE) == POSTCONDITION_STMT)\n+\n+/* True if NODE is a precondition.  */\n+#define PRECONDITION_P(NODE)           \\\n+  (TREE_CODE (NODE) == PRECONDITION_STMT)\n+\n+/* True if NODE is a postcondition.  */\n+#define POSTCONDITION_P(NODE)          \\\n+  (TREE_CODE (NODE) == POSTCONDITION_STMT)\n+\n+#define CONTRACT_CHECK(NODE) \\\n+  (TREE_CHECK3 (NODE, ASSERTION_STMT, PRECONDITION_STMT, POSTCONDITION_STMT))\n+\n+/* True iff the FUNCTION_DECL NODE currently has any contracts.  */\n+#define DECL_HAS_CONTRACTS_P(NODE) \\\n+  (DECL_CONTRACTS (NODE) != NULL_TREE)\n+\n+/* For a FUNCTION_DECL of a guarded function, this points to a list of the pre\n+   and post contracts of the first decl of NODE in original order. */\n+#define DECL_CONTRACTS(NODE) \\\n+  (find_contract (DECL_ATTRIBUTES (NODE)))\n+\n+/* The next contract (if any) after this one in an attribute list.  */\n+#define CONTRACT_CHAIN(NODE) \\\n+  (find_contract (TREE_CHAIN (NODE)))\n+\n+/* The wrapper of the original source location of a list of contracts.  */\n+#define CONTRACT_SOURCE_LOCATION_WRAPPER(NODE) \\\n+  (TREE_PURPOSE (TREE_VALUE (NODE)))\n+\n+/* The original source location of a list of contracts.  */\n+#define CONTRACT_SOURCE_LOCATION(NODE) \\\n+  (EXPR_LOCATION (CONTRACT_SOURCE_LOCATION_WRAPPER (NODE)))\n+\n+/* The actual code _STMT for a contract attribute.  */\n+#define CONTRACT_STATEMENT(NODE) \\\n+  (TREE_VALUE (TREE_VALUE (NODE)))\n+\n+/* True if the contract semantic was specified literally. If true, the\n+   contract mode is an identifier containing the semantic. Otherwise,\n+   it is a TREE_LIST whose TREE_VALUE is the level and whose TREE_PURPOSE\n+   is the role.  */\n+#define CONTRACT_LITERAL_MODE_P(NODE) \\\n+  (CONTRACT_MODE (NODE) != NULL_TREE \\\n+   && TREE_CODE (CONTRACT_MODE (NODE)) == IDENTIFIER_NODE)\n+\n+/* The identifier denoting the literal semantic of the contract.  */\n+#define CONTRACT_LITERAL_SEMANTIC(NODE) \\\n+  (TREE_OPERAND (NODE, 0))\n+\n+/* The written \"mode\" of the contract. Either an IDENTIFIER with the\n+   literal semantic or a TREE_LIST containing the level and role.  */\n+#define CONTRACT_MODE(NODE) \\\n+  (TREE_OPERAND (CONTRACT_CHECK (NODE), 0))\n+\n+/* The identifier denoting the build level of the contract. */\n+#define CONTRACT_LEVEL(NODE)\t\t\\\n+  (TREE_VALUE (CONTRACT_MODE (NODE)))\n+\n+/* The identifier denoting the role of the contract */\n+#define CONTRACT_ROLE(NODE)\t\t\\\n+  (TREE_PURPOSE (CONTRACT_MODE (NODE)))\n+\n+/* The parsed condition of the contract.  */\n+#define CONTRACT_CONDITION(NODE) \\\n+  (TREE_OPERAND (CONTRACT_CHECK (NODE), 1))\n+\n+/* True iff the condition of the contract NODE is not yet parsed.  */\n+#define CONTRACT_CONDITION_DEFERRED_P(NODE) \\\n+  (TREE_CODE (CONTRACT_CONDITION (NODE)) == DEFERRED_PARSE)\n+\n+/* The raw comment of the contract.  */\n+#define CONTRACT_COMMENT(NODE) \\\n+  (TREE_OPERAND (CONTRACT_CHECK (NODE), 2))\n+\n+/* The VAR_DECL of a postcondition result. For deferred contracts, this\n+   is an IDENTIFIER.  */\n+#define POSTCONDITION_IDENTIFIER(NODE) \\\n+  (TREE_OPERAND (POSTCONDITION_STMT_CHECK (NODE), 3))\n+\n+/* For a FUNCTION_DECL of a guarded function, this holds the function decl\n+   where pre contract checks are emitted.  */\n+#define DECL_PRE_FN(NODE) \\\n+  (get_precondition_function ((NODE)))\n+\n+/* For a FUNCTION_DECL of a guarded function, this holds the function decl\n+   where post contract checks are emitted.  */\n+#define DECL_POST_FN(NODE) \\\n+  (get_postcondition_function ((NODE)))\n+\n+/* True iff the FUNCTION_DECL is the pre function for a guarded function.  */\n+#define DECL_IS_PRE_FN_P(NODE) \\\n+  (DECL_ABSTRACT_ORIGIN (NODE) && DECL_PRE_FN (DECL_ABSTRACT_ORIGIN (NODE)) == NODE)\n+\n+/* True iff the FUNCTION_DECL is the post function for a guarded function.  */\n+#define DECL_IS_POST_FN_P(NODE) \\\n+  (DECL_ABSTRACT_ORIGIN (NODE) && DECL_POST_FN (DECL_ABSTRACT_ORIGIN (NODE)) == NODE)\n+\n+extern void remove_contract_attributes\t\t(tree);\n+extern void copy_contract_attributes\t\t(tree, tree);\n+extern void remap_contracts\t\t\t(tree, tree, tree, bool);\n+extern void maybe_update_postconditions\t\t(tree);\n+extern void rebuild_postconditions\t\t(tree);\n+extern bool check_postcondition_result\t\t(tree, tree, location_t);\n+extern tree get_precondition_function\t\t(tree);\n+extern tree get_postcondition_function\t\t(tree);\n+extern void duplicate_contracts\t\t\t(tree, tree);\n+extern void match_deferred_contracts\t\t(tree);\n+extern void defer_guarded_contract_match\t(tree, tree, tree);\n+extern bool diagnose_misapplied_contracts\t(tree);\n+extern tree finish_contract_attribute\t\t(tree, tree);\n+extern tree invalidate_contract\t\t\t(tree);\n+extern void update_late_contract\t\t(tree, tree, tree);\n+extern tree splice_out_contracts\t\t(tree);\n+extern bool all_attributes_are_contracts_p\t(tree);\n+extern void inherit_base_contracts\t\t(tree, tree);\n+extern tree apply_postcondition_to_return\t(tree);\n+extern void start_function_contracts\t\t(tree);\n+extern void finish_function_contracts\t\t(tree);\n+extern void set_contract_functions\t\t(tree, tree, tree);\n+extern tree build_contract_check\t\t(tree);\n+extern void emit_assertion\t\t\t(tree);\n+\n+#endif /* ! GCC_CP_CONTRACT_H */"}, {"sha": "983f2a566a66f4498d1d7e27734c507200a38481", "filename": "gcc/cp/cp-gimplify.cc", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fcp-gimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fcp-gimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.cc?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -1427,6 +1427,23 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n       wtd->bind_expr_stack.pop ();\n       break;\n \n+    case ASSERTION_STMT:\n+    case PRECONDITION_STMT:\n+    case POSTCONDITION_STMT:\n+      {\n+\tif (tree check = build_contract_check (stmt))\n+\t  {\n+\t    *stmt_p = check;\n+\t    return cp_genericize_r (stmt_p, walk_subtrees, data);\n+\t  }\n+\n+\t/* If we didn't build a check, replace it with void_node so we don't\n+\t   leak contracts into GENERIC.  */\n+\t*stmt_p = void_node;\n+\t*walk_subtrees = 0;\n+      }\n+      break;\n+\n     case USING_STMT:\n       {\n \ttree block = NULL_TREE;"}, {"sha": "6ed382662811a834dea5a399e65959a49f313efd", "filename": "gcc/cp/cp-objcp-common.cc", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fcp-objcp-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fcp-objcp-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.cc?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cp-objcp-common.h\"\n #include \"dwarf2.h\"\n #include \"stringpool.h\"\n+#include \"contracts.h\"\n \n /* Special routine to get the alias set for C++.  */\n \n@@ -86,6 +87,9 @@ cp_tree_size (enum tree_code code)\n     case CONSTRAINT_INFO:       return sizeof (tree_constraint_info);\n     case USERDEF_LITERAL:\treturn sizeof (tree_userdef_literal);\n     case TEMPLATE_DECL:\t\treturn sizeof (tree_template_decl);\n+    case ASSERTION_STMT:\treturn sizeof (tree_exp);\n+    case PRECONDITION_STMT:\treturn sizeof (tree_exp);\n+    case POSTCONDITION_STMT:\treturn sizeof (tree_exp);\n     default:\n       switch (TREE_CODE_CLASS (code))\n \t{\n@@ -564,6 +568,10 @@ cp_common_init_ts (void)\n   MARK_TS_EXP (CO_YIELD_EXPR);\n   MARK_TS_EXP (CO_RETURN_EXPR);\n \n+  MARK_TS_EXP (ASSERTION_STMT);\n+  MARK_TS_EXP (PRECONDITION_STMT);\n+  MARK_TS_EXP (POSTCONDITION_STMT);\n+\n   c_common_init_ts ();\n }\n \n@@ -576,6 +584,39 @@ cp_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n {\n   if (handle_module_option (unsigned (scode), arg, value))\n     return true;\n+\n+  enum opt_code code = (enum opt_code) scode;\n+  bool handled_p = true;\n+\n+  switch (code)\n+    {\n+    case OPT_fcontract_build_level_:\n+      handle_OPT_fcontract_build_level_ (arg);\n+      break;\n+\n+    case OPT_fcontract_assumption_mode_:\n+      handle_OPT_fcontract_assumption_mode_ (arg);\n+      break;\n+\n+    case OPT_fcontract_continuation_mode_:\n+      handle_OPT_fcontract_continuation_mode_ (arg);\n+      break;\n+\n+    case OPT_fcontract_role_:\n+      handle_OPT_fcontract_role_ (arg);\n+      break;\n+\n+    case OPT_fcontract_semantic_:\n+      handle_OPT_fcontract_semantic_ (arg);\n+      break;\n+\n+    default:\n+      handled_p = false;\n+      break;\n+    }\n+  if (handled_p)\n+    return handled_p;\n+\n   return c_common_handle_option (scode, arg, value, kind, loc, handlers);\n }\n "}, {"sha": "d8aab10549f141ca7e2671db9677b3081438a94d", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -582,6 +582,17 @@ DEFTREECODE (CO_YIELD_EXPR, \"co_yield\", tcc_expression, 2)\n \n DEFTREECODE (CO_RETURN_EXPR, \"co_return\", tcc_statement, 2)\n \n+/* Different flavors of contracts.\n+\n+   Assertions and preconditions have two operands: a node containing\n+   the their mode and condition. Postconditions have an additional\n+   operand to store the optional name for the result value.\n+\n+   CONTRACT_SEMANTIC has the computed behavior of the contract.  */\n+DEFTREECODE (ASSERTION_STMT, \"assertion_stmt\", tcc_statement, 3)\n+DEFTREECODE (PRECONDITION_STMT, \"precondition_stmt\", tcc_statement, 3)\n+DEFTREECODE (POSTCONDITION_STMT, \"postcondition_stmt\", tcc_statement, 4)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "548b533266a5b0521866ff7c17219dc3a4b30d3a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hard-reg-set.h\"\n #include \"function.h\"\n #include \"tristate.h\"\n+#include \"contracts.h\"\n \n /* In order for the format checking to accept the C++ front end\n    diagnostic framework extensions, you must include this file before\n@@ -232,6 +233,8 @@ enum cp_tree_index\n     CPTI_DSO_HANDLE,\n     CPTI_DCAST,\n \n+    CPTI_PSEUDO_CONTRACT_VIOLATION,\n+\n     CPTI_SOURCE_LOCATION_IMPL,\n \n     CPTI_FALLBACK_DFLOAT32_TYPE,\n@@ -266,6 +269,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n #define current_aggr\t\t\tcp_global_trees[CPTI_AGGR_TAG]\n /* std::align_val_t */\n #define align_type_node\t\t\tcp_global_trees[CPTI_ALIGN_TYPE]\n+#define pseudo_contract_violation_type\tcp_global_trees[CPTI_PSEUDO_CONTRACT_VIOLATION]\n \n /* We cache these tree nodes so as to call get_identifier less frequently.\n    For identifiers for functions, including special member functions such\n@@ -455,6 +459,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       ALIGNOF_EXPR_STD_P (in ALIGNOF_EXPR)\n       OVL_DEDUP_P (in OVERLOAD)\n       ATOMIC_CONSTR_MAP_INSTANTIATED_P (in ATOMIC_CONSTR)\n+      contract_semantic (in ASSERTION_, PRECONDITION_, POSTCONDITION_STMT)\n    1: IDENTIFIER_KIND_BIT_1 (in IDENTIFIER_NODE)\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -493,6 +498,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       LAMBDA_EXPR_CAPTURE_OPTIMIZED (in LAMBDA_EXPR)\n       IMPLICIT_CONV_EXPR_BRACED_INIT (in IMPLICIT_CONV_EXPR)\n       PACK_EXPANSION_AUTO_P (in *_PACK_EXPANSION)\n+      contract_semantic (in ASSERTION_, PRECONDITION_, POSTCONDITION_STMT)\n    3: IMPLICIT_RVALUE_P (in NON_LVALUE_EXPR or STATIC_CAST_EXPR)\n       ICS_BAD_FLAG (in _CONV)\n       FN_TRY_BLOCK_P (in TRY_BLOCK)\n@@ -505,6 +511,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       PACK_EXPANSION_FORCE_EXTRA_ARGS_P (in *_PACK_EXPANSION)\n       LAMBDA_EXPR_STATIC_P (in LAMBDA_EXPR)\n       TARGET_EXPR_ELIDING_P (in TARGET_EXPR)\n+      contract_semantic (in ASSERTION_, PRECONDITION_, POSTCONDITION_STMT)\n    4: IDENTIFIER_MARKED (IDENTIFIER_NODEs)\n       TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n \t  CALL_EXPR, or FIELD_DECL).\n@@ -1863,6 +1870,7 @@ struct GTY(()) saved_scope {\n   int x_processing_template_decl;\n   int x_processing_specialization;\n   int x_processing_constraint;\n+  int x_processing_contract_condition;\n   int suppress_location_wrappers;\n   BOOL_BITFIELD x_processing_explicit_instantiation : 1;\n   BOOL_BITFIELD need_pop_function_context : 1;\n@@ -1937,6 +1945,12 @@ extern GTY(()) struct saved_scope *scope_chain;\n #define processing_specialization scope_chain->x_processing_specialization\n #define processing_explicit_instantiation scope_chain->x_processing_explicit_instantiation\n \n+/* Nonzero if we are parsing the conditional expression of a contract\n+   condition. These expressions appear outside the paramter list (like a\n+   trailing return type), but are potentially evaluated.  */\n+\n+#define processing_contract_condition scope_chain->x_processing_contract_condition\n+\n #define in_discarded_stmt scope_chain->discarded_stmt\n #define in_consteval_if_p scope_chain->consteval_if_p\n \n@@ -5651,6 +5665,11 @@ extern int comparing_specializations;\n    FIXME we should always do this except during deduction/ordering.  */\n extern int comparing_dependent_aliases;\n \n+/* Nonzero if we want to consider different member expressions to compare\n+   equal if they designate the same entity. This is set when comparing\n+   contract conditions of overrides.  */\n+extern bool comparing_override_contracts;\n+\n /* In parser.cc.  */\n \n /* Nonzero if we are parsing an unevaluated operand: an operand to\n@@ -7453,8 +7472,10 @@ extern hashval_t iterative_hash_template_arg\t(tree arg, hashval_t val);\n extern tree coerce_template_parms\t\t(tree, tree, tree, tsubst_flags_t,\n \t\t\t\t\t\t bool = true);\n extern tree canonicalize_type_argument\t\t(tree, tsubst_flags_t);\n+extern void register_local_identity\t\t(tree);\n extern void register_local_specialization       (tree, tree);\n extern tree retrieve_local_specialization       (tree);\n+extern void register_parameter_specializations\t(tree, tree);\n extern tree extract_fnparm_pack                 (tree, tree *);\n extern tree template_parm_to_arg                (tree);\n extern tree dguide_name\t\t\t\t(tree);\n@@ -8526,6 +8547,49 @@ extern tree coro_get_actor_function\t\t(tree);\n extern tree coro_get_destroy_function\t\t(tree);\n extern tree coro_get_ramp_function\t\t(tree);\n \n+/* contracts.cc */\n+extern tree make_postcondition_variable\t\t(cp_expr);\n+extern tree make_postcondition_variable\t\t(cp_expr, tree);\n+extern tree grok_contract\t\t\t(tree, tree, tree, cp_expr, location_t);\n+extern tree finish_contract_condition\t\t(cp_expr);\n+\n+/* Return the first contract in ATTRS, or NULL_TREE if there are none.  */\n+\n+inline tree\n+find_contract (tree attrs)\n+{\n+  while (attrs && !cxx_contract_attribute_p (attrs))\n+    attrs = TREE_CHAIN (attrs);\n+  return attrs;\n+}\n+\n+inline void\n+set_decl_contracts (tree decl, tree contract_attrs)\n+{\n+  remove_contract_attributes (decl);\n+  DECL_ATTRIBUTES (decl) = chainon (DECL_ATTRIBUTES (decl), contract_attrs);\n+}\n+\n+/* Returns the computed semantic of the node.  */\n+\n+inline contract_semantic\n+get_contract_semantic (const_tree t)\n+{\n+  return (contract_semantic) (TREE_LANG_FLAG_3 (CONTRACT_CHECK (t))\n+      | (TREE_LANG_FLAG_2 (t) << 1)\n+      | (TREE_LANG_FLAG_0 ((t)) << 2));\n+}\n+\n+/* Sets the computed semantic of the node.  */\n+\n+inline void\n+set_contract_semantic (tree t, contract_semantic semantic)\n+{\n+  TREE_LANG_FLAG_3 (CONTRACT_CHECK (t)) = semantic & 0x01;\n+  TREE_LANG_FLAG_2 (t) = (semantic & 0x02) >> 1;\n+  TREE_LANG_FLAG_0 (t) = (semantic & 0x04) >> 2;\n+}\n+\n /* Inline bodies.  */\n   \n inline tree"}, {"sha": "544efdc99142d229b89b89730036cb94f4ec09be", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 109, "deletions": 6, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -2268,6 +2268,8 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)\n \t  = DECL_OVERLOADED_OPERATOR_CODE_RAW (olddecl);\n       new_defines_function = DECL_INITIAL (newdecl) != NULL_TREE;\n \n+      duplicate_contracts (newdecl, olddecl);\n+\n       /* Optionally warn about more than one declaration for the same\n \t name, but don't warn about a function declaration followed by a\n \t definition.  */\n@@ -2341,6 +2343,13 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)\n \t specializations.  */\n       gcc_assert (!DECL_TEMPLATE_SPECIALIZATIONS (newdecl));\n \n+      /* Make sure the contracts are equivalent.  */\n+      duplicate_contracts (newdecl, olddecl);\n+\n+      /* Remove contracts from old_result so they aren't appended to\n+\t old_result by the merge function.  */\n+      remove_contract_attributes (old_result);\n+\n       DECL_ATTRIBUTES (old_result)\n \t= (*targetm.merge_decl_attributes) (old_result, new_result);\n \n@@ -2863,11 +2872,23 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)\n \t}\n       if (! types_match || new_defines_function)\n \t{\n+\t  /* These are the final DECL_ARGUMENTS that will be used within the\n+\t     body; update any references to old DECL_ARGUMENTS in the\n+\t     contracts, if present.  */\n+\t  if (tree contracts = DECL_CONTRACTS (newdecl))\n+\t    remap_contracts (olddecl, newdecl, contracts, true);\n+\n \t  /* These need to be copied so that the names are available.\n \t     Note that if the types do match, we'll preserve inline\n \t     info and other bits, but if not, we won't.  */\n \t  DECL_ARGUMENTS (olddecl) = DECL_ARGUMENTS (newdecl);\n \t  DECL_RESULT (olddecl) = DECL_RESULT (newdecl);\n+\n+\t  /* In some cases, duplicate_contracts will remove contracts from\n+\t     OLDDECL, to avoid duplications. Sometimes, the contracts end up\n+\t     shared. If we removed them, re-add them.  */\n+\t  if (!DECL_CONTRACTS (olddecl))\n+\t    copy_contract_attributes (olddecl, newdecl);\n \t}\n       /* If redeclaring a builtin function, it stays built in\n \t if newdecl is a gnu_inline definition, or if newdecl is just\n@@ -2911,7 +2932,38 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)\n \t  /* Don't clear out the arguments if we're just redeclaring a\n \t     function.  */\n \t  if (DECL_ARGUMENTS (olddecl))\n-\t    DECL_ARGUMENTS (newdecl) = DECL_ARGUMENTS (olddecl);\n+\t    {\n+\t      /* If we removed contracts from previous definition, re-attach\n+\t\t them. Otherwise, rewrite the contracts so they match the\n+\t\t parameters of the new declaration.  */\n+\t      if (DECL_INITIAL (olddecl)\n+\t\t  && DECL_CONTRACTS (newdecl)\n+\t\t  && !DECL_CONTRACTS (olddecl))\n+\t\tcopy_contract_attributes (olddecl, newdecl);\n+\t      else\n+\t\t{\n+\t\t  /* Temporarily undo the re-contexting of parameters so we can\n+\t\t     actually remap parameters.  The inliner won't replace\n+\t\t     parameters if we don't do this.  */\n+\t\t  tree args = DECL_ARGUMENTS (newdecl);\n+\t\t  for (tree p = args; p; p = DECL_CHAIN (p))\n+\t\t    DECL_CONTEXT (p) = newdecl;\n+\n+\t\t  /* Save new argument names for use in contracts parsing,\n+\t\t     unless we've already started parsing the body of olddecl\n+\t\t     (particular issues arise when newdecl is from a prior\n+\t\t     friend decl with no argument names, see\n+\t\t     modules/contracts-tpl-friend-1).  */\n+\t\t  if (tree contracts = DECL_CONTRACTS (olddecl))\n+\t\t    remap_contracts (newdecl, olddecl, contracts, true);\n+\n+\t\t  /* And reverse this operation again. */\n+\t\t  for (tree p = args; p; p = DECL_CHAIN (p))\n+\t\t    DECL_CONTEXT (p) = olddecl;\n+\t\t}\n+\n+\t      DECL_ARGUMENTS (newdecl) = DECL_ARGUMENTS (olddecl);\n+\t    }\n \t}\n     }\n   else if (TREE_CODE (newdecl) == NAMESPACE_DECL)\n@@ -5522,6 +5574,12 @@ check_tag_decl (cp_decl_specifier_seq *declspecs,\n \twarn_misplaced_attr_for_class_type (loc, declared_type);\n     }\n \n+  /* Diagnose invalid application of contracts, if any.  */\n+  if (find_contract (declspecs->attributes))\n+    diagnose_misapplied_contracts (declspecs->attributes);\n+  else\n+    diagnose_misapplied_contracts (declspecs->std_attributes);\n+\n   return declared_type;\n }\n \n@@ -5813,9 +5871,16 @@ start_decl (const cp_declarator *declarator,\n       if (DECL_EXTERNAL (decl) && ! DECL_TEMPLATE_SPECIALIZATION (decl)\n \t  /* Aliases are definitions. */\n \t  && !alias)\n-\tpermerror (declarator->id_loc,\n-\t\t   \"declaration of %q#D outside of class is not definition\",\n-\t\t   decl);\n+\t{\n+\t  if (DECL_VIRTUAL_P (decl) || !flag_contracts)\n+\t    permerror (declarator->id_loc,\n+\t\t       \"declaration of %q#D outside of class is not definition\",\n+\t\t       decl);\n+\t  else if (flag_contract_strict_declarations)\n+\t    warning_at (declarator->id_loc, OPT_fcontract_strict_declarations_,\n+\t\t\t\"declaration of %q#D outside of class is not definition\",\n+\t\t\tdecl);\n+\t}\n     }\n \n   /* Create a DECL_LANG_SPECIFIC so that DECL_DECOMPOSITION_P works.  */\n@@ -10597,6 +10662,9 @@ grokfndecl (tree ctype,\n       *attrlist = NULL_TREE;\n     }\n \n+  if (DECL_HAS_CONTRACTS_P (decl))\n+    rebuild_postconditions (decl);\n+\n   /* Check main's type after attributes have been applied.  */\n   if (ctype == NULL_TREE && DECL_MAIN_P (decl))\n     {\n@@ -12802,14 +12870,18 @@ grokdeclarator (const cp_declarator *declarator,\n \t}\n     }\n \n-  if (declspecs->std_attributes)\n+  if (declspecs->std_attributes\n+      && !diagnose_misapplied_contracts (declspecs->std_attributes))\n     {\n       location_t attr_loc = declspecs->locations[ds_std_attribute];\n       if (warning_at (attr_loc, OPT_Wattributes, \"attribute ignored\"))\n \tinform (attr_loc, \"an attribute that appertains to a type-specifier \"\n \t\t\"is ignored\");\n     }\n \n+  if (attrlist)\n+    diagnose_misapplied_contracts (*attrlist);\n+\n   /* Determine the type of the entity declared by recurring on the\n      declarator.  */\n   for (; declarator; declarator = declarator->declarator)\n@@ -12847,6 +12919,12 @@ grokdeclarator (const cp_declarator *declarator,\n \n       inner_declarator = declarator->declarator;\n \n+      /* Check that contracts aren't misapplied.  */\n+      if (tree contract_attr = find_contract (declarator->std_attributes))\n+\tif (declarator->kind != cdk_function\n+\t    || innermost_code != cdk_function)\n+\t  diagnose_misapplied_contracts (contract_attr);\n+\n       /* We don't want to warn in parameter context because we don't\n \t yet know if the parse will succeed, and this might turn out\n \t to be a constructor call.  */\n@@ -13243,6 +13321,23 @@ grokdeclarator (const cp_declarator *declarator,\n \t\telse\n \t\t  returned_attrs = attr_chainon (returned_attrs, att);\n \t      }\n+\n+\t    /* Actually apply the contract attributes to the declaration.  */\n+\t    for (tree *p = &attrs; *p;)\n+\t      {\n+\t\ttree l = *p;\n+\t\tif (cxx_contract_attribute_p (l))\n+\t\t  {\n+\t\t    *p = TREE_CHAIN (l);\n+\t\t    /* Intentionally reverse order of contracts so they're\n+\t\t       reversed back into their lexical order.  */\n+\t\t    TREE_CHAIN (l) = NULL_TREE;\n+\t\t    returned_attrs = chainon (l, returned_attrs);\n+\t\t  }\n+\t\telse\n+\t\t  p = &TREE_CHAIN (l);\n+\t     }\n+\n \t    if (attrs)\n \t      /* [dcl.fct]/2:\n \n@@ -14265,7 +14360,10 @@ grokdeclarator (const cp_declarator *declarator,\n \t  {\n \t    /* Packages tend to use GNU attributes on friends, so we only\n \t       warn for standard attributes.  */\n-\t    if (attrlist && !funcdef_flag && cxx11_attribute_p (*attrlist))\n+\t    if (attrlist\n+\t\t&& !funcdef_flag\n+\t\t&& cxx11_attribute_p (*attrlist)\n+\t\t&& !all_attributes_are_contracts_p (*attrlist))\n \t      {\n \t\t*attrlist = NULL_TREE;\n \t\tif (warning_at (id_loc, OPT_Wattributes, \"attribute ignored\"))\n@@ -17486,6 +17584,8 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \n   store_parm_decls (current_function_parms);\n \n+  start_function_contracts (decl1);\n+\n   if (!processing_template_decl\n       && (flag_lifetime_dse > 1)\n       && DECL_CONSTRUCTOR_P (decl1)\n@@ -18206,6 +18306,9 @@ finish_function (bool inline_p)\n   current_function_decl = NULL_TREE;\n \n   invoke_plugin_callbacks (PLUGIN_FINISH_PARSE_FUNCTION, fndecl);\n+\n+  finish_function_contracts (fndecl);\n+\n   return fndecl;\n }\n \f"}, {"sha": "f95529a5c9a743dfa18642e95f5a14bfa4f8da74", "filename": "gcc/cp/decl2.cc", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fdecl2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fdecl2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.cc?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -1561,6 +1561,9 @@ cp_check_const_attributes (tree attributes)\n   tree attr;\n   for (attr = attributes; attr; attr = TREE_CHAIN (attr))\n     {\n+      if (cxx_contract_attribute_p (attr))\n+\tcontinue;\n+\n       tree arg;\n       /* As we implement alignas using gnu::aligned attribute and\n \t alignas argument is a constant expression, force manifestly\n@@ -2106,7 +2109,17 @@ void\n comdat_linkage (tree decl)\n {\n   if (flag_weak)\n-    make_decl_one_only (decl, cxx_comdat_group (decl));\n+    {\n+      make_decl_one_only (decl, cxx_comdat_group (decl));\n+      if (HAVE_COMDAT_GROUP && flag_contracts && DECL_CONTRACTS (decl))\n+\t{\n+\t  symtab_node *n = symtab_node::get (decl);\n+\t  if (tree pre = DECL_PRE_FN (decl))\n+\t    cgraph_node::get_create (pre)->add_to_same_comdat_group (n);\n+\t  if (tree post = DECL_POST_FN (decl))\n+\t    cgraph_node::get_create (post)->add_to_same_comdat_group (n);\n+\t}\n+    }\n   else if (TREE_CODE (decl) == FUNCTION_DECL\n \t   || (VAR_P (decl) && DECL_ARTIFICIAL (decl)))\n     /* We can just emit function and compiler-generated variables"}, {"sha": "12b28e8ee5b67f108252c871c66a4829065018e8", "filename": "gcc/cp/error.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Ferror.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Ferror.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.cc?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -567,7 +567,8 @@ dump_type (cxx_pretty_printer *pp, tree t, int flags)\n       else\n \t{\n \t  pp_cxx_cv_qualifier_seq (pp, t);\n-\t  pp_cxx_tree_identifier (pp, TYPE_IDENTIFIER (t));\n+\t  if (tree id = TYPE_IDENTIFIER (t))\n+\t    pp_cxx_tree_identifier (pp, id);\n \t}\n       break;\n "}, {"sha": "257e49b7f3f75463feb37d38f8c2e738357f0c60", "filename": "gcc/cp/g++spec.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fg%2B%2Bspec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fg%2B%2Bspec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fg%2B%2Bspec.cc?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -31,6 +31,8 @@ along with GCC; see the file COPYING3.  If not see\n #define WITHLIBC\t(1<<3)\n /* Skip this option.  */\n #define SKIPOPT\t\t(1<<4)\n+/* Add -lstdc++exp for experimental features that need library support.  */\n+#define EXPERIMENTAL\t(1<<5)\n \n #ifndef MATH_LIBRARY\n #define MATH_LIBRARY \"m\"\n@@ -158,6 +160,11 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n \n       switch (decoded_options[i].opt_index)\n \t{\n+\tcase OPT_fcontracts:\n+\t  args[i] |= EXPERIMENTAL;\n+\t  ++added;\n+\t  break;\n+\n \tcase OPT_nostdlib:\n \tcase OPT_nostdlib__:\n \tcase OPT_nodefaultlibs:\n@@ -348,6 +355,11 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n \t\t\t   &new_decoded_options[j]);\n \t}\n \n+      if ((args[i] & EXPERIMENTAL)\n+\t  && which_library == USE_LIBSTDCXX)\n+\tgenerate_option (OPT_l, \"stdc++exp\", 1, CL_DRIVER,\n+\t\t\t &new_decoded_options[++j]);\n+\n       if ((args[i] & SKIPOPT) != 0)\n \t--j;\n "}, {"sha": "e363ef35b9f0221c320563f74e112a658a14e67c", "filename": "gcc/cp/mangle.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fmangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fmangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.cc?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -856,6 +856,13 @@ write_encoding (const tree decl)\n \t\t\t\tmangle_return_type_p (decl),\n \t\t\t\td);\n \n+      /* If this is the pre/post function for a guarded function, append\n+\t .pre/post, like something from create_virtual_clone.  */\n+      if (DECL_IS_PRE_FN_P (decl))\n+\twrite_string (\".pre\");\n+      else if (DECL_IS_POST_FN_P (decl))\n+\twrite_string (\".post\");\n+\n       /* If this is a coroutine helper, then append an appropriate string to\n \t identify which.  */\n       if (tree ramp = DECL_RAMP_FN (decl))"}, {"sha": "a1764354ba597ba231284d343826c7468706a596", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -10186,6 +10186,20 @@ trees_out::fn_parms_init (tree fn)\n \t\t   base_tag - ix, ix, parm, fn);\n       tree_node_vals (parm);\n     }\n+\n+  if (!streaming_p ())\n+    {\n+      /* We must walk contract attrs so the dependency graph is complete. */\n+      for (tree contract = DECL_CONTRACTS (fn);\n+\t  contract;\n+\t  contract = CONTRACT_CHAIN (contract))\n+\ttree_node (contract);\n+    }\n+\n+  /* Write a reference to contracts pre/post functions, if any, to avoid\n+     regenerating them in importers.  */\n+  tree_node (DECL_PRE_FN (fn));\n+  tree_node (DECL_POST_FN (fn));\n }\n \n /* Build skeleton parm nodes, read their flags, type & parm indices.  */\n@@ -10220,6 +10234,11 @@ trees_in::fn_parms_init (tree fn)\n \treturn 0;\n     }\n \n+  /* Reload references to contract functions, if any.  */\n+  tree pre_fn = tree_node ();\n+  tree post_fn = tree_node ();\n+  set_contract_functions (fn, pre_fn, post_fn);\n+\n   return base_tag;\n }\n \n@@ -10807,7 +10826,15 @@ check_mergeable_decl (merge_kind mk, tree decl, tree ovl, merge_key const &key)\n \t\t   Matches decls_match behaviour.  */\n \t\t&& (!DECL_IS_UNDECLARED_BUILTIN (m_inner)\n \t\t    || !DECL_EXTERN_C_P (m_inner)\n-\t\t    || DECL_EXTERN_C_P (d_inner)))\n+\t\t    || DECL_EXTERN_C_P (d_inner))\n+\t\t/* Reject if one is a different member of a\n+\t\t   guarded/pre/post fn set.  */\n+\t\t&& (!flag_contracts\n+\t\t    || (DECL_IS_PRE_FN_P (d_inner)\n+\t\t\t== DECL_IS_PRE_FN_P (m_inner)))\n+\t\t&& (!flag_contracts\n+\t\t    || (DECL_IS_POST_FN_P (d_inner)\n+\t\t\t== DECL_IS_POST_FN_P (m_inner))))\n \t      {\n \t\ttree m_reqs = get_constraints (m_inner);\n \t\tif (m_reqs)\n@@ -14575,6 +14602,7 @@ module_state_config::get_dialect ()\n \t\t      cxx_dialect < cxx20 && flag_concepts ? \"/concepts\" : \"\",\n \t\t      flag_coroutines ? \"/coroutines\" : \"\",\n \t\t      flag_module_implicit_inline ? \"/implicit-inline\" : \"\",\n+\t\t      flag_contracts ? \"/contracts\" : \"\",\n \t\t      NULL);\n \n   return dialect;"}, {"sha": "aec625e2d9cf30412444403dfbe636aa43c7e6f3", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 511, "deletions": 11, "changes": 522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cp-name-hint.h\"\n #include \"memmodel.h\"\n #include \"c-family/known-headers.h\"\n+#include \"contracts.h\"\n #include \"bitmap.h\"\n \n \f\n@@ -2192,11 +2193,14 @@ cp_parser_context_new (cp_parser_context* next)\n   parser->unparsed_queues->last ().nsdmis\n #define unparsed_noexcepts \\\n   parser->unparsed_queues->last ().noexcepts\n+#define unparsed_contracts \\\n+  parser->unparsed_queues->last ().contracts\n \n static void\n push_unparsed_function_queues (cp_parser *parser)\n {\n-  cp_unparsed_functions_entry e = { NULL, make_tree_vector (), NULL, NULL };\n+  cp_unparsed_functions_entry e\n+      = { NULL, make_tree_vector (), NULL, NULL, NULL };\n   vec_safe_push (parser->unparsed_queues, e);\n }\n \n@@ -2695,6 +2699,10 @@ static tree cp_parser_transaction_cancel\n static tree cp_parser_yield_expression\n   (cp_parser *);\n \n+/* Contracts */\n+\n+static void cp_parser_late_contract_condition\n+  (cp_parser *, tree, tree);\n \n enum pragma_context {\n   pragma_external,\n@@ -2907,6 +2915,8 @@ static bool cp_parser_array_designator_p\n   (cp_parser *);\n static bool cp_parser_init_statement_p\n   (cp_parser *);\n+static bool cp_parser_skip_up_to_closing_square_bracket\n+  (cp_parser *);\n static bool cp_parser_skip_to_closing_square_bracket\n   (cp_parser *);\n static size_t cp_parser_skip_balanced_tokens (cp_parser *, size_t);\n@@ -12024,6 +12034,16 @@ cp_parser_handle_statement_omp_attributes (cp_parser *parser, tree attrs)\n   return attrs;\n }\n \n+/* True if and only if the name is one of the contract types.  */\n+\n+static bool\n+contract_attribute_p (const_tree id)\n+{\n+  return is_attribute_p (\"assert\", id)\n+    || is_attribute_p (\"pre\", id)\n+    || is_attribute_p (\"post\", id);\n+}\n+\n /* Handle omp::directive and omp::sequence attributes in *PATTRS\n    (if any) at the start or after declaration-id of a declaration.  */\n \n@@ -12157,7 +12177,10 @@ cp_parser_handle_directive_omp_attributes (cp_parser *parser, tree *pattrs,\n   is a (possibly labeled) if statement which is not enclosed in braces\n   and has an else clause.  This is used to implement -Wparentheses.\n \n-  CHAIN is a vector of if-else-if conditions.  */\n+  CHAIN is a vector of if-else-if conditions.\n+\n+  Note that this version of parsing restricts assertions to be attached to\n+  empty statements. */\n \n static void\n cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n@@ -12199,6 +12222,23 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n+\n+  /* If we have contracts, check that they're valid in this context.  */\n+  if (std_attrs != error_mark_node)\n+    {\n+      if (tree pre = lookup_attribute (\"pre\", std_attrs))\n+\terror_at (EXPR_LOCATION (TREE_VALUE (pre)),\n+\t\t  \"preconditions cannot be statements\");\n+      else if (tree post = lookup_attribute (\"post\", std_attrs))\n+\terror_at (EXPR_LOCATION (TREE_VALUE (post)),\n+\t\t  \"postconditions cannot be statements\");\n+\n+    /* Check that assertions are null statements.  */\n+    if (cp_contract_assertion_p (std_attrs))\n+      if (token->type != CPP_SEMICOLON)\n+\terror_at (token->location, \"assertions must be followed by %<;%>\");\n+    }\n+\n   bool omp_attrs_forbidden_p;\n   omp_attrs_forbidden_p = parser->omp_attrs_forbidden_p;\n \n@@ -12514,6 +12554,15 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t\t\t\"%<fallthrough%> attribute not followed by %<;%>\");\n \t  std_attrs = NULL_TREE;\n \t}\n+\n+      /* Handle [[assert: ...]];  */\n+      if (cp_contract_assertion_p (std_attrs))\n+\t{\n+\t  /* Add the assertion as a statement in the current block.  */\n+\t  gcc_assert (!statement || statement == error_mark_node);\n+\t  emit_assertion (std_attrs);\n+\t  std_attrs = NULL_TREE;\n+\t}\n     }\n \n   /* Set the line number for the statement.  */\n@@ -15697,7 +15746,12 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t\t   declared.  */;\n \t      else\n \t\t{\n-\t\t  if (decl_specs->type && CLASS_TYPE_P (decl_specs->type))\n+\t\t  if (find_contract (attrs))\n+\t\t    {\n+\t\t      diagnose_misapplied_contracts (attrs);\n+\t\t      attrs = NULL_TREE;\n+\t\t    }\n+\t\t  else if (decl_specs->type && CLASS_TYPE_P (decl_specs->type))\n \t\t    {\n \t\t      /*  This is an attribute following a\n \t\t\t  class-specifier.  */\n@@ -25398,11 +25452,11 @@ cp_parser_braced_list (cp_parser* parser, bool* non_constant_p)\n   return result;\n }\n \n-/* Consume tokens up to, and including, the next non-nested closing `]'.\n+/* Consume tokens up to, but not including, the next non-nested closing `]'.\n    Returns true iff we found a closing `]'.  */\n \n static bool\n-cp_parser_skip_to_closing_square_bracket (cp_parser *parser)\n+cp_parser_skip_up_to_closing_square_bracket (cp_parser *parser)\n {\n   unsigned square_depth = 0;\n \n@@ -25427,21 +25481,30 @@ cp_parser_skip_to_closing_square_bracket (cp_parser *parser)\n \n         case CPP_CLOSE_SQUARE:\n \t  if (!square_depth--)\n-\t    {\n-\t      cp_lexer_consume_token (parser->lexer);\n-\t      return true;\n-\t    }\n+\t    return true;\n \t  break;\n \n \tdefault:\n \t  break;\n \t}\n \n-      /* Consume the token.  */\n+      /* Consume the current token, skipping it.  */\n       cp_lexer_consume_token (parser->lexer);\n     }\n }\n \n+/* Consume tokens up to, and including, the next non-nested closing `]'.\n+   Returns true iff we found a closing `]'.  */\n+\n+static bool\n+cp_parser_skip_to_closing_square_bracket (cp_parser *parser)\n+{\n+  bool found = cp_parser_skip_up_to_closing_square_bracket (parser);\n+  if (found)\n+    cp_lexer_consume_token (parser->lexer);\n+  return found;\n+}\n+\n /* Return true if we are looking at an array-designator, false otherwise.  */\n \n static bool\n@@ -26284,6 +26347,56 @@ cp_parser_class_specifier (cp_parser* parser)\n \t  cp_parser_late_parsing_nsdmi (parser, decl);\n \t}\n       vec_safe_truncate (unparsed_nsdmis, 0);\n+\n+      /* Now contract attributes.  */\n+      FOR_EACH_VEC_SAFE_ELT (unparsed_contracts, ix, decl)\n+\t{\n+\t  tree ctx = DECL_CONTEXT (decl);\n+\t  if (class_type != ctx)\n+\t    {\n+\t      if (pushed_scope)\n+\t\tpop_scope (pushed_scope);\n+\t      class_type = ctx;\n+\t      pushed_scope = push_scope (class_type);\n+\t    }\n+\n+\t  temp_override<tree> cfd(current_function_decl, decl);\n+\n+\t  /* Make sure that any template parameters are in scope.  */\n+\t  maybe_begin_member_template_processing (decl);\n+\n+\t  /* Make sure that any member-function parameters are in scope.\n+\t     This function doesn't expect ccp to be set.  */\n+\t  current_class_ptr = current_class_ref = NULL_TREE;\n+\t  inject_parm_decls (decl);\n+\n+\t  /* 'this' is not allowed in static member functions.  */\n+\t  unsigned char local_variables_forbidden_p\n+\t    = parser->local_variables_forbidden_p;\n+\t  if (DECL_THIS_STATIC (decl))\n+\t    parser->local_variables_forbidden_p |= THIS_FORBIDDEN;\n+\n+\t  /* Now we can parse contract conditions.  */\n+\t  for (tree a = DECL_ATTRIBUTES (decl); a; a = TREE_CHAIN (a))\n+\t    {\n+\t      if (cxx_contract_attribute_p (a))\n+\t\tcp_parser_late_contract_condition (parser, decl, a);\n+\t    }\n+\n+\t  /* Restore the state of local_variables_forbidden_p.  */\n+\t  parser->local_variables_forbidden_p = local_variables_forbidden_p;\n+\n+\t  /* Remove any member-function parameters from the symbol table.  */\n+\t  pop_injected_parms ();\n+\n+\t  /* Remove any template parameters from the symbol table.  */\n+\t  maybe_end_member_template_processing ();\n+\n+\t  /* Perform any deferred contract matching.  */\n+\t  match_deferred_contracts (decl);\n+\t}\n+      vec_safe_truncate (unparsed_contracts, 0);\n+\n       current_class_ptr = save_ccp;\n       current_class_ref = save_ccr;\n       if (pushed_scope)\n@@ -26387,6 +26500,8 @@ cp_parser_class_head (cp_parser* parser,\n \n   /* Parse the attributes.  */\n   attributes = cp_parser_attributes_opt (parser);\n+  if (find_contract (attributes))\n+    diagnose_misapplied_contracts (attributes);\n \n   /* If the next token is `::', that is invalid -- but sometimes\n      people do try to write:\n@@ -29316,18 +29431,377 @@ cp_parser_std_attribute_list (cp_parser *parser, tree attr_ns)\n   return attributes;\n }\n \n+/* Optionally parse a C++20 contract role. A NULL return means that no\n+   contract role was specified.\n+\n+    contract-role:\n+      % default\n+      % identifier\n+\n+   If the identifier does not name a known contract role, it will\n+   be assumed to be default. Returns the identifier for the role\n+   token.  */\n+\n+static tree\n+cp_parser_contract_role (cp_parser *parser)\n+{\n+  gcc_assert (cp_lexer_next_token_is (parser->lexer, CPP_MOD));\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+  tree role_id = NULL_TREE;\n+  if (token->type == CPP_NAME)\n+    role_id = token->u.value;\n+  else if (token->type == CPP_KEYWORD && token->keyword == RID_DEFAULT)\n+    role_id = get_identifier (\"default\");\n+  else\n+    {\n+      error_at (token->location, \"expected contract-role\");\n+      return error_mark_node;\n+    }\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  /* FIXME: Warn about invalid/unknown roles?  */\n+  return role_id;\n+}\n+\n+/* Parse an optional contract mode.\n+\n+     contract-mode:\n+\tcontract-semantic\n+\t[contract-level] [contract-role]\n+\n+     contract-semantic:\n+       check_never_continue\n+       check_maybe_continue\n+       check_always_continue\n+\n+     contract-level:\n+       default\n+       audit\n+       axiom\n+\n+     contract-role:\n+       default\n+       identifier\n+\n+   This grammar is taken from P1332R0. During parsing, this sets options\n+   on the MODE object to determine the configuration of the contract.\n+\n+   Returns a tree containing the identifiers used in the configuration.\n+   This is either an IDENTIFIER with the literal semantic or a TREE_LIST\n+   whose TREE_VALUE is the contract-level and whose TREE_PURPOSE is the\n+   contract-role, if any. NULL_TREE is returned if no information is\n+   given (i.e., all defaults selected).  */\n+\n+static tree\n+cp_parser_contract_mode_opt (cp_parser *parser,\n+\t\t\t     bool postcondition_p)\n+{\n+  /* The mode is empty; the level and role are default.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n+    return NULL_TREE;\n+\n+  /* There is only a role; the level is default.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_MOD))\n+    {\n+      tree role_id = cp_parser_contract_role (parser);\n+      return build_tree_list (role_id, get_identifier (\"default\"));\n+    }\n+\n+  /* Otherwise, match semantic or level.  */\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+  contract_level level = CONTRACT_INVALID;\n+  contract_semantic semantic = CCS_INVALID;\n+  tree config_id;\n+  if (token->type == CPP_NAME)\n+    {\n+      config_id = token->u.value;\n+\n+      /* Either a named level, a concrete semantic, or an identifier\n+\t for a postcondition.  */\n+      const char *ident = IDENTIFIER_POINTER (token->u.value);\n+      level = map_contract_level (ident);\n+      semantic = map_contract_semantic (ident);\n+\n+      /* The identifier is the return value for a postcondition.  */\n+      if (level == CONTRACT_INVALID && semantic == CCS_INVALID\n+\t  && postcondition_p)\n+\treturn NULL_TREE;\n+    }\n+  else if (token->type == CPP_KEYWORD && token->keyword == RID_DEFAULT)\n+    {\n+      config_id = get_identifier (\"default\");\n+      level = CONTRACT_DEFAULT;\n+    }\n+  else\n+    {\n+      /* We got some other token other than a ':'.  */\n+      error_at (token->location, \"expected contract semantic or level\");\n+      return NULL_TREE;\n+    }\n+\n+  /* Consume the literal semantic or level token.  */\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  if (semantic == CCS_INVALID && level == CONTRACT_INVALID)\n+    {\n+      error_at (token->location,\n+\t\t\"expected contract level: \"\n+\t\t\"%<default%>, %<audit%>, or %<axiom%>\");\n+      return NULL_TREE;\n+    }\n+\n+  /* We matched an explicit semantic. */\n+  if (semantic != CCS_INVALID)\n+    {\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_MOD))\n+\t{\n+\t  error (\"invalid use of contract role for explicit semantic\");\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t}\n+      return config_id;\n+    }\n+\n+  /* We matched a level, there may be a role; otherwise this is default.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_MOD))\n+    {\n+      tree role_id = cp_parser_contract_role (parser);\n+      return build_tree_list (role_id, config_id);\n+    }\n+\n+  return build_tree_list (NULL_TREE, config_id);\n+}\n+\n+static tree\n+find_error (tree *tp, int *, void *)\n+{\n+  if (*tp == error_mark_node)\n+    return *tp;\n+  return NULL_TREE;\n+}\n+\n+static bool\n+contains_error_p (tree t)\n+{\n+  return walk_tree (&t, find_error, NULL, NULL);\n+}\n+\n+/* Parse a standard C++20 contract attribute specifier.\n+\n+  contract-attribute-specifier:\n+    [ [ assert contract-level [opt] : conditional-expression ] ]\n+    [ [ pre contract-level [opt] : conditional-expression ] ]\n+    [ [ post contract-level [opt] identifier [opt] : conditional-expression ] ]\n+\n+   For free functions, we cannot determine the type of the postcondition\n+   identifier because the we haven't called grokdeclarator yet. In those\n+   cases we parse the postcondition as if the identifier was declared as\n+   'auto <identifier>'. We then instantiate the postcondition once the\n+   return type is known.\n+\n+   For member functions, contracts are in the complete-class context, so the\n+   parse is deferred. We also have the return type avaialable (unless it's\n+   deduced), so we don't need to parse the postcondition in terms of a\n+   placeholder.  */\n+\n+static tree\n+cp_parser_contract_attribute_spec (cp_parser *parser, tree attribute)\n+{\n+  gcc_assert (contract_attribute_p (attribute));\n+  cp_token *token = cp_lexer_consume_token (parser->lexer);\n+  location_t loc = token->location;\n+\n+  bool assertion_p = is_attribute_p (\"assert\", attribute);\n+  bool postcondition_p = is_attribute_p (\"post\", attribute);\n+\n+  /* Parse the optional mode.  */\n+  tree mode = cp_parser_contract_mode_opt (parser, postcondition_p);\n+\n+  /* Check for postcondition identifiers.  */\n+  cp_expr identifier;\n+  if (postcondition_p && cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    identifier = cp_parser_identifier (parser);\n+  if (identifier == error_mark_node)\n+    return error_mark_node;\n+\n+  cp_parser_require (parser, CPP_COLON, RT_COLON);\n+\n+  /* Defer the parsing of pre/post contracts inside class definitions.  */\n+  tree contract;\n+  if (!assertion_p &&\n+      current_class_type &&\n+      TYPE_BEING_DEFINED (current_class_type))\n+    {\n+      /* Skip until we reach an unenclose ']'. If we ran into an unnested ']'\n+\t that doesn't close the attribute, return an error and let the attribute\n+\t handling code emit an error for missing ']]'.  */\n+      cp_token *first = cp_lexer_peek_token (parser->lexer);\n+      cp_parser_skip_to_closing_parenthesis_1 (parser,\n+\t\t\t\t\t       /*recovering=*/false,\n+\t\t\t\t\t       CPP_CLOSE_SQUARE,\n+\t\t\t\t\t       /*consume_paren=*/false);\n+      if (cp_lexer_peek_token (parser->lexer)->type != CPP_CLOSE_SQUARE\n+\t  || cp_lexer_peek_nth_token (parser->lexer, 2)->type != CPP_CLOSE_SQUARE)\n+\treturn error_mark_node;\n+      cp_token *last = cp_lexer_peek_token (parser->lexer);\n+\n+      /* Build a deferred-parse node.  */\n+      tree condition = make_node (DEFERRED_PARSE);\n+      DEFPARSE_TOKENS (condition) = cp_token_cache_new (first, last);\n+      DEFPARSE_INSTANTIATIONS (condition) = NULL;\n+\n+      /* And its corresponding contract.  */\n+      contract = grok_contract (attribute, mode, identifier, condition, loc);\n+    }\n+  else\n+    {\n+      /* Enable location wrappers when parsing contracts.  */\n+      auto suppression = make_temp_override (suppress_location_wrappers, 0);\n+\n+      /* Build a fake variable for the result identifier.  */\n+      tree result = NULL_TREE;\n+      if (identifier)\n+\t{\n+\t  begin_scope (sk_block, NULL_TREE);\n+\t  result = make_postcondition_variable (identifier);\n+\t  ++processing_template_decl;\n+\t}\n+\n+      /* Parse the condition, ensuring that parameters or the return variable\n+\t aren't flagged for use outside the body of a function.  */\n+      ++processing_contract_condition;\n+      cp_expr condition = cp_parser_conditional_expression (parser);\n+      --processing_contract_condition;\n+\n+      /* Try to recover from errors by scanning up to the end of the\n+\t attribute.  Sometimes we get partially parsed expressions, so\n+\t we need to search the condition for errors.  */\n+      if (contains_error_p (condition))\n+\tcp_parser_skip_up_to_closing_square_bracket (parser);\n+\n+      /* Build the contract.  */\n+      contract = grok_contract (attribute, mode, result, condition, loc);\n+\n+      /* Leave our temporary scope for the postcondition result.  */\n+      if (result)\n+\t{\n+\t  --processing_template_decl;\n+\t  pop_bindings_and_leave_scope ();\n+\t}\n+    }\n+\n+  if (!flag_contracts)\n+    {\n+      error_at (loc, \"contracts are only available with %<-fcontracts%>\");\n+      return error_mark_node;\n+    }\n+\n+  return finish_contract_attribute (attribute, contract);\n+}\n+\n+/* Parse a contract condition for a deferred contract.  */\n+\n+void cp_parser_late_contract_condition (cp_parser *parser,\n+\t\t\t\t\ttree fn,\n+\t\t\t\t\ttree attribute)\n+{\n+  tree contract = TREE_VALUE (TREE_VALUE (attribute));\n+\n+  /* Make sure we've gotten something that hasn't been parsed yet or that\n+     we're not parsing an invalid contract.  */\n+  tree condition = CONTRACT_CONDITION (contract);\n+  if (TREE_CODE (condition) != DEFERRED_PARSE)\n+    return;\n+\n+  tree identifier = NULL_TREE;\n+  if (TREE_CODE (contract) == POSTCONDITION_STMT)\n+    identifier = POSTCONDITION_IDENTIFIER (contract);\n+\n+  /* Build a fake variable for the result identifier.  */\n+  tree result = NULL_TREE;\n+  if (identifier)\n+    {\n+      /* TODO: Can we guarantee that the identifier has a location? */\n+      location_t loc = cp_expr_location (contract);\n+      tree type = TREE_TYPE (TREE_TYPE (fn));\n+      if (!check_postcondition_result (fn, type, loc))\n+\t{\n+\t  invalidate_contract (contract);\n+\t  return;\n+\t}\n+\n+      begin_scope (sk_block, NULL_TREE);\n+      result = make_postcondition_variable (identifier, type);\n+      ++processing_template_decl;\n+    }\n+\n+  /* 'this' is not allowed in preconditions of constructors or in postconditions\n+     of destructors.  Note that the previous value of this variable is\n+     established by the calling function, so we need to save it here.  */\n+  tree saved_ccr = current_class_ref;\n+  tree saved_ccp = current_class_ptr;\n+  if ((DECL_CONSTRUCTOR_P (fn) && PRECONDITION_P (contract)) ||\n+       (DECL_DESTRUCTOR_P (fn) && POSTCONDITION_P (contract)))\n+    {\n+      current_class_ref = current_class_ptr = NULL_TREE;\n+      parser->local_variables_forbidden_p |= THIS_FORBIDDEN;\n+    }\n+\n+  push_unparsed_function_queues (parser);\n+\n+  /* Push the saved tokens onto the parser's lexer stack.  */\n+  cp_token_cache *tokens = DEFPARSE_TOKENS (condition);\n+  cp_parser_push_lexer_for_tokens (parser, tokens);\n+\n+  /* Parse the condition, ensuring that parameters or the return variable\n+     aren't flagged for use outside the body of a function.  */\n+  ++processing_contract_condition;\n+  condition = cp_parser_conditional_expression (parser);\n+  --processing_contract_condition;\n+\n+  /* Revert to the main lexer.  */\n+  cp_parser_pop_lexer (parser);\n+\n+  /* Restore the queue.  */\n+  pop_unparsed_function_queues (parser);\n+\n+  current_class_ref = saved_ccr;\n+  current_class_ptr = saved_ccp;\n+\n+  /* Commit to changes.  */\n+  update_late_contract (contract, result, condition);\n+\n+  /* Leave our temporary scope for the postcondition result.  */\n+  if (result)\n+    {\n+      --processing_template_decl;\n+      pop_bindings_and_leave_scope ();\n+    }\n+}\n+\n /* Parse a standard C++-11 attribute specifier.\n \n    attribute-specifier:\n      [ [ attribute-using-prefix [opt] attribute-list ] ]\n+     contract-attribute-specifier\n      alignment-specifier\n \n    attribute-using-prefix:\n      using attribute-namespace :\n \n    alignment-specifier:\n      alignas ( type-id ... [opt] )\n-     alignas ( alignment-expression ... [opt] ).  */\n+     alignas ( alignment-expression ... [opt] ).\n+\n+   Extensions for contracts:\n+\n+   contract-attribute-specifier:\n+     [ [ assert :  contract-mode [opt] : conditional-expression ] ]\n+     [ [ pre :  contract-mode [opt] : conditional-expression ] ]\n+     [ [ post :  contract-mode [opt] identifier [opt] :\n+\t conditional-expression ] ]  */\n \n static tree\n cp_parser_std_attribute_spec (cp_parser *parser)\n@@ -29339,10 +29813,27 @@ cp_parser_std_attribute_spec (cp_parser *parser)\n       && cp_lexer_peek_nth_token (parser->lexer, 2)->type == CPP_OPEN_SQUARE)\n     {\n       tree attr_ns = NULL_TREE;\n+      tree attr_name = NULL_TREE;\n \n       cp_lexer_consume_token (parser->lexer);\n       cp_lexer_consume_token (parser->lexer);\n \n+      token = cp_lexer_peek_token (parser->lexer);\n+      if (token->type == CPP_NAME)\n+\t{\n+\t  attr_name = token->u.value;\n+\t  attr_name = canonicalize_attr_name (attr_name);\n+\t}\n+\n+      /* Handle contract-attribute-specs specially.  */\n+      if (attr_name && contract_attribute_p (attr_name))\n+\t{\n+\t  tree attrs = cp_parser_contract_attribute_spec (parser, attr_name);\n+\t  if (attrs != error_mark_node)\n+\t    attributes = attrs;\n+\t  goto finish_attrs;\n+\t}\n+\n       if (cp_lexer_next_token_is_keyword (parser->lexer, RID_USING))\n \t{\n \t  token = cp_lexer_peek_nth_token (parser->lexer, 2);\n@@ -29371,6 +29862,7 @@ cp_parser_std_attribute_spec (cp_parser *parser)\n \n       attributes = cp_parser_std_attribute_list (parser, attr_ns);\n \n+      finish_attrs:\n       if (!cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE)\n \t  || !cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE))\n \tcp_parser_skip_to_end_of_statement (parser);\n@@ -32397,6 +32889,14 @@ cp_parser_save_default_args (cp_parser* parser, tree decl)\n   tree spec = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (decl));\n   if (UNPARSED_NOEXCEPT_SPEC_P (spec))\n     vec_safe_push (unparsed_noexcepts, decl);\n+\n+  /* Contracts are deferred.  */\n+  for (tree attr = DECL_ATTRIBUTES (decl); attr; attr = TREE_CHAIN (attr))\n+    if (cxx_contract_attribute_p (attr))\n+      {\n+\tvec_safe_push (unparsed_contracts, decl);\n+\tbreak;\n+      }\n }\n \n /* DEFAULT_ARG contains the saved tokens for the initializer of DECL,"}, {"sha": "5737146dd424daf7cde7abfe8364f6958c8bd0ba", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -178,6 +178,9 @@ struct GTY(()) cp_unparsed_functions_entry {\n \n   /* Functions with noexcept-specifiers that require post-processing.  */\n   vec<tree, va_gc> *noexcepts;\n+\n+  /* Functions with contract attributes that require post-processing.  */\n+  vec<tree, va_gc> *contracts;\n };\n \n "}, {"sha": "aa459a7df2621b197ab18ed67eed4315ff29b3f6", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 160, "deletions": 4, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -217,7 +217,6 @@ static tree get_underlying_template (tree);\n static tree tsubst_attributes (tree, tree, tsubst_flags_t, tree);\n static tree canonicalize_expr_argument (tree, tsubst_flags_t);\n static tree make_argument_pack (tree);\n-static void register_parameter_specializations (tree, tree);\n static tree enclosing_instantiation_of (tree tctx);\n static void instantiate_body (tree pattern, tree args, tree d, bool nested);\n static tree maybe_dependent_member_ref (tree, tree, tsubst_flags_t, tree);\n@@ -1968,6 +1967,16 @@ register_local_specialization (tree spec, tree tmpl)\n   local_specializations->put (tmpl, spec);\n }\n \n+/* Registers T as a specialization of itself.  This is used to preserve\n+   the references to already-parsed parameters when instantiating\n+   postconditions.  */\n+\n+void\n+register_local_identity (tree t)\n+{\n+  local_specializations->put (t, t);\n+}\n+\n /* TYPE is a class type.  Returns true if TYPE is an explicitly\n    specialized class.  */\n \n@@ -3161,8 +3170,10 @@ check_explicit_specialization (tree declarator,\n \t\t       parm = DECL_CHAIN (parm))\n \t\t    DECL_CONTEXT (parm) = result;\n \t\t}\n-\t      return register_specialization (tmpl, gen_tmpl, targs,\n+\t      decl = register_specialization (tmpl, gen_tmpl, targs,\n \t\t\t\t\t      is_friend, 0);\n+\t      remove_contract_attributes (result);\n+\t      return decl;\n \t    }\n \n \t  /* Set up the DECL_TEMPLATE_INFO for DECL.  */\n@@ -3262,6 +3273,10 @@ check_explicit_specialization (tree declarator,\n \t\t\t\t\t      is_friend, 0);\n \t    }\n \n+\t  /* If this is a specialization, splice any contracts that may have\n+\t     been inherited from the template, removing them.  */\n+\t  if (decl != error_mark_node && DECL_TEMPLATE_SPECIALIZATION (decl))\n+\t    remove_contract_attributes (decl);\n \n \t  /* A 'structor should already have clones.  */\n \t  gcc_assert (decl == error_mark_node\n@@ -11575,6 +11590,113 @@ can_complete_type_without_circularity (tree type)\n static tree tsubst_omp_clauses (tree, enum c_omp_region_type, tree,\n \t\t\t\ttsubst_flags_t, tree);\n \n+/* Instantiate the contract statement.  */\n+\n+static tree\n+tsubst_contract (tree decl, tree t, tree args, tsubst_flags_t complain,\n+\t\t tree in_decl)\n+{\n+  tree type = decl ? TREE_TYPE (TREE_TYPE (decl)) : NULL_TREE;\n+  bool auto_p  = type_uses_auto (type);\n+\n+  tree r = copy_node (t);\n+\n+  /* Rebuild the result variable.  */\n+  if (POSTCONDITION_P (t) && POSTCONDITION_IDENTIFIER (t))\n+    {\n+      tree oldvar = POSTCONDITION_IDENTIFIER (t);\n+\n+      tree newvar = copy_node (oldvar);\n+      TREE_TYPE (newvar) = type;\n+      DECL_CONTEXT (newvar) = decl;\n+      POSTCONDITION_IDENTIFIER (r) = newvar;\n+\n+      /* Make sure the postcondition is valid.  */\n+      location_t loc = DECL_SOURCE_LOCATION (oldvar);\n+      if (!auto_p)\n+\tif (!check_postcondition_result (decl, type, loc))\n+\t  return invalidate_contract (r);\n+\n+      /* Make the variable available for lookup.  */\n+      register_local_specialization (newvar, oldvar);\n+    }\n+\n+  /* Instantiate the condition.  If the return type is undeduced, process\n+     the expression as if inside a template to avoid spurious type errors.  */\n+  if (auto_p)\n+    ++processing_template_decl;\n+  ++processing_contract_condition;\n+  CONTRACT_CONDITION (r)\n+      = tsubst_expr (CONTRACT_CONDITION (t), args, complain, in_decl);\n+  --processing_contract_condition;\n+  if (auto_p)\n+    --processing_template_decl;\n+\n+  /* And the comment.  */\n+  CONTRACT_COMMENT (r)\n+      = tsubst_expr (CONTRACT_COMMENT (r), args, complain, in_decl);\n+\n+  return r;\n+}\n+\n+/* Update T by instantiating its contract attribute.  */\n+\n+static void\n+tsubst_contract_attribute (tree decl, tree t, tree args,\n+\t\t\t   tsubst_flags_t complain, tree in_decl)\n+{\n+  /* For non-specializations, adjust the current declaration to the most general\n+     version of in_decl. Because we defer the instantiation of contracts as long\n+     as possible, they are still written in terms of the parameters (and return\n+     type) of the most general template.  */\n+  tree tmpl = DECL_TI_TEMPLATE (in_decl);\n+  if (!DECL_TEMPLATE_SPECIALIZATION (tmpl))\n+    in_decl = DECL_TEMPLATE_RESULT (most_general_template (in_decl));\n+  local_specialization_stack specs (lss_copy);\n+  register_parameter_specializations (in_decl, decl);\n+\n+  /* Get the contract to be instantiated.  */\n+  tree contract = CONTRACT_STATEMENT (t);\n+\n+  /* Use the complete set of template arguments for instantiation. The\n+     contract may not have been instantiated and still refer to outer levels\n+     of template parameters.  */\n+  args = DECL_TI_ARGS (decl);\n+\n+  /* For member functions, make this available for semantic analysis.  */\n+  tree save_ccp = current_class_ptr;\n+  tree save_ccr = current_class_ref;\n+  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (decl))\n+    {\n+      tree arg_types = TYPE_ARG_TYPES (TREE_TYPE (decl));\n+      tree this_type = TREE_TYPE (TREE_VALUE (arg_types));\n+      inject_this_parameter (this_type, cp_type_quals (this_type));\n+    }\n+\n+  contract = tsubst_contract (decl, contract, args, complain, in_decl);\n+\n+  current_class_ptr = save_ccp;\n+  current_class_ref = save_ccr;\n+\n+  /* Rebuild the attribute.  */\n+  TREE_VALUE (t) = build_tree_list (NULL_TREE, contract);\n+}\n+\n+/* Rebuild the attribute list for DECL, substituting into contracts\n+   as needed.  */\n+\n+void\n+tsubst_contract_attributes (tree decl, tree args, tsubst_flags_t complain, tree in_decl)\n+{\n+  tree list = copy_list (DECL_ATTRIBUTES (decl));\n+  for (tree attr = list; attr; attr = CONTRACT_CHAIN (attr))\n+    {\n+      if (cxx_contract_attribute_p (attr))\n+\ttsubst_contract_attribute (decl, attr, args, complain, in_decl);\n+    }\n+  DECL_ATTRIBUTES (decl) = list;\n+}\n+\n /* Instantiate a single dependent attribute T (a TREE_LIST), and return either\n    T or a new TREE_LIST, possibly a chain in the case of a pack expansion.  */\n \n@@ -11584,6 +11706,10 @@ tsubst_attribute (tree t, tree *decl_p, tree args,\n {\n   gcc_assert (ATTR_IS_DEPENDENT (t));\n \n+  /* Note that contract attributes are never substituted from this function.\n+     Their instantiation is triggered by regenerate_from_template_decl when\n+     we instantiate the body of the function.  */\n+\n   tree val = TREE_VALUE (t);\n   if (val == NULL_TREE)\n     /* Nothing to do.  */;\n@@ -17108,7 +17234,9 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t\t  = do_auto_deduction (TREE_TYPE (r), init, auto_node,\n \t\t\t\t\t       complain, adc_variable_type);\n \t\t    }\n-\t\t  gcc_assert (cp_unevaluated_operand || TREE_STATIC (r)\n+\t\t  gcc_assert (cp_unevaluated_operand\n+\t\t\t      || processing_contract_condition\n+\t\t\t      || TREE_STATIC (r)\n \t\t\t      || decl_constant_var_p (r)\n \t\t\t      || seen_error ());\n \t\t  if (!processing_template_decl\n@@ -18606,6 +18734,19 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       finish_using_directive (USING_STMT_NAMESPACE (t), /*attribs=*/NULL_TREE);\n       break;\n \n+    case PRECONDITION_STMT:\n+    case POSTCONDITION_STMT:\n+      gcc_unreachable ();\n+\n+    case ASSERTION_STMT:\n+      {\n+\tr = tsubst_contract (NULL_TREE, t, args, complain, in_decl);\n+\tif (r != error_mark_node)\n+\t  add_stmt (r);\n+\tRETURN (r);\n+      }\n+      break;\n+\n     case DECL_EXPR:\n       {\n \ttree decl, pattern_decl;\n@@ -26088,6 +26229,21 @@ regenerate_decl_from_template (tree decl, tree tmpl, tree args)\n \t    DECL_CONTEXT (t) = decl;\n \t}\n \n+      if (DECL_CONTRACTS (decl))\n+\t{\n+\t  /* If we're regenerating a specialization, the contracts will have\n+\t     been copied from the most general template. Replace those with\n+\t     the ones from the actual specialization.  */\n+\t  tree tmpl = DECL_TI_TEMPLATE (decl);\n+\t  if (DECL_TEMPLATE_SPECIALIZATION (tmpl))\n+\t    {\n+\t      remove_contract_attributes (decl);\n+\t      copy_contract_attributes (decl, code_pattern);\n+\t    }\n+\n+\t  tsubst_contract_attributes (decl, args, tf_warning_or_error, code_pattern);\n+\t}\n+\n       /* Merge additional specifiers from the CODE_PATTERN.  */\n       if (DECL_DECLARED_INLINE_P (code_pattern)\n \t  && !DECL_DECLARED_INLINE_P (decl))\n@@ -26333,7 +26489,7 @@ maybe_instantiate_noexcept (tree fn, tsubst_flags_t complain)\n /* We're starting to process the function INST, an instantiation of PATTERN;\n    add their parameters to local_specializations.  */\n \n-static void\n+void\n register_parameter_specializations (tree pattern, tree inst)\n {\n   tree tmpl_parm = DECL_ARGUMENTS (pattern);"}, {"sha": "0dbb3be1ee74ec61838898dfaee97c729f6c3f47", "filename": "gcc/cp/search.cc", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fsearch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fsearch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.cc?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"spellcheck-tree.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include \"tree-inline.h\"\n \n static int is_subobject_of_p (tree, tree);\n static tree dfs_lookup_base (tree, void *);\n@@ -2082,6 +2083,33 @@ check_final_overrider (tree overrider, tree basefn)\n \t}\n       return 0;\n     }\n+\n+  if (!DECL_HAS_CONTRACTS_P (basefn) && DECL_HAS_CONTRACTS_P (overrider))\n+    {\n+      auto_diagnostic_group d;\n+      error (\"function with contracts %q+D overriding contractless function\",\n+\t     overrider);\n+      inform (DECL_SOURCE_LOCATION (basefn),\n+\t      \"overridden function is %qD\", basefn);\n+      return 0;\n+    }\n+  else if (DECL_HAS_CONTRACTS_P (basefn) && !DECL_HAS_CONTRACTS_P (overrider))\n+    {\n+      /* We're inheriting basefn's contracts; create a copy of them but\n+\t replace references to their parms to our parms.  */\n+      inherit_base_contracts (overrider, basefn);\n+    }\n+  else if (DECL_HAS_CONTRACTS_P (basefn) && DECL_HAS_CONTRACTS_P (overrider))\n+    {\n+      /* We're in the process of completing the overrider's class, which means\n+\t our conditions definitely are not parsed so simply chain on the\n+\t basefn for later checking.\n+\n+\t Note that OVERRIDER's contracts will have been fully parsed at the\n+\t point the deferred match is run.  */\n+      defer_guarded_contract_match (overrider, basefn, DECL_CONTRACTS (basefn));\n+    }\n+\n   if (DECL_FINAL_P (basefn))\n     {\n       auto_diagnostic_group d;"}, {"sha": "9401b35a789f2b0ffb56e6b313ab3a586e50ccaa", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -610,7 +610,8 @@ set_cleanup_locs (tree stmts, location_t loc)\n   if (TREE_CODE (stmts) == CLEANUP_STMT)\n     {\n       tree t = CLEANUP_EXPR (stmts);\n-      protected_set_expr_location (t, loc);\n+      if (t && TREE_CODE (t) != POSTCONDITION_STMT)\n+\tprotected_set_expr_location (t, loc);\n       /* Avoid locus differences for C++ cdtor calls depending on whether\n \t cdtor_returns_this: a conversion to void is added to discard the return\n \t value, and this conversion ends up carrying the location, and when it\n@@ -2169,14 +2170,23 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope,\n \n   /* DR 613/850: Can use non-static data members without an associated\n      object in sizeof/decltype/alignof.  */\n-  if (is_dummy_object (object) && cp_unevaluated_operand == 0\n+  if (is_dummy_object (object)\n+      && !cp_unevaluated_operand\n       && (!processing_template_decl || !current_class_ref))\n     {\n       if (complain & tf_error)\n \t{\n \t  if (current_function_decl\n \t      && DECL_STATIC_FUNCTION_P (current_function_decl))\n \t    error (\"invalid use of member %qD in static member function\", decl);\n+\t  else if (current_function_decl\n+\t\t   && processing_contract_condition\n+\t\t   && DECL_CONSTRUCTOR_P (current_function_decl))\n+\t    error (\"invalid use of member %qD in constructor %<pre%> contract\", decl);\n+\t  else if (current_function_decl\n+\t\t   && processing_contract_condition\n+\t\t   && DECL_DESTRUCTOR_P (current_function_decl))\n+\t    error (\"invalid use of member %qD in destructor %<post%> contract\", decl);\n \t  else\n \t    error (\"invalid use of non-static data member %qD\", decl);\n \t  inform (DECL_SOURCE_LOCATION (decl), \"declared here\");\n@@ -3014,6 +3024,10 @@ finish_this_expr (void)\n   tree fn = current_nonlambda_function ();\n   if (fn && DECL_STATIC_FUNCTION_P (fn))\n     error (\"%<this%> is unavailable for static member functions\");\n+  else if (fn && processing_contract_condition && DECL_CONSTRUCTOR_P (fn))\n+    error (\"invalid use of %<this%> before it is valid\");\n+  else if (fn && processing_contract_condition && DECL_DESTRUCTOR_P (fn))\n+    error (\"invalid use of %<this%> after it is valid\");\n   else if (fn)\n     error (\"invalid use of %<this%> in non-member function\");\n   else\n@@ -3987,6 +4001,9 @@ process_outer_var_ref (tree decl, tsubst_flags_t complain, bool odr_use)\n \t}\n       return error_mark_node;\n     }\n+  else if (processing_contract_condition && (TREE_CODE (decl) == PARM_DECL))\n+    /* Use of a parameter in a contract condition is fine.  */\n+    return decl;\n   else\n     {\n       if (complain & tf_error)\n@@ -4119,7 +4136,8 @@ finish_id_expression_1 (tree id_expression,\n \t body, except inside an unevaluated context (i.e. decltype).  */\n       if (TREE_CODE (decl) == PARM_DECL\n \t  && DECL_CONTEXT (decl) == NULL_TREE\n-\t  && !cp_unevaluated_operand)\n+\t  && !cp_unevaluated_operand\n+\t  && !processing_contract_condition)\n \t{\n \t  *error_msg = G_(\"use of parameter outside function body\");\n \t  return error_mark_node;\n@@ -12290,6 +12308,10 @@ apply_deduced_return_type (tree fco, tree return_type)\n \n   TREE_TYPE (fco) = change_return_type (return_type, TREE_TYPE (fco));\n \n+  maybe_update_postconditions (fco);\n+\n+  /* Apply the type to the result object.  */\n+\n   result = DECL_RESULT (fco);\n   if (result == NULL_TREE)\n     return;"}, {"sha": "04a055d9d77b35392bcfdea1db32177f6f09188b", "filename": "gcc/cp/tree.cc", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.cc?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -46,6 +46,7 @@ static tree verify_stmt_tree_r (tree *, int *, void *);\n \n static tree handle_init_priority_attribute (tree *, tree, tree, int, bool *);\n static tree handle_abi_tag_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_contract_attribute (tree *, tree, tree, int, bool *);\n \n /* If REF is an lvalue, returns the kind of lvalue that REF is.\n    Otherwise, returns clk_none.  */\n@@ -3885,6 +3886,50 @@ called_fns_equal (tree t1, tree t2)\n     return cp_tree_equal (t1, t2);\n }\n \n+bool comparing_override_contracts;\n+\n+/* In a component reference, return the innermost object of\n+   the postfix-expression.  */\n+\n+static tree\n+get_innermost_component (tree t)\n+{\n+  gcc_assert (TREE_CODE (t) == COMPONENT_REF);\n+  while (TREE_CODE (t) == COMPONENT_REF)\n+    t = TREE_OPERAND (t, 0);\n+  return t;\n+}\n+\n+/* Returns true if T is a possibly converted 'this' or '*this' expression.  */\n+\n+static bool\n+is_this_expression (tree t)\n+{\n+  t = get_innermost_component (t);\n+  /* See through deferences and no-op conversions.  */\n+  if (TREE_CODE (t) == INDIRECT_REF)\n+    t = TREE_OPERAND (t, 0);\n+  if (TREE_CODE (t) == NOP_EXPR)\n+    t = TREE_OPERAND (t, 0);\n+  return is_this_parameter (t);\n+}\n+\n+static bool\n+comparing_this_references (tree t1, tree t2)\n+{\n+  return is_this_expression (t1) && is_this_expression (t2);\n+}\n+\n+static bool\n+equivalent_member_references (tree t1, tree t2)\n+{\n+  if (!comparing_this_references (t1, t2))\n+    return false;\n+  t1 = TREE_OPERAND (t1, 1);\n+  t2 = TREE_OPERAND (t2, 1);\n+  return t1 == t2;\n+}\n+\n /* Return truthvalue of whether T1 is the same tree structure as T2.\n    Return 1 if they are the same. Return 0 if they are different.  */\n \n@@ -4219,6 +4264,13 @@ cp_tree_equal (tree t1, tree t2)\n \treturn false;\n       return true;\n \n+    case COMPONENT_REF:\n+      /* If we're comparing contract conditions of overrides, member references\n+\t compare equal if they designate the same member.  */\n+      if (comparing_override_contracts)\n+\treturn equivalent_member_references (t1, t2);\n+      break;\n+\n     default:\n       break;\n     }\n@@ -5062,6 +5114,10 @@ const struct attribute_spec std_attribute_table[] =\n     handle_noreturn_attribute, attr_noreturn_exclusions },\n   { \"carries_dependency\", 0, 0, true, false, false, false,\n     handle_carries_dependency_attribute, NULL },\n+  { \"pre\", 0, -1, false, false, false, false,\n+    handle_contract_attribute, NULL },\n+  { \"post\", 0, -1, false, false, false, false,\n+    handle_contract_attribute, NULL },\n   { NULL, 0, 0, false, false, false, false, NULL, NULL }\n };\n \n@@ -5306,6 +5362,17 @@ handle_abi_tag_attribute (tree* node, tree name, tree args,\n   return NULL_TREE;\n }\n \n+/* Perform checking for contract attributes.  */\n+\n+tree\n+handle_contract_attribute (tree *ARG_UNUSED (node), tree ARG_UNUSED (name),\n+\t\t\t   tree ARG_UNUSED (args), int ARG_UNUSED (flags),\n+\t\t\t   bool *ARG_UNUSED (no_add_attrs))\n+{\n+  /* TODO: Is there any checking we could do here?  */\n+  return NULL_TREE;\n+}\n+\n /* Return a new PTRMEM_CST of the indicated TYPE.  The MEMBER is the\n    thing pointed to by the constant.  */\n "}, {"sha": "d5757b27f4990b81efd037ae20ce9798b9046f26", "filename": "gcc/cp/typeck.cc", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Ftypeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fcp%2Ftypeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.cc?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -11247,11 +11247,22 @@ check_return_expr (tree retval, bool *no_warning)\n \n   /* Actually copy the value returned into the appropriate location.  */\n   if (retval && retval != result)\n-    retval = cp_build_init_expr (result, retval);\n+    {\n+      /* If there's a postcondition for a scalar return value, wrap\n+\t retval in a call to the postcondition function.  */\n+      if (tree post = apply_postcondition_to_return (retval))\n+\tretval = post;\n+      retval = cp_build_init_expr (result, retval);\n+    }\n \n   if (tree set = maybe_set_retval_sentinel ())\n     retval = build2 (COMPOUND_EXPR, void_type_node, retval, set);\n \n+  /* If there's a postcondition for an aggregate return value, call the\n+     postcondition function after the return object is initialized.  */\n+  if (tree post = apply_postcondition_to_return (result))\n+    retval = build2 (COMPOUND_EXPR, void_type_node, retval, post);\n+\n   return retval;\n }\n "}, {"sha": "330da6eb5d4092dc52e7e15e4f90c3d4f066faec", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -3121,6 +3121,85 @@ of a loop too many expressions need to be evaluated, the resulting constexpr\n evaluation might take too long.\n The default is 33554432 (1<<25).\n \n+@item -fcontracts\n+@opindex fcontracts\n+Enable experimental support for the C++ Contracts feature, as briefly\n+added to and then removed from the C++20 working paper (N4820).  The\n+implementation also includes proposed enhancements from papers P1290,\n+P1332, and P1429.  This functionality is intended mostly for those\n+interested in experimentation towards refining the feature to get it\n+into shape for a future C++ standard.\n+\n+On violation of a checked contract, the violation handler is called.\n+Users can replace the violation handler by defining\n+@smallexample\n+void handle_contract_violation (const std::experimental::contract_violation&);\n+@end smallexample\n+\n+There are different sets of additional flags that can be used together\n+to specify which contracts will be checked and how, for N4820\n+contracts, P1332 contracts, or P1429 contracts; these sets cannot be\n+used together.\n+\n+@table @gcctabopt\n+@item -fcontract-mode=[on|off]\n+@opindex fcontract-mode\n+Control whether any contracts have any semantics at all.  Defaults to on.\n+\n+@item -fcontract-assumption-mode=[on|off]\n+@opindex fcontract-assumption-mode\n+[N4820] Control whether contracts with level @samp{axiom}\n+should have the assume semantic.  Defaults to on.\n+\n+@item -fcontract-build-level=[off|default|audit]\n+@opindex fcontract-build-level\n+[N4820] Specify which level of contracts to generate checks\n+for.  Defaults to @samp{default}.\n+\n+@item -fcontract-continuation-mode=[on|off]\n+@opindex fcontract-continuation-mode\n+[N4820] Control whether to allow the program to continue executing\n+after a contract violation.  That is, do checked contracts have the\n+@samp{maybe} semantic described below rather than the @samp{never}\n+semantic.  Defaults to off.\n+\n+@item -fcontract-role=<name>:<default>,<audit>,<axiom>\n+@opindex fcontract-role\n+[P1332] Specify the concrete semantics for each contract level\n+of a particular contract role.\n+\n+@item -fcontract-semantic=[default|audit|axiom]:<semantic>\n+[P1429] Specify the concrete semantic for a particular\n+contract level.\n+\n+@item -fcontract-strict-declarations=[on|off]\n+@opindex fcontract-strict-declarations\n+Control whether to reject adding contracts to a function after its\n+first declaration.  Defaults to off.\n+@end table\n+\n+The possible concrete semantics for that can be specified with\n+@samp{-fcontract-role} or @samp{-fcontract-semantic} are:\n+\n+@table @code\n+@item ignore\n+This contract has no effect.\n+\n+@item assume\n+This contract is treated like C++23 @code{[[assume]]}.\n+\n+@item check_never_continue\n+@itemx never\n+@itemx abort\n+This contract is checked.  If it fails, the violation handler is\n+called.  If the handler returns, @code{std::terminate} is called.\n+\n+@item check_maybe_continue\n+@itemx maybe\n+This contract is checked.  If it fails, the violation handler is\n+called.  If the handler returns, execution continues normally.\n+@end table\n+\n @item -fcoroutines\n @opindex fcoroutines\n Enable support for the C++ coroutines extension (experimental)."}, {"sha": "4f01a9506a77933335a647179a5116480922b3d9", "filename": "gcc/testsuite/g++.dg/contracts/backtrace_handler/Makefile", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fbacktrace_handler%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fbacktrace_handler%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fbacktrace_handler%2FMakefile?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,13 @@\n+CXXFLAGS=--std=c++17 -g\n+\n+default: assert_fail libhandle_contract_violation.so\n+\n+run: default\n+\tLD_PRELOAD=./libhandle_contract_violation.so ./assert_fail\n+\n+./libhandle_contract_violation.so: ./handle_contract_violation.cpp\n+\t${CXX} ${CXXFLAGS} -shared -fPIC -o $@ $<\n+\n+clean:\n+\trm -fr ./libhandle_contract_violation.so ./assert_fail\n+"}, {"sha": "df729f0d6095a247d5b6e15e1bfc7a8d67b8e879", "filename": "gcc/testsuite/g++.dg/contracts/backtrace_handler/README", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fbacktrace_handler%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fbacktrace_handler%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fbacktrace_handler%2FREADME?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,12 @@\n+build and install gcc to $prefix, then to see the raw backtrace info run:\n+LD_LIBRARY_PATH=$prefix/lib64 CXX=$prefix/bin/g++ make run\n+\n+for a filtered view using addr2line, see ./prettytrace.sh:\n+LD_LIBRARY_PATH=$prefix/lib64 CXX=$prefix/bin/g++ make run |& ./prettytrace.sh\n+\n+prettytrace.sh relies on addr2line and c++filt to lookup and demangle names,\n+and misc coreutils\n+\n+example_out.txt has an example of the raw output while example_pretty.txt\n+shows the corresponding prettified output\n+"}, {"sha": "08c64bc2849aa99a90b93c521b5f11b5e9426b43", "filename": "gcc/testsuite/g++.dg/contracts/backtrace_handler/assert_fail.cpp", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fbacktrace_handler%2Fassert_fail.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fbacktrace_handler%2Fassert_fail.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fbacktrace_handler%2Fassert_fail.cpp?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,23 @@\n+void fun1() {\n+  int x = 0;\n+  [[ assert: x < 0 ]];\n+}\n+namespace tns {\n+  void fun2() {\n+    fun1();\n+  }\n+}\n+template<typename T>\n+void fun3(T a) {\n+  tns::fun2();\n+}\n+void fun4() {\n+  fun3(5);\n+}\n+int main(int, char**) {\n+  void (*fp)() = nullptr;\n+  fp = fun4;\n+  fp();\n+  return 0;\n+}\n+"}, {"sha": "903ef22f2f5261a10fda9b8bd42026f34eacb2ff", "filename": "gcc/testsuite/g++.dg/contracts/backtrace_handler/example_out.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fbacktrace_handler%2Fexample_out.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fbacktrace_handler%2Fexample_out.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fbacktrace_handler%2Fexample_out.txt?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,12 @@\n+LD_PRELOAD=./libhandle_contract_violation.so ./assert_fail\n+contract violation: assert_fail.cpp:3: fun1::x < 0 is false [with contract level=default]\n+violation occurs here:\n+./assert_fail[0x4011ad]\n+./assert_fail[0x4011e0]\n+./assert_fail[0x401230]\n+./assert_fail[0x4011f1]\n+./assert_fail[0x401219]\n+/usr/lib/libc.so.6(__libc_start_main+0xf3)[0x7f26e4fa9223]\n+./assert_fail[0x4010be]\n+[0x0]\n+end of violation"}, {"sha": "9d5d481a9efcbf3580a2ff96d99bfe2bd82d2ed0", "filename": "gcc/testsuite/g++.dg/contracts/backtrace_handler/example_pretty.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fbacktrace_handler%2Fexample_pretty.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fbacktrace_handler%2Fexample_pretty.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fbacktrace_handler%2Fexample_pretty.txt?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,8 @@\n+LD_PRELOAD=./libhandle_contract_violation.so ./assert_fail\n+contract violation: assert_fail.cpp:3: fun1::x < 0 is false [with contract level=default]\n+violation occurs here:\n+    assert_fail.cpp:fun1():4\n+    assert_fail.cpp:tns::fun2():8\n+    assert_fail.cpp:void fun3<int>(int):13\n+    assert_fail.cpp:fun4():16\n+    assert_fail.cpp:main:21"}, {"sha": "bfbb97ec02ef6ef2bef879ae7c9b96dc4d5c06a1", "filename": "gcc/testsuite/g++.dg/contracts/backtrace_handler/handle_contract_violation.cpp", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fbacktrace_handler%2Fhandle_contract_violation.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fbacktrace_handler%2Fhandle_contract_violation.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fbacktrace_handler%2Fhandle_contract_violation.cpp?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,26 @@\n+#include <iostream>\n+#include <contract>\n+#include <execinfo.h>\n+#include <unistd.h>\n+\n+static constexpr int MAX_BACKTRACE_DEPTH = 128;\n+\n+void handle_contract_violation(const std::contract_violation &violation) {\n+  size_t _backtraceSize{0};\n+  void *_backtrace[MAX_BACKTRACE_DEPTH]{};\n+\n+  _backtraceSize = backtrace(_backtrace, MAX_BACKTRACE_DEPTH);\n+  if(_backtraceSize == MAX_BACKTRACE_DEPTH)\n+    std::cerr << \"warning: backtrace may have been truncated\" << std::endl;\n+\n+  std::cerr << \"contract violation: \" << violation.file_name()\n+    << \":\" << violation.line_number()\n+    << \": \" << violation.comment() << \" is false\"\n+    << \" [with contract level=\" << violation.assertion_level() << \"]\" << std::endl\n+    << \"violation occurs here:\" << std::endl;\n+  // skip the stack frame of handle_contract_violation and\n+  // on_contract_violation to get to wherever the assert was\n+  backtrace_symbols_fd(_backtrace + 2, _backtraceSize - 1, STDERR_FILENO);\n+  std::cerr << \"end of violation\" << std::endl;\n+}\n+"}, {"sha": "1978cd1c164d0a3ac56b1446599e049d98993c77", "filename": "gcc/testsuite/g++.dg/contracts/backtrace_handler/prettytrace.sh", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fbacktrace_handler%2Fprettytrace.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fbacktrace_handler%2Fprettytrace.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fbacktrace_handler%2Fprettytrace.sh?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,30 @@\n+#!/bin/bash\n+\n+inViolation=\"false\"\n+sed 's/^/:/' /dev/stdin | while read -r line; do\n+  line=\"$(echo \"$line\" | sed 's/^://')\"\n+\n+  if [[ \"${inViolation}\" == \"false\" ]]; then\n+    echo \"$line\"\n+    if [[ -n \"$(echo \"$line\" | grep 'violation occurs here:')\" ]]; then\n+      inViolation=\"true\"\n+    fi\n+    continue\n+  fi\n+\n+  if [[ -n \"$(echo \"$line\" | grep 'end of violation')\" ]]; then\n+    inViolation=\"false\"\n+    continue\n+  fi\n+\n+  addr=\"$(echo \"$line\" | sed -r 's/.*\\[0x([a-f0-9]+)\\]$/\\1/')\"\n+  bin=\"$(echo \"$line\" | sed -r 's/^([^([]*).*/\\1/')\"\n+  [[ -n \"${bin}\" ]] || continue\n+  t=\"$(addr2line -e \"$bin\" \"$addr\" -f)\"\n+  file=\"$(echo \"$t\" | tail -1 | tr ':' '\\n' | head -1)\"\n+  file=\"$(echo \"$file\" | sed -r \"s:^$(pwd)/?::\")\"\n+  line=\"$(echo \"$t\" | tail -1 | tr ':' '\\n' | tail -1 | cut -d' ' -f1)\"\n+  func=\"$(echo \"$t\" | head -1 | c++filt)\"\n+  [[ $file != \"??\" ]] && echo \"    $file:$func:$line\"\n+done\n+"}, {"sha": "a3a298210177c79f2168b9179a2c614c50843d6f", "filename": "gcc/testsuite/g++.dg/contracts/contracts-access1.C", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-access1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-access1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-access1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,128 @@\n+// ensure that that preconditions can access public, protected, and private\n+// members of the current and base classes\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+\n+struct Base\n+{\n+  int pub{-1};\n+\n+  virtual int b()\n+    [[ pre: pub > 0 ]]\n+    [[ pre: pro > 0 ]]\n+    [[ pre: pri > 0 ]]\n+  {\n+    return pub * pro * pri;\n+  }\n+\n+  protected:\n+    int pro{-1};\n+    int pri{-1};\n+};\n+\n+struct Child : Base\n+{\n+  int fun()\n+    [[ pre: pub > 0 ]]\n+    [[ pre: pro > 0 ]]\n+    [[ pre: pri > 0 ]]\n+  {\n+    return pub * pro;\n+  }\n+};\n+\n+struct VChild : Base\n+{\n+  int b()\n+    [[ pre: pub > 0 ]]\n+    [[ pre: pro > 0 ]]\n+    [[ pre: pri > 0 ]]\n+  {\n+    return pub * pro;\n+  }\n+};\n+\n+template<typename B>\n+struct TChild : B\n+{\n+  int fun()\n+    [[ pre: B::pub > 0 ]]\n+    [[ pre: B::pro > 0 ]]\n+    [[ pre: B::pri > 0 ]]\n+  {\n+    return B::pub * B::pro;\n+  }\n+};\n+\n+struct PubBase\n+{\n+  int pub{-1};\n+  int pro{-1};\n+  int pri{-1};\n+};\n+\n+struct PubChild : PubBase\n+{\n+  int fun()\n+    [[ pre: pub > 0 ]]\n+    [[ pre: pro > 0 ]]\n+    [[ pre: pri > 0 ]]\n+  {\n+    return pub * pro;\n+  }\n+};\n+\n+template<typename B>\n+struct TPubChild : B\n+{\n+  int fun()\n+    [[ pre: B::pub > 0 ]]\n+    [[ pre: B::pro > 0 ]]\n+    [[ pre: B::pri > 0 ]]\n+  {\n+    return B::pub * B::pro;\n+  }\n+};\n+\n+int main()\n+{\n+  Base base{};\n+  base.b();\n+\n+  Child child{};\n+  child.fun();\n+\n+  VChild vchild{};\n+  vchild.b();\n+\n+  TChild<Base> tchild{};\n+  tchild.fun();\n+\n+  PubChild pubchild{};\n+  pubchild.fun();\n+\n+  TPubChild<PubBase> tpubchild;\n+  tpubchild.fun();\n+\n+  return 0;\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 11 Base::b .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 12 Base::b .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 13 Base::b .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 26 Child::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 27 Child::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 28 Child::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 37 VChild::b .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 38 VChild::b .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 39 VChild::b .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 49 TChild<Base>::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 50 TChild<Base>::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 51 TChild<Base>::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 67 PubChild::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 68 PubChild::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 69 PubChild::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 79 TPubChild<PubBase>::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 80 TPubChild<PubBase>::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 81 TPubChild<PubBase>::fun .*(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "71388501ea76d27d4243c78461d700604c81b471", "filename": "gcc/testsuite/g++.dg/contracts/contracts-assume1.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-assume1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-assume1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-assume1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,30 @@\n+// test that assumed contracts do instatiate templates\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+template<typename T>\n+int f(T t)\n+{\n+  return -t;\n+}\n+\n+int dummy()\n+{\n+  [[ assert assume: f(1.0) > 0 ]];\n+  return -1;\n+}\n+\n+template<>\n+int f(double t) // { dg-error \"specialization of.*after instantiation\" }\n+{\n+  return -1.0;\n+}\n+\n+int main()\n+{\n+  dummy();\n+  f(1);\n+  f(1.0);\n+  return 0;\n+}\n+"}, {"sha": "af163eddcf29eeba6d4f74975218594e349c551d", "filename": "gcc/testsuite/g++.dg/contracts/contracts-assume2.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-assume2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-assume2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-assume2.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,34 @@\n+// ensure that assert contracts can be turned into compile time assumptions\n+// and that they can be used for optimization.\n+//\n+// Even though x == -1, the assert contract tells the compiler that it is\n+// safe to assume the x <= 0 branch is never taken fun can be transformed into\n+// just\n+//   printf(\"%d: test x>0\\n\", x);\n+//   return 0;\n+// we ensure this by matching on the output and expecting a 0 return code from\n+// main -- unlike contracts-ignore2 which expects a failing return code\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-role=default:never,assume,ignore -O1\" }\n+#include <cstdio>\n+\n+int fun(int x) {\n+  [[assert audit: x > 0]];\n+  if(x <= 0)\n+  {\n+    printf(\"%d: test x<=0 opt out\\n\", x);\n+    return -1;\n+  }\n+  else\n+  {\n+    printf(\"%d: test x>0\\n\", x);\n+    return 0;\n+  }\n+}\n+\n+int main(int, char**) {\n+  volatile int x = -1;\n+  return fun(x);\n+}\n+\n+// { dg-output \"-1: test x>0(\\n|\\r\\n|\\r)*\" }"}, {"sha": "8dad6bb562e5f4669cdb430169b03651029e5703", "filename": "gcc/testsuite/g++.dg/contracts/contracts-assume3.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-assume3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-assume3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-assume3.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,19 @@\n+// test that assumed contracts that reference undefined entities do not cause\n+// a link failure\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+int f(int t);\n+\n+int dummy()\n+{\n+  [[ assert assume: f(1) > 0 ]];\n+  return -1;\n+}\n+\n+int main()\n+{\n+  dummy();\n+  return 0;\n+}\n+"}, {"sha": "7954f53161219fe952de0fbb6c2f9db3336710dc", "filename": "gcc/testsuite/g++.dg/contracts/contracts-assume4.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-assume4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-assume4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-assume4.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,19 @@\n+// test that assumed constexpr contracts that reference undefined entities do\n+// not cause constexpr eval failure\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+constexpr int f(int t); // { dg-warning \"used but never defined\" }\n+\n+constexpr int dummy()\n+{\n+  [[ assert assume: f(1) > 0 ]];\n+  return -1;\n+}\n+\n+int main()\n+{\n+  constexpr int n = dummy();\n+  return 0;\n+}\n+"}, {"sha": "372c0deb13af91881c28ca165d87b6b95e24c790", "filename": "gcc/testsuite/g++.dg/contracts/contracts-assume5.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-assume5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-assume5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-assume5.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,34 @@\n+// test that assumed constexpr contracts that reference defined entities, or\n+// undefined entities in unevaluated context, cause constexpr eval failure when\n+// the predicate is constexpr false\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+constexpr int f(int t)\n+{\n+  return -1;\n+}\n+\n+constexpr int dummy()\n+{\n+  [[ assert assume: f(1) > 0 ]];\n+  return -1;\n+}\n+\n+constexpr int undef(int t);\n+\n+constexpr int dummy2()\n+{\n+  [[ assert assume: sizeof(decltype(undef(1))) < 0 ]];\n+  return -1;\n+}\n+\n+int main()\n+{\n+  constexpr int n = dummy(); // { dg-message \"in .constexpr. expansion\" }\n+  // { dg-error \"contract predicate\" \"\" { target *-*-* } 14 }\n+  constexpr int m = dummy2(); // { dg-message \"in .constexpr. expansion\" }\n+  // { dg-error \"contract predicate\" \"\" { target *-*-* } 22 }\n+  return 0;\n+}\n+"}, {"sha": "931c4d0c19c8f5f9bc9434261087fb6dfe7b2cb1", "filename": "gcc/testsuite/g++.dg/contracts/contracts-assume6.C", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-assume6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-assume6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-assume6.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,61 @@\n+// ensure that non-defined entities in assume contracts do not error\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+template<typename T>\n+T id2(T n);\n+\n+int fun(int n)\n+  [[ pre assume: id2(n) > 0 ]]\n+  [[ pre: n > 0 ]]\n+{\n+  return -n;\n+}\n+\n+template<typename T>\n+T tfun(T n)\n+  [[ pre assume: id2(n) > 0 ]]\n+  [[ pre: n > 0 ]]\n+{\n+  return -n;\n+}\n+\n+template<typename T>\n+constexpr T id(T n); // { dg-warning \"used but never defined\" }\n+\n+template<typename T>\n+constexpr T cfun(T n)\n+  [[ pre assume: id(n) > 0 ]]\n+  [[ pre: id(n) > 0 ]] // { dg-error \"used before its definition\" }\n+{\n+  return -n;\n+}\n+\n+template<typename T>\n+constexpr T id3(T n)\n+{\n+  return n;\n+}\n+\n+template<typename T>\n+constexpr T cfun2(T n)\n+  [[ pre assume: id3(n) > 0 ]] // { dg-error \"contract predicate\" }\n+{\n+  return -n;\n+}\n+\n+template<typename T>\n+constexpr T cfun3(T n)\n+  [[ pre: id3(n) > 0 ]] // { dg-error \"contract predicate\" }\n+{\n+  return -n;\n+}\n+\n+int main() {\n+  constexpr int n = cfun(-5);\n+  constexpr int n2 = cfun2(-5);\n+  constexpr int n3 = cfun3(-5);\n+  fun(-5);\n+  tfun(-5);\n+}\n+"}, {"sha": "3384ae6225ebc0e4cbaf7f5dbf5f85b8770425cc", "filename": "gcc/testsuite/g++.dg/contracts/contracts-comdat1.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-comdat1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-comdat1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-comdat1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,19 @@\n+// Contract condition functions should be local symbols in a comdat group with\n+// the guarded function.\n+\n+// { dg-do compile { target { c++20 && comdat_group } } }\n+// { dg-additional-options -fcontracts }\n+// { dg-final { scan-assembler-not \"_Z1fi.pre,comdat\" } }\n+// { dg-final { scan-assembler-not {(weak|globl)[^\\n]*_Z1fi.pre} } }\n+\n+inline int f(int i)\n+  [[ pre: i > 0 ]]\n+{\n+  return i;\n+}\n+\n+int main()\n+{\n+  if (f(42) != 42)\n+    __builtin_abort ();\n+}"}, {"sha": "9e32bac535dabc2ca3304b63304bc4fb0d6b89f1", "filename": "gcc/testsuite/g++.dg/contracts/contracts-config1.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-config1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-config1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-config1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,36 @@\n+// Small test to ensure that the level and role information printed by various\n+// contract configurations is correct.\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-role=default:maybe,maybe,ignore\" }\n+\n+int fun(int n)\n+  [[ post default r: r > 0 ]]\n+{\n+  return -n;\n+}\n+\n+int main(int, char **)\n+{\n+  [[ assert default: false ]];\n+  [[ assert: false ]];\n+  [[ assert audit: false ]];\n+  [[ assert default %new_role: false ]];\n+  [[ assert %new_role: false ]];\n+  [[ assert audit %new_role: false ]];\n+  [[ assert check_maybe_continue: false ]];\n+  [[ assert %default: false ]];\n+  [[ assert audit %default: false ]];\n+  fun(5);\n+  return 0;\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*main false default default 1.*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*main false default default 1.*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*main false audit default 1.*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*main false default new_role 1.*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*main false default new_role 1.*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*main false audit new_role 1.*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*main false   1.*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*main false default default 1.*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*main false audit default 1.*(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "4c111358d9b22de08314020169e4c1c18fc15f8a", "filename": "gcc/testsuite/g++.dg/contracts/contracts-constexpr1.C", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-constexpr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-constexpr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-constexpr1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,74 @@\n+// ensure that passing pre/post do not affect constexpr functions\n+// ensure that failing pre/post generate an error at runtime in constexpr funcs\n+// { dg-do run }\n+// { dg-options \"-std=c++20 -fcontracts -fcontract-continuation-mode=on\" }\n+\n+constexpr int wfun(int a)\n+  [[ pre: a > 0 ]]\n+  [[ post r: r > 0 ]]\n+{\n+  return a;\n+}\n+\n+constexpr int ffun(int a)\n+  [[ pre: a > 0 ]]\n+  [[ post r: r > 0 ]]\n+{\n+  return a;\n+}\n+\n+template<typename T>\n+constexpr int tfun(T a)\n+  [[ pre: a > 0 ]]\n+  [[ post r: r > 0 ]]\n+{\n+  return a;\n+}\n+\n+template<typename T>\n+constexpr int wtfun(T a)\n+  [[ pre: a > 0 ]]\n+  [[ post r: r > 0 ]]\n+{\n+  return a;\n+}\n+\n+template<typename T>\n+constexpr int ftfun(T a)\n+  [[ pre: a > 0 ]]\n+  [[ post r: r > 0 ]]\n+{\n+  return a;\n+}\n+\n+constexpr int explicitfn(int a)\n+  [[ pre ignore: a > 0 ]]\n+  [[ pre check_maybe_continue: a > 0 ]]\n+  [[ post ignore r: r > 0 ]]\n+  [[ post check_maybe_continue r: r > 0 ]]\n+{\n+  return a;\n+}\n+\n+int main(int, char **) {\n+  constexpr int a = wfun(10);\n+  int b = ffun(-10);\n+  constexpr int c = wtfun(10);\n+  int d = ftfun(-10);\n+\n+  int e = explicitfn(-10);\n+\n+  int z = ftfun(-10.0);\n+\n+  return 0;\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 14 ffun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 15 ffun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 38 ftfun<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 39 ftfun<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 46 explicitfn .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 48 explicitfn .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 38 ftfun<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 39 ftfun<double> .*(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "d0d41f05927103449afd4047ada9e559fbcfd3e7", "filename": "gcc/testsuite/g++.dg/contracts/contracts-constexpr2.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-constexpr2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-constexpr2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-constexpr2.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,58 @@\n+// ensure that failing pre/post can fail at constexpr time\n+// { dg-do compile }\n+// { dg-options \"-std=c++20 -fcontracts -fcontract-continuation-mode=on\" }\n+\n+constexpr int ffun(int a)\n+  [[ pre: a > 0 ]]\n+  [[ post r: r > 10 ]]\n+{\n+  return a;\n+}\n+\n+template<typename T>\n+constexpr int ftfun(T a)\n+  [[ pre: a > 0 ]]\n+  [[ post r: r > 10 ]]\n+{\n+  return a;\n+}\n+\n+constexpr int explicitfn(int a)\n+  [[ pre ignore: a > 0 ]]\n+  [[ pre check_maybe_continue: a > 0 ]]\n+  [[ post ignore r: r > 10 ]]\n+  [[ post check_maybe_continue r: r > 10 ]]\n+{\n+  return a;\n+}\n+\n+template<typename T>\n+constexpr int ftfun2(T a)\n+  [[ pre: a > 0 ]]\n+  [[ post r: r > 10 ]]\n+{\n+  return a;\n+}\n+\n+int main(int, char **) {\n+  constexpr int a = ffun(-10);\n+  // { dg-error \"contract predicate\" \"\" { target *-*-* } 6 }\n+  constexpr int b = ftfun(-10);\n+  // { dg-error \"contract predicate\" \"\" { target *-*-* } 14 }\n+  constexpr int c = explicitfn(-10);\n+  // { dg-error \"contract predicate\" \"\" { target *-*-* } 22 }\n+  constexpr int d = ftfun2(-10.0);\n+  // { dg-error \"contract predicate\" \"\" { target *-*-* } 31 }\n+\n+  constexpr int e = ffun(5);\n+  // { dg-error \"contract predicate\" \"\" { target *-*-* } 7 }\n+  constexpr int f = ftfun(5);\n+  // { dg-error \"contract predicate\" \"\" { target *-*-* } 15 }\n+  constexpr int g = explicitfn(5);\n+  // { dg-error \"contract predicate\" \"\" { target *-*-* } 24 }\n+  constexpr int h = ftfun2(5.5);\n+  // { dg-error \"contract predicate\" \"\" { target *-*-* } 32 }\n+\n+  return 0;\n+}\n+"}, {"sha": "8826220ef913b0bc06e8fc7a19875d8cce7aab38", "filename": "gcc/testsuite/g++.dg/contracts/contracts-constexpr3.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-constexpr3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-constexpr3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-constexpr3.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,10 @@\n+// An assumed contract shouldn't break constant evaluation.\n+\n+// { dg-do compile { target c++20 } }\n+// { dg-additional-options -fcontracts }\n+\n+bool b;\n+\n+constexpr int f() [[ pre assume: b ]] { return 42; }\n+\n+static_assert (f() > 0);"}, {"sha": "ff5e23f2f143c38337f0bb826522e00f2f1cee55", "filename": "gcc/testsuite/g++.dg/contracts/contracts-conversion1.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-conversion1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-conversion1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-conversion1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,19 @@\n+// Test to ensure that diagnostic location for condition conversion is in the\n+// right place.\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+\n+template<typename T>\n+void fn()\n+  [[ pre: T{} ]] // { dg-error \"no match\" }\n+{\n+}\n+\n+struct Z { };\n+\n+int main(int, char**) {\n+  fn<int>();\n+  fn<Z>();\n+  return 0;\n+}"}, {"sha": "bcd6096b5a717704997c2f1dc6364c66f1ae349a", "filename": "gcc/testsuite/g++.dg/contracts/contracts-ctor-dtor1.C", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-ctor-dtor1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-ctor-dtor1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-ctor-dtor1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,177 @@\n+// Tests to ensure that contracts are properly emitted for constructors,\n+// destructors, and their intersection with templates.\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+bool pre_{false}, post_{false};\n+bool delegate_{false};\n+\n+struct S\n+{\n+  S() [[ pre: pre_ ]] [[ post: post_ ]];\n+  ~S() [[ pre: pre_ ]] [[ post: post_ ]];\n+};\n+\n+S::S() { return; }\n+S::~S() { return; }\n+\n+struct SInline\n+{\n+  SInline() [[ pre: pre_ ]] [[ post: post_ ]] { return; }\n+  ~SInline() [[ pre: pre_ ]] [[ post: post_ ]] { return; }\n+};\n+\n+struct SDelegate0\n+{\n+  SDelegate0(int) [[ pre: pre_ ]] [[ post: post_ ]] { return; }\n+  SDelegate0() : SDelegate0(0) { return; }\n+  ~SDelegate0() [[ pre: pre_ ]] [[ post: post_ ]] { return; }\n+};\n+\n+struct SDelegate1\n+{\n+  SDelegate1(int) { return; }\n+  SDelegate1() [[ pre: pre_ ]] [[ post: post_ ]] : SDelegate1(0) { return; }\n+  ~SDelegate1() [[ pre: pre_ ]] [[ post: post_ ]] { return; }\n+};\n+\n+struct SDelegate2\n+{\n+  SDelegate2(int) [[ pre: pre_ ]] [[ post: post_ ]] { return; }\n+  SDelegate2() [[ pre: pre_ && delegate_ ]] [[ post: post_ && delegate_ ]] : SDelegate2(0) { return; }\n+  ~SDelegate2() [[ pre: pre_ ]] [[ post: post_ ]] { return; }\n+};\n+\n+struct SDelegate3\n+{\n+  SDelegate3(int) [[ pre: pre_ ]] [[ post: post_ ]] { return; }\n+  SDelegate3() [[ pre: pre_ && delegate_ ]] [[ post: post_ && delegate_ ]] : SDelegate3(0) { return; }\n+  ~SDelegate3() [[ pre: pre_ ]] [[ post: post_ ]] { return; }\n+};\n+\n+template<typename T>\n+struct S1\n+{\n+  S1() [[ pre: pre_ ]] [[ post: post_ ]] { }\n+};\n+\n+struct S2\n+{\n+  template<typename T>\n+  S2(T) [[ pre: pre_ ]] [[ post: post_ ]] { }\n+};\n+\n+template<typename T>\n+struct S3\n+{\n+  template<typename S>\n+  S3(S) [[ pre: pre_ ]] [[ post: post_ ]] { }\n+};\n+\n+struct G0\n+{\n+  G0() [[ post: x > 0 ]] {}\n+  ~G0() [[ pre: x > 0 ]] {}\n+  int x{-1};\n+};\n+\n+struct G1\n+{\n+  G1() [[ post: this->x > 0 ]] {}\n+  ~G1() [[ pre: this->x > 0 ]] {}\n+  int x{-1};\n+};\n+\n+int x{-1};\n+\n+struct G2\n+{\n+  G2() [[ pre: ::x > 0 ]] {}\n+  ~G2() [[ post: ::x > 0 ]] {}\n+  int x{1};\n+};\n+\n+void test0()\n+{\n+  S s;\n+  SInline si;\n+  SDelegate0 sd0;\n+  SDelegate1 sd1;\n+  SDelegate2 sd2;\n+  SDelegate3 sd3;\n+  S1<int> s1_i;\n+  S1<double> s1_d;\n+  S2 s2_i{1};\n+  S2 s2_d{.1};\n+  S3<int> s3_i_i{1};\n+  S3<int> s3_i_d{.1};\n+  S3<double> s3_d_i{1};\n+  S3<double> s3_d_d{.1};\n+}\n+\n+void test1()\n+{\n+  G0 g0;\n+  G1 g1;\n+  G2 g2;\n+}\n+\n+int main(int, char**)\n+{\n+  test0();\n+  test1();\n+  return 0;\n+};\n+\n+// test0\n+// { dg-output \"default std::handle_contract_violation called: .*.C 11 S::S .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 11 S::S .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 20 SInline::SInline .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 20 SInline::SInline .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 26 SDelegate0::SDelegate0 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 26 SDelegate0::SDelegate0 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 34 SDelegate1::SDelegate1 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 34 SDelegate1::SDelegate1 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 41 SDelegate2::SDelegate2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 40 SDelegate2::SDelegate2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 40 SDelegate2::SDelegate2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 41 SDelegate2::SDelegate2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 48 SDelegate3::SDelegate3 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 47 SDelegate3::SDelegate3 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 47 SDelegate3::SDelegate3 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 48 SDelegate3::SDelegate3 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 55 S1<int>::S1 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 55 S1<int>::S1 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 55 S1<double>::S1 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 55 S1<double>::S1 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 61 S2::S2<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 61 S2::S2<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 61 S2::S2<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 61 S2::S2<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 68 S3<int>::S3<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 68 S3<int>::S3<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 68 S3<int>::S3<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 68 S3<int>::S3<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 68 S3<double>::S3<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 68 S3<double>::S3<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 68 S3<double>::S3<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 68 S3<double>::S3<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 49 SDelegate3::~SDelegate3 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 49 SDelegate3::~SDelegate3 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 42 SDelegate2::~SDelegate2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 42 SDelegate2::~SDelegate2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 35 SDelegate1::~SDelegate1 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 35 SDelegate1::~SDelegate1 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 28 SDelegate0::~SDelegate0 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 28 SDelegate0::~SDelegate0 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 21 SInline::~SInline .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 21 SInline::~SInline .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 12 S::~S .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 12 S::~S .*(\\n|\\r\\n|\\r)*\" }\n+\n+// test1\n+// { dg-output \"default std::handle_contract_violation called: .*.C 73 G0::G0 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 80 G1::G1 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 81 G1::~G1 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 74 G0::~G0 .*(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "ba3b7678ef65a7f9eb998e80feb7ef7863ac9552", "filename": "gcc/testsuite/g++.dg/contracts/contracts-ctor-dtor2.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-ctor-dtor2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-ctor-dtor2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-ctor-dtor2.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,35 @@\n+// Tests to ensure that an invalid this parm cannot be used in pre on ctors or\n+// in post on dtors.\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+struct F0\n+{\n+  F0() [[ pre: x > 0 ]]; // { dg-error \"invalid use of member\" }\n+  ~F0() [[ post: x > 0 ]]; // { dg-error \"invalid use of member\" }\n+  int x{-1};\n+};\n+\n+struct F1\n+{\n+  F1() [[ pre: this->x > 0 ]]; // { dg-error \"may not be used\" }\n+  ~F1() [[ post: this->x > 0 ]]; // { dg-error \"may not be used\" }\n+  int x{-1};\n+};\n+\n+struct F2\n+{\n+  F2()\n+    [[ post ret: false ]] // { dg-error \"does not return a value\" }\n+  {\n+  }\n+  ~F2()\n+    [[ post r: false ]] // { dg-error \"does not return a value\" }\n+  {\n+  }\n+  void f()\n+    [[ post r: false ]] // { dg-error \"does not return a value\" }\n+  {\n+  }\n+};\n+"}, {"sha": "8266b4fed8f8ba5a52083fbf79cfce58c821b399", "filename": "gcc/testsuite/g++.dg/contracts/contracts-cv1.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-cv1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-cv1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-cv1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,37 @@\n+// Tests to ensure that contracts have a properly cv qualified this\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+struct S\n+{\n+  int g() const { return x_; }\n+  int f() { return x_; }\n+\n+  void mem_c() const\n+    [[ pre: f() ]] // { dg-error \"discards qualifiers\" }\n+  {\n+  }\n+  void mem_nc()\n+    [[ pre: f() ]]\n+  {\n+  }\n+\n+  void memc_c() const\n+    [[ pre: g() ]]\n+  {\n+  }\n+  void memc_nc()\n+    [[ pre: g() ]]\n+  {\n+  }\n+\n+  private:\n+    int x_{-10};\n+};\n+\n+int main(int, char**)\n+{\n+  S s;\n+  return 0;\n+};\n+"}, {"sha": "200ec73480095542e0a468fcdc7f83ea5112f774", "filename": "gcc/testsuite/g++.dg/contracts/contracts-deduced1.C", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-deduced1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-deduced1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-deduced1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,108 @@\n+// Tests to ensure that deduced return types work with postconditions using\n+// the return value on defining declarations.\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts --param ggc-min-heapsize=0 --param ggc-min-expand=0\" }\n+\n+auto undeduced(int z)\n+{\n+  if (!(sizeof(decltype(undeduced(5))) > 4)) // { dg-error \"before deduction\" }\n+    return 5;\n+  return 4;\n+}\n+\n+// defining declaration, fine\n+auto g0(int a) [[ pre: a < 0 ]] [[ post r: r > 0 ]]\n+{\n+  return -a * 1.2;\n+}\n+\n+// non defining post using nondeduced identifier, fine\n+int g1(int m) [[ post r: r == m ]];\n+\n+int g1(int n) [[ post s: s == n ]]\n+{\n+  return -n;\n+}\n+\n+int g2(int z)\n+  [[ pre: sizeof(decltype(g2(5))) > 4 ]]; // { dg-error \"not declared\" }\n+\n+int g3(int z)\n+  [[ pre: sizeof(decltype(g2(5))) > 4 ]]\n+{\n+  return -z;\n+}\n+\n+// deduced that doesn't use return, good\n+auto g4(int m) [[ post: m ]];\n+\n+auto g4(int m) [[ post: m ]]\n+{\n+  return -m;\n+}\n+\n+auto g5(int m) [[ pre: m ]];\n+\n+auto g5(int m) [[ pre: m ]]\n+{\n+  return -m;\n+}\n+\n+template<typename T>\n+auto g6(T t) [[ post r: r == t ]];\n+\n+template<typename S>\n+auto g6(S s) [[ post q: q == s ]]\n+{\n+  return s;\n+}\n+\n+template<typename T>\n+T g7(T t) [[ post r: r == t ]];\n+\n+template<typename S>\n+S g7(S s) [[ post q: q == s ]]\n+{\n+  return s;\n+}\n+\n+template<typename T>\n+auto g8(T t) [[ post r: r == t && sizeof(decltype(::g8(t))) > 2 ]]; // { dg-error \"not been declared\" }\n+\n+// This failure is related to the fact that we've invalidated the previous\n+// contract. \n+template<typename S>\n+auto g8(S s) [[ post q: q == s && sizeof(decltype(::g8(s))) > 2 ]] // { dg-error \"mismatched\" }\n+{\n+  return s;\n+}\n+\n+// non defining pre, bad\n+auto f0(int z)\n+  [[ pre: sizeof(decltype(f0(5))) > 4 ]]; // { dg-error \"not declared\" }\n+\n+// defining pre, still ill formed\n+auto f1(int z)\n+  [[ pre: sizeof(decltype(f1(5))) > 4 ]] // { dg-error \"not declared\" }\n+{\n+  return '5';\n+}\n+\n+// undeduced using postcon, OK\n+auto f2(int m) [[ post r: r == m ]];\n+\n+auto f2(int n) [[ post s: s == n ]]\n+{\n+  return n;\n+}\n+\n+template<typename T>\n+void f3(T t) [[ post r: false ]] // { dg-error \"function does not return a value\" }\n+{\n+}\n+\n+int main(int, char**)\n+{\n+  return 0;\n+}\n+"}, {"sha": "da9c019f10aab83f38fcf205ba68149dbef967a7", "filename": "gcc/testsuite/g++.dg/contracts/contracts-deduced2.C", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-deduced2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-deduced2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-deduced2.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,84 @@\n+// check that contracts work around deduced return types\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+\n+auto g0(int a) [[ pre: a < 0 ]] [[ post r: r > 0 ]]\n+{\n+  return -a * 1.2;\n+}\n+\n+int g1(int m) [[ post r: r == m ]];\n+\n+int g1(int n) [[ post s: s == n ]]\n+{\n+  return -n;\n+}\n+\n+int g2(int z)\n+{\n+  return -z;\n+}\n+\n+int g3(int z)\n+  [[ pre: sizeof(decltype(g2(5))) > 4 ]]\n+{\n+  return -z;\n+}\n+\n+auto g4(int m) [[ post: m ]];\n+\n+auto g4(int m) [[ post: m ]]\n+{\n+  return -m;\n+}\n+\n+auto g5(int m) [[ pre: m ]];\n+\n+auto g5(int m) [[ pre: m ]]\n+{\n+  return -m;\n+}\n+\n+template<typename T>\n+auto g6(T t) [[ post r: r == t ]];\n+\n+template<typename S>\n+auto g6(S s) [[ post q: q == s ]]\n+{\n+  return -s;\n+}\n+\n+// template<typename T>\n+// T g7(T t) [[ post r: r == t ]];\n+\n+template<typename S>\n+S g7(S s) [[ post q: q == s ]]\n+{\n+  return -s;\n+}\n+\n+int main(int, char**) {\n+  g0(5);\n+  g1(6);\n+  g2(1);\n+  g3(1);\n+  g4(0);\n+  g5(0);\n+  g6(5);\n+  g6(5.5);\n+  g7(5);\n+  g7(6.6);\n+  return 0;\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 5 g0 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 5 g0 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 12 g1 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 23 g3 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 30 g4 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 37 g5 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 46 g6<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 46 g6<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 55 g7<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 55 g7<double> .*(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "0ccfbe2c7c3d8471716d25b77551fa6d087c55d9", "filename": "gcc/testsuite/g++.dg/contracts/contracts-friend1.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-friend1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-friend1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-friend1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,40 @@\n+// ensure contracts on friend declarations are a complete class context\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+\n+struct X {\n+  friend void fn0(X x) [[ pre: x.a > 0 ]] { }\n+\n+  friend void fn2(X x);\n+  static void fns0(X x) [[ pre: x.a > 0 ]] { }\n+  static void fns1(X x) [[ pre: x.a > 0 ]];\n+  static void fns2(X x);\n+\n+  friend void fn(X &x) { x.a = -5; }\n+\n+private:\n+  int a{10};\n+};\n+\n+void fn2(X x) [[ pre: x.a > 0 ]] { }\n+void X::fns1(X x) { }\n+void X::fns2(X x) [[ pre: x.a > 0 ]] { }\n+\n+int main(int, char**) {\n+  X x;\n+  fn(x); // no contract\n+\n+  fn0(x);\n+  fn2(x);\n+\n+  X::fns0(x);\n+  X::fns1(x);\n+  X::fns2(x);\n+  return 0;\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 6 fn0 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 19 fn2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 9 X::fns0 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 10 X::fns1 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 21 X::fns2 .*(\\n|\\r\\n|\\r)*\" }"}, {"sha": "e5d5be7cb6a55a0b859be8577a7f95f623e69103", "filename": "gcc/testsuite/g++.dg/contracts/contracts-ft1.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-ft1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-ft1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-ft1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile }\n+\n+#ifdef __cpp_contracts\n+static_assert (false);\n+#endif\n+\n+#ifdef __cpp_contracts_literal_semantics\n+static_assert (false);\n+#endif\n+\n+#ifdef __cpp_contracts_roles\n+static_assert (false);\n+#endif\n+"}, {"sha": "c8ae656816661dda3f6246716bf12bc486a904fe", "filename": "gcc/testsuite/g++.dg/contracts/contracts-ignore1.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-ignore1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-ignore1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-ignore1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,30 @@\n+// test that ignored contracts do instatiate templates\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+template<typename T>\n+int f(T t)\n+{\n+  return -t;\n+}\n+\n+int dummy()\n+{\n+  [[ assert ignore: f(1.0) > 0 ]];\n+  return -1;\n+}\n+\n+template<>\n+int f(double t) // { dg-error \"specialization of.*after instantiation\" }\n+{\n+  return -1.0;\n+}\n+\n+int main()\n+{\n+  dummy();\n+  f(1);\n+  f(1.0);\n+  return 0;\n+}\n+"}, {"sha": "5cf800a355952ff03b86df8db027489d4c6c21f9", "filename": "gcc/testsuite/g++.dg/contracts/contracts-ignore2.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-ignore2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-ignore2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-ignore2.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,26 @@\n+// baseline for testing assert contracts being turned into compile time\n+// assumptions; see contracts-assume2 for the assumed case\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+#include <cstdio>\n+\n+int fun(int x) {\n+  [[assert audit: x > 0]];\n+  if(x <= 0)\n+  {\n+    printf(\"%d: test x<=0 opt out\\n\", x);\n+    return -1;\n+  }\n+  else\n+  {\n+    printf(\"%d: test x>0\\n\", x);\n+    return 0;\n+  }\n+}\n+\n+int main(int, char**) {\n+  volatile int x = -1;\n+  return fun(x);\n+}\n+\n+// { dg-shouldfail \"\" }"}, {"sha": "ea8e73a387f1351239de34b2d779405231b507cb", "filename": "gcc/testsuite/g++.dg/contracts/contracts-large-return.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-large-return.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-large-return.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-large-return.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+struct Foo\n+{\n+  int x;\n+  bool y;\n+  long z[4];\n+};\n+\n+Foo foo() [[ pre: true ]]\n+{\n+  return {};\n+}\n+"}, {"sha": "8145c61e8276098240ea87ab60538ebf18f66124", "filename": "gcc/testsuite/g++.dg/contracts/contracts-multiline1.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-multiline1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-multiline1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-multiline1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+\n+int main(int, char **)\n+{\n+  int x = 5;\n+  int y = 10;\n+  [[ assert:\n+    x\n+    <\n+    10\n+    &&\n+    y\n+    >\n+    123\n+  ]];\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 8 main x < 10 && y > 123.*(\\n|\\r\\n|\\r)*\" }"}, {"sha": "3f2f5edd6efd411e979250f86648770f80feef9a", "filename": "gcc/testsuite/g++.dg/contracts/contracts-multiple-inheritance1.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-multiple-inheritance1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-multiple-inheritance1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-multiple-inheritance1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+\n+struct BaseA {\n+  virtual int fun(int n) [[ pre: n > 0 ]] { return -n; }\n+};\n+\n+struct BaseB {\n+  virtual int fun(int n) [[ pre: n > 0 ]] { return -n; }\n+};\n+\n+struct Child : public BaseA, BaseB {\n+  int fun(int n) [[ pre: n > 0 ]] { return -n; }\n+};\n+"}, {"sha": "37bdac1d63f459c163db647e0cfed67bbf0f8f8a", "filename": "gcc/testsuite/g++.dg/contracts/contracts-multiple-inheritance2.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-multiple-inheritance2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-multiple-inheritance2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-multiple-inheritance2.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,33 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+\n+struct BaseA {\n+  virtual int fun(int n) [[ pre: n > 0 ]] { return -n; }\n+};\n+\n+struct BaseB {\n+  virtual int fun(int n) [[ pre: n < 0 ]] { return -n; }\n+};\n+\n+struct Child1 : public BaseA, BaseB {\n+  int fun(int n) [[ pre: n > 0 ]] { return -n; } // { dg-error \"mismatched\" }\n+};\n+\n+struct Child2 : public BaseA, BaseB {\n+  int fun(int n) [[ pre: n < 0 ]] { return -n; } // { dg-error \"mismatched\" }\n+};\n+\n+struct Child3 : public BaseA, BaseB {\n+  int fun(int n) { return -n; }\n+};\n+\n+struct Child4 : public BaseA {\n+  int fun(int n);\n+};\n+\n+int Child4::fun(int n)\n+  [[ pre: n != 0 ]] // { dg-error \"mismatched\" }\n+{\n+  return -n;\n+}\n+"}, {"sha": "9f91ff499d011ed63e3086d89d9fbc3abc7b3b15", "filename": "gcc/testsuite/g++.dg/contracts/contracts-nested-class1.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-nested-class1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-nested-class1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-nested-class1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,24 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+void gfn3(int n) [[ pre: n > 0 ]];\n+\n+struct Outer {\n+  struct Inner {\n+    void fn(int n) [[ pre: n > 0 && bob > 1 ]];\n+    void fn2(int n) [[ pre: n > 0 && bob > 1 ]];\n+  };\n+\n+  void fn(int m) [[ pre: m > 1 ]];\n+  friend void Inner::fn(int n) [[ pre: n > 0 && bob > 1 ]]; // { dg-error \"not declared\" }\n+\n+  friend void gfn(int p) [[ pre: p > 0 ]];\n+  friend void gfn(int q) [[ pre: q > 1 ]]; // { dg-error \"'q' was not declared\" }\n+\n+  // This should be okay.\n+  friend void gfn2(int q);\n+  friend void gfn2(int p) [[ pre: p > 0 ]] { }\n+\n+  static int bob;\n+};\n+int Outer::bob{-1};"}, {"sha": "43e75edbef805c7f5d806cbc802dbd3989e1a55f", "filename": "gcc/testsuite/g++.dg/contracts/contracts-nested-class2.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-nested-class2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-nested-class2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-nested-class2.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,40 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+\n+void gfn3(int n) [[ pre: n > 0 ]];\n+\n+struct Outer {\n+  struct Inner {\n+    void fn(int n) [[ pre: n > 0 && bob > 1 ]];\n+  };\n+\n+  void fn(int m) [[ pre: m > 1 ]];\n+\n+  friend void gfn1(int q);\n+  friend void gfn1(int p) [[ pre: p > 0 ]] { }\n+\n+  friend void gfn2(int q, Outer *);\n+  friend void gfn2(int p, Outer *) [[ pre: p > 0 ]] { }\n+\n+  friend void gfn3(int n);\n+\n+  static int bob;\n+};\n+int Outer::bob{-1};\n+\n+void Outer::Inner::fn(int x) { }\n+void Outer::fn(int y) { }\n+\n+void gfn3(int n) { }\n+void gfn1(int q);\n+\n+int main(int, char **) {\n+  Outer::Inner in;\n+  in.fn(-5);\n+  Outer out;\n+  out.fn(-6);\n+  gfn1(-7);\n+  gfn2(-8, &out);\n+  gfn3(-9);\n+}\n+"}, {"sha": "4608a4dc181b50fd8a7ebbe05d11f7bd330a6e56", "filename": "gcc/testsuite/g++.dg/contracts/contracts-nocopy1.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-nocopy1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-nocopy1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-nocopy1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,24 @@\n+// Contracts shouldn't introduce more copies.\n+\n+// { dg-do compile { target c++20 } }\n+// { dg-additional-options -fcontracts }\n+\n+struct A\n+{\n+  int i;\n+  A(int i): i(i) { }\n+  A(const A&) = delete;\n+};\n+\n+A f(A a)\n+  [[ pre: a.i > 0 ]]\n+  [[ post r: r.i > 0 ]]\n+{\n+  return {a.i};\n+}\n+\n+int main()\n+{\n+  if (f({42}).i != 42)\n+    __builtin_abort ();\n+}"}, {"sha": "f96aa988e0fe689bd9cdc96f25570f6e3a1967c5", "filename": "gcc/testsuite/g++.dg/contracts/contracts-override.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-override.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-override.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-override.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+struct Foo {\n+  virtual int f0(int n) [[ pre: false ]] { return n; }\n+  virtual int f1(int n) [[ pre: false ]] { return n; }\n+  virtual int f2(int n) [[ pre: false ]] { return n; }\n+  virtual int f3(int n) [[ pre: false ]] { return n; }\n+  virtual int f4(int n) [[ pre: false ]] { return n; }\n+  virtual int f5(int n) [[ pre: false ]] { return n; }\n+  virtual int f6(int n) [[ pre: false ]] { return n; }\n+  virtual int f7(int n) [[ pre: false ]] { return n; }\n+  virtual int f8(int n) [[ pre: false ]] { return n; }\n+  virtual int f9(int n) [[ pre: false ]] { return n; }\n+  virtual int f10(int n) [[ pre: false ]] { return n; }\n+  virtual int f11(int n) [[ pre: n > 0 ]] [[ pre: n > 1 ]] { return n; }\n+  virtual int f12(int n) [[ pre: n > 0 ]] [[ pre: n > 1 ]] { return n; }\n+};\n+\n+struct Bar : Foo {\n+  [[ pre: n > -1 ]] int f0(int n = 0) override { return -n; } // { dg-error \"contracts must appertain\" }\n+  int [[ pre: n > -2 ]] f1(int n = 0) override { return -n; } // { dg-error \"contracts must appertain\" }\n+  int f2 [[ pre: n > -3 ]] (int n = 0) override { return -n; } // { dg-error \"contracts must appertain\" }\n+  int f4([[ pre: n > -4 ]] int n = 0) override { return -n; } // { dg-error \"contracts must appertain\" }\n+  int f5(int [[ pre: n > -5 ]] n = 0) override { return -n; } // { dg-error \"contracts must appertain\" }\n+  int f6(int n [[ pre: n > -6 ]] = 0) override { return -n; } // { dg-error \"contracts must appertain\" }\n+  int f7(int n = [[ pre: n > -7 ]] 0) override { return -n; }\n+  // { dg-error \"expected identifier\" \"\" { target *-*-* } .-1 }\n+  // { dg-error \"expected .\\{. before numeric\" \"\" { target *-*-* } .-2 }\n+  // { dg-error \"invalid user-defined conversion\" \"\" { target *-*-* } .-3 }\n+  // { dg-error \"expected .,.\" \"\" { target *-*-* } .-4 }\n+  int f8(int n = 0 [[ pre: n > -8 ]]) override { return -n; }\n+  // { dg-error \"shall only introduce an attribute\" \"\" { target *-*-* } .-1 }\n+  int f9(int n = 0) [[ pre: n > -9 ]] override { return -n; } // { dg-error \"mismatched contract\" }\n+\n+  // The grammar doesn't appear to permit contracts after the virt-specifiers\n+  // but the parser will happily add these to an attribute list that is not\n+  // owned by the function declarator.\n+  int f10(int n = 0) override [[ pre: n > -10 ]] { return -n; } // { dg-error \"contracts must appertain\" }\n+  int f11(int n) [[ pre: n > 1 ]] override [[ pre: n > 0 ]] { return -n; } // { dg-error \"contracts must appertain\" }\n+  int f12(int n) [[ pre: n > 0 ]] override [[ pre: n > 1 ]] { return -n; } // { dg-error \"contracts must appertain\" }\n+};\n+"}, {"sha": "451760ea8223a8a609f1fe64887ffd1ae8c4fb55", "filename": "gcc/testsuite/g++.dg/contracts/contracts-post1.C", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-post1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-post1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-post1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,74 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+int f1(int n)\n+  [[pre: n >= 0]]\n+  [[post r: r >= 0]]\n+  [[post r: !(r < 0)]]\n+{\n+  return n;\n+}\n+\n+int f2(int n)\n+  [[post: true]]\n+{\n+  return 0;\n+}\n+\n+int f3(int n)\n+  [[post r: r >= n]]\n+{\n+  return n + 1;\n+}\n+\n+int f4(int n)\n+  [[post: x > 0]] // { dg-error \"not declared\" }\n+{\n+  return 0;\n+}\n+\n+void f5()\n+  [[post: true]]\n+{ }\n+\n+void f6()\n+  [[post r: true]] // { dg-error \"function does not return a value\" }\n+{ }\n+\n+int f7(int n)\n+  [[post: n > 0]]\n+{\n+  return x; // { dg-error \"not declared\" }\n+}\n+\n+void f8(int n)\n+  [[post: n > 0]]\n+{\n+  return;\n+}\n+\n+void f9(int n)\n+  [[post: n > 0]]\n+{\n+  return n; // { dg-error \"return-statement with a value\" }\n+}\n+\n+int f10(int n)\n+  [[post: n > 0]]\n+{\n+  return; // { dg-error \"return-statement with no value\" }\n+}\n+\n+void f11()\n+  [[post: true]]\n+{\n+  constexpr int n = 0;\n+  return n; // { dg-error \"return-statement with a value\" }\n+}\n+\n+int f12()\n+  [[post: true]]\n+{\n+  return; // { dg-error \"return-statement with no value\" }\n+}\n+"}, {"sha": "7665f82910709f74661944464360c6df505deac3", "filename": "gcc/testsuite/g++.dg/contracts/contracts-post2.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-post2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-post2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-post2.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+int f1(int n)\n+  [[post r: r == n]]\n+{\n+  return n;\n+}\n+\n+int main()\n+{\n+  f1(0);\n+}"}, {"sha": "9f1dffd8f6a748982da79fa6048b9fe8d5f89db7", "filename": "gcc/testsuite/g++.dg/contracts/contracts-post3.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-post3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-post3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-post3.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+// { dg-shouldfail \"assert violation\" }\n+// { dg-output \"default std::handle_contract_violation called\" }\n+\n+int f1(int n)\n+  [[post r: r > n]]\n+{\n+  return n;\n+}\n+\n+int main()\n+{\n+  f1(0);\n+}"}, {"sha": "af770c3dc949262f298af4c157b15bd6d89ab84c", "filename": "gcc/testsuite/g++.dg/contracts/contracts-post4.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-post4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-post4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-post4.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,36 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+struct S\n+{\n+  S() [[post: n == 0]]\n+    : n(0)\n+  { }\n+\n+  ~S() [[post: true]]\n+  { }\n+\n+  int f1()\n+    [[post r: n == r]]\n+  {\n+    return n;\n+  }\n+\n+  int f2()\n+    [[post r: r == x]] // { dg-error \"not declared\" }\n+  {\n+    return n;\n+  }\n+\n+  void f3()\n+    [[post r: n]] // { dg-error \"does not return a value\" }\n+  {\n+  }\n+\n+  int n = 0;\n+};\n+\n+int main()\n+{\n+  // f1(0);\n+}"}, {"sha": "c9127fb2cc95e43caf6a76cb6927a7ba93fe7275", "filename": "gcc/testsuite/g++.dg/contracts/contracts-post5.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-post5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-post5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-post5.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+// Tests for function templates\n+\n+template<typename T>\n+T f1(T n)\n+  [[pre: n >= 0]]\n+  [[post r: r >= 0]]\n+  [[post r: !(r < 0)]]\n+{\n+  return n;\n+}\n+\n+\n+void driver()\n+{\n+  f1(0);\n+}\n\\ No newline at end of file"}, {"sha": "f8246fbc15f198d5e2856b52f320957eb7003d3a", "filename": "gcc/testsuite/g++.dg/contracts/contracts-post6.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-post6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-post6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-post6.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,30 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+// Test for class members\n+\n+template<typename T>\n+struct S\n+{\n+  S(T n)\n+    [[post: true]]\n+    : n(n)\n+  { }\n+\n+  T f1(T n)\n+    [[pre: n >= 0]]\n+    [[post r: r >= 0]]\n+    [[post r: !(r < 0)]]\n+  {\n+    return n;\n+  }\n+\n+  T n;\n+};\n+\n+\n+void driver()\n+{\n+  S<int> s1(0);\n+  s1.f1(2);\n+}"}, {"sha": "908103cde1ec506ecc4c6ad186cc9d160d52aa60", "filename": "gcc/testsuite/g++.dg/contracts/contracts-pre1.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,36 @@\n+// generic pre contract parsing checks\n+//   check omitted, 'default', 'audit', and 'axiom' contract levels parse\n+//   ensure that an invalid contrcat level 'off' errors\n+//   ensure that a predicate referencing an undefined variable errors\n+//   ensure that a missing colon after contract level errors\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+void f1(int x) [[ pre: x >= 0 ]] { }\n+void f2(int x) [[ pre default: x >= 0 ]] { }\n+void f3(int x) [[ pre audit: x >= 0 ]] { }\n+void f4(int x) [[ pre axiom: x >= 0 ]] { }\n+\n+void finvalid(int x) [[ pre invalid: x >= 0 ]] { } // { dg-error \"expected contract level\" }\n+void fundeclared() [[ pre: x >= 0 ]] { } // { dg-error \".x. was not declared in this scope\" }\n+void fmissingcolon(int x) [[ pre default x == 0]] { } // { dg-error \"expected .:. before .x.\" }\n+\n+int Z;\n+void (*fp1)(int x) [[ pre: Z > 0 ]]; // { dg-error \"contracts must appertain\" }\n+void (*fp2 [[ pre: Z > 0 ]])(int x); // { dg-error \"contracts must appertain\" }\n+typedef void (*fp3)(int x) [[ pre: Z > 0 ]]; // { dg-error \"contracts must appertain\" }\n+typedef void (*fp4 [[ pre: Z > 0 ]])(int x); // { dg-error \"contracts must appertain\" }\n+fp3 fn5(int a) [[ pre: a > 0 ]]; // { dg-bogus \"contracts must appertain\" }\n+\n+int xyz;\n+[[ pre: xyz ]] struct Bar; // { dg-error \"contracts must appertain\" }\n+// { dg-warning \"attribute ignored\" \"\" { target *-*-* } .-1 }\n+struct [[ pre: xyz ]] Bar; // { dg-error \"contracts must appertain\" }\n+struct Bar [[ pre: xyz ]]; // { dg-error \"contracts must appertain\" }\n+struct Zoo {} x [[ pre: xyz ]]; // { dg-error \"contracts must appertain\" }\n+\n+void f6(int x) [[ pre: x > 0 ; // { dg-error \"expected .].\" }\n+void f7(int x) [[ pre: x > 0 ]; // { dg-error \"expected .].\" }\n+void f8(int x) [[ pre: x > 0 { }; // { dg-error \"expected .].\" }\n+void f9(int x) [[ pre: x > 0 ] { }; // { dg-error \"expected .].\" }\n+"}, {"sha": "877e9ada4043dd5314cb0434c7179114c8a8f831", "filename": "gcc/testsuite/g++.dg/contracts/contracts-pre10.C", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre10.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,190 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+\n+struct M\n+{\n+  template<typename T>\n+  int f(int a) [[ pre: a > 0 ]];\n+\n+  template<typename T>\n+  int g(int a) [[ pre: a > 0 ]]\n+  {\n+    return -a;\n+  }\n+\n+  template<typename T>\n+  int f_arg(T a) [[ pre: a > 0 ]];\n+\n+  template<typename T>\n+  int g_arg(T a) [[ pre: a > 0 ]]\n+  {\n+    return (int)-a;\n+  }\n+\n+  template<typename T>\n+  T f_ret(int a) [[ pre: a > 0 ]];\n+\n+  template<typename T>\n+  T g_ret(int a) [[ pre: a > 0 ]]\n+  {\n+    return -a * 1.5;\n+  }\n+};\n+\n+template<typename T>\n+int M::f(int a)\n+{\n+  return -a;\n+}\n+\n+template<typename T>\n+int M::f_arg(T a)\n+{\n+  return (int)-a;\n+}\n+\n+template<typename T>\n+T M::f_ret(int a)\n+{\n+  return -a * (T)1.5;\n+}\n+\n+template<typename T>\n+struct S\n+{\n+  template<typename Q>\n+  int f(int a) [[ pre: a > 0 ]];\n+\n+  template<typename Q>\n+  int g(int a) [[ pre: a > 0 ]]\n+  {\n+    return -a;\n+  }\n+};\n+\n+template<typename T>\n+template<typename Q>\n+int S<T>::f(int a)\n+{\n+  return -a;\n+}\n+\n+#include <cstdio>\n+int main(int, char**)\n+{\n+  {\n+    M m;\n+    printf (\"=================================\\n\");\n+    printf (\"m.f<int>(-10): %d\\n\", m.f<int>(-10));\n+    printf (\"m.f<double>(-11.5): %d\\n\", m.f<double>(-11.5));\n+    printf (\"m.f<int>(10): %d\\n\", m.f<int>(10));\n+    printf (\"m.f<double>(11.5): %d\\n\", m.f<double>(11.5));\n+\n+    printf (\"=================================\\n\");\n+    printf (\"m.g<int>(-10): %d\\n\", m.g<int>(-10));\n+    printf (\"m.g<double>(-11.5): %d\\n\", m.g<double>(-11.5));\n+    printf (\"m.g<int>(10): %d\\n\", m.g<int>(10));\n+    printf (\"m.g<double>(11.5): %d\\n\", m.g<double>(11.5));\n+\n+    printf (\"=================================\\n\");\n+    printf (\"m.f_arg(-10): %d\\n\", m.f_arg(-10));\n+    printf (\"m.f_arg(-11.5): %d\\n\", m.f_arg(-11.5));\n+    printf (\"m.f_arg(10): %d\\n\", m.f_arg(10));\n+    printf (\"m.f_arg(11.5): %d\\n\", m.f_arg(11.5));\n+\n+    printf (\"=================================\\n\");\n+    printf (\"m.g_arg(-10): %d\\n\", m.g_arg(-10));\n+    printf (\"m.g_arg(-11.5): %d\\n\", m.g_arg(-11.5));\n+    printf (\"m.g_arg(10): %d\\n\", m.g_arg(10));\n+    printf (\"m.g_arg(11.5): %d\\n\", m.g_arg(11.5));\n+\n+    printf (\"=================================\\n\");\n+    printf (\"m.f_ret<int>(-10): %d\\n\", m.f_ret<int>(-10));\n+    printf (\"m.f_ret<double>(-11.5): %f\\n\", m.f_ret<double>(-11.5));\n+    printf (\"m.f_ret<int>(10): %d\\n\", m.f_ret<int>(10));\n+    printf (\"m.f_ret<double>(11.5): %f\\n\", m.f_ret<double>(11.5));\n+\n+    printf (\"=================================\\n\");\n+    printf (\"m.g_ret<int>(-10): %d\\n\", m.g_ret<int>(-10));\n+    printf (\"m.g_ret<double>(-11.5): %f\\n\", m.g_ret<double>(-11.5));\n+    printf (\"m.g_ret<int>(10): %d\\n\", m.g_ret<int>(10));\n+    printf (\"m.g_ret<double>(11.5): %f\\n\", m.g_ret<double>(11.5));\n+  }\n+\n+  {\n+    S<int> s;\n+    printf (\"=================================\\n\");\n+    s.f<int>(-10);\n+\n+    s.f<double>(-10);\n+\n+    printf (\"=================================\\n\");\n+    s.g<int>(-10);\n+\n+    s.g<double>(-10);\n+  }\n+\n+  {\n+    S<double> s;\n+    printf (\"=================================\\n\");\n+    s.f<int>(-10);\n+\n+    s.f<double>(-10);\n+\n+    printf (\"=================================\\n\");\n+    s.g<int>(-10);\n+\n+    s.g<double>(-10);\n+  }\n+\n+  return 0;\n+}\n+\n+// { dg-output \"=================================(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 7 M::f<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.f<int>.-10.: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 7 M::f<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.f<double>.-11.5.: 11(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.f<int>.10.: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.f<double>.11.5.: -11(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"=================================(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 10 M::g<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.g<int>.-10.: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 10 M::g<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.g<double>.-11.5.: 11(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.g<int>.10.: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.g<double>.11.5.: -11(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"=================================(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 16 M::f_arg<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.f_arg.-10.: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 16 M::f_arg<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.f_arg.-11.5.: 11(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.f_arg.10.: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.f_arg.11.5.: -11(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"=================================(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 19 M::g_arg<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.g_arg.-10.: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 19 M::g_arg<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.g_arg.-11.5.: 11(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.g_arg.10.: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.g_arg.11.5.: -11(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"=================================(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 25 M::f_ret<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.f_ret<int>.-10.: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 25 M::f_ret<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.f_ret<double>.-11.5.: 16.500000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.f_ret<int>.10.: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.f_ret<double>.11.5.: -16.500000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"=================================(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 28 M::g_ret<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.g_ret<int>.-10.: 15(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 28 M::g_ret<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.g_ret<double>.-11.5.: 16.500000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.g_ret<int>.10.: -15(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"m.g_ret<double>.11.5.: -16.500000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"=================================(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 59 S<int>::g<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 59 S<int>::g<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"=================================(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 59 S<double>::g<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 59 S<double>::g<double> .*(\\n|\\r\\n|\\r)*\" }"}, {"sha": "4fe2f9d01920459186daabd5d222df7c77244582", "filename": "gcc/testsuite/g++.dg/contracts/contracts-pre2.C", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre2.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,212 @@\n+// basic test to ensure pre contracts work for free functions\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+#include <cstdio>\n+\n+namespace nullary\n+{\n+  int x = 10;\n+  int y = 10;\n+\n+  void fun()\n+    [[ pre: x < 0 ]]\n+  {\n+    printf(\"fun::x: %d\\n\", x);\n+  }\n+\n+  void fun2()\n+    [[ pre: x < 0 ]]\n+    [[ pre: y < 0 ]]\n+  {\n+    printf(\"fun2::x: %d fun2::y: %d\\n\", x, y);\n+  }\n+\n+  void funend()\n+    [[ pre: x < 0 ]];\n+}\n+\n+namespace nonvoid\n+{\n+  int x = 10;\n+  double y = 10.5;\n+\n+  struct S\n+  {\n+    bool z;\n+  };\n+\n+  void vfun()\n+    [[ pre: x < 0 ]]\n+  {\n+    printf(\"vfun::x: %d\\n\", x);\n+  }\n+\n+  int fun()\n+    [[ pre: x < 0 ]]\n+  {\n+    printf(\"fun::x: %d\\n\", x);\n+    return x;\n+  }\n+\n+  double fun2()\n+    [[ pre: x < 0 ]]\n+    [[ pre: y < 0 ]]\n+  {\n+    printf(\"fun2::x: %d fun2::y: %f\\n\", x, y);\n+    return y;\n+  }\n+\n+  S funend()\n+    [[ pre: x < 0 ]];\n+}\n+\n+namespace nonnullary\n+{\n+  int x = 10;\n+  double y = 10.5;\n+\n+  struct S\n+  {\n+    bool z;\n+  };\n+\n+  void vfun(int m, double n)\n+    [[ pre: x < 0 ]]\n+    [[ pre: m < 0 ]]\n+  {\n+    printf(\"vfun::x: %d\\n\", x);\n+  }\n+\n+  int fun(int m, double n)\n+    [[ pre: x < 0 ]]\n+  {\n+    printf(\"fun::x: %d\\n\", x);\n+    return x;\n+  }\n+\n+  double fun2(int m, double n)\n+    [[ pre: x < 0 ]]\n+    [[ pre: y < 0 ]]\n+    [[ pre: m < 0 ]]\n+    [[ pre: n < 0 ]]\n+  {\n+    printf(\"fun2::x: %d fun2::y: %f\\n\", x, y);\n+    return y;\n+  }\n+\n+  S funend(int m, double n)\n+    [[ pre: x < 0 ]]\n+    [[ pre: m < 0 ]];\n+}\n+\n+int main(int, char**) {\n+  // nullary void\n+  {\n+    nullary::fun();\n+    nullary::fun2();\n+    nullary::funend();\n+  }\n+\n+  // nullary non void\n+  {\n+    nonvoid::vfun();\n+\n+    int f = 13;\n+    f = nonvoid::fun();\n+    printf(\"main::f: %d\\n\", f);\n+    double d = 13.37;\n+    d = nonvoid::fun2();\n+    printf(\"main::d: %f\\n\", d);\n+    nonvoid::S s = nonvoid::funend();\n+    printf(\"main::s.z: %d\\n\", s.z ? 1 : 0);\n+  }\n+\n+  // non-nullary non-void\n+  {\n+    int x = 11;\n+    double y = 11.5;\n+\n+    nonnullary::vfun(x, y);\n+\n+    int f = 13;\n+    f = nonnullary::fun(x, y);\n+    printf(\"main::f: %d\\n\", f);\n+    double d = 13.37;\n+    d = nonnullary::fun2(x, y);\n+    printf(\"main::d: %f\\n\", d);\n+    nonnullary::S s = nonnullary::funend(x, y);\n+    printf(\"main::s.z: %d\\n\", s.z ? 1 : 0);\n+  }\n+  return 0;\n+}\n+\n+namespace nullary\n+{\n+  void funend()\n+    [[ pre: x < 0 ]]\n+  {\n+    printf(\"funend::x: %d\\n\", x);\n+  }\n+}\n+\n+namespace nonvoid\n+{\n+  S funend()\n+    [[ pre: x < 0 ]]\n+  {\n+    printf(\"funend::x: %d\\n\", x);\n+    S s;\n+    s.z = true;\n+    return s;\n+  }\n+}\n+\n+namespace nonnullary\n+{\n+  S funend(int m, double n)\n+    [[ pre: x < 0 ]]\n+    [[ pre: m < 0 ]]\n+  {\n+    printf(\"funend::x: %d\\n\", x);\n+    S s;\n+    s.z = true;\n+    return s;\n+  }\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 12 nullary::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"fun::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 18 nullary::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 19 nullary::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"fun2::x: 10 fun2::y: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 146 nullary::funend .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"funend::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 39 nonvoid::vfun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"vfun::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 45 nonvoid::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"fun::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"main::f: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 52 nonvoid::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 53 nonvoid::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"fun2::x: 10 fun2::y: 10.500000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"main::d: 10.500000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 155 nonvoid::funend .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"funend::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"main::s.z: 1(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 74 nonnullary::vfun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 75 nonnullary::vfun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"vfun::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 81 nonnullary::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"fun::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"main::f: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 88 nonnullary::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 89 nonnullary::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 90 nonnullary::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 91 nonnullary::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"fun2::x: 10 fun2::y: 10.500000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"main::d: 10.500000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 167 nonnullary::funend .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 168 nonnullary::funend .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"funend::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"main::s.z: 1(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "26167492b9743963073610e03bd0b817f152acc8", "filename": "gcc/testsuite/g++.dg/contracts/contracts-pre2a1.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre2a1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre2a1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre2a1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,33 @@\n+// ensure the feature test macros are defined pre c++20 while we still support\n+// -fcontracts independent of std version\n+// { dg-do compile { target c++11 } }\n+// { dg-additional-options \"-fcontracts\" }\n+\n+static_assert (__cpp_contracts >= 201906, \"__cpp_contracts\");\n+static_assert (__cpp_contracts_literal_semantics >= 201906, \"__cpp_contracts_literal_semantics\");\n+static_assert (__cpp_contracts_roles >= 201906, \"__cpp_contracts_roles\");\n+\n+int main()\n+{\n+  int x;\n+\n+  [[assert: x >= 0]];\n+  [[assert default: x < 0]];\n+  [[assert audit: x == 0]];\n+  [[assert axiom: x == 1]];\n+\n+  [[assert: x > 0 ? true : false]];\n+  [[assert: x < 0 ? true : false]];\n+\n+  [[assert ignore: x >= 0]];\n+  [[assert assume: x >= 0]];\n+  [[assert check_never_continue: x >= 0]];\n+  [[assert check_maybe_continue: x >= 0]];\n+\n+  [[assert %default: x >= 0]];\n+  [[assert default %default: x < 0]];\n+  [[assert audit %default: x == 0]];\n+  [[assert axiom %default: x == 1]];\n+  return 0;\n+}\n+"}, {"sha": "db9a0c37aa0f01c83414567ab0b1f65c19d98793", "filename": "gcc/testsuite/g++.dg/contracts/contracts-pre2a2.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre2a2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre2a2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre2a2.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,22 @@\n+// basic test to ensure contracts work pre-c++2a\n+// { dg-do run { target c++11 } }\n+// { dg-additional-options \"-fcontracts -fcontract-continuation-mode=on\" }\n+\n+int f(int n)\n+  [[ pre: n > 0 ]]\n+  [[ post r: r < 0 ]]\n+{\n+  [[ assert: n > 0 ]];\n+  return -n;\n+}\n+\n+int main()\n+{\n+  f(-5);\n+  return 0;\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 6 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 9 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 7 .*(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "1c4e3a98e634661ebbfb1cd35703f655d432c3fa", "filename": "gcc/testsuite/g++.dg/contracts/contracts-pre3.C", "status": "added", "additions": 525, "deletions": 0, "changes": 525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre3.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,525 @@\n+// tests to ensure pre contracts work on member functions\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+#include <cstdio>\n+\n+namespace member\n+{\n+  int x = 10;\n+  double y = 10.5;\n+\n+  struct S\n+  {\n+    bool z;\n+  };\n+\n+  struct T1\n+  {\n+    void vfun(int m, double n)\n+      [[ pre: x < 0 ]]\n+      [[ pre: m < 0 ]];\n+\n+    int fun(int m, double n)\n+      [[ pre: x < 0 ]];\n+\n+    double fun2(int m, double n)\n+      [[ pre: x < 0 ]]\n+      [[ pre: y < 0 ]]\n+      [[ pre: m < 0 ]]\n+      [[ pre: n < 0 ]];\n+\n+    S funend(int m, double n)\n+      [[ pre: x < 0 ]]\n+      [[ pre: m < 0 ]];\n+  };\n+\n+  void T1::vfun(int m, double n)\n+    [[ pre: x < 0 ]]\n+    [[ pre: m < 0 ]]\n+  {\n+    printf(\"vfun::x: %d\\n\", x);\n+  }\n+\n+\n+  int T1::fun(int m, double n)\n+    [[ pre: x < 0 ]]\n+  {\n+    printf(\"fun::x: %d\\n\", x);\n+    return x;\n+  }\n+\n+  double T1::fun2(int m, double n)\n+    [[ pre: x < 0 ]]\n+    [[ pre: y < 0 ]]\n+    [[ pre: m < 0 ]]\n+    [[ pre: n < 0 ]]\n+  {\n+    printf(\"fun2::x: %d fun2::y: %f\\n\", x, y);\n+    return y;\n+  }\n+}\n+\n+namespace special\n+{\n+  struct T1\n+  {\n+    T1(int m, int n)\n+      [[ pre: m < 0 ]]\n+      [[ pre: n < 0 ]];\n+\n+    int operator+(int m)\n+      [[ pre: m > 0 ]]\n+      [[ pre: v > 0 ]];\n+\n+    int operator-(int m)\n+      [[ pre: m > 0 ]]\n+      [[ pre: v > 0 ]];\n+\n+    ~T1()\n+      [[ pre: v > 0 ]];\n+\n+    int v{-10};\n+  };\n+\n+  T1::T1(int m, int n)\n+    [[ pre: m < 0 ]]\n+    [[ pre: n < 0 ]]\n+    : v{-m * n}\n+  {\n+  }\n+\n+  int T1::operator+(int m)\n+    [[ pre: m > 0 ]]\n+    [[ pre: v > 0 ]]\n+  {\n+    return v + m;\n+  }\n+\n+  int T1::operator-(int m)\n+    [[ pre: m > 0 ]]\n+    [[ pre: v > 0 ]]\n+  {\n+    return v - m;\n+  }\n+\n+  T1::~T1()\n+    [[ pre: v > 0 ]]\n+  {\n+  }\n+\n+  struct T2\n+  {\n+    T2(int m, int n)\n+      [[ pre: m < 0 ]]\n+      [[ pre: n < 0 ]]\n+      : v{-m * n}\n+    {\n+    }\n+\n+    int operator+(int m)\n+      [[ pre: m > 0 ]]\n+      [[ pre: v > 0 ]]\n+    {\n+      return v + m;\n+    }\n+\n+    int operator-(int m)\n+      [[ pre: m > 0 ]]\n+      [[ pre: v > 0 ]]\n+    {\n+      return v - m;\n+    }\n+\n+    ~T2()\n+      [[ pre: v > 0 ]]\n+    {\n+    }\n+\n+    int v{-10};\n+  };\n+\n+  struct TC : T1\n+  {\n+    TC(int m, int n)\n+      [[ pre: m < -1 ]]\n+      [[ pre: n < -1 ]]\n+      : T1{m, n}\n+    {\n+    }\n+\n+    ~TC()\n+      [[ pre: vc < 0 ]]\n+    {\n+    }\n+\n+    TC(int a)\n+      [[ pre: a < 0 ]]\n+      : TC{a, a}\n+    {\n+    }\n+\n+    int vc{10};\n+  };\n+\n+  void test()\n+  {\n+    T1 t1{10, 20};\n+    int a = t1 - -5;\n+    int b = t1 + -5;\n+    printf(\"==========\\n\");\n+\n+    T2 t2{10, 20};\n+    int k = t2 - -5;\n+    int j = t2 + -5;\n+    printf(\"==========\\n\");\n+\n+    TC tc{10, 20};\n+    printf(\"==========\\n\");\n+\n+    TC tc2{10};\n+    printf(\"==========\\n\");\n+  }\n+}\n+\n+namespace virt\n+{\n+  struct T1\n+  {\n+    virtual int fun(int m, int n)\n+      [[ pre: m > 0 ]]\n+      [[ pre: n > 0 ]]\n+      [[ pre: v > 0 ]];\n+    int v{-10};\n+  };\n+\n+  int T1::fun(int m, int n)\n+    [[ pre: m > 0 ]]\n+    [[ pre: n > 0 ]]\n+    [[ pre: v > 0 ]]\n+  {\n+    printf(\"T1::fun::m: %d, T1::fun::n: %d, T1::v: %d\\n\", m, n, v);\n+    return m * n * v;\n+  }\n+\n+  struct T2 : T1\n+  {\n+  };\n+\n+  struct T3 : T2\n+  {\n+    virtual int fun(int m, int n)\n+      [[ pre: m > 0 ]]\n+      [[ pre: n > 0 ]]\n+      [[ pre: v > 0 ]]\n+      override\n+    {\n+      printf(\"T3::fun::m: %d, T3::fun::n: %d, T3::v: %d\\n\", m, n, v);\n+      return m * n * v;\n+    }\n+  };\n+\n+  struct T3b : T2\n+  {\n+    virtual int fun(int m, int n)\n+      [[ pre: m > 0 ]]\n+      [[ pre: n > 0 ]]\n+      [[ pre: v > 0 ]]\n+      override;\n+\n+    int p(int a)\n+      [[ pre: a > 0 ]]\n+      [[ pre: v > 0 ]];\n+\n+    int u(int a)\n+      [[ pre: a > 0 ]]\n+      [[ pre: z > 0 ]];\n+\n+    int n(int a)\n+      [[ pre: a > 0 ]];\n+\n+    static int Sn(int a)\n+      [[ pre: a > 0 ]];\n+\n+    int z{-10};\n+  };\n+\n+  int T3b::fun(int m, int n)\n+    [[ pre: m > 0 ]]\n+    [[ pre: n > 0 ]]\n+    [[ pre: v > 0 ]]\n+  {\n+    printf(\"T3b::fun::m: %d, T3b::fun::n: %d, T3b::v: %d\\n\", m, n, v);\n+    return m * n * v;\n+  }\n+\n+  int T3b::p(int a)\n+    [[ pre: a > 0 ]]\n+    [[ pre: v > 0 ]]\n+  {\n+    printf(\"T3b::p: a: %d, v: %d\\n\", a, v);\n+    return a * v;\n+  }\n+\n+  int T3b::u(int a)\n+    [[ pre: a > 0 ]]\n+    [[ pre: z > 0 ]]\n+  {\n+    printf(\"T3b::u: a: %d, z: %d\\n\", a, z);\n+    return a * z;\n+  }\n+\n+  int T3b::n(int a)\n+    [[ pre: a > 0 ]]\n+  {\n+    printf(\"T3b::n: a: %d\\n\", a);\n+    return a;\n+  }\n+\n+  int T3b::Sn(int a)\n+    [[ pre: a > 0 ]]\n+  {\n+    printf(\"T3b::Sn: a: %d\\n\", a);\n+    return a;\n+  }\n+\n+  struct T3c : T2\n+  {\n+    int fun(int m, int n)\n+      [[ pre: m > 0 ]]\n+      [[ pre: n > 0 ]]\n+      [[ pre: v > 0 ]]\n+    {\n+      printf(\"T3c::fun::m: %d, T3c::fun::n: %d, T3c::v: %d\\n\", m, n, v);\n+      return m * n * v;\n+    }\n+\n+    int p(int a)\n+      [[ pre: a > 0 ]]\n+      [[ pre: v > 0 ]]\n+    {\n+      printf(\"T3c::p: a: %d, v: %d\\n\", a, v);\n+      return a * v;\n+    }\n+\n+    int u(int a)\n+      [[ pre: a > 0 ]]\n+      [[ pre: z > 0 ]]\n+    {\n+      printf(\"T3c::u: a: %d, z: %d\\n\", a, z);\n+      return a * z;\n+    }\n+\n+    int n(int a)\n+      [[ pre: a > 0 ]]\n+    {\n+      printf(\"T3c::n: a: %d\\n\", a);\n+      return a;\n+    }\n+\n+    static int Sn(int a)\n+      [[ pre: a > 0 ]]\n+    {\n+      printf(\"T3c::Sn: a: %d\\n\", a);\n+      return a;\n+    }\n+\n+    int z{-10};\n+  };\n+\n+  void t(const char *kind, T1 *t)\n+  {\n+    printf(\"=================\\n%s:\\n\", kind);\n+    t->fun(-1, -2);\n+  }\n+\n+  void test()\n+  {\n+    T1 t1;\n+    t1.fun(-10, -20);\n+\n+    T2 t2;\n+    t2.fun(-10, -20);\n+\n+    T3 t3;\n+    t3.fun(-10, -20);\n+\n+    T3b t3b;\n+    t3b.fun(-10, -20);\n+\n+    T3c t3c;\n+    t3c.fun(-10, -20);\n+\n+    t(\"T1\", &t1);\n+    t(\"T2\", &t2);\n+    t(\"T3\", &t3);\n+    t(\"T3b\", &t3b);\n+    t(\"T3c\", &t3c);\n+\n+    printf(\"=============\\n\");\n+    t3b.p(-3);\n+    t3b.u(-3);\n+    t3b.n(-3);\n+    T3b::Sn(-3);\n+\n+    printf(\"=============\\n\");\n+    t3c.p(-3);\n+    t3c.u(-3);\n+    t3c.n(-3);\n+    T3c::Sn(-3);\n+  }\n+}\n+\n+int main(int, char**) \n+{\n+  // ordinary member functions\n+  {\n+    int x = 11;\n+    double y = 11.5;\n+    member::T1 t1;\n+    t1.vfun(x, y);\n+\n+    int f = 13;\n+    f = t1.fun(x, y);\n+    printf(\"main::f: %d\\n\", f);\n+    double d = 13.37;\n+    d = t1.fun2(x, y);\n+    printf(\"main::d: %f\\n\", d);\n+    member::S s = t1.funend(x, y);\n+    printf(\"main::s.z: %d\\n\", s.z ? 1 : 0);\n+  }\n+\n+  special::test();\n+  virt::test();\n+  return 0;\n+}\n+\n+member::S member::T1::funend(int m, double n)\n+  [[ pre: x < 0 ]]\n+  [[ pre: m < 0 ]]\n+{\n+  printf(\"funend::x: %d\\n\", x);\n+  S s;\n+  s.z = true;\n+  return s;\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 37 member::T1::vfun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 38 member::T1::vfun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"vfun::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 45 member::T1::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"fun::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"main::f: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 52 member::T1::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 53 member::T1::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 54 member::T1::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 55 member::T1::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"fun2::x: 10 fun2::y: 10.500000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"main::d: 10.500000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 397 member::T1::funend .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 398 member::T1::funend .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"funend::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"main::s.z: 1(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 85 special::T1::T1 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 86 special::T1::T1 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 99 special::T1::operator- .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 100 special::T1::operator- .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 92 special::T1::operator. .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 93 special::T1::operator. .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"==========(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 113 special::T2::T2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 114 special::T2::T2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 127 special::T2::operator- .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 128 special::T2::operator- .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 120 special::T2::operator. .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 121 special::T2::operator. .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"==========(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 144 special::TC::TC .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 145 special::TC::TC .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 85 special::T1::T1 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 86 special::T1::T1 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"==========(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 156 special::TC::TC .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 144 special::TC::TC .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 145 special::TC::TC .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 85 special::T1::T1 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 86 special::T1::T1 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"==========(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 151 special::TC::~TC .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 106 special::T1::~T1 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 151 special::TC::~TC .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 106 special::T1::~T1 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 134 special::T2::~T2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 106 special::T1::~T1 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 196 virt::T1::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 197 virt::T1::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 198 virt::T1::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T1::fun::m: -10, T1::fun::n: -20, T1::v: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 196 virt::T1::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 197 virt::T1::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 198 virt::T1::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T1::fun::m: -10, T1::fun::n: -20, T1::v: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 211 virt::T3::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 212 virt::T3::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 213 virt::T3::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T3::fun::m: -10, T3::fun::n: -20, T3::v: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 247 virt::T3b::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 248 virt::T3b::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 249 virt::T3b::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T3b::fun::m: -10, T3b::fun::n: -20, T3b::v: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 288 virt::T3c::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 289 virt::T3c::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 290 virt::T3c::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T3c::fun::m: -10, T3c::fun::n: -20, T3c::v: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"=================(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T1:(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 196 virt::T1::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 197 virt::T1::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 198 virt::T1::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T1::fun::m: -1, T1::fun::n: -2, T1::v: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"=================(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T2:(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 196 virt::T1::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 197 virt::T1::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 198 virt::T1::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T1::fun::m: -1, T1::fun::n: -2, T1::v: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"=================(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T3:(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 211 virt::T3::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 212 virt::T3::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 213 virt::T3::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T3::fun::m: -1, T3::fun::n: -2, T3::v: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"=================(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T3b:(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 247 virt::T3b::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 248 virt::T3b::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 249 virt::T3b::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T3b::fun::m: -1, T3b::fun::n: -2, T3b::v: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"=================(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T3c:(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 288 virt::T3c::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 289 virt::T3c::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 290 virt::T3c::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T3c::fun::m: -1, T3c::fun::n: -2, T3c::v: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"=============(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 256 virt::T3b::p .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 257 virt::T3b::p .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T3b::p: a: -3, v: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 264 virt::T3b::u .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 265 virt::T3b::u .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T3b::u: a: -3, z: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 272 virt::T3b::n .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T3b::n: a: -3(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 279 virt::T3b::Sn .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T3b::Sn: a: -3(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"=============(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 297 virt::T3c::p .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 298 virt::T3c::p .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T3c::p: a: -3, v: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 305 virt::T3c::u .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 306 virt::T3c::u .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T3c::u: a: -3, z: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 313 virt::T3c::n .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T3c::n: a: -3(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 320 virt::T3c::Sn .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"T3c::Sn: a: -3(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "16189cdce9de07fb8ce4d8c057094f9277dd234d", "filename": "gcc/testsuite/g++.dg/contracts/contracts-pre4.C", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre4.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,92 @@\n+// test that contracts on overriding functions are found correctly\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+\n+struct Base\n+{\n+  virtual int f(int a) [[ pre: a > 0 ]];\n+};\n+\n+int Base::f(int a)\n+{\n+  return a + 10;\n+}\n+\n+// inherits original\n+struct Child0 : Base\n+{\n+};\n+\n+// defined out of line, explicit override\n+struct Child1 : Base\n+{\n+  virtual int f(int a) override;\n+};\n+\n+int Child1::f(int a)\n+{\n+  return a + 20;\n+}\n+\n+// defined out of line\n+struct Child2 : Base\n+{\n+  int f(int a);\n+};\n+\n+int Child2::f(int a)\n+{\n+  return a + 30;\n+}\n+\n+// defined inline, explicitly override\n+struct Child3 : Base\n+{\n+  virtual int f(int a) override\n+  {\n+    return a + 40;\n+  }\n+};\n+\n+// defined inline\n+struct Child4 : Base\n+{\n+  int f(int a)\n+  {\n+    return a + 50;\n+  }\n+};\n+\n+#include <cstdio>\n+int main(int, char**)\n+{\n+  Base b;\n+  Child0 c0;\n+  Child1 c1;\n+  Child2 c2;\n+  Child3 c3;\n+  Child4 c4;\n+\n+  printf(\"Base: %d\\n\", b.f(-10));\n+  printf(\"Child0: %d\\n\", c0.f(-10));\n+  printf(\"Child1: %d\\n\", c1.f(-10));\n+  printf(\"Child2: %d\\n\", c2.f(-10));\n+  printf(\"Child3: %d\\n\", c3.f(-10));\n+  printf(\"Child4: %d\\n\", c4.f(-10));\n+\n+  return 0;\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 7 Base::f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"Base: 0(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 7 Base::f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"Child0: 0(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 7 Child1::f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"Child1: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 7 Child2::f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"Child2: 20(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 7 Child3::f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"Child3: 30(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 7 Child4::f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"Child4: 40(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "278a545055f0dc9ce4a7e4173e82275e30101b7a", "filename": "gcc/testsuite/g++.dg/contracts/contracts-pre5.C", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre5.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,81 @@\n+// basic test to ensure pre contracts work for free templates\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+#include <cstdio>\n+\n+template<typename T>\n+int body(int a)\n+  [[ pre: a > 0 ]]\n+{\n+  T t = a * 2.5;\n+  return t;\n+}\n+\n+template<typename T>\n+int none(int a)\n+  [[ pre: a > 0 ]]\n+{\n+  return -a;\n+}\n+\n+template<typename T>\n+int arg0(T t)\n+  [[ pre: t > 0 ]]\n+{\n+  return -t - 10;\n+}\n+\n+template<typename T>\n+int arg1(int a, T t)\n+  [[ pre: a > 0 ]]\n+  [[ pre: t > 0 ]]\n+{\n+  return -t * a;\n+}\n+\n+template<typename T>\n+T ret(int a)\n+  [[ pre: a > 0 ]]\n+{\n+  return -a;\n+}\n+\n+int main(int, char**)\n+{\n+  printf(\"%d\\n\", body<int>(-1));\n+  printf(\"%d\\n\", body<double>(-2));\n+  printf(\"%d\\n\", none<int>(-1));\n+  printf(\"%d\\n\", none<double>(-2));\n+  printf(\"%d\\n\", arg0(-1));\n+  printf(\"%d\\n\", arg0(-2.9));\n+  printf(\"%d\\n\", arg1(-3, -1));\n+  printf(\"%d\\n\", arg1(-4, -2.9));\n+  printf(\"%d\\n\", (int)ret<int>(-3));\n+  printf(\"%d\\n\", (int)ret<double>(-4.9));\n+\n+  return 0;\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 8 body<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"-2(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 8 body<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"-5(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 16 none<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"1(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 16 none<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"2(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 23 arg0<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"-9(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 23 arg0<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"-7(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 30 arg1<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 31 arg1<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"-3(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 30 arg1<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 31 arg1<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"-11(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 38 ret<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"3(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 38 ret<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"4(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "44e8e264b54a829270ac757eb192a11a798e5040", "filename": "gcc/testsuite/g++.dg/contracts/contracts-pre6.C", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre6.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,74 @@\n+// ensure no errors are thrown when we have to insert a decl for the internal\n+// unchecked function after leaving a (possibly nested) namespace\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+namespace ns0\n+{\n+  int f(int a) [[ pre: a > 0 ]];\n+}\n+\n+int ns0::f(int a) [[ pre: a > 0 ]]\n+{\n+  return -a;\n+}\n+\n+namespace ns0\n+{\n+  namespace ns1\n+  {\n+    int f(int a) [[ pre: a > 0 ]];\n+  }\n+}\n+\n+int ns0::ns1::f(int a) [[ pre: a > 0 ]]\n+{\n+  return -a;\n+}\n+\n+namespace ns0\n+{\n+  namespace ns1\n+  {\n+    int f2(int a) [[ pre: a > 0 ]];\n+    namespace ns2\n+    {\n+      int f(int a) [[ pre: a > 0 ]];\n+    }\n+  }\n+  int ns1::f2(int a) [[ pre: a > 0 ]]\n+  {\n+    return -a;\n+  }\n+}\n+\n+int ns0::ns1::ns2::f(int a) [[ pre: a > 0 ]]\n+{\n+  return -a;\n+}\n+\n+namespace ns0\n+{\n+  struct S\n+  {\n+    int f(int a) [[ pre: a > 0 ]];\n+  };\n+  namespace ns1\n+  {\n+    struct S2\n+    {\n+      int f(int a) [[ pre: a > 0 ]];\n+    };\n+  }\n+}\n+\n+int ns0::S::f(int a) [[ pre: a > 0 ]]\n+{\n+  return -a;\n+}\n+\n+int ns0::ns1::S2::f(int a) [[ pre: a > 0 ]]\n+{\n+  return -a;\n+}\n+"}, {"sha": "aeb8fc042e6c0940b65a3ca65ae00764bf3e6264", "filename": "gcc/testsuite/g++.dg/contracts/contracts-pre7.C", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre7.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,134 @@\n+// ensure no errors are thrown when we have to insert a decl for the internal\n+// unchecked function after leaving a (possibly nested) namespace\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+\n+namespace ns0\n+{\n+  template<typename T>\n+  int f(T a) [[ pre: a > 0 ]];\n+}\n+\n+template<typename T>\n+int ns0::f(T a) [[ pre: a > 0 ]]\n+{\n+  return (int)-a;\n+}\n+\n+namespace ns0\n+{\n+  namespace ns1\n+  {\n+    template<typename T>\n+    int f(T a) [[ pre: a > 0 ]];\n+  }\n+}\n+\n+template<typename T>\n+int ns0::ns1::f(T a) [[ pre: a > 0 ]]\n+{\n+  return -a;\n+}\n+\n+namespace ns0\n+{\n+  namespace ns1\n+  {\n+    template<typename T>\n+    int f2(T a) [[ pre: a > 0 ]];\n+    namespace ns2\n+    {\n+      template<typename T>\n+      int f(T a) [[ pre: a > 0 ]];\n+    }\n+  }\n+  template<typename T>\n+  int ns1::f2(T a) [[ pre: a > 0 ]]\n+  {\n+    return -a;\n+  }\n+}\n+\n+template<typename T>\n+int ns0::ns1::ns2::f(T a) [[ pre: a > 0 ]]\n+{\n+  return -a;\n+}\n+\n+namespace ns0\n+{\n+  template<typename T>\n+  struct S\n+  {\n+    int f(T a) [[ pre: a > 0 ]];\n+  };\n+  namespace ns1\n+  {\n+    template<typename T>\n+    struct S2\n+    {\n+      int f(T a) [[ pre: a > 0 ]];\n+    };\n+  }\n+}\n+\n+template<typename T>\n+int ns0::S<T>::f(T a) [[ pre: a > 0 ]]\n+{\n+  return -a;\n+}\n+\n+template<typename T>\n+int ns0::ns1::S2<T>::f(T a) [[ pre: a > 0 ]]\n+{\n+  return -a;\n+}\n+\n+#include <cstdio>\n+int main(int, char**)\n+{\n+  printf (\"%d\\n\", ns0::f(-1));\n+  printf (\"%d\\n\", ns0::ns1::f(-2));\n+  printf (\"%d\\n\", ns0::ns1::f2(-3));\n+  printf (\"%d\\n\", ns0::ns1::ns2::f(-4));\n+  ns0::S<int> ns0_s;\n+  printf (\"%d\\n\", ns0_s.f(-5));\n+  ns0::ns1::S2<int> ns0_ns1_s2;\n+  printf (\"%d\\n\", ns0_ns1_s2.f(-6));\n+\n+  printf (\"%d\\n\", ns0::f(-7.5));\n+  printf (\"%d\\n\", ns0::ns1::f(-8.5));\n+  printf (\"%d\\n\", ns0::ns1::f2(-9.5));\n+  printf (\"%d\\n\", ns0::ns1::ns2::f(-10.5));\n+  ns0::S<double> ns0_sd;\n+  printf (\"%d\\n\", ns0_sd.f(-11.5));\n+  ns0::ns1::S2<double> ns0_ns1_s2d;\n+  printf (\"%d\\n\", ns0_ns1_s2d.f(-12.5));\n+\n+  return 0;\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 13 ns0::f<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"1(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 28 ns0::ns1::f<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"2(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 46 ns0::ns1::f2<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"3(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 53 ns0::ns1::ns2::f<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"4(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 76 ns0::S<int>::f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"5(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 82 ns0::ns1::S2<int>::f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"6(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 13 ns0::f<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"7(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 28 ns0::ns1::f<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"8(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 46 ns0::ns1::f2<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"9(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 53 ns0::ns1::ns2::f<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 76 ns0::S<double>::f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"11(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 82 ns0::ns1::S2<double>::f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"12(\\n|\\r\\n|\\r)*\" }"}, {"sha": "64c0cfa36dfe3b9bf80fb2dadf3af5b7731ea9e9", "filename": "gcc/testsuite/g++.dg/contracts/contracts-pre9.C", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-pre9.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,146 @@\n+// ensure no errors are thrown for various combinations of class templates\n+// with guarded members\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+\n+template<typename T>\n+struct S\n+{\n+  int f(int a) [[ pre: a > 0 ]];\n+  int g(int a) [[ pre: a > 0 ]];\n+};\n+\n+template<typename T>\n+int S<T>::f(int a) [[ pre: a > 0 ]]\n+{\n+  return -a;\n+}\n+\n+template<typename T>\n+int S<T>::g(int a) // Contract is inherited (error from line 10).\n+{\n+  return -a;\n+}\n+\n+template<typename T>\n+struct S_arg\n+{\n+  int f(T a) [[ pre: a > 0 ]];\n+  int g(T a) [[ pre: a > 0 ]];\n+};\n+\n+template<typename T>\n+int S_arg<T>::f(T a) [[ pre: a > 0 ]]\n+{\n+  return -a;\n+}\n+\n+template<typename T>\n+int S_arg<T>::g(T a) // Contract is inherited (error from line 29).\n+{\n+  return -a;\n+}\n+\n+template<typename T>\n+struct S_ret\n+{\n+  T f(int a) [[ pre: a > 0 ]];\n+  T g(int a) [[ pre: a > 0 ]];\n+};\n+\n+template<typename T>\n+T S_ret<T>::f(int a) [[ pre: a > 0 ]]\n+{\n+  return -a;\n+}\n+\n+template<typename T>\n+T S_ret<T>::g(int a) // Contract is inherited (error from line 48).\n+{\n+  return -a;\n+}\n+\n+#include <cstdio>\n+int main(int, char**)\n+{\n+  {\n+    S<int> s_int;\n+    printf (\"s_int.f(-10): %d\\n\", s_int.f(-10));\n+    printf (\"s_int.g(-10): %d\\n\", s_int.g(-10));\n+    printf (\"s_int.f(10): %d\\n\", s_int.f(10));\n+    printf (\"s_int.g(10): %d\\n\", s_int.g(10));\n+\n+    S<double> s_double;\n+    printf (\"s_double.f(-10.5): %d\\n\", s_double.f(-10.5));\n+    printf (\"s_double.g(-10.5): %d\\n\", s_double.g(-10.5));\n+    printf (\"s_double.f(10.5): %d\\n\", s_double.f(10.5));\n+    printf (\"s_double.g(10.5): %d\\n\", s_double.g(10.5));\n+  }\n+\n+  {\n+    S_arg<int> s_arg_int;\n+    printf (\"s_arg_int.f(-10): %d\\n\", s_arg_int.f(-10));\n+    printf (\"s_arg_int.g(-10): %d\\n\", s_arg_int.g(-10));\n+    printf (\"s_arg_int.f(10): %d\\n\", s_arg_int.f(10));\n+    printf (\"s_arg_int.g(10): %d\\n\", s_arg_int.g(10));\n+\n+    S_arg<double> s_arg_double;\n+    printf (\"s_arg_double.f(-10): %d\\n\", s_arg_double.f(-10));\n+    printf (\"s_arg_double.g(-10): %d\\n\", s_arg_double.g(-10));\n+    printf (\"s_arg_double.f(10): %d\\n\", s_arg_double.f(10));\n+    printf (\"s_arg_double.g(10): %d\\n\", s_arg_double.g(10));\n+  }\n+\n+  {\n+    S_ret<int> s_ret_int;\n+    printf (\"s_ret_int.f(-10): %d\\n\", s_ret_int.f(-10));\n+    printf (\"s_ret_int.g(-10): %d\\n\", s_ret_int.g(-10));\n+    printf (\"s_ret_int.f(10): %d\\n\", s_ret_int.f(10));\n+    printf (\"s_ret_int.g(10): %d\\n\", s_ret_int.g(10));\n+\n+    S_ret<double> s_ret_double;\n+    printf (\"s_ret_double.f(-10): %f\\n\", s_ret_double.f(-10));\n+    printf (\"s_ret_double.g(-10): %f\\n\", s_ret_double.g(-10));\n+    printf (\"s_ret_double.f(10): %f\\n\", s_ret_double.f(10));\n+    printf (\"s_ret_double.g(10): %f\\n\", s_ret_double.g(10));\n+  }\n+\n+  return 0;\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 14 S<int>::f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_int.f.-10.: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 10 S<int>::g .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_int.g.-10.: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_int.f.10.: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_int.g.10.: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 14 S<double>::f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_double.f.-10.5.: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 10 S<double>::g .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_double.g.-10.5.: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_double.f.10.5.: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_double.g.10.5.: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 33 S_arg<int>::f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_arg_int.f.-10.: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 29 S_arg<int>::g .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_arg_int.g.-10.: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_arg_int.f.10.: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_arg_int.g.10.: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 33 S_arg<double>::f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_arg_double.f.-10.: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 29 S_arg<double>::g .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_arg_double.g.-10.: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_arg_double.f.10.: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_arg_double.g.10.: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 52 S_ret<int>::f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_ret_int.f.-10.: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 48 S_ret<int>::g .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_ret_int.g.-10.: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_ret_int.f.10.: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_ret_int.g.10.: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 52 S_ret<double>::f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_ret_double.f.-10.: 10.000000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 48 S_ret<double>::g .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_ret_double.g.-10.: 10.000000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_ret_double.f.10.: -10.000000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"s_ret_double.g.10.: -10.000000(\\n|\\r\\n|\\r)*\" }"}, {"sha": "58d0aafeff53b1f97899d3c9a833461a1afa097e", "filename": "gcc/testsuite/g++.dg/contracts/contracts-redecl1.C", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,149 @@\n+// generic error tests for contract redecls with generalized redecl\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+// OK if equivalent -- even through renames.\n+int g0(int a) [[ pre: a > 0 ]];\n+int g0(int a) [[ pre: a > 0 ]];\n+\n+int g0b(int a) [[ pre: a > 0 ]];\n+int g0b(int b) [[ pre: b > 0 ]];\n+int g0b(int c) [[ pre: c > 0 ]]\n+{\n+  return 0;\n+}\n+\n+// OK if specified before.\n+int g1(int a) [[ pre: a > 0 ]];\n+int g1(int a);\n+\n+// OK if specified after.\n+int g2(int a);\n+int g2(int a) [[ pre: a > 0 ]];\n+\n+int g2b(int a);\n+int g2b(int b) [[ pre: b > 0 ]];\n+\n+// can add to non-virtual methods\n+struct G0\n+{\n+  int f(int a);\n+};\n+\n+// OK to add contracts at the point of definition.\n+int G0::f(int a) [[ pre: a > 0 ]]\n+{\n+  return -a;\n+}\n+\n+struct G1\n+{\n+  int f1(int a);\n+};\n+\n+// OK to redeclare functions and add constraints...\n+int G1::f1(int a) [[ pre: a > 0 ]];\n+\n+// ...and leave them off later.\n+int G1::f1(int a)\n+{\n+  return -a;\n+}\n+\n+int f0(int a) [[ pre: a > 0 ]];\n+int f0(int a) [[ pre: a > 0 ]] [[ pre: a > 10 ]]; // { dg-error \"different number of contracts\" }\n+\n+int f1(int a) [[ pre: a > 0 ]] [[ pre: a > 10 ]];\n+int f1(int a) [[ pre: a > 0 ]]; // { dg-error \"different number of contracts\" }\n+\n+int f2(int a) [[ pre: a > 0 ]];\n+int f2(int a) [[ pre: a < 0 ]]; // { dg-error \"mismatched contract\" }\n+\n+int f3(int a) { return a; }\n+int f3(int a) [[ pre: a < 0 ]]; // { dg-error \"cannot add contracts\" }\n+\n+struct Base\n+{\n+  virtual int f(int a) [[ pre: a > 0 ]];\n+};\n+\n+struct Child : Base\n+{\n+  int f(int a) [[ pre: a < 0 ]]; // { dg-error \"mismatched contract\" }\n+};\n+\n+struct S1\n+{\n+  virtual int f(int a); // contracts are inherited at the point of declarations\n+};\n+\n+int S1::f(int a) [[ pre: a > 0 ]] // { dg-error \"cannot add\" }\n+{\n+  return -a;\n+}\n+\n+struct S2\n+{\n+  int f() { return 0; }\n+};\n+\n+int S2::f(); // OK?\n+\n+\n+struct S3\n+{\n+  int f() { return 0; }\n+};\n+\n+int S3::f() [[pre: true]]; // { dg-error \"cannot add contracts\" }\n+\n+\n+// The initial decl of a guarded member must appear inside the class.\n+struct S4\n+{\n+  int f(int a);\n+};\n+\n+int S4::g(int a) [[ pre: a > 0 ]]; // { dg-error \"no declaration matches\" }\n+\n+\n+struct S5\n+{\n+  template<typename T>\n+  S5(T a);\n+};\n+\n+template<typename T>\n+S5::S5(T a) [[ pre: a > 0 ]]\n+{\n+}\n+\n+struct S6\n+{\n+  template<typename T>\n+  S6(T a);\n+};\n+\n+template<typename T>\n+S6::S6(T a) [[ pre: a > 0 ]];\n+\n+template<typename T>\n+S6::S6(T a)\n+{\n+}\n+\n+int p0(int n)\n+  [[ post r: r > 0 && r == n ]]\n+  [[ post r: r > 1 && r == n ]]\n+  [[ post r: r > 2 && r == n ]]\n+  [[ post r: r > 3 && r == n ]];\n+\n+int p0(int z)\n+  [[ post r: r > 0 && r == z ]]\n+  [[ post r1: r1 > 1 && r1 == z ]]\n+  [[ post r2: r2 > 2 && r2 == z ]]\n+  [[ post r3: r3 > 3 && r3 == z ]]\n+{\n+  return z;\n+}\n+"}, {"sha": "70c9259049fa1b56946b6b95d601a622df404ac6", "filename": "gcc/testsuite/g++.dg/contracts/contracts-redecl2.C", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl2.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,149 @@\n+// generic error tests for generalized contract redecls\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+// allowed to repeat contracts or omit them\n+int g0(int a) [[ pre: a > 0 ]];\n+int g0(int a) [[ pre: a > 0 ]];\n+\n+int g1(int a) [[ pre: a > 0 ]];\n+int g1(int a);\n+\n+// allowed to add from none if generalized redecl is on (by default)\n+int g2(int a);\n+int g2(int a) [[ pre: a > 0 ]];\n+\n+// can add to non-virtual methods\n+struct G0\n+{\n+  int f(int a);\n+};\n+\n+int G0::f(int a) [[ pre: a > 0 ]]\n+{\n+  return -a;\n+}\n+\n+struct G1\n+{\n+  int f(int a);\n+};\n+\n+int G1::f(int a) [[ pre: a > 0 ]];\n+\n+int G1::f(int a)\n+{\n+  return -a;\n+}\n+\n+// allowed to redeclare even without contracts\n+struct G2\n+{\n+  int f(int a);\n+};\n+\n+int G2::f(int a);\n+\n+\n+int f0(int a) [[ pre: a > 0 ]];\n+int f0(int a) [[ pre: a > 0 ]] [[ pre: a > 10 ]]; // { dg-error \"different number of contracts\" }\n+\n+int f1(int a) [[ pre: a > 0 ]];\n+int f1(int a) [[ pre: a < 0 ]]; // { dg-error \"mismatched contract\" }\n+\n+int f2(int a) { return a; }\n+int f2(int a) [[ pre: a < 0 ]]; // { dg-error \"cannot add contracts after definition\" }\n+\n+struct Base\n+{\n+  virtual int f(int a) [[ pre: a > 0 ]];\n+};\n+\n+struct Child : Base\n+{\n+  int f(int a) [[ pre: a < 0 ]]; // { dg-error \"mismatched contract\" }\n+};\n+\n+// the initial decl of a guarded member must appear inside the class\n+struct F2\n+{\n+  int f(int a);\n+};\n+\n+int F2::g(int a) [[ pre: a > 0 ]]; // { dg-error \"no declaration matches\" }\n+// FIXME if we move F2 down then a different error makes F2 undeclared\n+\n+struct F0\n+{\n+  virtual int f(int a);\n+};\n+\n+int F0::f(int a); // { dg-error \"declaration.*is not definition\" }\n+\n+struct F1\n+{\n+  virtual int f(int a);\n+};\n+\n+int F1::f(int a) [[ pre: a > 0 ]] // { dg-error \"cannot add\" }\n+{\n+  return -a;\n+}\n+\n+// cannot \"re\"declare members of a forward declared class\n+struct F2;\n+int F2::test(); // { dg-error \"no declaration matches\" }\n+int F2::test2() [[ pre: true ]]; // { dg-error \"no declaration matches\" }\n+\n+// can only redeclare member functions\n+struct F3\n+{\n+  int x;\n+  typedef int my_int;\n+\n+  struct Inner0;\n+  struct Inner1;\n+  enum my_enum0; // { dg-error \"use of enum.*without previous decl\" }\n+  enum my_enum1 { E1, E2 };\n+\n+  int test0();\n+  int test1();\n+  int test2();\n+};\n+\n+int F3::x{-1}; // { dg-error \"is not a static data member\" }\n+typedef double F3::my_int; // { dg-error \"typedef name may not be a nested-name-specifier\" }\n+struct F3::Inner0; // { dg-warning \"declaration.*does not declare anything\" }\n+\n+struct F3::Inner1 { };\n+\n+enum F3::my_enum1 { E0, E1, END }; // { dg-error \"multiple definition\" }\n+\n+struct F4\n+{\n+  int test0();\n+\n+  int F3::test0() [[ pre: true ]]; // { dg-error \"cannot declare member function\" }\n+  friend int F3::test1();\n+  friend int F3::test2();\n+};\n+int F3::test2() [[ pre: true ]] { return -1; }\n+\n+void dummy0()\n+{\n+  int F4::test0() [[ pre: true ]]; // { dg-error \"qualified-id in declaration\" }\n+}\n+\n+namespace ns0\n+{\n+  typedef int value;\n+  struct X\n+  {\n+    int test1(value);\n+    typedef double value;\n+    int test2(value);\n+  };\n+  int X::test1(value); // { dg-error \"no declaration matches\" }\n+  int X::test2(value);\n+}\n+"}, {"sha": "fdfca3a65ff3d2a30d3716a5f668b00ff528e292", "filename": "gcc/testsuite/g++.dg/contracts/contracts-redecl3.C", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl3.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,195 @@\n+// basic test to ensure contracts generalized redecl works\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+#include <cstdio>\n+\n+namespace defining\n+{\n+  int x = 10;\n+  double y = 10.5;\n+\n+  struct S\n+  {\n+    bool z;\n+  };\n+\n+  struct T1\n+  {\n+    void vfun(int m, double n);\n+    int fun(int m, double n);\n+    double fun2(int m, double n);\n+    S funend(int m, double n);\n+  };\n+\n+  void T1::vfun(int m, double n)\n+    [[ pre: x < 0 ]]\n+    [[ pre: m < 0 ]]\n+  {\n+    printf(\"vfun::x: %d\\n\", x);\n+  }\n+\n+  int T1::fun(int m, double n)\n+    [[ pre: x < 0 ]]\n+  {\n+    printf(\"fun::x: %d\\n\", x);\n+    return x;\n+  }\n+\n+  double T1::fun2(int m, double n)\n+    [[ pre: x < 0 ]]\n+    [[ pre: y < 0 ]]\n+    [[ pre: m < 0 ]]\n+    [[ pre: n < 0 ]]\n+  {\n+    printf(\"fun2::x: %d fun2::y: %f\\n\", x, y);\n+    return y;\n+  }\n+}\n+\n+namespace nondefining\n+{\n+  int x = 10;\n+  double y = 10.5;\n+\n+  struct S\n+  {\n+    bool z;\n+  };\n+\n+  struct T1\n+  {\n+    void vfun(int m, double n);\n+    int fun(int m, double n);\n+    double fun2(int m, double n);\n+    S funend(int m, double n);\n+  };\n+\n+  void T1::vfun(int m, double n)\n+    [[ pre: x < 0 ]]\n+    [[ pre: m < 0 ]];\n+  int T1::fun(int m, double n)\n+    [[ pre: x < 0 ]];\n+  double T1::fun2(int m, double n)\n+    [[ pre: x < 0 ]]\n+    [[ pre: y < 0 ]]\n+    [[ pre: m < 0 ]]\n+    [[ pre: n < 0 ]];\n+\n+  void T1::vfun(int m, double n)\n+  {\n+    printf(\"vfun::x: %d\\n\", x);\n+  }\n+\n+  int T1::fun(int m, double n)\n+  {\n+    printf(\"fun::x: %d\\n\", x);\n+    return x;\n+  }\n+\n+  double T1::fun2(int m, double n)\n+  {\n+    printf(\"fun2::x: %d fun2::y: %f\\n\", x, y);\n+    return y;\n+  }\n+}\n+\n+int main(int, char**) {\n+  // defining redecl\n+  {\n+    int x = 11;\n+    double y = 11.5;\n+\n+    defining::T1 t1;\n+    t1.vfun(x, y);\n+\n+    int f = 13;\n+    f = t1.fun(x, y);\n+    printf(\"main::f: %d\\n\", f);\n+    double d = 13.37;\n+    d = t1.fun2(x, y);\n+    printf(\"main::d: %f\\n\", d);\n+    defining::S s = t1.funend(x, y);\n+    printf(\"main::s.z: %d\\n\", s.z ? 1 : 0);\n+  }\n+\n+  // nondefining redecl\n+  {\n+    int x = 12;\n+    double y = 12.5;\n+\n+    nondefining::T1 t1;\n+    t1.vfun(x, y);\n+\n+    int f = 13;\n+    f = t1.fun(x, y);\n+    printf(\"main::f: %d\\n\", f);\n+    double d = 13.37;\n+    d = t1.fun2(x, y);\n+    printf(\"main::d: %f\\n\", d);\n+    nondefining::S s = t1.funend(x, y);\n+    printf(\"main::s.z: %d\\n\", s.z ? 1 : 0);\n+  }\n+  return 0;\n+}\n+\n+namespace defining\n+{\n+  S T1::funend(int m, double n)\n+    [[ pre: x < 0 ]]\n+    [[ pre: m < 0 ]]\n+  {\n+    printf(\"funend::x: %d\\n\", x);\n+    S s;\n+    s.z = true;\n+    return s;\n+  }\n+}\n+\n+namespace nondefining\n+{\n+  S T1::funend(int m, double n)\n+    [[ pre: x < 0 ]]\n+    [[ pre: m < 0 ]];\n+\n+  S T1::funend(int m, double n)\n+  {\n+    printf(\"funend::x: %d\\n\", x);\n+    S s;\n+    s.z = true;\n+    return s;\n+  }\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 25 defining::T1::vfun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 26 defining::T1::vfun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"vfun::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 32 defining::T1::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"fun::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"main::f: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 39 defining::T1::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 40 defining::T1::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 41 defining::T1::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 42 defining::T1::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"fun2::x: 10 fun2::y: 10.500000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"main::d: 10.500000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 138 defining::T1::funend .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 139 defining::T1::funend .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"funend::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"main::s.z: 1(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 68 nondefining::T1::vfun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 69 nondefining::T1::vfun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"vfun::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 71 nondefining::T1::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"fun::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"main::f: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 73 nondefining::T1::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 74 nondefining::T1::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 75 nondefining::T1::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 76 nondefining::T1::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"fun2::x: 10 fun2::y: 10.500000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"main::d: 10.500000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 151 nondefining::T1::funend .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 152 nondefining::T1::funend .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"funend::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"main::s.z: 1(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "c1e234226b6cdc32a12801af9f0be7d76355d8fd", "filename": "gcc/testsuite/g++.dg/contracts/contracts-redecl4.C", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl4.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,56 @@\n+// test that free functions can be redeclared with contracts without affecting\n+// normal default parm handling\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+#include <cstdio>\n+\n+int f(int a, int, int c = 10);\n+int f(int a, int b = 11, int);\n+int f(int a, int b, int c)\n+  [[ pre: a < 0 ]]\n+  [[ pre: b < 0 ]]\n+  [[ pre: c < 0 ]];\n+\n+int f(int, int, int);\n+\n+int f(int a, int b, int c)\n+{\n+  printf(\"f: a: %d, b: %d, c: %d\\n\", a, b, c);\n+  return a * b - c;\n+}\n+\n+int f(int a = 12, int, int);\n+\n+int main(int, char **)\n+{\n+  f(1,1,1);\n+  printf(\"=====\\n\");\n+  f(1,1);\n+  printf(\"=====\\n\");\n+  f(1);\n+  printf(\"=====\\n\");\n+  f();\n+  printf(\"=====\\n\");\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 10 f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 11 f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 12 f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"f: a: 1, b: 1, c: 1(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"=====(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 10 f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 11 f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 12 f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"f: a: 1, b: 1, c: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"=====(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 10 f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 11 f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 12 f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"f: a: 1, b: 11, c: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"=====(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 10 f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 11 f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 12 f .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"f: a: 12, b: 11, c: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"=====(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "ea4835f18999b21ae3d60d00b9c8704ff4c130f5", "filename": "gcc/testsuite/g++.dg/contracts/contracts-redecl5.C", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl5.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,101 @@\n+// generic error tests for generalized contract redecls\n+//   we also test for the warning diagnostic for strict redecl\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-strict-declarations=on\" }\n+\n+// allowed to repeat contracts or omit them\n+int g0(int a) [[ pre: a > 0 ]];\n+int g0(int a) [[ pre: a > 0 ]];\n+\n+int g1(int a) [[ pre: a > 0 ]];\n+int g1(int a);\n+\n+// allowed to add from none if generalized redecl is on (by default)\n+int g2(int a);\n+int g2(int a) [[ pre: a > 0 ]]; // { dg-warning \"adds contracts\" }\n+int g2(int a) [[ pre: a > 0 ]]; // { dg-bogus \"adds contracts\" }\n+\n+// can add to non-virtual methods\n+struct G0\n+{\n+  int f(int a);\n+};\n+\n+int G0::f(int a) [[ pre: a > 0 ]] // { dg-warning \"adds contracts\" }\n+{\n+  return -a;\n+}\n+\n+struct G1\n+{\n+  int f(int a);\n+};\n+\n+int G1::f(int a) [[ pre: a > 0 ]]; // { dg-warning \"adds contracts\" }\n+// { dg-warning \"outside of class is not definition\" \"\" { target *-*-* } .-1 }\n+\n+int G1::f(int a);\n+// { dg-warning \"outside of class is not definition\" \"\" { target *-*-* } .-1 }\n+\n+int G1::f(int a) [[ pre: a > 0 ]];\n+// { dg-warning \"outside of class is not definition\" \"\" { target *-*-* } .-1 }\n+\n+int G1::f(int a)\n+{\n+  return -a;\n+}\n+\n+// allowed to redeclare even without contracts\n+struct G2\n+{\n+  int f(int a);\n+};\n+\n+int G2::f(int a); // { dg-warning \"outside of class is not definition\" }\n+\n+\n+int f0(int a) [[ pre: a > 0 ]];\n+int f0(int a) [[ pre: a > 0 ]] [[ pre: a > 10 ]]; // { dg-error \"different number of contracts\" }\n+\n+int f1(int a) [[ pre: a > 0 ]];\n+int f1(int a) [[ pre: a < 0 ]]; // { dg-error \"mismatched contract\" }\n+\n+int f2(int a) { return a; }\n+int f2(int a) [[ pre: a < 0 ]]; // { dg-error \"cannot add contracts after definition\" }\n+\n+struct Base\n+{\n+  virtual int f(int a) [[ pre: a > 0 ]];\n+};\n+\n+struct Child : Base\n+{\n+  int f(int a) [[ pre: a < 0 ]]; // { dg-error \"mismatched contract\" }\n+};\n+\n+// the initial decl of a guarded member must appear inside the class\n+struct F2\n+{\n+  int f(int a);\n+};\n+\n+int F2::g(int a) [[ pre: a > 0 ]]; // { dg-error \"no declaration matches\" }\n+// FIXME if we move F2 down then a different error makes F2 undeclared\n+\n+struct F0\n+{\n+  virtual int f(int a);\n+};\n+\n+int F0::f(int a); // { dg-error \"declaration.*is not definition\" }\n+\n+struct F1\n+{\n+  virtual int f(int a);\n+};\n+\n+int F1::f(int a) [[ pre: a > 0 ]] // { dg-error \"cannot add\" }\n+{\n+  return -a;\n+}\n+"}, {"sha": "e79a5aa38efd12eab531282f269516ff9836e8cd", "filename": "gcc/testsuite/g++.dg/contracts/contracts-redecl6.C", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl6.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,195 @@\n+// basic test to ensure contracts generalized redecl works\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+#include <cstdio>\n+\n+namespace defining\n+{\n+  int x = 10;\n+  double y = 10.5;\n+\n+  struct S\n+  {\n+    bool z;\n+  };\n+\n+  struct T1\n+  {\n+    void vfun(int m, double n) const;\n+    int fun(int m, double n) volatile;\n+    double fun2(int m, double n) const volatile;\n+    static S funend(int m, double n);\n+  };\n+\n+  void T1::vfun(int m, double n) const\n+    [[ pre: x < 0 ]]\n+    [[ pre: m < 0 ]]\n+  {\n+    printf(\"vfun::x: %d\\n\", x);\n+  }\n+\n+  int T1::fun(int m, double n) volatile\n+    [[ pre: x < 0 ]]\n+  {\n+    printf(\"fun::x: %d\\n\", x);\n+    return x;\n+  }\n+\n+  double T1::fun2(int m, double n) const volatile\n+    [[ pre: x < 0 ]]\n+    [[ pre: y < 0 ]]\n+    [[ pre: m < 0 ]]\n+    [[ pre: n < 0 ]]\n+  {\n+    printf(\"fun2::x: %d fun2::y: %f\\n\", x, y);\n+    return y;\n+  }\n+}\n+\n+namespace nondefining\n+{\n+  int x = 10;\n+  double y = 10.5;\n+\n+  struct S\n+  {\n+    bool z;\n+  };\n+\n+  struct T1\n+  {\n+    void vfun(int m, double n) const;\n+    int fun(int m, double n) volatile;\n+    double fun2(int m, double n) const volatile;\n+    static S funend(int m, double n);\n+  };\n+\n+  void T1::vfun(int m, double n) const\n+    [[ pre: x < 0 ]]\n+    [[ pre: m < 0 ]];\n+  int T1::fun(int m, double n) volatile\n+    [[ pre: x < 0 ]];\n+  double T1::fun2(int m, double n) const volatile\n+    [[ pre: x < 0 ]]\n+    [[ pre: y < 0 ]]\n+    [[ pre: m < 0 ]]\n+    [[ pre: n < 0 ]];\n+\n+  void T1::vfun(int m, double n) const\n+  {\n+    printf(\"vfun::x: %d\\n\", x);\n+  }\n+\n+  int T1::fun(int m, double n) volatile\n+  {\n+    printf(\"fun::x: %d\\n\", x);\n+    return x;\n+  }\n+\n+  double T1::fun2(int m, double n) const volatile\n+  {\n+    printf(\"fun2::x: %d fun2::y: %f\\n\", x, y);\n+    return y;\n+  }\n+}\n+\n+int main(int, char**) {\n+  // defining redecl\n+  {\n+    int x = 11;\n+    double y = 11.5;\n+\n+    defining::T1 t1;\n+    t1.vfun(x, y);\n+\n+    int f = 13;\n+    f = t1.fun(x, y);\n+    printf(\"main::f: %d\\n\", f);\n+    double d = 13.37;\n+    d = t1.fun2(x, y);\n+    printf(\"main::d: %f\\n\", d);\n+    defining::S s = defining::T1::funend(x, y);\n+    printf(\"main::s.z: %d\\n\", s.z ? 1 : 0);\n+  }\n+\n+  // nondefining redecl\n+  {\n+    int x = 12;\n+    double y = 12.5;\n+\n+    nondefining::T1 t1;\n+    t1.vfun(x, y);\n+\n+    int f = 13;\n+    f = t1.fun(x, y);\n+    printf(\"main::f: %d\\n\", f);\n+    double d = 13.37;\n+    d = t1.fun2(x, y);\n+    printf(\"main::d: %f\\n\", d);\n+    nondefining::S s = nondefining::T1::funend(x, y);\n+    printf(\"main::s.z: %d\\n\", s.z ? 1 : 0);\n+  }\n+  return 0;\n+}\n+\n+namespace defining\n+{\n+  S T1::funend(int m, double n)\n+    [[ pre: x < 0 ]]\n+    [[ pre: m < 0 ]]\n+  {\n+    printf(\"funend::x: %d\\n\", x);\n+    S s;\n+    s.z = true;\n+    return s;\n+  }\n+}\n+\n+namespace nondefining\n+{\n+  S T1::funend(int m, double n)\n+    [[ pre: x < 0 ]]\n+    [[ pre: m < 0 ]];\n+\n+  S T1::funend(int m, double n)\n+  {\n+    printf(\"funend::x: %d\\n\", x);\n+    S s;\n+    s.z = true;\n+    return s;\n+  }\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 25 defining::T1::vfun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 26 defining::T1::vfun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"vfun::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 32 defining::T1::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"fun::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"main::f: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 39 defining::T1::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 40 defining::T1::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 41 defining::T1::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 42 defining::T1::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"fun2::x: 10 fun2::y: 10.500000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"main::d: 10.500000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 138 defining::T1::funend .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 139 defining::T1::funend .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"funend::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"main::s.z: 1(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 68 nondefining::T1::vfun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 69 nondefining::T1::vfun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"vfun::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 71 nondefining::T1::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"fun::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"main::f: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 73 nondefining::T1::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 74 nondefining::T1::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 75 nondefining::T1::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 76 nondefining::T1::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"fun2::x: 10 fun2::y: 10.500000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"main::d: 10.500000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 151 nondefining::T1::funend .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 152 nondefining::T1::funend .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"funend::x: 10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"main::s.z: 1(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "e3a57eea6322aea230884945070fddf4207d6852", "filename": "gcc/testsuite/g++.dg/contracts/contracts-redecl7.C", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl7.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,95 @@\n+// test that contracts can be added during (defining) friend declarations\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+#include <cstdio>\n+struct T;\n+\n+struct S\n+{\n+  int now(int a, T *t) [[ pre: a > 0 ]] [[ pre: x < 0 ]];\n+\n+\n+  int x{-1};\n+};\n+\n+int now(int a, T *t) [[ pre: a > 0 ]];\n+int later(int a, T *t);\n+int both(int a, T *t) [[ pre: a > 0 ]];\n+\n+struct T\n+{\n+  friend int now(int a, T *t);\n+  friend int later(int a, T *t) [[ pre: a > 0 ]] [[ pre: t->pri > 0 ]]\n+  {\n+    printf(\"later: a: %d, t->pri: %d\\n\", a, t->pri);\n+    return -a * t->pri;\n+  }\n+  friend int both(int a, T *t) [[ pre: a > 0 ]]\n+  {\n+    printf(\"both: a: %d, t->pri: %d\\n\", a, t->pri);\n+    return -a * t->pri;\n+  }\n+\n+\n+  friend int S::now(int a, T *t);\n+\n+  friend int hidden(int a, T *t) [[ pre: a > 0 ]] [[ pre: t->pri > 0 ]]\n+  {\n+    printf(\"hidden: a: %d, t->pri: %d\\n\", a, t->pri);\n+    return -a * t->pri;\n+  }\n+  friend int hidden2(int a, T *t) [[ pre: a > 0 ]] [[ pre: t->pri > 0 ]]\n+  {\n+    printf(\"hidden2: a: %d, t->pri: %d\\n\", a, t->pri);\n+    return -a * t->pri;\n+  }\n+\n+  int x{1};\n+  private:\n+    int pri{-10};\n+};\n+\n+int hidden2(int a, T *t) [[ pre: a > 0 ]] [[ pre: t->pri > 0 ]];\n+\n+int S::now(int a, T *t)\n+{\n+  printf(\"S::now: a: %d, t->pri: %d\\n\", a, t->pri);\n+  return -a * t->pri;\n+}\n+\n+int now(int a, T *t)\n+{\n+  printf(\"now: a: %d, t->pri: %d\\n\", a, t->pri);\n+  return -a * t->pri;\n+}\n+\n+int main(int, char**)\n+{\n+  T t;\n+  S s;\n+  s.now(-10, &t);\n+\n+  now(-20, &t);\n+  later(-21, &t);\n+  both(-22, &t);\n+  hidden(-23, &t);\n+  hidden2(-24, &t);\n+  return 0;\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 9 S::now .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"S::now: a: -10, t->pri: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 15 now .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"now: a: -20, t->pri: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 22 later .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 22 later .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"later: a: -21, t->pri: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 27 both .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"both: a: -22, t->pri: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 36 hidden .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 36 hidden .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"hidden: a: -23, t->pri: -10(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 41 hidden2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 41 hidden2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"hidden2: a: -24, t->pri: -10(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "933adce79f9fad9241a5a2e57c4a8b3de4a109e2", "filename": "gcc/testsuite/g++.dg/contracts/contracts-redecl8.C", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-redecl8.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,64 @@\n+// test that contracts are matched on friend decls when the type is complete\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+struct T;\n+\n+int both(int x, T *t) [[ pre: x > 0 ]] { return 0; }\n+int both2(int x, T *t) [[ pre: x > 0 ]];\n+\n+template<typename Z>\n+int fn(int x, Z *z) [[ pre: x > 0 ]];\n+\n+template<typename Z>\n+int fn2(int x, Z *z);\n+\n+template<typename Z>\n+int fn3(int x, Z *z) [[ pre: x > 0 ]];\n+\n+template<>\n+int fn3<T>(int x, T *z) [[ pre: x > 1 ]];\n+\n+struct T\n+{\n+  friend int both2(int x, T *t) [[ pre: x > 1 ]] // { dg-error \"mismatched\" }\n+  {\n+    return 0;\n+  }\n+\n+  friend int hidden(int x, T *t)\n+    [[ pre: x > 1 ]] [[ pre: t->pri > 0 ]]\n+  {\n+    return x;\n+  }\n+\n+  /* cannot define friend spec, so we never get to matching contracts\n+  friend int fn<T>(int x, T *t)\n+    [[ pre: t->pri > 0 ]] { return 0; } // error defining explicit spec friend\n+    */\n+\n+  // bad, general contracts must match general\n+  template<typename Z>\n+  friend int fn(int x, Z *z)\n+    [[ pre: z->pri > 1 ]] { return 0; } // { dg-error \"mismatched\" }\n+\n+  // fine, can add contracts\n+  template<typename Z>\n+  friend int fn2(int x, Z *z)\n+    [[ pre: z->pri > 1 ]] { return 0; } // { dg-bogus \"mismatched\" }\n+\n+  /* cannot declare without definition, so dup friend can't occur:\n+  friend int dup(int x, T *t)\n+    [[ pre: t->pri > 0 ]]; // error non-defining friend with contracts\n+  friend int dup(int x, T *t)\n+    [[ pre: t->pri > 1 ]]; // error non-defining friend with contracts\n+    */\n+\n+  int x{1};\n+  private:\n+    int pri{-10};\n+};\n+\n+int hidden(int x, T *t)\n+  [[ pre: x > 0 ]] [[ pre: t->pri > 1 ]]; // { dg-error \"mismatched\" }\n+"}, {"sha": "c9e7b9cec8bf0112f2d4dc846983327c7a2e0e2d", "filename": "gcc/testsuite/g++.dg/contracts/contracts-tmpl-attr1.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-tmpl-attr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-tmpl-attr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-tmpl-attr1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+template<typename T>\n+[[z]]\n+[[nodiscard]]\n+T fun(T n)\n+  [[ pre: n > 0 ]]\n+  [[ post r: r > 0 ]] // { dg-warning \".z. attribute.*ignored\" }\n+{\n+  return n;\n+}\n+\n+int main(int, char**) {\n+  fun(-5); // { dg-warning \"ignoring return value\" }\n+  fun(-5.3); // { dg-warning \"ignoring return value\" }\n+  return 0;\n+}\n+"}, {"sha": "57ba76535438d8fb52b66de72c2b1c9d5c845285", "filename": "gcc/testsuite/g++.dg/contracts/contracts-tmpl-spec1.C", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-tmpl-spec1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-tmpl-spec1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-tmpl-spec1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,121 @@\n+// basic test to ensure pre contracts work for free template specializations\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+#include <cstdio>\n+\n+template<typename T>\n+int body(int a)\n+  [[ pre: a > 0 ]]\n+{\n+  T t = a * 2.5;\n+  return t;\n+}\n+\n+template<>\n+int body<double>(int a)\n+  [[ pre: a > 0 ]]\n+{\n+  double t = a * 3.3;\n+  return t;\n+}\n+\n+template<typename T>\n+int none(int a)\n+  [[ pre: a > 0 ]]\n+{\n+  return -a;\n+}\n+\n+template<>\n+int none<double>(int a)\n+  [[ pre: a > 0 ]]\n+{\n+  return a - 100;\n+}\n+\n+template<typename T>\n+int arg0(T t)\n+  [[ pre: t > 0 ]]\n+{\n+  return -t - 10;\n+}\n+\n+template<>\n+int arg0<double>(double t)\n+  [[ pre: t > 0 ]]\n+{\n+  return -t + 10;\n+}\n+\n+template<typename T>\n+int arg1(int a, T t)\n+  [[ pre: a > 0 ]]\n+  [[ pre: t > 0 ]]\n+{\n+  return -t * a;\n+}\n+\n+template<>\n+int arg1<double>(int a, double t)\n+  [[ pre: a > 0 ]]\n+  [[ pre: t > 0 ]]\n+{\n+  return -t * a + 17;\n+}\n+\n+template<typename T>\n+T ret(int a)\n+  [[ pre: a > 0 ]]\n+{\n+  return -a;\n+}\n+\n+template<>\n+double ret<double>(int a)\n+  [[ pre: a > 0 ]]\n+{\n+  return -a * 3.3;\n+}\n+\n+\n+int main(int, char**)\n+{\n+  printf(\"%d\\n\", body<int>(-1));\n+  printf(\"%d\\n\", body<double>(-1));\n+  printf(\"%d\\n\", none<int>(-1));\n+  printf(\"%d\\n\", none<double>(-1));\n+  printf(\"%d\\n\", arg0(-1));\n+  printf(\"%d\\n\", arg0(-1.0));\n+  printf(\"%d\\n\", arg1(-3, -1));\n+  printf(\"%d\\n\", arg1(-3, -1.0));\n+  printf(\"%d\\n\", (int)ret<int>(-1));\n+  printf(\"%d\\n\", (int)ret<double>(-1));\n+  printf(\"%f\\n\", ret<double>(-1));\n+  return 0;\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 8 body<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"-2(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 16 body<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"-3(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 24 none<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"1(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 31 none<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"-101(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 38 arg0<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"-9(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 45 arg0<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"11(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 52 arg1<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 53 arg1<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"-3(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 60 arg1<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 61 arg1<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"14(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 68 ret<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"1(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 75 ret<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"3(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 75 ret<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"3.300000(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "25982dfc826355723913c9c659f463f037b7ab05", "filename": "gcc/testsuite/g++.dg/contracts/contracts-tmpl-spec2.C", "status": "added", "additions": 395, "deletions": 0, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-tmpl-spec2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-tmpl-spec2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-tmpl-spec2.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,395 @@\n+// basic test to ensure contracts work for class and member specializations\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+#include <cstdio>\n+\n+// template specializations can have differing contracts\n+template<typename T>\n+int body(int a)\n+  [[ pre: a > 0 ]]\n+{\n+  T t = a * 2.5;\n+  return t;\n+}\n+\n+template<>\n+int body<double>(int a)\n+  [[ pre: a > 1 ]]\n+{\n+  double t = a * 3.3;\n+  return t;\n+}\n+\n+template<typename T>\n+int none(int a)\n+  [[ pre: a > 0 ]]\n+{\n+  return -a;\n+}\n+\n+template<>\n+int none<double>(int a)\n+  [[ pre: a > 1 ]]\n+{\n+  return a - 100;\n+}\n+\n+template<typename T>\n+int arg0(T t)\n+  [[ pre: t > 0 ]]\n+{\n+  return -t - 10;\n+}\n+\n+template<>\n+int arg0<double>(double t)\n+  [[ pre: t > 1 ]]\n+{\n+  return -t + 10;\n+}\n+\n+template<typename T>\n+int arg1(int a, T t)\n+  [[ pre: a > 0 ]]\n+  [[ pre: t > 0 ]]\n+{\n+  return -t * a;\n+}\n+\n+template<>\n+int arg1<double>(int a, double t)\n+  [[ pre: a > 1 ]]\n+  [[ pre: t > 1 ]]\n+{\n+  return -t * a + 17;\n+}\n+\n+template<typename T>\n+T ret(int a)\n+  [[ pre: a > 0 ]]\n+{\n+  return -a;\n+}\n+\n+template<>\n+double ret<double>(int a)\n+  [[ pre: a > 1 ]]\n+{\n+  return -a * 3.3;\n+}\n+\n+// template specializations can have no contracts\n+template<typename T>\n+int g1(T t) [[ pre: t > 0 ]]\n+{\n+  return (int)t;\n+}\n+\n+template<>\n+int g1<double>(double t)\n+{\n+  return (int)t;\n+}\n+\n+// template specializations can have no contracts in the first decl but add\n+// them later\n+template<typename T>\n+int g2(T t) [[ pre: t > 0 ]]\n+{\n+  return (int)t;\n+}\n+\n+template<>\n+int g2<double>(double t);\n+\n+template<>\n+int g2<double>(double t)\n+  [[ pre: t < 0 ]]\n+{\n+  return (int)t;\n+}\n+\n+template<>\n+int g2<char>(char t)\n+  [[ pre: t < 'c' ]]\n+{\n+  return (int)t;\n+}\n+\n+// contracts can be different on the general template, partial and full specs\n+template<typename T, typename S>\n+struct G3\n+{\n+  void f(T t, S s)\n+    [[ pre: t > 0 ]]\n+    [[ pre: s > 0 ]]\n+  {\n+    printf (\"G3 general T S\\n\");\n+  }\n+};\n+\n+template<typename S>\n+struct G3<int, S>\n+{\n+  void f(int t, S s);\n+};\n+\n+template<typename S>\n+void G3<int, S>::f(int t, S s)\n+  [[ pre: t > 1 ]]\n+  [[ pre: s > 1 ]]\n+{\n+  printf (\"G3 partial int S\\n\");\n+}\n+\n+template<>\n+void G3<int, double>::f(int t, double s)\n+  [[ pre: t > 2 ]]\n+  [[ pre: s > 2 ]]\n+{\n+  printf (\"G3 full int double\\n\");\n+}\n+\n+struct C\n+{\n+  bool operator>(int rhs) { return false; }\n+};\n+\n+// deletes contracts\n+template<>\n+void G3<int, C>::f(int t, C s);\n+\n+template<>\n+void G3<int, C>::f(int t, C s)\n+{\n+  printf (\"G3 full int C\\n\");\n+};\n+\n+// specialized ctors\n+template<typename T, typename S>\n+struct G4\n+{\n+  G4(T t, S s)\n+    [[ pre: t > 0 ]]\n+    [[ pre: s > 0 ]]\n+    [[ post: x > 0 ]]\n+  {\n+    printf (\"G4 general T S\\n\");\n+    return;\n+  }\n+  int x{-1};\n+};\n+\n+template<typename S>\n+struct G4<char, S>\n+{\n+  G4(char t, S s)\n+    [[ pre: t > 'c' ]]\n+    [[ pre: s > 3 ]]\n+    [[ post: x2 > 3 ]]\n+  {\n+    printf (\"G4 partial char S\\n\");\n+    return;\n+  }\n+  int x2{-1};\n+};\n+\n+template<>\n+G4<double, double>::G4(double, double)\n+{\n+  printf (\"G4 full double double\\n\");\n+  return;\n+}\n+\n+template<>\n+G4<double, char>::G4(double a, char b)\n+  [[ pre: a > 0 ]]\n+  [[ pre: b > 'b' ]]\n+  [[ post: x > 1 ]]\n+{\n+  printf (\"G4 full double char\\n\");\n+  return;\n+}\n+\n+// crossover of template classes and template members ok\n+template<typename T, typename S>\n+struct G5\n+{\n+  template<typename P>\n+  void f(T t, S s, P r)\n+    [[ pre: t > 0 ]]\n+    [[ pre: s > 0 ]]\n+    [[ pre: r > 0 ]]\n+  {\n+    printf (\"G5 gen T S, f gen R\\n\");\n+  }\n+};\n+\n+template<typename S>\n+struct G5<char, S>\n+{\n+  template<typename R>\n+  void f(char x, S y, R z)\n+    [[ pre: x > 'z' ]]\n+    [[ pre: y > 1 ]]\n+    [[ pre: z > 1 ]]\n+  {\n+    printf (\"G5 partial char S, f gen R\\n\");\n+  }\n+};\n+\n+template<>\n+template<typename Q>\n+void G5<double, double>::f(double a, double b, Q c)\n+  [[ pre: a > 2 ]]\n+  [[ pre: b > 2 ]]\n+  [[ pre: c > 2 ]]\n+{\n+  printf (\"G5 full double double, f gen R\\n\");\n+}\n+\n+int main(int, char**)\n+{\n+  printf(\"%d\\n\", body<int>(-1));\n+  printf(\"%d\\n\", body<double>(-1));\n+  printf(\"%d\\n\", none<int>(-1));\n+  printf(\"%d\\n\", none<double>(-1));\n+  printf(\"%d\\n\", arg0(-1));\n+  printf(\"%d\\n\", arg0(-1.0));\n+  printf(\"%d\\n\", arg1(-3, -1));\n+  printf(\"%d\\n\", arg1(-3, -1.0));\n+  printf(\"%d\\n\", (int)ret<int>(-1));\n+  printf(\"%d\\n\", (int)ret<double>(-1));\n+  printf(\"%f\\n\", ret<double>(-1));\n+\n+  printf(\"%d\\n\", g1(-1));\n+  printf(\"%d\\n\", g1(-1.0));\n+\n+  printf(\"%d\\n\", g2(-1));\n+  printf(\"%d\\n\", g2(1.0));\n+  printf(\"%d\\n\", g2('d'));\n+\n+  G3<double, double> g3_gen;\n+  G3<int, int> g3_partial;\n+  G3<int, double> g3_full;\n+  g3_gen.f(-1.0, -1.0); // general\n+  g3_partial.f(-2, -2); // partial spec\n+  g3_full.f(-3, -3.0); // full spec\n+\n+  G3<char, char> g3_gen2;\n+  G3<int, char> g3_partial2;\n+  g3_gen2.f((char)-1, (char)-1);\n+  g3_partial2.f(-1, (char)-1);\n+\n+  G3<int, C> g3_full2;\n+  g3_full2.f(5, C{});\n+  g3_full2.f(-5, C{});\n+\n+  G4 g4_gen{-1, -1};\n+  G4 g4_full1{-1.0, -1.0};\n+  G4 g4_full2{-1.0, (char)'b'};\n+  G4 g4_partial{(char)'c', -5};\n+\n+  G5<int, int> g5_gen;\n+  g5_gen.f(-1, -1, -2);\n+  g5_gen.f(-1, -1, -2.0);\n+\n+  G5<char, int> g5_part;\n+  g5_part.f('a', -1, -2);\n+  g5_part.f('a', -1, -2.1);\n+\n+  G5<double, double> g5_full;\n+  g5_full.f(-1.0, -1.0, -2);\n+  g5_full.f(-1.0, -1.0, -2.1);\n+  return 0;\n+}\n+\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 9 body<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"-2(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 17 body<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"-3(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 25 none<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"1(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 32 none<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"-101(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 39 arg0<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"-9(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 46 arg0<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"11(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 53 arg1<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 54 arg1<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"-3(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 61 arg1<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 62 arg1<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"14(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 69 ret<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"1(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 76 ret<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"3(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 76 ret<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"3.300000(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 83 g1<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"-1(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"-1(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 97 g2<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"-1(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 107 g2<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"1(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 114 g2<char> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"100(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 124 G3<double, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 125 G3<double, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"G3 general T S(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 139 G3<int, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 140 G3<int, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"G3 partial int S(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 147 G3<int, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 148 G3<int, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"G3 full int double(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 124 G3<char, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 125 G3<char, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"G3 general T S(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 139 G3<int, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 140 G3<int, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"G3 partial int S(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"G3 full int C(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"G3 full int C(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 173 G4<int, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 174 G4<int, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"G4 general T S(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 175 G4<int, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"G4 full double double(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 206 G4<double, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 207 G4<double, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"G4 full double char(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 208 G4<double, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 187 G4<char, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 188 G4<char, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"G4 partial char S(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 189 G4<char, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 220 G5<int, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 221 G5<int, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 222 G5<int, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"G5 gen T S, f gen R(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 220 G5<int, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 221 G5<int, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 222 G5<int, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"G5 gen T S, f gen R(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 233 G5<char, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 234 G5<char, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 235 G5<char, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"G5 partial char S, f gen R(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 233 G5<char, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 234 G5<char, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 235 G5<char, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"G5 partial char S, f gen R(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 244 G5<double, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 245 G5<double, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 246 G5<double, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"G5 full double double, f gen R(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 244 G5<double, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 245 G5<double, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 246 G5<double, .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"G5 full double double, f gen R(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "44725893061b42221554bb99debc86631f7014d3", "filename": "gcc/testsuite/g++.dg/contracts/contracts-tmpl-spec3.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-tmpl-spec3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-tmpl-spec3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-tmpl-spec3.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,45 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+#include <cstdio>\n+\n+template<typename T, typename S>\n+struct G5\n+{\n+  template<typename R>\n+  void f(T t, S s, R r)\n+    [[ pre: t > 0 ]] [[ pre: s > 0 ]] [[ pre: r > 0 ]]\n+  {\n+    printf (\"G5 gen T S, f gen R\\n\");\n+  }\n+};\n+\n+// specializations can remove contracts\n+template<>\n+template<typename R>\n+void G5<double, double>::f(double a, double b, R c)\n+{\n+  printf (\"G5 full double double, f gen R\\n\");\n+}\n+\n+int main(int, char**) {\n+  G5<double, double> g5_full;\n+  g5_full.f(-1.0, -1.0, -2);\n+  g5_full.f(-1.0, -1.0, -2.1);\n+\n+  G5<int, double> g5_gen;\n+  g5_gen.f(-1, -1.0, -2);\n+  g5_gen.f(-1, -1.0, -2.1);\n+  return 0;\n+}\n+\n+// { dg-output \"G5 full double double, f gen R(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"G5 full double double, f gen R(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 10 G5<int, .* t > 0 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 10 G5<int, .* s > 0 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 10 G5<int, .* r > 0 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"G5 gen T S, f gen R(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 10 G5<int, .* t > 0 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 10 G5<int, .* s > 0 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 10 G5<int, .* r > 0 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"G5 gen T S, f gen R(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "6655e016221085f6df183cc4b3c23ea2b1c67781", "filename": "gcc/testsuite/g++.dg/contracts/contracts1.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts1.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,49 @@\n+// generic assert contract parsing checks\n+//   check omitted, 'default', 'audit', and 'axiom' contract levels parse\n+//   check that all concrete semantics parse\n+//   check omitted, '%default' contract roles parse\n+//   ensure that an invalid contract level 'invalid' errors\n+//   ensure that a predicate referencing an undefined variable errors\n+//   ensure that a missing colon after contract level errors\n+//   ensure that an invalid contract role 'invalid' errors\n+//   ensure that a missing colon after contract role errors\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+static_assert (__cpp_contracts >= 201906);\n+static_assert (__cpp_contracts_literal_semantics >= 201906);\n+static_assert (__cpp_contracts_roles >= 201906);\n+\n+int main()\n+{\n+  int x;\n+\n+  [[assert: x >= 0]];\n+  [[assert default: x < 0]];\n+  [[assert audit: x == 0]];\n+  [[assert axiom: x == 1]];\n+\n+  [[assert: x > 0 ? true : false]];\n+  [[assert: x < 0 ? true : false]];\n+\n+  [[assert: x = 0]]; // { dg-error \"expected .]. before .=. token\" }\n+\n+  [[assert ignore: x >= 0]];\n+  [[assert assume: x >= 0]];\n+  [[assert check_never_continue: x >= 0]];\n+  [[assert check_maybe_continue: x >= 0]];\n+\n+  [[assert %default: x >= 0]];\n+  [[assert default %default: x < 0]];\n+  [[assert audit %default: x == 0]];\n+  [[assert axiom %default: x == 1]];\n+\n+  [[assert check_always_continue: x >= 0]]; // { dg-error \"expected contract level\" }\n+  [[assert invalid: x == 0]]; // { dg-error \"expected contract level\" }\n+  [[assert: y == 0]]; // { dg-error \".y. was not declared in this scope\" }\n+  [[assert default x == 0]]; // { dg-error \"expected .:. before .x.\" }\n+  [[assert %default x >= 0]]; // { dg-error \"expected .:. before .x.\" }\n+\n+  [[assert %invalid: x >= 0]]; // TODO: optional warning?\n+  return 0;\n+}"}, {"sha": "ce0723c3db496422ee63bb3a17354a05a187443d", "filename": "gcc/testsuite/g++.dg/contracts/contracts10.C", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts10.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,73 @@\n+// general checks to ensure that contract violations are generated during\n+// runtime when appropriate\n+// each check also validates the expected file name, line number, function,\n+// predicate, and contract level are included in the violation_info object\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-build-level=audit -fcontract-continuation-mode=on\" }\n+\n+namespace tns\n+{\n+  int fun()\n+  {\n+    int x = 1;\n+    [[ assert: x < 0 ]];\n+    return 0;\n+  }\n+  int fun2();\n+\n+  struct TestType\n+  {\n+    static int fun();\n+    static int fun2()\n+    {\n+      int x = 1;\n+      [[ assert: x < 0 ]];\n+      return 0;\n+    }\n+  };\n+}\n+\n+int tns::fun2()\n+{\n+  int x = 1;\n+  [[ assert: x < 0 ]];\n+  return 0;\n+}\n+\n+int tns::TestType::fun()\n+{\n+  int x = 1;\n+  [[ assert: x < 0 ]];\n+  return 0;\n+}\n+\n+int main()\n+{\n+  int x = 100;\n+  [[assert: x < 0]];\n+  [[assert default: x < 1]];\n+  [[assert audit: x < 2]];\n+// contract_violation.line_number() may eventually come from\n+// std::source_location which *is* affected by the #line macro; our current\n+// implementation conforms to this so we've included it as a check\n+#line 100\n+  [[assert: x < 3]];\n+  [[assert axiom: x < 4]];\n+\n+  tns::fun();\n+  tns::fun2();\n+\n+  tns::TestType::fun();\n+  tns::TestType::fun2();\n+  return 0;\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 47 main .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 48 main .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 49 main .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 100 main .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 13 tns::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 33 tns::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 40 tns::TestType::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 24 tns::TestType::fun2 .*(\\n|\\r\\n|\\r)*\" }\n+ "}, {"sha": "b41bc535e5d50cd07f618408c919a8d289120a4f", "filename": "gcc/testsuite/g++.dg/contracts/contracts11.C", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts11.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,103 @@\n+// ensure that assert contract predicates that are not convertible to bool\n+// generate an error\n+// ensure the same for instatiated template functions\n+// ensure the same for non-instatiated template functions when the predicate\n+// is not dependent on the template parameters\n+// ensure template parameter dependent, potentially non-boolean, contract\n+// predicates do not generate an error if never instatiated\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+void fun()\n+{\n+  return;\n+}\n+\n+template<typename T>\n+void fun2(T a)\n+{\n+  [[assert: fun()]]; // { dg-error \"could not convert|in argument\" }\n+}\n+\n+template<typename T>\n+void fun3(T a)\n+{\n+  [[assert: fun()]]; // { dg-error \"could not convert|in argument\" }\n+}\n+\n+template<typename T>\n+void fun4(T a)\n+{\n+  [[assert: a.fun()]];\n+}\n+\n+struct test\n+{\n+  void fun() { }\n+  void fun2() { }\n+};\n+\n+template<typename T>\n+void fun5(T a)\n+{\n+  [[assert: a.fun2()]]; // { dg-error \"could not convert\" }\n+}\n+\n+struct VoidFun\n+{\n+  void fun() { }\n+};\n+struct BoolFun\n+{\n+  bool fun() { return true; }\n+};\n+\n+template<typename T>\n+void fun6(T a)\n+{\n+  [[ assert: a.fun() ]]; // { dg-error \"could not convert\" }\n+}\n+\n+template void fun6(VoidFun);\n+\n+template<typename T>\n+void fun7(T a)\n+{\n+  [[ assert: a.fun() ]];\n+}\n+\n+template void fun7(BoolFun);\n+\n+struct ImplicitBool\n+{\n+  operator bool() { return true; }\n+};\n+struct ExplicitBool\n+{\n+  explicit operator bool() { return true; }\n+};\n+\n+template<typename T>\n+void fun8(T a)\n+{\n+  [[ assert: T() ]];\n+}\n+\n+template void fun8(ImplicitBool);\n+template void fun8(ExplicitBool);\n+\n+void fun9()\n+{\n+  [[ assert: ImplicitBool() ]];\n+  [[ assert: ExplicitBool() ]];\n+}\n+\n+int main()\n+{\n+  [[assert: fun()]]; // { dg-error \"could not convert\" }\n+  fun2(1);\n+\n+  test t;\n+  fun5(t);\n+  return 0;\n+}"}, {"sha": "f888d51296da58dfddb13053a8617930a226ea54", "filename": "gcc/testsuite/g++.dg/contracts/contracts12.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts12.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,15 @@\n+// ensure that constants for contract levels are inserted into the binary when\n+// used and omitted when the runtime check is not generated\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-build-level=default\" }\n+// { dg-final { scan-assembler-not \"audit\" } }\n+// { dg-final { scan-assembler \"default\" } }\n+\n+int main()\n+{\n+  int x = 1;\n+  [[assert: x < 0]];\n+  [[assert default: x < 0]];\n+  [[assert audit: x < 0]];\n+  return 0;\n+}"}, {"sha": "14ba0e960066728f2d556a2d6178276f8e654715", "filename": "gcc/testsuite/g++.dg/contracts/contracts13.C", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts13.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,51 @@\n+// ensure that passing asserts do not affect constexpr functions\n+// ensure that failing asserts generate an error in a constexpr function\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+constexpr int wfun(int a) {\n+  [[assert: a > 0]];\n+  return a;\n+}\n+\n+constexpr int ffun(int a) {\n+  [[assert: a > 0]];\n+  return a;\n+}\n+\n+template<typename T>\n+constexpr int tfun(T a) {\n+  [[assert: a > 0]];\n+  return a;\n+}\n+\n+template<typename T>\n+constexpr int wtfun(T a) {\n+  [[assert: a > 0]];\n+  return a;\n+}\n+\n+template<typename T>\n+constexpr int ftfun(T a) {\n+  [[assert: a > 0]];\n+  return a;\n+}\n+\n+constexpr int explicitfn(int a) {\n+  [[assert ignore: a > 0]];\n+  [[assert check_never_continue: a > 0]];\n+  return a;\n+}\n+\n+int main(int, char **) {\n+  constexpr int a = wfun(10);\n+  constexpr int b = ffun(-10); // { dg-message \"in .constexpr. expansion\" }\n+  // { dg-error \"contract predicate\" \"\" { target *-*-* } 12 }\n+  constexpr int c = wtfun(10);\n+  constexpr int d = ftfun(-10);  // { dg-message \"in .constexpr. expansion\" }\n+  // { dg-error \"contract predicate\" \"\" { target *-*-* } 30 }\n+  constexpr int e = explicitfn(-10); // { dg-message \"in .constexpr. expansion\" }\n+  // { dg-error \"contract predicate\" \"\" { target *-*-* } 36 }\n+  return 0;\n+}\n+"}, {"sha": "55208dbc0a18c553b2b04f9f16106b72a1dac1c0", "filename": "gcc/testsuite/g++.dg/contracts/contracts14.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts14.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,58 @@\n+// ensure that exceptions thrown inside a custom contract violation handler\n+// are catchable up the call stack\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+#include <iostream>\n+#include <experimental/contract>\n+\n+void handle_contract_violation(const std::experimental::contract_violation &violation) {\n+  std::cerr << \"custom std::handle_contract_violation called:\"\n+    << \" \" << violation.line_number()\n+    << \" \" << violation.file_name()\n+    << std::endl;\n+  throw -(int)violation.line_number();\n+}\n+\n+int fun() {\n+  int x = 0;\n+  [[ assert: x < 0 ]];\n+  return 0;\n+}\n+\n+int fun3() {\n+  fun();\n+  return 2;\n+}\n+\n+int main(int, char**) {\n+  try {\n+    int x = 0;\n+    [[ assert: x < 0 ]];\n+  } catch(int &ex) {\n+    std::cerr << \"synth caught direct: \" << ex << std::endl;\n+  }\n+\n+  try {\n+    fun();\n+  } catch(int &ex) {\n+    std::cerr << \"synth caught indirect: \" << ex << std::endl;\n+  }\n+\n+  try {\n+    fun3();\n+  } catch(int &ex) {\n+    std::cerr << \"synth caught double indirect: \" << ex << std::endl;\n+  }\n+\n+  std::cerr << \"end main\" << std::endl;\n+  return 0;\n+}\n+\n+// { dg-output \"custom std::handle_contract_violation called: 30 .*/contracts14.C(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"synth caught direct: -30(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"custom std::handle_contract_violation called: 18 .*/contracts14.C(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"synth caught indirect: -18(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"custom std::handle_contract_violation called: 18 .*/contracts14.C(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"synth caught double indirect: -18(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"end main\" }\n+"}, {"sha": "d822f833916d0a6bf084bdd410122a7dd956e24a", "filename": "gcc/testsuite/g++.dg/contracts/contracts15.C", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts15.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,56 @@\n+// ensure that exceptions thrown inside a custom contract violation handler\n+// are not catchable up the call stack when failing in a noexcept function\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+#include <iostream>\n+#include <experimental/contract>\n+\n+void handle_contract_violation(const std::experimental::contract_violation &violation) {\n+  std::cerr << \"custom std::handle_contract_violation called:\"\n+    << \" \" << violation.line_number()\n+    << \" \" << violation.file_name()\n+    << std::endl;\n+  throw -(int)violation.line_number();\n+}\n+\n+int fun() noexcept {\n+  int x = 0;\n+  [[ assert: x < 0 ]];\n+  return 0;\n+}\n+\n+int fun3() {\n+  fun();\n+  return 2;\n+}\n+\n+int main(int, char**) {\n+  try {\n+    int x = 0;\n+    [[ assert: x < 0 ]];\n+  } catch(int &ex) {\n+    std::cerr << \"synth caught direct: \" << ex << std::endl;\n+  }\n+\n+  try {\n+    fun();\n+  } catch(int &ex) {\n+    std::cerr << \"synth caught indirect: \" << ex << std::endl;\n+  }\n+\n+  try {\n+    fun3();\n+  } catch(int &ex) {\n+    std::cerr << \"synth caught double indirect: \" << ex << std::endl;\n+  }\n+\n+  std::cerr << \"end main\" << std::endl;\n+  return 0;\n+}\n+\n+// { dg-output \"custom std::handle_contract_violation called: 30 .*/contracts15.C(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"synth caught direct: -30(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"custom std::handle_contract_violation called: 18 .*/contracts15.C(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"terminate called after throwing an instance of .int.(\\n|\\r\\n|\\r)*\" }\n+// { dg-shouldfail \"throwing in noexcept\" }\n+"}, {"sha": "1c7054507f2ac374cb7a09eed1441ad18296ab7e", "filename": "gcc/testsuite/g++.dg/contracts/contracts16.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts16.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,34 @@\n+// ensure that exceptions thrown inside a custom contract violation handler\n+// are not catchable up the call stack even when continue mode is off\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+#include <iostream>\n+#include <experimental/contract>\n+\n+void handle_contract_violation(const std::experimental::contract_violation &violation) {\n+  std::cerr << \"custom std::handle_contract_violation called:\"\n+    << \" \" << violation.line_number()\n+    << \" \" << violation.file_name()\n+    << std::endl;\n+  throw -(int)violation.line_number();\n+}\n+\n+int fun() {\n+  int x = 0;\n+  [[ assert: x < 0 ]];\n+  return 0;\n+}\n+\n+int main(int, char**) {\n+  try {\n+    fun();\n+  } catch(int &ex) {\n+    std::cerr << \"synth caught indirect: \" << ex << std::endl;\n+  }\n+\n+  return 0;\n+}\n+\n+// { dg-output \"custom std::handle_contract_violation called: 18 .*/contracts16.C(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"synth caught indirect: -18(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "d165bb05315198c5e2311c95d7b24b42b4bc0989", "filename": "gcc/testsuite/g++.dg/contracts/contracts17.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts17.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,35 @@\n+// ensure that exceptions thrown inside a custom contract violation handler\n+// are not catchable up the call stack when continue mode is off and the\n+// assert fails in a noexcept function\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+#include <iostream>\n+#include <experimental/contract>\n+\n+void handle_contract_violation(const std::experimental::contract_violation &violation) {\n+  std::cerr << \"custom std::handle_contract_violation called:\"\n+    << \" \" << violation.line_number()\n+    << \" \" << violation.file_name()\n+    << std::endl;\n+  throw -violation.line_number();\n+}\n+\n+int fun() noexcept {\n+  int x = 0;\n+  [[ assert: x < 0 ]];\n+  return 0;\n+}\n+\n+int main(int, char**) {\n+  try {\n+    fun();\n+  } catch(int &ex) {\n+    std::cerr << \"synth caught indirect: \" << ex << std::endl;\n+  }\n+\n+  return 0;\n+}\n+\n+// { dg-output \"custom std::handle_contract_violation called: 19 .*/contracts17.C(\\n|\\r\\n|\\r)*\" }\n+// { dg-shouldfail \"throwing in noexcept\" }\n+"}, {"sha": "e8163ba4ab2dc808e66e6edffff2e15976e78b1f", "filename": "gcc/testsuite/g++.dg/contracts/contracts18.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts18.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,15 @@\n+// check that a valid program using assertions compiles and runs\n+//   ensure an axiom with a failing predicate doesn't prevent a successful run\n+//   (axiom level contracts are never checked at runtime)\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-role=custom:never,ignore,ignore\" }\n+\n+int main()\n+{\n+  int x = 1;\n+  [[assert axiom: x < 0]];\n+  [[assert %custom: x > 0]];\n+  [[assert audit %custom: x < 0]];\n+  return 0;\n+}\n+"}, {"sha": "4a8b43a3186def359ecffc1c98a331b83b9ad2cd", "filename": "gcc/testsuite/g++.dg/contracts/contracts19.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts19.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,19 @@\n+// check that a valid program using assertions compiles and runs\n+//   ensure an axiom with a failing predicate doesn't prevent a successful run\n+//   (axiom level contracts are never checked at runtime)\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-role=custom:maybe,maybe,ignore\" }\n+\n+int main()\n+{\n+  int x = 10;\n+  [[assert axiom: x < 0]];\n+  [[assert %custom: x < 0]];\n+  [[assert audit %custom: x < 1]];\n+  [[assert axiom %custom: x < 1]];\n+  return 0;\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 11 main .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 12 main .*(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "9535e077d361541e5f9152b13492957a9fcb8838", "filename": "gcc/testsuite/g++.dg/contracts/contracts2.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts2.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,13 @@\n+// check that a valid program using assertions compiles and runs\n+//   ensure an axiom with a failing predicate doesn't prevent a successful run\n+//   (axiom level contracts are never checked at runtime)\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+int main()\n+{\n+  int x = 1;\n+  [[assert axiom: x < 0]];\n+  [[assert default: x > 0]];\n+  return 0;\n+}"}, {"sha": "adce5d70d402a4afa1c0ee6974e064be10402cbf", "filename": "gcc/testsuite/g++.dg/contracts/contracts20.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts20.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,11 @@\n+// test that contract attributes cause errors pre-c++2a\n+// { dg-do compile { target c++17_only } }\n+\n+int fun(int a)\n+  [[ pre: a > 0 ]] // { dg-error \"contracts are only available with .-fcontracts.\" }\n+  [[ post r: r < 0 ]] // { dg-error \"contracts are only available with .-fcontracts.\" }\n+{\n+  [[ assert: a != 0 ]]; // { dg-error \"contracts are only available with .-fcontracts.\" }\n+  return -a;\n+}\n+"}, {"sha": "91e32b9d9b25b9cd03aa835af9ef0f66bb14fca0", "filename": "gcc/testsuite/g++.dg/contracts/contracts22.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts22.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,32 @@\n+// ensure a default level assert with a failing predicate does not generate an\n+// error during runtime when the contracts mode is off\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-mode=off\" }\n+// { dg-output \"returning from main\" }\n+#include <cstdio>\n+\n+int constexpr f()\n+{\n+  constexpr int x = 1;\n+  [[assert default: x < 0]];\n+  return x;\n+}\n+\n+template<typename T> int k()\n+{\n+  int x = 1;\n+  [[assert default: x < 0]];\n+  return x;\n+}\n+\n+\n+int main()\n+{\n+  int x = 1;\n+  [[assert default: x < 0]];\n+  constexpr int x2 = f();\n+  int x3 = k<int>();\n+\n+  printf (\"returning from main\\n\");\n+  return 0;\n+}"}, {"sha": "70a54f95a937e9e9bc14daef6188302b9ce941f7", "filename": "gcc/testsuite/g++.dg/contracts/contracts24.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts24.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts24.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts24.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,15 @@\n+// check that a valid program using assertions compiles and runs\n+//   ensure an axiom with a failing predicate doesn't prevent a successful run\n+//   (axiom level contracts are never checked at runtime)\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-semantic=default:never -fcontract-semantic=audit:ignore -fcontract-semantic=axiom:ignore\" }\n+\n+int main()\n+{\n+  int x = 1;\n+  [[assert axiom: x < 0]];\n+  [[assert: x > 0]];\n+  [[assert audit: x < 0]];\n+  return 0;\n+}\n+"}, {"sha": "01217807bc194b7aaa0d6e253027f1bd1da89a67", "filename": "gcc/testsuite/g++.dg/contracts/contracts25.C", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts25.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts25.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts25.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,57 @@\n+// ensure that passing asserts do not affect constexpr functions\n+// ensure that failing asserts generate an error at runtime in constexpr funcs\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+\n+constexpr int wfun(int a) {\n+  [[assert: a > 0]];\n+  return a;\n+}\n+\n+constexpr int ffun(int a) {\n+  [[assert: a > 0]];\n+  return a;\n+}\n+\n+template<typename T>\n+constexpr int tfun(T a) {\n+  [[assert: a > 0]];\n+  return a;\n+}\n+\n+template<typename T>\n+constexpr int wtfun(T a) {\n+  [[assert: a > 0]];\n+  return a;\n+}\n+\n+template<typename T>\n+constexpr int ftfun(T a) {\n+  [[assert: a > 0]];\n+  return a;\n+}\n+\n+constexpr int explicitfn(int a) {\n+  [[assert ignore: a > 0]];\n+  [[assert check_maybe_continue: a > 0]];\n+  return a;\n+}\n+\n+int main(int, char **) {\n+  int a = wfun(10);\n+  int b = ffun(-10);\n+  int c = wtfun(10);\n+  int d = ftfun(-10);\n+\n+  int e = explicitfn(-10);\n+\n+  int z = ftfun(-10.0);\n+\n+  return 0;\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 12 ffun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 30 ftfun<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 36 explicitfn .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 30 ftfun<double> .*(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "ecb9fdb1e6517be3f985ca6d116bdd9663528e1b", "filename": "gcc/testsuite/g++.dg/contracts/contracts3.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts3.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,13 @@\n+// ensure a default level assert with a failing predicate generates an error\n+// during runtime when the contract build level is default\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+// { dg-shouldfail \"assert violation\" }\n+// { dg-output \"default std::handle_contract_violation called\" }\n+\n+int main()\n+{\n+  int x = 1;\n+  [[assert default: x < 0]];\n+  return 0;\n+}"}, {"sha": "ddd80025afc7ebce59a4323beb899104f26a8d1e", "filename": "gcc/testsuite/g++.dg/contracts/contracts35.C", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts35.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts35.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts35.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,47 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+#include <cstdio>\n+\n+struct S\n+{\n+  template<typename T>\n+  S(T a) [[ pre: a > 0 ]] [[ pre: a > 10 ]];\n+};\n+\n+template<typename T>\n+S::S(T a)\n+{\n+  printf (\"S::S(T): %d\\n\", (int)a);\n+}\n+\n+struct S1\n+{\n+  template<typename T>\n+  S1(T a) [[ pre: a > 0 ]] [[ pre: a > 10 ]]\n+  {\n+    printf (\"S1::S1(T): %d\\n\", (int)a);\n+  }\n+};\n+\n+int main(int, char **) {\n+  S s{-1};\n+  S s2{-2.5};\n+\n+  S1 s1_1{-3};\n+  S1 s1_2{-4.5};\n+  return 0;\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 8 S::S<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 8 S::S<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"S::S.T.: -1(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 8 S::S<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 8 S::S<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"S::S.T.: -2(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 20 S1::S1<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 20 S1::S1<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"S1::S1.T.: -3(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 20 S1::S1<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 20 S1::S1<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"S1::S1.T.: -4(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "a43fb9f98e26dc8ae977f2eb5f32ae89b4a8bc59", "filename": "gcc/testsuite/g++.dg/contracts/contracts4.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts4.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,11 @@\n+// ensure an audit level assert with a failing predicate does not generate an\n+// error during runtime when the contract build level is default\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+int main()\n+{\n+  int x = 1;\n+  [[assert audit: x < 0]];\n+  return 0;\n+}"}, {"sha": "0fa0ec83be51e956518719b73043a06a3bcf34c9", "filename": "gcc/testsuite/g++.dg/contracts/contracts5.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts5.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,13 @@\n+// ensure an audit level assert with a failing predicate generates an error\n+// during runtime when the contract build level is audit\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-build-level=audit\" }\n+// { dg-shouldfail \"assert violation\" }\n+// { dg-output \"default std::handle_contract_violation called\" }\n+\n+int main()\n+{\n+  int x = 1;\n+  [[assert audit: x < 0]];\n+  return 0;\n+}"}, {"sha": "59c010e5d390d2b7b7f7568237b679871884b0f9", "filename": "gcc/testsuite/g++.dg/contracts/contracts6.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts6.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,11 @@\n+// ensure a default level assert with a failing predicate does not generate an\n+// error during runtime when the contract build level is off\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-build-level=off\" }\n+\n+int main()\n+{\n+  int x = 1;\n+  [[assert default: x < 0]];\n+  return 0;\n+}"}, {"sha": "eaad8f0fc9d01509d08887830d5ff633f1b9fc6c", "filename": "gcc/testsuite/g++.dg/contracts/contracts7.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts7.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,14 @@\n+// ensure a default level assert with a failing predicate does generates an\n+// error during runtime but lets the program continue and complete\n+// successfully when the contract build level is default but continuation on\n+// contract failure is switched on\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+// { dg-output \"default std::handle_contract_violation called\" }\n+\n+int main()\n+{\n+  int x = 1;\n+  [[assert default: x < 0]];\n+  return 0;\n+}"}, {"sha": "9c8a6b5d8c436723181b8d962367e15a33961286", "filename": "gcc/testsuite/g++.dg/contracts/contracts8.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts8.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,43 @@\n+// generic assert contract parsing checks\n+//   ensure that existing generalized attribute parsing is not intefered with\n+//   ensure that an assert contract cannot chain into an empty attribute list\n+//   ensure that an attribute list cannot chain into an assert contract\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fcontracts\" }\n+\n+constexpr bool fun(int x) {\n+  return x < 0;\n+}\n+\n+namespace tns {\n+  constexpr bool f(int x) {\n+    return x < 0;\n+  }\n+}\n+\n+bool assert(int x) {\n+  return x < 0;\n+}\n+\n+int main()\n+{\n+  constexpr int x = 1;\n+  [[fun(x)]]; // { dg-warning \"attributes at the beginning of statement are ignored\" }\n+  [[fun(x), assert(x)]]; // { dg-warning \"attributes at the beginning of statement are ignored\" }\n+\n+  [[assert default: fun(x), ]]; // { dg-error \"expected ']'\" }\n+  [[assert default: fun(x) ]];\n+\n+  [[fun(x), assert default: fun(x)]]; // { dg-error \"expected .]. before .default.\" }\n+  // { dg-warning \"attributes at the beginning of statement are ignored\" \"\" { target *-*-* } .-1 }\n+  [[fun(x), assert: fun(x)]]; // { dg-error \"expected .]. before .:. token\" }\n+  // { dg-warning \"attributes at the beginning of statement are ignored\" \"\" { target *-*-* } .-1 }\n+  [[fun(x), assert fun(x)]]; // { dg-error \"expected .]. before .fun.\" }\n+  // { dg-warning \"attributes at the beginning of statement are ignored\" \"\" { target *-*-* } .-1 }\n+  [[ using tns: f(x) ]]; // { dg-warning \"attributes at the beginning of statement are ignored\" }\n+  [[ using tns: f(x), assert default: fun(x) ]]; // { dg-error \"expected .]. before .default.\" }\n+  // { dg-warning \"attributes at the beginning of statement are ignored\" \"\" { target *-*-* } .-1 }\n+  [[ using tns: f(x), , default: fun(x) ]]; // { dg-error \"expected .]. before .:.\" }\n+  // { dg-warning \"attributes at the beginning of statement are ignored\" \"\" { target *-*-* } .-1 }\n+  return 0;\n+}"}, {"sha": "f566628ec44a4c73100758ae3f91af2d83a92f4b", "filename": "gcc/testsuite/g++.dg/contracts/contracts9.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts9.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,45 @@\n+// ensure that dependent and non-dependent asserts inside templated\n+// functions parse without error whether the function is instatiated or not\n+// ensure that assert contract checks are generated inside called templates\n+// ensure that template functions can be used as assert predicates\n+// { dg-do run }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+\n+template<typename T>\n+int fun1(int a, T b)\n+{\n+  [[ assert: a > 0 ]];\n+  [[ assert: (long long)b > 0 ]];\n+  return a > 0;\n+}\n+\n+template<typename T>\n+struct test\n+{\n+  static int fun(int a, T b) {\n+    [[ assert: a > 0 ]];\n+    [[ assert: b > 0 ]];\n+    return a > 0;\n+  }\n+};\n+\n+int main()\n+{\n+  fun1(1, -1);\n+  fun1(-1, 1.0);\n+  fun1(-1, \"test\");\n+\n+  [[ assert: fun1(-1, -5) ]];\n+  [[ assert: test<int>::fun(10, -6) ]];\n+  [[ assert: test<double>::fun(10.0, -7) ]];\n+  // return 0;\n+}\n+\n+// { dg-output \"default std::handle_contract_violation called: .*.C 12 fun1<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 11 fun1<double> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 11 fun1<const char.> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 11 fun1<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 12 fun1<int> .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 32 main .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 21 test<int>::fun .*(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"default std::handle_contract_violation called: .*.C 21 test<double>::fun .*(\\n|\\r\\n|\\r)*\" }"}, {"sha": "8fcc5b2368a0414c938275d631c405b659db5395", "filename": "gcc/testsuite/g++.dg/contracts/except_preload_handler/Makefile", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fexcept_preload_handler%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fexcept_preload_handler%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fexcept_preload_handler%2FMakefile?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,13 @@\n+CXXFLAGS=--std=c++17 -fcontract-continuation-mode=on\n+\n+default: assert_fail libhandle_contract_violation.so\n+\n+run: default\n+\tLD_PRELOAD=./libhandle_contract_violation.so ./assert_fail\n+\n+./libhandle_contract_violation.so: ./handle_contract_violation.cpp\n+\t${CXX} ${CXXFLAGS} -shared -fPIC -o $@ $<\n+\n+clean:\n+\trm -fr ./*.o ./libhandle_contract_violation.so ./assert_fail\n+"}, {"sha": "cbfe48bd33f358bf4b66f537a63aab409df86544", "filename": "gcc/testsuite/g++.dg/contracts/except_preload_handler/README", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fexcept_preload_handler%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fexcept_preload_handler%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fexcept_preload_handler%2FREADME?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,13 @@\n+build and install gcc to $prefix, then run:\n+LD_LIBRARY_PATH=$prefix/lib64 CXX=$prefix/bin/g++ make run\n+\n+this test has a custom handle_contract_violation that throws an exception\n+this test is built with -fcontract-continuation-mode=on\n+\n+since 1) our fun() is not marked noexcept and 2) the continue mode is set to\n+on, we expect the exception thrown within the contract violation handler to\n+propagate back up into the catch block located in main()\n+\n+expected output therefore ends in:\n+\tsynth caught indirect: -1\n+"}, {"sha": "3dda7ac84d548c65cc7ef6b7716a170e5fab04df", "filename": "gcc/testsuite/g++.dg/contracts/except_preload_handler/assert_fail.cpp", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fexcept_preload_handler%2Fassert_fail.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fexcept_preload_handler%2Fassert_fail.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fexcept_preload_handler%2Fassert_fail.cpp?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,20 @@\n+#include <iostream>\n+#include <contract>\n+\n+int fun() {\n+\tint x = 0;\n+\t[[ assert: x < 0 ]];\n+\n+\treturn 0;\n+}\n+\n+int main(int argc, char**) {\n+\ttry {\n+\t\tfun();\n+\t} catch(int &ex) {\n+\t\tstd::cerr << \"synth caught indirect: \" << ex << std::endl;\n+\t}\n+\n+\treturn 0;\n+}\n+"}, {"sha": "ec051b39e5ffd20f7b154fae1322142c5f14ada4", "filename": "gcc/testsuite/g++.dg/contracts/except_preload_handler/handle_contract_violation.cpp", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fexcept_preload_handler%2Fhandle_contract_violation.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fexcept_preload_handler%2Fhandle_contract_violation.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fexcept_preload_handler%2Fhandle_contract_violation.cpp?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,14 @@\n+#include <iostream>\n+#include <contract>\n+\n+void handle_contract_violation(const std::contract_violation &violation) {\n+  std::cerr << \"custom handle_contract_violation: \" << std::endl\n+    << \" line_number: \" << violation.line_number() << std::endl\n+    << \" file_name: \" << violation.file_name() << std::endl\n+    << \" function_name: \" << violation.function_name() << std::endl\n+    << \" comment: \" << violation.comment() << std::endl\n+    << \" assertion_level: \" << violation.assertion_level() << std::endl\n+    << std::endl;\n+  throw -1;\n+}\n+"}, {"sha": "8fcc5b2368a0414c938275d631c405b659db5395", "filename": "gcc/testsuite/g++.dg/contracts/noexcept_preload_handler/Makefile", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fnoexcept_preload_handler%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fnoexcept_preload_handler%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fnoexcept_preload_handler%2FMakefile?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,13 @@\n+CXXFLAGS=--std=c++17 -fcontract-continuation-mode=on\n+\n+default: assert_fail libhandle_contract_violation.so\n+\n+run: default\n+\tLD_PRELOAD=./libhandle_contract_violation.so ./assert_fail\n+\n+./libhandle_contract_violation.so: ./handle_contract_violation.cpp\n+\t${CXX} ${CXXFLAGS} -shared -fPIC -o $@ $<\n+\n+clean:\n+\trm -fr ./*.o ./libhandle_contract_violation.so ./assert_fail\n+"}, {"sha": "aa7c6dd2df6055260512bf9e19560a60580b7200", "filename": "gcc/testsuite/g++.dg/contracts/noexcept_preload_handler/README", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fnoexcept_preload_handler%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fnoexcept_preload_handler%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fnoexcept_preload_handler%2FREADME?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,15 @@\n+build and install gcc to $prefix, then run:\n+LD_LIBRARY_PATH=$prefix/lib64 CXX=$prefix/bin/g++ make run\n+\n+this test has a custom handle_contract_violation that throws an exception\n+this test is built with -fcontract-continuation-mode=on\n+\n+since 1) our fun() *IS* marked noexcept even though 2) the continue mode is\n+set to on, we expect the exception thrown within the contract violation\n+handler to quashed and have std::terminate run.\n+\n+expected output therefore ends in:\n+\tterminate called after throwing an instance of 'int'\n+\n+despite there being a catch(int &) handler in main\n+"}, {"sha": "8ae98fbe668b1884c7e6d1705c914eb1183a7de1", "filename": "gcc/testsuite/g++.dg/contracts/noexcept_preload_handler/assert_fail.cpp", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fnoexcept_preload_handler%2Fassert_fail.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fnoexcept_preload_handler%2Fassert_fail.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fnoexcept_preload_handler%2Fassert_fail.cpp?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,20 @@\n+#include <iostream>\n+#include <contract>\n+\n+int fun() noexcept {\n+\tint x = 0;\n+\t[[ assert: x < 0 ]];\n+\n+\treturn 0;\n+}\n+\n+int main(int argc, char**) {\n+\ttry {\n+\t\tfun();\n+\t} catch(int &ex) {\n+\t\tstd::cerr << \"synth caught indirect: \" << ex << std::endl;\n+\t}\n+\n+\treturn 0;\n+}\n+"}, {"sha": "ec051b39e5ffd20f7b154fae1322142c5f14ada4", "filename": "gcc/testsuite/g++.dg/contracts/noexcept_preload_handler/handle_contract_violation.cpp", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fnoexcept_preload_handler%2Fhandle_contract_violation.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fnoexcept_preload_handler%2Fhandle_contract_violation.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fnoexcept_preload_handler%2Fhandle_contract_violation.cpp?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,14 @@\n+#include <iostream>\n+#include <contract>\n+\n+void handle_contract_violation(const std::contract_violation &violation) {\n+  std::cerr << \"custom handle_contract_violation: \" << std::endl\n+    << \" line_number: \" << violation.line_number() << std::endl\n+    << \" file_name: \" << violation.file_name() << std::endl\n+    << \" function_name: \" << violation.function_name() << std::endl\n+    << \" comment: \" << violation.comment() << std::endl\n+    << \" assertion_level: \" << violation.assertion_level() << std::endl\n+    << std::endl;\n+  throw -1;\n+}\n+"}, {"sha": "6ff083f4b5c220c6ba8454928dcd1eab5da2bdd2", "filename": "gcc/testsuite/g++.dg/contracts/preload_handler/Makefile", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_handler%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_handler%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_handler%2FMakefile?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,13 @@\n+CXXFLAGS=--std=c++17\n+\n+default: assert_fail libhandle_contract_violation.so\n+\n+run: default\n+\tLD_PRELOAD=./libhandle_contract_violation.so ./assert_fail\n+\n+./libhandle_contract_violation.so: ./handle_contract_violation.cpp\n+\t${CXX} ${CXXFLAGS} -shared -fPIC -o $@ $<\n+\n+clean:\n+\trm -fr ./libhandle_contract_violation.so ./assert_fail\n+"}, {"sha": "cc913fe8188b32d2e2f0c9ad7160e327522a04d3", "filename": "gcc/testsuite/g++.dg/contracts/preload_handler/README", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_handler%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_handler%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_handler%2FREADME?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,2 @@\n+build and install gcc to $prefix, then run:\n+LD_LIBRARY_PATH=$prefix/lib64 CXX=$prefix/bin/g++ make run"}, {"sha": "0f807db062837430e843c9315fa32b0782b02072", "filename": "gcc/testsuite/g++.dg/contracts/preload_handler/assert_fail.cpp", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_handler%2Fassert_fail.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_handler%2Fassert_fail.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_handler%2Fassert_fail.cpp?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,7 @@\n+int main(int, char**) {\n+\tint x = 0;\n+\t[[ assert: x < 0 ]];\n+\n+\treturn 0;\n+}\n+"}, {"sha": "6029875ee6cb0fc4afe1aa3df8025a97963b74d5", "filename": "gcc/testsuite/g++.dg/contracts/preload_handler/handle_contract_violation.cpp", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_handler%2Fhandle_contract_violation.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_handler%2Fhandle_contract_violation.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_handler%2Fhandle_contract_violation.cpp?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,15 @@\n+#include <iostream>\n+#include <contract>\n+\n+void handle_contract_violation(const std::contract_violation &violation) {\n+  std::cerr << \"custom handle_contract_violation: \" << std::endl\n+    << \" line_number: \" << violation.line_number() << std::endl\n+    << \" file_name: \" << violation.file_name() << std::endl\n+    << \" function_name: \" << violation.function_name() << std::endl\n+    << \" comment: \" << violation.comment() << std::endl\n+    << \" assertion_level: \" << violation.assertion_level() << std::endl\n+    << \" assertion_role: \" << violation.assertion_role() << std::endl\n+    << \" continuation_mode: \" << (int)violation.continuation_mode() << std::endl\n+    << std::endl;\n+}\n+"}, {"sha": "c8263285471dfae0cc056927d73a846cd93a1683", "filename": "gcc/testsuite/g++.dg/contracts/preload_nocontinue_handler/Makefile", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_nocontinue_handler%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_nocontinue_handler%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_nocontinue_handler%2FMakefile?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,23 @@\n+CXXFLAGS=--std=c++17 -fcontract-continuation-mode=on\n+LDFLAGS=-ldl\n+\n+default: assert_fail libhandle_contract_violation.so libnocontinue.so\n+\n+run: default\n+\t./assert_fail\n+\n+runno: default\n+\tLD_PRELOAD=\"./libnocontinue.so ./libhandle_contract_violation.so\" ./assert_fail\n+\n+runnostd: default\n+\tLD_PRELOAD=./libnocontinue.so ./assert_fail\n+\n+./libhandle_contract_violation.so: ./handle_contract_violation.cpp\n+\t${CXX} ${CXXFLAGS} -shared -fPIC -o $@ $<\n+\n+./libnocontinue.so: ./nocontinue.cpp\n+\t${CXX} ${CXXFLAGS} -shared -fPIC -o $@ $<\n+\n+clean:\n+\trm -fr ./libhandle_contract_violation.so ./libnocontinue.so ./assert_fail\n+"}, {"sha": "5c931918759ab675acf3062acc53a93da9430d0e", "filename": "gcc/testsuite/g++.dg/contracts/preload_nocontinue_handler/README", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_nocontinue_handler%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_nocontinue_handler%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_nocontinue_handler%2FREADME?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,23 @@\n+build and install gcc to $prefix, then run:\n+\n+LD_LIBRARY_PATH=$prefix/lib64 CXX=$prefix/bin/g++ make run\n+  Build and run with continuation mode on; will print violation info from the\n+  standard handler and then continue to print \"returning from main\"\n+\n+LD_LIBRARY_PATH=$prefix/lib64 CXX=$prefix/bin/g++ make runnostd\n+  Build and run with continuation mode on, using the default violation handler\n+  while preloading the 'nocontinue' hook. This uses LD_PRELOAD to turn all\n+  continuing contract violations into non-continuing versions.\n+\n+  Will print violation info from the standard handler and then terminate -- it\n+  will not print \"returning from main\"\n+\n+LD_LIBRARY_PATH=$prefix/lib64 CXX=$prefix/bin/g++ make runno\n+  Build and run with continuation mode on, using a custom violation handler\n+  while preloading the 'nocontinue' hook. This uses LD_PRELOAD to turn all\n+  continuing contract violations into non-continuing versions and to install a\n+  custom violation handler.\n+\n+  Will print violation info from the custom handler and then terminate -- it\n+  will not print \"returning from main\"\n+"}, {"sha": "a17a6239bb7f96276907ca4bf3a7c84d89e18b02", "filename": "gcc/testsuite/g++.dg/contracts/preload_nocontinue_handler/assert_fail.cpp", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_nocontinue_handler%2Fassert_fail.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_nocontinue_handler%2Fassert_fail.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_nocontinue_handler%2Fassert_fail.cpp?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,10 @@\n+#include <iostream>\n+\n+int main(int, char**) {\n+\tint x = 0;\n+\t[[ assert: x < 0 ]];\n+\n+\tstd::cout << \"returning from main\" << std::endl;\n+\treturn 0;\n+}\n+"}, {"sha": "8499483c86bd73b6f36da9cdec6e6efe32d25c9b", "filename": "gcc/testsuite/g++.dg/contracts/preload_nocontinue_handler/handle_contract_violation.cpp", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_nocontinue_handler%2Fhandle_contract_violation.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_nocontinue_handler%2Fhandle_contract_violation.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_nocontinue_handler%2Fhandle_contract_violation.cpp?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,13 @@\n+#include <iostream>\n+#include <contract>\n+\n+void handle_contract_violation(const std::contract_violation &violation) {\n+  std::cerr << \"custom handle_contract_violation: \" << std::endl\n+    << \" line_number: \" << violation.line_number() << std::endl\n+    << \" file_name: \" << violation.file_name() << std::endl\n+    << \" function_name: \" << violation.function_name() << std::endl\n+    << \" comment: \" << violation.comment() << std::endl\n+    << \" assertion_level: \" << violation.assertion_level() << std::endl\n+    << std::endl;\n+}\n+"}, {"sha": "2a7d53e353d2aba876a11d9edf4d37407e22bcf2", "filename": "gcc/testsuite/g++.dg/contracts/preload_nocontinue_handler/nocontinue.cpp", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_nocontinue_handler%2Fnocontinue.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_nocontinue_handler%2Fnocontinue.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fpreload_nocontinue_handler%2Fnocontinue.cpp?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,19 @@\n+#include <exception>\n+#include <contract>\n+#include <dlfcn.h>\n+\n+using handler = void (*)(const std::contract_violation &);\n+constexpr const char *mangledHandlerName = \"_Z25handle_contract_violationRKSt18contract_violation\";\n+void handle_contract_violation(const std::contract_violation &violation) {\n+  try {\n+    handler original_handle_contract_violation;\n+    original_handle_contract_violation =\n+      (handler)dlsym(RTLD_NEXT, mangledHandlerName);\n+    (*original_handle_contract_violation)(violation);\n+  }\n+  catch(...) {\n+    ; // squash\n+  }\n+  std::terminate();\n+}\n+"}, {"sha": "f991ef8644eb3d4c3f99fa0c5d10e600c94a9542", "filename": "gcc/testsuite/g++.dg/modules/contracts-1_a.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-1_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-1_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-1_a.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,46 @@\n+// Basic test to ensure that guarded templates correctly serialize and\n+// deserialize their contracts through the CMI.\n+// { dg-additional-options \"-fmodules-ts -fcontracts -fcontract-continuation-mode=on\" }\n+module;\n+#include <cstdio>\n+#include <experimental/contract>\n+export module foo;\n+// { dg-module-cmi foo }\n+\n+export int violation_count{0};\n+extern \"C++\" export void handle_contract_violation(const std::experimental::contract_violation &violation)\n+{\n+  violation_count++;\n+  printf(\"violation_count: %d\\n\", violation_count);\n+}\n+\n+export int nontemplate(int n)\n+  [[ pre: n > 0 ]]\n+  [[ post r: r > 0 ]]\n+{\n+  return -n;\n+}\n+\n+export\n+template<typename T>\n+T fn(T n)\n+  [[ pre: n > 0 ]]\n+  [[ post r: r > 0 ]]\n+{\n+  printf(\"%s(%d)\\n\", __FUNCTION__, n);\n+  return n;\n+}\n+\n+export\n+template<typename T>\n+void void_fn(T n)\n+  [[ pre: n < 0 ]]\n+{\n+  printf(\"%s(%d)\\n\", __FUNCTION__, n);\n+}\n+\n+export void foo_fn()\n+{\n+  fn(5);\n+}\n+"}, {"sha": "30c15f6928b54cd6055e97cb456e63898d816582", "filename": "gcc/testsuite/g++.dg/modules/contracts-1_b.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-1_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-1_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-1_b.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,33 @@\n+// { dg-module-do run }\n+// { dg-additional-options \"-fmodules-ts -fcontracts -fcontract-continuation-mode=on\" }\n+module;\n+#include <cstdio>\n+export module bar;\n+// { dg-module-cmi bar }\n+import foo;\n+\n+template<typename T>\n+bool bar_fn_pre(T n) { printf(\"bar fn pre(%d)\\n\", n); return true; }\n+\n+export\n+template<typename T>\n+T bar_fn(T n)\n+  [[ pre: bar_fn_pre(n) && n > 0 ]]\n+{\n+  printf(\"%s(%d)\\n\", __FUNCTION__, n);\n+  return n;\n+}\n+\n+int main(int, char**)\n+{\n+  nontemplate(5);\n+  nontemplate(-5);\n+  fn(5);\n+  fn(-5);\n+  void_fn(5);\n+  void_fn(-5);\n+  bar_fn(5);\n+  bar_fn(-5);\n+  return violation_count == 6 ? 0 : -1;\n+}\n+"}, {"sha": "828d680d2a091bbeb6e4442fd76f3eea4dc1794c", "filename": "gcc/testsuite/g++.dg/modules/contracts-2_a.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-2_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-2_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-2_a.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,49 @@\n+// Basic test to ensure that guarded function contracts are correctly\n+// serialized and deserialized through the CMI.\n+// This also tries to ensure that entities referenced in a function's\n+// contracts are correctly marked as a dependency of the function itself and\n+// serialized in the correct order.\n+// { dg-additional-options \"-fmodules-ts -fcontracts -fcontract-role=default:maybe,maybe,ignore\" }\n+module;\n+#include <cstdio>\n+#include <experimental/contract>\n+export module foo;\n+// { dg-module-cmi foo }\n+\n+export int violation_count{0};\n+export int violation_line_sum{0};\n+extern \"C++\" export void handle_contract_violation(const std::experimental::contract_violation &violation)\n+{\n+  violation_count++;\n+  violation_line_sum += violation.line_number () * violation_count;\n+  printf(\"violation: %d %d\\n\", violation_count, violation_line_sum);\n+}\n+\n+export int fn2(int n);\n+export int fn_in2(int n);\n+export int pre_print(int n) { printf(\"pre_print(%d)\\n\", n); return n; }\n+\n+export int fn_in1(int n) [[ pre: pre_print(n) > 0 ]]\n+{\n+  printf(\"%s blah (%d)\\n\", __FUNCTION__, n);\n+  return n;\n+}\n+export int fn_in2(int x) [[ pre: pre_print(x) > 0 ]]\n+{\n+  printf(\"%s(%d)\\n\", __FUNCTION__, x);\n+  return x;\n+}\n+\n+export int fn_iso(int n);\n+\n+export int fn1(int n)\n+  [[ pre: pre_print(n) > 0 ]];\n+\n+export int fn2(int n)\n+  [[ pre: pre_print(n) > 0 ]];\n+\n+export int pre_print2(int n);\n+\n+export int fn3(int n)\n+  [[ pre: pre_print2(n) > 0 ]];\n+"}, {"sha": "01939aeb947bb4a6e47d71c6a6025695c22014e1", "filename": "gcc/testsuite/g++.dg/modules/contracts-2_b.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-2_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-2_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-2_b.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,35 @@\n+// { dg-additional-options \"-fmodules-ts -fcontracts -fcontract-role=default:maybe,maybe,ignore\" }\n+module;\n+#include <cstdio>\n+module foo;\n+\n+int fn1(int x)\n+{\n+  printf(\"%s(%d)\\n\", __FUNCTION__, x);\n+  return x;\n+}\n+\n+int fn_iso(int n) [[ pre: pre_print(n) > 0 ]]\n+{\n+  printf(\"%s(%d)\\n\", __FUNCTION__, n);\n+  return n;\n+}\n+\n+int pre_print2(int n)\n+{\n+  printf(\"pre_print(%d)\\n\", n);\n+  return n;\n+}\n+\n+int fn2(int x)\n+{\n+  printf(\"%s(%d)\\n\", __FUNCTION__, x);\n+  return x;\n+}\n+\n+int fn3(int x)\n+{\n+  printf(\"%s(%d)\\n\", __FUNCTION__, x);\n+  return x;\n+}\n+"}, {"sha": "58938e0e6de160c05f1fb4683811ade30098ea70", "filename": "gcc/testsuite/g++.dg/modules/contracts-2_c.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-2_c.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-2_c.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-2_c.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,22 @@\n+// { dg-module-do run }\n+// { dg-additional-options \"-fmodules-ts -fcontracts -fcontract-role=default:maybe,maybe,ignore\" }\n+import foo;\n+\n+int main(int, char**)\n+{\n+  int x = -1;\n+\n+  fn_iso(x--);\n+  fn1(x--);\n+  fn2(x--);\n+  fn3(x--);\n+  fn_in1(x--);\n+  fn_in2(x--);\n+  return (violation_count == 6 && violation_line_sum == 729) ? 0 : -1;\n+}\n+\n+// TODO does any of this actually get verified?\n+// { dg-output \"pre_print.-1.(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"violation: 1 12(\\n|\\r\\n|\\r)*\" }\n+// { dg-output \"fn_iso.-1.(\\n|\\r\\n|\\r)*\" }\n+"}, {"sha": "a4f03d358426ce91ee027efa864dd765579cf2be", "filename": "gcc/testsuite/g++.dg/modules/contracts-3_a.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-3_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-3_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-3_a.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,41 @@\n+// Basic test to ensure that guarded templates correctly serialize and\n+// deserialize their contracts through the CMI.\n+// { dg-additional-options \"-fmodules-ts -fcontracts -fcontract-continuation-mode=on\" }\n+module;\n+#include <cstdio>\n+#include <experimental/contract>\n+export module foo;\n+// { dg-module-cmi foo }\n+\n+export int violation_count{0};\n+extern \"C++\" export void handle_contract_violation(const std::experimental::contract_violation &violation)\n+{\n+  violation_count++;\n+  printf(\"violation_count: %d\\n\", violation_count);\n+}\n+\n+export int nontemplate(int n)\n+  [[ pre: n > 0 ]]\n+  [[ post r: r > 0 ]]\n+{\n+  return -n;\n+}\n+\n+export\n+template<typename T>\n+T fn(T n)\n+  [[ pre: n > 0 ]]\n+  [[ post r: r > 0 ]]\n+{\n+  printf(\"%s(%d)\\n\", __FUNCTION__, n);\n+  return n;\n+}\n+\n+export\n+template<typename T>\n+void void_fn(T n)\n+  [[ pre: n < 0 ]]\n+{\n+  printf(\"%s(%d)\\n\", __FUNCTION__, n);\n+}\n+"}, {"sha": "b1d6375391b6b94acbf60f0f6628ddb42ba1b6b7", "filename": "gcc/testsuite/g++.dg/modules/contracts-3_b.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-3_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-3_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-3_b.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,35 @@\n+// { dg-module-do run }\n+// { dg-additional-options \"-fmodules-ts -fcontracts -fcontract-role=default:ignore,ignore,ignore\" }\n+module;\n+#include <cstdio>\n+export module bar;\n+// { dg-module-cmi bar }\n+import foo;\n+\n+template<typename T>\n+bool bar_fn_pre(T n) { printf(\"bar fn pre(%d)\\n\", n); return true; }\n+\n+export\n+template<typename T>\n+T bar_fn(T n)\n+  [[ pre: bar_fn_pre(n) && n > 0 ]]\n+{\n+  printf(\"%s(%d)\\n\", __FUNCTION__, n);\n+  return n;\n+}\n+\n+int main(int, char**)\n+{\n+  nontemplate(5);\n+  nontemplate(-5);\n+  fn(5);\n+  fn(-5);\n+  fn(5.3);\n+  fn(-5.3);\n+  void_fn(5);\n+  void_fn(-5);\n+  bar_fn(5);\n+  bar_fn(-5);\n+  return violation_count == 7 ? 0 : -1;\n+}\n+"}, {"sha": "f269e6c207826efe39a8e56b83dc67be3aa7c27f", "filename": "gcc/testsuite/g++.dg/modules/contracts-4_a.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-4_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-4_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-4_a.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,28 @@\n+// Test that template contracts are not reintpreted when the reinterpret\n+// contracts flag is not set, regardless of the current TU's contract\n+// configuration.\n+// { dg-additional-options \"-fmodules-ts -fcontracts -fcontract-role=default:maybe,maybe,ignore\" }\n+module;\n+#include <cstdio>\n+#include <experimental/contract>\n+export module foo;\n+// { dg-module-cmi foo }\n+\n+export int violation_count{0};\n+extern \"C++\" export void handle_contract_violation(const std::experimental::contract_violation &violation)\n+{\n+  violation_count++;\n+  printf(\"violation_count: %d\\n\", violation_count);\n+}\n+\n+export template<typename T>\n+T fn_t(T t)\n+  [[ pre: t > 0 ]]\n+  [[ pre audit %custom: t > 0 ]]\n+{\n+  printf(\"%s(%d)\\n\", __FUNCTION__, t);\n+  return t;\n+}\n+\n+export int fn_int(int n);\n+"}, {"sha": "65b9287b21126d3e2fa521d68eb72ca05cabd15f", "filename": "gcc/testsuite/g++.dg/modules/contracts-4_b.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-4_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-4_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-4_b.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,8 @@\n+// { dg-additional-options \"-fmodules-ts -fcontracts -fcontract-role=default:ignore,ignore,ignore\" }\n+module foo;\n+\n+int fn_int(int n)\n+{\n+  return fn_t(n);\n+}\n+"}, {"sha": "84fcb61631487b0127d7772df19925befed5507e", "filename": "gcc/testsuite/g++.dg/modules/contracts-4_c.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-4_c.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-4_c.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-4_c.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,9 @@\n+// { dg-additional-options \"-fmodules-ts -fcontracts -fcontract-role=default:ignore,ignore,ignore\" }\n+export module bar;\n+import foo;\n+\n+export int bar_fn_int(int n)\n+{\n+  return fn_t(n);\n+}\n+"}, {"sha": "dc56251d1d889c7f9c944e5a3e6f5223a84c53e0", "filename": "gcc/testsuite/g++.dg/modules/contracts-4_d.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-4_d.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-4_d.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-4_d.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,22 @@\n+// { dg-module-do run }\n+// { dg-additional-options \"-fmodules-ts -fcontracts\" }\n+module;\n+#include <cstdio>\n+export module baz;\n+import foo;\n+import bar;\n+\n+int main(int, char**)\n+{\n+  int x = -1;\n+\n+  printf(\"calling fn_int\\n\");\n+  fn_int(x--);\n+  printf(\"calling bar_fn_int\\n\");\n+  bar_fn_int(x--);\n+\n+  return violation_count - 4;\n+}\n+\n+// TODO verify dg-output as well once the testsuite supports it\n+"}, {"sha": "5e6d848aaa47431dae72cb3ad3bca8817fd1c272", "filename": "gcc/testsuite/g++.dg/modules/contracts-tpl-friend-1_a.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-tpl-friend-1_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-tpl-friend-1_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-tpl-friend-1_a.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,17 @@\n+// { dg-additional-options \"-fmodules-ts -fcontracts\" }\n+\n+export module foo;\n+// { dg-module-cmi foo }\n+\n+void foo (int, void *);\n+void foo (float, void *);\n+\n+template <typename T> class TPL\n+{\n+  friend void foo (T, void *); // { dg-warning \"non-template function\" }\n+\n+  T member;\n+};\n+\n+template class TPL<float>;  // instantiate\n+"}, {"sha": "f872c9248d9d4b8176e0f4bd3ee337e71dd0b314", "filename": "gcc/testsuite/g++.dg/modules/contracts-tpl-friend-1_b.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-tpl-friend-1_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-tpl-friend-1_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcontracts-tpl-friend-1_b.C?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -0,0 +1,19 @@\n+// { dg-additional-options \"-fmodules-ts -fcontracts\" }\n+\n+module foo;\n+\n+void foo (int x, void *p)\n+  [[ pre: x > 0 ]]\n+{\n+  auto *obj = reinterpret_cast<TPL<int> *> (p);\n+\n+  obj->member = x;\n+}\n+\n+void foo (float x, void *p)\n+  [[ pre: x > 0 ]]\n+{\n+  auto *obj = reinterpret_cast<TPL<float> *> (p);\n+\n+  obj->member = x;\n+}"}, {"sha": "cacbd75c385572cb40f4388b163e364b66a2e040", "filename": "gcc/testsuite/g++.dg/modules/modules.exp", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fmodules.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fmodules.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fmodules.exp?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -187,8 +187,9 @@ proc module_do_it { do_what testcase std asm_list } {\n \tlappend options \"additional_flags=$std\"\n \tset ident \"$ident $std\"\n     }\n-    if { [llength $do_what] > 3 } {\n-\tlappend options \"additional_flags=[lindex $do_what 3]\"\n+    global extra_tool_flags\n+    if { [llength $extra_tool_flags] } {\n+\tlappend options \"additional_flags=$extra_tool_flags\"\n     }\n \n     set execname \"./[file tail $testcase].exe\"\n@@ -250,6 +251,8 @@ proc module-init { src } {\n     set option_list {}\n     set have_std 0\n     set std_prefix \"-std=c++\"\n+    global extra_tool_flags\n+    set extra_tool_flags {}\n \n     foreach op $tmp {\n \tswitch [lindex $op 0] {\n@@ -258,11 +261,13 @@ proc module-init { src } {\n \t\tif { [string match \"*-std=*\" [lindex $op 2]] } {\n \t\t    set have_std 1\n \t\t}\n+\t\teval lappend extra_tool_flags [lindex $op 2]\n \t    }\n \t    \"dg-additional-options\" {\n \t\tif { [string match \"*-std=*\" [lindex $op 2]] } {\n \t\t    set have_std 1\n \t\t}\n+\t\teval lappend extra_tool_flags [lindex $op 2]\n \t    }\n \t}\n     }"}, {"sha": "4e10b614f077415498612e7e28952939f1ce2b6a", "filename": "gcc/testsuite/lib/g++.exp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Flib%2Fg%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb237ffc68ec9bb17982434f5941bfa14f8b50/gcc%2Ftestsuite%2Flib%2Fg%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fg%2B%2B.exp?ref=2efb237ffc68ec9bb17982434f5941bfa14f8b50", "patch": "@@ -142,6 +142,10 @@ proc g++_link_flags { paths } {\n \t  append flags \" -L${gccpath}/libstdc++-v3/src/.libs \"\n \t  append ld_library_path \":${gccpath}/libstdc++-v3/src/.libs\"\n       }\n+      if [file exists \"${gccpath}/libstdc++-v3/src/experimental/.libs/libstdc++exp.a\"] {\n+\t  append flags \" -L${gccpath}/libstdc++-v3/src/experimental/.libs \"\n+\t  append ld_library_path \":${gccpath}/libstdc++-v3/src/experimental/.libs\"\n+      }\n \n       if [file exists \"${gccpath}/libiberty/libiberty.a\"] {\n           append flags \"-L${gccpath}/libiberty \""}]}