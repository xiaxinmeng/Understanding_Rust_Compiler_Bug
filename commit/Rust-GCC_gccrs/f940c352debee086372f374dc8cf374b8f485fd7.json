{"sha": "f940c352debee086372f374dc8cf374b8f485fd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk0MGMzNTJkZWJlZTA4NjM3MmYzNzRkYzhjZjM3NGI4ZjQ4NWZkNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2000-11-22T00:59:12Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-11-22T00:59:12Z"}, "message": "alpha.c (alpha_split_tfmode_frobsign): New.\n\n        * config/alpha/alpha.c (alpha_split_tfmode_frobsign): New.\n        * config/alpha/alpha-protos.h: Declare it.\n        * config/alpha/alpha.md (abstf_internal): Use it.\n        (negtf_internal): Likewise.\n        (andnotdi3): Unstar the name.\n        (movtf_internal): Add o/G alternative.\n\nFrom-SVN: r37634", "tree": {"sha": "6e41af970e3a2919c2aeae37c26a63c0d7900f8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e41af970e3a2919c2aeae37c26a63c0d7900f8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f940c352debee086372f374dc8cf374b8f485fd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f940c352debee086372f374dc8cf374b8f485fd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f940c352debee086372f374dc8cf374b8f485fd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f940c352debee086372f374dc8cf374b8f485fd7/comments", "author": null, "committer": null, "parents": [{"sha": "dfc55970936e74f5305b4170d51f37e33982f901", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfc55970936e74f5305b4170d51f37e33982f901", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfc55970936e74f5305b4170d51f37e33982f901"}], "stats": {"total": 116, "additions": 67, "deletions": 49}, "files": [{"sha": "f95b9ba184918fef41c9d92849be62acaf3bff55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f940c352debee086372f374dc8cf374b8f485fd7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f940c352debee086372f374dc8cf374b8f485fd7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f940c352debee086372f374dc8cf374b8f485fd7", "patch": "@@ -1,3 +1,12 @@\n+2000-11-21  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (alpha_split_tfmode_frobsign): New.\n+\t* config/alpha/alpha-protos.h: Declare it.\n+\t* config/alpha/alpha.md (abstf_internal): Use it.\n+\t(negtf_internal): Likewise.\n+\t(andnotdi3): Unstar the name.\n+\t(movtf_internal): Add o/G alternative.\n+\n 2000-11-21  Zack Weinberg  <zack@wolery.stanford.edu>\n \n \t* stringpool.c (stringpool_statistics): Also report number and"}, {"sha": "c12b92d9c79f4f635fef9010fb595678d62f6e48", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f940c352debee086372f374dc8cf374b8f485fd7/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f940c352debee086372f374dc8cf374b8f485fd7/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=f940c352debee086372f374dc8cf374b8f485fd7", "patch": "@@ -90,6 +90,8 @@ extern int alpha_split_conditional_move PARAMS ((enum rtx_code, rtx, rtx,\n extern void alpha_emit_xfloating_arith PARAMS ((enum rtx_code, rtx[]));\n extern void alpha_emit_xfloating_cvt PARAMS ((enum rtx_code, rtx[]));\n extern void alpha_split_tfmode_pair PARAMS ((rtx[]));\n+extern void alpha_split_tfmode_frobsign PARAMS ((rtx[],\n+\t\t\t\t\t\t rtx (*)(rtx, rtx, rtx)));\n extern void alpha_expand_unaligned_load PARAMS ((rtx, rtx, HOST_WIDE_INT,\n \t\t\t\t\t\tHOST_WIDE_INT, int));\n extern void alpha_expand_unaligned_store PARAMS ((rtx, rtx, HOST_WIDE_INT,"}, {"sha": "d16c58c6042ec273b2ba1c10301f1b372fb8c227", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f940c352debee086372f374dc8cf374b8f485fd7/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f940c352debee086372f374dc8cf374b8f485fd7/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=f940c352debee086372f374dc8cf374b8f485fd7", "patch": "@@ -2357,6 +2357,10 @@ alpha_emit_xfloating_cvt (code, operands)\n \t\t\t\t\t       operands[1]));\n }\n \n+/* Split a TFmode OP[1] into DImode OP[2,3] and likewise for\n+   OP[0] into OP[0,1].  Naturally, output operand ordering is\n+   little-endian.  */\n+\n void\n alpha_split_tfmode_pair (operands)\n      rtx operands[4];\n@@ -2391,6 +2395,52 @@ alpha_split_tfmode_pair (operands)\n   else\n     abort ();\n }\n+\n+/* Implement negtf2 or abstf2.  Op0 is destination, op1 is source, \n+   op2 is a register containing the sign bit, operation is the \n+   logical operation to be performed.  */\n+\n+void\n+alpha_split_tfmode_frobsign (operands, operation)\n+     rtx operands[3];\n+     rtx (*operation) PARAMS ((rtx, rtx, rtx));\n+{\n+  rtx high_bit = operands[2];\n+  rtx scratch;\n+  int move;\n+\n+  alpha_split_tfmode_pair (operands);\n+\n+  /* Detect three flavours of operand overlap.  */\n+  move = 1;\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    move = 0;\n+  else if (rtx_equal_p (operands[1], operands[2]))\n+    {\n+      if (rtx_equal_p (operands[0], high_bit))\n+\tmove = 2;\n+      else\n+\tmove = -1;\n+    }\n+\n+  if (move < 0)\n+    emit_move_insn (operands[0], operands[2]);\n+\n+  /* ??? If the destination overlaps both source tf and high_bit, then\n+     assume source tf is dead in its entirety and use the other half\n+     for a scratch register.  Otherwise \"scratch\" is just the proper\n+     destination register.  */\n+  scratch = operands[move < 2 ? 1 : 3];\n+\n+  emit_insn ((*operation) (scratch, high_bit, operands[3]));\n+\n+  if (move > 0)\n+    {\n+      emit_move_insn (operands[0], operands[2]);\n+      if (move > 1)\n+\temit_move_insn (operands[1], scratch);\n+    }\n+}\n \f\n /* Use ext[wlq][lh] as the Architecture Handbook describes for extracting\n    unaligned data:"}, {"sha": "028ce48739a2f1faed4889dfc1084a9a4ffe1350", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 6, "deletions": 49, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f940c352debee086372f374dc8cf374b8f485fd7/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f940c352debee086372f374dc8cf374b8f485fd7/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=f940c352debee086372f374dc8cf374b8f485fd7", "patch": "@@ -1187,7 +1187,7 @@\n   \"zapnot %1,15,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n-(define_insn  \"*andnot\"\n+(define_insn \"andnotdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(and:DI (not:DI (match_operand:DI 1 \"reg_or_8bit_operand\" \"rI\"))\n \t\t(match_operand:DI 2 \"reg_or_0_operand\" \"rJ\")))]\n@@ -1876,35 +1876,12 @@\n (define_insn_and_split \"*abstf_internal\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=r\")\n \t(abs:TF (match_operand:TF 1 \"reg_or_fp0_operand\" \"rG\")))\n-   (use (match_operand:DI 2 \"register_operand\" \"=r\"))]\n+   (use (match_operand:DI 2 \"register_operand\" \"r\"))]\n   \"TARGET_HAS_XFLOATING_LIBS\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n-  \"\n-{\n-  int move;\n-  rtx tmp;\n-\n-  alpha_split_tfmode_pair (operands);\n-\n-  move = 1;\n-  if (rtx_equal_p (operands[0], operands[2]))\n-    move = 0;\n-  else if (rtx_equal_p (operands[1], operands[2]))\n-    move = -1;\n-\n-  if (move < 0)\n-    emit_move_insn (operands[0], operands[2]);\n-\n-  tmp = gen_rtx_NOT (DImode, operands[4]);\n-  tmp = gen_rtx_AND (DImode, tmp, operands[3]);\n-  emit_insn (gen_rtx_SET (VOIDmode, operands[1], tmp));\n-\t\n-  if (move > 0)\n-    emit_move_insn (operands[0], operands[2]);\n-  DONE;\n-}\")\n+  \"alpha_split_tfmode_frobsign (operands, gen_andnotdi3); DONE;\")\n \n (define_insn \"negsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n@@ -1937,32 +1914,12 @@\n (define_insn_and_split \"*negtf_internal\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=r\")\n \t(neg:TF (match_operand:TF 1 \"reg_or_fp0_operand\" \"rG\")))\n-   (use (match_operand:DI 2 \"register_operand\" \"=r\"))]\n+   (use (match_operand:DI 2 \"register_operand\" \"r\"))]\n   \"TARGET_HAS_XFLOATING_LIBS\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n-  \"\n-{\n-  int move;\n-\n-  alpha_split_tfmode_pair (operands);\n-\n-  move = 1;\n-  if (rtx_equal_p (operands[0], operands[2]))\n-    move = 0;\n-  else if (rtx_equal_p (operands[1], operands[2]))\n-    move = -1;\n-\n-  if (move < 0)\n-    emit_move_insn (operands[0], operands[2]);\n-\n-  emit_insn (gen_xordi3 (operands[1], operands[3], operands[4]));\n-\t\n-  if (move > 0)\n-    emit_move_insn (operands[0], operands[2]);\n-  DONE;\n-}\")\n+  \"alpha_split_tfmode_frobsign (operands, gen_xordi3); DONE;\")\n \n (define_insn \"*addsf_ieee\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=&f\")\n@@ -4595,7 +4552,7 @@\n \n (define_insn_and_split \"*movtf_internal\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=r,o\")\n-\t(match_operand:TF 1 \"input_operand\" \"roG,r\"))]\n+\t(match_operand:TF 1 \"input_operand\" \"roG,rG\"))]\n   \"register_operand (operands[0], TFmode)\n    || reg_or_fp0_operand (operands[1], TFmode)\"\n   \"#\""}]}