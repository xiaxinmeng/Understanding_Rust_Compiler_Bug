{"sha": "8ccd8b12ded1782f4273fd1f381b7d554df61a12", "node_id": "C_kwDOANBUbNoAKDhjY2Q4YjEyZGVkMTc4MmY0MjczZmQxZjM4MWI3ZDU1NGRmNjFhMTI", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-12-15T05:57:44Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-12-15T05:57:44Z"}, "message": "Add LXVKQ support.\n\nThis patch adds support to generate the LXVKQ instruction to load specific\nIEEE-128 floating point constants.\n\nCompared to the last time I submitted this patch, I modified it so that it\nuses the bit pattern of the vector to see if it can generate the LXVKQ\ninstruction.  This means on a little endian Power<xxx> system, the\nfollowing code will generate a LXVKQ 34,16 instruction:\n\n    vector long long foo (void)\n    {\n      return (vector long long) { 0x0000000000000000, 0x8000000000000000 };\n    }\n\nbecause that vector pattern is the same bit pattern as -0.0F128.\n\n2021-12-14  Michael Meissner  <meissner@the-meissners.org>\n\ngcc/\n\n\t* config/rs6000/constraints.md (eQ): New constraint.\n\t* config/rs6000/predicates.md (easy_fp_constant): Add support for\n\tgenerating the LXVKQ instruction.\n\t(easy_vector_constant_ieee128): New predicate.\n\t(easy_vector_constant): Add support for generating the LXVKQ\n\tinstruction.\n\t* config/rs6000/rs6000-protos.h (constant_generates_lxvkq): New\n\tdeclaration.\n\t* config/rs6000/rs6000.c (output_vec_const_move): Add support for\n\tgenerating LXVKQ.\n\t(constant_generates_lxvkq): New function.\n\t* config/rs6000/rs6000.opt (-mieee128-constant): New debug\n\toption.\n\t* config/rs6000/vsx.md (vsx_mov<mode>_64bit): Add support for\n\tgenerating LXVKQ.\n\t(vsx_mov<mode>_32bit): Likewise.\n\t* doc/md.texi (PowerPC and IBM RS6000 constraints): Document the\n\teQ constraint.\n\ngcc/testsuite/\n\n\t* gcc.target/powerpc/float128-constant.c: New test.", "tree": {"sha": "da03675a2aa6ac752ea46c9b1c242d10e8bb77cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da03675a2aa6ac752ea46c9b1c242d10e8bb77cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ccd8b12ded1782f4273fd1f381b7d554df61a12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ccd8b12ded1782f4273fd1f381b7d554df61a12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ccd8b12ded1782f4273fd1f381b7d554df61a12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ccd8b12ded1782f4273fd1f381b7d554df61a12/comments", "author": null, "committer": null, "parents": [{"sha": "c6756b3bc1d2af1c8e86f0ad1711e9b9134520ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6756b3bc1d2af1c8e86f0ad1711e9b9134520ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6756b3bc1d2af1c8e86f0ad1711e9b9134520ba"}], "stats": {"total": 285, "additions": 285, "deletions": 0}, "files": [{"sha": "e72132b4c28111aabfcbca7ff8acef5bee27909a", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccd8b12ded1782f4273fd1f381b7d554df61a12/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccd8b12ded1782f4273fd1f381b7d554df61a12/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=8ccd8b12ded1782f4273fd1f381b7d554df61a12", "patch": "@@ -213,6 +213,12 @@\n   \"A signed 34-bit integer constant if prefixed instructions are supported.\"\n   (match_operand 0 \"cint34_operand\"))\n \n+;; A TF/KF scalar constant or a vector constant that can load certain IEEE\n+;; 128-bit constants into vector registers using LXVKQ.\n+(define_constraint \"eQ\"\n+  \"An IEEE 128-bit constant that can be loaded into VSX registers.\"\n+  (match_operand 0 \"easy_vector_constant_ieee128\"))\n+\n ;; Floating-point constraints.  These two are defined so that insn\n ;; length attributes can be calculated exactly.\n "}, {"sha": "be721673cba9c794a81c3da70d4af4f33f1240d2", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccd8b12ded1782f4273fd1f381b7d554df61a12/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccd8b12ded1782f4273fd1f381b7d554df61a12/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=8ccd8b12ded1782f4273fd1f381b7d554df61a12", "patch": "@@ -601,6 +601,14 @@\n   if (TARGET_VSX && op == CONST0_RTX (mode))\n     return 1;\n \n+  /* Constants that can be generated with ISA 3.1 instructions are easy.  */\n+  vec_const_128bit_type vsx_const;\n+  if (TARGET_POWER10 && vec_const_128bit_to_bytes (op, mode, &vsx_const))\n+    {\n+      if (constant_generates_lxvkq (&vsx_const) != 0)\n+\treturn true;\n+    }\n+\n   /* Otherwise consider floating point constants hard, so that the\n      constant gets pushed to memory during the early RTL phases.  This\n      has the advantage that double precision constants that can be\n@@ -609,6 +617,23 @@\n    return 0;\n })\n \n+;; Return 1 if the operand is a special IEEE 128-bit value that can be loaded\n+;; via the LXVKQ instruction.\n+\n+(define_predicate \"easy_vector_constant_ieee128\"\n+  (match_code \"const_vector,const_double\")\n+{\n+  vec_const_128bit_type vsx_const;\n+\n+  /* Can we generate the LXVKQ instruction?  */\n+  if (!TARGET_IEEE128_CONSTANT || !TARGET_FLOAT128_HW || !TARGET_POWER10\n+      || !TARGET_VSX)\n+    return false;\n+\n+  return (vec_const_128bit_to_bytes (op, mode, &vsx_const)\n+\t  && constant_generates_lxvkq (&vsx_const) != 0);\n+})\n+\n ;; Return 1 if the operand is a constant that can loaded with a XXSPLTIB\n ;; instruction and then a VUPKHSB, VECSB2W or VECSB2D instruction.\n \n@@ -653,6 +678,15 @@\n       if (zero_constant (op, mode) || all_ones_constant (op, mode))\n \treturn true;\n \n+      /* Constants that can be generated with ISA 3.1 instructions are\n+         easy.  */\n+      vec_const_128bit_type vsx_const;\n+      if (TARGET_POWER10 && vec_const_128bit_to_bytes (op, mode, &vsx_const))\n+\t{\n+\t  if (constant_generates_lxvkq (&vsx_const) != 0)\n+\t    return true;\n+\t}\n+\n       if (TARGET_P9_VECTOR\n           && xxspltib_constant_p (op, mode, &num_insns, &value))\n \treturn true;"}, {"sha": "4a2e7fa7af1d639d53d1fbc501cc6ed2dcd0d949", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccd8b12ded1782f4273fd1f381b7d554df61a12/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccd8b12ded1782f4273fd1f381b7d554df61a12/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=8ccd8b12ded1782f4273fd1f381b7d554df61a12", "patch": "@@ -250,6 +250,7 @@ typedef struct {\n \n extern bool vec_const_128bit_to_bytes (rtx, machine_mode,\n \t\t\t\t       vec_const_128bit_type *);\n+extern unsigned constant_generates_lxvkq (vec_const_128bit_type *);\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE"}, {"sha": "0bc384464f637a95a7384c47ed830802b1fb12e2", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccd8b12ded1782f4273fd1f381b7d554df61a12/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccd8b12ded1782f4273fd1f381b7d554df61a12/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=8ccd8b12ded1782f4273fd1f381b7d554df61a12", "patch": "@@ -6700,6 +6700,17 @@ output_vec_const_move (rtx *operands)\n \t    gcc_unreachable ();\n \t}\n \n+      vec_const_128bit_type vsx_const;\n+      if (TARGET_POWER10 && vec_const_128bit_to_bytes (vec, mode, &vsx_const))\n+\t{\n+\t  unsigned imm = constant_generates_lxvkq (&vsx_const);\n+\t  if (imm)\n+\t    {\n+\t      operands[2] = GEN_INT (imm);\n+\t      return \"lxvkq %x0,%2\";\n+\t    }\n+\t}\n+\n       if (TARGET_P9_VECTOR\n \t  && xxspltib_constant_p (vec, mode, &num_insns, &xxspltib_value))\n \t{\n@@ -28587,6 +28598,57 @@ vec_const_128bit_to_bytes (rtx op,\n   return true;\n }\n \n+/* Determine if an IEEE 128-bit constant can be loaded with LXVKQ.  Return zero\n+   if the LXVKQ instruction cannot be used.  Otherwise return the immediate\n+   value to be used with the LXVKQ instruction.  */\n+\n+unsigned\n+constant_generates_lxvkq (vec_const_128bit_type *vsx_const)\n+{\n+  /* Is the instruction supported with power10 code generation, IEEE 128-bit\n+     floating point hardware and VSX registers are available.  */\n+  if (!TARGET_IEEE128_CONSTANT || !TARGET_FLOAT128_HW || !TARGET_POWER10\n+      || !TARGET_VSX)\n+    return 0;\n+\n+  /* All of the constants that are generated by LXVKQ have the bottom 3 words\n+     that are 0.  */\n+  if (vsx_const->words[1] != 0\n+      || vsx_const->words[2] != 0\n+      || vsx_const->words[3] != 0)\n+      return 0;\n+\n+  /* See if we have a match for the first word.  */\n+  switch (vsx_const->words[0])\n+    {\n+    case 0x3FFF0000U: return 1;\t\t/* IEEE 128-bit +1.0.  */\n+    case 0x40000000U: return 2;\t\t/* IEEE 128-bit +2.0.  */\n+    case 0x40008000U: return 3;\t\t/* IEEE 128-bit +3.0.  */\n+    case 0x40010000U: return 4;\t\t/* IEEE 128-bit +4.0.  */\n+    case 0x40014000U: return 5;\t\t/* IEEE 128-bit +5.0.  */\n+    case 0x40018000U: return 6;\t\t/* IEEE 128-bit +6.0.  */\n+    case 0x4001C000U: return 7;\t\t/* IEEE 128-bit +7.0.  */\n+    case 0x7FFF0000U: return 8;\t\t/* IEEE 128-bit +Infinity.  */\n+    case 0x7FFF8000U: return 9;\t\t/* IEEE 128-bit quiet NaN.  */\n+    case 0x80000000U: return 16;\t/* IEEE 128-bit -0.0.  */\n+    case 0xBFFF0000U: return 17;\t/* IEEE 128-bit -1.0.  */\n+    case 0xC0000000U: return 18;\t/* IEEE 128-bit -2.0.  */\n+    case 0xC0008000U: return 19;\t/* IEEE 128-bit -3.0.  */\n+    case 0xC0010000U: return 20;\t/* IEEE 128-bit -4.0.  */\n+    case 0xC0014000U: return 21;\t/* IEEE 128-bit -5.0.  */\n+    case 0xC0018000U: return 22;\t/* IEEE 128-bit -6.0.  */\n+    case 0xC001C000U: return 23;\t/* IEEE 128-bit -7.0.  */\n+    case 0xFFFF0000U: return 24;\t/* IEEE 128-bit -Infinity.  */\n+\n+      /* anything else cannot be loaded.  */\n+    default:\n+      break;\n+    }\n+\n+  return 0;\n+}\n+\n+\f\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-rs6000.h\""}, {"sha": "b7433ec4e30d854c3021b7a33dd5eb0851be9079", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccd8b12ded1782f4273fd1f381b7d554df61a12/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccd8b12ded1782f4273fd1f381b7d554df61a12/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=8ccd8b12ded1782f4273fd1f381b7d554df61a12", "patch": "@@ -640,6 +640,10 @@ mprivileged\n Target Var(rs6000_privileged) Init(0)\n Generate code that will run in privileged state.\n \n+mieee128-constant\n+Target Var(TARGET_IEEE128_CONSTANT) Init(1) Save\n+Generate (do not generate) code that uses the LXVKQ instruction.\n+\n -param=rs6000-density-pct-threshold=\n Target Undocumented Joined UInteger Var(rs6000_density_pct_threshold) Init(85) IntegerRange(0, 100) Param\n When costing for loop vectorization, we probably need to penalize the loop body"}, {"sha": "de048408a03d1b6a8cd373a381be2c0dc8995e64", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccd8b12ded1782f4273fd1f381b7d554df61a12/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccd8b12ded1782f4273fd1f381b7d554df61a12/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=8ccd8b12ded1782f4273fd1f381b7d554df61a12", "patch": "@@ -1192,16 +1192,19 @@\n \n ;;              VSX store  VSX load   VSX move  VSX->GPR   GPR->VSX    LQ (GPR)\n ;;              STQ (GPR)  GPR load   GPR store GPR move   XXSPLTIB    VSPLTISW\n+;;              LXVKQ\n ;;              VSX 0/-1   VMX const  GPR const LVX (VMX)  STVX (VMX)\n (define_insn \"vsx_mov<mode>_64bit\"\n   [(set (match_operand:VSX_M 0 \"nonimmediate_operand\"\n                \"=ZwO,      wa,        wa,        r,         we,        ?wQ,\n                 ?&r,       ??r,       ??Y,       <??r>,     wa,        v,\n+                wa,\n                 ?wa,       v,         <??r>,     wZ,        v\")\n \n \t(match_operand:VSX_M 1 \"input_operand\" \n                \"wa,        ZwO,       wa,        we,        r,         r,\n                 wQ,        Y,         r,         r,         wE,        jwM,\n+                eQ,\n                 ?jwM,      W,         <nW>,      v,         wZ\"))]\n \n   \"TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\n@@ -1213,35 +1216,43 @@\n   [(set_attr \"type\"\n                \"vecstore,  vecload,   vecsimple, mtvsr,     mfvsr,     load,\n                 store,     load,      store,     *,         vecsimple, vecsimple,\n+                vecperm,\n                 vecsimple, *,         *,         vecstore,  vecload\")\n    (set_attr \"num_insns\"\n                \"*,         *,         *,         2,         *,         2,\n                 2,         2,         2,         2,         *,         *,\n+                *,\n                 *,         5,         2,         *,         *\")\n    (set_attr \"max_prefixed_insns\"\n                \"*,         *,         *,         *,         *,         2,\n                 2,         2,         2,         2,         *,         *,\n+                *,\n                 *,         *,         *,         *,         *\")\n    (set_attr \"length\"\n                \"*,         *,         *,         8,         *,         8,\n                 8,         8,         8,         8,         *,         *,\n+                *,\n                 *,         20,        8,         *,         *\")\n    (set_attr \"isa\"\n                \"<VSisa>,   <VSisa>,   <VSisa>,   *,         *,         *,\n                 *,         *,         *,         *,         p9v,       *,\n+                p10,\n                 <VSisa>,   *,         *,         *,         *\")])\n \n ;;              VSX store  VSX load   VSX move   GPR load   GPR store  GPR move\n+;;              LXVKQ\n ;;              XXSPLTIB   VSPLTISW   VSX 0/-1   VMX const  GPR const\n ;;              LVX (VMX)  STVX (VMX)\n (define_insn \"*vsx_mov<mode>_32bit\"\n   [(set (match_operand:VSX_M 0 \"nonimmediate_operand\"\n                \"=ZwO,      wa,        wa,        ??r,       ??Y,       <??r>,\n+                wa,\n                 wa,        v,         ?wa,       v,         <??r>,\n                 wZ,        v\")\n \n \t(match_operand:VSX_M 1 \"input_operand\" \n                \"wa,        ZwO,       wa,        Y,         r,         r,\n+                eQ,\n                 wE,        jwM,       ?jwM,      W,         <nW>,\n                 v,         wZ\"))]\n \n@@ -1253,14 +1264,17 @@\n }\n   [(set_attr \"type\"\n                \"vecstore,  vecload,   vecsimple, load,      store,    *,\n+                vecperm,\n                 vecsimple, vecsimple, vecsimple, *,         *,\n                 vecstore,  vecload\")\n    (set_attr \"length\"\n                \"*,         *,         *,         16,        16,        16,\n+                *,\n                 *,         *,         *,         20,        16,\n                 *,         *\")\n    (set_attr \"isa\"\n                \"<VSisa>,   <VSisa>,   <VSisa>,   *,         *,         *,\n+                p10,\n                 p9v,       *,         <VSisa>,   *,         *,\n                 *,         *\")])\n "}, {"sha": "69cb7e3bfde203a022143d47f42dae8ab603efd9", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccd8b12ded1782f4273fd1f381b7d554df61a12/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccd8b12ded1782f4273fd1f381b7d554df61a12/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=8ccd8b12ded1782f4273fd1f381b7d554df61a12", "patch": "@@ -3336,6 +3336,10 @@ A constant whose negation is a signed 16-bit constant.\n @item eI\n A signed 34-bit integer constant if prefixed instructions are supported.\n \n+@item eQ\n+An IEEE 128-bit constant that can be loaded into a VSX register with\n+the @code{lxvkq} instruction.\n+\n @ifset INTERNALS\n @item G\n A floating point constant that can be loaded into a register with one"}, {"sha": "e3286a786a52c08d8dcd7cb58d7b26ee6e0cec9a", "filename": "gcc/testsuite/gcc.target/powerpc/float128-constant.c", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccd8b12ded1782f4273fd1f381b7d554df61a12/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-constant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccd8b12ded1782f4273fd1f381b7d554df61a12/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-constant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-constant.c?ref=8ccd8b12ded1782f4273fd1f381b7d554df61a12", "patch": "@@ -0,0 +1,160 @@\n+/* { dg-require-effective-target ppc_float128_hw } */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2\" } */\n+\n+/* Test whether the LXVKQ instruction is generated to load special IEEE 128-bit\n+   constants.  */\n+\n+_Float128\n+return_0 (void)\n+{\n+  return 0.0f128;\t\t\t/* XXSPLTIB 34,0.  */\n+}\n+\n+_Float128\n+return_1 (void)\n+{\n+  return 1.0f128;\t\t\t/* LXVKQ 34,1.  */\n+}\n+\n+_Float128\n+return_2 (void)\n+{\n+  return 2.0f128;\t\t\t/* LXVKQ 34,2.  */\n+}\n+\n+_Float128\n+return_3 (void)\n+{\n+  return 3.0f128;\t\t\t/* LXVKQ 34,3.  */\n+}\n+\n+_Float128\n+return_4 (void)\n+{\n+  return 4.0f128;\t\t\t/* LXVKQ 34,4.  */\n+}\n+\n+_Float128\n+return_5 (void)\n+{\n+  return 5.0f128;\t\t\t/* LXVKQ 34,5.  */\n+}\n+\n+_Float128\n+return_6 (void)\n+{\n+  return 6.0f128;\t\t\t/* LXVKQ 34,6.  */\n+}\n+\n+_Float128\n+return_7 (void)\n+{\n+  return 7.0f128;\t\t\t/* LXVKQ 34,7.  */\n+}\n+\n+_Float128\n+return_m0 (void)\n+{\n+  return -0.0f128;\t\t\t/* LXVKQ 34,16.  */\n+}\n+\n+_Float128\n+return_m1 (void)\n+{\n+  return -1.0f128;\t\t\t/* LXVKQ 34,17.  */\n+}\n+\n+_Float128\n+return_m2 (void)\n+{\n+  return -2.0f128;\t\t\t/* LXVKQ 34,18.  */\n+}\n+\n+_Float128\n+return_m3 (void)\n+{\n+  return -3.0f128;\t\t\t/* LXVKQ 34,19.  */\n+}\n+\n+_Float128\n+return_m4 (void)\n+{\n+  return -4.0f128;\t\t\t/* LXVKQ 34,20.  */\n+}\n+\n+_Float128\n+return_m5 (void)\n+{\n+  return -5.0f128;\t\t\t/* LXVKQ 34,21.  */\n+}\n+\n+_Float128\n+return_m6 (void)\n+{\n+  return -6.0f128;\t\t\t/* LXVKQ 34,22.  */\n+}\n+\n+_Float128\n+return_m7 (void)\n+{\n+  return -7.0f128;\t\t\t/* LXVKQ 34,23.  */\n+}\n+\n+_Float128\n+return_inf (void)\n+{\n+  return __builtin_inff128 ();\t\t/* LXVKQ 34,8.  */\n+}\n+\n+_Float128\n+return_minf (void)\n+{\n+  return - __builtin_inff128 ();\t/* LXVKQ 34,24.  */\n+}\n+\n+_Float128\n+return_nan (void)\n+{\n+  return __builtin_nanf128 (\"\");\t/* LXVKQ 34,9.  */\n+}\n+\n+/* Note, the following NaNs should not generate a LXVKQ instruction.  */\n+_Float128\n+return_mnan (void)\n+{\n+  return - __builtin_nanf128 (\"\");\t/* PLXV 34,... */\n+}\n+\n+_Float128\n+return_nan2 (void)\n+{\n+  return __builtin_nanf128 (\"1\");\t/* PLXV 34,... */\n+}\n+\n+_Float128\n+return_nans (void)\n+{\n+  return __builtin_nansf128 (\"\");\t/* PLXV 34,... */\n+}\n+\n+vector long long\n+return_longlong_neg_0 (void)\n+{\n+  /* This vector is the same pattern as -0.0F128.  */\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+#define FIRST\t0x8000000000000000\n+#define SECOND\t0x0000000000000000\n+\n+#else\n+#define FIRST\t0x0000000000000000\n+#define SECOND\t0x8000000000000000\n+#endif\n+\n+  return (vector long long) { FIRST, SECOND };\t/* LXVKQ 34,16.  */\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mlxvkq\\M}    19 } } */\n+/* { dg-final { scan-assembler-times {\\mplxv\\M}      3 } } */\n+/* { dg-final { scan-assembler-times {\\mxxspltib\\M}  1 } } */\n+"}]}