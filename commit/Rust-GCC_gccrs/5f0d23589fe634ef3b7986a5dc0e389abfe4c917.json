{"sha": "5f0d23589fe634ef3b7986a5dc0e389abfe4c917", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYwZDIzNTg5ZmU2MzRlZjNiNzk4NmE1ZGMwZTM4OWFiZmU0YzkxNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-12-24T15:44:45Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-12-24T15:44:45Z"}, "message": "rtl.h (in_expr_list_p): New declaration.\n\n\t* rtl.h (in_expr_list_p): New declaration.\n\t* rtlanal.c (in_expr_list_p): New function.\n\t* cfgcleanup.c: Reformatting and minor code rearrangement.\n\t* cfglayout.c, cfgloop.c, cfgrtl.c: Likewise.\n\nFrom-SVN: r48304", "tree": {"sha": "e186b987f46b4fb2c5b039a34787ffa2f09946d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e186b987f46b4fb2c5b039a34787ffa2f09946d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f0d23589fe634ef3b7986a5dc0e389abfe4c917", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f0d23589fe634ef3b7986a5dc0e389abfe4c917", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f0d23589fe634ef3b7986a5dc0e389abfe4c917", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f0d23589fe634ef3b7986a5dc0e389abfe4c917/comments", "author": null, "committer": null, "parents": [{"sha": "e88712b55bd1534c8ad70e40f0b81d92007e1000", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e88712b55bd1534c8ad70e40f0b81d92007e1000", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e88712b55bd1534c8ad70e40f0b81d92007e1000"}], "stats": {"total": 1102, "additions": 561, "deletions": 541}, "files": [{"sha": "b6772944d14fcc91fd1541aaa77c41397f22ebf8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0d23589fe634ef3b7986a5dc0e389abfe4c917/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0d23589fe634ef3b7986a5dc0e389abfe4c917/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f0d23589fe634ef3b7986a5dc0e389abfe4c917", "patch": "@@ -1,3 +1,10 @@\n+Mon Dec 24 10:24:59 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* rtl.h (in_expr_list_p): New declaration.\n+\t* rtlanal.c (in_expr_list_p): New function.\n+\t* cfgcleanup.c: Reformatting and minor code rearrangement.\n+\t* cfglayout.c, cfgloop.c, cfgrtl.c: Likewise.\n+\n 2001-12-23  Richard Henderson  <rth@redhat.com>\n \n \tPR c/5163:"}, {"sha": "9933defe433d640fc1f88b9ce0d0f5ae2dc766d5", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 86, "deletions": 55, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0d23589fe634ef3b7986a5dc0e389abfe4c917/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0d23589fe634ef3b7986a5dc0e389abfe4c917/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=5f0d23589fe634ef3b7986a5dc0e389abfe4c917", "patch": "@@ -47,21 +47,23 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"obstack.h\"\n \n /* cleanup_cfg maintains following flags for each basic block.  */\n-enum bb_flags {\n+\n+enum bb_flags\n+{\n     /* Set if life info needs to be recomputed for given BB.  */\n     BB_UPDATE_LIFE = 1,\n     /* Set if BB is the forwarder block to avoid too many\n        forwarder_block_p calls.  */\n     BB_FORWARDER_BLOCK = 2\n-  };\n+};\n \n-#define BB_FLAGS(bb) (enum bb_flags)(bb)->aux\n-#define BB_SET_FLAG(bb,flag) \\\n-  (bb)->aux = (void *) (long) ((enum bb_flags)(bb)->aux | (flag))\n-#define BB_CLEAR_FLAG(bb,flag) \\\n-  (bb)->aux = (void *) (long) ((enum bb_flags)(bb)->aux & ~(flag))\n+#define BB_FLAGS(BB) (enum bb_flags) (BB)->aux\n+#define BB_SET_FLAG(BB, FLAG) \\\n+  (BB)->aux = (void *) (long) ((enum bb_flags) (BB)->aux | (FLAG))\n+#define BB_CLEAR_FLAG(BB, FLAG) \\\n+  (BB)->aux = (void *) (long) ((enum bb_flags) (BB)->aux & ~(FLAG))\n \n-#define FORWARDER_BLOCK_P(bb) (BB_FLAGS(bb) & BB_FORWARDER_BLOCK)\n+#define FORWARDER_BLOCK_P(BB) (BB_FLAGS (BB) & BB_FORWARDER_BLOCK)\n \n static bool try_crossjump_to_edge\tPARAMS ((int, edge, edge));\n static bool try_crossjump_bb\t\tPARAMS ((int, basic_block));\n@@ -96,6 +98,7 @@ notice_new_block (bb)\n {\n   if (!bb)\n     return;\n+\n   BB_SET_FLAG (bb, BB_UPDATE_LIFE);\n   if (forwarder_block_p (bb))\n     BB_SET_FLAG (bb, BB_FORWARDER_BLOCK);\n@@ -183,6 +186,7 @@ try_simplify_condjump (cbranch_block)\n \f\n /* Attempt to prove that operation is NOOP using CSElib or mark the effect\n    on register.  Used by jump threading.  */\n+\n static bool\n mark_effect (exp, nonequal)\n   rtx exp;\n@@ -196,13 +200,15 @@ mark_effect (exp, nonequal)\n \tif (REG_P (XEXP (exp, 0)))\n \t  CLEAR_REGNO_REG_SET (nonequal, REGNO (XEXP (exp, 0)));\n \treturn false;\n+\n       case SET:\n \tif (rtx_equal_for_cselib_p (SET_DEST (exp), SET_SRC (exp)))\n \t  return false;\n \tif (GET_CODE (SET_SRC (exp)) != REG)\n \t  return true;\n \tSET_REGNO_REG_SET (nonequal, REGNO (SET_SRC (exp)));\n \treturn false;\n+\n       default:\n \treturn false;\n     }\n@@ -281,10 +287,11 @@ thread_jump (mode, e, b)\n \n   nonequal = BITMAP_XMALLOC();\n   CLEAR_REG_SET (nonequal);\n+\n   /* Now assume that we've continued by the edge E to B and continue\n      processing as if it were same basic block.\n-   \n      Our goal is to prove that whole block is an NOOP.  */\n+\n   for (insn = NEXT_INSN (b->head); insn != b->end && !failed;\n        insn = NEXT_INSN (insn))\n   {\n@@ -300,6 +307,7 @@ thread_jump (mode, e, b)\n \telse\n \t  failed |= mark_effect (pat, nonequal);\n       }\n+\n     cselib_process_insn (insn);\n   }\n \n@@ -340,7 +348,7 @@ try_forward_edges (mode, b)\n   bool changed = false;\n   edge e, next, threaded_edge;\n \n-  for (e = b->succ; e ; e = next)\n+  for (e = b->succ; e; e = next)\n     {\n       basic_block target, first;\n       int counter;\n@@ -372,6 +380,7 @@ try_forward_edges (mode, b)\n \t\tcounter = n_basic_blocks;\n \t      new_target = target->succ->dest;\n \t    }\n+\n \t  /* Allow to thread only over one edge at time to simplify updating\n \t     of probabilities.  */\n \t  else if ((mode & CLEANUP_THREADING) && !threaded)\n@@ -383,6 +392,7 @@ try_forward_edges (mode, b)\n \t\t  new_target_threaded = true;\n \t\t}\n \t    }\n+\n \t  if (!new_target)\n \t    break;\n \n@@ -400,7 +410,7 @@ try_forward_edges (mode, b)\n \t      if (GET_CODE (insn) != NOTE)\n \t\tinsn = NEXT_INSN (insn);\n \n-\t      for (;insn && GET_CODE (insn) != CODE_LABEL && !INSN_P (insn);\n+\t      for (; insn && GET_CODE (insn) != CODE_LABEL && !INSN_P (insn);\n \t\t   insn = NEXT_INSN (insn))\n \t\tif (GET_CODE (insn) == NOTE\n \t\t    && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n@@ -409,6 +419,7 @@ try_forward_edges (mode, b)\n \t      if (GET_CODE (insn) == NOTE)\n \t\tbreak;\n \t    }\n+\n \t  counter++;\n \t  target = new_target;\n \t  threaded |= new_target_threaded;\n@@ -438,10 +449,12 @@ try_forward_edges (mode, b)\n \t  else if (!redirect_edge_and_branch (e, target))\n \t    {\n \t      if (rtl_dump_file)\n-\t\tfprintf (rtl_dump_file, \"Forwarding edge %i->%i to %i failed.\\n\",\n+\t\tfprintf (rtl_dump_file,\n+\t\t\t \"Forwarding edge %i->%i to %i failed.\\n\",\n \t\t\t b->index, e->dest->index, target->index);\n \t      continue;\n \t    }\n+\n \t  /* We successfully forwarded the edge.  Now update profile\n \t     data: for each edge we traversed in the chain, remove\n \t     the original edge's execution count.  */\n@@ -456,13 +469,15 @@ try_forward_edges (mode, b)\n \t  do\n \t    {\n \t      edge t;\n+\n \t      first->count -= edge_count;\n \t      first->succ->count -= edge_count;\n \t      first->frequency -= edge_frequency;\n \t      if (first->succ->succ_next)\n \t\tt = threaded_edge;\n \t      else\n \t\tt = first->succ;\n+\n \t      first = t->dest;\n \t    }\n \t  while (first != target);\n@@ -553,10 +568,8 @@ merge_blocks_move_predecessor_nojumps (a, b)\n   BB_SET_FLAG (a, BB_UPDATE_LIFE);\n \n   if (rtl_dump_file)\n-    {\n-      fprintf (rtl_dump_file, \"Moved block %d before %d and merged.\\n\",\n-\t       a->index, b->index);\n-    }\n+    fprintf (rtl_dump_file, \"Moved block %d before %d and merged.\\n\",\n+\t     a->index, b->index);\n \n   /* Swap the records for the two blocks around.  Although we are deleting B,\n      A is now where B was and we want to compact the BB array from where\n@@ -623,10 +636,8 @@ merge_blocks_move_successor_nojumps (a, b)\n   BB_SET_FLAG (a, BB_UPDATE_LIFE);\n \n   if (rtl_dump_file)\n-    {\n-      fprintf (rtl_dump_file, \"Moved block %d after %d and merged.\\n\",\n-\t       b->index, a->index);\n-    }\n+    fprintf (rtl_dump_file, \"Moved block %d after %d and merged.\\n\",\n+\t     b->index, a->index);\n }\n \n /* Attempt to merge basic blocks that are potentially non-adjacent.\n@@ -660,13 +671,12 @@ merge_blocks (e, b, c, mode)\n       update_forwarder_flag (b);\n \n       if (rtl_dump_file)\n-\t{\n-\t  fprintf (rtl_dump_file, \"Merged %d and %d without moving.\\n\",\n-\t\t   b->index, c->index);\n-\t}\n+\tfprintf (rtl_dump_file, \"Merged %d and %d without moving.\\n\",\n+\t\t b->index, c->index);\n \n       return true;\n     }\n+\n   /* Otherwise we will need to move code around.  Do that only if expensive\n      transformations are allowed.  */\n   else if (mode & CLEANUP_EXPENSIVE)\n@@ -689,11 +699,13 @@ merge_blocks (e, b, c, mode)\n       for (tmp_edge = c->succ; tmp_edge; tmp_edge = tmp_edge->succ_next)\n \tif (tmp_edge->flags & EDGE_FALLTHRU)\n \t  break;\n+\n       c_has_outgoing_fallthru = (tmp_edge != NULL);\n \n       for (tmp_edge = b->pred; tmp_edge; tmp_edge = tmp_edge->pred_next)\n \tif (tmp_edge->flags & EDGE_FALLTHRU)\n \t  break;\n+\n       b_has_incoming_fallthru = (tmp_edge != NULL);\n       b_fallthru_edge = tmp_edge;\n \n@@ -714,6 +726,7 @@ merge_blocks (e, b, c, mode)\n       if (b_has_incoming_fallthru)\n \t{\n \t  basic_block bb;\n+\n \t  if (b_fallthru_edge->src == ENTRY_BLOCK_PTR)\n \t    return false;\n \t  bb = force_nonfallthru (b_fallthru_edge);\n@@ -722,9 +735,11 @@ merge_blocks (e, b, c, mode)\n \t  else\n \t    BB_SET_FLAG (b_fallthru_edge->src, BB_UPDATE_LIFE);\n \t}\n+\n       merge_blocks_move_predecessor_nojumps (b, c);\n       return true;\n     }\n+\n   return false;\n }\n \f\n@@ -825,8 +840,10 @@ insns_match_p (mode, i1, i2)\n \t\treturn true;\n \t    }\n \t}\n+\n       return false;\n     }\n+\n   return true;\n }\n \f\n@@ -857,6 +874,7 @@ flow_find_cross_jump (mode, bb1, bb2, f1, f2)\n       last1 = i1;\n       i1 = PREV_INSN (i1);\n     }\n+\n   i2 = bb2->end;\n   if (onlyjump_p (i2)\n       || (returnjump_p (i2) && !side_effects_p (PATTERN (i2))))\n@@ -873,6 +891,7 @@ flow_find_cross_jump (mode, bb1, bb2, f1, f2)\n       /* Ignore notes.  */\n       while (!active_insn_p (i1) && i1 != bb1->head)\n \ti1 = PREV_INSN (i1);\n+\n       while (!active_insn_p (i2) && i2 != bb2->head)\n \ti2 = PREV_INSN (i2);\n \n@@ -905,18 +924,16 @@ flow_find_cross_jump (mode, bb1, bb2, f1, f2)\n \t  last1 = i1, last2 = i2;\n           ninsns++;\n \t}\n+\n       i1 = PREV_INSN (i1);\n       i2 = PREV_INSN (i2);\n     }\n \n #ifdef HAVE_cc0\n-  if (ninsns)\n-    {\n-      /* Don't allow the insn after a compare to be shared by\n-\t cross-jumping unless the compare is also shared.  */\n-      if (reg_mentioned_p (cc0_rtx, last1) && ! sets_cc0_p (last1))\n-\tlast1 = afterlast1, last2 = afterlast2, ninsns--;\n-    }\n+  /* Don't allow the insn after a compare to be shared by\n+     cross-jumping unless the compare is also shared.  */\n+  if (ninsns && reg_mentioned_p (cc0_rtx, last1) && ! sets_cc0_p (last1))\n+    last1 = afterlast1, last2 = afterlast2, ninsns--;\n #endif\n \n   /* Include preceding notes and labels in the cross-jump.  One,\n@@ -926,10 +943,13 @@ flow_find_cross_jump (mode, bb1, bb2, f1, f2)\n     {\n       while (last1 != bb1->head && !active_insn_p (PREV_INSN (last1)))\n \tlast1 = PREV_INSN (last1);\n+\n       if (last1 != bb1->head && GET_CODE (PREV_INSN (last1)) == CODE_LABEL)\n \tlast1 = PREV_INSN (last1);\n+\n       while (last2 != bb2->head && !active_insn_p (PREV_INSN (last2)))\n \tlast2 = PREV_INSN (last2);\n+\n       if (last2 != bb2->head && GET_CODE (PREV_INSN (last2)) == CODE_LABEL)\n \tlast2 = PREV_INSN (last2);\n \n@@ -960,12 +980,8 @@ outgoing_edges_match (mode, bb1, bb2)\n      unconditional jump, or a fake edge to exit.  */\n   if (bb1->succ && !bb1->succ->succ_next\n       && !(bb1->succ->flags & (EDGE_COMPLEX | EDGE_FAKE)))\n-    {\n-      if (! bb2->succ || bb2->succ->succ_next\n-\t  || (bb2->succ->flags & (EDGE_COMPLEX | EDGE_FAKE)))\n-\treturn false;\n-      return true;\n-    }\n+    return (bb2->succ &&  !bb2->succ->succ_next\n+\t    && (bb2->succ->flags & (EDGE_COMPLEX | EDGE_FAKE)) == 0);\n \n   /* Match conditional jumps - this may get tricky when fallthru and branch\n      edges are crossed.  */\n@@ -996,6 +1012,7 @@ outgoing_edges_match (mode, bb1, bb2)\n          should be optimized out already.  */\n       if (FORWARDER_BLOCK_P (f1->dest))\n \tf1 = f1->dest->succ;\n+\n       if (FORWARDER_BLOCK_P (f2->dest))\n \tf2 = f2->dest->succ;\n \n@@ -1028,6 +1045,7 @@ outgoing_edges_match (mode, bb1, bb2)\n \tcode2 = reversed_comparison_code (cond2, bb2->end);\n       else\n \tcode2 = GET_CODE (cond2);\n+\n       if (code2 == UNKNOWN)\n \treturn false;\n \n@@ -1052,6 +1070,7 @@ outgoing_edges_match (mode, bb1, bb2)\n \t{\n \t  rtx note1, note2;\n \t  int prob1, prob2;\n+\n \t  note1 = find_reg_note (bb1->end, REG_BR_PROB, 0);\n \t  note2 = find_reg_note (bb2->end, REG_BR_PROB, 0);\n \n@@ -1067,6 +1086,7 @@ outgoing_edges_match (mode, bb1, bb2)\n \t      if (abs (prob1 - prob2) > REG_BR_PROB_BASE / 20)\n \t\treturn false;\n \t    }\n+\n \t  else if (note1 || note2)\n \t    return false;\n \t}\n@@ -1096,19 +1116,20 @@ outgoing_edges_match (mode, bb1, bb2)\n     {\n       if (e1->flags & EDGE_EH)\n \tnehedges1++;\n+\n       if (e2->flags & EDGE_EH)\n \tnehedges2++;\n+\n       if (e1->flags & EDGE_FALLTHRU)\n \tfallthru1 = e1;\n       if (e2->flags & EDGE_FALLTHRU)\n \tfallthru2 = e2;\n     }\n+\n   /* If number of edges of various types does not match, fail.  */\n-  if (e1 || e2)\n-    return false;\n-  if (nehedges1 != nehedges2)\n-    return false;\n-  if ((fallthru1 != 0) != (fallthru2 != 0))\n+  if (e1 || e2\n+      || nehedges1 != nehedges2\n+      || (fallthru1 != 0) != (fallthru2 != 0))\n     return false;\n \n   /* fallthru edges must be forwarded to the same destination.  */\n@@ -1118,17 +1139,21 @@ outgoing_edges_match (mode, bb1, bb2)\n \t                ? fallthru1->dest->succ->dest: fallthru1->dest);\n       basic_block d2 = (forwarder_block_p (fallthru2->dest)\n \t                ? fallthru2->dest->succ->dest: fallthru2->dest);\n+\n       if (d1 != d2)\n \treturn false;\n     }\n+\n   /* In case we do have EH edges, ensure we are in the same region.  */\n   if (nehedges1)\n     {\n       rtx n1 = find_reg_note (bb1->end, REG_EH_REGION, 0);\n       rtx n2 = find_reg_note (bb2->end, REG_EH_REGION, 0);\n+\n       if (XEXP (n1, 0) != XEXP (n2, 0))\n \treturn false;\n     }\n+\n   /* We don't need to match the rest of edges as above checks should be enought\n      to ensure that they are equivalent.  */\n   return true;\n@@ -1159,17 +1184,12 @@ try_crossjump_to_edge (mode, e1, e2)\n   if (src1->pred\n       && !src1->pred->pred_next\n       && FORWARDER_BLOCK_P (src1))\n-    {\n-      e1 = src1->pred;\n-      src1 = e1->src;\n-    }\n+    e1 = src1->pred, src1 = e1->src;\n+\n   if (src2->pred\n       && !src2->pred->pred_next\n       && FORWARDER_BLOCK_P (src2))\n-    {\n-      e2 = src2->pred;\n-      src2 = e2->src;\n-    }\n+    e2 = src2->pred, src2 = e2->src;\n \n   /* Nothing to do if we reach ENTRY, or a common source block.  */\n   if (src1 == ENTRY_BLOCK_PTR || src2 == ENTRY_BLOCK_PTR)\n@@ -1181,6 +1201,7 @@ try_crossjump_to_edge (mode, e1, e2)\n   if (FORWARDER_BLOCK_P (e1->dest)\n       && FORWARDER_BLOCK_P (e1->dest->succ->dest))\n     return false;\n+\n   if (FORWARDER_BLOCK_P (e2->dest)\n       && FORWARDER_BLOCK_P (e2->dest->succ->dest))\n     return false;\n@@ -1226,6 +1247,7 @@ try_crossjump_to_edge (mode, e1, e2)\n \n       if (FORWARDER_BLOCK_P (d))\n \td = d->succ->dest;\n+\n       for (s2 = src1->succ; ; s2 = s2->succ_next)\n \t{\n \t  basic_block d2 = s2->dest;\n@@ -1234,6 +1256,7 @@ try_crossjump_to_edge (mode, e1, e2)\n \t  if (d == d2)\n \t    break;\n \t}\n+\n       s->count += s2->count;\n \n       /* Take care to update possible forwarder blocks.  We verified\n@@ -1245,19 +1268,21 @@ try_crossjump_to_edge (mode, e1, e2)\n \t  s->dest->count += s2->count;\n \t  s->dest->frequency += EDGE_FREQUENCY (s);\n \t}\n+\n       if (FORWARDER_BLOCK_P (s2->dest))\n \t{\n \t  s2->dest->succ->count -= s2->count;\n \t  s2->dest->count -= s2->count;\n \t  s2->dest->frequency -= EDGE_FREQUENCY (s);\n \t}\n+\n       if (!redirect_to->frequency && !src1->frequency)\n \ts->probability = (s->probability + s2->probability) / 2;\n       else\n-\ts->probability =\n-\t  ((s->probability * redirect_to->frequency +\n-\t    s2->probability * src1->frequency)\n-\t   / (redirect_to->frequency + src1->frequency));\n+\ts->probability\n+\t  = ((s->probability * redirect_to->frequency +\n+\t      s2->probability * src1->frequency)\n+\t     / (redirect_to->frequency + src1->frequency));\n     }\n \n   note = find_reg_note (redirect_to->end, REG_BR_PROB, 0);\n@@ -1269,6 +1294,7 @@ try_crossjump_to_edge (mode, e1, e2)\n   /* Skip possible basic block header.  */\n   if (GET_CODE (newpos1) == CODE_LABEL)\n     newpos1 = NEXT_INSN (newpos1);\n+\n   if (GET_CODE (newpos1) == NOTE)\n     newpos1 = NEXT_INSN (newpos1);\n   last = src1->end;\n@@ -1409,7 +1435,6 @@ try_optimize_cfg (mode)\n   /* Attempt to merge blocks as made possible by edge removal.  If a block\n      has only one successor, and the successor has only one predecessor,\n      they may be combined.  */\n-\n   do\n     {\n       changed = false;\n@@ -1431,6 +1456,7 @@ try_optimize_cfg (mode)\n \t      c = BASIC_BLOCK (b->index - 1);\n \t      if (rtl_dump_file)\n \t\tfprintf (rtl_dump_file, \"Deleting block %i.\\n\", b->index);\n+\n \t      flow_delete_block (b);\n \t      changed = true;\n \t      b = c;\n@@ -1455,6 +1481,7 @@ try_optimize_cfg (mode)\n \t\t  || ! label_is_jump_target_p (b->head, b->pred->src->end)))\n \t    {\n \t      rtx label = b->head;\n+\n \t      b->head = NEXT_INSN (b->head);\n \t      delete_insn_chain (label, label);\n \t      if (rtl_dump_file)\n@@ -1475,6 +1502,7 @@ try_optimize_cfg (mode)\n \t      if (rtl_dump_file)\n \t\tfprintf (rtl_dump_file, \"Deleting fallthru block %i.\\n\",\n \t\t\t b->index);\n+\n \t      c = BASIC_BLOCK (b->index ? b->index - 1 : 1);\n \t      redirect_edge_succ_nodup (b->pred, b->succ->dest);\n \t      flow_delete_block (b);\n@@ -1554,6 +1582,7 @@ try_optimize_cfg (mode)\n   if ((mode & CLEANUP_UPDATE_LIFE) && changed_overall)\n     {\n       bool found = 0;\n+\n       blocks = sbitmap_alloc (n_basic_blocks);\n       sbitmap_zero (blocks);\n       for (i = 0; i < n_basic_blocks; i++)\n@@ -1562,12 +1591,14 @@ try_optimize_cfg (mode)\n \t    found = 1;\n \t    SET_BIT (blocks, i);\n \t  }\n+\n       if (found)\n \tupdate_life_info (blocks, UPDATE_LIFE_GLOBAL,\n \t\t\t  PROP_DEATH_NOTES | PROP_SCAN_DEAD_CODE\n \t\t\t  | PROP_KILL_DEAD_CODE);\n       sbitmap_free (blocks);\n     }\n+\n   for (i = 0; i < n_basic_blocks; i++)\n     BASIC_BLOCK (i)->aux = NULL;\n "}, {"sha": "14f08eb39ef5ea70b2941b225facdf2cb746973e", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 121, "deletions": 150, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0d23589fe634ef3b7986a5dc0e389abfe4c917/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0d23589fe634ef3b7986a5dc0e389abfe4c917/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=5f0d23589fe634ef3b7986a5dc0e389abfe4c917", "patch": "@@ -1,22 +1,22 @@\n /* Basic block reordering routines for the GNU compiler.\n    Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n \n-   This file is part of GCC.\n+This file is part of GCC.\n \n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 2, or (at your option)\n-   any later version.\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n \n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n \n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING.  If not, write to the Free\n-   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-   02111-1307, USA.  */\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -30,9 +30,7 @@\n #include \"cfglayout.h\"\n \n /* The contents of the current function definition are allocated\n-   in this obstack, and all are freed at the end of the function.\n-   For top-level functions, this is temporary_obstack.\n-   Separate obstacks are made for nested functions.  */\n+   in this obstack, and all are freed at the end of the function.  */\n \n extern struct obstack flow_obstack;\n \n@@ -126,7 +124,7 @@ skip_insns_after_block (bb)\n   if (bb->index + 1 != n_basic_blocks)\n     next_head = BASIC_BLOCK (bb->index + 1)->head;\n \n-  for (last_insn = insn = bb->end; (insn = NEXT_INSN (insn)); )\n+  for (last_insn = insn = bb->end; (insn = NEXT_INSN (insn)) != 0; )\n     {\n       if (insn == next_head)\n \tbreak;\n@@ -172,30 +170,30 @@ skip_insns_after_block (bb)\n \n       break;\n     }\n-  /* It is possible to hit contradicting sequence.  For instance:\n+\n+  /* It is possible to hit contradictory sequence.  For instance:\n     \n      jump_insn\n      NOTE_INSN_LOOP_BEG\n      barrier\n \n-     Where barrier belongs to jump_insn, but the note does not.\n-     This can be created by removing the basic block originally\n-     following NOTE_INSN_LOOP_BEG.\n+     Where barrier belongs to jump_insn, but the note does not.  This can be\n+     created by removing the basic block originally following\n+     NOTE_INSN_LOOP_BEG.  In such case reorder the notes.  */\n \n-     In such case reorder the notes.  */\n   for (insn = last_insn; insn != bb->end; insn = prev)\n     {\n-    prev = PREV_INSN (insn);\n-    if (GET_CODE (insn) == NOTE)\n-      switch (NOTE_LINE_NUMBER (insn))\n-        {\n+      prev = PREV_INSN (insn);\n+      if (GET_CODE (insn) == NOTE)\n+\tswitch (NOTE_LINE_NUMBER (insn))\n+\t  {\n           case NOTE_INSN_LOOP_END:\n           case NOTE_INSN_BLOCK_END:\n           case NOTE_INSN_DELETED:\n           case NOTE_INSN_DELETED_LABEL:\n-    \tcontinue;\n+\t    continue;\n           default:\n-    \treorder_insns (insn, insn, last_insn);\n+\t    reorder_insns (insn, insn, last_insn);\n         }\n     }\n \n@@ -213,8 +211,7 @@ label_for_bb (bb)\n   if (GET_CODE (label) != CODE_LABEL)\n     {\n       if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Emitting label for block %d\\n\",\n-\t\t bb->index);\n+\tfprintf (rtl_dump_file, \"Emitting label for block %d\\n\", bb->index);\n \n       label = block_label (bb);\n       if (bb->head == PREV_INSN (RBI (bb)->eff_head))\n@@ -233,7 +230,7 @@ record_effective_endpoints ()\n   rtx next_insn = get_insns ();\n   int i;\n   \n-  for (i = 0; i < n_basic_blocks; ++i)\n+  for (i = 0; i < n_basic_blocks; i++)\n     {\n       basic_block bb = BASIC_BLOCK (i);\n       rtx end;\n@@ -243,32 +240,33 @@ record_effective_endpoints ()\n       RBI (bb)->eff_end = end;\n       next_insn = NEXT_INSN (end);\n     }\n+\n   function_tail_eff_head = next_insn;\n }\n \f\n+/* Return the next NOTE_INSN_BASIC_BLOCK after X.  */\n+\n static rtx\n get_next_bb_note (x)\n      rtx x;\n {\n-  while (x)\n-    {\n-      if (NOTE_INSN_BASIC_BLOCK_P (x))\n-\treturn x;\n-      x = NEXT_INSN (x);\n-    }\n+  for (; x; x = NEXT_INSN (x))\n+    if (NOTE_INSN_BASIC_BLOCK_P (x))\n+      return x;\n+\n   return NULL;\n }\n \n+/* Return the fist NOTE_INSN_BASIC_BLOCK before X.  */\n+\n static rtx\n get_prev_bb_note (x)\n      rtx x;\n {\n-  while (x)\n-    {\n-      if (NOTE_INSN_BASIC_BLOCK_P (x))\n-\treturn x;\n-      x = PREV_INSN (x);\n-    }\n+  for (; x; x = PREV_INSN (x))\n+    if (NOTE_INSN_BASIC_BLOCK_P (x))\n+      return x;\n+\n   return NULL;\n }\n \n@@ -313,6 +311,7 @@ relate_bbs_with_scopes (s)\n \t  bbnote = get_next_bb_note (s->note_beg);\n \t  if (! bbnote)\n \t    abort ();\n+\n \t  if (NOTE_BASIC_BLOCK (bbnote) == s->bb_end)\n \t    {\n \t      bbs_spanned = 0;\n@@ -335,6 +334,7 @@ relate_bbs_with_scopes (s)\n \t  bbnote = get_prev_bb_note (s->note_end);\n \t  if (! bbnote)\n \t    abort ();\n+\n \t  if (NOTE_BASIC_BLOCK (bbnote) == s->bb_beg)\n \t    {\n \t      bbs_spanned = 0;\n@@ -357,16 +357,15 @@ relate_bbs_with_scopes (s)\n \tbbs_spanned = 0;\n       else\n \t{\n-          rtx x1, x2;\n \t  /* Both notes are outside of any bbs. This implies that all the\n \t     basic blocks spanned by the pair of notes are contained in\n              this scope. \n \t     There is a degenerate case to consider. If the notes do not\n \t     span any basic blocks, then it is an empty scope that can\n \t     safely be deleted or ignored. Mark these with level = -1.  */\n+\t  rtx x1 = get_next_bb_note (s->note_beg);\n+\t  rtx x2 = get_prev_bb_note (s->note_end);\n \n-\t  x1 = get_next_bb_note (s->note_beg);\n-\t  x2 = get_prev_bb_note (s->note_end);\n \t  if (! (x1 && x2))\n \t    {\n \t      s->level = -1; \n@@ -418,6 +417,7 @@ make_new_scope (level, note)\n      rtx note;\n {\n   scope new_scope = xcalloc (1, sizeof (struct scope_def));\n+\n   new_scope->level = level;\n   new_scope->note_beg = note;\n   return new_scope;\n@@ -442,6 +442,7 @@ build_scope_forest (forest)\n   root = NULL;\n   curr_bb = NULL;\n   bbi = 0;\n+\n   for (x = get_insns (); x; x = NEXT_INSN (x))\n     {\n       if (bbi < n_basic_blocks && x == BASIC_BLOCK (bbi)->head)\n@@ -454,8 +455,10 @@ build_scope_forest (forest)\n \t      if (root)\n \t\t{\n \t\t  scope new_scope;\n+\n \t\t  if (! curr_scope)\n \t\t    abort();\n+\n \t\t  level++;\n \t\t  new_scope = make_new_scope (level, x);\n \t\t  new_scope->outer = curr_scope;\n@@ -471,17 +474,20 @@ build_scope_forest (forest)\n \t\t      curr_scope->inner_last = new_scope;\n \t\t    }\n \t\t  curr_scope = curr_scope->inner_last;\n+\n \t\t}\n \t      else\n \t\t{\n \t\t  int ntrees = forest->num_trees;\n+\n \t\t  level++;\n \t          curr_scope = make_new_scope (level, x);\n \t\t  root = curr_scope;\n \t\t  forest->trees = xrealloc (forest->trees,\n \t\t\t\t\t    sizeof (scope) * (ntrees + 1));\n \t\t  forest->trees[forest->num_trees++] = root;\n \t\t}\n+\n \t      curr_scope->bb_beg = curr_bb;\n \t    }\n \t  else if (NOTE_LINE_NUMBER (x) == NOTE_INSN_BLOCK_END)\n@@ -493,22 +499,21 @@ build_scope_forest (forest)\n \t      if (level == -1)\n \t\troot = NULL;\n \t    }\n-\t} /* if note */\n+\t}\n \n       if (curr_bb && curr_bb->end == x)\n \t{\n \t  curr_bb = NULL;\n \t  bbi++;\n \t}\n-\n-    } /* for */\n+    } \n \n   for (i = 0; i < forest->num_trees; i++)\n     relate_bbs_with_scopes (forest->trees[i]);\n }\n \f\n-/* Remove all the NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes from\n-   the insn chain.  */\n+/* Remove all NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes from the insn\n+   chain.  */\n \n static void\n remove_scope_notes ()\n@@ -572,7 +577,6 @@ insert_intra_1 (s, ip, bb)\n     }\n }\n \n-\n /* Insert NOTE_INSN_BLOCK_END notes and NOTE_INSN_BLOCK_BEG notes for\n    scopes that are contained within BB.  */\n \n@@ -598,7 +602,6 @@ insert_intra_bb_scope_notes (bb)\n     }\n }\n \n-\n /* Given two consecutive basic blocks BB1 and BB2 with different scopes,\n    insert NOTE_INSN_BLOCK_END notes after BB1 and NOTE_INSN_BLOCK_BEG\n    notes before BB2 such that the notes are correctly balanced. If BB1 or\n@@ -619,8 +622,10 @@ insert_inter_bb_scope_notes (bb1, bb2)\n     {\n       scope s1 = RBI (bb1)->scope;\n       scope s2 = RBI (bb2)->scope;\n+\n       if (! s1 && ! s2)\n \treturn;\n+\n       if (! s1)\n \tbb1 = NULL;\n       else if (! s2)\n@@ -632,10 +637,9 @@ insert_inter_bb_scope_notes (bb1, bb2)\n     {\n       scope s1 = RBI (bb1)->scope;\n       scope s2 = RBI (bb2)->scope;\n+\n       while (s1 != s2)\n \t{\n-          if (! (s1 && s2))\n-\t    abort ();\n \t  if (s1->level > s2->level)\n \t    s1 = s1->outer;\n \t  else if (s2->level > s1->level)\n@@ -646,6 +650,7 @@ insert_inter_bb_scope_notes (bb1, bb2)\n \t      s2 = s2->outer;\n \t    }\n \t}\n+\n       com = s1;\n     }\n   else\n@@ -655,36 +660,32 @@ insert_inter_bb_scope_notes (bb1, bb2)\n   if (bb1)\n     {\n       rtx end = bb1->end;\n+      scope s;\n \n-      scope s = RBI (bb1)->scope;\n       ip = RBI (bb1)->eff_end;\n-      while (s != com)\n-\t{\n-\t  if (NOTE_BLOCK (s->note_beg))\n-\t    {  \n-\t      ip = emit_note_after (NOTE_INSN_BLOCK_END, ip);\n-\t      NOTE_BLOCK (ip) = NOTE_BLOCK (s->note_end);\n-\t    }\n-\t  s = s->outer;\n-\t}\n+      for (s = RBI (bb1)->scope; s != com; s = s->outer)\n+\tif (NOTE_BLOCK (s->note_beg))\n+\t  {  \n+\t    ip = emit_note_after (NOTE_INSN_BLOCK_END, ip);\n+\t    NOTE_BLOCK (ip) = NOTE_BLOCK (s->note_end);\n+\t  }\n+\n       /* Emitting note may move the end of basic block to unwanted place.  */\n       bb1->end = end;\n     }\n \n   /* Open scopes.  */\n   if (bb2)\n     {\n-      scope s = RBI (bb2)->scope;\n+      scope s;\n+\n       ip = bb2->head;\n-      while (s != com)\n-\t{\n-\t  if (NOTE_BLOCK (s->note_beg))\n-\t    {  \n-\t      ip = emit_note_before (NOTE_INSN_BLOCK_BEG, ip);\n-\t      NOTE_BLOCK (ip) = NOTE_BLOCK (s->note_beg);\n-\t    }\n-\t  s = s->outer;\n-\t}\n+      for (s = RBI (bb2)->scope; s != com; s = s->outer)\n+\tif (NOTE_BLOCK (s->note_beg))\n+\t  {  \n+\t    ip = emit_note_before (NOTE_INSN_BLOCK_BEG, ip);\n+\t    NOTE_BLOCK (ip) = NOTE_BLOCK (s->note_beg);\n+\t  }\n     }\n }\n \n@@ -709,6 +710,7 @@ rebuild_scope_notes (forest)\n     {\n       basic_block bb1 = BASIC_BLOCK (i);\n       basic_block bb2 = BASIC_BLOCK (i + 1);\n+\n       if (RBI (bb1)->scope != RBI (bb2)->scope)\n \tinsert_inter_bb_scope_notes (bb1, bb2);\n       insert_intra_bb_scope_notes (bb1);\n@@ -745,6 +747,7 @@ free_scope_forest (forest)\n     scope_forest_info *forest;\n {\n   int i;\n+\n   for (i = 0; i < forest->num_trees; i++)\n     free_scope_forest_1 (forest->trees[i]);\n }\n@@ -755,15 +758,15 @@ void\n dump_scope_forest (forest)\n     scope_forest_info *forest;\n {\n+  int i;\n+\n   if (forest->num_trees == 0)\n     fprintf (stderr, \"\\n< Empty scope forest >\\n\");\n   else\n-    {\n-      int i;\n-      fprintf (stderr, \"\\n< Scope forest >\\n\");\n-      for (i = 0; i < forest->num_trees; i++)\n-\tdump_scope_forest_1 (forest->trees[i], 0);\n-    }\n+    fprintf (stderr, \"\\n< Scope forest >\\n\");\n+\n+  for (i = 0; i < forest->num_trees; i++)\n+    dump_scope_forest_1 (forest->trees[i], 0);\n }\n \n /* Recursive portion of dump_scope_forest.  */\n@@ -813,33 +816,28 @@ fixup_reorder_chain ()\n   /* First do the bulk reordering -- rechain the blocks without regard to\n      the needed changes to jumps and labels.  */\n \n-  last_bb = BASIC_BLOCK (0);\n-  bb = RBI (last_bb)->next;\n-  index = 1;\n-  while (bb)\n+  for (last_bb = BASIC_BLOCK (0), bb = RBI (last_bb)->next, index = 1;\n+       bb != 0;\n+       last_bb = bb, bb = RBI (bb)->next, index++)\n     {\n       rtx last_e = RBI (last_bb)->eff_end;\n       rtx curr_h = RBI (bb)->eff_head;\n \n       NEXT_INSN (last_e) = curr_h;\n       PREV_INSN (curr_h) = last_e;\n-\n-      last_bb = bb;\n-      bb = RBI (bb)->next;\n-      index++;\n     }\n \n   if (index != n_basic_blocks)\n     abort ();\n \n   insn = RBI (last_bb)->eff_end;\n-\n   NEXT_INSN (insn) = function_tail_eff_head;\n   if (function_tail_eff_head)\n     PREV_INSN (function_tail_eff_head) = insn;\n \n   while (NEXT_INSN (insn))\n     insn = NEXT_INSN (insn);\n+\n   set_last_insn (insn);\n #ifdef ENABLE_CHECKING\n   verify_insn_chain ();\n@@ -884,6 +882,7 @@ fixup_reorder_chain ()\n \t      if (RBI (bb)->next != e_taken->dest)\n \t\t{\n \t\t  rtx note = find_reg_note (bb_end_insn, REG_BR_PROB, 0);\n+\n \t\t  if (note\n \t\t      && INTVAL (XEXP (note, 0)) < REG_BR_PROB_BASE / 2\n \t\t      && invert_jump (bb_end_insn,\n@@ -913,6 +912,7 @@ fixup_reorder_chain ()\n \t\t 99% case, there should not have been a fallthru edge.  */\n \t      if (! e_fall)\n \t\tcontinue;\n+\n #ifdef CASE_DROPS_THROUGH\n \t      /* Except for VAX.  Since we didn't have predication for the\n \t\t tablejump, the fallthru block should not have moved.  */\n@@ -936,15 +936,13 @@ fixup_reorder_chain ()\n \t  if (RBI (bb)->next == e_fall->dest)\n \t    continue;\n \n-\t  /* An fallthru to exit block.  */\n+\t  /* A fallthru to exit block.  */\n \t  if (!RBI (bb)->next && e_fall->dest == EXIT_BLOCK_PTR)\n \t    continue;\n \t}\n \n       /* We got here if we need to add a new jump insn.  */\n-\n       nb = force_nonfallthru (e_fall);\n-\n       if (nb)\n \t{\n \t  alloc_aux_for_block (nb, sizeof (struct reorder_block_def));\n@@ -965,18 +963,17 @@ fixup_reorder_chain ()\n \n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \"Reordered sequence:\\n\");\n-  while (bb)\n+\n+  for (; bb; bb = RBI (bb)->next, index++)\n     {\n       if (rtl_dump_file)\n \tfprintf (rtl_dump_file, \" %i %sbb %i freq %i\\n\", index,\n \t\t bb->index >= old_n_basic_blocks ? \"compensation \" : \"\",\n \t\t bb->index,\n \t   \t bb->frequency);\n+\n       bb->index = index;\n       BASIC_BLOCK (index) = bb;\n-\n-      bb = RBI (bb)->next;\n-      index++;\n     }\n }\n \f\n@@ -989,62 +986,31 @@ fixup_reorder_chain ()\n void\n verify_insn_chain ()\n {\n-  rtx x,\n-      prevx,\n-      nextx;\n-  int insn_cnt1,\n-      insn_cnt2;\n-\n-  prevx = NULL;\n-  insn_cnt1 = 1;\n-  for (x = get_insns (); x; x = NEXT_INSN (x))\n-    {\n-      if (PREV_INSN (x) != prevx)\n-\t{\n-\t  fprintf (stderr, \"Forward traversal: insn chain corrupt.\\n\");\n-\t  fprintf (stderr, \"previous insn:\\n\");\n-\t  debug_rtx (prevx);\n-\t  fprintf (stderr, \"current insn:\\n\");\n-\t  debug_rtx (x);\n-\t  abort ();\n-\t}\n-      ++insn_cnt1;\n-      prevx = x;\n-    }\n+  rtx x, prevx, nextx;\n+  int insn_cnt1, insn_cnt2;\n \n-  if (prevx != get_last_insn ())\n-    {\n-      fprintf (stderr, \"last_insn corrupt.\\n\");\n+  for (prevx = NULL, insn_cnt1 = 1, x = get_insns ();\n+       x != 0;\n+       prevx = x, insn_cnt1++, x = NEXT_INSN (x))\n+    if (PREV_INSN (x) != prevx)\n       abort ();\n-    }\n \n-  nextx = NULL;\n-  insn_cnt2 = 1;\n-  for (x = get_last_insn (); x; x = PREV_INSN (x))\n-    {\n-      if (NEXT_INSN (x) != nextx)\n-\t{\n-\t  fprintf (stderr, \"Reverse traversal: insn chain corrupt.\\n\");\n-\t  fprintf (stderr, \"current insn:\\n\");\n-\t  debug_rtx (x);\n-\t  fprintf (stderr, \"next insn:\\n\");\n-\t  debug_rtx (nextx);\n-\t  abort ();\n-\t}\n-      ++insn_cnt2;\n-      nextx = x;\n-    }\n+  if (prevx != get_last_insn ())\n+    abort ();\n \n-  if (insn_cnt1 != insn_cnt2)\n-    {\n-      fprintf (stderr, \"insn_cnt1 (%d) not equal to insn_cnt2 (%d).\\n\",\n-\t       insn_cnt1, insn_cnt2);\n+  for (nextx = NULL, insn_cnt2 = 1, x = get_last_insn ();\n+       x != 0;\n+       nextx = x, insn_cnt2++, x = PREV_INSN (x))\n+    if (NEXT_INSN (x) != nextx)\n       abort ();\n-    }\n+\n+  if (insn_cnt1 != insn_cnt2)\n+    abort ();\n }\n \n-/* The block falling through to exit must be the last one in the\n-   reordered chain.  Ensure that this condition is met.  */\n+/* The block falling through to exit must be the last one in the reordered\n+   chain.  Ensure it is.  */\n+\n static void\n fixup_fallthru_exit_predecessor ()\n {\n@@ -1054,21 +1020,25 @@ fixup_fallthru_exit_predecessor ()\n   for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n     if (e->flags & EDGE_FALLTHRU)\n       bb = e->src;\n+\n   if (bb && RBI (bb)->next)\n     {\n       basic_block c = BASIC_BLOCK (0);\n+\n       while (RBI (c)->next != bb)\n \tc = RBI (c)->next;\n+\n       RBI (c)->next = RBI (bb)->next;\n       while (RBI (c)->next)\n \tc = RBI (c)->next;\n+\n       RBI (c)->next = bb;\n       RBI (bb)->next = NULL;\n     }\n }\n \f\n-/* Main entry point to this module - initialize the datastructures for\n-   CFG layout changes.  */\n+/* Main entry point to this module: initialize the datastructures for CFG\n+   layout changes.  */\n \n void\n cfg_layout_initialize ()\n@@ -1081,14 +1051,15 @@ cfg_layout_initialize ()\n   record_effective_endpoints ();\n }\n \n-/* Finalize the changes - reorder insn list according to the sequence,\n-   enter compensation code, rebuild scope forest.  */\n+/* Finalize the changes: reorder insn list according to the sequence, enter\n+   compensation code, rebuild scope forest.  */\n \n void\n cfg_layout_finalize ()\n {\n   fixup_fallthru_exit_predecessor ();\n   fixup_reorder_chain ();\n+\n #ifdef ENABLE_CHECKING\n   verify_insn_chain ();\n #endif"}, {"sha": "b4b8eb73fbd8730c203774b36f0a84186e634e3a", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 93, "deletions": 111, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0d23589fe634ef3b7986a5dc0e389abfe4c917/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0d23589fe634ef3b7986a5dc0e389abfe4c917/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=5f0d23589fe634ef3b7986a5dc0e389abfe4c917", "patch": "@@ -31,11 +31,13 @@ static int flow_loop_nested_p\t\tPARAMS ((struct loop *,\n static int flow_loop_entry_edges_find\tPARAMS ((basic_block, const sbitmap,\n \t\t\t\t\t\t edge **));\n static int flow_loop_exit_edges_find\tPARAMS ((const sbitmap, edge **));\n-static int flow_loop_nodes_find\tPARAMS ((basic_block, basic_block, sbitmap));\n-static void flow_loop_pre_header_scan PARAMS ((struct loop *));\n+static int flow_loop_nodes_find\t\tPARAMS ((basic_block, basic_block,\n+\t\t\t\t\t\t sbitmap));\n+static void flow_loop_pre_header_scan\tPARAMS ((struct loop *));\n static basic_block flow_loop_pre_header_find PARAMS ((basic_block,\n \t\t\t\t\t\t      const sbitmap *));\n-static void flow_loop_tree_node_add\tPARAMS ((struct loop *, struct loop *));\n+static void flow_loop_tree_node_add\tPARAMS ((struct loop *,\n+\t\t\t\t\t\t struct loop *));\n static void flow_loops_tree_build\tPARAMS ((struct loops *));\n static int flow_loop_level_compute\tPARAMS ((struct loop *, int));\n static int flow_loops_level_compute\tPARAMS ((struct loops *));\n@@ -68,14 +70,17 @@ flow_loops_cfg_dump (loops, file)\n       fputs (\";; DFS order: \", file);\n       for (i = 0; i < n_basic_blocks; i++)\n \tfprintf (file, \"%d \", loops->cfg.dfs_order[i]);\n+\n       fputs (\"\\n\", file);\n     }\n+\n   /* Dump the reverse completion node order.  */\n   if (loops->cfg.rc_order)\n     {\n       fputs (\";; RC order: \", file);\n       for (i = 0; i < n_basic_blocks; i++)\n \tfprintf (file, \"%d \", loops->cfg.rc_order[i]);\n+\n       fputs (\"\\n\", file);\n     }\n }\n@@ -107,12 +112,10 @@ flow_loop_dump (loop, file, loop_dump_aux, verbose)\n     fprintf (file, \";;\\n;; Loop %d (%d to %d):%s%s\\n\",\n \t    loop->num, INSN_UID (loop->first->head),\n \t    INSN_UID (loop->last->end),\n-\t    loop->shared ? \" shared\" : \"\",\n-\t    loop->invalid ? \" invalid\" : \"\");\n+\t    loop->shared ? \" shared\" : \"\", loop->invalid ? \" invalid\" : \"\");\n   else\n     fprintf (file, \";;\\n;; Loop %d:%s%s\\n\", loop->num,\n-\t     loop->shared ? \" shared\" : \"\",\n-\t     loop->invalid ? \" invalid\" : \"\");\n+\t     loop->shared ? \" shared\" : \"\", loop->invalid ? \" invalid\" : \"\");\n \n   fprintf (file, \";;  header %d, latch %d, pre-header %d, first %d, last %d\\n\",\n \t   loop->header->index, loop->latch->index,\n@@ -125,14 +128,17 @@ flow_loop_dump (loop, file, loop_dump_aux, verbose)\n   if (loop->pre_header_edges)\n     flow_edge_list_print (\";;  pre-header edges\", loop->pre_header_edges,\n \t\t\t  loop->num_pre_header_edges, file);\n+\n   flow_edge_list_print (\";;  entry edges\", loop->entry_edges,\n \t\t\tloop->num_entries, file);\n   fprintf (file, \";;  %d\", loop->num_nodes);\n   flow_nodes_print (\" nodes\", loop->nodes, file);\n   flow_edge_list_print (\";;  exit edges\", loop->exit_edges,\n \t\t\tloop->num_exits, file);\n+\n   if (loop->exits_doms)\n     flow_nodes_print (\";;  exit doms\", loop->exits_doms, file);\n+\n   if (loop_dump_aux)\n     loop_dump_aux (loop, file, verbose);\n }\n@@ -147,49 +153,42 @@ flow_loops_dump (loops, file, loop_dump_aux, verbose)\n      void (*loop_dump_aux) PARAMS((const struct loop *, FILE *, int));\n      int verbose;\n {\n-  int i;\n+  int i, j;\n   int num_loops;\n \n   num_loops = loops->num;\n   if (! num_loops || ! file)\n     return;\n \n-  fprintf (file, \";; %d loops found, %d levels\\n\",\n-\t   num_loops, loops->levels);\n-\n+  fprintf (file, \";; %d loops found, %d levels\\n\", num_loops, loops->levels);\n   for (i = 0; i < num_loops; i++)\n     {\n       struct loop *loop = &loops->array[i];\n \n       flow_loop_dump (loop, file, loop_dump_aux, verbose);\n-\n       if (loop->shared)\n-\t{\n-\t  int j;\n-\n-\t  for (j = 0; j < i; j++)\n-\t    {\n-\t      struct loop *oloop = &loops->array[j];\n-\n-\t      if (loop->header == oloop->header)\n-\t\t{\n-\t\t  int disjoint;\n-\t\t  int smaller;\n-\n-\t\t  smaller = loop->num_nodes < oloop->num_nodes;\n-\n-\t\t  /* If the union of LOOP and OLOOP is different than\n-\t\t     the larger of LOOP and OLOOP then LOOP and OLOOP\n-\t\t     must be disjoint.  */\n-\t\t  disjoint = ! flow_loop_nested_p (smaller ? loop : oloop,\n-\t\t\t\t\t\t   smaller ? oloop : loop);\n-\t\t  fprintf (file,\n-\t\t\t   \";; loop header %d shared by loops %d, %d %s\\n\",\n-\t\t\t   loop->header->index, i, j,\n-\t\t\t   disjoint ? \"disjoint\" : \"nested\");\n-\t\t}\n-\t    }\n-\t}\n+\tfor (j = 0; j < i; j++)\n+\t  {\n+\t    struct loop *oloop = &loops->array[j];\n+\n+\t    if (loop->header == oloop->header)\n+\t      {\n+\t\tint disjoint;\n+\t\tint smaller;\n+\n+\t\tsmaller = loop->num_nodes < oloop->num_nodes;\n+\n+\t\t/* If the union of LOOP and OLOOP is different than\n+\t\t   the larger of LOOP and OLOOP then LOOP and OLOOP\n+\t\t   must be disjoint.  */\n+\t\tdisjoint = ! flow_loop_nested_p (smaller ? loop : oloop,\n+\t\t\t\t\t\t smaller ? oloop : loop);\n+\t\tfprintf (file,\n+\t\t\t \";; loop header %d shared by loops %d, %d %s\\n\",\n+\t\t\t loop->header->index, i, j,\n+\t\t\t disjoint ? \"disjoint\" : \"nested\");\n+\t      }\n+\t  }\n     }\n \n   if (verbose)\n@@ -225,11 +224,13 @@ flow_loops_free (loops)\n \t  if (loop->exits_doms)\n \t    sbitmap_free (loop->exits_doms);\n \t}\n+\n       free (loops->array);\n       loops->array = NULL;\n \n       if (loops->cfg.dom)\n \tsbitmap_vector_free (loops->cfg.dom);\n+\n       if (loops->cfg.dfs_order)\n \tfree (loops->cfg.dfs_order);\n \n@@ -394,42 +395,33 @@ static void\n flow_loop_pre_header_scan (loop)\n      struct loop *loop;\n {\n-  int num = 0;\n+  int num;\n   basic_block ebb;\n+  edge e;\n \n   loop->num_pre_header_edges = 0;\n-\n   if (loop->num_entries != 1)\n-     return;\n+    return;\n \n   ebb = loop->entry_edges[0]->src;\n+  if (ebb == ENTRY_BLOCK_PTR)\n+    return;\n \n-  if (ebb != ENTRY_BLOCK_PTR)\n-    {\n-      edge e;\n-\n-      /* Count number of edges along trace from loop header to\n-\t root of pre-header extended basic block.  Usually this is\n-\t only one or two edges.  */\n-      num++;\n-      while (ebb->pred->src != ENTRY_BLOCK_PTR && ! ebb->pred->pred_next)\n-\t{\n-\t  ebb = ebb->pred->src;\n-\t  num++;\n-\t}\n-\n-      loop->pre_header_edges = (edge *) xmalloc (num * sizeof (edge *));\n-      loop->num_pre_header_edges = num;\n-\n-      /* Store edges in order that they are followed.   The source\n-\t of the first edge is the root node of the pre-header extended\n-\t basic block and the destination of the last last edge is\n-\t the loop header.  */\n-      for (e = loop->entry_edges[0]; num; e = e->src->pred)\n-\t{\n-\t  loop->pre_header_edges[--num] = e;\n-\t}\n-    }\n+  /* Count number of edges along trace from loop header to\n+     root of pre-header extended basic block.  Usually this is\n+     only one or two edges.  */\n+  for (num = 1; ebb->pred->src != ENTRY_BLOCK_PTR && ! ebb->pred->pred_next;\n+       num++)\n+    ebb = ebb->pred->src;\n+\n+  loop->pre_header_edges = (edge *) xmalloc (num * sizeof (edge *));\n+  loop->num_pre_header_edges = num;\n+\n+  /* Store edges in order that they are followed.  The source of the first edge\n+     is the root node of the pre-header extended basic block and the\n+     destination of the last last edge is the loop header.  */\n+  for (e = loop->entry_edges[0]; num; e = e->src->pred)\n+    loop->pre_header_edges[--num] = e;\n }\n \n /* Return the block for the pre-header of the loop with header\n@@ -465,6 +457,7 @@ flow_loop_pre_header_find (header, dom)\n \t    }\n \t}\n     }\n+\n   return pre_header;\n }\n \n@@ -485,16 +478,13 @@ flow_loop_tree_node_add (prevloop, loop)\n       return;\n     }\n \n-  while (prevloop->outer)\n-    {\n-      if (flow_loop_nested_p (prevloop->outer, loop))\n-\t{\n-\t  prevloop->next = loop;\n-\t  loop->outer = prevloop->outer;\n-\t  return;\n-\t}\n-      prevloop = prevloop->outer;\n-    }\n+  for (; prevloop->outer; prevloop = prevloop->outer)\n+    if (flow_loop_nested_p (prevloop->outer, loop))\n+      {\n+\tprevloop->next = loop;\n+\tloop->outer = prevloop->outer;\n+\treturn;\n+      }\n \n   prevloop->next = loop;\n   loop->outer = NULL;\n@@ -517,7 +507,8 @@ flow_loops_tree_build (loops)\n      Since we used a depth first search this should be the\n      outermost loop.  */\n   loops->tree_root = &loops->array[0];\n-  loops->tree_root->outer = loops->tree_root->inner = loops->tree_root->next = NULL;\n+  loops->tree_root->outer = loops->tree_root->inner\n+    = loops->tree_root->next = NULL;\n \n   /* Add the remaining loops to the tree.  */\n   for (i = 1; i < num_loops; i++)\n@@ -546,13 +537,11 @@ flow_loop_level_compute (loop, depth)\n      itself).  */\n   for (inner = loop->inner; inner; inner = inner->next)\n     {\n-      int ilevel;\n-\n-      ilevel = flow_loop_level_compute (inner, depth + 1) + 1;\n+      int ilevel = flow_loop_level_compute (inner, depth + 1) + 1;\n \n-      if (ilevel > level)\n-\tlevel = ilevel;\n+      level = MAX (ilevel, level);\n     }\n+\n   loop->level = level;\n   loop->depth = depth;\n   return level;\n@@ -566,17 +555,17 @@ static int\n flow_loops_level_compute (loops)\n      struct loops *loops;\n {\n+  int levels = 0;\n   struct loop *loop;\n   int level;\n-  int levels = 0;\n \n   /* Traverse all the outer level loops.  */\n   for (loop = loops->tree_root; loop; loop = loop->next)\n     {\n       level = flow_loop_level_compute (loop, 1);\n-      if (level > levels)\n-\tlevels = level;\n+      levels = MAX (levels, level);\n     }\n+\n   return levels;\n }\n \n@@ -594,23 +583,15 @@ flow_loop_scan (loops, loop, flags)\n     flags |= LOOP_EXIT_EDGES;\n \n   if (flags & LOOP_ENTRY_EDGES)\n-    {\n-      /* Find edges which enter the loop header.\n-\t Note that the entry edges should only\n-\t enter the header of a natural loop.  */\n-      loop->num_entries\n-\t= flow_loop_entry_edges_find (loop->header,\n-\t\t\t\t      loop->nodes,\n-\t\t\t\t      &loop->entry_edges);\n-    }\n+    /* Find edges which enter the loop header.  Note that the entry edges\n+       should only enter the header of a natural loop.  */\n+    loop->num_entries = flow_loop_entry_edges_find (loop->header, loop->nodes,\n+\t\t\t\t\t\t    &loop->entry_edges);\n \n   if (flags & LOOP_EXIT_EDGES)\n-    {\n-      /* Find edges which exit the loop.  */\n-      loop->num_exits\n-\t= flow_loop_exit_edges_find (loop->nodes,\n-\t\t\t\t     &loop->exit_edges);\n-    }\n+    /* Find edges which exit the loop.  */\n+    loop->num_exits\n+      = flow_loop_exit_edges_find (loop->nodes, &loop->exit_edges);\n \n   if (flags & LOOP_EXITS_DOMS)\n     {\n@@ -640,13 +621,14 @@ flow_loop_scan (loops, loop, flags)\n \t the loop pre-header.  */\n       flow_loop_pre_header_scan (loop);\n     }\n+\n   return 1;\n }\n \n-/* Find all the natural loops in the function and save in LOOPS structure\n-   and recalculate loop_depth information in basic block structures.\n-   FLAGS controls which loop information is collected.\n-   Return the number of natural loops found.  */\n+/* Find all the natural loops in the function and save in LOOPS structure and\n+   recalculate loop_depth information in basic block structures.  FLAGS\n+   controls which loop information is collected.  Return the number of natural\n+   loops found.  */\n \n int\n flow_loops_find (loops, flags)\n@@ -668,7 +650,7 @@ flow_loops_find (loops, flags)\n   if (! (flags & LOOP_TREE))\n     abort ();\n \n-  memset (loops, 0, sizeof (*loops));\n+  memset (loops, 0, sizeof *loops);\n \n   /* Taking care of this degenerate case makes the rest of\n      this code simpler.  */\n@@ -684,7 +666,6 @@ flow_loops_find (loops, flags)\n \n   /* Count the number of loop edges (back edges).  This should be the\n      same as the number of natural loops.  */\n-\n   num_loops = 0;\n   for (b = 0; b < n_basic_blocks; b++)\n     {\n@@ -810,9 +791,7 @@ flow_loops_find (loops, flags)\n       sbitmap_free (headers);\n     }\n   else\n-    {\n-      sbitmap_vector_free (dom);\n-    }\n+    sbitmap_vector_free (dom);\n \n   loops->num = num_loops;\n \n@@ -828,6 +807,7 @@ flow_loops_find (loops, flags)\n \n /* Update the information regarding the loops in the CFG\n    specified by LOOPS.  */\n+\n int\n flow_loops_update (loops, flags)\n      struct loops *loops;\n@@ -850,5 +830,7 @@ flow_loop_outside_edge_p (loop, e)\n {\n   if (e->dest != loop->header)\n     abort ();\n-  return (e->src == ENTRY_BLOCK_PTR) || ! TEST_BIT (loop->nodes, e->src->index);\n+\n+  return (e->src == ENTRY_BLOCK_PTR)\n+    || ! TEST_BIT (loop->nodes, e->src->index);\n }"}, {"sha": "92d230eebce2c7745270003b73565c308b256526", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 235, "deletions": 225, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0d23589fe634ef3b7986a5dc0e389abfe4c917/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0d23589fe634ef3b7986a5dc0e389abfe4c917/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=5f0d23589fe634ef3b7986a5dc0e389abfe4c917", "patch": "@@ -19,28 +19,28 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n-/* This file contains low level functions to manipulate with CFG and analyze it\n-   that are aware of RTL intermediate language.\n+/* This file contains low level functions to manipulate the CFG and analyze it\n+   that are aware of the RTL intermediate language.\n \n    Available functionality:\n-     - CFG aware instruction chain manipulation\n+     - CFG-aware instruction chain manipulation\n \t delete_insn, delete_insn_chain\n      - Basic block manipulation\n-\t create_basic_block, flow_delete_block, split_block, merge_blocks_nomove\n-     - Infrastructure to determine quickly basic block for instruction.\n+\t create_basic_block, flow_delete_block, split_block,\n+\t merge_blocks_nomove\n+     - Infrastructure to determine quickly basic block for insn\n \t compute_bb_for_insn, update_bb_for_insn, set_block_for_insn,\n-     - Edge redirection with updating and optimizing instruction chain\n-\t     block_label, redirect_edge_and_branch,\n-\t     redirect_edge_and_branch_force, tidy_fallthru_edge, force_nonfallthru\n+     - Edge redirection with updating and optimizing of insn chain\n+\t block_label, redirect_edge_and_branch,\n+\t redirect_edge_and_branch_force, tidy_fallthru_edge, force_nonfallthru\n      - Edge splitting and commiting to edges\n-\t  split_edge, insert_insn_on_edge, commit_edge_insertions\n+\t split_edge, insert_insn_on_edge, commit_edge_insertions\n      - Dumping and debugging\n-\t  print_rtl_with_bb, dump_bb, debug_bb, debug_bb_n\n+\t print_rtl_with_bb, dump_bb, debug_bb, debug_bb_n\n      - Consistency checking\n-\t  verify_flow_info\n+\t verify_flow_info\n      - CFG updating after constant propagation\n-\t  purge_dead_edges, purge_all_dead_edges\n- */\n+\t purge_dead_edges, purge_all_dead_edges   */\n \f\n #include \"config.h\"\n #include \"system.h\"\n@@ -57,20 +57,18 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tm_p.h\"\n #include \"obstack.h\"\n \n-/* Stubs in case we haven't got a return insn.  */\n+/* Stubs in case we don't have a return insn.  */\n #ifndef HAVE_return\n #define HAVE_return 0\n #define gen_return() NULL_RTX\n #endif\n \n /* The basic block structure for every insn, indexed by uid.  */\n-\n varray_type basic_block_for_insn;\n \n /* The labels mentioned in non-jump rtl.  Valid during find_basic_blocks.  */\n /* ??? Should probably be using LABEL_NUSES instead.  It would take a\n    bit of surgery to be able to use or co-opt the routines in jump.  */\n-\n rtx label_value_list;\n rtx tail_recursion_label_list;\n \n@@ -83,7 +81,7 @@ static bool back_edge_of_syntactic_loop_p PARAMS ((basic_block, basic_block));\n static basic_block force_nonfallthru_and_redirect PARAMS ((edge, basic_block));\n \f\n /* Return true if NOTE is not one of the ones that must be kept paired,\n-   so that we may simply delete them.  */\n+   so that we may simply delete it.  */\n \n static int\n can_delete_note_p (note)\n@@ -99,26 +97,12 @@ static int\n can_delete_label_p (label)\n      rtx label;\n {\n-  rtx x;\n-\n-  if (LABEL_PRESERVE_P (label))\n-    return 0;\n-\n-  for (x = forced_labels; x; x = XEXP (x, 1))\n-    if (label == XEXP (x, 0))\n-      return 0;\n-  for (x = label_value_list; x; x = XEXP (x, 1))\n-    if (label == XEXP (x, 0))\n-      return 0;\n-  for (x = exception_handler_labels; x; x = XEXP (x, 1))\n-    if (label == XEXP (x, 0))\n-      return 0;\n-\n-  /* User declared labels must be preserved.  */\n-  if (LABEL_NAME (label) != 0)\n-    return 0;\n-\n-  return 1;\n+  return (!LABEL_PRESERVE_P (label)\n+\t  /* User declared labels must be preserved.  */\n+\t  && LABEL_NAME (label) == 0\n+\t  && !in_expr_list_p (forced_labels, label)\n+\t  && !in_expr_list_p (label_value_list, label)\n+\t  && !in_expr_list_p (exception_handler_labels, label));\n }\n \n /* Delete INSN by patching it out.  Return the next insn.  */\n@@ -145,6 +129,7 @@ delete_insn (insn)\n \t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED_LABEL;\n \t  NOTE_SOURCE_FILE (insn) = name;\n \t}\n+\n       remove_node_from_expr_list (insn, &nonlocal_goto_handler_labels);\n     }\n \n@@ -189,12 +174,11 @@ void\n delete_insn_chain (start, finish)\n      rtx start, finish;\n {\n-  /* Unchain the insns one by one.  It would be quicker to delete all\n-     of these with a single unchaining, rather than one at a time, but\n-     we need to keep the NOTE's.  */\n-\n   rtx next;\n \n+  /* Unchain the insns one by one.  It would be quicker to delete all of these\n+     with a single unchaining, rather than one at a time, but we need to keep\n+     the NOTE's.  */\n   while (1)\n     {\n       next = NEXT_INSN (start);\n@@ -209,14 +193,12 @@ delete_insn_chain (start, finish)\n     }\n }\n \f\n-/* Create a new basic block consisting of the instructions between\n-   HEAD and END inclusive.  This function is designed to allow fast\n-   BB construction - reuses the note and basic block struct\n-   in BB_NOTE, if any and do not grow BASIC_BLOCK chain and should\n-   be used directly only by CFG construction code.\n-   END can be NULL in to create new empty basic block before HEAD.\n-   Both END and HEAD can be NULL to create basic block at the end of\n-   INSN chain.  */\n+/* Create a new basic block consisting of the instructions between HEAD and END\n+   inclusive.  This function is designed to allow fast BB construction - reuses\n+   the note and basic block struct in BB_NOTE, if any and do not grow\n+   BASIC_BLOCK chain and should be used directly only by CFG construction code.\n+   END can be NULL in to create new empty basic block before HEAD.  Both END\n+   and HEAD can be NULL to create basic block at the end of INSN chain.  */\n \n basic_block\n create_basic_block_structure (index, head, end, bb_note)\n@@ -252,10 +234,8 @@ create_basic_block_structure (index, head, end, bb_note)\n       bb = alloc_block ();\n \n       if (!head && !end)\n-\t{\n-\t  head = end = bb_note = emit_note_after (NOTE_INSN_BASIC_BLOCK,\n-\t\t\t\t\t\t  get_last_insn ());\n-\t}\n+\thead = end = bb_note\n+\t  = emit_note_after (NOTE_INSN_BASIC_BLOCK, get_last_insn ());\n       else if (GET_CODE (head) == CODE_LABEL && end)\n \t{\n \t  bb_note = emit_note_after (NOTE_INSN_BASIC_BLOCK, head);\n@@ -269,6 +249,7 @@ create_basic_block_structure (index, head, end, bb_note)\n \t  if (!end)\n \t    end = head;\n \t}\n+\n       NOTE_BASIC_BLOCK (bb_note) = bb;\n     }\n \n@@ -290,11 +271,10 @@ create_basic_block_structure (index, head, end, bb_note)\n   return bb;\n }\n \n-/* Create new basic block consisting of instructions in between HEAD and\n-   END and place it to the BB chain at position INDEX.\n-   END can be NULL in to create new empty basic block before HEAD.\n-   Both END and HEAD can be NULL to create basic block at the end of\n-   INSN chain.  */\n+/* Create new basic block consisting of instructions in between HEAD and END\n+   and place it to the BB chain at position INDEX.  END can be NULL in to\n+   create new empty basic block before HEAD.  Both END and HEAD can be NULL to\n+   create basic block at the end of INSN chain.  */\n \n basic_block\n create_basic_block (index, head, end)\n@@ -313,6 +293,7 @@ create_basic_block (index, head, end)\n   for (i = n_basic_blocks - 1; i > index; --i)\n     {\n       basic_block tmp = BASIC_BLOCK (i - 1);\n+\n       BASIC_BLOCK (i) = tmp;\n       tmp->index = i;\n     }\n@@ -397,23 +378,22 @@ compute_bb_for_insn (max)\n \n   if (basic_block_for_insn)\n     VARRAY_FREE (basic_block_for_insn);\n+\n   VARRAY_BB_INIT (basic_block_for_insn, max, \"basic_block_for_insn\");\n \n   for (i = 0; i < n_basic_blocks; ++i)\n     {\n       basic_block bb = BASIC_BLOCK (i);\n-      rtx insn, end;\n+      rtx end = bb->end;\n+      rtx insn;\n \n-      end = bb->end;\n-      insn = bb->head;\n-      while (1)\n+      for (insn = bb->head; ; insn = NEXT_INSN (insn))\n \t{\n-\t  int uid = INSN_UID (insn);\n-\t  if (uid < max)\n-\t    VARRAY_BB (basic_block_for_insn, uid) = bb;\n+\t  if (INSN_UID (insn) < max)\n+\t    VARRAY_BB (basic_block_for_insn, INSN_UID (insn)) = bb;\n+\n \t  if (insn == end)\n \t    break;\n-\t  insn = NEXT_INSN (insn);\n \t}\n     }\n }\n@@ -425,6 +405,7 @@ free_bb_for_insn ()\n {\n   if (basic_block_for_insn)\n     VARRAY_FREE (basic_block_for_insn);\n+\n   basic_block_for_insn = 0;\n }\n \n@@ -442,7 +423,6 @@ update_bb_for_insn (bb)\n   for (insn = bb->head; ; insn = NEXT_INSN (insn))\n     {\n       set_block_for_insn (insn, bb);\n-\n       if (insn == bb->end)\n \tbreak;\n     }\n@@ -456,15 +436,15 @@ set_block_for_insn (insn, bb)\n      basic_block bb;\n {\n   size_t uid = INSN_UID (insn);\n+\n   if (uid >= basic_block_for_insn->num_elements)\n     {\n-      int new_size;\n-\n       /* Add one-eighth the size so we don't keep calling xrealloc.  */\n-      new_size = uid + (uid + 7) / 8;\n+      size_t new_size = uid + (uid + 7) / 8;\n \n       VARRAY_GROW (basic_block_for_insn, new_size);\n     }\n+\n   VARRAY_BB (basic_block_for_insn, uid) = bb;\n }\n \f\n@@ -528,37 +508,37 @@ void\n merge_blocks_nomove (a, b)\n      basic_block a, b;\n {\n-  edge e;\n-  rtx b_head, b_end, a_end;\n+  rtx b_head = b->head, b_end = b->end, a_end = a->end;\n   rtx del_first = NULL_RTX, del_last = NULL_RTX;\n   int b_empty = 0;\n+  edge e;\n \n   /* If there was a CODE_LABEL beginning B, delete it.  */\n-  b_head = b->head;\n-  b_end = b->end;\n   if (GET_CODE (b_head) == CODE_LABEL)\n     {\n       /* Detect basic blocks with nothing but a label.  This can happen\n \t in particular at the end of a function.  */\n       if (b_head == b_end)\n \tb_empty = 1;\n+\n       del_first = del_last = b_head;\n       b_head = NEXT_INSN (b_head);\n     }\n \n-  /* Delete the basic block note.  */\n+  /* Delete the basic block note and handle blocks containing just that\n+     note.  */\n   if (NOTE_INSN_BASIC_BLOCK_P (b_head))\n     {\n       if (b_head == b_end)\n \tb_empty = 1;\n       if (! del_last)\n \tdel_first = b_head;\n+\n       del_last = b_head;\n       b_head = NEXT_INSN (b_head);\n     }\n \n   /* If there was a jump out of A, delete it.  */\n-  a_end = a->end;\n   if (GET_CODE (a_end) == JUMP_INSN)\n     {\n       rtx prev;\n@@ -577,6 +557,7 @@ merge_blocks_nomove (a, b)\n       if (only_sets_cc0_p (prev))\n \t{\n \t  rtx tmp = prev;\n+\n \t  prev = prev_nonnote_insn (prev);\n \t  if (!prev)\n \t    prev = a->head;\n@@ -614,44 +595,46 @@ merge_blocks_nomove (a, b)\n   /* Reassociate the insns of B with A.  */\n   if (!b_empty)\n     {\n-      rtx x = a_end;\n       if (basic_block_for_insn)\n \t{\n-\t  BLOCK_FOR_INSN (x) = a;\n-\t  while (x != b_end)\n-\t    {\n-\t      x = NEXT_INSN (x);\n-\t      BLOCK_FOR_INSN (x) = a;\n-\t    }\n+\t  rtx x;\n+\n+\t  for (x = a_end; x != b_end; x = NEXT_INSN (x))\n+\t    BLOCK_FOR_INSN (x) = a;\n+\n+\t  BLOCK_FOR_INSN (b_end) = a;\n \t}\n+\n       a_end = b_end;\n     }\n+\n   a->end = a_end;\n }\n \f\n-/* Return label in the head of basic block.  Create one if it doesn't exist.  */\n+/* Return the label in the head of basic block BLOCK.  Create one if it doesn't\n+   exist.  */\n \n rtx\n block_label (block)\n      basic_block block;\n {\n   if (block == EXIT_BLOCK_PTR)\n     return NULL_RTX;\n+\n   if (GET_CODE (block->head) != CODE_LABEL)\n     {\n       block->head = emit_label_before (gen_label_rtx (), block->head);\n       if (basic_block_for_insn)\n \tset_block_for_insn (block->head, block);\n     }\n+\n   return block->head;\n }\n \n /* Attempt to perform edge redirection by replacing possibly complex jump\n-   instruction by unconditional jump or removing jump completely.\n-   This can apply only if all edges now point to the same block.\n-\n-   The parameters and return values are equivalent to redirect_edge_and_branch.\n- */\n+   instruction by unconditional jump or removing jump completely.  This can\n+   apply only if all edges now point to the same block.  The parameters and\n+   return values are equivalent to redirect_edge_and_branch.  */\n \n static bool\n try_redirect_by_replacing_jump (e, target)\n@@ -668,6 +651,7 @@ try_redirect_by_replacing_jump (e, target)\n   for (tmp = src->succ; tmp; tmp = tmp->succ_next)\n     if (tmp->dest != target && tmp != e)\n       break;\n+\n   if (tmp || !onlyjump_p (insn))\n     return false;\n \n@@ -694,6 +678,7 @@ try_redirect_by_replacing_jump (e, target)\n       /* Selectively unlink whole insn chain.  */\n       delete_insn_chain (kill_from, PREV_INSN (target->head));\n     }\n+\n   /* If this already is simplejump, redirect it.  */\n   else if (simplejump_p (insn))\n     {\n@@ -704,6 +689,7 @@ try_redirect_by_replacing_jump (e, target)\n \t\t INSN_UID (insn), e->dest->index, target->index);\n       redirect_jump (insn, block_label (target), 0);\n     }\n+\n   /* Or replace possibly complicated jump insn by simple jump insn.  */\n   else\n     {\n@@ -732,6 +718,7 @@ try_redirect_by_replacing_jump (e, target)\n     e->flags = EDGE_FALLTHRU;\n   else\n     e->flags = 0;\n+\n   e->probability = REG_BR_PROB_BASE;\n   e->count = src->count;\n \n@@ -743,43 +730,41 @@ try_redirect_by_replacing_jump (e, target)\n \n   if (e->dest != target)\n     redirect_edge_succ (e, target);\n+\n   return true;\n }\n \n /* Return last loop_beg note appearing after INSN, before start of next\n    basic block.  Return INSN if there are no such notes.\n \n-   When emitting jump to redirect an fallthru edge, it should always\n-   appear after the LOOP_BEG notes, as loop optimizer expect loop to\n-   either start by fallthru edge or jump following the LOOP_BEG note\n-   jumping to the loop exit test.  */\n+   When emitting jump to redirect an fallthru edge, it should always appear\n+   after the LOOP_BEG notes, as loop optimizer expect loop to either start by\n+   fallthru edge or jump following the LOOP_BEG note jumping to the loop exit\n+   test.  */\n \n static rtx\n last_loop_beg_note (insn)\n      rtx insn;\n {\n   rtx last = insn;\n-  insn = NEXT_INSN (insn);\n-  while (insn && GET_CODE (insn) == NOTE\n-\t && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK)\n-    {\n-      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\tlast = insn;\n-      insn = NEXT_INSN (insn);\n-    }\n+\n+  for (insn = NEXT_INSN (insn); insn && GET_CODE (insn) == NOTE\n+       && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK;\n+       insn = NEXT_INSN (insn))\n+    if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n+      last = insn;\n+\n   return last;\n }\n \n-/* Attempt to change code to redirect edge E to TARGET.\n-   Don't do that on expense of adding new instructions or reordering\n-   basic blocks.\n+/* Attempt to change code to redirect edge E to TARGET.  Don't do that on\n+   expense of adding new instructions or reordering basic blocks.\n \n-   Function can be also called with edge destination equivalent to the\n-   TARGET.  Then it should try the simplifications and do nothing if\n-   none is possible.\n+   Function can be also called with edge destination equivalent to the TARGET.\n+   Then it should try the simplifications and do nothing if none is possible.\n \n-   Return true if transformation succeeded.  We still return false in case\n-   E already destinated TARGET and we didn't managed to simplify instruction\n+   Return true if transformation succeeded.  We still return false in case E\n+   already destinated TARGET and we didn't managed to simplify instruction\n    stream.  */\n \n bool\n@@ -797,6 +782,7 @@ redirect_edge_and_branch (e, target)\n \n   if (try_redirect_by_replacing_jump (e, target))\n     return true;\n+\n   /* Do this fast path late, as we want above code to simplify for cases\n      where called on single edge leaving basic block containing nontrivial\n      jump insn.  */\n@@ -806,7 +792,7 @@ redirect_edge_and_branch (e, target)\n   /* We can only redirect non-fallthru edges of jump insn.  */\n   if (e->flags & EDGE_FALLTHRU)\n     return false;\n-  if (GET_CODE (insn) != JUMP_INSN)\n+  else if (GET_CODE (insn) != JUMP_INSN)\n     return false;\n \n   /* Recognize a tablejump and adjust all matching cases.  */\n@@ -851,27 +837,26 @@ redirect_edge_and_branch (e, target)\n       /* ?? We may play the games with moving the named labels from\n \t one basic block to the other in case only one computed_jump is\n \t available.  */\n-      if (computed_jump_p (insn))\n-\treturn false;\n-\n-      /* A return instruction can't be redirected.  */\n-      if (returnjump_p (insn))\n+      if (computed_jump_p (insn)\n+\t  /* A return instruction can't be redirected.  */\n+\t  || returnjump_p (insn))\n \treturn false;\n \n       /* If the insn doesn't go where we think, we're confused.  */\n-      if (JUMP_LABEL (insn) != old_label)\n-\tabort ();\n-      /* If the substitution doesn't succeed, die.  This can happen\n-\t if the back end emitted unrecognizable instructions.  */\n-      if (! redirect_jump (insn, block_label (target), 0))\n+      if (JUMP_LABEL (insn) != old_label\n+\t  /* If the substitution doesn't succeed, die.  This can happen\n+\t     if the back end emitted unrecognizable instructions.  */\n+\t  || !redirect_jump (insn, block_label (target), 0))\n \tabort ();\n     }\n \n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \"Edge %i->%i redirected to %i\\n\",\n \t     e->src->index, e->dest->index, target->index);\n+\n   if (e->dest != target)\n     redirect_edge_succ_nodup (e, target);\n+\n   return true;\n }\n \n@@ -889,23 +874,24 @@ force_nonfallthru_and_redirect (e, target)\n \n   if (e->flags & EDGE_ABNORMAL)\n     abort ();\n-  if (!(e->flags & EDGE_FALLTHRU))\n+  else if (!(e->flags & EDGE_FALLTHRU))\n     abort ();\n-  if (e->src->succ->succ_next)\n+  else if (e->src->succ->succ_next)\n     {\n       /* Create the new structures.  */\n       note = last_loop_beg_note (e->src->end);\n-      jump_block = create_basic_block (e->src->index + 1, NEXT_INSN (note), NULL);\n+      jump_block\n+\t= create_basic_block (e->src->index + 1, NEXT_INSN (note), NULL);\n       jump_block->count = e->count;\n       jump_block->frequency = EDGE_FREQUENCY (e);\n       jump_block->loop_depth = target->loop_depth;\n \n       if (target->global_live_at_start)\n \t{\n-\t  jump_block->global_live_at_start =\n-\t    OBSTACK_ALLOC_REG_SET (&flow_obstack);\n-\t  jump_block->global_live_at_end =\n-\t    OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+\t  jump_block->global_live_at_start\n+\t    = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+\t  jump_block->global_live_at_end\n+\t    = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n \t  COPY_REG_SET (jump_block->global_live_at_start,\n \t\t\ttarget->global_live_at_start);\n \t  COPY_REG_SET (jump_block->global_live_at_end,\n@@ -925,6 +911,7 @@ force_nonfallthru_and_redirect (e, target)\n     }\n   else\n     jump_block = e->src;\n+\n   e->flags &= ~EDGE_FALLTHRU;\n   if (target == EXIT_BLOCK_PTR)\n     {\n@@ -940,6 +927,7 @@ force_nonfallthru_and_redirect (e, target)\n       JUMP_LABEL (jump_block->end) = label;\n       LABEL_NUSES (label)++;\n     }\n+\n   emit_barrier_after (jump_block->end);\n   redirect_edge_succ_nodup (e, target);\n \n@@ -949,6 +937,7 @@ force_nonfallthru_and_redirect (e, target)\n /* Edge E is assumed to be fallthru edge.  Emit needed jump instruction\n    (and possibly create new basic block) to make edge non-fallthru.\n    Return newly created BB or NULL if none.  */\n+\n basic_block\n force_nonfallthru (e)\n      edge e;\n@@ -965,17 +954,13 @@ redirect_edge_and_branch_force (e, target)\n      edge e;\n      basic_block target;\n {\n-  basic_block new_bb;\n-\n-  if (redirect_edge_and_branch (e, target))\n-    return NULL;\n-  if (e->dest == target)\n+  if (redirect_edge_and_branch (e, target)\n+      || e->dest == target)\n     return NULL;\n \n   /* In case the edge redirection failed, try to force it to be non-fallthru\n      and redirect newly created simplejump.  */\n-  new_bb = force_nonfallthru_and_redirect (e, target);\n-  return new_bb;\n+  return force_nonfallthru_and_redirect (e, target);\n }\n \n /* The given edge should potentially be a fallthru edge.  If that is in\n@@ -1042,7 +1027,7 @@ tidy_fallthru_edges ()\n {\n   int i;\n \n-  for (i = 1; i < n_basic_blocks; ++i)\n+  for (i = 1; i < n_basic_blocks; i++)\n     {\n       basic_block b = BASIC_BLOCK (i - 1);\n       basic_block c = BASIC_BLOCK (i);\n@@ -1059,6 +1044,7 @@ tidy_fallthru_edges ()\n \t Furthermore, the edge will be marked as a fallthru because we\n \t merge the flags for the duplicate edges.  So we do not want to\n \t check that the edge is not a FALLTHRU edge.  */\n+\n       if ((s = b->succ) != NULL\n \t  && ! (s->flags & EDGE_COMPLEX)\n \t  && s->succ_next == NULL\n@@ -1082,8 +1068,7 @@ back_edge_of_syntactic_loop_p (bb1, bb2)\n \n   if (bb1->index > bb2->index)\n     return false;\n-\n-  if (bb1->index == bb2->index)\n+  else if (bb1->index == bb2->index)\n     return true;\n \n   for (insn = bb1->end; insn != bb2->head && count >= 0;\n@@ -1092,7 +1077,7 @@ back_edge_of_syntactic_loop_p (bb1, bb2)\n       {\n \tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n \t  count++;\n-\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n+\telse if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n \t  count--;\n       }\n \n@@ -1123,6 +1108,7 @@ split_edge (edge_in)\n   if ((edge_in->flags & EDGE_FALLTHRU) == 0)\n     {\n       edge e;\n+\n       for (e = edge_in->dest->pred; e; e = e->pred_next)\n \tif (e->flags & EDGE_FALLTHRU)\n \t  break;\n@@ -1152,7 +1138,8 @@ split_edge (edge_in)\n   if (edge_in->dest != EXIT_BLOCK_PTR\n       && PREV_INSN (edge_in->dest->head)\n       && GET_CODE (PREV_INSN (edge_in->dest->head)) == NOTE\n-      && NOTE_LINE_NUMBER (PREV_INSN (edge_in->dest->head)) == NOTE_INSN_LOOP_BEG\n+      && (NOTE_LINE_NUMBER (PREV_INSN (edge_in->dest->head))\n+\t  == NOTE_INSN_LOOP_BEG)\n       && !back_edge_of_syntactic_loop_p (edge_in->dest, edge_in->src))\n     before = PREV_INSN (edge_in->dest->head);\n   else if (edge_in->dest != EXIT_BLOCK_PTR)\n@@ -1170,8 +1157,10 @@ split_edge (edge_in)\n     {\n       bb->global_live_at_start = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n       bb->global_live_at_end = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n-      COPY_REG_SET (bb->global_live_at_start, edge_in->dest->global_live_at_start);\n-      COPY_REG_SET (bb->global_live_at_end, edge_in->dest->global_live_at_start);\n+      COPY_REG_SET (bb->global_live_at_start,\n+\t\t    edge_in->dest->global_live_at_start);\n+      COPY_REG_SET (bb->global_live_at_end,\n+\t\t    edge_in->dest->global_live_at_start);\n     }\n \n   edge_out = make_single_succ_edge (bb, edge_in->dest, EDGE_FALLTHRU);\n@@ -1254,19 +1243,19 @@ commit_one_edge_insertion (e)\n \t   && e->src != ENTRY_BLOCK_PTR)\n     {\n       bb = e->src;\n+\n       /* It is possible to have a non-simple jump here.  Consider a target\n \t where some forms of unconditional jumps clobber a register.  This\n \t happens on the fr30 for example.\n \n \t We know this block has a single successor, so we can just emit\n \t the queued insns before the jump.  */\n       if (GET_CODE (bb->end) == JUMP_INSN)\n-\t{\n-\t  before = bb->end;\n-\t  while (GET_CODE (PREV_INSN (before)) == NOTE\n-\t\t && NOTE_LINE_NUMBER (PREV_INSN (before)) == NOTE_INSN_LOOP_BEG)\n-\t    before = PREV_INSN (before);\n-\t}\n+\tfor (before = bb->end;\n+\t     GET_CODE (PREV_INSN (before)) == NOTE\n+\t     && NOTE_LINE_NUMBER (PREV_INSN (before)) == NOTE_INSN_LOOP_BEG;\n+\t     before = PREV_INSN (before))\n+\t  ;\n       else\n \t{\n \t  /* We'd better be fallthru, or we've lost track of what's what.  */\n@@ -1306,15 +1295,16 @@ commit_one_edge_insertion (e)\n \t  || e->succ_next != NULL\n \t  || (e->flags & EDGE_FALLTHRU) == 0)\n \tabort ();\n-      e->flags &= ~EDGE_FALLTHRU;\n \n+      e->flags &= ~EDGE_FALLTHRU;\n       emit_barrier_after (last);\n \n       if (before)\n \tdelete_insn (before);\n     }\n   else if (GET_CODE (last) == JUMP_INSN)\n     abort ();\n+\n   find_sub_basic_blocks (bb);\n }\n \n@@ -1374,8 +1364,7 @@ dump_bb (bb, outf)\n   dump_regset (bb->global_live_at_start, outf);\n   putc ('\\n', outf);\n \n-  for (insn = bb->head, last = NEXT_INSN (bb->end);\n-       insn != last;\n+  for (insn = bb->head, last = NEXT_INSN (bb->end); insn != last;\n        insn = NEXT_INSN (insn))\n     print_rtl_single (outf, insn);\n \n@@ -1420,12 +1409,12 @@ print_rtl_with_bb (outf, rtx_first)\n       int i;\n       enum bb_state { NOT_IN_BB, IN_ONE_BB, IN_MULTIPLE_BB };\n       int max_uid = get_max_uid ();\n-      basic_block *start = (basic_block *)\n-\txcalloc (max_uid, sizeof (basic_block));\n-      basic_block *end = (basic_block *)\n-\txcalloc (max_uid, sizeof (basic_block));\n-      enum bb_state *in_bb_p = (enum bb_state *)\n-\txcalloc (max_uid, sizeof (enum bb_state));\n+      basic_block *start\n+\t= (basic_block *) xcalloc (max_uid, sizeof (basic_block));\n+      basic_block *end\n+\t= (basic_block *) xcalloc (max_uid, sizeof (basic_block));\n+      enum bb_state *in_bb_p\n+\t= (enum bb_state *) xcalloc (max_uid, sizeof (enum bb_state));\n \n       for (i = n_basic_blocks - 1; i >= 0; i--)\n \t{\n@@ -1437,6 +1426,7 @@ print_rtl_with_bb (outf, rtx_first)\n \t  for (x = bb->head; x != NULL_RTX; x = NEXT_INSN (x))\n \t    {\n \t      enum bb_state state = IN_MULTIPLE_BB;\n+\n \t      if (in_bb_p[INSN_UID (x)] == NOT_IN_BB)\n \t\tstate = IN_ONE_BB;\n \t      in_bb_p[INSN_UID (x)] = state;\n@@ -1508,7 +1498,7 @@ print_rtl_with_bb (outf, rtx_first)\n    - scans body of the basic block for JUMP_INSN, CODE_LABEL\n      and NOTE_INSN_BASIC_BLOCK\n    - check that all insns are in the basic blocks\n-   (except the switch handling code, barriers and notes)\n+     (except the switch handling code, barriers and notes)\n    - check that all returns are followed by barriers\n \n    In future it can be extended check a lot of other stuff as well\n@@ -1540,6 +1530,7 @@ verify_flow_info ()\n       for (x = last_head; x != NULL_RTX; x = PREV_INSN (x))\n \tif (x == end)\n \t  break;\n+\n       if (!x)\n \t{\n \t  error (\"end insn %d for block %d not found in the insn stream\",\n@@ -1560,6 +1551,7 @@ verify_flow_info ()\n \t\t     INSN_UID (x), bb->index, bb_info[INSN_UID (x)]->index);\n \t      err = 1;\n \t    }\n+\n \t  bb_info[INSN_UID (x)] = bb;\n \n \t  if (x == head)\n@@ -1582,15 +1574,15 @@ verify_flow_info ()\n       int has_fallthru = 0;\n       edge e;\n \n-      e = bb->succ;\n-      while (e)\n+      for (e = bb->succ; e; e = e->succ_next)\n \t{\n \t  if (last_visited [e->dest->index + 2] == bb)\n \t    {\n \t      error (\"verify_flow_info: Duplicate edge %i->%i\",\n \t\t     e->src->index, e->dest->index);\n \t      err = 1;\n \t    }\n+\n \t  last_visited [e->dest->index + 2] = bb;\n \n \t  if (e->flags & EDGE_FALLTHRU)\n@@ -1601,28 +1593,32 @@ verify_flow_info ()\n \t      && e->dest != EXIT_BLOCK_PTR)\n \t    {\n \t      rtx insn;\n+\n \t      if (e->src->index + 1 != e->dest->index)\n \t\t{\n-\t\t    error (\"verify_flow_info: Incorrect blocks for fallthru %i->%i\",\n-\t\t\t   e->src->index, e->dest->index);\n-\t\t    err = 1;\n+\t\t  error\n+\t\t    (\"verify_flow_info: Incorrect blocks for fallthru %i->%i\",\n+\t\t     e->src->index, e->dest->index);\n+\t\t  err = 1;\n \t\t}\n \t      else\n \t\tfor (insn = NEXT_INSN (e->src->end); insn != e->dest->head;\n \t\t     insn = NEXT_INSN (insn))\n \t\t  if (GET_CODE (insn) == BARRIER\n #ifndef CASE_DROPS_THROUGH\n-\t\t      || INSN_P (insn))\n+\t\t      || INSN_P (insn)\n #else\n-\t\t      || (INSN_P (insn) && ! JUMP_TABLE_DATA_P (insn)))\n+\t\t      || (INSN_P (insn) && ! JUMP_TABLE_DATA_P (insn))\n #endif\n+\t\t      )\n \t\t    {\n \t\t      error (\"verify_flow_info: Incorrect fallthru %i->%i\",\n \t\t\t     e->src->index, e->dest->index);\n \t\t      fatal_insn (\"wrong insn in the fallthru edge\", insn);\n \t\t      err = 1;\n \t\t    }\n \t    }\n+\n \t  if (e->src != bb)\n \t    {\n \t      error (\"verify_flow_info: Basic block %d succ edge is corrupted\",\n@@ -1634,9 +1630,10 @@ verify_flow_info ()\n \t      fprintf (stderr, \"\\n\");\n \t      err = 1;\n \t    }\n+\n \t  edge_checksum[e->dest->index + 2] += (size_t) e;\n-\t  e = e->succ_next;\n \t}\n+\n       if (!has_fallthru)\n \t{\n \t  rtx insn;\n@@ -1654,8 +1651,7 @@ verify_flow_info ()\n \t\t}\n \t}\n \n-      e = bb->pred;\n-      while (e)\n+      for (e = bb->pred; e; e = e->pred_next)\n \t{\n \t  if (e->dest != bb)\n \t    {\n@@ -1668,20 +1664,23 @@ verify_flow_info ()\n \t      err = 1;\n \t    }\n \t  edge_checksum[e->dest->index + 2] -= (size_t) e;\n-\t  e = e->pred_next;\n \t}\n-       for (x = bb->head; x != NEXT_INSN (bb->end); x = NEXT_INSN (x))\n-\t if (basic_block_for_insn && BLOCK_FOR_INSN (x) != bb)\n-\t   {\n-\t     debug_rtx (x);\n-\t     if (! BLOCK_FOR_INSN (x))\n-\t       error (\"insn %d is inside basic block %d but block_for_insn is NULL\",\n-\t\t      INSN_UID (x), bb->index);\n-\t     else\n-\t       error (\"insn %d is inside basic block %d but block_for_insn is %i\",\n-\t\t      INSN_UID (x), bb->index, BLOCK_FOR_INSN (x)->index);\n-\t     err = 1;\n-\t   }\n+\n+      for (x = bb->head; x != NEXT_INSN (bb->end); x = NEXT_INSN (x))\n+\tif (basic_block_for_insn && BLOCK_FOR_INSN (x) != bb)\n+\t  {\n+\t    debug_rtx (x);\n+\t    if (! BLOCK_FOR_INSN (x))\n+\t      error\n+\t\t(\"insn %d inside basic block %d but block_for_insn is NULL\",\n+\t\t INSN_UID (x), bb->index);\n+\t    else\n+\t      error\n+\t\t(\"insn %d inside basic block %d but block_for_insn is %i\",\n+\t\t INSN_UID (x), bb->index, BLOCK_FOR_INSN (x)->index);\n+\n+\t    err = 1;\n+\t  }\n \n       /* OK pointers are correct.  Now check the header of basic\n          block.  It ought to contain optional CODE_LABEL followed\n@@ -1695,8 +1694,10 @@ verify_flow_info ()\n \t\t     bb->index);\n \t      err = 1;\n \t    }\n+\n \t  x = NEXT_INSN (x);\n \t}\n+\n       if (!NOTE_INSN_BASIC_BLOCK_P (x) || NOTE_BASIC_BLOCK (x) != bb)\n \t{\n \t  error (\"NOTE_INSN_BASIC_BLOCK is missing for block %d\",\n@@ -1705,42 +1706,38 @@ verify_flow_info ()\n \t}\n \n       if (bb->end == x)\n-\t{\n-\t  /* Do checks for empty blocks here */\n-\t}\n+\t/* Do checks for empty blocks her. e */\n+\t;\n       else\n-\t{\n-\t  x = NEXT_INSN (x);\n-\t  while (x)\n-\t    {\n-\t      if (NOTE_INSN_BASIC_BLOCK_P (x))\n-\t\t{\n-\t\t  error (\"NOTE_INSN_BASIC_BLOCK %d in the middle of basic block %d\",\n-\t\t\t INSN_UID (x), bb->index);\n-\t\t  err = 1;\n-\t\t}\n-\n-\t      if (x == bb->end)\n-\t\tbreak;\n-\n-\t      if (GET_CODE (x) == JUMP_INSN\n-\t\t  || GET_CODE (x) == CODE_LABEL\n-\t\t  || GET_CODE (x) == BARRIER)\n-\t\t{\n-\t\t  error (\"in basic block %d:\", bb->index);\n-\t\t  fatal_insn (\"flow control insn inside a basic block\", x);\n-\t\t}\n+\tfor (x = NEXT_INSN (x); x; x = NEXT_INSN (x))\n+\t  {\n+\t    if (NOTE_INSN_BASIC_BLOCK_P (x))\n+\t      {\n+\t\terror (\"NOTE_INSN_BASIC_BLOCK %d in middle of basic block %d\",\n+\t\t       INSN_UID (x), bb->index);\n+\t\terr = 1;\n+\t      }\n+\n+\t    if (x == bb->end)\n+\t      break;\n \n-\t      x = NEXT_INSN (x);\n-\t    }\n-\t}\n+\t    if (GET_CODE (x) == JUMP_INSN\n+\t\t|| GET_CODE (x) == CODE_LABEL\n+\t\t|| GET_CODE (x) == BARRIER)\n+\t      {\n+\t\terror (\"in basic block %d:\", bb->index);\n+\t\tfatal_insn (\"flow control insn inside a basic block\", x);\n+\t      }\n+\t  }\n     }\n \n   /* Complete edge checksumming for ENTRY and EXIT.  */\n   {\n     edge e;\n+\n     for (e = ENTRY_BLOCK_PTR->succ; e ; e = e->succ_next)\n       edge_checksum[e->dest->index + 2] += (size_t) e;\n+\n     for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n       edge_checksum[e->dest->index + 2] -= (size_t) e;\n   }\n@@ -1754,12 +1751,12 @@ verify_flow_info ()\n \n   last_bb_num_seen = -1;\n   num_bb_notes = 0;\n-  x = rtx_first;\n-  while (x)\n+  for (x = rtx_first; x; x = NEXT_INSN (x))\n     {\n       if (NOTE_INSN_BASIC_BLOCK_P (x))\n \t{\n \t  basic_block bb = NOTE_BASIC_BLOCK (x);\n+\n \t  num_bb_notes++;\n \t  if (bb->index != last_bb_num_seen + 1)\n \t    internal_error (\"basic blocks not numbered consecutively\");\n@@ -1781,9 +1778,7 @@ verify_flow_info ()\n \t\t  && GET_CODE (NEXT_INSN (x)) == JUMP_INSN\n \t\t  && (GET_CODE (PATTERN (NEXT_INSN (x))) == ADDR_DIFF_VEC\n \t\t      || GET_CODE (PATTERN (NEXT_INSN (x))) == ADDR_VEC))\n-\t\t{\n-\t\t  x = NEXT_INSN (x);\n-\t\t}\n+\t\tx = NEXT_INSN (x);\n \n \t      /* But in any case, non-deletable labels can appear anywhere.  */\n \t      break;\n@@ -1798,8 +1793,6 @@ verify_flow_info ()\n \t  && returnjump_p (x) && ! condjump_p (x)\n \t  && ! (NEXT_INSN (x) && GET_CODE (NEXT_INSN (x)) == BARRIER))\n \t    fatal_insn (\"return not followed by barrier\", x);\n-\n-      x = NEXT_INSN (x);\n     }\n \n   if (num_bb_notes != n_basic_blocks)\n@@ -1828,17 +1821,21 @@ purge_dead_edges (bb)\n   rtx insn = bb->end, note;\n   bool purged = false;\n \n+  /* ??? This makes no sense since the later test includes more cases.  */\n   if (GET_CODE (insn) == JUMP_INSN && !simplejump_p (insn))\n     return false;\n+\n   if (GET_CODE (insn) == JUMP_INSN)\n     {\n       rtx note;\n       edge b,f;\n+\n       /* We do care only about conditional jumps and simplejumps.  */\n       if (!any_condjump_p (insn)\n \t  && !returnjump_p (insn)\n \t  && !simplejump_p (insn))\n \treturn false;\n+\n       for (e = bb->succ; e; e = next)\n \t{\n \t  next = e->succ_next;\n@@ -1852,19 +1849,23 @@ purge_dead_edges (bb)\n \t  if ((e->flags & EDGE_FALLTHRU)\n \t      && any_condjump_p (insn))\n \t    continue;\n-\t  if (e->dest != EXIT_BLOCK_PTR\n-\t      && e->dest->head == JUMP_LABEL (insn))\n+\t  else if (e->dest != EXIT_BLOCK_PTR\n+\t\t   && e->dest->head == JUMP_LABEL (insn))\n \t    continue;\n-\t  if (e->dest == EXIT_BLOCK_PTR\n-\t      && returnjump_p (insn))\n+\t  else if (e->dest == EXIT_BLOCK_PTR\n+\t\t   && returnjump_p (insn))\n \t    continue;\n+\n \t  purged = true;\n \t  remove_edge (e);\n \t}\n+\n       if (!bb->succ || !purged)\n \treturn false;\n+\n       if (rtl_dump_file)\n \tfprintf (rtl_dump_file, \"Purged edges from bb %i\\n\", bb->index);\n+\n       if (!optimize)\n \treturn purged;\n \n@@ -1879,13 +1880,15 @@ purge_dead_edges (bb)\n \t  note = find_reg_note (insn, REG_BR_PROB, NULL);\n \t  if (!note)\n \t    return purged;\n+\n \t  b = BRANCH_EDGE (bb);\n \t  f = FALLTHRU_EDGE (bb);\n \t  b->probability = INTVAL (XEXP (note, 0));\n \t  f->probability = REG_BR_PROB_BASE - b->probability;\n \t  b->count = bb->count * b->probability / REG_BR_PROB_BASE;\n \t  f->count = bb->count * f->probability / REG_BR_PROB_BASE;\n \t}\n+\n       return purged;\n     }\n \n@@ -1894,6 +1897,7 @@ purge_dead_edges (bb)\n       && (note = find_reg_note (insn, REG_EH_REGION, NULL)))\n     {\n       rtx eqnote;\n+\n       if (! may_trap_p (PATTERN (insn))\n \t  || ((eqnote = find_reg_equal_equiv_note (insn))\n \t      && ! may_trap_p (XEXP (eqnote, 0))))\n@@ -1919,17 +1923,22 @@ purge_dead_edges (bb)\n      edge we know that there used to be a jump here and can then safely\n      remove all non-fallthru edges.  */\n   for (e = bb->succ; e && (e->flags & (EDGE_COMPLEX | EDGE_FALLTHRU));\n-       e = e->succ_next);\n+       e = e->succ_next)\n+    ;\n+\n   if (!e)\n     return purged;\n+\n   for (e = bb->succ; e; e = next)\n     {\n       next = e->succ_next;\n       if (!(e->flags & EDGE_FALLTHRU))\n \tremove_edge (e), purged = true;\n     }\n+\n   if (!bb->succ || bb->succ->succ_next)\n     abort ();\n+\n   bb->succ->probability = REG_BR_PROB_BASE;\n   bb->succ->count = bb->count;\n \n@@ -1939,10 +1948,8 @@ purge_dead_edges (bb)\n   return purged;\n }\n \n-/* Search all basic blocks for potentially dead edges and purge them.\n-\n-   Return true iff some edge has been eliminated.\n- */\n+/* Search all basic blocks for potentially dead edges and purge them.  Return\n+   true if some edge has been eliminated.  */\n \n bool\n purge_all_dead_edges (update_life_p)\n@@ -1956,18 +1963,21 @@ purge_all_dead_edges (update_life_p)\n       blocks = sbitmap_alloc (n_basic_blocks);\n       sbitmap_zero (blocks);\n     }\n+\n   for (i = 0; i < n_basic_blocks; i++)\n     {\n-      bool purged_here;\n-      purged_here = purge_dead_edges (BASIC_BLOCK (i));\n+      bool purged_here = purge_dead_edges (BASIC_BLOCK (i));\n+\n       purged |= purged_here;\n       if (purged_here && update_life_p)\n \tSET_BIT (blocks, i);\n     }\n+\n   if (update_life_p && purged)\n     update_life_info (blocks, UPDATE_LIFE_GLOBAL,\n \t\t      PROP_DEATH_NOTES | PROP_SCAN_DEAD_CODE\n \t\t      | PROP_KILL_DEAD_CODE);\n+\n   if (update_life_p)\n     sbitmap_free (blocks);\n   return purged;"}, {"sha": "676d4ace938d7a1bfcde8359013b6b80f6df0c2b", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0d23589fe634ef3b7986a5dc0e389abfe4c917/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0d23589fe634ef3b7986a5dc0e389abfe4c917/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=5f0d23589fe634ef3b7986a5dc0e389abfe4c917", "patch": "@@ -1483,6 +1483,7 @@ typedef int (*rtx_function)             PARAMS ((rtx *, void *));\n extern int for_each_rtx                 PARAMS ((rtx *, rtx_function, void *));\n extern rtx regno_use_in\t\t\tPARAMS ((unsigned int, rtx));\n extern int auto_inc_p\t\t\tPARAMS ((rtx));\n+extern int in_expr_list_p\t\tPARAMS ((rtx, rtx));\n extern void remove_node_from_expr_list\tPARAMS ((rtx, rtx *));\n extern int insns_safe_to_move_p         PARAMS ((rtx, rtx, rtx *));\n extern int loc_mentioned_in_p\t\tPARAMS ((rtx *, rtx));"}, {"sha": "427e3fbe9212f3dcd0996033e7c83ecf7a09e66f", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0d23589fe634ef3b7986a5dc0e389abfe4c917/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0d23589fe634ef3b7986a5dc0e389abfe4c917/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=5f0d23589fe634ef3b7986a5dc0e389abfe4c917", "patch": "@@ -1953,6 +1953,24 @@ remove_note (insn, note)\n   abort ();\n }\n \n+/* Search LISTP (an EXPR_LIST) for an entry whose first operand is NODE and\n+   return 1 if it is found.  A simple equality test is used to determine if\n+   NODE matches.  */\n+\n+int\n+in_expr_list_p (listp, node)\n+     rtx listp;\n+     rtx node;\n+{\n+  rtx x;\n+\n+  for (x = listp; x; x = XEXP (x, 1))\n+    if (node == XEXP (x, 0))\n+      return 1;\n+\n+  return 0;\n+}\n+\n /* Search LISTP (an EXPR_LIST) for an entry whose first operand is NODE and\n    remove that entry from the list if it is found.\n "}]}