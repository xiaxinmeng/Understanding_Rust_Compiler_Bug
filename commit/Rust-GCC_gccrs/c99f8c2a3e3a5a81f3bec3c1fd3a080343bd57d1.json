{"sha": "c99f8c2a3e3a5a81f3bec3c1fd3a080343bd57d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk5ZjhjMmEzZTNhNWE4MWYzYmVjM2MxZmQzYTA4MDM0M2JkNTdkMQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1999-02-24T11:50:54Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1999-02-24T11:50:54Z"}, "message": "loop.h (loop_insn_first_p): Declare.\n\n\t* loop.h (loop_insn_first_p): Declare.\n\t* loop.c (loop_insn_first_p): No longer static.\n\t* unroll.c (iteration_info) Fix comparison to\n\treg_iv_type->num_elements.\n\tBefore accessing reg_biv_class, check index against\n\tmax_reg_before_loop.\n\tFix and enable code for giv iterators.\n\t(loop_iterations): Compare with reg_iv_type->num_elements instead\n\tof with max_reg_before_loop.\n\nFrom-SVN: r25401", "tree": {"sha": "d564513348fedddafc05c01c247a96bf31e2b04b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d564513348fedddafc05c01c247a96bf31e2b04b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c99f8c2a3e3a5a81f3bec3c1fd3a080343bd57d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c99f8c2a3e3a5a81f3bec3c1fd3a080343bd57d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c99f8c2a3e3a5a81f3bec3c1fd3a080343bd57d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c99f8c2a3e3a5a81f3bec3c1fd3a080343bd57d1/comments", "author": null, "committer": null, "parents": [{"sha": "ddce352881f2a8fcea7e43d6e0354b5d03e1874e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddce352881f2a8fcea7e43d6e0354b5d03e1874e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddce352881f2a8fcea7e43d6e0354b5d03e1874e"}], "stats": {"total": 102, "additions": 64, "deletions": 38}, "files": [{"sha": "ff439fdc4c7c0f39a025e585abe99f4bec50d790", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c99f8c2a3e3a5a81f3bec3c1fd3a080343bd57d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c99f8c2a3e3a5a81f3bec3c1fd3a080343bd57d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c99f8c2a3e3a5a81f3bec3c1fd3a080343bd57d1", "patch": "@@ -1,3 +1,15 @@\n+Wed Feb 24 19:47:56 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* loop.h (loop_insn_first_p): Declare.\n+\t* loop.c (loop_insn_first_p): No longer static.\n+\t* unroll.c (iteration_info) Fix comparison to\n+\treg_iv_type->num_elements.\n+\tBefore accessing reg_biv_class, check index against\n+\tmax_reg_before_loop.\n+\tFix and enable code for giv iterators.\n+\t(loop_iterations): Compare with reg_iv_type->num_elements instead\n+\tof with max_reg_before_loop.\n+\n Wed Feb 24 19:17:11 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* unroll.c (unroll_loop): Avoid out-of-bounds index for local_regno."}, {"sha": "f65893360a30626cb12c0da42d5ffafd5fad08e8", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c99f8c2a3e3a5a81f3bec3c1fd3a080343bd57d1/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c99f8c2a3e3a5a81f3bec3c1fd3a080343bd57d1/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=c99f8c2a3e3a5a81f3bec3c1fd3a080343bd57d1", "patch": "@@ -376,8 +376,6 @@ static int indirect_jump_in_function_p PROTO((rtx));\n \n static int compute_luids PROTO((rtx, rtx, int));\n \n-static int loop_insn_first_p PROTO((rtx, rtx));\n-\n static int biv_elimination_giv_has_0_offset PROTO((struct induction *,\n \t\t\t\t\t\t   struct induction *, rtx));\n \f\n@@ -8112,7 +8110,7 @@ maybe_eliminate_biv (bl, loop_start, end, eliminate_p, threshold, insn_count)\n    This is like insn_first_p, except that we use the luid information if\n    available.  */\n \n-static int\n+int\n loop_insn_first_p (insn, reference)\n      rtx insn, reference;\n {"}, {"sha": "e164428d861fb5799404818b6a08304f2725de36", "filename": "gcc/loop.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c99f8c2a3e3a5a81f3bec3c1fd3a080343bd57d1/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c99f8c2a3e3a5a81f3bec3c1fd3a080343bd57d1/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=c99f8c2a3e3a5a81f3bec3c1fd3a080343bd57d1", "patch": "@@ -228,10 +228,6 @@ rtx get_condition_for_loop PROTO((rtx));\n void emit_iv_add_mult PROTO((rtx, rtx, rtx, rtx, rtx));\n rtx express_from PROTO((struct induction *, struct induction *));\n \n-/* Forward declarations for non-static functions declared in stmt.c.  */\n-void find_loop_tree_blocks PROTO((void));\n-void unroll_block_trees PROTO((void));\n-\n void unroll_loop PROTO((rtx, int, rtx, rtx, struct loop_info *, int));\n rtx biv_total_increment PROTO((struct iv_class *, rtx, rtx));\n unsigned HOST_WIDE_INT loop_iterations PROTO((rtx, rtx, struct loop_info *));\n@@ -244,7 +240,10 @@ rtx final_giv_value PROTO((struct induction *, rtx, rtx,\n \t\t\t   unsigned HOST_WIDE_INT));\n void emit_unrolled_add PROTO((rtx, rtx, rtx));\n int back_branch_in_range_p PROTO((rtx, rtx, rtx));\n+int loop_insn_first_p PROTO((rtx, rtx));\n \n extern int *loop_unroll_number;\n \n-\n+/* Forward declarations for non-static functions declared in stmt.c.  */\n+void find_loop_tree_blocks PROTO((void));\n+void unroll_block_trees PROTO((void));"}, {"sha": "7953416a3d5879f96711f32dc125f0f4907f08f6", "filename": "gcc/unroll.c", "status": "modified", "additions": 47, "deletions": 30, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c99f8c2a3e3a5a81f3bec3c1fd3a080343bd57d1/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c99f8c2a3e3a5a81f3bec3c1fd3a080343bd57d1/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=c99f8c2a3e3a5a81f3bec3c1fd3a080343bd57d1", "patch": "@@ -1404,10 +1404,9 @@ precondition_loop_p (loop_start, loop_info,\n       return 0;\n     }\n \n-  /* ??? Note that if iteration_info is modifed to allow GIV iterators\n-     such as \"while (i-- > 0)\", the initial value will be one too small.\n-     In this case, loop_iteration_var could be used to determine\n-     the correct initial value, provided the loop has not been reversed.\n+  /* Note that iteration_info biases the initial value for GIV iterators\n+     such as \"while (i-- > 0)\" so that we can calculate the number of\n+     iterations just like for BIV iterators.\n \n      Also note that the absolute values of initial_value and\n      final_value are unimportant as only their difference is used for\n@@ -2364,7 +2363,7 @@ iteration_info (iteration_var, initial_value, increment, loop_start, loop_end)\n \n   /* If this is a new register, can't handle it since we don't have any\n      reg_iv_type entry for it.  */\n-  if ((unsigned) REGNO (iteration_var) > reg_iv_type->num_elements)\n+  if ((unsigned) REGNO (iteration_var) >= reg_iv_type->num_elements)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n@@ -2392,6 +2391,12 @@ iteration_info (iteration_var, initial_value, increment, loop_start, loop_end)\n     }\n   else if (REG_IV_TYPE (REGNO (iteration_var)) == BASIC_INDUCT)\n     {\n+      /* When reg_iv_type / reg_iv_info is resized for biv increments\n+\t that are turned into givs, reg_biv_class is not resized.\n+\t So check here that we don't make an out-of-bounds access.  */\n+      if (REGNO (iteration_var) >= max_reg_before_loop)\n+\tabort ();\n+\n       /* Grab initial value, only useful if it is a constant.  */\n       bl = reg_biv_class[REGNO (iteration_var)];\n       *initial_value = bl->initial_value;\n@@ -2400,34 +2405,46 @@ iteration_info (iteration_var, initial_value, increment, loop_start, loop_end)\n     }\n   else if (REG_IV_TYPE (REGNO (iteration_var)) == GENERAL_INDUCT)\n     {\n-#if 1\n-      /* ??? The code below does not work because the incorrect number of\n-\t iterations is calculated when the biv is incremented after the giv\n-\t is set (which is the usual case).  This can probably be accounted\n-\t for by biasing the initial_value by subtracting the amount of the\n-\t increment that occurs between the giv set and the giv test.  However,\n-\t a giv as an iterator is very rare, so it does not seem worthwhile\n-\t to handle this.  */\n-      /* ??? An example failure is: i = 6; do {;} while (i++ < 9).  */\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Loop unrolling: Giv iterators are not handled.\\n\");\n-      return;\n-#else\n-      /* Initial value is mult_val times the biv's initial value plus\n-\t add_val.  Only useful if it is a constant.  */\n-      v = REG_IV_INFO (REGNO (iteration_var));\n+      HOST_WIDE_INT offset = 0;\n+      struct induction *v = REG_IV_INFO (REGNO (iteration_var));\n+\n+      if (REGNO (v->src_reg) >= max_reg_before_loop)\n+\tabort ();\n+\n       bl = reg_biv_class[REGNO (v->src_reg)];\n-      *initial_value = fold_rtx_mult_add (v->mult_val, bl->initial_value,\n-\t\t\t\t\t  v->add_val, v->mode);\n \n       /* Increment value is mult_val times the increment value of the biv.  */\n \n       *increment = biv_total_increment (bl, loop_start, loop_end);\n       if (*increment)\n-\t*increment = fold_rtx_mult_add (v->mult_val, *increment, const0_rtx,\n-\t\t\t\t\tv->mode);\n-#endif\n+\t{\n+\t  struct induction *biv_inc;\n+\n+\t  *increment\n+\t    = fold_rtx_mult_add (v->mult_val, *increment, const0_rtx, v->mode);\n+\t  /* The caller assumes that one full increment has occured at the\n+\t     first loop test.  But that's not true when the biv is incremented\n+\t     after the giv is set (which is the usual case), e.g.:\n+\t     i = 6; do {;} while (i++ < 9) .\n+\t     Therefore, we bias the initial value by subtracting the amount of\n+\t     the increment that occurs between the giv set and the giv test.  */\n+\t  for (biv_inc = bl->biv; biv_inc; biv_inc = biv_inc->next_iv)\n+\t    {\n+\t      if (loop_insn_first_p (v->insn, biv_inc->insn))\n+\t\toffset -= INTVAL (biv_inc->add_val);\n+\t    }\n+\t  offset *= INTVAL (v->mult_val);\n+\t}\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Loop unrolling: Giv iterator, initial value bias %ld.\\n\",\n+\t\t (long) offset);\n+      /* Initial value is mult_val times the biv's initial value plus\n+\t add_val.  Only useful if it is a constant.  */\n+      *initial_value\n+\t= fold_rtx_mult_add (v->mult_val,\n+\t\t\t     plus_constant (bl->initial_value, offset),\n+\t\t\t     v->add_val, v->mode);\n     }\n   else\n     {\n@@ -3626,10 +3643,10 @@ loop_iterations (loop_start, loop_end, loop_info)\n       return 0;\n     }\n \n-  /* Loop iterations is always called before any new registers are created\n-     now, so this should never occur.  */\n+  /* The only new registers that care created before loop iterations are\n+     givs made from biv increments, so this should never occur.  */\n \n-  if (REGNO (iteration_var) >= max_reg_before_loop)\n+  if ((unsigned) REGNO (iteration_var) >= reg_iv_type->num_elements)\n     abort ();\n \n   iteration_info (iteration_var, &initial_value, &increment,"}]}