{"sha": "119092c17a0c6e947f774692849dedb84acb53f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE5MDkyYzE3YTBjNmU5NDdmNzc0NjkyODQ5ZGVkYjg0YWNiNTNmMg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-04-28T06:42:20Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-04-28T06:42:20Z"}, "message": "tree-vrp.c (assert_info): New struct.\n\n2017-04-28  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vrp.c (assert_info): New struct.\n\t(add_assert_info): New helper.\n\t(register_edge_assert_for_2): Refactor to add asserts to a vector\n\tof assert_info.\n\t(register_edge_assert_for_1): Likewise.\n\t(register_edge_assert_for): Likewise.\n\t(finish_register_edge_assert_for): New helper actually registering\n\tasserts where live on edge.\n\t(find_conditional_asserts): Adjust.\n\t(find_switch_asserts): Likewise.\n\t(evrp_dom_walker::try_find_new_range): Generalize.\n\t(evrp_dom_walker::before_dom_children): Use register_edge_assert_for.\n\n\t* gcc.dg/tree-ssa/evrp7.c: New testcase.\n\t* gcc.dg/tree-ssa/evrp8.c: Likewise.\n\t* gcc.dg/tree-ssa/evrp9.c: Likewise.\n\t* gcc.dg/tree-ssa/vrp35.c: Disable EVRP.\n\t* gcc.dg/tree-ssa/vrp36.c: Likewise.\n\t* gcc.dg/tree-ssa/pr49039.c: Likewise.\n\nFrom-SVN: r247362", "tree": {"sha": "763e1c086d4cd69cd4e3e9cd6d1df3e14215ead6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/763e1c086d4cd69cd4e3e9cd6d1df3e14215ead6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/119092c17a0c6e947f774692849dedb84acb53f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/119092c17a0c6e947f774692849dedb84acb53f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/119092c17a0c6e947f774692849dedb84acb53f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/119092c17a0c6e947f774692849dedb84acb53f2/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e223180e6adefdfc8a19a74426d131157b62fcfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e223180e6adefdfc8a19a74426d131157b62fcfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e223180e6adefdfc8a19a74426d131157b62fcfa"}], "stats": {"total": 318, "additions": 210, "deletions": 108}, "files": [{"sha": "aa39842e400e8a81be7d78df6b420fc0925b200e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/119092c17a0c6e947f774692849dedb84acb53f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/119092c17a0c6e947f774692849dedb84acb53f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=119092c17a0c6e947f774692849dedb84acb53f2", "patch": "@@ -1,3 +1,18 @@\n+2017-04-28  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vrp.c (assert_info): New struct.\n+\t(add_assert_info): New helper.\n+\t(register_edge_assert_for_2): Refactor to add asserts to a vector\n+\tof assert_info.\n+\t(register_edge_assert_for_1): Likewise.\n+\t(register_edge_assert_for): Likewise.\n+\t(finish_register_edge_assert_for): New helper actually registering\n+\tasserts where live on edge.\n+\t(find_conditional_asserts): Adjust.\n+\t(find_switch_asserts): Likewise.\n+\t(evrp_dom_walker::try_find_new_range): Generalize.\n+\t(evrp_dom_walker::before_dom_children): Use register_edge_assert_for.\n+\n 2017-04-27  Marek Polacek  <polacek@redhat.com>\n \n \tPR sanitizer/80349"}, {"sha": "910f42d87ae7675ee3476b8bc965ded16f2e242d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/119092c17a0c6e947f774692849dedb84acb53f2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/119092c17a0c6e947f774692849dedb84acb53f2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=119092c17a0c6e947f774692849dedb84acb53f2", "patch": "@@ -1,3 +1,12 @@\n+2017-04-28  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/evrp7.c: New testcase.\n+\t* gcc.dg/tree-ssa/evrp8.c: Likewise.\n+\t* gcc.dg/tree-ssa/evrp9.c: Likewise.\n+\t* gcc.dg/tree-ssa/vrp35.c: Disable EVRP.\n+\t* gcc.dg/tree-ssa/vrp36.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr49039.c: Likewise.\n+ \n 2017-04-27  Marek Polacek  <polacek@redhat.com>\n \n \tPR sanitizer/80349"}, {"sha": "16fbe65e4d9e69c465bc76078f81e4ff7a222e18", "filename": "gcc/testsuite/gcc.dg/tree-ssa/evrp7.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/119092c17a0c6e947f774692849dedb84acb53f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/119092c17a0c6e947f774692849dedb84acb53f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp7.c?ref=119092c17a0c6e947f774692849dedb84acb53f2", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-evrp-details\" } */\n+\n+int test1(int i, int k)\n+{\n+  if (i > 0 && i <= 5 && k >= 10 && k < 42)\n+    {\n+      int j = i + 1 + k;\n+      return j == 10;\n+    }\n+  return 1;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Removing dead stmt \\[^\\r\\n\\]* = j_.* == 10\" \"evrp\" } } */"}, {"sha": "b7e5c7aa2de8f090a6e0d6ec17aff878fb48909c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/evrp8.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/119092c17a0c6e947f774692849dedb84acb53f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/119092c17a0c6e947f774692849dedb84acb53f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp8.c?ref=119092c17a0c6e947f774692849dedb84acb53f2", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-evrp-details\" } */\n+\n+int foo(int i)\n+{\n+  if (i < 0 || i >= 5)\n+    return i == 1;\n+  return 1;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Removing dead stmt \\[^\\r\\n\\]* = i_.* == 1\" \"evrp\" } } */"}, {"sha": "6e7828e43405b7c80d22da59064f5cb0c45c6064", "filename": "gcc/testsuite/gcc.dg/tree-ssa/evrp9.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/119092c17a0c6e947f774692849dedb84acb53f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/119092c17a0c6e947f774692849dedb84acb53f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp9.c?ref=119092c17a0c6e947f774692849dedb84acb53f2", "patch": "@@ -0,0 +1,28 @@\n+/* PR tree-optimization/49039 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-evrp\" } */\n+\n+extern void bar (void);\n+\n+void\n+foo (unsigned int x, unsigned int y)\n+{\n+  unsigned int minv, maxv;\n+  if (x >= 3 && x <= 6)\n+    return;\n+  if (y >= 5 && y <= 8)\n+    return;\n+  minv = x < y ? x : y;\n+  maxv = x > y ? x : y;\n+  if (minv == 5)\n+    bar ();\n+  if (minv == 6)\n+    bar ();\n+  if (maxv == 5)\n+    bar ();\n+  if (maxv == 6)\n+    bar ();\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"== 5\" \"evrp\" } } */\n+/* { dg-final { scan-tree-dump-not \"== 6\" \"evrp\" } } */"}, {"sha": "4bc0a8175a0f7f18e07ffaf5d8239e56c111382e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr49039.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/119092c17a0c6e947f774692849dedb84acb53f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr49039.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/119092c17a0c6e947f774692849dedb84acb53f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr49039.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr49039.c?ref=119092c17a0c6e947f774692849dedb84acb53f2", "patch": "@@ -1,6 +1,6 @@\n /* PR tree-optimization/49039 */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+/* { dg-options \"-O2 -fdisable-tree-evrp -fdump-tree-vrp1\" } */\n \n extern void bar (void);\n "}, {"sha": "a372a18cc4355ea26a518476dab8ffdd0ab42a03", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp35.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/119092c17a0c6e947f774692849dedb84acb53f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp35.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/119092c17a0c6e947f774692849dedb84acb53f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp35.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp35.c?ref=119092c17a0c6e947f774692849dedb84acb53f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp1-details\" } */\n+/* { dg-options \"-O2 -fdisable-tree-evrp -fdump-tree-vrp1-details\" } */\n \n int test1(int i, int k)\n {"}, {"sha": "1f77b539d70e07669d1c85960a9387f947362d32", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp36.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/119092c17a0c6e947f774692849dedb84acb53f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp36.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/119092c17a0c6e947f774692849dedb84acb53f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp36.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp36.c?ref=119092c17a0c6e947f774692849dedb84acb53f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp1-details\" } */\n+/* { dg-options \"-O2 -fdisable-tree-evrp -fdump-tree-vrp1-details\" } */\n \n int foo(int i)\n {"}, {"sha": "df5e42674917125e4895c241e4bc65ad8f025af1", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 130, "deletions": 105, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/119092c17a0c6e947f774692849dedb84acb53f2/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/119092c17a0c6e947f774692849dedb84acb53f2/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=119092c17a0c6e947f774692849dedb84acb53f2", "patch": "@@ -89,6 +89,21 @@ static tree vrp_evaluate_conditional_warnv_with_ops (enum tree_code,\n \t\t\t\t\t\t     tree, tree, bool, bool *,\n \t\t\t\t\t\t     bool *);\n \n+struct assert_info\n+{\n+  /* Predicate code for the ASSERT_EXPR.  Must be COMPARISON_CLASS_P.  */\n+  enum tree_code comp_code;\n+\n+  /* Name to register the assert for.  */\n+  tree name;\n+\n+  /* Value being compared against.  */\n+  tree val;\n+\n+  /* Expression to compare.  */\n+  tree expr;\n+};\n+\n /* Location information for ASSERT_EXPRs.  Each instance of this\n    structure describes an ASSERT_EXPR for an SSA name.  Since a single\n    SSA name may have more than one assertion associated with it, these\n@@ -5029,6 +5044,19 @@ debug_all_asserts (void)\n   dump_all_asserts (stderr);\n }\n \n+/* Push the assert info for NAME, EXPR, COMP_CODE and VAL to ASSERTS.  */\n+\n+static void\n+add_assert_info (vec<assert_info> &asserts,\n+\t\t tree name, tree expr, enum tree_code comp_code, tree val)\n+{\n+  assert_info info;\n+  info.comp_code = comp_code;\n+  info.name = name;\n+  info.val = val;\n+  info.expr = expr;\n+  asserts.safe_push (info);\n+}\n \n /* If NAME doesn't have an ASSERT_EXPR registered for asserting\n    'EXPR COMP_CODE VAL' at a location that dominates block BB or\n@@ -5357,9 +5385,10 @@ overflow_comparison_p (tree_code code, tree name, tree val,\n    Invert the condition COND if INVERT is true.  */\n \n static void\n-register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n+register_edge_assert_for_2 (tree name, edge e,\n \t\t\t    enum tree_code cond_code,\n-\t\t\t    tree cond_op0, tree cond_op1, bool invert)\n+\t\t\t    tree cond_op0, tree cond_op1, bool invert,\n+\t\t\t    vec<assert_info> &asserts)\n {\n   tree val;\n   enum tree_code comp_code;\n@@ -5370,20 +5399,15 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t\t\t\t\t\tinvert, &comp_code, &val))\n     return;\n \n-  /* Only register an ASSERT_EXPR if NAME was found in the sub-graph\n-     reachable from E.  */\n-  if (live_on_edge (e, name))\n+  /* Queue the assert.  */\n+  tree x;\n+  if (overflow_comparison_p (comp_code, name, val, false, &x))\n     {\n-      tree x;\n-      if (overflow_comparison_p (comp_code, name, val, false, &x))\n-\t{\n-\t  enum tree_code new_code\n-\t    = ((comp_code == GT_EXPR || comp_code == GE_EXPR)\n-\t       ? GT_EXPR : LE_EXPR);\n-\t  register_new_assert_for (name, name, new_code, x, NULL, e, bsi);\n-\t}\n-      register_new_assert_for (name, name, comp_code, val, NULL, e, bsi);\n+      enum tree_code new_code = ((comp_code == GT_EXPR || comp_code == GE_EXPR)\n+\t\t\t\t ? GT_EXPR : LE_EXPR);\n+      add_assert_info (asserts, name, name, new_code, x);\n     }\n+  add_assert_info (asserts, name, name, comp_code, val);\n \n   /* In the case of NAME <= CST and NAME being defined as\n      NAME = (unsigned) NAME2 + CST2 we can assert NAME2 >= -CST2\n@@ -5423,8 +5447,7 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n       \t  && TREE_CODE (name3) == SSA_NAME\n \t  && (cst2 == NULL_TREE\n \t      || TREE_CODE (cst2) == INTEGER_CST)\n-\t  && INTEGRAL_TYPE_P (TREE_TYPE (name3))\n-\t  && live_on_edge (e, name3))\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (name3)))\n \t{\n \t  tree tmp;\n \n@@ -5442,15 +5465,14 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \n-\t  register_new_assert_for (name3, tmp, comp_code, val, NULL, e, bsi);\n+\t  add_assert_info (asserts, name3, tmp, comp_code, val);\n \t}\n \n       /* If name2 is used later, create an ASSERT_EXPR for it.  */\n       if (name2 != NULL_TREE\n       \t  && TREE_CODE (name2) == SSA_NAME\n \t  && TREE_CODE (cst2) == INTEGER_CST\n-\t  && INTEGRAL_TYPE_P (TREE_TYPE (name2))\n-\t  && live_on_edge (e, name2))\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (name2)))\n \t{\n \t  tree tmp;\n \n@@ -5470,7 +5492,7 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \n-\t  register_new_assert_for (name2, tmp, comp_code, val, NULL, e, bsi);\n+\t  add_assert_info (asserts, name2, tmp, comp_code, val);\n \t}\n     }\n \n@@ -5496,8 +5518,7 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t    continue;\n \n \t  tree name2 = gimple_assign_lhs (use_stmt);\n-\t  if (TREE_CODE (name2) != SSA_NAME\n-\t      || !live_on_edge (e, name2))\n+\t  if (TREE_CODE (name2) != SSA_NAME)\n \t    continue;\n \n \t  enum tree_code code = gimple_assign_rhs_code (use_stmt);\n@@ -5525,8 +5546,7 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \n \t  if (TREE_OVERFLOW_P (cst))\n \t    cst = drop_tree_overflow (cst);\n-\t  register_new_assert_for (name2, name2, comp_code, cst,\n-\t\t\t\t   NULL, e, bsi);\n+\t  add_assert_info (asserts, name2, name2, comp_code, cst);\n \t}\n     }\n  \n@@ -5552,15 +5572,14 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t  tree op0 = gimple_assign_rhs1 (def_stmt);\n \t  tree op1 = gimple_assign_rhs2 (def_stmt);\n \t  if (TREE_CODE (op0) == SSA_NAME\n-\t      && TREE_CODE (op1) == INTEGER_CST\n-\t      && live_on_edge (e, op0))\n+\t      && TREE_CODE (op1) == INTEGER_CST)\n \t    {\n \t      enum tree_code reverse_op = (rhs_code == PLUS_EXPR\n \t\t\t\t\t   ? MINUS_EXPR : PLUS_EXPR);\n \t      op1 = int_const_binop (reverse_op, val, op1);\n \t      if (TREE_OVERFLOW (op1))\n \t\top1 = drop_tree_overflow (op1);\n-\t      register_new_assert_for (op0, op0, comp_code, op1, NULL, e, bsi);\n+\t      add_assert_info (asserts, op0, op0, comp_code, op1);\n \t    }\n \t}\n \n@@ -5578,8 +5597,7 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t      && prec == TYPE_PRECISION (TREE_TYPE (name2))\n \t      && (comp_code == LE_EXPR || comp_code == GT_EXPR\n \t\t  || !tree_int_cst_equal (val,\n-\t\t\t\t\t  TYPE_MIN_VALUE (TREE_TYPE (val))))\n-\t      && live_on_edge (e, name2))\n+\t\t\t\t\t  TYPE_MIN_VALUE (TREE_TYPE (val)))))\n \t    {\n \t      tree tmp, cst;\n \t      enum tree_code new_comp_code = comp_code;\n@@ -5606,8 +5624,7 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t\t  fprintf (dump_file, \"\\n\");\n \t\t}\n \n-\t      register_new_assert_for (name2, tmp, new_comp_code, cst, NULL,\n-\t\t\t\t       e, bsi);\n+\t      add_assert_info (asserts, name2, tmp, new_comp_code, cst);\n \t    }\n \t}\n \n@@ -5623,8 +5640,7 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t      && tree_fits_uhwi_p (cst2)\n \t      && INTEGRAL_TYPE_P (TREE_TYPE (name2))\n \t      && IN_RANGE (tree_to_uhwi (cst2), 1, prec - 1)\n-\t      && prec == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (val)))\n-\t      && live_on_edge (e, name2))\n+\t      && prec == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (val))))\n \t    {\n \t      mask = wi::mask (tree_to_uhwi (cst2), false, prec);\n \t      val2 = fold_binary (LSHIFT_EXPR, TREE_TYPE (val), val, cst2);\n@@ -5682,8 +5698,7 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t\t  fprintf (dump_file, \"\\n\");\n \t\t}\n \n-\t      register_new_assert_for (name2, tmp, new_comp_code, new_val,\n-\t\t\t\t       NULL, e, bsi);\n+\t      add_assert_info (asserts, name2, tmp, new_comp_code, new_val);\n \t    }\n \t}\n \n@@ -5728,12 +5743,10 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t\t  if (!CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt2))\n \t\t      || !INTEGRAL_TYPE_P (TREE_TYPE (names[1]))\n \t\t      || (TYPE_PRECISION (TREE_TYPE (name2))\n-\t\t\t  != TYPE_PRECISION (TREE_TYPE (names[1])))\n-\t\t      || !live_on_edge (e, names[1]))\n+\t\t\t  != TYPE_PRECISION (TREE_TYPE (names[1]))))\n \t\t    names[1] = NULL_TREE;\n \t\t}\n-\t      if (live_on_edge (e, name2))\n-\t\tnames[0] = name2;\n+\t      names[0] = name2;\n \t    }\n \t}\n       if (names[0] || names[1])\n@@ -5924,8 +5937,7 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t\t\tfprintf (dump_file, \"\\n\");\n \t\t      }\n \n-\t\t    register_new_assert_for (names[i], tmp, LE_EXPR,\n-\t\t\t\t\t     new_val, NULL, e, bsi);\n+\t\t    add_assert_info (asserts, names[i], tmp, LE_EXPR, new_val);\n \t\t  }\n \t    }\n \t}\n@@ -5941,7 +5953,7 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \n static void\n register_edge_assert_for_1 (tree op, enum tree_code code,\n-\t\t\t    edge e, gimple_stmt_iterator bsi)\n+\t\t\t    edge e, vec<assert_info> &asserts)\n {\n   gimple *op_def;\n   tree val;\n@@ -5951,13 +5963,9 @@ register_edge_assert_for_1 (tree op, enum tree_code code,\n   if (TREE_CODE (op) != SSA_NAME)\n     return;\n \n-  /* We know that OP will have a zero or nonzero value.  If OP is used\n-     more than once go ahead and register an assert for OP.  */\n-  if (live_on_edge (e, op))\n-    {\n-      val = build_int_cst (TREE_TYPE (op), 0);\n-      register_new_assert_for (op, op, code, val, NULL, e, bsi);\n-    }\n+  /* We know that OP will have a zero or nonzero value.  */\n+  val = build_int_cst (TREE_TYPE (op), 0);\n+  add_assert_info (asserts, op, op, code, val);\n \n   /* Now look at how OP is set.  If it's set from a comparison,\n      a truth operation or some bit operations, then we may be able\n@@ -5975,9 +5983,9 @@ register_edge_assert_for_1 (tree op, enum tree_code code,\n       tree op1 = gimple_assign_rhs2 (op_def);\n \n       if (TREE_CODE (op0) == SSA_NAME)\n-        register_edge_assert_for_2 (op0, e, bsi, rhs_code, op0, op1, invert);\n+        register_edge_assert_for_2 (op0, e, rhs_code, op0, op1, invert, asserts);\n       if (TREE_CODE (op1) == SSA_NAME)\n-        register_edge_assert_for_2 (op1, e, bsi, rhs_code, op0, op1, invert);\n+        register_edge_assert_for_2 (op1, e, rhs_code, op0, op1, invert, asserts);\n     }\n   else if ((code == NE_EXPR\n \t    && gimple_assign_rhs_code (op_def) == BIT_AND_EXPR)\n@@ -5989,22 +5997,22 @@ register_edge_assert_for_1 (tree op, enum tree_code code,\n       tree op1 = gimple_assign_rhs2 (op_def);\n       if (TREE_CODE (op0) == SSA_NAME\n \t  && has_single_use (op0))\n-\tregister_edge_assert_for_1 (op0, code, e, bsi);\n+\tregister_edge_assert_for_1 (op0, code, e, asserts);\n       if (TREE_CODE (op1) == SSA_NAME\n \t  && has_single_use (op1))\n-\tregister_edge_assert_for_1 (op1, code, e, bsi);\n+\tregister_edge_assert_for_1 (op1, code, e, asserts);\n     }\n   else if (gimple_assign_rhs_code (op_def) == BIT_NOT_EXPR\n \t   && TYPE_PRECISION (TREE_TYPE (gimple_assign_lhs (op_def))) == 1)\n     {\n       /* Recurse, flipping CODE.  */\n       code = invert_tree_comparison (code, false);\n-      register_edge_assert_for_1 (gimple_assign_rhs1 (op_def), code, e, bsi);\n+      register_edge_assert_for_1 (gimple_assign_rhs1 (op_def), code, e, asserts);\n     }\n   else if (gimple_assign_rhs_code (op_def) == SSA_NAME)\n     {\n       /* Recurse through the copy.  */\n-      register_edge_assert_for_1 (gimple_assign_rhs1 (op_def), code, e, bsi);\n+      register_edge_assert_for_1 (gimple_assign_rhs1 (op_def), code, e, asserts);\n     }\n   else if (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (op_def)))\n     {\n@@ -6014,7 +6022,7 @@ register_edge_assert_for_1 (tree op, enum tree_code code,\n       if (INTEGRAL_TYPE_P (TREE_TYPE (rhs))\n \t  && (TYPE_PRECISION (TREE_TYPE (rhs))\n \t      <= TYPE_PRECISION (TREE_TYPE (op))))\n-\tregister_edge_assert_for_1 (rhs, code, e, bsi);\n+\tregister_edge_assert_for_1 (rhs, code, e, asserts);\n     }\n }\n \n@@ -6023,9 +6031,9 @@ register_edge_assert_for_1 (tree op, enum tree_code code,\n    SI.  */\n \n static void\n-register_edge_assert_for (tree name, edge e, gimple_stmt_iterator si,\n+register_edge_assert_for (tree name, edge e,\n \t\t\t  enum tree_code cond_code, tree cond_op0,\n-\t\t\t  tree cond_op1)\n+\t\t\t  tree cond_op1, vec<assert_info> &asserts)\n {\n   tree val;\n   enum tree_code comp_code;\n@@ -6043,8 +6051,8 @@ register_edge_assert_for (tree name, edge e, gimple_stmt_iterator si,\n     return;\n \n   /* Register ASSERT_EXPRs for name.  */\n-  register_edge_assert_for_2 (name, e, si, cond_code, cond_op0,\n-\t\t\t      cond_op1, is_else_edge);\n+  register_edge_assert_for_2 (name, e, cond_code, cond_op0,\n+\t\t\t      cond_op1, is_else_edge, asserts);\n \n \n   /* If COND is effectively an equality test of an SSA_NAME against\n@@ -6064,8 +6072,8 @@ register_edge_assert_for (tree name, edge e, gimple_stmt_iterator si,\n \t{\n \t  tree op0 = gimple_assign_rhs1 (def_stmt);\n \t  tree op1 = gimple_assign_rhs2 (def_stmt);\n-\t  register_edge_assert_for_1 (op0, NE_EXPR, e, si);\n-\t  register_edge_assert_for_1 (op1, NE_EXPR, e, si);\n+\t  register_edge_assert_for_1 (op0, NE_EXPR, e, asserts);\n+\t  register_edge_assert_for_1 (op1, NE_EXPR, e, asserts);\n \t}\n     }\n \n@@ -6086,12 +6094,28 @@ register_edge_assert_for (tree name, edge e, gimple_stmt_iterator si,\n \t{\n \t  tree op0 = gimple_assign_rhs1 (def_stmt);\n \t  tree op1 = gimple_assign_rhs2 (def_stmt);\n-\t  register_edge_assert_for_1 (op0, EQ_EXPR, e, si);\n-\t  register_edge_assert_for_1 (op1, EQ_EXPR, e, si);\n+\t  register_edge_assert_for_1 (op0, EQ_EXPR, e, asserts);\n+\t  register_edge_assert_for_1 (op1, EQ_EXPR, e, asserts);\n \t}\n     }\n }\n \n+/* Finish found ASSERTS for E and register them at GSI.  */\n+\n+static void\n+finish_register_edge_assert_for (edge e, gimple_stmt_iterator gsi,\n+\t\t\t\t vec<assert_info> &asserts)\n+{\n+  for (unsigned i = 0; i < asserts.length (); ++i)\n+    /* Only register an ASSERT_EXPR if NAME was found in the sub-graph\n+       reachable from E.  */\n+    if (live_on_edge (e, asserts[i].name))\n+      register_new_assert_for (asserts[i].name, asserts[i].expr,\n+\t\t\t       asserts[i].comp_code, asserts[i].val,\n+\t\t\t       NULL, e, gsi);\n+}\n+\n+\n \n /* Determine whether the outgoing edges of BB should receive an\n    ASSERT_EXPR for each of the operands of BB's LAST statement.\n@@ -6123,11 +6147,13 @@ find_conditional_asserts (basic_block bb, gcond *last)\n \n       /* Register the necessary assertions for each operand in the\n \t conditional predicate.  */\n+      auto_vec<assert_info, 8> asserts;\n       FOR_EACH_SSA_TREE_OPERAND (op, last, iter, SSA_OP_USE)\n-\tregister_edge_assert_for (op, e, bsi,\n+\tregister_edge_assert_for (op, e,\n \t\t\t\t  gimple_cond_code (last),\n \t\t\t\t  gimple_cond_lhs (last),\n-\t\t\t\t  gimple_cond_rhs (last));\n+\t\t\t\t  gimple_cond_rhs (last), asserts);\n+      finish_register_edge_assert_for (e, bsi, asserts);\n     }\n }\n \n@@ -6239,12 +6265,16 @@ find_switch_asserts (basic_block bb, gswitch *last)\n \n       /* Register the necessary assertions for the operand in the\n \t SWITCH_EXPR.  */\n-      register_edge_assert_for (op, e, bsi,\n+      auto_vec<assert_info, 8> asserts;\n+      register_edge_assert_for (op, e,\n \t\t\t\tmax ? GE_EXPR : EQ_EXPR,\n-\t\t\t\top, fold_convert (TREE_TYPE (op), min));\n+\t\t\t\top, fold_convert (TREE_TYPE (op), min),\n+\t\t\t\tasserts);\n       if (max)\n-\tregister_edge_assert_for (op, e, bsi, LE_EXPR, op,\n-\t\t\t\t  fold_convert (TREE_TYPE (op), max));\n+\tregister_edge_assert_for (op, e, LE_EXPR, op,\n+\t\t\t\t  fold_convert (TREE_TYPE (op), max),\n+\t\t\t\t  asserts);\n+      finish_register_edge_assert_for (e, bsi, asserts);\n     }\n \n   XDELETEVEC (ci);\n@@ -6293,8 +6323,11 @@ find_switch_asserts (basic_block bb, gswitch *last)\n       if (max == NULL_TREE)\n \t{\n \t  /* Register the assertion OP != MIN.  */\n+\t  auto_vec<assert_info, 8> asserts;\n \t  min = fold_convert (TREE_TYPE (op), min);\n-\t  register_edge_assert_for (op, default_edge, bsi, NE_EXPR, op, min);\n+\t  register_edge_assert_for (op, default_edge, NE_EXPR, op, min,\n+\t\t\t\t    asserts);\n+\t  finish_register_edge_assert_for (default_edge, bsi, asserts);\n \t}\n       else\n \t{\n@@ -11160,7 +11193,7 @@ class evrp_dom_walker : public dom_walker\n   virtual void after_dom_children (basic_block);\n   void push_value_range (tree var, value_range *vr);\n   value_range *pop_value_range (tree var);\n-  value_range *try_find_new_range (tree op, tree_code code, tree limit);\n+  value_range *try_find_new_range (tree, tree op, tree_code code, tree limit);\n \n   /* Cond_stack holds the old VR.  */\n   auto_vec<std::pair <tree, value_range*> > stack;\n@@ -11169,19 +11202,18 @@ class evrp_dom_walker : public dom_walker\n   auto_vec<gimple *> stmts_to_remove;\n };\n \n-/*  Find new range for OP such that (OP CODE LIMIT) is true.  */\n+/*  Find new range for NAME such that (OP CODE LIMIT) is true.  */\n \n value_range *\n-evrp_dom_walker::try_find_new_range (tree op, tree_code code, tree limit)\n+evrp_dom_walker::try_find_new_range (tree name,\n+\t\t\t\t     tree op, tree_code code, tree limit)\n {\n   value_range vr = VR_INITIALIZER;\n-  value_range *old_vr = get_value_range (op);\n+  value_range *old_vr = get_value_range (name);\n \n   /* Discover VR when condition is true.  */\n-  extract_range_for_var_from_comparison_expr (op, code, op,\n+  extract_range_for_var_from_comparison_expr (name, code, op,\n \t\t\t\t\t      limit, &vr);\n-  if (old_vr->type == VR_RANGE || old_vr->type == VR_ANTI_RANGE)\n-    vrp_intersect_ranges (&vr, old_vr);\n   /* If we found any usable VR, set the VR to ssa_name and create a\n      PUSH old value in the stack with the old VR.  */\n   if (vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE)\n@@ -11245,36 +11277,29 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t  /* Entering a new scope.  Try to see if we can find a VR\n \t     here.  */\n \t  tree op1 = gimple_cond_rhs (stmt);\n-\t  tree_code code = gimple_cond_code (stmt);\n-\n \t  if (TREE_OVERFLOW_P (op1))\n \t    op1 = drop_tree_overflow (op1);\n+\t  tree_code code = gimple_cond_code (stmt);\n \n-\t  /* If condition is false, invert the cond.  */\n-\t  if (pred_e->flags & EDGE_FALSE_VALUE)\n-\t    code = invert_tree_comparison (gimple_cond_code (stmt),\n-\t\t\t\t\t   HONOR_NANS (op0));\n-\t  /* Add VR when (OP0 CODE OP1) condition is true.  */\n-\t  value_range *op0_range = try_find_new_range (op0, code, op1);\n-\n-\t  /* Register ranges for y in x < y where\n-\t     y might have ranges that are useful.  */\n-\t  tree limit;\n-\t  tree_code new_code;\n-\t  if (TREE_CODE (op1) == SSA_NAME\n-\t      && extract_code_and_val_from_cond_with_ops (op1, code,\n-\t\t\t\t\t\t\t  op0, op1,\n-\t\t\t\t\t\t\t  false,\n-\t\t\t\t\t\t\t  &new_code, &limit))\n+\t  auto_vec<assert_info, 8> asserts;\n+\t  register_edge_assert_for (op0, pred_e, code, op0, op1, asserts);\n+\t  if (TREE_CODE (op1) == SSA_NAME)\n+\t    register_edge_assert_for (op1, pred_e, code, op0, op1, asserts);\n+\n+\t  auto_vec<std::pair<tree, value_range *>, 8> vrs;\n+\t  for (unsigned i = 0; i < asserts.length (); ++i)\n \t    {\n-\t      /* Add VR when (OP1 NEW_CODE LIMIT) condition is true.  */\n-\t      value_range *op1_range = try_find_new_range (op1, new_code, limit);\n-\t      if (op1_range)\n-\t\tpush_value_range (op1, op1_range);\n+\t      value_range *vr = try_find_new_range (asserts[i].name,\n+\t\t\t\t\t\t    asserts[i].expr,\n+\t\t\t\t\t\t    asserts[i].comp_code,\n+\t\t\t\t\t\t    asserts[i].val);\n+\t      if (vr)\n+\t\tvrs.safe_push (std::make_pair (asserts[i].name, vr));\n \t    }\n-\n-\t  if (op0_range)\n-\t    push_value_range (op0, op0_range);\n+\t  /* Push updated ranges only after finding all of them to avoid\n+\t     ordering issues that can lead to worse ranges.  */\n+\t  for (unsigned i = 0; i < vrs.length (); ++i)\n+\t    push_value_range (vrs[i].first, vrs[i].second);\n \t}\n     }\n \n@@ -11462,13 +11487,13 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t\t      /* Add VR when (T COMP_CODE value) condition is\n \t\t\t true.  */\n \t\t      value_range *op_range\n-\t\t\t= try_find_new_range (t, comp_code, value);\n+\t\t\t= try_find_new_range (t, t, comp_code, value);\n \t\t      if (op_range)\n \t\t\tpush_value_range (t, op_range);\n \t\t    }\n \t\t}\n \t      /* Add VR when (OP COMP_CODE value) condition is true.  */\n-\t      value_range *op_range = try_find_new_range (op,\n+\t      value_range *op_range = try_find_new_range (op, op,\n \t\t\t\t\t\t\t  comp_code, value);\n \t      if (op_range)\n \t\tpush_value_range (op, op_range);"}]}