{"sha": "ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE0YTQ1M2I4OTA5ZWIwZjM2MTJiYmY5OGZlMmU2YTJhOGVlNDExNA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-05-29T16:19:32Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-05-29T16:19:32Z"}, "message": "cpplib.h (cpp_reader): Remove if_stack.\n\n\t* cpplib.h (cpp_reader): Remove if_stack.  Change\n\tpotential_control_macro to a cpp_hashnode *.  Add skipping flag.\n\t* cpphash.h (struct ihash): Change control_macro to a\n\tcpp_hashnode * and shorten name to cmacro.\n\tAdd NEVER_REINCLUDE constant.\n\n\t* cppfiles.c (redundant_include_p): Drop cpp_reader argument.\n\tExamine the cmacro node directly, no need to call cpp_defined.\n\t(_cpp_execute_include, read_include_file): Set cmacro to\n\tNEVER_REINCLUDE, not U\"\".\n\t* cpplex.c (cpp_push_buffer): Don't set new->if_stack.\n\t(cpp_get_token): If pfile->skipping is true, discard text and\n\tkeep scanning until we hit a directive; don't expand macros.\n\n\t* cpplib.c (struct if_stack): Remove if_succeeded, add\n\twas_skipping. Change control_macro to a cpp_hashnode * and\n\tshorten name to cmacro.  Remove typedef IF_STACK.\n\t(parse_ifdef), detect_if_not_defined): Return a cpp_hashnode *.\n\t(conditional_skip, skip_if_group,\n\tconsider_directive_while_skipping): Delete.\n\t(push_conditional): New.\n\t(_cpp_handle_directive): Don't process directives other than\n\tconditionals if we are skipping.\n\n\t(do_ifdef, do_ifndef, do_if, do_else, do_elif, do_endif):\n\tUpdate to new scheme.\n\t(validate_else): Skip rest of line here, unconditionally.\n\t(_cpp_unwind_if_stack): The stack is per-buffer.  Force\n\tpfile->skipping off.\n\n\t(all): Remove `scare quotes' from error messages.\n\n\t* gcc.dg/cpp-mi.c: Add another case, cpp-mix.h, where the\n\tguard macro is already defined when the header is first\n\tincluded.\n\t* gcc.dg/cpp-mix.h: New file.\n\t* gcc.dg/endif-label.c: Update patterns to match compiler.\n\n\t* g++.brendan/complex1.C: Declare abort.\n\t* g++.law/refs4.C: Remove XFAIL.\n\t* g++.oliva/expr2.C: Declare abort and exit.\n\nFrom-SVN: r34253", "tree": {"sha": "05d62231cd71e2302cbbf76f31135f52a6e77ba9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05d62231cd71e2302cbbf76f31135f52a6e77ba9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/comments", "author": null, "committer": null, "parents": [{"sha": "1b50716d21794f2f69aa2939045fbf1489ff3c19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b50716d21794f2f69aa2939045fbf1489ff3c19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b50716d21794f2f69aa2939045fbf1489ff3c19"}], "stats": {"total": 662, "additions": 293, "deletions": 369}, "files": [{"sha": "6534ad18c1885195bde1ce745ad646d959c2554b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114", "patch": "@@ -1,3 +1,37 @@\n+2000-05-29  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpplib.h (cpp_reader): Remove if_stack.  Change\n+\tpotential_control_macro to a cpp_hashnode *.  Add skipping flag.\n+\t* cpphash.h (struct ihash): Change control_macro to a\n+\tcpp_hashnode * and shorten name to cmacro.\n+\tAdd NEVER_REINCLUDE constant.\n+\n+\t* cppfiles.c (redundant_include_p): Drop cpp_reader argument.\n+\tExamine the cmacro node directly, no need to call cpp_defined.\n+\t(_cpp_execute_include, read_include_file): Set cmacro to\n+\tNEVER_REINCLUDE, not U\"\".\n+\t* cpplex.c (cpp_push_buffer): Don't set new->if_stack.\n+\t(cpp_get_token): If pfile->skipping is true, discard text and\n+\tkeep scanning until we hit a directive; don't expand macros.\n+\n+\t* cpplib.c (struct if_stack): Remove if_succeeded, add\n+\twas_skipping. Change control_macro to a cpp_hashnode * and\n+\tshorten name to cmacro.  Remove typedef IF_STACK.\n+\t(parse_ifdef), detect_if_not_defined): Return a cpp_hashnode *.\n+\t(conditional_skip, skip_if_group,\n+\tconsider_directive_while_skipping): Delete.\n+\t(push_conditional): New.\n+\t(_cpp_handle_directive): Don't process directives other than\n+\tconditionals if we are skipping.\n+\n+\t(do_ifdef, do_ifndef, do_if, do_else, do_elif, do_endif):\n+\tUpdate to new scheme.\n+\t(validate_else): Skip rest of line here, unconditionally.\n+\t(_cpp_unwind_if_stack): The stack is per-buffer.  Force\n+\tpfile->skipping off.\n+\n+\t(all): Remove `scare quotes' from error messages.\n+\n 2000-05-29  Richard Henderson  <rth@cygnus.com>\n \n \t* function.c (emit_return_into_block): New line_note arg; emit it."}, {"sha": "676c9d56c4a90dd86e22b8c95c21cece86f4b2e6", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114", "patch": "@@ -39,8 +39,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #  define MMAP_THRESHOLD 0\n #endif\n \n-static IHASH *redundant_include_p PARAMS ((cpp_reader *, IHASH *,\n-\t\t\t\t\t   struct file_name_list *));\n+static IHASH *redundant_include_p PARAMS ((IHASH *, struct file_name_list *));\n static IHASH *make_IHASH\tPARAMS ((const char *, const char *,\n \t\t\t\t\t struct file_name_list *,\n \t\t\t\t\t unsigned int, IHASH **));\n@@ -124,8 +123,7 @@ _cpp_init_include_hash (pfile)\n    the directories are in fact the same.  */\n \n static IHASH *\n-redundant_include_p (pfile, ihash, ilist)\n-     cpp_reader *pfile;\n+redundant_include_p (ihash, ilist)\n      IHASH *ihash;\n      struct file_name_list *ilist;\n {\n@@ -138,14 +136,14 @@ redundant_include_p (pfile, ihash, ilist)\n   for (i = ihash; i; i = i->next_this_file)\n     for (l = ilist; l; l = l->next)\n        if (i->foundhere == l)\n-\t /* The control_macro works like this: If it's NULL, the file\n-\t    is to be included again.  If it's \"\", the file is never to\n-\t    be included again.  If it's a string, the file is not to be\n-\t    included again if the string is the name of a defined macro. */\n-\t return (i->control_macro\n-\t\t && (i->control_macro[0] == '\\0'\n-\t\t     || cpp_defined (pfile, i->control_macro, \n-\t\t\t\t     ustrlen (i->control_macro))))\n+\t /* The cmacro works like this: If it's NULL, the file is to\n+\t    be included again.  If it's NEVER_REINCLUDE, the file is\n+\t    never to be included again.  Otherwise it is a macro\n+\t    hashnode, and the file is to be included again if the\n+\t    macro is not defined.  */\n+\t return (i->cmacro\n+\t\t && (i->cmacro == NEVER_REINCLUDE\n+\t\t     || i->cmacro->type != T_VOID))\n \t     ? (IHASH *)-1 : i;\n \n   return 0;\n@@ -199,7 +197,7 @@ make_IHASH (name, fname, path, hash, slot)\n     }\n   strcpy ((char *)ih->name, name);\n   ih->foundhere = path;\n-  ih->control_macro = NULL;\n+  ih->cmacro = NULL;\n   ih->hash = hash;\n   ih->next_this_file = *slot;\n   *slot = ih;\n@@ -256,7 +254,7 @@ find_include_file (pfile, fname, search_start, ihash, before)\n \t\t\t\t\t      (const void *) &dummy,\n \t\t\t\t\t      dummy.hash, INSERT);\n \n-  if (*slot && (ih = redundant_include_p (pfile, *slot, path)))\n+  if (*slot && (ih = redundant_include_p (*slot, path)))\n     {\n       if (ih == (IHASH *)-1)\n \treturn -2;\n@@ -629,7 +627,7 @@ _cpp_execute_include (pfile, f, len, no_reinclude, search_start)\n \n   /* Actually process the file.  */\n   if (no_reinclude)\n-    ihash->control_macro = U\"\";\n+    ihash->cmacro = NEVER_REINCLUDE;\n   \n   if (read_include_file (pfile, fd, ihash))\n     {\n@@ -662,7 +660,7 @@ cpp_read_file (pfile, fname)\n   slot = (IHASH **) htab_find_slot_with_hash (pfile->all_include_files,\n \t\t\t\t\t      (const void *) &dummy,\n \t\t\t\t\t      dummy.hash, INSERT);\n-  if (*slot && (ih = redundant_include_p (pfile, *slot, ABSOLUTE_PATH)))\n+  if (*slot && (ih = redundant_include_p (*slot, ABSOLUTE_PATH)))\n     {\n       if (ih == (IHASH *) -1)\n \treturn 1;  /* Already included.  */\n@@ -759,7 +757,7 @@ read_include_file (pfile, fd, ihash)\n   fp->nominal_fname = ihash->name;\n   \n   if (length == 0)\n-    ihash->control_macro = U\"\";  /* never re-include */\n+    ihash->cmacro = NEVER_REINCLUDE;\n   else\n     /* Temporary - I hope.  */\n     length = _cpp_prescan (pfile, fp, length);"}, {"sha": "28761c71225ad851545e3eaa06e3484427b8c41b", "filename": "gcc/cpphash.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114", "patch": "@@ -69,10 +69,11 @@ struct ihash\n   unsigned int hash;\t\t/* save hash value for future reference */\n   const char *nshort;\t\t/* name of file as referenced in #include;\n \t\t\t\t   points into name[]  */\n-  const U_CHAR *control_macro;\t/* macro, if any, preventing reinclusion.  */\n+  const cpp_hashnode *cmacro;\t/* macro, if any, preventing reinclusion.  */\n   const char name[1];\t\t/* (partial) pathname of file */\n };\n typedef struct ihash IHASH;\n+#define NEVER_REINCLUDE ((const cpp_hashnode *)-1)\n \n /* Character classes.\n    If the definition of `numchar' looks odd to you, please look up the"}, {"sha": "b35f2989786a8b2b02ca0b1cd3d2d021cf84f649", "filename": "gcc/cpplex.c", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114", "patch": "@@ -193,7 +193,6 @@ cpp_push_buffer (pfile, buffer, length)\n \n   new = (cpp_buffer *) xcalloc (1, sizeof (cpp_buffer));\n \n-  new->if_stack = pfile->if_stack;\n   new->buf = new->cur = buffer;\n   new->rlimit = buffer + length;\n   new->prev = buf;\n@@ -221,7 +220,7 @@ cpp_pop_buffer (pfile)\n \tpfile->system_include_depth--;\n       if (pfile->potential_control_macro)\n \t{\n-\t  buf->ihash->control_macro = pfile->potential_control_macro;\n+\t  buf->ihash->cmacro = pfile->potential_control_macro;\n \t  pfile->potential_control_macro = 0;\n \t}\n       pfile->input_stack_listing_current = 0;\n@@ -1743,31 +1742,34 @@ cpp_get_token (pfile)\n {\n   enum cpp_ttype token;\n   long written = CPP_WRITTEN (pfile);\n+  int macro_buffer;\n \n  get_next:\n   token = _cpp_lex_token (pfile);\n \n   switch (token)\n     {\n     default:\n+      if (pfile->skipping)\n+\tbreak;\n       pfile->potential_control_macro = 0;\n       pfile->only_seen_white = 0;\n-      return token;\n+      break;\n+\n+    case CPP_HSPACE:\n+    case CPP_COMMENT:\n+      break;\n \n     case CPP_VSPACE:\n       if (pfile->only_seen_white == 0)\n \tpfile->only_seen_white = 1;\n       CPP_BUMP_LINE (pfile);\n-      return token;\n-\n-    case CPP_HSPACE:\n-    case CPP_COMMENT:\n-      return token;\n+      break;\n \n     case CPP_HASH:\n       pfile->potential_control_macro = 0;\n       if (!pfile->only_seen_white)\n-\treturn CPP_HASH;\n+\tbreak;\n       /* XXX shouldn't have to do this - remove the hash or %: from\n \t the token buffer.  */\n       if (CPP_PWRITTEN (pfile)[-1] == '#')\n@@ -1776,30 +1778,43 @@ cpp_get_token (pfile)\n \tCPP_ADJUST_WRITTEN (pfile, -2);\n \n       if (_cpp_handle_directive (pfile))\n-\treturn CPP_DIRECTIVE; \n+\t{\n+\t  token = CPP_DIRECTIVE;\n+\t  break;\n+\t}\n       pfile->only_seen_white = 0;\n       CPP_PUTC (pfile, '#');\n-      return CPP_HASH;\n+      break;\n \n     case CPP_MACRO:\n+      if (pfile->skipping)\n+\tbreak;\n       pfile->potential_control_macro = 0;\n       pfile->only_seen_white = 0;\n       if (! pfile->no_macro_expand\n \t  && maybe_macroexpand (pfile, written))\n \tgoto get_next;\n-      return CPP_NAME;\n+      token = CPP_NAME;\n+      break;\n \n+      /* Do not run this case through the 'skipping' logic.  */\n     case CPP_EOF:\n       if (CPP_BUFFER (pfile) == NULL)\n \treturn CPP_EOF;\n-      if (CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n-\t{\n-\t  cpp_pop_buffer (pfile);\n-\t  goto get_next;\n-\t}\n+      macro_buffer = CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile));\n+\n       cpp_pop_buffer (pfile);\n+      if (macro_buffer)\n+\tgoto get_next;\n       return CPP_EOF;\n     }\n+  \n+  if (pfile->skipping)\n+    {\n+      CPP_SET_WRITTEN (pfile, written);\n+      goto get_next;\n+    }\n+  return token;\n }\n \n /* Like cpp_get_token, but skip spaces and comments.  */"}, {"sha": "3bc882562e72e17e2bb3cd26aed567f41ecb6b35", "filename": "gcc/cpplib.c", "status": "modified", "additions": 173, "deletions": 328, "changes": 501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114", "patch": "@@ -44,26 +44,22 @@ struct if_stack\n {\n   struct if_stack *next;\n   int lineno;\t\t\t/* line number where condition started */\n-  int if_succeeded;\t\t/* truth of last condition in this group */\n-  const U_CHAR *control_macro;\t/* macro name for #ifndef around entire file */\n+  int was_skipping;\t\t/* value of pfile->skipping before this if */\n+  const cpp_hashnode *cmacro;\t/* macro name for #ifndef around entire file */\n   int type;\t\t\t/* type of last directive seen in this group */\n };\n-typedef struct if_stack IF_STACK;\n \n /* Forward declarations.  */\n \n static void validate_else\t\tPARAMS ((cpp_reader *, const U_CHAR *));\n-static int parse_ifdef\t\t\tPARAMS ((cpp_reader *, const U_CHAR *));\n static unsigned int parse_include\tPARAMS ((cpp_reader *, const U_CHAR *));\n-static int conditional_skip\t\tPARAMS ((cpp_reader *, int, int,\n-\t\t\t\t\t\t U_CHAR *));\n-static int skip_if_group\t\tPARAMS ((cpp_reader *));\n+static void push_conditional\t\tPARAMS ((cpp_reader *, int, int,\n+\t\t\t\t\t\t const cpp_hashnode *));\n static void pass_thru_directive\t\tPARAMS ((const U_CHAR *, size_t,\n \t\t\t\t\t\t cpp_reader *, int));\n static int read_line_number\t\tPARAMS ((cpp_reader *, int *));\n-static U_CHAR *detect_if_not_defined\tPARAMS ((cpp_reader *));\n-static int consider_directive_while_skipping\n-\t\t\t\t\tPARAMS ((cpp_reader *, IF_STACK *));\n+static const cpp_hashnode *parse_ifdef\tPARAMS ((cpp_reader *, const U_CHAR *));\n+static const cpp_hashnode *detect_if_not_defined PARAMS ((cpp_reader *));\n \n /* Values for the flags field of the table below.  KANDR and COND\n    directives come from traditional (K&R) C.  The difference is, if we\n@@ -208,12 +204,13 @@ _cpp_handle_directive (pfile)\n   CPP_GOTO_MARK (pfile);\n \n   /* # followed by a number is equivalent to #line.  Do not recognize\n-     this form in assembly language source files.  Complain about this\n-     form if we're being pedantic, but not if this is regurgitated\n-     input (preprocessed or fed back in by the C++ frontend).  */\n+     this form in assembly language source files or skipped\n+     conditional groups.  Complain about this form if we're being\n+     pedantic, but not if this is regurgitated input (preprocessed or\n+     fed back in by the C++ frontend).  */\n   if (tok == CPP_NUMBER)\n     {\n-      if (CPP_OPTION (pfile, lang_asm))\n+      if (pfile->skipping || CPP_OPTION (pfile, lang_asm))\n \treturn 0;\n \n       if (CPP_PEDANTIC (pfile)\n@@ -244,8 +241,9 @@ _cpp_handle_directive (pfile)\n \t}\n       /* Don't complain about invalid directives in assembly source,\n \t we don't know where the comments are, and # may introduce\n-\t assembler pseudo-ops.  */\n-      if (!CPP_OPTION (pfile, lang_asm))\n+\t assembler pseudo-ops.  Don't complain about invalid directives\n+\t in skipped conditional groups (6.10 p4). */\n+      if (!pfile->skipping && !CPP_OPTION (pfile, lang_asm))\n \tcpp_error (pfile, \"invalid preprocessing directive #%s\", ident);\n       return 0;\n     }\n@@ -255,6 +253,11 @@ _cpp_handle_directive (pfile)\n \n  real_directive:\n \n+  /* If we are skipping a failed conditional group, all non-conditional\n+     directives are ignored.  */\n+  if (pfile->skipping && ORIGIN (dtable[i].flags) != COND)\n+    return 0;\n+\n   /* In -traditional mode, a directive is ignored unless its # is in\n      column 1.  */\n   if (CPP_TRADITIONAL (pfile) && !hash_at_bol)\n@@ -302,11 +305,7 @@ _cpp_handle_directive (pfile)\n   CPP_SET_WRITTEN (pfile, old_written);\n \n  process_directive:\n-  /* Some directives (e.g. #if) may return a request to execute\n-     another directive handler immediately.  No directive ever\n-     requests that #define be executed immediately, so it is safe for\n-     the loop to terminate when some function returns 0 (== T_DEFINE).  */\n-  while ((i = dtable[i].func (pfile)));\n+  (void) (*dtable[i].func) (pfile);\n   return 1;\n }\n \n@@ -434,22 +433,22 @@ parse_include (pfile, name)\n #endif\n   else\n     {\n-      cpp_error (pfile, \"`#%s' expects \\\"FILENAME\\\" or <FILENAME>\", name);\n+      cpp_error (pfile, \"#%s expects \\\"FILENAME\\\" or <FILENAME>\", name);\n       CPP_SET_WRITTEN (pfile, old_written);\n       _cpp_skip_rest_of_line (pfile);\n       return 0;\n     }\n \n   if (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n     {\n-      cpp_error (pfile, \"junk at end of `#%s'\", name);\n+      cpp_error (pfile, \"junk at end of #%s\", name);\n       _cpp_skip_rest_of_line (pfile);\n     }\n \n   CPP_SET_WRITTEN (pfile, old_written);\n \n   if (len == 0)\n-    cpp_error (pfile, \"empty file name in `#%s'\", name);\n+    cpp_error (pfile, \"empty file name in #%s\", name);\n \n   return len;\n }\n@@ -563,7 +562,7 @@ read_line_number (pfile, num)\n   else\n     {\n       if (token != CPP_VSPACE && token != CPP_EOF)\n-\tcpp_error (pfile, \"invalid format `#line' command\");\n+\tcpp_error (pfile, \"invalid format #line\");\n       CPP_SET_WRITTEN (pfile, save_written);\n       return 0;\n     }\n@@ -587,7 +586,7 @@ do_line (pfile)\n \n   if (token != CPP_NUMBER)\n     {\n-      cpp_error (pfile, \"token after `#line' is not an integer\");\n+      cpp_error (pfile, \"token after #line is not an integer\");\n       goto bad_line_directive;\n     }\n \n@@ -596,13 +595,13 @@ do_line (pfile)\n \t\t\t&x, 10);\n   if (x[0] != '\\0')\n     {\n-      cpp_error (pfile, \"token after `#line' is not an integer\");\n+      cpp_error (pfile, \"token after #line is not an integer\");\n       goto bad_line_directive;\n     }      \n   CPP_SET_WRITTEN (pfile, old_written);\n \n   if (CPP_PEDANTIC (pfile) && (new_lineno <= 0 || new_lineno > 32767))\n-    cpp_pedwarn (pfile, \"line number out of range in `#line' command\");\n+    cpp_pedwarn (pfile, \"line number out of range in #line\");\n \n   token = _cpp_get_directive_token (pfile);\n \n@@ -615,7 +614,7 @@ do_line (pfile)\n       if (read_line_number (pfile, &action_number))\n \t{\n \t  if (CPP_PEDANTIC (pfile))\n-\t    cpp_pedwarn (pfile, \"garbage at end of `#line' command\");\n+\t    cpp_pedwarn (pfile, \"garbage at end of #line\");\n \n \t  /* This is somewhat questionable: change the buffer stack\n \t     depth so that output_line_command thinks we've stacked\n@@ -656,7 +655,7 @@ do_line (pfile)\n     }\n   else if (token != CPP_VSPACE && token != CPP_EOF)\n     {\n-      cpp_error (pfile, \"token after `#line %d' is not a string\", new_lineno);\n+      cpp_error (pfile, \"second token after #line is not a string\");\n       goto bad_line_directive;\n     }\n \n@@ -889,12 +888,12 @@ do_pragma_once (pfile)\n   /* Allow #pragma once in system headers, since that's not the user's\n      fault.  */\n   if (!ip->system_header_p)\n-    cpp_warning (pfile, \"`#pragma once' is obsolete\");\n+    cpp_warning (pfile, \"#pragma once is obsolete\");\n       \n   if (CPP_PREV_BUFFER (ip) == NULL)\n-    cpp_warning (pfile, \"`#pragma once' outside include file\");\n+    cpp_warning (pfile, \"#pragma once outside include file\");\n   else\n-    ip->ihash->control_macro = U\"\";  /* never repeat */\n+    ip->ihash->cmacro = NEVER_REINCLUDE;\n \n   return 1;\n }\n@@ -929,7 +928,7 @@ do_pragma_implementation (pfile)\n   \n   if (cpp_included (pfile, copy))\n     cpp_warning (pfile,\n-\t \"`#pragma implementation' for `%s' appears after file is included\",\n+\t \"#pragma implementation for %s appears after file is included\",\n \t\t copy);\n   return 0;\n }\n@@ -1018,21 +1017,21 @@ do_sccs (pfile)\n    this file is white space, and if it is of the form\n    `#if ! defined SYMBOL', then SYMBOL is a possible controlling macro\n    for inclusion of this file.  (See redundant_include_p in cppfiles.c\n-   for an explanation of controlling macros.)  If so, return a\n-   malloced copy of SYMBOL.  Otherwise, return NULL.  */\n+   for an explanation of controlling macros.)  If so, return the\n+   hash node for SYMBOL.  Otherwise, return NULL.  */\n \n-static U_CHAR *\n+static const cpp_hashnode *\n detect_if_not_defined (pfile)\n      cpp_reader *pfile;\n {\n-  U_CHAR *control_macro = 0;\n+  const cpp_hashnode *cmacro = 0;\n   enum cpp_ttype token;\n   unsigned int base_offset;\n   unsigned int token_offset;\n   unsigned int need_rparen = 0;\n   unsigned int token_len;\n \n-  if (pfile->only_seen_white != 2)\n+  if (pfile->skipping || pfile->only_seen_white != 2)\n     return NULL;\n \n   /* Save state required for restore.  */\n@@ -1077,82 +1076,21 @@ detect_if_not_defined (pfile)\n     goto restore;\n \n   /* We have a legitimate controlling macro for this header.  */\n-  control_macro = (U_CHAR *) xmalloc (token_len + 1);\n-  memcpy (control_macro, pfile->token_buffer + token_offset, token_len);\n-  control_macro[token_len] = '\\0';\n+  cmacro = cpp_lookup (pfile, pfile->token_buffer + token_offset, token_len);\n \n  restore:\n   CPP_SET_WRITTEN (pfile, base_offset);\n   pfile->no_macro_expand--;\n   CPP_GOTO_MARK (pfile);\n \n-  return control_macro;\n-}\n-\n-/*\n- * #if is straightforward; just call _cpp_parse_expr, then conditional_skip.\n- * Also, check for a reinclude preventer of the form #if !defined (MACRO).\n- */\n-\n-static int\n-do_if (pfile)\n-     cpp_reader *pfile;\n-{\n-  U_CHAR *control_macro;\n-  int value;\n-  int save_only_seen_white = pfile->only_seen_white;\n-\n-  control_macro = detect_if_not_defined (pfile);  \n-\n-  pfile->only_seen_white = 0;\n-  value = _cpp_parse_expr (pfile);\n-  pfile->only_seen_white = save_only_seen_white;\n-\n-  return conditional_skip (pfile, value == 0, T_IF, control_macro);\n-}\n-\n-/*\n- * handle a #elif directive by not changing  if_stack  either.\n- * see the comment above do_else.\n- */\n-\n-static int\n-do_elif (pfile)\n-     cpp_reader *pfile;\n-{\n-  if (pfile->if_stack == CPP_BUFFER (pfile)->if_stack)\n-    {\n-      cpp_error (pfile, \"`#elif' not within a conditional\");\n-      return 0;\n-    }\n-  else\n-    {\n-      if (pfile->if_stack->type == T_ELSE)\n-\t{\n-\t  cpp_error (pfile, \"`#elif' after `#else'\");\n-\t  cpp_error_with_line (pfile, pfile->if_stack->lineno, 0,\n-\t\t\t       \"the conditional began here\");\n-\t}\n-      pfile->if_stack->type = T_ELIF;\n-    }\n-\n-  if (pfile->if_stack->if_succeeded)\n-    {\n-      _cpp_skip_rest_of_line (pfile);\n-      return skip_if_group (pfile);\n-    }\n-  if (_cpp_parse_expr (pfile) == 0)\n-    return skip_if_group (pfile);\n-\n-  ++pfile->if_stack->if_succeeded;\t/* continue processing input */\n-  return 0;\n+  return cmacro;\n }\n \n /* Parse an #ifdef or #ifndef directive.  Returns 1 for defined, 0 for\n    not defined; the macro tested is left in the token buffer (but\n    popped).  */\n \n-static int\n+static const cpp_hashnode *\n parse_ifdef (pfile, name)\n      cpp_reader *pfile;\n      const U_CHAR *name;\n@@ -1161,7 +1099,7 @@ parse_ifdef (pfile, name)\n   unsigned int len;\n   enum cpp_ttype token;\n   long old_written = CPP_WRITTEN (pfile);\n-  int defined;\n+  const cpp_hashnode *node = 0;\n \n   pfile->no_macro_expand++;\n   token = _cpp_get_directive_token (pfile);\n@@ -1173,34 +1111,31 @@ parse_ifdef (pfile, name)\n   if (token == CPP_VSPACE)\n     {\n       if (! CPP_TRADITIONAL (pfile))\n-\tcpp_pedwarn (pfile, \"`#%s' with no argument\", name);\n-      defined = 0;\n+\tcpp_pedwarn (pfile, \"#%s with no argument\", name);\n       goto done;\n     }\n   else if (token == CPP_NAME)\n     {\n-      defined = cpp_defined (pfile, ident, len);\n-      CPP_PUTC (pfile, '\\0');  /* so it can be copied with xstrdup */\n+      node = cpp_lookup (pfile, ident, len);\n     }\n   else\n     {\n-      defined = 0;\n       if (! CPP_TRADITIONAL (pfile))\n-\tcpp_error (pfile, \"`#%s' with invalid argument\", name);\n+\tcpp_error (pfile, \"#%s with invalid argument\", name);\n     }\n \n   if (!CPP_TRADITIONAL (pfile))\n     {\n       if (_cpp_get_directive_token (pfile) == CPP_VSPACE)\n \tgoto done;\n       \n-      cpp_pedwarn (pfile, \"garbage at end of `#%s' argument\", name);\n+      cpp_pedwarn (pfile, \"garbage at end of #%s\", name);\n     }\n   _cpp_skip_rest_of_line (pfile);\n   \n  done:\n   CPP_SET_WRITTEN (pfile, old_written); /* Pop */\n-  return defined;\n+  return node;\n }\n \n /* #ifdef is dead simple.  */\n@@ -1209,8 +1144,14 @@ static int\n do_ifdef (pfile)\n      cpp_reader *pfile;\n {\n-  int skip = ! parse_ifdef (pfile, dtable[T_IFDEF].name);\n-  return conditional_skip (pfile, skip, T_IFDEF, 0);\n+  int def = 0;\n+  const cpp_hashnode *node = parse_ifdef (pfile, dtable[T_IFDEF].name);\n+  if (node->type == T_POISON)\n+    cpp_error (pfile, \"attempt to use poisoned `%s'\", node->name);\n+  else\n+    def = (node->type != T_VOID);\n+  push_conditional (pfile, !def, T_IFDEF, 0);\n+  return 0;\n }\n \n /* #ifndef is a tad more complex, because we need to check for a\n@@ -1220,302 +1161,206 @@ static int\n do_ifndef (pfile)\n      cpp_reader *pfile;\n {\n-  int start_of_file, skip;\n-  U_CHAR *control_macro = 0;\n+  int start_of_file;\n+  int def = 0;\n+  const cpp_hashnode *cmacro;\n \n   start_of_file = pfile->only_seen_white == 2;\n-  skip = parse_ifdef (pfile, dtable[T_IFNDEF].name);\n-\n-  if (start_of_file && !skip)\n-    control_macro = uxstrdup (CPP_PWRITTEN (pfile));\n+  cmacro = parse_ifdef (pfile, dtable[T_IFNDEF].name);\n+  if (cmacro->type == T_POISON)\n+    cpp_error (pfile, \"attempt to use poisoned `%s'\", cmacro->name);\n+  else\n+    def = (cmacro->type != T_VOID);\n \n-  return conditional_skip (pfile, skip, T_IFNDEF, control_macro);\n+  push_conditional (pfile, def, T_IFNDEF,\n+\t\t    start_of_file ? cmacro : 0);\n+  return 0;\n }\n \n-/* Push TYPE on stack; then, if SKIP is nonzero, skip ahead.\n-   If this is a #ifndef starting at the beginning of a file,\n-   CONTROL_MACRO is the macro name tested by the #ifndef.\n-   Otherwise, CONTROL_MACRO is 0.  */\n+/* #if is straightforward; just call _cpp_parse_expr, then conditional_skip.\n+   Also, check for a reinclude preventer of the form #if !defined (MACRO).  */\n \n static int\n-conditional_skip (pfile, skip, type, control_macro)\n+do_if (pfile)\n      cpp_reader *pfile;\n-     int skip;\n-     int type;\n-     U_CHAR *control_macro;\n {\n-  IF_STACK *temp;\n-\n-  temp = (IF_STACK *) xcalloc (1, sizeof (IF_STACK));\n-  temp->lineno = CPP_BUFFER (pfile)->lineno;\n-  temp->next = pfile->if_stack;\n-  temp->control_macro = control_macro;\n-  pfile->if_stack = temp;\n-\n-  pfile->if_stack->type = type;\n+  const cpp_hashnode *cmacro = 0;\n+  int value = 0;\n+  int save_only_seen_white = pfile->only_seen_white;\n \n-  if (skip != 0)\n-    return skip_if_group (pfile);\n+  if (! pfile->skipping)\n+    {\n+      cmacro = detect_if_not_defined (pfile);  \n \n-  ++pfile->if_stack->if_succeeded;\n+      pfile->only_seen_white = 0;\n+      value = _cpp_parse_expr (pfile);\n+      pfile->only_seen_white = save_only_seen_white;\n+    }\n+  push_conditional (pfile, value == 0, T_IF, cmacro);\n   return 0;\n }\n \n-/* Subroutine of skip_if_group.  Examine one preprocessing directive\n-   and return 0 if skipping should continue, or the directive number\n-   of the directive that ends the block if it should halt.\n-\n-   Also adjusts the if_stack as appropriate.  The `#' has been read,\n-   but not the identifier. */\n+/* #else flips pfile->skipping and continues without changing\n+   if_stack; this is so that the error message for missing #endif's\n+   etc. will point to the original #if.  */\n \n static int\n-consider_directive_while_skipping (pfile, stack)\n-    cpp_reader *pfile;\n-    IF_STACK *stack; \n+do_else (pfile)\n+     cpp_reader *pfile;\n {\n-  long ident;\n-  int i, hash_at_bol;\n-  unsigned int len;\n-  IF_STACK *temp;\n-\n-  /* -traditional directives are recognized only with the # in column 1.  */\n-  hash_at_bol = CPP_IN_COLUMN_1 (pfile);\n-\n-  ident = CPP_WRITTEN (pfile);\n-  if (_cpp_get_directive_token (pfile) != CPP_NAME)\n-    return 0;\n-  len = CPP_WRITTEN (pfile) - ident;\n+  struct if_stack *ifs = CPP_BUFFER (pfile)->if_stack;\n \n-  for (i = 0; i < N_DIRECTIVES; i++)\n-    {\n-      if (dtable[i].length == len\n-\t  && !ustrncmp (dtable[i].name, pfile->token_buffer + ident, len)) \n-\tgoto real_directive;\n-    }\n-  return 0;\n-\n- real_directive:\n-\n-  /* If it's not a directive of interest to us, return now.  */\n-  if (ORIGIN (dtable[i].flags) != COND)\n-    return 0;\n-\n-  /* First, deal with -traditional and -Wtraditional.\n-     All COND directives are from K+R.  */\n+  validate_else (pfile, dtable[T_ELSE].name);\n \n-  if (! hash_at_bol)\n+  if (ifs == NULL)\n     {\n-      if (CPP_TRADITIONAL (pfile))\n-\t{\n-\t  if (CPP_WTRADITIONAL (pfile))\n-\t    cpp_warning (pfile, \"ignoring #%s because of its indented #\",\n-\t\t\t dtable[i].name);\n-\t  return 0;\n-\t}\n-      if (CPP_WTRADITIONAL (pfile))\n-\tcpp_warning (pfile, \"traditional C ignores %s with the # indented\",\n-\t\t     dtable[i].name);\n+      cpp_error (pfile, \"#else without #if\");\n+      return 0;\n     }\n-  \n-  switch (i)\n+  if (ifs->type == T_ELSE)\n     {\n-    default:\n-      cpp_ice (pfile, \"non COND directive in switch in c_d_w_s\");\n-      return 0;\n-\n-    case T_IF:\n-    case T_IFDEF:\n-    case T_IFNDEF:\n-      temp = (IF_STACK *) xcalloc (1, sizeof (IF_STACK));\n-      temp->lineno = CPP_BUFFER (pfile)->lineno;\n-      temp->next = pfile->if_stack;\n-      temp->type = i;\n-      pfile->if_stack = temp;\n-      return 0;\n-\n-    case T_ELSE:\n-      if (pfile->if_stack != stack)\n-\tvalidate_else (pfile, dtable[i].name);\n-      /* fall through */\n-    case T_ELIF:\n-      if (pfile->if_stack == stack)\n-\treturn i;\n-\n-      pfile->if_stack->type = i;\n-      return 0;\n-\n-    case T_ENDIF:\n-      if (pfile->if_stack != stack)\n-\tvalidate_else (pfile, dtable[i].name);\n-\n-      if (pfile->if_stack == stack)\n-\treturn i;\n-\t\t    \n-      temp = pfile->if_stack;\n-      pfile->if_stack = temp->next;\n-      free (temp);\n-      return 0;\n+      cpp_error (pfile, \"#else after #else\");\n+      cpp_error_with_line (pfile, ifs->lineno, 1, \"the conditional began here\");\n     }\n-}\n-\n-/* Skip to #endif, #else, or #elif.  Consumes the directive that\n-   causes it to stop, but not its argument.  Returns the number of\n-   that directive, which must be passed back up to\n-   _cpp_handle_directive, which will execute it.  */\n-static int\n-skip_if_group (pfile)\n-    cpp_reader *pfile;\n-{\n-  enum cpp_ttype token;\n-  IF_STACK *save_if_stack = pfile->if_stack; /* don't pop past here */\n-  long old_written;\n-  int ret = 0;\n \n-  /* We are no longer at the start of the file.  */\n-  pfile->only_seen_white = 0;\n+  /* #ifndef can't have its special treatment for containing the whole file\n+     if it has a #else clause.  */\n+  ifs->cmacro = 0;\n \n-  old_written = CPP_WRITTEN (pfile);\n-  pfile->no_macro_expand++;\n-  for (;;)\n+  ifs->type = T_ELSE;\n+  if (! ifs->was_skipping)\n     {\n-      /* We are at the end of a line.\n-\t XXX Serious layering violation here.  */\n-      int c = CPP_BUF_PEEK (CPP_BUFFER (pfile));\n-      if (c == EOF)\n-\tbreak;  /* Caller will issue error.  */\n-      else if (c != '\\n')\n-\tcpp_ice (pfile, \"character %c at end of line in skip_if_group\", c);\n-      CPP_BUFFER (pfile)->cur++;\n-      CPP_BUMP_LINE (pfile);\n-      CPP_SET_WRITTEN (pfile, old_written);\n-      pfile->only_seen_white = 1;\n-\n-      token = _cpp_get_directive_token (pfile);\n-\n-      if (token == CPP_HASH)\n-\t{\n-\t  ret = consider_directive_while_skipping (pfile, save_if_stack);\n-\t  if (ret)\n-\t    break;\n-\t}\n-\n-      if (token != CPP_VSPACE)\n-\t_cpp_skip_rest_of_line (pfile);\n+      /* If pfile->skipping is 2, one of the blocks in an #if/#elif/... chain\n+\t succeeded, so we mustn't do the else block.  */\n+      if (pfile->skipping < 2)\n+\tpfile->skipping = ! pfile->skipping;\n     }\n-  CPP_SET_WRITTEN (pfile, old_written);\n-  pfile->no_macro_expand--;\n-  return ret;\n+  return 0;\n }\n \n /*\n- * handle a #else directive.  Do this by just continuing processing\n- * without changing  if_stack ;  this is so that the error message\n- * for missing #endif's etc. will point to the original #if.  It\n- * is possible that something different would be better.\n+ * handle a #elif directive by not changing if_stack either.\n+ * see the comment above do_else.\n  */\n \n static int\n-do_else (pfile)\n+do_elif (pfile)\n      cpp_reader *pfile;\n {\n-  validate_else (pfile, dtable[T_ELSE].name);\n-  _cpp_skip_rest_of_line (pfile);\n+  struct if_stack *ifs = CPP_BUFFER (pfile)->if_stack;\n \n-  if (pfile->if_stack == CPP_BUFFER (pfile)->if_stack)\n+  if (ifs == NULL)\n     {\n-      cpp_error (pfile, \"`#else' not within a conditional\");\n+      cpp_error (pfile, \"#elif without #if\");\n       return 0;\n     }\n-  else\n+  if (ifs->type == T_ELSE)\n     {\n-      /* #ifndef can't have its special treatment for containing the whole file\n-\t if it has a #else clause.  */\n-      pfile->if_stack->control_macro = 0;\n+      cpp_error (pfile, \"#elif after #else\");\n+      cpp_error_with_line (pfile, ifs->lineno, 1, \"the conditional began here\");\n+    }\n \n-      if (pfile->if_stack->type == T_ELSE)\n-\t{\n-\t  cpp_error (pfile, \"`#else' after `#else'\");\n-\t  cpp_error_with_line (pfile, pfile->if_stack->lineno, 0,\n-\t\t\t       \"the conditional began here\");\n-\t}\n-      pfile->if_stack->type = T_ELSE;\n+  ifs->type = T_ELIF;\n+  if (ifs->was_skipping)\n+    _cpp_skip_rest_of_line (pfile);\n+  else if (pfile->skipping != 1)\n+    {\n+      _cpp_skip_rest_of_line (pfile);\n+      pfile->skipping = 2;  /* one block succeeded, so don't do any others */\n     }\n+  else\n+    pfile->skipping = ! _cpp_parse_expr (pfile);\n \n-  if (pfile->if_stack->if_succeeded)\n-    return skip_if_group (pfile);\n-  \n-  ++pfile->if_stack->if_succeeded;\t/* continue processing input */\n   return 0;\n }\n \n-/*\n- * unstack after #endif command\n- */\n+\n+/* #endif pops the if stack and resets pfile->skipping.  */\n \n static int\n do_endif (pfile)\n      cpp_reader *pfile;\n {\n+  struct if_stack *ifs = CPP_BUFFER (pfile)->if_stack;\n+\n   validate_else (pfile, dtable[T_ENDIF].name);\n-  _cpp_skip_rest_of_line (pfile);\n \n-  if (pfile->if_stack == CPP_BUFFER (pfile)->if_stack)\n-    cpp_error (pfile, \"`#endif' not within a conditional\");\n+  if (ifs == NULL)\n+    cpp_error (pfile, \"#endif without #if\");\n   else\n     {\n-      IF_STACK *temp = pfile->if_stack;\n-      pfile->if_stack = temp->next;\n-      if (temp->control_macro != 0)\n-\tpfile->potential_control_macro = temp->control_macro;\n-      free (temp);\n+      CPP_BUFFER (pfile)->if_stack = ifs->next;\n+      pfile->skipping = ifs->was_skipping;\n+      pfile->potential_control_macro = ifs->cmacro;\n+      free (ifs);\n     }\n   return 0;\n }\n \n+/* Push an if_stack entry and set pfile->skipping accordingly.\n+   If this is a #ifndef starting at the beginning of a file,\n+   CMACRO is the macro name tested by the #ifndef.  */\n+\n+static void\n+push_conditional (pfile, skip, type, cmacro)\n+     cpp_reader *pfile;\n+     int skip;\n+     int type;\n+     const cpp_hashnode *cmacro;\n+{\n+  struct if_stack *ifs;\n+\n+  ifs = (struct if_stack *) xmalloc (sizeof (struct if_stack));\n+  ifs->lineno = CPP_BUFFER (pfile)->lineno;\n+  ifs->next = CPP_BUFFER (pfile)->if_stack;\n+  ifs->cmacro = cmacro;\n+  ifs->was_skipping = pfile->skipping;\n+  ifs->type = type;\n+\n+  if (!pfile->skipping)\n+    pfile->skipping = skip;\n+\n+  CPP_BUFFER (pfile)->if_stack = ifs;\n+}\n+\n /* Issue -pedantic warning for text which is not a comment following\n-   an #else or #endif.  Do not warn in system headers, as this is harmless\n-   and very common on old systems.  */\n+   an #else or #endif.  */\n \n static void\n validate_else (pfile, directive)\n      cpp_reader *pfile;\n      const U_CHAR *directive;\n {\n-  long old_written;\n-  if (! CPP_PEDANTIC (pfile))\n-    return;\n-\n-  old_written = CPP_WRITTEN (pfile);\n-  pfile->no_macro_expand++;\n-  if (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n-    cpp_pedwarn (pfile,\n-\t\t \"text following `#%s' violates ANSI standard\", directive);\n-  CPP_SET_WRITTEN (pfile, old_written);\n-  pfile->no_macro_expand--;\n+  if (CPP_PEDANTIC (pfile))\n+    {\n+      long old_written = CPP_WRITTEN (pfile);\n+      pfile->no_macro_expand++;\n+      if (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n+\tcpp_pedwarn (pfile, \"ISO C forbids text after #%s\", directive);\n+      CPP_SET_WRITTEN (pfile, old_written);\n+      pfile->no_macro_expand--;\n+    }\n+  _cpp_skip_rest_of_line (pfile);\n }\n \n /* Called when we reach the end of a macro buffer.  Walk back up the\n    conditional stack till we reach its level at entry to this file,\n-   issuing error messages.  */\n+   issuing error messages.  Then force skipping off.  */\n void\n _cpp_unwind_if_stack (pfile, pbuf)\n      cpp_reader *pfile;\n      cpp_buffer *pbuf;\n {\n   struct if_stack *ifs, *nifs;\n \n-  for (ifs = pfile->if_stack;\n-       ifs != pbuf->if_stack;\n-       ifs = nifs)\n+  for (ifs = pbuf->if_stack; ifs; ifs = nifs)\n     {\n-      cpp_error_with_line (pfile, ifs->lineno, 0,\n-\t\t\t   \"unterminated `#%s' conditional\",\n+      cpp_error_with_line (pfile, ifs->lineno, 1, \"unterminated #%s\",\n \t\t\t   dtable[ifs->type].name);\n-\n       nifs = ifs->next;\n       free (ifs);\n     }\n-  pfile->if_stack = ifs;\n+  pfile->skipping = 0;\n }\n \n #define WARNING(msgid) do { cpp_warning(pfile, msgid); goto error; } while (0)"}, {"sha": "c2f95f526ddc1ff6dfeb371853e3d79749a1639c", "filename": "gcc/cpplib.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114", "patch": "@@ -509,8 +509,7 @@ struct cpp_reader\n      for include files.  (Altered as we get more of them.)  */\n   unsigned int max_include_len;\n \n-  struct if_stack *if_stack;\n-  const unsigned char *potential_control_macro;\n+  const cpp_hashnode *potential_control_macro;\n \n   /* Token column position adjustment owing to tabs in whitespace.  */\n   unsigned int col_adjust;\n@@ -555,6 +554,9 @@ struct cpp_reader\n   /* True after cpp_start_read completes.  Used to inhibit some\n      warnings while parsing the command line.  */\n   unsigned char done_initializing;\n+\n+  /* True if we are skipping a failed conditional group.  */\n+  unsigned char skipping;\n };\n \n /* struct cpp_printer encapsulates state used to convert the stream of"}, {"sha": "c963207532c85e15d753b5b38d33faa195f9ff55", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114", "patch": "@@ -1,3 +1,15 @@\n+2000-05-29  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* gcc.dg/cpp-mi.c: Add another case, cpp-mix.h, where the\n+\tguard macro is already defined when the header is first\n+\tincluded.\n+\t* gcc.dg/cpp-mix.h: New file.\n+\t* gcc.dg/endif-label.c: Update patterns to match compiler.\n+\n+\t* g++.brendan/complex1.C: Declare abort.\n+\t* g++.law/refs4.C: Remove XFAIL.\n+\t* g++.oliva/expr2.C: Declare abort and exit.\n+\n 2000-05-28  Alexandre Oliva  <aoliva@cygnus.com>\n \n \t* gcc.c-torture/execute/20000528-1.c: New test."}, {"sha": "a2378bedf7337384fa3c9e13ed4061b894515dc3", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/complex1.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcomplex1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcomplex1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcomplex1.C?ref=ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114", "patch": "@@ -8,6 +8,7 @@\n extern \"C\" {\n int printf (const char *, ...);\n void exit (int);\n+void abort (void);\n };\n \n __complex__ double cd;"}, {"sha": "13349ef1365a7cda147ec4715fab92f6fbef4668", "filename": "gcc/testsuite/g++.old-deja/g++.law/refs4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Frefs4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Frefs4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Frefs4.C?ref=ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114", "patch": "@@ -1,6 +1,6 @@\n // GROUPS passed references\n \n-// execution test - XFAIL *-*-*\n+// execution test\n \n #include <stdio.h>\n #include <stdlib.h>"}, {"sha": "20285937b78e2f446b6b96efb7c96b3a4b49b15c", "filename": "gcc/testsuite/g++.old-deja/g++.oliva/expr2.C", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Fexpr2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Fexpr2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Fexpr2.C?ref=ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114", "patch": "@@ -4,6 +4,9 @@\n \n // execution test - XFAIL *-*-*\n \n+extern \"C\" void abort (void);\n+extern \"C\" void exit (int);\n+\n int i, j;\n \n const int &f(const int& I, const int& J) {"}, {"sha": "f83a64d5871905e30e8a935ec67878fb09d72c53", "filename": "gcc/testsuite/gcc.dg/cpp-mi.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp-mi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp-mi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp-mi.c?ref=ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114", "patch": "@@ -17,6 +17,10 @@\n #include \"cpp-mindp.h\"\n #include \"cpp-mindp.h\"\n \n+#define CPP_MIX_H\n+#include \"cpp-mix.h\"\n+#include \"cpp-mix.h\"\n+\n int\n main (void)\n {\n@@ -28,7 +32,7 @@ main (void)\n \n    { dg-final { set tmp [grep cpp-mi.i {cpp-mi.*\\.h} line]\t} }\n    { dg-final { # send_user \"$tmp\\n\" } }\n-   { dg-final { if [regexp \"^{\\[0-9\\]+ cpp-mic\\.h} {\\[0-9\\]+ cpp-micc\\.h} {\\[0-9\\]+ cpp-mind\\.h} {\\[0-9\\]+ cpp-mindp\\.h}$\" $tmp] \\{ } }\n+   { dg-final { if [regexp \"^{\\[0-9\\]+ cpp-mic\\.h} {\\[0-9\\]+ cpp-micc\\.h} {\\[0-9\\]+ cpp-mind\\.h} {\\[0-9\\]+ cpp-mindp\\.h} {\\[0-9]+ cpp-mix\\.h}$\" $tmp] \\{ } }\n    { dg-final {     pass \"cpp-mi.c: redundant include check\"\t} }\n    { dg-final { \\} else \\{\t\t\t\t\t} }\n    { dg-final {     fail \"cpp-mi.c: redundant include check\"\t} }"}, {"sha": "ce0e76435d7f7d61bbf43d046f55836b141ff3b1", "filename": "gcc/testsuite/gcc.dg/cpp-mix.h", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp-mix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp-mix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp-mix.h?ref=ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114", "patch": "@@ -0,0 +1,9 @@\n+/* This header is never to have its contents visible, but it should\n+   still receive the optimization.  */\n+\n+#ifndef CPP_MIX_H\n+#define CPP_MIX_H\n+\n+#define main wibble\n+\n+#endif"}, {"sha": "c12662cd52ba6b2bdaef97f23f2cc385a904871d", "filename": "gcc/testsuite/gcc.dg/endif-label.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Ftestsuite%2Fgcc.dg%2Fendif-label.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114/gcc%2Ftestsuite%2Fgcc.dg%2Fendif-label.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fendif-label.c?ref=ea4a453b8909eb0f3612bbf98fe2e6a2a8ee4114", "patch": "@@ -4,12 +4,12 @@\n /* You can't get away with this in your own code... */\n #ifdef KERNEL\n #define foo\n-#endif KERNEL  /* { dg-warning \"text following\" \"good warning\" } */\n+#endif KERNEL  /* { dg-warning \"forbids text after\" \"good warning\" } */\n \n /* This will provoke a warning because the '3' is an extension.  */\n #line 10 \"endif-label.c\" 3 /* { dg-warning \"garbage at end\" \"#line extension\" } */\n \n /* ... but in a system header, it's acceptable.  */\n #ifdef KERNEL\n #define foo\n-#endif KERNEL  /* { dg-bogus \"text following\" \"bad warning\" } */\n+#endif KERNEL  /* { dg-bogus \"forbids text after\" \"bad warning\" } */"}]}