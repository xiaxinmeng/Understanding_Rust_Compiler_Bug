{"sha": "ec4a0419ad5374ad56137458e8de8bc4047cebe3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM0YTA0MTlhZDUzNzRhZDU2MTM3NDU4ZThkZThiYzQwNDdjZWJlMw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2003-03-04T20:56:24Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2003-03-04T20:56:24Z"}, "message": "gcov-io.h (gcov_save_position, [...]): Modified to enable reading/ writing of whole .da file just once.\n\n\t* gcov-io.h (gcov_save_position, gcov_reserve_length, gcov_resync,\n\tgcov_skip, gcov_skip_string, gcov_write_unsigned, gcov_write_counter,\n\tgcov_write_string, gcov_read_unsigned, gcov_read_counter,\n\tgcov_read_string, gcov_write_length): Modified to enable reading/\n\twriting of whole .da file just once.\n\t(da_file_open, da_file_close, da_file_eof, da_file_error,\n\tda_file_position, da_file_seek, da_file_write, da_file_read): New\n\tfunctions.\n\t(actual_da_file, actual_da_file_position, actual_da_file_length,\n\tactual_da_file_buffer, actual_da_file_buffer_size): New static\n\tfunctions.\n\t* libgcov.c (gcov_exit): Modified to read/write the whole .da file at\n\tjust once.\n\nFrom-SVN: r63800", "tree": {"sha": "9d5d6ef4d35ecaea4dd2bfdfb63a27fc5e81d9de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d5d6ef4d35ecaea4dd2bfdfb63a27fc5e81d9de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec4a0419ad5374ad56137458e8de8bc4047cebe3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec4a0419ad5374ad56137458e8de8bc4047cebe3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec4a0419ad5374ad56137458e8de8bc4047cebe3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec4a0419ad5374ad56137458e8de8bc4047cebe3/comments", "author": null, "committer": null, "parents": [{"sha": "79dbeefca8553daeb6e96c61b7e964f6ab3f5394", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79dbeefca8553daeb6e96c61b7e964f6ab3f5394", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79dbeefca8553daeb6e96c61b7e964f6ab3f5394"}], "stats": {"total": 465, "additions": 383, "deletions": 82}, "files": [{"sha": "79e0741e5d3e95644c6b0fb1d1581f920ca34e13", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec4a0419ad5374ad56137458e8de8bc4047cebe3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec4a0419ad5374ad56137458e8de8bc4047cebe3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec4a0419ad5374ad56137458e8de8bc4047cebe3", "patch": "@@ -1,3 +1,20 @@\n+2003-03-04  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* gcov-io.h (gcov_save_position, gcov_reserve_length, gcov_resync,\n+\tgcov_skip, gcov_skip_string, gcov_write_unsigned, gcov_write_counter,\n+\tgcov_write_string, gcov_read_unsigned, gcov_read_counter,\n+\tgcov_read_string, gcov_write_length): Modified to enable reading/\n+\twriting of whole .da file just once.\n+\t(da_file_open, da_file_close, da_file_eof, da_file_error,\n+\tda_file_position, da_file_seek, da_file_write, da_file_read): New\n+\tfunctions.\n+\t(actual_da_file, actual_da_file_position, actual_da_file_length,\n+\tactual_da_file_buffer, actual_da_file_buffer_size): New static\n+\tfunctions.\n+\t* libgcov.c (gcov_exit): Modified to read/write the whole .da file at\n+\tjust once.\n+\n+\n 2003-03-04  Andreas Schwab  <schwab@suse.de>\n \n \t* config/m68k/m68k.c (m68k_output_function_prologue): Fix CFA"}, {"sha": "4fcd7de5d21c8dcb96755e07b63837267c46d5a4", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 310, "deletions": 16, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec4a0419ad5374ad56137458e8de8bc4047cebe3/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec4a0419ad5374ad56137458e8de8bc4047cebe3/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=ec4a0419ad5374ad56137458e8de8bc4047cebe3", "patch": "@@ -302,18 +302,27 @@ static int gcov_write_summary PARAMS ((FILE *, unsigned,\n      ATTRIBUTE_UNUSED;\n #endif\n #define gcov_save_position(STREAM) \\\n- \tftell (STREAM)\n+ \tda_file_position (STREAM)\n #define gcov_reserve_length(STREAM) \\\n-\t(gcov_write_unsigned (STREAM, 0) ? 0 : ftell (STREAM) - 4)\n+\t(gcov_write_unsigned (STREAM, 0) ? 0 : da_file_position (STREAM) - 4)\n static int gcov_write_length PARAMS((FILE *, long))\n      ATTRIBUTE_UNUSED;\n #define gcov_resync(STREAM, BASE, LENGTH) \\\n-\tfseek (STREAM, BASE + (long)LENGTH, SEEK_SET)\n+\tda_file_seek (STREAM, BASE + (long)LENGTH, SEEK_SET)\n #define gcov_skip(STREAM, LENGTH) \\\n-\tfseek (STREAM, LENGTH, SEEK_CUR)\n+\tda_file_seek (STREAM, LENGTH, SEEK_CUR)\n #define gcov_skip_string(STREAM, LENGTH) \\\n-\tfseek (STREAM, (LENGTH) + 4 - ((LENGTH) & 3), SEEK_CUR)\n-\n+\tda_file_seek (STREAM, (LENGTH) + 4 - ((LENGTH) & 3), SEEK_CUR)\n+#if IN_LIBGCC2\n+static FILE *da_file_open PARAMS ((const char *, int *));\n+static int da_file_close PARAMS ((void));\n+static int da_file_eof PARAMS ((void));\n+static int da_file_error PARAMS ((void));\n+#endif\n+static unsigned long da_file_position PARAMS ((FILE *));\n+static int da_file_seek PARAMS ((FILE *, long, int));\n+static size_t da_file_write PARAMS ((const void *, size_t, size_t, FILE *));\n+static size_t da_file_read PARAMS ((void *, size_t, size_t, FILE *));\n \n /* Write VALUE to coverage file FILE.  Return nonzero if failed due to\n    file i/o error, or value error.  */\n@@ -332,7 +341,7 @@ gcov_write_unsigned (file, value)\n       value >>= 8;\n     }\n   return ((sizeof (value) > sizeof (buffer) && value)\n-\t  || fwrite (buffer, sizeof (buffer), 1, file) != 1);\n+\t  || da_file_write (buffer, 1, sizeof (buffer), file) != sizeof (buffer));\n }\n \n /* Write VALUE to coverage file FILE.  Return nonzero if failed due to\n@@ -353,7 +362,7 @@ gcov_write_counter (file, value)\n       value >>= 8;\n     }\n   return ((sizeof (value) > sizeof (buffer) && value != 0 && value != -1)\n-\t  || fwrite (buffer, sizeof (buffer), 1, file) != 1);\n+\t  || da_file_write (buffer, 1, sizeof (buffer), file) != sizeof (buffer));\n }\n \n /* Write VALUE to coverage file FILE.  Return nonzero if failed due to\n@@ -366,11 +375,12 @@ gcov_write_string (file, string, length)\n      const char *string;\n {\n   unsigned pad = 0;\n+  unsigned rem = 4 - (length & 3);\n \n   if (string)\n     return (gcov_write_unsigned (file, length)\n-\t    || fwrite (string, length, 1, file) != 1\n-\t    || fwrite (&pad, 4 - (length & 3), 1, file) != 1);\n+\t    || da_file_write (string, 1, length, file) != length\n+\t    || da_file_write (&pad, 1, rem, file) != rem);\n   else\n     return gcov_write_unsigned (file, 0);\n }\n@@ -387,7 +397,7 @@ gcov_read_unsigned (file, value_p)\n   unsigned ix;\n   unsigned char buffer[4];\n \n-  if (fread (buffer, sizeof (buffer), 1, file) != 1)\n+  if (da_file_read (buffer, 1, sizeof (buffer), file) != sizeof (buffer))\n     return 1;\n   for (ix = sizeof (value); ix < sizeof (buffer); ix++)\n     if (buffer[ix])\n@@ -413,7 +423,7 @@ gcov_read_counter (file, value_p)\n   unsigned ix;\n   unsigned char buffer[8];\n \n-  if (fread (buffer, sizeof (buffer), 1, file) != 1)\n+  if (da_file_read (buffer, 1, sizeof (buffer), file) != sizeof (buffer))\n     return 1;\n   for (ix = sizeof (value); ix < sizeof (buffer); ix++)\n     if (buffer[ix])\n@@ -457,7 +467,7 @@ gcov_read_string (file, string_p, length_p)\n   length += 4 - (length & 3);\n   *string_p = (char *) xmalloc (length);\n \n-  return fread (*string_p, length, 1, file) != 1;\n+  return da_file_read (*string_p, 1, length, file) != length;\n \n }\n \n@@ -472,10 +482,10 @@ gcov_write_length (file, place)\n      FILE *file;\n      long place;\n {\n-  long here = ftell (file);\n-  int result = (!place || fseek (file, place, SEEK_SET)\n+  long here = da_file_position (file);\n+  int result = (!place || da_file_seek (file, place, SEEK_SET)\n \t\t|| gcov_write_unsigned (file, here - place - 4));\n-  if (fseek (file, here, SEEK_SET))\n+  if (da_file_seek (file, here, SEEK_SET))\n     result = 1;\n   return result;\n }\n@@ -517,4 +527,288 @@ gcov_write_summary (da_file, tag, summary)\n }\n #endif\n \n+#if IN_LIBGCC2\n+/* The kernel had problems with managing a lot of small reads/writes we use;\n+   the functions below are used to buffer whole file in memory, thus reading and\n+   writing it only once.  This should be feasible, as we have this amount\n+   of memory for counters allocated anyway.  */\n+\n+static FILE *actual_da_file;\n+static unsigned long actual_da_file_position;\n+static unsigned long actual_da_file_length;\n+static char *actual_da_file_buffer;\n+static unsigned long actual_da_file_buffer_size;\n+\n+/* Open the file NAME and return it; in EXISTED return 1 if it existed\n+   already.  */\n+static FILE *\n+da_file_open (name, existed)\n+     const char *name;\n+     int *existed;\n+{\n+#if defined (TARGET_HAS_F_SETLKW)\n+  struct flock s_flock;\n+\n+  s_flock.l_type = F_WRLCK;\n+  s_flock.l_whence = SEEK_SET;\n+  s_flock.l_start = 0;\n+  s_flock.l_len = 0; /* Until EOF.  */\n+  s_flock.l_pid = getpid ();\n+#endif\n+\n+  if (actual_da_file)\n+    return 0;\n+  actual_da_file_position = 0;\n+  if (!actual_da_file_buffer)\n+    {\n+      actual_da_file_buffer = malloc (1);\n+      actual_da_file_buffer_size = 1;\n+    }\n+\n+  actual_da_file = fopen (name, \"r+t\");\n+  if (actual_da_file)\n+    *existed = 1;\n+  else\n+    {\n+      actual_da_file = fopen (name, \"w+t\");\n+      if (actual_da_file)\n+\t*existed = 0;\n+      else\n+\treturn 0;\n+    }\n+\n+#if defined (TARGET_HAS_F_SETLKW)\n+  /* After a fork, another process might try to read and/or write\n+     the same file simultaneously.  So if we can, lock the file to\n+     avoid race conditions.  */\n+  while (fcntl (fileno (actual_da_file), F_SETLKW, &s_flock)\n+\t && errno == EINTR)\n+    continue;\n+#endif\n+\n+  if (*existed)\n+    {\n+      if (fseek (actual_da_file, 0, SEEK_END))\n+\t{\n+\t  fclose (actual_da_file);\n+\t  actual_da_file = 0;\n+\t  return 0;\n+\t}\n+      actual_da_file_length = ftell (actual_da_file);\n+      rewind (actual_da_file);\n+    }\n+  else\n+    actual_da_file_length = 0;\n+\n+  if (actual_da_file_length > actual_da_file_buffer_size)\n+    {\n+      actual_da_file_buffer_size = actual_da_file_length;\n+      actual_da_file_buffer = realloc (actual_da_file_buffer,\n+\t\t\t\t       actual_da_file_buffer_size);\n+      if (!actual_da_file_buffer)\n+\t{\n+\t  fclose (actual_da_file);\n+\t  actual_da_file = 0;\n+\t  return 0;\n+\t}\n+    }\n+\n+  if (*existed)\n+    {\n+      if (fread (actual_da_file_buffer, actual_da_file_length,\n+\t\t 1, actual_da_file) != 1)\n+\t{\n+\t  fclose (actual_da_file);\n+\t  actual_da_file = 0;\n+\t  return 0;\n+\t}\n+      rewind (actual_da_file);\n+    }\n+\n+  return actual_da_file;\n+}\n+\n+/* Write changes to the .da file and close it.  */\n+static int da_file_close ()\n+{\n+  if (!actual_da_file)\n+    return -1;\n+  \n+  if (fwrite (actual_da_file_buffer, actual_da_file_length,\n+     \t      1, actual_da_file) != 1)\n+    return da_file_error ();\n+\n+  if (fclose (actual_da_file))\n+    {\n+      actual_da_file = 0;\n+      return -1;\n+    }\n+\n+  actual_da_file = 0;\n+  return 0;\n+}\n+\n+/* Returns current position in .da file.  */\n+static unsigned long\n+da_file_position (file)\n+     FILE *file;\n+{\n+  if (file)\n+    return ftell (file);\n+  return actual_da_file_position;\n+}\n+\n+/* Tests whether we have reached end of .da file.  */\n+static int\n+da_file_eof ()\n+{\n+  return actual_da_file_position == actual_da_file_length;\n+}\n+\n+/* Change position in the .da file.  */\n+static int\n+da_file_seek (file, pos, whence)\n+     FILE *file;\n+     long pos;\n+     int whence;\n+{\n+  if (file)\n+    return fseek (file, pos, whence);\n+\n+  if (!actual_da_file)\n+    return -1;\n+\n+  switch (whence)\n+    {\n+    case SEEK_CUR:\n+      if (pos < 0 && (unsigned long) -pos > actual_da_file_position)\n+\treturn da_file_error ();\n+\n+      actual_da_file_position += pos;\n+      break;\n+    case SEEK_SET:\n+      actual_da_file_position = pos;\n+      break;\n+    case SEEK_END:\n+      if ((unsigned long) -pos > actual_da_file_length)\n+\treturn da_file_error ();\n+      actual_da_file_position = actual_da_file_length + pos;\n+    }\n+  if (actual_da_file_position > actual_da_file_length)\n+    return da_file_error ();\n+  return 0;\n+}\n+\n+/* Write LEN chars of DATA to actual .da file; ELTS is expected to be 1,\n+   FILE 0.  */\n+static size_t\n+da_file_write (data, elts, len, file)\n+     const void *data;\n+     size_t elts;\n+     size_t len;\n+     FILE *file;\n+{\n+  size_t l = len;\n+  const char *dat = data;\n+\n+  if (file)\n+    return fwrite (data, elts, len, file);\n+\n+  if (elts != 1)\n+    abort ();\n+\n+  if (!actual_da_file)\n+    return -1;\n+  if (actual_da_file_position + len > actual_da_file_buffer_size)\n+    {\n+      actual_da_file_buffer_size = 2 * (actual_da_file_position + len);\n+      actual_da_file_buffer = realloc (actual_da_file_buffer,\n+\t\t\t\t       actual_da_file_buffer_size);\n+      if (!actual_da_file_buffer)\n+\treturn da_file_error ();\n+    }\n+  while (len--)\n+    actual_da_file_buffer[actual_da_file_position++] = *dat++;\n+  if (actual_da_file_position > actual_da_file_length)\n+    actual_da_file_length = actual_da_file_position;\n+\n+  return l;\n+}\n+\n+/* Read LEN chars of DATA from actual .da file; ELTS is expected to be 1,\n+   FILE 0.  */\n+static size_t\n+da_file_read (data, elts, len, file)\n+     void *data;\n+     size_t elts;\n+     size_t len;\n+     FILE *file;\n+{\n+  size_t l;\n+  char *dat = data;\n+\n+  if (file)\n+    return fread (data, elts, len, file);\n+\n+  if (elts != 1)\n+    abort ();\n+\n+  if (!actual_da_file)\n+    return -1;\n+  if (actual_da_file_position + len > actual_da_file_length)\n+    len = actual_da_file_length - actual_da_file_position;\n+  l = len;\n+  \n+  while (len--)\n+    *dat++ = actual_da_file_buffer[actual_da_file_position++];\n+  return l;\n+}\n+\n+/* Close the current .da file and report error.  */\n+static int\n+da_file_error ()\n+{\n+  if (actual_da_file)\n+    fclose (actual_da_file);\n+  actual_da_file = 0;\n+  return -1;\n+}\n+#else /* !IN_LIBGCC2 */\n+static size_t\n+da_file_write (data, elts, len, file)\n+     const void *data;\n+     size_t elts;\n+     size_t len;\n+     FILE *file;\n+{\n+  return fwrite (data, elts, len, file);\n+}\n+\n+static size_t\n+da_file_read (data, elts, len, file)\n+     void *data;\n+     size_t elts;\n+     size_t len;\n+     FILE *file;\n+{\n+  return fread (data, elts, len, file);\n+}\n+\n+static unsigned long\n+da_file_position (file)\n+     FILE *file;\n+{\n+  return ftell (file);\n+}\n+\n+static int\n+da_file_seek (file, pos, whence)\n+     FILE *file;\n+     long pos;\n+     int whence;\n+{\n+  return fseek (file, pos, whence);\n+}\n+#endif\n+\n #endif /* GCC_GCOV_IO_H */"}, {"sha": "31a160eec206ea63b77d2adae0b07700db076e4d", "filename": "gcc/libgcov.c", "status": "modified", "additions": 56, "deletions": 66, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec4a0419ad5374ad56137458e8de8bc4047cebe3/gcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec4a0419ad5374ad56137458e8de8bc4047cebe3/gcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcov.c?ref=ec4a0419ad5374ad56137458e8de8bc4047cebe3", "patch": "@@ -41,12 +41,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #undef NULL /* Avoid errors if stdio.h and our stddef.h mismatch.  */\n #include <stdio.h>\n \n-#include \"gcov-io.h\"\n #include <string.h>\n #if defined (TARGET_HAS_F_SETLKW)\n #include <fcntl.h>\n #include <errno.h>\n #endif\n+#include \"gcov-io.h\"\n \n /* Chain of per-object gcov structures.  */\n static struct gcov_info *gcov_list;\n@@ -106,7 +106,6 @@ gcov_exit (void)\n   \n   for (ptr = gcov_list; ptr; ptr = ptr->next)\n     {\n-      FILE *da_file;\n       struct gcov_summary object;\n       struct gcov_summary local_prg;\n       int merging = 0;\n@@ -154,39 +153,27 @@ gcov_exit (void)\n       memset (&object, 0, sizeof (object));\n       \n       /* Open for modification */\n-      if ((da_file = fopen (ptr->filename, \"r+b\")))\n-\tmerging = 1;\n-      else if ((da_file = fopen (ptr->filename, \"w+b\")))\n-\t;\n-      else\n+      if (!da_file_open (ptr->filename, &merging))\n \t{\n \t  fprintf (stderr, \"profiling:%s:Cannot open\\n\", ptr->filename);\n \t  ptr->filename = 0;\n \t  continue;\n \t}\n \n-#if defined (TARGET_HAS_F_SETLKW)\n-      /* After a fork, another process might try to read and/or write\n-         the same file simultaneously.  So if we can, lock the file to\n-         avoid race conditions.  */\n-      while (fcntl (fileno (da_file), F_SETLKW, &s_flock)\n-\t     && errno == EINTR)\n-\tcontinue;\n-#endif\n       if (merging)\n \t{\n \t  /* Merge data from file.  */\n \t      \n-\t  if (gcov_read_unsigned (da_file, &tag) || tag != GCOV_DATA_MAGIC)\n+\t  if (gcov_read_unsigned (0, &tag) || tag != GCOV_DATA_MAGIC)\n \t    {\n \t      fprintf (stderr, \"profiling:%s:Not a gcov data file\\n\",\n \t\t       ptr->filename);\n \t    read_fatal:;\n-\t      fclose (da_file);\n+\t      da_file_close ();\n \t      ptr->filename = 0;\n \t      continue;\n \t    }\n-\t  if (gcov_read_unsigned (da_file, &length) || length != GCOV_VERSION)\n+\t  if (gcov_read_unsigned (0, &length) || length != GCOV_VERSION)\n \t    {\n \t      gcov_version_mismatch (ptr, length);\n \t      goto read_fatal;\n@@ -196,8 +183,8 @@ gcov_exit (void)\n \t  for (ix = ptr->n_functions, fn_info = ptr->functions;\n \t       ix--; fn_info++)\n \t    {\n-\t      if (gcov_read_unsigned (da_file, &tag)\n-\t\t  || gcov_read_unsigned (da_file, &length))\n+\t      if (gcov_read_unsigned (0, &tag)\n+\t\t  || gcov_read_unsigned (0, &length))\n \t\t{\n \t\tread_error:;\n \t\t  fprintf (stderr, \"profiling:%s:Error merging\\n\",\n@@ -214,9 +201,9 @@ gcov_exit (void)\n \t\t  goto read_fatal;\n \t\t}\n \n-\t      if (gcov_read_unsigned (da_file, &flength)\n-\t\t  || gcov_skip_string (da_file, flength)\n-\t\t  || gcov_read_unsigned (da_file, &checksum))\n+\t      if (gcov_read_unsigned (0, &flength)\n+\t\t  || gcov_skip_string (0, flength)\n+\t\t  || gcov_read_unsigned (0, &checksum))\n \t\tgoto read_error;\n \t      if (flength != strlen (fn_info->name)\n \t\t  || checksum != fn_info->checksum)\n@@ -227,54 +214,59 @@ gcov_exit (void)\n \t\t   f_sect_index < fn_info->n_counter_sections;\n \t\t   f_sect_index++)\n \t\t{\n-\t\t  if (gcov_read_unsigned (da_file, &tag)\n-\t\t      || gcov_read_unsigned (da_file, &length))\n+\t\t  unsigned n_counters;\n+\n+\t\t  if (gcov_read_unsigned (0, &tag)\n+\t\t      || gcov_read_unsigned (0, &length))\n \t\t    goto read_error;\n \t\t  for (sect_index = 0;\n \t\t       sect_index < ptr->n_counter_sections;\n \t\t       sect_index++)\n \t\t    if (ptr->counter_sections[sect_index].tag == tag)\n \t\t      break;\n-\t\t  if (fn_info->counter_sections[f_sect_index].tag != tag\n-\t\t      || sect_index == ptr->n_counter_sections\n-\t\t      || length / 8 != fn_info->counter_sections[f_sect_index].n_counters)\n+\t\t  if (sect_index == ptr->n_counter_sections\n+\t\t      || fn_info->counter_sections[f_sect_index].tag != tag)\n \t\t    goto read_mismatch;\n-\t\t  \n-\t\t  for (jx = fn_info->counter_sections[f_sect_index].n_counters;\n-\t\t       jx--; counters[sect_index]++)\n-\t\t    if (gcov_read_counter (da_file, &count))\n-\t\t      goto read_error;\n+\n+\t\t  n_counters = fn_info->counter_sections[f_sect_index].n_counters;\n+\t\t  if (n_counters != length / 8)\n+\t\t    goto read_mismatch;\n+\t\t \n+\t\t  for (jx = 0; jx < n_counters; jx++)\n+\t    \t    if (gcov_read_counter (0, &count))\n+    \t\t      goto read_error;\n \t\t    else\n-\t\t      *counters[sect_index] += count;\n+\t\t      counters[sect_index][jx] += count;\n+\t\t  counters[sect_index] += n_counters;\n \t\t}\n \t    }\n \n \t  /* Check object summary */\n-\t  if (gcov_read_unsigned (da_file, &tag)\n-\t      || gcov_read_unsigned (da_file, &length))\n+\t  if (gcov_read_unsigned (0, &tag)\n+\t      || gcov_read_unsigned (0, &length))\n \t    goto read_error;\n \t  if (tag != GCOV_TAG_OBJECT_SUMMARY)\n \t    goto read_mismatch;\n-\t  if (gcov_read_summary (da_file, &object))\n+\t  if (gcov_read_summary (0, &object))\n \t    goto read_error;\n \n \t  /* Check program summary */\n \t  while (1)\n \t    {\n-\t      long base = ftell (da_file);\n+\t      long base = da_file_position (0);\n \t      \n-\t      if (gcov_read_unsigned (da_file, &tag)\n-\t\t  || gcov_read_unsigned (da_file, &length))\n+\t      if (gcov_read_unsigned (0, &tag)\n+\t\t  || gcov_read_unsigned (0, &length))\n \t\t{\n-\t\t  if (feof (da_file))\n+\t\t  if (da_file_eof ())\n \t\t    break;\n \t\t  goto read_error;\n \t\t}\n \t      if (tag != GCOV_TAG_PROGRAM_SUMMARY\n \t\t  && tag != GCOV_TAG_PLACEHOLDER_SUMMARY\n \t\t  && tag != GCOV_TAG_INCORRECT_SUMMARY)\n \t\tgoto read_mismatch;\n-\t      if (gcov_read_summary (da_file, &local_prg))\n+\t      if (gcov_read_summary (0, &local_prg))\n \t\tgoto read_error;\n \t      if (local_prg.checksum != program.checksum)\n \t\tcontinue;\n@@ -301,7 +293,7 @@ gcov_exit (void)\n \t      ptr->wkspc = base;\n \t      break;\n \t    }\n-\t  fseek (da_file, 0, SEEK_SET);\n+\t  da_file_seek (0, 0, SEEK_SET);\n \t}\n \n       object.runs++;\n@@ -313,12 +305,12 @@ gcov_exit (void)\n       \n       /* Write out the data.  */\n       if (/* magic */\n-\t  gcov_write_unsigned (da_file, GCOV_DATA_MAGIC)\n+\t  gcov_write_unsigned (0, GCOV_DATA_MAGIC)\n \t  /* version number */\n-\t  || gcov_write_unsigned (da_file, GCOV_VERSION))\n+\t  || gcov_write_unsigned (0, GCOV_VERSION))\n \t{\n \twrite_error:;\n-\t  fclose (da_file);\n+\t  da_file_close ();\n \t  fprintf (stderr, \"profiling:%s:Error writing\\n\", ptr->filename);\n \t  ptr->filename = 0;\n \t  continue;\n@@ -330,14 +322,14 @@ gcov_exit (void)\n       for (ix = ptr->n_functions, fn_info = ptr->functions; ix--; fn_info++)\n \t{\n \t  /* Announce function.  */\n-\t  if (gcov_write_unsigned (da_file, GCOV_TAG_FUNCTION)\n-\t      || !(base = gcov_reserve_length (da_file))\n+\t  if (gcov_write_unsigned (0, GCOV_TAG_FUNCTION)\n+\t      || !(base = gcov_reserve_length (0))\n \t      /* function name */\n-\t      || gcov_write_string (da_file, fn_info->name,\n+\t      || gcov_write_string (0, fn_info->name,\n \t\t\t\t    strlen (fn_info->name))\n \t      /* function checksum */\n-\t      || gcov_write_unsigned (da_file, fn_info->checksum)\n-\t      || gcov_write_length (da_file, base))\n+\t      || gcov_write_unsigned (0, fn_info->checksum)\n+\t      || gcov_write_length (0, base))\n \t    goto write_error;\n \n \t  /* counters.  */\n@@ -354,8 +346,8 @@ gcov_exit (void)\n \t      if (sect_index == ptr->n_counter_sections)\n \t\tabort ();\n \n-\t      if (gcov_write_unsigned (da_file, tag)\n-\t\t  || !(base = gcov_reserve_length (da_file)))\n+\t      if (gcov_write_unsigned (0, tag)\n+\t\t  || !(base = gcov_reserve_length (0)))\n \t\tgoto write_error;\n \t  \n     \t      for (jx = fn_info->counter_sections[f_sect_index].n_counters; jx--;)\n@@ -368,43 +360,41 @@ gcov_exit (void)\n \t\t      if (object.arc_max_sum < count)\n \t\t\tobject.arc_max_sum = count;\n \t\t    }\n-\t\t  if (gcov_write_counter (da_file, count))\n+\t\t  if (gcov_write_counter (0, count))\n \t\t    goto write_error; /* RIP Edsger Dijkstra */\n \t\t}\n-\t      if (gcov_write_length (da_file, base))\n+\t      if (gcov_write_length (0, base))\n \t\tgoto write_error;\n \t    }\n \t}\n \n       /* Object file summary.  */\n-      if (gcov_write_summary (da_file, GCOV_TAG_OBJECT_SUMMARY, &object))\n+      if (gcov_write_summary (0, GCOV_TAG_OBJECT_SUMMARY, &object))\n \tgoto write_error;\n \n       if (merging >= 0)\n \t{\n-\t  if (fseek (da_file, 0, SEEK_END))\n+\t  if (da_file_seek (0, 0, SEEK_END))\n \t    goto write_error;\n-\t  ptr->wkspc = ftell (da_file);\n-\t  if (gcov_write_summary (da_file, GCOV_TAG_PLACEHOLDER_SUMMARY,\n+\t  ptr->wkspc = da_file_position (0);\n+\t  if (gcov_write_summary (0, GCOV_TAG_PLACEHOLDER_SUMMARY,\n \t\t\t\t  &program))\n \t    goto write_error;\n \t}\n       else if (ptr->wkspc)\n \t{\n \t  /* Zap trailing program summary */\n-\t  if (fseek (da_file, ptr->wkspc, SEEK_SET))\n+\t  if (da_file_seek (0, ptr->wkspc, SEEK_SET))\n \t    goto write_error;\n \t  if (!local_prg.runs)\n \t    ptr->wkspc = 0;\n-\t  if (gcov_write_unsigned (da_file,\n-\t\t\t     local_prg.runs ? GCOV_TAG_PLACEHOLDER_SUMMARY\n-\t\t\t     : GCOV_TAG_INCORRECT_SUMMARY))\n+\t  if (gcov_write_unsigned (0, local_prg.runs\n+\t\t\t\t\t? GCOV_TAG_PLACEHOLDER_SUMMARY\n+\t\t\t\t\t: GCOV_TAG_INCORRECT_SUMMARY))\n \t    goto write_error;\n \t}\n-      if (fflush (da_file))\n-\tgoto write_error;\n \n-      if (fclose (da_file))\n+      if (da_file_close ())\n \t{\n \t  fprintf (stderr, \"profiling:%s:Error closing\\n\", ptr->filename);\n \t  ptr->filename = 0;"}]}