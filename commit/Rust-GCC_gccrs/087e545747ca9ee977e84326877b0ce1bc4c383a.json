{"sha": "087e545747ca9ee977e84326877b0ce1bc4c383a", "node_id": "C_kwDOANBUbNoAKDA4N2U1NDU3NDdjYTllZTk3N2U4NDMyNjg3N2IwY2UxYmM0YzM4M2E", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2022-01-21T11:48:28Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2022-01-21T17:45:30Z"}, "message": "Strengthen a few OpenACC test cases\n\nRather than rubber-stamp whatever requested vs. actual device kernel launch\nconfiguration happens, actually (again) verify the requested values (modulo\nexpected variations).\n\nThis better highlights that \"AMD GCN has an upper limit of 'num_workers(16)'\",\nand the deficiency that \"AMD GCN uses the autovectorizer for the vector\ndimension: the use of a function call in vector-partitioned code [...] is not\ncurrently supported\".\n\nAnd, this removes several instances of race conditions, where variables are\nconcurrently written to in OpenACC gang-redundant mode.\n\n\tlibgomp/\n\t* testsuite/libgomp.oacc-c-c++-common/loop-gwv-1.c: Strengthen.\n\t* testsuite/libgomp.oacc-c-c++-common/loop-gwv-2.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/loop-red-gwv-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/loop-red-v-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/loop-red-v-2.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/loop-red-w-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/loop-red-w-2.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/loop-red-wv-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/loop-v-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/loop-w-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/loop-wv-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/routine-gwv-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/routine-v-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/routine-w-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/routine-wv-1.c: Likewise.", "tree": {"sha": "445d8882268260758cba4adf4aa6863e5e7e3cc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/445d8882268260758cba4adf4aa6863e5e7e3cc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/087e545747ca9ee977e84326877b0ce1bc4c383a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/087e545747ca9ee977e84326877b0ce1bc4c383a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/087e545747ca9ee977e84326877b0ce1bc4c383a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/087e545747ca9ee977e84326877b0ce1bc4c383a/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23be9f83bbd2c6f03580757adbfe599de6bf702b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23be9f83bbd2c6f03580757adbfe599de6bf702b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23be9f83bbd2c6f03580757adbfe599de6bf702b"}], "stats": {"total": 259, "additions": 202, "deletions": 57}, "files": [{"sha": "d3f6ea24e7e3739733e74cf2ec0ee20258d4d925", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/loop-gwv-1.c", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-gwv-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-gwv-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-gwv-1.c?ref=087e545747ca9ee977e84326877b0ce1bc4c383a", "patch": "@@ -19,9 +19,12 @@ int main ()\n \n   for (ix = 0; ix < N;ix++)\n     ary[ix] = -1;\n-  \n-#pragma acc parallel num_gangs(32) num_workers(32) vector_length(32) \\\n-\t    copy(ary) copy(ondev) copyout(gangsize, workersize, vectorsize)\n+\n+#define NG 32\n+#define NW 32\n+#define VL 32\n+#pragma acc parallel num_gangs(NG) num_workers(NW) vector_length(VL) \\\n+\t    copy(ary) copy(ondev)\n   /* { dg-note {variable 'ix' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n   {\n #pragma acc loop gang worker vector\n@@ -45,11 +48,19 @@ int main ()\n \telse\n \t  ary[ix] = ix;\n       }\n-\n-    gangsize = __builtin_goacc_parlevel_size (GOMP_DIM_GANG);\n-    workersize = __builtin_goacc_parlevel_size (GOMP_DIM_WORKER);\n-    vectorsize = __builtin_goacc_parlevel_size (GOMP_DIM_VECTOR);\n   }\n+  gangsize = NG;\n+  workersize = NW;\n+  vectorsize = VL;\n+#ifdef ACC_DEVICE_TYPE_radeon\n+  /* AMD GCN has an upper limit of 'num_workers(16)'.  */\n+  if (workersize > 16)\n+    workersize = 16;\n+  /* AMD GCN uses the autovectorizer for the vector dimension: the use\n+     of a function call in vector-partitioned code in this test is not\n+     currently supported.  */\n+  vectorsize = 1;\n+#endif\n \n   for (ix = 0; ix < N; ix++)\n     {"}, {"sha": "4b761f0f6240851cd69e0250aaa659445f052a74", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/loop-gwv-2.c", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-gwv-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-gwv-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-gwv-2.c?ref=087e545747ca9ee977e84326877b0ce1bc4c383a", "patch": "@@ -46,14 +46,17 @@ int main ()\n   int ary[N];\n   int ix;\n   int exit = 0;\n-  int gangsize = 0, workersize = 0, vectorsize = 0;\n+  int gangsize, workersize, vectorsize;\n   int *gangdist, *workerdist, *vectordist;\n \n   for (ix = 0; ix < N;ix++)\n     ary[ix] = -1;\n \n-#pragma acc parallel num_gangs(32) num_workers(32) vector_length(32) \\\n-\t    copy(ary) copyout(gangsize, workersize, vectorsize)\n+#define NG 32\n+#define NW 32\n+#define VL 32\n+#pragma acc parallel num_gangs(NG) num_workers(NW) vector_length(VL) \\\n+\t    copy(ary)\n   /* { dg-note {variable 'ix' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n   {\n #pragma acc loop gang worker vector\n@@ -71,11 +74,23 @@ int main ()\n \n \tary[ix] = (g << 16) | (w << 8) | v;\n       }\n-\n-    gangsize = __builtin_goacc_parlevel_size (GOMP_DIM_GANG);\n-    workersize = __builtin_goacc_parlevel_size (GOMP_DIM_WORKER);\n-    vectorsize = __builtin_goacc_parlevel_size (GOMP_DIM_VECTOR);\n   }\n+  gangsize = NG;\n+  workersize = NW;\n+  vectorsize = VL;\n+#if defined ACC_DEVICE_TYPE_host\n+  gangsize = 1;\n+  workersize = 1;\n+  vectorsize = 1;\n+#elif defined ACC_DEVICE_TYPE_radeon\n+  /* AMD GCN has an upper limit of 'num_workers(16)'.  */\n+  if (workersize > 16)\n+    workersize = 16;\n+  /* AMD GCN uses the autovectorizer for the vector dimension: the use\n+     of a function call in vector-partitioned code in this test is not\n+     currently supported.  */\n+  vectorsize = 1;\n+#endif\n \n   gangdist = (int *) __builtin_alloca (gangsize * sizeof (int));\n   workerdist = (int *) __builtin_alloca (workersize * sizeof (int));\n@@ -92,6 +107,11 @@ int main ()\n       int w = (ary[ix] >> 8) & 255;\n       int v = ary[ix] & 255;\n \n+      if (g >= gangsize\n+\t  || w >= workersize\n+\t  || v >= vectorsize)\n+\t__builtin_abort ();\n+\n       gangdist[g]++;\n       workerdist[w]++;\n       vectordist[v]++;"}, {"sha": "4099d6072da98389d58648c5cb9a56c36b0eb52b", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/loop-red-gwv-1.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-red-gwv-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-red-gwv-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-red-gwv-1.c?ref=087e545747ca9ee977e84326877b0ce1bc4c383a", "patch": "@@ -16,8 +16,11 @@ int main ()\n   int t = 0, h = 0;\n   int gangsize, workersize, vectorsize;\n \n-#pragma acc parallel num_gangs(32) num_workers(32) vector_length(32) \\\n-\tcopy(ondev) copyout(gangsize, workersize, vectorsize)\n+#define NG 32\n+#define NW 32\n+#define VL 32\n+#pragma acc parallel num_gangs(NG) num_workers(NW) vector_length(VL) \\\n+\tcopy(ondev)\n   /* { dg-note {variable 'ix' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n   {\n #pragma acc loop gang worker vector reduction(+:t)\n@@ -42,10 +45,19 @@ int main ()\n \t  }\n \tt += val;\n       }\n-    gangsize = __builtin_goacc_parlevel_size (GOMP_DIM_GANG);\n-    workersize = __builtin_goacc_parlevel_size (GOMP_DIM_WORKER);\n-    vectorsize = __builtin_goacc_parlevel_size (GOMP_DIM_VECTOR);\n   }\n+  gangsize = NG;\n+  workersize = NW;\n+  vectorsize = VL;\n+#ifdef ACC_DEVICE_TYPE_radeon\n+  /* AMD GCN has an upper limit of 'num_workers(16)'.  */\n+  if (workersize > 16)\n+    workersize = 16;\n+  /* AMD GCN uses the autovectorizer for the vector dimension: the use\n+     of a function call in vector-partitioned code in this test is not\n+     currently supported.  */\n+  vectorsize = 1;\n+#endif\n \n   for (ix = 0; ix < N; ix++)\n     {"}, {"sha": "0fe368623c313e6ec5c16c4804c9521de5a55ce7", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/loop-red-v-1.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-red-v-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-red-v-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-red-v-1.c?ref=087e545747ca9ee977e84326877b0ce1bc4c383a", "patch": "@@ -17,7 +17,8 @@ int main ()\n   int t = 0,  h = 0;\n   int vectorsize;\n \n-#pragma acc parallel vector_length(32) copy(ondev) copyout(vectorsize)\n+#define VL 32\n+#pragma acc parallel vector_length(VL) copy(ondev)\n   /* { dg-note {variable 'ix' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n   {\n #pragma acc loop vector reduction (+:t)\n@@ -42,8 +43,14 @@ int main ()\n \t  }\n \tt += val;\n       }\n-    vectorsize = __builtin_goacc_parlevel_size (GOMP_DIM_VECTOR);\n   }\n+  vectorsize = VL;\n+#ifdef ACC_DEVICE_TYPE_radeon\n+  /* AMD GCN uses the autovectorizer for the vector dimension: the use\n+     of a function call in vector-partitioned code in this test is not\n+     currently supported.  */\n+  vectorsize = 1;\n+#endif\n \n   for (ix = 0; ix < N; ix++)\n     {"}, {"sha": "0cf2d473eb81f9bcaad709c1855d1e3096919f9d", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/loop-red-v-2.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-red-v-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-red-v-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-red-v-2.c?ref=087e545747ca9ee977e84326877b0ce1bc4c383a", "patch": "@@ -17,7 +17,8 @@ int main ()\n   int q = 0,  h = 0;\n   int vectorsize;\n \n-#pragma acc parallel vector_length(32) copy(q) copy(ondev) copyout(vectorsize)\n+#define VL 32\n+#pragma acc parallel vector_length(VL) copy(q) copy(ondev)\n   /* { dg-note {variable 't' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n   /* { dg-note {variable 'ix' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n   {\n@@ -46,8 +47,14 @@ int main ()\n \tt += val;\n       }\n     q = t;\n-    vectorsize = __builtin_goacc_parlevel_size (GOMP_DIM_VECTOR);\n   }\n+  vectorsize = VL;\n+#ifdef ACC_DEVICE_TYPE_radeon\n+  /* AMD GCN uses the autovectorizer for the vector dimension: the use\n+     of a function call in vector-partitioned code in this test is not\n+     currently supported.  */\n+  vectorsize = 1;\n+#endif\n \n   for (ix = 0; ix < N; ix++)\n     {"}, {"sha": "b0cb09399ba77d268471d59caea7127b4c566d89", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/loop-red-w-1.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-red-w-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-red-w-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-red-w-1.c?ref=087e545747ca9ee977e84326877b0ce1bc4c383a", "patch": "@@ -19,8 +19,10 @@ int main ()\n   int t = 0,  h = 0;\n   int workersize;\n \n-#pragma acc parallel num_workers(32) vector_length(32) copy(ondev) \\\n-\t    copyout(workersize)\n+#define NW 32\n+#define VL 32\n+#pragma acc parallel num_workers(NW) vector_length(VL) \\\n+\t    copy(ondev)\n   /* { dg-note {variable 'ix' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n   /* { dg-warning \"region is vector partitioned but does not contain vector partitioned code\" \"\" { target *-*-* } .-3 } */\n   {\n@@ -46,8 +48,13 @@ int main ()\n \t  }\n \tt += val;\n       }\n-    workersize = __builtin_goacc_parlevel_size (GOMP_DIM_WORKER);\n   }\n+  workersize = NW;\n+#ifdef ACC_DEVICE_TYPE_radeon\n+  /* AMD GCN has an upper limit of 'num_workers(16)'.  */\n+  if (workersize > 16)\n+    workersize = 16;\n+#endif\n \n   for (ix = 0; ix < N; ix++)\n     {"}, {"sha": "f9baedb0c466d195d207d89f3b7ce2f24d4e55d7", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/loop-red-w-2.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-red-w-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-red-w-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-red-w-2.c?ref=087e545747ca9ee977e84326877b0ce1bc4c383a", "patch": "@@ -19,8 +19,10 @@ int main ()\n   int q = 0,  h = 0;\n   int workersize;\n \n-#pragma acc parallel num_workers(32) vector_length(32) copy(q) copy(ondev) \\\n-\t    copyout(workersize)\n+#define NW 32\n+#define VL 32\n+#pragma acc parallel num_workers(NW) vector_length(VL) \\\n+\t    copy(q) copy(ondev)\n   /* { dg-note {variable 't' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n   /* { dg-note {variable 'ix' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-3 } */\n   /* { dg-warning \"region is vector partitioned but does not contain vector partitioned code\" \"\" { target *-*-* } .-4 } */\n@@ -50,8 +52,13 @@ int main ()\n \tt += val;\n       }\n     q = t;\n-    workersize = __builtin_goacc_parlevel_size (GOMP_DIM_WORKER);\n   }\n+  workersize = NW;\n+#ifdef ACC_DEVICE_TYPE_radeon\n+  /* AMD GCN has an upper limit of 'num_workers(16)'.  */\n+  if (workersize > 16)\n+    workersize = 16;\n+#endif\n \n   for (ix = 0; ix < N; ix++)\n     {"}, {"sha": "fadb2627f73ef78dd2241f5e7c6aabea9aa05568", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/loop-red-wv-1.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-red-wv-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-red-wv-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-red-wv-1.c?ref=087e545747ca9ee977e84326877b0ce1bc4c383a", "patch": "@@ -16,8 +16,10 @@ int main ()\n   int t = 0, h = 0;\n   int workersize, vectorsize;\n   \n-#pragma acc parallel num_workers(32) vector_length(32) copy(ondev) \\\n-\t    copyout(workersize, vectorsize)\n+#define NW 32\n+#define VL 32\n+#pragma acc parallel num_workers(NW) vector_length(VL) \\\n+\t    copy(ondev)\n   /* { dg-note {variable 'ix' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n   {\n #pragma acc loop worker vector reduction (+:t)\n@@ -42,9 +44,18 @@ int main ()\n \t  }\n \tt += val;\n       }\n-    workersize = __builtin_goacc_parlevel_size (GOMP_DIM_WORKER);\n-    vectorsize = __builtin_goacc_parlevel_size (GOMP_DIM_VECTOR);\n   }\n+  workersize = NW;\n+  vectorsize = VL;\n+#ifdef ACC_DEVICE_TYPE_radeon\n+  /* AMD GCN has an upper limit of 'num_workers(16)'.  */\n+  if (workersize > 16)\n+    workersize = 16;\n+  /* AMD GCN uses the autovectorizer for the vector dimension: the use\n+     of a function call in vector-partitioned code in this test is not\n+     currently supported.  */\n+  vectorsize = 1;\n+#endif\n \n   for (ix = 0; ix < N; ix++)\n     {"}, {"sha": "bfd22b0db7fa220641a26d236a99598c6a7d5d4b", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/loop-v-1.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-v-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-v-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-v-1.c?ref=087e545747ca9ee977e84326877b0ce1bc4c383a", "patch": "@@ -20,8 +20,9 @@ int main ()\n   for (ix = 0; ix < N;ix++)\n     ary[ix] = -1;\n   \n-#pragma acc parallel vector_length(32) copy(ary) copy(ondev) \\\n-\t    copyout(vectorsize)\n+#define VL 32\n+#pragma acc parallel vector_length(VL) \\\n+\t    copy(ary) copy(ondev)\n   /* { dg-note {variable 'ix' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n   {\n #pragma acc loop vector\n@@ -44,8 +45,14 @@ int main ()\n \telse\n \t  ary[ix] = ix;\n       }\n-    vectorsize = __builtin_goacc_parlevel_size (GOMP_DIM_VECTOR);\n   }\n+  vectorsize = VL;\n+#ifdef ACC_DEVICE_TYPE_radeon\n+  /* AMD GCN uses the autovectorizer for the vector dimension: the use\n+     of a function call in vector-partitioned code in this test is not\n+     currently supported.  */\n+  vectorsize = 1;\n+#endif\n \n   for (ix = 0; ix < N; ix++)\n     {"}, {"sha": "b910e251fb1171987939cce041dda5153d4a98ff", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/loop-w-1.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-w-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-w-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-w-1.c?ref=087e545747ca9ee977e84326877b0ce1bc4c383a", "patch": "@@ -23,8 +23,10 @@ int main ()\n   for (ix = 0; ix < N;ix++)\n     ary[ix] = -1;\n   \n-#pragma acc parallel num_workers(32) vector_length(32) copy(ary) copy(ondev) \\\n-\t    copyout(workersize)\n+#define NW 32\n+#define VL 32\n+#pragma acc parallel num_workers(NW) vector_length(VL) \\\n+\t    copy(ary) copy(ondev)\n   /* { dg-note {variable 'ix' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n   /* { dg-warning \"region is vector partitioned but does not contain vector partitioned code\" \"vector\" { target *-*-* } .-3 } */\n   {\n@@ -48,8 +50,13 @@ int main ()\n \telse\n \t  ary[ix] = ix;\n       }\n-    workersize = __builtin_goacc_parlevel_size (GOMP_DIM_WORKER);\n   }\n+  workersize = NW;\n+#ifdef ACC_DEVICE_TYPE_radeon\n+  /* AMD GCN has an upper limit of 'num_workers(16)'.  */\n+  if (workersize > 16)\n+    workersize = 16;\n+#endif\n \n   for (ix = 0; ix < N; ix++)\n     {"}, {"sha": "77326068a666db754f38988b38fc228a350617f8", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/loop-wv-1.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-wv-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-wv-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Floop-wv-1.c?ref=087e545747ca9ee977e84326877b0ce1bc4c383a", "patch": "@@ -20,8 +20,10 @@ int main ()\n   for (ix = 0; ix < N;ix++)\n     ary[ix] = -1;\n   \n-#pragma acc parallel num_workers(32) vector_length(32) copy(ary) copy(ondev) \\\n-\t    copyout(workersize, vectorsize)\n+#define NW 32\n+#define VL 32\n+#pragma acc parallel num_workers(NW) vector_length(VL) \\\n+\t    copy(ary) copy(ondev)\n   /* { dg-note {variable 'ix' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n   {\n #pragma acc loop worker vector\n@@ -44,9 +46,18 @@ int main ()\n \telse\n \t  ary[ix] = ix;\n       }\n-    workersize = __builtin_goacc_parlevel_size (GOMP_DIM_WORKER);\n-    vectorsize = __builtin_goacc_parlevel_size (GOMP_DIM_VECTOR);\n   }\n+  workersize = NW;\n+  vectorsize = VL;\n+#ifdef ACC_DEVICE_TYPE_radeon\n+  /* AMD GCN has an upper limit of 'num_workers(16)'.  */\n+  if (workersize > 16)\n+    workersize = 16;\n+  /* AMD GCN uses the autovectorizer for the vector dimension: the use\n+     of a function call in vector-partitioned code in this test is not\n+     currently supported.  */\n+  vectorsize = 1;\n+#endif\n \n   for (ix = 0; ix < N; ix++)\n     {"}, {"sha": "81e08119214a1619d01ca5033f8bc0e0b2c8c8fe", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/routine-gwv-1.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Froutine-gwv-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Froutine-gwv-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Froutine-gwv-1.c?ref=087e545747ca9ee977e84326877b0ce1bc4c383a", "patch": "@@ -35,14 +35,27 @@ int main ()\n   for (ix = 0; ix < N;ix++)\n     ary[ix] = -1;\n   \n-#pragma acc parallel num_gangs(32) num_workers(32) vector_length(32) copy(ary) copy(ondev) copyout(gangsize, workersize, vectorsize)\n+#define NG 32\n+#define NW 32\n+#define VL 32\n+#pragma acc parallel num_gangs(NG) num_workers(NW) vector_length(VL) \\\n+  copy(ary) copy(ondev)\n   {\n     ondev = acc_on_device (acc_device_not_host);\n     gang (ary);\n-    gangsize = __builtin_goacc_parlevel_size (GOMP_DIM_GANG);\n-    workersize = __builtin_goacc_parlevel_size (GOMP_DIM_WORKER);\n-    vectorsize = __builtin_goacc_parlevel_size (GOMP_DIM_VECTOR);\n   }\n+  gangsize = NG;\n+  workersize = NW;\n+  vectorsize = VL;\n+#ifdef ACC_DEVICE_TYPE_radeon\n+  /* AMD GCN has an upper limit of 'num_workers(16)'.  */\n+  if (workersize > 16)\n+    workersize = 16;\n+  /* AMD GCN uses the autovectorizer for the vector dimension: the use\n+     of a function call in vector-partitioned code in this test is not\n+     currently supported.  */\n+  vectorsize = 1;\n+#endif\n \n   for (ix = 0; ix < N; ix++)\n     {"}, {"sha": "7310906bd2d62f5785fac5b7150395ee105b3995", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/routine-v-1.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Froutine-v-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Froutine-v-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Froutine-v-1.c?ref=087e545747ca9ee977e84326877b0ce1bc4c383a", "patch": "@@ -35,13 +35,20 @@ int main ()\n   for (ix = 0; ix < N;ix++)\n     ary[ix] = -1;\n   \n-#pragma acc parallel vector_length(32) copy(ary) copy(ondev) \\\n-\t    copyout(vectorsize)\n+#define VL 32\n+#pragma acc parallel vector_length(VL) \\\n+\t    copy(ary) copy(ondev)\n   {\n     ondev = acc_on_device (acc_device_not_host);\n     vector (ary);\n-    vectorsize = __builtin_goacc_parlevel_size (GOMP_DIM_VECTOR);\n   }\n+  vectorsize = VL;\n+#ifdef ACC_DEVICE_TYPE_radeon\n+  /* AMD GCN uses the autovectorizer for the vector dimension: the use\n+     of a function call in vector-partitioned code in this test is not\n+     currently supported.  */\n+  vectorsize = 1;\n+#endif\n \n   for (ix = 0; ix < N; ix++)\n     {"}, {"sha": "4521cb911437d14e0d343764a5794a4402c49e38", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/routine-w-1.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Froutine-w-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Froutine-w-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Froutine-w-1.c?ref=087e545747ca9ee977e84326877b0ce1bc4c383a", "patch": "@@ -39,13 +39,20 @@ int main ()\n   for (ix = 0; ix < N;ix++)\n     ary[ix] = -1;\n   \n-#pragma acc parallel num_workers(32) vector_length(32) copy(ary) copy(ondev) \\\n-\t    copyout(workersize)\n+#define NW 32\n+#define VL 32\n+#pragma acc parallel num_workers(NW) vector_length(VL) \\\n+\t    copy(ary) copy(ondev)\n   {\n     ondev = acc_on_device (acc_device_not_host);\n     worker (ary);\n-    workersize = __builtin_goacc_parlevel_size (GOMP_DIM_WORKER);\n   }\n+  workersize = NW;\n+#ifdef ACC_DEVICE_TYPE_radeon\n+  /* AMD GCN has an upper limit of 'num_workers(16)'.  */\n+  if (workersize > 16)\n+    workersize = 16;\n+#endif\n \n   for (ix = 0; ix < N; ix++)\n     {"}, {"sha": "647d075bb0068753f31507c7a034b5627376225b", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/routine-wv-1.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Froutine-wv-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/087e545747ca9ee977e84326877b0ce1bc4c383a/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Froutine-wv-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Froutine-wv-1.c?ref=087e545747ca9ee977e84326877b0ce1bc4c383a", "patch": "@@ -35,14 +35,25 @@ int main ()\n   for (ix = 0; ix < N;ix++)\n     ary[ix] = -1;\n   \n-#pragma acc parallel num_workers(32) vector_length(32) copy(ary) copy(ondev) \\\n-\t    copyout(workersize, vectorsize)\n+#define NW 32\n+#define VL 32\n+#pragma acc parallel num_workers(NW) vector_length(VL) \\\n+\t    copy(ary) copy(ondev)\n   {\n     ondev = acc_on_device (acc_device_not_host);\n     worker (ary);\n-    workersize = __builtin_goacc_parlevel_size (GOMP_DIM_WORKER);\n-    vectorsize = __builtin_goacc_parlevel_size (GOMP_DIM_VECTOR);\n   }\n+  workersize = NW;\n+  vectorsize = VL;\n+#ifdef ACC_DEVICE_TYPE_radeon\n+  /* AMD GCN has an upper limit of 'num_workers(16)'.  */\n+  if (workersize > 16)\n+    workersize = 16;\n+  /* AMD GCN uses the autovectorizer for the vector dimension: the use\n+     of a function call in vector-partitioned code in this test is not\n+     currently supported.  */\n+  vectorsize = 1;\n+#endif\n \n   for (ix = 0; ix < N; ix++)\n     {"}]}