{"sha": "e655a6cc43e880b291b726394c1c6be6db461e89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY1NWE2Y2M0M2U4ODBiMjkxYjcyNjM5NGMxYzZiZTZkYjQ2MWU4OQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-08-01T17:59:11Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-08-01T17:59:11Z"}, "message": "re PR fortran/45435 (Automatically generate C interop interface blocks from C code)\n\n2017-08-01  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/45435\n\t* lang.opt (fc-prototypes): Add option.\n\t* gfortran.h (gfc_typespec): Add interop_kind to struct.\n\t(gfc_dump_c_prototypes): Add prototype.\n\t* decl.c (gfc_match_kind_spec): Copy symbol used for kind to typespec.\n\t* parse.c (gfc_parse_file): Call gfc_dump_prototypes.\n\t* dump-parse-tree.c (gfc_dump_c_prototypes): New function.\n\t(type_return): New enum.\n\t(get_c_type_name): New function.\n\t(write_decl): New function.\n\t(write_type): New function.\n\t(write_variable): New function.\n\t(write_proc): New function.\n\t(write_interop_decl): New function.\n\t* invoke.texi: Document -fc-prototypes.\n\nFrom-SVN: r250791", "tree": {"sha": "ae5f1937db6ee534a99d8620aff5982d4785e186", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae5f1937db6ee534a99d8620aff5982d4785e186"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e655a6cc43e880b291b726394c1c6be6db461e89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e655a6cc43e880b291b726394c1c6be6db461e89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e655a6cc43e880b291b726394c1c6be6db461e89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e655a6cc43e880b291b726394c1c6be6db461e89/comments", "author": null, "committer": null, "parents": [{"sha": "5cada901b548a5b02e18fe5d5d074c5d100a406d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cada901b548a5b02e18fe5d5d074c5d100a406d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cada901b548a5b02e18fe5d5d074c5d100a406d"}], "stats": {"total": 313, "additions": 313, "deletions": 0}, "files": [{"sha": "bd9ecc348f4430c4df7b23f859b6dd59eb678b2c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e655a6cc43e880b291b726394c1c6be6db461e89/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e655a6cc43e880b291b726394c1c6be6db461e89/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e655a6cc43e880b291b726394c1c6be6db461e89", "patch": "@@ -1,3 +1,21 @@\n+2017-08-01  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/45435\n+\t* lang.opt (fc-prototypes): Add option.\n+\t* gfortran.h (gfc_typespec): Add interop_kind to struct.\n+\t(gfc_dump_c_prototypes): Add prototype.\n+\t* decl.c (gfc_match_kind_spec): Copy symbol used for kind to typespec.\n+\t* parse.c (gfc_parse_file): Call gfc_dump_prototypes.\n+\t* dump-parse-tree.c (gfc_dump_c_prototypes): New function.\n+\t(type_return): New enum.\n+\t(get_c_type_name): New function.\n+\t(write_decl): New function.\n+\t(write_type): New function.\n+\t(write_variable): New function.\n+\t(write_proc): New function.\n+\t(write_interop_decl): New function.\n+\t* invoke.texi: Document -fc-prototypes.\n+\n 2017-08-01  Dominique d'Humieres  <dominiq@lps.ens.fr>\n \n \tPR fortran/53542"}, {"sha": "54ee5d3d2a62cd54033372ce581c75a5319ace6c", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e655a6cc43e880b291b726394c1c6be6db461e89/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e655a6cc43e880b291b726394c1c6be6db461e89/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=e655a6cc43e880b291b726394c1c6be6db461e89", "patch": "@@ -2631,6 +2631,8 @@ gfc_match_kind_spec (gfc_typespec *ts, bool kind_expr_only)\n \t of the named constants from iso_c_binding.  */\n       ts->is_c_interop = e->ts.is_iso_c;\n       ts->f90_type = e->ts.f90_type;\n+      if (e->symtree)\n+\tts->interop_kind = e->symtree->n.sym;\n     }\n \n   gfc_free_expr (e);"}, {"sha": "da9c5415e1d7a10e0e9b677ab005624b1ca2bf9a", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e655a6cc43e880b291b726394c1c6be6db461e89/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e655a6cc43e880b291b726394c1c6be6db461e89/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=e655a6cc43e880b291b726394c1c6be6db461e89", "patch": "@@ -2891,3 +2891,253 @@ gfc_dump_parse_tree (gfc_namespace *ns, FILE *file)\n   show_namespace (ns);\n }\n \n+/* This part writes BIND(C) definition for use in external C programs.  */\n+\n+static void write_interop_decl (gfc_symbol *);\n+\n+void\n+gfc_dump_c_prototypes (gfc_namespace *ns, FILE *file)\n+{\n+  int error_count;\n+  gfc_get_errors (NULL, &error_count);\n+  if (error_count != 0)\n+    return;\n+  dumpfile = file;\n+  gfc_traverse_ns (ns, write_interop_decl);\n+}\n+\n+enum type_return { T_OK=0, T_WARN, T_ERROR };\n+\n+/* Return the name of the type for later output.  Both function pointers and\n+   void pointers will be mapped to void *.  */\n+\n+static enum type_return\n+get_c_type_name (gfc_typespec *ts, gfc_array_spec *as, const char **pre,\n+\t\t const char **type_name, bool *asterisk, const char **post,\n+\t\t bool func_ret)\n+{\n+  static char post_buffer[40];\n+  enum type_return ret;\n+  ret = T_ERROR;\n+\n+  *pre = \" \";\n+  *asterisk = false;\n+  *post = \"\";\n+  *type_name = \"<error>\";\n+  if (ts->type == BT_REAL || ts->type == BT_INTEGER)\n+    {\n+ \n+      if (ts->is_c_interop && ts->interop_kind)\n+\t{\n+\t  *type_name = ts->interop_kind->name + 2;\n+\t  if (strcmp (*type_name, \"signed_char\") == 0)\n+\t    *type_name = \"signed char\";\n+\t  else if (strcmp (*type_name, \"size_t\") == 0)\n+\t    *type_name = \"ssize_t\";\n+\n+\t  ret = T_OK;\n+\t}\n+      else\n+\t{\n+\t  /* The user did not specify a C interop type.  Let's look through\n+\t     the available table and use the first one, but warn.  */\n+\t  int i;\n+\t  for (i=0; i<ISOCBINDING_NUMBER; i++)\n+\t    {\n+\t      if (c_interop_kinds_table[i].f90_type == ts->type\n+\t\t  && c_interop_kinds_table[i].value == ts->kind)\n+\t\t{\n+\t\t  *type_name = c_interop_kinds_table[i].name + 2;\n+\t\t  if (strcmp (*type_name, \"signed_char\") == 0)\n+\t\t    *type_name = \"signed char\";\n+\t\t  else if (strcmp (*type_name, \"size_t\") == 0)\n+\t\t    *type_name = \"ssize_t\";\n+\n+\t\t  ret = T_WARN;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else if (ts->type == BT_DERIVED)\n+    {\n+      if (ts->u.derived->from_intmod == INTMOD_ISO_C_BINDING)\n+\t{\n+\t  if (strcmp (ts->u.derived->name, \"c_ptr\") == 0)\n+\t    *type_name = \"void\";\n+\t  else if (strcmp (ts->u.derived->name, \"c_funptr\") == 0)\n+\t    {\n+\t      *type_name = \"int \";\n+\t      if (func_ret)\n+\t\t{\n+\t\t  *pre = \"(\";\n+\t\t  *post = \"())\";\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  *pre = \"(\";\n+\t\t  *post = \")()\";\n+\t\t}\n+\t    }\n+\t  *asterisk = true;\n+\t}\n+      else\n+\t*type_name = ts->u.derived->name;\n+\n+      ret = T_OK;\n+    }\n+  if (ret != T_ERROR && as)\n+    {\n+      mpz_t sz;\n+      bool size_ok;\n+      size_ok = spec_size (as, &sz);\n+      gcc_assert (size_ok == true);\n+      gmp_snprintf (post_buffer, sizeof(post_buffer), \"[%Zd]\", sz);\n+      *post = post_buffer;\n+      mpz_clear (sz);\n+    }\n+  return ret;\n+}\n+\n+/* Write out a declaration.  */\n+static void\n+write_decl (gfc_typespec *ts, gfc_array_spec *as, const char *sym_name,\n+\t    bool func_ret)\n+{\n+    const char *pre, *type_name, *post;\n+    bool asterisk;\n+    enum type_return rok;\n+\n+    rok = get_c_type_name (ts, as, &pre, &type_name, &asterisk, &post, func_ret);\n+    gcc_assert (rok != T_ERROR);\n+    fputs (type_name, dumpfile);\n+    fputs (pre, dumpfile);\n+    if (asterisk)\n+      fputs (\"*\", dumpfile);\n+\n+    fputs (sym_name, dumpfile);\n+    fputs (post, dumpfile);\n+    \n+    if (rok == T_WARN)\n+      fputs(\" /* WARNING: non-interoperable KIND */\", dumpfile);\n+}\n+\n+/* Write out an interoperable type.  It will be written as a typedef\n+   for a struct.  */\n+\n+static void\n+write_type (gfc_symbol *sym)\n+{\n+  gfc_component *c;\n+\n+  fprintf (dumpfile, \"typedef struct %s {\\n\", sym->name);\n+  for (c = sym->components; c; c = c->next)\n+    {\n+      fputs (\"    \", dumpfile);\n+      write_decl (&(c->ts), c->as, c->name, false);\n+      fputs (\";\\n\", dumpfile);\n+    }\n+\n+  fprintf (dumpfile, \"} %s;\\n\", sym->name);\n+}\n+\n+/* Write out a variable.  */\n+\n+static void\n+write_variable (gfc_symbol *sym)\n+{\n+  const char *sym_name;\n+\n+  gcc_assert (sym->attr.flavor == FL_VARIABLE);\n+\n+  if (sym->binding_label)\n+    sym_name = sym->binding_label;\n+  else\n+    sym_name = sym->name;\n+\n+  fputs (\"extern \", dumpfile);\n+  write_decl (&(sym->ts), sym->as, sym_name, false);\n+  fputs (\";\\n\", dumpfile);\n+}\n+\n+\n+/* Write out a procedure, including its arguments.  */\n+static void\n+write_proc (gfc_symbol *sym)\n+{\n+  const char *pre, *type_name, *post;\n+  bool asterisk;\n+  enum type_return rok;\n+  gfc_formal_arglist *f;\n+  const char *sym_name;\n+  const char *intent_in;\n+\n+  if (sym->binding_label)\n+    sym_name = sym->binding_label;\n+  else\n+    sym_name = sym->name;\n+\n+  if (sym->ts.type == BT_UNKNOWN)\n+    {\n+      fprintf (dumpfile, \"void \");\n+      fputs (sym_name, dumpfile);\n+    }\n+  else\n+    write_decl (&(sym->ts), sym->as, sym->name, true);\n+\n+  fputs (\" (\", dumpfile);\n+\n+  for (f = sym->formal; f; f = f->next)\n+    {\n+      gfc_symbol *s;\n+      s = f->sym;\n+      rok = get_c_type_name (&(s->ts), NULL, &pre, &type_name, &asterisk,\n+\t\t\t     &post, false);\n+      gcc_assert (rok != T_ERROR);\n+\n+      if (!s->attr.value)\n+\tasterisk = true;\n+\n+      if (s->attr.intent == INTENT_IN && !s->attr.value)\n+\tintent_in = \"const \";\n+      else\n+\tintent_in = \"\";\n+\n+      fputs (intent_in, dumpfile);\n+      fputs (type_name, dumpfile);\n+      fputs (pre, dumpfile);\n+      if (asterisk)\n+\tfputs (\"*\", dumpfile);\n+\n+      fputs (s->name, dumpfile);\n+      fputs (post, dumpfile);\n+      if (rok == T_WARN)\n+\tfputs(\" /* WARNING: non-interoperable KIND */ \", dumpfile);\n+\n+      fputs (f->next ? \", \" : \")\", dumpfile);\n+    }\n+  fputs (\";\\n\", dumpfile);\n+}\n+\n+\n+/* Write a C-interoperable declaration as a C prototype or extern\n+   declaration.  */\n+\n+static void\n+write_interop_decl (gfc_symbol *sym)\n+{\n+  /* Only dump bind(c) entities.  */\n+  if (!sym->attr.is_bind_c)\n+    return;\n+\n+  /* Don't dump our iso c module.  */\n+  if (sym->from_intmod == INTMOD_ISO_C_BINDING)\n+    return;\n+\n+  if (sym->attr.flavor == FL_VARIABLE)\n+    write_variable (sym);\n+  else if (sym->attr.flavor == FL_DERIVED)\n+    write_type (sym);\n+  else if (sym->attr.flavor == FL_PROCEDURE)\n+    write_proc (sym);\n+}"}, {"sha": "4d51d145277b4e9e0f72263964103aa2bb16fa71", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e655a6cc43e880b291b726394c1c6be6db461e89/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e655a6cc43e880b291b726394c1c6be6db461e89/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=e655a6cc43e880b291b726394c1c6be6db461e89", "patch": "@@ -1012,6 +1012,7 @@ typedef struct\n   int is_iso_c;\n   bt f90_type;\n   bool deferred;\n+  gfc_symbol *interop_kind;\n }\n gfc_typespec;\n \n@@ -3311,6 +3312,7 @@ void gfc_delete_bbt (void *, void *, compare_fn);\n \n /* dump-parse-tree.c */\n void gfc_dump_parse_tree (gfc_namespace *, FILE *);\n+void gfc_dump_c_prototypes (gfc_namespace *, FILE *);\n \n /* parse.c */\n bool gfc_parse_file (void);"}, {"sha": "15fdc16028a541d080820fef61547814a0d5e2a9", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e655a6cc43e880b291b726394c1c6be6db461e89/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e655a6cc43e880b291b726394c1c6be6db461e89/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=e655a6cc43e880b291b726394c1c6be6db461e89", "patch": "@@ -100,6 +100,8 @@ one is not the default.\n * Runtime Options::     Influencing runtime behavior\n * Code Gen Options::    Specifying conventions for function calls, data layout\n                         and register usage.\n+* Interoperability Options::  Options for interoperability with other\n+                              languages.\n * Environment Variables:: Environment variables that affect @command{gfortran}.\n @end menu\n \n@@ -171,6 +173,10 @@ and warnings}.\n -frecord-marker=@var{length} -fsign-zero\n }\n \n+@item Interoperability Options\n+@xref{Interoperability Options,,Options for interoperability}.\n+@gccoptlist{-fc-prototypes}\n+\n @item Code Generation Options\n @xref{Code Gen Options,,Options for code generation conventions}.\n @gccoptlist{-faggressive-function-elimination -fblas-matmul-limit=@var{n} @gol\n@@ -1746,6 +1752,34 @@ shared by @command{gfortran}, @command{gcc}, and other GNU compilers.\n \n @c man end\n \n+@node Interoperability Options\n+@section Options for interoperability with other languages\n+\n+@table @asis\n+\n+@item -fc-prototypes\n+@opindex @code{c-prototypes}\n+@cindex Generating C prototypes from Fortran source code\n+This option will generate C prototypes from @code{BIND(C)} variable\n+declarations, types and procedure interfaces and writes them to\n+standard output.  @code{ENUM} is not yet supported.\n+\n+The generated prototypes may need inclusion of an appropriate header,\n+such as @code{<stdint.h>} or @code{<stdlib.h>}.  For types which are\n+not specified using the appropriate kind from the @code{iso_c_binding}\n+module, a warning is added as a comment to the code.\n+\n+For function pointers, a pointer to a function returning @code{int}\n+without an explicit argument list is generated.\n+\n+Example of use:\n+@smallexample\n+$ gfortran -fc-prototypes -fsyntax-only foo.f90 > foo.h\n+@end smallexample\n+where the C code intended for interoperating with the Fortran code\n+then  uses @code{#include \"foo.h\"}.\n+@end table\n+\n @node Environment Variables\n @section Environment variables affecting @command{gfortran}\n @cindex environment variable"}, {"sha": "94185da103e9af6270ac0ade2159f2bd524daed4", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e655a6cc43e880b291b726394c1c6be6db461e89/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e655a6cc43e880b291b726394c1c6be6db461e89/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=e655a6cc43e880b291b726394c1c6be6db461e89", "patch": "@@ -416,6 +416,10 @@ fcray-pointer\n Fortran Var(flag_cray_pointer)\n Use the Cray Pointer extension.\n \n+fc-prototypes\n+Fortran Var(flag_c_prototypes)\n+Generate C prototypes from BIND(C) declarations.\n+\n fd-lines-as-code\n Fortran RejectNegative\n Ignore 'D' in column one in fixed form."}, {"sha": "9ac50f002dde27b45d47d2618924490f323e470a", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e655a6cc43e880b291b726394c1c6be6db461e89/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e655a6cc43e880b291b726394c1c6be6db461e89/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=e655a6cc43e880b291b726394c1c6be6db461e89", "patch": "@@ -6218,6 +6218,9 @@ gfc_parse_file (void)\n   if (flag_dump_fortran_original)\n     gfc_dump_parse_tree (gfc_current_ns, stdout);\n \n+  if (flag_c_prototypes)\n+    gfc_dump_c_prototypes (gfc_current_ns, stdout);\n+\n   gfc_get_errors (NULL, &errors);\n   if (s.state == COMP_MODULE || s.state == COMP_SUBMODULE)\n     {"}]}