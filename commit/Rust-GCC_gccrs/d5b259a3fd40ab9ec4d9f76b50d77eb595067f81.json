{"sha": "d5b259a3fd40ab9ec4d9f76b50d77eb595067f81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDViMjU5YTNmZDQwYWI5ZWM0ZDlmNzZiNTBkNzdlYjU5NTA2N2Y4MQ==", "commit": {"author": {"name": "CohenArthur", "email": "arthur.cohen@epita.fr", "date": "2021-09-10T08:40:11Z"}, "committer": {"name": "CohenArthur", "email": "arthur.cohen@epita.fr", "date": "2021-09-10T08:53:16Z"}, "message": "modules: Fix usage of path attributes and early returns\n\npath attributes were used wrongly in two ways:\n1/ The attribute's value would still contain extra data such as an equal\nsign and whitespaces, which need to be discarded in order to fetch the\nproper file path.\n2/ #[path]s are relative to the directory where the current source file\nis located. So we actually need to compute them later on down the line,\nonce the including directory has been figured out.\n\nAnother issue was that in the case that no candidates were found, or too\nmany were founds, the function `process_file_path` would still return\n\"successfully\" despite erroring out. This causes the function to return\nearly and thus not assign any string to the `module_file` member.\n\nWe also have the ability to emit an error for the module's location,\nwhich looks better for the user, instead of using a new `Location()`\nlike the session manager does (because it can't do otherwise)", "tree": {"sha": "cae07ec30aefc20d4b6fd3c4cb512a53ee624629", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cae07ec30aefc20d4b6fd3c4cb512a53ee624629"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5b259a3fd40ab9ec4d9f76b50d77eb595067f81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5b259a3fd40ab9ec4d9f76b50d77eb595067f81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5b259a3fd40ab9ec4d9f76b50d77eb595067f81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5b259a3fd40ab9ec4d9f76b50d77eb595067f81/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e93393d007276a3335839741f45865bc05787869", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e93393d007276a3335839741f45865bc05787869", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e93393d007276a3335839741f45865bc05787869"}], "stats": {"total": 47, "additions": 34, "deletions": 13}, "files": [{"sha": "b1572e1c2e572b91ddda7f1d0907ed9087951dd7", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b259a3fd40ab9ec4d9f76b50d77eb595067f81/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b259a3fd40ab9ec4d9f76b50d77eb595067f81/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=d5b259a3fd40ab9ec4d9f76b50d77eb595067f81", "patch": "@@ -4010,7 +4010,15 @@ filename_from_path_attribute (std::vector<Attribute> &outer_attrs)\n       return \"\";\n     }\n \n-  auto path = path_attr.get_attr_input ().as_string ();\n+  auto path_value = path_attr.get_attr_input ().as_string ();\n+\n+  // At this point, the 'path' is of the following format: '= \"<file.rs>\"'\n+  // We need to remove the equal sign and only keep the actual filename.\n+  // In order to do this, we can simply go through the string until we find\n+  // a character that is not an equal sign or whitespace\n+  auto filename_begin = path_value.find_first_not_of (\"=\\t \");\n+\n+  auto path = path_value.substr (filename_begin);\n \n   // On windows, the path might mix '/' and '\\' separators. Replace the\n   // UNIX-like separators by MSDOS separators to make sure the path will resolve\n@@ -4022,7 +4030,7 @@ filename_from_path_attribute (std::vector<Attribute> &outer_attrs)\n   path.replace ('/', '\\\\');\n #endif /* HAVE_DOS_BASED_FILE_SYSTEM */\n \n-  return path_attr.get_attr_input ().as_string ();\n+  return path;\n }\n \n void\n@@ -4031,10 +4039,6 @@ Module::process_file_path ()\n   rust_assert (kind == Module::ModuleKind::UNLOADED);\n   rust_assert (module_file.empty ());\n \n-  auto path_string = filename_from_path_attribute (get_outer_attrs ());\n-  if (!path_string.empty ())\n-    return;\n-\n   // This corresponds to the path of the file 'including' the module. So the\n   // file that contains the 'mod <file>;' directive\n   std::string including_fname (outer_filename);\n@@ -4053,6 +4057,13 @@ Module::process_file_path ()\n     current_directory_name\n       = including_fname.substr (0, dir_slash_pos) + file_separator;\n \n+  auto path_string = filename_from_path_attribute (get_outer_attrs ());\n+  if (!path_string.empty ())\n+    {\n+      module_file = current_directory_name + path_string;\n+      return;\n+    }\n+\n   // FIXME: We also have to search for\n   // <directory>/<including_fname>/<module_name>.rs In rustc, this is done via\n   // the concept of `DirOwnernship`, which is based on whether or not the\n@@ -4079,6 +4090,9 @@ Module::process_file_path ()\n     rust_error_at (locus, \"no candidate found for module %s\",\n \t\t   module_name.c_str ());\n \n+  if (no_candidates_found || multiple_candidates_found)\n+    return;\n+\n   module_file = file_mod_found ? expected_file_path\n \t\t\t       : current_directory_name + expected_dir_path;\n }\n@@ -4098,7 +4112,7 @@ Module::load_items ()\n \n   if (file_wrap.get_raw () == nullptr)\n     {\n-      rust_error_at (Location (), \"cannot open module file %s: %m\",\n+      rust_error_at (get_locus (), \"cannot open module file %s: %m\",\n \t\t     module_file.c_str ());\n       return;\n     }"}, {"sha": "4984d5dc2c14b063ffe9e99ae966b7328a946a25", "filename": "gcc/testsuite/rust/compile/torture/extern_mod2.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b259a3fd40ab9ec4d9f76b50d77eb595067f81/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fextern_mod2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b259a3fd40ab9ec4d9f76b50d77eb595067f81/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fextern_mod2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fextern_mod2.rs?ref=d5b259a3fd40ab9ec4d9f76b50d77eb595067f81", "patch": "@@ -3,14 +3,21 @@\n #[path = \"modules/valid_path.rs\"]\n mod not_a_valid_path;\n \n-// #[path]\n-// FIXME: This is wrong\n-// mod error; \n+#[path =\"modules/valid_path.rs\"]\n+mod path_without_extra_equal;\n+\n+#[path= \"modules/valid_path.rs\"]\n+mod no_leading_equal;\n+\n+#[path       =     \"modules/valid_path.rs\"]\n+mod extra_spaces;\n+\n+#[path] // { dg-error \"path attributes must contain a filename\" }\n+mod error; // { dg-error \"no candidate found\" }\n \n // This is \"valid\", and should only error out when parsing\n // the file\n-// FIXME: Fix path attribute expanding\n-// #[path = \"not_a_valid_file.rs\"]\n-// mod another_error;\n+#[path = \"not_a_valid_file.rs\"]\n+mod another_error; // { dg-error \"No such file or directory\" }\n \n fn main() {}"}]}