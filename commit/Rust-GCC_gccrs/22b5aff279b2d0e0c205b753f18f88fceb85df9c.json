{"sha": "22b5aff279b2d0e0c205b753f18f88fceb85df9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJiNWFmZjI3OWIyZDBlMGMyMDViNzUzZjE4Zjg4ZmNlYjg1ZGY5Yw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-04-13T07:16:18Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-17T08:14:05Z"}, "message": "[Ada] Deal with second specific superflat case in Optimize_Length_Comparison\n\n2020-06-17  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch4.adb (Optimize_Length_Comparison): New local variable to\n\trecord whether this may be a dynamic superflat case.\n\t(Is_Optimizable): Accept 0 as lower bound and set it in this case,\n\tbut return false if the operand is not a length too.\n\t(Rewrite_For_Equal_Lengths): New procedure.\n\tOptimize the comparison of two lengths in the superflat case when\n\tthe arrays have the same bounds.", "tree": {"sha": "595ab11e6634e6fad3b8a4bbe94d43ebceeffcac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/595ab11e6634e6fad3b8a4bbe94d43ebceeffcac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22b5aff279b2d0e0c205b753f18f88fceb85df9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22b5aff279b2d0e0c205b753f18f88fceb85df9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22b5aff279b2d0e0c205b753f18f88fceb85df9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22b5aff279b2d0e0c205b753f18f88fceb85df9c/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "741826eff5855366c65d49123b899ea40fc0c443", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/741826eff5855366c65d49123b899ea40fc0c443", "html_url": "https://github.com/Rust-GCC/gccrs/commit/741826eff5855366c65d49123b899ea40fc0c443"}], "stats": {"total": 96, "additions": 82, "deletions": 14}, "files": [{"sha": "8d427fed4ba5fcc2bdb76d884f767161ebc8b721", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 82, "deletions": 14, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b5aff279b2d0e0c205b753f18f88fceb85df9c/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b5aff279b2d0e0c205b753f18f88fceb85df9c/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=22b5aff279b2d0e0c205b753f18f88fceb85df9c", "patch": "@@ -227,7 +227,7 @@ package body Exp_Ch4 is\n    procedure Optimize_Length_Comparison (N : Node_Id);\n    --  Given an expression, if it is of the form X'Length op N (or the other\n    --  way round), where N is known at compile time to be 0 or 1, or something\n-   --  else where the value is known to be positive and in the 32-bit range,\n+   --  else where the value is known to be nonnegative and in the 32-bit range,\n    --  and X is a simple entity, and op is a comparison operator, optimizes it\n    --  into a comparison of X'First and X'Last.\n \n@@ -13781,6 +13781,14 @@ package body Exp_Ch4 is\n       Is_Zero : Boolean;\n       --  True for comparison operand of zero\n \n+      Maybe_Superflat : Boolean;\n+      --  True if we may be in the dynamic superflat case, i.e. Is_Zero is set\n+      --  to false but the comparison operand can be zero at run time. In this\n+      --  case, we normally cannot do anything because the canonical formula of\n+      --  the length is not valid, but there is one exception: when the operand\n+      --  is itself the length of an array with the same bounds as the array on\n+      --  the LHS, we can entirely optimize away the comparison.\n+\n       Comp : Node_Id;\n       --  Comparison operand, set only if Is_Zero is false\n \n@@ -13800,13 +13808,6 @@ package body Exp_Ch4 is\n       --  This is done with an unchecked conversion to Long_Long_Integer.\n       --  We use unchecked conversion to handle the enumeration type case.\n \n-      function Is_Optimizable (N : Node_Id) return Boolean;\n-      --  Tests N to see if it is an optimizable comparison value (defined as\n-      --  constant zero or one, or something else where the value is known to\n-      --  be positive and in the range of 32 bits and where the corresponding\n-      --  Length value is also known to be 32 bits). If result is true, sets\n-      --  Is_Zero and Comp accordingly.\n-\n       function Is_Entity_Length (N : Node_Id; Num : Pos) return Boolean;\n       --  Tests if N is a length attribute applied to a simple entity. If so,\n       --  returns True, and sets Ent to the entity, and Index to the integer\n@@ -13818,6 +13819,16 @@ package body Exp_Ch4 is\n       --  to check for being in range, which is not needed in this context.\n       --  Returns False if neither condition holds.\n \n+      function Is_Optimizable (N : Node_Id) return Boolean;\n+      --  Tests N to see if it is an optimizable comparison value (defined as\n+      --  constant zero or one, or something else where the value is known to\n+      --  be nonnegative and in the 32-bit range and where the corresponding\n+      --  Length value is also known to be 32 bits). If result is true, sets\n+      --  Is_Zero, Maybe_Superflat and Comp accordingly.\n+\n+      procedure Rewrite_For_Equal_Lengths;\n+      --  Rewrite the comparison of two equal lengths into either True or False\n+\n       ----------------------------------\n       -- Convert_To_Long_Long_Integer --\n       ----------------------------------\n@@ -13875,13 +13886,15 @@ package body Exp_Ch4 is\n             Val := Expr_Value (N);\n \n             if Val = Uint_0 then\n-               Is_Zero := True;\n-               Comp    := Empty;\n+               Is_Zero         := True;\n+               Maybe_Superflat := False;\n+               Comp            := Empty;\n                return True;\n \n             elsif Val = Uint_1 then\n-               Is_Zero := False;\n-               Comp    := Empty;\n+               Is_Zero         := False;\n+               Maybe_Superflat := False;\n+               Comp            := Empty;\n                return True;\n             end if;\n          end if;\n@@ -13891,16 +13904,24 @@ package body Exp_Ch4 is\n          Determine_Range (N, OK, Lo, Hi, Assume_Valid => True);\n \n          if not OK\n-           or else Lo < Uint_1\n+           or else Lo < Uint_0\n            or else Hi > UI_From_Int (Int'Last)\n          then\n             return False;\n          end if;\n \n+         Maybe_Superflat := (Lo = Uint_0);\n+\n          --  Tests if N is also a length attribute applied to a simple entity\n \n          Dbl := Is_Entity_Length (N, 2);\n \n+         --  We can deal with the superflat case only if N is also a length\n+\n+         if Maybe_Superflat and then not Dbl then\n+            return False;\n+         end if;\n+\n          --  Comparison value was within range, so now we must check the index\n          --  value to make sure it is also within 32 bits.\n \n@@ -13927,6 +13948,36 @@ package body Exp_Ch4 is\n          return True;\n       end Is_Optimizable;\n \n+      -------------------------------\n+      -- Rewrite_For_Equal_Lengths --\n+      -------------------------------\n+\n+      procedure Rewrite_For_Equal_Lengths is\n+      begin\n+         case Op is\n+            when N_Op_Eq\n+               | N_Op_Ge\n+               | N_Op_Le\n+            =>\n+               Rewrite (N,\n+                 Convert_To (Typ,\n+                    New_Occurrence_Of (Standard_True, Sloc (N))));\n+\n+            when N_Op_Ne\n+               | N_Op_Gt\n+               | N_Op_Lt\n+            =>\n+               Rewrite (N,\n+                 Convert_To (Typ,\n+                    New_Occurrence_Of (Standard_False, Sloc (N))));\n+\n+            when others =>\n+               raise Program_Error;\n+         end case;\n+\n+         Analyze_And_Resolve (N, Typ);\n+      end Rewrite_For_Equal_Lengths;\n+\n    --  Start of processing for Optimize_Length_Comparison\n \n    begin\n@@ -14103,6 +14154,16 @@ package body Exp_Ch4 is\n                   Analyze (Right);\n                   Analyze (Y_Last);\n \n+                  R := Compile_Time_Compare\n+                                         (Right, Y_Last, Assume_Valid => True);\n+\n+                  --  If the pairs of attributes are equal, we are done\n+\n+                  if R = EQ then\n+                     Rewrite_For_Equal_Lengths;\n+                     return;\n+                  end if;\n+\n                   --  If the base types are different, convert both operands to\n                   --  Long_Long_Integer, else compare them directly.\n \n@@ -14119,7 +14180,8 @@ package body Exp_Ch4 is\n                else\n                   Left :=\n                     Make_Op_Add (Loc,\n-                      Left_Opnd  => Convert_To_Long_Long_Integer (Y_Last),\n+                      Left_Opnd  =>\n+                        Convert_To_Long_Long_Integer (Y_Last),\n                       Right_Opnd =>\n                         Make_Op_Subtract (Loc,\n                           Left_Opnd  =>\n@@ -14142,6 +14204,12 @@ package body Exp_Ch4 is\n          end if;\n       end if;\n \n+      --  We cannot do anything in the superflat case past this point\n+\n+      if Maybe_Superflat then\n+         return;\n+      end if;\n+\n       --  If general operand, convert Last reference to Long_Long_Integer\n \n       if Present (Comp) then"}]}