{"sha": "62dafdeb1b1eb06c1168ac379245c79743a7c030", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJkYWZkZWIxYjFlYjA2YzExNjhhYzM3OTI0NWM3OTc0M2E3YzAzMA==", "commit": {"author": {"name": "Mumit Khan", "email": "khan@xraylith.wisc.edu", "date": "1999-09-14T10:13:49Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-09-14T10:13:49Z"}, "message": "* gthr-win32.h: New file.\n\nFrom-SVN: r29405", "tree": {"sha": "87040a2058c588e3f8b5d3b6d76031246885026a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87040a2058c588e3f8b5d3b6d76031246885026a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62dafdeb1b1eb06c1168ac379245c79743a7c030", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62dafdeb1b1eb06c1168ac379245c79743a7c030", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62dafdeb1b1eb06c1168ac379245c79743a7c030", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62dafdeb1b1eb06c1168ac379245c79743a7c030/comments", "author": null, "committer": null, "parents": [{"sha": "593d3a34f82af7473a00711fdb1dc6af780888b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/593d3a34f82af7473a00711fdb1dc6af780888b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/593d3a34f82af7473a00711fdb1dc6af780888b5"}], "stats": {"total": 197, "additions": 197, "deletions": 0}, "files": [{"sha": "43c1c59e54b859ca7d5280aa2e7e4c20044a5788", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62dafdeb1b1eb06c1168ac379245c79743a7c030/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62dafdeb1b1eb06c1168ac379245c79743a7c030/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62dafdeb1b1eb06c1168ac379245c79743a7c030", "patch": "@@ -1,5 +1,7 @@\n Tue Sep 14 04:03:44 1999  Mumit Khan  <khan@xraylith.wisc.edu>\n \n+\t* gthr-win32.h: New file.\n+\n \t* i386/winnt.c (i386_pe_valid_decl_attribute_p): Recognize\n \tshared as a valid attribute.\n \t* i386/cygwin.h (ASM_OUTPUT_SECTION): Handle shared attribute."}, {"sha": "b9402202722cd11fd70226469ebf7bcb96c587ec", "filename": "gcc/gthr-win32.h", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62dafdeb1b1eb06c1168ac379245c79743a7c030/gcc%2Fgthr-win32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62dafdeb1b1eb06c1168ac379245c79743a7c030/gcc%2Fgthr-win32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-win32.h?ref=62dafdeb1b1eb06c1168ac379245c79743a7c030", "patch": "@@ -0,0 +1,195 @@\n+/* Threads compatibily routines for libgcc2.  */\n+/* Compile this one with gcc.  */\n+/* Copyright (C) 1999 Free Software Foundation, Inc.\n+   Contributed by Mumit Khan <khan@xraylith.wisc.edu>.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with other files,\n+   some of which are compiled with GCC, to produce an executable,\n+   this library does not by itself cause the resulting executable\n+   to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#ifndef __gthr_win32_h\n+#define __gthr_win32_h\n+\n+/* Windows32 threads specific definitions. The windows32 threading model\n+   does not map well into pthread-inspired gcc's threading model, and so \n+   there are caveats one needs to be aware of.\n+\n+   1. The destructor supplied to __gthread_key_create is ignored. This\n+      will certainly cause memory leaks due to unreclaimed eh contexts\n+      (sizeof (eh_context) is at least 24 bytes for x86 currently).\n+\n+      This memory leak may be significant for long-running applications\n+      that make heavy use of C++ EH.\n+\n+   2. The error codes returned are non-POSIX like, and cast into ints.\n+      This may cause incorrect error return due to truncation values on \n+      hw where sizeof (DWORD) > sizeof (int).\n+  \n+   The basic framework should work well enough. */\n+\n+#define __GTHREADS 1\n+\n+#include <windows.h>\n+#include <errno.h>\n+\n+typedef DWORD __gthread_key_t;\n+\n+typedef struct {\n+  int done;\n+  long started;\n+} __gthread_once_t;\n+\n+typedef HANDLE __gthread_mutex_t;\n+\n+#define __GTHREAD_ONCE_INIT {FALSE, -1}\n+#define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function\n+\n+static inline int\n+__gthread_active_p ()\n+{\n+  return 1;\n+}\n+\n+static inline int\n+__gthread_once (__gthread_once_t *once, void (*func) ())\n+{\n+  if (! __gthread_active_p ())\n+    return -1;\n+  else if (once == NULL || func == NULL)\n+    return EINVAL;\n+\n+  if (! once->done)\n+    {\n+      if (InterlockedIncrement (&(once->started)) == 0)\n+        {\n+\t  (*func) ();\n+\t  once->done = TRUE;\n+\t}\n+    }\n+  else\n+    {\n+      /* Another thread is currently executing the code, so wait for it to\n+         finish; yield the CPU in the meantime.  */ \n+      while (! once->done)\n+        Sleep (0);\n+    }\n+  \n+  return 0;\n+}\n+\n+/* Windows32 thread local keys don't support destructors; to avoid leaks,\n+   we will have to figure something out in the future.  */\n+static inline int\n+__gthread_key_create (__gthread_key_t *key, \n+                      void (*dtor) (void *) __attribute__((__unused__)))\n+{\n+  int status = 0;\n+  DWORD tls_index = TlsAlloc ();\n+  if (tls_index != 0xFFFFFFFF)\n+    *key = tls_index;\n+  else\n+    status = (int) GetLastError ();\n+  return status;\n+}\n+\n+/* Currently, this routine is never called since win32 keys don't support\n+   destructors. Hopefully we'll find a way in the future.  */\n+static inline int\n+__gthread_key_dtor (__gthread_key_t key, void *ptr)\n+{\n+  int status = 0;\n+\n+  /* Just reset the key value to zero. */\n+  if (ptr)\n+    status = (TlsSetValue (key, 0) != 0) ? 0 : (int) GetLastError ();\n+  return status;\n+}\n+\n+/* Currently, this routine is never called since win32 keys don't support\n+   destructors. Hopefully we'll find a way in the future.  */\n+static inline int\n+__gthread_key_delete (__gthread_key_t key)\n+{\n+  return (TlsFree (key) != 0) ? 0 : (int) GetLastError ();\n+}\n+\n+static inline void *\n+__gthread_getspecific (__gthread_key_t key)\n+{\n+  return TlsGetValue (key);\n+}\n+\n+static inline int\n+__gthread_setspecific (__gthread_key_t key, const void *ptr)\n+{\n+  return (TlsSetValue (key, ptr) != 0) ? 0 : (int) GetLastError ();\n+}\n+\n+static inline void\n+__gthread_mutex_init_function (__gthread_mutex_t *mutex)\n+{\n+  /* Create unnamed mutex with default security attr and no initial owner.  */ \n+  *mutex = CreateMutex (NULL, 0, NULL);\n+}\n+\n+static inline int\n+__gthread_mutex_lock (__gthread_mutex_t *mutex)\n+{\n+  int status = 0;\n+\n+  if (__gthread_active_p ())\n+    {\n+      if (WaitForSingleObject (*mutex, INFINITE) == WAIT_OBJECT_0)\n+\tstatus = 0;\n+      else\n+\tstatus = 1;\n+    }\n+  return status;\n+}\n+\n+static inline int\n+__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n+{\n+  int status = 0;\n+\n+  if (__gthread_active_p ())\n+    {\n+      if (WaitForSingleObject (*mutex, 0) == WAIT_OBJECT_0)\n+\tstatus = 0;\n+      else\n+\tstatus = 1;\n+    }\n+  return status;\n+}\n+\n+static inline int\n+__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n+{\n+  if (__gthread_active_p ())\n+    return (ReleaseMutex (*mutex) != 0) ? 0 : 1;\n+  else\n+    return 0;\n+}\n+\n+#endif /* not __gthr_win32_h */\n+"}]}