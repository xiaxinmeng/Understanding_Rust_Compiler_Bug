{"sha": "d6b15134378bfba88effc523f4eb2c20a9486a63", "node_id": "C_kwDOANBUbNoAKGQ2YjE1MTM0Mzc4YmZiYTg4ZWZmYzUyM2Y0ZWIyYzIwYTk0ODZhNjM", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-08-01T21:10:40Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-09-06T07:14:20Z"}, "message": "[Ada] Correctly round Value attribute for floating point in more cases\n\nThis provides correct rounding in the IEEE 754 sense for the Value attribute\nof floating-point types in more cases, by bumping the number of significant\nbits used in the initial integer mantissa obtained from parsing.\n\ngcc/ada/\n\n\t* libgnat/s-valuer.ads (System.Value_R): Add Parts formal parameter\n\tas well as Data_Index, Scale_Array and Value_Array types.\n\t(Scan_Raw_Real): Change type of Scale and return type.\n\t(Value_Raw_Real): Likewise.\n\t* libgnat/s-valuer.adb (Round_Extra): Reorder parameters and adjust\n\trecursive call.\n\t(Scan_Decimal_Digits): Reorder parameters, add N parameter and deal\n\twith multi-part scale and value.\n\t(Scan_Integral_Digits): Likewise.\n\t(Scan_Raw_Real): Change type of Scale and return type and deal with\n\tmulti-part scale and value.\n\t(Value_Raw_Real): Change type of Scale and return type and tidy up.\n\t* libgnat/s-valued.adb (Impl): Pass 1 as Parts actual parameter.\n\t(Scan_Decimal): Adjust to type changes.\n\t(Value_Decimal): Likewise.\n\t* libgnat/s-valuef.adb (Impl): Pass 1 as Parts actual parameter.\n\t(Scan_Fixed): Adjust to type changes.\n\t(Value_Fixed): Likewise.\n\t* libgnat/s-valrea.adb (Need_Extra): Delete.\n\t(Precision_Limit): Always use the precision of the mantissa.\n\t(Impl): Pass 2 as Parts actual parameter.\n\t(Exact_Log2): New expression function.\n\t(Integer_to_Real): Change type of Scale and Val and deal with a\n\t2-part integer mantissa.\n\t(Scan_Real): Adjust to type changes.\n\t(Value_Real): Likewise.", "tree": {"sha": "777dc6fe70eea0b4aa247b4ea8205e95e7666d07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/777dc6fe70eea0b4aa247b4ea8205e95e7666d07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6b15134378bfba88effc523f4eb2c20a9486a63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6b15134378bfba88effc523f4eb2c20a9486a63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6b15134378bfba88effc523f4eb2c20a9486a63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6b15134378bfba88effc523f4eb2c20a9486a63/comments", "author": null, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33b182f61280d991bd0bda33003b5ee2a16024e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33b182f61280d991bd0bda33003b5ee2a16024e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33b182f61280d991bd0bda33003b5ee2a16024e2"}], "stats": {"total": 471, "additions": 253, "deletions": 218}, "files": [{"sha": "b712ba6827a1cc59f8b4a5435b8079cbc7d58616", "filename": "gcc/ada/libgnat/s-valrea.adb", "status": "modified", "additions": 84, "deletions": 102, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b15134378bfba88effc523f4eb2c20a9486a63/gcc%2Fada%2Flibgnat%2Fs-valrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b15134378bfba88effc523f4eb2c20a9486a63/gcc%2Fada%2Flibgnat%2Fs-valrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valrea.adb?ref=d6b15134378bfba88effc523f4eb2c20a9486a63", "patch": "@@ -43,18 +43,9 @@ package body System.Val_Real is\n    pragma Assert (Num'Machine_Mantissa <= Uns'Size);\n    --  We need an unsigned type large enough to represent the mantissa\n \n-   Need_Extra : constant Boolean := Num'Machine_Mantissa > Uns'Size - 4;\n-   --  If the mantissa of the floating-point type is almost as large as the\n-   --  unsigned type, we do not have enough space for an extra digit in the\n-   --  unsigned type so we handle the extra digit separately, at the cost of\n-   --  a bit more work in Integer_to_Real.\n+   Precision_Limit : constant Uns := 2**Num'Machine_Mantissa - 1;\n \n-   Precision_Limit : constant Uns :=\n-     (if Need_Extra then 2**Num'Machine_Mantissa - 1 else 2**Uns'Size - 1);\n-   --  If we handle the extra digit separately, we use the precision of the\n-   --  floating-point type so that the conversion is exact.\n-\n-   package Impl is new Value_R (Uns, Precision_Limit, Round => Need_Extra);\n+   package Impl is new Value_R (Uns, 2, Precision_Limit, Round => False);\n \n    subtype Base_T is Unsigned range 2 .. 16;\n \n@@ -83,12 +74,20 @@ package body System.Val_Real is\n    subtype Double_T is Double_Real.Double_T;\n    --  The double floating-point type\n \n+   function Exact_Log2 (N : Unsigned) return Positive is\n+     (case N is\n+        when  2     => 1,\n+        when  4     => 2,\n+        when  8     => 3,\n+        when 16     => 4,\n+        when others => raise Program_Error);\n+   --  Return the exponent of a power of 2\n+\n    function Integer_to_Real\n      (Str   : String;\n-      Val   : Uns;\n+      Val   : Impl.Value_Array;\n       Base  : Unsigned;\n-      Scale : Integer;\n-      Extra : Unsigned;\n+      Scale : Impl.Scale_Array;\n       Minus : Boolean) return Num;\n    --  Convert the real value from integer to real representation\n \n@@ -101,10 +100,9 @@ package body System.Val_Real is\n \n    function Integer_to_Real\n      (Str   : String;\n-      Val   : Uns;\n+      Val   : Impl.Value_Array;\n       Base  : Unsigned;\n-      Scale : Integer;\n-      Extra : Unsigned;\n+      Scale : Impl.Scale_Array;\n       Minus : Boolean) return Num\n    is\n       pragma Assert (Base in 2 .. 16);\n@@ -120,9 +118,9 @@ package body System.Val_Real is\n                   else  raise Program_Error);\n       --  Maximum exponent of the base that can fit in Num\n \n-      R_Val : Num;\n       D_Val : Double_T;\n-      S     : Integer := Scale;\n+      R_Val : Num;\n+      S     : Integer;\n \n    begin\n       --  We call the floating-point processor reset routine so we can be sure\n@@ -134,82 +132,78 @@ package body System.Val_Real is\n          System.Float_Control.Reset;\n       end if;\n \n-      --  Take into account the extra digit, i.e. do the two computations\n-\n-      --    (1)  R_Val := R_Val * Num (B) + Num (Extra)\n-      --    (2)  S := S - 1\n+      --  First convert the integer mantissa into a double real. The conversion\n+      --  of each part is exact, given the precision limit we used above. Then,\n+      --  if the contribution of the low part might be nonnull, scale the high\n+      --  part appropriately and add the low part to the result.\n \n-      --  In the first, the three operands are exact, so using an FMA would\n-      --  be ideal, but we are most likely running on the x87 FPU, hence we\n-      --  may not have one. That is why we turn the multiplication into an\n-      --  iterated addition with exact error handling, so that we can do a\n-      --  single rounding at the end.\n+      if Val (2) = 0 then\n+         D_Val := Double_Real.To_Double (Num (Val (1)));\n+         S := Scale (1);\n \n-      if Need_Extra and then Extra > 0 then\n+      else\n          declare\n-            B   : Unsigned := Base;\n-            Acc : Num      := 0.0;\n-            Err : Num      := 0.0;\n-            Fac : Num      := Num (Val);\n-            DS  : Double_T;\n+            V1 : constant Num := Num (Val (1));\n+            V2 : constant Num := Num (Val (2));\n+\n+            DS : Positive;\n \n          begin\n-            loop\n-               --  If B is odd, add one factor. Note that the accumulator is\n-               --  never larger than the factor at this point (it is in fact\n-               --  never larger than the factor minus the initial value).\n-\n-               if B rem 2 /= 0 then\n-                  if Acc = 0.0 then\n-                     Acc := Fac;\n-                  else\n-                     DS  := Double_Real.Quick_Two_Sum (Fac, Acc);\n-                     Acc := DS.Hi;\n-                     Err := Err + DS.Lo;\n-                  end if;\n-                  exit when B = 1;\n-               end if;\n+            DS := Scale (1) - Scale (2);\n \n-               --  Now B is (morally) even, halve it and double the factor,\n-               --  which is always an exact operation.\n+            case Base is\n+               --  If the base is a power of two, we use the efficient Scaling\n+               --  attribute up to an amount worth a double mantissa.\n \n-               B := B / 2;\n-               Fac := Fac * 2.0;\n-            end loop;\n+               when 2 | 4 | 8 | 16 =>\n+                  declare\n+                     L : constant Positive := Exact_Log2 (Base);\n \n-            --  Add Extra to the error, which are both small integers\n+                  begin\n+                     if DS <= 2 * Num'Machine_Mantissa / L then\n+                        DS := DS * L;\n+                        D_Val :=\n+                          Double_Real.Quick_Two_Sum (Num'Scaling (V1, DS), V2);\n+                        S := Scale (2);\n \n-            D_Val := Double_Real.Quick_Two_Sum (Acc, Err + Num (Extra));\n+                     else\n+                        D_Val := Double_Real.To_Double (V1);\n+                        S := Scale (1);\n+                     end if;\n+                  end;\n \n-            S := S - 1;\n-         end;\n+               --  If the base is 10, we also scale up to an amount worth a\n+               --  double mantissa.\n \n-      --  Or else, if the Extra digit is zero, do the exact conversion\n+               when 10 =>\n+                  declare\n+                     Powten : constant array (0 .. Maxpow) of Double_T;\n+                     pragma Import (Ada, Powten);\n+                     for Powten'Address use Powten_Address;\n \n-      elsif Need_Extra then\n-         D_Val := Double_Real.To_Double (Num (Val));\n+                  begin\n+                     if DS <= Maxpow then\n+                        D_Val := Powten (DS) * V1 + V2;\n+                        S := Scale (2);\n \n-      --  Otherwise, the value contains more bits than the mantissa so do the\n-      --  conversion in two steps.\n+                     else\n+                        D_Val := Double_Real.To_Double (V1);\n+                        S := Scale (1);\n+                     end if;\n+                  end;\n \n-      else\n-         declare\n-            Mask : constant Uns := 2**(Uns'Size - Num'Machine_Mantissa) - 1;\n-            Hi   : constant Uns := Val and not Mask;\n-            Lo   : constant Uns := Val and Mask;\n+               --  Inaccurate implementation for other bases\n \n-         begin\n-            if Hi = 0 then\n-               D_Val := Double_Real.To_Double (Num (Lo));\n-            else\n-               D_Val := Double_Real.Quick_Two_Sum (Num (Hi), Num (Lo));\n-            end if;\n+               when others =>\n+                  D_Val := Double_Real.To_Double (V1);\n+                  S := Scale (1);\n+            end case;\n          end;\n       end if;\n \n       --  Compute the final value by applying the scaling, if any\n \n-      if Val = 0 or else S = 0 then\n+      if (Val (1) = 0 and then Val (2) = 0) or else S = 0 then\n          R_Val := Double_Real.To_Single (D_Val);\n \n       else\n@@ -218,29 +212,17 @@ package body System.Val_Real is\n             --  attribute with an overflow check, if it is not 2, to catch\n             --  ludicrous exponents that would result in an infinity or zero.\n \n-            when 2 =>\n-               R_Val := Num'Scaling (Double_Real.To_Single (D_Val), S);\n-\n-            when 4 =>\n-               if Integer'First / 2 <= S and then S <= Integer'Last / 2 then\n-                  S := S * 2;\n-               end if;\n-\n-               R_Val := Num'Scaling (Double_Real.To_Single (D_Val), S);\n-\n-            when 8 =>\n-               if Integer'First / 3 <= S and then S <= Integer'Last / 3 then\n-                  S := S * 3;\n-               end if;\n-\n-               R_Val := Num'Scaling (Double_Real.To_Single (D_Val), S);\n+            when 2 | 4 | 8 | 16 =>\n+               declare\n+                  L : constant Positive := Exact_Log2 (Base);\n \n-            when 16 =>\n-               if Integer'First / 4 <= S and then S <= Integer'Last / 4 then\n-                  S := S * 4;\n-               end if;\n+               begin\n+                  if Integer'First / L <= S and then S <= Integer'Last / L then\n+                     S := S * L;\n+                  end if;\n \n-               R_Val := Num'Scaling (Double_Real.To_Single (D_Val), S);\n+                  R_Val := Num'Scaling (Double_Real.To_Single (D_Val), S);\n+               end;\n \n             --  If the base is 10, use a double implementation for the sake\n             --  of accuracy, to be removed when exponentiation is improved.\n@@ -358,15 +340,15 @@ package body System.Val_Real is\n       Max : Integer) return Num\n    is\n       Base  : Unsigned;\n-      Scale : Integer;\n+      Scale : Impl.Scale_Array;\n       Extra : Unsigned;\n       Minus : Boolean;\n-      Val   : Uns;\n+      Val   : Impl.Value_Array;\n \n    begin\n       Val := Impl.Scan_Raw_Real (Str, Ptr, Max, Base, Scale, Extra, Minus);\n \n-      return Integer_to_Real (Str, Val, Base, Scale, Extra, Minus);\n+      return Integer_to_Real (Str, Val, Base, Scale, Minus);\n    end Scan_Real;\n \n    ----------------\n@@ -375,15 +357,15 @@ package body System.Val_Real is\n \n    function Value_Real (Str : String) return Num is\n       Base  : Unsigned;\n-      Scale : Integer;\n+      Scale : Impl.Scale_Array;\n       Extra : Unsigned;\n       Minus : Boolean;\n-      Val   : Uns;\n+      Val   : Impl.Value_Array;\n \n    begin\n       Val := Impl.Value_Raw_Real (Str, Base, Scale, Extra, Minus);\n \n-      return Integer_to_Real (Str, Val, Base, Scale, Extra, Minus);\n+      return Integer_to_Real (Str, Val, Base, Scale, Minus);\n    end Value_Real;\n \n end System.Val_Real;"}, {"sha": "92e9140443e29eb48dd72f666ea9de25a262b083", "filename": "gcc/ada/libgnat/s-valued.adb", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b15134378bfba88effc523f4eb2c20a9486a63/gcc%2Fada%2Flibgnat%2Fs-valued.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b15134378bfba88effc523f4eb2c20a9486a63/gcc%2Fada%2Flibgnat%2Fs-valued.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valued.adb?ref=d6b15134378bfba88effc523f4eb2c20a9486a63", "patch": "@@ -38,7 +38,7 @@ package body System.Value_D is\n    pragma Assert (Int'Size <= Uns'Size);\n    --  We need an unsigned type large enough to represent the mantissa\n \n-   package Impl is new Value_R (Uns, 2**(Int'Size - 1), Round => False);\n+   package Impl is new Value_R (Uns, 1, 2**(Int'Size - 1), Round => False);\n    --  We do not use the Extra digit for decimal fixed-point types\n \n    function Integer_to_Decimal\n@@ -229,33 +229,33 @@ package body System.Value_D is\n       Max   : Integer;\n       Scale : Integer) return Int\n    is\n-      Base   : Unsigned;\n-      ScaleB : Integer;\n-      Extra  : Unsigned;\n-      Minus  : Boolean;\n-      Val    : Uns;\n+      Base  : Unsigned;\n+      Scl   : Impl.Scale_Array;\n+      Extra : Unsigned;\n+      Minus : Boolean;\n+      Val   : Impl.Value_Array;\n \n    begin\n-      Val := Impl.Scan_Raw_Real (Str, Ptr, Max, Base, ScaleB, Extra, Minus);\n+      Val := Impl.Scan_Raw_Real (Str, Ptr, Max, Base, Scl, Extra, Minus);\n \n-      return Integer_to_Decimal (Str, Val, Base, ScaleB, Minus, Scale);\n+      return Integer_to_Decimal (Str, Val (1), Base, Scl (1), Minus, Scale);\n    end Scan_Decimal;\n \n    -------------------\n    -- Value_Decimal --\n    -------------------\n \n    function Value_Decimal (Str : String; Scale : Integer) return Int is\n-      Base   : Unsigned;\n-      ScaleB : Integer;\n-      Extra  : Unsigned;\n-      Minus  : Boolean;\n-      Val    : Uns;\n+      Base  : Unsigned;\n+      Scl   : Impl.Scale_Array;\n+      Extra : Unsigned;\n+      Minus : Boolean;\n+      Val   : Impl.Value_Array;\n \n    begin\n-      Val := Impl.Value_Raw_Real (Str, Base, ScaleB, Extra, Minus);\n+      Val := Impl.Value_Raw_Real (Str, Base, Scl, Extra, Minus);\n \n-      return Integer_to_Decimal (Str, Val, Base, ScaleB, Minus, Scale);\n+      return Integer_to_Decimal (Str, Val (1), Base, Scl (1), Minus, Scale);\n    end Value_Decimal;\n \n end System.Value_D;"}, {"sha": "1b9d18ef7083cdf941e98e84a3f97219f60c2bd5", "filename": "gcc/ada/libgnat/s-valuef.adb", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b15134378bfba88effc523f4eb2c20a9486a63/gcc%2Fada%2Flibgnat%2Fs-valuef.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b15134378bfba88effc523f4eb2c20a9486a63/gcc%2Fada%2Flibgnat%2Fs-valuef.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuef.adb?ref=d6b15134378bfba88effc523f4eb2c20a9486a63", "patch": "@@ -46,7 +46,7 @@ package body System.Value_F is\n    pragma Assert (Int'Size <= Uns'Size);\n    --  We need an unsigned type large enough to represent the mantissa\n \n-   package Impl is new Value_R (Uns, 2**(Int'Size - 1), Round => True);\n+   package Impl is new Value_R (Uns, 1, 2**(Int'Size - 1), Round => True);\n    --  We use the Extra digit for ordinary fixed-point types\n \n    function Integer_To_Fixed\n@@ -332,16 +332,17 @@ package body System.Value_F is\n       Num : Int;\n       Den : Int) return Int\n    is\n-      Base   : Unsigned;\n-      ScaleB : Integer;\n-      Extra  : Unsigned;\n-      Minus  : Boolean;\n-      Val    : Uns;\n+      Base  : Unsigned;\n+      Scl   : Impl.Scale_Array;\n+      Extra : Unsigned;\n+      Minus : Boolean;\n+      Val   : Impl.Value_Array;\n \n    begin\n-      Val := Impl.Scan_Raw_Real (Str, Ptr, Max, Base, ScaleB, Extra, Minus);\n+      Val := Impl.Scan_Raw_Real (Str, Ptr, Max, Base, Scl, Extra, Minus);\n \n-      return Integer_To_Fixed (Str, Val, Base, ScaleB, Extra, Minus, Num, Den);\n+      return\n+        Integer_To_Fixed (Str, Val (1), Base, Scl (1), Extra, Minus, Num, Den);\n    end Scan_Fixed;\n \n    -----------------\n@@ -353,16 +354,17 @@ package body System.Value_F is\n       Num : Int;\n       Den : Int) return Int\n    is\n-      Base   : Unsigned;\n-      ScaleB : Integer;\n-      Extra  : Unsigned;\n-      Minus  : Boolean;\n-      Val    : Uns;\n+      Base  : Unsigned;\n+      Scl   : Impl.Scale_Array;\n+      Extra : Unsigned;\n+      Minus : Boolean;\n+      Val   : Impl.Value_Array;\n \n    begin\n-      Val := Impl.Value_Raw_Real (Str, Base, ScaleB, Extra, Minus);\n+      Val := Impl.Value_Raw_Real (Str, Base, Scl, Extra, Minus);\n \n-      return Integer_To_Fixed (Str, Val, Base, ScaleB, Extra, Minus, Num, Den);\n+      return\n+        Integer_To_Fixed (Str, Val (1), Base, Scl (1), Extra, Minus, Num, Den);\n    end Value_Fixed;\n \n end System.Value_F;"}, {"sha": "c55444a1ec7b8968247f6ac7dbb032836a5a66fb", "filename": "gcc/ada/libgnat/s-valuer.adb", "status": "modified", "additions": 112, "deletions": 80, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b15134378bfba88effc523f4eb2c20a9486a63/gcc%2Fada%2Flibgnat%2Fs-valuer.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b15134378bfba88effc523f4eb2c20a9486a63/gcc%2Fada%2Flibgnat%2Fs-valuer.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuer.adb?ref=d6b15134378bfba88effc523f4eb2c20a9486a63", "patch": "@@ -44,22 +44,23 @@ package body System.Value_R is\n \n    procedure Round_Extra\n      (Digit : Char_As_Digit;\n+      Base  : Unsigned;\n       Value : in out Uns;\n       Scale : in out Integer;\n-      Extra : in out Char_As_Digit;\n-      Base  : Unsigned);\n+      Extra : in out Char_As_Digit);\n    --  Round the triplet (Value, Scale, Extra) according to Digit in Base\n \n    procedure Scan_Decimal_Digits\n       (Str            : String;\n        Index          : in out Integer;\n        Max            : Integer;\n-       Value          : in out Uns;\n-       Scale          : in out Integer;\n-       Extra          : in out Char_As_Digit;\n-       Base_Violation : in out Boolean;\n        Base           : Unsigned;\n-       Base_Specified : Boolean);\n+       Base_Specified : Boolean;\n+       Value          : in out Value_Array;\n+       Scale          : in out Scale_Array;\n+       N              : in out Positive;\n+       Extra          : in out Char_As_Digit;\n+       Base_Violation : in out Boolean);\n    --  Scan the decimal part of a real (i.e. after decimal separator)\n    --\n    --  The string parsed is Str (Index .. Max) and after the call Index will\n@@ -77,12 +78,13 @@ package body System.Value_R is\n       (Str            : String;\n        Index          : in out Integer;\n        Max            : Integer;\n-       Value          : out Uns;\n-       Scale          : out Integer;\n-       Extra          : out Char_As_Digit;\n-       Base_Violation : in out Boolean;\n        Base           : Unsigned;\n-       Base_Specified : Boolean);\n+       Base_Specified : Boolean;\n+       Value          : out Value_Array;\n+       Scale          : out Scale_Array;\n+       N              : out Positive;\n+       Extra          : out Char_As_Digit;\n+       Base_Violation : in out Boolean);\n    --  Scan the integral part of a real (i.e. before decimal separator)\n    --\n    --  The string parsed is Str (Index .. Max) and after the call Index will\n@@ -123,10 +125,10 @@ package body System.Value_R is\n \n    procedure Round_Extra\n      (Digit : Char_As_Digit;\n+      Base  : Unsigned;\n       Value : in out Uns;\n       Scale : in out Integer;\n-      Extra : in out Char_As_Digit;\n-      Base  : Unsigned)\n+      Extra : in out Char_As_Digit)\n    is\n       pragma Assert (Base in 2 .. 16);\n \n@@ -145,7 +147,7 @@ package body System.Value_R is\n                Extra := Char_As_Digit (Value mod B);\n                Value := Value / B;\n                Scale := Scale + 1;\n-               Round_Extra (Digit, Value, Scale, Extra, Base);\n+               Round_Extra (Digit, Base, Value, Scale, Extra);\n \n             else\n                Extra := 0;\n@@ -166,12 +168,13 @@ package body System.Value_R is\n       (Str            : String;\n        Index          : in out Integer;\n        Max            : Integer;\n-       Value          : in out Uns;\n-       Scale          : in out Integer;\n-       Extra          : in out Char_As_Digit;\n-       Base_Violation : in out Boolean;\n        Base           : Unsigned;\n-       Base_Specified : Boolean)\n+       Base_Specified : Boolean;\n+       Value          : in out Value_Array;\n+       Scale          : in out Scale_Array;\n+       N              : in out Positive;\n+       Extra          : in out Char_As_Digit;\n+       Base_Violation : in out Boolean)\n \n    is\n       pragma Assert (Base in 2 .. 16);\n@@ -205,7 +208,7 @@ package body System.Value_R is\n       --  If initial Scale is not 0 then it means that Precision_Limit was\n       --  reached during scanning of the integral part.\n \n-      if Scale > 0 then\n+      if Scale (Data_Index'Last) > 0 then\n          Precision_Limit_Reached := True;\n       else\n          Extra := 0;\n@@ -247,7 +250,7 @@ package body System.Value_R is\n \n          if Precision_Limit_Reached then\n             if Round and then Precision_Limit_Just_Reached then\n-               Round_Extra (Digit, Value, Scale, Extra, Base);\n+               Round_Extra (Digit, Base, Value (N), Scale (N), Extra);\n                Precision_Limit_Just_Reached := False;\n             end if;\n \n@@ -258,19 +261,24 @@ package body System.Value_R is\n                Trailing_Zeros := Trailing_Zeros + 1;\n \n             else\n-               --  Handle accumulated zeros.\n+               --  Handle accumulated zeros\n \n                for J in 1 .. Trailing_Zeros loop\n-                  if Value <= UmaxB then\n-                     Value := Value * Uns (Base);\n-                     Scale := Scale - 1;\n+                  if Value (N) <= UmaxB then\n+                     Value (N) := Value (N) * Uns (Base);\n+                     Scale (N) := Scale (N) - 1;\n+\n+                  elsif Parts > 1 and then N < Data_Index'Last then\n+                     N := N + 1;\n+                     Scale (N) := Scale (N - 1) - 1;\n \n                   else\n                      Extra := 0;\n                      Precision_Limit_Reached := True;\n                      if Round and then J = Trailing_Zeros then\n-                        Round_Extra (Digit, Value, Scale, Extra, Base);\n+                        Round_Extra (Digit, Base, Value (N), Scale (N), Extra);\n                      end if;\n+\n                      exit;\n                   end if;\n                end loop;\n@@ -281,7 +289,7 @@ package body System.Value_R is\n \n                --  Handle current non zero digit\n \n-               Temp := Value * Uns (Base) + Uns (Digit);\n+               Temp := Value (N) * Uns (Base) + Uns (Digit);\n \n                --  Precision_Limit_Reached may have been set above\n \n@@ -292,15 +300,20 @@ package body System.Value_R is\n                --  account that Temp may wrap around when Precision_Limit is\n                --  equal to the largest integer.\n \n-               elsif Value <= Umax\n-                 or else (Value <= UmaxB\n+               elsif Value (N) <= Umax\n+                 or else (Value (N) <= UmaxB\n                            and then ((Precision_Limit < Uns'Last\n                                        and then Temp <= Precision_Limit)\n                                      or else (Precision_Limit = Uns'Last\n                                                and then Temp >= Uns (Base))))\n                then\n-                  Value := Temp;\n-                  Scale := Scale - 1;\n+                  Value (N) := Temp;\n+                  Scale (N) := Scale (N) - 1;\n+\n+               elsif Parts > 1 and then N < Data_Index'Last then\n+                  N := N + 1;\n+                  Value (N) := Uns (Digit);\n+                  Scale (N) := Scale (N - 1) - 1;\n \n                else\n                   Extra := Digit;\n@@ -352,12 +365,13 @@ package body System.Value_R is\n       (Str            : String;\n        Index          : in out Integer;\n        Max            : Integer;\n-       Value          : out Uns;\n-       Scale          : out Integer;\n-       Extra          : out Char_As_Digit;\n-       Base_Violation : in out Boolean;\n        Base           : Unsigned;\n-       Base_Specified : Boolean)\n+       Base_Specified : Boolean;\n+       Value          : out Value_Array;\n+       Scale          : out Scale_Array;\n+       N              : out Positive;\n+       Extra          : out Char_As_Digit;\n+       Base_Violation : in out Boolean)\n    is\n       pragma Assert (Base in 2 .. 16);\n \n@@ -382,10 +396,11 @@ package body System.Value_R is\n       --  Temporary\n \n    begin\n-      --  Initialize Value, Scale and Extra\n+      --  Initialize N, Value, Scale and Extra\n \n-      Value := 0;\n-      Scale := 0;\n+      N := 1;\n+      Value := (others => 0);\n+      Scale := (others => 0);\n       Extra := 0;\n \n       Precision_Limit_Reached := False;\n@@ -422,39 +437,49 @@ package body System.Value_R is\n          --  should continue only to assess the validity of the string.\n \n          if Precision_Limit_Reached then\n-            Scale := Scale + 1;\n+            Scale (N) := Scale (N) + 1;\n \n             if Round and then Precision_Limit_Just_Reached then\n-               Round_Extra (Digit, Value, Scale, Extra, Base);\n+               Round_Extra (Digit, Base, Value (N), Scale (N), Extra);\n                Precision_Limit_Just_Reached := False;\n             end if;\n \n          else\n-            Temp := Value * Uns (Base) + Uns (Digit);\n+            Temp := Value (N) * Uns (Base) + Uns (Digit);\n \n             --  Check if Temp is larger than Precision_Limit, taking into\n             --  account that Temp may wrap around when Precision_Limit is\n             --  equal to the largest integer.\n \n-            if Value <= Umax\n-              or else (Value <= UmaxB\n+            if Value (N) <= Umax\n+              or else (Value (N) <= UmaxB\n                         and then ((Precision_Limit < Uns'Last\n                                     and then Temp <= Precision_Limit)\n                                   or else (Precision_Limit = Uns'Last\n                                             and then Temp >= Uns (Base))))\n             then\n-               Value := Temp;\n+               Value (N) := Temp;\n+\n+            elsif Parts > 1 and then N < Data_Index'Last then\n+               N := N + 1;\n+               Value (N) := Uns (Digit);\n \n             else\n                Extra := Digit;\n                Precision_Limit_Reached := True;\n                if Round then\n                   Precision_Limit_Just_Reached := True;\n                end if;\n-               Scale := Scale + 1;\n+               Scale (N) := Scale (N) + 1;\n             end if;\n          end if;\n \n+         --  Every parsed digit also scales the previous parts\n+\n+         for J in 1 .. N - 1 loop\n+            Scale (J) := Scale (J) + 1;\n+         end loop;\n+\n          --  Look for the next character\n \n          Index := Index + 1;\n@@ -492,9 +517,9 @@ package body System.Value_R is\n       Ptr   : not null access Integer;\n       Max   : Integer;\n       Base  : out Unsigned;\n-      Scale : out Integer;\n+      Scale : out Scale_Array;\n       Extra : out Unsigned;\n-      Minus : out Boolean) return Uns\n+      Minus : out Boolean) return Value_Array\n    is\n       pragma Assert (Max <= Str'Last);\n \n@@ -509,17 +534,20 @@ package body System.Value_R is\n       --  If True some digits where not in the base. The real is still scanned\n       --  till the end even if an error will be raised.\n \n+      N : Positive;\n+      --  Index number of the current part\n+\n       Expon : Integer;\n-      --  Exponent as an Integer\n+      --  Exponent as an integer\n \n       Index : Integer;\n       --  Local copy of string pointer\n \n       Start : Positive;\n       --  Index of the first non-blank character\n \n-      Value : Uns;\n-      --  Mantissa as an Integer\n+      Value : Value_Array;\n+      --  Mantissa as an array of integers\n \n    begin\n       --  The default base is 10\n@@ -554,8 +582,8 @@ package body System.Value_R is\n          --  part or the base to use.\n \n          Scan_Integral_Digits\n-           (Str, Index, Max, Value, Scale, Char_As_Digit (Extra),\n-            Base_Violation, Base, Base_Specified => False);\n+           (Str, Index, Max, Base, False, Value, Scale, N,\n+            Char_As_Digit (Extra), Base_Violation);\n \n       --  A dot is allowed only if followed by a digit (RM 3.5(47))\n \n@@ -565,8 +593,9 @@ package body System.Value_R is\n       then\n          After_Point := True;\n          Index := Index + 1;\n-         Value := 0;\n-         Scale := 0;\n+         N := 1;\n+         Value := (others => 0);\n+         Scale := (others => 0);\n          Extra := 0;\n \n       else\n@@ -582,8 +611,8 @@ package body System.Value_R is\n       then\n          Base_Char := Str (Index);\n \n-         if Value in 2 .. 16 then\n-            Base := Unsigned (Value);\n+         if N = 1 and then Value (1) in 2 .. 16 then\n+            Base := Unsigned (Value (1));\n          else\n             Base_Violation := True;\n             Base := 16;\n@@ -597,7 +626,7 @@ package body System.Value_R is\n          then\n             After_Point := True;\n             Index := Index + 1;\n-            Value := 0;\n+            Value := (others => 0);\n          end if;\n       end if;\n \n@@ -609,8 +638,8 @@ package body System.Value_R is\n          end if;\n \n          Scan_Integral_Digits\n-           (Str, Index, Max, Value, Scale, Char_As_Digit (Extra),\n-            Base_Violation, Base, Base_Specified => Base_Char /= ASCII.NUL);\n+           (Str, Index, Max, Base, Base_Char /= ASCII.NUL, Value, Scale,\n+            N, Char_As_Digit (Extra), Base_Violation);\n       end if;\n \n       --  Do we have a dot?\n@@ -636,8 +665,8 @@ package body System.Value_R is\n          pragma Assert (Index <= Max);\n \n          Scan_Decimal_Digits\n-           (Str, Index, Max, Value, Scale, Char_As_Digit (Extra),\n-            Base_Violation, Base, Base_Specified => Base_Char /= ASCII.NUL);\n+           (Str, Index, Max, Base, Base_Char /= ASCII.NUL, Value, Scale,\n+            N, Char_As_Digit (Extra), Base_Violation);\n       end if;\n \n       --  If an explicit base was specified ensure that the delimiter is found\n@@ -660,9 +689,15 @@ package body System.Value_R is\n       --  Handle very large exponents like Scan_Exponent\n \n       if Expon < Integer'First / 10 or else Expon > Integer'Last / 10 then\n-         Scale := Expon;\n+         Scale (1) := Expon;\n+         for J in 2 .. Data_Index'Last loop\n+            Value (J) := 0;\n+         end loop;\n+\n       else\n-         Scale := Scale + Expon;\n+         for J in Data_Index'Range loop\n+            Scale (J) := Scale (J) + Expon;\n+         end loop;\n       end if;\n \n       --  Here is where we check for a bad based number\n@@ -672,7 +707,6 @@ package body System.Value_R is\n       else\n          return Value;\n       end if;\n-\n    end Scan_Raw_Real;\n \n    --------------------\n@@ -682,10 +716,13 @@ package body System.Value_R is\n    function Value_Raw_Real\n      (Str   : String;\n       Base  : out Unsigned;\n-      Scale : out Integer;\n+      Scale : out Scale_Array;\n       Extra : out Unsigned;\n-      Minus : out Boolean) return Uns\n+      Minus : out Boolean) return Value_Array\n    is\n+      P : aliased Integer;\n+      V : Value_Array;\n+\n    begin\n       --  We have to special case Str'Last = Positive'Last because the normal\n       --  circuit ends up setting P to Str'Last + 1 which is out of bounds. We\n@@ -697,20 +734,15 @@ package body System.Value_R is\n          begin\n             return Value_Raw_Real (NT (Str), Base, Scale, Extra, Minus);\n          end;\n+      end if;\n \n-      --  Normal case where Str'Last < Positive'Last\n+      --  Normal case\n \n-      else\n-         declare\n-            V : Uns;\n-            P : aliased Integer := Str'First;\n-         begin\n-            V := Scan_Raw_Real\n-                   (Str, P'Access, Str'Last, Base, Scale, Extra, Minus);\n-            Scan_Trailing_Blanks (Str, P);\n-            return V;\n-         end;\n-      end if;\n+      P := Str'First;\n+      V := Scan_Raw_Real (Str, P'Access, Str'Last, Base, Scale, Extra, Minus);\n+      Scan_Trailing_Blanks (Str, P);\n+\n+      return V;\n    end Value_Raw_Real;\n \n end System.Value_R;"}, {"sha": "d9d168ecb3e857621ed770384cfff2d3857a4240", "filename": "gcc/ada/libgnat/s-valuer.ads", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b15134378bfba88effc523f4eb2c20a9486a63/gcc%2Fada%2Flibgnat%2Fs-valuer.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b15134378bfba88effc523f4eb2c20a9486a63/gcc%2Fada%2Flibgnat%2Fs-valuer.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuer.ads?ref=d6b15134378bfba88effc523f4eb2c20a9486a63", "patch": "@@ -37,22 +37,37 @@ with System.Unsigned_Types; use System.Unsigned_Types;\n generic\n \n    type Uns is mod <>;\n+   --  Modular type used for the value\n+\n+   Parts : Positive;\n+   --  Number of Uns parts in the value\n \n    Precision_Limit : Uns;\n+   --  Precision limit for each part of the value\n \n    Round : Boolean;\n+   --  If Parts = 1, True if the extra digit must be rounded\n \n package System.Value_R is\n    pragma Preelaborate;\n \n+   subtype Data_Index is Positive range 1 .. Parts;\n+   --  The type indexing the value\n+\n+   type Scale_Array is array (Data_Index) of Integer;\n+   --  The scale for each part of the value\n+\n+   type Value_Array is array (Data_Index) of Uns;\n+   --  The value split into parts\n+\n    function Scan_Raw_Real\n      (Str   : String;\n       Ptr   : not null access Integer;\n       Max   : Integer;\n       Base  : out Unsigned;\n-      Scale : out Integer;\n+      Scale : out Scale_Array;\n       Extra : out Unsigned;\n-      Minus : out Boolean) return Uns;\n+      Minus : out Boolean) return Value_Array;\n    --  This function scans the string starting at Str (Ptr.all) for a valid\n    --  real literal according to the syntax described in (RM 3.5(43)). The\n    --  substring scanned extends no further than Str (Max). There are three\n@@ -64,9 +79,13 @@ package System.Value_R is\n    --  parameters are set; if Val is the result of the call, then the real\n    --  represented by the literal is equal to\n    --\n-   --    (Val * Base + Extra) * (Base ** (Scale - 1))\n+   --    (Val (1) * Base + Extra) * (Base ** (Scale (1) - 1))\n+   --\n+   --  when Parts = 1 and\n+   --\n+   --    Sum [Val (N) * (Base ** Scale (N)), N in 1 .. Parts]\n    --\n-   --  with the negative sign if Minus is true.\n+   --  when Parts > 1, with the negative sign if Minus is true.\n    --\n    --  If no valid real is found, then Ptr.all points either to an initial\n    --  non-blank character, or to Max + 1 if the field is all spaces and the\n@@ -91,9 +110,9 @@ package System.Value_R is\n    function Value_Raw_Real\n      (Str   : String;\n       Base  : out Unsigned;\n-      Scale : out Integer;\n+      Scale : out Scale_Array;\n       Extra : out Unsigned;\n-      Minus : out Boolean) return Uns;\n+      Minus : out Boolean) return Value_Array;\n    --  Used in computing X'Value (Str) where X is a real type. Str is the\n    --  string argument of the attribute. Constraint_Error is raised if the\n    --  string is malformed."}]}