{"sha": "7569f6972e44e6c1f00ca5e64d940a90e0bc3e24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU2OWY2OTcyZTQ0ZTZjMWYwMGNhNWU2NGQ5NDBhOTBlMGJjM2UyNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-15T11:01:03Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-15T11:01:03Z"}, "message": "[multiple changes]\n\n2013-10-15  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_pakd.adb (Expand_Packed_Element_Set,\n\tExpand_Packed_Element_Reference): Adjust for the case of packed\n\tarrays of reverse-storage-order types.\n\n2013-10-15  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_prag.adb: Minor reformatting.\n\n2013-10-15  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_attr.adb (Analyze_Attribute_Specification, case\n\tTo_Address): If the expression is an identifier, do not modify\n\tits type; it will be converted when necessary, and the type of\n\tthe expression must remain consistent with that of the entity\n\tfor back-end consistency.\n\n2013-10-15  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch7.adb (Unit_Requires_Body): Add flag\n\tIgnore_Abstract_State (Analyze_Package_Specification): Enforce\n\trule requiring Elaborate_Body if a non-null abstract state is\n\tspecified for a library-level package.\n\t* sem_ch7.ads (Unit_Requires_Body): Add flag Ignore_Abstract_State.\n\nFrom-SVN: r203598", "tree": {"sha": "11edc23b1f016bf36a7150ae2c7dd7a51d437f58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11edc23b1f016bf36a7150ae2c7dd7a51d437f58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7569f6972e44e6c1f00ca5e64d940a90e0bc3e24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7569f6972e44e6c1f00ca5e64d940a90e0bc3e24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7569f6972e44e6c1f00ca5e64d940a90e0bc3e24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7569f6972e44e6c1f00ca5e64d940a90e0bc3e24/comments", "author": null, "committer": null, "parents": [{"sha": "ecbda48438f5bbdc95104785e61d81855f05db1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecbda48438f5bbdc95104785e61d81855f05db1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecbda48438f5bbdc95104785e61d81855f05db1b"}], "stats": {"total": 212, "additions": 184, "deletions": 28}, "files": [{"sha": "41fd9869dcf4e5f08d0239aa890214e981b45af9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7569f6972e44e6c1f00ca5e64d940a90e0bc3e24/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7569f6972e44e6c1f00ca5e64d940a90e0bc3e24/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7569f6972e44e6c1f00ca5e64d940a90e0bc3e24", "patch": "@@ -1,3 +1,29 @@\n+2013-10-15  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_pakd.adb (Expand_Packed_Element_Set,\n+\tExpand_Packed_Element_Reference): Adjust for the case of packed\n+\tarrays of reverse-storage-order types.\n+\n+2013-10-15  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_prag.adb: Minor reformatting.\n+\n+2013-10-15  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Attribute_Specification, case\n+\tTo_Address): If the expression is an identifier, do not modify\n+\tits type; it will be converted when necessary, and the type of\n+\tthe expression must remain consistent with that of the entity\n+\tfor back-end consistency.\n+\n+2013-10-15  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch7.adb (Unit_Requires_Body): Add flag\n+\tIgnore_Abstract_State (Analyze_Package_Specification): Enforce\n+\trule requiring Elaborate_Body if a non-null abstract state is\n+\tspecified for a library-level package.\n+\t* sem_ch7.ads (Unit_Requires_Body): Add flag Ignore_Abstract_State.\n+\n 2013-10-15  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_prag.adb (Analyze_Constituent): When"}, {"sha": "7a27b7a58f8d58e856ef89bbdb245bd87d3318dd", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 96, "deletions": 18, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7569f6972e44e6c1f00ca5e64d940a90e0bc3e24/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7569f6972e44e6c1f00ca5e64d940a90e0bc3e24/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=7569f6972e44e6c1f00ca5e64d940a90e0bc3e24", "patch": "@@ -543,39 +543,78 @@ package body Exp_Pakd is\n    --  array type on the fly). Such actions are inserted into the tree\n    --  directly using Insert_Action.\n \n-   function Byte_Swap (N : Node_Id) return Node_Id;\n+   function Byte_Swap\n+     (N             : Node_Id;\n+      Left_Justify  : Boolean := False;\n+      Right_Justify : Boolean := False) return Node_Id;\n    --  Wrap N in a call to a byte swapping function, with appropriate type\n-   --  conversions.\n+   --  conversions. If Left_Justify is set True, the value is left justified\n+   --  before swapping. If Right_Justify is set True, the value is right\n+   --  justified after swapping. The Etype of the returned node is an\n+   --  integer type of an appropriate power-of-2 size.\n \n    ---------------\n    -- Byte_Swap --\n    ---------------\n \n-   function Byte_Swap (N : Node_Id) return Node_Id is\n+   function Byte_Swap\n+     (N             : Node_Id;\n+      Left_Justify  : Boolean := False;\n+      Right_Justify : Boolean := False) return Node_Id\n+   is\n       Loc     : constant Source_Ptr := Sloc (N);\n       T       : constant Entity_Id := Etype (N);\n+      T_Size  : constant Uint := RM_Size (T);\n+\n       Swap_RE : RE_Id;\n       Swap_F  : Entity_Id;\n+      Swap_T  : Entity_Id;\n+      --  Swapping function\n+\n+      Arg     : Node_Id;\n+      Swapped : Node_Id;\n+      Shift   : Uint;\n \n    begin\n-      pragma Assert (Esize (T) > 8);\n+      pragma Assert (T_Size > 8);\n \n-      if Esize (T) <= 16 then\n+      if T_Size <= 16 then\n          Swap_RE := RE_Bswap_16;\n-      elsif Esize (T) <= 32 then\n+\n+      elsif T_Size <= 32 then\n          Swap_RE := RE_Bswap_32;\n-      else pragma Assert (Esize (T) <= 64);\n+\n+      else pragma Assert (T_Size <= 64);\n          Swap_RE := RE_Bswap_64;\n       end if;\n \n       Swap_F := RTE (Swap_RE);\n+      Swap_T := Etype (Swap_F);\n+      Shift := Esize (Swap_T) - T_Size;\n+\n+      Arg := RJ_Unchecked_Convert_To (Swap_T, N);\n+\n+      if Left_Justify and then Shift > Uint_0 then\n+         Arg :=\n+           Make_Op_Shift_Left (Loc,\n+             Left_Opnd  => Arg,\n+             Right_Opnd => Make_Integer_Literal (Loc, Shift));\n+      end if;\n+\n+      Swapped :=\n+        Make_Function_Call (Loc,\n+          Name                   => New_Occurrence_Of (Swap_F, Loc),\n+          Parameter_Associations => New_List (Arg));\n+\n+      if Right_Justify and then Shift > Uint_0 then\n+         Swapped :=\n+           Make_Op_Shift_Right (Loc,\n+             Left_Opnd  => Swapped,\n+             Right_Opnd => Make_Integer_Literal (Loc, Shift));\n+      end if;\n \n-      return\n-        Unchecked_Convert_To (T,\n-          Make_Function_Call (Loc,\n-            Name                   => New_Occurrence_Of (Swap_F, Loc),\n-            Parameter_Associations =>\n-              New_List (Unchecked_Convert_To (Etype (Swap_F), N))));\n+      Set_Etype (Swapped, Swap_T);\n+      return Swapped;\n    end Byte_Swap;\n \n    ------------------------------\n@@ -1537,7 +1576,9 @@ package body Exp_Pakd is\n               and then not In_Reverse_Storage_Order_Object (Obj)\n             then\n                Require_Byte_Swapping := True;\n-               New_Rhs := Byte_Swap (New_Rhs);\n+               New_Rhs := Byte_Swap (New_Rhs,\n+                            Left_Justify  => Bytes_Big_Endian,\n+                            Right_Justify => not Bytes_Big_Endian);\n             end if;\n          end;\n \n@@ -1610,7 +1651,6 @@ package body Exp_Pakd is\n                   --  not a left justified conversion.\n \n                   Rhs := RJ_Unchecked_Convert_To (Etype (Obj), Rhs);\n-\n                end Fixup_Rhs;\n \n             begin\n@@ -1660,18 +1700,24 @@ package body Exp_Pakd is\n \n                if Nkind (New_Rhs) = N_Op_And then\n                   Set_Paren_Count (New_Rhs, 1);\n+                  Set_Etype (New_Rhs, Etype (Left_Opnd (New_Rhs)));\n                end if;\n \n                New_Rhs :=\n                  Make_Op_Or (Loc,\n                    Left_Opnd  => New_Rhs,\n-                   Right_Opnd => Or_Rhs);\n+                   Right_Opnd => Unchecked_Convert_To\n+                                   (Etype (New_Rhs), Or_Rhs));\n             end;\n          end if;\n \n          if Require_Byte_Swapping then\n             Set_Etype (New_Rhs, Etype (Obj));\n-            New_Rhs := Byte_Swap (New_Rhs);\n+            New_Rhs :=\n+              Unchecked_Convert_To (Etype (Obj),\n+                Byte_Swap (New_Rhs,\n+                             Left_Justify  => not Bytes_Big_Endian,\n+                             Right_Justify => Bytes_Big_Endian));\n          end if;\n \n          --  Now do the rewrite\n@@ -1991,6 +2037,11 @@ package body Exp_Pakd is\n       Lit   : Node_Id;\n       Arg   : Node_Id;\n \n+      Byte_Swapped : Boolean;\n+      --  Set true if bytes were swapped for the purpose of extracting the\n+      --  element, in which case we must swap back if the component type is\n+      --  a composite type with reverse scalar storage order.\n+\n    begin\n       --  If the node is an actual in a call, the prefix has not been fully\n       --  expanded, to account for the additional expansion for in-out actuals\n@@ -2057,7 +2108,13 @@ package body Exp_Pakd is\n            and then Esize (Atyp) > 8\n            and then not In_Reverse_Storage_Order_Object (Obj)\n          then\n-            Obj := Byte_Swap (Obj);\n+            Obj := Byte_Swap (Obj,\n+                     Left_Justify  => Bytes_Big_Endian,\n+                     Right_Justify => not Bytes_Big_Endian);\n+            Byte_Swapped := True;\n+\n+         else\n+            Byte_Swapped := False;\n          end if;\n \n          --  We generate a shift right to position the field, followed by a\n@@ -2075,6 +2132,15 @@ package body Exp_Pakd is\n              Left_Opnd  => Make_Shift_Right (Obj, Shift),\n              Right_Opnd => Lit);\n \n+         --  Swap back if necessary\n+\n+         Set_Etype (Arg, Ctyp);\n+         if Byte_Swapped and then Reverse_Storage_Order (Ctyp) then\n+            Arg := Byte_Swap (Arg,\n+                     Left_Justify  => not Bytes_Big_Endian,\n+                     Right_Justify => False);\n+         end if;\n+\n          --  We needed to analyze this before we do the unchecked convert\n          --  below, but we need it temporarily attached to the tree for\n          --  this analysis (hence the temporary Set_Parent call).\n@@ -2597,6 +2663,18 @@ package body Exp_Pakd is\n       Source_Siz := UI_To_Int (RM_Size (Source_Typ));\n       Target_Siz := UI_To_Int (RM_Size (Target_Typ));\n \n+      --  For a little-endian target type stored byte-swapped on a\n+      --  big-endian machine, do not mask to Target_Siz bits.\n+\n+      if Bytes_Big_Endian\n+           and then (Is_Record_Type (Target_Typ)\n+                       or else\n+                     Is_Array_Type (Target_Typ))\n+           and then Reverse_Storage_Order (Target_Typ)\n+      then\n+         Source_Siz := Target_Siz;\n+      end if;\n+\n       --  First step, if the source type is not a discrete type, then we first\n       --  convert to a modular type of the source length, since otherwise, on\n       --  a big-endian machine, we get left-justification. We do it for little-"}, {"sha": "177c3de74fa7c732d198b8087ff84f28cdb48ae8", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7569f6972e44e6c1f00ca5e64d940a90e0bc3e24/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7569f6972e44e6c1f00ca5e64d940a90e0bc3e24/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=7569f6972e44e6c1f00ca5e64d940a90e0bc3e24", "patch": "@@ -5627,9 +5627,16 @@ package body Sem_Attr is\n                Error_Attr (\"address value out of range for % attribute\", E1);\n             end if;\n \n+            --  In most cases the expression is a numeric literal or some other\n+            --  address expression, but if it is a declared constant it may be\n+            --  of a compatible type that must be left on the node.\n+\n+            if Is_Entity_Name (E1) then\n+               null;\n+\n             --  Set type to universal integer if negative\n \n-            if Val < 0 then\n+            elsif Val < 0 then\n                Set_Etype (E1, Universal_Integer);\n \n             --  Otherwise set type to Unsigned_64 to accomodate max values"}, {"sha": "0239fa76d4b9de1f8a8dfc8c7b31f9498c0433d5", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 43, "deletions": 4, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7569f6972e44e6c1f00ca5e64d940a90e0bc3e24/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7569f6972e44e6c1f00ca5e64d940a90e0bc3e24/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=7569f6972e44e6c1f00ca5e64d940a90e0bc3e24", "patch": "@@ -1483,7 +1483,38 @@ package body Sem_Ch7 is\n          Clear_Constants (Id, First_Private_Entity (Id));\n       end if;\n \n+      --  Issue an error in SPARK mode if a package specification contains\n+      --  more than one tagged type or type extension.\n+\n       Check_One_Tagged_Type_Or_Extension_At_Most;\n+\n+      --  Issue an error if a package that is a library unit does not require a\n+      --  body, and we have a non-null abstract state (SPARK LRM 7.1.5(4)).\n+\n+      if not Unit_Requires_Body (Id, Ignore_Abstract_State => True)\n+        and then Present (Abstract_States (Id))\n+\n+        --  We use Scope_Depth of 1 to identify library units, which seems a\n+        --  bit ugly, but there doesn't seem to be an easier way.\n+\n+        and then Scope_Depth (Id) = 1\n+\n+        --  A null abstract state always appears as the sole element of the\n+        --  state list.\n+\n+        and then not Is_Null_State (Node (First_Elmt (Abstract_States (Id))))\n+      then\n+         declare\n+            P : constant Node_Id := Get_Pragma (Id, Pragma_Abstract_State);\n+         begin\n+            Error_Msg_NE\n+              (\"package & specifies a non-null abstract state\", P, Id);\n+            Error_Msg_N\n+              (\"\\but package does not otherwise require a body\", P);\n+            Error_Msg_N\n+              (\"\\pragma Elaborate_Body is required in this case\", P);\n+         end;\n+      end if;\n    end Analyze_Package_Specification;\n \n    --------------------------------------\n@@ -2588,7 +2619,10 @@ package body Sem_Ch7 is\n    -- Unit_Requires_Body --\n    ------------------------\n \n-   function Unit_Requires_Body (P : Entity_Id) return Boolean is\n+   function Unit_Requires_Body\n+     (P                     : Entity_Id;\n+      Ignore_Abstract_State : Boolean := False) return Boolean\n+   is\n       E : Entity_Id;\n \n    begin\n@@ -2627,12 +2661,17 @@ package body Sem_Ch7 is\n          end;\n \n       --  A [generic] package that introduces at least one non-null abstract\n-      --  state requires completion. A null abstract state always appears as\n-      --  the sole element of the state list.\n+      --  state requires completion. However, there is a separate rule that\n+      --  requires that such a package have a reason other than this for a\n+      --  body being required (if necessary a pragma Elaborate_Body must be\n+      --  provided). If Ignore_Abstract_State is True, we don't do this check\n+      --  (so we can use Unit_Requires_Body to check for some other reason).\n \n       elsif Ekind_In (P, E_Generic_Package, E_Package)\n+        and then not Ignore_Abstract_State\n         and then Present (Abstract_States (P))\n-        and then not Is_Null_State (Node (First_Elmt (Abstract_States (P))))\n+        and then\n+            not Is_Null_State (Node (First_Elmt (Abstract_States (P))))\n       then\n          return True;\n       end if;"}, {"sha": "11e05cd7909c3f500b8f62e7c004563905e26690", "filename": "gcc/ada/sem_ch7.ads", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7569f6972e44e6c1f00ca5e64d940a90e0bc3e24/gcc%2Fada%2Fsem_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7569f6972e44e6c1f00ca5e64d940a90e0bc3e24/gcc%2Fada%2Fsem_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.ads?ref=7569f6972e44e6c1f00ca5e64d940a90e0bc3e24", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -52,9 +52,15 @@ package Sem_Ch7 is\n    --  but is deferred until the compilation of the  private part of the\n    --  child for public child packages.\n \n-   function Unit_Requires_Body (P : Entity_Id) return Boolean;\n-   --  Check if a unit requires a body. A specification requires a body\n-   --  if it contains declarations that require completion in a body.\n+   function Unit_Requires_Body\n+     (P                     : Entity_Id;\n+      Ignore_Abstract_State : Boolean := False) return Boolean;\n+   --  Check if a unit requires a body. A specification requires a body if it\n+   --  contains declarations that require completion in a body. If the flag\n+   --  Ignore_Abstract_State is set True, then the test for a non-null abstract\n+   --  state (which normally requires a body) is not carried out. This allows\n+   --  the use of this routine to tell if there is some other reason that a\n+   --  body is required (as is required for analyzing Abstract_State).\n \n    procedure May_Need_Implicit_Body (E : Entity_Id);\n    --  If a package declaration contains tasks or RACWs and does not require"}, {"sha": "8fa7853dcd86540232ee16e2f3d716aace46ef17", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7569f6972e44e6c1f00ca5e64d940a90e0bc3e24/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7569f6972e44e6c1f00ca5e64d940a90e0bc3e24/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=7569f6972e44e6c1f00ca5e64d940a90e0bc3e24", "patch": "@@ -4960,7 +4960,7 @@ package body Sem_Prag is\n                      Pragma_Misplaced;\n \n                   elsif (Nkind (Parent_Node) = N_Generic_Package_Declaration\n-                           or else Nkind (Parent_Node) =\n+                          or else Nkind (Parent_Node) =\n                                              N_Generic_Subprogram_Declaration)\n                     and then Plist = Generic_Formal_Declarations (Parent_Node)\n                   then"}]}