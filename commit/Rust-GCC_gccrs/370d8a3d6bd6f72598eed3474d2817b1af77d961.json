{"sha": "370d8a3d6bd6f72598eed3474d2817b1af77d961", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzcwZDhhM2Q2YmQ2ZjcyNTk4ZWVkMzQ3NGQyODE3YjFhZjc3ZDk2MQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2012-03-12T15:12:40Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2012-03-12T15:12:40Z"}, "message": "re PR libstdc++/52562 ([C++11] Most type_info functions not noexcept)\n\n2012-03-12  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR libstdc++/52562\n\t* libsupc++/typeinfo (type_info::name, before, operator==,\n\toperator!=): Mark noexcept in C++11 mode.\n\t* libsupc++/tinfo.cc (type_info::operator==): Adjust.\n\t* libsupc++/tinfo2.cc (type_info::before): Likewise.\n\t* testsuite/18_support/type_info/52562.cc: New.\n\nFrom-SVN: r185235", "tree": {"sha": "07b1866f06db09af0d2220801cca3536892f6058", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07b1866f06db09af0d2220801cca3536892f6058"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/370d8a3d6bd6f72598eed3474d2817b1af77d961", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/370d8a3d6bd6f72598eed3474d2817b1af77d961", "html_url": "https://github.com/Rust-GCC/gccrs/commit/370d8a3d6bd6f72598eed3474d2817b1af77d961", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/370d8a3d6bd6f72598eed3474d2817b1af77d961/comments", "author": null, "committer": null, "parents": [{"sha": "bb008427e190337ae91d93a14e90e87966d08887", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb008427e190337ae91d93a14e90e87966d08887", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb008427e190337ae91d93a14e90e87966d08887"}], "stats": {"total": 64, "additions": 52, "deletions": 12}, "files": [{"sha": "78d23a5a9fe8a5200f8bea4010d77d61eecb432a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370d8a3d6bd6f72598eed3474d2817b1af77d961/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370d8a3d6bd6f72598eed3474d2817b1af77d961/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=370d8a3d6bd6f72598eed3474d2817b1af77d961", "patch": "@@ -1,3 +1,12 @@\n+2012-03-12  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR libstdc++/52562\n+\t* libsupc++/typeinfo (type_info::name, before, operator==,\n+\toperator!=): Mark noexcept in C++11 mode.\n+\t* libsupc++/tinfo.cc (type_info::operator==): Adjust.\n+\t* libsupc++/tinfo2.cc (type_info::before): Likewise.\n+\t* testsuite/18_support/type_info/52562.cc: New.\n+\n 2012-03-10  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* config/abi/post/hppa-linux-gnu/baseline_symbols.txt: Remove TLS"}, {"sha": "d7affedfc2759f7d9268f92386156102be36d391", "filename": "libstdc++-v3/libsupc++/tinfo.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370d8a3d6bd6f72598eed3474d2817b1af77d961/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370d8a3d6bd6f72598eed3474d2817b1af77d961/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo.cc?ref=370d8a3d6bd6f72598eed3474d2817b1af77d961", "patch": "@@ -1,6 +1,6 @@\n // Methods for type_info for -*- C++ -*- Run Time Type Identification.\n // Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-// 2003, 2004, 2005, 2006, 2007, 2009\n+// 2003, 2004, 2005, 2006, 2007, 2009, 2012\n // Free Software Foundation\n //\n // This file is part of GCC.\n@@ -36,7 +36,7 @@ std::type_info::\n \n // We can't rely on common symbols being shared between shared objects.\n bool std::type_info::\n-operator== (const std::type_info& arg) const\n+operator== (const std::type_info& arg) const _GLIBCXX_NOEXCEPT\n {\n #if __GXX_MERGED_TYPEINFO_NAMES\n   return name () == arg.name ();"}, {"sha": "e4c36649f342806f933f2703748113dab8e64d41", "filename": "libstdc++-v3/libsupc++/tinfo2.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370d8a3d6bd6f72598eed3474d2817b1af77d961/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370d8a3d6bd6f72598eed3474d2817b1af77d961/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo2.cc?ref=370d8a3d6bd6f72598eed3474d2817b1af77d961", "patch": "@@ -1,6 +1,7 @@\n // Methods for type_info for -*- C++ -*- Run Time Type Identification.\n \n-// Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2009\n+// Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2009,\n+// 2012\n // Free Software Foundation\n //\n // This file is part of GCC.\n@@ -32,7 +33,7 @@ using std::type_info;\n #if !__GXX_TYPEINFO_EQUALITY_INLINE\n \n bool\n-type_info::before (const type_info &arg) const\n+type_info::before (const type_info &arg) const _GLIBCXX_NOEXCEPT\n {\n #if __GXX_MERGED_TYPEINFO_NAMES\n   return name () < arg.name ();"}, {"sha": "bf0935cfb5972bf0e0850f02eda48db42c3a4b2f", "filename": "libstdc++-v3/libsupc++/typeinfo", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370d8a3d6bd6f72598eed3474d2817b1af77d961/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftypeinfo", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370d8a3d6bd6f72598eed3474d2817b1af77d961/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftypeinfo", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftypeinfo?ref=370d8a3d6bd6f72598eed3474d2817b1af77d961", "patch": "@@ -98,28 +98,28 @@ namespace std\n \n     /** Returns an @e implementation-defined byte string; this is not\n      *  portable between compilers!  */\n-    const char* name() const\n+    const char* name() const _GLIBCXX_NOEXCEPT\n     { return __name[0] == '*' ? __name + 1 : __name; }\n \n #if !__GXX_TYPEINFO_EQUALITY_INLINE\n     // In old abi, or when weak symbols are not supported, there can\n     // be multiple instances of a type_info object for one\n     // type. Uniqueness must use the _name value, not object address.\n-    bool before(const type_info& __arg) const;\n-    bool operator==(const type_info& __arg) const;\n+    bool before(const type_info& __arg) const _GLIBCXX_NOEXCEPT;\n+    bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT;\n #else\n   #if !__GXX_MERGED_TYPEINFO_NAMES\n     /** Returns true if @c *this precedes @c __arg in the implementation's\n      *  collation order.  */\n     // Even with the new abi, on systems that support dlopen\n     // we can run into cases where type_info names aren't merged,\n     // so we still need to do string comparison.\n-    bool before(const type_info& __arg) const\n+    bool before(const type_info& __arg) const _GLIBCXX_NOEXCEPT\n     { return (__name[0] == '*' && __arg.__name[0] == '*')\n \t? __name < __arg.__name\n \t: __builtin_strcmp (__name, __arg.__name) < 0; }\n \n-    bool operator==(const type_info& __arg) const\n+    bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT\n     {\n       return ((__name == __arg.__name)\n \t      || (__name[0] != '*' &&\n@@ -128,14 +128,14 @@ namespace std\n   #else\n     // On some targets we can rely on type_info's NTBS being unique,\n     // and therefore address comparisons are sufficient.\n-    bool before(const type_info& __arg) const\n+    bool before(const type_info& __arg) const _GLIBCXX_NOEXCEPT\n     { return __name < __arg.__name; }\n \n-    bool operator==(const type_info& __arg) const\n+    bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT\n     { return __name == __arg.__name; }\n   #endif\n #endif\n-    bool operator!=(const type_info& __arg) const\n+    bool operator!=(const type_info& __arg) const _GLIBCXX_NOEXCEPT\n     { return !operator==(__arg); }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__"}, {"sha": "6b2aaf7fe4732fc17a85c802de3fc5a37143b20c", "filename": "libstdc++-v3/testsuite/18_support/type_info/52562.cc", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370d8a3d6bd6f72598eed3474d2817b1af77d961/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Ftype_info%2F52562.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370d8a3d6bd6f72598eed3474d2817b1af77d961/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Ftype_info%2F52562.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Ftype_info%2F52562.cc?ref=370d8a3d6bd6f72598eed3474d2817b1af77d961", "patch": "@@ -0,0 +1,30 @@\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2012 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <typeinfo>\n+\n+template<class T> T& lval() noexcept;\n+\n+// libstdc++/52562\n+static_assert(noexcept(lval<std::type_info>().name()), \"\");\n+static_assert(noexcept(lval<std::type_info>().before(lval<std::type_info>())),\n+\"\");\n+static_assert(noexcept(lval<std::type_info>() == lval<std::type_info>()), \"\");\n+static_assert(noexcept(lval<std::type_info>() != lval<std::type_info>()), \"\");"}]}