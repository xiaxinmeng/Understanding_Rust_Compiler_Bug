{"sha": "101c5bc507e0067fe0c97a2eefd0192d5092b0d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTAxYzViYzUwN2UwMDY3ZmUwYzk3YTJlZWZkMDE5MmQ1MDkyYjBkMA==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2005-04-17T14:30:37Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2005-04-17T14:30:37Z"}, "message": "re PR libstdc++/20914 (Another grouping trouble)\n\n2005-04-17  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/20914\n\t* include/bits/locale_facets.tcc (__int_to_char(_CharT*, _ValueT,\n\tconst _CharT*, ios_base::fmtflags, bool)): Don't deal with numeric\n\tbase or sign here, instead...\n\t(_M_insert_int(_OutIter, ios_base&, _CharT, _ValueT)): ... here,\n\tafter adding the grouping. This fixes the bug and also allows to\n\tclean-up the code dealing with integer types.\n\t(_M_group_int(const char*, size_t, _CharT, ios_base&, _CharT*,\n\t_CharT*, int&)): Simplify, remove bits dealing with numeric base.\n\t(__int_to_char(_CharT*, unsigned long, const _CharT*,\n\tios_base::fmtflags), __int_to_char(_CharT*, unsigned long long,\n\tconst _CharT*, ios_base::fmtflags)): Remove hackish fix for\n\tlibstdc++/15565.\n\t(__int_to_char(_CharT*, long, const _CharT*, ios_base::fmtflags),\n\t__int_to_char(_CharT*, long long, const _CharT*, ios_base::fmtflags)):\n\tSimplify, don't pass the sign.\n\t(_M_insert_float(_OutIter, ios_base&, _CharT, char, _ValueT)):\n\tDeal with a sign at the beginning of __cs; robustify the grouping\n\tcheck.\n\t* testsuite/22_locale/num_put/put/char/20914.cc: New.\n\t* testsuite/22_locale/num_put/put/wchar_t/20914.cc: Likewise.\n\nFrom-SVN: r98271", "tree": {"sha": "1a3e207094215de0d9c31617713705d0d5ce8bb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a3e207094215de0d9c31617713705d0d5ce8bb7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/101c5bc507e0067fe0c97a2eefd0192d5092b0d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/101c5bc507e0067fe0c97a2eefd0192d5092b0d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/101c5bc507e0067fe0c97a2eefd0192d5092b0d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/101c5bc507e0067fe0c97a2eefd0192d5092b0d0/comments", "author": null, "committer": null, "parents": [{"sha": "a34938bea3d8eeb9bc673b39e6c140825e1cbecf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a34938bea3d8eeb9bc673b39e6c140825e1cbecf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a34938bea3d8eeb9bc673b39e6c140825e1cbecf"}], "stats": {"total": 438, "additions": 310, "deletions": 128}, "files": [{"sha": "556302515fb0666010162fd062f0e9cbb4607524", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/101c5bc507e0067fe0c97a2eefd0192d5092b0d0/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/101c5bc507e0067fe0c97a2eefd0192d5092b0d0/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=101c5bc507e0067fe0c97a2eefd0192d5092b0d0", "patch": "@@ -1,12 +1,36 @@\n+2005-04-17  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/20914\n+\t* include/bits/locale_facets.tcc (__int_to_char(_CharT*, _ValueT,\n+\tconst _CharT*, ios_base::fmtflags, bool)): Don't deal with numeric\n+\tbase or sign here, instead...\n+\t(_M_insert_int(_OutIter, ios_base&, _CharT, _ValueT)): ... here,\n+\tafter adding the grouping. This fixes the bug and also allows to\n+\tclean-up the code dealing with integer types.\n+\t(_M_group_int(const char*, size_t, _CharT, ios_base&, _CharT*,\n+\t_CharT*, int&)): Simplify, remove bits dealing with numeric base.\n+\t(__int_to_char(_CharT*, unsigned long, const _CharT*,\n+\tios_base::fmtflags), __int_to_char(_CharT*, unsigned long long,\n+\tconst _CharT*, ios_base::fmtflags)): Remove hackish fix for\n+\tlibstdc++/15565.\n+\t(__int_to_char(_CharT*, long, const _CharT*, ios_base::fmtflags),\n+\t__int_to_char(_CharT*, long long, const _CharT*, ios_base::fmtflags)):\n+\tSimplify, don't pass the sign.\n+\t(_M_insert_float(_OutIter, ios_base&, _CharT, char, _ValueT)):\n+\tDeal with a sign at the beginning of __cs; robustify the grouping\t\n+\tcheck.\n+\t* testsuite/22_locale/num_put/put/char/20914.cc: New.\n+\t* testsuite/22_locale/num_put/put/wchar_t/20914.cc: Likewise.\n+\n 2005-04-14  Benjamin Kosnik  <bkoz@redhat.com>\n \n-        * include/ext/bitmap_allocator.h\n-        (__gnu_cxx::free_list::_M_get_mutex): New.\n-        (__gnu_cxx::free_list::_M_get_free_list): New.\n-        (__gnu_cxx::free_list::_S_bfl_mutex): Remove.\n-        (__gnu_cxx::free_list::_S_free_list): Remove.\n-        * src/bitmap_allocator.cc: Same.\n-        * config/linker-map.gnu: Remove free_list and mutex export.\n+\t* include/ext/bitmap_allocator.h\n+\t(__gnu_cxx::free_list::_M_get_mutex): New.\n+\t(__gnu_cxx::free_list::_M_get_free_list): New.\n+\t(__gnu_cxx::free_list::_S_bfl_mutex): Remove.\n+\t(__gnu_cxx::free_list::_S_free_list): Remove.\n+\t* src/bitmap_allocator.cc: Same.\n+\t* config/linker-map.gnu: Remove free_list and mutex export.\n \n 2005-04-14  Benjamin Kosnik  <bkoz@redhat.com>\n "}, {"sha": "b558237ff47de36c4ebae8f10978a13ea75abeb4", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 121, "deletions": 121, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/101c5bc507e0067fe0c97a2eefd0192d5092b0d0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/101c5bc507e0067fe0c97a2eefd0192d5092b0d0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=101c5bc507e0067fe0c97a2eefd0192d5092b0d0", "patch": "@@ -1,6 +1,6 @@\n // Locale support -*- C++ -*-\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -853,24 +853,16 @@ namespace std\n \t\t  ios_base::fmtflags __flags)\n     {\n       unsigned long __ul = static_cast<unsigned long>(__v);\n-      bool __neg = false;\n       if (__v < 0)\n-\t{\n-\t  __ul = -__ul;\n-\t  __neg = true;\n-\t}\n-      return __int_to_char(__bufend, __ul, __lit, __flags, __neg);\n+\t__ul = -__ul;\n+      return __int_to_char(__bufend, __ul, __lit, __flags, false);\n     }\n \n   template<typename _CharT>\n     inline int\n     __int_to_char(_CharT* __bufend, unsigned long __v, const _CharT* __lit,\n \t\t  ios_base::fmtflags __flags)\n-    {\n-      // About showpos, see Table 60 and C99 7.19.6.1, p6 (+).\n-      return __int_to_char(__bufend, __v, __lit,\n-\t\t\t   __flags & ~ios_base::showpos, false);\n-    }\n+    { return __int_to_char(__bufend, __v, __lit, __flags, false); }\n \n #ifdef _GLIBCXX_USE_LONG_LONG\n   template<typename _CharT>\n@@ -879,59 +871,47 @@ namespace std\n \t\t  ios_base::fmtflags __flags)\n     {\n       unsigned long long __ull = static_cast<unsigned long long>(__v);\n-      bool __neg = false;\n       if (__v < 0)\n-\t{\n-\t  __ull = -__ull;\n-\t  __neg = true;\n-\t}\n-      return __int_to_char(__bufend, __ull, __lit, __flags, __neg);\n+\t__ull = -__ull;\n+      return __int_to_char(__bufend, __ull, __lit, __flags, false);\n     }\n \n   template<typename _CharT>\n     inline int\n     __int_to_char(_CharT* __bufend, unsigned long long __v, \n \t\t  const _CharT* __lit, ios_base::fmtflags __flags)\n-    { return __int_to_char(__bufend, __v, __lit,\n-\t\t\t   __flags & ~ios_base::showpos, false); }\n+    { return __int_to_char(__bufend, __v, __lit, __flags, false); }\n #endif\n \n+  // N.B. The last argument is currently unused (see libstdc++/20914).\n   template<typename _CharT, typename _ValueT>\n     int\n     __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,\n-\t\t  ios_base::fmtflags __flags, bool __neg)\n+\t\t  ios_base::fmtflags __flags, bool)\n     {\n-      // Don't write base if already 0.\n-      const bool __showbase = (__flags & ios_base::showbase) && __v;\n       const ios_base::fmtflags __basefield = __flags & ios_base::basefield;\n-      _CharT* __buf = __bufend - 1;\n+      _CharT* __buf = __bufend;\n \n-      if (__builtin_expect(__basefield != ios_base::oct &&\n-\t\t\t   __basefield != ios_base::hex, true))\n+      if (__builtin_expect(__basefield != ios_base::oct\n+\t\t\t   && __basefield != ios_base::hex, true))\n \t{\n \t  // Decimal.\n \t  do\n \t    {\n-\t      *__buf-- = __lit[(__v % 10) + __num_base::_S_odigits];\n+\t      *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];\n \t      __v /= 10;\n \t    }\n \t  while (__v != 0);\n-\t  if (__neg)\n-\t    *__buf-- = __lit[__num_base::_S_ominus];\n-\t  else if (__flags & ios_base::showpos)\n-\t    *__buf-- = __lit[__num_base::_S_oplus];\n \t}\n       else if (__basefield == ios_base::oct)\n \t{\n \t  // Octal.\n \t  do\n \t    {\n-\t      *__buf-- = __lit[(__v & 0x7) + __num_base::_S_odigits];\n+\t      *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];\n \t      __v >>= 3;\n \t    }\n \t  while (__v != 0);\n-\t  if (__showbase)\n-\t    *__buf-- = __lit[__num_base::_S_odigits];\n \t}\n       else\n \t{\n@@ -941,53 +921,25 @@ namespace std\n \t                                        : __num_base::_S_odigits;\n \t  do\n \t    {\n-\t      *__buf-- = __lit[(__v & 0xf) + __case_offset];\n+\t      *--__buf = __lit[(__v & 0xf) + __case_offset];\n \t      __v >>= 4;\n \t    }\n \t  while (__v != 0);\n-\t  if (__showbase)\n-\t    {\n-\t      // 'x' or 'X'\n-\t      *__buf-- = __lit[__num_base::_S_ox + __uppercase];\n-\t      // '0'\n-\t      *__buf-- = __lit[__num_base::_S_odigits];\n-\t    }\n \t}\n-      return __bufend - __buf - 1;\n+      return __bufend - __buf;\n     }\n \n   template<typename _CharT, typename _OutIter>\n     void\n     num_put<_CharT, _OutIter>::\n     _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,\n-\t\t ios_base& __io, _CharT* __new, _CharT* __cs, int& __len) const\n+\t\t ios_base&, _CharT* __new, _CharT* __cs, int& __len) const\n     {\n-      // By itself __add_grouping cannot deal correctly with __cs when\n-      // ios::showbase is set and ios_base::oct || ios_base::hex.\n-      // Therefore we take care \"by hand\" of the initial 0, 0x or 0X.\n-      // However, remember that the latter do not occur if the number\n-      // printed is '0' (__len == 1).\n-      streamsize __off = 0;\n-      const ios_base::fmtflags __basefield = __io.flags()\n-\t                                     & ios_base::basefield;\n-      if ((__io.flags() & ios_base::showbase) && __len > 1)\n-\tif (__basefield == ios_base::oct)\n-\t  {\n-\t    __off = 1;\n-\t    __new[0] = __cs[0];\n-\t  }\n-\telse if (__basefield == ios_base::hex)\n-\t  {\n-\t    __off = 2;\n-\t    __new[0] = __cs[0];\n-\t    __new[1] = __cs[1];\n-\t  }\n-      _CharT* __p = std::__add_grouping(__new + __off, __sep, __grouping,\n-\t\t\t\t\t__grouping_size, __cs + __off,\n-\t\t\t\t\t__cs + __len);\n+      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,\n+\t\t\t\t\t__grouping_size, __cs, __cs + __len);\n       __len = __p - __new;\n     }\n-\n+  \n   template<typename _CharT, typename _OutIter>\n     template<typename _ValueT>\n       _OutIter\n@@ -1000,28 +952,64 @@ namespace std\n \tconst locale& __loc = __io._M_getloc();\n \tconst __cache_type* __lc = __uc(__loc);\n \tconst _CharT* __lit = __lc->_M_atoms_out;\n+\tconst ios_base::fmtflags __flags = __io.flags();\n \n \t// Long enough to hold hex, dec, and octal representations.\n-\tconst int __ilen = 4 * sizeof(_ValueT);\n+\tconst int __ilen = 5 * sizeof(_ValueT);\n \t_CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n \t\t\t\t\t\t\t     * __ilen));\n \n \t// [22.2.2.2.2] Stage 1, numeric conversion to character.\n \t// Result is returned right-justified in the buffer.\n-\tint __len;\n-\t__len = __int_to_char(__cs + __ilen, __v, __lit, __io.flags());\n+\tint __len = __int_to_char(__cs + __ilen, __v, __lit, __flags);\n \t__cs += __ilen - __len;\n \n \t// Add grouping, if necessary.\n \tif (__lc->_M_use_grouping)\n \t  {\n-\t    // Grouping can add (almost) as many separators as the\n-\t    // number of digits, but no more.\n+\t    // Grouping can add (almost) as many separators as the number\n+\t    // of digits + space is reserved for numeric base or sign.\n \t    _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n-\t\t\t\t\t\t\t\t  * __len * 2));\n+\t\t\t\t\t\t\t\t  * (__len + 1)\n+\t\t\t\t\t\t\t\t  * 2));\n \t    _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,\n-\t\t\t __lc->_M_thousands_sep, __io, __cs2, __cs, __len);\n-\t    __cs = __cs2;\n+\t\t\t __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);\n+\t    __cs = __cs2 + 2;\n+\t  }\n+\n+\t// Complete Stage 1, prepend numeric base or sign.\n+\tconst ios_base::fmtflags __basefield = __flags & ios_base::basefield;\n+\tif (__builtin_expect(__basefield != ios_base::oct\n+\t\t\t     && __basefield != ios_base::hex, true))\n+\t  {\n+\t    // Decimal.\n+\t    if (__v > 0)\n+\t      {\n+\t\tif (__flags & ios_base::showpos\n+\t\t    && numeric_limits<_ValueT>::is_signed)\n+\t\t  *--__cs = __lit[__num_base::_S_oplus], ++__len;\n+\t      }\n+\t    else if (__v)\n+\t      *--__cs = __lit[__num_base::_S_ominus], ++__len;\n+\t  }\n+\telse if (__basefield == ios_base::oct)\n+\t  {\n+\t    // Octal.\n+\t    if (__flags & ios_base::showbase && __v)\n+\t      *--__cs = __lit[__num_base::_S_odigits], ++__len;\n+\t  }\n+\telse\n+\t  {\n+\t    // Hex.\n+\t    if (__flags & ios_base::showbase && __v)\n+\t      {\n+\t\t// 'x' or 'X'\n+\t\tconst bool __uppercase = __flags & ios_base::uppercase;\n+\t\t*--__cs = __lit[__num_base::_S_ox + __uppercase];\n+\t\t// '0'\n+\t\t*--__cs = __lit[__num_base::_S_odigits];\n+\t\t__len += 2;\n+\t      }\n \t  }\n \n \t// Pad.\n@@ -1137,53 +1125,65 @@ namespace std\n \t\t\t\t      _S_get_c_locale(), __prec);\n #endif\n \n-      // [22.2.2.2.2] Stage 2, convert to char_type, using correct\n-      // numpunct.decimal_point() values for '.' and adding grouping.\n-      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n-\n-      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n-\t\t\t\t\t\t\t   * __len));\n-      __ctype.widen(__cs, __cs + __len, __ws);\n-\n-      // Replace decimal point.\n-      const _CharT __cdec = __ctype.widen('.');\n-      const _CharT __dec = __lc->_M_decimal_point;\n-      const _CharT* __p = char_traits<_CharT>::find(__ws, __len, __cdec);\n-      if (__p)\n-\t__ws[__p - __ws] = __dec;\n-\n-      // Add grouping, if necessary.\n-      // N.B. Make sure to not group things like 2e20, i.e., no decimal\n-      // point, scientific notation.\n-      if (__lc->_M_use_grouping\n-\t  && (__p || __len < 3 || (__cs[1] != 'e' && __cs[2] != 'e'\n-\t\t\t\t   && __cs[1] != 'E' && __cs[2] != 'E')))\n-\t{\n-\t  // Grouping can add (almost) as many separators as the\n-\t  // number of digits, but no more.\n-\t  _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n-\t\t\t\t\t\t\t\t* __len * 2));\n-\t  _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,\n-\t\t\t __lc->_M_thousands_sep, __p, __ws2, __ws, __len);\n-\t  __ws = __ws2;\n-\t}\n-\n-      // Pad.\n-      const streamsize __w = __io.width();\n-      if (__w > static_cast<streamsize>(__len))\n-\t{\n-\t  _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n-\t\t\t\t\t\t\t\t* __w));\n-\t  _M_pad(__fill, __w, __io, __ws3, __ws, __len);\n-\t  __ws = __ws3;\n-\t}\n-      __io.width(0);\n+\t// [22.2.2.2.2] Stage 2, convert to char_type, using correct\n+\t// numpunct.decimal_point() values for '.' and adding grouping.\n+\tconst ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n+\t\n+\t_CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n+\t\t\t\t\t\t\t     * __len));\n+\t__ctype.widen(__cs, __cs + __len, __ws);\n+\t\n+\t// Replace decimal point.\n+\tconst _CharT __cdec = __ctype.widen('.');\n+\tconst _CharT __dec = __lc->_M_decimal_point;\n+\tconst _CharT* __p = char_traits<_CharT>::find(__ws, __len, __cdec);\n+\tif (__p)\n+\t  __ws[__p - __ws] = __dec;\n+\t\n+\t// Add grouping, if necessary.\n+\t// N.B. Make sure to not group things like 2e20, i.e., no decimal\n+\t// point, scientific notation.\n+\tif (__lc->_M_use_grouping\n+\t    && (__p || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'\n+\t\t\t\t     && __cs[1] >= '0' && __cs[2] >= '0')))\n+\t  {\n+\t    // Grouping can add (almost) as many separators as the\n+\t    // number of digits, but no more.\n+\t    _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n+\t\t\t\t\t\t\t\t  * __len * 2));\n+\t    \n+\t    streamsize __off = 0;\n+\t    if (__cs[0] == '-' || __cs[0] == '+')\n+\t      {\n+\t\t__off = 1;\n+\t\t__ws2[0] = __ws[0];\n+\t\t__len -= 1;\n+\t      }\n+\t    \n+\t    _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,\n+\t\t\t   __lc->_M_thousands_sep, __p, __ws2 + __off,\n+\t\t\t   __ws + __off, __len);\n+\t    __len += __off;\n+\t    \n+\t    __ws = __ws2;\n+\t  }\n \n-      // [22.2.2.2.2] Stage 4.\n-      // Write resulting, fully-formatted string to output iterator.\n-      return std::__write(__s, __ws, __len);\n+\t// Pad.\n+\tconst streamsize __w = __io.width();\n+\tif (__w > static_cast<streamsize>(__len))\n+\t  {\n+\t    _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n+\t\t\t\t\t\t\t\t  * __w));\n+\t    _M_pad(__fill, __w, __io, __ws3, __ws, __len);\n+\t    __ws = __ws3;\n+\t  }\n+\t__io.width(0);\n+\t\n+\t// [22.2.2.2.2] Stage 4.\n+\t// Write resulting, fully-formatted string to output iterator.\n+\treturn std::__write(__s, __ws, __len);\n       }\n-\n+  \n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::"}, {"sha": "a90160c1cffae791b1110dbcd19d3304c0ce3a46", "filename": "libstdc++-v3/testsuite/22_locale/num_put/put/char/20914.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/101c5bc507e0067fe0c97a2eefd0192d5092b0d0/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_put%2Fput%2Fchar%2F20914.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/101c5bc507e0067fe0c97a2eefd0192d5092b0d0/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_put%2Fput%2Fchar%2F20914.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_put%2Fput%2Fchar%2F20914.cc?ref=101c5bc507e0067fe0c97a2eefd0192d5092b0d0", "patch": "@@ -0,0 +1,79 @@\n+// 2005-04-17  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.2.2.1  num_put members\n+\n+#include <locale>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/20914\n+void test01()\n+{\n+  using namespace std;\n+  bool test __attribute__((unused)) = true;\n+\n+  // A locale that expects grouping.\n+  locale loc_de = __gnu_test::try_named_locale(\"de_DE\");\n+\n+  const string empty;\n+  string result;\n+\n+  ostringstream oss;\n+  oss.imbue(loc_de);\n+  const num_put<char>& np = use_facet<num_put<char> >(oss.getloc()); \n+\n+  long l0 = -300000;\n+  long l1 = 300;\n+  double d0 = -300000;\n+  double d1 = 300;\n+\n+  oss.str(empty);\n+  oss.clear();\n+  np.put(oss.rdbuf(), oss, '*', l0);\n+  result = oss.str();\n+  VERIFY( result == \"-300.000\" );\n+\n+  oss.str(empty);\n+  oss.clear();\n+  np.put(oss.rdbuf(), oss, '*', d0);\n+  result = oss.str();\n+  VERIFY( result == \"-300.000\" );\n+\n+  oss.str(empty);\n+  oss.clear();\n+  oss.setf(ios::showpos);\n+  np.put(oss.rdbuf(), oss, '*', l1);\n+  result = oss.str();\n+  VERIFY( result == \"+300\" );\n+\n+  oss.str(empty);\n+  oss.clear();\n+  oss.setf(ios::showpos);\n+  np.put(oss.rdbuf(), oss, '*', d1);\n+  result = oss.str();\n+  VERIFY( result == \"+300\" );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "29dc16cd8465bb2a381d775636a6e21522e8cce9", "filename": "libstdc++-v3/testsuite/22_locale/num_put/put/wchar_t/20914.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/101c5bc507e0067fe0c97a2eefd0192d5092b0d0/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_put%2Fput%2Fwchar_t%2F20914.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/101c5bc507e0067fe0c97a2eefd0192d5092b0d0/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_put%2Fput%2Fwchar_t%2F20914.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_put%2Fput%2Fwchar_t%2F20914.cc?ref=101c5bc507e0067fe0c97a2eefd0192d5092b0d0", "patch": "@@ -0,0 +1,79 @@\n+// 2005-04-17  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.2.2.1  num_put members\n+\n+#include <locale>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/20914\n+void test01()\n+{\n+  using namespace std;\n+  bool test __attribute__((unused)) = true;\n+\n+  // A locale that expects grouping.\n+  locale loc_de = __gnu_test::try_named_locale(\"de_DE\");\n+\n+  const wstring empty;\n+  wstring result;\n+\n+  wostringstream oss;\n+  oss.imbue(loc_de);\n+  const num_put<wchar_t>& np = use_facet<num_put<wchar_t> >(oss.getloc()); \n+\n+  long l0 = -300000;\n+  long l1 = 300;\n+  double d0 = -300000;\n+  double d1 = 300;\n+\n+  oss.str(empty);\n+  oss.clear();\n+  np.put(oss.rdbuf(), oss, L'*', l0);\n+  result = oss.str();\n+  VERIFY( result == L\"-300.000\" );\n+\n+  oss.str(empty);\n+  oss.clear();\n+  np.put(oss.rdbuf(), oss, L'*', d0);\n+  result = oss.str();\n+  VERIFY( result == L\"-300.000\" );\n+\n+  oss.str(empty);\n+  oss.clear();\n+  oss.setf(ios::showpos);\n+  np.put(oss.rdbuf(), oss, L'*', l1);\n+  result = oss.str();\n+  VERIFY( result == L\"+300\" );\n+\n+  oss.str(empty);\n+  oss.clear();\n+  oss.setf(ios::showpos);\n+  np.put(oss.rdbuf(), oss, L'*', d1);\n+  result = oss.str();\n+  VERIFY( result == L\"+300\" );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}