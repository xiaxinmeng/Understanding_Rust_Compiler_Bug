{"sha": "7a37fa90703f62301130a3e1ef7ad4fade1bd786", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2EzN2ZhOTA3MDNmNjIzMDExMzBhM2UxZWY3YWQ0ZmFkZTFiZDc4Ng==", "commit": {"author": {"name": "Mikhail Maltsev", "email": "maltsevm@gmail.com", "date": "2015-05-15T18:02:50Z"}, "committer": {"name": "Mikhail Maltsev", "email": "miyuki@gcc.gnu.org", "date": "2015-05-15T18:02:50Z"}, "message": "re PR c/48956 (-Wconversion should warn when a complex value is assigned to a real result)\n\nPR c/48956\n\ngcc/c-family/\n* c-common.c (int_safely_convertible_to_real_p): Define.\n(unsafe_conversion_p): Check conversions involving complex types.\n(conversion_warning): Add new warning message for conversions which\ndiscard imaginary component.\n* c-common.h: (enum conversion_safety): Add new enumerator for such\nconversions.\n\ngcc/testsuite/\n* gcc.dg/Wconversion-complex-c99.c: New test.\n* gcc.dg/Wconversion-complex-gnu.c: New test.\n\nFrom-SVN: r223223", "tree": {"sha": "b968572ca494984649ee737b7d8ba1f7d14c5580", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b968572ca494984649ee737b7d8ba1f7d14c5580"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a37fa90703f62301130a3e1ef7ad4fade1bd786", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a37fa90703f62301130a3e1ef7ad4fade1bd786", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a37fa90703f62301130a3e1ef7ad4fade1bd786", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a37fa90703f62301130a3e1ef7ad4fade1bd786/comments", "author": {"login": "miyuki", "id": 4668268, "node_id": "MDQ6VXNlcjQ2NjgyNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/4668268?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miyuki", "html_url": "https://github.com/miyuki", "followers_url": "https://api.github.com/users/miyuki/followers", "following_url": "https://api.github.com/users/miyuki/following{/other_user}", "gists_url": "https://api.github.com/users/miyuki/gists{/gist_id}", "starred_url": "https://api.github.com/users/miyuki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miyuki/subscriptions", "organizations_url": "https://api.github.com/users/miyuki/orgs", "repos_url": "https://api.github.com/users/miyuki/repos", "events_url": "https://api.github.com/users/miyuki/events{/privacy}", "received_events_url": "https://api.github.com/users/miyuki/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bc4315fbb0075e29d9a246bf73ff4c56ccf8fa6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc4315fbb0075e29d9a246bf73ff4c56ccf8fa6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc4315fbb0075e29d9a246bf73ff4c56ccf8fa6b"}], "stats": {"total": 469, "additions": 446, "deletions": 23}, "files": [{"sha": "199ba43de4f863d499a0a096fe6c8dccbf436f14", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a37fa90703f62301130a3e1ef7ad4fade1bd786/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a37fa90703f62301130a3e1ef7ad4fade1bd786/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=7a37fa90703f62301130a3e1ef7ad4fade1bd786", "patch": "@@ -1,3 +1,13 @@\n+2015-05-15  Mikhail Maltsev  <maltsevm@gmail.com>\n+\n+\tPR c/48956\n+\t* c-common.c (int_safely_convertible_to_real_p): Define.\n+\t(unsafe_conversion_p): Check conversions involving complex types.\n+\t(conversion_warning): Add new warning message for conversions which\n+\tdiscard imaginary component.\n+\t* c-common.h: (enum conversion_safety): Add new enumerator for such\n+\tconversions.\n+\n 2015-05-14  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/66066"}, {"sha": "8c7fdd2399113ed011e271a883a63e0e448768e5", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 149, "deletions": 14, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a37fa90703f62301130a3e1ef7ad4fade1bd786/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a37fa90703f62301130a3e1ef7ad4fade1bd786/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=7a37fa90703f62301130a3e1ef7ad4fade1bd786", "patch": "@@ -2707,17 +2707,42 @@ shorten_binary_op (tree result_type, tree op0, tree op1, bool bitwise)\n   return result_type;\n }\n \n-/* Checks if expression EXPR of real/integer type cannot be converted\n-   to the real/integer type TYPE. Function returns non-zero when:\n+/* Returns true iff any integer value of type FROM_TYPE can be represented as\n+   real of type TO_TYPE.  This is a helper function for unsafe_conversion_p.  */\n+\n+static bool\n+int_safely_convertible_to_real_p (const_tree from_type, const_tree to_type)\n+{\n+  tree type_low_bound = TYPE_MIN_VALUE (from_type);\n+  tree type_high_bound = TYPE_MAX_VALUE (from_type);\n+  REAL_VALUE_TYPE real_low_bound =\n+\t  real_value_from_int_cst (0, type_low_bound);\n+  REAL_VALUE_TYPE real_high_bound =\n+\t  real_value_from_int_cst (0, type_high_bound);\n+\n+  return exact_real_truncate (TYPE_MODE (to_type), &real_low_bound)\n+\t && exact_real_truncate (TYPE_MODE (to_type), &real_high_bound);\n+}\n+\n+/* Checks if expression EXPR of complex/real/integer type cannot be converted\n+   to the complex/real/integer type TYPE.  Function returns non-zero when:\n \t* EXPR is a constant which cannot be exactly converted to TYPE.\n \t* EXPR is not a constant and size of EXPR's type > than size of TYPE,\n-\t  for EXPR type and TYPE being both integers or both real.\n+\t  for EXPR type and TYPE being both integers or both real, or both\n+\t  complex.\n+\t* EXPR is not a constant of complex type and TYPE is a real or\n+\t  an integer.\n \t* EXPR is not a constant of real type and TYPE is an integer.\n \t* EXPR is not a constant of integer type which cannot be\n \t  exactly converted to real type.\n+\n    Function allows conversions between types of different signedness and\n    can return SAFE_CONVERSION (zero) in that case.  Function can produce\n-   signedness warnings if PRODUCE_WARNS is true.  */\n+   signedness warnings if PRODUCE_WARNS is true.\n+\n+   Function allows conversions from complex constants to non-complex types,\n+   provided that imaginary part is zero and real part can be safely converted\n+   to TYPE.  */\n \n enum conversion_safety\n unsafe_conversion_p (location_t loc, tree type, tree expr, bool produce_warns)\n@@ -2728,6 +2753,11 @@ unsafe_conversion_p (location_t loc, tree type, tree expr, bool produce_warns)\n \n   if (TREE_CODE (expr) == REAL_CST || TREE_CODE (expr) == INTEGER_CST)\n     {\n+      /* If type is complex, we are interested in compatibility with\n+\t underlying type.  */\n+      if (TREE_CODE (type) == COMPLEX_TYPE)\n+\t  type = TREE_TYPE (type);\n+\n       /* Warn for real constant that is not an exact integer converted\n \t to integer type.  */\n       if (TREE_CODE (expr_type) == REAL_TYPE\n@@ -2777,6 +2807,63 @@ unsafe_conversion_p (location_t loc, tree type, tree expr, bool produce_warns)\n \t    }\n \t}\n     }\n+\n+  else if (TREE_CODE (expr) == COMPLEX_CST)\n+    {\n+      tree imag_part = TREE_IMAGPART (expr);\n+      /* Conversion from complex constant with zero imaginary part,\n+\t perform check for conversion of real part.  */\n+      if ((TREE_CODE (imag_part) == REAL_CST\n+\t   && real_zerop (imag_part))\n+\t  || (TREE_CODE (imag_part) == INTEGER_CST\n+\t      && integer_zerop (imag_part)))\n+\t/* Note: in this branch we use recursive call to unsafe_conversion_p\n+\t   with different type of EXPR, but it is still safe, because when EXPR\n+\t   is a constant, it's type is not used in text of generated warnings\n+\t   (otherwise they could sound misleading).  */\n+\treturn unsafe_conversion_p (loc, type, TREE_REALPART (expr),\n+\t\t\t\t    produce_warns);\n+      /* Conversion from complex constant with non-zero imaginary part.  */\n+      else\n+\t{\n+\t  /* Conversion to complex type.\n+\t     Perform checks for both real and imaginary parts.  */\n+\t  if (TREE_CODE (type) == COMPLEX_TYPE)\n+\t    {\n+\t      /* Unfortunately, produce_warns must be false in two subsequent\n+\t\t calls of unsafe_conversion_p, because otherwise we could\n+\t\t produce strange \"double\" warnings, if both real and imaginary\n+\t\t parts have conversion problems related to signedness.\n+\n+\t\t For example:\n+\t\t int32_t _Complex a = 0x80000000 + 0x80000000i;\n+\n+\t\t Possible solution: add a separate function for checking\n+\t\t constants and combine result of two calls appropriately.  */\n+\t      enum conversion_safety re_safety =\n+\t\t  unsafe_conversion_p (loc, type, TREE_REALPART (expr), false);\n+\t      enum conversion_safety im_safety =\n+\t\t  unsafe_conversion_p (loc, type, imag_part, false);\n+\n+\t      /* Merge the results into appropriate single warning.  */\n+\n+\t      /* Note: this case includes SAFE_CONVERSION, i.e. success.  */\n+\t      if (re_safety == im_safety)\n+\t\tgive_warning = re_safety;\n+\t      else if (!re_safety && im_safety)\n+\t\tgive_warning = im_safety;\n+\t      else if (re_safety && !im_safety)\n+\t\tgive_warning = re_safety;\n+\t      else\n+\t\tgive_warning = UNSAFE_OTHER;\n+\t    }\n+\t  /* Warn about conversion from complex to real or integer type.  */\n+\t  else\n+\t    give_warning = UNSAFE_IMAGINARY;\n+\t}\n+    }\n+\n+  /* Checks for remaining case: EXPR is not constant.  */\n   else\n     {\n       /* Warn for real types converted to integer types.  */\n@@ -2856,20 +2943,11 @@ unsafe_conversion_p (location_t loc, tree type, tree expr, bool produce_warns)\n       else if (TREE_CODE (expr_type) == INTEGER_TYPE\n \t       && TREE_CODE (type) == REAL_TYPE)\n \t{\n-\t  tree type_low_bound, type_high_bound;\n-\t  REAL_VALUE_TYPE real_low_bound, real_high_bound;\n-\n \t  /* Don't warn about char y = 0xff; float x = (int) y;  */\n \t  expr = get_unwidened (expr, 0);\n \t  expr_type = TREE_TYPE (expr);\n \n-\t  type_low_bound = TYPE_MIN_VALUE (expr_type);\n-\t  type_high_bound = TYPE_MAX_VALUE (expr_type);\n-\t  real_low_bound = real_value_from_int_cst (0, type_low_bound);\n-\t  real_high_bound = real_value_from_int_cst (0, type_high_bound);\n-\n-\t  if (!exact_real_truncate (TYPE_MODE (type), &real_low_bound)\n-\t      || !exact_real_truncate (TYPE_MODE (type), &real_high_bound))\n+\t  if (!int_safely_convertible_to_real_p (expr_type, type))\n \t    give_warning = UNSAFE_OTHER;\n \t}\n \n@@ -2878,6 +2956,58 @@ unsafe_conversion_p (location_t loc, tree type, tree expr, bool produce_warns)\n \t       && TREE_CODE (type) == REAL_TYPE\n \t       && TYPE_PRECISION (type) < TYPE_PRECISION (expr_type))\n \tgive_warning = UNSAFE_REAL;\n+\n+      /* Check conversion between two complex types.  */\n+      else if (TREE_CODE (expr_type) == COMPLEX_TYPE\n+\t       && TREE_CODE (type) == COMPLEX_TYPE)\n+\t{\n+\t  /* Extract underlying types (i.e., type of real and imaginary\n+\t     parts) of expr_type and type.  */\n+\t  tree from_type = TREE_TYPE (expr_type);\n+\t  tree to_type = TREE_TYPE (type);\n+\n+\t  /* Warn for real types converted to integer types.  */\n+\t  if (TREE_CODE (from_type) == REAL_TYPE\n+\t      && TREE_CODE (to_type) == INTEGER_TYPE)\n+\t    give_warning = UNSAFE_REAL;\n+\n+\t  /* Warn for real types converted to smaller real types.  */\n+\t  else if (TREE_CODE (from_type) == REAL_TYPE\n+\t\t   && TREE_CODE (to_type) == REAL_TYPE\n+\t\t   && TYPE_PRECISION (to_type) < TYPE_PRECISION (from_type))\n+\t    give_warning = UNSAFE_REAL;\n+\n+\t  /* Check conversion for complex integer types.  Here implementation\n+\t     is simpler than for real-domain integers because it does not\n+\t     involve sophisticated cases, such as bitmasks, casts, etc.  */\n+\t  else if (TREE_CODE (from_type) == INTEGER_TYPE\n+\t\t   && TREE_CODE (to_type) == INTEGER_TYPE)\n+\t    {\n+\t      /* Warn for integer types converted to smaller integer types.  */\n+\t      if (TYPE_PRECISION (to_type) < TYPE_PRECISION (from_type))\n+\t\tgive_warning = UNSAFE_OTHER;\n+\n+\t      /* Check for different signedness, see case for real-domain\n+\t\t integers (above) for a more detailed comment.  */\n+\t      else if (((TYPE_PRECISION (to_type) == TYPE_PRECISION (from_type)\n+\t\t    && TYPE_UNSIGNED (to_type) != TYPE_UNSIGNED (from_type))\n+\t\t    || (TYPE_UNSIGNED (to_type) && !TYPE_UNSIGNED (from_type)))\n+\t\t    && produce_warns)\n+\t\twarning_at (loc, OPT_Wsign_conversion,\n+\t\t\t\"conversion to %qT from %qT \"\n+\t\t\t\"may change the sign of the result\",\n+\t\t\ttype, expr_type);\n+\t    }\n+\t  else if (TREE_CODE (from_type) == INTEGER_TYPE\n+\t\t   && TREE_CODE (to_type) == REAL_TYPE\n+\t\t   && !int_safely_convertible_to_real_p (from_type, to_type))\n+\t    give_warning = UNSAFE_OTHER;\n+\t}\n+\n+      /* Warn for complex types converted to real or integer types.  */\n+      else if (TREE_CODE (expr_type) == COMPLEX_TYPE\n+\t       && TREE_CODE (type) != COMPLEX_TYPE)\n+\tgive_warning = UNSAFE_IMAGINARY;\n     }\n \n   return give_warning;\n@@ -2927,6 +3057,7 @@ conversion_warning (location_t loc, tree type, tree expr)\n \n     case REAL_CST:\n     case INTEGER_CST:\n+    case COMPLEX_CST:\n       conversion_kind = unsafe_conversion_p (loc, type, expr, true);\n       if (conversion_kind == UNSAFE_REAL)\n \twarning_at (loc, OPT_Wfloat_conversion,\n@@ -2956,6 +3087,10 @@ conversion_warning (location_t loc, tree type, tree expr)\n \twarning_at (loc, OPT_Wfloat_conversion,\n \t\t    \"conversion to %qT from %qT may alter its value\",\n \t\t    type, expr_type);\n+      else if (conversion_kind == UNSAFE_IMAGINARY)\n+\twarning_at (loc, OPT_Wconversion,\n+\t\t    \"conversion to %qT from %qT discards imaginary component\",\n+\t\t    type, expr_type);\n       else if (conversion_kind)\n \twarning_at (loc, OPT_Wconversion,\n \t\t    \"conversion to %qT from %qT may alter its value\","}, {"sha": "62eac9f74b60c460aaaa3f9535c8dddfaf35f40f", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a37fa90703f62301130a3e1ef7ad4fade1bd786/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a37fa90703f62301130a3e1ef7ad4fade1bd786/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=7a37fa90703f62301130a3e1ef7ad4fade1bd786", "patch": "@@ -728,15 +728,22 @@ struct visibility_flags\n   unsigned inlines_hidden : 1;\t/* True when -finlineshidden in effect.  */\n };\n \n-/* These enumerators are possible types of unsafe conversions.\n-   SAFE_CONVERSION The conversion is safe\n-   UNSAFE_OTHER Another type of conversion with problems\n-   UNSAFE_SIGN Conversion between signed and unsigned integers\n-    which are all warned about immediately, so this is unused\n-   UNSAFE_REAL Conversions that reduce the precision of reals\n-    including conversions from reals to integers\n- */\n-enum conversion_safety { SAFE_CONVERSION = 0, UNSAFE_OTHER, UNSAFE_SIGN, UNSAFE_REAL };\n+/* These enumerators are possible types of unsafe conversions.  */\n+enum conversion_safety {\n+  /* The conversion is safe.  */\n+  SAFE_CONVERSION = 0,\n+  /* Another type of conversion with problems.  */\n+  UNSAFE_OTHER,\n+  /* Conversion between signed and unsigned integers\n+     which are all warned about immediately, so this is unused.  */\n+  UNSAFE_SIGN,\n+  /* Conversions that reduce the precision of reals including conversions\n+     from reals to integers.  */\n+  UNSAFE_REAL,\n+  /* Conversions from complex to reals or integers, that discard imaginary\n+     component.  */\n+  UNSAFE_IMAGINARY\n+};\n \n /* Global visibility options.  */\n extern struct visibility_flags visibility_options;"}, {"sha": "cdd1c2885d8be29c5cd5c556011eaaf575b4dd70", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a37fa90703f62301130a3e1ef7ad4fade1bd786/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a37fa90703f62301130a3e1ef7ad4fade1bd786/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7a37fa90703f62301130a3e1ef7ad4fade1bd786", "patch": "@@ -1,3 +1,9 @@\n+2015-05-15  Mikhail Maltsev  <maltsevm@gmail.com>\n+\n+\tPR c/48956\n+\t* gcc.dg/Wconversion-complex-c99.c: New test.\n+\t* gcc.dg/Wconversion-complex-gnu.c: New test.\n+\n 2015-05-15  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR tree-optimization/64454"}, {"sha": "0e6c39022f495f1702ab546d85a11cd36c86dac1", "filename": "gcc/testsuite/gcc.dg/Wconversion-complex-c99.c", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a37fa90703f62301130a3e1ef7ad4fade1bd786/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-complex-c99.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a37fa90703f62301130a3e1ef7ad4fade1bd786/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-complex-c99.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-complex-c99.c?ref=7a37fa90703f62301130a3e1ef7ad4fade1bd786", "patch": "@@ -0,0 +1,138 @@\n+/* PR c/48956: Test for diagnostics for implicit conversions from complex\n+   to real types and narrowing conversions of complex types.  */\n+\n+/* Architecture restrictions taken from Wconversion-real-integer.c.\n+   Likewise, the magic value 16777217.  */\n+\n+/* { dg-do compile } */\n+/* { dg-skip-if \"doubles are floats,ints are 16bits\" { \"avr-*-*\" } { \"*\" } { \"\" } } */\n+/* { dg-options \" -std=c99 -pedantic -Wconversion \" } */\n+/* { dg-require-effective-target int32plus } */\n+/* { dg-require-effective-target double64plus } */\n+\n+/* A number which does not fit into float.  */\n+#define MAX_FLOAT_PLUS 16777217.\n+\n+/* Other types could be added, but that won't affect test coverage.  */\n+void ffloatc (float _Complex);\n+void fdoublec (double _Complex);\n+\n+void ffloat (float);\n+void fdouble (double);\n+\n+void fsi (int);\n+void fui (unsigned);\n+\n+float _Complex vfloatc;\n+double _Complex vdoublec;\n+\n+float vfloat;\n+double vdouble;\n+\n+int vsi;\n+unsigned vui;\n+\n+/* Check implicit conversions of complex values to reals.  */\n+void\n+var_complex_to_real (void)\n+{\n+  float _Complex floatc = 0.;\n+  double _Complex doublec = 0.;\n+\n+  ffloatc (floatc);\n+  fdoublec (doublec);\n+  vfloatc = floatc;\n+  vdoublec = doublec;\n+\n+  ffloat (floatc); /* { dg-warning \"conversion\" } */\n+  fdouble (floatc); /* { dg-warning \"conversion\" } */\n+  vfloat = floatc; /* { dg-warning \"conversion\" } */\n+  vdouble = floatc; /* { dg-warning \"conversion\" } */\n+\n+  ffloat (doublec); /* { dg-warning \"conversion\" } */\n+  fdouble (doublec); /* { dg-warning \"conversion\" } */\n+  vfloat = doublec; /* { dg-warning \"conversion\" } */\n+  vdouble = doublec; /* { dg-warning \"conversion\" } */\n+}\n+\n+/* Check implicit narrowing conversions of complex values.  */\n+void\n+var_complex_narrowing (void)\n+{\n+  float _Complex floatc = 0.;\n+  double _Complex doublec = 0.;\n+\n+  vdoublec = floatc;\n+  vfloatc = doublec; /* { dg-warning \"float-conversion\" } */\n+\n+  fdoublec (floatc);\n+  ffloatc (doublec); /* { dg-warning \"float-conversion\" } */\n+}\n+\n+/* Check implicit conversions of complex values to integers.  */\n+void\n+var_complex_to_int (void)\n+{\n+  float _Complex floatc = 0.;\n+  double _Complex doublec = 0.;\n+\n+  fsi (floatc); /* { dg-warning \"conversion\" } */\n+  fui (floatc); /* { dg-warning \"conversion\" } */\n+  vsi = floatc; /* { dg-warning \"conversion\" } */\n+  vui = floatc; /* { dg-warning \"conversion\" } */\n+\n+  fsi (doublec); /* { dg-warning \"conversion\" } */\n+  fui (doublec); /* { dg-warning \"conversion\" } */\n+  vsi = doublec; /* { dg-warning \"conversion\" } */\n+  vui = doublec; /* { dg-warning \"conversion\" } */\n+}\n+\n+/* Check implicit conversion of constant complex values to floats.  */\n+void\n+const_complex_to_real (void)\n+{\n+  ffloat (__builtin_complex (0., 1.)); /* { dg-warning \"conversion\" } */\n+  fdouble (__builtin_complex (0., 1.)); /* { dg-warning \"conversion\" } */\n+\n+  vfloat = __builtin_complex (0., 1.); /* { dg-warning \"conversion\" } */\n+  vdouble = __builtin_complex (0., 1.); /* { dg-warning \"conversion\" } */\n+\n+  vfloat = __builtin_complex (1., 0.) + __builtin_complex (1., 0.);\n+  vdouble = __builtin_complex (0., 0.) * __builtin_complex (1., 1.);\n+  ffloat (__builtin_complex (1., 0.) + __builtin_complex (1., 0.));\n+  fdouble (__builtin_complex (1., 0.) + __builtin_complex (1., 0.));\n+\n+  vfloat = __builtin_complex (MAX_FLOAT_PLUS, 0.); /* { dg-warning \"float-conversion\" } */\n+  ffloat (__builtin_complex (MAX_FLOAT_PLUS, 0.)); /* { dg-warning \"float-conversion\" } */\n+}\n+\n+/* Check implicit conversion of constant complex values to integers.  */\n+void\n+const_complex_to_int (void)\n+{\n+  vsi = __builtin_complex (-1., 0.);\n+  vui = __builtin_complex (1., 0.);\n+  fsi (__builtin_complex (-1., 0.));\n+  fui (__builtin_complex (1., 0.));\n+\n+  vui = __builtin_complex (-1., 0.); /* { dg-warning \"overflow\" } */\n+  fui (__builtin_complex (-1., 0.)); /* { dg-warning \"overflow\" } */\n+\n+  vsi = __builtin_complex (0.5, 0.); /* { dg-warning \"float-conversion\" } */\n+  fui (__builtin_complex (0.5, 0.)); /* { dg-warning \"float-conversion\" } */\n+\n+  vsi = __builtin_complex (-0.5, 0.); /* { dg-warning \"float-conversion\" } */\n+  fui (__builtin_complex (-0.5, 0.)); /* { dg-warning \"float-conversion\" } */\n+}\n+\n+/* Check implicit narrowing conversion of constant complex values to.  */\n+void\n+const_complex_narrowing (void)\n+{\n+  ffloatc (__builtin_complex (-100., 100.));\n+\n+  ffloatc (__builtin_complex (MAX_FLOAT_PLUS, 0.)); /* { dg-warning \"float-conversion\" } */\n+  ffloatc (__builtin_complex (0., MAX_FLOAT_PLUS)); /* { dg-warning \"float-conversion\" } */\n+  ffloatc (__builtin_complex (MAX_FLOAT_PLUS, MAX_FLOAT_PLUS)); /* { dg-warning \"float-conversion\" } */\n+}\n+"}, {"sha": "3839a39bce42c35009bb5bd1041ecfbf653081ec", "filename": "gcc/testsuite/gcc.dg/Wconversion-complex-gnu.c", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a37fa90703f62301130a3e1ef7ad4fade1bd786/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-complex-gnu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a37fa90703f62301130a3e1ef7ad4fade1bd786/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-complex-gnu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-complex-gnu.c?ref=7a37fa90703f62301130a3e1ef7ad4fade1bd786", "patch": "@@ -0,0 +1,127 @@\n+/* PR c/48956: Test for diagnostics for implicit conversions involving complex\n+   types.  See also Wconversion-complex-c99.c.\n+\n+   These tests cover integer complex values (which are GNU extensions).  */\n+\n+/* { dg-do compile } */\n+/* { dg-skip-if \"doubles are floats,ints are 16bits\" { \"avr-*-*\" } { \"*\" } { \"\" } } */\n+/* { dg-options \" -std=gnu99 -Wconversion \" } */\n+/* { dg-require-effective-target int32plus } */\n+/* { dg-require-effective-target double64plus } */\n+\n+#include <limits.h>\n+\n+void fsi (int);\n+void fui (unsigned);\n+void ffloat (float);\n+int vsi;\n+unsigned int vui;\n+float vfloat;\n+\n+void fsic (int _Complex);\n+void fuic (unsigned _Complex);\n+void ffloatc (float _Complex);\n+int _Complex vsic;\n+unsigned _Complex vuic;\n+float _Complex vfloatc;\n+\n+/* Check implicit conversions of float complex-domain values to integer\n+   complex-domain types.  */\n+void\n+var_float_to_int (void)\n+{\n+  double _Complex doublec = 0.;\n+\n+  fsic (doublec); /* { dg-warning \"float-conversion\" } */\n+  fuic (doublec); /* { dg-warning \"float-conversion\" } */\n+\n+  vsic = doublec; /* { dg-warning \"float-conversion\" } */\n+  vuic = doublec; /* { dg-warning \"float-conversion\" } */\n+}\n+\n+/* Check implicit conversions of integer complex-domain values to integer\n+   real-domain types.  */\n+void\n+var_complex_to_real (void)\n+{\n+  int _Complex ic = 0;\n+  unsigned _Complex uc = 0;\n+  unsigned long long _Complex ullc = 0;\n+\n+  fsic (ic);\n+  fuic (uc);\n+  vsic = ic;\n+  vuic = uc;\n+\n+  fsi (ic); /* { dg-warning \"conversion\" } */\n+  vsi = ic; /* { dg-warning \"conversion\" } */\n+  fui (uc); /* { dg-warning \"conversion\" } */\n+  vui = uc; /* { dg-warning \"conversion\" } */\n+\n+  fuic (ullc); /* { dg-warning \"conversion\" } */\n+  vuic = ullc; /* { dg-warning \"conversion\" } */\n+\n+  fui (ic); /* { dg-warning \"conversion\" } */\n+  vui = ic; /* { dg-warning \"conversion\" } */\n+}\n+\n+/* Check implicit conversions of float complex-domain constants to integer\n+   types.  */\n+void\n+const_float_to_int (void)\n+{\n+  fsic (1. - 1.i);\n+  fuic (1. + 1.i);\n+  vsic = 1. - 1.i;\n+  vuic = 1. + 1.i;\n+\n+  fsic (0.5 + 0.i); /* { dg-warning \"float-conversion\" } */\n+  vsic = 0.5 + 0.i; /* { dg-warning \"float-conversion\" } */\n+  fuic (0.5 + 0.i); /* { dg-warning \"float-conversion\" } */\n+}\n+\n+/* Check implicit conversions of integer complex-domain constants to integer\n+   types.  */\n+void\n+const_complex_int_to_real_int (void)\n+{\n+  fsi (-1 + 0i);\n+  fui (1 + 0i);\n+  vsi = -1 + 0i;\n+  vui = 1 + 0i;\n+\n+  fui (1 + 1i); /* { dg-warning \"conversion\" } */\n+  vui = 1 + 1i; /* { dg-warning \"conversion\" } */\n+\n+  fui (UINT_MAX + 1ull + 0i); /* { dg-warning \"conversion\" } */\n+  vui = UINT_MAX + 1ull + 0i; /* { dg-warning \"conversion\" } */\n+\n+  ffloat (UINT_MAX + 0i); /* { dg-warning \"float-conversion\" } */\n+  vfloat = UINT_MAX + 0i; /* { dg-warning \"float-conversion\" } */\n+}\n+\n+void\n+const_complex_int_narrowing (void)\n+{\n+  fsic (1 - 1i);\n+  fuic (1 + 1i);\n+  vsic = 1 - 1i;\n+  vuic = 1 + 1i;\n+\n+  fuic (UINT_MAX + 1ull + 1i); /* { dg-warning \"conversion\" } */\n+  fuic ((UINT_MAX + 1ull) * 1i); /* { dg-warning \"conversion\" } */\n+  fuic ((UINT_MAX + 1ull) + (UINT_MAX + 1ull) * 1i); /* { dg-warning \"conversion\" } */\n+\n+  vuic = (UINT_MAX + 1ull) * 1i; /* { dg-warning \"conversion\" } */\n+  vuic = (UINT_MAX + 1ull) + 1i; /* { dg-warning \"conversion\" } */\n+  vuic = (UINT_MAX + 1ull) + (UINT_MAX + 1ull) * 1i; /* { dg-warning \"conversion\" } */\n+\n+  ffloatc (UINT_MAX * 1i); /* { dg-warning \"float-conversion\" } */\n+  ffloatc (UINT_MAX + 1i); /* { dg-warning \"float-conversion\" } */\n+  ffloatc (UINT_MAX + UINT_MAX * 1i); /* { dg-warning \"float-conversion\" } */\n+\n+  vfloatc = UINT_MAX * 1i; /* { dg-warning \"float-conversion\" } */\n+  vfloatc = UINT_MAX + 1i; /* { dg-warning \"float-conversion\" } */\n+  vfloatc = UINT_MAX + UINT_MAX * 1i; /* { dg-warning \"float-conversion\" } */\n+}\n+"}]}