{"sha": "95ca22f405ab053a5275610e22b869f595c8e68b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVjYTIyZjQwNWFiMDUzYTUyNzU2MTBlMjJiODY5ZjU5NWM4ZTY4Yg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-09-30T10:10:02Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-09-30T10:10:02Z"}, "message": "function.c (gen_mem_addressof): If the address REG is REG_USERVAR_P make the new REG be so also.\n\n\t* function.c (gen_mem_addressof): If the address REG is\n\tREG_USERVAR_P make the new REG be so also.\n\t* loop.c (scan_loop): Apply DeMorgan's laws and add documentation\n\tin an attempt to clarify slightly.\n\nFrom-SVN: r22667", "tree": {"sha": "013f50ee70583c8416e79aa57fe911e240371d76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/013f50ee70583c8416e79aa57fe911e240371d76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95ca22f405ab053a5275610e22b869f595c8e68b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95ca22f405ab053a5275610e22b869f595c8e68b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95ca22f405ab053a5275610e22b869f595c8e68b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95ca22f405ab053a5275610e22b869f595c8e68b/comments", "author": null, "committer": null, "parents": [{"sha": "ee06cc21bf611f5e1fa1bc72ec901ac1d75ed62d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee06cc21bf611f5e1fa1bc72ec901ac1d75ed62d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee06cc21bf611f5e1fa1bc72ec901ac1d75ed62d"}], "stats": {"total": 70, "additions": 56, "deletions": 14}, "files": [{"sha": "b7d489fbc0573b06a02e6e9c7ba09d171b021d84", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95ca22f405ab053a5275610e22b869f595c8e68b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95ca22f405ab053a5275610e22b869f595c8e68b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95ca22f405ab053a5275610e22b869f595c8e68b", "patch": "@@ -1,3 +1,10 @@\n+Wed Sep 30 10:09:39 1998  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* function.c (gen_mem_addressof): If the address REG is\n+\tREG_USERVAR_P make the new REG be so also.\n+\t* loop.c (scan_loop): Apply DeMorgan's laws and add documentation\n+\tin an attempt to clarify slightly.\n+\n Wed Sep 30 09:57:40 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* expr.c (expand_expr): Handle COMPONENT_REF, BIT_FIELD_REF ARRAY_REF"}, {"sha": "54407fdb156748180f511c3badc9bda0fb8613e3", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95ca22f405ab053a5275610e22b869f595c8e68b/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95ca22f405ab053a5275610e22b869f595c8e68b/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=95ca22f405ab053a5275610e22b869f595c8e68b", "patch": "@@ -2756,9 +2756,11 @@ gen_mem_addressof (reg, decl)\n      tree decl;\n {\n   tree type = TREE_TYPE (decl);\n-\n   rtx r = gen_rtx_ADDRESSOF (Pmode, gen_reg_rtx (GET_MODE (reg)), REGNO (reg));\n   SET_ADDRESSOF_DECL (r, decl);\n+  /* If the original REG was a user-variable, then so is the REG whose\n+     address is being taken.  */\n+  REG_USERVAR_P (XEXP (r, 0)) = REG_USERVAR_P (reg);\n \n   XEXP (reg, 0) = r;\n   PUT_CODE (reg, MEM);"}, {"sha": "0a6cf059b4479f70b88ce6aba4827b100a099441", "filename": "gcc/loop.c", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95ca22f405ab053a5275610e22b869f595c8e68b/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95ca22f405ab053a5275610e22b869f595c8e68b/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=95ca22f405ab053a5275610e22b869f595c8e68b", "patch": "@@ -871,19 +871,31 @@ scan_loop (loop_start, end, unroll_p, bct_p)\n \t     We don't know its life-span, so we can't compute the benefit.  */\n \t  if (REGNO (SET_DEST (set)) >= max_reg_before_loop)\n \t    ;\n-\t  /* In order to move a register, we need to have one of three cases:\n-\t     (1) it is used only in the same basic block as the set\n-\t     (2) it is not a user variable and it is not used in the\n-\t         exit test (this can cause the variable to be used\n-\t\t before it is set just like a user-variable).\n-\t     (3) the set is guaranteed to be executed once the loop starts,\n-\t         and the reg is not used until after that.  */\n-\t  else if (! ((! maybe_never\n-\t\t       && ! loop_reg_used_before_p (set, p, loop_start,\n-\t\t\t\t\t\t    scan_start, end))\n-\t\t      || (! REG_USERVAR_P (SET_DEST (set))\n-\t\t\t  && ! REG_LOOP_TEST_P (SET_DEST (set)))\n-\t\t      || reg_in_basic_block_p (p, SET_DEST (set))))\n+\t  else if (/* The set is a user-variable or it is used in\n+\t\t      the exit test (this can cause the variable to be\n+\t\t      used before it is set just like a\n+\t\t      user-variable)...  */\n+\t\t   (REG_USERVAR_P (SET_DEST (set))\n+\t\t    || REG_LOOP_TEST_P (SET_DEST (set)))\n+\t\t   /* And the set is not guaranteed to be executed one\n+\t\t      the loop starts, or the value before the set is\n+\t\t      needed before the set occurs... */\n+\t\t   && (maybe_never\n+\t\t       || loop_reg_used_before_p (set, p, loop_start,\n+\t\t\t\t\t\t  scan_start, end))\n+\t\t   /* And the register is used in basic blocks other\n+\t\t      than the one where it is set (meaning that\n+\t\t      something after this point in the loop might\n+\t\t      depend on its value before the set).  */\n+\t\t   && !reg_in_basic_block_p (p, SET_DEST (set)))\n+\t    /* It is unsafe to move the set.  The fact that these\n+\t       three conditions are considered in conjunction means\n+\t       that we are assuming various conditions, such as:\n+\n+\t         o It's OK to move a set of a variable which was not\n+\t           created by the user and is not used in an exit test\n+\t           even if that point in the set would not be reached\n+\t\t   during execution of the loop.  */\n \t    ;\n \t  else if ((tem = invariant_p (src))\n \t\t   && (dependencies == 0"}, {"sha": "1d9246e01d7b4216c39e3eeb0e98007c83477c02", "filename": "gcc/testsuite/gcc.c-torture/execute/980929-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95ca22f405ab053a5275610e22b869f595c8e68b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F980929-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95ca22f405ab053a5275610e22b869f595c8e68b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F980929-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F980929-1.c?ref=95ca22f405ab053a5275610e22b869f595c8e68b", "patch": "@@ -0,0 +1,21 @@\n+void f(int i)\n+{\n+  if (i != 1000)\n+    abort ();\n+}\n+\n+\n+int main()\n+{\n+  int n=1000;\n+  int i;\n+\n+  f(n);\n+  for(i=0; i<1; ++i) {\n+    f(n);\n+    n=666;\n+    &n;\n+  }\n+\n+  exit (0);\n+}"}]}