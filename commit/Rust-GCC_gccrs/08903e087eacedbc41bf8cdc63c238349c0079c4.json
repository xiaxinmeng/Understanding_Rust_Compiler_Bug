{"sha": "08903e087eacedbc41bf8cdc63c238349c0079c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg5MDNlMDg3ZWFjZWRiYzQxYmY4Y2RjNjNjMjM4MzQ5YzAwNzljNA==", "commit": {"author": {"name": "Steven Bosscher", "email": "s.bosscher@student.tudelft.nl", "date": "2003-10-02T10:48:54Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2003-10-02T10:48:54Z"}, "message": "mcore.c: Convert to ISO C90 function declarations and definitions.\n\n* config/mcore/mcore.c: Convert to ISO C90 function declarations and definitions.\n* config/mcore/mcore.h: Likewise.\n* config/mcore/mcore-protos.h: Likewise.\n\nFrom-SVN: r72020", "tree": {"sha": "73317c1822ca334ac777123eb48d3ef04d80a76e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73317c1822ca334ac777123eb48d3ef04d80a76e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08903e087eacedbc41bf8cdc63c238349c0079c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08903e087eacedbc41bf8cdc63c238349c0079c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08903e087eacedbc41bf8cdc63c238349c0079c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08903e087eacedbc41bf8cdc63c238349c0079c4/comments", "author": null, "committer": null, "parents": [{"sha": "16aae3d209b6d248f12c5d064273c33bcb5e0ce2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16aae3d209b6d248f12c5d064273c33bcb5e0ce2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16aae3d209b6d248f12c5d064273c33bcb5e0ce2"}], "stats": {"total": 716, "additions": 281, "deletions": 435}, "files": [{"sha": "e04ac6a067d8294a0fc0d5abc2e37a76a6524c1e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08903e087eacedbc41bf8cdc63c238349c0079c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08903e087eacedbc41bf8cdc63c238349c0079c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08903e087eacedbc41bf8cdc63c238349c0079c4", "patch": "@@ -1,3 +1,10 @@\n+2003-10-02  Steven Bosscher <s.bosscher@student.tudelft.nl>\n+\n+\t* config/mcore/mcore.c: Convert to ISO C90 function declarations\n+\tand definitions.\n+\t* config/mcore/mcore.h: Likewise.\n+\t* config/mcore/mcore-protos.h: Likewise.\n+\n 2003-10-02  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/frv/frv.c (frv_use_dfa_pipeline_interface): New function."}, {"sha": "fedb3f8347c95dcf0347da280753e542a6654b9b", "filename": "gcc/config/mcore/mcore-protos.h", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08903e087eacedbc41bf8cdc63c238349c0079c4/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08903e087eacedbc41bf8cdc63c238349c0079c4/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h?ref=08903e087eacedbc41bf8cdc63c238349c0079c4", "patch": "@@ -1,49 +1,49 @@\n /* Prototypes for exported functions defined in mcore.c\n-   Copyright (C) 2000, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Nick Clifton (nickc@redhat.com)\n \n-This file is part of GCC.\n+   This file is part of GCC.\n \n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n \n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n \n-extern const char * mcore_output_jump_label_table\tPARAMS ((void));\n-extern void         mcore_expand_prolog          \tPARAMS ((void));\n-extern void         mcore_expand_epilog          \tPARAMS ((void));\n-extern int          mcore_const_ok_for_inline    \tPARAMS ((long));\n-extern int          mcore_num_ones               \tPARAMS ((int));\n-extern int          mcore_num_zeros              \tPARAMS ((int));\n-extern int          mcore_initial_elimination_offset\tPARAMS ((int, int));\n-extern int          mcore_byte_offset            \tPARAMS ((unsigned int));\n-extern int          mcore_halfword_offset        \tPARAMS ((unsigned int));\n-extern int          mcore_const_trick_uses_not   \tPARAMS ((long));\n-extern void         mcore_override_options       \tPARAMS ((void));\n-extern int          mcore_dllexport_name_p       \tPARAMS ((const char *));\n-extern int          mcore_dllimport_name_p       \tPARAMS ((const char *));\n-extern int          mcore_naked_function_p       \tPARAMS ((void));\n+extern const char * mcore_output_jump_label_table\t(void);\n+extern void         mcore_expand_prolog          \t(void);\n+extern void         mcore_expand_epilog          \t(void);\n+extern int          mcore_const_ok_for_inline    \t(long);\n+extern int          mcore_num_ones               \t(int);\n+extern int          mcore_num_zeros              \t(int);\n+extern int          mcore_initial_elimination_offset\t(int, int);\n+extern int          mcore_byte_offset            \t(unsigned int);\n+extern int          mcore_halfword_offset        \t(unsigned int);\n+extern int          mcore_const_trick_uses_not   \t(long);\n+extern void         mcore_override_options       \t(void);\n+extern int          mcore_dllexport_name_p       \t(const char *);\n+extern int          mcore_dllimport_name_p       \t(const char *);\n+extern int          mcore_naked_function_p       \t(void);\n \n #ifdef TREE_CODE\n #ifdef HAVE_MACHINE_MODES\n-extern int          mcore_function_arg_partial_nregs\tPARAMS ((CUMULATIVE_ARGS, enum machine_mode, tree, int));\n-extern void         mcore_setup_incoming_varargs\tPARAMS ((CUMULATIVE_ARGS, enum machine_mode, tree, int *));\n-extern int          mcore_num_arg_regs           \tPARAMS ((enum machine_mode, tree));\n-extern int          mcore_must_pass_on_stack     \tPARAMS ((enum machine_mode, tree));\n+extern int          mcore_function_arg_partial_nregs\t(CUMULATIVE_ARGS, enum machine_mode, tree, int);\n+extern void         mcore_setup_incoming_varargs\t(CUMULATIVE_ARGS, enum machine_mode, tree, int *);\n+extern int          mcore_num_arg_regs           \t(enum machine_mode, tree);\n+extern int          mcore_must_pass_on_stack     \t(enum machine_mode, tree);\n #endif /* HAVE_MACHINE_MODES */\n \n #ifdef RTX_CODE\n-extern rtx          mcore_function_value         \tPARAMS ((tree, tree));\n+extern rtx          mcore_function_value         \t(tree, tree);\n #endif /* RTX_CODE */\n #endif /* TREE_CODE */\n \n@@ -52,49 +52,49 @@ extern rtx          mcore_function_value         \tPARAMS ((tree, tree));\n extern GTY(()) rtx arch_compare_op0;\n extern GTY(()) rtx arch_compare_op1;\n \n-extern const char * mcore_output_bclri         \t\tPARAMS ((rtx, int));\n-extern const char * mcore_output_bseti         \t\tPARAMS ((rtx, int));\n-extern const char * mcore_output_cmov          \t\tPARAMS ((rtx *, int, const char *));\n-extern char *       mcore_output_call          \t\tPARAMS ((rtx *, int));\n-extern int          mcore_is_dead                \tPARAMS ((rtx, rtx));\n-extern int          mcore_expand_insv            \tPARAMS ((rtx *));\n-extern int          mcore_modify_comparison      \tPARAMS ((RTX_CODE));\n-extern void         mcore_expand_block_move      \tPARAMS ((rtx, rtx, rtx *));\n-extern const char * mcore_output_andn          \t\tPARAMS ((rtx, rtx *));\n-extern void         mcore_print_operand_address  \tPARAMS ((FILE *, rtx));\n-extern void         mcore_print_operand          \tPARAMS ((FILE *, rtx, int));\n-extern rtx          mcore_gen_compare_reg        \tPARAMS ((RTX_CODE));\n-extern int          mcore_symbolic_address_p     \tPARAMS ((rtx));\n-extern bool         mcore_r15_operand_p\t\t\tPARAMS ((rtx));\n-extern enum reg_class mcore_secondary_reload_class\tPARAMS ((enum reg_class, enum machine_mode, rtx));\n-extern enum reg_class mcore_reload_class \t\tPARAMS ((rtx, enum reg_class));\n-extern int          mcore_is_same_reg            \tPARAMS ((rtx, rtx));\n-extern int          mcore_arith_S_operand         \tPARAMS ((rtx));\n+extern const char * mcore_output_bclri         \t\t(rtx, int);\n+extern const char * mcore_output_bseti         \t\t(rtx, int);\n+extern const char * mcore_output_cmov          \t\t(rtx *, int, const char *);\n+extern char *       mcore_output_call          \t\t(rtx *, int);\n+extern int          mcore_is_dead                \t(rtx, rtx);\n+extern int          mcore_expand_insv            \t(rtx *);\n+extern int          mcore_modify_comparison      \t(RTX_CODE);\n+extern void         mcore_expand_block_move      \t(rtx, rtx, rtx *);\n+extern const char * mcore_output_andn          \t\t(rtx, rtx *);\n+extern void         mcore_print_operand_address  \t(FILE *, rtx);\n+extern void         mcore_print_operand          \t(FILE *, rtx, int);\n+extern rtx          mcore_gen_compare_reg        \t(RTX_CODE);\n+extern int          mcore_symbolic_address_p     \t(rtx);\n+extern bool         mcore_r15_operand_p\t\t\t(rtx);\n+extern enum reg_class mcore_secondary_reload_class\t(enum reg_class, enum machine_mode, rtx);\n+extern enum reg_class mcore_reload_class \t\t(rtx, enum reg_class);\n+extern int          mcore_is_same_reg            \t(rtx, rtx);\n+extern int          mcore_arith_S_operand         \t(rtx);\n \n #ifdef HAVE_MACHINE_MODES\n-extern const char * mcore_output_move          \t\tPARAMS ((rtx, rtx *, enum machine_mode));\n-extern const char * mcore_output_movedouble    \t\tPARAMS ((rtx *, enum machine_mode));\n-extern int          mcore_arith_reg_operand       \tPARAMS ((rtx, enum machine_mode));\n-extern int          mcore_general_movsrc_operand  \tPARAMS ((rtx, enum machine_mode));\n-extern int          mcore_general_movdst_operand  \tPARAMS ((rtx, enum machine_mode));\n-extern int          mcore_reload_operand          \tPARAMS ((rtx, enum machine_mode));\n-extern int          mcore_arith_J_operand         \tPARAMS ((rtx, enum machine_mode));\n-extern int          mcore_arith_K_operand         \tPARAMS ((rtx, enum machine_mode));\n-extern int          mcore_arith_K_operand_not_0   \tPARAMS ((rtx, enum machine_mode));\n-extern int          mcore_arith_M_operand         \tPARAMS ((rtx, enum machine_mode));\n-extern int          mcore_arith_K_S_operand       \tPARAMS ((rtx, enum machine_mode));\n-extern int          mcore_arith_imm_operand       \tPARAMS ((rtx, enum machine_mode));\n-extern int          mcore_arith_any_imm_operand   \tPARAMS ((rtx, enum machine_mode));\n-extern int          mcore_arith_O_operand         \tPARAMS ((rtx, enum machine_mode));\n-extern int          mcore_literal_K_operand       \tPARAMS ((rtx, enum machine_mode));\n-extern int          mcore_addsub_operand          \tPARAMS ((rtx, enum machine_mode));\n-extern int          mcore_compare_operand         \tPARAMS ((rtx, enum machine_mode));\n-extern int          mcore_load_multiple_operation \tPARAMS ((rtx, enum machine_mode));\n-extern int          mcore_store_multiple_operation\tPARAMS ((rtx, enum machine_mode));\n-extern int          mcore_call_address_operand    \tPARAMS ((rtx, enum machine_mode));\n+extern const char * mcore_output_move          \t\t(rtx, rtx *, enum machine_mode);\n+extern const char * mcore_output_movedouble    \t\t(rtx *, enum machine_mode);\n+extern int          mcore_arith_reg_operand       \t(rtx, enum machine_mode);\n+extern int          mcore_general_movsrc_operand  \t(rtx, enum machine_mode);\n+extern int          mcore_general_movdst_operand  \t(rtx, enum machine_mode);\n+extern int          mcore_reload_operand          \t(rtx, enum machine_mode);\n+extern int          mcore_arith_J_operand         \t(rtx, enum machine_mode);\n+extern int          mcore_arith_K_operand         \t(rtx, enum machine_mode);\n+extern int          mcore_arith_K_operand_not_0   \t(rtx, enum machine_mode);\n+extern int          mcore_arith_M_operand         \t(rtx, enum machine_mode);\n+extern int          mcore_arith_K_S_operand       \t(rtx, enum machine_mode);\n+extern int          mcore_arith_imm_operand       \t(rtx, enum machine_mode);\n+extern int          mcore_arith_any_imm_operand   \t(rtx, enum machine_mode);\n+extern int          mcore_arith_O_operand         \t(rtx, enum machine_mode);\n+extern int          mcore_literal_K_operand       \t(rtx, enum machine_mode);\n+extern int          mcore_addsub_operand          \t(rtx, enum machine_mode);\n+extern int          mcore_compare_operand         \t(rtx, enum machine_mode);\n+extern int          mcore_load_multiple_operation \t(rtx, enum machine_mode);\n+extern int          mcore_store_multiple_operation\t(rtx, enum machine_mode);\n+extern int          mcore_call_address_operand    \t(rtx, enum machine_mode);\n \n #ifdef TREE_CODE\n-extern rtx          mcore_function_arg           \tPARAMS ((CUMULATIVE_ARGS, enum machine_mode, tree, int));\n+extern rtx          mcore_function_arg           \t(CUMULATIVE_ARGS, enum machine_mode, tree, int);\n #endif /* TREE_CODE */\n #endif /* HAVE_MACHINE_MODES */\n #endif /* RTX_CODE */"}, {"sha": "25eca33d08f2597b83837791ae35d8a55e242357", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 181, "deletions": 315, "changes": 496, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08903e087eacedbc41bf8cdc63c238349c0079c4/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08903e087eacedbc41bf8cdc63c238349c0079c4/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=08903e087eacedbc41bf8cdc63c238349c0079c4", "patch": "@@ -1,22 +1,22 @@\n /* Output routines for Motorola MCore processor\n-   Copyright (C) 1993, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n-This file is part of GCC.\n+   This file is part of GCC.\n \n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n \n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -88,16 +88,16 @@ const enum reg_class reg_class_from_letter[] =\n \n struct mcore_frame\n {\n-  int arg_size;\t\t\t/* stdarg spills (bytes) */\n-  int reg_size;\t\t\t/* non-volatile reg saves (bytes) */\n-  int reg_mask;\t\t\t/* non-volatile reg saves */\n-  int local_size;\t\t/* locals */\n-  int outbound_size;\t\t/* arg overflow on calls out */\n+  int arg_size;\t\t\t/* Stdarg spills (bytes).  */\n+  int reg_size;\t\t\t/* Non-volatile reg saves (bytes).  */\n+  int reg_mask;\t\t\t/* Non-volatile reg saves.  */\n+  int local_size;\t\t/* Locals.  */\n+  int outbound_size;\t\t/* Arg overflow on calls out.  */\n   int pad_outbound;\n   int pad_local;\n   int pad_reg;\n   /* Describe the steps we'll use to grow it.  */\n-#define\tMAX_STACK_GROWS\t4\t/* gives us some spare space */\n+#define\tMAX_STACK_GROWS\t4\t/* Gives us some spare space.  */\n   int growth[MAX_STACK_GROWS];\n   int arg_offset;\n   int reg_offset;\n@@ -116,80 +116,77 @@ typedef enum\n }\n cond_type;\n \n-static void       output_stack_adjust          PARAMS ((int, int));\n-static int        calc_live_regs               PARAMS ((int *));\n-static int        const_ok_for_mcore           PARAMS ((int));\n-static int        try_constant_tricks          PARAMS ((long, int *, int *));\n-static const char *     output_inline_const          PARAMS ((enum machine_mode, rtx *));\n-static void       block_move_sequence          PARAMS ((rtx, rtx, rtx, rtx, int, int, int));\n-static void       layout_mcore_frame           PARAMS ((struct mcore_frame *));\n-static cond_type  is_cond_candidate            PARAMS ((rtx));\n-static rtx        emit_new_cond_insn           PARAMS ((rtx, int));\n-static rtx        conditionalize_block         PARAMS ((rtx));\n-static void       conditionalize_optimization  PARAMS ((void));\n-static void       mcore_reorg                  PARAMS ((void));\n-static rtx        handle_structs_in_regs       PARAMS ((enum machine_mode, tree, int));\n-static void       mcore_mark_dllexport         PARAMS ((tree));\n-static void       mcore_mark_dllimport         PARAMS ((tree));\n-static int        mcore_dllexport_p            PARAMS ((tree));\n-static int        mcore_dllimport_p            PARAMS ((tree));\n+static void       output_stack_adjust           (int, int);\n+static int        calc_live_regs                (int *);\n+static int        const_ok_for_mcore            (int);\n+static int        try_constant_tricks           (long, int *, int *);\n+static const char *     output_inline_const     (enum machine_mode, rtx *);\n+static void       block_move_sequence           (rtx, rtx, rtx, rtx, int, int, int);\n+static void       layout_mcore_frame            (struct mcore_frame *);\n+static cond_type  is_cond_candidate             (rtx);\n+static rtx        emit_new_cond_insn            (rtx, int);\n+static rtx        conditionalize_block          (rtx);\n+static void       conditionalize_optimization   (void);\n+static void       mcore_reorg                   (void);\n+static rtx        handle_structs_in_regs        (enum machine_mode, tree, int);\n+static void       mcore_mark_dllexport          (tree);\n+static void       mcore_mark_dllimport          (tree);\n+static int        mcore_dllexport_p             (tree);\n+static int        mcore_dllimport_p             (tree);\n const struct attribute_spec mcore_attribute_table[];\n-static tree       mcore_handle_naked_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree       mcore_handle_naked_attribute  (tree *, tree, tree, int, bool *);\n #ifdef OBJECT_FORMAT_ELF\n-static void\t  mcore_asm_named_section      PARAMS ((const char *,\n-\t\t\t\t\t\t\tunsigned int));\n+static void\t  mcore_asm_named_section       (const char *,\n+\t\t\t\t\t\t\tunsigned int);\n #endif\n-static void       mcore_unique_section\t       PARAMS ((tree, int));\n-static void mcore_encode_section_info\t\tPARAMS ((tree, rtx, int));\n-static const char *mcore_strip_name_encoding\tPARAMS ((const char *));\n-static int        mcore_const_costs            \tPARAMS ((rtx, RTX_CODE));\n-static int        mcore_and_cost               \tPARAMS ((rtx));\n-static int        mcore_ior_cost               \tPARAMS ((rtx));\n-static bool       mcore_rtx_costs\t\tPARAMS ((rtx, int, int, int *));\n+static void       mcore_unique_section\t        (tree, int);\n+static void mcore_encode_section_info\t\t(tree, rtx, int);\n+static const char *mcore_strip_name_encoding\t(const char *);\n+static int        mcore_const_costs            \t(rtx, RTX_CODE);\n+static int        mcore_and_cost               \t(rtx);\n+static int        mcore_ior_cost               \t(rtx);\n+static bool       mcore_rtx_costs\t\t(rtx, int, int, int *);\n \f\n /* Initialize the GCC target structure.  */\n #ifdef TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-#undef TARGET_MERGE_DECL_ATTRIBUTES\n-#define TARGET_MERGE_DECL_ATTRIBUTES merge_dllimport_decl_attributes\n+#undef  TARGET_MERGE_DECL_ATTRIBUTES\n+#define TARGET_MERGE_DECL_ATTRIBUTES\tmerge_dllimport_decl_attributes\n #endif\n \n #ifdef OBJECT_FORMAT_ELF\n-#undef TARGET_ASM_UNALIGNED_HI_OP\n+#undef  TARGET_ASM_UNALIGNED_HI_OP\n #define TARGET_ASM_UNALIGNED_HI_OP \"\\t.short\\t\"\n-#undef TARGET_ASM_UNALIGNED_SI_OP\n+#undef  TARGET_ASM_UNALIGNED_SI_OP\n #define TARGET_ASM_UNALIGNED_SI_OP \"\\t.long\\t\"\n #endif\n \n-#undef TARGET_ATTRIBUTE_TABLE\n-#define TARGET_ATTRIBUTE_TABLE mcore_attribute_table\n-#undef TARGET_ASM_UNIQUE_SECTION\n-#define TARGET_ASM_UNIQUE_SECTION mcore_unique_section\n-#undef TARGET_ENCODE_SECTION_INFO\n-#define TARGET_ENCODE_SECTION_INFO mcore_encode_section_info\n-#undef TARGET_STRIP_NAME_ENCODING\n-#define TARGET_STRIP_NAME_ENCODING mcore_strip_name_encoding\n-\n-#undef TARGET_RTX_COSTS\n-#define TARGET_RTX_COSTS mcore_rtx_costs\n-#undef TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST hook_int_rtx_0\n-\n-#undef TARGET_MACHINE_DEPENDENT_REORG\n-#define TARGET_MACHINE_DEPENDENT_REORG mcore_reorg\n+#undef  TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE \t\tmcore_attribute_table\n+#undef  TARGET_ASM_UNIQUE_SECTION\n+#define TARGET_ASM_UNIQUE_SECTION \tmcore_unique_section\n+#undef  TARGET_ENCODE_SECTION_INFO\n+#define TARGET_ENCODE_SECTION_INFO \tmcore_encode_section_info\n+#undef  TARGET_STRIP_NAME_ENCODING\n+#define TARGET_STRIP_NAME_ENCODING\tmcore_strip_name_encoding\n+#undef  TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS \t\tmcore_rtx_costs\n+#undef  TARGET_ADDRESS_COST\n+#define TARGET_ADDRESS_COST \t\thook_int_rtx_0\n+#undef  TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG\tmcore_reorg\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Adjust the stack and return the number of bytes taken to do it.  */\n static void\n-output_stack_adjust (direction, size)\n-     int direction;\n-     int size;\n+output_stack_adjust (int direction, int size)\n {\n   /* If extending stack a lot, we do it incrementally.  */\n   if (direction < 0 && size > mcore_stack_increment && mcore_stack_increment > 0)\n     {\n       rtx tmp = gen_rtx (REG, SImode, 1);\n       rtx memref;\n+\n       emit_insn (gen_movsi (tmp, GEN_INT (mcore_stack_increment)));\n       do\n \t{\n@@ -230,8 +227,7 @@ output_stack_adjust (direction, size)\n    both as a mask and a count.  */\n \n static int\n-calc_live_regs (count)\n-     int * count;\n+calc_live_regs (int * count)\n {\n   int reg;\n   int live_regs_mask = 0;\n@@ -253,9 +249,7 @@ calc_live_regs (count)\n /* Print the operand address in x to the stream.  */\n \n void\n-mcore_print_operand_address (stream, x)\n-     FILE * stream;\n-     rtx x;\n+mcore_print_operand_address (FILE * stream, rtx x)\n {\n   switch (GET_CODE (x))\n     {\n@@ -311,10 +305,7 @@ mcore_print_operand_address (stream, x)\n    'X'  print byte number for xtrbN instruction.  */\n \n void\n-mcore_print_operand (stream, x, code)\n-     FILE * stream;\n-     rtx x;\n-     int code;\n+mcore_print_operand (FILE * stream, rtx x, int code)\n {\n   switch (code)\n     {\n@@ -382,11 +373,8 @@ mcore_print_operand (stream, x, code)\n /* What does a constant cost ?  */\n \n static int\n-mcore_const_costs (exp, code)\n-     rtx exp;\n-     enum rtx_code code;\n+mcore_const_costs (rtx exp, enum rtx_code code)\n {\n-\n   int val = INTVAL (exp);\n \n   /* Easy constants.  */\n@@ -413,8 +401,7 @@ mcore_const_costs (exp, code)\n    out.  Otherwise we'll get bad code (multiple reloads of the same const).  */\n \n static int\n-mcore_and_cost (x)\n-     rtx x;\n+mcore_and_cost (rtx x)\n {\n   int val;\n \n@@ -440,8 +427,7 @@ mcore_and_cost (x)\n /* What does an or cost - see and_cost().  */\n \n static int\n-mcore_ior_cost (x)\n-     rtx x;\n+mcore_ior_cost (rtx x)\n {\n   int val;\n \n@@ -465,10 +451,7 @@ mcore_ior_cost (x)\n }\n \n static bool\n-mcore_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code;\n-     int *total;\n+mcore_rtx_costs (rtx x, int code, int outer_code, int * total)\n {\n   switch (code)\n     {\n@@ -511,10 +494,9 @@ mcore_rtx_costs (x, code, outer_code, total)\n    to load.  */\n \n int\n-mcore_modify_comparison (code)\n-     enum rtx_code code;\n+mcore_modify_comparison (enum rtx_code code)\n {\n-  rtx op1   = arch_compare_op1;\n+  rtx op1 = arch_compare_op1;\n   \n   if (GET_CODE (op1) == CONST_INT)\n     {\n@@ -541,8 +523,7 @@ mcore_modify_comparison (code)\n /* Prepare the operands for a comparison.  */\n \n rtx\n-mcore_gen_compare_reg (code)\n-     enum rtx_code code;\n+mcore_gen_compare_reg (enum rtx_code code)\n {\n   rtx op0 = arch_compare_op0;\n   rtx op1 = arch_compare_op1;\n@@ -557,7 +538,7 @@ mcore_gen_compare_reg (code)\n     {\n     case EQ:\t/* Use inverted condition, cmpne.  */\n       code = NE;\n-      /* drop through */\n+      /* Drop through.  */\n       \n     case NE:\t/* Use normal condition, cmpne.  */\n       if (GET_CODE (op1) == CONST_INT && ! CONST_OK_FOR_K (INTVAL (op1)))\n@@ -566,7 +547,7 @@ mcore_gen_compare_reg (code)\n \n     case LE:\t/* Use inverted condition, reversed cmplt.  */\n       code = GT;\n-      /* drop through */\n+      /* Drop through.  */\n       \n     case GT:\t/* Use normal condition, reversed cmplt.  */\n       if (GET_CODE (op1) == CONST_INT)\n@@ -575,11 +556,11 @@ mcore_gen_compare_reg (code)\n \n     case GE:\t/* Use inverted condition, cmplt.  */\n       code = LT;\n-      /* drop through */\n+      /* Drop through.  */\n       \n     case LT:\t/* Use normal condition, cmplt.  */\n       if (GET_CODE (op1) == CONST_INT && \n-\t  /* covered by btsti x,31 */\n+\t  /* covered by btsti x,31.  */\n \t  INTVAL (op1) != 0 &&\n \t  ! CONST_OK_FOR_J (INTVAL (op1)))\n \top1 = force_reg (SImode, op1);\n@@ -599,7 +580,7 @@ mcore_gen_compare_reg (code)\n \t  break;\n \t}\n       code = LEU;\n-      /* drop through */\n+      /* Drop through.  */\n       \n     case LEU:\t/* Use normal condition, reversed cmphs. */\n       if (GET_CODE (op1) == CONST_INT && INTVAL (op1) != 0)\n@@ -608,7 +589,7 @@ mcore_gen_compare_reg (code)\n \n     case LTU:\t/* Use inverted condition, cmphs.  */\n       code = GEU;\n-      /* drop through */\n+      /* Drop through.  */\n       \n     case GEU:\t/* Use normal condition, cmphs.  */\n       if (GET_CODE (op1) == CONST_INT && INTVAL (op1) != 0)\n@@ -624,10 +605,8 @@ mcore_gen_compare_reg (code)\n   return cc_reg;\n }\n \n-\n int\n-mcore_symbolic_address_p (x)\n-     rtx x;\n+mcore_symbolic_address_p (rtx x)\n {\n   switch (GET_CODE (x))\n     {\n@@ -645,19 +624,15 @@ mcore_symbolic_address_p (x)\n }\n \n int\n-mcore_call_address_operand (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+mcore_call_address_operand (rtx x, enum machine_mode mode)\n {\n   return register_operand (x, mode) || CONSTANT_P (x);\n }\n \n /* Functions to output assembly code for a function call.  */\n \n char *\n-mcore_output_call (operands, index)\n-     rtx operands[];\n-     int index;\n+mcore_output_call (rtx operands[], int index)\n {\n   static char buffer[20];\n   rtx addr = operands [index];\n@@ -697,8 +672,7 @@ mcore_output_call (operands, index)\n /* Can we load a constant with a single instruction ?  */\n \n static int\n-const_ok_for_mcore (value)\n-     int value;\n+const_ok_for_mcore (int value)\n {\n   if (value >= 0 && value <= 127)\n     return 1;\n@@ -717,8 +691,7 @@ const_ok_for_mcore (value)\n /* Can we load a constant inline with up to 2 instructions ?  */\n \n int\n-mcore_const_ok_for_inline (value)\n-     long value;\n+mcore_const_ok_for_inline (long value)\n {\n   int x, y;\n    \n@@ -728,8 +701,7 @@ mcore_const_ok_for_inline (value)\n /* Are we loading the constant using a not ?  */\n \n int\n-mcore_const_trick_uses_not (value)\n-     long value;\n+mcore_const_trick_uses_not (long value)\n {\n   int x, y;\n \n@@ -753,10 +725,7 @@ mcore_const_trick_uses_not (value)\n    11: single insn followed by ixw.  */\n \n static int\n-try_constant_tricks (value, x, y)\n-     long value;\n-     int * x;\n-     int * y;\n+try_constant_tricks (long value, int * x, int * y)\n {\n   int i;\n   unsigned bit, shf, rot;\n@@ -875,17 +844,14 @@ try_constant_tricks (value, x, y)\n   return 0;\n }\n \n-\n /* Check whether reg is dead at first.  This is done by searching ahead\n    for either the next use (i.e., reg is live), a death note, or a set of\n    reg.  Don't just use dead_or_set_p() since reload does not always mark \n    deaths (especially if PRESERVE_DEATH_NOTES_REGNO_P is not defined). We\n    can ignore subregs by extracting the actual register.  BRC  */\n \n int\n-mcore_is_dead (first, reg)\n-     rtx first;\n-     rtx reg;\n+mcore_is_dead (rtx first, rtx reg)\n {\n   rtx insn;\n \n@@ -927,12 +893,10 @@ mcore_is_dead (first, reg)\n   return 0;\n }\n \n-\n /* Count the number of ones in mask.  */\n \n int\n-mcore_num_ones (mask)\n-     int mask;\n+mcore_num_ones (int mask)\n {\n   /* A trick to count set bits recently posted on comp.compilers.  */\n   mask =  (mask >> 1  & 0x55555555) + (mask & 0x55555555);\n@@ -946,17 +910,15 @@ mcore_num_ones (mask)\n /* Count the number of zeros in mask.  */\n \n int\n-mcore_num_zeros (mask)\n-     int mask;\n+mcore_num_zeros (int mask)\n {\n   return 32 - mcore_num_ones (mask);\n }\n \n /* Determine byte being masked.  */\n \n int\n-mcore_byte_offset (mask)\n-     unsigned int mask;\n+mcore_byte_offset (unsigned int mask)\n {\n   if (mask == 0x00ffffffL)\n     return 0;\n@@ -973,8 +935,7 @@ mcore_byte_offset (mask)\n /* Determine halfword being masked.  */\n \n int\n-mcore_halfword_offset (mask)\n-     unsigned int mask;\n+mcore_halfword_offset (unsigned int mask)\n {\n   if (mask == 0x0000ffffL)\n     return 0;\n@@ -987,9 +948,7 @@ mcore_halfword_offset (mask)\n /* Output a series of bseti's corresponding to mask.  */\n \n const char *\n-mcore_output_bseti (dst, mask)\n-     rtx dst;\n-     int mask;\n+mcore_output_bseti (rtx dst, int mask)\n {\n   rtx out_operands[2];\n   int bit;\n@@ -1013,9 +972,7 @@ mcore_output_bseti (dst, mask)\n /* Output a series of bclri's corresponding to mask.  */\n \n const char *\n-mcore_output_bclri (dst, mask)\n-     rtx dst;\n-     int mask;\n+mcore_output_bclri (rtx dst, int mask)\n {\n   rtx out_operands[2];\n   int bit;\n@@ -1042,10 +999,7 @@ mcore_output_bclri (dst, mask)\n    really worth the effort.  */\n \n const char *\n-mcore_output_cmov (operands, cmp_t, test)\n-     rtx operands[];\n-     int cmp_t;\n-     const char * test;\n+mcore_output_cmov (rtx operands[], int cmp_t, const char * test)\n {\n   int load_value;\n   int adjust_value;\n@@ -1109,9 +1063,7 @@ mcore_output_cmov (operands, cmp_t, test)\n    by an and (i.e. combine the not and the and into andn). BRC  */\n \n const char *\n-mcore_output_andn (insn, operands)\n-     rtx insn ATTRIBUTE_UNUSED;\n-     rtx operands[];\n+mcore_output_andn (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n {\n   int x, y;\n   rtx out_operands[3];\n@@ -1148,9 +1100,7 @@ mcore_output_andn (insn, operands)\n /* Output an inline constant.  */\n \n static const char *\n-output_inline_const (mode, operands)\n-     enum machine_mode mode;\n-     rtx operands[];\n+output_inline_const (enum machine_mode mode, rtx operands[])\n {\n   int x = 0, y = 0;\n   int trick_no;\n@@ -1248,10 +1198,8 @@ output_inline_const (mode, operands)\n /* Output a move of a word or less value.  */\n \n const char *\n-mcore_output_move (insn, operands, mode)\n-     rtx insn ATTRIBUTE_UNUSED;\n-     rtx operands[];\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+mcore_output_move (rtx insn ATTRIBUTE_UNUSED, rtx operands[],\n+\t\t   enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   rtx dst = operands[0];\n   rtx src = operands[1];\n@@ -1321,9 +1269,7 @@ mcore_output_move (insn, operands, mode)\n    to take care when we see overlapping source and dest registers.  */\n \n const char *\n-mcore_output_movedouble (operands, mode)\n-     rtx operands[];\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+mcore_output_movedouble (rtx operands[], enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   rtx dst = operands[0];\n   rtx src = operands[1];\n@@ -1428,9 +1374,7 @@ mcore_output_movedouble (operands, mode)\n /* Nonzero if OP can be source of a simple move operation.  */\n \n int\n-mcore_general_movsrc_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mcore_general_movsrc_operand (rtx op, enum machine_mode mode)\n {\n   /* Any (MEM LABEL_REF) is OK.  That is a pc-relative load.  */\n   if (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == LABEL_REF)\n@@ -1442,9 +1386,7 @@ mcore_general_movsrc_operand (op, mode)\n /* Nonzero if OP can be destination of a simple move operation. */\n \n int\n-mcore_general_movdst_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mcore_general_movdst_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == REG && REGNO (op) == CC_REG)\n     return 0;\n@@ -1455,9 +1397,7 @@ mcore_general_movdst_operand (op, mode)\n /* Nonzero if OP is a normal arithmetic register.  */\n \n int\n-mcore_arith_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mcore_arith_reg_operand (rtx op, enum machine_mode mode)\n {\n   if (! register_operand (op, mode))\n     return 0;\n@@ -1475,9 +1415,7 @@ mcore_arith_reg_operand (op, mode)\n    operand.  See the ixh/ixw patterns.  */\n \n int\n-mcore_reload_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mcore_reload_operand (rtx op, enum machine_mode mode)\n {\n   if (mcore_arith_reg_operand (op, mode))\n     return 1;\n@@ -1491,9 +1429,7 @@ mcore_reload_operand (op, mode)\n /* Nonzero if OP is a valid source operand for an arithmetic insn.  */\n \n int\n-mcore_arith_J_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mcore_arith_J_operand (rtx op, enum machine_mode mode)\n {\n   if (register_operand (op, mode))\n     return 1;\n@@ -1507,9 +1443,7 @@ mcore_arith_J_operand (op, mode)\n /* Nonzero if OP is a valid source operand for an arithmetic insn.  */\n \n int\n-mcore_arith_K_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mcore_arith_K_operand (rtx op, enum machine_mode mode)\n {\n   if (register_operand (op, mode))\n     return 1;\n@@ -1523,9 +1457,7 @@ mcore_arith_K_operand (op, mode)\n /* Nonzero if OP is a valid source operand for a shift or rotate insn.  */\n \n int\n-mcore_arith_K_operand_not_0 (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mcore_arith_K_operand_not_0 (rtx op, enum machine_mode mode)\n {\n   if (register_operand (op, mode))\n     return 1;\n@@ -1539,9 +1471,7 @@ mcore_arith_K_operand_not_0 (op, mode)\n }\n \n int\n-mcore_arith_K_S_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mcore_arith_K_S_operand (rtx op, enum machine_mode mode)\n {\n   if (register_operand (op, mode))\n     return 1;\n@@ -1556,8 +1486,7 @@ mcore_arith_K_S_operand (op, mode)\n }\n \n int\n-mcore_arith_S_operand (op)\n-     rtx op;\n+mcore_arith_S_operand (rtx op)\n {\n   if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_M (~INTVAL (op)))\n     return 1;\n@@ -1566,9 +1495,7 @@ mcore_arith_S_operand (op)\n }\n \n int\n-mcore_arith_M_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mcore_arith_M_operand (rtx op, enum machine_mode mode)\n {\n   if (register_operand (op, mode))\n     return 1;\n@@ -1582,9 +1509,7 @@ mcore_arith_M_operand (op, mode)\n /* Nonzero if OP is a valid source operand for loading.  */\n \n int\n-mcore_arith_imm_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mcore_arith_imm_operand (rtx op, enum machine_mode mode)\n {\n   if (register_operand (op, mode))\n     return 1;\n@@ -1596,9 +1521,7 @@ mcore_arith_imm_operand (op, mode)\n }\n \n int\n-mcore_arith_any_imm_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mcore_arith_any_imm_operand (rtx op, enum machine_mode mode)\n {\n   if (register_operand (op, mode))\n     return 1;\n@@ -1612,9 +1535,7 @@ mcore_arith_any_imm_operand (op, mode)\n /* Nonzero if OP is a valid source operand for a cmov with two consts +/- 1.  */\n \n int\n-mcore_arith_O_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mcore_arith_O_operand (rtx op, enum machine_mode mode)\n {\n   if (register_operand (op, mode))\n     return 1;\n@@ -1628,9 +1549,7 @@ mcore_arith_O_operand (op, mode)\n /* Nonzero if OP is a valid source operand for a btsti.  */\n \n int\n-mcore_literal_K_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+mcore_literal_K_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_K (INTVAL (op)))\n     return 1;\n@@ -1641,9 +1560,7 @@ mcore_literal_K_operand (op, mode)\n /* Nonzero if OP is a valid source operand for an add/sub insn.  */\n \n int\n-mcore_addsub_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mcore_addsub_operand (rtx op, enum machine_mode mode)\n {\n   if (register_operand (op, mode))\n     return 1;\n@@ -1670,9 +1587,7 @@ mcore_addsub_operand (op, mode)\n /* Nonzero if OP is a valid source operand for a compare operation.  */\n \n int\n-mcore_compare_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mcore_compare_operand (rtx op, enum machine_mode mode)\n {\n   if (register_operand (op, mode))\n     return 1;\n@@ -1686,8 +1601,7 @@ mcore_compare_operand (op, mode)\n /* Expand insert bit field.  BRC  */\n \n int\n-mcore_expand_insv (operands)\n-     rtx operands[];\n+mcore_expand_insv (rtx operands[])\n {\n   int width = INTVAL (operands[1]);\n   int posn = INTVAL (operands[2]);\n@@ -1786,10 +1700,9 @@ mcore_expand_insv (operands)\n \n /* Return 1 if OP is a load multiple operation.  It is known to be a\n    PARALLEL and the first section will be tested.  */\n+\n int\n-mcore_load_multiple_operation (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+mcore_load_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   int count = XVECLEN (op, 0);\n   int dest_regno;\n@@ -1829,9 +1742,7 @@ mcore_load_multiple_operation (op, mode)\n /* Similar, but tests for store multiple.  */\n \n int\n-mcore_store_multiple_operation (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+mcore_store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   int count = XVECLEN (op, 0);\n   int src_regno;\n@@ -1890,12 +1801,8 @@ static const enum machine_mode mode_from_align[] =\n };\n \n static void\n-block_move_sequence (dest, dst_mem, src, src_mem, size, align, offset)\n-     rtx dest, dst_mem;\n-     rtx src, src_mem;\n-     int size;\n-     int align;\n-     int offset;\n+block_move_sequence (rtx dest, rtx dst_mem, rtx src, rtx src_mem,\n+\t\t     int size, int align, int offset)\n {\n   rtx temp[2];\n   enum machine_mode mode[2];\n@@ -1981,10 +1888,7 @@ block_move_sequence (dest, dst_mem, src, src_mem, size, align, offset)\n }\n \n void\n-mcore_expand_block_move (dst_mem, src_mem, operands)\n-     rtx dst_mem;\n-     rtx src_mem;\n-     rtx * operands;\n+mcore_expand_block_move (rtx dst_mem, rtx src_mem, rtx * operands)\n {\n   int align = INTVAL (operands[3]);\n   int bytes;\n@@ -2031,8 +1935,7 @@ static int current_function_anonymous_args;\n #define\tADDI_REACH (32)\t\t/* Maximum addi operand.  */\n \n static void\n-layout_mcore_frame (infp)\n-     struct mcore_frame * infp;\n+layout_mcore_frame (struct mcore_frame * infp)\n {\n   int n;\n   unsigned int i;\n@@ -2256,9 +2159,7 @@ layout_mcore_frame (infp)\n    the other its replacement, at the start of a routine.  */\n \n int\n-mcore_initial_elimination_offset (from, to)\n-     int from;\n-     int to;\n+mcore_initial_elimination_offset (int from, int to)\n {\n   int above_frame;\n   int below_frame;\n@@ -2288,11 +2189,9 @@ mcore_initial_elimination_offset (from, to)\n /* Keep track of some information about varargs for the prolog.  */\n \n void\n-mcore_setup_incoming_varargs (args_so_far, mode, type, ptr_pretend_size)\n-     CUMULATIVE_ARGS args_so_far;\n-     enum machine_mode mode;\n-     tree type;\n-     int * ptr_pretend_size ATTRIBUTE_UNUSED;\n+mcore_setup_incoming_varargs (CUMULATIVE_ARGS args_so_far,\n+\t\t\t      enum machine_mode mode, tree type,\n+\t\t\t      int * ptr_pretend_size ATTRIBUTE_UNUSED)\n {\n   current_function_anonymous_args = 1;\n \n@@ -2313,7 +2212,7 @@ mcore_setup_incoming_varargs (args_so_far, mode, type, ptr_pretend_size)\n }\n \n void\n-mcore_expand_prolog ()\n+mcore_expand_prolog (void)\n {\n   struct mcore_frame fi;\n   int space_allocated = 0;\n@@ -2366,7 +2265,7 @@ mcore_expand_prolog ()\n     return;\n   \n   /* Handle stdarg+regsaves in one shot: can't be more than 64 bytes.  */\n-  output_stack_adjust (-1, fi.growth[growth++]);\t/* grows it */\n+  output_stack_adjust (-1, fi.growth[growth++]);\t/* Grows it.  */\n \n   /* If we have a parameter passed partially in regs and partially in memory,\n      the registers will have been stored to memory already in function.c.  So\n@@ -2388,7 +2287,7 @@ mcore_expand_prolog ()\n \n   /* Do we need another stack adjustment before we do the register saves?  */\n   if (growth < fi.reg_growth)\n-    output_stack_adjust (-1, fi.growth[growth++]);\t\t/* grows it */\n+    output_stack_adjust (-1, fi.growth[growth++]);\t\t/* Grows it.  */\n \n   if (fi.reg_size != 0)\n     {\n@@ -2428,7 +2327,7 @@ mcore_expand_prolog ()\n     {\n       /* If we haven't already purchased to 'fp'.  */\n       if (growth < fi.local_growth)\n-        output_stack_adjust (-1, fi.growth[growth++]);\t\t/* grows it */\n+        output_stack_adjust (-1, fi.growth[growth++]);\t\t/* Grows it.  */\n       \n       emit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n \n@@ -2439,14 +2338,14 @@ mcore_expand_prolog ()\n   else\n     {\n       if (growth < fi.local_growth)\n-        output_stack_adjust (-1, fi.growth[growth++]);\t\t/* grows it */\n+        output_stack_adjust (-1, fi.growth[growth++]);\t\t/* Grows it.  */\n       if (fi.growth[growth])\n         output_stack_adjust (-1, fi.growth[growth++]);\n     }\n }\n \n void\n-mcore_expand_epilog ()\n+mcore_expand_epilog (void)\n {\n   struct mcore_frame fi;\n   int i;\n@@ -2594,7 +2493,7 @@ static int pool_size;\n    will only be labels.  */\n \n const char *\n-mcore_output_jump_label_table ()\n+mcore_output_jump_label_table (void)\n {\n   int i;\n \n@@ -2620,8 +2519,7 @@ mcore_output_jump_label_table ()\n /* Check whether insn is a candidate for a conditional.  */\n \n static cond_type\n-is_cond_candidate (insn)\n-     rtx insn;\n+is_cond_candidate (rtx insn)\n {\n   /* The only things we conditionalize are those that can be directly\n      changed into a conditional.  Only bother with SImode items.  If \n@@ -2690,9 +2588,7 @@ is_cond_candidate (insn)\n    new one.  Return the new insn if emitted.  */\n \n static rtx\n-emit_new_cond_insn (insn, cond)\n-     rtx insn;\n-     int cond;\n+emit_new_cond_insn (rtx insn, int cond)\n {\n   rtx c_insn = 0;\n   rtx pat, dst, src;\n@@ -2809,8 +2705,7 @@ emit_new_cond_insn (insn, cond)\n    starting at the last instruction of block 2.  This may allow an entire\n    if-then-else statement to be conditionalized.  BRC  */\n static rtx\n-conditionalize_block (first)\n-     rtx first;\n+conditionalize_block (rtx first)\n {\n   rtx insn;\n   rtx br_pat;\n@@ -2951,7 +2846,7 @@ conditionalize_block (first)\n    in before cse 2).  */\n \n static void\n-conditionalize_optimization ()\n+conditionalize_optimization (void)\n {\n   rtx insn;\n \n@@ -2965,7 +2860,7 @@ static int saved_warn_return_type_count = 0;\n /* This is to handle loads from the constant pool.  */\n \n static void\n-mcore_reorg ()\n+mcore_reorg (void)\n {\n   /* Reset this variable.  */\n   current_function_anonymous_args = 0;\n@@ -2998,8 +2893,7 @@ mcore_reorg ()\n /* Return true if X is something that can be moved directly into r15.  */\n \n bool\n-mcore_r15_operand_p (x)\n-     rtx x;\n+mcore_r15_operand_p (rtx x)\n {\n   switch (GET_CODE (x))\n     {\n@@ -3018,11 +2912,10 @@ mcore_r15_operand_p (x)\n \n /* Implement SECONDARY_RELOAD_CLASS.  If CLASS contains r15, and we can't\n    directly move X into it, use r1-r14 as a temporary.  */\n+\n enum reg_class\n-mcore_secondary_reload_class (class, mode, x)\n-     enum reg_class class;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     rtx x;\n+mcore_secondary_reload_class (enum reg_class class,\n+\t\t\t      enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   if (TEST_HARD_REG_BIT (reg_class_contents[class], 15)\n       && !mcore_r15_operand_p (x))\n@@ -3033,10 +2926,9 @@ mcore_secondary_reload_class (class, mode, x)\n /* Return the reg_class to use when reloading the rtx X into the class\n    CLASS.  If X is too complex to move directly into r15, prefer to\n    use LRW_REGS instead.  */\n+\n enum reg_class\n-mcore_reload_class (x, class)\n-     rtx x;\n-     enum reg_class class;\n+mcore_reload_class (rtx x, enum reg_class class)\n {\n   if (reg_class_subset_p (LRW_REGS, class) && !mcore_r15_operand_p (x))\n     return LRW_REGS;\n@@ -3049,10 +2941,9 @@ mcore_reload_class (x, class)\n    they are the same mode or note (e.g., a QImode in r2 matches an HImode\n    in r2 matches an SImode in r2. Might think in the future about whether\n    we want to be able to say something about modes.  */\n+\n int\n-mcore_is_same_reg (x, y)\n-     rtx x;\n-     rtx y;\n+mcore_is_same_reg (rtx x, rtx y)\n {\n   /* Strip any and all of the subreg wrappers. */\n   while (GET_CODE (x) == SUBREG)\n@@ -3068,7 +2959,7 @@ mcore_is_same_reg (x, y)\n }\n \n void\n-mcore_override_options ()\n+mcore_override_options (void)\n {\n   if (mcore_stack_increment_string)\n     {\n@@ -3088,9 +2979,7 @@ mcore_override_options ()\n }\n \f\n int\n-mcore_must_pass_on_stack (mode, type)\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     tree type;\n+mcore_must_pass_on_stack (enum machine_mode mode ATTRIBUTE_UNUSED, tree type)\n {\n   if (type == NULL)\n     return 0;\n@@ -3105,10 +2994,9 @@ mcore_must_pass_on_stack (mode, type)\n \n /* Compute the number of word sized registers needed to \n    hold a function argument of mode MODE and type TYPE.  */\n+\n int\n-mcore_num_arg_regs (mode, type)\n-     enum machine_mode mode;\n-     tree type;\n+mcore_num_arg_regs (enum machine_mode mode, tree type)\n {\n   int size;\n \n@@ -3124,10 +3012,7 @@ mcore_num_arg_regs (mode, type)\n }\n \n static rtx\n-handle_structs_in_regs (mode, type, reg)\n-     enum machine_mode mode;\n-     tree type;\n-     int  reg;\n+handle_structs_in_regs (enum machine_mode mode, tree type, int reg)\n {\n   int size;\n \n@@ -3171,9 +3056,7 @@ handle_structs_in_regs (mode, type, reg)\n }\n \n rtx\n-mcore_function_value (valtype, func)\n-     tree valtype;\n-     tree func ATTRIBUTE_UNUSED;\n+mcore_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n {\n   enum machine_mode mode;\n   int unsigned_p;\n@@ -3202,12 +3085,10 @@ mcore_function_value (valtype, func)\n    and the rest are pushed.  Any arg that starts within the first\n    NPARM_REGS words is at least partially passed in a register unless\n    its data type forbids.  */\n+\n rtx\n-mcore_function_arg (cum, mode, type, named)\n-     CUMULATIVE_ARGS   cum;\n-     enum machine_mode mode;\n-     tree              type;\n-     int               named;\n+mcore_function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode,\n+\t\t    tree type, int named)\n {\n   int arg_reg;\n   \n@@ -3232,12 +3113,10 @@ mcore_function_arg (cum, mode, type, named)\n    registers, or entirely on the stack, then 0 is returned.  CUM is the\n    number of argument registers already used by earlier parameters to\n    the function.  */\n+\n int\n-mcore_function_arg_partial_nregs (cum, mode, type, named)\n-     CUMULATIVE_ARGS   cum;\n-     enum machine_mode mode;\n-     tree              type;\n-     int               named;\n+mcore_function_arg_partial_nregs (CUMULATIVE_ARGS cum, enum machine_mode mode,\n+\t\t\t\t  tree type, int named)\n {\n   int reg = ROUND_REG (cum, mode);\n \n@@ -3272,25 +3151,25 @@ mcore_function_arg_partial_nregs (cum, mode, type, named)\n }\n \f\n /* Return nonzero if SYMBOL is marked as being dllexport'd.  */\n+\n int\n-mcore_dllexport_name_p (symbol)\n-     const char * symbol;\n+mcore_dllexport_name_p (const char * symbol)\n {\n   return symbol[0] == '@' && symbol[1] == 'e' && symbol[2] == '.';\n }\n \n /* Return nonzero if SYMBOL is marked as being dllimport'd.  */\n+\n int\n-mcore_dllimport_name_p (symbol)\n-     const char * symbol;\n+mcore_dllimport_name_p (const char * symbol)\n {\n   return symbol[0] == '@' && symbol[1] == 'i' && symbol[2] == '.';\n }\n \n /* Mark a DECL as being dllexport'd.  */\n+\n static void\n-mcore_mark_dllexport (decl)\n-     tree decl;\n+mcore_mark_dllexport (tree decl)\n {\n   const char * oldname;\n   char * newname;\n@@ -3325,9 +3204,9 @@ mcore_mark_dllexport (decl)\n }\n \n /* Mark a DECL as being dllimport'd.  */\n+\n static void\n-mcore_mark_dllimport (decl)\n-     tree decl;\n+mcore_mark_dllimport (tree decl)\n {\n   const char * oldname;\n   char * newname;\n@@ -3389,8 +3268,7 @@ mcore_mark_dllimport (decl)\n }\n \n static int\n-mcore_dllexport_p (decl)\n-     tree decl;\n+mcore_dllexport_p (tree decl)\n {\n   if (   TREE_CODE (decl) != VAR_DECL\n       && TREE_CODE (decl) != FUNCTION_DECL)\n@@ -3400,8 +3278,7 @@ mcore_dllexport_p (decl)\n }\n \n static int\n-mcore_dllimport_p (decl)\n-     tree decl;\n+mcore_dllimport_p (tree decl)\n {\n   if (   TREE_CODE (decl) != VAR_DECL\n       && TREE_CODE (decl) != FUNCTION_DECL)\n@@ -3414,10 +3291,7 @@ mcore_dllimport_p (decl)\n    install some info in the .drective (PE) or .exports (ELF) sections.   */\n \n static void\n-mcore_encode_section_info (decl, rtl, first)\n-     tree decl;\n-     rtx rtl ATTRIBUTE_UNUSED;\n-     int first ATTRIBUTE_UNUSED;\n+mcore_encode_section_info (tree decl, rtx rtl ATTRIBUTE_UNUSED, int first ATTRIBUTE_UNUSED)\n {\n   /* Mark the decl so we can tell from the rtl whether the object is\n      dllexport'd or dllimport'd.  */\n@@ -3451,8 +3325,7 @@ mcore_encode_section_info (decl, rtl, first)\n /* Undo the effects of the above.  */\n \n static const char *\n-mcore_strip_name_encoding (str)\n-     const char *str;\n+mcore_strip_name_encoding (const char * str)\n {\n   return str + (str[0] == '@' ? 3 : 0);\n }\n@@ -3473,13 +3346,10 @@ const struct attribute_spec mcore_attribute_table[] =\n \n /* Handle a \"naked\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n+\n static tree\n-mcore_handle_naked_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+mcore_handle_naked_attribute (tree * node, tree name, tree args ATTRIBUTE_UNUSED,\n+\t\t\t      int flags ATTRIBUTE_UNUSED, bool * no_add_attrs)\n {\n   if (TREE_CODE (*node) == FUNCTION_DECL)\n     {\n@@ -3513,9 +3383,7 @@ mcore_handle_naked_attribute (node, name, args, flags, no_add_attrs)\n    old code did as well.  */\n \n static void\n-mcore_unique_section (decl, reloc)\n-     tree decl;\n-     int reloc ATTRIBUTE_UNUSED;\n+mcore_unique_section (tree decl, int reloc ATTRIBUTE_UNUSED)\n {\n   int len;\n   const char * name;\n@@ -3548,16 +3416,14 @@ mcore_unique_section (decl, reloc)\n }\n \n int\n-mcore_naked_function_p ()\n+mcore_naked_function_p (void)\n {\n   return lookup_attribute (\"naked\", DECL_ATTRIBUTES (current_function_decl)) != NULL_TREE;\n }\n \n #ifdef OBJECT_FORMAT_ELF\n static void\n-mcore_asm_named_section (name, flags)\n-     const char *name;\n-     unsigned int flags ATTRIBUTE_UNUSED;\n+mcore_asm_named_section (const char *name, unsigned int flags ATTRIBUTE_UNUSED)\n {\n   fprintf (asm_out_file, \"\\t.section %s\\n\", name);\n }"}, {"sha": "f53ee8d9817bc080d99bcfd242208a276f31bae4", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 21, "deletions": 48, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08903e087eacedbc41bf8cdc63c238349c0079c4/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08903e087eacedbc41bf8cdc63c238349c0079c4/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=08903e087eacedbc41bf8cdc63c238349c0079c4", "patch": "@@ -60,7 +60,7 @@\n   while (0)\n \n /* If -m4align is ever re-enabled then add this line to the definition of CPP_SPEC\n-   %{!m4align:-D__MCORE_ALIGN_8__} %{m4align:-D__MCORE__ALIGN_4__} */\n+   %{!m4align:-D__MCORE_ALIGN_8__} %{m4align:-D__MCORE__ALIGN_4__}.  */\n #undef  CPP_SPEC\n #define CPP_SPEC \"%{m210:%{mlittle-endian:%ethe m210 does not have little endian support}}\"\n \n@@ -78,16 +78,16 @@\n    many architecture specific files (other architectures...).  */\n extern int target_flags;\n \n-#define HARDLIT_BIT\t   (1 << 0) /* Build in-line literals using 2 insns */\n-#define ALIGN8_BIT\t   (1 << 1) /* Max alignment goes to 8 instead of 4 */\n-#define DIV_BIT\t\t   (1 << 2) /* Generate divide instructions */\n-#define RELAX_IMM_BIT\t   (1 << 3) /* Arbitrary immediates in and, or, tst */\n-#define W_FIELD_BIT\t   (1 << 4) /* Generate bit insv/extv using SImode */\n-#define\tOVERALIGN_FUNC_BIT (1 << 5) /* Align functions to 4 byte boundary */\n-#define CGDATA_BIT\t   (1 << 6) /* Generate callgraph data */\n-#define SLOW_BYTES_BIT     (1 << 7) /* Slow byte access */\n-#define LITTLE_END_BIT     (1 << 8) /* Generate little endian code */\n-#define M340_BIT           (1 << 9) /* Generate code for the m340 */\n+#define HARDLIT_BIT\t   (1 << 0) /* Build in-line literals using 2 insns.  */\n+#define ALIGN8_BIT\t   (1 << 1) /* Max alignment goes to 8 instead of 4.  */\n+#define DIV_BIT\t\t   (1 << 2) /* Generate divide instructions.  */\n+#define RELAX_IMM_BIT\t   (1 << 3) /* Arbitrary immediates in and, or, tst.  */\n+#define W_FIELD_BIT\t   (1 << 4) /* Generate bit insv/extv using SImode.  */\n+#define\tOVERALIGN_FUNC_BIT (1 << 5) /* Align functions to 4 byte boundary.  */\n+#define CGDATA_BIT\t   (1 << 6) /* Generate callgraph data.  */\n+#define SLOW_BYTES_BIT     (1 << 7) /* Slow byte access.  */\n+#define LITTLE_END_BIT     (1 << 8) /* Generate little endian code.  */\n+#define M340_BIT           (1 << 9) /* Generate code for the m340.  */\n \n #define TARGET_DEFAULT     \\\n  (HARDLIT_BIT | ALIGN8_BIT | DIV_BIT | RELAX_IMM_BIT | M340_BIT | LITTLE_END_BIT)\n@@ -314,7 +314,7 @@ extern int mcore_stack_increment;\n \tap\t\targ pointer (doesn't really exist, always eliminated)\n \tc               c bit\n \tfp\t\tframe pointer (doesn't really exist, always eliminated)\n-\tx19\t\ttwo control registers  */\n+\tx19\t\ttwo control registers.  */\n \n /* Number of actual hardware registers.\n    The hardware registers are assigned numbers for the compiler\n@@ -327,12 +327,12 @@ extern int mcore_stack_increment;\n \n #define FIRST_PSEUDO_REGISTER 20\n \n-#define R1_REG  1\t/* where literals are forced */\n-#define LK_REG\t15\t/* overloaded on general register */\n-#define AP_REG  16\t/* fake arg pointer register */\n-/* RBE: mcore.md depends on CC_REG being set to 17 */\n-#define CC_REG\t17\t/* can't name it C_REG */\n-#define FP_REG  18\t/* fake frame pointer register */\n+#define R1_REG  1\t/* Where literals are forced.  */\n+#define LK_REG\t15\t/* Overloaded on general register.  */\n+#define AP_REG  16\t/* Fake arg pointer register.  */\n+/* RBE: mcore.md depends on CC_REG being set to 17.  */\n+#define CC_REG\t17\t/* Can't name it C_REG.  */\n+#define FP_REG  18\t/* Fake frame pointer register.  */\n \n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n@@ -460,7 +460,7 @@ extern int mcore_stack_increment;\n \n /* The MCore has only general registers. There are\n    also some special purpose registers: the T bit register, the\n-   procedure Link and the Count Registers */\n+   procedure Link and the Count Registers.  */\n enum reg_class\n {\n   NO_REGS,\n@@ -625,14 +625,6 @@ extern const enum reg_class reg_class_from_letter[];\n    makes the stack pointer a smaller address.  */\n #define STACK_GROWS_DOWNWARD  \n \n-/* Define this if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset in the frame.  */\n-/* We don't define this, because the MCore does not support\n-   addresses with negative offsets.  */\n-/* #define FRAME_GROWS_DOWNWARD */\n-\n /* Offset within stack frame to start allocating local variables at.\n    If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n    first local allocated.  Otherwise, it is the offset to the BEGINNING\n@@ -669,18 +661,6 @@ extern const enum reg_class reg_class_from_letter[];\n    we want to retain compatibility with older gcc versions.  */\n #define DEFAULT_PCC_STRUCT_RETURN 0\n \n-/* how we are going to return big values */\n-/*\n- * #define RETURN_IN_MEMORY(TYPE) \\\n- *   (TYPE_MODE (TYPE) == BLKmode \\\n- *    || ((TREE_CODE (TYPE) == RECORD_TYPE || TREE_CODE(TYPE) == UNION_TYPE) \\\n- *        && !(TYPE_MODE (TYPE) == SImode \\\n- * \t    || (TYPE_MODE (TYPE) == BLKmode \\\n- * \t\t&& TYPE_ALIGN (TYPE) == BITS_PER_WORD \\\n- * \t\t&& int_size_in_bytes (TYPE) == UNITS_PER_WORD))))\n- */ \n-\n-\n /* How many registers to use for struct return.  */\n #define\tRETURN_IN_MEMORY(TYPE) (int_size_in_bytes (TYPE) > 2 * UNITS_PER_WORD)\n \n@@ -939,11 +919,6 @@ extern const enum reg_class reg_class_from_letter[];\n    for the index in the tablejump instruction.  */\n #define CASE_VECTOR_MODE SImode\n \n-/* Define this if the tablejump instruction expects the table\n-   to contain offsets from the address of the table.\n-   Do not define this if the table should contain absolute addresses.  */\n-/* #define CASE_VECTOR_PC_RELATIVE */\n-\n /* 'char' is signed by default.  */\n #define DEFAULT_SIGNED_CHAR  0\n \n@@ -1030,11 +1005,9 @@ extern const enum reg_class reg_class_from_letter[];\n    ASM_DECLARE_OBJECT_NAME and then switch back to the original section\n    afterwards.  */\n #define SWITCH_SECTION_FUNCTION\t\t\t\t\t\\\n-static void switch_to_section PARAMS ((enum in_section, tree));\t\\\n+static void switch_to_section (enum in_section, tree);\t\t\\\n static void\t\t\t\t\t\t\t\\\n-switch_to_section (section, decl)\t\t\t\t\\\n-     enum in_section section;\t\t\t\t\t\\\n-     tree decl;\t\t\t\t\t\t\t\\\n+switch_to_section (enum in_section section, tree decl)\t\t\\\n {\t\t\t\t\t\t\t\t\\\n   switch (section)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\"}]}