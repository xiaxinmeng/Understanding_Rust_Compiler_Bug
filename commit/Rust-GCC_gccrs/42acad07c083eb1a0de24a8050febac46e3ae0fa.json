{"sha": "42acad07c083eb1a0de24a8050febac46e3ae0fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJhY2FkMDdjMDgzZWIxYTBkZTI0YTgwNTBmZWJhYzQ2ZTNhZTBmYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-09-26T08:45:36Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-09-26T08:45:36Z"}, "message": "trans.c (assoc_to_constructor): Minor tweaks.\n\n\t* gcc-interface/trans.c (assoc_to_constructor): Minor tweaks.\n\t* gcc-interface/utils2.c (build_simple_component_ref): Fix formatting\n\tissues.  Use COMPLETE_TYPE_P in assertion.  Also set TREE_READONLY if\n\tthe type of the record is TYPE_READONLY.\n\nFrom-SVN: r179184", "tree": {"sha": "b4120916df165fb7f745fbf1b345a23d67443257", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4120916df165fb7f745fbf1b345a23d67443257"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42acad07c083eb1a0de24a8050febac46e3ae0fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42acad07c083eb1a0de24a8050febac46e3ae0fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42acad07c083eb1a0de24a8050febac46e3ae0fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42acad07c083eb1a0de24a8050febac46e3ae0fa/comments", "author": null, "committer": null, "parents": [{"sha": "a1d7228158d344b16ef9baf8c8ed7a27649fc410", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1d7228158d344b16ef9baf8c8ed7a27649fc410", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1d7228158d344b16ef9baf8c8ed7a27649fc410"}], "stats": {"total": 87, "additions": 45, "deletions": 42}, "files": [{"sha": "ba9e61618756ed7ff65e003fd6a4cdaa4964a5bd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42acad07c083eb1a0de24a8050febac46e3ae0fa/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42acad07c083eb1a0de24a8050febac46e3ae0fa/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=42acad07c083eb1a0de24a8050febac46e3ae0fa", "patch": "@@ -1,3 +1,10 @@\n+2011-09-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (assoc_to_constructor): Minor tweaks.\n+\t* gcc-interface/utils2.c (build_simple_component_ref): Fix formatting\n+\tissues.  Use COMPLETE_TYPE_P in assertion.  Also set TREE_READONLY if\n+\tthe type of the record is TYPE_READONLY.\n+\n 2011-09-26  Eric Botcazou  <ebotcazou@adacore.com>\n \t    Robert Dewar  <dewar@adacore.com>\n "}, {"sha": "de26f978a140ecb9ca98efe4a62f995fed6111b1", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42acad07c083eb1a0de24a8050febac46e3ae0fa/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42acad07c083eb1a0de24a8050febac46e3ae0fa/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=42acad07c083eb1a0de24a8050febac46e3ae0fa", "patch": "@@ -7728,24 +7728,21 @@ process_type (Entity_Id gnat_entity)\n     }\n }\n \f\n-/* GNAT_ENTITY is the type of the resulting constructors,\n-   GNAT_ASSOC is the front of the Component_Associations of an N_Aggregate,\n-   and GNU_TYPE is the GCC type of the corresponding record.\n-\n-   Return a CONSTRUCTOR to build the record.  */\n+/* GNAT_ENTITY is the type of the resulting constructor, GNAT_ASSOC is the\n+   front of the Component_Associations of an N_Aggregate and GNU_TYPE is the\n+   GCC type of the corresponding record type.  Return the CONSTRUCTOR.  */\n \n static tree\n assoc_to_constructor (Entity_Id gnat_entity, Node_Id gnat_assoc, tree gnu_type)\n {\n-  tree gnu_list, gnu_result;\n+  tree gnu_list = NULL_TREE, gnu_result;\n \n   /* We test for GNU_FIELD being empty in the case where a variant\n      was the last thing since we don't take things off GNAT_ASSOC in\n      that case.  We check GNAT_ASSOC in case we have a variant, but it\n      has no fields.  */\n \n-  for (gnu_list = NULL_TREE; Present (gnat_assoc);\n-       gnat_assoc = Next (gnat_assoc))\n+  for (; Present (gnat_assoc); gnat_assoc = Next (gnat_assoc))\n     {\n       Node_Id gnat_field = First (Choices (gnat_assoc));\n       tree gnu_field = gnat_to_gnu_field_decl (Entity (gnat_field));\n@@ -7762,8 +7759,8 @@ assoc_to_constructor (Entity_Id gnat_entity, Node_Id gnat_assoc, tree gnu_type)\n \tcontinue;\n \n       /* Also ignore discriminants of Unchecked_Unions.  */\n-      else if (Is_Unchecked_Union (gnat_entity)\n-\t       && Ekind (Entity (gnat_field)) == E_Discriminant)\n+      if (Is_Unchecked_Union (gnat_entity)\n+\t  && Ekind (Entity (gnat_field)) == E_Discriminant)\n \tcontinue;\n \n       /* Before assigning a value in an aggregate make sure range checks\n@@ -7780,13 +7777,9 @@ assoc_to_constructor (Entity_Id gnat_entity, Node_Id gnat_assoc, tree gnu_type)\n   gnu_result = extract_values (gnu_list, gnu_type);\n \n #ifdef ENABLE_CHECKING\n-  {\n-    tree gnu_field;\n-\n-    /* Verify every entry in GNU_LIST was used.  */\n-    for (gnu_field = gnu_list; gnu_field; gnu_field = TREE_CHAIN (gnu_field))\n-      gcc_assert (TREE_ADDRESSABLE (gnu_field));\n-  }\n+  /* Verify that every entry in GNU_LIST was used.  */\n+  for (; gnu_list; gnu_list = TREE_CHAIN (gnu_list))\n+    gcc_assert (TREE_ADDRESSABLE (gnu_list));\n #endif\n \n   return gnu_result;"}, {"sha": "b9906b1f4652ed290425cff3eee9d63657ad60bd", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42acad07c083eb1a0de24a8050febac46e3ae0fa/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42acad07c083eb1a0de24a8050febac46e3ae0fa/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=42acad07c083eb1a0de24a8050febac46e3ae0fa", "patch": "@@ -1756,14 +1756,15 @@ build_simple_component_ref (tree record_variable, tree component,\n   gcc_assert ((TREE_CODE (record_type) == RECORD_TYPE\n \t       || TREE_CODE (record_type) == UNION_TYPE\n \t       || TREE_CODE (record_type) == QUAL_UNION_TYPE)\n-\t      && TYPE_SIZE (record_type)\n-\t      && (component != 0) != (field != 0));\n+\t      && COMPLETE_TYPE_P (record_type)\n+\t      && (component == NULL_TREE) != (field == NULL_TREE));\n \n-  /* If no field was specified, look for a field with the specified name\n-     in the current record only.  */\n+  /* If no field was specified, look for a field with the specified name in\n+     the current record only.  */\n   if (!field)\n-    for (field = TYPE_FIELDS (record_type); field;\n-\t field = TREE_CHAIN (field))\n+    for (field = TYPE_FIELDS (record_type);\n+\t field;\n+\t field = DECL_CHAIN (field))\n       if (DECL_NAME (field) == component)\n \tbreak;\n \n@@ -1777,7 +1778,8 @@ build_simple_component_ref (tree record_variable, tree component,\n       tree new_field;\n \n       /* First loop thru normal components.  */\n-      for (new_field = TYPE_FIELDS (record_type); new_field;\n+      for (new_field = TYPE_FIELDS (record_type);\n+\t   new_field;\n \t   new_field = DECL_CHAIN (new_field))\n \tif (SAME_FIELD_P (field, new_field))\n \t  break;\n@@ -1797,12 +1799,12 @@ build_simple_component_ref (tree record_variable, tree component,\n \t    return ref;\n \t}\n \n-      /* Next, loop thru DECL_INTERNAL_P components if we haven't found\n-         the component in the first search. Doing this search in 2 steps\n-         is required to avoiding hidden homonymous fields in the\n-         _Parent field.  */\n+      /* Next, loop thru DECL_INTERNAL_P components if we haven't found the\n+\t component in the first search.  Doing this search in two steps is\n+\t required to avoid hidden homonymous fields in the _Parent field.  */\n       if (!new_field)\n-\tfor (new_field = TYPE_FIELDS (record_type); new_field;\n+\tfor (new_field = TYPE_FIELDS (record_type);\n+\t     new_field;\n \t     new_field = DECL_CHAIN (new_field))\n \t  if (DECL_INTERNAL_P (new_field))\n \t    {\n@@ -1811,7 +1813,6 @@ build_simple_component_ref (tree record_variable, tree component,\n \t\t\t\t\t      NULL_TREE, new_field, no_fold_p);\n \t      ref = build_simple_component_ref (field_ref, NULL_TREE, field,\n \t\t\t\t\t\tno_fold_p);\n-\n \t      if (ref)\n \t\treturn ref;\n \t    }\n@@ -1822,16 +1823,15 @@ build_simple_component_ref (tree record_variable, tree component,\n   if (!field)\n     return NULL_TREE;\n \n-  /* If the field's offset has overflowed, do not attempt to access it\n-     as doing so may trigger sanity checks deeper in the back-end.\n-     Note that we don't need to warn since this will be done on trying\n-     to declare the object.  */\n+  /* If the field's offset has overflowed, do not try to access it, as doing\n+     so may trigger sanity checks deeper in the back-end.  Note that we don't\n+     need to warn since this will be done on trying to declare the object.  */\n   if (TREE_CODE (DECL_FIELD_OFFSET (field)) == INTEGER_CST\n       && TREE_OVERFLOW (DECL_FIELD_OFFSET (field)))\n     return NULL_TREE;\n \n-  /* Look through conversion between type variants.  Note that this\n-     is transparent as far as the field is concerned.  */\n+  /* Look through conversion between type variants.  This is transparent as\n+     far as the field is concerned.  */\n   if (TREE_CODE (record_variable) == VIEW_CONVERT_EXPR\n       && TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (record_variable, 0)))\n \t == record_type)\n@@ -1842,9 +1842,13 @@ build_simple_component_ref (tree record_variable, tree component,\n   ref = build3 (COMPONENT_REF, TREE_TYPE (field), inner_variable, field,\n \t\tNULL_TREE);\n \n-  if (TREE_READONLY (record_variable) || TREE_READONLY (field))\n+  if (TREE_READONLY (record_variable)\n+      || TREE_READONLY (field)\n+      || TYPE_READONLY (record_type))\n     TREE_READONLY (ref) = 1;\n-  if (TREE_THIS_VOLATILE (record_variable) || TREE_THIS_VOLATILE (field)\n+\n+  if (TREE_THIS_VOLATILE (record_variable)\n+      || TREE_THIS_VOLATILE (field)\n       || TYPE_VOLATILE (record_type))\n     TREE_THIS_VOLATILE (ref) = 1;\n \n@@ -1853,8 +1857,8 @@ build_simple_component_ref (tree record_variable, tree component,\n \n   /* The generic folder may punt in this case because the inner array type\n      can be self-referential, but folding is in fact not problematic.  */\n-  else if (TREE_CODE (record_variable) == CONSTRUCTOR\n-\t   && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (record_variable)))\n+  if (TREE_CODE (record_variable) == CONSTRUCTOR\n+      && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (record_variable)))\n     {\n       VEC(constructor_elt,gc) *elts = CONSTRUCTOR_ELTS (record_variable);\n       unsigned HOST_WIDE_INT idx;\n@@ -1865,8 +1869,7 @@ build_simple_component_ref (tree record_variable, tree component,\n       return ref;\n     }\n \n-  else\n-    return fold (ref);\n+  return fold (ref);\n }\n \f\n /* Like build_simple_component_ref, except that we give an error if the"}]}