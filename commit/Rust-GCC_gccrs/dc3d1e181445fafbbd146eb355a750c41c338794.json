{"sha": "dc3d1e181445fafbbd146eb355a750c41c338794", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMzZDFlMTgxNDQ1ZmFmYmJkMTQ2ZWIzNTVhNzUwYzQxYzMzODc5NA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-07-30T02:06:33Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-07-30T02:06:33Z"}, "message": "c++: constraints and explicit instantiation [PR96164]\n\nWhen considering to instantiate a member of a class template as part of\nan explicit instantiation of the class template, we need to first check\nthe member's constraints before proceeding with the instantiation of the\nmember.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/96164\n\t* constraint.cc (constraints_satisfied_p): Return true if\n\t!flags_concepts.\n\t* pt.c (do_type_instantiation): Update a paragraph taken from\n\t[temp.explicit] to reflect the latest specification.  Don't\n\tinstantiate a member with unsatisfied constraints.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/96164\n\t* g++.dg/cpp2a/concepts-explicit-inst5.C: New test.", "tree": {"sha": "ee9484d0ba615f7e8127a51efd6025ace0f0dade", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee9484d0ba615f7e8127a51efd6025ace0f0dade"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc3d1e181445fafbbd146eb355a750c41c338794", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc3d1e181445fafbbd146eb355a750c41c338794", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc3d1e181445fafbbd146eb355a750c41c338794", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc3d1e181445fafbbd146eb355a750c41c338794/comments", "author": null, "committer": null, "parents": [{"sha": "bea7a39103a5a86d5daabfff746316dfd4e42b3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bea7a39103a5a86d5daabfff746316dfd4e42b3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bea7a39103a5a86d5daabfff746316dfd4e42b3d"}], "stats": {"total": 43, "additions": 31, "deletions": 12}, "files": [{"sha": "e4aace596e7c1919ee45f629671bdf527b56a5bb", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3d1e181445fafbbd146eb355a750c41c338794/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3d1e181445fafbbd146eb355a750c41c338794/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=dc3d1e181445fafbbd146eb355a750c41c338794", "patch": "@@ -2864,6 +2864,9 @@ constraint_satisfaction_value (tree t, tree args, tsubst_flags_t complain)\n bool\n constraints_satisfied_p (tree t)\n {\n+  if (!flag_concepts)\n+    return true;\n+\n   return constraint_satisfaction_value (t, tf_none) == boolean_true_node;\n }\n \n@@ -2873,6 +2876,9 @@ constraints_satisfied_p (tree t)\n bool\n constraints_satisfied_p (tree t, tree args)\n {\n+  if (!flag_concepts)\n+    return true;\n+\n   return constraint_satisfaction_value (t, args, tf_none) == boolean_true_node;\n }\n "}, {"sha": "9b4e6ce7d89d9d13188f473919a7437f9ecbf04d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3d1e181445fafbbd146eb355a750c41c338794/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3d1e181445fafbbd146eb355a750c41c338794/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=dc3d1e181445fafbbd146eb355a750c41c338794", "patch": "@@ -24928,23 +24928,22 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n \n \t [temp.explicit]\n \n-\t The explicit instantiation of a class template specialization\n-\t implies the instantiation of all of its members not\n-\t previously explicitly specialized in the translation unit\n-\t containing the explicit instantiation.\n-\n-     Of course, we can't instantiate member template classes, since we\n-     don't have any arguments for them.  Note that the standard is\n-     unclear on whether the instantiation of the members are\n-     *explicit* instantiations or not.  However, the most natural\n-     interpretation is that it should be an explicit\n-     instantiation.  */\n+\t An explicit instantiation that names a class template\n+\t specialization is also an explicit instantiation of the same\n+\t kind (declaration or definition) of each of its members (not\n+\t including members inherited from base classes and members\n+\t that are templates) that has not been previously explicitly\n+\t specialized in the translation unit containing the explicit\n+\t instantiation, provided that the associated constraints, if\n+\t any, of that member are satisfied by the template arguments\n+\t of the explicit instantiation.  */\n   for (tree fld = TYPE_FIELDS (t); fld; fld = DECL_CHAIN (fld))\n     if ((VAR_P (fld)\n \t || (TREE_CODE (fld) == FUNCTION_DECL\n \t     && !static_p\n \t     && user_provided_p (fld)))\n-\t&& DECL_TEMPLATE_INSTANTIATION (fld))\n+\t&& DECL_TEMPLATE_INSTANTIATION (fld)\n+\t&& constraints_satisfied_p (fld))\n       {\n \tmark_decl_instantiated (fld, extern_p);\n \tif (! extern_p)"}, {"sha": "05959a8972c89a26625bfc6b41d3cd24dca991bc", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-explicit-inst5.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3d1e181445fafbbd146eb355a750c41c338794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-inst5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3d1e181445fafbbd146eb355a750c41c338794/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-inst5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-explicit-inst5.C?ref=dc3d1e181445fafbbd146eb355a750c41c338794", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/96164\n+// { dg-do compile { target concepts } }\n+\n+template <int N>\n+struct A {\n+    void f() requires (N == 3) { static_assert(N == 3); }\n+};\n+template struct A<2>;\n+\n+template <int N>\n+struct B {\n+    void f() requires (N == 2) { static_assert(N == 3); } // { dg-error \"assert\" }\n+};\n+template struct B<2>;"}]}