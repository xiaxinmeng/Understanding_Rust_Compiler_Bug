{"sha": "7a403706e45630a078966ef89131dddae077515a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E0MDM3MDZlNDU2MzBhMDc4OTY2ZWY4OTEzMWRkZGFlMDc3NTE1YQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-09-12T16:19:18Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-09-12T16:19:18Z"}, "message": "* haifa-sched.c: Fix formatting.\n\nFrom-SVN: r36367", "tree": {"sha": "e0c2ac8de4a27fefe226c3833955a4e281c92cbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0c2ac8de4a27fefe226c3833955a4e281c92cbb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a403706e45630a078966ef89131dddae077515a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a403706e45630a078966ef89131dddae077515a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a403706e45630a078966ef89131dddae077515a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a403706e45630a078966ef89131dddae077515a/comments", "author": null, "committer": null, "parents": [{"sha": "2ee7b20c8140006a4f0daf0b2fcd0c6250973c34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ee7b20c8140006a4f0daf0b2fcd0c6250973c34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ee7b20c8140006a4f0daf0b2fcd0c6250973c34"}], "stats": {"total": 203, "additions": 85, "deletions": 118}, "files": [{"sha": "dcf1028093cf599b815f03bb04e3171e42fafe60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a403706e45630a078966ef89131dddae077515a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a403706e45630a078966ef89131dddae077515a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a403706e45630a078966ef89131dddae077515a", "patch": "@@ -18,6 +18,8 @@ Tue Sep 12 08:53:57 2000  Jeffrey A Law  (law@cygnus.com)\n \n 2000-09-12  Kazu Hirata  <kazu@hxi.com>\n \n+\t* haifa-sched.c: Fix formatting.\n+\n \t* genattrtab.c: Fix formatting.\n \n \t* unroll.c: Fix formatting."}, {"sha": "248f1d8da2b5e52b27ca9af06ab8ee42d9895d61", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 83, "deletions": 118, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a403706e45630a078966ef89131dddae077515a/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a403706e45630a078966ef89131dddae077515a/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=7a403706e45630a078966ef89131dddae077515a", "patch": "@@ -21,7 +21,6 @@ along with GNU CC; see the file COPYING.  If not, write to the Free\n the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n-\n /* Instruction scheduling pass.\n \n    This pass implements list scheduling within basic blocks.  It is\n@@ -214,7 +213,6 @@ static int sched_verbose = 0;\n /* nr_inter/spec counts interblock/speculative motion for the function.  */\n static int nr_inter, nr_spec;\n \n-\n /* Debugging file.  All printouts are sent to dump, which is always set,\n    either to stderr, or to the dump listing file (-dRS).  */\n static FILE *dump = 0;\n@@ -308,7 +306,7 @@ static int reg_pending_sets_all;\n    branches for typical C code.  So we can make a guess that the average\n    basic block is approximately 5 instructions long; we will choose 100X\n    the average size as a very large basic block.\n-  \n+\n    Each insn has an associated bitmap for its dependencies.  Each bitmap\n    has enough entries to represent a dependency on any other insn in the\n    insn chain.  */\n@@ -323,7 +321,7 @@ struct haifa_insn_data\n      it represents forward dependancies.  */\n   rtx depend;\n \n-  /* The line number note in effect for each insn.  For line number \n+  /* The line number note in effect for each insn.  For line number\n      notes, this indicates whether the note may be reused.  */\n   rtx line_note;\n \n@@ -484,7 +482,7 @@ static int insn_cost PARAMS ((rtx, rtx, rtx));\n static int priority PARAMS ((rtx));\n static void free_pending_lists PARAMS ((void));\n static void add_insn_mem_dependence PARAMS ((struct deps *, rtx *, rtx *, rtx,\n-\t\t\t\t\t    rtx));\n+\t\t\t\t\t     rtx));\n static void flush_pending_lists PARAMS ((struct deps *, rtx, int));\n static void sched_analyze_1 PARAMS ((struct deps *, rtx, rtx));\n static void sched_analyze_2 PARAMS ((struct deps *, rtx, rtx));\n@@ -502,12 +500,12 @@ static void adjust_priority PARAMS ((rtx));\n \n /* Control flow graph edges are kept in circular lists.  */\n typedef struct\n-  {\n-    int from_block;\n-    int to_block;\n-    int next_in;\n-    int next_out;\n-  }\n+{\n+  int from_block;\n+  int to_block;\n+  int next_in;\n+  int next_out;\n+}\n haifa_edge;\n static haifa_edge *edge_table;\n \n@@ -527,21 +525,18 @@ static int *out_edges;\n #define IN_EDGES(block) (in_edges[block])\n #define OUT_EDGES(block) (out_edges[block])\n \n-\n-\n static int is_cfg_nonregular PARAMS ((void));\n static int build_control_flow PARAMS ((struct edge_list *));\n static void new_edge PARAMS ((int, int));\n \n-\n /* A region is the main entity for interblock scheduling: insns\n    are allowed to move between blocks in the same region, along\n    control flow graph edges, in the 'up' direction.  */\n typedef struct\n-  {\n-    int rgn_nr_blocks;\t\t/* Number of blocks in region.  */\n-    int rgn_blocks;\t\t/* cblocks in the region (actually index in rgn_bb_table).  */\n-  }\n+{\n+  int rgn_nr_blocks;\t\t/* Number of blocks in region.  */\n+  int rgn_blocks;\t\t/* cblocks in the region (actually index in rgn_bb_table).  */\n+}\n region;\n \n /* Number of regions in the procedure.  */\n@@ -581,16 +576,15 @@ static int current_blocks;\n /* The mapping from bb to block.  */\n #define BB_TO_BLOCK(bb) (rgn_bb_table[current_blocks + (bb)])\n \n-\n /* Bit vectors and bitset operations are needed for computations on\n    the control flow graph.  */\n \n typedef unsigned HOST_WIDE_INT *bitset;\n typedef struct\n-  {\n-    int *first_member;\t\t/* Pointer to the list start in bitlst_table.  */\n-    int nr_members;\t\t/* The number of members of the bit list.  */\n-  }\n+{\n+  int *first_member;\t\t/* Pointer to the list start in bitlst_table.  */\n+  int nr_members;\t\t/* The number of members of the bit list.  */\n+}\n bitlst;\n \n static int bitlst_table_last;\n@@ -608,13 +602,13 @@ static void extract_bitlst PARAMS ((bitset, int, int, bitlst *));\n    about such sources: are they valid?  Speculative?  Etc.  */\n typedef bitlst bblst;\n typedef struct\n-  {\n-    char is_valid;\n-    char is_speculative;\n-    int src_prob;\n-    bblst split_bbs;\n-    bblst update_bbs;\n-  }\n+{\n+  char is_valid;\n+  char is_speculative;\n+  int src_prob;\n+  bblst split_bbs;\n+  bblst update_bbs;\n+}\n candidate;\n \n static candidate *candidate_table;\n@@ -644,7 +638,6 @@ static void compute_trg_info PARAMS ((int));\n void debug_candidate PARAMS ((int));\n void debug_candidates PARAMS ((int));\n \n-\n /* Bit-set of bbs, where bit 'i' stands for bb 'i'.  */\n typedef bitset bbset;\n \n@@ -769,7 +762,7 @@ static rtx reemit_notes PARAMS ((rtx, rtx));\n static void get_block_head_tail PARAMS ((int, rtx *, rtx *));\n static void get_bb_head_tail PARAMS ((int, rtx *, rtx *));\n \n-static int queue_to_ready PARAMS ((rtx [], int));\n+static int queue_to_ready PARAMS ((rtx[], int));\n \n static void debug_ready_list PARAMS ((rtx[], int));\n static void init_target_units PARAMS ((void));\n@@ -819,7 +812,7 @@ add_dependence (insn, elem, dep_type)\n      such dependency is useless and can be ignored.  */\n   if (GET_CODE (elem) == NOTE)\n     return;\n-\t\n+\n   /* If elem is part of a sequence that must be scheduled together, then\n      make the dependence point to the last insn of the sequence.\n      When HAVE_cc0, it is possible for NOTEs to exist between users and\n@@ -881,7 +874,7 @@ add_dependence (insn, elem, dep_type)\n #ifdef INSN_SCHEDULING\n \t/* If we are adding a true dependency to INSN's LOG_LINKs, then\n \t   note that in the bitmap cache of true dependency information.  */\n-\tif ((int)dep_type == 0 && true_dependency_cache)\n+\tif ((int) dep_type == 0 && true_dependency_cache)\n \t  SET_BIT (true_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem));\n #endif\n \treturn;\n@@ -897,7 +890,7 @@ add_dependence (insn, elem, dep_type)\n #ifdef INSN_SCHEDULING\n   /* If we are adding a true dependency to INSN's LOG_LINKs, then\n      note that in the bitmap cache of true dependency information.  */\n-  if ((int)dep_type == 0 && true_dependency_cache)\n+  if ((int) dep_type == 0 && true_dependency_cache)\n     SET_BIT (true_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem));\n #endif\n }\n@@ -1134,7 +1127,6 @@ build_control_flow (edge_list)\n   return unreachable;\n }\n \n-\n /* Record an edge in the control flow graph from SOURCE to TARGET.\n \n    In theory, this is redundant with the s_succs computed above, but\n@@ -1194,7 +1186,6 @@ new_edge (source, target)\n     }\n }\n \n-\n /* BITSET macros for operations on the control flow graph.  */\n \n /* Compute bitwise union of two bitsets.  */\n@@ -1245,7 +1236,6 @@ do { register bitset tmpset = set;                                   \\\n       ~(1 << (index%HOST_BITS_PER_WIDE_INT));                        \\\n }\n \n-\n /* Check if the index'th bit in bitset set is on.  */\n \n static char\n@@ -1259,7 +1249,6 @@ bitset_member (set, index, len)\n \t  1 << (index % HOST_BITS_PER_WIDE_INT)) ? 1 : 0;\n }\n \n-\n /* Translate a bit-set SET to a list BL of the bit-set members.  */\n \n static void\n@@ -1300,7 +1289,6 @@ extract_bitlst (set, len, bitlen, bl)\n \n }\n \n-\n /* Functions for the construction of regions.  */\n \n /* Print the regions, for debugging purposes.  Callable from debugger.  */\n@@ -1331,7 +1319,6 @@ debug_regions ()\n     }\n }\n \n-\n /* Build a single block region for each basic block in the function.\n    This allows for using the same code for interblock and basic block\n    scheduling.  */\n@@ -1352,7 +1339,6 @@ find_single_block_region ()\n   nr_regions = n_basic_blocks;\n }\n \n-\n /* Update number of blocks and the estimate for number of insns\n    in the region.  Return 1 if the region is \"too large\" for interblock\n    scheduling (compile time considerations), otherwise return 0.  */\n@@ -1370,7 +1356,6 @@ too_large (block, num_bbs, num_insns)\n     return 0;\n }\n \n-\n /* Update_loop_relations(blk, hdr): Check if the loop headed by max_hdr[blk]\n    is still an inner loop.  Put in max_hdr[blk] the header of the most inner\n    loop containing blk.  */\n@@ -1387,7 +1372,6 @@ too_large (block, num_bbs, num_insns)\n          }                                                           \\\n }\n \n-\n /* Find regions for interblock scheduling.\n \n    A region for scheduling can be:\n@@ -1398,7 +1382,6 @@ too_large (block, num_bbs, num_insns)\n \n      * A basic block not contained in any other region.\n \n-\n    ?!? In theory we could build other regions based on extended basic\n    blocks or reverse extended basic blocks.  Is it worth the trouble?\n \n@@ -1413,7 +1396,6 @@ too_large (block, num_bbs, num_insns)\n      * block_to_bb\n      * containing region\n \n-\n    We use dominator relationships to avoid making regions out of non-reducible\n    loops.\n \n@@ -1441,10 +1423,10 @@ find_rgns (edge_list, dom)\n   /* Note if a block is an natural inner loop header.  */\n   sbitmap inner;\n \n-  /* Note if a block is in the block queue. */\n+  /* Note if a block is in the block queue.  */\n   sbitmap in_queue;\n \n-  /* Note if a block is in the block queue. */\n+  /* Note if a block is in the block queue.  */\n   sbitmap in_stack;\n \n   int num_edges = NUM_EDGES (edge_list);\n@@ -1556,7 +1538,7 @@ find_rgns (edge_list, dom)\n \t out edge.  However, if the node has no out edge then we will\n \t not set dfs_nr for that node.  This can confuse the scheduler\n \t into thinking that we have unreachable blocks, which in turn\n-\t disables cross block scheduling. \n+\t disables cross block scheduling.\n \n \t So, if we have a node with no out edges, go ahead and mark it\n \t as reachable now.  */\n@@ -1627,7 +1609,7 @@ find_rgns (edge_list, dom)\n \t\t If there exists a block that is not dominated by the loop\n \t\t header, then the block is reachable from outside the loop\n \t\t and thus the loop is not a natural loop.  */\n-\t      for (j = 0; j < n_basic_blocks; j++)\t\n+\t      for (j = 0; j < n_basic_blocks; j++)\n \t\t{\n \t\t  /* First identify blocks in the loop, except for the loop\n \t\t     entry block.  */\n@@ -1660,10 +1642,9 @@ find_rgns (edge_list, dom)\n \n \t      /* Estimate # insns, and count # blocks in the region.  */\n \t      num_bbs = 1;\n-\t      num_insns\t= (INSN_LUID (BLOCK_END (i))\n+\t      num_insns = (INSN_LUID (BLOCK_END (i))\n \t\t\t   - INSN_LUID (BLOCK_HEAD (i)));\n \n-\n \t      /* Find all loop latches (blocks with back edges to the loop\n \t\t header) or all the leaf blocks in the cfg has no loops.\n \n@@ -1710,7 +1691,6 @@ find_rgns (edge_list, dom)\n \t\t\t      break;\n \t\t\t    }\n \t\t\t}\n-\t\t      \n \t\t    }\n \t\t}\n \n@@ -1725,7 +1705,6 @@ find_rgns (edge_list, dom)\n \t\t c\t  a,d\n \t\t d\t  b\n \n-\n \t     The algorithm in the DFS traversal may not mark B & D as part\n \t     of the loop (ie they will not have max_hdr set to A).\n \n@@ -1744,7 +1723,7 @@ find_rgns (edge_list, dom)\n \n \t     We do not do this because I'm not sure that the actual\n \t     scheduling code will properly handle this case. ?!? */\n-\t\n+\n \t      while (head < tail && !too_large_failure)\n \t\t{\n \t\t  edge e;\n@@ -1843,7 +1822,6 @@ find_rgns (edge_list, dom)\n   free (in_stack);\n }\n \n-\n /* Functions for regions scheduling information.  */\n \n /* Compute dominators, probability, and potential-split-edges of bb.\n@@ -1921,8 +1899,9 @@ compute_dom_prob_ps (bb)\n   BITSET_DIFFER (pot_split[bb], ancestor_edges[bb], edgeset_size);\n \n   if (sched_verbose >= 2)\n-    fprintf (dump, \";;  bb_prob(%d, %d) = %3d\\n\", bb, BB_TO_BLOCK (bb), (int) (100.0 * prob[bb]));\n-}\t\t\t\t/* compute_dom_prob_ps */\n+    fprintf (dump, \";;  bb_prob(%d, %d) = %3d\\n\", bb, BB_TO_BLOCK (bb),\n+\t     (int) (100.0 * prob[bb]));\n+}\n \n /* Functions for target info.  */\n \n@@ -1945,7 +1924,6 @@ split_edges (bb_src, bb_trg, bl)\n   free (src);\n }\n \n-\n /* Find the valid candidate-source-blocks for the target block TRG, compute\n    their probability, and check if they are speculative or not.\n    For speculative sources, compute their update-blocks and split-blocks.  */\n@@ -2024,8 +2002,7 @@ compute_trg_info (trg)\n \t  sp->src_prob = 0;\n \t}\n     }\n-}\t\t\t\t/* compute_trg_info */\n-\n+}\n \n /* Print candidates info, for debugging purposes.  Callable from debugger.  */\n \n@@ -2065,7 +2042,6 @@ debug_candidate (i)\n     }\n }\n \n-\n /* Print candidates info, for debugging purposes.  Callable from debugger.  */\n \n void\n@@ -2080,7 +2056,6 @@ debug_candidates (trg)\n     debug_candidate (i);\n }\n \n-\n /* Functions for speculative scheduing.  */\n \n /* Return 0 if x is a set of a register alive in the beginning of one\n@@ -2161,7 +2136,6 @@ check_live_1 (src, x)\n   return 1;\n }\n \n-\n /* If x is a set of a register R, mark that R is alive in the beginning\n    of every update-block of src.  */\n \n@@ -2227,7 +2201,6 @@ update_live_1 (src, x)\n     }\n }\n \n-\n /* Return 1 if insn can be speculatively moved from block src to trg,\n    otherwise return 0.  Called before first insertion of insn to\n    ready-list or before the scheduling.  */\n@@ -2256,7 +2229,6 @@ check_live (insn, src)\n   return 1;\n }\n \n-\n /* Update the live registers info after insn was moved speculatively from\n    block src to trg.  */\n \n@@ -2586,8 +2558,7 @@ may_trap_exp (x, is_store)\n \t}\n       return insn_class;\n     }\n-}\t\t\t\t/* may_trap_exp */\n-\n+}\n \n /* Classifies insn for the purpose of verifying that it can be\n    moved speculatively, by examining it's patterns, returning:\n@@ -2628,7 +2599,7 @@ haifa_classify_insn (insn)\n \t      /* Test if it is a load.  */\n \t      tmp_class =\n \t\tWORST_CLASS (tmp_class,\n-\t\t\t   may_trap_exp (SET_SRC (XVECEXP (pat, 0, i)), 0));\n+\t\t\t     may_trap_exp (SET_SRC (XVECEXP (pat, 0, i)), 0));\n \t      break;\n \t    case COND_EXEC:\n \t    case TRAP_IF:\n@@ -2670,8 +2641,7 @@ haifa_classify_insn (insn)\n     }\n \n   return insn_class;\n-\n-}\t\t\t\t/* haifa_classify_insn */\n+}\n \n /* Return 1 if load_insn is prisky (i.e. if load_insn is fed by\n    a load moved speculatively, or if load_insn is protected by\n@@ -2693,7 +2663,7 @@ is_prisky (load_insn, bb_src, bb_trg)\n     return 1;\n \n   return 0;\n-}\t\t\t\t/* is_prisky */\n+}\n \n /* Insn is a candidate to be moved speculatively from bb_src to bb_trg.\n    Return 1 if insn is exception-free (and the motion is valid)\n@@ -2739,8 +2709,7 @@ is_exception_free (insn, bb_src, bb_trg)\n     }\n \n   return flag_schedule_speculative_load_dangerous;\n-}\t\t\t\t/* is_exception_free */\n-\n+}\n \n /* Process an insn's memory dependencies.  There are four kinds of\n    dependencies:\n@@ -2772,7 +2741,6 @@ find_insn_mem_list (insn, x, list, list1)\n   return 0;\n }\n \n-\n /* Compute the function units used by INSN.  This caches the value\n    returned by function_units_used.  A function unit is encoded as the\n    unit number if the value is non-negative and the compliment of a\n@@ -3163,7 +3131,6 @@ priority (insn)\n   return this_priority;\n }\n \f\n-\n /* Remove all INSN_LISTs and EXPR_LISTs from the pending lists and add\n    them to the unused_*_list variables, so that they can be reused.  */\n \n@@ -3279,7 +3246,7 @@ sched_analyze_1 (deps, x, insn)\n     }\n \n   while (GET_CODE (dest) == STRICT_LOW_PART || GET_CODE (dest) == SUBREG\n-      || GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == SIGN_EXTRACT)\n+\t || GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == SIGN_EXTRACT)\n     {\n       if (GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == SIGN_EXTRACT)\n \t{\n@@ -3318,9 +3285,9 @@ sched_analyze_1 (deps, x, insn)\n \t      if (code == SET)\n \t\t{\n \t\t  free_INSN_LIST_list (&deps->reg_last_uses[r]);\n-\t          for (u = deps->reg_last_clobbers[r]; u; u = XEXP (u, 1))\n+\t\t  for (u = deps->reg_last_clobbers[r]; u; u = XEXP (u, 1))\n \t\t    add_dependence (insn, XEXP (u, 0), REG_DEP_OUTPUT);\n-\t          SET_REGNO_REG_SET (reg_pending_sets, r);\n+\t\t  SET_REGNO_REG_SET (reg_pending_sets, r);\n \t\t}\n \t      else\n \t\tSET_REGNO_REG_SET (reg_pending_clobbers, r);\n@@ -3539,7 +3506,7 @@ sched_analyze_2 (deps, x, insn)\n \twhile (pending)\n \t  {\n \t    if (true_dependence (XEXP (pending_mem, 0), VOIDmode,\n-\t\tx, rtx_varies_p))\n+\t\t\t\t x, rtx_varies_p))\n \t      add_dependence (insn, XEXP (pending, 0), 0);\n \n \t    pending = XEXP (pending, 1);\n@@ -3791,11 +3758,11 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n \n   /* If a post-call group is still open, see if it should remain so.\n      This insn must be a simple move of a hard reg to a pseudo or\n-     vice-versa. \n+     vice-versa.\n \n      We must avoid moving these insns for correctness on\n      SMALL_REGISTER_CLASS machines, and for special registers like\n-     PIC_OFFSET_TABLE_REGNUM.  For simplicity, extend this to all \n+     PIC_OFFSET_TABLE_REGNUM.  For simplicity, extend this to all\n      hard regs for all targets.  */\n \n   if (deps->in_post_call_group_p)\n@@ -3961,13 +3928,13 @@ sched_analyze (deps, head, tail)\n \t  free_INSN_LIST_list (&deps->last_function_call);\n \t  deps->last_function_call = alloc_INSN_LIST (insn, NULL_RTX);\n \n-\t  /* Before reload, begin a post-call group, so as to keep the \n+\t  /* Before reload, begin a post-call group, so as to keep the\n \t     lifetimes of hard registers correct.  */\n \t  if (! reload_completed)\n \t    deps->in_post_call_group_p = 1;\n \t}\n \n-      /* See comments on reemit_notes as to why we do this.  \n+      /* See comments on reemit_notes as to why we do this.\n \t ??? Actually, the reemit_notes just say what is done, not why.  */\n \n       else if (GET_CODE (insn) == NOTE\n@@ -4030,13 +3997,12 @@ rank_for_schedule (x, y)\n      const PTR x;\n      const PTR y;\n {\n-  rtx tmp = *(const rtx *)y;\n-  rtx tmp2 = *(const rtx *)x;\n+  rtx tmp = *(const rtx *) y;\n+  rtx tmp2 = *(const rtx *) x;\n   rtx link;\n   int tmp_class, tmp2_class, depend_count1, depend_count2;\n   int val, priority_val, spec_val, prob_val, weight_val;\n \n-\n   /* Prefer insn with higher priority.  */\n   priority_val = INSN_PRIORITY (tmp2) - INSN_PRIORITY (tmp);\n   if (priority_val)\n@@ -4094,7 +4060,7 @@ rank_for_schedule (x, y)\n \treturn val;\n     }\n \n-  /* Prefer the insn which has more later insns that depend on it. \n+  /* Prefer the insn which has more later insns that depend on it.\n      This gives the scheduler more freedom when scheduling later\n      instructions at the expense of added register pressure.  */\n   depend_count1 = 0;\n@@ -4108,7 +4074,7 @@ rank_for_schedule (x, y)\n   val = depend_count2 - depend_count1;\n   if (val)\n     return val;\n-  \n+\n   /* If insns are equally good, sort by INSN_LUID (original insn order),\n      so that we make the sort stable.  This minimizes instruction movement,\n      thus minimizing sched's effect on debugging and cross-jumping.  */\n@@ -4171,7 +4137,7 @@ adjust_priority (prev)\n {\n   /* ??? There used to be code here to try and estimate how an insn\n      affected register lifetimes, but it did it by looking at REG_DEAD\n-     notes, which we removed in schedule_region.  Nor did it try to \n+     notes, which we removed in schedule_region.  Nor did it try to\n      take into account register pressure or anything useful like that.\n \n      Revisit when we have a machine model to work with and not before.  */\n@@ -4248,7 +4214,7 @@ schedule_insn (insn, ready, n_ready, clock)\n \n \t  if (sched_verbose >= 2)\n \t    {\n-\t      fprintf (dump, \";;\\t\\tdependences resolved: insn %d \", \n+\t      fprintf (dump, \";;\\t\\tdependences resolved: insn %d \",\n \t\t       INSN_UID (next));\n \n \t      if (current_nr_blocks > 1 && INSN_BB (next) != target_bb)\n@@ -4270,7 +4236,7 @@ schedule_insn (insn, ready, n_ready, clock)\n \t}\n     }\n \n-  /* Annotate the instruction with issue information -- TImode \n+  /* Annotate the instruction with issue information -- TImode\n      indicates that the instruction is expected not to be able\n      to issue on the same cycle as the previous insn.  A machine\n      may use this information to decide how the instruction should\n@@ -4470,7 +4436,6 @@ save_line_notes (bb)\n       LINE_NOTE (insn) = line;\n }\n \n-\n /* After bb was scheduled, insert line notes into the insns list.  */\n \n static void\n@@ -4629,7 +4594,7 @@ rm_other_notes (head, tail)\n \n static void\n find_insn_reg_weight (b)\n-    int b;\n+     int b;\n {\n   rtx insn, next_tail, head, tail;\n \n@@ -4725,7 +4690,8 @@ queue_to_ready (ready, n_ready)\n \t\t  q_size -= 1;\n \n \t\t  if (sched_verbose >= 2)\n-\t\t    fprintf (dump, \";;\\t\\tQ-->Ready: insn %d: \", INSN_UID (insn));\n+\t\t    fprintf (dump, \";;\\t\\tQ-->Ready: insn %d: \",\n+\t\t\t     INSN_UID (insn));\n \n \t\t  if (sched_verbose >= 2 && INSN_BB (insn) != target_bb)\n \t\t    fprintf (dump, \"(b%d) \", BLOCK_NUM (insn));\n@@ -4904,14 +4870,14 @@ print_exp (buf, x, verbose)\n   char tmp[BUF_LEN];\n   const char *st[4];\n   char *cur = buf;\n-  const char *fun = (char *)0;\n+  const char *fun = (char *) 0;\n   const char *sep;\n   rtx op[4];\n   int i;\n \n   for (i = 0; i < 4; i++)\n     {\n-      st[i] = (char *)0;\n+      st[i] = (char *) 0;\n       op[i] = NULL_RTX;\n     }\n \n@@ -5259,7 +5225,7 @@ print_value (buf, x, verbose)\n       cur = safe_concat (buf, cur, t);\n       break;\n     case CONST_DOUBLE:\n-      sprintf (t, \"<0x%lx,0x%lx>\", (long)XWINT (x, 2), (long)XWINT (x, 3));\n+      sprintf (t, \"<0x%lx,0x%lx>\", (long) XWINT (x, 2), (long) XWINT (x, 3));\n       cur = safe_concat (buf, cur, t);\n       break;\n     case CONST_STRING:\n@@ -5291,11 +5257,11 @@ print_value (buf, x, verbose)\n     case REG:\n       if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n \t{\n-\t  int c = reg_names[ REGNO (x) ][0];\n+\t  int c = reg_names[REGNO (x)][0];\n \t  if (c >= '0' && c <= '9')\n \t    cur = safe_concat (buf, cur, \"%\");\n \n-\t  cur = safe_concat (buf, cur, reg_names[ REGNO (x) ]);\n+\t  cur = safe_concat (buf, cur, reg_names[REGNO (x)]);\n \t}\n       else\n \t{\n@@ -5861,7 +5827,7 @@ schedule_block (bb, rgn_n_insns)\n   /* Prepare current target block info.  */\n   if (current_nr_blocks > 1)\n     {\n-      candidate_table = (candidate *) xmalloc (current_nr_blocks \n+      candidate_table = (candidate *) xmalloc (current_nr_blocks\n \t\t\t\t\t       * sizeof (candidate));\n \n       bblst_last = 0;\n@@ -5889,7 +5855,6 @@ schedule_block (bb, rgn_n_insns)\n   if (sched_verbose >= 5)\n     debug_dependencies ();\n \n-\n   /* Initialize ready list with all 'ready' insns in target block.\n      Count number of insns in the target block being scheduled.  */\n   n_ready = 0;\n@@ -5938,7 +5903,7 @@ schedule_block (bb, rgn_n_insns)\n \t      {\n \t\trtx next;\n \n-\t\t/* Note that we havn't squirrled away the notes for \n+\t\t/* Note that we havn't squirrled away the notes for\n \t\t   blocks other than the current.  So if this is a\n \t\t   speculative insn, NEXT might otherwise be a note.  */\n \t\tnext = next_nonnote_insn (insn);\n@@ -5999,7 +5964,7 @@ schedule_block (bb, rgn_n_insns)\n       /* Sort the ready list based on priority.  */\n       SCHED_SORT (ready, n_ready);\n \n-      /* Allow the target to reorder the list, typically for \n+      /* Allow the target to reorder the list, typically for\n \t better instruction bundling.  */\n #ifdef MD_SCHED_REORDER\n       MD_SCHED_REORDER (dump, sched_verbose, ready, n_ready, clock_var,\n@@ -6048,8 +6013,8 @@ schedule_block (bb, rgn_n_insns)\n \t      nr_inter++;\n \n \t      /* Find the beginning of the scheduling group.  */\n-\t      /* ??? Ought to update basic block here, but later bits of \n-\t\t schedule_block assumes the original insn block is \n+\t      /* ??? Ought to update basic block here, but later bits of\n+\t\t schedule_block assumes the original insn block is\n \t\t still intact.  */\n \n \t      temp = insn;\n@@ -6174,9 +6139,8 @@ schedule_block (bb, rgn_n_insns)\n   free (ready);\n \n   return (sched_n_insns);\n-}\t\t\t\t/* schedule_block () */\n+}\n \f\n-\n /* Print the bit-set of registers, S, callable from debugger.  */\n \n extern void\n@@ -6483,7 +6447,7 @@ propagate_deps (bb, tmp_deps, max_reg)\n       /* last_pending_memory_flush is inherited by bb_succ.  */\n       for (u = tmp_deps->last_pending_memory_flush; u; u = XEXP (u, 1))\n \t{\n-\t  if (find_insn_list (XEXP (u, 0), \n+\t  if (find_insn_list (XEXP (u, 0),\n \t\t\t      succ_deps->last_pending_memory_flush))\n \t    continue;\n \n@@ -6541,9 +6505,9 @@ compute_block_backward_dependences (bb)\n \n   /* Free up the INSN_LISTs.\n \n-     Note this loop is executed max_reg * nr_regions times.  It's first \n+     Note this loop is executed max_reg * nr_regions times.  It's first\n      implementation accounted for over 90% of the calls to free_INSN_LIST_list.\n-     The list was empty for the vast majority of those calls.  On the PA, not \n+     The list was empty for the vast majority of those calls.  On the PA, not\n      calling free_INSN_LIST_list in those cases improves -O2 compile times by\n      3-5% on average.  */\n   for (i = 0; i < max_reg; ++i)\n@@ -6749,7 +6713,7 @@ schedule_region (rgn)\n       edgeset_size = rgn_nr_edges / HOST_BITS_PER_WIDE_INT + 1;\n       edgeset_bitsize = rgn_nr_edges;\n       pot_split = (edgeset *) xmalloc (current_nr_blocks * sizeof (edgeset));\n-      ancestor_edges \n+      ancestor_edges\n \t= (edgeset *) xmalloc (current_nr_blocks * sizeof (edgeset));\n       for (i = 0; i < current_nr_blocks; i++)\n \t{\n@@ -6872,7 +6836,7 @@ schedule_insns (dump_file)\n \tif (insn == BLOCK_END (b))\n \t  break;\n       }\n-  \n+\n   /* ?!? We could save some memory by computing a per-region luid mapping\n      which could reduce both the number of vectors in the cache and the size\n      of each vector.  Instead we just avoid the cache entirely unless the\n@@ -7007,7 +6971,7 @@ schedule_insns (dump_file)\n     {\n       sbitmap_zero (blocks);\n       for (b = RGN_NR_BLOCKS (rgn) - 1; b >= 0; --b)\n-\tSET_BIT (blocks, rgn_bb_table [RGN_BLOCKS (rgn) + b]);\n+\tSET_BIT (blocks, rgn_bb_table[RGN_BLOCKS (rgn) + b]);\n \n       deaths_in_region[rgn] = count_or_remove_death_notes (blocks, 1);\n     }\n@@ -7027,7 +6991,7 @@ schedule_insns (dump_file)\n \n      I'm fairly certain that this _shouldn't_ happen, since I don't think\n      that live_at_start should change at region heads.  Not sure what the\n-     best way to test for this kind of thing... */\n+     best way to test for this kind of thing...  */\n \n   allocate_reg_life_data ();\n   compute_bb_for_insn (max_uid);\n@@ -7057,14 +7021,14 @@ schedule_insns (dump_file)\n \t/* In the single block case, the count of registers that died should\n \t   not have changed during the schedule.  */\n \tif (count_or_remove_death_notes (blocks, 0) != deaths_in_region[rgn])\n-          abort ();\n+\t  abort ();\n #endif\n       }\n \n   if (any_large_regions)\n     {\n       update_life_info (large_region_blocks, UPDATE_LIFE_GLOBAL,\n-\t\t        PROP_DEATH_NOTES | PROP_REG_INFO);\n+\t\t\tPROP_DEATH_NOTES | PROP_REG_INFO);\n     }\n \n   /* Reposition the prologue and epilogue notes in case we moved the\n@@ -7080,7 +7044,8 @@ schedule_insns (dump_file)\n     {\n       if (reload_completed == 0 && flag_schedule_interblock)\n \t{\n-\t  fprintf (dump, \"\\n;; Procedure interblock/speculative motions == %d/%d \\n\",\n+\t  fprintf (dump,\n+\t\t   \"\\n;; Procedure interblock/speculative motions == %d/%d \\n\",\n \t\t   nr_inter, nr_spec);\n \t}\n       else"}]}