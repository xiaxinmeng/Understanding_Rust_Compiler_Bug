{"sha": "682e805aafd694fda5be69267d11a260de607aa6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjgyZTgwNWFhZmQ2OTRmZGE1YmU2OTI2N2QxMWEyNjBkZTYwN2FhNg==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-10-24T17:23:19Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-10-24T17:23:19Z"}, "message": "Makefile.in (OBJC_SOURCE_FILES): Added accessors.m.\n\n2010-10-24  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * Makefile.in (OBJC_SOURCE_FILES): Added accessors.m.\n        * accessors.m: New.\n        * init.c: Include objc-private/accessors.h.\n        (__objc_exec_class): Call __objc_accessors_init.\n        * objc-private/accessors.h: New.\n\nFrom-SVN: r165903", "tree": {"sha": "a3b3ae3b676280309507a41528069c3672f970fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3b3ae3b676280309507a41528069c3672f970fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/682e805aafd694fda5be69267d11a260de607aa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/682e805aafd694fda5be69267d11a260de607aa6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/682e805aafd694fda5be69267d11a260de607aa6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/682e805aafd694fda5be69267d11a260de607aa6/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0f237806af83d337bde05c3fb079385c8cdbd09c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f237806af83d337bde05c3fb079385c8cdbd09c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f237806af83d337bde05c3fb079385c8cdbd09c"}], "stats": {"total": 330, "additions": 330, "deletions": 0}, "files": [{"sha": "ebcecfa3d2e74f802b5a035bf31dad0177633fe1", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/682e805aafd694fda5be69267d11a260de607aa6/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/682e805aafd694fda5be69267d11a260de607aa6/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=682e805aafd694fda5be69267d11a260de607aa6", "patch": "@@ -1,3 +1,11 @@\n+2010-10-24  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* Makefile.in (OBJC_SOURCE_FILES): Added accessors.m.\n+\t* accessors.m: New.\n+\t* init.c: Include objc-private/accessors.h.\n+\t(__objc_exec_class): Call __objc_accessors_init.\n+\t* objc-private/accessors.h: New.\n+\n 2010-10-17  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc/message.h: Moved initial includes outside of extern \"C\"."}, {"sha": "437764f49980bb6aa872a87872114f2446337091", "filename": "libobjc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/682e805aafd694fda5be69267d11a260de607aa6/libobjc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/682e805aafd694fda5be69267d11a260de607aa6/libobjc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FMakefile.in?ref=682e805aafd694fda5be69267d11a260de607aa6", "patch": "@@ -163,6 +163,7 @@ OBJC_SOURCE_FILES = \\\n    NXConstStr.m \\\n    Object.m \\\n    Protocol.m \\\n+   accessors.m \\\n    linking.m\n \n # C source files to compile"}, {"sha": "d6469ea7ce50ef8f3564b87eafe5caf22bac8ecc", "filename": "libobjc/accessors.m", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/682e805aafd694fda5be69267d11a260de607aa6/libobjc%2Faccessors.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/682e805aafd694fda5be69267d11a260de607aa6/libobjc%2Faccessors.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Faccessors.m?ref=682e805aafd694fda5be69267d11a260de607aa6", "patch": "@@ -0,0 +1,279 @@\n+/* GNU Objective C Runtime accessors functions\n+   Copyright (C) 2010 Free Software Foundation, Inc.\n+   Contributed by Nicola Pero\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 3, or (at your option) any later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"objc-private/common.h\"\n+#include \"objc/objc.h\"\n+#include \"objc/thr.h\"\n+#include <string.h>                    /* For memcpy */\n+\n+/* This file contains functions that the compiler uses when\n+   synthesizing accessors (getters/setters) for properties.  The\n+   functions are part of the ABI, but are meant to be used by the\n+   compiler and not by users; for this reason, they are not declared\n+   in public header files.  The compiler automatically generates\n+   declarations for these functions.  */\n+\n+/* Properties can be \"atomic\", which requires protecting them from\n+   concurrency issues using a lock.  Unfortunately, we can't have a\n+   lock for each property, so we'll go with a small pool of locks.\n+   Any time a property is accessed in an \"atomic\" way, we pick a\n+   random lock from the pool (random, but always the same one for the\n+   same property of the same object) and use it to protect access to\n+   the property.\n+\n+   The size of the pool is currently 16.  A bigger pool can help\n+   reduce contention, ie, reduce the chances that two threads,\n+   operating on unrelated properties, will have to wait for each other\n+   because the properties use the same lock.  16 seems big enough at\n+   the moment.  */\n+#define ACCESSORS_NUMBER_OF_LOCKS 16\n+\n+#define ACCESSORS_HASH(POINTER) ((((size_t)POINTER >> 8) ^ (size_t)POINTER) & (ACCESSORS_NUMBER_OF_LOCKS - 1))\n+\n+static objc_mutex_t accessors_locks[ACCESSORS_NUMBER_OF_LOCKS];\n+\n+/* This is called at startup to setup the locks.  */\n+void\n+__objc_accessors_init (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < ACCESSORS_NUMBER_OF_LOCKS; i++)\n+    accessors_locks[i] = objc_mutex_allocate ();\n+}\n+\n+/* The property accessors automatically call various methods from the\n+   Foundation library (eg, GNUstep-base).  These methods are not\n+   implemented here, but we need to declare them so we can compile the\n+   runtime.  The Foundation library will need to provide\n+   implementations of these methods (most likely in the root class,\n+   eg, NSObject) as the accessors only work with objects of classes\n+   that implement these methods.  */\n+@interface _libobjcNSObject\n+- (id) copyWithZone: (void *)zone;\n+- (id) mutableCopyWithZone: (void *)zone;\n+@end\n+#define COPY(X)         [((_libobjcNSObject *)(X)) copyWithZone: NULL]\n+#define MUTABLE_COPY(X) [((_libobjcNSObject *)(X)) mutableCopyWithZone: NULL]\n+\n+\n+#if OBJC_WITH_GC\n+\n+#  define AUTORELEASE(X)  (X)\n+#  define RELEASE(X)\n+#  define RETAIN(X)       (X)\n+\n+#else\n+\n+@interface _libobjcNSObject (RetainReleaseMethods)\n+- (id) autorelease;\n+- (oneway void) release;\n+- (id) retain;\n+@end\n+#  define AUTORELEASE(X)  [((_libobjcNSObject *)(X)) autorelease]\n+#  define RELEASE(X)      [((_libobjcNSObject *)(X)) release]\n+#  define RETAIN(X)       [((_libobjcNSObject *)(X)) retain]\n+\n+#endif\n+\n+/* The compiler uses this function when implementing some synthesized\n+   getters for properties of type 'id'.  */\n+id\n+objc_getProperty (id self, SEL __attribute__((unused)) _cmd, ptrdiff_t offset, BOOL is_atomic)\n+{\n+  if (self != nil)\n+    {\n+      id *pointer_to_ivar = (id *)((char *)self + offset);\n+\n+      if (is_atomic == NO)\n+\treturn AUTORELEASE (RETAIN (*pointer_to_ivar));\n+      else\n+\t{\n+\t  objc_mutex_t lock = accessors_locks[ACCESSORS_HASH (pointer_to_ivar)];\n+\t  id result;\n+\t  \n+\t  objc_mutex_lock (lock);\n+\t  result = RETAIN (*(pointer_to_ivar));\n+\t  objc_mutex_unlock (lock);\n+\t  \n+\t  return AUTORELEASE (result);\n+\t}\n+    }\n+\n+  return nil;\n+}\n+\n+/* The compiler uses this function when implementing some synthesized\n+   setters for properties of type 'id'.\n+\n+   PS: Note how 'should_copy' is declared 'BOOL' but then actually\n+   takes values from 0 to 2.  This hack was introduced by Apple; we\n+   do the same for compatibility reasons.  */\n+void\n+objc_setProperty (id self, SEL __attribute__((unused)) _cmd, ptrdiff_t offset, id new_value, BOOL is_atomic, BOOL should_copy)\n+{\n+  if (self != nil)\n+    {\n+      id *pointer_to_ivar = (id *)((char *)self + offset);\n+      id retained_value;\n+#if !OBJC_WITH_GC\n+      id old_value;\n+#endif\n+\n+      switch (should_copy)\n+\t{\n+\tcase 0: /* retain */\n+\t  {\n+\t    if (*pointer_to_ivar == new_value)\n+\t      return;\n+\t    retained_value = RETAIN (new_value);\n+\t    break;\n+\t  }\n+\tcase 2: /* mutable copy */\n+\t  {\n+\t    retained_value = MUTABLE_COPY (new_value);\n+\t    break;\n+\t  }\n+\tcase 1: /* copy */\n+\tdefault:\n+\t  {\n+\t    retained_value = COPY (new_value);\n+\t    break;\n+\t  }\n+\t}\n+\n+      if (is_atomic == NO)\n+\t{\n+#if !OBJC_WITH_GC\n+\t  old_value = *pointer_to_ivar;\n+#endif\n+\t  *pointer_to_ivar = retained_value;\n+\t}\n+      else\n+\t{\n+\t  objc_mutex_t lock = accessors_locks[ACCESSORS_HASH (pointer_to_ivar)];\n+\n+\t  objc_mutex_lock (lock);\n+#if !OBJC_WITH_GC\n+\t  old_value = *pointer_to_ivar;\n+#endif\n+\t  *pointer_to_ivar = retained_value;\n+\t  objc_mutex_unlock (lock);\n+\t}\n+#if !OBJC_WITH_GC\n+      RELEASE (old_value);\n+#endif\n+    }\n+}\n+\n+/* The compiler uses this function when implementing some synthesized\n+   getters for properties of arbitrary C types.  The data is just\n+   copied.  Compatibility Note: this function does not exist in the\n+   Apple/NeXT runtime.  */\n+void\n+objc_getPropertyStruct (void *destination, const void *source, ptrdiff_t size, BOOL is_atomic, BOOL __attribute__((unused)) has_strong)\n+{\n+  if (is_atomic == NO)\n+    memcpy (destination, source, size);\n+  else\n+    {\n+      objc_mutex_t lock = accessors_locks[ACCESSORS_HASH (source)];\n+\n+      objc_mutex_lock (lock);\n+      memcpy (destination, source, size);\n+      objc_mutex_unlock (lock);\n+    }\n+}\n+\n+/* The compiler uses this function when implementing some synthesized\n+   setters for properties of arbitrary C types.  The data is just\n+   copied.  Compatibility Note: this function does not exist in the\n+   Apple/NeXT runtime.  */\n+void\n+objc_setPropertyStruct (void *destination, const void *source, ptrdiff_t size, BOOL is_atomic, BOOL __attribute__((unused)) has_strong)\n+{\n+  if (is_atomic == NO)\n+    memcpy (destination, source, size);\n+  else\n+    {\n+      objc_mutex_t lock = accessors_locks[ACCESSORS_HASH (destination)];\n+\n+      objc_mutex_lock (lock);\n+      memcpy (destination, source, size);\n+      objc_mutex_unlock (lock);\n+    }\n+}\n+\n+/* This is the function that the Apple/NeXT runtime has instead of\n+   objc_getPropertyStruct and objc_setPropertyStruct.  We include it\n+   for API compatibility (just for people who may have used\n+   objc_copyStruct on the NeXT runtime thinking it was a public API);\n+   the compiler never generates calls to it with the GNU runtime.\n+   This function is clumsy because it requires two locks instead of\n+   one.  */\n+void\n+objc_copyStruct (void *destination, const void *source, ptrdiff_t size, BOOL is_atomic, BOOL __attribute__((unused)) has_strong)\n+{\n+  if (is_atomic == NO)\n+    memcpy (destination, source, size);\n+  else\n+    {\n+      /* We don't know which one is the property, so we have to lock\n+\t both.  One of them is most likely a temporary buffer in the\n+\t local stack and we really wouldn't want to lock it (our\n+\t objc_getPropertyStruct and objc_setPropertyStruct functions\n+\t don't lock it).  Note that if we're locking more than one\n+\t accessor lock at once, we need to always lock them in the\n+\t same order to avoid deadlocks.  */\n+      objc_mutex_t first_lock;\n+      objc_mutex_t second_lock;\n+\n+      if (ACCESSORS_HASH (source) == ACCESSORS_HASH (destination))\n+\t{\n+\t  /* A lucky collision.  */\n+\t  first_lock = accessors_locks[ACCESSORS_HASH (source)];\n+\t  objc_mutex_lock (first_lock);\n+\t  memcpy (destination, source, size);\n+\t  objc_mutex_unlock (first_lock);\n+\t  return;\n+\t}\n+\n+      if (ACCESSORS_HASH (source) > ACCESSORS_HASH (destination))\n+\t{\n+\t  first_lock = accessors_locks[ACCESSORS_HASH (source)];\n+\t  second_lock = accessors_locks[ACCESSORS_HASH (destination)];\n+\t}\n+      else\n+\t{\n+\t  first_lock = accessors_locks[ACCESSORS_HASH (destination)];\n+\t  second_lock = accessors_locks[ACCESSORS_HASH (source)];\t  \n+\t}\n+\n+      objc_mutex_lock (first_lock);\n+      objc_mutex_lock (second_lock);\n+      memcpy (destination, source, size);\n+      objc_mutex_unlock (second_lock);\n+      objc_mutex_unlock (first_lock);\n+    }\n+}"}, {"sha": "b348e77d0fd1a75cf22e64707fc43d86aad8a3ff", "filename": "libobjc/init.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/682e805aafd694fda5be69267d11a260de607aa6/libobjc%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/682e805aafd694fda5be69267d11a260de607aa6/libobjc%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Finit.c?ref=682e805aafd694fda5be69267d11a260de607aa6", "patch": "@@ -35,6 +35,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"objc-private/protocols.h\" /* For __objc_protocols_init(),\n \t\t\t\t       __objc_protocols_add_protocol()\n \t\t\t\t       __objc_protocols_register_selectors() */\n+#include \"objc-private/accessors.h\" /* For __objc_accessors_init() */\n \n /* The version number of this runtime.  This must match the number \n    defined in gcc (objc-act.c).  */\n@@ -582,6 +583,7 @@ __objc_exec_class (Module_t module)\n \t\t\t\t\t   (hash_func_type)objc_hash_ptr,\n \t\t\t\t\t   objc_compare_ptrs);\n       __objc_protocols_init ();\n+      __objc_accessors_init ();\n       __objc_sync_init ();\n       previous_constructors = 1;\n     }"}, {"sha": "a7bcca226495cc0f415d4d58adfae20c68e2d7a9", "filename": "libobjc/objc-private/accessors.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/682e805aafd694fda5be69267d11a260de607aa6/libobjc%2Fobjc-private%2Faccessors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/682e805aafd694fda5be69267d11a260de607aa6/libobjc%2Fobjc-private%2Faccessors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc-private%2Faccessors.h?ref=682e805aafd694fda5be69267d11a260de607aa6", "patch": "@@ -0,0 +1,40 @@\n+/* GNU Objective C Runtime accessors - Private Declarations\n+   Copyright (C) 2010 Free Software Foundation, Inc.\n+   Contributed by Nicola Pero <nicola.pero@meta-innovation.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 3, or (at your option) any later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef __objc_private_accessors_INCLUDE_GNU\n+#define __objc_private_accessors_INCLUDE_GNU\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif /* __cplusplus */\n+\n+/* This function needs to be called at startup by init.c.  */\n+void\n+__objc_accessors_init (void);\n+\n+#ifdef __cplusplus\n+}\n+#endif /* __cplusplus */\n+\n+#endif /* not __objc_private_accessors_INCLUDE_GNU */"}]}