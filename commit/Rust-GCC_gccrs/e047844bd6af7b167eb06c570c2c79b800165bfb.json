{"sha": "e047844bd6af7b167eb06c570c2c79b800165bfb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA0Nzg0NGJkNmFmN2IxNjdlYjA2YzU3MGMyYzc5YjgwMDE2NWJmYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-01-19T12:59:51Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-01-19T12:59:51Z"}, "message": "Claw back some of the code size regression in 548.exchange2_r\n\nThis patch tries harder to detect cases in which the inner dimension\nof an array access is invariant, such as:\n\n     x(i, :) = 100\n\nIt fixes some of the code size regression in 548.exchange2_r, with\nsize improving by 5% compared to before the patch.  Of the two other\nSPEC 2017 tests affected by loop versioning, 554.roms_r improved by a\ntrivial amount (0.3%) and 549.fotonik3d_r didn't change.  All three\nresults are with -Ofast -flto.\n\n2019-01-19  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* gimple-loop-versioning.cc (loop_versioning::dump_inner_likelihood):\n\tNew function, split out from...\n\t(loop_versioning::analyze_stride): ...here.\n\t(loop_versioning::find_per_loop_multiplication): Use gassign.\n\t(loop_versioning::analyze_term_using_scevs): Return a success code.\n\t(loop_versioning::analyze_arbitrary_term): New function.\n\t(loop_versioning::analyze_address_fragment): Use\n\tanalyze_arbitrary_term if all else fails.\n\ngcc/testsuite/\n\t* gfortran.dg/loop_versioning_1.f90: Bump the number of identified\n\tinner strides.\n\t* gfortran.dg/loop_versioning_9.f90: New test.\n\t* gfortran.dg/loop_versioning_10.f90: Likewise.\n\nFrom-SVN: r268093", "tree": {"sha": "5e8d6419785057f060ac589573af4aa2ace012dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e8d6419785057f060ac589573af4aa2ace012dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e047844bd6af7b167eb06c570c2c79b800165bfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e047844bd6af7b167eb06c570c2c79b800165bfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e047844bd6af7b167eb06c570c2c79b800165bfb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e047844bd6af7b167eb06c570c2c79b800165bfb/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b9e25708aa6fbe8fed641882bbdde4410d7c6d61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9e25708aa6fbe8fed641882bbdde4410d7c6d61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9e25708aa6fbe8fed641882bbdde4410d7c6d61"}], "stats": {"total": 178, "additions": 158, "deletions": 20}, "files": [{"sha": "4a4a8ed973c3d8c2b3c800bdaef6a131bbe39aba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e047844bd6af7b167eb06c570c2c79b800165bfb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e047844bd6af7b167eb06c570c2c79b800165bfb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e047844bd6af7b167eb06c570c2c79b800165bfb", "patch": "@@ -1,3 +1,14 @@\n+2019-01-19  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gimple-loop-versioning.cc (loop_versioning::dump_inner_likelihood):\n+\tNew function, split out from...\n+\t(loop_versioning::analyze_stride): ...here.\n+\t(loop_versioning::find_per_loop_multiplication): Use gassign.\n+\t(loop_versioning::analyze_term_using_scevs): Return a success code.\n+\t(loop_versioning::analyze_arbitrary_term): New function.\n+\t(loop_versioning::analyze_address_fragment): Use\n+\tanalyze_arbitrary_term if all else fails.\n+\n 2019-01-18  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR target/88892"}, {"sha": "2f7cda9c8cb6b2ee5cfcf0ce134bd673d69f50c4", "filename": "gcc/gimple-loop-versioning.cc", "status": "modified", "additions": 77, "deletions": 19, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e047844bd6af7b167eb06c570c2c79b800165bfb/gcc%2Fgimple-loop-versioning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e047844bd6af7b167eb06c570c2c79b800165bfb/gcc%2Fgimple-loop-versioning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-versioning.cc?ref=e047844bd6af7b167eb06c570c2c79b800165bfb", "patch": "@@ -294,10 +294,12 @@ class loop_versioning\n   bool acceptable_type_p (tree, unsigned HOST_WIDE_INT *);\n   bool multiply_term_by (address_term_info &, tree);\n   inner_likelihood get_inner_likelihood (tree, unsigned HOST_WIDE_INT);\n+  void dump_inner_likelihood (address_info &, address_term_info &);\n   void analyze_stride (address_info &, address_term_info &,\n \t\t       tree, struct loop *);\n   bool find_per_loop_multiplication (address_info &, address_term_info &);\n-  void analyze_term_using_scevs (address_info &, address_term_info &);\n+  bool analyze_term_using_scevs (address_info &, address_term_info &);\n+  void analyze_arbitrary_term (address_info &, address_term_info &);\n   void analyze_address_fragment (address_info &);\n   void record_address_fragment (gimple *, unsigned HOST_WIDE_INT,\n \t\t\t\ttree, unsigned HOST_WIDE_INT, HOST_WIDE_INT);\n@@ -803,6 +805,24 @@ loop_versioning::get_inner_likelihood (tree stride,\n   return unlikely_p ? INNER_UNLIKELY : INNER_DONT_KNOW;\n }\n \n+/* Dump the likelihood that TERM's stride is for the innermost dimension.\n+   ADDRESS is the address that contains TERM.  */\n+\n+void\n+loop_versioning::dump_inner_likelihood (address_info &address,\n+\t\t\t\t\taddress_term_info &term)\n+{\n+  if (term.inner_likelihood == INNER_LIKELY)\n+    dump_printf_loc (MSG_NOTE, address.stmt, \"%T is likely to be the\"\n+\t\t     \" innermost dimension\\n\", term.stride);\n+  else if (term.inner_likelihood == INNER_UNLIKELY)\n+    dump_printf_loc (MSG_NOTE, address.stmt, \"%T is probably not the\"\n+\t\t     \" innermost dimension\\n\", term.stride);\n+  else\n+    dump_printf_loc (MSG_NOTE, address.stmt, \"cannot tell whether %T\"\n+\t\t     \" is the innermost dimension\\n\", term.stride);\n+}\n+\n /* The caller has identified that STRIDE is the stride of interest\n    in TERM, and that the stride is applied in OP_LOOP.  Record this\n    information in TERM, deciding whether STRIDE is likely to be for\n@@ -818,17 +838,7 @@ loop_versioning::analyze_stride (address_info &address,\n \n   term.inner_likelihood = get_inner_likelihood (stride, term.multiplier);\n   if (dump_enabled_p ())\n-    {\n-      if (term.inner_likelihood == INNER_LIKELY)\n-\tdump_printf_loc (MSG_NOTE, address.stmt, \"%T is likely to be the\"\n-\t\t\t \" innermost dimension\\n\", stride);\n-      else if (term.inner_likelihood == INNER_UNLIKELY)\n-\tdump_printf_loc (MSG_NOTE, address.stmt, \"%T is probably not the\"\n-\t\t\t \" innermost dimension\\n\", stride);\n-      else\n-\tdump_printf_loc (MSG_NOTE, address.stmt, \"cannot tell whether %T\"\n-\t\t\t \" is the innermost dimension\\n\", stride);\n-    }\n+    dump_inner_likelihood (address, term);\n \n   /* To be a versioning opportunity we require:\n \n@@ -879,7 +889,7 @@ bool\n loop_versioning::find_per_loop_multiplication (address_info &address,\n \t\t\t\t\t       address_term_info &term)\n {\n-  gimple *mult = maybe_get_assign (term.expr);\n+  gassign *mult = maybe_get_assign (term.expr);\n   if (!mult || gimple_assign_rhs_code (mult) != MULT_EXPR)\n     return false;\n \n@@ -909,25 +919,25 @@ loop_versioning::find_per_loop_multiplication (address_info &address,\n }\n \n /* Try to use scalar evolutions to find an address stride for TERM,\n-   which belongs to ADDRESS.\n+   which belongs to ADDRESS.  Return true and update TERM if so.\n \n    Here we are interested in any evolution information we can find,\n    not just evolutions wrt ADDRESS->LOOP.  For example, if we find that\n    an outer loop obviously iterates over the inner dimension of an array,\n    that information can help us eliminate worthless versioning opportunities\n    in inner loops.  */\n \n-void\n+bool\n loop_versioning::analyze_term_using_scevs (address_info &address,\n \t\t\t\t\t   address_term_info &term)\n {\n   gimple *setter = maybe_get_stmt (term.expr);\n   if (!setter)\n-    return;\n+    return false;\n \n   struct loop *wrt_loop = loop_containing_stmt (setter);\n   if (!loop_outer (wrt_loop))\n-    return;\n+    return false;\n \n   tree chrec = strip_casts (analyze_scalar_evolution (wrt_loop, term.expr));\n   if (TREE_CODE (chrec) == POLYNOMIAL_CHREC)\n@@ -955,7 +965,53 @@ loop_versioning::analyze_term_using_scevs (address_info &address,\n \t}\n \n       analyze_stride (address, term, stride, get_chrec_loop (chrec));\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Address term TERM is an arbitrary term that provides no versioning\n+   opportunities.  Analyze it to see whether it contains any likely\n+   inner strides, so that we don't mistakenly version for other\n+   (less likely) candidates.\n+\n+   This copes with invariant innermost indices such as:\n+\n+     x(i, :) = 100\n+\n+   where the \"i\" component of the address is invariant in the loop\n+   but provides the real inner stride.\n+\n+   ADDRESS is the address that contains TERM.  */\n+\n+void\n+loop_versioning::analyze_arbitrary_term (address_info &address,\n+\t\t\t\t\t address_term_info &term)\n+\n+{\n+  /* A multiplication offers two potential strides.  Pick the one that\n+     is most likely to be an innermost stride.  */\n+  tree expr = term.expr, alt = NULL_TREE;\n+  gassign *mult = maybe_get_assign (expr);\n+  if (mult && gimple_assign_rhs_code (mult) == MULT_EXPR)\n+    {\n+      expr = strip_casts (gimple_assign_rhs1 (mult));\n+      alt = strip_casts (gimple_assign_rhs2 (mult));\n+    }\n+  term.stride = expr;\n+  term.inner_likelihood = get_inner_likelihood (expr, term.multiplier);\n+  if (alt)\n+    {\n+      inner_likelihood alt_l = get_inner_likelihood (alt, term.multiplier);\n+      if (alt_l > term.inner_likelihood)\n+\t{\n+\t  term.stride = alt;\n+\t  term.inner_likelihood = alt_l;\n+\t}\n     }\n+  if (dump_enabled_p ())\n+    dump_inner_likelihood (address, term);\n }\n \n /* Try to identify loop strides in ADDRESS and try to choose realistic\n@@ -1038,8 +1094,10 @@ loop_versioning::analyze_address_fragment (address_info &address)\n      find_per_loop_multiplication and analyze_term_using_scevs can handle,\n      but the former is much cheaper than SCEV analysis, so try it first.  */\n   for (unsigned int i = 0; i < address.terms.length (); ++i)\n-    if (!find_per_loop_multiplication (address, address.terms[i]))\n-      analyze_term_using_scevs (address, address.terms[i]);\n+    if (!find_per_loop_multiplication (address, address.terms[i])\n+\t&& !analyze_term_using_scevs (address, address.terms[i])\n+\t&& !POINTER_TYPE_P (TREE_TYPE (address.terms[i].expr)))\n+      analyze_arbitrary_term (address, address.terms[i]);\n \n   /* Check for strides that are likely to be for the innermost dimension.\n "}, {"sha": "2a59d1b0a4bb471e4586c2e4a53f05fa600b60c6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e047844bd6af7b167eb06c570c2c79b800165bfb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e047844bd6af7b167eb06c570c2c79b800165bfb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e047844bd6af7b167eb06c570c2c79b800165bfb", "patch": "@@ -1,3 +1,10 @@\n+2019-01-19  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gfortran.dg/loop_versioning_1.f90: Bump the number of identified\n+\tinner strides.\n+\t* gfortran.dg/loop_versioning_9.f90: New test.\n+\t* gfortran.dg/loop_versioning_10.f90: Likewise.\n+\n 2019-01-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/88902"}, {"sha": "144a193d70885f838e1c234bde2a69fb49c174f9", "filename": "gcc/testsuite/gfortran.dg/loop_versioning_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e047844bd6af7b167eb06c570c2c79b800165bfb/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e047844bd6af7b167eb06c570c2c79b800165bfb/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_1.f90?ref=e047844bd6af7b167eb06c570c2c79b800165bfb", "patch": "@@ -23,6 +23,6 @@ subroutine f3(x, limit, step)\n   end do\n end subroutine f3\n \n-! { dg-final { scan-tree-dump-times {likely to be the innermost dimension} 1 \"lversion\" } }\n+! { dg-final { scan-tree-dump-times {likely to be the innermost dimension} 2 \"lversion\" } }\n ! { dg-final { scan-tree-dump-times {want to version containing loop} 3 \"lversion\" } }\n ! { dg-final { scan-tree-dump-times {versioned this loop} 3 \"lversion\" } }"}, {"sha": "5803527bb3c19b170cb9a46616b1c55693dd9f4a", "filename": "gcc/testsuite/gfortran.dg/loop_versioning_10.f90", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e047844bd6af7b167eb06c570c2c79b800165bfb/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e047844bd6af7b167eb06c570c2c79b800165bfb/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_10.f90?ref=e047844bd6af7b167eb06c570c2c79b800165bfb", "patch": "@@ -0,0 +1,31 @@\n+! { dg-options \"-O3 -fdump-tree-lversion-details\" }\n+\n+subroutine f1(x)\n+  real :: x(:, :)\n+  x(:, 1) = 100\n+end subroutine f1\n+\n+subroutine f2(x, i)\n+  real :: x(:, :)\n+  integer :: i\n+  x(:, i) = 100\n+end subroutine f2\n+\n+subroutine f3(x)\n+  real :: x(:, :)\n+  do j = lbound(x, 1), ubound(x, 1)\n+     x(j, 1) = 100\n+  end do\n+end subroutine f3\n+\n+subroutine f4(x, i)\n+  real :: x(:, :)\n+  integer :: i\n+  do j = lbound(x, 1), ubound(x, 1)\n+     x(j, i) = 100\n+  end do\n+end subroutine f4\n+\n+! { dg-final { scan-tree-dump-times {likely to be the innermost dimension} 6 \"lversion\" } }\n+! { dg-final { scan-tree-dump-times {want to version} 4 \"lversion\" } }\n+! { dg-final { scan-tree-dump-times {versioned} 4 \"lversion\" } }"}, {"sha": "7a0fd55eaca6d736a374098c75555a2f557d62a5", "filename": "gcc/testsuite/gfortran.dg/loop_versioning_9.f90", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e047844bd6af7b167eb06c570c2c79b800165bfb/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e047844bd6af7b167eb06c570c2c79b800165bfb/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Floop_versioning_9.f90?ref=e047844bd6af7b167eb06c570c2c79b800165bfb", "patch": "@@ -0,0 +1,31 @@\n+! { dg-options \"-O3 -fdump-tree-lversion-details\" }\n+\n+subroutine f1(x)\n+  real :: x(:, :)\n+  x(1, :) = 100\n+end subroutine f1\n+\n+subroutine f2(x, i)\n+  real :: x(:, :)\n+  integer :: i\n+  x(i, :) = 100\n+end subroutine f2\n+\n+subroutine f3(x)\n+  real :: x(:, :)\n+  do j = lbound(x, 2), ubound(x, 2)\n+     x(1, j) = 100\n+  end do\n+end subroutine f3\n+\n+subroutine f4(x, i)\n+  real :: x(:, :)\n+  integer :: i\n+  do j = lbound(x, 2), ubound(x, 2)\n+     x(i, j) = 100\n+  end do\n+end subroutine f4\n+\n+! { dg-final { scan-tree-dump-times {likely to be the innermost dimension} 4 \"lversion\" } }\n+! { dg-final { scan-tree-dump-not {want to version} \"lversion\" } }\n+! { dg-final { scan-tree-dump-not {versioned} \"lversion\" } }"}]}