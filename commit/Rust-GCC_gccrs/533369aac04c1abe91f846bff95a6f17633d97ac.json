{"sha": "533369aac04c1abe91f846bff95a6f17633d97ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMzMzY5YWFjMDRjMWFiZTkxZjg0NmJmZjk1YTZmMTc2MzNkOTdhYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T10:20:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T10:20:34Z"}, "message": "[multiple changes]\n\n2013-04-11  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch6.adb: Minor reformatting.\n\n2013-04-11  Yannick Moy  <moy@adacore.com>\n\n\t* ali-util.adb (Read_Withed_ALIs): Do not consider it an error to\n\tread ALI files with No_Object=True in Alfa mode.\n\t* gnat1drv.adb: Set appropriately Back_End_Mode in Alfa mode, whether\n\tthis is during frame condition generation of translation to Why.\n\n2013-04-11  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb: Minor code reorganization\n\t* types.ads: Minor reformatting.\n\nFrom-SVN: r197759", "tree": {"sha": "d23582872d684e82a1e6aea153c21774a1fed4ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d23582872d684e82a1e6aea153c21774a1fed4ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/533369aac04c1abe91f846bff95a6f17633d97ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/533369aac04c1abe91f846bff95a6f17633d97ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/533369aac04c1abe91f846bff95a6f17633d97ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/533369aac04c1abe91f846bff95a6f17633d97ac/comments", "author": null, "committer": null, "parents": [{"sha": "3a8e3f636ac1597af351f7907ab684959d41b226", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a8e3f636ac1597af351f7907ab684959d41b226", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a8e3f636ac1597af351f7907ab684959d41b226"}], "stats": {"total": 200, "additions": 100, "deletions": 100}, "files": [{"sha": "0ed467beb5e0079655e770c3c19b4fe6f869de1b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533369aac04c1abe91f846bff95a6f17633d97ac/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533369aac04c1abe91f846bff95a6f17633d97ac/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=533369aac04c1abe91f846bff95a6f17633d97ac", "patch": "@@ -1,3 +1,19 @@\n+2013-04-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch6.adb: Minor reformatting.\n+\n+2013-04-11  Yannick Moy  <moy@adacore.com>\n+\n+\t* ali-util.adb (Read_Withed_ALIs): Do not consider it an error to\n+\tread ALI files with No_Object=True in Alfa mode.\n+\t* gnat1drv.adb: Set appropriately Back_End_Mode in Alfa mode, whether\n+\tthis is during frame condition generation of translation to Why.\n+\n+2013-04-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb: Minor code reorganization\n+\t* types.ads: Minor reformatting.\n+\n 2013-04-11  Johannes Kanig  <kanig@adacore.com>\n \n \t* opt.ads New global boolean Frame_Condition_Mode to avoid"}, {"sha": "d8b12adf47bada3efda2000013dd47a4222cb640", "filename": "gcc/ada/ali-util.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533369aac04c1abe91f846bff95a6f17633d97ac/gcc%2Fada%2Fali-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533369aac04c1abe91f846bff95a6f17633d97ac/gcc%2Fada%2Fali-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali-util.adb?ref=533369aac04c1abe91f846bff95a6f17633d97ac", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -272,7 +272,11 @@ package body ALI.Util is\n                      Error_Msg (\"{ had errors, must be fixed, and recompiled\");\n                      Set_Name_Table_Info (Afile, Int (No_Unit_Id));\n \n+                  --  In formal verification mode, object files are never\n+                  --  generated, so No_Object=True is not considered an error.\n+\n                   elsif ALIs.Table (Idread).No_Object\n+                    and then not Alfa_Mode\n                     and then not Ignore_Errors\n                   then\n                      Error_Msg_File_1 := Withs.Table (W).Sfile;"}, {"sha": "7fcad755bf9c1be3085eb13d6a55c0bda05bb837", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 60, "deletions": 91, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533369aac04c1abe91f846bff95a6f17633d97ac/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533369aac04c1abe91f846bff95a6f17633d97ac/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=533369aac04c1abe91f846bff95a6f17633d97ac", "patch": "@@ -355,6 +355,7 @@ package body Exp_Ch4 is\n          if Nkind (Op1) = N_Op_Not then\n             Arg1 := Right_Opnd (Op1);\n             Arg2 := Right_Opnd (Op2);\n+\n             if Kind = N_Op_And then\n                Proc_Name := RTE (RE_Vector_Nor);\n             elsif Kind = N_Op_Or then\n@@ -601,9 +602,8 @@ package body Exp_Ch4 is\n       Dtyp := Available_View (Designated_Type (PtrT));\n       Etyp := Etype (Expression (Orig_Node));\n \n-      if Is_Class_Wide_Type (Dtyp)\n-        and then Is_Interface (Dtyp)\n-      then\n+      if Is_Class_Wide_Type (Dtyp) and then Is_Interface (Dtyp) then\n+\n          --  If the type of the allocator expression is not an interface type\n          --  we can generate code to reference the record component containing\n          --  the pointer to the secondary dispatch table.\n@@ -641,7 +641,7 @@ package body Exp_Ch4 is\n          --  generate a run-time call to displace \"this\" to reference the\n          --  component containing the pointer to the secondary dispatch table\n          --  or else raise Constraint_Error if the actual object does not\n-         --  implement the target interface. This case corresponds with the\n+         --  implement the target interface. This case corresponds to the\n          --  following example:\n \n          --   function Op (Obj : Iface_1'Class) return access Iface_2'Class is\n@@ -1204,9 +1204,8 @@ package body Exp_Ch4 is\n             Insert_Action (N, Tag_Assign);\n          end if;\n \n-         if Needs_Finalization (DesigT)\n-            and then Needs_Finalization (T)\n-         then\n+         if Needs_Finalization (DesigT) and then Needs_Finalization (T) then\n+\n             --  Generate an Adjust call if the object will be moved. In Ada\n             --  2005, the object may be inherently limited, in which case\n             --  there is no Adjust procedure, and the object is built in\n@@ -1220,17 +1219,17 @@ package body Exp_Ch4 is\n               and then not Is_Immutably_Limited_Type (T)\n             then\n                Insert_Action (N,\n-                 Make_Adjust_Call (\n-                   Obj_Ref    =>\n \n-                     --  An unchecked conversion is needed in the classwide\n-                     --  case because the designated type can be an ancestor\n-                     --  of the subtype mark of the allocator.\n+                 --  An unchecked conversion is needed in the classwide case\n+                 --  because the designated type can be an ancestor of the\n+                 --  subtype mark of the allocator.\n \n-                     Unchecked_Convert_To (T,\n-                       Make_Explicit_Dereference (Loc,\n-                         Prefix => New_Reference_To (Temp, Loc))),\n-                   Typ => T));\n+                 Make_Adjust_Call\n+                   (Obj_Ref =>\n+                      Unchecked_Convert_To (T,\n+                        Make_Explicit_Dereference (Loc,\n+                          Prefix => New_Reference_To (Temp, Loc))),\n+                    Typ     => T));\n             end if;\n \n             --  Generate:\n@@ -1315,9 +1314,7 @@ package body Exp_Ch4 is\n          Rewrite (N, New_Reference_To (Temp, Loc));\n          Analyze_And_Resolve (N, PtrT);\n \n-      elsif Is_Access_Type (T)\n-        and then Can_Never_Be_Null (T)\n-      then\n+      elsif Is_Access_Type (T) and then Can_Never_Be_Null (T) then\n          Install_Null_Excluding_Check (Exp);\n \n       elsif Is_Access_Type (DesigT)\n@@ -2701,8 +2698,8 @@ package body Exp_Ch4 is\n                         --  discriminant(s).\n \n                         if Nkind (Lhs) = N_Selected_Component\n-                          and then Has_Per_Object_Constraint (\n-                                     Entity (Selector_Name (Lhs)))\n+                          and then Has_Per_Object_Constraint\n+                                     (Entity (Selector_Name (Lhs)))\n                         then\n                            Lhs_Discr_Val :=\n                              Make_Selected_Component (Loc,\n@@ -3336,9 +3333,7 @@ package body Exp_Ch4 is\n       --  converted to an array, and the easiest way of doing that is to go\n       --  through the normal general circuit.\n \n-      if NN = 1\n-        and then Base_Type (Etype (Operands (1))) /= Ctyp\n-      then\n+      if NN = 1 and then Base_Type (Etype (Operands (1))) /= Ctyp then\n          Result := Operands (1);\n          goto Done;\n       end if;\n@@ -4214,8 +4209,7 @@ package body Exp_Ch4 is\n       --  Expand_Allocator_Expression inherit the proper type attributes.\n \n       if (Ekind (PtrT) = E_Anonymous_Access_Type\n-           or else\n-             (Is_Itype (PtrT) and then No (Finalization_Master (PtrT))))\n+           or else (Is_Itype (PtrT) and then No (Finalization_Master (PtrT))))\n         and then Needs_Finalization (Dtyp)\n       then\n          --  Detect the allocation of an anonymous controlled object where the\n@@ -4797,9 +4791,7 @@ package body Exp_Ch4 is\n                      --    * CodePeer mode - TSS primitive Finalize_Address is\n                      --    not created in this mode.\n \n-                     elsif not Alfa_Mode\n-                       and then not CodePeer_Mode\n-                     then\n+                     elsif not (Alfa_Mode or CodePeer_Mode) then\n                         Insert_Action (N,\n                           Make_Set_Finalize_Address_Call\n                             (Loc     => Loc,\n@@ -4819,9 +4811,7 @@ package body Exp_Ch4 is\n       --  object that has been rewritten as a reference, we displace \"this\"\n       --  to reference properly its secondary dispatch table.\n \n-      if Nkind (N) = N_Identifier\n-        and then Is_Interface (Dtyp)\n-      then\n+      if Nkind (N) = N_Identifier and then Is_Interface (Dtyp) then\n          Displace_Allocator_Pointer (N);\n       end if;\n \n@@ -5101,10 +5091,10 @@ package body Exp_Ch4 is\n                   while Present (Par) loop\n                      if Is_List_Member (Par)\n                        and then\n-                          not Nkind_In (Par, N_Component_Association,\n-                                             N_Discriminant_Association,\n-                                             N_Parameter_Association,\n-                                             N_Pragma_Argument_Association)\n+                         not Nkind_In (Par, N_Component_Association,\n+                                            N_Discriminant_Association,\n+                                            N_Parameter_Association,\n+                                            N_Pragma_Argument_Association)\n                      then\n                         return Par;\n \n@@ -5667,9 +5657,7 @@ package body Exp_Ch4 is\n       --  change it to the SLOC of the expression which, after expansion, will\n       --  correspond to what is being evaluated.\n \n-      if Present (Parent (N))\n-        and then Nkind (Parent (N)) = N_If_Statement\n-      then\n+      if Present (Parent (N)) and then Nkind (Parent (N)) = N_If_Statement then\n          Set_Sloc (New_If, Sloc (Parent (N)));\n          Set_Sloc (Parent (N), Loc);\n       end if;\n@@ -6531,7 +6519,7 @@ package body Exp_Ch4 is\n                return;\n \n             elsif Nkind_In (Parnt, N_Indexed_Component, N_Selected_Component)\n-               and then Prefix (Parnt) = Child\n+              and then Prefix (Parnt) = Child\n             then\n                null;\n \n@@ -6643,8 +6631,8 @@ package body Exp_Ch4 is\n       --  Deal with software overflow checking\n \n       if not Backend_Overflow_Checks_On_Target\n-         and then Is_Signed_Integer_Type (Etype (N))\n-         and then Do_Overflow_Check (N)\n+        and then Is_Signed_Integer_Type (Etype (N))\n+        and then Do_Overflow_Check (N)\n       then\n          --  The only case to worry about is when the argument is equal to the\n          --  largest negative number, so what we do is to insert the check:\n@@ -6881,9 +6869,8 @@ package body Exp_Ch4 is\n       --  We cannot do this transformation in configurable run time mode if we\n       --  have 64-bit integers and long shifts are not available.\n \n-        and then\n-          (Esize (Ltyp) <= 32\n-             or else Support_Long_Shifts_On_Target)\n+        and then (Esize (Ltyp) <= 32\n+                   or else Support_Long_Shifts_On_Target)\n       then\n          Rewrite (N,\n            Make_Op_Shift_Right (Loc,\n@@ -6934,17 +6921,13 @@ package body Exp_Ch4 is\n       --  Mixed-mode operations can appear in a non-static universal context,\n       --  in which case the integer argument must be converted explicitly.\n \n-      elsif Typ = Universal_Real\n-        and then Is_Integer_Type (Rtyp)\n-      then\n+      elsif Typ = Universal_Real and then Is_Integer_Type (Rtyp) then\n          Rewrite (Ropnd,\n            Convert_To (Universal_Real, Relocate_Node (Ropnd)));\n \n          Analyze_And_Resolve (Ropnd, Universal_Real);\n \n-      elsif Typ = Universal_Real\n-        and then Is_Integer_Type (Ltyp)\n-      then\n+      elsif Typ = Universal_Real and then Is_Integer_Type (Ltyp) then\n          Rewrite (Lopnd,\n            Convert_To (Universal_Real, Relocate_Node (Lopnd)));\n \n@@ -7077,8 +7060,8 @@ package body Exp_Ch4 is\n                --  Lhs of equality\n \n                if Nkind (Lhs) = N_Selected_Component\n-                 and then Has_Per_Object_Constraint\n-                            (Entity (Selector_Name (Lhs)))\n+                 and then\n+                   Has_Per_Object_Constraint (Entity (Selector_Name (Lhs)))\n                then\n                   --  Enclosing record is an Unchecked_Union, use formal A\n \n@@ -7118,8 +7101,8 @@ package body Exp_Ch4 is\n                --  Rhs of equality\n \n                if Nkind (Rhs) = N_Selected_Component\n-                 and then Has_Per_Object_Constraint\n-                            (Entity (Selector_Name (Rhs)))\n+                 and then\n+                   Has_Per_Object_Constraint (Entity (Selector_Name (Rhs)))\n                then\n                   if Is_Unchecked_Union\n                        (Scope (Entity (Selector_Name (Rhs))))\n@@ -7764,10 +7747,10 @@ package body Exp_Ch4 is\n                    and then not Do_Overflow_Check (P))\n                  or else\n                   (Nkind (P) = N_Op_Divide\n-                     and then Is_Integer_Type (Etype (L))\n-                     and then Is_Unsigned_Type (Etype (L))\n-                     and then R = N\n-                     and then not Do_Overflow_Check (P))\n+                    and then Is_Integer_Type (Etype (L))\n+                    and then Is_Unsigned_Type (Etype (L))\n+                    and then R = N\n+                    and then not Do_Overflow_Check (P))\n                then\n                   Set_Is_Power_Of_2_For_Shift (N);\n                   return;\n@@ -8209,10 +8192,7 @@ package body Exp_Ch4 is\n       --  (the operation now corresponds to the hardware remainder), and it\n       --  does not seem likely that it could be harmful.\n \n-      if LOK and then Llo >= 0\n-           and then\n-         ROK and then Rlo >= 0\n-      then\n+      if LOK and then Llo >= 0 and then ROK and then Rlo >= 0 then\n          Rewrite (N,\n            Make_Op_Rem (Sloc (N),\n              Left_Opnd  => Left_Opnd (N),\n@@ -8312,12 +8292,9 @@ package body Exp_Ch4 is\n       Rop : constant Node_Id    := Right_Opnd (N);\n \n       Lp2 : constant Boolean :=\n-              Nkind (Lop) = N_Op_Expon\n-                and then Is_Power_Of_2_For_Shift (Lop);\n-\n+              Nkind (Lop) = N_Op_Expon and then Is_Power_Of_2_For_Shift (Lop);\n       Rp2 : constant Boolean :=\n-              Nkind (Rop) = N_Op_Expon\n-                and then Is_Power_Of_2_For_Shift (Rop);\n+              Nkind (Rop) = N_Op_Expon and then Is_Power_Of_2_For_Shift (Rop);\n \n       Ltyp : constant Entity_Id  := Etype (Lop);\n       Rtyp : constant Entity_Id  := Etype (Rop);\n@@ -8476,18 +8453,12 @@ package body Exp_Ch4 is\n       --  Mixed-mode operations can appear in a non-static universal context,\n       --  in which case the integer argument must be converted explicitly.\n \n-      elsif Typ = Universal_Real\n-        and then Is_Integer_Type (Rtyp)\n-      then\n+      elsif Typ = Universal_Real and then Is_Integer_Type (Rtyp) then\n          Rewrite (Rop, Convert_To (Universal_Real, Relocate_Node (Rop)));\n-\n          Analyze_And_Resolve (Rop, Universal_Real);\n \n-      elsif Typ = Universal_Real\n-        and then Is_Integer_Type (Ltyp)\n-      then\n+      elsif Typ = Universal_Real and then Is_Integer_Type (Ltyp) then\n          Rewrite (Lop, Convert_To (Universal_Real, Relocate_Node (Lop)));\n-\n          Analyze_And_Resolve (Lop, Universal_Real);\n \n       --  Non-fixed point cases, check software overflow checking required\n@@ -9105,7 +9076,7 @@ package body Exp_Ch4 is\n    begin\n       --  Do validity check if validity checking operands\n \n-      if Validity_Checks_On and then Validity_Check_Operands then\n+      if Validity_Checks_On and Validity_Check_Operands then\n          Ensure_Valid (Operand);\n       end if;\n \n@@ -9383,7 +9354,7 @@ package body Exp_Ch4 is\n             --  contexts where we do not want the value anyway.\n \n             elsif (Nkind (Par) = N_Attribute_Reference\n-                     and then Prefix (Par) = N)\n+                    and then Prefix (Par) = N)\n               or else Is_Renamed_Object (N)\n             then\n                null;\n@@ -9452,11 +9423,11 @@ package body Exp_Ch4 is\n                      --  fact incorrect.\n \n                      elsif Is_Entity_Name (Dval)\n-                       and then Nkind (Parent (Entity (Dval))) =\n-                                                      N_Object_Declaration\n-                       and then Present (Expression (Parent (Entity (Dval))))\n                        and then\n-                         not Is_Static_Expression\n+                         Nkind (Parent (Entity (Dval))) = N_Object_Declaration\n+                       and then Present (Expression (Parent (Entity (Dval))))\n+                       and then not\n+                         Is_Static_Expression\n                            (Expression (Parent (Entity (Dval))))\n                      then\n                         exit Discr_Loop;\n@@ -9725,7 +9696,7 @@ package body Exp_Ch4 is\n \n       elsif Nkind (Parent (N)) = N_Assignment_Statement\n         or else (Nkind (Parent (Parent (N))) = N_Assignment_Statement\n-                   and then Parent (N) = Name (Parent (Parent (N))))\n+                  and then Parent (N) = Name (Parent (Parent (N))))\n       then\n          return;\n \n@@ -9958,7 +9929,7 @@ package body Exp_Ch4 is\n          --  range as the base type (or is the base type).\n \n          if Range_Checks_Suppressed (Target_Type)\n-           or else (Lo = Type_Low_Bound (Btyp)\n+           or else (Lo = Type_Low_Bound  (Btyp)\n                       and then\n                     Hi = Type_High_Bound (Btyp))\n          then\n@@ -10222,9 +10193,7 @@ package body Exp_Ch4 is\n \n       --  Do validity check if validity checking operands\n \n-      if Validity_Checks_On\n-        and then Validity_Check_Operands\n-      then\n+      if Validity_Checks_On and Validity_Check_Operands then\n          Ensure_Valid (Operand);\n       end if;\n \n@@ -12775,10 +12744,10 @@ package body Exp_Ch4 is\n          if not Is_Class_Wide_Type (Left_Type)\n            and then (Is_Ancestor (Etype (Right_Type), Left_Type,\n                                   Use_Full_View => True)\n-                       or else (Is_Interface (Etype (Right_Type))\n-                                 and then Interface_Present_In_Ancestor\n-                                           (Typ   => Left_Type,\n-                                            Iface => Etype (Right_Type))))\n+                      or else (Is_Interface (Etype (Right_Type))\n+                                and then Interface_Present_In_Ancestor\n+                                          (Typ   => Left_Type,\n+                                           Iface => Etype (Right_Type))))\n          then\n             Result := New_Reference_To (Standard_True, Loc);\n             return;"}, {"sha": "cd0d6504d2b5f3630e3319d322f74b2281582da5", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533369aac04c1abe91f846bff95a6f17633d97ac/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533369aac04c1abe91f846bff95a6f17633d97ac/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=533369aac04c1abe91f846bff95a6f17633d97ac", "patch": "@@ -1043,13 +1043,24 @@ begin\n       elsif Main_Kind in N_Generic_Renaming_Declaration then\n          Back_End_Mode := Generate_Object;\n \n-      --  It is not an error to analyze (in CodePeer mode or Alfa mode with\n-      --  generation of Why) a spec which requires a body, when the body is\n-      --  not available.\n+      --  It is not an error to analyze in CodePeer mode a spec which requires\n+      --  a body, in order to generate SCIL for this spec.\n \n-      elsif CodePeer_Mode or (Alfa_Mode and not Frame_Condition_Mode) then\n+      elsif CodePeer_Mode then\n          Back_End_Mode := Generate_Object;\n \n+      --  It is not an error to analyze in Alfa mode a spec which requires a\n+      --  body, when the body is not available. During frame condition\n+      --  generation, the corresponding ALI file is generated. During\n+      --  translation to Why, Why code is generated for the spec.\n+\n+      elsif Alfa_Mode then\n+         if Frame_Condition_Mode then\n+            Back_End_Mode := Declarations_Only;\n+         else\n+            Back_End_Mode := Generate_Object;\n+         end if;\n+\n       --  In all other cases (specs which have bodies, generics, and bodies\n       --  where subunits are missing), we cannot generate code and we generate\n       --  a warning message. Note that generic instantiations are gone at this"}, {"sha": "50c49136f527b1b47ab6c9bbde0cde436ae3e6c1", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533369aac04c1abe91f846bff95a6f17633d97ac/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533369aac04c1abe91f846bff95a6f17633d97ac/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=533369aac04c1abe91f846bff95a6f17633d97ac", "patch": "@@ -449,7 +449,7 @@ package body Sem_Ch6 is\n             --  prevent visibility issues later with operators in instances.\n \n             Preanalyze_Spec_Expression\n-              (New_Copy_Tree (Expression  (Ret)), Etype (Id));\n+              (New_Copy_Tree (Expression (Ret)), Etype (Id));\n             End_Scope;\n          end;\n       end if;"}, {"sha": "19e3269c5705d1dd6e96956dca92d174a2685bd8", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533369aac04c1abe91f846bff95a6f17633d97ac/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533369aac04c1abe91f846bff95a6f17633d97ac/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=533369aac04c1abe91f846bff95a6f17633d97ac", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -102,8 +102,8 @@ package Types is\n    --  Graphic characters, as defined in ARM\n \n    subtype Line_Terminator is Character range ASCII.LF .. ASCII.CR;\n-   --  Line terminator characters (LF, VT, FF, CR). For further details,\n-   --  see the extensive discussion of line termination in the Sinput spec.\n+   --  Line terminator characters (LF, VT, FF, CR). For further details, see\n+   --  the extensive discussion of line termination in the Sinput spec.\n \n    subtype Upper_Half_Character is\n      Character range Character'Val (16#80#) .. Character'Val (16#FF#);"}]}