{"sha": "5e942c506635af4d8ffc95aeb1bebc46a5584c73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU5NDJjNTA2NjM1YWY0ZDhmZmM5NWFlYjFiZWJjNDZhNTU4NGM3Mw==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1998-11-10T18:04:25Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1998-11-10T18:04:25Z"}, "message": "class.c (is_compiled_class): Call safe_layout_class for class compiled from source.\n\nTue Nov 10 12:34:03 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* class.c (is_compiled_class): Call safe_layout_class for class\n \tcompiled from source.\n\t* conver.h (convert_to_integer, convert_to_real,\n \tconvert_to_pointer): Added prototypes.\n\t* decl.c (init_decl_processing): Non longer push the decls of\n \t`methodtable', `constants', `Class', `Field', `dispatchTable'\n \t`jexception' and `Method'.\n\t* expr.c (build_invokeinterface): New function.\n\t(expand_invoke): static variable CLASS_IDENT now in\n \tbuild_invokeinterface. Use build_invokeinterface.\n\t(expand_java_field_op): Moved code to inline\n \tjava.lang.PRIMTYPE.TYPE into a function.\n\t(build_primtype_type_ref): New function.\n\t* java-tree.def (INSTANCEOF_EXPR): New tree code.\n\t* java-tree.h (CLASS_METHOD_CHECKED_P, METHOD_DEPRECATED,\n \tFIELD_DEPRECATED, CLASS_DEPRECATED): New flag macros.\n\t(DECL_CONSTRUCTOR_P): Fixed typo in comment.\n\t(DECL_LOCAL_STATIC_VALUE): New macro.\n\t(build_invokeinterface, build_primtype_type_ref): New function\n \tprototypes.\n\t(java_parse_abort_on_error): Macro rewritten.\n\t* jcf-parse.c (current_method): Add comment to declaration.\n\t(parse_zip_file_entries, process_zip_dir, void parse_source_file):\n \tFunction prototypes fixed.\n\t(jcf_parse_source): push/pop parser context. save/restore global.\n\t(parse_source_file): Fixed leading comment. Now take a\n \tIDENTIFIER_NODE as an argument. Doesn't check methods, layout\n \tclasses and pop the parser context anymore.\n\t(yyparse): Push parser context, save globals, parse the source\n \tfile, restore globals and pop the parser context when processing a\n \tsource file.\n\t* jcf.h (VERBOSE_SKELETON): Replaces SOURCE_FRONTEND_DEBUG define.\n\t* lex.c (java_parse_doc_section): New function.\n\t(java_lex): Call java_parse_doc_section when appropriate. Build an\n \toperator around INSTANCEOF_TK.\n\t* lex.h (java_lineterminator, java_sprint_unicode,\n \tjava_unicode_2_utf8, java_lex_error, java_store_unicode):\n \tPrototypes rewritten.\n\t(java_parse_escape_sequence, java_letter_or_digit_p,\n \tjava_parse_doc_section, java_parse_end_comment, java_get_unicode,\n \tjava_read_unicode, java_store_unicode, java_read_char,\n \tjava_allocate_new_line, java_unget_unicode, java_sneak_unicode):\n \tAdded function prototypes.\n\t* parse.h (VERBOSE_SKELETON): Replaces SOURCE_FRONTEND_DEBUG\n \tdefine.\n\t(JNULLP_TYPE_P, CHECK_METHODS, CHECK_DEPRECATED, REGISTER_IMPORT):\n \tNew macros\n\t(struct parser_ctxt): New fields: deprecated,\n \tcurrent_parsed_class_un, gclass_list.\n\t(fix_method_argument_names, issue_warning_error_from_context,\n \tresolve_package, lookup_package_type): New function prototypes.\n\t(resolve_expression_name): Fixed function prototype.\n\t(find_applicable_accessible_methods_list): Fixed indentation, added\n\textra argument in prototype.\n\t(check_final_assignment, build_null_of_type, check_deprecation,\n \tcheck_method_redefinition, reset_method_name,\n \tjava_check_regular_methods, java_check_abstract_methods,\n \tmaybe_build_primttype_type_ref): New function prototype.\n\t* parse.y (conver.h): Include.\n\t(INSTANCEOF_TK): Tagged <operator>.\n\t(single_type_import_declaration): Use REGISTER_IMPORT macro.\n\t(relational_expression:): Build binop for instanceof.\n\t(java_push_parser_context): Remember ctxp->gclass_list across\n \tcontexts.\n\t(java_pop_parser_context): Simply return if no context\n \texists. Remember gclass_list across contexts.\n\t(issue_warning_error_from_context): New function.\n\t(parse_error_context): Don't setup ctxp->elc here. Call\n \tissue_warning_error_from_context instead.\n\t(parse_warning_context): Likewise.\n\t(maybe_create_class_interface_decl): Removed DECL_ARTIFICIAL\n \tsetup. Link new class/interface to ctxp->gclass_list.\n\t(add_superinterfaces): Register interface as incomplete if not\n \tloaded.\n\t(create_class): Remember class unqualified name in\n \tctxp->current_parsed_class_un. Check class deprecation.\n\t(register_fields): Check field deprecation. Remember static final\n \tfield value in DECL_LOCAL_STATIC_VALUE. Changed comment in part\n \tprocessing INIT.\n\t(method_header): New local variable ORIG_ARG. Use unqualified\n \tcurrent class name for check on constructor errors. Promote return\n \ttype if of record type. Argument list fix moved in\n \tfix_method_argument_names, called here. Check method deprecation.\n\t(fix_method_argument_names): New function.\n\t(method_declarator): Promote record typed arguments.\n\t(safe_layout_class): Check class methods before layout.\n\t(java_complete_class): Compute field layout when patched.\n\t(do_resolve_class): Try to load class after having it renamed\n \tafter the package name.\n\t(get_printable_method_name): Use DECL_CONTEXT.\n\t(reset_method_name): New function.\n\t(check_method_redefinition): Use reset_method_name.\n\t(java_check_regular_methods): New local variable\n \tSAVED_FOUND_WFL. Temporarily reinstall overriding/hiding method\n \tnames for error report. Check for compile-time error when method\n \tfound has default (package) access.\n\t(java_check_abstract_methods): Now takes an interface DECL node as\n \tan argument. Also reinstall real name on unchecked\n \toverriding/hiding methods for error report.\n\t(java_check_methods): Fixed leading comment. Get classes to verify\n \tfrom ctxp->gclass_list. Use CHECK_METHODS macro and set\n \tCLASS_METHOD_CHECKED_P on class verification.\n\t(lookup_java_method2): Get real method name if necessary.\n\t(find_in_imports): Don't check package class access here.\n\t(resolve_package, lookup_package_type): New functions.\n\t(java_layout_classes): Fixed leading comment. Take classes to be\n \tlaid out from ctxp->gclass_list.\n\t(java_complete_expand_methods): Don't expand native and abstract\n \tmethods.\n\t(java_expand_classes): New function.\n\t(resolve_expression_name): Use additional argument ORIG.  Retrieve\n \tvalues of static final field of primitive types.\n\t(resolve_field_access): Handles static final field of promotive\n \ttype.\n\t(resolve_qualified_expression_name): Handle STRING_CST as\n \tprimaries and package name resolution. Check deprecation on found\n \tdecls. Set where_found and type_found on non static field resolved\n \tduring qualification. Layout non primitive field decl types.\n\t(check_deprecation): New function.\n\t(maybe_access_field): Simplified.\n\t(patch_method_invocation_stmt): Local variable CLASS_TYPE\n \tremoved. Reverse method's argument when primary is a type. Don't\n \tuse CLASS_TYPE to report problems, use IDENTIFIER_WFL\n \tinstead. Include abstract class in the list of class searchable\n \tfor constructors. Use DECL_CONTEXT of found method for access\n \tchecks. Check method deprecation.\n\t(patch_invoke): Pay extra care to NEW_CLASS_EXPR type call when\n \tconverting arguments. Handle INVOKE_INTERFACE.\n\t(lookup_method_invoke): Search constructor using existing\n \tinfrastructure (don't rely on lookup_java_constructor anymore).\n\t(find_applicable_accessible_methods_list): Extra argument flag\n \tLC. Now include constructor in the search.\n\t(qualify_ambiguous_name): Conditional expression are primaries.\n\t(not_initialized_as_it_should_p): static final are always\n \tinitialized.\n\t(java_complete_tree): Pass extra NULL argument to\n \tresolve_expression_name. Stricter test to carry on patching\n \tassignments. New case for INSTANCEOF_EXPR.\n\t(complete_function_arguments): Inline PRIMTYPE.TYPE read access.\n\t(check_final_assignment, maybe_build_primttype_type_ref): New\n \tfunctions.\n\t(patch_assignment): Detect resolved static finals and carry normal\n \tassignment error check on them. Inline PRIMTYPE.TYPE read access.\n\t(try_builtin_assignconv): Access constant 0 on all primitive\n \ttypes.\n\t(valid_builtin_assignconv_identity_widening_p): Accept identical\n \ttypes. Accept all promoted type on int type.\n\t(valid_ref_assignconv_cast_p): Accept a null pointer to be\n \tassigned to a reference.\n\t(valid_method_invocation_conversion_p): Accept to check null\n \tpointers.\n\t(build_binop): Merge declaration and initialization of local\n \tvariable BINOP.\n\t(patch_binop): New case for INSTANCEOF_EXPR. NE_EXPR to accept all\n \tnumeric types. Improved validity test for qualify operators on\n \treferences.\n\t(patch_unaryop): Broadened rejection test for PREDECREMENT_EXPR\n \tand PREINCREMENT_EXPR. Also detect resolved static finals of a\n \tprimitive type and issue the appropriate error message.\n\t(resolve_type_during_patch): Mark class loaded when resolved.\n\t(patch_cast): Allow null to be cased to reference types.\n\t(build_null_of_type): New function.\n\t(patch_array_ref): Handle array on references correctly.\n\t(patch_return): Removed unused local variable MODIFY. Force\n \tboolean to be returned as integers. Allows null to be returned by\n \ta function returning a reference.\n\t* typeck.c (convert_to_integer, convert_to_real,\n \tconvert_to_pointer): Prototypes moved to convert.h\n\t(lookup_argument_method): Use method real name, if necessary.\nThis improves method checking, gets rid of a cross file type\ndependency bug and does a more robust job at laying out classes when\nnecessary. It unifies the regular methods and constructors lookup. It\nimplements the `instanceof' operator and interface method\ninvocations. It also fixes random bugs.\n\nFrom-SVN: r23599", "tree": {"sha": "636dff1c6ffbcfcabf6a640123a6e04ba13e8e49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/636dff1c6ffbcfcabf6a640123a6e04ba13e8e49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e942c506635af4d8ffc95aeb1bebc46a5584c73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e942c506635af4d8ffc95aeb1bebc46a5584c73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e942c506635af4d8ffc95aeb1bebc46a5584c73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e942c506635af4d8ffc95aeb1bebc46a5584c73/comments", "author": null, "committer": null, "parents": [{"sha": "fbd2bdda01a0de82bf4ee14634287228b1f82c84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbd2bdda01a0de82bf4ee14634287228b1f82c84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbd2bdda01a0de82bf4ee14634287228b1f82c84"}], "stats": {"total": 3376, "additions": 2285, "deletions": 1091}, "files": [{"sha": "c225fdf7f3274b6f534ed922642969b5bb17d3fd", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=5e942c506635af4d8ffc95aeb1bebc46a5584c73", "patch": "@@ -1,3 +1,175 @@\n+Tue Nov 10 12:34:03 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* class.c (is_compiled_class): Call safe_layout_class for class\n+ \tcompiled from source.\n+\t* conver.h (convert_to_integer, convert_to_real,\n+ \tconvert_to_pointer): Added prototypes.\n+\t* decl.c (init_decl_processing): Non longer push the decls of\n+ \t`methodtable', `constants', `Class', `Field', `dispatchTable'\n+ \t`jexception' and `Method'.\n+\t* expr.c (build_invokeinterface): New function.\n+\t(expand_invoke): static variable CLASS_IDENT now in\n+ \tbuild_invokeinterface. Use build_invokeinterface.\n+\t(expand_java_field_op): Moved code to inline\n+ \tjava.lang.PRIMTYPE.TYPE into a function.\n+\t(build_primtype_type_ref): New function.\n+\t* java-tree.def (INSTANCEOF_EXPR): New tree code.\n+\t* java-tree.h (CLASS_METHOD_CHECKED_P, METHOD_DEPRECATED,\n+ \tFIELD_DEPRECATED, CLASS_DEPRECATED): New flag macros.\n+\t(DECL_CONSTRUCTOR_P): Fixed typo in comment.\n+\t(DECL_LOCAL_STATIC_VALUE): New macro.\n+\t(build_invokeinterface, build_primtype_type_ref): New function\n+ \tprototypes.\n+\t(java_parse_abort_on_error): Macro rewritten.\n+\t* jcf-parse.c (current_method): Add comment to declaration.\n+\t(parse_zip_file_entries, process_zip_dir, void parse_source_file):\n+ \tFunction prototypes fixed.\n+\t(jcf_parse_source): push/pop parser context. save/restore global.\n+\t(parse_source_file): Fixed leading comment. Now take a\n+ \tIDENTIFIER_NODE as an argument. Doesn't check methods, layout\n+ \tclasses and pop the parser context anymore.\n+\t(yyparse): Push parser context, save globals, parse the source\n+ \tfile, restore globals and pop the parser context when processing a\n+ \tsource file.\n+\t* jcf.h (VERBOSE_SKELETON): Replaces SOURCE_FRONTEND_DEBUG define.\n+\t* lex.c (java_parse_doc_section): New function.\n+\t(java_lex): Call java_parse_doc_section when appropriate. Build an\n+ \toperator around INSTANCEOF_TK.\n+\t* lex.h (java_lineterminator, java_sprint_unicode,\n+ \tjava_unicode_2_utf8, java_lex_error, java_store_unicode):\n+ \tPrototypes rewritten.\n+\t(java_parse_escape_sequence, java_letter_or_digit_p,\n+ \tjava_parse_doc_section, java_parse_end_comment, java_get_unicode,\n+ \tjava_read_unicode, java_store_unicode, java_read_char,\n+ \tjava_allocate_new_line, java_unget_unicode, java_sneak_unicode):\n+ \tAdded function prototypes.\n+\t* parse.h (VERBOSE_SKELETON): Replaces SOURCE_FRONTEND_DEBUG\n+ \tdefine.\n+\t(JNULLP_TYPE_P, CHECK_METHODS, CHECK_DEPRECATED, REGISTER_IMPORT):\n+ \tNew macros\n+\t(struct parser_ctxt): New fields: deprecated,\n+ \tcurrent_parsed_class_un, gclass_list.\n+\t(fix_method_argument_names, issue_warning_error_from_context,\n+ \tresolve_package, lookup_package_type): New function prototypes.\n+\t(resolve_expression_name): Fixed function prototype.\n+\t(find_applicable_accessible_methods_list): Fixed indentation, added\n+\textra argument in prototype.\n+\t(check_final_assignment, build_null_of_type, check_deprecation,\n+ \tcheck_method_redefinition, reset_method_name,\n+ \tjava_check_regular_methods, java_check_abstract_methods,\n+ \tmaybe_build_primttype_type_ref): New function prototype.\n+\t* parse.y (conver.h): Include.\n+\t(INSTANCEOF_TK): Tagged <operator>.\n+\t(single_type_import_declaration): Use REGISTER_IMPORT macro.\n+\t(relational_expression:): Build binop for instanceof.\n+\t(java_push_parser_context): Remember ctxp->gclass_list across\n+ \tcontexts.\n+\t(java_pop_parser_context): Simply return if no context\n+ \texists. Remember gclass_list across contexts.\n+\t(issue_warning_error_from_context): New function.\n+\t(parse_error_context): Don't setup ctxp->elc here. Call\n+ \tissue_warning_error_from_context instead.\n+\t(parse_warning_context): Likewise.\n+\t(maybe_create_class_interface_decl): Removed DECL_ARTIFICIAL\n+ \tsetup. Link new class/interface to ctxp->gclass_list.\n+\t(add_superinterfaces): Register interface as incomplete if not\n+ \tloaded.\n+\t(create_class): Remember class unqualified name in\n+ \tctxp->current_parsed_class_un. Check class deprecation.\n+\t(register_fields): Check field deprecation. Remember static final\n+ \tfield value in DECL_LOCAL_STATIC_VALUE. Changed comment in part\n+ \tprocessing INIT.\n+\t(method_header): New local variable ORIG_ARG. Use unqualified\n+ \tcurrent class name for check on constructor errors. Promote return\n+ \ttype if of record type. Argument list fix moved in\n+ \tfix_method_argument_names, called here. Check method deprecation.\n+\t(fix_method_argument_names): New function.\n+\t(method_declarator): Promote record typed arguments.\n+\t(safe_layout_class): Check class methods before layout.\n+\t(java_complete_class): Compute field layout when patched.\n+\t(do_resolve_class): Try to load class after having it renamed\n+ \tafter the package name.\n+\t(get_printable_method_name): Use DECL_CONTEXT.\n+\t(reset_method_name): New function.\n+\t(check_method_redefinition): Use reset_method_name.\n+\t(java_check_regular_methods): New local variable\n+ \tSAVED_FOUND_WFL. Temporarily reinstall overriding/hiding method\n+ \tnames for error report. Check for compile-time error when method\n+ \tfound has default (package) access.\n+\t(java_check_abstract_methods): Now takes an interface DECL node as\n+ \tan argument. Also reinstall real name on unchecked\n+ \toverriding/hiding methods for error report.\n+\t(java_check_methods): Fixed leading comment. Get classes to verify\n+ \tfrom ctxp->gclass_list. Use CHECK_METHODS macro and set\n+ \tCLASS_METHOD_CHECKED_P on class verification.\n+\t(lookup_java_method2): Get real method name if necessary.\n+\t(find_in_imports): Don't check package class access here.\n+\t(resolve_package, lookup_package_type): New functions.\n+\t(java_layout_classes): Fixed leading comment. Take classes to be\n+ \tlaid out from ctxp->gclass_list.\n+\t(java_complete_expand_methods): Don't expand native and abstract\n+ \tmethods.\n+\t(java_expand_classes): New function.\n+\t(resolve_expression_name): Use additional argument ORIG.  Retrieve\n+ \tvalues of static final field of primitive types.\n+\t(resolve_field_access): Handles static final field of promotive\n+ \ttype.\n+\t(resolve_qualified_expression_name): Handle STRING_CST as\n+ \tprimaries and package name resolution. Check deprecation on found\n+ \tdecls. Set where_found and type_found on non static field resolved\n+ \tduring qualification. Layout non primitive field decl types.\n+\t(check_deprecation): New function.\n+\t(maybe_access_field): Simplified.\n+\t(patch_method_invocation_stmt): Local variable CLASS_TYPE\n+ \tremoved. Reverse method's argument when primary is a type. Don't\n+ \tuse CLASS_TYPE to report problems, use IDENTIFIER_WFL\n+ \tinstead. Include abstract class in the list of class searchable\n+ \tfor constructors. Use DECL_CONTEXT of found method for access\n+ \tchecks. Check method deprecation.\n+\t(patch_invoke): Pay extra care to NEW_CLASS_EXPR type call when\n+ \tconverting arguments. Handle INVOKE_INTERFACE.\n+\t(lookup_method_invoke): Search constructor using existing\n+ \tinfrastructure (don't rely on lookup_java_constructor anymore).\n+\t(find_applicable_accessible_methods_list): Extra argument flag\n+ \tLC. Now include constructor in the search.\n+\t(qualify_ambiguous_name): Conditional expression are primaries.\n+\t(not_initialized_as_it_should_p): static final are always\n+ \tinitialized.\n+\t(java_complete_tree): Pass extra NULL argument to\n+ \tresolve_expression_name. Stricter test to carry on patching\n+ \tassignments. New case for INSTANCEOF_EXPR.\n+\t(complete_function_arguments): Inline PRIMTYPE.TYPE read access.\n+\t(check_final_assignment, maybe_build_primttype_type_ref): New\n+ \tfunctions.\n+\t(patch_assignment): Detect resolved static finals and carry normal\n+ \tassignment error check on them. Inline PRIMTYPE.TYPE read access.\n+\t(try_builtin_assignconv): Access constant 0 on all primitive\n+ \ttypes.\n+\t(valid_builtin_assignconv_identity_widening_p): Accept identical\n+ \ttypes. Accept all promoted type on int type.\n+\t(valid_ref_assignconv_cast_p): Accept a null pointer to be\n+ \tassigned to a reference.\n+\t(valid_method_invocation_conversion_p): Accept to check null\n+ \tpointers.\n+\t(build_binop): Merge declaration and initialization of local\n+ \tvariable BINOP.\n+\t(patch_binop): New case for INSTANCEOF_EXPR. NE_EXPR to accept all\n+ \tnumeric types. Improved validity test for qualify operators on\n+ \treferences.\n+\t(patch_unaryop): Broadened rejection test for PREDECREMENT_EXPR\n+ \tand PREINCREMENT_EXPR. Also detect resolved static finals of a\n+ \tprimitive type and issue the appropriate error message.\n+\t(resolve_type_during_patch): Mark class loaded when resolved.\n+\t(patch_cast): Allow null to be cased to reference types.\n+\t(build_null_of_type): New function.\n+\t(patch_array_ref): Handle array on references correctly.\n+\t(patch_return): Removed unused local variable MODIFY. Force\n+ \tboolean to be returned as integers. Allows null to be returned by\n+ \ta function returning a reference.\n+\t* typeck.c (convert_to_integer, convert_to_real,\n+ \tconvert_to_pointer): Prototypes moved to convert.h\n+\t(lookup_argument_method): Use method real name, if necessary.\n+\n 1998-10-30  Tom Tromey  <tromey@cygnus.com>\n \n \t* class.c (build_class_ref): Changed name of primitive classes to"}, {"sha": "47e9f5c93e600cd49b116d509ea6fb52500b269b", "filename": "gcc/java/class.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=5e942c506635af4d8ffc95aeb1bebc46a5584c73", "patch": "@@ -1153,7 +1153,12 @@ is_compiled_class (class)\n   if (flag_assume_compiled)\n     {\n       if (!CLASS_LOADED_P (class))\n-\tload_class (class, 1);\n+\t{\n+\t  if (CLASS_FROM_SOURCE_P (class))\n+\t    safe_layout_class (class);\n+\t  else\n+\t    load_class (class, 1);\n+\t}\n       return 1;\n     }\n "}, {"sha": "a627bc2aca88acdf8e3f0c50a8d0587e8e69ef54", "filename": "gcc/java/convert.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fconvert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fconvert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconvert.h?ref=5e942c506635af4d8ffc95aeb1bebc46a5584c73", "patch": "@@ -1,3 +1,4 @@\n+\n /* Definition of conversion functions.\n    Copyright (C) 1993 Free Software Foundation, Inc.\n \n@@ -22,3 +23,6 @@ Boston, MA 02111-1307, USA.  */\n \n extern tree convert_to_boolean PROTO ((tree, tree));\n extern tree convert_to_char    PROTO ((tree, tree));\n+extern tree convert_to_integer PROTO ((tree type, tree expr));\n+extern tree convert_to_real PROTO ((tree type, tree expr));\n+extern tree convert_to_pointer PROTO ((tree type, tree expr));"}, {"sha": "0831a37b89a25daa70207f734eadeb9d65b224f5", "filename": "gcc/java/decl.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=5e942c506635af4d8ffc95aeb1bebc46a5584c73", "patch": "@@ -527,8 +527,7 @@ init_decl_processing ()\n \n   methodtable_type = make_node (RECORD_TYPE);\n   layout_type (methodtable_type);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"methodtable\"),\n-\t\t\tmethodtable_type));\n+  build_decl (TYPE_DECL, get_identifier (\"methodtable\"), methodtable_type);\n   methodtable_ptr_type = build_pointer_type (methodtable_type);\n \n   TYPE_identifier_node = get_identifier (\"TYPE\");\n@@ -554,8 +553,7 @@ init_decl_processing ()\n   PUSH_FIELD (constants_type_node, field, \"tags\", ptr_type_node);\n   PUSH_FIELD (constants_type_node, field, \"data\", ptr_type_node);\n   FINISH_RECORD (constants_type_node);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"constants\"),\n-\t\t\tconstants_type_node));\n+  build_decl (TYPE_DECL, get_identifier (\"constants\"), constants_type_node);\n \n   access_flags_type_node = unsigned_short_type_node;\n \n@@ -606,7 +604,7 @@ init_decl_processing ()\n     FIELD_PRIVATE (t) = 1;\n   push_super_field (class_type_node, object_type_node);\n   FINISH_RECORD (class_type_node);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"Class\"), class_type_node));\n+  build_decl (TYPE_DECL, get_identifier (\"Class\"), class_type_node);\n \n   field_info_union_node = make_node (UNION_TYPE);\n   PUSH_FIELD (field_info_union_node, field, \"boffset\", int_type_node);\n@@ -623,7 +621,7 @@ init_decl_processing ()\n   PUSH_FIELD (field_type_node, field, \"info\", field_info_union_node);\n   FINISH_RECORD (field_type_node);\n   CLASS_LOADED_P (field_type_node) = 1;\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"Field\"), field_type_node));\n+  build_decl (TYPE_DECL, get_identifier (\"Field\"), field_type_node);\n \n   one_elt_array_domain_type = build_index_type (integer_one_node);\n   nativecode_ptr_array_type_node\n@@ -632,7 +630,7 @@ init_decl_processing ()\n   PUSH_FIELD (dtable_type, field, \"class\", class_ptr_type);\n   PUSH_FIELD (dtable_type, field, \"methods\", nativecode_ptr_array_type_node);\n   FINISH_RECORD (dtable_type);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"dispatchTable\"), dtable_type));\n+  build_decl (TYPE_DECL, get_identifier (\"dispatchTable\"), dtable_type);\n \n #define jint_type int_type_node\n #define jint_ptr_type ptr_type_node\n@@ -643,7 +641,7 @@ init_decl_processing ()\n   PUSH_FIELD (jexception_type, field, \"handler_pc\", ptr_type_node);\n   PUSH_FIELD (jexception_type, field, \"catch_type\", class_ptr_type);\n   FINISH_RECORD (jexception_type);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"jexception\"), field_type_node));\n+  build_decl (TYPE_DECL, get_identifier (\"jexception\"), field_type_node);\n   jexception_ptr_type = build_pointer_type (jexception_type);\n \n   lineNumberEntry_type = make_node (RECORD_TYPE);\n@@ -665,7 +663,7 @@ init_decl_processing ()\n   PUSH_FIELD (method_type_node, field, \"ncode\", nativecode_ptr_type_node);\n   FINISH_RECORD (method_type_node);\n   CLASS_LOADED_P (method_type_node) = 1;\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"Method\"), method_type_node));\n+  build_decl (TYPE_DECL, get_identifier (\"Method\"), method_type_node);\n \n   t = tree_cons (NULL_TREE, class_ptr_type,\n \t\t build_tree_list (NULL_TREE, int_type_node));"}, {"sha": "37c512256d7f7b4d99cb0c47143656e1afc56673", "filename": "gcc/java/expr.c", "status": "modified", "additions": 60, "deletions": 48, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=5e942c506635af4d8ffc95aeb1bebc46a5584c73", "patch": "@@ -1431,6 +1431,32 @@ build_invokevirtual (dtable, method)\n   return func;\n }\n \n+tree\n+build_invokeinterface (dtable, method_name, method_signature)\n+     tree dtable, method_name, method_signature;\n+{\n+  static tree class_ident = NULL_TREE;\n+  tree lookup_arg;\n+\n+  /* We expand invokeinterface here.  _Jv_LookupInterfaceMethod() will\n+     ensure that the selected method exists, is public and not\n+     abstract nor static.  */\n+\t    \n+  if (class_ident == NULL_TREE)\n+    class_ident = get_identifier (\"class\");\n+  \n+  dtable = build1 (INDIRECT_REF, dtable_type, dtable);\n+  dtable = build (COMPONENT_REF, class_ptr_type, dtable,\n+\t\t  lookup_field (&dtable_type, class_ident));\n+  lookup_arg = build_tree_list (NULL_TREE, build_utf8_ref (method_signature));\n+  lookup_arg = tree_cons (NULL_TREE, dtable,\n+\t\t\t  tree_cons (NULL_TREE, build_utf8_ref (method_name),\n+\t\t\t\t     lookup_arg));\n+  return build (CALL_EXPR, ptr_type_node, \n+\t\tbuild_address_of (soft_lookupinterfacemethod_node),\n+\t\tlookup_arg, NULL_TREE);\n+}\n+  \n /* Expand one of the invoke_* opcodes.\n    OCPODE is the specific opcode.\n    METHOD_REF_INDEX is an index into the constant pool.\n@@ -1449,8 +1475,6 @@ expand_invoke (opcode, method_ref_index, nargs)\n   char *self_name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (self_type)));\n   tree call, func, method, arg_list, method_type;\n \n-  static tree class_ident = NULL_TREE;\n-\n   if (! CLASS_LOADED_P (self_type))\n     {\n       load_class (self_type, 1);\n@@ -1522,30 +1546,7 @@ expand_invoke (opcode, method_ref_index, nargs)\n       if (opcode == OPCODE_invokevirtual)\n \tfunc = build_invokevirtual (dtable, method);\n       else\n-\t{\n-\t  /* We expand invokeinterface here.\n-\t     _Jv_LookupInterfaceMethod() will ensure that the selected\n-\t     method exists, is public and not abstract nor static.  */\n-\t    \n-\t  tree lookup_arg;\n-\n-\t  if (class_ident == NULL_TREE)\n-\t    class_ident = get_identifier (\"class\");\n-\n-\t  dtable = build1 (INDIRECT_REF, dtable_type, dtable);\n-\t  dtable = build (COMPONENT_REF, class_ptr_type, dtable,\n-\t\t\t  lookup_field (&dtable_type, class_ident));\n-\t  lookup_arg = build_tree_list (NULL_TREE,\n-\t\t\t\t\tbuild_utf8_ref (method_signature));\n-\t  lookup_arg = tree_cons (NULL_TREE, dtable,\n-\t\t\t\t  tree_cons (NULL_TREE,\n-\t\t\t\t\t     build_utf8_ref (method_name),\n-\t\t\t\t\t     lookup_arg));\n-\t  func = build (CALL_EXPR,\n-\t\t\tptr_type_node,\n-\t\t\tbuild_address_of (soft_lookupinterfacemethod_node),\n-\t\t\tlookup_arg, NULL_TREE);\n-\t}\n+\tfunc = build_invokeinterface (dtable, method_name, method_signature);\n     }\n   func = build1 (NOP_EXPR, build_pointer_type (method_type), func);\n   call = build (CALL_EXPR, TREE_TYPE (method_type), func, arg_list, NULL_TREE);\n@@ -1615,29 +1616,10 @@ expand_java_field_op (is_static, is_putting, field_ref_index)\n       && field_type == class_ptr_type\n       && strncmp (self_name, \"java.lang.\", 10) == 0)\n     {\n-      char *class_name = self_name+10;\n-      tree typ;\n-      if (strcmp(class_name, \"Byte\") == 0)\n-\ttyp = byte_type_node;\n-      else if (strcmp(class_name, \"Short\") == 0)\n-\ttyp = short_type_node;\n-      else if (strcmp(class_name, \"Integer\") == 0)\n-\ttyp = int_type_node;\n-      else if (strcmp(class_name, \"Long\") == 0)\n-\ttyp = long_type_node;\n-      else if (strcmp(class_name, \"Float\") == 0)\n-\ttyp = float_type_node;\n-      else if (strcmp(class_name, \"Boolean\") == 0)\n-\ttyp = boolean_type_node;\n-      else if (strcmp(class_name, \"Char\") == 0)\n-\ttyp = char_type_node;\n-      else if (strcmp(class_name, \"Void\") == 0)\n-\ttyp = void_type_node;\n-      else\n-\ttyp = NULL_TREE;\n-      if (typ != NULL_TREE)\n+      tree typ = build_primtype_type_ref (self_name);\n+      if (typ)\n \t{\n-\t  push_value (build_class_ref (typ));\n+\t  push_value (typ);\n \t  return;\n \t}\n     }\n@@ -1672,6 +1654,36 @@ expand_java_field_op (is_static, is_putting, field_ref_index)\n     push_value (field_ref);\n }\n \n+tree\n+build_primtype_type_ref (self_name)\n+    char *self_name;\n+{\n+  char *class_name = self_name+10;\n+  tree typ;\n+  if (strncmp(class_name, \"Byte\", 4) == 0)\n+    typ = byte_type_node;\n+  else if (strncmp(class_name, \"Short\", 5) == 0)\n+    typ = short_type_node;\n+  else if (strncmp(class_name, \"Integer\", 7) == 0)\n+    typ = int_type_node;\n+  else if (strncmp(class_name, \"Long\", 4) == 0)\n+    typ = long_type_node;\n+  else if (strncmp(class_name, \"Float\", 5) == 0)\n+    typ = float_type_node;\n+  else if (strncmp(class_name, \"Boolean\", 7) == 0)\n+    typ = boolean_type_node;\n+  else if (strncmp(class_name, \"Char\", 4) == 0)\n+    typ = char_type_node;\n+  else if (strncmp(class_name, \"Void\", 4) == 0)\n+    typ = void_type_node;\n+  else\n+    typ = NULL_TREE;\n+  if (typ != NULL_TREE)\n+    return build_class_ref (typ);\n+  else\n+    return NULL_TREE;\n+}\n+\n void\n load_type_state (label)\n      tree label;"}, {"sha": "b367066aa3126fae42f01732104b2d7a9b889c6f", "filename": "gcc/java/java-tree.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fjava-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fjava-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.def?ref=5e942c506635af4d8ffc95aeb1bebc46a5584c73", "patch": "@@ -70,3 +70,10 @@ DEFTREECODE (THROW_EXPR, \"throw\", '1', 1)\n    Operand 1 is the then-value\n    Operand 2 is the else-value.  */\n DEFTREECODE (CONDITIONAL_EXPR, \"?:\", 'e', 3)\n+\n+/* instanceof operator.\n+   Operand 0 is the expression that is getting tested\n+   Operand 1 is the class used for the test.  */\n+DEFTREECODE (INSTANCEOF_EXPR, \"instanceof\", 'e', 2)\n+\n+"}, {"sha": "d80c6c9582a658a1d6117d068af661d25f4a0b0a", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=5e942c506635af4d8ffc95aeb1bebc46a5584c73", "patch": "@@ -56,6 +56,7 @@ struct JCF;\n       IS_CRAFTED_STRING_BUFFER_P (in CALL_EXPR)\n \n    Usage of TYPE_LANG_FLAG_?:\n+   0: CLASS_METHOD_CHECKED_P (in RECORD_TYPE)\n    1: TYPE_ARRAY_P (in RECORD_TYPE).\n    2: CLASS_LOADED_P (in RECORD_TYPE).\n    3: CLASS_FROM_SOURCE_P (in RECORD_TYPE).\n@@ -64,6 +65,9 @@ struct JCF;\n    6: CLASS_HAS_FINIT_P (in RECORD_TYPE)\n \n    Usage of DECL_LANG_FLAG_?:\n+   0: METHOD_DEPRECATED (in FUNCTION_DECL).\n+      FIELD_DEPRECATED (in FIELD_DECL).\n+      CLASS_DEPRECATED (in TYPE_DECL).\n    1: METHOD_PUBLIC (in FUNCTION_DECL).\n       FIELD_PUBLIC (in FIELD_DECL).\n       CLASS_PUBLIC (in TYPE_DECL).\n@@ -85,7 +89,7 @@ struct JCF;\n       LABEL_CHANGED (in LABEL_DECL)\n       CLASS_SUPER (in TYPE_DECL, ACC_SUPER flag)\n       INITIALIZED_P (in FIELD_DECL, VAR_DECL, PARM_DECL)\n-   7: DECL_CONSTRUCTOR_P (in FUNCTION_DECL)\n+   7: DECL_CONSTRUCTOR_P (in FUNCTION_DECL).\n */\n \n /* True if the class whose TYPE_BINFO this is has a superclass.\n@@ -396,6 +400,9 @@ struct lang_identifier\n    slot_number in decl_map. */\n #define DECL_LOCAL_SLOT_CHAIN(NODE) \\\n   (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->slot_chain)\n+/* For a static field seen from the parser, it holds its associated\n+   value, the one returned when the field is looked up. */\n+#define DECL_LOCAL_STATIC_VALUE(NODE) DECL_LOCAL_SLOT_CHAIN (NODE)\n \n /* DECL_LANG_SPECIFIC for FUNCTION_DECLs. */\n struct lang_decl\n@@ -501,6 +508,7 @@ extern tree lookup_name PROTO ((tree));\n extern tree build_known_method_ref PROTO ((tree, tree, tree, tree, tree));\n extern tree build_class_init PROTO ((tree, tree));\n extern tree build_invokevirtual PROTO ((tree, tree));\n+extern tree build_invokeinterface PROTO ((tree, tree, tree));\n extern tree invoke_build_dtable PROTO ((int, tree));\n extern tree build_field_ref PROTO ((tree, tree, tree));\n extern void pushdecl_force_head PROTO ((tree));\n@@ -533,6 +541,7 @@ extern int alloc_name_constant PROTO ((int, tree));\n extern void emit_register_classes PROTO (());\n extern void lang_init_source PROTO ((int));\n extern void write_classfile PROTO ((tree));\n+extern tree build_primtype_type_ref PROTO ((char *));\n \n /* Access flags etc for a method (a FUNCTION_DECL): */\n \n@@ -570,6 +579,13 @@ extern void write_classfile PROTO ((tree));\n #define CLASS_ABSTRACT(DECL) DECL_LANG_FLAG_5 (DECL)\n #define CLASS_SUPER(DECL) DECL_LANG_FLAG_6 (DECL)\n \n+/* @deprecated marker flag on methods, fields and classes */\n+\n+#define METHOD_DEPRECATED(DECL) DECL_LANG_FLAG_0 (DECL)\n+#define FIELD_DEPRECATED(DECL) DECL_LANG_FLAG_0 (DECL)\n+#define CLASS_DEPRECATED(DECL) DECL_LANG_FLAG_0 (DECL)\n+#define DECL_DEPRECATED(DECL) DECL_LANG_FLAG_0 (DECL)\n+\n /* The number of virtual methods in this class's dispatch table.\n  Does not include initial two dummy entries (one points to the\n  Class object, and the other is for G++ -fvtable-thunks compatibility). */\n@@ -657,6 +673,9 @@ extern tree *type_map;\n /* FIXME this use of TREE_TYPE conflicts with something or other. */\n #define TYPE_ARRAY_ELEMENT(ATYPE) TREE_TYPE(ATYPE)\n \n+/* True if methods in class TYPE have been checked.  */\n+#define CLASS_METHOD_CHECKED_P(TYPE) TYPE_LANG_FLAG_0 (TYPE)\n+\n /* True if class TYPE has been loaded. */\n #define CLASS_LOADED_P(TYPE) TYPE_LANG_FLAG_2 (TYPE)\n \n@@ -795,13 +814,12 @@ extern tree *type_map;\n \n /* Make the current function where this macro is invoked report error\n    messages and and return, if any */\n-#define java_parse_abort_on_error()\t\t\\\n-  {\t\t\t\t\t\t\\\n-     extern int java_error_count;\t\t\\\n-     if (java_error_count)\t\t\t\\\n-       {\t\t\t\t\t\\\n-         java_report_errors ();\t\t\t\\\n-\t java_pop_parser_context (0);\t\t\\\n-\t return;\t\t\t\t\\\n-       }\t\t\t\t\t\\\n+#define java_parse_abort_on_error()\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+     extern int java_error_count;\t\t\t\t\t\\\n+     if (java_error_count)\t\t\t\t\t\t\\\n+       {\t\t\t\t\t\t\t\t\\\n+         java_report_errors ();\t\t\t\t\t\t\\\n+\t return;\t\t\t\t\t\t\t\\\n+       }\t\t\t\t\t\t\t\t\\\n    }"}, {"sha": "df4881d31cd50f25851a1605cdb1aa992d702761", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 20, "deletions": 31, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=5e942c506635af4d8ffc95aeb1bebc46a5584c73", "patch": "@@ -64,15 +64,14 @@ tree main_class = NULL_TREE;\n /* The FIELD_DECL for the current field. */\n static tree current_field = NULL_TREE;\n \n+/* The METHOD_DECL for the current method.  */\n static tree current_method = NULL_TREE;\n \n+/* Declarations of some functions used here.  */\n static tree give_name_to_class PROTO ((JCF *jcf, int index));\n-\n-void parse_zip_file_entries (void);\n-void process_zip_dir();\n-\n-/* Source file compilation declarations */\n-static void parse_source_file ();\n+void parse_zip_file_entries PROTO (());\n+void process_zip_dir PROTO (());\n+static void parse_source_file PROTO ((tree));\n \n /* Handle \"SourceFile\" attribute. */\n \n@@ -506,14 +505,17 @@ int\n jcf_parse_source (jcf)\n      JCF *jcf;\n {\n-  tree filename = get_identifier (input_filename);\n-  java_parser_context_save_global ();\n+  tree file;\n \n+  java_parser_context_save_global ();\n+  java_push_parser_context ();\n   input_filename = current_jcf->filename;\n+  file = get_identifier (input_filename);\n   if (!(finput = fopen (input_filename, \"r\")))\n     fatal (\"input file `%s' just disappeared - jcf_parse_source\",\n \t   input_filename);\n-  parse_source_file (IS_A_COMMAND_LINE_FILENAME_P (filename));\n+  parse_source_file (file);\n+  java_pop_parser_context (IS_A_COMMAND_LINE_FILENAME_P (file));\n   java_parser_context_restore_global ();\n }\n \n@@ -658,22 +660,16 @@ parse_class_file ()\n   lineno = save_lineno;\n }\n \n-/* Parse a source file, as pointed by the current JCF. If PARSE_ONLY\n-   is non zero, we're not parsing a file found on the command line and\n-   we skip things related to code generation. */\n+/* Parse a source file, as pointed by the current value of INPUT_FILENAME. */\n \n static void\n-parse_source_file (parse_only)\n-     int parse_only;\n+parse_source_file (file)\n+     tree file;\n {\n-  int remember_for_generation;\n-  tree filename = get_identifier (input_filename);\n-\n   /* Mark the file as parsed */\n-  HAS_BEEN_ALREADY_PARSED_P (filename) = 1;\n+  HAS_BEEN_ALREADY_PARSED_P (file) = 1;\n \n   lang_init_source (1);\t\t    /* Error msgs have no method prototypes */\n-  java_push_parser_context ();\n   java_init_lex ();\t\t    /* Initialize the parser */\n   java_parse_abort_on_error ();\n   java_parse ();\t\t    /* Parse and build partial tree nodes. */\n@@ -682,17 +678,6 @@ parse_source_file (parse_only)\n   java_parse_abort_on_error ();\n   java_check_circular_reference (); /* Check on circular references */\n   java_parse_abort_on_error ();\n-  java_check_methods ();            /* Check the methods */\n-  java_parse_abort_on_error ();\n-  java_layout_classes ();\n-  java_parse_abort_on_error ();\n-\n-  /* If only parsing, make sure that the currently parsed file isn't\n-     also present in the argument list. If it's the case, remember\n-     that we should generate it. */\n-  remember_for_generation = !parse_only \n-    || IS_A_COMMAND_LINE_FILENAME_P (filename);\n-  java_pop_parser_context (remember_for_generation);\n }\n \n int\n@@ -775,7 +760,11 @@ yyparse ()\n \t  parse_class_file ();\n \t  break;\n \tcase JCF_SOURCE:\n-\t  parse_source_file (0);\t/* Parse and generate */\n+\t  java_push_parser_context ();\n+\t  java_parser_context_save_global ();\n+\t  parse_source_file (name);\n+\t  java_parser_context_restore_global ();\n+\t  java_pop_parser_context (1);\n \t  break;\n \t}\n     }"}, {"sha": "5d092c6ec3ab9687ff87a5d9d1d208b2b2aae043", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=5e942c506635af4d8ffc95aeb1bebc46a5584c73", "patch": "@@ -706,7 +706,6 @@ emit_iinc (var, value, state)\n static void\n emit_load_or_store (var, opcode, state)\n      tree var;\n-     int opcode;\n      struct jcf_partial *state;\n {\n   tree type = TREE_TYPE (var);"}, {"sha": "1b8aff2dac6c9ab826f19a08ad1285be6aa700bd", "filename": "gcc/java/jcf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fjcf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fjcf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf.h?ref=5e942c506635af4d8ffc95aeb1bebc46a5584c73", "patch": "@@ -248,7 +248,7 @@ extern int jcf_unexpected_eof PROTO ((JCF*, int));\n /* Debug macros, for the front end */\n \n extern int quiet_flag;\n-#ifdef SOURCE_FRONTEND_DEBUG\n+#ifdef VERBOSE_SKELETON\n #undef SOURCE_FRONTEND_DEBUG\n #define SOURCE_FRONTEND_DEBUG(X)\t\t\t\t\\\n   {if (!quiet_flag) {printf (\"* \"); printf X; putchar ('\\n');} }"}, {"sha": "46101931e6067f4df4d6c7032b7a5bd48c4ca528", "filename": "gcc/java/lang-options.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang-options.h?ref=5e942c506635af4d8ffc95aeb1bebc46a5584c73", "patch": "@@ -22,11 +22,14 @@ Java and all Java-based marks are trademarks or registered trademarks\n of Sun Microsystems, Inc. in the United States and other countries.\n The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n \n-DEFINE_LANG_NAME (\"Java\")\n-     \n /* This is the contribution to the `lang_options' array in gcc.c for\n    java.  */\n \n+/* CYGNUS LOCAL - the format of this file has been changed to\n+   allow cc1 to implement --help.  nickc/--help */\n+\n+DEFINE_LANG_NAME (\"Java\")\n+     \n   { \"-fbounds-check\", \"\" },\n   { \"-fno-bounds-check\", \"Disable automatic array bounds checking\" },\n   { \"-fassume-compiled\", \"Make is_compiled_class return 1\"},"}, {"sha": "0a632f1bb54798aaca89abb9c2ed3e864d2598c4", "filename": "gcc/java/lex.c", "status": "modified", "additions": 59, "deletions": 56, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=5e942c506635af4d8ffc95aeb1bebc46a5584c73", "patch": "@@ -368,6 +368,62 @@ java_parse_end_comment ()\n     }\n }\n \n+/* Parse the documentation section. Keywords must be at the beginning\n+   of a documentation comment line (ignoring white space and any `*'\n+   character). Parsed keyword(s): @DEPRECATED.  */\n+\n+static int\n+java_parse_doc_section (c)\n+     unicode_t c;\n+{\n+  int valid_tag = 0, seen_star;\n+\n+  while (JAVA_WHITE_SPACE_P (c) || (c == '*') || c == '\\n')\n+    {\n+      switch (c)\n+\t{\n+\tcase '*':\n+\t  seen_star = 1;\n+\t  break;\n+\tcase '\\n': /* ULT */\n+\t  valid_tag = 1;\n+\t  break;\n+\tdefault:\n+\t  seen_star = 0;\n+\t}\n+      c = java_get_unicode();\n+    }\n+  \n+  if (c == UEOF)\n+    java_lex_error (\"Comment not terminated at end of input\", 0);\n+  \n+  if (seen_star && (c == '/'))\n+    return 1;\t\t\t/* Goto step1 in caller */\n+\n+  /* We're parsing @deprecated */\n+  if (valid_tag && (c == '@'))\n+    {\n+      char tag [10];\n+      int  tag_index = 0;\n+\n+      while (tag_index < 10 && c != UEOF && c != ' ' && c != '\\n')\n+\t{\n+\t  c = java_get_unicode ();\n+\t  tag [tag_index++] = c;\n+\t}\n+      \n+      if (c == UEOF)\n+\tjava_lex_error (\"Comment not terminated at end of input\", 0);\n+      \n+      java_unget_unicode ();\n+      tag [tag_index] = '\\0';\n+\n+      if (!strcmp (tag, \"deprecated\"))\n+\tctxp->deprecated = 1;\n+    }\n+  return 0;\n+}\n+\n /* This function to be used only by JAVA_ID_CHAR_P (), otherwise it\n    will return a wrong result.  */\n static int\n@@ -494,62 +550,8 @@ java_lex (java_lval)\n \t    {\n \t      if ((c = java_get_unicode ()) == '/')\n \t\tgoto step1;\t/* Empy documentation comment  */\n-\n-\t      else\n-\t\t/* Parsing the documentation section. We're looking\n-\t\t for the @depracated pseudo keyword.  the @deprecated\n-\t\t tag must be at the beginning of a doc comment line\n-\t\t (ignoring white space and any * character)  */\n-\n-\t\t{ \n-\t\t  int valid_tag = 0, seen_star;\n-\n-\t\t  while (JAVA_WHITE_SPACE_P (c) || (c == '*') || c == '\\n')\n-\t\t    {\n-\t\t      switch (c)\n-\t\t\t{\n-\t\t\tcase '*':\n-\t\t\t  seen_star = 1;\n-\t\t\t  break;\n-\t\t\tcase '\\n': /* ULT */\n-\t\t\t  valid_tag = 1;\n-\t\t\t  break;\n-\t\t\tdefault:\n-\t\t\t  seen_star = 0;\n-\t\t\t}\n-\t\t      c = java_get_unicode();\n-\t\t    }\n-\t\t  \n-\t\t  if (c == UEOF)\n-\t\t    java_lex_error \n-\t\t      (\"Comment not terminated at end of input\", 0);\n-\n-\t\t  if (seen_star && (c == '/'))\n-\t\t    goto step1;\t/* End of documentation */\n-\n-\t\t  if (valid_tag && (c == '@'))\n-\t\t    {\n-\t\t      char deprecated [10];\n-\t\t      int  deprecated_index = 0;\n-\n-\t\t      for (deprecated_index = 0, c = java_get_unicode (); \n-\t\t\t   deprecated_index < 10 && c != UEOF;\n-\t\t\t   c = java_get_unicode ())\n-\t\t\tdeprecated [deprecated_index++] = c;\n-\n-\t\t      if (c == UEOF)\n-\t\t\tjava_lex_error \n-\t\t          (\"Comment not terminated at end of input\", 0);\n-\t\t      \n-\t\t      java_unget_unicode ();\n-\t\t      deprecated [deprecated_index] = '\\0';\n-\t\t      if (!strcmp (deprecated, \"deprecated\"))\n-\t\t\t{\n-\t\t\t  /* Set global flag to be checked by class. FIXME  */\n-\t\t\t  warning (\"deprecated implementation found\");\n-\t\t\t}\n-\t\t    }\n-\t\t}\n+\t      else if (java_parse_doc_section (c))\n+\t\tgoto step1;\n \t    }\n \t  else\n \t    java_unget_unicode ();\n@@ -1206,6 +1208,7 @@ java_lex (java_lval)\n \t    case TRY_TK:\n \t    case CATCH_TK:\n \t    case THROW_TK:\n+\t    case INSTANCEOF_TK:\n \t      BUILD_OPERATOR (kw->token);\n \n \t    default:"}, {"sha": "621cfa63e12bf785a727063bdde37d7924189c9a", "filename": "gcc/java/lex.h", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.h?ref=5e942c506635af4d8ffc95aeb1bebc46a5584c73", "patch": "@@ -35,13 +35,6 @@ extern int   lineno;\n /* A Unicode character, as read from the input file  */\n typedef unsigned short unicode_t;\n \n-/* Function declaration  */\n-static int java_lineterminator ();\n-static char *java_sprint_unicode ();\n-static void java_unicode_2_utf8 ();\n-static void java_lex_error ();\n-static void java_store_unicode ();\n-\n /* Debug macro to print-out what we match  */\n #ifdef JAVA_LEX_DEBUG\n #ifdef JAVA_LEX_DEBUG_CHAR\n@@ -511,4 +504,23 @@ static tree build_wfl_node ();\n #define JAVA_READ_BUFFER 256\n #define UEOF (unicode_t)0xffff\n \n+/* Function declaration  */\n+static int java_lineterminator PROTO ((unicode_t));\n+static char *java_sprint_unicode PROTO ((struct java_line *, int));\n+static void java_unicode_2_utf8 PROTO ((unicode_t));\n+static void java_lex_error PROTO ((char *, int));\n+static int java_is_eol PROTO ((FILE *, int));\n+static void java_store_unicode PROTO ((struct java_line *, unicode_t, int));\n+static unicode_t java_parse_escape_sequence PROTO (());\n+static int java_letter_or_digit_p PROTO ((unicode_t));\n+static int java_parse_doc_section PROTO ((unicode_t));\n+static void java_parse_end_comment PROTO (());\n+static unicode_t java_get_unicode PROTO (());\n+static unicode_t java_read_unicode PROTO ((int, int *));\n+static void java_store_unicode PROTO ((struct java_line *, unicode_t, int));\n+static unicode_t java_read_char PROTO (());\n+static void java_allocate_new_line PROTO (());\n+static void java_unget_unicode PROTO (());\n+static unicode_t java_sneak_unicode PROTO (());\n+\n #endif"}, {"sha": "08f587a6c9681f95f23213bdb50452ed84429eb5", "filename": "gcc/java/mangle.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fmangle.c?ref=5e942c506635af4d8ffc95aeb1bebc46a5584c73", "patch": "@@ -70,7 +70,6 @@ void\n emit_unicode_mangled_name (obstack, name, len)\n      struct obstack *obstack;\n      char *name;\n-     int len;\n {\n   unsigned char *ptr;\n   unsigned char *limit = (unsigned char *)name + len;"}, {"sha": "8646523eace694051de667c124bf64995b48465e", "filename": "gcc/java/parse.c", "status": "modified", "additions": 1137, "deletions": 670, "changes": 1807, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=5e942c506635af4d8ffc95aeb1bebc46a5584c73"}, {"sha": "7f783dcb636e460ada0e336dd9c641e8e6199bbe", "filename": "gcc/java/parse.h", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=5e942c506635af4d8ffc95aeb1bebc46a5584c73", "patch": "@@ -47,7 +47,7 @@ extern tree stabilize_reference PROTO ((tree));\n #define RULE( rule )\n #endif\n \n-#ifdef SOURCE_FRONTEND_DEBUG\n+#ifdef VERBOSE_SKELETON\n #undef SOURCE_FRONTEND_DEBUG\n #define SOURCE_FRONTEND_DEBUG(X)\t\t\t\t\\\n   {if (!quiet_flag) {printf (\"* \"); printf X; putchar ('\\n');} }\n@@ -182,6 +182,8 @@ extern tree stabilize_reference PROTO ((tree));\n \t\t\t\t     ||\t(TREE_CODE (TYPE) == POINTER_TYPE     \\\n \t\t\t\t\t &&  TREE_CODE (TREE_TYPE (TYPE)) ==  \\\n \t\t\t\t\t RECORD_TYPE)))\n+#define JNULLP_TYPE_P(TYPE) ((TYPE) && (TREE_CODE (TYPE) == POINTER_TYPE) \\\n+\t\t\t     && (TYPE) == TREE_TYPE (null_pointer_node))\n \n /* Other predicate */\n #define DECL_P(NODE) (NODE && (TREE_CODE (NODE) == PARM_DECL\t\t\\\n@@ -523,6 +525,32 @@ static jdeplist *reverse_jdep_list ();\n       *ret_decl = NULL_TREE;\t\t\t\\\n     return error_mark_node;\t\t\t\\\n   }\n+\n+/* Convenient macro to check. Assumes that CLASS is a CLASS_DECL.  */\n+#define CHECK_METHODS(CLASS)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    if (CLASS_INTERFACE ((CLASS)))\t\t\\\n+      java_check_abstract_methods ((CLASS));\t\\\n+    else\t\t\t\t\t\\\n+      java_check_regular_methods ((CLASS));\t\\\n+  }\n+\n+/* Using and reseting the @deprecated tag flag */\n+#define CHECK_DEPRECATED(DECL)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    if (ctxp->deprecated)\t\t\t\\\n+      DECL_DEPRECATED (DECL) = 1;\t\t\\\n+    ctxp->deprecated = 0;\t\t\t\\\n+  }\n+\n+/* Register an impor */\n+#define REGISTER_IMPORT(WHOLE, NAME)\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  IS_A_SINGLE_IMPORT_CLASSFILE_NAME_P ((NAME)) = 1;\t\\\n+  node = build_tree_list ((WHOLE), (NAME));\t\t\\\n+  TREE_CHAIN (node) = ctxp->import_list;\t\t\\\n+  ctxp->import_list = node;\t\t\t\t\\\n+}\n      \n /* Parser context data structure. */\n struct parser_ctxt {\n@@ -542,6 +570,7 @@ struct parser_ctxt {\n   int minus_seen;\t\t     /* Integral literal overflow */\n   int lineno;\t\t\t    /* Current lineno */\n   int java_error_flag;\t\t    /* Report error when true */\n+  int deprecated;\t\t     /* @deprecated tag seen */\n \n   /* This section is defined only if we compile jc1 */\n #ifndef JC1_LITE\n@@ -561,7 +590,9 @@ struct parser_ctxt {\n \n   tree  incomplete_class;\t    /* List of non-complete classes */\n   tree  current_parsed_class;\t    /* Class currently parsed */\n+  tree  current_parsed_class_un;    /* Curr. parsed class unqualified name */\n   tree  class_list;\t\t    /* List of classes in a CU */\n+  tree  gclass_list;\t\t    /* All classes seen so far. */\n   jdeplist *classd_list;\t    /* Classe dependencies in a CU */\n   \n   tree non_static_initialized;\t    /* List of non static initialized fields */\n@@ -604,16 +635,20 @@ static void check_modifiers_consistency PROTO ((int));\n static tree lookup_cl PROTO ((tree));\n static tree lookup_java_method2 PROTO ((tree, tree, int));\n static tree method_header PROTO ((int, tree, tree, tree));\n+static void fix_method_argument_names PROTO ((tree ,tree));\n static tree method_declarator PROTO ((tree, tree));\n static void parse_error_context VPROTO ((tree cl, char *msg, ...));\n static void parse_warning_context VPROTO ((tree cl, char *msg, ...));\n+static void issue_warning_error_from_context PROTO ((tree, char *msg));\n static tree parse_jdk1_1_error PROTO ((char *));\n static void complete_class_report_errors PROTO ((jdep *));\n static int process_imports PROTO ((void));\n static void read_import_dir PROTO ((tree));\n static int find_in_imports_on_demand PROTO ((tree));\n static int find_in_imports PROTO ((tree));\n static int check_pkg_class_access PROTO ((tree, tree));\n+static tree resolve_package PROTO ((tree, tree *));\n+static tree lookup_package_type PROTO ((char *, int));\n static tree resolve_class PROTO ((tree, tree, tree));\n static tree do_resolve_class PROTO ((tree, tree, tree));\n static void declare_local_variables PROTO ((int, tree, tree));\n@@ -623,7 +658,7 @@ static void expand_start_java_method PROTO ((tree));\n static tree find_name_in_single_imports PROTO ((tree));\n static void check_abstract_method_header PROTO ((tree));\n static tree lookup_java_interface_method2 PROTO ((tree, tree));\n-static tree resolve_expression_name PROTO ((tree));\n+static tree resolve_expression_name PROTO ((tree, tree *));\n static tree maybe_create_class_interface_decl PROTO ((tree, tree, tree));\n static int check_class_interface_creation PROTO ((int, int, tree, \n \t\t\t\t\t\t  tree, tree, tree));\n@@ -633,7 +668,8 @@ static int breakdown_qualified PROTO ((tree *, tree *, tree));\n static tree resolve_and_layout PROTO ((tree, tree));\n static tree resolve_no_layout PROTO ((tree, tree));\n static int invocation_mode PROTO ((tree, int));\n-static tree find_applicable_accessible_methods_list PROTO ((tree, tree, tree));\n+static tree find_applicable_accessible_methods_list PROTO ((int, tree, \n+\t\t\t\t\t\t\t    tree, tree));\n static tree find_most_specific_methods_list PROTO ((tree));\n static int argument_types_convertible PROTO ((tree, tree));\n static tree patch_invoke PROTO ((tree, tree, tree, int));\n@@ -654,12 +690,14 @@ static tree build_method_invocation PROTO ((tree, tree));\n static tree build_new_invocation PROTO ((tree, tree));\n static tree build_assignment PROTO ((int, int, tree, tree));\n static tree build_binop PROTO ((enum tree_code, int, tree, tree));\n+static int check_final_assignment PROTO ((tree ,tree));\n static tree patch_assignment PROTO ((tree, tree, tree ));\n static tree patch_binop PROTO ((tree, tree, tree));\n static tree build_unaryop PROTO ((int, int, tree));\n static tree build_incdec PROTO ((int, int, tree, int));\n static tree patch_unaryop PROTO ((tree, tree));\n static tree build_cast PROTO ((int, tree, tree));\n+static tree build_null_of_type PROTO ((tree));\n static tree patch_cast PROTO ((tree, tree));\n static int valid_ref_assignconv_cast_p PROTO ((tree, tree, int));\n static int valid_builtin_assignconv_identity_widening_p PROTO ((tree, tree));\n@@ -689,6 +727,7 @@ static tree maybe_access_field PROTO ((tree, tree, tree));\n static int complete_function_arguments PROTO ((tree));\n static int check_for_static_method_reference PROTO ((tree, tree, tree, tree, tree));\n static int not_accessible_p PROTO ((tree, tree, int));\n+static void check_deprecation PROTO ((tree, tree));\n static int class_in_current_package PROTO ((tree));\n static tree build_if_else_statement PROTO ((int, tree, tree, tree));\n static tree patch_if_else_statement PROTO ((tree));\n@@ -735,6 +774,11 @@ static tree create_artificial_method PROTO ((tree, int, tree, tree, tree));\n static void start_artificial_method_body PROTO ((tree));\n static void end_artificial_method_body PROTO ((tree));\n static tree generate_field_initialization_code PROTO ((tree));\n+static int check_method_redefinition PROTO ((tree, tree));\n+static int reset_method_name PROTO ((tree));\n+static void java_check_regular_methods PROTO ((tree));\n+static void java_check_abstract_methods PROTO ((tree));\n+static tree maybe_build_primttype_type_ref PROTO ((tree, tree));\n \n void safe_layout_class PROTO ((tree));\n void java_complete_class PROTO ((void));"}, {"sha": "8d7c6766a9145947be189326c3fc3747c7bbeddc", "filename": "gcc/java/parse.y", "status": "modified", "additions": 712, "deletions": 246, "changes": 958, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=5e942c506635af4d8ffc95aeb1bebc46a5584c73", "patch": "@@ -67,6 +67,7 @@ definitions and other extensions.  */\n #include \"lex.h\"\n #include \"parse.h\"\n #include \"zipfile.h\"\n+#include \"convert.h\"\n \n /* Number of error found so far. */\n int java_error_count; \n@@ -248,7 +249,7 @@ static tree wfl_to_string = NULL_TREE;\n %token   <operator>     BOOL_AND_TK AND_TK BOOL_OR_TK OR_TK INCR_TK PLUS_TK\n %token   <operator>     DECR_TK MINUS_TK MULT_TK DIV_TK XOR_TK REM_TK NEQ_TK\n %token   <operator>     NEG_TK REL_QM_TK REL_CL_TK NOT_TK LT_TK\n-%token   <operator>     OP_TK OSB_TK DOT_TK THROW_TK\n+%token   <operator>     OP_TK OSB_TK DOT_TK THROW_TK INSTANCEOF_TK\n %type    <operator>\tTHIS_TK SUPER_TK RETURN_TK BREAK_TK CONTINUE_TK \n %type\t <operator>     CASE_TK DEFAULT_TK TRY_TK CATCH_TK SYNCHRONIZED_TK\n \n@@ -409,14 +410,11 @@ single_type_import_declaration:\n \t\t\t  ($2, \"Ambiguous class: `%s' and `%s'\",\n \t\t\t   IDENTIFIER_POINTER (name), \n \t\t\t   IDENTIFIER_POINTER (err));\n+\t\t      else\n+\t\t\tREGISTER_IMPORT ($2, last_name)\n \t\t    }\n \t\t  else\n-\t\t    {\n-\t\t      IS_A_SINGLE_IMPORT_CLASSFILE_NAME_P (last_name) = 1;\n-\t\t      node = build_tree_list ($2, last_name);\n-\t\t      TREE_CHAIN (node) = ctxp->import_list;\n-\t\t      ctxp->import_list = node;\n-\t\t    }\n+\t\t    REGISTER_IMPORT ($2, last_name);\n \t\t}\n |\tIMPORT_TK error\n \t\t{yyerror (\"Missing name\"); RECOVER;}\n@@ -1936,6 +1934,7 @@ relational_expression:\n \t\t\t\t    $1, $3); \n \t\t}\n |\trelational_expression INSTANCEOF_TK reference_type\n+\t\t{ $$ = build_binop (INSTANCEOF_EXPR, $2.location, $1, $3); }\n |\trelational_expression LT_TK error\n \t\t{yyerror (\"Missing term\"); RECOVER;}\n |\trelational_expression GT_TK error\n@@ -2098,7 +2097,10 @@ java_push_parser_context ()\n   new->next = ctxp;\n   ctxp = new;\n   if (ctxp->next)\n-    ctxp->incomplete_class = ctxp->next->incomplete_class;\n+    {\n+      ctxp->incomplete_class = ctxp->next->incomplete_class;\n+      ctxp->gclass_list = ctxp->next->gclass_list;\n+    }\n }  \n \n /* If the first file of a file list was a class file, no context\n@@ -2142,12 +2144,17 @@ java_pop_parser_context (generate)\n      int generate;\n {\n   tree current;\n-  struct parser_ctxt *toFree = ctxp;\n-  struct parser_ctxt *next = ctxp->next;\n+  struct parser_ctxt *toFree, *next;\n \n+  if (!ctxp)\n+    return;\n+\n+  toFree = ctxp;\n+  next = ctxp->next;\n   if (next)\n     {\n       next->incomplete_class = ctxp->incomplete_class;\n+      next->gclass_list = ctxp->gclass_list;\n       lineno = ctxp->lineno;\n       finput = ctxp->finput;\n       current_class = ctxp->current_class;\n@@ -2259,6 +2266,24 @@ parse_error (msg)\n   java_error (msg);\n }\n \n+static void\n+issue_warning_error_from_context (cl, msg)\n+     tree cl;\n+     char *msg;\n+{\n+  char *saved;\n+\n+  ctxp->elc.line = EXPR_WFL_LINENO (cl);\n+  ctxp->elc.col  = (EXPR_WFL_COLNO (cl) == 0xfff ? -1 : EXPR_WFL_COLNO (cl));\n+\n+  /* We have a CL, that's a good reason for using it if it contains data */\n+  saved = ctxp->filename;\n+  if (TREE_CODE (cl) == EXPR_WITH_FILE_LOCATION && EXPR_WFL_FILENAME_NODE (cl))\n+    ctxp->filename = EXPR_WFL_FILENAME (cl);\n+  parse_error (msg);\n+  ctxp->filename = saved;\n+}\n+\n /* Issue an error message at a current source line CL */\n \n static void\n@@ -2269,6 +2294,7 @@ parse_error_context VPROTO ((tree cl, char *msg, ...))\n   char *msg;\n #endif\n   char buffer [4096];\n+  char *saved;\n   va_list ap;\n \n   VA_START (ap, msg);\n@@ -2279,10 +2305,7 @@ parse_error_context VPROTO ((tree cl, char *msg, ...))\n   vsprintf (buffer, msg, ap);\n \n   force_error = 1;\n-  ctxp->elc.line = EXPR_WFL_LINENO (cl);\n-  ctxp->elc.col  = (EXPR_WFL_COLNO (cl) == 0xfff ? -1 : EXPR_WFL_COLNO (cl));\n-\n-  parse_error (buffer);\n+  issue_warning_error_from_context (cl, buffer);\n   force_error = 0;\n }\n \n@@ -2296,6 +2319,7 @@ parse_warning_context VPROTO ((tree cl, char *msg, ...))\n   char *msg;\n #endif\n   char buffer [4096];\n+  char *saved;\n   va_list ap;\n \n   VA_START (ap, msg);\n@@ -2306,10 +2330,7 @@ parse_warning_context VPROTO ((tree cl, char *msg, ...))\n   vsprintf (buffer, msg, ap);\n \n   force_error = do_warning = 1;\n-  ctxp->elc.line = EXPR_WFL_LINENO (cl);\n-  ctxp->elc.col  = (EXPR_WFL_COLNO (cl) == 0xfff ? -1 : EXPR_WFL_COLNO (cl));\n-\n-  parse_error (buffer);\n+  issue_warning_error_from_context (cl, buffer);\n   do_warning = force_error = 0;\n }\n \n@@ -2562,9 +2583,7 @@ static tree\n maybe_create_class_interface_decl (decl, qualified_name, cl)\n      tree decl, qualified_name, cl;\n {\n-  if (decl)\n-    DECL_ARTIFICIAL (decl) = 1; /* FIXME */\n-  else\n+  if (!decl)\n     decl = push_class (make_class (), qualified_name);\n   \n   /* Take care of the file and line business */\n@@ -2579,6 +2598,10 @@ maybe_create_class_interface_decl (decl, qualified_name, cl)\n   /* Link the declaration to the already seen ones */\n   TREE_CHAIN (decl) = ctxp->class_list;\n   ctxp->class_list = decl;\n+\n+  /* Create a new node in the global list */\n+  ctxp->gclass_list = tree_cons (NULL_TREE, decl, ctxp->gclass_list);\n+\n   /* Install a new dependency list element */\n   create_jdep_list (ctxp);\n \n@@ -2602,10 +2625,11 @@ add_superinterfaces (decl, interface_list)\n   for (node = interface_list; node; node = TREE_CHAIN (node))\n     {\n       tree current = TREE_PURPOSE (node), interface_decl;\n-      if ((interface_decl = IDENTIFIER_CLASS_VALUE (EXPR_WFL_NODE (current))))\n+      tree idecl = IDENTIFIER_CLASS_VALUE (EXPR_WFL_NODE (current));\n+      if (idecl && CLASS_LOADED_P (TREE_TYPE (idecl)))\n \t{\n-\t  if (!parser_check_super_interface (interface_decl, decl, current))\n-\t    parser_add_interface (decl, interface_decl, current);\n+\t  if (!parser_check_super_interface (idecl, decl, current))\n+\t    parser_add_interface (decl, idecl, current);\n \t}\n       else\n \tregister_incomplete_type (JDEP_INTERFACE,\n@@ -2673,6 +2697,7 @@ create_class (flags, id, super, interfaces)\n \n   class_id = parser_qualified_classname (id);\n   decl = IDENTIFIER_CLASS_VALUE (class_id);\n+  ctxp->current_parsed_class_un = EXPR_WFL_NODE (id);\n   EXPR_WFL_NODE (id) = class_id;\n \n   /* Basic check: scope, redefinition, modifiers */\n@@ -2725,6 +2750,9 @@ create_class (flags, id, super, interfaces)\n   CLASS_COMPLETE_P (decl) = 1;\n   add_superinterfaces (decl, interfaces);\n \n+  /* Eventually sets the @deprecated tag flag */\n+  CHECK_DEPRECATED (decl);\n+\n   return decl;\n }\n \n@@ -2854,9 +2882,10 @@ register_fields (flags, type, variable_list)\n \t}\n \n       /* Set lineno to the line the field was found and create a\n-         declaration for it */\n+         declaration for it. Eventually sets the @deprecated tag flag. */\n       lineno = EXPR_WFL_LINENO (cl);\n       field_decl = add_field (class_type, current_name, type, flags);\n+      CHECK_DEPRECATED (field_decl);\n       \n       /* Check if we must chain. */\n       if (must_chain)\n@@ -2873,23 +2902,26 @@ register_fields (flags, type, variable_list)\n \t  /* The field is declared static */\n \t  if (flags & ACC_STATIC)\n \t    {\n-\t      /* FIXME */\n \t      if (flags & ACC_FINAL)\n-\t\t;\t\t\n-\t      /* Otherwise, the field should be initialized in\n-\t\t <clinit>. This field is remembered so we can\n-\t\t generate <clinit> later. */\n+\t\t{\n+\t\t  if (DECL_LANG_SPECIFIC (field_decl) == NULL)\n+\t\t    DECL_LANG_SPECIFIC (field_decl) = (struct lang_decl *)\n+\t\t      permalloc (sizeof (struct lang_decl_var));\n+\t\t  DECL_LOCAL_STATIC_VALUE (field_decl) = \n+\t\t    TREE_OPERAND (init, 1);\n+\t\t}\n+\t      /* Otherwise, the field should be initialized in <clinit>. \n+\t\t This field is remembered so we can generate <clinit> later */\n \t      else\n \t\t{\n \t\t  INITIALIZED_P (field_decl) = 1;\n \t\t  TREE_CHAIN (init) = ctxp->static_initialized;\n \t\t  ctxp->static_initialized = init;\n \t\t}\n \t    }\n-\t  /* A non-static field declared with an immediate\n-\t     initialization is to be initialized in <init>, if\n-\t     any.  This field is remembered to be processed at the\n-\t     time of the generation of <init>. */\n+\t  /* A non-static field declared with an immediate initialization is\n+\t     to be initialized in <init>, if any.  This field is remembered\n+\t     to be processed at the time of the generation of <init>. */\n \t  else\n \t    {\n \t      INITIALIZED_P (field_decl) = 1;\n@@ -2986,7 +3018,7 @@ method_header (flags, type, mdecl, throws)\n   tree meth = TREE_VALUE (mdecl);\n   tree id = TREE_PURPOSE (mdecl);\n   tree this_class = TREE_TYPE (ctxp->current_parsed_class);\n-  tree meth_name, returned_type, current;\n+  tree meth_name, returned_type, current, orig_arg;\n   int saved_lineno;\n   int constructor_ok = 0;\n   \n@@ -3014,7 +3046,7 @@ method_header (flags, type, mdecl, throws)\n       int ec = java_error_count;\n       /* 8.6: Constructor declarations: we might be trying to define a\n          method without specifying a return type. */\n-      if (EXPR_WFL_NODE (id) != DECL_NAME (ctxp->current_parsed_class))\n+      if (EXPR_WFL_NODE (id) != ctxp->current_parsed_class_un)\n \tparse_error_context \n \t  (id, \"Invalid method declaration, return type required\");\n       /* 8.6.3: Constructor modifiers */\n@@ -3077,7 +3109,11 @@ method_header (flags, type, mdecl, throws)\n \t}\n     }\n   else\n-    TREE_TYPE (meth) = type;\n+    {\n+      if (TREE_CODE (type) == RECORD_TYPE)\n+\ttype = promote_type (type);\n+      TREE_TYPE (meth) = type;\n+    }\n \n   saved_lineno = lineno;\n   /* When defining an abstract or interface method, the curly\n@@ -3086,6 +3122,9 @@ method_header (flags, type, mdecl, throws)\n   lineno = (ctxp->first_ccb_indent1 ? ctxp->first_ccb_indent1 : \n \t    EXPR_WFL_LINENO (id));\n \n+  /* Remember the original argument list */\n+  orig_arg = TYPE_ARG_TYPES (meth);\n+\n   if (patch_stage)\t\t/* includes ret type and/or all args */\n     {\n       jdep *jdep;\n@@ -3101,28 +3140,15 @@ method_header (flags, type, mdecl, throws)\n       register_incomplete_type (JDEP_METHOD_END, NULL_TREE, meth, NULL_TREE);\n     }\n   else\n-    {\n-      tree signature = build_java_signature (meth);\n-      tree arg, orig_arg;\n-      /* Save original argument list, including argument's names */\n-      orig_arg = TYPE_ARG_TYPES (meth);\n-      /* Add the method to its class */\n-      meth = add_method (this_class, flags, meth_name, signature);\n-      /* Fix the method argument list so we have the argument name\n-         information */\n-      arg = TYPE_ARG_TYPES (TREE_TYPE (meth));\n-      if (TREE_CODE (TREE_TYPE (meth)) == METHOD_TYPE)\n-\t{\n-\t  TREE_PURPOSE (arg) = this_identifier_node;\n-\t  arg = TREE_CHAIN (arg);\n-\t}\n-      while (orig_arg)\n-        {\n-\t  TREE_PURPOSE (arg) = TREE_PURPOSE (orig_arg);\n-\t  orig_arg = TREE_CHAIN (orig_arg);\n-\t  arg = TREE_CHAIN (arg);\n-\t}\n-    }\n+    meth = add_method (this_class, flags, meth_name, \n+\t\t       build_java_signature (meth));\n+\n+  /* Fix the method argument list so we have the argument name\n+     information */\n+  fix_method_argument_names (orig_arg, meth);\n+\n+  /* Register the parameter number and re-install the current line\n+     number */\n   DECL_MAX_LOCALS (meth) = ctxp->formal_parameter_number+1;\n   lineno = saved_lineno;\n \n@@ -3157,9 +3183,30 @@ method_header (flags, type, mdecl, throws)\n   if (constructor_ok)\n     DECL_CONSTRUCTOR_P (meth) = 1;\n \n+  /* Eventually set the @deprecated tag flag */\n+  CHECK_DEPRECATED (meth);\n+\n   return meth;\n }\n \n+static void\n+fix_method_argument_names (orig_arg, meth)\n+    tree orig_arg, meth;\n+{\n+  tree arg = TYPE_ARG_TYPES (TREE_TYPE (meth));\n+  if (TREE_CODE (TREE_TYPE (meth)) == METHOD_TYPE)\n+    {\n+      TREE_PURPOSE (arg) = this_identifier_node;\n+      arg = TREE_CHAIN (arg);\n+    }\n+  while (orig_arg)\n+    {\n+      TREE_PURPOSE (arg) = TREE_PURPOSE (orig_arg);\n+      orig_arg = TREE_CHAIN (orig_arg);\n+      arg = TREE_CHAIN (arg);\n+    }\n+}\n+\n /* Complete the method declaration with METHOD_BODY.  */\n \n static void\n@@ -3305,6 +3352,9 @@ method_declarator (id, list)\n       type = build_array_from_name (type, type_wfl, name, &name);\n       EXPR_WFL_NODE (wfl_name) = name;\n \n+      if (TREE_CODE (type) == RECORD_TYPE)\n+\ttype = promote_type (type);\n+\n       /* Check redefinition */\n       for (already = arg_types; already; already = TREE_CHAIN (already))\n \tif (TREE_PURPOSE (already) == name)\n@@ -3564,14 +3614,20 @@ void\n safe_layout_class (class)\n      tree class;\n {\n+  tree list;\n   tree save_current_class = current_class;\n   char *save_input_filename = input_filename;\n   int save_lineno = lineno;\n-  \n+\n   push_obstacks (&permanent_obstack, &permanent_obstack);\n+\n+  if (!CLASS_METHOD_CHECKED_P (class))\n+    CHECK_METHODS (TYPE_NAME (class));\n+  CLASS_METHOD_CHECKED_P (class) = 1;\n+\n   layout_class (class);\n   pop_obstacks ();\n-  \n+\n   current_class = save_current_class;\n   input_filename = save_input_filename;\n   lineno = save_lineno;\n@@ -3655,6 +3711,8 @@ java_complete_class ()\n \t\t  field_type = promote_type (field_type);\n \t\tpop_obstacks ();\n \t\tTREE_TYPE (field_decl) = field_type;\n+\t\tDECL_ALIGN (field_decl) = 0;\n+\t\tlayout_decl (field_decl, 0);\n \t\tSOURCE_FRONTEND_DEBUG \n \t\t  ((\"Completed field/var decl `%s' with `%s'\",\n \t\t    IDENTIFIER_POINTER (DECL_NAME (field_decl)),\n@@ -3817,7 +3875,6 @@ do_resolve_class (class_type, decl, cl)\n \n   /* 2- And check for the type in the current compilation unit. If it fails,\n      try with a name qualified with the package name if appropriate. */\n-\n   if ((new_class_decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type))))\n     {\n       if (!CLASS_LOADED_P (TREE_TYPE (new_class_decl)) &&\n@@ -3830,6 +3887,8 @@ do_resolve_class (class_type, decl, cl)\n   if (!QUALIFIED_P (TYPE_NAME (class_type)) && ctxp->package)\n     TYPE_NAME (class_type) = merge_qualified_name (ctxp->package, \n \t\t\t\t\t\t   TYPE_NAME (class_type));\n+  if (!(new_class_decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type))))\n+    load_class (TYPE_NAME (class_type), 0);\n   if ((new_class_decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type))))\n     {\n       if (!CLASS_LOADED_P (TREE_TYPE (new_class_decl)) &&\n@@ -3984,9 +4043,7 @@ get_printable_method_name (decl)\n   if (DECL_CONSTRUCTOR_P (decl))\n     {\n       name = DECL_NAME (decl);\n-      DECL_NAME (decl) = \n-\tDECL_NAME (ctxp->current_parsed_class ? \n-\t\t   ctxp->current_parsed_class : current_class);\n+      DECL_NAME (decl) = DECL_NAME (TYPE_NAME (DECL_CONTEXT (decl)));\n     }\n       \n   to_return = lang_printable_name (decl, 0);\n@@ -3996,6 +4053,28 @@ get_printable_method_name (decl)\n   return to_return;\n }\n \n+/* Reinstall the proper DECL_NAME on METHOD. Return 0 if the method\n+   nevertheless needs to be verfied, 1 otherwise.  */\n+\n+static int\n+reset_method_name (method)\n+     tree method;\n+{\n+  if (DECL_NAME (method) != clinit_identifier_node\n+      && DECL_NAME (method) != finit_identifier_node)\n+    {\n+      /* NAME is just the plain name when Object is being defined */\n+      if (DECL_CONTEXT (method) != object_type_node)\n+\tDECL_NAME (method) = \n+\t  (DECL_CONSTRUCTOR_P (method) ? init_identifier_node :\n+\t   (TREE_CODE (DECL_NAME (method)) == EXPR_WITH_FILE_LOCATION ? \n+\t    EXPR_WFL_NODE (DECL_NAME (method)) : DECL_NAME (method)));\n+      return 0;\n+    }\n+  else \n+    return 1;\n+}\n+\n /* Track method being redefined inside the same class. As a side\n    effect, set DECL_NAME to an IDENTIFIER (prior entering this\n    function it's a FWL, so we can track errors more accurately */\n@@ -4009,19 +4088,14 @@ check_method_redefinition (class, method)\n   tree sig = TYPE_LANG_SPECIFIC (TREE_TYPE (method))->signature;\n   /* decl name of artificial <clinit> and <finit> doesn't need to be fixed and\n      checked */\n-  if (DECL_NAME (method) != clinit_identifier_node\n-      && DECL_NAME (method) != finit_identifier_node)\n-    {\n-      /* NAME is just the plain name when Object is being defined */\n-      if (class != object_type_node)\n-\tname = DECL_NAME (method) = (DECL_CONSTRUCTOR_P (method) ? \n-\t\t\t\t     init_identifier_node :\n-\t\t\t\t     EXPR_WFL_NODE (DECL_NAME (method)));\n-      else \n-\tname = DECL_NAME (method);\n-    }\n-  else \n+\n+  /* Reset the method name before running the check. If it returns 1,\n+     the method doesn't need to be verified with respect to method\n+     redeclaration and we return 0 */\n+  if (reset_method_name (method))\n     return 0;\n+\n+  name = DECL_NAME (method);\n   \n   for (redef = TYPE_METHODS (class); redef; redef = TREE_CHAIN (redef))\n     {\n@@ -4049,20 +4123,26 @@ static void\n java_check_regular_methods (class_decl)\n      tree class_decl;\n {\n+  int saw_constructor = 0;\n   tree method;\n   tree class = CLASS_TO_HANDLE_TYPE (TREE_TYPE (class_decl));\n   tree super_class = CLASSTYPE_SUPER (class);\n-  int saw_constructor = 0;\n+  tree saved_found_wfl = NULL_TREE, found = NULL_TREE;\n \n   TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));\n \n   /* Should take interfaces into account. FIXME */\n   for (method = TYPE_METHODS (class); method; method = TREE_CHAIN (method))\n     {\n-      tree found, sig;\n+      tree sig;\n       tree method_wfl = DECL_NAME (method);\n       int aflags;\n \n+      /* If we previously found something and its name was saved,\n+         reinstall it now */\n+      if (found && saved_found_wfl)\n+\tDECL_NAME (found) = saved_found_wfl;\n+\n       /* Check for redefinitions */\n       if (check_method_redefinition (class, method))\n \tcontinue;\n@@ -4077,12 +4157,17 @@ java_check_regular_methods (class_decl)\n        }\n \n       sig = build_java_argument_signature (TREE_TYPE (method));\n-\n       found = lookup_argument_method (super_class, DECL_NAME (method), sig);\n \n-      /* Nothing overrides or it's a private method */\n+      /* Nothing overrides or it's a private method. */\n       if (!found || (found && METHOD_PRIVATE (found)))\n-        continue;\n+\tcontinue;\n+\n+      /* If found wasn't verified, it's DECL_NAME won't be set properly. \n+\t We set it temporarily for the sake of the error report. */\n+      saved_found_wfl = DECL_NAME (found);\n+      reset_method_name (found);\n+\n       /* Can't override a method with the same name and different return\n \t types. */\n       if (TREE_TYPE (TREE_TYPE (found)) != TREE_TYPE (TREE_TYPE (method)))\n@@ -4126,19 +4211,27 @@ java_check_regular_methods (class_decl)\n \t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n \t  continue;\n \t}\n-      /* Overriding/hiding public must be public or\n-\t overriding/hiding protected must be protected or public */\n-      if ((METHOD_PUBLIC (found) && !METHOD_PUBLIC (method)) ||\n-\t  (METHOD_PROTECTED (found) \n-\t   && !(METHOD_PUBLIC (method) || METHOD_PROTECTED (method))))\n+\n+      aflags = get_access_flags_from_decl (found);\n+      /* - Overriding/hiding public must be public\n+\t - Overriding/hiding protected must be protected or public\n+         - If the overriden or hidden method has default (package)\n+           access, then the overriding or hiding method must not be\n+           private; otherwise, a compile-time error occurs */\n+      if ((METHOD_PUBLIC (found) && !METHOD_PUBLIC (method)) \n+\t  || (METHOD_PROTECTED (found) \n+\t      && !(METHOD_PUBLIC (method) || METHOD_PROTECTED (method)))\n+\t  || (!(aflags & (ACC_PUBLIC | ACC_PRIVATE | ACC_STATIC))\n+\t      && METHOD_PRIVATE (method)))\n \t{\n \t  parse_error_context \n \t    (method_wfl,\n \t     \"Methods can't be overridden to be more private. Method `%s' is \"\n-\t     \"%s in class `%s'\", lang_printable_name (found, 0),\n-\t     (METHOD_PUBLIC (found) ? \"public\" : \"protected\"),\n-\t     IDENTIFIER_POINTER \n-\t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n+\t     \"not %s in class `%s'\", lang_printable_name (method, 0),\n+\t     (METHOD_PUBLIC (method) ? \"public\" : \n+\t      (METHOD_PRIVATE (method) ? \"private\" : \"protected\")),\n+\t     IDENTIFIER_POINTER (DECL_NAME \n+\t\t\t\t (TYPE_NAME (DECL_CONTEXT (found)))));\n \t  continue;\n \t}\n \n@@ -4148,9 +4241,10 @@ java_check_regular_methods (class_decl)\n \n       /* If the method has default access in an other package, then\n \t issue a warning that the current method doesn't override the\n-\t one that was found elsewhere */\n-      aflags = get_access_flags_from_decl (found);\n-      if ((!aflags || (aflags > ACC_PROTECTED))\n+\t one that was found elsewhere. Do not issue this warning when\n+\t the match was found in java.lang.Object.  */\n+      if (DECL_CONTEXT (found) != object_type_node \n+\t  && (!aflags || (aflags > ACC_PROTECTED))\n \t  && !class_in_current_package (DECL_CONTEXT (found)))\n \tparse_warning_context \n \t  (method_wfl, \"Method `%s' in class `%s' does not \"\n@@ -4160,10 +4254,16 @@ java_check_regular_methods (class_decl)\n \t   IDENTIFIER_POINTER (DECL_NAME (class_decl)),\n \t   IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n \n-      /* Check on (default) package access. FIXME.  */\n       /* Inheriting multiple methods with the same signature. FIXME */\n     }\n   \n+  /* Don't forget eventual pending found and saved_found_wfl. Take\n+     into account that we might have exited because we saw an\n+     aritifical method as the last entry. */\n+\n+  if (found && !DECL_ARTIFICIAL (found) && saved_found_wfl)\n+    DECL_NAME (found) = saved_found_wfl;\n+\n   TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));\n \n   if (!saw_constructor)\n@@ -4220,11 +4320,12 @@ check_throws_clauses (method, method_wfl, found)\n /* Check abstract method of interface INTERFACE */\n \n static void\n-java_check_abstract_methods (interface)\n-     tree interface;\n+java_check_abstract_methods (interface_decl)\n+     tree interface_decl;\n {\n   int i, n;\n   tree method, basetype_vec, found;\n+  tree interface = TREE_TYPE (interface_decl);\n \n   for (method = TYPE_METHODS (interface); method; method = TREE_CHAIN (method))\n     {\n@@ -4239,16 +4340,20 @@ java_check_abstract_methods (interface)\n       found = lookup_java_interface_method2 (interface, method);\n       if (found)\n \t{\n-\t  char *t = strdup (lang_printable_name (TREE_TYPE (TREE_TYPE (found)),\n-\t\t\t\t\t\t 0));\n+\t  char *t;\n+\t  tree saved_found_wfl = DECL_NAME (found);\n+\t  reset_method_name (found);\n+\t  t = strdup (lang_printable_name (TREE_TYPE (TREE_TYPE (found)), 0));\n \t  parse_error_context \n \t    (method_wfl,\n-\t     \"Method `%s' was defined with return type `%s' in class `%s \",\n+\t     \"Method `%s' was defined with return type `%s' in class `%s'\",\n \t     lang_printable_name (found, 0), t,\n \t     IDENTIFIER_POINTER \n \t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n \t  free (t);\n \t  continue;\n+\t  \n+\t  DECL_NAME (found) = saved_found_wfl;\n \t}\n     }\n \n@@ -4270,37 +4375,39 @@ java_check_abstract_methods (interface)\n \t  found = lookup_java_interface_method2 (interface, \n \t\t\t\t\t\t sub_interface_method);\n \t  if (found && (found != sub_interface_method))\n-\t    parse_error_context \n-\t      (lookup_cl (sub_interface_method),\n-\t       \"Interface `%s' inherits method `%s' from interface `%s'. This \"\n-\t       \"method is redefined with a different return \"\n-\t       \"type in interface `%s'\",\n-\t       IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (interface))),\n-\t       lang_printable_name (found, 0),\n-\t       IDENTIFIER_POINTER \n-\t         (DECL_NAME (TYPE_NAME (DECL_CONTEXT (sub_interface_method)))),\n-\t       IDENTIFIER_POINTER \n-\t         (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n+\t    {\n+\t      tree saved_found_wfl = DECL_NAME (found);\n+\t      reset_method_name (found);\n+\t      parse_error_context \n+\t\t(lookup_cl (sub_interface_method),\n+\t\t \"Interface `%s' inherits method `%s' from interface `%s'. \"\n+\t\t \"This method is redefined with a different return type in \"\n+\t\t \"interface `%s'\",\n+\t\t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (interface))),\n+\t\t lang_printable_name (found, 0),\n+\t\t IDENTIFIER_POINTER \n+\t\t   (DECL_NAME (TYPE_NAME \n+\t\t\t       (DECL_CONTEXT (sub_interface_method)))),\n+\t\t IDENTIFIER_POINTER \n+\t           (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n+\t      DECL_NAME (found) = saved_found_wfl;\n+\t    }\n \t}\n     }\n }\n \n-/* Check the method on all the defined classes. Should be done to the\n-   classes declared in the compilation unit only. FIXME  */\n+/* Check the method on all the defined classes. Process all the\n+   classes that we compiled from source code for this CU.  */\n \n void\n java_check_methods ()\n {\n   tree current;\n-  for (current = ctxp->class_list; current; current = TREE_CHAIN (current))\n-    if (CLASS_FROM_SOURCE_P (TREE_TYPE (current)))\n+  for (current = ctxp->gclass_list; current; current = TREE_CHAIN (current))\n+    if (CLASS_FROM_SOURCE_P (TREE_TYPE (TREE_VALUE (current))))\n       {\n-\ttree class = CLASS_TO_HANDLE_TYPE (TREE_TYPE (current));\n-\n-\tif (CLASS_INTERFACE (TYPE_NAME (class)))\n-\t  java_check_abstract_methods (class);\n-\telse\n-\t  java_check_regular_methods (current);\n+\tCHECK_METHODS (TREE_VALUE (current));\n+\tCLASS_METHOD_CHECKED_P (TREE_TYPE (TREE_VALUE (current))) = 1;\n       }\n }\n \n@@ -4345,9 +4452,12 @@ lookup_java_method2 (clas, method_decl, do_interface)\n      tree clas, method_decl;\n      int do_interface;\n {\n-  tree method, method_signature, method_name, method_type;\n+  tree method, method_signature, method_name, method_type, name;\n+\n   method_signature = build_java_argument_signature (TREE_TYPE (method_decl));\n-  method_name = DECL_NAME (method_decl);\n+  name = DECL_NAME (method_decl);\n+  method_name = (TREE_CODE (name) == EXPR_WITH_FILE_LOCATION ? \n+\t\t EXPR_WFL_NODE (name) : name);\n   method_type = TREE_TYPE (TREE_TYPE (method_decl));\n \n   while (clas != NULL_TREE)\n@@ -4356,12 +4466,12 @@ lookup_java_method2 (clas, method_decl, do_interface)\n \t   method != NULL_TREE;  method = TREE_CHAIN (method))\n \t{\n \t  tree method_sig = build_java_argument_signature (TREE_TYPE (method));\n-\t  if (DECL_NAME (method) == method_name \n+\t  tree name = DECL_NAME (method);\n+\t  if ((TREE_CODE (name) == EXPR_WITH_FILE_LOCATION ?\n+\t       EXPR_WFL_NODE (name) : name) == method_name\n \t      && method_sig == method_signature \n \t      && TREE_TYPE (TREE_TYPE (method)) != method_type)\n-\t    {\n-\t      return method;\n-\t    }\n+\t    return method;\n \t}\n       clas = (do_interface ? NULL_TREE : CLASSTYPE_SUPER (clas));\n     }\n@@ -4450,8 +4560,6 @@ find_in_imports (class_type)\n       {\n \tTYPE_NAME (class_type) = EXPR_WFL_NODE (TREE_PURPOSE (import));\n \tQUALIFIED_P (TYPE_NAME (class_type)) = 1;\n-\treturn check_pkg_class_access (TYPE_NAME (class_type), \n-\t\t\t\t       TREE_PURPOSE (import));\n       }\n   return 0;\n }\n@@ -4675,6 +4783,50 @@ find_in_imports_on_demand (class_type)\n     return (seen_once < 0 ? 0 : seen_once); /* It's ok not to have found */\n }\n \n+static tree\n+resolve_package (pkg, next)\n+     tree pkg, *next;\n+{\n+  tree type_name = NULL_TREE;\n+  char *name = IDENTIFIER_POINTER (EXPR_WFL_NODE (pkg));\n+  int   length = IDENTIFIER_LENGTH (EXPR_WFL_NODE (pkg));\n+\n+  /* The trick is to determine when the package name stops and were\n+     the name of something contained in the package starts. Then we\n+     return a fully qualified name of what we want to get. */\n+\n+  /* Do a quick search on well known package names */\n+  if (!strncmp (name, \"java.lang.reflect\", 17))\n+    {\n+      *next = \n+\tTREE_CHAIN (TREE_CHAIN (TREE_CHAIN (EXPR_WFL_QUALIFICATION (pkg))));\n+      type_name = lookup_package_type (name, 17);\n+    }\n+  else if (!strncmp (name, \"java.lang\", 9))\n+    {\n+      *next = TREE_CHAIN (TREE_CHAIN (EXPR_WFL_QUALIFICATION (pkg)));\n+      type_name = lookup_package_type (name, 9);\n+    }\n+  else\n+    return NULL_TREE;\t\t/* FIXME, search all imported packages. */\n+\n+  return type_name;\n+}\n+\n+static tree\n+lookup_package_type (name, from)\n+     char *name;\n+     int from;\n+{\n+  char subname [128];\n+  char *sub = &name[from+1];\n+  while (*sub != '.' && *sub)\n+    sub++;\n+  strncpy (subname, name, sub-name);\n+  subname [sub-name] = '\\0';\n+  return get_identifier (subname);\n+}\n+\n /* Check that CLASS_NAME refers to a PUBLIC class. Return 0 if no\n    access violations were found, 1 otherwise.  */\n \n@@ -5021,16 +5173,21 @@ add_stmt_to_compound (existing, type, stmt)\n /* Hold THIS for the scope of the current public method decl.  */\n static tree current_this;\n \n-/* Layout all class found during parsing. Also fixes the order of\n-   several field related lists. */\n+/* Layout all class found during parsing. Also fixes the order of some\n+   lists.  */\n \n void\n java_layout_classes ()\n {\n   tree current;\n-  for (current = ctxp->class_list; current; current = TREE_CHAIN (current))\n+\n+  java_check_methods ();\n+  /* Error reported by the caller */\n+  if (java_error_count)\n+    return;\n+  for (current = ctxp->gclass_list; current; current = TREE_CHAIN (current))\n     {\n-      current_class = TREE_TYPE (current);\n+      current_class = TREE_TYPE (TREE_VALUE (current));\n \n       /* Reverse the fields if it's necessary (they've already\n          reversed if the dummy field has been inserted at the\n@@ -5042,6 +5199,10 @@ java_layout_classes ()\n       /* Do a layout if necessary */\n       if (!TYPE_SIZE (current_class) || (current_class == object_type_node))\n \tsafe_layout_class (current_class);\n+\n+      /* Error reported by the caller */\n+      if (java_error_count)\n+\treturn;\n     }\n }\n \n@@ -5080,7 +5241,9 @@ java_complete_expand_methods ()\n \t\t    restore_line_number_status (0);\n \t\t  }\n \t      }\n-\t    else\n+\t    else if (METHOD_ABSTRACT (decl) || METHOD_NATIVE (decl))\n+\t      continue;\n+\t    else \n \t      java_complete_expand_method (decl);\n \t  }\n \n@@ -5135,6 +5298,7 @@ java_complete_expand_method (mdecl)\n \n       if (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl)))\n \tjava_complete_tree (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl)));\n+\n       /* Don't go any further if we've found error(s) during the\n          expansion */\n       if (!java_error_count)\n@@ -5294,6 +5458,13 @@ java_expand_finals ()\n void\n java_expand_classes ()\n {\n+  ctxp = ctxp_for_generation;\n+  /* If we found error earlier, we don't want to report then twice. */\n+  if (java_error_count || !ctxp)\n+    return;\n+  java_layout_classes ();\n+  java_parse_abort_on_error ();\n+\n   for (; ctxp_for_generation; ctxp_for_generation = ctxp_for_generation->next)\n     {\n       ctxp = ctxp_for_generation;\n@@ -5425,8 +5596,9 @@ cut_identifier_in_qualified (wfl)\n /* Resolve the expression name NAME. Return its decl.  */\n \n static tree\n-resolve_expression_name (id)\n+resolve_expression_name (id, orig)\n      tree id;\n+     tree *orig;\n {\n   tree name = EXPR_WFL_NODE (id);\n   tree decl;\n@@ -5445,6 +5617,7 @@ resolve_expression_name (id)\n \t  decl = lookup_field_wrapper (current_class, name);\n \t  if (decl)\n \t    {\n+\t      tree value = NULL_TREE;\n \t      int fs = FIELD_STATIC (decl);\n \t      /* Instance variable (8.3.1.1) can't appear within\n \t\t static method, static initializer or initializer for\n@@ -5468,16 +5641,29 @@ resolve_expression_name (id)\n \t\t     \"constructor has been called\", IDENTIFIER_POINTER (name));\n \t\t  return error_mark_node;\n \t\t}\n+\t      /* The field is final. We may use its value instead */\n+\t      if (fs && FIELD_FINAL (decl))\n+\t\tvalue = java_complete_tree (DECL_LOCAL_STATIC_VALUE (decl));\n+\n+\t      /* Otherwise build what it takes to access the field */\n \t      decl = build_field_ref ((fs ? NULL_TREE : current_this),\n \t\t\t\t      current_class, name);\n-\t      return (fs ? build_class_init (current_class, decl) : decl);\n+\t      if (fs && !flag_emit_class_files)\n+\t\tdecl = build_class_init (current_class, decl);\n+\t      /* We may be asked to save the real field access node */\n+\t      if (orig)\n+\t\t*orig = decl;\n+\t      /* And we return what we got */\n+\t      return (value ? value : decl);\n \t    }\n \t  /* Fall down to error report on undefined variable */\n \t}\n     }\n   /* 6.5.5.2 Qualified Expression Names */\n   else\n     {\n+      if (orig)\n+\t*orig = NULL_TREE;\n       qualify_ambiguous_name (id);\n       /* 15.10.1 Field Access Using a Primary and/or Expression Name */\n       /* 15.10.2: Accessing Superclass Members using super */\n@@ -5523,12 +5709,24 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n     field_ref = decl;\n   else if (DECL_P (decl))\n     {\n+      int static_final_found = 0;\n+      if (!type_found)\n+\ttype_found = DECL_CONTEXT (decl);\n       is_static = DECL_P (decl) && FIELD_STATIC (decl);\n-      field_ref = build_field_ref ((is_static ? NULL_TREE : where_found), \n-\t\t\t\t   type_found, DECL_NAME (decl));\n+      if (FIELD_FINAL (decl) \n+\t  && JPRIMITIVE_TYPE_P (TREE_TYPE (decl))\n+\t  && DECL_LANG_SPECIFIC (decl)\n+\t  && DECL_LOCAL_STATIC_VALUE (decl))\n+\t{\n+\t  field_ref = java_complete_tree (DECL_LOCAL_STATIC_VALUE (decl));\n+\t  static_final_found = 1;\n+\t}\n+      else\n+\tfield_ref = build_field_ref ((is_static ? NULL_TREE : where_found), \n+\t\t\t\t     type_found, DECL_NAME (decl));\n       if (field_ref == error_mark_node)\n \treturn error_mark_node;\n-      if (is_static)\n+      if (is_static && !static_final_found)\n \t{\n \t  field_ref = build_class_init (type_found, field_ref);\n \t  /* If the static field was identified by an expression that\n@@ -5571,7 +5769,6 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n       tree qual_wfl = QUAL_WFL (q);\n \n       /* 15.10.1 Field Access Using a Primary */\n-      \n       switch (TREE_CODE (qual_wfl))\n \t{\n \tcase CALL_EXPR:\n@@ -5619,6 +5816,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t  continue;\n \n \tcase CONDITIONAL_EXPR:\n+\tcase STRING_CST:\n \t  *where_found = decl = java_complete_tree (qual_wfl);\n \t  if (decl == error_mark_node)\n \t    return 1;\n@@ -5660,7 +5858,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t    }\n \t  /* We have to generate code for intermediate acess */\n \t  *where_found = decl = current_this;\n-\t  type = QUAL_DECL_TYPE (decl);\n+\t  *type_found = type = QUAL_DECL_TYPE (decl);\n \t  continue;\n \t}\n \n@@ -5692,17 +5890,33 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t assume a variable/class name was meant. */\n       if (RESOLVE_PACKAGE_NAME_P (qual_wfl))\n \t{\n-\t  if (from_super || from_cast)\n-\t    parse_error_context \n-\t      ((from_cast ? qual_wfl : wfl),\n-\t       \"No variable `%s' defined in class `%s'\",\n-\t       IDENTIFIER_POINTER (EXPR_WFL_NODE (qual_wfl)),\n-\t       lang_printable_name (type, 0));\n+\t  tree name = resolve_package (wfl, &q);\n+\t  if (name)\n+\t    {\n+\t      *where_found = decl = resolve_no_layout (name, qual_wfl);\n+\t      /* We wan't to be absolutely that the class is laid\n+                 out. We're going to search something inside it. */\n+\t      *type_found = type = TREE_TYPE (decl);\n+\t      layout_class (type);\n+\t      from_type = 1;\n+\t      /* Should be a list, really. FIXME */\n+\t      RESOLVE_EXPRESSION_NAME_P (QUAL_WFL (TREE_CHAIN (q))) = 1;\n+\t      RESOLVE_PACKAGE_NAME_P (QUAL_WFL (TREE_CHAIN (q))) = 0;\n+\t    }\n \t  else\n-\t    parse_error_context\n-\t      (qual_wfl, \"Undefined variable or class name: `%s'\",\n-\t       IDENTIFIER_POINTER (EXPR_WFL_NODE (qual_wfl)));\n-\t  return 1;\n+\t    {\n+\t      if (from_super || from_cast)\n+\t\tparse_error_context \n+\t\t  ((from_cast ? qual_wfl : wfl),\n+\t\t   \"No variable `%s' defined in class `%s'\",\n+\t\t   IDENTIFIER_POINTER (EXPR_WFL_NODE (qual_wfl)),\n+\t\t   lang_printable_name (type, 0));\n+\t      else\n+\t\tparse_error_context\n+\t\t  (qual_wfl, \"Undefined variable or class name: `%s'\",\n+\t\t   IDENTIFIER_POINTER (EXPR_WFL_NODE (qual_wfl)));\n+\t      return 1;\n+\t    }\n \t}\n \n       /* We have a type name. It's been already resolved when the\n@@ -5722,6 +5936,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t\t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))));\n \t      return 1;\n \t    }\n+\t  check_deprecation (qual_wfl, decl);\n \t  \n \t  type = TREE_TYPE (decl);\n \t  from_type = 1;\n@@ -5738,18 +5953,24 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t  if (!from_super && QUAL_RESOLUTION (q))\n \t    {\n \t      decl = QUAL_RESOLUTION (q);\n-\t      *type_found = type;\n+\t      if (!type && !FIELD_STATIC (decl))\n+\t\t{\n+\t\t  *where_found = current_this;\n+\t\t  *type_found = type;\n+\t\t}\n \t    }\n \n \t  /* We have to search for a field, knowing the type of its\n              container. The flag FROM_TYPE indicates that we resolved\n              the last member of the expression as a type name, which\n-             means that for the resolution of this field, will check\n-             on other errors than if the it was resolved as a member\n-             of an other field. */\n+             means that for the resolution of this field, we'll look\n+             for other errors than if it was resolved as a member of\n+             an other field. */\n \t  else\n \t    {\n \t      int is_static;\n+\t      tree field_decl_type; /* For layout */\n+\n \t      if (!from_type && !JREFERENCE_TYPE_P (type))\n \t\t{\n \t\t  parse_error_context \n@@ -5769,6 +5990,17 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t\t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n \t\t  return 1;\n \t\t}\n+\n+\t      /* Layout the type of field_decl, since we may need\n+                 it. Don't do primitive types or loaded classes */\n+\t      if (TREE_CODE (TREE_TYPE (field_decl)) == POINTER_TYPE)\n+\t\tfield_decl_type = TREE_TYPE (TREE_TYPE (field_decl));\n+\t      else\n+\t\tfield_decl_type = TREE_TYPE (field_decl);\n+\t      if (!JPRIMITIVE_TYPE_P (field_decl_type) \n+\t\t  && !CLASS_LOADED_P (field_decl_type))\n+\t\tresolve_and_layout (DECL_NAME (TYPE_NAME (field_decl_type)),\n+\t\t\t\t    NULL_TREE);\n \t      \n \t      /* Check on accessibility here */\n \t      if (not_accessible_p (type, field_decl, from_super))\n@@ -5784,6 +6016,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t\t       (DECL_NAME (TYPE_NAME (current_class))));\n \t\t  return 1;\n \t\t}\n+\t      check_deprecation (qual_wfl, field_decl);\n \t      \n \t      /* There are things to check when fields are accessed\n \t         from type. There are no restrictions on a static\n@@ -5802,8 +6035,9 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t\t}\n \t      from_cast = from_super = 0;\n \n-\t      /* If we need to generate something to get a proper handle\n-\t\t on what this field is accessed from, do it now. */\n+\t      /* If we need to generate something to get a proper\n+\t\t handle on what this field is accessed from, do it\n+\t\t now. */\n \t      if (!is_static)\n \t\t{\n \t\t  decl = maybe_access_field (decl, *where_found, *type_found);\n@@ -5889,6 +6123,38 @@ int not_accessible_p (reference, member, from_super)\n   return 0;\n }\n \n+/* Test deprecated decl access.  */\n+static void\n+check_deprecation (wfl, decl)\n+     tree wfl, decl;\n+{\n+  char *file = DECL_SOURCE_FILE (decl);\n+  /* Complain if the field is deprecated and the file it was defined\n+     in isn't compiled at the same time the file which contains its\n+     use is */\n+  if (DECL_DEPRECATED (decl) \n+      && !IS_A_COMMAND_LINE_FILENAME_P (get_identifier (file)))\n+    {\n+      char the [20];\n+      switch (TREE_CODE (decl))\n+\t{\n+\tcase FUNCTION_DECL:\n+\t  strcpy (the, \"method\");\n+\t  break;\n+\tcase FIELD_DECL:\n+\t  strcpy (the, \"field\");\n+\t  break;\n+\tcase TYPE_DECL:\n+\t  strcpy (the, \"class\");\n+\t  break;\n+\t}\n+      parse_warning_context \n+\t(wfl, \"The %s `%s' in class `%s' has been deprecated\", \n+\t the, lang_printable_name (decl, 0),\n+\t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (DECL_CONTEXT (decl)))));\n+    }\n+}\n+\n /* Returns 1 if class was declared in the current package, 0 otherwise */\n \n static int\n@@ -5933,10 +6199,8 @@ static tree\n maybe_access_field (decl, where, type)\n   tree decl, where, type;\n {\n-  if (DECL_P (decl) && decl != current_this\n-      && (!(TREE_CODE (decl) != PARM_DECL\n-\t    && FIELD_STATIC (decl)))\n-      && !IDENTIFIER_LOCAL_VALUE (DECL_NAME (decl)))\n+  if (TREE_CODE (decl) == FIELD_DECL && decl != current_this\n+      && !FIELD_STATIC (decl))\n     decl = build_field_ref (where ? where : current_this, \n \t\t\t    (type ? type : DECL_CONTEXT (decl)),\n \t\t\t    DECL_NAME (decl));\n@@ -5957,7 +6221,7 @@ patch_method_invocation_stmt (patch, primary, where, is_static, ret_decl, super)\n   tree wfl = TREE_OPERAND (patch, 0);\n   tree args = TREE_OPERAND (patch, 1);\n   tree name = EXPR_WFL_NODE (wfl);\n-  tree list, class_type;\n+  tree list;\n   int is_static_flag = 0;\n   \n   /* Should be overriden if everything goes well. Otherwise, if\n@@ -6028,6 +6292,7 @@ patch_method_invocation_stmt (patch, primary, where, is_static, ret_decl, super)\n \t      free (fct_name);\n \t      PATCH_METHOD_RETURN_ERROR ();\n \t    }\n+\t  args = nreverse (args);\n \t}\n       /* We're resolving an expression name */\n       else\n@@ -6053,9 +6318,7 @@ patch_method_invocation_stmt (patch, primary, where, is_static, ret_decl, super)\n \t  args = tree_cons (NULL_TREE, field, nreverse (args));\n \t}\n \n-      /* CLASS_TYPE is used during the call to not_accessible_p and\n-\t IDENTIFIER_WFL will be used to report any problem further */\n-      class_type = TREE_TYPE (class_decl);\n+      /* IDENTIFIER_WFL will be used to report any problem further */\n       wfl = identifier_wfl;\n     }\n   /* Resolution of simple names, names generated after a primary: or\n@@ -6099,8 +6362,11 @@ patch_method_invocation_stmt (patch, primary, where, is_static, ret_decl, super)\n \t\t  PATCH_METHOD_RETURN_ERROR ();\n \t\t}\n \t      \n-\t      /* Can't instantiate an abstract class */\n-\t      if (CLASS_ABSTRACT (class_to_search))\n+\t      /* Can't instantiate an abstract class, but we can\n+\t         invoke it's constructor. It's use within the `new'\n+\t         context is denied here. */\n+\t      if (CLASS_ABSTRACT (class_to_search) \n+\t\t  && TREE_CODE (patch) == NEW_CLASS_EXPR)\n \t\t{\n \t\t  parse_error_context \n \t\t    (wfl, \"Class `%s' is an abstract class. It can't be \"\n@@ -6143,8 +6409,6 @@ patch_method_invocation_stmt (patch, primary, where, is_static, ret_decl, super)\n       args = nreverse (args);\n       if (!METHOD_STATIC (list) && TREE_CODE (patch) != NEW_CLASS_EXPR)\n \targs = tree_cons (NULL_TREE, primary ? primary : current_this, args);\n-\n-      class_type = class_to_search;\n     }\n \n   /* Merge point of all resolution schemes. If we have nothing, this\n@@ -6154,18 +6418,19 @@ patch_method_invocation_stmt (patch, primary, where, is_static, ret_decl, super)\n \n   /* Check accessibility, position the is_static flag, build and\n      return the call */\n-  if (not_accessible_p (class_type, list, 0))\n+  if (not_accessible_p (DECL_CONTEXT (list), list, 0))\n     {\n       char *fct_name = strdup (lang_printable_name (list, 0));\n       parse_error_context \n \t(wfl, \"Can't access %s method `%s %s.%s' from `%s'\",\n \t java_accstring_lookup (get_access_flags_from_decl (list)),\n \t lang_printable_name (TREE_TYPE (TREE_TYPE (list)), 0), \n-\t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (class_type))), fct_name,\n-\t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))));\n+\t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (DECL_CONTEXT (list)))), \n+\t fct_name, IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))));\n       free (fct_name);\n       PATCH_METHOD_RETURN_ERROR ();\n     }\n+  check_deprecation (wfl, list);\n \n   is_static_flag = METHOD_STATIC (list);\n \n@@ -6223,9 +6488,14 @@ patch_invoke (patch, method, args, from_super)\n   tree signature = build_java_signature (TREE_TYPE (method));\n   tree original_call, t, ta;\n \n-  /* Last step for args: convert build-in types. */\n-  for (t = TYPE_ARG_TYPES (TREE_TYPE (method)), ta = args;\n-       t && ta; t = TREE_CHAIN (t), ta = TREE_CHAIN (ta))\n+  /* Last step for args: convert build-in types. If we're dealing with\n+     a new TYPE() type call, the first argument to the constructor\n+     isn't found in the incomming argument list, but delivered by\n+     `new' */\n+  t = TYPE_ARG_TYPES (TREE_TYPE (method));\n+  if (TREE_CODE (patch) == NEW_CLASS_EXPR)\n+    t = TREE_CHAIN (t);\n+  for (ta = args; t && ta; t = TREE_CHAIN (t), ta = TREE_CHAIN (ta))\n     if (JPRIMITIVE_TYPE_P (TREE_TYPE (TREE_VALUE (ta))) &&\n \tTREE_TYPE (TREE_VALUE (ta)) != TREE_VALUE (t))\n       TREE_VALUE (ta) = convert (TREE_VALUE (t), TREE_VALUE (ta));\n@@ -6243,6 +6513,11 @@ patch_invoke (patch, method, args, from_super)\n \t\t\t\t     DECL_CONTEXT (method), signature, args);\n       break;\n \n+    case INVOKE_INTERFACE:\n+      dtable = invoke_build_dtable (1, args);\n+      func = build_invokeinterface (dtable, DECL_NAME (method), signature);\n+      break;\n+\n     default:\n       fatal (\"Unknown invocation mode `%d' - build_invoke\", im);\n       return NULL_TREE;\n@@ -6318,34 +6593,24 @@ lookup_method_invoke (lc, cl, class, name, arg_list)\n      tree class, name, arg_list;\n {\n   tree method = make_node (FUNCTION_TYPE);\n-  tree arg_type_list = NULL_TREE;\n+  tree atl = NULL_TREE;\t\t/* Arg Type List */\n   tree signature, list, node;\n   char *candidates;\t\t/* Used for error report */\n \n+  /* Fix the arguments */\n   for (node = arg_list; node; node = TREE_CHAIN (node))\n     {\n       tree current_arg = TREE_TYPE (TREE_VALUE (node));\n       if (TREE_CODE (current_arg) == RECORD_TYPE)\n \tcurrent_arg = promote_type (current_arg);\n-      arg_type_list = tree_cons (NULL_TREE, current_arg, arg_type_list);\n+      atl = tree_cons (NULL_TREE, current_arg, atl);\n     }\n-  TYPE_ARG_TYPES (method) = arg_type_list;\n+  TYPE_ARG_TYPES (method) = atl;\n \n-  if (!lc)\n-    {\n-      list = find_applicable_accessible_methods_list (class, name, \n-\t\t\t\t\t\t      arg_type_list);\n-      list = find_most_specific_methods_list (list);\n-    }\n-  else\n-    {\n-      TREE_TYPE (method) = void_type_node;\n-      signature = build_java_signature (method);\n-      list = lookup_java_constructor (class, signature);\n-    }\n-\n-  if (lc && list)\n-    return list;\n+  /* Find all candidates and then refine the list, searching for the\n+     most specific method. */\n+  list = find_applicable_accessible_methods_list (lc, class, name, atl);\n+  list = find_most_specific_methods_list (list);\n   if (list && !TREE_CHAIN (list))\n     return TREE_VALUE (list);\n \n@@ -6386,10 +6651,12 @@ lookup_method_invoke (lc, cl, class, name, arg_list)\n   return NULL_TREE;\n }\n \n-/* 15.11.2.1: Find Methods that are Applicable and Accessible */\n+/* 15.11.2.1: Find Methods that are Applicable and Accessible. LC is 1\n+   when we're looking for a constructor. */\n \n static tree\n-find_applicable_accessible_methods_list (class, name, arglist)\n+find_applicable_accessible_methods_list (lc, class, name, arglist)\n+     int lc;\n      tree class, name, arglist;\n {\n   tree method;\n@@ -6400,10 +6667,12 @@ find_applicable_accessible_methods_list (class, name, arglist)\n       for (method = TYPE_METHODS (class);\n \t   method != NULL_TREE;  method = TREE_CHAIN (method))\n \t{\n-\t  /* Names have to match and we're not looking for constructor */\n-\t  if (DECL_NAME (method) != name || DECL_CONSTRUCTOR_P (method))\n+\t  if (lc && !DECL_CONSTRUCTOR_P (method))\n \t    continue;\n-\n+\t  else if (!lc && (DECL_CONSTRUCTOR_P (method)\n+\t\t\t   || DECL_NAME (method) != name))\n+\t    continue;\n+\t  \n \t  if (argument_types_convertible (method, arglist))\n \t    {\n \t      /* Retain accessible methods only */\n@@ -6414,7 +6683,9 @@ find_applicable_accessible_methods_list (class, name, arglist)\n \t\tall_list = tree_cons (NULL_TREE, method, list);\n \t    }\n \t}\n-      class = CLASSTYPE_SUPER (class);\n+      /* When dealing with constructor, stop here, otherwise search\n+         other classes */\n+      class = (lc ? NULL_TREE : CLASSTYPE_SUPER (class));\n     }\n   /* Either return the list obtained or all selected (but\n      inaccessible) methods for better error report. */\n@@ -6598,8 +6869,9 @@ qualify_ambiguous_name (id)\n \t/* Do one more interation to set things up */\n \tsuper_found = again = 1;\n       }\n-    /* Loop one more time if we're dealing with ?: up front */\n-    if (TREE_CODE (qual_wfl) == CONDITIONAL_EXPR)\n+    /* Loop one more time if we're dealing with ?: or a string constant */\n+    if (TREE_CODE (qual_wfl) == CONDITIONAL_EXPR\n+\t|| TREE_CODE (qual_wfl) == STRING_CST)\n       {\n \tqual = TREE_CHAIN (qual);\n \tqual_wfl = QUAL_WFL (qual);\n@@ -6709,8 +6981,10 @@ not_initialized_as_it_should_p (decl)\n {\n   if (DECL_P (decl))\n     {\n-      if (TREE_CODE (decl) == FIELD_DECL\n-\t  && METHOD_STATIC (current_function_decl))\n+      if (FIELD_FINAL (decl))\n+\treturn 0;\n+      if (TREE_CODE (decl) == FIELD_DECL \n+\t  && (METHOD_STATIC (current_function_decl)))\n \treturn 0;\n       return DECL_P (decl) && !INITIALIZED_P (decl);\n     }\n@@ -6860,7 +7134,7 @@ java_complete_tree (node)\n     case EXPR_WITH_FILE_LOCATION:\n       if (!EXPR_WFL_NODE (node) /* Or a PRIMARY flag ? */\n \t  || TREE_CODE (EXPR_WFL_NODE (node)) == IDENTIFIER_NODE)\n-        return resolve_expression_name (node);\n+        return resolve_expression_name (node, NULL);\n       else\n \t{\n \t  EXPR_WFL_NODE (node) = java_complete_tree (EXPR_WFL_NODE (node));\n@@ -6958,7 +7232,8 @@ java_complete_tree (node)\n \t     an error during the assignment. In any cases, the\n \t     assignment operation fails. */\n \t  if (TREE_CODE (TREE_OPERAND (node, 1)) != EXPR_WITH_FILE_LOCATION\n-\t      && TREE_TYPE (TREE_OPERAND (node, 1)) != error_mark_node)\n+\t      && TREE_TYPE (TREE_OPERAND (node, 1)) != error_mark_node\n+\t      && TREE_TYPE (TREE_OPERAND (node, 1)))\n \t    patch_assignment (node, wfl_op1, wfl_op2);\n \n \t  /* Now, we still mark the lhs as initialized */\n@@ -7015,6 +7290,11 @@ java_complete_tree (node)\n \t}\n       return patch_binop (node, wfl_op1, wfl_op2);\n \n+    case INSTANCEOF_EXPR:\n+      wfl_op1 = TREE_OPERAND (node, 0);\n+      COMPLETE_CHECK_OP_0 (node);\n+      return patch_binop (node, wfl_op1, TREE_OPERAND (node, 1));\n+\n     case UNARY_PLUS_EXPR:\n     case NEGATE_EXPR:\n     case TRUTH_NOT_EXPR:\n@@ -7108,8 +7388,10 @@ complete_function_arguments (node)\n \t `+' operator. Build `parm.toString()' and expand it. */\n       if ((temp = patch_string (parm)))\n \tparm = temp;\n-      TREE_VALUE (cn) = parm;\n+      /* Inline PRIMTYPE.TYPE read access */\n+      parm = maybe_build_primttype_type_ref (parm, wfl);\n \n+      TREE_VALUE (cn) = parm;\n       if (not_initialized_as_it_should_p (parm))\n \t{\n \t  ERROR_VARIABLE_NOT_INITIALIZED (wfl, EXPR_WFL_NODE (wfl));\n@@ -7350,6 +7632,47 @@ print_int_node (node)\n   return buffer;\n }\n \n+/* Return 1 if you an assignment of a FINAL is attempted */\n+\n+static int\n+check_final_assignment (lvalue, wfl)\n+     tree lvalue, wfl;\n+{\n+  if (DECL_P (lvalue) && FIELD_FINAL (lvalue))\n+    {\n+      parse_error_context \n+        (wfl, \"Can't assign a value to the final variable `%s'\",\n+\t IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl)));\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Inline references to java.lang.PRIMTYPE.TYPE when accessed in\n+   read. This is needed to avoid circularities in the implementation\n+   of these fields in libjava. */\n+\n+static tree\n+maybe_build_primttype_type_ref (rhs, wfl)\n+    tree rhs, wfl;\n+{\n+  tree to_return = NULL_TREE;\n+  tree rhs_type = TREE_TYPE (rhs);\n+  if (TREE_CODE (rhs) == COMPOUND_EXPR)\n+    {\n+      tree n = TREE_OPERAND (rhs, 1);\n+      if (TREE_CODE (n) == VAR_DECL \n+\t  && DECL_NAME (n) == TYPE_identifier_node\n+\t  && rhs_type == class_ptr_type)\n+\t{\n+\t  char *self_name = IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl));\n+\t  if (!strncmp (self_name, \"java.lang.\", 10))\n+\t    to_return = build_primtype_type_ref (self_name);\n+\t}\n+    }\n+  return (to_return ? to_return : rhs );\n+}\n+\n /* 15.25 Assignment operators. */\n \n static tree\n@@ -7359,19 +7682,14 @@ patch_assignment (node, wfl_op1, wfl_op2)\n      tree wfl_op2;\n {\n   tree rhs = TREE_OPERAND (node, 1);\n-  tree lvalue = TREE_OPERAND (node, 0);\n+  tree lvalue = TREE_OPERAND (node, 0), llvalue;\n   tree lhs_type, rhs_type, new_rhs = NULL_TREE;\n   int error_found = 0;\n   int lvalue_from_array = 0;\n \n   /* Can't assign to a final. */\n-  if (DECL_P (lvalue) && FIELD_FINAL (lvalue))\n-    {\n-      parse_error_context \n-        (wfl_op1, \"Can't assign a value to the final variable `%s'\",\n-\t IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl_op1)));\n-      error_found = 1;\n-    }\n+  if (check_final_assignment (lvalue, wfl_op1))\n+    error_found = 1;\n \n   EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n \n@@ -7394,8 +7712,18 @@ patch_assignment (node, wfl_op1, wfl_op2)\n   /* Or a function return slot */\n   else if (TREE_CODE (lvalue) == RESULT_DECL)\n     lhs_type = TREE_TYPE (lvalue);\n-  /* Otherwise, this is an error */\n-  else\n+  /* Otherwise, we might want to try to write into an optimized static\n+     final, this is an of a different nature, reported further on. */\n+  else if (TREE_CODE (wfl_op1) == EXPR_WITH_FILE_LOCATION\n+\t   && resolve_expression_name (wfl_op1, &llvalue)\n+\t   && check_final_assignment (llvalue, wfl_op1))\n+    {\n+      error_found = 1;\n+      /* What we should do instead is resetting the all the flags\n+         previously set, exchange lvalue for llvalue and continue. */\n+      return error_mark_node;\n+    }\n+  else \n     {\n       parse_error_context (wfl_op1, \"Invalid left hand side of assignment\");\n       error_found = 1;\n@@ -7462,6 +7790,22 @@ patch_assignment (node, wfl_op1, wfl_op2)\n       INITIALIZED_P (rhs) = 1;\n     }\n \n+  /* Inline read access to java.lang.PRIMTYPE.TYPE */\n+  rhs = maybe_build_primttype_type_ref (rhs, wfl_op2);\n+\n+  if (TREE_CODE (rhs) == COMPOUND_EXPR)\n+    {\n+      tree n = TREE_OPERAND (rhs, 1);\n+      if (TREE_CODE (n) == VAR_DECL \n+\t  && DECL_NAME (n) == TYPE_identifier_node\n+\t  && rhs_type == class_ptr_type)\n+\t{\n+\t  char *self_name = IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl_op2));\n+\t  if (!strncmp (self_name, \"java.lang.\", 10))\n+\t    rhs = build_primtype_type_ref (self_name);\n+\t}\n+    }\n+\n   if (error_found)\n     return error_mark_node;\n \n@@ -7515,9 +7859,15 @@ try_builtin_assignconv (wfl_op1, lhs_type, rhs)\n   tree new_rhs = NULL_TREE;\n   tree rhs_type = TREE_TYPE (rhs);\n \n+  /* Zero accepted everywhere */\n+  if (TREE_CODE (rhs) == INTEGER_CST \n+      && TREE_INT_CST_HIGH (rhs) == 0 && TREE_INT_CST_LOW (rhs) == 0\n+      && JPRIMITIVE_TYPE_P (rhs_type))\n+    new_rhs = convert (lhs_type, rhs);\n+\n   /* 5.1.1 Try Identity Conversion,\n      5.1.2 Try Widening Primitive Conversion */\n-  if (valid_builtin_assignconv_identity_widening_p (lhs_type, rhs_type))\n+  else if (valid_builtin_assignconv_identity_widening_p (lhs_type, rhs_type))\n     new_rhs = convert (lhs_type, rhs);\n \n   /* Try a narrowing primitive conversion (5.1.3): \n@@ -7552,20 +7902,32 @@ static int\n valid_builtin_assignconv_identity_widening_p (lhs_type, rhs_type)\n      tree lhs_type, rhs_type;\n {\n-  int all_primitive = \n+  int all_primitive;\n+\n+  if (lhs_type == rhs_type)\n+    return 1;\n+\n+  all_primitive = \n     JPRIMITIVE_TYPE_P (lhs_type) && JPRIMITIVE_TYPE_P (rhs_type);\n \n   if (!all_primitive)\n     return 0;\n \n-  if (lhs_type == rhs_type)\n-    return 1;\n-\n   /* byte, even if it's smaller than a char can't be converted into a\n      char. Short can't too, but the < test below takes care of that */\n   if (lhs_type == char_type_node && rhs_type == byte_type_node)\n     return 0;\n \n+  /* Accept all promoted type here. Note, we can't use <= in the test\n+     below, because we still need to bounce out assignments of short\n+     to char and the likes */\n+  if (lhs_type == int_type_node\n+      && (rhs_type == promoted_byte_type_node\n+\t  || rhs_type == promoted_short_type_node\n+\t  || rhs_type == promoted_char_type_node\n+\t  || rhs_type == promoted_boolean_type_node))\n+    return 1;\n+\n   if (JINTEGRAL_TYPE_P (rhs_type)\n       && ((TYPE_PRECISION (rhs_type) < TYPE_PRECISION (lhs_type))\n \t  || (JFLOAT_TYPE_P (lhs_type) &&\n@@ -7590,6 +7952,8 @@ valid_ref_assignconv_cast_p (source, dest, cast)\n      tree dest;\n      int cast;\n {\n+  if (JNULLP_TYPE_P (source))\n+    return 1;\n   if (TREE_CODE (source) == POINTER_TYPE)\n     source = TREE_TYPE (source);\n   if (TREE_CODE (dest) == POINTER_TYPE)\n@@ -7715,8 +8079,8 @@ valid_method_invocation_conversion_p (dest, source)\n   return ((JPRIMITIVE_TYPE_P (source) \n \t    && JPRIMITIVE_TYPE_P (dest)\n \t    && valid_builtin_assignconv_identity_widening_p (dest, source))\n-\t   || (JREFERENCE_TYPE_P (source) \n-\t       && JREFERENCE_TYPE_P (dest)\n+\t   || ((JREFERENCE_TYPE_P (source) || JNULLP_TYPE_P (source))\n+\t       && (JREFERENCE_TYPE_P (dest) || JNULLP_TYPE_P (dest))\n \t       && valid_ref_assignconv_cast_p (source, dest, 0)));\n }\n \n@@ -7728,9 +8092,7 @@ build_binop (op, op_location, op1, op2)\n      int op_location;\n      tree op1, op2;\n {\n-  tree binop;\n-\n-  binop = build (op, NULL_TREE, op1, op2);\n+  tree binop = build (op, NULL_TREE, op1, op2);\n   TREE_SIDE_EFFECTS (binop) = 1;\n   /* Store the location of the operator, for better error report. The\n      string of the operator will be rebuild based on the OP value. */\n@@ -7935,7 +8297,63 @@ patch_binop (node, wfl_op1, wfl_op2)\n \t  TREE_SET_CODE (node, RSHIFT_EXPR);\n \t}\n       break;\n+\n+      /* 15.19.1 Type Comparison Operator instaceof */\n+    case INSTANCEOF_EXPR:\n+\n+      TREE_TYPE (node) = boolean_type_node;\n+\n+      if (!(op2_type = resolve_type_during_patch (op2)))\n+\treturn error_mark_node;\n+\n+      /* The first operand must be a reference type or the null type */\n+      if (!JREFERENCE_TYPE_P (op1_type) && op1 != null_pointer_node)\n+\terror_found = 1;\t/* Error reported further below */\n+\n+      /* The second operand must be a reference type */\n+      if (!JREFERENCE_TYPE_P (op2_type))\n+\t{\n+\t  SET_WFL_OPERATOR (wfl_operator, node, wfl_op2);\n+\t  parse_error_context\n+\t    (wfl_operator, \"Invalid argument `%s' for `instanceof'\",\n+\t     lang_printable_name (op2_type, 0));\n+\t  error_found = 1;\n+\t}\n+\n+      if (!error_found && valid_ref_assignconv_cast_p (op1_type, op2_type, 1))\n+\t{\n+\t  /* If the first operand is null, the result is always false */\n+\t  if (op1 == null_pointer_node)\n+\t    return boolean_false_node;\n+\t  /* Otherwise we have to invoke instance of to figure it out */\n+\t  else\n+\t    {\n+\t      tree call =\n+\t\tbuild (CALL_EXPR, boolean_type_node,\n+\t\t       build_address_of (soft_instanceof_node),\n+\t\t       tree_cons \n+\t\t       (NULL_TREE, op1,\n+\t\t\tbuild_tree_list (NULL_TREE,\n+\t\t\t\t\t build_class_ref (op2_type))),\n+\t\t       NULL_TREE);\n+\t      TREE_SIDE_EFFECTS (call) = 1;\n+\t      return call;\n+\t    }\n+\t}\n+      /* There is no way the expression operand can be an instance of\n+\t the type operand. This is a compile time error. */\n+      else\n+\t{\n+\t  char *t1 = strdup (lang_printable_name (op1_type, 0));\n+\t  SET_WFL_OPERATOR (wfl_operator, node, wfl_op1);\n+\t  parse_error_context \n+\t    (wfl_operator, \"Impossible for `%s' to be instance of `%s'\",\n+\t     t1, lang_printable_name (op2_type, 0));\n+\t  free (t1);\n+\t  error_found = 1;\n+\t}\n       \n+      break;\n \n       /* 15.21 Bitwise and Logical Operators */\n     case BIT_AND_EXPR:\n@@ -8011,7 +8429,7 @@ patch_binop (node, wfl_op1, wfl_op2)\n     case NE_EXPR:\n       /* 15.20.1 Numerical Equality Operators == and != */\n       /* Binary numeric promotion is performed on the operands */\n-      if (JPRIMITIVE_TYPE_P (op1_type) && JPRIMITIVE_TYPE_P (op2_type))\n+      if (JNUMERIC_TYPE_P (op1_type) && JNUMERIC_TYPE_P (op2_type))\n \tbinary_numeric_promotion (op1_type, op2_type, &op1, &op2);\n       \n       /* 15.20.2 Boolean Equality Operators == and != */\n@@ -8020,10 +8438,14 @@ patch_binop (node, wfl_op1, wfl_op2)\n \t;\t\t\t/* Nothing to do here */\n       \n       /* 15.20.3 Reference Equality Operators == and != */\n-      /* Types have to be either references or the null type */\n+      /* Types have to be either references or the null type. If\n+         they're references, it must be possible to convert either\n+         type to the other by casting conversion. */\n       else if (op1 == null_pointer_node || op2 == null_pointer_node \n \t       || (JREFERENCE_TYPE_P (op1_type) && JREFERENCE_TYPE_P (op2_type)\n-\t\t   && ((op1_type == op2_type))))\n+\t\t   && (valid_ref_assignconv_cast_p (op1_type, op2_type, 1)\n+\t\t       || valid_ref_assignconv_cast_p (op2_type, \n+\t\t\t\t\t\t       op1_type, 1))))\n \t;\t\t\t/* Nothing to do here */\n \t  \n       /* Else we have an error figure what can't be converted into\n@@ -8344,22 +8766,25 @@ patch_unaryop (node, wfl_op)\n     case PREINCREMENT_EXPR:\n       /* 15.14.2 Prefix Decrement Operator -- */\n     case PREDECREMENT_EXPR:\n-      if (!DECL_P (op) && !(TREE_CODE (op) == INDIRECT_REF \n+      if (!DECL_P (op) && !((TREE_CODE (op) == INDIRECT_REF \n+\t\t\t     || TREE_CODE (op) == COMPONENT_REF) \n \t\t\t    && JPRIMITIVE_TYPE_P (TREE_TYPE (op))))\n \t{\n-\t  parse_error_context (wfl_operator, \"Invalid argument to `%s'\",\n-\t\t\t       operator_string (node));\n-\t  TREE_TYPE (node) = error_mark_node;\n-\t  error_found = 1;\n-\t}\n-      else if (DECL_P (op) && FIELD_FINAL (op))\n-\t{\n-\t  parse_error_context \n-\t    (wfl_op, \"Can't assign a value to the final variable `%s'\",\n-\t     IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl_op)));\n+\t  tree lvalue;\n+\t  /* Before screaming, check that we're not in fact trying to\n+\t     increment a optimized static final access, in which case\n+\t     we issue an different error message. */\n+\t  if (!(TREE_CODE (wfl_op) == EXPR_WITH_FILE_LOCATION\n+\t\t&& resolve_expression_name (wfl_op, &lvalue)\n+\t\t&& check_final_assignment (lvalue, wfl_op)))\n+\t    parse_error_context (wfl_operator, \"Invalid argument to `%s'\",\n+\t\t\t\t operator_string (node));\n \t  TREE_TYPE (node) = error_mark_node;\n \t  error_found = 1;\n \t}\n+      else if (check_final_assignment (op, wfl_op))\n+\terror_found = 1;\n+\n       /* From now on, we know that op if a variable and that it has a\n          valid wfl. We use wfl_op to locate errors related to the\n          ++/-- operand. */\n@@ -8480,7 +8905,10 @@ resolve_type_during_patch (type)\n \t  return NULL_TREE;\n \t}\n       else\n-\treturn TREE_TYPE (type_decl);\n+\t{\n+\t  CLASS_LOADED_P (TREE_TYPE (type_decl)) = 1;\n+\t  return TREE_TYPE (type_decl);\n+\t}\n     }\n   return type;\n }\n@@ -8515,6 +8943,10 @@ patch_cast (node, wfl_operator)\n       return convert (cast_type, op);\n     }\n \n+  /* null can be casted to references */\n+  if (op == null_pointer_node && JREFERENCE_TYPE_P (cast_type))\n+    return build_null_of_type (cast_type);\n+\n   /* The remaining legal casts involve conversion between reference\n      types. Check for their compile time correctness. */\n   if (JREFERENCE_TYPE_P (op_type) && JREFERENCE_TYPE_P (cast_type) \n@@ -8544,6 +8976,17 @@ patch_cast (node, wfl_operator)\n   return error_mark_node;\n }\n \n+/* Build a null constant and give it the type TYPE.  */\n+\n+static tree\n+build_null_of_type (type)\n+     tree type;\n+{\n+  tree node = build_int_2 (0, 0);\n+  TREE_TYPE (node) = promote_type (type);\n+  return node;\n+}\n+\n /* Build an ARRAY_REF incomplete tree node. Note that operand 1 isn't\n    a list of indices. */\n static tree\n@@ -8617,8 +9060,11 @@ patch_array_ref (node, wfl_array, wfl_index)\n     return error_mark_node;\n   index = convert (promoted_index_type, index);\n \n-  if (TREE_CODE (array_type) == RECORD_TYPE)\n-    array_type = promote_type (TYPE_ARRAY_ELEMENT (array_type));\n+  array_type = TYPE_ARRAY_ELEMENT (array_type);\n+  if (TREE_CODE (array_type) == RECORD_TYPE \n+      && !JPRIMITIVE_TYPE_P (TREE_TYPE (array_type)))\n+    array_type = promote_type (array_type);\n+\n   if (flag_emit_class_files)\n     {\n       TREE_OPERAND (node, 0)= array;\n@@ -8804,7 +9250,6 @@ patch_return (node)\n   tree return_exp = TREE_OPERAND (node, 0);\n   tree meth = current_function_decl;\n   tree mtype = TREE_TYPE (TREE_TYPE (current_function_decl));\n-  tree modify;\n   int error_found = 0;\n \n   TREE_TYPE (node) = error_mark_node;\n@@ -8838,12 +9283,33 @@ patch_return (node)\n       return error_mark_node;\n     }\n \n-  /* If we have a return_exp, build a modify expression and expand it */\n+  /* If we have a return_exp, build a modify expression and expand\n+     it. Note: at that point, the assignment is declared valid, but we\n+     may want to carry some more hacks */\n   if (return_exp)\n     {\n-      modify = build (MODIFY_EXPR, NULL_TREE, DECL_RESULT (meth), return_exp);\n+      tree exp = java_complete_tree (return_exp);\n+      tree modify, patched;\n+\n+      /* If the function returned value and EXP are booleans, EXP has\n+      to be converted into the type of DECL_RESULT, which is integer\n+      (see complete_start_java_method) */\n+      if (TREE_TYPE (exp) == boolean_type_node &&\n+\t  TREE_TYPE (TREE_TYPE (meth)) == boolean_type_node)\n+\texp = convert_to_integer (TREE_TYPE (DECL_RESULT (meth)), exp);\n+\n+      /* `null' can be assigned to a function returning a reference */\n+      if (JREFERENCE_TYPE_P (TREE_TYPE (TREE_TYPE (meth))) &&\n+\t  exp == null_pointer_node)\n+\texp = build_null_of_type (TREE_TYPE (TREE_TYPE (meth)));\n+\n+      if ((patched = patch_string (exp)))\n+\texp = patched;\n+      \n+      modify = build (MODIFY_EXPR, NULL_TREE, DECL_RESULT (meth), exp);\n       EXPR_WFL_LINECOL (modify) = EXPR_WFL_LINECOL (node);\n       modify = java_complete_tree (modify);\n+\n       if (modify != error_mark_node)\n \t{\n \t  TREE_SIDE_EFFECTS (modify) = 1;"}, {"sha": "154ba571de57b9c4dd93ef5931c3df4341bc537a", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e942c506635af4d8ffc95aeb1bebc46a5584c73/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=5e942c506635af4d8ffc95aeb1bebc46a5584c73", "patch": "@@ -52,10 +52,6 @@ set_local_type (slot, type)\n     type_map[++slot] = void_type_node;\n }\n \n-extern tree convert_to_integer (tree type, tree expr);\n-extern tree convert_to_real (tree type, tree expr);\n-extern tree convert_to_pointer (tree type, tree expr);\n-\n /* Create an expression whose value is that of EXPR,\n    converted to type TYPE.  The TREE_TYPE of the value\n    is always TYPE.  This function implements all reasonable\n@@ -663,7 +659,7 @@ lookup_argument_method (clas, method_name, method_signature)\n \t  tree method_sig = build_java_argument_signature (TREE_TYPE (method));\n \t  tree name = DECL_NAME (method);\n \t  if ((TREE_CODE (name) == EXPR_WITH_FILE_LOCATION ?\n-\t       EXPR_WFL_NODE (DECL_NAME (method)) : name) == method_name \n+\t       EXPR_WFL_NODE (name) : name) == method_name \n \t      && method_sig == method_signature)\n \t    return method;\n \t}"}]}