{"sha": "05fb69e4c9ce7e8767d36e5bfb5c0e6e67d3b905", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDVmYjY5ZTRjOWNlN2U4NzY3ZDM2ZTViZmI1YzBlNmU2N2QzYjkwNQ==", "commit": {"author": {"name": "Dirk Mueller", "email": "dmueller@suse.de", "date": "2007-04-18T20:09:21Z"}, "committer": {"name": "Dirk Mueller", "email": "mueller@gcc.gnu.org", "date": "2007-04-18T20:09:21Z"}, "message": "re PR tree-optimization/31227 (-Warray-bounds doesn't play together with loop optimizations)\n\n2007-04-18  Dirk Mueller  <dmueller@suse.de>\n\n       PR diagnostic/31227\n       * tree-vrp.c (search_for_addr_array): New.\n       (check_array_bounds): Suppress warning about\n       address taken of array refs if its not de-referenced.\n\n       * gcc.dg/Warray-bounds-3.c: New.\n\nFrom-SVN: r123958", "tree": {"sha": "62909f2190eec0ab07088cbefcf865ed93cdca51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62909f2190eec0ab07088cbefcf865ed93cdca51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05fb69e4c9ce7e8767d36e5bfb5c0e6e67d3b905", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05fb69e4c9ce7e8767d36e5bfb5c0e6e67d3b905", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05fb69e4c9ce7e8767d36e5bfb5c0e6e67d3b905", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05fb69e4c9ce7e8767d36e5bfb5c0e6e67d3b905/comments", "author": null, "committer": null, "parents": [{"sha": "28e44f4fe6750b8e7389f496f2267dcf3bc2117c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28e44f4fe6750b8e7389f496f2267dcf3bc2117c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28e44f4fe6750b8e7389f496f2267dcf3bc2117c"}], "stats": {"total": 196, "additions": 162, "deletions": 34}, "files": [{"sha": "db9ff5cf8371a6a624953dd44119c8de8b415fae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05fb69e4c9ce7e8767d36e5bfb5c0e6e67d3b905/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05fb69e4c9ce7e8767d36e5bfb5c0e6e67d3b905/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=05fb69e4c9ce7e8767d36e5bfb5c0e6e67d3b905", "patch": "@@ -1,3 +1,10 @@\n+2007-04-18  Dirk Mueller  <dmueller@suse.de>\n+\n+\tPR diagnostic/31227\n+\t* tree-vrp.c (search_for_addr_array): New.\n+\t(check_array_bounds): Suppress warning about\n+\taddress taken of array refs if its not de-referenced.\n+\n 2007-04-18  Dorit Nuzman  <dorit@il.ibm.com>\n \n \t* tree-vectorizer.c (destroy_loop_vec_info): Set loop->aux to NULL."}, {"sha": "06c53cf210467ec36e5421e8d14bb0decf3d2a36", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05fb69e4c9ce7e8767d36e5bfb5c0e6e67d3b905/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05fb69e4c9ce7e8767d36e5bfb5c0e6e67d3b905/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=05fb69e4c9ce7e8767d36e5bfb5c0e6e67d3b905", "patch": "@@ -1,3 +1,8 @@\n+2007-04-18  Dirk Mueller  <dmueller@suse.de>\n+\n+\tPR diagnostic/31227\n+\t* gcc.dg/Warray-bounds-3.c: New.\n+\n 2007-04-18  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/19431"}, {"sha": "19cdb8e5fe104efd914fa3e3f0cb5bf8e788ffe0", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-3.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05fb69e4c9ce7e8767d36e5bfb5c0e6e67d3b905/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05fb69e4c9ce7e8767d36e5bfb5c0e6e67d3b905/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-3.c?ref=05fb69e4c9ce7e8767d36e5bfb5c0e6e67d3b905", "patch": "@@ -0,0 +1,108 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Warray-bounds\" } */\n+/* based on PR 31227 */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern size_t strlen (const char *);\n+\n+struct iovec\n+{\n+  void *iov_base;\n+  size_t iov_len;\n+};\n+\n+struct S\n+{\n+  const char *abday[7];\n+  const char *day[7];\n+  const char *abmon[12];\n+  const char *mon[12];\n+  const char *am_pm[2];\n+};\n+\n+extern void foo (size_t, struct iovec *);\n+\n+void\n+bar (struct S *time)\n+{\n+  struct iovec iov[43];\n+  size_t cnt;\n+  iov[0].iov_base = (void *) \"abc\";\n+  iov[0].iov_len = 3;\n+\n+  iov[1].iov_base = (void *) \"def\";\n+  iov[1].iov_len = 3;\n+\n+  for (cnt = 0; cnt <= 7; ++cnt)\n+    {\n+      iov[2 + cnt].iov_base = (void *) (time->abday[cnt] ?: \"\");\n+      iov[2 + cnt].iov_len = strlen (iov[2 + cnt].iov_base) + 1;\n+    }\n+\n+  for (; cnt <= 14; ++cnt)\n+    {\n+      iov[2 + cnt].iov_base = (void *) (time->day[cnt - 7] ?: \"\");\n+      iov[2 + cnt].iov_len = strlen (iov[2 + cnt].iov_base) + 1;\n+    }\n+\n+  for (; cnt <= 26; ++cnt)\n+    {\n+      iov[2 + cnt].iov_base = (void *) (time->abmon[cnt - 14] ?: \"\");\n+      iov[2 + cnt].iov_len = strlen (iov[2 + cnt].iov_base) + 1;\n+    }\n+\n+  for (; cnt <= 38; ++cnt)\n+    {\n+      iov[2 + cnt].iov_base = (void *) (time->mon[cnt - 26] ?: \"\");\n+      iov[2 + cnt].iov_len = strlen (iov[2 + cnt].iov_base) + 1;\n+    }\n+\n+  for (; cnt <= 40; ++cnt)\n+    {\n+      iov[2 + cnt].iov_base =  (void *) (time->am_pm[cnt - 38] ?: \"\");\n+      iov[2 + cnt].iov_len = strlen (iov[2 + cnt].iov_base) + 1;\n+    }\n+\n+  foo (2 + cnt, iov);\n+}\n+\n+struct malloc_chunk {\n+  long prev_size;\n+  long size;\n+  struct malloc_chunk* fd;\n+  struct malloc_chunk* bk;\n+};\n+typedef struct malloc_chunk* mchunkptr;\n+struct malloc_state {\n+  mchunkptr        top;\n+  mchunkptr        last_remainder;\n+  mchunkptr        bins[128 * 2 - 2];\n+};\n+#define bin_at(m, i) \\\n+  (mchunkptr) (((char *) &((m)->bins[((i) - 1) * 2]))                         \\\n+             - __builtin_offsetof (struct malloc_chunk, fd))\n+\n+void malloc_init_state(struct malloc_state *av)\n+{\n+  int     i;\n+  mchunkptr bin;\n+\n+  for (i = 1; i < 128; ++i) {\n+    bin = bin_at(av,i);\n+    bin->fd = bin->bk = bin;\n+  }\n+}\n+\n+typedef unsigned short WCHAR;\n+typedef WCHAR *LPWSTR;\n+\n+static void g(LPWSTR dest, int len) {\n+     dest[len-1] = 0;\n+}\n+\n+void f() {\n+    WCHAR szPathW[260];\n+\n+    g(szPathW, 260);\n+}"}, {"sha": "e35a6e9008d0ed065d846559ddf91c4283795622", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 42, "deletions": 34, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05fb69e4c9ce7e8767d36e5bfb5c0e6e67d3b905/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05fb69e4c9ce7e8767d36e5bfb5c0e6e67d3b905/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=05fb69e4c9ce7e8767d36e5bfb5c0e6e67d3b905", "patch": "@@ -4233,6 +4233,36 @@ check_array_ref (tree ref, location_t* locus, bool ignore_off_by_one)\n     }\n }\n \n+/* Searches if the expr T, located at LOCATION computes\n+   address of an ARRAY_REF, and call check_array_ref on it.  */\n+\n+static void\n+search_for_addr_array(tree t, location_t* location)\n+{\n+  while (TREE_CODE (t) == SSA_NAME)\n+    {\n+      t = SSA_NAME_DEF_STMT (t);\n+      if (TREE_CODE (t) != GIMPLE_MODIFY_STMT)\n+\treturn;\n+      t = GIMPLE_STMT_OPERAND (t, 1);\n+    }\n+\n+\n+  /* We are only interested in addresses of ARRAY_REF's.  */\n+  if (TREE_CODE (t) != ADDR_EXPR) \n+    return;\n+\n+  /* Check each ARRAY_REFs in the reference chain. */\n+  do \n+    {\n+      if (TREE_CODE (t) == ARRAY_REF)\n+\tcheck_array_ref (t, location, true /*ignore_off_by_one*/);\n+\n+      t = TREE_OPERAND(t,0);\n+    }\n+  while (handled_component_p (t));\n+}\n+\n /* walk_tree() callback that checks if *TP is\n    an ARRAY_REF inside an ADDR_EXPR (in which an array\n    subscript one outside the valid range is allowed). Call\n@@ -4250,44 +4280,22 @@ check_array_bounds (tree *tp, int *walk_subtree, void *data)\n \n   if (TREE_CODE (t) == ARRAY_REF)\n     check_array_ref (t, location, false /*ignore_off_by_one*/);\n-  else if (TREE_CODE (t) == ADDR_EXPR)\n-    {\n-       use_operand_p op;\n-       tree use_stmt;\n-       t = TREE_OPERAND (t, 0);\n-\n-       /* Don't warn on statements like\n-\n-          ssa_name = 500 + &array[-200]\n \n-          or\n-\n-          ssa_name = &array[-200]\n-          other_name = ssa_name + 300;\n-\n-          which are sometimes\n-          produced by other optimizing passes.  */\n-\n-       if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n-           && BINARY_CLASS_P (GIMPLE_STMT_OPERAND (stmt, 1)))\n-         *walk_subtree = FALSE;\n-\n-       if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n-           && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == SSA_NAME\n-           && single_imm_use (GIMPLE_STMT_OPERAND (stmt, 0), &op, &use_stmt)\n-           && TREE_CODE (use_stmt) == GIMPLE_MODIFY_STMT\n-           && BINARY_CLASS_P (GIMPLE_STMT_OPERAND (use_stmt, 1)))\n-         *walk_subtree = FALSE;\n+  if (TREE_CODE (t) == INDIRECT_REF\n+      || (TREE_CODE (t) == RETURN_EXPR && TREE_OPERAND (t, 0)))\n+    search_for_addr_array (TREE_OPERAND (t, 0), location);\n+  else if (TREE_CODE (t) == CALL_EXPR)\n+    {\n+      tree arg;\n+      call_expr_arg_iterator iter;\n \n-       while (*walk_subtree && handled_component_p (t))\n-         {\n-           if (TREE_CODE (t) == ARRAY_REF)\n-             check_array_ref (t, location, true /*ignore_off_by_one*/);\n-           t = TREE_OPERAND (t, 0);\n-         }\n-       *walk_subtree = FALSE;\n+      FOR_EACH_CALL_EXPR_ARG (arg, iter, t) \n+\tsearch_for_addr_array (arg, location);\n     }\n \n+  if (TREE_CODE (t) == ADDR_EXPR)\n+    *walk_subtree = FALSE;\n+\n   return NULL_TREE;\n }\n "}]}