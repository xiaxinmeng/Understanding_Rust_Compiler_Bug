{"sha": "9c71c00f17f1a694dba637ef7e4a4c9074c2d1e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWM3MWMwMGYxN2YxYTY5NGRiYTYzN2VmN2U0YTRjOTA3NGMyZDFlOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-10-23T12:01:11Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-10-23T12:01:11Z"}, "message": "tree-ssa-pre.c (bitmap_remove_from_set): Rename to...\n\n2017-10-23  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-pre.c (bitmap_remove_from_set): Rename to...\n\t(bitmap_remove_expr_from_set): ... this.  All callers call this\n\tfor non-constant values.\n\t(bitmap_set_subtract): Rename to...\n\t(bitmap_set_subtract_expressions): ... this.  Adjust and\n\toptimize.\n\t(bitmap_set_contains_value): Remove superfluous check.\n\t(bitmap_set_replace_value): Inline into single caller ...\n\t(bitmap_value_replace_in_set): ... here and simplify.\n\t(dependent_clean): Merge into ...\n\t(clean): ... this using an overload.  Adjust.\n\t(prune_clobbered_mems): Adjust.\n\t(compute_antic_aux): Likewise.\n\t(compute_partial_antic_aux): Likewise.\n\nFrom-SVN: r254007", "tree": {"sha": "e9d47c7da1522a990612bbd6f78bf6e1c787b573", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9d47c7da1522a990612bbd6f78bf6e1c787b573"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c71c00f17f1a694dba637ef7e4a4c9074c2d1e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c71c00f17f1a694dba637ef7e4a4c9074c2d1e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c71c00f17f1a694dba637ef7e4a4c9074c2d1e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c71c00f17f1a694dba637ef7e4a4c9074c2d1e9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2de9164b45111b54bea99afd97ca4f0de382a5e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2de9164b45111b54bea99afd97ca4f0de382a5e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2de9164b45111b54bea99afd97ca4f0de382a5e3"}], "stats": {"total": 149, "additions": 62, "deletions": 87}, "files": [{"sha": "a4d8cff9dea002d00196dd9d0b5db3465e22707f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c71c00f17f1a694dba637ef7e4a4c9074c2d1e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c71c00f17f1a694dba637ef7e4a4c9074c2d1e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9c71c00f17f1a694dba637ef7e4a4c9074c2d1e9", "patch": "@@ -1,3 +1,20 @@\n+2017-10-23  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-pre.c (bitmap_remove_from_set): Rename to...\n+\t(bitmap_remove_expr_from_set): ... this.  All callers call this\n+\tfor non-constant values.\n+\t(bitmap_set_subtract): Rename to...\n+\t(bitmap_set_subtract_expressions): ... this.  Adjust and\n+\toptimize.\n+\t(bitmap_set_contains_value): Remove superfluous check.\n+\t(bitmap_set_replace_value): Inline into single caller ...\n+\t(bitmap_value_replace_in_set): ... here and simplify.\n+\t(dependent_clean): Merge into ...\n+\t(clean): ... this using an overload.  Adjust.\n+\t(prune_clobbered_mems): Adjust.\n+\t(compute_antic_aux): Likewise.\n+\t(compute_partial_antic_aux): Likewise.\n+\n 2017-10-23  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/82129"}, {"sha": "7bf87019afe7210a6734bf4ecf3def6be71f03c0", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 45, "deletions": 87, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c71c00f17f1a694dba637ef7e4a4c9074c2d1e9/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c71c00f17f1a694dba637ef7e4a4c9074c2d1e9/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=9c71c00f17f1a694dba637ef7e4a4c9074c2d1e9", "patch": "@@ -719,14 +719,11 @@ sccvn_valnum_from_value_id (unsigned int val)\n /* Remove an expression EXPR from a bitmapped set.  */\n \n static void\n-bitmap_remove_from_set (bitmap_set_t set, pre_expr expr)\n+bitmap_remove_expr_from_set (bitmap_set_t set, pre_expr expr)\n {\n   unsigned int val  = get_expr_value_id (expr);\n-  if (!value_id_constant_p (val))\n-    {\n-      bitmap_clear_bit (&set->values, val);\n-      bitmap_clear_bit (&set->expressions, get_expression_id (expr));\n-    }\n+  bitmap_clear_bit (&set->values, val);\n+  bitmap_clear_bit (&set->expressions, get_expression_id (expr));\n }\n \n /* Insert an expression EXPR into a bitmapped set.  */\n@@ -802,7 +799,7 @@ sorted_array_from_bitmap_set (bitmap_set_t set)\n /* Subtract all expressions contained in ORIG from DEST.  */\n \n static bitmap_set_t\n-bitmap_set_subtract (bitmap_set_t dest, bitmap_set_t orig)\n+bitmap_set_subtract_expressions (bitmap_set_t dest, bitmap_set_t orig)\n {\n   bitmap_set_t result = bitmap_set_new ();\n   bitmap_iterator bi;\n@@ -833,15 +830,15 @@ bitmap_set_subtract_values (bitmap_set_t a, bitmap_set_t b)\n     {\n       if (to_remove)\n \t{\n-\t  bitmap_remove_from_set (a, to_remove);\n+\t  bitmap_remove_expr_from_set (a, to_remove);\n \t  to_remove = NULL;\n \t}\n       pre_expr expr = expression_for_id (i);\n-      if (bitmap_set_contains_value (b, get_expr_value_id (expr)))\n+      if (bitmap_bit_p (&b->values, get_expr_value_id (expr)))\n \tto_remove = expr;\n     }\n   if (to_remove)\n-    bitmap_remove_from_set (a, to_remove);\n+    bitmap_remove_expr_from_set (a, to_remove);\n }\n \n \n@@ -853,9 +850,6 @@ bitmap_set_contains_value (bitmap_set_t set, unsigned int value_id)\n   if (value_id_constant_p (value_id))\n     return true;\n \n-  if (!set || bitmap_empty_p (&set->expressions))\n-    return false;\n-\n   return bitmap_bit_p (&set->values, value_id);\n }\n \n@@ -865,44 +859,6 @@ bitmap_set_contains_expr (bitmap_set_t set, const pre_expr expr)\n   return bitmap_bit_p (&set->expressions, get_expression_id (expr));\n }\n \n-/* Replace an instance of value LOOKFOR with expression EXPR in SET.  */\n-\n-static void\n-bitmap_set_replace_value (bitmap_set_t set, unsigned int lookfor,\n-\t\t\t  const pre_expr expr)\n-{\n-  bitmap exprset;\n-  unsigned int i;\n-  bitmap_iterator bi;\n-\n-  if (value_id_constant_p (lookfor))\n-    return;\n-\n-  if (!bitmap_set_contains_value (set, lookfor))\n-    return;\n-\n-  /* The number of expressions having a given value is usually\n-     significantly less than the total number of expressions in SET.\n-     Thus, rather than check, for each expression in SET, whether it\n-     has the value LOOKFOR, we walk the reverse mapping that tells us\n-     what expressions have a given value, and see if any of those\n-     expressions are in our set.  For large testcases, this is about\n-     5-10x faster than walking the bitmap.  If this is somehow a\n-     significant lose for some cases, we can choose which set to walk\n-     based on the set size.  */\n-  exprset = value_expressions[lookfor];\n-  EXECUTE_IF_SET_IN_BITMAP (exprset, 0, i, bi)\n-    {\n-      if (bitmap_clear_bit (&set->expressions, i))\n-\t{\n-\t  bitmap_set_bit (&set->expressions, get_expression_id (expr));\n-\t  return;\n-\t}\n-    }\n-\n-  gcc_unreachable ();\n-}\n-\n /* Return true if two bitmap sets are equal.  */\n \n static bool\n@@ -918,9 +874,33 @@ static void\n bitmap_value_replace_in_set (bitmap_set_t set, pre_expr expr)\n {\n   unsigned int val = get_expr_value_id (expr);\n+  if (value_id_constant_p (val))\n+    return;\n \n   if (bitmap_set_contains_value (set, val))\n-    bitmap_set_replace_value (set, val, expr);\n+    {\n+      /* The number of expressions having a given value is usually\n+\t significantly less than the total number of expressions in SET.\n+\t Thus, rather than check, for each expression in SET, whether it\n+\t has the value LOOKFOR, we walk the reverse mapping that tells us\n+\t what expressions have a given value, and see if any of those\n+\t expressions are in our set.  For large testcases, this is about\n+\t 5-10x faster than walking the bitmap.  If this is somehow a\n+\t significant lose for some cases, we can choose which set to walk\n+\t based on the set size.  */\n+      unsigned int i;\n+      bitmap_iterator bi;\n+      bitmap exprset = value_expressions[val];\n+      EXECUTE_IF_SET_IN_BITMAP (exprset, 0, i, bi)\n+\t{\n+\t  if (bitmap_clear_bit (&set->expressions, i))\n+\t    {\n+\t      bitmap_set_bit (&set->expressions, get_expression_id (expr));\n+\t      return;\n+\t    }\n+\t}\n+      gcc_unreachable ();\n+    }\n   else\n     bitmap_insert_into_set (set, expr);\n }\n@@ -1979,14 +1959,12 @@ valid_in_sets (bitmap_set_t set1, bitmap_set_t set2, pre_expr expr)\n     }\n }\n \n-/* Clean the set of expressions that are no longer valid in SET1 or\n-   SET2.  This means expressions that are made up of values we have no\n-   leaders for in SET1 or SET2.  This version is used for partial\n-   anticipation, which means it is not valid in either ANTIC_IN or\n-   PA_IN.  */\n+/* Clean the set of expressions SET1 that are no longer valid in SET1 or SET2.\n+   This means expressions that are made up of values we have no leaders for\n+   in SET1 or SET2.  */\n \n static void\n-dependent_clean (bitmap_set_t set1, bitmap_set_t set2)\n+clean (bitmap_set_t set1, bitmap_set_t set2 = NULL)\n {\n   vec<pre_expr> exprs = sorted_array_from_bitmap_set (set1);\n   pre_expr expr;\n@@ -1995,26 +1973,7 @@ dependent_clean (bitmap_set_t set1, bitmap_set_t set2)\n   FOR_EACH_VEC_ELT (exprs, i, expr)\n     {\n       if (!valid_in_sets (set1, set2, expr))\n-\tbitmap_remove_from_set (set1, expr);\n-    }\n-  exprs.release ();\n-}\n-\n-/* Clean the set of expressions that are no longer valid in SET.  This\n-   means expressions that are made up of values we have no leaders for\n-   in SET.  */\n-\n-static void\n-clean (bitmap_set_t set)\n-{\n-  vec<pre_expr> exprs = sorted_array_from_bitmap_set (set);\n-  pre_expr expr;\n-  int i;\n-\n-  FOR_EACH_VEC_ELT (exprs, i, expr)\n-    {\n-      if (!valid_in_sets (set, NULL, expr))\n-\tbitmap_remove_from_set (set, expr);\n+\tbitmap_remove_expr_from_set (set1, expr);\n     }\n   exprs.release ();\n }\n@@ -2034,7 +1993,7 @@ prune_clobbered_mems (bitmap_set_t set, basic_block block)\n       /* Remove queued expr.  */\n       if (to_remove)\n \t{\n-\t  bitmap_remove_from_set (set, to_remove);\n+\t  bitmap_remove_expr_from_set (set, to_remove);\n \t  to_remove = NULL;\n \t}\n \n@@ -2069,7 +2028,7 @@ prune_clobbered_mems (bitmap_set_t set, basic_block block)\n \n   /* Remove queued expr.  */\n   if (to_remove)\n-    bitmap_remove_from_set (set, to_remove);\n+    bitmap_remove_expr_from_set (set, to_remove);\n }\n \n static sbitmap has_abnormal_preds;\n@@ -2206,11 +2165,11 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n   prune_clobbered_mems (ANTIC_OUT, block);\n \n   /* Generate ANTIC_OUT - TMP_GEN.  */\n-  S = bitmap_set_subtract (ANTIC_OUT, TMP_GEN (block));\n+  S = bitmap_set_subtract_expressions (ANTIC_OUT, TMP_GEN (block));\n \n   /* Start ANTIC_IN with EXP_GEN - TMP_GEN.  */\n-  ANTIC_IN (block) = bitmap_set_subtract (EXP_GEN (block),\n-\t\t\t\t\t  TMP_GEN (block));\n+  ANTIC_IN (block) = bitmap_set_subtract_expressions (EXP_GEN (block),\n+\t\t\t\t\t\t      TMP_GEN (block));\n \n   /* Then union in the ANTIC_OUT - TMP_GEN values,\n      to get ANTIC_OUT U EXP_GEN - TMP_GEN */\n@@ -2254,8 +2213,7 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n    else if succs(BLOCK) == 1 then\n      PA_OUT[BLOCK] = phi_translate (PA_IN[succ(BLOCK)])\n \n-   PA_IN[BLOCK] = dependent_clean(PA_OUT[BLOCK] - TMP_GEN[BLOCK]\n-\t\t\t\t  - ANTIC_IN[BLOCK])\n+   PA_IN[BLOCK] = clean(PA_OUT[BLOCK] - TMP_GEN[BLOCK] - ANTIC_IN[BLOCK])\n \n */\n static void\n@@ -2348,7 +2306,7 @@ compute_partial_antic_aux (basic_block block,\n \n   /* PA_IN starts with PA_OUT - TMP_GEN.\n      Then we subtract things from ANTIC_IN.  */\n-  PA_IN (block) = bitmap_set_subtract (PA_OUT, TMP_GEN (block));\n+  PA_IN (block) = bitmap_set_subtract_expressions (PA_OUT, TMP_GEN (block));\n \n   /* For partial antic, we want to put back in the phi results, since\n      we will properly avoid making them partially antic over backedges.  */\n@@ -2358,7 +2316,7 @@ compute_partial_antic_aux (basic_block block,\n   /* PA_IN[block] = PA_IN[block] - ANTIC_IN[block] */\n   bitmap_set_subtract_values (PA_IN (block), ANTIC_IN (block));\n \n-  dependent_clean (PA_IN (block), ANTIC_IN (block));\n+  clean (PA_IN (block), ANTIC_IN (block));\n \n  maybe_dump_sets:\n   if (dump_file && (dump_flags & TDF_DETAILS))"}]}