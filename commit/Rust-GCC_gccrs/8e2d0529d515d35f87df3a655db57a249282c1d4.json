{"sha": "8e2d0529d515d35f87df3a655db57a249282c1d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUyZDA1MjlkNTE1ZDM1Zjg3ZGYzYTY1NWRiNTdhMjQ5MjgyYzFkNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-06-16T17:59:02Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-06-16T17:59:02Z"}, "message": "alias-access-path-4.c: New testcase.\n\n\n\t* gcc.dg/tree-ssa/alias-access-path-4.c: New testcase.\n\t* gcc.dg/tree-ssa/alias-access-path-5.c: New testcase.\n\n\t* tree-ssa-alias.c (aliasing_component_refs_p): Watch for arrays\n\tat the end of structures.\n\nFrom-SVN: r272357", "tree": {"sha": "c81eae2b0696e98e6da4901e0f7cf2935285f67d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c81eae2b0696e98e6da4901e0f7cf2935285f67d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e2d0529d515d35f87df3a655db57a249282c1d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e2d0529d515d35f87df3a655db57a249282c1d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e2d0529d515d35f87df3a655db57a249282c1d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e2d0529d515d35f87df3a655db57a249282c1d4/comments", "author": null, "committer": null, "parents": [{"sha": "ce3a201593d0ed5b606360c064778de34b5b04ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce3a201593d0ed5b606360c064778de34b5b04ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce3a201593d0ed5b606360c064778de34b5b04ef"}], "stats": {"total": 141, "additions": 129, "deletions": 12}, "files": [{"sha": "05c18aa6479528f5fc34a87b3ca193437cfef250", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2d0529d515d35f87df3a655db57a249282c1d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2d0529d515d35f87df3a655db57a249282c1d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e2d0529d515d35f87df3a655db57a249282c1d4", "patch": "@@ -1,3 +1,8 @@\n+2019-06-16  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree-ssa-alias.c (aliasing_component_refs_p): Watch for arrays\n+\tat the end of structures.\n+\n 2019-06-16  Iain Sandoe  <iain@sandoe.co.uk>\n \n \t* config/darwin.c (machopic_indirect_call_target): Use renamed"}, {"sha": "51861120f8feb113c7fe1d6da952be1a4850063b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2d0529d515d35f87df3a655db57a249282c1d4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2d0529d515d35f87df3a655db57a249282c1d4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8e2d0529d515d35f87df3a655db57a249282c1d4", "patch": "@@ -1,3 +1,8 @@\n+2019-06-16  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/tree-ssa/alias-access-path-4.c: New testcase.\n+\t* gcc.dg/tree-ssa/alias-access-path-5.c: New testcase.\n+\n 2019-06-15  Iain Buclaw  <ibuclaw@gdcproject.org>\n \n \tPR d/90650"}, {"sha": "641ef89cbb8ae541c18dd3e078b18f2f3fea1168", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-access-path-4.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2d0529d515d35f87df3a655db57a249282c1d4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2d0529d515d35f87df3a655db57a249282c1d4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-4.c?ref=8e2d0529d515d35f87df3a655db57a249282c1d4", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+struct a {int v1;\n+          int v2;};\n+struct b {struct a a[0];};\n+union c {struct b b;};\n+\n+int\n+test (struct b *bptr1, union c *cptr, int i, int j)\n+{\n+  bptr1->a[i].v1=123;\n+  cptr->b.a[j].v2=1;\n+  return bptr1->a[i].v1;\n+}\n+int\n+test2 (struct b *bptr1, union c *cptr, int i, int j)\n+{\n+  bptr1->a[i].v1=124;\n+  cptr->b.a[j].v1=1;\n+  return bptr1->a[i].v1;\n+}\n+/* { dg-final { scan-tree-dump-times \"return 123\" 1 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-not \"return 124\" \"optimized\"} } */"}, {"sha": "412f99e7c5505dcd78cce818c0aefcf9027dbc3f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-access-path-5.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2d0529d515d35f87df3a655db57a249282c1d4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2d0529d515d35f87df3a655db57a249282c1d4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-5.c?ref=8e2d0529d515d35f87df3a655db57a249282c1d4", "patch": "@@ -0,0 +1,25 @@\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+struct a {int v1;\n+          int v2;};\n+struct b {int array[0]; struct a a[];};\n+union c {struct b b;};\n+\n+int\n+test (struct b *bptr1, union c *cptr, int i, int j)\n+{\n+  bptr1->a[i].v1=123;\n+  cptr->b.a[j].v2=1;\n+  return bptr1->a[i].v1;\n+}\n+int\n+test2 (struct b *bptr1, union c *cptr, int i, int j)\n+{\n+  bptr1->a[i].v1=124;\n+  cptr->b.a[j].v1=1;\n+  return bptr1->a[i].v1;\n+}\n+/* { dg-final { scan-tree-dump-times \"return 123\" 1 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-not \"return 124\" \"optimized\"} } */"}, {"sha": "52f9270c6045c9646833349f2e6f18376e79ddf2", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 70, "deletions": 12, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2d0529d515d35f87df3a655db57a249282c1d4/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2d0529d515d35f87df3a655db57a249282c1d4/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=8e2d0529d515d35f87df3a655db57a249282c1d4", "patch": "@@ -877,30 +877,74 @@ aliasing_component_refs_p (tree ref1,\n   tree *refp;\n   int same_p1 = 0, same_p2 = 0;\n   bool maybe_match = false;\n+  tree end_struct_ref1 = NULL, end_struct_ref2 = NULL;\n \n   /* Choose bases and base types to search for.  */\n   base1 = ref1;\n   while (handled_component_p (base1))\n-    base1 = TREE_OPERAND (base1, 0);\n+    {\n+      /* Generally access paths are monotous in the size of object. The\n+\t exception are trailing arrays of structures. I.e.\n+\t   struct a {int array[0];};\n+\t or\n+\t   struct a {int array1[0]; int array[];};\n+\t Such struct has size 0 but accesses to a.array may have non-zero size.\n+\t In this case the size of TREE_TYPE (base1) is smaller than\n+\t size of TREE_TYPE (TREE_OPERNAD (base1, 0)).\n+\n+\t Because we compare sizes of arrays just by sizes of their elements,\n+\t we only need to care about zero sized array fields here.  */\n+      if (TREE_CODE (base1) == COMPONENT_REF\n+\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (base1, 1))) == ARRAY_TYPE\n+\t  && (!TYPE_SIZE (TREE_TYPE (TREE_OPERAND (base1, 1)))\n+\t      || integer_zerop (TYPE_SIZE (TREE_TYPE (TREE_OPERAND (base1, 1)))))\n+\t  && array_at_struct_end_p (base1))\n+\t{\n+\t  gcc_checking_assert (!end_struct_ref1);\n+          end_struct_ref1 = base1;\n+\t}\n+      base1 = TREE_OPERAND (base1, 0);\n+    }\n   type1 = TREE_TYPE (base1);\n   base2 = ref2;\n   while (handled_component_p (base2))\n-    base2 = TREE_OPERAND (base2, 0);\n+    {\n+      if (TREE_CODE (base2) == COMPONENT_REF\n+\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (base2, 1))) == ARRAY_TYPE\n+\t  && (!TYPE_SIZE (TREE_TYPE (TREE_OPERAND (base2, 1)))\n+\t      || integer_zerop (TYPE_SIZE (TREE_TYPE (TREE_OPERAND (base2, 1)))))\n+\t  && array_at_struct_end_p (base2))\n+\t{\n+\t  gcc_checking_assert (!end_struct_ref2);\n+\t  end_struct_ref2 = base2;\n+\t}\n+      base2 = TREE_OPERAND (base2, 0);\n+    }\n   type2 = TREE_TYPE (base2);\n \n   /* Now search for the type1 in the access path of ref2.  This\n      would be a common base for doing offset based disambiguation on.\n      This however only makes sense if type2 is big enough to hold type1.  */\n   int cmp_outer = compare_type_sizes (type2, type1);\n-  if (cmp_outer >= 0)\n+\n+  /* If type2 is big enough to contain type1 walk its access path.\n+     We also need to care of arrays at the end of structs that may extend\n+     beyond the end of structure.  */\n+  if (cmp_outer >= 0\n+      || (end_struct_ref2\n+\t  && compare_type_sizes (TREE_TYPE (end_struct_ref2), type1) >= 0))\n     {\n       refp = &ref2;\n       while (true)\n \t{\n \t  /* We walk from inner type to the outer types. If type we see is\n \t     already too large to be part of type1, terminate the search.  */\n \t  int cmp = compare_type_sizes (type1, TREE_TYPE (*refp));\n-\t  if (cmp < 0)\n+\n+\t  if (cmp < 0\n+\t      && (!end_struct_ref1\n+\t\t  || compare_type_sizes (TREE_TYPE (end_struct_ref1),\n+\t\t\t\t\t TREE_TYPE (*refp)) < 0))\n \t    break;\n \t  /* If types may be of same size, see if we can decide about their\n \t     equality.  */\n@@ -957,13 +1001,18 @@ aliasing_component_refs_p (tree ref1,\n     }\n \n   /* If we didn't find a common base, try the other way around.  */\n-  if (cmp_outer <= 0)\n+  if (cmp_outer <= 0 \n+      || (end_struct_ref1\n+\t  && compare_type_sizes (TREE_TYPE (end_struct_ref1), type1) <= 0))\n     {\n       refp = &ref1;\n       while (true)\n \t{\n \t  int cmp = compare_type_sizes (type2, TREE_TYPE (*refp));\n-\t  if (cmp < 0)\n+\t  if (cmp < 0\n+\t      && (!end_struct_ref2\n+\t\t  || compare_type_sizes (TREE_TYPE (end_struct_ref2),\n+\t\t\t\t\t TREE_TYPE (*refp)) < 0))\n \t    break;\n \t  /* If types may be of same size, see if we can decide about their\n \t     equality.  */\n@@ -1024,6 +1073,9 @@ aliasing_component_refs_p (tree ref1,\n      if there is no B2 in the tail of path1 and no B1 on the\n      tail of path2.  */\n   if (compare_type_sizes (TREE_TYPE (ref2), type1) >= 0\n+      && (!end_struct_ref1\n+\t  || compare_type_sizes (TREE_TYPE (ref2),\n+\t\t \t\t TREE_TYPE (end_struct_ref1)) >= 0)\n       && type_has_components_p (TREE_TYPE (ref2))\n       && (base1_alias_set == ref2_alias_set\n           || alias_set_subset_of (base1_alias_set, ref2_alias_set)))\n@@ -1034,6 +1086,9 @@ aliasing_component_refs_p (tree ref1,\n   /* If this is ptr vs. decl then we know there is no ptr ... decl path.  */\n   if (!ref2_is_decl\n       && compare_type_sizes (TREE_TYPE (ref1), type2) >= 0\n+      && (!end_struct_ref2\n+\t  || compare_type_sizes (TREE_TYPE (ref1),\n+\t\t \t\t TREE_TYPE (end_struct_ref2)) >= 0)\n       && type_has_components_p (TREE_TYPE (ref1))\n       && (base2_alias_set == ref1_alias_set\n \t  || alias_set_subset_of (base2_alias_set, ref1_alias_set)))\n@@ -1477,8 +1532,9 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n       && same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (dbase2)) == 1\n       && (TREE_CODE (TREE_TYPE (base1)) != ARRAY_TYPE\n \t  || (TYPE_SIZE (TREE_TYPE (base1))\n-\t      && TREE_CODE (TYPE_SIZE (TREE_TYPE (base1))) == INTEGER_CST)))\n-    return ranges_maybe_overlap_p (doffset1, max_size1, doffset2, max_size2);\n+\t      && TREE_CODE (TYPE_SIZE (TREE_TYPE (base1))) == INTEGER_CST))\n+      && !ranges_maybe_overlap_p (doffset1, max_size1, doffset2, max_size2))\n+    return false;\n \n   if (ref1 && ref2\n       && nonoverlapping_component_refs_p (ref1, ref2))\n@@ -1558,8 +1614,9 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n     {\n       poly_offset_int moff1 = mem_ref_offset (base1) << LOG2_BITS_PER_UNIT;\n       poly_offset_int moff2 = mem_ref_offset (base2) << LOG2_BITS_PER_UNIT;\n-      return ranges_maybe_overlap_p (offset1 + moff1, max_size1,\n-\t\t\t\t     offset2 + moff2, max_size2);\n+      if (!ranges_maybe_overlap_p (offset1 + moff1, max_size1,\n+\t\t\t\t   offset2 + moff2, max_size2))\n+\treturn false;\n     }\n   if (!ptr_derefs_may_alias_p (ptr1, ptr2))\n     return false;\n@@ -1598,8 +1655,9 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n       /* But avoid treating arrays as \"objects\", instead assume they\n          can overlap by an exact multiple of their element size.\n          See gcc.dg/torture/alias-2.c.  */\n-      && TREE_CODE (TREE_TYPE (ptrtype1)) != ARRAY_TYPE)\n-    return ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2);\n+      && TREE_CODE (TREE_TYPE (ptrtype1)) != ARRAY_TYPE\n+      && !ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2))\n+    return false;\n \n   if (ref1 && ref2\n       && nonoverlapping_component_refs_p (ref1, ref2))"}]}