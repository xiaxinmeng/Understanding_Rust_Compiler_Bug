{"sha": "16e247566db1df18a63965f8b3da7345459c6296", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZlMjQ3NTY2ZGIxZGYxOGE2Mzk2NWY4YjNkYTczNDU0NTljNjI5Ng==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2013-02-04T22:33:15Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2013-02-04T22:33:15Z"}, "message": "re PR fortran/56008 ([F03] wrong code with lhs-realloc on assignment with derived types having allocatable components)\n\n2013-02-04  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/56008\n\tPR fortran/47517\n\t* trans-array.c (gfc_alloc_allocatable_for_assignment): Save\n\tthe lhs descriptor before it is modified for reallocation. Use\n\tit to deallocate allocatable components in the reallocation\n\tblock.  Nullify allocatable components for newly (re)allocated\n\tarrays.\n\n2013-02-04  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/56008\n\t* gfortran.dg/realloc_on _assign_16.f90 : New test.\n\n\tPR fortran/47517\n\t* gfortran.dg/realloc_on _assign_17.f90 : New test.\n\nFrom-SVN: r195741", "tree": {"sha": "b050a17024c43f8e674ed0aa5a78ec65c9e5d061", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b050a17024c43f8e674ed0aa5a78ec65c9e5d061"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16e247566db1df18a63965f8b3da7345459c6296", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16e247566db1df18a63965f8b3da7345459c6296", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16e247566db1df18a63965f8b3da7345459c6296", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16e247566db1df18a63965f8b3da7345459c6296/comments", "author": null, "committer": null, "parents": [{"sha": "9ccd841a07944a30a4c17df1b0dd274b7e1c4431", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ccd841a07944a30a4c17df1b0dd274b7e1c4431", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ccd841a07944a30a4c17df1b0dd274b7e1c4431"}], "stats": {"total": 126, "additions": 126, "deletions": 0}, "files": [{"sha": "c22d3d9908f2b0d0f864e6444716f23172ccf439", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e247566db1df18a63965f8b3da7345459c6296/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e247566db1df18a63965f8b3da7345459c6296/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=16e247566db1df18a63965f8b3da7345459c6296", "patch": "@@ -1,3 +1,13 @@\n+2013-02-04  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/56008\n+\tPR fortran/47517\n+\t* trans-array.c (gfc_alloc_allocatable_for_assignment): Save\n+\tthe lhs descriptor before it is modified for reallocation. Use\n+\tit to deallocate allocatable components in the reallocation\n+\tblock.  Nullify allocatable components for newly (re)allocated\n+\tarrays.\n+\n 2013-02-04  Mikael Morin  <mikael@gcc.gnu.org>\n \n \tPR fortran/54195"}, {"sha": "4553ddc5b537390874dd73c1c434fb3c08c0f8c5", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e247566db1df18a63965f8b3da7345459c6296/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e247566db1df18a63965f8b3da7345459c6296/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=16e247566db1df18a63965f8b3da7345459c6296", "patch": "@@ -7941,6 +7941,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   tree lbound;\n   tree ubound;\n   tree desc;\n+  tree old_desc;\n   tree desc2;\n   tree offset;\n   tree jump_label1;\n@@ -8091,6 +8092,13 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n \t\t\t  size1, size2);\n   neq_size = gfc_evaluate_now (cond, &fblock);\n \n+  /* Deallocation of allocatable components will have to occur on\n+     reallocation.  Fix the old descriptor now.  */\n+  if ((expr1->ts.type == BT_DERIVED)\n+\t&& expr1->ts.u.derived->attr.alloc_comp)\n+    old_desc = gfc_evaluate_now (desc, &fblock);\n+  else\n+    old_desc = NULL_TREE;\n \n   /* Now modify the lhs descriptor and the associated scalarizer\n      variables. F2003 7.4.1.3: \"If variable is or becomes an\n@@ -8201,12 +8209,30 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   /* Realloc expression.  Note that the scalarizer uses desc.data\n      in the array reference - (*desc.data)[<element>]. */\n   gfc_init_block (&realloc_block);\n+\n+  if ((expr1->ts.type == BT_DERIVED)\n+\t&& expr1->ts.u.derived->attr.alloc_comp)\n+    {\n+      tmp = gfc_deallocate_alloc_comp (expr1->ts.u.derived, old_desc,\n+\t\t\t\t       expr1->rank);\n+      gfc_add_expr_to_block (&realloc_block, tmp);\n+    }\n+\n   tmp = build_call_expr_loc (input_location,\n \t\t\t     builtin_decl_explicit (BUILT_IN_REALLOC), 2,\n \t\t\t     fold_convert (pvoid_type_node, array1),\n \t\t\t     size2);\n   gfc_conv_descriptor_data_set (&realloc_block,\n \t\t\t\tdesc, tmp);\n+\n+  if ((expr1->ts.type == BT_DERIVED)\n+\t&& expr1->ts.u.derived->attr.alloc_comp)\n+    {\n+      tmp = gfc_nullify_alloc_comp (expr1->ts.u.derived, desc,\n+\t\t\t\t    expr1->rank);\n+      gfc_add_expr_to_block (&realloc_block, tmp);\n+    }\n+\n   realloc_expr = gfc_finish_block (&realloc_block);\n \n   /* Only reallocate if sizes are different.  */\n@@ -8224,6 +8250,13 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n \t\t\t\tdesc, tmp);\n   tmp = gfc_conv_descriptor_dtype (desc);\n   gfc_add_modify (&alloc_block, tmp, gfc_get_dtype (TREE_TYPE (desc)));\n+  if ((expr1->ts.type == BT_DERIVED)\n+\t&& expr1->ts.u.derived->attr.alloc_comp)\n+    {\n+      tmp = gfc_nullify_alloc_comp (expr1->ts.u.derived, desc,\n+\t\t\t\t    expr1->rank);\n+      gfc_add_expr_to_block (&alloc_block, tmp);\n+    }\n   alloc_expr = gfc_finish_block (&alloc_block);\n \n   /* Malloc if not allocated; realloc otherwise.  */"}, {"sha": "548ccc12e64271ddd6fc54e013803d637a22cafc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e247566db1df18a63965f8b3da7345459c6296/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e247566db1df18a63965f8b3da7345459c6296/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=16e247566db1df18a63965f8b3da7345459c6296", "patch": "@@ -1,3 +1,11 @@\n+2013-02-04  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/56008\n+\t* gfortran.dg/realloc_on _assign_16.f90 : New test.\n+\n+\tPR fortran/47517\n+\t* gfortran.dg/realloc_on _assign_17.f90 : New test.\n+\n 2013-02-04  Alexander Potapenko <glider@google.com>\n             Jack Howarth  <howarth@bromo.med.uc.edu>\n \t    Jakub Jelinek  <jakub@redhat.com>"}, {"sha": "84af6670f66d70d454e4f52e9ed23427a37665cf", "filename": "gcc/testsuite/gfortran.dg/realloc_on_assign_16.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e247566db1df18a63965f8b3da7345459c6296/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_16.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e247566db1df18a63965f8b3da7345459c6296/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_16.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_16.f90?ref=16e247566db1df18a63965f8b3da7345459c6296", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do run }\n+! Test the fix for PR56008\n+!\n+! Contributed by Stefan Mauerberger  <stefan.mauerberger@gmail.com>\n+!\n+PROGRAM main\n+    !USE MPI\n+\n+    TYPE :: test_typ\n+        REAL, ALLOCATABLE :: a(:)\n+    END TYPE\n+\n+    TYPE(test_typ) :: xx, yy\n+    TYPE(test_typ), ALLOCATABLE :: conc(:)\n+\n+    !CALL MPI_INIT(i)\n+\n+    xx = test_typ( [1.0,2.0] )\n+    yy = test_typ( [4.0,4.9] )\n+\n+    conc = [ xx, yy ]\n+\n+    if (any (int (10.0*conc(1)%a) .ne. [10,20])) call abort\n+    if (any (int (10.0*conc(2)%a) .ne. [40,49])) call abort\n+\n+    !CALL MPI_FINALIZE(i)\n+\n+END PROGRAM main"}, {"sha": "61b1e91d6419c1faf66bdb088091d3bf1bce981c", "filename": "gcc/testsuite/gfortran.dg/realloc_on_assign_17.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e247566db1df18a63965f8b3da7345459c6296/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_17.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e247566db1df18a63965f8b3da7345459c6296/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_17.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_17.f90?ref=16e247566db1df18a63965f8b3da7345459c6296", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do run }\n+! Test the fix for PR47517\n+!\n+! Reported by Tobias Burnus  <burnus@gcc.gnu.org>\n+! from a testcase by James Van Buskirk\n+module mytypes\n+   implicit none\n+   type label\n+      integer, allocatable :: parts(:)\n+   end type label\n+   type table\n+      type(label), allocatable :: headers(:)\n+   end type table\n+end module mytypes\n+\n+program allocate_assign\n+   use mytypes\n+   implicit none\n+   integer, parameter :: ik8 = selected_int_kind(18)\n+   type(table) x1(2)\n+   type(table) x2(3)\n+   type(table), allocatable :: x(:)\n+   integer i, j, k\n+   integer(ik8) s\n+   call foo\n+   s = 0\n+   do k = 1, 10000\n+      x = x1\n+      s = s+x(2)%headers(2)%parts(2)\n+      x = x2\n+      s = s+x(2)%headers(2)%parts(2)\n+   end do\n+   if (s .ne. 40000) call abort\n+contains\n+!\n+! TODO - these assignments lose 1872 bytes on x86_64/FC17\n+! This is PR38319\n+!\n+   subroutine foo\n+       x1 = [table([(label([(j,j=1,3)]),i=1,3)]), &\n+             table([(label([(j,j=1,4)]),i=1,4)])]\n+\n+       x2 = [table([(label([(j,j=1,4)]),i=1,4)]), &\n+             table([(label([(j,j=1,5)]),i=1,5)]), &\n+             table([(label([(j,j=1,6)]),i=1,6)])]\n+   end subroutine\n+end program allocate_assign"}]}