{"sha": "748d9390b9739dadc48a775c7ea869c42b3f39a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ4ZDkzOTBiOTczOWRhZGM0OGE3NzVjN2VhODY5YzQyYjNmMzlhOQ==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2017-10-04T16:40:44Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2017-10-04T16:40:44Z"}, "message": "Revert r253399:\n\n\tPR rtl-optimization/82396\n\t* haifa-sched.c (autopref_multipass_init): Simplify\n\tinitialization.\n\t(autopref_rank_data): Simplify sort order.\n\t* sched-int.h (autopref_multipass_data_): Remove\n\tmulti_mem_insn_p, min_offset and max_offset.\n\nFrom-SVN: r253419", "tree": {"sha": "5d6dbb016f15373dd739a59f704264c9bb2024ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d6dbb016f15373dd739a59f704264c9bb2024ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/748d9390b9739dadc48a775c7ea869c42b3f39a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/748d9390b9739dadc48a775c7ea869c42b3f39a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/748d9390b9739dadc48a775c7ea869c42b3f39a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/748d9390b9739dadc48a775c7ea869c42b3f39a9/comments", "author": null, "committer": null, "parents": [{"sha": "420db57431715a5aed988c5ba600c913dc779f0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/420db57431715a5aed988c5ba600c913dc779f0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/420db57431715a5aed988c5ba600c913dc779f0e"}], "stats": {"total": 123, "additions": 108, "deletions": 15}, "files": [{"sha": "5167a14788fc503303e589de56b03adf66965352", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/748d9390b9739dadc48a775c7ea869c42b3f39a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/748d9390b9739dadc48a775c7ea869c42b3f39a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=748d9390b9739dadc48a775c7ea869c42b3f39a9", "patch": "@@ -1,3 +1,14 @@\n+2017-10-04  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\tRevert r253399:\n+\n+\tPR rtl-optimization/82396\n+\t* haifa-sched.c (autopref_multipass_init): Simplify\n+\tinitialization.\n+\t(autopref_rank_data): Simplify sort order.\n+\t* sched-int.h (autopref_multipass_data_): Remove\n+\tmulti_mem_insn_p, min_offset and max_offset.\n+\n 2017-10-04  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* doc/sourcebuild.texi: Document vect_peeling_profitable."}, {"sha": "549e8961411ecd0a04ac3b24ba78b5d53e63258a", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 88, "deletions": 13, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/748d9390b9739dadc48a775c7ea869c42b3f39a9/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/748d9390b9739dadc48a775c7ea869c42b3f39a9/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=748d9390b9739dadc48a775c7ea869c42b3f39a9", "patch": "@@ -5568,7 +5568,9 @@ autopref_multipass_init (const rtx_insn *insn, int write)\n \n   gcc_assert (data->status == AUTOPREF_MULTIPASS_DATA_UNINITIALIZED);\n   data->base = NULL_RTX;\n-  data->offset = 0;\n+  data->min_offset = 0;\n+  data->max_offset = 0;\n+  data->multi_mem_insn_p = false;\n   /* Set insn entry initialized, but not relevant for auto-prefetcher.  */\n   data->status = AUTOPREF_MULTIPASS_DATA_IRRELEVANT;\n \n@@ -5583,33 +5585,49 @@ autopref_multipass_init (const rtx_insn *insn, int write)\n     {\n       int n_elems = XVECLEN (pat, 0);\n \n-      int i, offset;\n-      rtx base, prev_base = NULL_RTX;\n-      int min_offset = INT_MAX;\n+      int i = 0;\n+      rtx prev_base = NULL_RTX;\n+      int min_offset = 0;\n+      int max_offset = 0;\n \n       for (i = 0; i < n_elems; i++)\n \t{\n \t  rtx set = XVECEXP (pat, 0, i);\n \t  if (GET_CODE (set) != SET)\n \t    return;\n \n+\t  rtx base = NULL_RTX;\n+\t  int offset = 0;\n \t  if (!analyze_set_insn_for_autopref (set, write, &base, &offset))\n \t    return;\n \n+\t  if (i == 0)\n+\t    {\n+\t      prev_base = base;\n+\t      min_offset = offset;\n+\t      max_offset = offset;\n+\t    }\n \t  /* Ensure that all memory operations in the PARALLEL use the same\n \t     base register.  */\n-\t  if (i > 0 && REGNO (base) != REGNO (prev_base))\n+\t  else if (REGNO (base) != REGNO (prev_base))\n \t    return;\n-\t  prev_base = base;\n-\t  min_offset = MIN (min_offset, offset);\n+\t  else\n+\t    {\n+\t      min_offset = MIN (min_offset, offset);\n+\t      max_offset = MAX (max_offset, offset);\n+\t    }\n \t}\n \n-      /* If we reached here then we have a valid PARALLEL of multiple memory ops\n-\t with prev_base as the base and min_offset containing the offset.  */\n+      /* If we reached here then we have a valid PARALLEL of multiple memory\n+\t ops with prev_base as the base and min_offset and max_offset\n+\t containing the offsets range.  */\n       gcc_assert (prev_base);\n       data->base = prev_base;\n-      data->offset = min_offset;\n+      data->min_offset = min_offset;\n+      data->max_offset = max_offset;\n+      data->multi_mem_insn_p = true;\n       data->status = AUTOPREF_MULTIPASS_DATA_NORMAL;\n+\n       return;\n     }\n \n@@ -5619,7 +5637,7 @@ autopref_multipass_init (const rtx_insn *insn, int write)\n     return;\n \n   if (!analyze_set_insn_for_autopref (set, write, &data->base,\n-\t\t\t\t       &data->offset))\n+\t\t\t\t       &data->min_offset))\n     return;\n \n   /* This insn is relevant for the auto-prefetcher.\n@@ -5628,6 +5646,63 @@ autopref_multipass_init (const rtx_insn *insn, int write)\n   data->status = AUTOPREF_MULTIPASS_DATA_NORMAL;\n }\n \n+\n+/* Helper for autopref_rank_for_schedule.  Given the data of two\n+   insns relevant to the auto-prefetcher modelling code DATA1 and DATA2\n+   return their comparison result.  Return 0 if there is no sensible\n+   ranking order for the two insns.  */\n+\n+static int\n+autopref_rank_data (autopref_multipass_data_t data1,\n+\t\t     autopref_multipass_data_t data2)\n+{\n+  /* Simple case when both insns are simple single memory ops.  */\n+  if (!data1->multi_mem_insn_p && !data2->multi_mem_insn_p)\n+    return data1->min_offset - data2->min_offset;\n+\n+  /* Two load/store multiple insns.  Return 0 if the offset ranges\n+     overlap and the difference between the minimum offsets otherwise.  */\n+  else if (data1->multi_mem_insn_p && data2->multi_mem_insn_p)\n+    {\n+      int min1 = data1->min_offset;\n+      int max1 = data1->max_offset;\n+      int min2 = data2->min_offset;\n+      int max2 = data2->max_offset;\n+\n+      if (max1 < min2 || min1 > max2)\n+\treturn min1 - min2;\n+      else\n+\treturn 0;\n+    }\n+\n+  /* The other two cases is a pair of a load/store multiple and\n+     a simple memory op.  Return 0 if the single op's offset is within the\n+     range of the multi-op insn and the difference between the single offset\n+     and the minimum offset of the multi-set insn otherwise.  */\n+  else if (data1->multi_mem_insn_p && !data2->multi_mem_insn_p)\n+    {\n+      int max1 = data1->max_offset;\n+      int min1 = data1->min_offset;\n+\n+      if (data2->min_offset >= min1\n+\t  && data2->min_offset <= max1)\n+\treturn 0;\n+      else\n+\treturn min1 - data2->min_offset;\n+    }\n+  else\n+    {\n+      int max2 = data2->max_offset;\n+      int min2 = data2->min_offset;\n+\n+      if (data1->min_offset >= min2\n+\t  && data1->min_offset <= max2)\n+\treturn 0;\n+      else\n+\treturn data1->min_offset - min2;\n+    }\n+}\n+\n /* Helper function for rank_for_schedule sorting.  */\n static int\n autopref_rank_for_schedule (const rtx_insn *insn1, const rtx_insn *insn2)\n@@ -5650,7 +5725,7 @@ autopref_rank_for_schedule (const rtx_insn *insn1, const rtx_insn *insn2)\n       int irrel2 = data2->status == AUTOPREF_MULTIPASS_DATA_IRRELEVANT;\n \n       if (!irrel1 && !irrel2)\n-\tr = data1->offset - data2->offset;\n+\tr = autopref_rank_data (data1, data2);\n       else\n \tr = irrel2 - irrel1;\n     }\n@@ -5678,7 +5753,7 @@ autopref_multipass_dfa_lookahead_guard_1 (const rtx_insn *insn1,\n     return 0;\n \n   if (rtx_equal_p (data1->base, data2->base)\n-      && data1->offset > data2->offset)\n+      && autopref_rank_data (data1, data2) > 0)\n     {\n       if (sched_verbose >= 2)\n \t{"}, {"sha": "2af8f9fc32c0085c18511bbc83ad52c6ec31f671", "filename": "gcc/sched-int.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/748d9390b9739dadc48a775c7ea869c42b3f39a9/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/748d9390b9739dadc48a775c7ea869c42b3f39a9/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=748d9390b9739dadc48a775c7ea869c42b3f39a9", "patch": "@@ -819,8 +819,15 @@ struct autopref_multipass_data_\n   /* Base part of memory address.  */\n   rtx base;\n \n-  /* Memory offset from the base.  */\n-  int offset;\n+  /* Memory offsets from the base.  For single simple sets\n+     only min_offset is valid.  For multi-set insns min_offset\n+     and max_offset record the minimum and maximum offsets from the same\n+     base among the sets inside the PARALLEL.  */\n+  int min_offset;\n+  int max_offset;\n+\n+  /* True if this is a load/store-multiple instruction.  */\n+  bool multi_mem_insn_p;\n \n   /* Entry status.  */\n   enum autopref_multipass_data_status status;"}]}