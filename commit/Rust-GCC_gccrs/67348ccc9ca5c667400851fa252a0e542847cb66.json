{"sha": "67348ccc9ca5c667400851fa252a0e542847cb66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjczNDhjY2M5Y2E1YzY2NzQwMDg1MWZhMjUyYTBlNTQyODQ3Y2I2Ng==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2013-10-29T18:30:00Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2013-10-29T18:30:00Z"}, "message": "Autogenerated fixes of \"->symbol.\" to \"->\"\n\nThis is the autogenerated part of the conversion of the symtable types\nto a C++ class hierarchy.\n\ngcc/\n\n\tPatch autogenerated by refactor_symtab.py from\n\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n\trevision 58bb219cc090b2f4516a9297d868c245495ee622\n\n\t* asan.c (asan_finish_file): Update for conversion of symtab types to\n\ta true class hierarchy.\n\t* cfgexpand.c (estimated_stack_frame_size): Likewise.\n\t* cgraph.c (cgraph_get_body): Likewise.\n\t(cgraph_get_create_real_symbol_node): Likewise.\n\t(verify_cgraph_node): Likewise.\n\t(verify_edge_corresponds_to_fndecl): Likewise.\n\t(verify_edge_count_and_frequency): Likewise.\n\t(cgraph_will_be_removed_from_program_if_no_direct_calls): Likewise.\n\t(cgraph_can_remove_if_no_direct_calls_p): Likewise.\n\t(cgraph_can_remove_if_no_direct_calls_and_refs_p): Likewise.\n\t(cgraph_node_cannot_return): Likewise.\n\t(cgraph_set_pure_flag_1): Likewise.\n\t(cgraph_set_const_flag_1): Likewise.\n\t(cgraph_set_nothrow_flag_1): Likewise.\n\t(cgraph_make_node_local_1): Likewise.\n\t(cgraph_for_node_and_aliases): Likewise.\n\t(cgraph_for_node_thunks_and_aliases): Likewise.\n\t(cgraph_node_can_be_local_p): Likewise.\n\t(cgraph_node_cannot_be_local_p_1): Likewise.\n\t(cgraph_function_body_availability): Likewise.\n\t(dump_cgraph_node): Likewise.\n\t(cgraph_rtl_info): Likewise.\n\t(cgraph_mark_address_taken_node): Likewise.\n\t(cgraph_remove_node): Likewise.\n\t(cgraph_release_function_body): Likewise.\n\t(cgraph_update_edges_for_call_stmt_node): Likewise.\n\t(cgraph_redirect_edge_call_stmt_to_callee): Likewise.\n\t(cgraph_make_edge_direct): Likewise.\n\t(cgraph_resolve_speculation): Likewise.\n\t(cgraph_speculative_call_info): Likewise.\n\t(cgraph_turn_edge_to_speculative): Likewise.\n\t(cgraph_create_edge_1): Likewise.\n\t(cgraph_set_call_stmt): Likewise.\n\t(cgraph_node_for_asm): Likewise.\n\t(cgraph_add_thunk): Likewise.\n\t(cgraph_same_body_alias): Likewise.\n\t(cgraph_create_function_alias): Likewise.\n\t(cgraph_create_node): Likewise.\n\t(cgraph_create_empty_node): Likewise.\n\t(record_function_versions): Likewise.\n\t(used_from_object_file_p): Likewise.\n\t* cgraph.h (symtab_can_be_discarded): Likewise.\n\t(symtab_real_symbol_p): Likewise.\n\t(cgraph_mark_force_output_node): Likewise.\n\t(cgraph_edge_recursive_p): Likewise.\n\t(symtab_alias_target): Likewise.\n\t(varpool_all_refs_explicit_p): Likewise.\n\t(varpool_can_remove_if_no_refs): Likewise.\n\t(cgraph_only_called_directly_or_aliased_p): Likewise.\n\t(cgraph_next_function_with_gimple_body): Likewise.\n\t(cgraph_first_function_with_gimple_body): Likewise.\n\t(cgraph_function_with_gimple_body_p): Likewise.\n\t(cgraph_next_function): Likewise.\n\t(cgraph_first_function): Likewise.\n\t(cgraph_next_defined_function): Likewise.\n\t(cgraph_first_defined_function): Likewise.\n\t(varpool_next_defined_variable): Likewise.\n\t(varpool_first_defined_variable): Likewise.\n\t(varpool_next_static_initializer): Likewise.\n\t(varpool_first_static_initializer): Likewise.\n\t(varpool_next_variable): Likewise.\n\t(varpool_first_variable): Likewise.\n\t(varpool_node_name): Likewise.\n\t(varpool): Likewise.\n\t(cgraph): Likewise.\n\t(is_a_helper <varpool_node>::test): Likewise.\n\t(is_a_helper <cgraph_node>::test): Likewise.\n\t(varpool_variable_node): Likewise.\n\t(cgraph_function_or_thunk_node): Likewise.\n\t(varpool_alias_target): Likewise.\n\t(cgraph_alias_target): Likewise.\n\t(cgraph_node_name): Likewise.\n\t(varpool_node_asm_name): Likewise.\n\t(cgraph_node_asm_name): Likewise.\n\t* cgraphbuild.c (remove_cgraph_callee_edges): Likewise.\n\t(cgraph_rebuild_references): Likewise.\n\t(rebuild_cgraph_edges): Likewise.\n\t(record_eh_tables): Likewise.\n\t(build_cgraph_edges): Likewise.\n\t(mark_store): Likewise.\n\t(mark_load): Likewise.\n\t(mark_address): Likewise.\n\t(record_type_list): Likewise.\n\t(record_reference): Likewise.\n\t* cgraphclones.c (cgraph_materialize_all_clones): Likewise.\n\t(cgraph_materialize_clone): Likewise.\n\t(cgraph_function_versioning): Likewise.\n\t(cgraph_copy_node_for_versioning): Likewise.\n\t(update_call_expr): Likewise.\n\t(cgraph_find_replacement_node): Likewise.\n\t(cgraph_create_virtual_clone): Likewise.\n\t(cgraph_clone_node): Likewise.\n\t* cgraphunit.c (compile): Likewise.\n\t(output_weakrefs): Likewise.\n\t(output_in_order): Likewise.\n\t(expand_function): Likewise.\n\t(assemble_thunks_and_aliases): Likewise.\n\t(expand_thunk): Likewise.\n\t(mark_functions_to_output): Likewise.\n\t(handle_alias_pairs): Likewise.\n\t(analyze_functions): Likewise.\n\t(walk_polymorphic_call_targets): Likewise.\n\t(varpool_finalize_decl): Likewise.\n\t(process_function_and_variable_attributes): Likewise.\n\t(cgraph_process_same_body_aliases): Likewise.\n\t(analyze_function): Likewise.\n\t(cgraph_add_new_function): Likewise.\n\t(cgraph_finalize_function): Likewise.\n\t(referred_to_p): Likewise.\n\t(cgraph_reset_node): Likewise.\n\t(cgraph_process_new_functions): Likewise.\n\t(enqueue_node): Likewise.\n\t(decide_is_symbol_needed): Likewise.\n\t* coverage.c (coverage_compute_profile_id): Likewise.\n\t* dbxout.c (dbxout_expand_expr): Likewise.\n\t* dwarf2out.c (premark_types_used_by_global_vars_helper): Likewise.\n\t(reference_to_unused): Likewise.\n\t* gimple-fold.c (can_refer_decl_in_current_unit_p): Likewise.\n\t* gimplify.c (unvisit_body): Likewise.\n\t(unshare_body): Likewise.\n\t* ipa-cp.c (ipcp_generate_summary): Likewise.\n\t(ipcp_decision_stage): Likewise.\n\t(identify_dead_nodes): Likewise.\n\t(decide_whether_version_node): Likewise.\n\t(decide_about_value): Likewise.\n\t(perhaps_add_new_callers): Likewise.\n\t(create_specialized_node): Likewise.\n\t(update_profiling_info): Likewise.\n\t(ipcp_propagate_stage): Likewise.\n\t(estimate_local_effects): Likewise.\n\t(good_cloning_opportunity_p): Likewise.\n\t(devirtualization_time_bonus): Likewise.\n\t(propagate_constants_accross_call): Likewise.\n\t(initialize_node_lattices): Likewise.\n\t(ipcp_cloning_candidate_p): Likewise.\n\t(determine_versionability): Likewise.\n\t(print_all_lattices): Likewise.\n\t(print_lattice): Likewise.\n\t(ipcp_discover_new_direct_edges): Likewise.\n\t* ipa-devirt.c (ipa_devirt): Likewise.\n\t(likely_target_p): Likewise.\n\t(update_type_inheritance_graph): Likewise.\n\t(possible_polymorphic_call_target_p): Likewise.\n\t(dump_possible_polymorphic_call_targets): Likewise.\n\t(devirt_variable_node_removal_hook): Likewise.\n\t(record_binfo): Likewise.\n\t(maybe_record_node): Likewise.\n\t(build_type_inheritance_graph): Likewise.\n\t* ipa-inline-analysis.c (inline_write_summary): Likewise.\n\t(inline_generate_summary): Likewise.\n\t(inline_analyze_function): Likewise.\n\t(do_estimate_growth): Likewise.\n\t(simple_edge_hints): Likewise.\n\t(estimate_node_size_and_time): Likewise.\n\t(estimate_edge_devirt_benefit): Likewise.\n\t(compute_inline_parameters): Likewise.\n\t(estimate_function_body_sizes): Likewise.\n\t(compute_bb_predicates): Likewise.\n\t(initialize_inline_failed): Likewise.\n\t(dump_inline_summary): Likewise.\n\t(dump_inline_edge_summary): Likewise.\n\t* ipa-inline-transform.c (inline_transform): Likewise.\n\t(preserve_function_body_p): Likewise.\n\t(save_inline_function_body): Likewise.\n\t(inline_call): Likewise.\n\t(clone_inlined_nodes): Likewise.\n\t(can_remove_node_now_p): Likewise.\n\t(can_remove_node_now_p_1): Likewise.\n\t* ipa-inline.c (early_inliner): Likewise.\n\t(early_inline_small_functions): Likewise.\n\t(inline_always_inline_functions): Likewise.\n\t(ipa_inline): Likewise.\n\t(flatten_function): Likewise.\n\t(inline_small_functions): Likewise.\n\t(speculation_useful_p): Likewise.\n\t(recursive_inlining): Likewise.\n\t(update_caller_keys): Likewise.\n\t(reset_edge_caches): Likewise.\n\t(update_edge_key): Likewise.\n\t(edge_badness): Likewise.\n\t(relative_time_benefit): Likewise.\n\t(want_inline_self_recursive_call_p): Likewise.\n\t(want_inline_small_function_p): Likewise.\n\t(want_early_inline_function_p): Likewise.\n\t(num_calls): Likewise.\n\t(can_early_inline_edge_p): Likewise.\n\t(can_inline_edge_p): Likewise.\n\t(report_inline_failed_reason): Likewise.\n\t* ipa-profile.c (ipa_profile): Likewise.\n\t(ipa_propagate_frequency): Likewise.\n\t(ipa_propagate_frequency_1): Likewise.\n\t(ipa_profile_generate_summary): Likewise.\n\t* ipa-prop.c (ipcp_transform_function): Likewise.\n\t(read_replacements_section): Likewise.\n\t(ipa_prop_read_section): Likewise.\n\t(ipa_modify_call_arguments): Likewise.\n\t(ipa_print_node_params): Likewise.\n\t(propagate_controlled_uses): Likewise.\n\t(update_indirect_edges_after_inlining): Likewise.\n\t(remove_described_reference): Likewise.\n\t(ipa_make_edge_direct_to_target): Likewise.\n\t(ipa_analyze_node): Likewise.\n\t(ipa_analyze_params_uses): Likewise.\n\t(ipa_compute_jump_functions): Likewise.\n\t(ipa_get_callee_param_type): Likewise.\n\t(ipa_print_node_jump_functions): Likewise.\n\t(ipa_initialize_node_params): Likewise.\n\t(ipa_populate_param_decls): Likewise.\n\t(ipa_func_spec_opts_forbid_analysis_p): Likewise.\n\t(write_agg_replacement_chain): Likewise.\n\t(ipa_write_node_info): Likewise.\n\t(ipa_edge_duplication_hook): Likewise.\n\t(try_decrement_rdesc_refcount): Likewise.\n\t* ipa-pure-const.c (propagate_nothrow): Likewise.\n\t(propagate_pure_const): Likewise.\n\t(pure_const_read_summary): Likewise.\n\t(pure_const_write_summary): Likewise.\n\t(analyze_function): Likewise.\n\t* ipa-ref-inline.h (ipa_ref_referred_ref_list): Likewise.\n\t(ipa_ref_referring_ref_list): Likewise.\n\t* ipa-ref.c (ipa_clear_stmts_in_references): Likewise.\n\t(ipa_remove_stmt_references): Likewise.\n\t(ipa_find_reference): Likewise.\n\t(ipa_dump_referring): Likewise.\n\t(ipa_dump_references): Likewise.\n\t(ipa_record_reference): Likewise.\n\t* ipa-reference.c (ipa_reference_read_optimization_summary): Likewise.\n\t(ipa_reference_write_optimization_summary): Likewise.\n\t(write_node_summary_p): Likewise.\n\t(propagate): Likewise.\n\t(read_write_all_from_decl): Likewise.\n\t(generate_summary): Likewise.\n\t(analyze_function): Likewise.\n\t(propagate_bits): Likewise.\n\t(ipa_reference_get_not_written_global): Likewise.\n\t(ipa_reference_get_not_read_global): Likewise.\n\t* ipa-split.c (execute_split_functions): Likewise.\n\t(split_function): Likewise.\n\t* ipa-utils.c (ipa_merge_profiles): Likewise.\n\t(dump_cgraph_node_set): Likewise.\n\t(ipa_reverse_postorder): Likewise.\n\t(ipa_edge_within_scc): Likewise.\n\t(ipa_get_nodes_in_cycle): Likewise.\n\t(ipa_free_postorder_info): Likewise.\n\t(ipa_reduced_postorder): Likewise.\n\t(searchc): Likewise.\n\t(recursive_call_p): Likewise.\n\t* ipa.c (ipa_cdtor_merge): Likewise.\n\t(record_cdtor_fn): Likewise.\n\t(function_and_variable_visibility): Likewise.\n\t(varpool_externally_visible_p): Likewise.\n\t(cgraph_externally_visible_p): Likewise.\n\t(comdat_can_be_unshared_p): Likewise.\n\t(comdat_can_be_unshared_p_1): Likewise.\n\t(address_taken_from_non_vtable_p): Likewise.\n\t(ipa_discover_readonly_nonaddressable_vars): Likewise.\n\t(symtab_remove_unreachable_nodes): Likewise.\n\t(walk_polymorphic_call_targets): Likewise.\n\t(process_references): Likewise.\n\t(enqueue_node): Likewise.\n\t(has_addr_references_p): Likewise.\n\t(cgraph_non_local_node_p_1): Likewise.\n\t* is-a.h (varpool_analyze_node): Likewise.\n\t* lto-cgraph.c (input_symtab): Likewise.\n\t(merge_profile_summaries): Likewise.\n\t(input_cgraph_1): Likewise.\n\t(input_edge): Likewise.\n\t(input_varpool_node): Likewise.\n\t(input_node): Likewise.\n\t(input_overwrite_node): Likewise.\n\t(compute_ltrans_boundary): Likewise.\n\t(output_refs): Likewise.\n\t(lto_output_varpool_node): Likewise.\n\t(lto_output_node): Likewise.\n\t(reachable_from_other_partition_p): Likewise.\n\t(referenced_from_other_partition_p): Likewise.\n\t(lto_output_edge): Likewise.\n\t(output_node_opt_summary): Likewise.\n\t(add_node_to): Likewise.\n\t(reachable_from_this_partition_p): Likewise.\n\t(lto_set_symtab_encoder_in_partition): Likewise.\n\t(lto_symtab_encoder_in_partition_p): Likewise.\n\t(lto_set_symtab_encoder_encode_initializer): Likewise.\n\t(lto_symtab_encoder_encode_initializer_p): Likewise.\n\t(lto_set_symtab_encoder_encode_body): Likewise.\n\t(lto_symtab_encoder_encode_body_p): Likewise.\n\t* lto-section-in.c (lto_free_function_in_decl_state_for_node):\n\tLikewise.\n\t* lto-streamer-in.c (lto_read_body): Likewise.\n\t(fixup_call_stmt_edges): Likewise.\n\t(fixup_call_stmt_edges_1): Likewise.\n\t* lto-streamer-out.c (produce_symtab): Likewise.\n\t(output_symbol_p): Likewise.\n\t(write_symbol): Likewise.\n\t(lto_output): Likewise.\n\t(copy_function): Likewise.\n\t(output_function): Likewise.\n\t* passes.c (function_called_by_processed_nodes_p): Likewise.\n\t(ipa_write_optimization_summaries): Likewise.\n\t(ipa_write_summaries): Likewise.\n\t(do_per_function_toporder): Likewise.\n\t(do_per_function): Likewise.\n\t(dump_passes): Likewise.\n\t* symtab.c (symtab_semantically_equivalent_p): Likewise.\n\t(symtab_nonoverwritable_alias): Likewise.\n\t(symtab_nonoverwritable_alias_1): Likewise.\n\t(symtab_for_node_and_aliases): Likewise.\n\t(symtab_resolve_alias): Likewise.\n\t(fixup_same_cpp_alias_visibility): Likewise.\n\t(symtab_alias_ultimate_target): Likewise.\n\t(symtab_used_from_object_file_p): Likewise.\n\t(verify_symtab_base): Likewise.\n\t(dump_symtab_base): Likewise.\n\t(symtab_node_name): Likewise.\n\t(symtab_node_asm_name): Likewise.\n\t(symtab_dissolve_same_comdat_group_list): Likewise.\n\t(symtab_add_to_same_comdat_group): Likewise.\n\t(symtab_unregister_node): Likewise.\n\t(symtab_insert_node_to_hashtable): Likewise.\n\t(symtab_register_node): Likewise.\n\t(unlink_from_assembler_name_hash): Likewise.\n\t(insert_to_assembler_name_hash): Likewise.\n\t(eq_assembler_name): Likewise.\n\t(hash_node_by_assembler_name): Likewise.\n\t(eq_node): Likewise.\n\t(hash_node): Likewise.\n\t* toplev.c (wrapup_global_declaration_2): Likewise.\n\t* trans-mem.c (ipa_tm_execute): Likewise.\n\t(ipa_tm_transform_clone): Likewise.\n\t(ipa_tm_transform_transaction): Likewise.\n\t(ipa_tm_transform_calls_redirect): Likewise.\n\t(ipa_tm_insert_gettmclone_call): Likewise.\n\t(ipa_tm_insert_irr_call): Likewise.\n\t(ipa_tm_create_version): Likewise.\n\t(ipa_tm_create_version_alias): Likewise.\n\t(ipa_tm_mark_forced_by_abi_node): Likewise.\n\t(ipa_tm_mark_force_output_node): Likewise.\n\t(ipa_tm_diagnose_tm_safe): Likewise.\n\t(ipa_tm_mayenterirr_function): Likewise.\n\t(ipa_tm_scan_irr_function): Likewise.\n\t(ipa_tm_note_irrevocable): Likewise.\n\t(ipa_tm_scan_calls_clone): Likewise.\n\t(get_cg_data): Likewise.\n\t* tree-eh.c (tree_could_trap_p): Likewise.\n\t* tree-emutls.c (ipa_lower_emutls): Likewise.\n\t(create_emultls_var): Likewise.\n\t(lower_emutls_function_body): Likewise.\n\t(gen_emutls_addr): Likewise.\n\t(emutls_decl): Likewise.\n\t(new_emutls_decl): Likewise.\n\t* tree-inline.c (tree_function_versioning): Likewise.\n\t(optimize_inline_calls): Likewise.\n\t(expand_call_inline): Likewise.\n\t(estimate_num_insns): Likewise.\n\t(copy_bb): Likewise.\n\t(delete_unreachable_blocks_update_callgraph): Likewise.\n\t* tree-nested.c (gimplify_all_functions): Likewise.\n\t(create_nesting_tree): Likewise.\n\t(check_for_nested_with_variably_modified): Likewise.\n\t* tree-pretty-print.c (dump_function_header): Likewise.\n\t* tree-profile.c (tree_profiling): Likewise.\n\t* tree-sra.c (ipa_sra_preliminary_function_checks): Likewise.\n\t(modify_function): Likewise.\n\t(convert_callers): Likewise.\n\t(convert_callers_for_node): Likewise.\n\t* tree-ssa-structalias.c (ipa_pta_execute): Likewise.\n\t(associate_varinfo_to_alias): Likewise.\n\t(create_variable_info_for): Likewise.\n\t(get_constraint_for_ssa_var): Likewise.\n\t* tree-vectorizer.c (increase_alignment): Likewise.\n\t* tree.c (find_decls_types_in_var): Likewise.\n\t(find_decls_types_in_node): Likewise.\n\t(free_lang_data_in_decl): Likewise.\n\t* value-prof.c (gimple_ic_transform): Likewise.\n\t(gimple_ic): Likewise.\n\t(check_ic_target): Likewise.\n\t(init_node_map): Likewise.\n\t* varasm.c (decl_binds_to_current_def_p): Likewise.\n\t(default_binds_local_p_1): Likewise.\n\t(dump_tm_clone_pairs): Likewise.\n\t(assemble_alias): Likewise.\n\t(find_decl): Likewise.\n\t(mark_decl_referenced): Likewise.\n\t* varpool.c (varpool_for_node_and_aliases): Likewise.\n\t(varpool_extra_name_alias): Likewise.\n\t(varpool_create_variable_alias): Likewise.\n\t(add_new_static_var): Likewise.\n\t(varpool_finalize_named_section_flags): Likewise.\n\t(varpool_remove_unreferenced_decls): Likewise.\n\t(enqueue_node): Likewise.\n\t(varpool_assemble_decl): Likewise.\n\t(assemble_aliases): Likewise.\n\t(varpool_analyze_node): Likewise.\n\t(cgraph_variable_initializer_availability): Likewise.\n\t(varpool_add_new_variable): Likewise.\n\t(ctor_for_folding): Likewise.\n\t(dump_varpool_node): Likewise.\n\t(varpool_remove_initializer): Likewise.\n\t(varpool_remove_node): Likewise.\n\t(varpool_node_for_decl): Likewise.\n\t(varpool_create_empty_node): Likewise.\n\t* config/i386/i386.c (ix86_generate_version_dispatcher_body):\n\tLikewise.\n\t(ix86_get_function_versions_dispatcher): Likewise.\n\ngcc/ada/\n\n\tPatch autogenerated by refactor_symtab.py from\n\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n\trevision 58bb219cc090b2f4516a9297d868c245495ee622\n\n\t* gcc-interface/trans.c (finalize_nrv): Update for conversion of\n\tsymtab types to a true class hierarchy.\n\t* gcc-interface/utils.c (gnat_write_global_declarations): Likewise.\n\ngcc/c-family/\n\n\tPatch autogenerated by refactor_symtab.py from\n\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n\trevision 58bb219cc090b2f4516a9297d868c245495ee622\n\n\t* c-gimplify.c (c_genericize): Update for conversion of symtab types\n\tto a true class hierarchy.\n\t* c-pragma.c (maybe_apply_pending_pragma_weaks): Likewise.\n\ngcc/cp/\n\n\tPatch autogenerated by refactor_symtab.py from\n\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n\trevision 58bb219cc090b2f4516a9297d868c245495ee622\n\n\t* call.c (mark_versions_used): Update for conversion of symtab types\n\tto a true class hierarchy.\n\t* decl2.c (cp_write_global_declarations): Likewise.\n\t(clear_decl_external): Likewise.\n\t(build_java_method_aliases): Likewise.\n\t(collect_candidates_for_java_method_aliases): Likewise.\n\t(mark_needed): Likewise.\n\t(var_finalized_p): Likewise.\n\t(maybe_make_one_only): Likewise.\n\t(maybe_emit_vtables): Likewise.\n\t* lambda.c (maybe_add_lambda_conv_op): Likewise.\n\t* method.c (use_thunk): Likewise.\n\t* optimize.c (maybe_clone_body): Likewise.\n\t* tree.c (cp_fix_function_decl_p): Likewise.\n\ngcc/java/\n\n\tPatch autogenerated by refactor_symtab.py from\n\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n\trevision 58bb219cc090b2f4516a9297d868c245495ee622\n\n\t* decl.c (java_mark_decl_local): Update for conversion of symtab types\n\tto a true class hierarchy.\n\ngcc/lto/\n\n\tPatch autogenerated by refactor_symtab.py from\n\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n\trevision 58bb219cc090b2f4516a9297d868c245495ee622\n\n\t* lto-partition.c (lto_promote_cross_file_statics): Update for\n\tconversion of symtab types to a true class hierarchy.\n\t(rename_statics): Likewise.\n\t(promote_symbol): Likewise.\n\t(privatize_symbol_name): Likewise.\n\t(lto_balanced_map): Likewise.\n\t(varpool_node_cmp): Likewise.\n\t(node_cmp): Likewise.\n\t(lto_1_to_1_map): Likewise.\n\t(undo_partition): Likewise.\n\t(add_symbol_to_partition): Likewise.\n\t(contained_in_symbol): Likewise.\n\t(add_symbol_to_partition_1): Likewise.\n\t(add_references_to_partition): Likewise.\n\t(symbol_partitioned_p): Likewise.\n\t(get_symbol_class): Likewise.\n\t(lto_max_map): Likewise.\n\t* lto-symtab.c (lto_symtab_prevailing_decl): Likewise.\n\t(lto_symtab_merge_symbols): Likewise.\n\t(lto_symtab_merge_symbols_1): Likewise.\n\t(lto_symtab_merge_decls): Likewise.\n\t(lto_symtab_merge_decls_1): Likewise.\n\t(lto_symtab_merge_decls_2): Likewise.\n\t(lto_symtab_resolve_symbols): Likewise.\n\t(lto_symtab_resolve_can_prevail_p): Likewise.\n\t(lto_symtab_symbol_p): Likewise.\n\t(lto_symtab_resolve_replaceable_p): Likewise.\n\t(lto_symtab_merge): Likewise.\n\t(lto_varpool_replace_node): Likewise.\n\t(lto_cgraph_replace_node): Likewise.\n\t* lto.c (lto_main): Likewise.\n\t(do_whole_program_analysis): Likewise.\n\t(materialize_cgraph): Likewise.\n\t(read_cgraph_and_symbols): Likewise.\n\t(cmp_partitions_order): Likewise.\n\t(lto_materialize_function): Likewise.\n\t(has_analyzed_clone_p): Likewise.\n\nFrom-SVN: r204171", "tree": {"sha": "f3633e8f82a98ad68711b7c65603427a81a4f40c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3633e8f82a98ad68711b7c65603427a81a4f40c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67348ccc9ca5c667400851fa252a0e542847cb66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67348ccc9ca5c667400851fa252a0e542847cb66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67348ccc9ca5c667400851fa252a0e542847cb66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67348ccc9ca5c667400851fa252a0e542847cb66/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a3bfa8b80c84f097b684b5ba7851ceb81642ccd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3bfa8b80c84f097b684b5ba7851ceb81642ccd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3bfa8b80c84f097b684b5ba7851ceb81642ccd3"}], "stats": {"total": 4342, "additions": 2424, "deletions": 1918}, "files": [{"sha": "2b76bf9cad64831f1e713e01e9b5d9d0a375da16", "filename": "gcc/ChangeLog", "status": "modified", "additions": 412, "deletions": 0, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -1,3 +1,415 @@\n+2013-10-29  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPatch autogenerated by refactor_symtab.py from\n+\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n+\trevision 58bb219cc090b2f4516a9297d868c245495ee622\n+\n+\t* asan.c (asan_finish_file): Update for conversion of symtab types to\n+\ta true class hierarchy.\n+\t* cfgexpand.c (estimated_stack_frame_size): Likewise.\n+\t* cgraph.c (cgraph_get_body): Likewise.\n+\t(cgraph_get_create_real_symbol_node): Likewise.\n+\t(verify_cgraph_node): Likewise.\n+\t(verify_edge_corresponds_to_fndecl): Likewise.\n+\t(verify_edge_count_and_frequency): Likewise.\n+\t(cgraph_will_be_removed_from_program_if_no_direct_calls): Likewise.\n+\t(cgraph_can_remove_if_no_direct_calls_p): Likewise.\n+\t(cgraph_can_remove_if_no_direct_calls_and_refs_p): Likewise.\n+\t(cgraph_node_cannot_return): Likewise.\n+\t(cgraph_set_pure_flag_1): Likewise.\n+\t(cgraph_set_const_flag_1): Likewise.\n+\t(cgraph_set_nothrow_flag_1): Likewise.\n+\t(cgraph_make_node_local_1): Likewise.\n+\t(cgraph_for_node_and_aliases): Likewise.\n+\t(cgraph_for_node_thunks_and_aliases): Likewise.\n+\t(cgraph_node_can_be_local_p): Likewise.\n+\t(cgraph_node_cannot_be_local_p_1): Likewise.\n+\t(cgraph_function_body_availability): Likewise.\n+\t(dump_cgraph_node): Likewise.\n+\t(cgraph_rtl_info): Likewise.\n+\t(cgraph_mark_address_taken_node): Likewise.\n+\t(cgraph_remove_node): Likewise.\n+\t(cgraph_release_function_body): Likewise.\n+\t(cgraph_update_edges_for_call_stmt_node): Likewise.\n+\t(cgraph_redirect_edge_call_stmt_to_callee): Likewise.\n+\t(cgraph_make_edge_direct): Likewise.\n+\t(cgraph_resolve_speculation): Likewise.\n+\t(cgraph_speculative_call_info): Likewise.\n+\t(cgraph_turn_edge_to_speculative): Likewise.\n+\t(cgraph_create_edge_1): Likewise.\n+\t(cgraph_set_call_stmt): Likewise.\n+\t(cgraph_node_for_asm): Likewise.\n+\t(cgraph_add_thunk): Likewise.\n+\t(cgraph_same_body_alias): Likewise.\n+\t(cgraph_create_function_alias): Likewise.\n+\t(cgraph_create_node): Likewise.\n+\t(cgraph_create_empty_node): Likewise.\n+\t(record_function_versions): Likewise.\n+\t(used_from_object_file_p): Likewise.\n+\t* cgraph.h (symtab_can_be_discarded): Likewise.\n+\t(symtab_real_symbol_p): Likewise.\n+\t(cgraph_mark_force_output_node): Likewise.\n+\t(cgraph_edge_recursive_p): Likewise.\n+\t(symtab_alias_target): Likewise.\n+\t(varpool_all_refs_explicit_p): Likewise.\n+\t(varpool_can_remove_if_no_refs): Likewise.\n+\t(cgraph_only_called_directly_or_aliased_p): Likewise.\n+\t(cgraph_next_function_with_gimple_body): Likewise.\n+\t(cgraph_first_function_with_gimple_body): Likewise.\n+\t(cgraph_function_with_gimple_body_p): Likewise.\n+\t(cgraph_next_function): Likewise.\n+\t(cgraph_first_function): Likewise.\n+\t(cgraph_next_defined_function): Likewise.\n+\t(cgraph_first_defined_function): Likewise.\n+\t(varpool_next_defined_variable): Likewise.\n+\t(varpool_first_defined_variable): Likewise.\n+\t(varpool_next_static_initializer): Likewise.\n+\t(varpool_first_static_initializer): Likewise.\n+\t(varpool_next_variable): Likewise.\n+\t(varpool_first_variable): Likewise.\n+\t(varpool_node_name): Likewise.\n+\t(varpool): Likewise.\n+\t(cgraph): Likewise.\n+\t(is_a_helper <varpool_node>::test): Likewise.\n+\t(is_a_helper <cgraph_node>::test): Likewise.\n+\t(varpool_variable_node): Likewise.\n+\t(cgraph_function_or_thunk_node): Likewise.\n+\t(varpool_alias_target): Likewise.\n+\t(cgraph_alias_target): Likewise.\n+\t(cgraph_node_name): Likewise.\n+\t(varpool_node_asm_name): Likewise.\n+\t(cgraph_node_asm_name): Likewise.\n+\t* cgraphbuild.c (remove_cgraph_callee_edges): Likewise.\n+\t(cgraph_rebuild_references): Likewise.\n+\t(rebuild_cgraph_edges): Likewise.\n+\t(record_eh_tables): Likewise.\n+\t(build_cgraph_edges): Likewise.\n+\t(mark_store): Likewise.\n+\t(mark_load): Likewise.\n+\t(mark_address): Likewise.\n+\t(record_type_list): Likewise.\n+\t(record_reference): Likewise.\n+\t* cgraphclones.c (cgraph_materialize_all_clones): Likewise.\n+\t(cgraph_materialize_clone): Likewise.\n+\t(cgraph_function_versioning): Likewise.\n+\t(cgraph_copy_node_for_versioning): Likewise.\n+\t(update_call_expr): Likewise.\n+\t(cgraph_find_replacement_node): Likewise.\n+\t(cgraph_create_virtual_clone): Likewise.\n+\t(cgraph_clone_node): Likewise.\n+\t* cgraphunit.c (compile): Likewise.\n+\t(output_weakrefs): Likewise.\n+\t(output_in_order): Likewise.\n+\t(expand_function): Likewise.\n+\t(assemble_thunks_and_aliases): Likewise.\n+\t(expand_thunk): Likewise.\n+\t(mark_functions_to_output): Likewise.\n+\t(handle_alias_pairs): Likewise.\n+\t(analyze_functions): Likewise.\n+\t(walk_polymorphic_call_targets): Likewise.\n+\t(varpool_finalize_decl): Likewise.\n+\t(process_function_and_variable_attributes): Likewise.\n+\t(cgraph_process_same_body_aliases): Likewise.\n+\t(analyze_function): Likewise.\n+\t(cgraph_add_new_function): Likewise.\n+\t(cgraph_finalize_function): Likewise.\n+\t(referred_to_p): Likewise.\n+\t(cgraph_reset_node): Likewise.\n+\t(cgraph_process_new_functions): Likewise.\n+\t(enqueue_node): Likewise.\n+\t(decide_is_symbol_needed): Likewise.\n+\t* coverage.c (coverage_compute_profile_id): Likewise.\n+\t* dbxout.c (dbxout_expand_expr): Likewise.\n+\t* dwarf2out.c (premark_types_used_by_global_vars_helper): Likewise.\n+\t(reference_to_unused): Likewise.\n+\t* gimple-fold.c (can_refer_decl_in_current_unit_p): Likewise.\n+\t* gimplify.c (unvisit_body): Likewise.\n+\t(unshare_body): Likewise.\n+\t* ipa-cp.c (ipcp_generate_summary): Likewise.\n+\t(ipcp_decision_stage): Likewise.\n+\t(identify_dead_nodes): Likewise.\n+\t(decide_whether_version_node): Likewise.\n+\t(decide_about_value): Likewise.\n+\t(perhaps_add_new_callers): Likewise.\n+\t(create_specialized_node): Likewise.\n+\t(update_profiling_info): Likewise.\n+\t(ipcp_propagate_stage): Likewise.\n+\t(estimate_local_effects): Likewise.\n+\t(good_cloning_opportunity_p): Likewise.\n+\t(devirtualization_time_bonus): Likewise.\n+\t(propagate_constants_accross_call): Likewise.\n+\t(initialize_node_lattices): Likewise.\n+\t(ipcp_cloning_candidate_p): Likewise.\n+\t(determine_versionability): Likewise.\n+\t(print_all_lattices): Likewise.\n+\t(print_lattice): Likewise.\n+\t(ipcp_discover_new_direct_edges): Likewise.\n+\t* ipa-devirt.c (ipa_devirt): Likewise.\n+\t(likely_target_p): Likewise.\n+\t(update_type_inheritance_graph): Likewise.\n+\t(possible_polymorphic_call_target_p): Likewise.\n+\t(dump_possible_polymorphic_call_targets): Likewise.\n+\t(devirt_variable_node_removal_hook): Likewise.\n+\t(record_binfo): Likewise.\n+\t(maybe_record_node): Likewise.\n+\t(build_type_inheritance_graph): Likewise.\n+\t* ipa-inline-analysis.c (inline_write_summary): Likewise.\n+\t(inline_generate_summary): Likewise.\n+\t(inline_analyze_function): Likewise.\n+\t(do_estimate_growth): Likewise.\n+\t(simple_edge_hints): Likewise.\n+\t(estimate_node_size_and_time): Likewise.\n+\t(estimate_edge_devirt_benefit): Likewise.\n+\t(compute_inline_parameters): Likewise.\n+\t(estimate_function_body_sizes): Likewise.\n+\t(compute_bb_predicates): Likewise.\n+\t(initialize_inline_failed): Likewise.\n+\t(dump_inline_summary): Likewise.\n+\t(dump_inline_edge_summary): Likewise.\n+\t* ipa-inline-transform.c (inline_transform): Likewise.\n+\t(preserve_function_body_p): Likewise.\n+\t(save_inline_function_body): Likewise.\n+\t(inline_call): Likewise.\n+\t(clone_inlined_nodes): Likewise.\n+\t(can_remove_node_now_p): Likewise.\n+\t(can_remove_node_now_p_1): Likewise.\n+\t* ipa-inline.c (early_inliner): Likewise.\n+\t(early_inline_small_functions): Likewise.\n+\t(inline_always_inline_functions): Likewise.\n+\t(ipa_inline): Likewise.\n+\t(flatten_function): Likewise.\n+\t(inline_small_functions): Likewise.\n+\t(speculation_useful_p): Likewise.\n+\t(recursive_inlining): Likewise.\n+\t(update_caller_keys): Likewise.\n+\t(reset_edge_caches): Likewise.\n+\t(update_edge_key): Likewise.\n+\t(edge_badness): Likewise.\n+\t(relative_time_benefit): Likewise.\n+\t(want_inline_self_recursive_call_p): Likewise.\n+\t(want_inline_small_function_p): Likewise.\n+\t(want_early_inline_function_p): Likewise.\n+\t(num_calls): Likewise.\n+\t(can_early_inline_edge_p): Likewise.\n+\t(can_inline_edge_p): Likewise.\n+\t(report_inline_failed_reason): Likewise.\n+\t* ipa-profile.c (ipa_profile): Likewise.\n+\t(ipa_propagate_frequency): Likewise.\n+\t(ipa_propagate_frequency_1): Likewise.\n+\t(ipa_profile_generate_summary): Likewise.\n+\t* ipa-prop.c (ipcp_transform_function): Likewise.\n+\t(read_replacements_section): Likewise.\n+\t(ipa_prop_read_section): Likewise.\n+\t(ipa_modify_call_arguments): Likewise.\n+\t(ipa_print_node_params): Likewise.\n+\t(propagate_controlled_uses): Likewise.\n+\t(update_indirect_edges_after_inlining): Likewise.\n+\t(remove_described_reference): Likewise.\n+\t(ipa_make_edge_direct_to_target): Likewise.\n+\t(ipa_analyze_node): Likewise.\n+\t(ipa_analyze_params_uses): Likewise.\n+\t(ipa_compute_jump_functions): Likewise.\n+\t(ipa_get_callee_param_type): Likewise.\n+\t(ipa_print_node_jump_functions): Likewise.\n+\t(ipa_initialize_node_params): Likewise.\n+\t(ipa_populate_param_decls): Likewise.\n+\t(ipa_func_spec_opts_forbid_analysis_p): Likewise.\n+\t(write_agg_replacement_chain): Likewise.\n+\t(ipa_write_node_info): Likewise.\n+\t(ipa_edge_duplication_hook): Likewise.\n+\t(try_decrement_rdesc_refcount): Likewise.\n+\t* ipa-pure-const.c (propagate_nothrow): Likewise.\n+\t(propagate_pure_const): Likewise.\n+\t(pure_const_read_summary): Likewise.\n+\t(pure_const_write_summary): Likewise.\n+\t(analyze_function): Likewise.\n+\t* ipa-ref-inline.h (ipa_ref_referred_ref_list): Likewise.\n+\t(ipa_ref_referring_ref_list): Likewise.\n+\t* ipa-ref.c (ipa_clear_stmts_in_references): Likewise.\n+\t(ipa_remove_stmt_references): Likewise.\n+\t(ipa_find_reference): Likewise.\n+\t(ipa_dump_referring): Likewise.\n+\t(ipa_dump_references): Likewise.\n+\t(ipa_record_reference): Likewise.\n+\t* ipa-reference.c (ipa_reference_read_optimization_summary): Likewise.\n+\t(ipa_reference_write_optimization_summary): Likewise.\n+\t(write_node_summary_p): Likewise.\n+\t(propagate): Likewise.\n+\t(read_write_all_from_decl): Likewise.\n+\t(generate_summary): Likewise.\n+\t(analyze_function): Likewise.\n+\t(propagate_bits): Likewise.\n+\t(ipa_reference_get_not_written_global): Likewise.\n+\t(ipa_reference_get_not_read_global): Likewise.\n+\t* ipa-split.c (execute_split_functions): Likewise.\n+\t(split_function): Likewise.\n+\t* ipa-utils.c (ipa_merge_profiles): Likewise.\n+\t(dump_cgraph_node_set): Likewise.\n+\t(ipa_reverse_postorder): Likewise.\n+\t(ipa_edge_within_scc): Likewise.\n+\t(ipa_get_nodes_in_cycle): Likewise.\n+\t(ipa_free_postorder_info): Likewise.\n+\t(ipa_reduced_postorder): Likewise.\n+\t(searchc): Likewise.\n+\t(recursive_call_p): Likewise.\n+\t* ipa.c (ipa_cdtor_merge): Likewise.\n+\t(record_cdtor_fn): Likewise.\n+\t(function_and_variable_visibility): Likewise.\n+\t(varpool_externally_visible_p): Likewise.\n+\t(cgraph_externally_visible_p): Likewise.\n+\t(comdat_can_be_unshared_p): Likewise.\n+\t(comdat_can_be_unshared_p_1): Likewise.\n+\t(address_taken_from_non_vtable_p): Likewise.\n+\t(ipa_discover_readonly_nonaddressable_vars): Likewise.\n+\t(symtab_remove_unreachable_nodes): Likewise.\n+\t(walk_polymorphic_call_targets): Likewise.\n+\t(process_references): Likewise.\n+\t(enqueue_node): Likewise.\n+\t(has_addr_references_p): Likewise.\n+\t(cgraph_non_local_node_p_1): Likewise.\n+\t* is-a.h (varpool_analyze_node): Likewise.\n+\t* lto-cgraph.c (input_symtab): Likewise.\n+\t(merge_profile_summaries): Likewise.\n+\t(input_cgraph_1): Likewise.\n+\t(input_edge): Likewise.\n+\t(input_varpool_node): Likewise.\n+\t(input_node): Likewise.\n+\t(input_overwrite_node): Likewise.\n+\t(compute_ltrans_boundary): Likewise.\n+\t(output_refs): Likewise.\n+\t(lto_output_varpool_node): Likewise.\n+\t(lto_output_node): Likewise.\n+\t(reachable_from_other_partition_p): Likewise.\n+\t(referenced_from_other_partition_p): Likewise.\n+\t(lto_output_edge): Likewise.\n+\t(output_node_opt_summary): Likewise.\n+\t(add_node_to): Likewise.\n+\t(reachable_from_this_partition_p): Likewise.\n+\t(lto_set_symtab_encoder_in_partition): Likewise.\n+\t(lto_symtab_encoder_in_partition_p): Likewise.\n+\t(lto_set_symtab_encoder_encode_initializer): Likewise.\n+\t(lto_symtab_encoder_encode_initializer_p): Likewise.\n+\t(lto_set_symtab_encoder_encode_body): Likewise.\n+\t(lto_symtab_encoder_encode_body_p): Likewise.\n+\t* lto-section-in.c (lto_free_function_in_decl_state_for_node):\n+\tLikewise.\n+\t* lto-streamer-in.c (lto_read_body): Likewise.\n+\t(fixup_call_stmt_edges): Likewise.\n+\t(fixup_call_stmt_edges_1): Likewise.\n+\t* lto-streamer-out.c (produce_symtab): Likewise.\n+\t(output_symbol_p): Likewise.\n+\t(write_symbol): Likewise.\n+\t(lto_output): Likewise.\n+\t(copy_function): Likewise.\n+\t(output_function): Likewise.\n+\t* passes.c (function_called_by_processed_nodes_p): Likewise.\n+\t(ipa_write_optimization_summaries): Likewise.\n+\t(ipa_write_summaries): Likewise.\n+\t(do_per_function_toporder): Likewise.\n+\t(do_per_function): Likewise.\n+\t(dump_passes): Likewise.\n+\t* symtab.c (symtab_semantically_equivalent_p): Likewise.\n+\t(symtab_nonoverwritable_alias): Likewise.\n+\t(symtab_nonoverwritable_alias_1): Likewise.\n+\t(symtab_for_node_and_aliases): Likewise.\n+\t(symtab_resolve_alias): Likewise.\n+\t(fixup_same_cpp_alias_visibility): Likewise.\n+\t(symtab_alias_ultimate_target): Likewise.\n+\t(symtab_used_from_object_file_p): Likewise.\n+\t(verify_symtab_base): Likewise.\n+\t(dump_symtab_base): Likewise.\n+\t(symtab_node_name): Likewise.\n+\t(symtab_node_asm_name): Likewise.\n+\t(symtab_dissolve_same_comdat_group_list): Likewise.\n+\t(symtab_add_to_same_comdat_group): Likewise.\n+\t(symtab_unregister_node): Likewise.\n+\t(symtab_insert_node_to_hashtable): Likewise.\n+\t(symtab_register_node): Likewise.\n+\t(unlink_from_assembler_name_hash): Likewise.\n+\t(insert_to_assembler_name_hash): Likewise.\n+\t(eq_assembler_name): Likewise.\n+\t(hash_node_by_assembler_name): Likewise.\n+\t(eq_node): Likewise.\n+\t(hash_node): Likewise.\n+\t* toplev.c (wrapup_global_declaration_2): Likewise.\n+\t* trans-mem.c (ipa_tm_execute): Likewise.\n+\t(ipa_tm_transform_clone): Likewise.\n+\t(ipa_tm_transform_transaction): Likewise.\n+\t(ipa_tm_transform_calls_redirect): Likewise.\n+\t(ipa_tm_insert_gettmclone_call): Likewise.\n+\t(ipa_tm_insert_irr_call): Likewise.\n+\t(ipa_tm_create_version): Likewise.\n+\t(ipa_tm_create_version_alias): Likewise.\n+\t(ipa_tm_mark_forced_by_abi_node): Likewise.\n+\t(ipa_tm_mark_force_output_node): Likewise.\n+\t(ipa_tm_diagnose_tm_safe): Likewise.\n+\t(ipa_tm_mayenterirr_function): Likewise.\n+\t(ipa_tm_scan_irr_function): Likewise.\n+\t(ipa_tm_note_irrevocable): Likewise.\n+\t(ipa_tm_scan_calls_clone): Likewise.\n+\t(get_cg_data): Likewise.\n+\t* tree-eh.c (tree_could_trap_p): Likewise.\n+\t* tree-emutls.c (ipa_lower_emutls): Likewise.\n+\t(create_emultls_var): Likewise.\n+\t(lower_emutls_function_body): Likewise.\n+\t(gen_emutls_addr): Likewise.\n+\t(emutls_decl): Likewise.\n+\t(new_emutls_decl): Likewise.\n+\t* tree-inline.c (tree_function_versioning): Likewise.\n+\t(optimize_inline_calls): Likewise.\n+\t(expand_call_inline): Likewise.\n+\t(estimate_num_insns): Likewise.\n+\t(copy_bb): Likewise.\n+\t(delete_unreachable_blocks_update_callgraph): Likewise.\n+\t* tree-nested.c (gimplify_all_functions): Likewise.\n+\t(create_nesting_tree): Likewise.\n+\t(check_for_nested_with_variably_modified): Likewise.\n+\t* tree-pretty-print.c (dump_function_header): Likewise.\n+\t* tree-profile.c (tree_profiling): Likewise.\n+\t* tree-sra.c (ipa_sra_preliminary_function_checks): Likewise.\n+\t(modify_function): Likewise.\n+\t(convert_callers): Likewise.\n+\t(convert_callers_for_node): Likewise.\n+\t* tree-ssa-structalias.c (ipa_pta_execute): Likewise.\n+\t(associate_varinfo_to_alias): Likewise.\n+\t(create_variable_info_for): Likewise.\n+\t(get_constraint_for_ssa_var): Likewise.\n+\t* tree-vectorizer.c (increase_alignment): Likewise.\n+\t* tree.c (find_decls_types_in_var): Likewise.\n+\t(find_decls_types_in_node): Likewise.\n+\t(free_lang_data_in_decl): Likewise.\n+\t* value-prof.c (gimple_ic_transform): Likewise.\n+\t(gimple_ic): Likewise.\n+\t(check_ic_target): Likewise.\n+\t(init_node_map): Likewise.\n+\t* varasm.c (decl_binds_to_current_def_p): Likewise.\n+\t(default_binds_local_p_1): Likewise.\n+\t(dump_tm_clone_pairs): Likewise.\n+\t(assemble_alias): Likewise.\n+\t(find_decl): Likewise.\n+\t(mark_decl_referenced): Likewise.\n+\t* varpool.c (varpool_for_node_and_aliases): Likewise.\n+\t(varpool_extra_name_alias): Likewise.\n+\t(varpool_create_variable_alias): Likewise.\n+\t(add_new_static_var): Likewise.\n+\t(varpool_finalize_named_section_flags): Likewise.\n+\t(varpool_remove_unreferenced_decls): Likewise.\n+\t(enqueue_node): Likewise.\n+\t(varpool_assemble_decl): Likewise.\n+\t(assemble_aliases): Likewise.\n+\t(varpool_analyze_node): Likewise.\n+\t(cgraph_variable_initializer_availability): Likewise.\n+\t(varpool_add_new_variable): Likewise.\n+\t(ctor_for_folding): Likewise.\n+\t(dump_varpool_node): Likewise.\n+\t(varpool_remove_initializer): Likewise.\n+\t(varpool_remove_node): Likewise.\n+\t(varpool_node_for_decl): Likewise.\n+\t(varpool_create_empty_node): Likewise.\n+\t* config/i386/i386.c (ix86_generate_version_dispatcher_body):\n+\tLikewise.\n+\t(ix86_get_function_versions_dispatcher): Likewise.\n+\n 2013-10-29  David Malcolm  <dmalcolm@redhat.com>\n \n \t* cgraph.h (symtab_node_base): Convert to a class;"}, {"sha": "3970d05c62490638a04ec21ec8473438067c78db", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -1,3 +1,13 @@\n+2013-10-29  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPatch autogenerated by refactor_symtab.py from\n+\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n+\trevision 58bb219cc090b2f4516a9297d868c245495ee622\n+\n+\t* gcc-interface/trans.c (finalize_nrv): Update for conversion of\n+\tsymtab types to a true class hierarchy.\n+\t* gcc-interface/utils.c (gnat_write_global_declarations): Likewise.\n+\n 2013-10-28  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* gcc-interface/decl.c (components_to_record): Adjust."}, {"sha": "1d76e6aa468e9e5abfe49333dc9093af22346557", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -3246,7 +3246,7 @@ finalize_nrv (tree fndecl, bitmap nrv, vec<tree, va_gc> *other, Node_Id gnat_ret\n   /* Prune also the candidates that are referenced by nested functions.  */\n   node = cgraph_get_create_node (fndecl);\n   for (node = node->nested; node; node = node->next_nested)\n-    walk_tree_without_duplicates (&DECL_SAVED_TREE (node->symbol.decl), prune_nrv_r,\n+    walk_tree_without_duplicates (&DECL_SAVED_TREE (node->decl), prune_nrv_r,\n \t\t\t\t  &data);\n   if (bitmap_empty_p (nrv))\n     return;"}, {"sha": "01a60280e630948f9886b37988ffb0e050fcd687", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -5633,7 +5633,7 @@ gnat_write_global_declarations (void)\n       TREE_STATIC (dummy_global) = 1;\n       TREE_ASM_WRITTEN (dummy_global) = 1;\n       node = varpool_node_for_decl (dummy_global);\n-      node->symbol.force_output = 1;\n+      node->force_output = 1;\n \n       while (!types_used_by_cur_var_decl->is_empty ())\n \t{"}, {"sha": "f2934b0490ddc19fcf44419fcdd57d12b9ac0998", "filename": "gcc/asan.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -2175,8 +2175,8 @@ asan_finish_file (void)\n   tree fn = builtin_decl_implicit (BUILT_IN_ASAN_INIT);\n   append_to_statement_list (build_call_expr (fn, 0), &asan_ctor_statements);\n   FOR_EACH_DEFINED_VARIABLE (vnode)\n-    if (TREE_ASM_WRITTEN (vnode->symbol.decl)\n-\t&& asan_protect_global (vnode->symbol.decl))\n+    if (TREE_ASM_WRITTEN (vnode->decl)\n+\t&& asan_protect_global (vnode->decl))\n       ++gcount;\n   htab_t const_desc_htab = constant_pool_htab ();\n   htab_traverse (const_desc_htab, count_string_csts, &gcount);\n@@ -2197,9 +2197,9 @@ asan_finish_file (void)\n       DECL_IGNORED_P (var) = 1;\n       vec_alloc (v, gcount);\n       FOR_EACH_DEFINED_VARIABLE (vnode)\n-\tif (TREE_ASM_WRITTEN (vnode->symbol.decl)\n-\t    && asan_protect_global (vnode->symbol.decl))\n-\t  asan_add_global (vnode->symbol.decl, TREE_TYPE (type), v);\n+\tif (TREE_ASM_WRITTEN (vnode->decl)\n+\t    && asan_protect_global (vnode->decl))\n+\t  asan_add_global (vnode->decl, TREE_TYPE (type), v);\n       struct asan_add_string_csts_data aascd;\n       aascd.type = TREE_TYPE (type);\n       aascd.v = v;"}, {"sha": "6c6435cca23ce8a9eba04d860c55fda37897e302", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -1,3 +1,13 @@\n+2013-10-29  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPatch autogenerated by refactor_symtab.py from\n+\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n+\trevision 58bb219cc090b2f4516a9297d868c245495ee622\n+\n+\t* c-gimplify.c (c_genericize): Update for conversion of symtab types\n+\tto a true class hierarchy.\n+\t* c-pragma.c (maybe_apply_pending_pragma_weaks): Likewise.\n+\n 2013-10-27  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* c-lex.c (interpret_integer): Remove call to cpp_num_sign_extend."}, {"sha": "2a4f633ad4ff3f9ef8f9f98d5b96798df7404a7d", "filename": "gcc/c-family/c-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fc-family%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fc-family%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-gimplify.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -98,7 +98,7 @@ c_genericize (tree fndecl)\n   /* Dump all nested functions now.  */\n   cgn = cgraph_get_create_node (fndecl);\n   for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n-    c_genericize (cgn->symbol.decl);\n+    c_genericize (cgn->decl);\n }\n \n static void"}, {"sha": "752a40d8e771afef047e3a75dbd3e0438245a4da", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -322,7 +322,7 @@ maybe_apply_pending_pragma_weaks (void)\n \n       target = symtab_node_for_asm (id);\n       decl = build_decl (UNKNOWN_LOCATION,\n-\t\t\t target ? TREE_CODE (target->symbol.decl) : FUNCTION_DECL,\n+\t\t\t target ? TREE_CODE (target->decl) : FUNCTION_DECL,\n \t\t\t alias_id, default_function_type);\n \n       DECL_ARTIFICIAL (decl) = 1;"}, {"sha": "fb05ce7a05d3dadb1d2bd8b7e6d9856e1dc5a4e5", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -1509,7 +1509,7 @@ estimated_stack_frame_size (struct cgraph_node *node)\n   HOST_WIDE_INT size = 0;\n   size_t i;\n   tree var;\n-  struct function *fn = DECL_STRUCT_FUNCTION (node->symbol.decl);\n+  struct function *fn = DECL_STRUCT_FUNCTION (node->decl);\n \n   push_cfun (fn);\n "}, {"sha": "4a4e9ac97d4a463cce44f7ad6486704f8f18195a", "filename": "gcc/cgraph.c", "status": "modified", "additions": 153, "deletions": 153, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -274,8 +274,8 @@ record_function_versions (tree decl1, tree decl2)\n \n /* Macros to access the next item in the list of free cgraph nodes and\n    edges. */\n-#define NEXT_FREE_NODE(NODE) cgraph ((NODE)->symbol.next)\n-#define SET_NEXT_FREE_NODE(NODE,NODE2) ((NODE))->symbol.next = (symtab_node)NODE2\n+#define NEXT_FREE_NODE(NODE) cgraph ((NODE)->next)\n+#define SET_NEXT_FREE_NODE(NODE,NODE2) ((NODE))->next = NODE2\n #define NEXT_FREE_EDGE(EDGE) (EDGE)->prev_caller\n \n /* Register HOOK to be called with DATA on each removed edge.  */\n@@ -513,7 +513,7 @@ cgraph_create_empty_node (void)\n {\n   struct cgraph_node *node = cgraph_allocate_node ();\n \n-  node->symbol.type = SYMTAB_FUNCTION;\n+  node->type = SYMTAB_FUNCTION;\n   node->frequency = NODE_FREQUENCY_NORMAL;\n   node->count_materialization_scale = REG_BR_PROB_BASE;\n   cgraph_n_nodes++;\n@@ -528,8 +528,8 @@ cgraph_create_node (tree decl)\n   struct cgraph_node *node = cgraph_create_empty_node ();\n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n \n-  node->symbol.decl = decl;\n-  symtab_register_node ((symtab_node) node);\n+  node->decl = decl;\n+  symtab_register_node (node);\n \n   if (DECL_CONTEXT (decl) && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)\n     {\n@@ -567,12 +567,12 @@ cgraph_create_function_alias (tree alias, tree target)\n \t      || TREE_CODE (target) == IDENTIFIER_NODE);\n   gcc_assert (TREE_CODE (alias) == FUNCTION_DECL);\n   alias_node = cgraph_get_create_node (alias);\n-  gcc_assert (!alias_node->symbol.definition);\n-  alias_node->symbol.alias_target = target;\n-  alias_node->symbol.definition = true;\n-  alias_node->symbol.alias = true;\n+  gcc_assert (!alias_node->definition);\n+  alias_node->alias_target = target;\n+  alias_node->definition = true;\n+  alias_node->alias = true;\n   if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (alias)) != NULL)\n-    alias_node->symbol.weakref = true;\n+    alias_node->weakref = true;\n   return alias_node;\n }\n \n@@ -595,10 +595,10 @@ cgraph_same_body_alias (struct cgraph_node *decl_node ATTRIBUTE_UNUSED, tree ali\n     return NULL;\n \n   n = cgraph_create_function_alias (alias, decl);\n-  n->symbol.cpp_implicit_alias = true;\n+  n->cpp_implicit_alias = true;\n   if (cpp_implicit_aliases_done)\n-    symtab_resolve_alias ((symtab_node)n,\n-\t\t\t  (symtab_node)cgraph_get_node (decl));\n+    symtab_resolve_alias (n,\n+\t\t\t  cgraph_get_node (decl));\n   return n;\n }\n \n@@ -619,8 +619,8 @@ cgraph_add_thunk (struct cgraph_node *decl_node ATTRIBUTE_UNUSED,\n   node = cgraph_get_node (alias);\n   if (node)\n     {\n-      gcc_assert (node->symbol.definition);\n-      gcc_assert (!node->symbol.alias);\n+      gcc_assert (node->definition);\n+      gcc_assert (!node->alias);\n       gcc_assert (!node->thunk.thunk_p);\n       cgraph_remove_node (node);\n     }\n@@ -635,7 +635,7 @@ cgraph_add_thunk (struct cgraph_node *decl_node ATTRIBUTE_UNUSED,\n   node->thunk.virtual_offset_p = virtual_offset != NULL;\n   node->thunk.alias = real_alias;\n   node->thunk.thunk_p = true;\n-  node->symbol.definition = true;\n+  node->definition = true;\n \n   return node;\n }\n@@ -649,7 +649,7 @@ cgraph_node_for_asm (tree asmname)\n   /* We do not want to look at inline clones.  */\n   for (symtab_node node = symtab_node_for_asm (asmname);\n        node;\n-       node = node->symbol.next_sharing_asm_name)\n+       node = node->next_sharing_asm_name)\n     {\n       cgraph_node *cn = dyn_cast <cgraph_node> (node);\n       if (cn && !cn->global.inlined_to)\n@@ -804,7 +804,7 @@ cgraph_set_call_stmt (struct cgraph_edge *e, gimple new_stmt,\n       e = cgraph_make_edge_direct (e, new_callee);\n     }\n \n-  push_cfun (DECL_STRUCT_FUNCTION (e->caller->symbol.decl));\n+  push_cfun (DECL_STRUCT_FUNCTION (e->caller->decl));\n   e->can_throw_external = stmt_can_throw_external (new_stmt);\n   pop_cfun ();\n   if (e->caller->call_site_hash)\n@@ -863,13 +863,13 @@ cgraph_create_edge_1 (struct cgraph_node *caller, struct cgraph_node *callee,\n   gcc_assert (freq <= CGRAPH_FREQ_MAX);\n \n   edge->call_stmt = call_stmt;\n-  push_cfun (DECL_STRUCT_FUNCTION (caller->symbol.decl));\n+  push_cfun (DECL_STRUCT_FUNCTION (caller->decl));\n   edge->can_throw_external\n     = call_stmt ? stmt_can_throw_external (call_stmt) : false;\n   pop_cfun ();\n   if (call_stmt\n-      && callee && callee->symbol.decl\n-      && !gimple_check_call_matching_types (call_stmt, callee->symbol.decl,\n+      && callee && callee->decl\n+      && !gimple_check_call_matching_types (call_stmt, callee->decl,\n \t\t\t\t\t    false))\n     edge->call_stmt_cannot_inline_p = true;\n   else\n@@ -1081,22 +1081,22 @@ cgraph_turn_edge_to_speculative (struct cgraph_edge *e,\n     {\n       fprintf (dump_file, \"Indirect call -> speculative call\"\n \t       \" %s/%i => %s/%i\\n\",\n-\t       xstrdup (cgraph_node_name (n)), n->symbol.order,\n-\t       xstrdup (cgraph_node_name (n2)), n2->symbol.order);\n+\t       xstrdup (cgraph_node_name (n)), n->order,\n+\t       xstrdup (cgraph_node_name (n2)), n2->order);\n     }\n   e->speculative = true;\n   e2 = cgraph_create_edge (n, n2, e->call_stmt, direct_count, direct_frequency);\n   initialize_inline_failed (e2);\n   e2->speculative = true;\n-  if (TREE_NOTHROW (n2->symbol.decl))\n+  if (TREE_NOTHROW (n2->decl))\n     e2->can_throw_external = false;\n   else\n     e2->can_throw_external = e->can_throw_external;\n   e2->lto_stmt_uid = e->lto_stmt_uid;\n   e->count -= e2->count;\n   e->frequency -= e2->frequency;\n   cgraph_call_edge_duplication_hooks (e, e2);\n-  ref = ipa_record_reference ((symtab_node)n, (symtab_node)n2,\n+  ref = ipa_record_reference (n, n2,\n \t\t\t      IPA_REF_ADDR, e->call_stmt);\n   ref->lto_stmt_uid = e->lto_stmt_uid;\n   ref->speculative = e->speculative;\n@@ -1150,7 +1150,7 @@ cgraph_speculative_call_info (struct cgraph_edge *e,\n   indirect = e2;\n \n   reference = NULL;\n-  for (i = 0; ipa_ref_list_reference_iterate (&e->caller->symbol.ref_list,\n+  for (i = 0; ipa_ref_list_reference_iterate (&e->caller->ref_list,\n \t\t\t\t\t      i, ref); i++)\n     if (ref->speculative\n \t&& ((ref->stmt && ref->stmt == e->call_stmt)\n@@ -1192,7 +1192,7 @@ cgraph_resolve_speculation (struct cgraph_edge *edge, tree callee_decl)\n   gcc_assert (edge->speculative);\n   cgraph_speculative_call_info (edge, e2, edge, ref);\n   if (!callee_decl\n-      || !symtab_semantically_equivalent_p ((symtab_node) ref->referred,\n+      || !symtab_semantically_equivalent_p (ref->referred,\n \t\t\t\t\t    symtab_get_node (callee_decl)))\n     {\n       if (dump_file)\n@@ -1201,16 +1201,16 @@ cgraph_resolve_speculation (struct cgraph_edge *edge, tree callee_decl)\n \t    {\n \t      fprintf (dump_file, \"Speculative indirect call %s/%i => %s/%i has \"\n \t\t       \"turned out to have contradicting known target \",\n-\t\t       xstrdup (cgraph_node_name (edge->caller)), edge->caller->symbol.order,\n-\t\t       xstrdup (cgraph_node_name (e2->callee)), e2->callee->symbol.order);\n+\t\t       xstrdup (cgraph_node_name (edge->caller)), edge->caller->order,\n+\t\t       xstrdup (cgraph_node_name (e2->callee)), e2->callee->order);\n \t      print_generic_expr (dump_file, callee_decl, 0);\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \t  else\n \t    {\n \t      fprintf (dump_file, \"Removing speculative call %s/%i => %s/%i\\n\",\n-\t\t       xstrdup (cgraph_node_name (edge->caller)), edge->caller->symbol.order,\n-\t\t       xstrdup (cgraph_node_name (e2->callee)), e2->callee->symbol.order);\n+\t\t       xstrdup (cgraph_node_name (edge->caller)), edge->caller->order,\n+\t\t       xstrdup (cgraph_node_name (e2->callee)), e2->callee->order);\n \t    }\n \t}\n     }\n@@ -1252,7 +1252,7 @@ cgraph_make_edge_direct (struct cgraph_edge *edge, struct cgraph_node *callee)\n   /* If we are redirecting speculative call, make it non-speculative.  */\n   if (edge->indirect_unknown_callee && edge->speculative)\n     {\n-      edge = cgraph_resolve_speculation (edge, callee->symbol.decl);\n+      edge = cgraph_resolve_speculation (edge, callee->decl);\n \n       /* On successful speculation just return the pre existing direct edge.  */\n       if (!edge->indirect_unknown_callee)\n@@ -1283,7 +1283,7 @@ cgraph_make_edge_direct (struct cgraph_edge *edge, struct cgraph_node *callee)\n \n   if (edge->call_stmt)\n     edge->call_stmt_cannot_inline_p\n-      = !gimple_check_call_matching_types (edge->call_stmt, callee->symbol.decl,\n+      = !gimple_check_call_matching_types (edge->call_stmt, callee->decl,\n \t\t\t\t\t   false);\n \n   /* We need to re-determine the inlining status of the edge.  */\n@@ -1320,23 +1320,23 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n \t signature.  We did not update the call statement yet, so compare it \n \t with the reference that still points to the proper type.  */\n       else if (!gimple_check_call_matching_types (e->call_stmt,\n-\t\t\t\t\t\t  ref->referred->symbol.decl,\n+\t\t\t\t\t\t  ref->referred->decl,\n \t\t\t\t\t\t  true))\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Not expanding speculative call of %s/%i -> %s/%i\\n\"\n \t\t     \"Type mismatch.\\n\",\n \t\t     xstrdup (cgraph_node_name (e->caller)),\n-\t\t     e->caller->symbol.order,\n+\t\t     e->caller->order,\n \t\t     xstrdup (cgraph_node_name (e->callee)),\n-\t\t     e->callee->symbol.order);\n+\t\t     e->callee->order);\n \t  e = cgraph_resolve_speculation (e, NULL);\n \t  /* We are producing the final function body and will throw away the\n \t     callgraph edges really soon.  Reset the counts/frequencies to\n \t     keep verifier happy in the case of roundoff errors.  */\n \t  e->count = gimple_bb (e->call_stmt)->count;\n \t  e->frequency = compute_call_stmt_bb_frequency\n-\t\t\t  (e->caller->symbol.decl, gimple_bb (e->call_stmt));\n+\t\t\t  (e->caller->decl, gimple_bb (e->call_stmt));\n \t}\n       /* Expand speculation into GIMPLE code.  */\n       else\n@@ -1346,12 +1346,12 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n \t\t     \"Expanding speculative call of %s/%i -> %s/%i count:\"\n \t\t     HOST_WIDEST_INT_PRINT_DEC\"\\n\",\n \t\t     xstrdup (cgraph_node_name (e->caller)),\n-\t\t     e->caller->symbol.order,\n+\t\t     e->caller->order,\n \t\t     xstrdup (cgraph_node_name (e->callee)),\n-\t\t     e->callee->symbol.order,\n+\t\t     e->callee->order,\n \t\t     (HOST_WIDEST_INT)e->count);\n \t  gcc_assert (e2->speculative);\n-\t  push_cfun (DECL_STRUCT_FUNCTION (e->caller->symbol.decl));\n+\t  push_cfun (DECL_STRUCT_FUNCTION (e->caller->decl));\n \t  new_stmt = gimple_ic (e->call_stmt, cgraph (ref->referred),\n \t\t\t\te->count || e2->count\n \t\t\t\t?  RDIV (e->count * REG_BR_PROB_BASE,\n@@ -1365,9 +1365,9 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n \t  cgraph_set_call_stmt_including_clones (e->caller, e->call_stmt,\n \t\t\t\t\t\t new_stmt, false);\n \t  e->frequency = compute_call_stmt_bb_frequency\n-\t\t\t   (e->caller->symbol.decl, gimple_bb (e->call_stmt));\n+\t\t\t   (e->caller->decl, gimple_bb (e->call_stmt));\n \t  e2->frequency = compute_call_stmt_bb_frequency\n-\t\t\t   (e2->caller->symbol.decl, gimple_bb (e2->call_stmt));\n+\t\t\t   (e2->caller->decl, gimple_bb (e2->call_stmt));\n \t  e2->speculative = false;\n \t  ref->speculative = false;\n \t  ref->stmt = NULL;\n@@ -1381,7 +1381,7 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n     }\n \n   if (e->indirect_unknown_callee\n-      || decl == e->callee->symbol.decl)\n+      || decl == e->callee->decl)\n     return e->call_stmt;\n \n #ifdef ENABLE_CHECKING\n@@ -1395,8 +1395,8 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"updating call of %s/%i -> %s/%i: \",\n-\t       xstrdup (cgraph_node_name (e->caller)), e->caller->symbol.order,\n-\t       xstrdup (cgraph_node_name (e->callee)), e->callee->symbol.order);\n+\t       xstrdup (cgraph_node_name (e->caller)), e->caller->order,\n+\t       xstrdup (cgraph_node_name (e->callee)), e->callee->order);\n       print_gimple_stmt (cgraph_dump_file, e->call_stmt, 0, dump_flags);\n       if (e->callee->clone.combined_args_to_skip)\n \t{\n@@ -1413,7 +1413,7 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n       new_stmt\n \t= gimple_call_copy_skip_args (e->call_stmt,\n \t\t\t\t      e->callee->clone.combined_args_to_skip);\n-      gimple_call_set_fndecl (new_stmt, e->callee->symbol.decl);\n+      gimple_call_set_fndecl (new_stmt, e->callee->decl);\n       gimple_call_set_fntype (new_stmt, gimple_call_fntype (e->call_stmt));\n \n       if (gimple_vdef (new_stmt)\n@@ -1436,7 +1436,7 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n   else\n     {\n       new_stmt = e->call_stmt;\n-      gimple_call_set_fndecl (new_stmt, e->callee->symbol.decl);\n+      gimple_call_set_fndecl (new_stmt, e->callee->decl);\n       update_stmt (new_stmt);\n     }\n \n@@ -1486,7 +1486,7 @@ cgraph_update_edges_for_call_stmt_node (struct cgraph_node *node,\n \t      struct cgraph_node *callee = e->callee;\n \t      while (callee)\n \t\t{\n-\t\t  if (callee->symbol.decl == new_call\n+\t\t  if (callee->decl == new_call\n \t\t      || callee->former_clone_of == new_call)\n \t\t    return;\n \t\t  callee = callee->clone_of;\n@@ -1659,17 +1659,17 @@ cgraph_release_function_body (struct cgraph_node *node)\n   node->ipa_transforms_to_apply.release ();\n   if (!node->used_as_abstract_origin && cgraph_state != CGRAPH_STATE_PARSING)\n     {\n-      DECL_RESULT (node->symbol.decl) = NULL;\n-      DECL_ARGUMENTS (node->symbol.decl) = NULL;\n+      DECL_RESULT (node->decl) = NULL;\n+      DECL_ARGUMENTS (node->decl) = NULL;\n     }\n   /* If the node is abstract and needed, then do not clear DECL_INITIAL\n      of its associated function function declaration because it's\n      needed to emit debug info later.  */\n-  if (!node->used_as_abstract_origin && DECL_INITIAL (node->symbol.decl))\n-    DECL_INITIAL (node->symbol.decl) = error_mark_node;\n-  release_function_body (node->symbol.decl);\n-  if (node->symbol.lto_file_data)\n-    lto_free_function_in_decl_state_for_node ((symtab_node) node);\n+  if (!node->used_as_abstract_origin && DECL_INITIAL (node->decl))\n+    DECL_INITIAL (node->decl) = error_mark_node;\n+  release_function_body (node->decl);\n+  if (node->lto_file_data)\n+    lto_free_function_in_decl_state_for_node (node);\n }\n \n /* Remove the node from cgraph.  */\n@@ -1687,8 +1687,8 @@ cgraph_remove_node (struct cgraph_node *node)\n \n   /* Incremental inlining access removed nodes stored in the postorder list.\n      */\n-  node->symbol.force_output = false;\n-  node->symbol.forced_by_abi = false;\n+  node->force_output = false;\n+  node->forced_by_abi = false;\n   for (n = node->nested; n; n = n->next_nested)\n     n->origin = NULL;\n   node->nested = NULL;\n@@ -1700,7 +1700,7 @@ cgraph_remove_node (struct cgraph_node *node)\n \tnode2 = &(*node2)->next_nested;\n       *node2 = node->next_nested;\n     }\n-  symtab_unregister_node ((symtab_node)node);\n+  symtab_unregister_node (node);\n   if (node->prev_sibling_clone)\n     node->prev_sibling_clone->next_sibling_clone = node->next_sibling_clone;\n   else if (node->clone_of)\n@@ -1744,18 +1744,18 @@ cgraph_remove_node (struct cgraph_node *node)\n      */\n   if (cgraph_state != CGRAPH_LTO_STREAMING)\n     {\n-      n = cgraph_get_node (node->symbol.decl);\n+      n = cgraph_get_node (node->decl);\n       if (!n\n \t  || (!n->clones && !n->clone_of && !n->global.inlined_to\n \t      && (cgraph_global_info_ready\n-\t\t  && (TREE_ASM_WRITTEN (n->symbol.decl)\n-\t\t      || DECL_EXTERNAL (n->symbol.decl)\n-\t\t      || !n->symbol.analyzed\n-\t\t      || (!flag_wpa && n->symbol.in_other_partition)))))\n+\t\t  && (TREE_ASM_WRITTEN (n->decl)\n+\t\t      || DECL_EXTERNAL (n->decl)\n+\t\t      || !n->analyzed\n+\t\t      || (!flag_wpa && n->in_other_partition)))))\n \tcgraph_release_function_body (node);\n     }\n \n-  node->symbol.decl = NULL;\n+  node->decl = NULL;\n   if (node->call_site_hash)\n     {\n       htab_delete (node->call_site_hash);\n@@ -1766,7 +1766,7 @@ cgraph_remove_node (struct cgraph_node *node)\n   /* Clear out the node to NULL all pointers and add the node to the free\n      list.  */\n   memset (node, 0, sizeof (*node));\n-  node->symbol.type = SYMTAB_FUNCTION;\n+  node->type = SYMTAB_FUNCTION;\n   node->uid = uid;\n   SET_NEXT_FREE_NODE (node, free_nodes);\n   free_nodes = node;\n@@ -1791,9 +1791,9 @@ cgraph_mark_address_taken_node (struct cgraph_node *node)\n      of the object was taken (and thus it should be set on node alias is\n      referring to).  We should remove the first use and the remove the\n      following set.  */\n-  node->symbol.address_taken = 1;\n+  node->address_taken = 1;\n   node = cgraph_function_or_thunk_node (node, NULL);\n-  node->symbol.address_taken = 1;\n+  node->address_taken = 1;\n }\n \n /* Return local info for the compiled function.  */\n@@ -1835,7 +1835,7 @@ cgraph_rtl_info (tree decl)\n   node = cgraph_get_node (decl);\n   if (!node\n       || (decl != current_function_decl\n-\t  && !TREE_ASM_WRITTEN (node->symbol.decl)))\n+\t  && !TREE_ASM_WRITTEN (node->decl)))\n     return NULL;\n   return &node->rtl;\n }\n@@ -1871,18 +1871,18 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n   struct cgraph_edge *edge;\n   int indirect_calls_count = 0;\n \n-  dump_symtab_base (f, (symtab_node) node);\n+  dump_symtab_base (f, node);\n \n   if (node->global.inlined_to)\n     fprintf (f, \"  Function %s/%i is inline copy in %s/%i\\n\",\n \t     xstrdup (cgraph_node_name (node)),\n-\t     node->symbol.order,\n+\t     node->order,\n \t     xstrdup (cgraph_node_name (node->global.inlined_to)),\n-\t     node->global.inlined_to->symbol.order);\n+\t     node->global.inlined_to->order);\n   if (node->clone_of)\n     fprintf (f, \"  Clone of %s/%i\\n\",\n \t     cgraph_node_asm_name (node->clone_of),\n-\t     node->clone_of->symbol.order);\n+\t     node->clone_of->order);\n   if (cgraph_function_flags_ready)\n     fprintf (f, \"  Availability: %s\\n\",\n \t     cgraph_availability_names [cgraph_function_body_availability (node)]);\n@@ -1896,7 +1896,7 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \t     (HOST_WIDEST_INT)node->count);\n   if (node->origin)\n     fprintf (f, \" nested in: %s\", cgraph_node_asm_name (node->origin));\n-  if (gimple_has_body_p (node->symbol.decl))\n+  if (gimple_has_body_p (node->decl))\n     fprintf (f, \" body\");\n   if (node->process)\n     fprintf (f, \" process\");\n@@ -1926,7 +1926,7 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \t       (int)node->thunk.virtual_value,\n \t       (int)node->thunk.virtual_offset_p);\n     }\n-  if (node->symbol.alias && node->thunk.alias\n+  if (node->alias && node->thunk.alias\n       && DECL_P (node->thunk.alias))\n     {\n       fprintf (f, \"  Alias of %s\",\n@@ -1942,7 +1942,7 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n   for (edge = node->callers; edge; edge = edge->next_caller)\n     {\n       fprintf (f, \"%s/%i \", cgraph_node_asm_name (edge->caller),\n-\t       edge->caller->symbol.order);\n+\t       edge->caller->order);\n       if (edge->count)\n \tfprintf (f, \"(\"HOST_WIDEST_INT_PRINT_DEC\"x) \",\n \t\t (HOST_WIDEST_INT)edge->count);\n@@ -1963,7 +1963,7 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n   for (edge = node->callees; edge; edge = edge->next_callee)\n     {\n       fprintf (f, \"%s/%i \", cgraph_node_asm_name (edge->callee),\n-\t       edge->callee->symbol.order);\n+\t       edge->callee->order);\n       if (edge->speculative)\n \tfprintf (f, \"(speculative) \");\n       if (!edge->inline_failed)\n@@ -2047,20 +2047,20 @@ enum availability\n cgraph_function_body_availability (struct cgraph_node *node)\n {\n   enum availability avail;\n-  if (!node->symbol.analyzed)\n+  if (!node->analyzed)\n     avail = AVAIL_NOT_AVAILABLE;\n   else if (node->local.local)\n     avail = AVAIL_LOCAL;\n-  else if (node->symbol.alias && node->symbol.weakref)\n+  else if (node->alias && node->weakref)\n     cgraph_function_or_thunk_node (node, &avail);\n-  else if (lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (node->symbol.decl)))\n+  else if (lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (node->decl)))\n     avail = AVAIL_OVERWRITABLE;\n-  else if (!node->symbol.externally_visible)\n+  else if (!node->externally_visible)\n     avail = AVAIL_AVAILABLE;\n   /* Inline functions are safe to be analyzed even if their symbol can\n      be overwritten at runtime.  It is not meaningful to enforce any sane\n      behaviour on replacing inline function by different body.  */\n-  else if (DECL_DECLARED_INLINE_P (node->symbol.decl))\n+  else if (DECL_DECLARED_INLINE_P (node->decl))\n     avail = AVAIL_AVAILABLE;\n \n   /* If the function can be overwritten, return OVERWRITABLE.  Take\n@@ -2073,8 +2073,8 @@ cgraph_function_body_availability (struct cgraph_node *node)\n      AVAIL_AVAILABLE here?  That would be good reason to preserve this\n      bit.  */\n \n-  else if (decl_replaceable_p (node->symbol.decl)\n-\t   && !DECL_EXTERNAL (node->symbol.decl))\n+  else if (decl_replaceable_p (node->decl)\n+\t   && !DECL_EXTERNAL (node->decl))\n     avail = AVAIL_OVERWRITABLE;\n   else avail = AVAIL_AVAILABLE;\n \n@@ -2086,12 +2086,12 @@ static bool\n cgraph_node_cannot_be_local_p_1 (struct cgraph_node *node,\n \t\t\t\t void *data ATTRIBUTE_UNUSED)\n {\n-  return !(!node->symbol.force_output\n-\t   && ((DECL_COMDAT (node->symbol.decl)\n-\t\t&& !node->symbol.forced_by_abi\n-\t        && !symtab_used_from_object_file_p ((symtab_node) node)\n-\t\t&& !node->symbol.same_comdat_group)\n-\t       || !node->symbol.externally_visible));\n+  return !(!node->force_output\n+\t   && ((DECL_COMDAT (node->decl)\n+\t\t&& !node->forced_by_abi\n+\t        && !symtab_used_from_object_file_p (node)\n+\t\t&& !node->same_comdat_group)\n+\t       || !node->externally_visible));\n }\n \n /* Return true if NODE can be made local for API change.\n@@ -2101,7 +2101,7 @@ cgraph_node_cannot_be_local_p_1 (struct cgraph_node *node,\n bool\n cgraph_node_can_be_local_p (struct cgraph_node *node)\n {\n-  return (!node->symbol.address_taken\n+  return (!node->address_taken\n \t  && !cgraph_for_node_and_aliases (node,\n \t\t\t\t\t   cgraph_node_cannot_be_local_p_1,\n \t\t\t\t\t   NULL, true));\n@@ -2130,7 +2130,7 @@ cgraph_for_node_thunks_and_aliases (struct cgraph_node *node,\n       if (cgraph_for_node_thunks_and_aliases (e->caller, callback, data,\n \t\t\t\t\t      include_overwritable))\n \treturn true;\n-  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list, i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n \tstruct cgraph_node *alias = ipa_ref_referring_node (ref);\n@@ -2158,7 +2158,7 @@ cgraph_for_node_and_aliases (struct cgraph_node *node,\n \n   if (callback (node, data))\n     return true;\n-  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list, i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n \tstruct cgraph_node *alias = ipa_ref_referring_node (ref);\n@@ -2177,16 +2177,16 @@ static bool\n cgraph_make_node_local_1 (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n {\n   gcc_checking_assert (cgraph_node_can_be_local_p (node));\n-  if (DECL_COMDAT (node->symbol.decl) || DECL_EXTERNAL (node->symbol.decl))\n+  if (DECL_COMDAT (node->decl) || DECL_EXTERNAL (node->decl))\n     {\n-      symtab_make_decl_local (node->symbol.decl);\n+      symtab_make_decl_local (node->decl);\n \n-      node->symbol.externally_visible = false;\n-      node->symbol.forced_by_abi = false;\n+      node->externally_visible = false;\n+      node->forced_by_abi = false;\n       node->local.local = true;\n-      node->symbol.unique_name = (node->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t\t\t  || node->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY_EXP);\n-      node->symbol.resolution = LDPR_PREVAILING_DEF_IRONLY;\n+      node->unique_name = (node->resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t\t\t\t  || node->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP);\n+      node->resolution = LDPR_PREVAILING_DEF_IRONLY;\n       gcc_assert (cgraph_function_body_availability (node) == AVAIL_LOCAL);\n     }\n   return false;\n@@ -2208,7 +2208,7 @@ cgraph_set_nothrow_flag_1 (struct cgraph_node *node, void *data)\n {\n   struct cgraph_edge *e;\n \n-  TREE_NOTHROW (node->symbol.decl) = data != NULL;\n+  TREE_NOTHROW (node->decl) = data != NULL;\n \n   if (data != NULL)\n     for (e = node->callers; e; e = e->next_caller)\n@@ -2235,13 +2235,13 @@ cgraph_set_const_flag_1 (struct cgraph_node *node, void *data)\n      optimized out.  */\n   if (data && !((size_t)data & 2))\n     {\n-      if (DECL_STATIC_CONSTRUCTOR (node->symbol.decl))\n-\tDECL_STATIC_CONSTRUCTOR (node->symbol.decl) = 0;\n-      if (DECL_STATIC_DESTRUCTOR (node->symbol.decl))\n-\tDECL_STATIC_DESTRUCTOR (node->symbol.decl) = 0;\n+      if (DECL_STATIC_CONSTRUCTOR (node->decl))\n+\tDECL_STATIC_CONSTRUCTOR (node->decl) = 0;\n+      if (DECL_STATIC_DESTRUCTOR (node->decl))\n+\tDECL_STATIC_DESTRUCTOR (node->decl) = 0;\n     }\n-  TREE_READONLY (node->symbol.decl) = data != NULL;\n-  DECL_LOOPING_CONST_OR_PURE_P (node->symbol.decl) = ((size_t)data & 2) != 0;\n+  TREE_READONLY (node->decl) = data != NULL;\n+  DECL_LOOPING_CONST_OR_PURE_P (node->decl) = ((size_t)data & 2) != 0;\n   return false;\n }\n \n@@ -2265,13 +2265,13 @@ cgraph_set_pure_flag_1 (struct cgraph_node *node, void *data)\n      optimized out.  */\n   if (data && !((size_t)data & 2))\n     {\n-      if (DECL_STATIC_CONSTRUCTOR (node->symbol.decl))\n-\tDECL_STATIC_CONSTRUCTOR (node->symbol.decl) = 0;\n-      if (DECL_STATIC_DESTRUCTOR (node->symbol.decl))\n-\tDECL_STATIC_DESTRUCTOR (node->symbol.decl) = 0;\n+      if (DECL_STATIC_CONSTRUCTOR (node->decl))\n+\tDECL_STATIC_CONSTRUCTOR (node->decl) = 0;\n+      if (DECL_STATIC_DESTRUCTOR (node->decl))\n+\tDECL_STATIC_DESTRUCTOR (node->decl) = 0;\n     }\n-  DECL_PURE_P (node->symbol.decl) = data != NULL;\n-  DECL_LOOPING_CONST_OR_PURE_P (node->symbol.decl) = ((size_t)data & 2) != 0;\n+  DECL_PURE_P (node->decl) = data != NULL;\n+  DECL_LOOPING_CONST_OR_PURE_P (node->decl) = ((size_t)data & 2) != 0;\n   return false;\n }\n \n@@ -2292,7 +2292,7 @@ cgraph_set_pure_flag (struct cgraph_node *node, bool pure, bool looping)\n bool\n cgraph_node_cannot_return (struct cgraph_node *node)\n {\n-  int flags = flags_from_decl_or_type (node->symbol.decl);\n+  int flags = flags_from_decl_or_type (node->decl);\n   if (!flag_exceptions)\n     return (flags & ECF_NORETURN) != 0;\n   else\n@@ -2331,19 +2331,19 @@ cgraph_can_remove_if_no_direct_calls_and_refs_p (struct cgraph_node *node)\n {\n   gcc_assert (!node->global.inlined_to);\n   /* Extern inlines can always go, we will use the external definition.  */\n-  if (DECL_EXTERNAL (node->symbol.decl))\n+  if (DECL_EXTERNAL (node->decl))\n     return true;\n   /* When function is needed, we can not remove it.  */\n-  if (node->symbol.force_output || node->symbol.used_from_other_partition)\n+  if (node->force_output || node->used_from_other_partition)\n     return false;\n-  if (DECL_STATIC_CONSTRUCTOR (node->symbol.decl)\n-      || DECL_STATIC_DESTRUCTOR (node->symbol.decl))\n+  if (DECL_STATIC_CONSTRUCTOR (node->decl)\n+      || DECL_STATIC_DESTRUCTOR (node->decl))\n     return false;\n   /* Only COMDAT functions can be removed if externally visible.  */\n-  if (node->symbol.externally_visible\n-      && (!DECL_COMDAT (node->symbol.decl)\n-\t  || node->symbol.forced_by_abi\n-\t  || symtab_used_from_object_file_p ((symtab_node) node)))\n+  if (node->externally_visible\n+      && (!DECL_COMDAT (node->decl)\n+\t  || node->forced_by_abi\n+\t  || symtab_used_from_object_file_p (node)))\n     return false;\n   return true;\n }\n@@ -2363,9 +2363,9 @@ bool\n cgraph_can_remove_if_no_direct_calls_p (struct cgraph_node *node)\n {\n   /* Extern inlines can always go, we will use the external definition.  */\n-  if (DECL_EXTERNAL (node->symbol.decl))\n+  if (DECL_EXTERNAL (node->decl))\n     return true;\n-  if (node->symbol.address_taken)\n+  if (node->address_taken)\n     return false;\n   return !cgraph_for_node_and_aliases (node, nonremovable_p, NULL, true);\n }\n@@ -2375,7 +2375,7 @@ cgraph_can_remove_if_no_direct_calls_p (struct cgraph_node *node)\n static bool\n used_from_object_file_p (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n {\n-  return symtab_used_from_object_file_p ((symtab_node) node);\n+  return symtab_used_from_object_file_p (node);\n }\n \n /* Return true when function NODE can be expected to be removed\n@@ -2402,7 +2402,7 @@ cgraph_will_be_removed_from_program_if_no_direct_calls (struct cgraph_node *node\n     return cgraph_only_called_directly_p (node);\n   else\n     {\n-       if (DECL_EXTERNAL (node->symbol.decl))\n+       if (DECL_EXTERNAL (node->decl))\n          return true;\n       return cgraph_can_remove_if_no_direct_calls_p (node);\n     }\n@@ -2492,7 +2492,7 @@ verify_edge_count_and_frequency (struct cgraph_edge *e)\n       error (\"caller edge frequency is too large\");\n       error_found = true;\n     }\n-  if (gimple_has_body_p (e->caller->symbol.decl)\n+  if (gimple_has_body_p (e->caller->decl)\n       && !e->caller->global.inlined_to\n       && !e->speculative\n       /* FIXME: Inline-analysis sets frequency to 0 when edge is optimized out.\n@@ -2502,12 +2502,12 @@ verify_edge_count_and_frequency (struct cgraph_edge *e)\n \t      && ((inline_edge_summary_vec.length () <= (unsigned) e->uid)\n \t          || !inline_edge_summary (e)->predicate)))\n       && (e->frequency\n-\t  != compute_call_stmt_bb_frequency (e->caller->symbol.decl,\n+\t  != compute_call_stmt_bb_frequency (e->caller->decl,\n \t\t\t\t\t     gimple_bb (e->call_stmt))))\n     {\n       error (\"caller edge frequency %i does not match BB frequency %i\",\n \t     e->frequency,\n-\t     compute_call_stmt_bb_frequency (e->caller->symbol.decl,\n+\t     compute_call_stmt_bb_frequency (e->caller->decl,\n \t\t\t\t\t     gimple_bb (e->call_stmt)));\n       error_found = true;\n     }\n@@ -2549,11 +2549,11 @@ verify_edge_corresponds_to_fndecl (struct cgraph_edge *e, tree decl)\n \n   /* We do not know if a node from a different partition is an alias or what it\n      aliases and therefore cannot do the former_clone_of check reliably.  */\n-  if (!node || node->symbol.in_other_partition || e->callee->symbol.in_other_partition)\n+  if (!node || node->in_other_partition || e->callee->in_other_partition)\n     return false;\n   node = cgraph_function_or_thunk_node (node, NULL);\n \n-  if (e->callee->former_clone_of != node->symbol.decl\n+  if (e->callee->former_clone_of != node->decl\n       /* IPA-CP sometimes redirect edge to clone and then back to the former\n \t function.  This ping-pong has to go, eventually.  */\n       && (node != cgraph_function_or_thunk_node (e->callee, NULL))\n@@ -2568,7 +2568,7 @@ DEBUG_FUNCTION void\n verify_cgraph_node (struct cgraph_node *node)\n {\n   struct cgraph_edge *e;\n-  struct function *this_cfun = DECL_STRUCT_FUNCTION (node->symbol.decl);\n+  struct function *this_cfun = DECL_STRUCT_FUNCTION (node->decl);\n   basic_block this_block;\n   gimple_stmt_iterator gsi;\n   bool error_found = false;\n@@ -2577,7 +2577,7 @@ verify_cgraph_node (struct cgraph_node *node)\n     return;\n \n   timevar_push (TV_CGRAPH_VERIFY);\n-  error_found |= verify_symtab_base ((symtab_node) node);\n+  error_found |= verify_symtab_base (node);\n   for (e = node->callees; e; e = e->next_callee)\n     if (e->aux)\n       {\n@@ -2591,27 +2591,27 @@ verify_cgraph_node (struct cgraph_node *node)\n       error (\"execution count is negative\");\n       error_found = true;\n     }\n-  if (node->global.inlined_to && node->symbol.same_comdat_group)\n+  if (node->global.inlined_to && node->same_comdat_group)\n     {\n       error (\"inline clone in same comdat group list\");\n       error_found = true;\n     }\n-  if (!node->symbol.definition && !node->symbol.in_other_partition && node->local.local)\n+  if (!node->definition && !node->in_other_partition && node->local.local)\n     {\n       error (\"local symbols must be defined\");\n       error_found = true;\n     }\n-  if (node->global.inlined_to && node->symbol.externally_visible)\n+  if (node->global.inlined_to && node->externally_visible)\n     {\n       error (\"externally visible inline clone\");\n       error_found = true;\n     }\n-  if (node->global.inlined_to && node->symbol.address_taken)\n+  if (node->global.inlined_to && node->address_taken)\n     {\n       error (\"inline clone with address taken\");\n       error_found = true;\n     }\n-  if (node->global.inlined_to && node->symbol.force_output)\n+  if (node->global.inlined_to && node->force_output)\n     {\n       error (\"inline clone is forced to output\");\n       error_found = true;\n@@ -2714,7 +2714,7 @@ verify_cgraph_node (struct cgraph_node *node)\n       error_found = true;\n     }\n \n-  if (node->symbol.analyzed && node->symbol.alias)\n+  if (node->analyzed && node->alias)\n     {\n       bool ref_found = false;\n       int i;\n@@ -2725,7 +2725,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t  error (\"Alias has call edges\");\n           error_found = true;\n \t}\n-      for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list,\n+      for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list,\n \t\t\t\t\t\t  i, ref); i++)\n \tif (ref->use != IPA_REF_ALIAS)\n \t  {\n@@ -2745,7 +2745,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t    error_found = true;\n \t  }\n     }\n-  if (node->symbol.analyzed && node->thunk.thunk_p)\n+  if (node->analyzed && node->thunk.thunk_p)\n     {\n       if (!node->callees)\n \t{\n@@ -2757,15 +2757,15 @@ verify_cgraph_node (struct cgraph_node *node)\n \t  error (\"More than one edge out of thunk node\");\n           error_found = true;\n \t}\n-      if (gimple_has_body_p (node->symbol.decl))\n+      if (gimple_has_body_p (node->decl))\n         {\n \t  error (\"Thunk is not supposed to have body\");\n           error_found = true;\n         }\n     }\n-  else if (node->symbol.analyzed && gimple_has_body_p (node->symbol.decl)\n-           && !TREE_ASM_WRITTEN (node->symbol.decl)\n-           && (!DECL_EXTERNAL (node->symbol.decl) || node->global.inlined_to)\n+  else if (node->analyzed && gimple_has_body_p (node->decl)\n+           && !TREE_ASM_WRITTEN (node->decl)\n+           && (!DECL_EXTERNAL (node->decl) || node->global.inlined_to)\n            && !flag_wpa)\n     {\n       if (this_cfun->cfg)\n@@ -2804,7 +2804,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t\t      if (verify_edge_corresponds_to_fndecl (e, decl))\n \t\t\t\t{\n \t\t\t\t  error (\"edge points to wrong declaration:\");\n-\t\t\t\t  debug_tree (e->callee->symbol.decl);\n+\t\t\t\t  debug_tree (e->callee->decl);\n \t\t\t\t  fprintf (stderr,\" Instead of:\");\n \t\t\t\t  debug_tree (decl);\n \t\t\t\t  error_found = true;\n@@ -2830,7 +2830,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t}\n \t      }\n \t    for (i = 0;\n-\t\t ipa_ref_list_reference_iterate (&node->symbol.ref_list, i, ref);\n+\t\t ipa_ref_list_reference_iterate (&node->ref_list, i, ref);\n \t\t i++)\n \t      if (ref->stmt && !pointer_set_contains (stmts, ref->stmt))\n \t\t{\n@@ -2919,17 +2919,17 @@ cgraph_get_create_real_symbol_node (tree decl)\n     {\n       first_clone->clone_of = node;\n       node->clones = first_clone;\n-      symtab_prevail_in_asm_name_hash ((symtab_node) node);\n-      symtab_insert_node_to_hashtable ((symtab_node) node);\n+      symtab_prevail_in_asm_name_hash (node);\n+      symtab_insert_node_to_hashtable (node);\n       if (dump_file)\n \tfprintf (dump_file, \"Introduced new external node \"\n \t\t \"(%s/%i) and turned into root of the clone tree.\\n\",\n-\t\t xstrdup (cgraph_node_name (node)), node->symbol.order);\n+\t\t xstrdup (cgraph_node_name (node)), node->order);\n     }\n   else if (dump_file)\n     fprintf (dump_file, \"Introduced new external node \"\n \t     \"(%s/%i).\\n\", xstrdup (cgraph_node_name (node)),\n-\t     node->symbol.order);\n+\t     node->order);\n   return node;\n }\n \n@@ -2968,14 +2968,14 @@ cgraph_get_body (struct cgraph_node *node)\n   struct lto_file_decl_data *file_data;\n   const char *data, *name;\n   size_t len;\n-  tree decl = node->symbol.decl;\n+  tree decl = node->decl;\n \n   if (DECL_RESULT (decl))\n     return false;\n \n   gcc_assert (in_lto_p);\n \n-  file_data = node->symbol.lto_file_data;\n+  file_data = node->lto_file_data;\n   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n \n   /* We may have renamed the declaration, e.g., a static function.  */\n@@ -2997,7 +2997,7 @@ cgraph_get_body (struct cgraph_node *node)\n   lto_stats.num_function_bodies++;\n   lto_free_section_data (file_data, LTO_section_function_body, name,\n \t\t\t data, len);\n-  lto_free_function_in_decl_state_for_node ((symtab_node) node);\n+  lto_free_function_in_decl_state_for_node (node);\n   return true;\n }\n "}, {"sha": "9171a79a8f776e8718b76526438b61ee604f84c5", "filename": "gcc/cgraph.h", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -538,7 +538,7 @@ template <>\n inline bool\n is_a_helper <cgraph_node>::test (symtab_node_base *p)\n {\n-  return p->symbol.type == SYMTAB_FUNCTION;\n+  return p->type == SYMTAB_FUNCTION;\n }\n \n /* Report whether or not THIS symtab node is a vriable, aka varpool_node.  */\n@@ -548,7 +548,7 @@ template <>\n inline bool\n is_a_helper <varpool_node>::test (symtab_node_base *p)\n {\n-  return p->symbol.type == SYMTAB_VARIABLE;\n+  return p->type == SYMTAB_VARIABLE;\n }\n \n extern GTY(()) symtab_node symtab_nodes;\n@@ -850,15 +850,15 @@ void varpool_remove_initializer (struct varpool_node *);\n static inline struct cgraph_node *\n cgraph (symtab_node node)\n {\n-  gcc_checking_assert (!node || node->symbol.type == SYMTAB_FUNCTION);\n+  gcc_checking_assert (!node || node->type == SYMTAB_FUNCTION);\n   return (struct cgraph_node *)node;\n }\n \n /* Return varpool node for given symbol and check it is a variable.  */\n static inline struct varpool_node *\n varpool (symtab_node node)\n {\n-  gcc_checking_assert (!node || node->symbol.type == SYMTAB_VARIABLE);\n+  gcc_checking_assert (!node || node->type == SYMTAB_VARIABLE);\n   return (struct varpool_node *)node;\n }\n \n@@ -882,41 +882,41 @@ varpool_get_node (const_tree decl)\n static inline const char *\n cgraph_node_asm_name (struct cgraph_node *node)\n {\n-  return symtab_node_asm_name ((symtab_node)node);\n+  return symtab_node_asm_name (node);\n }\n \n /* Return asm name of varpool node.  */\n static inline const char *\n varpool_node_asm_name (struct varpool_node *node)\n {\n-  return symtab_node_asm_name ((symtab_node)node);\n+  return symtab_node_asm_name (node);\n }\n \n /* Return name of cgraph node.  */\n static inline const char *\n cgraph_node_name (struct cgraph_node *node)\n {\n-  return symtab_node_name ((symtab_node)node);\n+  return symtab_node_name (node);\n }\n \n /* Return name of varpool node.  */\n static inline const char *\n varpool_node_name (struct varpool_node *node)\n {\n-  return symtab_node_name ((symtab_node)node);\n+  return symtab_node_name (node);\n }\n \n /* Walk all symbols.  */\n #define FOR_EACH_SYMBOL(node) \\\n-   for ((node) = symtab_nodes; (node); (node) = (node)->symbol.next)\n+   for ((node) = symtab_nodes; (node); (node) = (node)->next)\n \n \n /* Return first variable.  */\n static inline struct varpool_node *\n varpool_first_variable (void)\n {\n   symtab_node node;\n-  for (node = symtab_nodes; node; node = node->symbol.next)\n+  for (node = symtab_nodes; node; node = node->next)\n     if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n       return vnode;\n   return NULL;\n@@ -926,8 +926,8 @@ varpool_first_variable (void)\n static inline struct varpool_node *\n varpool_next_variable (struct varpool_node *node)\n {\n-  symtab_node node1 = (symtab_node) node->symbol.next;\n-  for (; node1; node1 = node1->symbol.next)\n+  symtab_node node1 = node->next;\n+  for (; node1; node1 = node1->next)\n     if (varpool_node *vnode1 = dyn_cast <varpool_node> (node1))\n       return vnode1;\n   return NULL;\n@@ -943,10 +943,10 @@ static inline struct varpool_node *\n varpool_first_static_initializer (void)\n {\n   symtab_node node;\n-  for (node = symtab_nodes; node; node = node->symbol.next)\n+  for (node = symtab_nodes; node; node = node->next)\n     {\n       varpool_node *vnode = dyn_cast <varpool_node> (node);\n-      if (vnode && DECL_INITIAL (node->symbol.decl))\n+      if (vnode && DECL_INITIAL (node->decl))\n \treturn vnode;\n     }\n   return NULL;\n@@ -956,11 +956,11 @@ varpool_first_static_initializer (void)\n static inline struct varpool_node *\n varpool_next_static_initializer (struct varpool_node *node)\n {\n-  symtab_node node1 = (symtab_node) node->symbol.next;\n-  for (; node1; node1 = node1->symbol.next)\n+  symtab_node node1 = node->next;\n+  for (; node1; node1 = node1->next)\n     {\n       varpool_node *vnode1 = dyn_cast <varpool_node> (node1);\n-      if (vnode1 && DECL_INITIAL (node1->symbol.decl))\n+      if (vnode1 && DECL_INITIAL (node1->decl))\n \treturn vnode1;\n     }\n   return NULL;\n@@ -976,10 +976,10 @@ static inline struct varpool_node *\n varpool_first_defined_variable (void)\n {\n   symtab_node node;\n-  for (node = symtab_nodes; node; node = node->symbol.next)\n+  for (node = symtab_nodes; node; node = node->next)\n     {\n       varpool_node *vnode = dyn_cast <varpool_node> (node);\n-      if (vnode && vnode->symbol.definition)\n+      if (vnode && vnode->definition)\n \treturn vnode;\n     }\n   return NULL;\n@@ -989,11 +989,11 @@ varpool_first_defined_variable (void)\n static inline struct varpool_node *\n varpool_next_defined_variable (struct varpool_node *node)\n {\n-  symtab_node node1 = (symtab_node) node->symbol.next;\n-  for (; node1; node1 = node1->symbol.next)\n+  symtab_node node1 = node->next;\n+  for (; node1; node1 = node1->next)\n     {\n       varpool_node *vnode1 = dyn_cast <varpool_node> (node1);\n-      if (vnode1 && vnode1->symbol.definition)\n+      if (vnode1 && vnode1->definition)\n \treturn vnode1;\n     }\n   return NULL;\n@@ -1008,10 +1008,10 @@ static inline struct cgraph_node *\n cgraph_first_defined_function (void)\n {\n   symtab_node node;\n-  for (node = symtab_nodes; node; node = node->symbol.next)\n+  for (node = symtab_nodes; node; node = node->next)\n     {\n       cgraph_node *cn = dyn_cast <cgraph_node> (node);\n-      if (cn && cn->symbol.definition)\n+      if (cn && cn->definition)\n \treturn cn;\n     }\n   return NULL;\n@@ -1021,11 +1021,11 @@ cgraph_first_defined_function (void)\n static inline struct cgraph_node *\n cgraph_next_defined_function (struct cgraph_node *node)\n {\n-  symtab_node node1 = (symtab_node) node->symbol.next;\n-  for (; node1; node1 = node1->symbol.next)\n+  symtab_node node1 = node->next;\n+  for (; node1; node1 = node1->next)\n     {\n       cgraph_node *cn1 = dyn_cast <cgraph_node> (node1);\n-      if (cn1 && cn1->symbol.definition)\n+      if (cn1 && cn1->definition)\n \treturn cn1;\n     }\n   return NULL;\n@@ -1041,7 +1041,7 @@ static inline struct cgraph_node *\n cgraph_first_function (void)\n {\n   symtab_node node;\n-  for (node = symtab_nodes; node; node = node->symbol.next)\n+  for (node = symtab_nodes; node; node = node->next)\n     if (cgraph_node *cn = dyn_cast <cgraph_node> (node))\n       return cn;\n   return NULL;\n@@ -1051,8 +1051,8 @@ cgraph_first_function (void)\n static inline struct cgraph_node *\n cgraph_next_function (struct cgraph_node *node)\n {\n-  symtab_node node1 = (symtab_node) node->symbol.next;\n-  for (; node1; node1 = node1->symbol.next)\n+  symtab_node node1 = node->next;\n+  for (; node1; node1 = node1->next)\n     if (cgraph_node *cn1 = dyn_cast <cgraph_node> (node1))\n       return cn1;\n   return NULL;\n@@ -1071,15 +1071,15 @@ cgraph_next_function (struct cgraph_node *node)\n static inline bool\n cgraph_function_with_gimple_body_p (struct cgraph_node *node)\n {\n-  return node->symbol.definition && !node->thunk.thunk_p && !node->symbol.alias;\n+  return node->definition && !node->thunk.thunk_p && !node->alias;\n }\n \n /* Return first function with body defined.  */\n static inline struct cgraph_node *\n cgraph_first_function_with_gimple_body (void)\n {\n   symtab_node node;\n-  for (node = symtab_nodes; node; node = node->symbol.next)\n+  for (node = symtab_nodes; node; node = node->next)\n     {\n       cgraph_node *cn = dyn_cast <cgraph_node> (node);\n       if (cn && cgraph_function_with_gimple_body_p (cn))\n@@ -1092,8 +1092,8 @@ cgraph_first_function_with_gimple_body (void)\n static inline struct cgraph_node *\n cgraph_next_function_with_gimple_body (struct cgraph_node *node)\n {\n-  symtab_node node1 = node->symbol.next;\n-  for (; node1; node1 = node1->symbol.next)\n+  symtab_node node1 = node->next;\n+  for (; node1; node1 = node1->next)\n     {\n       cgraph_node *cn1 = dyn_cast <cgraph_node> (node1);\n       if (cn1 && cgraph_function_with_gimple_body_p (cn1))\n@@ -1245,12 +1245,12 @@ static inline bool\n cgraph_only_called_directly_or_aliased_p (struct cgraph_node *node)\n {\n   gcc_assert (!node->global.inlined_to);\n-  return (!node->symbol.force_output && !node->symbol.address_taken\n-\t  && !node->symbol.used_from_other_partition\n-\t  && !DECL_VIRTUAL_P (node->symbol.decl)\n-\t  && !DECL_STATIC_CONSTRUCTOR (node->symbol.decl)\n-\t  && !DECL_STATIC_DESTRUCTOR (node->symbol.decl)\n-\t  && !node->symbol.externally_visible);\n+  return (!node->force_output && !node->address_taken\n+\t  && !node->used_from_other_partition\n+\t  && !DECL_VIRTUAL_P (node->decl)\n+\t  && !DECL_STATIC_CONSTRUCTOR (node->decl)\n+\t  && !DECL_STATIC_DESTRUCTOR (node->decl)\n+\t  && !node->externally_visible);\n }\n \n /* Return true when function NODE can be removed from callgraph\n@@ -1259,14 +1259,14 @@ cgraph_only_called_directly_or_aliased_p (struct cgraph_node *node)\n static inline bool\n varpool_can_remove_if_no_refs (struct varpool_node *node)\n {\n-  if (DECL_EXTERNAL (node->symbol.decl))\n+  if (DECL_EXTERNAL (node->decl))\n     return true;\n-  return (!node->symbol.force_output && !node->symbol.used_from_other_partition\n-  \t  && ((DECL_COMDAT (node->symbol.decl)\n-\t       && !node->symbol.forced_by_abi\n-\t       && !symtab_used_from_object_file_p ((symtab_node) node))\n-\t      || !node->symbol.externally_visible\n-\t      || DECL_HAS_VALUE_EXPR_P (node->symbol.decl)));\n+  return (!node->force_output && !node->used_from_other_partition\n+  \t  && ((DECL_COMDAT (node->decl)\n+\t       && !node->forced_by_abi\n+\t       && !symtab_used_from_object_file_p (node))\n+\t      || !node->externally_visible\n+\t      || DECL_HAS_VALUE_EXPR_P (node->decl)));\n }\n \n /* Return true when all references to VNODE must be visible in ipa_ref_list.\n@@ -1277,10 +1277,10 @@ varpool_can_remove_if_no_refs (struct varpool_node *node)\n static inline bool\n varpool_all_refs_explicit_p (struct varpool_node *vnode)\n {\n-  return (vnode->symbol.definition\n-\t  && !vnode->symbol.externally_visible\n-\t  && !vnode->symbol.used_from_other_partition\n-\t  && !vnode->symbol.force_output);\n+  return (vnode->definition\n+\t  && !vnode->externally_visible\n+\t  && !vnode->used_from_other_partition\n+\t  && !vnode->force_output);\n }\n \n /* Constant pool accessor function.  */\n@@ -1295,21 +1295,21 @@ static inline symtab_node\n symtab_alias_target (symtab_node n)\n {\n   struct ipa_ref *ref;\n-  ipa_ref_list_reference_iterate (&n->symbol.ref_list, 0, ref);\n+  ipa_ref_list_reference_iterate (&n->ref_list, 0, ref);\n   gcc_checking_assert (ref->use == IPA_REF_ALIAS);\n   return ref->referred;\n }\n \n static inline struct cgraph_node *\n cgraph_alias_target (struct cgraph_node *n)\n {\n-  return dyn_cast <cgraph_node> (symtab_alias_target ((symtab_node) n));\n+  return dyn_cast <cgraph_node> (symtab_alias_target (n));\n }\n \n static inline struct varpool_node *\n varpool_alias_target (struct varpool_node *n)\n {\n-  return dyn_cast <varpool_node> (symtab_alias_target ((symtab_node) n));\n+  return dyn_cast <varpool_node> (symtab_alias_target (n));\n }\n \n /* Given NODE, walk the alias chain to return the function NODE is alias of.\n@@ -1322,7 +1322,7 @@ cgraph_function_or_thunk_node (struct cgraph_node *node,\n {\n   struct cgraph_node *n;\n \n-  n = dyn_cast <cgraph_node> (symtab_alias_ultimate_target ((symtab_node)node,\n+  n = dyn_cast <cgraph_node> (symtab_alias_ultimate_target (node,\n \t\t\t\t\t\t\t    availability));\n   if (!n && availability)\n     *availability = AVAIL_NOT_AVAILABLE;\n@@ -1338,7 +1338,7 @@ varpool_variable_node (struct varpool_node *node,\n {\n   struct varpool_node *n;\n \n-  n = dyn_cast <varpool_node> (symtab_alias_ultimate_target ((symtab_node)node,\n+  n = dyn_cast <varpool_node> (symtab_alias_ultimate_target (node,\n \t\t\t\t\t\t\t     availability));\n   if (!n && availability)\n     *availability = AVAIL_NOT_AVAILABLE;\n@@ -1351,9 +1351,9 @@ cgraph_edge_recursive_p (struct cgraph_edge *e)\n {\n   struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n   if (e->caller->global.inlined_to)\n-    return e->caller->global.inlined_to->symbol.decl == callee->symbol.decl;\n+    return e->caller->global.inlined_to->decl == callee->decl;\n   else\n-    return e->caller->symbol.decl == callee->symbol.decl;\n+    return e->caller->decl == callee->decl;\n }\n \n /* Return true if the TM_CLONE bit is set for a given FNDECL.  */\n@@ -1372,7 +1372,7 @@ decl_is_tm_clone (const_tree fndecl)\n static inline void\n cgraph_mark_force_output_node (struct cgraph_node *node)\n {\n-  node->symbol.force_output = 1;\n+  node->force_output = 1;\n   gcc_checking_assert (!node->global.inlined_to);\n }\n \n@@ -1384,7 +1384,7 @@ symtab_real_symbol_p (symtab_node node)\n {\n   struct cgraph_node *cnode;\n \n-  if (DECL_ABSTRACT (node->symbol.decl))\n+  if (DECL_ABSTRACT (node->decl))\n     return false;\n   if (!is_a <cgraph_node> (node))\n     return true;\n@@ -1399,10 +1399,10 @@ symtab_real_symbol_p (symtab_node node)\n static inline bool\n symtab_can_be_discarded (symtab_node node)\n {\n-  return (DECL_EXTERNAL (node->symbol.decl)\n-\t  || (DECL_ONE_ONLY (node->symbol.decl)\n-\t      && node->symbol.resolution != LDPR_PREVAILING_DEF\n-\t      && node->symbol.resolution != LDPR_PREVAILING_DEF_IRONLY\n-\t      && node->symbol.resolution != LDPR_PREVAILING_DEF_IRONLY_EXP));\n+  return (DECL_EXTERNAL (node->decl)\n+\t  || (DECL_ONE_ONLY (node->decl)\n+\t      && node->resolution != LDPR_PREVAILING_DEF\n+\t      && node->resolution != LDPR_PREVAILING_DEF_IRONLY\n+\t      && node->resolution != LDPR_PREVAILING_DEF_IRONLY_EXP));\n }\n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "1490cb7aa3e11143891f7dcc6f0226b8f2eefb16", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -74,16 +74,16 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n \t  struct cgraph_node *node = cgraph_get_create_real_symbol_node (decl);\n \t  if (!ctx->only_vars)\n \t    cgraph_mark_address_taken_node (node);\n-\t  ipa_record_reference ((symtab_node)ctx->varpool_node,\n-\t\t\t\t(symtab_node)node,\n+\t  ipa_record_reference (ctx->varpool_node,\n+\t\t\t\tnode,\n \t\t\t        IPA_REF_ADDR, NULL);\n \t}\n \n       if (TREE_CODE (decl) == VAR_DECL)\n \t{\n \t  struct varpool_node *vnode = varpool_node_for_decl (decl);\n-\t  ipa_record_reference ((symtab_node)ctx->varpool_node,\n-\t\t\t\t(symtab_node)vnode,\n+\t  ipa_record_reference (ctx->varpool_node,\n+\t\t\t\tvnode,\n \t\t\t\tIPA_REF_ADDR, NULL);\n \t}\n       *walk_subtrees = 0;\n@@ -121,8 +121,8 @@ record_type_list (struct cgraph_node *node, tree list)\n \t  if (TREE_CODE (type) == VAR_DECL)\n \t    {\n \t      struct varpool_node *vnode = varpool_node_for_decl (type);\n-\t      ipa_record_reference ((symtab_node)node,\n-\t\t\t\t    (symtab_node)vnode,\n+\t      ipa_record_reference (node,\n+\t\t\t\t    vnode,\n \t\t\t\t    IPA_REF_ADDR, NULL);\n \t    }\n \t}\n@@ -137,12 +137,12 @@ record_eh_tables (struct cgraph_node *node, struct function *fun)\n {\n   eh_region i;\n \n-  if (DECL_FUNCTION_PERSONALITY (node->symbol.decl))\n+  if (DECL_FUNCTION_PERSONALITY (node->decl))\n     {\n       struct cgraph_node *per_node;\n \n-      per_node = cgraph_get_create_real_symbol_node (DECL_FUNCTION_PERSONALITY (node->symbol.decl));\n-      ipa_record_reference ((symtab_node)node, (symtab_node)per_node, IPA_REF_ADDR, NULL);\n+      per_node = cgraph_get_create_real_symbol_node (DECL_FUNCTION_PERSONALITY (node->decl));\n+      ipa_record_reference (node, per_node, IPA_REF_ADDR, NULL);\n       cgraph_mark_address_taken_node (per_node);\n     }\n \n@@ -224,7 +224,7 @@ mark_address (gimple stmt, tree addr, void *data)\n       struct cgraph_node *node = cgraph_get_create_real_symbol_node (addr);\n       cgraph_mark_address_taken_node (node);\n       ipa_record_reference ((symtab_node)data,\n-\t\t\t    (symtab_node)node,\n+\t\t\t    node,\n \t\t\t    IPA_REF_ADDR, stmt);\n     }\n   else if (addr && TREE_CODE (addr) == VAR_DECL\n@@ -233,7 +233,7 @@ mark_address (gimple stmt, tree addr, void *data)\n       struct varpool_node *vnode = varpool_node_for_decl (addr);\n \n       ipa_record_reference ((symtab_node)data,\n-\t\t\t    (symtab_node)vnode,\n+\t\t\t    vnode,\n \t\t\t    IPA_REF_ADDR, stmt);\n     }\n \n@@ -253,7 +253,7 @@ mark_load (gimple stmt, tree t, void *data)\n       struct cgraph_node *node = cgraph_get_create_real_symbol_node (t);\n       cgraph_mark_address_taken_node (node);\n       ipa_record_reference ((symtab_node)data,\n-\t\t\t    (symtab_node)node,\n+\t\t\t    node,\n \t\t\t    IPA_REF_ADDR, stmt);\n     }\n   else if (t && TREE_CODE (t) == VAR_DECL\n@@ -262,7 +262,7 @@ mark_load (gimple stmt, tree t, void *data)\n       struct varpool_node *vnode = varpool_node_for_decl (t);\n \n       ipa_record_reference ((symtab_node)data,\n-\t\t\t    (symtab_node)vnode,\n+\t\t\t    vnode,\n \t\t\t    IPA_REF_LOAD, stmt);\n     }\n   return false;\n@@ -280,7 +280,7 @@ mark_store (gimple stmt, tree t, void *data)\n       struct varpool_node *vnode = varpool_node_for_decl (t);\n \n       ipa_record_reference ((symtab_node)data,\n-\t\t\t    (symtab_node)vnode,\n+\t\t\t    vnode,\n \t\t\t    IPA_REF_STORE, stmt);\n      }\n   return false;\n@@ -337,21 +337,21 @@ build_cgraph_edges (void)\n \t      && gimple_omp_parallel_child_fn (stmt))\n \t    {\n \t      tree fn = gimple_omp_parallel_child_fn (stmt);\n-\t      ipa_record_reference ((symtab_node)node,\n-\t\t\t\t    (symtab_node)cgraph_get_create_real_symbol_node (fn),\n+\t      ipa_record_reference (node,\n+\t\t\t\t    cgraph_get_create_real_symbol_node (fn),\n \t\t\t\t    IPA_REF_ADDR, stmt);\n \t    }\n \t  if (gimple_code (stmt) == GIMPLE_OMP_TASK)\n \t    {\n \t      tree fn = gimple_omp_task_child_fn (stmt);\n \t      if (fn)\n-\t\tipa_record_reference ((symtab_node)node,\n-\t\t\t\t      (symtab_node) cgraph_get_create_real_symbol_node (fn),\n+\t\tipa_record_reference (node,\n+\t\t\t\t      cgraph_get_create_real_symbol_node (fn),\n \t\t\t\t      IPA_REF_ADDR, stmt);\n \t      fn = gimple_omp_task_copy_fn (stmt);\n \t      if (fn)\n-\t\tipa_record_reference ((symtab_node)node,\n-\t\t\t\t      (symtab_node)cgraph_get_create_real_symbol_node (fn),\n+\t\tipa_record_reference (node,\n+\t\t\t\t      cgraph_get_create_real_symbol_node (fn),\n \t\t\t\t      IPA_REF_ADDR, stmt);\n \t    }\n \t}\n@@ -437,7 +437,7 @@ rebuild_cgraph_edges (void)\n   gimple_stmt_iterator gsi;\n \n   cgraph_node_remove_callees (node);\n-  ipa_remove_all_references (&node->symbol.ref_list);\n+  ipa_remove_all_references (&node->ref_list);\n \n   node->count = ENTRY_BLOCK_PTR->count;\n \n@@ -485,7 +485,7 @@ cgraph_rebuild_references (void)\n   int i;\n \n   /* Keep speculative references for further cgraph edge expansion.  */\n-  for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list, i, ref);)\n+  for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref);)\n     if (!ref->speculative)\n       ipa_remove_reference (ref);\n     else\n@@ -547,7 +547,7 @@ remove_cgraph_callee_edges (void)\n {\n   struct cgraph_node *node = cgraph_get_node (current_function_decl);\n   cgraph_node_remove_callees (node);\n-  ipa_remove_all_references (&node->symbol.ref_list);\n+  ipa_remove_all_references (&node->ref_list);\n   return 0;\n }\n "}, {"sha": "373f5013d26b6e8ad63e2b5ee327621f0054fdf2", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -187,19 +187,19 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n   gcov_type count_scale;\n   unsigned i;\n \n-  new_node->symbol.decl = decl;\n-  symtab_register_node ((symtab_node)new_node);\n+  new_node->decl = decl;\n+  symtab_register_node (new_node);\n   new_node->origin = n->origin;\n-  new_node->symbol.lto_file_data = n->symbol.lto_file_data;\n+  new_node->lto_file_data = n->lto_file_data;\n   if (new_node->origin)\n     {\n       new_node->next_nested = new_node->origin->nested;\n       new_node->origin->nested = new_node;\n     }\n-  new_node->symbol.analyzed = n->symbol.analyzed;\n-  new_node->symbol.definition = n->symbol.definition;\n+  new_node->analyzed = n->analyzed;\n+  new_node->definition = n->definition;\n   new_node->local = n->local;\n-  new_node->symbol.externally_visible = false;\n+  new_node->externally_visible = false;\n   new_node->local.local = true;\n   new_node->global = n->global;\n   new_node->global.inlined_to = new_inlined_to;\n@@ -239,7 +239,7 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n   for (e = n->indirect_calls; e; e = e->next_callee)\n     cgraph_clone_edge (e, new_node, e->call_stmt, e->lto_stmt_uid,\n \t\t       count_scale, freq, update_original);\n-  ipa_clone_references ((symtab_node)new_node, &n->symbol.ref_list);\n+  ipa_clone_references (new_node, &n->ref_list);\n \n   new_node->next_sibling_clone = n->clones;\n   if (n->clones)\n@@ -290,7 +290,7 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n \t\t\t     bitmap args_to_skip,\n \t\t\t     const char * suffix)\n {\n-  tree old_decl = old_node->symbol.decl;\n+  tree old_decl = old_node->decl;\n   struct cgraph_node *new_node = NULL;\n   tree new_decl;\n   size_t len, i;\n@@ -336,16 +336,16 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n      that is not weak also.\n      ??? We cannot use COMDAT linkage because there is no\n      ABI support for this.  */\n-  DECL_EXTERNAL (new_node->symbol.decl) = 0;\n+  DECL_EXTERNAL (new_node->decl) = 0;\n   if (DECL_ONE_ONLY (old_decl))\n-    DECL_SECTION_NAME (new_node->symbol.decl) = NULL;\n-  DECL_COMDAT_GROUP (new_node->symbol.decl) = 0;\n-  TREE_PUBLIC (new_node->symbol.decl) = 0;\n-  DECL_COMDAT (new_node->symbol.decl) = 0;\n-  DECL_WEAK (new_node->symbol.decl) = 0;\n-  DECL_VIRTUAL_P (new_node->symbol.decl) = 0;\n-  DECL_STATIC_CONSTRUCTOR (new_node->symbol.decl) = 0;\n-  DECL_STATIC_DESTRUCTOR (new_node->symbol.decl) = 0;\n+    DECL_SECTION_NAME (new_node->decl) = NULL;\n+  DECL_COMDAT_GROUP (new_node->decl) = 0;\n+  TREE_PUBLIC (new_node->decl) = 0;\n+  DECL_COMDAT (new_node->decl) = 0;\n+  DECL_WEAK (new_node->decl) = 0;\n+  DECL_VIRTUAL_P (new_node->decl) = 0;\n+  DECL_STATIC_CONSTRUCTOR (new_node->decl) = 0;\n+  DECL_STATIC_DESTRUCTOR (new_node->decl) = 0;\n   new_node->clone.tree_map = tree_map;\n   new_node->clone.args_to_skip = args_to_skip;\n \n@@ -355,9 +355,9 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n        && !DECL_WEAK (old_decl)\n        && !DECL_COMDAT (old_decl))\n       || in_lto_p)\n-    new_node->symbol.unique_name = true;\n+    new_node->unique_name = true;\n   FOR_EACH_VEC_SAFE_ELT (tree_map, i, map)\n-    ipa_maybe_record_reference ((symtab_node) new_node, map->new_tree,\n+    ipa_maybe_record_reference (new_node, map->new_tree,\n \t\t\t\tIPA_REF_ADDR, NULL);\n   if (!args_to_skip)\n     new_node->clone.combined_args_to_skip = old_node->clone.combined_args_to_skip;\n@@ -369,7 +369,7 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n       struct cgraph_node *orig_node;\n       for (orig_node = old_node; orig_node->clone_of; orig_node = orig_node->clone_of)\n         ;\n-      for (arg = DECL_ARGUMENTS (orig_node->symbol.decl);\n+      for (arg = DECL_ARGUMENTS (orig_node->decl);\n \t   arg; arg = DECL_CHAIN (arg), oldi++)\n \t{\n \t  if (bitmap_bit_p (old_node->clone.combined_args_to_skip, oldi))\n@@ -385,7 +385,7 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n     }\n   else\n     new_node->clone.combined_args_to_skip = args_to_skip;\n-  new_node->symbol.externally_visible = 0;\n+  new_node->externally_visible = 0;\n   new_node->local.local = 1;\n   new_node->lowered = true;\n \n@@ -404,7 +404,7 @@ cgraph_find_replacement_node (struct cgraph_node *node)\n \n   for (next_inline_clone = node->clones;\n        next_inline_clone\n-       && next_inline_clone->symbol.decl != node->symbol.decl;\n+       && next_inline_clone->decl != node->decl;\n        next_inline_clone = next_inline_clone->next_sibling_clone)\n     ;\n \n@@ -631,8 +631,8 @@ update_call_expr (struct cgraph_node *new_version)\n   /* Update the call expr on the edges to call the new version.  */\n   for (e = new_version->callers; e; e = e->next_caller)\n     {\n-      struct function *inner_function = DECL_STRUCT_FUNCTION (e->caller->symbol.decl);\n-      gimple_call_set_fndecl (e->call_stmt, new_version->symbol.decl);\n+      struct function *inner_function = DECL_STRUCT_FUNCTION (e->caller->decl);\n+      gimple_call_set_fndecl (e->call_stmt, new_version->decl);\n       maybe_clean_eh_stmt_fn (inner_function, e->call_stmt);\n     }\n }\n@@ -663,11 +663,11 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n \n    new_version = cgraph_create_node (new_decl);\n \n-   new_version->symbol.analyzed = old_version->symbol.analyzed;\n-   new_version->symbol.definition = old_version->symbol.definition;\n+   new_version->analyzed = old_version->analyzed;\n+   new_version->definition = old_version->definition;\n    new_version->local = old_version->local;\n-   new_version->symbol.externally_visible = false;\n-   new_version->local.local = new_version->symbol.definition;\n+   new_version->externally_visible = false;\n+   new_version->local.local = new_version->definition;\n    new_version->global = old_version->global;\n    new_version->rtl = old_version->rtl;\n    new_version->count = old_version->count;\n@@ -728,7 +728,7 @@ cgraph_function_versioning (struct cgraph_node *old_version_node,\n \t\t\t    basic_block new_entry_block,\n \t\t\t    const char *clone_name)\n {\n-  tree old_decl = old_version_node->symbol.decl;\n+  tree old_decl = old_version_node->decl;\n   struct cgraph_node *new_version_node = NULL;\n   tree new_decl;\n \n@@ -768,9 +768,9 @@ cgraph_function_versioning (struct cgraph_node *old_version_node,\n      that is not weak also.\n      ??? We cannot use COMDAT linkage because there is no\n      ABI support for this.  */\n-  symtab_make_decl_local (new_version_node->symbol.decl);\n-  DECL_VIRTUAL_P (new_version_node->symbol.decl) = 0;\n-  new_version_node->symbol.externally_visible = 0;\n+  symtab_make_decl_local (new_version_node->decl);\n+  DECL_VIRTUAL_P (new_version_node->decl) = 0;\n+  new_version_node->externally_visible = 0;\n   new_version_node->local.local = 1;\n   new_version_node->lowered = true;\n   /* Clones of global symbols or symbols with unique names are unique.  */\n@@ -779,7 +779,7 @@ cgraph_function_versioning (struct cgraph_node *old_version_node,\n        && !DECL_WEAK (old_decl)\n        && !DECL_COMDAT (old_decl))\n       || in_lto_p)\n-    new_version_node->symbol.unique_name = true;\n+    new_version_node->unique_name = true;\n \n   /* Update the call_expr on the edges to call the new version node. */\n   update_call_expr (new_version_node);\n@@ -794,18 +794,18 @@ static void\n cgraph_materialize_clone (struct cgraph_node *node)\n {\n   bitmap_obstack_initialize (NULL);\n-  node->former_clone_of = node->clone_of->symbol.decl;\n+  node->former_clone_of = node->clone_of->decl;\n   if (node->clone_of->former_clone_of)\n     node->former_clone_of = node->clone_of->former_clone_of;\n   /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n-  tree_function_versioning (node->clone_of->symbol.decl, node->symbol.decl,\n+  tree_function_versioning (node->clone_of->decl, node->decl,\n   \t\t\t    node->clone.tree_map, true,\n \t\t\t    node->clone.args_to_skip, false,\n \t\t\t    NULL, NULL);\n   if (cgraph_dump_file)\n     {\n-      dump_function_to_file (node->clone_of->symbol.decl, cgraph_dump_file, dump_flags);\n-      dump_function_to_file (node->symbol.decl, cgraph_dump_file, dump_flags);\n+      dump_function_to_file (node->clone_of->decl, cgraph_dump_file, dump_flags);\n+      dump_function_to_file (node->decl, cgraph_dump_file, dump_flags);\n     }\n \n   /* Function is no longer clone.  */\n@@ -817,11 +817,11 @@ cgraph_materialize_clone (struct cgraph_node *node)\n     node->clone_of->clones = node->next_sibling_clone;\n   node->next_sibling_clone = NULL;\n   node->prev_sibling_clone = NULL;\n-  if (!node->clone_of->symbol.analyzed && !node->clone_of->clones)\n+  if (!node->clone_of->analyzed && !node->clone_of->clones)\n     {\n       cgraph_release_function_body (node->clone_of);\n       cgraph_node_remove_callees (node->clone_of);\n-      ipa_remove_all_references (&node->clone_of->symbol.ref_list);\n+      ipa_remove_all_references (&node->clone_of->ref_list);\n     }\n   node->clone_of = NULL;\n   bitmap_obstack_release (NULL);\n@@ -854,12 +854,12 @@ cgraph_materialize_all_clones (void)\n       stabilized = true;\n       FOR_EACH_FUNCTION (node)\n         {\n-\t  if (node->clone_of && node->symbol.decl != node->clone_of->symbol.decl\n-\t      && !gimple_has_body_p (node->symbol.decl))\n+\t  if (node->clone_of && node->decl != node->clone_of->decl\n+\t      && !gimple_has_body_p (node->decl))\n \t    {\n \t      if (!node->clone_of->clone_of)\n \t\tcgraph_get_body (node->clone_of);\n-\t      if (gimple_has_body_p (node->clone_of->symbol.decl))\n+\t      if (gimple_has_body_p (node->clone_of->decl))\n \t        {\n \t\t  if (cgraph_dump_file)\n \t\t    {\n@@ -903,13 +903,13 @@ cgraph_materialize_all_clones (void)\n \t}\n     }\n   FOR_EACH_FUNCTION (node)\n-    if (!node->symbol.analyzed && node->callees)\n+    if (!node->analyzed && node->callees)\n       {\n         cgraph_node_remove_callees (node);\n-\tipa_remove_all_references (&node->symbol.ref_list);\n+\tipa_remove_all_references (&node->ref_list);\n       }\n     else\n-      ipa_clear_stmts_in_references ((symtab_node)node);\n+      ipa_clear_stmts_in_references (node);\n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file, \"Materialization Call site updates done.\\n\");\n #ifdef ENABLE_CHECKING"}, {"sha": "060ee70d7d4481ebae0319c4eeb489c7674f9421", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 151, "deletions": 151, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -227,25 +227,25 @@ static GTY (()) tree vtable_entry_type;\n bool\n decide_is_symbol_needed (symtab_node node)\n {\n-  tree decl = node->symbol.decl;\n+  tree decl = node->decl;\n \n   /* Double check that no one output the function into assembly file\n      early.  */\n   gcc_checking_assert (!DECL_ASSEMBLER_NAME_SET_P (decl)\n \t               || !TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)));\n \n-  if (!node->symbol.definition)\n+  if (!node->definition)\n     return false;\n \n   if (DECL_EXTERNAL (decl))\n     return false;\n \n   /* If the user told us it is used, then it must be so.  */\n-  if (node->symbol.force_output)\n+  if (node->force_output)\n     return true;\n \n   /* ABI forced symbols are needed when they are external.  */\n-  if (node->symbol.forced_by_abi && TREE_PUBLIC (decl))\n+  if (node->forced_by_abi && TREE_PUBLIC (decl))\n     return true;\n \n  /* Keep constructors, destructors and virtual functions.  */\n@@ -271,10 +271,10 @@ static symtab_node first = (symtab_node)(void *)1;\n static void\n enqueue_node (symtab_node node)\n {\n-  if (node->symbol.aux)\n+  if (node->aux)\n     return;\n   gcc_checking_assert (first);\n-  node->symbol.aux = first;\n+  node->aux = first;\n   first = node;\n }\n \n@@ -298,7 +298,7 @@ cgraph_process_new_functions (void)\n   for (csi = csi_start (cgraph_new_nodes); !csi_end_p (csi); csi_next (&csi))\n     {\n       node = csi_node (csi);\n-      fndecl = node->symbol.decl;\n+      fndecl = node->decl;\n       switch (cgraph_state)\n \t{\n \tcase CGRAPH_STATE_CONSTRUCTION:\n@@ -308,7 +308,7 @@ cgraph_process_new_functions (void)\n \t  cgraph_finalize_function (fndecl, false);\n \t  output = true;\n           cgraph_call_function_insertion_hooks (node);\n-\t  enqueue_node ((symtab_node) node);\n+\t  enqueue_node (node);\n \t  break;\n \n \tcase CGRAPH_STATE_IPA:\n@@ -318,7 +318,7 @@ cgraph_process_new_functions (void)\n \t     cgraph but not on this function.  */\n \n \t  gimple_register_cfg_hooks ();\n-\t  if (!node->symbol.analyzed)\n+\t  if (!node->analyzed)\n \t    analyze_function (node);\n \t  push_cfun (DECL_STRUCT_FUNCTION (fndecl));\n \t  if (cgraph_state == CGRAPH_STATE_IPA_SSA\n@@ -374,14 +374,14 @@ cgraph_reset_node (struct cgraph_node *node)\n   memset (&node->local, 0, sizeof (node->local));\n   memset (&node->global, 0, sizeof (node->global));\n   memset (&node->rtl, 0, sizeof (node->rtl));\n-  node->symbol.analyzed = false;\n-  node->symbol.definition = false;\n-  node->symbol.alias = false;\n-  node->symbol.weakref = false;\n-  node->symbol.cpp_implicit_alias = false;\n+  node->analyzed = false;\n+  node->definition = false;\n+  node->alias = false;\n+  node->weakref = false;\n+  node->cpp_implicit_alias = false;\n \n   cgraph_node_remove_callees (node);\n-  ipa_remove_all_references (&node->symbol.ref_list);\n+  ipa_remove_all_references (&node->ref_list);\n }\n \n /* Return true when there are references to NODE.  */\n@@ -392,7 +392,7 @@ referred_to_p (symtab_node node)\n   struct ipa_ref *ref;\n \n   /* See if there are any references at all.  */\n-  if (ipa_ref_list_referring_iterate (&node->symbol.ref_list, 0, ref))\n+  if (ipa_ref_list_referring_iterate (&node->ref_list, 0, ref))\n     return true;\n   /* For functions check also calls.  */\n   cgraph_node *cn = dyn_cast <cgraph_node> (node);\n@@ -411,7 +411,7 @@ cgraph_finalize_function (tree decl, bool no_collect)\n {\n   struct cgraph_node *node = cgraph_get_create_node (decl);\n \n-  if (node->symbol.definition)\n+  if (node->definition)\n     {\n       /* Nested functions should only be defined once.  */\n       gcc_assert (!DECL_CONTEXT (decl)\n@@ -421,7 +421,7 @@ cgraph_finalize_function (tree decl, bool no_collect)\n     }\n \n   notice_global_symbol (decl);\n-  node->symbol.definition = true;\n+  node->definition = true;\n   node->lowered = DECL_STRUCT_FUNCTION (decl)->cfg != NULL;\n \n   /* With -fkeep-inline-functions we are keeping all inline functions except\n@@ -430,21 +430,21 @@ cgraph_finalize_function (tree decl, bool no_collect)\n       && DECL_DECLARED_INLINE_P (decl)\n       && !DECL_EXTERNAL (decl)\n       && !DECL_DISREGARD_INLINE_LIMITS (decl))\n-    node->symbol.force_output = 1;\n+    node->force_output = 1;\n \n   /* When not optimizing, also output the static functions. (see\n      PR24561), but don't do so for always_inline functions, functions\n      declared inline and nested functions.  These were optimized out\n      in the original implementation and it is unclear whether we want\n      to change the behavior here.  */\n   if ((!optimize\n-       && !node->symbol.cpp_implicit_alias\n+       && !node->cpp_implicit_alias\n        && !DECL_DISREGARD_INLINE_LIMITS (decl)\n        && !DECL_DECLARED_INLINE_P (decl)\n        && !(DECL_CONTEXT (decl)\n \t    && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL))\n       && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n-    node->symbol.force_output = 1;\n+    node->force_output = 1;\n \n   /* If we've not yet emitted decl, tell the debug info about it.  */\n   if (!TREE_ASM_WRITTEN (decl))\n@@ -458,9 +458,9 @@ cgraph_finalize_function (tree decl, bool no_collect)\n     ggc_collect ();\n \n   if (cgraph_state == CGRAPH_STATE_CONSTRUCTION\n-      && (decide_is_symbol_needed ((symtab_node) node)\n-\t  || referred_to_p ((symtab_node)node)))\n-    enqueue_node ((symtab_node)node);\n+      && (decide_is_symbol_needed (node)\n+\t  || referred_to_p (node)))\n+    enqueue_node (node);\n }\n \n /* Add the function FNDECL to the call graph.\n@@ -502,8 +502,8 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n \t   analyzing and compilation.  */\n \tnode = cgraph_get_create_node (fndecl);\n \tnode->local.local = false;\n-\tnode->symbol.definition = true;\n-\tnode->symbol.force_output = true;\n+\tnode->definition = true;\n+\tnode->force_output = true;\n \tif (!lowered && cgraph_state == CGRAPH_STATE_EXPANSION)\n \t  {\n \t    push_cfun (DECL_STRUCT_FUNCTION (fndecl));\n@@ -529,7 +529,7 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n \tnode = cgraph_create_node (fndecl);\n \tif (lowered)\n \t  node->lowered = true;\n-\tnode->symbol.definition = true;\n+\tnode->definition = true;\n \tanalyze_function (node);\n \tpush_cfun (DECL_STRUCT_FUNCTION (fndecl));\n \tgimple_register_cfg_hooks ();\n@@ -590,7 +590,7 @@ output_asm_statements (void)\n static void\n analyze_function (struct cgraph_node *node)\n {\n-  tree decl = node->symbol.decl;\n+  tree decl = node->decl;\n   location_t saved_loc = input_location;\n   input_location = DECL_SOURCE_LOCATION (decl);\n \n@@ -601,14 +601,14 @@ analyze_function (struct cgraph_node *node)\n       if (!expand_thunk (node, false))\n \t{\n \t  node->thunk.alias = NULL;\n-\t  node->symbol.analyzed = true;\n+\t  node->analyzed = true;\n \t  return;\n \t}\n       node->thunk.alias = NULL;\n     }\n-  if (node->symbol.alias)\n+  if (node->alias)\n     symtab_resolve_alias\n-       ((symtab_node) node, (symtab_node) cgraph_get_node (node->symbol.alias_target));\n+       (node, cgraph_get_node (node->alias_target));\n   else if (node->dispatcher_function)\n     {\n       /* Generate the dispatcher body of multi-versioned functions.  */\n@@ -628,7 +628,7 @@ analyze_function (struct cgraph_node *node)\n     {\n       push_cfun (DECL_STRUCT_FUNCTION (decl));\n \n-      assign_assembler_name_if_neeeded (node->symbol.decl);\n+      assign_assembler_name_if_neeeded (node->decl);\n \n       /* Make sure to gimplify bodies only once.  During analyzing a\n \t function we lower it, which will require gimplified nested\n@@ -642,7 +642,7 @@ analyze_function (struct cgraph_node *node)\n       if (!node->lowered)\n \t{\n \t  if (node->nested)\n-\t    lower_nested_functions (node->symbol.decl);\n+\t    lower_nested_functions (node->decl);\n \t  gcc_assert (!node->nested);\n \n \t  gimple_register_cfg_hooks ();\n@@ -657,7 +657,7 @@ analyze_function (struct cgraph_node *node)\n \n       pop_cfun ();\n     }\n-  node->symbol.analyzed = true;\n+  node->analyzed = true;\n \n   input_location = saved_loc;\n }\n@@ -673,12 +673,12 @@ cgraph_process_same_body_aliases (void)\n {\n   symtab_node node;\n   FOR_EACH_SYMBOL (node)\n-    if (node->symbol.cpp_implicit_alias && !node->symbol.analyzed)\n+    if (node->cpp_implicit_alias && !node->analyzed)\n       symtab_resolve_alias\n         (node,\n-\t TREE_CODE (node->symbol.alias_target) == VAR_DECL\n-\t ? (symtab_node)varpool_node_for_decl (node->symbol.alias_target)\n-\t : (symtab_node)cgraph_get_create_node (node->symbol.alias_target));\n+\t TREE_CODE (node->alias_target) == VAR_DECL\n+\t ? (symtab_node)varpool_node_for_decl (node->alias_target)\n+\t : (symtab_node)cgraph_get_create_node (node->alias_target));\n   cpp_implicit_aliases_done = true;\n }\n \n@@ -734,20 +734,20 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n   for (node = cgraph_first_function (); node != first;\n        node = cgraph_next_function (node))\n     {\n-      tree decl = node->symbol.decl;\n+      tree decl = node->decl;\n       if (DECL_PRESERVE_P (decl))\n \tcgraph_mark_force_output_node (node);\n       else if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (decl)))\n \t{\n-\t  if (! TREE_PUBLIC (node->symbol.decl))\n-\t    warning_at (DECL_SOURCE_LOCATION (node->symbol.decl), OPT_Wattributes,\n+\t  if (! TREE_PUBLIC (node->decl))\n+\t    warning_at (DECL_SOURCE_LOCATION (node->decl), OPT_Wattributes,\n \t\t\t\"%<externally_visible%>\"\n \t\t\t\" attribute have effect only on public objects\");\n \t}\n       if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl))\n-\t  && (node->symbol.definition && !node->symbol.alias))\n+\t  && (node->definition && !node->alias))\n \t{\n-\t  warning_at (DECL_SOURCE_LOCATION (node->symbol.decl), OPT_Wattributes,\n+\t  warning_at (DECL_SOURCE_LOCATION (node->decl), OPT_Wattributes,\n \t\t      \"%<weakref%> attribute ignored\"\n \t\t      \" because function is defined\");\n \t  DECL_WEAK (decl) = 0;\n@@ -767,24 +767,24 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n   for (vnode = varpool_first_variable (); vnode != first_var;\n        vnode = varpool_next_variable (vnode))\n     {\n-      tree decl = vnode->symbol.decl;\n+      tree decl = vnode->decl;\n       if (DECL_EXTERNAL (decl)\n \t  && DECL_INITIAL (decl))\n \tvarpool_finalize_decl (decl);\n       if (DECL_PRESERVE_P (decl))\n-\tvnode->symbol.force_output = true;\n+\tvnode->force_output = true;\n       else if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (decl)))\n \t{\n-\t  if (! TREE_PUBLIC (vnode->symbol.decl))\n-\t    warning_at (DECL_SOURCE_LOCATION (vnode->symbol.decl), OPT_Wattributes,\n+\t  if (! TREE_PUBLIC (vnode->decl))\n+\t    warning_at (DECL_SOURCE_LOCATION (vnode->decl), OPT_Wattributes,\n \t\t\t\"%<externally_visible%>\"\n \t\t\t\" attribute have effect only on public objects\");\n \t}\n       if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl))\n-\t  && vnode->symbol.definition\n+\t  && vnode->definition\n \t  && DECL_INITIAL (decl))\n \t{\n-\t  warning_at (DECL_SOURCE_LOCATION (vnode->symbol.decl), OPT_Wattributes,\n+\t  warning_at (DECL_SOURCE_LOCATION (vnode->decl), OPT_Wattributes,\n \t\t      \"%<weakref%> attribute ignored\"\n \t\t      \" because variable is initialized\");\n \t  DECL_WEAK (decl) = 0;\n@@ -806,21 +806,21 @@ varpool_finalize_decl (tree decl)\n \n   gcc_assert (TREE_STATIC (decl) || DECL_EXTERNAL (decl));\n \n-  if (node->symbol.definition)\n+  if (node->definition)\n     return;\n   notice_global_symbol (decl);\n-  node->symbol.definition = true;\n+  node->definition = true;\n   if (TREE_THIS_VOLATILE (decl) || DECL_PRESERVE_P (decl)\n       /* Traditionally we do not eliminate static variables when not\n \t optimizing and when not doing toplevel reoder.  */\n-      || (!flag_toplevel_reorder && !DECL_COMDAT (node->symbol.decl)\n-\t  && !DECL_ARTIFICIAL (node->symbol.decl)))\n-    node->symbol.force_output = true;\n+      || (!flag_toplevel_reorder && !DECL_COMDAT (node->decl)\n+\t  && !DECL_ARTIFICIAL (node->decl)))\n+    node->force_output = true;\n \n   if (cgraph_state == CGRAPH_STATE_CONSTRUCTION\n-      && (decide_is_symbol_needed ((symtab_node) node)\n-\t  || referred_to_p ((symtab_node)node)))\n-    enqueue_node ((symtab_node)node);\n+      && (decide_is_symbol_needed (node)\n+\t  || referred_to_p (node)))\n+    enqueue_node (node);\n   if (cgraph_state >= CGRAPH_STATE_IPA_SSA)\n     varpool_analyze_node (node);\n   /* Some frontends produce various interface variables after compilation\n@@ -857,14 +857,14 @@ walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n \t  /* Do not bother to mark virtual methods in anonymous namespace;\n \t     either we will find use of virtual table defining it, or it is\n \t     unused.  */\n-\t  if (targets[i]->symbol.definition\n+\t  if (targets[i]->definition\n \t      && TREE_CODE\n-\t\t  (TREE_TYPE (targets[i]->symbol.decl))\n+\t\t  (TREE_TYPE (targets[i]->decl))\n \t\t   == METHOD_TYPE\n \t      && !type_in_anonymous_namespace_p\n \t\t   (method_class_type\n-\t\t     (TREE_TYPE (targets[i]->symbol.decl))))\n-\t  enqueue_node ((symtab_node) targets[i]);\n+\t\t     (TREE_TYPE (targets[i]->decl))))\n+\t  enqueue_node (targets[i]);\n \t}\n     }\n \n@@ -934,7 +934,7 @@ analyze_functions (void)\n      C++ FE is confused about the COMDAT groups being right.  */\n   if (cpp_implicit_aliases_done)\n     FOR_EACH_SYMBOL (node)\n-      if (node->symbol.cpp_implicit_alias)\n+      if (node->cpp_implicit_alias)\n \t  fixup_same_cpp_alias_visibility (node, symtab_alias_target (node));\n   if (optimize && flag_devirtualize)\n     build_type_inheritance_graph ();\n@@ -949,8 +949,8 @@ analyze_functions (void)\n \n       /* First identify the trivially needed symbols.  */\n       for (node = symtab_nodes;\n-\t   node != (symtab_node)first_analyzed\n-\t   && node != (symtab_node)first_analyzed_var; node = node->symbol.next)\n+\t   node != first_analyzed\n+\t   && node != first_analyzed_var; node = node->next)\n \t{\n \t  if (decide_is_symbol_needed (node))\n \t    {\n@@ -963,8 +963,8 @@ analyze_functions (void)\n \t      if (!changed && cgraph_dump_file)\n \t\tfprintf (cgraph_dump_file, \"\\n\");\n \t    }\n-\t  if (node == (symtab_node)first_analyzed\n-\t      || node == (symtab_node)first_analyzed_var)\n+\t  if (node == first_analyzed\n+\t      || node == first_analyzed_var)\n \t    break;\n \t}\n       cgraph_process_new_functions ();\n@@ -980,18 +980,18 @@ analyze_functions (void)\n \t{\n \t  changed = true;\n \t  node = first;\n-\t  first = (symtab_node)first->symbol.aux;\n+\t  first = (symtab_node)first->aux;\n \t  cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n-\t  if (cnode && cnode->symbol.definition)\n+\t  if (cnode && cnode->definition)\n \t    {\n \t      struct cgraph_edge *edge;\n-\t      tree decl = cnode->symbol.decl;\n+\t      tree decl = cnode->decl;\n \n \t      /* ??? It is possible to create extern inline function\n \t      and later using weak alias attribute to kill its body.\n \t      See gcc.c-torture/compile/20011119-1.c  */\n \t      if (!DECL_STRUCT_FUNCTION (decl)\n-\t\t  && !cnode->symbol.alias\n+\t\t  && !cnode->alias\n \t\t  && !cnode->thunk.thunk_p\n \t\t  && !cnode->dispatcher_function)\n \t\t{\n@@ -1000,12 +1000,12 @@ analyze_functions (void)\n \t\t  continue;\n \t\t}\n \n-\t      if (!cnode->symbol.analyzed)\n+\t      if (!cnode->analyzed)\n \t\tanalyze_function (cnode);\n \n \t      for (edge = cnode->callees; edge; edge = edge->next_callee)\n-\t\tif (edge->callee->symbol.definition)\n-\t\t   enqueue_node ((symtab_node)edge->callee);\n+\t\tif (edge->callee->definition)\n+\t\t   enqueue_node (edge->callee);\n \t      if (optimize && flag_devirtualize)\n \t\t{\n \t\t  struct cgraph_edge *next;\n@@ -1033,20 +1033,20 @@ analyze_functions (void)\n \t  else\n \t    {\n \t      varpool_node *vnode = dyn_cast <varpool_node> (node);\n-\t      if (vnode && vnode->symbol.definition && !vnode->symbol.analyzed)\n+\t      if (vnode && vnode->definition && !vnode->analyzed)\n \t\tvarpool_analyze_node (vnode);\n \t    }\n \n-\t  if (node->symbol.same_comdat_group)\n+\t  if (node->same_comdat_group)\n \t    {\n \t      symtab_node next;\n-\t      for (next = node->symbol.same_comdat_group;\n+\t      for (next = node->same_comdat_group;\n \t\t   next != node;\n-\t\t   next = next->symbol.same_comdat_group)\n+\t\t   next = next->same_comdat_group)\n \t\tenqueue_node (next);\n \t    }\n-\t  for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list, i, ref); i++)\n-\t    if (ref->referred->symbol.definition)\n+\t  for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref); i++)\n+\t    if (ref->referred->definition)\n \t      enqueue_node (ref->referred);\n           cgraph_process_new_functions ();\n \t}\n@@ -1065,11 +1065,11 @@ analyze_functions (void)\n     fprintf (cgraph_dump_file, \"\\nRemoving unused symbols:\");\n \n   for (node = symtab_nodes;\n-       node != (symtab_node)first_handled\n-       && node != (symtab_node)first_handled_var; node = next)\n+       node != first_handled\n+       && node != first_handled_var; node = next)\n     {\n-      next = node->symbol.next;\n-      if (!node->symbol.aux && !referred_to_p (node))\n+      next = node->next;\n+      if (!node->aux && !referred_to_p (node))\n \t{\n \t  if (cgraph_dump_file)\n \t    fprintf (cgraph_dump_file, \" %s\", symtab_node_name (node));\n@@ -1078,22 +1078,22 @@ analyze_functions (void)\n \t}\n       if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n \t{\n-\t  tree decl = node->symbol.decl;\n+\t  tree decl = node->decl;\n \n-\t  if (cnode->symbol.definition && !gimple_has_body_p (decl)\n-\t      && !cnode->symbol.alias\n+\t  if (cnode->definition && !gimple_has_body_p (decl)\n+\t      && !cnode->alias\n \t      && !cnode->thunk.thunk_p)\n \t    cgraph_reset_node (cnode);\n \n-\t  gcc_assert (!cnode->symbol.definition || cnode->thunk.thunk_p\n-\t\t      || cnode->symbol.alias\n+\t  gcc_assert (!cnode->definition || cnode->thunk.thunk_p\n+\t\t      || cnode->alias\n \t\t      || gimple_has_body_p (decl));\n-\t  gcc_assert (cnode->symbol.analyzed == cnode->symbol.definition);\n+\t  gcc_assert (cnode->analyzed == cnode->definition);\n \t}\n-      node->symbol.aux = NULL;\n+      node->aux = NULL;\n     }\n-  for (;node; node = node->symbol.next)\n-    node->symbol.aux = NULL;\n+  for (;node; node = node->next)\n+    node->aux = NULL;\n   first_analyzed = cgraph_first_function ();\n   first_analyzed_var = varpool_first_variable ();\n   if (cgraph_dump_file)\n@@ -1136,9 +1136,9 @@ handle_alias_pairs (void)\n \t  symtab_node node = symtab_get_node (p->decl);\n \t  if (node)\n \t    {\n-\t      node->symbol.alias_target = p->target;\n-\t      node->symbol.weakref = true;\n-\t      node->symbol.alias = true;\n+\t      node->alias_target = p->target;\n+\t      node->weakref = true;\n+\t      node->alias = true;\n \t    }\n \t  alias_pairs->unordered_remove (i);\n \t  continue;\n@@ -1148,17 +1148,17 @@ handle_alias_pairs (void)\n \t  error (\"%q+D aliased to undefined symbol %qE\", p->decl, p->target);\n \t  symtab_node node = symtab_get_node (p->decl);\n \t  if (node)\n-\t    node->symbol.alias = false;\n+\t    node->alias = false;\n \t  alias_pairs->unordered_remove (i);\n \t  continue;\n \t}\n \n-      if (DECL_EXTERNAL (target_node->symbol.decl)\n+      if (DECL_EXTERNAL (target_node->decl)\n \t  /* We use local aliases for C++ thunks to force the tailcall\n \t     to bind locally.  This is a hack - to keep it working do\n \t     the following (which is not strictly correct).  */\n-\t  && (! TREE_CODE (target_node->symbol.decl) == FUNCTION_DECL\n-\t      || ! DECL_VIRTUAL_P (target_node->symbol.decl))\n+\t  && (! TREE_CODE (target_node->decl) == FUNCTION_DECL\n+\t      || ! DECL_VIRTUAL_P (target_node->decl))\n \t  && ! lookup_attribute (\"weakref\", DECL_ATTRIBUTES (p->decl)))\n \t{\n \t  error (\"%q+D aliased to external symbol %qE\",\n@@ -1169,23 +1169,23 @@ handle_alias_pairs (void)\n           && target_node && is_a <cgraph_node> (target_node))\n \t{\n \t  struct cgraph_node *src_node = cgraph_get_node (p->decl);\n-\t  if (src_node && src_node->symbol.definition)\n+\t  if (src_node && src_node->definition)\n             cgraph_reset_node (src_node);\n-\t  cgraph_create_function_alias (p->decl, target_node->symbol.decl);\n+\t  cgraph_create_function_alias (p->decl, target_node->decl);\n \t  alias_pairs->unordered_remove (i);\n \t}\n       else if (TREE_CODE (p->decl) == VAR_DECL\n \t       && target_node && is_a <varpool_node> (target_node))\n \t{\n-\t  varpool_create_variable_alias (p->decl, target_node->symbol.decl);\n+\t  varpool_create_variable_alias (p->decl, target_node->decl);\n \t  alias_pairs->unordered_remove (i);\n \t}\n       else\n \t{\n \t  error (\"%q+D alias in between function and variable is not supported\",\n \t\t p->decl);\n \t  warning (0, \"%q+D aliased declaration\",\n-\t\t   target_node->symbol.decl);\n+\t\t   target_node->decl);\n \t  alias_pairs->unordered_remove (i);\n \t}\n     }\n@@ -1208,34 +1208,34 @@ mark_functions_to_output (void)\n \n   FOR_EACH_FUNCTION (node)\n     {\n-      tree decl = node->symbol.decl;\n+      tree decl = node->decl;\n \n-      gcc_assert (!node->process || node->symbol.same_comdat_group);\n+      gcc_assert (!node->process || node->same_comdat_group);\n       if (node->process)\n \tcontinue;\n \n       /* We need to output all local functions that are used and not\n \t always inlined, as well as those that are reachable from\n \t outside the current compilation unit.  */\n-      if (node->symbol.analyzed\n+      if (node->analyzed\n \t  && !node->thunk.thunk_p\n-\t  && !node->symbol.alias\n+\t  && !node->alias\n \t  && !node->global.inlined_to\n \t  && !TREE_ASM_WRITTEN (decl)\n \t  && !DECL_EXTERNAL (decl))\n \t{\n \t  node->process = 1;\n-\t  if (node->symbol.same_comdat_group)\n+\t  if (node->same_comdat_group)\n \t    {\n \t      struct cgraph_node *next;\n-\t      for (next = cgraph (node->symbol.same_comdat_group);\n+\t      for (next = cgraph (node->same_comdat_group);\n \t\t   next != node;\n-\t\t   next = cgraph (next->symbol.same_comdat_group))\n-\t\tif (!next->thunk.thunk_p && !next->symbol.alias)\n+\t\t   next = cgraph (next->same_comdat_group))\n+\t\tif (!next->thunk.thunk_p && !next->alias)\n \t\t  next->process = 1;\n \t    }\n \t}\n-      else if (node->symbol.same_comdat_group)\n+      else if (node->same_comdat_group)\n \t{\n #ifdef ENABLE_CHECKING\n \t  check_same_comdat_groups = true;\n@@ -1250,8 +1250,8 @@ mark_functions_to_output (void)\n \t      /* FIXME: in ltrans unit when offline copy is outside partition but inline copies\n \t\t are inside partition, we can end up not removing the body since we no longer\n \t\t have analyzed node pointing to it.  */\n-\t      && !node->symbol.in_other_partition\n-\t      && !node->symbol.alias\n+\t      && !node->in_other_partition\n+\t      && !node->alias\n \t      && !node->clones\n \t      && !DECL_EXTERNAL (decl))\n \t    {\n@@ -1261,7 +1261,7 @@ mark_functions_to_output (void)\n #endif\n \t  gcc_assert (node->global.inlined_to\n \t\t      || !gimple_has_body_p (decl)\n-\t\t      || node->symbol.in_other_partition\n+\t\t      || node->in_other_partition\n \t\t      || node->clones\n \t\t      || DECL_ARTIFICIAL (decl)\n \t\t      || DECL_EXTERNAL (decl));\n@@ -1272,16 +1272,16 @@ mark_functions_to_output (void)\n #ifdef ENABLE_CHECKING\n   if (check_same_comdat_groups)\n     FOR_EACH_FUNCTION (node)\n-      if (node->symbol.same_comdat_group && !node->process)\n+      if (node->same_comdat_group && !node->process)\n \t{\n-\t  tree decl = node->symbol.decl;\n+\t  tree decl = node->decl;\n \t  if (!node->global.inlined_to\n \t      && gimple_has_body_p (decl)\n \t      /* FIXME: in an ltrans unit when the offline copy is outside a\n \t\t partition but inline copies are inside a partition, we can\n \t\t end up not removing the body since we no longer have an\n \t\t analyzed node pointing to it.  */\n-\t      && !node->symbol.in_other_partition\n+\t      && !node->in_other_partition\n \t      && !node->clones\n \t      && !DECL_EXTERNAL (decl))\n \t    {\n@@ -1451,8 +1451,8 @@ expand_thunk (struct cgraph_node *node, bool output_asm_thunks)\n   HOST_WIDE_INT fixed_offset = node->thunk.fixed_offset;\n   HOST_WIDE_INT virtual_value = node->thunk.virtual_value;\n   tree virtual_offset = NULL;\n-  tree alias = node->callees->callee->symbol.decl;\n-  tree thunk_fndecl = node->symbol.decl;\n+  tree alias = node->callees->callee->decl;\n+  tree thunk_fndecl = node->decl;\n   tree a;\n \n \n@@ -1504,7 +1504,7 @@ expand_thunk (struct cgraph_node *node, bool output_asm_thunks)\n       set_cfun (NULL);\n       TREE_ASM_WRITTEN (thunk_fndecl) = 1;\n       node->thunk.thunk_p = false;\n-      node->symbol.analyzed = false;\n+      node->analyzed = false;\n     }\n   else\n     {\n@@ -1690,20 +1690,20 @@ assemble_thunks_and_aliases (struct cgraph_node *node)\n       }\n     else\n       e = e->next_caller;\n-  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list,\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list,\n \t\t\t\t\t     i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n \tstruct cgraph_node *alias = ipa_ref_referring_node (ref);\n-        bool saved_written = TREE_ASM_WRITTEN (node->symbol.decl);\n+        bool saved_written = TREE_ASM_WRITTEN (node->decl);\n \n \t/* Force assemble_alias to really output the alias this time instead\n \t   of buffering it in same alias pairs.  */\n-\tTREE_ASM_WRITTEN (node->symbol.decl) = 1;\n-\tdo_assemble_alias (alias->symbol.decl,\n-\t\t\t   DECL_ASSEMBLER_NAME (node->symbol.decl));\n+\tTREE_ASM_WRITTEN (node->decl) = 1;\n+\tdo_assemble_alias (alias->decl,\n+\t\t\t   DECL_ASSEMBLER_NAME (node->decl));\n \tassemble_thunks_and_aliases (alias);\n-\tTREE_ASM_WRITTEN (node->symbol.decl) = saved_written;\n+\tTREE_ASM_WRITTEN (node->decl) = saved_written;\n       }\n }\n \n@@ -1712,7 +1712,7 @@ assemble_thunks_and_aliases (struct cgraph_node *node)\n static void\n expand_function (struct cgraph_node *node)\n {\n-  tree decl = node->symbol.decl;\n+  tree decl = node->decl;\n   location_t saved_loc;\n \n   /* We ought to not compile any inline clones.  */\n@@ -1817,7 +1817,7 @@ expand_function (struct cgraph_node *node)\n   /* Eliminate all call edges.  This is important so the GIMPLE_CALL no longer\n      points to the dead function body.  */\n   cgraph_node_remove_callees (node);\n-  ipa_remove_all_references (&node->symbol.ref_list);\n+  ipa_remove_all_references (&node->ref_list);\n }\n \n \n@@ -1905,19 +1905,19 @@ output_in_order (void)\n \n   FOR_EACH_DEFINED_FUNCTION (pf)\n     {\n-      if (pf->process && !pf->thunk.thunk_p && !pf->symbol.alias)\n+      if (pf->process && !pf->thunk.thunk_p && !pf->alias)\n \t{\n-\t  i = pf->symbol.order;\n+\t  i = pf->order;\n \t  gcc_assert (nodes[i].kind == ORDER_UNDEFINED);\n \t  nodes[i].kind = ORDER_FUNCTION;\n \t  nodes[i].u.f = pf;\n \t}\n     }\n \n   FOR_EACH_DEFINED_VARIABLE (pv)\n-    if (!DECL_EXTERNAL (pv->symbol.decl))\n+    if (!DECL_EXTERNAL (pv->decl))\n       {\n-\ti = pv->symbol.order;\n+\ti = pv->order;\n \tgcc_assert (nodes[i].kind == ORDER_UNDEFINED);\n \tnodes[i].kind = ORDER_VAR;\n \tnodes[i].u.v = pv;\n@@ -2050,9 +2050,9 @@ output_weakrefs (void)\n {\n   symtab_node node;\n   FOR_EACH_SYMBOL (node)\n-    if (node->symbol.alias\n-        && !TREE_ASM_WRITTEN (node->symbol.decl)\n-\t&& node->symbol.weakref)\n+    if (node->alias\n+        && !TREE_ASM_WRITTEN (node->decl)\n+\t&& node->weakref)\n       {\n \ttree target;\n \n@@ -2061,18 +2061,18 @@ output_weakrefs (void)\n \t   alias.\n \t   When alias target is defined, we need to fetch it from symtab reference,\n \t   otherwise it is pointed to by alias_target.  */\n-\tif (node->symbol.alias_target)\n-\t  target = (DECL_P (node->symbol.alias_target)\n-\t\t    ? DECL_ASSEMBLER_NAME (node->symbol.alias_target)\n-\t\t    : node->symbol.alias_target);\n-\telse if (node->symbol.analyzed)\n-\t  target = DECL_ASSEMBLER_NAME (symtab_alias_target (node)->symbol.decl);\n+\tif (node->alias_target)\n+\t  target = (DECL_P (node->alias_target)\n+\t\t    ? DECL_ASSEMBLER_NAME (node->alias_target)\n+\t\t    : node->alias_target);\n+\telse if (node->analyzed)\n+\t  target = DECL_ASSEMBLER_NAME (symtab_alias_target (node)->decl);\n \telse\n \t  {\n \t    gcc_unreachable ();\n-\t    target = get_alias_symbol (node->symbol.decl);\n+\t    target = get_alias_symbol (node->decl);\n \t  }\n-        do_assemble_alias (node->symbol.decl, target);\n+        do_assemble_alias (node->decl, target);\n       }\n }\n \n@@ -2173,14 +2173,14 @@ compile (void)\n   symtab_node node;\n \n   FOR_EACH_SYMBOL (node)\n-    if (node->symbol.alias\n-\t&& lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)))\n+    if (node->alias\n+\t&& lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->decl)))\n       {\n \tIDENTIFIER_TRANSPARENT_ALIAS\n-\t   (DECL_ASSEMBLER_NAME (node->symbol.decl)) = 1;\n-\tTREE_CHAIN (DECL_ASSEMBLER_NAME (node->symbol.decl))\n-\t   = (node->symbol.alias_target ? node->symbol.alias_target\n-\t      : DECL_ASSEMBLER_NAME (symtab_alias_target (node)->symbol.decl));\n+\t   (DECL_ASSEMBLER_NAME (node->decl)) = 1;\n+\tTREE_CHAIN (DECL_ASSEMBLER_NAME (node->decl))\n+\t   = (node->alias_target ? node->alias_target\n+\t      : DECL_ASSEMBLER_NAME (symtab_alias_target (node)->decl));\n       }\n #endif\n \n@@ -2215,7 +2215,7 @@ compile (void)\n \n       FOR_EACH_DEFINED_FUNCTION (node)\n \tif (node->global.inlined_to\n-\t    || gimple_has_body_p (node->symbol.decl))\n+\t    || gimple_has_body_p (node->decl))\n \t  {\n \t    error_found = true;\n \t    dump_cgraph_node (stderr, node);"}, {"sha": "2df39551a3856f17ffd931f1bc1dddc23b456cdc", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -30154,7 +30154,7 @@ ix86_get_function_versions_dispatcher (void *decl)\n   while (default_version_info != NULL)\n     {\n       if (is_function_default_version\n-\t    (default_version_info->this_node->symbol.decl))\n+\t    (default_version_info->this_node->decl))\n         break;\n       default_version_info = default_version_info->next;\n     }\n@@ -30184,15 +30184,15 @@ ix86_get_function_versions_dispatcher (void *decl)\n       struct cgraph_function_version_info *dispatcher_version_info = NULL;\n \n       /* Right now, the dispatching is done via ifunc.  */\n-      dispatch_decl = make_dispatcher_decl (default_node->symbol.decl);\n+      dispatch_decl = make_dispatcher_decl (default_node->decl);\n \n       dispatcher_node = cgraph_get_create_node (dispatch_decl);\n       gcc_assert (dispatcher_node != NULL);\n       dispatcher_node->dispatcher_function = 1;\n       dispatcher_version_info\n \t= insert_new_cgraph_node_version (dispatcher_node);\n       dispatcher_version_info->next = default_version_info;\n-      dispatcher_node->symbol.definition = 1;\n+      dispatcher_node->definition = 1;\n \n       /* Set the dispatcher for all the versions.  */\n       it_v = default_version_info;\n@@ -30205,7 +30205,7 @@ ix86_get_function_versions_dispatcher (void *decl)\n   else\n #endif\n     {\n-      error_at (DECL_SOURCE_LOCATION (default_node->symbol.decl),\n+      error_at (DECL_SOURCE_LOCATION (default_node->decl),\n \t\t\"multiversioning needs ifunc which is not supported \"\n \t\t\"on this target\");\n     }\n@@ -30344,13 +30344,13 @@ ix86_generate_version_dispatcher_body (void *node_p)\n     return node_version_info->dispatcher_resolver;\n \n   /* The first version in the chain corresponds to the default version.  */\n-  default_ver_decl = node_version_info->next->this_node->symbol.decl;\n+  default_ver_decl = node_version_info->next->this_node->decl;\n \n   /* node is going to be an alias, so remove the finalized bit.  */\n-  node->symbol.definition = false;\n+  node->definition = false;\n \n   resolver_decl = make_resolver_func (default_ver_decl,\n-\t\t\t\t      node->symbol.decl, &empty_bb);\n+\t\t\t\t      node->decl, &empty_bb);\n \n   node_version_info->dispatcher_resolver = resolver_decl;\n \n@@ -30367,10 +30367,10 @@ ix86_generate_version_dispatcher_body (void *node_p)\n \t not.  This happens for methods in derived classes that override\n \t virtual methods in base classes but are not explicitly marked as\n \t virtual.  */\n-      if (DECL_VINDEX (versn->symbol.decl))\n+      if (DECL_VINDEX (versn->decl))\n \tsorry (\"Virtual function multiversioning not supported\");\n \n-      fn_ver_vec.safe_push (versn->symbol.decl);\n+      fn_ver_vec.safe_push (versn->decl);\n     }\n \n   dispatch_function_versions (resolver_decl, &fn_ver_vec, &empty_bb);"}, {"sha": "9b0fc8b3d1437c81d76bfaa5422a70d3196ea1bc", "filename": "gcc/coverage.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -554,12 +554,12 @@ unsigned\n coverage_compute_profile_id (struct cgraph_node *n)\n {\n   expanded_location xloc\n-    = expand_location (DECL_SOURCE_LOCATION (n->symbol.decl));\n+    = expand_location (DECL_SOURCE_LOCATION (n->decl));\n   unsigned chksum = xloc.line;\n \n   chksum = coverage_checksum_string (chksum, xloc.file);\n   chksum = coverage_checksum_string\n-    (chksum, IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (n->symbol.decl)));\n+    (chksum, IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (n->decl)));\n   if (first_global_object_name)\n     chksum = coverage_checksum_string\n       (chksum, first_global_object_name);"}, {"sha": "0d329b5a9286646faf7deb4206719735dc6c5601", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -1,3 +1,24 @@\n+2013-10-29  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPatch autogenerated by refactor_symtab.py from\n+\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n+\trevision 58bb219cc090b2f4516a9297d868c245495ee622\n+\n+\t* call.c (mark_versions_used): Update for conversion of symtab types\n+\tto a true class hierarchy.\n+\t* decl2.c (cp_write_global_declarations): Likewise.\n+\t(clear_decl_external): Likewise.\n+\t(build_java_method_aliases): Likewise.\n+\t(collect_candidates_for_java_method_aliases): Likewise.\n+\t(mark_needed): Likewise.\n+\t(var_finalized_p): Likewise.\n+\t(maybe_make_one_only): Likewise.\n+\t(maybe_emit_vtables): Likewise.\n+\t* lambda.c (maybe_add_lambda_conv_op): Likewise.\n+\t* method.c (use_thunk): Likewise.\n+\t* optimize.c (maybe_clone_body): Likewise.\n+\t* tree.c (cp_fix_function_decl_p): Likewise.\n+\n 2013-10-29  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/58888"}, {"sha": "5663010f31e23df37c497f3555d3eadb1743bfa0", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -6630,7 +6630,7 @@ mark_versions_used (tree fn)\n   it_v = node_v->next;\n   while (it_v != NULL)\n     {\n-      mark_used (it_v->this_node->symbol.decl);\n+      mark_used (it_v->this_node->decl);\n       it_v = it_v->next;\n     }\n }"}, {"sha": "d776471607c67d1a06a5ec78c723353251266449", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -1747,7 +1747,7 @@ maybe_make_one_only (tree decl)\n           struct varpool_node *node = varpool_node_for_decl (decl);\n \t  DECL_COMDAT (decl) = 1;\n \t  /* Mark it needed so we don't forget to emit it.  */\n-          node->symbol.forced_by_abi = true;\n+          node->forced_by_abi = true;\n \t  TREE_USED (decl) = 1;\n \t}\n     }\n@@ -1845,7 +1845,7 @@ import_export_class (tree ctype)\n static bool\n var_finalized_p (tree var)\n {\n-  return varpool_node_for_decl (var)->symbol.definition;\n+  return varpool_node_for_decl (var)->definition;\n }\n \n /* DECL is a VAR_DECL or FUNCTION_DECL which, for whatever reason,\n@@ -1862,14 +1862,14 @@ mark_needed (tree decl)\n \t functions can be marked reachable, just use the external\n \t definition.  */\n       struct cgraph_node *node = cgraph_get_create_node (decl);\n-      node->symbol.forced_by_abi = true;\n+      node->forced_by_abi = true;\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n     {\n       struct varpool_node *node = varpool_node_for_decl (decl);\n       /* C++ frontend use mark_decl_references to force COMDAT variables\n          to be output that might appear dead otherwise.  */\n-      node->symbol.forced_by_abi = true;\n+      node->forced_by_abi = true;\n     }\n }\n \n@@ -1979,7 +1979,7 @@ maybe_emit_vtables (tree ctype)\n \t{\n \t  current = varpool_node_for_decl (vtbl);\n \t  if (last)\n-\t    symtab_add_to_same_comdat_group ((symtab_node) current, (symtab_node) last);\n+\t    symtab_add_to_same_comdat_group (current, last);\n \t  last = current;\n \t}\n     }\n@@ -3744,7 +3744,7 @@ collect_candidates_for_java_method_aliases (void)\n \n   FOR_EACH_FUNCTION (node)\n     {\n-      tree fndecl = node->symbol.decl;\n+      tree fndecl = node->decl;\n \n       if (DECL_CLASS_SCOPE_P (fndecl)\n \t  && TYPE_FOR_JAVA (DECL_CONTEXT (fndecl))\n@@ -3777,7 +3777,7 @@ build_java_method_aliases (struct pointer_set_t *candidates)\n \n   FOR_EACH_FUNCTION (node)\n     {\n-      tree fndecl = node->symbol.decl;\n+      tree fndecl = node->decl;\n \n       if (TREE_ASM_WRITTEN (fndecl)\n \t  && pointer_set_contains (candidates, fndecl))\n@@ -3958,7 +3958,7 @@ collect_all_refs (const char *source_file)\n static bool\n clear_decl_external (struct cgraph_node *node, void * /*data*/)\n {\n-  DECL_EXTERNAL (node->symbol.decl) = 0;\n+  DECL_EXTERNAL (node->decl) = 0;\n   return false;\n }\n \n@@ -4276,18 +4276,18 @@ cp_write_global_declarations (void)\n \t      struct cgraph_node *node, *next;\n \n \t      node = cgraph_get_node (decl);\n-\t      if (node->symbol.cpp_implicit_alias)\n+\t      if (node->cpp_implicit_alias)\n \t\tnode = cgraph_alias_target (node);\n \n \t      cgraph_for_node_and_aliases (node, clear_decl_external,\n \t\t\t\t\t   NULL, true);\n \t      /* If we mark !DECL_EXTERNAL one of the symbols in some comdat\n \t\t group, we need to mark all symbols in the same comdat group\n \t\t that way.  */\n-\t      if (node->symbol.same_comdat_group)\n-\t\tfor (next = cgraph (node->symbol.same_comdat_group);\n+\t      if (node->same_comdat_group)\n+\t\tfor (next = cgraph (node->same_comdat_group);\n \t\t     next != node;\n-\t\t     next = cgraph (next->symbol.same_comdat_group))\n+\t\t     next = cgraph (next->same_comdat_group))\n \t          cgraph_for_node_and_aliases (next, clear_decl_external,\n \t\t\t\t\t       NULL, true);\n \t    }\n@@ -4299,7 +4299,7 @@ cp_write_global_declarations (void)\n \t  if (!DECL_EXTERNAL (decl)\n \t      && decl_needed_p (decl)\n \t      && !TREE_ASM_WRITTEN (decl)\n-\t      && !cgraph_get_node (decl)->symbol.definition)\n+\t      && !cgraph_get_node (decl)->definition)\n \t    {\n \t      /* We will output the function; no longer consider it in this\n \t\t loop.  */"}, {"sha": "f39ce1a5ea69b8db51b65ccf1ab869853463257e", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -1020,8 +1020,8 @@ maybe_add_lambda_conv_op (tree type)\n     {\n       /* Put the thunk in the same comdat group as the call op.  */\n       symtab_add_to_same_comdat_group\n-\t ((symtab_node) cgraph_get_create_node (statfn),\n-          (symtab_node) cgraph_get_create_node (callop));\n+\t (cgraph_get_create_node (statfn),\n+          cgraph_get_create_node (callop));\n     }\n   tree body = begin_function_body ();\n   tree compound_stmt = begin_compound_stmt (0);"}, {"sha": "353e99a6410ffc6408d2b916ebc61fac414ca382", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -386,8 +386,8 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n \t\t\t\t this_adjusting, fixed_offset, virtual_value,\n \t\t\t\t virtual_offset, alias);\n   if (DECL_ONE_ONLY (function))\n-    symtab_add_to_same_comdat_group ((symtab_node) thunk_node,\n-\t\t\t\t     (symtab_node) funcn);\n+    symtab_add_to_same_comdat_group (thunk_node,\n+\t\t\t\t     funcn);\n \n   if (!this_adjusting\n       || !targetm.asm_out.can_output_mi_thunk (thunk_fndecl, fixed_offset,"}, {"sha": "c4ee8484bb95ab7197c0e6c69b59300e7e2e24c3", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -339,7 +339,7 @@ maybe_clone_body (tree fn)\n \t     virtual, it goes into the same comdat group as well.  */\n \t  if (comdat_group)\n \t    symtab_add_to_same_comdat_group\n-\t       ((symtab_node) cgraph_get_create_node (clone),\n+\t       (cgraph_get_create_node (clone),\n \t        symtab_get_node (fns[0]));\n \t}\n       else if (alias)"}, {"sha": "3ac034806200a06396759fb79b77a4a475a347b7", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -3983,8 +3983,8 @@ cp_fix_function_decl_p (tree decl)\n \n       /* Don't fix same_body aliases.  Although they don't have their own\n \t CFG, they share it with what they alias to.  */\n-      if (!node || !node->symbol.alias\n-\t  || !vec_safe_length (node->symbol.ref_list.references))\n+      if (!node || !node->alias\n+\t  || !vec_safe_length (node->ref_list.references))\n \treturn true;\n     }\n "}, {"sha": "84f765efe5e7bd07b9c1d21a577eb862c0b24a28", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -2480,7 +2480,7 @@ dbxout_expand_expr (tree expr)\n \t     return NULL, otherwise stabs might reference an undefined\n \t     symbol.  */\n \t  struct varpool_node *node = varpool_get_node (expr);\n-\t  if (!node || !node->symbol.definition)\n+\t  if (!node || !node->definition)\n \t    return NULL;\n \t}\n       /* FALLTHRU */"}, {"sha": "5ef7bd2034dd553b597e7a7522c8fa41cfa14101", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -15143,7 +15143,7 @@ reference_to_unused (tree * tp, int * walk_subtrees,\n   else if (TREE_CODE (*tp) == VAR_DECL)\n     {\n       struct varpool_node *node = varpool_get_node (*tp);\n-      if (!node || !node->symbol.definition)\n+      if (!node || !node->definition)\n \treturn *tp;\n     }\n   else if (TREE_CODE (*tp) == FUNCTION_DECL\n@@ -17821,7 +17821,7 @@ premark_types_used_by_global_vars_helper (void **slot,\n       /* Ask cgraph if the global variable really is to be emitted.\n          If yes, then we'll keep the DIE of ENTRY->TYPE.  */\n       struct varpool_node *node = varpool_get_node (entry->var_decl);\n-      if (node && node->symbol.definition)\n+      if (node && node->definition)\n \t{\n \t  die->die_perennial_p = 1;\n \t  /* Keep the parent DIEs as well.  */"}, {"sha": "73b626c7d7b779a27aa5d435053a4da3ccac7d53", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -93,14 +93,14 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n       || TREE_CODE (from_decl) != VAR_DECL\n       || !DECL_EXTERNAL (from_decl)\n       || (flag_ltrans\n-\t  && symtab_get_node (from_decl)->symbol.in_other_partition))\n+\t  && symtab_get_node (from_decl)->in_other_partition))\n     return true;\n   /* We are folding reference from external vtable.  The vtable may reffer\n      to a symbol keyed to other compilation unit.  The other compilation\n      unit may be in separate DSO and the symbol may be hidden.  */\n   if (DECL_VISIBILITY_SPECIFIED (decl)\n       && DECL_EXTERNAL (decl)\n-      && (!(snode = symtab_get_node (decl)) || !snode->symbol.in_other_partition))\n+      && (!(snode = symtab_get_node (decl)) || !snode->in_other_partition))\n     return false;\n   /* When function is public, we always can introduce new reference.\n      Exception are the COMDAT functions where introducing a direct\n@@ -131,7 +131,7 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n          The second is important when devirtualization happens during final\n          compilation stage when making a new reference no longer makes callee\n          to be compiled.  */\n-      if (!node || !node->symbol.definition || node->global.inlined_to)\n+      if (!node || !node->definition || node->global.inlined_to)\n \t{\n \t  gcc_checking_assert (!TREE_ASM_WRITTEN (decl));\n \t  return false;\n@@ -140,7 +140,7 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n   else if (TREE_CODE (decl) == VAR_DECL)\n     {\n       vnode = varpool_get_node (decl);\n-      if (!vnode || !vnode->symbol.definition)\n+      if (!vnode || !vnode->definition)\n \t{\n \t  gcc_checking_assert (!TREE_ASM_WRITTEN (decl));\n \t  return false;"}, {"sha": "04f08b3461ee6b13ef15ac03883877795e526a7c", "filename": "gcc/gimplify.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -977,7 +977,7 @@ unshare_body (tree fndecl)\n \n   if (cgn)\n     for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n-      unshare_body (cgn->symbol.decl);\n+      unshare_body (cgn->decl);\n }\n \n /* Callback for walk_tree to unmark the visited trees rooted at *TP.\n@@ -1020,7 +1020,7 @@ unvisit_body (tree fndecl)\n \n   if (cgn)\n     for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n-      unvisit_body (cgn->symbol.decl);\n+      unvisit_body (cgn->decl);\n }\n \n /* Unconditionally make an unshared copy of EXPR.  This is used when using"}, {"sha": "72a96d22c17b14ba89031fe6207a15e21b661dac", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -352,7 +352,7 @@ print_lattice (FILE * f, struct ipcp_lattice *lat,\n \n \t  fprintf (f, \" [from:\");\n \t  for (s = val->sources; s; s = s->next)\n-\t    fprintf (f, \" %i(%i)\", s->cs->caller->symbol.order,\n+\t    fprintf (f, \" %i(%i)\", s->cs->caller->order,\n \t\t     s->cs->frequency);\n \t  fprintf (f, \"]\");\n \t}\n@@ -382,7 +382,7 @@ print_all_lattices (FILE * f, bool dump_sources, bool dump_benefits)\n \n       info = IPA_NODE_REF (node);\n       fprintf (f, \"  Node: %s/%i:\\n\", cgraph_node_name (node),\n-\t       node->symbol.order);\n+\t       node->order);\n       count = ipa_get_param_count (info);\n       for (i = 0; i < count; i++)\n \t{\n@@ -423,16 +423,16 @@ determine_versionability (struct cgraph_node *node)\n   /* There are a number of generic reasons functions cannot be versioned.  We\n      also cannot remove parameters if there are type attributes such as fnspec\n      present.  */\n-  if (node->symbol.alias || node->thunk.thunk_p)\n+  if (node->alias || node->thunk.thunk_p)\n     reason = \"alias or thunk\";\n   else if (!node->local.versionable)\n     reason = \"not a tree_versionable_function\";\n   else if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n     reason = \"insufficient body availability\";\n \n-  if (reason && dump_file && !node->symbol.alias && !node->thunk.thunk_p)\n+  if (reason && dump_file && !node->alias && !node->thunk.thunk_p)\n     fprintf (dump_file, \"Function %s/%i is not versionable, reason: %s.\\n\",\n-\t     cgraph_node_name (node), node->symbol.order, reason);\n+\t     cgraph_node_name (node), node->order, reason);\n \n   node->local.versionable = (reason == NULL);\n }\n@@ -508,7 +508,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n       return false;\n     }\n \n-  if (!optimize_function_for_speed_p (DECL_STRUCT_FUNCTION (node->symbol.decl)))\n+  if (!optimize_function_for_speed_p (DECL_STRUCT_FUNCTION (node->decl)))\n     {\n       if (dump_file)\n         fprintf (dump_file, \"Not considering %s for cloning; \"\n@@ -710,9 +710,9 @@ initialize_node_lattices (struct cgraph_node *node)\n \t    set_all_contains_variable (plats);\n \t}\n       if (dump_file && (dump_flags & TDF_DETAILS)\n-\t  && !node->symbol.alias && !node->thunk.thunk_p)\n+\t  && !node->alias && !node->thunk.thunk_p)\n \tfprintf (dump_file, \"Marking all lattices of %s/%i as %s\\n\",\n-\t\t cgraph_node_name (node), node->symbol.order,\n+\t\t cgraph_node_name (node), node->order,\n \t\t disable ? \"BOTTOM\" : \"VARIABLE\");\n     }\n \n@@ -1405,7 +1405,7 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n   int i, args_count, parms_count;\n \n   callee = cgraph_function_node (cs->callee, &availability);\n-  if (!callee->symbol.definition)\n+  if (!callee->definition)\n     return false;\n   gcc_checking_assert (cgraph_function_with_gimple_body_p (callee));\n   callee_info = IPA_NODE_REF (callee);\n@@ -1418,7 +1418,7 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n      parameter.  However, we might need to uncover a thunk from below a series\n      of aliases first.  */\n   alias_or_thunk = cs->callee;\n-  while (alias_or_thunk->symbol.alias)\n+  while (alias_or_thunk->alias)\n     alias_or_thunk = cgraph_alias_target (alias_or_thunk);\n   if (alias_or_thunk->thunk.thunk_p)\n     {\n@@ -1597,7 +1597,7 @@ devirtualization_time_bonus (struct cgraph_node *node,\n       /* Only bare minimum benefit for clearly un-inlineable targets.  */\n       res += 1;\n       callee = cgraph_get_node (target);\n-      if (!callee || !callee->symbol.definition)\n+      if (!callee || !callee->definition)\n \tcontinue;\n       isummary = inline_summary (callee);\n       if (!isummary->inlinable)\n@@ -1610,7 +1610,7 @@ devirtualization_time_bonus (struct cgraph_node *node,\n       else if (isummary->size <= MAX_INLINE_INSNS_AUTO / 2)\n \tres += 15;\n       else if (isummary->size <= MAX_INLINE_INSNS_AUTO\n-\t       || DECL_DECLARED_INLINE_P (callee->symbol.decl))\n+\t       || DECL_DECLARED_INLINE_P (callee->decl))\n \tres += 7;\n     }\n \n@@ -1640,7 +1640,7 @@ good_cloning_opportunity_p (struct cgraph_node *node, int time_benefit,\n {\n   if (time_benefit == 0\n       || !flag_ipa_cp_clone\n-      || !optimize_function_for_speed_p (DECL_STRUCT_FUNCTION (node->symbol.decl)))\n+      || !optimize_function_for_speed_p (DECL_STRUCT_FUNCTION (node->decl)))\n     return false;\n \n   gcc_assert (size_cost > 0);\n@@ -1817,7 +1817,7 @@ estimate_local_effects (struct cgraph_node *node)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\nEstimating effects for %s/%i, base_time: %i.\\n\",\n-\t     cgraph_node_name (node), node->symbol.order, base_time);\n+\t     cgraph_node_name (node), node->order, base_time);\n \n   always_const = gather_context_independent_values (info, &known_csts,\n \t\t\t\t\t\t    &known_binfos, &known_aggs,\n@@ -2219,7 +2219,7 @@ ipcp_propagate_stage (struct topo_info *topo)\n \t\t\t\t   ipa_get_param_count (info));\n \tinitialize_node_lattices (node);\n       }\n-    if (node->symbol.definition && !node->symbol.alias)\n+    if (node->definition && !node->alias)\n       overall_size += inline_summary (node)->self_size;\n     if (node->count > max_count)\n       max_count = node->count;\n@@ -2287,8 +2287,8 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node,\n \t\t    fprintf (dump_file, \"     controlled uses count of param \"\n \t\t\t     \"%i bumped down to %i\\n\", param_index, c);\n \t\t  if (c == 0\n-\t\t      && (to_del = ipa_find_reference ((symtab_node) node,\n-\t\t\t\t\t\t       (symtab_node) cs->callee,\n+\t\t      && (to_del = ipa_find_reference (node,\n+\t\t\t\t\t\t       cs->callee,\n \t\t\t\t\t\t       NULL, 0)))\n \t\t    {\n \t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2544,7 +2544,7 @@ update_profiling_info (struct cgraph_node *orig_node,\n \tfprintf (dump_file, \"    Problem: node %s/%i has too low count \"\n \t\t HOST_WIDE_INT_PRINT_DEC \" while the sum of incoming \"\n \t\t \"counts is \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-\t\t cgraph_node_name (orig_node), orig_node->symbol.order,\n+\t\t cgraph_node_name (orig_node), orig_node->order,\n \t\t (HOST_WIDE_INT) orig_node_count,\n \t\t (HOST_WIDE_INT) (orig_sum + new_sum));\n \n@@ -2677,13 +2677,13 @@ create_specialized_node (struct cgraph_node *node,\n \t\t\t\t\t  args_to_skip, \"constprop\");\n   ipa_set_node_agg_value_chain (new_node, aggvals);\n   for (av = aggvals; av; av = av->next)\n-    ipa_maybe_record_reference ((symtab_node) new_node, av->value,\n+    ipa_maybe_record_reference (new_node, av->value,\n \t\t\t\tIPA_REF_ADDR, NULL);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"     the new node is %s/%i.\\n\",\n-\t       cgraph_node_name (new_node), new_node->symbol.order);\n+\t       cgraph_node_name (new_node), new_node->order);\n       if (aggvals)\n \tipa_dump_agg_replacement_values (dump_file, aggvals);\n     }\n@@ -3236,9 +3236,9 @@ perhaps_add_new_callers (struct cgraph_node *node, struct ipcp_value *val)\n \t\t    fprintf (dump_file, \" - adding an extra caller %s/%i\"\n \t\t\t     \" of %s/%i\\n\",\n \t\t\t     xstrdup (cgraph_node_name (cs->caller)),\n-\t\t\t     cs->caller->symbol.order,\n+\t\t\t     cs->caller->order,\n \t\t\t     xstrdup (cgraph_node_name (val->spec_node)),\n-\t\t\t     val->spec_node->symbol.order);\n+\t\t\t     val->spec_node->order);\n \n \t\t  cgraph_redirect_edge_callee (cs, val->spec_node);\n \t\t  redirected_sum += cs->count;\n@@ -3342,7 +3342,7 @@ decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n \n   if (dump_file)\n     fprintf (dump_file, \"  Creating a specialized node of %s/%i.\\n\",\n-\t     cgraph_node_name (node), node->symbol.order);\n+\t     cgraph_node_name (node), node->order);\n \n   callers = gather_edges_for_value (val, caller_count);\n   kv = known_csts.copy ();\n@@ -3379,7 +3379,7 @@ decide_whether_version_node (struct cgraph_node *node)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\nEvaluating opportunities for %s/%i.\\n\",\n-\t     cgraph_node_name (node), node->symbol.order);\n+\t     cgraph_node_name (node), node->order);\n \n   gather_context_independent_values (info, &known_csts, &known_binfos,\n \t\t\t\t  info->do_clone_for_all_contexts ? &known_aggs\n@@ -3423,7 +3423,7 @@ decide_whether_version_node (struct cgraph_node *node)\n       if (dump_file)\n \tfprintf (dump_file, \" - Creating a specialized node of %s/%i \"\n \t\t \"for all known contexts.\\n\", cgraph_node_name (node),\n-\t\t node->symbol.order);\n+\t\t node->order);\n \n       callers = collect_callers_of_node (node);\n       move_binfos_to_values (known_csts, known_binfos);\n@@ -3498,23 +3498,23 @@ static void\n identify_dead_nodes (struct cgraph_node *node)\n {\n   struct cgraph_node *v;\n-  for (v = node; v ; v = ((struct ipa_dfs_info *) v->symbol.aux)->next_cycle)\n+  for (v = node; v ; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n     if (cgraph_will_be_removed_from_program_if_no_direct_calls (v)\n \t&& !cgraph_for_node_and_aliases (v,\n \t\t\t\t\t has_undead_caller_from_outside_scc_p,\n \t\t\t\t\t NULL, true))\n       IPA_NODE_REF (v)->node_dead = 1;\n \n-  for (v = node; v ; v = ((struct ipa_dfs_info *) v->symbol.aux)->next_cycle)\n+  for (v = node; v ; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n     if (!IPA_NODE_REF (v)->node_dead)\n       spread_undeadness (v);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      for (v = node; v ; v = ((struct ipa_dfs_info *) v->symbol.aux)->next_cycle)\n+      for (v = node; v ; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n \tif (IPA_NODE_REF (v)->node_dead)\n \t  fprintf (dump_file, \"  Marking node as dead: %s/%i.\\n\",\n-\t\t   cgraph_node_name (v), v->symbol.order);\n+\t\t   cgraph_node_name (v), v->order);\n     }\n }\n \n@@ -3538,7 +3538,7 @@ ipcp_decision_stage (struct topo_info *topo)\n \t{\n \t  struct cgraph_node *v;\n \t  iterate = false;\n-\t  for (v = node; v ; v = ((struct ipa_dfs_info *) v->symbol.aux)->next_cycle)\n+\t  for (v = node; v ; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n \t    if (cgraph_function_with_gimple_body_p (v)\n \t\t&& ipcp_versionable_function_p (v))\n \t      iterate |= decide_whether_version_node (v);\n@@ -3611,7 +3611,7 @@ ipcp_generate_summary (void)\n   FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n       {\n \tnode->local.versionable\n-\t  = tree_versionable_function_p (node->symbol.decl);\n+\t  = tree_versionable_function_p (node->decl);\n \tipa_analyze_node (node);\n       }\n }"}, {"sha": "80c6b73a4b1802dfeff90bcb9c610b854f84bb65", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -544,9 +544,9 @@ build_type_inheritance_graph (void)\n   /* We reconstruct the graph starting of types of all methods seen in the\n      the unit.  */\n   FOR_EACH_FUNCTION (n)\n-    if (DECL_VIRTUAL_P (n->symbol.decl)\n-\t&& symtab_real_symbol_p ((symtab_node)n))\n-      get_odr_type (method_class_type (TREE_TYPE (n->symbol.decl)), true);\n+    if (DECL_VIRTUAL_P (n->decl)\n+\t&& symtab_real_symbol_p (n))\n+      get_odr_type (method_class_type (TREE_TYPE (n->decl)), true);\n   if (inheritance_dump_file)\n     {\n       dump_type_inheritance_graph (inheritance_dump_file);\n@@ -572,8 +572,8 @@ maybe_record_node (vec <cgraph_node *> &nodes,\n       && !pointer_set_insert (inserted, target)\n       && (target_node = cgraph_get_node (target)) != NULL\n       && (TREE_PUBLIC (target)\n-\t  || target_node->symbol.definition)\n-      && symtab_real_symbol_p ((symtab_node)target_node))\n+\t  || target_node->definition)\n+      && symtab_real_symbol_p (target_node))\n     {\n       pointer_set_insert (cached_polymorphic_call_targets,\n \t\t\t  target_node);\n@@ -627,7 +627,7 @@ record_binfo (vec <cgraph_node *> &nodes,\n \t  if (TREE_CODE (vtable) == POINTER_PLUS_EXPR)\n \t    vtable = TREE_OPERAND (TREE_OPERAND (vtable, 0), 0);\n \t  vnode = varpool_get_node (vtable);\n-\t  if (!vnode || !vnode->symbol.definition)\n+\t  if (!vnode || !vnode->definition)\n \t    return;\n \t}\n       tree target = gimple_get_virt_method_for_binfo (otr_token, type_binfo);\n@@ -761,8 +761,8 @@ devirt_variable_node_removal_hook (struct varpool_node *n,\n \t\t\t\t   void *d ATTRIBUTE_UNUSED)\n {\n   if (cached_polymorphic_call_targets\n-      && DECL_VIRTUAL_P (n->symbol.decl)\n-      && type_in_anonymous_namespace_p (DECL_CONTEXT (n->symbol.decl)))\n+      && DECL_VIRTUAL_P (n->decl)\n+      && type_in_anonymous_namespace_p (DECL_CONTEXT (n->decl)))\n     free_polymorphic_call_targets_hash ();\n }\n \n@@ -891,7 +891,7 @@ dump_possible_polymorphic_call_targets (FILE *f,\n \t   final ? \" (full list)\" : \" (partial list, may call to other unit)\");\n   for (i = 0; i < targets.length (); i++)\n     fprintf (f, \" %s/%i\", cgraph_node_name (targets[i]),\n-\t     targets[i]->symbol.order);\n+\t     targets[i]->order);\n   fprintf (f, \"\\n\");\n }\n \n@@ -917,7 +917,7 @@ possible_polymorphic_call_target_p (tree otr_type,\n \n   /* At a moment we allow middle end to dig out new external declarations\n      as a targets of polymorphic calls.  */\n-  if (!final && !n->symbol.definition)\n+  if (!final && !n->definition)\n     return true;\n   return false;\n }\n@@ -938,10 +938,10 @@ update_type_inheritance_graph (void)\n   /* We reconstruct the graph starting of types of all methods seen in the\n      the unit.  */\n   FOR_EACH_FUNCTION (n)\n-    if (DECL_VIRTUAL_P (n->symbol.decl)\n-\t&& !n->symbol.definition\n-\t&& symtab_real_symbol_p ((symtab_node)n))\n-      get_odr_type (method_class_type (TREE_TYPE (n->symbol.decl)), true);\n+    if (DECL_VIRTUAL_P (n->decl)\n+\t&& !n->definition\n+\t&& symtab_real_symbol_p (n))\n+      get_odr_type (method_class_type (TREE_TYPE (n->decl)), true);\n   timevar_pop (TV_IPA_INHERITANCE);\n }\n \n@@ -955,13 +955,13 @@ likely_target_p (struct cgraph_node *n)\n {\n   int flags;\n   /* cxa_pure_virtual and similar things are not likely.  */\n-  if (TREE_CODE (TREE_TYPE (n->symbol.decl)) != METHOD_TYPE)\n+  if (TREE_CODE (TREE_TYPE (n->decl)) != METHOD_TYPE)\n     return false;\n-  flags = flags_from_decl_or_type (n->symbol.decl);\n+  flags = flags_from_decl_or_type (n->decl);\n   if (flags & ECF_NORETURN)\n     return false;\n   if (lookup_attribute (\"cold\",\n-\t\t\tDECL_ATTRIBUTES (n->symbol.decl)))\n+\t\t\tDECL_ATTRIBUTES (n->decl)))\n     return false;\n   if (n->frequency < NODE_FREQUENCY_NORMAL)\n     return false;\n@@ -988,7 +988,7 @@ ipa_devirt (void)\n       bool update = false;\n       if (dump_file && n->indirect_calls)\n \tfprintf (dump_file, \"\\n\\nProcesing function %s/%i\\n\",\n-\t\t cgraph_node_name (n), n->symbol.order);\n+\t\t cgraph_node_name (n), n->order);\n       for (e = n->indirect_calls; e; e = e->next_callee)\n \tif (e->indirect_info->polymorphic)\n \t  {\n@@ -1069,7 +1069,7 @@ ipa_devirt (void)\n \t\t  }\n \t\tcontinue;\n \t      }\n-\t    if (!likely_target->symbol.definition)\n+\t    if (!likely_target->definition)\n \t      {\n \t\tif (dump_file)\n \t\t  fprintf (dump_file, \"Target is not an definition\\n\");\n@@ -1080,7 +1080,7 @@ ipa_devirt (void)\n \t       can handle these just well, it is common for programs to\n \t       incorrectly with headers defining methods they are linked\n \t       with.  */\n-\t    if (DECL_EXTERNAL (likely_target->symbol.decl))\n+\t    if (DECL_EXTERNAL (likely_target->decl))\n \t      {\n \t\tif (dump_file)\n \t\t  fprintf (dump_file, \"Target is external\\n\");\n@@ -1089,7 +1089,7 @@ ipa_devirt (void)\n \t      }\n \t    if (cgraph_function_body_availability (likely_target)\n \t\t<= AVAIL_OVERWRITABLE\n-\t\t&& symtab_can_be_discarded ((symtab_node) likely_target))\n+\t\t&& symtab_can_be_discarded (likely_target))\n \t      {\n \t\tif (dump_file)\n \t\t  fprintf (dump_file, \"Target is overwritable\\n\");\n@@ -1101,14 +1101,14 @@ ipa_devirt (void)\n \t\tif (dump_file)\n \t\t  fprintf (dump_file,\n \t\t\t   \"Speculatively devirtualizing call in %s/%i to %s/%i\\n\",\n-\t\t\t   cgraph_node_name (n), n->symbol.order,\n+\t\t\t   cgraph_node_name (n), n->order,\n \t\t\t   cgraph_node_name (likely_target),\n-\t\t\t   likely_target->symbol.order);\n-\t\tif (!symtab_can_be_discarded ((symtab_node) likely_target))\n+\t\t\t   likely_target->order);\n+\t\tif (!symtab_can_be_discarded (likely_target))\n \t\t  {\n \t\t    cgraph_node *alias;\n \t\t    alias = cgraph (symtab_nonoverwritable_alias\n-\t\t\t\t     ((symtab_node)likely_target));\n+\t\t\t\t     (likely_target));\n \t\t    if (alias)\n \t\t      likely_target = alias;\n \t\t  }"}, {"sha": "bc0e8c3170f95a127f0ebe86be416b1b708bd870", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -1298,7 +1298,7 @@ dump_inline_edge_summary (FILE *f, int indent, struct cgraph_node *node,\n       fprintf (f,\n \t       \"%*s%s/%i %s\\n%*s  loop depth:%2i freq:%4i size:%2i\"\n \t       \" time: %2i callee size:%2i stack:%2i\",\n-\t       indent, \"\", cgraph_node_name (callee), callee->symbol.order,\n+\t       indent, \"\", cgraph_node_name (callee), callee->order,\n \t       !edge->inline_failed\n \t       ? \"inlined\" : cgraph_inline_failed_string (edge-> inline_failed),\n \t       indent, \"\", es->loop_depth, edge->frequency,\n@@ -1358,14 +1358,14 @@ dump_inline_edge_summary (FILE *f, int indent, struct cgraph_node *node,\n void\n dump_inline_summary (FILE *f, struct cgraph_node *node)\n {\n-  if (node->symbol.definition)\n+  if (node->definition)\n     {\n       struct inline_summary *s = inline_summary (node);\n       size_time_entry *e;\n       int i;\n       fprintf (f, \"Inline summary for %s/%i\", cgraph_node_name (node),\n-\t       node->symbol.order);\n-      if (DECL_DISREGARD_INLINE_LIMITS (node->symbol.decl))\n+\t       node->order);\n+      if (DECL_DISREGARD_INLINE_LIMITS (node->decl))\n \tfprintf (f, \" always_inline\");\n       if (s->inlinable)\n \tfprintf (f, \" inlinable\");\n@@ -1434,7 +1434,7 @@ initialize_inline_failed (struct cgraph_edge *e)\n \n   if (e->indirect_unknown_callee)\n     e->inline_failed = CIF_INDIRECT_UNKNOWN_CALL;\n-  else if (!callee->symbol.definition)\n+  else if (!callee->definition)\n     e->inline_failed = CIF_BODY_NOT_AVAILABLE;\n   else if (callee->local.redefined_extern_inline)\n     e->inline_failed = CIF_REDEFINED_EXTERN_INLINE;\n@@ -1821,7 +1821,7 @@ compute_bb_predicates (struct cgraph_node *node,\n \t\t       struct ipa_node_params *parms_info,\n \t\t       struct inline_summary *summary)\n {\n-  struct function *my_function = DECL_STRUCT_FUNCTION (node->symbol.decl);\n+  struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);\n   bool done = false;\n   basic_block bb;\n \n@@ -2348,7 +2348,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n      <0,2>.  */\n   basic_block bb;\n   gimple_stmt_iterator bsi;\n-  struct function *my_function = DECL_STRUCT_FUNCTION (node->symbol.decl);\n+  struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);\n   int freq;\n   struct inline_summary *info = inline_summary (node);\n   struct predicate bb_predicate;\n@@ -2396,7 +2396,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   for (n = 0; n < nblocks; n++)\n     {\n       bb = BASIC_BLOCK (order[n]);\n-      freq = compute_call_stmt_bb_frequency (node->symbol.decl, bb);\n+      freq = compute_call_stmt_bb_frequency (node->decl, bb);\n \n       /* TODO: Obviously predicates can be propagated down across CFG.  */\n       if (parms_info)\n@@ -2743,7 +2743,7 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n     }\n \n   /* Even is_gimple_min_invariant rely on current_function_decl.  */\n-  push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \n   /* Estimate the stack size for the function if we're optimizing.  */\n   self_stack_size = optimize ? estimated_stack_frame_size (node) : 0;\n@@ -2753,13 +2753,13 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n \n   /* Can this function be inlined at all?  */\n   if (!optimize && !lookup_attribute (\"always_inline\",\n-\t\t\t\t      DECL_ATTRIBUTES (node->symbol.decl)))\n+\t\t\t\t      DECL_ATTRIBUTES (node->decl)))\n     info->inlinable = false;\n   else\n-    info->inlinable = tree_inlinable_function_p (node->symbol.decl);\n+    info->inlinable = tree_inlinable_function_p (node->decl);\n \n   /* Type attributes can use parameter indices to describe them.  */\n-  if (TYPE_ATTRIBUTES (TREE_TYPE (node->symbol.decl)))\n+  if (TYPE_ATTRIBUTES (TREE_TYPE (node->decl)))\n     node->local.can_change_signature = false;\n   else\n     {\n@@ -2771,7 +2771,7 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n \t  /* Functions calling builtin_apply can not change signature.  */\n \t  for (e = node->callees; e; e = e->next_callee)\n \t    {\n-\t      tree cdecl = e->callee->symbol.decl;\n+\t      tree cdecl = e->callee->decl;\n \t      if (DECL_BUILT_IN (cdecl)\n \t\t  && DECL_BUILT_IN_CLASS (cdecl) == BUILT_IN_NORMAL\n \t\t  && (DECL_FUNCTION_CODE (cdecl) == BUILT_IN_APPLY_ARGS\n@@ -2879,7 +2879,7 @@ estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n   gcc_checking_assert (*size >= 0);\n \n   callee = cgraph_get_node (target);\n-  if (!callee || !callee->symbol.definition)\n+  if (!callee || !callee->definition)\n     return false;\n   isummary = inline_summary (callee);\n   return isummary->inlinable;\n@@ -2985,7 +2985,7 @@ estimate_node_size_and_time (struct cgraph_node *node,\n       bool found = false;\n       fprintf (dump_file, \"   Estimating body: %s/%i\\n\"\n \t       \"   Known to be false: \", cgraph_node_name (node),\n-\t       node->symbol.order);\n+\t       node->order);\n \n       for (i = predicate_not_inlined_condition;\n \t   i < (predicate_first_dynamic_condition\n@@ -3036,7 +3036,7 @@ estimate_node_size_and_time (struct cgraph_node *node,\n     hints |= INLINE_HINT_array_index;\n   if (info->scc_no)\n     hints |= INLINE_HINT_in_scc;\n-  if (DECL_DECLARED_INLINE_P (node->symbol.decl))\n+  if (DECL_DECLARED_INLINE_P (node->decl))\n     hints |= INLINE_HINT_declared_inline;\n \n   estimate_calls_size_and_time (node, &size, &time, &hints, possible_truths,\n@@ -3496,8 +3496,8 @@ simple_edge_hints (struct cgraph_edge *edge)\n       && !cgraph_edge_recursive_p (edge))\n     hints |= INLINE_HINT_same_scc;\n \n-  if (to->symbol.lto_file_data && edge->callee->symbol.lto_file_data\n-      && to->symbol.lto_file_data != edge->callee->symbol.lto_file_data)\n+  if (to->lto_file_data && edge->callee->lto_file_data\n+      && to->lto_file_data != edge->callee->lto_file_data)\n     hints |= INLINE_HINT_cross_module;\n \n   return hints;\n@@ -3716,7 +3716,7 @@ do_estimate_growth (struct cgraph_node *node)\n      return zero or negative growths. */\n   if (d.self_recursive)\n     d.growth = d.growth < info->size ? info->size : d.growth;\n-  else if (DECL_EXTERNAL (node->symbol.decl))\n+  else if (DECL_EXTERNAL (node->decl))\n     ;\n   else\n     {\n@@ -3725,7 +3725,7 @@ do_estimate_growth (struct cgraph_node *node)\n       /* COMDAT functions are very often not shared across multiple units\n          since they come from various template instantiations.\n          Take this into account.  */\n-      else if (DECL_COMDAT (node->symbol.decl)\n+      else if (DECL_COMDAT (node->decl)\n \t       && cgraph_can_remove_if_no_direct_calls_p (node))\n \td.growth -= (info->size\n \t\t     * (100 - PARAM_VALUE (PARAM_COMDAT_SHARING_PROBABILITY))\n@@ -3762,11 +3762,11 @@ inline_indirect_intraprocedural_analysis (struct cgraph_node *node)\n static void\n inline_analyze_function (struct cgraph_node *node)\n {\n-  push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \n   if (dump_file)\n     fprintf (dump_file, \"\\nAnalyzing function: %s/%u\\n\",\n-\t     cgraph_node_name (node), node->symbol.order);\n+\t     cgraph_node_name (node), node->order);\n   if (optimize && !node->thunk.thunk_p)\n     inline_indirect_intraprocedural_analysis (node);\n   compute_inline_parameters (node, false);\n@@ -3819,7 +3819,7 @@ inline_generate_summary (void)\n   inline_free_summary ();\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (!node->symbol.alias)\n+    if (!node->alias)\n       inline_analyze_function (node);\n }\n \n@@ -4053,7 +4053,7 @@ inline_write_summary (void)\n     {\n       symtab_node snode = lto_symtab_encoder_deref (encoder, i);\n       cgraph_node *cnode = dyn_cast <cgraph_node> (snode);\n-      if (cnode && cnode->symbol.definition && !cnode->symbol.alias)\n+      if (cnode && cnode->definition && !cnode->alias)\n \tcount++;\n     }\n   streamer_write_uhwi (ob, count);\n@@ -4062,7 +4062,7 @@ inline_write_summary (void)\n     {\n       symtab_node snode = lto_symtab_encoder_deref (encoder, i);\n       cgraph_node *cnode = dyn_cast <cgraph_node> (snode);\n-      if (cnode && (node = cnode)->symbol.definition && !node->symbol.alias)\n+      if (cnode && (node = cnode)->definition && !node->alias)\n \t{\n \t  struct inline_summary *info = inline_summary (node);\n \t  struct bitpack_d bp;\n@@ -4073,7 +4073,7 @@ inline_write_summary (void)\n \n \t  streamer_write_uhwi (ob,\n \t\t\t       lto_symtab_encoder_encode (encoder,\n-\t\t\t\t\t\t\t  (symtab_node)\n+\t\t\t\t\t\t\t  \n \t\t\t\t\t\t\t  node));\n \t  streamer_write_hwi (ob, info->estimated_self_stack_size);\n \t  streamer_write_hwi (ob, info->self_size);"}, {"sha": "32f068e460e9235e5b6d144f36ea4c008726258a", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -85,15 +85,15 @@ can_remove_node_now_p_1 (struct cgraph_node *node)\n   /* FIXME: When address is taken of DECL_EXTERNAL function we still\n      can remove its offline copy, but we would need to keep unanalyzed node in\n      the callgraph so references can point to it.  */\n-  return (!node->symbol.address_taken\n-\t  && !ipa_ref_has_aliases_p (&node->symbol.ref_list)\n+  return (!node->address_taken\n+\t  && !ipa_ref_has_aliases_p (&node->ref_list)\n \t  && !node->used_as_abstract_origin\n \t  && cgraph_can_remove_if_no_direct_calls_p (node)\n \t  /* Inlining might enable more devirtualizing, so we want to remove\n \t     those only after all devirtualizable virtual calls are processed.\n \t     Lacking may edges in callgraph we just preserve them post\n \t     inlining.  */\n-\t  && !DECL_VIRTUAL_P (node->symbol.decl)\n+\t  && !DECL_VIRTUAL_P (node->decl)\n \t  /* During early inlining some unanalyzed cgraph nodes might be in the\n \t     callgraph and they might reffer the function in question.  */\n \t  && !cgraph_new_nodes);\n@@ -112,10 +112,10 @@ can_remove_node_now_p (struct cgraph_node *node, struct cgraph_edge *e)\n \n   /* When we see same comdat group, we need to be sure that all\n      items can be removed.  */\n-  if (!node->symbol.same_comdat_group)\n+  if (!node->same_comdat_group)\n     return true;\n-  for (next = cgraph (node->symbol.same_comdat_group);\n-       next != node; next = cgraph (next->symbol.same_comdat_group))\n+  for (next = cgraph (node->same_comdat_group);\n+       next != node; next = cgraph (next->same_comdat_group))\n     if ((next->callers && next->callers != e)\n \t|| !can_remove_node_now_p_1 (next))\n       return false;\n@@ -161,28 +161,28 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t     For now we keep the ohter functions in the group in program until\n \t     cgraph_remove_unreachable_functions gets rid of them.  */\n \t  gcc_assert (!e->callee->global.inlined_to);\n-          symtab_dissolve_same_comdat_group_list ((symtab_node) e->callee);\n-\t  if (e->callee->symbol.definition && !DECL_EXTERNAL (e->callee->symbol.decl))\n+          symtab_dissolve_same_comdat_group_list (e->callee);\n+\t  if (e->callee->definition && !DECL_EXTERNAL (e->callee->decl))\n \t    {\n \t      if (overall_size)\n \t        *overall_size -= inline_summary (e->callee)->size;\n \t      nfunctions_inlined++;\n \t    }\n \t  duplicate = false;\n-\t  e->callee->symbol.externally_visible = false;\n+\t  e->callee->externally_visible = false;\n           update_noncloned_frequencies (e->callee, e->frequency);\n \t}\n       else\n \t{\n \t  struct cgraph_node *n;\n-\t  n = cgraph_clone_node (e->callee, e->callee->symbol.decl,\n+\t  n = cgraph_clone_node (e->callee, e->callee->decl,\n \t\t\t\t e->count, e->frequency, update_original,\n \t\t\t\t vNULL, true, inlining_into);\n \t  cgraph_redirect_edge_callee (e, n);\n \t}\n     }\n   else\n-    symtab_dissolve_same_comdat_group_list ((symtab_node) e->callee);\n+    symtab_dissolve_same_comdat_group_list (e->callee);\n \n   e->callee->global.inlined_to = inlining_into;\n \n@@ -234,7 +234,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n   gcc_assert (!callee->global.inlined_to);\n \n   e->inline_failed = CIF_OK;\n-  DECL_POSSIBLY_INLINED (callee->symbol.decl) = true;\n+  DECL_POSSIBLY_INLINED (callee->decl) = true;\n \n   to = e->caller;\n   if (to->global.inlined_to)\n@@ -286,7 +286,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n   /* Account the change of overall unit size; external functions will be\n      removed and are thus not accounted.  */\n   if (overall_size\n-      && !DECL_EXTERNAL (to->symbol.decl))\n+      && !DECL_EXTERNAL (to->decl))\n     *overall_size += new_size - old_size;\n   ncalls_inlined++;\n \n@@ -312,13 +312,13 @@ save_inline_function_body (struct cgraph_node *node)\n     fprintf (dump_file, \"\\nSaving body of %s for later reuse\\n\",\n \t     cgraph_node_name (node));\n  \n-  gcc_assert (node == cgraph_get_node (node->symbol.decl));\n+  gcc_assert (node == cgraph_get_node (node->decl));\n \n   /* first_clone will be turned into real function.  */\n   first_clone = node->clones;\n-  first_clone->symbol.decl = copy_node (node->symbol.decl);\n-  symtab_insert_node_to_hashtable ((symtab_node) first_clone);\n-  gcc_assert (first_clone == cgraph_get_node (first_clone->symbol.decl));\n+  first_clone->decl = copy_node (node->decl);\n+  symtab_insert_node_to_hashtable (first_clone);\n+  gcc_assert (first_clone == cgraph_get_node (first_clone->decl));\n \n   /* Now reshape the clone tree, so all other clones descends from\n      first_clone.  */\n@@ -346,8 +346,8 @@ save_inline_function_body (struct cgraph_node *node)\n   if (first_clone->clones)\n     for (n = first_clone->clones; n != first_clone;)\n       {\n-        gcc_assert (n->symbol.decl == node->symbol.decl);\n-\tn->symbol.decl = first_clone->symbol.decl;\n+        gcc_assert (n->decl == node->decl);\n+\tn->decl = first_clone->decl;\n \tif (n->clones)\n \t  n = n->clones;\n \telse if (n->next_sibling_clone)\n@@ -362,16 +362,16 @@ save_inline_function_body (struct cgraph_node *node)\n       }\n \n   /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n-  tree_function_versioning (node->symbol.decl, first_clone->symbol.decl,\n+  tree_function_versioning (node->decl, first_clone->decl,\n \t\t\t    NULL, true, NULL, false,\n \t\t\t    NULL, NULL);\n \n   /* The function will be short lived and removed after we inline all the clones,\n      but make it internal so we won't confuse ourself.  */\n-  DECL_EXTERNAL (first_clone->symbol.decl) = 0;\n-  DECL_COMDAT_GROUP (first_clone->symbol.decl) = NULL_TREE;\n-  TREE_PUBLIC (first_clone->symbol.decl) = 0;\n-  DECL_COMDAT (first_clone->symbol.decl) = 0;\n+  DECL_EXTERNAL (first_clone->decl) = 0;\n+  DECL_COMDAT_GROUP (first_clone->decl) = NULL_TREE;\n+  TREE_PUBLIC (first_clone->decl) = 0;\n+  DECL_COMDAT (first_clone->decl) = 0;\n   first_clone->ipa_transforms_to_apply.release ();\n \n   /* When doing recursive inlining, the clone may become unnecessary.\n@@ -397,7 +397,7 @@ static bool\n preserve_function_body_p (struct cgraph_node *node)\n {\n   gcc_assert (cgraph_global_info_ready);\n-  gcc_assert (!node->symbol.alias && !node->thunk.thunk_p);\n+  gcc_assert (!node->alias && !node->thunk.thunk_p);\n \n   /* Look if there is any clone around.  */\n   if (node->clones)\n@@ -428,7 +428,7 @@ inline_transform (struct cgraph_node *node)\n       next = e->next_callee;\n       cgraph_redirect_edge_call_stmt_to_callee (e);\n     }\n-  ipa_remove_all_references (&node->symbol.ref_list);\n+  ipa_remove_all_references (&node->ref_list);\n \n   timevar_push (TV_INTEGRATION);\n   if (node->callees && optimize)"}, {"sha": "784094b4948e26a68ddb7c4fcfb89d8572926e41", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 84, "deletions": 84, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -221,8 +221,8 @@ report_inline_failed_reason (struct cgraph_edge *e)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"  not inlinable: %s/%i -> %s/%i, %s\\n\",\n-\t       xstrdup (cgraph_node_name (e->caller)), e->caller->symbol.order,\n-\t       xstrdup (cgraph_node_name (e->callee)), e->callee->symbol.order,\n+\t       xstrdup (cgraph_node_name (e->caller)), e->caller->order,\n+\t       xstrdup (cgraph_node_name (e->callee)), e->callee->order,\n \t       cgraph_inline_failed_string (e->inline_failed));\n     }\n }\n@@ -244,22 +244,22 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n   enum availability avail;\n   struct cgraph_node *callee\n     = cgraph_function_or_thunk_node (e->callee, &avail);\n-  tree caller_tree = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (e->caller->symbol.decl);\n+  tree caller_tree = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (e->caller->decl);\n   tree callee_tree\n-    = callee ? DECL_FUNCTION_SPECIFIC_OPTIMIZATION (callee->symbol.decl) : NULL;\n-  struct function *caller_cfun = DECL_STRUCT_FUNCTION (e->caller->symbol.decl);\n+    = callee ? DECL_FUNCTION_SPECIFIC_OPTIMIZATION (callee->decl) : NULL;\n+  struct function *caller_cfun = DECL_STRUCT_FUNCTION (e->caller->decl);\n   struct function *callee_cfun\n-    = callee ? DECL_STRUCT_FUNCTION (callee->symbol.decl) : NULL;\n+    = callee ? DECL_STRUCT_FUNCTION (callee->decl) : NULL;\n \n   if (!caller_cfun && e->caller->clone_of)\n-    caller_cfun = DECL_STRUCT_FUNCTION (e->caller->clone_of->symbol.decl);\n+    caller_cfun = DECL_STRUCT_FUNCTION (e->caller->clone_of->decl);\n \n   if (!callee_cfun && callee && callee->clone_of)\n-    callee_cfun = DECL_STRUCT_FUNCTION (callee->clone_of->symbol.decl);\n+    callee_cfun = DECL_STRUCT_FUNCTION (callee->clone_of->decl);\n \n   gcc_assert (e->inline_failed);\n \n-  if (!callee || !callee->symbol.definition)\n+  if (!callee || !callee->definition)\n     {\n       e->inline_failed = CIF_BODY_NOT_AVAILABLE;\n       inlinable = false;\n@@ -281,18 +281,18 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n       inlinable = false;\n     }\n   /* Don't inline if the functions have different EH personalities.  */\n-  else if (DECL_FUNCTION_PERSONALITY (e->caller->symbol.decl)\n-\t   && DECL_FUNCTION_PERSONALITY (callee->symbol.decl)\n-\t   && (DECL_FUNCTION_PERSONALITY (e->caller->symbol.decl)\n-\t       != DECL_FUNCTION_PERSONALITY (callee->symbol.decl)))\n+  else if (DECL_FUNCTION_PERSONALITY (e->caller->decl)\n+\t   && DECL_FUNCTION_PERSONALITY (callee->decl)\n+\t   && (DECL_FUNCTION_PERSONALITY (e->caller->decl)\n+\t       != DECL_FUNCTION_PERSONALITY (callee->decl)))\n     {\n       e->inline_failed = CIF_EH_PERSONALITY;\n       inlinable = false;\n     }\n   /* TM pure functions should not be inlined into non-TM_pure\n      functions.  */\n-  else if (is_tm_pure (callee->symbol.decl)\n-\t   && !is_tm_pure (e->caller->symbol.decl))\n+  else if (is_tm_pure (callee->decl)\n+\t   && !is_tm_pure (e->caller->decl))\n     {\n       e->inline_failed = CIF_UNSPECIFIED;\n       inlinable = false;\n@@ -308,20 +308,20 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n       inlinable = false;\n     }\n   /* Check compatibility of target optimization options.  */\n-  else if (!targetm.target_option.can_inline_p (e->caller->symbol.decl,\n-\t\t\t\t\t\tcallee->symbol.decl))\n+  else if (!targetm.target_option.can_inline_p (e->caller->decl,\n+\t\t\t\t\t\tcallee->decl))\n     {\n       e->inline_failed = CIF_TARGET_OPTION_MISMATCH;\n       inlinable = false;\n     }\n   /* Check if caller growth allows the inlining.  */\n-  else if (!DECL_DISREGARD_INLINE_LIMITS (callee->symbol.decl)\n+  else if (!DECL_DISREGARD_INLINE_LIMITS (callee->decl)\n \t   && !disregard_limits\n \t   && !lookup_attribute (\"flatten\",\n \t\t\t\t DECL_ATTRIBUTES\n \t\t\t\t   (e->caller->global.inlined_to\n-\t\t\t\t    ? e->caller->global.inlined_to->symbol.decl\n-\t\t\t\t    : e->caller->symbol.decl))\n+\t\t\t\t    ? e->caller->global.inlined_to->decl\n+\t\t\t\t    : e->caller->decl))\n            && !caller_growth_limits (e))\n     inlinable = false;\n   /* Don't inline a function with a higher optimization level than the\n@@ -342,7 +342,7 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n       if (((caller_opt->x_optimize > callee_opt->x_optimize)\n \t   || (caller_opt->x_optimize_size != callee_opt->x_optimize_size))\n \t  /* gcc.dg/pr43564.c.  Look at forced inline even in -O0.  */\n-\t  && !DECL_DISREGARD_INLINE_LIMITS (e->callee->symbol.decl))\n+\t  && !DECL_DISREGARD_INLINE_LIMITS (e->callee->decl))\n \t{\n \t  e->inline_failed = CIF_OPTIMIZATION_MISMATCH;\n \t  inlinable = false;\n@@ -365,7 +365,7 @@ can_early_inline_edge_p (struct cgraph_edge *e)\n   /* Early inliner might get called at WPA stage when IPA pass adds new\n      function.  In this case we can not really do any of early inlining\n      because function bodies are missing.  */\n-  if (!gimple_has_body_p (callee->symbol.decl))\n+  if (!gimple_has_body_p (callee->decl))\n     {\n       e->inline_failed = CIF_BODY_NOT_AVAILABLE;\n       return false;\n@@ -374,8 +374,8 @@ can_early_inline_edge_p (struct cgraph_edge *e)\n      (i.e. the callgraph is cyclic and we did not process\n      the callee by early inliner, yet).  We don't have CIF code for this\n      case; later we will re-do the decision in the real inliner.  */\n-  if (!gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->caller->symbol.decl))\n-      || !gimple_in_ssa_p (DECL_STRUCT_FUNCTION (callee->symbol.decl)))\n+  if (!gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->caller->decl))\n+      || !gimple_in_ssa_p (DECL_STRUCT_FUNCTION (callee->decl)))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"  edge not inlinable: not in SSA form\\n\");\n@@ -396,7 +396,7 @@ num_calls (struct cgraph_node *n)\n   int num = 0;\n \n   for (e = n->callees; e; e = e->next_callee)\n-    if (!is_inexpensive_builtin (e->callee->symbol.decl))\n+    if (!is_inexpensive_builtin (e->callee->decl))\n       num++;\n   return num;\n }\n@@ -410,9 +410,9 @@ want_early_inline_function_p (struct cgraph_edge *e)\n   bool want_inline = true;\n   struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n \n-  if (DECL_DISREGARD_INLINE_LIMITS (callee->symbol.decl))\n+  if (DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n     ;\n-  else if (!DECL_DECLARED_INLINE_P (callee->symbol.decl)\n+  else if (!DECL_DECLARED_INLINE_P (callee->decl)\n \t   && !flag_inline_small_functions)\n     {\n       e->inline_failed = CIF_FUNCTION_NOT_INLINE_CANDIDATE;\n@@ -433,8 +433,8 @@ want_early_inline_function_p (struct cgraph_edge *e)\n \t    fprintf (dump_file, \"  will not early inline: %s/%i->%s/%i, \"\n \t\t     \"call is cold and code would grow by %i\\n\",\n \t\t     xstrdup (cgraph_node_name (e->caller)),\n-\t\t     e->caller->symbol.order,\n-\t\t     xstrdup (cgraph_node_name (callee)), callee->symbol.order,\n+\t\t     e->caller->order,\n+\t\t     xstrdup (cgraph_node_name (callee)), callee->order,\n \t\t     growth);\n \t  want_inline = false;\n \t}\n@@ -444,8 +444,8 @@ want_early_inline_function_p (struct cgraph_edge *e)\n \t    fprintf (dump_file, \"  will not early inline: %s/%i->%s/%i, \"\n \t\t     \"growth %i exceeds --param early-inlining-insns\\n\",\n \t\t     xstrdup (cgraph_node_name (e->caller)),\n-\t\t     e->caller->symbol.order,\n-\t\t     xstrdup (cgraph_node_name (callee)), callee->symbol.order,\n+\t\t     e->caller->order,\n+\t\t     xstrdup (cgraph_node_name (callee)), callee->order,\n \t\t     growth);\n \t  want_inline = false;\n \t}\n@@ -457,8 +457,8 @@ want_early_inline_function_p (struct cgraph_edge *e)\n \t\t     \"growth %i exceeds --param early-inlining-insns \"\n \t\t     \"divided by number of calls\\n\",\n \t\t     xstrdup (cgraph_node_name (e->caller)),\n-\t\t     e->caller->symbol.order,\n-\t\t     xstrdup (cgraph_node_name (callee)), callee->symbol.order,\n+\t\t     e->caller->order,\n+\t\t     xstrdup (cgraph_node_name (callee)), callee->order,\n \t\t     growth);\n \t  want_inline = false;\n \t}\n@@ -528,9 +528,9 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n   bool want_inline = true;\n   struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n \n-  if (DECL_DISREGARD_INLINE_LIMITS (callee->symbol.decl))\n+  if (DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n     ;\n-  else if (!DECL_DECLARED_INLINE_P (callee->symbol.decl)\n+  else if (!DECL_DECLARED_INLINE_P (callee->decl)\n \t   && !flag_inline_small_functions)\n     {\n       e->inline_failed = CIF_FUNCTION_NOT_INLINE_CANDIDATE;\n@@ -546,7 +546,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t;\n       /* Apply MAX_INLINE_INSNS_SINGLE limit.  Do not do so when\n \t hints suggests that inlining given function is very profitable.  */\n-      else if (DECL_DECLARED_INLINE_P (callee->symbol.decl)\n+      else if (DECL_DECLARED_INLINE_P (callee->decl)\n \t       && growth >= MAX_INLINE_INSNS_SINGLE\n \t       && !big_speedup\n \t       && !(hints & (INLINE_HINT_indirect_call\n@@ -589,11 +589,11 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t\t  Consequently we ask cgraph_can_remove_if_no_direct_calls_p\n \t\t  instead of\n \t\t  cgraph_will_be_removed_from_program_if_no_direct_calls  */\n-\t        && !DECL_EXTERNAL (callee->symbol.decl)\n+\t        && !DECL_EXTERNAL (callee->decl)\n \t\t&& cgraph_can_remove_if_no_direct_calls_p (callee)\n \t\t&& estimate_growth (callee) <= 0)\n \t;\n-      else if (!DECL_DECLARED_INLINE_P (callee->symbol.decl)\n+      else if (!DECL_DECLARED_INLINE_P (callee->decl)\n \t       && !flag_inline_functions)\n \t{\n           e->inline_failed = CIF_NOT_DECLARED_INLINED;\n@@ -602,7 +602,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n       /* Apply MAX_INLINE_INSNS_AUTO limit for functions not declared inline\n \t Upgrade it to MAX_INLINE_INSNS_SINGLE when hints suggests that\n \t inlining given function is very profitable.  */\n-      else if (!DECL_DECLARED_INLINE_P (callee->symbol.decl)\n+      else if (!DECL_DECLARED_INLINE_P (callee->decl)\n \t       && !big_speedup\n \t       && growth >= ((hints & (INLINE_HINT_indirect_call\n \t\t\t\t       | INLINE_HINT_loop_iterations\n@@ -649,7 +649,7 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n   int caller_freq = CGRAPH_FREQ_BASE;\n   int max_depth = PARAM_VALUE (PARAM_MAX_INLINE_RECURSIVE_DEPTH_AUTO);\n \n-  if (DECL_DECLARED_INLINE_P (edge->caller->symbol.decl))\n+  if (DECL_DECLARED_INLINE_P (edge->caller->decl))\n     max_depth = PARAM_VALUE (PARAM_MAX_INLINE_RECURSIVE_DEPTH);\n \n   if (!cgraph_maybe_hot_edge_p (edge))\n@@ -815,8 +815,8 @@ relative_time_benefit (struct inline_summary *callee_info,\n \n   /* Inlining into extern inline function is not a win.  */\n   if (DECL_EXTERNAL (edge->caller->global.inlined_to\n-\t\t     ? edge->caller->global.inlined_to->symbol.decl\n-\t\t     : edge->caller->symbol.decl))\n+\t\t     ? edge->caller->global.inlined_to->decl\n+\t\t     : edge->caller->decl))\n     return 1;\n \n   /* Watch overflows.  */\n@@ -855,7 +855,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n   struct inline_summary *callee_info = inline_summary (callee);\n   inline_hints hints;\n \n-  if (DECL_DISREGARD_INLINE_LIMITS (callee->symbol.decl))\n+  if (DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n     return INT_MIN;\n \n   growth = estimate_edge_growth (edge);\n@@ -869,9 +869,9 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n     {\n       fprintf (dump_file, \"    Badness calculation for %s/%i -> %s/%i\\n\",\n \t       xstrdup (cgraph_node_name (edge->caller)),\n-\t       edge->caller->symbol.order,\n+\t       edge->caller->order,\n \t       xstrdup (cgraph_node_name (callee)),\n-\t       edge->callee->symbol.order);\n+\t       edge->callee->order);\n       fprintf (dump_file, \"      size growth %i, time %i \",\n \t       growth,\n \t       edge_time);\n@@ -1036,9 +1036,9 @@ update_edge_key (fibheap_t heap, struct cgraph_edge *edge)\n \t      fprintf (dump_file,\n \t\t       \"  decreasing badness %s/%i -> %s/%i, %i to %i\\n\",\n \t\t       xstrdup (cgraph_node_name (edge->caller)),\n-\t\t       edge->caller->symbol.order,\n+\t\t       edge->caller->order,\n \t\t       xstrdup (cgraph_node_name (edge->callee)),\n-\t\t       edge->callee->symbol.order,\n+\t\t       edge->callee->order,\n \t\t       (int)n->key,\n \t\t       badness);\n \t    }\n@@ -1053,9 +1053,9 @@ update_edge_key (fibheap_t heap, struct cgraph_edge *edge)\n \t   fprintf (dump_file,\n \t\t    \"  enqueuing call %s/%i -> %s/%i, badness %i\\n\",\n \t\t    xstrdup (cgraph_node_name (edge->caller)),\n-\t\t    edge->caller->symbol.order,\n+\t\t    edge->caller->order,\n \t\t    xstrdup (cgraph_node_name (edge->callee)),\n-\t\t    edge->callee->symbol.order,\n+\t\t    edge->callee->order,\n \t\t    badness);\n \t }\n       edge->aux = fibheap_insert (heap, badness, edge);\n@@ -1086,7 +1086,7 @@ reset_edge_caches (struct cgraph_node *node)\n   for (edge = where->callers; edge; edge = edge->next_caller)\n     if (edge->inline_failed)\n       reset_edge_growth_cache (edge);\n-  for (i = 0; ipa_ref_list_referring_iterate (&where->symbol.ref_list,\n+  for (i = 0; ipa_ref_list_referring_iterate (&where->ref_list,\n \t\t\t\t\t      i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       reset_edge_caches (ipa_ref_referring_node (ref));\n@@ -1131,13 +1131,13 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n   int i;\n   struct ipa_ref *ref;\n \n-  if ((!node->symbol.alias && !inline_summary (node)->inlinable)\n+  if ((!node->alias && !inline_summary (node)->inlinable)\n       || node->global.inlined_to)\n     return;\n   if (!bitmap_set_bit (updated_nodes, node->uid))\n     return;\n \n-  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list,\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list,\n \t\t\t\t\t      i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n@@ -1269,7 +1269,7 @@ recursive_inlining (struct cgraph_edge *edge,\n   if (node->global.inlined_to)\n     node = node->global.inlined_to;\n \n-  if (DECL_DECLARED_INLINE_P (node->symbol.decl))\n+  if (DECL_DECLARED_INLINE_P (node->decl))\n     limit = PARAM_VALUE (PARAM_MAX_INLINE_INSNS_RECURSIVE);\n \n   /* Make sure that function is small enough to be considered for inlining.  */\n@@ -1318,8 +1318,8 @@ recursive_inlining (struct cgraph_edge *edge,\n       depth = 1;\n       for (cnode = curr->caller;\n \t   cnode->global.inlined_to; cnode = cnode->callers->caller)\n-\tif (node->symbol.decl\n-\t    == cgraph_function_or_thunk_node (curr->callee, NULL)->symbol.decl)\n+\tif (node->decl\n+\t    == cgraph_function_or_thunk_node (curr->callee, NULL)->decl)\n           depth++;\n \n       if (!want_inline_self_recursive_call_p (curr, node, false, depth))\n@@ -1343,7 +1343,7 @@ recursive_inlining (struct cgraph_edge *edge,\n       if (!master_clone)\n \t{\n \t  /* We need original clone to copy around.  */\n-\t  master_clone = cgraph_clone_node (node, node->symbol.decl,\n+\t  master_clone = cgraph_clone_node (node, node->decl,\n \t\t\t\t\t    node->count, CGRAPH_FREQ_BASE,\n \t\t\t\t\t    false, vNULL, true, NULL);\n \t  for (e = master_clone->callees; e; e = e->next_callee)\n@@ -1455,7 +1455,7 @@ speculation_useful_p (struct cgraph_edge *e, bool anticipate_inlining)\n      else we propagate is useless.  */\n   if (avail >= AVAIL_AVAILABLE)\n     {\n-      int ecf_flags = flags_from_decl_or_type (target->symbol.decl);\n+      int ecf_flags = flags_from_decl_or_type (target->decl);\n       if (ecf_flags & ECF_CONST)\n         {\n           cgraph_speculative_call_info (e, direct, indirect, ref);\n@@ -1545,17 +1545,17 @@ inline_small_functions (void)\n \t    || node->thunk.thunk_p)\n \t  {\n \t    struct inline_summary *info = inline_summary (node);\n-\t    struct ipa_dfs_info *dfs = (struct ipa_dfs_info *) node->symbol.aux;\n+\t    struct ipa_dfs_info *dfs = (struct ipa_dfs_info *) node->aux;\n \n-\t    if (!DECL_EXTERNAL (node->symbol.decl))\n+\t    if (!DECL_EXTERNAL (node->decl))\n \t      initial_size += info->size;\n \t    info->growth = estimate_growth (node);\n \t    if (dfs && dfs->next_cycle)\n \t      {\n \t\tstruct cgraph_node *n2;\n \t\tint id = dfs->scc_no + 1;\n \t\tfor (n2 = node; n2;\n-\t\t     n2 = ((struct ipa_dfs_info *) node->symbol.aux)->next_cycle)\n+\t\t     n2 = ((struct ipa_dfs_info *) node->aux)->next_cycle)\n \t\t  {\n \t\t    struct inline_summary *info2 = inline_summary (n2);\n \t\t    if (info2->scc_no)\n@@ -1593,7 +1593,7 @@ inline_small_functions (void)\n \n       if (dump_file)\n \tfprintf (dump_file, \"Enqueueing calls in %s/%i.\\n\",\n-\t\t cgraph_node_name (node), node->symbol.order);\n+\t\t cgraph_node_name (node), node->order);\n \n       for (edge = node->callees; edge; edge = next)\n \t{\n@@ -1676,13 +1676,13 @@ inline_small_functions (void)\n \t{\n \t  fprintf (dump_file,\n \t\t   \"\\nConsidering %s/%i with %i size\\n\",\n-\t\t   cgraph_node_name (callee), callee->symbol.order,\n+\t\t   cgraph_node_name (callee), callee->order,\n \t\t   inline_summary (callee)->size);\n \t  fprintf (dump_file,\n \t\t   \" to be inlined into %s/%i in %s:%i\\n\"\n \t\t   \" Estimated growth after inlined into all is %+i insns.\\n\"\n \t\t   \" Estimated badness is %i, frequency %.2f.\\n\",\n-\t\t   cgraph_node_name (edge->caller), edge->caller->symbol.order,\n+\t\t   cgraph_node_name (edge->caller), edge->caller->order,\n \t\t   flag_wpa ? \"unknown\"\n \t\t   : gimple_filename ((const_gimple) edge->call_stmt),\n \t\t   flag_wpa ? -1\n@@ -1698,7 +1698,7 @@ inline_small_functions (void)\n \t}\n \n       if (overall_size + growth > max_size\n-\t  && !DECL_DISREGARD_INLINE_LIMITS (callee->symbol.decl))\n+\t  && !DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n \t{\n \t  edge->inline_failed = CIF_INLINE_UNIT_GROWTH_LIMIT;\n \t  report_inline_failed_reason (edge);\n@@ -1750,7 +1750,7 @@ inline_small_functions (void)\n \t  where = edge->caller;\n \t  while (where->global.inlined_to)\n \t    {\n-\t      if (where->symbol.decl == callee->symbol.decl)\n+\t      if (where->decl == callee->decl)\n \t\touter_node = where, depth++;\n \t      where = where->callers->caller;\n \t    }\n@@ -1759,7 +1759,7 @@ inline_small_functions (void)\n \t\t\t\t\t\t     true, depth))\n \t    {\n \t      edge->inline_failed\n-\t\t= (DECL_DISREGARD_INLINE_LIMITS (edge->callee->symbol.decl)\n+\t\t= (DECL_DISREGARD_INLINE_LIMITS (edge->callee->decl)\n \t\t   ? CIF_RECURSIVE_INLINING : CIF_UNSPECIFIED);\n \t      resolve_noninline_speculation (edge_heap, edge);\n \t      continue;\n@@ -1831,17 +1831,17 @@ flatten_function (struct cgraph_node *node, bool early)\n   struct cgraph_edge *e;\n \n   /* We shouldn't be called recursively when we are being processed.  */\n-  gcc_assert (node->symbol.aux == NULL);\n+  gcc_assert (node->aux == NULL);\n \n-  node->symbol.aux = (void *) node;\n+  node->aux = (void *) node;\n \n   for (e = node->callees; e; e = e->next_callee)\n     {\n       struct cgraph_node *orig_callee;\n       struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n \n       /* We've hit cycle?  It is time to give up.  */\n-      if (callee->symbol.aux)\n+      if (callee->aux)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file,\n@@ -1875,8 +1875,8 @@ flatten_function (struct cgraph_node *node, bool early)\n \t  continue;\n \t}\n \n-      if (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->symbol.decl))\n-\t  != gimple_in_ssa_p (DECL_STRUCT_FUNCTION (callee->symbol.decl)))\n+      if (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n+\t  != gimple_in_ssa_p (DECL_STRUCT_FUNCTION (callee->decl)))\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Not inlining: SSA form does not match.\\n\");\n@@ -1892,13 +1892,13 @@ flatten_function (struct cgraph_node *node, bool early)\n       orig_callee = callee;\n       inline_call (e, true, NULL, NULL, false);\n       if (e->callee != orig_callee)\n-\torig_callee->symbol.aux = (void *) node;\n+\torig_callee->aux = (void *) node;\n       flatten_function (e->callee, early);\n       if (e->callee != orig_callee)\n-\torig_callee->symbol.aux = NULL;\n+\torig_callee->aux = NULL;\n     }\n \n-  node->symbol.aux = NULL;\n+  node->aux = NULL;\n   if (!node->global.inlined_to)\n     inline_update_overall_summary (node);\n }\n@@ -1984,7 +1984,7 @@ ipa_inline (void)\n   nnodes = ipa_reverse_postorder (order);\n \n   FOR_EACH_FUNCTION (node)\n-    node->symbol.aux = 0;\n+    node->aux = 0;\n \n   if (dump_file)\n     fprintf (dump_file, \"\\nFlattening functions:\\n\");\n@@ -2001,7 +2001,7 @@ ipa_inline (void)\n \t try to flatten itself turning it into a self-recursive\n \t function.  */\n       if (lookup_attribute (\"flatten\",\n-\t\t\t    DECL_ATTRIBUTES (node->symbol.decl)) != NULL)\n+\t\t\t    DECL_ATTRIBUTES (node->decl)) != NULL)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file,\n@@ -2106,7 +2106,7 @@ inline_always_inline_functions (struct cgraph_node *node)\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n-      if (!DECL_DISREGARD_INLINE_LIMITS (callee->symbol.decl))\n+      if (!DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n \tcontinue;\n \n       if (cgraph_edge_recursive_p (e))\n@@ -2124,7 +2124,7 @@ inline_always_inline_functions (struct cgraph_node *node)\n \t     is not inlinable.  This will allow flagging an error later in\n \t     expand_call_inline in tree-inline.c.  */\n \t  if (lookup_attribute (\"always_inline\",\n-\t\t\t\t DECL_ATTRIBUTES (callee->symbol.decl)) != NULL)\n+\t\t\t\t DECL_ATTRIBUTES (callee->decl)) != NULL)\n \t    inlined = true;\n \t  continue;\n \t}\n@@ -2159,7 +2159,7 @@ early_inline_small_functions (struct cgraph_node *node)\n \tcontinue;\n \n       /* Do not consider functions not declared inline.  */\n-      if (!DECL_DECLARED_INLINE_P (callee->symbol.decl)\n+      if (!DECL_DECLARED_INLINE_P (callee->decl)\n \t  && !flag_inline_small_functions\n \t  && !flag_inline_functions)\n \tcontinue;\n@@ -2219,7 +2219,7 @@ early_inliner (void)\n #ifdef ENABLE_CHECKING\n   verify_cgraph_node (node);\n #endif\n-  ipa_remove_all_references (&node->symbol.ref_list);\n+  ipa_remove_all_references (&node->ref_list);\n \n   /* Even when not optimizing or not inlining inline always-inline\n      functions.  */\n@@ -2236,10 +2236,10 @@ early_inliner (void)\n \t cycles of edges to be always inlined in the callgraph.\n \n \t We might want to be smarter and just avoid this type of inlining.  */\n-      || DECL_DISREGARD_INLINE_LIMITS (node->symbol.decl))\n+      || DECL_DISREGARD_INLINE_LIMITS (node->decl))\n     ;\n   else if (lookup_attribute (\"flatten\",\n-\t\t\t     DECL_ATTRIBUTES (node->symbol.decl)) != NULL)\n+\t\t\t     DECL_ATTRIBUTES (node->decl)) != NULL)\n     {\n       /* When the function is marked to be flattened, recursively inline\n \t all calls in it.  */\n@@ -2270,9 +2270,9 @@ early_inliner (void)\n \t\t= estimate_num_insns (edge->call_stmt, &eni_size_weights);\n \t      es->call_stmt_time\n \t\t= estimate_num_insns (edge->call_stmt, &eni_time_weights);\n-\t      if (edge->callee->symbol.decl\n+\t      if (edge->callee->decl\n \t\t  && !gimple_check_call_matching_types (\n-\t\t      edge->call_stmt, edge->callee->symbol.decl, false))\n+\t\t      edge->call_stmt, edge->callee->decl, false))\n \t\tedge->call_stmt_cannot_inline_p = true;\n \t    }\n \t  timevar_pop (TV_INTEGRATION);"}, {"sha": "1260069207e14d41d8c4442bfeb01180b17a5819", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -185,7 +185,7 @@ ipa_profile_generate_summary (void)\n \t\t\t\t      10);\n   \n   FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n-    FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (node->symbol.decl))\n+    FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (node->decl))\n       {\n \tint time = 0;\n \tint size = 0;\n@@ -197,7 +197,7 @@ ipa_profile_generate_summary (void)\n \t      {\n \t\thistogram_value h;\n \t\th = gimple_histogram_value_of_type\n-\t\t      (DECL_STRUCT_FUNCTION (node->symbol.decl),\n+\t\t      (DECL_STRUCT_FUNCTION (node->decl),\n \t\t       stmt, HIST_TYPE_INDIR_CALL);\n \t\t/* No need to do sanity check: gimple_ic_transform already\n \t\t   takes away bad histograms.  */\n@@ -219,7 +219,7 @@ ipa_profile_generate_summary (void)\n \t\t\t    e->indirect_info->common_target_probability = REG_BR_PROB_BASE;\n \t\t\t  }\n \t\t      }\n-\t\t    gimple_remove_histogram_value (DECL_STRUCT_FUNCTION (node->symbol.decl),\n+\t\t    gimple_remove_histogram_value (DECL_STRUCT_FUNCTION (node->decl),\n \t\t\t\t\t\t    stmt, h);\n \t\t  }\n \t      }\n@@ -325,7 +325,7 @@ ipa_propagate_frequency_1 (struct cgraph_node *node, void *data)\n \t  /* It makes sense to put main() together with the static constructors.\n \t     It will be executed for sure, but rest of functions called from\n \t     main are definitely not at startup only.  */\n-\t  if (MAIN_NAME_P (DECL_NAME (edge->caller->symbol.decl)))\n+\t  if (MAIN_NAME_P (DECL_NAME (edge->caller->decl)))\n \t    d->only_called_at_startup = 0;\n           d->only_called_at_exit &= edge->caller->only_called_at_exit;\n \t}\n@@ -401,10 +401,10 @@ ipa_propagate_frequency (struct cgraph_node *node)\n   /* We can not propagate anything useful about externally visible functions\n      nor about virtuals.  */\n   if (!node->local.local\n-      || node->symbol.alias\n-      || (flag_devirtualize && DECL_VIRTUAL_P (node->symbol.decl)))\n+      || node->alias\n+      || (flag_devirtualize && DECL_VIRTUAL_P (node->decl)))\n     return false;\n-  gcc_assert (node->symbol.analyzed);\n+  gcc_assert (node->analyzed);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Processing frequency %s\\n\", cgraph_node_name (node));\n \n@@ -589,8 +589,8 @@ ipa_profile (void)\n \t\t    {\n \t\t      fprintf (dump_file, \"Indirect call -> direct call from\"\n \t\t\t       \" other module %s/%i => %s/%i, prob %3.2f\\n\",\n-\t\t\t       xstrdup (cgraph_node_name (n)), n->symbol.order,\n-\t\t\t       xstrdup (cgraph_node_name (n2)), n2->symbol.order,\n+\t\t\t       xstrdup (cgraph_node_name (n)), n->order,\n+\t\t\t       xstrdup (cgraph_node_name (n2)), n2->order,\n \t\t\t       e->indirect_info->common_target_probability\n \t\t\t       / (float)REG_BR_PROB_BASE);\n \t\t    }\n@@ -611,7 +611,7 @@ ipa_profile (void)\n \t\t    }\n \t\t  else if (cgraph_function_body_availability (n2)\n \t\t\t   <= AVAIL_OVERWRITABLE\n-\t\t\t   && symtab_can_be_discarded ((symtab_node) n2))\n+\t\t\t   && symtab_can_be_discarded (n2))\n \t\t    {\n \t\t      nuseless++;\n \t\t      if (dump_file)\n@@ -625,11 +625,11 @@ ipa_profile (void)\n \t\t\t control flow goes to this particular implementation\n \t\t\t of N2.  Speculate on the local alias to allow inlining.\n \t\t       */\n-\t\t      if (!symtab_can_be_discarded ((symtab_node) n2))\n+\t\t      if (!symtab_can_be_discarded (n2))\n \t\t\t{\n \t\t\t  cgraph_node *alias;\n \t\t\t  alias = cgraph (symtab_nonoverwritable_alias\n-\t\t\t\t\t   ((symtab_node)n2));\n+\t\t\t\t\t   (n2));\n \t\t\t  if (alias)\n \t\t\t    n2 = alias;\n \t\t\t}\n@@ -677,30 +677,30 @@ ipa_profile (void)\n       if (order[i]->local.local && ipa_propagate_frequency (order[i]))\n \t{\n \t  for (e = order[i]->callees; e; e = e->next_callee)\n-\t    if (e->callee->local.local && !e->callee->symbol.aux)\n+\t    if (e->callee->local.local && !e->callee->aux)\n \t      {\n \t        something_changed = true;\n-\t        e->callee->symbol.aux = (void *)1;\n+\t        e->callee->aux = (void *)1;\n \t      }\n \t}\n-      order[i]->symbol.aux = NULL;\n+      order[i]->aux = NULL;\n     }\n \n   while (something_changed)\n     {\n       something_changed = false;\n       for (i = order_pos - 1; i >= 0; i--)\n \t{\n-\t  if (order[i]->symbol.aux && ipa_propagate_frequency (order[i]))\n+\t  if (order[i]->aux && ipa_propagate_frequency (order[i]))\n \t    {\n \t      for (e = order[i]->callees; e; e = e->next_callee)\n-\t\tif (e->callee->local.local && !e->callee->symbol.aux)\n+\t\tif (e->callee->local.local && !e->callee->aux)\n \t\t  {\n \t\t    something_changed = true;\n-\t\t    e->callee->symbol.aux = (void *)1;\n+\t\t    e->callee->aux = (void *)1;\n \t\t  }\n \t    }\n-\t  order[i]->symbol.aux = NULL;\n+\t  order[i]->aux = NULL;\n \t}\n     }\n   free (order);"}, {"sha": "1ceabfabb3f48e6dba7d0d84294579b3469dcca8", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -90,7 +90,7 @@ static alloc_pool ipa_refdesc_pool;\n static bool\n ipa_func_spec_opts_forbid_analysis_p (struct cgraph_node *node)\n {\n-  tree fs_opts = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (node->symbol.decl);\n+  tree fs_opts = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (node->decl);\n   struct cl_optimization *os;\n \n   if (!fs_opts)\n@@ -136,7 +136,7 @@ ipa_populate_param_decls (struct cgraph_node *node,\n   tree parm;\n   int param_num;\n \n-  fndecl = node->symbol.decl;\n+  fndecl = node->decl;\n   gcc_assert (gimple_has_body_p (fndecl));\n   fnargs = DECL_ARGUMENTS (fndecl);\n   param_num = 0;\n@@ -201,7 +201,7 @@ ipa_initialize_node_params (struct cgraph_node *node)\n \n   if (!info->descriptors.exists ())\n     {\n-      ipa_alloc_node_params (node, count_formal_params (node->symbol.decl));\n+      ipa_alloc_node_params (node, count_formal_params (node->decl));\n       ipa_populate_param_decls (node, info->descriptors);\n     }\n }\n@@ -315,16 +315,16 @@ ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node)\n   struct cgraph_edge *cs;\n \n   fprintf (f, \"  Jump functions of caller  %s/%i:\\n\", cgraph_node_name (node),\n-\t   node->symbol.order);\n+\t   node->order);\n   for (cs = node->callees; cs; cs = cs->next_callee)\n     {\n       if (!ipa_edge_args_info_available_for_edge_p (cs))\n \tcontinue;\n \n       fprintf (f, \"    callsite  %s/%i -> %s/%i : \\n\",\n-\t       xstrdup (cgraph_node_name (node)), node->symbol.order,\n+\t       xstrdup (cgraph_node_name (node)), node->order,\n \t       xstrdup (cgraph_node_name (cs->callee)),\n-\t       cs->callee->symbol.order);\n+\t       cs->callee->order);\n       ipa_print_node_jump_functions_for_edge (f, cs);\n     }\n \n@@ -1513,7 +1513,7 @@ ipa_get_callee_param_type (struct cgraph_edge *e, int i)\n {\n   int n;\n   tree type = (e->callee\n-\t       ? TREE_TYPE (e->callee->symbol.decl)\n+\t       ? TREE_TYPE (e->callee->decl)\n \t       : gimple_call_fntype (e->call_stmt));\n   tree t = TYPE_ARG_TYPES (type);\n \n@@ -1527,7 +1527,7 @@ ipa_get_callee_param_type (struct cgraph_edge *e, int i)\n     return TREE_VALUE (t);\n   if (!e->callee)\n     return NULL;\n-  t = DECL_ARGUMENTS (e->callee->symbol.decl);\n+  t = DECL_ARGUMENTS (e->callee->decl);\n   for (n = 0; n < i; n++)\n     {\n       if (!t)\n@@ -1647,7 +1647,7 @@ ipa_compute_jump_functions (struct cgraph_node *node,\n \t\t\t\t\t\t\t\t  NULL);\n       /* We do not need to bother analyzing calls to unknown\n \t functions unless they may become known during lto/whopr.  */\n-      if (!callee->symbol.definition && !flag_lto)\n+      if (!callee->definition && !flag_lto)\n \tcontinue;\n       ipa_compute_jump_functions_for_edge (parms_ainfo, cs);\n     }\n@@ -2056,7 +2056,7 @@ static void\n ipa_analyze_params_uses (struct cgraph_node *node,\n \t\t\t struct param_analysis_info *parms_ainfo)\n {\n-  tree decl = node->symbol.decl;\n+  tree decl = node->decl;\n   basic_block bb;\n   struct function *func;\n   gimple_stmt_iterator gsi;\n@@ -2086,7 +2086,7 @@ ipa_analyze_params_uses (struct cgraph_node *node,\n \t the flag during modification analysis.  */\n       if (is_gimple_reg (parm))\n \t{\n-\t  tree ddef = ssa_default_def (DECL_STRUCT_FUNCTION (node->symbol.decl),\n+\t  tree ddef = ssa_default_def (DECL_STRUCT_FUNCTION (node->decl),\n \t\t\t\t       parm);\n \t  if (ddef && !has_zero_uses (ddef))\n \t    {\n@@ -2165,7 +2165,7 @@ ipa_analyze_node (struct cgraph_node *node)\n   ipa_check_create_node_params ();\n   ipa_check_create_edge_args ();\n   info = IPA_NODE_REF (node);\n-  push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n   ipa_initialize_node_params (node);\n \n   param_count = ipa_get_param_count (info);\n@@ -2418,7 +2418,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n \t  if (dump_file)\n \t    fprintf (dump_file, \"ipa-prop: Discovered direct call to non-function\"\n \t\t\t\t\" in %s/%i, making it unreachable.\\n\",\n-\t\t     cgraph_node_name (ie->caller), ie->caller->symbol.order);\n+\t\t     cgraph_node_name (ie->caller), ie->caller->order);\n \t  target = builtin_decl_implicit (BUILT_IN_UNREACHABLE);\n \t  callee = cgraph_get_create_node (target);\n \t  unreachable = true;\n@@ -2445,9 +2445,9 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n \t    fprintf (dump_file, \"ipa-prop: Discovered call to a known target \"\n \t\t     \"(%s/%i -> %s/%i) but can not refer to it. Giving up.\\n\",\n \t\t     xstrdup (cgraph_node_name (ie->caller)),\n-\t\t     ie->caller->symbol.order,\n+\t\t     ie->caller->order,\n \t\t     xstrdup (cgraph_node_name (ie->callee)),\n-\t\t     ie->callee->symbol.order);\n+\t\t     ie->callee->order);\n \t  return NULL;\n \t}\n       callee = cgraph_get_create_real_symbol_node (target);\n@@ -2464,9 +2464,9 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n \t       \"(%s/%i -> %s/%i), for stmt \",\n \t       ie->indirect_info->polymorphic ? \"a virtual\" : \"an indirect\",\n \t       xstrdup (cgraph_node_name (ie->caller)),\n-\t       ie->caller->symbol.order,\n+\t       ie->caller->order,\n \t       xstrdup (cgraph_node_name (callee)),\n-\t       callee->symbol.order);\n+\t       callee->order);\n       if (ie->call_stmt)\n \tprint_gimple_stmt (dump_file, ie->call_stmt, 2, TDF_SLIM);\n       else\n@@ -2520,7 +2520,7 @@ remove_described_reference (symtab_node symbol, struct ipa_cst_ref_desc *rdesc)\n   origin = rdesc->cs;\n   if (!origin)\n     return false;\n-  to_del = ipa_find_reference ((symtab_node) origin->caller, symbol,\n+  to_del = ipa_find_reference (origin->caller, symbol,\n \t\t\t       origin->call_stmt, origin->lto_stmt_uid);\n   if (!to_del)\n     return false;\n@@ -2529,7 +2529,7 @@ remove_described_reference (symtab_node symbol, struct ipa_cst_ref_desc *rdesc)\n   if (dump_file)\n     fprintf (dump_file, \"ipa-prop: Removed a reference from %s/%i to %s.\\n\",\n \t     xstrdup (cgraph_node_name (origin->caller)),\n-\t     origin->caller->symbol.order, xstrdup (symtab_node_name (symbol)));\n+\t     origin->caller->order, xstrdup (symtab_node_name (symbol)));\n   return true;\n }\n \n@@ -2577,7 +2577,7 @@ try_decrement_rdesc_refcount (struct ipa_jump_func *jfunc)\n       && (rdesc = jfunc_rdesc_usable (jfunc))\n       && --rdesc->refcount == 0)\n     {\n-      symtab_node symbol = (symtab_node) cgraph_node_for_jfunc (jfunc);\n+      symtab_node symbol = cgraph_node_for_jfunc (jfunc);\n       if (!symbol)\n \treturn false;\n \n@@ -2737,7 +2737,7 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \t    new_direct_edge->call_stmt_cannot_inline_p\n \t      = !gimple_check_call_matching_types (\n \t\t  new_direct_edge->call_stmt,\n-\t\t  new_direct_edge->callee->symbol.decl, false);\n+\t\t  new_direct_edge->callee->decl, false);\n \t  if (new_edges)\n \t    {\n \t      new_edges->safe_push (new_direct_edge);\n@@ -2853,15 +2853,15 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t      if (t && TREE_CODE (t) == ADDR_EXPR\n \t\t  && TREE_CODE (TREE_OPERAND (t, 0)) == FUNCTION_DECL\n \t\t  && (n = cgraph_get_node (TREE_OPERAND (t, 0)))\n-\t\t  && (ref = ipa_find_reference ((symtab_node) new_root,\n-\t\t\t\t\t\t(symtab_node) n, NULL, 0)))\n+\t\t  && (ref = ipa_find_reference (new_root,\n+\t\t\t\t\t\tn, NULL, 0)))\n \t\t{\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"ipa-prop: Removing cloning-created \"\n \t\t\t     \"reference from %s/%i to %s/%i.\\n\",\n \t\t\t     xstrdup (cgraph_node_name (new_root)),\n-\t\t\t     new_root->symbol.order,\n-\t\t\t     xstrdup (cgraph_node_name (n)), n->symbol.order);\n+\t\t\t     new_root->order,\n+\t\t\t     xstrdup (cgraph_node_name (n)), n->order);\n \t\t  ipa_remove_reference (ref);\n \t\t}\n \t    }\n@@ -2884,7 +2884,7 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t\t{\n \t\t  struct cgraph_node *clone;\n \t\t  bool ok;\n-\t\t  ok = remove_described_reference ((symtab_node) n, rdesc);\n+\t\t  ok = remove_described_reference (n, rdesc);\n \t\t  gcc_checking_assert (ok);\n \n \t\t  clone = cs->caller;\n@@ -2893,18 +2893,18 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t\t\t && IPA_NODE_REF (clone)->ipcp_orig_node)\n \t\t    {\n \t\t      struct ipa_ref *ref;\n-\t\t      ref = ipa_find_reference ((symtab_node) clone,\n-\t\t\t\t\t\t(symtab_node) n, NULL, 0);\n+\t\t      ref = ipa_find_reference (clone,\n+\t\t\t\t\t\tn, NULL, 0);\n \t\t      if (ref)\n \t\t\t{\n \t\t\t  if (dump_file)\n \t\t\t    fprintf (dump_file, \"ipa-prop: Removing \"\n \t\t\t\t     \"cloning-created reference \"\n \t\t\t\t     \"from %s/%i to %s/%i.\\n\",\n \t\t\t\t     xstrdup (cgraph_node_name (clone)),\n-\t\t\t\t     clone->symbol.order,\n+\t\t\t\t     clone->order,\n \t\t\t\t     xstrdup (cgraph_node_name (n)),\n-\t\t\t\t     n->symbol.order);\n+\t\t\t\t     n->order);\n \t\t\t  ipa_remove_reference (ref);\n \t\t\t}\n \t\t      clone = clone->callers->caller;\n@@ -3097,12 +3097,12 @@ ipa_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n \t  else if (src->caller == dst->caller)\n \t    {\n \t      struct ipa_ref *ref;\n-\t      symtab_node n = (symtab_node) cgraph_node_for_jfunc (src_jf);\n+\t      symtab_node n = cgraph_node_for_jfunc (src_jf);\n \t      gcc_checking_assert (n);\n-\t      ref = ipa_find_reference ((symtab_node) src->caller, n,\n+\t      ref = ipa_find_reference (src->caller, n,\n \t\t\t\t\tsrc->call_stmt, src->lto_stmt_uid);\n \t      gcc_checking_assert (ref);\n-\t      ipa_clone_ref (ref, (symtab_node) dst->caller, ref->stmt);\n+\t      ipa_clone_ref (ref, dst->caller, ref->stmt);\n \n \t      gcc_checking_assert (ipa_refdesc_pool);\n \t      struct ipa_cst_ref_desc *dst_rdesc\n@@ -3283,11 +3283,11 @@ ipa_print_node_params (FILE *f, struct cgraph_node *node)\n   int i, count;\n   struct ipa_node_params *info;\n \n-  if (!node->symbol.definition)\n+  if (!node->definition)\n     return;\n   info = IPA_NODE_REF (node);\n   fprintf (f, \"  function  %s/%i parameter descriptors:\\n\",\n-\t   cgraph_node_name (node), node->symbol.order);\n+\t   cgraph_node_name (node), node->order);\n   count = ipa_get_param_count (info);\n   for (i = 0; i < count; i++)\n     {\n@@ -3530,8 +3530,8 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gimple stmt,\n \n   len = adjustments.length ();\n   vargs.create (len);\n-  callee_decl = !cs ? gimple_call_fndecl (stmt) : cs->callee->symbol.decl;\n-  ipa_remove_stmt_references ((symtab_node) current_node, stmt);\n+  callee_decl = !cs ? gimple_call_fndecl (stmt) : cs->callee->decl;\n+  ipa_remove_stmt_references (current_node, stmt);\n \n   gsi = gsi_for_stmt (stmt);\n   prev_gsi = gsi;\n@@ -4123,7 +4123,7 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n   struct bitpack_d bp;\n \n   encoder = ob->decl_state->symtab_node_encoder;\n-  node_ref = lto_symtab_encoder_encode (encoder, (symtab_node) node);\n+  node_ref = lto_symtab_encoder_encode (encoder, node);\n   streamer_write_uhwi (ob, node_ref);\n \n   streamer_write_uhwi (ob, ipa_get_param_count (info));\n@@ -4287,7 +4287,7 @@ ipa_prop_read_section (struct lto_file_decl_data *file_data, const char *data,\n       index = streamer_read_uhwi (&ib_main);\n       encoder = file_data->symtab_node_encoder;\n       node = cgraph (lto_symtab_encoder_deref (encoder, index));\n-      gcc_assert (node->symbol.definition);\n+      gcc_assert (node->definition);\n       ipa_read_node_info (&ib_main, node, data_in);\n     }\n   lto_free_section_data (file_data, LTO_section_jump_functions, NULL, data,\n@@ -4339,7 +4339,7 @@ write_agg_replacement_chain (struct output_block *ob, struct cgraph_node *node)\n \n   aggvals = ipa_get_agg_replacements_for_node (node);\n   encoder = ob->decl_state->symtab_node_encoder;\n-  node_ref = lto_symtab_encoder_encode (encoder, (symtab_node) node);\n+  node_ref = lto_symtab_encoder_encode (encoder, node);\n   streamer_write_uhwi (ob, node_ref);\n \n   for (av = aggvals; av; av = av->next)\n@@ -4463,7 +4463,7 @@ read_replacements_section (struct lto_file_decl_data *file_data,\n       index = streamer_read_uhwi (&ib_main);\n       encoder = file_data->symtab_node_encoder;\n       node = cgraph (lto_symtab_encoder_deref (encoder, index));\n-      gcc_assert (node->symbol.definition);\n+      gcc_assert (node->definition);\n       read_agg_replacement_chain (&ib_main, node, data_in);\n     }\n   lto_free_section_data (file_data, LTO_section_jump_functions, NULL, data,\n@@ -4545,12 +4545,12 @@ ipcp_transform_function (struct cgraph_node *node)\n \n   if (dump_file)\n     fprintf (dump_file, \"Modification phase of node %s/%i\\n\",\n-\t     cgraph_node_name (node), node->symbol.order);\n+\t     cgraph_node_name (node), node->order);\n \n   aggval = ipa_get_agg_replacements_for_node (node);\n   if (!aggval)\n       return 0;\n-  param_count = count_formal_params (node->symbol.decl);\n+  param_count = count_formal_params (node->decl);\n   if (param_count == 0)\n     return 0;\n   adjust_agg_replacement_values (node, aggval);"}, {"sha": "50bf500b1728c7a82e7fade45563a89d6797d48a", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -716,7 +716,7 @@ check_stmt (gimple_stmt_iterator *gsip, funct_state local, bool ipa)\n static funct_state\n analyze_function (struct cgraph_node *fn, bool ipa)\n {\n-  tree decl = fn->symbol.decl;\n+  tree decl = fn->decl;\n   funct_state l;\n   basic_block this_block;\n \n@@ -727,10 +727,10 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n   l->looping = false;\n   l->can_throw = false;\n   state_from_flags (&l->state_previously_known, &l->looping_previously_known,\n-\t\t    flags_from_decl_or_type (fn->symbol.decl),\n+\t\t    flags_from_decl_or_type (fn->decl),\n \t\t    cgraph_node_cannot_return (fn));\n \n-  if (fn->thunk.thunk_p || fn->symbol.alias)\n+  if (fn->thunk.thunk_p || fn->alias)\n     {\n       /* Thunk gets propagated through, so nothing interesting happens.  */\n       gcc_assert (ipa);\n@@ -943,7 +943,7 @@ pure_const_write_summary (void)\n        lsei_next_function_in_partition (&lsei))\n     {\n       node = lsei_cgraph_node (lsei);\n-      if (node->symbol.definition && has_function_state (node))\n+      if (node->definition && has_function_state (node))\n \tcount++;\n     }\n \n@@ -954,7 +954,7 @@ pure_const_write_summary (void)\n        lsei_next_function_in_partition (&lsei))\n     {\n       node = lsei_cgraph_node (lsei);\n-      if (node->symbol.definition && has_function_state (node))\n+      if (node->definition && has_function_state (node))\n \t{\n \t  struct bitpack_d bp;\n \t  funct_state fs;\n@@ -964,7 +964,7 @@ pure_const_write_summary (void)\n \t  fs = get_function_state (node);\n \n \t  encoder = ob->decl_state->symtab_node_encoder;\n-\t  node_ref = lto_symtab_encoder_encode (encoder, (symtab_node)node);\n+\t  node_ref = lto_symtab_encoder_encode (encoder, node);\n \t  streamer_write_uhwi_stream (ob->main_stream, node_ref);\n \n \t  /* Note that flags will need to be read in the opposite\n@@ -1033,10 +1033,10 @@ pure_const_read_summary (void)\n \t      fs->can_throw = bp_unpack_value (&bp, 1);\n \t      if (dump_file)\n \t\t{\n-\t\t  int flags = flags_from_decl_or_type (node->symbol.decl);\n+\t\t  int flags = flags_from_decl_or_type (node->decl);\n \t\t  fprintf (dump_file, \"Read info for %s/%i \",\n \t\t\t   cgraph_node_name (node),\n-\t\t\t   node->symbol.order);\n+\t\t\t   node->order);\n \t\t  if (flags & ECF_CONST)\n \t\t    fprintf (dump_file, \" const\");\n \t\t  if (flags & ECF_PURE)\n@@ -1117,7 +1117,7 @@ propagate_pure_const (void)\n       int count = 0;\n       node = order[i];\n \n-      if (node->symbol.alias)\n+      if (node->alias)\n \tcontinue;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1136,7 +1136,7 @@ propagate_pure_const (void)\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"  Visiting %s/%i state:%s looping %i\\n\",\n \t\t     cgraph_node_name (w),\n-\t\t     w->symbol.order,\n+\t\t     w->order,\n \t\t     pure_const_names[w_l->pure_const_state],\n \t\t     w_l->looping);\n \n@@ -1183,7 +1183,7 @@ propagate_pure_const (void)\n \t\t  fprintf (dump_file,\n \t\t\t   \"    Call to %s/%i\",\n \t\t\t   cgraph_node_name (e->callee),\n-\t\t\t   e->callee->symbol.order);\n+\t\t\t   e->callee->order);\n \t\t}\n \t      if (avail > AVAIL_OVERWRITABLE)\n \t\t{\n@@ -1212,11 +1212,11 @@ propagate_pure_const (void)\n \t\t    }\n \t\t}\n \t      else if (special_builtin_state (&edge_state, &edge_looping,\n-\t\t\t\t\t       y->symbol.decl))\n+\t\t\t\t\t       y->decl))\n \t\t;\n \t      else\n \t\tstate_from_flags (&edge_state, &edge_looping,\n-\t\t\t\t  flags_from_decl_or_type (y->symbol.decl),\n+\t\t\t\t  flags_from_decl_or_type (y->decl),\n \t\t\t\t  cgraph_edge_cannot_lead_to_return (e));\n \n \t      /* Merge the results with what we already know.  */\n@@ -1255,15 +1255,15 @@ propagate_pure_const (void)\n \t    break;\n \n \t  /* And finally all loads and stores.  */\n-\t  for (i = 0; ipa_ref_list_reference_iterate (&w->symbol.ref_list, i, ref); i++)\n+\t  for (i = 0; ipa_ref_list_reference_iterate (&w->ref_list, i, ref); i++)\n \t    {\n \t      enum pure_const_state_e ref_state = IPA_CONST;\n \t      bool ref_looping = false;\n \t      switch (ref->use)\n \t\t{\n \t\tcase IPA_REF_LOAD:\n \t\t  /* readonly reads are safe.  */\n-\t\t  if (TREE_READONLY (ipa_ref_varpool_node (ref)->symbol.decl))\n+\t\t  if (TREE_READONLY (ipa_ref_varpool_node (ref)->decl))\n \t\t    break;\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t    fprintf (dump_file, \"    nonreadonly global var read\\n\");\n@@ -1287,7 +1287,7 @@ propagate_pure_const (void)\n \t      if (pure_const_state == IPA_NEITHER)\n \t\tbreak;\n \t    }\n-\t  w_info = (struct ipa_dfs_info *) w->symbol.aux;\n+\t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  w = w_info->next_cycle;\n \t}\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1322,9 +1322,9 @@ propagate_pure_const (void)\n \t  switch (this_state)\n \t    {\n \t    case IPA_CONST:\n-\t      if (!TREE_READONLY (w->symbol.decl))\n+\t      if (!TREE_READONLY (w->decl))\n \t\t{\n-\t\t  warn_function_const (w->symbol.decl, !this_looping);\n+\t\t  warn_function_const (w->decl, !this_looping);\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"Function found to be %sconst: %s\\n\",\n \t\t\t     this_looping ? \"looping \" : \"\",\n@@ -1334,9 +1334,9 @@ propagate_pure_const (void)\n \t      break;\n \n \t    case IPA_PURE:\n-\t      if (!DECL_PURE_P (w->symbol.decl))\n+\t      if (!DECL_PURE_P (w->decl))\n \t\t{\n-\t\t  warn_function_pure (w->symbol.decl, !this_looping);\n+\t\t  warn_function_pure (w->decl, !this_looping);\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"Function found to be %spure: %s\\n\",\n \t\t\t     this_looping ? \"looping \" : \"\",\n@@ -1348,7 +1348,7 @@ propagate_pure_const (void)\n \t    default:\n \t      break;\n \t    }\n-\t  w_info = (struct ipa_dfs_info *) w->symbol.aux;\n+\t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  w = w_info->next_cycle;\n \t}\n     }\n@@ -1387,7 +1387,7 @@ propagate_nothrow (void)\n       bool can_throw = false;\n       node = order[i];\n \n-      if (node->symbol.alias)\n+      if (node->alias)\n \tcontinue;\n \n       /* Find the worst state for any node in the cycle.  */\n@@ -1415,11 +1415,11 @@ propagate_nothrow (void)\n \n \t\t  if (can_throw)\n \t\t    break;\n-\t\t  if (y_l->can_throw && !TREE_NOTHROW (w->symbol.decl)\n+\t\t  if (y_l->can_throw && !TREE_NOTHROW (w->decl)\n \t\t      && e->can_throw_external)\n \t\t    can_throw = true;\n \t\t}\n-\t      else if (e->can_throw_external && !TREE_NOTHROW (y->symbol.decl))\n+\t      else if (e->can_throw_external && !TREE_NOTHROW (y->decl))\n \t        can_throw = true;\n \t    }\n           for (ie = node->indirect_calls; ie; ie = ie->next_callee)\n@@ -1428,7 +1428,7 @@ propagate_nothrow (void)\n \t\tcan_throw = true;\n \t\tbreak;\n \t      }\n-\t  w_info = (struct ipa_dfs_info *) w->symbol.aux;\n+\t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  w = w_info->next_cycle;\n \t}\n \n@@ -1438,16 +1438,16 @@ propagate_nothrow (void)\n       while (w)\n \t{\n \t  funct_state w_l = get_function_state (w);\n-\t  if (!can_throw && !TREE_NOTHROW (w->symbol.decl))\n+\t  if (!can_throw && !TREE_NOTHROW (w->decl))\n \t    {\n \t      cgraph_set_nothrow_flag (w, true);\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"Function found to be nothrow: %s\\n\",\n \t\t\t cgraph_node_name (w));\n \t    }\n-\t  else if (can_throw && !TREE_NOTHROW (w->symbol.decl))\n+\t  else if (can_throw && !TREE_NOTHROW (w->decl))\n \t    w_l->can_throw = true;\n-\t  w_info = (struct ipa_dfs_info *) w->symbol.aux;\n+\t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  w = w_info->next_cycle;\n \t}\n     }"}, {"sha": "4bb43c2af1d11ed525568b409f05afae6b54a88f", "filename": "gcc/ipa-ref-inline.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-ref-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-ref-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref-inline.h?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -54,15 +54,15 @@ ipa_ref_referring_varpool_node (struct ipa_ref *ref)\n static inline struct ipa_ref_list *\n ipa_ref_referring_ref_list (struct ipa_ref *ref)\n {\n-  return &ref->referring->symbol.ref_list;\n+  return &ref->referring->ref_list;\n }\n \n /* Return reference list REF is in.  */\n \n static inline struct ipa_ref_list *\n ipa_ref_referred_ref_list (struct ipa_ref *ref)\n {\n-  return &ref->referred->symbol.ref_list;\n+  return &ref->referred->ref_list;\n }\n \n /* Return first reference in LIST or NULL if empty.  */"}, {"sha": "4f04614e301481ac146ece697843e7052b93fb57", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -45,12 +45,12 @@ ipa_record_reference (symtab_node referring_node,\n   gcc_checking_assert (!stmt || is_a <cgraph_node> (referring_node));\n   gcc_checking_assert (use_type != IPA_REF_ALIAS || !stmt);\n \n-  list = &referring_node->symbol.ref_list;\n+  list = &referring_node->ref_list;\n   old_references = vec_safe_address (list->references);\n   vec_safe_grow (list->references, vec_safe_length (list->references) + 1);\n   ref = &list->references->last ();\n \n-  list2 = &referred_node->symbol.ref_list;\n+  list2 = &referred_node->ref_list;\n   list2->referring.safe_push (ref);\n   ref->referred_index = list2->referring.length () - 1;\n   ref->referring = referring_node;\n@@ -155,7 +155,7 @@ ipa_dump_references (FILE * file, struct ipa_ref_list *list)\n     {\n       fprintf (file, \"%s/%i (%s)\",\n                symtab_node_asm_name (ref->referred),\n-               ref->referred->symbol.order,\n+               ref->referred->order,\n \t       ipa_ref_use_name [ref->use]);\n       if (ref->speculative)\n \tfprintf (file, \" (speculative)\");\n@@ -174,7 +174,7 @@ ipa_dump_referring (FILE * file, struct ipa_ref_list *list)\n     {\n       fprintf (file, \"%s/%i (%s)\",\n                symtab_node_asm_name (ref->referring),\n-               ref->referring->symbol.order,\n+               ref->referring->order,\n \t       ipa_ref_use_name [ref->use]);\n       if (ref->speculative)\n \tfprintf (file, \" (speculative)\");\n@@ -274,7 +274,7 @@ ipa_find_reference (symtab_node referring_node, symtab_node referred_node,\n   struct ipa_ref *r = NULL;\n   int i;\n \n-  for (i = 0; ipa_ref_list_reference_iterate (&referring_node->symbol.ref_list, i, r); i++)\n+  for (i = 0; ipa_ref_list_reference_iterate (&referring_node->ref_list, i, r); i++)\n     if (r->referred == referred_node\n \t&& !r->speculative\n \t&& ((stmt && r->stmt == stmt)\n@@ -293,7 +293,7 @@ ipa_remove_stmt_references (symtab_node referring_node, gimple stmt)\n   struct ipa_ref *r = NULL;\n   int i;\n \n-  for (i = 0; ipa_ref_list_reference_iterate (&referring_node->symbol.ref_list, i, r); i++)\n+  for (i = 0; ipa_ref_list_reference_iterate (&referring_node->ref_list, i, r); i++)\n     if (r->stmt == stmt)\n       ipa_remove_reference (r);\n }\n@@ -309,7 +309,7 @@ ipa_clear_stmts_in_references (symtab_node referring_node)\n   struct ipa_ref *r = NULL;\n   int i;\n \n-  for (i = 0; ipa_ref_list_reference_iterate (&referring_node->symbol.ref_list, i, r); i++)\n+  for (i = 0; ipa_ref_list_reference_iterate (&referring_node->ref_list, i, r); i++)\n     if (!r->speculative)\n       {\n \tr->stmt = NULL;"}, {"sha": "25a6ad4421ca1e1fc9633e0493de95b76dad3802", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -178,7 +178,7 @@ ipa_reference_get_not_read_global (struct cgraph_node *fn)\n     get_reference_optimization_summary (cgraph_function_node (fn, NULL));\n   if (info)\n     return info->statics_not_read;\n-  else if (flags_from_decl_or_type (fn->symbol.decl) & ECF_LEAF)\n+  else if (flags_from_decl_or_type (fn->decl) & ECF_LEAF)\n     return all_module_statics;\n   else\n     return NULL;\n@@ -196,7 +196,7 @@ ipa_reference_get_not_written_global (struct cgraph_node *fn)\n     get_reference_optimization_summary (fn);\n   if (info)\n     return info->statics_not_written;\n-  else if (flags_from_decl_or_type (fn->symbol.decl) & ECF_LEAF)\n+  else if (flags_from_decl_or_type (fn->decl) & ECF_LEAF)\n     return all_module_statics;\n   else\n     return NULL;\n@@ -365,7 +365,7 @@ propagate_bits (ipa_reference_global_vars_info_t x_global, struct cgraph_node *x\n \tcontinue;\n \n       /* Only look into nodes we can propagate something.  */\n-      int flags = flags_from_decl_or_type (y->symbol.decl);\n+      int flags = flags_from_decl_or_type (y->decl);\n       if (avail > AVAIL_OVERWRITABLE\n \t  || (avail == AVAIL_OVERWRITABLE && (flags & ECF_LEAF)))\n \t{\n@@ -460,11 +460,11 @@ analyze_function (struct cgraph_node *fn)\n   tree var;\n \n   local = init_function_info (fn);\n-  for (i = 0; ipa_ref_list_reference_iterate (&fn->symbol.ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_reference_iterate (&fn->ref_list, i, ref); i++)\n     {\n       if (!is_a <varpool_node> (ref->referred))\n \tcontinue;\n-      var = ipa_ref_varpool_node (ref)->symbol.decl;\n+      var = ipa_ref_varpool_node (ref)->decl;\n       if (!is_proper_for_analysis (var))\n \tcontinue;\n       switch (ref->use)\n@@ -562,7 +562,7 @@ generate_summary (void)\n \t  l = &get_reference_vars_info (node)->local;\n \t  fprintf (dump_file,\n \t\t   \"\\nFunction name:%s/%i:\",\n-\t\t   cgraph_node_asm_name (node), node->symbol.order);\n+\t\t   cgraph_node_asm_name (node), node->order);\n \t  fprintf (dump_file, \"\\n  locals read: \");\n \t  if (l->statics_read)\n \t    EXECUTE_IF_SET_IN_BITMAP (l->statics_read,\n@@ -587,7 +587,7 @@ static void\n read_write_all_from_decl (struct cgraph_node *node,\n \t\t\t  bool &read_all, bool &write_all)\n {\n-  tree decl = node->symbol.decl;\n+  tree decl = node->decl;\n   int flags = flags_from_decl_or_type (decl);\n   if ((flags & ECF_LEAF)\n       && cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n@@ -600,7 +600,7 @@ read_write_all_from_decl (struct cgraph_node *node,\n       read_all = true;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n          fprintf (dump_file, \"   %s/%i -> read all\\n\",\n-\t\t  cgraph_node_asm_name (node), node->symbol.order);\n+\t\t  cgraph_node_asm_name (node), node->order);\n     }\n   else\n     {\n@@ -610,7 +610,7 @@ read_write_all_from_decl (struct cgraph_node *node,\n       write_all = true;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n          fprintf (dump_file, \"   %s/%i -> read all, write all\\n\",\n-\t\t  cgraph_node_asm_name (node), node->symbol.order);\n+\t\t  cgraph_node_asm_name (node), node->order);\n     }\n }\n \n@@ -677,12 +677,12 @@ propagate (void)\n \n   /* Now we know what vars are really statics; prune out those that aren't.  */\n   FOR_EACH_VARIABLE (vnode)\n-    if (vnode->symbol.externally_visible\n-\t|| TREE_ADDRESSABLE (vnode->symbol.decl)\n-\t|| TREE_READONLY (vnode->symbol.decl)\n-\t|| !is_proper_for_analysis (vnode->symbol.decl)\n-\t|| !vnode->symbol.definition)\n-      bitmap_clear_bit (all_module_statics, DECL_UID (vnode->symbol.decl));\n+    if (vnode->externally_visible\n+\t|| TREE_ADDRESSABLE (vnode->decl)\n+\t|| TREE_READONLY (vnode->decl)\n+\t|| !is_proper_for_analysis (vnode->decl)\n+\t|| !vnode->definition)\n+      bitmap_clear_bit (all_module_statics, DECL_UID (vnode->decl));\n \n   /* Forget info we collected \"just for fun\" on variables that turned out to be\n      non-local.  */\n@@ -713,7 +713,7 @@ propagate (void)\n       bool write_all = false;\n \n       node = order[i];\n-      if (node->symbol.alias)\n+      if (node->alias)\n \tcontinue;\n \n       node_info = get_reference_vars_info (node);\n@@ -723,7 +723,7 @@ propagate (void)\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"Starting cycle with %s/%i\\n\",\n-\t\t  cgraph_node_asm_name (node), node->symbol.order);\n+\t\t  cgraph_node_asm_name (node), node->order);\n \n       vec<cgraph_node_ptr> cycle_nodes = ipa_get_nodes_in_cycle (node);\n \n@@ -732,7 +732,7 @@ propagate (void)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"  Visiting %s/%i\\n\",\n-\t\t     cgraph_node_asm_name (w), w->symbol.order);\n+\t\t     cgraph_node_asm_name (w), w->order);\n \t  get_read_write_all_from_node (w, read_all, write_all);\n \t  if (read_all && write_all)\n \t    break;\n@@ -759,7 +759,7 @@ propagate (void)\n \t    {\n \t      ipa_reference_vars_info_t w_ri = get_reference_vars_info (w);\n \t      ipa_reference_local_vars_info_t w_l = &w_ri->local;\n-\t      int flags = flags_from_decl_or_type (w->symbol.decl);\n+\t      int flags = flags_from_decl_or_type (w->decl);\n \n \t      if (!(flags & ECF_CONST))\n \t\tread_all = union_static_var_sets (node_g->statics_read,\n@@ -791,12 +791,12 @@ propagate (void)\n \t  struct cgraph_node *w;\n \n \t  node = order[i];\n-\t  if (node->symbol.alias)\n+\t  if (node->alias)\n \t    continue;\n \n \t  fprintf (dump_file,\n \t\t   \"\\nFunction name:%s/%i:\",\n-\t\t   cgraph_node_asm_name (node), node->symbol.order);\n+\t\t   cgraph_node_asm_name (node), node->order);\n \n \t  ipa_reference_vars_info_t node_info = get_reference_vars_info (node);\n \t  ipa_reference_global_vars_info_t node_g = &node_info->global;\n@@ -808,7 +808,7 @@ propagate (void)\n \t      ipa_reference_local_vars_info_t w_l = &w_ri->local;\n \t      if (w != node)\n \t\tfprintf (dump_file, \"\\n  next cycle: %s/%i \",\n-\t\t\t cgraph_node_asm_name (w), w->symbol.order);\n+\t\t\t cgraph_node_asm_name (w), w->order);\n \t      fprintf (dump_file, \"\\n    locals read: \");\n \t      dump_static_vars_set_to_file (dump_file, w_l->statics_read);\n \t      fprintf (dump_file, \"\\n    locals written: \");\n@@ -832,9 +832,9 @@ propagate (void)\n       ipa_reference_optimization_summary_t opt;\n \n       node_info = get_reference_vars_info (node);\n-      if (!node->symbol.alias\n+      if (!node->alias\n \t  && (cgraph_function_body_availability (node) > AVAIL_OVERWRITABLE\n-\t      || (flags_from_decl_or_type (node->symbol.decl) & ECF_LEAF)))\n+\t      || (flags_from_decl_or_type (node->decl) & ECF_LEAF)))\n \t{\n \t  node_g = &node_info->global;\n \n@@ -891,7 +891,7 @@ write_node_summary_p (struct cgraph_node *node,\n   ipa_reference_optimization_summary_t info;\n \n   /* See if we have (non-empty) info.  */\n-  if (!node->symbol.definition || node->global.inlined_to)\n+  if (!node->definition || node->global.inlined_to)\n     return false;\n   info = get_reference_optimization_summary (node);\n   if (!info || (bitmap_empty_p (info->statics_not_read)\n@@ -905,7 +905,7 @@ write_node_summary_p (struct cgraph_node *node,\n      In future we might also want to include summaries of functions references\n      by initializers of constant variables references in current unit.  */\n   if (!reachable_from_this_partition_p (node, encoder)\n-      && !referenced_from_this_partition_p (&node->symbol.ref_list, encoder))\n+      && !referenced_from_this_partition_p (&node->ref_list, encoder))\n     return false;\n \n   /* See if the info has non-empty intersections with vars we want to encode.  */\n@@ -971,10 +971,10 @@ ipa_reference_write_optimization_summary (void)\n       symtab_node snode = lto_symtab_encoder_deref (encoder, i);\n       varpool_node *vnode = dyn_cast <varpool_node> (snode);\n       if (vnode\n-\t  && bitmap_bit_p (all_module_statics, DECL_UID (vnode->symbol.decl))\n-\t  && referenced_from_this_partition_p (&vnode->symbol.ref_list, encoder))\n+\t  && bitmap_bit_p (all_module_statics, DECL_UID (vnode->decl))\n+\t  && referenced_from_this_partition_p (&vnode->ref_list, encoder))\n \t{\n-\t  tree decl = vnode->symbol.decl;\n+\t  tree decl = vnode->decl;\n \t  bitmap_set_bit (ltrans_statics, DECL_UID (decl));\n \t  splay_tree_insert (reference_vars_to_consider,\n \t\t\t     DECL_UID (decl), (splay_tree_value)decl);\n@@ -1086,7 +1086,7 @@ ipa_reference_read_optimization_summary (void)\n \t      if (dump_file)\n \t\tfprintf (dump_file,\n \t\t\t \"\\nFunction name:%s/%i:\\n  static not read:\",\n-\t\t\t cgraph_node_asm_name (node), node->symbol.order);\n+\t\t\t cgraph_node_asm_name (node), node->order);\n \n \t      /* Set the statics not read.  */\n \t      v_count = streamer_read_hwi (ib);"}, {"sha": "849868ca68ce199829b4cbe9df7d09b3b3be3e36", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -1223,20 +1223,20 @@ split_function (struct split_point *split_point)\n   /* For usual cloning it is enough to clear builtin only when signature\n      changes.  For partial inlining we however can not expect the part\n      of builtin implementation to have same semantic as the whole.  */\n-  if (DECL_BUILT_IN (node->symbol.decl))\n+  if (DECL_BUILT_IN (node->decl))\n     {\n-      DECL_BUILT_IN_CLASS (node->symbol.decl) = NOT_BUILT_IN;\n-      DECL_FUNCTION_CODE (node->symbol.decl) = (enum built_in_function) 0;\n+      DECL_BUILT_IN_CLASS (node->decl) = NOT_BUILT_IN;\n+      DECL_FUNCTION_CODE (node->decl) = (enum built_in_function) 0;\n     }\n   /* If the original function is declared inline, there is no point in issuing\n      a warning for the non-inlinable part.  */\n-  DECL_NO_INLINE_WARNING_P (node->symbol.decl) = 1;\n+  DECL_NO_INLINE_WARNING_P (node->decl) = 1;\n   cgraph_node_remove_callees (cur_node);\n-  ipa_remove_all_references (&cur_node->symbol.ref_list);\n+  ipa_remove_all_references (&cur_node->ref_list);\n   if (!split_part_return_p)\n-    TREE_THIS_VOLATILE (node->symbol.decl) = 1;\n+    TREE_THIS_VOLATILE (node->decl) = 1;\n   if (dump_file)\n-    dump_function_to_file (node->symbol.decl, dump_file, dump_flags);\n+    dump_function_to_file (node->decl, dump_file, dump_flags);\n \n   /* Create the basic block we place call into.  It is the entry basic block\n      split after last label.  */\n@@ -1261,7 +1261,7 @@ split_function (struct split_point *split_point)\n \t\t\t\t\tfalse, GSI_CONTINUE_LINKING);\n \targs_to_pass[i] = arg;\n       }\n-  call = gimple_build_call_vec (node->symbol.decl, args_to_pass);\n+  call = gimple_build_call_vec (node->decl, args_to_pass);\n   gimple_set_block (call, DECL_INITIAL (current_function_decl));\n   args_to_pass.release ();\n \n@@ -1288,7 +1288,7 @@ split_function (struct split_point *split_point)\n \t    continue;\n \n \t  if (debug_args == NULL)\n-\t    debug_args = decl_debug_args_insert (node->symbol.decl);\n+\t    debug_args = decl_debug_args_insert (node->decl);\n \t  ddecl = make_node (DEBUG_EXPR_DECL);\n \t  DECL_ARTIFICIAL (ddecl) = 1;\n \t  TREE_TYPE (ddecl) = TREE_TYPE (parm);\n@@ -1314,8 +1314,8 @@ split_function (struct split_point *split_point)\n       gimple_stmt_iterator cgsi;\n       gimple def_temp;\n \n-      push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n-      var = BLOCK_VARS (DECL_INITIAL (node->symbol.decl));\n+      push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+      var = BLOCK_VARS (DECL_INITIAL (node->decl));\n       i = vec_safe_length (*debug_args);\n       cgsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR));\n       do\n@@ -1515,7 +1515,7 @@ execute_split_functions (void)\n \tfprintf (dump_file, \"Not splitting: not inlinable.\\n\");\n       return 0;\n     }\n-  if (DECL_DISREGARD_INLINE_LIMITS (node->symbol.decl))\n+  if (DECL_DISREGARD_INLINE_LIMITS (node->decl))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Not splitting: disregarding inline limits.\\n\");\n@@ -1549,8 +1549,8 @@ execute_split_functions (void)\n   if ((!node->callers\n        /* Local functions called once will be completely inlined most of time.  */\n        || (!node->callers->next_caller && node->local.local))\n-      && !node->symbol.address_taken\n-      && (!flag_lto || !node->symbol.externally_visible))\n+      && !node->address_taken\n+      && (!flag_lto || !node->externally_visible))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Not splitting: not called directly \""}, {"sha": "84108166e66c6a509855c1b0acd3375527f707c0", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -84,7 +84,7 @@ searchc (struct searchc_env* env, struct cgraph_node *v,\n \t bool (*ignore_edge) (struct cgraph_edge *))\n {\n   struct cgraph_edge *edge;\n-  struct ipa_dfs_info *v_info = (struct ipa_dfs_info *) v->symbol.aux;\n+  struct ipa_dfs_info *v_info = (struct ipa_dfs_info *) v->aux;\n \n   /* mark node as old */\n   v_info->new_node = false;\n@@ -105,11 +105,11 @@ searchc (struct searchc_env* env, struct cgraph_node *v,\n       if (!w || (ignore_edge && ignore_edge (edge)))\n         continue;\n \n-      if (w->symbol.aux\n+      if (w->aux\n \t  && (avail > AVAIL_OVERWRITABLE\n \t      || (env->allow_overwritable && avail == AVAIL_OVERWRITABLE)))\n \t{\n-\t  w_info = (struct ipa_dfs_info *) w->symbol.aux;\n+\t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  if (w_info->new_node)\n \t    {\n \t      searchc (env, w, ignore_edge);\n@@ -134,7 +134,7 @@ searchc (struct searchc_env* env, struct cgraph_node *v,\n       struct ipa_dfs_info *x_info;\n       do {\n \tx = env->stack[--(env->stack_size)];\n-\tx_info = (struct ipa_dfs_info *) x->symbol.aux;\n+\tx_info = (struct ipa_dfs_info *) x->aux;\n \tx_info->on_stack = false;\n \tx_info->scc_no = v_info->dfn_number;\n \n@@ -188,20 +188,20 @@ ipa_reduced_postorder (struct cgraph_node **order,\n \t      && (avail == AVAIL_OVERWRITABLE)))\n \t{\n \t  /* Reuse the info if it is already there.  */\n-\t  struct ipa_dfs_info *info = (struct ipa_dfs_info *) node->symbol.aux;\n+\t  struct ipa_dfs_info *info = (struct ipa_dfs_info *) node->aux;\n \t  if (!info)\n \t    info = XCNEW (struct ipa_dfs_info);\n \t  info->new_node = true;\n \t  info->on_stack = false;\n \t  info->next_cycle = NULL;\n-\t  node->symbol.aux = info;\n+\t  node->aux = info;\n \n \t  splay_tree_insert (env.nodes_marked_new,\n \t\t\t     (splay_tree_key)node->uid,\n \t\t\t     (splay_tree_value)node);\n \t}\n       else\n-\tnode->symbol.aux = NULL;\n+\tnode->aux = NULL;\n     }\n   result = splay_tree_min (env.nodes_marked_new);\n   while (result)\n@@ -226,10 +226,10 @@ ipa_free_postorder_info (void)\n   FOR_EACH_DEFINED_FUNCTION (node)\n     {\n       /* Get rid of the aux information.  */\n-      if (node->symbol.aux)\n+      if (node->aux)\n \t{\n-\t  free (node->symbol.aux);\n-\t  node->symbol.aux = NULL;\n+\t  free (node->aux);\n+\t  node->aux = NULL;\n \t}\n     }\n }\n@@ -245,7 +245,7 @@ ipa_get_nodes_in_cycle (struct cgraph_node *node)\n   while (node)\n     {\n       v.safe_push (node);\n-      node_dfs_info = (struct ipa_dfs_info *) node->symbol.aux;\n+      node_dfs_info = (struct ipa_dfs_info *) node->aux;\n       node = node_dfs_info->next_cycle;\n     }\n   return v;\n@@ -257,11 +257,11 @@ ipa_get_nodes_in_cycle (struct cgraph_node *node)\n bool\n ipa_edge_within_scc (struct cgraph_edge *cs)\n {\n-  struct ipa_dfs_info *caller_dfs = (struct ipa_dfs_info *) cs->caller->symbol.aux;\n+  struct ipa_dfs_info *caller_dfs = (struct ipa_dfs_info *) cs->caller->aux;\n   struct ipa_dfs_info *callee_dfs;\n   struct cgraph_node *callee = cgraph_function_node (cs->callee, NULL);\n \n-  callee_dfs = (struct ipa_dfs_info *) callee->symbol.aux;\n+  callee_dfs = (struct ipa_dfs_info *) callee->aux;\n   return (caller_dfs\n \t  && callee_dfs\n \t  && caller_dfs->scc_no == callee_dfs->scc_no);\n@@ -296,21 +296,21 @@ ipa_reverse_postorder (struct cgraph_node **order)\n      to be output and put them into order as well, so we get dependencies\n      right through inline functions.  */\n   FOR_EACH_FUNCTION (node)\n-    node->symbol.aux = NULL;\n+    node->aux = NULL;\n   for (pass = 0; pass < 2; pass++)\n     FOR_EACH_FUNCTION (node)\n-      if (!node->symbol.aux\n+      if (!node->aux\n \t  && (pass\n-\t      || (!node->symbol.address_taken\n+\t      || (!node->address_taken\n \t\t  && !node->global.inlined_to\n-\t\t  && !node->symbol.alias && !node->thunk.thunk_p\n+\t\t  && !node->alias && !node->thunk.thunk_p\n \t\t  && !cgraph_only_called_directly_p (node))))\n \t{\n \t  stack_size = 0;\n           stack[stack_size].node = node;\n \t  stack[stack_size].edge = node->callers;\n \t  stack[stack_size].ref = 0;\n-\t  node->symbol.aux = (void *)(size_t)1;\n+\t  node->aux = (void *)(size_t)1;\n \t  while (stack_size >= 0)\n \t    {\n \t      while (true)\n@@ -324,12 +324,12 @@ ipa_reverse_postorder (struct cgraph_node **order)\n \t\t      /* Break possible cycles involving always-inline\n \t\t\t functions by ignoring edges from always-inline\n \t\t\t functions to non-always-inline functions.  */\n-\t\t      if (DECL_DISREGARD_INLINE_LIMITS (edge->caller->symbol.decl)\n+\t\t      if (DECL_DISREGARD_INLINE_LIMITS (edge->caller->decl)\n \t\t\t  && !DECL_DISREGARD_INLINE_LIMITS\n-\t\t\t    (cgraph_function_node (edge->callee, NULL)->symbol.decl))\n+\t\t\t    (cgraph_function_node (edge->callee, NULL)->decl))\n \t\t\tnode2 = NULL;\n \t\t    }\n-\t\t  for (;ipa_ref_list_referring_iterate (&stack[stack_size].node->symbol.ref_list,\n+\t\t  for (;ipa_ref_list_referring_iterate (&stack[stack_size].node->ref_list,\n \t\t\t\t\t\t       stack[stack_size].ref,\n \t\t\t\t\t\t       ref) && !node2;\n \t\t       stack[stack_size].ref++)\n@@ -339,20 +339,20 @@ ipa_reverse_postorder (struct cgraph_node **order)\n \t\t    }\n \t\t  if (!node2)\n \t\t    break;\n-\t\t  if (!node2->symbol.aux)\n+\t\t  if (!node2->aux)\n \t\t    {\n \t\t      stack[++stack_size].node = node2;\n \t\t      stack[stack_size].edge = node2->callers;\n \t\t      stack[stack_size].ref = 0;\n-\t\t      node2->symbol.aux = (void *)(size_t)1;\n+\t\t      node2->aux = (void *)(size_t)1;\n \t\t    }\n \t\t}\n \t      order[order_pos++] = stack[stack_size--].node;\n \t    }\n \t}\n   free (stack);\n   FOR_EACH_FUNCTION (node)\n-    node->symbol.aux = NULL;\n+    node->aux = NULL;\n   return order_pos;\n }\n \n@@ -481,7 +481,7 @@ dump_cgraph_node_set (FILE *f, cgraph_node_set set)\n   for (iter = csi_start (set); !csi_end_p (iter); csi_next (&iter))\n     {\n       struct cgraph_node *node = csi_node (iter);\n-      fprintf (f, \" %s/%i\", cgraph_node_name (node), node->symbol.order);\n+      fprintf (f, \" %s/%i\", cgraph_node_name (node), node->order);\n     }\n   fprintf (f, \"\\n\");\n }\n@@ -643,12 +643,12 @@ void\n ipa_merge_profiles (struct cgraph_node *dst,\n \t\t    struct cgraph_node *src)\n {\n-  tree oldsrcdecl = src->symbol.decl;\n+  tree oldsrcdecl = src->decl;\n   struct function *srccfun, *dstcfun;\n   bool match = true;\n \n-  if (!src->symbol.definition\n-      || !dst->symbol.definition)\n+  if (!src->definition\n+      || !dst->definition)\n     return;\n   if (src->frequency < dst->frequency)\n     src->frequency = dst->frequency;\n@@ -657,49 +657,49 @@ ipa_merge_profiles (struct cgraph_node *dst,\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"Merging profiles of %s/%i to %s/%i\\n\",\n-\t       xstrdup (cgraph_node_name (src)), src->symbol.order,\n-\t       xstrdup (cgraph_node_name (dst)), dst->symbol.order);\n+\t       xstrdup (cgraph_node_name (src)), src->order,\n+\t       xstrdup (cgraph_node_name (dst)), dst->order);\n     }\n   dst->count += src->count;\n \n   /* This is ugly.  We need to get both function bodies into memory.\n      If declaration is merged, we need to duplicate it to be able\n      to load body that is being replaced.  This makes symbol table\n      temporarily inconsistent.  */\n-  if (src->symbol.decl == dst->symbol.decl)\n+  if (src->decl == dst->decl)\n     {\n       void **slot;\n       struct lto_in_decl_state temp;\n       struct lto_in_decl_state *state;\n \n       /* We are going to move the decl, we want to remove its file decl data.\n \t and link these with the new decl. */\n-      temp.fn_decl = src->symbol.decl;\n-      slot = htab_find_slot (src->symbol.lto_file_data->function_decl_states,\n+      temp.fn_decl = src->decl;\n+      slot = htab_find_slot (src->lto_file_data->function_decl_states,\n \t\t\t     &temp, NO_INSERT);\n       state = (lto_in_decl_state *)*slot;\n-      htab_clear_slot (src->symbol.lto_file_data->function_decl_states, slot);\n+      htab_clear_slot (src->lto_file_data->function_decl_states, slot);\n       gcc_assert (state);\n \n       /* Duplicate the decl and be sure it does not link into body of DST.  */\n-      src->symbol.decl = copy_node (src->symbol.decl);\n-      DECL_STRUCT_FUNCTION (src->symbol.decl) = NULL;\n-      DECL_ARGUMENTS (src->symbol.decl) = NULL;\n-      DECL_INITIAL (src->symbol.decl) = NULL;\n-      DECL_RESULT (src->symbol.decl) = NULL;\n+      src->decl = copy_node (src->decl);\n+      DECL_STRUCT_FUNCTION (src->decl) = NULL;\n+      DECL_ARGUMENTS (src->decl) = NULL;\n+      DECL_INITIAL (src->decl) = NULL;\n+      DECL_RESULT (src->decl) = NULL;\n \n       /* Associate the decl state with new declaration, so LTO streamer\n  \t can look it up.  */\n-      state->fn_decl = src->symbol.decl;\n-      slot = htab_find_slot (src->symbol.lto_file_data->function_decl_states,\n+      state->fn_decl = src->decl;\n+      slot = htab_find_slot (src->lto_file_data->function_decl_states,\n \t\t\t     state, INSERT);\n       gcc_assert (!*slot);\n       *slot = state;\n     }\n   cgraph_get_body (src);\n   cgraph_get_body (dst);\n-  srccfun = DECL_STRUCT_FUNCTION (src->symbol.decl);\n-  dstcfun = DECL_STRUCT_FUNCTION (dst->symbol.decl);\n+  srccfun = DECL_STRUCT_FUNCTION (src->decl);\n+  dstcfun = DECL_STRUCT_FUNCTION (dst->decl);\n   if (n_basic_blocks_for_function (srccfun)\n       != n_basic_blocks_for_function (dstcfun))\n     {\n@@ -787,22 +787,22 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t  gcc_assert (!e->speculative);\n \t  e->count = gimple_bb (e->call_stmt)->count;\n \t  e->frequency = compute_call_stmt_bb_frequency\n-\t\t\t     (dst->symbol.decl,\n+\t\t\t     (dst->decl,\n \t\t\t      gimple_bb (e->call_stmt));\n \t}\n       for (e = dst->indirect_calls; e; e = e->next_callee)\n \t{\n \t  gcc_assert (!e->speculative);\n \t  e->count = gimple_bb (e->call_stmt)->count;\n \t  e->frequency = compute_call_stmt_bb_frequency\n-\t\t\t     (dst->symbol.decl,\n+\t\t\t     (dst->decl,\n \t\t\t      gimple_bb (e->call_stmt));\n \t}\n       cgraph_release_function_body (src);\n       inline_update_overall_summary (dst);\n     }\n   /* TODO: if there is no match, we can scale up.  */\n-  src->symbol.decl = oldsrcdecl;\n+  src->decl = oldsrcdecl;\n }\n \n /* Return true if call to DEST is known to be self-recusive call withing FUNC.   */\n@@ -813,6 +813,6 @@ recursive_call_p (tree func, tree dest)\n   struct cgraph_node *dest_node = cgraph_get_create_node (dest);\n   struct cgraph_node *cnode = cgraph_get_create_node (func);\n \n-  return symtab_semantically_equivalent_p ((symtab_node)dest_node,\n-\t\t\t\t\t   (symtab_node)cnode);\n+  return symtab_semantically_equivalent_p (dest_node,\n+\t\t\t\t\t   cnode);\n }"}, {"sha": "868a9d2ae1dce22fecc528f40afb4577702924e9", "filename": "gcc/ipa.c", "status": "modified", "additions": 214, "deletions": 214, "changes": 428, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -43,12 +43,12 @@ cgraph_non_local_node_p_1 (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED\n {\n    /* FIXME: Aliases can be local, but i386 gets thunks wrong then.  */\n    return !(cgraph_only_called_directly_or_aliased_p (node)\n-\t    && !ipa_ref_has_aliases_p (&node->symbol.ref_list)\n-\t    && node->symbol.definition\n-\t    && !DECL_EXTERNAL (node->symbol.decl)\n-\t    && !node->symbol.externally_visible\n-\t    && !node->symbol.used_from_other_partition\n-\t    && !node->symbol.in_other_partition);\n+\t    && !ipa_ref_has_aliases_p (&node->ref_list)\n+\t    && node->definition\n+\t    && !DECL_EXTERNAL (node->decl)\n+\t    && !node->externally_visible\n+\t    && !node->used_from_other_partition\n+\t    && !node->in_other_partition);\n }\n \n /* Return true when function can be marked local.  */\n@@ -76,7 +76,7 @@ has_addr_references_p (struct cgraph_node *node,\n   int i;\n   struct ipa_ref *ref;\n \n-  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list,\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list,\n \t\t\t\t\t      i, ref); i++)\n     if (ref->use == IPA_REF_ADDR)\n       return true;\n@@ -111,13 +111,13 @@ enqueue_node (symtab_node node, symtab_node *first,\n \t      struct pointer_set_t *reachable)\n {\n   /* Node is still in queue; do nothing.  */\n-  if (node->symbol.aux && node->symbol.aux != (void *) 2)\n+  if (node->aux && node->aux != (void *) 2)\n     return;\n   /* Node was already processed as unreachable, re-enqueue\n      only if it became reachable now.  */\n-  if (node->symbol.aux == (void *)2 && !pointer_set_contains (reachable, node))\n+  if (node->aux == (void *)2 && !pointer_set_contains (reachable, node))\n     return;\n-  node->symbol.aux = *first;\n+  node->aux = *first;\n   *first = node;\n }\n \n@@ -135,18 +135,18 @@ process_references (struct ipa_ref_list *list,\n     {\n       symtab_node node = ref->referred;\n \n-      if (node->symbol.definition && !node->symbol.in_other_partition\n-\t  && ((!DECL_EXTERNAL (node->symbol.decl) || node->symbol.alias)\n+      if (node->definition && !node->in_other_partition\n+\t  && ((!DECL_EXTERNAL (node->decl) || node->alias)\n \t      || (before_inlining_p\n \t\t  /* We use variable constructors during late complation for\n \t\t     constant folding.  Keep references alive so partitioning\n \t\t     knows about potential references.  */\n-\t\t  || (TREE_CODE (node->symbol.decl) == VAR_DECL\n+\t\t  || (TREE_CODE (node->decl) == VAR_DECL\n \t\t      && flag_wpa\n-\t\t      && ctor_for_folding (node->symbol.decl)\n+\t\t      && ctor_for_folding (node->decl)\n \t\t         != error_mark_node))))\n \tpointer_set_insert (reachable, node);\n-      enqueue_node ((symtab_node) node, first, reachable);\n+      enqueue_node (node, first, reachable);\n     }\n }\n \n@@ -181,21 +181,21 @@ walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n \t  /* Do not bother to mark virtual methods in anonymous namespace;\n \t     either we will find use of virtual table defining it, or it is\n \t     unused.  */\n-\t  if (TREE_CODE (TREE_TYPE (n->symbol.decl)) == METHOD_TYPE\n+\t  if (TREE_CODE (TREE_TYPE (n->decl)) == METHOD_TYPE\n \t      && type_in_anonymous_namespace_p\n-\t\t    (method_class_type (TREE_TYPE (n->symbol.decl))))\n+\t\t    (method_class_type (TREE_TYPE (n->decl))))\n \t    continue;\n \n \t  /* Prior inlining, keep alive bodies of possible targets for\n \t     devirtualization.  */\n-\t   if (n->symbol.definition\n+\t   if (n->definition\n \t       && before_inlining_p)\n \t     pointer_set_insert (reachable, n);\n \n \t  /* Even after inlining we want to keep the possible targets in the\n \t     boundary, so late passes can still produce direct call even if\n \t     the chance for inlining is lost.  */\n-\t  enqueue_node ((symtab_node) n, first, reachable);\n+\t  enqueue_node (n, first, reachable);\n \t}\n     }\n \n@@ -218,8 +218,8 @@ walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n \t    fprintf (dump_file,\n \t\t     \"Devirtualizing call in %s/%i to %s/%i\\n\",\n \t\t     cgraph_node_name (edge->caller),\n-\t\t     edge->caller->symbol.order,\n-\t\t     cgraph_node_name (target), target->symbol.order);\n+\t\t     edge->caller->order,\n+\t\t     cgraph_node_name (target), target->order);\n \t  edge = cgraph_make_edge_direct (edge, target);\n \t  if (!inline_summary_vec && edge->call_stmt)\n \t    cgraph_redirect_edge_call_stmt_to_callee (edge);\n@@ -305,9 +305,9 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n     fprintf (file, \"\\nReclaiming functions:\");\n #ifdef ENABLE_CHECKING\n   FOR_EACH_FUNCTION (node)\n-    gcc_assert (!node->symbol.aux);\n+    gcc_assert (!node->aux);\n   FOR_EACH_VARIABLE (vnode)\n-    gcc_assert (!vnode->symbol.aux);\n+    gcc_assert (!vnode->aux);\n #endif\n   /* Mark functions whose bodies are obviously needed.\n      This is mostly when they can be referenced externally.  Inline clones\n@@ -316,26 +316,26 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   FOR_EACH_FUNCTION (node)\n     {\n       node->used_as_abstract_origin = false;\n-      if (node->symbol.definition\n+      if (node->definition\n \t  && !node->global.inlined_to\n-\t  && !node->symbol.in_other_partition\n+\t  && !node->in_other_partition\n \t  && !cgraph_can_remove_if_no_direct_calls_and_refs_p (node))\n \t{\n \t  gcc_assert (!node->global.inlined_to);\n \t  pointer_set_insert (reachable, node);\n-\t  enqueue_node ((symtab_node)node, &first, reachable);\n+\t  enqueue_node (node, &first, reachable);\n \t}\n       else\n-\tgcc_assert (!node->symbol.aux);\n+\tgcc_assert (!node->aux);\n      }\n \n   /* Mark variables that are obviously needed.  */\n   FOR_EACH_DEFINED_VARIABLE (vnode)\n     if (!varpool_can_remove_if_no_refs (vnode)\n-\t&& !vnode->symbol.in_other_partition)\n+\t&& !vnode->in_other_partition)\n       {\n \tpointer_set_insert (reachable, vnode);\n-\tenqueue_node ((symtab_node)vnode, &first, reachable);\n+\tenqueue_node (vnode, &first, reachable);\n       }\n \n   /* Perform reachability analysis.  */\n@@ -344,34 +344,34 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n       bool in_boundary_p = !pointer_set_contains (reachable, first);\n       symtab_node node = first;\n \n-      first = (symtab_node)first->symbol.aux;\n+      first = (symtab_node)first->aux;\n \n       /* If we are processing symbol in boundary, mark its AUX pointer for\n \t possible later re-processing in enqueue_node.  */\n       if (in_boundary_p)\n-\tnode->symbol.aux = (void *)2;\n+\tnode->aux = (void *)2;\n       else\n \t{\n-\t  if (DECL_ABSTRACT_ORIGIN (node->symbol.decl))\n+\t  if (DECL_ABSTRACT_ORIGIN (node->decl))\n \t    {\n \t      struct cgraph_node *origin_node\n-\t      = cgraph_get_create_real_symbol_node (DECL_ABSTRACT_ORIGIN (node->symbol.decl));\n+\t      = cgraph_get_create_real_symbol_node (DECL_ABSTRACT_ORIGIN (node->decl));\n \t      origin_node->used_as_abstract_origin = true;\n-\t      enqueue_node ((symtab_node) origin_node, &first, reachable);\n+\t      enqueue_node (origin_node, &first, reachable);\n \t    }\n \t  /* If any symbol in a comdat group is reachable, force\n \t     all other in the same comdat group to be also reachable.  */\n-\t  if (node->symbol.same_comdat_group)\n+\t  if (node->same_comdat_group)\n \t    {\n \t      symtab_node next;\n-\t      for (next = node->symbol.same_comdat_group;\n+\t      for (next = node->same_comdat_group;\n \t\t   next != node;\n-\t\t   next = next->symbol.same_comdat_group)\n+\t\t   next = next->same_comdat_group)\n \t\tif (!pointer_set_insert (reachable, next))\n-\t\t  enqueue_node ((symtab_node) next, &first, reachable);\n+\t\t  enqueue_node (next, &first, reachable);\n \t    }\n \t  /* Mark references as reachable.  */\n-\t  process_references (&node->symbol.ref_list, &first,\n+\t  process_references (&node->ref_list, &first,\n \t\t\t      before_inlining_p, reachable);\n \t}\n \n@@ -397,31 +397,31 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t}\n \t      for (e = cnode->callees; e; e = e->next_callee)\n \t\t{\n-\t\t  if (e->callee->symbol.definition\n-\t\t      && !e->callee->symbol.in_other_partition\n+\t\t  if (e->callee->definition\n+\t\t      && !e->callee->in_other_partition\n \t\t      && (!e->inline_failed\n-\t\t\t  || !DECL_EXTERNAL (e->callee->symbol.decl)\n-\t\t\t  || e->callee->symbol.alias\n+\t\t\t  || !DECL_EXTERNAL (e->callee->decl)\n+\t\t\t  || e->callee->alias\n \t\t\t  || before_inlining_p))\n \t\t    pointer_set_insert (reachable, e->callee);\n-\t\t  enqueue_node ((symtab_node) e->callee, &first, reachable);\n+\t\t  enqueue_node (e->callee, &first, reachable);\n \t\t}\n \n \t      /* When inline clone exists, mark body to be preserved so when removing\n \t\t offline copy of the function we don't kill it.  */\n \t      if (cnode->global.inlined_to)\n-\t        pointer_set_insert (body_needed_for_clonning, cnode->symbol.decl);\n+\t        pointer_set_insert (body_needed_for_clonning, cnode->decl);\n \n \t      /* For non-inline clones, force their origins to the boundary and ensure\n \t\t that body is not removed.  */\n \t      while (cnode->clone_of)\n \t\t{\n-\t\t  bool noninline = cnode->clone_of->symbol.decl != cnode->symbol.decl;\n+\t\t  bool noninline = cnode->clone_of->decl != cnode->decl;\n \t\t  cnode = cnode->clone_of;\n \t\t  if (noninline)\n \t\t    {\n-\t\t      pointer_set_insert (body_needed_for_clonning, cnode->symbol.decl);\n-\t\t      enqueue_node ((symtab_node)cnode, &first, reachable);\n+\t\t      pointer_set_insert (body_needed_for_clonning, cnode->decl);\n+\t\t      enqueue_node (cnode, &first, reachable);\n \t\t    }\n \t\t}\n \t    }\n@@ -431,12 +431,12 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \trefers to.  */\n       varpool_node *vnode = dyn_cast <varpool_node> (node);\n       if (vnode\n-\t  && DECL_EXTERNAL (node->symbol.decl)\n-\t  && !vnode->symbol.alias\n+\t  && DECL_EXTERNAL (node->decl)\n+\t  && !vnode->alias\n \t  && in_boundary_p)\n \t{\n \t  struct ipa_ref *ref;\n-\t  for (int i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list, i, ref); i++)\n+\t  for (int i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref); i++)\n \t    enqueue_node (ref->referred, &first, reachable);\n \t}\n     }\n@@ -447,7 +447,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n       next = cgraph_next_function (node);\n \n       /* If node is not needed at all, remove it.  */\n-      if (!node->symbol.aux)\n+      if (!node->aux)\n \t{\n \t  if (file)\n \t    fprintf (file, \" %s\", cgraph_node_name (node));\n@@ -457,29 +457,29 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n       /* If node is unreachable, remove its body.  */\n       else if (!pointer_set_contains (reachable, node))\n         {\n-\t  if (!pointer_set_contains (body_needed_for_clonning, node->symbol.decl))\n+\t  if (!pointer_set_contains (body_needed_for_clonning, node->decl))\n \t    cgraph_release_function_body (node);\n \t  else if (!node->clone_of)\n-\t    gcc_assert (in_lto_p || DECL_RESULT (node->symbol.decl));\n-\t  if (node->symbol.definition)\n+\t    gcc_assert (in_lto_p || DECL_RESULT (node->decl));\n+\t  if (node->definition)\n \t    {\n \t      if (file)\n \t\tfprintf (file, \" %s\", cgraph_node_name (node));\n-\t      node->symbol.analyzed = false;\n-\t      node->symbol.definition = false;\n-\t      node->symbol.cpp_implicit_alias = false;\n-\t      node->symbol.alias = false;\n-\t      node->symbol.weakref = false;\n-\t      if (!node->symbol.in_other_partition)\n+\t      node->analyzed = false;\n+\t      node->definition = false;\n+\t      node->cpp_implicit_alias = false;\n+\t      node->alias = false;\n+\t      node->weakref = false;\n+\t      if (!node->in_other_partition)\n \t\tnode->local.local = false;\n \t      cgraph_node_remove_callees (node);\n-\t      ipa_remove_all_references (&node->symbol.ref_list);\n+\t      ipa_remove_all_references (&node->ref_list);\n \t      changed = true;\n \t    }\n \t}\n       else\n \tgcc_assert (node->clone_of || !cgraph_function_with_gimple_body_p (node)\n-\t\t    || in_lto_p || DECL_RESULT (node->symbol.decl));\n+\t\t    || in_lto_p || DECL_RESULT (node->decl));\n     }\n \n   /* Inline clones might be kept around so their materializing allows further\n@@ -494,7 +494,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  node->global.inlined_to = NULL;\n \t  update_inlined_to_pointer (node, node);\n \t}\n-      node->symbol.aux = NULL;\n+      node->aux = NULL;\n     }\n \n   /* Remove unreachable variables.  */\n@@ -503,11 +503,11 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   for (vnode = varpool_first_variable (); vnode; vnode = vnext)\n     {\n       vnext = varpool_next_variable (vnode);\n-      if (!vnode->symbol.aux\n+      if (!vnode->aux\n \t  /* For can_refer_decl_in_current_unit_p we want to track for\n \t     all external variables if they are defined in other partition\n \t     or not.  */\n-\t  && (!flag_ltrans || !DECL_EXTERNAL (vnode->symbol.decl)))\n+\t  && (!flag_ltrans || !DECL_EXTERNAL (vnode->decl)))\n \t{\n \t  if (file)\n \t    fprintf (file, \" %s\", varpool_node_name (vnode));\n@@ -517,25 +517,25 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n       else if (!pointer_set_contains (reachable, vnode))\n         {\n \t  tree init;\n-\t  if (vnode->symbol.definition)\n+\t  if (vnode->definition)\n \t    {\n \t      if (file)\n \t\tfprintf (file, \" %s\", varpool_node_name (vnode));\n \t      changed = true;\n \t    }\n-\t  vnode->symbol.definition = false;\n-\t  vnode->symbol.analyzed = false;\n-\t  vnode->symbol.aux = NULL;\n+\t  vnode->definition = false;\n+\t  vnode->analyzed = false;\n+\t  vnode->aux = NULL;\n \n \t  /* Keep body if it may be useful for constant folding.  */\n-\t  if ((init = ctor_for_folding (vnode->symbol.decl)) == error_mark_node)\n+\t  if ((init = ctor_for_folding (vnode->decl)) == error_mark_node)\n \t    varpool_remove_initializer (vnode);\n \t  else\n-\t    DECL_INITIAL (vnode->symbol.decl) = init;\n-\t  ipa_remove_all_references (&vnode->symbol.ref_list);\n+\t    DECL_INITIAL (vnode->decl) = init;\n+\t  ipa_remove_all_references (&vnode->ref_list);\n \t}\n       else\n-\tvnode->symbol.aux = NULL;\n+\tvnode->aux = NULL;\n     }\n \n   pointer_set_destroy (reachable);\n@@ -546,14 +546,14 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   if (file)\n     fprintf (file, \"\\nClearing address taken flags:\");\n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (node->symbol.address_taken\n-\t&& !node->symbol.used_from_other_partition)\n+    if (node->address_taken\n+\t&& !node->used_from_other_partition)\n       {\n \tif (!cgraph_for_node_and_aliases (node, has_addr_references_p, NULL, true))\n \t  {\n \t    if (file)\n \t      fprintf (file, \" %s\", cgraph_node_name (node));\n-\t    node->symbol.address_taken = false;\n+\t    node->address_taken = false;\n \t    changed = true;\n \t    if (cgraph_local_node_p (node))\n \t      {\n@@ -595,15 +595,15 @@ ipa_discover_readonly_nonaddressable_vars (void)\n   if (dump_file)\n     fprintf (dump_file, \"Clearing variable flags:\");\n   FOR_EACH_VARIABLE (vnode)\n-    if (vnode->symbol.definition && varpool_all_refs_explicit_p (vnode)\n-\t&& (TREE_ADDRESSABLE (vnode->symbol.decl)\n-\t    || !TREE_READONLY (vnode->symbol.decl)))\n+    if (vnode->definition && varpool_all_refs_explicit_p (vnode)\n+\t&& (TREE_ADDRESSABLE (vnode->decl)\n+\t    || !TREE_READONLY (vnode->decl)))\n       {\n \tbool written = false;\n \tbool address_taken = false;\n \tint i;\n         struct ipa_ref *ref;\n-        for (i = 0; ipa_ref_list_referring_iterate (&vnode->symbol.ref_list,\n+        for (i = 0; ipa_ref_list_referring_iterate (&vnode->ref_list,\n \t\t\t\t\t\t   i, ref)\n \t\t    && (!written || !address_taken); i++)\n \t  switch (ref->use)\n@@ -617,21 +617,21 @@ ipa_discover_readonly_nonaddressable_vars (void)\n \t      written = true;\n \t      break;\n \t    }\n-\tif (TREE_ADDRESSABLE (vnode->symbol.decl) && !address_taken)\n+\tif (TREE_ADDRESSABLE (vnode->decl) && !address_taken)\n \t  {\n \t    if (dump_file)\n \t      fprintf (dump_file, \" %s (addressable)\", varpool_node_name (vnode));\n-\t    TREE_ADDRESSABLE (vnode->symbol.decl) = 0;\n+\t    TREE_ADDRESSABLE (vnode->decl) = 0;\n \t  }\n-\tif (!TREE_READONLY (vnode->symbol.decl) && !address_taken && !written\n+\tif (!TREE_READONLY (vnode->decl) && !address_taken && !written\n \t    /* Making variable in explicit section readonly can cause section\n \t       type conflict. \n \t       See e.g. gcc.c-torture/compile/pr23237.c */\n-\t    && DECL_SECTION_NAME (vnode->symbol.decl) == NULL)\n+\t    && DECL_SECTION_NAME (vnode->decl) == NULL)\n \t  {\n \t    if (dump_file)\n \t      fprintf (dump_file, \" %s (read-only)\", varpool_node_name (vnode));\n-\t    TREE_READONLY (vnode->symbol.decl) = 1;\n+\t    TREE_READONLY (vnode->decl) = 1;\n \t  }\n       }\n   if (dump_file)\n@@ -644,15 +644,15 @@ address_taken_from_non_vtable_p (symtab_node node)\n {\n   int i;\n   struct ipa_ref *ref;\n-  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list,\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list,\n \t\t\t\t\t     i, ref); i++)\n     if (ref->use == IPA_REF_ADDR)\n       {\n \tstruct varpool_node *node;\n \tif (is_a <cgraph_node> (ref->referring))\n \t  return true;\n \tnode = ipa_ref_referring_varpool_node (ref);\n-\tif (!DECL_VIRTUAL_P (node->symbol.decl))\n+\tif (!DECL_VIRTUAL_P (node->decl))\n \t  return true;\n       }\n   return false;\n@@ -667,29 +667,29 @@ comdat_can_be_unshared_p_1 (symtab_node node)\n      break eventually. Exception are virutal functions, C++\n      constructors/destructors and vtables, where this is not possible by\n      language standard.  */\n-  if (!DECL_VIRTUAL_P (node->symbol.decl)\n-      && (TREE_CODE (node->symbol.decl) != FUNCTION_DECL\n-\t  || (!DECL_CXX_CONSTRUCTOR_P (node->symbol.decl)\n-\t      && !DECL_CXX_DESTRUCTOR_P (node->symbol.decl)))\n+  if (!DECL_VIRTUAL_P (node->decl)\n+      && (TREE_CODE (node->decl) != FUNCTION_DECL\n+\t  || (!DECL_CXX_CONSTRUCTOR_P (node->decl)\n+\t      && !DECL_CXX_DESTRUCTOR_P (node->decl)))\n       && address_taken_from_non_vtable_p (node))\n     return false;\n \n   /* If the symbol is used in some weird way, better to not touch it.  */\n-  if (node->symbol.force_output)\n+  if (node->force_output)\n     return false;\n \n   /* Explicit instantiations needs to be output when possibly\n      used externally.  */\n-  if (node->symbol.forced_by_abi\n-      && TREE_PUBLIC (node->symbol.decl)\n-      && (node->symbol.resolution != LDPR_PREVAILING_DEF_IRONLY\n+  if (node->forced_by_abi\n+      && TREE_PUBLIC (node->decl)\n+      && (node->resolution != LDPR_PREVAILING_DEF_IRONLY\n           && !flag_whole_program))\n     return false;\n \n   /* Non-readonly and volatile variables can not be duplicated.  */\n   if (is_a <varpool_node> (node)\n-      && (!TREE_READONLY (node->symbol.decl)\n-\t  || TREE_THIS_VOLATILE (node->symbol.decl)))\n+      && (!TREE_READONLY (node->decl)\n+\t  || TREE_THIS_VOLATILE (node->decl)))\n     return false;\n   return true;\n }\n@@ -708,15 +708,15 @@ comdat_can_be_unshared_p (symtab_node node)\n {\n   if (!comdat_can_be_unshared_p_1 (node))\n     return false;\n-  if (node->symbol.same_comdat_group)\n+  if (node->same_comdat_group)\n     {\n       symtab_node next;\n \n       /* If more than one function is in the same COMDAT group, it must\n          be shared even if just one function in the comdat group has\n          address taken.  */\n-      for (next = node->symbol.same_comdat_group;\n-\t   next != node; next = next->symbol.same_comdat_group)\n+      for (next = node->same_comdat_group;\n+\t   next != node; next = next->same_comdat_group)\n         if (!comdat_can_be_unshared_p_1 (next))\n           return false;\n     }\n@@ -729,55 +729,55 @@ static bool\n cgraph_externally_visible_p (struct cgraph_node *node,\n \t\t\t     bool whole_program)\n {\n-  if (!node->symbol.definition)\n+  if (!node->definition)\n     return false;\n-  if (!TREE_PUBLIC (node->symbol.decl)\n-      || DECL_EXTERNAL (node->symbol.decl))\n+  if (!TREE_PUBLIC (node->decl)\n+      || DECL_EXTERNAL (node->decl))\n     return false;\n \n   /* Do not try to localize built-in functions yet.  One of problems is that we\n      end up mangling their asm for WHOPR that makes it impossible to call them\n      using the implicit built-in declarations anymore.  Similarly this enables\n      us to remove them as unreachable before actual calls may appear during\n      expansion or folding.  */\n-  if (DECL_BUILT_IN (node->symbol.decl))\n+  if (DECL_BUILT_IN (node->decl))\n     return true;\n \n   /* If linker counts on us, we must preserve the function.  */\n-  if (symtab_used_from_object_file_p ((symtab_node) node))\n+  if (symtab_used_from_object_file_p (node))\n     return true;\n-  if (DECL_PRESERVE_P (node->symbol.decl))\n+  if (DECL_PRESERVE_P (node->decl))\n     return true;\n   if (lookup_attribute (\"externally_visible\",\n-\t\t\tDECL_ATTRIBUTES (node->symbol.decl)))\n+\t\t\tDECL_ATTRIBUTES (node->decl)))\n     return true;\n   if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n       && lookup_attribute (\"dllexport\",\n-\t\t\t   DECL_ATTRIBUTES (node->symbol.decl)))\n+\t\t\t   DECL_ATTRIBUTES (node->decl)))\n     return true;\n-  if (node->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY)\n+  if (node->resolution == LDPR_PREVAILING_DEF_IRONLY)\n     return false;\n   /* When doing LTO or whole program, we can bring COMDAT functoins static.\n      This improves code quality and we know we will duplicate them at most twice\n      (in the case that we are not using plugin and link with object file\n       implementing same COMDAT)  */\n   if ((in_lto_p || whole_program)\n-      && DECL_COMDAT (node->symbol.decl)\n-      && comdat_can_be_unshared_p ((symtab_node) node))\n+      && DECL_COMDAT (node->decl)\n+      && comdat_can_be_unshared_p (node))\n     return false;\n \n   /* When doing link time optimizations, hidden symbols become local.  */\n   if (in_lto_p\n-      && (DECL_VISIBILITY (node->symbol.decl) == VISIBILITY_HIDDEN\n-\t  || DECL_VISIBILITY (node->symbol.decl) == VISIBILITY_INTERNAL)\n+      && (DECL_VISIBILITY (node->decl) == VISIBILITY_HIDDEN\n+\t  || DECL_VISIBILITY (node->decl) == VISIBILITY_INTERNAL)\n       /* Be sure that node is defined in IR file, not in other object\n \t file.  In that case we don't set used_from_other_object_file.  */\n-      && node->symbol.definition)\n+      && node->definition)\n     ;\n   else if (!whole_program)\n     return true;\n \n-  if (MAIN_NAME_P (DECL_NAME (node->symbol.decl)))\n+  if (MAIN_NAME_P (DECL_NAME (node->decl)))\n     return true;\n \n   return false;\n@@ -788,26 +788,26 @@ cgraph_externally_visible_p (struct cgraph_node *node,\n bool\n varpool_externally_visible_p (struct varpool_node *vnode)\n {\n-  if (DECL_EXTERNAL (vnode->symbol.decl))\n+  if (DECL_EXTERNAL (vnode->decl))\n     return true;\n \n-  if (!TREE_PUBLIC (vnode->symbol.decl))\n+  if (!TREE_PUBLIC (vnode->decl))\n     return false;\n \n   /* If linker counts on us, we must preserve the function.  */\n-  if (symtab_used_from_object_file_p ((symtab_node) vnode))\n+  if (symtab_used_from_object_file_p (vnode))\n     return true;\n \n-  if (DECL_HARD_REGISTER (vnode->symbol.decl))\n+  if (DECL_HARD_REGISTER (vnode->decl))\n     return true;\n-  if (DECL_PRESERVE_P (vnode->symbol.decl))\n+  if (DECL_PRESERVE_P (vnode->decl))\n     return true;\n   if (lookup_attribute (\"externally_visible\",\n-\t\t\tDECL_ATTRIBUTES (vnode->symbol.decl)))\n+\t\t\tDECL_ATTRIBUTES (vnode->decl)))\n     return true;\n   if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n       && lookup_attribute (\"dllexport\",\n-\t\t\t   DECL_ATTRIBUTES (vnode->symbol.decl)))\n+\t\t\t   DECL_ATTRIBUTES (vnode->decl)))\n     return true;\n \n   /* See if we have linker information about symbol not being used or\n@@ -816,9 +816,9 @@ varpool_externally_visible_p (struct varpool_node *vnode)\n      Even if the linker clams the symbol is unused, never bring internal\n      symbols that are declared by user as used or externally visible.\n      This is needed for i.e. references from asm statements.   */\n-  if (symtab_used_from_object_file_p ((symtab_node) vnode))\n+  if (symtab_used_from_object_file_p (vnode))\n     return true;\n-  if (vnode->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY)\n+  if (vnode->resolution == LDPR_PREVAILING_DEF_IRONLY)\n     return false;\n \n   /* As a special case, the COMDAT virtual tables can be unshared.\n@@ -827,17 +827,17 @@ varpool_externally_visible_p (struct varpool_node *vnode)\n      is faster for dynamic linking.  Also this match logic hidding vtables\n      from LTO symbol tables.  */\n   if ((in_lto_p || flag_whole_program)\n-      && DECL_COMDAT (vnode->symbol.decl)\n-      && comdat_can_be_unshared_p ((symtab_node) vnode))\n+      && DECL_COMDAT (vnode->decl)\n+      && comdat_can_be_unshared_p (vnode))\n     return false;\n \n   /* When doing link time optimizations, hidden symbols become local.  */\n   if (in_lto_p\n-      && (DECL_VISIBILITY (vnode->symbol.decl) == VISIBILITY_HIDDEN\n-\t  || DECL_VISIBILITY (vnode->symbol.decl) == VISIBILITY_INTERNAL)\n+      && (DECL_VISIBILITY (vnode->decl) == VISIBILITY_HIDDEN\n+\t  || DECL_VISIBILITY (vnode->decl) == VISIBILITY_INTERNAL)\n       /* Be sure that node is defined in IR file, not in other object\n \t file.  In that case we don't set used_from_other_object_file.  */\n-      && vnode->symbol.definition)\n+      && vnode->definition)\n     ;\n   else if (!flag_whole_program)\n     return true;\n@@ -849,7 +849,7 @@ varpool_externally_visible_p (struct varpool_node *vnode)\n      FIXME: We can do so for readonly vars with no address taken and\n      possibly also for vtables since no direct pointer comparsion is done.\n      It might be interesting to do so to reduce linking overhead.  */\n-  if (DECL_COMDAT (vnode->symbol.decl) || DECL_WEAK (vnode->symbol.decl))\n+  if (DECL_COMDAT (vnode->decl) || DECL_WEAK (vnode->decl))\n     return true;\n   return false;\n }\n@@ -887,102 +887,102 @@ function_and_variable_visibility (bool whole_program)\n \n   FOR_EACH_FUNCTION (node)\n     {\n-      int flags = flags_from_decl_or_type (node->symbol.decl);\n+      int flags = flags_from_decl_or_type (node->decl);\n \n       /* Optimize away PURE and CONST constructors and destructors.  */\n       if (optimize\n \t  && (flags & (ECF_CONST | ECF_PURE))\n \t  && !(flags & ECF_LOOPING_CONST_OR_PURE))\n \t{\n-\t  DECL_STATIC_CONSTRUCTOR (node->symbol.decl) = 0;\n-\t  DECL_STATIC_DESTRUCTOR (node->symbol.decl) = 0;\n+\t  DECL_STATIC_CONSTRUCTOR (node->decl) = 0;\n+\t  DECL_STATIC_DESTRUCTOR (node->decl) = 0;\n \t}\n \n       /* Frontends and alias code marks nodes as needed before parsing is finished.\n \t We may end up marking as node external nodes where this flag is meaningless\n \t strip it.  */\n-      if (DECL_EXTERNAL (node->symbol.decl) || !node->symbol.definition)\n+      if (DECL_EXTERNAL (node->decl) || !node->definition)\n \t{\n-\t  node->symbol.force_output = 0;\n-\t  node->symbol.forced_by_abi = 0;\n+\t  node->force_output = 0;\n+\t  node->forced_by_abi = 0;\n \t}\n \n       /* C++ FE on lack of COMDAT support create local COMDAT functions\n \t (that ought to be shared but can not due to object format\n \t limitations).  It is necessary to keep the flag to make rest of C++ FE\n \t happy.  Clear the flag here to avoid confusion in middle-end.  */\n-      if (DECL_COMDAT (node->symbol.decl) && !TREE_PUBLIC (node->symbol.decl))\n-        DECL_COMDAT (node->symbol.decl) = 0;\n+      if (DECL_COMDAT (node->decl) && !TREE_PUBLIC (node->decl))\n+        DECL_COMDAT (node->decl) = 0;\n \n       /* For external decls stop tracking same_comdat_group. It doesn't matter\n \t what comdat group they are in when they won't be emitted in this TU.  */\n-      if (node->symbol.same_comdat_group && DECL_EXTERNAL (node->symbol.decl))\n+      if (node->same_comdat_group && DECL_EXTERNAL (node->decl))\n \t{\n #ifdef ENABLE_CHECKING\n \t  symtab_node n;\n \n-\t  for (n = node->symbol.same_comdat_group;\n-\t       n != (symtab_node)node;\n-\t       n = n->symbol.same_comdat_group)\n+\t  for (n = node->same_comdat_group;\n+\t       n != node;\n+\t       n = n->same_comdat_group)\n \t      /* If at least one of same comdat group functions is external,\n \t\t all of them have to be, otherwise it is a front-end bug.  */\n-\t      gcc_assert (DECL_EXTERNAL (n->symbol.decl));\n+\t      gcc_assert (DECL_EXTERNAL (n->decl));\n #endif\n-\t  symtab_dissolve_same_comdat_group_list ((symtab_node) node);\n+\t  symtab_dissolve_same_comdat_group_list (node);\n \t}\n-      gcc_assert ((!DECL_WEAK (node->symbol.decl)\n-\t\t  && !DECL_COMDAT (node->symbol.decl))\n-      \t          || TREE_PUBLIC (node->symbol.decl)\n-\t\t  || node->symbol.weakref\n-\t\t  || DECL_EXTERNAL (node->symbol.decl));\n+      gcc_assert ((!DECL_WEAK (node->decl)\n+\t\t  && !DECL_COMDAT (node->decl))\n+      \t          || TREE_PUBLIC (node->decl)\n+\t\t  || node->weakref\n+\t\t  || DECL_EXTERNAL (node->decl));\n       if (cgraph_externally_visible_p (node, whole_program))\n         {\n \t  gcc_assert (!node->global.inlined_to);\n-\t  node->symbol.externally_visible = true;\n+\t  node->externally_visible = true;\n \t}\n       else\n \t{\n-\t  node->symbol.externally_visible = false;\n-\t  node->symbol.forced_by_abi = false;\n+\t  node->externally_visible = false;\n+\t  node->forced_by_abi = false;\n \t}\n-      if (!node->symbol.externally_visible\n-\t  && node->symbol.definition && !node->symbol.weakref\n-\t  && !DECL_EXTERNAL (node->symbol.decl))\n+      if (!node->externally_visible\n+\t  && node->definition && !node->weakref\n+\t  && !DECL_EXTERNAL (node->decl))\n \t{\n \t  gcc_assert (whole_program || in_lto_p\n-\t\t      || !TREE_PUBLIC (node->symbol.decl));\n-\t  node->symbol.unique_name = ((node->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t\t\t      || node->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n-\t\t\t\t      && TREE_PUBLIC (node->symbol.decl));\n-\t  symtab_make_decl_local (node->symbol.decl);\n-\t  node->symbol.resolution = LDPR_PREVAILING_DEF_IRONLY;\n-\t  if (node->symbol.same_comdat_group)\n+\t\t      || !TREE_PUBLIC (node->decl));\n+\t  node->unique_name = ((node->resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t\t\t\t      || node->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n+\t\t\t\t      && TREE_PUBLIC (node->decl));\n+\t  symtab_make_decl_local (node->decl);\n+\t  node->resolution = LDPR_PREVAILING_DEF_IRONLY;\n+\t  if (node->same_comdat_group)\n \t    /* cgraph_externally_visible_p has already checked all other nodes\n \t       in the group and they will all be made local.  We need to\n \t       dissolve the group at once so that the predicate does not\n \t       segfault though. */\n-\t    symtab_dissolve_same_comdat_group_list ((symtab_node) node);\n+\t    symtab_dissolve_same_comdat_group_list (node);\n \t}\n \n       if (node->thunk.thunk_p\n-\t  && TREE_PUBLIC (node->symbol.decl))\n+\t  && TREE_PUBLIC (node->decl))\n \t{\n \t  struct cgraph_node *decl_node = node;\n \n \t  decl_node = cgraph_function_node (decl_node->callees->callee, NULL);\n \n \t  /* Thunks have the same visibility as function they are attached to.\n \t     Make sure the C++ front end set this up properly.  */\n-\t  if (DECL_ONE_ONLY (decl_node->symbol.decl))\n+\t  if (DECL_ONE_ONLY (decl_node->decl))\n \t    {\n-\t      gcc_checking_assert (DECL_COMDAT (node->symbol.decl)\n-\t\t\t\t   == DECL_COMDAT (decl_node->symbol.decl));\n-\t      gcc_checking_assert (DECL_COMDAT_GROUP (node->symbol.decl)\n-\t\t\t\t   == DECL_COMDAT_GROUP (decl_node->symbol.decl));\n-\t      gcc_checking_assert (node->symbol.same_comdat_group);\n+\t      gcc_checking_assert (DECL_COMDAT (node->decl)\n+\t\t\t\t   == DECL_COMDAT (decl_node->decl));\n+\t      gcc_checking_assert (DECL_COMDAT_GROUP (node->decl)\n+\t\t\t\t   == DECL_COMDAT_GROUP (decl_node->decl));\n+\t      gcc_checking_assert (node->same_comdat_group);\n \t    }\n-\t  if (DECL_EXTERNAL (decl_node->symbol.decl))\n-\t    DECL_EXTERNAL (node->symbol.decl) = 1;\n+\t  if (DECL_EXTERNAL (decl_node->decl))\n+\t    DECL_EXTERNAL (node->decl) = 1;\n \t}\n     }\n   FOR_EACH_DEFINED_FUNCTION (node)\n@@ -995,9 +995,9 @@ function_and_variable_visibility (bool whole_program)\n \t cheaper and enable more optimization.\n \n \t TODO: We can also update virtual tables.  */\n-      if (node->callers && can_replace_by_local_alias ((symtab_node)node))\n+      if (node->callers && can_replace_by_local_alias (node))\n \t{\n-\t  struct cgraph_node *alias = cgraph (symtab_nonoverwritable_alias ((symtab_node) node));\n+\t  struct cgraph_node *alias = cgraph (symtab_nonoverwritable_alias (node));\n \n \t  if (alias && alias != node)\n \t    {\n@@ -1006,9 +1006,9 @@ function_and_variable_visibility (bool whole_program)\n \t\t  struct cgraph_edge *e = node->callers;\n \n \t\t  cgraph_redirect_edge_callee (e, alias);\n-\t\t  if (gimple_has_body_p (e->caller->symbol.decl))\n+\t\t  if (gimple_has_body_p (e->caller->decl))\n \t\t    {\n-\t\t      push_cfun (DECL_STRUCT_FUNCTION (e->caller->symbol.decl));\n+\t\t      push_cfun (DECL_STRUCT_FUNCTION (e->caller->decl));\n \t\t      cgraph_redirect_edge_call_stmt_to_callee (e);\n \t\t      pop_cfun ();\n \t\t    }\n@@ -1019,10 +1019,10 @@ function_and_variable_visibility (bool whole_program)\n   FOR_EACH_VARIABLE (vnode)\n     {\n       /* weak flag makes no sense on local variables.  */\n-      gcc_assert (!DECL_WEAK (vnode->symbol.decl)\n-\t\t  || vnode->symbol.weakref\n-      \t\t  || TREE_PUBLIC (vnode->symbol.decl)\n-\t\t  || DECL_EXTERNAL (vnode->symbol.decl));\n+      gcc_assert (!DECL_WEAK (vnode->decl)\n+\t\t  || vnode->weakref\n+      \t\t  || TREE_PUBLIC (vnode->decl)\n+\t\t  || DECL_EXTERNAL (vnode->decl));\n       /* In several cases declarations can not be common:\n \n \t - when declaration has initializer\n@@ -1036,39 +1036,39 @@ function_and_variable_visibility (bool whole_program)\n \t     static int a __attribute__ ((common))\n \n \t Canonicalize things here and clear the redundant flag.  */\n-      if (DECL_COMMON (vnode->symbol.decl)\n-\t  && (!(TREE_PUBLIC (vnode->symbol.decl)\n-\t      || DECL_EXTERNAL (vnode->symbol.decl))\n-\t      || (DECL_INITIAL (vnode->symbol.decl)\n-\t\t  && DECL_INITIAL (vnode->symbol.decl) != error_mark_node)\n-\t      || DECL_WEAK (vnode->symbol.decl)\n-\t      || DECL_SECTION_NAME (vnode->symbol.decl) != NULL\n+      if (DECL_COMMON (vnode->decl)\n+\t  && (!(TREE_PUBLIC (vnode->decl)\n+\t      || DECL_EXTERNAL (vnode->decl))\n+\t      || (DECL_INITIAL (vnode->decl)\n+\t\t  && DECL_INITIAL (vnode->decl) != error_mark_node)\n+\t      || DECL_WEAK (vnode->decl)\n+\t      || DECL_SECTION_NAME (vnode->decl) != NULL\n \t      || ! (ADDR_SPACE_GENERIC_P\n-\t\t    (TYPE_ADDR_SPACE (TREE_TYPE (vnode->symbol.decl))))))\n-\tDECL_COMMON (vnode->symbol.decl) = 0;\n+\t\t    (TYPE_ADDR_SPACE (TREE_TYPE (vnode->decl))))))\n+\tDECL_COMMON (vnode->decl) = 0;\n     }\n   FOR_EACH_DEFINED_VARIABLE (vnode)\n     {\n-      if (!vnode->symbol.definition)\n+      if (!vnode->definition)\n         continue;\n       if (varpool_externally_visible_p (vnode))\n-\tvnode->symbol.externally_visible = true;\n+\tvnode->externally_visible = true;\n       else\n \t{\n-          vnode->symbol.externally_visible = false;\n-\t  vnode->symbol.forced_by_abi = false;\n+          vnode->externally_visible = false;\n+\t  vnode->forced_by_abi = false;\n \t}\n-      if (!vnode->symbol.externally_visible\n-\t  && !vnode->symbol.weakref)\n+      if (!vnode->externally_visible\n+\t  && !vnode->weakref)\n \t{\n-\t  gcc_assert (in_lto_p || whole_program || !TREE_PUBLIC (vnode->symbol.decl));\n-\t  vnode->symbol.unique_name = ((vnode->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t\t\t       || vnode->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n-\t\t\t\t       && TREE_PUBLIC (vnode->symbol.decl));\n-\t  symtab_make_decl_local (vnode->symbol.decl);\n-\t  if (vnode->symbol.same_comdat_group)\n-\t    symtab_dissolve_same_comdat_group_list ((symtab_node) vnode);\n-\t  vnode->symbol.resolution = LDPR_PREVAILING_DEF_IRONLY;\n+\t  gcc_assert (in_lto_p || whole_program || !TREE_PUBLIC (vnode->decl));\n+\t  vnode->unique_name = ((vnode->resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t\t\t\t       || vnode->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n+\t\t\t\t       && TREE_PUBLIC (vnode->decl));\n+\t  symtab_make_decl_local (vnode->decl);\n+\t  if (vnode->same_comdat_group)\n+\t    symtab_dissolve_same_comdat_group_list (vnode);\n+\t  vnode->resolution = LDPR_PREVAILING_DEF_IRONLY;\n \t}\n     }\n \n@@ -1081,12 +1081,12 @@ function_and_variable_visibility (bool whole_program)\n       fprintf (dump_file, \"\\n\\n\");\n       fprintf (dump_file, \"\\nMarking externally visible functions:\");\n       FOR_EACH_DEFINED_FUNCTION (node)\n-\tif (node->symbol.externally_visible)\n+\tif (node->externally_visible)\n \t  fprintf (dump_file, \" %s\", cgraph_node_name (node));\n       fprintf (dump_file, \"\\n\\n\");\n       fprintf (dump_file, \"\\nMarking externally visible variables:\");\n       FOR_EACH_DEFINED_VARIABLE (vnode)\n-\tif (vnode->symbol.externally_visible)\n+\tif (vnode->externally_visible)\n \t  fprintf (dump_file, \" %s\", varpool_node_name (vnode));\n       fprintf (dump_file, \"\\n\\n\");\n     }\n@@ -1363,12 +1363,12 @@ static vec<tree> static_dtors;\n static void\n record_cdtor_fn (struct cgraph_node *node)\n {\n-  if (DECL_STATIC_CONSTRUCTOR (node->symbol.decl))\n-    static_ctors.safe_push (node->symbol.decl);\n-  if (DECL_STATIC_DESTRUCTOR (node->symbol.decl))\n-    static_dtors.safe_push (node->symbol.decl);\n-  node = cgraph_get_node (node->symbol.decl);\n-  DECL_DISREGARD_INLINE_LIMITS (node->symbol.decl) = 1;\n+  if (DECL_STATIC_CONSTRUCTOR (node->decl))\n+    static_ctors.safe_push (node->decl);\n+  if (DECL_STATIC_DESTRUCTOR (node->decl))\n+    static_dtors.safe_push (node->decl);\n+  node = cgraph_get_node (node->decl);\n+  DECL_DISREGARD_INLINE_LIMITS (node->decl) = 1;\n }\n \n /* Define global constructors/destructor functions for the CDTORS, of\n@@ -1522,8 +1522,8 @@ ipa_cdtor_merge (void)\n {\n   struct cgraph_node *node;\n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (DECL_STATIC_CONSTRUCTOR (node->symbol.decl)\n-\t|| DECL_STATIC_DESTRUCTOR (node->symbol.decl))\n+    if (DECL_STATIC_CONSTRUCTOR (node->decl)\n+\t|| DECL_STATIC_DESTRUCTOR (node->decl))\n        record_cdtor_fn (node);\n   build_cdtor_fns ();\n   static_ctors.release ();"}, {"sha": "15540e40d8e5bc5e72bc137ba050865bc20cbf16", "filename": "gcc/is-a.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fis-a.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fis-a.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fis-a.h?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -112,7 +112,7 @@ example,\n   inline bool\n   is_a_helper <cgraph_node>::test (symtab_node_base *p)\n   {\n-    return p->symbol.type == SYMTAB_FUNCTION;\n+    return p->type == SYMTAB_FUNCTION;\n   }\n \n If a simple reinterpret_cast between the pointer types is incorrect, then you"}, {"sha": "d6a75fe1981f752bc7a5417f1dbbae2eab5c1f19", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -1,3 +1,12 @@\n+2013-10-29  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPatch autogenerated by refactor_symtab.py from\n+\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n+\trevision 58bb219cc090b2f4516a9297d868c245495ee622\n+\n+\t* decl.c (java_mark_decl_local): Update for conversion of symtab types\n+\tto a true class hierarchy.\n+\n 2013-10-14  David Malcolm  <dmalcolm@redhat.com>\n \n \t* lang.c (java_handle_option): Update for introduction of"}, {"sha": "0a2cecc3fef6e0f6a17d0a12404ac2305f8da903", "filename": "gcc/java/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -1904,7 +1904,7 @@ java_mark_decl_local (tree decl)\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       struct cgraph_node *node = cgraph_get_node (decl);\n-      gcc_assert (!node || !node->symbol.definition);\n+      gcc_assert (!node || !node->definition);\n     }\n #endif\n   gcc_assert (!DECL_RTL_SET_P (decl));"}, {"sha": "46797fd4ed9be2070f6925025bf327910fec4326", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 139, "deletions": 139, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -183,7 +183,7 @@ bool\n lto_symtab_encoder_encode_body_p (lto_symtab_encoder_t encoder,\n \t\t\t\t  struct cgraph_node *node)\n {\n-  int index = lto_symtab_encoder_lookup (encoder, (symtab_node)node);\n+  int index = lto_symtab_encoder_lookup (encoder, node);\n   return encoder->nodes[index].body;\n }\n \n@@ -193,8 +193,8 @@ static void\n lto_set_symtab_encoder_encode_body (lto_symtab_encoder_t encoder,\n \t\t\t\t    struct cgraph_node *node)\n {\n-  int index = lto_symtab_encoder_encode (encoder, (symtab_node)node);\n-  gcc_checking_assert (encoder->nodes[index].node == (symtab_node)node);\n+  int index = lto_symtab_encoder_encode (encoder, node);\n+  gcc_checking_assert (encoder->nodes[index].node == node);\n   encoder->nodes[index].body = true;\n }\n \n@@ -204,7 +204,7 @@ bool\n lto_symtab_encoder_encode_initializer_p (lto_symtab_encoder_t encoder,\n \t\t\t\t\t struct varpool_node *node)\n {\n-  int index = lto_symtab_encoder_lookup (encoder, (symtab_node)node);\n+  int index = lto_symtab_encoder_lookup (encoder, node);\n   if (index == LCC_NOT_FOUND)\n     return false;\n   return encoder->nodes[index].initializer;\n@@ -216,7 +216,7 @@ static void\n lto_set_symtab_encoder_encode_initializer (lto_symtab_encoder_t encoder,\n \t\t\t\t\t   struct varpool_node *node)\n {\n-  int index = lto_symtab_encoder_lookup (encoder, (symtab_node)node);\n+  int index = lto_symtab_encoder_lookup (encoder, node);\n   encoder->nodes[index].initializer = true;\n }\n \n@@ -226,7 +226,7 @@ bool\n lto_symtab_encoder_in_partition_p (lto_symtab_encoder_t encoder,\n \t\t\t\t   symtab_node node)\n {\n-  int index = lto_symtab_encoder_lookup (encoder, (symtab_node)node);\n+  int index = lto_symtab_encoder_lookup (encoder, node);\n   if (index == LCC_NOT_FOUND)\n     return false;\n   return encoder->nodes[index].in_partition;\n@@ -238,7 +238,7 @@ void\n lto_set_symtab_encoder_in_partition (lto_symtab_encoder_t encoder,\n \t\t\t\t     symtab_node node)\n {\n-  int index = lto_symtab_encoder_encode (encoder, (symtab_node)node);\n+  int index = lto_symtab_encoder_encode (encoder, node);\n   encoder->nodes[index].in_partition = true;\n }\n \n@@ -259,21 +259,21 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n     streamer_write_enum (ob->main_stream, LTO_symtab_tags, LTO_symtab_last_tag,\n \t\t\t LTO_symtab_edge);\n \n-  ref = lto_symtab_encoder_lookup (encoder, (symtab_node)edge->caller);\n+  ref = lto_symtab_encoder_lookup (encoder, edge->caller);\n   gcc_assert (ref != LCC_NOT_FOUND);\n   streamer_write_hwi_stream (ob->main_stream, ref);\n \n   if (!edge->indirect_unknown_callee)\n     {\n-      ref = lto_symtab_encoder_lookup (encoder, (symtab_node)edge->callee);\n+      ref = lto_symtab_encoder_lookup (encoder, edge->callee);\n       gcc_assert (ref != LCC_NOT_FOUND);\n       streamer_write_hwi_stream (ob->main_stream, ref);\n     }\n \n   streamer_write_gcov_count_stream (ob->main_stream, edge->count);\n \n   bp = bitpack_create (ob->main_stream);\n-  uid = (!gimple_has_body_p (edge->caller->symbol.decl)\n+  uid = (!gimple_has_body_p (edge->caller->decl)\n \t ? edge->lto_stmt_uid : gimple_uid (edge->call_stmt) + 1);\n   bp_pack_enum (&bp, cgraph_inline_failed_enum,\n \t        CIF_N_REASONS, edge->inline_failed);\n@@ -319,7 +319,7 @@ referenced_from_other_partition_p (struct ipa_ref_list *list, lto_symtab_encoder\n   struct ipa_ref *ref;\n   for (i = 0; ipa_ref_list_referring_iterate (list, i, ref); i++)\n     {\n-      if (ref->referring->symbol.in_other_partition\n+      if (ref->referring->in_other_partition\n           || !lto_symtab_encoder_in_partition_p (encoder, ref->referring))\n \treturn true;\n     }\n@@ -332,13 +332,13 @@ bool\n reachable_from_other_partition_p (struct cgraph_node *node, lto_symtab_encoder_t encoder)\n {\n   struct cgraph_edge *e;\n-  if (!node->symbol.definition)\n+  if (!node->definition)\n     return false;\n   if (node->global.inlined_to)\n     return false;\n   for (e = node->callers; e; e = e->next_caller)\n-    if (e->caller->symbol.in_other_partition\n-\t|| !lto_symtab_encoder_in_partition_p (encoder, (symtab_node)e->caller))\n+    if (e->caller->in_other_partition\n+\t|| !lto_symtab_encoder_in_partition_p (encoder, e->caller))\n       return true;\n   return false;\n }\n@@ -364,7 +364,7 @@ reachable_from_this_partition_p (struct cgraph_node *node, lto_symtab_encoder_t\n {\n   struct cgraph_edge *e;\n   for (e = node->callers; e; e = e->next_caller)\n-    if (lto_symtab_encoder_in_partition_p (encoder, (symtab_node)e->caller))\n+    if (lto_symtab_encoder_in_partition_p (encoder, e->caller))\n       return true;\n   return false;\n }\n@@ -391,16 +391,16 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   int i;\n   bool alias_p;\n \n-  boundary_p = !lto_symtab_encoder_in_partition_p (encoder, (symtab_node)node);\n+  boundary_p = !lto_symtab_encoder_in_partition_p (encoder, node);\n \n-  if (node->symbol.analyzed && !boundary_p)\n+  if (node->analyzed && !boundary_p)\n     tag = LTO_symtab_analyzed_node;\n   else\n     tag = LTO_symtab_unavail_node;\n \n   streamer_write_enum (ob->main_stream, LTO_symtab_tags, LTO_symtab_last_tag,\n \t\t       tag);\n-  streamer_write_hwi_stream (ob->main_stream, node->symbol.order);\n+  streamer_write_hwi_stream (ob->main_stream, node->order);\n \n   /* In WPA mode, we only output part of the call-graph.  Also, we\n      fake cgraph node attributes.  There are two cases that we care.\n@@ -412,7 +412,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n      Cherry-picked nodes:  These are nodes we pulled from other\n      translation units into SET during IPA-inlining.  We make them as\n      local static nodes to prevent clashes with other local statics.  */\n-  if (boundary_p && node->symbol.analyzed && !DECL_EXTERNAL (node->symbol.decl))\n+  if (boundary_p && node->analyzed && !DECL_EXTERNAL (node->decl))\n     {\n       /* Inline clones can not be part of boundary.  \n          gcc_assert (!node->global.inlined_to);  \n@@ -427,7 +427,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \n   clone_of = node->clone_of;\n   while (clone_of\n-\t && (ref = lto_symtab_encoder_lookup (encoder, (symtab_node)clone_of)) == LCC_NOT_FOUND)\n+\t && (ref = lto_symtab_encoder_lookup (encoder, clone_of)) == LCC_NOT_FOUND)\n     if (clone_of->prev_sibling_clone)\n       clone_of = clone_of->prev_sibling_clone;\n     else\n@@ -450,7 +450,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n     streamer_write_hwi_stream (ob->main_stream, ref);\n \n \n-  lto_output_fn_decl_index (ob->decl_state, ob->main_stream, node->symbol.decl);\n+  lto_output_fn_decl_index (ob->decl_state, ob->main_stream, node->decl);\n   streamer_write_gcov_count_stream (ob->main_stream, node->count);\n   streamer_write_hwi_stream (ob->main_stream, node->count_materialization_scale);\n \n@@ -463,7 +463,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n     {\n       if (node->global.inlined_to)\n \t{\n-\t  ref = lto_symtab_encoder_lookup (encoder, (symtab_node)node->global.inlined_to);\n+\t  ref = lto_symtab_encoder_lookup (encoder, node->global.inlined_to);\n \t  gcc_assert (ref != LCC_NOT_FOUND);\n \t}\n       else\n@@ -472,10 +472,10 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n       streamer_write_hwi_stream (ob->main_stream, ref);\n     }\n \n-  if (node->symbol.same_comdat_group && !boundary_p)\n+  if (node->same_comdat_group && !boundary_p)\n     {\n       ref = lto_symtab_encoder_lookup (encoder,\n-\t\t\t\t       node->symbol.same_comdat_group);\n+\t\t\t\t       node->same_comdat_group);\n       gcc_assert (ref != LCC_NOT_FOUND);\n     }\n   else\n@@ -484,20 +484,20 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \n   bp = bitpack_create (ob->main_stream);\n   bp_pack_value (&bp, node->local.local, 1);\n-  bp_pack_value (&bp, node->symbol.externally_visible, 1);\n-  bp_pack_value (&bp, node->symbol.definition, 1);\n+  bp_pack_value (&bp, node->externally_visible, 1);\n+  bp_pack_value (&bp, node->definition, 1);\n   bp_pack_value (&bp, node->local.versionable, 1);\n   bp_pack_value (&bp, node->local.can_change_signature, 1);\n   bp_pack_value (&bp, node->local.redefined_extern_inline, 1);\n-  bp_pack_value (&bp, node->symbol.force_output, 1);\n-  bp_pack_value (&bp, node->symbol.forced_by_abi, 1);\n-  bp_pack_value (&bp, node->symbol.unique_name, 1);\n-  bp_pack_value (&bp, node->symbol.address_taken, 1);\n+  bp_pack_value (&bp, node->force_output, 1);\n+  bp_pack_value (&bp, node->forced_by_abi, 1);\n+  bp_pack_value (&bp, node->unique_name, 1);\n+  bp_pack_value (&bp, node->address_taken, 1);\n   bp_pack_value (&bp, tag == LTO_symtab_analyzed_node\n-\t\t && !DECL_EXTERNAL (node->symbol.decl)\n-\t\t && !DECL_COMDAT (node->symbol.decl)\n+\t\t && !DECL_EXTERNAL (node->decl)\n+\t\t && !DECL_COMDAT (node->decl)\n \t\t && (reachable_from_other_partition_p (node, encoder)\n-\t\t     || referenced_from_other_partition_p (&node->symbol.ref_list,\n+\t\t     || referenced_from_other_partition_p (&node->ref_list,\n \t\t\t\t\t\t\t   encoder)), 1);\n   bp_pack_value (&bp, node->lowered, 1);\n   bp_pack_value (&bp, in_other_partition, 1);\n@@ -507,16 +507,16 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n      defined in other unit, we may use the info on aliases to resolve \n      symbol1 != symbol2 type tests that we can do only for locally defined objects\n      otherwise.  */\n-  alias_p = node->symbol.alias && (!boundary_p || node->symbol.weakref);\n+  alias_p = node->alias && (!boundary_p || node->weakref);\n   bp_pack_value (&bp, alias_p, 1);\n-  bp_pack_value (&bp, node->symbol.weakref, 1);\n+  bp_pack_value (&bp, node->weakref, 1);\n   bp_pack_value (&bp, node->frequency, 2);\n   bp_pack_value (&bp, node->only_called_at_startup, 1);\n   bp_pack_value (&bp, node->only_called_at_exit, 1);\n   bp_pack_value (&bp, node->tm_clone, 1);\n   bp_pack_value (&bp, node->thunk.thunk_p && !boundary_p, 1);\n   bp_pack_enum (&bp, ld_plugin_symbol_resolution,\n-\t        LDPR_NUM_KNOWN, node->symbol.resolution);\n+\t        LDPR_NUM_KNOWN, node->resolution);\n   streamer_write_bitpack (&bp);\n \n   if (node->thunk.thunk_p && !boundary_p)\n@@ -538,57 +538,57 @@ static void\n lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node *node,\n \t\t\t lto_symtab_encoder_t encoder)\n {\n-  bool boundary_p = !lto_symtab_encoder_in_partition_p (encoder, (symtab_node)node);\n+  bool boundary_p = !lto_symtab_encoder_in_partition_p (encoder, node);\n   struct bitpack_d bp;\n   int ref;\n   bool alias_p;\n \n   streamer_write_enum (ob->main_stream, LTO_symtab_tags, LTO_symtab_last_tag,\n \t\t       LTO_symtab_variable);\n-  streamer_write_hwi_stream (ob->main_stream, node->symbol.order);\n-  lto_output_var_decl_index (ob->decl_state, ob->main_stream, node->symbol.decl);\n+  streamer_write_hwi_stream (ob->main_stream, node->order);\n+  lto_output_var_decl_index (ob->decl_state, ob->main_stream, node->decl);\n   bp = bitpack_create (ob->main_stream);\n-  bp_pack_value (&bp, node->symbol.externally_visible, 1);\n-  bp_pack_value (&bp, node->symbol.force_output, 1);\n-  bp_pack_value (&bp, node->symbol.forced_by_abi, 1);\n-  bp_pack_value (&bp, node->symbol.unique_name, 1);\n-  bp_pack_value (&bp, node->symbol.definition, 1);\n-  alias_p = node->symbol.alias && (!boundary_p || node->symbol.weakref);\n+  bp_pack_value (&bp, node->externally_visible, 1);\n+  bp_pack_value (&bp, node->force_output, 1);\n+  bp_pack_value (&bp, node->forced_by_abi, 1);\n+  bp_pack_value (&bp, node->unique_name, 1);\n+  bp_pack_value (&bp, node->definition, 1);\n+  alias_p = node->alias && (!boundary_p || node->weakref);\n   bp_pack_value (&bp, alias_p, 1);\n-  bp_pack_value (&bp, node->symbol.weakref, 1);\n-  bp_pack_value (&bp, node->symbol.analyzed && !boundary_p, 1);\n-  gcc_assert (node->symbol.definition || !node->symbol.analyzed);\n+  bp_pack_value (&bp, node->weakref, 1);\n+  bp_pack_value (&bp, node->analyzed && !boundary_p, 1);\n+  gcc_assert (node->definition || !node->analyzed);\n   /* Constant pool initializers can be de-unified into individual ltrans units.\n      FIXME: Alternatively at -Os we may want to avoid generating for them the local\n      labels and share them across LTRANS partitions.  */\n-  if (DECL_IN_CONSTANT_POOL (node->symbol.decl)\n-      && !DECL_EXTERNAL (node->symbol.decl)\n-      && !DECL_COMDAT (node->symbol.decl))\n+  if (DECL_IN_CONSTANT_POOL (node->decl)\n+      && !DECL_EXTERNAL (node->decl)\n+      && !DECL_COMDAT (node->decl))\n     {\n       bp_pack_value (&bp, 0, 1);  /* used_from_other_parition.  */\n       bp_pack_value (&bp, 0, 1);  /* in_other_partition.  */\n     }\n   else\n     {\n-      bp_pack_value (&bp, node->symbol.definition\n-\t\t     && referenced_from_other_partition_p (&node->symbol.ref_list,\n+      bp_pack_value (&bp, node->definition\n+\t\t     && referenced_from_other_partition_p (&node->ref_list,\n \t\t\t\t\t\t\t   encoder), 1);\n-      bp_pack_value (&bp, node->symbol.analyzed\n-\t\t     && boundary_p && !DECL_EXTERNAL (node->symbol.decl), 1);\n+      bp_pack_value (&bp, node->analyzed\n+\t\t     && boundary_p && !DECL_EXTERNAL (node->decl), 1);\n \t  /* in_other_partition.  */\n     }\n   streamer_write_bitpack (&bp);\n-  if (node->symbol.same_comdat_group && !boundary_p)\n+  if (node->same_comdat_group && !boundary_p)\n     {\n       ref = lto_symtab_encoder_lookup (encoder,\n-\t\t\t\t       node->symbol.same_comdat_group);\n+\t\t\t\t       node->same_comdat_group);\n       gcc_assert (ref != LCC_NOT_FOUND);\n     }\n   else\n     ref = LCC_NOT_FOUND;\n   streamer_write_hwi_stream (ob->main_stream, ref);\n   streamer_write_enum (ob->main_stream, ld_plugin_symbol_resolution,\n-\t\t       LDPR_NUM_KNOWN, node->symbol.resolution);\n+\t\t       LDPR_NUM_KNOWN, node->resolution);\n }\n \n /* Output the varpool NODE to OB. \n@@ -705,13 +705,13 @@ output_refs (lto_symtab_encoder_t encoder)\n     {\n       symtab_node node = lsei_node (lsei);\n \n-      count = ipa_ref_list_nreferences (&node->symbol.ref_list);\n+      count = ipa_ref_list_nreferences (&node->ref_list);\n       if (count)\n \t{\n \t  streamer_write_gcov_count_stream (ob->main_stream, count);\n \t  streamer_write_uhwi_stream (ob->main_stream,\n \t\t\t\t     lto_symtab_encoder_lookup (encoder, node));\n-\t  for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list,\n+\t  for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list,\n \t\t\t\t\t\t      i, ref); i++)\n \t    lto_output_ref (ob, ref, encoder);\n \t}\n@@ -733,7 +733,7 @@ add_node_to (lto_symtab_encoder_t encoder, struct cgraph_node *node,\n     add_node_to (encoder, node->clone_of, include_body);\n   else if (include_body)\n     lto_set_symtab_encoder_encode_body (encoder, node);\n-  lto_symtab_encoder_encode (encoder, (symtab_node)node);\n+  lto_symtab_encoder_encode (encoder, node);\n }\n \n /* Add all references in LIST to encoders.  */\n@@ -779,13 +779,13 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n     {\n       node = lsei_cgraph_node (lsei);\n       add_node_to (encoder, node, true);\n-      lto_set_symtab_encoder_in_partition (encoder, (symtab_node)node);\n-      add_references (encoder, &node->symbol.ref_list);\n+      lto_set_symtab_encoder_in_partition (encoder, node);\n+      add_references (encoder, &node->ref_list);\n       /* For proper debug info, we need to ship the origins, too.  */\n-      if (DECL_ABSTRACT_ORIGIN (node->symbol.decl))\n+      if (DECL_ABSTRACT_ORIGIN (node->decl))\n \t{\n \t  struct cgraph_node *origin_node\n-\t  = cgraph_get_node (DECL_ABSTRACT_ORIGIN (node->symbol.decl));\n+\t  = cgraph_get_node (DECL_ABSTRACT_ORIGIN (node->decl));\n \t  add_node_to (encoder, origin_node, true);\n \t}\n     }\n@@ -794,15 +794,15 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n     {\n       struct varpool_node *vnode = lsei_varpool_node (lsei);\n \n-      lto_set_symtab_encoder_in_partition (encoder, (symtab_node)vnode);\n+      lto_set_symtab_encoder_in_partition (encoder, vnode);\n       lto_set_symtab_encoder_encode_initializer (encoder, vnode);\n-      add_references (encoder, &vnode->symbol.ref_list);\n+      add_references (encoder, &vnode->ref_list);\n       /* For proper debug info, we need to ship the origins, too.  */\n-      if (DECL_ABSTRACT_ORIGIN (vnode->symbol.decl))\n+      if (DECL_ABSTRACT_ORIGIN (vnode->decl))\n \t{\n \t  struct varpool_node *origin_node\n-\t  = varpool_get_node (DECL_ABSTRACT_ORIGIN (node->symbol.decl));\n-\t  lto_set_symtab_encoder_in_partition (encoder, (symtab_node)origin_node);\n+\t  = varpool_get_node (DECL_ABSTRACT_ORIGIN (node->decl));\n+\t  lto_set_symtab_encoder_in_partition (encoder, origin_node);\n \t}\n     }\n   /* Pickle in also the initializer of all referenced readonly variables\n@@ -815,10 +815,10 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n \t{\n \t  if (!lto_symtab_encoder_encode_initializer_p (encoder,\n \t\t\t\t\t\t\tvnode)\n-\t      && ctor_for_folding (vnode->symbol.decl) != error_mark_node)\n+\t      && ctor_for_folding (vnode->decl) != error_mark_node)\n \t    {\n \t      lto_set_symtab_encoder_encode_initializer (encoder, vnode);\n-\t      add_references (encoder, &vnode->symbol.ref_list);\n+\t      add_references (encoder, &vnode->ref_list);\n \t    }\n        }\n     }\n@@ -832,7 +832,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n       for (edge = node->callees; edge; edge = edge->next_callee)\n \t{\n \t  struct cgraph_node *callee = edge->callee;\n-\t  if (!lto_symtab_encoder_in_partition_p (encoder, (symtab_node)callee))\n+\t  if (!lto_symtab_encoder_in_partition_p (encoder, callee))\n \t    {\n \t      /* We should have moved all the inlines.  */\n \t      gcc_assert (!callee->global.inlined_to);\n@@ -859,9 +859,9 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n \n \t\t      /* Adding an external declarations into the unit serves\n \t\t\t no purpose and just increases its boundary.  */\n-\t\t      if (callee->symbol.definition\n+\t\t      if (callee->definition\n \t\t\t  && !lto_symtab_encoder_in_partition_p\n-\t\t\t       (encoder, (symtab_node)callee))\n+\t\t\t       (encoder, callee))\n \t\t\t{\n \t\t\t  gcc_assert (!callee->global.inlined_to);\n \t\t\t  add_node_to (encoder, callee, false);\n@@ -952,24 +952,24 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n \t\t      enum LTO_symtab_tags tag,\n \t\t      struct bitpack_d *bp)\n {\n-  node->symbol.aux = (void *) tag;\n-  node->symbol.lto_file_data = file_data;\n+  node->aux = (void *) tag;\n+  node->lto_file_data = file_data;\n \n   node->local.local = bp_unpack_value (bp, 1);\n-  node->symbol.externally_visible = bp_unpack_value (bp, 1);\n-  node->symbol.definition = bp_unpack_value (bp, 1);\n+  node->externally_visible = bp_unpack_value (bp, 1);\n+  node->definition = bp_unpack_value (bp, 1);\n   node->local.versionable = bp_unpack_value (bp, 1);\n   node->local.can_change_signature = bp_unpack_value (bp, 1);\n   node->local.redefined_extern_inline = bp_unpack_value (bp, 1);\n-  node->symbol.force_output = bp_unpack_value (bp, 1);\n-  node->symbol.forced_by_abi = bp_unpack_value (bp, 1);\n-  node->symbol.unique_name = bp_unpack_value (bp, 1);\n-  node->symbol.address_taken = bp_unpack_value (bp, 1);\n-  node->symbol.used_from_other_partition = bp_unpack_value (bp, 1);\n+  node->force_output = bp_unpack_value (bp, 1);\n+  node->forced_by_abi = bp_unpack_value (bp, 1);\n+  node->unique_name = bp_unpack_value (bp, 1);\n+  node->address_taken = bp_unpack_value (bp, 1);\n+  node->used_from_other_partition = bp_unpack_value (bp, 1);\n   node->lowered = bp_unpack_value (bp, 1);\n-  node->symbol.analyzed = tag == LTO_symtab_analyzed_node;\n-  node->symbol.in_other_partition = bp_unpack_value (bp, 1);\n-  if (node->symbol.in_other_partition\n+  node->analyzed = tag == LTO_symtab_analyzed_node;\n+  node->in_other_partition = bp_unpack_value (bp, 1);\n+  if (node->in_other_partition\n       /* Avoid updating decl when we are seeing just inline clone.\n \t When inlining function that has functions already inlined into it,\n \t we produce clones of inline clones.\n@@ -978,19 +978,19 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n \t we might end up streaming inline clone from other partition\n \t to support clone we are interested in. */\n       && (!node->clone_of\n-\t  || node->clone_of->symbol.decl != node->symbol.decl))\n+\t  || node->clone_of->decl != node->decl))\n     {\n-      DECL_EXTERNAL (node->symbol.decl) = 1;\n-      TREE_STATIC (node->symbol.decl) = 0;\n+      DECL_EXTERNAL (node->decl) = 1;\n+      TREE_STATIC (node->decl) = 0;\n     }\n-  node->symbol.alias = bp_unpack_value (bp, 1);\n-  node->symbol.weakref = bp_unpack_value (bp, 1);\n+  node->alias = bp_unpack_value (bp, 1);\n+  node->weakref = bp_unpack_value (bp, 1);\n   node->frequency = (enum node_frequency)bp_unpack_value (bp, 2);\n   node->only_called_at_startup = bp_unpack_value (bp, 1);\n   node->only_called_at_exit = bp_unpack_value (bp, 1);\n   node->tm_clone = bp_unpack_value (bp, 1);\n   node->thunk.thunk_p = bp_unpack_value (bp, 1);\n-  node->symbol.resolution = bp_unpack_enum (bp, ld_plugin_symbol_resolution,\n+  node->resolution = bp_unpack_enum (bp, ld_plugin_symbol_resolution,\n \t\t\t\t     LDPR_NUM_KNOWN);\n }\n \n@@ -1041,11 +1041,11 @@ input_node (struct lto_file_decl_data *file_data,\n \t from other input file.  We keep cgraph unmerged until after streaming\n \t of ipa passes is done.  Alays forcingly create a fresh node.  */\n       node = cgraph_create_empty_node ();\n-      node->symbol.decl = fn_decl;\n-      symtab_register_node ((symtab_node)node);\n+      node->decl = fn_decl;\n+      symtab_register_node (node);\n     }\n \n-  node->symbol.order = order;\n+  node->order = order;\n   if (order >= symtab_order)\n     symtab_order = order + 1;\n \n@@ -1073,7 +1073,7 @@ input_node (struct lto_file_decl_data *file_data,\n      have already been read will have their tag stored in the 'aux'\n      field.  Since built-in functions can be referenced in multiple\n      functions, they are expected to be read more than once.  */\n-  if (node->symbol.aux && !DECL_BUILT_IN (node->symbol.decl))\n+  if (node->aux && !DECL_BUILT_IN (node->decl))\n     internal_error (\"bytecode stream: found multiple instances of cgraph \"\n \t\t    \"node with uid %d\", node->uid);\n \n@@ -1084,7 +1084,7 @@ input_node (struct lto_file_decl_data *file_data,\n   node->global.inlined_to = (cgraph_node_ptr) (intptr_t) ref;\n \n   /* Store a reference for now, and fix up later to be a pointer.  */\n-  node->symbol.same_comdat_group = (symtab_node) (intptr_t) ref2;\n+  node->same_comdat_group = (symtab_node) (intptr_t) ref2;\n \n   if (node->thunk.thunk_p)\n     {\n@@ -1097,8 +1097,8 @@ input_node (struct lto_file_decl_data *file_data,\n       node->thunk.virtual_value = virtual_value;\n       node->thunk.virtual_offset_p = (type & 4);\n     }\n-  if (node->symbol.alias && !node->symbol.analyzed && node->symbol.weakref)\n-    node->symbol.alias_target = get_alias_symbol (node->symbol.decl);\n+  if (node->alias && !node->analyzed && node->weakref)\n+    node->alias_target = get_alias_symbol (node->decl);\n   node->profile_id = streamer_read_hwi (ib);\n   return node;\n }\n@@ -1125,36 +1125,36 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n      from other input file.  We keep cgraph unmerged until after streaming\n      of ipa passes is done.  Alays forcingly create a fresh node.  */\n   node = varpool_create_empty_node ();\n-  node->symbol.decl = var_decl;\n-  symtab_register_node ((symtab_node)node);\n+  node->decl = var_decl;\n+  symtab_register_node (node);\n \n-  node->symbol.order = order;\n+  node->order = order;\n   if (order >= symtab_order)\n     symtab_order = order + 1;\n-  node->symbol.lto_file_data = file_data;\n+  node->lto_file_data = file_data;\n \n   bp = streamer_read_bitpack (ib);\n-  node->symbol.externally_visible = bp_unpack_value (&bp, 1);\n-  node->symbol.force_output = bp_unpack_value (&bp, 1);\n-  node->symbol.forced_by_abi = bp_unpack_value (&bp, 1);\n-  node->symbol.unique_name = bp_unpack_value (&bp, 1);\n-  node->symbol.definition = bp_unpack_value (&bp, 1);\n-  node->symbol.alias = bp_unpack_value (&bp, 1);\n-  node->symbol.weakref = bp_unpack_value (&bp, 1);\n-  node->symbol.analyzed = bp_unpack_value (&bp, 1);\n-  node->symbol.used_from_other_partition = bp_unpack_value (&bp, 1);\n-  node->symbol.in_other_partition = bp_unpack_value (&bp, 1);\n-  if (node->symbol.in_other_partition)\n+  node->externally_visible = bp_unpack_value (&bp, 1);\n+  node->force_output = bp_unpack_value (&bp, 1);\n+  node->forced_by_abi = bp_unpack_value (&bp, 1);\n+  node->unique_name = bp_unpack_value (&bp, 1);\n+  node->definition = bp_unpack_value (&bp, 1);\n+  node->alias = bp_unpack_value (&bp, 1);\n+  node->weakref = bp_unpack_value (&bp, 1);\n+  node->analyzed = bp_unpack_value (&bp, 1);\n+  node->used_from_other_partition = bp_unpack_value (&bp, 1);\n+  node->in_other_partition = bp_unpack_value (&bp, 1);\n+  if (node->in_other_partition)\n     {\n-      DECL_EXTERNAL (node->symbol.decl) = 1;\n-      TREE_STATIC (node->symbol.decl) = 0;\n+      DECL_EXTERNAL (node->decl) = 1;\n+      TREE_STATIC (node->decl) = 0;\n     }\n-  if (node->symbol.alias && !node->symbol.analyzed && node->symbol.weakref)\n-    node->symbol.alias_target = get_alias_symbol (node->symbol.decl);\n+  if (node->alias && !node->analyzed && node->weakref)\n+    node->alias_target = get_alias_symbol (node->decl);\n   ref = streamer_read_hwi (ib);\n   /* Store a reference for now, and fix up later to be a pointer.  */\n-  node->symbol.same_comdat_group = (symtab_node) (intptr_t) ref;\n-  node->symbol.resolution = streamer_read_enum (ib, ld_plugin_symbol_resolution,\n+  node->same_comdat_group = (symtab_node) (intptr_t) ref;\n+  node->resolution = streamer_read_enum (ib, ld_plugin_symbol_resolution,\n \t\t\t\t\t        LDPR_NUM_KNOWN);\n \n   return node;\n@@ -1203,13 +1203,13 @@ input_edge (struct lto_input_block *ib, vec<symtab_node> nodes,\n   int ecf_flags = 0;\n \n   caller = cgraph (nodes[streamer_read_hwi (ib)]);\n-  if (caller == NULL || caller->symbol.decl == NULL_TREE)\n+  if (caller == NULL || caller->decl == NULL_TREE)\n     internal_error (\"bytecode stream: no caller found while reading edge\");\n \n   if (!indirect)\n     {\n       callee = cgraph (nodes[streamer_read_hwi (ib)]);\n-      if (callee == NULL || callee->symbol.decl == NULL_TREE)\n+      if (callee == NULL || callee->decl == NULL_TREE)\n \tinternal_error (\"bytecode stream: no callee found while reading edge\");\n     }\n   else\n@@ -1276,14 +1276,14 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n         input_edge (ib, nodes, true);\n       else if (tag == LTO_symtab_variable)\n         {\n-\t  node = (symtab_node)input_varpool_node (file_data, ib);\n+\t  node = input_varpool_node (file_data, ib);\n           nodes.safe_push (node);\n \t  lto_symtab_encoder_encode (file_data->symtab_node_encoder, node);\n         }\n       else\n \t{\n-\t  node = (symtab_node)input_node (file_data, ib, tag, nodes);\n-\t  if (node == NULL || node->symbol.decl == NULL_TREE)\n+\t  node = input_node (file_data, ib, tag, nodes);\n+\t  if (node == NULL || node->decl == NULL_TREE)\n \t    internal_error (\"bytecode stream: found empty cgraph node\");\n \t  nodes.safe_push (node);\n \t  lto_symtab_encoder_encode (file_data->symtab_node_encoder, node);\n@@ -1297,7 +1297,7 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n   /* AUX pointers should be all non-zero for function nodes read from the stream.  */\n #ifdef ENABLE_CHECKING\n   FOR_EACH_VEC_ELT (nodes, i, node)\n-    gcc_assert (node->symbol.aux || !is_a <cgraph_node> (node));\n+    gcc_assert (node->aux || !is_a <cgraph_node> (node));\n #endif\n   FOR_EACH_VEC_ELT (nodes, i, node)\n     {\n@@ -1307,9 +1307,9 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n \t  ref = (int) (intptr_t) cnode->global.inlined_to;\n \n \t  /* We share declaration of builtins, so we may read same node twice.  */\n-\t  if (!node->symbol.aux)\n+\t  if (!node->aux)\n \t    continue;\n-\t  node->symbol.aux = NULL;\n+\t  node->aux = NULL;\n \n \t  /* Fixup inlined_to from reference to pointer.  */\n \t  if (ref != LCC_NOT_FOUND)\n@@ -1318,16 +1318,16 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n \t    cnode->global.inlined_to = NULL;\n \t}\n \n-      ref = (int) (intptr_t) node->symbol.same_comdat_group;\n+      ref = (int) (intptr_t) node->same_comdat_group;\n \n       /* Fixup same_comdat_group from reference to pointer.  */\n       if (ref != LCC_NOT_FOUND)\n-\tnode->symbol.same_comdat_group = nodes[ref];\n+\tnode->same_comdat_group = nodes[ref];\n       else\n-\tnode->symbol.same_comdat_group = NULL;\n+\tnode->same_comdat_group = NULL;\n     }\n   FOR_EACH_VEC_ELT (nodes, i, node)\n-    node->symbol.aux = is_a <cgraph_node> (node) ? (void *)1 : NULL;\n+    node->aux = is_a <cgraph_node> (node) ? (void *)1 : NULL;\n   return nodes;\n }\n \n@@ -1509,13 +1509,13 @@ merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n      During LTRANS we already have values of count_materialization_scale\n      computed, so just update them.  */\n   FOR_EACH_FUNCTION (node)\n-    if (node->symbol.lto_file_data\n-\t&& node->symbol.lto_file_data->profile_info.runs)\n+    if (node->lto_file_data\n+\t&& node->lto_file_data->profile_info.runs)\n       {\n \tint scale;\n \n \tscale = RDIV (node->count_materialization_scale * max_runs,\n-                      node->symbol.lto_file_data->profile_info.runs);\n+                      node->lto_file_data->profile_info.runs);\n \tnode->count_materialization_scale = scale;\n \tif (scale < 0)\n \t  fatal_error (\"Profile information in %s corrupted\",\n@@ -1583,8 +1583,8 @@ input_symtab (void)\n \t node for the parent function was never emitted to the gimple\n \t file, cgraph_node will create a node for it when setting the\n \t context of the nested function.  */\n-      if (node->symbol.lto_file_data)\n-\tnode->symbol.aux = NULL;\n+      if (node->lto_file_data)\n+\tnode->aux = NULL;\n     }\n }\n \n@@ -1651,7 +1651,7 @@ output_node_opt_summary (struct output_block *ob,\n       streamer_write_bitpack (&bp);\n     }\n \n-  if (lto_symtab_encoder_in_partition_p (encoder, (symtab_node) node))\n+  if (lto_symtab_encoder_in_partition_p (encoder, node))\n     {\n       for (e = node->callees; e; e = e->next_callee)\n \toutput_edge_opt_summary (ob, e);"}, {"sha": "adc266f2c6394ae38c25a5fb36d07e2777b10353", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -433,19 +433,19 @@ lto_free_function_in_decl_state_for_node (symtab_node node)\n   struct lto_in_decl_state temp;\n   void **slot;\n \n-  if (!node->symbol.lto_file_data)\n+  if (!node->lto_file_data)\n     return;\n \n-  temp.fn_decl = node->symbol.decl;\n-  slot = htab_find_slot (node->symbol.lto_file_data->function_decl_states,\n+  temp.fn_decl = node->decl;\n+  slot = htab_find_slot (node->lto_file_data->function_decl_states,\n \t\t\t &temp, NO_INSERT);\n   if (slot && *slot)\n     {\n       lto_free_function_in_decl_state ((struct lto_in_decl_state*) *slot);\n-      htab_clear_slot (node->symbol.lto_file_data->function_decl_states,\n+      htab_clear_slot (node->lto_file_data->function_decl_states,\n \t\t       slot);\n     }\n-  node->symbol.lto_file_data = NULL;\n+  node->lto_file_data = NULL;\n }\n \n "}, {"sha": "d4a52a766712456eac71064ad30da65729f09201", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -784,7 +784,7 @@ fixup_call_stmt_edges_1 (struct cgraph_node *node, gimple *stmts,\n         fatal_error (\"Cgraph edge statement index not found\");\n     }\n   for (i = 0;\n-       ipa_ref_list_reference_iterate (&node->symbol.ref_list, i, ref);\n+       ipa_ref_list_reference_iterate (&node->ref_list, i, ref);\n        i++)\n     if (ref->lto_stmt_uid)\n       {\n@@ -807,7 +807,7 @@ fixup_call_stmt_edges (struct cgraph_node *orig, gimple *stmts)\n \n   while (orig->clone_of)\n     orig = orig->clone_of;\n-  fn = DECL_STRUCT_FUNCTION (orig->symbol.decl);\n+  fn = DECL_STRUCT_FUNCTION (orig->decl);\n \n   fixup_call_stmt_edges_1 (orig, stmts, fn);\n   if (orig->clones)\n@@ -1024,7 +1024,7 @@ lto_read_body (struct lto_file_decl_data *file_data, struct cgraph_node *node,\n   int string_offset;\n   struct lto_input_block ib_cfg;\n   struct lto_input_block ib_main;\n-  tree fn_decl = node->symbol.decl;\n+  tree fn_decl = node->decl;\n \n   header = (const struct lto_function_header *) data;\n   cfg_offset = sizeof (struct lto_function_header);"}, {"sha": "cbbd40a931c016683ed5ee5c993356cdd931330b", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -1751,7 +1751,7 @@ output_function (struct cgraph_node *node)\n   basic_block bb;\n   struct output_block *ob;\n \n-  function = node->symbol.decl;\n+  function = node->decl;\n   fn = DECL_STRUCT_FUNCTION (function);\n   ob = create_output_block (LTO_section_function_body);\n \n@@ -1910,8 +1910,8 @@ lto_output_toplevel_asms (void)\n static void\n copy_function (struct cgraph_node *node)\n {\n-  tree function = node->symbol.decl;\n-  struct lto_file_decl_data *file_data = node->symbol.lto_file_data;\n+  tree function = node->decl;\n+  struct lto_file_decl_data *file_data = node->lto_file_data;\n   struct lto_output_stream *output_stream = XCNEW (struct lto_output_stream);\n   const char *data;\n   size_t len;\n@@ -1938,7 +1938,7 @@ copy_function (struct cgraph_node *node)\n \n   /* Copy decls. */\n   in_state =\n-    lto_get_function_in_decl_state (node->symbol.lto_file_data, function);\n+    lto_get_function_in_decl_state (node->lto_file_data, function);\n   gcc_assert (in_state);\n \n   for (i = 0; i < LTO_N_DECL_STREAMS; i++)\n@@ -1986,21 +1986,21 @@ lto_output (void)\n       cgraph_node *node = dyn_cast <cgraph_node> (snode);\n       if (node\n \t  && lto_symtab_encoder_encode_body_p (encoder, node)\n-\t  && !node->symbol.alias)\n+\t  && !node->alias)\n \t{\n #ifdef ENABLE_CHECKING\n-\t  gcc_assert (!bitmap_bit_p (output, DECL_UID (node->symbol.decl)));\n-\t  bitmap_set_bit (output, DECL_UID (node->symbol.decl));\n+\t  gcc_assert (!bitmap_bit_p (output, DECL_UID (node->decl)));\n+\t  bitmap_set_bit (output, DECL_UID (node->decl));\n #endif\n \t  decl_state = lto_new_out_decl_state ();\n \t  lto_push_out_decl_state (decl_state);\n-\t  if (gimple_has_body_p (node->symbol.decl) || !flag_wpa)\n+\t  if (gimple_has_body_p (node->decl) || !flag_wpa)\n \t    output_function (node);\n \t  else\n \t    copy_function (node);\n \t  gcc_assert (lto_get_out_decl_state () == decl_state);\n \t  lto_pop_out_decl_state ();\n-\t  lto_record_function_out_decl_state (node->symbol.decl, decl_state);\n+\t  lto_record_function_out_decl_state (node->decl, decl_state);\n \t}\n     }\n \n@@ -2232,10 +2232,10 @@ write_symbol (struct streamer_tree_cache_d *cache,\n \n       /* When something is defined, it should have node attached.  */\n       gcc_assert (alias || TREE_CODE (t) != VAR_DECL\n-\t\t  || varpool_get_node (t)->symbol.definition);\n+\t\t  || varpool_get_node (t)->definition);\n       gcc_assert (alias || TREE_CODE (t) != FUNCTION_DECL\n \t\t  || (cgraph_get_node (t)\n-\t\t      && cgraph_get_node (t)->symbol.definition));\n+\t\t      && cgraph_get_node (t)->definition));\n     }\n \n   /* Imitate what default_elf_asm_output_external do.\n@@ -2299,26 +2299,26 @@ output_symbol_p (symtab_node node)\n      and devirtualization.  We do not want to see them in symbol table as\n      references unless they are really used.  */\n   cnode = dyn_cast <cgraph_node> (node);\n-  if (cnode && (!node->symbol.definition || DECL_EXTERNAL (cnode->symbol.decl))\n+  if (cnode && (!node->definition || DECL_EXTERNAL (cnode->decl))\n       && cnode->callers)\n     return true;\n \n  /* Ignore all references from external vars initializers - they are not really\n     part of the compilation unit until they are used by folding.  Some symbols,\n     like references to external construction vtables can not be referred to at all.\n     We decide this at can_refer_decl_in_current_unit_p.  */\n- if (!node->symbol.definition || DECL_EXTERNAL (node->symbol.decl))\n+ if (!node->definition || DECL_EXTERNAL (node->decl))\n     {\n       int i;\n       struct ipa_ref *ref;\n-      for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list,\n+      for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list,\n \t\t\t\t\t          i, ref); i++)\n \t{\n \t  if (ref->use == IPA_REF_ALIAS)\n \t    continue;\n           if (is_a <cgraph_node> (ref->referring))\n \t    return true;\n-\t  if (!DECL_EXTERNAL (ref->referring->symbol.decl))\n+\t  if (!DECL_EXTERNAL (ref->referring->decl))\n \t    return true;\n \t}\n       return false;\n@@ -2354,18 +2354,18 @@ produce_symtab (struct output_block *ob)\n     {\n       symtab_node node = lsei_node (lsei);\n \n-      if (!output_symbol_p (node) || DECL_EXTERNAL (node->symbol.decl))\n+      if (!output_symbol_p (node) || DECL_EXTERNAL (node->decl))\n \tcontinue;\n-      write_symbol (cache, &stream, node->symbol.decl, seen, false);\n+      write_symbol (cache, &stream, node->decl, seen, false);\n     }\n   for (lsei = lsei_start (encoder);\n        !lsei_end_p (lsei); lsei_next (&lsei))\n     {\n       symtab_node node = lsei_node (lsei);\n \n-      if (!output_symbol_p (node) || !DECL_EXTERNAL (node->symbol.decl))\n+      if (!output_symbol_p (node) || !DECL_EXTERNAL (node->decl))\n \tcontinue;\n-      write_symbol (cache, &stream, node->symbol.decl, seen, false);\n+      write_symbol (cache, &stream, node->decl, seen, false);\n     }\n \n   lto_write_stream (&stream);"}, {"sha": "d1f5d496755c01e713d9f871bcd44671a954fd62", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -1,3 +1,47 @@\n+2013-10-29  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPatch autogenerated by refactor_symtab.py from\n+\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n+\trevision 58bb219cc090b2f4516a9297d868c245495ee622\n+\n+\t* lto-partition.c (lto_promote_cross_file_statics): Update for\n+\tconversion of symtab types to a true class hierarchy.\n+\t(rename_statics): Likewise.\n+\t(promote_symbol): Likewise.\n+\t(privatize_symbol_name): Likewise.\n+\t(lto_balanced_map): Likewise.\n+\t(varpool_node_cmp): Likewise.\n+\t(node_cmp): Likewise.\n+\t(lto_1_to_1_map): Likewise.\n+\t(undo_partition): Likewise.\n+\t(add_symbol_to_partition): Likewise.\n+\t(contained_in_symbol): Likewise.\n+\t(add_symbol_to_partition_1): Likewise.\n+\t(add_references_to_partition): Likewise.\n+\t(symbol_partitioned_p): Likewise.\n+\t(get_symbol_class): Likewise.\n+\t(lto_max_map): Likewise.\n+\t* lto-symtab.c (lto_symtab_prevailing_decl): Likewise.\n+\t(lto_symtab_merge_symbols): Likewise.\n+\t(lto_symtab_merge_symbols_1): Likewise.\n+\t(lto_symtab_merge_decls): Likewise.\n+\t(lto_symtab_merge_decls_1): Likewise.\n+\t(lto_symtab_merge_decls_2): Likewise.\n+\t(lto_symtab_resolve_symbols): Likewise.\n+\t(lto_symtab_resolve_can_prevail_p): Likewise.\n+\t(lto_symtab_symbol_p): Likewise.\n+\t(lto_symtab_resolve_replaceable_p): Likewise.\n+\t(lto_symtab_merge): Likewise.\n+\t(lto_varpool_replace_node): Likewise.\n+\t(lto_cgraph_replace_node): Likewise.\n+\t* lto.c (lto_main): Likewise.\n+\t(do_whole_program_analysis): Likewise.\n+\t(materialize_cgraph): Likewise.\n+\t(read_cgraph_and_symbols): Likewise.\n+\t(cmp_partitions_order): Likewise.\n+\t(lto_materialize_function): Likewise.\n+\t(has_analyzed_clone_p): Likewise.\n+\n 2013-10-29  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* lto/lto-object.c: Add gimple.h to include list."}, {"sha": "4abeb117fa0860ebaf9d776d0e74145371b33e6f", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 100, "deletions": 100, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -58,41 +58,41 @@ get_symbol_class (symtab_node node)\n      This include external delcarations.   */\n   cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n \n-  if (DECL_ABSTRACT (node->symbol.decl))\n+  if (DECL_ABSTRACT (node->decl))\n     return SYMBOL_EXTERNAL;\n \n   if (cnode && cnode->global.inlined_to)\n     return SYMBOL_DUPLICATE;\n \n   /* Weakref aliases are always duplicated.  */\n-  if (node->symbol.weakref)\n+  if (node->weakref)\n     return SYMBOL_DUPLICATE;\n \n   /* External declarations are external.  */\n-  if (DECL_EXTERNAL (node->symbol.decl))\n+  if (DECL_EXTERNAL (node->decl))\n     return SYMBOL_EXTERNAL;\n \n   if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n     {\n       /* Constant pool references use local symbol names that can not\n          be promoted global.  We should never put into a constant pool\n          objects that can not be duplicated across partitions.  */\n-      if (DECL_IN_CONSTANT_POOL (node->symbol.decl))\n+      if (DECL_IN_CONSTANT_POOL (node->decl))\n \treturn SYMBOL_DUPLICATE;\n-      gcc_checking_assert (vnode->symbol.definition);\n+      gcc_checking_assert (vnode->definition);\n     }\n   /* Functions that are cloned may stay in callgraph even if they are unused.\n      Handle them as external; compute_ltrans_boundary take care to make\n      proper things to happen (i.e. to make them appear in the boundary but\n      with body streamed, so clone can me materialized).  */\n-  else if (!cgraph (node)->symbol.definition)\n+  else if (!cgraph (node)->definition)\n     return SYMBOL_EXTERNAL;\n \n   /* Comdats are duplicated to every use unless they are keyed.\n      Those do not need duplication.  */\n-  if (DECL_COMDAT (node->symbol.decl)\n-      && !node->symbol.force_output\n-      && !symtab_used_from_object_file_p ((symtab_node) node))\n+  if (DECL_COMDAT (node->decl)\n+      && !node->force_output\n+      && !symtab_used_from_object_file_p (node))\n     return SYMBOL_DUPLICATE;\n \n   return SYMBOL_PARTITION;\n@@ -133,7 +133,7 @@ free_ltrans_partitions (void)\n static inline bool\n symbol_partitioned_p (symtab_node node)\n {\n-  return node->symbol.aux;\n+  return node->aux;\n }\n \n /* Add references into the partition.  */\n@@ -144,14 +144,14 @@ add_references_to_partition (ltrans_partition part, symtab_node node)\n   struct ipa_ref *ref;\n \n   /* Add all duplicated references to the partition.  */\n-  for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref); i++)\n     if (get_symbol_class (ref->referred) == SYMBOL_DUPLICATE)\n       add_symbol_to_partition (part, ref->referred);\n     /* References to a readonly variable may be constant foled into its value.\n        Recursively look into the initializers of the constant variable and add\n        references, too.  */\n     else if (is_a <varpool_node> (ref->referred)\n-\t     && ctor_for_folding (ref->referred->symbol.decl) != error_mark_node\n+\t     && ctor_for_folding (ref->referred->decl) != error_mark_node\n \t     && !lto_symtab_encoder_in_partition_p (part->encoder, ref->referred))\n       {\n \tif (!part->initializers_visited)\n@@ -173,15 +173,15 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node node)\n   symtab_node node1;\n \n   /* If NODE is already there, we have nothing to do.  */\n-  if (lto_symtab_encoder_in_partition_p (part->encoder, (symtab_node) node))\n+  if (lto_symtab_encoder_in_partition_p (part->encoder, node))\n     return true;\n \n   /* non-duplicated aliases or tunks of a duplicated symbol needs to be output\n      just once.\n \n      Be lax about comdats; they may or may not be duplicated and we may\n      end up in need to duplicate keyed comdat because it has unkeyed alias.  */\n-  if (c == SYMBOL_PARTITION && !DECL_COMDAT (node->symbol.decl)\n+  if (c == SYMBOL_PARTITION && !DECL_COMDAT (node->decl)\n       && symbol_partitioned_p (node))\n     return false;\n \n@@ -190,16 +190,16 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node node)\n   gcc_assert (c != SYMBOL_EXTERNAL\n \t      && (c == SYMBOL_DUPLICATE || !symbol_partitioned_p (node)));\n \n-  lto_set_symtab_encoder_in_partition (part->encoder, (symtab_node) node);\n+  lto_set_symtab_encoder_in_partition (part->encoder, node);\n \n   if (symbol_partitioned_p (node))\n     {\n-      node->symbol.in_other_partition = 1;\n+      node->in_other_partition = 1;\n       if (cgraph_dump_file)\n         fprintf (cgraph_dump_file, \"Symbol node %s now used in multiple partitions\\n\",\n \t\t symtab_node_name (node));\n     }\n-  node->symbol.aux = (void *)((size_t)node->symbol.aux + 1);\n+  node->aux = (void *)((size_t)node->aux + 1);\n \n   if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n     {\n@@ -209,27 +209,27 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node node)\n       /* Add all inline clones and callees that are duplicated.  */\n       for (e = cnode->callees; e; e = e->next_callee)\n \tif (!e->inline_failed)\n-\t  add_symbol_to_partition_1 (part, (symtab_node) e->callee);\n-\telse if (get_symbol_class ((symtab_node) e->callee) == SYMBOL_DUPLICATE)\n-\t  add_symbol_to_partition (part, (symtab_node) e->callee);\n+\t  add_symbol_to_partition_1 (part, e->callee);\n+\telse if (get_symbol_class (e->callee) == SYMBOL_DUPLICATE)\n+\t  add_symbol_to_partition (part, e->callee);\n \n       /* Add all thunks associated with the function.  */\n       for (e = cnode->callers; e; e = e->next_caller)\n \tif (e->caller->thunk.thunk_p)\n-\t  add_symbol_to_partition_1 (part, (symtab_node) e->caller);\n+\t  add_symbol_to_partition_1 (part, e->caller);\n     }\n \n   add_references_to_partition (part, node);\n \n   /* Add all aliases associated with the symbol.  */\n-  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list, i, ref); i++)\n-    if (ref->use == IPA_REF_ALIAS && !node->symbol.weakref)\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list, i, ref); i++)\n+    if (ref->use == IPA_REF_ALIAS && !node->weakref)\n       add_symbol_to_partition_1 (part, ref->referring);\n \n   /* Ensure that SAME_COMDAT_GROUP lists all allways added in a group.  */\n-  if (node->symbol.same_comdat_group)\n-    for (node1 = node->symbol.same_comdat_group;\n-\t node1 != node; node1 = node1->symbol.same_comdat_group)\n+  if (node->same_comdat_group)\n+    for (node1 = node->same_comdat_group;\n+\t node1 != node; node1 = node1->same_comdat_group)\n       {\n \tbool added = add_symbol_to_partition_1 (part, node1);\n \tgcc_assert (added);\n@@ -245,17 +245,17 @@ static symtab_node\n contained_in_symbol (symtab_node node)\n {\n   /* Weakrefs are never contained in anything.  */\n-  if (node->symbol.weakref)\n+  if (node->weakref)\n     return node;\n   if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n     {\n       cnode = cgraph_function_node (cnode, NULL);\n       if (cnode->global.inlined_to)\n \tcnode = cnode->global.inlined_to;\n-      return (symtab_node) cnode;\n+      return cnode;\n     }\n   else if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n-    return (symtab_node) varpool_variable_node (vnode, NULL);\n+    return varpool_variable_node (vnode, NULL);\n   return node;\n }\n \n@@ -281,7 +281,7 @@ add_symbol_to_partition (ltrans_partition part, symtab_node node)\n      Be lax about comdats; they may or may not be duplicated and we may\n      end up in need to duplicate keyed comdat because it has unkeyed alias.  */\n   gcc_assert (get_symbol_class (node) == SYMBOL_DUPLICATE\n-\t      || DECL_COMDAT (node->symbol.decl)\n+\t      || DECL_COMDAT (node->decl)\n \t      || !symbol_partitioned_p (node));\n   add_symbol_to_partition_1 (part, node);\n }\n@@ -305,7 +305,7 @@ undo_partition (ltrans_partition partition, unsigned int n_nodes)\n       if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n         partition->insns -= inline_summary (cnode)->self_size;\n       lto_symtab_encoder_delete_node (partition->encoder, node);\n-      node->symbol.aux = (void *)((size_t)node->symbol.aux - 1);\n+      node->aux = (void *)((size_t)node->aux - 1);\n     }\n }\n \n@@ -330,7 +330,7 @@ lto_1_to_1_map (void)\n \t  || symbol_partitioned_p (node))\n \tcontinue;\n \n-      file_data = node->symbol.lto_file_data;\n+      file_data = node->lto_file_data;\n \n       if (file_data)\n \t{\n@@ -355,7 +355,7 @@ lto_1_to_1_map (void)\n \t  npartitions++;\n \t}\n \n-      add_symbol_to_partition (partition, (symtab_node) node);\n+      add_symbol_to_partition (partition, node);\n     }\n \n   /* If the cgraph is empty, create one cgraph node set so that there is still\n@@ -382,7 +382,7 @@ lto_max_map (void)\n \t  || symbol_partitioned_p (node))\n \tcontinue;\n       partition = new_partition (symtab_node_asm_name (node));\n-      add_symbol_to_partition (partition, (symtab_node) node);\n+      add_symbol_to_partition (partition, node);\n       npartitions++;\n     }\n   if (!npartitions)\n@@ -395,7 +395,7 @@ node_cmp (const void *pa, const void *pb)\n {\n   const struct cgraph_node *a = *(const struct cgraph_node * const *) pa;\n   const struct cgraph_node *b = *(const struct cgraph_node * const *) pb;\n-  return b->symbol.order - a->symbol.order;\n+  return b->order - a->order;\n }\n \n /* Helper function for qsort; sort nodes by order.  */\n@@ -404,7 +404,7 @@ varpool_node_cmp (const void *pa, const void *pb)\n {\n   const struct varpool_node *a = *(const struct varpool_node * const *) pa;\n   const struct varpool_node *b = *(const struct varpool_node * const *) pb;\n-  return b->symbol.order - a->symbol.order;\n+  return b->order - a->order;\n }\n \n /* Group cgraph nodes into equally-sized partitions.\n@@ -466,10 +466,10 @@ lto_balanced_map (void)\n   int current_order = -1;\n \n   FOR_EACH_VARIABLE (vnode)\n-    gcc_assert (!vnode->symbol.aux);\n+    gcc_assert (!vnode->aux);\n     \n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (get_symbol_class ((symtab_node) node) == SYMBOL_PARTITION)\n+    if (get_symbol_class (node) == SYMBOL_PARTITION)\n       {\n \torder[n_nodes++] = node;\n \ttotal_size += inline_summary (node)->size;\n@@ -486,13 +486,13 @@ lto_balanced_map (void)\n       qsort (order, n_nodes, sizeof (struct cgraph_node *), node_cmp);\n \n       FOR_EACH_VARIABLE (vnode)\n-\tif (get_symbol_class ((symtab_node) vnode) == SYMBOL_PARTITION)\n+\tif (get_symbol_class (vnode) == SYMBOL_PARTITION)\n \t  n_varpool_nodes++;\n       varpool_order = XNEWVEC (struct varpool_node *, n_varpool_nodes);\n \n       n_varpool_nodes = 0;\n       FOR_EACH_VARIABLE (vnode)\n-\tif (get_symbol_class ((symtab_node) vnode) == SYMBOL_PARTITION)\n+\tif (get_symbol_class (vnode) == SYMBOL_PARTITION)\n \t  varpool_order[n_varpool_nodes++] = vnode;\n       qsort (varpool_order, n_varpool_nodes, sizeof (struct varpool_node *),\n \t     varpool_node_cmp);\n@@ -510,21 +510,21 @@ lto_balanced_map (void)\n \n   for (i = 0; i < n_nodes; i++)\n     {\n-      if (symbol_partitioned_p ((symtab_node) order[i]))\n+      if (symbol_partitioned_p (order[i]))\n \tcontinue;\n \n-      current_order = order[i]->symbol.order;\n+      current_order = order[i]->order;\n \n       if (!flag_toplevel_reorder)\n \twhile (varpool_pos < n_varpool_nodes\n-\t       && varpool_order[varpool_pos]->symbol.order < current_order)\n+\t       && varpool_order[varpool_pos]->order < current_order)\n \t  {\n-\t    if (!symbol_partitioned_p ((symtab_node) varpool_order[varpool_pos]))\n-\t      add_symbol_to_partition (partition, (symtab_node) varpool_order[varpool_pos]);\n+\t    if (!symbol_partitioned_p (varpool_order[varpool_pos]))\n+\t      add_symbol_to_partition (partition, varpool_order[varpool_pos]);\n \t    varpool_pos++;\n \t  }\n \n-      add_symbol_to_partition (partition, (symtab_node) order[i]);\n+      add_symbol_to_partition (partition, order[i]);\n       total_size -= inline_summary (order[i])->size;\n \t  \n \n@@ -552,15 +552,15 @@ lto_balanced_map (void)\n \t    {\n \t      struct cgraph_edge *edge;\n \n-\t      refs = &node->symbol.ref_list;\n+\t      refs = &node->ref_list;\n \n \t      last_visited_node++;\n \n-\t      gcc_assert (node->symbol.definition || node->symbol.weakref);\n+\t      gcc_assert (node->definition || node->weakref);\n \n \t      /* Compute boundary cost of callgraph edges.  */\n \t      for (edge = node->callees; edge; edge = edge->next_callee)\n-\t\tif (edge->callee->symbol.definition)\n+\t\tif (edge->callee->definition)\n \t\t  {\n \t\t    int edge_cost = edge->frequency;\n \t\t    int index;\n@@ -569,7 +569,7 @@ lto_balanced_map (void)\n \t\t      edge_cost = 1;\n \t\t    gcc_assert (edge_cost > 0);\n \t\t    index = lto_symtab_encoder_lookup (partition->encoder,\n-\t\t\t\t\t\t       (symtab_node)edge->callee);\n+\t\t\t\t\t\t       edge->callee);\n \t\t    if (index != LCC_NOT_FOUND\n \t\t        && index < last_visited_node - 1)\n \t\t      cost -= edge_cost, internal += edge_cost;\n@@ -581,12 +581,12 @@ lto_balanced_map (void)\n \t\t  int edge_cost = edge->frequency;\n \t\t  int index;\n \n-\t\t  gcc_assert (edge->caller->symbol.definition);\n+\t\t  gcc_assert (edge->caller->definition);\n \t\t  if (!edge_cost)\n \t\t    edge_cost = 1;\n \t\t  gcc_assert (edge_cost > 0);\n \t\t  index = lto_symtab_encoder_lookup (partition->encoder,\n-\t\t\t\t\t\t     (symtab_node)edge->caller);\n+\t\t\t\t\t\t     edge->caller);\n \t\t  if (index != LCC_NOT_FOUND\n \t\t      && index < last_visited_node - 1)\n \t\t    cost -= edge_cost;\n@@ -596,7 +596,7 @@ lto_balanced_map (void)\n \t    }\n \t  else\n \t    {\n-\t      refs = &snode->symbol.ref_list;\n+\t      refs = &snode->ref_list;\n \t      last_visited_node++;\n \t    }\n \n@@ -608,13 +608,13 @@ lto_balanced_map (void)\n \t\tint index;\n \n \t\tvnode = ipa_ref_varpool_node (ref);\n-\t\tif (!vnode->symbol.definition)\n+\t\tif (!vnode->definition)\n \t\t  continue;\n-\t\tif (!symbol_partitioned_p ((symtab_node) vnode) && flag_toplevel_reorder\n-\t\t    && get_symbol_class ((symtab_node) vnode) == SYMBOL_PARTITION)\n-\t\t  add_symbol_to_partition (partition, (symtab_node) vnode);\n+\t\tif (!symbol_partitioned_p (vnode) && flag_toplevel_reorder\n+\t\t    && get_symbol_class (vnode) == SYMBOL_PARTITION)\n+\t\t  add_symbol_to_partition (partition, vnode);\n \t\tindex = lto_symtab_encoder_lookup (partition->encoder,\n-\t\t\t\t\t\t   (symtab_node)vnode);\n+\t\t\t\t\t\t   vnode);\n \t\tif (index != LCC_NOT_FOUND\n \t\t    && index < last_visited_node - 1)\n \t\t  cost--, internal++;\n@@ -626,10 +626,10 @@ lto_balanced_map (void)\n \t\tint index;\n \n \t\tnode = ipa_ref_node (ref);\n-\t\tif (!node->symbol.definition)\n+\t\tif (!node->definition)\n \t\t  continue;\n \t\tindex = lto_symtab_encoder_lookup (partition->encoder,\n-\t\t\t\t\t\t   (symtab_node)node);\n+\t\t\t\t\t\t   node);\n \t\tif (index != LCC_NOT_FOUND\n \t\t    && index < last_visited_node - 1)\n \t\t  cost--, internal++;\n@@ -642,12 +642,12 @@ lto_balanced_map (void)\n \t\tint index;\n \n \t\tvnode = ipa_ref_referring_varpool_node (ref);\n-\t\tgcc_assert (vnode->symbol.definition);\n-\t\tif (!symbol_partitioned_p ((symtab_node) vnode) && flag_toplevel_reorder\n-\t\t    && get_symbol_class ((symtab_node) vnode) == SYMBOL_PARTITION)\n-\t\t  add_symbol_to_partition (partition, (symtab_node) vnode);\n+\t\tgcc_assert (vnode->definition);\n+\t\tif (!symbol_partitioned_p (vnode) && flag_toplevel_reorder\n+\t\t    && get_symbol_class (vnode) == SYMBOL_PARTITION)\n+\t\t  add_symbol_to_partition (partition, vnode);\n \t\tindex = lto_symtab_encoder_lookup (partition->encoder,\n-\t\t\t\t\t\t   (symtab_node)vnode);\n+\t\t\t\t\t\t   vnode);\n \t\tif (index != LCC_NOT_FOUND\n \t\t    && index < last_visited_node - 1)\n \t\t  cost--;\n@@ -659,9 +659,9 @@ lto_balanced_map (void)\n \t\tint index;\n \n \t\tnode = ipa_ref_referring_node (ref);\n-\t\tgcc_assert (node->symbol.definition);\n+\t\tgcc_assert (node->definition);\n \t\tindex = lto_symtab_encoder_lookup (partition->encoder,\n-\t\t\t\t\t\t   (symtab_node)node);\n+\t\t\t\t\t\t   node);\n \t\tif (index != LCC_NOT_FOUND\n \t\t    && index < last_visited_node - 1)\n \t\t  cost--;\n@@ -688,7 +688,7 @@ lto_balanced_map (void)\n       if (cgraph_dump_file)\n \tfprintf (cgraph_dump_file, \"Step %i: added %s/%i, size %i, cost %i/%i \"\n \t\t \"best %i/%i, step %i\\n\", i,\n-\t\t cgraph_node_name (order[i]), order[i]->symbol.order,\n+\t\t cgraph_node_name (order[i]), order[i]->order,\n \t\t partition->insns, cost, internal,\n \t\t best_cost, best_internal, best_i);\n       /* Partition is too large, unwind into step when best cost was reached and\n@@ -705,7 +705,7 @@ lto_balanced_map (void)\n \t    }\n \t  i = best_i;\n  \t  /* When we are finished, avoid creating empty partition.  */\n-\t  while (i < n_nodes - 1 && symbol_partitioned_p ((symtab_node) order[i + 1]))\n+\t  while (i < n_nodes - 1 && symbol_partitioned_p (order[i + 1]))\n \t    i++;\n \t  if (i == n_nodes - 1)\n \t    break;\n@@ -737,16 +737,16 @@ lto_balanced_map (void)\n   if (flag_toplevel_reorder)\n     {\n       FOR_EACH_VARIABLE (vnode)\n-        if (get_symbol_class ((symtab_node) vnode) == SYMBOL_PARTITION\n-\t    && !symbol_partitioned_p ((symtab_node) vnode))\n-\t  add_symbol_to_partition (partition, (symtab_node) vnode);\n+        if (get_symbol_class (vnode) == SYMBOL_PARTITION\n+\t    && !symbol_partitioned_p (vnode))\n+\t  add_symbol_to_partition (partition, vnode);\n     }\n   else\n     {\n       while (varpool_pos < n_varpool_nodes)\n \t{\n-\t  if (!symbol_partitioned_p ((symtab_node) varpool_order[varpool_pos]))\n-\t    add_symbol_to_partition (partition, (symtab_node) varpool_order[varpool_pos]);\n+\t  if (!symbol_partitioned_p (varpool_order[varpool_pos]))\n+\t    add_symbol_to_partition (partition, varpool_order[varpool_pos]);\n \t  varpool_pos++;\n \t}\n       free (varpool_order);\n@@ -765,13 +765,13 @@ lto_balanced_map (void)\n static bool\n privatize_symbol_name (symtab_node node)\n {\n-  tree decl = node->symbol.decl;\n+  tree decl = node->decl;\n   const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n \n   /* Our renaming machinery do not handle more than one change of assembler name.\n      We should not need more than one anyway.  */\n-  if (node->symbol.lto_file_data\n-      && lto_get_decl_name_mapping (node->symbol.lto_file_data, name) != name)\n+  if (node->lto_file_data\n+      && lto_get_decl_name_mapping (node->lto_file_data, name) != name)\n     {\n       if (cgraph_dump_file)\n \tfprintf (cgraph_dump_file,\n@@ -783,7 +783,7 @@ privatize_symbol_name (symtab_node node)\n      ???  should have a flag whether a symbol has a 'private' name already,\n      since we produce some symbols like that i.e. for global constructors\n      that are not really clones.  */\n-  if (node->symbol.unique_name)\n+  if (node->unique_name)\n     {\n       if (cgraph_dump_file)\n \tfprintf (cgraph_dump_file,\n@@ -792,8 +792,8 @@ privatize_symbol_name (symtab_node node)\n       return false;\n     }\n   change_decl_assembler_name (decl, clone_function_name (decl, \"lto_priv\"));\n-  if (node->symbol.lto_file_data)\n-    lto_record_renamed_decl (node->symbol.lto_file_data, name,\n+  if (node->lto_file_data)\n+    lto_record_renamed_decl (node->lto_file_data, name,\n \t\t\t     IDENTIFIER_POINTER\n \t\t\t     (DECL_ASSEMBLER_NAME (decl)));\n   if (cgraph_dump_file)\n@@ -809,19 +809,19 @@ static void\n promote_symbol (symtab_node node)\n {\n   /* We already promoted ... */\n-  if (DECL_VISIBILITY (node->symbol.decl) == VISIBILITY_HIDDEN\n-      && DECL_VISIBILITY_SPECIFIED (node->symbol.decl)\n-      && TREE_PUBLIC (node->symbol.decl))\n+  if (DECL_VISIBILITY (node->decl) == VISIBILITY_HIDDEN\n+      && DECL_VISIBILITY_SPECIFIED (node->decl)\n+      && TREE_PUBLIC (node->decl))\n     return;\n \n-  gcc_checking_assert (!TREE_PUBLIC (node->symbol.decl)\n-\t\t       && !DECL_EXTERNAL (node->symbol.decl));\n+  gcc_checking_assert (!TREE_PUBLIC (node->decl)\n+\t\t       && !DECL_EXTERNAL (node->decl));\n   /* Be sure that newly public symbol does not conflict with anything already\n      defined by the non-LTO part.  */\n   privatize_symbol_name (node);\n-  TREE_PUBLIC (node->symbol.decl) = 1;\n-  DECL_VISIBILITY (node->symbol.decl) = VISIBILITY_HIDDEN;\n-  DECL_VISIBILITY_SPECIFIED (node->symbol.decl) = true;\n+  TREE_PUBLIC (node->decl) = 1;\n+  DECL_VISIBILITY (node->decl) = VISIBILITY_HIDDEN;\n+  DECL_VISIBILITY_SPECIFIED (node->decl) = true;\n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file,\n \t    \"Promoting as hidden: %s\\n\", symtab_node_name (node));\n@@ -854,16 +854,16 @@ may_need_named_section_p (lto_symtab_encoder_t encoder, symtab_node node)\n static void\n rename_statics (lto_symtab_encoder_t encoder, symtab_node node)\n {\n-  tree decl = node->symbol.decl;\n+  tree decl = node->decl;\n   symtab_node s;\n   tree name = DECL_ASSEMBLER_NAME (decl);\n \n   /* See if this is static symbol. */\n-  if ((node->symbol.externally_visible\n+  if ((node->externally_visible\n       /* FIXME: externally_visible is somewhat illogically not set for\n \t external symbols (i.e. those not defined).  Remove this test\n \t once this is fixed.  */\n-        || DECL_EXTERNAL (node->symbol.decl)\n+        || DECL_EXTERNAL (node->decl)\n         || !symtab_real_symbol_p (node))\n        && !may_need_named_section_p (encoder, node))\n     return;\n@@ -872,9 +872,9 @@ rename_statics (lto_symtab_encoder_t encoder, symtab_node node)\n      (all types of symbols counts here, since we can not have static of the\n      same name as external or public symbol.)  */\n   for (s = symtab_node_for_asm (name);\n-       s; s = s->symbol.next_sharing_asm_name)\n+       s; s = s->next_sharing_asm_name)\n     if ((symtab_real_symbol_p (s) || may_need_named_section_p (encoder, s))\n-\t&& s->symbol.decl != node->symbol.decl\n+\t&& s->decl != node->decl\n \t&& (!encoder\n \t    || lto_symtab_encoder_lookup (encoder, s) != LCC_NOT_FOUND))\n        break;\n@@ -890,20 +890,20 @@ rename_statics (lto_symtab_encoder_t encoder, symtab_node node)\n   /* Assign every symbol in the set that shares the same ASM name an unique\n      mangled name.  */\n   for (s = symtab_node_for_asm (name); s;)\n-    if (!s->symbol.externally_visible\n+    if (!s->externally_visible\n \t&& ((symtab_real_symbol_p (s)\n-             && !DECL_EXTERNAL (node->symbol.decl)\n-\t     && !TREE_PUBLIC (node->symbol.decl))\n+             && !DECL_EXTERNAL (node->decl)\n+\t     && !TREE_PUBLIC (node->decl))\n  \t    || may_need_named_section_p (encoder, s))\n \t&& (!encoder\n \t    || lto_symtab_encoder_lookup (encoder, s) != LCC_NOT_FOUND))\n       {\n         if (privatize_symbol_name (s))\n \t  /* Re-start from beginning since we do not know how many symbols changed a name.  */\n \t  s = symtab_node_for_asm (name);\n-        else s = s->symbol.next_sharing_asm_name;\n+        else s = s->next_sharing_asm_name;\n       }\n-    else s = s->symbol.next_sharing_asm_name;\n+    else s = s->next_sharing_asm_name;\n }\n \n /* Find out all static decls that need to be promoted to global because\n@@ -942,12 +942,12 @@ lto_promote_cross_file_statics (void)\n \t  rename_statics (encoder, node);\n \n \t  /* No need to promote if symbol already is externally visible ... */\n-\t  if (node->symbol.externally_visible\n+\t  if (node->externally_visible\n  \t      /* ... or if it is part of current partition ... */\n \t      || lto_symtab_encoder_in_partition_p (encoder, node)\n \t      /* ... or if we do not partition it. This mean that it will\n \t\t appear in every partition refernecing it.  */\n-\t      || get_symbol_class ((symtab_node) node) != SYMBOL_PARTITION)\n+\t      || get_symbol_class (node) != SYMBOL_PARTITION)\n \t    continue;\n \n           promote_symbol (node);"}, {"sha": "13646bb6b722b46c39b18b6d4ca1a701183aa5dd", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 103, "deletions": 103, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -44,26 +44,26 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n     {\n       fprintf (cgraph_dump_file, \"Replacing cgraph node %s/%i by %s/%i\"\n  \t       \" for symbol %s\\n\",\n-\t       cgraph_node_name (node), node->symbol.order,\n+\t       cgraph_node_name (node), node->order,\n \t       cgraph_node_name (prevailing_node),\n-\t       prevailing_node->symbol.order,\n+\t       prevailing_node->order,\n \t       IDENTIFIER_POINTER ((*targetm.asm_out.mangle_assembler_name)\n-\t\t (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->symbol.decl)))));\n+\t\t (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->decl)))));\n     }\n \n   /* Merge node flags.  */\n-  if (node->symbol.force_output)\n+  if (node->force_output)\n     cgraph_mark_force_output_node (prevailing_node);\n-  if (node->symbol.address_taken)\n+  if (node->address_taken)\n     {\n       gcc_assert (!prevailing_node->global.inlined_to);\n       cgraph_mark_address_taken_node (prevailing_node);\n     }\n \n   /* Redirect all incoming edges.  */\n   compatible_p\n-    = types_compatible_p (TREE_TYPE (TREE_TYPE (prevailing_node->symbol.decl)),\n-\t\t\t  TREE_TYPE (TREE_TYPE (node->symbol.decl)));\n+    = types_compatible_p (TREE_TYPE (TREE_TYPE (prevailing_node->decl)),\n+\t\t\t  TREE_TYPE (TREE_TYPE (node->decl)));\n   for (e = node->callers; e; e = next)\n     {\n       next = e->next_caller;\n@@ -76,12 +76,12 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n \te->call_stmt_cannot_inline_p = 1;\n     }\n   /* Redirect incomming references.  */\n-  ipa_clone_referring ((symtab_node)prevailing_node, &node->symbol.ref_list);\n+  ipa_clone_referring (prevailing_node, &node->ref_list);\n \n   ipa_merge_profiles (prevailing_node, node);\n-  lto_free_function_in_decl_state_for_node ((symtab_node)node);\n+  lto_free_function_in_decl_state_for_node (node);\n \n-  if (node->symbol.decl != prevailing_node->symbol.decl)\n+  if (node->decl != prevailing_node->decl)\n     cgraph_release_function_body (node);\n \n   /* Finally remove the replaced node.  */\n@@ -95,15 +95,15 @@ static void\n lto_varpool_replace_node (struct varpool_node *vnode,\n \t\t\t  struct varpool_node *prevailing_node)\n {\n-  gcc_assert (!vnode->symbol.definition || prevailing_node->symbol.definition);\n-  gcc_assert (!vnode->symbol.analyzed || prevailing_node->symbol.analyzed);\n+  gcc_assert (!vnode->definition || prevailing_node->definition);\n+  gcc_assert (!vnode->analyzed || prevailing_node->analyzed);\n \n-  ipa_clone_referring ((symtab_node)prevailing_node, &vnode->symbol.ref_list);\n+  ipa_clone_referring (prevailing_node, &vnode->ref_list);\n \n   /* Be sure we can garbage collect the initializer.  */\n-  if (DECL_INITIAL (vnode->symbol.decl)\n-      && vnode->symbol.decl != prevailing_node->symbol.decl)\n-    DECL_INITIAL (vnode->symbol.decl) = error_mark_node;\n+  if (DECL_INITIAL (vnode->decl)\n+      && vnode->decl != prevailing_node->decl)\n+    DECL_INITIAL (vnode->decl) = error_mark_node;\n   /* Finally remove the replaced node.  */\n   varpool_remove_node (vnode);\n }\n@@ -115,8 +115,8 @@ lto_varpool_replace_node (struct varpool_node *vnode,\n static bool\n lto_symtab_merge (symtab_node prevailing, symtab_node entry)\n {\n-  tree prevailing_decl = prevailing->symbol.decl;\n-  tree decl = entry->symbol.decl;\n+  tree prevailing_decl = prevailing->decl;\n+  tree decl = entry->decl;\n   tree prevailing_type, type;\n \n   if (prevailing_decl == decl)\n@@ -218,15 +218,15 @@ lto_symtab_merge (symtab_node prevailing, symtab_node entry)\n static bool\n lto_symtab_resolve_replaceable_p (symtab_node e)\n {\n-  if (DECL_EXTERNAL (e->symbol.decl)\n-      || DECL_COMDAT (e->symbol.decl)\n-      || DECL_ONE_ONLY (e->symbol.decl)\n-      || DECL_WEAK (e->symbol.decl))\n+  if (DECL_EXTERNAL (e->decl)\n+      || DECL_COMDAT (e->decl)\n+      || DECL_ONE_ONLY (e->decl)\n+      || DECL_WEAK (e->decl))\n     return true;\n \n-  if (TREE_CODE (e->symbol.decl) == VAR_DECL)\n-    return (DECL_COMMON (e->symbol.decl)\n-\t    || (!flag_no_common && !DECL_INITIAL (e->symbol.decl)));\n+  if (TREE_CODE (e->decl) == VAR_DECL)\n+    return (DECL_COMMON (e->decl)\n+\t    || (!flag_no_common && !DECL_INITIAL (e->decl)));\n \n   return false;\n }\n@@ -238,7 +238,7 @@ lto_symtab_resolve_replaceable_p (symtab_node e)\n static bool\n lto_symtab_symbol_p (symtab_node e)\n {\n-  if (!TREE_PUBLIC (e->symbol.decl) && !DECL_EXTERNAL (e->symbol.decl))\n+  if (!TREE_PUBLIC (e->decl) && !DECL_EXTERNAL (e->decl))\n     return false;\n   return symtab_real_symbol_p (e);\n }\n@@ -254,10 +254,10 @@ lto_symtab_resolve_can_prevail_p (symtab_node e)\n   /* The C++ frontend ends up neither setting TREE_STATIC nor\n      DECL_EXTERNAL on virtual methods but only TREE_PUBLIC.\n      So do not reject !TREE_STATIC here but only DECL_EXTERNAL.  */\n-  if (DECL_EXTERNAL (e->symbol.decl))\n+  if (DECL_EXTERNAL (e->decl))\n     return false;\n \n-  return e->symbol.definition;\n+  return e->definition;\n }\n \n /* Resolve the symbol with the candidates in the chain *SLOT and store\n@@ -270,11 +270,11 @@ lto_symtab_resolve_symbols (symtab_node first)\n   symtab_node prevailing = NULL;\n \n   /* Always set e->node so that edges are updated to reflect decl merging. */\n-  for (e = first; e; e = e->symbol.next_sharing_asm_name)\n+  for (e = first; e; e = e->next_sharing_asm_name)\n     if (lto_symtab_symbol_p (e)\n-\t&& (e->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t    || e->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY_EXP\n-\t    || e->symbol.resolution == LDPR_PREVAILING_DEF))\n+\t&& (e->resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t    || e->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP\n+\t    || e->resolution == LDPR_PREVAILING_DEF))\n       {\n \tprevailing = e;\n \tbreak;\n@@ -284,19 +284,19 @@ lto_symtab_resolve_symbols (symtab_node first)\n   if (prevailing)\n     {\n       /* Assert it's the only one.  */\n-      for (e = prevailing->symbol.next_sharing_asm_name; e; e = e->symbol.next_sharing_asm_name)\n+      for (e = prevailing->next_sharing_asm_name; e; e = e->next_sharing_asm_name)\n \tif (lto_symtab_symbol_p (e)\n-\t    && (e->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t|| e->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY_EXP\n-\t\t|| e->symbol.resolution == LDPR_PREVAILING_DEF))\n+\t    && (e->resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t\t|| e->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP\n+\t\t|| e->resolution == LDPR_PREVAILING_DEF))\n \t  fatal_error (\"multiple prevailing defs for %qE\",\n-\t\t       DECL_NAME (prevailing->symbol.decl));\n+\t\t       DECL_NAME (prevailing->decl));\n       return prevailing;\n     }\n \n   /* Find the single non-replaceable prevailing symbol and\n      diagnose ODR violations.  */\n-  for (e = first; e; e = e->symbol.next_sharing_asm_name)\n+  for (e = first; e; e = e->next_sharing_asm_name)\n     {\n       if (!lto_symtab_resolve_can_prevail_p (e))\n \tcontinue;\n@@ -306,9 +306,9 @@ lto_symtab_resolve_symbols (symtab_node first)\n \t{\n \t  if (prevailing)\n \t    {\n-\t      error_at (DECL_SOURCE_LOCATION (e->symbol.decl),\n-\t\t\t\"%qD has already been defined\", e->symbol.decl);\n-\t      inform (DECL_SOURCE_LOCATION (prevailing->symbol.decl),\n+\t      error_at (DECL_SOURCE_LOCATION (e->decl),\n+\t\t\t\"%qD has already been defined\", e->decl);\n+\t      inform (DECL_SOURCE_LOCATION (prevailing->decl),\n \t\t      \"previously defined here\");\n \t    }\n \t  prevailing = e;\n@@ -318,22 +318,22 @@ lto_symtab_resolve_symbols (symtab_node first)\n     return prevailing;\n \n   /* Do a second round choosing one from the replaceable prevailing decls.  */\n-  for (e = first; e; e = e->symbol.next_sharing_asm_name)\n+  for (e = first; e; e = e->next_sharing_asm_name)\n     {\n       if (!lto_symtab_resolve_can_prevail_p (e))\n \tcontinue;\n \n       /* Choose the first function that can prevail as prevailing.  */\n-      if (TREE_CODE (e->symbol.decl) == FUNCTION_DECL)\n+      if (TREE_CODE (e->decl) == FUNCTION_DECL)\n \t{\n \t  prevailing = e;\n \t  break;\n \t}\n \n       /* From variables that can prevail choose the largest one.  */\n       if (!prevailing\n-\t  || tree_int_cst_lt (DECL_SIZE (prevailing->symbol.decl),\n-\t\t\t      DECL_SIZE (e->symbol.decl))\n+\t  || tree_int_cst_lt (DECL_SIZE (prevailing->decl),\n+\t\t\t      DECL_SIZE (e->decl))\n \t  /* When variables are equivalent try to chose one that has useful\n \t     DECL_INITIAL.  This makes sense for keyed vtables that are\n \t     DECL_EXTERNAL but initialized.  In units that do not need them\n@@ -343,11 +343,11 @@ lto_symtab_resolve_symbols (symtab_node first)\n \t     We know that the vtable is keyed outside the LTO unit - otherwise\n \t     the keyed instance would prevail.  We still can preserve useful\n \t     info in the initializer.  */\n-\t  || (DECL_SIZE (prevailing->symbol.decl) == DECL_SIZE (e->symbol.decl)\n-\t      && (DECL_INITIAL (e->symbol.decl)\n-\t\t  && DECL_INITIAL (e->symbol.decl) != error_mark_node)\n-\t      && (!DECL_INITIAL (prevailing->symbol.decl)\n-\t\t  || DECL_INITIAL (prevailing->symbol.decl) == error_mark_node)))\n+\t  || (DECL_SIZE (prevailing->decl) == DECL_SIZE (e->decl)\n+\t      && (DECL_INITIAL (e->decl)\n+\t\t  && DECL_INITIAL (e->decl) != error_mark_node)\n+\t      && (!DECL_INITIAL (prevailing->decl)\n+\t\t  || DECL_INITIAL (prevailing->decl) == error_mark_node)))\n \tprevailing = e;\n     }\n \n@@ -368,41 +368,41 @@ lto_symtab_merge_decls_2 (symtab_node first, bool diagnosed_p)\n \n   /* Nothing to do for a single entry.  */\n   prevailing = first;\n-  if (!prevailing->symbol.next_sharing_asm_name)\n+  if (!prevailing->next_sharing_asm_name)\n     return;\n \n   /* Try to merge each entry with the prevailing one.  */\n-  for (e = prevailing->symbol.next_sharing_asm_name;\n-       e; e = e->symbol.next_sharing_asm_name)\n-    if (TREE_PUBLIC (e->symbol.decl))\n+  for (e = prevailing->next_sharing_asm_name;\n+       e; e = e->next_sharing_asm_name)\n+    if (TREE_PUBLIC (e->decl))\n       {\n \tif (!lto_symtab_merge (prevailing, e)\n \t    && !diagnosed_p)\n-\t  mismatches.safe_push (e->symbol.decl);\n+\t  mismatches.safe_push (e->decl);\n       }\n   if (mismatches.is_empty ())\n     return;\n \n   /* Diagnose all mismatched re-declarations.  */\n   FOR_EACH_VEC_ELT (mismatches, i, decl)\n     {\n-      if (!types_compatible_p (TREE_TYPE (prevailing->symbol.decl),\n+      if (!types_compatible_p (TREE_TYPE (prevailing->decl),\n \t\t\t       TREE_TYPE (decl)))\n \tdiagnosed_p |= warning_at (DECL_SOURCE_LOCATION (decl), 0,\n \t\t\t\t   \"type of %qD does not match original \"\n \t\t\t\t   \"declaration\", decl);\n \n-      else if ((DECL_USER_ALIGN (prevailing->symbol.decl)\n+      else if ((DECL_USER_ALIGN (prevailing->decl)\n \t        && DECL_USER_ALIGN (decl))\n-\t       && DECL_ALIGN (prevailing->symbol.decl) < DECL_ALIGN (decl))\n+\t       && DECL_ALIGN (prevailing->decl) < DECL_ALIGN (decl))\n \t{\n \t  diagnosed_p |= warning_at (DECL_SOURCE_LOCATION (decl), 0,\n \t\t\t\t     \"alignment of %qD is bigger than \"\n \t\t\t\t     \"original declaration\", decl);\n \t}\n     }\n   if (diagnosed_p)\n-    inform (DECL_SOURCE_LOCATION (prevailing->symbol.decl),\n+    inform (DECL_SOURCE_LOCATION (prevailing->decl),\n \t    \"previously declared here\");\n \n   mismatches.release ();\n@@ -420,8 +420,8 @@ lto_symtab_merge_decls_1 (symtab_node first)\n     {\n       fprintf (cgraph_dump_file, \"Merging nodes for %s. Candidates:\\n\",\n \t       symtab_node_asm_name (first));\n-      for (e = first; e; e = e->symbol.next_sharing_asm_name)\n-\tif (TREE_PUBLIC (e->symbol.decl))\n+      for (e = first; e; e = e->next_sharing_asm_name)\n+\tif (TREE_PUBLIC (e->decl))\n \t  dump_symtab_node (cgraph_dump_file, e);\n     }\n \n@@ -442,21 +442,21 @@ lto_symtab_merge_decls_1 (symtab_node first)\n \t This is needed for C++ typeinfos, for example in\n \t lto/20081204-1 there are typeifos in both units, just\n \t one of them do have size.  */\n-      if (TREE_CODE (prevailing->symbol.decl) == VAR_DECL)\n+      if (TREE_CODE (prevailing->decl) == VAR_DECL)\n \t{\n-\t  for (e = prevailing->symbol.next_sharing_asm_name;\n-\t       e; e = e->symbol.next_sharing_asm_name)\n-\t    if (!COMPLETE_TYPE_P (TREE_TYPE (prevailing->symbol.decl))\n-\t\t&& COMPLETE_TYPE_P (TREE_TYPE (e->symbol.decl))\n+\t  for (e = prevailing->next_sharing_asm_name;\n+\t       e; e = e->next_sharing_asm_name)\n+\t    if (!COMPLETE_TYPE_P (TREE_TYPE (prevailing->decl))\n+\t\t&& COMPLETE_TYPE_P (TREE_TYPE (e->decl))\n \t\t&& lto_symtab_symbol_p (e))\n \t      prevailing = e;\n \t}\n       /* For variables prefer the non-builtin if one is available.  */\n-      else if (TREE_CODE (prevailing->symbol.decl) == FUNCTION_DECL)\n+      else if (TREE_CODE (prevailing->decl) == FUNCTION_DECL)\n \t{\n-\t  for (e = first; e; e = e->symbol.next_sharing_asm_name)\n-\t    if (TREE_CODE (e->symbol.decl) == FUNCTION_DECL\n-\t\t&& !DECL_BUILT_IN (e->symbol.decl)\n+\t  for (e = first; e; e = e->next_sharing_asm_name)\n+\t    if (TREE_CODE (e->decl) == FUNCTION_DECL\n+\t\t&& !DECL_BUILT_IN (e->decl)\n \t\t&& lto_symtab_symbol_p (e))\n \t      {\n \t\tprevailing = e;\n@@ -468,29 +468,29 @@ lto_symtab_merge_decls_1 (symtab_node first)\n   symtab_prevail_in_asm_name_hash (prevailing);\n \n   /* Diagnose mismatched objects.  */\n-  for (e = prevailing->symbol.next_sharing_asm_name;\n-       e; e = e->symbol.next_sharing_asm_name)\n+  for (e = prevailing->next_sharing_asm_name;\n+       e; e = e->next_sharing_asm_name)\n     {\n-      if (TREE_CODE (prevailing->symbol.decl)\n-\t  == TREE_CODE (e->symbol.decl))\n+      if (TREE_CODE (prevailing->decl)\n+\t  == TREE_CODE (e->decl))\n \tcontinue;\n       if (!lto_symtab_symbol_p (e))\n \tcontinue;\n \n-      switch (TREE_CODE (prevailing->symbol.decl))\n+      switch (TREE_CODE (prevailing->decl))\n \t{\n \tcase VAR_DECL:\n-\t  gcc_assert (TREE_CODE (e->symbol.decl) == FUNCTION_DECL);\n-\t  error_at (DECL_SOURCE_LOCATION (e->symbol.decl),\n+\t  gcc_assert (TREE_CODE (e->decl) == FUNCTION_DECL);\n+\t  error_at (DECL_SOURCE_LOCATION (e->decl),\n \t\t    \"variable %qD redeclared as function\",\n-\t\t    prevailing->symbol.decl);\n+\t\t    prevailing->decl);\n \t  break;\n \n \tcase FUNCTION_DECL:\n-\t  gcc_assert (TREE_CODE (e->symbol.decl) == VAR_DECL);\n-\t  error_at (DECL_SOURCE_LOCATION (e->symbol.decl),\n+\t  gcc_assert (TREE_CODE (e->decl) == VAR_DECL);\n+\t  error_at (DECL_SOURCE_LOCATION (e->decl),\n \t\t    \"function %qD redeclared as variable\",\n-\t\t    prevailing->symbol.decl);\n+\t\t    prevailing->decl);\n \t  break;\n \n \tdefault:\n@@ -500,7 +500,7 @@ lto_symtab_merge_decls_1 (symtab_node first)\n       diagnosed_p = true;\n     }\n   if (diagnosed_p)\n-      inform (DECL_SOURCE_LOCATION (prevailing->symbol.decl),\n+      inform (DECL_SOURCE_LOCATION (prevailing->decl),\n \t      \"previously declared here\");\n \n   /* Merge the chain to the single prevailing decl and diagnose\n@@ -510,7 +510,7 @@ lto_symtab_merge_decls_1 (symtab_node first)\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"After resolution:\\n\");\n-      for (e = prevailing; e; e = e->symbol.next_sharing_asm_name)\n+      for (e = prevailing; e; e = e->next_sharing_asm_name)\n \tdump_symtab_node (cgraph_dump_file, e);\n     }\n }\n@@ -526,8 +526,8 @@ lto_symtab_merge_decls (void)\n   symtab_initialize_asm_name_hash ();\n \n   FOR_EACH_SYMBOL (node)\n-    if (!node->symbol.previous_sharing_asm_name\n-\t&& node->symbol.next_sharing_asm_name)\n+    if (!node->previous_sharing_asm_name\n+\t&& node->next_sharing_asm_name)\n       lto_symtab_merge_decls_1 (node);\n }\n \n@@ -539,15 +539,15 @@ lto_symtab_merge_symbols_1 (symtab_node prevailing)\n   symtab_node e, next;\n \n   /* Replace the cgraph node of each entry with the prevailing one.  */\n-  for (e = prevailing->symbol.next_sharing_asm_name; e;\n+  for (e = prevailing->next_sharing_asm_name; e;\n        e = next)\n     {\n-      next = e->symbol.next_sharing_asm_name;\n+      next = e->next_sharing_asm_name;\n \n       if (!lto_symtab_symbol_p (e))\n \tcontinue;\n       cgraph_node *ce = dyn_cast <cgraph_node> (e);\n-      if (ce && !DECL_BUILT_IN (e->symbol.decl))\n+      if (ce && !DECL_BUILT_IN (e->decl))\n \tlto_cgraph_replace_node (ce, cgraph (prevailing));\n       if (varpool_node *ve = dyn_cast <varpool_node> (e))\n \tlto_varpool_replace_node (ve, varpool (prevailing));\n@@ -574,8 +574,8 @@ lto_symtab_merge_symbols (void)\n \t updated to the ohter dupliate.  */\n       FOR_EACH_SYMBOL (node)\n \tif (lto_symtab_symbol_p (node)\n-\t    && node->symbol.next_sharing_asm_name\n-\t    && !node->symbol.previous_sharing_asm_name)\n+\t    && node->next_sharing_asm_name\n+\t    && !node->previous_sharing_asm_name)\n \t  lto_symtab_merge_symbols_1 (node);\n \n       /* Resolve weakref aliases whose target are now in the compilation unit.  \n@@ -586,46 +586,46 @@ lto_symtab_merge_symbols (void)\n \t  varpool_node *vnode;\n \t  symtab_node node2;\n \n-\t  if (!node->symbol.analyzed && node->symbol.alias_target)\n+\t  if (!node->analyzed && node->alias_target)\n \t    {\n-\t      symtab_node tgt = symtab_node_for_asm (node->symbol.alias_target);\n-\t      gcc_assert (node->symbol.weakref);\n+\t      symtab_node tgt = symtab_node_for_asm (node->alias_target);\n+\t      gcc_assert (node->weakref);\n \t      if (tgt)\n \t\tsymtab_resolve_alias (node, tgt);\n \t    }\n-\t  node->symbol.aux = NULL;\n+\t  node->aux = NULL;\n \n \t  if (!(cnode = dyn_cast <cgraph_node> (node))\n \t      || !cnode->clone_of\n-\t      || cnode->clone_of->symbol.decl != cnode->symbol.decl)\n+\t      || cnode->clone_of->decl != cnode->decl)\n \t    {\n \t      /* Builtins are not merged via decl merging.  It is however\n \t\t possible that tree merging unified the declaration.  We\n \t\t do not want duplicate entries in symbol table.  */\n-\t      if (cnode && DECL_BUILT_IN (node->symbol.decl)\n-\t\t  && (cnode2 = cgraph_get_node (node->symbol.decl))\n+\t      if (cnode && DECL_BUILT_IN (node->decl)\n+\t\t  && (cnode2 = cgraph_get_node (node->decl))\n \t\t  && cnode2 != cnode)\n \t\tlto_cgraph_replace_node (cnode2, cnode);\n \n \t      /* The user defined assembler variables are also not unified by their\n \t\t symbol name (since it is irrelevant), but we need to unify symbol\n \t\t nodes if tree merging occured.  */\n \t      if ((vnode = dyn_cast <varpool_node> (node))\n-\t\t  && DECL_HARD_REGISTER (vnode->symbol.decl)\n-\t\t  && (node2 = symtab_get_node (vnode->symbol.decl))\n+\t\t  && DECL_HARD_REGISTER (vnode->decl)\n+\t\t  && (node2 = symtab_get_node (vnode->decl))\n \t\t  && node2 != node)\n \t\tlto_varpool_replace_node (dyn_cast <varpool_node> (node2),\n \t\t\t\t\t  vnode);\n \t  \n \n \t      /* Abstract functions may have duplicated cgraph nodes attached;\n \t\t remove them.  */\n-\t      else if (cnode && DECL_ABSTRACT (cnode->symbol.decl)\n-\t\t       && (cnode2 = cgraph_get_node (node->symbol.decl))\n+\t      else if (cnode && DECL_ABSTRACT (cnode->decl)\n+\t\t       && (cnode2 = cgraph_get_node (node->decl))\n \t\t       && cnode2 != cnode)\n \t\tcgraph_remove_node (cnode2);\n \n-\t      symtab_insert_node_to_hashtable ((symtab_node)node);\n+\t      symtab_insert_node_to_hashtable (node);\n \t    }\n \t}\n     }\n@@ -659,5 +659,5 @@ lto_symtab_prevailing_decl (tree decl)\n   if (!ret)\n     return decl;\n \n-  return ret->symbol.decl;\n+  return ret->decl;\n }"}, {"sha": "89de69dea6fd126bb059368757e4805aa839303d", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -171,7 +171,7 @@ has_analyzed_clone_p (struct cgraph_node *node)\n   if (node)\n     while (node != orig)\n       {\n-\tif (node->symbol.analyzed)\n+\tif (node->analyzed)\n \t  return true;\n \tif (node->clones)\n \t  node = node->clones;\n@@ -195,10 +195,10 @@ lto_materialize_function (struct cgraph_node *node)\n {\n   tree decl;\n \n-  decl = node->symbol.decl;\n+  decl = node->decl;\n   /* Read in functions with body (analyzed nodes)\n      and also functions that are needed to produce virtual clones.  */\n-  if ((cgraph_function_with_gimple_body_p (node) && node->symbol.analyzed)\n+  if ((cgraph_function_with_gimple_body_p (node) && node->analyzed)\n       || node->used_as_abstract_origin\n       || has_analyzed_clone_p (node))\n     {\n@@ -2398,9 +2398,9 @@ cmp_partitions_order (const void *a, const void *b)\n   int ordera = -1, orderb = -1;\n \n   if (lto_symtab_encoder_size (pa->encoder))\n-    ordera = lto_symtab_encoder_deref (pa->encoder, 0)->symbol.order;\n+    ordera = lto_symtab_encoder_deref (pa->encoder, 0)->order;\n   if (lto_symtab_encoder_size (pb->encoder))\n-    orderb = lto_symtab_encoder_deref (pb->encoder, 0)->symbol.order;\n+    orderb = lto_symtab_encoder_deref (pb->encoder, 0)->order;\n   return orderb - ordera;\n }\n \n@@ -2873,11 +2873,11 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n \n   FOR_EACH_SYMBOL (snode)\n     if (symtab_real_symbol_p (snode)\n-\t&& snode->symbol.lto_file_data\n-\t&& snode->symbol.lto_file_data->resolution_map\n-\t&& (res = pointer_map_contains (snode->symbol.lto_file_data->resolution_map,\n-\t\t\t\t\tsnode->symbol.decl)))\n-      snode->symbol.resolution\n+\t&& snode->lto_file_data\n+\t&& snode->lto_file_data->resolution_map\n+\t&& (res = pointer_map_contains (snode->lto_file_data->resolution_map,\n+\t\t\t\t\tsnode->decl)))\n+      snode->resolution\n \t= (enum ld_plugin_symbol_resolution)(size_t)*res;\n   for (i = 0; all_file_decl_data[i]; i++)\n     if (all_file_decl_data[i]->resolution_map)\n@@ -2979,7 +2979,7 @@ materialize_cgraph (void)\n \n   FOR_EACH_FUNCTION (node)\n     {\n-      if (node->symbol.lto_file_data)\n+      if (node->lto_file_data)\n \t{\n \t  lto_materialize_function (node);\n \t  lto_stats.num_input_cgraph_nodes++;\n@@ -3126,7 +3126,7 @@ do_whole_program_analysis (void)\n   /* AUX pointers are used by partitioning code to bookkeep number of\n      partitions symbol is in.  This is no longer needed.  */\n   FOR_EACH_SYMBOL (node)\n-    node->symbol.aux = NULL;\n+    node->aux = NULL;\n \n   lto_stats.num_cgraph_partitions += ltrans_partitions.length ();\n   timevar_pop (TV_WHOPR_PARTITIONING);\n@@ -3288,7 +3288,7 @@ lto_main (void)\n \n \t  /* Record the global variables.  */\n \t  FOR_EACH_DEFINED_VARIABLE (vnode)\n-\t    vec_safe_push (lto_global_var_decls, vnode->symbol.decl);\n+\t    vec_safe_push (lto_global_var_decls, vnode->decl);\n \t}\n     }\n "}, {"sha": "19e5869c14bc43a7e0bd2c73ab64961c750647df", "filename": "gcc/passes.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -893,7 +893,7 @@ pass_manager::dump_passes () const\n   create_pass_tab ();\n \n   FOR_EACH_FUNCTION (n)\n-    if (DECL_STRUCT_FUNCTION (n->symbol.decl))\n+    if (DECL_STRUCT_FUNCTION (n->decl))\n       {\n \tnode = n;\n \tbreak;\n@@ -902,7 +902,7 @@ pass_manager::dump_passes () const\n   if (!node)\n     return;\n \n-  push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \n   dump_pass_list (all_lowering_passes, 1);\n   dump_pass_list (all_small_ipa_passes, 1);\n@@ -1577,10 +1577,10 @@ do_per_function (void (*callback) (void *data), void *data)\n     {\n       struct cgraph_node *node;\n       FOR_EACH_DEFINED_FUNCTION (node)\n-\tif (node->symbol.analyzed && gimple_has_body_p (node->symbol.decl)\n-\t    && (!node->clone_of || node->symbol.decl != node->clone_of->symbol.decl))\n+\tif (node->analyzed && gimple_has_body_p (node->decl)\n+\t    && (!node->clone_of || node->decl != node->clone_of->decl))\n \t  {\n-\t    push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+\t    push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \t    callback (data);\n \t    if (!flag_wpa)\n \t      {\n@@ -1627,7 +1627,7 @@ do_per_function_toporder (void (*callback) (void *data), void *data)\n \t  if (cgraph_function_with_gimple_body_p (node))\n \t    {\n \t      cgraph_get_body (node);\n-\t      push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+\t      push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \t      callback (data);\n \t      free_dominance_info (CDI_DOMINATORS);\n \t      free_dominance_info (CDI_POST_DOMINATORS);\n@@ -2368,19 +2368,19 @@ ipa_write_summaries (void)\n \t     ordering then matches the one IPA-passes get in their stmt_fixup\n \t     hooks.  */\n \n-\t  push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+\t  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \t  renumber_gimple_stmt_uids ();\n \t  pop_cfun ();\n \t}\n-      if (node->symbol.definition)\n-        lto_set_symtab_encoder_in_partition (encoder, (symtab_node)node);\n+      if (node->definition)\n+        lto_set_symtab_encoder_in_partition (encoder, node);\n     }\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (node->symbol.alias)\n-      lto_set_symtab_encoder_in_partition (encoder, (symtab_node)node);\n+    if (node->alias)\n+      lto_set_symtab_encoder_in_partition (encoder, node);\n   FOR_EACH_DEFINED_VARIABLE (vnode)\n-    lto_set_symtab_encoder_in_partition (encoder, (symtab_node)vnode);\n+    lto_set_symtab_encoder_in_partition (encoder, vnode);\n \n   ipa_write_summaries_1 (compute_ltrans_boundary (encoder));\n \n@@ -2446,10 +2446,10 @@ ipa_write_optimization_summaries (lto_symtab_encoder_t encoder)\n \n \t For functions newly born at WPA stage we need to initialize\n \t the uids here.  */\n-      if (node->symbol.definition\n-\t  && gimple_has_body_p (node->symbol.decl))\n+      if (node->definition\n+\t  && gimple_has_body_p (node->decl))\n \t{\n-\t  push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+\t  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \t  renumber_gimple_stmt_uids ();\n \t  pop_cfun ();\n \t}\n@@ -2691,11 +2691,11 @@ function_called_by_processed_nodes_p (void)\n        e;\n        e = e->next_caller)\n     {\n-      if (e->caller->symbol.decl == current_function_decl)\n+      if (e->caller->decl == current_function_decl)\n         continue;\n       if (!cgraph_function_with_gimple_body_p (e->caller))\n         continue;\n-      if (TREE_ASM_WRITTEN (e->caller->symbol.decl))\n+      if (TREE_ASM_WRITTEN (e->caller->decl))\n         continue;\n       if (!e->caller->process && !e->caller->global.inlined_to)\n       \tbreak;"}, {"sha": "eb57a99d6af3979e028da48d23ca7a1fcdea27bc", "filename": "gcc/symtab.c", "status": "modified", "additions": 193, "deletions": 193, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -67,7 +67,7 @@ static hashval_t\n hash_node (const void *p)\n {\n   const_symtab_node n = (const_symtab_node ) p;\n-  return (hashval_t) DECL_UID (n->symbol.decl);\n+  return (hashval_t) DECL_UID (n->decl);\n }\n \n \n@@ -78,7 +78,7 @@ eq_node (const void *p1, const void *p2)\n {\n   const_symtab_node n1 = (const_symtab_node) p1;\n   const_symtab_node n2 = (const_symtab_node) p2;\n-  return DECL_UID (n1->symbol.decl) == DECL_UID (n2->symbol.decl);\n+  return DECL_UID (n1->decl) == DECL_UID (n2->decl);\n }\n \n /* Returns a hash code for P.  */\n@@ -87,7 +87,7 @@ static hashval_t\n hash_node_by_assembler_name (const void *p)\n {\n   const_symtab_node n = (const_symtab_node) p;\n-  return (hashval_t) decl_assembler_name_hash (DECL_ASSEMBLER_NAME (n->symbol.decl));\n+  return (hashval_t) decl_assembler_name_hash (DECL_ASSEMBLER_NAME (n->decl));\n }\n \n /* Returns nonzero if P1 and P2 are equal.  */\n@@ -97,41 +97,41 @@ eq_assembler_name (const void *p1, const void *p2)\n {\n   const_symtab_node n1 = (const_symtab_node) p1;\n   const_tree name = (const_tree)p2;\n-  return (decl_assembler_name_equal (n1->symbol.decl, name));\n+  return (decl_assembler_name_equal (n1->decl, name));\n }\n \n /* Insert NODE to assembler name hash.  */\n \n static void\n insert_to_assembler_name_hash (symtab_node node, bool with_clones)\n {\n-  if (is_a <varpool_node> (node) && DECL_HARD_REGISTER (node->symbol.decl))\n+  if (is_a <varpool_node> (node) && DECL_HARD_REGISTER (node->decl))\n     return;\n-  gcc_checking_assert (!node->symbol.previous_sharing_asm_name\n-\t\t       && !node->symbol.next_sharing_asm_name);\n+  gcc_checking_assert (!node->previous_sharing_asm_name\n+\t\t       && !node->next_sharing_asm_name);\n   if (assembler_name_hash)\n     {\n       void **aslot;\n       struct cgraph_node *cnode;\n-      tree decl = node->symbol.decl;\n+      tree decl = node->decl;\n \n-      tree name = DECL_ASSEMBLER_NAME (node->symbol.decl);\n+      tree name = DECL_ASSEMBLER_NAME (node->decl);\n \n       aslot = htab_find_slot_with_hash (assembler_name_hash, name,\n \t\t\t\t\tdecl_assembler_name_hash (name),\n \t\t\t\t\tINSERT);\n       gcc_assert (*aslot != node);\n-      node->symbol.next_sharing_asm_name = (symtab_node)*aslot;\n+      node->next_sharing_asm_name = (symtab_node)*aslot;\n       if (*aslot != NULL)\n-\t((symtab_node)*aslot)->symbol.previous_sharing_asm_name = node;\n+\t((symtab_node)*aslot)->previous_sharing_asm_name = node;\n       *aslot = node;\n \n       /* Update also possible inline clones sharing a decl.  */\n       cnode = dyn_cast <cgraph_node> (node);\n       if (cnode && cnode->clones && with_clones)\n \tfor (cnode = cnode->clones; cnode; cnode = cnode->next_sibling_clone)\n-\t  if (cnode->symbol.decl == decl)\n-\t    insert_to_assembler_name_hash ((symtab_node) cnode, true);\n+\t  if (cnode->decl == decl)\n+\t    insert_to_assembler_name_hash (cnode, true);\n     }\n \n }\n@@ -144,38 +144,38 @@ unlink_from_assembler_name_hash (symtab_node node, bool with_clones)\n   if (assembler_name_hash)\n     {\n       struct cgraph_node *cnode;\n-      tree decl = node->symbol.decl;\n+      tree decl = node->decl;\n \n-      if (node->symbol.next_sharing_asm_name)\n-\tnode->symbol.next_sharing_asm_name->symbol.previous_sharing_asm_name\n-\t  = node->symbol.previous_sharing_asm_name;\n-      if (node->symbol.previous_sharing_asm_name)\n+      if (node->next_sharing_asm_name)\n+\tnode->next_sharing_asm_name->previous_sharing_asm_name\n+\t  = node->previous_sharing_asm_name;\n+      if (node->previous_sharing_asm_name)\n \t{\n-\t  node->symbol.previous_sharing_asm_name->symbol.next_sharing_asm_name\n-\t    = node->symbol.next_sharing_asm_name;\n+\t  node->previous_sharing_asm_name->next_sharing_asm_name\n+\t    = node->next_sharing_asm_name;\n \t}\n       else\n \t{\n-\t  tree name = DECL_ASSEMBLER_NAME (node->symbol.decl);\n+\t  tree name = DECL_ASSEMBLER_NAME (node->decl);\n           void **slot;\n \t  slot = htab_find_slot_with_hash (assembler_name_hash, name,\n \t\t\t\t\t   decl_assembler_name_hash (name),\n \t\t\t\t\t   NO_INSERT);\n \t  gcc_assert (*slot == node);\n-\t  if (!node->symbol.next_sharing_asm_name)\n+\t  if (!node->next_sharing_asm_name)\n \t    htab_clear_slot (assembler_name_hash, slot);\n \t  else\n-\t    *slot = node->symbol.next_sharing_asm_name;\n+\t    *slot = node->next_sharing_asm_name;\n \t}\n-      node->symbol.next_sharing_asm_name = NULL;\n-      node->symbol.previous_sharing_asm_name = NULL;\n+      node->next_sharing_asm_name = NULL;\n+      node->previous_sharing_asm_name = NULL;\n \n       /* Update also possible inline clones sharing a decl.  */\n       cnode = dyn_cast <cgraph_node> (node);\n       if (cnode && cnode->clones && with_clones)\n \tfor (cnode = cnode->clones; cnode; cnode = cnode->next_sibling_clone)\n-\t  if (cnode->symbol.decl == decl)\n-\t    unlink_from_assembler_name_hash ((symtab_node) cnode, true);\n+\t  if (cnode->decl == decl)\n+\t    unlink_from_assembler_name_hash (cnode, true);\n     }\n }\n \n@@ -198,22 +198,22 @@ symtab_register_node (symtab_node node)\n   struct symtab_node_base key;\n   symtab_node *slot;\n \n-  node->symbol.next = symtab_nodes;\n-  node->symbol.previous = NULL;\n+  node->next = symtab_nodes;\n+  node->previous = NULL;\n   if (symtab_nodes)\n-    symtab_nodes->symbol.previous = node;\n+    symtab_nodes->previous = node;\n   symtab_nodes = node;\n \n   if (!symtab_hash)\n     symtab_hash = htab_create_ggc (10, hash_node, eq_node, NULL);\n-  key.decl = node->symbol.decl;\n+  key.decl = node->decl;\n   slot = (symtab_node *) htab_find_slot (symtab_hash, &key, INSERT);\n   if (*slot == NULL)\n     *slot = node;\n \n-  ipa_empty_ref_list (&node->symbol.ref_list);\n+  ipa_empty_ref_list (&node->ref_list);\n \n-  node->symbol.order = symtab_order++;\n+  node->order = symtab_order++;\n \n   /* Be sure to do this last; C++ FE might create new nodes via\n      DECL_ASSEMBLER_NAME langhook!  */\n@@ -231,7 +231,7 @@ symtab_insert_node_to_hashtable (symtab_node node)\n \n   if (!symtab_hash)\n     symtab_hash = htab_create_ggc (10, hash_node, eq_node, NULL);\n-  key.decl = node->symbol.decl;\n+  key.decl = node->decl;\n   slot = (symtab_node *) htab_find_slot (symtab_hash, &key, INSERT);\n   *slot = node;\n }\n@@ -243,31 +243,31 @@ void\n symtab_unregister_node (symtab_node node)\n {\n   void **slot;\n-  ipa_remove_all_references (&node->symbol.ref_list);\n-  ipa_remove_all_referring (&node->symbol.ref_list);\n+  ipa_remove_all_references (&node->ref_list);\n+  ipa_remove_all_referring (&node->ref_list);\n \n-  if (node->symbol.same_comdat_group)\n+  if (node->same_comdat_group)\n     {\n       symtab_node prev;\n-      for (prev = node->symbol.same_comdat_group;\n-\t   prev->symbol.same_comdat_group != node;\n-\t   prev = prev->symbol.same_comdat_group)\n+      for (prev = node->same_comdat_group;\n+\t   prev->same_comdat_group != node;\n+\t   prev = prev->same_comdat_group)\n \t;\n-      if (node->symbol.same_comdat_group == prev)\n-\tprev->symbol.same_comdat_group = NULL;\n+      if (node->same_comdat_group == prev)\n+\tprev->same_comdat_group = NULL;\n       else\n-\tprev->symbol.same_comdat_group = node->symbol.same_comdat_group;\n-      node->symbol.same_comdat_group = NULL;\n+\tprev->same_comdat_group = node->same_comdat_group;\n+      node->same_comdat_group = NULL;\n     }\n \n-  if (node->symbol.previous)\n-    node->symbol.previous->symbol.next = node->symbol.next;\n+  if (node->previous)\n+    node->previous->next = node->next;\n   else\n-    symtab_nodes = node->symbol.next;\n-  if (node->symbol.next)\n-    node->symbol.next->symbol.previous = node->symbol.previous;\n-  node->symbol.next = NULL;\n-  node->symbol.previous = NULL;\n+    symtab_nodes = node->next;\n+  if (node->next)\n+    node->next->previous = node->previous;\n+  node->next = NULL;\n+  node->previous = NULL;\n \n   slot = htab_find_slot (symtab_hash, node, NO_INSERT);\n \n@@ -278,13 +278,13 @@ symtab_unregister_node (symtab_node node)\n     {\n       symtab_node replacement_node = NULL;\n       if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n-\treplacement_node = (symtab_node)cgraph_find_replacement_node (cnode);\n+\treplacement_node = cgraph_find_replacement_node (cnode);\n       if (!replacement_node)\n \thtab_clear_slot (symtab_hash, slot);\n       else\n \t*slot = replacement_node;\n     }\n-  if (!is_a <varpool_node> (node) || !DECL_HARD_REGISTER (node->symbol.decl))\n+  if (!is_a <varpool_node> (node) || !DECL_HARD_REGISTER (node->decl))\n     unlink_from_assembler_name_hash (node, false);\n }\n \n@@ -418,22 +418,22 @@ void\n symtab_add_to_same_comdat_group (symtab_node new_node,\n \t\t\t\t symtab_node old_node)\n {\n-  gcc_assert (DECL_ONE_ONLY (old_node->symbol.decl));\n-  gcc_assert (!new_node->symbol.same_comdat_group);\n+  gcc_assert (DECL_ONE_ONLY (old_node->decl));\n+  gcc_assert (!new_node->same_comdat_group);\n   gcc_assert (new_node != old_node);\n \n-  DECL_COMDAT_GROUP (new_node->symbol.decl) = DECL_COMDAT_GROUP (old_node->symbol.decl);\n-  new_node->symbol.same_comdat_group = old_node;\n-  if (!old_node->symbol.same_comdat_group)\n-    old_node->symbol.same_comdat_group = new_node;\n+  DECL_COMDAT_GROUP (new_node->decl) = DECL_COMDAT_GROUP (old_node->decl);\n+  new_node->same_comdat_group = old_node;\n+  if (!old_node->same_comdat_group)\n+    old_node->same_comdat_group = new_node;\n   else\n     {\n       symtab_node n;\n-      for (n = old_node->symbol.same_comdat_group;\n-\t   n->symbol.same_comdat_group != old_node;\n-\t   n = n->symbol.same_comdat_group)\n+      for (n = old_node->same_comdat_group;\n+\t   n->same_comdat_group != old_node;\n+\t   n = n->same_comdat_group)\n \t;\n-      n->symbol.same_comdat_group = new_node;\n+      n->same_comdat_group = new_node;\n     }\n }\n \n@@ -444,12 +444,12 @@ symtab_dissolve_same_comdat_group_list (symtab_node node)\n {\n   symtab_node n = node, next;\n \n-  if (!node->symbol.same_comdat_group)\n+  if (!node->same_comdat_group)\n     return;\n   do\n     {\n-      next = n->symbol.same_comdat_group;\n-      n->symbol.same_comdat_group = NULL;\n+      next = n->same_comdat_group;\n+      n->same_comdat_group = NULL;\n       n = next;\n     }\n   while (n != node);\n@@ -462,17 +462,17 @@ symtab_dissolve_same_comdat_group_list (symtab_node node)\n const char *\n symtab_node_asm_name (symtab_node node)\n {\n-  if (!DECL_ASSEMBLER_NAME_SET_P (node->symbol.decl))\n-    return lang_hooks.decl_printable_name (node->symbol.decl, 2);\n-  return IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->symbol.decl));\n+  if (!DECL_ASSEMBLER_NAME_SET_P (node->decl))\n+    return lang_hooks.decl_printable_name (node->decl, 2);\n+  return IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->decl));\n }\n \n /* Return printable identifier name.  */\n \n const char *\n symtab_node_name (symtab_node node)\n {\n-  return lang_hooks.decl_printable_name (node->symbol.decl, 2);\n+  return lang_hooks.decl_printable_name (node->decl, 2);\n }\n \n static const char * const symtab_type_names[] = {\"symbol\", \"function\", \"variable\"};\n@@ -488,107 +488,107 @@ dump_symtab_base (FILE *f, symtab_node node)\n \n   fprintf (f, \"%s/%i (%s)\",\n \t   symtab_node_asm_name (node),\n-\t   node->symbol.order,\n+\t   node->order,\n \t   symtab_node_name (node));\n   dump_addr (f, \" @\", (void *)node);\n-  fprintf (f, \"\\n  Type: %s\", symtab_type_names[node->symbol.type]);\n+  fprintf (f, \"\\n  Type: %s\", symtab_type_names[node->type]);\n \n-  if (node->symbol.definition)\n+  if (node->definition)\n     fprintf (f, \" definition\");\n-  if (node->symbol.analyzed)\n+  if (node->analyzed)\n     fprintf (f, \" analyzed\");\n-  if (node->symbol.alias)\n+  if (node->alias)\n     fprintf (f, \" alias\");\n-  if (node->symbol.weakref)\n+  if (node->weakref)\n     fprintf (f, \" weakref\");\n-  if (node->symbol.cpp_implicit_alias)\n+  if (node->cpp_implicit_alias)\n     fprintf (f, \" cpp_implicit_alias\");\n-  if (node->symbol.alias_target)\n+  if (node->alias_target)\n     fprintf (f, \" target:%s\",\n-\t     DECL_P (node->symbol.alias_target) \n+\t     DECL_P (node->alias_target) \n \t     ? IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME\n-\t\t\t\t     (node->symbol.alias_target))\n-\t     : IDENTIFIER_POINTER (node->symbol.alias_target));\n+\t\t\t\t     (node->alias_target))\n+\t     : IDENTIFIER_POINTER (node->alias_target));\n   fprintf (f, \"\\n  Visibility:\");\n-  if (node->symbol.in_other_partition)\n+  if (node->in_other_partition)\n     fprintf (f, \" in_other_partition\");\n-  if (node->symbol.used_from_other_partition)\n+  if (node->used_from_other_partition)\n     fprintf (f, \" used_from_other_partition\");\n-  if (node->symbol.force_output)\n+  if (node->force_output)\n     fprintf (f, \" force_output\");\n-  if (node->symbol.forced_by_abi)\n+  if (node->forced_by_abi)\n     fprintf (f, \" forced_by_abi\");\n-  if (node->symbol.externally_visible)\n+  if (node->externally_visible)\n     fprintf (f, \" externally_visible\");\n-  if (node->symbol.resolution != LDPR_UNKNOWN)\n+  if (node->resolution != LDPR_UNKNOWN)\n     fprintf (f, \" %s\",\n- \t     ld_plugin_symbol_resolution_names[(int)node->symbol.resolution]);\n-  if (TREE_ASM_WRITTEN (node->symbol.decl))\n+ \t     ld_plugin_symbol_resolution_names[(int)node->resolution]);\n+  if (TREE_ASM_WRITTEN (node->decl))\n     fprintf (f, \" asm_written\");\n-  if (DECL_EXTERNAL (node->symbol.decl))\n+  if (DECL_EXTERNAL (node->decl))\n     fprintf (f, \" external\");\n-  if (TREE_PUBLIC (node->symbol.decl))\n+  if (TREE_PUBLIC (node->decl))\n     fprintf (f, \" public\");\n-  if (DECL_COMMON (node->symbol.decl))\n+  if (DECL_COMMON (node->decl))\n     fprintf (f, \" common\");\n-  if (DECL_WEAK (node->symbol.decl))\n+  if (DECL_WEAK (node->decl))\n     fprintf (f, \" weak\");\n-  if (DECL_DLLIMPORT_P (node->symbol.decl))\n+  if (DECL_DLLIMPORT_P (node->decl))\n     fprintf (f, \" dll_import\");\n-  if (DECL_COMDAT (node->symbol.decl))\n+  if (DECL_COMDAT (node->decl))\n     fprintf (f, \" comdat\");\n-  if (DECL_COMDAT_GROUP (node->symbol.decl))\n+  if (DECL_COMDAT_GROUP (node->decl))\n     fprintf (f, \" comdat_group:%s\",\n-\t     IDENTIFIER_POINTER (DECL_COMDAT_GROUP (node->symbol.decl)));\n-  if (DECL_ONE_ONLY (node->symbol.decl))\n+\t     IDENTIFIER_POINTER (DECL_COMDAT_GROUP (node->decl)));\n+  if (DECL_ONE_ONLY (node->decl))\n     fprintf (f, \" one_only\");\n-  if (DECL_SECTION_NAME (node->symbol.decl))\n+  if (DECL_SECTION_NAME (node->decl))\n     fprintf (f, \" section_name:%s\",\n-\t     TREE_STRING_POINTER (DECL_SECTION_NAME (node->symbol.decl)));\n-  if (DECL_VISIBILITY_SPECIFIED (node->symbol.decl))\n+\t     TREE_STRING_POINTER (DECL_SECTION_NAME (node->decl)));\n+  if (DECL_VISIBILITY_SPECIFIED (node->decl))\n     fprintf (f, \" visibility_specified\");\n-  if (DECL_VISIBILITY (node->symbol.decl))\n+  if (DECL_VISIBILITY (node->decl))\n     fprintf (f, \" visibility:%s\",\n-\t     visibility_types [DECL_VISIBILITY (node->symbol.decl)]);\n-  if (DECL_VIRTUAL_P (node->symbol.decl))\n+\t     visibility_types [DECL_VISIBILITY (node->decl)]);\n+  if (DECL_VIRTUAL_P (node->decl))\n     fprintf (f, \" virtual\");\n-  if (DECL_ARTIFICIAL (node->symbol.decl))\n+  if (DECL_ARTIFICIAL (node->decl))\n     fprintf (f, \" artificial\");\n-  if (TREE_CODE (node->symbol.decl) == FUNCTION_DECL)\n+  if (TREE_CODE (node->decl) == FUNCTION_DECL)\n     {\n-      if (DECL_STATIC_CONSTRUCTOR (node->symbol.decl))\n+      if (DECL_STATIC_CONSTRUCTOR (node->decl))\n \tfprintf (f, \" constructor\");\n-      if (DECL_STATIC_DESTRUCTOR (node->symbol.decl))\n+      if (DECL_STATIC_DESTRUCTOR (node->decl))\n \tfprintf (f, \" destructor\");\n     }\n   fprintf (f, \"\\n\");\n   \n-  if (node->symbol.same_comdat_group)\n+  if (node->same_comdat_group)\n     fprintf (f, \"  Same comdat group as: %s/%i\\n\",\n-\t     symtab_node_asm_name (node->symbol.same_comdat_group),\n-\t     node->symbol.same_comdat_group->symbol.order);\n-  if (node->symbol.next_sharing_asm_name)\n+\t     symtab_node_asm_name (node->same_comdat_group),\n+\t     node->same_comdat_group->order);\n+  if (node->next_sharing_asm_name)\n     fprintf (f, \"  next sharing asm name: %i\\n\",\n-\t     node->symbol.next_sharing_asm_name->symbol.order);\n-  if (node->symbol.previous_sharing_asm_name)\n+\t     node->next_sharing_asm_name->order);\n+  if (node->previous_sharing_asm_name)\n     fprintf (f, \"  previous sharing asm name: %i\\n\",\n-\t     node->symbol.previous_sharing_asm_name->symbol.order);\n+\t     node->previous_sharing_asm_name->order);\n \n-  if (node->symbol.address_taken)\n+  if (node->address_taken)\n     fprintf (f, \"  Address is taken.\\n\");\n-  if (node->symbol.aux)\n+  if (node->aux)\n     {\n       fprintf (f, \"  Aux:\");\n-      dump_addr (f, \" @\", (void *)node->symbol.aux);\n+      dump_addr (f, \" @\", (void *)node->aux);\n     }\n \n   fprintf (f, \"  References: \");\n-  ipa_dump_references (f, &node->symbol.ref_list);\n+  ipa_dump_references (f, &node->ref_list);\n   fprintf (f, \"  Referring: \");\n-  ipa_dump_referring (f, &node->symbol.ref_list);\n-  if (node->symbol.lto_file_data)\n+  ipa_dump_referring (f, &node->ref_list);\n+  if (node->lto_file_data)\n     fprintf (f, \"  Read from file: %s\\n\",\n-\t     node->symbol.lto_file_data->file_name);\n+\t     node->lto_file_data->file_name);\n }\n \n /* Dump symtab node.  */\n@@ -639,15 +639,15 @@ verify_symtab_base (symtab_node node)\n \n   if (is_a <cgraph_node> (node))\n     {\n-      if (TREE_CODE (node->symbol.decl) != FUNCTION_DECL)\n+      if (TREE_CODE (node->decl) != FUNCTION_DECL)\n \t{\n           error (\"function symbol is not function\");\n           error_found = true;\n \t}\n     }\n   else if (is_a <varpool_node> (node))\n     {\n-      if (TREE_CODE (node->symbol.decl) != VAR_DECL)\n+      if (TREE_CODE (node->decl) != VAR_DECL)\n \t{\n           error (\"variable symbol is not variable\");\n           error_found = true;\n@@ -661,7 +661,7 @@ verify_symtab_base (symtab_node node)\n    \n   if (cgraph_state != CGRAPH_LTO_STREAMING)\n     {\n-      hashed_node = symtab_get_node (node->symbol.decl);\n+      hashed_node = symtab_get_node (node->decl);\n       if (!hashed_node)\n \t{\n \t  error (\"node not found in symtab decl hashtable\");\n@@ -670,17 +670,17 @@ verify_symtab_base (symtab_node node)\n       if (hashed_node != node\n \t  && (!is_a <cgraph_node> (node)\n \t      || !dyn_cast <cgraph_node> (node)->clone_of\n-\t      || dyn_cast <cgraph_node> (node)->clone_of->symbol.decl\n-\t\t != node->symbol.decl))\n+\t      || dyn_cast <cgraph_node> (node)->clone_of->decl\n+\t\t != node->decl))\n \t{\n \t  error (\"node differs from symtab decl hashtable\");\n \t  error_found = true;\n \t}\n     }\n   if (assembler_name_hash)\n     {\n-      hashed_node = symtab_node_for_asm (DECL_ASSEMBLER_NAME (node->symbol.decl));\n-      if (hashed_node && hashed_node->symbol.previous_sharing_asm_name)\n+      hashed_node = symtab_node_for_asm (DECL_ASSEMBLER_NAME (node->decl));\n+      if (hashed_node && hashed_node->previous_sharing_asm_name)\n \t{\n           error (\"assembler name hash list corrupted\");\n           error_found = true;\n@@ -689,53 +689,53 @@ verify_symtab_base (symtab_node node)\n \t{\n \t  if (hashed_node == node)\n \t    break;\n-\t  hashed_node = hashed_node->symbol.next_sharing_asm_name;\n+\t  hashed_node = hashed_node->next_sharing_asm_name;\n \t}\n       if (!hashed_node\n           && !(is_a <varpool_node> (node)\n-\t       || DECL_HARD_REGISTER (node->symbol.decl)))\n+\t       || DECL_HARD_REGISTER (node->decl)))\n \t{\n           error (\"node not found in symtab assembler name hash\");\n           error_found = true;\n \t}\n     }\n-  if (node->symbol.previous_sharing_asm_name\n-      && node->symbol.previous_sharing_asm_name->symbol.next_sharing_asm_name != node)\n+  if (node->previous_sharing_asm_name\n+      && node->previous_sharing_asm_name->next_sharing_asm_name != node)\n     {\n       error (\"double linked list of assembler names corrupted\");\n       error_found = true;\n     }\n-  if (node->symbol.analyzed && !node->symbol.definition)\n+  if (node->analyzed && !node->definition)\n     {\n       error (\"node is analyzed byt it is not a definition\");\n       error_found = true;\n     }\n-  if (node->symbol.cpp_implicit_alias && !node->symbol.alias)\n+  if (node->cpp_implicit_alias && !node->alias)\n     {\n       error (\"node is alias but not implicit alias\");\n       error_found = true;\n     }\n-  if (node->symbol.alias && !node->symbol.definition\n-      && !node->symbol.weakref)\n+  if (node->alias && !node->definition\n+      && !node->weakref)\n     {\n       error (\"node is alias but not definition\");\n       error_found = true;\n     }\n-  if (node->symbol.weakref && !node->symbol.alias)\n+  if (node->weakref && !node->alias)\n     {\n       error (\"node is weakref but not an alias\");\n       error_found = true;\n     }\n-  if (node->symbol.same_comdat_group)\n+  if (node->same_comdat_group)\n     {\n-      symtab_node n = node->symbol.same_comdat_group;\n+      symtab_node n = node->same_comdat_group;\n \n-      if (!DECL_ONE_ONLY (n->symbol.decl))\n+      if (!DECL_ONE_ONLY (n->decl))\n \t{\n \t  error (\"non-DECL_ONE_ONLY node in a same_comdat_group list\");\n \t  error_found = true;\n \t}\n-      if (n->symbol.type != node->symbol.type)\n+      if (n->type != node->type)\n \t{\n \t  error (\"mixing different types of symbol in same comdat groups is not supported\");\n \t  error_found = true;\n@@ -747,13 +747,13 @@ verify_symtab_base (symtab_node node)\n \t}\n       do\n \t{\n-\t  if (!n->symbol.same_comdat_group)\n+\t  if (!n->same_comdat_group)\n \t    {\n \t      error (\"same_comdat_group is not a circular list\");\n \t      error_found = true;\n \t      break;\n \t    }\n-\t  n = n->symbol.same_comdat_group;\n+\t  n = n->same_comdat_group;\n \t}\n       while (n != node);\n     }\n@@ -808,9 +808,9 @@ resolution_used_from_other_file_p (enum ld_plugin_symbol_resolution resolution)\n bool\n symtab_used_from_object_file_p (symtab_node node)\n {\n-  if (!TREE_PUBLIC (node->symbol.decl) || DECL_EXTERNAL (node->symbol.decl))\n+  if (!TREE_PUBLIC (node->decl) || DECL_EXTERNAL (node->decl))\n     return false;\n-  if (resolution_used_from_other_file_p (node->symbol.resolution))\n+  if (resolution_used_from_other_file_p (node->resolution))\n     return true;\n   return false;\n }\n@@ -875,7 +875,7 @@ symtab_alias_ultimate_target (symtab_node node, enum availability *availability)\n {\n   bool weakref_p = false;\n \n-  if (!node->symbol.alias)\n+  if (!node->alias)\n     {\n       if (availability)\n         *availability = symtab_node_availability (node);\n@@ -898,21 +898,21 @@ symtab_alias_ultimate_target (symtab_node node, enum availability *availability)\n \n   if (availability)\n     {\n-      weakref_p = node->symbol.weakref;\n+      weakref_p = node->weakref;\n       if (!weakref_p)\n         *availability = symtab_node_availability (node);\n       else\n \t*availability = AVAIL_LOCAL;\n     }\n   while (node)\n     {\n-      if (node->symbol.alias && node->symbol.analyzed)\n+      if (node->alias && node->analyzed)\n \tnode = symtab_alias_target (node);\n       else\n \t{\n \t  if (!availability)\n \t    ;\n-\t  else if (node->symbol.analyzed)\n+\t  else if (node->analyzed)\n \t    {\n \t      if (weakref_p)\n \t\t{\n@@ -930,7 +930,7 @@ symtab_alias_ultimate_target (symtab_node node, enum availability *availability)\n \t  enum availability a = symtab_node_availability (node);\n \t  if (a < *availability)\n \t    *availability = a;\n-          weakref_p = node->symbol.weakref;\n+          weakref_p = node->weakref;\n \t}\n     }\n   if (availability)\n@@ -950,31 +950,31 @@ fixup_same_cpp_alias_visibility (symtab_node node, symtab_node target)\n {\n   if (is_a <cgraph_node> (node))\n     {\n-      DECL_DECLARED_INLINE_P (node->symbol.decl)\n-\t = DECL_DECLARED_INLINE_P (target->symbol.decl);\n-      DECL_DISREGARD_INLINE_LIMITS (node->symbol.decl)\n-\t = DECL_DISREGARD_INLINE_LIMITS (target->symbol.decl);\n+      DECL_DECLARED_INLINE_P (node->decl)\n+\t = DECL_DECLARED_INLINE_P (target->decl);\n+      DECL_DISREGARD_INLINE_LIMITS (node->decl)\n+\t = DECL_DISREGARD_INLINE_LIMITS (target->decl);\n     }\n   /* FIXME: It is not really clear why those flags should not be copied for\n      functions, too.  */\n   else\n     {\n-      DECL_WEAK (node->symbol.decl) = DECL_WEAK (target->symbol.decl);\n-      DECL_EXTERNAL (node->symbol.decl) = DECL_EXTERNAL (target->symbol.decl);\n-      DECL_VISIBILITY (node->symbol.decl) = DECL_VISIBILITY (target->symbol.decl);\n+      DECL_WEAK (node->decl) = DECL_WEAK (target->decl);\n+      DECL_EXTERNAL (node->decl) = DECL_EXTERNAL (target->decl);\n+      DECL_VISIBILITY (node->decl) = DECL_VISIBILITY (target->decl);\n     }\n-  DECL_VIRTUAL_P (node->symbol.decl) = DECL_VIRTUAL_P (target->symbol.decl);\n-  if (TREE_PUBLIC (node->symbol.decl))\n+  DECL_VIRTUAL_P (node->decl) = DECL_VIRTUAL_P (target->decl);\n+  if (TREE_PUBLIC (node->decl))\n     {\n-      DECL_EXTERNAL (node->symbol.decl) = DECL_EXTERNAL (target->symbol.decl);\n-      DECL_COMDAT (node->symbol.decl) = DECL_COMDAT (target->symbol.decl);\n-      DECL_COMDAT_GROUP (node->symbol.decl)\n-\t = DECL_COMDAT_GROUP (target->symbol.decl);\n-      if (DECL_ONE_ONLY (target->symbol.decl)\n-\t  && !node->symbol.same_comdat_group)\n-\tsymtab_add_to_same_comdat_group ((symtab_node)node, (symtab_node)target);\n+      DECL_EXTERNAL (node->decl) = DECL_EXTERNAL (target->decl);\n+      DECL_COMDAT (node->decl) = DECL_COMDAT (target->decl);\n+      DECL_COMDAT_GROUP (node->decl)\n+\t = DECL_COMDAT_GROUP (target->decl);\n+      if (DECL_ONE_ONLY (target->decl)\n+\t  && !node->same_comdat_group)\n+\tsymtab_add_to_same_comdat_group (node, target);\n     }\n-  node->symbol.externally_visible = target->symbol.externally_visible;\n+  node->externally_visible = target->externally_visible;\n }\n \n /* Add reference recording that NODE is alias of TARGET.\n@@ -986,42 +986,42 @@ symtab_resolve_alias (symtab_node node, symtab_node target)\n {\n   symtab_node n;\n \n-  gcc_assert (!node->symbol.analyzed\n-\t      && !vec_safe_length (node->symbol.ref_list.references));\n+  gcc_assert (!node->analyzed\n+\t      && !vec_safe_length (node->ref_list.references));\n \n   /* Never let cycles to creep into the symbol table alias references;\n      those will make alias walkers to be infinite.  */\n-  for (n = target; n && n->symbol.alias;\n-       n = n->symbol.analyzed ? symtab_alias_target (n) : NULL)\n+  for (n = target; n && n->alias;\n+       n = n->analyzed ? symtab_alias_target (n) : NULL)\n     if (n == node)\n        {\n \t if (is_a <cgraph_node> (node))\n-           error (\"function %q+D part of alias cycle\", node->symbol.decl);\n+           error (\"function %q+D part of alias cycle\", node->decl);\n          else if (is_a <varpool_node> (node))\n-           error (\"variable %q+D part of alias cycle\", node->symbol.decl);\n+           error (\"variable %q+D part of alias cycle\", node->decl);\n \t else\n \t   gcc_unreachable ();\n-\t node->symbol.alias = false;\n+\t node->alias = false;\n \t return false;\n        }\n \n   /* \"analyze\" the node - i.e. mark the reference.  */\n-  node->symbol.definition = true;\n-  node->symbol.alias = true;\n-  node->symbol.analyzed = true;\n+  node->definition = true;\n+  node->alias = true;\n+  node->analyzed = true;\n   ipa_record_reference (node, target, IPA_REF_ALIAS, NULL);\n \n   /* Alias targets become reudndant after alias is resolved into an reference.\n      We do not want to keep it around or we would have to mind updating them\n      when renaming symbols.  */\n-  node->symbol.alias_target = NULL;\n+  node->alias_target = NULL;\n \n-  if (node->symbol.cpp_implicit_alias && cgraph_state >= CGRAPH_STATE_CONSTRUCTION)\n+  if (node->cpp_implicit_alias && cgraph_state >= CGRAPH_STATE_CONSTRUCTION)\n     fixup_same_cpp_alias_visibility (node, target);\n \n   /* If alias has address taken, so does the target.  */\n-  if (node->symbol.address_taken)\n-    symtab_alias_ultimate_target (target, NULL)->symbol.address_taken = true;\n+  if (node->address_taken)\n+    symtab_alias_ultimate_target (target, NULL)->address_taken = true;\n   return true;\n }\n \n@@ -1040,7 +1040,7 @@ symtab_for_node_and_aliases (symtab_node node,\n \n   if (callback (node, data))\n     return true;\n-  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list, i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n \tsymtab_node alias = ref->referring;\n@@ -1058,7 +1058,7 @@ symtab_for_node_and_aliases (symtab_node node,\n static bool\n symtab_nonoverwritable_alias_1 (symtab_node node, void *data)\n {\n-  if (decl_binds_to_current_def_p (node->symbol.decl))\n+  if (decl_binds_to_current_def_p (node->decl))\n     {\n       *(symtab_node *)data = node;\n       return true;\n@@ -1079,7 +1079,7 @@ symtab_nonoverwritable_alias (symtab_node node)\n   /* First try to look up existing alias or base object\n      (if that is already non-overwritable).  */\n   node = symtab_alias_ultimate_target (node, NULL);\n-  gcc_assert (!node->symbol.alias && !node->symbol.weakref);\n+  gcc_assert (!node->alias && !node->weakref);\n   symtab_for_node_and_aliases (node, symtab_nonoverwritable_alias_1,\n \t\t               (void *)&new_node, true);\n   if (new_node)\n@@ -1090,8 +1090,8 @@ symtab_nonoverwritable_alias (symtab_node node)\n #endif\n \n   /* Otherwise create a new one.  */\n-  new_decl = copy_node (node->symbol.decl);\n-  DECL_NAME (new_decl) = clone_function_name (node->symbol.decl, \"localalias\");\n+  new_decl = copy_node (node->decl);\n+  DECL_NAME (new_decl) = clone_function_name (node->decl, \"localalias\");\n   if (TREE_CODE (new_decl) == FUNCTION_DECL)\n     DECL_STRUCT_FUNCTION (new_decl) = NULL;\n   DECL_INITIAL (new_decl) = NULL;\n@@ -1100,7 +1100,7 @@ symtab_nonoverwritable_alias (symtab_node node)\n \n   /* Update the properties.  */\n   DECL_EXTERNAL (new_decl) = 0;\n-  if (DECL_ONE_ONLY (node->symbol.decl))\n+  if (DECL_ONE_ONLY (node->decl))\n     DECL_SECTION_NAME (new_decl) = NULL;\n   DECL_COMDAT_GROUP (new_decl) = 0;\n   TREE_PUBLIC (new_decl) = 0;\n@@ -1111,12 +1111,12 @@ symtab_nonoverwritable_alias (symtab_node node)\n     {\n       DECL_STATIC_CONSTRUCTOR (new_decl) = 0;\n       DECL_STATIC_DESTRUCTOR (new_decl) = 0;\n-      new_node = (symtab_node) cgraph_create_function_alias\n-\t\t\t\t (new_decl, node->symbol.decl);\n+      new_node = cgraph_create_function_alias\n+\t\t\t\t (new_decl, node->decl);\n     }\n   else\n-    new_node = (symtab_node) varpool_create_variable_alias (new_decl,\n-\t\t\t\t\t\t\t    node->symbol.decl);\n+    new_node = varpool_create_variable_alias (new_decl,\n+\t\t\t\t\t\t\t    node->decl);\n   symtab_resolve_alias (new_node, node);  \n   gcc_assert (decl_binds_to_current_def_p (new_decl));\n   return new_node;\n@@ -1132,7 +1132,7 @@ symtab_semantically_equivalent_p (symtab_node a,\n   symtab_node ba, bb;\n \n   /* Equivalent functions are equivalent.  */\n-  if (a->symbol.decl == b->symbol.decl)\n+  if (a->decl == b->decl)\n     return true;\n \n   /* If symbol is not overwritable by different implementation,"}, {"sha": "436f7a592f3a9f18e020c7ee902053eb88b3dbda", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -394,15 +394,15 @@ wrapup_global_declaration_2 (tree decl)\n \n       if (!node && flag_ltrans)\n \tneeded = false;\n-      else if (node && node->symbol.definition)\n+      else if (node && node->definition)\n \tneeded = false;\n-      else if (node && node->symbol.alias)\n+      else if (node && node->alias)\n \tneeded = false;\n       else if (!cgraph_global_info_ready\n \t       && (TREE_USED (decl)\n \t\t   || TREE_USED (DECL_ASSEMBLER_NAME (decl))))\n \t/* needed */;\n-      else if (node && node->symbol.analyzed)\n+      else if (node && node->analyzed)\n \t/* needed */;\n       else if (DECL_COMDAT (decl))\n \tneeded = false;"}, {"sha": "d74455d2bbcfaf545e402b7fe4fa4d2302e2485c", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -4040,16 +4040,16 @@ get_cg_data (struct cgraph_node **node, bool traverse_aliases)\n {\n   struct tm_ipa_cg_data *d;\n \n-  if (traverse_aliases && (*node)->symbol.alias)\n+  if (traverse_aliases && (*node)->alias)\n     *node = cgraph_alias_target (*node);\n \n-  d = (struct tm_ipa_cg_data *) (*node)->symbol.aux;\n+  d = (struct tm_ipa_cg_data *) (*node)->aux;\n \n   if (d == NULL)\n     {\n       d = (struct tm_ipa_cg_data *)\n \tobstack_alloc (&tm_obstack.obstack, sizeof (*d));\n-      (*node)->symbol.aux = (void *) d;\n+      (*node)->aux = (void *) d;\n       memset (d, 0, sizeof (*d));\n     }\n \n@@ -4192,7 +4192,7 @@ static void\n ipa_tm_scan_calls_clone (struct cgraph_node *node,\n \t\t\t cgraph_node_queue *callees_p)\n {\n-  struct function *fn = DECL_STRUCT_FUNCTION (node->symbol.decl);\n+  struct function *fn = DECL_STRUCT_FUNCTION (node->decl);\n   basic_block bb;\n \n   FOR_EACH_BB_FN (bb, fn)\n@@ -4221,7 +4221,7 @@ ipa_tm_note_irrevocable (struct cgraph_node *node,\n \tcontinue;\n       /* Even if we think we can go irrevocable, believe the user\n \t above all.  */\n-      if (is_tm_safe_or_pure (e->caller->symbol.decl))\n+      if (is_tm_safe_or_pure (e->caller->decl))\n \tcontinue;\n \n       caller = e->caller;\n@@ -4493,11 +4493,11 @@ ipa_tm_scan_irr_function (struct cgraph_node *node, bool for_clone)\n   bool ret = false;\n \n   /* Builtin operators (operator new, and such).  */\n-  if (DECL_STRUCT_FUNCTION (node->symbol.decl) == NULL\n-      || DECL_STRUCT_FUNCTION (node->symbol.decl)->cfg == NULL)\n+  if (DECL_STRUCT_FUNCTION (node->decl) == NULL\n+      || DECL_STRUCT_FUNCTION (node->decl)->cfg == NULL)\n     return false;\n \n-  push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n   calculate_dominance_info (CDI_DOMINATORS);\n \n   d = get_cg_data (&node, true);\n@@ -4583,7 +4583,7 @@ ipa_tm_mayenterirr_function (struct cgraph_node *node)\n   unsigned flags;\n \n   d = get_cg_data (&node, true);\n-  decl = node->symbol.decl;\n+  decl = node->decl;\n   flags = flags_from_decl_or_type (decl);\n \n   /* Handle some TM builtins.  Ordinarily these aren't actually generated\n@@ -4626,7 +4626,7 @@ ipa_tm_mayenterirr_function (struct cgraph_node *node)\n   /* Recurse on the main body for aliases.  In general, this will\n      result in one of the bits above being set so that we will not\n      have to recurse next time.  */\n-  if (node->symbol.alias)\n+  if (node->alias)\n     return ipa_tm_mayenterirr_function (cgraph_get_node (node->thunk.alias));\n \n   /* What remains is unmarked local functions without items that force\n@@ -4643,11 +4643,11 @@ ipa_tm_diagnose_tm_safe (struct cgraph_node *node)\n   struct cgraph_edge *e;\n \n   for (e = node->callees; e ; e = e->next_callee)\n-    if (!is_tm_callable (e->callee->symbol.decl)\n+    if (!is_tm_callable (e->callee->decl)\n \t&& e->callee->local.tm_may_enter_irr)\n       error_at (gimple_location (e->call_stmt),\n \t\t\"unsafe function call %qD within \"\n-\t\t\"%<transaction_safe%> function\", e->callee->symbol.decl);\n+\t\t\"%<transaction_safe%> function\", e->callee->decl);\n }\n \n /* Diagnose call from atomic transactions to unmarked functions\n@@ -4786,14 +4786,14 @@ static inline void\n ipa_tm_mark_force_output_node (struct cgraph_node *node)\n {\n   cgraph_mark_force_output_node (node);\n-  node->symbol.analyzed = true;\n+  node->analyzed = true;\n }\n \n static inline void\n ipa_tm_mark_forced_by_abi_node (struct cgraph_node *node)\n {\n-  node->symbol.forced_by_abi = true;\n-  node->symbol.analyzed = true;\n+  node->forced_by_abi = true;\n+  node->analyzed = true;\n }\n \n /* Callback data for ipa_tm_create_version_alias.  */\n@@ -4814,10 +4814,10 @@ ipa_tm_create_version_alias (struct cgraph_node *node, void *data)\n   tree old_decl, new_decl, tm_name;\n   struct cgraph_node *new_node;\n \n-  if (!node->symbol.cpp_implicit_alias)\n+  if (!node->cpp_implicit_alias)\n     return false;\n \n-  old_decl = node->symbol.decl;\n+  old_decl = node->decl;\n   tm_name = tm_mangle (DECL_ASSEMBLER_NAME (old_decl));\n   new_decl = build_decl (DECL_SOURCE_LOCATION (old_decl),\n \t\t\t TREE_CODE (old_decl), tm_name,\n@@ -4843,16 +4843,16 @@ ipa_tm_create_version_alias (struct cgraph_node *node, void *data)\n \n   new_node = cgraph_same_body_alias (NULL, new_decl, info->new_decl);\n   new_node->tm_clone = true;\n-  new_node->symbol.externally_visible = info->old_node->symbol.externally_visible;\n+  new_node->externally_visible = info->old_node->externally_visible;\n   /* ?? Do not traverse aliases here.  */\n   get_cg_data (&node, false)->clone = new_node;\n \n   record_tm_clone_pair (old_decl, new_decl);\n \n-  if (info->old_node->symbol.force_output\n-      || ipa_ref_list_first_referring (&info->old_node->symbol.ref_list))\n+  if (info->old_node->force_output\n+      || ipa_ref_list_first_referring (&info->old_node->ref_list))\n     ipa_tm_mark_force_output_node (new_node);\n-  if (info->old_node->symbol.forced_by_abi)\n+  if (info->old_node->forced_by_abi)\n     ipa_tm_mark_forced_by_abi_node (new_node);\n   return false;\n }\n@@ -4866,7 +4866,7 @@ ipa_tm_create_version (struct cgraph_node *old_node)\n   tree new_decl, old_decl, tm_name;\n   struct cgraph_node *new_node;\n \n-  old_decl = old_node->symbol.decl;\n+  old_decl = old_node->decl;\n   new_decl = copy_node (old_decl);\n \n   /* DECL_ASSEMBLER_NAME needs to be set before we call\n@@ -4883,7 +4883,7 @@ ipa_tm_create_version (struct cgraph_node *old_node)\n \n   new_node = cgraph_copy_node_for_versioning (old_node, new_decl, vNULL, NULL);\n   new_node->local.local = false;\n-  new_node->symbol.externally_visible = old_node->symbol.externally_visible;\n+  new_node->externally_visible = old_node->externally_visible;\n   new_node->lowered = true;\n   new_node->tm_clone = 1;\n   get_cg_data (&old_node, true)->clone = new_node;\n@@ -4907,10 +4907,10 @@ ipa_tm_create_version (struct cgraph_node *old_node)\n   record_tm_clone_pair (old_decl, new_decl);\n \n   cgraph_call_function_insertion_hooks (new_node);\n-  if (old_node->symbol.force_output\n-      || ipa_ref_list_first_referring (&old_node->symbol.ref_list))\n+  if (old_node->force_output\n+      || ipa_ref_list_first_referring (&old_node->ref_list))\n     ipa_tm_mark_force_output_node (new_node);\n-  if (old_node->symbol.forced_by_abi)\n+  if (old_node->forced_by_abi)\n     ipa_tm_mark_forced_by_abi_node (new_node);\n \n   /* Do the same thing, but for any aliases of the original node.  */\n@@ -4945,7 +4945,7 @@ ipa_tm_insert_irr_call (struct cgraph_node *node, struct tm_region *region,\n \t       cgraph_get_create_node\n \t\t  (builtin_decl_explicit (BUILT_IN_TM_IRREVOCABLE)),\n \t\t      g, 0,\n-\t\t      compute_call_stmt_bb_frequency (node->symbol.decl,\n+\t\t      compute_call_stmt_bb_frequency (node->decl,\n \t\t\t\t\t\t      gimple_bb (g)));\n }\n \n@@ -4995,7 +4995,7 @@ ipa_tm_insert_gettmclone_call (struct cgraph_node *node,\n   gsi_insert_before (gsi, g, GSI_SAME_STMT);\n \n   cgraph_create_edge (node, cgraph_get_create_node (gettm_fn), g, 0,\n-\t\t      compute_call_stmt_bb_frequency (node->symbol.decl,\n+\t\t      compute_call_stmt_bb_frequency (node->decl,\n \t\t\t\t\t\t      gimple_bb (g)));\n \n   /* Cast return value from tm_gettmclone* into appropriate function\n@@ -5122,7 +5122,7 @@ ipa_tm_transform_calls_redirect (struct cgraph_node *node,\n \t  return;\n \t}\n \n-      fndecl = new_node->symbol.decl;\n+      fndecl = new_node->decl;\n     }\n \n   cgraph_redirect_edge_callee (e, new_node);\n@@ -5216,7 +5216,7 @@ ipa_tm_transform_transaction (struct cgraph_node *node)\n \n   d = get_cg_data (&node, true);\n \n-  push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n   calculate_dominance_info (CDI_DOMINATORS);\n \n   for (region = d->all_tm_regions; region; region = region->next)\n@@ -5259,7 +5259,7 @@ ipa_tm_transform_clone (struct cgraph_node *node)\n   if (!node->callees && !node->indirect_calls && !d->irrevocable_blocks_clone)\n     return;\n \n-  push_cfun (DECL_STRUCT_FUNCTION (d->clone->symbol.decl));\n+  push_cfun (DECL_STRUCT_FUNCTION (d->clone->decl));\n   calculate_dominance_info (CDI_DOMINATORS);\n \n   need_ssa_rename =\n@@ -5295,7 +5295,7 @@ ipa_tm_execute (void)\n \n   /* For all local functions marked tm_callable, queue them.  */\n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (is_tm_callable (node->symbol.decl)\n+    if (is_tm_callable (node->decl)\n \t&& cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n       {\n \td = get_cg_data (&node, true);\n@@ -5310,14 +5310,14 @@ ipa_tm_execute (void)\n \t/* ... marked tm_pure, record that fact for the runtime by\n \t   indicating that the pure function is its own tm_callable.\n \t   No need to do this if the function's address can't be taken.  */\n-\tif (is_tm_pure (node->symbol.decl))\n+\tif (is_tm_pure (node->decl))\n \t  {\n \t    if (!node->local.local)\n-\t      record_tm_clone_pair (node->symbol.decl, node->symbol.decl);\n+\t      record_tm_clone_pair (node->decl, node->decl);\n \t    continue;\n \t  }\n \n-\tpush_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+\tpush_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \tcalculate_dominance_info (CDI_DOMINATORS);\n \n \ttm_region_init (NULL);\n@@ -5355,20 +5355,20 @@ ipa_tm_execute (void)\n \n       /* Some callees cannot be arbitrarily cloned.  These will always be\n \t irrevocable.  Mark these now, so that we need not scan them.  */\n-      if (is_tm_irrevocable (node->symbol.decl))\n+      if (is_tm_irrevocable (node->decl))\n \tipa_tm_note_irrevocable (node, &irr_worklist);\n       else if (a <= AVAIL_NOT_AVAILABLE\n-\t       && !is_tm_safe_or_pure (node->symbol.decl))\n+\t       && !is_tm_safe_or_pure (node->decl))\n \tipa_tm_note_irrevocable (node, &irr_worklist);\n       else if (a >= AVAIL_OVERWRITABLE)\n \t{\n-\t  if (!tree_versionable_function_p (node->symbol.decl))\n+\t  if (!tree_versionable_function_p (node->decl))\n \t    ipa_tm_note_irrevocable (node, &irr_worklist);\n \t  else if (!d->is_irrevocable)\n \t    {\n \t      /* If this is an alias, make sure its base is queued as well.\n \t\t we need not scan the callees now, as the base will do.  */\n-\t      if (node->symbol.alias)\n+\t      if (node->alias)\n \t\t{\n \t\t  node = cgraph_get_node (node->thunk.alias);\n \t\t  d = get_cg_data (&node, true);\n@@ -5446,7 +5446,7 @@ ipa_tm_execute (void)\n       for (e = node->callers; e ; e = e->next_caller)\n \t{\n \t  caller = e->caller;\n-\t  if (!is_tm_safe_or_pure (caller->symbol.decl)\n+\t  if (!is_tm_safe_or_pure (caller->decl)\n \t      && !caller->local.tm_may_enter_irr)\n \t    {\n \t      d = get_cg_data (&caller, true);\n@@ -5455,7 +5455,7 @@ ipa_tm_execute (void)\n \t}\n \n       /* Propagate back to referring aliases as well.  */\n-      for (j = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list, j, ref); j++)\n+      for (j = 0; ipa_ref_list_referring_iterate (&node->ref_list, j, ref); j++)\n \t{\n \t  caller = cgraph (ref->referring);\n \t  if (ref->use == IPA_REF_ALIAS\n@@ -5475,7 +5475,7 @@ ipa_tm_execute (void)\n \t&& cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n       {\n \td = get_cg_data (&node, true);\n-\tif (is_tm_safe (node->symbol.decl))\n+\tif (is_tm_safe (node->decl))\n \t  ipa_tm_diagnose_tm_safe (node);\n \telse if (d->all_tm_regions)\n \t  ipa_tm_diagnose_transaction (node, d->all_tm_regions);\n@@ -5489,15 +5489,15 @@ ipa_tm_execute (void)\n       bool doit = false;\n \n       node = tm_callees[i];\n-      if (node->symbol.cpp_implicit_alias)\n+      if (node->cpp_implicit_alias)\n \tcontinue;\n \n       a = cgraph_function_body_availability (node);\n       d = get_cg_data (&node, true);\n \n       if (a <= AVAIL_NOT_AVAILABLE)\n-\tdoit = is_tm_callable (node->symbol.decl);\n-      else if (a <= AVAIL_AVAILABLE && is_tm_callable (node->symbol.decl))\n+\tdoit = is_tm_callable (node->decl);\n+      else if (a <= AVAIL_AVAILABLE && is_tm_callable (node->decl))\n \tdoit = true;\n       else if (!d->is_irrevocable\n \t       && d->tm_callers_normal + d->tm_callers_clone > 0)\n@@ -5511,7 +5511,7 @@ ipa_tm_execute (void)\n   for (i = 0; i < tm_callees.length (); ++i)\n     {\n       node = tm_callees[i];\n-      if (node->symbol.analyzed)\n+      if (node->analyzed)\n \t{\n \t  d = get_cg_data (&node, true);\n \t  if (d->clone)\n@@ -5534,7 +5534,7 @@ ipa_tm_execute (void)\n   free_original_copy_tables ();\n \n   FOR_EACH_FUNCTION (node)\n-    node->symbol.aux = NULL;\n+    node->aux = NULL;\n \n #ifdef ENABLE_CHECKING\n   verify_cgraph ();"}, {"sha": "a91542d56aa7913dcb593d104c2be1702860c001", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -2602,7 +2602,7 @@ tree_could_trap_p (tree expr)\n \t  if (!DECL_EXTERNAL (expr))\n \t    return false;\n \t  node = cgraph_function_node (cgraph_get_node (expr), NULL);\n-\t  if (node && node->symbol.in_other_partition)\n+\t  if (node && node->in_other_partition)\n \t    return false;\n \t  return true;\n \t}\n@@ -2618,7 +2618,7 @@ tree_could_trap_p (tree expr)\n \t  if (!DECL_EXTERNAL (expr))\n \t    return false;\n \t  node = varpool_variable_node (varpool_get_node (expr), NULL);\n-\t  if (node && node->symbol.in_other_partition)\n+\t  if (node && node->in_other_partition)\n \t    return false;\n \t  return true;\n \t}"}, {"sha": "b5ca407d62e22fd9c52764f33228ff6ade76a761", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -340,7 +340,7 @@ new_emutls_decl (tree decl, tree alias_of)\n   else \n     varpool_create_variable_alias (to,\n \t\t\t\t   varpool_node_for_asm\n-\t\t\t\t    (DECL_ASSEMBLER_NAME (DECL_VALUE_EXPR (alias_of)))->symbol.decl);\n+\t\t\t\t    (DECL_ASSEMBLER_NAME (DECL_VALUE_EXPR (alias_of)))->decl);\n   return to;\n }\n \n@@ -368,7 +368,7 @@ emutls_decl (tree decl)\n \n   i = emutls_index (decl);\n   var = control_vars[i];\n-  return var->symbol.decl;\n+  return var->decl;\n }\n \n /* Generate a call statement to initialize CONTROL_DECL for TLS_DECL.\n@@ -430,7 +430,7 @@ gen_emutls_addr (tree decl, struct lower_emutls_data *d)\n       gimple x;\n \n       cvar = control_vars[index];\n-      cdecl = cvar->symbol.decl;\n+      cdecl = cvar->decl;\n       TREE_ADDRESSABLE (cdecl) = 1;\n \n       addr = create_tmp_var (build_pointer_type (TREE_TYPE (decl)), NULL);\n@@ -447,7 +447,7 @@ gen_emutls_addr (tree decl, struct lower_emutls_data *d)\n \n       /* We may be adding a new reference to a new variable to the function.\n          This means we have to play with the ipa-reference web.  */\n-      ipa_record_reference ((symtab_node)d->cfun_node, (symtab_node)cvar, IPA_REF_ADDR, x);\n+      ipa_record_reference (d->cfun_node, cvar, IPA_REF_ADDR, x);\n \n       /* Record this ssa_name for possible use later in the basic block.  */\n       access_vars[index] = addr;\n@@ -620,7 +620,7 @@ lower_emutls_function_body (struct cgraph_node *node)\n   struct lower_emutls_data d;\n   bool any_edge_inserts = false;\n \n-  push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \n   d.cfun_node = node;\n   d.builtin_decl = builtin_decl_explicit (BUILT_IN_EMUTLS_GET_ADDRESS);\n@@ -702,29 +702,29 @@ create_emultls_var (struct varpool_node *var, void *data)\n   tree cdecl;\n   struct varpool_node *cvar;\n \n-  cdecl = new_emutls_decl (var->symbol.decl,\n-\t\t\t   var->symbol.alias && var->symbol.analyzed\n-\t\t\t   ? varpool_alias_target (var)->symbol.decl : NULL);\n+  cdecl = new_emutls_decl (var->decl,\n+\t\t\t   var->alias && var->analyzed\n+\t\t\t   ? varpool_alias_target (var)->decl : NULL);\n \n   cvar = varpool_get_node (cdecl);\n   control_vars.quick_push (cvar);\n \n-  if (!var->symbol.alias)\n+  if (!var->alias)\n     {\n       /* Make sure the COMMON block control variable gets initialized.\n \t Note that there's no point in doing this for aliases; we only\n \t need to do this once for the main variable.  */\n-      emutls_common_1 (var->symbol.decl, cdecl, (tree *)data);\n+      emutls_common_1 (var->decl, cdecl, (tree *)data);\n     }\n-  if (var->symbol.alias && !var->symbol.analyzed)\n-    cvar->symbol.alias = true;\n+  if (var->alias && !var->analyzed)\n+    cvar->alias = true;\n \n   /* Indicate that the value of the TLS variable may be found elsewhere,\n      preventing the variable from re-appearing in the GIMPLE.  We cheat\n      and use the control variable here (rather than a full call_expr),\n      which is special-cased inside the DWARF2 output routines.  */\n-  SET_DECL_VALUE_EXPR (var->symbol.decl, cdecl);\n-  DECL_HAS_VALUE_EXPR_P (var->symbol.decl) = 1;\n+  SET_DECL_VALUE_EXPR (var->decl, cdecl);\n+  DECL_HAS_VALUE_EXPR_P (var->decl) = 1;\n   return false;\n }\n \n@@ -743,12 +743,12 @@ ipa_lower_emutls (void)\n \n   /* Examine all global variables for TLS variables.  */\n   FOR_EACH_VARIABLE (var)\n-    if (DECL_THREAD_LOCAL_P (var->symbol.decl))\n+    if (DECL_THREAD_LOCAL_P (var->decl))\n       {\n-\tgcc_checking_assert (TREE_STATIC (var->symbol.decl)\n-\t\t\t     || DECL_EXTERNAL (var->symbol.decl));\n+\tgcc_checking_assert (TREE_STATIC (var->decl)\n+\t\t\t     || DECL_EXTERNAL (var->decl));\n \tvarpool_node_set_add (tls_vars, var);\n-\tif (var->symbol.alias && var->symbol.definition)\n+\tif (var->alias && var->definition)\n \t  varpool_node_set_add (tls_vars, varpool_variable_node (var, NULL));\n       }\n \n@@ -772,9 +772,9 @@ ipa_lower_emutls (void)\n     {\n       var = tls_vars->nodes[i];\n \n-      if (var->symbol.alias && !var->symbol.analyzed)\n+      if (var->alias && !var->analyzed)\n \tany_aliases = true;\n-      else if (!var->symbol.alias)\n+      else if (!var->alias)\n \tvarpool_for_node_and_aliases (var, create_emultls_var, &ctor_body, true);\n     }\n "}, {"sha": "74f333b82690db90a72fbe52e67a021c21d743b8", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -1746,7 +1746,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t      /* We could also just rescale the frequency, but\n \t\t         doing so would introduce roundoff errors and make\n \t\t\t verifier unhappy.  */\n-\t\t      new_freq  = compute_call_stmt_bb_frequency (id->dst_node->symbol.decl,\n+\t\t      new_freq  = compute_call_stmt_bb_frequency (id->dst_node->decl,\n \t\t\t\t\t\t\t\t  copy_basic_block);\n \n \t\t      /* Speculative calls consist of two edges - direct and indirect.\n@@ -1771,7 +1771,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t\t\t\t\t\t       (old_edge->frequency + indirect->frequency)),\n \t\t\t\t\t\t\t CGRAPH_FREQ_MAX);\n \t\t\t    }\n-\t\t\t  ipa_clone_ref (ref, (symtab_node)id->dst_node, stmt);\n+\t\t\t  ipa_clone_ref (ref, id->dst_node, stmt);\n \t\t\t}\n \t\t      else\n \t\t\t{\n@@ -1816,7 +1816,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t      if ((!edge\n \t\t   || (edge->indirect_inlining_edge\n \t\t       && id->transform_call_graph_edges == CB_CGE_MOVE_CLONES))\n-\t\t  && id->dst_node->symbol.definition\n+\t\t  && id->dst_node->definition\n \t\t  && (fn = gimple_call_fndecl (stmt)) != NULL)\n \t\t{\n \t\t  struct cgraph_node *dest = cgraph_get_node (fn);\n@@ -1827,21 +1827,21 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t     producing dead clone (for further cloning).  In all\n \t\t     other cases we hit a bug (incorrect node sharing is the\n \t\t     most common reason for missing edges).  */\n-\t\t  gcc_assert (!dest->symbol.definition\n-\t\t\t      || dest->symbol.address_taken\n-\t\t  \t      || !id->src_node->symbol.definition\n-\t\t\t      || !id->dst_node->symbol.definition);\n+\t\t  gcc_assert (!dest->definition\n+\t\t\t      || dest->address_taken\n+\t\t  \t      || !id->src_node->definition\n+\t\t\t      || !id->dst_node->definition);\n \t\t  if (id->transform_call_graph_edges == CB_CGE_MOVE_CLONES)\n \t\t    cgraph_create_edge_including_clones\n \t\t      (id->dst_node, dest, orig_stmt, stmt, bb->count,\n-\t\t       compute_call_stmt_bb_frequency (id->dst_node->symbol.decl,\n+\t\t       compute_call_stmt_bb_frequency (id->dst_node->decl,\n \t\t       \t\t\t\t       copy_basic_block),\n \t\t       CIF_ORIGINALLY_INDIRECT_CALL);\n \t\t  else\n \t\t    cgraph_create_edge (id->dst_node, dest, stmt,\n \t\t\t\t\tbb->count,\n \t\t\t\t\tcompute_call_stmt_bb_frequency\n-\t\t\t\t\t  (id->dst_node->symbol.decl,\n+\t\t\t\t\t  (id->dst_node->decl,\n \t\t\t\t\t   copy_basic_block))->inline_failed\n \t\t      = CIF_ORIGINALLY_INDIRECT_CALL;\n \t\t  if (dump_file)\n@@ -3745,7 +3745,7 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n \n \t/* Do not special case builtins where we see the body.\n \t   This just confuse inliner.  */\n-\tif (!decl || !(node = cgraph_get_node (decl)) || node->symbol.definition)\n+\tif (!decl || !(node = cgraph_get_node (decl)) || node->definition)\n \t  ;\n \t/* For buitins that are likely expanded to nothing or\n \t   inlined do not account operand costs.  */\n@@ -4017,7 +4017,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n      If we cannot, then there is no hope of inlining the function.  */\n   if (cg_edge->indirect_unknown_callee)\n     goto egress;\n-  fn = cg_edge->callee->symbol.decl;\n+  fn = cg_edge->callee->decl;\n   gcc_checking_assert (fn);\n \n   /* If FN is a declaration of a function in a nested scope that was\n@@ -4077,21 +4077,21 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n \t}\n       goto egress;\n     }\n-  fn = cg_edge->callee->symbol.decl;\n+  fn = cg_edge->callee->decl;\n   cgraph_get_body (cg_edge->callee);\n \n #ifdef ENABLE_CHECKING\n-  if (cg_edge->callee->symbol.decl != id->dst_node->symbol.decl)\n+  if (cg_edge->callee->decl != id->dst_node->decl)\n     verify_cgraph_node (cg_edge->callee);\n #endif\n \n   /* We will be inlining this callee.  */\n   id->eh_lp_nr = lookup_stmt_eh_lp (stmt);\n \n   /* Update the callers EH personality.  */\n-  if (DECL_FUNCTION_PERSONALITY (cg_edge->callee->symbol.decl))\n-    DECL_FUNCTION_PERSONALITY (cg_edge->caller->symbol.decl)\n-      = DECL_FUNCTION_PERSONALITY (cg_edge->callee->symbol.decl);\n+  if (DECL_FUNCTION_PERSONALITY (cg_edge->callee->decl))\n+    DECL_FUNCTION_PERSONALITY (cg_edge->caller->decl)\n+      = DECL_FUNCTION_PERSONALITY (cg_edge->callee->decl);\n \n   /* Split the block holding the GIMPLE_CALL.  */\n   e = split_block (bb, stmt);\n@@ -4339,7 +4339,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n      variables in the function when the blocks get blown away as soon as we\n      remove the cgraph node.  */\n   if (gimple_block (stmt))\n-    (*debug_hooks->outlining_inline_function) (cg_edge->callee->symbol.decl);\n+    (*debug_hooks->outlining_inline_function) (cg_edge->callee->decl);\n \n   /* Update callgraph if needed.  */\n   cgraph_remove_node (cg_edge->callee);\n@@ -4491,7 +4491,7 @@ optimize_inline_calls (tree fn)\n   memset (&id, 0, sizeof (id));\n \n   id.src_node = id.dst_node = cgraph_get_node (fn);\n-  gcc_assert (id.dst_node->symbol.definition);\n+  gcc_assert (id.dst_node->definition);\n   id.dst_fn = fn;\n   /* Or any functions that aren't finished yet.  */\n   if (current_function_decl)\n@@ -5077,7 +5077,7 @@ delete_unreachable_blocks_update_callgraph (copy_body_data *id)\n \t      struct cgraph_edge *e;\n \t      struct cgraph_node *node;\n \n-\t      ipa_remove_stmt_references ((symtab_node)id->dst_node, gsi_stmt (bsi));\n+\t      ipa_remove_stmt_references (id->dst_node, gsi_stmt (bsi));\n \n \t      if (gimple_code (gsi_stmt (bsi)) == GIMPLE_CALL\n \t\t  &&(e = cgraph_edge (id->dst_node, gsi_stmt (bsi))) != NULL)\n@@ -5091,7 +5091,7 @@ delete_unreachable_blocks_update_callgraph (copy_body_data *id)\n \t\t  && id->dst_node->clones)\n \t\tfor (node = id->dst_node->clones; node != id->dst_node;)\n \t\t  {\n-\t\t    ipa_remove_stmt_references ((symtab_node)node, gsi_stmt (bsi));\n+\t\t    ipa_remove_stmt_references (node, gsi_stmt (bsi));\n \t\t    if (gimple_code (gsi_stmt (bsi)) == GIMPLE_CALL\n \t\t\t&& (e = cgraph_edge (node, gsi_stmt (bsi))) != NULL)\n \t\t      {\n@@ -5414,7 +5414,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   pointer_set_destroy (id.statements_to_fold);\n   fold_cond_expr_cond ();\n   delete_unreachable_blocks_update_callgraph (&id);\n-  if (id.dst_node->symbol.definition)\n+  if (id.dst_node->definition)\n     cgraph_rebuild_references ();\n   update_ssa (TODO_update_ssa);\n "}, {"sha": "dc63ef6902ebbfc017bdf9679681a886081b8e8c", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -701,11 +701,11 @@ check_for_nested_with_variably_modified (tree fndecl, tree orig_fndecl)\n \n   for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n     {\n-      for (arg = DECL_ARGUMENTS (cgn->symbol.decl); arg; arg = DECL_CHAIN (arg))\n+      for (arg = DECL_ARGUMENTS (cgn->decl); arg; arg = DECL_CHAIN (arg))\n \tif (variably_modified_type_p (TREE_TYPE (arg), orig_fndecl))\n \t  return true;\n \n-      if (check_for_nested_with_variably_modified (cgn->symbol.decl,\n+      if (check_for_nested_with_variably_modified (cgn->decl,\n \t\t\t\t\t\t   orig_fndecl))\n \treturn true;\n     }\n@@ -724,7 +724,7 @@ create_nesting_tree (struct cgraph_node *cgn)\n   info->var_map = pointer_map_create ();\n   info->mem_refs = pointer_set_create ();\n   info->suppress_expansion = BITMAP_ALLOC (&nesting_info_bitmap_obstack);\n-  info->context = cgn->symbol.decl;\n+  info->context = cgn->decl;\n \n   for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n     {\n@@ -2630,8 +2630,8 @@ static void\n gimplify_all_functions (struct cgraph_node *root)\n {\n   struct cgraph_node *iter;\n-  if (!gimple_body (root->symbol.decl))\n-    gimplify_function_tree (root->symbol.decl);\n+  if (!gimple_body (root->decl))\n+    gimplify_function_tree (root->decl);\n   for (iter = root->nested; iter; iter = iter->next_nested)\n     gimplify_all_functions (iter);\n }"}, {"sha": "9234706be6d2707e0beb5ed033942096120f5269", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -3390,7 +3390,7 @@ dump_function_header (FILE *dump_file, tree fdecl, int flags)\n     fprintf (dump_file, \", decl_uid=%d\", DECL_UID (fdecl));\n   if (node)\n     {\n-      fprintf (dump_file, \", symbol_order=%d)%s\\n\\n\", node->symbol.order,\n+      fprintf (dump_file, \", symbol_order=%d)%s\\n\\n\", node->order,\n                node->frequency == NODE_FREQUENCY_HOT\n                ? \" (hot)\"\n                : node->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED"}, {"sha": "e98ea686fbcce4be5d15f9c4943acf7327a50dd8", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -528,14 +528,14 @@ tree_profiling (void)\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n     {\n-      if (!gimple_has_body_p (node->symbol.decl))\n+      if (!gimple_has_body_p (node->decl))\n \tcontinue;\n \n       /* Don't profile functions produced for builtin stuff.  */\n-      if (DECL_SOURCE_LOCATION (node->symbol.decl) == BUILTINS_LOCATION)\n+      if (DECL_SOURCE_LOCATION (node->decl) == BUILTINS_LOCATION)\n \tcontinue;\n \n-      push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+      push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \n       /* Local pure-const may imply need to fixup the cfg.  */\n       if (execute_fixup_cfg () & TODO_cleanup_cfg)\n@@ -563,13 +563,13 @@ tree_profiling (void)\n   /* Drop pure/const flags from instrumented functions.  */\n   FOR_EACH_DEFINED_FUNCTION (node)\n     {\n-      if (!gimple_has_body_p (node->symbol.decl)\n+      if (!gimple_has_body_p (node->decl)\n \t  || !(!node->clone_of\n-\t  || node->symbol.decl != node->clone_of->symbol.decl))\n+\t  || node->decl != node->clone_of->decl))\n \tcontinue;\n \n       /* Don't profile functions produced for builtin stuff.  */\n-      if (DECL_SOURCE_LOCATION (node->symbol.decl) == BUILTINS_LOCATION)\n+      if (DECL_SOURCE_LOCATION (node->decl) == BUILTINS_LOCATION)\n \tcontinue;\n \n       cgraph_set_const_flag (node, false, false);\n@@ -581,16 +581,16 @@ tree_profiling (void)\n     {\n       basic_block bb;\n \n-      if (!gimple_has_body_p (node->symbol.decl)\n+      if (!gimple_has_body_p (node->decl)\n \t  || !(!node->clone_of\n-\t  || node->symbol.decl != node->clone_of->symbol.decl))\n+\t  || node->decl != node->clone_of->decl))\n \tcontinue;\n \n       /* Don't profile functions produced for builtin stuff.  */\n-      if (DECL_SOURCE_LOCATION (node->symbol.decl) == BUILTINS_LOCATION)\n+      if (DECL_SOURCE_LOCATION (node->decl) == BUILTINS_LOCATION)\n \tcontinue;\n \n-      push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+      push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \n       FOR_EACH_BB (bb)\n \t{"}, {"sha": "38da57700e2de7e1ea23f45434dbc5a6b8ce2711", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -4838,14 +4838,14 @@ convert_callers_for_node (struct cgraph_node *node,\n \n   for (cs = node->callers; cs; cs = cs->next_caller)\n     {\n-      push_cfun (DECL_STRUCT_FUNCTION (cs->caller->symbol.decl));\n+      push_cfun (DECL_STRUCT_FUNCTION (cs->caller->decl));\n \n       if (dump_file)\n \tfprintf (dump_file, \"Adjusting call %s/%i -> %s/%i\\n\",\n \t\t xstrdup (cgraph_node_name (cs->caller)),\n-\t\t cs->caller->symbol.order,\n+\t\t cs->caller->order,\n \t\t xstrdup (cgraph_node_name (cs->callee)),\n-\t\t cs->callee->symbol.order);\n+\t\t cs->callee->order);\n \n       ipa_modify_call_arguments (cs, cs->call_stmt, *adjustments);\n \n@@ -4854,7 +4854,7 @@ convert_callers_for_node (struct cgraph_node *node,\n \n   for (cs = node->callers; cs; cs = cs->next_caller)\n     if (bitmap_set_bit (recomputed_callers, cs->caller->uid)\n-\t&& gimple_in_ssa_p (DECL_STRUCT_FUNCTION (cs->caller->symbol.decl)))\n+\t&& gimple_in_ssa_p (DECL_STRUCT_FUNCTION (cs->caller->decl)))\n       compute_inline_parameters (cs->caller, true);\n   BITMAP_FREE (recomputed_callers);\n \n@@ -4890,7 +4890,7 @@ convert_callers (struct cgraph_node *node, tree old_decl,\n \t    {\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"Adjusting recursive call\");\n-\t      gimple_call_set_fndecl (stmt, node->symbol.decl);\n+\t      gimple_call_set_fndecl (stmt, node->decl);\n \t      ipa_modify_call_arguments (NULL, stmt, adjustments);\n \t    }\n \t}\n@@ -4918,11 +4918,11 @@ modify_function (struct cgraph_node *node, ipa_parm_adjustment_vec adjustments)\n \t\t\t\t\t NULL, false, NULL, NULL, \"isra\");\n   redirect_callers.release ();\n \n-  push_cfun (DECL_STRUCT_FUNCTION (new_node->symbol.decl));\n+  push_cfun (DECL_STRUCT_FUNCTION (new_node->decl));\n   ipa_modify_formal_parameters (current_function_decl, adjustments, \"ISRA\");\n   cfg_changed = ipa_sra_modify_function_body (adjustments);\n   sra_ipa_reset_debug_stmts (adjustments);\n-  convert_callers (new_node, node->symbol.decl, adjustments);\n+  convert_callers (new_node, node->decl, adjustments);\n   cgraph_make_node_local (new_node);\n   return cfg_changed;\n }\n@@ -4958,7 +4958,7 @@ ipa_sra_preliminary_function_checks (struct cgraph_node *node)\n       return false;\n     }\n \n-  if (!tree_versionable_function_p (node->symbol.decl))\n+  if (!tree_versionable_function_p (node->decl))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Function is not versionable.\\n\");\n@@ -4972,7 +4972,7 @@ ipa_sra_preliminary_function_checks (struct cgraph_node *node)\n       return false;\n     }\n \n-  if ((DECL_COMDAT (node->symbol.decl) || DECL_EXTERNAL (node->symbol.decl))\n+  if ((DECL_COMDAT (node->decl) || DECL_EXTERNAL (node->decl))\n       && inline_summary (node)->size >= MAX_INLINE_INSNS_AUTO)\n     {\n       if (dump_file)\n@@ -4995,7 +4995,7 @@ ipa_sra_preliminary_function_checks (struct cgraph_node *node)\n       return false;\n     }\n \n-  if (TYPE_ATTRIBUTES (TREE_TYPE (node->symbol.decl)))\n+  if (TYPE_ATTRIBUTES (TREE_TYPE (node->decl)))\n     return false;\n \n   return true;"}, {"sha": "6f3a4cee29f2fcd7101c1afb5debefdc93aea002", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -2877,10 +2877,10 @@ get_constraint_for_ssa_var (tree t, vec<ce_s> *results, bool address_p)\n       && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n     {\n       struct varpool_node *node = varpool_get_node (t);\n-      if (node && node->symbol.alias && node->symbol.analyzed)\n+      if (node && node->alias && node->analyzed)\n \t{\n \t  node = varpool_variable_node (node, NULL);\n-\t  t = node->symbol.decl;\n+\t  t = node->decl;\n \t}\n     }\n \n@@ -5754,7 +5754,7 @@ create_variable_info_for (tree decl, const char *name)\n \t  /* If this is a global variable with an initializer and we are in\n \t     IPA mode generate constraints for it.  */\n \t  if (DECL_INITIAL (decl)\n-\t      && vnode->symbol.definition)\n+\t      && vnode->definition)\n \t    {\n \t      vec<ce_s> rhsc = vNULL;\n \t      struct constraint_expr lhs, *rhsp;\n@@ -7060,9 +7060,9 @@ struct pt_solution ipa_escaped_pt\n static bool\n associate_varinfo_to_alias (struct cgraph_node *node, void *data)\n {\n-  if ((node->symbol.alias || node->thunk.thunk_p)\n-      && node->symbol.analyzed)\n-    insert_vi_for_tree (node->symbol.decl, (varinfo_t)data);\n+  if ((node->alias || node->thunk.thunk_p)\n+      && node->analyzed)\n+    insert_vi_for_tree (node->decl, (varinfo_t)data);\n   return false;\n }\n \n@@ -7097,18 +7097,18 @@ ipa_pta_execute (void)\n \n       gcc_assert (!node->clone_of);\n \n-      vi = create_function_info_for (node->symbol.decl,\n-\t\t\t             alias_get_name (node->symbol.decl));\n+      vi = create_function_info_for (node->decl,\n+\t\t\t             alias_get_name (node->decl));\n       cgraph_for_node_and_aliases (node, associate_varinfo_to_alias, vi, true);\n     }\n \n   /* Create constraints for global variables and their initializers.  */\n   FOR_EACH_VARIABLE (var)\n     {\n-      if (var->symbol.alias && var->symbol.analyzed)\n+      if (var->alias && var->analyzed)\n \tcontinue;\n \n-      get_vi_for_tree (var->symbol.decl);\n+      get_vi_for_tree (var->decl);\n     }\n \n   if (dump_file)\n@@ -7133,32 +7133,32 @@ ipa_pta_execute (void)\n \t{\n \t  fprintf (dump_file,\n \t\t   \"Generating constraints for %s\", cgraph_node_name (node));\n-\t  if (DECL_ASSEMBLER_NAME_SET_P (node->symbol.decl))\n+\t  if (DECL_ASSEMBLER_NAME_SET_P (node->decl))\n \t    fprintf (dump_file, \" (%s)\",\n \t\t     IDENTIFIER_POINTER\n-\t\t       (DECL_ASSEMBLER_NAME (node->symbol.decl)));\n+\t\t       (DECL_ASSEMBLER_NAME (node->decl)));\n \t  fprintf (dump_file, \"\\n\");\n \t}\n \n-      func = DECL_STRUCT_FUNCTION (node->symbol.decl);\n+      func = DECL_STRUCT_FUNCTION (node->decl);\n       push_cfun (func);\n \n       /* For externally visible or attribute used annotated functions use\n \t local constraints for their arguments.\n \t For local functions we see all callers and thus do not need initial\n \t constraints for parameters.  */\n-      if (node->symbol.used_from_other_partition\n-\t  || node->symbol.externally_visible\n-\t  || node->symbol.force_output)\n+      if (node->used_from_other_partition\n+\t  || node->externally_visible\n+\t  || node->force_output)\n \t{\n \t  intra_create_variable_infos ();\n \n \t  /* We also need to make function return values escape.  Nothing\n \t     escapes by returning from main though.  */\n-\t  if (!MAIN_NAME_P (DECL_NAME (node->symbol.decl)))\n+\t  if (!MAIN_NAME_P (DECL_NAME (node->decl)))\n \t    {\n \t      varinfo_t fi, rvi;\n-\t      fi = lookup_vi_for_tree (node->symbol.decl);\n+\t      fi = lookup_vi_for_tree (node->decl);\n \t      rvi = first_vi_for_offset (fi, fi_result);\n \t      if (rvi && rvi->offset == fi_result)\n \t\t{\n@@ -7238,7 +7238,7 @@ ipa_pta_execute (void)\n       if (!cgraph_function_with_gimple_body_p (node) || node->clone_of)\n \tcontinue;\n \n-      fn = DECL_STRUCT_FUNCTION (node->symbol.decl);\n+      fn = DECL_STRUCT_FUNCTION (node->decl);\n \n       /* Compute the points-to sets for pointer SSA_NAMEs.  */\n       FOR_EACH_VEC_ELT (*fn->gimple_df->ssa_names, i, ptr)\n@@ -7249,7 +7249,7 @@ ipa_pta_execute (void)\n \t}\n \n       /* Compute the call-use and call-clobber sets for all direct calls.  */\n-      fi = lookup_vi_for_tree (node->symbol.decl);\n+      fi = lookup_vi_for_tree (node->decl);\n       gcc_assert (fi->is_fn_info);\n       clobbers\n \t= find_what_var_points_to (first_vi_for_offset (fi, fi_clobbers));"}, {"sha": "8e3190fa2c16f3eb5fac6c826af099fcbee3370b", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -552,7 +552,7 @@ increase_alignment (void)\n   /* Increase the alignment of all global arrays for vectorization.  */\n   FOR_EACH_DEFINED_VARIABLE (vnode)\n     {\n-      tree vectype, decl = vnode->symbol.decl;\n+      tree vectype, decl = vnode->decl;\n       tree t;\n       unsigned int alignment;\n "}, {"sha": "ecefee1f8b8f99594875b4b91a4fe0b7d89c97e2", "filename": "gcc/tree.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -5009,7 +5009,7 @@ free_lang_data_in_decl (tree decl)\n     {\n       struct cgraph_node *node;\n       if (!(node = cgraph_get_node (decl))\n-\t  || (!node->symbol.definition && !node->clones))\n+\t  || (!node->definition && !node->clones))\n \t{\n \t  if (node)\n \t    cgraph_release_function_body (node);\n@@ -5423,14 +5423,14 @@ find_decls_types_in_node (struct cgraph_node *n, struct free_lang_data_d *fld)\n   unsigned ix;\n   tree t;\n \n-  find_decls_types (n->symbol.decl, fld);\n+  find_decls_types (n->decl, fld);\n \n-  if (!gimple_has_body_p (n->symbol.decl))\n+  if (!gimple_has_body_p (n->decl))\n     return;\n \n   gcc_assert (current_function_decl == NULL_TREE && cfun == NULL);\n \n-  fn = DECL_STRUCT_FUNCTION (n->symbol.decl);\n+  fn = DECL_STRUCT_FUNCTION (n->decl);\n \n   /* Traverse locals. */\n   FOR_EACH_LOCAL_DECL (fn, ix, t)\n@@ -5486,7 +5486,7 @@ find_decls_types_in_node (struct cgraph_node *n, struct free_lang_data_d *fld)\n static void\n find_decls_types_in_var (struct varpool_node *v, struct free_lang_data_d *fld)\n {\n-  find_decls_types (v->symbol.decl, fld);\n+  find_decls_types (v->decl, fld);\n }\n \n /* If T needs an assembler name, have one created for it.  */"}, {"sha": "7be54ce4a8e37c6b0fb3fdeebd00da831099621f", "filename": "gcc/value-prof.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -1208,9 +1208,9 @@ init_node_map (bool local)\n \t\t\t   \" with nodes %s/%i %s/%i\\n\",\n \t\t\t   n->profile_id,\n \t\t\t   cgraph_node_name (n),\n-\t\t\t   n->symbol.order,\n+\t\t\t   n->order,\n \t\t\t   symtab_node_name (*(symtab_node*)val),\n-\t\t\t   (*(symtab_node *)val)->symbol.order);\n+\t\t\t   (*(symtab_node *)val)->order);\n \t\tn->profile_id = (n->profile_id + 1) & 0x7fffffff;\n \t      }\n \t  }\n@@ -1221,7 +1221,7 @@ init_node_map (bool local)\n \t\t       \"Node %s/%i has no profile-id\"\n \t\t       \" (profile feedback missing?)\\n\",\n \t\t       cgraph_node_name (n),\n-\t\t       n->symbol.order);\n+\t\t       n->order);\n \t    continue;\n \t  }\n \telse if ((val = pointer_map_contains (cgraph_node_map,\n@@ -1232,7 +1232,7 @@ init_node_map (bool local)\n \t\t       \"Node %s/%i has IP profile-id %i conflict. \"\n \t\t       \"Giving up.\\n\",\n \t\t       cgraph_node_name (n),\n-\t\t       n->symbol.order,\n+\t\t       n->order,\n \t\t       n->profile_id);\n \t    *val = NULL;\n \t    continue;\n@@ -1273,7 +1273,7 @@ static bool\n check_ic_target (gimple call_stmt, struct cgraph_node *target)\n {\n    location_t locus;\n-   if (gimple_check_call_matching_types (call_stmt, target->symbol.decl, true))\n+   if (gimple_check_call_matching_types (call_stmt, target->decl, true))\n      return true;\n \n    locus =  gimple_location (call_stmt);\n@@ -1316,7 +1316,7 @@ gimple_ic (gimple icall_stmt, struct cgraph_node *direct_call,\n   load_stmt = gimple_build_assign (tmp0, tmp);\n   gsi_insert_before (&gsi, load_stmt, GSI_SAME_STMT);\n \n-  tmp = fold_convert (optype, build_addr (direct_call->symbol.decl,\n+  tmp = fold_convert (optype, build_addr (direct_call->decl,\n \t\t\t\t\t  current_function_decl));\n   load_stmt = gimple_build_assign (tmp1, tmp);\n   gsi_insert_before (&gsi, load_stmt, GSI_SAME_STMT);\n@@ -1328,8 +1328,8 @@ gimple_ic (gimple icall_stmt, struct cgraph_node *direct_call,\n   gimple_set_vuse (icall_stmt, NULL_TREE);\n   update_stmt (icall_stmt);\n   dcall_stmt = gimple_copy (icall_stmt);\n-  gimple_call_set_fndecl (dcall_stmt, direct_call->symbol.decl);\n-  dflags = flags_from_decl_or_type (direct_call->symbol.decl);\n+  gimple_call_set_fndecl (dcall_stmt, direct_call->decl);\n+  dflags = flags_from_decl_or_type (direct_call->decl);\n   if ((dflags & ECF_NORETURN) != 0)\n     gimple_call_set_lhs (dcall_stmt, NULL_TREE);\n   gsi_insert_before (&gsi, dcall_stmt, GSI_SAME_STMT);\n@@ -1494,7 +1494,7 @@ gimple_ic_transform (gimple_stmt_iterator *gsi)\n \t  fprintf (dump_file, \"Indirect call -> direct call \");\n \t  print_generic_expr (dump_file, gimple_call_fn (stmt), TDF_SLIM);\n \t  fprintf (dump_file, \"=> \");\n-\t  print_generic_expr (dump_file, direct_call->symbol.decl, TDF_SLIM);\n+\t  print_generic_expr (dump_file, direct_call->decl, TDF_SLIM);\n \t  fprintf (dump_file, \" transformation skipped because of type mismatch\");\n \t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n \t}\n@@ -1507,7 +1507,7 @@ gimple_ic_transform (gimple_stmt_iterator *gsi)\n       fprintf (dump_file, \"Indirect call -> direct call \");\n       print_generic_expr (dump_file, gimple_call_fn (stmt), TDF_SLIM);\n       fprintf (dump_file, \"=> \");\n-      print_generic_expr (dump_file, direct_call->symbol.decl, TDF_SLIM);\n+      print_generic_expr (dump_file, direct_call->decl, TDF_SLIM);\n       fprintf (dump_file, \" transformation on insn postponned to ipa-profile\");\n       print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n       fprintf (dump_file, \"hist->count \"HOST_WIDEST_INT_PRINT_DEC"}, {"sha": "099992e8405603764fe279ddc517594e38a88323", "filename": "gcc/varasm.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -2357,15 +2357,15 @@ mark_decl_referenced (tree decl)\n \t definition.  */\n       struct cgraph_node *node = cgraph_get_create_node (decl);\n       if (!DECL_EXTERNAL (decl)\n-\t  && !node->symbol.definition)\n+\t  && !node->definition)\n \tcgraph_mark_force_output_node (node);\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n     {\n       struct varpool_node *node = varpool_node_for_decl (decl);\n       /* C++ frontend use mark_decl_references to force COMDAT variables\n          to be output that might appear dead otherwise.  */\n-      node->symbol.force_output = true;\n+      node->force_output = true;\n     }\n   /* else do nothing - we can get various sorts of CST nodes here,\n      which do not need to be marked.  */\n@@ -5384,7 +5384,7 @@ find_decl (tree target)\n {\n   symtab_node node = symtab_node_for_asm (target);\n   if (node)\n-    return node->symbol.decl;\n+    return node->decl;\n   return NULL_TREE;\n }\n \n@@ -5669,9 +5669,9 @@ assemble_alias (tree decl, tree target)\n \n   /* Allow aliases to aliases.  */\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n-    cgraph_get_create_node (decl)->symbol.alias = true;\n+    cgraph_get_create_node (decl)->alias = true;\n   else\n-    varpool_node_for_decl (decl)->symbol.alias = true;\n+    varpool_node_for_decl (decl)->alias = true;\n \n   /* If the target has already been emitted, we don't have to queue the\n      alias.  This saves a tad of memory.  */\n@@ -5774,12 +5774,12 @@ dump_tm_clone_pairs (vec<tm_alias_pair> tm_alias_pairs)\n \t TM_GETTMCLONE.  If neither of these are true, we didn't generate\n \t a clone, and we didn't call it indirectly... no sense keeping it\n \t in the clone table.  */\n-      if (!dst_n || !dst_n->symbol.definition)\n+      if (!dst_n || !dst_n->definition)\n \tcontinue;\n \n       /* This covers the case where we have optimized the original\n \t function away, and only access the transactional clone.  */\n-      if (!src_n || !src_n->symbol.definition)\n+      if (!src_n || !src_n->definition)\n \tcontinue;\n \n       if (!switched)\n@@ -6724,20 +6724,20 @@ default_binds_local_p_1 (const_tree exp, int shlib)\n       && (TREE_STATIC (exp) || DECL_EXTERNAL (exp)))\n     {\n       struct varpool_node *vnode = varpool_get_node (exp);\n-      if (vnode && resolution_local_p (vnode->symbol.resolution))\n+      if (vnode && resolution_local_p (vnode->resolution))\n \tresolved_locally = true;\n       if (vnode\n-\t  && resolution_to_local_definition_p (vnode->symbol.resolution))\n+\t  && resolution_to_local_definition_p (vnode->resolution))\n \tresolved_to_local_def = true;\n     }\n   else if (TREE_CODE (exp) == FUNCTION_DECL && TREE_PUBLIC (exp))\n     {\n       struct cgraph_node *node = cgraph_get_node (exp);\n       if (node\n-\t  && resolution_local_p (node->symbol.resolution))\n+\t  && resolution_local_p (node->resolution))\n \tresolved_locally = true;\n       if (node\n-\t  && resolution_to_local_definition_p (node->symbol.resolution))\n+\t  && resolution_to_local_definition_p (node->resolution))\n \tresolved_to_local_def = true;\n     }\n \n@@ -6818,15 +6818,15 @@ decl_binds_to_current_def_p (tree decl)\n     {\n       struct varpool_node *vnode = varpool_get_node (decl);\n       if (vnode\n-\t  && vnode->symbol.resolution != LDPR_UNKNOWN)\n-\treturn resolution_to_local_definition_p (vnode->symbol.resolution);\n+\t  && vnode->resolution != LDPR_UNKNOWN)\n+\treturn resolution_to_local_definition_p (vnode->resolution);\n     }\n   else if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       struct cgraph_node *node = cgraph_get_node (decl);\n       if (node\n-\t  && node->symbol.resolution != LDPR_UNKNOWN)\n-\treturn resolution_to_local_definition_p (node->symbol.resolution);\n+\t  && node->resolution != LDPR_UNKNOWN)\n+\treturn resolution_to_local_definition_p (node->resolution);\n     }\n   /* Otherwise we have to assume the worst for DECL_WEAK (hidden weaks\n      binds locally but still can be overwritten), DECL_COMMON (can be merged"}, {"sha": "2db666ac80f7eb3136c5e1c3056e48264455fd05", "filename": "gcc/varpool.c", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67348ccc9ca5c667400851fa252a0e542847cb66/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=67348ccc9ca5c667400851fa252a0e542847cb66", "patch": "@@ -135,7 +135,7 @@ struct varpool_node *\n varpool_create_empty_node (void)\n {   \n   struct varpool_node *node = ggc_alloc_cleared_varpool_node ();\n-  node->symbol.type = SYMTAB_VARIABLE;\n+  node->type = SYMTAB_VARIABLE;\n   return node;\n }   \n \n@@ -149,8 +149,8 @@ varpool_node_for_decl (tree decl)\n     return node;\n \n   node = varpool_create_empty_node ();\n-  node->symbol.decl = decl;\n-  symtab_register_node ((symtab_node)node);\n+  node->decl = decl;\n+  symtab_register_node (node);\n   return node;\n }\n \n@@ -160,53 +160,53 @@ varpool_remove_node (struct varpool_node *node)\n {\n   tree init;\n   varpool_call_node_removal_hooks (node);\n-  symtab_unregister_node ((symtab_node)node);\n+  symtab_unregister_node (node);\n \n   /* Because we remove references from external functions before final compilation,\n      we may end up removing useful constructors.\n      FIXME: We probably want to trace boundaries better.  */\n-  if ((init = ctor_for_folding (node->symbol.decl)) == error_mark_node)\n+  if ((init = ctor_for_folding (node->decl)) == error_mark_node)\n     varpool_remove_initializer (node);\n   else\n-    DECL_INITIAL (node->symbol.decl) = init;\n+    DECL_INITIAL (node->decl) = init;\n   ggc_free (node);\n }\n \n /* Renove node initializer when it is no longer needed.  */\n void\n varpool_remove_initializer (struct varpool_node *node)\n {\n-  if (DECL_INITIAL (node->symbol.decl)\n-      && !DECL_IN_CONSTANT_POOL (node->symbol.decl)\n+  if (DECL_INITIAL (node->decl)\n+      && !DECL_IN_CONSTANT_POOL (node->decl)\n       /* Keep vtables for BINFO folding.  */\n-      && !DECL_VIRTUAL_P (node->symbol.decl)\n+      && !DECL_VIRTUAL_P (node->decl)\n       /* FIXME: http://gcc.gnu.org/PR55395 */\n       && debug_info_level == DINFO_LEVEL_NONE\n       /* When doing declaration merging we have duplicate\n \t entries for given decl.  Do not attempt to remove\n \t the boides, or we will end up remiving\n \t wrong one.  */\n       && cgraph_state != CGRAPH_LTO_STREAMING)\n-    DECL_INITIAL (node->symbol.decl) = error_mark_node;\n+    DECL_INITIAL (node->decl) = error_mark_node;\n }\n \n /* Dump given cgraph node.  */\n void\n dump_varpool_node (FILE *f, struct varpool_node *node)\n {\n-  dump_symtab_base (f, (symtab_node)node);\n+  dump_symtab_base (f, node);\n   fprintf (f, \"  Availability: %s\\n\",\n \t   cgraph_function_flags_ready\n \t   ? cgraph_availability_names[cgraph_variable_initializer_availability (node)]\n \t   : \"not-ready\");\n   fprintf (f, \"  Varpool flags:\");\n-  if (DECL_INITIAL (node->symbol.decl))\n+  if (DECL_INITIAL (node->decl))\n     fprintf (f, \" initialized\");\n   if (node->output)\n     fprintf (f, \" output\");\n-  if (TREE_READONLY (node->symbol.decl))\n+  if (TREE_READONLY (node->decl))\n     fprintf (f, \" read-only\");\n-  if (ctor_for_folding (node->symbol.decl) != error_mark_node)\n+  if (ctor_for_folding (node->decl) != error_mark_node)\n     fprintf (f, \" const-value-known\");\n   fprintf (f, \"\\n\");\n }\n@@ -275,7 +275,7 @@ ctor_for_folding (tree decl)\n   if (node)\n     {\n       real_node = varpool_variable_node (node);\n-      real_decl = real_node->symbol.decl;\n+      real_decl = real_node->decl;\n     }\n   else\n     real_decl = decl;\n@@ -292,7 +292,7 @@ ctor_for_folding (tree decl)\n       if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl)))\n \t{\n \t  node = varpool_alias_target (node);\n-\t  decl = node->symbol.decl;\n+\t  decl = node->decl;\n \t}\n     }\n \n@@ -342,7 +342,7 @@ varpool_add_new_variable (tree decl)\n   node = varpool_node_for_decl (decl);\n   varpool_call_variable_insertion_hooks (node);\n   if (varpool_externally_visible_p (node))\n-    node->symbol.externally_visible = true;\n+    node->externally_visible = true;\n }\n \n /* Return variable availability.  See cgraph.h for description of individual\n@@ -351,14 +351,14 @@ enum availability\n cgraph_variable_initializer_availability (struct varpool_node *node)\n {\n   gcc_assert (cgraph_function_flags_ready);\n-  if (!node->symbol.definition)\n+  if (!node->definition)\n     return AVAIL_NOT_AVAILABLE;\n-  if (!TREE_PUBLIC (node->symbol.decl))\n+  if (!TREE_PUBLIC (node->decl))\n     return AVAIL_AVAILABLE;\n-  if (DECL_IN_CONSTANT_POOL (node->symbol.decl)\n-      || DECL_VIRTUAL_P (node->symbol.decl))\n+  if (DECL_IN_CONSTANT_POOL (node->decl)\n+      || DECL_VIRTUAL_P (node->decl))\n     return AVAIL_AVAILABLE;\n-  if (node->symbol.alias && node->symbol.weakref)\n+  if (node->alias && node->weakref)\n     {\n       enum availability avail;\n \n@@ -369,33 +369,33 @@ cgraph_variable_initializer_availability (struct varpool_node *node)\n   /* If the variable can be overwritten, return OVERWRITABLE.  Takes\n      care of at least one notable extension - the COMDAT variables\n      used to share template instantiations in C++.  */\n-  if (decl_replaceable_p (node->symbol.decl)\n-      || DECL_EXTERNAL (node->symbol.decl))\n+  if (decl_replaceable_p (node->decl)\n+      || DECL_EXTERNAL (node->decl))\n     return AVAIL_OVERWRITABLE;\n   return AVAIL_AVAILABLE;\n }\n \n void\n varpool_analyze_node (struct varpool_node *node)\n {\n-  tree decl = node->symbol.decl;\n+  tree decl = node->decl;\n \n   /* When reading back varpool at LTO time, we re-construct the queue in order\n      to have \"needed\" list right by inserting all needed nodes into varpool.\n      We however don't want to re-analyze already analyzed nodes.  */\n-  if (!node->symbol.analyzed)\n+  if (!node->analyzed)\n     {\n       gcc_assert (!in_lto_p || cgraph_function_flags_ready);\n       /* Compute the alignment early so function body expanders are\n \t already informed about increased alignment.  */\n       align_variable (decl, 0);\n     }\n-  if (node->symbol.alias)\n+  if (node->alias)\n     symtab_resolve_alias\n-       ((symtab_node) node, (symtab_node) varpool_get_node (node->symbol.alias_target));\n+       (node, varpool_get_node (node->alias_target));\n   else if (DECL_INITIAL (decl))\n-    record_references_in_initializer (decl, node->symbol.analyzed);\n-  node->symbol.analyzed = true;\n+    record_references_in_initializer (decl, node->analyzed);\n+  node->analyzed = true;\n }\n \n /* Assemble thunks and aliases associated to NODE.  */\n@@ -405,12 +405,12 @@ assemble_aliases (struct varpool_node *node)\n {\n   int i;\n   struct ipa_ref *ref;\n-  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list, i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n \tstruct varpool_node *alias = ipa_ref_referring_varpool_node (ref);\n-\tdo_assemble_alias (alias->symbol.decl,\n-\t\t\t   DECL_ASSEMBLER_NAME (node->symbol.decl));\n+\tdo_assemble_alias (alias->decl,\n+\t\t\t   DECL_ASSEMBLER_NAME (node->decl));\n \tassemble_aliases (alias);\n       }\n }\n@@ -420,11 +420,11 @@ assemble_aliases (struct varpool_node *node)\n bool\n varpool_assemble_decl (struct varpool_node *node)\n {\n-  tree decl = node->symbol.decl;\n+  tree decl = node->decl;\n \n   /* Aliases are outout when their target is produced or by\n      output_weakrefs.  */\n-  if (node->symbol.alias)\n+  if (node->alias)\n     return false;\n \n   /* Constant pool is output from RTL land when the reference\n@@ -448,12 +448,12 @@ varpool_assemble_decl (struct varpool_node *node)\n \t\t       && TREE_CODE (decl) == VAR_DECL\n \t\t       && !DECL_HAS_VALUE_EXPR_P (decl));\n \n-  if (!node->symbol.in_other_partition\n+  if (!node->in_other_partition\n       && !DECL_EXTERNAL (decl))\n     {\n       assemble_variable (decl, 0, 1, 0);\n       gcc_assert (TREE_ASM_WRITTEN (decl));\n-      node->symbol.definition = true;\n+      node->definition = true;\n       assemble_aliases (node);\n       return true;\n     }\n@@ -467,10 +467,10 @@ varpool_assemble_decl (struct varpool_node *node)\n static void\n enqueue_node (struct varpool_node *node, struct varpool_node **first)\n {\n-  if (node->symbol.aux)\n+  if (node->aux)\n     return;\n   gcc_checking_assert (*first);\n-  node->symbol.aux = *first;\n+  node->aux = *first;\n   *first = node;\n }\n \n@@ -494,11 +494,11 @@ varpool_remove_unreferenced_decls (void)\n     fprintf (cgraph_dump_file, \"Trivially needed variables:\");\n   FOR_EACH_DEFINED_VARIABLE (node)\n     {\n-      if (node->symbol.analyzed\n+      if (node->analyzed\n \t  && (!varpool_can_remove_if_no_refs (node)\n \t      /* We just expanded all function bodies.  See if any of\n \t\t them needed the variable.  */\n-\t      || DECL_RTL_SET_P (node->symbol.decl)))\n+\t      || DECL_RTL_SET_P (node->decl)))\n \t{\n \t  enqueue_node (node, &first);\n           if (cgraph_dump_file)\n@@ -508,27 +508,27 @@ varpool_remove_unreferenced_decls (void)\n   while (first != (struct varpool_node *)(void *)1)\n     {\n       node = first;\n-      first = (struct varpool_node *)first->symbol.aux;\n+      first = (struct varpool_node *)first->aux;\n \n-      if (node->symbol.same_comdat_group)\n+      if (node->same_comdat_group)\n \t{\n \t  symtab_node next;\n-\t  for (next = node->symbol.same_comdat_group;\n-\t       next != (symtab_node)node;\n-\t       next = next->symbol.same_comdat_group)\n+\t  for (next = node->same_comdat_group;\n+\t       next != node;\n+\t       next = next->same_comdat_group)\n \t    {\n \t      varpool_node *vnext = dyn_cast <varpool_node> (next);\n-\t      if (vnext && vnext->symbol.analyzed)\n+\t      if (vnext && vnext->analyzed)\n \t\tenqueue_node (vnext, &first);\n \t    }\n \t}\n-      for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list, i, ref); i++)\n+      for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref); i++)\n \t{\n \t  varpool_node *vnode = dyn_cast <varpool_node> (ref->referred);\n \t  if (vnode\n-\t      && (!DECL_EXTERNAL (ref->referred->symbol.decl)\n-\t\t  || vnode->symbol.alias)\n-\t      && vnode->symbol.analyzed)\n+\t      && (!DECL_EXTERNAL (ref->referred->decl)\n+\t\t  || vnode->alias)\n+\t      && vnode->analyzed)\n \t    enqueue_node (vnode, &first);\n \t}\n     }\n@@ -537,7 +537,7 @@ varpool_remove_unreferenced_decls (void)\n   for (node = varpool_first_defined_variable (); node; node = next)\n     {\n       next = varpool_next_defined_variable (node);\n-      if (!node->symbol.aux)\n+      if (!node->aux)\n \t{\n           if (cgraph_dump_file)\n \t    fprintf (cgraph_dump_file, \" %s\", varpool_node_asm_name (node));\n@@ -555,14 +555,14 @@ varpool_remove_unreferenced_decls (void)\n void\n varpool_finalize_named_section_flags (struct varpool_node *node)\n {\n-  if (!TREE_ASM_WRITTEN (node->symbol.decl)\n-      && !node->symbol.alias\n-      && !node->symbol.in_other_partition\n-      && !DECL_EXTERNAL (node->symbol.decl)\n-      && TREE_CODE (node->symbol.decl) == VAR_DECL\n-      && !DECL_HAS_VALUE_EXPR_P (node->symbol.decl)\n-      && DECL_SECTION_NAME (node->symbol.decl))\n-    get_variable_section (node->symbol.decl, false);\n+  if (!TREE_ASM_WRITTEN (node->decl)\n+      && !node->alias\n+      && !node->in_other_partition\n+      && !DECL_EXTERNAL (node->decl)\n+      && TREE_CODE (node->decl) == VAR_DECL\n+      && !DECL_HAS_VALUE_EXPR_P (node->decl)\n+      && DECL_SECTION_NAME (node->decl))\n+    get_variable_section (node->decl, false);\n }\n \n /* Output all variables enqueued to be assembled.  */\n@@ -607,7 +607,7 @@ add_new_static_var (tree type)\n   new_node = varpool_node_for_decl (new_decl);\n   varpool_finalize_decl (new_decl);\n \n-  return new_node->symbol.decl;\n+  return new_node->decl;\n }\n \n /* Attempt to mark ALIAS as an alias to DECL.  Return TRUE if successful.\n@@ -621,11 +621,11 @@ varpool_create_variable_alias (tree alias, tree decl)\n   gcc_assert (TREE_CODE (decl) == VAR_DECL);\n   gcc_assert (TREE_CODE (alias) == VAR_DECL);\n   alias_node = varpool_node_for_decl (alias);\n-  alias_node->symbol.alias = true;\n-  alias_node->symbol.definition = true;\n-  alias_node->symbol.alias_target = decl;\n+  alias_node->alias = true;\n+  alias_node->definition = true;\n+  alias_node->alias_target = decl;\n   if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (alias)) != NULL)\n-    alias_node->symbol.weakref = true;\n+    alias_node->weakref = true;\n   return alias_node;\n }\n \n@@ -642,15 +642,15 @@ varpool_extra_name_alias (tree alias, tree decl)\n   return NULL;\n #endif\n   alias_node = varpool_create_variable_alias (alias, decl);\n-  alias_node->symbol.cpp_implicit_alias = true;\n+  alias_node->cpp_implicit_alias = true;\n \n   /* Extra name alias mechanizm creates aliases really late\n      via DECL_ASSEMBLER_NAME mechanizm.\n      This is unfortunate because they are not going through the\n      standard channels.  Ensure they get output.  */\n   if (cpp_implicit_aliases_done)\n-    symtab_resolve_alias ((symtab_node)alias_node,\n-\t\t\t  (symtab_node)varpool_node_for_decl (decl));\n+    symtab_resolve_alias (alias_node,\n+\t\t\t  varpool_node_for_decl (decl));\n   return alias_node;\n }\n \n@@ -669,7 +669,7 @@ varpool_for_node_and_aliases (struct varpool_node *node,\n \n   if (callback (node, data))\n     return true;\n-  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list, i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n \tstruct varpool_node *alias = ipa_ref_referring_varpool_node (ref);"}]}