{"sha": "45a6c1e36347998df5e779866f26d15dc9d01fbd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVhNmMxZTM2MzQ3OTk4ZGY1ZTc3OTg2NmYyNmQxNWRjOWQwMWZiZA==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2016-11-02T13:56:07Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2016-11-02T13:56:07Z"}, "message": "The add expander still contains some expansion code that was required for the previous prolog/epilog code...\n\nThe add expander still contains some expansion code that was required for the\nprevious prolog/epilog code, but which is no longer needed.  I also noticed\nthat the current version splits off immediates from frame addressing\ninstructions, which doesn't seem a good idea.  Avoiding this resulted in small\ncodesize improvements.\n\n    gcc/\n        * config/aarch64/aarch64.md (add<mode>3): Remove\n        redundant code.  Don't split frame based additions.\n\nFrom-SVN: r241790", "tree": {"sha": "eb8e76986eee365abe7bd9265d665197d978fd09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb8e76986eee365abe7bd9265d665197d978fd09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45a6c1e36347998df5e779866f26d15dc9d01fbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45a6c1e36347998df5e779866f26d15dc9d01fbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45a6c1e36347998df5e779866f26d15dc9d01fbd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45a6c1e36347998df5e779866f26d15dc9d01fbd/comments", "author": null, "committer": null, "parents": [{"sha": "b5926e23e4721298fa9b81148cab86ee3042ea95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5926e23e4721298fa9b81148cab86ee3042ea95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5926e23e4721298fa9b81148cab86ee3042ea95"}], "stats": {"total": 30, "additions": 11, "deletions": 19}, "files": [{"sha": "6221150228d5cb53abe36c7e4007fcf655b3064b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a6c1e36347998df5e779866f26d15dc9d01fbd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a6c1e36347998df5e779866f26d15dc9d01fbd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=45a6c1e36347998df5e779866f26d15dc9d01fbd", "patch": "@@ -1,3 +1,8 @@\n+2016-11-02  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* config/aarch64/aarch64.md (add<mode>3): Remove\n+\tredundant code.  Don't split frame based additions.\n+\n 2016-11-02  Richard Biener  <rguenther@suse.de>\n \n \t* gimple-ssa-store-merging.c (struct store_immediate_info): Remove"}, {"sha": "d5df9bb91b477e97d54d055d38429b6443fca8c2", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a6c1e36347998df5e779866f26d15dc9d01fbd/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a6c1e36347998df5e779866f26d15dc9d01fbd/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=45a6c1e36347998df5e779866f26d15dc9d01fbd", "patch": "@@ -1605,25 +1605,12 @@\n \t      (match_operand:GPI 2 \"aarch64_pluslong_operand\" \"\")))]\n   \"\"\n {\n-  if (aarch64_pluslong_strict_immedate (operands[2], <MODE>mode))\n-    {\n-      /* Give CSE the opportunity to share this constant across additions.  */\n-      if (!cse_not_expected && can_create_pseudo_p ())\n-        operands[2] = force_reg (<MODE>mode, operands[2]);\n-\n-      /* Split will refuse to operate on a modification to the stack pointer.\n-\t Aid the prologue and epilogue expanders by splitting this now.  */\n-      else if (reload_completed && operands[0] == stack_pointer_rtx)\n-\t{\n-\t  HOST_WIDE_INT i = INTVAL (operands[2]);\n-\t  HOST_WIDE_INT s = (i >= 0 ? i & 0xfff : -(-i & 0xfff));\n-\t  emit_insn (gen_rtx_SET (operands[0],\n-\t\t\t\t  gen_rtx_PLUS (<MODE>mode, operands[1],\n-\t\t\t\t\t\tGEN_INT (i - s))));\n-\t  operands[1] = operands[0];\n-\t  operands[2] = GEN_INT (s);\n-\t}\n-    }\n+  /* If the constant is too large for a single instruction and isn't frame\n+     based, split off the immediate so it is available for CSE.  */\n+  if (!aarch64_plus_immediate (operands[2], <MODE>mode)\n+      && can_create_pseudo_p ()\n+      && !REGNO_PTR_FRAME_P (REGNO (operands[1])))\n+    operands[2] = force_reg (<MODE>mode, operands[2]);\n })\n \n (define_insn \"*add<mode>3_aarch64\""}]}