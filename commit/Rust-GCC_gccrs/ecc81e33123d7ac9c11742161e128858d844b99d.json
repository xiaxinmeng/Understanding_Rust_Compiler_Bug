{"sha": "ecc81e33123d7ac9c11742161e128858d844b99d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNjODFlMzMxMjNkN2FjOWMxMTc0MjE2MWUxMjg4NThkODQ0Yjk5ZA==", "commit": {"author": {"name": "Andi Kleen", "email": "ak@linux.intel.com", "date": "2014-09-26T04:06:40Z"}, "committer": {"name": "Andi Kleen", "email": "ak@gcc.gnu.org", "date": "2014-09-26T04:06:40Z"}, "message": "Add direct support for Linux kernel __fentry__ patching\n\nThe Linux kernel dynamically patches in __fentry__ calls in and\nout at runtime. This allows using function tracing for debugging\nin production kernels without (significant) performance penalty.\n\nFor this it needs a table pointing to each __fentry__ call.\n\nThe way it is currently implemented is that a special\nperl script scans the object file, generates the table in a special\nsection. When the kernel boots up it nops the calls, and\nthen later patches in the calls again as needed.\n\nThe recordmcount.pl script in the kernel works, but it seems\ncleaner and faster to support the code generation of the patch table\ndirectly in gcc.\n\nThis also allows to nop the calls directly at code generation\ntime, which allows to skip a patching step at kernel boot.\nI also expect that a patchable production tracing facility is also useful\nfor other applications.\n\nFor example it could be used in ftracer\n(https://github.com/andikleen/ftracer)\n\nHaving a nop area at the beginning of each function can be also\nalso useful for other things. For example it can be used to patch\nfunctions at runtime to point to different functions, to do\nbinary updates without restarting the program (like ksplice or\nsimilar)\n\nThis patch implements two new options for the i386 target:\n\n-mrecord-mcount\nGenerate a __mcount_loc section entry for each __fentry__ or mcount\ncall. The section is compatible with the kernel convention\nand the data is put into a section loaded at runtime.\n\n-mnop-mcount\nGenerate the mcount/__fentry__ call as 5 byte nop that can be\npatched in later. The nop is generated as a single instruction,\nas the Linux kernel run time patching relies on this.\n\nLimitations:\n- I didn't implement -mnop-mcount for -fPIC. This\nwould need a good single instruction 6 byte NOP and it seems a\nbit pointless, as the patching would prevent text sharing.\n- I didn't implement noping for targets that pass a variable\nto mcount.\n- The facility could be useful on architectures too. Currently\nthe mcount code is target specific, so I made it a i386 option.\n\ngcc/:\n\n2014-09-25  Andi Kleen  <ak@linux.intel.com>\n\n\t* config/i386/i386.c (x86_print_call_or_nop): New function.\n\t(x86_function_profiler): Support -mnop-mcount and\n\t-mrecord-mcount.\n\t* config/i386/i386.opt (-mnop-mcount, -mrecord-mcount): Add\n\t* doc/invoke.texi: Document -mnop-mcount, -mrecord-mcount.\n\ngcc/testsuite:\n\n2014-09-25  Andi Kleen  <ak@linux.intel.com>\n\n\t* gcc.target/i386/nop-mcount.c: New file.\n\t* gcc.target/i386/record-mcount.c: New file.\n\nFrom-SVN: r215629", "tree": {"sha": "fd0848cafa95e3618b8829b766aae35e59770c01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd0848cafa95e3618b8829b766aae35e59770c01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ecc81e33123d7ac9c11742161e128858d844b99d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecc81e33123d7ac9c11742161e128858d844b99d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecc81e33123d7ac9c11742161e128858d844b99d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecc81e33123d7ac9c11742161e128858d844b99d/comments", "author": null, "committer": null, "parents": [{"sha": "6eb0ae29ec058a56434c43ebd8c8b3741bf6475c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eb0ae29ec058a56434c43ebd8c8b3741bf6475c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6eb0ae29ec058a56434c43ebd8c8b3741bf6475c"}], "stats": {"total": 121, "additions": 115, "deletions": 6}, "files": [{"sha": "d10df70fff48382b7fe9cf530f9764b40c6e5e92", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecc81e33123d7ac9c11742161e128858d844b99d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecc81e33123d7ac9c11742161e128858d844b99d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ecc81e33123d7ac9c11742161e128858d844b99d", "patch": "@@ -1,3 +1,11 @@\n+2014-09-25  Andi Kleen  <ak@linux.intel.com>\n+\n+\t* config/i386/i386.c (x86_print_call_or_nop): New function.\n+\t(x86_function_profiler): Support -mnop-mcount and\n+\t-mrecord-mcount.\n+\t* config/i386/i386.opt (-mnop-mcount, -mrecord-mcount): Add\n+\t* doc/invoke.texi: Document -mnop-mcount, -mrecord-mcount.\n+\n 2014-09-25  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-prop.c (ipa_intraprocedural_devirtualization): Remove."}, {"sha": "4cf4dea7b07b6eb762f1f7afad16a8565cc10635", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecc81e33123d7ac9c11742161e128858d844b99d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecc81e33123d7ac9c11742161e128858d844b99d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ecc81e33123d7ac9c11742161e128858d844b99d", "patch": "@@ -3975,6 +3975,13 @@ ix86_option_override_internal (bool main_args_p,\n \t}\n     }\n \n+#ifndef NO_PROFILE_COUNTERS\n+  if (flag_nop_mcount)\n+    error (\"-mnop-mcount is not compatible with this target\");\n+#endif\n+  if (flag_nop_mcount && flag_pic)\n+    error (\"-mnop-mcount is not implemented for -fPIC\");\n+\n   /* Accept -msseregparm only if at least SSE support is enabled.  */\n   if (TARGET_SSEREGPARM_P (opts->x_target_flags)\n       && ! TARGET_SSE_P (opts->x_ix86_isa_flags))\n@@ -39040,40 +39047,57 @@ x86_field_alignment (tree field, int computed)\n   return computed;\n }\n \n+/* Print call to TARGET to FILE.  */\n+\n+static void\n+x86_print_call_or_nop (FILE *file, const char *target)\n+{\n+  if (flag_nop_mcount)\n+    fprintf (file, \"1:\\tnopl 0x00(%%eax,%%eax,1)\\n\"); /* 5 byte nop.  */\n+  else\n+    fprintf (file, \"1:\\tcall\\t%s\\n\", target);\n+}\n+\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n void\n x86_function_profiler (FILE *file, int labelno ATTRIBUTE_UNUSED)\n {\n   const char *mcount_name = (flag_fentry ? MCOUNT_NAME_BEFORE_PROLOGUE\n \t\t\t\t\t : MCOUNT_NAME);\n-\n   if (TARGET_64BIT)\n     {\n #ifndef NO_PROFILE_COUNTERS\n       fprintf (file, \"\\tleaq\\t%sP%d(%%rip),%%r11\\n\", LPREFIX, labelno);\n #endif\n \n       if (!TARGET_PECOFF && flag_pic)\n-\tfprintf (file, \"\\tcall\\t*%s@GOTPCREL(%%rip)\\n\", mcount_name);\n+\tfprintf (file, \"1:\\tcall\\t*%s@GOTPCREL(%%rip)\\n\", mcount_name);\n       else\n-\tfprintf (file, \"\\tcall\\t%s\\n\", mcount_name);\n+\tx86_print_call_or_nop (file, mcount_name);\n     }\n   else if (flag_pic)\n     {\n #ifndef NO_PROFILE_COUNTERS\n       fprintf (file, \"\\tleal\\t%sP%d@GOTOFF(%%ebx),%%\" PROFILE_COUNT_REGISTER \"\\n\",\n \t       LPREFIX, labelno);\n #endif\n-      fprintf (file, \"\\tcall\\t*%s@GOT(%%ebx)\\n\", mcount_name);\n+      fprintf (file, \"1:\\tcall\\t*%s@GOT(%%ebx)\\n\", mcount_name);\n     }\n   else\n     {\n #ifndef NO_PROFILE_COUNTERS\n       fprintf (file, \"\\tmovl\\t$%sP%d,%%\" PROFILE_COUNT_REGISTER \"\\n\",\n \t       LPREFIX, labelno);\n #endif\n-      fprintf (file, \"\\tcall\\t%s\\n\", mcount_name);\n+      x86_print_call_or_nop (file, mcount_name);\n+    }\n+\n+  if (flag_record_mcount)\n+    {\n+      fprintf (file, \"\\t.section __mcount_loc, \\\"a\\\",@progbits\\n\");\n+      fprintf (file, \"\\t.%s 1b\\n\", TARGET_64BIT ? \"quad\" : \"long\");\n+      fprintf (file, \"\\t.previous\\n\");\n     }\n }\n "}, {"sha": "acf6b3751577580209226603ab55da666ed2267d", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecc81e33123d7ac9c11742161e128858d844b99d/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecc81e33123d7ac9c11742161e128858d844b99d/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=ecc81e33123d7ac9c11742161e128858d844b99d", "patch": "@@ -789,6 +789,15 @@ mfentry\n Target Report Var(flag_fentry) Init(-1)\n Emit profiling counter call at function entry before prologue.\n \n+mrecord-mcount\n+Target Report Var(flag_record_mcount) Init(0)\n+Generate __mcount_loc section with all mcount or __fentry__ calls.\n+\n+mnop-mcount\n+Target Report Var(flag_nop_mcount) Init(0)\n+Generate mcount/__fentry__ calls as nops. To activate they need to be\n+patched in.\n+\n m8bit-idiv\n Target Report Mask(USE_8BIT_IDIV) Save\n Expand 32bit/64bit integer divide into 8bit unsigned integer divide with run-time check"}, {"sha": "0c3f4beaea98b52aaf36df84a834735a131461dc", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecc81e33123d7ac9c11742161e128858d844b99d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecc81e33123d7ac9c11742161e128858d844b99d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ecc81e33123d7ac9c11742161e128858d844b99d", "patch": "@@ -692,7 +692,7 @@ Objective-C and Objective-C++ Dialects}.\n -momit-leaf-frame-pointer  -mno-red-zone -mno-tls-direct-seg-refs @gol\n -mcmodel=@var{code-model} -mabi=@var{name} -maddress-mode=@var{mode} @gol\n -m32 -m64 -mx32 -m16 -mlarge-data-threshold=@var{num} @gol\n--msse2avx -mfentry -m8bit-idiv @gol\n+-msse2avx -mfentry -mrecord-mcount -mnop-mcount -m8bit-idiv @gol\n -mavx256-split-unaligned-load -mavx256-split-unaligned-store @gol\n -mstack-protector-guard=@var{guard}}\n \n@@ -15988,6 +15988,21 @@ counter call before the prologue.\n Note: On x86 architectures the attribute @code{ms_hook_prologue}\n isn't possible at the moment for @option{-mfentry} and @option{-pg}.\n \n+@item -mrecord-mcount\n+@itemx -mno-record-mcount\n+@opindex mrecord-mcount\n+If profiling is active (@option{-pg}), generate a __mcount_loc section\n+that contains pointers to each profiling call. This is useful for\n+automatically patching and out calls.\n+\n+@item -mnop-mcount\n+@itemx -mno-nop-mcount\n+@opindex mnop-mcount\n+If profiling is active (@option{-pg}), generate the calls to\n+the profiling functions as nops. This is useful when they\n+should be patched in later dynamically. This is likely only\n+useful together with @option{-mrecord-mcount}.\n+\n @item -m8bit-idiv\n @itemx -mno-8bit-idiv\n @opindex 8bit-idiv"}, {"sha": "0074c0c09a0f228506d6a7af75365d0308855819", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecc81e33123d7ac9c11742161e128858d844b99d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecc81e33123d7ac9c11742161e128858d844b99d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ecc81e33123d7ac9c11742161e128858d844b99d", "patch": "@@ -1,3 +1,8 @@\n+2014-09-25  Andi Kleen  <ak@linux.intel.com>\n+\n+\t* gcc.target/i386/nop-mcount.c: New file.\n+\t* gcc.target/i386/record-mcount.c: New file.\n+\n 2014-09-25  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* gcc.dg/vect/pr56933.c: Don't specify \"dg-do run\" explicitly."}, {"sha": "25922315604fb473d6fb6986389c40b54c95f444", "filename": "gcc/testsuite/gcc.target/i386/nop-mcount.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecc81e33123d7ac9c11742161e128858d844b99d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fnop-mcount.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecc81e33123d7ac9c11742161e128858d844b99d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fnop-mcount.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fnop-mcount.c?ref=ecc81e33123d7ac9c11742161e128858d844b99d", "patch": "@@ -0,0 +1,24 @@\n+/* Test -mnop-mcount */\n+/* { dg-do compile } */\n+/* { dg-options \"-pg -mfentry -mrecord-mcount -mnop-mcount\" } */\n+/* { dg-final { scan-assembler-not \"__fentry__\" } } */\n+/* Origin: Andi Kleen */\n+extern void foobar(char *);\n+\n+void func(void)\n+{\n+  foobar (\"Hello world\\n\");\n+}\n+\n+void func2(void)\n+{\n+  int i;\n+  for (i = 0; i < 10; i++)\n+    foobar (\"Hello world\");\n+}\n+\n+void func3(a)\n+char *a;\n+{\n+  foobar(\"Hello world\");\n+}"}, {"sha": "dae413e9b0ead12a537b1337df8f1275288955ca", "filename": "gcc/testsuite/gcc.target/i386/record-mcount.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecc81e33123d7ac9c11742161e128858d844b99d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frecord-mcount.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecc81e33123d7ac9c11742161e128858d844b99d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frecord-mcount.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frecord-mcount.c?ref=ecc81e33123d7ac9c11742161e128858d844b99d", "patch": "@@ -0,0 +1,24 @@\n+/* Test -mrecord-mcount */\n+/* { dg-do compile } */\n+/* { dg-options \"-pg -mrecord-mcount\" } */\n+/* { dg-final { scan-assembler \"mcount_loc\" } } */\n+/* Origin: Andi Kleen */\n+extern void foobar(char *);\n+\n+void func(void)\n+{\n+  foobar (\"Hello world\\n\");\n+}\n+\n+void func2(void)\n+{\n+  int i;\n+  for (i = 0; i < 10; i++)\n+    foobar (\"Hello world\");\n+}\n+\n+void func3(a)\n+char *a;\n+{\n+  foobar(\"Hello world\");\n+}"}]}