{"sha": "dd8c13e38722b002cbc000a73ba539a7eedbc496", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ4YzEzZTM4NzIyYjAwMmNiYzAwMGE3M2JhNTM5YTdlZWRiYzQ5Ng==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-09-16T00:38:00Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-09-16T00:38:00Z"}, "message": "pa.c (emit_move_sequence): Properly set the mode of the scratch register when...\n\n\n        * pa.c (emit_move_sequence): Properly set the mode of the scratch\n        register when performing secondary reloads for the SAR register.\n\nFrom-SVN: r29446", "tree": {"sha": "7e57ad98468c6001cc2b07f50d6ee76c537b3e43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e57ad98468c6001cc2b07f50d6ee76c537b3e43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd8c13e38722b002cbc000a73ba539a7eedbc496", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd8c13e38722b002cbc000a73ba539a7eedbc496", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd8c13e38722b002cbc000a73ba539a7eedbc496", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd8c13e38722b002cbc000a73ba539a7eedbc496/comments", "author": null, "committer": null, "parents": [{"sha": "5019d7a7f06217a19edf434fca2d91590dee5351", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5019d7a7f06217a19edf434fca2d91590dee5351", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5019d7a7f06217a19edf434fca2d91590dee5351"}], "stats": {"total": 34, "additions": 27, "deletions": 7}, "files": [{"sha": "39930f970d807db5d0d6815ddcd64a5e4d338309", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd8c13e38722b002cbc000a73ba539a7eedbc496/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd8c13e38722b002cbc000a73ba539a7eedbc496/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dd8c13e38722b002cbc000a73ba539a7eedbc496", "patch": "@@ -1,3 +1,8 @@\n+Wed Sep 15 18:35:38 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* pa.c (emit_move_sequence): Properly set the mode of the scratch\n+\tregister when performing secondary reloads for the SAR register.\n+\n Wed Sep 15 15:51:52 1999  Mark Mitchell  <mark@codesourcery.com>\n \n \t* rtl.h (NOTE_BLOCK_NUMBER): Replace with ..."}, {"sha": "773c0c7bc0b7106001e25b316c4e3095db7afe83", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd8c13e38722b002cbc000a73ba539a7eedbc496/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd8c13e38722b002cbc000a73ba539a7eedbc496/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=dd8c13e38722b002cbc000a73ba539a7eedbc496", "patch": "@@ -1288,28 +1288,43 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t\t   && FP_REG_CLASS_P (REGNO_REG_CLASS (REGNO (operand1)))))\n \t   && scratch_reg)\n     {\n-      /* SCRATCH_REG will hold an address and maybe the actual data.  We want\n-\t it in WORD_MODE regardless of what mode it was originally given\n-\t to us.  */\n-      scratch_reg = gen_rtx_REG (word_mode, REGNO (scratch_reg));\n-\n       /* D might not fit in 14 bits either; for such cases load D into\n \t scratch reg.  */\n       if (GET_CODE (operand1) == MEM\n \t  && !memory_address_p (Pmode, XEXP (operand1, 0)))\n \t{\n+\t  /* We are reloading the address into the scratch register, so we\n+\t     want to make sure the scratch register is a full register.  */\n+\t  scratch_reg = gen_rtx_REG (word_mode, REGNO (scratch_reg));\n+\n \t  emit_move_insn (scratch_reg, XEXP (XEXP (operand1, 0), 1));\t\n \t  emit_move_insn (scratch_reg, gen_rtx_fmt_ee (GET_CODE (XEXP (operand1,\n \t\t\t\t\t\t\t\t        0)),\n \t\t\t\t\t\t       Pmode,\n \t\t\t\t\t\t       XEXP (XEXP (operand1, 0),\n \t\t\t\t\t\t       0),\n \t\t\t\t\t\t       scratch_reg));\n-\t  emit_move_insn (scratch_reg, gen_rtx_MEM (GET_MODE (operand1),\n+\n+\t  /* Now we are going to load the scratch register from memory,\n+\t     we want to load it in the same width as the original MEM,\n+\t     which must be the same as the width of the ultimate destination,\n+\t     OPERAND0.  */\n+\t  scratch_reg = gen_rtx_REG (GET_MODE (operand0), REGNO (scratch_reg));\n+\t  \n+\t  emit_move_insn (scratch_reg, gen_rtx_MEM (GET_MODE (operand0),\n \t\t\t\t\t\t    scratch_reg));\n \t}\n       else\n-\temit_move_insn (scratch_reg, operand1);\n+\t{\n+\t  /* We want to load the scratch register using the same mode as\n+\t     the ultimate destination.  */\n+\t  scratch_reg = gen_rtx_REG (GET_MODE (operand0), REGNO (scratch_reg));\n+\t  emit_move_insn (scratch_reg, operand1);\n+\t}\n+\n+      /* And emit the insn to set the ultimate destination.  We know that\n+\t the scratch register has the same mode as the destination at this\n+\t point.  */\n       emit_move_insn (operand0, scratch_reg);\n       return 1;\n     }"}]}