{"sha": "438be795a5e2bc261ca4f9d4b9117052dd1cc9a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM4YmU3OTVhNWUyYmMyNjFjYTRmOWQ0YjkxMTcwNTJkZDFjYzlhOA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-02-06T21:26:28Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-02-06T21:26:28Z"}, "message": "(reg_pending_sets, reg_pending_sets_all): New variables.\n\n(sched_analyze_1): Set reg_pending_sets instead of reg_last_sets.\n(sched_analyze_2): Set reg_pending_sets or reg_pending_sets_all\ninstead of reg_last_sets.\n(sched_analyze_insn): Use reg_pending_sets and\nreg_pending_sets_all to set reg_last_sets.  Set\nreg_pending_sets_all instead of reg_last_sets.\n(schedule_block): Allocate and clear reg_pending_sets.\n\nFrom-SVN: r6492", "tree": {"sha": "7cada14ca317ae46ddb838086734083fde4b8ad9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7cada14ca317ae46ddb838086734083fde4b8ad9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/438be795a5e2bc261ca4f9d4b9117052dd1cc9a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/438be795a5e2bc261ca4f9d4b9117052dd1cc9a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/438be795a5e2bc261ca4f9d4b9117052dd1cc9a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/438be795a5e2bc261ca4f9d4b9117052dd1cc9a8/comments", "author": null, "committer": null, "parents": [{"sha": "cb6c1cf1cffc357b1b0e306eb04bed6377c000c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb6c1cf1cffc357b1b0e306eb04bed6377c000c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb6c1cf1cffc357b1b0e306eb04bed6377c000c3"}], "stats": {"total": 39, "additions": 34, "deletions": 5}, "files": [{"sha": "26b3d30ae67e43cb9e71546e4647a7415c3e49d2", "filename": "gcc/sched.c", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/438be795a5e2bc261ca4f9d4b9117052dd1cc9a8/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/438be795a5e2bc261ca4f9d4b9117052dd1cc9a8/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=438be795a5e2bc261ca4f9d4b9117052dd1cc9a8", "patch": "@@ -142,6 +142,8 @@ static int *sched_reg_live_length;\n    by splitting insns.  */\n static rtx *reg_last_uses;\n static rtx *reg_last_sets;\n+static regset reg_pending_sets;\n+static int reg_pending_sets_all;\n \n /* Vector indexed by INSN_UID giving the original ordering of the insns.  */\n static int *insn_luid;\n@@ -1688,7 +1690,8 @@ sched_analyze_1 (x, insn)\n \t      if (reg_last_sets[regno + i])\n \t\tadd_dependence (insn, reg_last_sets[regno + i],\n \t\t\t\tREG_DEP_OUTPUT);\n-\t      reg_last_sets[regno + i] = insn;\n+\t      reg_pending_sets[(regno + i) / REGSET_ELT_BITS]\n+\t\t|= (REGSET_ELT_TYPE) 1 << ((regno + i) % REGSET_ELT_BITS);\n \t      if ((call_used_regs[i] || global_regs[i])\n \t\t  && last_function_call)\n \t\t/* Function calls clobber all call_used regs.  */\n@@ -1704,7 +1707,8 @@ sched_analyze_1 (x, insn)\n \t  reg_last_uses[regno] = 0;\n \t  if (reg_last_sets[regno])\n \t    add_dependence (insn, reg_last_sets[regno], REG_DEP_OUTPUT);\n-\t  reg_last_sets[regno] = insn;\n+\t  reg_pending_sets[regno / REGSET_ELT_BITS]\n+\t    |= (REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS);\n \n \t  /* Pseudos that are REG_EQUIV to something may be replaced\n \t     by that during reloading.  We need only add dependencies for\n@@ -1951,8 +1955,8 @@ sched_analyze_2 (x, insn)\n \t\treg_last_uses[i] = 0;\n \t\tif (reg_last_sets[i])\n \t\t  add_dependence (insn, reg_last_sets[i], 0);\n-\t\treg_last_sets[i] = insn;\n \t      }\n+\t    reg_pending_sets_all = 1;\n \n \t    flush_pending_lists (insn);\n \t  }\n@@ -2006,6 +2010,8 @@ sched_analyze_insn (x, insn)\n {\n   register RTX_CODE code = GET_CODE (x);\n   rtx link;\n+  int maxreg = max_reg_num ();\n+  int i;\n \n   if (code == SET || code == CLOBBER)\n     sched_analyze_1 (x, insn);\n@@ -2045,6 +2051,25 @@ sched_analyze_insn (x, insn)\n \t  sched_analyze_2 (XEXP (note, 0), insn);\n     }\n \n+  for (i = 0; i < regset_size; i++)\n+    {\n+      REGSET_ELT_TYPE sets = reg_pending_sets[i];\n+      if (sets)\n+\t{\n+\t  register int bit;\n+\t  for (bit = 0; bit < REGSET_ELT_BITS; bit++)\n+\t    if (sets & ((REGSET_ELT_TYPE) 1 << bit))\n+\t      reg_last_sets[i * REGSET_ELT_BITS + bit] = insn;\n+\t  reg_pending_sets[i] = 0;\n+\t}\n+    }\n+  if (reg_pending_sets_all)\n+    {\n+      for (i = 0; i < maxreg; i++)\n+\treg_last_sets[i] = insn;\n+      reg_pending_sets_all = 0;\n+    }\n+\n   /* Handle function calls and function returns created by the epilogue\n      threading code.  */\n   if (GET_CODE (insn) == CALL_INSN || GET_CODE (insn) == JUMP_INSN)\n@@ -2132,8 +2157,8 @@ sched_analyze (head, tail)\n \t\t  reg_last_uses[i] = 0;\n \t\t  if (reg_last_sets[i])\n \t\t    add_dependence (insn, reg_last_sets[i], 0);\n-\t\t  reg_last_sets[i] = insn;\n \t\t}\n+\t      reg_pending_sets_all = 1;\n \n \t      /* Add a fake REG_NOTE which we will later convert\n \t\t back into a NOTE_INSN_SETJMP note.  */\n@@ -2150,7 +2175,8 @@ sched_analyze (head, tail)\n \t\t    reg_last_uses[i] = 0;\n \t\t    if (reg_last_sets[i])\n \t\t      add_dependence (insn, reg_last_sets[i], REG_DEP_ANTI);\n-\t\t    reg_last_sets[i] = insn;\n+\t\t    reg_pending_sets[i / REGSET_ELT_BITS]\n+\t\t      |= (REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS);\n \t\t  }\n \t    }\n \n@@ -3042,6 +3068,9 @@ schedule_block (b, file)\n   bzero (reg_last_uses, i * sizeof (rtx));\n   reg_last_sets = (rtx *) alloca (i * sizeof (rtx));\n   bzero (reg_last_sets, i * sizeof (rtx));\n+  reg_pending_sets = (regset) alloca (regset_bytes);\n+  bzero (reg_pending_sets, regset_bytes);\n+  reg_pending_sets_all = 0;\n   clear_units ();\n \n   /* Remove certain insns at the beginning from scheduling,"}]}