{"sha": "2c4974b72a5f9a9744b2319b85e4eb239e601c44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM0OTc0YjcyYTVmOWE5NzQ0YjIzMTliODVlNGViMjM5ZTYwMWM0NA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-04-30T15:06:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-04-30T15:06:23Z"}, "message": "va-ppc.h (__va_start_common): Let __builtin_saveregs do the work.\n\n        * va-ppc.h (__va_start_common): Let __builtin_saveregs do the work.\n        * rs6000.c (expand_builtin_saveregs): For V4, initialize a private\n        va_list struct, and return a pointer to it.\n        (setup_incoming_varargs): V4 save area based off virtual_stack_vars\n        instead of frame_pointer.\n\nFrom-SVN: r26710", "tree": {"sha": "7706f72402a9c7f3fb2f9ab9b6a37610041e752f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7706f72402a9c7f3fb2f9ab9b6a37610041e752f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c4974b72a5f9a9744b2319b85e4eb239e601c44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c4974b72a5f9a9744b2319b85e4eb239e601c44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c4974b72a5f9a9744b2319b85e4eb239e601c44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c4974b72a5f9a9744b2319b85e4eb239e601c44/comments", "author": null, "committer": null, "parents": [{"sha": "d8f8e9ba17173a2b929b6047c6892610271cf252", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8f8e9ba17173a2b929b6047c6892610271cf252", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8f8e9ba17173a2b929b6047c6892610271cf252"}], "stats": {"total": 120, "additions": 89, "deletions": 31}, "files": [{"sha": "d488b46813ac746a1161d28b09845e90e77586e4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c4974b72a5f9a9744b2319b85e4eb239e601c44/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c4974b72a5f9a9744b2319b85e4eb239e601c44/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c4974b72a5f9a9744b2319b85e4eb239e601c44", "patch": "@@ -1,3 +1,11 @@\n+Fri Apr 30 13:55:43 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* va-ppc.h (__va_start_common): Let __builtin_saveregs do the work.\n+\t* rs6000.c (expand_builtin_saveregs): For V4, initialize a private\n+\tva_list struct, and return a pointer to it.\n+\t(setup_incoming_varargs): V4 save area based off virtual_stack_vars\n+\tinstead of frame_pointer.\n+\n Thu Apr 29 23:02:22 1999  Mark Mitchell  <mark@codesourcery.com>\n \n \t* emit-rtl.c (start_sequence): Expand comments."}, {"sha": "f456984a7dda5e211e424c1ec4f63fbe189ea208", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 74, "deletions": 3, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c4974b72a5f9a9744b2319b85e4eb239e601c44/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c4974b72a5f9a9744b2319b85e4eb239e601c44/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=2c4974b72a5f9a9744b2319b85e4eb239e601c44", "patch": "@@ -1633,7 +1633,8 @@ setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n     {\n       rs6000_sysv_varargs_p = 1;\n       if (! no_rtl)\n-\tsave_area = plus_constant (frame_pointer_rtx, RS6000_VARARGS_OFFSET);\n+\tsave_area = plus_constant (virtual_stack_vars_rtx,\n+\t\t\t\t   - RS6000_VARARGS_OFFSET);\n     }\n   else\n     rs6000_sysv_varargs_p = 0;\n@@ -1704,13 +1705,83 @@ setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n    \n    On the Power/PowerPC return the address of the area on the stack\n    used to hold arguments.  Under AIX, this includes the 8 word register\n-   save area.  Under V.4 this does not.  */\n+   save area. \n+\n+   Under V.4, things are more complicated.  We do not have access to\n+   all of the virtual registers required for va_start to do its job,\n+   so we construct the va_list in its entirity here, and reduce va_start\n+   to a block copy.  This is similar to the way we do things on Alpha.  */\n \n struct rtx_def *\n expand_builtin_saveregs (args)\n      tree args ATTRIBUTE_UNUSED;\n {\n-  return virtual_incoming_args_rtx;\n+  rtx block, mem_gpr_fpr, mem_reg_save_area, mem_overflow, tmp;\n+  tree fntype;\n+  int stdarg_p;\n+  HOST_WIDE_INT words, gpr, fpr;\n+\n+  if (DEFAULT_ABI != ABI_V4 && DEFAULT_ABI != ABI_SOLARIS)\n+    return virtual_incoming_args_rtx;\n+\n+  fntype = TREE_TYPE (current_function_decl);\n+  stdarg_p = (TYPE_ARG_TYPES (fntype) != 0\n+\t      && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n+\t\t  != void_type_node));\n+\n+  /* Allocate the va_list constructor.  */\n+  block = assign_stack_local (BLKmode, 3 * UNITS_PER_WORD, BITS_PER_WORD);\n+  RTX_UNCHANGING_P (block) = 1;\n+  RTX_UNCHANGING_P (XEXP (block, 0)) = 1;\n+\n+  mem_gpr_fpr = change_address (block, word_mode, XEXP (block, 0));\n+  mem_overflow = change_address (block, ptr_mode, \n+\t\t\t         plus_constant (XEXP (block, 0),\n+\t\t\t\t\t\tUNITS_PER_WORD));\n+  mem_reg_save_area = change_address (block, ptr_mode, \n+\t\t\t\t      plus_constant (XEXP (block, 0),\n+\t\t\t\t\t\t     2 * UNITS_PER_WORD));\n+\n+  /* Construct the two characters of `gpr' and `fpr' as a unit.  */\n+  words = current_function_args_info.words - !stdarg_p;\n+  gpr = (words > 8 ? 8 : words);\n+  fpr = current_function_args_info.fregno - 33;\n+\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      HOST_WIDE_INT bits = gpr << 8 | fpr;\n+      if (HOST_BITS_PER_WIDE_INT >= BITS_PER_WORD)\n+        tmp = GEN_INT (bits << (BITS_PER_WORD - 16));\n+      else\n+\t{\n+\t  bits <<= BITS_PER_WORD - HOST_BITS_PER_WIDE_INT - 16;\n+\t  tmp = immed_double_const (0, bits, word_mode);\n+\t}\n+    }\n+  else\n+    tmp = GEN_INT (fpr << 8 | gpr);\n+\n+  emit_move_insn (mem_gpr_fpr, tmp);\n+\n+  /* Find the overflow area.  */\n+  if (words <= 8)\n+    tmp = virtual_incoming_args_rtx;\n+  else\n+    tmp = expand_binop (Pmode, add_optab, virtual_incoming_args_rtx,\n+\t\t        GEN_INT ((words - 8) * UNITS_PER_WORD),\n+\t\t        mem_overflow, 0, OPTAB_WIDEN);\n+  if (tmp != mem_overflow)\n+    emit_move_insn (mem_overflow, tmp);\n+\n+  /* Find the register save area.  */\n+  tmp = expand_binop (Pmode, add_optab, virtual_stack_vars_rtx,\n+\t\t      GEN_INT (-RS6000_VARARGS_SIZE),\n+\t\t      mem_reg_save_area, 0, OPTAB_WIDEN);\n+  if (tmp != mem_reg_save_area)\n+    emit_move_insn (mem_reg_save_area, tmp);\n+\n+  /* Return the address of the va_list constructor.  */\n+  return XEXP (block, 0);\n }\n \n \f"}, {"sha": "6d81497174d2bb2b429317b7cae25f083aed6782", "filename": "gcc/ginclude/va-ppc.h", "status": "modified", "additions": 7, "deletions": 28, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c4974b72a5f9a9744b2319b85e4eb239e601c44/gcc%2Fginclude%2Fva-ppc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c4974b72a5f9a9744b2319b85e4eb239e601c44/gcc%2Fginclude%2Fva-ppc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-ppc.h?ref=2c4974b72a5f9a9744b2319b85e4eb239e601c44", "patch": "@@ -59,34 +59,13 @@ typedef struct {\n   ((TYPE *) (void *) (&(((__va_regsave_t *)\t\t\t\t\\\n \t\t\t (AP)->reg_save_area)->__gp_save[(int)(AP)->gpr])))\n \n-/* Common code for va_start for both varargs and stdarg.  This depends\n-   on the format of rs6000_args in rs6000.h.  The fields used are:\n-\n-   #0\tWORDS\t\t\t# words used for GP regs/stack values\n-   #1\tFREGNO\t\t\tnext available FP register\n-   #2\tNARGS_PROTOTYPE\t\t# args left in the current prototype\n-   #3\tORIG_NARGS\t\toriginal value of NARGS_PROTOTYPE\n-   #4\tVARARGS_OFFSET\t\toffset from frame pointer of varargs area */\n-\n-#define __va_words\t\t__builtin_args_info (0)\n-#define __va_fregno\t\t__builtin_args_info (1)\n-#define\t__va_nargs\t\t__builtin_args_info (2)\n-#define __va_orig_nargs\t\t__builtin_args_info (3)\n-#define __va_varargs_offset\t__builtin_args_info (4)\n-\n-#define __va_start_common(AP, FAKE)\t\t\t\t\t\\\n-__extension__ ({\t\t\t\t\t\t\t\\\n-   register int __words = __va_words - FAKE;\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-   (AP)->gpr = (__words < 8) ? __words : 8;\t\t\t\t\\\n-   (AP)->fpr = __va_fregno - 33;\t\t\t\t\t\\\n-   (AP)->reg_save_area = (((char *) __builtin_frame_address (0))\t\\\n-\t\t\t  + __va_varargs_offset);\t\t\t\\\n-   __va_overflow(AP) = ((char *)__builtin_saveregs ()\t\t\t\\\n-\t\t\t+ (((__words >= 8) ? __words - 8 : 0)\t\t\\\n-\t\t\t   * sizeof (long)));\t\t\t\t\\\n-   (void)0;\t\t\t\t\t\t\t\t\\\n-})\n+/* Common code for va_start for both varargs and stdarg.  We allow all\n+   the work to be done by __builtin_saveregs.  It returns a pointer to\n+   a va_list that was constructed on the stack; we must simply copy it\n+   to the user's variable.  */\n+\n+#define __va_start_common(AP, FAKE) \\\n+  __builtin_memcpy ((AP), __builtin_saveregs (), sizeof(__gnuc_va_list))\n \n #ifdef _STDARG_H /* stdarg.h support */\n "}]}