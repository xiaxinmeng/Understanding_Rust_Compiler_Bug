{"sha": "54394f4d8db10c44648966a3d243aea627d668a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQzOTRmNGQ4ZGIxMGM0NDY0ODk2NmEzZDI0M2FlYTYyN2Q2NjhhNQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-09-21T15:21:48Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-09-21T15:21:48Z"}, "message": "dwarf2out.c (is_cu_die): New function.\n\n2010-09-21  Richard Guenther  <rguenther@suse.de>\n\n\t* dwarf2out.c (is_cu_die): New function.\n\t(add_pubtype): Use it.\n\t(gen_subprogram_die): Likewise.\n\t(gen_struct_or_union_type_die): Likewise.\n\t(dwarf2out_finish): Likewise.\n\t(comp_unit_die): Rename to ...\n\t(single_comp_unit_die): ... this.\n\t(comp_unit_die): New function lazily constructing and\n\treturning single_comp_unit_die.\n\t(is_cxx, is_fortran, is_ada, debug_dwarf, break_out_comdat_types,\n\tbase_type_die, subrange_type_die, modified_type_die,\n\tlower_bound_default, add_bound_info, add_prototyped_attribute,\n\tdwarf2out_vms_debug_main_pointer, scope_die_for, retry_incomplete_types,\n\tdwarf2out_abstract_function, gen_type_die_with_usage, get_context_die,\n\tforce_decl_die, gen_namespace_die, dwarf2out_decl,\n\tdwarf2out_start_source_file, dwarf2out_end_source_file,\n\tprune_unused_types, dwarf2out_finish): Use it.\n\t(gen_compile_unit_die): For GNU GIMPLE derive DW_AT_language from\n\tthe global list of translation-unit decls.\n\t(dwarf2out_init): Do not create single_comp_unit_die here.\n\t(force_decl_die): Handle TRANSLATION_UNIT_DECL.\n\nFrom-SVN: r164484", "tree": {"sha": "998692acdc10a328cfcea96423bd16e06a9197d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/998692acdc10a328cfcea96423bd16e06a9197d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54394f4d8db10c44648966a3d243aea627d668a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54394f4d8db10c44648966a3d243aea627d668a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54394f4d8db10c44648966a3d243aea627d668a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54394f4d8db10c44648966a3d243aea627d668a5/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9cad5fe7b54a032107af1bdbaaf97e6fee98e14c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cad5fe7b54a032107af1bdbaaf97e6fee98e14c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cad5fe7b54a032107af1bdbaaf97e6fee98e14c"}], "stats": {"total": 215, "additions": 142, "deletions": 73}, "files": [{"sha": "a0d6e785bbe1deee78f6439d5d8cbac9b38d88de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54394f4d8db10c44648966a3d243aea627d668a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54394f4d8db10c44648966a3d243aea627d668a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=54394f4d8db10c44648966a3d243aea627d668a5", "patch": "@@ -1,3 +1,27 @@\n+2010-09-21  Richard Guenther  <rguenther@suse.de>\n+\n+\t* dwarf2out.c (is_cu_die): New function.\n+\t(add_pubtype): Use it.\n+\t(gen_subprogram_die): Likewise.\n+\t(gen_struct_or_union_type_die): Likewise.\n+\t(dwarf2out_finish): Likewise.\n+\t(comp_unit_die): Rename to ...\n+\t(single_comp_unit_die): ... this.\n+\t(comp_unit_die): New function lazily constructing and\n+\treturning single_comp_unit_die.\n+\t(is_cxx, is_fortran, is_ada, debug_dwarf, break_out_comdat_types,\n+\tbase_type_die, subrange_type_die, modified_type_die,\n+\tlower_bound_default, add_bound_info, add_prototyped_attribute,\n+\tdwarf2out_vms_debug_main_pointer, scope_die_for, retry_incomplete_types,\n+\tdwarf2out_abstract_function, gen_type_die_with_usage, get_context_die,\n+\tforce_decl_die, gen_namespace_die, dwarf2out_decl,\n+\tdwarf2out_start_source_file, dwarf2out_end_source_file,\n+\tprune_unused_types, dwarf2out_finish): Use it.\n+\t(gen_compile_unit_die): For GNU GIMPLE derive DW_AT_language from\n+\tthe global list of translation-unit decls.\n+\t(dwarf2out_init): Do not create single_comp_unit_die here.\n+\t(force_decl_die): Handle TRANSLATION_UNIT_DECL.\n+\n 2010-09-21  Richard Guenther  <rguenther@suse.de>\n \n \t* dwarf2out.c (dwarf2out_decl): Do not always generate a DIE"}, {"sha": "900994d0bedb4c2decc212e2855c65246aaa3920", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 118, "deletions": 73, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54394f4d8db10c44648966a3d243aea627d668a5/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54394f4d8db10c44648966a3d243aea627d668a5/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=54394f4d8db10c44648966a3d243aea627d668a5", "patch": "@@ -5878,7 +5878,7 @@ skeleton_chain_node;\n static unsigned long next_die_offset;\n \n /* Record the root of the DIE's built for the current compilation unit.  */\n-static GTY(()) dw_die_ref comp_unit_die;\n+static GTY(()) dw_die_ref single_comp_unit_die;\n \n /* A list of type DIEs that have been separated into comdat sections.  */\n static GTY(()) comdat_type_node *comdat_type_list;\n@@ -6498,6 +6498,15 @@ static char ranges_section_label[2 * MAX_ARTIFICIAL_LABEL_BYTES];\n #endif\n \n \f\n+/* Return the root of the DIE's built for the current compilation unit.  */\n+static dw_die_ref\n+comp_unit_die (void)\n+{\n+  if (!single_comp_unit_die)\n+    single_comp_unit_die = gen_compile_unit_die (NULL);\n+  return single_comp_unit_die;\n+}\n+\n /* We allow a language front-end to designate a function that is to be\n    called to \"demangle\" any name before it is put into a DIE.  */\n \n@@ -7691,7 +7700,7 @@ get_AT_file (dw_die_ref die, enum dwarf_attribute attr_kind)\n static inline bool\n is_cxx (void)\n {\n-  unsigned int lang = get_AT_unsigned (comp_unit_die, DW_AT_language);\n+  unsigned int lang = get_AT_unsigned (comp_unit_die (), DW_AT_language);\n \n   return lang == DW_LANG_C_plus_plus || lang == DW_LANG_ObjC_plus_plus;\n }\n@@ -7701,7 +7710,7 @@ is_cxx (void)\n static inline bool\n is_fortran (void)\n {\n-  unsigned int lang = get_AT_unsigned (comp_unit_die, DW_AT_language);\n+  unsigned int lang = get_AT_unsigned (comp_unit_die (), DW_AT_language);\n \n   return (lang == DW_LANG_Fortran77\n \t  || lang == DW_LANG_Fortran90\n@@ -7713,7 +7722,7 @@ is_fortran (void)\n static inline bool\n is_ada (void)\n {\n-  unsigned int lang = get_AT_unsigned (comp_unit_die, DW_AT_language);\n+  unsigned int lang = get_AT_unsigned (comp_unit_die (), DW_AT_language);\n \n   return lang == DW_LANG_Ada95 || lang == DW_LANG_Ada83;\n }\n@@ -8456,7 +8465,7 @@ DEBUG_FUNCTION void\n debug_dwarf (void)\n {\n   print_indent = 0;\n-  print_die (comp_unit_die, stderr);\n+  print_die (comp_unit_die (), stderr);\n   if (! DWARF2_ASM_LINE_DEBUG_INFO)\n     print_dwarf_line_table (stderr);\n }\n@@ -9506,6 +9515,14 @@ is_symbol_die (dw_die_ref c)\n \t  || c->die_tag == DW_TAG_module);\n }\n \n+/* Returns true iff C is a compile-unit DIE.  */\n+\n+static inline bool\n+is_cu_die (dw_die_ref c)\n+{\n+  return c && c->die_tag == DW_TAG_compile_unit;\n+}\n+\n static char *\n gen_internal_sym (const char *prefix)\n {\n@@ -10031,7 +10048,7 @@ break_out_comdat_types (dw_die_ref die)\n            add it to the list of comdat types.  */\n         unit = new_die (DW_TAG_type_unit, NULL, NULL);\n         add_AT_unsigned (unit, DW_AT_language,\n-                         get_AT_unsigned (comp_unit_die, DW_AT_language));\n+                         get_AT_unsigned (comp_unit_die (), DW_AT_language));\n         type_node = ggc_alloc_cleared_comdat_type_node ();\n         type_node->root_die = unit;\n         type_node->next = comdat_type_list;\n@@ -11353,7 +11370,7 @@ add_pubtype (tree decl, dw_die_ref die)\n \n   e.name = NULL;\n   if ((TREE_PUBLIC (decl)\n-       || die->die_parent == comp_unit_die)\n+       || is_cu_die (die->die_parent))\n       && (die->die_tag == DW_TAG_typedef || COMPLETE_TYPE_P (decl)))\n     {\n       e.die = die;\n@@ -12557,7 +12574,7 @@ base_type_die (tree type)\n       gcc_unreachable ();\n     }\n \n-  base_type_result = new_die (DW_TAG_base_type, comp_unit_die, type);\n+  base_type_result = new_die (DW_TAG_base_type, comp_unit_die (), type);\n \n   add_AT_unsigned (base_type_result, DW_AT_byte_size,\n \t\t   int_size_in_bytes (type));\n@@ -12648,7 +12665,7 @@ subrange_type_die (tree type, tree low, tree high, dw_die_ref context_die)\n   const HOST_WIDE_INT size_in_bytes = int_size_in_bytes (type);\n \n   if (context_die == NULL)\n-    context_die = comp_unit_die;\n+    context_die = comp_unit_die ();\n \n   subrange_die = new_die (DW_TAG_subrange_type, context_die, type);\n \n@@ -12743,17 +12760,17 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n \n   if (is_const_type)\n     {\n-      mod_type_die = new_die (DW_TAG_const_type, comp_unit_die, type);\n+      mod_type_die = new_die (DW_TAG_const_type, comp_unit_die (), type);\n       sub_die = modified_type_die (type, 0, is_volatile_type, context_die);\n     }\n   else if (is_volatile_type)\n     {\n-      mod_type_die = new_die (DW_TAG_volatile_type, comp_unit_die, type);\n+      mod_type_die = new_die (DW_TAG_volatile_type, comp_unit_die (), type);\n       sub_die = modified_type_die (type, 0, 0, context_die);\n     }\n   else if (code == POINTER_TYPE)\n     {\n-      mod_type_die = new_die (DW_TAG_pointer_type, comp_unit_die, type);\n+      mod_type_die = new_die (DW_TAG_pointer_type, comp_unit_die (), type);\n       add_AT_unsigned (mod_type_die, DW_AT_byte_size,\n \t\t       simple_type_size_in_bits (type) / BITS_PER_UNIT);\n       item_type = TREE_TYPE (type);\n@@ -12764,10 +12781,10 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n   else if (code == REFERENCE_TYPE)\n     {\n       if (TYPE_REF_IS_RVALUE (type) && dwarf_version >= 4)\n-\tmod_type_die = new_die (DW_TAG_rvalue_reference_type, comp_unit_die,\n+\tmod_type_die = new_die (DW_TAG_rvalue_reference_type, comp_unit_die (),\n \t\t\t\ttype);\n       else\n-\tmod_type_die = new_die (DW_TAG_reference_type, comp_unit_die, type);\n+\tmod_type_die = new_die (DW_TAG_reference_type, comp_unit_die (), type);\n       add_AT_unsigned (mod_type_die, DW_AT_byte_size,\n \t\t       simple_type_size_in_bits (type) / BITS_PER_UNIT);\n       item_type = TREE_TYPE (type);\n@@ -17126,7 +17143,7 @@ add_comp_dir_attribute (dw_die_ref die)\n static int\n lower_bound_default (void)\n {\n-  switch (get_AT_unsigned (comp_unit_die, DW_AT_language))\n+  switch (get_AT_unsigned (comp_unit_die (), DW_AT_language))\n     {\n     case DW_LANG_C:\n     case DW_LANG_C89:\n@@ -17255,7 +17272,7 @@ add_bound_info (dw_die_ref subrange_die, enum dwarf_attribute bound_attr, tree b\n \t  break;\n \n \tif (current_function_decl == 0)\n-\t  ctx = comp_unit_die;\n+\t  ctx = comp_unit_die ();\n \telse\n \t  ctx = lookup_decl_die (current_function_decl);\n \n@@ -17448,7 +17465,7 @@ add_bit_size_attribute (dw_die_ref die, tree decl)\n static inline void\n add_prototyped_attribute (dw_die_ref die, tree func_type)\n {\n-  if (get_AT_unsigned (comp_unit_die, DW_AT_language) == DW_LANG_C89\n+  if (get_AT_unsigned (comp_unit_die (), DW_AT_language) == DW_LANG_C89\n       && TYPE_ARG_TYPES (func_type) != NULL)\n     add_AT_flag (die, DW_AT_prototyped, 1);\n }\n@@ -17628,17 +17645,17 @@ dwarf2out_vms_debug_main_pointer (void)\n \t\t\t       current_function_funcdef_no);\n   add_AT_lbl_id (die, DW_AT_entry_pc, label);\n \n-  /* Make it the first child of comp_unit_die.  */\n-  die->die_parent = comp_unit_die;\n-  if (comp_unit_die->die_child)\n+  /* Make it the first child of comp_unit_die ().  */\n+  die->die_parent = comp_unit_die ();\n+  if (comp_unit_die ()->die_child)\n     {\n-      die->die_sib = comp_unit_die->die_child->die_sib;\n-      comp_unit_die->die_child->die_sib = die;\n+      die->die_sib = comp_unit_die ()->die_child->die_sib;\n+      comp_unit_die ()->die_child->die_sib = die;\n     }\n   else\n     {\n       die->die_sib = die;\n-      comp_unit_die->die_child = die;\n+      comp_unit_die ()->die_child = die;\n     }\n }\n #endif /* VMS_DEBUGGING_INFO */\n@@ -17693,7 +17710,7 @@ scope_die_for (tree t, dw_die_ref context_die)\n     containing_scope = NULL_TREE;\n \n   if (containing_scope == NULL_TREE)\n-    scope_die = comp_unit_die;\n+    scope_die = comp_unit_die ();\n   else if (TYPE_P (containing_scope))\n     {\n       /* For types, we can just look up the appropriate DIE.  But\n@@ -17713,7 +17730,7 @@ scope_die_for (tree t, dw_die_ref context_die)\n \n \t  /* If none of the current dies are suitable, we get file scope.  */\n \t  if (scope_die == NULL)\n-\t    scope_die = comp_unit_die;\n+\t    scope_die = comp_unit_die ();\n \t}\n       else\n \tscope_die = lookup_type_die (containing_scope);\n@@ -18217,7 +18234,7 @@ retry_incomplete_types (void)\n   for (i = VEC_length (tree, incomplete_types) - 1; i >= 0; i--)\n     if (should_emit_struct_debug (VEC_index (tree, incomplete_types, i),\n \t\t\t\t  DINFO_USAGE_DIR_USE))\n-      gen_type_die (VEC_index (tree, incomplete_types, i), comp_unit_die);\n+      gen_type_die (VEC_index (tree, incomplete_types, i), comp_unit_die ());\n }\n \n /* Determine what tag to use for a record type.  */\n@@ -18587,7 +18604,7 @@ dwarf2out_abstract_function (tree decl)\n       context = decl_class_context (decl);\n       if (context)\n \tgen_type_die_for_member\n-\t  (context, decl, decl_function_context (decl) ? NULL : comp_unit_die);\n+\t  (context, decl, decl_function_context (decl) ? NULL : comp_unit_die ());\n     }\n \n   /* Pretend we've just finished compiling this function.  */\n@@ -18751,7 +18768,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t instances of inlines, since the spec requires the out-of-line copy\n \t to have the same parent.  For local class methods, this doesn't\n \t apply; we just use the old DIE.  */\n-      if ((old_die->die_parent == comp_unit_die || context_die == NULL)\n+      if ((is_cu_die (old_die->die_parent) || context_die == NULL)\n \t  && (DECL_ARTIFICIAL (decl)\n \t      || (get_AT_file (old_die, DW_AT_decl_file) == file_index\n \t\t  && (get_AT_unsigned (old_die, DW_AT_decl_line)\n@@ -19613,6 +19630,38 @@ gen_compile_unit_die (const char *filename)\n \n   add_AT_string (die, DW_AT_producer, producer);\n \n+  /* If our producer is LTO try to figure out a common language to use\n+     from the global list of translation units.  */\n+  if (strcmp (language_string, \"GNU GIMPLE\") == 0)\n+    {\n+      unsigned i;\n+      tree t;\n+      const char *common_lang = NULL;\n+\n+      FOR_EACH_VEC_ELT (tree, all_translation_units, i, t)\n+\t{\n+\t  if (!TRANSLATION_UNIT_LANGUAGE (t))\n+\t    continue;\n+\t  if (!common_lang)\n+\t    common_lang = TRANSLATION_UNIT_LANGUAGE (t);\n+\t  else if (strcmp (common_lang, TRANSLATION_UNIT_LANGUAGE (t)) == 0)\n+\t    ;\n+\t  else if (strncmp (common_lang, \"GNU C\", 5) == 0\n+\t\t   && strncmp (TRANSLATION_UNIT_LANGUAGE (t), \"GNU C\", 5) == 0)\n+\t    /* Mixing C and C++ is ok, use C++ in that case.  */\n+\t    common_lang = \"GNU C++\";\n+\t  else\n+\t    {\n+\t      /* Fall back to C.  */\n+\t      common_lang = NULL;\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (common_lang)\n+\tlanguage_string = common_lang;\n+    }\n+\n   language = DW_LANG_C89;\n   if (strcmp (language_string, \"GNU C++\") == 0)\n     language = DW_LANG_C_plus_plus;\n@@ -19772,7 +19821,7 @@ gen_struct_or_union_type_die (tree type, dw_die_ref context_die,\n \n   scope_die = scope_die_for (type, context_die);\n \n-  if (! type_die || (nested && scope_die == comp_unit_die))\n+  if (! type_die || (nested && is_cu_die (scope_die)))\n     /* First occurrence of type or toplevel definition of nested class.  */\n     {\n       dw_die_ref old_die = type_die;\n@@ -20149,7 +20198,7 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n \t    tree name = TYPE_NAME (type);\n \t    if (TREE_CODE (name) == TYPE_DECL)\n \t      name = DECL_NAME (name);\n-            type_die = new_die (DW_TAG_unspecified_type, comp_unit_die, type);\n+            type_die = new_die (DW_TAG_unspecified_type, comp_unit_die (), type);\n             add_name_attribute (type_die, IDENTIFIER_POINTER (name));\n             equate_type_number_to_die (type, type_die);\n           }\n@@ -20379,7 +20428,7 @@ get_context_die (tree context)\n       else\n \treturn force_decl_die (context);\n     }\n-  return comp_unit_die;\n+  return comp_unit_die ();\n }\n \n /* Returns the DIE for decl.  A DIE will always be returned.  */\n@@ -20425,7 +20474,11 @@ force_decl_die (tree decl)\n \t    dwarf2out_decl (decl);\n \t  else\n \t    /* DWARF2 has neither DW_TAG_module, nor DW_TAG_namespace.  */\n-\t    decl_die = comp_unit_die;\n+\t    decl_die = comp_unit_die ();\n+\t  break;\n+\n+\tcase TRANSLATION_UNIT_DECL:\n+\t  decl_die = comp_unit_die ();\n \t  break;\n \n \tdefault:\n@@ -20522,7 +20575,7 @@ gen_namespace_die (tree decl, dw_die_ref context_die)\n   if (DECL_ABSTRACT_ORIGIN (decl) == NULL)\n     {\n       /* Output a real namespace or module.  */\n-      context_die = setup_namespace_context (decl, comp_unit_die);\n+      context_die = setup_namespace_context (decl, comp_unit_die ());\n       namespace_die = new_die (is_fortran ()\n \t\t\t       ? DW_TAG_module : DW_TAG_namespace,\n \t\t\t       context_die, decl);\n@@ -20549,7 +20602,7 @@ gen_namespace_die (tree decl, dw_die_ref context_die)\n \n       if (DECL_CONTEXT (decl) == NULL_TREE\n \t  || TREE_CODE (DECL_CONTEXT (decl)) == NAMESPACE_DECL)\n-\tcontext_die = setup_namespace_context (decl, comp_unit_die);\n+\tcontext_die = setup_namespace_context (decl, comp_unit_die ());\n       /* Now create the namespace alias DIE.  */\n       namespace_die = new_die (DW_TAG_imported_declaration, context_die, decl);\n       add_name_and_src_coords_attributes (namespace_die, decl);\n@@ -20920,7 +20973,7 @@ dwarf2out_imported_module_or_decl (tree decl, tree name, tree context,\n void\n dwarf2out_decl (tree decl)\n {\n-  dw_die_ref context_die = comp_unit_die;\n+  dw_die_ref context_die = comp_unit_die ();\n \n   switch (TREE_CODE (decl))\n     {\n@@ -21565,7 +21618,7 @@ dwarf2out_start_source_file (unsigned int lineno, const char *filename)\n       /* Record the beginning of the file for break_out_includes.  */\n       dw_die_ref bincl_die;\n \n-      bincl_die = new_die (DW_TAG_GNU_BINCL, comp_unit_die, NULL);\n+      bincl_die = new_die (DW_TAG_GNU_BINCL, comp_unit_die (), NULL);\n       add_AT_string (bincl_die, DW_AT_name, remap_debug_filename (filename));\n     }\n \n@@ -21589,7 +21642,7 @@ dwarf2out_end_source_file (unsigned int lineno ATTRIBUTE_UNUSED)\n {\n   if (flag_eliminate_dwarf2_dups && dwarf_version < 4)\n     /* Record the end of the file for break_out_includes.  */\n-    new_die (DW_TAG_GNU_EINCL, comp_unit_die, NULL);\n+    new_die (DW_TAG_GNU_EINCL, comp_unit_die (), NULL);\n \n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n     {\n@@ -21675,14 +21728,6 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n   vcall_insn_table = htab_create_ggc (10, vcall_insn_table_hash,\n                                       vcall_insn_table_eq, NULL);\n \n-  /* Generate the initial DIE for the .debug section.  Note that the (string)\n-     value given in the DW_AT_name attribute of the DW_TAG_compile_unit DIE\n-     will (typically) be a relative pathname and that this pathname should be\n-     taken as being relative to the directory from which the compiler was\n-     invoked when the given (base) source file was compiled.  We will fill\n-     in this value in dwarf2out_finish.  */\n-  comp_unit_die = gen_compile_unit_die (NULL);\n-\n   incomplete_types = VEC_alloc (tree, gc, 64);\n \n   used_rtx_array = VEC_alloc (rtx, gc, 32);\n@@ -22092,7 +22137,7 @@ prune_unused_types (void)\n \n #if ENABLE_ASSERT_CHECKING\n   /* All the marks should already be clear.  */\n-  verify_marks_clear (comp_unit_die);\n+  verify_marks_clear (comp_unit_die ());\n   for (node = limbo_die_list; node; node = node->next)\n     verify_marks_clear (node->die);\n   for (ctnode = comdat_type_list; ctnode; ctnode = ctnode->next)\n@@ -22103,7 +22148,7 @@ prune_unused_types (void)\n   premark_types_used_by_global_vars ();\n \n   /* Set the mark on nodes that are actually used.  */\n-  prune_unused_types_walk (comp_unit_die);\n+  prune_unused_types_walk (comp_unit_die ());\n   for (node = limbo_die_list; node; node = node->next)\n     prune_unused_types_walk (node->die);\n   for (ctnode = comdat_type_list; ctnode; ctnode = ctnode->next)\n@@ -22128,14 +22173,14 @@ prune_unused_types (void)\n     htab_traverse (debug_str_hash, prune_indirect_string, NULL);\n   else if (debug_str_hash)\n     htab_empty (debug_str_hash);\n-  prune_unused_types_prune (comp_unit_die);\n+  prune_unused_types_prune (comp_unit_die ());\n   for (node = limbo_die_list; node; node = node->next)\n     prune_unused_types_prune (node->die);\n   for (ctnode = comdat_type_list; ctnode; ctnode = ctnode->next)\n     prune_unused_types_prune (ctnode->root_die);\n \n   /* Leave the marks clear.  */\n-  prune_unmark_dies (comp_unit_die);\n+  prune_unmark_dies (comp_unit_die ());\n   for (node = limbo_die_list; node; node = node->next)\n     prune_unmark_dies (node->die);\n   for (ctnode = comdat_type_list; ctnode; ctnode = ctnode->next)\n@@ -22354,15 +22399,15 @@ dwarf2out_finish (const char *filename)\n \n   /* Add the name for the main input file now.  We delayed this from\n      dwarf2out_init to avoid complications with PCH.  */\n-  add_name_attribute (comp_unit_die, remap_debug_filename (filename));\n+  add_name_attribute (comp_unit_die (), remap_debug_filename (filename));\n   if (!IS_ABSOLUTE_PATH (filename))\n-    add_comp_dir_attribute (comp_unit_die);\n-  else if (get_AT (comp_unit_die, DW_AT_comp_dir) == NULL)\n+    add_comp_dir_attribute (comp_unit_die ());\n+  else if (get_AT (comp_unit_die (), DW_AT_comp_dir) == NULL)\n     {\n       bool p = false;\n       htab_traverse (file_table, file_table_relative_p, &p);\n       if (p)\n-\tadd_comp_dir_attribute (comp_unit_die);\n+\tadd_comp_dir_attribute (comp_unit_die ());\n     }\n \n   for (i = 0; i < VEC_length (deferred_locations, deferred_locations_list); i++)\n@@ -22389,11 +22434,11 @@ dwarf2out_finish (const char *filename)\n \n \t  if (origin)\n \t    add_child_die (origin->die_parent, die);\n-\t  else if (die == comp_unit_die)\n+\t  else if (is_cu_die (die))\n \t    ;\n \t  else if (seen_error ())\n \t    /* It's OK to be confused by errors in the input.  */\n-\t    add_child_die (comp_unit_die, die);\n+\t    add_child_die (comp_unit_die (), die);\n \t  else\n \t    {\n \t      /* In certain situations, the lexical block containing a\n@@ -22423,14 +22468,14 @@ dwarf2out_finish (const char *filename)\n \t      if (origin)\n \t        add_child_die (origin, die);\n \t      else\n-\t        add_child_die (comp_unit_die, die);\n+\t        add_child_die (comp_unit_die (), die);\n \t    }\n \t}\n     }\n \n   limbo_die_list = NULL;\n \n-  resolve_addr (comp_unit_die);\n+  resolve_addr (comp_unit_die ());\n \n   for (node = deferred_asm_name; node; node = node->next)\n     {\n@@ -22454,12 +22499,12 @@ dwarf2out_finish (const char *filename)\n   /* Generate separate CUs for each of the include files we've seen.\n      They will go into limbo_die_list.  */\n   if (flag_eliminate_dwarf2_dups && dwarf_version < 4)\n-    break_out_includes (comp_unit_die);\n+    break_out_includes (comp_unit_die ());\n \n   /* Generate separate COMDAT sections for type DIEs. */\n   if (dwarf_version >= 4)\n     {\n-      break_out_comdat_types (comp_unit_die);\n+      break_out_comdat_types (comp_unit_die ());\n \n       /* Each new type_unit DIE was added to the limbo die list when created.\n          Since these have all been added to comdat_type_list, clear the\n@@ -22471,7 +22516,7 @@ dwarf2out_finish (const char *filename)\n          references to the main compile unit).  */\n       for (ctnode = comdat_type_list; ctnode != NULL; ctnode = ctnode->next)\n         copy_decls_for_unworthy_types (ctnode->root_die);\n-      copy_decls_for_unworthy_types (comp_unit_die);\n+      copy_decls_for_unworthy_types (comp_unit_die ());\n \n       /* In the process of copying declarations from one unit to another,\n          we may have left some declarations behind that are no longer\n@@ -22481,7 +22526,7 @@ dwarf2out_finish (const char *filename)\n \n   /* Traverse the DIE's and add add sibling attributes to those DIE's\n      that have children.  */\n-  add_sibling_attributes (comp_unit_die);\n+  add_sibling_attributes (comp_unit_die ());\n   for (node = limbo_die_list; node; node = node->next)\n     add_sibling_attributes (node->die);\n   for (ctnode = comdat_type_list; ctnode != NULL; ctnode = ctnode->next)\n@@ -22501,8 +22546,8 @@ dwarf2out_finish (const char *filename)\n   if (!have_multiple_function_sections\n       || !(dwarf_version >= 3 || !dwarf_strict))\n     {\n-      add_AT_lbl_id (comp_unit_die, DW_AT_low_pc, text_section_label);\n-      add_AT_lbl_id (comp_unit_die, DW_AT_high_pc, text_end_label);\n+      add_AT_lbl_id (comp_unit_die (), DW_AT_low_pc, text_section_label);\n+      add_AT_lbl_id (comp_unit_die (), DW_AT_high_pc, text_end_label);\n     }\n \n   else\n@@ -22515,14 +22560,14 @@ dwarf2out_finish (const char *filename)\n \t absolute.  Historically, we've emitted the unexpected\n \t DW_AT_entry_pc instead of DW_AT_low_pc for this purpose.\n \t Emit both to give time for other tools to adapt.  */\n-      add_AT_addr (comp_unit_die, DW_AT_low_pc, const0_rtx);\n-      add_AT_addr (comp_unit_die, DW_AT_entry_pc, const0_rtx);\n+      add_AT_addr (comp_unit_die (), DW_AT_low_pc, const0_rtx);\n+      add_AT_addr (comp_unit_die (), DW_AT_entry_pc, const0_rtx);\n \n       if (text_section_used)\n-\tadd_ranges_by_labels (comp_unit_die, text_section_label,\n+\tadd_ranges_by_labels (comp_unit_die (), text_section_label,\n \t\t\t      text_end_label, &range_list_added);\n       if (flag_reorder_blocks_and_partition && cold_text_section_used)\n-\tadd_ranges_by_labels (comp_unit_die, cold_text_section_label,\n+\tadd_ranges_by_labels (comp_unit_die (), cold_text_section_label,\n \t\t\t      cold_end_label, &range_list_added);\n \n       for (fde_idx = 0; fde_idx < fde_table_in_use; fde_idx++)\n@@ -22532,18 +22577,18 @@ dwarf2out_finish (const char *filename)\n \t  if (fde->dw_fde_switched_sections)\n \t    {\n \t      if (!fde->in_std_section)\n-\t\tadd_ranges_by_labels (comp_unit_die,\n+\t\tadd_ranges_by_labels (comp_unit_die (),\n \t\t\t\t      fde->dw_fde_hot_section_label,\n \t\t\t\t      fde->dw_fde_hot_section_end_label,\n \t\t\t\t      &range_list_added);\n \t      if (!fde->cold_in_std_section)\n-\t\tadd_ranges_by_labels (comp_unit_die,\n+\t\tadd_ranges_by_labels (comp_unit_die (),\n \t\t\t\t      fde->dw_fde_unlikely_section_label,\n \t\t\t\t      fde->dw_fde_unlikely_section_end_label,\n \t\t\t\t      &range_list_added);\n \t    }\n \t  else if (!fde->in_std_section)\n-\t    add_ranges_by_labels (comp_unit_die, fde->dw_fde_begin,\n+\t    add_ranges_by_labels (comp_unit_die (), fde->dw_fde_begin,\n \t\t\t\t  fde->dw_fde_end, &range_list_added);\n \t}\n \n@@ -22552,11 +22597,11 @@ dwarf2out_finish (const char *filename)\n     }\n \n   if (debug_info_level >= DINFO_LEVEL_NORMAL)\n-    add_AT_lineptr (comp_unit_die, DW_AT_stmt_list,\n+    add_AT_lineptr (comp_unit_die (), DW_AT_stmt_list,\n \t\t    debug_line_section_label);\n \n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n-    add_AT_macptr (comp_unit_die, DW_AT_macro_info, macinfo_section_label);\n+    add_AT_macptr (comp_unit_die (), DW_AT_macro_info, macinfo_section_label);\n \n   /* Output all of the compilation units.  We put the main one last so that\n      the offsets are available to output_pubnames.  */\n@@ -22586,7 +22631,7 @@ dwarf2out_finish (const char *filename)\n \n   /* Output the main compilation unit if non-empty or if .debug_macinfo\n      has been emitted.  */\n-  output_comp_unit (comp_unit_die, debug_info_level >= DINFO_LEVEL_VERBOSE);\n+  output_comp_unit (comp_unit_die (), debug_info_level >= DINFO_LEVEL_VERBOSE);\n \n   /* Output the abbreviation table.  */\n   switch_to_section (debug_abbrev_section);"}]}