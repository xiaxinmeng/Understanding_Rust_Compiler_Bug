{"sha": "670961f051aedbac21bc769c21c5b28b338b6003", "node_id": "C_kwDOANBUbNoAKDY3MDk2MWYwNTFhZWRiYWMyMWJjNzY5YzIxYzViMjhiMzM4YjYwMDM", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-25T11:04:43Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-26T06:23:50Z"}, "message": "Improve compute_control_dep_chain path finding\n\nThis improves the compute_control_dep_chain path finding by first\nmarking the dominating region we search and then making sure to\nnot walk outside if it when enumerating all paths from the dominating\nblock to the interesting PHI edge source.  I have limited the DFS\nwalk done for the marking in similar ways as we limit the walking\nin compute_control_dep_chain, more careful limiting might be\nnecessary though - the --param uninit-control-dep-attempts param\nI re-use has a rather high default of 1000 which we might be able\nto reduce with this patch as well (I think we'll usually hit some of the\nother limits before ever reaching this).\n\n\t* gimple-predicate-analysis.cc (dfs_mark_dominating_region):\n\tNew helper.\n\t(compute_control_dep_chain): Adjust to honor marked region\n\tif provided.\n\t(uninit_analysis::init_from_phi_def): Pre-mark the dominating\n\tregion to improve compute_control_dep_chain walking.\n\t* vec.h (vec<T, va_heap, vl_ptr>::allocated): Add forwarder.", "tree": {"sha": "01f4bc58600b452dbf3018fedf321ceed652531c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01f4bc58600b452dbf3018fedf321ceed652531c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/670961f051aedbac21bc769c21c5b28b338b6003", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/670961f051aedbac21bc769c21c5b28b338b6003", "html_url": "https://github.com/Rust-GCC/gccrs/commit/670961f051aedbac21bc769c21c5b28b338b6003", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/670961f051aedbac21bc769c21c5b28b338b6003/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b4d528d8c57ad7a2d5e39427bf4af7b8c1668c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b4d528d8c57ad7a2d5e39427bf4af7b8c1668c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b4d528d8c57ad7a2d5e39427bf4af7b8c1668c3"}], "stats": {"total": 84, "additions": 81, "deletions": 3}, "files": [{"sha": "e395c1b705226c5cb842afe28ce5b159422d5cc2", "filename": "gcc/gimple-predicate-analysis.cc", "status": "modified", "additions": 78, "deletions": 3, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670961f051aedbac21bc769c21c5b28b338b6003/gcc%2Fgimple-predicate-analysis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670961f051aedbac21bc769c21c5b28b338b6003/gcc%2Fgimple-predicate-analysis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predicate-analysis.cc?ref=670961f051aedbac21bc769c21c5b28b338b6003", "patch": "@@ -1078,6 +1078,54 @@ simple_control_dep_chain (vec<edge>& chain, basic_block from, edge to)\n   simple_control_dep_chain (chain, from, to->src);\n }\n \n+/* Perform a DFS walk on predecessor edges to mark the region denoted\n+   by the EXIT edge and DOM which dominates EXIT->src, including DOM.\n+   Blocks in the region are marked with FLAG and added to BBS.  BBS is\n+   filled up to its capacity only after which the walk is terminated\n+   and false is returned.  If the whole region was marked, true is returned.  */\n+\n+static bool\n+dfs_mark_dominating_region (edge exit, basic_block dom, int flag,\n+\t\t\t    vec<basic_block> &bbs)\n+{\n+  if (exit->src == dom || exit->src->flags & flag)\n+    return true;\n+  if (!bbs.space (1))\n+    return false;\n+  bbs.quick_push (exit->src);\n+  exit->src->flags |= flag;\n+  auto_vec<edge_iterator, 20> stack (bbs.allocated () - bbs.length () + 1);\n+  stack.quick_push (ei_start (exit->src->preds));\n+  while (!stack.is_empty ())\n+    {\n+      /* Look at the edge on the top of the stack.  */\n+      edge_iterator ei = stack.last ();\n+      basic_block src = ei_edge (ei)->src;\n+\n+      /* Check if the edge source has been visited yet.  */\n+      if (!(src->flags & flag))\n+\t{\n+\t  /* Mark the source if there's still space.  If not, return early.  */\n+\t  if (!bbs.space (1))\n+\t    return false;\n+\t  src->flags |= flag;\n+\t  bbs.quick_push (src);\n+\n+\t  /* Queue its predecessors if we didn't reach DOM.  */\n+\t  if (src != dom && EDGE_COUNT (src->preds) > 0)\n+\t    stack.quick_push (ei_start (src->preds));\n+\t}\n+      else\n+\t{\n+\t  if (!ei_one_before_end_p (ei))\n+\t    ei_next (&stack.last ());\n+\t  else\n+\t    stack.pop ();\n+\t}\n+    }\n+  return true;\n+}\n+\n /* Recursively compute the control dependence chains (paths of edges)\n    from the dependent basic block, DEP_BB, up to the dominating basic\n    block, DOM_BB (the head node of a chain should be dominated by it),\n@@ -1093,7 +1141,7 @@ static bool\n compute_control_dep_chain (basic_block dom_bb, const_basic_block dep_bb,\n \t\t\t   vec<edge> cd_chains[], unsigned *num_chains,\n \t\t\t   vec<edge> &cur_cd_chain, unsigned *num_calls,\n-\t\t\t   unsigned depth = 0)\n+\t\t\t   unsigned in_region = 0, unsigned depth = 0)\n {\n   if (*num_calls > (unsigned)param_uninit_control_dep_attempts)\n     {\n@@ -1167,10 +1215,14 @@ compute_control_dep_chain (basic_block dom_bb, const_basic_block dep_bb,\n \t      break;\n \t    }\n \n+\t  /* If the dominating region has been marked avoid walking outside.  */\n+\t  if (in_region != 0 && !(cd_bb->flags & in_region))\n+\t    break;\n+\n \t  /* Check if DEP_BB is indirectly control-dependent on DOM_BB.  */\n \t  if (compute_control_dep_chain (cd_bb, dep_bb, cd_chains,\n \t\t\t\t\t num_chains, cur_cd_chain,\n-\t\t\t\t\t num_calls, depth + 1))\n+\t\t\t\t\t num_calls, in_region, depth + 1))\n \t    {\n \t      found_cd_chain = true;\n \t      break;\n@@ -2238,6 +2290,25 @@ uninit_analysis::init_from_phi_def (gphi *phi)\n   if (nedges == 0)\n     return false;\n \n+  auto_bb_flag in_region (cfun);\n+  auto_vec<basic_block, 20> region (MIN (n_basic_blocks_for_fn (cfun),\n+\t\t\t\t\t param_uninit_control_dep_attempts));\n+  /* Pre-mark the PHI incoming edges PHI block to make sure we only walk\n+     interesting edges from there.  */\n+  for (unsigned i = 0; i < nedges; i++)\n+    {\n+      if (!(def_edges[i]->dest->flags & in_region))\n+\t{\n+\t  if (!region.space (1))\n+\t    break;\n+\t  def_edges[i]->dest->flags |= in_region;\n+\t  region.quick_push (def_edges[i]->dest);\n+\t}\n+    }\n+  for (unsigned i = 0; i < nedges; i++)\n+    if (!dfs_mark_dominating_region (def_edges[i], cd_root, in_region, region))\n+      break;\n+\n   unsigned num_chains = 0;\n   auto_vec<edge> dep_chains[MAX_NUM_CHAINS];\n   auto_vec<edge, MAX_CHAIN_LEN + 1> cur_chain;\n@@ -2247,7 +2318,7 @@ uninit_analysis::init_from_phi_def (gphi *phi)\n       unsigned num_calls = 0;\n       unsigned prev_nc = num_chains;\n       compute_control_dep_chain (cd_root, e->src, dep_chains,\n-\t\t\t\t &num_chains, cur_chain, &num_calls);\n+\t\t\t\t &num_chains, cur_chain, &num_calls, in_region);\n \n       /* Update the newly added chains with the phi operand edge.  */\n       if (EDGE_COUNT (e->src->succs) > 1)\n@@ -2259,6 +2330,10 @@ uninit_analysis::init_from_phi_def (gphi *phi)\n \t}\n     }\n \n+  /* Unmark the region.  */\n+  for (auto bb : region)\n+    bb->flags &= ~in_region;\n+\n   /* Convert control dependence chains to the predicate in *THIS under\n      which the PHI operands are defined to values for which M_EVAL is\n      false.  */"}, {"sha": "d048fa54ce8a69c73e4de56cc598acbc91a65cd3", "filename": "gcc/vec.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/670961f051aedbac21bc769c21c5b28b338b6003/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/670961f051aedbac21bc769c21c5b28b338b6003/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=670961f051aedbac21bc769c21c5b28b338b6003", "patch": "@@ -1469,6 +1469,9 @@ struct vec<T, va_heap, vl_ptr>\n   bool is_empty (void) const\n   { return m_vec ? m_vec->is_empty () : true; }\n \n+  unsigned allocated (void) const\n+  { return m_vec ? m_vec->allocated () : 0; }\n+\n   unsigned length (void) const\n   { return m_vec ? m_vec->length () : 0; }\n "}]}