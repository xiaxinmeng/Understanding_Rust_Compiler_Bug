{"sha": "23847df44028af7bf9b73ce25b38ebb49aeed8c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM4NDdkZjQ0MDI4YWY3YmY5YjczY2UyNWIzOGViYjQ5YWVlZDhjNw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-04-09T14:12:34Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-04-09T14:12:34Z"}, "message": "tree-vect-slp.c (vect_get_and_check_slp_defs): Remove code dealing with cost.\n\n2013-04-09  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Remove code\n\tdealing with cost.\n\t(vect_build_slp_tree): Likewise.\n\t(vect_analyze_slp_cost_1, vect_analyze_slp_cost): New functions\n\tcalculating the cost of a SLP instance.\n\t(vect_analyze_slp_instance): Use it from here, after building\n\tthe SLP tree.\n\nFrom-SVN: r197635", "tree": {"sha": "960957d5817256ef283e46e44e6b3dc5dabcbd06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/960957d5817256ef283e46e44e6b3dc5dabcbd06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23847df44028af7bf9b73ce25b38ebb49aeed8c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23847df44028af7bf9b73ce25b38ebb49aeed8c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23847df44028af7bf9b73ce25b38ebb49aeed8c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23847df44028af7bf9b73ce25b38ebb49aeed8c7/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ea3a0fdefa353d0fd3402cba31f24e1a847ab257", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea3a0fdefa353d0fd3402cba31f24e1a847ab257", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea3a0fdefa353d0fd3402cba31f24e1a847ab257"}], "stats": {"total": 231, "additions": 143, "deletions": 88}, "files": [{"sha": "42823116e0468ff07ecfc6b9a2c2aed2b23eb7b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23847df44028af7bf9b73ce25b38ebb49aeed8c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23847df44028af7bf9b73ce25b38ebb49aeed8c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=23847df44028af7bf9b73ce25b38ebb49aeed8c7", "patch": "@@ -1,3 +1,13 @@\n+2013-04-09  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Remove code\n+\tdealing with cost.\n+\t(vect_build_slp_tree): Likewise.\n+\t(vect_analyze_slp_cost_1, vect_analyze_slp_cost): New functions\n+\tcalculating the cost of a SLP instance.\n+\t(vect_analyze_slp_instance): Use it from here, after building\n+\tthe SLP tree.\n+\n 2013-04-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/56883"}, {"sha": "28f86b3955010bc0f4ae0a3e9bdd3bdede4845a5", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 133, "deletions": 88, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23847df44028af7bf9b73ce25b38ebb49aeed8c7/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23847df44028af7bf9b73ce25b38ebb49aeed8c7/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=23847df44028af7bf9b73ce25b38ebb49aeed8c7", "patch": "@@ -199,20 +199,15 @@ vect_get_place_in_interleaving_chain (gimple stmt, gimple first_stmt)\n \n static bool\n vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n-                             slp_tree slp_node, gimple stmt,\n-\t\t\t     int ncopies_for_cost, bool first,\n-                             vec<slp_oprnd_info> *oprnds_info,\n-\t\t\t     stmt_vector_for_cost *prologue_cost_vec,\n-\t\t\t     stmt_vector_for_cost *body_cost_vec)\n+                             gimple stmt, bool first,\n+                             vec<slp_oprnd_info> *oprnds_info)\n {\n   tree oprnd;\n   unsigned int i, number_of_oprnds;\n   tree def, def_op0 = NULL_TREE;\n   gimple def_stmt;\n   enum vect_def_type dt = vect_uninitialized_def;\n   enum vect_def_type dt_op0 = vect_uninitialized_def;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  tree lhs = gimple_get_lhs (stmt);\n   struct loop *loop = NULL;\n   enum tree_code rhs_code;\n   bool different_types = false;\n@@ -344,22 +339,6 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t    {\n \t      def_op0 = def;\n \t      dt_op0 = dt;\n-\t      /* Analyze costs (for the first stmt of the group only).  */\n-\t      if (REFERENCE_CLASS_P (lhs))\n-\t\t/* Store.  */\n-                vect_model_store_cost (stmt_info, ncopies_for_cost, false,\n-\t\t\t\t       dt, slp_node, prologue_cost_vec,\n-\t\t\t\t       body_cost_vec);\n-\t      else\n-\t\t{\n-\t\t  enum vect_def_type dts[2];\n-\t\t  dts[0] = dt;\n-\t\t  dts[1] = vect_uninitialized_def;\n-\t\t  /* Not memory operation (we don't call this function for\n-\t\t     loads).  */\n-\t\t  vect_model_simple_cost (stmt_info, ncopies_for_cost, dts,\n-\t\t\t\t\t  prologue_cost_vec, body_cost_vec);\n-\t\t}\n \t    }\n \t}\n       else\n@@ -479,13 +458,11 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n static bool\n vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n-                     slp_tree *node, unsigned int group_size, int *outside_cost,\n-                     int ncopies_for_cost, unsigned int *max_nunits,\n+                     slp_tree *node, unsigned int group_size,\n+                     unsigned int *max_nunits,\n                      vec<int> *load_permutation,\n                      vec<slp_tree> *loads,\n-                     unsigned int vectorization_factor, bool *loads_permuted,\n-\t\t     stmt_vector_for_cost *prologue_cost_vec,\n-\t\t     stmt_vector_for_cost *body_cost_vec)\n+                     unsigned int vectorization_factor, bool *loads_permuted)\n {\n   unsigned int i;\n   vec<gimple> stmts = SLP_TREE_SCALAR_STMTS (*node);\n@@ -750,11 +727,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t  if (REFERENCE_CLASS_P (lhs))\n \t    {\n \t      /* Store.  */\n-\t      if (!vect_get_and_check_slp_defs (loop_vinfo, bb_vinfo, *node,\n-\t\t\t\t\t\tstmt, ncopies_for_cost,\n-\t\t\t\t\t\t(i == 0), &oprnds_info,\n-\t\t\t\t\t\tprologue_cost_vec,\n-\t\t\t\t\t\tbody_cost_vec))\n+\t      if (!vect_get_and_check_slp_defs (loop_vinfo, bb_vinfo,\n+\t\t\t\t\t\tstmt, (i == 0), &oprnds_info))\n \t\t{\n \t  \t  vect_free_oprnd_info (oprnds_info);\n  \t\t  return false;\n@@ -863,11 +837,6 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t  \t      vect_free_oprnd_info (oprnds_info);\n                       return false;\n                     }\n-\n-                  /* Analyze costs (for the first stmt in the group).  */\n-                  vect_model_load_cost (vinfo_for_stmt (stmt),\n-                                        ncopies_for_cost, false, *node,\n-\t\t\t\t\tprologue_cost_vec, body_cost_vec);\n                 }\n \n               /* Store the place of this load in the interleaving chain.  In\n@@ -943,10 +912,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n             }\n \n \t  /* Find the def-stmts.  */\n-\t  if (!vect_get_and_check_slp_defs (loop_vinfo, bb_vinfo, *node, stmt,\n-\t\t\t\t\t    ncopies_for_cost, (i == 0),\n-\t\t\t\t\t    &oprnds_info, prologue_cost_vec,\n-\t\t\t\t\t    body_cost_vec))\n+\t  if (!vect_get_and_check_slp_defs (loop_vinfo, bb_vinfo, stmt,\n+\t\t\t\t\t    (i == 0), &oprnds_info))\n \t    {\n \t      vect_free_oprnd_info (oprnds_info);\n \t      return false;\n@@ -959,12 +926,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n     {\n       loads->safe_push (*node);\n       if (permutation)\n-        {\n-\t  gimple first_stmt = stmts[0];\n-          *loads_permuted = true;\n-\t  (void) record_stmt_cost (body_cost_vec, group_size, vec_perm, \n-\t\t\t\t   vinfo_for_stmt (first_stmt), 0, vect_body);\n-        }\n+\t*loads_permuted = true;\n       else\n         {\n           /* We don't check here complex numbers chains, so we set\n@@ -989,10 +951,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       child = vect_create_new_slp_node (oprnd_info->def_stmts);\n       if (!child\n           || !vect_build_slp_tree (loop_vinfo, bb_vinfo, &child, group_size,\n-\t\t\t\t   outside_cost, ncopies_for_cost,\n \t\t\t\t   max_nunits, load_permutation, loads,\n-\t\t\t\t   vectorization_factor, loads_permuted,\n-\t\t\t\t   prologue_cost_vec, body_cost_vec))\n+\t\t\t\t   vectorization_factor, loads_permuted))\n         {\n \t  if (child)\n \t    oprnd_info->def_stmts = vNULL;\n@@ -1510,6 +1470,122 @@ vect_find_last_store_in_slp_instance (slp_instance instance)\n   return last_store;\n }\n \n+/* Compute the cost for the SLP node NODE in the SLP instance INSTANCE.  */\n+\n+static void\n+vect_analyze_slp_cost_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n+\t\t\t slp_instance instance, slp_tree node,\n+\t\t\t stmt_vector_for_cost *prologue_cost_vec,\n+\t\t\t unsigned ncopies_for_cost)\n+{\n+  stmt_vector_for_cost *body_cost_vec = &SLP_INSTANCE_BODY_COST_VEC (instance);\n+\n+  unsigned i;\n+  slp_tree child;\n+  gimple stmt, s;\n+  stmt_vec_info stmt_info;\n+  tree lhs;\n+  unsigned group_size = SLP_INSTANCE_GROUP_SIZE (instance);\n+\n+  /* Recurse down the SLP tree.  */\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+    vect_analyze_slp_cost_1 (loop_vinfo, bb_vinfo,\n+\t\t\t     instance, child, prologue_cost_vec,\n+\t\t\t     ncopies_for_cost);\n+\n+  /* Look at the first scalar stmt to determine the cost.  */\n+  stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n+  stmt_info = vinfo_for_stmt (stmt);\n+  if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n+    {\n+      if (DR_IS_WRITE (STMT_VINFO_DATA_REF (stmt_info)))\n+\tvect_model_store_cost (stmt_info, ncopies_for_cost, false,\n+\t\t\t       vect_uninitialized_def,\n+\t\t\t       node, prologue_cost_vec, body_cost_vec);\n+      else\n+\t{\n+\t  int i;\n+\t  gcc_checking_assert (DR_IS_READ (STMT_VINFO_DATA_REF (stmt_info)));\n+\t  vect_model_load_cost (stmt_info, ncopies_for_cost, false,\n+\t\t\t\tnode, prologue_cost_vec, body_cost_vec);\n+\t  /* If the load is permuted record the cost for the permutation.\n+\t     ???  Loads from multiple chains are let through here only\n+\t     for a single special case involving complex numbers where\n+\t     in the end no permutation is necessary.  */\n+\t  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, s)\n+\t    if ((STMT_VINFO_GROUP_FIRST_ELEMENT (vinfo_for_stmt (s))\n+\t\t == STMT_VINFO_GROUP_FIRST_ELEMENT (stmt_info))\n+\t\t&& vect_get_place_in_interleaving_chain\n+\t\t     (s, STMT_VINFO_GROUP_FIRST_ELEMENT (stmt_info)) != i)\n+\t      {\n+\t\trecord_stmt_cost (body_cost_vec, group_size, vec_perm,\n+\t\t\t\t  stmt_info, 0, vect_body);\n+\t\tbreak;\n+\t      }\n+\t}\n+    }\n+  else\n+    record_stmt_cost (body_cost_vec, ncopies_for_cost, vector_stmt,\n+\t\t      stmt_info, 0, vect_body);\n+\n+  /* Scan operands and account for prologue cost of constants/externals.\n+     ???  This over-estimates cost for multiple uses and should be\n+     re-engineered.  */\n+  lhs = gimple_get_lhs (stmt);\n+  for (i = 0; i < gimple_num_ops (stmt); ++i)\n+    {\n+      tree def, op = gimple_op (stmt, i);\n+      gimple def_stmt;\n+      enum vect_def_type dt;\n+      if (!op || op == lhs)\n+\tcontinue;\n+      if (vect_is_simple_use (op, NULL, loop_vinfo, bb_vinfo,\n+\t\t\t      &def_stmt, &def, &dt)\n+\t  && (dt == vect_constant_def || dt == vect_external_def))\n+\trecord_stmt_cost (prologue_cost_vec, 1, vector_stmt,\n+\t\t\t  stmt_info, 0, vect_prologue);\n+    }\n+}\n+\n+/* Compute the cost for the SLP instance INSTANCE.  */\n+\n+static void\n+vect_analyze_slp_cost (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n+\t\t       slp_instance instance, unsigned nunits)\n+{\n+  stmt_vector_for_cost body_cost_vec, prologue_cost_vec;\n+  unsigned ncopies_for_cost;\n+  stmt_info_for_cost *si;\n+  unsigned i;\n+\n+  /* Calculate the number of vector stmts to create based on the unrolling\n+     factor (number of vectors is 1 if NUNITS >= GROUP_SIZE, and is\n+     GROUP_SIZE / NUNITS otherwise.  */\n+  unsigned group_size = SLP_INSTANCE_GROUP_SIZE (instance);\n+  ncopies_for_cost = least_common_multiple (nunits, group_size) / nunits;\n+\n+  prologue_cost_vec.create (10);\n+  body_cost_vec.create (10);\n+  SLP_INSTANCE_BODY_COST_VEC (instance) = body_cost_vec;\n+  vect_analyze_slp_cost_1 (loop_vinfo, bb_vinfo,\n+\t\t\t   instance, SLP_INSTANCE_TREE (instance),\n+\t\t\t   &prologue_cost_vec, ncopies_for_cost);\n+\n+  /* Record the prologue costs, which were delayed until we were\n+     sure that SLP was successful.  Unlike the body costs, we know\n+     the final values now regardless of the loop vectorization factor.  */\n+  void *data = (loop_vinfo ? LOOP_VINFO_TARGET_COST_DATA (loop_vinfo)\n+\t\t: BB_VINFO_TARGET_COST_DATA (bb_vinfo));\n+  FOR_EACH_VEC_ELT (prologue_cost_vec, i, si)\n+    {\n+      struct _stmt_vec_info *stmt_info\n+\t= si->stmt ? vinfo_for_stmt (si->stmt) : NULL;\n+      (void) add_stmt_cost (data, si->count, si->kind, stmt_info,\n+\t\t\t    si->misalign, vect_prologue);\n+    }\n+\n+  prologue_cost_vec.release ();\n+}\n \n /* Analyze an SLP instance starting from a group of grouped stores.  Call\n    vect_build_slp_tree to build a tree of packed stmts if possible.\n@@ -1526,15 +1602,13 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   tree vectype, scalar_type = NULL_TREE;\n   gimple next;\n   unsigned int vectorization_factor = 0;\n-  int outside_cost = 0, ncopies_for_cost, i;\n+  int i;\n   unsigned int max_nunits = 0;\n   vec<int> load_permutation;\n   vec<slp_tree> loads;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt));\n   bool loads_permuted = false;\n   vec<gimple> scalar_stmts;\n-  stmt_vector_for_cost body_cost_vec, prologue_cost_vec;\n-  stmt_info_for_cost *si;\n \n   if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n     {\n@@ -1615,26 +1689,14 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n   node = vect_create_new_slp_node (scalar_stmts);\n \n-  /* Calculate the number of vector stmts to create based on the unrolling\n-     factor (number of vectors is 1 if NUNITS >= GROUP_SIZE, and is\n-     GROUP_SIZE / NUNITS otherwise.  */\n-  ncopies_for_cost = unrolling_factor * group_size / nunits;\n-\n   load_permutation.create (group_size * group_size);\n   loads.create (group_size);\n-  prologue_cost_vec.create (10);\n-  body_cost_vec.create (10);\n \n   /* Build the tree for the SLP instance.  */\n   if (vect_build_slp_tree (loop_vinfo, bb_vinfo, &node, group_size,\n-                           &outside_cost, ncopies_for_cost,\n \t\t\t   &max_nunits, &load_permutation, &loads,\n-\t\t\t   vectorization_factor, &loads_permuted,\n-\t\t\t   &prologue_cost_vec, &body_cost_vec))\n+\t\t\t   vectorization_factor, &loads_permuted))\n     {\n-      void *data = (loop_vinfo ? LOOP_VINFO_TARGET_COST_DATA (loop_vinfo)\n-\t\t    : BB_VINFO_TARGET_COST_DATA (bb_vinfo));\n-\n       /* Calculate the unrolling factor based on the smallest type.  */\n       if (max_nunits > nunits)\n         unrolling_factor = least_common_multiple (max_nunits, group_size)\n@@ -1647,8 +1709,6 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t     \"Build SLP failed: unrolling required in basic\"\n \t\t\t     \" block SLP\");\n \t  vect_free_slp_tree (node);\n-\t  body_cost_vec.release ();\n-\t  prologue_cost_vec.release ();\n \t  load_permutation.release ();\n \t  loads.release ();\n           return false;\n@@ -1659,7 +1719,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       SLP_INSTANCE_TREE (new_instance) = node;\n       SLP_INSTANCE_GROUP_SIZE (new_instance) = group_size;\n       SLP_INSTANCE_UNROLLING_FACTOR (new_instance) = unrolling_factor;\n-      SLP_INSTANCE_BODY_COST_VEC (new_instance) = body_cost_vec;\n+      SLP_INSTANCE_BODY_COST_VEC (new_instance) = vNULL;\n       SLP_INSTANCE_LOADS (new_instance) = loads;\n       SLP_INSTANCE_FIRST_LOAD_STMT (new_instance) = NULL;\n       SLP_INSTANCE_LOAD_PERMUTATION (new_instance) = load_permutation;\n@@ -1678,7 +1738,6 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                 }\n \n               vect_free_slp_instance (new_instance);\n-\t      prologue_cost_vec.release ();\n               return false;\n             }\n \n@@ -1688,18 +1747,9 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       else\n         SLP_INSTANCE_LOAD_PERMUTATION (new_instance).release ();\n \n-      /* Record the prologue costs, which were delayed until we were\n-\t sure that SLP was successful.  Unlike the body costs, we know\n-\t the final values now regardless of the loop vectorization factor.  */\n-      FOR_EACH_VEC_ELT (prologue_cost_vec, i, si)\n-\t{\n-\t  struct _stmt_vec_info *stmt_info\n-\t    = si->stmt ? vinfo_for_stmt (si->stmt) : NULL;\n-\t  (void) add_stmt_cost (data, si->count, si->kind, stmt_info,\n-\t\t\t\tsi->misalign, vect_prologue);\n-\t}\n-\n-      prologue_cost_vec.release ();\n+      /* Compute the costs of this SLP instance.  */\n+      vect_analyze_slp_cost (loop_vinfo, bb_vinfo,\n+\t\t\t     new_instance, TYPE_VECTOR_SUBPARTS (vectype));\n \n       if (loop_vinfo)\n         LOOP_VINFO_SLP_INSTANCES (loop_vinfo).safe_push (new_instance);\n@@ -1711,11 +1761,6 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n       return true;\n     }\n-  else\n-    {\n-      body_cost_vec.release ();\n-      prologue_cost_vec.release ();\n-    }\n \n   /* Failed to SLP.  */\n   /* Free the allocated memory.  */"}]}