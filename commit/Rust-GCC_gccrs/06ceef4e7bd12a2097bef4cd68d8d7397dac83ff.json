{"sha": "06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZjZWVmNGU3YmQxMmEyMDk3YmVmNGNkNjhkOGQ3Mzk3ZGFjODNmZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-02-20T01:11:00Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-02-20T01:11:00Z"}, "message": "c-common.c (decl_attributes): Set DECL_SIZE_UNIT.\n\n\t* c-common.c (decl_attributes): Set DECL_SIZE_UNIT.\n\t* c-decl.c (duplicate_decls, finish_enum): Likewise.\n\t(finish_decl): Remove -Wlarger-than code from here.\n\t* flags.h (id_clash_len): Now int.\n\t(larger_than_size): Now HOST_WIDE_INT.\n\t* fold-const.c (size_int_wide): No more HIGH parm; NUMBER is signed.\n\tClean up checking to see if in table.\n\t(make_bit_field_ref): Remove extra parm to bitsize_int.\n\t* ggc-common.c (ggc_mark_tree_children): Mark DECL_SIZE_UNIT.\n\t* print-tree.c (print_node): Print DECL_SIZE_UNIT and TYPE_SIZE_UNIT.\n\t* stmt.c (expand_decl): Use DECL_SIZE_UNIT for stack checking size\n\tand for computing size of decl.\n\t* stor-layout.c (layout_decl): Set DECL_SIZE_UNIT.\n\tMove -Wlarger-than code to here.\n\t(layout_record): Remove extra arg to bitsize_int.\n\tSet TYPE_BINFO_SIZE_UNIT.\n\t(layout_union): Remove extra arg to bitsize_int.\n\tUse proper type for size of QUAL_UNION.\n\t(layout_type): Remove extra arg to bitsize_int.\n\t* toplev.c (id_clash_len): Now int.\n\t(larger_than_size): Now HOST_WIDE_INT.\n\t(decode_W_option): Clean up id-clash and larger-than- cases.\n\t* tree.c (get_identifier, maybe_get_identifier): Remove unneeded casts.\n\t(expr_align, case FUNCTION_DECL): DECL_ALIGN is not defined.\n\t* tree.h (BINFO_SIZE_UNIT, TYPE_BINFO_SIZE_UNIT, DECL_SIZE_UNIT): New.\n\t(struct tree_decl): New field size_unit.\n\t(size_int_wide): No HIGH operand; NUMBER is now signed.\n\t(size_int_2): Deleted.\n\t(size_int, bitsize_int): Don't use it and rework args.\n\t* varasm.c (assemble_variable, output_constructor): Use DECL_SIZE_UNIT.\n\t* ch/decl.c (layout_enum): Set DECL_SIZE_UNIT.\n\t* ch/satisfy.c (safe_satisfy_decl): Likewise.\n\t* cp/class.c (build_primary_vtable, layout_vtable_decl): Likewise.\n\t(avoid_overlap, build_base_field): Likewise.\n\t(build_base_field, build_base_fields, is_empty_class):\n\tTest DECL_SIZE with integer_zero.\n\t(layout_class_type): Set CLASSTYPE_SIZE_UNIT.\n\t* cp/cp-tree.h (struct lang_type): New field size_unit.\n\t(CLASSTYPE_SIZE_UNIT): New macro.\n\t* cp/decl.c (init_decl_processing): Set DECL_SIZE_UNIT.\n\t(cp_finish_decl): Delete -Wlarger-than processing.\n\t* cp/optimize.c (remap_decl): Walk DECL_SIZE_UNIT.\n\t* cp/pt.c (tsubst_decl): Set DECL_SIZE_UNIT.\n\t* cp/tree.c (make_binfo): binfo vector is one entry longer.\n\t(walk_tree): Walk DECL_SIZE_UNIT.\n\t* f/com.c (ffecom_sym_transform): Use DECL_SIZE_UNIT.\n\t(ffecom_transform_common_, ffecom_transform_equiv_): Likewise.\n\t(duplicate_decls): Likewise.\n\t(ffecom_tree_canonize_ptr_): Delete extra arg to bitsize_int.\n\t(finish_decl): Delete -Wlarger-than processing.\n\t* java/class.c (build_class_ref, push_super_field): Set DECL_SIZE_UNIT.\n\t* java/constants.c (build_constants_constructor): Likewise.\n\nFrom-SVN: r32068", "tree": {"sha": "7f6c09091ffe927c1ab220b0ad2180cb341a9a84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f6c09091ffe927c1ab220b0ad2180cb341a9a84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/comments", "author": null, "committer": null, "parents": [{"sha": "ccd4c273d9fd62fa7d57061387ad73ffb1043aa0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccd4c273d9fd62fa7d57061387ad73ffb1043aa0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccd4c273d9fd62fa7d57061387ad73ffb1043aa0"}], "stats": {"total": 581, "additions": 312, "deletions": 269}, "files": [{"sha": "76b64cbb45d71a931d27e1bfc3714b59ae4ce9ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,3 +1,58 @@\n+Sat Feb 19 18:43:13 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* c-common.c (decl_attributes): Set DECL_SIZE_UNIT.\n+\t* c-decl.c (duplicate_decls, finish_enum): Likewise.\n+\t(finish_decl): Remove -Wlarger-than code from here.\n+\t* flags.h (id_clash_len): Now int.\n+\t(larger_than_size): Now HOST_WIDE_INT.\n+\t* fold-const.c (size_int_wide): No more HIGH parm; NUMBER is signed.\n+\tClean up checking to see if in table.\n+\t(make_bit_field_ref): Remove extra parm to bitsize_int.\n+\t* ggc-common.c (ggc_mark_tree_children): Mark DECL_SIZE_UNIT.\n+\t* print-tree.c (print_node): Print DECL_SIZE_UNIT and TYPE_SIZE_UNIT.\n+\t* stmt.c (expand_decl): Use DECL_SIZE_UNIT for stack checking size\n+\tand for computing size of decl.\n+\t* stor-layout.c (layout_decl): Set DECL_SIZE_UNIT.\n+\tMove -Wlarger-than code to here.\n+\t(layout_record): Remove extra arg to bitsize_int.\n+\tSet TYPE_BINFO_SIZE_UNIT.\n+\t(layout_union): Remove extra arg to bitsize_int.\n+\tUse proper type for size of QUAL_UNION.\n+\t(layout_type): Remove extra arg to bitsize_int.\n+\t* toplev.c (id_clash_len): Now int.\n+\t(larger_than_size): Now HOST_WIDE_INT.\n+\t(decode_W_option): Clean up id-clash and larger-than- cases.\n+\t* tree.c (get_identifier, maybe_get_identifier): Remove unneeded casts.\n+\t(expr_align, case FUNCTION_DECL): DECL_ALIGN is not defined.\n+\t* tree.h (BINFO_SIZE_UNIT, TYPE_BINFO_SIZE_UNIT, DECL_SIZE_UNIT): New.\n+\t(struct tree_decl): New field size_unit.\n+\t(size_int_wide): No HIGH operand; NUMBER is now signed.\n+\t(size_int_2): Deleted.\n+\t(size_int, bitsize_int): Don't use it and rework args.\n+\t* varasm.c (assemble_variable, output_constructor): Use DECL_SIZE_UNIT.\n+\t* ch/decl.c (layout_enum): Set DECL_SIZE_UNIT.\t\n+\t* ch/satisfy.c (safe_satisfy_decl): Likewise.\n+\t* cp/class.c (build_primary_vtable, layout_vtable_decl): Likewise.\n+\t(avoid_overlap, build_base_field): Likewise.\n+\t(build_base_field, build_base_fields, is_empty_class): \n+\tTest DECL_SIZE with integer_zero.\n+\t(layout_class_type): Set CLASSTYPE_SIZE_UNIT.\n+\t* cp/cp-tree.h (struct lang_type): New field size_unit.\n+\t(CLASSTYPE_SIZE_UNIT): New macro.\n+\t* cp/decl.c (init_decl_processing): Set DECL_SIZE_UNIT.\n+\t(cp_finish_decl): Delete -Wlarger-than processing.\n+\t* cp/optimize.c (remap_decl): Walk DECL_SIZE_UNIT.\n+\t* cp/pt.c (tsubst_decl): Set DECL_SIZE_UNIT.\n+\t* cp/tree.c (make_binfo): binfo vector is one entry longer.\n+\t(walk_tree): Walk DECL_SIZE_UNIT.\n+\t* f/com.c (ffecom_sym_transform): Use DECL_SIZE_UNIT.\n+\t(ffecom_transform_common_, ffecom_transform_equiv_): Likewise.\n+\t(duplicate_decls): Likewise.\n+\t(ffecom_tree_canonize_ptr_): Delete extra arg to bitsize_int.\n+\t(finish_decl): Delete -Wlarger-than processing.\n+\t* java/class.c (build_class_ref, push_super_field): Set DECL_SIZE_UNIT.\n+\t* java/constants.c (build_constants_constructor): Likewise.\n+\n Fri Feb 18 20:01:58 2000  Jeffrey A Law  (law@cygnus.com)\n \n \t* pa/quadlib.asm (_U_QFgt, _U_Qfge): Fix flags for _U_Qfcmp call."}, {"sha": "815c8e1a601c9d53806627fd497ee1010d074464", "filename": "gcc/c-common.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,5 +1,6 @@\n /* Subroutines shared by all languages that are variants of C.\n-   Copyright (C) 1992, 93-98, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -733,7 +734,7 @@ decl_attributes (node, attributes, prefix_attributes)\n \t      else\n \t\t{\n \t\t  TREE_TYPE (decl) = type = typefm;\n-\t\t  DECL_SIZE (decl) = 0;\n+\t\t  DECL_SIZE (decl) = DECL_SIZE_UNIT (decl) = 0;\n \t\t  layout_decl (decl, 0);\n \t\t}\n \t    }"}, {"sha": "87fcef8a5006ec11a4e59f70f48c9576297056e7", "filename": "gcc/c-decl.c", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,5 +1,6 @@\n /* Process declarations and variables for C compiler.\n-   Copyright (C) 1988, 92-99, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -1796,6 +1797,7 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t{\n \t  /* Since the type is OLDDECL's, make OLDDECL's size go with.  */\n \t  DECL_SIZE (newdecl) = DECL_SIZE (olddecl);\n+\t  DECL_SIZE_UNIT (newdecl) = DECL_SIZE_UNIT (olddecl);\n \t  DECL_MODE (newdecl) = DECL_MODE (olddecl);\n \t  if (TREE_CODE (olddecl) != FUNCTION_DECL)\n \t    if (DECL_ALIGN (olddecl) > DECL_ALIGN (newdecl))\n@@ -3477,8 +3479,7 @@ finish_decl (decl, init, asmspec_tree)\n \n   if (TREE_CODE (decl) == VAR_DECL)\n     {\n-      if (DECL_SIZE (decl) == 0\n-\t  && TYPE_SIZE (TREE_TYPE (decl)) != 0)\n+      if (DECL_SIZE (decl) == 0 && TYPE_SIZE (TREE_TYPE (decl)) != 0)\n \tlayout_decl (decl, 0);\n \n       if (DECL_SIZE (decl) == 0\n@@ -3565,23 +3566,6 @@ finish_decl (decl, init, asmspec_tree)\n       rest_of_decl_compilation (decl, NULL_PTR, DECL_CONTEXT (decl) == 0, 0);\n     }\n \n-  /* If requested, warn about definitions of large data objects.  */\n-\n-  if (warn_larger_than\n-      && (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL)\n-      && !DECL_EXTERNAL (decl))\n-    {\n-      register tree decl_size = DECL_SIZE (decl);\n-\n-      if (decl_size && TREE_CODE (decl_size) == INTEGER_CST)\n-\t{\n-\t   unsigned units = TREE_INT_CST_LOW(decl_size) / BITS_PER_UNIT;\n-\n-\t  if (units > larger_than_size)\n-\t    warning_with_decl (decl, \"size of `%s' is %u bytes\", units);\n-\t}\n-    }\n-\n   /* At the end of a declaration, throw away any variable type sizes\n      of types defined inside that declaration.  There is no use\n      computing them in the following function definition.  */\n@@ -5497,6 +5481,7 @@ finish_enum (enumtype, values, attributes)\n \n \t  TREE_TYPE (enu) = enumtype;\n \t  DECL_SIZE (enu) = TYPE_SIZE (enumtype);\n+\t  DECL_SIZE_UNIT (enu) = TYPE_SIZE_UNIT (enumtype);\n \t  DECL_ALIGN (enu) = TYPE_ALIGN (enumtype);\n \t  DECL_MODE (enu) = TYPE_MODE (enumtype);\n \t  DECL_INITIAL (enu) = convert (enumtype, DECL_INITIAL (enu));"}, {"sha": "7a5941ec628349a39147aadb1a7df7cf4d994230", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 3, "deletions": 38, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,5 +1,6 @@\n /* Build expressions with type checking for C compiler.\n-   Copyright (C) 1987, 88, 91-99, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1996, 1997,\n+   1998, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -3498,43 +3499,6 @@ build_conditional_expr (ifexp, op1, op2)\n   if (result_type != TREE_TYPE (op2))\n     op2 = convert_and_check (result_type, op2);\n     \n-#if 0\n-  if (code1 == RECORD_TYPE || code1 == UNION_TYPE)\n-    {\n-      result_type = TREE_TYPE (op1);\n-      if (TREE_CONSTANT (ifexp))\n-\treturn pedantic_non_lvalue (integer_zerop (ifexp) ? op2 : op1);\n-\n-      if (TYPE_MODE (result_type) == BLKmode)\n-\t{\n-\t  register tree tempvar\n-\t    = build_decl (VAR_DECL, NULL_TREE, result_type);\n-\t  register tree xop1 = build_modify_expr (tempvar, op1);\n-\t  register tree xop2 = build_modify_expr (tempvar, op2);\n-\t  register tree result = fold (build (COND_EXPR, result_type,\n-\t\t\t\t\t      ifexp, xop1, xop2));\n-\n-\t  layout_decl (tempvar, TYPE_ALIGN (result_type));\n-\t  /* No way to handle variable-sized objects here.\n-\t     I fear that the entire handling of BLKmode conditional exprs\n-\t     needs to be redone.  */\n-\t  if (TREE_CODE (DECL_SIZE (tempvar)) != INTEGER_CST)\n-\t    abort ();\n-\t  DECL_RTL (tempvar)\n-\t    = assign_stack_local (DECL_MODE (tempvar),\n-\t\t\t\t  (TREE_INT_CST_LOW (DECL_SIZE (tempvar))\n-\t\t\t\t   + BITS_PER_UNIT - 1)\n-\t\t\t\t  / BITS_PER_UNIT,\n-\t\t\t\t  0);\n-\n-\t  TREE_SIDE_EFFECTS (result)\n-\t    = TREE_SIDE_EFFECTS (ifexp) | TREE_SIDE_EFFECTS (op1)\n-\t      | TREE_SIDE_EFFECTS (op2);\n-\t  return build (COMPOUND_EXPR, result_type, result, tempvar);\n-\t}\n-    }\n-#endif /* 0 */\n-    \n   if (TREE_CODE (ifexp) == INTEGER_CST)\n     return pedantic_non_lvalue (integer_zerop (ifexp) ? op2 : op1);\n \n@@ -5985,6 +5949,7 @@ output_init_element (value, type, field, pending)\n \t\t{\n \t\t  tree temp = size_binop (PLUS_EXPR, DECL_FIELD_BITPOS (field),\n \t\t\t\t\t  DECL_SIZE (field));\n+\n \t\t  TREE_INT_CST_LOW (constructor_bit_index)\n \t\t    = TREE_INT_CST_LOW (temp);\n \t\t  TREE_INT_CST_HIGH (constructor_bit_index)"}, {"sha": "ffda9abeabfbfe84f8c257ae1833355909f1a608", "filename": "gcc/ch/decl.c", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fch%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fch%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fdecl.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,21 +1,22 @@\n /* Process declarations and variables for GNU CHILL compiler.\n-   Copyright (C) 1992, 93, 94, 98, 99, 2000 Free Software Foundation, Inc. \n+   Copyright (C) 1992, 1993, 1994, 1998, 1999, 2000\n+   Free Software Foundation, Inc. \n    \n-   This file is part of GNU CC.\n-   \n-   GNU CC is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 2, or (at your option)\n-   any later version.\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n    \n-   GNU CC is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n    \n-   You should have received a copy of the GNU General Public License\n-   along with GNU CC; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330,\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n \n@@ -4606,7 +4607,9 @@ layout_enum (enumtype)\n   for (pair = values; pair; pair = TREE_CHAIN (pair))\n     {\n       tree decl = TREE_VALUE (pair);\n+\n       DECL_SIZE (decl) = TYPE_SIZE (enumtype);\n+      DECL_SIZE_UNIT (decl) = TYPE_SIZE_UNIT (enumtype);\n       DECL_ALIGN (decl) = TYPE_ALIGN (enumtype);\n \n       /* Set the TREE_VALUE to the name, rather than the decl,"}, {"sha": "fa300302c291956033f68d65f01dcab463dfdd73", "filename": "gcc/ch/satisfy.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fch%2Fsatisfy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fch%2Fsatisfy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fsatisfy.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,5 +1,5 @@\n /* Name-satisfaction for GNU Chill compiler.\n-   Copyright (C) 1993, 98, 99, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1998, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -186,6 +186,8 @@ safe_satisfy_decl (decl, prev_chain)\n \t\t}\n \t      /* DECL_SIZE is set to prevent re-doing this stuff. */\n \t      DECL_SIZE (decl) = TYPE_SIZE (TREE_TYPE (decl));\n+\t      DECL_SIZE_UNIT (decl) = TYPE_SIZE_UNIT (TREE_TYPE (decl));\n+\n \t      if (! TREE_CONSTANT (DECL_INITIAL (decl))\n \t\t  && TREE_CODE (DECL_INITIAL (decl)) != ERROR_MARK)\n \t\t{"}, {"sha": "a8ba1bda8aa5e4a35e465df43ea9a8d087599f26", "filename": "gcc/cp/class.c", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,5 +1,6 @@\n /* Functions related to building classes and their related objects.\n-   Copyright (C) 1987, 92-99, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+   1999, 2000 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -1068,6 +1069,8 @@ build_primary_vtable (binfo, type)\n       virtuals = copy_list (BINFO_VIRTUALS (binfo));\n       TREE_TYPE (decl) = TREE_TYPE (BINFO_VTABLE (binfo));\n       DECL_SIZE (decl) = TYPE_SIZE (TREE_TYPE (BINFO_VTABLE (binfo)));\n+      DECL_SIZE_UNIT (decl)\n+\t= TYPE_SIZE_UNIT (TREE_TYPE (BINFO_VTABLE (binfo)));\n \n       /* Now do rtti stuff.  */\n       offset = get_derived_offset (TYPE_BINFO (type), NULL_TREE);\n@@ -2529,14 +2532,16 @@ layout_vtable_decl (binfo, n)\n   /* We may have to grow the vtable.  */\n   if (!same_type_p (TREE_TYPE (BINFO_VTABLE (binfo)), atype))\n     {\n-      TREE_TYPE (BINFO_VTABLE (binfo)) = atype;\n-      DECL_SIZE (BINFO_VTABLE (binfo)) = 0;\n-      layout_decl (BINFO_VTABLE (binfo), 0);\n+      tree vtable = BINFO_VTABLE (binfo);\n+\n+      TREE_TYPE (vtable) = atype;\n+      DECL_SIZE (vtable) = DECL_SIZE_UNIT (vtable) = 0;\n+      layout_decl (vtable, 0);\n+\n       /* At one time the vtable info was grabbed 2 words at a time.  This\n-\t fails on sparc unless you have 8-byte alignment.  (tiemann) */\n-      DECL_ALIGN (BINFO_VTABLE (binfo))\n-\t= MAX (TYPE_ALIGN (double_type_node),\n-\t       DECL_ALIGN (BINFO_VTABLE (binfo)));\n+\t fails on Sparc unless you have 8-byte alignment.  */\n+      DECL_ALIGN (vtable) = MAX (TYPE_ALIGN (double_type_node),\n+\t\t\t\t DECL_ALIGN (vtable));\n     }\n }\n \n@@ -4030,7 +4035,8 @@ avoid_overlap (decl, newdecl, empty_p)\n        field = TREE_CHAIN (field))\n     ;\n \n-  DECL_SIZE (field) = integer_one_node;\n+  DECL_SIZE (field) = bitsize_int (1);\n+  DECL_SIZE_UNIT (field) = 0;\n   /* The containing class cannot be empty; this field takes up space.  */\n   *empty_p = 0;\n \n@@ -4062,9 +4068,10 @@ build_base_field (t, binfo, empty_p, saw_empty_p, base_align)\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_FIELD_CONTEXT (decl) = t;\n   DECL_SIZE (decl) = CLASSTYPE_SIZE (basetype);\n+  DECL_SIZE_UNIT (decl) = CLASSTYPE_SIZE_UNIT (basetype);\n   DECL_ALIGN (decl) = CLASSTYPE_ALIGN (basetype);\n   \n-  if (flag_new_abi && DECL_SIZE (decl) == integer_zero_node)\n+  if (flag_new_abi && integer_zerop (DECL_SIZE (decl)))\n     {\n       *saw_empty_p = 1;\n       return decl;\n@@ -4085,6 +4092,9 @@ build_base_field (t, binfo, empty_p, saw_empty_p, base_align)\n       DECL_SIZE (decl)\n \t= size_int (MAX (TREE_INT_CST_LOW (DECL_SIZE (decl)),\n \t\t\t (int) (*base_align)));\n+      DECL_SIZE_UNIT (decl)\n+\t= size_int (MAX (TREE_INT_CST_LOW (DECL_SIZE_UNIT (decl)),\n+\t\t\t (int) *base_align / BITS_PER_UNIT));\n     }\n \n   return decl;\n@@ -4156,17 +4166,15 @@ build_base_fields (rec, empty_p)\n   if (flag_new_abi && saw_empty)\n     for (decl = base_decls; decl; decl = TREE_CHAIN (decl))\n       {\n-\tif (DECL_SIZE (decl) == integer_zero_node)\n+\tif (integer_zerop (DECL_SIZE (decl)))\n \t  {\n \t    /* First step through the following bases until we find\n \t       an overlap or a non-empty base.  */\n \t    for (nextdecl = TREE_CHAIN (decl); nextdecl;\n \t\t nextdecl = TREE_CHAIN (nextdecl))\n-\t      {\n-\t\tif (avoid_overlap (decl, nextdecl, empty_p)\n-\t\t    || DECL_SIZE (nextdecl) != integer_zero_node)\n-\t\t  goto nextbase;\n-\t      }\n+\t      if (avoid_overlap (decl, nextdecl, empty_p)\n+\t\t  || ! integer_zerop (DECL_SIZE (nextdecl)))\n+\t\tgoto nextbase;\n \n \t    /* If we're still looking, also check against the first\n \t       field.  */\n@@ -4822,12 +4830,22 @@ layout_class_type (t, empty_p, has_virtual_p,\n   /* Remember the size and alignment of the class before adding\n      the virtual bases.  */\n   if (*empty_p && flag_new_abi)\n-    CLASSTYPE_SIZE (t) = integer_zero_node;\n+    {\n+      CLASSTYPE_SIZE (t) = bitsize_int (0);\n+      CLASSTYPE_SIZE_UNIT (t) = size_int (0);\n+    }\n   else if (flag_new_abi && TYPE_HAS_COMPLEX_INIT_REF (t)\n \t   && TYPE_HAS_COMPLEX_ASSIGN_REF (t))\n-    CLASSTYPE_SIZE (t) = TYPE_BINFO_SIZE (t);\n+    {\n+      CLASSTYPE_SIZE (t) = TYPE_BINFO_SIZE (t);\n+      CLASSTYPE_SIZE_UNIT (t) = TYPE_BINFO_SIZE_UNIT (t);\n+    }\n   else\n-    CLASSTYPE_SIZE (t) = TYPE_SIZE (t);\n+    {\n+      CLASSTYPE_SIZE (t) = TYPE_SIZE (t);\n+      CLASSTYPE_SIZE_UNIT (t) = TYPE_SIZE_UNIT (t);\n+    }\n+\n   CLASSTYPE_ALIGN (t) = TYPE_ALIGN (t);\n \n   /* Set the TYPE_DECL for this type to contain the right\n@@ -6217,7 +6235,7 @@ is_empty_class (type)\n     return 0;\n \n   if (flag_new_abi)\n-    return CLASSTYPE_SIZE (type) == integer_zero_node;\n+    return integer_zerop (CLASSTYPE_SIZE (type));\n \n   if (TYPE_BINFO_BASETYPES (type))\n     return 0;"}, {"sha": "f560de972074be8a672be0fde570b525243e68ff", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,6 +1,7 @@\n /* Definitions for C++ parsing and type checking.\n-   Copyright (C) 1987, 92-97, 1998, 1999, 2000 Free Software Foundation, Inc.\n-   Hacked by Michael Tiemann (tiemann@cygnus.com)\n+   Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n+   Free Software Foundation, Inc.\n+   Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n \n@@ -1358,6 +1359,7 @@ struct lang_type\n   union tree_node *search_slot;\n \n   union tree_node *size;\n+  union tree_node *size_unit;\n \n   union tree_node *pure_virtuals;\n   union tree_node *friend_classes;\n@@ -1561,6 +1563,7 @@ struct lang_type\n /* These are the size, mode and alignment of the type without its\n    virtual base classes, for when we use this type as a base itself.  */\n #define CLASSTYPE_SIZE(NODE) (TYPE_LANG_SPECIFIC(NODE)->size)\n+#define CLASSTYPE_SIZE_UNIT(NODE) (TYPE_LANG_SPECIFIC(NODE)->size_unit)\n #define CLASSTYPE_ALIGN(NODE) (TYPE_LANG_SPECIFIC(NODE)->align)\n \n /* A cons list of virtual functions which cannot be inherited by"}, {"sha": "a948c30e59a856cb4667d7a6e52c05649a92d493", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,5 +1,6 @@\n /* Process declarations and variables for C compiler.\n-   Copyright (C) 1988, 92-98, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n+   Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -6295,6 +6296,7 @@ init_decl_processing ()\n       DECL_NAME (fields[3]) = delta2_identifier;\n       DECL_MODE (fields[3]) = TYPE_MODE (delta_type_node);\n       DECL_SIZE (fields[3]) = TYPE_SIZE (delta_type_node);\n+      DECL_SIZE_UNIT (fields[3]) = TYPE_SIZE_UNIT (delta_type_node);\n       TREE_UNSIGNED (fields[3]) = 0;\n       TREE_CHAIN (fields[2]) = fields[3];\n       vtable_entry_type = build_qualified_type (vtable_entry_type,\n@@ -7108,7 +7110,7 @@ layout_var_decl (decl)\n      `extern X x' for some incomplete type `X'.)  */\n   if (!DECL_EXTERNAL (decl))\n     complete_type (type);\n-  if (!DECL_SIZE (decl)&& TYPE_SIZE (type))\n+  if (!DECL_SIZE (decl) && TYPE_SIZE (type))\n     layout_decl (decl, 0);\n \n   if (!DECL_EXTERNAL (decl) && DECL_SIZE (decl) == NULL_TREE)\n@@ -7868,24 +7870,6 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n \n  finish_end:\n \n-  /* If requested, warn about definitions of large data objects.  */\n-\n-  if (warn_larger_than\n-      && ! processing_template_decl\n-      && (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL)\n-      && !DECL_EXTERNAL (decl))\n-    {\n-      register tree decl_size = DECL_SIZE (decl);\n-\n-      if (decl_size && TREE_CODE (decl_size) == INTEGER_CST)\n-\t{\n-\t  unsigned units = TREE_INT_CST_LOW (decl_size) / BITS_PER_UNIT;\n-\n-\t  if (units > larger_than_size)\n-\t    warning_with_decl (decl, \"size of `%s' is %u bytes\", units);\n-\t}\n-    }\n-\n   if (was_readonly)\n     TREE_READONLY (decl) = 1;\n }"}, {"sha": "f668ec46161b2058ce45c35f1a3c1b90984f9182", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,24 +1,23 @@\n /* Perform optimizations on tree structure.\n-\n    Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n    Written by Mark Michell (mark@codesourcery.com).\n \n-   This file is part of GNU CC.\n+This file is part of GNU CC.\n \n-   GNU CC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 2, or (at your option)\n-   any later version.\n-   \n-   GNU CC is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n    \n-   You should have received a copy of the GNU General Public License\n-   along with GNU CC; see the file COPYING.  If not, write to the Free\n-   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-   02111-1307, USA.  */\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -109,6 +108,7 @@ remap_decl (decl, id)\n \t in which case some fields need to be remapped because they may\n \t contain SAVE_EXPRs.  */\n       walk_tree (&DECL_SIZE (t), copy_body_r, id);\n+      walk_tree (&DECL_SIZE_UNIT (t), copy_body_r, id);\n       if (TREE_TYPE (t) && TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE\n \t  && TYPE_DOMAIN (TREE_TYPE (t)))\n \twalk_tree (&TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (t))),"}, {"sha": "b50976d56c847708aea37555595d2b19fe47fae0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,5 +1,6 @@\n /* Handle parameterized types (templates) for GNU C++.\n-   Copyright (C) 1992, 93-97, 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n+   Free Software Foundation, Inc.\n    Written by Ken Raeburn (raeburn@cygnus.com) while at Watchmaker Computing.\n    Rewritten by Jason Merrill (jason@cygnus.com).\n \n@@ -5909,7 +5910,7 @@ tsubst_decl (t, args, type, in_decl)\n \t   this variable; otherwise we run into circular dependencies.  */\n \tDECL_INITIAL (r) = NULL_TREE;\n \tDECL_RTL (r) = 0;\n-\tDECL_SIZE (r) = 0;\n+\tDECL_SIZE (r) = DECL_SIZE_UNIT (r) = 0;\n \tcopy_lang_decl (r);\n \n \t/* For __PRETTY_FUNCTION__ we have to adjust the initializer.  */"}, {"sha": "6097302b42b6ebced1cab186fec439f9d4b3e9ae", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,5 +1,6 @@\n /* Language-dependent node constructors for parse phase of GNU compiler.\n-   Copyright (C) 1987, 88, 92-98, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+   1999, 2000 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -845,7 +846,7 @@ make_binfo (offset, binfo, vtable, virtuals)\n      tree offset, binfo;\n      tree vtable, virtuals;\n {\n-  tree new_binfo = make_tree_vec (7);\n+  tree new_binfo = make_tree_vec (8);\n   tree type;\n \n   if (TREE_CODE (binfo) == TREE_VEC)\n@@ -1268,6 +1269,7 @@ walk_tree (tp, func, data)\n \t\t refer to the declaration itself.  */\n \t      WALK_SUBTREE (DECL_INITIAL (DECL_STMT_DECL (*tp)));\n \t      WALK_SUBTREE (DECL_SIZE (DECL_STMT_DECL (*tp)));\n+\t      WALK_SUBTREE (DECL_SIZE_UNIT (DECL_STMT_DECL (*tp)));\n \t    }\n \n \t  WALK_SUBTREE (TREE_CHAIN (*tp));"}, {"sha": "39b3734e1589ed9d3f7504c15f5e3c37671104e9", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,5 +1,6 @@\n /* Output Dwarf2 format symbol table information from the GNU C compiler.\n-   Copyright (C) 1992, 93, 95-99, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1993, 1995, 1996, 1997, 1998, 1999, 2000\n+   Free Software Foundation, Inc.\n    Contributed by Gary Funck (gary@intrepid.com).\n    Derived from DWARF 1 implementation of Ron Guilmette (rfg@monkeys.com).\n    Extensively modified by Jason Merrill (jason@cygnus.com)."}, {"sha": "febdbc669e87170c3111e608c2f2e30646926483", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,5 +1,6 @@\n /* Convert tree expression to rtl instructions, for GNU compiler.\n-   Copyright (C) 1988, 92-99, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n "}, {"sha": "b181f8ef4916564179e72a81a14d217a3db62ca3", "filename": "gcc/f/com.c", "status": "modified", "additions": 18, "deletions": 45, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,5 +1,6 @@\n /* com.c -- Implementation File (module.c template V1.0)\n-   Copyright (C) 1995-1999 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000\n+   Free Software Foundation, Inc.\n    Contributed by James Craig Burley.\n \n This file is part of GNU Fortran.\n@@ -7762,15 +7763,12 @@ ffecom_sym_transform_ (ffesymbol s)\n \n \t\tfinish_decl (t, initexpr, FALSE);\n \n-\t\tif ((st != NULL) && (DECL_SIZE (t) != error_mark_node))\n+\t\tif (st != NULL && DECL_SIZE (t) != error_mark_node)\n \t\t  {\n-\t\t    tree size_tree;\n-\n-\t\t    size_tree = size_binop (CEIL_DIV_EXPR,\n-\t\t\t\t\t    DECL_SIZE (t),\n-\t\t\t\t\t    size_int (BITS_PER_UNIT));\n-\t\t    assert (TREE_INT_CST_HIGH (size_tree) == 0);\n-\t\t    assert (TREE_INT_CST_LOW (size_tree) == ffestorag_size (st));\n+\t\t    assert (TREE_CODE (DECL_SIZE_UNIT (t)) == INTEGER_CST);\n+\t\t    assert (TREE_INT_CST_HIGH (DECL_SIZE_UNIT (t)) == 0);\n+\t\t    assert (TREE_INT_CST_LOW (DECL_SIZE_UNIT (t))\n+\t\t\t    == ffestorag_size (st));\n \t\t  }\n \n \t\tresume_momentary (yes);\n@@ -8826,15 +8824,10 @@ ffecom_transform_common_ (ffesymbol s)\n \n   if (init)\n     {\n-      tree size_tree;\n-\n-      assert (DECL_SIZE (cbt) != NULL_TREE);\n-      assert (TREE_CODE (DECL_SIZE (cbt)) == INTEGER_CST);\n-      size_tree = size_binop (CEIL_DIV_EXPR,\n-\t\t\t      DECL_SIZE (cbt),\n-\t\t\t      size_int (BITS_PER_UNIT));\n-      assert (TREE_INT_CST_HIGH (size_tree) == 0);\n-      assert (TREE_INT_CST_LOW (size_tree)\n+      assert (DECL_SIZE_UNIT (cbt) != NULL_TREE);\n+      assert (TREE_CODE (DECL_SIZE_UNIT (cbt)) == INTEGER_CST);\n+      assert (TREE_INT_CST_HIGH (DECL_SIZE_UNIT (cbt)) == 0);\n+      assert (TREE_INT_CST_LOW (DECL_SIZE_UNIT (cbt))\n \t      == ffeglobal_common_size (g) + ffeglobal_common_pad (g));\n     }\n \n@@ -8966,13 +8959,9 @@ ffecom_transform_equiv_ (ffestorag eqst)\n     ffestorag_set_init (eqst, ffebld_new_any ());\n \n   {\n-    tree size_tree;\n-\n-    size_tree = size_binop (CEIL_DIV_EXPR,\n-\t\t\t    DECL_SIZE (eqt),\n-\t\t\t    size_int (BITS_PER_UNIT));\n-    assert (TREE_INT_CST_HIGH (size_tree) == 0);\n-    assert (TREE_INT_CST_LOW (size_tree)\n+    assert (TREE_CODE (DECL_SIZE_UNIT (eqt)) == INTEGER_CST);\n+    assert (TREE_INT_CST_HIGH (DECL_SIZE_UNIT (eqt)) == 0);\n+    assert (TREE_INT_CST_LOW (DECL_SIZE_UNIT (eqt))\n \t    == ffestorag_size (eqst) + ffestorag_modulo (eqst));\n   }\n \n@@ -9120,15 +9109,15 @@ ffecom_tree_canonize_ptr_ (tree *decl, tree *offset,\n \n     case PARM_DECL:\n       *decl = t;\n-      *offset = bitsize_int (0L, 0L);\n+      *offset = bitsize_int (0);\n       break;\n \n     case ADDR_EXPR:\n       if (TREE_CODE (TREE_OPERAND (t, 0)) == VAR_DECL)\n \t{\n \t  /* A reference to COMMON.  */\n \t  *decl = TREE_OPERAND (t, 0);\n-\t  *offset = bitsize_int (0L, 0L);\n+\t  *offset = bitsize_int (0);\n \t  break;\n \t}\n       /* Fall through.  */\n@@ -9249,7 +9238,7 @@ ffecom_tree_canonize_ref_ (tree *decl, tree *offset,\n     case VAR_DECL:\n     case PARM_DECL:\n       *decl = t;\n-      *offset = bitsize_int (0L, 0L);\n+      *offset = bitsize_int (0);\n       *size = TYPE_SIZE (TREE_TYPE (t));\n       return;\n \n@@ -13839,6 +13828,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t{\n \t  /* Since the type is OLDDECL's, make OLDDECL's size go with.  */\n \t  DECL_SIZE (newdecl) = DECL_SIZE (olddecl);\n+\t  DECL_SIZE_UNIT (newdecl) = DECL_SIZE_UNIT (olddecl);\n \t  if (TREE_CODE (olddecl) != FUNCTION_DECL)\n \t    if (DECL_ALIGN (olddecl) > DECL_ALIGN (newdecl))\n \t      DECL_ALIGN (newdecl) = DECL_ALIGN (olddecl);\n@@ -14148,23 +14138,6 @@ finish_decl (tree decl, tree init, bool is_top_level)\n \t}\n     }\n \n-  /* If requested, warn about definitions of large data objects.  */\n-\n-  if (warn_larger_than\n-      && (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL)\n-      && !DECL_EXTERNAL (decl))\n-    {\n-      register tree decl_size = DECL_SIZE (decl);\n-\n-      if (decl_size && TREE_CODE (decl_size) == INTEGER_CST)\n-\t{\n-\t   unsigned units = TREE_INT_CST_LOW (decl_size) / BITS_PER_UNIT;\n-\n-\t  if (units > larger_than_size)\n-\t    warning_with_decl (decl, \"size of `%s' is %u bytes\", units);\n-\t}\n-    }\n-\n   /* If we have gone back from temporary to permanent allocation, actually\n      free the temporary space that we no longer need.  */\n   if (temporary && !allocation_temporary_p ())"}, {"sha": "1d7e782a3612eeca2bf6d04145f963539a3d5ef1", "filename": "gcc/flags.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,5 +1,6 @@\n /* Compilation switch flag definitions for GNU CC.\n-   Copyright (C) 1987, 88, 94-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -122,14 +123,14 @@ extern int warn_template_debugging;\n    characters.  The value N is in `id_clash_len'.  */\n \n extern int warn_id_clash;\n-extern unsigned id_clash_len;\n+extern int id_clash_len;\n \n /* Nonzero means warn about any objects definitions whose size is larger\n    than N bytes.  Also want about function definitions whose returned\n    values are larger than N bytes. The value N is in `larger_than_size'.  */\n \n extern int warn_larger_than;\n-extern unsigned larger_than_size;\n+extern HOST_WIDE_INT larger_than_size;\n \n /* Warn if a function returns an aggregate,\n    since there are often incompatible calling conventions for doing this.  */"}, {"sha": "ff925c91af4d47deefa150764d82d94913892d7e", "filename": "gcc/fold-const.c", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,5 +1,6 @@\n /* Fold a constant sub-tree into a single node for C-compiler\n-   Copyright (C) 1987, 88, 92-99, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+   1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -1795,16 +1796,16 @@ const_binop (code, arg1, arg2, notrunc)\n   return 0;\n }\n \f\n-/* Return an INTEGER_CST with value whose HOST_BITS_PER_WIDE_INT bits are\n-   given by HIGH and whose HOST_BITS_PER_WIDE_INT bits are given by NUMBER.\n+/* Return an INTEGER_CST with value whose low-order HOST_BITS_PER_WIDE_INT\n+   bits are given by NUMBER.\n \n    If BIT_P is nonzero, this represents a size in bit and the type of the\n    result will be bitsizetype, othewise it represents a size in bytes and\n    the type of the result will be sizetype.  */\n \n tree\n-size_int_wide (number, high, bit_p)\n-     unsigned HOST_WIDE_INT number, high;\n+size_int_wide (number, bit_p)\n+     HOST_WIDE_INT number;\n      int bit_p;\n {\n   /* Type-size nodes already made for small sizes.  */\n@@ -1819,12 +1820,15 @@ size_int_wide (number, high, bit_p)\n       init_p = 1;\n     }\n \n-  if (number < 2*HOST_BITS_PER_WIDE_INT + 1 && high == 0\n-      && size_table[number][bit_p] != 0)\n-    return size_table[number][bit_p];\n-\n-  if (number < 2*HOST_BITS_PER_WIDE_INT + 1 && high == 0)\n+  /* If this is a positive number that fits in the table we use to hold\n+     cached entries, see if it is already in the table and put it there\n+     if not.  */\n+  if (number >= 0\n+      && number < (int) (sizeof size_table / sizeof size_table[0]) / 2)\n     {\n+      if (size_table[number][bit_p] != 0)\n+\treturn size_table[number][bit_p];\n+\n       if (! ggc_p)\n \t{\n \t  /* Make this a permanent node.  */\n@@ -1842,7 +1846,7 @@ size_int_wide (number, high, bit_p)\n       return t;\n     }\n \n-  t = build_int_2 (number, high);\n+  t = build_int_2 (number, 0);\n   TREE_TYPE (t) = bit_p ? bitsizetype : sizetype;\n   TREE_OVERFLOW (t) = TREE_CONSTANT_OVERFLOW (t) = force_fit_type (t, 0);\n   return t;\n@@ -2809,7 +2813,7 @@ make_bit_field_ref (inner, type, bitsize, bitpos, unsignedp)\n      int unsignedp;\n {\n   tree result = build (BIT_FIELD_REF, type, inner,\n-\t\t       size_int (bitsize), bitsize_int (bitpos, 0L));\n+\t\t       size_int (bitsize), bitsize_int (bitpos));\n \n   TREE_UNSIGNED (result) = unsignedp;\n "}, {"sha": "50a610e5e3fb1a05c4e41df7e7420f84e5d05599", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -378,6 +378,7 @@ ggc_mark_tree_children (t)\n     case 'd': /* A decl node.  */\n       ggc_mark_string (DECL_SOURCE_FILE (t));\n       ggc_mark_tree (DECL_SIZE (t));\n+      ggc_mark_tree (DECL_SIZE_UNIT (t));\n       ggc_mark_tree (DECL_NAME (t));\n       ggc_mark_tree (DECL_CONTEXT (t));\n       ggc_mark_tree (DECL_ARGUMENTS (t));"}, {"sha": "a62f89042be60fc1d7f89eb0e72bb393c561f115", "filename": "gcc/java/class.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,5 +1,5 @@\n /* Functions related to building classes and their related objects.\n-   Copyright (C) 1996, 97-99, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -800,6 +800,7 @@ build_class_ref (type)\n \t      push_obstacks (&permanent_obstack, &permanent_obstack);\n \t      decl = build_decl (VAR_DECL, decl_name, class_type_node);\n \t      DECL_SIZE (decl) = TYPE_SIZE (class_type_node);\n+\t      DECL_SIZE_UNIT (decl) = TYPE_SIZE_UNIT (class_type_node);\n \t      TREE_STATIC (decl) = 1;\n \t      TREE_PUBLIC (decl) = 1;\n \t      DECL_IGNORED_P (decl) = 1;\n@@ -1600,6 +1601,7 @@ push_super_field (this_class, super_class)\n   TREE_CHAIN (base_decl) = TYPE_FIELDS (this_class);\n   TYPE_FIELDS (this_class) = base_decl;\n   DECL_SIZE (base_decl) = TYPE_SIZE (super_class);\n+  DECL_SIZE_UNIT (base_decl) = TYPE_SIZE_UNIT (super_class);\n }\n \n /* Handle the different manners we may have to lay out a super class.  */"}, {"sha": "b747ac8e79412e4316fc307de9cbc97ec0df5121", "filename": "gcc/java/constants.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,5 +1,5 @@\n /* Handle the constant pool of the Java(TM) Virtual Machine.\n-   Copyright (C) 1997, 98-99, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -457,7 +457,8 @@ build_constants_constructor ()\n       DECL_INITIAL (data_decl) = build (CONSTRUCTOR, TREE_TYPE (data_decl),\n \t\t\t\t\tNULL_TREE, data_list);\n       DECL_SIZE (data_decl) = TYPE_SIZE (TREE_TYPE (data_decl));\n-      rest_of_decl_compilation (data_decl, (char*) 0, 1, 0);\n+      DECL_SIZE_UNIT (data_decl) = TYPE_SIZE_UNIT (TREE_TYPE (data_decl));\n+      rest_of_decl_compilation (data_decl, (char *) 0, 1, 0);\n       data_value = build_address_of (data_decl);\n \n       tags_type = build_array_type (unsigned_byte_type_node, index_type);"}, {"sha": "7c82d0ad3732db7d6ca30f6e75cab5ddb2be76a7", "filename": "gcc/print-tree.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,5 +1,6 @@\n /* Prints out tree in human readable form - GNU C-compiler\n-   Copyright (C) 1990, 91, 93-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1990, 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -396,6 +397,8 @@ print_node (file, prefix, node, indent)\n \t       DECL_SOURCE_FILE (node), DECL_SOURCE_LINE (node));\n \n       print_node (file, \"size\", DECL_SIZE (node), indent + 4);\n+      print_node (file, \"unit size\", DECL_SIZE_UNIT (node), indent + 4);\n+      \n       indent_to (file, indent + 3);\n       if (TREE_CODE (node) != FUNCTION_DECL)\n \tfprintf (file, \" align %d\", DECL_ALIGN (node));\n@@ -478,6 +481,7 @@ print_node (file, prefix, node, indent)\n       fprintf (file, \" %s\", GET_MODE_NAME(mode));\n \n       print_node (file, \"size\", TYPE_SIZE (node), indent + 4);\n+      print_node (file, \"unit size\", TYPE_SIZE_UNIT (node), indent + 4);\n       indent_to (file, indent + 3);\n \n       fprintf (file, \" align %d\", TYPE_ALIGN (node));"}, {"sha": "de16c0f0939645b3e9ebbff08f540a6094322ee8", "filename": "gcc/sdbout.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,5 +1,6 @@\n /* Output sdb-format symbol table information from GNU compiler.\n-   Copyright (C) 1988, 92-99, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n "}, {"sha": "be27faeb221a3770af3de1afa939a9265320b4ee", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 66, "deletions": 26, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,5 +1,6 @@\n /* C-compiler utilities for types and variables storage layout\n-   Copyright (C) 1987, 88, 92-98, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1996, 1998,\n+   1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -265,16 +266,24 @@ layout_decl (decl, known_align)\n   DECL_MODE (decl) = TYPE_MODE (type);\n   TREE_UNSIGNED (decl) = TREE_UNSIGNED (type);\n   if (DECL_SIZE (decl) == 0)\n-    DECL_SIZE (decl) = TYPE_SIZE (type);\n+    {\n+      DECL_SIZE (decl) = TYPE_SIZE (type);\n+      DECL_SIZE_UNIT (decl) = TYPE_SIZE_UNIT (type);\n+    }\n \n   if (code == FIELD_DECL && DECL_BIT_FIELD (decl))\n     {\n       if (spec_size == 0 && DECL_NAME (decl) != 0)\n \tabort ();\n \n       /* Size is specified in number of bits.  */\n-      DECL_SIZE (decl) = bitsize_int (spec_size, 0);\n+      DECL_SIZE (decl) = bitsize_int (spec_size);\n+      if (spec_size % BITS_PER_UNIT == 0)\n+\tDECL_SIZE_UNIT (decl) = size_int (spec_size / BITS_PER_UNIT);\n+      else\n+\tDECL_SIZE_UNIT (decl) = 0;\n     }\n+\n   /* Force alignment required for the data type.\n      But if the decl itself wants greater alignment, don't override that.\n      Likewise, if the decl is packed, don't override it.  */\n@@ -308,7 +317,8 @@ layout_decl (decl, known_align)\n \t  DECL_ALIGN (decl) = MAX (GET_MODE_ALIGNMENT (xmode),\n \t\t\t\t   DECL_ALIGN (decl));\n \t  DECL_MODE (decl) = xmode;\n-\t  DECL_SIZE (decl) = bitsize_int (GET_MODE_BITSIZE (xmode), 0);\n+\t  DECL_SIZE (decl) = bitsize_int (GET_MODE_BITSIZE (xmode));\n+\t  DECL_SIZE_UNIT (decl) = size_int (GET_MODE_SIZE (xmode));\n \t  /* This no longer needs to be accessed as a bit field.  */\n \t  DECL_BIT_FIELD (decl) = 0;\n \t}\n@@ -317,15 +327,38 @@ layout_decl (decl, known_align)\n   /* Turn off DECL_BIT_FIELD if we won't need it set.  */\n   if (DECL_BIT_FIELD (decl) && TYPE_MODE (type) == BLKmode\n       && known_align % TYPE_ALIGN (type) == 0\n-      && DECL_SIZE (decl) != 0\n-      && (TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST\n-\t  || (TREE_INT_CST_LOW (DECL_SIZE (decl)) % BITS_PER_UNIT) == 0)\n+      && DECL_SIZE_UNIT (decl) != 0\n       && DECL_ALIGN (decl) >= TYPE_ALIGN (type))\n     DECL_BIT_FIELD (decl) = 0;\n \n   /* Evaluate nonconstant size only once, either now or as soon as safe.  */\n   if (DECL_SIZE (decl) != 0 && TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)\n     DECL_SIZE (decl) = variable_size (DECL_SIZE (decl));\n+  if (DECL_SIZE_UNIT (decl) != 0\n+      && TREE_CODE (DECL_SIZE_UNIT (decl)) != INTEGER_CST)\n+    DECL_SIZE_UNIT (decl) = variable_size (DECL_SIZE_UNIT (decl));\n+\n+  /* If requested, warn about definitions of large data objects.  */\n+  if (warn_larger_than\n+      && (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL)\n+      && ! DECL_EXTERNAL (decl))\n+    {\n+      tree size = DECL_SIZE_UNIT (decl);\n+\n+      if (size != 0 && TREE_CODE (size) == INTEGER_CST\n+\t  && (TREE_INT_CST_HIGH (size) != 0\n+\t      || TREE_INT_CST_LOW (size) > larger_than_size))\n+\t{\n+\t  int size_as_int = TREE_INT_CST_LOW (size);\n+\n+\t  if (size_as_int == TREE_INT_CST_LOW (size)\n+\t      && TREE_INT_CST_HIGH (size) == 0)\n+\t    warning_with_decl (decl, \"size of `%s' is %d bytes\", size_as_int);\n+\t  else\n+\t    warning_with_decl (decl, \"size of `%s' is larger than %d bytes\",\n+\t\t\t       larger_than_size);\n+\t}\n+    }\n }\n \f\n /* Lay out a RECORD_TYPE type (a C struct).\n@@ -485,7 +518,7 @@ layout_record (rec)\n \t    {\n \t      if (const_size > 0)\n \t\tvar_size = size_binop (PLUS_EXPR, var_size,\n-\t\t\t\t       bitsize_int (const_size, 0L));\n+\t\t\t\t       bitsize_int (const_size));\n \t      const_size = 0;\n \t      var_size = round_up (var_size, desired_align);\n \t      var_align = MIN (var_align, desired_align);\n@@ -549,12 +582,12 @@ layout_record (rec)\n \n       if (var_size && const_size)\n \tDECL_FIELD_BITPOS (field)\n-\t  = size_binop (PLUS_EXPR, var_size, bitsize_int (const_size, 0L));\n+\t  = size_binop (PLUS_EXPR, var_size, bitsize_int (const_size));\n       else if (var_size)\n \tDECL_FIELD_BITPOS (field) = var_size;\n       else\n \t{\n-\t  DECL_FIELD_BITPOS (field) = bitsize_int (const_size, 0L);\n+\t  DECL_FIELD_BITPOS (field) = bitsize_int (const_size);\n \n \t  /* If this field ended up more aligned than we thought it\n \t     would be (we approximate this by seeing if its position\n@@ -595,12 +628,12 @@ layout_record (rec)\n      Round it up to a multiple of the record's alignment.  */\n \n   if (var_size == NULL_TREE)\n-    TYPE_SIZE (rec) = bitsize_int (const_size, 0L);\n+    TYPE_SIZE (rec) = bitsize_int (const_size);\n   else\n     {\n       if (const_size)\n \tvar_size\n-\t  = size_binop (PLUS_EXPR, var_size, bitsize_int (const_size, 0L));\n+\t  = size_binop (PLUS_EXPR, var_size, bitsize_int (const_size));\n       TYPE_SIZE (rec) = var_size;\n     }\n \n@@ -614,7 +647,13 @@ layout_record (rec)\n   /* Record the un-rounded size in the binfo node.  But first we check\n      the size of TYPE_BINFO to make sure that BINFO_SIZE is available.  */\n   if (TYPE_BINFO (rec) && TREE_VEC_LENGTH (TYPE_BINFO (rec)) > 6)\n-    TYPE_BINFO_SIZE (rec) = TYPE_SIZE (rec);\n+    {\n+      TYPE_BINFO_SIZE (rec) = TYPE_SIZE (rec);\n+      TYPE_BINFO_SIZE_UNIT (rec)\n+\t= convert (sizetype,\n+\t\t   size_binop (FLOOR_DIV_EXPR, TYPE_SIZE (rec),\n+\t\t\t       size_int (BITS_PER_UNIT)));\n+    }\n   \n   {\n     tree unpadded_size = TYPE_SIZE (rec);\n@@ -718,7 +757,7 @@ layout_union (rec)\n \tcontinue;\n \n       layout_decl (field, 0);\n-      DECL_FIELD_BITPOS (field) = bitsize_int (0L, 0L);\n+      DECL_FIELD_BITPOS (field) = bitsize_int (0);\n \n       /* Union must be at least as aligned as any field requires.  */\n \n@@ -749,23 +788,24 @@ layout_union (rec)\n \t    var_size = size_binop (MAX_EXPR, var_size, dsize);\n \t}\n       else if (TREE_CODE (rec) == QUAL_UNION_TYPE)\n-\tvar_size = fold (build (COND_EXPR, sizetype, DECL_QUALIFIER (field),\n+\tvar_size = fold (build (COND_EXPR, bitsizetype, DECL_QUALIFIER (field),\n \t\t\t\tDECL_SIZE (field),\n-\t\t\t\tvar_size ? var_size : bitsize_int (0L, 0L)));\n+\t\t\t\tvar_size ? var_size : bitsize_int (0)));\n       }\n \n   if (TREE_CODE (rec) == QUAL_UNION_TYPE)\n     TYPE_FIELDS (rec) = nreverse (TYPE_FIELDS (rec));\n \n   /* Determine the ultimate size of the union (in bytes).  */\n   if (NULL == var_size)\n-    TYPE_SIZE (rec) = bitsize_int (CEIL (const_size, BITS_PER_UNIT)\n-\t\t\t\t   * BITS_PER_UNIT, 0L);\n+    TYPE_SIZE (rec)\n+      = bitsize_int (CEIL (const_size, BITS_PER_UNIT) * BITS_PER_UNIT);\n+\n   else if (const_size == 0)\n     TYPE_SIZE (rec) = var_size;\n   else\n     TYPE_SIZE (rec) = size_binop (MAX_EXPR, var_size,\n-\t\t\t\t  round_up (bitsize_int (const_size, 0L),\n+\t\t\t\t  round_up (bitsize_int (const_size),\n \t\t\t\t\t    BITS_PER_UNIT));\n \n   /* Determine the desired alignment.  */\n@@ -839,13 +879,13 @@ layout_type (type)\n \n       TYPE_MODE (type) = smallest_mode_for_size (TYPE_PRECISION (type),\n \t\t\t\t\t\t MODE_INT);\n-      TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)), 0L);\n+      TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n       TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n       break;\n \n     case REAL_TYPE:\n       TYPE_MODE (type) = mode_for_size (TYPE_PRECISION (type), MODE_FLOAT, 0);\n-      TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)), 0L);\n+      TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n       TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n       break;\n \n@@ -856,7 +896,7 @@ layout_type (type)\n \t\t\t (TREE_CODE (TREE_TYPE (type)) == INTEGER_TYPE\n \t\t\t  ? MODE_COMPLEX_INT : MODE_COMPLEX_FLOAT),\n \t\t\t 0);\n-      TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)), 0L);\n+      TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n       TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n       break;\n \n@@ -868,22 +908,22 @@ layout_type (type)\n       break;\n \n     case OFFSET_TYPE:\n-      TYPE_SIZE (type) = bitsize_int (POINTER_SIZE, 0L);\n+      TYPE_SIZE (type) = bitsize_int (POINTER_SIZE);\n       TYPE_SIZE_UNIT (type) = size_int (POINTER_SIZE / BITS_PER_UNIT);\n       TYPE_MODE (type) = ptr_mode;\n       break;\n \n     case FUNCTION_TYPE:\n     case METHOD_TYPE:\n       TYPE_MODE (type) = mode_for_size (2 * POINTER_SIZE, MODE_INT, 0);\n-      TYPE_SIZE (type) = bitsize_int (2 * POINTER_SIZE, 0);\n+      TYPE_SIZE (type) = bitsize_int (2 * POINTER_SIZE);\n       TYPE_SIZE_UNIT (type) = size_int ((2 * POINTER_SIZE) / BITS_PER_UNIT);\n       break;\n \n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n       TYPE_MODE (type) = ptr_mode;\n-      TYPE_SIZE (type) = bitsize_int (POINTER_SIZE, 0L);\n+      TYPE_SIZE (type) = bitsize_int (POINTER_SIZE);\n       TYPE_SIZE_UNIT (type) = size_int (POINTER_SIZE / BITS_PER_UNIT);\n       TREE_UNSIGNED (type) = 1;\n       TYPE_PRECISION (type) = POINTER_SIZE;\n@@ -1159,7 +1199,7 @@ layout_type (type)\n \t  else\n \t    TYPE_MODE (type) = mode_for_size (alignment, MODE_INT, 1);\n \n-\t  TYPE_SIZE (type) = bitsize_int (rounded_size, 0L);\n+\t  TYPE_SIZE (type) = bitsize_int (rounded_size);\n \t  TYPE_SIZE_UNIT (type) = size_int (rounded_size / BITS_PER_UNIT);\n \t  TYPE_ALIGN (type) = alignment;\n \t  TYPE_PRECISION (type) = size_in_bits;"}, {"sha": "4c5a7ef3402df49fac306ed16ee55afdff1b733c", "filename": "gcc/tree.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,5 +1,6 @@\n /* Language-independent node constructors for parse phase of GNU compiler.\n-   Copyright (C) 1987, 88, 92-99, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+   1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -1263,7 +1264,7 @@ get_identifier (text)\n \n   /* Decide how much of that length to hash on */\n   hash_len = len;\n-  if (warn_id_clash && (unsigned)len > id_clash_len)\n+  if (warn_id_clash && len > id_clash_len)\n     hash_len = id_clash_len;\n \n   /* Compute hash code */\n@@ -1282,7 +1283,7 @@ get_identifier (text)\n       return idp;\t\t/* <-- return if found */\n \n   /* Not found; optionally warn about a similar identifier */\n-  if (warn_id_clash && do_identifier_warnings && (unsigned)len >= id_clash_len)\n+  if (warn_id_clash && do_identifier_warnings && len >= id_clash_len)\n     for (idp = hash_table[hi]; idp; idp = TREE_CHAIN (idp))\n       if (!strncmp (IDENTIFIER_POINTER (idp), text, id_clash_len))\n \t{\n@@ -1329,7 +1330,7 @@ maybe_get_identifier (text)\n \n   /* Decide how much of that length to hash on */\n   hash_len = len;\n-  if (warn_id_clash && (unsigned)len > id_clash_len)\n+  if (warn_id_clash && len > id_clash_len)\n     hash_len = id_clash_len;\n \n   /* Compute hash code */\n@@ -2282,12 +2283,15 @@ expr_align (t)\n       align1 = expr_align (TREE_OPERAND (t, 2));\n       return MIN (align0, align1);\n \n-    case FUNCTION_DECL:  case LABEL_DECL:  case CONST_DECL:\n+    case LABEL_DECL:     case CONST_DECL:\n     case VAR_DECL:       case PARM_DECL:   case RESULT_DECL:\n       if (DECL_ALIGN (t) != 0)\n \treturn DECL_ALIGN (t);\n       break;\n \n+    case FUNCTION_DECL:\n+      return FUNCTION_BOUNDARY;\n+\n     default:\n       break;\n     }"}, {"sha": "a5a6d5192ad85a937f0b92411fcde1e3db85617a", "filename": "gcc/tree.h", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,5 +1,6 @@\n /* Front-end tree definitions for GNU compiler.\n-   Copyright (C) 1989, 93-98, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -1045,9 +1046,11 @@ struct tree_type\n #define BINFO_VPTR_FIELD(NODE) TREE_VEC_ELT ((NODE), 5)\n \n /* The size of a base class subobject of this type.  Not all frontends\n-   currently allocate the space for this field.  */\n+   currently allocate the space for these fields.  */\n #define BINFO_SIZE(NODE) TREE_VEC_ELT ((NODE), 6)\n+#define BINFO_SIZE_UNIT(NODE) TREE_VEC_ELT ((NODE), 7)\n #define TYPE_BINFO_SIZE(NODE) BINFO_SIZE (TYPE_BINFO (NODE))\n+#define TYPE_BINFO_SIZE_UNIT(NODE) BINFO_SIZE_UNIT (TYPE_BINFO (NODE))\n \n /* Slot used to build a chain that represents a use of inheritance.\n    For example, if X is derived from Y, and Y is derived from Z,\n@@ -1113,16 +1116,18 @@ struct tree_type\n #define DECL_INITIAL(NODE) (DECL_CHECK (NODE)->decl.initial)\n /* For a PARM_DECL, records the data type used to pass the argument,\n    which may be different from the type seen in the program.  */\n-#define DECL_ARG_TYPE(NODE) (DECL_CHECK (NODE)->decl.initial)   /* In PARM_DECL.  */\n+#define DECL_ARG_TYPE(NODE) (DECL_CHECK (NODE)->decl.initial)\n /* For a FIELD_DECL in a QUAL_UNION_TYPE, records the expression, which\n    if nonzero, indicates that the field occupies the type.  */\n #define DECL_QUALIFIER(NODE) (DECL_CHECK (NODE)->decl.initial)\n /* These two fields describe where in the source code the declaration was.  */\n #define DECL_SOURCE_FILE(NODE) (DECL_CHECK (NODE)->decl.filename)\n #define DECL_SOURCE_LINE(NODE) (DECL_CHECK (NODE)->decl.linenum)\n-/* Holds the size of the datum, as a tree expression.\n+/* Holds the size of the datum, in bits, as a tree expression.\n    Need not be constant.  */\n #define DECL_SIZE(NODE) (DECL_CHECK (NODE)->decl.size)\n+/* Likewise for the size in bytes.  */\n+#define DECL_SIZE_UNIT(NODE) (DECL_CHECK (NODE)->decl.size_unit)\n /* Holds the alignment required for the datum.  */\n #define DECL_ALIGN(NODE) (DECL_CHECK (NODE)->decl.frame_size.u)\n /* Holds the machine mode corresponding to the declaration of a variable or\n@@ -1417,18 +1422,20 @@ struct tree_decl\n       } f;\n   } frame_size;\n \n+  union tree_node *size_unit;\n   union tree_node *name;\n   union tree_node *context;\n-  union tree_node *arguments;\n-  union tree_node *result;\n-  union tree_node *initial;\n+  union tree_node *arguments;\t/* Also used for DECL_FIELD_BITPOS */\n+  union tree_node *result;\t/* Also used for DECL_BIT_FIELD_TYPE */\n+  union tree_node *initial;\t/* Also used for DECL_QUALIFIER */\n   union tree_node *abstract_origin;\n   union tree_node *assembler_name;\n   union tree_node *section_name;\n   union tree_node *machine_attributes;\n   struct rtx_def *rtl;\t/* acts as link to register transfer language\n \t\t\t\t   (rtl) info */\n   struct rtx_def *live_range_rtl;\n+\n   /* For FUNCTION_DECLs: points to insn that constitutes its definition\n      on the permanent obstack.  For FIELD_DECL, this is DECL_FIELD_SIZE.  */\n   union {\n@@ -1773,13 +1780,10 @@ extern tree size_in_bytes\t\tPARAMS ((tree));\n extern HOST_WIDE_INT int_size_in_bytes\tPARAMS ((tree));\n extern tree size_binop\t\t\tPARAMS ((enum tree_code, tree, tree));\n extern tree ssize_binop\t\t\tPARAMS ((enum tree_code, tree, tree));\n-extern tree size_int_wide\t\tPARAMS ((unsigned HOST_WIDE_INT,\n-\t\t\t\t\t       unsigned HOST_WIDE_INT, int));\n-#define size_int(L) size_int_2 ((L), 0, 0)\n-#define bitsize_int(L, H) size_int_2 ((L), (H), 1)\n-#define size_int_2(L, H, T)\t\t\t\\\n-  size_int_wide ((unsigned HOST_WIDE_INT) (L),\t\\\n-\t\t (unsigned HOST_WIDE_INT) (H), (T))\n+extern tree size_int_wide\t\tPARAMS ((HOST_WIDE_INT, int));\n+\n+#define size_int(L) size_int_wide ((HOST_WIDE_INT) (L), 0)\n+#define bitsize_int(L) size_int_wide ((HOST_WIDE_INT) (L), 1)\n \n extern tree round_up\t\t\tPARAMS ((tree, int));\n extern tree get_pending_sizes\t\tPARAMS ((void));"}, {"sha": "e71ba3afb5933aac88e3e2f997a543badfa96a54", "filename": "gcc/varasm.c", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "patch": "@@ -1,5 +1,6 @@\n /* Output variables, constants and external declarations, for GNU compiler.\n-   Copyright (C) 1987, 88, 89, 92-99, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,\n+   1998, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -1418,14 +1419,12 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n     {\n       int size;\n \n-      if (TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)\n+      if (TREE_CODE (DECL_SIZE_UNIT (decl)) != INTEGER_CST)\n \tgoto finish;\n \n-      /* This is better than explicit arithmetic, since it avoids overflow.  */\n-      size_tree = size_binop (CEIL_DIV_EXPR,\n-\t\t\t      DECL_SIZE (decl), size_int (BITS_PER_UNIT));\n-\n+      size_tree = DECL_SIZE_UNIT (decl);\n       size = TREE_INT_CST_LOW (size_tree);\n+\n       if (TREE_INT_CST_HIGH (size_tree) != 0\n \t  || size != TREE_INT_CST_LOW (size_tree))\n \t{\n@@ -1435,7 +1434,6 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n     }\n \n   name = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n-\n   if (TREE_PUBLIC (decl) && DECL_NAME (decl)\n       && ! first_global_object_name\n       && ! (DECL_COMMON (decl) && (DECL_INITIAL (decl) == 0\n@@ -4427,21 +4425,10 @@ output_constructor (exp, size)\n \t  /* Determine size this element should occupy.  */\n \t  if (field)\n \t    {\n-\t      if (TREE_CODE (DECL_SIZE (field)) != INTEGER_CST)\n+\t      if (TREE_CODE (DECL_SIZE_UNIT (field)) != INTEGER_CST)\n \t\tabort ();\n-\t      if (TREE_INT_CST_LOW (DECL_SIZE (field)) > 100000)\n-\t\t{\n-\t\t  /* This avoids overflow trouble.  */\n-\t\t  tree size_tree = size_binop (CEIL_DIV_EXPR,\n-\t\t\t\t\t       DECL_SIZE (field),\n-\t\t\t\t\t       size_int (BITS_PER_UNIT));\n-\t\t  fieldsize = TREE_INT_CST_LOW (size_tree);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  fieldsize = TREE_INT_CST_LOW (DECL_SIZE (field));\n-\t\t  fieldsize = (fieldsize + BITS_PER_UNIT - 1) / BITS_PER_UNIT;\n-\t\t}\n+\n+\t      fieldsize = TREE_INT_CST_LOW (DECL_SIZE_UNIT (field));\n \t    }\n \t  else\n \t    fieldsize = int_size_in_bytes (TREE_TYPE (TREE_TYPE (exp)));"}]}