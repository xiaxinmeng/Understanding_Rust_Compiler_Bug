{"sha": "a6207a2b7e0d334b7fdab31d7969256892577349", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTYyMDdhMmI3ZTBkMzM0YjdmZGFiMzFkNzk2OTI1Njg5MjU3NzM0OQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1999-02-12T10:33:17Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1999-02-12T10:33:17Z"}, "message": "loop.c (loop_insn_first_p, [...]): New functions.\n\n\t* loop.c (loop_insn_first_p, biv_elimination_giv_has_0_offset):\n\tNew functions.\n\t(maybe_eliminate_biv_1): Use biv_elimination_giv_has_0_offset.\n\nFrom-SVN: r25167", "tree": {"sha": "9241303f2f81d701ed9e60ee2051211d9865d1dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9241303f2f81d701ed9e60ee2051211d9865d1dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6207a2b7e0d334b7fdab31d7969256892577349", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6207a2b7e0d334b7fdab31d7969256892577349", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6207a2b7e0d334b7fdab31d7969256892577349", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6207a2b7e0d334b7fdab31d7969256892577349/comments", "author": null, "committer": null, "parents": [{"sha": "354a5b07211102048d123ef4e03f485d29ad6709", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/354a5b07211102048d123ef4e03f485d29ad6709", "html_url": "https://github.com/Rust-GCC/gccrs/commit/354a5b07211102048d123ef4e03f485d29ad6709"}], "stats": {"total": 126, "additions": 71, "deletions": 55}, "files": [{"sha": "1510fd1677551664bffe4db0818aa124a59d249a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6207a2b7e0d334b7fdab31d7969256892577349/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6207a2b7e0d334b7fdab31d7969256892577349/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6207a2b7e0d334b7fdab31d7969256892577349", "patch": "@@ -1,3 +1,9 @@\n+Fri Feb 12 18:29:11 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* loop.c (loop_insn_first_p, biv_elimination_giv_has_0_offset):\n+\tNew functions.\n+\t(maybe_eliminate_biv_1): Use biv_elimination_giv_has_0_offset.\n+\n Fri Feb 12 16:56:10 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* loop.c (load_mems): Don't guess how to do a load / store, use"}, {"sha": "12b52adbb79a24f357b3e54349e704303810af15", "filename": "gcc/loop.c", "status": "modified", "additions": 65, "deletions": 55, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6207a2b7e0d334b7fdab31d7969256892577349/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6207a2b7e0d334b7fdab31d7969256892577349/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=a6207a2b7e0d334b7fdab31d7969256892577349", "patch": "@@ -375,7 +375,12 @@ static void instrument_loop_bct PROTO((rtx, rtx, rtx));\n int indirect_jump_in_function = 0;\n static int indirect_jump_in_function_p PROTO((rtx));\n \n-static int compute_luids PROTO ((rtx, rtx, int));\n+static int compute_luids PROTO((rtx, rtx, int));\n+\n+static int loop_insn_first_p PROTO((rtx, rtx));\n+\n+static int biv_elimination_giv_has_0_offset PROTO((struct induction *,\n+\t\t\t\t\t\t   struct induction *, rtx));\n \f\n /* Relative gain of eliminating various kinds of operations.  */\n static int add_cost;\n@@ -8078,6 +8083,59 @@ maybe_eliminate_biv (bl, loop_start, end, eliminate_p, threshold, insn_count)\n   return 0;\n }\n \f\n+/* INSN and REFERENCE are instructions in the same insn chain.\n+   Return non-zero if INSN is first.\n+   This is like insn_first_p, except that we use the luid information if\n+   available.  */\n+\n+static int\n+loop_insn_first_p (insn, reference)\n+     rtx insn, reference;\n+{\n+  return ((INSN_UID (insn) < max_uid_for_loop\n+\t   && INSN_UID (reference) < max_uid_for_loop)\n+\t  ? INSN_LUID (insn) < INSN_LUID (reference)\n+\t  : insn_first_p (insn, reference));\n+}\n+\n+/* We are trying to eliminate BIV in INSN using GIV.  Return non-zero if\n+   the offset that we have to take into account due to auto-increment /\n+   div derivation is zero.  */\n+static int\n+biv_elimination_giv_has_0_offset (biv, giv, insn)\n+     struct induction *biv, *giv;\n+     rtx insn;\n+{\n+  /* If the giv V had the auto-inc address optimization applied\n+     to it, and INSN occurs between the giv insn and the biv\n+     insn, then we'd have to adjust the value used here.\n+     This is rare, so we don't bother to make this possible.  */\n+  if (giv->auto_inc_opt\n+      && ((loop_insn_first_p (giv->insn, insn)\n+\t   && loop_insn_first_p (insn, biv->insn))\n+\t  || (loop_insn_first_p (biv->insn, insn)\n+\t      && loop_insn_first_p (insn, giv->insn))))\n+    return 0;\n+\n+  /* If the giv V was derived from another giv, and INSN does\n+     not occur between the giv insn and the biv insn, then we'd\n+     have to adjust the value used here.  This is rare, so we don't\n+     bother to make this possible.  */\n+  if (giv->derived_from\n+      && ! (giv->always_executed\n+\t    && loop_insn_first_p (giv->insn, insn)\n+\t    && loop_insn_first_p (insn, biv->insn)))\n+    return 0;\n+  if (giv->same\n+      && giv->same->derived_from\n+      && ! (giv->same->always_executed\n+\t    && loop_insn_first_p (giv->same->insn, insn)\n+\t    && loop_insn_first_p (insn, biv->insn)))\n+    return 0;\n+\n+  return 1;\n+}\n+\n /* If BL appears in X (part of the pattern of INSN), see if we can\n    eliminate its use.  If so, return 1.  If not, return 0.\n \n@@ -8143,15 +8201,7 @@ maybe_eliminate_biv_1 (x, insn, bl, eliminate_p, where)\n \t\t&& v->mode == mode\n \t\t&& 0)\n \t      {\n-\t\t/* If the giv V had the auto-inc address optimization applied\n-\t\t   to it, and INSN occurs between the giv insn and the biv\n-\t\t   insn, then we must adjust the value used here.\n-\t\t   This is rare, so we don't bother to do so.  */\n-\t\tif (v->auto_inc_opt\n-\t\t    && ((INSN_LUID (v->insn) < INSN_LUID (insn)\n-\t\t\t && INSN_LUID (insn) < INSN_LUID (bl->biv->insn))\n-\t\t\t|| (INSN_LUID (v->insn) > INSN_LUID (insn)\n-\t\t\t    && INSN_LUID (insn) > INSN_LUID (bl->biv->insn))))\n+\t\tif (! biv_elimination_giv_has_0_offset (bl->biv, v, insn))\n \t\t  continue;\n \n \t\tif (! eliminate_p)\n@@ -8186,15 +8236,7 @@ maybe_eliminate_biv_1 (x, insn, bl, eliminate_p, where)\n \t\t    || (GET_CODE (v->add_val) == REG\n \t\t\t&& REGNO_POINTER_FLAG (REGNO (v->add_val)))))\n \t      {\n-\t\t/* If the giv V had the auto-inc address optimization applied\n-\t\t   to it, and INSN occurs between the giv insn and the biv\n-\t\t   insn, then we must adjust the value used here.\n-\t\t   This is rare, so we don't bother to do so.  */\n-\t\tif (v->auto_inc_opt\n-\t\t    && ((INSN_LUID (v->insn) < INSN_LUID (insn)\n-\t\t\t && INSN_LUID (insn) < INSN_LUID (bl->biv->insn))\n-\t\t\t|| (INSN_LUID (v->insn) > INSN_LUID (insn)\n-\t\t\t    && INSN_LUID (insn) > INSN_LUID (bl->biv->insn))))\n+\t\tif (! biv_elimination_giv_has_0_offset (bl->biv, v, insn))\n \t\t  continue;\n \n \t\tif (! eliminate_p)\n@@ -8259,15 +8301,7 @@ maybe_eliminate_biv_1 (x, insn, bl, eliminate_p, where)\n \t\t&& ! v->ignore && ! v->maybe_dead && v->always_computable\n \t\t&& v->mode == mode)\n \t      {\n-\t\t/* If the giv V had the auto-inc address optimization applied\n-\t\t   to it, and INSN occurs between the giv insn and the biv\n-\t\t   insn, then we must adjust the value used here.\n-\t\t   This is rare, so we don't bother to do so.  */\n-\t\tif (v->auto_inc_opt\n-\t\t    && ((INSN_LUID (v->insn) < INSN_LUID (insn)\n-\t\t\t && INSN_LUID (insn) < INSN_LUID (bl->biv->insn))\n-\t\t\t|| (INSN_LUID (v->insn) > INSN_LUID (insn)\n-\t\t\t    && INSN_LUID (insn) > INSN_LUID (bl->biv->insn))))\n+\t\tif (! biv_elimination_giv_has_0_offset (bl->biv, v, insn))\n \t\t  continue;\n \n \t\tif (! eliminate_p)\n@@ -8310,15 +8344,7 @@ maybe_eliminate_biv_1 (x, insn, bl, eliminate_p, where)\n \t      {\n \t\trtx tem;\n \n-\t\t/* If the giv V had the auto-inc address optimization applied\n-\t\t   to it, and INSN occurs between the giv insn and the biv\n-\t\t   insn, then we must adjust the value used here.\n-\t\t   This is rare, so we don't bother to do so.  */\n-\t\tif (v->auto_inc_opt\n-\t\t    && ((INSN_LUID (v->insn) < INSN_LUID (insn)\n-\t\t\t && INSN_LUID (insn) < INSN_LUID (bl->biv->insn))\n-\t\t\t|| (INSN_LUID (v->insn) > INSN_LUID (insn)\n-\t\t\t    && INSN_LUID (insn) > INSN_LUID (bl->biv->insn))))\n+\t\tif (! biv_elimination_giv_has_0_offset (bl->biv, v, insn))\n \t\t  continue;\n \n \t\tif (! eliminate_p)\n@@ -8354,15 +8380,7 @@ maybe_eliminate_biv_1 (x, insn, bl, eliminate_p, where)\n \t\t  {\n \t\t    rtx tem;\n \n-\t\t    /* If the giv V had the auto-inc address optimization applied\n-\t\t       to it, and INSN occurs between the giv insn and the biv\n-\t\t       insn, then we must adjust the value used here.\n-\t\t       This is rare, so we don't bother to do so.  */\n-\t\t    if (v->auto_inc_opt\n-\t\t\t&& ((INSN_LUID (v->insn) < INSN_LUID (insn)\n-\t\t\t     && INSN_LUID (insn) < INSN_LUID (bl->biv->insn))\n-\t\t\t    || (INSN_LUID (v->insn) > INSN_LUID (insn)\n-\t\t\t\t&& INSN_LUID (insn) > INSN_LUID (bl->biv->insn))))\n+\t\t    if (! biv_elimination_giv_has_0_offset (bl->biv, v, insn))\n \t\t      continue;\n \n \t\t    if (! eliminate_p)\n@@ -8416,15 +8434,7 @@ maybe_eliminate_biv_1 (x, insn, bl, eliminate_p, where)\n \t\t    && rtx_equal_p (tv->add_val, v->add_val)\n \t\t    && tv->mode == mode)\n \t\t  {\n-\t\t    /* If the giv V had the auto-inc address optimization applied\n-\t\t       to it, and INSN occurs between the giv insn and the biv\n-\t\t       insn, then we must adjust the value used here.\n-\t\t       This is rare, so we don't bother to do so.  */\n-\t\t    if (v->auto_inc_opt\n-\t\t\t&& ((INSN_LUID (v->insn) < INSN_LUID (insn)\n-\t\t\t     && INSN_LUID (insn) < INSN_LUID (bl->biv->insn))\n-\t\t\t    || (INSN_LUID (v->insn) > INSN_LUID (insn)\n-\t\t\t\t&& INSN_LUID (insn) > INSN_LUID (bl->biv->insn))))\n+\t\t    if (! biv_elimination_giv_has_0_offset (bl->biv, v, insn))\n \t\t      continue;\n \n \t\t    if (! eliminate_p)"}]}