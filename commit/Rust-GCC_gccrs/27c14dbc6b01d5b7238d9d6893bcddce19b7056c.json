{"sha": "27c14dbc6b01d5b7238d9d6893bcddce19b7056c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdjMTRkYmM2YjAxZDViNzIzOGQ5ZDY4OTNiY2RkY2UxOWI3MDU2Yw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-10-16T17:18:57Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-10-16T17:18:57Z"}, "message": "PR tree-optimization/91996 - fold non-constant strlen relational expressions\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/91996\n\t* gcc.dg/strlenopt-80.c: New test.\n\t* gcc.dg/strlenopt-81.c: New test.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/91996\n\t* tree-ssa-strlen.c (maybe_warn_pointless_strcmp): Improve location\n\tinformation.\n\t(compare_nonzero_chars): Add an overload.\n\t(count_nonzero_bytes): Add an argument.  Call overload above.\n\tHandle non-constant lengths in some range.\n\t(handle_store): Add an argument.\n\t(check_and_optimize_stmt): Pass an argument to handle_store.\n\nFrom-SVN: r277076", "tree": {"sha": "91e41b4bdffd010279c5b4036678d1c8f93a21da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91e41b4bdffd010279c5b4036678d1c8f93a21da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27c14dbc6b01d5b7238d9d6893bcddce19b7056c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27c14dbc6b01d5b7238d9d6893bcddce19b7056c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27c14dbc6b01d5b7238d9d6893bcddce19b7056c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27c14dbc6b01d5b7238d9d6893bcddce19b7056c/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b7bfd3c503b063ad9bbcb975816423e82cf48636", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7bfd3c503b063ad9bbcb975816423e82cf48636", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7bfd3c503b063ad9bbcb975816423e82cf48636"}], "stats": {"total": 463, "additions": 422, "deletions": 41}, "files": [{"sha": "018a0a1832d609cccec28bbb7e6b870538d50f08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c14dbc6b01d5b7238d9d6893bcddce19b7056c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c14dbc6b01d5b7238d9d6893bcddce19b7056c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=27c14dbc6b01d5b7238d9d6893bcddce19b7056c", "patch": "@@ -1,3 +1,14 @@\n+2019-10-16  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/91996\n+\t* tree-ssa-strlen.c (maybe_warn_pointless_strcmp): Improve location\n+\tinformation.\n+\t(compare_nonzero_chars): Add an overload.\n+\t(count_nonzero_bytes): Add an argument.  Call overload above.\n+\tHandle non-constant lengths in some range.\n+\t(handle_store): Add an argument.\n+\t(check_and_optimize_stmt): Pass an argument to handle_store.\n+\n 2019-10-16  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/arm.c (neon_valid_immediate): Clear bytes before use."}, {"sha": "8816472a8a4be02546ec1d62f3706778b6a46607", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c14dbc6b01d5b7238d9d6893bcddce19b7056c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c14dbc6b01d5b7238d9d6893bcddce19b7056c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=27c14dbc6b01d5b7238d9d6893bcddce19b7056c", "patch": "@@ -1,3 +1,9 @@\n+2019-10-16  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/91996\n+\t* gcc.dg/strlenopt-80.c: New test.\n+\t* gcc.dg/strlenopt-81.c: New test.\n+\n 2019-10-16  Mihailo Stojanovic  <mistojanovic@wavecomp.com>\n \n \t* gcc.target/mips/msa-dpadd-dpsub.c: New test."}, {"sha": "9124fe4740a1b905077238acd94d08d561be1b36", "filename": "gcc/testsuite/gcc.dg/strlenopt-80.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c14dbc6b01d5b7238d9d6893bcddce19b7056c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-80.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c14dbc6b01d5b7238d9d6893bcddce19b7056c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-80.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-80.c?ref=27c14dbc6b01d5b7238d9d6893bcddce19b7056c", "patch": "@@ -0,0 +1,108 @@\n+/* PR tree-optimization/91996 - fold strlen relational expressions\n+\n+   The optimization is only implemented for MEM_REF stores and other\n+   targets than those below may not transform the memcpy call into\n+   such a store.\n+   { dg-do compile { target aarch64*-*-* i?86-*-* powerpc*-*-* x86_64-*-* } }\n+\n+   { dg-options \"-O2 -Wall -fdump-tree-optimized\" } */\n+\n+#define CHAR_BIT      __CHAR_BIT__\n+#define SIZE_MAX      __SIZE_MAX__\n+#define LEN_MAX       (__PTRDIFF_MAX__ - 2)\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+typedef __SIZE_TYPE__    size_t;\n+\n+extern void* memcpy (void*, const void*, size_t);\n+extern size_t strlen (const char*);\n+\n+#define CONCAT(a, b) a ## b\n+#define CAT(a, b)    CONCAT (a, b)\n+\n+extern void sink (void*, ...);\n+extern void failure_on_line (int);\n+\n+extern char src[];\n+extern char dst[];\n+\n+/* Copy (1 << NCPYLOG) bytes from an unknown string SRC with strlen (SRC)\n+   in the range [MINSRCLEN, MAXSRCLEN] into DST + DSTOFF and verify that\n+   strlen (DST + DSTOFF) is in the range [MINDSTLEN, MAXDSTLEN].  */\n+#define MIN_MAX(dst, dstoff, src,\t\t\t\t\t\\\n+\t     minsrclen, maxsrclen, mindstlen, maxdstlen, ncpylog)\t\\\n+  void CAT (test_on_line_, __LINE__) (void)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    size_t srclen = strlen (src);\t\t\t\t\t\\\n+    if ((minsrclen) <= srclen && srclen <= (maxsrclen)) {\t\t\\\n+      char *d = (dst) + (dstoff);\t\t\t\t\t\\\n+      memcpy (d, src, (size_t)1 << (ncpylog));\t\t\t\t\\\n+      size_t dstlen = strlen (d);\t\t\t\t\t\\\n+      if (dstlen < (mindstlen) || (maxdstlen) < dstlen)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  failure_on_line (__LINE__);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      sink (dst, src);\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  } typedef void dummy_type\n+\n+// Verify the lower bound of the resulting strlen range.\n+#define MIN(dst, dstoff, src, minsrclen, mindstlen, ncpylog)\t\t\\\n+  MIN_MAX (dst, dstoff, src, minsrclen, LEN_MAX, mindstlen, LEN_MAX, ncpylog)\n+\n+MIN (dst, 0, src, 2, 1, 0);\n+MIN (dst, 0, src, 3, 1, 0);\n+MIN (dst, 0, src, 3, 2, 1);\n+MIN (dst, 0, src, 3, 2, 2);\n+MIN (dst, 0, src, 3, 2, 3);\n+\n+MIN (dst, 1, src, 2, 1, 0);\n+MIN (dst, 1, src, 3, 1, 0);\n+MIN (dst, 1, src, 3, 2, 1);\n+MIN (dst, 1, src, 3, 2, 2);\n+MIN (dst, 1, src, 3, 2, 3);\n+\n+MIN (dst, 2, src, 2, 1, 0);\n+MIN (dst, 3, src, 3, 1, 0);\n+MIN (dst, 4, src, 3, 2, 1);\n+MIN (dst, 5, src, 3, 2, 2);\n+MIN (dst, 6, src, 3, 2, 3);\n+\n+\n+MIN (dst, 0, src, 5, 1, 0);\n+MIN (dst, 0, src, 5, 2, 1);\n+MIN (dst, 0, src, 5, 4, 2);\n+MIN (dst, 0, src, 5, 5, 3);\n+\n+#if __aarch64__ || __x86_64__\n+/* Of the targets above only aarch64 and x86_64 transform memcpy calls\n+   of (2 << 4) bytes into MEM_REF.  */\n+MIN (dst, 0, src, 5, 5, 4);\n+#endif\n+\n+MIN (dst, 11, src, 5, 1, 0);\n+MIN (dst, 22, src, 5, 2, 1);\n+MIN (dst, 33, src, 5, 4, 2);\n+MIN (dst, 44, src, 5, 5, 3);\n+\n+#if __aarch64__ || __x86_64__\n+MIN (dst, 55, src, 5, 5, 4);\n+#endif\n+\n+MIN (dst, 11, src, LEN_MAX, 1, 0);\n+MIN (dst, 22, src, LEN_MAX, 2, 1);\n+MIN (dst, 33, src, LEN_MAX, 4, 2);\n+MIN (dst, 44, src, LEN_MAX, 5, 3);\n+MIN (dst, 55, src, LEN_MAX, 5, 4);\n+MIN (dst, 66, src, LEN_MAX, 9, 8);\n+MIN (dst, 66, src, LEN_MAX, LEN_MAX, sizeof (ptrdiff_t) * CHAR_BIT - 1);\n+\n+\n+MIN_MAX (dst, 0, src, 3, 5, 1, LEN_MAX, 0);\n+MIN_MAX (dst, 0, src, 3, 5, 2, LEN_MAX, 1);\n+MIN_MAX (dst, 0, src, 3, 5, 3, LEN_MAX, 2);\n+\n+/* Upper bound not implemented yet.\n+   MIN_MAX (dst, 0, src, 3, 5, 3, 5, 3);  */\n+\n+/* { dg-final { scan-tree-dump-times \"failure_on_line \\\\(\" 0 \"optimized\" } } */"}, {"sha": "95ac29aa71f06e314fe7b2bb1eb15bd0c0543627", "filename": "gcc/testsuite/gcc.dg/strlenopt-81.c", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c14dbc6b01d5b7238d9d6893bcddce19b7056c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-81.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c14dbc6b01d5b7238d9d6893bcddce19b7056c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-81.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-81.c?ref=27c14dbc6b01d5b7238d9d6893bcddce19b7056c", "patch": "@@ -0,0 +1,190 @@\n+/* PR tree-optimization/ - fold strlen relational expressions\n+   { dg-do run }\n+   { dg-options \"-O2 -Wall -Wno-unused-local-typedefs -fdump-tree-optimized\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#define NOIPA   __attribute__ ((noipa))\n+\n+#define CONCAT(a, b) a ## b\n+#define CAT(a, b)    CONCAT (a, b)\n+\n+/* Used in tests where EXPR is expected to be folded to false.  */\n+#define ELIM(expr)\t\t\t\t\t\t\t\\\n+  if (expr) {\t\t\t\t\t\t\t\t\\\n+    extern void\t\t\t\t\t\t\t\t\\\n+      CAT (CAT (test_on_line_, __LINE__), _not_eliminated)(void);\t\\\n+    CAT (CAT (test_on_line_, __LINE__), _not_eliminated)();\t\t\\\n+  } typedef void dummy_type\n+\n+char a[32], b[32];\n+\n+void init (void)\n+{\n+  __builtin_strncpy (a, \"abcdefgh\", sizeof a);\n+  __builtin_strncpy (b, \"0123456789\", sizeof b);\n+}\n+\n+NOIPA void fail (const char *func)\n+{\n+  __builtin_printf (\"failure in %s\\n\", func);\n+  __builtin_abort ();\n+}\n+\n+NOIPA void test_global_cpy_4 (void)\n+{\n+  size_t blen = __builtin_strlen (b);\n+  if (blen < 9) return;\n+\n+  char *d = a;\n+  __builtin_memcpy (d, b, 4);\n+\n+  size_t dlen = __builtin_strlen (d);\n+  if (dlen != 8)   // cannot be eliminated\n+    fail (\"test_global\");\n+}\n+\n+\n+NOIPA void test_global_cpy_10 (void)\n+{\n+  size_t blen = __builtin_strlen (b);\n+  if (blen < 9) return;\n+\n+  char *d = a;\n+  __builtin_memcpy (d, b, 10);\n+\n+  size_t dlen = __builtin_strlen (d);\n+  if (dlen != 10)   // cannot be eliminated\n+    fail (\"test_global_cpy_10\");\n+}\n+\n+NOIPA void test_global_cpy_11 (void)\n+{\n+  size_t blen = __builtin_strlen (b);\n+  if (blen < 9) return;\n+\n+  char *d = a;\n+  __builtin_memcpy (d, b, 11);\n+\n+  size_t dlen = __builtin_strlen (d);\n+  if (dlen != 10)   // cannot be eliminated\n+    fail (\"test_global_cpy_11\");\n+}\n+\n+NOIPA void test_global_cpy_20 (void)\n+{\n+  size_t blen = __builtin_strlen (b);\n+  if (blen < 9) return;\n+\n+  char *d = a;\n+  __builtin_memcpy (d, b, 20);\n+\n+  size_t dlen = __builtin_strlen (d);\n+  if (dlen != 10)   // cannot be eliminated\n+    fail (\"test_global_cpy_20\");\n+}\n+\n+NOIPA void test_local_cpy_4 (void)\n+{\n+  size_t blen = __builtin_strlen (b);\n+  if (blen < 9) return;\n+\n+  char a[10] = \"abcdefgh\";\n+  char *d = a;\n+  __builtin_memcpy (d, b, 4);\n+\n+  size_t dlen = __builtin_strlen (d);\n+  ELIM (dlen != 8);\n+}\n+\n+NOIPA void test_local_cpy_10 (void)\n+{\n+  size_t blen = __builtin_strlen (b);\n+  if (blen < 9) return;\n+\n+  char a[32] = \"abcdefgh\";\n+  char *d = a;\n+  __builtin_memcpy (d, b, 10);\n+\n+  /* B can be longer than 9 and A can initially be longer than 10\n+     so the test below cannot be eliminated.  */\n+  size_t dlen = __builtin_strlen (d);\n+  if (dlen != 10)\n+    fail (\"test_local_cpy_10\");\n+}\n+\n+NOIPA void test_local_cpy_11 (void)\n+{\n+  size_t blen = __builtin_strlen (b);\n+  if (blen < 9) return;\n+\n+  char a[32] = \"abcdefgh\";\n+  char *d = a;\n+  __builtin_memcpy (d, b, 11);\n+\n+  size_t dlen = __builtin_strlen (d);\n+  if (dlen != 10)\n+    fail (\"test_global_cpy_20\");\n+}\n+\n+NOIPA void test_local_cpy_20 (void)\n+{\n+  size_t blen = __builtin_strlen (b);\n+  if (blen < 9) return;\n+\n+  char a[32] = \"abcdefgh\";\n+  char *d = a;\n+  __builtin_memcpy (d, b, 20);\n+\n+  size_t dlen = __builtin_strlen (d);\n+  if (dlen != 10)\n+    fail (\"test_global_cpy_20\");\n+}\n+\n+NOIPA void test_global_length_eq (void)\n+{\n+  size_t blen = __builtin_strlen (b);\n+  if (blen != 10) return;\n+\n+  size_t alen = __builtin_strlen (a);\n+  if (alen != 8) return;\n+\n+  char *d = a;\n+  __builtin_memcpy (d, b, 4);\n+\n+  size_t dlen = __builtin_strlen (d);\n+  ELIM (dlen != 8);\n+}\n+\n+\n+NOIPA void test_global_length_gt (void)\n+{\n+  size_t blen = __builtin_strlen (b);\n+  if (blen < 9) return;\n+\n+  size_t alen = __builtin_strlen (a);\n+  if (alen < 8) return;\n+\n+  char *d = a;\n+  __builtin_memcpy (d, b, 4);\n+\n+  size_t dlen = __builtin_strlen (d);\n+  ELIM (dlen < 8);\n+}\n+\n+#define TEST(name) do { init (); test_ ## name (); } while (0)\n+\n+int main (void)\n+{\n+  TEST (local_cpy_4);\n+  TEST (local_cpy_10);\n+  TEST (local_cpy_11);\n+  TEST (local_cpy_20);\n+\n+  TEST (global_cpy_4);\n+  TEST (global_cpy_10);\n+  TEST (global_cpy_11);\n+  TEST (global_cpy_20);\n+  TEST (global_length_eq);\n+  TEST (global_length_gt);\n+}"}, {"sha": "bd1eb0d7ab8a68b2c58bed867d3030a56889ef89", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 107, "deletions": 41, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c14dbc6b01d5b7238d9d6893bcddce19b7056c/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c14dbc6b01d5b7238d9d6893bcddce19b7056c/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=27c14dbc6b01d5b7238d9d6893bcddce19b7056c", "patch": "@@ -191,12 +191,12 @@ static void handle_builtin_stxncpy (built_in_function, gimple_stmt_iterator *);\n \n /* Return:\n \n-   - 1 if SI is known to start with more than OFF nonzero characters.\n+   *  +1  if SI is known to start with more than OFF nonzero characters.\n \n-   - 0 if SI is known to start with OFF nonzero characters,\n-     but is not known to start with more.\n+   *   0  if SI is known to start with OFF nonzero characters,\n+\t  but is not known to start with more.\n \n-   - -1 if SI might not start with OFF nonzero characters.  */\n+   *  -1  if SI might not start with OFF nonzero characters.  */\n \n static inline int\n compare_nonzero_chars (strinfo *si, unsigned HOST_WIDE_INT off)\n@@ -208,6 +208,33 @@ compare_nonzero_chars (strinfo *si, unsigned HOST_WIDE_INT off)\n     return -1;\n }\n \n+/* Same as above but suitable also for strings with non-constant lengths.\n+   Uses RVALS to determine length range.  */\n+\n+static int\n+compare_nonzero_chars (strinfo *si, unsigned HOST_WIDE_INT off,\n+\t\t       const vr_values *rvals)\n+{\n+  if (!si->nonzero_chars)\n+    return -1;\n+\n+  if (TREE_CODE (si->nonzero_chars) == INTEGER_CST)\n+    return compare_tree_int (si->nonzero_chars, off);\n+\n+  if (TREE_CODE (si->nonzero_chars) != SSA_NAME)\n+    return -1;\n+\n+  const value_range *vr\n+    = (CONST_CAST (class vr_values *, rvals)\n+       ->get_value_range (si->nonzero_chars));\n+\n+  value_range_kind rng = vr->kind ();\n+  if (rng != VR_RANGE || !range_int_cst_p (vr))\n+    return -1;\n+\n+  return compare_tree_int (vr->min (), off);\n+}\n+\n /* Return true if SI is known to be a zero-length string.  */\n \n static inline bool\n@@ -3619,7 +3646,8 @@ maybe_warn_pointless_strcmp (gimple *stmt, HOST_WIDE_INT bound,\n \t\t\t     unsigned HOST_WIDE_INT len[2],\n \t\t\t     unsigned HOST_WIDE_INT siz)\n {\n-  gimple *use = used_only_for_zero_equality (gimple_call_lhs (stmt));\n+  tree lhs = gimple_call_lhs (stmt);\n+  gimple *use = used_only_for_zero_equality (lhs);\n   if (!use)\n     return;\n \n@@ -3642,7 +3670,11 @@ maybe_warn_pointless_strcmp (gimple *stmt, HOST_WIDE_INT bound,\n \n   /* FIXME: Include a note pointing to the declaration of the smaller\n      array.  */\n-  location_t stmt_loc = gimple_location (stmt);\n+  location_t stmt_loc = gimple_nonartificial_location (stmt);\n+  if (stmt_loc == UNKNOWN_LOCATION && EXPR_HAS_LOCATION (lhs))\n+    stmt_loc = tree_nonartificial_location (lhs);\n+  stmt_loc = expansion_point_location_if_in_system_header (stmt_loc);\n+\n   tree callee = gimple_call_fndecl (stmt);\n   bool warned = false;\n   if (siz <= minlen && bound == -1)\n@@ -3918,40 +3950,70 @@ static bool\n count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n \t\t     unsigned HOST_WIDE_INT nbytes,\n \t\t     unsigned lenrange[3], bool *nulterm,\n-\t\t     bool *allnul, bool *allnonnul, ssa_name_limit_t &snlim)\n+\t\t     bool *allnul, bool *allnonnul, const vr_values *rvals,\n+\t\t     ssa_name_limit_t &snlim)\n {\n   int idx = get_stridx (exp);\n   if (idx > 0)\n     {\n       strinfo *si = get_strinfo (idx);\n-      /* FIXME: Handle non-constant lengths in some range.  */\n-      if (!si || !tree_fits_shwi_p (si->nonzero_chars))\n+      if (!si)\n \treturn false;\n \n-      unsigned len = tree_to_shwi (si->nonzero_chars);\n-      unsigned size = len + si->full_string_p;\n-      if (size <= offset)\n+      /* Handle both constant lengths as well non-constant lengths\n+\t in some range.  */\n+      unsigned HOST_WIDE_INT minlen, maxlen;\n+      if (tree_fits_shwi_p (si->nonzero_chars))\n+\tminlen = maxlen = tree_to_shwi (si->nonzero_chars);\n+      else if (nbytes\n+\t       && si->nonzero_chars\n+\t       && TREE_CODE (si->nonzero_chars) == SSA_NAME)\n+\t{\n+\t  const value_range *vr\n+\t    = CONST_CAST (class vr_values *, rvals)\n+\t    ->get_value_range (si->nonzero_chars);\n+\t  if (vr->kind () != VR_RANGE\n+\t      || !range_int_cst_p (vr))\n+\t    return false;\n+\n+\t minlen = tree_to_uhwi (vr->min ());\n+\t maxlen = tree_to_uhwi (vr->max ());\n+\t}\n+      else\n \treturn false;\n \n-      len -= offset;\n+      if (maxlen < offset)\n+\treturn false;\n \n-      if (len < lenrange[0])\n-\tlenrange[0] = len;\n-      if (lenrange[1] < len)\n-\tlenrange[1] = len;\n-      if (lenrange[2] < nbytes)\n-\tlenrange[2] = nbytes;\n+      minlen = minlen < offset ? 0 : minlen - offset;\n+      maxlen -= offset;\n+      if (maxlen + 1 < nbytes)\n+\treturn false;\n \n-      if (!si->full_string_p)\n+      if (nbytes <= minlen)\n \t*nulterm = false;\n \n-      /* Since only the length of the string are known and\n-\t its contents, clear ALLNUL and ALLNONNUL purely on\n-\t the basis of the length.  */\n-      if (len)\n-\t*allnul = false;\n-      else\n+      if (nbytes < minlen)\n+\t{\n+\t  minlen = nbytes;\n+\t  if (nbytes < maxlen)\n+\t    maxlen = nbytes;\n+\t}\n+\n+      if (minlen < lenrange[0])\n+\tlenrange[0] = minlen;\n+      if (lenrange[1] < maxlen)\n+\tlenrange[1] = maxlen;\n+\n+      if (lenrange[2] < nbytes)\n+\t(lenrange[2] = nbytes);\n+\n+      /* Since only the length of the string are known and not its contents,\n+\t clear ALLNUL and ALLNONNUL purely on the basis of the length.  */\n+      *allnul = false;\n+      if (minlen < nbytes)\n \t*allnonnul = false;\n+\n       return true;\n     }\n \n@@ -3960,7 +4022,7 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n \n   if (TREE_CODE (exp) == SSA_NAME)\n     {\n-      /* Handle a single-character specially.  */\n+      /* Handle non-zero single-character stores specially.  */\n       tree type = TREE_TYPE (exp);\n       if (TREE_CODE (type) == INTEGER_TYPE\n \t  && TYPE_MODE (type) == TYPE_MODE (char_type_node)\n@@ -3972,7 +4034,7 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n \t     for an arbitrary constant.  */\n \t  exp = build_int_cst (type, 1);\n \t  return count_nonzero_bytes (exp, offset, 1, lenrange,\n-\t\t\t\t      nulterm, allnul, allnonnul, snlim);\n+\t\t\t\t      nulterm, allnul, allnonnul, rvals, snlim);\n \t}\n \n       gimple *stmt = SSA_NAME_DEF_STMT (exp);\n@@ -3981,6 +4043,7 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n \t  exp = gimple_assign_rhs1 (stmt);\n \t  if (TREE_CODE (exp) != MEM_REF)\n \t    return false;\n+\t  /* Handle MEM_REF below.  */\n \t}\n       else if (gimple_code (stmt) == GIMPLE_PHI)\n \t{\n@@ -3996,7 +4059,7 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n \t    {\n \t      tree def = gimple_phi_arg_def (stmt, i);\n \t      if (!count_nonzero_bytes (def, offset, nbytes, lenrange, nulterm,\n-\t\t\t\t\tallnul, allnonnul, snlim))\n+\t\t\t\t\tallnul, allnonnul, rvals, snlim))\n \t\treturn false;\n \t    }\n \n@@ -4033,7 +4096,7 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n \n       /* Handle MEM_REF = SSA_NAME types of assignments.  */\n       return count_nonzero_bytes (arg, offset, nbytes, lenrange, nulterm,\n-\t\t\t\t  allnul, allnonnul, snlim);\n+\t\t\t\t  allnul, allnonnul, rvals, snlim);\n     }\n \n   if (TREE_CODE (exp) == VAR_DECL && TREE_READONLY (exp))\n@@ -4132,11 +4195,13 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n   return true;\n }\n \n-/* Same as above except with an implicit SSA_NAME limit.  */\n+/* Same as above except with an implicit SSA_NAME limit.  RVALS is used\n+   to determine ranges of dynamically computed string lengths (the results\n+   of strlen).  */\n \n static bool\n count_nonzero_bytes (tree exp, unsigned lenrange[3], bool *nulterm,\n-\t\t     bool *allnul, bool *allnonnul)\n+\t\t     bool *allnul, bool *allnonnul, const vr_values *rvals)\n {\n   /* Set to optimistic values so the caller doesn't have to worry about\n      initializing these and to what.  On success, the function will clear\n@@ -4149,7 +4214,7 @@ count_nonzero_bytes (tree exp, unsigned lenrange[3], bool *nulterm,\n \n   ssa_name_limit_t snlim;\n   return count_nonzero_bytes (exp, 0, 0, lenrange, nulterm, allnul, allnonnul,\n-\t\t\t      snlim);\n+\t\t\t      rvals, snlim);\n }\n \n /* Handle a single or multibyte store other than by a built-in function,\n@@ -4158,7 +4223,7 @@ count_nonzero_bytes (tree exp, unsigned lenrange[3], bool *nulterm,\n    '*(int*)a = 12345').  Return true when handled.  */\n \n static bool\n-handle_store (gimple_stmt_iterator *gsi)\n+handle_store (gimple_stmt_iterator *gsi, const vr_values *rvals)\n {\n   int idx = -1;\n   strinfo *si = NULL;\n@@ -4184,7 +4249,7 @@ handle_store (gimple_stmt_iterator *gsi)\n \t    si = get_strinfo (idx);\n \t  if (offset == 0)\n \t    ssaname = TREE_OPERAND (lhs, 0);\n-\t  else if (si == NULL || compare_nonzero_chars (si, offset) < 0)\n+\t  else if (si == NULL || compare_nonzero_chars (si, offset, rvals) < 0)\n \t    return true;\n \t}\n     }\n@@ -4214,7 +4279,8 @@ handle_store (gimple_stmt_iterator *gsi)\n \n   const bool ranges_valid\n     = count_nonzero_bytes (rhs, lenrange, &full_string_p,\n-\t\t\t   &storing_all_zeros_p, &storing_all_nonzero_p);\n+\t\t\t   &storing_all_zeros_p, &storing_all_nonzero_p,\n+\t\t\t   rvals);\n   if (ranges_valid)\n     {\n       rhs_minlen = lenrange[0];\n@@ -4233,7 +4299,7 @@ handle_store (gimple_stmt_iterator *gsi)\n \t\t/* Fall back on the LHS location if the statement\n \t\t   doesn't have one.  */\n \t\tlocation_t loc = gimple_nonartificial_location (stmt);\n-\t\tif (loc == UNKNOWN_LOCATION)\n+\t\tif (loc == UNKNOWN_LOCATION && EXPR_HAS_LOCATION (lhs))\n \t\t  loc = tree_nonartificial_location (lhs);\n \t\tloc = expansion_point_location_if_in_system_header (loc);\n \t\tif (warning_n (loc, OPT_Wstringop_overflow_,\n@@ -4271,15 +4337,15 @@ handle_store (gimple_stmt_iterator *gsi)\n \t{\n \t  /* The offset of the last stored byte.  */\n \t  unsigned HOST_WIDE_INT endoff = offset + lenrange[2] - 1;\n-\t  store_before_nul[0] = compare_nonzero_chars (si, offset);\n+\t  store_before_nul[0] = compare_nonzero_chars (si, offset, rvals);\n \t  if (endoff == offset)\n \t    store_before_nul[1] = store_before_nul[0];\n \t  else\n-\t    store_before_nul[1] = compare_nonzero_chars (si, endoff);\n+\t    store_before_nul[1] = compare_nonzero_chars (si, endoff, rvals);\n \t}\n       else\n \t{\n-\t  store_before_nul[0] = compare_nonzero_chars (si, offset);\n+\t  store_before_nul[0] = compare_nonzero_chars (si, offset, rvals);\n \t  store_before_nul[1] = store_before_nul[0];\n \t  gcc_assert (offset == 0 || store_before_nul[0] >= 0);\n \t}\n@@ -4841,7 +4907,7 @@ check_and_optimize_stmt (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n \t  }\n \n \t/* Handle a single or multibyte assignment.  */\n-\tif (is_char_store && !handle_store (gsi))\n+\tif (is_char_store && !handle_store (gsi, rvals))\n \t  return false;\n       }\n     }"}]}