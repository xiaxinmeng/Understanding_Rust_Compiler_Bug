{"sha": "9fb5fd444bef7601aec09778bc6ee926a6f76fd4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZiNWZkNDQ0YmVmNzYwMWFlYzA5Nzc4YmM2ZWU5MjZhNmY3NmZkNA==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2015-05-28T10:35:39Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2015-05-28T10:35:39Z"}, "message": "oacc-init.c (resolve_device): Add FAIL_IS_ERROR argument.\n\n\t* oacc-init.c (resolve_device): Add FAIL_IS_ERROR argument. Update\n\tfunction comment. Only call gomp_fatal if new argument is true.\n\t(acc_dev_num_out_of_range): New function.\n\t(acc_init_1, acc_shutdown_1): Update call to resolve_device. Call\n\tacc_dev_num_out_of_range as appropriate.\n\t(acc_get_num_devices, acc_set_device_type, acc_get_device_type)\n\t(acc_get_device_num, acc_set_device_num): Update calls to resolve_device.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-4.c: Update expected test\n\toutput.\n\nFrom-SVN: r223803", "tree": {"sha": "8c355aeab7e41119def2a5220f0f5b8b89c41c01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c355aeab7e41119def2a5220f0f5b8b89c41c01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fb5fd444bef7601aec09778bc6ee926a6f76fd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb5fd444bef7601aec09778bc6ee926a6f76fd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fb5fd444bef7601aec09778bc6ee926a6f76fd4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb5fd444bef7601aec09778bc6ee926a6f76fd4/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "32eaed9380bfff86977823c0bf88fb69c2a375a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32eaed9380bfff86977823c0bf88fb69c2a375a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32eaed9380bfff86977823c0bf88fb69c2a375a6"}], "stats": {"total": 97, "additions": 71, "deletions": 26}, "files": [{"sha": "a1ea09933facc05eb8be283cfde932d9e68862f8", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb5fd444bef7601aec09778bc6ee926a6f76fd4/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb5fd444bef7601aec09778bc6ee926a6f76fd4/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=9fb5fd444bef7601aec09778bc6ee926a6f76fd4", "patch": "@@ -1,3 +1,15 @@\n+2015-05-28  Julian Brown  <julian@codesourcery.com>\n+\n+\t* oacc-init.c (resolve_device): Add FAIL_IS_ERROR argument. Update\n+\tfunction comment. Only call gomp_fatal if new argument is true.\n+\t(acc_dev_num_out_of_range): New function.\n+\t(acc_init_1, acc_shutdown_1): Update call to resolve_device. Call\n+\tacc_dev_num_out_of_range as appropriate.\n+\t(acc_get_num_devices, acc_set_device_type, acc_get_device_type)\n+\t(acc_get_device_num, acc_set_device_num): Update calls to resolve_device.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-4.c: Update expected test\n+\toutput.\n+\n 2015-05-28  Julian Brown  <julian@codesourcery.com>\n \n \tPR libgomp/65742"}, {"sha": "c91731edcacce54ed69b246e4c0f5d9068507ed0", "filename": "libgomp/oacc-init.c", "status": "modified", "additions": 58, "deletions": 25, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb5fd444bef7601aec09778bc6ee926a6f76fd4/libgomp%2Foacc-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb5fd444bef7601aec09778bc6ee926a6f76fd4/libgomp%2Foacc-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-init.c?ref=9fb5fd444bef7601aec09778bc6ee926a6f76fd4", "patch": "@@ -109,10 +109,12 @@ name_of_acc_device_t (enum acc_device_t type)\n     }\n }\n \n-/* ACC_DEVICE_LOCK should be held before calling this function.  */\n+/* ACC_DEVICE_LOCK must be held before calling this function.  If FAIL_IS_ERROR\n+   is true, this function raises an error if there are no devices of type D,\n+   otherwise it returns NULL in that case.  */\n \n static struct gomp_device_descr *\n-resolve_device (acc_device_t d)\n+resolve_device (acc_device_t d, bool fail_is_error)\n {\n   acc_device_t d_arg = d;\n \n@@ -130,7 +132,13 @@ resolve_device (acc_device_t d)\n \t\t  && dispatchers[d]->get_num_devices_func () > 0)\n \t\tgoto found;\n \n-\t    gomp_fatal (\"device type %s not supported\", goacc_device_type);\n+\t    if (fail_is_error)\n+\t      {\n+\t\tgomp_mutex_unlock (&acc_device_lock);\n+\t\tgomp_fatal (\"device type %s not supported\", goacc_device_type);\n+\t      }\n+\t    else\n+\t      return NULL;\n \t  }\n \n \t/* No default device specified, so start scanning for any non-host\n@@ -149,15 +157,26 @@ resolve_device (acc_device_t d)\n \t  d = acc_device_host;\n \t  goto found;\n \t}\n-      gomp_fatal (\"no device found\");\n+      if (fail_is_error)\n+        {\n+\t  gomp_mutex_unlock (&acc_device_lock);\n+\t  gomp_fatal (\"no device found\");\n+\t}\n+      else\n+        return NULL;\n       break;\n \n     case acc_device_host:\n       break;\n \n     default:\n       if (d > _ACC_device_hwm)\n-\tgomp_fatal (\"device %u out of range\", (unsigned)d);\n+\t{\n+\t  if (fail_is_error)\n+\t    goto unsupported_device;\n+\t  else\n+\t    return NULL;\n+\t}\n       break;\n     }\n  found:\n@@ -166,12 +185,30 @@ resolve_device (acc_device_t d)\n \t  && d != acc_device_default\n \t  && d != acc_device_not_host);\n \n+  if (dispatchers[d] == NULL && fail_is_error)\n+    {\n+    unsupported_device:\n+      gomp_mutex_unlock (&acc_device_lock);\n+      gomp_fatal (\"device type %s not supported\", name_of_acc_device_t (d));\n+    }\n+\n   return dispatchers[d];\n }\n \n+/* Emit a suitable error if no device of a particular type is available, or\n+   the given device number is out-of-range.  */\n+static void\n+acc_dev_num_out_of_range (acc_device_t d, int ord, int ndevs)\n+{\n+  if (ndevs == 0)\n+    gomp_fatal (\"no devices of type %s available\", name_of_acc_device_t (d));\n+  else\n+    gomp_fatal (\"device %u out of range\", ord);\n+}\n+\n /* This is called when plugins have been initialized, and serves to call\n    (indirectly) the target's device_init hook.  Calling multiple times without\n-   an intervening acc_shutdown_1 call is an error.  ACC_DEVICE_LOCK should be\n+   an intervening acc_shutdown_1 call is an error.  ACC_DEVICE_LOCK must be\n    held before calling this function.  */\n \n static struct gomp_device_descr *\n@@ -180,12 +217,12 @@ acc_init_1 (acc_device_t d)\n   struct gomp_device_descr *base_dev, *acc_dev;\n   int ndevs;\n \n-  base_dev = resolve_device (d);\n+  base_dev = resolve_device (d, true);\n \n   ndevs = base_dev->get_num_devices_func ();\n \n-  if (!base_dev || ndevs <= 0 || goacc_device_num >= ndevs)\n-    gomp_fatal (\"device %s not supported\", name_of_acc_device_t (d));\n+  if (ndevs <= 0 || goacc_device_num >= ndevs)\n+    acc_dev_num_out_of_range (d, goacc_device_num, ndevs);\n \n   acc_dev = &base_dev[goacc_device_num];\n \n@@ -202,7 +239,7 @@ acc_init_1 (acc_device_t d)\n   return base_dev;\n }\n \n-/* ACC_DEVICE_LOCK should be held before calling this function.  */\n+/* ACC_DEVICE_LOCK must be held before calling this function.  */\n \n static void\n acc_shutdown_1 (acc_device_t d)\n@@ -213,10 +250,7 @@ acc_shutdown_1 (acc_device_t d)\n   bool devices_active = false;\n \n   /* Get the base device for this device type.  */\n-  base_dev = resolve_device (d);\n-\n-  if (!base_dev)\n-    gomp_fatal (\"device %s not supported\", name_of_acc_device_t (d));\n+  base_dev = resolve_device (d, true);\n \n   gomp_mutex_lock (&goacc_thread_lock);\n \n@@ -366,7 +400,8 @@ goacc_attach_host_thread_to_device (int ord)\n   \n   num_devices = base_dev->get_num_devices_func ();\n   if (num_devices <= 0 || ord >= num_devices)\n-    gomp_fatal (\"device %u out of range\", ord);\n+    acc_dev_num_out_of_range (acc_device_type (base_dev->type), ord,\n+\t\t\t      num_devices);\n   \n   if (!thr)\n     thr = goacc_new_thread ();\n@@ -426,7 +461,7 @@ acc_get_num_devices (acc_device_t d)\n   gomp_init_targets_once ();\n \n   gomp_mutex_lock (&acc_device_lock);\n-  acc_dev = resolve_device (d);\n+  acc_dev = resolve_device (d, false);\n   gomp_mutex_unlock (&acc_device_lock);\n \n   if (!acc_dev)\n@@ -456,7 +491,7 @@ acc_set_device_type (acc_device_t d)\n   if (!cached_base_dev)\n     gomp_init_targets_once ();\n \n-  cached_base_dev = base_dev = resolve_device (d);\n+  cached_base_dev = base_dev = resolve_device (d, true);\n   acc_dev = &base_dev[goacc_device_num];\n \n   gomp_mutex_lock (&acc_dev->lock);\n@@ -494,7 +529,7 @@ acc_get_device_type (void)\n       gomp_init_targets_once ();\n \n       gomp_mutex_lock (&acc_device_lock);\n-      dev = resolve_device (acc_device_default);\n+      dev = resolve_device (acc_device_default, true);\n       gomp_mutex_unlock (&acc_device_lock);\n       res = acc_device_type (dev->type);\n     }\n@@ -514,16 +549,14 @@ acc_get_device_num (acc_device_t d)\n   struct goacc_thread *thr = goacc_thread ();\n \n   if (d >= _ACC_device_hwm)\n-    gomp_fatal (\"device %u out of range\", (unsigned)d);\n+    gomp_fatal (\"unknown device type %u\", (unsigned) d);\n \n   if (!cached_base_dev)\n     gomp_init_targets_once ();\n \n   gomp_mutex_lock (&acc_device_lock);\n-  dev = resolve_device (d);\n+  dev = resolve_device (d, true);\n   gomp_mutex_unlock (&acc_device_lock);\n-  if (!dev)\n-    gomp_fatal (\"device %s not supported\", name_of_acc_device_t (d));\n \n   if (thr && thr->base_dev == dev && thr->dev)\n     return thr->dev->target_id;\n@@ -554,12 +587,12 @@ acc_set_device_num (int ord, acc_device_t d)\n     {\n       gomp_mutex_lock (&acc_device_lock);\n \n-      cached_base_dev = base_dev = resolve_device (d);\n+      cached_base_dev = base_dev = resolve_device (d, true);\n \n       num_devices = base_dev->get_num_devices_func ();\n \n-      if (ord >= num_devices)\n-        gomp_fatal (\"device %u out of range\", ord);\n+      if (num_devices <= 0 || ord >= num_devices)\n+        acc_dev_num_out_of_range (d, ord, num_devices);\n \n       acc_dev = &base_dev[ord];\n "}, {"sha": "3bb9ea512b60b0329e9df012fbdb1363f3e17776", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb5fd444bef7601aec09778bc6ee926a6f76fd4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb5fd444bef7601aec09778bc6ee926a6f76fd4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-4.c?ref=9fb5fd444bef7601aec09778bc6ee926a6f76fd4", "patch": "@@ -10,5 +10,5 @@ main (int argc, char **argv)\n   return 0;\n }\n \n-/* { dg-output \"device \\[0-9\\]+ out of range\" } */\n+/* { dg-output \"unknown device type \\[0-9\\]+\" } */\n /* { dg-shouldfail \"\" } */"}]}