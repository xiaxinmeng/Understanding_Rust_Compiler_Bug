{"sha": "8d51ecf8a06d682387cdb49aa00daa5c59b3e4eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ1MWVjZjhhMDZkNjgyMzg3Y2RiNDlhYTAwZGFhNWM1OWIzZTRlYg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2001-12-11T14:51:55Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2001-12-11T14:51:55Z"}, "message": "builtins.c (expand_builtin): Use a switch statement to list those functions not expanded without...\n\n\t* builtins.c (expand_builtin): Use a switch statement to list\n\tthose functions not expanded without optimizations, instead of a\n\tseries of equality tests.\n\nFrom-SVN: r47876", "tree": {"sha": "a83f26c0fbf4fb7c476808332fa14faa7b9ec89f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a83f26c0fbf4fb7c476808332fa14faa7b9ec89f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d51ecf8a06d682387cdb49aa00daa5c59b3e4eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d51ecf8a06d682387cdb49aa00daa5c59b3e4eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d51ecf8a06d682387cdb49aa00daa5c59b3e4eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d51ecf8a06d682387cdb49aa00daa5c59b3e4eb/comments", "author": null, "committer": null, "parents": [{"sha": "19cfdd34bc7ae1a414ca0f9157d88ceed5655dc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19cfdd34bc7ae1a414ca0f9157d88ceed5655dc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19cfdd34bc7ae1a414ca0f9157d88ceed5655dc2"}], "stats": {"total": 192, "additions": 110, "deletions": 82}, "files": [{"sha": "a2ec53c90053a8543c26f5d236561b5a44683c38", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d51ecf8a06d682387cdb49aa00daa5c59b3e4eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d51ecf8a06d682387cdb49aa00daa5c59b3e4eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d51ecf8a06d682387cdb49aa00daa5c59b3e4eb", "patch": "@@ -1,3 +1,9 @@\n+2001-12-10  Roger Sayle <roger@eyesopen.com>\n+\n+\t* builtins.c (expand_builtin): Use a switch statement to list\n+\tthose functions not expanded without optimizations, instead of a\n+\tseries of equality tests.\n+\n Tue Dec 11 07:08:57 2001  Douglas B. Rupp  <rupp@gnat.com>\n \n \t* config/alpha/vms.h (LIB_SPEC): Define.\n@@ -195,11 +201,11 @@ Sun Dec  9 18:40:07 2001  Douglas B. Rupp  <rupp@gnat.com>\n \n \t* config/rs6000/aix43.h (NON_POWERPC_MASKS): Delete MASK_STRING.\n \t* config/rs6000/aix51.h (NON_POWERPC_MASKS): Same.\n- \t* config/rs6000/rs6000.md (load_multiple, store_multiple): Do not use \n- \tfor powerpc64.\n- \t* config/rs6000/rs6000.md (movstrsi_8reg, movstrsi_6reg, \n- \tmovstrsi_4reg, movstrsi_1_reg): Add powerpc64.\n-\t* config/rs6000/rs6000.c (expand_block_move): Do not use \n+\t* config/rs6000/rs6000.md (load_multiple, store_multiple): Do not use\n+\tfor powerpc64.\n+\t* config/rs6000/rs6000.md (movstrsi_8reg, movstrsi_6reg,\n+\tmovstrsi_4reg, movstrsi_1_reg): Add powerpc64.\n+\t* config/rs6000/rs6000.c (expand_block_move): Do not use\n \tgen_movstrsi_2reg and powerpc64.\n \n 2001-10-08  Aldy Hernandez  <aldyh@redhat.com>\n@@ -276,16 +282,16 @@ Sun Dec  9 18:40:07 2001  Douglas B. Rupp  <rupp@gnat.com>\n         * config/rs6000/darwin.h: Set MAX_LONG_TYPE_SIZE to 32.\n         * config/rs6000/rs6000.c (rs6000_emit_move): In Darwin-\n         specific codegen, eliminate a register copy.\n-        (print_operand_address): Add support for Darwin's lo16(constant) \n+        (print_operand_address): Add support for Darwin's lo16(constant)\n \tsyntax.\n-        (rs6000_machopic_legitimize_pic_address): Fix darwin-specific \n+        (rs6000_machopic_legitimize_pic_address): Fix darwin-specific\n         generation of addresses within very large data objects.\n         (s8bit_cint_operand):  New.\n         * config/rs6000/rs6000.md: Remove \"iu\" reference for 750/7400.\n         Move \"mtjmpr\" to correct functional unit for 750/7400/7450.\n-        Add imul2 and imul3 insn types for multiplication by 16- and \n+        Add imul2 and imul3 insn types for multiplication by 16- and\n \t8-bit constants.\n-        Change tablejump patterns to strongly discourage using LR \n+        Change tablejump patterns to strongly discourage using LR\n \trather than CTR.\n \tAdd %lo16 patterns for Darwin loads and stores.\n \n@@ -578,7 +584,7 @@ Wed Dec  5 17:59:19 2001  Douglas B. Rupp  <rupp@gnat.com>\n \t* config/alpha/vms.h (SIZE_TYPE, PTRDIFF_TYPE): Remove, were disabled.\n \t(DOLLARS_IN_IDENTIFIERS, LINK_SPEC): Remove duplicate.\n \t(LIB_SPEC): Remove.\n-\t\n+\n Wed Dec  5 16:03:04 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* doc/c-tree.texi (RECORD_TYPE, UNION_TYPE): Expand on definition.\n@@ -640,7 +646,7 @@ Wed Dec  5 16:03:04 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n 2001-12-05  Daniel Berlin  <dan@cgsoftware.com>\n \n \t* config/rs6000/rs6000.h (enum rs6000_builtins): Add more altivec\n-\tbuiltins. \n+\tbuiltins.\n \n \t* config/rs6000/rs6000.md: Modeling of 7450 altivec changed to\n \tbetter reflect reality (change from Apple's tree).\n@@ -649,7 +655,7 @@ Wed Dec  5 16:03:04 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \tRemove more unspecs (vector merge instructions, etc).\n \n \t* config/rs6000/rs6000.c (bdesc_3arg): New, for 3 argument altivec\n-\tbuiltins. \n+\tbuiltins.\n \t(bdesc_1arg): New, for 1 argument altivec builtins.\n \t(altivec_expand_builtin): Handle unary and ternary ops.\n \t(altivec_init_builtins): Ditto.\n@@ -688,7 +694,7 @@ Wed Dec  5 07:41:13 2001  Douglas B. Rupp  <rupp@gnat.com>\n \n Wed Dec  5 07:27:42 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t\t\t  Douglas B. Rupp  <rupp@gnat.com>\n-\t\n+\n \t* vmsdbg.h, vmsdbgout.c: Add documentation and minor cleanups.\n \t* doc/invoke.texi: Add -gvms.\n \t* doc/passes.texi: Add mention of vmsdbgout.c.\n@@ -815,14 +821,14 @@ Wed Dec  5 00:42:16 EST 2001  John Wehle  (john@feith.com)\n \n 2001-12-04  Andrew MacLeod  <amacleod@redhat.com>\n \n-\t* stmt.c (expand_return): Clear destination instead of clobbering it \n+\t* stmt.c (expand_return): Clear destination instead of clobbering it\n \twhen setting a return value via bitsets.\n \n 2001-12-04  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* tree.c (get_callee_fndecl): Only use DECL_ABSTRACT_ORIGIN if\n \tit has DECL_SAVED_TREE.\n-\t\n+\n \t* c-decl.c (duplicate_decls): Revert rth's patch.  If newdecl\n \tis in a different binding level, get its abstract origin to be\n \tolddecl."}, {"sha": "e21e05547824c68754366204dd8b6a5f8554b699", "filename": "gcc/builtins.c", "status": "modified", "additions": 89, "deletions": 67, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d51ecf8a06d682387cdb49aa00daa5c59b3e4eb/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d51ecf8a06d682387cdb49aa00daa5c59b3e4eb/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=8d51ecf8a06d682387cdb49aa00daa5c59b3e4eb", "patch": "@@ -79,7 +79,7 @@ static tree c_strlen\t\t\tPARAMS ((tree));\n static const char *c_getstr\t\tPARAMS ((tree));\n static rtx c_readstr\t\t\tPARAMS ((const char *,\n \t\t\t\t\t\t enum machine_mode));\n-static int target_char_cast\t\tPARAMS ((tree, char *)); \n+static int target_char_cast\t\tPARAMS ((tree, char *));\n static rtx get_memory_rtx\t\tPARAMS ((tree));\n static int apply_args_size\t\tPARAMS ((void));\n static int apply_result_size\t\tPARAMS ((void));\n@@ -757,7 +757,7 @@ expand_builtin_prefetch (arglist)\n        error (\"second arg to `__builtin_prefetch' must be a constant\");\n        arg1 = integer_zero_node;\n     }\n-  op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0); \n+  op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n   /* Argument 1 must be either zero or one.  */\n   if (INTVAL (op1) != 0 && INTVAL (op1) != 1)\n     {\n@@ -771,7 +771,7 @@ expand_builtin_prefetch (arglist)\n       error (\"third arg to `__builtin_prefetch' must be a constant\");\n       arg2 = integer_zero_node;\n     }\n-  op2 = expand_expr (arg2, NULL_RTX, VOIDmode, 0); \n+  op2 = expand_expr (arg2, NULL_RTX, VOIDmode, 0);\n   /* Argument 2 must be 0, 1, 2, or 3.  */\n   if (INTVAL (op2) < 0 || INTVAL (op2) > 3)\n     {\n@@ -858,11 +858,11 @@ static enum machine_mode apply_result_mode[FIRST_PSEUDO_REGISTER];\n    used for calling a function.  */\n static int apply_args_reg_offset[FIRST_PSEUDO_REGISTER];\n \n-/* Return the offset of register REGNO into the block returned by \n+/* Return the offset of register REGNO into the block returned by\n    __builtin_apply_args.  This is not declared static, since it is\n    needed in objc-act.c.  */\n \n-int \n+int\n apply_args_register_offset (regno)\n      int regno;\n {\n@@ -1043,7 +1043,7 @@ result_vector (savep, result)\n   enum machine_mode mode;\n   rtx reg, mem;\n   rtx *savevec = (rtx *) alloca (FIRST_PSEUDO_REGISTER * sizeof (rtx));\n-  \n+\n   size = nelts = 0;\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if ((mode = apply_result_mode[regno]) != VOIDmode)\n@@ -1415,7 +1415,7 @@ type_to_class (type)\n     default:\t\t   return no_type_class;\n     }\n }\n-  \n+\n /* Expand a call to __builtin_classify_type with arguments found in\n    ARGLIST.  */\n \n@@ -1462,7 +1462,7 @@ expand_builtin_mathfn (exp, target, subtarget)\n      tree exp;\n      rtx target, subtarget;\n {\n-  optab builtin_optab;  \n+  optab builtin_optab;\n   rtx op0, insns;\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   tree arglist = TREE_OPERAND (exp, 1);\n@@ -1571,7 +1571,7 @@ expand_builtin_mathfn (exp, target, subtarget)\n   insns = get_insns ();\n   end_sequence ();\n   emit_insns (insns);\n- \n+\n   return target;\n }\n \n@@ -1648,7 +1648,7 @@ expand_builtin_strlen (exp, target)\n \n       /* Now that we are assured of success, expand the source.  */\n       start_sequence ();\n-      pat = memory_address (BLKmode, \n+      pat = memory_address (BLKmode,\n \t\t\t    expand_expr (src, src_reg, ptr_mode, EXPAND_SUM));\n       if (pat != src_reg)\n \temit_move_insn (src_reg, pat);\n@@ -2045,7 +2045,7 @@ expand_builtin_strncpy (arglist, target, mode)\n            side-effects.  */\n \t  expand_expr (TREE_VALUE (TREE_CHAIN (arglist)), const0_rtx,\n \t\t       VOIDmode, EXPAND_NORMAL);\n-\t  /* Return the dst parameter.  */\t\t       \n+\t  /* Return the dst parameter.  */\n \t  return expand_expr (TREE_VALUE (arglist), target, mode,\n \t\t\t      EXPAND_NORMAL);\n \t}\n@@ -2079,7 +2079,7 @@ expand_builtin_strncpy (arglist, target, mode)\n \t\t\t   (PTR) p, dest_align);\n \t  return force_operand (XEXP (dest_mem, 0), NULL_RTX);\n \t}\n-      \n+\n       /* OK transform into builtin memcpy.  */\n       return expand_builtin_memcpy (arglist);\n     }\n@@ -2126,7 +2126,7 @@ expand_builtin_memset (exp)\n \t= get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n       rtx dest_mem, dest_addr, len_rtx;\n \n-      /* If DEST is not a pointer type, don't do this \n+      /* If DEST is not a pointer type, don't do this\n \t operation in-line.  */\n       if (dest_align == 0)\n \treturn 0;\n@@ -2182,17 +2182,17 @@ expand_builtin_bzero (exp)\n \n   dest = TREE_VALUE (arglist);\n   size = TREE_VALUE (TREE_CHAIN (arglist));\n-  \n+\n   /* New argument list transforming bzero(ptr x, int y) to\n      memset(ptr x, int 0, size_t y).  */\n-  \n+\n   newarglist = build_tree_list (NULL_TREE, convert (sizetype, size));\n   newarglist = tree_cons (NULL_TREE, integer_zero_node, newarglist);\n   newarglist = tree_cons (NULL_TREE, dest, newarglist);\n \n   TREE_OPERAND (exp, 1) = newarglist;\n   result = expand_builtin_memset(exp);\n-      \n+\n   /* Always restore the original arguments.  */\n   TREE_OPERAND (exp, 1) = arglist;\n \n@@ -2324,7 +2324,7 @@ expand_builtin_strcmp (exp, target, mode)\n       tree result = fold (build (MINUS_EXPR, integer_type_node, ind1, ind2));\n       return expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n-  \n+\n #ifdef HAVE_cmpstrsi\n   if (! HAVE_cmpstrsi)\n     return 0;\n@@ -2447,7 +2447,7 @@ expand_builtin_strncmp (exp, target, mode)\n      lengths, and it doesn't have side effects, then call\n      expand_builtin_memcmp() using length MIN(strlen(string)+1, arg3).  */\n   if (HAVE_cmpstrsi)\n-    { \n+    {\n       tree newarglist, len = 0;\n \n       /* Perhaps one of the strings is really constant, if so prefer\n@@ -2466,10 +2466,10 @@ expand_builtin_strncmp (exp, target, mode)\n       /* If we still don't have a length, punt.  */\n       if (!len)\n \treturn 0;\n-\t\n+\n       /* Add one to the string length.  */\n       len = fold (size_binop (PLUS_EXPR, len, ssize_int (1)));\n-        \n+\n       /* The actual new length parameter is MIN(len,arg3).  */\n       len = fold (build (MIN_EXPR, TREE_TYPE (len), len, arg3));\n \n@@ -2479,7 +2479,7 @@ expand_builtin_strncmp (exp, target, mode)\n       return expand_builtin_memcmp (exp, newarglist, target);\n     }\n #endif\n-  \n+\n   return 0;\n }\n \n@@ -2549,7 +2549,7 @@ expand_builtin_strncat (arglist, target, mode)\n \t  tree newarglist =\n \t    tree_cons (NULL_TREE, dst, build_tree_list (NULL_TREE, src)),\n \t    fn = built_in_decls[BUILT_IN_STRCAT];\n-\t  \n+\n \t  /* If the replacement _DECL isn't initialized, don't do the\n \t     transformation.  */\n \t  if (!fn)\n@@ -2578,14 +2578,14 @@ expand_builtin_strspn (arglist, target, mode)\n     {\n       tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n       const char *p1 = c_getstr (s1), *p2 = c_getstr (s2);\n-      \n+\n       /* If both arguments are constants, evaluate at compile-time.  */\n       if (p1 && p2)\n         {\n \t  const size_t r = strspn (p1, p2);\n \t  return expand_expr (size_int (r), target, mode, EXPAND_NORMAL);\n \t}\n-      \n+\n       /* If either argument is \"\", return 0.  */\n       if ((p1 && *p1 == '\\0') || (p2 && *p2 == '\\0'))\n         {\n@@ -2615,14 +2615,14 @@ expand_builtin_strcspn (arglist, target, mode)\n     {\n       tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n       const char *p1 = c_getstr (s1), *p2 = c_getstr (s2);\n-      \n+\n       /* If both arguments are constants, evaluate at compile-time.  */\n       if (p1 && p2)\n         {\n \t  const size_t r = strcspn (p1, p2);\n \t  return expand_expr (size_int (r), target, mode, EXPAND_NORMAL);\n \t}\n-      \n+\n       /* If the first argument is \"\", return 0.  */\n       if (p1 && *p1 == '\\0')\n         {\n@@ -2637,7 +2637,7 @@ expand_builtin_strcspn (arglist, target, mode)\n         {\n \t  tree newarglist = build_tree_list (NULL_TREE, s1),\n \t    fn = built_in_decls[BUILT_IN_STRLEN];\n-\t  \n+\n \t  /* If the replacement _DECL isn't initialized, don't do the\n \t     transformation.  */\n \t  if (!fn)\n@@ -2711,7 +2711,7 @@ expand_builtin_args_info (exp)\n   tree arglist = TREE_OPERAND (exp, 1);\n   int nwords = sizeof (CUMULATIVE_ARGS) / sizeof (int);\n   int *word_ptr = (int *) &current_function_args_info;\n-#if 0\t\n+#if 0\n   /* These are used by the code below that is if 0'ed away */\n   int i;\n   tree type, elts, result;\n@@ -2777,7 +2777,7 @@ expand_builtin_next_arg (arglist)\n       tree arg = TREE_VALUE (arglist);\n \n       /* Strip off all nops for the sake of the comparison.  This\n-\t is not quite the same as STRIP_NOPS.  It does more.  \n+\t is not quite the same as STRIP_NOPS.  It does more.\n \t We must also strip off INDIRECT_EXPR for C++ reference\n \t parameters.  */\n       while (TREE_CODE (arg) == NOP_EXPR\n@@ -2818,10 +2818,10 @@ stabilize_va_list (valist, needs_lvalue)\n \t So fix it.  */\n       if (TREE_CODE (TREE_TYPE (valist)) == ARRAY_TYPE)\n \t{\n- \t  tree p1 = build_pointer_type (TREE_TYPE (va_list_type_node));\n- \t  tree p2 = build_pointer_type (va_list_type_node);\n+\t  tree p1 = build_pointer_type (TREE_TYPE (va_list_type_node));\n+\t  tree p2 = build_pointer_type (va_list_type_node);\n \n- \t  valist = build1 (ADDR_EXPR, p2, valist);\n+\t  valist = build1 (ADDR_EXPR, p2, valist);\n \t  valist = fold (build1 (NOP_EXPR, p1, valist));\n \t}\n     }\n@@ -2833,7 +2833,7 @@ stabilize_va_list (valist, needs_lvalue)\n \t{\n \t  if (! TREE_SIDE_EFFECTS (valist))\n \t    return valist;\n-\t  \n+\n \t  pt = build_pointer_type (va_list_type_node);\n \t  valist = fold (build1 (ADDR_EXPR, pt, valist));\n \t  TREE_SIDE_EFFECTS (valist) = 1;\n@@ -2966,7 +2966,7 @@ expand_builtin_va_arg (valist, type)\n   have_va_type = TREE_TYPE (valist);\n   if (TREE_CODE (want_va_type) == ARRAY_TYPE)\n     {\n-      /* If va_list is an array type, the argument may have decayed \n+      /* If va_list is an array type, the argument may have decayed\n \t to a pointer type, e.g. by being passed to another function.\n          In that case, unwrap both types so that we can compare the\n \t underlying records.  */\n@@ -3061,7 +3061,7 @@ expand_builtin_va_end (arglist)\n   return const0_rtx;\n }\n \n-/* Expand ARGLIST, from a call to __builtin_va_copy.  We do this as a \n+/* Expand ARGLIST, from a call to __builtin_va_copy.  We do this as a\n    builtin rather than just as an assignment in stdarg.h because of the\n    nastiness of array-type va_list types.  */\n \n@@ -3263,7 +3263,7 @@ expand_builtin_fputs (arglist, ignore)\n \tconst char *p = c_getstr (TREE_VALUE (arglist));\n \n \tif (p != NULL)\n-\t  {      \n+\t  {\n \t    /* New argument list transforming fputs(string, stream) to\n \t       fputc(string[0], stream).  */\n \t    arglist =\n@@ -3278,7 +3278,7 @@ expand_builtin_fputs (arglist, ignore)\n     case 1: /* length is greater than 1, call fwrite.  */\n       {\n \ttree string_arg = TREE_VALUE (arglist);\n-      \n+\n \t/* New argument list transforming fputs(string, stream) to\n \t   fwrite(string, 1, len, stream).  */\n \targlist = build_tree_list (NULL_TREE, TREE_VALUE (TREE_CHAIN (arglist)));\n@@ -3291,7 +3291,7 @@ expand_builtin_fputs (arglist, ignore)\n     default:\n       abort();\n     }\n-  \n+\n   return expand_expr (build_function_call_expr (fn, arglist),\n \t\t      (ignore ? const0_rtx : NULL_RTX),\n \t\t      VOIDmode, EXPAND_NORMAL);\n@@ -3330,7 +3330,7 @@ expand_builtin_expect (arglist, target)\n \t moderately sure to be able to correctly interpret the branch\n \t condition later.  */\n       target = force_reg (GET_MODE (target), target);\n-  \n+\n       rtx_c = expand_expr (c, NULL_RTX, GET_MODE (target), EXPAND_NORMAL);\n \n       note = emit_note (NULL, NOTE_INSN_EXPECTED_VALUE);\n@@ -3482,27 +3482,49 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \n   if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD)\n     return (*targetm.expand_builtin) (exp, target, subtarget, mode, ignore);\n-  \n+\n   /* When not optimizing, generate calls to library functions for a certain\n      set of builtins.  */\n-  if (! optimize && ! CALLED_AS_BUILT_IN (fndecl)\n-      && (fcode == BUILT_IN_SIN || fcode == BUILT_IN_COS\n-\t  || fcode == BUILT_IN_FSQRT || fcode == BUILT_IN_SQRTF\n-\t  || fcode == BUILT_IN_SQRTL || fcode == BUILT_IN_MEMSET\n-\t  || fcode == BUILT_IN_MEMCPY || fcode == BUILT_IN_MEMCMP\n-\t  || fcode == BUILT_IN_BCMP || fcode == BUILT_IN_BZERO\n-\t  || fcode == BUILT_IN_INDEX || fcode == BUILT_IN_RINDEX\n-\t  || fcode == BUILT_IN_STRCHR || fcode == BUILT_IN_STRRCHR\n-\t  || fcode == BUILT_IN_STRLEN || fcode == BUILT_IN_STRCPY\n-\t  || fcode == BUILT_IN_STRNCPY || fcode == BUILT_IN_STRNCMP\n-\t  || fcode == BUILT_IN_STRSTR || fcode == BUILT_IN_STRPBRK\n-\t  || fcode == BUILT_IN_STRCAT || fcode == BUILT_IN_STRNCAT\n-\t  || fcode == BUILT_IN_STRSPN || fcode == BUILT_IN_STRCSPN\n-\t  || fcode == BUILT_IN_STRCMP || fcode == BUILT_IN_FFS\n-\t  || fcode == BUILT_IN_PUTCHAR || fcode == BUILT_IN_PUTS\n-\t  || fcode == BUILT_IN_PRINTF || fcode == BUILT_IN_FPUTC\n-\t  || fcode == BUILT_IN_FPUTS || fcode == BUILT_IN_FWRITE))\n-    return expand_call (exp, target, ignore);\n+  if (!optimize && !CALLED_AS_BUILT_IN (fndecl))\n+    switch (fcode)\n+      {\n+      case BUILT_IN_SIN:\n+      case BUILT_IN_COS:\n+      case BUILT_IN_FSQRT:\n+      case BUILT_IN_SQRTF:\n+      case BUILT_IN_SQRTL:\n+      case BUILT_IN_MEMSET:\n+      case BUILT_IN_MEMCPY:\n+      case BUILT_IN_MEMCMP:\n+      case BUILT_IN_BCMP:\n+      case BUILT_IN_BZERO:\n+      case BUILT_IN_INDEX:\n+      case BUILT_IN_RINDEX:\n+      case BUILT_IN_STRCHR:\n+      case BUILT_IN_STRRCHR:\n+      case BUILT_IN_STRLEN:\n+      case BUILT_IN_STRCPY:\n+      case BUILT_IN_STRNCPY:\n+      case BUILT_IN_STRNCMP:\n+      case BUILT_IN_STRSTR:\n+      case BUILT_IN_STRPBRK:\n+      case BUILT_IN_STRCAT:\n+      case BUILT_IN_STRNCAT:\n+      case BUILT_IN_STRSPN:\n+      case BUILT_IN_STRCSPN:\n+      case BUILT_IN_STRCMP:\n+      case BUILT_IN_FFS:\n+      case BUILT_IN_PUTCHAR:\n+      case BUILT_IN_PUTS:\n+      case BUILT_IN_PRINTF:\n+      case BUILT_IN_FPUTC:\n+      case BUILT_IN_FPUTS:\n+      case BUILT_IN_FWRITE:\n+        return expand_call (exp, target, ignore);\n+\n+      default:\n+        break;\n+    }\n \n   switch (fcode)\n     {\n@@ -3643,49 +3665,49 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       if (target)\n \treturn target;\n       break;\n-      \n+\n     case BUILT_IN_STRNCPY:\n       target = expand_builtin_strncpy (arglist, target, mode);\n       if (target)\n \treturn target;\n       break;\n-      \n+\n     case BUILT_IN_STRCAT:\n       target = expand_builtin_strcat (arglist, target, mode);\n       if (target)\n \treturn target;\n       break;\n-      \n+\n     case BUILT_IN_STRNCAT:\n       target = expand_builtin_strncat (arglist, target, mode);\n       if (target)\n \treturn target;\n       break;\n-      \n+\n     case BUILT_IN_STRSPN:\n       target = expand_builtin_strspn (arglist, target, mode);\n       if (target)\n \treturn target;\n       break;\n-      \n+\n     case BUILT_IN_STRCSPN:\n       target = expand_builtin_strcspn (arglist, target, mode);\n       if (target)\n \treturn target;\n       break;\n-      \n+\n     case BUILT_IN_STRSTR:\n       target = expand_builtin_strstr (arglist, target, mode);\n       if (target)\n \treturn target;\n       break;\n-      \n+\n     case BUILT_IN_STRPBRK:\n       target = expand_builtin_strpbrk (arglist, target, mode);\n       if (target)\n \treturn target;\n       break;\n-      \n+\n     case BUILT_IN_INDEX:\n     case BUILT_IN_STRCHR:\n       target = expand_builtin_strchr (arglist, target, mode);\n@@ -3795,7 +3817,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       if (target)\n \treturn target;\n       break;\n-      \n+\n       /* Various hooks for the DWARF 2 __throw routine.  */\n     case BUILT_IN_UNWIND_INIT:\n       expand_builtin_unwind_init ();"}]}