{"sha": "790e949032a94bc90fc4fcf79b31c8c14850dcb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzkwZTk0OTAzMmE5NGJjOTBmYzRmY2Y3OWIzMWM4YzE0ODUwZGNiMQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-30T06:52:04Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-30T06:52:04Z"}, "message": "(push_init_level): For braces around scalar, just warn.\n\n(process_init_element): Special handling for {\"foo\"}.\n(struct constructor_stack): New field `replacement_value'.\n(push_init_level, really_start_incremental_init): Clear new field.\n(pop_init_level): Return the replacement_value if any.\nAt top level in initializer, output that value,\nand set the array size from it.\n\n(digest_init): Delete arg TAIL.  Fix all calls.\n\n(convert_for_assignment): Mismatch in signedness\nof pointer targets should not inhibit warnings for const mismatch.\n\nFrom-SVN: r5042", "tree": {"sha": "b24f6edee9d586f84b705e22650da55ae18c9a24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b24f6edee9d586f84b705e22650da55ae18c9a24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/790e949032a94bc90fc4fcf79b31c8c14850dcb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/790e949032a94bc90fc4fcf79b31c8c14850dcb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/790e949032a94bc90fc4fcf79b31c8c14850dcb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/790e949032a94bc90fc4fcf79b31c8c14850dcb1/comments", "author": null, "committer": null, "parents": [{"sha": "6d7512e47340cf0451ca674ed78b45375d579163", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d7512e47340cf0451ca674ed78b45375d579163", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d7512e47340cf0451ca674ed78b45375d579163"}], "stats": {"total": 109, "additions": 89, "deletions": 20}, "files": [{"sha": "e4d4f240ff51349d1a697ce982df1ff4918b1a0c", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 89, "deletions": 20, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/790e949032a94bc90fc4fcf79b31c8c14850dcb1/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/790e949032a94bc90fc4fcf79b31c8c14850dcb1/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=790e949032a94bc90fc4fcf79b31c8c14850dcb1", "patch": "@@ -3899,7 +3899,7 @@ build_c_cast (type, expr)\n \t    name = \"\";\n \t  return digest_init (type, build_nt (CONSTRUCTOR, NULL_TREE,\n \t\t\t\t\t      build_tree_list (field, value)),\n-\t\t\t      NULL_PTR, 0, 0, name);\n+\t\t\t      0, 0);\n \t}\n       error (\"cast to union type from type not present in union\");\n       return error_mark_node;\n@@ -4273,7 +4273,9 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t Meanwhile, the lhs target must have all the qualifiers of the rhs.  */\n       if (TYPE_MAIN_VARIANT (ttl) == void_type_node\n \t  || TYPE_MAIN_VARIANT (ttr) == void_type_node\n-\t  || comp_target_types (type, rhstype))\n+\t  || comp_target_types (type, rhstype)\n+\t  || (unsigned_type (TYPE_MAIN_VARIANT (ttl))\n+\t      == unsigned_type (TYPE_MAIN_VARIANT (ttr))))\n \t{\n \t  if (pedantic\n \t      && ((TYPE_MAIN_VARIANT (ttl) == void_type_node\n@@ -4292,9 +4294,19 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t      if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n \t\twarn_for_assignment (\"%s discards `const' from pointer target type\",\n \t\t\t\t     get_spelling (errtype), funname, parmnum);\n-\t      if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n+\t      else if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n \t\twarn_for_assignment (\"%s discards `volatile' from pointer target type\",\n \t\t\t\t     get_spelling (errtype), funname, parmnum);\n+\t      /* If this is not a case of ignoring a mismatch in signedness,\n+\t\t no warning.  */\n+\t      else if (TYPE_MAIN_VARIANT (ttl) == void_type_node\n+\t\t       || TYPE_MAIN_VARIANT (ttr) == void_type_node\n+\t\t       || comp_target_types (type, rhstype))\n+\t\t;\n+\t      /* If there is a mismatch, do warn.  */\n+\t      else if (pedantic)\n+\t\twarn_for_assignment (\"pointer targets in %s differ in signedness\",\n+\t\t\t\t     get_spelling (errtype), funname, parmnum);\n \t    }\n \t  else\n \t    {\n@@ -4310,13 +4322,6 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t\t\t\t     get_spelling (errtype), funname, parmnum);\n \t    }\n \t}\n-      else if (unsigned_type (TYPE_MAIN_VARIANT (ttl))\n-\t       == unsigned_type (TYPE_MAIN_VARIANT (ttr)))\n-\t{\n-\t  if (pedantic)\n-\t    warn_for_assignment (\"pointer targets in %s differ in signedness\",\n-\t\t\t\t get_spelling (errtype), funname, parmnum);\n-\t}\n       else\n \twarn_for_assignment (\"%s from incompatible pointer type\",\n \t\t\t     get_spelling (errtype), funname, parmnum);\n@@ -4536,9 +4541,8 @@ store_init_value (decl, init)\n \n   /* Digest the specified initializer into an expression.  */\n \n-  value = digest_init (type, init, NULL_PTR, TREE_STATIC (decl),\n-\t\t       TREE_STATIC (decl) || pedantic, \n-\t\t       IDENTIFIER_POINTER (DECL_NAME (decl)));\n+  value = digest_init (type, init, TREE_STATIC (decl),\n+\t\t       TREE_STATIC (decl) || pedantic);\n \n   /* Store the expression if valid; else report error.  */\n \n@@ -4832,8 +4836,8 @@ static tree free_tree_list = NULL_TREE;\n    (That is true for all nested calls to digest_init.)  */\n \n static tree\n-digest_init (type, init, tail, require_constant, constructor_constant)\n-     tree type, init, *tail;\n+digest_init (type, init, require_constant, constructor_constant)\n+     tree type, init;\n      int require_constant, constructor_constant;\n {\n   enum tree_code code = TREE_CODE (type);\n@@ -5156,6 +5160,9 @@ struct constructor_stack\n   int offset;\n   tree pending_elts;\n   int depth;\n+  /* If nonzero, this value should replace the entire\n+     constructor at this level.  */\n+  tree replacement_value;\n   char constant;\n   char simple;\n   char implicit;\n@@ -5319,6 +5326,7 @@ really_start_incremental_init (type)\n   p->erroneous = constructor_erroneous;\n   p->pending_elts = constructor_pending_elts;\n   p->depth = constructor_depth;\n+  p->replacement_value = 0;\n   p->implicit = 0;\n   p->incremental = constructor_incremental;\n   p->outer = 0;\n@@ -5400,6 +5408,7 @@ push_init_level (implicit)\n   p->erroneous = constructor_erroneous;\n   p->pending_elts = constructor_pending_elts;\n   p->depth = constructor_depth;\n+  p->replacement_value = 0;\n   p->implicit = implicit;\n   p->incremental = constructor_incremental;\n   p->outer = 0;\n@@ -5445,7 +5454,7 @@ push_init_level (implicit)\n     }\n   else\n     {\n-      error_init (\"braces where a scalar is expected%s\", \" for `%s'\", NULL);\n+      warning (\"braces around scalar initializer\");\n       constructor_fields = constructor_type;\n       constructor_unfilled_fields = constructor_type;\n     }\n@@ -5513,7 +5522,50 @@ pop_init_level (implicit)\n \n   /* Pad out the end of the structure.  */\n   \n-  if (! constructor_incremental)\n+  if (p->replacement_value)\n+    {\n+      /* If this closes a superfluous brace pair,\n+\t just pass out the element between them.  */\n+      constructor = p->replacement_value;\n+      /* If this is the top level thing within the initializer,\n+\t and it's for a variable, then since we already calle\n+\t assemble_variable, we must output the value now.  */\n+      if (p->next == 0 && constructor_decl != 0\n+\t  && constructor_incremental)\n+\t{\n+\t  constructor = digest_init (constructor_type, constructor,\n+\t\t\t\t     0, 0);\n+\n+\t  /* If initializing an array of unknown size,\n+\t     determine the size now.  */\n+\t  if (TREE_CODE (constructor_type) == ARRAY_TYPE\n+\t      && TYPE_DOMAIN (constructor_type) == 0)\n+\t    {\n+\t      int failure;\n+\n+\t      push_obstacks_nochange ();\n+\t      if (TREE_PERMANENT (constructor_type))\n+\t\tend_temporary_allocation ();\n+\n+\t      /* We shouldn't have an incomplete array type within\n+\t\t some other type.  */\n+\t      if (constructor_stack->next)\n+\t\tabort ();\n+\n+\t      failure\n+\t\t= complete_array_type (constructor_type,\n+\t\t\t\t       constructor, 0);\n+\t      if (failure)\n+\t\tabort ();\n+\n+\t      size = int_size_in_bytes (constructor_type);\n+\t      pop_obstacks ();\n+\t    }\n+\n+\t  output_constant (constructor, size);\n+\t}\n+    }\n+  else if (! constructor_incremental)\n     {\n       if (constructor_erroneous)\n \tconstructor = error_mark_node;\n@@ -5750,7 +5802,7 @@ output_init_element (value, type, field, pending)\n       if (! duplicate)\n \tconstructor_pending_elts\n \t  = tree_cons (field,\n-\t\t       digest_init (type, value, (tree *)NULL,\n+\t\t       digest_init (type, value,\n \t\t\t\t    require_constant_value,\n \t\t\t\t    require_constant_elements),\n \t\t       constructor_pending_elts);\n@@ -5762,7 +5814,7 @@ output_init_element (value, type, field, pending)\n       if (!duplicate)\n \tconstructor_pending_elts\n \t  = tree_cons (field,\n-\t\t       digest_init (type, value, (tree *)NULL,\n+\t\t       digest_init (type, value,\n \t\t\t\t    require_constant_value,\n \t\t\t\t    require_constant_elements),\n \t\t       constructor_pending_elts);\n@@ -5778,7 +5830,7 @@ output_init_element (value, type, field, pending)\n \t    constructor_elements\n \t      = tree_cons ((TREE_CODE (constructor_type) != ARRAY_TYPE\n \t\t\t    ? field : NULL),\n-\t\t\t   digest_init (type, value, (tree *)NULL,\n+\t\t\t   digest_init (type, value,\n \t\t\t\t\trequire_constant_value,\n \t\t\t\t\trequire_constant_elements),\n \t\t\t   constructor_elements);\n@@ -5981,6 +6033,16 @@ process_init_element (value)\n   tree orig_value = value;\n   int string_flag = value != 0 && TREE_CODE (value) == STRING_CST;\n \n+  /* Handle superfluous braces around string cst as in\n+     char x[] = {\"foo\"}; */\n+  if (string_flag\n+      && TREE_CODE (constructor_type) == ARRAY_TYPE\n+      && integer_zerop (constructor_unfilled_index))\n+    {\n+      constructor_stack->replacement_value = value;\n+      return;\n+    }\n+\n   if (value != 0)\n     value = default_conversion (value);\n \n@@ -5993,6 +6055,13 @@ process_init_element (value)\n   else if (initializer_constant_valid_p (value, TREE_TYPE (value)) == 0)\n     constructor_simple = 0;\n \n+  if (constructor_stack->replacement_value != 0)\n+    {\n+      error_init (\"excess elements in struct initializer%s\",\n+\t\t  \" after `%s'\", NULL_PTR);\n+      return;\n+    }\n+\n   /* If we've exhausted any levels that didn't have braces,\n      pop them now.  */\n   while (constructor_stack->implicit)"}]}