{"sha": "ed44da020e182d3eee3610fe8e5eacb9518f9848", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ0NGRhMDIwZTE4MmQzZWVlMzYxMGZlOGU1ZWFjYjk1MThmOTg0OA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-08-06T16:58:43Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-08-06T16:58:43Z"}, "message": "cp-tree.h (ENUM_TEMPLATE_INFO): New macro.\n\n\t* cp-tree.h (ENUM_TEMPLATE_INFO): New macro.\n\t(TYPE_TEMPLATE_INFO): Likewise.\n\t(SET_TYPE_TEMPLATE_INFO): Likewise.\n\t(ENUM_TI_TEMPLATE): Likewise.\n\t(ENUM_TI_ARGS): Likewise.\n\t(lookup_nested_type_by_name): Remove.\n\t* decl.c (maybe_process_template_type_declaration): Handle enums.\n\t(start_enum): Don't check for primary-template enum declarations\n\there.\n\t(finish_enum): Clean up, document.  Make sure template enum\n\tconstants get the correct type.\n\t(build_enumerator): Copy initializers for template enumerations,\n\ttoo.\n\t(grok_enum_decls): Document.\n\t* lex.c (do_identifier): Document use of LOOKUP_EXPR a bit\n\tbetter.  Build LOOKUP_EXPRs for local variables, even if they are\n\tTREE_PERMANENT.\n\t* pt.c (tsubst_enum): Remove field_chain parameter.\n\t(template_class_depth): Include the depth of surrounding function\n\tcontexts.\n\t(push_template_decl): Check for primary-template enum declarations\n\there.  Deal with enumeration templates.\n\t(lookup_template_class): Likewise.\n\t(for_each_template_parm): Likewise.\n\t(instantiate_class_template): Don't call tsubst_enum directly,\n\tcall tsubst instead, to instantiate enums.  Deal with all\n\tfield_chain issues here, not in tsubst_enum.\n\t(lookup_nested_type_by_name): Remove.\n\t(tsubst_aggr_type): Revise handling of enumeration types.\n\t(tsubst): Likewise.\n\t(tsubst_copy): Likewise.\n\t(tsubst_expr): Call tsubst, not tsubst_enum for TAG_DEFNs.\n\nFrom-SVN: r21622", "tree": {"sha": "b355abe185dd73456bde7f2fa6e7439b5e0ad9a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b355abe185dd73456bde7f2fa6e7439b5e0ad9a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed44da020e182d3eee3610fe8e5eacb9518f9848", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed44da020e182d3eee3610fe8e5eacb9518f9848", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed44da020e182d3eee3610fe8e5eacb9518f9848", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed44da020e182d3eee3610fe8e5eacb9518f9848/comments", "author": null, "committer": null, "parents": [{"sha": "a8b0896fe66c3ef592d99d3a2f02eb2d986eb2b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8b0896fe66c3ef592d99d3a2f02eb2d986eb2b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8b0896fe66c3ef592d99d3a2f02eb2d986eb2b1"}], "stats": {"total": 568, "additions": 411, "deletions": 157}, "files": [{"sha": "f6bc1b67b1967a2d38ade409787ddbb7a3f97bff", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed44da020e182d3eee3610fe8e5eacb9518f9848/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed44da020e182d3eee3610fe8e5eacb9518f9848/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ed44da020e182d3eee3610fe8e5eacb9518f9848", "patch": "@@ -1,3 +1,38 @@\n+1998-08-06  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.h (ENUM_TEMPLATE_INFO): New macro.\n+\t(TYPE_TEMPLATE_INFO): Likewise.\n+\t(SET_TYPE_TEMPLATE_INFO): Likewise.\n+\t(ENUM_TI_TEMPLATE): Likewise.\n+\t(ENUM_TI_ARGS): Likewise.\n+\t(lookup_nested_type_by_name): Remove.\n+\t* decl.c (maybe_process_template_type_declaration): Handle enums.\n+\t(start_enum): Don't check for primary-template enum declarations\n+\there. \n+\t(finish_enum): Clean up, document.  Make sure template enum\n+\tconstants get the correct type.\n+\t(build_enumerator): Copy initializers for template enumerations,\n+\ttoo. \n+\t(grok_enum_decls): Document.\n+\t* lex.c (do_identifier): Document use of LOOKUP_EXPR a bit\n+\tbetter.  Build LOOKUP_EXPRs for local variables, even if they are\n+\tTREE_PERMANENT.\n+\t* pt.c (tsubst_enum): Remove field_chain parameter.\n+\t(template_class_depth): Include the depth of surrounding function\n+\tcontexts.\n+\t(push_template_decl): Check for primary-template enum declarations\n+\there.  Deal with enumeration templates.\n+\t(lookup_template_class): Likewise.\n+\t(for_each_template_parm): Likewise.\n+\t(instantiate_class_template): Don't call tsubst_enum directly,\n+\tcall tsubst instead, to instantiate enums.  Deal with all\n+\tfield_chain issues here, not in tsubst_enum.\n+\t(lookup_nested_type_by_name): Remove.\n+\t(tsubst_aggr_type): Revise handling of enumeration types.\n+\t(tsubst): Likewise.\n+\t(tsubst_copy): Likewise.\n+\t(tsubst_expr): Call tsubst, not tsubst_enum for TAG_DEFNs.\n+\t\n 1998-08-04  Mark Mitchell  <mark@markmitchell.com>\n \n \t* decl.c (pushtag): Don't mangle the name of a TYPE_DECL if it"}, {"sha": "fdcd704803f640cf047e47fe3ed4c8b1ba988271", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed44da020e182d3eee3610fe8e5eacb9518f9848/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed44da020e182d3eee3610fe8e5eacb9518f9848/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ed44da020e182d3eee3610fe8e5eacb9518f9848", "patch": "@@ -1245,15 +1245,38 @@ struct lang_decl\n \n /* For a VAR_DECL or FUNCTION_DECL: template-specific information.  */\n #define DECL_TEMPLATE_INFO(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.template_info)\n+\n+/* Template information for a RECORD_TYPE or UNION_TYPE.  */\n #define CLASSTYPE_TEMPLATE_INFO(NODE) (TYPE_LANG_SPECIFIC(NODE)->template_info)\n+\n+/* Template information for an ENUMERAL_TYPE.  Although an enumeration may\n+   not be a primary template, it may be declared within the scope of a\n+   primary template and the enumeration constants may depend on\n+   non-type template parameters.  */\n+#define ENUM_TEMPLATE_INFO(NODE) (TYPE_BINFO (NODE))\n+\n+/* Template information for an ENUMERAL_, RECORD_, or UNION_TYPE.  */\n+#define TYPE_TEMPLATE_INFO(NODE)\t\t\t\t\t\\\n+  (TREE_CODE (NODE) == ENUMERAL_TYPE \t\t\t\t\t\\\n+   ? ENUM_TEMPLATE_INFO (NODE) : CLASSTYPE_TEMPLATE_INFO (NODE))\n+\n+/* Set the template information for an ENUMERAL_, RECORD_, or\n+   UNION_TYPE to VAL.  */\n+#define SET_TYPE_TEMPLATE_INFO(NODE, VAL) \t\\\n+  (TREE_CODE (NODE) == ENUMERAL_TYPE \t\t\\\n+   ? (ENUM_TEMPLATE_INFO (NODE) = VAL) \t\t\\\n+   : (CLASSTYPE_TEMPLATE_INFO (NODE) = VAL))\n+\n #define TI_TEMPLATE(NODE) (TREE_PURPOSE (NODE))\n #define TI_ARGS(NODE) (TREE_VALUE (NODE))\n #define TI_SPEC_INFO(NODE) (TREE_CHAIN (NODE))\n #define TI_PENDING_TEMPLATE_FLAG(NODE) TREE_LANG_FLAG_1 (NODE)\n+\n /* TI_PENDING_SPECIALIZATION_FLAG on a template-info node indicates\n    that the template is a specialization of a member template, but\n    that we don't yet know which one.  */\n #define TI_PENDING_SPECIALIZATION_FLAG(NODE) TREE_LANG_FLAG_1 (NODE)\n+\n /* The TEMPLATE_DECL instantiated or specialized by NODE.  This\n    TEMPLATE_DECL will be the immediate parent, not the most general\n    template.  For example, in:\n@@ -1273,6 +1296,7 @@ struct lang_decl\n    the DECL_TI_TEMPLATE will be a LOOKUP_EXPR for `f' and the\n    DECL_TI_ARGS will be {int}.  */ \n #define DECL_TI_TEMPLATE(NODE)      TI_TEMPLATE (DECL_TEMPLATE_INFO (NODE))\n+\n /* The template arguments used to obtain this decl from the most\n    general form of DECL_TI_TEMPLATE.  For the example given for\n    DECL_TI_TEMPLATE, the DECL_TI_ARGS will be {int, double}.  These\n@@ -1282,6 +1306,19 @@ struct lang_decl\n #define CLASSTYPE_TI_TEMPLATE(NODE) TI_TEMPLATE (CLASSTYPE_TEMPLATE_INFO (NODE))\n #define CLASSTYPE_TI_ARGS(NODE)     TI_ARGS (CLASSTYPE_TEMPLATE_INFO (NODE))\n #define CLASSTYPE_TI_SPEC_INFO(NODE) TI_SPEC_INFO (CLASSTYPE_TEMPLATE_INFO (NODE))\n+#define ENUM_TI_TEMPLATE(NODE) \t\t\t\\\n+  TI_TEMPLATE (ENUM_TEMPLATE_INFO (NODE))\n+#define ENUM_TI_ARGS(NODE)\t\t\t\\\n+  TI_ARGS (ENUM_TEMPLATE_INFO (NODE))\n+\n+/* Like DECL_TI_TEMPLATE, but for an ENUMERAL_, RECORD_, or UNION_TYPE.  */\n+#define TYPE_TI_TEMPLATE(NODE)\t\t\t\\\n+  (TI_TEMPLATE (TYPE_TEMPLATE_INFO (NODE)))\n+\n+/* Like DECL_TI_ARGS, , but for an ENUMERAL_, RECORD_, or UNION_TYPE.  */\n+#define TYPE_TI_ARGS(NODE)\t\t\t\\\n+  (TI_ARGS (TYPE_TEMPLATE_INFO (NODE)))\n+\n #define INNERMOST_TEMPLATE_PARMS(NODE)  TREE_VALUE(NODE)\n \n #define TEMPLATE_PARMS_FOR_INLINE(NODE) TREE_LANG_FLAG_1 (NODE)\n@@ -2783,7 +2820,6 @@ extern void mark_class_instantiated\t\tPROTO((tree, int));\n extern void do_decl_instantiation\t\tPROTO((tree, tree, tree));\n extern void do_type_instantiation\t\tPROTO((tree, tree));\n extern tree instantiate_decl\t\t\tPROTO((tree));\n-extern tree lookup_nested_type_by_name\t\tPROTO((tree, tree));\n extern tree do_poplevel\t\t\t\tPROTO((void));\n extern tree get_bindings\t\t\tPROTO((tree, tree, tree));\n /* CONT ... */"}, {"sha": "1b70a1ba9151820378737ee192e8fbc2cd31c8cb", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 76, "deletions": 41, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed44da020e182d3eee3610fe8e5eacb9518f9848/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed44da020e182d3eee3610fe8e5eacb9518f9848/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ed44da020e182d3eee3610fe8e5eacb9518f9848", "patch": "@@ -2253,26 +2253,29 @@ maybe_process_template_type_declaration (type, globalize, b)\n     {\n       maybe_check_template_type (type);\n \n-      if (IS_AGGR_TYPE (type)\n-\t  && (/* If !GLOBALIZE then we are looking at a definition.\n-\t\t It may not be a primary template.  (For example, in:\n+      my_friendly_assert (IS_AGGR_TYPE (type) \n+\t\t\t  || TREE_CODE (type) == ENUMERAL_TYPE, 0);\n+\t\t\t  \n+\t\t\t  \n+      if (/* If !GLOBALIZE then we are looking at a definition.\n+\t     It may not be a primary template.  (For example, in:\n \t\t  \n-\t\t template <class T>\n-\t\t struct S1 { class S2 {}; }\n+\t       template <class T>\n+\t       struct S1 { class S2 {}; }\n \t\t  \n-\t\t we have to push_template_decl for S2.)  */\n-\t      (processing_template_decl && !globalize)\n-\t      /* If we are declaring a friend template class, we will\n-\t\t have GLOBALIZE set, since something like:\n+\t     we have to push_template_decl for S2.)  */\n+\t  (processing_template_decl && !globalize)\n+\t  /* If we are declaring a friend template class, we will\n+\t     have GLOBALIZE set, since something like:\n \n-\t\t template <class T>\n-\t\t struct S1 {\n-\t\t   template <class U>\n-\t\t   friend class S2; \n-\t\t };\n+\t       template <class T>\n+\t       struct S1 {\n+\t\t template <class U>\n+\t\t friend class S2; \n+\t       };\n \n-\t\t declares S2 to be at global scope.  */\n-\t      || PROCESSING_REAL_TEMPLATE_DECL_P ()))\n+\t     declares S2 to be at global scope.  */\n+\t  || PROCESSING_REAL_TEMPLATE_DECL_P ())\n \t{\n \t  /* This may change after the call to\n \t     push_template_decl_real, but we want the original value.  */\n@@ -2286,7 +2289,8 @@ maybe_process_template_type_declaration (type, globalize, b)\n \t     declaration of the member class into the class scope.  In the\n \t     friend case, push_template_decl will already have put the\n \t     friend into global scope, if appropriate.  */\n-\t  if (!globalize && b->pseudo_global\n+\t  if (TREE_CODE (type) != ENUMERAL_TYPE\n+\t      && !globalize && b->pseudo_global\n \t      && b->level_chain->parm_flag == 2)\n \t    {\n \t      pushdecl_with_scope (CLASSTYPE_TI_TEMPLATE (type),\n@@ -11753,9 +11757,6 @@ start_enum (name)\n       pushtag (name, enumtype, 0);\n     }\n \n-  if (b->pseudo_global)\n-    cp_error (\"template declaration of `%#T'\", enumtype);\n-\n   if (current_class_type)\n     TREE_ADDRESSABLE (b->tags) = 1;\n \n@@ -11783,30 +11784,46 @@ finish_enum (enumtype, values)\n \n   if (values)\n     {\n-      register tree pair;\n-      register tree value = DECL_INITIAL (TREE_VALUE (values));\n+      tree pair;\n \n-      if (! processing_template_decl)\n-\t{\n-\t  /* Speed up the main loop by performing some precalculations */\n-\t  TREE_TYPE (TREE_VALUE (values)) = enumtype;\n-\t  TREE_TYPE (value) = enumtype;\n-\t  minnode = maxnode = value;\n-\t}\n-      TREE_VALUE (values) = value;\n-      \n-      for (pair = TREE_CHAIN (values); pair; pair = TREE_CHAIN (pair))\n+      for (pair = values; pair; pair = TREE_CHAIN (pair))\n \t{\n-\t  value = DECL_INITIAL (TREE_VALUE (pair));\n-\t  if (! processing_template_decl)\n-\t    {\n-\t      TREE_TYPE (TREE_VALUE (pair)) = enumtype;\n+\t  tree decl;\n+\t  tree value;\n+\n+\t  /* The TREE_VALUE is a CONST_DECL for this enumeration\n+\t     constant.  */\n+\t  decl = TREE_VALUE (pair);\n+\n+\t  /* The type of the CONST_DECL is the type of the enumeration,\n+\t     not an INTEGER_TYPE.  */\n+\t  TREE_TYPE (decl) = enumtype;\n+\n+\t  /* The DECL_INITIAL will be NULL if we are processing a\n+\t     template declaration and this enumeration constant had no\n+\t     explicit initializer.  */\n+\t  value = DECL_INITIAL (decl);\n+\t  if (value)\n+\t    {\n+\t      /* Set the TREE_TYPE for the VALUE as well.  When\n+\t\t processing a template, however, we might have a\n+\t\t TEMPLATE_PARM_INDEX, and we should not change the\n+\t\t type of such a thing.  */\n+\t      if (TREE_CODE (value) == TEMPLATE_PARM_INDEX)\n+\t\tDECL_INITIAL (decl) = value \n+\t\t  = build1 (NOP_EXPR, enumtype, value);\n \t      TREE_TYPE (value) = enumtype;\n-\t      if (tree_int_cst_lt (maxnode, value))\n+\n+\t      if (!minnode)\n+\t\tminnode = maxnode = value;\n+\t      else if (tree_int_cst_lt (maxnode, value))\n \t\tmaxnode = value;\n \t      else if (tree_int_cst_lt (value, minnode))\n \t\tminnode = value;\n \t    }\n+\n+\t  /* In the list we're building up, we want the enumeration\n+\t     values, not the CONST_DECLs.  */\n \t  TREE_VALUE (pair) = value;\n \t}\n     }\n@@ -11922,16 +11939,17 @@ build_enumerator (name, value)\n      /* Remove no-op casts from the value.  */\n      if (value)\n        STRIP_TYPE_NOPS (value);\n-\n-     /* We have to always copy here; not all INTEGER_CSTs are unshared,\n-\tand there's no wedding ring. Look at size_int()...*/\n-     value = copy_node (value);\n #if 0\n      /* To fix MAX_VAL enum consts. (bkoz)  */\n      TREE_TYPE (value) = integer_type_node;\n #endif\n    }\n \n+ /* We have to always copy here; not all INTEGER_CSTs are unshared,\n+    and there's no wedding ring. Look at size_int()...*/\n+ if (value != NULL_TREE)\n+   value = copy_node (value);\n+\n   /* C++ associates enums with global, function, or class declarations.  */\n \n   decl = current_scope ();\n@@ -11970,6 +11988,23 @@ build_enumerator (name, value)\n   return result;\n }\n \n+/* Called after we have finished the declaration of an enumeration\n+   type, and, perhaps, some objects whose type involves the\n+   enumeration type.  DECL, if non-NULL, is the declaration of the\n+   first such object.  \n+\n+   If CURRENT_LOCAL_ENUM is NULL, the DECL is returned. \n+\n+   If CURRENT_LOCAL_ENUM is non-NULL, it should be the CONST_DECL for\n+   the last enumeration constant of an enumeration type that is a\n+   member of a class.  The enumeration constants are already chained\n+   together through their TREE_CHAIN fields.  This function sets the\n+   TREE_CHAIN of the last enumeration constant to DECL.  The\n+   CONST_DECL for the last enumeration constant is returned.  \n+\n+   CURRENT_LOCAL_ENUM will always be NULL when this function \n+   returns.  */\n+\n tree\n grok_enum_decls (decl)\n      tree decl;"}, {"sha": "3271965939027045c1134adbfe4dba56bce0edc8", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed44da020e182d3eee3610fe8e5eacb9518f9848/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed44da020e182d3eee3610fe8e5eacb9518f9848/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=ed44da020e182d3eee3610fe8e5eacb9518f9848", "patch": "@@ -2988,9 +2988,26 @@ do_identifier (token, parsing, args)\n   else\n     id = hack_identifier (id, token);\n \n+  /* We must look up dependent names when the template is\n+     instantiated, not while parsing it.  For now, we don't\n+     distinguish between dependent and independent names.  So, for\n+     example, we look up all overloaded functions at\n+     instantiation-time, even though in some cases we should just use\n+     the DECL we have here.  We also use LOOKUP_EXPRs to find things\n+     like local variables, rather than created TEMPLATE_DECLs for the\n+     local variables and then finding matching instantiations.  */\n   if (current_template_parms\n       && (is_overloaded_fn (id) \n+\t  /* If it's not going to be around at instantiation time, we\n+\t     look it up then.  This is a hack, and should go when we\n+\t     really get dependent/independent name lookup right.  */\n \t  || !TREE_PERMANENT (id)\n+\t  /* Some local VAR_DECLs (such as those for local variables\n+\t     in member functions of local classes) are built on the\n+\t     permanent obstack.  */\n+\t  || (TREE_CODE (id) == VAR_DECL \n+\t      && CP_DECL_CONTEXT (id)\n+\t      && TREE_CODE (CP_DECL_CONTEXT (id)) == FUNCTION_DECL)\n \t  || TREE_CODE (id) == PARM_DECL\n \t  || TREE_CODE (id) == USING_DECL))\n     id = build_min_nt (LOOKUP_EXPR, token);"}, {"sha": "3071f1e37153b2973311f7e9f7590a337cc2b063", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 186, "deletions": 115, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed44da020e182d3eee3610fe8e5eacb9518f9848/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed44da020e182d3eee3610fe8e5eacb9518f9848/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ed44da020e182d3eee3610fe8e5eacb9518f9848", "patch": "@@ -85,7 +85,7 @@ static tree tsubst_expr_values PROTO((tree, tree));\n static int list_eq PROTO((tree, tree));\n static tree get_class_bindings PROTO((tree, tree, tree));\n static tree coerce_template_parms PROTO((tree, tree, tree, int, int));\n-static tree tsubst_enum\tPROTO((tree, tree, tree *));\n+static tree tsubst_enum\tPROTO((tree, tree));\n static tree add_to_template_args PROTO((tree, tree));\n static tree add_outermost_template_args PROTO((tree, tree));\n static void maybe_adjust_types_for_deduction PROTO((unification_kind_t, tree*,\n@@ -254,15 +254,29 @@ template_class_depth_real (type, count_specializations)\n   int depth;\n \n   for (depth = 0; \n-       type && TREE_CODE (type) != FUNCTION_DECL \n-\t && TREE_CODE (type) != NAMESPACE_DECL;\n-       type = TYPE_CONTEXT (type))\n-    if (CLASSTYPE_TEMPLATE_INFO (type)\n-\t&& PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (type))\n-\t&& ((count_specializations\n-\t     && CLASSTYPE_TEMPLATE_SPECIALIZATION (type))\n-\t    || uses_template_parms (CLASSTYPE_TI_ARGS (type))))\n-      ++depth;\n+       type && TREE_CODE (type) != NAMESPACE_DECL;\n+       type = (TREE_CODE (type) == FUNCTION_DECL) \n+\t ? DECL_REAL_CONTEXT (type) : TYPE_CONTEXT (type))\n+    {\n+      if (TREE_CODE (type) != FUNCTION_DECL)\n+\t{\n+\t  if (CLASSTYPE_TEMPLATE_INFO (type)\n+\t      && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (type))\n+\t      && ((count_specializations\n+\t\t   && CLASSTYPE_TEMPLATE_SPECIALIZATION (type))\n+\t\t  || uses_template_parms (CLASSTYPE_TI_ARGS (type))))\n+\t    ++depth;\n+\t}\n+      else \n+\t{\n+\t  if (DECL_TEMPLATE_INFO (type)\n+\t      && PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (type))\n+\t      && ((count_specializations\n+\t\t   && DECL_TEMPLATE_SPECIALIZATION (type))\n+\t\t  || uses_template_parms (DECL_TI_ARGS (type))))\n+\t    ++depth;\n+\t}\n+    }\n \n   return depth;\n }\n@@ -1802,10 +1816,14 @@ push_template_decl_real (decl, is_friend)\n \tcp_error (\"template with C linkage\");\n       if (TREE_CODE (decl) == TYPE_DECL && ANON_AGGRNAME_P (DECL_NAME (decl)))\n \tcp_error (\"template class without a name\");\n+      if (TREE_CODE (decl) == TYPE_DECL \n+\t  && TREE_CODE (TREE_TYPE (decl)) == ENUMERAL_TYPE)\n+\tcp_error (\"template declaration of `%#T'\", TREE_TYPE (decl));\n     }\n \n   /* Partial specialization.  */\n   if (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl)\n+      && TREE_CODE (TREE_TYPE (decl)) != ENUMERAL_TYPE\n       && CLASSTYPE_TEMPLATE_SPECIALIZATION (TREE_TYPE (decl)))\n     {\n       tree type = TREE_TYPE (decl);\n@@ -1930,10 +1948,11 @@ push_template_decl_real (decl, is_friend)\n \t\t  ctx, decl);\n       if (TREE_CODE (decl) == TYPE_DECL)\n \t{\n-\t  if (IS_AGGR_TYPE_CODE (TREE_CODE (TREE_TYPE (decl)))\n-\t      && CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (decl))\n-\t      && CLASSTYPE_TI_TEMPLATE (TREE_TYPE (decl)))\n-\t    tmpl = CLASSTYPE_TI_TEMPLATE (TREE_TYPE (decl));\n+\t  if ((IS_AGGR_TYPE_CODE (TREE_CODE (TREE_TYPE (decl)))\n+\t       || TREE_CODE (TREE_TYPE (decl)) == ENUMERAL_TYPE)\n+\t      && TYPE_TEMPLATE_INFO (TREE_TYPE (decl))\n+\t      && TYPE_TI_TEMPLATE (TREE_TYPE (decl)))\n+\t    tmpl = TYPE_TI_TEMPLATE (TREE_TYPE (decl));\n \t  else\n \t    {\n \t      cp_error (\"`%D' does not declare a template type\", decl);\n@@ -2037,8 +2056,9 @@ push_template_decl_real (decl, is_friend)\n \n   if (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl))\n     {\n-      CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (tmpl)) = info;\n-      if (!ctx || TREE_CODE (ctx) != FUNCTION_DECL)\n+      SET_TYPE_TEMPLATE_INFO (TREE_TYPE (tmpl), info);\n+      if ((!ctx || TREE_CODE (ctx) != FUNCTION_DECL)\n+\t  && TREE_CODE (TREE_TYPE (decl)) != ENUMERAL_TYPE)\n \tDECL_NAME (decl) = classtype_mangled_name (TREE_TYPE (decl));\n     }\n   else if (! DECL_LANG_SPECIFIC (decl))\n@@ -3124,9 +3144,11 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n       template = CLASSTYPE_TI_TEMPLATE (TREE_TYPE (d1));\n       d1 = DECL_NAME (template);\n     }\n-  else if (TREE_CODE_CLASS (TREE_CODE (d1)) == 't' && IS_AGGR_TYPE (d1))\n+  else if (TREE_CODE (d1) == ENUMERAL_TYPE \n+\t   || (TREE_CODE_CLASS (TREE_CODE (d1)) == 't' \n+\t       && IS_AGGR_TYPE (d1)))\n     {\n-      template = CLASSTYPE_TI_TEMPLATE (d1);\n+      template = TYPE_TI_TEMPLATE (d1);\n       d1 = DECL_NAME (template);\n     }\n   else if (TREE_CODE (d1) == TEMPLATE_DECL\n@@ -3229,7 +3251,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t      return error_mark_node;\n \t    }\n \n-\t  arglist = add_to_template_args (CLASSTYPE_TI_ARGS (context),\n+\t  arglist = add_to_template_args (TYPE_TI_ARGS (context),\n \t\t\t\t\t  arglist);\n \t  arg_depth = TMPL_ARGS_DEPTH (arglist);\n \t}\n@@ -3286,7 +3308,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \n \t the `C<T>' is just the same as `C'.  Outside of the\n \t class, however, such a reference is an instantiation.  */\n-      if (comp_template_args (CLASSTYPE_TI_ARGS (template_type),\n+      if (comp_template_args (TYPE_TI_ARGS (template_type),\n \t\t\t      arglist))\n \t{\n \t  found = template_type;\n@@ -3338,45 +3360,67 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n       push_obstacks (&permanent_obstack, &permanent_obstack);\n       \n       /* Create the type.  */\n-      t = make_lang_type (TREE_CODE (template_type));\n-      CLASSTYPE_DECLARED_CLASS (t) \n-\t= CLASSTYPE_DECLARED_CLASS (template_type);\n-      TYPE_CONTEXT (t) = FROB_CONTEXT (context);\n+      if (TREE_CODE (template_type) == ENUMERAL_TYPE)\n+\t{\n+\t  if (!uses_template_parms (arglist))\n+\t    t = tsubst_enum (template_type, arglist);\n+\t  else\n+\t    /* We don't want to call tsubst_enum for this type, since\n+\t       the values for the enumeration constants may involve\n+\t       template parameters.  And, no one should be interested\n+\t       in the enumeration constants for such a type.  */\n+\t    t = make_node (ENUMERAL_TYPE);\n+\t}\n+      else\n+\t{\n+\t  t = make_lang_type (TREE_CODE (template_type));\n+\t  CLASSTYPE_DECLARED_CLASS (t) \n+\t    = CLASSTYPE_DECLARED_CLASS (template_type);\n+\t  CLASSTYPE_GOT_SEMICOLON (t) = 1;\n+\t  SET_CLASSTYPE_IMPLICIT_INSTANTIATION (t);\n+\t}\n+\n+      /* If we called tsubst_enum above, this information will already\n+\t be set up.  */\n+      if (!TYPE_NAME (t))\n+\t{\n+\t  TYPE_CONTEXT (t) = FROB_CONTEXT (context);\n \t  \n-      /* Create a stub TYPE_DECL for it.  */\n-      type_decl = build_decl (TYPE_DECL, DECL_NAME (template), t);\n-      SET_DECL_ARTIFICIAL (type_decl);\n-      DECL_CONTEXT (type_decl) = TYPE_CONTEXT (t);\n-      DECL_SOURCE_FILE (type_decl) \n-\t= DECL_SOURCE_FILE (TYPE_STUB_DECL (template_type));\n-      DECL_SOURCE_LINE (type_decl) \n-\t= DECL_SOURCE_LINE (TYPE_STUB_DECL (template_type));\n-      TYPE_STUB_DECL (t) = TYPE_NAME (t) = type_decl;\n+\t  /* Create a stub TYPE_DECL for it.  */\n+\t  type_decl = build_decl (TYPE_DECL, DECL_NAME (template), t);\n+\t  SET_DECL_ARTIFICIAL (type_decl);\n+\t  DECL_CONTEXT (type_decl) = TYPE_CONTEXT (t);\n+\t  DECL_SOURCE_FILE (type_decl) \n+\t    = DECL_SOURCE_FILE (TYPE_STUB_DECL (template_type));\n+\t  DECL_SOURCE_LINE (type_decl) \n+\t    = DECL_SOURCE_LINE (TYPE_STUB_DECL (template_type));\n+\t  TYPE_STUB_DECL (t) = TYPE_NAME (t) = type_decl;\n+\t}\n+      else\n+\ttype_decl = TYPE_NAME (t);\n \n       /* We're done with the permanent obstack, now.  */\n       pop_obstacks ();\n \n-      /* Seems to be wanted.  */\n-      CLASSTYPE_GOT_SEMICOLON (t) = 1;\n-\n       /* Set up the template information.  */\n       arglist = copy_to_permanent (arglist);\n-      CLASSTYPE_TEMPLATE_INFO (t)\n-\t= perm_tree_cons (template, arglist, NULL_TREE);\n+      SET_TYPE_TEMPLATE_INFO (t,\n+\t\t\t      perm_tree_cons (template, arglist, NULL_TREE));\n       DECL_TEMPLATE_INSTANTIATIONS (template) = perm_tree_cons\n \t(arglist, t, DECL_TEMPLATE_INSTANTIATIONS (template));\n-      SET_CLASSTYPE_IMPLICIT_INSTANTIATION (t);\n \n       /* Reset the name of the type, now that CLASSTYPE_TEMPLATE_INFO\n \t is set up.  */\n-      DECL_NAME (type_decl) = classtype_mangled_name (t);\n+      if (TREE_CODE (t) != ENUMERAL_TYPE)\n+\tDECL_NAME (type_decl) = classtype_mangled_name (t);\n       DECL_ASSEMBLER_NAME (type_decl) = DECL_NAME (type_decl);\n       if (! uses_template_parms (arglist))\n \t{\n \t  DECL_ASSEMBLER_NAME (type_decl)\n \t    = get_identifier (build_overload_name (t, 1, 1));\n \t  \n-\t  if (flag_external_templates\n+\t  if (TREE_CODE (t) != ENUMERAL_TYPE\n+\t      && flag_external_templates\n \t      && CLASSTYPE_INTERFACE_KNOWN (TREE_TYPE (template))\n \t      && ! CLASSTYPE_INTERFACE_ONLY (TREE_TYPE (template)))\n \t    add_pending_template (t);\n@@ -3449,15 +3493,19 @@ for_each_template_parm (t, fn, data)\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n       return for_each_template_parm (TREE_TYPE (t), fn, data);\n+\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_FLAG (t))\n \treturn for_each_template_parm (TYPE_PTRMEMFUNC_FN_TYPE (t),\n \t\t\t\t       fn, data);\n+      /* Fall through.  */\n+\n     case UNION_TYPE:\n-      if (! CLASSTYPE_TEMPLATE_INFO (t))\n+    case ENUMERAL_TYPE:\n+      if (! TYPE_TEMPLATE_INFO (t))\n \treturn 0;\n       return for_each_template_parm (TREE_VALUE\n-\t\t\t\t     (CLASSTYPE_TEMPLATE_INFO (t)),\n+\t\t\t\t     (TYPE_TEMPLATE_INFO (t)),\n \t\t\t\t     fn, data);\n     case FUNCTION_TYPE:\n       if (for_each_template_parm (TYPE_ARG_TYPES (t), fn, data))\n@@ -3541,16 +3589,6 @@ for_each_template_parm (t, fn, data)\n     case NAMESPACE_DECL:\n       return 0;\n \n-    case ENUMERAL_TYPE:\n-      {\n-\ttree v;\n-\n-\tfor (v = TYPE_VALUES (t); v != NULL_TREE; v = TREE_CHAIN (v))\n-\t  if (for_each_template_parm (TREE_VALUE (v), fn, data))\n-\t    return 1;\n-      }\n-      return 0;\n-\n       /* constants */\n     case INTEGER_CST:\n     case REAL_CST:\n@@ -4207,24 +4245,46 @@ instantiate_class_template (type)\n       tree name = TYPE_IDENTIFIER (tag);\n       tree newtag;\n \n-      if (TREE_CODE (tag) == ENUMERAL_TYPE)\n+      newtag = tsubst (tag, args, NULL_TREE);\n+      if (TREE_CODE (newtag) == ENUMERAL_TYPE)\n \t{\n-\t  newtag = tsubst_enum (tag, args, field_chain);\n-\t  while (*field_chain)\n+\t  extern tree current_local_enum;\n+\t  tree prev_local_enum = current_local_enum;\n+\n+\t  if (TYPE_VALUES (newtag))\n \t    {\n-\t      DECL_FIELD_CONTEXT (*field_chain) = type;\n-\t      field_chain = &TREE_CHAIN (*field_chain);\n+\t      tree v;\n+\n+\t      /* We must set things up so that CURRENT_LOCAL_ENUM is the\n+\t\t CONST_DECL for the last enumeration constant, since the\n+\t\t CONST_DECLs are chained backwards.  */\n+\t      for (v = TYPE_VALUES (newtag); TREE_CHAIN (v); \n+\t\t   v = TREE_CHAIN (v))\n+\t\t;\n+\n+\t      current_local_enum \n+\t\t= IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (v));\n+\t      *field_chain = grok_enum_decls (NULL_TREE);\n+\t      current_local_enum = prev_local_enum;\n+\n+\t      while (*field_chain)\n+\t\t{\n+\t\t  DECL_FIELD_CONTEXT (*field_chain) = type;\n+\t\t  field_chain = &TREE_CHAIN (*field_chain);\n+\t\t}\n \t    }\n \t}\n       else\n-\tnewtag = tsubst (tag, args, NULL_TREE);\n-\n-      /* Now, we call pushtag to put this NEWTAG into the scope of\n-\t TYPE.  We first set up the IDENTIFIER_TYPE_VALUE to avoid\n-\t pushtag calling push_template_decl.  */\n-      if (name)\n-\tSET_IDENTIFIER_TYPE_VALUE (name, newtag);\n-      pushtag (name, newtag, /*globalize=*/0);\n+\t{\n+\t  /* Now, we call pushtag to put this NEWTAG into the scope of\n+\t     TYPE.  We first set up the IDENTIFIER_TYPE_VALUE to avoid\n+\t     pushtag calling push_template_decl.  We don't have to do\n+\t     this for enums because it will already have been done in\n+\t     tsubst_enum.  */\n+\t  if (name)\n+\t    SET_IDENTIFIER_TYPE_VALUE (name, newtag);\n+\t  pushtag (name, newtag, /*globalize=*/0);\n+\t}\n     }\n \n   /* Don't replace enum constants here.  */\n@@ -4371,24 +4431,6 @@ list_eq (t1, t2)\n   return list_eq (TREE_CHAIN (t1), TREE_CHAIN (t2));\n }\n \n-tree \n-lookup_nested_type_by_name (ctype, name)\n-        tree ctype, name;\n-{\n-  tree t;\n-\n-  complete_type (ctype);\n-\n-  for (t = CLASSTYPE_TAGS (ctype); t; t = TREE_CHAIN (t))\n-    {\n-      if (name == TREE_PURPOSE (t)\n-\t  /* this catches typedef enum { foo } bar; */\n-\t  || name == TYPE_IDENTIFIER (TREE_VALUE (t)))\n-\treturn TREE_VALUE (t);\n-    }\n-  return NULL_TREE;\n-}\n-\n /* If arg is a non-type template parameter that does not depend on template\n    arguments, fold it like we weren't in the body of a template.  */\n \n@@ -4507,11 +4549,11 @@ tsubst_template_parms (parms, args)\n   return r;\n }\n \n-/* Substitute the ARGS into the indicated aggregate type T.  If T is\n-   not an aggregate type, it is handled as if by tsubst.  IN_DECL is\n-   as for tsubst.  If ENTERING_SCOPE is non-zero, T is the context for\n-   a template which we are presently tsubst'ing.  Return the\n-   subsituted value.  */\n+/* Substitute the ARGS into the indicated aggregate (or enumeration)\n+   type T.  If T is not an aggregate or enumeration type, it is\n+   handled as if by tsubst.  IN_DECL is as for tsubst.  If\n+   ENTERING_SCOPE is non-zero, T is the context for a template which\n+   we are presently tsubst'ing.  Return the subsituted value.  */\n \n tree\n tsubst_aggr_type (t, args, in_decl, entering_scope)\n@@ -4535,6 +4577,7 @@ tsubst_aggr_type (t, args, in_decl, entering_scope)\n \t}\n \n       /* else fall through */\n+    case ENUMERAL_TYPE:\n     case UNION_TYPE:\n       if (uses_template_parms (t))\n \t{\n@@ -4559,7 +4602,7 @@ tsubst_aggr_type (t, args, in_decl, entering_scope)\n \t     and supposing that we are instantiating f<int, double>,\n \t     then our ARGS will be {int, double}, but, when looking up\n \t     S we only want {double}.  */\n-\t  argvec = tsubst (CLASSTYPE_TI_ARGS (t), args, in_decl);\n+\t  argvec = tsubst (TYPE_TI_ARGS (t), args, in_decl);\n \n   \t  r = lookup_template_class (t, argvec, in_decl, context,\n \t\t\t\t     entering_scope);\n@@ -4614,6 +4657,7 @@ tsubst (t, args, in_decl)\n     {\n     case RECORD_TYPE:\n     case UNION_TYPE:\n+    case ENUMERAL_TYPE:\n       return tsubst_aggr_type (t, args, in_decl, /*entering_scope=*/0);\n \n     case ERROR_MARK:\n@@ -4629,18 +4673,6 @@ tsubst (t, args, in_decl)\n     case NAMESPACE_DECL:\n       return t;\n \n-    case ENUMERAL_TYPE:\n-      {\n-\ttree ctx = tsubst_aggr_type (TYPE_CONTEXT (t), args, in_decl,\n-\t\t\t\t     /*entering_scope=*/1);\n-\tif (ctx == NULL_TREE || TREE_CODE (ctx) == NAMESPACE_DECL)\n-\t  return t;\n-\telse if (ctx == current_function_decl)\n-\t  return lookup_name (TYPE_IDENTIFIER (t), 1);\n-\telse\n-\t  return lookup_nested_type_by_name (ctx, TYPE_IDENTIFIER (t));\n-      }\n-\n     case INTEGER_TYPE:\n       if (t == integer_type_node)\n \treturn t;\n@@ -5496,12 +5528,45 @@ tsubst_copy (t, args, in_decl)\n       return do_identifier (DECL_NAME (t), 0, NULL_TREE);\n \n     case CONST_DECL:\n+      {\n+\ttree enum_type;\n+\ttree v;\n+\n+\tif (!DECL_CONTEXT (t))\n+\t  /* This is a global enumeration constant.  */\n+\t  return t;\n+\n+\t/* Unfortunately, we cannot just call lookup_name here.\n+\t Consider:\n+\n+\t template <int I> int f() {\n+\t   enum E { a = I };\n+\t   struct S { void g() { E e = a; } };\n+\t };\n+\n+\t When we instantiate f<7>::S::g(), say, lookup_name is not\n+\t clever enough to find f<7>::a.  */\n+\tenum_type \n+\t  = tsubst_aggr_type (TREE_TYPE (t), args, in_decl, \n+\t\t\t      /*entering_scope=*/0);\n+\n+\tfor (v = TYPE_VALUES (enum_type); \n+\t     v != NULL_TREE; \n+\t     v = TREE_CHAIN (v))\n+\t  if (TREE_PURPOSE (v) == DECL_NAME (t))\n+\t    return TREE_VALUE (v);\n+\n+\t  /* We didn't find the name.  That should never happen; if\n+\t     name-lookup found it during preliminary parsing, we\n+\t     should find it again here during instantiation.  */\n+\tmy_friendly_abort (0);\n+      }\n+      break;\n+\n     case FIELD_DECL:\n       if (DECL_CONTEXT (t))\n \t{\n \t  tree ctx;\n-\t  if (TREE_CODE (DECL_CONTEXT (t)) == FUNCTION_DECL)\n-\t    return lookup_name (DECL_NAME (t), 0);\n \n \t  ctx = tsubst_aggr_type (DECL_CONTEXT (t), args, in_decl,\n \t\t\t\t  /*entering_scope=*/1);\n@@ -5984,7 +6049,7 @@ tsubst_expr (t, args, in_decl)\n       lineno = TREE_COMPLEXITY (t);\n       t = TREE_TYPE (t);\n       if (TREE_CODE (t) == ENUMERAL_TYPE)\n-\ttsubst_enum (t, args, NULL);\n+\ttsubst (t, args, NULL_TREE);\n       break;\n \n     default:\n@@ -7823,13 +7888,11 @@ add_maybe_template (d, fns)\n   DECL_MAYBE_TEMPLATE (d) = 1;\n }\n \n-/* Instantiate an enumerated type.  Used by instantiate_class_template and\n-   tsubst_expr.  */\n+/* Instantiate an enumerated type.  */\n \n static tree\n-tsubst_enum (tag, args, field_chain)\n+tsubst_enum (tag, args)\n      tree tag, args;\n-     tree * field_chain;\n {\n   extern tree current_local_enum;\n   tree prev_local_enum = current_local_enum;\n@@ -7839,18 +7902,26 @@ tsubst_enum (tag, args, field_chain)\n \n   for (e = TYPE_VALUES (tag); e; e = TREE_CHAIN (e))\n     {\n-      tree elt = build_enumerator (TREE_PURPOSE (e),\n-\t\t\t\t   tsubst_expr (TREE_VALUE (e), args,\n-\t\t\t\t\t\tNULL_TREE));\n+      tree value;\n+      tree elt;\n+\n+      value = TREE_VALUE (e);\n+      if (value)\n+\t{\n+\t  if (TREE_CODE (value) == NOP_EXPR)\n+\t    /* This is the special case where the value is really a\n+\t   TEMPLATE_PARM_INDEX.  See finish_enum.  */\n+\t    value = TREE_OPERAND (value, 0);\n+\t  value = tsubst_expr (value, args, NULL_TREE);\n+\t}\n+\n+      elt = build_enumerator (TREE_PURPOSE (e), value);\n       TREE_CHAIN (elt) = values;\n       values = elt;\n     }\n \n   finish_enum (newtag, values);\n \n-  if (NULL != field_chain)\n-    *field_chain = grok_enum_decls (NULL_TREE);\n-\n   current_local_enum = prev_local_enum;\n \n   return newtag;"}, {"sha": "2da6dd9bbbff1244fb029ecfd0843d50a25844f4", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash19.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed44da020e182d3eee3610fe8e5eacb9518f9848/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed44da020e182d3eee3610fe8e5eacb9518f9848/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash19.C?ref=ed44da020e182d3eee3610fe8e5eacb9518f9848", "patch": "@@ -0,0 +1,19 @@\n+// Build don't link:\n+\n+template <int I>\n+void f()\n+{\n+  class C { public: int c; };\n+\n+  struct S {\n+    void g() {\n+      C e;\n+      e.c = 3;\n+    };\n+  };\n+\n+  S s;\n+  s.g();\n+}\n+\n+template void f<7>();"}, {"sha": "acfd681ec92a06f1cad400464829a7f2ead84515", "filename": "gcc/testsuite/g++.old-deja/g++.pt/enum6.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed44da020e182d3eee3610fe8e5eacb9518f9848/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fenum6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed44da020e182d3eee3610fe8e5eacb9518f9848/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fenum6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fenum6.C?ref=ed44da020e182d3eee3610fe8e5eacb9518f9848", "patch": "@@ -0,0 +1,14 @@\n+// Build don't link:\n+\n+template <class T>\n+struct vector {};\n+\n+template<class T>\n+void fn(T)\n+{\n+  enum tern { H, L, X, U };\n+\n+  vector<tern> ternvec; // ERROR - composed from a local type\n+}\n+\n+template void fn(int);"}, {"sha": "47dcbfa6761311de6e2cc7a6eea93dec0ebff289", "filename": "gcc/testsuite/g++.old-deja/g++.pt/enum7.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed44da020e182d3eee3610fe8e5eacb9518f9848/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fenum7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed44da020e182d3eee3610fe8e5eacb9518f9848/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fenum7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fenum7.C?ref=ed44da020e182d3eee3610fe8e5eacb9518f9848", "patch": "@@ -0,0 +1,27 @@\n+template <int I>\n+int f()\n+{\n+  enum E { a = I };\n+\n+  struct S {\n+    int g() {\n+      E e;\n+      e = a;\n+      return (int) e;\n+    };\n+  };\n+\n+  S s;\n+\n+  return s.g();\n+}\n+\n+\n+int main()\n+{\n+  if (f<7>() != 7)\n+    return 1;\n+  if (f<-3>() != -3)\n+    return 1;\n+  return 0;\n+}"}]}