{"sha": "4caa6bab76241bc16517bf1d1075c986d0d0b8ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNhYTZiYWI3NjI0MWJjMTY1MTdiZjFkMTA3NWM5ODZkMGQwYjhhZA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.ibm.com", "date": "2019-07-24T11:27:56Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2019-07-24T11:27:56Z"}, "message": "S/390: Add add/sub/mul overflow check patterns\n\nThis patch implements the addv, subv, and mulv patterns for signed\nintegers.\n\ngcc/ChangeLog:\n\n2019-07-24  Andreas Krebbel  <krebbel@linux.ibm.com>\n\n\t* config/s390/predicates.md (addv_const_operand): New predicate.\n\t* config/s390/s390-modes.def (CCO): New condition code mode.\n\t* config/s390/s390.c (s390_match_ccmode_set): Handle E_CCOmode.\n\t(s390_branch_condition_mask): Likewise.\n\t* config/s390/s390.md (\"addv<mode>4\", \"subv<mode>4\")\n\t(\"mulv<mode>4\"): New expanders.\n\t(\"*addv<mode>3_ccoverflow\", \"*addv<mode>3_ccoverflow_const\")\n\t(\"*subv<mode>3_ccoverflow\", \"*mulv<mode>3_ccoverflow\"): New\n\tpattern definitions.\n\ngcc/testsuite/ChangeLog:\n\n2019-07-24  Andreas Krebbel  <krebbel@linux.ibm.com>\n\n\t* gcc.target/s390/addsub-signed-overflow-1.c: New test.\n\t* gcc.target/s390/addsub-signed-overflow-2.c: New test.\n\t* gcc.target/s390/mul-signed-overflow-1.c: New test.\n\t* gcc.target/s390/mul-signed-overflow-2.c: New test.\n\nFrom-SVN: r273759", "tree": {"sha": "c2585c57177403ab03fea7af0e95aefb6d6172b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2585c57177403ab03fea7af0e95aefb6d6172b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4caa6bab76241bc16517bf1d1075c986d0d0b8ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4caa6bab76241bc16517bf1d1075c986d0d0b8ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4caa6bab76241bc16517bf1d1075c986d0d0b8ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4caa6bab76241bc16517bf1d1075c986d0d0b8ad/comments", "author": {"login": "Andreas-Krebbel", "id": 38103320, "node_id": "MDQ6VXNlcjM4MTAzMzIw", "avatar_url": "https://avatars.githubusercontent.com/u/38103320?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Andreas-Krebbel", "html_url": "https://github.com/Andreas-Krebbel", "followers_url": "https://api.github.com/users/Andreas-Krebbel/followers", "following_url": "https://api.github.com/users/Andreas-Krebbel/following{/other_user}", "gists_url": "https://api.github.com/users/Andreas-Krebbel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Andreas-Krebbel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Andreas-Krebbel/subscriptions", "organizations_url": "https://api.github.com/users/Andreas-Krebbel/orgs", "repos_url": "https://api.github.com/users/Andreas-Krebbel/repos", "events_url": "https://api.github.com/users/Andreas-Krebbel/events{/privacy}", "received_events_url": "https://api.github.com/users/Andreas-Krebbel/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "21caa1a2649d586f4f8830aba43b0c132584f2dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21caa1a2649d586f4f8830aba43b0c132584f2dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21caa1a2649d586f4f8830aba43b0c132584f2dd"}], "stats": {"total": 466, "additions": 466, "deletions": 0}, "files": [{"sha": "c463383779974d2382148e7d3c51e149d0698631", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4caa6bab76241bc16517bf1d1075c986d0d0b8ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4caa6bab76241bc16517bf1d1075c986d0d0b8ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4caa6bab76241bc16517bf1d1075c986d0d0b8ad", "patch": "@@ -1,3 +1,15 @@\n+2019-07-24  Andreas Krebbel  <krebbel@linux.ibm.com>\n+\n+\t* config/s390/predicates.md (addv_const_operand): New predicate.\n+\t* config/s390/s390-modes.def (CCO): New condition code mode.\n+\t* config/s390/s390.c (s390_match_ccmode_set): Handle E_CCOmode.\n+\t(s390_branch_condition_mask): Likewise.\n+\t* config/s390/s390.md (\"addv<mode>4\", \"subv<mode>4\")\n+\t(\"mulv<mode>4\"): New expanders.\n+\t(\"*addv<mode>3_ccoverflow\", \"*addv<mode>3_ccoverflow_const\")\n+\t(\"*subv<mode>3_ccoverflow\", \"*mulv<mode>3_ccoverflow\"): New\n+\tpattern definitions.\n+\n 2019-07-24  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n \n \tPR middle-end/91166"}, {"sha": "fa15c05bcad495402279f3b1cca6852674714755", "filename": "gcc/config/s390/predicates.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4caa6bab76241bc16517bf1d1075c986d0d0b8ad/gcc%2Fconfig%2Fs390%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4caa6bab76241bc16517bf1d1075c986d0d0b8ad/gcc%2Fconfig%2Fs390%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fpredicates.md?ref=4caa6bab76241bc16517bf1d1075c986d0d0b8ad", "patch": "@@ -585,3 +585,9 @@\n   return s390_valid_shift_count (op, 0);\n }\n )\n+\n+; An integer constant which can be used in a signed add with overflow\n+; pattern without being reloaded.\n+(define_predicate \"addv_const_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) >= -32768 && INTVAL (op) <= 32767\")))"}, {"sha": "7b7c1141449bcdd675b94b044bdf13fb1dc4e5a1", "filename": "gcc/config/s390/s390-modes.def", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4caa6bab76241bc16517bf1d1075c986d0d0b8ad/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4caa6bab76241bc16517bf1d1075c986d0d0b8ad/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-modes.def?ref=4caa6bab76241bc16517bf1d1075c986d0d0b8ad", "patch": "@@ -31,6 +31,8 @@ FLOAT_MODE (TF, 16, ieee_quad_format);\n \n Condition Codes\n \n+      CC0         CC1          CC2         CC3\n+\n Check for zero\n \n CCZ:  EQ          NE           NE          NE\n@@ -57,6 +59,10 @@ CCA:  EQ          LT           GT          Overflow\n CCAP: EQ          LT           GT          LT         (AGHI, AHI)\n CCAN: EQ          LT           GT          GT         (AGHI, AHI)\n \n+Condition codes for overflow checking resulting from signed adds/subs/mults\n+\n+CCO:  EQ          EQ           EQ          NE         (AGR, AGHI, SGR, MSC, ...)\n+\n Condition codes of unsigned adds and subs\n \n CCL:  EQ          NE           EQ          NE         (ALGF/R, ALG/R, AL/R/Y,\n@@ -98,6 +104,13 @@ If you know whether the used constant is positive or negative you can predict\n the sign of the result even in case of an overflow.\n \n \n+CCO\n+\n+This mode is used to check whether there was an overflow condition in\n+a signed add, sub, or mul operation.  See (addv<mode>4, subv<mode>4,\n+mulv<mode>4 patterns).\n+\n+\n CCT, CCT1, CCT2, CCT3\n \n If bits of an integer masked with an AND instruction are checked, the test under\n@@ -204,6 +217,7 @@ CC_MODE (CCZ1);\n CC_MODE (CCA);\n CC_MODE (CCAP);\n CC_MODE (CCAN);\n+CC_MODE (CCO);\n CC_MODE (CCL);\n CC_MODE (CCL1);\n CC_MODE (CCL2);"}, {"sha": "24b8a5c7a0df1c9a86258c48518112f71c225674", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4caa6bab76241bc16517bf1d1075c986d0d0b8ad/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4caa6bab76241bc16517bf1d1075c986d0d0b8ad/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=4caa6bab76241bc16517bf1d1075c986d0d0b8ad", "patch": "@@ -1378,6 +1378,7 @@ s390_match_ccmode_set (rtx set, machine_mode req_mode)\n     case E_CCSRmode:\n     case E_CCUmode:\n     case E_CCURmode:\n+    case E_CCOmode:\n     case E_CCLmode:\n     case E_CCL1mode:\n     case E_CCL2mode:\n@@ -2071,6 +2072,15 @@ s390_branch_condition_mask (rtx code)\n \t}\n       break;\n \n+    case E_CCOmode:\n+      switch (GET_CODE (code))\n+\t{\n+\tcase EQ:\treturn CC0 | CC1 | CC2;\n+\tcase NE:\treturn CC3;\n+\tdefault:\treturn -1;\n+\t}\n+      break;\n+\n     case E_CCSmode:\n       switch (GET_CODE (code))\n \t{"}, {"sha": "e4516f6c37849e72ba3e74489997c8208b686145", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4caa6bab76241bc16517bf1d1075c986d0d0b8ad/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4caa6bab76241bc16517bf1d1075c986d0d0b8ad/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=4caa6bab76241bc16517bf1d1075c986d0d0b8ad", "patch": "@@ -5961,6 +5961,83 @@\n   \"agh\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RXY\")])\n \n+\n+; Jump to label OP3 if OP1 + OP2 results in a signed overflow\n+\n+; addv_const_operand accepts all constants which can be handled\n+; without reloads.  These will be handled primarily by\n+; \"*addv<mode>3_ccoverflow_const\" which doesn't provide a register\n+; alternative.  Hence we have to match the operand exactly.\n+; For immediates we have to avoid the SIGN_EXTEND around OP2.\n+(define_expand \"addv<mode>4\"\n+  [(parallel\n+    [(set (reg:CCO CC_REGNUM)\n+\t  (compare:CCO (plus:<DBL>\n+\t\t\t(sign_extend:<DBL> (match_operand:GPR 1 \"nonimmediate_operand\"))\n+\t\t\t(match_dup 4))\n+\t\t       (sign_extend:<DBL> (plus:GPR (match_dup 1)\n+\t\t\t\t\t\t    (match_operand:GPR 2 \"general_operand\")))))\n+     (set (match_operand:GPR 0 \"nonimmediate_operand\")\n+\t  (plus:GPR (match_dup 1) (match_dup 2)))])\n+   (set (pc)\n+\t(if_then_else (ne (reg:CCO CC_REGNUM) (const_int 0))\n+\t\t      (label_ref (match_operand 3))\n+\t\t      (pc)))]\n+  \"\"\n+{\n+  if (CONSTANT_P (operands[2])\n+      && !addv_const_operand (operands[2], GET_MODE (operands[2])))\n+    operands[2] = force_reg (<GPR:MODE>mode, operands[2]);\n+\n+  if (GET_MODE (operands[2]) != VOIDmode)\n+    operands[4] = gen_rtx_SIGN_EXTEND (<DBL>mode, operands[2]);\n+  else\n+    /* This is what CSE does when propagating a constant into the pattern.  */\n+    operands[4] = simplify_unary_operation (SIGN_EXTEND, <GPR:DBL>mode, operands[2], <GPR:MODE>mode);\n+})\n+\n+; ark, agrk, ar, ahi, ahik, aghik, a, ay, agr, aghi, ag, asi, agsi\n+(define_insn \"*addv<mode>3_ccoverflow\"\n+  [(set (reg CC_REGNUM)\n+\t(compare (plus:<DBL>\n+\t\t  (sign_extend:<DBL> (match_operand:GPR 1 \"nonimmediate_operand\" \"%0,d,0,d,0,0,0\"))\n+\t\t  (sign_extend:<DBL> (match_operand:GPR 2 \"general_operand\"      \" d,d,K,K,R,T,C\")))\n+\t\t (sign_extend:<DBL> (plus:GPR (match_dup 1) (match_dup 2)))))\n+   (set (match_operand:GPR                              0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,S\")\n+        (plus:GPR (match_dup 1) (match_dup 2)))]\n+  \"s390_match_ccmode (insn, CCOmode)\"\n+  \"@\n+   a<g>r\\t%0,%2\n+   a<g>rk\\t%0,%1,%2\n+   a<g>hi\\t%0,%h2\n+   a<g>hik\\t%0,%1,%h2\n+   a<g>\\t%0,%2\n+   a<y>\\t%0,%2\n+   a<g>si\\t%0,%c2\"\n+  [(set_attr \"op_type\"  \"RR<E>,RRF,RI,RIE,RX<Y>,RXY,SIY\")\n+   (set_attr \"cpu_facility\" \"*,z196,*,z196,*,longdisp,z10\")\n+   (set_attr \"z10prop\" \"z10_super_E1,*,z10_super_E1,*,\n+                        z10_super_E1,z10_super_E1,z10_super_E1\")])\n+\n+; ahi, aghi, ahik, aghik, asi, agsi\n+(define_insn \"*addv<mode>3_ccoverflow_const\"\n+  [(set (reg CC_REGNUM)\n+\t(compare (plus:<DBL>\n+\t\t  (sign_extend:<DBL> (match_operand:GPR 1 \"nonimmediate_operand\" \"%0,d,0\"))\n+\t\t  (match_operand:<DBL>                  2 \"addv_const_operand\"    \"K,K,C\"))\n+\t\t (sign_extend:<DBL> (plus:GPR (match_dup 1) (match_dup 2)))))\n+   (set (match_operand:GPR                              0 \"nonimmediate_operand\" \"=d,d,S\")\n+        (plus:GPR (match_dup 1) (match_dup 2)))]\n+  \"s390_match_ccmode (insn, CCOmode)\"\n+  \"@\n+   a<g>hi\\t%0,%h2\n+   a<g>hik\\t%0,%1,%h2\n+   a<g>si\\t%0,%c2\"\n+  [(set_attr \"op_type\"  \"RI,RIE,SIY\")\n+   (set_attr \"cpu_facility\" \"*,z196,z10\")\n+   (set_attr \"z10prop\" \"z10_super_E1,*,z10_super_E1\")])\n+\n+\n ;\n ; add(tf|df|sf|td|dd)3 instruction pattern(s).\n ;\n@@ -6370,6 +6447,41 @@\n   \"sgh\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RXY\")])\n \n+; Jump to label OP3 if OP1 - OP2 results in a signed overflow\n+(define_expand \"subv<mode>4\"\n+  [(parallel\n+    [(set (reg:CCO CC_REGNUM)\n+\t  (compare:CCO (minus:<DBL>\n+\t\t\t(sign_extend:<DBL> (match_operand:GPR 1 \"nonimmediate_operand\"))\n+\t\t\t(sign_extend:<DBL> (match_operand:GPR 2 \"nonimmediate_operand\")))\n+\t\t       (sign_extend:<DBL> (minus:GPR (match_dup 1) (match_dup 2)))))\n+     (set (match_operand:GPR                                  0 \"nonimmediate_operand\")\n+          (minus:GPR (match_dup 1) (match_dup 2)))])\n+   (set (pc)\n+        (if_then_else (ne (reg:CCO CC_REGNUM) (const_int 0))\n+\t\t      (label_ref (match_operand 3))\n+                      (pc)))]\n+  \"\")\n+\n+; sr, s, sy, sgr, sg, srk, sgrk\n+(define_insn \"*subv<mode>3_ccoverflow\"\n+  [(set (reg CC_REGNUM)\n+\t(compare (minus:<DBL>\n+\t\t  (sign_extend:<DBL> (match_operand:GPR 1 \"nonimmediate_operand\" \"0,d,0,0\"))\n+\t\t  (sign_extend:<DBL> (match_operand:GPR 2 \"nonimmediate_operand\" \"d,d,R,T\")))\n+\t\t (sign_extend:<DBL> (minus:GPR (match_dup 1) (match_dup 2)))))\n+   (set (match_operand:GPR                              0 \"register_operand\"    \"=d,d,d,d\")\n+        (minus:GPR (match_dup 1) (match_dup 2)))]\n+  \"s390_match_ccmode (insn, CCOmode)\"\n+  \"@\n+   s<g>r\\t%0,%2\n+   s<g>rk\\t%0,%1,%2\n+   s<g>\\t%0,%2\n+   s<y>\\t%0,%2\"\n+  [(set_attr \"op_type\"  \"RR<E>,RRF,RX<Y>,RXY\")\n+   (set_attr \"cpu_facility\" \"*,z196,*,longdisp\")\n+   (set_attr \"z10prop\" \"z10_super_c_E1,*,z10_super_E1,z10_super_E1\")])\n+\n \n ;\n ; sub(tf|df|sf|td|dd)3 instruction pattern(s).\n@@ -6888,6 +7000,38 @@\n    (set_attr \"type\"         \"imulsi\")\n    (set_attr \"cpu_facility\" \"*,*,z10\")])\n \n+; Jump to label OP3 if OP1 * OP2 results in a signed overflow\n+(define_expand \"mulv<mode>4\"\n+  [(parallel\n+    [(set (reg:CCO CC_REGNUM)\n+\t  (compare:CCO (mult:<DBL>\n+\t\t\t (sign_extend:<DBL> (match_operand:GPR 1 \"register_operand\"))\n+\t\t\t (sign_extend:<DBL> (match_operand:GPR 2 \"nonimmediate_operand\")))\n+\t\t\t(sign_extend:<DBL> (mult:GPR (match_dup 1) (match_dup 2)))))\n+     (set (match_operand:GPR 0 \"register_operand\")\n+          (mult:GPR (match_dup 1) (match_dup 2)))])\n+   (set (pc)\n+        (if_then_else (ne (reg:CCO CC_REGNUM) (const_int 0))\n+\t\t      (label_ref (match_operand 3))\n+                      (pc)))]\n+  \"TARGET_Z14\")\n+\n+; msrkc, msc, msgrkc, msgc\n+(define_insn \"*mulv<mode>3_ccoverflow\"\n+  [(set (reg CC_REGNUM)\n+\t(compare (mult:<DBL>\n+\t\t  (sign_extend:<DBL> (match_operand:GPR 1 \"register_operand\"     \"%d,0\"))\n+\t\t  (sign_extend:<DBL> (match_operand:GPR 2 \"nonimmediate_operand\" \" d,T\")))\n+\t\t (sign_extend:<DBL> (mult:GPR (match_dup 1) (match_dup 2)))))\n+   (set (match_operand:GPR                              0 \"register_operand\"     \"=d,d\")\n+        (mult:GPR (match_dup 1) (match_dup 2)))]\n+  \"s390_match_ccmode (insn, CCOmode) && TARGET_Z14\"\n+  \"@\n+   ms<g>rkc\\t%0,%1,%2\n+   ms<g>c\\t%0,%2\"\n+  [(set_attr \"op_type\"  \"RRF,RXY\")])\n+\n+\n ;\n ; umul instruction pattern(s).\n ;"}, {"sha": "6da56e0dd86006c21f28376abafb621b5f346074", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4caa6bab76241bc16517bf1d1075c986d0d0b8ad/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4caa6bab76241bc16517bf1d1075c986d0d0b8ad/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4caa6bab76241bc16517bf1d1075c986d0d0b8ad", "patch": "@@ -1,3 +1,10 @@\n+2019-07-24  Andreas Krebbel  <krebbel@linux.ibm.com>\n+\n+\t* gcc.target/s390/addsub-signed-overflow-1.c: New test.\n+\t* gcc.target/s390/addsub-signed-overflow-2.c: New test.\n+\t* gcc.target/s390/mul-signed-overflow-1.c: New test.\n+\t* gcc.target/s390/mul-signed-overflow-2.c: New test.\n+\n 2019-07-24  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n \n \tPR middle-end/91166"}, {"sha": "367dbcb3774addb19ebdcb3db5e71b50d2850ecd", "filename": "gcc/testsuite/gcc.target/s390/addsub-signed-overflow-1.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4caa6bab76241bc16517bf1d1075c986d0d0b8ad/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Faddsub-signed-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4caa6bab76241bc16517bf1d1075c986d0d0b8ad/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Faddsub-signed-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Faddsub-signed-overflow-1.c?ref=4caa6bab76241bc16517bf1d1075c986d0d0b8ad", "patch": "@@ -0,0 +1,81 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mzarch --save-temps\" } */\n+\n+#include <stddef.h>\n+#include <limits.h>\n+\n+int __attribute__((noinline,noclone))\n+sadd (int a, int b, int *res)\n+{\n+   return __builtin_sadd_overflow(a, b, res);\n+}\n+\n+int __attribute__((noinline,noclone))\n+ssub (int a, int b, int *res)\n+{\n+   return __builtin_ssub_overflow(a, b, res);\n+}\n+\n+\n+int __attribute__((noinline,noclone))\n+saddl (long a, long b, long *res)\n+{\n+   return __builtin_saddl_overflow(a, b, res);\n+}\n+\n+int __attribute__((noinline,noclone))\n+ssubl (long a, long b, long *res)\n+{\n+   return __builtin_ssubl_overflow(a, b, res);\n+}\n+\n+\n+int __attribute__((noinline,noclone))\n+saddll (long long a, long long b, long long *res)\n+{\n+   return __builtin_saddll_overflow(a, b, res);\n+}\n+\n+int __attribute__((noinline,noclone))\n+ssubll (long long a, long long b, long long *res)\n+{\n+   return __builtin_ssubll_overflow(a, b, res);\n+}\n+\n+\n+/* With the attribute at least main always uses the same instructions\n+   regardless of the -march setting.  This is necessary for the\n+   scan-assembler-times directive below.  */\n+int __attribute__ ((target(\"arch=z10\")))\n+main ()\n+{\n+  int ret = 0;\n+  int result;\n+  long lresult;\n+  long long llresult;\n+\n+  ret += !!sadd (INT_MAX, 1, &result);\n+  ret += !!ssub (INT_MIN, 1, &result);\n+  ret += !!saddl (LONG_MAX, 1, &lresult);\n+  ret += !!ssubl (LONG_MIN, 1, &lresult);\n+  ret += !!saddll (LLONG_MAX, 1, &llresult);\n+  ret += !!ssubll (LLONG_MIN, 1, &llresult);\n+\n+  if (ret != 6)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* Check that no compare or bitop instructions are emitted.  */\n+/* { dg-final { scan-assembler-not \"\\tcr\" } } */\n+/* { dg-final { scan-assembler-not \"\\txr\" } } */\n+/* { dg-final { scan-assembler-not \"\\tnr\" } } */\n+/* { dg-final { scan-assembler-not \"\\tcgr\" } } */\n+/* { dg-final { scan-assembler-not \"\\txgr\" } } */\n+/* { dg-final { scan-assembler-not \"\\tngr\" } } */\n+/* On 31 bit the long long variants use risbgn to merge the 32 bit\n+   regs into a 64 bit reg.  */\n+/* { dg-final { scan-assembler-not \"\\trisbg\" { target { lp64 } } } } */\n+/* Just one for the ret != 6 comparison.  */\n+/* { dg-final { scan-assembler-times \"ci\" 1 } } */"}, {"sha": "230ad4af1e73866c9f22857c44a283d9567a2d41", "filename": "gcc/testsuite/gcc.target/s390/addsub-signed-overflow-2.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4caa6bab76241bc16517bf1d1075c986d0d0b8ad/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Faddsub-signed-overflow-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4caa6bab76241bc16517bf1d1075c986d0d0b8ad/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Faddsub-signed-overflow-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Faddsub-signed-overflow-2.c?ref=4caa6bab76241bc16517bf1d1075c986d0d0b8ad", "patch": "@@ -0,0 +1,80 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mzarch --save-temps\" } */\n+\n+#include <stddef.h>\n+#include <limits.h>\n+\n+int __attribute__((noinline,noclone))\n+sadd (int a, int *res)\n+{\n+   return __builtin_sadd_overflow(a, -1, res);\n+}\n+\n+int __attribute__((noinline,noclone))\n+ssub (int a, int *res)\n+{\n+   return __builtin_ssub_overflow(a, -1, res);\n+}\n+\n+\n+int __attribute__((noinline,noclone))\n+saddl (long a, long *res)\n+{\n+   return __builtin_saddl_overflow(a, -1, res);\n+}\n+\n+int __attribute__((noinline,noclone))\n+ssubl (long a, long *res)\n+{\n+   return __builtin_ssubl_overflow(a, -1, res);\n+}\n+\n+\n+int __attribute__((noinline,noclone))\n+saddll (long long a, long long *res)\n+{\n+   return __builtin_saddll_overflow(a, -1, res);\n+}\n+\n+int __attribute__((noinline,noclone))\n+ssubll (long long a, long long *res)\n+{\n+   return __builtin_ssubll_overflow(a, -1, res);\n+}\n+\n+/* With the attribute at least main always uses the same instructions\n+   regardless of the -march setting.  This is necessary for the\n+   scan-assembler-times directive below.  */\n+int __attribute__ ((target(\"arch=z10\")))\n+main ()\n+{\n+  int ret = 0;\n+  int result;\n+  long lresult;\n+  long long llresult;\n+\n+  ret += !!sadd (INT_MIN, &result);\n+  ret += !!ssub (INT_MIN, &result);\n+  ret += !!saddl (LONG_MIN, &lresult);\n+  ret += !!ssubl (LONG_MIN, &lresult);\n+  ret += !!saddll (LLONG_MIN, &llresult);\n+  ret += !!ssubll (LLONG_MIN, &llresult);\n+\n+  if (ret != 3)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* Check that no compare or bitop instructions are emitted.  */\n+/* { dg-final { scan-assembler-not \"\\tcr\" } } */\n+/* { dg-final { scan-assembler-not \"\\txr\" } } */\n+/* { dg-final { scan-assembler-not \"\\tnr\" } } */\n+/* { dg-final { scan-assembler-not \"\\tcgr\" } } */\n+/* { dg-final { scan-assembler-not \"\\txgr\" } } */\n+/* { dg-final { scan-assembler-not \"\\tngr\" } } */\n+/* On 31 bit the long long variants use risbgn to merge the 32 bit\n+   regs into a 64 bit reg.  */\n+/* { dg-final { scan-assembler-not \"\\trisbg\" { target { lp64 } } } } */\n+/* Just one for the ret != 3 comparison.  */\n+/* { dg-final { scan-assembler-times \"ci\" 1 } } */"}, {"sha": "b3db60ffef5fc6a5ebec22a0df1222e72e8c84ba", "filename": "gcc/testsuite/gcc.target/s390/mul-signed-overflow-1.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4caa6bab76241bc16517bf1d1075c986d0d0b8ad/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmul-signed-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4caa6bab76241bc16517bf1d1075c986d0d0b8ad/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmul-signed-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmul-signed-overflow-1.c?ref=4caa6bab76241bc16517bf1d1075c986d0d0b8ad", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do run } */\n+/* z14 only because we need msrkc, msc, msgrkc, msgc  */\n+/* { dg-options \"-O3 -march=z14 -mzarch --save-temps\" } */\n+\n+#include <stddef.h>\n+#include <limits.h>\n+\n+int __attribute__((noinline,noclone))\n+smul (int a, int b, int *res)\n+{\n+   return __builtin_smul_overflow(a, b, res);\n+}\n+\n+int __attribute__((noinline,noclone))\n+smull (long a, long b, long *res)\n+{\n+   return __builtin_smull_overflow(a, b, res);\n+}\n+\n+int __attribute__((noinline,noclone))\n+smulll (long long a, long long b, long long *res)\n+{\n+   return __builtin_smulll_overflow(a, b, res);\n+}\n+\n+\n+int\n+main ()\n+{\n+  int ret = 0;\n+  int result;\n+  long lresult;\n+  long long llresult;\n+\n+  ret += !!smul (INT_MAX, 2, &result);\n+  ret += !!smull (LONG_MAX, 2, &lresult);\n+  ret += !!smulll (LLONG_MAX, 2, &llresult);\n+\n+  if (ret != 3)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* Check that no compare or bitop instructions are emitted.  */\n+/* { dg-final { scan-assembler-not \"\\tcr\" } } */\n+/* { dg-final { scan-assembler-not \"\\txr\" } } */\n+/* { dg-final { scan-assembler-not \"\\tnr\" } } */\n+/* { dg-final { scan-assembler-not \"\\tcgr\" } } */\n+/* { dg-final { scan-assembler-not \"\\txgr\" } } */\n+/* { dg-final { scan-assembler-not \"\\tngr\" } } */\n+/* On 31 bit the long long variants use risbgn to merge the 32 bit\n+   regs into a 64 bit reg.  */\n+/* { dg-final { scan-assembler-not \"\\trisbg\" { target { lp64 } } } } */\n+/* Just one for the ret != 3 comparison.  */\n+/* { dg-final { scan-assembler-times \"ci\" 1 } } */"}, {"sha": "76b3fa60361b6f9b753058050e23d719242d76a8", "filename": "gcc/testsuite/gcc.target/s390/mul-signed-overflow-2.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4caa6bab76241bc16517bf1d1075c986d0d0b8ad/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmul-signed-overflow-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4caa6bab76241bc16517bf1d1075c986d0d0b8ad/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmul-signed-overflow-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmul-signed-overflow-2.c?ref=4caa6bab76241bc16517bf1d1075c986d0d0b8ad", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do run } */\n+/* z14 only because we need msrkc, msc, msgrkc, msgc  */\n+/* { dg-options \"-O3 -march=z14 -mzarch --save-temps\" } */\n+\n+#include <stddef.h>\n+#include <limits.h>\n+\n+int __attribute__((noinline,noclone))\n+smul (int a, int *res)\n+{\n+   return __builtin_smul_overflow(a, -1, res);\n+}\n+\n+int __attribute__((noinline,noclone))\n+smull (long a, long *res)\n+{\n+   return __builtin_smull_overflow(a, -1, res);\n+}\n+\n+int __attribute__((noinline,noclone))\n+smulll (long long a, long long *res)\n+{\n+   return __builtin_smulll_overflow(a, -1, res);\n+}\n+\n+\n+int\n+main ()\n+{\n+  int ret = 0;\n+  int result;\n+  long lresult;\n+  long long llresult;\n+\n+  ret += !!smul (INT_MIN, &result);\n+  ret += !!smull (LONG_MIN, &lresult);\n+  ret += !!smulll (LLONG_MIN, &llresult);\n+\n+  if (ret != 3)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* Check that no compare or bitop instructions are emitted.  */\n+/* { dg-final { scan-assembler-not \"\\tcr\" } } */\n+/* { dg-final { scan-assembler-not \"\\txr\" } } */\n+/* { dg-final { scan-assembler-not \"\\tnr\" } } */\n+/* { dg-final { scan-assembler-not \"\\tcgr\" } } */\n+/* { dg-final { scan-assembler-not \"\\txgr\" } } */\n+/* { dg-final { scan-assembler-not \"\\tngr\" } } */\n+/* On 31 bit the long long variants use risbgn to merge the 32 bit\n+   regs into a 64 bit reg.  */\n+/* { dg-final { scan-assembler-not \"\\trisbg\" { target { lp64 } } } } */\n+/* Just one for the ret != 3 comparison.  */\n+/* { dg-final { scan-assembler-times \"ci\" 1 } } */"}]}