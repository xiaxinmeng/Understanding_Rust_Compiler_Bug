{"sha": "fa5cc2db547120c41a1f1708039ad54b9dd171ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE1Y2MyZGI1NDcxMjBjNDFhMWYxNzA4MDM5YWQ1NGI5ZGQxNzFlYQ==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2015-05-20T19:44:25Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2015-05-20T19:44:25Z"}, "message": "formatter.h (_GLIBCXX_TYPEID): New macro to simplify usage of typeid.\n\n2015-05-20  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/debug/formatter.h (_GLIBCXX_TYPEID): New macro to simplify\n\tusage of typeid.\n\t(_Error_formatter::_M_print_type): New.\n\t* src/c++11/debug.cc\n\t(_Error_formatter::_Parameter::_M_print_field): Use latter.\n\t(_Error_formatter::_M_print_type): Implement latter using\n\t__cxaabiv1::__cxa_demangle to print demangled type name.\n\nFrom-SVN: r223455", "tree": {"sha": "f5218ba270e7073028ba36b20d617c7859270d6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5218ba270e7073028ba36b20d617c7859270d6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa5cc2db547120c41a1f1708039ad54b9dd171ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa5cc2db547120c41a1f1708039ad54b9dd171ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa5cc2db547120c41a1f1708039ad54b9dd171ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa5cc2db547120c41a1f1708039ad54b9dd171ea/comments", "author": null, "committer": null, "parents": [{"sha": "1476d1bd020588ee81d1384354cf533c88849a3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1476d1bd020588ee81d1384354cf533c88849a3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1476d1bd020588ee81d1384354cf533c88849a3a"}], "stats": {"total": 549, "additions": 271, "deletions": 278}, "files": [{"sha": "5797c970f4bb199d76405f8884068dbbb131de67", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5cc2db547120c41a1f1708039ad54b9dd171ea/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5cc2db547120c41a1f1708039ad54b9dd171ea/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=fa5cc2db547120c41a1f1708039ad54b9dd171ea", "patch": "@@ -1,5 +1,13 @@\n 2015-05-20  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \n+\t* include/debug/formatter.h (_GLIBCXX_TYPEID): New macro to simplify\n+\tusage of typeid.\n+\t(_Error_formatter::_M_print_type): New.\n+\t* src/c++11/debug.cc\n+\t(_Error_formatter::_Parameter::_M_print_field): Use latter.\n+\t(_Error_formatter::_M_print_type): Implement latter using\n+\t__cxaabiv1::__cxa_demangle to print demangled type name.\n+\n \t* include/bits/cpp_type_traits.h\n \t(std::move_iterator): Delete declaration.\n \t(std::__is_move_iterator<move_iterator>): Move partial specialization..."}, {"sha": "32dcf92ac599f5961e46d3d630ca6315436a7c09", "filename": "libstdc++-v3/include/debug/formatter.h", "status": "modified", "additions": 75, "deletions": 95, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5cc2db547120c41a1f1708039ad54b9dd171ea/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fformatter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5cc2db547120c41a1f1708039ad54b9dd171ea/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fformatter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fformatter.h?ref=fa5cc2db547120c41a1f1708039ad54b9dd171ea", "patch": "@@ -31,7 +31,17 @@\n \n #include <bits/c++config.h>\n #include <bits/cpp_type_traits.h>\n-#include <typeinfo>\n+\n+#if __cpp_rtti\n+# include <typeinfo>\n+# define _GLIBCXX_TYPEID(_Type) &typeid(_Type)\n+#else\n+namespace std\n+{\n+  class type_info;\n+}\n+# define _GLIBCXX_TYPEID(_Type) 0\n+#endif\n \n namespace __gnu_debug\n {\n@@ -134,11 +144,11 @@ namespace __gnu_debug\n     enum _Iterator_state\n     {\n       __unknown_state,\n-      __singular,      // singular, may still be attached to a sequence\n-      __begin,         // dereferenceable, and at the beginning\n-      __middle,        // dereferenceable, not at the beginning\n-      __end,           // past-the-end, may be at beginning if sequence empty\n-      __before_begin,  // before begin\n+      __singular,\t// singular, may still be attached to a sequence\n+      __begin,\t\t// dereferenceable, and at the beginning\n+      __middle,\t\t// dereferenceable, not at the beginning\n+      __end,\t\t// past-the-end, may be at beginning if sequence empty\n+      __before_begin,\t// before begin\n       __last_state\n     };\n \n@@ -163,76 +173,68 @@ namespace __gnu_debug\n \t// When _M_kind == __iterator\n \tstruct\n \t{\n-\t  const char*      _M_name;\n-\t  const void*      _M_address;\n-\t  const type_info* _M_type;\n-\t  _Constness       _M_constness;\n-\t  _Iterator_state  _M_state;\n-\t  const void*      _M_sequence;\n-\t  const type_info* _M_seq_type;\n+\t  const char*\t\t_M_name;\n+\t  const void*\t\t_M_address;\n+\t  const type_info*\t_M_type;\n+\t  _Constness\t\t_M_constness;\n+\t  _Iterator_state\t_M_state;\n+\t  const void*\t\t_M_sequence;\n+\t  const type_info*\t_M_seq_type;\n \t} _M_iterator;\n \n \t// When _M_kind == __sequence\n \tstruct\n \t{\n-\t  const char*      _M_name;\n-\t  const void*      _M_address;\n-\t  const type_info* _M_type;\n+\t  const char*\t\t_M_name;\n+\t  const void*\t\t_M_address;\n+\t  const type_info*\t_M_type;\n \t} _M_sequence;\n \n \t// When _M_kind == __integer\n \tstruct\n \t{\n-\t  const char* _M_name;\n-\t  long        _M_value;\n+\t  const char*\t\t_M_name;\n+\t  long\t\t\t_M_value;\n \t} _M_integer;\n \n \t// When _M_kind == __string\n \tstruct\n \t{\n-\t  const char* _M_name;\n-\t  const char* _M_value;\n+\t  const char*\t\t_M_name;\n+\t  const char*\t\t_M_value;\n \t} _M_string;\n       } _M_variant;\n \n       _Parameter() : _M_kind(__unused_param), _M_variant() { }\n \n-      _Parameter(long __value, const char* __name) \n+      _Parameter(long __value, const char* __name)\n       : _M_kind(__integer), _M_variant()\n       {\n \t_M_variant._M_integer._M_name = __name;\n \t_M_variant._M_integer._M_value = __value;\n       }\n \n-      _Parameter(const char* __value, const char* __name) \n+      _Parameter(const char* __value, const char* __name)\n       : _M_kind(__string), _M_variant()\n       {\n \t_M_variant._M_string._M_name = __name;\n \t_M_variant._M_string._M_value = __value;\n       }\n \n       template<typename _Iterator, typename _Sequence>\n-        _Parameter(const _Safe_iterator<_Iterator, _Sequence>& __it,\n+\t_Parameter(const _Safe_iterator<_Iterator, _Sequence>& __it,\n \t\t   const char* __name, _Is_iterator)\n \t: _M_kind(__iterator),  _M_variant()\n-        {\n+\t{\n \t  _M_variant._M_iterator._M_name = __name;\n \t  _M_variant._M_iterator._M_address = &__it;\n-#if __cpp_rtti\n-\t  _M_variant._M_iterator._M_type = &typeid(__it);\n-#else\n-\t  _M_variant._M_iterator._M_type = 0;\n-#endif\n+\t  _M_variant._M_iterator._M_type = _GLIBCXX_TYPEID(__it);\n \t  _M_variant._M_iterator._M_constness =\n \t    std::__are_same<_Safe_iterator<_Iterator, _Sequence>,\n-\t                    typename _Sequence::iterator>::\n+\t\t\t    typename _Sequence::iterator>::\n \t      __value ? __mutable_iterator : __const_iterator;\n \t  _M_variant._M_iterator._M_sequence = __it._M_get_sequence();\n-#if __cpp_rtti\n-\t  _M_variant._M_iterator._M_seq_type = &typeid(_Sequence);\n-#else\n-\t  _M_variant._M_iterator._M_seq_type = 0;\n-#endif\n+\t  _M_variant._M_iterator._M_seq_type = _GLIBCXX_TYPEID(_Sequence);\n \n \t  if (__it._M_singular())\n \t    _M_variant._M_iterator._M_state = __singular;\n@@ -256,21 +258,13 @@ namespace __gnu_debug\n \t{\n \t  _M_variant._M_iterator._M_name = __name;\n \t  _M_variant._M_iterator._M_address = &__it;\n-#if __cpp_rtti\n-\t  _M_variant._M_iterator._M_type = &typeid(__it);\n-#else\n-\t  _M_variant._M_iterator._M_type = 0;\n-#endif\n+\t  _M_variant._M_iterator._M_type = _GLIBCXX_TYPEID(__it);\n \t  _M_variant._M_iterator._M_constness =\n \t    std::__are_same<_Safe_local_iterator<_Iterator, _Sequence>,\n-\t                    typename _Sequence::local_iterator>::\n+\t\t\t    typename _Sequence::local_iterator>::\n \t      __value ? __mutable_iterator : __const_iterator;\n \t  _M_variant._M_iterator._M_sequence = __it._M_get_sequence();\n-#if __cpp_rtti\n-\t  _M_variant._M_iterator._M_seq_type = &typeid(_Sequence);\n-#else\n-\t  _M_variant._M_iterator._M_seq_type = 0;\n-#endif\n+\t  _M_variant._M_iterator._M_seq_type = _GLIBCXX_TYPEID(_Sequence);\n \n \t  if (__it._M_singular())\n \t    _M_variant._M_iterator._M_state = __singular;\n@@ -286,50 +280,38 @@ namespace __gnu_debug\n \t}\n \n       template<typename _Type>\n-        _Parameter(const _Type*& __it, const char* __name, _Is_iterator)\n-        : _M_kind(__iterator), _M_variant()\n-        {\n+\t_Parameter(const _Type*& __it, const char* __name, _Is_iterator)\n+\t: _M_kind(__iterator), _M_variant()\n+\t{\n \t  _M_variant._M_iterator._M_name = __name;\n \t  _M_variant._M_iterator._M_address = &__it;\n-#if __cpp_rtti\n-\t  _M_variant._M_iterator._M_type = &typeid(__it);\n-#else\n-\t  _M_variant._M_iterator._M_type = 0;\n-#endif\n+\t  _M_variant._M_iterator._M_type = _GLIBCXX_TYPEID(__it);\n \t  _M_variant._M_iterator._M_constness = __mutable_iterator;\n \t  _M_variant._M_iterator._M_state = __it? __unknown_state : __singular;\n \t  _M_variant._M_iterator._M_sequence = 0;\n \t  _M_variant._M_iterator._M_seq_type = 0;\n \t}\n \n       template<typename _Type>\n-        _Parameter(_Type*& __it, const char* __name, _Is_iterator)\n-        : _M_kind(__iterator), _M_variant()\n-        {\n+\t_Parameter(_Type*& __it, const char* __name, _Is_iterator)\n+\t: _M_kind(__iterator), _M_variant()\n+\t{\n \t  _M_variant._M_iterator._M_name = __name;\n \t  _M_variant._M_iterator._M_address = &__it;\n-#if __cpp_rtti\n-\t  _M_variant._M_iterator._M_type = &typeid(__it);\n-#else\n-\t  _M_variant._M_iterator._M_type = 0;\n-#endif\n+\t  _M_variant._M_iterator._M_type = _GLIBCXX_TYPEID(__it);\n \t  _M_variant._M_iterator._M_constness = __const_iterator;\n \t  _M_variant._M_iterator._M_state = __it? __unknown_state : __singular;\n \t  _M_variant._M_iterator._M_sequence = 0;\n \t  _M_variant._M_iterator._M_seq_type = 0;\n \t}\n \n       template<typename _Iterator>\n-        _Parameter(const _Iterator& __it, const char* __name, _Is_iterator)\n-        : _M_kind(__iterator), _M_variant()\n-        {\n+\t_Parameter(const _Iterator& __it, const char* __name, _Is_iterator)\n+\t: _M_kind(__iterator), _M_variant()\n+\t{\n \t  _M_variant._M_iterator._M_name = __name;\n \t  _M_variant._M_iterator._M_address = &__it;\n-#if __cpp_rtti\n-\t  _M_variant._M_iterator._M_type = &typeid(__it);\n-#else\n-\t  _M_variant._M_iterator._M_type = 0;\n-#endif\n+\t  _M_variant._M_iterator._M_type = _GLIBCXX_TYPEID(__it);\n \t  _M_variant._M_iterator._M_constness = __unknown_constness;\n \t  _M_variant._M_iterator._M_state =\n \t    __gnu_debug::__check_singular(__it)? __singular : __unknown_state;\n@@ -338,31 +320,23 @@ namespace __gnu_debug\n \t}\n \n       template<typename _Sequence>\n-        _Parameter(const _Safe_sequence<_Sequence>& __seq,\n+\t_Parameter(const _Safe_sequence<_Sequence>& __seq,\n \t\t   const char* __name, _Is_sequence)\n-        : _M_kind(__sequence), _M_variant()\n-        {\n+\t: _M_kind(__sequence), _M_variant()\n+\t{\n \t  _M_variant._M_sequence._M_name = __name;\n \t  _M_variant._M_sequence._M_address =\n \t    static_cast<const _Sequence*>(&__seq);\n-#if __cpp_rtti\n-\t  _M_variant._M_sequence._M_type = &typeid(_Sequence);\n-#else\n-\t  _M_variant._M_sequence._M_type = 0;\n-#endif\n+\t  _M_variant._M_sequence._M_type = _GLIBCXX_TYPEID(_Sequence);\n \t}\n \n       template<typename _Sequence>\n-        _Parameter(const _Sequence& __seq, const char* __name, _Is_sequence)\n-        : _M_kind(__sequence), _M_variant()\n-        {\n+\t_Parameter(const _Sequence& __seq, const char* __name, _Is_sequence)\n+\t: _M_kind(__sequence), _M_variant()\n+\t{\n \t  _M_variant._M_sequence._M_name = __name;\n \t  _M_variant._M_sequence._M_address = &__seq;\n-#if __cpp_rtti\n-\t  _M_variant._M_sequence._M_type = &typeid(_Sequence);\n-#else\n-\t  _M_variant._M_sequence._M_type = 0;\n-#endif\n+\t  _M_variant._M_sequence._M_type = _GLIBCXX_TYPEID(_Sequence);\n \t}\n \n       void\n@@ -438,21 +412,25 @@ namespace __gnu_debug\n     void\n     _M_print_string(const char* __string) const;\n \n+    void\n+    _M_print_type(const type_info* __info,\n+\t\t  const char* __unknown_name) const;\n+\n     void\n     _M_get_max_length() const throw ();\n \n     enum { __max_parameters = 9 };\n \n-    const char*         _M_file;\n-    std::size_t         _M_line;\n-    mutable _Parameter  _M_parameters[__max_parameters];\n-    mutable std::size_t _M_num_parameters;\n-    mutable const char* _M_text;\n-    mutable std::size_t _M_max_length;\n+    const char*\t\t_M_file;\n+    std::size_t\t\t_M_line;\n+    mutable _Parameter\t_M_parameters[__max_parameters];\n+    mutable std::size_t\t_M_num_parameters;\n+    mutable const char*\t_M_text;\n+    mutable std::size_t\t_M_max_length;\n     enum { _M_indent = 4 } ;\n-    mutable std::size_t _M_column;\n-    mutable bool        _M_first_line;\n-    mutable bool        _M_wordwrap;\n+    mutable std::size_t\t_M_column;\n+    mutable bool\t_M_first_line;\n+    mutable bool\t_M_wordwrap;\n \n   public:\n     static _Error_formatter\n@@ -461,4 +439,6 @@ namespace __gnu_debug\n   };\n } // namespace __gnu_debug\n \n+#undef _GLIBCXX_TYPEID\n+\n #endif"}, {"sha": "f51435aa2c41f045e10cf92595f1421cd9861313", "filename": "libstdc++-v3/src/c++11/debug.cc", "status": "modified", "additions": 188, "deletions": 183, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5cc2db547120c41a1f1708039ad54b9dd171ea/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fdebug.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5cc2db547120c41a1f1708039ad54b9dd171ea/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fdebug.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fdebug.cc?ref=fa5cc2db547120c41a1f1708039ad54b9dd171ea", "patch": "@@ -35,6 +35,8 @@\n #include <cstdlib>\n #include <functional>\n \n+#include <cxxabi.h> // for __cxa_demangle\n+\n using namespace std;\n \n namespace\n@@ -101,7 +103,7 @@ namespace\n \n namespace __gnu_debug\n {\n-  const char* _S_debug_messages[] = \n+  const char* _S_debug_messages[] =\n   {\n     // General Checks\n     \"function requires a valid iterator range [%1.name;, %2.name;)\",\n@@ -182,7 +184,8 @@ namespace __gnu_debug\n     \" container only holds %3; buckets\",\n     \"load factor shall be positive\",\n     \"allocators must be equal\",\n-    \"attempt to insert with an iterator range [%1.name;, %2.name;) from this container\"\n+    \"attempt to insert with an iterator range [%1.name;, %2.name;) from this\"\n+    \" container\"\n   };\n \n   void\n@@ -192,7 +195,7 @@ namespace __gnu_debug\n     __gnu_cxx::__scoped_lock sentry(_M_get_mutex());\n     detach_all(_M_iterators);\n     _M_iterators = 0;\n-    \n+\n     detach_all(_M_const_iterators);\n     _M_const_iterators = 0;\n   }\n@@ -307,7 +310,7 @@ namespace __gnu_debug\n   _M_attach(_Safe_sequence_base* __seq, bool __constant)\n   {\n     _M_detach();\n-    \n+\n     // Attach to the new sequence (if there is one)\n     if (__seq)\n       {\n@@ -316,13 +319,13 @@ namespace __gnu_debug\n \t_M_sequence->_M_attach(this, __constant);\n       }\n   }\n-  \n+\n   void\n   _Safe_iterator_base::\n   _M_attach_single(_Safe_sequence_base* __seq, bool __constant) throw ()\n   {\n     _M_detach_single();\n-    \n+\n     // Attach to the new sequence (if there is one)\n     if (__seq)\n       {\n@@ -366,12 +369,12 @@ namespace __gnu_debug\n   _Safe_iterator_base::\n   _M_singular() const throw ()\n   { return !_M_sequence || _M_version != _M_sequence->_M_version; }\n-    \n+\n   bool\n   _Safe_iterator_base::\n   _M_can_compare(const _Safe_iterator_base& __x) const throw ()\n   {\n-    return (!_M_singular() \n+    return (!_M_singular()\n \t    && !__x._M_singular() && _M_sequence == __x._M_sequence);\n   }\n \n@@ -390,7 +393,7 @@ namespace __gnu_debug\n   _M_attach(_Safe_sequence_base* __cont, bool __constant)\n   {\n     _M_detach();\n-    \n+\n     // Attach to the new container (if there is one)\n     if (__cont)\n       {\n@@ -399,13 +402,13 @@ namespace __gnu_debug\n \t_M_get_container()->_M_attach_local(this, __constant);\n       }\n   }\n-  \n+\n   void\n   _Safe_local_iterator_base::\n   _M_attach_single(_Safe_sequence_base* __cont, bool __constant) throw ()\n   {\n     _M_detach_single();\n-    \n+\n     // Attach to the new container (if there is one)\n     if (__cont)\n       {\n@@ -442,7 +445,7 @@ namespace __gnu_debug\n     __gnu_cxx::__scoped_lock sentry(_M_get_mutex());\n     detach_all(_M_iterators);\n     _M_iterators = 0;\n-    \n+\n     detach_all(_M_const_iterators);\n     _M_const_iterators = 0;\n \n@@ -524,151 +527,132 @@ namespace __gnu_debug\n     assert(this->_M_kind != _Parameter::__unused_param);\n     const int __bufsize = 64;\n     char __buf[__bufsize];\n-    \n-    if (_M_kind == __iterator)\n-      {\n-\tif (strcmp(__name, \"name\") == 0)\n-\t  {\n-\t    assert(_M_variant._M_iterator._M_name);\n-\t    __formatter->_M_print_word(_M_variant._M_iterator._M_name);\n-\t  }\n-\telse if (strcmp(__name, \"address\") == 0)\n-\t  {\n-\t    __formatter->_M_format_word(__buf, __bufsize, \"%p\", \n-\t\t\t\t\t_M_variant._M_iterator._M_address);\n-\t    __formatter->_M_print_word(__buf);\n-\t  }\n-\telse if (strcmp(__name, \"type\") == 0)\n-\t  {\n-\t    if (!_M_variant._M_iterator._M_type)\n-\t      __formatter->_M_print_word(\"<unknown type>\");\n-\t    else\n-\t      // TBD: demangle!\n-\t      __formatter->_M_print_word(_M_variant._M_iterator.\n-\t\t\t\t\t _M_type->name());\n-\t  }\n-\telse if (strcmp(__name, \"constness\") == 0)\n-\t  {\n-\t    static const char* __constness_names[__last_constness] =\n-\t      {\n-\t\t\"<unknown>\",\n-\t\t\"constant\",\n-\t\t\"mutable\"\n-\t      };\n-\t    __formatter->_M_print_word(__constness_names[_M_variant.\n-\t\t\t\t\t\t\t _M_iterator.\n-\t\t\t\t\t\t\t _M_constness]);\n-\t  }\n-\telse if (strcmp(__name, \"state\") == 0)\n-\t  {\n-\t    static const char* __state_names[__last_state] = \n-\t      {\n-\t\t\"<unknown>\",\n-\t\t\"singular\",\n-\t\t\"dereferenceable (start-of-sequence)\",\n-\t\t\"dereferenceable\",\n-\t\t\"past-the-end\",\n-\t\t\"before-begin\"\n-\t      };\n-\t    __formatter->_M_print_word(__state_names[_M_variant.\n-\t\t\t\t\t\t     _M_iterator._M_state]);\n-\t  }\n-\telse if (strcmp(__name, \"sequence\") == 0)\n-\t  {\n-\t    assert(_M_variant._M_iterator._M_sequence);\n-\t    __formatter->_M_format_word(__buf, __bufsize, \"%p\", \n-\t\t\t\t\t_M_variant._M_iterator._M_sequence);\n-\t    __formatter->_M_print_word(__buf);\n-\t  }\n-\telse if (strcmp(__name, \"seq_type\") == 0)\n-\t  {\n-\t    if (!_M_variant._M_iterator._M_seq_type)\n-\t      __formatter->_M_print_word(\"<unknown seq_type>\");\n-\t    else\n-\t      // TBD: demangle!\n-\t      __formatter->_M_print_word(_M_variant._M_iterator.\n-\t\t\t\t\t _M_seq_type->name());\n-\t  }\n-\telse\n-\t  assert(false);\n-      }\n-    else if (_M_kind == __sequence)\n-      {\n-\tif (strcmp(__name, \"name\") == 0)\n-\t  {\n-\t    assert(_M_variant._M_sequence._M_name);\n-\t    __formatter->_M_print_word(_M_variant._M_sequence._M_name);\n-\t  }\n-\telse if (strcmp(__name, \"address\") == 0)\n-\t  {\n-\t    assert(_M_variant._M_sequence._M_address);\n-\t    __formatter->_M_format_word(__buf, __bufsize, \"%p\", \n-\t\t\t\t\t_M_variant._M_sequence._M_address);\n-\t    __formatter->_M_print_word(__buf);\n-\t  }\n-\telse if (strcmp(__name, \"type\") == 0)\n-\t  {\n-\t    if (!_M_variant._M_sequence._M_type)\n-\t      __formatter->_M_print_word(\"<unknown type>\");\n-\t    else\n-\t      // TBD: demangle!\n-\t      __formatter->_M_print_word(_M_variant._M_sequence.\n-\t\t\t\t\t _M_type->name());\n-\t  }\n-\telse\n-\t  assert(false);\n-      }\n-    else if (_M_kind == __integer)\n-      {\n-\tif (strcmp(__name, \"name\") == 0)\n-\t  {\n-\t    assert(_M_variant._M_integer._M_name);\n-\t    __formatter->_M_print_word(_M_variant._M_integer._M_name);\n-\t  }\n-\telse\n+\n+    switch (_M_kind)\n+    {\n+    case __iterator:\n+      if (strcmp(__name, \"name\") == 0)\n+\t{\n+\t  assert(_M_variant._M_iterator._M_name);\n+\t  __formatter->_M_print_word(_M_variant._M_iterator._M_name);\n+\t}\n+      else if (strcmp(__name, \"address\") == 0)\n+\t{\n+\t  __formatter->_M_format_word(__buf, __bufsize, \"%p\",\n+\t\t\t\t      _M_variant._M_iterator._M_address);\n+\t  __formatter->_M_print_word(__buf);\n+\t}\n+      else if (strcmp(__name, \"type\") == 0)\n+\t__formatter->_M_print_type(_M_variant._M_iterator._M_type,\n+\t\t\t\t   \"<unknown type>\");\n+      else if (strcmp(__name, \"constness\") == 0)\n+\t{\n+\t  static const char* __constness_names[__last_constness] =\n+\t    {\n+\t      \"<unknown>\",\n+\t      \"constant\",\n+\t      \"mutable\"\n+\t    };\n+\t  __formatter->_M_print_word(__constness_names[_M_variant.\n+\t\t\t\t\t\t       _M_iterator.\n+\t\t\t\t\t\t       _M_constness]);\n+\t}\n+      else if (strcmp(__name, \"state\") == 0)\n+\t{\n+\t  static const char* __state_names[__last_state] =\n+\t    {\n+\t      \"<unknown>\",\n+\t      \"singular\",\n+\t      \"dereferenceable (start-of-sequence)\",\n+\t      \"dereferenceable\",\n+\t      \"past-the-end\",\n+\t      \"before-begin\"\n+\t    };\n+\t  __formatter->_M_print_word(__state_names[_M_variant.\n+\t\t\t\t\t\t   _M_iterator._M_state]);\n+\t}\n+      else if (strcmp(__name, \"sequence\") == 0)\n+\t{\n+\t  assert(_M_variant._M_iterator._M_sequence);\n+\t  __formatter->_M_format_word(__buf, __bufsize, \"%p\",\n+\t\t\t\t      _M_variant._M_iterator._M_sequence);\n+\t  __formatter->_M_print_word(__buf);\n+\t}\n+      else if (strcmp(__name, \"seq_type\") == 0)\n+\t__formatter->_M_print_type(_M_variant._M_iterator._M_seq_type,\n+\t\t\t\t   \"<unknown seq_type>\");\n+      else\n \tassert(false);\n-      }\n-    else if (_M_kind == __string)\n-      {\n-\tif (strcmp(__name, \"name\") == 0)\n-\t  {\n-\t    assert(_M_variant._M_string._M_name);\n-\t    __formatter->_M_print_word(_M_variant._M_string._M_name);\n-\t  }\n-\telse\n-\t  assert(false);\n-      }\n-    else\n-      {\n+      break;\n+    case __sequence:\n+      if (strcmp(__name, \"name\") == 0)\n+\t{\n+\t  assert(_M_variant._M_sequence._M_name);\n+\t  __formatter->_M_print_word(_M_variant._M_sequence._M_name);\n+\t}\n+      else if (strcmp(__name, \"address\") == 0)\n+\t{\n+\t  assert(_M_variant._M_sequence._M_address);\n+\t  __formatter->_M_format_word(__buf, __bufsize, \"%p\",\n+\t\t\t\t      _M_variant._M_sequence._M_address);\n+\t  __formatter->_M_print_word(__buf);\n+\t}\n+      else if (strcmp(__name, \"type\") == 0)\n+\t__formatter->_M_print_type(_M_variant._M_sequence._M_type,\n+\t\t\t\t   \"<unknown type>\");\n+      else\n \tassert(false);\n-      }\n+      break;\n+    case __integer:\n+      if (strcmp(__name, \"name\") == 0)\n+\t{\n+\t  assert(_M_variant._M_integer._M_name);\n+\t  __formatter->_M_print_word(_M_variant._M_integer._M_name);\n+\t}\n+      else\n+\tassert(false);\n+      break;\n+    case __string:\n+      if (strcmp(__name, \"name\") == 0)\n+\t{\n+\t  assert(_M_variant._M_string._M_name);\n+\t  __formatter->_M_print_word(_M_variant._M_string._M_name);\n+\t}\n+      else\n+\tassert(false);\n+      break;\n+    default:\n+      assert(false);\n+      break;\n+    }\n   }\n-  \n+\n   void\n   _Error_formatter::_Parameter::\n   _M_print_description(const _Error_formatter* __formatter) const\n   {\n     const int __bufsize = 128;\n     char __buf[__bufsize];\n-    \n-    if (_M_kind == __iterator)\n+\n+    switch (_M_kind)\n       {\n+      case __iterator:\n \t__formatter->_M_print_word(\"iterator \");\n \tif (_M_variant._M_iterator._M_name)\n \t  {\n-\t    __formatter->_M_format_word(__buf, __bufsize, \"\\\"%s\\\" \", \n+\t    __formatter->_M_format_word(__buf, __bufsize, \"\\\"%s\\\" \",\n \t\t\t\t\t_M_variant._M_iterator._M_name);\n \t    __formatter->_M_print_word(__buf);\n \t  }\n-\t\n-\t__formatter->_M_format_word(__buf, __bufsize, \"@ 0x%p {\\n\", \n+\n+\t__formatter->_M_format_word(__buf, __bufsize, \"@ 0x%p {\\n\",\n \t\t\t\t    _M_variant._M_iterator._M_address);\n \t__formatter->_M_print_word(__buf);\n \tif (_M_variant._M_iterator._M_type)\n \t  {\n \t    __formatter->_M_print_word(\"type = \");\n \t    _M_print_field(__formatter, \"type\");\n-\t    \n+\n \t    if (_M_variant._M_iterator._M_constness != __unknown_constness)\n \t      {\n \t\t__formatter->_M_print_word(\" (\");\n@@ -677,14 +661,14 @@ namespace __gnu_debug\n \t      }\n \t    __formatter->_M_print_word(\";\\n\");\n \t  }\n-\t\n+\n \tif (_M_variant._M_iterator._M_state != __unknown_state)\n \t  {\n \t    __formatter->_M_print_word(\"  state = \");\n \t    _M_print_field(__formatter, \"state\");\n \t    __formatter->_M_print_word(\";\\n\");\n \t  }\n-\t\n+\n \tif (_M_variant._M_iterator._M_sequence)\n \t  {\n \t    __formatter->_M_print_word(\"  references sequence \");\n@@ -694,47 +678,49 @@ namespace __gnu_debug\n \t\t_M_print_field(__formatter, \"seq_type\");\n \t\t__formatter->_M_print_word(\"' \");\n \t      }\n-\t    \n-\t    __formatter->_M_format_word(__buf, __bufsize, \"@ 0x%p\\n\", \n+\n+\t    __formatter->_M_format_word(__buf, __bufsize, \"@ 0x%p\\n\",\n \t\t\t\t\t_M_variant._M_iterator._M_sequence);\n \t    __formatter->_M_print_word(__buf);\n \t  }\n \t__formatter->_M_print_word(\"}\\n\");\n-      }\n-    else if (_M_kind == __sequence)\n-      {\n+\tbreak;\n+      case __sequence:\n \t__formatter->_M_print_word(\"sequence \");\n \tif (_M_variant._M_sequence._M_name)\n \t  {\n-\t    __formatter->_M_format_word(__buf, __bufsize, \"\\\"%s\\\" \", \n+\t    __formatter->_M_format_word(__buf, __bufsize, \"\\\"%s\\\" \",\n \t\t\t\t\t_M_variant._M_sequence._M_name);\n \t    __formatter->_M_print_word(__buf);\n \t  }\n-\t\n-\t__formatter->_M_format_word(__buf, __bufsize, \"@ 0x%p {\\n\", \n+\n+\t__formatter->_M_format_word(__buf, __bufsize, \"@ 0x%p {\\n\",\n \t\t\t\t    _M_variant._M_sequence._M_address);\n \t__formatter->_M_print_word(__buf);\n-\t\n+\n \tif (_M_variant._M_sequence._M_type)\n \t  {\n \t    __formatter->_M_print_word(\"  type = \");\n \t    _M_print_field(__formatter, \"type\");\n \t    __formatter->_M_print_word(\";\\n\");\n-\t  }\t  \n+\t  }\n \t__formatter->_M_print_word(\"}\\n\");\n+\tbreak;\n+      default:\n+\tbreak;\n       }\n   }\n \n   const _Error_formatter&\n   _Error_formatter::_M_message(_Debug_msg_id __id) const throw ()\n   { return this->_M_message(_S_debug_messages[__id]); }\n-  \n+\n   void\n   _Error_formatter::_M_error() const\n   {\n     const int __bufsize = 128;\n     char __buf[__bufsize];\n-    \n+\n     // Emit file & line number information\n     _M_column = 1;\n     _M_wordwrap = false;\n@@ -744,48 +730,52 @@ namespace __gnu_debug\n \t_M_print_word(__buf);\n \t_M_column += strlen(__buf);\n       }\n-    \n+\n     if (_M_line > 0)\n       {\n \t_M_format_word(__buf, __bufsize, \"%u:\", _M_line);\n \t_M_print_word(__buf);\n \t_M_column += strlen(__buf);\n       }\n-    \n+\n     if (_M_max_length)\n       _M_wordwrap = true;\n     _M_print_word(\"error: \");\n-    \n+\n     // Print the error message\n     assert(_M_text);\n     _M_print_string(_M_text);\n     _M_print_word(\".\\n\");\n-    \n+\n     // Emit descriptions of the objects involved in the operation\n     _M_wordwrap = false;\n     bool __has_noninteger_parameters = false;\n     for (unsigned int __i = 0; __i < _M_num_parameters; ++__i)\n       {\n-\tif (_M_parameters[__i]._M_kind == _Parameter::__iterator\n-\t    || _M_parameters[__i]._M_kind == _Parameter::__sequence)\n+\tswitch (_M_parameters[__i]._M_kind)\n \t  {\n+\t  case _Parameter::__iterator:\n+\t  case _Parameter::__sequence:\n \t    if (!__has_noninteger_parameters)\n \t      {\n \t\t_M_first_line = true;\n \t\t_M_print_word(\"\\nObjects involved in the operation:\\n\");\n \t\t__has_noninteger_parameters = true;\n \t      }\n \t    _M_parameters[__i]._M_print_description(this);\n+\t    break;\n+\t  default:\n+\t    break;\n \t  }\n       }\n-    \n+\n     abort();\n   }\n \n   template<typename _Tp>\n     void\n-    _Error_formatter::_M_format_word(char* __buf, \n-\t\t\t\t     int __n __attribute__ ((__unused__)), \n+    _Error_formatter::_M_format_word(char* __buf,\n+\t\t\t\t     int __n __attribute__ ((__unused__)),\n \t\t\t\t     const char* __fmt, _Tp __s) const throw ()\n     {\n #ifdef _GLIBCXX_USE_C99\n@@ -795,25 +785,24 @@ namespace __gnu_debug\n #endif\n     }\n \n-  \n-  void \n+  void\n   _Error_formatter::_M_print_word(const char* __word) const\n   {\n-    if (!_M_wordwrap) \n+    if (!_M_wordwrap)\n       {\n \tfprintf(stderr, \"%s\", __word);\n \treturn;\n       }\n-    \n+\n     size_t __length = strlen(__word);\n     if (__length == 0)\n       return;\n-    \n+\n     size_t __visual_length\n       = __word[__length - 1] == '\\n' ? __length - 1 : __length;\n     if (__visual_length == 0\n \t|| (_M_column + __visual_length < _M_max_length)\n-\t|| (__visual_length >= _M_max_length && _M_column == 1)) \n+\t|| (__visual_length >= _M_max_length && _M_column == 1))\n       {\n \t// If this isn't the first line, indent\n \tif (_M_column == 1 && !_M_first_line)\n@@ -825,10 +814,10 @@ namespace __gnu_debug\n \t    fprintf(stderr, \"%s\", __spacing);\n \t    _M_column += _M_indent;\n \t  }\n-\t\n+\n \tfprintf(stderr, \"%s\", __word);\n-\t\n-\tif (__word[__length - 1] == '\\n') \n+\n+\tif (__word[__length - 1] == '\\n')\n \t  {\n \t    _M_first_line = false;\n \t    _M_column = 1;\n@@ -842,7 +831,7 @@ namespace __gnu_debug\n \t_M_print_word(__word);\n       }\n   }\n-  \n+\n   void\n   _Error_formatter::\n   _M_print_string(const char* __string) const\n@@ -864,21 +853,21 @@ namespace __gnu_debug\n \t      ++__finish;\n \t    if (isspace(*__finish))\n \t      ++__finish;\n-\t    \n+\n \t    const ptrdiff_t __len = __finish - __start;\n \t    assert(__len < __bufsize);\n \t    memcpy(__buf, __start, __len);\n \t    __buf[__len] = '\\0';\n \t    _M_print_word(__buf);\n \t    __start = __finish;\n-\t    \n+\n \t    // Skip extra whitespace\n-\t    while (*__start == ' ') \n+\t    while (*__start == ' ')\n \t      ++__start;\n-\t    \n+\n \t    continue;\n-\t  } \n-\t\n+\t  }\n+\n \t++__start;\n \tassert(*__start);\n \tif (*__start == '%')\n@@ -887,13 +876,13 @@ namespace __gnu_debug\n \t    ++__start;\n \t    continue;\n \t  }\n-\t\n+\n \t// Get the parameter number\n \tassert(*__start >= '1' && *__start <= '9');\n \tsize_t __param = *__start - '0';\n \t--__param;\n \tassert(__param < _M_num_parameters);\n-      \n+\n \t// '.' separates the parameter number from the field\n \t// name, if there is one.\n \t++__start;\n@@ -904,15 +893,15 @@ namespace __gnu_debug\n \t    __buf[0] = '\\0';\n \t    if (_M_parameters[__param]._M_kind == _Parameter::__integer)\n \t      {\n-\t\t_M_format_word(__buf, __bufsize, \"%ld\", \n+\t\t_M_format_word(__buf, __bufsize, \"%ld\",\n \t\t\t       _M_parameters[__param]._M_variant._M_integer._M_value);\n \t\t_M_print_word(__buf);\n \t      }\n \t    else if (_M_parameters[__param]._M_kind == _Parameter::__string)\n \t      _M_print_string(_M_parameters[__param]._M_variant._M_string._M_value);\n \t    continue;\n \t  }\n-\t\n+\n \t// Extract the field name we want\n \tenum { __max_field_len = 16 };\n \tchar __field[__max_field_len];\n@@ -926,8 +915,24 @@ namespace __gnu_debug\n \t  }\n \t++__start;\n \t__field[__field_idx] = 0;\n-\t\n-\t_M_parameters[__param]._M_print_field(this, __field);\t\t  \n+\n+\t_M_parameters[__param]._M_print_field(this, __field);\n+      }\n+  }\n+\n+  void\n+  _Error_formatter::_M_print_type(const type_info* __info,\n+\t\t\t\t  const char* __unknown_name) const\n+  {\n+    if (!__info)\n+      _M_print_word(__unknown_name);\n+    else\n+      {\n+\tint __status;\n+\tchar* __demangled_name =\n+\t  __cxxabiv1::__cxa_demangle(__info->name(), NULL, NULL, &__status);\n+\t_M_print_word(__status == 0 ? __demangled_name : __info->name());\n+\tfree(__demangled_name);\n       }\n   }\n \n@@ -947,7 +952,7 @@ namespace __gnu_debug\n   // Instantiations.\n   template\n     void\n-    _Error_formatter::_M_format_word(char*, int, const char*, \n+    _Error_formatter::_M_format_word(char*, int, const char*,\n \t\t\t\t     const void*) const;\n \n   template\n@@ -956,11 +961,11 @@ namespace __gnu_debug\n \n   template\n     void\n-    _Error_formatter::_M_format_word(char*, int, const char*, \n+    _Error_formatter::_M_format_word(char*, int, const char*,\n \t\t\t\t     std::size_t) const;\n \n   template\n     void\n-    _Error_formatter::_M_format_word(char*, int, const char*, \n+    _Error_formatter::_M_format_word(char*, int, const char*,\n \t\t\t\t     const char*) const;\n } // namespace __gnu_debug"}]}