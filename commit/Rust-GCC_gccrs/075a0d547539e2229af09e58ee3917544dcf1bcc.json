{"sha": "075a0d547539e2229af09e58ee3917544dcf1bcc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc1YTBkNTQ3NTM5ZTIyMjlhZjA5ZTU4ZWUzOTE3NTQ0ZGNmMWJjYw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-05-02T16:47:03Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-05-02T16:47:03Z"}, "message": "tree-ssa-uncprop.c (equiv_hash_elt, [...]): Use VEC instead of VARRAY.\n\n\t* tree-ssa-uncprop.c (equiv_hash_elt, remove_equivalence,\n\trecord_equiv, tree_ssa_uncprop, uncprop_into_successor_phis):\n\tUse VEC instead of VARRAY.\n\t(equiv_free): New.\n\nFrom-SVN: r99104", "tree": {"sha": "1d74b277b0be6680e162f88a3e3bfefbd9b70568", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d74b277b0be6680e162f88a3e3bfefbd9b70568"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/075a0d547539e2229af09e58ee3917544dcf1bcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/075a0d547539e2229af09e58ee3917544dcf1bcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/075a0d547539e2229af09e58ee3917544dcf1bcc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/075a0d547539e2229af09e58ee3917544dcf1bcc/comments", "author": null, "committer": null, "parents": [{"sha": "58646b77eddc64f8b2cb6041180c3680d85c1faf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58646b77eddc64f8b2cb6041180c3680d85c1faf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58646b77eddc64f8b2cb6041180c3680d85c1faf"}], "stats": {"total": 31, "additions": 23, "deletions": 8}, "files": [{"sha": "4a3b56e49ef332175c2d984a1ec88111b178374c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/075a0d547539e2229af09e58ee3917544dcf1bcc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/075a0d547539e2229af09e58ee3917544dcf1bcc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=075a0d547539e2229af09e58ee3917544dcf1bcc", "patch": "@@ -1,3 +1,10 @@\n+2005-05-02  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* tree-ssa-uncprop.c (equiv_hash_elt, remove_equivalence,\n+\trecord_equiv, tree_ssa_uncprop, uncprop_into_successor_phis):\n+\tUse VEC instead of VARRAY.\n+\t(equiv_free): New.\n+\n 2005-05-02  Paolo Bonzini  <bonzini@gnu.org>\n \n         * c-common.c (resolve_overloaded_builtin): Forward to target"}, {"sha": "a35131b12c2b598421e53052e49412734b9a9dda", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/075a0d547539e2229af09e58ee3917544dcf1bcc/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/075a0d547539e2229af09e58ee3917544dcf1bcc/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=075a0d547539e2229af09e58ee3917544dcf1bcc", "patch": "@@ -300,7 +300,7 @@ struct equiv_hash_elt\n   tree value;\n \n   /* List of SSA_NAMEs which have the same value/key.  */\n-  varray_type equivalences;\n+  VEC(tree,heap) *equivalences;\n };\n \n static void uncprop_initialize_block (struct dom_walk_data *, basic_block);\n@@ -325,6 +325,16 @@ equiv_eq (const void *p1, const void *p2)\n   return operand_equal_p (value1, value2, 0);\n }\n \n+/* Free an instance of equiv_hash_elt.  */\n+\n+static void\n+equiv_free (void *p)\n+{\n+  struct equiv_hash_elt *elt = (struct equiv_hash_elt *) p;\n+  VEC_free (tree, heap, elt->equivalences);\n+  free (elt);\n+}\n+\n /* Remove the most recently recorded equivalency for VALUE.  */\n \n static void\n@@ -339,7 +349,7 @@ remove_equivalence (tree value)\n   slot = htab_find_slot (equiv, &equiv_hash_elt, NO_INSERT);\n \n   equiv_hash_elt_p = (struct equiv_hash_elt *) *slot;\n-  VARRAY_POP (equiv_hash_elt_p->equivalences);\n+  VEC_pop (tree, equiv_hash_elt_p->equivalences);\n }\n \n /* Record EQUIVALENCE = VALUE into our hash table.  */\n@@ -363,9 +373,7 @@ record_equiv (tree value, tree equivalence)\n \n   equiv_hash_elt = (struct equiv_hash_elt *) *slot;\n   \n-  if (!equiv_hash_elt->equivalences)\n-    VARRAY_TREE_INIT (equiv_hash_elt->equivalences, 10, \"value equivs\");\n-  VARRAY_PUSH_TREE (equiv_hash_elt->equivalences, equivalence);\n+  VEC_safe_push (tree, heap, equiv_hash_elt->equivalences, equivalence);\n }\n \n /* Main driver for un-cprop.  */\n@@ -379,7 +387,7 @@ tree_ssa_uncprop (void)\n   associate_equivalences_with_edges ();\n \n   /* Create our global data structures.  */\n-  equiv = htab_create (1024, equiv_hash, equiv_eq, free);\n+  equiv = htab_create (1024, equiv_hash, equiv_eq, equiv_free);\n   equiv_stack = VEC_alloc (tree, heap, 2);\n \n   /* We're going to do a dominator walk, so ensure that we have\n@@ -508,9 +516,9 @@ uncprop_into_successor_phis (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \t\t then replace the value in the argument with its equivalent\n \t\t SSA_NAME.  Use the most recent equivalence as hopefully\n \t\t that results in shortest lifetimes.  */\n-\t      for (j = VARRAY_ACTIVE_SIZE (elt->equivalences) - 1; j >= 0; j--)\n+\t      for (j = VEC_length (tree, elt->equivalences) - 1; j >= 0; j--)\n \t\t{\n-\t\t  tree equiv = VARRAY_TREE (elt->equivalences, j);\n+\t\t  tree equiv = VEC_index (tree, elt->equivalences, j);\n \n \t\t  if (SSA_NAME_VAR (equiv) == SSA_NAME_VAR (PHI_RESULT (phi)))\n \t\t    {"}]}