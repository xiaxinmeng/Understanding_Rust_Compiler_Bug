{"sha": "729a212576ebc14125d4c8e33a5b13ba43eeadec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI5YTIxMjU3NmViYzE0MTI1ZDRjOGUzM2E1YjEzYmE0M2VlYWRlYw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-02-10T22:05:40Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-02-10T22:05:40Z"}, "message": "combine.c (make_extraction, [...]): Avoid warning on mixed-signedness conditionals.\n\n\t* combine.c (make_extraction, force_to_mode): Avoid warning on\n\tmixed-signedness conditionals.\n\t(make_field_assignment, nonzero_bits): Likewise.\n\t* expmed.c (store_fixed_bit_field): ALIGN arg now unsigned.\n\t(store_split_bit_field, extract_split_bit_field): Likewise.\n\t(extract_fixed_bit_field, store_bit_field,\n\t* expr.c: Change alignment to be unsigned everywhere.\n\t(move_by_pieces, store_constructor_field, store_constructor):\n\tAlignment parm is unsigned.\n\t(emit_block_move, emit_group_load, emit_group_store): Likewise.\n\t(clear_storage, emit_push_insn, compare_from_rtx): Likewise.\n\t(do_compare_rtx_and_jump): Likewise.\n\t(move_by_pieces_ninsns, clear_by_pieces): Likewise.\n\tCompare align with GET_MODE_ALIGNMENT.\n\t(expand_expr_unaligned): Pointer to alignment is pointer to unsigned.\n\t(get_inner_reference): Likewise.\n\t(copy_blkmode_from_reg, emit_push_insn): Remove unneeded casts.\n\t(expand_assignment): Local vars for alignment now unsigned.\n\t(store_constructor, store_field, expand_expr, do_jump): Likewise.\n\t(do_compare_and_jump): Likewise.\n\t(store_field): Call new function expr_align.\n\t* expr.h (emit_block_move, emit_group_load, emit_group_store):\n\tAlignment arg now unsigned.\n\t(clear_storage, emit_push_insn, compare_from_rtx): Likewise.\n\t(do_compare_rtx_and_jump, store_bit_field): Likewise.\n\t(extract_bit_field): Likewise.\n\t* fold-const.c (add_double): Add cast to eliminate signedness warning.\n\t* machmode.h (GET_MODE_ALIGNMENT): Result is unsigned.\n\t(get_best_mode): Alignment arg is unsigned.\n\t* rtl.h (move_by_pieces): Likewise.\n\t* store-layout.c (maximum_field_alignment, set_alignment):\n\tNow unsigned.\n\t(layout_decl): Alignment arg is now unsigned.\n\tRemove unneeded casts.\n\t(layout_record, layout_union, layout_type): Remove unneeded casts.\n\tLocal alignment variables now unsigned.\n\t(get_best_mode): Alignment arg now unsigned.\n\t* tree.c (expr_align): New function.\n\t* tree.h (expr_align): Likewise.\n\t(maximum_field_alignment, set_alignment): Now unsigned.\n\t(get_inner_reference): Alignment argument is now pointer to unsigned.\n\t* varasm.c (assemble_variable): Add cast to eliminate warning.\n\nFrom-SVN: r31904", "tree": {"sha": "6986eb3ff22851f6ba40b08e9a2247fb26755e79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6986eb3ff22851f6ba40b08e9a2247fb26755e79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/729a212576ebc14125d4c8e33a5b13ba43eeadec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/729a212576ebc14125d4c8e33a5b13ba43eeadec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/729a212576ebc14125d4c8e33a5b13ba43eeadec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/729a212576ebc14125d4c8e33a5b13ba43eeadec/comments", "author": null, "committer": null, "parents": [{"sha": "5e4900c7f4945f48d9660d2682bbbcce40ec9603", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e4900c7f4945f48d9660d2682bbbcce40ec9603", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e4900c7f4945f48d9660d2682bbbcce40ec9603"}], "stats": {"total": 380, "additions": 243, "deletions": 137}, "files": [{"sha": "705f84cb3ecc7b943ddd573a7baa77cad383ed7d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=729a212576ebc14125d4c8e33a5b13ba43eeadec", "patch": "@@ -1,3 +1,48 @@\n+Thu Feb 10 16:26:49 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* combine.c (make_extraction, force_to_mode): Avoid warning on\n+\tmixed-signedness conditionals.\n+\t(make_field_assignment, nonzero_bits): Likewise.\n+\t* expmed.c (store_fixed_bit_field): ALIGN arg now unsigned.\n+\t(store_split_bit_field, extract_split_bit_field): Likewise.\n+\t(extract_fixed_bit_field, store_bit_field, \n+\t* expr.c: Change alignment to be unsigned everywhere.\n+\t(move_by_pieces, store_constructor_field, store_constructor): \n+\tAlignment parm is unsigned.\n+\t(emit_block_move, emit_group_load, emit_group_store): Likewise.\n+\t(clear_storage, emit_push_insn, compare_from_rtx): Likewise.\n+\t(do_compare_rtx_and_jump): Likewise.\n+\t(move_by_pieces_ninsns, clear_by_pieces): Likewise.\n+\tCompare align with GET_MODE_ALIGNMENT.\n+\t(expand_expr_unaligned): Pointer to alignment is pointer to unsigned.\n+\t(get_inner_reference): Likewise.\n+\t(copy_blkmode_from_reg, emit_push_insn): Remove unneeded casts.\n+\t(expand_assignment): Local vars for alignment now unsigned.\n+\t(store_constructor, store_field, expand_expr, do_jump): Likewise.\n+\t(do_compare_and_jump): Likewise.\n+\t(store_field): Call new function expr_align.\n+\t* expr.h (emit_block_move, emit_group_load, emit_group_store):\n+\tAlignment arg now unsigned.\n+\t(clear_storage, emit_push_insn, compare_from_rtx): Likewise.\n+\t(do_compare_rtx_and_jump, store_bit_field): Likewise.\n+\t(extract_bit_field): Likewise.\n+\t* fold-const.c (add_double): Add cast to eliminate signedness warning.\n+\t* machmode.h (GET_MODE_ALIGNMENT): Result is unsigned.\n+\t(get_best_mode): Alignment arg is unsigned.\n+\t* rtl.h (move_by_pieces): Likewise.\n+\t* store-layout.c (maximum_field_alignment, set_alignment):\n+\tNow unsigned.\n+\t(layout_decl): Alignment arg is now unsigned.\n+\tRemove unneeded casts.\n+\t(layout_record, layout_union, layout_type): Remove unneeded casts.\n+\tLocal alignment variables now unsigned.\n+\t(get_best_mode): Alignment arg now unsigned.\n+\t* tree.c (expr_align): New function.\n+\t* tree.h (expr_align): Likewise.\n+\t(maximum_field_alignment, set_alignment): Now unsigned.\n+\t(get_inner_reference): Alignment argument is now pointer to unsigned.\n+\t* varasm.c (assemble_variable): Add cast to eliminate warning.\n+\n Thu Feb 10 12:56:47 2000  Jim Wilson  <wilson@cygnus.com>\n \n \t* expmed.c (store_bit_field): If op0 and fieldmode are the same size,"}, {"sha": "f6b88670310ce0bcc46e5885b145b8128a2d733b", "filename": "gcc/combine.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=729a212576ebc14125d4c8e33a5b13ba43eeadec", "patch": "@@ -5891,7 +5891,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \tnew = force_to_mode (inner, tmode,\n \t\t\t     len >= HOST_BITS_PER_WIDE_INT\n \t\t\t     ? GET_MODE_MASK (tmode)\n-\t\t\t     : ((HOST_WIDE_INT) 1 << len) - 1,\n+\t\t\t     : ((unsigned HOST_WIDE_INT) 1 << len) - 1,\n \t\t\t     NULL_RTX, 0);\n \n       /* If this extraction is going into the destination of a SET, \n@@ -6112,7 +6112,8 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t\t\t     pos_rtx\n \t\t\t     || len + orig_pos >= HOST_BITS_PER_WIDE_INT\n \t\t\t     ? GET_MODE_MASK (wanted_inner_mode)\n-\t\t\t     : (((HOST_WIDE_INT) 1 << len) - 1) << orig_pos,\n+\t\t\t     : ((((unsigned HOST_WIDE_INT) 1 << len) - 1)\n+\t\t\t\t<< orig_pos),\n \t\t\t     NULL_RTX, 0);\n     }\n \n@@ -6583,7 +6584,8 @@ force_to_mode (x, mode, mask, reg, just_select)\n   if (op_mode)\n     fuller_mask = (GET_MODE_BITSIZE (op_mode) >= HOST_BITS_PER_WIDE_INT\n \t\t   ? GET_MODE_MASK (op_mode)\n-\t\t   : ((HOST_WIDE_INT) 1 << (floor_log2 (mask) + 1)) - 1);\n+\t\t   : (((unsigned HOST_WIDE_INT) 1 << (floor_log2 (mask) + 1))\n+\t\t      - 1));\n   else\n     fuller_mask = ~ (HOST_WIDE_INT) 0;\n \n@@ -7525,7 +7527,7 @@ make_field_assignment (x)\n \t\t       mode,\n \t\t       GET_MODE_BITSIZE (mode) >= HOST_BITS_PER_WIDE_INT\n \t\t       ? GET_MODE_MASK (mode)\n-\t\t       : ((HOST_WIDE_INT) 1 << len) - 1,\n+\t\t       : ((unsigned HOST_WIDE_INT) 1 << len) - 1,\n \t\t       dest, 0);\n \n   return gen_rtx_combine (SET, VOIDmode, assign, src);\n@@ -8110,8 +8112,10 @@ nonzero_bits (x, mode)\n \t  /* If this is a typical RISC machine, we only have to worry\n \t     about the way loads are extended.  */\n \t  if (LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (x))) == SIGN_EXTEND\n-\t      ? (nonzero\n-\t\t & (1L << (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x))) - 1)))\n+\t      ? (((nonzero\n+\t\t   & (((unsigned HOST_WIDE_INT) 1\n+\t\t       << (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x))) - 1))))\n+\t\t  != 0))\n \t      : LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (x))) != ZERO_EXTEND)\n #endif\n \t    {"}, {"sha": "f9383758905f8bf4462c9dc28e903a8010699efe", "filename": "gcc/expmed.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=729a212576ebc14125d4c8e33a5b13ba43eeadec", "patch": "@@ -34,15 +34,19 @@ Boston, MA 02111-1307, USA.  */\n #include \"real.h\"\n #include \"recog.h\"\n \n-static void store_fixed_bit_field\tPARAMS ((rtx, int, int, int, rtx, int));\n-static void store_split_bit_field\tPARAMS ((rtx, int, int, rtx, int));\n+static void store_fixed_bit_field\tPARAMS ((rtx, int, int, int, rtx,\n+\t\t\t\t\t\t unsigned int));\n+static void store_split_bit_field\tPARAMS ((rtx, int, int, rtx,\n+\t\t\t\t\t\t unsigned int));\n static rtx extract_fixed_bit_field\tPARAMS ((enum machine_mode, rtx, int,\n-\t\t\t\t\t\t int, int, rtx, int, int));\n+\t\t\t\t\t\t int, int, rtx, int,\n+\t\t\t\t\t\t unsigned int));\n static rtx mask_rtx\t\t\tPARAMS ((enum machine_mode, int,\n \t\t\t\t\t\t int, int));\n static rtx lshift_value\t\t\tPARAMS ((enum machine_mode, rtx,\n \t\t\t\t\t\t int, int));\n-static rtx extract_split_bit_field\tPARAMS ((rtx, int, int, int, int));\n+static rtx extract_split_bit_field\tPARAMS ((rtx, int, int, int,\n+\t\t\t\t\t\t unsigned int));\n static void do_cmp_and_jump\t\tPARAMS ((rtx, rtx, enum rtx_code,\n \t\t\t\t\t\t enum machine_mode, rtx));\n \n@@ -224,7 +228,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n      int bitnum;\n      enum machine_mode fieldmode;\n      rtx value;\n-     int align;\n+     unsigned int align;\n      int total_size;\n {\n   int unit = (GET_CODE (str_rtx) == MEM) ? BITS_PER_UNIT : BITS_PER_WORD;\n@@ -508,7 +512,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n \n \t  if (bestmode == VOIDmode\n \t      || (SLOW_UNALIGNED_ACCESS (bestmode, align)\n-\t\t  && GET_MODE_SIZE (bestmode) > align))\n+\t\t  && GET_MODE_SIZE (bestmode) > (int) align))\n \t    goto insv_loses;\n \n \t  /* Adjust address to point to the containing unit of that mode.  */\n@@ -623,7 +627,7 @@ store_fixed_bit_field (op0, offset, bitsize, bitpos, value, struct_align)\n      register rtx op0;\n      register int offset, bitsize, bitpos;\n      register rtx value;\n-     int struct_align;\n+     unsigned int struct_align;\n {\n   register enum machine_mode mode;\n   int total_bits = BITS_PER_WORD;\n@@ -794,7 +798,7 @@ store_split_bit_field (op0, bitsize, bitpos, value, align)\n      rtx op0;\n      int bitsize, bitpos;\n      rtx value;\n-     int align;\n+     unsigned int align;\n {\n   int unit;\n   int bitsdone = 0;\n@@ -951,7 +955,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n      int unsignedp;\n      rtx target;\n      enum machine_mode mode, tmode;\n-     int align;\n+     unsigned int align;\n      int total_size;\n {\n   int unit = (GET_CODE (str_rtx) == MEM) ? BITS_PER_UNIT : BITS_PER_WORD;\n@@ -1391,7 +1395,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \n \t\t  if (bestmode == VOIDmode\n \t\t      || (SLOW_UNALIGNED_ACCESS (bestmode, align)\n-\t\t\t  && GET_MODE_SIZE (bestmode) > align))\n+\t\t\t  && GET_MODE_SIZE (bestmode) > (int) align))\n \t\t    goto extv_loses;\n \n \t\t  /* Compute offset as multiple of this unit,\n@@ -1530,7 +1534,7 @@ extract_fixed_bit_field (tmode, op0, offset, bitsize, bitpos,\n      register rtx op0, target;\n      register int offset, bitsize, bitpos;\n      int unsignedp;\n-     int align;\n+     unsigned int align;\n {\n   int total_bits = BITS_PER_WORD;\n   enum machine_mode mode;\n@@ -1748,7 +1752,8 @@ lshift_value (mode, value, bitpos, bitsize)\n static rtx\n extract_split_bit_field (op0, bitsize, bitpos, unsignedp, align)\n      rtx op0;\n-     int bitsize, bitpos, unsignedp, align;\n+     int bitsize, bitpos, unsignedp;\n+     unsigned int align;\n {\n   int unit;\n   int bitsdone = 0;"}, {"sha": "26e23f06a1566a9f575bbc25ad78526ab8388d68", "filename": "gcc/expr.c", "status": "modified", "additions": 54, "deletions": 58, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=729a212576ebc14125d4c8e33a5b13ba43eeadec", "patch": "@@ -132,21 +132,21 @@ extern struct obstack permanent_obstack;\n static rtx get_push_address\tPARAMS ((int));\n \n static rtx enqueue_insn\t\tPARAMS ((rtx, rtx));\n-static int move_by_pieces_ninsns PARAMS ((unsigned int, int));\n+static int move_by_pieces_ninsns PARAMS ((unsigned int, unsigned int));\n static void move_by_pieces_1\tPARAMS ((rtx (*) (rtx, ...), enum machine_mode,\n \t\t\t\t\t struct move_by_pieces *));\n-static void clear_by_pieces\tPARAMS ((rtx, int, int));\n+static void clear_by_pieces\tPARAMS ((rtx, int, unsigned int));\n static void clear_by_pieces_1\tPARAMS ((rtx (*) (rtx, ...),\n \t\t\t\t\t enum machine_mode,\n \t\t\t\t\t struct clear_by_pieces *));\n static int is_zeros_p\t\tPARAMS ((tree));\n static int mostly_zeros_p\tPARAMS ((tree));\n static void store_constructor_field PARAMS ((rtx, int, int, enum machine_mode,\n-\t\t\t\t\t     tree, tree, int, int));\n-static void store_constructor\tPARAMS ((tree, rtx, int, int, int));\n+\t\t\t\t\t     tree, tree, unsigned int, int));\n+static void store_constructor\tPARAMS ((tree, rtx, unsigned int, int, int));\n static rtx store_field\t\tPARAMS ((rtx, int, int, enum machine_mode,\n-\t\t\t\t\t tree, enum machine_mode, int, int,\n-\t\t\t\t\t int, int));\n+\t\t\t\t\t tree, enum machine_mode, int,\n+\t\t\t\t\t unsigned int, int, int));\n static enum memory_use_mode\n   get_memory_usage_from_modifier PARAMS ((enum expand_modifier));\n static tree save_noncopied_parts PARAMS ((tree, tree));\n@@ -155,7 +155,7 @@ static int safe_from_p\t\tPARAMS ((rtx, tree, int));\n static int fixed_type_p\t\tPARAMS ((tree));\n static rtx var_rtx\t\tPARAMS ((tree));\n static int readonly_fields_p\tPARAMS ((tree));\n-static rtx expand_expr_unaligned PARAMS ((tree, int *));\n+static rtx expand_expr_unaligned PARAMS ((tree, unsigned int *));\n static rtx expand_increment\tPARAMS ((tree, int, int));\n static void preexpand_calls\tPARAMS ((tree));\n static void do_jump_by_parts_greater PARAMS ((tree, int, rtx, rtx));\n@@ -1360,7 +1360,8 @@ convert_modes (mode, oldmode, x, unsignedp)\n void\n move_by_pieces (to, from, len, align)\n      rtx to, from;\n-     int len, align;\n+     int len;\n+     unsigned int align;\n {\n   struct move_by_pieces data;\n   rtx to_addr = XEXP (to, 0), from_addr = XEXP (from, 0);\n@@ -1455,7 +1456,7 @@ move_by_pieces (to, from, len, align)\n       icode = mov_optab->handlers[(int) mode].insn_code;\n       if (icode != CODE_FOR_nothing\n \t  && align >= MIN (BIGGEST_ALIGNMENT / BITS_PER_UNIT,\n-\t\t\t   GET_MODE_SIZE (mode)))\n+\t\t\t   (unsigned int) GET_MODE_SIZE (mode)))\n \tmove_by_pieces_1 (GEN_FCN (icode), mode, &data);\n \n       max_size = GET_MODE_SIZE (mode);\n@@ -1472,7 +1473,7 @@ move_by_pieces (to, from, len, align)\n static int\n move_by_pieces_ninsns (l, align)\n      unsigned int l;\n-     int align;\n+     unsigned int align;\n {\n   register int n_insns = 0;\n   int max_size = MOVE_MAX + 1;\n@@ -1496,8 +1497,7 @@ move_by_pieces_ninsns (l, align)\n \n       icode = mov_optab->handlers[(int) mode].insn_code;\n       if (icode != CODE_FOR_nothing\n-\t  && align >= MIN (BIGGEST_ALIGNMENT / BITS_PER_UNIT,\n-\t\t\t   GET_MODE_SIZE (mode)))\n+\t  && align >= GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT)\n \tn_insns += l / GET_MODE_SIZE (mode), l %= GET_MODE_SIZE (mode);\n \n       max_size = GET_MODE_SIZE (mode);\n@@ -1574,7 +1574,7 @@ rtx\n emit_block_move (x, y, size, align)\n      rtx x, y;\n      rtx size;\n-     int align;\n+     unsigned int align;\n {\n   rtx retval = 0;\n #ifdef TARGET_MEM_FUNCTIONS\n@@ -1883,7 +1883,8 @@ move_block_from_reg (regno, x, nregs, size)\n void\n emit_group_load (dst, orig_src, ssize, align)\n      rtx dst, orig_src;\n-     int align, ssize;\n+     unsigned int align;\n+     int ssize;\n {\n   rtx *tmps, src;\n   int start, i;\n@@ -1926,13 +1927,13 @@ emit_group_load (dst, orig_src, ssize, align)\n \t  shift = (bytelen - (ssize - bytepos)) * BITS_PER_UNIT;\n \t  bytelen = ssize - bytepos;\n \t  if (bytelen <= 0)\n-\t    abort();\n+\t    abort ();\n \t}\n \n       /* Optimize the access just a bit.  */\n       if (GET_CODE (src) == MEM\n-\t  && align*BITS_PER_UNIT >= GET_MODE_ALIGNMENT (mode)\n-\t  && bytepos*BITS_PER_UNIT % GET_MODE_ALIGNMENT (mode) == 0\n+\t  && align * BITS_PER_UNIT >= GET_MODE_ALIGNMENT (mode)\n+\t  && bytepos * BITS_PER_UNIT % GET_MODE_ALIGNMENT (mode) == 0\n \t  && bytelen == GET_MODE_SIZE (mode))\n \t{\n \t  tmps[i] = gen_reg_rtx (mode);\n@@ -1979,7 +1980,8 @@ emit_group_load (dst, orig_src, ssize, align)\n void\n emit_group_store (orig_dst, src, ssize, align)\n      rtx orig_dst, src;\n-     int ssize, align;\n+     int ssize;\n+     unsigned int align;\n {\n   rtx *tmps, dst;\n   int start, i;\n@@ -2063,21 +2065,18 @@ emit_group_store (orig_dst, src, ssize, align)\n \n       /* Optimize the access just a bit.  */\n       if (GET_CODE (dst) == MEM\n-\t  && align*BITS_PER_UNIT >= GET_MODE_ALIGNMENT (mode)\n-\t  && bytepos*BITS_PER_UNIT % GET_MODE_ALIGNMENT (mode) == 0\n+\t  && align * BITS_PER_UNIT >= GET_MODE_ALIGNMENT (mode)\n+\t  && bytepos * BITS_PER_UNIT % GET_MODE_ALIGNMENT (mode) == 0\n \t  && bytelen == GET_MODE_SIZE (mode))\n-\t{\n-\t  emit_move_insn (change_address (dst, mode,\n-\t\t\t\t\t  plus_constant (XEXP (dst, 0),\n-\t\t\t\t\t\t\t bytepos)),\n-\t\t\t  tmps[i]);\n-\t}\n+\temit_move_insn (change_address (dst, mode,\n+\t\t\t\t\tplus_constant (XEXP (dst, 0),\n+\t\t\t\t\t\t       bytepos)),\n+\t\t\ttmps[i]);\n       else\n-\t{\n-\t  store_bit_field (dst, bytelen*BITS_PER_UNIT, bytepos*BITS_PER_UNIT,\n+\tstore_bit_field (dst, bytelen * BITS_PER_UNIT, bytepos * BITS_PER_UNIT,\n \t\t\t   mode, tmps[i], align, ssize);\n-\t}\n     }\n+\n   emit_queue();\n \n   /* Copy from the pseudo into the (probable) hard reg.  */\n@@ -2092,18 +2091,17 @@ emit_group_store (orig_dst, src, ssize, align)\n    The primary purpose of this routine is to handle functions\n    that return BLKmode structures in registers.  Some machines\n    (the PA for example) want to return all small structures\n-   in registers regardless of the structure's alignment.\n-  */\n+   in registers regardless of the structure's alignment. */\n \n rtx\n-copy_blkmode_from_reg(tgtblk,srcreg,type)\n+copy_blkmode_from_reg (tgtblk,srcreg,type)\n      rtx tgtblk;\n      rtx srcreg;\n      tree type;\n {\n       int bytes = int_size_in_bytes (type);\n       rtx src = NULL, dst = NULL;\n-      int bitsize = MIN (TYPE_ALIGN (type), (unsigned int) BITS_PER_WORD);\n+      int bitsize = MIN (TYPE_ALIGN (type), BITS_PER_WORD);\n       int bitpos, xbitpos, big_endian_correction = 0;\n       \n       if (tgtblk == 0)\n@@ -2232,7 +2230,8 @@ use_group_regs (call_fusage, regs)\n static void\n clear_by_pieces (to, len, align)\n      rtx to;\n-     int len, align;\n+     int len;\n+     unsigned int align;\n {\n   struct clear_by_pieces data;\n   rtx to_addr = XEXP (to, 0);\n@@ -2302,8 +2301,7 @@ clear_by_pieces (to, len, align)\n \n       icode = mov_optab->handlers[(int) mode].insn_code;\n       if (icode != CODE_FOR_nothing\n-\t  && align >= MIN (BIGGEST_ALIGNMENT / BITS_PER_UNIT,\n-\t\t\t   GET_MODE_SIZE (mode)))\n+\t  && align >= GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT)\n \tclear_by_pieces_1 (GEN_FCN (icode), mode, &data);\n \n       max_size = GET_MODE_SIZE (mode);\n@@ -2361,7 +2359,7 @@ rtx\n clear_storage (object, size, align)\n      rtx object;\n      rtx size;\n-     int align;\n+     unsigned int align;\n {\n #ifdef TARGET_MEM_FUNCTIONS\n   static tree fn;\n@@ -2905,7 +2903,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n      enum machine_mode mode;\n      tree type;\n      rtx size;\n-     int align;\n+     unsigned int align;\n      int partial;\n      rtx reg;\n      int extra;\n@@ -3066,7 +3064,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \n \t  /* TEMP is the address of the block.  Copy the data there.  */\n \t  if (GET_CODE (size) == CONST_INT\n-\t      && (MOVE_BY_PIECES_P ((unsigned) INTVAL (size), align)))\n+\t      && MOVE_BY_PIECES_P ((unsigned) INTVAL (size), align))\n \t    {\n \t      move_by_pieces (gen_rtx_MEM (BLKmode, temp), xinner,\n \t\t\t      INTVAL (size), align);\n@@ -3328,7 +3326,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n       int unsignedp;\n       int volatilep = 0;\n       tree tem;\n-      int alignment;\n+      unsigned int alignment;\n \n       push_temp_slots ();\n       tem = get_inner_reference (to, &bitsize, &bitpos, &offset, &mode1,\n@@ -4053,7 +4051,7 @@ store_constructor_field (target, bitsize, bitpos,\n      int bitsize, bitpos;\n      enum machine_mode mode;\n      tree exp, type;\n-     int align;\n+     unsigned int align;\n      int cleared;\n {\n   if (TREE_CODE (exp) == CONSTRUCTOR\n@@ -4092,7 +4090,7 @@ static void\n store_constructor (exp, target, align, cleared, size)\n      tree exp;\n      rtx target;\n-     int align;\n+     unsigned int align;\n      int cleared;\n      int size;\n {\n@@ -4361,7 +4359,7 @@ store_constructor (exp, target, align, cleared, size)\n \t  int bitpos;\n \t  int unsignedp;\n \t  tree value = TREE_VALUE (elt);\n-\t  int align = TYPE_ALIGN (TREE_TYPE (value));\n+\t  unsigned int align = TYPE_ALIGN (TREE_TYPE (value));\n \t  tree index = TREE_PURPOSE (elt);\n \t  rtx xtarget = target;\n \n@@ -4711,7 +4709,7 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n      tree exp;\n      enum machine_mode value_mode;\n      int unsignedp;\n-     int align;\n+     unsigned int align;\n      int total_size;\n      int alias_set;\n {\n@@ -4809,6 +4807,8 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n \t boundary.  If so, we simply do a block copy.  */\n       if (GET_MODE (target) == BLKmode && GET_MODE (temp) == BLKmode)\n \t{\n+\t  unsigned int exp_align = expr_align (exp) / BITS_PER_UNIT;\n+\n \t  if (GET_CODE (target) != MEM || GET_CODE (temp) != MEM\n \t      || bitpos % BITS_PER_UNIT != 0)\n \t    abort ();\n@@ -4817,12 +4817,8 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n \t\t\t\t   plus_constant (XEXP (target, 0),\n \t\t\t\t\t\tbitpos / BITS_PER_UNIT));\n \n-\t  /* Make sure that ALIGN is no stricter than the alignment of\n-\t     EXP.  */\n-\t  if (TREE_CODE (exp) == VAR_DECL)\n-\t    align = MIN (DECL_ALIGN (exp) / BITS_PER_UNIT, align);\n-\t  else\n-\t    align = MIN (TYPE_ALIGN (TREE_TYPE (exp)) / BITS_PER_UNIT, align);\n+\t  /* Make sure that ALIGN is no stricter than the alignment of EXP.  */\n+\t  align = MIN (exp_align, align);\n \n \t  /* Find an alignment that is consistent with the bit position.  */\n \t  while ((bitpos % (align * BITS_PER_UNIT)) != 0)\n@@ -4928,7 +4924,7 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n      enum machine_mode *pmode;\n      int *punsignedp;\n      int *pvolatilep;\n-     int *palignment;\n+     unsigned int *palignment;\n {\n   tree orig_exp = exp;\n   tree size_tree = 0;\n@@ -6610,7 +6606,7 @@ expand_expr (exp, target, tmode, modifier)\n \tint bitpos;\n \ttree offset;\n \tint volatilep = 0;\n-\tint alignment;\n+\tunsigned int alignment;\n \ttree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n \t\t\t\t\t&mode1, &unsignedp, &volatilep,\n \t\t\t\t\t&alignment);\n@@ -8477,7 +8473,7 @@ expand_expr (exp, target, tmode, modifier)\n static rtx\n expand_expr_unaligned (exp, palign)\n      register tree exp;\n-     int *palign;\n+     unsigned int *palign;\n {\n   register rtx op0;\n   tree type = TREE_TYPE (exp);\n@@ -8607,7 +8603,7 @@ expand_expr_unaligned (exp, palign)\n \tint bitpos;\n \ttree offset;\n \tint volatilep = 0;\n-\tint alignment;\n+\tunsigned int alignment;\n \tint unsignedp;\n \ttree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n \t\t\t\t\t&mode1, &unsignedp, &volatilep,\n@@ -9340,7 +9336,7 @@ do_jump (exp, if_false_label, if_true_label)\n \ttree type;\n \ttree offset;\n \tint volatilep = 0;\n-\tint alignment;\n+\tunsigned int alignment;\n \n \t/* Get description of this reference.  We don't actually care\n \t   about the underlying object here.  */\n@@ -9804,7 +9800,7 @@ compare_from_rtx (op0, op1, code, unsignedp, mode, size, align)\n      int unsignedp;\n      enum machine_mode mode;\n      rtx size;\n-     int align;\n+     unsigned int align;\n {\n   rtx tem;\n \n@@ -9876,7 +9872,7 @@ do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode, size, align,\n      int unsignedp;\n      enum machine_mode mode;\n      rtx size;\n-     int align;\n+     unsigned int align;\n      rtx if_false_label, if_true_label;\n {\n   rtx tem;\n@@ -9981,7 +9977,7 @@ do_compare_and_jump (exp, signed_code, unsigned_code, if_false_label,\n      enum rtx_code signed_code, unsigned_code;\n      rtx if_false_label, if_true_label;\n {\n-  int align0, align1;\n+  unsigned int align0, align1;\n   register rtx op0, op1;\n   register tree type;\n   register enum machine_mode mode;"}, {"sha": "ef8622a620d33162aa4343fde819c5555c60125c", "filename": "gcc/expr.h", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=729a212576ebc14125d4c8e33a5b13ba43eeadec", "patch": "@@ -942,10 +942,11 @@ extern void convert_move PARAMS ((rtx, rtx, int));\n extern rtx convert_to_mode PARAMS ((enum machine_mode, rtx, int));\n \n /* Convert an rtx to MODE from OLDMODE and return the result.  */\n-extern rtx convert_modes PARAMS ((enum machine_mode, enum machine_mode, rtx, int));\n+extern rtx convert_modes PARAMS ((enum machine_mode, enum machine_mode,\n+\t\t\t\t  rtx, int));\n \n /* Emit code to move a block Y to a block X.  */\n-extern rtx emit_block_move PARAMS ((rtx, rtx, rtx, int));\n+extern rtx emit_block_move PARAMS ((rtx, rtx, rtx, unsigned int));\n \n /* Copy all or part of a value X into registers starting at REGNO.\n    The number of registers to be filled is NREGS.  */\n@@ -957,10 +958,11 @@ extern void move_block_from_reg PARAMS ((int, rtx, int, int));\n \n /* Load a BLKmode value into non-consecutive registers represented by a\n    PARALLEL.  */\n-extern void emit_group_load PARAMS ((rtx, rtx, int, int));\n+extern void emit_group_load PARAMS ((rtx, rtx, int, unsigned int));\n+\n /* Store a BLKmode value from non-consecutive registers represented by a\n    PARALLEL.  */\n-extern void emit_group_store PARAMS ((rtx, rtx, int, int));\n+extern void emit_group_store PARAMS ((rtx, rtx, int, unsigned int));\n \n #ifdef TREE_CODE\n /* Copy BLKmode object from a set of registers. */\n@@ -969,16 +971,18 @@ extern rtx copy_blkmode_from_reg PARAMS ((rtx,rtx,tree));\n \n /* Mark REG as holding a parameter for the next CALL_INSN.  */\n extern void use_reg PARAMS ((rtx *, rtx));\n+\n /* Mark NREGS consecutive regs, starting at REGNO, as holding parameters\n    for the next CALL_INSN.  */\n extern void use_regs PARAMS ((rtx *, int, int));\n+\n /* Mark a PARALLEL as holding a parameter for the next CALL_INSN.  */\n extern void use_group_regs PARAMS ((rtx *, rtx));\n \n /* Write zeros through the storage of OBJECT.\n    If OBJECT has BLKmode, SIZE is its length in bytes and ALIGN is its\n    alignment.  */\n-extern rtx clear_storage PARAMS ((rtx, rtx, int));\n+extern rtx clear_storage PARAMS ((rtx, rtx, unsigned int));\n \n /* Emit insns to set X from Y.  */\n extern rtx emit_move_insn PARAMS ((rtx, rtx));\n@@ -995,8 +999,9 @@ extern rtx gen_push_operand PARAMS ((void));\n \n #ifdef TREE_CODE\n /* Generate code to push something onto the stack, given its mode and type.  */\n-extern void emit_push_insn PARAMS ((rtx, enum machine_mode, tree, rtx, int,\n-\t\t\t\t    int, rtx, int, rtx, rtx, int, rtx));\n+extern void emit_push_insn PARAMS ((rtx, enum machine_mode, tree, rtx,\n+\t\t\t\t    unsigned int, int, rtx, int, rtx, rtx,\n+\t\t\t\t    int, rtx));\n \n /* Emit library call.  */\n extern void emit_library_call PARAMS ((rtx orgfun, int no_queue,\n@@ -1056,10 +1061,10 @@ extern void do_jump PARAMS ((tree, rtx, rtx));\n \n /* Generate rtl to compare two rtx's, will call emit_cmp_insn.  */\n extern rtx compare_from_rtx PARAMS ((rtx, rtx, enum rtx_code, int,\n-\t\t\t\t     enum machine_mode, rtx, int));\n+\t\t\t\t     enum machine_mode, rtx, unsigned int));\n extern void do_compare_rtx_and_jump PARAMS ((rtx, rtx, enum rtx_code, int,\n-\t\t\t\t\t     enum machine_mode, rtx, int,\n-\t\t\t\t\t     rtx, rtx));\n+\t\t\t\t\t     enum machine_mode, rtx,\n+\t\t\t\t\t     unsigned int, rtx, rtx));\n \n /* Generate a tablejump instruction (used for switch statements).  */\n extern void do_tablejump PARAMS ((rtx, enum machine_mode, rtx, rtx, rtx));\n@@ -1193,8 +1198,11 @@ extern rtx hard_libcall_value PARAMS ((enum machine_mode));\n    of STACK_BOUNDARY / BITS_PER_UNIT.  */\n extern rtx round_push PARAMS ((rtx));\n \n-extern rtx store_bit_field PARAMS ((rtx, int, int, enum machine_mode, rtx, int, int));\n-extern rtx extract_bit_field PARAMS ((rtx, int, int, int, rtx, enum machine_mode, enum machine_mode, int, int));\n+extern rtx store_bit_field PARAMS ((rtx, int, int, enum machine_mode, rtx,\n+\t\t\t\t    unsigned int, int));\n+extern rtx extract_bit_field PARAMS ((rtx, int, int, int, rtx,\n+\t\t\t\t      enum machine_mode, enum machine_mode,\n+\t\t\t\t      unsigned int, int));\n extern rtx expand_mult PARAMS ((enum machine_mode, rtx, rtx, rtx, int));\n extern rtx expand_mult_add PARAMS ((rtx, rtx, rtx, rtx,enum machine_mode, int));\n extern rtx expand_mult_highpart_adjust PARAMS ((enum machine_mode, rtx, rtx, rtx, rtx, int));"}, {"sha": "e98a7f709e61c9a982aa242c7b8fe40b0c29219e", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=729a212576ebc14125d4c8e33a5b13ba43eeadec", "patch": "@@ -251,7 +251,7 @@ add_double (l1, h1, l2, h2, lv, hv)\n   HOST_WIDE_INT l, h;\n \n   l = l1 + l2;\n-  h = h1 + h2 + ((unsigned HOST_WIDE_INT) l < l1);\n+  h = h1 + h2 + ((unsigned HOST_WIDE_INT) l < (unsigned HOST_WIDE_INT) l1);\n \n   *lv = l;\n   *hv = h;"}, {"sha": "1f2fb2bbd09f8f977dc0b95797ec61aec2125d75", "filename": "gcc/machmode.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=729a212576ebc14125d4c8e33a5b13ba43eeadec", "patch": "@@ -120,13 +120,14 @@ extern enum machine_mode int_mode_for_mode PARAMS ((enum machine_mode));\n \n /* Find the best mode to use to access a bit field.  */\n \n-extern enum machine_mode get_best_mode PARAMS ((int, int, int, enum machine_mode, int));\n+extern enum machine_mode get_best_mode PARAMS ((int, int, unsigned int,\n+\t\t\t\t\t\tenum machine_mode, int));\n \n /* Determine alignment, 1<=result<=BIGGEST_ALIGNMENT.  */\n \n #define GET_MODE_ALIGNMENT(MODE)   \\\n-  MIN (BIGGEST_ALIGNMENT, \t   \\\n-       MAX (1, (GET_MODE_UNIT_SIZE (MODE) * BITS_PER_UNIT)))\n+  (unsigned int) MIN (BIGGEST_ALIGNMENT, \t   \\\n+\t\t      MAX (1, (GET_MODE_UNIT_SIZE (MODE) * BITS_PER_UNIT)))\n \n /* For each class, get the narrowest mode in that class.  */\n "}, {"sha": "f95b04bf61d34a0aef7bdb0b8847db89e5e73aa7", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=729a212576ebc14125d4c8e33a5b13ba43eeadec", "patch": "@@ -1524,7 +1524,7 @@ extern int preserve_subexpressions_p\tPARAMS ((void));\n \n /* In expr.c */\n extern void init_expr_once\t\tPARAMS ((void));\n-extern void move_by_pieces\t\tPARAMS ((rtx, rtx, int, int));\n+extern void move_by_pieces\t\tPARAMS ((rtx, rtx, int, unsigned int));\n \n \n /* In stupid.c */"}, {"sha": "707d0a078f43cdee54e6857f92690ad6d11c8f0a", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=729a212576ebc14125d4c8e33a5b13ba43eeadec", "patch": "@@ -37,11 +37,11 @@ struct sizetype_tab sizetype_tab;\n \n /* If nonzero, this is an upper limit on alignment of structure fields.\n    The value is measured in bits.  */\n-int maximum_field_alignment;\n+unsigned int maximum_field_alignment;\n \n /* If non-zero, the alignment of a bitstring or (power-)set value, in bits.\n    May be overridden by front-ends.  */\n-int set_alignment = 0;\n+unsigned int set_alignment = 0;\n \n static tree layout_record\tPARAMS ((tree));\n static void layout_union\tPARAMS ((tree));\n@@ -241,7 +241,7 @@ round_up (value, divisor)\n void\n layout_decl (decl, known_align)\n      tree decl;\n-     unsigned known_align;\n+     unsigned int known_align;\n {\n   register tree type = TREE_TYPE (decl);\n   register enum tree_code code = TREE_CODE (decl);\n@@ -289,8 +289,7 @@ layout_decl (decl, known_align)\n     {\n       DECL_BIT_FIELD_TYPE (decl) = DECL_BIT_FIELD (decl) ? type : 0;\n       if (maximum_field_alignment != 0)\n-\tDECL_ALIGN (decl) = MIN (DECL_ALIGN (decl),\n-\t\t\t\t (unsigned)maximum_field_alignment);\n+\tDECL_ALIGN (decl) = MIN (DECL_ALIGN (decl), maximum_field_alignment);\n       else if (DECL_PACKED (decl))\n \tDECL_ALIGN (decl) = MIN (DECL_ALIGN (decl), BITS_PER_UNIT);\n     }\n@@ -306,7 +305,7 @@ layout_decl (decl, known_align)\n       if (xmode != BLKmode\n \t  && known_align % GET_MODE_ALIGNMENT (xmode) == 0)\n \t{\n-\t  DECL_ALIGN (decl) = MAX ((unsigned) GET_MODE_ALIGNMENT (xmode),\n+\t  DECL_ALIGN (decl) = MAX (GET_MODE_ALIGNMENT (xmode),\n \t\t\t\t   DECL_ALIGN (decl));\n \t  DECL_MODE (decl) = xmode;\n \t  DECL_SIZE (decl) = bitsize_int (GET_MODE_BITSIZE (xmode), 0);\n@@ -346,20 +345,20 @@ layout_record (rec)\n      tree rec;\n {\n   register tree field;\n-  unsigned record_align = MAX (BITS_PER_UNIT, TYPE_ALIGN (rec));\n-  unsigned unpacked_align = record_align;\n+  unsigned int record_align = MAX (BITS_PER_UNIT, TYPE_ALIGN (rec));\n+  unsigned int unpacked_align = record_align;\n   /* These must be laid out *after* the record is.  */\n   tree pending_statics = NULL_TREE;\n   /* Record size so far is CONST_SIZE + VAR_SIZE bits,\n      where CONST_SIZE is an integer\n      and VAR_SIZE is a tree expression.\n      If VAR_SIZE is null, the size is just CONST_SIZE.\n      Naturally we try to avoid using VAR_SIZE.  */\n-  register HOST_WIDE_INT const_size = 0;\n-  register tree var_size = 0;\n+  HOST_WIDE_INT const_size = 0;\n+  tree var_size = 0;\n   /* Once we start using VAR_SIZE, this is the maximum alignment\n      that we know VAR_SIZE has.  */\n-  register int var_align = BITS_PER_UNIT;\n+  unsigned int var_align = BITS_PER_UNIT;\n   int packed_maybe_necessary = 0;\n \n #ifdef STRUCTURE_SIZE_BOUNDARY\n@@ -370,8 +369,8 @@ layout_record (rec)\n \n   for (field = TYPE_FIELDS (rec); field; field = TREE_CHAIN (field))\n     {\n-      register int known_align = var_size ? var_align : const_size;\n-      register int desired_align = 0;\n+      unsigned int known_align = var_size ? var_align : const_size;\n+      unsigned int desired_align = 0;\n       tree type = TREE_TYPE (field);\n \n       /* If FIELD is static, then treat it like a separate variable,\n@@ -422,37 +421,37 @@ layout_record (rec)\n \t     It does, however, affect the alignment of the next field\n \t     within the structure.  */\n \t  if (! integer_zerop (DECL_SIZE (field)))\n-\t    record_align = MAX ((int)record_align, desired_align);\n+\t    record_align = MAX (record_align, desired_align);\n \t  else if (! DECL_PACKED (field))\n \t    desired_align = TYPE_ALIGN (type);\n \t  /* A named bit field of declared type `int'\n \t     forces the entire structure to have `int' alignment.  */\n \t  if (DECL_NAME (field) != 0)\n \t    {\n-\t      int type_align = TYPE_ALIGN (type);\n+\t      unsigned int type_align = TYPE_ALIGN (type);\n+\n \t      if (maximum_field_alignment != 0)\n \t\ttype_align = MIN (type_align, maximum_field_alignment);\n \t      else if (DECL_PACKED (field))\n \t\ttype_align = MIN (type_align, BITS_PER_UNIT);\n \n-\t      record_align = MAX ((int) record_align, type_align);\n+\t      record_align = MAX (record_align, type_align);\n \t      if (warn_packed)\n \t\tunpacked_align = MAX (unpacked_align, TYPE_ALIGN (type));\n \t    }\n \t}\n       else\n #endif\n \t{\n-\t  record_align = MAX ((int) record_align, desired_align);\n+\t  record_align = MAX (record_align, desired_align);\n \t  if (warn_packed)\n \t    unpacked_align = MAX (unpacked_align, TYPE_ALIGN (type));\n \t}\n \n       if (warn_packed && DECL_PACKED (field))\n \t{\n \t  if (const_size % TYPE_ALIGN (type) == 0\n-\t      || (var_align % TYPE_ALIGN (type) == 0\n-\t\t  && var_size != NULL_TREE))\n+\t      || (var_align % TYPE_ALIGN (type) == 0 && var_size != NULL_TREE))\n \t    {\n \t      if (TYPE_ALIGN (type) > desired_align)\n \t\t{\n@@ -471,17 +470,15 @@ layout_record (rec)\n \t own alignment?  */\n \n       if (const_size % desired_align != 0\n-\t  || (var_align % desired_align != 0\n-\t      && var_size != NULL_TREE))\n+\t  || (var_align % desired_align != 0 && var_size != NULL_TREE))\n \t{\n \t  /* No, we need to skip space before this field.\n \t     Bump the cumulative size to multiple of field alignment.  */\n \n \t  if (warn_padded)\n \t    warning_with_decl (field, \"padding struct to align `%s'\");\n \n-\t  if (var_size == NULL_TREE\n-\t      || var_align % desired_align == 0)\n+\t  if (var_size == NULL_TREE || var_align % desired_align == 0)\n \t    const_size\n \t      = CEIL (const_size, desired_align) * desired_align;\n \t  else\n@@ -504,7 +501,7 @@ layout_record (rec)\n \t  && maximum_field_alignment == 0\n \t  && !integer_zerop (DECL_SIZE (field)))\n \t{\n-\t  int type_align = TYPE_ALIGN (type);\n+\t  unsigned int type_align = TYPE_ALIGN (type);\n \t  register tree dsize = DECL_SIZE (field);\n \t  int field_size = TREE_INT_CST_LOW (dsize);\n \n@@ -527,7 +524,7 @@ layout_record (rec)\n \t  && !DECL_PACKED (field)\n \t  && !integer_zerop (DECL_SIZE (field)))\n \t{\n-\t  int type_align = TYPE_ALIGN (type);\n+\t  unsigned int type_align = TYPE_ALIGN (type);\n \t  register tree dsize = DECL_SIZE (field);\n \t  int field_size = TREE_INT_CST_LOW (dsize);\n \n@@ -598,9 +595,7 @@ layout_record (rec)\n      Round it up to a multiple of the record's alignment.  */\n \n   if (var_size == NULL_TREE)\n-    {\n-      TYPE_SIZE (rec) = bitsize_int (const_size, 0L);\n-    }\n+    TYPE_SIZE (rec) = bitsize_int (const_size, 0L);\n   else\n     {\n       if (const_size)\n@@ -623,12 +618,14 @@ layout_record (rec)\n   \n   {\n     tree unpadded_size = TYPE_SIZE (rec);\n+\n #ifdef ROUND_TYPE_SIZE\n     TYPE_SIZE (rec) = ROUND_TYPE_SIZE (rec, TYPE_SIZE (rec), TYPE_ALIGN (rec));\n #else\n     /* Round the size up to be a multiple of the required alignment */\n     TYPE_SIZE (rec) = round_up (TYPE_SIZE (rec), TYPE_ALIGN (rec));\n #endif\n+\n     if (warn_padded && var_size == NULL_TREE\n \t&& simple_cst_equal (unpadded_size, TYPE_SIZE (rec)) == 0)\n       warning (\"padding struct size to alignment boundary\");\n@@ -638,6 +635,7 @@ layout_record (rec)\n       && var_size == NULL_TREE)\n     {\n       tree unpacked_size;\n+\n       TYPE_PACKED (rec) = 0;\n #ifdef ROUND_TYPE_ALIGN\n       unpacked_align\n@@ -650,11 +648,13 @@ layout_record (rec)\n #else\n       unpacked_size = round_up (TYPE_SIZE (rec), unpacked_align);\n #endif\n+\n       if (simple_cst_equal (unpacked_size, TYPE_SIZE (rec)))\n \t{\n \t  if (TYPE_NAME (rec))\n \t    {\n \t      char *name;\n+\n \t      if (TREE_CODE (TYPE_NAME (rec)) == IDENTIFIER_NODE)\n \t\tname = IDENTIFIER_POINTER (TYPE_NAME (rec));\n \t      else\n@@ -689,7 +689,7 @@ layout_union (rec)\n      tree rec;\n {\n   register tree field;\n-  unsigned union_align = BITS_PER_UNIT;\n+  unsigned int union_align = BITS_PER_UNIT;\n \n   /* The size of the union, based on the fields scanned so far,\n      is max (CONST_SIZE, VAR_SIZE).\n@@ -1111,9 +1111,11 @@ layout_type (type)\n \t     then stick with BLKmode.  */\n \t  && (! STRICT_ALIGNMENT\n \t      || TYPE_ALIGN (type) >= BIGGEST_ALIGNMENT\n-\t      || (int)TYPE_ALIGN (type) >= TREE_INT_CST_LOW (TYPE_SIZE (type))))\n+\t      || ((int) TYPE_ALIGN (type)\n+\t\t  >= TREE_INT_CST_LOW (TYPE_SIZE (type)))))\n \t{\n \t  tree field;\n+\n \t  /* A union which has any BLKmode members must itself be BLKmode;\n \t     it can't go in a register.\n \t     Unless the member is BLKmode only because it isn't aligned.  */\n@@ -1144,16 +1146,19 @@ layout_type (type)\n #ifndef SET_WORD_SIZE\n #define SET_WORD_SIZE BITS_PER_WORD\n #endif\n-\t  int alignment = set_alignment ? set_alignment : SET_WORD_SIZE;\n+\t  unsigned int alignment\n+\t    = set_alignment ? set_alignment : SET_WORD_SIZE;\n \t  int size_in_bits\n \t    = (TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))\n \t       - TREE_INT_CST_LOW (TYPE_MIN_VALUE (TYPE_DOMAIN (type))) + 1);\n \t  int rounded_size\n \t    = ((size_in_bits + alignment - 1) / alignment) * alignment;\n-\t  if (rounded_size > alignment)\n+\n+\t  if (rounded_size > (int) alignment)\n \t    TYPE_MODE (type) = BLKmode;\n \t  else\n \t    TYPE_MODE (type) = mode_for_size (alignment, MODE_INT, 1);\n+\n \t  TYPE_SIZE (type) = bitsize_int (rounded_size, 0L);\n \t  TYPE_SIZE_UNIT (type) = size_int (rounded_size / BITS_PER_UNIT);\n \t  TYPE_ALIGN (type) = alignment;\n@@ -1170,7 +1175,7 @@ layout_type (type)\n \n     default:\n       abort ();\n-    } /* end switch */\n+    }\n \n   /* Normally, use the alignment corresponding to the mode chosen.\n      However, where strict alignment is not required, avoid\n@@ -1224,7 +1229,7 @@ layout_type (type)\n       /* Record layout info of this variant.  */\n       tree size = TYPE_SIZE (type);\n       tree size_unit = TYPE_SIZE_UNIT (type);\n-      int align = TYPE_ALIGN (type);\n+      unsigned int align = TYPE_ALIGN (type);\n       enum machine_mode mode = TYPE_MODE (type);\n \n       /* Copy it into all variants.  */\n@@ -1281,7 +1286,6 @@ make_signed_type (precision)\n     set_sizetype (type);\n \n   /* Lay out the type: set its alignment, size, etc.  */\n-\n   layout_type (type);\n   return type;\n }\n@@ -1386,7 +1390,6 @@ fixup_signed_type (type)\n   TREE_TYPE (TYPE_MAX_VALUE (type)) = type;\n \n   /* Lay out the type: set its alignment, size, etc.  */\n-\n   layout_type (type);\n }\n \n@@ -1413,7 +1416,6 @@ fixup_unsigned_type (type)\n   TREE_TYPE (TYPE_MAX_VALUE (type)) = type;\n \n   /* Lay out the type: set its alignment, size, etc.  */\n-\n   layout_type (type);\n }\n \f\n@@ -1435,7 +1437,7 @@ fixup_unsigned_type (type)\n enum machine_mode\n get_best_mode (bitsize, bitpos, align, largest_mode, volatilep)\n      int bitsize, bitpos;\n-     int align;\n+     unsigned int align;\n      enum machine_mode largest_mode;\n      int volatilep;\n {\n@@ -1459,7 +1461,7 @@ get_best_mode (bitsize, bitpos, align, largest_mode, volatilep)\n \t if the extra 4th byte is past the end of memory.\n \t (Though at least one Unix compiler ignores this problem:\n \t that on the Sequent 386 machine.  */\n-      || MIN (unit, BIGGEST_ALIGNMENT) > align\n+      || MIN (unit, BIGGEST_ALIGNMENT) > (int) align\n       || (largest_mode != VOIDmode && unit > GET_MODE_BITSIZE (largest_mode)))\n     return VOIDmode;\n \n@@ -1473,7 +1475,7 @@ get_best_mode (bitsize, bitpos, align, largest_mode, volatilep)\n \t  unit = GET_MODE_BITSIZE (tmode);\n \t  if (bitpos / unit == (bitpos + bitsize - 1) / unit\n \t      && unit <= BITS_PER_WORD\n-\t      && unit <= MIN (align, BIGGEST_ALIGNMENT)\n+\t      && unit <= (int) MIN (align, BIGGEST_ALIGNMENT)\n \t      && (largest_mode == VOIDmode\n \t\t  || unit <= GET_MODE_BITSIZE (largest_mode)))\n \t    wide_mode = tmode;"}, {"sha": "d0313c4c90bac96446f5b95d42c5b6a18698fb1c", "filename": "gcc/tree.c", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=729a212576ebc14125d4c8e33a5b13ba43eeadec", "patch": "@@ -2251,6 +2251,50 @@ int_size_in_bytes (type)\n \n   return TREE_INT_CST_LOW (t);\n }\n+\n+/* Return the strictest alignment, in bits, that  T is known to have.  */\n+\n+unsigned int\n+expr_align (t)\n+     tree t;\n+{\n+  unsigned int align0, align1;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case NOP_EXPR:  case CONVERT_EXPR:  case NON_LVALUE_EXPR:\n+      /* If we have conversions, we know that the alignment of the\n+\t object must meet each of the alignments of the types.  */\n+      align0 = expr_align (TREE_OPERAND (t, 0));\n+      align1 = TYPE_ALIGN (TREE_TYPE (t));\n+      return MAX (align0, align1);\n+\n+    case SAVE_EXPR:         case COMPOUND_EXPR:       case MODIFY_EXPR:\n+    case INIT_EXPR:         case TARGET_EXPR:         case WITH_CLEANUP_EXPR:\n+    case WITH_RECORD_EXPR:  case CLEANUP_POINT_EXPR:  case UNSAVE_EXPR:\n+      /* These don't change the alignment of an object.  */\n+      return expr_align (TREE_OPERAND (t, 0));\n+\n+    case COND_EXPR:\n+      /* The best we can do is say that the alignment is the least aligned\n+\t of the two arms.  */\n+      align0 = expr_align (TREE_OPERAND (t, 1));\n+      align1 = expr_align (TREE_OPERAND (t, 2));\n+      return MIN (align0, align1);\n+\n+    case FUNCTION_DECL:  case LABEL_DECL:  case CONST_DECL:\n+    case VAR_DECL:       case PARM_DECL:   case RESULT_DECL:\n+      if (DECL_ALIGN (t) != 0)\n+\treturn DECL_ALIGN (t);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Otherwise take the alignment from that of the type.  */\n+  return TYPE_ALIGN (TREE_TYPE (t));\n+}\n \f\n /* Return, as a tree node, the number of elements for TYPE (which is an\n    ARRAY_TYPE) minus one. This counts only elements of the top array.  */"}, {"sha": "b27f0e09dbfd447c41870274ae4954d42259d391", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=729a212576ebc14125d4c8e33a5b13ba43eeadec", "patch": "@@ -1766,6 +1766,7 @@ extern tree non_lvalue\t\t\tPARAMS ((tree));\n extern tree pedantic_non_lvalue\t\tPARAMS ((tree));\n \n extern tree convert\t\t\tPARAMS ((tree, tree));\n+extern unsigned int expr_align\t\tPARAMS ((tree));\n extern tree size_in_bytes\t\tPARAMS ((tree));\n extern HOST_WIDE_INT int_size_in_bytes\tPARAMS ((tree));\n extern tree size_binop\t\t\tPARAMS ((enum tree_code, tree, tree));\n@@ -1806,10 +1807,10 @@ extern struct sizetype_tab sizetype_tab;\n #define ubitsizetype sizetype_tab.xubitsizetype\n \n /* If nonzero, an upper limit on alignment of structure fields, in bits. */\n-extern int maximum_field_alignment;\n+extern unsigned int maximum_field_alignment;\n \n /* If non-zero, the alignment of a bitstring or (power-)set value, in bits. */\n-extern int set_alignment;\n+extern unsigned int set_alignment;\n \n /* Concatenate two lists (chains of TREE_LIST nodes) X and Y\n    by making the last node in X point to Y.\n@@ -1995,7 +1996,7 @@ extern tree maybe_build_cleanup\t\tPARAMS ((tree));\n \n extern tree get_inner_reference\t\tPARAMS ((tree, int *, int *, tree *,\n \t\t\t\t\t       enum machine_mode *, int *,\n-\t\t\t\t\t       int *, int *));\n+\t\t\t\t\t       int *, unsigned int *));\n \n /* Given a DECL or TYPE, return the scope in which it was declared, or\n    NUL_TREE if there is no containing scope.  */"}, {"sha": "76d91f71f2f28e3ac1f48bc6ec26851137e62c90", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729a212576ebc14125d4c8e33a5b13ba43eeadec/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=729a212576ebc14125d4c8e33a5b13ba43eeadec", "patch": "@@ -1511,7 +1511,7 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n \t\t * (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n       \n #if !defined(ASM_OUTPUT_ALIGNED_COMMON) && !defined(ASM_OUTPUT_ALIGNED_BSS)\n-      if ( (DECL_ALIGN (decl) / BITS_PER_UNIT) > rounded)\n+      if ((DECL_ALIGN (decl) / BITS_PER_UNIT) > (unsigned int) rounded)\n          warning_with_decl \n            (decl, \"requested alignment for %s is greater than implemented alignment of %d.\",rounded);\n #endif"}]}