{"sha": "726e2d544cdcb3e91ac2e0ced52bf7ef592b18f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI2ZTJkNTQ0Y2RjYjNlOTFhYzJlMGNlZDUyYmY3ZWY1OTJiMThmMw==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "1998-05-31T15:13:36Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-05-31T15:13:36Z"}, "message": "reload.c (find_reloads): Record the existing mode if operand_mode == VOIDmode before replacing a...\n\n        * reload.c (find_reloads): Record the existing mode if\n        operand_mode == VOIDmode before replacing a register with\n        a constant.\n        * i386.md (tstsi, tsthi, tstqi, tstsf, tstdf, tstxf): Set\n        i386_compare_op1 to const0_rtx for the benefit of the\n        conditional move patterns.\n        (movsicc, movhicc, movsfcc, movdfcc, movxfcc, movdicc): Rewrite\n        based on suggestions from Jim Wilson.\n\nFrom-SVN: r20151", "tree": {"sha": "0c1c29104eec694d1022f9b5a1440651674fc445", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c1c29104eec694d1022f9b5a1440651674fc445"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/726e2d544cdcb3e91ac2e0ced52bf7ef592b18f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/726e2d544cdcb3e91ac2e0ced52bf7ef592b18f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/726e2d544cdcb3e91ac2e0ced52bf7ef592b18f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/726e2d544cdcb3e91ac2e0ced52bf7ef592b18f3/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7e5df0048fe26c97b06e9f7d8d4a2ea66e6d1ad6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e5df0048fe26c97b06e9f7d8d4a2ea66e6d1ad6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e5df0048fe26c97b06e9f7d8d4a2ea66e6d1ad6"}], "stats": {"total": 703, "additions": 550, "deletions": 153}, "files": [{"sha": "87f05f9e3b7fa365de832fcbaa1917ad7735e05d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726e2d544cdcb3e91ac2e0ced52bf7ef592b18f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726e2d544cdcb3e91ac2e0ced52bf7ef592b18f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=726e2d544cdcb3e91ac2e0ced52bf7ef592b18f3", "patch": "@@ -1,3 +1,14 @@\n+Sun May 31 16:11:41 1998  John Wehle  (john@feith.com)\n+\n+\t* reload.c (find_reloads): Record the existing mode if\n+\toperand_mode == VOIDmode before replacing a register with\n+\ta constant.\n+\t* i386.md (tstsi, tsthi, tstqi, tstsf, tstdf, tstxf): Set\n+\ti386_compare_op1 to const0_rtx for the benefit of the\n+\tconditional move patterns.\n+\t(movsicc, movhicc, movsfcc, movdfcc, movxfcc, movdicc): Rewrite\n+\tbased on suggestions from Jim Wilson.\n+\n Sun May 31 00:44:02 PDT 1998 Jeff Law  (law@cygnus.com)\n \n \t* version.c: Bump for snapshot."}, {"sha": "f060c05aee143f9ac905b12906212708d0761a2e", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 529, "deletions": 151, "changes": 680, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726e2d544cdcb3e91ac2e0ced52bf7ef592b18f3/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726e2d544cdcb3e91ac2e0ced52bf7ef592b18f3/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=726e2d544cdcb3e91ac2e0ced52bf7ef592b18f3", "patch": "@@ -164,6 +164,7 @@\n {\n   i386_compare_gen = gen_tstsi_1;\n   i386_compare_op0 = operands[0];\n+  i386_compare_op1 = const0_rtx;\n   DONE;\n }\")\n \n@@ -188,6 +189,7 @@\n {\n   i386_compare_gen = gen_tsthi_1;\n   i386_compare_op0 = operands[0];\n+  i386_compare_op1 = const0_rtx;\n   DONE;\n }\")\n \n@@ -212,6 +214,7 @@\n {\n   i386_compare_gen = gen_tstqi_1;\n   i386_compare_op0 = operands[0];\n+  i386_compare_op1 = const0_rtx;\n   DONE;\n }\")\n \n@@ -245,6 +248,7 @@\n {\n   i386_compare_gen = gen_tstsf_cc;\n   i386_compare_op0 = operands[0];\n+  i386_compare_op1 = const0_rtx;\n   DONE;\n }\")\n \n@@ -278,6 +282,7 @@\n {\n   i386_compare_gen = gen_tstdf_cc;\n   i386_compare_op0 = operands[0];\n+  i386_compare_op1 = const0_rtx;\n   DONE;\n }\")\n \n@@ -311,6 +316,7 @@\n {\n   i386_compare_gen = gen_tstxf_cc;\n   i386_compare_op0 = operands[0];\n+  i386_compare_op1 = const0_rtx;\n   DONE;\n }\")\n \f\n@@ -7229,255 +7235,627 @@ byte_xor_operation:\n \n /* Conditional move define_insns.  */\n \n-;; These are all disabled, because they are buggy.  They are all susceptible\n-;; to problems with input reloads clobbering the condition code registers.\n-;; It appears the only safe way to write a integer/FP conditional move pattern\n-;; is to write one which emits both the compare and the cmov, and which can be\n-;; split only after reload.\n-\n (define_expand \"movsicc\"\n-  [(match_dup 4)\n-   (parallel [(set (match_operand 0 \"register_operand\" \"\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(if_then_else:SI (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"\")\n-\t\t\t (match_operand:SI 3 \"general_operand\" \"\")))\n-   (clobber (match_scratch:SI 4 \"=&r\"))])]\n-  \"0 && TARGET_CMOVE\"\n+\t\t\t (match_operand:SI 2 \"nonimmediate_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_CMOVE\"\n   \"\n {\n-  operands[4] = i386_compare_gen (i386_compare_op0, i386_compare_op1);\n-}\")\n+  if (GET_MODE_CLASS (GET_MODE (i386_compare_op0)) != MODE_INT)\n+    FAIL;\n \n-(define_expand \"movhicc\"\n-  [(match_dup 4)\n-   (parallel [(set (match_operand 0 \"register_operand\" \"\")\n-\t(if_then_else:HI (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:HI 2 \"general_operand\" \"\")\n-\t\t\t (match_operand:HI 3 \"general_operand\" \"\")))\n-   (clobber (match_scratch:SI 4 \"=&r\"))])]\n-  \"0 && TARGET_CMOVE\"\n-  \"\n-{\n-  operands[4] = i386_compare_gen (i386_compare_op0, i386_compare_op1);\n+  operands[1] = gen_rtx_fmt_ee (GET_CODE (operands[1]),\n+\t\t\tGET_MODE (i386_compare_op0),\n+\t\t\ti386_compare_op0, i386_compare_op1);\n }\")\n \n-(define_insn \"movsicc_1\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,&r,rm\")\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r,r,r\")\n+\t(if_then_else:SI (match_operator 1 \"comparison_operator\" \n+\t      [(match_operand:QI 2 \"nonimmediate_operand\" \"q,m,q,m,q,m\")\n+\t\t(match_operand:QI 3 \"general_operand\" \"qmn,qn,qmn,qn,qmn,qn\")])\n+\t      (match_operand:SI 4 \"nonimmediate_operand\" \"rm,rm,0,0,rm,rm\")\n+\t      (match_operand:SI 5 \"nonimmediate_operand\" \"0,0,rm,rm,rm,rm\")))]\n+  \"TARGET_CMOVE\"\n+  \"#\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r,r,r\")\n+\t(if_then_else:SI (match_operator 1 \"comparison_operator\" \n+\t      [(match_operand 2 \"nonimmediate_operand\" \"r,m,r,m,r,m\")\n+\t\t(match_operand 3 \"general_operand\" \"rmi,ri,rmi,ri,rmi,ri\")])\n+\t      (match_operand:SI 4 \"nonimmediate_operand\" \"rm,rm,0,0,rm,rm\")\n+\t      (match_operand:SI 5 \"nonimmediate_operand\" \"0,0,rm,rm,rm,rm\")))]\n+  \"TARGET_CMOVE && GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(if_then_else:SI (match_operator 1 \"comparison_operator\" \n+\t\t\t\t[(match_operand 2 \"nonimmediate_operand\" \"\")\n+\t\t\t\t (const_int 0)])\n+\t\t      (match_operand:SI 3 \"nonimmediate_operand\" \"rm,0,rm\")\n+\t\t      (match_operand:SI 4 \"nonimmediate_operand\" \"0,rm,rm\")))]\n+  \"TARGET_CMOVE && reload_completed\"\n+  [(set (cc0)\n+\t(match_dup 2))\n+   (set (match_dup 0)\n+\t(if_then_else:SI (match_op_dup 1 [(cc0) (const_int 0)])\n+\t\t      (match_dup 3) (match_dup 4)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(if_then_else:SI (match_operator 1 \"comparison_operator\" \n+\t\t\t\t[(match_operand 2 \"nonimmediate_operand\" \"\")\n+\t\t\t\t (match_operand 3 \"general_operand\" \"\")])\n+\t\t      (match_operand:SI 4 \"nonimmediate_operand\" \"rm,0,rm\")\n+\t\t      (match_operand:SI 5 \"nonimmediate_operand\" \"0,rm,rm\")))]\n+  \"TARGET_CMOVE && reload_completed\"\n+  [(set (cc0) (compare (match_dup 2) (match_dup 3)))\n+   (set (match_dup 0)\n+\t(if_then_else:SI (match_op_dup 1 [(cc0) (const_int 0)])\n+\t\t      (match_dup 4) (match_dup 5)))]\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n \t(if_then_else:SI (match_operator 1 \"comparison_operator\" \n \t\t\t\t[(cc0) (const_int 0)])\n-\t\t      (match_operand:SI 2 \"general_operand\" \"rm,0,rm,g\")\n-\t\t      (match_operand:SI 3 \"general_operand\" \"0,rm,rm,g\")))\n-   (clobber (match_scratch:SI 4 \"X,X,X,=&r\"))]\n-  \"0 && TARGET_CMOVE\"\n+\t\t      (match_operand:SI 2 \"nonimmediate_operand\" \"rm,0,rm\")\n+\t\t      (match_operand:SI 3 \"nonimmediate_operand\" \"0,rm,rm\")))]\n+  \"TARGET_CMOVE && reload_completed\"\n   \"*\n {\n-  if (which_alternative == 0)\n+\n+  switch (which_alternative)\n     {\n+    case 0:\n       /* r <- cond ? arg : r */\n       output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n-    }\n-  else if (which_alternative == 1)\n-    {\n+      break;\n+\n+    case 1:\n       /* r <- cond ? r : arg */\n       output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n-    }\n-  else if (which_alternative == 2)\n-    {\n+      break;\n+\n+    case 2:\n       /* r <- cond ? arg1 : arg2 */\n       output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n       output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n+      break;\n+\n+    default:\n+      abort();\n+    /* NOTREACHED */\n+      break;\n     }\n-  else if (which_alternative == 3)\n-    {\n-      /* r <- cond ? arg1 : arg2 */\n-    rtx xops[3];\n-\n-    xops[0] = gen_label_rtx ();\n-    xops[1] = gen_label_rtx ();\n-    xops[2] = operands[1];\n-\n-    output_asm_insn (\\\"j%c2 %l0\\\", xops);\n-    if (! rtx_equal_p (operands[0], operands[2]))\n-       if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[2]) == MEM)\n-         {\n-           output_asm_insn (AS2 (mov%z2,%2,%4), operands);\n-           output_asm_insn (AS2 (mov%z2,%4,%0), operands);\n-         }\n-       else\n-      output_asm_insn (AS2 (mov%z0,%2,%0), operands);\n-    output_asm_insn (\\\"jmp %l1\\\", xops);\n-    ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (xops[0]));\n-    if (! rtx_equal_p (operands[0], operands[3]))\n-      {\n-        if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[3]) == MEM)\n-          {\n-            output_asm_insn (AS2 (mov%z3,%3,%4), operands);\n-            output_asm_insn (AS2 (mov%z3,%4,%0), operands);\n-          }\n-        else\n-      output_asm_insn (AS2 (mov%z0,%3,%0), operands);\n-      }\n-    ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (xops[1]));\n-    }  \n+\n   RET;\n }\")\n \n-(define_insn \"movhicc_1\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,&r,rm\")\n+(define_expand \"movhicc\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(if_then_else:HI (match_operand 1 \"comparison_operator\" \"\")\n+\t\t\t (match_operand:HI 2 \"nonimmediate_operand\" \"\")\n+\t\t\t (match_operand:HI 3 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_CMOVE\"\n+  \"\n+{\n+  if (GET_MODE_CLASS (GET_MODE (i386_compare_op0)) != MODE_INT)\n+    FAIL;\n+\n+  operands[1] = gen_rtx_fmt_ee (GET_CODE (operands[1]),\n+\t\t\tGET_MODE (i386_compare_op0),\n+\t\t\ti386_compare_op0, i386_compare_op1);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r,r,r,r\")\n+\t(if_then_else:HI (match_operator 1 \"comparison_operator\" \n+\t      [(match_operand:QI 2 \"nonimmediate_operand\" \"q,m,q,m,q,m\")\n+\t\t(match_operand:QI 3 \"general_operand\" \"qmn,qn,qmn,qn,qmn,qn\")])\n+\t      (match_operand:HI 4 \"nonimmediate_operand\" \"rm,rm,0,0,rm,rm\")\n+\t      (match_operand:HI 5 \"nonimmediate_operand\" \"0,0,rm,rm,rm,rm\")))]\n+  \"TARGET_CMOVE\"\n+  \"#\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r,r,r,r\")\n+\t(if_then_else:HI (match_operator 1 \"comparison_operator\" \n+\t      [(match_operand 2 \"nonimmediate_operand\" \"r,m,r,m,r,m\")\n+\t\t(match_operand 3 \"general_operand\" \"rmi,ri,rmi,ri,rmi,ri\")])\n+\t      (match_operand:HI 4 \"nonimmediate_operand\" \"rm,rm,0,0,rm,rm\")\n+\t      (match_operand:HI 5 \"nonimmediate_operand\" \"0,0,rm,rm,rm,rm\")))]\n+  \"TARGET_CMOVE && GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n+\t(if_then_else:HI (match_operator 1 \"comparison_operator\" \n+\t\t\t\t[(match_operand 2 \"nonimmediate_operand\" \"\")\n+\t\t\t\t (const_int 0)])\n+\t\t      (match_operand:HI 3 \"nonimmediate_operand\" \"rm,0,rm\")\n+\t\t      (match_operand:HI 4 \"nonimmediate_operand\" \"0,rm,rm\")))]\n+  \"TARGET_CMOVE && reload_completed\"\n+  [(set (cc0)\n+\t(match_dup 2))\n+   (set (match_dup 0)\n+\t(if_then_else:HI (match_op_dup 1 [(cc0) (const_int 0)])\n+\t\t      (match_dup 3) (match_dup 4)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n+\t(if_then_else:HI (match_operator 1 \"comparison_operator\" \n+\t\t\t\t[(match_operand 2 \"nonimmediate_operand\" \"\")\n+\t\t\t\t (match_operand 3 \"general_operand\" \"\")])\n+\t\t      (match_operand:HI 4 \"nonimmediate_operand\" \"rm,0,rm\")\n+\t\t      (match_operand:HI 5 \"nonimmediate_operand\" \"0,rm,rm\")))]\n+  \"TARGET_CMOVE && reload_completed\"\n+  [(set (cc0)\n+\t(compare (match_dup 2) (match_dup 3)))\n+   (set (match_dup 0)\n+\t(if_then_else:HI (match_op_dup 1 [(cc0) (const_int 0)])\n+\t\t      (match_dup 4) (match_dup 5)))]\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n \t(if_then_else:HI (match_operator 1 \"comparison_operator\" \n \t\t\t\t[(cc0) (const_int 0)])\n-\t\t      (match_operand:HI 2 \"general_operand\" \"rm,0,rm,g\")\n-\t\t      (match_operand:HI 3 \"general_operand\" \"0,rm,rm,g\")))\n-   (clobber (match_scratch:SI 4 \"X,X,X,=&r\"))]\n-  \"0 && TARGET_CMOVE\"\n+\t\t      (match_operand:HI 2 \"nonimmediate_operand\" \"rm,0,rm\")\n+\t\t      (match_operand:HI 3 \"nonimmediate_operand\" \"0,rm,rm\")))]\n+  \"TARGET_CMOVE && reload_completed\"\n   \"*\n {\n-  if (which_alternative == 0)\n+\n+  switch (which_alternative)\n     {\n+    case 0:\n       /* r <- cond ? arg : r */\n       output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n-    }\n-  else if (which_alternative == 1)\n-    {\n+      break;\n+\n+    case 1:\n       /* r <- cond ? r : arg */\n       output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n-    }\n-  else if (which_alternative == 2)\n-    {\n+      break;\n+\n+    case 2:\n       /* r <- cond ? arg1 : arg2 */\n       output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n       output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n+      break;\n+\n+    default:\n+      abort();\n+    /* NOTREACHED */\n+      break;\n     }\n-  else if (which_alternative == 3)\n-    {\n-      /* r <- cond ? arg1 : arg2 */\n-    rtx xops[3];\n-\n-    xops[0] = gen_label_rtx ();\n-    xops[1] = gen_label_rtx ();\n-    xops[2] = operands[1];\n-\n-    output_asm_insn (\\\"j%c2 %l0\\\", xops);\n-    if (! rtx_equal_p (operands[0], operands[2]))\n-       if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[2]) == MEM)\n-         {\n-           output_asm_insn (AS2 (mov%z2,%2,%4), operands);\n-           output_asm_insn (AS2 (mov%z2,%4,%0), operands);\n-         }\n-       else\n-      output_asm_insn (AS2 (mov%z0,%2,%0), operands);\n-    output_asm_insn (\\\"jmp %l1\\\", xops);\n-    ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (xops[0]));\n-    if (! rtx_equal_p (operands[0], operands[3]))\n-      {\n-        if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[3]) == MEM)\n-          {\n-            output_asm_insn (AS2 (mov%z3,%3,%4), operands);\n-            output_asm_insn (AS2 (mov%z3,%4,%0), operands);\n-          }\n-        else\n-      output_asm_insn (AS2 (mov%z0,%3,%0), operands);\n-      }\n-    ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (xops[1]));\n-    }  \n+\n   RET;\n }\")\n-;; We need to disable the FP forms of these since they do not support\n-;; memory as written, but no input reloads are permitted for insns\n-;; that use cc0.  Also, movxfcc is not present.\n \n (define_expand \"movsfcc\"\n-  [(match_dup 4)\n-   (set (match_operand 0 \"register_operand\" \"\")\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n \t(if_then_else:SF (match_operand 1 \"comparison_operator\" \"\")\n \t\t\t (match_operand:SF 2 \"register_operand\" \"\")\n \t\t\t (match_operand:SF 3 \"register_operand\" \"\")))]\n-  \"0 && TARGET_CMOVE\"\n+  \"TARGET_CMOVE\"\n   \"\n {\n-  operands[4] = i386_compare_gen (i386_compare_op0, i386_compare_op1);\n+  if (GET_MODE_CLASS (GET_MODE (i386_compare_op0)) != MODE_INT)\n+    FAIL;\n+\n+  operands[1] = gen_rtx_fmt_ee (GET_CODE (operands[1]),\n+\t\t\tGET_MODE (i386_compare_op0),\n+\t\t\ti386_compare_op0, i386_compare_op1);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f,f,f,f,f\")\n+\t(if_then_else:SF (match_operator 1 \"comparison_operator\" \n+\t      [(match_operand:QI 2 \"nonimmediate_operand\" \"q,m,q,m,q,m\")\n+\t\t(match_operand:QI 3 \"general_operand\" \"qmn,qn,qmn,qn,qmn,qn\")])\n+\t      (match_operand:SF 4 \"register_operand\" \"f,f,0,0,f,f\")\n+\t      (match_operand:SF 5 \"register_operand\" \"0,0,f,f,f,f\")))]\n+  \"TARGET_CMOVE\"\n+  \"#\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f,f,f,f,f\")\n+\t(if_then_else:SF (match_operator 1 \"comparison_operator\" \n+\t\t[(match_operand 2 \"nonimmediate_operand\" \"r,m,r,m,r,m\")\n+\t\t (match_operand 3 \"general_operand\" \"rmi,ri,rmi,ri,rmi,ri\")])\n+\t      (match_operand:SF 4 \"register_operand\" \"f,f,0,0,f,f\")\n+\t      (match_operand:SF 5 \"register_operand\" \"0,0,f,f,f,f\")))]\n+  \"TARGET_CMOVE && GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f,f\")\n+\t(if_then_else:SF (match_operator 1 \"comparison_operator\" \n+\t\t\t\t[(match_operand 2 \"nonimmediate_operand\" \"\")\n+\t\t\t\t (const_int 0)])\n+\t\t      (match_operand:SF 3 \"register_operand\" \"f,0,f\")\n+\t\t      (match_operand:SF 4 \"register_operand\" \"0,f,f\")))]\n+  \"TARGET_CMOVE && reload_completed\"\n+  [(set (cc0)\n+\t(match_dup 2))\n+   (set (match_dup 0)\n+\t(if_then_else:SF (match_op_dup 1 [(cc0) (const_int 0)])\n+\t\t      (match_dup 3) (match_dup 4)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f,f\")\n+\t(if_then_else:SF (match_operator 1 \"comparison_operator\" \n+\t\t\t\t[(match_operand 2 \"nonimmediate_operand\" \"\")\n+\t\t\t\t (match_operand 3 \"general_operand\" \"\")])\n+\t\t      (match_operand:SF 4 \"register_operand\" \"f,0,f\")\n+\t\t      (match_operand:SF 5 \"register_operand\" \"0,f,f\")))]\n+  \"TARGET_CMOVE && reload_completed\"\n+  [(set (cc0) (compare (match_dup 2) (match_dup 3)))\n+   (set (match_dup 0)\n+\t(if_then_else:SF (match_op_dup 1 [(cc0) (const_int 0)])\n+\t\t      (match_dup 4) (match_dup 5)))]\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f,f\")\n+\t(if_then_else:SF (match_operator 1 \"comparison_operator\" \n+\t\t\t\t[(cc0) (const_int 0)])\n+\t\t      (match_operand:SF 2 \"register_operand\" \"f,0,f\")\n+\t\t      (match_operand:SF 3 \"register_operand\" \"0,f,f\")))]\n+  \"TARGET_CMOVE && reload_completed\"\n+  \"*\n+{\n+\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      /* r <- cond ? arg : r */\n+      output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n+      break;\n+\n+    case 1:\n+      /* r <- cond ? r : arg */\n+      output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n+      break;\n+\n+    case 2:\n+      /* r <- cond ? r : arg */\n+      output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n+      output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n+      break;\n+\n+    default:\n+      abort();\n+    /* NOTREACHED */\n+      break;\n+    }\n+\n+  RET;\n }\")\n \n (define_expand \"movdfcc\"\n-  [(match_dup 4)\n-   (set (match_operand 0 \"register_operand\" \"t\")\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(if_then_else:DF (match_operand 1 \"comparison_operator\" \"\")\n \t\t\t (match_operand:DF 2 \"register_operand\" \"\")\n \t\t\t (match_operand:DF 3 \"register_operand\" \"\")))]\n-  \"0 && TARGET_CMOVE\"\n+  \"TARGET_CMOVE\"\n   \"\n {\n-  operands[4] = i386_compare_gen (i386_compare_op0, i386_compare_op1);\n+  if (GET_MODE_CLASS (GET_MODE (i386_compare_op0)) != MODE_INT)\n+    FAIL;\n+\n+  operands[1] = gen_rtx_fmt_ee (GET_CODE (operands[1]),\n+\t\t\tGET_MODE (i386_compare_op0),\n+\t\t\ti386_compare_op0, i386_compare_op1);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f,f,f,f,f\")\n+\t(if_then_else:DF (match_operator 1 \"comparison_operator\" \n+\t      [(match_operand:QI 2 \"nonimmediate_operand\" \"q,m,q,m,q,m\")\n+\t\t(match_operand:QI 3 \"general_operand\" \"qmn,qn,qmn,qn,qmn,qn\")])\n+\t      (match_operand:DF 4 \"register_operand\" \"f,f,0,0,f,f\")\n+\t      (match_operand:DF 5 \"register_operand\" \"0,0,f,f,f,f\")))]\n+  \"TARGET_CMOVE\"\n+  \"#\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f,f,f,f,f\")\n+\t(if_then_else:DF (match_operator 1 \"comparison_operator\" \n+\t      [(match_operand 2 \"nonimmediate_operand\" \"r,m,r,m,r,m\")\n+\t\t(match_operand 3 \"general_operand\" \"rmi,ri,rmi,ri,rmi,ri\")])\n+\t      (match_operand:DF 4 \"register_operand\" \"f,f,0,0,f,f\")\n+\t      (match_operand:DF 5 \"register_operand\" \"0,0,f,f,f,f\")))]\n+  \"TARGET_CMOVE && GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f,f\")\n+\t(if_then_else:DF (match_operator 1 \"comparison_operator\" \n+\t\t\t\t[(match_operand 2 \"nonimmediate_operand\" \"\")\n+\t\t\t\t (const_int 0)])\n+\t\t      (match_operand:DF 3 \"register_operand\" \"f,0,f\")\n+\t\t      (match_operand:DF 4 \"register_operand\" \"0,f,f\")))]\n+  \"TARGET_CMOVE && reload_completed\"\n+  [(set (cc0)\n+\t(match_dup 2))\n+   (set (match_dup 0)\n+\t(if_then_else:DF (match_op_dup 1 [(cc0) (const_int 0)])\n+\t\t      (match_dup 3) (match_dup 4)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f,f\")\n+\t(if_then_else:DF (match_operator 1 \"comparison_operator\" \n+\t\t\t\t[(match_operand 2 \"nonimmediate_operand\" \"\")\n+\t\t\t\t (match_operand 3 \"general_operand\" \"\")])\n+\t\t      (match_operand:DF 4 \"register_operand\" \"f,0,f\")\n+\t\t      (match_operand:DF 5 \"register_operand\" \"0,f,f\")))]\n+  \"TARGET_CMOVE && reload_completed\"\n+  [(set (cc0) (compare (match_dup 2) (match_dup 3)))\n+   (set (match_dup 0)\n+\t(if_then_else:DF (match_op_dup 1 [(cc0) (const_int 0)])\n+\t\t      (match_dup 4) (match_dup 5)))]\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f,f\")\n+\t(if_then_else:DF (match_operator 1 \"comparison_operator\" \n+\t\t\t\t[(cc0) (const_int 0)])\n+\t\t      (match_operand:DF 2 \"register_operand\" \"f,0,f\")\n+\t\t      (match_operand:DF 3 \"register_operand\" \"0,f,f\")))]\n+  \"TARGET_CMOVE && reload_completed\"\n+  \"*\n+{\n+\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      /* r <- cond ? arg : r */\n+      output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n+      break;\n+\n+    case 1:\n+      /* r <- cond ? r : arg */\n+      output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n+      break;\n+\n+    case 2:\n+      /* r <- cond ? r : arg */\n+      output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n+      output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n+      break;\n+\n+    default:\n+      abort();\n+    /* NOTREACHED */\n+      break;\n+    }\n+\n+  RET;\n }\")\n \n (define_expand \"movxfcc\"\n-  [(match_dup 4)\n-   (set (match_operand 0 \"register_operand\" \"\")\n+  [(set (match_operand:XF 0 \"register_operand\" \"\")\n \t(if_then_else:XF (match_operand 1 \"comparison_operator\" \"\")\n \t\t\t (match_operand:XF 2 \"register_operand\" \"\")\n \t\t\t (match_operand:XF 3 \"register_operand\" \"\")))]\n-  \"0 && TARGET_CMOVE\"\n+  \"TARGET_CMOVE\"\n   \"\n {\n-  operands[4] = i386_compare_gen (i386_compare_op0, i386_compare_op1);\n+  if (GET_MODE_CLASS (GET_MODE (i386_compare_op0)) != MODE_INT)\n+    FAIL;\n+\n+  operands[1] = gen_rtx_fmt_ee (GET_CODE (operands[1]),\n+\t\t\tGET_MODE (i386_compare_op0),\n+\t\t\ti386_compare_op0, i386_compare_op1);\n }\")\n \n-(define_insn \"movsfcc_1\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=f,f,&f\")\n-\t(if_then_else:SF (match_operator 1 \"comparison_operator\" \n-\t\t\t\t\t [(cc0) (const_int 0)])\n-\t\t\t (match_operand:SF 2 \"register_operand\" \"0,f,f\")\n-\t\t\t (match_operand:SF 3 \"register_operand\" \"f,0,f\")))]\n-  \"0 && TARGET_CMOVE\"\n+(define_insn \"\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f,f,f,f,f,f\")\n+\t(if_then_else:XF (match_operator 1 \"comparison_operator\" \n+\t      [(match_operand:QI 2 \"nonimmediate_operand\" \"q,m,q,m,q,m\")\n+\t\t(match_operand:QI 3 \"general_operand\" \"qmn,qn,qmn,qn,qmn,qn\")])\n+\t      (match_operand:XF 4 \"register_operand\" \"f,f,0,0,f,f\")\n+\t      (match_operand:XF 5 \"register_operand\" \"0,0,f,f,f,f\")))]\n+  \"TARGET_CMOVE\"\n+  \"#\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f,f,f,f,f,f\")\n+\t(if_then_else:XF (match_operator 1 \"comparison_operator\" \n+\t      [(match_operand 2 \"nonimmediate_operand\" \"r,m,r,m,r,m\")\n+\t\t(match_operand 3 \"general_operand\" \"rmi,ri,rmi,ri,rmi,ri\")])\n+\t      (match_operand:XF 4 \"register_operand\" \"f,f,0,0,f,f\")\n+\t      (match_operand:XF 5 \"register_operand\" \"0,0,f,f,f,f\")))]\n+  \"TARGET_CMOVE && GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f,f,f\")\n+\t(if_then_else:XF (match_operator 1 \"comparison_operator\" \n+\t\t\t\t[(match_operand 2 \"nonimmediate_operand\" \"\")\n+\t\t\t\t (const_int 0)])\n+\t\t      (match_operand:XF 3 \"register_operand\" \"f,0,f\")\n+\t\t      (match_operand:XF 4 \"register_operand\" \"0,f,f\")))]\n+  \"TARGET_CMOVE && reload_completed\"\n+  [(set (cc0)\n+\t(match_dup 2))\n+   (set (match_dup 0)\n+\t(if_then_else:XF (match_op_dup 1 [(cc0) (const_int 0)])\n+\t\t      (match_dup 3) (match_dup 4)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f,f,f\")\n+\t(if_then_else:XF (match_operator 1 \"comparison_operator\" \n+\t\t\t\t[(match_operand 2 \"nonimmediate_operand\" \"\")\n+\t\t\t\t (match_operand 3 \"general_operand\" \"\")])\n+\t\t      (match_operand:XF 4 \"register_operand\" \"f,0,f\")\n+\t\t      (match_operand:XF 5 \"register_operand\" \"0,f,f\")))]\n+  \"TARGET_CMOVE && reload_completed\"\n+  [(set (cc0) (compare (match_dup 2) (match_dup 3)))\n+   (set (match_dup 0)\n+\t(if_then_else:XF (match_op_dup 1 [(cc0) (const_int 0)])\n+\t\t      (match_dup 4) (match_dup 5)))]\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f,f,f\")\n+\t(if_then_else:XF (match_operator 1 \"comparison_operator\" \n+\t\t\t\t[(cc0) (const_int 0)])\n+\t\t      (match_operand:XF 2 \"register_operand\" \"f,0,f\")\n+\t\t      (match_operand:XF 3 \"register_operand\" \"0,f,f\")))]\n+  \"TARGET_CMOVE && reload_completed\"\n   \"*\n {\n+\n   switch (which_alternative)\n     {\n     case 0:\n       /* r <- cond ? arg : r */\n-      output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n+      output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n       break;\n \n     case 1:\n       /* r <- cond ? r : arg */\n-      output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n+      output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n       break;\n \n     case 2:\n       /* r <- cond ? r : arg */\n       output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n       output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n       break;\n+\n+    default:\n+      abort();\n+    /* NOTREACHED */\n+      break;\n     }\n \n   RET;\n }\")\n \n-(define_insn \"movdfcc_1\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=f,f,&f\")\n-\t(if_then_else:DF (match_operator 1 \"comparison_operator\" \n-\t\t\t\t\t [(cc0) (const_int 0)])\n-\t\t\t (match_operand:DF 2 \"register_operand\" \"0,f,f\")\n-\t\t\t (match_operand:DF 3 \"register_operand\" \"f,0,f\")))]\n-  \"0 && TARGET_CMOVE\"\n+(define_expand \"movdicc\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(if_then_else:DI (match_operand 1 \"comparison_operator\" \"\")\n+\t\t\t (match_operand:DI 2 \"nonimmediate_operand\" \"\")\n+\t\t\t (match_operand:DI 3 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_CMOVE\"\n+  \"\n+{\n+  if (GET_MODE_CLASS (GET_MODE (i386_compare_op0)) != MODE_INT)\n+    FAIL;\n+\n+  operands[1] = gen_rtx_fmt_ee (GET_CODE (operands[1]),\n+\t\t\tGET_MODE (i386_compare_op0),\n+\t\t\ti386_compare_op0, i386_compare_op1);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r,&r,&r,&r,&r,&r\")\n+\t(if_then_else:DI (match_operator 1 \"comparison_operator\" \n+\t      [(match_operand:QI 2 \"nonimmediate_operand\" \"q,m,q,m,q,m\")\n+\t\t(match_operand:QI 3 \"general_operand\" \"qmn,qn,qmn,qn,qmn,qn\")])\n+\t      (match_operand:DI 4 \"nonimmediate_operand\" \"ro,ro,0,0,ro,ro\")\n+\t      (match_operand:DI 5 \"nonimmediate_operand\" \"0,0,ro,ro,ro,ro\")))]\n+  \"TARGET_CMOVE\"\n+  \"#\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r,&r,&r,&r,&r,&r\")\n+\t(if_then_else:DI (match_operator 1 \"comparison_operator\" \n+\t      [(match_operand 2 \"nonimmediate_operand\" \"r,m,r,m,r,m\")\n+\t\t(match_operand 3 \"general_operand\" \"rmi,ri,rmi,ri,rmi,ri\")])\n+\t      (match_operand:DI 4 \"nonimmediate_operand\" \"ro,ro,0,0,ro,ro\")\n+\t      (match_operand:DI 5 \"nonimmediate_operand\" \"0,0,ro,ro,ro,ro\")))]\n+  \"TARGET_CMOVE && GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r,&r,&r\")\n+\t(if_then_else:DI (match_operator 1 \"comparison_operator\" \n+\t\t\t\t[(match_operand 2 \"nonimmediate_operand\" \"\")\n+\t\t\t\t (const_int 0)])\n+\t\t      (match_operand:DI 3 \"nonimmediate_operand\" \"ro,0,ro\")\n+\t\t      (match_operand:DI 4 \"nonimmediate_operand\" \"0,ro,ro\")))]\n+  \"TARGET_CMOVE && reload_completed\"\n+  [(set (cc0)\n+\t(match_dup 2))\n+   (set (match_dup 0)\n+\t(if_then_else:DI (match_op_dup 1 [(cc0) (const_int 0)])\n+\t\t      (match_dup 3) (match_dup 4)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r,&r,&r\")\n+\t(if_then_else:DI (match_operator 1 \"comparison_operator\" \n+\t\t\t\t[(match_operand 2 \"nonimmediate_operand\" \"\")\n+\t\t\t\t (match_operand 3 \"general_operand\" \"\")])\n+\t\t      (match_operand:DI 4 \"nonimmediate_operand\" \"ro,0,ro\")\n+\t\t      (match_operand:DI 5 \"nonimmediate_operand\" \"0,ro,ro\")))]\n+  \"TARGET_CMOVE && reload_completed\"\n+  [(set (cc0) (compare (match_dup 2) (match_dup 3)))\n+   (set (match_dup 0)\n+\t(if_then_else:DI (match_op_dup 1 [(cc0) (const_int 0)])\n+\t\t      (match_dup 4) (match_dup 5)))]\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r,&r,&r\")\n+\t(if_then_else:DI (match_operator 1 \"comparison_operator\" \n+\t\t\t\t[(cc0) (const_int 0)])\n+\t\t      (match_operand:DI 2 \"nonimmediate_operand\" \"ro,0,ro\")\n+\t\t      (match_operand:DI 3 \"nonimmediate_operand\" \"0,ro,ro\")))]\n+  \"TARGET_CMOVE && reload_completed\"\n   \"*\n {\n+  rtx xops[4];\n+\n+  xops[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n+  xops[1] = operands[1];\n+  xops[2] = REG_P (operands[2])\n+\t\t? gen_rtx_REG (SImode, REGNO (operands[2]) + 1)\n+\t\t: adj_offsettable_operand (operands[2], 4);\n+  xops[3] = REG_P (operands[3])\n+\t\t? gen_rtx_REG (SImode, REGNO (operands[3]) + 1)\n+\t\t: adj_offsettable_operand (operands[3], 4);\n+\n   switch (which_alternative)\n     {\n     case 0:\n       /* r <- cond ? arg : r */\n-      output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n+      output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n+      output_asm_insn (AS2 (cmov%C1,%2,%0), xops);\n       break;\n \n     case 1:\n       /* r <- cond ? r : arg */\n-      output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n+      output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n+      output_asm_insn (AS2 (cmov%c1,%3,%0), xops);\n       break;\n \n     case 2:\n-      /* r <- cond ? r : arg */\n-      output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n-      output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n+      /* r <- cond ? arg1 : arg2 */\n+      output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n+      output_asm_insn (AS2 (cmov%C1,%2,%0), xops);\n+      output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n+      output_asm_insn (AS2 (cmov%c1,%3,%0), xops);\n+      break;\n+\n+    default:\n+      abort();\n+    /* NOTREACHED */\n       break;\n     }\n "}, {"sha": "1604a7b0ba0ec9b8802c6c483c9bea383aaedce1", "filename": "gcc/reload.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726e2d544cdcb3e91ac2e0ced52bf7ef592b18f3/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726e2d544cdcb3e91ac2e0ced52bf7ef592b18f3/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=726e2d544cdcb3e91ac2e0ced52bf7ef592b18f3", "patch": "@@ -2641,8 +2641,16 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  register int regno = REGNO (recog_operand[i]);\n \t  if (reg_equiv_constant[regno] != 0\n \t      && (set == 0 || &SET_DEST (set) != recog_operand_loc[i]))\n-\t    substed_operand[i] = recog_operand[i]\n-\t      = reg_equiv_constant[regno];\n+\t    {\n+\t      /* Record the existing mode so that the check if constants are\n+\t         allowed will work when operand_mode isn't specified. */\n+\n+\t      if (operand_mode[i] == VOIDmode)\n+\t\toperand_mode[i] = GET_MODE (recog_operand[i]);\n+\n+\t      substed_operand[i] = recog_operand[i]\n+\t        = reg_equiv_constant[regno];\n+\t    }\n #if 0 /* This might screw code in reload1.c to delete prior output-reload\n \t that feeds this insn.  */\n \t  if (reg_equiv_mem[regno] != 0)"}]}