{"sha": "c095a4f848959916b29dc626c2fd8120c0eedee7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzA5NWE0Zjg0ODk1OTkxNmIyOWRjNjI2YzJmZDgxMjBjMGVlZGVlNw==", "commit": {"author": {"name": "Douglas Gregor", "email": "doug.gregor@gmail.com", "date": "2008-01-15T16:09:28Z"}, "committer": {"name": "Doug Gregor", "email": "dgregor@gcc.gnu.org", "date": "2008-01-15T16:09:28Z"}, "message": "re PR c++/33964 (internal compiler error: in dependent_type_p, at cp/pt.c:15319 (vararg templates))\n\n2008-01-15  Douglas Gregor  <doug.gregor@gmail.com>\n\n       PR c++/33964\n       * pt.c (process_partial_specialization): Don't mark template\n       parameters that occur in non-deduced contexts.\n       (struct pair_fn_data): Add include_nondeduced_p.\n       (for_each_template_parm_r): Only visit non-deduced contexts if\n       include_nondeduced_p is set.\n       (for_each_template_parm): Added parameter include_nondeduced_p,\n       which states whether template parameters found in non-deduced\n       contexts should be visited.\n       (uses_template_parms): Visit all template parameters, even those\n       in non-deduced contexts.\n\n2008-01-15  Douglas Gregor  <doug.gregor@gmail.com>\n\n       PR c++/33964\n       * g++.dg/cpp0x/vt-33964.C: New.\n       * g++.dg/template/partial5.C: New.\n\nFrom-SVN: r131544", "tree": {"sha": "f8fe52dda8cb6ad5ce9f551afd15dd57225459ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8fe52dda8cb6ad5ce9f551afd15dd57225459ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c095a4f848959916b29dc626c2fd8120c0eedee7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c095a4f848959916b29dc626c2fd8120c0eedee7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c095a4f848959916b29dc626c2fd8120c0eedee7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c095a4f848959916b29dc626c2fd8120c0eedee7/comments", "author": {"login": "DougGregor", "id": 989428, "node_id": "MDQ6VXNlcjk4OTQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/989428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DougGregor", "html_url": "https://github.com/DougGregor", "followers_url": "https://api.github.com/users/DougGregor/followers", "following_url": "https://api.github.com/users/DougGregor/following{/other_user}", "gists_url": "https://api.github.com/users/DougGregor/gists{/gist_id}", "starred_url": "https://api.github.com/users/DougGregor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DougGregor/subscriptions", "organizations_url": "https://api.github.com/users/DougGregor/orgs", "repos_url": "https://api.github.com/users/DougGregor/repos", "events_url": "https://api.github.com/users/DougGregor/events{/privacy}", "received_events_url": "https://api.github.com/users/DougGregor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "85d852346c60093ad0f749aefecf6c8c46f9a2b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85d852346c60093ad0f749aefecf6c8c46f9a2b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85d852346c60093ad0f749aefecf6c8c46f9a2b5"}], "stats": {"total": 133, "additions": 111, "deletions": 22}, "files": [{"sha": "e464d91b914fe008056dd3e0f985a7d5c7a17ed6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c095a4f848959916b29dc626c2fd8120c0eedee7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c095a4f848959916b29dc626c2fd8120c0eedee7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c095a4f848959916b29dc626c2fd8120c0eedee7", "patch": "@@ -1,3 +1,17 @@\n+2008-01-15  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+       PR c++/33964\n+       * pt.c (process_partial_specialization): Don't mark template\n+       parameters that occur in non-deduced contexts.\n+       (struct pair_fn_data): Add include_nondeduced_p.\n+       (for_each_template_parm_r): Only visit non-deduced contexts if\n+       include_nondeduced_p is set.\n+       (for_each_template_parm): Added parameter include_nondeduced_p,\n+       which states whether template parameters found in non-deduced\n+       contexts should be visited.\n+       (uses_template_parms): Visit all template parameters, even those\n+       in non-deduced contexts.\n+\n 2008-01-15  Douglas Gregor  <doug.gregor@gmail.com>\n \n        PR c++/34052"}, {"sha": "409b123a480416999b23e097a5a1476ff446ea3c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 47, "deletions": 22, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c095a4f848959916b29dc626c2fd8120c0eedee7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c095a4f848959916b29dc626c2fd8120c0eedee7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=c095a4f848959916b29dc626c2fd8120c0eedee7", "patch": "@@ -125,7 +125,7 @@ static tree convert_nontype_argument (tree, tree);\n static tree convert_template_argument (tree, tree, tree,\n \t\t\t\t       tsubst_flags_t, int, tree);\n static int for_each_template_parm (tree, tree_fn_t, void*,\n-\t\t\t\t   struct pointer_set_t*);\n+\t\t\t\t   struct pointer_set_t*, bool);\n static tree expand_template_argument_pack (tree);\n static tree build_template_parm_index (int, int, int, tree, tree);\n static bool inline_needs_template_parms (tree);\n@@ -3378,7 +3378,8 @@ process_partial_specialization (tree decl)\n       for_each_template_parm (TREE_VEC_ELT (inner_args, i),\n \t\t\t      &mark_template_parm,\n \t\t\t      &tpd,\n-\t\t\t      NULL);\n+\t\t\t      NULL,\n+\t\t\t      /*include_nondeduced_p=*/false);\n     }\n   for (i = 0; i < ntparms; ++i)\n     if (tpd.parms[i] == 0)\n@@ -3501,7 +3502,8 @@ process_partial_specialization (tree decl)\n                   for_each_template_parm (type,\n                                           &mark_template_parm,\n                                           &tpd2,\n-                                          NULL);\n+                                          NULL,\n+\t\t\t\t\t  /*include_nondeduced_p=*/false);\n \n                   if (tpd2.arg_uses_template_parms [i])\n                     {\n@@ -5929,6 +5931,9 @@ struct pair_fn_data\n {\n   tree_fn_t fn;\n   void *data;\n+  /* True when we should also visit template parameters that occur in\n+     non-deduced contexts.  */\n+  bool include_nondeduced_p;\n   struct pointer_set_t *visited;\n };\n \n@@ -5943,7 +5948,9 @@ for_each_template_parm_r (tree *tp, int *walk_subtrees, void *d)\n   void *data = pfd->data;\n \n   if (TYPE_P (t)\n-      && for_each_template_parm (TYPE_CONTEXT (t), fn, data, pfd->visited))\n+      && (pfd->include_nondeduced_p || TREE_CODE (t) != TYPENAME_TYPE)\n+      && for_each_template_parm (TYPE_CONTEXT (t), fn, data, pfd->visited,\n+\t\t\t\t pfd->include_nondeduced_p))\n     return error_mark_node;\n \n   switch (TREE_CODE (t))\n@@ -5958,29 +5965,33 @@ for_each_template_parm_r (tree *tp, int *walk_subtrees, void *d)\n       if (!TYPE_TEMPLATE_INFO (t))\n \t*walk_subtrees = 0;\n       else if (for_each_template_parm (TREE_VALUE (TYPE_TEMPLATE_INFO (t)),\n-\t\t\t\t       fn, data, pfd->visited))\n+\t\t\t\t       fn, data, pfd->visited, \n+\t\t\t\t       pfd->include_nondeduced_p))\n \treturn error_mark_node;\n       break;\n \n     case INTEGER_TYPE:\n       if (for_each_template_parm (TYPE_MIN_VALUE (t),\n-\t\t\t\t  fn, data, pfd->visited)\n+\t\t\t\t  fn, data, pfd->visited, \n+\t\t\t\t  pfd->include_nondeduced_p)\n \t  || for_each_template_parm (TYPE_MAX_VALUE (t),\n-\t\t\t\t     fn, data, pfd->visited))\n+\t\t\t\t     fn, data, pfd->visited,\n+\t\t\t\t     pfd->include_nondeduced_p))\n \treturn error_mark_node;\n       break;\n \n     case METHOD_TYPE:\n       /* Since we're not going to walk subtrees, we have to do this\n \t explicitly here.  */\n       if (for_each_template_parm (TYPE_METHOD_BASETYPE (t), fn, data,\n-\t\t\t\t  pfd->visited))\n+\t\t\t\t  pfd->visited, pfd->include_nondeduced_p))\n \treturn error_mark_node;\n       /* Fall through.  */\n \n     case FUNCTION_TYPE:\n       /* Check the return type.  */\n-      if (for_each_template_parm (TREE_TYPE (t), fn, data, pfd->visited))\n+      if (for_each_template_parm (TREE_TYPE (t), fn, data, pfd->visited,\n+\t\t\t\t  pfd->include_nondeduced_p))\n \treturn error_mark_node;\n \n       /* Check the parameter types.  Since default arguments are not\n@@ -5994,7 +6005,7 @@ for_each_template_parm_r (tree *tp, int *walk_subtrees, void *d)\n \n \tfor (parm = TYPE_ARG_TYPES (t); parm; parm = TREE_CHAIN (parm))\n \t  if (for_each_template_parm (TREE_VALUE (parm), fn, data,\n-\t\t\t\t      pfd->visited))\n+\t\t\t\t      pfd->visited, pfd->include_nondeduced_p))\n \t    return error_mark_node;\n \n \t/* Since we've already handled the TYPE_ARG_TYPES, we don't\n@@ -6004,34 +6015,38 @@ for_each_template_parm_r (tree *tp, int *walk_subtrees, void *d)\n       break;\n \n     case TYPEOF_TYPE:\n-      if (for_each_template_parm (TYPE_FIELDS (t), fn, data,\n-\t\t\t\t  pfd->visited))\n+      if (pfd->include_nondeduced_p\n+\t  && for_each_template_parm (TYPE_FIELDS (t), fn, data,\n+\t\t\t\t     pfd->visited, \n+\t\t\t\t     pfd->include_nondeduced_p))\n \treturn error_mark_node;\n       break;\n \n     case FUNCTION_DECL:\n     case VAR_DECL:\n       if (DECL_LANG_SPECIFIC (t) && DECL_TEMPLATE_INFO (t)\n \t  && for_each_template_parm (DECL_TI_ARGS (t), fn, data,\n-\t\t\t\t     pfd->visited))\n+\t\t\t\t     pfd->visited, pfd->include_nondeduced_p))\n \treturn error_mark_node;\n       /* Fall through.  */\n \n     case PARM_DECL:\n     case CONST_DECL:\n       if (TREE_CODE (t) == CONST_DECL && DECL_TEMPLATE_PARM_P (t)\n \t  && for_each_template_parm (DECL_INITIAL (t), fn, data,\n-\t\t\t\t     pfd->visited))\n+\t\t\t\t     pfd->visited, pfd->include_nondeduced_p))\n \treturn error_mark_node;\n       if (DECL_CONTEXT (t)\n+\t  && pfd->include_nondeduced_p\n \t  && for_each_template_parm (DECL_CONTEXT (t), fn, data,\n-\t\t\t\t     pfd->visited))\n+\t\t\t\t     pfd->visited, pfd->include_nondeduced_p))\n \treturn error_mark_node;\n       break;\n \n     case BOUND_TEMPLATE_TEMPLATE_PARM:\n       /* Record template parameters such as `T' inside `TT<T>'.  */\n-      if (for_each_template_parm (TYPE_TI_ARGS (t), fn, data, pfd->visited))\n+      if (for_each_template_parm (TYPE_TI_ARGS (t), fn, data, pfd->visited,\n+\t\t\t\t  pfd->include_nondeduced_p))\n \treturn error_mark_node;\n       /* Fall through.  */\n \n@@ -6047,7 +6062,8 @@ for_each_template_parm_r (tree *tp, int *walk_subtrees, void *d)\n     case TEMPLATE_DECL:\n       /* A template template parameter is encountered.  */\n       if (DECL_TEMPLATE_TEMPLATE_PARM_P (t)\n-\t  && for_each_template_parm (TREE_TYPE (t), fn, data, pfd->visited))\n+\t  && for_each_template_parm (TREE_TYPE (t), fn, data, pfd->visited,\n+\t\t\t\t     pfd->include_nondeduced_p))\n \treturn error_mark_node;\n \n       /* Already substituted template template parameter */\n@@ -6057,15 +6073,17 @@ for_each_template_parm_r (tree *tp, int *walk_subtrees, void *d)\n     case TYPENAME_TYPE:\n       if (!fn\n \t  || for_each_template_parm (TYPENAME_TYPE_FULLNAME (t), fn,\n-\t\t\t\t     data, pfd->visited))\n+\t\t\t\t     data, pfd->visited, \n+\t\t\t\t     pfd->include_nondeduced_p))\n \treturn error_mark_node;\n       break;\n \n     case CONSTRUCTOR:\n       if (TREE_TYPE (t) && TYPE_PTRMEMFUNC_P (TREE_TYPE (t))\n+\t  && pfd->include_nondeduced_p\n \t  && for_each_template_parm (TYPE_PTRMEMFUNC_FN_TYPE\n \t\t\t\t     (TREE_TYPE (t)), fn, data,\n-\t\t\t\t     pfd->visited))\n+\t\t\t\t     pfd->visited, pfd->include_nondeduced_p))\n \treturn error_mark_node;\n       break;\n \n@@ -6106,18 +6124,24 @@ for_each_template_parm_r (tree *tp, int *walk_subtrees, void *d)\n    for_each_template_parm returns 1.  Otherwise, the iteration\n    continues.  If FN never returns a nonzero value, the value\n    returned by for_each_template_parm is 0.  If FN is NULL, it is\n-   considered to be the function which always returns 1.  */\n+   considered to be the function which always returns 1.\n+\n+   If INCLUDE_NONDEDUCED_P, then this routine will also visit template\n+   parameters that occur in non-deduced contexts.  When false, only\n+   visits those template parameters that can be deduced.  */\n \n static int\n for_each_template_parm (tree t, tree_fn_t fn, void* data,\n-\t\t\tstruct pointer_set_t *visited)\n+\t\t\tstruct pointer_set_t *visited,\n+\t\t\tbool include_nondeduced_p)\n {\n   struct pair_fn_data pfd;\n   int result;\n \n   /* Set up.  */\n   pfd.fn = fn;\n   pfd.data = data;\n+  pfd.include_nondeduced_p = include_nondeduced_p;\n \n   /* Walk the tree.  (Conceptually, we would like to walk without\n      duplicates, but for_each_template_parm_r recursively calls\n@@ -6189,7 +6213,8 @@ uses_template_parms (tree t)\n int\n uses_template_parms_level (tree t, int level)\n {\n-  return for_each_template_parm (t, template_parm_this_level_p, &level, NULL);\n+  return for_each_template_parm (t, template_parm_this_level_p, &level, NULL,\n+\t\t\t\t /*include_nondeduced_p=*/true);\n }\n \n static int tinst_depth;"}, {"sha": "3ae1bd2ff1d4a806677f0251d0a202ac3cbb74cc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c095a4f848959916b29dc626c2fd8120c0eedee7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c095a4f848959916b29dc626c2fd8120c0eedee7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c095a4f848959916b29dc626c2fd8120c0eedee7", "patch": "@@ -1,3 +1,9 @@\n+2008-01-15  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+       PR c++/33964\n+       * g++.dg/cpp0x/vt-33964.C: New.\n+       * g++.dg/template/partial5.C: New.\n+\n 2008-01-15  Douglas Gregor  <doug.gregor@gmail.com>\n \n        PR c++/34052"}, {"sha": "0b84b6cec8993e4f1532a3b0aec05484a78b9dce", "filename": "gcc/testsuite/g++.dg/cpp0x/vt-33964.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c095a4f848959916b29dc626c2fd8120c0eedee7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvt-33964.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c095a4f848959916b29dc626c2fd8120c0eedee7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvt-33964.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvt-33964.C?ref=c095a4f848959916b29dc626c2fd8120c0eedee7", "patch": "@@ -0,0 +1,20 @@\n+// { dg-options \"-std=c++0x\" }\n+template<typename ... Args>\n+struct foo\n+{\n+    static bool const value = true;\n+};\n+\n+template<typename ... Args>\n+struct foo< typename Args::is_applied... > // { dg-error \"not used|Args\" }\n+{\n+    static bool const value = false;\n+};\n+\n+struct not_applied { typedef void is_applied; };\n+struct applied { typedef applied is_applied; };\n+\n+int main()\n+{\n+    foo<applied, applied> i;\n+}"}, {"sha": "aa32e3b8a419cd5aa1bc982c7cd83edcab0c778e", "filename": "gcc/testsuite/g++.dg/template/partial5.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c095a4f848959916b29dc626c2fd8120c0eedee7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c095a4f848959916b29dc626c2fd8120c0eedee7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial5.C?ref=c095a4f848959916b29dc626c2fd8120c0eedee7", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/33964\n+\n+template<typename T>\n+struct X { };\n+\n+template<typename T>\n+struct X<typename T::foo> { }; // { dg-error \"not used|T\" }\n+\n+template<int N>\n+struct X<int[N]> {}; // okay\n+\n+\n+template<typename T, typename T::foo V>\n+struct Y { };\n+\n+template<typename T, typename U, U v>\n+struct Y<T, v> { }; // { dg-error \"not used|U\" }\n+\n+\n+template<typename T, T V>\n+struct Z { };\n+\n+template<typename T>\n+struct Z<T, (T)0> { }; // { dg-error \"involves template parameter\" }"}]}