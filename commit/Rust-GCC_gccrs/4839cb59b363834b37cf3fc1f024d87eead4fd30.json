{"sha": "4839cb59b363834b37cf3fc1f024d87eead4fd30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgzOWNiNTliMzYzODM0YjM3Y2YzZmMxZjAyNGQ4N2VlYWQ0ZmQzMA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-02-25T19:49:22Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-02-25T19:49:22Z"}, "message": "tree-ssa-loop-niter.c (compute_estimated_nb_iterations): Fix off-by-one error.\n\n\t* tree-ssa-loop-niter.c (compute_estimated_nb_iterations): Fix\n\toff-by-one error.\n\t(array_at_struct_end_p): New function.\n\t(idx_infer_loop_bounds): Use it.\n\t(estimate_numbers_of_iterations_loop): Export.\n\t* predict.c (predict_loops): Use estimated_loop_iterations_int.\n\tDo not use PRED_LOOP_EXIT on exits predicted by # of iterations.\n\t(tree_estimate_probability): Call record_loop_exits.\n\t* tree-data-ref.c (get_number_of_iters_for_loop): Replaced by ...\n\t(estimated_loop_iterations, estimated_loop_iterations_int,\n\testimated_loop_iterations_tree): New functions.\n\t(analyze_siv_subscript_cst_affine,\n\tcompute_overlap_steps_for_affine_1_2,\n\tanalyze_subscript_affine_affine): Use estimated_loop_iterations_int.\n\t(analyze_miv_subscript): Use estimated_loop_iterations_tree.\n\t* predict.def (PRED_LOOP_ITERATIONS): Update comment.\n\t(PRED_LOOP_ITERATIONS_GUESSED): New.\n\t* cfgloop.c (record_loop_exits): Do nothing if there are no loops.\n\t* cfgloop.h (estimate_numbers_of_iterations_loop,\n\testimated_loop_iterations_int): Declare.\n\nFrom-SVN: r122316", "tree": {"sha": "442c3c77bcfc1b33de609ff61cc1e7e4b84bc7e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/442c3c77bcfc1b33de609ff61cc1e7e4b84bc7e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4839cb59b363834b37cf3fc1f024d87eead4fd30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4839cb59b363834b37cf3fc1f024d87eead4fd30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4839cb59b363834b37cf3fc1f024d87eead4fd30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4839cb59b363834b37cf3fc1f024d87eead4fd30/comments", "author": null, "committer": null, "parents": [{"sha": "fc8600f9c12ccb952cb38fbad4a2f34e0d958473", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc8600f9c12ccb952cb38fbad4a2f34e0d958473", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc8600f9c12ccb952cb38fbad4a2f34e0d958473"}], "stats": {"total": 296, "additions": 231, "deletions": 65}, "files": [{"sha": "e835441970b1eee7057eb5b5e985bfdf2287dd45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4839cb59b363834b37cf3fc1f024d87eead4fd30/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4839cb59b363834b37cf3fc1f024d87eead4fd30/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4839cb59b363834b37cf3fc1f024d87eead4fd30", "patch": "@@ -1,3 +1,26 @@\n+2007-02-25  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-niter.c (compute_estimated_nb_iterations): Fix\n+\toff-by-one error.\n+\t(array_at_struct_end_p): New function.\n+\t(idx_infer_loop_bounds): Use it.\n+\t(estimate_numbers_of_iterations_loop): Export.\n+\t* predict.c (predict_loops): Use estimated_loop_iterations_int.\n+\tDo not use PRED_LOOP_EXIT on exits predicted by # of iterations.\n+\t(tree_estimate_probability): Call record_loop_exits.\n+\t* tree-data-ref.c (get_number_of_iters_for_loop): Replaced by ...\n+\t(estimated_loop_iterations, estimated_loop_iterations_int,\n+\testimated_loop_iterations_tree): New functions.\n+\t(analyze_siv_subscript_cst_affine,\n+\tcompute_overlap_steps_for_affine_1_2,\n+\tanalyze_subscript_affine_affine): Use estimated_loop_iterations_int.\n+\t(analyze_miv_subscript): Use estimated_loop_iterations_tree.\n+\t* predict.def (PRED_LOOP_ITERATIONS): Update comment.\n+\t(PRED_LOOP_ITERATIONS_GUESSED): New.\n+\t* cfgloop.c (record_loop_exits): Do nothing if there are no loops.\n+\t* cfgloop.h (estimate_numbers_of_iterations_loop,\n+\testimated_loop_iterations_int): Declare.\n+\n 2007-02-25  Mark Mitchell  <mark@codesourcery.com>\n \n \t* doc/extend.texi: Document optional priority argument to"}, {"sha": "12ce92cdd9ee4726140a30dfc7ee9e858a50f4a1", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4839cb59b363834b37cf3fc1f024d87eead4fd30/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4839cb59b363834b37cf3fc1f024d87eead4fd30/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=4839cb59b363834b37cf3fc1f024d87eead4fd30", "patch": "@@ -1038,6 +1038,9 @@ record_loop_exits (void)\n   edge_iterator ei;\n   edge e;\n \n+  if (!current_loops)\n+    return;\n+\n   if (current_loops->state & LOOPS_HAVE_RECORDED_EXITS)\n     return;\n   current_loops->state |= LOOPS_HAVE_RECORDED_EXITS;"}, {"sha": "c6cd7221aa7d4a088f294d43f703fa4615a1773f", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4839cb59b363834b37cf3fc1f024d87eead4fd30/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4839cb59b363834b37cf3fc1f024d87eead4fd30/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=4839cb59b363834b37cf3fc1f024d87eead4fd30", "patch": "@@ -265,6 +265,9 @@ extern bool just_once_each_iteration_p (const struct loop *, basic_block);\n extern unsigned expected_loop_iterations (const struct loop *);\n extern rtx doloop_condition_get (rtx);\n \n+void estimate_numbers_of_iterations_loop (struct loop *);\n+HOST_WIDE_INT estimated_loop_iterations_int (struct loop *, bool);\n+\n /* Loop manipulation.  */\n extern bool can_duplicate_loop_p (struct loop *loop);\n "}, {"sha": "0e86c52723858431ceb11942746e9e9dcda496c8", "filename": "gcc/predict.c", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4839cb59b363834b37cf3fc1f024d87eead4fd30/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4839cb59b363834b37cf3fc1f024d87eead4fd30/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=4839cb59b363834b37cf3fc1f024d87eead4fd30", "patch": "@@ -650,6 +650,10 @@ predict_loops (void)\n       for (j = 0; VEC_iterate (edge, exits, j, ex); j++)\n \t{\n \t  tree niter = NULL;\n+\t  HOST_WIDE_INT nitercst;\n+\t  int max = PARAM_VALUE (PARAM_MAX_PREDICTED_ITERATIONS);\n+\t  int probability;\n+\t  enum br_predictor predictor;\n \n \t  if (number_of_iterations_exit (loop, ex, &niter_desc, false))\n \t    niter = niter_desc.niter;\n@@ -658,20 +662,31 @@ predict_loops (void)\n \n \t  if (TREE_CODE (niter) == INTEGER_CST)\n \t    {\n-\t      int probability;\n-\t      int max = PARAM_VALUE (PARAM_MAX_PREDICTED_ITERATIONS);\n \t      if (host_integerp (niter, 1)\n \t\t  && compare_tree_int (niter, max-1) == -1)\n-\t\t{\n-\t\t  HOST_WIDE_INT nitercst = tree_low_cst (niter, 1) + 1;\n-\t\t  probability = ((REG_BR_PROB_BASE + nitercst / 2)\n-\t\t\t\t / nitercst);\n-\t\t}\n+\t\tnitercst = tree_low_cst (niter, 1) + 1;\n \t      else\n-\t\tprobability = ((REG_BR_PROB_BASE + max / 2) / max);\n+\t\tnitercst = max;\n+\t      predictor = PRED_LOOP_ITERATIONS;\n+\t    }\n+\t  /* If we have just one exit and we can derive some information about\n+\t     the number of iterations of the loop from the statements inside\n+\t     the loop, use it to predict this exit.  */\n+\t  else if (n_exits == 1)\n+\t    {\n+\t      nitercst = estimated_loop_iterations_int (loop, false);\n+\t      if (nitercst < 0)\n+\t\tcontinue;\n+\t      if (nitercst > max)\n+\t\tnitercst = max;\n \n-\t      predict_edge (ex, PRED_LOOP_ITERATIONS, probability);\n+\t      predictor = PRED_LOOP_ITERATIONS_GUESSED;\n \t    }\n+\t  else\n+\t    continue;\n+\n+\t  probability = ((REG_BR_PROB_BASE + nitercst / 2) / nitercst);\n+\t  predict_edge (ex, predictor, probability);\n \t}\n       VEC_free (edge, heap, exits);\n \n@@ -706,7 +721,11 @@ predict_loops (void)\n \n \t  /* Loop exit heuristics - predict an edge exiting the loop if the\n \t     conditional has no loop header successors as not taken.  */\n-\t  if (!header_found)\n+\t  if (!header_found\n+\t      /* If we already used more reliable loop exit predictors, do not\n+\t\t bother with PRED_LOOP_EXIT.  */\n+\t      && !predicted_by_p (bb, PRED_LOOP_ITERATIONS_GUESSED)\n+\t      && !predicted_by_p (bb, PRED_LOOP_ITERATIONS))\n \t    {\n \t      /* For loop with many exits we don't want to predict all exits\n \t         with the pretty large probability, because if all exits are\n@@ -1258,6 +1277,7 @@ tree_estimate_probability (void)\n   tree_bb_level_predictions ();\n \n   mark_irreducible_loops ();\n+  record_loop_exits ();\n   if (current_loops)\n     predict_loops ();\n "}, {"sha": "22474b3db40c42a962d1f71a1eef8e230141735d", "filename": "gcc/predict.def", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4839cb59b363834b37cf3fc1f024d87eead4fd30/gcc%2Fpredict.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4839cb59b363834b37cf3fc1f024d87eead4fd30/gcc%2Fpredict.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.def?ref=4839cb59b363834b37cf3fc1f024d87eead4fd30", "patch": "@@ -52,16 +52,20 @@ DEF_PREDICTOR (PRED_NO_PREDICTION, \"no prediction\", PROB_ALWAYS, 0)\n DEF_PREDICTOR (PRED_UNCONDITIONAL, \"unconditional jump\", PROB_ALWAYS,\n \t       PRED_FLAG_FIRST_MATCH)\n \n-/* Use number of loop iterations determined by loop unroller to set\n-   probability.  We don't want to use Dempster-Shaffer theory here,\n-   as the predictions is exact.  */\n+/* Use number of loop iterations determined by # of iterations\n+   analysis to set probability.  We don't want to use Dempster-Shaffer\n+   theory here, as the predictions is exact.  */\n DEF_PREDICTOR (PRED_LOOP_ITERATIONS, \"loop iterations\", PROB_ALWAYS,\n \t       PRED_FLAG_FIRST_MATCH)\n \n /* Hints dropped by user via __builtin_expect feature.  */\n DEF_PREDICTOR (PRED_BUILTIN_EXPECT, \"__builtin_expect\", PROB_VERY_LIKELY,\n \t       PRED_FLAG_FIRST_MATCH)\n \n+/* Use number of loop iterations guessed by the contents of the loop.  */\n+DEF_PREDICTOR (PRED_LOOP_ITERATIONS_GUESSED, \"guessed loop iterations\",\n+\t       PROB_ALWAYS, PRED_FLAG_FIRST_MATCH)\n+\n /* Branch containing goto is probably not taken.  */\n DEF_PREDICTOR (PRED_CONTINUE, \"continue\", HITRATE (56), 0)\n "}, {"sha": "b6750ee0021fc78e0620a96734e235f840e4d0a5", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 96, "deletions": 48, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4839cb59b363834b37cf3fc1f024d87eead4fd30/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4839cb59b363834b37cf3fc1f024d87eead4fd30/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=4839cb59b363834b37cf3fc1f024d87eead4fd30", "patch": "@@ -2543,29 +2543,85 @@ analyze_ziv_subscript (tree chrec_a,\n     fprintf (dump_file, \")\\n\");\n }\n \n-/* Get the real or estimated number of iterations for LOOPNUM, whichever is\n-   available. Return the number of iterations as a tree, or NULL_TREE if\n-   we don't know.  */\n+/* Sets NIT to the estimated number of executions of the statements in\n+   LOOP.  If CONSERVATIVE is true, we must be sure that NIT is at least as\n+   large as the number of iterations.  If we have no reliable estimate,\n+   the function returns false, otherwise returns true.  */\n \n-static tree\n-get_number_of_iters_for_loop (int loopnum)\n+static bool\n+estimated_loop_iterations (struct loop *loop, bool conservative,\n+\t\t\t   double_int *nit)\n {\n-  struct loop *loop = get_loop (loopnum);\n   tree numiter = number_of_exit_cond_executions (loop);\n \n+  /* If we have an exact value, use it.  */\n   if (TREE_CODE (numiter) == INTEGER_CST)\n-    return numiter;\n+    {\n+      *nit = tree_to_double_int (numiter);\n+      return true;\n+    }\n \n+  /* If we have a measured profile and we do not ask for a conservative bound,\n+     use it.  */\n+  if (!conservative && loop->header->count != 0)\n+    {\n+      *nit = uhwi_to_double_int (expected_loop_iterations (loop) + 1);\n+      return true;\n+    }\n+\n+  /* Finally, try using a reliable estimate on number of iterations according\n+     to the size of the accessed data, if available.  */\n+  estimate_numbers_of_iterations_loop (loop);\n   if (loop->estimate_state == EST_AVAILABLE)\n     {\n-      tree type = lang_hooks.types.type_for_size (INT_TYPE_SIZE, true);\n-      if (double_int_fits_to_tree_p (type, loop->estimated_nb_iterations))\n-\treturn double_int_to_tree (type, loop->estimated_nb_iterations);\n+      *nit = loop->estimated_nb_iterations;\n+      return true;\n     }\n \n-  return NULL_TREE;\n+  return false;\n+}\n+\n+/* Similar to estimated_loop_iterations, but returns the estimate only\n+   if it fits to HOST_WIDE_INT.  If this is not the case, or the estimate\n+   on the number of iterations of LOOP could not be derived, returns -1.  */\n+\n+HOST_WIDE_INT\n+estimated_loop_iterations_int (struct loop *loop, bool conservative)\n+{\n+  double_int nit;\n+  HOST_WIDE_INT hwi_nit;\n+\n+  if (!estimated_loop_iterations (loop, conservative, &nit))\n+    return -1;\n+\n+  if (!double_int_fits_in_shwi_p (nit))\n+    return -1;\n+  hwi_nit = double_int_to_shwi (nit);\n+\n+  return hwi_nit < 0 ? -1 : hwi_nit;\n }\n     \n+/* Similar to estimated_loop_iterations, but returns the estimate as a tree,\n+   and only if it fits to the int type.  If this is not the case, or the\n+   estimate on the number of iterations of LOOP could not be derived, returns\n+   chrec_dont_know.  */\n+\n+static tree\n+estimated_loop_iterations_tree (struct loop *loop, bool conservative)\n+{\n+  double_int nit;\n+  tree type;\n+\n+  if (!estimated_loop_iterations (loop, conservative, &nit))\n+    return chrec_dont_know;\n+\n+  type = lang_hooks.types.type_for_size (INT_TYPE_SIZE, true);\n+  if (!double_int_fits_to_tree_p (type, nit))\n+    return chrec_dont_know;\n+\n+  return double_int_to_tree (type, nit);\n+}\n+\n /* Analyze a SIV (Single Index Variable) subscript where CHREC_A is a\n    constant, and CHREC_B is an affine function.  *OVERLAPS_A and\n    *OVERLAPS_B are initialized to the functions that describe the\n@@ -2626,8 +2682,8 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t  \n \t\t  if (tree_fold_divides_p (CHREC_RIGHT (chrec_b), difference))\n \t\t    {\n-\t\t      tree numiter;\n-\t\t      int loopnum = CHREC_VARIABLE (chrec_b);\n+\t\t      HOST_WIDE_INT numiter;\n+\t\t      struct loop *loop = get_chrec_loop (chrec_b);\n \n \t\t      *overlaps_a = conflict_fn (1, affine_fn_cst (integer_zero_node));\n \t\t      tmp = fold_build2 (EXACT_DIV_EXPR, integer_type_node,\n@@ -2641,11 +2697,10 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \n \t\t      /* Perform weak-zero siv test to see if overlap is\n \t\t\t outside the loop bounds.  */\n-\t\t      numiter = get_number_of_iters_for_loop (loopnum);\n+\t\t      numiter = estimated_loop_iterations_int (loop, true);\n \n-\t\t      if (numiter != NULL_TREE\n-\t\t\t  && TREE_CODE (tmp) == INTEGER_CST\n-\t\t\t  && tree_int_cst_lt (numiter, tmp))\n+\t\t      if (numiter >= 0\n+\t\t\t  && compare_tree_int (tmp, numiter) > 0)\n \t\t\t{\n \t\t\t  free_conflict_function (*overlaps_a);\n \t\t\t  free_conflict_function (*overlaps_b);\n@@ -2709,8 +2764,8 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t  */\n \t\t  if (tree_fold_divides_p (CHREC_RIGHT (chrec_b), difference))\n \t\t    {\n-\t\t      tree numiter;\n-\t\t      int loopnum = CHREC_VARIABLE (chrec_b);\n+\t\t      HOST_WIDE_INT numiter;\n+\t\t      struct loop *loop = get_chrec_loop (chrec_b);\n \n \t\t      *overlaps_a = conflict_fn (1, affine_fn_cst (integer_zero_node));\n \t\t      tmp = fold_build2 (EXACT_DIV_EXPR,\n@@ -2721,11 +2776,10 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \n \t\t      /* Perform weak-zero siv test to see if overlap is\n \t\t\t outside the loop bounds.  */\n-\t\t      numiter = get_number_of_iters_for_loop (loopnum);\n+\t\t      numiter = estimated_loop_iterations_int (loop, true);\n \n-\t\t      if (numiter != NULL_TREE\n-\t\t\t  && TREE_CODE (tmp) == INTEGER_CST\n-\t\t\t  && tree_int_cst_lt (numiter, tmp))\n+\t\t      if (numiter >= 0\n+\t\t\t  && compare_tree_int (tmp, numiter) > 0)\n \t\t\t{\n \t\t\t  free_conflict_function (*overlaps_a);\n \t\t\t  free_conflict_function (*overlaps_b);\n@@ -2852,8 +2906,7 @@ compute_overlap_steps_for_affine_1_2 (tree chrec_a, tree chrec_b,\n {\n   bool xz_p, yz_p, xyz_p;\n   int step_x, step_y, step_z;\n-  int niter_x, niter_y, niter_z, niter;\n-  tree numiter_x, numiter_y, numiter_z;\n+  HOST_WIDE_INT niter_x, niter_y, niter_z, niter;\n   affine_fn overlaps_a_xz, overlaps_b_xz;\n   affine_fn overlaps_a_yz, overlaps_b_yz;\n   affine_fn overlaps_a_xyz, overlaps_b_xyz;\n@@ -2864,12 +2917,12 @@ compute_overlap_steps_for_affine_1_2 (tree chrec_a, tree chrec_b,\n   step_y = int_cst_value (CHREC_RIGHT (chrec_a));\n   step_z = int_cst_value (CHREC_RIGHT (chrec_b));\n \n-  numiter_x = get_number_of_iters_for_loop (CHREC_VARIABLE (CHREC_LEFT (chrec_a)));\n-  numiter_y = get_number_of_iters_for_loop (CHREC_VARIABLE (chrec_a));\n-  numiter_z = get_number_of_iters_for_loop (CHREC_VARIABLE (chrec_b));\n+  niter_x = estimated_loop_iterations_int\n+\t  \t(get_chrec_loop (CHREC_LEFT (chrec_a)), true);\n+  niter_y = estimated_loop_iterations_int (get_chrec_loop (chrec_a), true);\n+  niter_z = estimated_loop_iterations_int (get_chrec_loop (chrec_b), true);\n   \n-  if (numiter_x == NULL_TREE || numiter_y == NULL_TREE \n-      || numiter_z == NULL_TREE)\n+  if (niter_x < 0 || niter_y < 0 || niter_z < 0)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"overlap steps test failed: no iteration counts.\\n\");\n@@ -2880,10 +2933,6 @@ compute_overlap_steps_for_affine_1_2 (tree chrec_a, tree chrec_b,\n       return;\n     }\n \n-  niter_x = int_cst_value (numiter_x);\n-  niter_y = int_cst_value (numiter_y);\n-  niter_z = int_cst_value (numiter_z);\n-\n   niter = MIN (niter_x, niter_z);\n   compute_overlap_steps_for_affine_univar (niter, step_x, step_z,\n \t\t\t\t\t   &overlaps_a_xz,\n@@ -3029,13 +3078,14 @@ analyze_subscript_affine_affine (tree chrec_a,\n       if (nb_vars_a == 1 && nb_vars_b == 1)\n \t{\n \t  int step_a, step_b;\n-\t  int niter, niter_a, niter_b;\n-\t  tree numiter_a, numiter_b;\n+\t  HOST_WIDE_INT niter, niter_a, niter_b;\n \t  affine_fn ova, ovb;\n \n-\t  numiter_a = get_number_of_iters_for_loop (CHREC_VARIABLE (chrec_a));\n-\t  numiter_b = get_number_of_iters_for_loop (CHREC_VARIABLE (chrec_b));\n-\t  if (numiter_a == NULL_TREE || numiter_b == NULL_TREE)\n+\t  niter_a = estimated_loop_iterations_int\n+\t\t\t(get_chrec_loop (chrec_a), true);\n+\t  niter_b = estimated_loop_iterations_int\n+\t\t\t(get_chrec_loop (chrec_b), true);\n+\t  if (niter_a < 0 || niter_b < 0)\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"affine-affine test failed: missing iteration counts.\\n\");\n@@ -3045,8 +3095,6 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t      goto end_analyze_subs_aa;\n \t    }\n \n-\t  niter_a = int_cst_value (numiter_a);\n-\t  niter_b = int_cst_value (numiter_b);\n \t  niter = MIN (niter_a, niter_b);\n \n \t  step_a = int_cst_value (CHREC_RIGHT (chrec_a));\n@@ -3140,12 +3188,13 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t     equation: chrec_a (X0) = chrec_b (Y0).  */\n \t  int x0, y0;\n \t  int niter, niter_a, niter_b;\n-\t  tree numiter_a, numiter_b;\n \n-\t  numiter_a = get_number_of_iters_for_loop (CHREC_VARIABLE (chrec_a));\n-\t  numiter_b = get_number_of_iters_for_loop (CHREC_VARIABLE (chrec_b));\n+\t  niter_a = estimated_loop_iterations_int\n+\t\t\t(get_chrec_loop (chrec_a), true);\n+\t  niter_b = estimated_loop_iterations_int\n+\t\t\t(get_chrec_loop (chrec_b), true);\n \n-\t  if (numiter_a == NULL_TREE || numiter_b == NULL_TREE)\n+\t  if (niter_a < 0 || niter_b < 0)\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"affine-affine test failed: missing iteration counts.\\n\");\n@@ -3155,8 +3204,6 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t      goto end_analyze_subs_aa;\n \t    }\n \n-\t  niter_a = int_cst_value (numiter_a);\n-\t  niter_b = int_cst_value (numiter_b);\n \t  niter = MIN (niter_a, niter_b);\n \n \t  i0 = U[0][0] * gamma / gcd_alpha_beta;\n@@ -3481,7 +3528,8 @@ analyze_miv_subscript (tree chrec_a,\n \t in the same order.  */\n       *overlaps_a = conflict_fn (1, affine_fn_cst (integer_zero_node));\n       *overlaps_b = conflict_fn (1, affine_fn_cst (integer_zero_node));\n-      *last_conflicts = get_number_of_iters_for_loop (CHREC_VARIABLE (chrec_a));\n+      *last_conflicts = estimated_loop_iterations_tree\n+\t\t\t\t(get_chrec_loop (chrec_a), true);\n       dependence_stats.num_miv_dependent++;\n     }\n   "}, {"sha": "018e9a80529fa51db0f2827d7be4e8dbc39525ae", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 69, "deletions": 4, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4839cb59b363834b37cf3fc1f024d87eead4fd30/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4839cb59b363834b37cf3fc1f024d87eead4fd30/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=4839cb59b363834b37cf3fc1f024d87eead4fd30", "patch": "@@ -1752,6 +1752,8 @@ static void\n compute_estimated_nb_iterations (struct loop *loop)\n {\n   struct nb_iter_bound *bound;\n+  double_int bnd_val, delta;\n+  edge exit;\n  \n   gcc_assert (loop->estimate_state == EST_NOT_AVAILABLE);\n \n@@ -1760,17 +1762,79 @@ compute_estimated_nb_iterations (struct loop *loop)\n       if (!bound->realistic)\n \tcontinue;\n \n+      bnd_val = bound->bound;\n+      /* If bound->stmt is an exit, then every statement in the loop is\n+\t executed at most BND_VAL + 1 times.  If it is not an exit, then\n+\t some of the statements before it could be executed BND_VAL + 2\n+\t times, if an exit of LOOP is before stmt.  */\n+      exit = single_exit (loop);\n+\n+      if (bound->is_exit\n+\t  || (exit != NULL\n+\t      && dominated_by_p (CDI_DOMINATORS,\n+\t\t\t\t exit->src, bb_for_stmt (bound->stmt))))\n+\tdelta = double_int_one;\n+      else\n+\tdelta = double_int_two;\n+      bnd_val = double_int_add (bnd_val, delta);\n+\n+      /* If an overflow occured, ignore the result.  */\n+      if (double_int_ucmp (bnd_val, delta) < 0)\n+\tcontinue;\n+\n       /* Update only when there is no previous estimation, or when the current\n \t estimation is smaller.  */\n       if (loop->estimate_state == EST_NOT_AVAILABLE\n-\t  || double_int_ucmp (bound->bound, loop->estimated_nb_iterations) < 0)\n+\t  || double_int_ucmp (bnd_val, loop->estimated_nb_iterations) < 0)\n \t{\n \t  loop->estimate_state = EST_AVAILABLE;\n-\t  loop->estimated_nb_iterations = bound->bound;\n+\t  loop->estimated_nb_iterations = bnd_val;\n \t}\n     }\n }\n \n+/* Returns true if REF is a reference to an array at the end of a dynamically\n+   allocated structure.  If this is the case, the array may be allocated larger\n+   than its upper bound implies.  */\n+\n+static bool\n+array_at_struct_end_p (tree ref)\n+{\n+  tree base = get_base_address (ref);\n+  tree parent, field;\n+\n+  /* Unless the reference is through a pointer, the size of the array matches\n+     its declaration.  */\n+  if (!base || !INDIRECT_REF_P (base))\n+    return false;\n+  \n+  for (;handled_component_p (ref); ref = parent)\n+    {\n+      parent = TREE_OPERAND (ref, 0);\n+\n+      if (TREE_CODE (ref) == COMPONENT_REF)\n+\t{\n+\t  /* All fields of a union are at its end.  */\n+\t  if (TREE_CODE (TREE_TYPE (parent)) == UNION_TYPE)\n+\t    continue;\n+\n+\t  /* Unless the field is at the end of the struct, we are done.  */\n+\t  field = TREE_OPERAND (ref, 1);\n+\t  if (TREE_CHAIN (field))\n+\t    return false;\n+\t}\n+\n+      /* The other options are ARRAY_REF, ARRAY_RANGE_REF, VIEW_CONVERT_EXPR.\n+\t In all these cases, we might be accessing the last element, and\n+\t although in practice this will probably never happen, it is legal for\n+\t the indices of this last element to exceed the bounds of the array.\n+\t Therefore, continue checking.  */\n+    }\n+\n+  gcc_assert (INDIRECT_REF_P (ref));\n+  return true;\n+}\n+\n /* Determine information about number of iterations a LOOP from the index\n    IDX of a data reference accessed in STMT.  Callback for for_each_index.  */\n \n@@ -1789,7 +1853,8 @@ idx_infer_loop_bounds (tree base, tree *idx, void *dta)\n   bool sign;\n   struct loop *loop = data->loop;\n \n-  if (TREE_CODE (base) != ARRAY_REF)\n+  if (TREE_CODE (base) != ARRAY_REF\n+      || array_at_struct_end_p (base))\n     return true;\n \n   ev = instantiate_parameters (loop, analyze_scalar_evolution (loop, *idx));\n@@ -1974,7 +2039,7 @@ infer_loop_bounds_from_undefined (struct loop *loop)\n \n /* Records estimates on numbers of iterations of LOOP.  */\n \n-static void\n+void\n estimate_numbers_of_iterations_loop (struct loop *loop)\n {\n   VEC (edge, heap) *exits;"}]}