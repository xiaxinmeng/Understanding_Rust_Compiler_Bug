{"sha": "f19626cf3086867bd69b25c5113e159289107ce4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE5NjI2Y2YzMDg2ODY3YmQ2OWIyNWM1MTEzZTE1OTI4OTEwN2NlNA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2014-12-17T06:29:30Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2014-12-17T06:29:30Z"}, "message": "re PR fortran/54687 (Use gcc option machinery for gfortran)\n\n2014-12-17  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/54687\ngcc/\n        * flag-types.h (gfc_init_local_real, gfc_fcoarray,\n        gfc_convert): New enums; moved from fortran/.\n\ngcc/fortran/\n        * gfortran.h (gfc_option_t): Remove flags which now\n        have a Var().\n        (init_local_real, gfc_fcoarray): Moved to ../flag-types.h.\n        * libgfortran.h (unit_convert): Add comment.\n        * lang.opt (flag-convert, flag-init_real, flag-coarray):\n        Add Var() and Enum().\n        * options.c (gfc_handle_coarray_option): Remove.\n        (gfc_init_options, gfc_post_options, gfc_handle_option):\n        Update for *.opt changes.\n        * array.c: Update for flag-variable name changes.\n        * check.c: Ditto.\n        * match.c: Ditto.\n        * resolve.c: Ditto.\n        * simplify.c: Ditto.\n        * trans-array.c: Ditto.\n        * trans-decl.c: Ditto.\n        * trans-expr.c: Ditto.\n        * trans-intrinsic.c: Ditto.\n        * trans-stmt.c: Ditto.\n        * trans-types.c: Ditto.\n        * trans.c: Ditto.\n\nFrom-SVN: r218808", "tree": {"sha": "32e51ec198310663e2c4886fe09010eaa133946a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32e51ec198310663e2c4886fe09010eaa133946a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f19626cf3086867bd69b25c5113e159289107ce4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f19626cf3086867bd69b25c5113e159289107ce4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f19626cf3086867bd69b25c5113e159289107ce4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f19626cf3086867bd69b25c5113e159289107ce4/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "69044fa9eb7eac6f9176861154b7e06125209671", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69044fa9eb7eac6f9176861154b7e06125209671", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69044fa9eb7eac6f9176861154b7e06125209671"}], "stats": {"total": 388, "additions": 205, "deletions": 183}, "files": [{"sha": "461b03220cc55fc1ca75bea09ac309d08470cc7b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f19626cf3086867bd69b25c5113e159289107ce4", "patch": "@@ -1,3 +1,9 @@\n+2014-12-17  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/54687\n+\t* flag-types.h (gfc_init_local_real, gfc_fcoarray,\n+\tgfc_convert): New enums; moved from fortran/.\n+\n 2014-12-16  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* fibonacci_heap.h (min): Return m_data instead of non-existing data."}, {"sha": "81e8fb8d4da8f4b3c0d7a3493bba31aa3cd141a1", "filename": "gcc/flag-types.h", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=f19626cf3086867bd69b25c5113e159289107ce4", "patch": "@@ -263,4 +263,38 @@ enum lto_partition_model {\n   LTO_PARTITION_MAX = 4\n };\n \n+\n+/* gfortran -finit-real= values.  */\n+\n+enum gfc_init_local_real\n+{\n+  GFC_INIT_REAL_OFF = 0,\n+  GFC_INIT_REAL_ZERO,\n+  GFC_INIT_REAL_NAN,\n+  GFC_INIT_REAL_SNAN,\n+  GFC_INIT_REAL_INF,\n+  GFC_INIT_REAL_NEG_INF\n+};\n+\n+/* gfortran -fcoarray= values.  */\n+\n+enum gfc_fcoarray\n+{\n+  GFC_FCOARRAY_NONE = 0,\n+  GFC_FCOARRAY_SINGLE,\n+  GFC_FCOARRAY_LIB\n+};\n+\n+\n+/* gfortran -fconvert= values; used for unformatted I/O.\n+   Keep in sync with GFC_CONVERT_* in gcc/fortran/libgfortran.h.   */\n+enum gfc_convert\n+{\n+  GFC_FLAG_CONVERT_NATIVE = 0,\n+  GFC_FLAG_CONVERT_SWAP,\n+  GFC_FLAG_CONVERT_BIG,\n+  GFC_FLAG_CONVERT_LITTLE\n+};\n+\n+\n #endif /* ! GCC_FLAG_TYPES_H */"}, {"sha": "3f20d0a7649c50f5f3902561441f12dac85d6664", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f19626cf3086867bd69b25c5113e159289107ce4", "patch": "@@ -1,3 +1,28 @@\n+2014-12-17  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/54687\n+\t* gfortran.h (gfc_option_t): Remove flags which now\n+\thave a Var().\n+\t(init_local_real, gfc_fcoarray): Moved to ../flag-types.h.\n+\t* libgfortran.h (unit_convert): Add comment.\n+\t* lang.opt (flag-convert, flag-init_real, flag-coarray):\n+\tAdd Var() and Enum().\n+\t* options.c (gfc_handle_coarray_option): Remove.\n+\t(gfc_init_options, gfc_post_options, gfc_handle_option):\n+\tUpdate for *.opt changes.\n+\t* array.c: Update for flag-variable name changes.\n+\t* check.c: Ditto.\n+\t* match.c: Ditto.\n+\t* resolve.c: Ditto.\n+\t* simplify.c: Ditto.\n+\t* trans-array.c: Ditto.\n+\t* trans-decl.c: Ditto.\n+\t* trans-expr.c: Ditto.\n+\t* trans-intrinsic.c: Ditto.\n+\t* trans-stmt.c: Ditto.\n+\t* trans-types.c: Ditto.\n+\t* trans.c: Ditto.\n+\n 2014-12-16  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/54687"}, {"sha": "e60b938a1742a56d4d9ae3984398d52fe4c0e249", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=f19626cf3086867bd69b25c5113e159289107ce4", "patch": "@@ -208,7 +208,7 @@ gfc_match_array_ref (gfc_array_ref *ar, gfc_array_spec *as, int init,\n \treturn MATCH_ERROR;\n     }\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n+  if (flag_coarray == GFC_FCOARRAY_NONE)\n     {\n       gfc_fatal_error (\"Coarrays disabled at %C, use %<-fcoarray=%> to enable\");\n       return MATCH_ERROR;\n@@ -591,7 +591,7 @@ gfc_match_array_spec (gfc_array_spec **asp, bool match_dim, bool match_codim)\n   if (!gfc_notify_std (GFC_STD_F2008, \"Coarray declaration at %C\"))\n     goto cleanup;\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n+  if (flag_coarray == GFC_FCOARRAY_NONE)\n     {\n       gfc_fatal_error (\"Coarrays disabled at %C, use %<-fcoarray=%> to enable\");\n       goto cleanup;"}, {"sha": "95c5223de651a2a3a6ae3cba578942c4909ae7d1", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=f19626cf3086867bd69b25c5113e159289107ce4", "patch": "@@ -1481,7 +1481,7 @@ check_co_collective (gfc_expr *a, gfc_expr *image_idx, gfc_expr *stat,\n \t}\n     }\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n+  if (flag_coarray == GFC_FCOARRAY_NONE)\n     {\n       gfc_fatal_error (\"Coarrays disabled at %L, use %<-fcoarray=%> to enable\",\n \t\t       &a->where);\n@@ -2569,7 +2569,7 @@ gfc_check_lbound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n bool\n gfc_check_lcobound (gfc_expr *coarray, gfc_expr *dim, gfc_expr *kind)\n {\n-  if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n+  if (flag_coarray == GFC_FCOARRAY_NONE)\n     {\n       gfc_fatal_error (\"Coarrays disabled at %C, use %<-fcoarray=%> to enable\");\n       return false;\n@@ -4847,7 +4847,7 @@ gfc_check_image_index (gfc_expr *coarray, gfc_expr *sub)\n {\n   mpz_t nelems;\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n+  if (flag_coarray == GFC_FCOARRAY_NONE)\n     {\n       gfc_fatal_error (\"Coarrays disabled at %C, use %<-fcoarray=%> to enable\");\n       return false;\n@@ -4885,7 +4885,7 @@ gfc_check_image_index (gfc_expr *coarray, gfc_expr *sub)\n bool\n gfc_check_num_images (gfc_expr *distance, gfc_expr *failed)\n {\n-  if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n+  if (flag_coarray == GFC_FCOARRAY_NONE)\n     {\n       gfc_fatal_error (\"Coarrays disabled at %C, use %<-fcoarray=%> to enable\");\n       return false;\n@@ -4927,7 +4927,7 @@ gfc_check_num_images (gfc_expr *distance, gfc_expr *failed)\n bool\n gfc_check_this_image (gfc_expr *coarray, gfc_expr *dim, gfc_expr *distance)\n {\n-  if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n+  if (flag_coarray == GFC_FCOARRAY_NONE)\n     {\n       gfc_fatal_error (\"Coarrays disabled at %C, use %<-fcoarray=%> to enable\");\n       return false;\n@@ -5126,7 +5126,7 @@ gfc_check_ubound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n bool\n gfc_check_ucobound (gfc_expr *coarray, gfc_expr *dim, gfc_expr *kind)\n {\n-  if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n+  if (flag_coarray == GFC_FCOARRAY_NONE)\n     {\n       gfc_fatal_error (\"Coarrays disabled at %C, use %<-fcoarray=%> to enable\");\n       return false;"}, {"sha": "41c6c5725ea274272b94f4864cbfef4f7599cf9e", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=f19626cf3086867bd69b25c5113e159289107ce4", "patch": "@@ -599,18 +599,6 @@ enum gfc_isym_id\n };\n typedef enum gfc_isym_id gfc_isym_id;\n \n-\n-typedef enum\n-{\n-  GFC_INIT_REAL_OFF = 0,\n-  GFC_INIT_REAL_ZERO,\n-  GFC_INIT_REAL_NAN,\n-  GFC_INIT_REAL_SNAN,\n-  GFC_INIT_REAL_INF,\n-  GFC_INIT_REAL_NEG_INF\n-}\n-init_local_real;\n-\n typedef enum\n {\n   GFC_INIT_LOGICAL_OFF = 0,\n@@ -633,14 +621,6 @@ typedef enum\n }\n init_local_integer;\n \n-typedef enum\n-{\n-  GFC_FCOARRAY_NONE = 0,\n-  GFC_FCOARRAY_SINGLE,\n-  GFC_FCOARRAY_LIB\n-}\n-gfc_fcoarray;\n-\n typedef enum\n {\n   GFC_ENABLE_REVERSE,\n@@ -2436,19 +2416,16 @@ typedef struct\n   int flag_d_lines;\n   int flag_init_integer;\n   int flag_init_integer_value;\n-  int flag_init_real;\n   int flag_init_logical;\n   int flag_init_character;\n   char flag_init_character_value;\n \n   int fpe;\n   int fpe_summary;\n   int rtcheck;\n-  gfc_fcoarray coarray;\n \n   int warn_std;\n   int allow_std;\n-  int convert;\n }\n gfc_option_t;\n "}, {"sha": "95be3658e4f18c74951a32b2ed25e36e6cbdd001", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 49, "deletions": 16, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=f19626cf3086867bd69b25c5113e159289107ce4", "patch": "@@ -381,21 +381,24 @@ fcheck-array-temporaries\n Fortran\n Produce a warning at runtime if a array temporary has been created for a procedure argument\n \n-fconvert=big-endian\n-Fortran RejectNegative\n-Use big-endian format for unformatted files\n+fconvert=\n+Fortran RejectNegative Joined Enum(gfc_convert) Var(flag_convert) Init(GFC_FLAG_CONVERT_NATIVE)\n+-fconvert=<big-endian|little-endian|native|swap> The endianness used for unformatted files.\n \n-fconvert=little-endian\n-Fortran RejectNegative\n-Use little-endian format for unformatted files\n+Enum\n+Name(gfc_convert) Type(enum gfc_convert) UnknownError(Unrecognized option to endianess value: %qs)\n \n-fconvert=native\n-Fortran RejectNegative\n-Use native format for unformatted files\n+EnumValue\n+Enum(gfc_convert) String(big-endian) Value(GFC_FLAG_CONVERT_BIG)\n \n-fconvert=swap\n-Fortran RejectNegative\n-Swap endianness for unformatted files\n+EnumValue\n+Enum(gfc_convert) String(little-endian) Value(GFC_FLAG_CONVERT_LITTLE)\n+\n+EnumValue\n+Enum(gfc_convert) String(native) Value(GFC_FLAG_CONVERT_NATIVE)\n+\n+EnumValue\n+Enum(gfc_convert) String(swap) Value(GFC_FLAG_CONVERT_SWAP)\n \n fcray-pointer\n Fortran Var(flag_cray_pointer)\n@@ -518,8 +521,26 @@ Fortran RejectNegative Joined\n -finit-logical=<true|false>\tInitialize local logical variables\n \n finit-real=\n-Fortran RejectNegative Joined\n--finit-real=<zero|nan|inf|-inf>\tInitialize local real variables\n+Fortran RejectNegative ToLower Joined Enum(gfc_init_local_real) Var(flag_init_real) Init(GFC_INIT_REAL_OFF)\n+-finit-real=<zero|snan|nan|inf|-inf>\tInitialize local real variables\n+\n+Enum\n+Name(gfc_init_local_real) Type(enum gfc_init_local_real) UnknownError(Unrecognized option to floating-point init value: %qs)\n+\n+EnumValue\n+Enum(gfc_init_local_real) String(zero) Value(GFC_INIT_REAL_ZERO)\n+\n+EnumValue\n+Enum(gfc_init_local_real) String(snan) Value(GFC_INIT_REAL_SNAN)\n+\n+EnumValue\n+Enum(gfc_init_local_real) String(nan) Value(GFC_INIT_REAL_NAN)\n+\n+EnumValue\n+Enum(gfc_init_local_real) String(inf) Value(GFC_INIT_REAL_INF)\n+\n+EnumValue\n+Enum(gfc_init_local_real) String(-inf) Value(GFC_INIT_REAL_NEG_INF)\n \n fmax-array-constructor=\n Fortran RejectNegative Joined UInteger Var(flag_max_array_constructor) Init(65535)\n@@ -614,8 +635,20 @@ Fortran Var(flag_repack_arrays)\n Copy array sections into a contiguous block on procedure entry\n \n fcoarray=\n-Fortran RejectNegative JoinedOrMissing\n--fcoarray=[...]\tSpecify which coarray parallelization should be used\n+Fortran RejectNegative Joined Enum(gfc_fcoarray) Var(flag_coarray) Init(GFC_FCOARRAY_NONE)\n+-fcoarray=<none|single|lib>\tSpecify which coarray parallelization should be used\n+\n+Enum\n+Name(gfc_fcoarray) Type(enum gfc_fcoarray) UnknownError(Unrecognized option: %qs)\n+\n+EnumValue\n+Enum(gfc_fcoarray) String(none) Value(GFC_FCOARRAY_NONE)\n+\n+EnumValue\n+Enum(gfc_fcoarray) String(single) Value(GFC_FCOARRAY_SINGLE)\n+\n+EnumValue\n+Enum(gfc_fcoarray) String(lib) Value(GFC_FCOARRAY_LIB)\n \n fcheck=\n Fortran RejectNegative JoinedOrMissing"}, {"sha": "e8ac92698f9a51d12bfbabeedc4627963ecac8aa", "filename": "gcc/fortran/libgfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flibgfortran.h?ref=f19626cf3086867bd69b25c5113e159289107ce4", "patch": "@@ -70,6 +70,7 @@ along with GCC; see the file COPYING3.  If not see\n \n \n /* Possible values for the CONVERT I/O specifier.  */\n+/* Keep in sync with GFC_FLAG_CONVERT_* in gcc/flags.h.  */\n typedef enum\n {\n   GFC_CONVERT_NONE = -1,"}, {"sha": "fb68eec6ee87530ec6a54b700096b4bb8ccf5d4f", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=f19626cf3086867bd69b25c5113e159289107ce4", "patch": "@@ -1663,7 +1663,7 @@ gfc_match_critical (void)\n   if (!gfc_notify_std (GFC_STD_F2008, \"CRITICAL statement at %C\"))\n     return MATCH_ERROR;\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n+  if (flag_coarray == GFC_FCOARRAY_NONE)\n     {\n        gfc_fatal_error (\"Coarrays disabled at %C, use %<-fcoarray=%> to \"\n \t\t\t\"enable\");\n@@ -2725,7 +2725,7 @@ lock_unlock_statement (gfc_statement st)\n \n   gfc_unset_implicit_pure (NULL);\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n+  if (flag_coarray == GFC_FCOARRAY_NONE)\n     {\n        gfc_fatal_error (\"Coarrays disabled at %C, use %<-fcoarray=%> to enable\");\n        return MATCH_ERROR;\n@@ -2921,7 +2921,7 @@ sync_statement (gfc_statement st)\n   if (!gfc_notify_std (GFC_STD_F2008, \"SYNC statement at %C\"))\n     return MATCH_ERROR;\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n+  if (flag_coarray == GFC_FCOARRAY_NONE)\n     {\n        gfc_fatal_error (\"Coarrays disabled at %C, use %<-fcoarray=%> to \"\n \t\t\t\"enable\");"}, {"sha": "307688a1b69336cb851faf418e850dfacaafde11", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 1, "deletions": 54, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=f19626cf3086867bd69b25c5113e159289107ce4", "patch": "@@ -84,14 +84,12 @@ gfc_init_options (unsigned int decoded_options_count,\n   gfc_option.max_continue_fixed = 255;\n   gfc_option.max_continue_free = 255;\n   gfc_option.max_identifier_length = GFC_MAX_SYMBOL_LEN;\n-  gfc_option.convert = GFC_CONVERT_NATIVE;\n   gfc_option.max_errors = 25;\n \n   gfc_option.flag_preprocessed = 0;\n   gfc_option.flag_d_lines = -1;\n   gfc_option.flag_init_integer = GFC_INIT_INTEGER_OFF;\n   gfc_option.flag_init_integer_value = 0;\n-  gfc_option.flag_init_real = GFC_INIT_REAL_OFF;\n   gfc_option.flag_init_logical = GFC_INIT_LOGICAL_OFF;\n   gfc_option.flag_init_character = GFC_INIT_CHARACTER_OFF;\n   gfc_option.flag_init_character_value = (char)0;\n@@ -102,7 +100,6 @@ gfc_init_options (unsigned int decoded_options_count,\n \t\t\t   | GFC_FPE_ZERO | GFC_FPE_OVERFLOW\n \t\t\t   | GFC_FPE_UNDERFLOW;\n   gfc_option.rtcheck = 0;\n-  gfc_option.coarray = GFC_FCOARRAY_NONE;\n \n   /* ??? Wmissing-include-dirs is disabled by default in C/C++ but\n      enabled by default in Fortran.  Ideally, we should express this\n@@ -468,20 +465,6 @@ gfc_handle_fpe_option (const char *arg, bool trap)\n }\n \n \n-static void\n-gfc_handle_coarray_option (const char *arg)\n-{\n-  if (strcmp (arg, \"none\") == 0)\n-    gfc_option.coarray = GFC_FCOARRAY_NONE;\n-  else if (strcmp (arg, \"single\") == 0)\n-    gfc_option.coarray = GFC_FCOARRAY_SINGLE;\n-  else if (strcmp (arg, \"lib\") == 0)\n-    gfc_option.coarray = GFC_FCOARRAY_LIB;\n-  else\n-    gfc_fatal_error (\"Argument to %<-fcoarray%> is not valid: %s\", arg);\n-}\n-\n-\n static void\n gfc_handle_runtime_check_option (const char *arg)\n {\n@@ -596,7 +579,7 @@ gfc_handle_option (size_t scode, const char *arg, int value,\n     case OPT_finit_local_zero:\n       gfc_option.flag_init_integer = GFC_INIT_INTEGER_ON;\n       gfc_option.flag_init_integer_value = 0;\n-      gfc_option.flag_init_real = GFC_INIT_REAL_ZERO;\n+      flag_init_real = GFC_INIT_REAL_ZERO;\n       gfc_option.flag_init_logical = GFC_INIT_LOGICAL_FALSE;\n       gfc_option.flag_init_character = GFC_INIT_CHARACTER_ON;\n       gfc_option.flag_init_character_value = (char)0;\n@@ -612,22 +595,6 @@ gfc_handle_option (size_t scode, const char *arg, int value,\n \t\t\t arg);\n       break;\n \n-    case OPT_finit_real_:\n-      if (!strcasecmp (arg, \"zero\"))\n-\tgfc_option.flag_init_real = GFC_INIT_REAL_ZERO;\n-      else if (!strcasecmp (arg, \"nan\"))\n-\tgfc_option.flag_init_real = GFC_INIT_REAL_NAN;\n-      else if (!strcasecmp (arg, \"snan\"))\n-\tgfc_option.flag_init_real = GFC_INIT_REAL_SNAN;\n-      else if (!strcasecmp (arg, \"inf\"))\n-\tgfc_option.flag_init_real = GFC_INIT_REAL_INF;\n-      else if (!strcasecmp (arg, \"-inf\"))\n-\tgfc_option.flag_init_real = GFC_INIT_REAL_NEG_INF;\n-      else\n-\tgfc_fatal_error (\"Unrecognized option to %<-finit-real%>: %s\",\n-\t\t\t arg);\n-      break;\n-\n     case OPT_finit_integer_:\n       gfc_option.flag_init_integer = GFC_INIT_INTEGER_ON;\n       gfc_option.flag_init_integer_value = atoi (arg);\n@@ -712,29 +679,9 @@ gfc_handle_option (size_t scode, const char *arg, int value,\n       /* Handled in language-independent code.  */\n       break;\n \n-    case OPT_fconvert_little_endian:\n-      gfc_option.convert = GFC_CONVERT_LITTLE;\n-      break;\n-\n-    case OPT_fconvert_big_endian:\n-      gfc_option.convert = GFC_CONVERT_BIG;\n-      break;\n-\n-    case OPT_fconvert_native:\n-      gfc_option.convert = GFC_CONVERT_NATIVE;\n-      break;\n-\n-    case OPT_fconvert_swap:\n-      gfc_option.convert = GFC_CONVERT_SWAP;\n-      break;\n-\n     case OPT_fcheck_:\n       gfc_handle_runtime_check_option (arg);\n       break;\n-\n-    case OPT_fcoarray_:\n-      gfc_handle_coarray_option (arg);\n-      break;\n     }\n \n   Fortran_handle_option_auto (&global_options, &global_options_set, "}, {"sha": "3b8b8695bc16ec30c1ce9db5bc1a6f2d70df37a6", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=f19626cf3086867bd69b25c5113e159289107ce4", "patch": "@@ -5091,7 +5091,7 @@ resolve_variable (gfc_expr *e)\n   if (t)\n     expression_rank (e);\n \n-  if (t && gfc_option.coarray == GFC_FCOARRAY_LIB && gfc_is_coindexed (e))\n+  if (t && flag_coarray == GFC_FCOARRAY_LIB && gfc_is_coindexed (e))\n     add_caf_get_intrinsic (e);\n \n   return t;\n@@ -8526,7 +8526,7 @@ resolve_critical (gfc_code *code)\n   char name[GFC_MAX_SYMBOL_LEN];\n   static int serial = 0;\n \n-  if (gfc_option.coarray != GFC_FCOARRAY_LIB)\n+  if (flag_coarray != GFC_FCOARRAY_LIB)\n     return;\n \n   symtree = gfc_find_symtree (gfc_current_ns->sym_root,\n@@ -9398,7 +9398,7 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n      the LHS is (re)allocatable or has a vector subscript.  If the LHS is a\n      noncoindexed array and the RHS is a coindexed scalar, use the normal code\n      path.  */\n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB\n+  if (flag_coarray == GFC_FCOARRAY_LIB\n       && (lhs_coindexed\n \t  || (code->expr2->expr_type == EXPR_FUNCTION\n \t      && code->expr2->value.function.isym\n@@ -10689,7 +10689,7 @@ build_default_init_expr (gfc_symbol *sym)\n       break;\n \n     case BT_REAL:\n-      switch (gfc_option.flag_init_real)\n+      switch (flag_init_real)\n \t{\n \tcase GFC_INIT_REAL_SNAN:\n \t  init_expr->is_snan = 1;\n@@ -10718,7 +10718,7 @@ build_default_init_expr (gfc_symbol *sym)\n       break;\n \n     case BT_COMPLEX:\n-      switch (gfc_option.flag_init_real)\n+      switch (flag_init_real)\n \t{\n \tcase GFC_INIT_REAL_SNAN:\n \t  init_expr->is_snan = 1;"}, {"sha": "d46c5dbee74afa3dd31efe1610e41c7968c6e4a4", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=f19626cf3086867bd69b25c5113e159289107ce4", "patch": "@@ -3324,7 +3324,7 @@ simplify_bound_dim (gfc_expr *array, gfc_expr *kind, int d, int upper,\n   /* The last dimension of an assumed-size array is special.  */\n   if ((!coarray && d == as->rank && as->type == AS_ASSUMED_SIZE && !upper)\n       || (coarray && d == as->rank + as->corank\n-\t  && (!upper || gfc_option.coarray == GFC_FCOARRAY_SINGLE)))\n+\t  && (!upper || flag_coarray == GFC_FCOARRAY_SINGLE)))\n     {\n       if (as->lower[d-1]->expr_type == EXPR_CONSTANT)\n \t{\n@@ -4633,13 +4633,13 @@ gfc_simplify_num_images (gfc_expr *distance ATTRIBUTE_UNUSED, gfc_expr *failed)\n {\n   gfc_expr *result;\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n+  if (flag_coarray == GFC_FCOARRAY_NONE)\n     {\n       gfc_fatal_error (\"Coarrays disabled at %C, use %<-fcoarray=%> to enable\");\n       return &gfc_bad_expr;\n     }\n \n-  if (gfc_option.coarray != GFC_FCOARRAY_SINGLE)\n+  if (flag_coarray != GFC_FCOARRAY_SINGLE)\n     return NULL;\n \n   if (failed && failed->expr_type != EXPR_CONSTANT)\n@@ -6525,7 +6525,7 @@ gfc_simplify_image_index (gfc_expr *coarray, gfc_expr *sub)\n \n   gcc_assert (sub_cons == NULL);\n \n-  if (gfc_option.coarray != GFC_FCOARRAY_SINGLE && !first_image)\n+  if (flag_coarray != GFC_FCOARRAY_SINGLE && !first_image)\n     return NULL;\n \n   result = gfc_get_constant_expr (BT_INTEGER, gfc_default_integer_kind,\n@@ -6543,7 +6543,7 @@ gfc_expr *\n gfc_simplify_this_image (gfc_expr *coarray, gfc_expr *dim,\n \t\t\t gfc_expr *distance ATTRIBUTE_UNUSED)\n {\n-  if (gfc_option.coarray != GFC_FCOARRAY_SINGLE)\n+  if (flag_coarray != GFC_FCOARRAY_SINGLE)\n     return NULL;\n \n   /* If no coarray argument has been passed or when the first argument"}, {"sha": "e061dcf766a3cd22fe082ee93e070a6d065578ee", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=f19626cf3086867bd69b25c5113e159289107ce4", "patch": "@@ -298,7 +298,7 @@ gfc_conv_descriptor_token (tree desc)\n \n   type = TREE_TYPE (desc);\n   gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n-  gcc_assert (gfc_option.coarray == GFC_FCOARRAY_LIB);\n+  gcc_assert (flag_coarray == GFC_FCOARRAY_LIB);\n   field = gfc_advance_chain (TYPE_FIELDS (type), CAF_TOKEN_FIELD);\n \n   /* Should be a restricted pointer - except in the finalization wrapper.  */\n@@ -5277,7 +5277,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   pointer = gfc_conv_descriptor_data_get (se->expr);\n   STRIP_NOPS (pointer);\n \n-  if (coarray && gfc_option.coarray == GFC_FCOARRAY_LIB)\n+  if (coarray && flag_coarray == GFC_FCOARRAY_LIB)\n     token = gfc_build_addr_expr (NULL_TREE,\n \t\t\t\t gfc_conv_descriptor_token (se->expr));\n \n@@ -5360,7 +5360,7 @@ gfc_array_deallocate (tree descriptor, tree pstat, tree errmsg, tree errlen,\n      the allocation status may not be changed.  */\n   tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n \t\t\t var, build_int_cst (TREE_TYPE (var), 0));\n-  if (pstat != NULL_TREE && coarray && gfc_option.coarray == GFC_FCOARRAY_LIB)\n+  if (pstat != NULL_TREE && coarray && flag_coarray == GFC_FCOARRAY_LIB)\n     {\n       tree cond;\n       tree stat = build_fold_indirect_ref_loc (input_location, pstat);\n@@ -7264,7 +7264,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,\n \t\t  gfc_add_modify (&se->pre, new_field, old_field);\n \t\t}\n \n-\t      if (gfc_option.coarray == GFC_FCOARRAY_LIB\n+\t      if (flag_coarray == GFC_FCOARRAY_LIB\n \t\t  && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (old_desc))\n \t\t  && GFC_TYPE_ARRAY_AKIND (TREE_TYPE (old_desc))\n \t\t     == GFC_ARRAY_ALLOCATABLE)"}, {"sha": "494d8aa905eb03e06b284b0f16e7f731914b569a", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=f19626cf3086867bd69b25c5113e159289107ce4", "patch": "@@ -626,7 +626,7 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n   if (!sym->attr.use_assoc\n \t&& (sym->attr.save != SAVE_NONE || sym->attr.data\n \t    || (sym->value && sym->ns->proc_name->attr.is_main_program)\n-\t    || (gfc_option.coarray == GFC_FCOARRAY_LIB\n+\t    || (flag_coarray == GFC_FCOARRAY_LIB\n \t\t&& sym->attr.codimension && !sym->attr.allocatable)))\n     TREE_STATIC (decl) = 1;\n \n@@ -814,7 +814,7 @@ gfc_build_qualified_array (tree decl, gfc_symbol * sym)\n   nest = (procns->proc_name->backend_decl != current_function_decl)\n \t && !sym->attr.contained;\n \n-  if (sym->attr.codimension && gfc_option.coarray == GFC_FCOARRAY_LIB\n+  if (sym->attr.codimension && flag_coarray == GFC_FCOARRAY_LIB\n       && sym->as->type != AS_ASSUMED_SHAPE\n       && GFC_TYPE_ARRAY_CAF_TOKEN (type) == NULL_TREE)\n     {\n@@ -1548,7 +1548,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n       && (sym->attr.save || sym->ns->proc_name->attr.is_main_program\n \t  || flag_max_stack_var_size == 0\n \t  || sym->attr.data || sym->ns->proc_name->attr.flavor == FL_MODULE)\n-      && (gfc_option.coarray != GFC_FCOARRAY_LIB\n+      && (flag_coarray != GFC_FCOARRAY_LIB\n \t  || !sym->attr.codimension || sym->attr.allocatable))\n     {\n       /* Add static initializer. For procedures, it is only needed if\n@@ -2301,7 +2301,7 @@ create_function_arglist (gfc_symbol * sym)\n \n       /* Coarrays which are descriptorless or assumed-shape pass with\n \t -fcoarray=lib the token and the offset as hidden arguments.  */\n-      if (gfc_option.coarray == GFC_FCOARRAY_LIB\n+      if (flag_coarray == GFC_FCOARRAY_LIB\n \t  && ((f->sym->ts.type != BT_CLASS && f->sym->attr.codimension\n \t       && !f->sym->attr.allocatable)\n \t      || (f->sym->ts.type == BT_CLASS\n@@ -3327,7 +3327,7 @@ gfc_build_builtin_function_decls (void)\n   TREE_NOTHROW (gfor_fndecl_associated) = 1;\n \n   /* Coarray library calls.  */\n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+  if (flag_coarray == GFC_FCOARRAY_LIB)\n     {\n       tree pint_type, pppchar_type;\n \n@@ -3890,7 +3890,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \n \t  if (CLASS_DATA (sym)->attr.dimension\n \t      || (CLASS_DATA (sym)->attr.codimension\n-\t\t  && gfc_option.coarray != GFC_FCOARRAY_LIB))\n+\t\t  && flag_coarray != GFC_FCOARRAY_LIB))\n \t    {\n \t      tmp = gfc_class_data_get (sym->backend_decl);\n \t      tmp = gfc_build_null_descriptor (TREE_TYPE (tmp));\n@@ -4683,7 +4683,7 @@ gfc_emit_parameter_debug_info (gfc_symbol *sym)\n \t\t\t\t   sym->attr.dimension, false))\n     return;\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB && sym->attr.codimension)\n+  if (flag_coarray == GFC_FCOARRAY_LIB && sym->attr.codimension)\n     return;\n \n   /* Create the decl for the variable or constant.  */\n@@ -4873,7 +4873,7 @@ gfc_generate_module_vars (gfc_namespace * ns)\n   gfc_traverse_ns (ns, gfc_create_module_variable);\n   gfc_traverse_ns (ns, create_module_nml_decl);\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB && has_coarray_vars)\n+  if (flag_coarray == GFC_FCOARRAY_LIB && has_coarray_vars)\n     generate_coarray_init (ns);\n \n   cur_module = NULL;\n@@ -5372,7 +5372,7 @@ create_main_function (tree fndecl)\n   /* Call some libgfortran initialization routines, call then MAIN__().  */\n \n   /* Call _gfortran_caf_init (*argc, ***argv).  */\n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+  if (flag_coarray == GFC_FCOARRAY_LIB)\n     {\n       tree pint_type, pppchar_type;\n       pint_type = build_pointer_type (integer_type_node);\n@@ -5476,12 +5476,11 @@ create_main_function (tree fndecl)\n   /* If this is the main program and an -fconvert option was provided,\n      add a call to set_convert.  */\n \n-  if (gfc_option.convert != GFC_CONVERT_NATIVE)\n+  if (flag_convert != GFC_FLAG_CONVERT_NATIVE)\n     {\n       tmp = build_call_expr_loc (input_location,\n \t\t\t     gfor_fndecl_set_convert, 1,\n-\t\t\t     build_int_cst (integer_type_node,\n-\t\t\t\t\t    gfc_option.convert));\n+\t\t\t     build_int_cst (integer_type_node, flag_convert));\n       gfc_add_expr_to_block (&body, tmp);\n     }\n \n@@ -5515,7 +5514,7 @@ create_main_function (tree fndecl)\n   TREE_USED (fndecl) = 1;\n \n   /* Coarray: Call _gfortran_caf_finalize(void).  */\n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+  if (flag_coarray == GFC_FCOARRAY_LIB)\n     {\n       /* Per F2008, 8.5.1 END of the main program implies a\n \t SYNC MEMORY.  */\n@@ -5705,7 +5704,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n   has_coarray_vars = false;\n   generate_local_vars (ns);\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB && has_coarray_vars)\n+  if (flag_coarray == GFC_FCOARRAY_LIB && has_coarray_vars)\n     generate_coarray_init (ns);\n \n   /* Keep the parent fake result declaration in module functions\n@@ -5895,7 +5894,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n \t If there are static coarrays in this function, the nested _caf_init\n \t function has already called cgraph_create_node, which also created\n \t the cgraph node for this function.  */\n-      if (!has_coarray_vars || gfc_option.coarray != GFC_FCOARRAY_LIB)\n+      if (!has_coarray_vars || flag_coarray != GFC_FCOARRAY_LIB)\n \t(void) cgraph_node::create (fndecl);\n     }\n   else\n@@ -6026,7 +6025,7 @@ gfc_process_block_locals (gfc_namespace* ns)\n \n   generate_local_vars (ns);\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB && has_coarray_vars)\n+  if (flag_coarray == GFC_FCOARRAY_LIB && has_coarray_vars)\n     generate_coarray_init (ns);\n \n   decl = saved_local_decls;"}, {"sha": "7772dcafa494372466394dc665ae1ddee80dce74", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=f19626cf3086867bd69b25c5113e159289107ce4", "patch": "@@ -4999,7 +4999,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n       /* For descriptorless coarrays and assumed-shape coarray dummies, we\n \t pass the token and the offset as additional arguments.  */\n-      if (fsym && e == NULL && gfc_option.coarray == GFC_FCOARRAY_LIB\n+      if (fsym && e == NULL && flag_coarray == GFC_FCOARRAY_LIB\n \t  && ((fsym->ts.type != BT_CLASS && fsym->attr.codimension\n \t       && !fsym->attr.allocatable)\n \t      || (fsym->ts.type == BT_CLASS\n@@ -5011,7 +5011,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  vec_safe_push (stringargs, build_int_cst (gfc_array_index_type, 0));\n \t  gcc_assert (fsym->attr.optional);\n \t}\n-      else if (fsym && gfc_option.coarray == GFC_FCOARRAY_LIB\n+      else if (fsym && flag_coarray == GFC_FCOARRAY_LIB\n \t       && ((fsym->ts.type != BT_CLASS && fsym->attr.codimension\n \t\t    && !fsym->attr.allocatable)\n \t\t   || (fsym->ts.type == BT_CLASS"}, {"sha": "0cce3cb3980d590463869e301f5cc676114d0cc9", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=f19626cf3086867bd69b25c5113e159289107ce4", "patch": "@@ -1106,7 +1106,7 @@ gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind,\n   tree caf_decl, token, offset, image_index, tmp;\n   tree res_var, dst_var, type, kind, vec;\n \n-  gcc_assert (gfc_option.coarray == GFC_FCOARRAY_LIB);\n+  gcc_assert (flag_coarray == GFC_FCOARRAY_LIB);\n \n   if (se->ss && se->ss->info->useflags)\n     {\n@@ -1236,7 +1236,7 @@ conv_caf_send (gfc_code *code) {\n   tree lhs_type = NULL_TREE;\n   tree vec = null_pointer_node, rhs_vec = null_pointer_node;\n \n-  gcc_assert (gfc_option.coarray == GFC_FCOARRAY_LIB);\n+  gcc_assert (flag_coarray == GFC_FCOARRAY_LIB);\n \n   lhs_expr = code->ext.actual->expr;\n   rhs_expr = code->ext.actual->next->expr;\n@@ -1404,7 +1404,7 @@ trans_this_image (gfc_se * se, gfc_expr *expr)\n     distance = expr->value.function.actual->expr;\n \n   /* The case -fcoarray=single is handled elsewhere.  */\n-  gcc_assert (gfc_option.coarray != GFC_FCOARRAY_SINGLE);\n+  gcc_assert (flag_coarray != GFC_FCOARRAY_SINGLE);\n \n   /* Argument-free version: THIS_IMAGE().  */\n   if (distance || expr->value.function.actual->expr == NULL)\n@@ -1716,7 +1716,7 @@ trans_image_index (gfc_se * se, gfc_expr *expr)\n \n   /* Return 0 if \"coindex\" exceeds num_images().  */\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_SINGLE)\n+  if (flag_coarray == GFC_FCOARRAY_SINGLE)\n     num_images = build_int_cst (type, 1);\n   else\n     {\n@@ -2098,7 +2098,7 @@ conv_intrinsic_cobound (gfc_se * se, gfc_expr * expr)\n          where size is the product of the extent of all but the last\n \t codimension.  */\n \n-      if (gfc_option.coarray != GFC_FCOARRAY_SINGLE && corank > 1)\n+      if (flag_coarray != GFC_FCOARRAY_SINGLE && corank > 1)\n \t{\n           tree cosize;\n \n@@ -2116,7 +2116,7 @@ conv_intrinsic_cobound (gfc_se * se, gfc_expr * expr)\n \t  resbound = fold_build2_loc (input_location, PLUS_EXPR,\n \t\t\t\t      gfc_array_index_type, resbound, tmp);\n \t}\n-      else if (gfc_option.coarray != GFC_FCOARRAY_SINGLE)\n+      else if (flag_coarray != GFC_FCOARRAY_SINGLE)\n \t{\n \t  /* ubound = lbound + num_images() - 1.  */\n \t  tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_num_images,\n@@ -8137,7 +8137,7 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n     case GFC_ISYM_THIS_IMAGE:\n       /* For num_images() == 1, handle as LCOBOUND.  */\n       if (expr->value.function.actual->expr\n-\t  && gfc_option.coarray == GFC_FCOARRAY_SINGLE)\n+\t  && flag_coarray == GFC_FCOARRAY_SINGLE)\n \tconv_intrinsic_cobound (se, expr);\n       else\n \ttrans_this_image (se, expr);\n@@ -8592,16 +8592,16 @@ conv_co_collective (gfc_code *code)\n       gfc_add_block_to_block (&block, &argse.pre);\n       gfc_add_block_to_block (&post_block, &argse.post);\n       stat = argse.expr;\n-      if (gfc_option.coarray != GFC_FCOARRAY_SINGLE)\n+      if (flag_coarray != GFC_FCOARRAY_SINGLE)\n \tstat = gfc_build_addr_expr (NULL_TREE, stat);\n     }\n-  else if (gfc_option.coarray == GFC_FCOARRAY_SINGLE)\n+  else if (flag_coarray == GFC_FCOARRAY_SINGLE)\n     stat = NULL_TREE;\n   else\n     stat = null_pointer_node;\n \n   /* Early exit for GFC_FCOARRAY_SINGLE.  */\n-  if (gfc_option.coarray == GFC_FCOARRAY_SINGLE)\n+  if (flag_coarray == GFC_FCOARRAY_SINGLE)\n     {\n       if (stat != NULL_TREE)\n \tgfc_add_modify (&block, stat,\n@@ -8761,7 +8761,7 @@ conv_intrinsic_atomic_op (gfc_code *code)\n   atom = argse.expr;\n \n   gfc_init_se (&argse, NULL);\n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB\n+  if (flag_coarray == GFC_FCOARRAY_LIB\n       && code->ext.actual->next->expr->ts.kind == atom_expr->ts.kind)\n     argse.want_pointer = 1;\n   gfc_conv_expr (&argse, code->ext.actual->next->expr);\n@@ -8777,12 +8777,12 @@ conv_intrinsic_atomic_op (gfc_code *code)\n     case GFC_ISYM_ATOMIC_OR:\n     case GFC_ISYM_ATOMIC_XOR:\n       stat_expr = code->ext.actual->next->next->expr;\n-      if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+      if (flag_coarray == GFC_FCOARRAY_LIB)\n \told = null_pointer_node;\n       break;\n     default:\n       gfc_init_se (&argse, NULL);\n-      if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+      if (flag_coarray == GFC_FCOARRAY_LIB)\n \targse.want_pointer = 1;\n       gfc_conv_expr (&argse, code->ext.actual->next->next->expr);\n       gfc_add_block_to_block (&block, &argse.pre);\n@@ -8796,17 +8796,17 @@ conv_intrinsic_atomic_op (gfc_code *code)\n     {\n       gcc_assert (stat_expr->expr_type == EXPR_VARIABLE);\n       gfc_init_se (&argse, NULL);\n-      if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+      if (flag_coarray == GFC_FCOARRAY_LIB)\n \targse.want_pointer = 1;\n       gfc_conv_expr_val (&argse, stat_expr);\n       gfc_add_block_to_block (&block, &argse.pre);\n       gfc_add_block_to_block (&post_block, &argse.post);\n       stat = argse.expr;\n     }\n-  else if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+  else if (flag_coarray == GFC_FCOARRAY_LIB)\n     stat = null_pointer_node;\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+  if (flag_coarray == GFC_FCOARRAY_LIB)\n     {\n       tree image_index, caf_decl, offset, token;\n       int op;\n@@ -8960,7 +8960,7 @@ conv_intrinsic_atomic_ref (gfc_code *code)\n   atom = argse.expr;\n \n   gfc_init_se (&argse, NULL);\n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB\n+  if (flag_coarray == GFC_FCOARRAY_LIB\n       && code->ext.actual->expr->ts.kind == atom_expr->ts.kind)\n     argse.want_pointer = 1;\n   gfc_conv_expr (&argse, code->ext.actual->expr);\n@@ -8974,17 +8974,17 @@ conv_intrinsic_atomic_ref (gfc_code *code)\n       gcc_assert (code->ext.actual->next->next->expr->expr_type\n \t\t  == EXPR_VARIABLE);\n       gfc_init_se (&argse, NULL);\n-      if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+      if (flag_coarray == GFC_FCOARRAY_LIB)\n \targse.want_pointer = 1;\n       gfc_conv_expr_val (&argse, code->ext.actual->next->next->expr);\n       gfc_add_block_to_block (&block, &argse.pre);\n       gfc_add_block_to_block (&post_block, &argse.post);\n       stat = argse.expr;\n     }\n-  else if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+  else if (flag_coarray == GFC_FCOARRAY_LIB)\n     stat = null_pointer_node;\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+  if (flag_coarray == GFC_FCOARRAY_LIB)\n     {\n       tree image_index, caf_decl, offset, token;\n       tree orig_value = NULL_TREE, vardecl = NULL_TREE;\n@@ -9061,23 +9061,23 @@ conv_intrinsic_atomic_cas (gfc_code *code)\n   atom = argse.expr;\n \n   gfc_init_se (&argse, NULL);\n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+  if (flag_coarray == GFC_FCOARRAY_LIB)\n     argse.want_pointer = 1;\n   gfc_conv_expr (&argse, code->ext.actual->next->expr);\n   gfc_add_block_to_block (&block, &argse.pre);\n   gfc_add_block_to_block (&post_block, &argse.post);\n   old = argse.expr;\n \n   gfc_init_se (&argse, NULL);\n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+  if (flag_coarray == GFC_FCOARRAY_LIB)\n     argse.want_pointer = 1;\n   gfc_conv_expr (&argse, code->ext.actual->next->next->expr);\n   gfc_add_block_to_block (&block, &argse.pre);\n   gfc_add_block_to_block (&post_block, &argse.post);\n   comp = argse.expr;\n \n   gfc_init_se (&argse, NULL);\n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB\n+  if (flag_coarray == GFC_FCOARRAY_LIB\n       && code->ext.actual->next->next->next->expr->ts.kind\n \t == atom_expr->ts.kind)\n     argse.want_pointer = 1;\n@@ -9092,18 +9092,18 @@ conv_intrinsic_atomic_cas (gfc_code *code)\n       gcc_assert (code->ext.actual->next->next->next->next->expr->expr_type\n \t\t  == EXPR_VARIABLE);\n       gfc_init_se (&argse, NULL);\n-      if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+      if (flag_coarray == GFC_FCOARRAY_LIB)\n \targse.want_pointer = 1;\n       gfc_conv_expr_val (&argse,\n \t\t\t code->ext.actual->next->next->next->next->expr);\n       gfc_add_block_to_block (&block, &argse.pre);\n       gfc_add_block_to_block (&post_block, &argse.post);\n       stat = argse.expr;\n     }\n-  else if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+  else if (flag_coarray == GFC_FCOARRAY_LIB)\n     stat = null_pointer_node;\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+  if (flag_coarray == GFC_FCOARRAY_LIB)\n     {\n       tree image_index, caf_decl, offset, token;\n \n@@ -9357,7 +9357,7 @@ conv_intrinsic_move_alloc (gfc_code *code)\n \n   /* For coarrays, call SYNC ALL if TO is already deallocated as MOVE_ALLOC\n      is an image control \"statement\", cf. IR F08/0040 in 12-006A.  */\n-  if (coarray && gfc_option.coarray == GFC_FCOARRAY_LIB)\n+  if (coarray && flag_coarray == GFC_FCOARRAY_LIB)\n     {\n       tree cond;\n "}, {"sha": "47edd327d0ce54bb3b218bf42e55b810eee631d8", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=f19626cf3086867bd69b25c5113e159289107ce4", "patch": "@@ -627,7 +627,7 @@ gfc_trans_stop (gfc_code *code, bool error_stop)\n   gfc_init_se (&se, NULL);\n   gfc_start_block (&se.pre);\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB && !error_stop)\n+  if (flag_coarray == GFC_FCOARRAY_LIB && !error_stop)\n     {\n       /* Per F2008, 8.5.1 STOP implies a SYNC MEMORY.  */\n       tmp = builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE);\n@@ -643,7 +643,7 @@ gfc_trans_stop (gfc_code *code, bool error_stop)\n       tmp = build_int_cst (gfc_int4_type_node, 0);\n       tmp = build_call_expr_loc (input_location,\n \t\t\t\t error_stop\n-\t\t\t\t ? (gfc_option.coarray == GFC_FCOARRAY_LIB\n+\t\t\t\t ? (flag_coarray == GFC_FCOARRAY_LIB\n \t\t\t\t    ? gfor_fndecl_caf_error_stop_str\n \t\t\t\t    : gfor_fndecl_error_stop_string)\n \t\t\t\t : gfor_fndecl_stop_string,\n@@ -654,7 +654,7 @@ gfc_trans_stop (gfc_code *code, bool error_stop)\n       gfc_conv_expr (&se, code->expr1);\n       tmp = build_call_expr_loc (input_location,\n \t\t\t\t error_stop\n-\t\t\t\t ? (gfc_option.coarray == GFC_FCOARRAY_LIB\n+\t\t\t\t ? (flag_coarray == GFC_FCOARRAY_LIB\n \t\t\t\t    ? gfor_fndecl_caf_error_stop\n \t\t\t\t    : gfor_fndecl_error_stop_numeric)\n \t\t\t\t : gfor_fndecl_stop_numeric_f08, 1,\n@@ -665,7 +665,7 @@ gfc_trans_stop (gfc_code *code, bool error_stop)\n       gfc_conv_expr_reference (&se, code->expr1);\n       tmp = build_call_expr_loc (input_location,\n \t\t\t\t error_stop\n-\t\t\t\t ? (gfc_option.coarray == GFC_FCOARRAY_LIB\n+\t\t\t\t ? (flag_coarray == GFC_FCOARRAY_LIB\n \t\t\t\t    ? gfor_fndecl_caf_error_stop_str\n \t\t\t\t    : gfor_fndecl_error_stop_string)\n \t\t\t\t : gfor_fndecl_stop_string,\n@@ -688,7 +688,7 @@ gfc_trans_lock_unlock (gfc_code *code, gfc_exec_op type ATTRIBUTE_UNUSED)\n \n   /* Short cut: For single images without STAT= or LOCK_ACQUIRED\n      return early. (ERRMSG= is always untouched for -fcoarray=single.)  */\n-  if (!code->expr2 && !code->expr4 && gfc_option.coarray != GFC_FCOARRAY_LIB)\n+  if (!code->expr2 && !code->expr4 && flag_coarray != GFC_FCOARRAY_LIB)\n     return NULL_TREE;\n \n   gfc_init_se (&se, NULL);\n@@ -733,7 +733,7 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type)\n   /* Short cut: For single images without bound checking or without STAT=,\n      return early. (ERRMSG= is always untouched for -fcoarray=single.)  */\n   if (!code->expr2 && !(gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n-      && gfc_option.coarray != GFC_FCOARRAY_LIB)\n+      && flag_coarray != GFC_FCOARRAY_LIB)\n     return NULL_TREE;\n \n   gfc_init_se (&se, NULL);\n@@ -756,7 +756,7 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type)\n   else\n     stat = null_pointer_node;\n \n-  if (code->expr3 && gfc_option.coarray == GFC_FCOARRAY_LIB\n+  if (code->expr3 && flag_coarray == GFC_FCOARRAY_LIB\n       && type != EXEC_SYNC_MEMORY)\n     {\n       gcc_assert (code->expr3->expr_type == EXPR_VARIABLE);\n@@ -766,7 +766,7 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type)\n       errmsg = gfc_build_addr_expr (NULL, argse.expr);\n       errmsglen = argse.string_length;\n     }\n-  else if (gfc_option.coarray == GFC_FCOARRAY_LIB && type != EXEC_SYNC_MEMORY)\n+  else if (flag_coarray == GFC_FCOARRAY_LIB && type != EXEC_SYNC_MEMORY)\n     {\n       errmsg = null_pointer_node;\n       errmsglen = build_int_cst (integer_type_node, 0);\n@@ -778,7 +778,7 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type)\n       && code->expr1->rank == 0)\n     {\n       tree cond;\n-      if (gfc_option.coarray != GFC_FCOARRAY_LIB)\n+      if (flag_coarray != GFC_FCOARRAY_LIB)\n \tcond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n \t\t\t\timages, build_int_cst (TREE_TYPE (images), 1));\n       else\n@@ -803,14 +803,14 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type)\n \n    /* Per F2008, 8.5.1, a SYNC MEMORY is implied by calling the\n       image control statements SYNC IMAGES and SYNC ALL.  */\n-   if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+   if (flag_coarray == GFC_FCOARRAY_LIB)\n      {\n        tmp = builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE);\n        tmp = build_call_expr_loc (input_location, tmp, 0);\n        gfc_add_expr_to_block (&se.pre, tmp);\n      }\n \n-  if (gfc_option.coarray != GFC_FCOARRAY_LIB || type == EXEC_SYNC_MEMORY)\n+  if (flag_coarray != GFC_FCOARRAY_LIB || type == EXEC_SYNC_MEMORY)\n     {\n       /* Set STAT to zero.  */\n       if (code->expr2)\n@@ -1115,7 +1115,7 @@ gfc_trans_critical (gfc_code *code)\n \n   gfc_start_block (&block);\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+  if (flag_coarray == GFC_FCOARRAY_LIB)\n     {\n       token = gfc_get_symbol_decl (code->resolved_sym);\n       token = GFC_TYPE_ARRAY_CAF_TOKEN (TREE_TYPE (token));\n@@ -1129,7 +1129,7 @@ gfc_trans_critical (gfc_code *code)\n   tmp = gfc_trans_code (code->block->next);\n   gfc_add_expr_to_block (&block, tmp);\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+  if (flag_coarray == GFC_FCOARRAY_LIB)\n     {\n       tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_unlock, 6,\n \t\t\t\t token, integer_zero_node, integer_one_node,"}, {"sha": "9bf08038efd1cdf47d604e0c9e67a0954d11dbf6", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=f19626cf3086867bd69b25c5113e159289107ce4", "patch": "@@ -1648,7 +1648,7 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed,\n \n   if (as->rank == 0)\n     {\n-      if (packed != PACKED_STATIC  || gfc_option.coarray == GFC_FCOARRAY_LIB)\n+      if (packed != PACKED_STATIC  || flag_coarray == GFC_FCOARRAY_LIB)\n \t{\n \t  type = build_pointer_type (type);\n \n@@ -1702,7 +1702,7 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed,\n     }\n \n   if (packed != PACKED_STATIC || !known_stride\n-      || (as->corank && gfc_option.coarray == GFC_FCOARRAY_LIB))\n+      || (as->corank && flag_coarray == GFC_FCOARRAY_LIB))\n     {\n       /* For dummy arrays and automatic (heap allocated) arrays we\n \t want a pointer to the array.  */\n@@ -1734,7 +1734,7 @@ gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted,\n \n   gcc_assert (codimen + dimen >= 0 && codimen + dimen <= GFC_MAX_DIMENSIONS);\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB && codimen)\n+  if (flag_coarray == GFC_FCOARRAY_LIB && codimen)\n     {\n       if (gfc_array_descriptor_base_caf[idx])\n \treturn gfc_array_descriptor_base_caf[idx];\n@@ -1782,7 +1782,7 @@ gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted,\n       TREE_NO_WARNING (decl) = 1;\n     }\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB && codimen\n+  if (flag_coarray == GFC_FCOARRAY_LIB && codimen\n       && akind == GFC_ARRAY_ALLOCATABLE)\n     {\n       decl = gfc_add_field_to_struct_1 (fat_type,\n@@ -1795,7 +1795,7 @@ gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted,\n   gfc_finish_type (fat_type);\n   TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (fat_type)) = 1;\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB && codimen\n+  if (flag_coarray == GFC_FCOARRAY_LIB && codimen\n       && akind == GFC_ARRAY_ALLOCATABLE)\n     gfc_array_descriptor_base_caf[idx] = fat_type;\n   else"}, {"sha": "7c54b8e249977c24c3714dff057546b377c5fddc", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19626cf3086867bd69b25c5113e159289107ce4/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=f19626cf3086867bd69b25c5113e159289107ce4", "patch": "@@ -772,7 +772,7 @@ gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size, tree token,\n      gfc_allocate_using_lib.  */\n   gfc_start_block (&alloc_block);\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB\n+  if (flag_coarray == GFC_FCOARRAY_LIB\n       && gfc_expr_attr (expr).codimension)\n     {\n       tree cond;\n@@ -1263,7 +1263,7 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n   /* When POINTER is not NULL, we free it.  */\n   gfc_start_block (&non_null);\n   gfc_add_finalizer_call (&non_null, expr);\n-  if (!coarray || gfc_option.coarray != GFC_FCOARRAY_LIB)\n+  if (!coarray || flag_coarray != GFC_FCOARRAY_LIB)\n     {\n       tmp = build_call_expr_loc (input_location,\n \t\t\t\t builtin_decl_explicit (BUILT_IN_FREE), 1,"}]}