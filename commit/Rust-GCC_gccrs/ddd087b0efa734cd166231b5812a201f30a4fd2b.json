{"sha": "ddd087b0efa734cd166231b5812a201f30a4fd2b", "node_id": "C_kwDOANBUbNoAKGRkZDA4N2IwZWZhNzM0Y2QxNjYyMzFiNTgxMmEyMDFmMzBhNGZkMmI", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-11T09:41:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-11T09:41:37Z"}, "message": "Merge #1003\n\n1003: Add more intrinsics and refactor how we implement them r=philberty a=philberty\n\nThis patch series implements:\r\n\r\n1. offset\r\n2. size_of\r\n3. unreachable\r\n4. abort\r\n\r\nIt removes the GCC wrapper mappings to make them much easier to implement. It also demonstrates in single commits\r\nthe implementation of each of these intrinsic to make it easy to follow in how we implement them.\r\n\r\nAddresses #658 #849 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "1aac8c264cccddd81497c168203756005000b5fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1aac8c264cccddd81497c168203756005000b5fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddd087b0efa734cd166231b5812a201f30a4fd2b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiKxlRCRBK7hj4Ov3rIwAASJEIAB6mEJKD9B6pw4L6SpAqj5Wr\n8fRtC1atDVriMS72J4qpWzTCulhq3ymL0OPP9ngNzIc+478tcJg89fgu3RVqfhFJ\nVh9y6254Thaa3wsDOrHwHSQTWI+wPCfigOE4qnRt7BqVELuSinI3ppJUhp6aV3Rz\ndp6iFjJZiCgDS3XeoB0FzybRMGkbTP0iMUIoz7qygJIVANITuHIEQvuW+gGO+viT\nQQ961HITT73su7tL0zUvNUml1T2SHKdanuAENGukU7R2uq4gmcOtUS13H7qlihWp\n0rk/6t8VazbqUfzCg7a39fE4tRz444slHmsBlKFBeNpRQcuydhqNdlAOB2wz6eg=\n=lWLn\n-----END PGP SIGNATURE-----\n", "payload": "tree 1aac8c264cccddd81497c168203756005000b5fe\nparent 1f4e2deb31973f13940a99961042d4898b1a8207\nparent f05744511998309f6694ad18abcc22fbac025dc2\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1646991697 +0000\ncommitter GitHub <noreply@github.com> 1646991697 +0000\n\nMerge #1003\n\n1003: Add more intrinsics and refactor how we implement them r=philberty a=philberty\n\nThis patch series implements:\r\n\r\n1. offset\r\n2. size_of\r\n3. unreachable\r\n4. abort\r\n\r\nIt removes the GCC wrapper mappings to make them much easier to implement. It also demonstrates in single commits\r\nthe implementation of each of these intrinsic to make it easy to follow in how we implement them.\r\n\r\nAddresses #658 #849 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddd087b0efa734cd166231b5812a201f30a4fd2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddd087b0efa734cd166231b5812a201f30a4fd2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddd087b0efa734cd166231b5812a201f30a4fd2b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f4e2deb31973f13940a99961042d4898b1a8207", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f4e2deb31973f13940a99961042d4898b1a8207", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f4e2deb31973f13940a99961042d4898b1a8207"}, {"sha": "f05744511998309f6694ad18abcc22fbac025dc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f05744511998309f6694ad18abcc22fbac025dc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f05744511998309f6694ad18abcc22fbac025dc2"}], "stats": {"total": 611, "additions": 439, "deletions": 172}, "files": [{"sha": "5e3cfaa2f3d49cd6178dda5f37fd2fb7035ebf2b", "filename": "gcc/rust/backend/rust-compile-fnparam.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h?ref=ddd087b0efa734cd166231b5812a201f30a4fd2b", "patch": "@@ -36,6 +36,14 @@ class CompileFnParam : public HIRCompileBase, public HIR::HIRPatternVisitor\n     return compiler.compiled_param;\n   }\n \n+  static Bvariable *compile (Context *ctx, tree fndecl, HIR::Pattern *param,\n+\t\t\t     tree decl_type, Location locus)\n+  {\n+    CompileFnParam compiler (ctx, fndecl, decl_type, locus);\n+    param->accept_vis (compiler);\n+    return compiler.compiled_param;\n+  }\n+\n   void visit (HIR::IdentifierPattern &pattern) override\n   {\n     if (!pattern.is_mut ())"}, {"sha": "3665f5d35f791b784bb689f9e9d015b4de61ef06", "filename": "gcc/rust/backend/rust-compile-intrinsic.cc", "status": "modified", "additions": 367, "deletions": 55, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc?ref=ddd087b0efa734cd166231b5812a201f30a4fd2b", "patch": "@@ -15,78 +15,390 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-compile-intrinsic.h\"\n+#include \"langhooks.h\"\n+#include \"rust-compile-type.h\"\n+#include \"rust-compile-fnparam.h\"\n+#include \"rust-tree.h\"\n \n namespace Rust {\n namespace Compile {\n \n+// https://github.com/rust-lang/rust/blob/master/library/core/src/intrinsics.rs\n+// https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_llvm/src/intrinsic.rs\n+// https://github.com/Rust-GCC/gccrs/issues/658\n+//\n+//   let llvm_name = match name {\n+//     sym::sqrtf32 => \"llvm.sqrt.f32\",\n+//     sym::sqrtf64 => \"llvm.sqrt.f64\",\n+//     sym::powif32 => \"llvm.powi.f32\",\n+//     sym::powif64 => \"llvm.powi.f64\",\n+//     sym::sinf32 => \"llvm.sin.f32\",\n+//     sym::sinf64 => \"llvm.sin.f64\",\n+//     sym::cosf32 => \"llvm.cos.f32\",\n+//     sym::cosf64 => \"llvm.cos.f64\",\n+//     sym::powf32 => \"llvm.pow.f32\",\n+//     sym::powf64 => \"llvm.pow.f64\",\n+//     sym::expf32 => \"llvm.exp.f32\",\n+//     sym::expf64 => \"llvm.exp.f64\",\n+//     sym::exp2f32 => \"llvm.exp2.f32\",\n+//     sym::exp2f64 => \"llvm.exp2.f64\",\n+//     sym::logf32 => \"llvm.log.f32\",\n+//     sym::logf64 => \"llvm.log.f64\",\n+//     sym::log10f32 => \"llvm.log10.f32\",\n+//     sym::log10f64 => \"llvm.log10.f64\",\n+//     sym::log2f32 => \"llvm.log2.f32\",\n+//     sym::log2f64 => \"llvm.log2.f64\",\n+//     sym::fmaf32 => \"llvm.fma.f32\",\n+//     sym::fmaf64 => \"llvm.fma.f64\",\n+//     sym::fabsf32 => \"llvm.fabs.f32\",\n+//     sym::fabsf64 => \"llvm.fabs.f64\",\n+//     sym::minnumf32 => \"llvm.minnum.f32\",\n+//     sym::minnumf64 => \"llvm.minnum.f64\",\n+//     sym::maxnumf32 => \"llvm.maxnum.f32\",\n+//     sym::maxnumf64 => \"llvm.maxnum.f64\",\n+//     sym::copysignf32 => \"llvm.copysign.f32\",\n+//     sym::copysignf64 => \"llvm.copysign.f64\",\n+//     sym::floorf32 => \"llvm.floor.f32\",\n+//     sym::floorf64 => \"llvm.floor.f64\",\n+//     sym::ceilf32 => \"llvm.ceil.f32\",\n+//     sym::ceilf64 => \"llvm.ceil.f64\",\n+//     sym::truncf32 => \"llvm.trunc.f32\",\n+//     sym::truncf64 => \"llvm.trunc.f64\",\n+//     sym::rintf32 => \"llvm.rint.f32\",\n+//     sym::rintf64 => \"llvm.rint.f64\",\n+//     sym::nearbyintf32 => \"llvm.nearbyint.f32\",\n+//     sym::nearbyintf64 => \"llvm.nearbyint.f64\",\n+//     sym::roundf32 => \"llvm.round.f32\",\n+//     sym::roundf64 => \"llvm.round.f64\",\n+//     _ => return None,\n+// };\n+// Some(cx.get_intrinsic(&llvm_name))\n+class SimpleIntrinsics\n+{\n+public:\n+  static SimpleIntrinsics &get ()\n+  {\n+    static SimpleIntrinsics instance;\n+    return instance;\n+  }\n+\n+  bool lookup_simple_builtin (const std::string &name, tree *builtin)\n+  {\n+    auto it = rust_intrinsic_to_gcc_builtin.find (name);\n+    if (it == rust_intrinsic_to_gcc_builtin.end ())\n+      return false;\n+\n+    return lookup_gcc_builtin (it->second, builtin);\n+  }\n+\n+private:\n+  static const int builtin_const = 1 << 0;\n+  static const int builtin_noreturn = 1 << 1;\n+  static const int builtin_novops = 1 << 2;\n+\n+  SimpleIntrinsics () { setup (); }\n+\n+  void setup ()\n+  {\n+    tree math_function_type_f32\n+      = build_function_type_list (float_type_node, float_type_node, NULL_TREE);\n+\n+    define_builtin (\"sinf32\", BUILT_IN_SINF, \"__builtin_sinf\", \"sinf\",\n+\t\t    math_function_type_f32, builtin_const);\n+\n+    define_builtin (\"sqrtf32\", BUILT_IN_SQRTF, \"__builtin_sqrtf\", \"sqrtf\",\n+\t\t    math_function_type_f32, builtin_const);\n+\n+    define_builtin (\"unreachable\", BUILT_IN_UNREACHABLE,\n+\t\t    \"__builtin_unreachable\", NULL,\n+\t\t    build_function_type (void_type_node, void_list_node),\n+\t\t    builtin_const | builtin_noreturn);\n+\n+    define_builtin (\"abort\", BUILT_IN_ABORT, \"__builtin_abort\", \"abort\",\n+\t\t    build_function_type (void_type_node, void_list_node),\n+\t\t    builtin_const | builtin_noreturn);\n+  }\n+\n+  // Define a builtin function.  BCODE is the builtin function code\n+  // defined by builtins.def.  NAME is the name of the builtin function.\n+  // LIBNAME is the name of the corresponding library function, and is\n+  // NULL if there isn't one.  FNTYPE is the type of the function.\n+  // CONST_P is true if the function has the const attribute.\n+  // NORETURN_P is true if the function has the noreturn attribute.\n+  void define_builtin (const std::string rust_name, built_in_function bcode,\n+\t\t       const char *name, const char *libname, tree fntype,\n+\t\t       int flags)\n+  {\n+    tree decl = add_builtin_function (name, fntype, bcode, BUILT_IN_NORMAL,\n+\t\t\t\t      libname, NULL_TREE);\n+    if ((flags & builtin_const) != 0)\n+      TREE_READONLY (decl) = 1;\n+    if ((flags & builtin_noreturn) != 0)\n+      TREE_THIS_VOLATILE (decl) = 1;\n+    if ((flags & builtin_novops) != 0)\n+      DECL_IS_NOVOPS (decl) = 1;\n+    set_builtin_decl (bcode, decl, true);\n+    this->builtin_functions_[name] = decl;\n+    if (libname != NULL)\n+      {\n+\tdecl = add_builtin_function (libname, fntype, bcode, BUILT_IN_NORMAL,\n+\t\t\t\t     NULL, NULL_TREE);\n+\tif ((flags & builtin_const) != 0)\n+\t  TREE_READONLY (decl) = 1;\n+\tif ((flags & builtin_noreturn) != 0)\n+\t  TREE_THIS_VOLATILE (decl) = 1;\n+\tif ((flags & builtin_novops) != 0)\n+\t  DECL_IS_NOVOPS (decl) = 1;\n+\tthis->builtin_functions_[libname] = decl;\n+      }\n+\n+    rust_intrinsic_to_gcc_builtin[rust_name] = name;\n+  }\n+\n+  bool lookup_gcc_builtin (const std::string &name, tree *builtin)\n+  {\n+    auto it = builtin_functions_.find (name);\n+    if (it == builtin_functions_.end ())\n+      return false;\n+\n+    *builtin = it->second;\n+    return true;\n+  }\n+\n+  // A mapping of the GCC built-ins exposed to GCC Rust.\n+  std::map<std::string, tree> builtin_functions_;\n+  std::map<std::string, std::string> rust_intrinsic_to_gcc_builtin;\n+};\n+\n+static tree\n+offset_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype);\n+static tree\n+sizeof_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype);\n+\n+static const std::map<std::string,\n+\t\t      std::function<tree (Context *, TyTy::BaseType *)>>\n+  generic_intrinsics = {{\"offset\", &offset_intrinsic_handler},\n+\t\t\t{\"size_of\", &sizeof_intrinsic_handler}};\n+\n Intrinsics::Intrinsics (Context *ctx) : ctx (ctx) {}\n \n tree\n Intrinsics::compile (TyTy::FnType *fntype)\n {\n   rust_assert (fntype->get_abi () == ABI::INTRINSIC);\n \n-  // https://github.com/rust-lang/rust/blob/master/library/core/src/intrinsics.rs\n-  // https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_llvm/src/intrinsic.rs\n-  // https://github.com/Rust-GCC/gccrs/issues/658\n-\n-  //   let llvm_name = match name {\n-  //     sym::sqrtf32 => \"llvm.sqrt.f32\",\n-  //     sym::sqrtf64 => \"llvm.sqrt.f64\",\n-  //     sym::powif32 => \"llvm.powi.f32\",\n-  //     sym::powif64 => \"llvm.powi.f64\",\n-  //     sym::sinf32 => \"llvm.sin.f32\",\n-  //     sym::sinf64 => \"llvm.sin.f64\",\n-  //     sym::cosf32 => \"llvm.cos.f32\",\n-  //     sym::cosf64 => \"llvm.cos.f64\",\n-  //     sym::powf32 => \"llvm.pow.f32\",\n-  //     sym::powf64 => \"llvm.pow.f64\",\n-  //     sym::expf32 => \"llvm.exp.f32\",\n-  //     sym::expf64 => \"llvm.exp.f64\",\n-  //     sym::exp2f32 => \"llvm.exp2.f32\",\n-  //     sym::exp2f64 => \"llvm.exp2.f64\",\n-  //     sym::logf32 => \"llvm.log.f32\",\n-  //     sym::logf64 => \"llvm.log.f64\",\n-  //     sym::log10f32 => \"llvm.log10.f32\",\n-  //     sym::log10f64 => \"llvm.log10.f64\",\n-  //     sym::log2f32 => \"llvm.log2.f32\",\n-  //     sym::log2f64 => \"llvm.log2.f64\",\n-  //     sym::fmaf32 => \"llvm.fma.f32\",\n-  //     sym::fmaf64 => \"llvm.fma.f64\",\n-  //     sym::fabsf32 => \"llvm.fabs.f32\",\n-  //     sym::fabsf64 => \"llvm.fabs.f64\",\n-  //     sym::minnumf32 => \"llvm.minnum.f32\",\n-  //     sym::minnumf64 => \"llvm.minnum.f64\",\n-  //     sym::maxnumf32 => \"llvm.maxnum.f32\",\n-  //     sym::maxnumf64 => \"llvm.maxnum.f64\",\n-  //     sym::copysignf32 => \"llvm.copysign.f32\",\n-  //     sym::copysignf64 => \"llvm.copysign.f64\",\n-  //     sym::floorf32 => \"llvm.floor.f32\",\n-  //     sym::floorf64 => \"llvm.floor.f64\",\n-  //     sym::ceilf32 => \"llvm.ceil.f32\",\n-  //     sym::ceilf64 => \"llvm.ceil.f64\",\n-  //     sym::truncf32 => \"llvm.trunc.f32\",\n-  //     sym::truncf64 => \"llvm.trunc.f64\",\n-  //     sym::rintf32 => \"llvm.rint.f32\",\n-  //     sym::rintf64 => \"llvm.rint.f64\",\n-  //     sym::nearbyintf32 => \"llvm.nearbyint.f32\",\n-  //     sym::nearbyintf64 => \"llvm.nearbyint.f64\",\n-  //     sym::roundf32 => \"llvm.round.f32\",\n-  //     sym::roundf64 => \"llvm.round.f64\",\n-  //     _ => return None,\n-  // };\n-  // Some(cx.get_intrinsic(&llvm_name))\n-\n-  tree builtin = ctx->get_backend ()->lookup_builtin_by_rust_name (\n-    fntype->get_identifier ());\n-  if (builtin != nullptr)\n+  tree builtin = error_mark_node;\n+  SimpleIntrinsics &simple_intrinsics = SimpleIntrinsics::get ();\n+  if (simple_intrinsics.lookup_simple_builtin (fntype->get_identifier (),\n+\t\t\t\t\t       &builtin))\n     return builtin;\n \n+  // is it an generic builtin?\n+  auto it = generic_intrinsics.find (fntype->get_identifier ());\n+  if (it != generic_intrinsics.end ())\n+    return it->second (ctx, fntype);\n+\n   Location locus = ctx->get_mappings ()->lookup_location (fntype->get_ref ());\n-  rust_error_at (locus, \"unknown builtin\");\n+  rust_error_at (locus, \"unknown builtin intrinsic: %s\",\n+\t\t fntype->get_identifier ().c_str ());\n \n   return error_mark_node;\n }\n \n+static tree\n+offset_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype_tyty)\n+{\n+  rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n+  const Resolver::CanonicalPath &canonical_path = fntype->get_ident ().path;\n+\n+  // items can be forward compiled which means we may not need to invoke this\n+  // code. We might also have already compiled this generic function as well.\n+  tree lookup = NULL_TREE;\n+  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n+\t\t\t\t fntype->get_id (), fntype))\n+    {\n+      // has this been added to the list then it must be finished\n+      if (ctx->function_completed (lookup))\n+\t{\n+\t  tree dummy = NULL_TREE;\n+\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n+\t    {\n+\t      ctx->insert_function_decl (fntype, lookup);\n+\t    }\n+\t  return lookup;\n+\t}\n+    }\n+\n+  if (fntype->has_subsititions_defined ())\n+    {\n+      // override the Hir Lookups for the substituions in this context\n+      fntype->override_context ();\n+    }\n+\n+  // offset intrinsic has two params dst pointer and offset isize\n+  if (fntype->get_params ().size () != 2)\n+    {\n+      rust_error_at (fntype->get_ident ().locus,\n+\t\t     \"invalid number of parameters for offset intrinsic\");\n+      return error_mark_node;\n+    }\n+\n+  tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+  std::string ir_symbol_name\n+    = canonical_path.get () + fntype->subst_as_string ();\n+  std::string asm_name = ctx->mangle_item (fntype, canonical_path);\n+\n+  unsigned int flags = 0;\n+  tree fndecl\n+    = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name, asm_name,\n+\t\t\t\t     flags, fntype->get_ident ().locus);\n+  TREE_PUBLIC (fndecl) = 0;\n+  TREE_READONLY (fndecl) = 1;\n+  DECL_ARTIFICIAL (fndecl) = 1;\n+  DECL_EXTERNAL (fndecl) = 0;\n+  DECL_DECLARED_INLINE_P (fndecl) = 1;\n+\n+  // setup the params\n+  std::vector<Bvariable *> param_vars;\n+  for (auto &parm : fntype->get_params ())\n+    {\n+      auto &referenced_param = parm.first;\n+      auto &param_tyty = parm.second;\n+      auto compiled_param_type = TyTyResolveCompile::compile (ctx, param_tyty);\n+\n+      Location param_locus = referenced_param->get_locus ();\n+      Bvariable *compiled_param_var\n+\t= CompileFnParam::compile (ctx, fndecl, referenced_param,\n+\t\t\t\t   compiled_param_type, param_locus);\n+\n+      param_vars.push_back (compiled_param_var);\n+    }\n+\n+  auto &dst_param = param_vars.at (0);\n+  auto &size_param = param_vars.at (1);\n+  rust_assert (param_vars.size () == 2);\n+  if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+    return error_mark_node;\n+\n+  tree enclosing_scope = NULL_TREE;\n+  Location start_location = Location ();\n+  Location end_location = Location ();\n+\n+  tree code_block = ctx->get_backend ()->block (fndecl, enclosing_scope, {},\n+\t\t\t\t\t\tstart_location, end_location);\n+  ctx->push_block (code_block);\n+\n+  // BUILTIN offset FN BODY BEGIN\n+  tree dst = ctx->get_backend ()->var_expression (dst_param, Location ());\n+  tree size = ctx->get_backend ()->var_expression (size_param, Location ());\n+  tree pointer_offset_expr\n+    = pointer_offset_expression (dst, size, BUILTINS_LOCATION);\n+  auto return_statement\n+    = ctx->get_backend ()->return_statement (fndecl, {pointer_offset_expr},\n+\t\t\t\t\t     Location ());\n+  ctx->add_statement (return_statement);\n+  // BUILTIN offset FN BODY END\n+\n+  tree bind_tree = ctx->pop_block ();\n+\n+  gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n+  DECL_SAVED_TREE (fndecl) = bind_tree;\n+\n+  ctx->pop_fn ();\n+  ctx->push_function (fndecl);\n+\n+  return fndecl;\n+}\n+\n+static tree\n+sizeof_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype_tyty)\n+{\n+  rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n+  const Resolver::CanonicalPath &canonical_path = fntype->get_ident ().path;\n+\n+  // items can be forward compiled which means we may not need to invoke this\n+  // code. We might also have already compiled this generic function as well.\n+  tree lookup = NULL_TREE;\n+  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n+\t\t\t\t fntype->get_id (), fntype))\n+    {\n+      // has this been added to the list then it must be finished\n+      if (ctx->function_completed (lookup))\n+\t{\n+\t  tree dummy = NULL_TREE;\n+\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n+\t    {\n+\t      ctx->insert_function_decl (fntype, lookup);\n+\t    }\n+\t  return lookup;\n+\t}\n+    }\n+\n+  if (fntype->has_subsititions_defined ())\n+    {\n+      // override the Hir Lookups for the substituions in this context\n+      fntype->override_context ();\n+    }\n+\n+  // offset intrinsic has two params dst pointer and offset isize\n+  if (fntype->get_params ().size () != 0)\n+    {\n+      rust_error_at (fntype->get_ident ().locus,\n+\t\t     \"invalid number of parameters for size of intrinsic\");\n+      return error_mark_node;\n+    }\n+\n+  // get the template parameter type tree fn size_of<T>();\n+  rust_assert (fntype->get_num_substitutions () == 1);\n+  auto &param_mapping = fntype->get_substs ().at (0);\n+  const TyTy::ParamType *param_tyty = param_mapping.get_param_ty ();\n+  TyTy::BaseType *resolved_tyty = param_tyty->resolve ();\n+  tree template_parameter_type\n+    = TyTyResolveCompile::compile (ctx, resolved_tyty);\n+\n+  // build the intrinsic function\n+  tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+  std::string ir_symbol_name\n+    = canonical_path.get () + fntype->subst_as_string ();\n+  std::string asm_name = ctx->mangle_item (fntype, canonical_path);\n+\n+  unsigned int flags = 0;\n+  tree fndecl\n+    = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name, asm_name,\n+\t\t\t\t     flags, fntype->get_ident ().locus);\n+  TREE_PUBLIC (fndecl) = 0;\n+  TREE_READONLY (fndecl) = 1;\n+  DECL_ARTIFICIAL (fndecl) = 1;\n+  DECL_EXTERNAL (fndecl) = 0;\n+  DECL_DECLARED_INLINE_P (fndecl) = 1;\n+\n+  tree enclosing_scope = NULL_TREE;\n+  Location start_location = Location ();\n+  Location end_location = Location ();\n+\n+  tree code_block = ctx->get_backend ()->block (fndecl, enclosing_scope, {},\n+\t\t\t\t\t\tstart_location, end_location);\n+  ctx->push_block (code_block);\n+\n+  // BUILTIN size_of FN BODY BEGIN\n+  tree size_expr = TYPE_SIZE_UNIT (template_parameter_type);\n+  auto return_statement\n+    = ctx->get_backend ()->return_statement (fndecl, {size_expr}, Location ());\n+  ctx->add_statement (return_statement);\n+  // BUILTIN size_of FN BODY END\n+\n+  tree bind_tree = ctx->pop_block ();\n+\n+  gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n+  DECL_SAVED_TREE (fndecl) = bind_tree;\n+\n+  ctx->pop_fn ();\n+  ctx->push_function (fndecl);\n+\n+  return fndecl;\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "2ad672d0b4c8df9b40cda46d44b0c8c19f6266a5", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=ddd087b0efa734cd166231b5812a201f30a4fd2b", "patch": "@@ -17,6 +17,7 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-compile-resolve-path.h\"\n+#include \"rust-compile-intrinsic.h\"\n #include \"rust-compile-item.h\"\n #include \"rust-compile-implitem.h\"\n #include \"rust-compile-expr.h\"\n@@ -142,6 +143,13 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n \t  TREE_USED (fn) = 1;\n \t  return address_expression (fn, expr_locus);\n \t}\n+      else if (fntype->get_abi () == ABI::INTRINSIC)\n+\t{\n+\t  Intrinsics compile (ctx);\n+\t  fn = compile.compile (fntype);\n+\t  TREE_USED (fn) = 1;\n+\t  return address_expression (fn, expr_locus);\n+\t}\n     }\n \n   // let the query system figure it out"}, {"sha": "6f7614d041335624d320c460592598e62dff370e", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=ddd087b0efa734cd166231b5812a201f30a4fd2b", "patch": "@@ -17,6 +17,7 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-tree.h\"\n+#include \"fold-const.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"escaped_string.h\"\n@@ -656,4 +657,21 @@ get_fndecl_from_callee (tree fn)\n   return NULL_TREE;\n }\n \n+tree\n+pointer_offset_expression (tree base_tree, tree index_tree, location_t location)\n+{\n+  tree element_type_tree = TREE_TYPE (TREE_TYPE (base_tree));\n+  if (base_tree == error_mark_node || TREE_TYPE (base_tree) == error_mark_node\n+      || index_tree == error_mark_node || element_type_tree == error_mark_node)\n+    return error_mark_node;\n+\n+  tree element_size = TYPE_SIZE_UNIT (element_type_tree);\n+  index_tree = fold_convert_loc (location, sizetype, index_tree);\n+  tree offset\n+    = fold_build2_loc (location, MULT_EXPR, sizetype, index_tree, element_size);\n+\n+  return fold_build2_loc (location, POINTER_PLUS_EXPR, TREE_TYPE (base_tree),\n+\t\t\t  base_tree, offset);\n+}\n+\n } // namespace Rust"}, {"sha": "c50e090f9391367d1b903cd3a3dac7532eef71df", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=ddd087b0efa734cd166231b5812a201f30a4fd2b", "patch": "@@ -177,6 +177,12 @@ expr_loc_or_input_loc (const_tree t);\n extern tree\n get_fndecl_from_callee (tree fn);\n \n+// FIXME some helpers from HIRCompileBase could probably be moved here over time\n+\n+// Return an expression for the address of BASE[INDEX], used in offset intrinsic\n+extern tree\n+pointer_offset_expression (tree base_tree, tree index_tree, location_t locus);\n+\n } // namespace Rust\n \n #endif // RUST_TREE"}, {"sha": "a9b4dd8ab038df480da4eb53539ea201eeaf3fc7", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=ddd087b0efa734cd166231b5812a201f30a4fd2b", "patch": "@@ -291,6 +291,19 @@ class ASTLoweringType : public ASTLoweringBase\n \t\t\t       translated);\n   }\n \n+  void visit (AST::NeverType &type) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::NeverType (mapping, type.get_locus ());\n+\n+    mappings->insert_hir_type (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+  }\n+\n   void visit (AST::TraitObjectTypeOneBound &type) override;\n \n   void visit (AST::TraitObjectType &type) override;"}, {"sha": "fd5c056725a65d21163347a6cf8dc6797ecde6fa", "filename": "gcc/rust/resolve/rust-ast-resolve-type.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc?ref=ddd087b0efa734cd166231b5812a201f30a4fd2b", "patch": "@@ -197,6 +197,12 @@ ResolveType::visit (AST::InferredType &type)\n   ok = true;\n }\n \n+void\n+ResolveType::visit (AST::NeverType &type)\n+{\n+  ok = true;\n+}\n+\n void\n ResolveType::visit (AST::SliceType &type)\n {"}, {"sha": "e5344235879ef3c81e693b60a101c3ccb42d19c1", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=ddd087b0efa734cd166231b5812a201f30a4fd2b", "patch": "@@ -386,6 +386,8 @@ class ResolveType : public ResolverBase\n \n   void visit (AST::InferredType &type) override;\n \n+  void visit (AST::NeverType &type) override;\n+\n   void visit (AST::RawPointerType &type) override;\n \n   void visit (AST::TraitObjectTypeOneBound &type) override;"}, {"sha": "86c159da9531b2161a1b0855390c2504f91bedb3", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=ddd087b0efa734cd166231b5812a201f30a4fd2b", "patch": "@@ -187,6 +187,7 @@ Resolver::generate_builtins ()\n   auto isize = new TyTy::ISizeType (mappings->get_next_hir_id ());\n   auto char_tyty = new TyTy::CharType (mappings->get_next_hir_id ());\n   auto str = new TyTy::StrType (mappings->get_next_hir_id ());\n+  auto never = new TyTy::NeverType (mappings->get_next_hir_id ());\n \n   MKBUILTIN_TYPE (\"u8\", builtins, u8);\n   MKBUILTIN_TYPE (\"u16\", builtins, u16);\n@@ -205,6 +206,7 @@ Resolver::generate_builtins ()\n   MKBUILTIN_TYPE (\"isize\", builtins, isize);\n   MKBUILTIN_TYPE (\"char\", builtins, char_tyty);\n   MKBUILTIN_TYPE (\"str\", builtins, str);\n+  MKBUILTIN_TYPE (\"!\", builtins, never);\n \n   // unit type ()\n   TyTy::TupleType *unit_tyty"}, {"sha": "6bfebe3d5c2fe413b9598a82f01dbe5943c83eac", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=ddd087b0efa734cd166231b5812a201f30a4fd2b", "patch": "@@ -275,10 +275,6 @@ class Backend\n \t\t\t\tconst std::vector<tree> &vals, Location)\n     = 0;\n \n-  // Return an expression for the address of BASE[INDEX].\n-  // BASE has a pointer type.  This is used for slice indexing.\n-  virtual tree pointer_offset_expression (tree base, tree index, Location) = 0;\n-\n   // Return an expression for ARRAY[INDEX] as an l-value.  ARRAY is a valid\n   // fixed-length array, not a slice.\n   virtual tree array_index_expression (tree array, tree index, Location) = 0;\n@@ -508,12 +504,6 @@ class Backend\n \t\t\t   const std::vector<Bvariable *> &param_vars)\n     = 0;\n \n-  // Look up a named built-in function in the current backend implementation.\n-  // Returns NULL if no built-in function by that name exists.\n-  virtual tree lookup_gcc_builtin (const std::string &) = 0;\n-\n-  virtual tree lookup_builtin_by_rust_name (const std::string &) = 0;\n-\n   // Utility.\n \n   // Write the definitions for all TYPE_DECLS, CONSTANT_DECLS,"}, {"sha": "6ea9ef3e44e03088abd33a58c9fcb6183b9c605d", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=ddd087b0efa734cd166231b5812a201f30a4fd2b", "patch": "@@ -246,8 +246,6 @@ class Gcc_backend : public Backend\n   tree array_constructor_expression (tree, const std::vector<unsigned long> &,\n \t\t\t\t     const std::vector<tree> &, Location);\n \n-  tree pointer_offset_expression (tree base, tree offset, Location);\n-\n   tree array_index_expression (tree array, tree index, Location);\n \n   tree call_expression (tree caller, tree fn, const std::vector<tree> &args,\n@@ -346,19 +344,6 @@ class Gcc_backend : public Backend\n   tree non_zero_size_type (tree);\n \n   tree convert_tree (tree, tree, Location);\n-\n-private:\n-  static const int builtin_const = 1 << 0;\n-  static const int builtin_noreturn = 1 << 1;\n-  static const int builtin_novops = 1 << 2;\n-\n-  void define_builtin (const std::string rust_name, built_in_function bcode,\n-\t\t       const char *name, const char *libname, tree fntype,\n-\t\t       int flags);\n-\n-  // A mapping of the GCC built-ins exposed to GCCRust.\n-  std::map<std::string, tree> builtin_functions_;\n-  std::map<std::string, std::string> rust_intrinsic_to_gcc_builtin;\n };\n \n // A helper function to create a GCC identifier from a C++ string.\n@@ -475,14 +460,6 @@ Gcc_backend::Gcc_backend ()\n   //       \t\tbuiltin_const);\n \n   // We provide some functions for the math library.\n-  tree math_function_type_f32\n-    = build_function_type_list (float_type_node, float_type_node, NULL_TREE);\n-\n-  this->define_builtin (\"sinf32\", BUILT_IN_SINF, \"__builtin_sinf\", \"sinf\",\n-\t\t\tmath_function_type_f32, builtin_const);\n-\n-  this->define_builtin (\"sqrtf32\", BUILT_IN_SQRTF, \"__builtin_sqrtf\", \"sqrtf\",\n-\t\t\tmath_function_type_f32, builtin_const);\n \n   // We use __builtin_return_address in the thunk we build for\n   // functions which call recover, and for runtime.getcallerpc.\n@@ -1717,27 +1694,6 @@ Gcc_backend::array_constructor_expression (\n   return ret;\n }\n \n-// Return an expression for the address of BASE[INDEX].\n-\n-tree\n-Gcc_backend::pointer_offset_expression (tree base_tree, tree index_tree,\n-\t\t\t\t\tLocation location)\n-{\n-  tree element_type_tree = TREE_TYPE (TREE_TYPE (base_tree));\n-  if (base_tree == error_mark_node || TREE_TYPE (base_tree) == error_mark_node\n-      || index_tree == error_mark_node || element_type_tree == error_mark_node)\n-    return error_mark_node;\n-\n-  tree element_size = TYPE_SIZE_UNIT (element_type_tree);\n-  index_tree\n-    = fold_convert_loc (location.gcc_location (), sizetype, index_tree);\n-  tree offset = fold_build2_loc (location.gcc_location (), MULT_EXPR, sizetype,\n-\t\t\t\t index_tree, element_size);\n-  tree ptr = fold_build2_loc (location.gcc_location (), POINTER_PLUS_EXPR,\n-\t\t\t      TREE_TYPE (base_tree), base_tree, offset);\n-  return ptr;\n-}\n-\n // Return an expression representing ARRAY[INDEX]\n \n tree\n@@ -2684,27 +2640,6 @@ Gcc_backend::function_set_parameters (\n   return true;\n }\n \n-// Look up a named built-in function in the current backend implementation.\n-// Returns NULL if no built-in function by that name exists.\n-\n-tree\n-Gcc_backend::lookup_gcc_builtin (const std::string &name)\n-{\n-  if (this->builtin_functions_.count (name) != 0)\n-    return this->builtin_functions_[name];\n-  return NULL;\n-}\n-\n-tree\n-Gcc_backend::lookup_builtin_by_rust_name (const std::string &name)\n-{\n-  auto it = rust_intrinsic_to_gcc_builtin.find (name);\n-  if (it == rust_intrinsic_to_gcc_builtin.end ())\n-    return NULL;\n-\n-  return lookup_gcc_builtin (it->second);\n-}\n-\n // Write the definitions for all TYPE_DECLS, CONSTANT_DECLS,\n // FUNCTION_DECLS, and VARIABLE_DECLS declared globally, as well as\n // emit early debugging information.\n@@ -2786,44 +2721,6 @@ Gcc_backend::write_export_data (const char *bytes, unsigned int size)\n   rust_write_export_data (bytes, size);\n }\n \n-// Define a builtin function.  BCODE is the builtin function code\n-// defined by builtins.def.  NAME is the name of the builtin function.\n-// LIBNAME is the name of the corresponding library function, and is\n-// NULL if there isn't one.  FNTYPE is the type of the function.\n-// CONST_P is true if the function has the const attribute.\n-// NORETURN_P is true if the function has the noreturn attribute.\n-\n-void\n-Gcc_backend::define_builtin (const std::string rust_name,\n-\t\t\t     built_in_function bcode, const char *name,\n-\t\t\t     const char *libname, tree fntype, int flags)\n-{\n-  tree decl = add_builtin_function (name, fntype, bcode, BUILT_IN_NORMAL,\n-\t\t\t\t    libname, NULL_TREE);\n-  if ((flags & builtin_const) != 0)\n-    TREE_READONLY (decl) = 1;\n-  if ((flags & builtin_noreturn) != 0)\n-    TREE_THIS_VOLATILE (decl) = 1;\n-  if ((flags & builtin_novops) != 0)\n-    DECL_IS_NOVOPS (decl) = 1;\n-  set_builtin_decl (bcode, decl, true);\n-  this->builtin_functions_[name] = decl;\n-  if (libname != NULL)\n-    {\n-      decl = add_builtin_function (libname, fntype, bcode, BUILT_IN_NORMAL,\n-\t\t\t\t   NULL, NULL_TREE);\n-      if ((flags & builtin_const) != 0)\n-\tTREE_READONLY (decl) = 1;\n-      if ((flags & builtin_noreturn) != 0)\n-\tTREE_THIS_VOLATILE (decl) = 1;\n-      if ((flags & builtin_novops) != 0)\n-\tDECL_IS_NOVOPS (decl) = 1;\n-      this->builtin_functions_[libname] = decl;\n-    }\n-\n-  rust_intrinsic_to_gcc_builtin[rust_name] = name;\n-}\n-\n // Return the backend generator.\n \n Backend *"}, {"sha": "74298e422e8a1bcb8592e733083a3e934e272d82", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd087b0efa734cd166231b5812a201f30a4fd2b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=ddd087b0efa734cd166231b5812a201f30a4fd2b", "patch": "@@ -145,6 +145,15 @@ class TypeCheckType : public TypeCheckBase\n \t\t\t\t      type.get_locus ());\n   }\n \n+  void visit (HIR::NeverType &type) override\n+  {\n+    TyTy::BaseType *lookup = nullptr;\n+    bool ok = context->lookup_builtin (\"!\", &lookup);\n+    rust_assert (ok);\n+\n+    translated = lookup->clone ();\n+  }\n+\n   void visit (HIR::TraitObjectType &type) override;\n \n private:"}, {"sha": "c94cb828071ff5817448bd85a8a498f0844bd8d4", "filename": "gcc/testsuite/rust/compile/never_type_err2.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f4e2deb31973f13940a99961042d4898b1a8207/gcc%2Ftestsuite%2Frust%2Fcompile%2Fnever_type_err2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f4e2deb31973f13940a99961042d4898b1a8207/gcc%2Ftestsuite%2Frust%2Fcompile%2Fnever_type_err2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fnever_type_err2.rs?ref=1f4e2deb31973f13940a99961042d4898b1a8207", "patch": "@@ -1,4 +0,0 @@\n-// FIXME: Unimplemented features\n-fn foo() -> ! { // { dg-error \"unresolved type\" }\n-    let a: !; // { dg-error \"unresolved type\" }\n-}"}]}