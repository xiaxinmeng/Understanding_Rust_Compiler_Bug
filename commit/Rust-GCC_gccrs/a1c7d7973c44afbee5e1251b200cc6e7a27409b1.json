{"sha": "a1c7d7973c44afbee5e1251b200cc6e7a27409b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFjN2Q3OTczYzQ0YWZiZWU1ZTEyNTFiMjAwY2M2ZTdhMjc0MDliMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-09-26T08:26:37Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-09-26T08:26:37Z"}, "message": "ada-tree.h (DECL_CAN_NEVER_BE_NULL_P): New macro.\n\n\t* gcc-interface/ada-tree.h (DECL_CAN_NEVER_BE_NULL_P): New macro.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Set the flag.\n\t(gnat_to_gnu_param): Likewise.\n\t* gcc-interface/utils.c (convert) <UNCONSTRAINED_ARRAY_REF>: Invoke\n\tmaybe_unconstrained_array instead of doing the work manually.\n\t(maybe_unconstrained_array): Propagate the TREE_THIS_NOTRAP flag.\n\t* gcc-interface/utils2.c (build_unary_op) <INDIRECT_REF>: If operand\n\tis a DECL with the flag, set TREE_THIS_NOTRAP on the reference.\n\t(gnat_stabilize_reference_1): Propagate the TREE_THIS_NOTRAP flag.\n\t(gnat_stabilize_reference): Likewise.\n\nFrom-SVN: r179182", "tree": {"sha": "0bbfdf9e810f8a0d87f499a7747d27b4dadc2da4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bbfdf9e810f8a0d87f499a7747d27b4dadc2da4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1c7d7973c44afbee5e1251b200cc6e7a27409b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1c7d7973c44afbee5e1251b200cc6e7a27409b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1c7d7973c44afbee5e1251b200cc6e7a27409b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1c7d7973c44afbee5e1251b200cc6e7a27409b1/comments", "author": null, "committer": null, "parents": [{"sha": "20633efc34fadc76b339620c2d37f3c12231c40a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20633efc34fadc76b339620c2d37f3c12231c40a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20633efc34fadc76b339620c2d37f3c12231c40a"}], "stats": {"total": 153, "additions": 94, "deletions": 59}, "files": [{"sha": "47842198be60e8d4c62251a588c0da0617e726ea", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c7d7973c44afbee5e1251b200cc6e7a27409b1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c7d7973c44afbee5e1251b200cc6e7a27409b1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a1c7d7973c44afbee5e1251b200cc6e7a27409b1", "patch": "@@ -1,3 +1,16 @@\n+2011-09-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h (DECL_CAN_NEVER_BE_NULL_P): New macro.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Set the flag.\n+\t(gnat_to_gnu_param): Likewise.\n+\t* gcc-interface/utils.c (convert) <UNCONSTRAINED_ARRAY_REF>: Invoke\n+\tmaybe_unconstrained_array instead of doing the work manually.\n+\t(maybe_unconstrained_array): Propagate the TREE_THIS_NOTRAP flag.\n+\t* gcc-interface/utils2.c (build_unary_op) <INDIRECT_REF>: If operand\n+\tis a DECL with the flag, set TREE_THIS_NOTRAP on the reference.\n+\t(gnat_stabilize_reference_1): Propagate the TREE_THIS_NOTRAP flag.\n+\t(gnat_stabilize_reference): Likewise.\n+\n 2011-09-26  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/ada-tree.h (TYPE_NULL_BOUNDS): New macro."}, {"sha": "d10fcf0ad928f5a7acfe67b1a071c5121284db1c", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c7d7973c44afbee5e1251b200cc6e7a27409b1/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c7d7973c44afbee5e1251b200cc6e7a27409b1/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=a1c7d7973c44afbee5e1251b200cc6e7a27409b1", "patch": "@@ -352,6 +352,9 @@ do {\t\t\t\t\t\t   \\\n    is needed to access the object.  */\n #define DECL_BY_REF_P(NODE) DECL_LANG_FLAG_1 (NODE)\n \n+/* Nonzero in a DECL if it is made for a pointer that can never be null.  */\n+#define DECL_CAN_NEVER_BE_NULL_P(NODE) DECL_LANG_FLAG_2 (NODE)\n+\n /* Nonzero in a FIELD_DECL that is a dummy built for some internal reason.  */\n #define DECL_INTERNAL_P(NODE) DECL_LANG_FLAG_3 (FIELD_DECL_CHECK (NODE))\n \n@@ -364,7 +367,7 @@ do {\t\t\t\t\t\t   \\\n   DECL_LANG_FLAG_3 (FUNCTION_DECL_CHECK (NODE))\n \n /* Nonzero in a DECL if it is made for a pointer that points to something which\n-   is readonly.  Used mostly for fat pointers.  */\n+   is readonly.  */\n #define DECL_POINTS_TO_READONLY_P(NODE) DECL_LANG_FLAG_4 (NODE)\n \n /* Nonzero in a PARM_DECL if we are to pass by descriptor.  */"}, {"sha": "98d68fe01a67e0f463f9a5e037c07ae9eae06cd8", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c7d7973c44afbee5e1251b200cc6e7a27409b1/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c7d7973c44afbee5e1251b200cc6e7a27409b1/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=a1c7d7973c44afbee5e1251b200cc6e7a27409b1", "patch": "@@ -1417,6 +1417,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t     gnat_entity);\n \tDECL_BY_REF_P (gnu_decl) = used_by_ref;\n \tDECL_POINTS_TO_READONLY_P (gnu_decl) = used_by_ref && inner_const_flag;\n+\tDECL_CAN_NEVER_BE_NULL_P (gnu_decl) = Can_Never_Be_Null (gnat_entity);\n \n \t/* If we are defining an Out parameter and optimization isn't enabled,\n \t   create a fake PARM_DECL for debugging purposes and make it point to\n@@ -5568,6 +5569,7 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n                                       mech == By_Short_Descriptor);\n   DECL_POINTS_TO_READONLY_P (gnu_param)\n     = (ro_param && (by_ref || by_component_ptr));\n+  DECL_CAN_NEVER_BE_NULL_P (gnu_param) = Can_Never_Be_Null (gnat_param);\n \n   /* Save the alternate descriptor type, if any.  */\n   if (gnu_param_type_alt)"}, {"sha": "baa4ca1983b1e7043e3901f476504dbdf0ce78fa", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c7d7973c44afbee5e1251b200cc6e7a27409b1/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c7d7973c44afbee5e1251b200cc6e7a27409b1/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=a1c7d7973c44afbee5e1251b200cc6e7a27409b1", "patch": "@@ -3819,8 +3819,7 @@ convert (tree type, tree expr)\n       return gnat_build_constructor (type, v);\n     }\n \n-  /* There are some special cases of expressions that we process\n-     specially.  */\n+  /* There are some cases of expressions that we process specially.  */\n   switch (TREE_CODE (expr))\n     {\n     case ERROR_MARK:\n@@ -3976,21 +3975,11 @@ convert (tree type, tree expr)\n       break;\n \n     case UNCONSTRAINED_ARRAY_REF:\n-      {\n-\t/* Convert this to the type of the inner array by getting the address\n-\t   of the array from the template.  */\n-\tconst bool no_trap = TREE_THIS_NOTRAP (expr);\n-\texpr = TREE_OPERAND (expr, 0);\n-\texpr = build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t       build_component_ref (expr, NULL_TREE,\n-\t\t\t\t\t\t    TYPE_FIELDS\n-\t\t\t\t\t\t    (TREE_TYPE (expr)),\n-\t\t\t\t\t\t    false));\n-\tTREE_THIS_NOTRAP (expr) = no_trap;\n-\tetype = TREE_TYPE (expr);\n-\tecode = TREE_CODE (etype);\n-\tbreak;\n-      }\n+      /* First retrieve the underlying array.  */\n+      expr = maybe_unconstrained_array (expr);\n+      etype = TREE_TYPE (expr);\n+      ecode = TREE_CODE (etype);\n+      break;\n \n     case VIEW_CONVERT_EXPR:\n       {\n@@ -4282,6 +4271,8 @@ maybe_unconstrained_array (tree exp)\n       if (code == UNCONSTRAINED_ARRAY_REF)\n \t{\n \t  const bool read_only = TREE_READONLY (exp);\n+\t  const bool no_trap = TREE_THIS_NOTRAP (exp);\n+\n \t  exp = TREE_OPERAND (exp, 0);\n \t  if (TREE_CODE (exp) == COND_EXPR)\n \t    {\n@@ -4306,12 +4297,16 @@ maybe_unconstrained_array (tree exp)\n \t\t\t    TREE_OPERAND (exp, 0), op1, op2);\n \t    }\n \t  else\n-\t    exp = build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t\t  build_component_ref (exp, NULL_TREE,\n-\t\t\t\t\t\t       TYPE_FIELDS\n-\t\t\t\t\t\t       (TREE_TYPE (exp)),\n-\t\t\t\t\t\t       false));\n-\t  TREE_READONLY (exp) = read_only;\n+\t    {\n+\t      exp = build_unary_op (INDIRECT_REF, NULL_TREE,\n+\t\t\t\t    build_component_ref (exp, NULL_TREE,\n+\t\t\t\t\t\t         TYPE_FIELDS\n+\t\t\t\t\t\t         (TREE_TYPE (exp)),\n+\t\t\t\t\t\t         false));\n+\t      TREE_READONLY (exp) = read_only;\n+\t      TREE_THIS_NOTRAP (exp) = no_trap;\n+\t    }\n+\n \t  return exp;\n \t}\n "}, {"sha": "12c517c5c4a098edbe1cdeeca80ee4f78ce292ea", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 57, "deletions": 35, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c7d7973c44afbee5e1251b200cc6e7a27409b1/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c7d7973c44afbee5e1251b200cc6e7a27409b1/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=a1c7d7973c44afbee5e1251b200cc6e7a27409b1", "patch": "@@ -1276,44 +1276,60 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n       break;\n \n     case INDIRECT_REF:\n-      /* If we want to refer to an unconstrained array, use the appropriate\n-\t expression to do so.  This will never survive down to the back-end.\n-\t But if TYPE is a thin pointer, first convert to a fat pointer.  */\n-      if (TYPE_IS_THIN_POINTER_P (type)\n-\t  && TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type)))\n-\t{\n-\t  operand\n-\t    = convert (TREE_TYPE (TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type))),\n+      {\n+\tbool can_never_be_null;\n+\ttree t = operand;\n+\n+\twhile (CONVERT_EXPR_P (t) || TREE_CODE (t) == VIEW_CONVERT_EXPR)\n+\t  t = TREE_OPERAND (t, 0);\n+\n+\tcan_never_be_null = DECL_P (t) && DECL_CAN_NEVER_BE_NULL_P (t);\n+\n+\t/* If TYPE is a thin pointer, first convert to the fat pointer.  */\n+\tif (TYPE_IS_THIN_POINTER_P (type)\n+\t    && TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type)))\n+\t  {\n+\t    operand = convert\n+\t\t      (TREE_TYPE (TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type))),\n \t\t       operand);\n-\t  type = TREE_TYPE (operand);\n-\t}\n+\t    type = TREE_TYPE (operand);\n+\t  }\n \n-      if (TYPE_IS_FAT_POINTER_P (type))\n-\t{\n-\t  result = build1 (UNCONSTRAINED_ARRAY_REF,\n-\t\t\t   TYPE_UNCONSTRAINED_ARRAY (type), operand);\n-\t  TREE_READONLY (result)\n-\t    = TYPE_READONLY (TYPE_UNCONSTRAINED_ARRAY (type));\n-\t}\n+\t/* If we want to refer to an unconstrained array, use the appropriate\n+\t   expression.  But this will never survive down to the back-end.  */\n+\tif (TYPE_IS_FAT_POINTER_P (type))\n+\t  {\n+\t    result = build1 (UNCONSTRAINED_ARRAY_REF,\n+\t\t\t     TYPE_UNCONSTRAINED_ARRAY (type), operand);\n+\t    TREE_READONLY (result)\n+\t      = TYPE_READONLY (TYPE_UNCONSTRAINED_ARRAY (type));\n+\t  }\n \n-      /* If we are dereferencing an ADDR_EXPR, return its operand.  */\n-      else if (TREE_CODE (operand) == ADDR_EXPR)\n-\tresult = TREE_OPERAND (operand, 0);\n+\t/* If we are dereferencing an ADDR_EXPR, return its operand.  */\n+\telse if (TREE_CODE (operand) == ADDR_EXPR)\n+\t  result = TREE_OPERAND (operand, 0);\n \n-      /* Otherwise, build and fold the indirect reference.  */\n-      else\n-\t{\n-\t  result = build_fold_indirect_ref (operand);\n-\t  TREE_READONLY (result) = TYPE_READONLY (TREE_TYPE (type));\n-\t}\n+\t/* Otherwise, build and fold the indirect reference.  */\n+\telse\n+\t  {\n+\t    result = build_fold_indirect_ref (operand);\n+\t    TREE_READONLY (result) = TYPE_READONLY (TREE_TYPE (type));\n+\t  }\n \n-      if (!TYPE_IS_FAT_POINTER_P (type) && TYPE_VOLATILE (TREE_TYPE (type)))\n-\t{\n-\t  TREE_SIDE_EFFECTS (result) = 1;\n-\t  if (TREE_CODE (result) == INDIRECT_REF)\n-\t    TREE_THIS_VOLATILE (result) = TYPE_VOLATILE (TREE_TYPE (result));\n-\t}\n-      break;\n+\tif (!TYPE_IS_FAT_POINTER_P (type) && TYPE_VOLATILE (TREE_TYPE (type)))\n+\t  {\n+\t    TREE_SIDE_EFFECTS (result) = 1;\n+\t    if (TREE_CODE (result) == INDIRECT_REF)\n+\t      TREE_THIS_VOLATILE (result) = TYPE_VOLATILE (TREE_TYPE (result));\n+\t  }\n+\n+\tif ((TREE_CODE (result) == INDIRECT_REF\n+\t     || TREE_CODE (result) == UNCONSTRAINED_ARRAY_REF)\n+\t    && can_never_be_null)\n+\t  TREE_THIS_NOTRAP (result) = 1;\n+\n+\tbreak;\n+      }\n \n     case NEGATE_EXPR:\n     case BIT_NOT_EXPR:\n@@ -2442,7 +2458,10 @@ gnat_stabilize_reference_1 (tree e, bool force)\n   TREE_SIDE_EFFECTS (result) |= TREE_SIDE_EFFECTS (e);\n   TREE_THIS_VOLATILE (result) = TREE_THIS_VOLATILE (e);\n \n-  if (code == INDIRECT_REF || code == ARRAY_REF || code == ARRAY_RANGE_REF)\n+  if (code == INDIRECT_REF\n+      || code == UNCONSTRAINED_ARRAY_REF\n+      || code == ARRAY_REF\n+      || code == ARRAY_RANGE_REF)\n     TREE_THIS_NOTRAP (result) = TREE_THIS_NOTRAP (e);\n \n   return result;\n@@ -2578,7 +2597,10 @@ gnat_stabilize_reference (tree ref, bool force, bool *success)\n   TREE_SIDE_EFFECTS (result) |= TREE_SIDE_EFFECTS (ref);\n   TREE_THIS_VOLATILE (result) = TREE_THIS_VOLATILE (ref);\n \n-  if (code == INDIRECT_REF || code == ARRAY_REF || code == ARRAY_RANGE_REF)\n+  if (code == INDIRECT_REF\n+      || code == UNCONSTRAINED_ARRAY_REF\n+      || code == ARRAY_REF\n+      || code == ARRAY_RANGE_REF)\n     TREE_THIS_NOTRAP (result) = TREE_THIS_NOTRAP (ref);\n \n   return result;"}]}