{"sha": "b325faf9d99e6d49917c5929a864534629c56892", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjMyNWZhZjlkOTllNmQ0OTkxN2M1OTI5YTg2NDUzNDYyOWM1Njg5Mg==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2009-08-17T18:55:30Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2009-08-17T18:55:30Z"}, "message": "re PR fortran/37425 (Fortran 2003: GENERIC bindings as operators)\n\n2009-08-17  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/37425\n\t* resolve.c (get_checked_tb_operator_target): New routine to do checks\n\ton type-bound operators in common between intrinsic and user operators.\n\t(resolve_typebound_intrinsic_op): Call it.\n\t(resolve_typebound_user_op): Ditto.\n\n2009-08-17  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/37425\n\t* gfortran.dg/typebound_operator_2.f03: Test for error with illegal\n\tNOPASS bindings as operators.\n\nFrom-SVN: r150856", "tree": {"sha": "604fa49230c2dd7e3f8b9ffcc778f1cd14109f34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/604fa49230c2dd7e3f8b9ffcc778f1cd14109f34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b325faf9d99e6d49917c5929a864534629c56892", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b325faf9d99e6d49917c5929a864534629c56892", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b325faf9d99e6d49917c5929a864534629c56892", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b325faf9d99e6d49917c5929a864534629c56892/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "709a22df7924a3f186c9f06573fde3c63a0a926f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/709a22df7924a3f186c9f06573fde3c63a0a926f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/709a22df7924a3f186c9f06573fde3c63a0a926f"}], "stats": {"total": 62, "additions": 50, "deletions": 12}, "files": [{"sha": "10f95fb0cdfaaf9404cba5bd318990fd18571a47", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b325faf9d99e6d49917c5929a864534629c56892/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b325faf9d99e6d49917c5929a864534629c56892/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b325faf9d99e6d49917c5929a864534629c56892", "patch": "@@ -1,3 +1,11 @@\n+2009-08-17  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/37425\n+\t* resolve.c (get_checked_tb_operator_target): New routine to do checks\n+\ton type-bound operators in common between intrinsic and user operators.\n+\t(resolve_typebound_intrinsic_op): Call it.\n+\t(resolve_typebound_user_op): Ditto.\n+\n 2009-08-17  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/41075"}, {"sha": "4f99aba07087dd2cad9235a411e828d94cc36bb4", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b325faf9d99e6d49917c5929a864534629c56892/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b325faf9d99e6d49917c5929a864534629c56892/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=b325faf9d99e6d49917c5929a864534629c56892", "patch": "@@ -8965,6 +8965,29 @@ resolve_typebound_generic (gfc_symbol* derived, gfc_symtree* st)\n }\n \n \n+/* Retrieve the target-procedure of an operator binding and do some checks in\n+   common for intrinsic and user-defined type-bound operators.  */\n+\n+static gfc_symbol*\n+get_checked_tb_operator_target (gfc_tbp_generic* target, locus where)\n+{\n+  gfc_symbol* target_proc;\n+\n+  gcc_assert (target->specific && !target->specific->is_generic);\n+  target_proc = target->specific->u.specific->n.sym;\n+  gcc_assert (target_proc);\n+\n+  /* All operator bindings must have a passed-object dummy argument.  */\n+  if (target->specific->nopass)\n+    {\n+      gfc_error (\"Type-bound operator at %L can't be NOPASS\", &where);\n+      return NULL;\n+    }\n+\n+  return target_proc;\n+}\n+\n+\n /* Resolve a type-bound intrinsic operator.  */\n \n static gfc_try\n@@ -8998,9 +9021,9 @@ resolve_typebound_intrinsic_op (gfc_symbol* derived, gfc_intrinsic_op op,\n     {\n       gfc_symbol* target_proc;\n \n-      gcc_assert (target->specific && !target->specific->is_generic);\n-      target_proc = target->specific->u.specific->n.sym;\n-      gcc_assert (target_proc);\n+      target_proc = get_checked_tb_operator_target (target, p->where);\n+      if (!target_proc)\n+\treturn FAILURE;\n \n       if (!gfc_check_operator_interface (target_proc, op, p->where))\n \treturn FAILURE;\n@@ -9059,9 +9082,9 @@ resolve_typebound_user_op (gfc_symtree* stree)\n     {\n       gfc_symbol* target_proc;\n \n-      gcc_assert (target->specific && !target->specific->is_generic);\n-      target_proc = target->specific->u.specific->n.sym;\n-      gcc_assert (target_proc);\n+      target_proc = get_checked_tb_operator_target (target, stree->n.tb->where);\n+      if (!target_proc)\n+\tgoto error;\n \n       if (check_uop_procedure (target_proc, stree->n.tb->where) == FAILURE)\n \tgoto error;"}, {"sha": "7c905d7ad461a9bdf2046a18b18c1a27ef149c5a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b325faf9d99e6d49917c5929a864534629c56892/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b325faf9d99e6d49917c5929a864534629c56892/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b325faf9d99e6d49917c5929a864534629c56892", "patch": "@@ -1,3 +1,9 @@\n+2009-08-17  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/37425\n+\t* gfortran.dg/typebound_operator_2.f03: Test for error with illegal\n+\tNOPASS bindings as operators.\n+\n 2009-08-17  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* lib/target-supports.exp"}, {"sha": "67f467cf9b82bdebe341eaacc64fa1e2e29da5f4", "filename": "gcc/testsuite/gfortran.dg/typebound_operator_2.f03", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b325faf9d99e6d49917c5929a864534629c56892/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b325faf9d99e6d49917c5929a864534629c56892/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_2.f03?ref=b325faf9d99e6d49917c5929a864534629c56892", "patch": "@@ -13,8 +13,8 @@ MODULE m\n     PROCEDURE, PASS :: onearg\n     PROCEDURE, PASS :: onearg_alt => onearg\n     PROCEDURE, PASS :: onearg_alt2 => onearg\n+    PROCEDURE, NOPASS :: nopassed => onearg\n     PROCEDURE, PASS :: threearg\n-    PROCEDURE, NOPASS :: noarg\n     PROCEDURE, PASS :: sub\n     PROCEDURE, PASS :: sub2 ! { dg-error \"must be a FUNCTION\" }\n     PROCEDURE, PASS :: func\n@@ -26,10 +26,15 @@ MODULE m\n \n     GENERIC :: OPERATOR(.UOPA.) => sub ! { dg-error \"must be a FUNCTION\" }\n     GENERIC :: OPERATOR(.UOPB.) => threearg ! { dg-error \"at most, two arguments\" }\n-    GENERIC :: OPERATOR(.UOPC.) => noarg ! { dg-error \"at least one argument\" }\n+    ! We can't check for the 'at least one argument' error, because in this case\n+    ! the procedure must be NOPASS and that other error is issued.  But of\n+    ! course this should be alright.\n \n     GENERIC :: OPERATOR(.UNARY.) => onearg_alt\n     GENERIC, PRIVATE :: OPERATOR(.UNARY.) => onearg_alt2 ! { dg-error \"must have the same access\" }\n+\n+    GENERIC :: OPERATOR(.UNARYPRIME.) => nopassed ! { dg-error \"can't be NOPASS\" }\n+    GENERIC :: OPERATOR(-) => nopassed ! { dg-error \"can't be NOPASS\" }\n   END TYPE t\n \n CONTAINS\n@@ -44,10 +49,6 @@ INTEGER FUNCTION threearg (a, b, c)\n     threearg = 42\n   END FUNCTION threearg\n \n-  INTEGER FUNCTION noarg ()\n-    noarg = 42\n-  END FUNCTION noarg\n-\n   LOGICAL FUNCTION func (me, b) ! { dg-error \"must be a SUBROUTINE\" }\n     CLASS(t), INTENT(OUT) :: me\n     CLASS(t), INTENT(IN) :: b"}]}