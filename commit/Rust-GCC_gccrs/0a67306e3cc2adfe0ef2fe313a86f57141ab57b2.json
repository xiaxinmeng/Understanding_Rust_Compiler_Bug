{"sha": "0a67306e3cc2adfe0ef2fe313a86f57141ab57b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE2NzMwNmUzY2MyYWRmZTBlZjJmZTMxM2E4NmY1NzE0MWFiNTdiMg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2019-10-18T19:02:43Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-10-18T19:02:43Z"}, "message": "[arm] Correctly cost addition with a carry-in\n\nThe cost routine for Arm and Thumb2 was not recognising the idioms that\ndescribe the addition with carry, this results in the instructions\nappearing more expensive than they really are, which occasionally can lead\nto poor choices by combine.  Recognising all the possible variants is\na little trickier than normal because the expressions can become complex\nenough that this is no single canonical from.\n\n\t* config/arm/arm.c (strip_carry_operation): New function.\n\t(arm_rtx_costs_internal, case PLUS): Handle addtion with carry-in\n\tfor SImode.\n\nFrom-SVN: r277172", "tree": {"sha": "bc6d57abbdd9f82006e4b9f3d43b5b08b06d27c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc6d57abbdd9f82006e4b9f3d43b5b08b06d27c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a67306e3cc2adfe0ef2fe313a86f57141ab57b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a67306e3cc2adfe0ef2fe313a86f57141ab57b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a67306e3cc2adfe0ef2fe313a86f57141ab57b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a67306e3cc2adfe0ef2fe313a86f57141ab57b2/comments", "author": null, "committer": null, "parents": [{"sha": "1e271beeec163b124eb424c0c9918b045e289c06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e271beeec163b124eb424c0c9918b045e289c06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e271beeec163b124eb424c0c9918b045e289c06"}], "stats": {"total": 82, "additions": 71, "deletions": 11}, "files": [{"sha": "aa6b2cb4254ebb08d94848c396ec7fe661dcb49a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a67306e3cc2adfe0ef2fe313a86f57141ab57b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a67306e3cc2adfe0ef2fe313a86f57141ab57b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a67306e3cc2adfe0ef2fe313a86f57141ab57b2", "patch": "@@ -1,3 +1,9 @@\n+2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm.c (strip_carry_operation): New function.\n+\t(arm_rtx_costs_internal, case PLUS): Handle addtion with carry-in\n+\tfor SImode.\n+\n 2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/predicates.md (arm_carry_operation): New special"}, {"sha": "820a41f8a242722446f836e22e48437e81a48c4f", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 65, "deletions": 11, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a67306e3cc2adfe0ef2fe313a86f57141ab57b2/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a67306e3cc2adfe0ef2fe313a86f57141ab57b2/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=0a67306e3cc2adfe0ef2fe313a86f57141ab57b2", "patch": "@@ -9504,6 +9504,20 @@ thumb1_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)\n     }\n }\n \n+/* Helper function for arm_rtx_costs.  If one operand of the OP, a\n+   PLUS, adds the carry flag, then return the other operand.  If\n+   neither is a carry, return OP unchanged.  */\n+static rtx\n+strip_carry_operation (rtx op)\n+{\n+  gcc_assert (GET_CODE (op) == PLUS);\n+  if (arm_carry_operation (XEXP (op, 0), GET_MODE (op)))\n+    return XEXP (op, 1);\n+  else if (arm_carry_operation (XEXP (op, 1), GET_MODE (op)))\n+    return XEXP (op, 0);\n+  return op;\n+}\n+\n /* Helper function for arm_rtx_costs.  If the operand is a valid shift\n    operand, then return the operand that is being shifted.  If the shift\n    is not by a constant, then set SHIFT_REG to point to the operand.\n@@ -10253,8 +10267,41 @@ arm_rtx_costs_internal (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t      return true;\n \t    }\n \n+\t  rtx op0 = XEXP (x, 0);\n+\t  rtx op1 = XEXP (x, 1);\n+\n+\t  /* Handle a side effect of adding in the carry to an addition.  */\n+\t  if (GET_CODE (op0) == PLUS\n+\t      && arm_carry_operation (op1, mode))\n+\t    {\n+\t      op1 = XEXP (op0, 1);\n+\t      op0 = XEXP (op0, 0);\n+\t    }\n+\t  else if (GET_CODE (op1) == PLUS\n+\t\t   && arm_carry_operation (op0, mode))\n+\t    {\n+\t      op0 = XEXP (op1, 0);\n+\t      op1 = XEXP (op1, 1);\n+\t    }\n+\t  else if (GET_CODE (op0) == PLUS)\n+\t    {\n+\t      op0 = strip_carry_operation (op0);\n+\t      if (swap_commutative_operands_p (op0, op1))\n+\t\tstd::swap (op0, op1);\n+\t    }\n+\n+\t  if (arm_carry_operation (op0, mode))\n+\t    {\n+\t      /* Adding the carry to a register is a canonicalization of\n+\t\t adding 0 to the register plus the carry.  */\n+\t      if (speed_p)\n+\t\t*cost += extra_cost->alu.arith;\n+\t      *cost += rtx_cost (op1, mode, PLUS, 1, speed_p);\n+\t      return true;\n+\t    }\n+\n \t  shift_reg = NULL;\n-\t  shift_op = shifter_op_p (XEXP (x, 0), &shift_reg);\n+\t  shift_op = shifter_op_p (op0, &shift_reg);\n \t  if (shift_op != NULL)\n \t    {\n \t      if (shift_reg)\n@@ -10267,12 +10314,13 @@ arm_rtx_costs_internal (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t*cost += extra_cost->alu.arith_shift;\n \n \t      *cost += (rtx_cost (shift_op, mode, ASHIFT, 0, speed_p)\n-\t\t\t+ rtx_cost (XEXP (x, 1), mode, PLUS, 1, speed_p));\n+\t\t\t+ rtx_cost (op1, mode, PLUS, 1, speed_p));\n \t      return true;\n \t    }\n-\t  if (GET_CODE (XEXP (x, 0)) == MULT)\n+\n+\t  if (GET_CODE (op0) == MULT)\n \t    {\n-\t      rtx mul_op = XEXP (x, 0);\n+\t      rtx mul_op = op0;\n \n \t      if (TARGET_DSP_MULTIPLY\n \t\t  && ((GET_CODE (XEXP (mul_op, 0)) == SIGN_EXTEND\n@@ -10296,32 +10344,38 @@ arm_rtx_costs_internal (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t\t\t      SIGN_EXTEND, 0, speed_p)\n \t\t\t    + rtx_cost (XEXP (XEXP (mul_op, 1), 0), mode,\n \t\t\t\t\tSIGN_EXTEND, 0, speed_p)\n-\t\t\t    + rtx_cost (XEXP (x, 1), mode, PLUS, 1, speed_p));\n+\t\t\t    + rtx_cost (op1, mode, PLUS, 1, speed_p));\n \t\t  return true;\n \t\t}\n \n \t      if (speed_p)\n \t\t*cost += extra_cost->mult[0].add;\n \t      *cost += (rtx_cost (XEXP (mul_op, 0), mode, MULT, 0, speed_p)\n \t\t\t+ rtx_cost (XEXP (mul_op, 1), mode, MULT, 1, speed_p)\n-\t\t\t+ rtx_cost (XEXP (x, 1), mode, PLUS, 1, speed_p));\n+\t\t\t+ rtx_cost (op1, mode, PLUS, 1, speed_p));\n \t      return true;\n \t    }\n-\t  if (CONST_INT_P (XEXP (x, 1)))\n+\n+\t  if (CONST_INT_P (op1))\n \t    {\n \t      int insns = arm_gen_constant (PLUS, SImode, NULL_RTX,\n-\t\t\t\t\t    INTVAL (XEXP (x, 1)), NULL_RTX,\n+\t\t\t\t\t    INTVAL (op1), NULL_RTX,\n \t\t\t\t\t    NULL_RTX, 1, 0);\n \t      *cost = COSTS_N_INSNS (insns);\n \t      if (speed_p)\n \t\t*cost += insns * extra_cost->alu.arith;\n-\t      *cost += rtx_cost (XEXP (x, 0), mode, PLUS, 0, speed_p);\n+\t      *cost += rtx_cost (op0, mode, PLUS, 0, speed_p);\n \t      return true;\n \t    }\n-\t  else if (speed_p)\n+\n+\t  if (speed_p)\n \t    *cost += extra_cost->alu.arith;\n \n-\t  return false;\n+\t  /* Don't recurse here because we want to test the operands\n+\t     without any carry operation.  */\n+\t  *cost += rtx_cost (op0, mode, PLUS, 0, speed_p);\n+\t  *cost += rtx_cost (op1, mode, PLUS, 1, speed_p);\n+\t  return true;\n \t}\n \n       if (mode == DImode)"}]}