{"sha": "93fa842809e11c31a60d603dac8da965d0328869", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNmYTg0MjgwOWUxMWMzMWE2MGQ2MDNkYWM4ZGE5NjVkMDMyODg2OQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2006-03-24T19:09:11Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2006-03-24T19:09:11Z"}, "message": "s390.c (s390_decompose_address): Allow SImode for index and base register.\n\n2006-03-24  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* config/s390/s390.c (s390_decompose_address): Allow SImode for\n\tindex and base register.\n\t(s390_expand_plug_operand, legitimate_address_p, preferred_la_operand_p,\n\tprint_operand_address, print_operand): Replaced REG_OK_FOR_BASE_STRICT_P\n\twith REGNO_OK_FOR_BASE_P and REG_OK_FOR_INDEX_STRICT_P with\n\tREGNO_OK_FOR_INDEX_P.\n\t* config/s390/s390.h (REGNO_OK_FOR_INDEX_P): Replaced check with\n\tADDR_REGNO_P.\n\t(REG_OK_FOR_INDEX_NONSTRICT_P, REG_OK_FOR_BASE_NONSTRICT_P,\n\tREG_OK_FOR_INDEX_STRICT_P, REG_OK_FOR_BASE_STRICT_P, REG_OK_FOR_INDEX_P,\n\tREG_OK_FOR_BASE_P): Definitions removed.\n\nFrom-SVN: r112357", "tree": {"sha": "7c3fbb686b7ffebd06bf1b284b40151addcb088e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c3fbb686b7ffebd06bf1b284b40151addcb088e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93fa842809e11c31a60d603dac8da965d0328869", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93fa842809e11c31a60d603dac8da965d0328869", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93fa842809e11c31a60d603dac8da965d0328869", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93fa842809e11c31a60d603dac8da965d0328869/comments", "author": null, "committer": null, "parents": [{"sha": "d0c03515ba316fc4875d12dd219cc6c21891ef4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0c03515ba316fc4875d12dd219cc6c21891ef4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0c03515ba316fc4875d12dd219cc6c21891ef4a"}], "stats": {"total": 93, "additions": 42, "deletions": 51}, "files": [{"sha": "8bc62daa26ecff221d7e5dbb544b83d92f89e564", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93fa842809e11c31a60d603dac8da965d0328869/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93fa842809e11c31a60d603dac8da965d0328869/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93fa842809e11c31a60d603dac8da965d0328869", "patch": "@@ -1,3 +1,17 @@\n+2006-03-24  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* config/s390/s390.c (s390_decompose_address): Allow SImode for\n+\tindex and base register.\n+\t(s390_expand_plug_operand, legitimate_address_p, preferred_la_operand_p,\n+\tprint_operand_address, print_operand): Replaced REG_OK_FOR_BASE_STRICT_P\n+\twith REGNO_OK_FOR_BASE_P and REG_OK_FOR_INDEX_STRICT_P with\n+\tREGNO_OK_FOR_INDEX_P.\n+\t* config/s390/s390.h (REGNO_OK_FOR_INDEX_P): Replaced check with\n+\tADDR_REGNO_P.\n+\t(REG_OK_FOR_INDEX_NONSTRICT_P, REG_OK_FOR_BASE_NONSTRICT_P,\n+\tREG_OK_FOR_INDEX_STRICT_P, REG_OK_FOR_BASE_STRICT_P, REG_OK_FOR_INDEX_P,\n+\tREG_OK_FOR_BASE_P): Definitions removed.\n+\n 2006-03-24  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/26611"}, {"sha": "0d03fa603d7a7c4e8a835f25113d21691c0ab4b8", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93fa842809e11c31a60d603dac8da965d0328869/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93fa842809e11c31a60d603dac8da965d0328869/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=93fa842809e11c31a60d603dac8da965d0328869", "patch": "@@ -1617,7 +1617,9 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n \t    return false;\n \t  }\n \n-      if (GET_CODE (base) != REG || GET_MODE (base) != Pmode)\n+      if (!REG_P (base) \n+\t  || (GET_MODE (base) != SImode \n+\t      && GET_MODE (base) != Pmode))\n \treturn false;\n \n       if (REGNO (base) == STACK_POINTER_REGNUM\n@@ -1663,7 +1665,9 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n \t    return false;\n \t  }\n \n-      if (GET_CODE (indx) != REG || GET_MODE (indx) != Pmode)\n+      if (!REG_P (indx) \n+\t  || (GET_MODE (indx) != SImode\n+\t      && GET_MODE (indx) != Pmode))\n \treturn false;\n \n       if (REGNO (indx) == STACK_POINTER_REGNUM\n@@ -2678,8 +2682,8 @@ s390_expand_plus_operand (rtx target, rtx src,\n \n   /* If the address is already strictly valid, there's nothing to do.  */\n   if (!s390_decompose_address (src, &ad)\n-      || (ad.base && !REG_OK_FOR_BASE_STRICT_P (ad.base))\n-      || (ad.indx && !REG_OK_FOR_INDEX_STRICT_P (ad.indx)))\n+      || (ad.base && !REGNO_OK_FOR_BASE_P (REGNO (ad.base)))\n+      || (ad.indx && !REGNO_OK_FOR_INDEX_P (REGNO (ad.indx))))\n     {\n       /* Otherwise, one of the operands cannot be an address register;\n          we reload its value into the scratch register.  */\n@@ -2727,19 +2731,24 @@ legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n \n   if (strict)\n     {\n-      if (ad.base && !REG_OK_FOR_BASE_STRICT_P (ad.base))\n+      if (ad.base && !REGNO_OK_FOR_BASE_P (REGNO (ad.base)))\n \treturn false;\n-      if (ad.indx && !REG_OK_FOR_INDEX_STRICT_P (ad.indx))\n+\n+      if (ad.indx && !REGNO_OK_FOR_INDEX_P (REGNO (ad.indx)))\n \treturn false;\n     }\n   else\n     {\n-      if (ad.base && !REG_OK_FOR_BASE_NONSTRICT_P (ad.base))\n-\treturn false;\n-      if (ad.indx && !REG_OK_FOR_INDEX_NONSTRICT_P (ad.indx))\n+      if (ad.base \n+\t  && !(REGNO (ad.base) >= FIRST_PSEUDO_REGISTER\n+\t       || REGNO_REG_CLASS (REGNO (ad.base)) == ADDR_REGS))\n \treturn false;\n+      \n+      if (ad.indx\n+\t  && !(REGNO (ad.indx) >= FIRST_PSEUDO_REGISTER\n+\t       || REGNO_REG_CLASS (REGNO (ad.indx)) == ADDR_REGS))\n+\t  return false;\n     }\n-\n   return true;\n }\n \n@@ -2770,9 +2779,9 @@ preferred_la_operand_p (rtx op1, rtx op2)\n \n   if (!s390_decompose_address (op1, &addr))\n     return false;\n-  if (addr.base && !REG_OK_FOR_BASE_STRICT_P (addr.base))\n+  if (addr.base && !REGNO_OK_FOR_BASE_P (REGNO (addr.base)))\n     return false;\n-  if (addr.indx && !REG_OK_FOR_INDEX_STRICT_P (addr.indx))\n+  if (addr.indx && !REGNO_OK_FOR_INDEX_P (REGNO (addr.indx)))\n     return false;\n \n   if (!TARGET_64BIT && !addr.pointer)\n@@ -4500,8 +4509,8 @@ print_operand_address (FILE *file, rtx addr)\n   struct s390_address ad;\n \n   if (!s390_decompose_address (addr, &ad)\n-      || (ad.base && !REG_OK_FOR_BASE_STRICT_P (ad.base))\n-      || (ad.indx && !REG_OK_FOR_INDEX_STRICT_P (ad.indx)))\n+      || (ad.base && !REGNO_OK_FOR_BASE_P (REGNO (ad.base)))\n+      || (ad.indx && !REGNO_OK_FOR_INDEX_P (REGNO (ad.indx))))\n     output_operand_lossage (\"cannot decompose address\");\n \n   if (ad.disp)\n@@ -4585,7 +4594,7 @@ print_operand (FILE *file, rtx x, int code)\n         gcc_assert (GET_CODE (x) == MEM);\n \tret = s390_decompose_address (XEXP (x, 0), &ad);\n \tgcc_assert (ret);\n-\tgcc_assert (!ad.base || REG_OK_FOR_BASE_STRICT_P (ad.base));\n+\tgcc_assert (!ad.base || REGNO_OK_FOR_BASE_P (REGNO (ad.base)));\n \tgcc_assert (!ad.indx);\n \n         if (ad.disp)\n@@ -4603,7 +4612,7 @@ print_operand (FILE *file, rtx x, int code)\n         gcc_assert (GET_CODE (x) == MEM);\n \tret = s390_decompose_address (XEXP (x, 0), &ad);\n \tgcc_assert (ret);\n-\tgcc_assert (!ad.base || REG_OK_FOR_BASE_STRICT_P (ad.base));\n+\tgcc_assert (!ad.base || REGNO_OK_FOR_BASE_P (REGNO (ad.base)));\n \tgcc_assert (!ad.indx);\n \n         if (ad.base)\n@@ -4621,7 +4630,7 @@ print_operand (FILE *file, rtx x, int code)\n         gcc_assert (GET_CODE (x) == MEM);\n \tret = s390_decompose_address (XEXP (x, 0), &ad);\n \tgcc_assert (ret);\n-\tgcc_assert (!ad.base || REG_OK_FOR_BASE_STRICT_P (ad.base));\n+\tgcc_assert (!ad.base || REGNO_OK_FOR_BASE_P (REGNO (ad.base)));\n \tgcc_assert (!ad.indx);\n \n \tif (ad.disp)"}, {"sha": "5feb9d5b7cfc7749b399cd473fd8048d3c0f4622", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93fa842809e11c31a60d603dac8da965d0328869/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93fa842809e11c31a60d603dac8da965d0328869/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=93fa842809e11c31a60d603dac8da965d0328869", "patch": "@@ -476,8 +476,8 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n    or a pseudo register currently allocated to one such.  */\n #define REGNO_OK_FOR_INDEX_P(REGNO)\t\t\t\t\t\\\n     (((REGNO) < FIRST_PSEUDO_REGISTER \t\t\t\t\t\\\n-     && REGNO_REG_CLASS ((REGNO)) == ADDR_REGS) \t\t\t\\\n-    || (reg_renumber[REGNO] > 0 && reg_renumber[REGNO] < 16))\n+      && REGNO_REG_CLASS ((REGNO)) == ADDR_REGS) \t\t\t\\\n+     || ADDR_REGNO_P (reg_renumber[REGNO]))\n #define REGNO_OK_FOR_BASE_P(REGNO) REGNO_OK_FOR_INDEX_P (REGNO)\n \n \n@@ -729,38 +729,6 @@ CUMULATIVE_ARGS;\n /* Maximum number of registers that can appear in a valid memory address.  */\n #define MAX_REGS_PER_ADDRESS 2\n \n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx and check\n-   its validity for a certain class.  We have two alternate definitions\n-   for each of them.  The usual definition accepts all pseudo regs; the\n-   other rejects them all.  The symbol REG_OK_STRICT causes the latter\n-   definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that they will\n-   get allocated to the class that the insn wants them to be in.\n-   Some source files that are used after register allocation\n-   need to be strict.  */\n-\n-#define REG_OK_FOR_INDEX_NONSTRICT_P(X)   \t\\\n-((GET_MODE (X) == Pmode) &&\t\t\t\\\n- ((REGNO (X) >= FIRST_PSEUDO_REGISTER) \t\t\\\n-  || REGNO_REG_CLASS (REGNO (X)) == ADDR_REGS))\n-\n-#define REG_OK_FOR_BASE_NONSTRICT_P(X)    REG_OK_FOR_INDEX_NONSTRICT_P (X)\n-\n-#define REG_OK_FOR_INDEX_STRICT_P(X) \t\t\t\t\\\n-((GET_MODE (X) == Pmode) && (REGNO_OK_FOR_INDEX_P (REGNO (X))))\n-\n-#define REG_OK_FOR_BASE_STRICT_P(X)\t\t\t\t\\\n-((GET_MODE (X) == Pmode) && (REGNO_OK_FOR_BASE_P (REGNO (X))))\n-\n-#ifndef REG_OK_STRICT\n-#define REG_OK_FOR_INDEX_P(X)  REG_OK_FOR_INDEX_NONSTRICT_P(X)\n-#define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_NONSTRICT_P(X)\n-#else\n-#define REG_OK_FOR_INDEX_P(X)  REG_OK_FOR_INDEX_STRICT_P(X)\n-#define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_STRICT_P(X)\n-#endif\n-\n /* S/390 has no mode dependent addresses.  */\n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\n "}]}