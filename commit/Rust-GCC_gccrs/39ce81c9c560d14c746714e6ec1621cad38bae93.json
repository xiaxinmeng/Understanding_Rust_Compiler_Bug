{"sha": "39ce81c9c560d14c746714e6ec1621cad38bae93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzljZTgxYzljNTYwZDE0Yzc0NjcxNGU2ZWMxNjIxY2FkMzhiYWU5Mw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2005-06-30T23:09:06Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2005-06-30T23:09:06Z"}, "message": "pretty-print.h (PP_NL_ARGMAX): New.\n\ngcc:\n\t* pretty-print.h (PP_NL_ARGMAX): New.\n\t(text_info): Add locus.\n\t(struct chunk_info): New.\n\t(output_buffer): Add formatted_obstack, chunk_obstack, and\n\tcur_chunk_array. Change obstack to a pointer.\n\t(pp_wrapping_mode_t, pp_wrapping_mode, pp_set_verbatim_wrapping): New.\n\t(struct pretty_print_info): Replace ideal_maximum_length and\n\tprefixing_rule with wrapping.\n\t(pp_line_cutoff, pp_prefixing_rule): Update to match.\n\tUpdate prototypes and wrapper macros throughout.\n\t* pretty-print.c (pp_formatted_text_data, pp_append_r)\n\t(pp_base_clear_output_area, pp_construct, pp_base_formatted_text)\n\t(pp_base_last_position_in_text, pp_base_newline, pp_base_character):\n\tUpdate for changes to pp structure.\n\t(pp_base_prepare_to_format, pp_base_format_text): Delete.\n\t(pp_base_format, pp_base_output_formatted_text): New functions.\n\t(pp_base_format_verbatim): Use pp_set_verbatim_wrapping.\n\t(pp_verbatim): Clear text.locus.\n\t(pp_printf): Likewise.  Use pp_format and pp_output_formatted_text.\n\t* c-objc-common.c (c_tree_printer): Update function signature.\n\t* diagnostic.c (diagnostic_initialize): Update for changes to\n\tpp structure.\n\t(diagnostic_report_diagnostic): Call pp_format and then\n\tpp_output_formatted_text.\n\t(verbatim): Clear text.locus.\n\t* diagnostic.h (diagnostic_prefixing_rule, diagnostic_line_cutoff):\n\tUpdate for changes to pp structure.\n\n\t* c-lang.c: No need to include c-pretty-print.h.\n\t* Makefile.in: Remove bogus line containing only a tab.\n\t(c-lang.o): Update dependencies.\n\t* toplev.c (announce_function): Don't use verbatim.\n\t(default_tree_printer): Update signature.\n\n\t* objc/objc-lang.c: No need to include c-pretty-print.h.\n\t* objc/Make-lang.in: Update dependencies.\n\ngcc/cp:\n\t* cp-lang.c: No need to include cxx-pretty-print.h.\n\t* error.c (cp_printer): Update signature.  No need to process\n\tflags.\n\t(print_instantiation_partial_context): Output last newline\n\twith pp_base_newline.\n\t* Make-lang.in: Update dependencies.\n\ngcc/objcp:\n\t* objcp-lang.c: No need to include cxx-pretty-print.h.\n\t* Make-lang.in: Update dependencies.\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r101481", "tree": {"sha": "aaf251a28f0a2167060005edc8eb763baadddd63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aaf251a28f0a2167060005edc8eb763baadddd63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39ce81c9c560d14c746714e6ec1621cad38bae93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ce81c9c560d14c746714e6ec1621cad38bae93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39ce81c9c560d14c746714e6ec1621cad38bae93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ce81c9c560d14c746714e6ec1621cad38bae93/comments", "author": null, "committer": null, "parents": [{"sha": "a3648cfc0c331051ae47bedcc40c561f9979673a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3648cfc0c331051ae47bedcc40c561f9979673a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3648cfc0c331051ae47bedcc40c561f9979673a"}], "stats": {"total": 742, "additions": 531, "deletions": 211}, "files": [{"sha": "b3a52610a12c375354f7773e02cb832045d6d0e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39ce81c9c560d14c746714e6ec1621cad38bae93", "patch": "@@ -1,3 +1,43 @@\n+2005-06-30  Zack Weinberg  <zack@codesourcery.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* pretty-print.h (PP_NL_ARGMAX): New.\n+\t(text_info): Add locus.\n+\t(struct chunk_info): New.\n+\t(output_buffer): Add formatted_obstack, chunk_obstack, and\n+\tcur_chunk_array. Change obstack to a pointer.\n+\t(pp_wrapping_mode_t, pp_wrapping_mode, pp_set_verbatim_wrapping): New.\n+\t(struct pretty_print_info): Replace ideal_maximum_length and\n+\tprefixing_rule with wrapping.\n+\t(pp_line_cutoff, pp_prefixing_rule): Update to match.\n+\tUpdate prototypes and wrapper macros throughout.\n+\t* pretty-print.c (pp_formatted_text_data, pp_append_r)\n+\t(pp_base_clear_output_area, pp_construct, pp_base_formatted_text)\n+\t(pp_base_last_position_in_text, pp_base_newline, pp_base_character):\n+\tUpdate for changes to pp structure.\n+\t(pp_base_prepare_to_format, pp_base_format_text): Delete.\n+\t(pp_base_format, pp_base_output_formatted_text): New functions.\n+\t(pp_base_format_verbatim): Use pp_set_verbatim_wrapping.\n+\t(pp_verbatim): Clear text.locus.\n+\t(pp_printf): Likewise.  Use pp_format and pp_output_formatted_text.\n+\t* c-objc-common.c (c_tree_printer): Update function signature.\n+\t* diagnostic.c (diagnostic_initialize): Update for changes to\n+\tpp structure.\n+\t(diagnostic_report_diagnostic): Call pp_format and then\n+\tpp_output_formatted_text.\n+\t(verbatim): Clear text.locus.\n+\t* diagnostic.h (diagnostic_prefixing_rule, diagnostic_line_cutoff):\n+\tUpdate for changes to pp structure.\n+\n+\t* c-lang.c: No need to include c-pretty-print.h.\n+\t* Makefile.in: Remove bogus line containing only a tab.\n+\t(c-lang.o): Update dependencies.\n+\t* toplev.c (announce_function): Don't use verbatim.\n+\t(default_tree_printer): Update signature.\n+\n+\t* objc/objc-lang.c: No need to include c-pretty-print.h.\n+\t* objc/Make-lang.in: Update dependencies.\n+\n 2005-06-29  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* tree-complex.c (complex_variable_components): Now a hashtable."}, {"sha": "ade51f7d03b16be23c652e83a21c9cee864514d2", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=39ce81c9c560d14c746714e6ec1621cad38bae93", "patch": "@@ -1216,7 +1216,6 @@ stamp-as: $(ORIGINAL_AS_FOR_TARGET)\n \t     chmod +x as ;; \\\n \tesac\n \techo timestamp > $@\n-\t\n \n stamp-collect-ld: $(ORIGINAL_LD_FOR_TARGET)\n \t@echo creating collect-ld; rm -f collect-ld; \\\n@@ -1452,7 +1451,7 @@ c-typeck.o : c-typeck.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n     $(RTL_H) toplev.h $(TM_P_H) langhooks.h $(GGC_H) $(TREE_FLOW_H) \\\n     $(TREE_GIMPLE_H) tree-iterator.h\n c-lang.o : c-lang.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-    $(C_TREE_H) $(C_PRETTY_PRINT_H) $(DIAGNOSTIC_H) \\\n+    $(C_TREE_H) $(DIAGNOSTIC_H) \\\n     $(GGC_H) langhooks.h $(LANGHOOKS_DEF_H) $(C_COMMON_H) gtype-c.h \\\n     c-objc-common.h $(C_PRAGMA_H) c-common.def tree-inline.h\n stub-objc.o : stub-objc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\"}, {"sha": "81fb05bc700eebcec6050a29b1c99061feb6bcbc", "filename": "gcc/c-lang.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=39ce81c9c560d14c746714e6ec1621cad38bae93", "patch": "@@ -32,7 +32,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"langhooks-def.h\"\n #include \"tree-inline.h\"\n #include \"diagnostic.h\"\n-#include \"c-pretty-print.h\"\n #include \"c-objc-common.h\"\n #include \"c-pragma.h\"\n "}, {"sha": "0fb5b619ba47279e5f2713eb213ebcffb57a9278", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=39ce81c9c560d14c746714e6ec1621cad38bae93", "patch": "@@ -40,7 +40,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"target.h\"\n #include \"c-objc-common.h\"\n \n-static bool c_tree_printer (pretty_printer *, text_info *);\n+static bool c_tree_printer (pretty_printer *, text_info *, const char *,\n+\t\t\t    int, bool, bool, bool);\n \n bool\n c_missing_noreturn_ok_p (tree decl)\n@@ -160,15 +161,20 @@ c_objc_common_init (void)\n    Please notice when called, the `%' part was already skipped by the\n    diagnostic machinery.  */\n static bool\n-c_tree_printer (pretty_printer *pp, text_info *text)\n+c_tree_printer (pretty_printer *pp, text_info *text, const char *spec,\n+\t\tint precision, bool wide, bool plus, bool hash)\n {\n   tree t = va_arg (*text->args_ptr, tree);\n   tree name;\n   const char *n = \"({anonymous})\";\n   c_pretty_printer *cpp = (c_pretty_printer *) pp;\n   pp->padding = pp_none;\n \n-  switch (*text->format_spec)\n+  /* FUTURE: %+x should set the locus.  */\n+  if (precision != 0 || wide || plus || hash)\n+    return false;\n+\n+  switch (*spec)\n     {\n     case 'D':\n       if (DECL_DEBUG_EXPR_IS_FROM (t) && DECL_DEBUG_EXPR (t))"}, {"sha": "af099af89285ed31353565ff54a7e5eca8ace8e7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=39ce81c9c560d14c746714e6ec1621cad38bae93", "patch": "@@ -1,3 +1,13 @@\n+2005-06-30  Zack Weinberg  <zack@codesourcery.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cp-lang.c: No need to include cxx-pretty-print.h.\n+\t* error.c (cp_printer): Update signature.  No need to process\n+\tflags.\n+\t(print_instantiation_partial_context): Output last newline\n+\twith pp_base_newline.\n+\t* Make-lang.in: Update dependencies.\n+\n 2005-06-30  Steven Bosscher  <stevenb@suse.de>\n \n \t* decl.c (start_decl): Replace DECL_THREAD_LOCAL with"}, {"sha": "9dec64e346d99bc8d6f5aa40b32d0cdd01b0f30c", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=39ce81c9c560d14c746714e6ec1621cad38bae93", "patch": "@@ -236,7 +236,7 @@ CXX_PRETTY_PRINT_H = cp/cxx-pretty-print.h $(C_PRETTY_PRINT_H)\n cp/lex.o: cp/lex.c $(CXX_TREE_H) $(TM_H) flags.h \\\n   c-pragma.h toplev.h output.h input.h cp/operators.def $(TM_P_H)\n cp/cp-lang.o: cp/cp-lang.c $(CXX_TREE_H) $(TM_H) toplev.h debug.h langhooks.h \\\n-  $(LANGHOOKS_DEF_H) c-common.h gtype-cp.h $(CXX_PRETTY_PRINT_H) \\\n+  $(LANGHOOKS_DEF_H) c-common.h gtype-cp.h \\\n   $(DIAGNOSTIC_H) cp/cp-objcp-common.h\n cp/decl.o: cp/decl.c $(CXX_TREE_H) $(TM_H) flags.h cp/decl.h \\\n   output.h $(EXPR_H) except.h toplev.h $(HASHTAB_H) $(RTL_H) \\"}, {"sha": "1806b47d74165da541f3c086e1da1d563bff515f", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=39ce81c9c560d14c746714e6ec1621cad38bae93", "patch": "@@ -30,7 +30,6 @@ Boston, MA 02110-1301, USA.  */\n #include \"langhooks.h\"\n #include \"langhooks-def.h\"\n #include \"diagnostic.h\"\n-#include \"cxx-pretty-print.h\"\n #include \"debug.h\"\n #include \"cp-objcp-common.h\"\n "}, {"sha": "fd222be914ec09f609691374ebb0be057e5572fb", "filename": "gcc/cp/error.c", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=39ce81c9c560d14c746714e6ec1621cad38bae93", "patch": "@@ -86,7 +86,8 @@ static void cp_diagnostic_starter (diagnostic_context *, diagnostic_info *);\n static void cp_diagnostic_finalizer (diagnostic_context *, diagnostic_info *);\n static void cp_print_error_function (diagnostic_context *, diagnostic_info *);\n \n-static bool cp_printer (pretty_printer *, text_info *);\n+static bool cp_printer (pretty_printer *, text_info *, const char *,\n+\t\t\tint, bool, bool, bool);\n static tree locate_error (const char *, va_list);\n static location_t location_of (tree);\n \n@@ -2228,8 +2229,9 @@ print_instantiation_partial_context (diagnostic_context *context,\n \t\t\t\t   TFF_DECL_SPECIFIERS | TFF_RETURN_TYPE));\n       loc = TINST_LOCATION (t);\n     }\n-  pp_verbatim (context->printer, \"%s:%d:   instantiated from here\\n\",\n+  pp_verbatim (context->printer, \"%s:%d:   instantiated from here\",\n \t       xloc.file, xloc.line);\n+  pp_base_newline (context->printer);\n }\n \n /* Called from cp_thing to print the template context for an error.  */\n@@ -2266,24 +2268,23 @@ print_instantiation_context (void)\n    %T   type.\n    %V   cv-qualifier.  */\n static bool\n-cp_printer (pretty_printer *pp, text_info *text)\n+cp_printer (pretty_printer *pp, text_info *text, const char *spec,\n+\t    int precision, bool wide, bool set_locus, bool verbose)\n {\n-  int verbose = 0;\n   const char *result;\n-#define next_tree    va_arg (*text->args_ptr, tree)\n+  tree t = NULL;\n+#define next_tree    (t = va_arg (*text->args_ptr, tree))\n #define next_tcode   va_arg (*text->args_ptr, enum tree_code)\n #define next_lang    va_arg (*text->args_ptr, enum languages)\n #define next_int     va_arg (*text->args_ptr, int)\n \n-  if (*text->format_spec == '+')\n-    ++text->format_spec;\n-  if (*text->format_spec == '#')\n-    {\n-      verbose = 1;\n-      ++text->format_spec;\n-    }\n+  if (precision != 0 || wide)\n+    return false;\n+\n+  if (text->locus == NULL)\n+    set_locus = false;\n \n-  switch (*text->format_spec)\n+  switch (*spec)\n     {\n     case 'A': result = args_to_string (next_tree, verbose);\tbreak;\n     case 'C': result = code_to_string (next_tcode);\t\tbreak;\n@@ -2302,6 +2303,8 @@ cp_printer (pretty_printer *pp, text_info *text)\n     }\n \n   pp_base_string (pp, result);\n+  if (set_locus && t != NULL)\n+    *text->locus = location_of (t);\n   return true;\n #undef next_tree\n #undef next_tcode"}, {"sha": "ef4b07f422690ed83db8280d75ee877ea8b14cda", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=39ce81c9c560d14c746714e6ec1621cad38bae93", "patch": "@@ -97,7 +97,7 @@ diagnostic_initialize (diagnostic_context *context)\n   /* By default, diagnostics are sent to stderr.  */\n   context->printer->buffer->stream = stderr;\n   /* By default, we emit prefixes once per message.  */\n-  context->printer->prefixing_rule = DIAGNOSTICS_SHOW_PREFIX_ONCE;\n+  context->printer->wrapping.rule = DIAGNOSTICS_SHOW_PREFIX_ONCE;\n \n   memset (context->diagnostic_count, 0, sizeof context->diagnostic_count);\n   context->issue_warnings_are_errors_message = true;\n@@ -347,10 +347,10 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n \t  = ACONCAT ((diagnostic->message.format_spec,\n \t\t      \" [\", cl_options[diagnostic->option_index].opt_text, \"]\", NULL));\n \n-      pp_prepare_to_format (context->printer, &diagnostic->message,\n-\t\t\t    &diagnostic->location);\n+      diagnostic->message.locus = &diagnostic->location;\n+      pp_format (context->printer, &diagnostic->message);\n       (*diagnostic_starter (context)) (context, diagnostic);\n-      pp_format_text (context->printer, &diagnostic->message);\n+      pp_output_formatted_text (context->printer);\n       (*diagnostic_finalizer (context)) (context, diagnostic);\n       pp_flush (context->printer);\n       diagnostic_action_after_output (context, diagnostic);\n@@ -405,6 +405,7 @@ verbatim (const char *gmsgid, ...)\n   text.err_no = errno;\n   text.args_ptr = &ap;\n   text.format_spec = _(gmsgid);\n+  text.locus = NULL;\n   pp_format_verbatim (global_dc->printer, &text);\n   pp_flush (global_dc->printer);\n   va_end (ap);"}, {"sha": "ec2df1251fc02399f3e521198491b43cf3f601b0", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=39ce81c9c560d14c746714e6ec1621cad38bae93", "patch": "@@ -120,11 +120,11 @@ struct diagnostic_context\n #define diagnostic_format_decoder(DC) ((DC)->printer->format_decoder)\n \n /* Same as output_prefixing_rule.  Works on 'diagnostic_context *'.  */\n-#define diagnostic_prefixing_rule(DC) ((DC)->printer->prefixing_rule)\n+#define diagnostic_prefixing_rule(DC) ((DC)->printer->wrapping.rule)\n \n /* Maximum characters per line in automatic line wrapping mode.\n    Zero means don't wrap lines.  */\n-#define diagnostic_line_cutoff(DC) ((DC)->printer->ideal_maximum_length)\n+#define diagnostic_line_cutoff(DC) ((DC)->printer->wrapping.line_cutoff)\n \n #define diagnostic_flush_buffer(DC) pp_base_flush ((DC)->printer)\n "}, {"sha": "17786865ebc836a394751807832c32ecd6acad74", "filename": "gcc/objc/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fobjc%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fobjc%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FMake-lang.in?ref=39ce81c9c560d14c746714e6ec1621cad38bae93", "patch": "@@ -69,7 +69,7 @@ cc1obj$(exeext): $(OBJC_OBJS) $(C_AND_OBJC_OBJS) cc1obj-checksum.o $(BACKEND) $(\n \n objc/objc-lang.o : objc/objc-lang.c \\\n    $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-   $(C_TREE_H) $(C_PRETTY_PRINT_H) $(DIAGNOSTIC_H) \\\n+   $(C_TREE_H) $(DIAGNOSTIC_H) \\\n    $(GGC_H) langhooks.h $(LANGHOOKS_DEF_H) $(C_COMMON_H) gtype-objc.h \\\n    c-objc-common.h objc/objc-act.h tree-gimple.h\n "}, {"sha": "93db774065a70e342a92099ae2996da080e29e84", "filename": "gcc/objc/objc-lang.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fobjc%2Fobjc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fobjc%2Fobjc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-lang.c?ref=39ce81c9c560d14c746714e6ec1621cad38bae93", "patch": "@@ -31,7 +31,6 @@ Boston, MA 02110-1301, USA.  */\n #include \"langhooks.h\"\n #include \"langhooks-def.h\"\n #include \"diagnostic.h\"\n-#include \"c-pretty-print.h\"\n #include \"c-objc-common.h\"\n \n enum c_language_kind c_language = clk_objc;"}, {"sha": "4f3969ec1fc70e75403a00f6aa0507a1916f8631", "filename": "gcc/objcp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fobjcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fobjcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FChangeLog?ref=39ce81c9c560d14c746714e6ec1621cad38bae93", "patch": "@@ -1,3 +1,9 @@\n+2005-06-30  Zack Weinberg  <zack@codesourcery.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* objcp-lang.c: No need to include cxx-pretty-print.h.\n+\t* Make-lang.in: Update dependencies.\n+\n 2005-06-25  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* all files: Update FSF in copyright headers."}, {"sha": "1e3a21d0cee394cc51b72a81c82e5de181124489", "filename": "gcc/objcp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fobjcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fobjcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FMake-lang.in?ref=39ce81c9c560d14c746714e6ec1621cad38bae93", "patch": "@@ -69,7 +69,7 @@ cc1objplus$(exeext): $(OBJCXX_OBJS) cc1objplus-checksum.o $(BACKEND) $(LIBDEPS)\n \n objcp/objcp-lang.o : objcp/objcp-lang.c \\\n   $(CXX_TREE_H) $(TM_H) toplev.h debug.h langhooks.h objc/objc-act.h \\\n-  $(LANGHOOKS_DEF_H) c-common.h gtype-objcp.h $(CXX_PRETTY_PRINT_H) \\\n+  $(LANGHOOKS_DEF_H) c-common.h gtype-objcp.h \\\n   $(DIAGNOSTIC_H) cp/cp-objcp-common.h tree-gimple.h\n \n objcp/objcp-decl.o : objcp/objcp-decl.c \\"}, {"sha": "30415ae5d11f7d98ce6f3ace870a0720d68c11fc", "filename": "gcc/objcp/objcp-lang.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fobjcp%2Fobjcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fobjcp%2Fobjcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fobjcp-lang.c?ref=39ce81c9c560d14c746714e6ec1621cad38bae93", "patch": "@@ -31,7 +31,6 @@ Boston, MA 02110-1301, USA.  */\n #include \"langhooks.h\"\n #include \"langhooks-def.h\"\n #include \"diagnostic.h\"\n-#include \"cxx-pretty-print.h\"\n #include \"debug.h\"\n #include \"cp-objcp-common.h\"\n "}, {"sha": "b98f5dd754ab309120e1defd0650b843ade09829", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 352, "deletions": 154, "changes": 506, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=39ce81c9c560d14c746714e6ec1621cad38bae93", "patch": "@@ -33,7 +33,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n /* A pointer to the formatted diagnostic message.  */\n #define pp_formatted_text_data(PP) \\\n-   ((const char *) obstack_base (&pp_base (PP)->buffer->obstack))\n+   ((const char *) obstack_base (pp_base (PP)->buffer->obstack))\n \n /* Format an integer given by va_arg (ARG, type-specifier T) where\n    type-specifier is a precision modifier as indicated by PREC.  F is\n@@ -149,7 +149,7 @@ pp_maybe_wrap_text (pretty_printer *pp, const char *start, const char *end)\n static inline void\n pp_append_r (pretty_printer *pp, const char *start, int length)\n {\n-  obstack_grow (&pp->buffer->obstack, start, length);\n+  obstack_grow (pp->buffer->obstack, start, length);\n   pp->buffer->line_length += length;\n }\n \n@@ -166,42 +166,7 @@ pp_base_indent (pretty_printer *pp)\n     pp_space (pp);\n }\n \n-/* Prepare PP to format a message pointed to by TEXT, with tentative\n-   location LOCUS.  It is expected that a call to pp_format_text with\n-   exactly the same PP and TEXT arguments will follow.  This routine\n-   may modify the data in memory at TEXT and LOCP, and if it does,\n-   caller is expected to notice.\n-\n-   Currently, all this does is notice a %H or %J escape at the beginning\n-   of the string, and update LOCUS to match.  */\n-void\n-pp_base_prepare_to_format (pretty_printer *pp ATTRIBUTE_UNUSED,\n-\t\t\t   text_info *text,\n-\t\t\t   location_t *locus)\n-{\n-  const char *p = text->format_spec;\n-  tree t;\n-\n-  /* Extract the location information if any.  */\n-  if (p[0] == '%')\n-    switch (p[1])\n-      {\n-      case 'H':\n-\t*locus = *va_arg (*text->args_ptr, location_t *);\n-\ttext->format_spec = p + 2;\n-\tbreak;\n-\n-      case 'J':\n-\tt = va_arg (*text->args_ptr, tree);\n-\t*locus = DECL_SOURCE_LOCATION (t);\n-\ttext->format_spec = p + 2;\n-\tbreak;\n-      }\n-}\n-\n-\n-/* Format a message pointed to by TEXT.  The following format specifiers are\n-   recognized as being client independent:\n+/* The following format specifiers are recognized as being client independent:\n    %d, %i: (signed) integer in base ten.\n    %u: unsigned integer in base ten.\n    %o: unsigned integer in base eight.\n@@ -218,147 +183,338 @@ pp_base_prepare_to_format (pretty_printer *pp ATTRIBUTE_UNUSED,\n    %>: closing quote.\n    %': apostrophe (should only be used in untranslated messages;\n        translations should use appropriate punctuation directly).\n-   %.*s: a substring the length of which is specified by an integer.\n+   %.*s: a substring the length of which is specified by an argument\n+\t integer.\n+   %Ns: likewise, but length specified as constant in the format string.\n    %H: location_t.\n-   Flag 'q': quote formatted text (must come immediately after '%').  */\n+   %J: a decl tree, from which DECL_SOURCE_LOCATION will be recorded.\n+   Flag 'q': quote formatted text (must come immediately after '%').\n+\n+   Arguments can be used sequentially, or through %N$ resp. *N$\n+   notation Nth argument after the format string.  If %N$ / *N$\n+   notation is used, it must be used for all arguments, except %m, %%,\n+   %<, %> and %', which may not have a number, as they do not consume\n+   an argument.  When %M$.*N$s is used, M must be N + 1.  (This may\n+   also be written %M$.*s, provided N is not otherwise used.)  The\n+   format string must have conversion specifiers with argument numbers\n+   1 up to highest argument; each argument may only be used once.\n+   A format string can have at most 30 arguments.  */\n+\n+/* Formatting phases 1 and 2: render TEXT->format_spec plus\n+   TEXT->args_ptr into a series of chunks in PP->buffer->args[].\n+   Phase 3 is in pp_base_format_text.  */\n+\n void\n-pp_base_format_text (pretty_printer *pp, text_info *text)\n+pp_base_format (pretty_printer *pp, text_info *text)\n {\n-  for (; *text->format_spec; ++text->format_spec)\n+  output_buffer *buffer = pp->buffer;\n+  const char *p;\n+  const char **args;\n+  struct chunk_info *new_chunk_array;\n+\n+  unsigned int curarg = 0, chunk = 0, argno;\n+  pp_wrapping_mode_t old_wrapping_mode;\n+  bool any_unnumbered = false, any_numbered = false;\n+  const char **formatters[PP_NL_ARGMAX];\n+\n+  /* Allocate a new chunk structure.  */\n+  new_chunk_array = XOBNEW (&buffer->chunk_obstack, struct chunk_info);\n+  new_chunk_array->prev = buffer->cur_chunk_array;\n+  buffer->cur_chunk_array = new_chunk_array;\n+  args = new_chunk_array->args;\n+\n+  /* Formatting phase 1: split up TEXT->format_spec into chunks in\n+     PP->buffer->args[].  Even-numbered chunks are to be output\n+     verbatim, odd-numbered chunks are format specifiers.\n+     %m, %%, %<, %>, and %' are replaced with the appropriate text at\n+     this point.  */\n+\n+  memset (formatters, 0, sizeof formatters);\n+  \n+  for (p = text->format_spec; *p; )\n     {\n-      int precision = 0;\n-      bool wide = false;\n-      bool quoted = false;\n+      while (*p != '\\0' && *p != '%')\n+\t{\n+\t  obstack_1grow (&buffer->chunk_obstack, *p);\n+\t  p++;\n+\t}\n \n-      /* Ignore text.  */\n-      {\n-\tconst char *p = text->format_spec;\n-\twhile (*p && *p != '%')\n-\t  ++p;\n-\tpp_wrap_text (pp, text->format_spec, p);\n-        text->format_spec = p;\n-      }\n+      if (*p == '\\0')\n+\tbreak;\n+\n+      switch (*++p)\n+\t{\n+\tcase '\\0':\n+\t  gcc_unreachable ();\n+\t  \n+\tcase '%':\n+\t  obstack_1grow (&buffer->chunk_obstack, '%');\n+\t  p++;\n+\t  continue;\n \n-      if (*text->format_spec == '\\0')\n+\tcase '<':\n+\t  obstack_grow (&buffer->chunk_obstack,\n+\t\t\topen_quote, strlen (open_quote));\n+\t  p++;\n+\t  continue;\n+\n+\tcase '>':\n+\tcase '\\'':\n+\t  obstack_grow (&buffer->chunk_obstack,\n+\t\t\topen_quote, strlen (close_quote));\n+\t  p++;\n+\t  continue;\n+\n+\tcase 'm':\n+\t  {\n+\t    const char *errstr = xstrerror (text->err_no);\n+\t    obstack_grow (&buffer->chunk_obstack, errstr, strlen (errstr));\n+\t  }\n+\t  p++;\n+\t  continue;\n+\n+\tdefault:\n+\t  /* Handled in phase 2.  Terminate the plain chunk here.  */\n+\t  obstack_1grow (&buffer->chunk_obstack, '\\0');\n+\t  gcc_assert (chunk < PP_NL_ARGMAX * 2);\n+\t  args[chunk++] = XOBFINISH (&buffer->chunk_obstack, const char *);\n+\t  break;\n+\t}\n+\n+      if (ISDIGIT (*p))\n+\t{\n+\t  char *end;\n+\t  argno = strtoul (p, &end, 10) - 1;\n+\t  p = end;\n+\t  gcc_assert (*p == '$');\n+\t  p++;\n+\n+\t  any_numbered = true;\n+\t  gcc_assert (!any_unnumbered);\n+\t}\n+      else\n+\t{\n+\t  argno = curarg++;\n+\t  any_unnumbered = true;\n+\t  gcc_assert (!any_numbered);\n+\t}\n+      gcc_assert (argno < PP_NL_ARGMAX);\n+      gcc_assert (!formatters[argno]);\n+      formatters[argno] = &args[chunk];\n+      do\n+\t{\n+\t  obstack_1grow (&buffer->chunk_obstack, *p);\n+\t  p++;\n+\t}\n+      while (strchr (\"qwl+#\", p[-1]));\n+\n+      if (p[-1] == '.')\n+\t{\n+\t  /* We handle '%.Ns' and '%.*s' or '%M$.*N$s'\n+\t     (where M == N + 1).  */\n+\t  if (ISDIGIT (*p))\n+\t    {\n+\t      do\n+\t\t{\n+\t\t  obstack_1grow (&buffer->chunk_obstack, *p);\n+\t\t  p++;\n+\t\t}\n+\t      while (ISDIGIT (p[-1]));\n+\t      gcc_assert (p[-1] == 's');\n+\t    }\n+\t  else\n+\t    {\n+\t      gcc_assert (*p == '*');\n+\t      obstack_1grow (&buffer->chunk_obstack, '*');\n+\t      p++;\n+\n+\t      if (ISDIGIT (*p))\n+\t\t{\n+\t\t  char *end;\n+\t\t  unsigned int argno2 = strtoul (p, &end, 10) - 1;\n+\t\t  p = end;\n+\t\t  gcc_assert (argno2 == argno - 1);\n+\t\t  gcc_assert (!any_unnumbered);\n+\t\t  gcc_assert (*p == '$');\n+\n+\t\t  p++;\n+\t\t  formatters[argno2] = formatters[argno];\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gcc_assert (!any_numbered);\n+\t\t  formatters[argno+1] = formatters[argno];\n+\t\t  curarg++;\n+\t\t}\n+\t      gcc_assert (*p == 's');\n+\t      obstack_1grow (&buffer->chunk_obstack, 's');\n+\t      p++;\n+\t    }\n+\t}\n+      if (*p == '\\0')\n \tbreak;\n \n-      /* We got a '%'.  Check for 'q', then parse precision modifiers,\n-\t if any.  */\n-      if (*++text->format_spec == 'q')\n+      obstack_1grow (&buffer->chunk_obstack, '\\0');\n+      gcc_assert (chunk < PP_NL_ARGMAX * 2);\n+      args[chunk++] = XOBFINISH (&buffer->chunk_obstack, const char *);\n+    }\n+\n+  obstack_1grow (&buffer->chunk_obstack, '\\0');\n+  gcc_assert (chunk < PP_NL_ARGMAX * 2);\n+  args[chunk++] = XOBFINISH (&buffer->chunk_obstack, const char *);\n+  args[chunk] = 0;\n+\t\t  \n+  /* Set output to the argument obstack, and switch line-wrapping and\n+     prefixing off.  */\n+  buffer->obstack = &buffer->chunk_obstack;\n+  old_wrapping_mode = pp_set_verbatim_wrapping (pp);\n+\n+  /* Second phase.  Replace each formatter with the formatted text it\n+     corresponds to.  */\n+\n+  for (argno = 0; formatters[argno]; argno++)\n+    {\n+      int precision = 0;\n+      bool wide = false;\n+      bool plus = false;\n+      bool hash = false;\n+      bool quote = false;\n+\n+      /* We do not attempt to enforce any ordering on the modifier\n+\t characters.  */\n+\n+      for (p = *formatters[argno];; p++)\n \t{\n-\t  quoted = true;\n-\t  ++text->format_spec;\n+\t  switch (*p)\n+\t    {\n+\t    case 'q':\n+\t      gcc_assert (!quote);\n+\t      quote = true;\n+\t      continue;\n+\n+\t    case '+':\n+\t      gcc_assert (!plus);\n+\t      plus = true;\n+\t      continue;\n+\n+\t    case '#':\n+\t      gcc_assert (!hash);\n+\t      hash = true;\n+\t      continue;\n+\n+\t    case 'w':\n+\t      gcc_assert (!wide);\n+\t      wide = true;\n+\t      continue;\n+\n+\t    case 'l':\n+\t      /* We don't support precision beyond that of \"long long\".  */\n+\t      gcc_assert (precision < 2);\n+\t      precision++;\n+\t      continue;\n+\t    }\n+\t  break;\n \t}\n-      switch (*text->format_spec)\n-        {\n-        case 'w':\n-          wide = true;\n-          ++text->format_spec;\n-          break;\n-\n-        case 'l':\n-          do\n-            ++precision;\n-          while (*++text->format_spec == 'l');\n-          break;\n-\n-        default:\n-          break;\n-        }\n-      /* We don't support precision beyond that of \"long long\".  */\n-      gcc_assert (precision <= 2);\n-\n-      if (quoted)\n+\n+      gcc_assert (!wide || precision == 0);\n+\n+      if (quote)\n \tpp_string (pp, open_quote);\n-      switch (*text->format_spec)\n+\n+      switch (*p)\n \t{\n \tcase 'c':\n \t  pp_character (pp, va_arg (*text->args_ptr, int));\n \t  break;\n \n \tcase 'd':\n \tcase 'i':\n-          if (wide)\n-            pp_wide_integer (pp, va_arg (*text->args_ptr, HOST_WIDE_INT));\n-          else\n-            pp_integer_with_precision\n-              (pp, *text->args_ptr, precision, int, \"d\");\n+\t  if (wide)\n+\t    pp_wide_integer (pp, va_arg (*text->args_ptr, HOST_WIDE_INT));\n+\t  else\n+\t    pp_integer_with_precision\n+\t      (pp, *text->args_ptr, precision, int, \"d\");\n \t  break;\n \n \tcase 'o':\n-          if (wide)\n-            pp_scalar (pp, \"%\" HOST_WIDE_INT_PRINT \"o\",\n-                       va_arg (*text->args_ptr, unsigned HOST_WIDE_INT));\n-          else\n-            pp_integer_with_precision\n-              (pp, *text->args_ptr, precision, unsigned, \"u\");\n+\t  if (wide)\n+\t    pp_scalar (pp, \"%\" HOST_WIDE_INT_PRINT \"o\",\n+\t\t       va_arg (*text->args_ptr, unsigned HOST_WIDE_INT));\n+\t  else\n+\t    pp_integer_with_precision\n+\t      (pp, *text->args_ptr, precision, unsigned, \"o\");\n \t  break;\n \n \tcase 's':\n \t  pp_string (pp, va_arg (*text->args_ptr, const char *));\n \t  break;\n \n-        case 'p':\n-          pp_pointer (pp, va_arg (*text->args_ptr, void *));\n-          break;\n+\tcase 'p':\n+\t  pp_pointer (pp, va_arg (*text->args_ptr, void *));\n+\t  break;\n \n \tcase 'u':\n-          if (wide)\n-            pp_scalar (pp, HOST_WIDE_INT_PRINT_UNSIGNED,\n-                       va_arg (*text->args_ptr, unsigned HOST_WIDE_INT));\n-          else\n-            pp_integer_with_precision\n-              (pp, *text->args_ptr, precision, unsigned, \"u\");\n+\t  if (wide)\n+\t    pp_scalar (pp, HOST_WIDE_INT_PRINT_UNSIGNED,\n+\t\t       va_arg (*text->args_ptr, unsigned HOST_WIDE_INT));\n+\t  else\n+\t    pp_integer_with_precision\n+\t      (pp, *text->args_ptr, precision, unsigned, \"u\");\n \t  break;\n \n \tcase 'x':\n-          if (wide)\n-            pp_scalar (pp, HOST_WIDE_INT_PRINT_HEX,\n-                       va_arg (*text->args_ptr, unsigned HOST_WIDE_INT));\n-          else\n-            pp_integer_with_precision\n-              (pp, *text->args_ptr, precision, unsigned, \"x\");\n-\t  break;\n-\n-\tcase 'm':\n-\t  pp_string (pp, xstrerror (text->err_no));\n+\t  if (wide)\n+\t    pp_scalar (pp, HOST_WIDE_INT_PRINT_HEX,\n+\t\t       va_arg (*text->args_ptr, unsigned HOST_WIDE_INT));\n+\t  else\n+\t    pp_integer_with_precision\n+\t      (pp, *text->args_ptr, precision, unsigned, \"x\");\n \t  break;\n \n-\tcase '%':\n-\t  pp_character (pp, '%');\n-\t  break;\n-\n-\tcase '<':\n-\t  pp_string (pp, open_quote);\n+\tcase 'H':\n+\t  {\n+\t    location_t *locus = va_arg (*text->args_ptr, location_t *);\n+\t    gcc_assert (text->locus != NULL);\n+\t    *text->locus = *locus;\n+\t  }\n \t  break;\n \n-\tcase '>':\n-\tcase '\\'':\n-\t  pp_string (pp, close_quote);\n+\tcase 'J':\n+\t  {\n+\t    tree t = va_arg (*text->args_ptr, tree);\n+\t    gcc_assert (text->locus != NULL);\n+\t    *text->locus = DECL_SOURCE_LOCATION (t);\n+\t  }\n \t  break;\n \n-        case 'H':\n-          {\n-            location_t *locus = va_arg (*text->args_ptr, location_t *);\n-\t    expanded_location s = expand_location (*locus);\n-            pp_string (pp, \"file '\");\n-            pp_string (pp, s.file);\n-            pp_string (pp, \"', line \");\n-            pp_decimal_int (pp, s.line);\n-          }\n-          break;\n-\n \tcase '.':\n \t  {\n \t    int n;\n \t    const char *s;\n-\t    /* We handle no precision specifier but '%.*s'.  */\n-\t    ++text->format_spec;\n-\t    gcc_assert (*text->format_spec == '*');\n-\t    ++text->format_spec;\n-\t    gcc_assert (*text->format_spec == 's');\n \n-\t    n = va_arg (*text->args_ptr, int);\n+\t    /* We handle '%.Ns' and '%.*s' or '%M$.*N$s'\n+\t       (where M == N + 1).  The format string should be verified\n+\t       already from the first phase.  */\n+\t    p++;\n+\t    if (ISDIGIT (*p))\n+\t      {\n+\t\tchar *end;\n+\t\tn = strtoul (p, &end, 10);\n+\t\tp = end;\n+\t\tgcc_assert (*p == 's');\n+\t      }\n+\t    else\n+\t      {\n+\t\tgcc_assert (*p == '*');\n+\t\tp++;\n+\t\tgcc_assert (*p == 's');\n+\t\tn = va_arg (*text->args_ptr, int);\n+\n+\t\t/* This consumes a second entry in the formatters array.  */\n+\t\tgcc_assert (formatters[argno] == formatters[argno+1]);\n+\t\targno++;\n+\t      }\n+\n \t    s = va_arg (*text->args_ptr, const char *);\n \t    pp_append_text (pp, s, s + n);\n \t  }\n@@ -367,33 +523,70 @@ pp_base_format_text (pretty_printer *pp, text_info *text)\n \tdefault:\n \t  {\n \t    bool ok;\n-\t    \n+\n \t    gcc_assert (pp_format_decoder (pp));\n-\t    ok = pp_format_decoder (pp) (pp, text);\n+\t    ok = pp_format_decoder (pp) (pp, text, p,\n+\t\t\t\t\t precision, wide, plus, hash);\n \t    gcc_assert (ok);\n \t  }\n \t}\n-      if (quoted)\n+\n+      if (quote)\n \tpp_string (pp, close_quote);\n+\n+      obstack_1grow (&buffer->chunk_obstack, '\\0');\n+      *formatters[argno] = XOBFINISH (&buffer->chunk_obstack, const char *);\n     }\n+\n+#ifdef ENABLE_CHECKING\n+  for (; argno < PP_NL_ARGMAX; argno++)\n+    gcc_assert (!formatters[argno]);\n+#endif\n+\n+  /* Revert to normal obstack and wrapping mode.  */\n+  buffer->obstack = &buffer->formatted_obstack;\n+  buffer->line_length = 0;\n+  pp_wrapping_mode (pp) = old_wrapping_mode;\n+  pp_clear_state (pp);\n+}\n+\n+/* Format of a message pointed to by TEXT.  */\n+void\n+pp_base_output_formatted_text (pretty_printer *pp)\n+{\n+  unsigned int chunk;\n+  output_buffer *buffer = pp_buffer (pp);\n+  struct chunk_info *chunk_array = buffer->cur_chunk_array;\n+  const char **args = chunk_array->args;\n+\n+  gcc_assert (buffer->obstack == &buffer->formatted_obstack);\n+  gcc_assert (buffer->line_length == 0);\n+\n+  /* This is a third phase, first 2 phases done in pp_base_format_args.\n+     Now we actually print it.  */\n+  for (chunk = 0; args[chunk]; chunk++)\n+    pp_string (pp, args[chunk]);\n+\n+  /* Deallocate the chunk structure and everything after it (i.e. the\n+     associated series of formatted strings).  */\n+  buffer->cur_chunk_array = chunk_array->prev;\n+  obstack_free (&buffer->chunk_obstack, chunk_array);\n }\n \n /* Helper subroutine of output_verbatim and verbatim. Do the appropriate\n    settings needed by BUFFER for a verbatim formatting.  */\n void\n pp_base_format_verbatim (pretty_printer *pp, text_info *text)\n {\n-  diagnostic_prefixing_rule_t rule = pp_prefixing_rule (pp);\n-  int line_cutoff = pp_line_cutoff (pp);\n-\n   /* Set verbatim mode.  */\n-  pp->prefixing_rule = DIAGNOSTICS_SHOW_PREFIX_NEVER;\n-  pp_line_cutoff (pp) = 0;\n+  pp_wrapping_mode_t oldmode = pp_set_verbatim_wrapping (pp);\n+\n   /* Do the actual formatting.  */\n-  pp_format_text (pp, text);\n+  pp_format (pp, text);\n+  pp_output_formatted_text (pp);\n+\n   /* Restore previous settings.  */\n-  pp_prefixing_rule (pp) = rule;\n-  pp_line_cutoff (pp) = line_cutoff;\n+  pp_wrapping_mode (pp) = oldmode;\n }\n \n /* Flush the content of BUFFER onto the attached stream.  */\n@@ -421,7 +614,7 @@ pp_base_set_line_maximum_length (pretty_printer *pp, int length)\n void\n pp_base_clear_output_area (pretty_printer *pp)\n {\n-  obstack_free (&pp->buffer->obstack, obstack_base (&pp->buffer->obstack));\n+  obstack_free (pp->buffer->obstack, obstack_base (pp->buffer->obstack));\n   pp->buffer->line_length = 0;\n }\n \n@@ -485,7 +678,9 @@ pp_construct (pretty_printer *pp, const char *prefix, int maximum_length)\n {\n   memset (pp, 0, sizeof (pretty_printer));\n   pp->buffer = xcalloc (1, sizeof (output_buffer));\n-  obstack_init (&pp->buffer->obstack);\n+  obstack_init (&pp->buffer->chunk_obstack);\n+  obstack_init (&pp->buffer->formatted_obstack);\n+  pp->buffer->obstack = &pp->buffer->formatted_obstack;\n   pp->buffer->stream = stderr;\n   pp_line_cutoff (pp) = maximum_length;\n   pp_prefixing_rule (pp) = DIAGNOSTICS_SHOW_PREFIX_ONCE;\n@@ -516,7 +711,7 @@ pp_base_append_text (pretty_printer *pp, const char *start, const char *end)\n const char *\n pp_base_formatted_text (pretty_printer *pp)\n {\n-  obstack_1grow (&pp->buffer->obstack, '\\0');\n+  obstack_1grow (pp->buffer->obstack, '\\0');\n   return pp_formatted_text_data (pp);\n }\n \n@@ -526,7 +721,7 @@ const char *\n pp_base_last_position_in_text (const pretty_printer *pp)\n {\n   const char *p = NULL;\n-  struct obstack *text = &pp->buffer->obstack;\n+  struct obstack *text = pp->buffer->obstack;\n \n   if (obstack_base (text) != obstack_next_free (text))\n     p = ((const char *) obstack_next_free (text)) - 1;\n@@ -553,7 +748,9 @@ pp_printf (pretty_printer *pp, const char *msg, ...)\n   text.err_no = errno;\n   text.args_ptr = &ap;\n   text.format_spec = msg;\n-  pp_format_text (pp, &text);\n+  text.locus = NULL;\n+  pp_format (pp, &text);\n+  pp_output_formatted_text (pp);\n   va_end (ap);\n }\n \n@@ -569,6 +766,7 @@ pp_verbatim (pretty_printer *pp, const char *msg, ...)\n   text.err_no = errno;\n   text.args_ptr = &ap;\n   text.format_spec = msg;\n+  text.locus = NULL;\n   pp_format_verbatim (pp, &text);\n   va_end (ap);\n }\n@@ -579,7 +777,7 @@ pp_verbatim (pretty_printer *pp, const char *msg, ...)\n void\n pp_base_newline (pretty_printer *pp)\n {\n-  obstack_1grow (&pp->buffer->obstack, '\\n');\n+  obstack_1grow (pp->buffer->obstack, '\\n');\n   pp->buffer->line_length = 0;\n }\n \n@@ -594,7 +792,7 @@ pp_base_character (pretty_printer *pp, int c)\n       if (ISSPACE (c))\n         return;\n     }\n-  obstack_1grow (&pp->buffer->obstack, c);\n+  obstack_1grow (pp->buffer->obstack, c);\n   ++pp->buffer->line_length;\n }\n "}, {"sha": "b587e600882b610be11d2020bc2c5cd615b89f46", "filename": "gcc/pretty-print.h", "status": "modified", "additions": 78, "deletions": 22, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fpretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Fpretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.h?ref=39ce81c9c560d14c746714e6ec1621cad38bae93", "patch": "@@ -25,13 +25,17 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"obstack.h\"\n #include \"input.h\"\n \n+/* Maximum number of format string arguments.  */\n+#define PP_NL_ARGMAX   30\n+\n /* The type of a text to be formatted according a format specification\n    along with a list of things.  */\n typedef struct\n {\n   const char *format_spec;\n   va_list *args_ptr;\n   int err_no;  /* for %m */\n+  location_t *locus;\n } text_info;\n \n /* How often diagnostics are prefixed by their locations:\n@@ -46,12 +50,42 @@ typedef enum\n   DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE = 0x2\n } diagnostic_prefixing_rule_t;\n \n+/* The chunk_info data structure forms a stack of the results from the\n+   first phase of formatting (pp_base_format) which have not yet been\n+   output (pp_base_output_formatted_text).  A stack is necessary because\n+   the diagnostic starter may decide to generate its own output by way\n+   of the formatter.  */\n+struct chunk_info\n+{\n+  /* Pointer to previous chunk on the stack.  */\n+  struct chunk_info *prev;\n+\n+  /* Array of chunks to output.  Each chunk is a NUL-terminated string.\n+     In the first phase of formatting, even-numbered chunks are\n+     to be output verbatim, odd-numbered chunks are format specifiers.\n+     The second phase replaces all odd-numbered chunks with formatted\n+     text, and the third phase simply emits all the chunks in sequence\n+     with appropriate line-wrapping.  */\n+  const char *args[PP_NL_ARGMAX * 2];\n+};\n+\n /* The output buffer datatype.  This is best seen as an abstract datatype\n    whose fields should not be accessed directly by clients.  */\n typedef struct \n {\n-  /* The obstack where the text is built up.  */  \n-  struct obstack obstack;\n+  /* Obstack where the text is built up.  */  \n+  struct obstack formatted_obstack;\n+\n+  /* Obstack containing a chunked representation of the format\n+     specification plus arguments.  */\n+  struct obstack chunk_obstack;\n+\n+  /* Currently active obstack: one of the above two.  This is used so\n+     that the text formatters don't need to know which phase we're in.  */\n+  struct obstack *obstack;\n+\n+  /* Stack of chunk arrays.  These come from the chunk_obstack.  */\n+  struct chunk_info *cur_chunk_array;\n \n   /* Where to output formatted text.  */\n   FILE *stream;\n@@ -72,11 +106,34 @@ typedef enum\n   pp_none, pp_before, pp_after\n } pp_padding;\n \n+/* Structure for switching in and out of verbatim mode in a convenient\n+   manner.  */\n+typedef struct\n+{\n+  /* Current prefixing rule.  */\n+  diagnostic_prefixing_rule_t rule;\n+\n+  /* The ideal upper bound of number of characters per line, as suggested\n+     by front-end.  */  \n+  int line_cutoff;\n+} pp_wrapping_mode_t;\n+\n+/* Maximum characters per line in automatic line wrapping mode.\n+   Zero means don't wrap lines.  */\n+#define pp_line_cutoff(PP)  pp_base (PP)->wrapping.line_cutoff\n+\n+/* Prefixing rule used in formatting a diagnostic message.  */\n+#define pp_prefixing_rule(PP)  pp_base (PP)->wrapping.rule\n+\n+/* Get or set the wrapping mode as a single entity.  */\n+#define pp_wrapping_mode(PP) pp_base (PP)->wrapping\n+\n /* The type of a hook that formats client-specific data onto a pretty_pinter.\n    A client-supplied formatter returns true if everything goes well,\n    otherwise it returns false.  */\n typedef struct pretty_print_info pretty_printer;\n-typedef bool (*printer_fn) (pretty_printer *, text_info *);\n+typedef bool (*printer_fn) (pretty_printer *, text_info *, const char *,\n+\t\t\t    int, bool, bool, bool);\n \n /* Client supplied function used to decode formats.  */\n #define pp_format_decoder(PP) pp_base (PP)->format_decoder\n@@ -85,16 +142,9 @@ typedef bool (*printer_fn) (pretty_printer *, text_info *);\n    formatting.  */\n #define pp_needs_newline(PP)  pp_base (PP)->need_newline \n \n-/* Maximum characters per line in automatic line wrapping mode.\n-   Zero means don't wrap lines.  */\n-#define pp_line_cutoff(PP)  pp_base (PP)->ideal_maximum_length\n-\n /* True if PRETTY-PTINTER is in line-wrapping mode.  */\n #define pp_is_wrapping_line(PP) (pp_line_cutoff (PP) > 0)\n \n-/* Prefixing rule used in formatting a diagnostic message.  */\n-#define pp_prefixing_rule(PP)  pp_base (PP)->prefixing_rule\n-\n /* The amount of whitespace to be emitted when starting a new line.  */\n #define pp_indentation(PP) pp_base (PP)->indent_skip\n \n@@ -116,15 +166,11 @@ struct pretty_print_info\n      account the case of a very very looong prefix.  */  \n   int maximum_length;\n \n-  /* The ideal upper bound of number of characters per line, as suggested\n-     by front-end.  */  \n-  int ideal_maximum_length;\n-\n   /* Indentation count.  */\n   int indent_skip;\n \n-  /* Current prefixing rule.  */\n-  diagnostic_prefixing_rule_t prefixing_rule;\n+  /* Current wrapping mode.  */\n+  pp_wrapping_mode_t wrapping;\n \n   /* If non-NULL, this function formats a TEXT into the BUFFER.  When called,\n      TEXT->format_spec points to a format code.  FORMAT_DECODER should call\n@@ -158,9 +204,9 @@ struct pretty_print_info\n #define pp_append_text(PP, B, E) \\\n   pp_base_append_text (pp_base (PP), B, E)\n #define pp_flush(PP)            pp_base_flush (pp_base (PP))\n-#define pp_prepare_to_format(PP, TI, LOC) \\\n-  pp_base_prepare_to_format (pp_base (PP), TI, LOC)\n-#define pp_format_text(PP, TI)  pp_base_format_text (pp_base (PP), TI)\n+#define pp_format(PP, TI)       pp_base_format (pp_base (PP), TI)\n+#define pp_output_formatted_text(PP) \\\n+  pp_base_output_formatted_text (pp_base (PP))\n #define pp_format_verbatim(PP, TI) \\\n   pp_base_format_verbatim (pp_base (PP), TI)\n \n@@ -264,9 +310,8 @@ extern void pp_printf (pretty_printer *, const char *, ...)\n extern void pp_verbatim (pretty_printer *, const char *, ...)\n      ATTRIBUTE_GCC_PPDIAG(2,3);\n extern void pp_base_flush (pretty_printer *);\n-extern void pp_base_prepare_to_format (pretty_printer *, text_info *,\n-\t\t\t\t       location_t *);\n-extern void pp_base_format_text (pretty_printer *, text_info *);\n+extern void pp_base_format (pretty_printer *, text_info *);\n+extern void pp_base_output_formatted_text (pretty_printer *);\n extern void pp_base_format_verbatim (pretty_printer *, text_info *);\n \n extern void pp_base_indent (pretty_printer *);\n@@ -276,4 +321,15 @@ extern void pp_base_string (pretty_printer *, const char *);\n extern void pp_write_text_to_stream (pretty_printer *pp);\n extern void pp_base_maybe_space (pretty_printer *);\n \n+/* Switch into verbatim mode and return the old mode.  */\n+static inline pp_wrapping_mode_t\n+pp_set_verbatim_wrapping_ (pretty_printer *pp)\n+{\n+  pp_wrapping_mode_t oldmode = pp_wrapping_mode (pp);\n+  pp_line_cutoff (pp) = 0;\n+  pp_prefixing_rule (pp) = DIAGNOSTICS_SHOW_PREFIX_NEVER;\n+  return oldmode;\n+}\n+#define pp_set_verbatim_wrapping(PP) pp_set_verbatim_wrapping_ (pp_base (PP))\n+\n #endif /* GCC_PRETTY_PRINT_H */"}, {"sha": "0cfbcd2587477560dc7692e9cb10fa96755dd389", "filename": "gcc/toplev.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce81c9c560d14c746714e6ec1621cad38bae93/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=39ce81c9c560d14c746714e6ec1621cad38bae93", "patch": "@@ -442,9 +442,9 @@ announce_function (tree decl)\n   if (!quiet_flag)\n     {\n       if (rtl_dump_and_exit)\n-\tverbatim (\"%s \", IDENTIFIER_POINTER (DECL_NAME (decl)));\n+\tfprintf (stderr, \"%s \", IDENTIFIER_POINTER (DECL_NAME (decl)));\n       else\n-\tverbatim (\" %s\", lang_hooks.decl_printable_name (decl, 2));\n+\tfprintf (stderr, \" %s\", lang_hooks.decl_printable_name (decl, 2));\n       fflush (stderr);\n       pp_needs_newline (global_dc->printer) = true;\n       diagnostic_set_last_function (global_dc);\n@@ -1355,11 +1355,16 @@ default_pch_valid_p (const void *data_p, size_t len)\n \n /* Default tree printer.   Handles declarations only.  */\n static bool\n-default_tree_printer (pretty_printer * pp, text_info *text)\n+default_tree_printer (pretty_printer * pp, text_info *text, const char *spec,\n+\t\t      int precision, bool wide, bool plus, bool hash)\n {\n   tree t;\n \n-  switch (*text->format_spec)\n+  /* FUTURE: %+x should set the locus.  */\n+  if (precision != 0 || wide || plus || hash)\n+    return false;\n+\n+  switch (*spec)\n     {\n     case 'D':\n       t = va_arg (*text->args_ptr, tree);"}]}