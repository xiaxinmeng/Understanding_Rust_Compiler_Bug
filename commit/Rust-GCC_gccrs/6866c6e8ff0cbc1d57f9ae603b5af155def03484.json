{"sha": "6866c6e8ff0cbc1d57f9ae603b5af155def03484", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg2NmM2ZThmZjBjYmMxZDU3ZjlhZTYwM2I1YWYxNTVkZWYwMzQ4NA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2009-04-15T15:51:26Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2009-04-15T15:51:26Z"}, "message": "c.opt (Wenum-compare): Enable for C and Objc.\n\ngcc/:\n\t* c.opt (Wenum-compare): Enable for C and Objc.  Initialize to -1.\n\t* c-opts.c (c_common_handle_option): For C, set warn_enum_compare\n\tfor -Wall and for -Wc++-compat.\n\t(c_common_post_options): For C++, set warn_enum_compare if not\n\talready set.\n\t* c-tree.h (struct c_expr): Add field original_type.\n\t(build_external_ref): Update declaration.\n\t* c-parser.c (c_parser_braced_init): Set original_type.\n\t(c_parser_initelt): Likewise.\n\t(c_parser_expr_no_commas): Likewise.\n\t(c_parser_conditional_expression): Likewise.\n\t(c_parser_cast_expression): Likewise.\n\t(c_parser_unary_expression): Likewise.  Pull setting of\n\toriginal_code to top of function.\n\t(c_parser_sizeof_expression): Set original_type.\n\t(c_parser_alignof_expression): Likewise.\n\t(c_parser_postfix_expression): Likewise.  Pull setting of\n\toriginal_code to top of function.\n\t(c_parser_postfix_expression_after_paren_type): Set\n\toriginal_type.\n\t(c_parser_postfix_expression_after_primary): Likewise.\n\t(c_parser_expression): Likewise.\n\t* c-typeck.c (build_external_ref): Add type parameter.  Change all\n\tcallers.\n\t(c_expr_sizeof_expr): Set original_type field.\n\t(parser_build_unary_op): Likewise.\n\t(parser_build_binary_op): Likewise.  Optionally warn about\n\tcomparisons of enums of different types.\n\t(digest_init): Set original_type field.\n\t(really_start_incremental_init): Likewise.\n\t(push_init_level, pop_init_level): Likewise.\n\t* doc/invoke.texi (Warning Options): -Wenum-compare now\n\tsupported in C.\ngcc/testsuite/:\n\t* gcc.dg/Wenum-compare-1.c: New testcase.\n\nFrom-SVN: r146127", "tree": {"sha": "1f0d9f50c4eb35dde54f0cbacee826d856fe8113", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f0d9f50c4eb35dde54f0cbacee826d856fe8113"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6866c6e8ff0cbc1d57f9ae603b5af155def03484", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6866c6e8ff0cbc1d57f9ae603b5af155def03484", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6866c6e8ff0cbc1d57f9ae603b5af155def03484", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6866c6e8ff0cbc1d57f9ae603b5af155def03484/comments", "author": null, "committer": null, "parents": [{"sha": "f116fecf890dbc4aaacd256eb26459d7ece30e99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f116fecf890dbc4aaacd256eb26459d7ece30e99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f116fecf890dbc4aaacd256eb26459d7ece30e99"}], "stats": {"total": 256, "additions": 208, "deletions": 48}, "files": [{"sha": "eb0ccb13689b299d85c063b05c1640cf9f13370a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6866c6e8ff0cbc1d57f9ae603b5af155def03484/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6866c6e8ff0cbc1d57f9ae603b5af155def03484/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6866c6e8ff0cbc1d57f9ae603b5af155def03484", "patch": "@@ -1,3 +1,39 @@\n+2009-04-15  Ian Lance Taylor  <iant@google.com>\n+\n+\t* c.opt (Wenum-compare): Enable for C and Objc.  Initialize to -1.\n+\t* c-opts.c (c_common_handle_option): For C, set warn_enum_compare\n+\tfor -Wall and for -Wc++-compat.\n+\t(c_common_post_options): For C++, set warn_enum_compare if not\n+\talready set.\n+\t* c-tree.h (struct c_expr): Add field original_type.\n+\t(build_external_ref): Update declaration.\n+\t* c-parser.c (c_parser_braced_init): Set original_type.\n+\t(c_parser_initelt): Likewise.\n+\t(c_parser_expr_no_commas): Likewise.\n+\t(c_parser_conditional_expression): Likewise.\n+\t(c_parser_cast_expression): Likewise.\n+\t(c_parser_unary_expression): Likewise.  Pull setting of\n+\toriginal_code to top of function.\n+\t(c_parser_sizeof_expression): Set original_type.\n+\t(c_parser_alignof_expression): Likewise.\n+\t(c_parser_postfix_expression): Likewise.  Pull setting of\n+\toriginal_code to top of function.\n+\t(c_parser_postfix_expression_after_paren_type): Set\n+\toriginal_type.\n+\t(c_parser_postfix_expression_after_primary): Likewise.\n+\t(c_parser_expression): Likewise.\n+\t* c-typeck.c (build_external_ref): Add type parameter.  Change all\n+\tcallers.\n+\t(c_expr_sizeof_expr): Set original_type field.\n+\t(parser_build_unary_op): Likewise.\n+\t(parser_build_binary_op): Likewise.  Optionally warn about\n+\tcomparisons of enums of different types.\n+\t(digest_init): Set original_type field.\n+\t(really_start_incremental_init): Likewise.\n+\t(push_init_level, pop_init_level): Likewise.\n+\t* doc/invoke.texi (Warning Options): -Wenum-compare now\n+\tsupported in C.\n+\n 2009-04-15  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-pre.c (eliminate): When replacing a PHI node carry"}, {"sha": "f61952289c8eea73a39596185dffdf8468cf9e78", "filename": "gcc/c-opts.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6866c6e8ff0cbc1d57f9ae603b5af155def03484/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6866c6e8ff0cbc1d57f9ae603b5af155def03484/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=6866c6e8ff0cbc1d57f9ae603b5af155def03484", "patch": "@@ -412,6 +412,12 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n \t     can turn it off only if it's not explicit.  */\n \t  if (warn_main == -1)\n \t    warn_main = (value ? 2 : 0);\n+\n+\t  /* In C, -Wall turns on -Wenum-compare, which we do here.\n+\t     In C++ it is on by default, which is done in\n+\t     c_common_post_options.  */\n+          if (warn_enum_compare == -1)\n+            warn_enum_compare = value;\n \t}\n       else\n \t{\n@@ -438,6 +444,13 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n       cpp_opts->warn_comments = value;\n       break;\n \n+    case OPT_Wc___compat:\n+      /* Because -Wenum-compare is the default in C++, -Wc++-compat\n+\t implies -Wenum-compare.  */\n+      if (warn_enum_compare == -1 && value)\n+\twarn_enum_compare = value;\n+      break;\n+\n     case OPT_Wdeprecated:\n       cpp_opts->warn_deprecated = value;\n       break;\n@@ -1099,6 +1112,12 @@ c_common_post_options (const char **pfilename)\n   if (warn_sign_conversion == -1)\n     warn_sign_conversion =  (c_dialect_cxx ()) ? 0 : warn_conversion;\n \n+  /* In C, -Wall and -Wc++-compat enable -Wenum-compare, which we do\n+     in c_common_handle_option; if it has not yet been set, it is\n+     disabled by default.  In C++, it is enabled by default.  */\n+  if (warn_enum_compare == -1)\n+    warn_enum_compare = c_dialect_cxx () ? 1 : 0;\n+\n   /* -Wpacked-bitfield-compat is on by default for the C languages.  The\n      warning is issued in stor-layout.c which is not part of the front-end so\n      we need to selectively turn it on here.  */"}, {"sha": "9b3ace515a9b7dd5df97a0d5493f42aa2982a62f", "filename": "gcc/c-parser.c", "status": "modified", "additions": 68, "deletions": 39, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6866c6e8ff0cbc1d57f9ae603b5af155def03484/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6866c6e8ff0cbc1d57f9ae603b5af155def03484/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=6866c6e8ff0cbc1d57f9ae603b5af155def03484", "patch": "@@ -3044,6 +3044,7 @@ c_parser_braced_init (c_parser *parser, tree type, bool nested_p)\n       struct c_expr ret;\n       ret.value = error_mark_node;\n       ret.original_code = ERROR_MARK;\n+      ret.original_type = NULL;\n       c_parser_skip_until_found (parser, CPP_CLOSE_BRACE, \"expected %<}%>\");\n       pop_init_level (0);\n       return ret;\n@@ -3100,6 +3101,7 @@ c_parser_initelt (c_parser *parser)\n \t\t  struct c_expr init;\n \t\t  init.value = error_mark_node;\n \t\t  init.original_code = ERROR_MARK;\n+\t\t  init.original_type = NULL;\n \t\t  c_parser_error (parser, \"expected identifier\");\n \t\t  c_parser_skip_until_found (parser, CPP_COMMA, NULL);\n \t\t  process_init_element (init, false);\n@@ -3174,6 +3176,7 @@ c_parser_initelt (c_parser *parser)\n \t\t  mexpr.value\n \t\t    = objc_build_message_expr (build_tree_list (rec, args));\n \t\t  mexpr.original_code = ERROR_MARK;\n+\t\t  mexpr.original_type = NULL;\n \t\t  /* Now parse and process the remainder of the\n \t\t     initializer, starting with this message\n \t\t     expression as a primary-expression.  */\n@@ -3223,6 +3226,7 @@ c_parser_initelt (c_parser *parser)\n \t\t  struct c_expr init;\n \t\t  init.value = error_mark_node;\n \t\t  init.original_code = ERROR_MARK;\n+\t\t  init.original_type = NULL;\n \t\t  c_parser_error (parser, \"expected %<=%>\");\n \t\t  c_parser_skip_until_found (parser, CPP_COMMA, NULL);\n \t\t  process_init_element (init, false);\n@@ -4438,6 +4442,7 @@ c_parser_expr_no_commas (c_parser *parser, struct c_expr *after)\n       TREE_NO_WARNING (ret.value) = 1;\n       ret.original_code = ERROR_MARK;\n     }\n+  ret.original_type = NULL;\n   return ret;\n }\n \n@@ -4485,6 +4490,7 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n       exp1.value = c_save_expr (default_conversion (cond.value));\n       if (eptype)\n \texp1.value = build1 (EXCESS_PRECISION_EXPR, eptype, exp1.value);\n+      exp1.original_type = NULL;\n       cond.value = c_objc_common_truthvalue_conversion (cond_loc, exp1.value);\n       skip_evaluation += cond.value == truthvalue_true_node;\n     }\n@@ -4503,6 +4509,7 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n       skip_evaluation -= cond.value == truthvalue_true_node;\n       ret.value = error_mark_node;\n       ret.original_code = ERROR_MARK;\n+      ret.original_type = NULL;\n       return ret;\n     }\n   exp2 = c_parser_conditional_expression (parser, NULL);\n@@ -4512,6 +4519,24 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n \t\t\t\t      cond.original_code == C_MAYBE_CONST_EXPR,\n \t\t\t\t      exp1.value, exp2.value);\n   ret.original_code = ERROR_MARK;\n+  if (exp1.value == error_mark_node || exp2.value == error_mark_node)\n+    ret.original_type = NULL;\n+  else\n+    {\n+      tree t1, t2;\n+\n+      /* If both sides are enum type, the default conversion will have\n+\t made the type of the result be an integer type.  We want to\n+\t remember the enum types we started with.  */\n+      t1 = exp1.original_type ? exp1.original_type : TREE_TYPE (exp1.value);\n+      t2 = exp2.original_type ? exp2.original_type : TREE_TYPE (exp2.value);\n+      ret.original_type = ((t1 != error_mark_node\n+\t\t\t    && t2 != error_mark_node\n+\t\t\t    && (TYPE_MAIN_VARIANT (t1)\n+\t\t\t\t== TYPE_MAIN_VARIANT (t2)))\n+\t\t\t   ? t1\n+\t\t\t   : NULL);\n+    }\n   return ret;\n }\n \n@@ -4800,6 +4825,7 @@ c_parser_cast_expression (c_parser *parser, struct c_expr *after)\n \t{\n \t  ret.value = error_mark_node;\n \t  ret.original_code = ERROR_MARK;\n+\t  ret.original_type = NULL;\n \t  return ret;\n \t}\n \n@@ -4813,6 +4839,7 @@ c_parser_cast_expression (c_parser *parser, struct c_expr *after)\n       expr = default_function_array_conversion (expr);\n       ret.value = c_cast_expr (type_name, expr.value);\n       ret.original_code = ERROR_MARK;\n+      ret.original_type = NULL;\n       return ret;\n     }\n   else\n@@ -4852,6 +4879,8 @@ c_parser_unary_expression (c_parser *parser)\n   int ext;\n   struct c_expr ret, op;\n   location_t loc = c_parser_peek_token (parser)->location;\n+  ret.original_code = ERROR_MARK;\n+  ret.original_type = NULL;\n   switch (c_parser_peek_token (parser)->type)\n     {\n     case CPP_PLUS_PLUS:\n@@ -4874,7 +4903,6 @@ c_parser_unary_expression (c_parser *parser)\n       op = c_parser_cast_expression (parser, NULL);\n       op = default_function_array_conversion (op);\n       ret.value = build_indirect_ref (loc, op.value, \"unary *\");\n-      ret.original_code = ERROR_MARK;\n       return ret;\n     case CPP_PLUS:\n       if (!c_dialect_objc () && !in_system_header)\n@@ -4914,7 +4942,6 @@ c_parser_unary_expression (c_parser *parser)\n \t  c_parser_error (parser, \"expected identifier\");\n \t  ret.value = error_mark_node;\n \t}\n-\tret.original_code = ERROR_MARK;\n \treturn ret;\n     case CPP_KEYWORD:\n       switch (c_parser_peek_token (parser)->keyword)\n@@ -4975,6 +5002,7 @@ c_parser_sizeof_expression (c_parser *parser)\n \t  in_sizeof--;\n \t  ret.value = error_mark_node;\n \t  ret.original_code = ERROR_MARK;\n+\t  ret.original_type = NULL;\n \t  return ret;\n \t}\n       if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n@@ -5029,6 +5057,7 @@ c_parser_alignof_expression (c_parser *parser)\n \t  in_alignof--;\n \t  ret.value = error_mark_node;\n \t  ret.original_code = ERROR_MARK;\n+\t  ret.original_type = NULL;\n \t  return ret;\n \t}\n       if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n@@ -5042,6 +5071,7 @@ c_parser_alignof_expression (c_parser *parser)\n       in_alignof--;\n       ret.value = c_alignof (groktypename (type_name, NULL, NULL));\n       ret.original_code = ERROR_MARK;\n+      ret.original_type = NULL;\n       return ret;\n     }\n   else\n@@ -5053,6 +5083,7 @@ c_parser_alignof_expression (c_parser *parser)\n       in_alignof--;\n       ret.value = c_alignof_expr (expr.value);\n       ret.original_code = ERROR_MARK;\n+      ret.original_type = NULL;\n       return ret;\n     }\n }\n@@ -5116,11 +5147,12 @@ c_parser_postfix_expression (c_parser *parser)\n   struct c_expr expr, e1, e2, e3;\n   struct c_type_name *t1, *t2;\n   location_t loc;\n+  expr.original_code = ERROR_MARK;\n+  expr.original_type = NULL;\n   switch (c_parser_peek_token (parser)->type)\n     {\n     case CPP_NUMBER:\n       expr.value = c_parser_peek_token (parser)->value;\n-      expr.original_code = ERROR_MARK;\n       loc = c_parser_peek_token (parser)->location;\n       c_parser_consume_token (parser);\n       if (TREE_CODE (expr.value) == FIXED_CST\n@@ -5135,7 +5167,6 @@ c_parser_postfix_expression (c_parser *parser)\n     case CPP_CHAR32:\n     case CPP_WCHAR:\n       expr.value = c_parser_peek_token (parser)->value;\n-      expr.original_code = ERROR_MARK;\n       c_parser_consume_token (parser);\n       break;\n     case CPP_STRING:\n@@ -5150,15 +5181,13 @@ c_parser_postfix_expression (c_parser *parser)\n       gcc_assert (c_dialect_objc ());\n       expr.value\n \t= objc_build_string_object (c_parser_peek_token (parser)->value);\n-      expr.original_code = ERROR_MARK;\n       c_parser_consume_token (parser);\n       break;\n     case CPP_NAME:\n       if (c_parser_peek_token (parser)->id_kind != C_ID_ID)\n \t{\n \t  c_parser_error (parser, \"expected expression\");\n \t  expr.value = error_mark_node;\n-\t  expr.original_code = ERROR_MARK;\n \t  break;\n \t}\n       {\n@@ -5167,8 +5196,8 @@ c_parser_postfix_expression (c_parser *parser)\n \tc_parser_consume_token (parser);\n \texpr.value = build_external_ref (id,\n \t\t\t\t\t (c_parser_peek_token (parser)->type\n-\t\t\t\t\t  == CPP_OPEN_PAREN), loc);\n-\texpr.original_code = ERROR_MARK;\n+\t\t\t\t\t  == CPP_OPEN_PAREN), loc,\n+\t\t\t\t\t &expr.original_type);\n       }\n       break;\n     case CPP_OPEN_PAREN:\n@@ -5189,7 +5218,6 @@ c_parser_postfix_expression (c_parser *parser)\n \t      c_parser_skip_until_found (parser, CPP_CLOSE_BRACE, NULL);\n \t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n \t      expr.value = error_mark_node;\n-\t      expr.original_code = ERROR_MARK;\n \t      break;\n \t    }\n \t  stmt = c_begin_stmt_expr ();\n@@ -5199,7 +5227,6 @@ c_parser_postfix_expression (c_parser *parser)\n \t  pedwarn (here, OPT_pedantic, \n \t\t   \"ISO C forbids braced-groups within expressions\");\n \t  expr.value = c_finish_stmt_expr (stmt);\n-\t  expr.original_code = ERROR_MARK;\n \t}\n       else if (c_token_starts_typename (c_parser_peek_2nd_token (parser)))\n \t{\n@@ -5215,7 +5242,6 @@ c_parser_postfix_expression (c_parser *parser)\n \t  if (type_name == NULL)\n \t    {\n \t      expr.value = error_mark_node;\n-\t      expr.original_code = ERROR_MARK;\n \t    }\n \t  else\n \t    expr = c_parser_postfix_expression_after_paren_type (parser,\n@@ -5230,6 +5256,7 @@ c_parser_postfix_expression (c_parser *parser)\n \t    TREE_NO_WARNING (expr.value) = 1;\n \t  if (expr.original_code != C_MAYBE_CONST_EXPR)\n \t    expr.original_code = ERROR_MARK;\n+\t  /* Don't change EXPR.ORIGINAL_TYPE.  */\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n \t}\n@@ -5243,15 +5270,13 @@ c_parser_postfix_expression (c_parser *parser)\n \t  expr.value = fname_decl (c_parser_peek_token (parser)->location,\n \t\t\t\t   c_parser_peek_token (parser)->keyword,\n \t\t\t\t   c_parser_peek_token (parser)->value);\n-\t  expr.original_code = ERROR_MARK;\n \t  c_parser_consume_token (parser);\n \t  break;\n \tcase RID_VA_ARG:\n \t  c_parser_consume_token (parser);\n \t  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n \t    {\n \t      expr.value = error_mark_node;\n-\t      expr.original_code = ERROR_MARK;\n \t      break;\n \t    }\n \t  e1 = c_parser_expr_no_commas (parser, NULL);\n@@ -5260,7 +5285,6 @@ c_parser_postfix_expression (c_parser *parser)\n \t    {\n \t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n \t      expr.value = error_mark_node;\n-\t      expr.original_code = ERROR_MARK;\n \t      break;\n \t    }\n \t  t1 = c_parser_type_name (parser);\n@@ -5269,7 +5293,6 @@ c_parser_postfix_expression (c_parser *parser)\n \t  if (t1 == NULL)\n \t    {\n \t      expr.value = error_mark_node;\n-\t      expr.original_code = ERROR_MARK;\n \t    }\n \t  else\n \t    {\n@@ -5284,29 +5307,25 @@ c_parser_postfix_expression (c_parser *parser)\n \t\t\t\t       expr.value);\n \t\t  C_MAYBE_CONST_EXPR_NON_CONST (expr.value) = true;\n \t\t}\n-\t      expr.original_code = ERROR_MARK;\n \t    }\n \t  break;\n \tcase RID_OFFSETOF:\n \t  c_parser_consume_token (parser);\n \t  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n \t    {\n \t      expr.value = error_mark_node;\n-\t      expr.original_code = ERROR_MARK;\n \t      break;\n \t    }\n \t  t1 = c_parser_type_name (parser);\n \t  if (t1 == NULL)\n \t    {\n \t      expr.value = error_mark_node;\n-\t      expr.original_code = ERROR_MARK;\n \t      break;\n \t    }\n \t  if (!c_parser_require (parser, CPP_COMMA, \"expected %<,%>\"))\n \t    {\n \t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n \t      expr.value = error_mark_node;\n-\t      expr.original_code = ERROR_MARK;\n \t      break;\n \t    }\n \t  {\n@@ -5371,15 +5390,13 @@ c_parser_postfix_expression (c_parser *parser)\n \t    c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t       \"expected %<)%>\");\n \t    expr.value = fold_offsetof (offsetof_ref, NULL_TREE);\n-\t    expr.original_code = ERROR_MARK;\n \t  }\n \t  break;\n \tcase RID_CHOOSE_EXPR:\n \t  c_parser_consume_token (parser);\n \t  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n \t    {\n \t      expr.value = error_mark_node;\n-\t      expr.original_code = ERROR_MARK;\n \t      break;\n \t    }\n \t  loc = c_parser_peek_token (parser)->location;\n@@ -5388,15 +5405,13 @@ c_parser_postfix_expression (c_parser *parser)\n \t    {\n \t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n \t      expr.value = error_mark_node;\n-\t      expr.original_code = ERROR_MARK;\n \t      break;\n \t    }\n \t  e2 = c_parser_expr_no_commas (parser, NULL);\n \t  if (!c_parser_require (parser, CPP_COMMA, \"expected %<,%>\"))\n \t    {\n \t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n \t      expr.value = error_mark_node;\n-\t      expr.original_code = ERROR_MARK;\n \t      break;\n \t    }\n \t  e3 = c_parser_expr_no_commas (parser, NULL);\n@@ -5420,28 +5435,24 @@ c_parser_postfix_expression (c_parser *parser)\n \t  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n \t    {\n \t      expr.value = error_mark_node;\n-\t      expr.original_code = ERROR_MARK;\n \t      break;\n \t    }\n \t  t1 = c_parser_type_name (parser);\n \t  if (t1 == NULL)\n \t    {\n \t      expr.value = error_mark_node;\n-\t      expr.original_code = ERROR_MARK;\n \t      break;\n \t    }\n \t  if (!c_parser_require (parser, CPP_COMMA, \"expected %<,%>\"))\n \t    {\n \t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n \t      expr.value = error_mark_node;\n-\t      expr.original_code = ERROR_MARK;\n \t      break;\n \t    }\n \t  t2 = c_parser_type_name (parser);\n \t  if (t2 == NULL)\n \t    {\n \t      expr.value = error_mark_node;\n-\t      expr.original_code = ERROR_MARK;\n \t      break;\n \t    }\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n@@ -5455,7 +5466,6 @@ c_parser_postfix_expression (c_parser *parser)\n \t    expr.value = comptypes (e1, e2)\n \t      ? build_int_cst (NULL_TREE, 1)\n \t      : build_int_cst (NULL_TREE, 0);\n-\t    expr.original_code = ERROR_MARK;\n \t  }\n \t  break;\n \tcase RID_AT_SELECTOR:\n@@ -5464,15 +5474,13 @@ c_parser_postfix_expression (c_parser *parser)\n \t  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n \t    {\n \t      expr.value = error_mark_node;\n-\t      expr.original_code = ERROR_MARK;\n \t      break;\n \t    }\n \t  {\n \t    tree sel = c_parser_objc_selector_arg (parser);\n \t    c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t       \"expected %<)%>\");\n \t    expr.value = objc_build_selector_expr (sel);\n-\t    expr.original_code = ERROR_MARK;\n \t  }\n \t  break;\n \tcase RID_AT_PROTOCOL:\n@@ -5481,15 +5489,13 @@ c_parser_postfix_expression (c_parser *parser)\n \t  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n \t    {\n \t      expr.value = error_mark_node;\n-\t      expr.original_code = ERROR_MARK;\n \t      break;\n \t    }\n \t  if (c_parser_next_token_is_not (parser, CPP_NAME))\n \t    {\n \t      c_parser_error (parser, \"expected identifier\");\n \t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n \t      expr.value = error_mark_node;\n-\t      expr.original_code = ERROR_MARK;\n \t      break;\n \t    }\n \t  {\n@@ -5498,7 +5504,6 @@ c_parser_postfix_expression (c_parser *parser)\n \t    c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t       \"expected %<)%>\");\n \t    expr.value = objc_build_protocol_expr (id);\n-\t    expr.original_code = ERROR_MARK;\n \t  }\n \t  break;\n \tcase RID_AT_ENCODE:\n@@ -5508,14 +5513,12 @@ c_parser_postfix_expression (c_parser *parser)\n \t  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n \t    {\n \t      expr.value = error_mark_node;\n-\t      expr.original_code = ERROR_MARK;\n \t      break;\n \t    }\n \t  t1 = c_parser_type_name (parser);\n \t  if (t1 == NULL)\n \t    {\n \t      expr.value = error_mark_node;\n-\t      expr.original_code = ERROR_MARK;\n \t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n \t      break;\n \t    }\n@@ -5524,13 +5527,11 @@ c_parser_postfix_expression (c_parser *parser)\n \t  {\n \t    tree type = groktypename (t1, NULL, NULL);\n \t    expr.value = objc_build_encode_expr (type);\n-\t    expr.original_code = ERROR_MARK;\n \t  }\n \t  break;\n \tdefault:\n \t  c_parser_error (parser, \"expected expression\");\n \t  expr.value = error_mark_node;\n-\t  expr.original_code = ERROR_MARK;\n \t  break;\n \t}\n       break;\n@@ -5545,14 +5546,12 @@ c_parser_postfix_expression (c_parser *parser)\n \t\t\t\t     \"expected %<]%>\");\n \t  expr.value = objc_build_message_expr (build_tree_list (receiver,\n \t\t\t\t\t\t\t\t args));\n-\t  expr.original_code = ERROR_MARK;\n \t  break;\n \t}\n       /* Else fall through to report error.  */\n     default:\n       c_parser_error (parser, \"expected expression\");\n       expr.value = error_mark_node;\n-      expr.original_code = ERROR_MARK;\n       break;\n     }\n   return c_parser_postfix_expression_after_primary (parser, expr);\n@@ -5597,6 +5596,7 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n   non_const |= !type_expr_const;\n   expr.value = build_compound_literal (type, init.value, non_const);\n   expr.original_code = ERROR_MARK;\n+  expr.original_type = NULL;\n   if (type_expr)\n     {\n       if (TREE_CODE (expr.value) == C_MAYBE_CONST_EXPR)\n@@ -5637,6 +5637,7 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t\t\t\t     \"expected %<]%>\");\n \t  expr.value = build_array_ref (expr.value, idx, loc);\n \t  expr.original_code = ERROR_MARK;\n+\t  expr.original_type = NULL;\n \t  break;\n \tcase CPP_OPEN_PAREN:\n \t  /* Function call.  */\n@@ -5655,6 +5656,7 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t      && DECL_BUILT_IN_CLASS (orig_expr.value) == BUILT_IN_NORMAL\n \t      && DECL_FUNCTION_CODE (orig_expr.value) == BUILT_IN_CONSTANT_P)\n \t    expr.original_code = C_MAYBE_CONST_EXPR;\n+\t  expr.original_type = NULL;\n \t  break;\n \tcase CPP_DOT:\n \t  /* Structure element reference.  */\n@@ -5667,11 +5669,23 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t      c_parser_error (parser, \"expected identifier\");\n \t      expr.value = error_mark_node;\n \t      expr.original_code = ERROR_MARK;\n+              expr.original_type = NULL;\n \t      return expr;\n \t    }\n \t  c_parser_consume_token (parser);\n \t  expr.value = build_component_ref (expr.value, ident);\n \t  expr.original_code = ERROR_MARK;\n+\t  if (TREE_CODE (expr.value) != COMPONENT_REF)\n+\t    expr.original_type = NULL;\n+\t  else\n+\t    {\n+\t      /* Remember the original type of a bitfield.  */\n+\t      tree field = TREE_OPERAND (expr.value, 1);\n+\t      if (TREE_CODE (field) != FIELD_DECL)\n+\t\texpr.original_type = NULL;\n+\t      else\n+\t\texpr.original_type = DECL_BIT_FIELD_TYPE (field);\n+\t    }\n \t  break;\n \tcase CPP_DEREF:\n \t  /* Structure element reference.  */\n@@ -5684,6 +5698,7 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t      c_parser_error (parser, \"expected identifier\");\n \t      expr.value = error_mark_node;\n \t      expr.original_code = ERROR_MARK;\n+\t      expr.original_type = NULL;\n \t      return expr;\n \t    }\n \t  c_parser_consume_token (parser);\n@@ -5692,6 +5707,17 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t\t\t\t\t\t\t\t\"->\"),\n \t\t\t\t\t    ident);\n \t  expr.original_code = ERROR_MARK;\n+\t  if (TREE_CODE (expr.value) != COMPONENT_REF)\n+\t    expr.original_type = NULL;\n+\t  else\n+\t    {\n+\t      /* Remember the original type of a bitfield.  */\n+\t      tree field = TREE_OPERAND (expr.value, 1);\n+\t      if (TREE_CODE (field) != FIELD_DECL)\n+\t\texpr.original_type = NULL;\n+\t      else\n+\t\texpr.original_type = DECL_BIT_FIELD_TYPE (field);\n+\t    }\n \t  break;\n \tcase CPP_PLUS_PLUS:\n \t  /* Postincrement.  */\n@@ -5700,6 +5726,7 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t  expr.value = build_unary_op (loc,\n \t\t\t\t       POSTINCREMENT_EXPR, expr.value, 0);\n \t  expr.original_code = ERROR_MARK;\n+\t  expr.original_type = NULL;\n \t  break;\n \tcase CPP_MINUS_MINUS:\n \t  /* Postdecrement.  */\n@@ -5708,6 +5735,7 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t  expr.value = build_unary_op (loc,\n \t\t\t\t       POSTDECREMENT_EXPR, expr.value, 0);\n \t  expr.original_code = ERROR_MARK;\n+\t  expr.original_type = NULL;\n \t  break;\n \tdefault:\n \t  return expr;\n@@ -5735,6 +5763,7 @@ c_parser_expression (c_parser *parser)\n       next = default_function_array_conversion (next);\n       expr.value = build_compound_expr (expr.value, next.value);\n       expr.original_code = COMPOUND_EXPR;\n+      expr.original_type = NULL;\n     }\n   return expr;\n }"}, {"sha": "6b9fcc798ca13efde120a203556f968d3df12f7f", "filename": "gcc/c-tree.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6866c6e8ff0cbc1d57f9ae603b5af155def03484/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6866c6e8ff0cbc1d57f9ae603b5af155def03484/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=6866c6e8ff0cbc1d57f9ae603b5af155def03484", "patch": "@@ -163,6 +163,11 @@ struct c_expr\n      initializers, or ERROR_MARK for other expressions (including\n      parenthesized expressions).  */\n   enum tree_code original_code;\n+  /* If not NULL, the original type of an expression.  This will\n+     differ from the type of the value field for an enum constant.\n+     The type of an enum constant is a plain integer type, but this\n+     field will be the enum type.  */\n+  tree original_type;\n };\n \n /* A kind of type specifier.  Note that this information is currently\n@@ -577,7 +582,7 @@ extern struct c_expr default_function_array_conversion (struct c_expr);\n extern tree composite_type (tree, tree);\n extern tree build_component_ref (tree, tree);\n extern tree build_array_ref (tree, tree, location_t);\n-extern tree build_external_ref (tree, int, location_t);\n+extern tree build_external_ref (tree, int, location_t, tree *);\n extern void pop_maybe_used (bool);\n extern struct c_expr c_expr_sizeof_expr (struct c_expr);\n extern struct c_expr c_expr_sizeof_type (struct c_type_name *);"}, {"sha": "c6bb9f8792cf4871c3242bd15e83f77114a96065", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6866c6e8ff0cbc1d57f9ae603b5af155def03484/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6866c6e8ff0cbc1d57f9ae603b5af155def03484/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=6866c6e8ff0cbc1d57f9ae603b5af155def03484", "patch": "@@ -2202,9 +2202,12 @@ build_array_ref (tree array, tree index, location_t loc)\n \f\n /* Build an external reference to identifier ID.  FUN indicates\n    whether this will be used for a function call.  LOC is the source\n-   location of the identifier.  */\n+   location of the identifier.  This sets *TYPE to the type of the\n+   identifier, which is not the same as the type of the returned value\n+   for CONST_DECLs defined as enum constants.  If the type of the\n+   identifier is not available, *TYPE is set to NULL.  */\n tree\n-build_external_ref (tree id, int fun, location_t loc)\n+build_external_ref (tree id, int fun, location_t loc, tree *type)\n {\n   tree ref;\n   tree decl = lookup_name (id);\n@@ -2213,8 +2216,12 @@ build_external_ref (tree id, int fun, location_t loc)\n      whatever lookup_name() found.  */\n   decl = objc_lookup_ivar (decl, id);\n \n+  *type = NULL;\n   if (decl && decl != error_mark_node)\n-    ref = decl;\n+    {\n+      ref = decl;\n+      *type = TREE_TYPE (ref);\n+    }\n   else if (fun)\n     /* Implicit function declaration.  */\n     ref = implicitly_declare (id);\n@@ -2346,6 +2353,7 @@ c_expr_sizeof_expr (struct c_expr expr)\n     {\n       ret.value = error_mark_node;\n       ret.original_code = ERROR_MARK;\n+      ret.original_type = NULL;\n       pop_maybe_used (false);\n     }\n   else\n@@ -2355,6 +2363,7 @@ c_expr_sizeof_expr (struct c_expr expr)\n \t\t\t\t       &expr_const_operands);\n       ret.value = c_sizeof (TREE_TYPE (folded_expr));\n       ret.original_code = ERROR_MARK;\n+      ret.original_type = NULL;\n       if (c_vla_type_p (TREE_TYPE (folded_expr)))\n \t{\n \t  /* sizeof is evaluated when given a vla (C99 6.5.3.4p2).  */\n@@ -2380,6 +2389,7 @@ c_expr_sizeof_type (struct c_type_name *t)\n   type = groktypename (t, &type_expr, &type_expr_const);\n   ret.value = c_sizeof (type);\n   ret.original_code = ERROR_MARK;\n+  ret.original_type = NULL;\n   if (type_expr && c_vla_type_p (type))\n     {\n       ret.value = build2 (C_MAYBE_CONST_EXPR, TREE_TYPE (ret.value),\n@@ -2856,7 +2866,8 @@ parser_build_unary_op (enum tree_code code, struct c_expr arg, location_t loc)\n \n   result.value = build_unary_op (loc, code, arg.value, 0);\n   result.original_code = code;\n-  \n+  result.original_type = NULL;\n+\n   if (TREE_OVERFLOW_P (result.value) && !TREE_OVERFLOW_P (arg.value))\n     overflow_warning (result.value);\n \n@@ -2879,10 +2890,17 @@ parser_build_binary_op (location_t location, enum tree_code code,\n \n   enum tree_code code1 = arg1.original_code;\n   enum tree_code code2 = arg2.original_code;\n+  tree type1 = (arg1.original_type\n+                ? arg1.original_type\n+                : TREE_TYPE (arg1.value));\n+  tree type2 = (arg2.original_type\n+                ? arg2.original_type\n+                : TREE_TYPE (arg2.value));\n \n   result.value = build_binary_op (location, code,\n \t\t\t\t  arg1.value, arg2.value, 1);\n   result.original_code = code;\n+  result.original_type = NULL;\n \n   if (TREE_CODE (result.value) == ERROR_MARK)\n     return result;\n@@ -2915,6 +2933,16 @@ parser_build_binary_op (location_t location, enum tree_code code,\n       && !TREE_OVERFLOW_P (arg2.value))\n     overflow_warning (result.value);\n \n+  /* Warn about comparisons of different enum types.  */\n+  if (warn_enum_compare\n+      && TREE_CODE_CLASS (code) == tcc_comparison\n+      && TREE_CODE (type1) == ENUMERAL_TYPE\n+      && TREE_CODE (type2) == ENUMERAL_TYPE\n+      && TYPE_MAIN_VARIANT (type1) != TYPE_MAIN_VARIANT (type2))\n+    warning_at (location, OPT_Wenum_compare,\n+\t\t\"comparison between %qT and %qT\",\n+\t\ttype1, type2);\n+\n   return result;\n }\n \f\n@@ -5171,6 +5199,7 @@ digest_init (tree type, tree init, bool null_pointer_constant,\n \t  tree typ2 = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (inside_init)));\n \t  expr.value = inside_init;\n \t  expr.original_code = (strict_string ? STRING_CST : ERROR_MARK);\n+\t  expr.original_type = NULL;\n \t  maybe_warn_string_init (type, expr);\n \n \t  if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (inside_init)),\n@@ -5690,6 +5719,7 @@ really_start_incremental_init (tree type)\n   p->depth = constructor_depth;\n   p->replacement_value.value = 0;\n   p->replacement_value.original_code = ERROR_MARK;\n+  p->replacement_value.original_type = NULL;\n   p->implicit = 0;\n   p->range_stack = 0;\n   p->outer = 0;\n@@ -5833,6 +5863,7 @@ push_init_level (int implicit)\n   p->depth = constructor_depth;\n   p->replacement_value.value = 0;\n   p->replacement_value.original_code = ERROR_MARK;\n+  p->replacement_value.original_type = NULL;\n   p->implicit = implicit;\n   p->outer = 0;\n   p->incremental = constructor_incremental;\n@@ -5989,6 +6020,7 @@ pop_init_level (int implicit)\n   struct c_expr ret;\n   ret.value = 0;\n   ret.original_code = ERROR_MARK;\n+  ret.original_type = NULL;\n \n   if (implicit == 0)\n     {"}, {"sha": "2a1b74076cb35607b73e327f40d990071d6525bf", "filename": "gcc/c.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6866c6e8ff0cbc1d57f9ae603b5af155def03484/gcc%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6866c6e8ff0cbc1d57f9ae603b5af155def03484/gcc%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc.opt?ref=6866c6e8ff0cbc1d57f9ae603b5af155def03484", "patch": "@@ -204,7 +204,7 @@ C ObjC C++ ObjC++ Warning\n Warn about stray tokens after #elif and #endif\n \n Wenum-compare\n-C++ ObjC++ Var(warn_enum_compare) Init(1) Warning\n+C ObjC C++ ObjC++ Var(warn_enum_compare) Init(-1) Warning\n Warn about comparison of different enum types\n \n Werror"}, {"sha": "12262f25d5486a3b368bf199b61dcf2572b9dca6", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6866c6e8ff0cbc1d57f9ae603b5af155def03484/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6866c6e8ff0cbc1d57f9ae603b5af155def03484/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=6866c6e8ff0cbc1d57f9ae603b5af155def03484", "patch": "@@ -2758,6 +2758,7 @@ Options} and @ref{Objective-C and Objective-C++ Dialect Options}.\n -Warray-bounds @r{(only with} @option{-O2}@r{)}  @gol\n -Wc++0x-compat  @gol\n -Wchar-subscripts  @gol\n+-Wenum-compare @r{(in C/Objc; this is on by default in C++)} @gol\n -Wimplicit-int  @gol\n -Wimplicit-function-declaration  @gol\n -Wcomment  @gol\n@@ -3743,11 +3744,12 @@ integers are disabled by default in C++ unless\n Warn if an empty body occurs in an @samp{if}, @samp{else} or @samp{do\n while} statement.  This warning is also enabled by @option{-Wextra}.\n \n-@item -Wenum-compare @r{(C++ and Objective-C++ only)}\n+@item -Wenum-compare\n @opindex Wenum-compare\n @opindex Wno-enum-compare\n-Warn about a comparison between values of different enum types. This\n-warning is enabled by default.\n+Warn about a comparison between values of different enum types. In C++\n+this warning is enabled by default.  In C this warning is enabled by\n+@option{-Wall}.\n \n @item -Wsign-compare\n @opindex Wsign-compare"}, {"sha": "ffcd8889eefcc8fc6ec70b762a2e284202244fe0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6866c6e8ff0cbc1d57f9ae603b5af155def03484/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6866c6e8ff0cbc1d57f9ae603b5af155def03484/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6866c6e8ff0cbc1d57f9ae603b5af155def03484", "patch": "@@ -1,3 +1,7 @@\n+2009-04-15  Ian Lance Taylor  <iant@google.com>\n+\n+\t* gcc.dg/Wenum-compare-1.c: New testcase.\n+\n 2009-04-15  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/39764"}, {"sha": "dd321e0f643e126a1715aa25904abe5fbb4963be", "filename": "gcc/testsuite/gcc.dg/Wenum-compare-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6866c6e8ff0cbc1d57f9ae603b5af155def03484/gcc%2Ftestsuite%2Fgcc.dg%2FWenum-compare-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6866c6e8ff0cbc1d57f9ae603b5af155def03484/gcc%2Ftestsuite%2Fgcc.dg%2FWenum-compare-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWenum-compare-1.c?ref=6866c6e8ff0cbc1d57f9ae603b5af155def03484", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wenum-compare\" } */\n+enum E1 { A, B, C };\n+enum E2 { D, E, F };\n+extern void f2 ();\n+void\n+f1 ()\n+{\n+  int a = A;\n+  int d = D;\n+  enum E1 e1 = A;\n+  enum E2 e2 = D;\n+  if (A > D)\t/* { dg-warning \"comparison between .enum E1. and .enum E2.\" } */\n+    f2 ();\n+  if (e1 > e2)  /* { dg-warning \"comparison between .enum E1. and .enum E2.\" } */\n+    f2 ();\n+  if (e1 > e2 + 1)\n+    f2 ();\n+  if (A > 0)\n+    f2 ();\n+  if (e1 > 0)\n+    f2 ();\n+  if (A + D > 0)\n+    f2 ();\n+  if (e1 > 0)\n+    f2 ();\n+  if (A + D > 0)\n+    f2 ();\n+  if ((int) A > D)\n+    f2 ();\n+  if ((int) e1 > e2)\n+    f2 ();\n+}"}]}