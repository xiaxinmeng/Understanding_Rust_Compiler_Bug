{"sha": "3dce09649d93c3465754c0b027574823607964ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RjZTA5NjQ5ZDkzYzM0NjU3NTRjMGIwMjc1NzQ4MjM2MDc5NjRhYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2014-10-13T20:20:44Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2014-10-13T20:20:44Z"}, "message": "Handle cfa adjustments in csa pass\n\n* combine-stack-adj.c (no_unhandled_cfa): New.\n(maybe_merge_cfa_adjust): New.\n(combine_stack_adjustments_for_block): Use them.\n\nFrom-SVN: r216161", "tree": {"sha": "d350efbd0701fbb2f17254a9d19f87669769a4bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d350efbd0701fbb2f17254a9d19f87669769a4bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3dce09649d93c3465754c0b027574823607964ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dce09649d93c3465754c0b027574823607964ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dce09649d93c3465754c0b027574823607964ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dce09649d93c3465754c0b027574823607964ab/comments", "author": null, "committer": null, "parents": [{"sha": "e3c891c7cf1218dc6e1c9dd2593e110fe67ad7c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3c891c7cf1218dc6e1c9dd2593e110fe67ad7c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3c891c7cf1218dc6e1c9dd2593e110fe67ad7c6"}], "stats": {"total": 374, "additions": 367, "deletions": 7}, "files": [{"sha": "8829dfeec2003ec621cb4ec398ccc4d74bd4e1c0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dce09649d93c3465754c0b027574823607964ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dce09649d93c3465754c0b027574823607964ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3dce09649d93c3465754c0b027574823607964ab", "patch": "@@ -1,3 +1,9 @@\n+2014-10-13  Richard Henderson  <rth@redhat.com>\n+\n+\t* combine-stack-adj.c (no_unhandled_cfa): New.\n+\t(maybe_merge_cfa_adjust): New.\n+\t(combine_stack_adjustments_for_block): Use them.\n+\n 2014-10-13  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* Makefile.in (TAGS): Tag ../include files."}, {"sha": "844873c574dce27eaf8d9d1f4467d92e95192644", "filename": "gcc/combine-stack-adj.c", "status": "modified", "additions": 90, "deletions": 7, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dce09649d93c3465754c0b027574823607964ab/gcc%2Fcombine-stack-adj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dce09649d93c3465754c0b027574823607964ab/gcc%2Fcombine-stack-adj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine-stack-adj.c?ref=3dce09649d93c3465754c0b027574823607964ab", "patch": "@@ -190,6 +190,44 @@ record_one_stack_ref (rtx_insn *insn, rtx *ref, struct csa_reflist *next_reflist\n   return ml;\n }\n \n+/* We only know how to adjust the CFA; no other frame-related changes\n+   may appear in any insn to be deleted.  */\n+\n+static bool\n+no_unhandled_cfa (rtx_insn *insn)\n+{\n+  if (!RTX_FRAME_RELATED_P (insn))\n+    return true;\n+\n+  /* No CFA notes at all is a legacy interpretation like\n+     FRAME_RELATED_EXPR, and is context sensitive within\n+     the prologue state machine.  We can't handle that here.  */\n+  bool has_cfa_adjust = false;\n+\n+  for (rtx link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+    switch (REG_NOTE_KIND (link))\n+      {\n+      default:\n+        break;\n+      case REG_CFA_ADJUST_CFA:\n+\thas_cfa_adjust = true;\n+\tbreak;\n+\n+      case REG_FRAME_RELATED_EXPR:\n+      case REG_CFA_DEF_CFA:\n+      case REG_CFA_OFFSET:\n+      case REG_CFA_REGISTER:\n+      case REG_CFA_EXPRESSION:\n+      case REG_CFA_RESTORE:\n+      case REG_CFA_SET_VDRAP:\n+      case REG_CFA_WINDOW_SAVE:\n+      case REG_CFA_FLUSH_QUEUE:\n+\treturn false;\n+      }\n+\n+  return has_cfa_adjust;\n+}\n+\n /* Attempt to apply ADJUST to the stack adjusting insn INSN, as well\n    as each of the memories and stack references in REFLIST.  Return true\n    on success.  */\n@@ -320,6 +358,44 @@ maybe_move_args_size_note (rtx_insn *last, rtx_insn *insn, bool after)\n     add_reg_note (last, REG_ARGS_SIZE, XEXP (note, 0));\n }\n \n+/* Merge any REG_CFA_ADJUST_CFA note from SRC into DST.\n+   AFTER is true iff DST follows SRC in the instruction stream.  */\n+\n+static void\n+maybe_merge_cfa_adjust (rtx_insn *dst, rtx_insn *src, bool after)\n+{\n+  rtx snote = NULL, dnote = NULL;\n+  rtx sexp, dexp;\n+  rtx exp1, exp2;\n+\n+  if (RTX_FRAME_RELATED_P (src))\n+    snote = find_reg_note (src, REG_CFA_ADJUST_CFA, NULL_RTX);\n+  if (snote == NULL)\n+    return;\n+  sexp = XEXP (snote, 0);\n+\n+  if (RTX_FRAME_RELATED_P (dst))\n+    dnote = find_reg_note (dst, REG_CFA_ADJUST_CFA, NULL_RTX);\n+  if (dnote == NULL)\n+    {\n+      add_reg_note (dst, REG_CFA_ADJUST_CFA, sexp);\n+      return;\n+    }\n+  dexp = XEXP (dnote, 0);\n+\n+  gcc_assert (GET_CODE (sexp) == SET);\n+  gcc_assert (GET_CODE (dexp) == SET);\n+\n+  if (after)\n+    exp1 = dexp, exp2 = sexp;\n+  else\n+    exp1 = sexp, exp2 = dexp;\n+\n+  SET_SRC (exp1) = simplify_replace_rtx (SET_SRC (exp1), SET_DEST (exp2),\n+\t\t\t\t\t SET_SRC (exp2));\n+  XEXP (dnote, 0) = exp1;\n+}\n+\n /* Return the next (or previous) active insn within BB.  */\n \n static rtx_insn *\n@@ -491,12 +567,15 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t      /* Combine an allocation into the first instruction.  */\n \t      if (STACK_GROWS_DOWNWARD ? this_adjust <= 0 : this_adjust >= 0)\n \t\t{\n-\t\t  if (try_apply_stack_adjustment (last_sp_set, reflist,\n-\t\t\t\t\t\t  last_sp_adjust + this_adjust,\n-\t\t\t\t\t\t  this_adjust))\n+\t\t  if (no_unhandled_cfa (insn)\n+\t\t      && try_apply_stack_adjustment (last_sp_set, reflist,\n+\t\t\t\t\t\t     last_sp_adjust\n+\t\t\t\t\t\t     + this_adjust,\n+\t\t\t\t\t\t     this_adjust))\n \t\t    {\n \t\t      /* It worked!  */\n \t\t      maybe_move_args_size_note (last_sp_set, insn, false);\n+\t\t      maybe_merge_cfa_adjust (last_sp_set, insn, false);\n \t\t      delete_insn (insn);\n \t\t      last_sp_adjust += this_adjust;\n \t\t      continue;\n@@ -508,12 +587,15 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t      else if (STACK_GROWS_DOWNWARD\n \t\t       ? last_sp_adjust >= 0 : last_sp_adjust <= 0)\n \t\t{\n-\t\t  if (try_apply_stack_adjustment (insn, reflist,\n-\t\t\t\t\t\t  last_sp_adjust + this_adjust,\n-\t\t\t\t\t\t  -last_sp_adjust))\n+\t\t  if (no_unhandled_cfa (last_sp_set)\n+\t\t      && try_apply_stack_adjustment (insn, reflist,\n+\t\t\t\t\t\t     last_sp_adjust\n+\t\t\t\t\t\t     + this_adjust,\n+\t\t\t\t\t\t     -last_sp_adjust))\n \t\t    {\n \t\t      /* It worked!  */\n \t\t      maybe_move_args_size_note (insn, last_sp_set, true);\n+\t\t      maybe_merge_cfa_adjust (insn, last_sp_set, true);\n \t\t      delete_insn (last_sp_set);\n \t\t      last_sp_set = insn;\n \t\t      last_sp_adjust += this_adjust;\n@@ -528,9 +610,10 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t\t delete the old deallocation insn.  */\n \t      if (last_sp_set)\n \t\t{\n-\t\t  if (last_sp_adjust == 0)\n+\t\t  if (last_sp_adjust == 0 && no_unhandled_cfa (last_sp_set))\n \t\t    {\n \t\t      maybe_move_args_size_note (insn, last_sp_set, true);\n+\t\t      maybe_merge_cfa_adjust (insn, last_sp_set, true);\n \t\t      delete_insn (last_sp_set);\n \t\t    }\n \t\t  else"}, {"sha": "b052a7041065ddafa0aa8407c257be152c8aa3fc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dce09649d93c3465754c0b027574823607964ab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dce09649d93c3465754c0b027574823607964ab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3dce09649d93c3465754c0b027574823607964ab", "patch": "@@ -1,3 +1,7 @@\n+2014-10-13  Richard Henderson  <rth@redhat.com>\n+\n+\t* g++.dg/torture/20141013.C: New.\n+\n 2014-10-13  Evgeny Stupachenko  <evstupac@gmail.com>\n \n \tPR target/8340"}, {"sha": "529ef0965e4472e5038a9e6d09f13ca4f4a05954", "filename": "gcc/testsuite/g++.dg/torture/20141013.C", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dce09649d93c3465754c0b027574823607964ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2F20141013.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dce09649d93c3465754c0b027574823607964ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2F20141013.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2F20141013.C?ref=3dce09649d93c3465754c0b027574823607964ab", "patch": "@@ -0,0 +1,267 @@\n+enum\n+{\n+  _sch_isdigit = 0x0004,\n+  _sch_ispunct = 0x0020,\n+  _sch_isxdigit = 0x0100,\n+  _sch_isidst = 0x0200,\n+  _sch_isvsp = 0x0400,\n+  _sch_isnvsp = 0x0800,\n+  _sch_isalnum = _sch_isidst | _sch_isdigit,\n+  _sch_iscppsp = _sch_isvsp | _sch_isnvsp,\n+};\n+extern const unsigned short _sch_istable[256];\n+typedef union tree_node *tree;\n+typedef const union tree_node *const_tree;\n+enum opt_code\n+{\n+  OPT_Warray_bounds = 240,\n+  OPT_Wformat_ = 245,\n+  OPT_Wintf_annotation = 368,\n+  OPT_std_gnu__14 = 1311,\n+};\n+enum tree_code\n+{\n+  TREE_LIST,\n+  CONST_DECL,\n+  ADDR_EXPR,\n+  MAX_TREE_CODES\n+};\n+enum tree_code_class\n+{\n+  tcc_type,\n+};\n+enum tree_node_structure_enum\n+{\n+  TS_TYPED,\n+  TS_COMMON,\n+};\n+enum integer_type_kind\n+{\n+  itk_char,\n+  itk_none\n+};\n+struct tree_base\n+{\n+  enum tree_code code:16;\n+};\n+struct tree_typed\n+{\n+  tree type;\n+};\n+struct tree_common\n+{\n+  tree chain;\n+};\n+struct tree_list\n+{\n+  tree purpose;\n+};\n+struct tree_type_common\n+{\n+  tree main_variant;\n+};\n+union tree_node\n+{\n+  struct tree_base base;\n+  struct tree_typed typed;\n+  struct tree_common common;\n+  struct tree_type_common type_common;\n+  struct tree_list list;\n+};\n+extern unsigned char tree_contains_struct[MAX_TREE_CODES][64];\n+extern tree integer_types[itk_none];\n+extern void tree_contains_struct_check_failed (const_tree,\n+\t\t\t\t\t       tree_node_structure_enum,\n+\t\t\t\t\t       const char *, int,\n+\t\t\t\t\t       const char *)\n+  __attribute__ ((__noreturn__));\n+inline tree\n+tree_check (tree __t, const char *__f, int __l, const char *__g,\n+\t    tree_code __c)\n+{\n+}\n+\n+inline const_tree\n+contains_struct_check (const_tree __t,\n+\t\t       const enum tree_node_structure_enum __s,\n+\t\t       const char *__f, int __l, const char *__g)\n+{\n+  if (tree_contains_struct[((enum tree_code) (__t)->base.code)][__s] != 1)\n+    tree_contains_struct_check_failed (__t, __s, __f, __l, __g);\n+}\n+\n+inline const_tree\n+tree_class_check (const_tree __t, const enum tree_code_class __class,\n+\t\t  const char *__f, int __l, const char *__g)\n+{\n+}\n+\n+static inline bool\n+is_attribute_p (const char *attr_name, const_tree ident)\n+{\n+}\n+\n+extern int integer_zerop (const_tree);\n+extern bool warning (int, const char *, ...)\n+  __attribute__ ((__nonnull__ (2)));\n+extern void\n+check_function_arguments_recurse (void (*)(void *, tree, unsigned long long),\n+\t\t\t\t  void *, tree, unsigned long long);\n+extern bool objc_string_ref_type_p (tree);\n+enum\n+{\n+  FMT_FLAG_SCANF_A_KLUDGE = 2,\n+  FMT_FLAG_PARSE_ARG_CONVERT_EXTERNAL = 256\n+};\n+typedef struct\n+{\n+}\n+format_flag_spec;\n+typedef struct\n+{\n+  int flags;\n+  tree *width_type;\n+}\n+format_kind_info;\n+typedef struct alloc_pool_list_def\n+{\n+}\n+ *alloc_pool;\n+struct gcc_targetcm\n+{\n+  bool (*string_object_ref_type_p) (const_tree stringref);\n+}\n+ ;\n+extern struct gcc_targetcm targetcm;\n+enum format_type\n+{\n+  gcc_objc_string_format_type,\n+};\n+typedef struct function_format_info\n+{\n+  int format_type;\n+}\n+function_format_info;\n+static const format_kind_info format_types_orig[] = { };\n+struct format_check_context { };\n+\n+static const format_kind_info *format_types = format_types_orig;\n+static void check_format_info (function_format_info *, tree);\n+void check_format_arg (void *, tree, unsigned long long);\n+\n+void\n+check_function_format (tree attrs, int nargs, tree * argarray)\n+{\n+  tree a;\n+  for (a = attrs;\n+       a;\n+       ((contains_struct_check\n+\t ((a), (TS_COMMON), \"../../git-master/gcc/c-family/c-format.c\", 1002,\n+\t  __FUNCTION__))->common.chain))\n+    {\n+      if (is_attribute_p\n+\t  (\"format\",\n+\t   ((tree_check\n+\t     ((a), \"../../git-master/gcc/c-family/c-format.c\", 1004,\n+\t      __FUNCTION__, (TREE_LIST)))->list.purpose)))\n+\t{\n+\t  function_format_info info;\n+\t  {\n+\t    tree params = (tree) __null;\n+\t    check_format_info (&info, params);\n+\t  }\n+\t}\n+    }\n+}\n+\n+static bool\n+avoid_dollar_number (const char *format)\n+{\n+  while ((_sch_istable[(*format) & 0xff] & (unsigned short) (_sch_isdigit)))\n+    format++;\n+  if (*format == '$')\n+    {\n+      warning (OPT_Wformat_,\n+\t       \"$ operand number used after format without operand number\");\n+    }\n+}\n+\n+static void\n+check_format_info (function_format_info * info, tree params)\n+{\n+  format_check_context format_ctx;\n+  unsigned long long arg_num;\n+  tree format_tree;\n+  check_function_arguments_recurse (check_format_arg, &format_ctx,\n+\t\t\t\t    format_tree, arg_num);\n+  const char *format_chars;\n+  if (integer_zerop (format_tree))\n+    {\n+      {\n+\t((contains_struct_check\n+\t  ((params), (TS_COMMON),\n+\t   \"../../git-master/gcc/c-family/c-format.c\", 1444,\n+\t   __FUNCTION__))->common.chain);\n+      }\n+      return;\n+    }\n+  if (((enum tree_code) (format_tree)->base.code) != ADDR_EXPR)\n+    {\n+      return;\n+    }\n+  if (format_types[info->format_type].flags & (int)\n+      FMT_FLAG_PARSE_ARG_CONVERT_EXTERNAL)\n+    {\n+      bool objc_str = (info->format_type == gcc_objc_string_format_type);\n+      if (((enum tree_code) (format_tree)->base.code) != CONST_DECL\n+\t  ||\n+\t  !((objc_str\n+\t     &&\n+\t     objc_string_ref_type_p (((contains_struct_check\n+\t\t\t\t       ((format_tree), (TS_TYPED),\n+\t\t\t\t\t\"../../git-master/gcc/c-family/c-format.c\",\n+\t\t\t\t\t1498, __FUNCTION__))->typed.type)))\n+\t    ||\n+\t    (*targetcm.string_object_ref_type_p) ((const_tree)\n+\t\t\t\t\t\t  ((contains_struct_check\n+\t\t\t\t\t\t    ((format_tree),\n+\t\t\t\t\t\t     (TS_TYPED),\n+\t\t\t\t\t\t     \"../../git-master/gcc/c-family/c-format.c\",\n+\t\t\t\t\t\t     1500,\n+\t\t\t\t\t\t     __FUNCTION__))->typed.\n+\t\t\t\t\t\t   type))))\n+\t{\n+\t}\n+    }\n+  {\n+  }\n+  if (((tree_class_check\n+\t((((contains_struct_check\n+\t    ((((contains_struct_check\n+\t\t((format_tree), (TS_TYPED),\n+\t\t \"../../git-master/gcc/c-family/c-format.c\", 1549,\n+\t\t __FUNCTION__))->typed.type)), (TS_TYPED),\n+\t     \"../../git-master/gcc/c-family/c-format.c\", 1549,\n+\t     __FUNCTION__))->typed.type)), (tcc_type),\n+\t \"../../git-master/gcc/c-family/c-format.c\", 1549,\n+\t __FUNCTION__))->type_common.main_variant) != integer_types[itk_char])\n+    {\n+      return;\n+    }\n+  {\n+  }\n+  const format_kind_info *fki = &format_types[info->format_type];\n+  while (*format_chars != 0)\n+    {\n+      {\n+\tif (fki->width_type != __null && *format_chars == '*')\n+\t  {\n+\t    {\n+\t      if (avoid_dollar_number (format_chars))\n+\t\tif (avoid_dollar_number (format_chars))\n+\t\t  return;\n+\t    }\n+\t  }\n+      }\n+    }\n+}"}]}