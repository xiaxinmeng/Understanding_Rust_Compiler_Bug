{"sha": "1ec87690545eefc5c1453b225c62f5adcbbe1f49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVjODc2OTA1NDVlZWZjNWMxNDUzYjIyNWM2MmY1YWRjYmJlMWY0OQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-02-07T16:58:17Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-02-07T16:58:17Z"}, "message": "re PR tree-optimization/47615 (ICE: too deep recursion in phi_translate/phi_translate_1 with -ftree-pre -fno-tree-fre -fno-tree-sra)\n\n2011-02-07  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/47615\n\t* tree-ssa-sccvn.h (run_scc_vn): Take a vn-walk mode argument.\n\t* tree-ssa-sccvn.c (default_vn_walk_kind): New global.\n\t(run_scc_vn): Initialize it.\n\t(visit_reference_op_load): Use it.\n\t* tree-ssa-pre.c (execute_pre): Use VN_WALK if in PRE.\n\n\t* g++.dg/opt/pr47615.C: New testcase.\n\nFrom-SVN: r169888", "tree": {"sha": "97360474f30c6761309e34c3f16854fbc0320127", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97360474f30c6761309e34c3f16854fbc0320127"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ec87690545eefc5c1453b225c62f5adcbbe1f49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ec87690545eefc5c1453b225c62f5adcbbe1f49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ec87690545eefc5c1453b225c62f5adcbbe1f49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ec87690545eefc5c1453b225c62f5adcbbe1f49/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b46ae6da882b09242d230d4ec532e534c9bd1323", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b46ae6da882b09242d230d4ec532e534c9bd1323", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b46ae6da882b09242d230d4ec532e534c9bd1323"}], "stats": {"total": 745, "additions": 738, "deletions": 7}, "files": [{"sha": "06643283c4cb1020fb42fe5df3c7624f6842b83b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ec87690545eefc5c1453b225c62f5adcbbe1f49/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ec87690545eefc5c1453b225c62f5adcbbe1f49/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ec87690545eefc5c1453b225c62f5adcbbe1f49", "patch": "@@ -1,3 +1,12 @@\n+2011-02-07  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/47615\n+\t* tree-ssa-sccvn.h (run_scc_vn): Take a vn-walk mode argument.\n+\t* tree-ssa-sccvn.c (default_vn_walk_kind): New global.\n+\t(run_scc_vn): Initialize it.\n+\t(visit_reference_op_load): Use it.\n+\t* tree-ssa-pre.c (execute_pre): Use VN_WALK if in PRE.\n+\n 2011-02-07  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n \n \t* config/spu/spu.c (spu_init_libfuncs): Install SImode and"}, {"sha": "eca3d7f07268c2a786b8f421407333603b097f73", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ec87690545eefc5c1453b225c62f5adcbbe1f49/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ec87690545eefc5c1453b225c62f5adcbbe1f49/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1ec87690545eefc5c1453b225c62f5adcbbe1f49", "patch": "@@ -1,3 +1,8 @@\n+2011-02-07  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/47615\n+\t* g++.dg/opt/pr47615.C: New testcase.\n+\n 2011-02-07  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/47621"}, {"sha": "bbbcbe1e47ffcf0e69c604a3977b87da43098c2f", "filename": "gcc/testsuite/g++.dg/opt/pr47615.C", "status": "added", "additions": 711, "deletions": 0, "changes": 711, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ec87690545eefc5c1453b225c62f5adcbbe1f49/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr47615.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ec87690545eefc5c1453b225c62f5adcbbe1f49/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr47615.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr47615.C?ref=1ec87690545eefc5c1453b225c62f5adcbbe1f49", "patch": "@@ -0,0 +1,711 @@\n+// { dg-do compile }\n+// { dg-options \"-O -fstrict-aliasing -ftree-pre -fno-tree-fre -fno-tree-sra\" }\n+\n+typedef __SIZE_TYPE__ size_t;\n+namespace std \n+{\n+  template < class _T1, class > struct pair\n+  {\n+    _T1 first;\n+  };\n+}\n+namespace __gnu_cxx\n+{\n+  template < typename _Tp > class new_allocator\n+  {\n+  public:\n+    typedef size_t size_type;\n+    typedef _Tp * pointer;\n+    typedef _Tp const_pointer;\n+    typedef _Tp & reference;\n+    typedef const _Tp & const_reference;\n+    template < typename _Tp1 > struct rebind\n+    {\n+      typedef new_allocator < _Tp1 > other;\n+    };\n+  };\n+}\n+namespace std\n+{\n+template < typename _Tp > class allocator:\n+  public __gnu_cxx::new_allocator < _Tp >\n+  {};\n+  template < typename, typename, typename > struct binary_function;\n+  template < typename _Tp > struct less:binary_function < _Tp, _Tp, bool >\n+  {};\n+}\n+namespace __gnu_cxx\n+{\n+  namespace typelist\n+  {\n+    struct null_type;\n+    template < typename Root > struct node\n+    {\n+      typedef Root root;\n+    };\n+    template < typename, typename > struct chain;\n+    namespace detail\n+    {\n+      template < typename, int >struct chain_at_index_;\n+      template\n+\t<\n+\ttypename\n+\tHd, typename Tl > struct chain_at_index_ <chain < Hd, Tl >, 0 >\n+      {\n+\ttypedef Hd type;\n+      };\n+      template\n+\t<\n+\ttypename\n+\tHd, typename Tl, int i > struct chain_at_index_ <chain < Hd, Tl >, i >\n+      {\n+\ttypedef typename chain_at_index_ < Tl, i - 1 >::type type;\n+      };\n+    }\n+    template < typename Typelist, int i > struct at_index\n+    {\n+      typedef typename Typelist::root root_type;\n+      typedef detail::chain_at_index_ < root_type, i > index_type;\n+      typedef typename index_type::type type;\n+    };\n+    template < typename T1, typename T2 > struct create2\n+    {\n+      typedef node < chain < T1, chain < T2, null_type > > >type;\n+    };\n+  }\n+}\n+namespace std\n+{\n+  namespace tr1\n+  {\n+    template < typename _Tp, _Tp __v > struct integral_constant\n+    {\n+      static const _Tp value = __v;\n+    };\n+    typedef integral_constant < bool, false > false_type;\n+    template < typename, typename > struct is_same:false_type\n+    {};\n+  }\n+}\n+using std::tr1::is_same;\n+namespace __gnu_pbds\n+{\n+  struct null_mapped_type;\n+  struct rb_tree_tag;\n+  namespace detail\n+  {\n+    template < typename, typename, typename > struct basic_tree_policy_base;\n+    template\n+      <\n+      typename\n+      Const_Node_Iterator,\n+      typename\n+      Allocator\n+      >\n+      struct\n+      basic_tree_policy_base\n+      <Const_Node_Iterator, Const_Node_Iterator, Allocator >\n+    {};\n+  }\n+  template\n+    < typename, typename, typename, typename > struct null_tree_node_update;\n+template < typename Const_Node_Iterator, typename Node_Iterator, typename, typename Allocator > class tree_order_statistics_node_update:\n+  detail::basic_tree_policy_base\n+    < Const_Node_Iterator, Node_Iterator, Allocator >\n+  {\n+  public:\n+    typedef Allocator allocator_type;\n+    typedef typename allocator_type::size_type size_type;\n+    typedef size_type metadata_type;\n+    typedef Const_Node_Iterator const_node_iterator;\n+    typedef Node_Iterator node_iterator;\n+    typedef\n+      typename\n+      allocator_type::template\n+      rebind < metadata_type >::other::reference metadata_reference;\n+    void operator () (node_iterator, const_node_iterator) const;\n+  };\n+  template\n+    <\n+    typename\n+    Const_Node_Iterator,\n+    class\n+    Node_Iterator,\n+    class\n+    Cmp_Fn,\n+    class\n+    Allocator\n+    >\n+    inline\n+    void\n+    tree_order_statistics_node_update\n+    <\n+    Const_Node_Iterator,\n+    Node_Iterator,\n+    Cmp_Fn,\n+    Allocator\n+    >::operator\n+    () (node_iterator node_it, const_node_iterator end_nd_it) const\n+  {\n+    node_iterator l_child_it;\n+    size_type\n+      l_rank = (l_child_it == end_nd_it) ? : l_child_it.get_metadata ();\n+    node_iterator r_child_it = node_it.get_r_child ();\n+    size_type\n+      r_rank = (r_child_it == end_nd_it) ? : r_child_it.get_metadata ();\n+    const_cast\n+      < metadata_reference > (node_it.get_metadata ()) = l_rank + r_rank;\n+  }\n+  namespace\n+  {\n+    template < typename, typename, typename, bool > struct value_type_base;\n+    template\n+      <\n+      typename\n+      Key,\n+      typename\n+      Allocator\n+      > struct value_type_base <Key, null_mapped_type, Allocator, false >\n+    {\n+      typedef Key value_type;\n+      typedef\n+\ttypename\n+\tAllocator::template rebind < value_type >::other value_type_allocator;\n+      typedef typename value_type_allocator::pointer pointer;\n+      typedef typename value_type_allocator::const_pointer const_pointer;\n+      typedef typename value_type_allocator::reference reference;\n+      typedef typename value_type_allocator::const_reference const_reference;\n+    };\n+    template\n+      <\n+      typename\n+      Key,\n+      typename\n+      Mapped, typename Alloc, bool Store_Extra > struct vt_base_selector\n+    {\n+      typedef value_type_base < Key, Mapped, Alloc, Store_Extra > type;\n+    };\n+    template\n+      <\n+      typename\n+      Key,\n+      typename\n+      Mapped,\n+      typename\n+      Alloc,\n+      bool\n+      Store_Extra\n+      >\n+      struct\n+      types_traits:vt_base_selector < Key, Mapped, Alloc, Store_Extra >::type\n+    {};\n+    template < typename, class, class > struct dumconst_node_iterator;\n+    template\n+      <\n+      typename\n+      Key,\n+      typename\n+      Mapped,\n+      class,\n+      class\n+      Node_And_It_Traits, class Allocator > class bin_search_tree_no_data_\n+    {\n+    protected:\n+      typedef\n+\ttypename\n+\tAllocator::template\n+\trebind\n+\t< typename Node_And_It_Traits::node >::other::pointer node_pointer;\n+      typedef\n+\ttypename\n+\ttypes_traits\n+\t< Key, Mapped, Allocator, false >::const_reference const_reference;\n+      typedef typename Node_And_It_Traits::point_iterator point_iterator;\n+      typedef typename Node_And_It_Traits::node_update node_update;\n+      void rotate_right (node_pointer);\n+      template\n+\t<\n+\ttypename\n+\tNode_Update_ > void apply_update (node_pointer, Node_Update_ *);\n+    };\n+    template\n+      <\n+      typename\n+      Key,\n+      typename\n+      Mapped,\n+      class\n+      Cmp_Fn,\n+      class\n+      Node_And_It_Traits,\n+      class\n+      Allocator\n+      >\n+      void\n+      bin_search_tree_no_data_\n+      <\n+      Key,\n+      Mapped,\n+      Cmp_Fn, Node_And_It_Traits, Allocator >::rotate_right (node_pointer p_x)\n+    {\n+      node_pointer p_y = p_x->m_p_parent;\n+      p_y->m_p_right = p_x;\n+      apply_update (p_x, this);\n+      apply_update (p_x->m_p_parent, (node_update *) this);\n+    }\n+    template\n+      <\n+      typename\n+      Key,\n+      typename\n+      Mapped,\n+      class\n+      Cmp_Fn,\n+      class\n+      Node_And_It_Traits,\n+      class\n+      Allocator\n+      >\n+      template\n+      <\n+      typename\n+      Node_Update_\n+      >\n+      void\n+      bin_search_tree_no_data_\n+      <\n+      Key,\n+      Mapped,\n+      Cmp_Fn,\n+      Node_And_It_Traits,\n+      Allocator >::apply_update (node_pointer p_nd, Node_Update_ *)\n+    {\n+      node_update ()((p_nd), ((0)));\n+    }\n+  }\n+  namespace detail\n+  {\n+  template < typename Key, typename Mapped, typename Cmp_Fn, typename Node_And_It_Traits, typename Allocator > class rb_tree_no_data_:\n+    bin_search_tree_no_data_\n+      < Key, Mapped, Cmp_Fn, Node_And_It_Traits, Allocator >\n+    {\n+      typedef\n+\tbin_search_tree_no_data_\n+\t< Key, Mapped, Cmp_Fn, Node_And_It_Traits, Allocator > base_type;\n+      typedef typename base_type::node_pointer node_pointer;\n+    public:\n+      typedef typename base_type::const_reference const_reference;\n+      typedef typename base_type::point_iterator point_iterator;\n+      std::pair < point_iterator, bool > insert (const_reference);\n+      void insert_fixup (node_pointer);\n+    };\n+    template\n+      <\n+      typename\n+      Key,\n+      typename\n+      Mapped,\n+      typename\n+      Cmp_Fn,\n+      typename\n+      Node_And_It_Traits,\n+      typename\n+      Allocator\n+      >\n+      std::pair\n+      <\n+      typename\n+      rb_tree_no_data_\n+      <\n+      Key,\n+      Mapped,\n+      Cmp_Fn,\n+      Node_And_It_Traits,\n+      Allocator\n+      >::point_iterator,\n+      bool\n+      >\n+      rb_tree_no_data_\n+      <\n+      Key,\n+      Mapped,\n+      Cmp_Fn, Node_And_It_Traits, Allocator >::insert (const_reference)\n+    {\n+      std::pair < point_iterator, bool > ins_pair;\n+{\n+\tinsert_fixup (ins_pair.first.m_p_nd);\n+      }\n+    }\n+    template\n+      <\n+      typename\n+      Key,\n+      typename\n+      Mapped,\n+      typename\n+      Cmp_Fn,\n+      typename\n+      Node_And_It_Traits,\n+      typename\n+      Allocator\n+      >\n+      void\n+      rb_tree_no_data_\n+      <\n+      Key,\n+      Mapped,\n+      Cmp_Fn,\n+      Node_And_It_Traits, Allocator >::insert_fixup (node_pointer p_nd)\n+    {\n+{\n+{\n+{\n+\t    rotate_right (p_nd);\n+\t  }\n+\t}\n+      }\n+    }\n+    template\n+      <\n+      typename,\n+      typename, typename, typename, typename > struct container_base_dispatch;\n+    template\n+      <\n+      typename\n+      Key,\n+      typename\n+      Policy_Tl,\n+      typename\n+      Alloc\n+      >\n+      struct\n+      container_base_dispatch\n+      <Key, null_mapped_type, rb_tree_tag, Policy_Tl, Alloc >\n+    {\n+      typedef __gnu_cxx::typelist::at_index < Policy_Tl, 0 > at0;\n+      typedef typename at0::type at0t;\n+      typedef __gnu_cxx::typelist::at_index < Policy_Tl, 1 > at1;\n+      typedef typename at1::type at1t;\n+      typedef\n+\trb_tree_no_data_ < Key, null_mapped_type, at0t, at1t, Alloc > type;\n+    };\n+    template\n+      <\n+      typename\n+      Node_Pointer,\n+      typename,\n+      typename,\n+      typename,\n+      typename, typename, bool, class > class bin_search_tree_const_it_\n+    {\n+    public:\n+      Node_Pointer m_p_nd;\n+    };\n+    template\n+      <\n+      typename\n+      Node,\n+      class\n+      Const_Iterator,\n+      class Iterator, class Allocator > class bin_search_tree_const_node_it_\n+    {\n+      typedef\n+\ttypename\n+\tAllocator::template rebind < Node >::other::pointer node_pointer;\n+    public:\n+      typedef typename Node::metadata_type metadata_type;\n+      typedef\n+\ttypename\n+\tAllocator::template\n+\trebind\n+\t< metadata_type >::other::const_reference const_metadata_reference;\n+    bin_search_tree_const_node_it_ (node_pointer p_nd):\n+      m_p_nd ((p_nd))\n+      {}\n+      const_metadata_reference get_metadata ()\n+      {\n+\treturn (m_p_nd->get_metadata ());\n+      }\n+      bin_search_tree_const_node_it_ ()\n+      {}\n+      bin_search_tree_const_node_it_\n+\t< Node, Const_Iterator, Iterator, Allocator > get_r_child ()\n+      {\n+\treturn ((m_p_nd->m_p_right));\n+      }\n+      bool operator == (bin_search_tree_const_node_it_)\n+      {}\n+      node_pointer m_p_nd;\n+    };\n+    template\n+      <\n+      typename,\n+      typename,\n+      class,\n+      template\n+      <\n+      typename,\n+      class,\n+      class, class > class, class, class > struct bin_search_tree_traits;\n+    template\n+      <\n+      typename\n+      Key,\n+      class\n+      Cmp_Fn,\n+      template\n+      <\n+      typename,\n+      class,\n+      class,\n+      class\n+      >\n+      class\n+      Node_Update,\n+      class\n+      Node,\n+      class\n+      Allocator\n+      >\n+      struct\n+      bin_search_tree_traits\n+      <Key, null_mapped_type, Cmp_Fn, Node_Update, Node, Allocator >\n+    {\n+      typedef\n+\ttypes_traits < Key, null_mapped_type, Allocator, false > type_traits;\n+      typedef Node node;\n+      typedef\n+\tbin_search_tree_const_it_\n+\t<\n+\ttypename\n+\tAllocator::template\n+\trebind\n+\t<\n+\tnode\n+\t>::other::pointer,\n+\ttypename\n+\ttype_traits::value_type,\n+\ttypename\n+\ttype_traits::pointer,\n+\ttypename\n+\ttype_traits::const_pointer,\n+\ttypename\n+\ttype_traits::reference,\n+\ttypename\n+\ttype_traits::const_reference, true, Allocator > const_point_iterator;\n+      typedef const_point_iterator point_iterator;\n+      typedef\n+\tbin_search_tree_const_node_it_\n+\t<\n+\tNode,\n+\tconst_point_iterator, point_iterator, Allocator > const_node_iterator;\n+      typedef const_node_iterator node_iterator;\n+      typedef\n+\tNode_Update\n+\t< const_node_iterator, node_iterator, Cmp_Fn, Allocator > node_update;\n+    };\n+    template < typename Node_Update, bool > struct tree_metadata_helper\n+    {\n+      typedef typename Node_Update::metadata_type type;\n+    };\n+    template\n+      <\n+      typename\n+      Key,\n+      typename\n+      Data,\n+      class\n+      Cmp_Fn,\n+      template\n+      <\n+      typename,\n+      class,\n+      class,\n+      class\n+      >\n+      class Node_Update, class Allocator > struct tree_node_metadata_selector\n+    {\n+      typedef\n+\tdumconst_node_iterator < Key, Data, Allocator > dumconst_node_it;\n+      enum\n+      {\n+\tnull_update = is_same < Node_Update < dumconst_node_it,\n+\tdumconst_node_it,\n+\tCmp_Fn,\n+\tAllocator >,\n+\tnull_tree_node_update < dumconst_node_it,\n+\tdumconst_node_it,\n+\tCmp_Fn,\n+\tAllocator > >::value\n+      };\n+      typedef\n+\ttypename\n+\ttree_metadata_helper\n+\t<\n+\tNode_Update\n+\t<\n+\tdumconst_node_it,\n+\tdumconst_node_it, Cmp_Fn, Allocator >, null_update >::type type;\n+    };\n+    template\n+      <\n+      typename,\n+      typename,\n+      class,\n+      template\n+      <\n+      typename,\n+      class, class, class > class, class, class > struct tree_traits;\n+    template < typename Value_Type, class Metadata, class Allocator > struct rb_tree_node_\n+    {\n+      typedef Metadata metadata_type;\n+      typedef\n+\ttypename\n+\tAllocator::template\n+\trebind\n+\t<\n+\trb_tree_node_\n+\t< Value_Type, Metadata, Allocator > >::other::pointer node_pointer;\n+      typedef\n+\ttypename\n+\tAllocator::template\n+\trebind < metadata_type >::other::reference metadata_reference;\n+        metadata_reference get_metadata ()\n+      {\n+\treturn m_metadata;\n+      }\n+      node_pointer m_p_right;\n+      node_pointer m_p_parent;\n+      metadata_type m_metadata;\n+    };\n+    template\n+      <\n+      typename\n+      Key,\n+      typename\n+      Mapped,\n+      typename\n+      Cmp_Fn,\n+      template\n+      <\n+      typename,\n+      class,\n+      class,\n+      class\n+      >\n+      class\n+      Node_Update,\n+      typename\n+      Allocator\n+      >\n+      struct\n+      tree_traits\n+      <Key,\n+      Mapped,\n+      Cmp_Fn,\n+      Node_Update,\n+      rb_tree_tag,\n+      Allocator\n+      >:bin_search_tree_traits\n+      <\n+      Key,\n+      Mapped,\n+      Cmp_Fn,\n+      Node_Update,\n+      rb_tree_node_\n+      <\n+      typename\n+      types_traits\n+      <\n+      Key,\n+      Mapped,\n+      Allocator,\n+      false\n+      >::value_type,\n+      typename\n+      tree_node_metadata_selector\n+      <\n+      Key,\n+      Mapped, Cmp_Fn, Node_Update, Allocator >::type, Allocator >, Allocator >\n+    {};\n+  }\n+template < typename Key, typename Mapped, typename Tag, typename Policy_Tl, typename Allocator > class container_base:\n+  public\n+    detail::container_base_dispatch\n+    < Key, Mapped, Tag, Policy_Tl, Allocator >::type\n+  {};\n+template < typename Key, typename Mapped, typename Tag, typename, typename Policy_Tl, typename Allocator > class basic_tree:\n+  public\n+    container_base < Key, Mapped, Tag, Policy_Tl, Allocator >\n+  {};\n+  template\n+    <\n+    typename\n+    Key,\n+    typename\n+    Mapped,\n+    typename\n+    Cmp_Fn\n+    =\n+    std::less\n+    <\n+    Key\n+    >,\n+    typename\n+    Tag\n+    =\n+    rb_tree_tag,\n+    template\n+    <\n+    typename,\n+    typename,\n+    typename,\n+    typename\n+    >\n+    class\n+    Node_Update\n+    =\n+    null_tree_node_update,\n+    typename\n+    Allocator\n+    =\n+    std::allocator\n+    <\n+    char\n+    > >class\n+    tree:public\n+    basic_tree\n+    <\n+    Key,\n+    Mapped,\n+    Tag,\n+    detail::tree_traits\n+    <\n+    Key,\n+    Mapped,\n+    Cmp_Fn,\n+    Node_Update,\n+    Tag,\n+    Allocator\n+    >,\n+    typename\n+    __gnu_cxx::typelist::create2\n+    <\n+    Cmp_Fn,\n+    detail::tree_traits\n+    < Key, Mapped, Cmp_Fn, Node_Update, Tag, Allocator > >::type, Allocator >\n+  {};\n+}\n+using namespace std;\n+using namespace __gnu_pbds;\n+typedef\n+  tree\n+  <\n+  int,\n+  null_mapped_type,\n+  less < int >, rb_tree_tag, tree_order_statistics_node_update > set_t;\n+main ()\n+{\n+  set_t s;\n+  s.insert (12);\n+}"}, {"sha": "00ff8cc1ab5e64d3e77014c216dffa827ead9924", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ec87690545eefc5c1453b225c62f5adcbbe1f49/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ec87690545eefc5c1453b225c62f5adcbbe1f49/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=1ec87690545eefc5c1453b225c62f5adcbbe1f49", "patch": "@@ -4853,7 +4853,7 @@ execute_pre (bool do_fre)\n   if (!do_fre)\n     loop_optimizer_init (LOOPS_NORMAL);\n \n-  if (!run_scc_vn ())\n+  if (!run_scc_vn (do_fre ? VN_WALKREWRITE : VN_WALK))\n     {\n       if (!do_fre)\n \tloop_optimizer_finalize ();"}, {"sha": "9222cb5f583f9c2847f6a51897e941fb3a006525", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ec87690545eefc5c1453b225c62f5adcbbe1f49/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ec87690545eefc5c1453b225c62f5adcbbe1f49/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=1ec87690545eefc5c1453b225c62f5adcbbe1f49", "patch": "@@ -1244,6 +1244,7 @@ vn_reference_lookup_1 (vn_reference_t vr, vn_reference_t *vnresult)\n \n static tree *last_vuse_ptr;\n static vn_lookup_kind vn_walk_kind;\n+static vn_lookup_kind default_vn_walk_kind;\n \n /* Callback for walk_non_aliased_vuses.  Adjusts the vn_reference_t VR_\n    with the current VUSE and performs the expression lookup.  */\n@@ -2261,14 +2262,15 @@ visit_reference_op_load (tree lhs, tree op, gimple stmt)\n \n   last_vuse = gimple_vuse (stmt);\n   last_vuse_ptr = &last_vuse;\n-  result = vn_reference_lookup (op, gimple_vuse (stmt), VN_WALKREWRITE, NULL);\n+  result = vn_reference_lookup (op, gimple_vuse (stmt),\n+\t\t\t\tdefault_vn_walk_kind, NULL);\n   last_vuse_ptr = NULL;\n \n   /* If we have a VCE, try looking up its operand as it might be stored in\n      a different type.  */\n   if (!result && TREE_CODE (op) == VIEW_CONVERT_EXPR)\n     result = vn_reference_lookup (TREE_OPERAND (op, 0), gimple_vuse (stmt),\n-    \t\t\t\t  VN_WALKREWRITE, NULL);\n+    \t\t\t\t  default_vn_walk_kind, NULL);\n \n   /* We handle type-punning through unions by value-numbering based\n      on offset and size of the access.  Be prepared to handle a\n@@ -3463,15 +3465,18 @@ set_hashtable_value_ids (void)\n }\n \n /* Do SCCVN.  Returns true if it finished, false if we bailed out\n-   due to resource constraints.  */\n+   due to resource constraints.  DEFAULT_VN_WALK_KIND_ specifies\n+   how we use the alias oracle walking during the VN process.  */\n \n bool\n-run_scc_vn (void)\n+run_scc_vn (vn_lookup_kind default_vn_walk_kind_)\n {\n   size_t i;\n   tree param;\n   bool changed = true;\n \n+  default_vn_walk_kind = default_vn_walk_kind_;\n+\n   init_scc_vn ();\n   current_info = valid_info;\n "}, {"sha": "bf99702e43ad0ab90f4d8e0f5bea3b932c53e5ca", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ec87690545eefc5c1453b225c62f5adcbbe1f49/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ec87690545eefc5c1453b225c62f5adcbbe1f49/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=1ec87690545eefc5c1453b225c62f5adcbbe1f49", "patch": "@@ -165,11 +165,13 @@ typedef struct vn_ssa_aux\n   unsigned needs_insertion : 1;\n } *vn_ssa_aux_t;\n \n+typedef enum { VN_NOWALK, VN_WALK, VN_WALKREWRITE } vn_lookup_kind;\n+\n /* Return the value numbering info for an SSA_NAME.  */\n extern vn_ssa_aux_t VN_INFO (tree);\n extern vn_ssa_aux_t VN_INFO_GET (tree);\n tree vn_get_expr_for (tree);\n-bool run_scc_vn (void);\n+bool run_scc_vn (vn_lookup_kind);\n void free_scc_vn (void);\n tree vn_nary_op_lookup (tree, vn_nary_op_t *);\n tree vn_nary_op_lookup_stmt (gimple, vn_nary_op_t *);\n@@ -187,7 +189,6 @@ void copy_reference_ops_from_ref (tree, VEC(vn_reference_op_s, heap) **);\n void copy_reference_ops_from_call (gimple, VEC(vn_reference_op_s, heap) **);\n bool ao_ref_init_from_vn_reference (ao_ref *, alias_set_type, tree,\n \t\t\t\t    VEC (vn_reference_op_s, heap) *);\n-typedef enum { VN_NOWALK, VN_WALK, VN_WALKREWRITE } vn_lookup_kind;\n tree vn_reference_lookup_pieces (tree, alias_set_type, tree,\n \t\t\t\t VEC (vn_reference_op_s, heap) *,\n \t\t\t\t vn_reference_t *, vn_lookup_kind);"}]}