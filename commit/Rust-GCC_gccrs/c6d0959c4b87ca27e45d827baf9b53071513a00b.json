{"sha": "c6d0959c4b87ca27e45d827baf9b53071513a00b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZkMDk1OWM0Yjg3Y2EyN2U0NWQ4MjdiYWY5YjUzMDcxNTEzYTAwYg==", "commit": {"author": {"name": "Ranjit Mathew", "email": "rmathew@gcc.gnu.org", "date": "2006-07-07T15:40:55Z"}, "committer": {"name": "Ranjit Mathew", "email": "rmathew@gcc.gnu.org", "date": "2006-07-07T15:40:55Z"}, "message": "backtrace.h (fallback_backtrace): Scan for a function's prologue to determine its beginning.\n\n\t* sysdep/i386/backtrace.h (fallback_backtrace): Scan for a function's\n\tprologue to determine its beginning.  Stop unwinding when we reach\n\tJvRunMain().\n\nFrom-SVN: r115261", "tree": {"sha": "cd5da0d97f30d4e4367bc650c3e8d8425bb458b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd5da0d97f30d4e4367bc650c3e8d8425bb458b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6d0959c4b87ca27e45d827baf9b53071513a00b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6d0959c4b87ca27e45d827baf9b53071513a00b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6d0959c4b87ca27e45d827baf9b53071513a00b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6d0959c4b87ca27e45d827baf9b53071513a00b/comments", "author": null, "committer": null, "parents": [{"sha": "11de7ef20ea8ef75edf512c53e810c62762231be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11de7ef20ea8ef75edf512c53e810c62762231be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11de7ef20ea8ef75edf512c53e810c62762231be"}], "stats": {"total": 64, "additions": 42, "deletions": 22}, "files": [{"sha": "929da9468c387d06e18cba8502327691423ae822", "filename": "libjava/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d0959c4b87ca27e45d827baf9b53071513a00b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d0959c4b87ca27e45d827baf9b53071513a00b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=c6d0959c4b87ca27e45d827baf9b53071513a00b", "patch": "@@ -1,3 +1,9 @@\n+2006-07-07  Ranjit Mathew  <rmathew@gcc.gnu.org>\n+\n+\t* sysdep/i386/backtrace.h (fallback_backtrace): Scan for a function's\n+\tprologue to determine its beginning.  Stop unwinding when we reach\n+\tJvRunMain().\n+\n 2006-07-07  Gary Benson  <gbenson@redhat.com>\n \n \t* Makefile.am (BOOT_CLASS_PATH_DIR): Only contain libgcj.jar."}, {"sha": "3b951634efb3483ca40dbc4668ae8249bbd27112", "filename": "libjava/sysdep/i386/backtrace.h", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d0959c4b87ca27e45d827baf9b53071513a00b/libjava%2Fsysdep%2Fi386%2Fbacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d0959c4b87ca27e45d827baf9b53071513a00b/libjava%2Fsysdep%2Fi386%2Fbacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsysdep%2Fi386%2Fbacktrace.h?ref=c6d0959c4b87ca27e45d827baf9b53071513a00b", "patch": "@@ -20,45 +20,59 @@ details.  */\n void\n fallback_backtrace (_Jv_UnwindState *state)\n {\n-  register void *_ebp __asm__ (\"ebp\");\n-  register void *_esp __asm__ (\"esp\");\n-  _Jv_uintptr_t *rfp;\n+  register _Jv_uintptr_t *_ebp __asm__ (\"ebp\");\n+  register _Jv_uintptr_t _esp __asm__ (\"esp\");\n+  _Jv_uintptr_t rfp;\n \n   int i = state->pos;\n-  for (rfp = *(_Jv_uintptr_t **)_ebp;\n+  for (rfp = *_ebp;\n        rfp && i < state->length;\n-       rfp = *(_Jv_uintptr_t **)rfp)\n+       rfp = *(_Jv_uintptr_t *)rfp)\n     {\n       /* Sanity checks to eliminate dubious-looking frame pointer chains.\n          The frame pointer should be a 32-bit word-aligned stack address.\n          Since the stack grows downwards on x86, the frame pointer must have\n          a value greater than the current value of the stack pointer, it\n          should not be below the supposed next frame pointer and it should\n          not be too far off from the supposed next frame pointer.  */\n-      int diff = *rfp - (_Jv_uintptr_t)rfp;\n-      if (((_Jv_uintptr_t)rfp & 0x00000003) != 0 || (void*)rfp < _esp\n+      int diff = *(_Jv_uintptr_t *)rfp - rfp;\n+      if ((rfp & 0x00000003) != 0 || rfp < _esp\n           || diff > 4 * 1024 || diff < 0)\n         break;\n \n-      /* Use the return address in the calling function stored just before\n-         the current frame pointer to locate the address operand part of the\n-         \"CALL <XYZ>\" instruction in the calling function that called this\n-         function.  */\n-      void *ip = (void*)(rfp[1] - 4);\n+      /* Get the return address in the calling function.  This is stored on\n+         the stack just before the value of the old frame pointer.  */\n+      _Jv_uintptr_t ret_addr\n+        = *(_Jv_uintptr_t *)(rfp + sizeof (_Jv_uintptr_t));\n \n-      /* Verify that the instruction at this position is a \"CALL <XYZ>\" and\n-         use its operand to determine the starting address of the function\n-         that this function had called.  0xE8 is the opcode for this CALL\n-         instruction variant.  */\n-      if (*(unsigned char *)((_Jv_uintptr_t)ip - 1) == 0xE8 && i > state->pos\n-          && state->frames[i-1].type == frame_native)\n+      state->frames[i].type = frame_native;\n+      state->frames[i].ip = (void *)(ret_addr - 1);\n+      state->frames[i].start_ip = NULL;\n+\n+      /* Try to locate a \"pushl %ebp; movl %esp, %ebp\" function prologue\n+         by scanning backwards at even addresses below the return address.\n+         This instruction sequence is encoded as 0x55 0x89 0xE5.  We give up\n+         if we do not find this sequence even after scanning 1024K of memory.\n+         FIXME: This is not robust and will probably give us false positives,\n+         but this is about the best we can do if we do not have DWARF-2 unwind\n+         information based exception handling.  */\n+      _Jv_uintptr_t scan_addr = (ret_addr & 0xFFFFFFFE) - 2;\n+      _Jv_uintptr_t limit_addr\n+        = (scan_addr > 1024 * 1024) ? (scan_addr - 1024 * 1024) : 2;\n+      for ( ; scan_addr >= limit_addr; scan_addr -= 2)\n         {\n-          state->frames[i-1].start_ip\n-            = (void *)((_Jv_uintptr_t)ip + 4 + *(_Jv_uintptr_t *)ip);\n+          unsigned char *scan_bytes = (unsigned char *)scan_addr;\n+          if (scan_bytes[0] == 0x55 && scan_bytes[1] == 0x89\n+              && scan_bytes[2] == 0xE5)\n+            {\n+              state->frames[i].start_ip = (void *)scan_addr;\n+              break;\n+            }\n         }\n \n-      state->frames[i].type = frame_native;\n-      state->frames[i].ip = ip;\n+      /* No need to unwind beyond JvRunMain().  */\n+      if (state->frames[i].start_ip == (void *)JvRunMain)\n+        break;\n \n       i++;\n     }"}]}