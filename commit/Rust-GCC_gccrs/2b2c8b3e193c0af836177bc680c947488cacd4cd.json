{"sha": "2b2c8b3e193c0af836177bc680c947488cacd4cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIyYzhiM2UxOTNjMGFmODM2MTc3YmM2ODBjOTQ3NDg4Y2FjZDRjZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-07-09T19:32:53Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-07-09T19:32:53Z"}, "message": "flow.c (redirect_edge_and_branch_force): New.\n\n\t* flow.c (redirect_edge_and_branch_force): New.\n\t(can_fallthru): Ensure that basic blocks are succeeding.\n\t(try_optimize_cfg): Do not delete basic block if it is the last one.\n\n\t* flow.c (try_redirect_by_replacing_jump): Do not remove\n\tjumps with side effects, unlink chain on fallthru edge;\n\tset block for new jump instruction; avoid basic block to\n\tover by line number note.\n\n\t* flow.c (try_simplify_condjump): Verify that the condjump\n\tis not always falling trought.\n\n\tRe-install patch:\n\t* flow.c (try_redirect_by_replacing_jump): Remove cc0 setter.\n\n\t* flow.c (forwarder_block_p): Fix for fallthru blocks.\n\t(try_redirect_by_replacing_jump): Update properly the count\n\tand frequency information.\n\nFrom-SVN: r43867", "tree": {"sha": "94ab6501dc177da0dcb3f93e499ee8d453d64393", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94ab6501dc177da0dcb3f93e499ee8d453d64393"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b2c8b3e193c0af836177bc680c947488cacd4cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b2c8b3e193c0af836177bc680c947488cacd4cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b2c8b3e193c0af836177bc680c947488cacd4cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b2c8b3e193c0af836177bc680c947488cacd4cd/comments", "author": null, "committer": null, "parents": [{"sha": "823e3574e6af2c399d12390ee99cb4f17c1297df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/823e3574e6af2c399d12390ee99cb4f17c1297df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/823e3574e6af2c399d12390ee99cb4f17c1297df"}], "stats": {"total": 208, "additions": 187, "deletions": 21}, "files": [{"sha": "807f1096d4d7e2cd0a683ba2dbda0ea96566d535", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b2c8b3e193c0af836177bc680c947488cacd4cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b2c8b3e193c0af836177bc680c947488cacd4cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b2c8b3e193c0af836177bc680c947488cacd4cd", "patch": "@@ -1,3 +1,24 @@\n+Mon Jul  9 17:23:10 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* flow.c (redirect_edge_and_branch_force): New.\n+\t(can_fallthru): Ensure that basic blocks are succeeding.\n+\t(try_optimize_cfg): Do not delete basic block if it is the last one.\n+\n+\t* flow.c (try_redirect_by_replacing_jump): Do not remove\n+\tjumps with side effects, unlink chain on fallthru edge;\n+\tset block for new jump instruction; avoid basic block to\n+\tover by line number note.\n+\n+\t* flow.c (try_simplify_condjump): Verify that the condjump\n+\tis not always falling trought.\n+\n+\tRe-install patch:\n+\t* flow.c (try_redirect_by_replacing_jump): Remove cc0 setter.\n+\n+\t* flow.c (forwarder_block_p): Fix for fallthru blocks.\n+\t(try_redirect_by_replacing_jump): Update properly the count\n+\tand frequency information.\n+\n Mon Jul  9 06:41:07 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* emit-rtl.c (adjust_address, adjust_address_nv): Handle an"}, {"sha": "fba78dda8f13965fb69b2dc456ecacf6ed137c65", "filename": "gcc/flow.c", "status": "modified", "additions": 166, "deletions": 21, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b2c8b3e193c0af836177bc680c947488cacd4cd/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b2c8b3e193c0af836177bc680c947488cacd4cd/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=2b2c8b3e193c0af836177bc680c947488cacd4cd", "patch": "@@ -476,6 +476,7 @@ static int flow_loops_level_compute\tPARAMS ((struct loops *));\n static void allocate_bb_life_data\tPARAMS ((void));\n static void find_sub_basic_blocks\tPARAMS ((basic_block));\n static bool redirect_edge_and_branch \tPARAMS ((edge, basic_block));\n+static basic_block redirect_edge_and_branch_force PARAMS ((edge, basic_block));\n static rtx block_label\t\t\tPARAMS ((basic_block));\n \f\n /* Find basic blocks of the current function.\n@@ -1619,18 +1620,19 @@ static bool\n forwarder_block_p (bb)\n      basic_block bb;\n {\n-  rtx insn;\n+  rtx insn = bb->head;\n   if (bb == EXIT_BLOCK_PTR || bb == ENTRY_BLOCK_PTR\n       || !bb->succ || bb->succ->succ_next)\n     return false;\n \n-  insn = next_active_insn (bb->head);\n-  if (!insn)\n-    return false;\n-  if (GET_CODE (insn) == CODE_LABEL\n-      || (GET_CODE (insn) == JUMP_INSN && onlyjump_p (insn)))\n-    return true;\n-  return false;\n+  while (insn != bb->end)\n+    {\n+      if (active_insn_p (insn))\n+\treturn false;\n+      insn = NEXT_INSN (insn);\n+    }\n+  return (!active_insn_p (insn)\n+\t  || (GET_CODE (insn) == JUMP_INSN && onlyjump_p (insn)));\n }\n \n /* Return nonzero if we can reach target from src by falling trought.  */\n@@ -1641,7 +1643,7 @@ can_fallthru (src, target)\n   rtx insn = src->end;\n   rtx insn2 = target->head;\n \n-  if (!active_insn_p (insn2))\n+  if (src->index + 1 == target->index && !active_insn_p (insn2))\n     insn2 = next_active_insn (insn2);\n   /* ??? Later we may add code to move jump tables offline.  */\n   return next_active_insn (insn) == insn2;\n@@ -1663,13 +1665,12 @@ try_redirect_by_replacing_jump (e, target)\n   edge tmp;\n   rtx set;\n   int fallthru = 0;\n-  rtx barrier;\n \n   /* Verify that all targets will be TARGET.  */\n   for (tmp = src->succ; tmp; tmp = tmp->succ_next)\n     if (tmp->dest != target && tmp != e)\n       break;\n-  if (tmp || GET_CODE (insn) != JUMP_INSN)\n+  if (tmp || !onlyjump_p (insn))\n     return false;\n \n   /* Avoid removing branch with side effects.  */\n@@ -1685,7 +1686,11 @@ try_redirect_by_replacing_jump (e, target)\n \tfprintf (rtl_dump_file, \"Removing jump %i.\\n\", INSN_UID (insn));\n       flow_delete_insn (insn);\n       fallthru = 1;\n-      insn = src->end;\n+\n+      /* Selectivly unlink whole insn chain.  */\n+      if (src->end != PREV_INSN (target->head))\n+\tflow_delete_insn_chain (NEXT_INSN (src->end),\n+\t\t\t\tPREV_INSN (target->head));\n     }\n   /* If this already is simplejump, redirect it.  */\n   else if (simplejump_p (insn))\n@@ -1701,16 +1706,21 @@ try_redirect_by_replacing_jump (e, target)\n   else\n     {\n       rtx target_label = block_label (target);\n+      rtx barrier;\n \n       src->end = PREV_INSN (insn);\n       src->end = emit_jump_insn_after (gen_jump (target_label), src->end);\n       JUMP_LABEL (src->end) = target_label;\n       LABEL_NUSES (target_label)++;\n+      if (basic_block_for_insn)\n+\tset_block_for_new_insns (src->end, src);\n       if (rtl_dump_file)\n \tfprintf (rtl_dump_file, \"Replacing insn %i by jump %i\\n\",\n \t\t INSN_UID (insn), INSN_UID (src->end));\n       flow_delete_insn (insn);\n-      insn = src->end;\n+      barrier = next_nonnote_insn (src->end);\n+      if (!barrier || GET_CODE (barrier) != BARRIER)\n+\temit_barrier_after (src->end);\n     }\n \n   /* Keep only one edge out and set proper flags.  */\n@@ -1721,13 +1731,32 @@ try_redirect_by_replacing_jump (e, target)\n     e->flags = EDGE_FALLTHRU;\n   else\n     e->flags = 0;\n+  e->probability = REG_BR_PROB_BASE;\n+  e->count = src->count;\n \n-  /* Fixup barriers.  */\n-  barrier = next_nonnote_insn (insn);\n-  if (fallthru && GET_CODE (barrier) == BARRIER)\n-    flow_delete_insn (barrier);\n-  else if (!fallthru && GET_CODE (barrier) != BARRIER)\n-    emit_barrier_after (insn);\n+  /* In case we've zapped an conditional jump, we need to kill the cc0\n+     setter too if available.  */\n+#ifdef HAVE_cc0\n+  insn = src->end;\n+  if (GET_CODE (insn) == JUMP_INSN)\n+    insn = prev_nonnote_insn (insn);\n+  if (sets_cc0_p (insn))\n+    {\n+      if (insn == src->end)\n+\tsrc->end = PREV_INSN (insn);\n+      flow_delete_insn (insn);\n+    }\n+#endif\n+\n+  /* We don't want a block to end on a line-number note since that has\n+     the potential of changing the code between -g and not -g.  */\n+  while (GET_CODE (e->src->end) == NOTE\n+\t && NOTE_LINE_NUMBER (e->src->end) >= 0)\n+    {\n+      rtx prev = PREV_INSN (e->src->end);\n+      flow_delete_insn (e->src->end);\n+      e->src->end = prev;\n+    }\n \n   if (e->dest != target)\n     redirect_edge_succ (e, target);\n@@ -1788,7 +1817,7 @@ redirect_edge_and_branch (e, target)\n       for (j = GET_NUM_ELEM (vec) - 1; j >= 0; --j)\n \tif (XEXP (RTVEC_ELT (vec, j), 0) == old_label)\n \t  {\n-\t    RTVEC_ELT (vec, j) = gen_rtx_LABEL_REF (VOIDmode, new_label);\n+\t    RTVEC_ELT (vec, j) = gen_rtx_LABEL_REF (Pmode, new_label);\n \t    --LABEL_NUSES (old_label);\n \t    ++LABEL_NUSES (new_label);\n \t  }\n@@ -1837,6 +1866,8 @@ redirect_edge_and_branch (e, target)\n       if (s)\n \t{\n \t  s->flags |= e->flags;\n+\t  s->probability += e->probability;\n+\t  s->count += e->count;\n \t  remove_edge (e);\n \t}\n       else\n@@ -1845,6 +1876,117 @@ redirect_edge_and_branch (e, target)\n   return true;\n }\n \n+/* Redirect edge even at the expense of creating new jump insn or\n+   basic block.  Return new basic block if created, NULL otherwise.\n+   Abort if converison is impossible.  */\n+static basic_block\n+redirect_edge_and_branch_force (e, target)\n+     edge e;\n+     basic_block target;\n+{\n+  basic_block new_bb;\n+  edge new_edge;\n+  rtx label;\n+  rtx bb_note;\n+  int i, j;\n+\n+  if (redirect_edge_and_branch (e, target))\n+    return NULL;\n+  if (e->dest == target)\n+    return NULL;\n+  if (e->flags & EDGE_ABNORMAL)\n+    abort ();\n+  if (!(e->flags & EDGE_FALLTHRU))\n+    abort ();\n+\n+  e->flags &= ~EDGE_FALLTHRU;\n+  label = block_label (target);\n+  /* Case of the fallthru block.  */\n+  if (!e->src->succ->succ_next)\n+    {\n+      e->src->end = emit_jump_insn_after (gen_jump (label), e->src->end);\n+      JUMP_LABEL (e->src->end) = label;\n+      LABEL_NUSES (label)++;\n+      if (basic_block_for_insn)\n+\tset_block_for_insn (e->src->end, e->src);\n+      emit_barrier_after (e->src->end);\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file,\n+\t\t \"Emitting jump insn %i to redirect edge %i->%i to %i\\n\",\n+\t\t INSN_UID (e->src->end), e->src->index, e->dest->index,\n+\t\t target->index);\n+      redirect_edge_succ (e, target);\n+      return NULL;\n+    }\n+  /* Redirecting fallthru edge of the conditional needs extra work.  */\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file,\n+\t     \"Emitting jump insn %i in new BB to redirect edge %i->%i to %i\\n\",\n+\t     INSN_UID (e->src->end), e->src->index, e->dest->index,\n+\t     target->index);\n+\n+  /* Create the new structures.  */\n+  new_bb = (basic_block) obstack_alloc (&flow_obstack, sizeof (*new_bb));\n+  new_edge = (edge) xcalloc (1, sizeof (*new_edge));\n+  n_edges++;\n+\n+  memset (new_bb, 0, sizeof (*new_bb));\n+\n+  new_bb->end = new_bb->head = e->src->end;\n+  new_bb->succ = NULL;\n+  new_bb->pred = new_edge;\n+  new_bb->count = e->count;\n+  new_bb->frequency = e->probability * e->src->frequency / REG_BR_PROB_BASE;\n+  new_bb->loop_depth = e->dest->loop_depth;\n+\n+  new_edge->flags = EDGE_FALLTHRU;\n+  new_edge->probability = e->probability;\n+  new_edge->count = e->count;\n+\n+  /* Wire edge in.  */\n+  new_edge->src = e->src;\n+  new_edge->dest = new_bb;\n+  new_edge->succ_next = e->src->succ;\n+  e->src->succ = new_edge;\n+  new_edge->pred_next = NULL;\n+\n+  /* Redirect old edge.  */\n+  redirect_edge_succ (e, target);\n+  redirect_edge_pred (e, new_bb);\n+  e->probability = REG_BR_PROB_BASE;\n+\n+  /* Place the new block just after the block being split.  */\n+  VARRAY_GROW (basic_block_info, ++n_basic_blocks);\n+\n+  /* Some parts of the compiler expect blocks to be number in\n+     sequential order so insert the new block immediately after the\n+     block being split..  */\n+  j = new_edge->src->index;\n+  for (i = n_basic_blocks - 1; i > j + 1; --i)\n+    {\n+      basic_block tmp = BASIC_BLOCK (i - 1);\n+      BASIC_BLOCK (i) = tmp;\n+      tmp->index = i;\n+    }\n+\n+  BASIC_BLOCK (i) = new_bb;\n+  new_bb->index = i;\n+\n+  /* Create the basic block note.  */\n+  bb_note = emit_note_after (NOTE_INSN_BASIC_BLOCK, new_bb->head);\n+  NOTE_BASIC_BLOCK (bb_note) = new_bb;\n+  new_bb->head = bb_note;\n+\n+  new_bb->end = emit_jump_insn_after (gen_jump (label), new_bb->head);\n+  JUMP_LABEL (new_bb->end) = label;\n+  LABEL_NUSES (label)++;\n+  if (basic_block_for_insn)\n+    set_block_for_insn (new_bb->end, new_bb);\n+  emit_barrier_after (new_bb->end);\n+  return new_bb;\n+}\n+\n /* Split a (typically critical) edge.  Return the new block.\n    Abort on abnormal edges.\n \n@@ -2874,7 +3016,9 @@ try_simplify_condjump (src)\n   rtx insn = src->end;\n   edge branch, fallthru;\n \n-  if (!any_condjump_p (insn))\n+  /* Verify that there are exactly two successors.  */\n+  if (!src->succ || !src->succ->succ_next || src->succ->succ_next->succ_next\n+      || !any_condjump_p (insn))\n     return false;\n \n   fallthru = FALLTHRU_EDGE (src);\n@@ -3007,6 +3151,7 @@ try_optimize_cfg ()\n \t  /* The fallthru forwarder block can be deleted.  */\n \t  if (b->pred->pred_next == NULL\n \t      && forwarder_block_p (b)\n+\t      && n_basic_blocks > 1\n \t      && (b->pred->flags & EDGE_FALLTHRU)\n \t      && (b->succ->flags & EDGE_FALLTHRU))\n \t    {"}]}