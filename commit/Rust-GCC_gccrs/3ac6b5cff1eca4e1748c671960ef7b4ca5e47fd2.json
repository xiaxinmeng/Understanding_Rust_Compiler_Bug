{"sha": "3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FjNmI1Y2ZmMWVjYTRlMTc0OGM2NzE5NjBlZjdiNGNhNWU0N2ZkMg==", "commit": {"author": {"name": "Lewis Hyatt", "email": "lhyatt@gmail.com", "date": "2021-08-24T23:30:44Z"}, "committer": {"name": "Lewis Hyatt", "email": "lhyatt@gmail.com", "date": "2021-08-25T15:15:28Z"}, "message": "diagnostics: Support for -finput-charset [PR93067]\n\nAdds the logic to handle -finput-charset in layout_get_source_line(), so that\nsource lines are converted from their input encodings prior to being output by\ndiagnostics machinery. Also adds the ability to strip a UTF-8 BOM similarly.\n\ngcc/c-family/ChangeLog:\n\n\tPR other/93067\n\t* c-opts.c (c_common_input_charset_cb): New function.\n\t(c_common_post_options): Call new function\n\tdiagnostic_initialize_input_context().\n\ngcc/d/ChangeLog:\n\n\tPR other/93067\n\t* d-lang.cc (d_input_charset_callback): New function.\n\t(d_init): Call new function\n\tdiagnostic_initialize_input_context().\n\ngcc/fortran/ChangeLog:\n\n\tPR other/93067\n\t* cpp.c (gfc_cpp_post_options): Call new function\n\tdiagnostic_initialize_input_context().\n\ngcc/ChangeLog:\n\n\tPR other/93067\n\t* coretypes.h (typedef diagnostic_input_charset_callback): Declare.\n\t* diagnostic.c (diagnostic_initialize_input_context): New function.\n\t* diagnostic.h (diagnostic_initialize_input_context): Declare.\n\t* input.c (default_charset_callback): New function.\n\t(file_cache::initialize_input_context): New function.\n\t(file_cache_slot::create): Added ability to convert the input\n\taccording to the input context.\n\t(file_cache::file_cache): Initialize the new input context.\n\t(class file_cache_slot): Added new m_alloc_offset member.\n\t(file_cache_slot::file_cache_slot): Initialize the new member.\n\t(file_cache_slot::~file_cache_slot): Handle potentially offset buffer.\n\t(file_cache_slot::maybe_grow): Likewise.\n\t(file_cache_slot::needs_read_p): Handle NULL fp, which is now possible.\n\t(file_cache_slot::get_next_line): Likewise.\n\t* input.h (class file_cache): Added input context member.\n\nlibcpp/ChangeLog:\n\n\tPR other/93067\n\t* charset.c (init_iconv_desc): Adapt to permit PFILE argument to\n\tbe NULL.\n\t(_cpp_convert_input): Likewise. Also move UTF-8 BOM logic to...\n\t(cpp_check_utf8_bom): ...here.  New function.\n\t(cpp_input_conversion_is_trivial): New function.\n\t* files.c (read_file_guts): Allow PFILE argument to be NULL.  Add\n\tINPUT_CHARSET argument as an alternate source of this information.\n\t(read_file): Pass the new argument to read_file_guts.\n\t(cpp_get_converted_source): New function.\n\t* include/cpplib.h (struct cpp_converted_source): Declare.\n\t(cpp_get_converted_source): Declare.\n\t(cpp_input_conversion_is_trivial): Declare.\n\t(cpp_check_utf8_bom): Declare.\n\ngcc/testsuite/ChangeLog:\n\n\tPR other/93067\n\t* gcc.dg/diagnostic-input-charset-1.c: New test.\n\t* gcc.dg/diagnostic-input-utf8-bom.c: New test.", "tree": {"sha": "688dfb2b2708df32fd2e6b548061eea352e79cea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/688dfb2b2708df32fd2e6b548061eea352e79cea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/comments", "author": null, "committer": null, "parents": [{"sha": "43a5d46feabd93ba78983919234f05f5fc9a0982", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43a5d46feabd93ba78983919234f05f5fc9a0982", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43a5d46feabd93ba78983919234f05f5fc9a0982"}], "stats": {"total": 393, "additions": 335, "deletions": 58}, "files": [{"sha": "fdde082158b3f97038b3548c916a8f4a6c2b7d7c", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2", "patch": "@@ -188,6 +188,14 @@ c_common_diagnostics_set_defaults (diagnostic_context *context)\n   context->opt_permissive = OPT_fpermissive;\n }\n \n+/* Input charset configuration for diagnostics.  */\n+static const char *\n+c_common_input_charset_cb (const char * /*filename*/)\n+{\n+  const char *cs = cpp_opts->input_charset;\n+  return cpp_input_conversion_is_trivial (cs) ? nullptr : cs;\n+}\n+\n /* Whether options from all C-family languages should be accepted\n    quietly.  */\n static bool accept_all_c_family_options = false;\n@@ -1136,6 +1144,11 @@ c_common_post_options (const char **pfilename)\n   cpp_post_options (parse_in);\n   init_global_opts_from_cpp (&global_options, cpp_get_options (parse_in));\n \n+  /* Let diagnostics infrastructure know how to convert input files the same\n+     way libcpp will do it, namely using the configured input charset and\n+     skipping a UTF-8 BOM if present.  */\n+  diagnostic_initialize_input_context (global_dc,\n+\t\t\t\t       c_common_input_charset_cb, true);\n   input_location = UNKNOWN_LOCATION;\n \n   *pfilename = this_input_filename"}, {"sha": "726fcaddda2a6199781d2cb2f1fb6acf7807f38e", "filename": "gcc/coretypes.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2", "patch": "@@ -154,6 +154,7 @@ struct cl_option_handlers;\n struct diagnostic_context;\n class pretty_printer;\n class diagnostic_event_id_t;\n+typedef const char * (*diagnostic_input_charset_callback)(const char *);\n \n template<typename T> struct array_traits;\n "}, {"sha": "fa29a46ab1ebf3b514e8a854a2e8475d7c712f8d", "filename": "gcc/d/d-lang.cc", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/gcc%2Fd%2Fd-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/gcc%2Fd%2Fd-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-lang.cc?ref=3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2", "patch": "@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"output.h\"\n #include \"print-tree.h\"\n #include \"debug.h\"\n+#include \"input.h\"\n \n #include \"d-tree.h\"\n #include \"id.h\"\n@@ -362,6 +363,19 @@ d_option_lang_mask (void)\n   return CL_D;\n }\n \n+/* Implements input charset and BOM skipping configuration for\n+   diagnostics.  */\n+static const char *d_input_charset_callback (const char * /*filename*/)\n+{\n+  /* TODO: The input charset is automatically determined by code in\n+     dmd/dmodule.c based on the contents of the file.  If this detection\n+     logic were factored out and could be reused here, then we would be able\n+     to return UTF-16 or UTF-32 as needed here.  For now, we return always\n+     NULL, which means no conversion is necessary, i.e. the input is assumed\n+     to be UTF-8 when diagnostics read this file.  */\n+  return nullptr;\n+}\n+\n /* Implements the lang_hooks.init routine for language D.  */\n \n static bool\n@@ -373,6 +387,11 @@ d_init (void)\n   Expression::_init ();\n   Objc::_init ();\n \n+  /* Diagnostics input init, to enable BOM skipping and\n+     input charset conversion.  */\n+  diagnostic_initialize_input_context (global_dc,\n+\t\t\t\t       d_input_charset_callback, true);\n+\n   /* Back-end init.  */\n   global_binding_level = ggc_cleared_alloc <binding_level> ();\n   current_binding_level = global_binding_level;"}, {"sha": "b3afbeae648844a872f5773915f6227e5a1f5725", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2", "patch": "@@ -293,6 +293,17 @@ diagnostic_urls_init (diagnostic_context *context, int value /*= -1 */)\n     = determine_url_format ((diagnostic_url_rule_t) value);\n }\n \n+/* Create the file_cache, if not already created, and tell it how to\n+   translate files on input.  */\n+void diagnostic_initialize_input_context (diagnostic_context *context,\n+\t\t\t\t\t  diagnostic_input_charset_callback ccb,\n+\t\t\t\t\t  bool should_skip_bom)\n+{\n+  if (!context->m_file_cache)\n+    context->m_file_cache = new file_cache;\n+  context->m_file_cache->initialize_input_context (ccb, should_skip_bom);\n+}\n+\n /* Do any cleaning up required after the last diagnostic is emitted.  */\n \n void"}, {"sha": "f90d20a4f5ec751e7dd769ed554cee62bd1321dd", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2", "patch": "@@ -446,6 +446,25 @@ extern void diagnostic_show_locus (diagnostic_context *,\n \t\t\t\t   diagnostic_t diagnostic_kind);\n extern void diagnostic_show_any_path (diagnostic_context *, diagnostic_info *);\n \n+/* Because we read source files a second time after the frontend did it the\n+   first time, we need to know how the frontend handled things like character\n+   set conversion and UTF-8 BOM stripping, in order to make everything\n+   consistent.  This function needs to be called by each frontend that requires\n+   non-default behavior, to inform the diagnostics infrastructure how input is\n+   to be processed.  The default behavior is to do no conversion and not to\n+   strip a UTF-8 BOM.\n+\n+   The callback should return the input charset to be used to convert the given\n+   file's contents to UTF-8, or it should return NULL if no conversion is needed\n+   for this file.  SHOULD_SKIP_BOM only applies in case no conversion was\n+   performed, and if true, it will cause a UTF-8 BOM to be skipped at the\n+   beginning of the file.  (In case a conversion was performed, the BOM is\n+   rather skipped as part of the conversion process.)  */\n+\n+void diagnostic_initialize_input_context (diagnostic_context *context,\n+\t\t\t\t\t  diagnostic_input_charset_callback ccb,\n+\t\t\t\t\t  bool should_skip_bom);\n+\n /* Force diagnostics controlled by OPTIDX to be kind KIND.  */\n extern diagnostic_t diagnostic_classify_diagnostic (diagnostic_context *,\n \t\t\t\t\t\t    int /* optidx */,"}, {"sha": "83c4517acdbb3ec1413838070be0bc580ec0bc4f", "filename": "gcc/fortran/cpp.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/gcc%2Ffortran%2Fcpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/gcc%2Ffortran%2Fcpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcpp.c?ref=3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2", "patch": "@@ -493,6 +493,12 @@ gfc_cpp_post_options (void)\n \n   cpp_post_options (cpp_in);\n \n+\n+  /* Let diagnostics infrastructure know how to convert input files the same\n+     way libcpp will do it, namely, with no charset conversion but with\n+     skipping of a UTF-8 BOM if present.  */\n+  diagnostic_initialize_input_context (global_dc, nullptr, true);\n+\n   gfc_cpp_register_include_paths ();\n }\n "}, {"sha": "4b809862e02dc78f63572bf78a5fc413a2b99f6e", "filename": "gcc/input.c", "status": "modified", "additions": 88, "deletions": 12, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2", "patch": "@@ -22,14 +22,27 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"intl.h\"\n #include \"diagnostic.h\"\n-#include \"diagnostic-core.h\"\n #include \"selftest.h\"\n #include \"cpplib.h\"\n \n #ifndef HAVE_ICONV\n #define HAVE_ICONV 0\n #endif\n \n+/* Input charset configuration.  */\n+static const char *default_charset_callback (const char *)\n+{\n+  return nullptr;\n+}\n+\n+void\n+file_cache::initialize_input_context (diagnostic_input_charset_callback ccb,\n+\t\t\t\t      bool should_skip_bom)\n+{\n+  in_context.ccb = (ccb ? ccb : default_charset_callback);\n+  in_context.should_skip_bom = should_skip_bom;\n+}\n+\n /* This is a cache used by get_next_line to store the content of a\n    file to be searched for file lines.  */\n class file_cache_slot\n@@ -51,7 +64,8 @@ class file_cache_slot\n \n   void inc_use_count () { m_use_count++; }\n \n-  void create (const char *file_path, FILE *fp, unsigned highest_use_count);\n+  bool create (const file_cache::input_context &in_context,\n+\t       const char *file_path, FILE *fp, unsigned highest_use_count);\n   void evict ();\n \n  private:\n@@ -110,6 +124,10 @@ class file_cache_slot\n      far.  */\n   char *m_data;\n \n+  /* The allocated buffer to be freed may start a little earlier than DATA,\n+     e.g. if a UTF8 BOM was skipped at the beginning.  */\n+  int m_alloc_offset;\n+\n   /*  The size of the DATA array above.*/\n   size_t m_size;\n \n@@ -147,6 +165,17 @@ class file_cache_slot\n      doesn't explode.  We thus scale total_lines down to\n      line_record_size.  */\n   vec<line_info, va_heap> m_line_record;\n+\n+  void offset_buffer (int offset)\n+  {\n+    gcc_assert (offset < 0 ? m_alloc_offset + offset >= 0\n+\t\t: (size_t) offset <= m_size);\n+    gcc_assert (m_data);\n+    m_alloc_offset += offset;\n+    m_data += offset;\n+    m_size -= offset;\n+  }\n+\n };\n \n /* Current position in real source file.  */\n@@ -419,21 +448,25 @@ file_cache::add_file (const char *file_path)\n \n   unsigned highest_use_count = 0;\n   file_cache_slot *r = evicted_cache_tab_entry (&highest_use_count);\n-  r->create (file_path, fp, highest_use_count);\n+  if (!r->create (in_context, file_path, fp, highest_use_count))\n+    return NULL;\n   return r;\n }\n \n /* Populate this slot for use on FILE_PATH and FP, dropping any\n    existing cached content within it.  */\n \n-void\n-file_cache_slot::create (const char *file_path, FILE *fp,\n+bool\n+file_cache_slot::create (const file_cache::input_context &in_context,\n+\t\t\t const char *file_path, FILE *fp,\n \t\t\t unsigned highest_use_count)\n {\n   m_file_path = file_path;\n   if (m_fp)\n     fclose (m_fp);\n   m_fp = fp;\n+  if (m_alloc_offset)\n+    offset_buffer (-m_alloc_offset);\n   m_nb_read = 0;\n   m_line_start_idx = 0;\n   m_line_num = 0;\n@@ -443,13 +476,44 @@ file_cache_slot::create (const char *file_path, FILE *fp,\n   m_use_count = ++highest_use_count;\n   m_total_lines = total_lines_num (file_path);\n   m_missing_trailing_newline = true;\n+\n+\n+  /* Check the input configuration to determine if we need to do any\n+     transformations, such as charset conversion or BOM skipping.  */\n+  if (const char *input_charset = in_context.ccb (file_path))\n+    {\n+      /* Need a full-blown conversion of the input charset.  */\n+      fclose (m_fp);\n+      m_fp = NULL;\n+      const cpp_converted_source cs\n+\t= cpp_get_converted_source (file_path, input_charset);\n+      if (!cs.data)\n+\treturn false;\n+      if (m_data)\n+\tXDELETEVEC (m_data);\n+      m_data = cs.data;\n+      m_nb_read = m_size = cs.len;\n+      m_alloc_offset = cs.data - cs.to_free;\n+    }\n+  else if (in_context.should_skip_bom)\n+    {\n+      if (read_data ())\n+\t{\n+\t  const int offset = cpp_check_utf8_bom (m_data, m_nb_read);\n+\t  offset_buffer (offset);\n+\t  m_nb_read -= offset;\n+\t}\n+    }\n+\n+  return true;\n }\n \n /* file_cache's ctor.  */\n \n file_cache::file_cache ()\n : m_file_slots (new file_cache_slot[num_file_slots])\n {\n+  initialize_input_context (nullptr, false);\n }\n \n /* file_cache's dtor.  */\n@@ -478,8 +542,8 @@ file_cache::lookup_or_add_file (const char *file_path)\n \n file_cache_slot::file_cache_slot ()\n : m_use_count (0), m_file_path (NULL), m_fp (NULL), m_data (0),\n-  m_size (0), m_nb_read (0), m_line_start_idx (0), m_line_num (0),\n-  m_total_lines (0), m_missing_trailing_newline (true)\n+  m_alloc_offset (0), m_size (0), m_nb_read (0), m_line_start_idx (0),\n+  m_line_num (0), m_total_lines (0), m_missing_trailing_newline (true)\n {\n   m_line_record.create (0);\n }\n@@ -495,6 +559,7 @@ file_cache_slot::~file_cache_slot ()\n     }\n   if (m_data)\n     {\n+      offset_buffer (-m_alloc_offset);\n       XDELETEVEC (m_data);\n       m_data = 0;\n     }\n@@ -509,7 +574,7 @@ file_cache_slot::~file_cache_slot ()\n bool\n file_cache_slot::needs_read_p () const\n {\n-  return (m_nb_read == 0\n+  return m_fp && (m_nb_read == 0\n \t  || m_nb_read == m_size\n \t  || (m_line_start_idx >= m_nb_read - 1));\n }\n@@ -531,9 +596,20 @@ file_cache_slot::maybe_grow ()\n   if (!needs_grow_p ())\n     return;\n \n-  size_t size = m_size == 0 ? buffer_size : m_size * 2;\n-  m_data = XRESIZEVEC (char, m_data, size);\n-  m_size = size;\n+  if (!m_data)\n+    {\n+      gcc_assert (m_size == 0 && m_alloc_offset == 0);\n+      m_size = buffer_size;\n+      m_data = XNEWVEC (char, m_size);\n+    }\n+  else\n+    {\n+      const int offset = m_alloc_offset;\n+      offset_buffer (-offset);\n+      m_size *= 2;\n+      m_data = XRESIZEVEC (char, m_data, m_size);\n+      offset_buffer (offset);\n+    }\n }\n \n /*  Read more data into the cache.  Extends the cache if need be.\n@@ -632,7 +708,7 @@ file_cache_slot::get_next_line (char **line, ssize_t *line_len)\n       m_missing_trailing_newline = false;\n     }\n \n-  if (ferror (m_fp))\n+  if (m_fp && ferror (m_fp))\n     return false;\n \n   /* At this point, we've found the end of the of line.  It either"}, {"sha": "e6881072c5f5191d7ba193c0dfe0fae008f1b74a", "filename": "gcc/input.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2", "patch": "@@ -111,6 +111,15 @@ class file_cache\n   file_cache_slot *lookup_or_add_file (const char *file_path);\n   void forcibly_evict_file (const char *file_path);\n \n+  /* See comments in diagnostic.h about the input conversion context.  */\n+  struct input_context\n+  {\n+    diagnostic_input_charset_callback ccb;\n+    bool should_skip_bom;\n+  };\n+  void initialize_input_context (diagnostic_input_charset_callback ccb,\n+\t\t\t\t bool should_skip_bom);\n+\n  private:\n   file_cache_slot *evicted_cache_tab_entry (unsigned *highest_use_count);\n   file_cache_slot *add_file (const char *file_path);\n@@ -119,6 +128,7 @@ class file_cache\n  private:\n   static const size_t num_file_slots = 16;\n   file_cache_slot *m_file_slots;\n+  input_context in_context;\n };\n \n extern expanded_location"}, {"sha": "4e56833162d8204776dc2eeb23f042f251f8d9aa", "filename": "gcc/testsuite/gcc.dg/diagnostic-input-charset-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/gcc%2Ftestsuite%2Fgcc.dg%2Fdiagnostic-input-charset-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/gcc%2Ftestsuite%2Fgcc.dg%2Fdiagnostic-input-charset-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdiagnostic-input-charset-1.c?ref=3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-require-iconv \"CP850\" } */\n+/* { dg-options \"-finput-charset=CP850 -fdiagnostics-show-caret\" } */\n+\n+/* Test that diagnostics are converted to UTF-8; this file is encoded in\n+   CP850.  Why CP850?  -finput-charset only supports encodings that are a\n+   superset of ASCII.  But encodings that look like latin-1 are automatically\n+   converted by expect to UTF-8, and hence by the time dg sees them, it can't\n+   verify they were actually output in UTF-8.  So codepage 850 was chosen as one\n+   that is hopefully available and meets the requirements of matching ASCII and\n+   not matching latin-1.  */\n+const char *section = \"\ufffd\"\n+/* { dg-error \"expected .* at end of input\" \"\" { target *-*-*} .-1 } */\n+/* { dg-begin-multiline-output \"\" }\n+ const char *section = \"\u00a7\"\n+ ^~~~~\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "1a3f35287da725cafdfb7970bf56c3a72fb6e4a7", "filename": "gcc/testsuite/gcc.dg/diagnostic-input-utf8-bom.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/gcc%2Ftestsuite%2Fgcc.dg%2Fdiagnostic-input-utf8-bom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/gcc%2Ftestsuite%2Fgcc.dg%2Fdiagnostic-input-utf8-bom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdiagnostic-input-utf8-bom.c?ref=3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2", "patch": "@@ -0,0 +1,14 @@\n+\ufeffint 1;\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-show-caret\" } */\n+\n+/* This file begins with a UTF-8 byte order mark.  Verify that diagnostics\n+   still point to the right place, since the stripping of the BOM happens twice,\n+   once when libcpp reads the file, and once when diagnostics infrastucture\n+   reads it.  */\n+\n+/* { dg-error \"expected .* before numeric constant\" \"\" { target *-*-*} 1 } */\n+/* { dg-begin-multiline-output \"\" }\n+ int 1;\n+     ^\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "61881f978a86e88396b939517ea23522b86084e1", "filename": "libcpp/charset.c", "status": "modified", "additions": 77, "deletions": 32, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/libcpp%2Fcharset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/libcpp%2Fcharset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fcharset.c?ref=3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2", "patch": "@@ -630,7 +630,11 @@ static const struct cpp_conversion conversion_tab[] = {\n    cset_converter structure for conversion from FROM to TO.  If\n    iconv_open() fails, issue an error and return an identity\n    converter.  Silently return an identity converter if FROM and TO\n-   are identical.  */\n+   are identical.\n+\n+   PFILE is only used for generating diagnostics; setting it to NULL\n+   suppresses diagnostics.  */\n+\n static struct cset_converter\n init_iconv_desc (cpp_reader *pfile, const char *to, const char *from)\n {\n@@ -672,25 +676,31 @@ init_iconv_desc (cpp_reader *pfile, const char *to, const char *from)\n \n       if (ret.cd == (iconv_t) -1)\n \t{\n-\t  if (errno == EINVAL)\n-\t    cpp_error (pfile, CPP_DL_ERROR, /* FIXME should be DL_SORRY */\n-\t\t       \"conversion from %s to %s not supported by iconv\",\n-\t\t       from, to);\n-\t  else\n-\t    cpp_errno (pfile, CPP_DL_ERROR, \"iconv_open\");\n-\n+\t  if (pfile)\n+\t    {\n+\t      if (errno == EINVAL)\n+\t\tcpp_error (pfile, CPP_DL_ERROR, /* FIXME should be DL_SORRY */\n+\t\t\t   \"conversion from %s to %s not supported by iconv\",\n+\t\t\t   from, to);\n+\t      else\n+\t\tcpp_errno (pfile, CPP_DL_ERROR, \"iconv_open\");\n+\t    }\n \t  ret.func = convert_no_conversion;\n \t}\n     }\n   else\n     {\n-      cpp_error (pfile, CPP_DL_ERROR, /* FIXME: should be DL_SORRY */\n-\t\t \"no iconv implementation, cannot convert from %s to %s\",\n-\t\t from, to);\n+      if (pfile)\n+\t{\n+\t  cpp_error (pfile, CPP_DL_ERROR, /* FIXME: should be DL_SORRY */\n+\t\t     \"no iconv implementation, cannot convert from %s to %s\",\n+\t\t     from, to);\n+\t}\n       ret.func = convert_no_conversion;\n       ret.cd = (iconv_t) -1;\n       ret.width = -1;\n     }\n+\n   return ret;\n }\n \n@@ -2122,6 +2132,25 @@ _cpp_interpret_identifier (cpp_reader *pfile, const uchar *id, size_t len)\n \t\t\t\t  buf, bufp - buf, HT_ALLOC));\n }\n \f\n+\n+/* Utility to strip a UTF-8 byte order marking from the beginning\n+   of a buffer.  Returns the number of bytes to skip, which currently\n+   will be either 0 or 3.  */\n+int\n+cpp_check_utf8_bom (const char *data, size_t data_length)\n+{\n+\n+#if HOST_CHARSET == HOST_CHARSET_ASCII\n+  const unsigned char *udata = (const unsigned char *) data;\n+  if (data_length >= 3 && udata[0] == 0xef && udata[1] == 0xbb\n+      && udata[2] == 0xbf)\n+    return 3;\n+#endif\n+\n+  return 0;\n+}\n+\n+\n /* Convert an input buffer (containing the complete contents of one\n    source file) from INPUT_CHARSET to the source character set.  INPUT\n    points to the input buffer, SIZE is its allocated size, and LEN is\n@@ -2135,7 +2164,11 @@ _cpp_interpret_identifier (cpp_reader *pfile, const uchar *id, size_t len)\n    INPUT is expected to have been allocated with xmalloc.  This\n    function will either set *BUFFER_START to INPUT, or free it and set\n    *BUFFER_START to a pointer to another xmalloc-allocated block of\n-   memory.  */\n+   memory.\n+\n+   PFILE is only used to generate diagnostics; setting it to NULL suppresses\n+   diagnostics, and causes a return of NULL if there was any error instead.  */\n+\n uchar * \n _cpp_convert_input (cpp_reader *pfile, const char *input_charset,\n \t\t    uchar *input, size_t size, size_t len,\n@@ -2158,17 +2191,27 @@ _cpp_convert_input (cpp_reader *pfile, const char *input_charset,\n       to.text = XNEWVEC (uchar, to.asize);\n       to.len = 0;\n \n-      if (!APPLY_CONVERSION (input_cset, input, len, &to))\n-\tcpp_error (pfile, CPP_DL_ERROR,\n-\t\t   \"failure to convert %s to %s\",\n-\t\t   CPP_OPTION (pfile, input_charset), SOURCE_CHARSET);\n-\n+      const bool ok = APPLY_CONVERSION (input_cset, input, len, &to);\n       free (input);\n-    }\n \n-  /* Clean up the mess.  */\n-  if (input_cset.func == convert_using_iconv)\n-    iconv_close (input_cset.cd);\n+      /* Clean up the mess.  */\n+      if (input_cset.func == convert_using_iconv)\n+\ticonv_close (input_cset.cd);\n+\n+      /* Handle conversion failure.  */\n+      if (!ok)\n+\t{\n+\t  if (!pfile)\n+\t    {\n+\t      XDELETEVEC (to.text);\n+\t      *buffer_start = NULL;\n+\t      *st_size = 0;\n+\t      return NULL;\n+\t    }\n+\t  cpp_error (pfile, CPP_DL_ERROR, \"failure to convert %s to %s\",\n+\t\t     input_charset, SOURCE_CHARSET);\n+\t}\n+    }\n \n   /* Resize buffer if we allocated substantially too much, or if we\n      haven't enough space for the \\n-terminator or following\n@@ -2192,19 +2235,14 @@ _cpp_convert_input (cpp_reader *pfile, const char *input_charset,\n \n   buffer = to.text;\n   *st_size = to.len;\n-#if HOST_CHARSET == HOST_CHARSET_ASCII\n-  /* The HOST_CHARSET test just above ensures that the source charset\n-     is UTF-8.  So, ignore a UTF-8 BOM if we see one.  Note that\n-     glib'c UTF-8 iconv() provider (as of glibc 2.7) does not ignore a\n+\n+  /* Ignore a UTF-8 BOM if we see one and the source charset is UTF-8.  Note\n+     that glib'c UTF-8 iconv() provider (as of glibc 2.7) does not ignore a\n      BOM -- however, even if it did, we would still need this code due\n      to the 'convert_no_conversion' case.  */\n-  if (to.len >= 3 && to.text[0] == 0xef && to.text[1] == 0xbb\n-      && to.text[2] == 0xbf)\n-    {\n-      *st_size -= 3;\n-      buffer += 3;\n-    }\n-#endif\n+  const int bom_len = cpp_check_utf8_bom ((const char *) to.text, to.len);\n+  *st_size -= bom_len;\n+  buffer += bom_len;\n \n   *buffer_start = to.text;\n   return buffer;\n@@ -2244,6 +2282,13 @@ _cpp_default_encoding (void)\n   return current_encoding;\n }\n \n+/* Check if the configured input charset requires no conversion, other than\n+   possibly stripping a UTF-8 BOM.  */\n+bool cpp_input_conversion_is_trivial (const char *input_charset)\n+{\n+  return !strcasecmp (input_charset, SOURCE_CHARSET);\n+}\n+\n /* Implementation of class cpp_string_location_reader.  */\n \n /* Constructor for cpp_string_location_reader.  */"}, {"sha": "c93a03c69ef5b5a5d58feb7615e955e199c7f128", "filename": "libcpp/files.c", "status": "modified", "additions": 42, "deletions": 14, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/libcpp%2Ffiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/libcpp%2Ffiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ffiles.c?ref=3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2", "patch": "@@ -173,7 +173,7 @@ static bool pch_open_file (cpp_reader *pfile, _cpp_file *file,\n static bool find_file_in_dir (cpp_reader *pfile, _cpp_file *file,\n \t\t\t      bool *invalid_pch, location_t loc);\n static bool read_file_guts (cpp_reader *pfile, _cpp_file *file,\n-\t\t\t    location_t loc);\n+\t\t\t    location_t loc, const char *input_charset);\n static bool read_file (cpp_reader *pfile, _cpp_file *file,\n \t\t       location_t loc);\n static struct cpp_dir *search_path_head (cpp_reader *, const char *fname,\n@@ -671,18 +671,22 @@ _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir,\n \n    Use LOC for any diagnostics.\n \n+   PFILE may be NULL.  In this case, no diagnostics are issued.\n+\n    FIXME: Flush file cache and try again if we run out of memory.  */\n static bool\n-read_file_guts (cpp_reader *pfile, _cpp_file *file, location_t loc)\n+read_file_guts (cpp_reader *pfile, _cpp_file *file, location_t loc,\n+\t\tconst char *input_charset)\n {\n   ssize_t size, total, count;\n   uchar *buf;\n   bool regular;\n \n   if (S_ISBLK (file->st.st_mode))\n     {\n-      cpp_error_at (pfile, CPP_DL_ERROR, loc,\n-\t\t    \"%s is a block device\", file->path);\n+      if (pfile)\n+\tcpp_error_at (pfile, CPP_DL_ERROR, loc,\n+\t\t      \"%s is a block device\", file->path);\n       return false;\n     }\n \n@@ -699,8 +703,9 @@ read_file_guts (cpp_reader *pfile, _cpp_file *file, location_t loc)\n \t does not bite us.  */\n       if (file->st.st_size > INTTYPE_MAXIMUM (ssize_t))\n \t{\n-\t  cpp_error_at (pfile, CPP_DL_ERROR, loc,\n-\t\t\t\"%s is too large\", file->path);\n+\t  if (pfile)\n+\t    cpp_error_at (pfile, CPP_DL_ERROR, loc,\n+\t\t\t  \"%s is too large\", file->path);\n \t  return false;\n \t}\n \n@@ -733,29 +738,29 @@ read_file_guts (cpp_reader *pfile, _cpp_file *file, location_t loc)\n \n   if (count < 0)\n     {\n-      cpp_errno_filename (pfile, CPP_DL_ERROR, file->path, loc);\n+      if (pfile)\n+\tcpp_errno_filename (pfile, CPP_DL_ERROR, file->path, loc);\n       free (buf);\n       return false;\n     }\n \n-  if (regular && total != size && STAT_SIZE_RELIABLE (file->st))\n+  if (pfile && regular && total != size && STAT_SIZE_RELIABLE (file->st))\n     cpp_error_at (pfile, CPP_DL_WARNING, loc,\n \t       \"%s is shorter than expected\", file->path);\n \n   file->buffer = _cpp_convert_input (pfile,\n-\t\t\t\t     CPP_OPTION (pfile, input_charset),\n+\t\t\t\t     input_charset,\n \t\t\t\t     buf, size + 16, total,\n \t\t\t\t     &file->buffer_start,\n \t\t\t\t     &file->st.st_size);\n-  file->buffer_valid = true;\n-\n-  return true;\n+  file->buffer_valid = file->buffer;\n+  return file->buffer_valid;\n }\n \n /* Convenience wrapper around read_file_guts that opens the file if\n    necessary and closes the file descriptor after reading.  FILE must\n    have been passed through find_file() at some stage.  Use LOC for\n-   any diagnostics.  */\n+   any diagnostics.  Unlike read_file_guts(), PFILE may not be NULL.  */\n static bool\n read_file (cpp_reader *pfile, _cpp_file *file, location_t loc)\n {\n@@ -773,7 +778,8 @@ read_file (cpp_reader *pfile, _cpp_file *file, location_t loc)\n       return false;\n     }\n \n-  file->dont_read = !read_file_guts (pfile, file, loc);\n+  file->dont_read = !read_file_guts (pfile, file, loc,\n+\t\t\t\t     CPP_OPTION (pfile, input_charset));\n   close (file->fd);\n   file->fd = -1;\n \n@@ -2145,3 +2151,25 @@ _cpp_has_header (cpp_reader *pfile, const char *fname, int angle_brackets,\n   return file->err_no != ENOENT;\n }\n \n+/* Read a file and convert to input charset, the same as if it were being read\n+   by a cpp_reader.  */\n+\n+cpp_converted_source\n+cpp_get_converted_source (const char *fname, const char *input_charset)\n+{\n+  cpp_converted_source res = {};\n+  _cpp_file file = {};\n+  file.fd = -1;\n+  file.name = lbasename (fname);\n+  file.path = fname;\n+  if (!open_file (&file))\n+    return res;\n+  const bool ok = read_file_guts (NULL, &file, 0, input_charset);\n+  close (file.fd);\n+  if (!ok)\n+    return res;\n+  res.to_free = (char *) file.buffer_start;\n+  res.data = (char *) file.buffer;\n+  res.len = file.st.st_size;\n+  return res;\n+}"}, {"sha": "af1429171ea858c7bd6033ff936a89229aaaf47e", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=3ac6b5cff1eca4e1748c671960ef7b4ca5e47fd2", "patch": "@@ -1379,6 +1379,20 @@ extern struct _cpp_file *cpp_get_file (cpp_buffer *);\n extern cpp_buffer *cpp_get_prev (cpp_buffer *);\n extern void cpp_clear_file_cache (cpp_reader *);\n \n+/* cpp_get_converted_source returns the contents of the given file, as it exists\n+   after cpplib has read it and converted it from the input charset to the\n+   source charset.  Return struct will be zero-filled if the data could not be\n+   read for any reason.  The data starts at the DATA pointer, but the TO_FREE\n+   pointer is what should be passed to free(), as there may be an offset.  */\n+struct cpp_converted_source\n+{\n+  char *to_free;\n+  char *data;\n+  size_t len;\n+};\n+cpp_converted_source cpp_get_converted_source (const char *fname,\n+\t\t\t\t\t       const char *input_charset);\n+\n /* In pch.c */\n struct save_macro_data;\n extern int cpp_save_state (cpp_reader *, FILE *);\n@@ -1449,6 +1463,7 @@ class cpp_display_width_computation {\n /* Convenience functions that are simple use cases for class\n    cpp_display_width_computation.  Tab characters will be expanded to spaces\n    as determined by TABSTOP.  */\n+\n int cpp_byte_column_to_display_column (const char *data, int data_length,\n \t\t\t\t       int column, int tabstop);\n inline int cpp_display_width (const char *data, int data_length,\n@@ -1461,4 +1476,7 @@ int cpp_display_column_to_byte_column (const char *data, int data_length,\n \t\t\t\t       int display_col, int tabstop);\n int cpp_wcwidth (cppchar_t c);\n \n+bool cpp_input_conversion_is_trivial (const char *input_charset);\n+int cpp_check_utf8_bom (const char *data, size_t data_length);\n+\n #endif /* ! LIBCPP_CPPLIB_H */"}]}