{"sha": "7d75abc8ea408019c1c004150bfbce42bfbffa71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q3NWFiYzhlYTQwODAxOWMxYzAwNDE1MGJmYmNlNDJiZmJmZmE3MQ==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2012-04-17T13:54:26Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2012-04-17T13:54:26Z"}, "message": "re PR tree-optimization/18437 (vectorizer failed for matrix multiplication)\n\n\tPR tree-optimization/18437\n\n\t* tree-vectorizer.h (_stmt_vec_info.stride_load_p): New member.\n\t(STMT_VINFO_STRIDE_LOAD_P): New accessor.\n\t(vect_check_strided_load): Declare.\n\t* tree-vect-data-refs.c (vect_check_strided_load): New function.\n\t(vect_analyze_data_refs): Use it to accept strided loads.\n\t* tree-vect-stmts.c (vectorizable_load): Ditto and handle them.\n\ntestsuite/\n\t* gfortran.dg/vect/rnflow-trs2a2.f90: New test.\n\nFrom-SVN: r186530", "tree": {"sha": "86bb9df647b69f4246a856e415af27fe41e37b32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86bb9df647b69f4246a856e415af27fe41e37b32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d75abc8ea408019c1c004150bfbce42bfbffa71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d75abc8ea408019c1c004150bfbce42bfbffa71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d75abc8ea408019c1c004150bfbce42bfbffa71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d75abc8ea408019c1c004150bfbce42bfbffa71/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "efa26eaae377bf2a5ce9b02b84f3963a0166e280", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efa26eaae377bf2a5ce9b02b84f3963a0166e280", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efa26eaae377bf2a5ce9b02b84f3963a0166e280"}], "stats": {"total": 219, "additions": 214, "deletions": 5}, "files": [{"sha": "d43e3449643572ebe1c8bd42e50fb5b346e1fbf1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d75abc8ea408019c1c004150bfbce42bfbffa71/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d75abc8ea408019c1c004150bfbce42bfbffa71/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d75abc8ea408019c1c004150bfbce42bfbffa71", "patch": "@@ -1,3 +1,13 @@\n+2012-04-17  Michael Matz  <matz@suse.de>\n+\n+\tPR tree-optimization/18437\n+\t* tree-vectorizer.h (_stmt_vec_info.stride_load_p): New member.\n+\t(STMT_VINFO_STRIDE_LOAD_P): New accessor.\n+\t(vect_check_strided_load): Declare.\n+\t* tree-vect-data-refs.c (vect_check_strided_load): New function.\n+\t(vect_analyze_data_refs): Use it to accept strided loads.\n+\t* tree-vect-stmts.c (vectorizable_load): Ditto and handle them.\n+\n 2012-04-17  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/53011"}, {"sha": "301f56193ee0979d736ca5489f0c07028734fc24", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d75abc8ea408019c1c004150bfbce42bfbffa71/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d75abc8ea408019c1c004150bfbce42bfbffa71/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7d75abc8ea408019c1c004150bfbce42bfbffa71", "patch": "@@ -1,3 +1,8 @@\n+2012-04-17  Michael Matz  <matz@suse.de>\n+\n+\tPR tree-optimization/18437\n+\t* gfortran.dg/vect/rnflow-trs2a2.f90: New test.\n+\n 2012-04-17  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/53011"}, {"sha": "1d13cea80e0f1bb085862273c4f14ea54edd5d42", "filename": "gcc/testsuite/gfortran.dg/vect/rnflow-trs2a2.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d75abc8ea408019c1c004150bfbce42bfbffa71/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Frnflow-trs2a2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d75abc8ea408019c1c004150bfbce42bfbffa71/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Frnflow-trs2a2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Frnflow-trs2a2.f90?ref=7d75abc8ea408019c1c004150bfbce42bfbffa71", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do compile }\n+! { dg-require-effective-target vect_double }\n+\n+      function trs2a2 (j, k, u, d, m)\n+!      matrice de transition intermediaire, partant de k sans descendre\n+!      sous j. R = IjU(I-Ik)DIj, avec Ii = deltajj, j >= i.\n+!      alternative: trs2a2 = 0\n+!                   trs2a2 (j:k-1, j:k-1) = matmul (utrsft (j:k-1,j:k-1),\n+!                                                   dtrsft (j:k-1,j:k-1))\n+!\n+      real, dimension (1:m,1:m) :: trs2a2  ! resultat\n+      real, dimension (1:m,1:m) :: u, d    ! matrices utrsft, dtrsft\n+      integer, intent (in)      :: j, k, m ! niveaux vallee pic\n+!\n+!##### following line replaced by Prentice to make less system dependent\n+!      real (kind = kind (1.0d0)) :: dtmp\n+      real (kind = selected_real_kind (10,50)) :: dtmp\n+!\n+      trs2a2 = 0.0\n+      do iclw1 = j, k - 1\n+         do iclw2 = j, k - 1\n+            dtmp = 0.0d0\n+            do iclww = j, k - 1\n+               dtmp = dtmp + u (iclw1, iclww) * d (iclww, iclw2)\n+            enddo\n+            trs2a2 (iclw1, iclw2) = dtmp\n+         enddo\n+      enddo\n+      return\n+      end function trs2a2\n+\n+! { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } }\n+! { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "37df7ab32e9da27a7f146b53ba856a9ef1fd028b", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 60, "deletions": 5, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d75abc8ea408019c1c004150bfbce42bfbffa71/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d75abc8ea408019c1c004150bfbce42bfbffa71/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=7d75abc8ea408019c1c004150bfbce42bfbffa71", "patch": "@@ -2690,6 +2690,53 @@ vect_check_gather (gimple stmt, loop_vec_info loop_vinfo, tree *basep,\n   return decl;\n }\n \n+/* Check wether a non-affine load in STMT (being in the loop referred to\n+   in LOOP_VINFO) is suitable for handling as strided load.  That is the case\n+   if its address is a simple induction variable.  If so return the base\n+   of that induction variable in *BASEP and the (loop-invariant) step\n+   in *STEPP, both only when that pointer is non-zero.\n+\n+   This handles ARRAY_REFs (with variant index) and MEM_REFs (with variant\n+   base pointer) only.  */\n+\n+bool\n+vect_check_strided_load (gimple stmt, loop_vec_info loop_vinfo, tree *basep,\n+\t\t\t tree *stepp)\n+{\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n+  tree base, off;\n+  affine_iv iv;\n+\n+  base = DR_REF (dr);\n+\n+  if (TREE_CODE (base) == ARRAY_REF)\n+    {\n+      off = TREE_OPERAND (base, 1);\n+      base = TREE_OPERAND (base, 0);\n+    }\n+  else if (TREE_CODE (base) == MEM_REF)\n+    {\n+      off = TREE_OPERAND (base, 0);\n+      base = TREE_OPERAND (base, 1);\n+    }\n+  else\n+    return false;\n+\n+  if (TREE_CODE (off) != SSA_NAME)\n+    return false;\n+\n+  if (!expr_invariant_in_loop_p (loop, base)\n+      || !simple_iv (loop, loop_containing_stmt (stmt), off, &iv, true))\n+    return false;\n+\n+  if (basep)\n+    *basep = iv.base;\n+  if (stepp)\n+    *stepp = iv.step;\n+  return true;\n+}\n \n /* Function vect_analyze_data_refs.\n \n@@ -3090,16 +3137,21 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t  VEC (ddr_p, heap) *ddrs = LOOP_VINFO_DDRS (loop_vinfo);\n \t  struct data_dependence_relation *ddr, *newddr;\n \t  bool bad = false;\n+\t  bool strided_load = false;\n \t  tree off;\n \t  VEC (loop_p, heap) *nest = LOOP_VINFO_LOOP_NEST (loop_vinfo);\n \n-\t  if (!vect_check_gather (stmt, loop_vinfo, NULL, &off, NULL)\n-\t      || get_vectype_for_scalar_type (TREE_TYPE (off)) == NULL_TREE)\n+\t  strided_load = vect_check_strided_load (stmt, loop_vinfo, NULL, NULL);\n+\t  gather = 0 != vect_check_gather (stmt, loop_vinfo, NULL, &off, NULL);\n+\t  if (gather\n+\t      && get_vectype_for_scalar_type (TREE_TYPE (off)) == NULL_TREE)\n+\t    gather = false;\n+\t  if (!gather && !strided_load)\n \t    {\n \t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n \t\t{\n \t\t  fprintf (vect_dump,\n-\t\t\t   \"not vectorized: not suitable for gather \");\n+\t\t\t   \"not vectorized: not suitable for gather/strided load \");\n \t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n \t\t}\n \t      return false;\n@@ -3152,13 +3204,16 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t\t{\n \t\t  fprintf (vect_dump,\n \t\t\t   \"not vectorized: data dependence conflict\"\n-\t\t\t   \" prevents gather\");\n+\t\t\t   \" prevents gather/strided load\");\n \t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n \t\t}\n \t      return false;\n \t    }\n \n-\t  STMT_VINFO_GATHER_P (stmt_info) = true;\n+\t  if (gather)\n+\t    STMT_VINFO_GATHER_P (stmt_info) = true;\n+\t  else if (strided_load)\n+\t    STMT_VINFO_STRIDE_LOAD_P (stmt_info) = true;\n \t}\n     }\n "}, {"sha": "5e6f71a19bfc84df4a9c3b7645e66c8b5b091a75", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d75abc8ea408019c1c004150bfbce42bfbffa71/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d75abc8ea408019c1c004150bfbce42bfbffa71/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=7d75abc8ea408019c1c004150bfbce42bfbffa71", "patch": "@@ -4224,6 +4224,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   tree aggr_type;\n   tree gather_base = NULL_TREE, gather_off = NULL_TREE;\n   tree gather_off_vectype = NULL_TREE, gather_decl = NULL_TREE;\n+  tree stride_base, stride_step;\n   int gather_scale = 1;\n   enum vect_def_type gather_dt = vect_unknown_def_type;\n \n@@ -4357,6 +4358,10 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t  return false;\n \t}\n     }\n+  else if (STMT_VINFO_STRIDE_LOAD_P (stmt_info))\n+    {\n+      vect_check_strided_load (stmt, loop_vinfo, &stride_base, &stride_step);\n+    }\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n@@ -4524,6 +4529,104 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t}\n       return true;\n     }\n+  else if (STMT_VINFO_STRIDE_LOAD_P (stmt_info))\n+    {\n+      gimple_stmt_iterator incr_gsi;\n+      bool insert_after;\n+      gimple incr;\n+      tree offvar;\n+      tree ref = DR_REF (dr);\n+      tree ivstep;\n+      tree running_off;\n+      VEC(constructor_elt, gc) *v = NULL;\n+      gimple_seq stmts = NULL;\n+\n+      gcc_assert (stride_base && stride_step);\n+\n+      /* For a load with loop-invariant (but other than power-of-2)\n+         stride (i.e. not a grouped access) like so:\n+\n+\t   for (i = 0; i < n; i += stride)\n+\t     ... = array[i];\n+\n+\t we generate a new induction variable and new accesses to\n+\t form a new vector (or vectors, depending on ncopies):\n+\n+\t   for (j = 0; ; j += VF*stride)\n+\t     tmp1 = array[j];\n+\t     tmp2 = array[j + stride];\n+\t     ...\n+\t     vectemp = {tmp1, tmp2, ...}\n+         */\n+\n+      ivstep = stride_step;\n+      ivstep = fold_build2 (MULT_EXPR, TREE_TYPE (ivstep), ivstep,\n+\t\t\t    build_int_cst (TREE_TYPE (ivstep), vf));\n+\n+      standard_iv_increment_position (loop, &incr_gsi, &insert_after);\n+\n+      create_iv (stride_base, ivstep, NULL,\n+\t\t loop, &incr_gsi, insert_after,\n+\t\t &offvar, NULL);\n+      incr = gsi_stmt (incr_gsi);\n+      set_vinfo_for_stmt (incr, new_stmt_vec_info (incr, loop_vinfo, NULL));\n+\n+      stride_step = force_gimple_operand (stride_step, &stmts, true, NULL_TREE);\n+      if (stmts)\n+\tgsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n+\n+      prev_stmt_info = NULL;\n+      running_off = offvar;\n+      for (j = 0; j < ncopies; j++)\n+\t{\n+\t  tree vec_inv;\n+\n+\t  v = VEC_alloc (constructor_elt, gc, nunits);\n+\t  for (i = 0; i < nunits; i++)\n+\t    {\n+\t      tree newref, newoff;\n+\t      gimple incr;\n+\t      if (TREE_CODE (ref) == ARRAY_REF)\n+\t\tnewref = build4 (ARRAY_REF, TREE_TYPE (ref),\n+\t\t\t\t unshare_expr (TREE_OPERAND (ref, 0)),\n+\t\t\t\t running_off,\n+\t\t\t\t NULL_TREE, NULL_TREE);\n+\t      else\n+\t\tnewref = build2 (MEM_REF, TREE_TYPE (ref),\n+\t\t\t\t running_off,\n+\t\t\t\t TREE_OPERAND (ref, 1));\n+\n+\t      newref = force_gimple_operand_gsi (gsi, newref, true,\n+\t\t\t\t\t\t NULL_TREE, true,\n+\t\t\t\t\t\t GSI_SAME_STMT);\n+\t      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, newref);\n+\t      newoff = SSA_NAME_VAR (running_off);\n+\t      if (POINTER_TYPE_P (TREE_TYPE (newoff)))\n+\t\tincr = gimple_build_assign_with_ops (POINTER_PLUS_EXPR, newoff,\n+\t\t\t\t\t\t     running_off, stride_step);\n+\t      else\n+\t\tincr = gimple_build_assign_with_ops (PLUS_EXPR, newoff,\n+\t\t\t\t\t\t     running_off, stride_step);\n+\t      newoff = make_ssa_name (newoff, incr);\n+\t      gimple_assign_set_lhs (incr, newoff);\n+\t      vect_finish_stmt_generation (stmt, incr, gsi);\n+\n+\t      running_off = newoff;\n+\t    }\n+\n+\t  vec_inv = build_constructor (vectype, v);\n+\t  new_temp = vect_init_vector (stmt, vec_inv, vectype, gsi);\n+\t  new_stmt = SSA_NAME_DEF_STMT (new_temp);\n+\t  mark_symbols_for_renaming (new_stmt);\n+\n+\t  if (j == 0)\n+\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\t  else\n+\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t}\n+      return true;\n+    }\n \n   if (grouped_load)\n     {"}, {"sha": "5d9960940474707230f799c65d220d216227048b", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d75abc8ea408019c1c004150bfbce42bfbffa71/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d75abc8ea408019c1c004150bfbce42bfbffa71/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=7d75abc8ea408019c1c004150bfbce42bfbffa71", "patch": "@@ -545,6 +545,7 @@ typedef struct _stmt_vec_info {\n \n   /* For loads only, true if this is a gather load.  */\n   bool gather_p;\n+  bool stride_load_p;\n } *stmt_vec_info;\n \n /* Access Functions.  */\n@@ -559,6 +560,7 @@ typedef struct _stmt_vec_info {\n #define STMT_VINFO_VECTORIZABLE(S)         (S)->vectorizable\n #define STMT_VINFO_DATA_REF(S)             (S)->data_ref_info\n #define STMT_VINFO_GATHER_P(S)\t\t   (S)->gather_p\n+#define STMT_VINFO_STRIDE_LOAD_P(S)\t   (S)->stride_load_p\n \n #define STMT_VINFO_DR_BASE_ADDRESS(S)      (S)->dr_base_address\n #define STMT_VINFO_DR_INIT(S)              (S)->dr_init\n@@ -875,6 +877,7 @@ extern bool vect_analyze_data_ref_accesses (loop_vec_info, bb_vec_info);\n extern bool vect_prune_runtime_alias_test_list (loop_vec_info);\n extern tree vect_check_gather (gimple, loop_vec_info, tree *, tree *,\n \t\t\t       int *);\n+extern bool vect_check_strided_load (gimple, loop_vec_info, tree *, tree *);\n extern bool vect_analyze_data_refs (loop_vec_info, bb_vec_info, int *);\n extern tree vect_create_data_ref_ptr (gimple, tree, struct loop *, tree,\n \t\t\t\t      tree *, gimple_stmt_iterator *,"}]}