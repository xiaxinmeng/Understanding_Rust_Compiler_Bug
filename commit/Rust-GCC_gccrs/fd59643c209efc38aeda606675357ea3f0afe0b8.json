{"sha": "fd59643c209efc38aeda606675357ea3f0afe0b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ1OTY0M2MyMDllZmMzOGFlZGE2MDY2NzUzNTdlYTNmMGFmZTBiOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2012-04-26T15:49:44Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-04-26T15:49:44Z"}, "message": "sched-deps.c (fixup_sched_groups): Rename to...\n\ngcc/\n\t* sched-deps.c (fixup_sched_groups): Rename to...\n\t(chain_to_prev_insn): ...this.\n\t(chain_to_prev_insn_p): New function.\n\t(deps_analyze_insn): Use it instead of SCHED_GROUP_P.\n\nFrom-SVN: r186883", "tree": {"sha": "41e4c6b9bbf40426f2a4b10439f42d63cd539fe6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41e4c6b9bbf40426f2a4b10439f42d63cd539fe6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd59643c209efc38aeda606675357ea3f0afe0b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd59643c209efc38aeda606675357ea3f0afe0b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd59643c209efc38aeda606675357ea3f0afe0b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd59643c209efc38aeda606675357ea3f0afe0b8/comments", "author": null, "committer": null, "parents": [{"sha": "7a1aca9c426e2723c731f1f3e006e8b03265616a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a1aca9c426e2723c731f1f3e006e8b03265616a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a1aca9c426e2723c731f1f3e006e8b03265616a"}], "stats": {"total": 49, "additions": 44, "deletions": 5}, "files": [{"sha": "493f74f47b7ffef04c08bfcccceb87ae1f5ab215", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd59643c209efc38aeda606675357ea3f0afe0b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd59643c209efc38aeda606675357ea3f0afe0b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fd59643c209efc38aeda606675357ea3f0afe0b8", "patch": "@@ -1,3 +1,10 @@\n+2012-04-26  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* sched-deps.c (fixup_sched_groups): Rename to...\n+\t(chain_to_prev_insn): ...this.\n+\t(chain_to_prev_insn_p): New function.\n+\t(deps_analyze_insn): Use it instead of SCHED_GROUP_P.\n+\n 2012-04-26  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* sched-int.h (_haifa_insn_data): Move priority_status."}, {"sha": "4a0212112f2044083bfef0f33a2aa1798186b4b7", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd59643c209efc38aeda606675357ea3f0afe0b8/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd59643c209efc38aeda606675357ea3f0afe0b8/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=fd59643c209efc38aeda606675357ea3f0afe0b8", "patch": "@@ -477,7 +477,7 @@ static void add_dependence_list (rtx, rtx, int, enum reg_note);\n static void add_dependence_list_and_free (struct deps_desc *, rtx,\n \t\t\t\t\t  rtx *, int, enum reg_note);\n static void delete_all_dependences (rtx);\n-static void fixup_sched_groups (rtx);\n+static void chain_to_prev_insn (rtx);\n \n static void flush_pending_lists (struct deps_desc *, rtx, int, int);\n static void sched_analyze_1 (struct deps_desc *, rtx, rtx);\n@@ -1652,7 +1652,7 @@ delete_all_dependences (rtx insn)\n    the previous nonnote insn.  */\n \n static void\n-fixup_sched_groups (rtx insn)\n+chain_to_prev_insn (rtx insn)\n {\n   sd_iterator_def sd_it;\n   dep_t dep;\n@@ -3295,7 +3295,7 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx insn)\n \t       instructions that follow seem like they should be part\n \t       of the call group.\n \n-\t       Also, if we did, fixup_sched_groups() would move the\n+\t       Also, if we did, chain_to_prev_insn would move the\n \t       deps of the debug insn to the call insn, modifying\n \t       non-debug post-dependency counts of the debug insn\n \t       dependencies and otherwise messing with the scheduling\n@@ -3441,6 +3441,37 @@ call_may_noreturn_p (rtx insn)\n   return true;\n }\n \n+/* Return true if INSN should be made dependent on the previous instruction\n+   group, and if all INSN's dependencies should be moved to the first\n+   instruction of that group.  */\n+\n+static bool\n+chain_to_prev_insn_p (rtx insn)\n+{\n+  rtx prev, x;\n+\n+  /* INSN forms a group with the previous instruction.  */\n+  if (SCHED_GROUP_P (insn))\n+    return true;\n+\n+  /* If the previous instruction clobbers a register R and this one sets\n+     part of R, the clobber was added specifically to help us track the\n+     liveness of R.  There's no point scheduling the clobber and leaving\n+     INSN behind, especially if we move the clobber to another block.  */\n+  prev = prev_nonnote_nondebug_insn (insn);\n+  if (prev\n+      && INSN_P (prev)\n+      && BLOCK_FOR_INSN (prev) == BLOCK_FOR_INSN (insn)\n+      && GET_CODE (PATTERN (prev)) == CLOBBER)\n+    {\n+      x = XEXP (PATTERN (prev), 0);\n+      if (set_of (x, insn))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n /* Analyze INSN with DEPS as a context.  */\n void\n deps_analyze_insn (struct deps_desc *deps, rtx insn)\n@@ -3608,8 +3639,9 @@ deps_analyze_insn (struct deps_desc *deps, rtx insn)\n \n   /* Fixup the dependencies in the sched group.  */\n   if ((NONJUMP_INSN_P (insn) || JUMP_P (insn))\n-      && SCHED_GROUP_P (insn) && !sel_sched_p ())\n-    fixup_sched_groups (insn);\n+      && chain_to_prev_insn_p (insn)\n+      && !sel_sched_p ())\n+    chain_to_prev_insn (insn);\n }\n \n /* Initialize DEPS for the new block beginning with HEAD.  */"}]}