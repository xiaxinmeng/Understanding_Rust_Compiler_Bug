{"sha": "324ed5a676f020e3bd4b37f40028025d1e915bbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI0ZWQ1YTY3NmYwMjBlM2JkNGIzN2Y0MDAyODAyNWQxZTkxNWJiZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-06-24T18:15:36Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-06-24T18:15:36Z"}, "message": "utils2.c (known_alignment): Derive the alignment from pointed-to types only if it is otherwise unknown.\n\n\t* utils2.c (known_alignment): Derive the alignment from pointed-to\n\ttypes only if it is otherwise unknown.\n\t<INTEGER_CST>: Tidy.\n\t<MULT_EXPR>: Likewise.\n\t<POINTER_PLUS_EXPR>: If the alignment of the offset is unknown, use\n\tthat of the base.\n\nFrom-SVN: r137081", "tree": {"sha": "1f4c859fa21f77b99e36f9bd2885a7fe48b8f631", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f4c859fa21f77b99e36f9bd2885a7fe48b8f631"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/324ed5a676f020e3bd4b37f40028025d1e915bbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/324ed5a676f020e3bd4b37f40028025d1e915bbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/324ed5a676f020e3bd4b37f40028025d1e915bbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/324ed5a676f020e3bd4b37f40028025d1e915bbf/comments", "author": null, "committer": null, "parents": [{"sha": "a057a4f13b2599c7fa19bf08b9617b6b3f67d2d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a057a4f13b2599c7fa19bf08b9617b6b3f67d2d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a057a4f13b2599c7fa19bf08b9617b6b3f67d2d7"}], "stats": {"total": 108, "additions": 79, "deletions": 29}, "files": [{"sha": "be34816b3f463357ac9110321e0bb85a980a6d33", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324ed5a676f020e3bd4b37f40028025d1e915bbf/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324ed5a676f020e3bd4b37f40028025d1e915bbf/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=324ed5a676f020e3bd4b37f40028025d1e915bbf", "patch": "@@ -1,3 +1,12 @@\n+2008-06-24  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* utils2.c (known_alignment): Derive the alignment from pointed-to\n+\ttypes only if it is otherwise unknown.\n+\t<INTEGER_CST>: Tidy.\n+\t<MULT_EXPR>: Likewise.\n+\t<POINTER_PLUS_EXPR>: If the alignment of the offset is unknown, use\n+\tthat of the base.\n+\n 2008-06-20  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR ada/36573"}, {"sha": "300fbd37d01d21517512d2a89f0365cc2a27f708", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324ed5a676f020e3bd4b37f40028025d1e915bbf/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324ed5a676f020e3bd4b37f40028025d1e915bbf/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=324ed5a676f020e3bd4b37f40028025d1e915bbf", "patch": "@@ -136,23 +136,6 @@ known_alignment (tree exp)\n {\n   unsigned int this_alignment;\n   unsigned int lhs, rhs;\n-  unsigned int type_alignment;\n-\n-  /* For pointer expressions, we know that the designated object is always at\n-     least as strictly aligned as the designated subtype, so we account for\n-     both type and expression information in this case.\n-\n-     Beware that we can still get a dummy designated subtype here (e.g. Taft\n-     Amendment types), in which the alignment information is meaningless and\n-     should be ignored.\n-\n-     We always compute a type_alignment value and return the MAX of it\n-     compared with what we get from the expression tree. Just set the\n-     type_alignment value to 0 when the type information is to be ignored.  */\n-  type_alignment\n-    = ((POINTER_TYPE_P (TREE_TYPE (exp))\n-\t&& !TYPE_IS_DUMMY_P (TREE_TYPE (TREE_TYPE (exp))))\n-       ? TYPE_ALIGN (TREE_TYPE (TREE_TYPE (exp))) : 0);\n \n   switch (TREE_CODE (exp))\n     {\n@@ -170,7 +153,6 @@ known_alignment (tree exp)\n       break;\n \n     case PLUS_EXPR:\n-    case POINTER_PLUS_EXPR:\n     case MINUS_EXPR:\n       /* If two address are added, the alignment of the result is the\n \t minimum of the two alignments.  */\n@@ -179,6 +161,17 @@ known_alignment (tree exp)\n       this_alignment = MIN (lhs, rhs);\n       break;\n \n+    case POINTER_PLUS_EXPR:\n+      lhs = known_alignment (TREE_OPERAND (exp, 0));\n+      rhs = known_alignment (TREE_OPERAND (exp, 1));\n+      /* If we don't know the alignment of the offset, we assume that\n+\t of the base.  */\n+      if (rhs == 0)\n+\tthis_alignment = lhs;\n+      else\n+\tthis_alignment = MIN (lhs, rhs);\n+      break;\n+\n     case COND_EXPR:\n       /* If there is a choice between two values, use the smallest one.  */\n       lhs = known_alignment (TREE_OPERAND (exp, 1));\n@@ -187,12 +180,12 @@ known_alignment (tree exp)\n       break;\n \n     case INTEGER_CST:\n-      /* The first part of this represents the lowest bit in the constant,\n-\t but is it in bytes, not bits.  */\n-      this_alignment\n-\t= MIN (BITS_PER_UNIT\n-\t\t  * (TREE_INT_CST_LOW (exp) & - TREE_INT_CST_LOW (exp)),\n-\t\t  BIGGEST_ALIGNMENT);\n+      {\n+\tunsigned HOST_WIDE_INT c = TREE_INT_CST_LOW (exp);\n+\t/* The first part of this represents the lowest bit in the constant,\n+\t   but it is originally in bytes, not bits.  */\n+\tthis_alignment = MIN (BITS_PER_UNIT * (c & -c), BIGGEST_ALIGNMENT);\n+      }\n       break;\n \n     case MULT_EXPR:\n@@ -201,10 +194,12 @@ known_alignment (tree exp)\n       lhs = known_alignment (TREE_OPERAND (exp, 0));\n       rhs = known_alignment (TREE_OPERAND (exp, 1));\n \n-      if (lhs == 0 || rhs == 0)\n-\tthis_alignment = MIN (BIGGEST_ALIGNMENT, MAX (lhs, rhs));\n+      if (lhs == 0)\n+\tthis_alignment = rhs;\n+      else if (rhs == 0)\n+\tthis_alignment = lhs;\n       else\n-\tthis_alignment = MIN (BIGGEST_ALIGNMENT, lhs * rhs);\n+\tthis_alignment = MIN (lhs * rhs, BIGGEST_ALIGNMENT);\n       break;\n \n     case BIT_AND_EXPR:\n@@ -220,11 +215,19 @@ known_alignment (tree exp)\n       break;\n \n     default:\n-      this_alignment = 0;\n+      /* For other pointer expressions, we assume that the pointed-to object\n+\t is at least as aligned as the pointed-to type.  Beware that we can\n+\t have a dummy type here (e.g. a Taft Amendment type), for which the\n+\t alignment is meaningless and should be ignored.  */\n+      if (POINTER_TYPE_P (TREE_TYPE (exp))\n+\t  && !TYPE_IS_DUMMY_P (TREE_TYPE (TREE_TYPE (exp))))\n+\tthis_alignment = TYPE_ALIGN (TREE_TYPE (TREE_TYPE (exp)));\n+      else\n+\tthis_alignment = 0;\n       break;\n     }\n \n-  return MAX (type_alignment, this_alignment);\n+  return this_alignment;\n }\n \f\n /* We have a comparison or assignment operation on two types, T1 and T2, which"}, {"sha": "4c569c26edb655af7139d5770f66f4ce3c54d507", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324ed5a676f020e3bd4b37f40028025d1e915bbf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324ed5a676f020e3bd4b37f40028025d1e915bbf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=324ed5a676f020e3bd4b37f40028025d1e915bbf", "patch": "@@ -1,3 +1,7 @@\n+2008-06-24  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/warn5.adb: New test.\n+\n 2008-06-24  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/36504"}, {"sha": "108bc594c0c4f9fab30112a78a98fc5cf6865779", "filename": "gcc/testsuite/gnat.dg/warn5.adb", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324ed5a676f020e3bd4b37f40028025d1e915bbf/gcc%2Ftestsuite%2Fgnat.dg%2Fwarn5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324ed5a676f020e3bd4b37f40028025d1e915bbf/gcc%2Ftestsuite%2Fgnat.dg%2Fwarn5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fwarn5.adb?ref=324ed5a676f020e3bd4b37f40028025d1e915bbf", "patch": "@@ -0,0 +1,34 @@\n+-- { dg-do compile }\n+\n+with System;\n+with Unchecked_Conversion;\n+\n+procedure Warn5 is\n+\n+  type Digit_Type is range 0..15;\n+\n+  type Frequency_Type is array( 1..12) of Digit_Type;\n+  pragma Pack(Frequency_Type);\n+\n+  type Element_Type is record\n+     F : Frequency_Type;\n+  end record;\n+\n+  type Array_Type is array (Natural range <>) of Element_Type;\n+\n+  type List_Type is record\n+    A : Array_Type (0..1);\n+  end record;\n+  for List_Type'Alignment use 4;\n+\n+  type Pointer_Type is access Element_Type;\n+  function To_Ptr is new Unchecked_Conversion(System.Address, Pointer_Type);\n+\n+  function Pointer (Pos : Natural; List : List_Type) return Pointer_Type is\n+  begin\n+    return To_Ptr(List.A(Pos)'Address); -- { dg-warning \"source alignment\" \"\" { target alpha*-*-* hppa*-*-* ia64-*-* mips*-*-* sparc*-*-* } }\n+  end;\n+\n+begin\n+  null;\n+end;"}]}