{"sha": "4e7512c9d18b4bdd5a52a239746b4cd2b0a91399", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU3NTEyYzlkMThiNGJkZDVhNTJhMjM5NzQ2YjRjZDJiMGE5MTM5OQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-04-16T19:45:32Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-04-16T19:45:32Z"}, "message": "cp-tree.def (THUNK_DECL): Add to documentation.\n\n\t* cp-tree.def (THUNK_DECL): Add to documentation.\n\t* cp-tree.h (flag_huge_objects): Declare.\n\t* class.c (modify_vtable_entry): Tidy.\n\t(update_vtable_entry_for_fn): Split out from dfs_modify_vtables.\n\tCalculate delta appropriately for the new ABI.\n\t(dfs_modify_vtables): Use it.\n\t(modify_all_vtables): Fix thinko in code to add overriding copies\n\tof functions to primary vtables.\n\t(build_clone): Fix typo in comment.\n\t(clone_function_decl): Correct order of destructors in vtable.\n\t(build_vbase_offset_vtbl_entries): Adjust comment.\n\t(dfs_vcall_offset_queue_p): Remove.\n\t(dfs_build_vcall_offset_vtbl_entries): Update BV_VCALL_INDEX.\n\t(build_vcall_offset_vtbl_entries): Juse use dfs_skip_vbases.\n\t(build_vtable_entry): Correct check for pure virtual functions.\n\tDon't declare flag_huge_objects.\n\t* decl.c (flag_huge_objects): Remove declaration.\n\t* method.c (make_thunk): Tweak mangling for vcall offset thunks.\n\tUse int_size_in_bytes.\n\t(emit_thunk): Handle vcall offset thunks.\n\nFrom-SVN: r33185", "tree": {"sha": "b4f81d3119e33454003b3194b8678c7292aaff83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4f81d3119e33454003b3194b8678c7292aaff83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e7512c9d18b4bdd5a52a239746b4cd2b0a91399", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e7512c9d18b4bdd5a52a239746b4cd2b0a91399", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e7512c9d18b4bdd5a52a239746b4cd2b0a91399", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e7512c9d18b4bdd5a52a239746b4cd2b0a91399/comments", "author": null, "committer": null, "parents": [{"sha": "3268dc00a8332f0af73ccee3e5445e98e05388d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3268dc00a8332f0af73ccee3e5445e98e05388d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3268dc00a8332f0af73ccee3e5445e98e05388d0"}], "stats": {"total": 330, "additions": 222, "deletions": 108}, "files": [{"sha": "ca2ac716d0a04a8d67487512249d52157159d7ae", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7512c9d18b4bdd5a52a239746b4cd2b0a91399/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7512c9d18b4bdd5a52a239746b4cd2b0a91399/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4e7512c9d18b4bdd5a52a239746b4cd2b0a91399", "patch": "@@ -1,3 +1,26 @@\n+2000-04-15  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.def (THUNK_DECL): Add to documentation.\n+\t* cp-tree.h (flag_huge_objects): Declare.\n+\t* class.c (modify_vtable_entry): Tidy.\n+\t(update_vtable_entry_for_fn): Split out from dfs_modify_vtables.\n+\tCalculate delta appropriately for the new ABI.\n+\t(dfs_modify_vtables): Use it.\n+\t(modify_all_vtables): Fix thinko in code to add overriding copies\n+\tof functions to primary vtables.\n+\t(build_clone): Fix typo in comment.\n+\t(clone_function_decl): Correct order of destructors in vtable.\n+\t(build_vbase_offset_vtbl_entries): Adjust comment.\n+\t(dfs_vcall_offset_queue_p): Remove.\n+\t(dfs_build_vcall_offset_vtbl_entries): Update BV_VCALL_INDEX.\n+\t(build_vcall_offset_vtbl_entries): Juse use dfs_skip_vbases.\n+\t(build_vtable_entry): Correct check for pure virtual functions.\n+\tDon't declare flag_huge_objects.\n+\t* decl.c (flag_huge_objects): Remove declaration.\n+\t* method.c (make_thunk): Tweak mangling for vcall offset thunks.\n+\tUse int_size_in_bytes.\n+\t(emit_thunk): Handle vcall offset thunks.\n+\t\n Sat Apr 15 16:00:01 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* decl2.c (parse_time, varconst_time): Delete declarations."}, {"sha": "bf9c804a8a35c4e06f9e1dfb28b400912e7d59c7", "filename": "gcc/cp/class.c", "status": "modified", "additions": 133, "deletions": 86, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7512c9d18b4bdd5a52a239746b4cd2b0a91399/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7512c9d18b4bdd5a52a239746b4cd2b0a91399/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=4e7512c9d18b4bdd5a52a239746b4cd2b0a91399", "patch": "@@ -146,7 +146,6 @@ static void layout_virtual_bases PARAMS ((tree, varray_type *));\n static tree dfs_set_offset_for_shared_vbases PARAMS ((tree, void *));\n static tree dfs_set_offset_for_unshared_vbases PARAMS ((tree, void *));\n static void build_vbase_offset_vtbl_entries PARAMS ((tree, vcall_offset_data *));\n-static tree dfs_vcall_offset_queue_p PARAMS ((tree, void *));\n static tree dfs_build_vcall_offset_vtbl_entries PARAMS ((tree, void *));\n static void build_vcall_offset_vtbl_entries PARAMS ((tree, vcall_offset_data *));\n static void layout_vtable_decl PARAMS ((tree, int));\n@@ -977,9 +976,9 @@ make_new_vtable (t, binfo)\n \n /* Make *VIRTUALS, an entry on the BINFO_VIRTUALS list for BINFO\n    (which is in the hierarchy dominated by T) list FNDECL as its\n-   BV_FN.  DELTA is the required adjustment from the `this' pointer\n-   where the vtable entry appears to the `this' required when the\n-   function is actually called.  */\n+   BV_FN.  DELTA is the required constant adjustment from the `this'\n+   pointer where the vtable entry appears to the `this' required when\n+   the function is actually called.  */\n \n static void\n modify_vtable_entry (t, binfo, fndecl, delta, virtuals)\n@@ -989,15 +988,12 @@ modify_vtable_entry (t, binfo, fndecl, delta, virtuals)\n      tree delta;\n      tree *virtuals;\n {\n-  tree vcall_index;\n   tree v;\n \n   v = *virtuals;\n-  vcall_index = integer_zero_node;\n \n   if (fndecl != BV_FN (v)\n-      || !tree_int_cst_equal (delta, BV_DELTA (v))\n-      || !tree_int_cst_equal (vcall_index, BV_VCALL_INDEX (v)))\n+      || !tree_int_cst_equal (delta, BV_DELTA (v)))\n     {\n       tree base_fndecl;\n \n@@ -1015,7 +1011,7 @@ modify_vtable_entry (t, binfo, fndecl, delta, virtuals)\n \n       base_fndecl = BV_FN (v);\n       BV_DELTA (v) = delta;\n-      BV_VCALL_INDEX (v) = vcall_index;\n+      BV_VCALL_INDEX (v) = integer_zero_node;\n       BV_FN (v) = fndecl;\n \n       /* Now assign virtual dispatch information, if unset.  We can\n@@ -1087,7 +1083,8 @@ add_virtual_function (new_virtuals_p, overridden_virtuals_p,\n     /* We've already dealt with this function.  */\n     return;\n \n-  new_virtual = build_tree_list (integer_zero_node, fndecl);\n+  new_virtual = build_tree_list (NULL_TREE, fndecl);\n+  BV_DELTA (new_virtual) = integer_zero_node;\n   BV_VCALL_INDEX (new_virtual) = integer_zero_node;\n \n   if (DECL_VINDEX (fndecl) == error_mark_node)\n@@ -2470,6 +2467,84 @@ dfs_find_base (binfo, data)\n \t  ? binfo : NULL_TREE);\n }\n \n+/* Update a entry in the vtable for BINFO, which is in the hierarchy\n+   dominated by T.  FN has been overridden in BINFO; VIRTUALS points\n+   to the corresponding position in the BINFO_VIRTUALS list.  */\n+\n+static void\n+update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n+     tree t;\n+     tree binfo;\n+     tree fn;\n+     tree *virtuals;\n+{\n+  tree b;\n+  tree overrider;\n+  tree vindex;\n+  tree delta;\n+  HOST_WIDE_INT vindex_val;\n+  HOST_WIDE_INT i;\n+\n+  /* Find the function which originally caused this vtable\n+     entry to be present.  */\n+  vindex = DECL_VINDEX (fn);\n+  b = dfs_walk (binfo, dfs_find_base, NULL, DECL_VIRTUAL_CONTEXT (fn));\n+  fn = BINFO_VIRTUALS (TYPE_BINFO (BINFO_TYPE (b)));\n+  i = first_vfun_index (BINFO_TYPE (b));\n+  vindex_val = tree_low_cst (vindex, 0);\n+  while (i < vindex_val)\n+    {\n+      fn = TREE_CHAIN (fn);\n+      ++i;\n+    }\n+  fn = BV_FN (fn);\n+\n+  /* Handle the case of a virtual function defined in BINFO itself.  */\n+  overrider = find_final_overrider (t, b, fn);\n+  if (overrider == error_mark_node)\n+    return;\n+\n+  /* Compute the constant adjustment to the `this' pointer.  The\n+     `this' pointer, when this function is called, will point at the\n+     class whose vtable this is.  */\n+  delta = size_binop (PLUS_EXPR,\n+\t\t      get_derived_offset (binfo,\n+\t\t\t\t\t  DECL_VIRTUAL_CONTEXT (fn)),\n+\t\t      BINFO_OFFSET (binfo));\n+  if (flag_new_abi)\n+    {\n+      /* Under the new ABI, we only need to adjust as far as the\n+\t nearest virtual base.  Then we use the vcall offset in the\n+\t virtual bases vtable.  */\n+      for (b = binfo; b; b = BINFO_INHERITANCE_CHAIN (b))\n+\t{\n+\t  if (TREE_VIA_VIRTUAL (b))\n+\t    break;\n+\t  if (same_type_p (BINFO_TYPE (b), \n+\t\t\t   BINFO_TYPE (TREE_VALUE (overrider))))\n+\t    break;\n+\t}\n+    }\n+  else\n+    b = NULL_TREE;\n+\n+  if (b && TREE_VIA_VIRTUAL (b))\n+    /* The `this' pointer needs to be adjusted to the nearest virtual\n+       base.  */\n+    delta = size_diffop (BINFO_OFFSET (b), delta);\n+  else\n+    /* The `this' pointer needs to be adjusted from pointing to\n+       BINFO to pointing at the base where the final overrider\n+       appears.  */\n+    delta = size_diffop (BINFO_OFFSET (TREE_VALUE (overrider)), delta);\n+\n+  modify_vtable_entry (t, \n+\t\t       binfo, \n+\t\t       TREE_PURPOSE (overrider),\n+\t\t       delta,\n+\t\t       virtuals);\n+}\n+\n /* Called from modify_all_vtables via dfs_walk.  */\n \n static tree\n@@ -2503,51 +2578,10 @@ dfs_modify_vtables (binfo, data)\n \t   virtuals;\n \t   virtuals = TREE_CHAIN (virtuals),\n \t     old_virtuals = TREE_CHAIN (old_virtuals))\n-\t{\n-\t  tree b;\n-\t  tree fn;\n-\t  tree overrider;\n-\t  tree vindex;\n-\t  tree delta;\n-\t  HOST_WIDE_INT vindex_val;\n-\t  HOST_WIDE_INT i;\n-\n-\t  /* Find the function which originally caused this vtable\n-\t     entry to be present.  */\n-\t  fn = BV_FN (old_virtuals);\n-\t  vindex = DECL_VINDEX (fn);\n-\t  b = dfs_walk (binfo, dfs_find_base, NULL, DECL_VIRTUAL_CONTEXT (fn));\n-\t  fn = BINFO_VIRTUALS (TYPE_BINFO (BINFO_TYPE (b)));\n-\t  i = first_vfun_index (BINFO_TYPE (b));\n-\t  vindex_val = tree_low_cst (vindex, 0);\n-\t  while (i < vindex_val)\n-\t    {\n-\t      fn = TREE_CHAIN (fn);\n-\t      ++i;\n-\t    }\n-\t  fn = BV_FN (fn);\n-\n-\t  /* Handle the case of a virtual function defined in BINFO\n-\t     itself.  */\n-\t  overrider = find_final_overrider (t, b, fn);\n-\t  if (overrider == error_mark_node)\n-\t    continue;\n-\n-\t  /* The `this' pointer needs to be adjusted from pointing to\n-\t     BINFO to pointing at the base where the final overrider\n-\t     appears.  */\n-\t  delta = size_binop (PLUS_EXPR,\n-\t\t\t      get_derived_offset (binfo,\n-\t\t\t\t\t\t  DECL_VIRTUAL_CONTEXT (fn)),\n-\t\t\t      BINFO_OFFSET (binfo));\n-\t  delta = size_diffop (BINFO_OFFSET (TREE_VALUE (overrider)), delta);\n-\n-\t  modify_vtable_entry (t, \n-\t\t\t       binfo, \n-\t\t\t       TREE_PURPOSE (overrider),\n-\t\t\t       delta,\n-\t\t\t       &virtuals);\n-\t}\n+\tupdate_vtable_entry_for_fn (t, \n+\t\t\t\t    binfo, \n+\t\t\t\t    BV_FN (old_virtuals),\n+\t\t\t\t    &virtuals);\n     }\n \n   SET_BINFO_MARKED (binfo);\n@@ -2591,8 +2625,8 @@ modify_all_vtables (t, vfuns_p, overridden_virtuals)\n \t{\n \t  tree fn = TREE_VALUE (*fnsp);\n \n-\t  if (BINFO_VIRTUALS (binfo)\n-\t      && !value_member (fn, BINFO_VIRTUALS (binfo)))\n+\t  if (!BINFO_VIRTUALS (binfo)\n+\t      || !value_member (fn, BINFO_VIRTUALS (binfo)))\n \t    {\n \t      /* Set the vtable index.  */\n \t      set_vindex (t, fn, vfuns_p);\n@@ -3891,7 +3925,7 @@ build_clone (fn, name)\n \tDECL_VINDEX (clone) = NULL_TREE;\n     }\n \n-  /* If there was an in-charge paramter, drop it from the function\n+  /* If there was an in-charge parameter, drop it from the function\n      type.  */\n   if (DECL_HAS_IN_CHARGE_PARM_P (clone))\n     {\n@@ -3990,11 +4024,14 @@ clone_function_decl (fn, update_method_vec_p)\n \n       /* For each destructor, we need two variants: an in-charge\n \t version, a not-in-charge version, and an in-charge deleting\n-\t version.  */\n-      clone = build_clone (fn, complete_dtor_identifier);\n+\t version.  We clone the deleting version first because that\n+\t means it will go second on the TYPE_METHODS list -- and that\n+\t corresponds to the correct layout order in the virtual\n+\t function table.  */\n+      clone = build_clone (fn, deleting_dtor_identifier);\n       if (update_method_vec_p)\n \tadd_method (DECL_CONTEXT (clone), NULL, clone);\n-      clone = build_clone (fn, deleting_dtor_identifier);\n+      clone = build_clone (fn, complete_dtor_identifier);\n       if (update_method_vec_p)\n \tadd_method (DECL_CONTEXT (clone), NULL, clone);\n       clone = build_clone (fn, base_dtor_identifier);\n@@ -6637,9 +6674,9 @@ build_vbase_offset_vtbl_entries (binfo, vod)\n \t\t\t\tvod->index, integer_one_node));\n \n       /* The initializer is the delta from BINFO to this virtual base.\n-\t   The vbase offsets go in reverse inheritance-graph order, and\n-\t   we are walking in inheritance graph order so these end up in\n-\t   the right order.  */\n+\t The vbase offsets go in reverse inheritance-graph order, and\n+\t we are walking in inheritance graph order so these end up in\n+\t the right order.  */\n       delta = size_diffop (BINFO_OFFSET (b), BINFO_OFFSET (binfo));\n       vod->inits = tree_cons (NULL_TREE, \n \t\t\t      fold (build1 (NOP_EXPR, \n@@ -6651,59 +6688,70 @@ build_vbase_offset_vtbl_entries (binfo, vod)\n \n /* Called from build_vcall_offset_vtbl_entries via dfs_walk.  */\n \n-static tree\n-dfs_vcall_offset_queue_p (binfo, data)\n-     tree binfo;\n-     void *data;\n-{\n-  vcall_offset_data* vod = (vcall_offset_data *) data;\n-\n-  return (binfo == vod->vbase) ? binfo : dfs_skip_vbases (binfo, NULL);\n-}\n-\n-/* Called from build_vcall_offset_vtbl_entries via dfs_walk.  */\n-\n static tree\n dfs_build_vcall_offset_vtbl_entries (binfo, data)\n      tree binfo;\n      void *data;\n {\n   vcall_offset_data* vod;\n-  tree virtuals;\n+  tree derived_virtuals;\n+  tree base_virtuals;\n   tree binfo_inits;\n+  tree non_primary_binfo;\n   tree b;\n   int i;\n \n   vod = (vcall_offset_data *) data;\n   binfo_inits = NULL_TREE;\n-  \n+\n+  /* We might be a primary base class.  Go up the inheritance\n+     hierarchy until we find the class of which we are a primary base:\n+     it is the BINFO_VIRTUALS there that we need to consider.  */\n+  non_primary_binfo = binfo;\n+  while (BINFO_PRIMARY_MARKED_P (non_primary_binfo))\n+    non_primary_binfo = BINFO_INHERITANCE_CHAIN (non_primary_binfo);\n+\n   /* Skip virtuals that we have already handled in a primary base\n      class.  */\n-  virtuals = BINFO_VIRTUALS (binfo);\n+  base_virtuals = BINFO_VIRTUALS (binfo);\n+  derived_virtuals = BINFO_VIRTUALS (non_primary_binfo);\n   b = BINFO_PRIMARY_BINFO (binfo);\n   if (b)\n     for (i = 0; i < CLASSTYPE_VSIZE (BINFO_TYPE (b)); ++i)\n-      virtuals = TREE_CHAIN (virtuals);\n+      {\n+\tbase_virtuals = TREE_CHAIN (base_virtuals);\n+\tderived_virtuals = TREE_CHAIN (derived_virtuals);\n+      }\n \n   /* Make entries for the rest of the virtuals.  */\n-  while (virtuals)\n+  while (base_virtuals)\n     {\n       /* Figure out what function we're looking at.  */\n-      tree fn = TREE_VALUE (virtuals);\n+      tree fn = TREE_VALUE (derived_virtuals);\n       tree base = DECL_CONTEXT (fn);\n       /* The FN comes from BASE.  So, we must caculate the adjustment\n \t from the virtual base that derived from BINFO to BASE.  */\n       tree base_binfo = get_binfo (base, vod->derived, /*protect=*/0);\n \n+      /* Compute the vcall offset.  */\n       binfo_inits\n \t= tree_cons (NULL_TREE,\n \t\t     fold (build1 (NOP_EXPR, vtable_entry_type,\n \t\t\t\t   size_diffop (BINFO_OFFSET (base_binfo),\n \t\t\t\t\t\tBINFO_OFFSET (vod->vbase)))),\n \t\t     binfo_inits);\n+\n+      /* Keep track of the vtable index where this vcall offset can be\n+\t found.  */\n+      BV_VCALL_INDEX (derived_virtuals) = vod->index;\n+      /* The next vcall offset will be found at a more negative\n+\t offset.  */\n       vod->index = fold (build (MINUS_EXPR, integer_type_node,\n \t\t\t\tvod->index, integer_one_node));\n-      virtuals = TREE_CHAIN (virtuals);\n+\n+      /* Go to the next entries in the list.  */\n+      derived_virtuals = TREE_CHAIN (derived_virtuals);\n+      base_virtuals = TREE_CHAIN (base_virtuals);\n     }\n \n   /* The offests are built up in reverse order, so we straighten them\n@@ -6772,7 +6820,7 @@ build_vcall_offset_vtbl_entries (binfo, vod)\n   dfs_walk_real (binfo,\n \t\t dfs_build_vcall_offset_vtbl_entries,\n \t\t NULL,\n-\t\t dfs_vcall_offset_queue_p,\n+\t\t dfs_skip_vbases,\n \t\t vod);\n   vod->inits = chainon (vod->inits, inits);\n }\n@@ -6880,7 +6928,7 @@ build_vtable_entry (delta, vcall_index, entry)\n       idelta = tree_low_cst (delta, 0);\n       ivindex = tree_low_cst (vcall_index, 0);\n       if ((idelta || ivindex) \n-\t  && ! DECL_PURE_VIRTUAL_P (TREE_OPERAND (entry, 0)))\n+\t  && TREE_OPERAND (entry, 0) != abort_fndecl)\n \t{\n \t  entry = make_thunk (entry, idelta, ivindex);\n \t  entry = build1 (ADDR_EXPR, vtable_entry_type, entry);\n@@ -6894,7 +6942,6 @@ build_vtable_entry (delta, vcall_index, entry)\n     }\n   else\n     {\n-      extern int flag_huge_objects;\n       tree elems = tree_cons (NULL_TREE, delta,\n \t\t\t      tree_cons (NULL_TREE, integer_zero_node,\n \t\t\t\t\t build_tree_list (NULL_TREE, entry)));"}, {"sha": "30ebe45b4508ae19c0e6cfa979a4778001ff5ed4", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7512c9d18b4bdd5a52a239746b4cd2b0a91399/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7512c9d18b4bdd5a52a239746b4cd2b0a91399/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=4e7512c9d18b4bdd5a52a239746b4cd2b0a91399", "patch": "@@ -161,8 +161,10 @@ DEFTREECODE (TYPEOF_TYPE, \"typeof_type\", 't', 0)\n /* A thunk is a stub function.\n \n    A THUNK_DECL is an alternate entry point for an ordinary\n-   FUNCTION_DECL.  It's job is to adjust the `this' poitner before\n-   transferring control to the FUNCTION_DECL.\n+   FUNCTION_DECL.  The address of the ordinary FUNCTION_DECL is given\n+   by the DECL_INITIAL, which is always an ADDR_EXPR whose operand is\n+   a FUNCTION_DECL.  The job of the thunk is to adjust the `this'\n+   pointer before transferring control to the FUNCTION_DECL.\n \n    A thunk may perform either, or both, of the following operations:\n "}, {"sha": "f63cb6b5da1e5098b4d2972ce59bce6fbae3e639", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7512c9d18b4bdd5a52a239746b4cd2b0a91399/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7512c9d18b4bdd5a52a239746b4cd2b0a91399/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4e7512c9d18b4bdd5a52a239746b4cd2b0a91399", "patch": "@@ -219,6 +219,11 @@ extern int flag_honor_std;\n \n extern int flag_rtti;\n \n+/* Nonzero if we want to support huge (> 2^(sizeof(short)*8-1) bytes)\n+   objects.  */\n+\n+extern int flag_huge_objects;\n+\n /* Nonzero if virtual base class offsets are stored in the virtual\n    function table.  Zero if, instead, a pointer to the virtual base is\n    stored in the object itself.  */\n@@ -1767,7 +1772,7 @@ struct lang_type\n \n       struct A {};\n       struct B : public A { };\n-      struct C : virtual public B { void f(); };\n+      struct C : virtual public B { void f(); int i; };\n \n    `A' is the primary base class for `B'.  But, `B' is not a primary\n    base class for `C'.  So, in the copy of `A' that appears in the"}, {"sha": "69a868f4021dab9317c20f71a5e59483d4fd245c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7512c9d18b4bdd5a52a239746b4cd2b0a91399/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7512c9d18b4bdd5a52a239746b4cd2b0a91399/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4e7512c9d18b4bdd5a52a239746b4cd2b0a91399", "patch": "@@ -336,10 +336,6 @@ extern int flag_no_builtin;\n \n extern int flag_no_nonansi_builtin;\n \n-/* Nonzero if we want to support huge (> 2^(sizeof(short)*8-1) bytes)\n-   objects.  */\n-extern int flag_huge_objects;\n-\n /* Nonzero if we want to conserve space in the .o files.  We do this\n    by putting uninitialized data and runtime initialized data into\n    .common instead of .data at the expense of not flagging multiple"}, {"sha": "206c88598503cc17f2e27e11c5d31ec14555c6bf", "filename": "gcc/cp/method.c", "status": "modified", "additions": 50, "deletions": 11, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7512c9d18b4bdd5a52a239746b4cd2b0a91399/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7512c9d18b4bdd5a52a239746b4cd2b0a91399/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=4e7512c9d18b4bdd5a52a239746b4cd2b0a91399", "patch": "@@ -2036,12 +2036,12 @@ make_thunk (function, delta, vcall_index)\n   else\n     icat (-delta);\n   OB_PUTC ('_');\n-  OB_PUTID (DECL_ASSEMBLER_NAME (func_decl));\n   if (vcall_index)\n     {\n-      OB_PUTC ('_');\n       icat (vcall_index);\n+      OB_PUTC ('_');\n     }\n+  OB_PUTID (DECL_ASSEMBLER_NAME (func_decl));\n   OB_FINISH ();\n   thunk_id = get_identifier (obstack_base (&scratch_obstack));\n \n@@ -2062,7 +2062,7 @@ make_thunk (function, delta, vcall_index)\n       DECL_INITIAL (thunk) = function;\n       THUNK_DELTA (thunk) = delta;\n       THUNK_VCALL_OFFSET (thunk) \n-\t= vcall_index * TREE_INT_CST_LOW (TYPE_SIZE (vtable_entry_type));\n+\t= vcall_index * int_size_in_bytes (vtable_entry_type);\n       DECL_EXTERNAL (thunk) = 1;\n       DECL_ARTIFICIAL (thunk) = 1;\n       /* So that finish_file can write out any thunks that need to be: */\n@@ -2077,8 +2077,10 @@ void\n emit_thunk (thunk_fndecl)\n      tree thunk_fndecl;\n {\n-  tree function = TREE_OPERAND (DECL_INITIAL (thunk_fndecl), 0);\n+  tree fnaddr = DECL_INITIAL (thunk_fndecl);\n+  tree function = TREE_OPERAND (fnaddr, 0);\n   int delta = THUNK_DELTA (thunk_fndecl);\n+  int vcall_offset = THUNK_VCALL_OFFSET (thunk_fndecl);\n \n   if (TREE_ASM_WRITTEN (thunk_fndecl))\n     return;\n@@ -2094,7 +2096,7 @@ emit_thunk (thunk_fndecl)\n   TREE_SET_CODE (thunk_fndecl, FUNCTION_DECL);\n \n #ifdef ASM_OUTPUT_MI_THUNK\n-  if (!flag_syntax_only)\n+  if (!flag_syntax_only && vcall_offset == 0)\n     {\n       const char *fnname;\n       current_function_decl = thunk_fndecl;\n@@ -2112,7 +2114,8 @@ emit_thunk (thunk_fndecl)\n       current_function_decl = 0;\n       cfun = 0;\n     }\n-#else /* ASM_OUTPUT_MI_THUNK */\n+#endif /* ASM_OUTPUT_MI_THUNK */\n+  else\n   {\n   /* If we don't have the necessary macro for efficient thunks, generate a\n      thunk function that just makes a call to the real function.\n@@ -2140,30 +2143,66 @@ emit_thunk (thunk_fndecl)\n     copy_lang_decl (thunk_fndecl);\n     DECL_INTERFACE_KNOWN (thunk_fndecl) = 1;\n     DECL_NOT_REALLY_EXTERN (thunk_fndecl) = 1;\n+    DECL_SAVED_FUNCTION_DATA (thunk_fndecl) = NULL;\n \n-    start_function (NULL_TREE, thunk_fndecl, NULL_TREE, \n-\t\t    SF_DEFAULT | SF_PRE_PARSED);\n+    push_to_top_level ();\n+    start_function (NULL_TREE, thunk_fndecl, NULL_TREE, SF_PRE_PARSED);\n     store_parm_decls ();\n     current_function_is_thunk = 1;\n \n-    /* Build up the call to the real function.  */\n-    t = build_int_2 (delta, -1 * (delta < 0));\n+    /* Adjust the this pointer by the constant.  */\n+    t = ssize_int (delta);\n     TREE_TYPE (t) = signed_type (sizetype);\n     t = fold (build (PLUS_EXPR, TREE_TYPE (a), a, t));\n+    /* If there's a vcall offset, look up that value in the vtable and\n+       adjust the `this' pointer again.  */\n+    if (vcall_offset != 0)\n+      {\n+\ttree orig_this;\n+\n+\tt = save_expr (t);\n+\torig_this = t;\n+\t/* The vptr is always at offset zero in the object.  */\n+\tt = build1 (NOP_EXPR,\n+\t\t    build_pointer_type (build_pointer_type \n+\t\t\t\t\t(vtable_entry_type)),\n+\t\t    t);\n+\t/* Form the vtable address.  */\n+\tt = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (t)), t);\n+\t/* Find the entry with the vcall offset.  */\n+\tt = build (PLUS_EXPR, TREE_TYPE (t), t, ssize_int (vcall_offset));\n+\t/* Calculate the offset itself.  */\n+\tt = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (t)), t);\n+\t/* Adjust the `this' pointer.  */\n+\tt = fold (build (PLUS_EXPR,\n+\t\t\t TREE_TYPE (orig_this),\n+\t\t\t orig_this,\n+\t\t\t t));\n+      }\n+\n+    /* Build up the call to the real function.  */\n     t = tree_cons (NULL_TREE, t, NULL_TREE);\n     for (a = TREE_CHAIN (a); a; a = TREE_CHAIN (a))\n       t = tree_cons (NULL_TREE, a, t);\n     t = nreverse (t);\n     t = build_call (function, t);\n     finish_return_stmt (t);\n \n+    /* The back-end expects DECL_INITIAL to contain a BLOCK, so we\n+       clear this here.  */\n+    DECL_INITIAL (thunk_fndecl) = NULL_TREE;\n+    DECL_INITIAL (thunk_fndecl) = make_node (BLOCK);\n+    BLOCK_VARS (DECL_INITIAL (thunk_fndecl)) \n+      = DECL_ARGUMENTS (thunk_fndecl);\n     expand_body (finish_function (0));\n+    /* Restore the DECL_INITIAL for the THUNK_DECL.  */\n+    DECL_INITIAL (thunk_fndecl) = fnaddr;\n+    pop_from_top_level ();\n \n     /* Don't let the backend defer this function.  */\n     if (DECL_DEFER_OUTPUT (thunk_fndecl))\n       output_inline_function (thunk_fndecl);\n   }\n-#endif /* ASM_OUTPUT_MI_THUNK */\n \n   TREE_SET_CODE (thunk_fndecl, THUNK_DECL);\n }"}, {"sha": "8c4c93eb6670465071503a49b0cbb5c3a0759208", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vtable2.C", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7512c9d18b4bdd5a52a239746b4cd2b0a91399/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7512c9d18b4bdd5a52a239746b4cd2b0a91399/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable2.C?ref=4e7512c9d18b4bdd5a52a239746b4cd2b0a91399", "patch": "@@ -108,10 +108,10 @@ void S4::s1 ()\n \n    S2-in-S4 secondary vtable\n \n-     S4::s1 vcall offset\n      S1 vbase offset\n-     S2:s0 vcall offset\n+     S4::s1 vcall offset\n      S0 vbase offset\n+     S2:s0 vcall offset\n      S2 offset to top\n      S4 RTTI\n      S2::s0\n@@ -151,10 +151,12 @@ int main ()\n     return 5;\n   if (*vtbl++ != (ptrdiff_t) &s1__2S4)\n     return 6;\n-  // All the vcall and vbase offsets should be zero.\n+  // The S1 vbase offset.\n   if (*vtbl++ != 0)\n     return 7;\n-  if (*vtbl++ != 0)\n+  // The S4::s1 vcall offset is negative; once you convert to S2, you\n+  // have to convert to S4 to find the final overrider.\n+  if (*vtbl++ != ((char*) &s4 - (char*) (S2*) &s4))\n     return 8;\n   if (*vtbl++ != 0)\n     return 9;"}]}