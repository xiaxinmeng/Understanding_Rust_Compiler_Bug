{"sha": "0d00888247bcfe39791153f9aa1fd8734f58bc74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQwMDg4ODI0N2JjZmUzOTc5MTE1M2Y5YWExZmQ4NzM0ZjU4YmM3NA==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-06-09T21:32:37Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-06-09T21:32:37Z"}, "message": "re PR target/6526 ([SH4] sdivsi3_i4 can clobber xd0/xd2)\n\n\tPR target/6526\n\t* config/sh/lib1funcs.S (sdivsi3_i4, udivsi3_i4): Do not change bits\n\tother than FPSCR.PR and FPSCR.SZ.  Add SH4A implementation.\n\n\tPR target/6526\n\t* gcc.target/sh/pr6526.c: New.\n\nFrom-SVN: r199873", "tree": {"sha": "5cfdce74e6c97d2a997232dd0f3a63aab12de94e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cfdce74e6c97d2a997232dd0f3a63aab12de94e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d00888247bcfe39791153f9aa1fd8734f58bc74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d00888247bcfe39791153f9aa1fd8734f58bc74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d00888247bcfe39791153f9aa1fd8734f58bc74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d00888247bcfe39791153f9aa1fd8734f58bc74/comments", "author": null, "committer": null, "parents": [{"sha": "3e56ed50d74ae33d87353df9a5aff5c247a81349", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e56ed50d74ae33d87353df9a5aff5c247a81349", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e56ed50d74ae33d87353df9a5aff5c247a81349"}], "stats": {"total": 300, "additions": 230, "deletions": 70}, "files": [{"sha": "cae5502642f4400e4d4ef77cd09284318aa2dea8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d00888247bcfe39791153f9aa1fd8734f58bc74/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d00888247bcfe39791153f9aa1fd8734f58bc74/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0d00888247bcfe39791153f9aa1fd8734f58bc74", "patch": "@@ -1,3 +1,8 @@\n+2013-06-09  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/6526\n+\t* gcc.target/sh/pr6526.c: New.\n+\n 2013-06-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/57568"}, {"sha": "a7dd6d87af64b572632c6760f73d27ef828caafc", "filename": "gcc/testsuite/gcc.target/sh/pr6526.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d00888247bcfe39791153f9aa1fd8734f58bc74/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr6526.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d00888247bcfe39791153f9aa1fd8734f58bc74/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr6526.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr6526.c?ref=0d00888247bcfe39791153f9aa1fd8734f58bc74", "patch": "@@ -0,0 +1,64 @@\n+/* Check that the XF registers are not clobbered by an integer division\n+   that is done using double precision FPU division.  */\n+/* { dg-do run { target \"sh*-*-*\" } }  */\n+/* { dg-options \"-O1 -mdiv=call-fp\" }  */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"*\" } { \"-m4*-single\" \"-m4*-single-only\" } }  */\n+\n+#include <assert.h>\n+#include <stdlib.h>\n+\n+extern void __set_fpscr (int);\n+\n+void\n+write_xf0 (float* f)\n+{\n+  __asm__ __volatile__ (\"frchg; fmov.s @%0,fr0; frchg\" : : \"r\" (f) : \"memory\");\n+}\n+ \n+void\n+read_xf0 (float* f)\n+{\n+  __asm__ __volatile__ (\"frchg; fmov.s fr0,@%0; frchg\" : : \"r\" (f) : \"memory\");\n+}\n+\n+int __attribute__ ((noinline))\n+test_00 (int a, int b)\n+{\n+  return a / b;\n+}\n+\n+unsigned int __attribute__ ((noinline))\n+test_01 (unsigned a, unsigned b)\n+{\n+  return a / b;\n+}\n+\n+int __attribute__ ((noinline))\n+test_02 (int x)\n+{\n+  return x & 0;\n+}\n+\n+int\n+main (void)\n+{\n+  float test_value;\n+  int r = 0;\n+\n+  /* Set FPSCR.FR to 1.  */\n+  __set_fpscr (0x200000);\n+\n+  test_value = 123;\n+  write_xf0 (&test_value);\n+  r += test_00 (40, 4);\n+  read_xf0 (&test_value);\n+  assert (test_value == 123);\n+\n+  test_value = 321;\n+  write_xf0 (&test_value);\n+  r += test_01 (50, 5);\n+  read_xf0 (&test_value);\n+  assert (test_value == 321);\n+\n+  return test_02 (r);\n+}"}, {"sha": "832b4256e6986a1aecb2eb090c6e38777ec0a7bf", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d00888247bcfe39791153f9aa1fd8734f58bc74/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d00888247bcfe39791153f9aa1fd8734f58bc74/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=0d00888247bcfe39791153f9aa1fd8734f58bc74", "patch": "@@ -1,3 +1,9 @@\n+2013-06-09  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/6526\n+\t* config/sh/lib1funcs.S (sdivsi3_i4, udivsi3_i4): Do not change bits\n+\tother than FPSCR.PR and FPSCR.SZ.  Add SH4A implementation.\n+\n 2013-06-08  Walter Lee  <walt@tilera.com>\n \n \t* config/tilepro/atomic.h: Don't include stdint.h or features.h."}, {"sha": "51addf360cf2c8322d870b73877f6431e2afccfa", "filename": "libgcc/config/sh/lib1funcs.S", "status": "modified", "additions": 155, "deletions": 70, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d00888247bcfe39791153f9aa1fd8734f58bc74/libgcc%2Fconfig%2Fsh%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d00888247bcfe39791153f9aa1fd8734f58bc74/libgcc%2Fconfig%2Fsh%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fsh%2Flib1funcs.S?ref=0d00888247bcfe39791153f9aa1fd8734f58bc74", "patch": "@@ -1003,11 +1003,17 @@ hiset:\tsts\tmacl,r0\t\t! r0 = bb*dd\n \tENDFUNC(GLOBAL(mulsi3))\n #endif\n #endif /* ! __SH5__ */\n+\n+/*------------------------------------------------------------------------------\n+  32 bit signed integer division that uses FPU double precision division.  */\n+\n #ifdef L_sdivsi3_i4\n \t.title \"SH DIVIDE\"\n-!! 4 byte integer Divide code for the Renesas SH\n+\n #if defined (__SH4__) || defined (__SH2A__)\n-!! args in r4 and r5, result in fpul, clobber dr0, dr2\n+/* This variant is used when FPSCR.PR = 1 (double precision) is the default\n+   setting.\n+   Args in r4 and r5, result in fpul, clobber dr0, dr2.  */\n \n \t.global\tGLOBAL(sdivsi3_i4)\n \tHIDDEN_FUNC(GLOBAL(sdivsi3_i4))\n@@ -1021,8 +1027,13 @@ GLOBAL(sdivsi3_i4):\n \tftrc dr0,fpul\n \n \tENDFUNC(GLOBAL(sdivsi3_i4))\n+\n #elif defined (__SH2A_SINGLE__) || defined (__SH2A_SINGLE_ONLY__) || defined(__SH4_SINGLE__) || defined(__SH4_SINGLE_ONLY__) || (defined (__SH5__) && ! defined __SH4_NOFPU__)\n-!! args in r4 and r5, result in fpul, clobber r2, dr0, dr2\n+/* This variant is used when FPSCR.PR = 0 (sigle precision) is the default\n+   setting.\n+   Args in r4 and r5, result in fpul, clobber r2, dr0, dr2.\n+   For this to work, we must temporarily switch the FPU do double precision,\n+   but we better do not touch FPSCR.FR.  See PR 6526.  */\n \n #if ! __SH5__ || __SH5__ == 32\n #if __SH5__\n@@ -1031,24 +1042,43 @@ GLOBAL(sdivsi3_i4):\n \t.global\tGLOBAL(sdivsi3_i4)\n \tHIDDEN_FUNC(GLOBAL(sdivsi3_i4))\n GLOBAL(sdivsi3_i4):\n-\tsts.l fpscr,@-r15\n-\tmov #8,r2\n-\tswap.w r2,r2\n-\tlds r2,fpscr\n-\tlds r4,fpul\n-\tfloat fpul,dr0\n-\tlds r5,fpul\n-\tfloat fpul,dr2\n-\tfdiv dr2,dr0\n-\tftrc dr0,fpul\n+\n+#ifndef __SH4A__\n+\tmov.l\tr3,@-r15\n+\tsts\tfpscr,r2\n+\tmov\t#8,r3\n+\tswap.w\tr3,r3\t\t// r3 = 1 << 19 (FPSCR.PR bit)\n+\tor\tr2,r3\n+\tlds\tr3,fpscr\t// Set FPSCR.PR = 1.\n+\tlds\tr4,fpul\n+\tfloat\tfpul,dr0\n+\tlds\tr5,fpul\n+\tfloat\tfpul,dr2\n+\tfdiv\tdr2,dr0\n+\tftrc\tdr0,fpul\n+\tlds\tr2,fpscr\n \trts\n-\tlds.l @r15+,fpscr\n+\tmov.l\t@r15+,r3\n+#else\n+/* On SH4A we can use the fpchg instruction to flip the FPSCR.PR bit.  */\n+\tfpchg\n+\tlds\tr4,fpul\n+\tfloat\tfpul,dr0\n+\tlds\tr5,fpul\n+\tfloat\tfpul,dr2\n+\tfdiv\tdr2,dr0\n+\tftrc\tdr0,fpul\n+\trts\n+\tfpchg\t\n+\n+#endif /* __SH4A__  */\n \n \tENDFUNC(GLOBAL(sdivsi3_i4))\n #endif /* ! __SH5__ || __SH5__ == 32 */\n #endif /* ! __SH4__ || __SH2A__  */\n-#endif\n+#endif /* L_sdivsi3_i4  */\n \n+//------------------------------------------------------------------------------\n #ifdef L_sdivsi3\n /* __SH4_SINGLE_ONLY__ keeps this part for link compatibility with\n    sh2e/sh3e code.  */\n@@ -1367,54 +1397,60 @@ div0:\trts\n \tmov\t#0,r0\n \n \tENDFUNC(GLOBAL(sdivsi3))\n-#endif /* ! __SHMEDIA__ */\n-#endif\n-#ifdef L_udivsi3_i4\n+#endif /* ! __SHMEDIA__  */\n+#endif /* L_sdivsi3  */\n+\n+/*------------------------------------------------------------------------------\n+  32 bit unsigned integer division that uses FPU double precision division.  */\n \n+#ifdef L_udivsi3_i4\n \t.title \"SH DIVIDE\"\n-!! 4 byte integer Divide code for the Renesas SH\n+\n #if defined (__SH4__) || defined (__SH2A__)\n-!! args in r4 and r5, result in fpul, clobber r0, r1, r4, r5, dr0, dr2, dr4,\n-!! and t bit\n+/* This variant is used when FPSCR.PR = 1 (double precision) is the default\n+   setting.\n+   Args in r4 and r5, result in fpul,\n+   clobber r0, r1, r4, r5, dr0, dr2, dr4, and t bit  */\n \n \t.global\tGLOBAL(udivsi3_i4)\n \tHIDDEN_FUNC(GLOBAL(udivsi3_i4))\n GLOBAL(udivsi3_i4):\n-\tmov #1,r1\n-\tcmp/hi r1,r5\n-\tbf trivial\n-\trotr r1\n-\txor r1,r4\n-\tlds r4,fpul\n-\tmova L1,r0\n+\tmov\t#1,r1\n+\tcmp/hi\tr1,r5\n+\tbf/s\ttrivial\n+\trotr\tr1\n+\txor\tr1,r4\n+\tlds\tr4,fpul\n+\tmova\tL1,r0\n #ifdef FMOVD_WORKS\n-\tfmov.d @r0+,dr4\n+\tfmov.d\t@r0+,dr4\n #else\n-\tfmov.s @r0+,DR40\n-\tfmov.s @r0,DR41\n+\tfmov.s\t@r0+,DR40\n+\tfmov.s\t@r0,DR41\n #endif\n-\tfloat fpul,dr0\n-\txor r1,r5\n-\tlds r5,fpul\n-\tfloat fpul,dr2\n-\tfadd dr4,dr0\n-\tfadd dr4,dr2\n-\tfdiv dr2,dr0\n+\tfloat\tfpul,dr0\n+\txor\tr1,r5\n+\tlds\tr5,fpul\n+\tfloat\tfpul,dr2\n+\tfadd\tdr4,dr0\n+\tfadd\tdr4,dr2\n+\tfdiv\tdr2,dr0\n \trts\n-\tftrc dr0,fpul\n+\tftrc\tdr0,fpul\n \n trivial:\n \trts\n-\tlds r4,fpul\n+\tlds\tr4,fpul\n \n \t.align 2\n #ifdef FMOVD_WORKS\n-\t.align 3\t! make double below 8 byte aligned.\n+\t.align 3\t// Make the double below 8 byte aligned.\n #endif\n L1:\n \t.double 2147483648\n \n \tENDFUNC(GLOBAL(udivsi3_i4))\n+\n #elif defined (__SH5__) && ! defined (__SH4_NOFPU__) && ! defined (__SH2A_NOFPU__)\n #if ! __SH5__ || __SH5__ == 32\n !! args in r4 and r5, result in fpul, clobber r20, r21, dr0, fr33\n@@ -1436,57 +1472,106 @@ GLOBAL(udivsi3_i4):\n \n \tENDFUNC(GLOBAL(udivsi3_i4))\n #endif /* ! __SH5__ || __SH5__ == 32 */\n+\n #elif defined (__SH2A_SINGLE__) || defined (__SH2A_SINGLE_ONLY__) || defined(__SH4_SINGLE__) || defined(__SH4_SINGLE_ONLY__)\n-!! args in r4 and r5, result in fpul, clobber r0, r1, r4, r5, dr0, dr2, dr4\n+/* This variant is used when FPSCR.PR = 0 (sigle precision) is the default\n+   setting.\n+   Args in r4 and r5, result in fpul,\n+   clobber r0, r1, r4, r5, dr0, dr2, dr4.\n+   For this to work, we must temporarily switch the FPU do double precision,\n+   but we better do not touch FPSCR.FR.  See PR 6526.  */\n \n \t.global\tGLOBAL(udivsi3_i4)\n \tHIDDEN_FUNC(GLOBAL(udivsi3_i4))\n GLOBAL(udivsi3_i4):\n-\tmov #1,r1\n-\tcmp/hi r1,r5\n-\tbf trivial\n-\tsts.l fpscr,@-r15\n-\tmova L1,r0\n-\tlds.l @r0+,fpscr\n-\trotr r1\n-\txor r1,r4\n-\tlds r4,fpul\n+\n+#ifndef __SH4A__\n+\tmov\t#1,r1\n+\tcmp/hi\tr1,r5\n+\tbf/s\ttrivial\n+\trotr\tr1\t\t// r1 = 1 << 31\n+\tsts.l\tfpscr,@-r15\n+\txor\tr1,r4\n+\tmov.l\t@(0,r15),r0\n+\txor\tr1,r5\n+\tmov.l\tL2,r1\n+\tlds\tr4,fpul\n+\tor\tr0,r1\n+\tmova\tL1,r0\n+\tlds\tr1,fpscr\n #ifdef FMOVD_WORKS\n-\tfmov.d @r0+,dr4\n+\tfmov.d\t@r0+,dr4\n #else\n-\tfmov.s @r0+,DR40\n-\tfmov.s @r0,DR41\n+\tfmov.s\t@r0+,DR40\n+\tfmov.s\t@r0,DR41\n #endif\n-\tfloat fpul,dr0\n-\txor r1,r5\n-\tlds r5,fpul\n-\tfloat fpul,dr2\n-\tfadd dr4,dr0\n-\tfadd dr4,dr2\n-\tfdiv dr2,dr0\n-\tftrc dr0,fpul\n+\tfloat\tfpul,dr0\n+\tlds\tr5,fpul\n+\tfloat\tfpul,dr2\n+\tfadd\tdr4,dr0\n+\tfadd\tdr4,dr2\n+\tfdiv\tdr2,dr0\n+\tftrc\tdr0,fpul\n \trts\n-\tlds.l @r15+,fpscr\n+\tlds.l\t@r15+,fpscr\n \n #ifdef FMOVD_WORKS\n-\t.align 3\t! make double below 8 byte aligned.\n+\t.align 3\t// Make the double below 8 byte aligned.\n #endif\n trivial:\n \trts\n-\tlds r4,fpul\n+\tlds\tr4,fpul\n \n \t.align 2\n-L1:\n-#ifndef FMOVD_WORKS\n-\t.long 0x80000\n+L2:\n+#ifdef FMOVD_WORKS\n+\t.long 0x180000\t// FPSCR.PR = 1, FPSCR.SZ = 1\n #else\n-\t.long 0x180000\n+\t.long 0x80000\t// FPSCR.PR = 1\n #endif\n+L1:\n+\t.double 2147483648\n+\n+#else\n+/* On SH4A we can use the fpchg instruction to flip the FPSCR.PR bit.\n+   Although on SH4A fmovd usually works, it would require either additional\n+   two fschg instructions or an FPSCR push + pop.  It's not worth the effort\n+   for loading only one double constant.  */\n+\tmov\t#1,r1\n+\tcmp/hi\tr1,r5\n+\tbf/s\ttrivial\n+\trotr\tr1\t\t// r1 = 1 << 31\n+\tfpchg\n+\tmova\tL1,r0\n+\txor\tr1,r4\n+\tfmov.s\t@r0+,DR40\n+\tlds\tr4,fpul\n+\tfmov.s\t@r0,DR41\n+\txor\tr1,r5\n+\tfloat\tfpul,dr0\n+\tlds\tr5,fpul\n+\tfloat\tfpul,dr2\n+\tfadd\tdr4,dr0\n+\tfadd\tdr4,dr2\n+\tfdiv\tdr2,dr0\n+\tftrc\tdr0,fpul\n+\trts\n+\tfpchg\n+\n+trivial:\n+\trts\n+\tlds\tr4,fpul\n+\n+\t.align 2\n+L1:\n \t.double 2147483648\n \n+#endif /* __SH4A__  */\n+\n+\n \tENDFUNC(GLOBAL(udivsi3_i4))\n #endif /* ! __SH4__ */\n-#endif\n+#endif /* L_udivsi3_i4  */\n \n #ifdef L_udivsi3\n /* __SH4_SINGLE_ONLY__ keeps this part for link compatibility with"}]}