{"sha": "3daa7bbf7912030a760199f31a0926a11365a76f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RhYTdiYmY3OTEyMDMwYTc2MDE5OWYzMWEwOTI2YTExMzY1YTc2Zg==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2014-10-04T14:53:41Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2014-10-04T14:53:41Z"}, "message": "remove score-* support\n\nlibgcc/ChangeLog:\n\n2014-10-04  Trevor Saunders  <tsaunders@mozilla.com>\n\n\t* config.host: Remove support for score-*.\n\ncontrib/ChangeLog:\n\n2014-10-04  Trevor Saunders  <tsaunders@mozilla.com>\n\n\t* compare-all-tests: Don't test score-*.\n\t* config-list.mk: Likewise.\n\ngcc/ChangeLog:\n\n2014-10-04  Trevor Saunders  <tsaunders@mozilla.com>\n\n\t* common/config/score/score-common.c: Remove.\n\t* config.gcc: Remove support for score-*.\n\t* config/score/constraints.md: Remove.\n\t* config/score/elf.h: Remove.\n\t* config/score/predicates.md: Remove.\n\t* config/score/score-conv.h: Remove.\n\t* config/score/score-generic.md: Remove.\n\t* config/score/score-modes.def: Remove.\n\t* config/score/score-protos.h: Remove.\n\t* config/score/score.c: Remove.\n\t* config/score/score.h: Remove.\n\t* config/score/score.md: Remove.\n\t* config/score/score.opt: Remove.\n\t* doc/md.texi: Don't document score-*.\n\nFrom-SVN: r215889", "tree": {"sha": "96ae78bbc59bddf37d613b584d9e6baa63d5757f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96ae78bbc59bddf37d613b584d9e6baa63d5757f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3daa7bbf7912030a760199f31a0926a11365a76f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3daa7bbf7912030a760199f31a0926a11365a76f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3daa7bbf7912030a760199f31a0926a11365a76f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3daa7bbf7912030a760199f31a0926a11365a76f/comments", "author": null, "committer": null, "parents": [{"sha": "bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8"}], "stats": {"total": 5514, "additions": 33, "deletions": 5481}, "files": [{"sha": "b340f875f360e403d788eaeaba471551701d0dbc", "filename": "contrib/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daa7bbf7912030a760199f31a0926a11365a76f/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daa7bbf7912030a760199f31a0926a11365a76f/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=3daa7bbf7912030a760199f31a0926a11365a76f", "patch": "@@ -1,3 +1,8 @@\n+2014-10-04  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* compare-all-tests: Don't test score-*.\n+\t* config-list.mk: Likewise.\n+\n 2014-10-02  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* dg-extract-results.py (output_variation): Always sort if do_sum."}, {"sha": "444e3b5b7e39cf7780045f88ff1d908a2ca4927d", "filename": "contrib/compare-all-tests", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daa7bbf7912030a760199f31a0926a11365a76f/contrib%2Fcompare-all-tests", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daa7bbf7912030a760199f31a0926a11365a76f/contrib%2Fcompare-all-tests", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fcompare-all-tests?ref=3daa7bbf7912030a760199f31a0926a11365a76f", "patch": "@@ -31,12 +31,11 @@ mn10300_opts='-mam33 -mam33-2'\n pa_opts='-march=2.0 -march=1.0 -march=1.1'\n ppc_opts='-m32 -m64'\n s390_opts='-m31 -m31/-mzarch -m64'\n-score_opts='-mscore3 -mscore7'\n sh64_opts='-m5-32media -m5-32media-nofpu -m5-64media -m5-64media-nofpu -m5-compact -m5-compact-nofpu'\n sh_opts='-m3 -m3e -m4 -m4a -m4al -m4/-mieee -m1 -m1/-mno-cbranchdi -m2a -m2a/-mieee -m2e -m2e/-mieee'\n sparc_opts='-mcpu=v8/-m32 -mcpu=v9/-m32 -m64'\n \n-all_targets='alpha arm avr bfin cris fr30 frv h8300 ia64 iq2000 m32c m32r m68k mcore mips mmix mn10300 pa pdp11 ppc score sh sh64 sparc spu v850 vax xstormy16 xtensa' # e500 \n+all_targets='alpha arm avr bfin cris fr30 frv h8300 ia64 iq2000 m32c m32r m68k mcore mips mmix mn10300 pa pdp11 ppc sh sh64 sparc spu v850 vax xstormy16 xtensa' # e500 \n \n test_one_file ()\n {"}, {"sha": "94884d9b25529422932e909f32d5486b964df034", "filename": "contrib/config-list.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daa7bbf7912030a760199f31a0926a11365a76f/contrib%2Fconfig-list.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daa7bbf7912030a760199f31a0926a11365a76f/contrib%2Fconfig-list.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fconfig-list.mk?ref=3daa7bbf7912030a760199f31a0926a11365a76f", "patch": "@@ -76,7 +76,7 @@ LIST = aarch64-elf aarch64-linux-gnu \\\n   x86_64-knetbsd-gnu x86_64-w64-mingw32 \\\n   x86_64-mingw32OPT-enable-sjlj-exceptions=yes xstormy16-elf xtensa-elf \\\n   xtensa-linux \\\n-  i686-interix3OPT-enable-obsolete score-elfOPT-enable-obsolete\n+  i686-interix3OPT-enable-obsolete\n \n LOGFILES = $(patsubst %,log/%-make.out,$(LIST))\n all: $(LOGFILES)"}, {"sha": "b8bc17b8699d51930a9f27e8562141ef7f0d16e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daa7bbf7912030a760199f31a0926a11365a76f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daa7bbf7912030a760199f31a0926a11365a76f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3daa7bbf7912030a760199f31a0926a11365a76f", "patch": "@@ -1,7 +1,24 @@\n+2014-10-04  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* common/config/score/score-common.c: Remove.\n+\t* config.gcc: Remove support for score-*.\n+\t* config/score/constraints.md: Remove.\n+\t* config/score/elf.h: Remove.\n+\t* config/score/predicates.md: Remove.\n+\t* config/score/score-conv.h: Remove.\n+\t* config/score/score-generic.md: Remove.\n+\t* config/score/score-modes.def: Remove.\n+\t* config/score/score-protos.h: Remove.\n+\t* config/score/score.c: Remove.\n+\t* config/score/score.h: Remove.\n+\t* config/score/score.md: Remove.\n+\t* config/score/score.opt: Remove.\n+\t* doc/md.texi: Don't document score-*.\n+\n 2014-10-04  Trevor Saunders  <tsaunders@mozilla.com>\n     \n-    \tPR pch/63429\n-    \t* genconditions.c: Directly include ggc.h before rtl.h.\n+\tPR pch/63429\n+\t* genconditions.c: Directly include ggc.h before rtl.h.\n \n 2014-10-03  Jan Hubicka  <hubicka@ucw.cz>\n "}, {"sha": "51bd9553ae45c4b5d440e9ee8aaa9ab22a3db34b", "filename": "gcc/common/config/score/score-common.c", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fcommon%2Fconfig%2Fscore%2Fscore-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fcommon%2Fconfig%2Fscore%2Fscore-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fscore%2Fscore-common.c?ref=bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8", "patch": "@@ -1,74 +0,0 @@\n-/* Common hooks for Sunplus S+CORE.\n-   Copyright (C) 2005-2014 Free Software Foundation, Inc.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"common/common-target.h\"\n-#include \"common/common-target-def.h\"\n-#include \"opts.h\"\n-#include \"flags.h\"\n-\n-/* Implement TARGET_OPTION_OPTIMIZATION_TABLE.  */\n-static const struct default_options score_option_optimization_table[] =\n-  {\n-    { OPT_LEVELS_1_PLUS, OPT_fomit_frame_pointer, NULL, 1 },\n-    { OPT_LEVELS_NONE, 0, NULL, 0 }\n-  };\n-\n-#undef TARGET_DEFAULT_TARGET_FLAGS\n-#define TARGET_DEFAULT_TARGET_FLAGS     TARGET_DEFAULT\n-\n-#undef TARGET_HANDLE_OPTION\n-#define TARGET_HANDLE_OPTION            score_handle_option\n-\n-#undef TARGET_OPTION_OPTIMIZATION_TABLE\n-#define TARGET_OPTION_OPTIMIZATION_TABLE score_option_optimization_table\n-\n-#define MASK_ALL_CPU_BITS\t(MASK_SCORE7 | MASK_SCORE7D)\n-\n-/* Implement TARGET_HANDLE_OPTION.  */\n-static bool\n-score_handle_option (struct gcc_options *opts,\n-\t\t     struct gcc_options *opts_set ATTRIBUTE_UNUSED,\n-\t\t     const struct cl_decoded_option *decoded,\n-\t\t     location_t loc ATTRIBUTE_UNUSED)\n-{\n-  size_t code = decoded->opt_index;\n-  int value = decoded->value;\n-\n-  switch (code)\n-    {\n-    case OPT_mscore7d:\n-      opts->x_target_flags &= ~(MASK_ALL_CPU_BITS);\n-      opts->x_target_flags |= MASK_SCORE7 | MASK_SCORE7D;\n-      return true;\n-\n-    case OPT_march_:\n-      opts->x_target_flags &= ~(MASK_ALL_CPU_BITS);\n-      opts->x_target_flags |= value;\n-      return true;\n-\n-    default:\n-      return true;\n-    }\n-}\n-\n-struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;"}, {"sha": "d8f5593fc6dc79a640caed3c99b6a5242bdb18e9", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daa7bbf7912030a760199f31a0926a11365a76f/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daa7bbf7912030a760199f31a0926a11365a76f/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=3daa7bbf7912030a760199f31a0926a11365a76f", "patch": "@@ -236,7 +236,8 @@ md_file=\n \n # Obsolete configurations.\n case ${target} in\n- score-*\t\t\t\t\\\n+# Currently there are no obsolete targets.\n+ nothing\t\t\t\t\\\n  )\n     if test \"x$enable_obsolete\" != xyes; then\n       echo \"*** Configuration ${target} is obsolete.\" >&2\n@@ -432,10 +433,6 @@ powerpc*-*-*)\n rs6000*-*-*)\n \textra_options=\"${extra_options} g.opt fused-madd.opt rs6000/rs6000-tables.opt\"\n \t;;\n-score*-*-*)\n-\tcpu_type=score\n-\textra_options=\"${extra_options} g.opt\"\n-\t;;\n sparc*-*-*)\n \tcpu_type=sparc\n \tc_target_objs=\"sparc-c.o\"\n@@ -2441,11 +2438,6 @@ s390x-ibm-tpf*)\n         thread_file='tpf'\n \textra_options=\"${extra_options} s390/tpf.opt\"\n \t;;\n-score-*-elf)\n-\tgas=yes\n-\tgnu_ld=yes\n-        tm_file=\"dbxelf.h elfos.h score/elf.h score/score.h newlib-stdint.h\"\n-        ;;\n sh-*-elf* | sh[12346l]*-*-elf* | \\\n   sh-*-linux* | sh[2346lbe]*-*-linux* | \\\n   sh-*-netbsdelf* | shl*-*-netbsdelf* | sh5-*-netbsd* | sh5l*-*-netbsd* | \\"}, {"sha": "50b0ebfda7324b16f14fb453afd5b389fd97bf1c", "filename": "gcc/config/score/constraints.md", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fconstraints.md?ref=bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8", "patch": "@@ -1,93 +0,0 @@\n-;; Constraint definitions for S+CORE\n-;; Copyright (C) 2005-2014 Free Software Foundation, Inc.\n-;; Contributed by Sunnorth.\n-\n-;; This file is part of GCC.\n-\n-;; GCC is free software; you can redistribute it and/or modify it\n-;; under the terms of the GNU General Public License as published\n-;; by the Free Software Foundation; either version 3, or (at your\n-;; option) any later version.\n-\n-;; GCC is distributed in the hope that it will be useful, but WITHOUT\n-;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-;; License for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.  */\n-\n-;; -------------------------------------------------------------------------\n-;; Constraints\n-;; -------------------------------------------------------------------------\n-\n-;; Register constraints.\n-(define_register_constraint \"d\" \"G32_REGS\"\n-  \"r0 to r31\")\n-\n-(define_register_constraint \"e\" \"G16_REGS\"\n-  \"r0 to r15\")\n-\n-(define_register_constraint \"t\" \"T32_REGS\"\n-  \"r8 to r11 | r22 to r27\")\n-\n-(define_register_constraint \"h\" \"HI_REG\"\n-  \"hi\")\n-\n-(define_register_constraint \"l\" \"LO_REG\"\n-  \"lo\")\n-\n-(define_register_constraint \"x\" \"CE_REGS\"\n-  \"hi + lo\")\n-\n-(define_register_constraint \"q\" \"CN_REG\"\n-  \"cnt\")\n-\n-(define_register_constraint \"y\" \"LC_REG\"\n-  \"lcb\")\n-\n-(define_register_constraint \"z\" \"SC_REG\"\n-  \"scb\")\n-\n-(define_register_constraint \"a\" \"SP_REGS\"\n-  \"cnt + lcb + scb\")\n-\n-(define_register_constraint \"c\" \"CR_REGS\"\n-  \"cr0 to cr15\")\n-\n-;; Integer constant constraints.\n-(define_constraint \"I\"\n-  \"High 16-bit constant (32-bit constant with 16 LSBs zero).\"\n-  (and (match_code \"const_int\")\n-       (match_test \"(ival & 0xffff) == 0\")))\n-\n-(define_constraint \"J\"\n-  \"Unsigned 5 bit integer (in the range 0 to 31).\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= 0 && ival <= 31\")))\n-\n-(define_constraint \"K\"\n-  \"Unsigned 16 bit integer (in the range 0 to 65535).\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= 0 && ival <= 65535\")))\n-\n-(define_constraint \"L\"\n-  \"Signed 16 bit integer (in the range \u221232768 to 32767).\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= -32768 && ival <= 32767\")))\n-\n-(define_constraint \"M\"\n-  \"Unsigned 14 bit integer (in the range 0 to 16383).\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= 0 && ival <= 16383\")))\n-\n-(define_constraint \"N\"\n-  \"Signed 14 bit integer (in the range \u22128192 to 8191).\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= -8192 && ival <= 8191\")))\n-\n-(define_constraint \"Z\"\n-  \"Any SYMBOL_REF.\"\n-  (and (match_code \"symbol_ref\")\n-       (match_test \"GET_CODE (op) == SYMBOL_REF\")))"}, {"sha": "a3fb8a9301efbf0227581797c0072a86e51c473a", "filename": "gcc/config/score/elf.h", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Felf.h?ref=bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8", "patch": "@@ -1,97 +0,0 @@\n-/* elf.h for Sunplus S+CORE processor\n-   Copyright (C) 2005-2014 Free Software Foundation, Inc.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#define OBJECT_FORMAT_ELF\n-\n-/* Biggest alignment supported by the object file format of this machine.  */\n-#undef  MAX_OFILE_ALIGNMENT\n-#define MAX_OFILE_ALIGNMENT        (32768 * 8)\n-\n-/* Switch into a generic section.  */\n-#undef  TARGET_ASM_NAMED_SECTION\n-#define TARGET_ASM_NAMED_SECTION  default_elf_asm_named_section\n-\n-/* The following macro defines the format used to output the second\n-   operand of the .type assembler directive.  */\n-#define TYPE_OPERAND_FMT        \"@%s\"\n-\n-#undef TYPE_ASM_OP\n-#define TYPE_ASM_OP             \"\\t.type\\t\"\n-\n-#undef SIZE_ASM_OP\n-#define SIZE_ASM_OP             \"\\t.size\\t\"\n-\n-/* A c expression whose value is a string containing the\n-   assembler operation to identify the following data as\n-   uninitialized global data.  */\n-#ifndef BSS_SECTION_ASM_OP\n-#define BSS_SECTION_ASM_OP      \"\\t.section\\t.bss\"\n-#endif\n-\n-#ifndef ASM_OUTPUT_ALIGNED_BSS\n-#define ASM_OUTPUT_ALIGNED_BSS asm_output_aligned_bss\n-#endif\n-\n-#define ASM_OUTPUT_DEF(FILE, LABEL1, LABEL2)                       \\\n-  do {                                                             \\\n-    fputc ('\\t', FILE);                                            \\\n-    assemble_name (FILE, LABEL1);                                  \\\n-    fputs (\" = \", FILE);                                           \\\n-    assemble_name (FILE, LABEL2);                                  \\\n-    fputc ('\\n', FILE);                                            \\\n- } while (0)\n-\n-\n-/* This is how we tell the assembler that a symbol is weak.  */\n-#undef  ASM_WEAKEN_LABEL\n-#define ASM_WEAKEN_LABEL(FILE, NAME) ASM_OUTPUT_WEAK_ALIAS (FILE, NAME, 0)\n-\n-#define ASM_OUTPUT_WEAK_ALIAS(FILE, NAME, VALUE)      \\\n-  do {                                                \\\n-    fputs (\"\\t.weak\\t\", FILE);                        \\\n-    assemble_name (FILE, NAME);                       \\\n-    if (VALUE)                                        \\\n-      {                                               \\\n-        fputc (' ', FILE);                            \\\n-        assemble_name (FILE, VALUE);                  \\\n-      }                                               \\\n-    fputc ('\\n', FILE);                               \\\n- } while (0)\n-\n-#define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)\n-\n-/* On elf, we *do* have support for the .init and .fini sections, and we\n-   can put stuff in there to be executed before and after `main'.  We let\n-   crtstuff.c and other files know this by defining the following symbols.\n-   The definitions say how to change sections to the .init and .fini\n-   sections.  This is the same for all known elf assemblers.  */\n-#undef  INIT_SECTION_ASM_OP\n-#define INIT_SECTION_ASM_OP     \"\\t.section\\t.init\"\n-#undef  FINI_SECTION_ASM_OP\n-#define FINI_SECTION_ASM_OP     \"\\t.section\\t.fini\"\n-\n-/* Don't set the target flags, this is done by the linker script */\n-#undef  LIB_SPEC\n-#define LIB_SPEC \"\"\n-\n-#undef  STARTFILE_SPEC\n-#define STARTFILE_SPEC          \"crti%O%s crtbegin%O%s\"\n-\n-#undef  ENDFILE_SPEC\n-#define ENDFILE_SPEC            \"crtend%O%s crtn%O%s\""}, {"sha": "543be72604957f5634df3b60239ede60ed9a1cad", "filename": "gcc/config/score/predicates.md", "status": "removed", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fpredicates.md?ref=bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8", "patch": "@@ -1,152 +0,0 @@\n-;; Predicate definitions for Sunplus S+CORE.\n-;; Copyright (C) 2005-2014 Free Software Foundation, Inc.\n-;;\n-;; This file is part of GCC.\n-;;\n-;; GCC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 3, or (at your option)\n-;; any later version.\n-;;\n-;; GCC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-;;\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.\n-\n-(define_predicate \"const_uimm5\"\n-  (match_code \"const_int\")\n-{\n-  return IMM_IN_RANGE (INTVAL (op), 5, 0);\n-})\n-\n-(define_predicate \"const_simm12\"\n-  (match_code \"const_int\")\n-{\n-  return IMM_IN_RANGE (INTVAL (op), 12, 1);\n-})\n-\n-(define_predicate \"const_simm15\"\n-  (match_code \"const_int\")\n-{\n-  return IMM_IN_RANGE (INTVAL (op), 15, 1);\n-})\n-\n-(define_predicate \"arith_operand\"\n-  (ior (match_code \"const_int\")\n-       (match_operand 0 \"register_operand\")))\n-\n-(define_predicate \"score_register_operand\"\n-  (match_code \"reg,subreg\")\n-{\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  return (GET_CODE (op) == REG)\n-          && (REGNO (op) != CC_REGNUM);\n-})\n-\n-(define_predicate \"const_call_insn_operand\"\n-  (match_code \"const,symbol_ref,label_ref\")\n-{\n-  enum score_symbol_type symbol_type;\n-\n-  return (score_symbolic_constant_p (op, &symbol_type)\n-          && (symbol_type == SYMBOL_GENERAL));\n-})\n-\n-(define_predicate \"call_insn_operand\"\n-  (ior (match_operand 0 \"const_call_insn_operand\")\n-       (match_operand 0 \"register_operand\")))\n-\n-(define_predicate \"hireg_operand\"\n-  (and (match_code \"reg\")\n-       (match_test \"REGNO (op) == HI_REGNUM\")))\n-\n-(define_predicate \"loreg_operand\"\n-  (and (match_code \"reg\")\n-       (match_test \"REGNO (op) == LO_REGNUM\")))\n-\n-(define_predicate \"sr0_operand\"\n-  (and (match_code \"reg\")\n-       (match_test \"REGNO (op) == CN_REGNUM\")))\n-\n-(define_predicate \"g32reg_operand\"\n-  (and (match_code \"reg\")\n-       (match_test \"GP_REG_P (REGNO (op))\")))\n-\n-(define_predicate \"branch_n_operator\"\n-  (match_code \"lt,ge\"))\n-\n-(define_predicate \"branch_nz_operator\"\n-  (match_code \"eq,ne,lt,ge\"))\n-\n-(define_predicate \"score_load_multiple_operation\"\n-  (match_code \"parallel\")\n-{\n-  int count = XVECLEN (op, 0);\n-  int dest_regno;\n-  int i;\n-\n-  /* Perform a quick check so we don't blow up below.  */\n-  if (count <= 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != MEM)\n-    return 0;\n-\n-  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n-\n-  for (i = 1; i < count; i++)\n-    {\n-      rtx elt = XVECEXP (op, 0, i);\n-\n-      if (GET_CODE (elt) != SET\n-          || GET_CODE (SET_DEST (elt)) != REG\n-          || GET_MODE (SET_DEST (elt)) != SImode\n-          || REGNO (SET_DEST (elt)) != (unsigned) (dest_regno + i)\n-          || GET_CODE (SET_SRC (elt)) != MEM\n-          || GET_MODE (SET_SRC (elt)) != SImode\n-          || GET_CODE (XEXP (SET_SRC (elt), 0)) != POST_INC)\n-        return 0;\n-    }\n-\n-  return 1;\n-})\n-\n-(define_predicate \"score_store_multiple_operation\"\n-  (match_code \"parallel\")\n-{\n-  int count = XVECLEN (op, 0);\n-  int src_regno;\n-  int i;\n-\n-  /* Perform a quick check so we don't blow up below.  */\n-  if (count <= 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != MEM\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != REG)\n-    return 0;\n-\n-  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, 0)));\n-\n-  for (i = 1; i < count; i++)\n-    {\n-      rtx elt = XVECEXP (op, 0, i);\n-\n-      if (GET_CODE (elt) != SET\n-          || GET_CODE (SET_SRC (elt)) != REG\n-          || GET_MODE (SET_SRC (elt)) != SImode\n-          || REGNO (SET_SRC (elt)) != (unsigned) (src_regno + i)\n-          || GET_CODE (SET_DEST (elt)) != MEM\n-          || GET_MODE (SET_DEST (elt)) != SImode\n-          || GET_CODE (XEXP (SET_DEST (elt), 0)) != PRE_DEC)\n-        return 0;\n-    }\n-\n-  return 1;\n-})\n-"}, {"sha": "c362d9f2db4d13809aed978ad1047ddc87efb527", "filename": "gcc/config/score/score-conv.h", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Fscore-conv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Fscore-conv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-conv.h?ref=bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8", "patch": "@@ -1,78 +0,0 @@\n-/* score-conv.h for Sunplus S+CORE processor\n-   Copyright (C) 2005-2014 Free Software Foundation, Inc.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_SCORE_CONV_H\n-#define GCC_SCORE_CONV_H\n-\n-#define GP_REG_FIRST                    0U\n-#define GP_REG_LAST                     31U\n-#define GP_REG_NUM                      (GP_REG_LAST - GP_REG_FIRST + 1U)\n-#define GP_DBX_FIRST                    0U\n-\n-#define CE_REG_FIRST                    48U\n-#define CE_REG_LAST                     49U\n-#define CE_REG_NUM                      (CE_REG_LAST - CE_REG_FIRST + 1U)\n-\n-#define ARG_REG_FIRST                   4U\n-#define ARG_REG_LAST                    7U\n-#define ARG_REG_NUM                     (ARG_REG_LAST - ARG_REG_FIRST + 1U)\n-\n-#define REG_CONTAIN(REGNO, FIRST, NUM) \\\n-  ((unsigned int)((int) (REGNO) - (FIRST)) < (NUM))\n-\n-#define GP_REG_P(REGNO)        REG_CONTAIN (REGNO, GP_REG_FIRST, GP_REG_NUM)\n-\n-#define G8_REG_P(REGNO)        REG_CONTAIN (REGNO, GP_REG_FIRST, 8)\n-\n-#define G16_REG_P(REGNO)       REG_CONTAIN (REGNO, GP_REG_FIRST, 16)\n-\n-#define CE_REG_P(REGNO)        REG_CONTAIN (REGNO, CE_REG_FIRST, CE_REG_NUM)\n-\n-#define GR_REG_CLASS_P(C)        ((C) == G16_REGS || (C) == G32_REGS)\n-#define SP_REG_CLASS_P(C) \\\n-  ((C) == CN_REG || (C) == LC_REG || (C) == SC_REG || (C) == SP_REGS)\n-#define CP_REG_CLASS_P(C) \\\n-  ((C) == CP1_REGS || (C) == CP2_REGS || (C) == CP3_REGS || (C) == CPA_REGS)\n-#define CE_REG_CLASS_P(C) \\\n-  ((C) == HI_REG || (C) == LO_REG || (C) == CE_REGS)\n-\n-#define UIMM_IN_RANGE(V, W) \\\n-  ((V) >= 0 \\\n-   && ((unsigned HOST_WIDE_INT) (V) \\\n-       <= (((unsigned HOST_WIDE_INT) 2 << ((W) - 1)) - 1)))\n-\n-#define SIMM_IN_RANGE(V, W)                            \\\n-  ((V) >= ((HOST_WIDE_INT) -1 << ((W) - 1))      \\\n-   && (V) <= (((HOST_WIDE_INT) 1 << ((W) - 1)) - 1))\n-\n-#define IMM_IN_RANGE(V, W, S)  \\\n-  ((S) ? SIMM_IN_RANGE (V, W) : UIMM_IN_RANGE (V, W))\n-\n-#define IMM_IS_POW_OF_2(V, E1, E2)                 \\\n-  ((V) >= ((unsigned HOST_WIDE_INT) 1 << (E1))     \\\n-   && (V) <= ((unsigned HOST_WIDE_INT) 1 << (E2))  \\\n-   && ((V) & ((V) - 1)) == 0)\n-\n-enum score_symbol_type\n-{\n-  SYMBOL_GENERAL,\n-  SYMBOL_SMALL_DATA  /* The symbol refers to something in a small data section  */\n-};\n-\n-#endif"}, {"sha": "4f155f9f4fdaf8bc4849a1f14b3926a691d09f54", "filename": "gcc/config/score/score-generic.md", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Fscore-generic.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Fscore-generic.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-generic.md?ref=bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8", "patch": "@@ -1,44 +0,0 @@\n-;;  Machine description for Sunplus S+CORE\n-;;  Sunplus S+CORE Pipeline Description\n-;;  Copyright (C) 2005-2014 Free Software Foundation, Inc.\n-;;  Contributed by Sunnorth.\n-\n-;; This file is part of GCC.\n-\n-;; GCC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 3, or (at your option)\n-;; any later version.\n-\n-;; GCC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.\n-\n-(define_automaton \"score\")\n-\n-(define_cpu_unit \"core\" \"score\")\n-\n-(define_insn_reservation \"memory\" 3\n-                         (eq_attr \"type\" \"load\")\n-                         \"core\")\n-\n-(define_insn_reservation \"mul\" 3\n-                         (eq_attr \"type\" \"mul,div\")\n-                         \"core\")\n-\n-(define_insn_reservation \"fce\" 1\n-                         (eq_attr \"type\" \"fce\")\n-                         \"core\")\n-\n-(define_insn_reservation \"tsr\" 1\n-                         (eq_attr \"type\" \"tsr,fsr\")\n-                         \"core\")\n-\n-(define_insn_reservation \"up_c\" 1\n-                         (eq_attr \"up_c\" \"yes\")\n-                         \"core\")"}, {"sha": "dc1b386618a2312a8558034ada085feac721e8c3", "filename": "gcc/config/score/score-modes.def", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Fscore-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Fscore-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-modes.def?ref=bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8", "patch": "@@ -1,24 +0,0 @@\n-/* score-modes.def for Sunplus S+CORE processor\n-   Copyright (C) 2005-2014 Free Software Foundation, Inc.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* CC_NZmode should be used if the N (sign) and Z (zero) flag is set correctly.\n-   CC_Nmode should be used if only the N flag is set correctly.  */\n-\n-CC_MODE (CC_N);\n-CC_MODE (CC_NZ);"}, {"sha": "8a83a532984dc26eb68f2771752318bb8bf89f19", "filename": "gcc/config/score/score-protos.h", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Fscore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Fscore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-protos.h?ref=bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8", "patch": "@@ -1,83 +0,0 @@\n-/* score-protos.h for Sunplus S+CORE processor\n-   Copyright (C) 2005-2014 Free Software Foundation, Inc.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_SCORE_PROTOS_H\n-#define GCC_SCORE_PROTOS_H\n-\n-/* Machine Print.  */\n-enum score_mem_unit {SCORE_BYTE = 0, SCORE_HWORD = 1, SCORE_WORD = 2};\n-\n-#define SCORE_ALIGN_UNIT(V, UNIT)   !(V & ((1 << UNIT) - 1))\n-\n-extern void score_prologue (void);\n-extern void score_epilogue (int sibcall_p);\n-extern void score_call (rtx *ops, bool sib);\n-extern void score_call_value (rtx *ops, bool sib);\n-extern void score_movdi (rtx *ops);\n-extern void score_zero_extract_andi (rtx *ops);\n-extern const char * score_linsn (rtx *ops, enum score_mem_unit unit, bool sign);\n-extern const char * score_sinsn (rtx *ops, enum score_mem_unit unit);\n-extern const char * score_limm (rtx *ops);\n-extern const char * score_move (rtx *ops);\n-extern bool score_unaligned_load (rtx* ops);\n-extern bool score_unaligned_store (rtx* ops);\n-extern bool score_block_move (rtx* ops);\n-extern int score_address_cost (rtx addr, enum machine_mode mode,\n-\t\t\t       addr_space_t as, bool speed);\n-extern int score_address_p (enum machine_mode mode, rtx x, int strict);\n-extern int score_reg_class (int regno);\n-extern int score_hard_regno_mode_ok (unsigned int, enum machine_mode);\n-extern int score_const_ok_for_letter_p (HOST_WIDE_INT value, char c);\n-extern int score_extra_constraint (rtx op, char c);\n-extern rtx score_return_addr (int count, rtx frame);\n-extern int score_regno_mode_ok_for_base_p (int regno, int strict);\n-extern void score_init_cumulative_args (CUMULATIVE_ARGS *cum,\n-                                        tree fntype, rtx libname);\n-extern void score_declare_object (FILE *stream, const char *name,\n-                                  const char *directive, const char *fmt, ...);\n-extern int score_output_external (FILE *file, tree decl, const char *name);\n-extern enum reg_class score_secondary_reload_class (enum reg_class rclass,\n-                                                    enum machine_mode mode,\n-                                                    rtx x);\n-extern rtx score_function_value (const_tree valtype, const_tree func,\n-                                 enum machine_mode mode);\n-extern enum reg_class score_preferred_reload_class (rtx x,\n-                                                    enum reg_class rclass);\n-extern HOST_WIDE_INT score_initial_elimination_offset (int from, int to);\n-extern void score_print_operand (FILE *file, rtx op, int letter);\n-extern void score_print_operand_address (FILE *file, rtx addr);\n-extern int score_symbolic_constant_p (rtx x,\n-                                      enum score_symbol_type *symbol_type);\n-extern void score_movsicc (rtx *ops);\n-extern const char * score_select_add_imm (rtx *ops, bool set_cc);\n-extern const char * score_select (rtx *ops, const char *inst_pre, bool commu,\n-                                  const char *letter, bool set_cc);\n-extern const char * score_output_casesi (rtx *operands);\n-extern const char * score_rpush (rtx *ops);\n-extern const char * score_rpop (rtx *ops);\n-extern bool score_rtx_costs (rtx x, int code, int outer_code, int opno,\n-\t\t\t     int *total, bool speed);\n-\n-#ifdef RTX_CODE\n-extern enum machine_mode score_select_cc_mode (enum rtx_code op, rtx x, rtx y);\n-#endif\n-\n-extern struct extern_list *extern_head;\n-\n-#endif /* GCC_SCORE_PROTOS_H  */"}, {"sha": "9257f476618af7a39509fbda889882ddd7f87d90", "filename": "gcc/config/score/score.c", "status": "removed", "additions": 0, "deletions": 1941, "changes": 1941, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Fscore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Fscore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.c?ref=bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8", "patch": "@@ -1,1941 +0,0 @@\n-/* Output routines for Sunplus S+CORE processor\n-   Copyright (C) 2005-2014 Free Software Foundation, Inc.\n-   Contributed by Sunnorth.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"insn-attr.h\"\n-#include \"recog.h\"\n-#include \"diagnostic-core.h\"\n-#include \"output.h\"\n-#include \"tree.h\"\n-#include \"stringpool.h\"\n-#include \"calls.h\"\n-#include \"varasm.h\"\n-#include \"stor-layout.h\"\n-#include \"function.h\"\n-#include \"expr.h\"\n-#include \"optabs.h\"\n-#include \"flags.h\"\n-#include \"reload.h\"\n-#include \"tm_p.h\"\n-#include \"ggc.h\"\n-#include \"gstab.h\"\n-#include \"hashtab.h\"\n-#include \"debug.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-#include \"langhooks.h\"\n-#include \"df.h\"\n-#include \"opts.h\"\n-#include \"builtins.h\"\n-\n-#define SCORE_SDATA_MAX                score_sdata_max\n-#define SCORE_STACK_ALIGN(LOC)         (((LOC) + 3) & ~3)\n-#define SCORE_PROLOGUE_TEMP_REGNUM     (GP_REG_FIRST + 8)\n-#define SCORE_EPILOGUE_TEMP_REGNUM     (GP_REG_FIRST + 8)\n-#define SCORE_DEFAULT_SDATA_MAX        8\n-\n-#define BITSET_P(VALUE, BIT)           (((VALUE) & (1L << (BIT))) != 0)\n-#define INS_BUF_SZ                     128\n-\n-enum score_address_type\n-{\n-  SCORE_ADD_REG,\n-  SCORE_ADD_CONST_INT,\n-  SCORE_ADD_SYMBOLIC\n-};\n-\n-struct score_frame_info\n-{\n-  HOST_WIDE_INT total_size;       /* bytes that the entire frame takes up  */\n-  HOST_WIDE_INT var_size;         /* bytes that variables take up  */\n-  HOST_WIDE_INT args_size;        /* bytes that outgoing arguments take up  */\n-  HOST_WIDE_INT gp_reg_size;      /* bytes needed to store gp regs  */\n-  HOST_WIDE_INT gp_sp_offset;     /* offset from new sp to store gp registers  */\n-  HOST_WIDE_INT cprestore_size;   /* # bytes that the .cprestore slot takes up  */\n-  unsigned int  mask;             /* mask of saved gp registers  */\n-  int num_gp;                     /* number of gp registers saved  */\n-};\n-\n-struct score_arg_info\n-{\n-  unsigned int num_bytes;     /* The argument's size in bytes  */\n-  unsigned int reg_words;     /* The number of words passed in registers  */\n-  unsigned int reg_offset;    /* The offset of the first register from  */\n-                              /* GP_ARG_FIRST or FP_ARG_FIRST etc  */\n-  unsigned int stack_words;   /* The number of words that must be passed  */\n-                              /* on the stack  */\n-  unsigned int stack_offset;  /* The offset from the start of the stack  */\n-                              /* overflow area  */\n-};\n-\n-#ifdef RTX_CODE\n-struct score_address_info\n-{\n-  enum score_address_type type;\n-  rtx reg;\n-  rtx offset;\n-  enum rtx_code code;\n-  enum score_symbol_type symbol_type;\n-};\n-#endif\n-\n-static int score_sdata_max;\n-static char score_ins[INS_BUF_SZ + 8];\n-\n-struct extern_list *extern_head = 0;\n-\n-#undef  TARGET_ASM_FILE_START\n-#define TARGET_ASM_FILE_START           score_asm_file_start\n-\n-#undef  TARGET_ASM_FILE_END\n-#define TARGET_ASM_FILE_END             score_asm_file_end\n-\n-#undef  TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE    score_function_prologue\n-\n-#undef  TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE    score_function_epilogue\n-\n-#undef TARGET_OPTION_OVERRIDE\n-#define TARGET_OPTION_OVERRIDE          score_option_override\n-\n-#undef  TARGET_SCHED_ISSUE_RATE\n-#define TARGET_SCHED_ISSUE_RATE         score_issue_rate\n-\n-#undef TARGET_ASM_SELECT_RTX_SECTION\n-#define TARGET_ASM_SELECT_RTX_SECTION   score_select_rtx_section\n-\n-#undef  TARGET_IN_SMALL_DATA_P\n-#define TARGET_IN_SMALL_DATA_P          score_in_small_data_p\n-\n-#undef  TARGET_FUNCTION_OK_FOR_SIBCALL\n-#define TARGET_FUNCTION_OK_FOR_SIBCALL  score_function_ok_for_sibcall\n-\n-#undef TARGET_STRICT_ARGUMENT_NAMING\n-#define TARGET_STRICT_ARGUMENT_NAMING   hook_bool_CUMULATIVE_ARGS_true\n-\n-#undef TARGET_ASM_OUTPUT_MI_THUNK\n-#define TARGET_ASM_OUTPUT_MI_THUNK      score_output_mi_thunk\n-\n-#undef TARGET_PROMOTE_FUNCTION_MODE\n-#define TARGET_PROMOTE_FUNCTION_MODE    default_promote_function_mode_always_promote\n-\n-#undef TARGET_PROMOTE_PROTOTYPES\n-#define TARGET_PROMOTE_PROTOTYPES       hook_bool_const_tree_true\n-\n-#undef TARGET_MUST_PASS_IN_STACK\n-#define TARGET_MUST_PASS_IN_STACK       must_pass_in_stack_var_size\n-\n-#undef TARGET_ARG_PARTIAL_BYTES\n-#define TARGET_ARG_PARTIAL_BYTES        score_arg_partial_bytes\n-\n-#undef TARGET_FUNCTION_ARG\n-#define TARGET_FUNCTION_ARG             score_function_arg\n-\n-#undef TARGET_FUNCTION_ARG_ADVANCE\n-#define TARGET_FUNCTION_ARG_ADVANCE     score_function_arg_advance\n-\n-#undef TARGET_PASS_BY_REFERENCE\n-#define TARGET_PASS_BY_REFERENCE        score_pass_by_reference\n-\n-#undef TARGET_RETURN_IN_MEMORY\n-#define TARGET_RETURN_IN_MEMORY         score_return_in_memory\n-\n-#undef TARGET_RTX_COSTS\n-#define TARGET_RTX_COSTS                score_rtx_costs\n-\n-#undef TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST             score_address_cost\n-\n-#undef TARGET_LEGITIMATE_ADDRESS_P\n-#define TARGET_LEGITIMATE_ADDRESS_P\tscore_legitimate_address_p\n-\n-#undef TARGET_CAN_ELIMINATE\n-#define TARGET_CAN_ELIMINATE            score_can_eliminate\n-\n-#undef TARGET_CONDITIONAL_REGISTER_USAGE\n-#define TARGET_CONDITIONAL_REGISTER_USAGE score_conditional_register_usage\n-\n-#undef TARGET_ASM_TRAMPOLINE_TEMPLATE\n-#define TARGET_ASM_TRAMPOLINE_TEMPLATE\tscore_asm_trampoline_template\n-#undef TARGET_TRAMPOLINE_INIT\n-#define TARGET_TRAMPOLINE_INIT\t\tscore_trampoline_init\n-\n-#undef TARGET_REGISTER_MOVE_COST\n-#define TARGET_REGISTER_MOVE_COST\tscore_register_move_cost\n-\n-/* Return true if SYMBOL is a SYMBOL_REF and OFFSET + SYMBOL points\n-   to the same object as SYMBOL.  */\n-static int\n-score_offset_within_object_p (rtx symbol, HOST_WIDE_INT offset)\n-{\n-  if (GET_CODE (symbol) != SYMBOL_REF)\n-    return 0;\n-\n-  if (CONSTANT_POOL_ADDRESS_P (symbol)\n-      && offset >= 0\n-      && offset < (int)GET_MODE_SIZE (get_pool_mode (symbol)))\n-    return 1;\n-\n-  if (SYMBOL_REF_DECL (symbol) != 0\n-      && offset >= 0\n-      && offset < int_size_in_bytes (TREE_TYPE (SYMBOL_REF_DECL (symbol))))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Split X into a base and a constant offset, storing them in *BASE\n-   and *OFFSET respectively.  */\n-static void\n-score_split_const (rtx x, rtx *base, HOST_WIDE_INT *offset)\n-{\n-  *offset = 0;\n-\n-  if (GET_CODE (x) == CONST)\n-    x = XEXP (x, 0);\n-\n-  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-    {\n-      *offset += INTVAL (XEXP (x, 1));\n-      x = XEXP (x, 0);\n-    }\n-\n-  *base = x;\n-}\n-\n-/* Classify symbol X, which must be a SYMBOL_REF or a LABEL_REF.  */\n-static enum score_symbol_type\n-score_classify_symbol (rtx x)\n-{\n-  if (GET_CODE (x) == LABEL_REF)\n-    return SYMBOL_GENERAL;\n-\n-  gcc_assert (GET_CODE (x) == SYMBOL_REF);\n-\n-  if (CONSTANT_POOL_ADDRESS_P (x))\n-    {\n-      if (GET_MODE_SIZE (get_pool_mode (x)) <= SCORE_SDATA_MAX)\n-        return SYMBOL_SMALL_DATA;\n-      return SYMBOL_GENERAL;\n-    }\n-  if (SYMBOL_REF_SMALL_P (x))\n-    return SYMBOL_SMALL_DATA;\n-  return SYMBOL_GENERAL;\n-}\n-\n-/* Return true if the current function must save REGNO.  */\n-static int\n-score_save_reg_p (unsigned int regno)\n-{\n-  /* Check call-saved registers.  */\n-  if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n-    return 1;\n-\n-  /* We need to save the old frame pointer before setting up a new one.  */\n-  if (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\n-    return 1;\n-\n-  /* We need to save the incoming return address if it is ever clobbered\n-     within the function.  */\n-  if (regno == RA_REGNUM && df_regs_ever_live_p (regno))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Return one word of double-word value OP, taking into account the fixed\n-   endianness of certain registers.  HIGH_P is true to select the high part,\n-   false to select the low part.  */\n-static rtx\n-score_subw (rtx op, int high_p)\n-{\n-  unsigned int byte;\n-  enum machine_mode mode = GET_MODE (op);\n-\n-  if (mode == VOIDmode)\n-    mode = DImode;\n-\n-  byte = (TARGET_LITTLE_ENDIAN ? high_p : !high_p) ? UNITS_PER_WORD : 0;\n-\n-  if (GET_CODE (op) == REG && REGNO (op) == HI_REGNUM)\n-    return gen_rtx_REG (SImode, high_p ? HI_REGNUM : LO_REGNUM);\n-\n-  if (GET_CODE (op) == MEM)\n-    return adjust_address (op, SImode, byte);\n-\n-  return simplify_gen_subreg (SImode, op, mode, byte);\n-}\n-\n-static struct score_frame_info *\n-score_cached_frame (void)\n-{\n-  static struct score_frame_info _frame_info;\n-  return &_frame_info;\n-}\n-\n-/* Return the bytes needed to compute the frame pointer from the current\n-   stack pointer.  SIZE is the size (in bytes) of the local variables.  */\n-static struct score_frame_info *\n-score_compute_frame_size (HOST_WIDE_INT size)\n-{\n-  unsigned int regno;\n-  struct score_frame_info *f = score_cached_frame ();\n-\n-  memset (f, 0, sizeof (struct score_frame_info));\n-  f->gp_reg_size = 0;\n-  f->mask = 0;\n-  f->var_size = SCORE_STACK_ALIGN (size);\n-  f->args_size = crtl->outgoing_args_size;\n-  f->cprestore_size = flag_pic ? UNITS_PER_WORD : 0;\n-  if (f->var_size == 0 && crtl->is_leaf)\n-    f->args_size = f->cprestore_size = 0;\n-\n-  if (f->args_size == 0 && cfun->calls_alloca)\n-    f->args_size = UNITS_PER_WORD;\n-\n-  f->total_size = f->var_size + f->args_size + f->cprestore_size;\n-  for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n-    {\n-      if (score_save_reg_p (regno))\n-        {\n-          f->gp_reg_size += GET_MODE_SIZE (SImode);\n-          f->mask |= 1 << (regno - GP_REG_FIRST);\n-        }\n-    }\n-\n-  if (crtl->calls_eh_return)\n-    {\n-      unsigned int i;\n-      for (i = 0;; ++i)\n-        {\n-          regno = EH_RETURN_DATA_REGNO (i);\n-          if (regno == INVALID_REGNUM)\n-            break;\n-          f->gp_reg_size += GET_MODE_SIZE (SImode);\n-          f->mask |= 1 << (regno - GP_REG_FIRST);\n-        }\n-    }\n-\n-  f->total_size += f->gp_reg_size;\n-  f->num_gp = f->gp_reg_size / UNITS_PER_WORD;\n-\n-  if (f->mask)\n-    {\n-      HOST_WIDE_INT offset;\n-      offset = (f->args_size + f->cprestore_size + f->var_size\n-                + f->gp_reg_size - GET_MODE_SIZE (SImode));\n-      f->gp_sp_offset = offset;\n-    }\n-  else\n-    f->gp_sp_offset = 0;\n-\n-  return f;\n-}\n-\n-/* Return true if X is a valid base register for the given mode.\n-   Allow only hard registers if STRICT.  */\n-static int\n-score_valid_base_register_p (rtx x, int strict)\n-{\n-  if (!strict && GET_CODE (x) == SUBREG)\n-    x = SUBREG_REG (x);\n-\n-  return (GET_CODE (x) == REG\n-          && score_regno_mode_ok_for_base_p (REGNO (x), strict));\n-}\n-\n-/* Return true if X is a valid address for machine mode MODE.  If it is,\n-   fill in INFO appropriately.  STRICT is true if we should only accept\n-   hard base registers.  */\n-static int\n-score_classify_address (struct score_address_info *info,\n-                        enum machine_mode mode, rtx x, int strict)\n-{\n-  info->code = GET_CODE (x);\n-\n-  switch (info->code)\n-    {\n-    case REG:\n-    case SUBREG:\n-      info->type = SCORE_ADD_REG;\n-      info->reg = x;\n-      info->offset = const0_rtx;\n-      return score_valid_base_register_p (info->reg, strict);\n-    case PLUS:\n-      info->type = SCORE_ADD_REG;\n-      info->reg = XEXP (x, 0);\n-      info->offset = XEXP (x, 1);\n-      return (score_valid_base_register_p (info->reg, strict)\n-              && GET_CODE (info->offset) == CONST_INT\n-              && IMM_IN_RANGE (INTVAL (info->offset), 15, 1));\n-    case PRE_DEC:\n-    case POST_DEC:\n-    case PRE_INC:\n-    case POST_INC:\n-      if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (SImode))\n-        return false;\n-      info->type = SCORE_ADD_REG;\n-      info->reg = XEXP (x, 0);\n-      info->offset = GEN_INT (GET_MODE_SIZE (mode));\n-      return score_valid_base_register_p (info->reg, strict);\n-    case CONST_INT:\n-      info->type = SCORE_ADD_CONST_INT;\n-      return IMM_IN_RANGE (INTVAL (x), 15, 1);\n-    case CONST:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      info->type = SCORE_ADD_SYMBOLIC;\n-      return (score_symbolic_constant_p (x, &info->symbol_type)\n-              && (info->symbol_type == SYMBOL_GENERAL\n-                  || info->symbol_type == SYMBOL_SMALL_DATA));\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* Implement TARGET_RETURN_IN_MEMORY.  In S+core,\n-   small structures are returned in a register.\n-   Objects with varying size must still be returned in memory.  */\n-static bool\n-score_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n-{\n-    return ((TYPE_MODE (type) == BLKmode)\n-            || (int_size_in_bytes (type) > 2 * UNITS_PER_WORD)\n-            || (int_size_in_bytes (type) == -1));\n-}\n-\n-/* Return a legitimate address for REG + OFFSET.  */\n-static rtx\n-score_add_offset (rtx reg, HOST_WIDE_INT offset)\n-{\n-  if (!IMM_IN_RANGE (offset, 15, 1))\n-    {\n-      reg = expand_simple_binop (GET_MODE (reg), PLUS,\n-                                 gen_int_mode (offset & 0xffffc000,\n-                                               GET_MODE (reg)),\n-                                 reg, NULL, 0, OPTAB_WIDEN);\n-      offset &= 0x3fff;\n-    }\n-\n-  return plus_constant (GET_MODE (reg), reg, offset);\n-}\n-\n-/* Implement TARGET_ASM_OUTPUT_MI_THUNK.  Generate rtl rather than asm text\n-   in order to avoid duplicating too much logic from elsewhere.  */\n-static void\n-score_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n-                       HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n-                       tree function)\n-{\n-  rtx this_rtx, temp1, fnaddr;\n-  rtx_insn *insn;\n-\n-  /* Pretend to be a post-reload pass while generating rtl.  */\n-  reload_completed = 1;\n-\n-  /* Mark the end of the (empty) prologue.  */\n-  emit_note (NOTE_INSN_PROLOGUE_END);\n-\n-  /* We need two temporary registers in some cases.  */\n-  temp1 = gen_rtx_REG (Pmode, 8);\n-\n-  /* Find out which register contains the \"this\" pointer.  */\n-  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n-    this_rtx = gen_rtx_REG (Pmode, ARG_REG_FIRST + 1);\n-  else\n-    this_rtx = gen_rtx_REG (Pmode, ARG_REG_FIRST);\n-\n-  /* Add DELTA to THIS_RTX.  */\n-  if (delta != 0)\n-    {\n-      rtx offset = GEN_INT (delta);\n-      if (!(delta >= -32768 && delta <= 32767))\n-        {\n-          emit_move_insn (temp1, offset);\n-          offset = temp1;\n-        }\n-      emit_insn (gen_add3_insn (this_rtx, this_rtx, offset));\n-    }\n-\n-  /* If needed, add *(*THIS_RTX + VCALL_OFFSET) to THIS_RTX.  */\n-  if (vcall_offset != 0)\n-    {\n-      rtx addr;\n-\n-      /* Set TEMP1 to *THIS_RTX.  */\n-      emit_move_insn (temp1, gen_rtx_MEM (Pmode, this_rtx));\n-\n-      /* Set ADDR to a legitimate address for *THIS_RTX + VCALL_OFFSET.  */\n-      addr = score_add_offset (temp1, vcall_offset);\n-\n-      /* Load the offset and add it to THIS_RTX.  */\n-      emit_move_insn (temp1, gen_rtx_MEM (Pmode, addr));\n-      emit_insn (gen_add3_insn (this_rtx, this_rtx, temp1));\n-    }\n-\n-  /* Jump to the target function.  */\n-  fnaddr = XEXP (DECL_RTL (function), 0);\n-  insn = emit_call_insn (gen_sibcall_internal_score7 (fnaddr, const0_rtx));\n-  SIBLING_CALL_P (insn) = 1;\n-\n-  /* Run just enough of rest_of_compilation.  This sequence was\n-     \"borrowed\" from alpha.c.  */\n-  insn = get_insns ();\n-  split_all_insns_noflow ();\n-  shorten_branches (insn);\n-  final_start_function (insn, file, 1);\n-  final (insn, file, 1);\n-  final_end_function ();\n-\n-  /* Clean up the vars set above.  Note that final_end_function resets\n-     the global pointer for us.  */\n-  reload_completed = 0;\n-}\n-\n-/* Fill INFO with information about a single argument.  CUM is the\n-   cumulative state for earlier arguments.  MODE is the mode of this\n-   argument and TYPE is its type (if known).  NAMED is true if this\n-   is a named (fixed) argument rather than a variable one.  */\n-static void\n-score_classify_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-                    const_tree type, bool named, struct score_arg_info *info)\n-{\n-  int even_reg_p;\n-  unsigned int num_words, max_regs;\n-\n-  even_reg_p = 0;\n-  if (GET_MODE_CLASS (mode) == MODE_INT\n-      || GET_MODE_CLASS (mode) == MODE_FLOAT)\n-    even_reg_p = (GET_MODE_SIZE (mode) > UNITS_PER_WORD);\n-  else\n-    if (type != NULL_TREE && TYPE_ALIGN (type) > BITS_PER_WORD && named)\n-      even_reg_p = 1;\n-\n-  if (TARGET_MUST_PASS_IN_STACK (mode, type))\n-    info->reg_offset = ARG_REG_NUM;\n-  else\n-    {\n-      info->reg_offset = cum->num_gprs;\n-      if (even_reg_p)\n-        info->reg_offset += info->reg_offset & 1;\n-    }\n-\n-  if (mode == BLKmode)\n-    info->num_bytes = int_size_in_bytes (type);\n-  else\n-    info->num_bytes = GET_MODE_SIZE (mode);\n-\n-  num_words = (info->num_bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-  max_regs = ARG_REG_NUM - info->reg_offset;\n-\n-  /* Partition the argument between registers and stack.  */\n-  info->reg_words = MIN (num_words, max_regs);\n-  info->stack_words = num_words - info->reg_words;\n-\n-  /* The alignment applied to registers is also applied to stack arguments.  */\n-  if (info->stack_words)\n-    {\n-      info->stack_offset = cum->stack_words;\n-      if (even_reg_p)\n-        info->stack_offset += info->stack_offset & 1;\n-    }\n-}\n-\n-/* Set up the stack and frame (if desired) for the function.  */\n-static void\n-score_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n-{\n-  const char *fnname;\n-  struct score_frame_info *f = score_cached_frame ();\n-  HOST_WIDE_INT tsize = f->total_size;\n-\n-  fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n-  if (!flag_inhibit_size_directive)\n-    {\n-      fputs (\"\\t.ent\\t\", file);\n-      assemble_name (file, fnname);\n-      fputs (\"\\n\", file);\n-    }\n-  assemble_name (file, fnname);\n-  fputs (\":\\n\", file);\n-\n-  if (!flag_inhibit_size_directive)\n-    {\n-      fprintf (file,\n-               \"\\t.frame\\t%s,\" HOST_WIDE_INT_PRINT_DEC \",%s, %d\\t\\t\"\n-               \"# vars= \" HOST_WIDE_INT_PRINT_DEC \", regs= %d\"\n-               \", args= \" HOST_WIDE_INT_PRINT_DEC\n-               \", gp= \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-               (reg_names[(frame_pointer_needed)\n-                ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM]),\n-               tsize,\n-               reg_names[RA_REGNUM],\n-               crtl->is_leaf ? 1 : 0,\n-               f->var_size,\n-               f->num_gp,\n-               f->args_size,\n-               f->cprestore_size);\n-\n-      fprintf(file, \"\\t.mask\\t0x%08x,\" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-              f->mask,\n-              (f->gp_sp_offset - f->total_size));\n-    }\n-}\n-\n-/* Do any necessary cleanup after a function to restore stack, frame,\n-   and regs.  */\n-static void\n-score_function_epilogue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n-{\n-  if (!flag_inhibit_size_directive)\n-    {\n-      const char *fnname;\n-      fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n-      fputs (\"\\t.end\\t\", file);\n-      assemble_name (file, fnname);\n-      fputs (\"\\n\", file);\n-    }\n-}\n-\n-/* Returns true if X contains a SYMBOL_REF.  */\n-static bool\n-score_symbolic_expression_p (rtx x)\n-{\n-  if (GET_CODE (x) == SYMBOL_REF)\n-    return true;\n-\n-  if (GET_CODE (x) == CONST)\n-    return score_symbolic_expression_p (XEXP (x, 0));\n-\n-  if (UNARY_P (x))\n-    return score_symbolic_expression_p (XEXP (x, 0));\n-\n-  if (ARITHMETIC_P (x))\n-    return (score_symbolic_expression_p (XEXP (x, 0))\n-            || score_symbolic_expression_p (XEXP (x, 1)));\n-\n-  return false;\n-}\n-\n-/* Choose the section to use for the constant rtx expression X that has\n-   mode MODE.  */\n-static section *\n-score_select_rtx_section (enum machine_mode mode, rtx x, unsigned HOST_WIDE_INT align)\n-{\n-  if (GET_MODE_SIZE (mode) <= SCORE_SDATA_MAX)\n-    return get_named_section (0, \".sdata\", 0);\n-  else if (flag_pic && score_symbolic_expression_p (x))\n-    return get_named_section (0, \".data.rel.ro\", 3);\n-  else\n-    return mergeable_constant_section (mode, align, 0);\n-}\n-\n-/* Implement TARGET_IN_SMALL_DATA_P.  */\n-static bool\n-score_in_small_data_p (const_tree decl)\n-{\n-  HOST_WIDE_INT size;\n-\n-  if (TREE_CODE (decl) == STRING_CST\n-      || TREE_CODE (decl) == FUNCTION_DECL)\n-    return false;\n-\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_SECTION_NAME (decl) != 0)\n-    {\n-      const char *name;\n-      name = DECL_SECTION_NAME (decl);\n-      if (strcmp (name, \".sdata\") != 0\n-          && strcmp (name, \".sbss\") != 0)\n-        return true;\n-      if (!DECL_EXTERNAL (decl))\n-        return false;\n-    }\n-  size = int_size_in_bytes (TREE_TYPE (decl));\n-  return (size > 0 && size <= SCORE_SDATA_MAX);\n-}\n-\n-/* Implement TARGET_ASM_FILE_START.  */\n-static void\n-score_asm_file_start (void)\n-{\n-  default_file_start ();\n-  fprintf (asm_out_file, ASM_COMMENT_START\n-           \"GCC for S+core %s \\n\", SCORE_GCC_VERSION);\n-\n-  if (flag_pic)\n-    fprintf (asm_out_file, \"\\t.set pic\\n\");\n-}\n-\n-/* Implement TARGET_ASM_FILE_END.  When using assembler macros, emit\n-   .externs for any small-data variables that turned out to be external.  */\n-static void\n-score_asm_file_end (void)\n-{\n-  tree name_tree;\n-  struct extern_list *p;\n-  if (extern_head)\n-    {\n-      fputs (\"\\n\", asm_out_file);\n-      for (p = extern_head; p != 0; p = p->next)\n-        {\n-          name_tree = get_identifier (p->name);\n-          if (!TREE_ASM_WRITTEN (name_tree)\n-              && TREE_SYMBOL_REFERENCED (name_tree))\n-            {\n-              TREE_ASM_WRITTEN (name_tree) = 1;\n-              fputs (\"\\t.extern\\t\", asm_out_file);\n-              assemble_name (asm_out_file, p->name);\n-              fprintf (asm_out_file, \", %d\\n\", p->size);\n-            }\n-        }\n-    }\n-}\n-\n-/* Implement TARGET_OPTION_OVERRIDE hook.  */\n-static void\n-score_option_override (void)\n-{\n-  flag_pic = false;\n-  score_sdata_max = SCORE_DEFAULT_SDATA_MAX;\n-\n-}\n-\n-/* Implement REGNO_REG_CLASS macro.  */\n-int\n-score_reg_class (int regno)\n-{\n-  int c;\n-  gcc_assert (regno >= 0 && regno < FIRST_PSEUDO_REGISTER);\n-\n-  if (regno == FRAME_POINTER_REGNUM\n-      || regno == ARG_POINTER_REGNUM)\n-    return ALL_REGS;\n-\n-  for (c = 0; c < N_REG_CLASSES; c++)\n-    if (TEST_HARD_REG_BIT (reg_class_contents[c], regno))\n-      return c;\n-\n-  return NO_REGS;\n-}\n-\n-/* Implement PREFERRED_RELOAD_CLASS macro.  */\n-enum reg_class\n-score_preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class rclass)\n-{\n-  if (reg_class_subset_p (G16_REGS, rclass))\n-    return G16_REGS;\n-  if (reg_class_subset_p (G32_REGS, rclass))\n-    return G32_REGS;\n-  return rclass;\n-}\n-\n-/* Implement SECONDARY_INPUT_RELOAD_CLASS\n-   and SECONDARY_OUTPUT_RELOAD_CLASS macro.  */\n-enum reg_class\n-score_secondary_reload_class (enum reg_class rclass,\n-                              enum machine_mode mode ATTRIBUTE_UNUSED,\n-                              rtx x)\n-{\n-  int regno = -1;\n-  if (GET_CODE (x) == REG || GET_CODE(x) == SUBREG)\n-    regno = true_regnum (x);\n-\n-  if (!GR_REG_CLASS_P (rclass))\n-    return GP_REG_P (regno) ? NO_REGS : G32_REGS;\n-  return NO_REGS;\n-}\n-\n-\n-/* Return truth value on whether or not a given hard register\n-   can support a given mode.  */\n-int\n-score_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n-{\n-  int size = GET_MODE_SIZE (mode);\n-  enum mode_class mclass = GET_MODE_CLASS (mode);\n-\n-  if (mclass == MODE_CC)\n-    return regno == CC_REGNUM;\n-  else if (regno == FRAME_POINTER_REGNUM\n-           || regno == ARG_POINTER_REGNUM)\n-    return mclass == MODE_INT;\n-  else if (GP_REG_P (regno))\n-    /* ((regno <= (GP_REG_LAST- HARD_REGNO_NREGS (dummy, mode)) + 1)  */\n-    return !(regno & 1) || (size <= UNITS_PER_WORD);\n-  else if (CE_REG_P (regno))\n-    return (mclass == MODE_INT\n-            && ((size <= UNITS_PER_WORD)\n-                || (regno == CE_REG_FIRST && size == 2 * UNITS_PER_WORD)));\n-  else\n-    return (mclass == MODE_INT) && (size <= UNITS_PER_WORD);\n-}\n-\n-/* Implement INITIAL_ELIMINATION_OFFSET.  FROM is either the frame\n-   pointer or argument pointer.  TO is either the stack pointer or\n-   hard frame pointer.  */\n-HOST_WIDE_INT\n-score_initial_elimination_offset (int from,\n-                                  int to ATTRIBUTE_UNUSED)\n-{\n-  struct score_frame_info *f = score_compute_frame_size (get_frame_size ());\n-  switch (from)\n-    {\n-    case ARG_POINTER_REGNUM:\n-      return f->total_size;\n-    case FRAME_POINTER_REGNUM:\n-      return 0;\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Implement TARGET_FUNCTION_ARG_ADVANCE hook.  */\n-static void\n-score_function_arg_advance (cumulative_args_t cum_args, enum machine_mode mode,\n-                            const_tree type, bool named)\n-{\n-  struct score_arg_info info;\n-  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_args);\n-  score_classify_arg (cum, mode, type, named, &info);\n-  cum->num_gprs = info.reg_offset + info.reg_words;\n-  if (info.stack_words > 0)\n-    cum->stack_words = info.stack_offset + info.stack_words;\n-  cum->arg_number++;\n-}\n-\n-/* Implement TARGET_ARG_PARTIAL_BYTES macro.  */\n-int\n-score_arg_partial_bytes (cumulative_args_t cum_args,\n-                         enum machine_mode mode, tree type, bool named)\n-{\n-  struct score_arg_info info;\n-  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_args);\n-  score_classify_arg (cum, mode, type, named, &info);\n-  return info.stack_words > 0 ? info.reg_words * UNITS_PER_WORD : 0;\n-}\n-\n-/* Implement TARGET_FUNCTION_ARG hook.  */\n-static rtx\n-score_function_arg (cumulative_args_t cum_args, enum machine_mode mode,\n-                    const_tree type, bool named)\n-{\n-  struct score_arg_info info;\n-  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_args);\n-\n-  if (mode == VOIDmode || !named)\n-    return 0;\n-\n-  score_classify_arg (cum, mode, type, named, &info);\n-\n-  if (info.reg_offset == ARG_REG_NUM)\n-    return 0;\n-\n-  if (!info.stack_words)\n-    return gen_rtx_REG (mode, ARG_REG_FIRST + info.reg_offset);\n-  else\n-    {\n-      rtx ret = gen_rtx_PARALLEL (mode, rtvec_alloc (info.reg_words));\n-      unsigned int i, part_offset = 0;\n-      for (i = 0; i < info.reg_words; i++)\n-        {\n-          rtx reg;\n-          reg = gen_rtx_REG (SImode, ARG_REG_FIRST + info.reg_offset + i);\n-          XVECEXP (ret, 0, i) = gen_rtx_EXPR_LIST (SImode, reg,\n-                                                   GEN_INT (part_offset));\n-          part_offset += UNITS_PER_WORD;\n-        }\n-      return ret;\n-    }\n-}\n-\n-/* Implement FUNCTION_VALUE and LIBCALL_VALUE.  For normal calls,\n-   VALTYPE is the return type and MODE is VOIDmode.  For libcalls,\n-   VALTYPE is null and MODE is the mode of the return value.  */\n-rtx\n-score_function_value (const_tree valtype, const_tree func, enum machine_mode mode)\n-{\n-  if (valtype)\n-    {\n-      int unsignedp;\n-      mode = TYPE_MODE (valtype);\n-      unsignedp = TYPE_UNSIGNED (valtype);\n-      mode = promote_function_mode (valtype, mode, &unsignedp, func, 1);\n-    }\n-  return gen_rtx_REG (mode, RT_REGNUM);\n-}\n-\n-/* Implement TARGET_ASM_TRAMPOLINE_TEMPLATE.  */\n-\n-static void\n-score_asm_trampoline_template (FILE *f)\n-{\n-  fprintf (f, \"\\t.set r1\\n\");\n-  fprintf (f, \"\\tmv r31, r3\\n\");\n-  fprintf (f, \"\\tbl nextinsn\\n\");\n-  fprintf (f, \"nextinsn:\\n\");\n-  fprintf (f, \"\\tlw r1, [r3, 6*4-8]\\n\");\n-  fprintf (f, \"\\tlw r23, [r3, 6*4-4]\\n\");\n-  fprintf (f, \"\\tmv r3, r31\\n\");\n-  fprintf (f, \"\\tbr! r1\\n\");\n-  fprintf (f, \"\\tnop!\\n\");\n-  fprintf (f, \"\\t.set nor1\\n\");\n-}\n-\n-/* Implement TARGET_TRAMPOLINE_INIT.  */\n-static void\n-score_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n-{\n-#define CODE_SIZE        (TRAMPOLINE_INSNS * UNITS_PER_WORD)\n-\n-  rtx fnaddr = XEXP (DECL_RTL (fndecl), 0);\n-  rtx mem;\n-\n-  emit_block_move (m_tramp, assemble_trampoline_template (),\n-\t\t   GEN_INT (TRAMPOLINE_SIZE), BLOCK_OP_NORMAL);\n-\n-  mem = adjust_address (m_tramp, SImode, CODE_SIZE);\n-  emit_move_insn (mem, fnaddr);\n-  mem = adjust_address (m_tramp, SImode, CODE_SIZE + GET_MODE_SIZE (SImode));\n-  emit_move_insn (mem, chain_value);\n-\n-#undef CODE_SIZE\n-}\n-\n-/* This function is used to implement REG_MODE_OK_FOR_BASE_P macro.  */\n-int\n-score_regno_mode_ok_for_base_p (int regno, int strict)\n-{\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    {\n-      if (!strict)\n-        return 1;\n-      regno = reg_renumber[regno];\n-    }\n-  if (regno == ARG_POINTER_REGNUM\n-      || regno == FRAME_POINTER_REGNUM)\n-    return 1;\n-  return GP_REG_P (regno);\n-}\n-\n-/* Implement TARGET_LEGITIMATE_ADDRESS_P macro.  */\n-static bool\n-score_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n-{\n-  struct score_address_info addr;\n-\n-  return score_classify_address (&addr, mode, x, strict);\n-}\n-\n-/* Implement TARGET_REGISTER_MOVE_COST.\n-\n-   Return a number assessing the cost of moving a register in class\n-   FROM to class TO. */\n-static int\n-score_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n-                          reg_class_t from, reg_class_t to)\n-{\n-  if (GR_REG_CLASS_P (from))\n-    {\n-      if (GR_REG_CLASS_P (to))\n-        return 2;\n-      else if (SP_REG_CLASS_P (to))\n-        return 4;\n-      else if (CP_REG_CLASS_P (to))\n-        return 5;\n-      else if (CE_REG_CLASS_P (to))\n-        return 6;\n-    }\n-  if (GR_REG_CLASS_P (to))\n-    {\n-      if (GR_REG_CLASS_P (from))\n-        return 2;\n-      else if (SP_REG_CLASS_P (from))\n-        return 4;\n-      else if (CP_REG_CLASS_P (from))\n-        return 5;\n-      else if (CE_REG_CLASS_P (from))\n-        return 6;\n-    }\n-  return 12;\n-}\n-\n-/* Return the number of instructions needed to load a symbol of the\n-   given type into a register.  */\n-static int\n-score_symbol_insns (enum score_symbol_type type)\n-{\n-  switch (type)\n-    {\n-    case SYMBOL_GENERAL:\n-      return 2;\n-\n-    case SYMBOL_SMALL_DATA:\n-      return 1;\n-    }\n-\n-  gcc_unreachable ();\n-}\n-\n-/* Return the number of instructions needed to load or store a value\n-   of mode MODE at X.  Return 0 if X isn't valid for MODE.  */\n-static int\n-score_address_insns (rtx x, enum machine_mode mode)\n-{\n-  struct score_address_info addr;\n-  int factor;\n-\n-  if (mode == BLKmode)\n-    factor = 1;\n-  else\n-    factor = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-\n-  if (score_classify_address (&addr, mode, x, false))\n-    switch (addr.type)\n-      {\n-      case SCORE_ADD_REG:\n-      case SCORE_ADD_CONST_INT:\n-        return factor;\n-\n-      case SCORE_ADD_SYMBOLIC:\n-        return factor * score_symbol_insns (addr.symbol_type);\n-      }\n-  return 0;\n-}\n-\n-/* Implement TARGET_RTX_COSTS macro.  */\n-bool\n-score_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n-\t\t int *total, bool speed ATTRIBUTE_UNUSED)\n-{\n-  enum machine_mode mode = GET_MODE (x);\n-\n-  switch (code)\n-    {\n-    case CONST_INT:\n-      if (outer_code == SET)\n-        {\n-          if (((INTVAL (x) & 0xffff) == 0) \n-              || (INTVAL (x) >= -32768 && INTVAL (x) <= 32767))\n-            *total = COSTS_N_INSNS (1);\n-          else\n-            *total = COSTS_N_INSNS (2);\n-        }\n-      else if (outer_code == PLUS || outer_code == MINUS)\n-        {\n-          if (INTVAL (x) >= -8192 && INTVAL (x) <= 8191)\n-            *total = 0;\n-          else if (((INTVAL (x) & 0xffff) == 0)\n-                   || (INTVAL (x) >= -32768 && INTVAL (x) <= 32767))\n-            *total = 1;\n-          else\n-            *total = COSTS_N_INSNS (2);\n-        }\n-      else if (outer_code == AND || outer_code == IOR)\n-        {\n-          if (INTVAL (x) >= 0 && INTVAL (x) <= 16383)\n-            *total = 0;\n-          else if (((INTVAL (x) & 0xffff) == 0)\n-                   || (INTVAL (x) >= 0 && INTVAL (x) <= 65535))\n-            *total = 1;\n-          else\n-            *total = COSTS_N_INSNS (2);\n-        }\n-      else\n-        {\n-          *total = 0;\n-        }\n-      return true;\n-\n-    case CONST:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-    case CONST_DOUBLE:\n-      *total = COSTS_N_INSNS (2);\n-      return true;\n-\n-    case MEM:\n-      {\n-        /* If the address is legitimate, return the number of\n-           instructions it needs, otherwise use the default handling.  */\n-        int n = score_address_insns (XEXP (x, 0), GET_MODE (x));\n-        if (n > 0)\n-          {\n-            *total = COSTS_N_INSNS (n + 1);\n-            return true;\n-          }\n-        return false;\n-      }\n-\n-    case FFS:\n-      *total = COSTS_N_INSNS (6);\n-      return true;\n-\n-    case NOT:\n-      *total = COSTS_N_INSNS (1);\n-      return true;\n-\n-    case AND:\n-    case IOR:\n-    case XOR:\n-      if (mode == DImode)\n-        {\n-          *total = COSTS_N_INSNS (2);\n-          return true;\n-        }\n-      return false;\n-\n-    case ASHIFT:\n-    case ASHIFTRT:\n-    case LSHIFTRT:\n-      if (mode == DImode)\n-        {\n-          *total = COSTS_N_INSNS ((GET_CODE (XEXP (x, 1)) == CONST_INT)\n-                                  ? 4 : 12);\n-          return true;\n-        }\n-      return false;\n-\n-    case ABS:\n-      *total = COSTS_N_INSNS (4);\n-      return true;\n-\n-    case PLUS:\n-    case MINUS:\n-      if (mode == DImode)\n-        {\n-          *total = COSTS_N_INSNS (4);\n-          return true;\n-        }\n-      *total = COSTS_N_INSNS (1);\n-      return true;\n-\n-    case NEG:\n-      if (mode == DImode)\n-        {\n-          *total = COSTS_N_INSNS (4);\n-          return true;\n-        }\n-      return false;\n-\n-    case MULT:\n-      *total = optimize_size ? COSTS_N_INSNS (2) : COSTS_N_INSNS (12);\n-      return true;\n-\n-    case DIV:\n-    case MOD:\n-    case UDIV:\n-    case UMOD:\n-      *total = optimize_size ? COSTS_N_INSNS (2) : COSTS_N_INSNS (33);\n-      return true;\n-\n-    case SIGN_EXTEND:\n-    case ZERO_EXTEND:\n-      switch (GET_MODE (XEXP (x, 0)))\n-        {\n-        case QImode:\n-        case HImode:\n-          if (GET_CODE (XEXP (x, 0)) == MEM)\n-            {\n-              *total = COSTS_N_INSNS (2);\n-\n-              if (!TARGET_LITTLE_ENDIAN &&\n-                  side_effects_p (XEXP (XEXP (x, 0), 0)))\n-                *total = 100;\n-            }\n-          else\n-            *total = COSTS_N_INSNS (1);\n-          break;\n-\n-        default:\n-          *total = COSTS_N_INSNS (1);\n-          break;\n-        }\n-      return true;\n-\n-    default:\n-      return false;\n-    }\n-}\n-\n-/* Implement TARGET_ADDRESS_COST macro.  */\n-int\n-score_address_cost (rtx addr, enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t    addr_space_t as ATTRIBUTE_UNUSED,\n-\t\t    bool speed ATTRIBUTE_UNUSED)\n-{\n-  return score_address_insns (addr, SImode);\n-}\n-\n-/* Implement ASM_OUTPUT_EXTERNAL macro.  */\n-int\n-score_output_external (FILE *file ATTRIBUTE_UNUSED,\n-                       tree decl, const char *name)\n-{\n-  register struct extern_list *p;\n-\n-  if (score_in_small_data_p (decl))\n-    {\n-      p = ggc_alloc<extern_list> ();\n-      p->next = extern_head;\n-      p->name = name;\n-      p->size = int_size_in_bytes (TREE_TYPE (decl));\n-      extern_head = p;\n-    }\n-  return 0;\n-}\n-\n-/* Implement RETURN_ADDR_RTX.  Note, we do not support moving\n-   back to a previous frame.  */\n-rtx\n-score_return_addr (int count, rtx frame ATTRIBUTE_UNUSED)\n-{\n-  if (count != 0)\n-    return const0_rtx;\n-  return get_hard_reg_initial_val (Pmode, RA_REGNUM);\n-}\n-\n-/* Implement PRINT_OPERAND macro.  */\n-/* Score-specific operand codes:\n-   '['        print .set nor1 directive\n-   ']'        print .set r1 directive\n-   'U'        print hi part of a CONST_INT rtx\n-   'E'        print log2(v)\n-   'F'        print log2(~v)\n-   'D'        print SFmode const double\n-   'S'        selectively print \"!\" if operand is 15bit instruction accessible\n-   'V'        print \"v!\" if operand is 15bit instruction accessible, or \"lfh!\"\n-   'L'        low  part of DImode reg operand\n-   'H'        high part of DImode reg operand\n-   'C'        print part of opcode for a branch condition.  */\n-void\n-score_print_operand (FILE *file, rtx op, int c)\n-{\n-  enum rtx_code code = UNKNOWN;\n-  if (!PRINT_OPERAND_PUNCT_VALID_P (c))\n-    code = GET_CODE (op);\n-\n-  if (c == '[')\n-    {\n-      fprintf (file, \".set r1\\n\");\n-    }\n-  else if (c == ']')\n-    {\n-      fprintf (file, \"\\n\\t.set nor1\");\n-    }\n-  else if (c == 'U')\n-    {\n-      gcc_assert (code == CONST_INT);\n-      fprintf (file, HOST_WIDE_INT_PRINT_HEX,\n-               (INTVAL (op) >> 16) & 0xffff);\n-    }\n-  else if (c == 'D')\n-    {\n-      if (GET_CODE (op) == CONST_DOUBLE)\n-        {\n-          rtx temp = gen_lowpart (SImode, op);\n-          gcc_assert (GET_MODE (op) == SFmode);\n-          fprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (temp) & 0xffffffff);\n-        }\n-      else\n-        output_addr_const (file, op);\n-    }\n-  else if (c == 'S')\n-    {\n-      gcc_assert (code == REG);\n-      if (G16_REG_P (REGNO (op)))\n-        fprintf (file, \"!\");\n-    }\n-  else if (c == 'V')\n-    {\n-      gcc_assert (code == REG);\n-      fprintf (file, G16_REG_P (REGNO (op)) ? \"v!\" : \"lfh!\");\n-    }\n-  else if (c == 'C')\n-    {\n-      enum machine_mode mode = GET_MODE (XEXP (op, 0));\n-\n-      switch (code)\n-        {\n-        case EQ: fputs (\"eq\", file); break;\n-        case NE: fputs (\"ne\", file); break;\n-        case GT: fputs (\"gt\", file); break;\n-        case GE: fputs (mode != CCmode ? \"pl\" : \"ge\", file); break;\n-        case LT: fputs (mode != CCmode ? \"mi\" : \"lt\", file); break;\n-        case LE: fputs (\"le\", file); break;\n-        case GTU: fputs (\"gtu\", file); break;\n-        case GEU: fputs (\"cs\", file); break;\n-        case LTU: fputs (\"cc\", file); break;\n-        case LEU: fputs (\"leu\", file); break;\n-        default:\n-          output_operand_lossage (\"invalid operand for code: '%c'\", code);\n-        }\n-    }\n-  else if (c == 'E')\n-    {\n-      unsigned HOST_WIDE_INT i;\n-      unsigned HOST_WIDE_INT pow2mask = 1;\n-      unsigned HOST_WIDE_INT val;\n-\n-      val = INTVAL (op);\n-      for (i = 0; i < 32; i++)\n-        {\n-          if (val == pow2mask)\n-            break;\n-          pow2mask <<= 1;\n-        }\n-      gcc_assert (i < 32);\n-      fprintf (file, HOST_WIDE_INT_PRINT_HEX, i);\n-    }\n-  else if (c == 'F')\n-    {\n-      unsigned HOST_WIDE_INT i;\n-      unsigned HOST_WIDE_INT pow2mask = 1;\n-      unsigned HOST_WIDE_INT val;\n-\n-      val = ~INTVAL (op);\n-      for (i = 0; i < 32; i++)\n-        {\n-          if (val == pow2mask)\n-            break;\n-          pow2mask <<= 1;\n-        }\n-      gcc_assert (i < 32);\n-      fprintf (file, HOST_WIDE_INT_PRINT_HEX, i);\n-    }\n-  else if (code == REG)\n-    {\n-      int regnum = REGNO (op);\n-      if ((c == 'H' && !WORDS_BIG_ENDIAN)\n-          || (c == 'L' && WORDS_BIG_ENDIAN))\n-        regnum ++;\n-      fprintf (file, \"%s\", reg_names[regnum]);\n-    }\n-  else\n-    {\n-      switch (code)\n-        {\n-        case MEM:\n-          score_print_operand_address (file, op);\n-          break;\n-        default:\n-          output_addr_const (file, op);\n-        }\n-    }\n-}\n-\n-/* Implement PRINT_OPERAND_ADDRESS macro.  */\n-void\n-score_print_operand_address (FILE *file, rtx x)\n-{\n-  struct score_address_info addr;\n-  enum rtx_code code = GET_CODE (x);\n-  enum machine_mode mode = GET_MODE (x);\n-\n-  if (code == MEM)\n-    x = XEXP (x, 0);\n-\n-  if (score_classify_address (&addr, mode, x, true))\n-    {\n-      switch (addr.type)\n-        {\n-        case SCORE_ADD_REG:\n-          {\n-            switch (addr.code)\n-              {\n-              case PRE_DEC:\n-                fprintf (file, \"[%s,-%ld]+\", reg_names[REGNO (addr.reg)],\n-                         INTVAL (addr.offset));\n-                break;\n-              case POST_DEC:\n-                fprintf (file, \"[%s]+,-%ld\", reg_names[REGNO (addr.reg)],\n-                         INTVAL (addr.offset));\n-                break;\n-              case PRE_INC:\n-                fprintf (file, \"[%s, %ld]+\", reg_names[REGNO (addr.reg)],\n-                         INTVAL (addr.offset));\n-                break;\n-              case POST_INC:\n-                fprintf (file, \"[%s]+, %ld\", reg_names[REGNO (addr.reg)],\n-                         INTVAL (addr.offset));\n-                break;\n-              default:\n-                if (INTVAL(addr.offset) == 0)\n-                  fprintf(file, \"[%s]\", reg_names[REGNO (addr.reg)]);\n-                else\n-                  fprintf(file, \"[%s, %ld]\", reg_names[REGNO (addr.reg)],\n-                          INTVAL(addr.offset));\n-                break;\n-              }\n-          }\n-          return;\n-        case SCORE_ADD_CONST_INT:\n-        case SCORE_ADD_SYMBOLIC:\n-          output_addr_const (file, x);\n-          return;\n-        }\n-    }\n-  print_rtl (stderr, x);\n-  gcc_unreachable ();\n-}\n-\n-/* Implement SELECT_CC_MODE macro.  */\n-enum machine_mode\n-score_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n-{\n-  if ((op == EQ || op == NE || op == LT || op == GE)\n-      && y == const0_rtx\n-      && GET_MODE (x) == SImode)\n-    {\n-      switch (GET_CODE (x))\n-        {\n-        case PLUS:\n-        case MINUS:\n-        case NEG:\n-        case AND:\n-        case IOR:\n-        case XOR:\n-        case NOT:\n-        case ASHIFT:\n-        case LSHIFTRT:\n-        case ASHIFTRT:\n-          return CC_NZmode;\n-\n-        case SIGN_EXTEND:\n-        case ZERO_EXTEND:\n-        case ROTATE:\n-        case ROTATERT:\n-          return (op == LT || op == GE) ? CC_Nmode : CCmode;\n-\n-        default:\n-          return CCmode;\n-        }\n-    }\n-\n-  if ((op == EQ || op == NE)\n-      && (GET_CODE (y) == NEG)\n-      && register_operand (XEXP (y, 0), SImode)\n-      && register_operand (x, SImode))\n-    {\n-      return CC_NZmode;\n-    }\n-\n-  return CCmode;\n-}\n-\n-/* Generate the prologue instructions for entry into a S+core function.  */\n-void\n-score_prologue (void)\n-{\n-#define EMIT_PL(_rtx)        RTX_FRAME_RELATED_P (_rtx) = 1\n-\n-  struct score_frame_info *f = score_compute_frame_size (get_frame_size ());\n-  HOST_WIDE_INT size;\n-  int regno;\n-\n-  size = f->total_size - f->gp_reg_size;\n-\n-  if (flag_pic)\n-    emit_insn (gen_cpload_score7 ());\n-\n-  for (regno = (int) GP_REG_LAST; regno >= (int) GP_REG_FIRST; regno--)\n-    {\n-      if (BITSET_P (f->mask, regno - GP_REG_FIRST))\n-        {\n-          rtx mem = gen_rtx_MEM (SImode,\n-                                 gen_rtx_PRE_DEC (SImode, stack_pointer_rtx));\n-          rtx reg = gen_rtx_REG (SImode, regno);\n-          if (!crtl->calls_eh_return)\n-            MEM_READONLY_P (mem) = 1;\n-          EMIT_PL (emit_insn (gen_pushsi_score7 (mem, reg)));\n-        }\n-    }\n-\n-  if (size > 0)\n-    {\n-      rtx_insn *insn;\n-\n-      if (size >= -32768 && size <= 32767)\n-        EMIT_PL (emit_insn (gen_add3_insn (stack_pointer_rtx,\n-                                           stack_pointer_rtx,\n-                                           GEN_INT (-size))));\n-      else\n-        {\n-          EMIT_PL (emit_move_insn (gen_rtx_REG (Pmode, SCORE_PROLOGUE_TEMP_REGNUM),\n-                                   GEN_INT (size)));\n-          EMIT_PL (emit_insn\n-                   (gen_sub3_insn (stack_pointer_rtx,\n-                                   stack_pointer_rtx,\n-                                   gen_rtx_REG (Pmode,\n-                                                SCORE_PROLOGUE_TEMP_REGNUM))));\n-        }\n-      insn = get_last_insn ();\n-      REG_NOTES (insn) =\n-        alloc_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-                         gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-                                      plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t     -size)),\n-                                      REG_NOTES (insn));\n-    }\n-\n-  if (frame_pointer_needed)\n-    EMIT_PL (emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx));\n-\n-  if (flag_pic && f->cprestore_size)\n-    {\n-      if (frame_pointer_needed)\n-        emit_insn (gen_cprestore_use_fp_score7 (GEN_INT (size - f->cprestore_size)));\n-      else\n-        emit_insn (gen_cprestore_use_sp_score7 (GEN_INT (size - f->cprestore_size)));\n-    }\n-\n-#undef EMIT_PL\n-}\n-\n-/* Generate the epilogue instructions in a S+core function.  */\n-void\n-score_epilogue (int sibcall_p)\n-{\n-  struct score_frame_info *f = score_compute_frame_size (get_frame_size ());\n-  HOST_WIDE_INT size;\n-  int regno;\n-  rtx base;\n-\n-  size = f->total_size - f->gp_reg_size;\n-\n-  if (!frame_pointer_needed)\n-    base = stack_pointer_rtx;\n-  else\n-    base = hard_frame_pointer_rtx;\n-\n-  if (size)\n-    {\n-      if (size >= -32768 && size <= 32767)\n-        emit_insn (gen_add3_insn (base, base, GEN_INT (size)));\n-      else\n-        {\n-          emit_move_insn (gen_rtx_REG (Pmode, SCORE_EPILOGUE_TEMP_REGNUM),\n-                          GEN_INT (size));\n-          emit_insn (gen_add3_insn (base, base,\n-                                    gen_rtx_REG (Pmode,\n-                                                 SCORE_EPILOGUE_TEMP_REGNUM)));\n-        }\n-    }\n-\n-  if (base != stack_pointer_rtx)\n-    emit_move_insn (stack_pointer_rtx, base);\n-\n-  if (crtl->calls_eh_return)\n-    emit_insn (gen_add3_insn (stack_pointer_rtx,\n-                              stack_pointer_rtx,\n-                              EH_RETURN_STACKADJ_RTX));\n-\n-  for (regno = (int) GP_REG_FIRST; regno <= (int) GP_REG_LAST; regno++)\n-    {\n-      if (BITSET_P (f->mask, regno - GP_REG_FIRST))\n-        {\n-          rtx mem = gen_rtx_MEM (SImode,\n-                                 gen_rtx_POST_INC (SImode, stack_pointer_rtx));\n-          rtx reg = gen_rtx_REG (SImode, regno);\n-\n-          if (!crtl->calls_eh_return)\n-            MEM_READONLY_P (mem) = 1;\n-\n-          emit_insn (gen_popsi_score7 (reg, mem));\n-        }\n-    }\n-\n-  if (!sibcall_p)\n-    emit_jump_insn (gen_return_internal_score7 (gen_rtx_REG (Pmode, RA_REGNUM)));\n-}\n-\n-/* Return true if X is a symbolic constant that can be calculated in\n-   the same way as a bare symbol.  If it is, store the type of the\n-   symbol in *SYMBOL_TYPE.  */\n-int\n-score_symbolic_constant_p (rtx x, enum score_symbol_type *symbol_type)\n-{\n-  HOST_WIDE_INT offset;\n-\n-  score_split_const (x, &x, &offset);\n-  if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n-    *symbol_type = score_classify_symbol (x);\n-  else\n-    return 0;\n-\n-  if (offset == 0)\n-    return 1;\n-\n-  /* if offset > 15bit, must reload  */\n-  if (!IMM_IN_RANGE (offset, 15, 1))\n-    return 0;\n-\n-  switch (*symbol_type)\n-    {\n-    case SYMBOL_GENERAL:\n-      return 1;\n-    case SYMBOL_SMALL_DATA:\n-      return score_offset_within_object_p (x, offset);\n-    }\n-  gcc_unreachable ();\n-}\n-\n-void\n-score_movsicc (rtx *ops)\n-{\n-  enum machine_mode mode;\n-\n-  mode = score_select_cc_mode (GET_CODE (ops[1]), ops[2], ops[3]);\n-  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (mode, CC_REGNUM),\n-                          gen_rtx_COMPARE (mode, XEXP (ops[1], 0),\n-\t\t\t\t\t   XEXP (ops[1], 1))));\n-}\n-\n-/* Call and sibcall pattern all need call this function.  */\n-void\n-score_call (rtx *ops, bool sib)\n-{\n-  rtx addr = XEXP (ops[0], 0);\n-  if (!call_insn_operand (addr, VOIDmode))\n-    {\n-      rtx oaddr = addr;\n-      addr = gen_reg_rtx (Pmode);\n-      gen_move_insn (addr, oaddr);\n-    }\n-\n-  if (sib)\n-    emit_call_insn (gen_sibcall_internal_score7 (addr, ops[1]));\n-  else\n-    emit_call_insn (gen_call_internal_score7 (addr, ops[1]));\n-}\n-\n-/* Call value and sibcall value pattern all need call this function.  */\n-void\n-score_call_value (rtx *ops, bool sib)\n-{\n-  rtx result = ops[0];\n-  rtx addr = XEXP (ops[1], 0);\n-  rtx arg = ops[2];\n-\n-  if (!call_insn_operand (addr, VOIDmode))\n-    {\n-      rtx oaddr = addr;\n-      addr = gen_reg_rtx (Pmode);\n-      gen_move_insn (addr, oaddr);\n-    }\n-\n-  if (sib)\n-    emit_call_insn (gen_sibcall_value_internal_score7 (result, addr, arg));\n-  else\n-    emit_call_insn (gen_call_value_internal_score7 (result, addr, arg));\n-}\n-\n-/* Machine Split  */\n-void\n-score_movdi (rtx *ops)\n-{\n-  rtx dst = ops[0];\n-  rtx src = ops[1];\n-  rtx dst0 = score_subw (dst, 0);\n-  rtx dst1 = score_subw (dst, 1);\n-  rtx src0 = score_subw (src, 0);\n-  rtx src1 = score_subw (src, 1);\n-\n-  if (GET_CODE (dst0) == REG && reg_overlap_mentioned_p (dst0, src))\n-    {\n-      emit_move_insn (dst1, src1);\n-      emit_move_insn (dst0, src0);\n-    }\n-  else\n-    {\n-      emit_move_insn (dst0, src0);\n-      emit_move_insn (dst1, src1);\n-    }\n-}\n-\n-void\n-score_zero_extract_andi (rtx *ops)\n-{\n-  if (INTVAL (ops[1]) == 1 && const_uimm5 (ops[2], SImode))\n-    emit_insn (gen_zero_extract_bittst_score7 (ops[0], ops[2]));\n-  else\n-    {\n-      unsigned HOST_WIDE_INT mask;\n-      mask = (0xffffffffU & ((1U << INTVAL (ops[1])) - 1U));\n-      mask = mask << INTVAL (ops[2]);\n-      emit_insn (gen_andsi3_cmp_score7 (ops[3], ops[0],\n-                                 gen_int_mode (mask, SImode)));\n-    }\n-}\n-\n-/* Check addr could be present as PRE/POST mode.  */\n-static bool\n-score_pindex_mem (rtx addr)\n-{\n-  if (GET_CODE (addr) == MEM)\n-    {\n-      switch (GET_CODE (XEXP (addr, 0)))\n-        {\n-        case PRE_DEC:\n-        case POST_DEC:\n-        case PRE_INC:\n-        case POST_INC:\n-          return true;\n-        default:\n-          break;\n-        }\n-    }\n-  return false;\n-}\n-\n-/* Output asm code for ld/sw insn.  */\n-static int\n-score_pr_addr_post (rtx *ops, int idata, int iaddr, char *ip, enum score_mem_unit unit)\n-{\n-  struct score_address_info ai;\n-\n-  gcc_assert (GET_CODE (ops[idata]) == REG);\n-  gcc_assert (score_classify_address (&ai, SImode, XEXP (ops[iaddr], 0), true));\n-\n-  if (!score_pindex_mem (ops[iaddr])\n-      && ai.type == SCORE_ADD_REG\n-      && GET_CODE (ai.offset) == CONST_INT\n-      && G16_REG_P (REGNO (ops[idata]))\n-      && G16_REG_P (REGNO (ai.reg)))\n-    {\n-      if (INTVAL (ai.offset) == 0)\n-        {\n-          ops[iaddr] = ai.reg;\n-          return snprintf (ip, INS_BUF_SZ,\n-                           \"!\\t%%%d, [%%%d]\", idata, iaddr);\n-        }\n-      if (REGNO (ai.reg) == HARD_FRAME_POINTER_REGNUM)\n-        {\n-          HOST_WIDE_INT offset = INTVAL (ai.offset);\n-          if (SCORE_ALIGN_UNIT (offset, unit)\n-              && (((offset >> unit) >= 0) && ((offset >> unit) <= 31)))\n-            {\n-              ops[iaddr] = ai.offset;\n-              return snprintf (ip, INS_BUF_SZ,\n-                               \"p!\\t%%%d, %%c%d\", idata, iaddr);\n-            }\n-        }\n-    }\n-  return snprintf (ip, INS_BUF_SZ, \"\\t%%%d, %%a%d\", idata, iaddr);\n-}\n-\n-/* Output asm insn for load.  */\n-const char *\n-score_linsn (rtx *ops, enum score_mem_unit unit, bool sign)\n-{\n-  const char *pre_ins[] =\n-    {\"lbu\", \"lhu\", \"lw\", \"??\", \"lb\", \"lh\", \"lw\", \"??\"};\n-  char *ip;\n-\n-  strcpy (score_ins, pre_ins[(sign ? 4 : 0) + unit]);\n-  ip = score_ins + strlen (score_ins);\n-\n-  if ((!sign && unit != SCORE_HWORD)\n-      || (sign && unit != SCORE_BYTE))\n-    score_pr_addr_post (ops, 0, 1, ip, unit);\n-  else\n-    snprintf (ip, INS_BUF_SZ, \"\\t%%0, %%a1\");\n-\n-  return score_ins;\n-}\n-\n-/* Output asm insn for store.  */\n-const char *\n-score_sinsn (rtx *ops, enum score_mem_unit unit)\n-{\n-  const char *pre_ins[] = {\"sb\", \"sh\", \"sw\"};\n-  char *ip;\n-\n-  strcpy (score_ins, pre_ins[unit]);\n-  ip = score_ins + strlen (score_ins);\n-  score_pr_addr_post (ops, 1, 0, ip, unit);\n-  return score_ins;\n-}\n-\n-/* Output asm insn for load immediate.  */\n-const char *\n-score_limm (rtx *ops)\n-{\n-  HOST_WIDE_INT v;\n-\n-  gcc_assert (GET_CODE (ops[0]) == REG);\n-  gcc_assert (GET_CODE (ops[1]) == CONST_INT);\n-\n-  v = INTVAL (ops[1]);\n-  if (G16_REG_P (REGNO (ops[0])) && IMM_IN_RANGE (v, 8, 0))\n-    return \"ldiu!\\t%0, %c1\";\n-  else if (IMM_IN_RANGE (v, 16, 1))\n-    return \"ldi\\t%0, %c1\";\n-  else if ((v & 0xffff) == 0)\n-    return \"ldis\\t%0, %U1\";\n-  else\n-    return \"li\\t%0, %c1\";\n-}\n-\n-/* Output asm insn for move.  */\n-const char *\n-score_move (rtx *ops)\n-{\n-  gcc_assert (GET_CODE (ops[0]) == REG);\n-  gcc_assert (GET_CODE (ops[1]) == REG);\n-\n-  if (G16_REG_P (REGNO (ops[0])))\n-    {\n-      if (G16_REG_P (REGNO (ops[1])))\n-        return \"mv!\\t%0, %1\";\n-      else\n-        return \"mlfh!\\t%0, %1\";\n-    }\n-  else if (G16_REG_P (REGNO (ops[1])))\n-    return \"mhfl!\\t%0, %1\";\n-  else\n-    return \"mv\\t%0, %1\";\n-}\n-\n-/* Generate add insn.  */\n-const char *\n-score_select_add_imm (rtx *ops, bool set_cc)\n-{\n-  HOST_WIDE_INT v = INTVAL (ops[2]);\n-\n-  gcc_assert (GET_CODE (ops[2]) == CONST_INT);\n-  gcc_assert (REGNO (ops[0]) == REGNO (ops[1]));\n-\n-  if (set_cc && G16_REG_P (REGNO (ops[0])))\n-    {\n-      if (v > 0 && IMM_IS_POW_OF_2 ((unsigned HOST_WIDE_INT) v, 0, 15))\n-        {\n-          ops[2] = GEN_INT (ffs (v) - 1);\n-          return \"addei!\\t%0, %c2\";\n-        }\n-\n-      if (v < 0 && IMM_IS_POW_OF_2 ((unsigned HOST_WIDE_INT) (-v), 0, 15))\n-        {\n-          ops[2] = GEN_INT (ffs (-v) - 1);\n-          return \"subei!\\t%0, %c2\";\n-        }\n-    }\n-\n-  if (set_cc)\n-    return \"addi.c\\t%0, %c2\";\n-  else\n-    return \"addi\\t%0, %c2\";\n-}\n-\n-/* Output arith insn.  */\n-const char *\n-score_select (rtx *ops, const char *inst_pre,\n-              bool commu, const char *letter, bool set_cc)\n-{\n-  gcc_assert (GET_CODE (ops[0]) == REG);\n-  gcc_assert (GET_CODE (ops[1]) == REG);\n-\n-  if (set_cc && G16_REG_P (REGNO (ops[0]))\n-      && (GET_CODE (ops[2]) == REG ? G16_REG_P (REGNO (ops[2])) : 1)\n-      && REGNO (ops[0]) == REGNO (ops[1]))\n-    {\n-      snprintf (score_ins, INS_BUF_SZ, \"%s!\\t%%0, %%%s2\", inst_pre, letter);\n-      return score_ins;\n-    }\n-\n-  if (commu && set_cc && G16_REG_P (REGNO (ops[0]))\n-      && G16_REG_P (REGNO (ops[1]))\n-      && REGNO (ops[0]) == REGNO (ops[2]))\n-    {\n-      gcc_assert (GET_CODE (ops[2]) == REG);\n-      snprintf (score_ins, INS_BUF_SZ, \"%s!\\t%%0, %%%s1\", inst_pre, letter);\n-      return score_ins;\n-    }\n-\n-  if (set_cc)\n-    snprintf (score_ins, INS_BUF_SZ, \"%s.c\\t%%0, %%1, %%%s2\", inst_pre, letter);\n-  else\n-    snprintf (score_ins, INS_BUF_SZ, \"%s\\t%%0, %%1, %%%s2\", inst_pre, letter);\n-  return score_ins;\n-}\n-\n-/* Return nonzero when an argument must be passed by reference.  */\n-static bool\n-score_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-                         enum machine_mode mode, const_tree type,\n-                         bool named ATTRIBUTE_UNUSED)\n-{\n-  /* If we have a variable-sized parameter, we have no choice.  */\n-  return targetm.calls.must_pass_in_stack (mode, type);\n-}\n-\n-/* Implement TARGET_FUNCTION_OK_FOR_SIBCALL.  */\n-static bool\n-score_function_ok_for_sibcall (ATTRIBUTE_UNUSED tree decl,\n-                               ATTRIBUTE_UNUSED tree exp)\n-{\n-  return true;\n-}\n-\n-/* Implement TARGET_SCHED_ISSUE_RATE.  */\n-static int\n-score_issue_rate (void)\n-{\n-  return 1;\n-}\n-\n-/* We can always eliminate to the hard frame pointer.  We can eliminate\n-   to the stack pointer unless a frame pointer is needed.  */\n-\n-static bool\n-score_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)\n-{\n-  return (to == HARD_FRAME_POINTER_REGNUM\n-          || (to  == STACK_POINTER_REGNUM && !frame_pointer_needed));\n-}\n-\n-/* Argument support functions.  */\n-\n-/* Initialize CUMULATIVE_ARGS for a function.  */\n-void\n-score_init_cumulative_args (CUMULATIVE_ARGS *cum,\n-                            tree fntype ATTRIBUTE_UNUSED,\n-                            rtx libname ATTRIBUTE_UNUSED)\n-{\n-  memset (cum, 0, sizeof (CUMULATIVE_ARGS));\n-}\n-\n-static void\n-score_conditional_register_usage (void)\n-{\n-   if (!flag_pic)\n-     fixed_regs[PIC_OFFSET_TABLE_REGNUM] =\n-     call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 0;\n-}\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "125a209637c2a4dc4de6249828f0d43664fd7df9", "filename": "gcc/config/score/score.h", "status": "removed", "additions": 0, "deletions": 867, "changes": 867, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Fscore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Fscore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.h?ref=bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8", "patch": "@@ -1,867 +0,0 @@\n-/* score.h for Sunplus S+CORE processor\n-   Copyright (C) 2005-2014 Free Software Foundation, Inc.\n-   Contributed by Sunnorth.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"score-conv.h\"\n-\n-#undef CC1_SPEC\n-#define CC1_SPEC                 \"%{!mel:-meb} %{mel:-mel } \\\n-%{!mscore*:-mscore7}    \\\n-%{mscore7:-mscore7}     \\\n-%{mscore7d:-mscore7d}   \\\n-%{G*}\"\n-\n-#undef ASM_SPEC\n-#define ASM_SPEC                 \"%{!mel:-EB} %{mel:-EL} \\\n-%{!mscore*:-march=score7}         \\\n-%{mscore7:-march=score7}          \\\n-%{mscore7d:-march=score7}         \\\n-%{march=score7:-march=score7}     \\\n-%{march=score7d:-march=score7}    \\\n-%{G*}\"\n-\n-#undef LINK_SPEC\n-#define LINK_SPEC                \"%{!mel:-EB} %{mel:-EL} \\\n-%{!mscore*:-mscore7_elf}          \\\n-%{mscore7:-mscore7_elf}           \\\n-%{mscore7d:-mscore7_elf}          \\\n-%{march=score7:-mscore7_elf}      \\\n-%{march=score7d:-mscore7_elf}     \\\n-%{G*}\"\n-\n-/* Run-time Target Specification.  */\n-#define TARGET_CPU_CPP_BUILTINS()               \\\n-  do {                                          \\\n-    builtin_define (\"SUNPLUS\");                 \\\n-    builtin_define (\"__SCORE__\");               \\\n-    builtin_define (\"__score__\");               \\\n-    if (TARGET_LITTLE_ENDIAN)                   \\\n-      builtin_define (\"__scorele__\");           \\\n-    else                                        \\\n-      builtin_define (\"__scorebe__\");           \\\n-    if (TARGET_SCORE7)                          \\\n-      builtin_define (\"__score7__\");            \\\n-    if (TARGET_SCORE7D)                         \\\n-      builtin_define (\"__score7d__\");           \\\n-  } while (0)\n-\n-#define TARGET_DEFAULT         0\n-\n-#define SCORE_GCC_VERSION      \"1.6\"\n-\n-/* Target machine storage layout.  */\n-#define BITS_BIG_ENDIAN        0\n-#define BYTES_BIG_ENDIAN       (TARGET_LITTLE_ENDIAN == 0)\n-#define WORDS_BIG_ENDIAN       (TARGET_LITTLE_ENDIAN == 0)\n-\n-/* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD                 4\n-\n-/* Define this macro if it is advisable to hold scalars in registers\n-   in a wider mode than that declared by the program.  In such cases,\n-   the value is constrained to be within the bounds of the declared\n-   type, but kept valid in the wider mode.  The signedness of the\n-   extension may differ from that of the type.  */\n-#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)     \\\n-  if (GET_MODE_CLASS (MODE) == MODE_INT         \\\n-      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD) \\\n-    (MODE) = SImode;\n-\n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY                  BITS_PER_WORD\n-#define STACK_BOUNDARY                 BITS_PER_WORD\n-\n-/* Allocation boundary (in *bits*) for the code of a function.  */\n-#define FUNCTION_BOUNDARY              BITS_PER_WORD\n-\n-/* There is no point aligning anything to a rounder boundary than this.  */\n-#define BIGGEST_ALIGNMENT              LONG_DOUBLE_TYPE_SIZE\n-\n-/* If defined, a C expression to compute the alignment for a static\n-   variable.  TYPE is the data type, and ALIGN is the alignment that\n-   the object would ordinarily have.  The value of this macro is used\n-   instead of that alignment to align the object.\n-\n-   If this macro is not defined, then ALIGN is used.\n-\n-   One use of this macro is to increase alignment of medium-size\n-   data to make it all fit in fewer cache lines.  Another is to\n-   cause character arrays to be word-aligned so that `strcpy' calls\n-   that copy constants to character arrays can be done inline.  */\n-#define DATA_ALIGNMENT(TYPE, ALIGN)                                      \\\n-  ((((ALIGN) < BITS_PER_WORD)                                            \\\n-    && (TREE_CODE (TYPE) == ARRAY_TYPE                                   \\\n-        || TREE_CODE (TYPE) == UNION_TYPE                                \\\n-        || TREE_CODE (TYPE) == RECORD_TYPE)) ? BITS_PER_WORD : (ALIGN))\n-\n-/* If defined, a C expression to compute the alignment given to a\n-   constant that is being placed in memory.  EXP is the constant\n-   and ALIGN is the alignment that the object would ordinarily have.\n-   The value of this macro is used instead of that alignment to align\n-   the object.\n-\n-   If this macro is not defined, then ALIGN is used.\n-\n-   The typical use of this macro is to increase alignment for string\n-   constants to be word aligned so that `strcpy' calls that copy\n-   constants can be done inline.  */\n-#define CONSTANT_ALIGNMENT(EXP, ALIGN)                                  \\\n-  ((TREE_CODE (EXP) == STRING_CST  || TREE_CODE (EXP) == CONSTRUCTOR)   \\\n-   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n-\n-/* If defined, a C expression to compute the alignment for a local\n-   variable.  TYPE is the data type, and ALIGN is the alignment that\n-   the object would ordinarily have.  The value of this macro is used\n-   instead of that alignment to align the object.\n-\n-   If this macro is not defined, then ALIGN is used.\n-\n-   One use of this macro is to increase alignment of medium-size\n-   data to make it all fit in fewer cache lines.  */\n-#define LOCAL_ALIGNMENT(TYPE, ALIGN)                                    \\\n-  ((TREE_CODE (TYPE) == ARRAY_TYPE                                      \\\n-    && TYPE_MODE (TREE_TYPE (TYPE)) == QImode                           \\\n-    && (ALIGN) < BITS_PER_WORD) ? BITS_PER_WORD : (ALIGN))\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY           32\n-\n-/* All accesses must be aligned.  */\n-#define STRICT_ALIGNMENT               1\n-\n-/* Score requires that structure alignment is affected by bitfields.  */\n-#define PCC_BITFIELD_TYPE_MATTERS      1\n-\n-/* long double is not a fixed mode, but the idea is that, if we\n-   support long double, we also want a 128-bit integer type.  */\n-#define MAX_FIXED_MODE_SIZE            LONG_DOUBLE_TYPE_SIZE\n-\n-/* Layout of Data Type.  */\n-/* Set the sizes of the core types.  */\n-#define INT_TYPE_SIZE                   32\n-#define SHORT_TYPE_SIZE                 16\n-#define LONG_TYPE_SIZE                  32\n-#define LONG_LONG_TYPE_SIZE             64\n-#define CHAR_TYPE_SIZE                  8\n-#define FLOAT_TYPE_SIZE                 32\n-#define DOUBLE_TYPE_SIZE                64\n-#define LONG_DOUBLE_TYPE_SIZE           64\n-\n-/* Define this as 1 if `char' should by default be signed; else as 0.  */\n-#undef DEFAULT_SIGNED_CHAR\n-#define DEFAULT_SIGNED_CHAR             1\n-\n-/* Default definitions for size_t and ptrdiff_t.  */\n-#define SIZE_TYPE                       \"unsigned int\"\n-\n-#define UINTPTR_TYPE\t\t\t\"long unsigned int\"\n-\n-/* Register Usage\n-\n-   S+core have:\n-   - 32 integer registers\n-   - 16 control registers (cond)\n-   - 16 special registers (ceh/cel/cnt/lcr/scr/arg/fp)\n-   - 32 coprocessors 1 registers\n-   - 32 coprocessors 2 registers\n-   - 32 coprocessors 3 registers.  */\n-#define FIRST_PSEUDO_REGISTER           160\n-\n-/* By default, fix the kernel registers (r30 and r31), the global\n-   pointer (r28) and the stack pointer (r0).  This can change\n-   depending on the command-line options.\n-\n-   Regarding coprocessor registers: without evidence to the contrary,\n-   it's best to assume that each coprocessor register has a unique\n-   use.  This can be overridden, in, e.g., TARGET_OPTION_OVERRIDE or\n-   TARGET_CONDITIONAL_REGISTER_USAGE should the assumption be inappropriate\n-   for a particular target.  */\n-\n-/* Control Registers, use mfcr/mtcr insn\n-    32        cr0         PSR\n-    33        cr1         Condition\n-    34        cr2         ECR\n-    35        cr3         EXCPVec\n-    36        cr4         CCR\n-    37        cr5         EPC\n-    38        cr6         EMA\n-    39        cr7         TLBLock\n-    40        cr8         TLBPT\n-    41        cr8         PEADDR\n-    42        cr10        TLBRPT\n-    43        cr11        PEVN\n-    44        cr12        PECTX\n-    45        cr13\n-    46        cr14\n-    47        cr15\n-\n-    Custom Engine Register, use mfce/mtce\n-    48        CEH        CEH\n-    49        CEL        CEL\n-\n-    Special-Purpose Register, use mfsr/mtsr\n-    50        sr0        CNT\n-    51        sr1        LCR\n-    52        sr2        SCR\n-\n-    53        ARG_POINTER_REGNUM\n-    54        FRAME_POINTER_REGNUM\n-    but Control register have 32 registers, cr16-cr31.  */\n-#define FIXED_REGISTERS                                  \\\n-{                                                        \\\n-  /* General Purpose Registers  */                       \\\n-  1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,        \\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,        \\\n-  /* Control Registers  */                               \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n-  /* CEH/ CEL/ CNT/ LCR/ SCR / ARG_POINTER_REGNUM/ FRAME_POINTER_REGNUM */\\\n-  0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n-  /* CP 1 Registers  */                                  \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n-  /* CP 2 Registers  */                                  \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n-  /* CP 3 Registers  */                                  \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n-}\n-\n-#define CALL_USED_REGISTERS                              \\\n-{                                                        \\\n-  /* General purpose register  */                        \\\n-  1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,        \\\n-  0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n-  /* Control Registers  */                               \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n-  /* CP 1 Registers  */                                  \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n-  /* CP 2 Registers  */                                  \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n-  /* CP 3 Registers  */                                  \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        \\\n-}\n-\n-#define REG_ALLOC_ORDER                                                   \\\n-{   0,  1,  6,  7,  8,  9, 10, 11,  4,  5, 22, 23, 24, 25, 26, 27,        \\\n-   12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 28, 29, 30, 31,  2,  3,        \\\n-   32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,        \\\n-   48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,        \\\n-   64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,        \\\n-   80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,        \\\n-   96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111,        \\\n-  112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,        \\\n-  128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,        \\\n-  144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159        }\n-\n-/* Macro to conditionally modify fixed_regs/call_used_regs.  */\n-#define PIC_OFFSET_TABLE_REGNUM          29\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE) \\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* Return true if REGNO is suitable for holding a quantity of type MODE.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) score_hard_regno_mode_ok (REGNO, MODE)\n-\n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2)                             \\\n-  ((GET_MODE_CLASS (MODE1) == MODE_FLOAT                          \\\n-    || GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)              \\\n-   == (GET_MODE_CLASS (MODE2) == MODE_FLOAT                       \\\n-       || GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT))\n-\n-/* Register Classes.  */\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.  */\n-enum reg_class\n-{\n-  NO_REGS,\n-  G16_REGS,    /* r0 ~ r15 */\n-  G32_REGS,    /* r0 ~ r31 */\n-  T32_REGS,    /* r8 ~ r11 | r22 ~ r27 */\n-\n-  HI_REG,      /* hi                 */\n-  LO_REG,      /* lo                 */\n-  CE_REGS,     /* hi + lo            */\n-\n-  CN_REG,      /* cnt                */\n-  LC_REG,      /* lcb                */\n-  SC_REG,      /* scb                */\n-  SP_REGS,     /* cnt + lcb + scb    */\n-\n-  CR_REGS,     /* cr0 - cr15         */\n-\n-  CP1_REGS,    /* cp1                */\n-  CP2_REGS,    /* cp2                */\n-  CP3_REGS,    /* cp3                */\n-  CPA_REGS,    /* cp1 + cp2 + cp3    */\n-\n-  ALL_REGS,\n-  LIM_REG_CLASSES\n-};\n-\n-#define N_REG_CLASSES                  ((int) LIM_REG_CLASSES)\n-\n-#define GENERAL_REGS                   G32_REGS\n-\n-/* Give names of register classes as strings for dump file.  */\n-#define REG_CLASS_NAMES           \\\n-{                                 \\\n-  \"NO_REGS\",                      \\\n-  \"G16_REGS\",                     \\\n-  \"G32_REGS\",                     \\\n-  \"T32_REGS\",                     \\\n-                                  \\\n-  \"HI_REG\",                       \\\n-  \"LO_REG\",                       \\\n-  \"CE_REGS\",                      \\\n-                                  \\\n-  \"CN_REG\",                       \\\n-  \"LC_REG\",                       \\\n-  \"SC_REG\",                       \\\n-  \"SP_REGS\",                      \\\n-                                  \\\n-  \"CR_REGS\",                      \\\n-                                  \\\n-  \"CP1_REGS\",                     \\\n-  \"CP2_REGS\",                     \\\n-  \"CP3_REGS\",                     \\\n-  \"CPA_REGS\",                     \\\n-                                  \\\n-  \"ALL_REGS\",                     \\\n-}\n-\n-/* Define which registers fit in which classes.  */\n-#define REG_CLASS_CONTENTS                                        \\\n-{                                                                 \\\n-  /* NO_REGS/G16/G32/T32  */                                      \\\n-  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},  \\\n-  { 0x0000ffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000},  \\\n-  { 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000},  \\\n-  { 0x0fc00f00, 0x00000000, 0x00000000, 0x00000000, 0x00000000},  \\\n-  /* HI/LO/CE  */                                                 \\\n-  { 0x00000000, 0x00010000, 0x00000000, 0x00000000, 0x00000000},  \\\n-  { 0x00000000, 0x00020000, 0x00000000, 0x00000000, 0x00000000},  \\\n-  { 0x00000000, 0x00030000, 0x00000000, 0x00000000, 0x00000000},  \\\n-  /* CN/LC/SC/SP/CR  */                                           \\\n-  { 0x00000000, 0x00040000, 0x00000000, 0x00000000, 0x00000000},  \\\n-  { 0x00000000, 0x00080000, 0x00000000, 0x00000000, 0x00000000},  \\\n-  { 0x00000000, 0x00100000, 0x00000000, 0x00000000, 0x00000000},  \\\n-  { 0x00000000, 0x001c0000, 0x00000000, 0x00000000, 0x00000000},  \\\n-  { 0x00000000, 0x0000ffff, 0x00000000, 0x00000000, 0x00000000},  \\\n-  /* CP1/CP2/CP3/CPA  */                                          \\\n-  { 0x00000000, 0x00000000, 0xffffffff, 0x00000000, 0x00000000},  \\\n-  { 0x00000000, 0x00000000, 0x00000000, 0xffffffff, 0x00000000},  \\\n-  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffffffff},  \\\n-  { 0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0xffffffff},  \\\n-  /* ALL_REGS  */                                                 \\\n-  { 0xffffffff, 0x001fffff, 0xffffffff, 0xffffffff, 0xffffffff},  \\\n-}\n-\n-/* A C expression whose value is a register class containing hard\n-   register REGNO.  In general there is more that one such class;\n-   choose a class which is \"minimal\", meaning that no smaller class\n-   also contains the register.  */\n-#define REGNO_REG_CLASS(REGNO) (enum reg_class) score_reg_class (REGNO)\n-\n-/* A macro whose definition is the name of the class to which a\n-   valid base register must belong.  A base register is one used in\n-   an address which is the register value plus a displacement.  */\n-#define BASE_REG_CLASS                 G16_REGS\n-\n-/* The class value for index registers.  */\n-#define INDEX_REG_CLASS                NO_REGS\n-\n-/* Addressing modes, and classification of registers for them.  */\n-#define REGNO_MODE_OK_FOR_BASE_P(REGNO, MODE) \\\n-  score_regno_mode_ok_for_base_p (REGNO, 1)\n-\n-#define REGNO_OK_FOR_INDEX_P(NUM)       0\n-\n-#define PREFERRED_RELOAD_CLASS(X, CLASS) \\\n-  score_preferred_reload_class (X, CLASS)\n-\n-/* If we need to load shorts byte-at-a-time, then we need a scratch.  */\n-#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X) \\\n-  score_secondary_reload_class (CLASS, MODE, X)\n-\n-/* Return the register class of a scratch register needed to copy IN into\n-   or out of a register in CLASS in MODE.  If it can be done directly,\n-   NO_REGS is returned.  */\n-#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X) \\\n-  score_secondary_reload_class (CLASS, MODE, X)\n-\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)    \\\n-  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)        \\\n-   ? reg_classes_intersect_p (HI_REG, (CLASS)) : 0)\n-\n-\n-/* Basic Stack Layout.  */\n-/* Stack layout; function entry, exit and calling.  */\n-#define STACK_GROWS_DOWNWARD\n-\n-#define STACK_PUSH_CODE                 PRE_DEC\n-#define STACK_POP_CODE                  POST_INC\n-\n-/* The offset of the first local variable from the beginning of the frame.\n-   See compute_frame_size for details about the frame layout.  */\n-#define STARTING_FRAME_OFFSET           crtl->outgoing_args_size\n-\n-/* The argument pointer always points to the first argument.  */\n-#define FIRST_PARM_OFFSET(FUNDECL)      0\n-\n-/* A C expression whose value is RTL representing the value of the return\n-   address for the frame COUNT steps up from the current frame.  */\n-#define RETURN_ADDR_RTX(count, frame)   score_return_addr (count, frame)\n-\n-/* Pick up the return address upon entry to a procedure.  */\n-#define INCOMING_RETURN_ADDR_RTX        gen_rtx_REG (VOIDmode, RA_REGNUM)\n-\n-/* Exception handling Support.  */\n-/* Use r0 to r3 to pass exception handling information.  */\n-#define EH_RETURN_DATA_REGNO(N) \\\n-  ((N) < 4 ? (N) + ARG_REG_FIRST : INVALID_REGNUM)\n-\n-/* The register that holds the return address in exception handlers.  */\n-#define EH_RETURN_STACKADJ_RTX          gen_rtx_REG (Pmode, EH_REGNUM)\n-#define EH_RETURN_HANDLER_RTX  \t\tgen_rtx_REG (SImode, 30)\n-\n-/* Registers That Address the Stack Frame.  */\n-/* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM            SP_REGNUM\n-\n-/* These two registers don't really exist: they get eliminated to either\n-   the stack or hard frame pointer.  */\n-#define FRAME_POINTER_REGNUM            53\n-\n-/*  we use r2 as the frame pointer.  */\n-#define HARD_FRAME_POINTER_REGNUM       FP_REGNUM\n-\n-#define ARG_POINTER_REGNUM              54\n-\n-/* Register in which static-chain is passed to a function.  */\n-#define STATIC_CHAIN_REGNUM             23\n-\n-/* Elimination Frame Pointer and Arg Pointer  */\n-\n-#define ELIMINABLE_REGS                                \\\n-  {{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},        \\\n-   { ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},   \\\n-   { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},      \\\n-   { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\n-\n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n-  (OFFSET) = score_initial_elimination_offset ((FROM), (TO))\n-\n-/* Passing Function Arguments on the Stack.  */\n-/* Allocate stack space for arguments at the beginning of each function.  */\n-#define ACCUMULATE_OUTGOING_ARGS        1\n-\n-/* reserve stack space for all argument registers.  */\n-#define REG_PARM_STACK_SPACE(FNDECL)    UNITS_PER_WORD\n-\n-/* Define this if it is the responsibility of the caller to\n-   allocate the area reserved for arguments passed in registers.\n-   If `ACCUMULATE_OUTGOING_ARGS' is also defined, the only effect\n-   of this macro is to determine whether the space is included in\n-   `crtl->outgoing_args_size'.  */\n-#define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 1\n-\n-/* Passing Arguments in Registers  */\n-/* A C type for declaring a variable that is used as the first argument of\n-   `FUNCTION_ARG' and other related values.  For some target machines, the\n-   type `int' suffices and can hold the number of bytes of argument so far.  */\n-typedef struct score_args\n-{\n-  unsigned int arg_number;             /* how many arguments have been seen  */\n-  unsigned int num_gprs;               /* number of gprs in use  */\n-  unsigned int stack_words;            /* number of words in stack  */\n-} score_args_t;\n-\n-#define CUMULATIVE_ARGS                score_args_t\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS\n-   for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.  */\n-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, n_named_args) \\\n-  score_init_cumulative_args (&CUM, FNTYPE, LIBNAME)\n-\n-/* 1 if N is a possible register number for function argument passing.\n-   We have no FP argument registers when soft-float.  When FP registers\n-   are 32 bits, we can't directly reference the odd numbered ones.  */\n-#define FUNCTION_ARG_REGNO_P(REGNO) \\\n-  REG_CONTAIN (REGNO, ARG_REG_FIRST, ARG_REG_NUM)\n-\n-/* How Scalar Function Values Are Returned.  */\n-#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-  score_function_value ((VALTYPE), (FUNC), VOIDmode)\n-\n-#define LIBCALL_VALUE(MODE)  score_function_value (NULL_TREE, NULL, (MODE))\n-\n-/* 1 if N is a possible register number for a function value.  */\n-#define FUNCTION_VALUE_REGNO_P(REGNO)   ((REGNO) == (ARG_REG_FIRST))\n-\n-#define PIC_FUNCTION_ADDR_REGNUM        (GP_REG_FIRST + 25)\n-\n-/* How Large Values Are Returned.  */\n-#define STRUCT_VALUE                    0\n-\n-/* Function Entry and Exit  */\n-/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n-   the stack pointer does not matter.  The value is tested only in\n-   functions that have frame pointers.\n-   No definition is equivalent to always zero.  */\n-#define EXIT_IGNORE_STACK               1\n-\n-/* Generating Code for Profiling  */\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-#define FUNCTION_PROFILER(FILE, LABELNO)                              \\\n-  do {                                                                \\\n-    if (TARGET_SCORE7)                                                \\\n-      {                                                               \\\n-        fprintf (FILE, \" .set r1  \\n\");                               \\\n-        fprintf (FILE, \" mv   r%d,r%d \\n\", AT_REGNUM, RA_REGNUM);     \\\n-        fprintf (FILE, \" subi r%d, %d \\n\", STACK_POINTER_REGNUM, 8);  \\\n-        fprintf (FILE, \" jl   _mcount \\n\");                           \\\n-        fprintf (FILE, \" .set nor1 \\n\");                              \\\n-      }                                                               \\\n-  } while (0)\n-\n-/* Trampolines for Nested Functions.  */\n-#define TRAMPOLINE_INSNS                6\n-\n-/* A C expression for the size in bytes of the trampoline, as an integer.  */\n-#define TRAMPOLINE_SIZE                (24 + GET_MODE_SIZE (ptr_mode) * 2)\n-\n-#define HAVE_PRE_INCREMENT              1\n-#define HAVE_PRE_DECREMENT              1\n-#define HAVE_POST_INCREMENT             1\n-#define HAVE_POST_DECREMENT             1\n-#define HAVE_PRE_MODIFY_DISP            1\n-#define HAVE_POST_MODIFY_DISP           1\n-#define HAVE_PRE_MODIFY_REG             0\n-#define HAVE_POST_MODIFY_REG            0\n-\n-/* Maximum number of registers that can appear in a valid memory address.  */\n-#define MAX_REGS_PER_ADDRESS            1\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects them all.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Some source files that are used after register allocation\n-   need to be strict.  */\n-#ifndef REG_OK_STRICT\n-#define REG_MODE_OK_FOR_BASE_P(X, MODE) \\\n-  score_regno_mode_ok_for_base_p (REGNO (X), 0)\n-#else\n-#define REG_MODE_OK_FOR_BASE_P(X, MODE) \\\n-  score_regno_mode_ok_for_base_p (REGNO (X), 1)\n-#endif\n-\n-#define REG_OK_FOR_INDEX_P(X) 0\n-\n-/* Condition Code Status.  */\n-#define SELECT_CC_MODE(OP, X, Y)        score_select_cc_mode (OP, X, Y)\n-\n-/* Return nonzero if SELECT_CC_MODE will never return MODE for a\n-   floating point inequality comparison.  */\n-#define REVERSIBLE_CC_MODE(MODE)        1\n-\n-/* Describing Relative Costs of Operations  */\n-/* Try to generate sequences that don't involve branches.  */\n-#define BRANCH_COST(speed_p, predictable_p) 2\n-\n-/* Nonzero if access to memory by bytes is slow and undesirable.  */\n-#define SLOW_BYTE_ACCESS                1\n-\n-/* Define this macro if it is as good or better to call a constant\n-   function address than to call an address kept in a register.  */\n-#define NO_FUNCTION_CSE                 1\n-\n-/* Dividing the Output into Sections (Texts, Data, ...).  */\n-/* Define the strings to put out for each section in the object file.  */\n-#define TEXT_SECTION_ASM_OP             \"\\t.text\"\n-#define DATA_SECTION_ASM_OP             \"\\t.data\"\n-#define SDATA_SECTION_ASM_OP            \"\\t.sdata\"\n-\n-#undef  READONLY_DATA_SECTION_ASM_OP\n-#define READONLY_DATA_SECTION_ASM_OP    \"\\t.rdata\"\n-\n-/* The Overall Framework of an Assembler File  */\n-/* How to start an assembler comment.\n-   The leading space is important.  */\n-#define ASM_COMMENT_START               \"#\"\n-\n-/* Output to assembler file text saying following lines\n-   may contain character constants, extra white space, comments, etc.  */\n-#define ASM_APP_ON                     \"#APP\\n\\t.set volatile\\n\"\n-\n-/* Output to assembler file text saying following lines\n-   no longer contain unusual constructs.  */\n-#define ASM_APP_OFF                     \"#NO_APP\\n\\t.set optimize\\n\"\n-\n-/* Output of Uninitialized Variables.  */\n-/* This says how to define a global common symbol.  */\n-#define ASM_OUTPUT_ALIGNED_DECL_COMMON(STREAM, DECL, NAME, SIZE, ALIGN)     \\\n-  do {                                                                      \\\n-    fputs (\"\\n\\t.comm\\t\", STREAM);                                          \\\n-    assemble_name (STREAM, NAME);                                           \\\n-    fprintf (STREAM, \" , \" HOST_WIDE_INT_PRINT_UNSIGNED \", %u\\n\",           \\\n-             SIZE, ALIGN / BITS_PER_UNIT);                                  \\\n-  } while (0)\n-\n-/* This says how to define a local common symbol (i.e., not visible to\n-   linker).  */\n-#undef ASM_OUTPUT_ALIGNED_LOCAL\n-#define ASM_OUTPUT_ALIGNED_LOCAL(STREAM, NAME, SIZE, ALIGN)                 \\\n-  do {                                                                      \\\n-    fputs (\"\\n\\t.lcomm\\t\", STREAM);                                         \\\n-    assemble_name (STREAM, NAME);                                           \\\n-    fprintf (STREAM, \" , \" HOST_WIDE_INT_PRINT_UNSIGNED \", %u\\n\",           \\\n-             SIZE, ALIGN / BITS_PER_UNIT);                                  \\\n-  } while (0)\n-\n-/* Globalizing directive for a label.  */\n-#define GLOBAL_ASM_OP                   \"\\t.globl\\t\"\n-\n-/* Output and Generation of Labels  */\n-/* This is how to declare a function name.  The actual work of\n-   emitting the label is moved to function_prologue, so that we can\n-   get the line number correctly emitted before the .ent directive,\n-   and after any .file directives.  Define as empty so that the function\n-   is not declared before the .ent directive elsewhere.  */\n-#undef ASM_DECLARE_FUNCTION_NAME\n-#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\n-\n-#undef ASM_DECLARE_OBJECT_NAME\n-#define ASM_DECLARE_OBJECT_NAME(STREAM, NAME, DECL)   \\\n-  do {                                                \\\n-    assemble_name (STREAM, NAME);                     \\\n-    fprintf (STREAM, \":\\n\");                          \\\n-  } while (0)\n-\n-/* This says how to output an external.  It would be possible not to\n-   output anything and let undefined symbol become external. However\n-   the assembler uses length information on externals to allocate in\n-   data/sdata bss/sbss, thereby saving exec time.  */\n-#undef ASM_OUTPUT_EXTERNAL\n-#define ASM_OUTPUT_EXTERNAL(STREAM, DECL, NAME) \\\n-  score_output_external (STREAM, DECL, NAME)\n-\n-/* This handles the magic '..CURRENT_FUNCTION' symbol, which means\n-   'the start of the function that this code is output in'.  */\n-#define ASM_OUTPUT_LABELREF(STREAM, NAME) \\\n-  fprintf ((STREAM), \"%s\", (NAME))\n-\n-/* Local compiler-generated symbols must have a prefix that the assembler\n-   understands.  */\n-#define LOCAL_LABEL_PREFIX              (TARGET_SCORE7 ? \".\" : \"$\")\n-\n-#undef ASM_GENERATE_INTERNAL_LABEL\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM) \\\n-  sprintf ((LABEL), \"*%s%s%ld\", (LOCAL_LABEL_PREFIX), (PREFIX), (long) (NUM))\n-\n-/* Output of Assembler Instructions.  */\n-#define REGISTER_NAMES                                                    \\\n-{ \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",                         \\\n-  \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",                   \\\n-  \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",                 \\\n-  \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\",                 \\\n-                                                                          \\\n-  \"cr0\", \"cr1\", \"cr2\", \"cr3\", \"cr4\", \"cr5\", \"cr6\", \"cr7\",                 \\\n-  \"cr8\", \"cr9\", \"cr10\", \"cr11\", \"cr12\", \"cr13\", \"cr14\", \"cr15\",           \\\n-                                                                          \\\n-  \"ceh\", \"cel\", \"sr0\", \"sr1\", \"sr2\", \"_arg\", \"_frame\", \"\",                \\\n-  \"cr24\", \"cr25\", \"cr26\", \"cr27\", \"cr28\", \"cr29\", \"cr30\", \"cr31\",         \\\n-                                                                          \\\n-  \"c1r0\", \"c1r1\", \"c1r2\", \"c1r3\", \"c1r4\", \"c1r5\", \"c1r6\", \"c1r7\",         \\\n-  \"c1r8\", \"c1r9\", \"c1r10\", \"c1r11\", \"c1r12\", \"c1r13\", \"c1r14\", \"c1r15\",   \\\n-  \"c1r16\", \"c1r17\", \"c1r18\", \"c1r19\", \"c1r20\", \"c1r21\", \"c1r22\", \"c1r23\", \\\n-  \"c1r24\", \"c1r25\", \"c1r26\", \"c1r27\", \"c1r28\", \"c1r29\", \"c1r30\", \"c1r31\", \\\n-                                                                          \\\n-  \"c2r0\", \"c2r1\", \"c2r2\", \"c2r3\", \"c2r4\", \"c2r5\", \"c2r6\", \"c2r7\",         \\\n-  \"c2r8\", \"c2r9\", \"c2r10\", \"c2r11\", \"c2r12\", \"c2r13\", \"c2r14\", \"c2r15\",   \\\n-  \"c2r16\", \"c2r17\", \"c2r18\", \"c2r19\", \"c2r20\", \"c2r21\", \"c2r22\", \"c2r23\", \\\n-  \"c2r24\", \"c2r25\", \"c2r26\", \"c2r27\", \"c2r28\", \"c2r29\", \"c2r30\", \"c2r31\", \\\n-                                                                          \\\n-  \"c3r0\", \"c3r1\", \"c3r2\", \"c3r3\", \"c3r4\", \"c3r5\", \"c3r6\", \"c3r7\",         \\\n-  \"c3r8\", \"c3r9\", \"c3r10\", \"c3r11\", \"c3r12\", \"c3r13\", \"c3r14\", \"c3r15\",   \\\n-  \"c3r16\", \"c3r17\", \"c3r18\", \"c3r19\", \"c3r20\", \"c3r21\", \"c3r22\", \"c3r23\", \\\n-  \"c3r24\", \"c3r25\", \"c3r26\", \"c3r27\", \"c3r28\", \"c3r29\", \"c3r30\", \"c3r31\", \\\n-}\n-\n-/* Print operand X (an rtx) in assembler syntax to file FILE.  */\n-#define PRINT_OPERAND(STREAM, X, CODE)  score_print_operand (STREAM, X, CODE)\n-\n-/* A C expression which evaluates to true if CODE is a valid\n-   punctuation character for use in the `PRINT_OPERAND' macro.  */\n-#define PRINT_OPERAND_PUNCT_VALID_P(C)  ((C) == '[' || (C) == ']')\n-\n-/* Print a memory address as an operand to reference that memory location.  */\n-#define PRINT_OPERAND_ADDRESS(STREAM, X) \\\n-  score_print_operand_address (STREAM, X)\n-\n-/* By default on the S+core, external symbols do not have an underscore\n-   prepended.  */\n-#define USER_LABEL_PREFIX        \"\"\n-\n-/* This is how to output an insn to push a register on the stack.  */\n-#define ASM_OUTPUT_REG_PUSH(STREAM, REGNO)           \\\n-  do {                                               \\\n-    if (TARGET_SCORE7)                               \\\n-        fprintf (STREAM, \"\\tpush! %s,[%s]\\n\",        \\\n-                 reg_names[REGNO],                   \\\n-                 reg_names[STACK_POINTER_REGNUM]);   \\\n-  } while (0)\n-\n-/* This is how to output an insn to pop a register from the stack.  */\n-#define ASM_OUTPUT_REG_POP(STREAM, REGNO)            \\\n-  do {                                               \\\n-    if (TARGET_SCORE7)                               \\\n-      fprintf (STREAM, \"\\tpop! %s,[%s]\\n\",           \\\n-               reg_names[REGNO],                     \\\n-               reg_names[STACK_POINTER_REGNUM]);     \\\n-  } while (0)\n-\n-/* Output of Dispatch Tables.  */\n-/* This is how to output an element of a case-vector.  We can make the\n-   entries PC-relative in GP-relative when .gp(d)word is supported.  */\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\t\\\n-    if (TARGET_SCORE7)\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\t\\\n-\tif (flag_pic)\t\t\t\t\t\t\t\t\\\n-\t  fprintf (STREAM, \"\\t.gpword %sL%d\\n\", LOCAL_LABEL_PREFIX, VALUE);\t\\\n-\telse\t\t\t\t\t\t\t\t\t\\\n-\t  fprintf (STREAM, \"\\t.word %sL%d\\n\", LOCAL_LABEL_PREFIX, VALUE);\t\\\n-      }\t\t\t\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n-/* Jump table alignment is explicit in ASM_OUTPUT_CASE_LABEL.  */\n-#define ADDR_VEC_ALIGN(JUMPTABLE) (GET_MODE (PATTERN (JUMPTABLE)) == SImode ? 2 \\\n-                                   : GET_MODE (PATTERN (JUMPTABLE)) == HImode ? 1 : 0)\n-\n-/* This is how to output a label which precedes a jumptable.  Since\n-   Score3 instructions are 2 bytes, we may need explicit alignment here.  */\n-#undef  ASM_OUTPUT_CASE_LABEL\n-#define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, JUMPTABLE)             \\\n-  do {                                                                  \\\n-      if ((TARGET_SCORE7) && GET_MODE (PATTERN (JUMPTABLE)) == SImode)  \\\n-        ASM_OUTPUT_ALIGN (FILE, 2);                                     \\\n-      (*targetm.asm_out.internal_label) (FILE, PREFIX, NUM);            \\\n-  } while (0)\n-\n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE                SImode\n-\n-/* This is how to output an element of a case-vector that is absolute.  */\n-#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE) \\\n-  fprintf (STREAM, \"\\t.word %sL%d\\n\", LOCAL_LABEL_PREFIX, VALUE)\n-\n-/* Assembler Commands for Exception Regions  */\n-/* Since the S+core is encoded in the least-significant bit\n-   of the address, mask it off return addresses for purposes of\n-   finding exception handling regions.  */\n-#define MASK_RETURN_ADDR               constm1_rtx\n-\n-/* Assembler Commands for Alignment  */\n-/* This is how to output an assembler line to advance the location\n-   counter by SIZE bytes.  */\n-#undef ASM_OUTPUT_SKIP\n-#define ASM_OUTPUT_SKIP(STREAM, SIZE) \\\n-  fprintf (STREAM, \"\\t.space\\t\"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", (SIZE))\n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter\n-   to a multiple of 2**LOG bytes.  */\n-#define ASM_OUTPUT_ALIGN(STREAM, LOG) \\\n-  fprintf (STREAM, \"\\t.align\\t%d\\n\", (LOG))\n-\n-/* Macros Affecting All Debugging Formats.  */\n-#ifndef PREFERRED_DEBUGGING_TYPE\n-#define PREFERRED_DEBUGGING_TYPE         DWARF2_DEBUG\n-#endif\n-\n-/* Specific Options for DBX Output.  */\n-#define DBX_DEBUGGING_INFO              1\n-\n-/* By default, turn on GDB extensions.  */\n-#define DEFAULT_GDB_EXTENSIONS          1\n-\n-#define DBX_CONTIN_LENGTH               0\n-\n-/* File Names in DBX Format.  */\n-#define DWARF2_DEBUGGING_INFO           1\n-\n-/* The DWARF 2 CFA column which tracks the return address.  */\n-#define DWARF_FRAME_RETURN_COLUMN       3\n-\n-/* Define if operations between registers always perform the operation\n-   on the full register even if a narrower mode is specified.  */\n-#define WORD_REGISTER_OPERATIONS\n-\n-/*  All references are zero extended.  */\n-#define LOAD_EXTEND_OP(MODE)            ZERO_EXTEND\n-\n-/* Define if loading short immediate values into registers sign extends.  */\n-#define SHORT_IMMEDIATES_SIGN_EXTEND\n-\n-/* Max number of bytes we can move from memory to memory\n-   in one reasonably fast instruction.  */\n-#define MOVE_MAX                        4\n-\n-/* Define this to be nonzero if shift instructions ignore all but the low-order\n-   few bits.  */\n-#define SHIFT_COUNT_TRUNCATED           1\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-/* Specify the machine mode that pointers have.\n-   After generation of rtl, the compiler makes no further distinction\n-   between pointers and any other objects of this machine mode.  */\n-#define Pmode                           SImode\n-\n-/* Give call MEMs SImode since it is the \"most permissive\" mode\n-   for 32-bit targets.  */\n-#define FUNCTION_MODE                   Pmode\n-\n-struct GTY ((chain_next (\"%h.next\"))) extern_list\n-{\n-  struct extern_list *next;             /* next external  */\n-  const char *name;                     /* name of the external  */\n-  int size;                             /* size in bytes  */\n-};\n-\n-extern GTY (()) struct extern_list      *extern_head;"}, {"sha": "a4ffb3a2b8b656acecc674a42f12ce5e09e1708a", "filename": "gcc/config/score/score.md", "status": "removed", "additions": 0, "deletions": 1879, "changes": 1879, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Fscore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Fscore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.md?ref=bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8", "patch": "@@ -1,1879 +0,0 @@\n-;;  Machine description for Sunplus S+CORE\n-;;  Copyright (C) 2005-2014 Free Software Foundation, Inc.\n-;;  Contributed by Sunnorth.\n-\n-;; This file is part of GCC.\n-\n-;; GCC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 3, or (at your option)\n-;; any later version.\n-\n-;; GCC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.\n-\n-;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n-\n-; branch        conditional branch\n-; jump          unconditional jump\n-; call          unconditional call\n-; load          load instruction(s)\n-; store         store instruction(s)\n-; cmp           integer compare\n-; arith         integer arithmetic instruction\n-; move          data movement within same register set\n-; const         load constant\n-; nop           no operation\n-; mul           integer multiply\n-; div           integer divide\n-; cndmv         conditional moves\n-; fce           transfer from hi/lo registers\n-; tce           transfer to   hi/lo registers\n-; fsr           transfer from special registers\n-; tsr           transfer to   special registers\n-\n-(define_constants\n-  [(CC_REGNUM       33)\n-   (T_REGNUM        34)\n-   (RA_REGNUM       3)\n-   (SP_REGNUM       0)\n-   (AT_REGNUM       1)\n-   (FP_REGNUM       2)\n-   (RT_REGNUM       4)\n-   (GP_REGNUM       28)\n-   (EH_REGNUM       29)\n-   (HI_REGNUM       48)\n-   (LO_REGNUM       49)\n-   (CN_REGNUM       50)\n-   (LC_REGNUM       51)\n-   (SC_REGNUM       52)])\n-\n-(define_constants\n-   [(BITTST         0)\n-    (CPLOAD         1)\n-    (CPRESTORE      2)\n-\n-    (SCB            3)\n-    (SCW            4)\n-    (SCE            5)\n-    (SCLC           6)\n-\n-    (LCB            7)\n-    (LCW            8)\n-    (LCE            9)\n-\n-    (SFFS           10)])\n-\n-(define_attr \"type\"\n-  \"unknown,branch,jump,call,load,store,cmp,arith,move,const,nop,mul,div,cndmv,fce,tce,fsr,tsr,fcr,tcr\"\n-  (const_string \"unknown\"))\n-\n-(define_attr \"mode\" \"unknown,QI,HI,SI,DI\"\n-  (const_string \"unknown\"))\n-\n-(define_attr \"length\" \"\" (const_int 4))\n-\n-(define_attr \"up_c\" \"yes,no\"\n-  (const_string \"no\"))\n-\n-(include \"constraints.md\")\n-(include \"score-generic.md\")\n-(include \"predicates.md\")\n-\n-(define_expand \"movqi\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\")\n-        (match_operand:QI 1 \"general_operand\"))]\n-  \"\"\n-{\n-  if (MEM_P (operands[0])\n-      && !register_operand (operands[1], QImode))\n-    {\n-      operands[1] = force_reg (QImode, operands[1]);\n-    }\n-})\n-\n-(define_insn \"*movqi_insns_score7\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,d,d,m,d,*x,d,*a\")\n-        (match_operand:QI 1 \"general_operand\" \"i,d,m,d,*x,d,*a,d\"))]\n-  \"(!MEM_P (operands[0]) || register_operand (operands[1], QImode))\n-   && (TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return score_limm (operands);\n-    case 1: return score_move (operands);\n-    case 2: return score_linsn (operands, SCORE_BYTE, false);\n-    case 3: return score_sinsn (operands, SCORE_BYTE);\n-    case 4: return TARGET_SCORE7D ? \\\"mf%1%S0 %0\\\" : \\\"mf%1    %0\\\";\n-    case 5: return TARGET_SCORE7D ? \\\"mt%0%S1 %1\\\" : \\\"mt%0    %1\\\";\n-    case 6: return \\\"mfsr\\t%0, %1\\\";\n-    case 7: return \\\"mtsr\\t%1, %0\\\";\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith,move,load,store,fce,tce,fsr,tsr\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_expand \"movhi\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\")\n-        (match_operand:HI 1 \"general_operand\"))]\n-  \"\"\n-{\n-  if (MEM_P (operands[0])\n-      && !register_operand (operands[1], HImode))\n-    {\n-      operands[1] = force_reg (HImode, operands[1]);\n-    }\n-})\n-\n-(define_insn \"*movhi_insns_score7\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,m,d,*x,d,*a\")\n-        (match_operand:HI 1 \"general_operand\" \"i,d,m,d,*x,d,*a,d\"))]\n-  \"(!MEM_P (operands[0]) || register_operand (operands[1], HImode))\n-   && (TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return score_limm (operands);\n-    case 1: return score_move (operands);\n-    case 2: return score_linsn (operands, SCORE_HWORD, false);\n-    case 3: return score_sinsn (operands, SCORE_HWORD);\n-    case 4: return TARGET_SCORE7D ? \\\"mf%1%S0 %0\\\" : \\\"mf%1    %0\\\";\n-    case 5: return TARGET_SCORE7D ? \\\"mt%0%S1 %1\\\" : \\\"mt%0    %1\\\";\n-    case 6: return \\\"mfsr\\t%0, %1\\\";\n-    case 7: return \\\"mtsr\\t%1, %0\\\";\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith,move,load,store,fce,tce,fsr,tsr\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_expand \"movsi\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\")\n-        (match_operand:SI 1 \"general_operand\"))]\n-  \"\"\n-{\n-  if (MEM_P (operands[0])\n-      && !register_operand (operands[1], SImode))\n-    {\n-      operands[1] = force_reg (SImode, operands[1]);\n-    }\n-})\n-\n-(define_insn \"*movsi_insns_score7\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,m,d,*x,d,*a,d,*c\")\n-        (match_operand:SI 1 \"general_operand\" \"i,d,m,d,*x,d,*a,d,*c,d\"))]\n-  \"(!MEM_P (operands[0]) || register_operand (operands[1], SImode))\n-   && (TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (GET_CODE (operands[1]) != CONST_INT)\n-        return \\\"la\\t%0, %1\\\";\n-      else\n-        return score_limm (operands);\n-    case 1: return score_move (operands);\n-    case 2: return score_linsn (operands, SCORE_WORD, false);\n-    case 3: return score_sinsn (operands, SCORE_WORD);\n-    case 4: return TARGET_SCORE7D ? \\\"mf%1%S0 %0\\\" : \\\"mf%1    %0\\\";\n-    case 5: return TARGET_SCORE7D ? \\\"mt%0%S1 %1\\\" : \\\"mt%0    %1\\\";\n-    case 6: return \\\"mfsr\\t%0, %1\\\";\n-    case 7: return \\\"mtsr\\t%1, %0\\\";\n-    case 8: return \\\"mfcr\\t%0, %1\\\";\n-    case 9: return \\\"mtcr\\t%1, %0\\\";\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith,move,load,store,fce,tce,fsr,tsr,fcr,tcr\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn_and_split \"movdi\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,m,d,*x\")\n-        (match_operand:DI 1 \"general_operand\" \"i,d,m,d,*x,d\"))]\n-  \"\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(const_int 0)]\n-{\n-  score_movdi (operands);\n-  DONE;\n-})\n-\n-(define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\")\n-        (match_operand:SF 1 \"general_operand\"))]\n-  \"\"\n-{\n-  if (MEM_P (operands[0])\n-      && !register_operand (operands[1], SFmode))\n-    {\n-      operands[1] = force_reg (SFmode, operands[1]);\n-    }\n-})\n-\n-(define_insn \"*movsf_insns_score7\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=d,d,d,m\")\n-        (match_operand:SF 1 \"general_operand\" \"i,d,m,d\"))]\n-  \"(!MEM_P (operands[0]) || register_operand (operands[1], SFmode))\n-   && (TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return \\\"li\\t%0, %D1\\\";;\n-    case 1: return score_move (operands);\n-    case 2: return score_linsn (operands, SCORE_WORD, false);\n-    case 3: return score_sinsn (operands, SCORE_WORD);\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith,move,load,store\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn_and_split \"movdf\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=d,d,d,m\")\n-        (match_operand:DF 1 \"general_operand\" \"i,d,m,d\"))]\n-  \"\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(const_int 0)]\n-{\n-  score_movdi (operands);\n-  DONE;\n-})\n-\n-(define_expand \"addsi3\"\n-  [(set (match_operand:SI 0 \"score_register_operand\" )\n-        (plus:SI (match_operand:SI 1 \"score_register_operand\")\n-                 (match_operand:SI 2 \"arith_operand\")))]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"*addsi3_score7\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"0,0,d,d\")\n-                 (match_operand:SI 2 \"arith_operand\" \"I,L,N,d\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return \\\"addis\\t%0, %U2\\\";\n-    case 1: return score_select_add_imm (operands, false);\n-    case 2: return \\\"addri\\t%0, %1, %c2\\\";\n-    case 3: return score_select (operands, \"add\", true, \"\", false);\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*addsi3_cmp_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (plus:SI\n-                        (match_operand:SI 1 \"register_operand\" \"0,0,d,d\")\n-                        (match_operand:SI 2 \"arith_operand\" \"I,L,N,d\"))\n-                       (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=d,d,d,d\"))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return \\\"addis.c\\t%0, %U2\\\";\n-    case 1: return score_select_add_imm (operands, true);\n-    case 2: return \\\"addri.c\\t%0, %1, %c2\\\";\n-    case 3: return score_select (operands, \"add\", true, \"\", true);\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*addsi3_ucc_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (plus:SI\n-                        (match_operand:SI 1 \"register_operand\" \"0,0,d,d\")\n-                        (match_operand:SI 2 \"arith_operand\" \"I,L,N,d\"))\n-                       (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n-        (plus:SI (match_dup 1) (match_dup 2)))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return \\\"addis.c\\t%0, %U2\\\";\n-    case 1: return score_select_add_imm (operands, true);\n-    case 2: return \\\"addri.c\\t%0, %1, %c2\\\";\n-    case 3: return score_select (operands, \"add\", true, \"\", true);\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"adddi3\"\n-  [(parallel\n-    [(set (match_operand:DI 0 \"score_register_operand\")\n-          (plus:DI (match_operand:DI 1 \"score_register_operand\")\n-                   (match_operand:DI 2 \"score_register_operand\")))\n-    (clobber (reg:CC CC_REGNUM))])]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"*adddi3_score7\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=e,d\")\n-        (plus:DI (match_operand:DI 1 \"register_operand\" \"0,d\")\n-                 (match_operand:DI 2 \"register_operand\" \"e,d\")))\n-  (clobber (reg:CC CC_REGNUM))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"@\n-   add!    %L0, %L2\\;addc!   %H0, %H2\n-   add.c   %L0, %L1, %L2\\;addc    %H0, %H1, %H2\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_expand \"subsi3\"\n-  [(set (match_operand:SI 0 \"score_register_operand\")\n-        (minus:SI (match_operand:SI 1 \"score_register_operand\")\n-                  (match_operand:SI 2 \"score_register_operand\")))]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"*subsi3_score7\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (minus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                  (match_operand:SI 2 \"register_operand\" \"d\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  return score_select (operands, \"sub\", false, \"\", false);\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*subsi3_cmp_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (minus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                                 (match_operand:SI 2 \"register_operand\" \"d\"))\n-                       (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=d\"))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  return score_select (operands, \"sub\", false, \"\", true);\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"g32reg_operand\" \"\")\n-        (minus:SI (match_operand:SI 1 \"g32reg_operand\" \"\")\n-                  (match_operand:SI 2 \"g32reg_operand\" \"\")))\n-   (set (reg:CC CC_REGNUM)\n-        (compare:CC (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  [(set (reg:CC CC_REGNUM)\n-        (compare:CC (match_dup 1) (match_dup 2)))\n-   (set (match_dup 0)\n-        (minus:SI (match_dup 1) (match_dup 2)))])\n-\n-(define_insn \"subsi3_ucc_pcmp\"\n-  [(parallel\n-    [(set (reg:CC CC_REGNUM)\n-          (compare:CC (match_operand:SI 1 \"score_register_operand\" \"d\")\n-                      (match_operand:SI 2 \"score_register_operand\" \"d\")))\n-     (set (match_operand:SI 0 \"score_register_operand\" \"=d\")\n-          (minus:SI (match_dup 1) (match_dup 2)))])]\n-  \"\"\n-{\n-  return score_select (operands, \"sub\", false, \"\", true);\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"length\" \"4\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"subsi3_ucc\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (minus:SI (match_operand:SI 1 \"score_register_operand\" \"d\")\n-                                 (match_operand:SI 2 \"score_register_operand\" \"d\"))\n-                       (const_int 0)))\n-   (set (match_operand:SI 0 \"score_register_operand\" \"=d\")\n-        (minus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-{\n-  return score_select (operands, \"sub\", false, \"\", true);\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"length\" \"4\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"subdi3\"\n-  [(parallel\n-    [(set (match_operand:DI 0 \"score_register_operand\")\n-          (minus:DI (match_operand:DI 1 \"score_register_operand\")\n-                    (match_operand:DI 2 \"score_register_operand\")))\n-     (clobber (reg:CC CC_REGNUM))])]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"*subdi3_score7\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=e,d\")\n-        (minus:DI (match_operand:DI 1 \"register_operand\" \"0,d\")\n-                  (match_operand:DI 2 \"register_operand\" \"e,d\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"@\n-   sub!    %L0, %L2\\;subc    %H0, %H1, %H2\n-   sub.c   %L0, %L1, %L2\\;subc    %H0, %H1, %H2\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_expand \"andsi3\"\n-  [(set (match_operand:SI 0 \"score_register_operand\")\n-        (and:SI (match_operand:SI 1 \"score_register_operand\")\n-                (match_operand:SI 2 \"arith_operand\")))]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"*andsi3_score7\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n-        (and:SI (match_operand:SI 1 \"register_operand\" \"0,0,d,d\")\n-                (match_operand:SI 2 \"arith_operand\" \"I,K,M,d\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return \\\"andis\\t%0, %U2\\\";\n-    case 1: return \\\"andi\\t%0, %c2\";\n-    case 2: return \\\"andri\\t%0, %1, %c2\\\";\n-    case 3: return score_select (operands, \"and\", true, \"\", false);\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"andsi3_cmp_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (and:SI (match_operand:SI 1 \"register_operand\" \"0,0,0,d\")\n-                               (match_operand:SI 2 \"arith_operand\" \"I,K,M,d\"))\n-                       (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=d,d,d,d\"))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return \\\"andis.c\\t%0, %U2\\\";\n-    case 1: return \\\"andi.c\\t%0, %c2\";\n-    case 2: return \\\"andri.c\\t%0, %1, %c2\\\";\n-    case 3: return score_select (operands, \"and\", true, \"\", true);\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*andsi3_ucc_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (and:SI\n-                        (match_operand:SI 1 \"register_operand\" \"0,0,d,d\")\n-                        (match_operand:SI 2 \"arith_operand\" \"I,K,M,d\"))\n-                       (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n-        (and:SI (match_dup 1) (match_dup 2)))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return \\\"andis.c\\t%0, %U2\\\";\n-    case 1: return \\\"andi.c\\t%0, %c2\";\n-    case 2: return \\\"andri.c\\t%0, %1, %c2\\\";\n-    case 3: return score_select (operands, \"and\", true, \"\", true);\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn_and_split \"*zero_extract_andi\"\n-  [(set (reg:CC CC_REGNUM)\n-        (compare:CC (zero_extract:SI\n-                     (match_operand:SI 0 \"score_register_operand\" \"d\")\n-                     (match_operand:SI 1 \"const_uimm5\" \"\")\n-                     (match_operand:SI 2 \"const_uimm5\" \"\"))\n-                    (const_int 0)))]\n-  \"\"\n-  \"#\"\n-  \"\"\n-  [(const_int 1)]\n-{\n-  score_zero_extract_andi (operands);\n-  DONE;\n-})\n-\n-(define_expand \"iorsi3\"\n-  [(set (match_operand:SI 0 \"score_register_operand\")\n-        (ior:SI (match_operand:SI 1 \"score_register_operand\")\n-                (match_operand:SI 2 \"arith_operand\")))]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"*iorsi3_score7\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n-        (ior:SI (match_operand:SI 1 \"register_operand\" \"0,0,d,d\")\n-                (match_operand:SI 2 \"arith_operand\" \"I,K,M,d\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return \\\"oris\\t%0, %U2\\\";\n-    case 1: return \\\"ori\\t%0, %c2\\\";\n-    case 2: return \\\"orri\\t%0, %1, %c2\\\";\n-    case 3: return score_select (operands, \"or\", true, \"\", false);\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*iorsi3_ucc_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (ior:SI\n-                        (match_operand:SI 1 \"register_operand\" \"0,0,d,d\")\n-                        (match_operand:SI 2 \"arith_operand\" \"I,K,M,d\"))\n-                       (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n-        (ior:SI (match_dup 1) (match_dup 2)))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return \\\"oris.c\\t%0, %U2\\\";\n-    case 1: return \\\"ori.c\\t%0, %c2\\\";\n-    case 2: return \\\"orri.c\\t%0, %1, %c2\\\";\n-    case 3: return score_select (operands, \"or\", true, \"\", true);\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*iorsi3_cmp_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (ior:SI\n-                        (match_operand:SI 1 \"register_operand\" \"0,0,d,d\")\n-                        (match_operand:SI 2 \"arith_operand\" \"I,K,M,d\"))\n-                       (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=d,d,d,d\"))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return \\\"oris.c\\t%0, %U2\\\";\n-    case 1: return \\\"ori.c\\t%0, %c2\\\";\n-    case 2: return \\\"orri.c\\t%0, %1, %c2\\\";\n-    case 3: return score_select (operands, \"or\", true, \"\", true);\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"xorsi3\"\n-  [(set (match_operand:SI 0 \"score_register_operand\")\n-        (xor:SI (match_operand:SI 1 \"score_register_operand\")\n-                (match_operand:SI 2 \"score_register_operand\")))]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"*xorsi3_score7\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (xor:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                (match_operand:SI 2 \"register_operand\" \"d\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  return score_select (operands, \"xor\", true, \"\", false);\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*xorsi3_ucc_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (xor:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                               (match_operand:SI 2 \"register_operand\" \"d\"))\n-                       (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (xor:SI (match_dup 1) (match_dup 2)))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  return score_select (operands, \"xor\", true, \"\", true);\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*xorsi3_cmp_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (xor:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                               (match_operand:SI 2 \"register_operand\" \"d\"))\n-                       (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=d\"))]\n-  \"\"\n-{\n-  return score_select (operands, \"xor\", true, \"\", true);\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"score_register_operand\")\n-        (sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\")))]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"*extendqisi2_score7\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-        (sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"d,m\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return \\\"extsb\\t%0, %1\\\";\n-    case 1: return score_linsn (operands, SCORE_BYTE, true);\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith,load\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*extendqisi2_ucc_score7\"\n-  [(set (reg:CC_N CC_REGNUM)\n-        (compare:CC_N (ashiftrt:SI\n-                       (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                                  (const_int 24))\n-                       (const_int 24))\n-                      (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (sign_extend:SI (match_operand:QI 2 \"register_operand\" \"0\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"extsb.c %0, %1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*extendqisi2_cmp_score7\"\n-  [(set (reg:CC_N CC_REGNUM)\n-        (compare:CC_N (ashiftrt:SI\n-                       (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                                  (const_int 24))\n-                       (const_int 24))\n-                      (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=d\"))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"extsb.c %0, %1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"score_register_operand\")\n-        (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\")))]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"*extendhisi2_score7\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-        (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"d,m\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return \\\"extsh\\t%0, %1\\\";\n-    case 1: return score_linsn (operands, SCORE_HWORD, true);\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith, load\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*extendhisi2_ucc_score7\"\n-  [(set (reg:CC_N CC_REGNUM)\n-        (compare:CC_N (ashiftrt:SI\n-                       (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                                  (const_int 16))\n-                       (const_int 16))\n-                      (const_int 0)))\n-  (set (match_operand:SI 0 \"register_operand\" \"=d\")\n-       (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"0\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"extsh.c %0, %1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*extendhisi2_cmp_score7\"\n-  [(set (reg:CC_N CC_REGNUM)\n-        (compare:CC_N (ashiftrt:SI\n-                       (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                                  (const_int 16))\n-                       (const_int 16))\n-                      (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=d\"))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"extsh.c %0, %1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"score_register_operand\")\n-        (zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\")))]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"*zero_extendqisi2_score7\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-        (zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"d,m\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return \\\"extzb\\t%0, %1\\\";\n-    case 1: return score_linsn (operands, SCORE_BYTE, false);\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith, load\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*zero_extendqisi2_ucc_score7\"\n-  [(set (reg:CC_N CC_REGNUM)\n-        (compare:CC_N (lshiftrt:SI\n-                       (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                                  (const_int 24))\n-                       (const_int 24))\n-                      (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (zero_extend:SI (match_operand:QI 2 \"register_operand\" \"0\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"extzb.c %0, %1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*zero_extendqisi2_cmp_score7\"\n-  [(set (reg:CC_N CC_REGNUM)\n-        (compare:CC_N (lshiftrt:SI\n-                       (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                                  (const_int 24))\n-                       (const_int 24))\n-                      (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=d\"))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"extzb.c %0, %1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"score_register_operand\")\n-        (zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\")))]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"*zero_extendhisi2_score7\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-        (zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"d,m\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return \\\"extzh\\t%0, %1\\\";\n-    case 1: return score_linsn (operands, SCORE_HWORD, false);\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith, load\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*zero_extendhisi2_ucc_score7\"\n-  [(set (reg:CC_N CC_REGNUM)\n-        (compare:CC_N (lshiftrt:SI\n-                       (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                                  (const_int 16))\n-                       (const_int 16))\n-                      (const_int 0)))\n-  (set (match_operand:SI 0 \"register_operand\" \"=d\")\n-       (zero_extend:SI (match_operand:HI 2 \"register_operand\" \"0\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"extzh.c %0, %1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*zero_extendhisi2_cmp_score7\"\n-  [(set (reg:CC_N CC_REGNUM)\n-        (compare:CC_N (lshiftrt:SI\n-                       (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                                  (const_int 16))\n-                       (const_int 16))\n-                      (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=d\"))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"extzh.c %0, %1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"mulsi3\"\n-    [(set (match_operand:SI 0 \"score_register_operand\")\n-          (mult:SI (match_operand:SI 1 \"score_register_operand\")\n-                   (match_operand:SI 2 \"score_register_operand\")))]\n-  \"\"\n-{\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    emit_insn (gen_mulsi3_score7 (operands[0], operands[1], operands[2]));\n-  DONE;\n-})\n-\n-(define_insn \"mulsi3_score7\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-        (mult:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                 (match_operand:SI 2 \"register_operand\" \"d\")))\n-   (clobber (reg:SI HI_REGNUM))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"mul     %1, %2\"\n-  [(set_attr \"type\" \"mul\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"mulsidi3\"\n-    [(set (match_operand:DI 0 \"score_register_operand\")\n-          (mult:DI (sign_extend:DI\n-                    (match_operand:SI 1 \"score_register_operand\"))\n-                   (sign_extend:DI\n-                    (match_operand:SI 2 \"score_register_operand\"))))]\n-  \"\"\n-{\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    emit_insn (gen_mulsidi3_score7 (operands[0], operands[1], operands[2]));\n-  DONE;\n-})\n-\n-(define_insn \"mulsidi3_score7\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n-        (mult:DI (sign_extend:DI\n-                  (match_operand:SI 1 \"register_operand\" \"d\"))\n-                 (sign_extend:DI\n-                  (match_operand:SI 2 \"register_operand\" \"d\"))))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"mul     %1, %2\"\n-  [(set_attr \"type\" \"mul\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_expand \"umulsidi3\"\n-  [(set (match_operand:DI 0 \"score_register_operand\")\n-        (mult:DI (zero_extend:DI\n-                  (match_operand:SI 1 \"score_register_operand\"))\n-                 (zero_extend:DI\n-                  (match_operand:SI 2 \"score_register_operand\"))))]\n-  \"\"\n-{\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    emit_insn (gen_umulsidi3_score7 (operands[0], operands[1], operands[2]));\n-  DONE;\n-})\n-\n-(define_insn \"umulsidi3_score7\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n-        (mult:DI (zero_extend:DI\n-                  (match_operand:SI 1 \"register_operand\" \"d\"))\n-                 (zero_extend:DI\n-                  (match_operand:SI 2 \"register_operand\" \"d\"))))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"mulu    %1, %2\"\n-  [(set_attr \"type\" \"mul\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_expand \"divmodsi4\"\n-  [(parallel\n-    [(set (match_operand:SI 0 \"score_register_operand\")\n-          (div:SI (match_operand:SI 1 \"score_register_operand\")\n-                  (match_operand:SI 2 \"score_register_operand\")))\n-     (set (match_operand:SI 3 \"score_register_operand\")\n-          (mod:SI (match_dup 1) (match_dup 2)))])]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"*divmodsi4_score7\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-        (div:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                (match_operand:SI 2 \"register_operand\" \"d\")))\n-   (set (match_operand:SI 3 \"register_operand\" \"=h\")\n-        (mod:SI (match_dup 1) (match_dup 2)))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"div     %1, %2\"\n-  [(set_attr \"type\" \"div\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"udivmodsi4\"\n-  [(parallel\n-    [(set (match_operand:SI 0 \"score_register_operand\")\n-          (udiv:SI (match_operand:SI 1 \"score_register_operand\")\n-                   (match_operand:SI 2 \"score_register_operand\")))\n-     (set (match_operand:SI 3 \"score_register_operand\")\n-          (umod:SI (match_dup 1) (match_dup 2)))])]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"*udivmodsi4_score7\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-        (udiv:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                 (match_operand:SI 2 \"register_operand\" \"d\")))\n-   (set (match_operand:SI 3 \"register_operand\" \"=h\")\n-        (umod:SI (match_dup 1) (match_dup 2)))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"divu    %1, %2\"\n-  [(set_attr \"type\" \"div\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"score_register_operand\")\n-        (ashift:SI (match_operand:SI 1 \"score_register_operand\")\n-                   (match_operand:SI 2 \"arith_operand\")))]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"*ashlsi3_score7\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-        (ashift:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n-                   (match_operand:SI 2 \"arith_operand\" \"J,d\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"@\n-   slli    %0, %1, %c2\n-   sll     %0, %1, %2\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*ashlsi3_ucc_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (ashift:SI\n-                        (match_operand:SI 1 \"register_operand\" \"d,d\")\n-                        (match_operand:SI 2 \"arith_operand\" \"J,d\"))\n-                       (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-        (ashift:SI (match_dup 1) (match_dup 2)))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return score_select (operands, \"slli\", false, \"c\", true);\n-    case 1: return score_select (operands, \"sll\", false, \"\", true);\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*ashlsi3_cmp_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (ashift:SI\n-                        (match_operand:SI 1 \"register_operand\" \"d,d\")\n-                        (match_operand:SI 2 \"arith_operand\" \"J,d\"))\n-                       (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=d,d\"))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return score_select (operands, \"slli\", false, \"c\", true);\n-    case 1: return score_select (operands, \"sll\", false, \"\", true);\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"score_register_operand\")\n-        (ashiftrt:SI (match_operand:SI 1 \"score_register_operand\")\n-                     (match_operand:SI 2 \"arith_operand\")))]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"*ashrsi3_score7\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-        (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n-                     (match_operand:SI 2 \"arith_operand\" \"J,d\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"@\n-   srai    %0, %1, %c2\n-   sra     %0, %1, %2\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*ashrsi3_ucc_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (ashiftrt:SI\n-                        (match_operand:SI 1 \"register_operand\" \"d,d\")\n-                        (match_operand:SI 2 \"arith_operand\" \"J,d\"))\n-                       (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-        (ashiftrt:SI (match_dup 1) (match_dup 2)))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return \\\"srai.c\\t%0, %1, %c2\\\";\n-    case 1: return score_select (operands, \"sra\", false, \"\", true);\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*ashrsi3_cmp_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (ashiftrt:SI\n-                        (match_operand:SI 1 \"register_operand\" \"d,d\")\n-                        (match_operand:SI 2 \"arith_operand\" \"J,d\"))\n-                       (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=d,d\"))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return \\\"srai.c\\t%0, %1, %c2\\\";\n-    case 1: return score_select (operands, \"sra\", false, \"\", true);\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"score_register_operand\")\n-        (lshiftrt:SI (match_operand:SI 1 \"score_register_operand\")\n-                     (match_operand:SI 2 \"arith_operand\")))]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"*lshrsi3_score7\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-        (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n-                     (match_operand:SI 2 \"arith_operand\" \"J,d\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"@\n-   srli    %0, %1, %c2\n-   srl     %0, %1, %2\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*lshrsi3_ucc_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (lshiftrt:SI\n-                        (match_operand:SI 1 \"register_operand\" \"d,d\")\n-                        (match_operand:SI 2 \"arith_operand\" \"J,d\"))\n-                       (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-        (lshiftrt:SI (match_dup 1) (match_dup 2)))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return score_select (operands, \"srli\", false, \"c\", true);\n-    case 1: return score_select (operands, \"srl\", false, \"\", true);\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*lshrsi3_cmp_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (lshiftrt:SI\n-                        (match_operand:SI 1 \"register_operand\" \"d,d\")\n-                        (match_operand:SI 2 \"arith_operand\" \"J,d\"))\n-                       (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=d,d\"))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return score_select (operands, \"srli\", false, \"c\", true);\n-    case 1: return score_select (operands, \"srl\", false, \"\", true);\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"negsi2\"\n-  [(set (match_operand:SI 0 \"score_register_operand\")\n-        (neg:SI (match_operand:SI 1 \"score_register_operand\")))]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"*negsi2_score7\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (neg:SI (match_operand:SI 1 \"register_operand\" \"d\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"neg     %0, %1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*negsi2_cmp_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (neg:SI (match_operand:SI 1 \"register_operand\" \"e,d\"))\n-                       (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=e,d\"))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"@\n-   neg!    %0, %1\n-   neg.c   %0, %1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*negsi2_ucc_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (neg:SI (match_operand:SI 1 \"register_operand\" \"e,d\"))\n-                       (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=e,d\")\n-        (neg:SI (match_dup 1)))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"@\n-   neg!    %0, %1\n-   neg.c   %0, %1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"score_register_operand\")\n-        (not:SI (match_operand:SI 1 \"score_register_operand\")))]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"*one_cmplsi2_score7\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (not:SI (match_operand:SI 1 \"register_operand\" \"d\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"not\\t%0, %1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*one_cmplsi2_ucc_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (not:SI (match_operand:SI 1 \"register_operand\" \"e,d\"))\n-                       (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=e,d\")\n-        (not:SI (match_dup 1)))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"@\n-   not!    %0, %1\n-   not.c   %0, %1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*one_cmplsi2_cmp_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (not:SI (match_operand:SI 1 \"register_operand\" \"e,d\"))\n-                       (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=e,d\"))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"@\n-   not!    %0, %1\n-   not.c   %0, %1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"rotlsi3\"\n-  [(parallel\n-    [(set (match_operand:SI 0 \"score_register_operand\")\n-          (rotate:SI (match_operand:SI 1 \"score_register_operand\")\n-                     (match_operand:SI 2 \"arith_operand\")))\n-     (clobber (reg:CC CC_REGNUM))])]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"*rotlsi3_score7\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-        (rotate:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n-                   (match_operand:SI 2 \"arith_operand\" \"J,d\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"@\n-   roli.c  %0, %1, %c2\n-   rol.c   %0, %1, %2\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"rotrsi3\"\n-  [(parallel\n-    [(set (match_operand:SI 0 \"score_register_operand\")\n-          (rotatert:SI (match_operand:SI 1 \"score_register_operand\")\n-                       (match_operand:SI 2 \"arith_operand\")))\n-     (clobber (reg:CC CC_REGNUM))])]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"*rotrsi3_score7\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-        (rotatert:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n-                     (match_operand:SI 2 \"arith_operand\" \"J,d\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"@\n-   rori.c  %0, %1, %c2\n-   ror.c   %0, %1, %2\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"cbranchsi4\"\n-  [(set (reg:CC CC_REGNUM)\n-        (compare:CC (match_operand:SI 1 \"score_register_operand\" \"\")\n-                    (match_operand:SI 2 \"arith_operand\" \"\")))\n-   (set (pc)\n-        (if_then_else\n-\t (match_operator 0 \"ordered_comparison_operator\"\n-\t\t\t [(reg:CC CC_REGNUM)\n-\t\t \t  (const_int 0)]) \n-         (label_ref (match_operand 3 \"\" \"\"))\n-         (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"cmpsi_nz_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (match_operand:SI 0 \"register_operand\" \"d,e,d\")\n-                       (match_operand:SI 1 \"arith_operand\" \"L,e,d\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"@\n-   cmpi.c  %0, %c1\n-   cmp!    %0, %1\n-   cmp.c   %0, %1\"\n-   [(set_attr \"type\" \"cmp\")\n-    (set_attr \"up_c\" \"yes\")\n-    (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"cmpsi_n_score7\"\n-  [(set (reg:CC_N CC_REGNUM)\n-        (compare:CC_N (match_operand:SI 0 \"register_operand\" \"d,e,d\")\n-                      (match_operand:SI 1 \"arith_operand\" \"L,e,d\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"@\n-   cmpi.c  %0, %c1\n-   cmp!    %0, %1\n-   cmp.c   %0, %1\"\n-   [(set_attr \"type\" \"cmp\")\n-    (set_attr \"up_c\" \"yes\")\n-    (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*cmpsi_to_addsi_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (match_operand:SI 1 \"register_operand\" \"0,d\")\n-                       (neg:SI (match_operand:SI 2 \"register_operand\" \"e,d\"))))\n-   (clobber (match_scratch:SI 0 \"=e,d\"))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"@\n-   add!    %0, %2\n-   add.c   %0, %1, %2\"\n-   [(set_attr \"type\" \"cmp\")\n-    (set_attr \"up_c\" \"yes\")\n-    (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"cmpsi_cc_score7\"\n-  [(set (reg:CC CC_REGNUM)\n-        (compare:CC (match_operand:SI 0 \"register_operand\" \"d,e,d\")\n-                    (match_operand:SI 1 \"arith_operand\" \"L,e,d\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"@\n-   cmpi.c  %0, %c1\n-   cmp!    %0, %1\n-   cmp.c   %0, %1\"\n-  [(set_attr \"type\" \"cmp\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*branch_n_score7\"\n-  [(set (pc)\n-        (if_then_else\n-         (match_operator 0 \"branch_n_operator\"\n-                         [(reg:CC_N CC_REGNUM)\n-                          (const_int 0)])\n-         (label_ref (match_operand 1 \"\" \"\"))\n-         (pc)))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"b%C0    %1\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"*branch_nz_score7\"\n-  [(set (pc)\n-        (if_then_else\n-         (match_operator 0 \"branch_nz_operator\"\n-                         [(reg:CC_NZ CC_REGNUM)\n-                          (const_int 0)])\n-         (label_ref (match_operand 1 \"\" \"\"))\n-         (pc)))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"b%C0    %1\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"*branch_cc_score7\"\n-  [(set (pc)\n-        (if_then_else\n-         (match_operator 0 \"comparison_operator\"\n-                         [(reg:CC CC_REGNUM)\n-                          (const_int 0)])\n-         (label_ref (match_operand 1 \"\" \"\"))\n-         (pc)))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"b%C0    %1\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"jump\"\n-  [(set (pc)\n-        (label_ref (match_operand 0 \"\" \"\")))]\n-  \"\"\n-{\n-  if (!flag_pic)\n-    return \\\"j\\t%0\\\";\n-  else\n-    return \\\"b\\t%0\\\";\n-}\n-  [(set_attr \"type\" \"jump\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_expand \"sibcall\"\n-  [(parallel [(call (match_operand 0 \"\" \"\")\n-                    (match_operand 1 \"\" \"\"))\n-              (use (match_operand 2 \"\" \"\"))])]\n-  \"\"\n-{\n-  score_call (operands, true);\n-  DONE;\n-})\n-\n-(define_insn \"sibcall_internal_score7\"\n-  [(call (mem:SI (match_operand:SI 0 \"call_insn_operand\" \"t,Z\"))\n-         (match_operand 1 \"\" \"\"))\n-   (clobber (reg:SI RT_REGNUM))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\n-   && SIBLING_CALL_P (insn)\"\n-{\n-  if (!flag_pic)\n-    switch (which_alternative)\n-      {\n-      case 0: return \\\"br%S0\\t%0\\\";\n-      case 1: return \\\"j\\t%0\\\";\n-      default: gcc_unreachable ();\n-      }\n-  else\n-    switch (which_alternative)\n-      {\n-      case 0: return \\\"mv\\tr29, %0\\;br\\tr29\\\";\n-      case 1: return \\\"la\\tr29, %0\\;br\\tr29\\\";\n-      default: gcc_unreachable ();\n-      }\n-}\n-  [(set_attr \"type\" \"call\")])\n-\n-(define_expand \"sibcall_value\"\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n-              (call (match_operand 1 \"\" \"\") (match_operand 2 \"\" \"\")))\n-              (use (match_operand 3 \"\" \"\"))])]\n-  \"\"\n-{\n-  score_call_value (operands, true);\n-  DONE;\n-})\n-\n-(define_insn \"sibcall_value_internal_score7\"\n-  [(set (match_operand 0 \"register_operand\" \"=d,d\")\n-        (call (mem:SI (match_operand:SI 1 \"call_insn_operand\" \"t,Z\"))\n-              (match_operand 2 \"\" \"\")))\n-   (clobber (reg:SI RT_REGNUM))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\n-   && SIBLING_CALL_P (insn)\"\n-{\n-  if (!flag_pic)\n-    switch (which_alternative)\n-      {\n-      case 0: return \\\"br%S1\\t%1\\\";\n-      case 1: return \\\"j\\t%1\\\";\n-      default: gcc_unreachable ();\n-      }\n-  else\n-    switch (which_alternative)\n-      {\n-      case 0: return \\\"mv\\tr29, %1\\;br\\tr29\\\";\n-      case 1: return \\\"la\\tr29, %1\\;br\\tr29\\\";\n-      default: gcc_unreachable ();\n-      }\n-}\n-  [(set_attr \"type\" \"call\")])\n-\n-(define_expand \"call\"\n-  [(parallel [(call (match_operand 0 \"\" \"\") (match_operand 1 \"\" \"\"))\n-              (use (match_operand 2 \"\" \"\"))])]\n-  \"\"\n-{\n-  score_call (operands, false);\n-  DONE;\n-})\n-\n-(define_insn \"call_internal_score7\"\n-  [(call (mem:SI (match_operand:SI 0 \"call_insn_operand\" \"d,Z\"))\n-         (match_operand 1 \"\" \"\"))\n-   (clobber (reg:SI RA_REGNUM))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  if (!flag_pic)\n-    switch (which_alternative)\n-      {\n-      case 0: return \\\"brl%S0\\t%0\\\";\n-      case 1: return \\\"jl\\t%0\\\";\n-      default: gcc_unreachable ();\n-      }\n-  else\n-     switch (which_alternative)\n-      {\n-      case 0: return \\\"mv\\tr29, %0\\;brl\\tr29\\\";\n-      case 1: return \\\"la\\tr29, %0\\;brl\\tr29\\\";\n-      default: gcc_unreachable ();\n-      }\n-}\n-  [(set_attr \"type\" \"call\")])\n-\n-(define_expand \"call_value\"\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n-                   (call (match_operand 1 \"\" \"\") (match_operand 2 \"\" \"\")))\n-              (use (match_operand 3 \"\" \"\"))])]\n-  \"\"\n-{\n-  score_call_value (operands, false);\n-  DONE;\n-})\n-\n-(define_insn \"call_value_internal_score7\"\n-  [(set (match_operand 0 \"register_operand\" \"=d,d\")\n-        (call (mem:SI (match_operand:SI 1 \"call_insn_operand\" \"d,Z\"))\n-              (match_operand 2 \"\" \"\")))\n-   (clobber (reg:SI RA_REGNUM))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  if (!flag_pic)\n-    switch (which_alternative)\n-      {\n-      case 0: return \\\"brl%S1\\t%1\\\";\n-      case 1: return \\\"jl\\t%1\\\";\n-      default: gcc_unreachable ();\n-      }\n-  else\n-    switch (which_alternative)\n-      {\n-      case 0: return \\\"mv\\tr29, %1\\;brl\\tr29\\\";\n-      case 1: return \\\"la\\tr29, %1\\;brl\\tr29\\\";\n-      default: gcc_unreachable ();\n-      }\n-}\n-  [(set_attr \"type\" \"call\")])\n-\n-(define_expand \"indirect_jump\"\n-  [(set (pc) (match_operand 0 \"score_register_operand\" \"d\"))]\n-  \"\"\n-{\n-  rtx dest;\n-  dest = operands[0];\n-  if (GET_CODE (dest) != REG\n-      || GET_MODE (dest) != Pmode)\n-    operands[0] = copy_to_mode_reg (Pmode, dest);\n-\n-  emit_jump_insn (gen_indirect_jump_internal_score (operands[0]));\n-  DONE;\n-})\n-\n-(define_insn \"indirect_jump_internal_score\"\n-  [(set (pc) (match_operand:SI 0 \"score_register_operand\" \"d\"))]\n-  \"\"\n-  \"br%S0   %0\"\n-  [(set_attr \"type\" \"jump\")])\n-\n-(define_expand \"tablejump\"\n-  [(set (pc)\n-        (match_operand 0 \"score_register_operand\" \"d\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"\"\n-{\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    emit_jump_insn (gen_tablejump_internal_score7 (operands[0], operands[1]));\n-\n-  DONE;\n-})\n-\n-(define_insn \"tablejump_internal_score7\"\n-  [(set (pc)\n-        (match_operand:SI 0 \"register_operand\" \"d\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-{\n-  if (flag_pic)\n-    return \\\"mv\\tr29, %0\\;.cpadd\\tr29\\;br\\tr29\\\";\n-  else\n-    return \\\"br%S0\\t%0\\\";\n-}\n-  [(set_attr \"type\" \"jump\")])\n-\n-(define_expand \"prologue\"\n-  [(const_int 1)]\n-  \"\"\n-{\n-  score_prologue ();\n-  DONE;\n-})\n-\n-(define_expand \"epilogue\"\n-  [(const_int 2)]\n-  \"\"\n-{\n-  score_epilogue (false);\n-  DONE;\n-})\n-\n-(define_expand \"sibcall_epilogue\"\n-  [(const_int 2)]\n-  \"\"\n-{\n-  score_epilogue (true);\n-  DONE;\n-})\n-\n-(define_insn \"return_internal_score7\"\n-  [(return)\n-   (use (match_operand 0 \"pmode_register_operand\" \"d\"))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"br%S0\\t%0\")\n-\n-(define_insn \"nop\"\n-  [(const_int 0)]\n-  \"\"\n-  \"#nop!\"\n-)\n-\n-(define_insn \"cpload_score7\"\n-  [(unspec_volatile:SI [(const_int 1)] CPLOAD)]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\n-   && flag_pic\"\n-  \".cpload\\tr29\"\n-)\n-\n-(define_insn \"cprestore_use_fp_score7\"\n-  [(unspec_volatile:SI [(match_operand:SI 0 \"\" \"\")] CPRESTORE)\n-   (use (reg:SI FP_REGNUM))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\n-   && flag_pic\"\n-  \".cprestore\\tr2, %0\"\n-)\n-\n-(define_insn \"cprestore_use_sp_score7\"\n-  [(unspec_volatile:SI [(match_operand:SI 0 \"\" \"\")] CPRESTORE)\n-   (use (reg:SI SP_REGNUM))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\n-   && flag_pic\"\n-  \".cprestore\\tr0, %0\"\n-)\n-\n-(define_insn \"pushsi_score7\"\n-  [(set (match_operand:SI 0 \"push_operand\" \"=<\")\n-        (match_operand:SI 1 \"register_operand\" \"d\"))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"push!\\t%1, [r0]\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"popsi_score7\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (match_operand:SI 1 \"pop_operand\" \">\"))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"pop!\\t%0, [r0]\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"g32reg_operand\" \"\")\n-        (match_operand:SI 1 \"loreg_operand\" \"\"))\n-   (set (match_operand:SI 2 \"g32reg_operand\" \"\")\n-        (match_operand:SI 3 \"hireg_operand\" \"\"))]\n-  \"\"\n-  [(parallel\n-       [(set (match_dup 0) (match_dup 1))\n-        (set (match_dup 2) (match_dup 3))])])\n-\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"g32reg_operand\" \"\")\n-        (match_operand:SI 1 \"hireg_operand\" \"\"))\n-   (set (match_operand:SI 2 \"g32reg_operand\" \"\")\n-        (match_operand:SI 3 \"loreg_operand\" \"\"))]\n-  \"\"\n-  [(parallel\n-       [(set (match_dup 2) (match_dup 3))\n-        (set (match_dup 0) (match_dup 1))])])\n-\n-(define_insn \"movhilo\"\n-  [(parallel\n-    [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-          (match_operand:SI 1 \"loreg_operand\" \"\"))\n-     (set (match_operand:SI 2 \"register_operand\" \"=d\")\n-          (match_operand:SI 3 \"hireg_operand\" \"\"))])]\n-  \"\"\n-  \"mfcehl\\t%2, %0\"\n-  [(set_attr \"type\" \"fce\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"movsicc\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (if_then_else:SI (match_operator 1 \"comparison_operator\"\n-                          [(reg:CC CC_REGNUM) (const_int 0)])\n-                         (match_operand:SI 2 \"register_operand\" \"\")\n-                         (match_operand:SI 3 \"register_operand\" \"\")))]\n-  \"\"\n-{\n-  score_movsicc (operands);\n-})\n-\n-(define_insn \"movsicc_internal_score7\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (if_then_else:SI (match_operator 1 \"comparison_operator\"\n-                          [(reg:CC CC_REGNUM) (const_int 0)])\n-                         (match_operand:SI 2 \"arith_operand\" \"d\")\n-                         (match_operand:SI 3 \"arith_operand\" \"0\")))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"mv%C1\\t%0, %2\"\n-  [(set_attr \"type\" \"cndmv\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"zero_extract_bittst_score7\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (unspec:SI\n-                        [(match_operand:SI 0 \"register_operand\" \"*e,d\")\n-                         (match_operand:SI 1 \"const_uimm5\" \"\")]\n-                        BITTST)\n-                       (const_int 0)))]\n-  \"(TARGET_SCORE7 || TARGET_SCORE7D)\"\n-  \"@\n-   bittst!\\t%0, %c1\n-   bittst.c\\t%0, %c1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"andsi3_extzh\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (and:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                (const_int 65535)))]\n-  \"\"\n-  \"extzh\\t%0, %1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"length\" \"4\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"clzsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (clz:SI (match_operand:SI 1 \"register_operand\" \"d\")))]\n-  \"(TARGET_SCORE7D)\"\n-  \"clz\\t%0, %1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"smaxsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (smax:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                 (match_operand:SI 2 \"register_operand\" \"d\")))]\n-  \"(TARGET_SCORE7D)\"\n-  \"max\\t%0, %1, %2\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"sminsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (smin:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                 (match_operand:SI 2 \"register_operand\" \"d\")))]\n-  \"(TARGET_SCORE7D)\"\n-  \"min\\t%0, %1, %2\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"abssi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (abs:SI (match_operand:SI 1 \"register_operand\" \"d\")))]\n-  \"(TARGET_SCORE7D)\"\n-  \"abs\\t%0, %1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"sffs\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (unspec:SI [(match_operand:SI 1 \"register_operand\" \"d\")] SFFS))]\n-  \"(TARGET_SCORE7D)\"\n-  \"bitrev\\t%0, %1, r0\\;clz\\t%0, %0\\;addi\\t%0, 0x1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"ffssi2\"\n-  [(set (match_operand:SI 0 \"register_operand\")\n-        (ffs:SI (match_operand:SI 1 \"register_operand\")))]\n-  \"(TARGET_SCORE7D)\"\n-{\n-  emit_insn (gen_sffs (operands[0], operands[1]));\n-  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (CC_NZmode, CC_REGNUM),\n-                          gen_rtx_COMPARE (CC_NZmode, operands[0],\n-                                           GEN_INT (33))));\n-  if (TARGET_SCORE7D)\n-    emit_insn (gen_movsicc_internal_score7 (operands[0],\n-               gen_rtx_fmt_ee (EQ, VOIDmode, operands[0], GEN_INT (33)),\n-               GEN_INT (0),\n-               operands[0]));\n-  DONE;\n-})\n-\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"loreg_operand\" \"\")\n-        (match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (match_operand:SI 2 \"hireg_operand\" \"\")\n-        (match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"(TARGET_SCORE7D)\"\n-  [(parallel\n-       [(set (match_dup 0) (match_dup 1))\n-        (set (match_dup 2) (match_dup 3))])])\n-\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"hireg_operand\" \"\")\n-        (match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (match_operand:SI 2 \"loreg_operand\" \"\")\n-        (match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"(TARGET_SCORE7D)\"\n-  [(parallel\n-       [(set (match_dup 2) (match_dup 3))\n-        (set (match_dup 0) (match_dup 1))])])\n-\n-(define_insn \"movtohilo\"\n-  [(parallel\n-       [(set (match_operand:SI 0 \"loreg_operand\" \"=l\")\n-             (match_operand:SI 1 \"register_operand\" \"d\"))\n-        (set (match_operand:SI 2 \"hireg_operand\" \"=h\")\n-             (match_operand:SI 3 \"register_operand\" \"d\"))])]\n-  \"(TARGET_SCORE7D)\"\n-  \"mtcehl\\t%3, %1\"\n-  [(set_attr \"type\" \"fce\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"mulsi3addsi\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l,l,d\")\n-        (plus:SI (mult:SI (match_operand:SI 2 \"register_operand\" \"d,d,d\")\n-                          (match_operand:SI 3 \"register_operand\" \"d,d,d\"))\n-                 (match_operand:SI 1 \"register_operand\" \"0,d,l\")))\n-   (clobber (reg:SI HI_REGNUM))]\n-  \"(TARGET_SCORE7D)\"\n-  \"@\n-   mad\\t%2, %3\n-   mtcel%S1\\t%1\\;mad\\t%2, %3\n-   mad\\t%2, %3\\;mfcel%S0\\t%0\"\n-  [(set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"mulsi3subsi\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l,l,d\")\n-        (minus:SI (match_operand:SI 1 \"register_operand\" \"0,d,l\")\n-                  (mult:SI (match_operand:SI 2 \"register_operand\" \"d,d,d\")\n-                           (match_operand:SI 3 \"register_operand\" \"d,d,d\"))))\n-   (clobber (reg:SI HI_REGNUM))]\n-  \"(TARGET_SCORE7D)\"\n-  \"@\n-   msb\\t%2, %3\n-   mtcel%S1\\t%1\\;msb\\t%2, %3\n-   msb\\t%2, %3\\;mfcel%S0\\t%0\"\n-  [(set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"mulsidi3adddi\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n-        (plus:DI (mult:DI\n-                  (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"%d\"))\n-                  (sign_extend:DI (match_operand:SI 3 \"register_operand\" \"d\")))\n-                 (match_operand:DI 1 \"register_operand\" \"0\")))]\n-  \"(TARGET_SCORE7D)\"\n-  \"mad\\t%2, %3\"\n-  [(set_attr \"mode\" \"DI\")])\n-\n-(define_insn \"umulsidi3adddi\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n-        (plus:DI (mult:DI\n-                  (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"%d\"))\n-                  (zero_extend:DI (match_operand:SI 3 \"register_operand\" \"d\")))\n-                 (match_operand:DI 1 \"register_operand\" \"0\")))]\n-  \"(TARGET_SCORE7D)\"\n-  \"madu\\t%2, %3\"\n-  [(set_attr \"mode\" \"DI\")])\n-\n-(define_insn \"mulsidi3subdi\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n-        (minus:DI\n-         (match_operand:DI 1 \"register_operand\" \"0\")\n-         (mult:DI\n-          (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"%d\"))\n-          (sign_extend:DI (match_operand:SI 3 \"register_operand\" \"d\")))))]\n-  \"(TARGET_SCORE7D)\"\n-  \"msb\\t%2, %3\"\n-  [(set_attr \"mode\" \"DI\")])\n-\n-(define_insn \"umulsidi3subdi\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n-        (minus:DI\n-         (match_operand:DI 1 \"register_operand\" \"0\")\n-         (mult:DI (zero_extend:DI\n-                   (match_operand:SI 2 \"register_operand\" \"%d\"))\n-                  (zero_extend:DI\n-                   (match_operand:SI 3 \"register_operand\" \"d\")))))]\n-  \"(TARGET_SCORE7D)\"\n-  \"msbu\\t%2, %3\"\n-  [(set_attr \"mode\" \"DI\")])\n-"}, {"sha": "7761fe0939a32f9cad7bb592775666775fd19c7b", "filename": "gcc/config/score/score.opt", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Fscore.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8/gcc%2Fconfig%2Fscore%2Fscore.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.opt?ref=bf55b4a0ef1bc41c43e9916ed6ac261b142b5cf8", "patch": "@@ -1,57 +0,0 @@\n-; Options for the Sunnorth port of the compiler.\n-\n-; Copyright (C) 2005-2014 Free Software Foundation, Inc.\n-;\n-; This file is part of GCC.\n-;\n-; GCC is free software; you can redistribute it and/or modify it under\n-; the terms of the GNU General Public License as published by the Free\n-; Software Foundation; either version 3, or (at your option) any later\n-; version.\n-;\n-; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-; for more details.\n-;\n-; You should have received a copy of the GNU General Public License\n-; along with GCC; see the file COPYING3.  If not see\n-; <http://www.gnu.org/licenses/>.\n-\n-meb\n-Target RejectNegative Report InverseMask(LITTLE_ENDIAN)\n-Generate big-endian code\n-\n-mel\n-Target RejectNegative Report Mask(LITTLE_ENDIAN)\n-Generate little-endian code\n-\n-mnhwloop\n-Target RejectNegative Report Mask(NHWLOOP)\n-Disable bcnz instruction\n-\n-muls\n-Target RejectNegative Report Mask(ULS)\n-Enable unaligned load/store instruction\n-\n-mscore7\n-Target RejectNegative Report Mask(SCORE7)\n-Support SCORE 7 ISA\n-\n-mscore7d\n-Target RejectNegative Report Mask(SCORE7D)\n-Support SCORE 7D ISA\n-\n-march=\n-Target RejectNegative Joined Enum(score_arch)\n-Specify the name of the target architecture\n-\n-Enum\n-Name(score_arch) Type(int)\n-Known SCORE architectures (for use with the -march= option):\n-\n-EnumValue\n-Enum(score_arch) String(score7) Value(MASK_SCORE7)\n-\n-EnumValue\n-Enum(score_arch) String(score7d) Value(MASK_SCORE7 | MASK_SCORE7D)"}, {"sha": "ccebc70be4bb62c5b238cf4de4b50f23c9bf31f4", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daa7bbf7912030a760199f31a0926a11365a76f/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daa7bbf7912030a760199f31a0926a11365a76f/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=3daa7bbf7912030a760199f31a0926a11365a76f", "patch": "@@ -3673,75 +3673,6 @@ Shift count operand.\n \n @end table\n \n-@item Score family---@file{config/score/score.h}\n-@table @code\n-@item d\n-Registers from r0 to r32.\n-\n-@item e\n-Registers from r0 to r16.\n-\n-@item t\n-r8---r11 or r22---r27 registers.\n-\n-@item h\n-hi register.\n-\n-@item l\n-lo register.\n-\n-@item x\n-hi + lo register.\n-\n-@item q\n-cnt register.\n-\n-@item y\n-lcb register.\n-\n-@item z\n-scb register.\n-\n-@item a\n-cnt + lcb + scb register.\n-\n-@item c\n-cr0---cr15 register.\n-\n-@item b\n-cp1 registers.\n-\n-@item f\n-cp2 registers.\n-\n-@item i\n-cp3 registers.\n-\n-@item j\n-cp1 + cp2 + cp3 registers.\n-\n-@item I\n-High 16-bit constant (32-bit constant with 16 LSBs zero).\n-\n-@item J\n-Unsigned 5 bit integer (in the range 0 to 31).\n-\n-@item K\n-Unsigned 16 bit integer (in the range 0 to 65535).\n-\n-@item L\n-Signed 16 bit integer (in the range @minus{}32768 to 32767).\n-\n-@item M\n-Unsigned 14 bit integer (in the range 0 to 16383).\n-\n-@item N\n-Signed 14 bit integer (in the range @minus{}8192 to 8191).\n-\n-@item Z\n-Any SYMBOL_REF.\n-@end table\n-\n @item Xstormy16---@file{config/stormy16/stormy16.h}\n @table @code\n @item a"}, {"sha": "80a571aeb45e8c7cc6ebc1ad3dd752aa48f64c35", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-rom.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daa7bbf7912030a760199f31a0926a11365a76f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-rom.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daa7bbf7912030a760199f31a0926a11365a76f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-rom.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-rom.C?ref=3daa7bbf7912030a760199f31a0926a11365a76f", "patch": "@@ -1,6 +1,6 @@\n // PR c++/49673: check that test_data goes into .rodata\n // { dg-do compile { target c++11 } }\n-// { dg-additional-options -G0 { target { { alpha*-*-* frv*-*-* ia64-*-* lm32*-*-* m32r*-*-* microblaze*-*-* mips*-*-* nios2-*-* powerpc*-*-* rs6000*-*-* score*-*-* } && { ! { *-*-darwin* *-*-aix* alpha*-*-*vms* } } } } }\n+// { dg-additional-options -G0 { target { { alpha*-*-* frv*-*-* ia64-*-* lm32*-*-* m32r*-*-* microblaze*-*-* mips*-*-* nios2-*-* powerpc*-*-* rs6000*-*-* } && { ! { *-*-darwin* *-*-aix* alpha*-*-*vms* } } } } }\n // { dg-final { scan-assembler \"\\\\.rdata\" { target mips*-*-* } } }\n // { dg-final { scan-assembler \"rodata\" { target { { *-*-linux-gnu *-*-gnu* *-*-elf } && { ! mips*-*-* } } } } }\n "}, {"sha": "7adbc042c267ff4fef8f7901d711ef77c97d8493", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daa7bbf7912030a760199f31a0926a11365a76f/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daa7bbf7912030a760199f31a0926a11365a76f/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=3daa7bbf7912030a760199f31a0926a11365a76f", "patch": "@@ -1,3 +1,7 @@\n+2014-10-04  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* config.host: Remove support for score-*.\n+\n 2014-09-22  Joseph Myers  <joseph@codesourcery.com>\n \n \t* dfp-bit.h (LIBGCC2_LONG_DOUBLE_TYPE_SIZE): Remove."}, {"sha": "cd3139f8f3715469e7152e32f5ddf545f19716d7", "filename": "libgcc/config.host", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daa7bbf7912030a760199f31a0926a11365a76f/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daa7bbf7912030a760199f31a0926a11365a76f/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=3daa7bbf7912030a760199f31a0926a11365a76f", "patch": "@@ -167,9 +167,6 @@ powerpc*-*-*)\n \t;;\n rs6000*-*-*)\n \t;;\n-score*-*-*)\n-\tcpu_type=score\n-\t;;\n sparc64*-*-*)\n \tcpu_type=sparc\n \t;;\n@@ -1051,10 +1048,6 @@ s390x-ibm-tpf*)\n \textra_parts=\"crtbeginS.o crtendS.o\"\n \tmd_unwind_header=s390/tpf-unwind.h\n \t;;\n-score-*-elf)\n-\ttmake_file=\"${tmake_file} t-softfp-sfdf t-softfp-excl t-softfp\"\n-\textra_parts=\"$extra_parts crti.o crtn.o\"\n-        ;;\n sh-*-elf* | sh[12346l]*-*-elf*)\n \ttmake_file=\"$tmake_file sh/t-sh t-crtstuff-pic t-fdpbit\"\n \textra_parts=\"$extra_parts crt1.o crti.o crtn.o crtbeginS.o crtendS.o \\"}]}