{"sha": "6a2a38620cf178b53b217051f32d1d7bbba86fc9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmEyYTM4NjIwY2YxNzhiNTNiMjE3MDUxZjMyZDFkN2JiYmE4NmZjOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-01-19T17:50:53Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-01-19T17:50:53Z"}, "message": "alias: Fix offset checks involving section anchors [PR92294]\n\nmemrefs_conflict_p assumes that:\n\n  [XB + XO, XB + XO + XS)\n\ndoes not alias\n\n  [YB + YO, YB + YO + YS)\n\nwhenever:\n\n  [XO, XO + XS)\n\ndoes not intersect\n\n  [YO, YO + YS)\n\nIn other words, the accesses can alias only if XB == YB at runtime.\n\nHowever, this doesn't cope correctly with section anchors.\nFor example, if XB is an anchor symbol and YB is at offset\nXO from the anchor, then:\n\n  [XB + XO, XB + XO + XS)\n\noverlaps\n\n  [YB, YB + YS)\n\nwhatever the value of XO is.  In other words, when doing the\nalias check for two symbols whose local definitions are in\nthe same block, we should apply the known difference between\ntheir block offsets to the intersection test above.\n\ngcc/\n\tPR rtl-optimization/92294\n\t* alias.c (compare_base_symbol_refs): Take an extra parameter\n\tand add the distance between two symbols to it.  Enshrine in\n\tcomments that -1 means \"either 0 or 1, but we can't tell\n\twhich at compile time\".\n\t(memrefs_conflict_p): Update call accordingly.\n\t(rtx_equal_for_memref_p): Likewise.  Take the distance between symbols\n\tinto account.", "tree": {"sha": "2bd3bc8988bd0ce2bc3a55deddc8ddae7412a7cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bd3bc8988bd0ce2bc3a55deddc8ddae7412a7cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a2a38620cf178b53b217051f32d1d7bbba86fc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a2a38620cf178b53b217051f32d1d7bbba86fc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a2a38620cf178b53b217051f32d1d7bbba86fc9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a2a38620cf178b53b217051f32d1d7bbba86fc9/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04cdb132020733bedc36d14d61cce4246b8bbe4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04cdb132020733bedc36d14d61cce4246b8bbe4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04cdb132020733bedc36d14d61cce4246b8bbe4c"}], "stats": {"total": 47, "additions": 31, "deletions": 16}, "files": [{"sha": "69e1eb89ac673f918e3845a586463a58f8883086", "filename": "gcc/alias.c", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a2a38620cf178b53b217051f32d1d7bbba86fc9/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a2a38620cf178b53b217051f32d1d7bbba86fc9/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=6a2a38620cf178b53b217051f32d1d7bbba86fc9", "patch": "@@ -159,7 +159,8 @@ static tree decl_for_component_ref (tree);\n static int write_dependence_p (const_rtx,\n \t\t\t       const_rtx, machine_mode, rtx,\n \t\t\t       bool, bool, bool);\n-static int compare_base_symbol_refs (const_rtx, const_rtx);\n+static int compare_base_symbol_refs (const_rtx, const_rtx,\n+\t\t\t\t     HOST_WIDE_INT * = NULL);\n \n static void memory_modified_1 (rtx, const_rtx, void *);\n \n@@ -1837,7 +1838,11 @@ rtx_equal_for_memref_p (const_rtx x, const_rtx y)\n       return label_ref_label (x) == label_ref_label (y);\n \n     case SYMBOL_REF:\n-      return compare_base_symbol_refs (x, y) == 1;\n+      {\n+\tHOST_WIDE_INT distance = 0;\n+\treturn (compare_base_symbol_refs (x, y, &distance) == 1\n+\t\t&& distance == 0);\n+      }\n \n     case ENTRY_VALUE:\n       /* This is magic, don't go through canonicalization et al.  */\n@@ -2172,10 +2177,20 @@ compare_base_decls (tree base1, tree base2)\n   return ret;\n }\n \n-/* Same as compare_base_decls but for SYMBOL_REF.  */\n+/* Compare SYMBOL_REFs X_BASE and Y_BASE.\n+\n+   - Return 1 if Y_BASE - X_BASE is constant, adding that constant\n+     to *DISTANCE if DISTANCE is nonnull.\n+\n+   - Return 0 if no accesses based on X_BASE can alias Y_BASE.\n+\n+   - Return -1 if one of the two results applies, but we can't tell\n+     which at compile time.  Update DISTANCE in the same way as\n+     for a return value of 1, for the case in which that holds.  */\n \n static int\n-compare_base_symbol_refs (const_rtx x_base, const_rtx y_base)\n+compare_base_symbol_refs (const_rtx x_base, const_rtx y_base,\n+\t\t\t  HOST_WIDE_INT *distance)\n {\n   tree x_decl = SYMBOL_REF_DECL (x_base);\n   tree y_decl = SYMBOL_REF_DECL (y_base);\n@@ -2192,8 +2207,8 @@ compare_base_symbol_refs (const_rtx x_base, const_rtx y_base)\n \t  std::swap (x_decl, y_decl);\n \t  std::swap (x_base, y_base);\n \t}\n-      /* We handle specially only section anchors and assume that other\n- \t labels may overlap with user variables in an arbitrary way.  */\n+      /* We handle specially only section anchors.  Other symbols are\n+\t either equal (via aliasing) or refer to different objects.  */\n       if (!SYMBOL_REF_HAS_BLOCK_INFO_P (y_base))\n         return -1;\n       /* Anchors contains static VAR_DECLs and CONST_DECLs.  We are safe\n@@ -2222,14 +2237,13 @@ compare_base_symbol_refs (const_rtx x_base, const_rtx y_base)\n     {\n       if (SYMBOL_REF_BLOCK (x_base) != SYMBOL_REF_BLOCK (y_base))\n \treturn 0;\n-      if (SYMBOL_REF_BLOCK_OFFSET (x_base) == SYMBOL_REF_BLOCK_OFFSET (y_base))\n-\treturn binds_def ? 1 : -1;\n-      if (SYMBOL_REF_ANCHOR_P (x_base) != SYMBOL_REF_ANCHOR_P (y_base))\n-\treturn -1;\n-      return 0;\n+      if (distance)\n+\t*distance += (SYMBOL_REF_BLOCK_OFFSET (y_base)\n+\t\t      - SYMBOL_REF_BLOCK_OFFSET (x_base));\n+      return binds_def ? 1 : -1;\n     }\n-  /* In general we assume that memory locations pointed to by different labels\n-     may overlap in undefined ways.  */\n+  /* Either the symbols are equal (via aliasing) or they refer to\n+     different objects.  */\n   return -1;\n }\n \n@@ -2513,11 +2527,12 @@ memrefs_conflict_p (poly_int64 xsize, rtx x, poly_int64 ysize, rtx y,\n \n   if (GET_CODE (x) == SYMBOL_REF && GET_CODE (y) == SYMBOL_REF)\n     {\n-      int cmp = compare_base_symbol_refs (x,y);\n+      HOST_WIDE_INT distance = 0;\n+      int cmp = compare_base_symbol_refs (x, y, &distance);\n \n       /* If both decls are the same, decide by offsets.  */\n       if (cmp == 1)\n-        return offset_overlap_p (c, xsize, ysize);\n+\treturn offset_overlap_p (c + distance, xsize, ysize);\n       /* Assume a potential overlap for symbolic addresses that went\n \t through alignment adjustments (i.e., that have negative\n \t sizes), because we can't know how far they are from each\n@@ -2526,7 +2541,7 @@ memrefs_conflict_p (poly_int64 xsize, rtx x, poly_int64 ysize, rtx y,\n \treturn -1;\n       /* If decls are different or we know by offsets that there is no overlap,\n \t we win.  */\n-      if (!cmp || !offset_overlap_p (c, xsize, ysize))\n+      if (!cmp || !offset_overlap_p (c + distance, xsize, ysize))\n \treturn 0;\n       /* Decls may or may not be different and offsets overlap....*/\n       return -1;"}]}