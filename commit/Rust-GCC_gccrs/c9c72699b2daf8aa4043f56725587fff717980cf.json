{"sha": "c9c72699b2daf8aa4043f56725587fff717980cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzljNzI2OTliMmRhZjhhYTQwNDNmNTY3MjU1ODdmZmY3MTc5ODBjZg==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2012-07-16T17:23:54Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2012-07-16T17:23:54Z"}, "message": "spu.c (targetm): Move to bottom of file.\n\n\t* config/spu/spu.c (targetm): Move to bottom of file.\n\t(spu_attribute_table): Likewise.\n\t(spu_option_override, spu_init_builtins, spu_builtin_decl,\n\tspu_scalar_mode_supported_p, spu_vector_mode_supported_p,\n\tspu_legitimate_address_p, spu_addr_space_legitimate_address_p,\n\tadjust_operand, get_pic_reg, need_to_save_reg, frame_emit_store,\n\tframe_emit_load, frame_emit_add_imm, emit_nop_for_insn,\n\tinsn_clobbers_hbr, spu_emit_branch_hint, spu_emit_vector_compare,\n\tget_branch_target, spu_machine_dependent_reorg, spu_sched_issue_rate,\n\tspu_sched_variable_issue, spu_sched_adjust_cost, spu_sched_init_global,\n\tspu_sched_init, spu_sched_reorder, spu_handle_fndecl_attribute,\n\tspu_handle_vector_attribute, spu_pass_by_reference, spu_function_arg,\n\tspu_function_arg_advance, spu_build_builtin_va_list, spu_va_start,\n\tspu_gimplify_va_arg_expr, store_with_one_insn_p, reg_aligned_for_addr,\n\tspu_assemble_integer, spu_asm_globalize_label, spu_rtx_costs,\n\tspu_function_ok_for_sibcall, spu_init_libfuncs, spu_return_in_memory,\n\tspu_encode_section_info, spu_legitimize_address,\n\tspu_addr_space_legitimize_address, spu_builtin_mask_for_load,\n\tspu_builtin_vectorization_cost, spu_vector_alignment_reachable,\n\tspu_addr_space_pointer_mode, spu_addr_space_address_mode,\n\tspu_addr_space_subset_p, spu_addr_space_convert, spu_sms_res_mii,\n\tspu_section_type_flags, spu_select_section, spu_unique_section,\n\tspu_trampoline_init, spu_conditional_register_usage,\n\tspu_ref_may_alias_errno, spu_output_mi_thunk, spu_unwind_word_mode,\n\tspu_libgcc_cmp_return_mode, spu_libgcc_shift_count_mode,\n\tspu_setup_incoming_varargs): Remove prototypes.\n\t(spu_legitimize_address): Add \"static\" to definition.\n\nFrom-SVN: r189544", "tree": {"sha": "522128c0ba3430e139f02821ae71b1d3c580b481", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/522128c0ba3430e139f02821ae71b1d3c580b481"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9c72699b2daf8aa4043f56725587fff717980cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9c72699b2daf8aa4043f56725587fff717980cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9c72699b2daf8aa4043f56725587fff717980cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9c72699b2daf8aa4043f56725587fff717980cf/comments", "author": null, "committer": null, "parents": [{"sha": "053c2b8794ffe02224138b2fa8c365a7da1424e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/053c2b8794ffe02224138b2fa8c365a7da1424e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/053c2b8794ffe02224138b2fa8c365a7da1424e5"}], "stats": {"total": 544, "additions": 243, "deletions": 301}, "files": [{"sha": "884cef2ae7f5a21a4c8eb738c2b4e7655d45734d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9c72699b2daf8aa4043f56725587fff717980cf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9c72699b2daf8aa4043f56725587fff717980cf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c9c72699b2daf8aa4043f56725587fff717980cf", "patch": "@@ -1,3 +1,33 @@\n+2012-07-16  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* config/spu/spu.c (targetm): Move to bottom of file.\n+\t(spu_attribute_table): Likewise.\n+\t(spu_option_override, spu_init_builtins, spu_builtin_decl,\n+\tspu_scalar_mode_supported_p, spu_vector_mode_supported_p,\n+\tspu_legitimate_address_p, spu_addr_space_legitimate_address_p,\n+\tadjust_operand, get_pic_reg, need_to_save_reg, frame_emit_store,\n+\tframe_emit_load, frame_emit_add_imm, emit_nop_for_insn,\n+\tinsn_clobbers_hbr, spu_emit_branch_hint, spu_emit_vector_compare,\n+\tget_branch_target, spu_machine_dependent_reorg, spu_sched_issue_rate,\n+\tspu_sched_variable_issue, spu_sched_adjust_cost, spu_sched_init_global,\n+\tspu_sched_init, spu_sched_reorder, spu_handle_fndecl_attribute,\n+\tspu_handle_vector_attribute, spu_pass_by_reference, spu_function_arg,\n+\tspu_function_arg_advance, spu_build_builtin_va_list, spu_va_start,\n+\tspu_gimplify_va_arg_expr, store_with_one_insn_p, reg_aligned_for_addr,\n+\tspu_assemble_integer, spu_asm_globalize_label, spu_rtx_costs,\n+\tspu_function_ok_for_sibcall, spu_init_libfuncs, spu_return_in_memory,\n+\tspu_encode_section_info, spu_legitimize_address,\n+\tspu_addr_space_legitimize_address, spu_builtin_mask_for_load,\n+\tspu_builtin_vectorization_cost, spu_vector_alignment_reachable,\n+\tspu_addr_space_pointer_mode, spu_addr_space_address_mode,\n+\tspu_addr_space_subset_p, spu_addr_space_convert, spu_sms_res_mii,\n+\tspu_section_type_flags, spu_select_section, spu_unique_section,\n+\tspu_trampoline_init, spu_conditional_register_usage,\n+\tspu_ref_may_alias_errno, spu_output_mi_thunk, spu_unwind_word_mode,\n+\tspu_libgcc_cmp_return_mode, spu_libgcc_shift_count_mode,\n+\tspu_setup_incoming_varargs): Remove prototypes.\n+\t(spu_legitimize_address): Add \"static\" to definition.\n+\n 2012-07-16  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/rtmintrin.h (_xabort): Remove trailing semicolon."}, {"sha": "838c17298ab56476b8934323492f1e2c0b479cac", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 213, "deletions": 301, "changes": 514, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9c72699b2daf8aa4043f56725587fff717980cf/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9c72699b2daf8aa4043f56725587fff717980cf/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=c9c72699b2daf8aa4043f56725587fff717980cf", "patch": "@@ -147,88 +147,11 @@ static struct spu_builtin_range spu_builtin_range[] = {\n char regs_ever_allocated[FIRST_PSEUDO_REGISTER];\n \n /*  Prototypes and external defs.  */\n-static void spu_option_override (void);\n-static void spu_init_builtins (void);\n-static tree spu_builtin_decl (unsigned, bool);\n-static bool spu_scalar_mode_supported_p (enum machine_mode mode);\n-static bool spu_vector_mode_supported_p (enum machine_mode mode);\n-static bool spu_legitimate_address_p (enum machine_mode, rtx, bool);\n-static bool spu_addr_space_legitimate_address_p (enum machine_mode, rtx,\n-\t\t\t\t\t\t bool, addr_space_t);\n-static rtx adjust_operand (rtx op, HOST_WIDE_INT * start);\n-static rtx get_pic_reg (void);\n-static int need_to_save_reg (int regno, int saving);\n-static rtx frame_emit_store (int regno, rtx addr, HOST_WIDE_INT offset);\n-static rtx frame_emit_load (int regno, rtx addr, HOST_WIDE_INT offset);\n-static rtx frame_emit_add_imm (rtx dst, rtx src, HOST_WIDE_INT imm,\n-\t\t\t       rtx scratch);\n-static void emit_nop_for_insn (rtx insn);\n-static bool insn_clobbers_hbr (rtx insn);\n-static void spu_emit_branch_hint (rtx before, rtx branch, rtx target,\n-\t\t\t\t  int distance, sbitmap blocks);\n-static rtx spu_emit_vector_compare (enum rtx_code rcode, rtx op0, rtx op1,\n-\t                            enum machine_mode dmode);\n-static rtx get_branch_target (rtx branch);\n-static void spu_machine_dependent_reorg (void);\n-static int spu_sched_issue_rate (void);\n-static int spu_sched_variable_issue (FILE * dump, int verbose, rtx insn,\n-\t\t\t\t     int can_issue_more);\n static int get_pipe (rtx insn);\n-static int spu_sched_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost);\n-static void spu_sched_init_global (FILE *, int, int);\n-static void spu_sched_init (FILE *, int, int);\n-static int spu_sched_reorder (FILE *, int, rtx *, int *, int);\n-static tree spu_handle_fndecl_attribute (tree * node, tree name, tree args,\n-\t\t\t\t\t int flags,\n-\t\t\t\t\t bool *no_add_attrs);\n-static tree spu_handle_vector_attribute (tree * node, tree name, tree args,\n-\t\t\t\t\t int flags,\n-\t\t\t\t\t bool *no_add_attrs);\n static int spu_naked_function_p (tree func);\n-static bool spu_pass_by_reference (cumulative_args_t cum,\n-\t\t\t\t   enum machine_mode mode,\n-\t\t\t\t   const_tree type, bool named);\n-static rtx spu_function_arg (cumulative_args_t cum, enum machine_mode mode,\n-\t\t\t     const_tree type, bool named);\n-static void spu_function_arg_advance (cumulative_args_t cum,\n-\t\t\t\t      enum machine_mode mode,\n-\t\t\t\t      const_tree type, bool named);\n-static tree spu_build_builtin_va_list (void);\n-static void spu_va_start (tree, rtx);\n-static tree spu_gimplify_va_arg_expr (tree valist, tree type,\n-\t\t\t\t      gimple_seq * pre_p, gimple_seq * post_p);\n-static int store_with_one_insn_p (rtx mem);\n static int mem_is_padded_component_ref (rtx x);\n-static int reg_aligned_for_addr (rtx x);\n-static bool spu_assemble_integer (rtx x, unsigned int size, int aligned_p);\n-static void spu_asm_globalize_label (FILE * file, const char *name);\n-static bool spu_rtx_costs (rtx x, int code, int outer_code, int opno,\n-\t\t\t   int *total, bool speed);\n-static bool spu_function_ok_for_sibcall (tree decl, tree exp);\n-static void spu_init_libfuncs (void);\n-static bool spu_return_in_memory (const_tree type, const_tree fntype);\n static void fix_range (const char *);\n-static void spu_encode_section_info (tree, rtx, int);\n-static rtx spu_legitimize_address (rtx, rtx, enum machine_mode);\n-static rtx spu_addr_space_legitimize_address (rtx, rtx, enum machine_mode,\n-\t\t\t\t\t      addr_space_t);\n-static tree spu_builtin_mask_for_load (void);\n-static int spu_builtin_vectorization_cost (enum vect_cost_for_stmt, tree, int);\n-static bool spu_vector_alignment_reachable (const_tree, bool);\n-static enum machine_mode spu_addr_space_pointer_mode (addr_space_t);\n-static enum machine_mode spu_addr_space_address_mode (addr_space_t);\n-static bool spu_addr_space_subset_p (addr_space_t, addr_space_t);\n-static rtx spu_addr_space_convert (rtx, tree, tree);\n-static int spu_sms_res_mii (struct ddg *g);\n-static unsigned int spu_section_type_flags (tree, const char *, int);\n-static section *spu_select_section (tree, int, unsigned HOST_WIDE_INT);\n-static void spu_unique_section (tree, int);\n static rtx spu_expand_load (rtx, rtx, rtx, int);\n-static void spu_trampoline_init (rtx, tree, rtx);\n-static void spu_conditional_register_usage (void);\n-static bool spu_ref_may_alias_errno (ao_ref *);\n-static void spu_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n-\t\t\t\t HOST_WIDE_INT, tree);\n \n /* Which instruction set architecture to use.  */\n int spu_arch;\n@@ -272,233 +195,10 @@ static int cpat_info(unsigned char *arr, int size, int *prun, int *pstart);\n static enum immediate_class classify_immediate (rtx op,\n \t\t\t\t\t\tenum machine_mode mode);\n \n-static enum machine_mode spu_unwind_word_mode (void);\n-\n-static enum machine_mode\n-spu_libgcc_cmp_return_mode (void);\n-\n-static enum machine_mode\n-spu_libgcc_shift_count_mode (void);\n-\n /* Pointer mode for __ea references.  */\n #define EAmode (spu_ea_model != 32 ? DImode : SImode)\n \n \f\n-/*  Table of machine attributes.  */\n-static const struct attribute_spec spu_attribute_table[] =\n-{\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n-  { \"naked\",          0, 0, true,  false, false, spu_handle_fndecl_attribute,\n-    false },\n-  { \"spu_vector\",     0, 0, false, true,  false, spu_handle_vector_attribute,\n-    false },\n-  { NULL,             0, 0, false, false, false, NULL, false }\n-};\n-\f\n-/*  TARGET overrides.  */\n-\n-#undef TARGET_ADDR_SPACE_POINTER_MODE\n-#define TARGET_ADDR_SPACE_POINTER_MODE spu_addr_space_pointer_mode\n-\n-#undef TARGET_ADDR_SPACE_ADDRESS_MODE\n-#define TARGET_ADDR_SPACE_ADDRESS_MODE spu_addr_space_address_mode\n-\n-#undef TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P\n-#define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P \\\n-  spu_addr_space_legitimate_address_p\n-\n-#undef TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS\n-#define TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS spu_addr_space_legitimize_address\n-\n-#undef TARGET_ADDR_SPACE_SUBSET_P\n-#define TARGET_ADDR_SPACE_SUBSET_P spu_addr_space_subset_p\n-\n-#undef TARGET_ADDR_SPACE_CONVERT\n-#define TARGET_ADDR_SPACE_CONVERT spu_addr_space_convert\n-\n-#undef TARGET_INIT_BUILTINS\n-#define TARGET_INIT_BUILTINS spu_init_builtins\n-#undef TARGET_BUILTIN_DECL\n-#define TARGET_BUILTIN_DECL spu_builtin_decl\n-\n-#undef TARGET_EXPAND_BUILTIN\n-#define TARGET_EXPAND_BUILTIN spu_expand_builtin\n-\n-#undef TARGET_UNWIND_WORD_MODE\n-#define TARGET_UNWIND_WORD_MODE spu_unwind_word_mode\n-\n-#undef TARGET_LEGITIMIZE_ADDRESS\n-#define TARGET_LEGITIMIZE_ADDRESS spu_legitimize_address\n-\n-/* The current assembler doesn't like .4byte foo@ppu, so use the normal .long\n-   and .quad for the debugger.  When it is known that the assembler is fixed,\n-   these can be removed.  */\n-#undef TARGET_ASM_UNALIGNED_SI_OP\n-#define TARGET_ASM_UNALIGNED_SI_OP\t\"\\t.long\\t\"\n-\n-#undef TARGET_ASM_ALIGNED_DI_OP\n-#define TARGET_ASM_ALIGNED_DI_OP\t\"\\t.quad\\t\"\n-\n-/* The .8byte directive doesn't seem to work well for a 32 bit\n-   architecture. */\n-#undef TARGET_ASM_UNALIGNED_DI_OP\n-#define TARGET_ASM_UNALIGNED_DI_OP NULL\n-\n-#undef TARGET_RTX_COSTS\n-#define TARGET_RTX_COSTS spu_rtx_costs\n-\n-#undef TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST hook_int_rtx_bool_0\n-\n-#undef TARGET_SCHED_ISSUE_RATE\n-#define TARGET_SCHED_ISSUE_RATE spu_sched_issue_rate\n-\n-#undef TARGET_SCHED_INIT_GLOBAL\n-#define TARGET_SCHED_INIT_GLOBAL spu_sched_init_global\n-\n-#undef TARGET_SCHED_INIT\n-#define TARGET_SCHED_INIT spu_sched_init\n-\n-#undef TARGET_SCHED_VARIABLE_ISSUE\n-#define TARGET_SCHED_VARIABLE_ISSUE spu_sched_variable_issue\n-\n-#undef TARGET_SCHED_REORDER\n-#define TARGET_SCHED_REORDER spu_sched_reorder\n-\n-#undef TARGET_SCHED_REORDER2\n-#define TARGET_SCHED_REORDER2 spu_sched_reorder\n-\n-#undef TARGET_SCHED_ADJUST_COST\n-#define TARGET_SCHED_ADJUST_COST spu_sched_adjust_cost\n-\n-#undef  TARGET_ATTRIBUTE_TABLE\n-#define TARGET_ATTRIBUTE_TABLE spu_attribute_table\n-\n-#undef TARGET_ASM_INTEGER\n-#define TARGET_ASM_INTEGER spu_assemble_integer\n-\n-#undef TARGET_SCALAR_MODE_SUPPORTED_P\n-#define TARGET_SCALAR_MODE_SUPPORTED_P\tspu_scalar_mode_supported_p\n-\n-#undef TARGET_VECTOR_MODE_SUPPORTED_P\n-#define TARGET_VECTOR_MODE_SUPPORTED_P\tspu_vector_mode_supported_p\n-\n-#undef TARGET_FUNCTION_OK_FOR_SIBCALL\n-#define TARGET_FUNCTION_OK_FOR_SIBCALL spu_function_ok_for_sibcall\n-\n-#undef TARGET_ASM_GLOBALIZE_LABEL\n-#define TARGET_ASM_GLOBALIZE_LABEL spu_asm_globalize_label\n-\n-#undef TARGET_PASS_BY_REFERENCE\n-#define TARGET_PASS_BY_REFERENCE spu_pass_by_reference\n-\n-#undef TARGET_FUNCTION_ARG\n-#define TARGET_FUNCTION_ARG spu_function_arg\n-\n-#undef TARGET_FUNCTION_ARG_ADVANCE\n-#define TARGET_FUNCTION_ARG_ADVANCE spu_function_arg_advance\n-\n-#undef TARGET_MUST_PASS_IN_STACK\n-#define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n-\n-#undef TARGET_BUILD_BUILTIN_VA_LIST\n-#define TARGET_BUILD_BUILTIN_VA_LIST spu_build_builtin_va_list\n-\n-#undef TARGET_EXPAND_BUILTIN_VA_START\n-#define TARGET_EXPAND_BUILTIN_VA_START spu_va_start\n-\n-static void spu_setup_incoming_varargs (cumulative_args_t cum,\n-\t\t\t\t\tenum machine_mode mode,\n-\t\t\t\t\ttree type, int *pretend_size,\n-\t\t\t\t\tint no_rtl);\n-#undef TARGET_SETUP_INCOMING_VARARGS\n-#define TARGET_SETUP_INCOMING_VARARGS spu_setup_incoming_varargs\n-\n-#undef TARGET_MACHINE_DEPENDENT_REORG\n-#define TARGET_MACHINE_DEPENDENT_REORG spu_machine_dependent_reorg\n-\n-#undef TARGET_GIMPLIFY_VA_ARG_EXPR\n-#define TARGET_GIMPLIFY_VA_ARG_EXPR spu_gimplify_va_arg_expr\n-\n-#undef TARGET_INIT_LIBFUNCS\n-#define TARGET_INIT_LIBFUNCS spu_init_libfuncs\n-\n-#undef TARGET_RETURN_IN_MEMORY\n-#define TARGET_RETURN_IN_MEMORY spu_return_in_memory\n-\n-#undef  TARGET_ENCODE_SECTION_INFO\n-#define TARGET_ENCODE_SECTION_INFO spu_encode_section_info\n-\n-#undef TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD\n-#define TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD spu_builtin_mask_for_load\n-\n-#undef TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\n-#define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST spu_builtin_vectorization_cost\n-\n-#undef TARGET_VECTORIZE_INIT_COST\n-#define TARGET_VECTORIZE_INIT_COST spu_init_cost\n-\n-#undef TARGET_VECTORIZE_ADD_STMT_COST\n-#define TARGET_VECTORIZE_ADD_STMT_COST spu_add_stmt_cost\n-\n-#undef TARGET_VECTORIZE_FINISH_COST\n-#define TARGET_VECTORIZE_FINISH_COST spu_finish_cost\n-\n-#undef TARGET_VECTORIZE_DESTROY_COST_DATA\n-#define TARGET_VECTORIZE_DESTROY_COST_DATA spu_destroy_cost_data\n-\n-#undef TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE\n-#define TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE spu_vector_alignment_reachable\n-\n-#undef TARGET_LIBGCC_CMP_RETURN_MODE\n-#define TARGET_LIBGCC_CMP_RETURN_MODE spu_libgcc_cmp_return_mode\n-\n-#undef TARGET_LIBGCC_SHIFT_COUNT_MODE\n-#define TARGET_LIBGCC_SHIFT_COUNT_MODE spu_libgcc_shift_count_mode\n-\n-#undef TARGET_SCHED_SMS_RES_MII\n-#define TARGET_SCHED_SMS_RES_MII spu_sms_res_mii\n-\n-#undef TARGET_SECTION_TYPE_FLAGS\n-#define TARGET_SECTION_TYPE_FLAGS spu_section_type_flags\n-\n-#undef TARGET_ASM_SELECT_SECTION\n-#define TARGET_ASM_SELECT_SECTION  spu_select_section\n-\n-#undef TARGET_ASM_UNIQUE_SECTION\n-#define TARGET_ASM_UNIQUE_SECTION  spu_unique_section\n-\n-#undef TARGET_LEGITIMATE_ADDRESS_P\n-#define TARGET_LEGITIMATE_ADDRESS_P spu_legitimate_address_p\n-\n-#undef TARGET_LEGITIMATE_CONSTANT_P\n-#define TARGET_LEGITIMATE_CONSTANT_P spu_legitimate_constant_p\n-\n-#undef TARGET_TRAMPOLINE_INIT\n-#define TARGET_TRAMPOLINE_INIT spu_trampoline_init\n-\n-#undef TARGET_OPTION_OVERRIDE\n-#define TARGET_OPTION_OVERRIDE spu_option_override\n-\n-#undef TARGET_CONDITIONAL_REGISTER_USAGE\n-#define TARGET_CONDITIONAL_REGISTER_USAGE spu_conditional_register_usage\n-\n-#undef TARGET_REF_MAY_ALIAS_ERRNO\n-#define TARGET_REF_MAY_ALIAS_ERRNO spu_ref_may_alias_errno\n-\n-#undef TARGET_ASM_OUTPUT_MI_THUNK\n-#define TARGET_ASM_OUTPUT_MI_THUNK spu_output_mi_thunk\n-#undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n-#define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_const_tree_hwi_hwi_const_tree_true\n-\n-/* Variable tracking should be run after all optimizations which\n-   change order of insns.  It also needs a valid CFG.  */\n-#undef TARGET_DELAY_VARTRACK\n-#define TARGET_DELAY_VARTRACK true\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;\n-\n /* Define the structure for the machine field in struct function.  */\n struct GTY(()) machine_function\n {\n@@ -3888,7 +3588,7 @@ spu_addr_space_legitimate_address_p (enum machine_mode mode, rtx x,\n \n /* When the address is reg + const_int, force the const_int into a\n    register.  */\n-rtx\n+static rtx\n spu_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t\t\tenum machine_mode mode ATTRIBUTE_UNUSED)\n {\n@@ -7376,4 +7076,216 @@ spu_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n   final_end_function ();\n }\n \n+\f\n+/*  Table of machine attributes.  */\n+static const struct attribute_spec spu_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n+       affects_type_identity } */\n+  { \"naked\",          0, 0, true,  false, false, spu_handle_fndecl_attribute,\n+    false },\n+  { \"spu_vector\",     0, 0, false, true,  false, spu_handle_vector_attribute,\n+    false },\n+  { NULL,             0, 0, false, false, false, NULL, false }\n+};\n+\n+/*  TARGET overrides.  */\n+\n+#undef TARGET_ADDR_SPACE_POINTER_MODE\n+#define TARGET_ADDR_SPACE_POINTER_MODE spu_addr_space_pointer_mode\n+\n+#undef TARGET_ADDR_SPACE_ADDRESS_MODE\n+#define TARGET_ADDR_SPACE_ADDRESS_MODE spu_addr_space_address_mode\n+\n+#undef TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P\n+#define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P \\\n+  spu_addr_space_legitimate_address_p\n+\n+#undef TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS\n+#define TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS spu_addr_space_legitimize_address\n+\n+#undef TARGET_ADDR_SPACE_SUBSET_P\n+#define TARGET_ADDR_SPACE_SUBSET_P spu_addr_space_subset_p\n+\n+#undef TARGET_ADDR_SPACE_CONVERT\n+#define TARGET_ADDR_SPACE_CONVERT spu_addr_space_convert\n+\n+#undef TARGET_INIT_BUILTINS\n+#define TARGET_INIT_BUILTINS spu_init_builtins\n+#undef TARGET_BUILTIN_DECL\n+#define TARGET_BUILTIN_DECL spu_builtin_decl\n+\n+#undef TARGET_EXPAND_BUILTIN\n+#define TARGET_EXPAND_BUILTIN spu_expand_builtin\n+\n+#undef TARGET_UNWIND_WORD_MODE\n+#define TARGET_UNWIND_WORD_MODE spu_unwind_word_mode\n+\n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS spu_legitimize_address\n+\n+/* The current assembler doesn't like .4byte foo@ppu, so use the normal .long\n+   and .quad for the debugger.  When it is known that the assembler is fixed,\n+   these can be removed.  */\n+#undef TARGET_ASM_UNALIGNED_SI_OP\n+#define TARGET_ASM_UNALIGNED_SI_OP\t\"\\t.long\\t\"\n+\n+#undef TARGET_ASM_ALIGNED_DI_OP\n+#define TARGET_ASM_ALIGNED_DI_OP\t\"\\t.quad\\t\"\n+\n+/* The .8byte directive doesn't seem to work well for a 32 bit\n+   architecture. */\n+#undef TARGET_ASM_UNALIGNED_DI_OP\n+#define TARGET_ASM_UNALIGNED_DI_OP NULL\n+\n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS spu_rtx_costs\n+\n+#undef TARGET_ADDRESS_COST\n+#define TARGET_ADDRESS_COST hook_int_rtx_bool_0\n+\n+#undef TARGET_SCHED_ISSUE_RATE\n+#define TARGET_SCHED_ISSUE_RATE spu_sched_issue_rate\n+\n+#undef TARGET_SCHED_INIT_GLOBAL\n+#define TARGET_SCHED_INIT_GLOBAL spu_sched_init_global\n+\n+#undef TARGET_SCHED_INIT\n+#define TARGET_SCHED_INIT spu_sched_init\n+\n+#undef TARGET_SCHED_VARIABLE_ISSUE\n+#define TARGET_SCHED_VARIABLE_ISSUE spu_sched_variable_issue\n+\n+#undef TARGET_SCHED_REORDER\n+#define TARGET_SCHED_REORDER spu_sched_reorder\n+\n+#undef TARGET_SCHED_REORDER2\n+#define TARGET_SCHED_REORDER2 spu_sched_reorder\n+\n+#undef TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST spu_sched_adjust_cost\n+\n+#undef  TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE spu_attribute_table\n+\n+#undef TARGET_ASM_INTEGER\n+#define TARGET_ASM_INTEGER spu_assemble_integer\n+\n+#undef TARGET_SCALAR_MODE_SUPPORTED_P\n+#define TARGET_SCALAR_MODE_SUPPORTED_P\tspu_scalar_mode_supported_p\n+\n+#undef TARGET_VECTOR_MODE_SUPPORTED_P\n+#define TARGET_VECTOR_MODE_SUPPORTED_P\tspu_vector_mode_supported_p\n+\n+#undef TARGET_FUNCTION_OK_FOR_SIBCALL\n+#define TARGET_FUNCTION_OK_FOR_SIBCALL spu_function_ok_for_sibcall\n+\n+#undef TARGET_ASM_GLOBALIZE_LABEL\n+#define TARGET_ASM_GLOBALIZE_LABEL spu_asm_globalize_label\n+\n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE spu_pass_by_reference\n+\n+#undef TARGET_FUNCTION_ARG\n+#define TARGET_FUNCTION_ARG spu_function_arg\n+\n+#undef TARGET_FUNCTION_ARG_ADVANCE\n+#define TARGET_FUNCTION_ARG_ADVANCE spu_function_arg_advance\n+\n+#undef TARGET_MUST_PASS_IN_STACK\n+#define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n+\n+#undef TARGET_BUILD_BUILTIN_VA_LIST\n+#define TARGET_BUILD_BUILTIN_VA_LIST spu_build_builtin_va_list\n+\n+#undef TARGET_EXPAND_BUILTIN_VA_START\n+#define TARGET_EXPAND_BUILTIN_VA_START spu_va_start\n+\n+#undef TARGET_SETUP_INCOMING_VARARGS\n+#define TARGET_SETUP_INCOMING_VARARGS spu_setup_incoming_varargs\n+\n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG spu_machine_dependent_reorg\n+\n+#undef TARGET_GIMPLIFY_VA_ARG_EXPR\n+#define TARGET_GIMPLIFY_VA_ARG_EXPR spu_gimplify_va_arg_expr\n+\n+#undef TARGET_INIT_LIBFUNCS\n+#define TARGET_INIT_LIBFUNCS spu_init_libfuncs\n+\n+#undef TARGET_RETURN_IN_MEMORY\n+#define TARGET_RETURN_IN_MEMORY spu_return_in_memory\n+\n+#undef  TARGET_ENCODE_SECTION_INFO\n+#define TARGET_ENCODE_SECTION_INFO spu_encode_section_info\n+\n+#undef TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD\n+#define TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD spu_builtin_mask_for_load\n+\n+#undef TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\n+#define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST spu_builtin_vectorization_cost\n+\n+#undef TARGET_VECTORIZE_INIT_COST\n+#define TARGET_VECTORIZE_INIT_COST spu_init_cost\n+\n+#undef TARGET_VECTORIZE_ADD_STMT_COST\n+#define TARGET_VECTORIZE_ADD_STMT_COST spu_add_stmt_cost\n+\n+#undef TARGET_VECTORIZE_FINISH_COST\n+#define TARGET_VECTORIZE_FINISH_COST spu_finish_cost\n+\n+#undef TARGET_VECTORIZE_DESTROY_COST_DATA\n+#define TARGET_VECTORIZE_DESTROY_COST_DATA spu_destroy_cost_data\n+\n+#undef TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE\n+#define TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE spu_vector_alignment_reachable\n+\n+#undef TARGET_LIBGCC_CMP_RETURN_MODE\n+#define TARGET_LIBGCC_CMP_RETURN_MODE spu_libgcc_cmp_return_mode\n+\n+#undef TARGET_LIBGCC_SHIFT_COUNT_MODE\n+#define TARGET_LIBGCC_SHIFT_COUNT_MODE spu_libgcc_shift_count_mode\n+\n+#undef TARGET_SCHED_SMS_RES_MII\n+#define TARGET_SCHED_SMS_RES_MII spu_sms_res_mii\n+\n+#undef TARGET_SECTION_TYPE_FLAGS\n+#define TARGET_SECTION_TYPE_FLAGS spu_section_type_flags\n+\n+#undef TARGET_ASM_SELECT_SECTION\n+#define TARGET_ASM_SELECT_SECTION  spu_select_section\n+\n+#undef TARGET_ASM_UNIQUE_SECTION\n+#define TARGET_ASM_UNIQUE_SECTION  spu_unique_section\n+\n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P spu_legitimate_address_p\n+\n+#undef TARGET_LEGITIMATE_CONSTANT_P\n+#define TARGET_LEGITIMATE_CONSTANT_P spu_legitimate_constant_p\n+\n+#undef TARGET_TRAMPOLINE_INIT\n+#define TARGET_TRAMPOLINE_INIT spu_trampoline_init\n+\n+#undef TARGET_OPTION_OVERRIDE\n+#define TARGET_OPTION_OVERRIDE spu_option_override\n+\n+#undef TARGET_CONDITIONAL_REGISTER_USAGE\n+#define TARGET_CONDITIONAL_REGISTER_USAGE spu_conditional_register_usage\n+\n+#undef TARGET_REF_MAY_ALIAS_ERRNO\n+#define TARGET_REF_MAY_ALIAS_ERRNO spu_ref_may_alias_errno\n+\n+#undef TARGET_ASM_OUTPUT_MI_THUNK\n+#define TARGET_ASM_OUTPUT_MI_THUNK spu_output_mi_thunk\n+#undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_const_tree_hwi_hwi_const_tree_true\n+\n+/* Variable tracking should be run after all optimizations which\n+   change order of insns.  It also needs a valid CFG.  */\n+#undef TARGET_DELAY_VARTRACK\n+#define TARGET_DELAY_VARTRACK true\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;\n+\n #include \"gt-spu.h\""}]}