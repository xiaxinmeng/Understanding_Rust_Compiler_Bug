{"sha": "25eafae67f186cfa4c0fd0f89f743d7707d5bf21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVlYWZhZTY3ZjE4NmNmYTRjMGZkMGY4OWY3NDNkNzcwN2Q1YmYyMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-04-05T11:55:45Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-04-05T11:55:45Z"}, "message": "re PR debug/89892 (gcc generates wrong debug information at -O2)\n\n2019-04-05  Richard Biener  <rguenther@suse.de>\n\n\tPR debug/89892\n\tPR debug/89905\n\t* tree-cfgcleanup.c (remove_forwarder_block): Always move\n\tdebug bind stmts but reset them if they are not valid at the\n\tdestination.\n\n\t* gcc.dg/guality/pr89892.c: New testcase.\n\t* gcc.dg/guality/pr89905.c: Likewise.\n\t* gcc.dg/guality/loop-1.c: Likewise.\n\nFrom-SVN: r270165", "tree": {"sha": "f9f02b361b7c7daecd0478253904defd40599532", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9f02b361b7c7daecd0478253904defd40599532"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25eafae67f186cfa4c0fd0f89f743d7707d5bf21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25eafae67f186cfa4c0fd0f89f743d7707d5bf21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25eafae67f186cfa4c0fd0f89f743d7707d5bf21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25eafae67f186cfa4c0fd0f89f743d7707d5bf21/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2723350fc6fd336768abd93e568babe032d97228", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2723350fc6fd336768abd93e568babe032d97228", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2723350fc6fd336768abd93e568babe032d97228"}], "stats": {"total": 141, "additions": 138, "deletions": 3}, "files": [{"sha": "53b58ef3df03e55acdfc14f6af187cfb74cc870b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25eafae67f186cfa4c0fd0f89f743d7707d5bf21/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25eafae67f186cfa4c0fd0f89f743d7707d5bf21/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=25eafae67f186cfa4c0fd0f89f743d7707d5bf21", "patch": "@@ -1,3 +1,11 @@\n+2019-04-05  Richard Biener  <rguenther@suse.de>\n+\n+\tPR debug/89892\n+\tPR debug/89905\n+\t* tree-cfgcleanup.c (remove_forwarder_block): Always move\n+\tdebug bind stmts but reset them if they are not valid at the\n+\tdestination.\n+\n 2019-04-05  Martin Liska  <mliska@suse.cz>\n \n \tPR translation/89936"}, {"sha": "e19a1b824e9307bba252b3cee5e0e61e9cda8db6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25eafae67f186cfa4c0fd0f89f743d7707d5bf21/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25eafae67f186cfa4c0fd0f89f743d7707d5bf21/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=25eafae67f186cfa4c0fd0f89f743d7707d5bf21", "patch": "@@ -1,3 +1,11 @@\n+2019-04-05  Richard Biener  <rguenther@suse.de>\n+\n+\tPR debug/89892\n+\tPR debug/89905\n+\t* gcc.dg/guality/pr89892.c: New testcase.\n+\t* gcc.dg/guality/pr89905.c: Likewise.\n+\t* gcc.dg/guality/loop-1.c: Likewise.\n+\n 2019-04-05  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR tree-optimization/89956"}, {"sha": "8da447d5379b4ac226fd3245625bc7b8bb046f9a", "filename": "gcc/testsuite/gcc.dg/guality/loop-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25eafae67f186cfa4c0fd0f89f743d7707d5bf21/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Floop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25eafae67f186cfa4c0fd0f89f743d7707d5bf21/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Floop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Floop-1.c?ref=25eafae67f186cfa4c0fd0f89f743d7707d5bf21", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fno-tree-scev-cprop -fno-tree-vectorize -g\" } */\n+\n+#include \"../nop.h\"\n+\n+void __attribute__((noipa,noinline))\n+foo (int n)\n+{\n+  if (n == 0)\n+    return;\n+  int i = 0;\n+  do\n+    {\n+      ++i; /* { dg-final { gdb-test . \"i\" \"0\" } } */\n+    }\n+  while (i < n);\n+  /* The following works only with final value replacement or with the NOP\n+     but not without (which means -Og).  Vectorization breaks it, so disable\n+     that.  At -O3 it currently fails, PR89983.  */\n+  __asm__ volatile (NOP : : \"g\" (i) : \"memory\"); /* { dg-final { gdb-test . \"i\" \"1\" } } */\n+}\n+int main() { foo(1); }"}, {"sha": "9bb27fde436c8020a9d36b0b994e921fe77ffee9", "filename": "gcc/testsuite/gcc.dg/guality/pr89892.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25eafae67f186cfa4c0fd0f89f743d7707d5bf21/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr89892.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25eafae67f186cfa4c0fd0f89f743d7707d5bf21/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr89892.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr89892.c?ref=25eafae67f186cfa4c0fd0f89f743d7707d5bf21", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-options \"-g\" } */\n+\n+void __attribute__((noinline))\n+optimize_me_not ()\n+{\n+  __asm__ volatile (\"\" : : : \"memory\");\n+}\n+volatile int a;\n+static short b[3][9][1] = {5};\n+int c;\n+int main() {\n+    int i, d;\n+    i = 0;\n+    for (; i < 3; i++) {\n+\tc = 0;\n+\tfor (; c < 9; c++) {\n+\t    d = 0;\n+\t    for (; d < 1; d++)\n+\t      a = b[i][c][d];\n+\t}\n+    }\n+    i = c = 0;\n+    for (; c < 7; c++)\n+      for (; d < 6; d++)\n+\ta;\n+    /* i may very well be optimized out, so we cannot test for i == 0.\n+       Instead test i + 1 which will make the test UNSUPPORTED if i\n+       is optimized out.  Since the test previously had wrong debug\n+       with i == 2 this is acceptable.  Optimally we'd produce a\n+       debug stmt for the final value of the loop which would fix\n+       the UNSUPPORTED cases.  */\n+    optimize_me_not(); /* { dg-final { gdb-test . \"i + 1\" \"1\" } } */\n+}"}, {"sha": "e718359c9e6016c0da634069950c2b9c88e1aaaf", "filename": "gcc/testsuite/gcc.dg/guality/pr89905.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25eafae67f186cfa4c0fd0f89f743d7707d5bf21/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr89905.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25eafae67f186cfa4c0fd0f89f743d7707d5bf21/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr89905.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr89905.c?ref=25eafae67f186cfa4c0fd0f89f743d7707d5bf21", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do run } */\n+/* { dg-options \"-g\" } */\n+\n+void __attribute__((noinline))\n+optimize_me_not ()\n+{\n+  __asm__ volatile (\"\" : : : \"memory\");\n+}\n+char c, d = 22, f;\n+short e, g;\n+int h;\n+char(a)() {}\n+char(b)() { return 0; }\n+void i() {\n+    char j;\n+    for (; h < 1;) {\n+\tshort k[9] = {1, 1, 1, 1, 1, 1, 1, 1, 1};\n+\tint l, i = 5;\n+\tshort m[3] = {0, 0, 0};\n+\tfor (; h < 7; h++)\n+\t  for (; d >= 33;) {\n+\t      ++k[8];\n+\t      f = (c || a()) && g;\n+\t  }\n+\ti++;\n+\tj = b() || m[2];\n+\tl = 0;\n+\tfor (; l <= 6; l = d)\n+\t  e = k[8];\n+\t/* i may very well be optimized out, so we cannot test for i == 6.\n+\t   Instead test i + 1 which will make the test UNSUPPORTED if i\n+\t   is optimized out.  Since the test previously had wrong debug\n+\t   with i == 5 this is acceptable.  Optimally we'd produce a\n+\t   debug stmt for the final value of the loop which would fix\n+\t   the UNSUPPORTED cases.  */\n+\toptimize_me_not(); /* { dg-final { gdb-test . \"i + 1\" \"7\" } } */\n+    }\n+}\n+int main() { i(); }"}, {"sha": "3c291f5473b6f2a0680caa9a0457f9a43410df0c", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25eafae67f186cfa4c0fd0f89f743d7707d5bf21/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25eafae67f186cfa4c0fd0f89f743d7707d5bf21/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=25eafae67f186cfa4c0fd0f89f743d7707d5bf21", "patch": "@@ -564,15 +564,39 @@ remove_forwarder_block (basic_block bb)\n \tgsi_next (&gsi);\n     }\n \n-  /* Move debug statements if the destination has a single predecessor.  */\n-  if (can_move_debug_stmts && !gsi_end_p (gsi))\n+  /* Move debug statements.  Reset them if the destination does not\n+     have a single predecessor.  */\n+  if (!gsi_end_p (gsi))\n     {\n       gsi_to = gsi_after_labels (dest);\n       do\n \t{\n \t  gimple *debug = gsi_stmt (gsi);\n \t  gcc_assert (is_gimple_debug (debug));\n-\t  gsi_move_before (&gsi, &gsi_to);\n+\t  /* Move debug binds anyway, but not anything else\n+\t     like begin-stmt markers unless they are always\n+\t     valid at the destination.  */\n+\t  if (can_move_debug_stmts\n+\t      || gimple_debug_bind_p (debug))\n+\t    {\n+\t      gsi_move_before (&gsi, &gsi_to);\n+\t      /* Reset debug-binds that are not always valid at the\n+\t\t destination.  Simply dropping them can cause earlier\n+\t\t values to become live, generating wrong debug information.\n+\t\t ???  There are several things we could improve here.  For\n+\t\t one we might be able to move stmts to the predecessor.\n+\t\t For anther, if the debug stmt is immediately followed\n+\t\t by a (debug) definition in the destination (on a\n+\t\t post-dominated path?) we can elide it without any bad\n+\t\t effects.  */\n+\t      if (!can_move_debug_stmts)\n+\t\t{\n+\t\t  gimple_debug_bind_reset_value (debug);\n+\t\t  update_stmt (debug);\n+\t\t}\n+\t    }\n+\t  else\n+\t    gsi_next (&gsi);\n \t}\n       while (!gsi_end_p (gsi));\n     }"}]}