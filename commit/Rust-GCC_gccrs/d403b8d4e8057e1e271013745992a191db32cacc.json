{"sha": "d403b8d4e8057e1e271013745992a191db32cacc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQwM2I4ZDRlODA1N2UxZTI3MTAxMzc0NTk5MmExOTFkYjMyY2FjYw==", "commit": {"author": {"name": "Matthew Wahab", "email": "matthew.wahab@arm.com", "date": "2016-09-23T09:46:26Z"}, "committer": {"name": "Matthew Wahab", "email": "mwahab@gcc.gnu.org", "date": "2016-09-23T09:46:26Z"}, "message": "[PATCH 8/17][ARM] Add VFP FP16 arithmetic instructions.\n\ngcc/\n2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n\n\t* config/arm/iterators.md (Code iterators): Fix some white-space\n\tin the comments.\n\t(GLTE): New.\n\t(ABSNEG): New\n\t(FCVT): Moved from vfp.md.\n\t(VCVT_HF_US_N): New.\n\t(VCVT_SI_US_N): New.\n\t(VCVT_HF_US): New.\n\t(VCVTH_US): New.\n\t(FP16_RND): New.\n\t(absneg_str): New.\n\t(FCVTI32typename): Moved from vfp.md.\n\t(sup): Add UNSPEC_VCVTA_S, UNSPEC_VCVTA_U, UNSPEC_VCVTM_S,\n\tUNSPEC_VCVTM_U, UNSPEC_VCVTN_S, UNSPEC_VCVTN_U, UNSPEC_VCVTP_S,\n\tUNSPEC_VCVTP_U, UNSPEC_VCVT_HF_S_N, UNSPEC_VCVT_HF_U_N,\n\tUNSPEC_VCVT_SI_S_N, UNSPEC_VCVT_SI_U_N,  UNSPEC_VCVTH_S_N,\n\tUNSPEC_VCVTH_U_N, UNSPEC_VCVTH_S and UNSPEC_VCVTH_U.\n\t(vcvth_op): New.\n\t(fp16_rnd_str): New.\n\t(fp16_rnd_insn): New.\n\t* config/arm/unspecs.md (UNSPEC_VCVT_HF_S_N): New.\n\t(UNSPEC_VCVT_HF_U_N): New.\n\t(UNSPEC_VCVT_SI_S_N): New.\n\t(UNSPEC_VCVT_SI_U_N): New.\n\t(UNSPEC_VCVTH_S): New.\n\t(UNSPEC_VCVTH_U): New.\n\t(UNSPEC_VCVTA_S): New.\n\t(UNSPEC_VCVTA_U): New.\n\t(UNSPEC_VCVTM_S): New.\n\t(UNSPEC_VCVTM_U): New.\n\t(UNSPEC_VCVTN_S): New.\n\t(UNSPEC_VCVTN_U): New.\n\t(UNSPEC_VCVTP_S): New.\n\t(UNSPEC_VCVTP_U): New.\n\t(UNSPEC_VCVTP_S): New.\n\t(UNSPEC_VCVTP_U): New.\n\t(UNSPEC_VRND): New.\n\t(UNSPEC_VRNDA): New.\n\t(UNSPEC_VRNDI): New.\n\t(UNSPEC_VRNDM): New.\n\t(UNSPEC_VRNDN): New.\n\t(UNSPEC_VRNDP): New.\n\t(UNSPEC_VRNDX): New.\n\t* config/arm/vfp.md (<absneg_str>hf2): New.\n\t(neon_vabshf): New.\n\t(neon_v<fp16_rnd_str>hf): New.\n\t(neon_vrndihf): New.\n\t(addhf3): New.\n\t(subhf3): New.\n\t(divhf3): New.\n\t(mulhf3): New.\n\t(*mulsf3neghf_vfp): New.\n\t(*negmulhf3_vfp): New.\n\t(*mulsf3addhf_vfp): New.\n\t(*mulhf3subhf_vfp): New.\n\t(*mulhf3neghfaddhf_vfp): New.\n\t(*mulhf3neghfsubhf_vfp): New.\n\t(fmahf4): New.\n\t(neon_vfmahf): New.\n\t(fmsubhf4_fp16): New.\n\t(neon_vfmshf): New.\n\t(*fnmsubhf4): New.\n\t(*fnmaddhf4): New.\n\t(neon_vsqrthf): New.\n\t(neon_vrsqrtshf): New.\n\t(FCVT): Move to iterators.md.\n\t(FCVTI32typename): Likewise.\n\t(neon_vcvth<sup>hf): New.\n\t(neon_vcvth<sup>si): New.\n\t(neon_vcvth<sup>_nhf_unspec): New.\n\t(neon_vcvth<sup>_nhf): New.\n\t(neon_vcvth<sup>_nsi_unspec): New.\n\t(neon_vcvth<sup>_nsi): New.\n\t(neon_vcvt<vcvth_op>h<sup>si): New.\n\t(neon_<fmaxmin_op>hf): New.\n\ntestsuite/\n2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n\n\t* gcc.target/arm/armv8_2-fp16-arith-1.c: New.\n\t* gcc.target/arm/armv8_2-fp16-conv-1.c: New.\n\nFrom-SVN: r240411", "tree": {"sha": "e6f680494cfbdc51bbc0f76448e0e182a149fef1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6f680494cfbdc51bbc0f76448e0e182a149fef1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d403b8d4e8057e1e271013745992a191db32cacc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d403b8d4e8057e1e271013745992a191db32cacc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d403b8d4e8057e1e271013745992a191db32cacc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d403b8d4e8057e1e271013745992a191db32cacc/comments", "author": null, "committer": null, "parents": [{"sha": "e2080e79bef0826fbfa1953141cdc6e2ab7eb9e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2080e79bef0826fbfa1953141cdc6e2ab7eb9e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2080e79bef0826fbfa1953141cdc6e2ab7eb9e3"}], "stats": {"total": 714, "additions": 708, "deletions": 6}, "files": [{"sha": "73d18cf6ae640585431a7eac05cd42d9b08ea184", "filename": "gcc/ChangeLog", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d403b8d4e8057e1e271013745992a191db32cacc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d403b8d4e8057e1e271013745992a191db32cacc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d403b8d4e8057e1e271013745992a191db32cacc", "patch": "@@ -1,3 +1,81 @@\n+2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n+\n+\t* config/arm/iterators.md (Code iterators): Fix some white-space\n+\tin the comments.\n+\t(GLTE): New.\n+\t(ABSNEG): New\n+\t(FCVT): Moved from vfp.md.\n+\t(VCVT_HF_US_N): New.\n+\t(VCVT_SI_US_N): New.\n+\t(VCVT_HF_US): New.\n+\t(VCVTH_US): New.\n+\t(FP16_RND): New.\n+\t(absneg_str): New.\n+\t(FCVTI32typename): Moved from vfp.md.\n+\t(sup): Add UNSPEC_VCVTA_S, UNSPEC_VCVTA_U, UNSPEC_VCVTM_S,\n+\tUNSPEC_VCVTM_U, UNSPEC_VCVTN_S, UNSPEC_VCVTN_U, UNSPEC_VCVTP_S,\n+\tUNSPEC_VCVTP_U, UNSPEC_VCVT_HF_S_N, UNSPEC_VCVT_HF_U_N,\n+\tUNSPEC_VCVT_SI_S_N, UNSPEC_VCVT_SI_U_N,  UNSPEC_VCVTH_S_N,\n+\tUNSPEC_VCVTH_U_N, UNSPEC_VCVTH_S and UNSPEC_VCVTH_U.\n+\t(vcvth_op): New.\n+\t(fp16_rnd_str): New.\n+\t(fp16_rnd_insn): New.\n+\t* config/arm/unspecs.md (UNSPEC_VCVT_HF_S_N): New.\n+\t(UNSPEC_VCVT_HF_U_N): New.\n+\t(UNSPEC_VCVT_SI_S_N): New.\n+\t(UNSPEC_VCVT_SI_U_N): New.\n+\t(UNSPEC_VCVTH_S): New.\n+\t(UNSPEC_VCVTH_U): New.\n+\t(UNSPEC_VCVTA_S): New.\n+\t(UNSPEC_VCVTA_U): New.\n+\t(UNSPEC_VCVTM_S): New.\n+\t(UNSPEC_VCVTM_U): New.\n+\t(UNSPEC_VCVTN_S): New.\n+\t(UNSPEC_VCVTN_U): New.\n+\t(UNSPEC_VCVTP_S): New.\n+\t(UNSPEC_VCVTP_U): New.\n+\t(UNSPEC_VCVTP_S): New.\n+\t(UNSPEC_VCVTP_U): New.\n+\t(UNSPEC_VRND): New.\n+\t(UNSPEC_VRNDA): New.\n+\t(UNSPEC_VRNDI): New.\n+\t(UNSPEC_VRNDM): New.\n+\t(UNSPEC_VRNDN): New.\n+\t(UNSPEC_VRNDP): New.\n+\t(UNSPEC_VRNDX): New.\n+\t* config/arm/vfp.md (<absneg_str>hf2): New.\n+\t(neon_vabshf): New.\n+\t(neon_v<fp16_rnd_str>hf): New.\n+\t(neon_vrndihf): New.\n+\t(addhf3): New.\n+\t(subhf3): New.\n+\t(divhf3): New.\n+\t(mulhf3): New.\n+\t(*mulsf3neghf_vfp): New.\n+\t(*negmulhf3_vfp): New.\n+\t(*mulsf3addhf_vfp): New.\n+\t(*mulhf3subhf_vfp): New.\n+\t(*mulhf3neghfaddhf_vfp): New.\n+\t(*mulhf3neghfsubhf_vfp): New.\n+\t(fmahf4): New.\n+\t(neon_vfmahf): New.\n+\t(fmsubhf4_fp16): New.\n+\t(neon_vfmshf): New.\n+\t(*fnmsubhf4): New.\n+\t(*fnmaddhf4): New.\n+\t(neon_vsqrthf): New.\n+\t(neon_vrsqrtshf): New.\n+\t(FCVT): Move to iterators.md.\n+\t(FCVTI32typename): Likewise.\n+\t(neon_vcvth<sup>hf): New.\n+\t(neon_vcvth<sup>si): New.\n+\t(neon_vcvth<sup>_nhf_unspec): New.\n+\t(neon_vcvth<sup>_nhf): New.\n+\t(neon_vcvth<sup>_nsi_unspec): New.\n+\t(neon_vcvth<sup>_nsi): New.\n+\t(neon_vcvt<vcvth_op>h<sup>si): New.\n+\t(neon_<fmaxmin_op>hf): New.\n+\n 2016-09-23  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n \n \t* config/s390/s390.md (bitoff, bitoff_plus): Neq mode attributes."}, {"sha": "9371b6a97df48253eb71ceef78fcba6736072cc9", "filename": "gcc/config/arm/iterators.md", "status": "modified", "additions": 56, "deletions": 3, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d403b8d4e8057e1e271013745992a191db32cacc/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d403b8d4e8057e1e271013745992a191db32cacc/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=d403b8d4e8057e1e271013745992a191db32cacc", "patch": "@@ -199,14 +199,17 @@\n ;; Code iterators\n ;;----------------------------------------------------------------------------\n \n-;; A list of condition codes used in compare instructions where \n-;; the carry flag from the addition is used instead of doing the \n+;; A list of condition codes used in compare instructions where\n+;; the carry flag from the addition is used instead of doing the\n ;; compare a second time.\n (define_code_iterator LTUGEU [ltu geu])\n \n ;; The signed gt, ge comparisons\n (define_code_iterator GTGE [gt ge])\n \n+;; The signed gt, ge, lt, le comparisons\n+(define_code_iterator GLTE [gt ge lt le])\n+\n ;; The unsigned gt, ge comparisons\n (define_code_iterator GTUGEU [gtu geu])\n \n@@ -235,6 +238,12 @@\n ;; Binary operators whose second operand can be shifted.\n (define_code_iterator SHIFTABLE_OPS [plus minus ior xor and])\n \n+;; Operations on the sign of a number.\n+(define_code_iterator ABSNEG [abs neg])\n+\n+;; Conversions.\n+(define_code_iterator FCVT [unsigned_float float])\n+\n ;; plus and minus are the only SHIFTABLE_OPS for which Thumb2 allows\n ;; a stack pointer opoerand.  The minus operation is a candidate for an rsub\n ;; and hence only plus is supported.\n@@ -330,6 +339,22 @@\n \n (define_int_iterator VCVT_US_N [UNSPEC_VCVT_S_N UNSPEC_VCVT_U_N])\n \n+(define_int_iterator VCVT_HF_US_N [UNSPEC_VCVT_HF_S_N UNSPEC_VCVT_HF_U_N])\n+\n+(define_int_iterator VCVT_SI_US_N [UNSPEC_VCVT_SI_S_N UNSPEC_VCVT_SI_U_N])\n+\n+(define_int_iterator VCVT_HF_US [UNSPEC_VCVTA_S UNSPEC_VCVTA_U\n+\t\t\t\t UNSPEC_VCVTM_S UNSPEC_VCVTM_U\n+\t\t\t\t UNSPEC_VCVTN_S UNSPEC_VCVTN_U\n+\t\t\t\t UNSPEC_VCVTP_S UNSPEC_VCVTP_U])\n+\n+(define_int_iterator VCVTH_US [UNSPEC_VCVTH_S UNSPEC_VCVTH_U])\n+\n+;; Operators for FP16 instructions.\n+(define_int_iterator FP16_RND [UNSPEC_VRND UNSPEC_VRNDA\n+\t\t\t       UNSPEC_VRNDM UNSPEC_VRNDN\n+\t\t\t       UNSPEC_VRNDP UNSPEC_VRNDX])\n+\n (define_int_iterator VQMOVN [UNSPEC_VQMOVN_S UNSPEC_VQMOVN_U])\n \n (define_int_iterator VMOVL [UNSPEC_VMOVL_S UNSPEC_VMOVL_U])\n@@ -687,6 +712,12 @@\n (define_code_attr shift [(ashiftrt \"ashr\") (lshiftrt \"lshr\")])\n (define_code_attr shifttype [(ashiftrt \"signed\") (lshiftrt \"unsigned\")])\n \n+;; String reprentations of operations on the sign of a number.\n+(define_code_attr absneg_str [(abs \"abs\") (neg \"neg\")])\n+\n+;; Conversions.\n+(define_code_attr FCVTI32typename [(unsigned_float \"u32\") (float \"s32\")])\n+\n ;;----------------------------------------------------------------------------\n ;; Int attributes\n ;;----------------------------------------------------------------------------\n@@ -718,7 +749,13 @@\n   (UNSPEC_VPMAX \"s\") (UNSPEC_VPMAX_U \"u\")\n   (UNSPEC_VPMIN \"s\") (UNSPEC_VPMIN_U \"u\")\n   (UNSPEC_VCVT_S \"s\") (UNSPEC_VCVT_U \"u\")\n+  (UNSPEC_VCVTA_S \"s\") (UNSPEC_VCVTA_U \"u\")\n+  (UNSPEC_VCVTM_S \"s\") (UNSPEC_VCVTM_U \"u\")\n+  (UNSPEC_VCVTN_S \"s\") (UNSPEC_VCVTN_U \"u\")\n+  (UNSPEC_VCVTP_S \"s\") (UNSPEC_VCVTP_U \"u\")\n   (UNSPEC_VCVT_S_N \"s\") (UNSPEC_VCVT_U_N \"u\")\n+  (UNSPEC_VCVT_HF_S_N \"s\") (UNSPEC_VCVT_HF_U_N \"u\")\n+  (UNSPEC_VCVT_SI_S_N \"s\") (UNSPEC_VCVT_SI_U_N \"u\")\n   (UNSPEC_VQMOVN_S \"s\") (UNSPEC_VQMOVN_U \"u\")\n   (UNSPEC_VMOVL_S \"s\") (UNSPEC_VMOVL_U \"u\")\n   (UNSPEC_VSHL_S \"s\") (UNSPEC_VSHL_U \"u\")\n@@ -733,9 +770,25 @@\n   (UNSPEC_VSHLL_S_N \"s\") (UNSPEC_VSHLL_U_N \"u\")\n   (UNSPEC_VSRA_S_N \"s\") (UNSPEC_VSRA_U_N \"u\")\n   (UNSPEC_VRSRA_S_N \"s\") (UNSPEC_VRSRA_U_N \"u\")\n-\n+  (UNSPEC_VCVTH_S \"s\") (UNSPEC_VCVTH_U \"u\")\n ])\n \n+(define_int_attr vcvth_op\n+ [(UNSPEC_VCVTA_S \"a\") (UNSPEC_VCVTA_U \"a\")\n+  (UNSPEC_VCVTM_S \"m\") (UNSPEC_VCVTM_U \"m\")\n+  (UNSPEC_VCVTN_S \"n\") (UNSPEC_VCVTN_U \"n\")\n+  (UNSPEC_VCVTP_S \"p\") (UNSPEC_VCVTP_U \"p\")])\n+\n+(define_int_attr fp16_rnd_str\n+  [(UNSPEC_VRND \"rnd\") (UNSPEC_VRNDA \"rnda\")\n+   (UNSPEC_VRNDM \"rndm\") (UNSPEC_VRNDN \"rndn\")\n+   (UNSPEC_VRNDP \"rndp\") (UNSPEC_VRNDX \"rndx\")])\n+\n+(define_int_attr fp16_rnd_insn\n+  [(UNSPEC_VRND \"vrintz\") (UNSPEC_VRNDA \"vrinta\")\n+   (UNSPEC_VRNDM \"vrintm\") (UNSPEC_VRNDN \"vrintn\")\n+   (UNSPEC_VRNDP \"vrintp\") (UNSPEC_VRNDX \"vrintx\")])\n+\n (define_int_attr cmp_op_unsp [(UNSPEC_VCEQ \"eq\") (UNSPEC_VCGT \"gt\")\n                               (UNSPEC_VCGE \"ge\") (UNSPEC_VCLE \"le\")\n                               (UNSPEC_VCLT \"lt\") (UNSPEC_VCAGE \"ge\")"}, {"sha": "57a47ff2b781555b8d70fdecd8696ff2a35a330a", "filename": "gcc/config/arm/unspecs.md", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d403b8d4e8057e1e271013745992a191db32cacc/gcc%2Fconfig%2Farm%2Funspecs.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d403b8d4e8057e1e271013745992a191db32cacc/gcc%2Fconfig%2Farm%2Funspecs.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funspecs.md?ref=d403b8d4e8057e1e271013745992a191db32cacc", "patch": "@@ -203,6 +203,20 @@\n   UNSPEC_VCVT_U\n   UNSPEC_VCVT_S_N\n   UNSPEC_VCVT_U_N\n+  UNSPEC_VCVT_HF_S_N\n+  UNSPEC_VCVT_HF_U_N\n+  UNSPEC_VCVT_SI_S_N\n+  UNSPEC_VCVT_SI_U_N\n+  UNSPEC_VCVTH_S\n+  UNSPEC_VCVTH_U\n+  UNSPEC_VCVTA_S\n+  UNSPEC_VCVTA_U\n+  UNSPEC_VCVTM_S\n+  UNSPEC_VCVTM_U\n+  UNSPEC_VCVTN_S\n+  UNSPEC_VCVTN_U\n+  UNSPEC_VCVTP_S\n+  UNSPEC_VCVTP_U\n   UNSPEC_VEXT\n   UNSPEC_VHADD_S\n   UNSPEC_VHADD_U\n@@ -365,5 +379,12 @@\n   UNSPEC_NVRINTN\n   UNSPEC_VQRDMLAH\n   UNSPEC_VQRDMLSH\n+  UNSPEC_VRND\n+  UNSPEC_VRNDA\n+  UNSPEC_VRNDI\n+  UNSPEC_VRNDM\n+  UNSPEC_VRNDN\n+  UNSPEC_VRNDP\n+  UNSPEC_VRNDX\n ])\n "}, {"sha": "5d22c341313cb0d96e66e85265f9b8f5faae24a3", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 379, "deletions": 3, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d403b8d4e8057e1e271013745992a191db32cacc/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d403b8d4e8057e1e271013745992a191db32cacc/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=d403b8d4e8057e1e271013745992a191db32cacc", "patch": "@@ -937,9 +937,63 @@\n    (set_attr \"type\" \"ffarithd\")]\n )\n \n+;; ABS and NEG for FP16.\n+(define_insn \"<absneg_str>hf2\"\n+  [(set (match_operand:HF 0 \"s_register_operand\" \"=w\")\n+    (ABSNEG:HF (match_operand:HF 1 \"s_register_operand\" \"w\")))]\n+ \"TARGET_VFP_FP16INST\"\n+ \"v<absneg_str>.f16\\t%0, %1\"\n+  [(set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"ffariths\")]\n+)\n+\n+(define_expand \"neon_vabshf\"\n+ [(set\n+   (match_operand:HF 0 \"s_register_operand\")\n+   (abs:HF (match_operand:HF 1 \"s_register_operand\")))]\n+ \"TARGET_VFP_FP16INST\"\n+{\n+  emit_insn (gen_abshf2 (operands[0], operands[1]));\n+  DONE;\n+})\n+\n+;; VRND for FP16.\n+(define_insn \"neon_v<fp16_rnd_str>hf\"\n+  [(set (match_operand:HF 0 \"s_register_operand\" \"=w\")\n+    (unspec:HF\n+     [(match_operand:HF 1 \"s_register_operand\" \"w\")]\n+     FP16_RND))]\n+ \"TARGET_VFP_FP16INST\"\n+ \"<fp16_rnd_insn>.f16\\t%0, %1\"\n+ [(set_attr \"conds\" \"unconditional\")\n+  (set_attr \"type\" \"neon_fp_round_s\")]\n+)\n+\n+(define_insn \"neon_vrndihf\"\n+  [(set (match_operand:HF 0 \"s_register_operand\" \"=w\")\n+    (unspec:HF\n+     [(match_operand:HF 1 \"s_register_operand\" \"w\")]\n+     UNSPEC_VRNDI))]\n+  \"TARGET_VFP_FP16INST\"\n+  \"vrintr.f16\\t%0, %1\"\n+ [(set_attr \"conds\" \"unconditional\")\n+  (set_attr \"type\" \"neon_fp_round_s\")]\n+)\n \n ;; Arithmetic insns\n \n+(define_insn \"addhf3\"\n+  [(set\n+    (match_operand:HF 0 \"s_register_operand\" \"=w\")\n+    (plus:HF\n+     (match_operand:HF 1 \"s_register_operand\" \"w\")\n+     (match_operand:HF 2 \"s_register_operand\" \"w\")))]\n+ \"TARGET_VFP_FP16INST\"\n+ \"vadd.f16\\t%0, %1, %2\"\n+  [(set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"fadds\")]\n+)\n+\n (define_insn \"*addsf3_vfp\"\n   [(set (match_operand:SF\t   0 \"s_register_operand\" \"=t\")\n \t(plus:SF (match_operand:SF 1 \"s_register_operand\" \"t\")\n@@ -962,6 +1016,17 @@\n    (set_attr \"type\" \"faddd\")]\n )\n \n+(define_insn \"subhf3\"\n+ [(set\n+   (match_operand:HF 0 \"s_register_operand\" \"=w\")\n+   (minus:HF\n+    (match_operand:HF 1 \"s_register_operand\" \"w\")\n+    (match_operand:HF 2 \"s_register_operand\" \"w\")))]\n+ \"TARGET_VFP_FP16INST\"\n+ \"vsub.f16\\t%0, %1, %2\"\n+  [(set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"fadds\")]\n+)\n \n (define_insn \"*subsf3_vfp\"\n   [(set (match_operand:SF\t    0 \"s_register_operand\" \"=t\")\n@@ -988,6 +1053,19 @@\n \n ;; Division insns\n \n+;; FP16 Division.\n+(define_insn \"divhf3\"\n+  [(set\n+    (match_operand:HF\t   0 \"s_register_operand\" \"=w\")\n+    (div:HF\n+     (match_operand:HF 1 \"s_register_operand\" \"w\")\n+     (match_operand:HF 2 \"s_register_operand\" \"w\")))]\n+  \"TARGET_VFP_FP16INST\"\n+  \"vdiv.f16\\t%0, %1, %2\"\n+  [(set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"fdivs\")]\n+)\n+\n ; VFP9 Erratum 760019: It's potentially unsafe to overwrite the input\n ; operands, so mark the output as early clobber for VFPv2 on ARMv5 or\n ; earlier.\n@@ -1018,6 +1096,17 @@\n \n ;; Multiplication insns\n \n+(define_insn \"mulhf3\"\n+ [(set\n+   (match_operand:HF 0 \"s_register_operand\" \"=w\")\n+   (mult:HF (match_operand:HF 1 \"s_register_operand\" \"w\")\n+\t    (match_operand:HF 2 \"s_register_operand\" \"w\")))]\n+  \"TARGET_VFP_FP16INST\"\n+  \"vmul.f16\\t%0, %1, %2\"\n+  [(set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"fmuls\")]\n+)\n+\n (define_insn \"*mulsf3_vfp\"\n   [(set (match_operand:SF\t   0 \"s_register_operand\" \"=t\")\n \t(mult:SF (match_operand:SF 1 \"s_register_operand\" \"t\")\n@@ -1040,6 +1129,26 @@\n    (set_attr \"type\" \"fmuld\")]\n )\n \n+(define_insn \"*mulsf3neghf_vfp\"\n+  [(set (match_operand:HF\t\t   0 \"s_register_operand\" \"=t\")\n+\t(mult:HF (neg:HF (match_operand:HF 1 \"s_register_operand\" \"t\"))\n+\t\t (match_operand:HF\t   2 \"s_register_operand\" \"t\")))]\n+  \"TARGET_VFP_FP16INST && !flag_rounding_math\"\n+  \"vnmul.f16\\\\t%0, %1, %2\"\n+  [(set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"fmuls\")]\n+)\n+\n+(define_insn \"*negmulhf3_vfp\"\n+  [(set (match_operand:HF\t\t   0 \"s_register_operand\" \"=t\")\n+\t(neg:HF (mult:HF (match_operand:HF 1 \"s_register_operand\" \"t\")\n+\t\t (match_operand:HF\t   2 \"s_register_operand\" \"t\"))))]\n+  \"TARGET_VFP_FP16INST\"\n+  \"vnmul.f16\\\\t%0, %1, %2\"\n+  [(set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"fmuls\")]\n+)\n+\n (define_insn \"*mulsf3negsf_vfp\"\n   [(set (match_operand:SF\t\t   0 \"s_register_operand\" \"=t\")\n \t(mult:SF (neg:SF (match_operand:SF 1 \"s_register_operand\" \"t\"))\n@@ -1089,6 +1198,18 @@\n ;; Multiply-accumulate insns\n \n ;; 0 = 1 * 2 + 0\n+(define_insn \"*mulsf3addhf_vfp\"\n+ [(set (match_operand:HF 0 \"s_register_operand\" \"=t\")\n+       (plus:HF\n+\t(mult:HF (match_operand:HF 2 \"s_register_operand\" \"t\")\n+\t\t (match_operand:HF 3 \"s_register_operand\" \"t\"))\n+\t(match_operand:HF 1 \"s_register_operand\" \"0\")))]\n+  \"TARGET_VFP_FP16INST\"\n+  \"vmla.f16\\\\t%0, %2, %3\"\n+  [(set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"fmacs\")]\n+)\n+\n (define_insn \"*mulsf3addsf_vfp\"\n   [(set (match_operand:SF\t\t    0 \"s_register_operand\" \"=t\")\n \t(plus:SF (mult:SF (match_operand:SF 2 \"s_register_operand\" \"t\")\n@@ -1114,6 +1235,17 @@\n )\n \n ;; 0 = 1 * 2 - 0\n+(define_insn \"*mulhf3subhf_vfp\"\n+  [(set (match_operand:HF 0 \"s_register_operand\" \"=t\")\n+\t(minus:HF (mult:HF (match_operand:HF 2 \"s_register_operand\" \"t\")\n+\t\t\t   (match_operand:HF 3 \"s_register_operand\" \"t\"))\n+\t\t  (match_operand:HF 1 \"s_register_operand\" \"0\")))]\n+  \"TARGET_VFP_FP16INST\"\n+  \"vnmls.f16\\\\t%0, %2, %3\"\n+  [(set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"fmacs\")]\n+)\n+\n (define_insn \"*mulsf3subsf_vfp\"\n   [(set (match_operand:SF\t\t     0 \"s_register_operand\" \"=t\")\n \t(minus:SF (mult:SF (match_operand:SF 2 \"s_register_operand\" \"t\")\n@@ -1139,6 +1271,17 @@\n )\n \n ;; 0 = -(1 * 2) + 0\n+(define_insn \"*mulhf3neghfaddhf_vfp\"\n+  [(set (match_operand:HF 0 \"s_register_operand\" \"=t\")\n+\t(minus:HF (match_operand:HF 1 \"s_register_operand\" \"0\")\n+\t\t  (mult:HF (match_operand:HF 2 \"s_register_operand\" \"t\")\n+\t\t\t   (match_operand:HF 3 \"s_register_operand\" \"t\"))))]\n+  \"TARGET_VFP_FP16INST\"\n+  \"vmls.f16\\\\t%0, %2, %3\"\n+  [(set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"fmacs\")]\n+)\n+\n (define_insn \"*mulsf3negsfaddsf_vfp\"\n   [(set (match_operand:SF\t\t     0 \"s_register_operand\" \"=t\")\n \t(minus:SF (match_operand:SF\t     1 \"s_register_operand\" \"0\")\n@@ -1165,6 +1308,18 @@\n \n \n ;; 0 = -(1 * 2) - 0\n+(define_insn \"*mulhf3neghfsubhf_vfp\"\n+  [(set (match_operand:HF 0 \"s_register_operand\" \"=t\")\n+\t(minus:HF (mult:HF\n+\t\t   (neg:HF (match_operand:HF 2 \"s_register_operand\" \"t\"))\n+\t\t   (match_operand:HF 3 \"s_register_operand\" \"t\"))\n+\t\t  (match_operand:HF 1 \"s_register_operand\" \"0\")))]\n+  \"TARGET_VFP_FP16INST\"\n+  \"vnmla.f16\\\\t%0, %2, %3\"\n+  [(set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"fmacs\")]\n+)\n+\n (define_insn \"*mulsf3negsfsubsf_vfp\"\n   [(set (match_operand:SF\t\t      0 \"s_register_operand\" \"=t\")\n \t(minus:SF (mult:SF\n@@ -1193,6 +1348,30 @@\n \n ;; Fused-multiply-accumulate\n \n+(define_insn \"fmahf4\"\n+  [(set (match_operand:HF 0 \"register_operand\" \"=w\")\n+    (fma:HF\n+     (match_operand:HF 1 \"register_operand\" \"w\")\n+     (match_operand:HF 2 \"register_operand\" \"w\")\n+     (match_operand:HF 3 \"register_operand\" \"0\")))]\n+ \"TARGET_VFP_FP16INST\"\n+ \"vfma.f16\\\\t%0, %1, %2\"\n+ [(set_attr \"conds\" \"unconditional\")\n+  (set_attr \"type\" \"ffmas\")]\n+)\n+\n+(define_expand \"neon_vfmahf\"\n+  [(match_operand:HF 0 \"s_register_operand\")\n+   (match_operand:HF 1 \"s_register_operand\")\n+   (match_operand:HF 2 \"s_register_operand\")\n+   (match_operand:HF 3 \"s_register_operand\")]\n+  \"TARGET_VFP_FP16INST\"\n+{\n+  emit_insn (gen_fmahf4 (operands[0], operands[2], operands[3],\n+\t\t\t operands[1]));\n+  DONE;\n+})\n+\n (define_insn \"fma<SDF:mode>4\"\n   [(set (match_operand:SDF 0 \"register_operand\" \"=<F_constraint>\")\n         (fma:SDF (match_operand:SDF 1 \"register_operand\" \"<F_constraint>\")\n@@ -1205,6 +1384,30 @@\n    (set_attr \"type\" \"ffma<vfp_type>\")]\n )\n \n+(define_insn \"fmsubhf4_fp16\"\n+ [(set (match_operand:HF 0 \"register_operand\" \"=w\")\n+   (fma:HF\n+    (neg:HF (match_operand:HF 1 \"register_operand\" \"w\"))\n+    (match_operand:HF 2 \"register_operand\" \"w\")\n+    (match_operand:HF 3 \"register_operand\" \"0\")))]\n+ \"TARGET_VFP_FP16INST\"\n+ \"vfms.f16\\\\t%0, %1, %2\"\n+ [(set_attr \"conds\" \"unconditional\")\n+  (set_attr \"type\" \"ffmas\")]\n+)\n+\n+(define_expand \"neon_vfmshf\"\n+  [(match_operand:HF 0 \"s_register_operand\")\n+   (match_operand:HF 1 \"s_register_operand\")\n+   (match_operand:HF 2 \"s_register_operand\")\n+   (match_operand:HF 3 \"s_register_operand\")]\n+  \"TARGET_VFP_FP16INST\"\n+{\n+  emit_insn (gen_fmsubhf4_fp16 (operands[0], operands[2], operands[3],\n+\t\t\t\toperands[1]));\n+  DONE;\n+})\n+\n (define_insn \"*fmsub<SDF:mode>4\"\n   [(set (match_operand:SDF 0 \"register_operand\" \"=<F_constraint>\")\n \t(fma:SDF (neg:SDF (match_operand:SDF 1 \"register_operand\"\n@@ -1218,6 +1421,17 @@\n    (set_attr \"type\" \"ffma<vfp_type>\")]\n )\n \n+(define_insn \"*fnmsubhf4\"\n+  [(set (match_operand:HF 0 \"register_operand\" \"=w\")\n+\t(fma:HF (match_operand:HF 1 \"register_operand\" \"w\")\n+\t\t (match_operand:HF 2 \"register_operand\" \"w\")\n+\t\t (neg:HF (match_operand:HF 3 \"register_operand\" \"0\"))))]\n+  \"TARGET_VFP_FP16INST\"\n+  \"vfnms.f16\\\\t%0, %1, %2\"\n+  [(set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"ffmas\")]\n+)\n+\n (define_insn \"*fnmsub<SDF:mode>4\"\n   [(set (match_operand:SDF 0 \"register_operand\" \"=<F_constraint>\")\n \t(fma:SDF (match_operand:SDF 1 \"register_operand\" \"<F_constraint>\")\n@@ -1230,6 +1444,17 @@\n    (set_attr \"type\" \"ffma<vfp_type>\")]\n )\n \n+(define_insn \"*fnmaddhf4\"\n+  [(set (match_operand:HF 0 \"register_operand\" \"=w\")\n+\t(fma:HF (neg:HF (match_operand:HF 1 \"register_operand\" \"w\"))\n+\t\t (match_operand:HF 2 \"register_operand\" \"w\")\n+\t\t (neg:HF (match_operand:HF 3 \"register_operand\" \"0\"))))]\n+  \"TARGET_VFP_FP16INST\"\n+  \"vfnma.f16\\\\t%0, %1, %2\"\n+  [(set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"ffmas\")]\n+)\n+\n (define_insn \"*fnmadd<SDF:mode>4\"\n   [(set (match_operand:SDF 0 \"register_operand\" \"=<F_constraint>\")\n \t(fma:SDF (neg:SDF (match_operand:SDF 1 \"register_operand\"\n@@ -1372,6 +1597,27 @@\n \n ;; Sqrt insns.\n \n+(define_insn \"neon_vsqrthf\"\n+  [(set (match_operand:HF 0 \"s_register_operand\" \"=w\")\n+\t(sqrt:HF (match_operand:HF 1 \"s_register_operand\" \"w\")))]\n+  \"TARGET_VFP_FP16INST\"\n+  \"vsqrt.f16\\t%0, %1\"\n+  [(set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"fsqrts\")]\n+)\n+\n+(define_insn \"neon_vrsqrtshf\"\n+  [(set\n+    (match_operand:HF 0 \"s_register_operand\" \"=w\")\n+    (unspec:HF [(match_operand:HF 1 \"s_register_operand\" \"w\")\n+\t\t(match_operand:HF 2 \"s_register_operand\" \"w\")]\n+     UNSPEC_VRSQRTS))]\n+ \"TARGET_VFP_FP16INST\"\n+ \"vrsqrts.f16\\t%0, %1, %2\"\n+ [(set_attr \"conds\" \"unconditional\")\n+  (set_attr \"type\" \"fsqrts\")]\n+)\n+\n ; VFP9 Erratum 760019: It's potentially unsafe to overwrite the input\n ; operands, so mark the output as early clobber for VFPv2 on ARMv5 or\n ; earlier.\n@@ -1528,9 +1774,6 @@\n )\n \n ;; Fixed point to floating point conversions.\n-(define_code_iterator FCVT [unsigned_float float])\n-(define_code_attr FCVTI32typename [(unsigned_float \"u32\") (float \"s32\")])\n-\n (define_insn \"*combine_vcvt_f32_<FCVTI32typename>\"\n   [(set (match_operand:SF 0 \"s_register_operand\" \"=t\")\n \t(mult:SF (FCVT:SF (match_operand:SI 1 \"s_register_operand\" \"0\"))\n@@ -1575,6 +1818,125 @@\n    (set_attr \"type\" \"f_cvtf2i\")]\n  )\n \n+;; FP16 conversions.\n+(define_insn \"neon_vcvth<sup>hf\"\n+ [(set (match_operand:HF 0 \"s_register_operand\" \"=w\")\n+   (unspec:HF\n+    [(match_operand:SI 1 \"s_register_operand\" \"w\")]\n+    VCVTH_US))]\n+ \"TARGET_VFP_FP16INST\"\n+ \"vcvt.f16.<sup>%#32\\t%0, %1\"\n+ [(set_attr \"conds\" \"unconditional\")\n+  (set_attr \"type\" \"f_cvti2f\")]\n+)\n+\n+(define_insn \"neon_vcvth<sup>si\"\n+ [(set (match_operand:SI 0 \"s_register_operand\" \"=w\")\n+   (unspec:SI\n+    [(match_operand:HF 1 \"s_register_operand\" \"w\")]\n+    VCVTH_US))]\n+ \"TARGET_VFP_FP16INST\"\n+ \"vcvt.<sup>%#32.f16\\t%0, %1\"\n+ [(set_attr \"conds\" \"unconditional\")\n+  (set_attr \"type\" \"f_cvtf2i\")]\n+)\n+\n+;; The neon_vcvth<sup>_nhf patterns are used to generate the instruction for the\n+;; vcvth_n_f16_<sup>32 arm_fp16 intrinsics.  They are complicated by the\n+;; hardware requirement that the source and destination registers are the same\n+;; despite having different machine modes.  The approach is to use a temporary\n+;; register for the conversion and move that to the correct destination.\n+\n+;; Generate an unspec pattern for the intrinsic.\n+(define_insn \"neon_vcvth<sup>_nhf_unspec\"\n+ [(set\n+   (match_operand:SI 0 \"s_register_operand\" \"=w\")\n+   (unspec:SI\n+    [(match_operand:SI 1 \"s_register_operand\" \"0\")\n+     (match_operand:SI 2 \"immediate_operand\" \"i\")]\n+    VCVT_HF_US_N))\n+ (set\n+  (match_operand:HF 3 \"s_register_operand\" \"=w\")\n+  (float_truncate:HF (float:SF (match_dup 0))))]\n+ \"TARGET_VFP_FP16INST\"\n+{\n+  neon_const_bounds (operands[2], 1, 33);\n+  return \"vcvt.f16.<sup>32\\t%0, %0, %2\\;vmov.f32\\t%3, %0\";\n+}\n+  [(set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"f_cvti2f\")]\n+)\n+\n+;; Generate the instruction patterns needed for vcvth_n_f16_s32 neon intrinsics.\n+(define_expand \"neon_vcvth<sup>_nhf\"\n+ [(match_operand:HF 0 \"s_register_operand\")\n+  (unspec:HF [(match_operand:SI 1 \"s_register_operand\")\n+\t      (match_operand:SI 2 \"immediate_operand\")]\n+   VCVT_HF_US_N)]\n+\"TARGET_VFP_FP16INST\"\n+{\n+  rtx op1 = gen_reg_rtx (SImode);\n+\n+  neon_const_bounds (operands[2], 1, 33);\n+\n+  emit_move_insn (op1, operands[1]);\n+  emit_insn (gen_neon_vcvth<sup>_nhf_unspec (op1, op1, operands[2],\n+\t\t\t\t\t     operands[0]));\n+  DONE;\n+})\n+\n+;; The neon_vcvth<sup>_nsi patterns are used to generate the instruction for the\n+;; vcvth_n_<sup>32_f16 arm_fp16 intrinsics.  They have the same restrictions and\n+;; are implemented in the same way as the neon_vcvth<sup>_nhf patterns.\n+\n+;; Generate an unspec pattern, constraining the registers.\n+(define_insn \"neon_vcvth<sup>_nsi_unspec\"\n+ [(set (match_operand:SI 0 \"s_register_operand\" \"=w\")\n+   (unspec:SI\n+    [(fix:SI\n+      (fix:SF\n+       (float_extend:SF\n+\t(match_operand:HF 1 \"s_register_operand\" \"w\"))))\n+     (match_operand:SI 2 \"immediate_operand\" \"i\")]\n+    VCVT_SI_US_N))]\n+ \"TARGET_VFP_FP16INST\"\n+{\n+  neon_const_bounds (operands[2], 1, 33);\n+  return \"vmov.f32\\t%0, %1\\;vcvt.<sup>%#32.f16\\t%0, %0, %2\";\n+}\n+  [(set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"f_cvtf2i\")]\n+)\n+\n+;; Generate the instruction patterns needed for vcvth_n_f16_s32 neon intrinsics.\n+(define_expand \"neon_vcvth<sup>_nsi\"\n+ [(match_operand:SI 0 \"s_register_operand\")\n+  (unspec:SI\n+   [(match_operand:HF 1 \"s_register_operand\")\n+    (match_operand:SI 2 \"immediate_operand\")]\n+   VCVT_SI_US_N)]\n+ \"TARGET_VFP_FP16INST\"\n+{\n+  rtx op1 = gen_reg_rtx (SImode);\n+\n+  neon_const_bounds (operands[2], 1, 33);\n+  emit_insn (gen_neon_vcvth<sup>_nsi_unspec (op1, operands[1], operands[2]));\n+  emit_move_insn (operands[0], op1);\n+  DONE;\n+})\n+\n+(define_insn \"neon_vcvt<vcvth_op>h<sup>si\"\n+ [(set\n+   (match_operand:SI 0 \"s_register_operand\" \"=w\")\n+   (unspec:SI\n+    [(match_operand:HF 1 \"s_register_operand\" \"w\")]\n+    VCVT_HF_US))]\n+ \"TARGET_VFP_FP16INST\"\n+ \"vcvt<vcvth_op>.<sup>%#32.f16\\t%0, %1\"\n+  [(set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"f_cvtf2i\")]\n+)\n+\n ;; Store multiple insn used in function prologue.\n (define_insn \"*push_multi_vfp\"\n   [(match_parallel 2 \"multi_register_push\"\n@@ -1644,6 +2006,20 @@\n )\n \n ;; Scalar forms for the IEEE-754 fmax()/fmin() functions\n+\n+(define_insn \"neon_<fmaxmin_op>hf\"\n+ [(set\n+   (match_operand:HF 0 \"s_register_operand\" \"=w\")\n+   (unspec:HF\n+    [(match_operand:HF 1 \"s_register_operand\" \"w\")\n+     (match_operand:HF 2 \"s_register_operand\" \"w\")]\n+    VMAXMINFNM))]\n+ \"TARGET_VFP_FP16INST\"\n+ \"<fmaxmin_op>.f16\\t%0, %1, %2\"\n+ [(set_attr \"conds\" \"unconditional\")\n+  (set_attr \"type\" \"f_minmaxs\")]\n+)\n+\n (define_insn \"<fmaxmin><mode>3\"\n   [(set (match_operand:SDF 0 \"s_register_operand\" \"=<F_constraint>\")\n \t(unspec:SDF [(match_operand:SDF 1 \"s_register_operand\" \"<F_constraint>\")"}, {"sha": "585458fcf1f2cc1e1a0e7178f412cf73f33123b1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d403b8d4e8057e1e271013745992a191db32cacc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d403b8d4e8057e1e271013745992a191db32cacc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d403b8d4e8057e1e271013745992a191db32cacc", "patch": "@@ -1,3 +1,8 @@\n+2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n+\n+\t* gcc.target/arm/armv8_2-fp16-arith-1.c: New.\n+\t* gcc.target/arm/armv8_2-fp16-conv-1.c: New.\n+\n 2016-09-23  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n \n \t* gcc.target/s390/md/rXsbg_mode_sXl.c: Adapt expected assembly"}, {"sha": "e7da3fcb1ae1a0bc734d8f8c3138a26413fd09f4", "filename": "gcc/testsuite/gcc.target/arm/armv8_2-fp16-arith-1.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d403b8d4e8057e1e271013745992a191db32cacc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_2-fp16-arith-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d403b8d4e8057e1e271013745992a191db32cacc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_2-fp16-arith-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_2-fp16-arith-1.c?ref=d403b8d4e8057e1e271013745992a191db32cacc", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-do compile }  */\n+/* { dg-require-effective-target arm_v8_2a_fp16_scalar_ok }  */\n+/* { dg-options \"-O2 -ffast-math\" }  */\n+/* { dg-add-options arm_v8_2a_fp16_scalar }  */\n+\n+/* Test instructions generated for half-precision arithmetic.  */\n+\n+typedef __fp16 float16_t;\n+typedef __simd64_float16_t float16x4_t;\n+typedef __simd128_float16_t float16x8_t;\n+\n+float16_t\n+fp16_abs (float16_t a)\n+{\n+  return (a < 0) ? -a : a;\n+}\n+\n+#define TEST_UNOP(NAME, OPERATOR, TY)\t\t\\\n+  TY test_##NAME##_##TY (TY a)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return OPERATOR (a);\t\t\t\\\n+  }\n+\n+#define TEST_BINOP(NAME, OPERATOR, TY)\t\t\\\n+  TY test_##NAME##_##TY (TY a, TY b)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return a OPERATOR b;\t\t\t\\\n+  }\n+\n+#define TEST_CMP(NAME, OPERATOR, RTY, TY)\t\\\n+  RTY test_##NAME##_##TY (TY a, TY b)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return a OPERATOR b;\t\t\t\\\n+  }\n+\n+/* Scalars.  */\n+\n+TEST_UNOP (neg, -, float16_t)\n+TEST_UNOP (abs, fp16_abs, float16_t)\n+\n+TEST_BINOP (add, +, float16_t)\n+TEST_BINOP (sub, -, float16_t)\n+TEST_BINOP (mult, *, float16_t)\n+TEST_BINOP (div, /, float16_t)\n+\n+TEST_CMP (equal, ==, int, float16_t)\n+TEST_CMP (unequal, !=, int, float16_t)\n+TEST_CMP (lessthan, <, int, float16_t)\n+TEST_CMP (greaterthan, >, int, float16_t)\n+TEST_CMP (lessthanequal, <=, int, float16_t)\n+TEST_CMP (greaterthanqual, >=, int, float16_t)\n+\n+/* { dg-final { scan-assembler-times {vneg\\.f16\\ts[0-9]+, s[0-9]+} 1 } }  */\n+/* { dg-final { scan-assembler-times {vabs\\.f16\\ts[0-9]+, s[0-9]+} 2 } }  */\n+\n+/* { dg-final { scan-assembler-times {vadd\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 1 } }  */\n+/* { dg-final { scan-assembler-times {vsub\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 1 } }  */\n+/* { dg-final { scan-assembler-times {vmul\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 1 } }  */\n+/* { dg-final { scan-assembler-times {vdiv\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 1 } }  */\n+/* { dg-final { scan-assembler-times {vcmp\\.f32\\ts[0-9]+, s[0-9]+} 2 } }  */\n+/* { dg-final { scan-assembler-times {vcmpe\\.f32\\ts[0-9]+, s[0-9]+} 4 } }  */\n+\n+/* { dg-final { scan-assembler-not {vadd\\.f32} } }  */\n+/* { dg-final { scan-assembler-not {vsub\\.f32} } }  */\n+/* { dg-final { scan-assembler-not {vmul\\.f32} } }  */\n+/* { dg-final { scan-assembler-not {vdiv\\.f32} } }  */\n+/* { dg-final { scan-assembler-not {vcmp\\.f16} } }  */\n+/* { dg-final { scan-assembler-not {vcmpe\\.f16} } }  */"}, {"sha": "c9639a542ae3e5c145ab999a760eff78800358bc", "filename": "gcc/testsuite/gcc.target/arm/armv8_2-fp16-conv-1.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d403b8d4e8057e1e271013745992a191db32cacc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_2-fp16-conv-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d403b8d4e8057e1e271013745992a191db32cacc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_2-fp16-conv-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_2-fp16-conv-1.c?ref=d403b8d4e8057e1e271013745992a191db32cacc", "patch": "@@ -0,0 +1,101 @@\n+/* { dg-do compile }  */\n+/* { dg-require-effective-target arm_v8_2a_fp16_scalar_ok }  */\n+/* { dg-options \"-O2\" }  */\n+/* { dg-add-options arm_v8_2a_fp16_scalar }  */\n+\n+/* Test ARMv8.2 FP16 conversions.  */\n+#include <arm_fp16.h>\n+\n+float\n+f16_to_f32 (__fp16 a)\n+{\n+  return (float)a;\n+}\n+\n+float\n+f16_to_pf32 (__fp16* a)\n+{\n+  return (float)*a;\n+}\n+\n+short\n+f16_to_s16 (__fp16 a)\n+{\n+  return (short)a;\n+}\n+\n+short\n+pf16_to_s16 (__fp16* a)\n+{\n+  return (short)*a;\n+}\n+\n+/* { dg-final { scan-assembler-times {vcvtb\\.f32\\.f16\\ts[0-9]+, s[0-9]+} 4 } }  */\n+\n+__fp16\n+f32_to_f16 (float a)\n+{\n+  return (__fp16)a;\n+}\n+\n+void\n+f32_to_pf16 (__fp16* x, float a)\n+{\n+  *x = (__fp16)a;\n+}\n+\n+__fp16\n+s16_to_f16 (short a)\n+{\n+  return (__fp16)a;\n+}\n+\n+void\n+s16_to_pf16 (__fp16* x, short a)\n+{\n+  *x = (__fp16)a;\n+}\n+\n+/* { dg-final { scan-assembler-times {vcvtb\\.f16\\.f32\\ts[0-9]+, s[0-9]+} 4 } }  */\n+\n+float\n+s16_to_f32 (short a)\n+{\n+  return (float)a;\n+}\n+\n+/* { dg-final { scan-assembler-times {vcvt\\.f32\\.s32\\ts[0-9]+, s[0-9]+} 3 } }  */\n+\n+short\n+f32_to_s16 (float a)\n+{\n+  return (short)a;\n+}\n+\n+/* { dg-final { scan-assembler-times {vcvt\\.s32\\.f32\\ts[0-9]+, s[0-9]+} 3 } }  */\n+\n+unsigned short\n+f32_to_u16 (float a)\n+{\n+  return (unsigned short)a;\n+}\n+\n+/* { dg-final { scan-assembler-times {vcvt\\.u32\\.f32\\ts[0-9]+, s[0-9]+} 1 } }  */\n+\n+short\n+f64_to_s16 (double a)\n+{\n+  return (short)a;\n+}\n+\n+/* { dg-final { scan-assembler-times {vcvt\\.s32\\.f64\\ts[0-9]+, d[0-9]+} 1 } }  */\n+\n+unsigned short\n+f64_to_u16 (double a)\n+{\n+  return (unsigned short)a;\n+}\n+\n+/* { dg-final { scan-assembler-times {vcvt\\.s32\\.f64\\ts[0-9]+, d[0-9]+} 1 } }  */\n+\n+"}]}