{"sha": "822eda12605c08abde5e4d3f388f3cd85b198412", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIyZWRhMTI2MDVjMDhhYmRlNWU0ZDNmMzg4ZjNjZDg1YjE5ODQxMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-10-19T08:48:37Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-10-19T08:48:37Z"}, "message": "re PR target/7693 (Typo in i386 mmintrin.h header)\n\n\t* mmintrin.h (__m64): typedef it to v2si.\n\t(_mm_cvtsi32_si64, _mm_cvtsi32_si64_mm_sll_pi16,\n\t_mm_sll_pi32, _mm_sll_pi64, _mm_slli_pi64, _mm_sra_pi16,\n\t_mm_sra_pi32, _mm_srl_pi16, _mm_srl_pi32, _mm_srl_pi64,\n\t_mm_srli_pi64, _mm_and_si64, _mm_andnot_si64,\n\t_mm_or_si64, _mm_xor_si64): Add neccesary casts.\n\t* xmmintrin.h (_mm_setzero_si64): Likewise.\n\n\t* i386.h (ALIGN_MODE_128): Update comment; add missing modes\n\t(SSE_REG_MODE_P, MMX_REG_MODE_P): New macros.\n\n\tPR target/7693\n\tPatch by Shawn Wagner\n\t* mmintrin.h: Replace pi64 by si64.\n\nFrom-SVN: r58306", "tree": {"sha": "f1efd84c5856f54a8dd3c97998f920817860fd09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1efd84c5856f54a8dd3c97998f920817860fd09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/822eda12605c08abde5e4d3f388f3cd85b198412", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/822eda12605c08abde5e4d3f388f3cd85b198412", "html_url": "https://github.com/Rust-GCC/gccrs/commit/822eda12605c08abde5e4d3f388f3cd85b198412", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/822eda12605c08abde5e4d3f388f3cd85b198412/comments", "author": null, "committer": null, "parents": [{"sha": "bf3d8f27d5fb7811e0e1aa798e69d7868d03e3ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf3d8f27d5fb7811e0e1aa798e69d7868d03e3ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf3d8f27d5fb7811e0e1aa798e69d7868d03e3ae"}], "stats": {"total": 79, "additions": 54, "deletions": 25}, "files": [{"sha": "a6552e424f7961a2c78af88f3ed1d7bd7fcc5af9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/822eda12605c08abde5e4d3f388f3cd85b198412/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/822eda12605c08abde5e4d3f388f3cd85b198412/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=822eda12605c08abde5e4d3f388f3cd85b198412", "patch": "@@ -1,3 +1,20 @@\n+Sat Oct 19 10:46:52 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* mmintrin.h (__m64): typedef it to v2si.\n+\t(_mm_cvtsi32_si64, _mm_cvtsi32_si64_mm_sll_pi16,\n+\t_mm_sll_pi32, _mm_sll_pi64, _mm_slli_pi64, _mm_sra_pi16,\n+\t_mm_sra_pi32, _mm_srl_pi16, _mm_srl_pi32, _mm_srl_pi64,\n+\t_mm_srli_pi64, _mm_and_si64, _mm_andnot_si64,\n+\t_mm_or_si64, _mm_xor_si64): Add neccesary casts.\n+\t* xmmintrin.h (_mm_setzero_si64): Likewise.\n+\n+\t* i386.h (ALIGN_MODE_128): Update comment; add missing modes\n+\t(SSE_REG_MODE_P, MMX_REG_MODE_P): New macros.\n+\n+\tPR target/7693\n+\tPatch by Shawn Wagner\n+\t* mmintrin.h: Replace pi64 by si64.\n+\n 2002-10-18  David Edelsohn  <edelsohn@gnu.org>\n \n \t* rs6000.md (movdf_hardfloat32): Order alternatives consistently."}, {"sha": "4c389899c1a450c641b9b7ddc46e003220e2e7c7", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/822eda12605c08abde5e4d3f388f3cd85b198412/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/822eda12605c08abde5e4d3f388f3cd85b198412/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=822eda12605c08abde5e4d3f388f3cd85b198412", "patch": "@@ -730,10 +730,9 @@ extern int x86_prefetch_sse;\n \n #define BIGGEST_ALIGNMENT 128\n \n-/* Decide whether a variable of mode MODE must be 128 bit aligned.  */\n+/* Decide whether a variable of mode MODE should be 128 bit aligned.  */\n #define ALIGN_MODE_128(MODE) \\\n- ((MODE) == XFmode || (MODE) == TFmode || ((MODE) == TImode) \\\n-  || (MODE) == V4SFmode\t|| (MODE) == V4SImode)\n+ ((MODE) == XFmode || (MODE) == TFmode || SSE_REG_MODE_P (MODE))\n \n /* The published ABIs say that doubles should be aligned on word\n    boundaries, so lower the aligment for structure fields unless\n@@ -1007,6 +1006,17 @@ do {\t\t\t\t\t\t\t\t\t\\\n      || (MODE) == CDImode\t\t\t\t\t\t\\\n      || (TARGET_64BIT && ((MODE) == TImode || (MODE) == CTImode)))\n \n+/* Return true for modes passed in SSE registers.  */\n+#define SSE_REG_MODE_P(MODE) \\\n+ ((MODE) == TImode || (MODE) == V16QImode\t\t\t\t\\\n+   || (MODE) == V8HImode || (MODE) == V2DFmode || (MODE) == V2DImode\t\\\n+   || (MODE) == V4SFmode || (MODE) == V4SImode)\n+\n+/* Return true for modes passed in MMX registers.  */\n+#define MMX_REG_MODE_P(MODE) \\\n+ ((MODE) == V8QImode || (MODE) == V4HImode || (MODE) == V2SImode\t\\\n+   || (MODE) == V2SFmode)\n+\n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE)\t\\"}, {"sha": "52e5195fbafbac0250492db7a5618f26afd83cc4", "filename": "gcc/config/i386/mmintrin.h", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/822eda12605c08abde5e4d3f388f3cd85b198412/gcc%2Fconfig%2Fi386%2Fmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/822eda12605c08abde5e4d3f388f3cd85b198412/gcc%2Fconfig%2Fi386%2Fmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmmintrin.h?ref=822eda12605c08abde5e4d3f388f3cd85b198412", "patch": "@@ -34,7 +34,7 @@\n # error \"MMX instruction set not enabled\"\n #else\n /* The data type intended for user use.  */\n-typedef unsigned long long __m64 __attribute__ ((__aligned__ (8)));\n+typedef int __m64 __attribute__ ((__mode__ (__V2SI__)));\n \n /* Internal data types for implementing the intrinsics.  */\n typedef int __v2si __attribute__ ((__mode__ (__V2SI__)));\n@@ -52,14 +52,16 @@ _mm_empty (void)\n static __inline __m64 \n _mm_cvtsi32_si64 (int __i)\n {\n-  return (unsigned int) __i;\n+  long long __tmp = (unsigned int)__i;\n+  return (__m64) __tmp;\n }\n \n /* Convert the lower 32 bits of the __m64 object into an integer.  */\n static __inline int\n _mm_cvtsi64_si32 (__m64 __i)\n {\n-  return __i;\n+  long long __tmp = (long long)__i;\n+  return __tmp;\n }\n \n /* Pack the four 16-bit values from M1 into the lower four 8-bit values of\n@@ -272,7 +274,7 @@ _mm_mullo_pi16 (__m64 __m1, __m64 __m2)\n static __inline __m64\n _mm_sll_pi16 (__m64 __m, __m64 __count)\n {\n-  return (__m64) __builtin_ia32_psllw ((__v4hi)__m, __count);\n+  return (__m64) __builtin_ia32_psllw ((__v4hi)__m, (long long)__count);\n }\n \n static __inline __m64\n@@ -285,7 +287,7 @@ _mm_slli_pi16 (__m64 __m, int __count)\n static __inline __m64\n _mm_sll_pi32 (__m64 __m, __m64 __count)\n {\n-  return (__m64) __builtin_ia32_pslld ((__v2si)__m, __count);\n+  return (__m64) __builtin_ia32_pslld ((__v2si)__m, (long long)__count);\n }\n \n static __inline __m64\n@@ -296,22 +298,22 @@ _mm_slli_pi32 (__m64 __m, int __count)\n \n /* Shift the 64-bit value in M left by COUNT.  */\n static __inline __m64\n-_mm_sll_pi64 (__m64 __m, __m64 __count)\n+_mm_sll_si64 (__m64 __m, __m64 __count)\n {\n-  return (__m64) __builtin_ia32_psllq (__m, __count);\n+  return (__m64) __builtin_ia32_psllq ((long long)__m, (long long)__count);\n }\n \n static __inline __m64\n-_mm_slli_pi64 (__m64 __m, int __count)\n+_mm_slli_si64 (__m64 __m, int __count)\n {\n-  return (__m64) __builtin_ia32_psllq (__m, __count);\n+  return (__m64) __builtin_ia32_psllq ((long long)__m, (long long)__count);\n }\n \n /* Shift four 16-bit values in M right by COUNT; shift in the sign bit.  */\n static __inline __m64\n _mm_sra_pi16 (__m64 __m, __m64 __count)\n {\n-  return (__m64) __builtin_ia32_psraw ((__v4hi)__m, __count);\n+  return (__m64) __builtin_ia32_psraw ((__v4hi)__m, (long long)__count);\n }\n \n static __inline __m64\n@@ -324,7 +326,7 @@ _mm_srai_pi16 (__m64 __m, int __count)\n static __inline __m64\n _mm_sra_pi32 (__m64 __m, __m64 __count)\n {\n-  return (__m64) __builtin_ia32_psrad ((__v2si)__m, __count);\n+  return (__m64) __builtin_ia32_psrad ((__v2si)__m, (long long)__count);\n }\n \n static __inline __m64\n@@ -337,7 +339,7 @@ _mm_srai_pi32 (__m64 __m, int __count)\n static __inline __m64\n _mm_srl_pi16 (__m64 __m, __m64 __count)\n {\n-  return (__m64) __builtin_ia32_psrlw ((__v4hi)__m, __count);\n+  return (__m64) __builtin_ia32_psrlw ((__v4hi)__m, (long long)__count);\n }\n \n static __inline __m64\n@@ -350,7 +352,7 @@ _mm_srli_pi16 (__m64 __m, int __count)\n static __inline __m64\n _mm_srl_pi32 (__m64 __m, __m64 __count)\n {\n-  return (__m64) __builtin_ia32_psrld ((__v2si)__m, __count);\n+  return (__m64) __builtin_ia32_psrld ((__v2si)__m, (long long)__count);\n }\n \n static __inline __m64\n@@ -361,44 +363,44 @@ _mm_srli_pi32 (__m64 __m, int __count)\n \n /* Shift the 64-bit value in M left by COUNT; shift in zeros.  */\n static __inline __m64\n-_mm_srl_pi64 (__m64 __m, __m64 __count)\n+_mm_srl_si64 (__m64 __m, __m64 __count)\n {\n-  return (__m64) __builtin_ia32_psrlq (__m, __count);\n+  return (__m64) __builtin_ia32_psrlq ((long long)__m, (long long)__count);\n }\n \n static __inline __m64\n-_mm_srli_pi64 (__m64 __m, int __count)\n+_mm_srli_si64 (__m64 __m, int __count)\n {\n-  return (__m64) __builtin_ia32_psrlq (__m, __count);\n+  return (__m64) __builtin_ia32_psrlq ((long long)__m, (long long)__count);\n }\n \n /* Bit-wise AND the 64-bit values in M1 and M2.  */\n static __inline __m64\n _mm_and_si64 (__m64 __m1, __m64 __m2)\n {\n-  return __builtin_ia32_pand (__m1, __m2);\n+  return (__m64) __builtin_ia32_pand ((long long)__m1, (long long)__m2);\n }\n \n /* Bit-wise complement the 64-bit value in M1 and bit-wise AND it with the\n    64-bit value in M2.  */\n static __inline __m64\n _mm_andnot_si64 (__m64 __m1, __m64 __m2)\n {\n-  return __builtin_ia32_pandn (__m1, __m2);\n+  return (__m64) __builtin_ia32_pandn ((long long)__m1, (long long)__m2);\n }\n \n /* Bit-wise inclusive OR the 64-bit values in M1 and M2.  */\n static __inline __m64\n _mm_or_si64 (__m64 __m1, __m64 __m2)\n {\n-  return __builtin_ia32_por (__m1, __m2);\n+  return (__m64)__builtin_ia32_por ((long long)__m1, (long long)__m2);\n }\n \n /* Bit-wise exclusive OR the 64-bit values in M1 and M2.  */\n static __inline __m64\n _mm_xor_si64 (__m64 __m1, __m64 __m2)\n {\n-  return __builtin_ia32_pxor (__m1, __m2);\n+  return (__m64)__builtin_ia32_pxor ((long long)__m1, (long long)__m2);\n }\n \n /* Compare eight 8-bit values.  The result of the comparison is 0xFF if the\n@@ -447,7 +449,7 @@ _mm_cmpgt_pi32 (__m64 __m1, __m64 __m2)\n static __inline __m64\n _mm_setzero_si64 (void)\n {\n-  return __builtin_ia32_mmx_zero ();\n+  return (__m64)__builtin_ia32_mmx_zero ();\n }\n \n /* Creates a vector of two 32-bit values; I0 is least significant.  */"}]}