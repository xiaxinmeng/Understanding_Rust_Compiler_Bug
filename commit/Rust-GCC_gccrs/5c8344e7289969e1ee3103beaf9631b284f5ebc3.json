{"sha": "5c8344e7289969e1ee3103beaf9631b284f5ebc3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM4MzQ0ZTcyODk5NjllMWVlMzEwM2JlYWY5NjMxYjI4NGY1ZWJjMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-05-26T08:14:38Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-05-26T08:14:38Z"}, "message": "Simplify types of TYPE_VALUES in enumeral types\n\nstreaming code assumes that INTEGER_CST never appears in non-trivial component.\nThis is not true and we sometimes stream such components which sort of silently\nworks but breaks our IL invariant about tree sharing.  This patch fixes one\ninstance of this problem where ENUMERAL_TYPE lists all its valids in TYPE_VALUES\nthat with some FEs (like Ada and C++) are having the enumeral type as a type\nwhile in other FEs (like C) are simple integer types.\n\nI convert them all to integers which also increases chance that they will be\nshared with other integer constants at stream time.\n\ngcc/\n\n\t* tree.c (free_lang_data_in_type): Simpify types of TYPE_VALUES in\n\tenumeral types.", "tree": {"sha": "c5a1697ecc49aaa82862cb9cd1dca734de44804d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5a1697ecc49aaa82862cb9cd1dca734de44804d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c8344e7289969e1ee3103beaf9631b284f5ebc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c8344e7289969e1ee3103beaf9631b284f5ebc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c8344e7289969e1ee3103beaf9631b284f5ebc3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c8344e7289969e1ee3103beaf9631b284f5ebc3/comments", "author": null, "committer": null, "parents": [{"sha": "f1f862aec2c3b93dbd6adfc35b0e1b6034e59c21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1f862aec2c3b93dbd6adfc35b0e1b6034e59c21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1f862aec2c3b93dbd6adfc35b0e1b6034e59c21"}], "stats": {"total": 24, "additions": 22, "deletions": 2}, "files": [{"sha": "ea6692476e71793e5be2a0d3634c72449d0a1e98", "filename": "gcc/tree.c", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c8344e7289969e1ee3103beaf9631b284f5ebc3/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c8344e7289969e1ee3103beaf9631b284f5ebc3/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=5c8344e7289969e1ee3103beaf9631b284f5ebc3", "patch": "@@ -5556,6 +5556,7 @@ free_lang_data_in_type (tree type, class free_lang_data_d *fld)\n     {\n       if (TREE_CODE (type) == ENUMERAL_TYPE)\n \t{\n+\t  tree it = NULL_TREE;\n \t  ENUM_IS_OPAQUE (type) = 0;\n \t  ENUM_IS_SCOPED (type) = 0;\n \t  /* Type values are used only for C++ ODR checking.  Drop them\n@@ -5568,8 +5569,27 @@ free_lang_data_in_type (tree type, class free_lang_data_d *fld)\n \t  /* Simplify representation by recording only values rather\n \t     than const decls.  */\n \t    for (tree e = TYPE_VALUES (type); e; e = TREE_CHAIN (e))\n-\t      if (TREE_CODE (TREE_VALUE (e)) == CONST_DECL)\n-\t\tTREE_VALUE (e) = DECL_INITIAL (TREE_VALUE (e));\n+\t      {\n+\t\tif (TREE_CODE (TREE_VALUE (e)) == CONST_DECL)\n+\t\t  {\n+\t\t    TREE_VALUE (e) = DECL_INITIAL (TREE_VALUE (e));\n+\t\t    /* We can not stream values whose TREE_TYPE is type itself\n+\t\t       because that would create non-trivial CSS.  Canonicalize\n+\t\t       them to integer types.  */\n+\t\t  }\n+\t\t/* Some frontends use ENUMERAL_TYPE to represent the constants.\n+\t\t   This leads to nontrivial SCC components containing\n+\t\t   INTEGER_CST which is not good for streaming.  Convert them\n+\t\t   all to corresponding integer type.  */\n+\t\tif (TREE_CODE (TREE_TYPE (TREE_VALUE (e))) != INTEGER_TYPE)\n+\t\t  {\n+\t\t    if (!it)\n+\t\t      it = lang_hooks.types.type_for_size\n+\t\t\t       (TYPE_PRECISION (TREE_TYPE (TREE_VALUE (e))),\n+\t\t\t\tTYPE_UNSIGNED (TREE_TYPE (TREE_VALUE (e))));\n+\t\t    TREE_VALUE (e) = fold_convert (it, TREE_VALUE (e));\n+\t\t  }\n+\t       }\n \t}\n       free_lang_data_in_one_sizepos (&TYPE_MIN_VALUE (type));\n       free_lang_data_in_one_sizepos (&TYPE_MAX_VALUE (type));"}]}