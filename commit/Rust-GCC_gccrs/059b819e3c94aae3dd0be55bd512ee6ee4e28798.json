{"sha": "059b819e3c94aae3dd0be55bd512ee6ee4e28798", "node_id": "C_kwDOANBUbNoAKDA1OWI4MTllM2M5NGFhZTNkZDBiZTU1YmQ1MTJlZTZlZTRlMjg3OTg", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-09-22T07:29:13Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-09-22T07:29:13Z"}, "message": "openmp: Add support for allocator and align modifiers on allocate clauses\n\nAs the allocate-2.c testcase shows, this change isn't 100% backwards compatible,\none could have allocate and/or align functions that return an OpenMP allocator\nhandle and previously it would call those functions and now would use those\nnames as keywords for the modifiers.  But it allows specify extra alignment\nrequirements for the allocations.\n\n2021-09-22  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/\n\t* tree.h (OMP_CLAUSE_ALLOCATE_ALIGN): Define.\n\t* tree.c (omp_clause_num_ops): Change number of OMP_CLAUSE_ALLOCATE\n\targuments from 2 to 3.\n\t* tree-pretty-print.c (dump_omp_clause): Print allocator() around\n\tallocate clause allocator and print align if present.\n\t* omp-low.c (scan_sharing_clauses): Force allocate_map entry even\n\tfor omp_default_mem_alloc if align modifier is present.  If align\n\tmodifier is present, use TREE_LIST to encode both allocator and\n\talign.\n\t(lower_private_allocate, lower_rec_input_clauses, create_task_copyfn):\n\tHandle align modifier on allocator clause if present.\ngcc/c-family/\n\t* c-omp.c (c_omp_split_clauses): Copy over OMP_CLAUSE_ALLOCATE_ALIGN.\ngcc/c/\n\t* c-parser.c (c_parser_omp_clause_allocate): Parse allocate clause\n\tmodifiers.\ngcc/cp/\n\t* parser.c (cp_parser_omp_clause_allocate): Parse allocate clause\n\tmodifiers.\n\t* semantics.c (finish_omp_clauses) <OMP_CLAUSE_ALLOCATE>: Perform\n\tsemantic analysis of OMP_CLAUSE_ALLOCATE_ALIGN.\n\t* pt.c (tsubst_omp_clauses) <case OMP_CLAUSE_ALLOCATE>: Handle\n\talso OMP_CLAUSE_ALLOCATE_ALIGN.\ngcc/testsuite/\n\t* c-c++-common/gomp/allocate-6.c: New test.\n\t* c-c++-common/gomp/allocate-7.c: New test.\n\t* g++.dg/gomp/allocate-4.C: New test.\nlibgomp/\n\t* testsuite/libgomp.c-c++-common/allocate-2.c: New test.\n\t* testsuite/libgomp.c-c++-common/allocate-3.c: New test.", "tree": {"sha": "bb8b074085f64d452820b382f51a65c04cf26448", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb8b074085f64d452820b382f51a65c04cf26448"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/059b819e3c94aae3dd0be55bd512ee6ee4e28798", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/059b819e3c94aae3dd0be55bd512ee6ee4e28798", "html_url": "https://github.com/Rust-GCC/gccrs/commit/059b819e3c94aae3dd0be55bd512ee6ee4e28798", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/059b819e3c94aae3dd0be55bd512ee6ee4e28798/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "578b76873383784841f5478573f4ac5d251aa0ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/578b76873383784841f5478573f4ac5d251aa0ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/578b76873383784841f5478573f4ac5d251aa0ba"}], "stats": {"total": 1019, "additions": 986, "deletions": 33}, "files": [{"sha": "1f07a0a454b2a4ebcb0a2a20946105ed3f6413ea", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=059b819e3c94aae3dd0be55bd512ee6ee4e28798", "patch": "@@ -2511,6 +2511,8 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t\t    = OMP_CLAUSE_DECL (clauses);\n \t\t  OMP_CLAUSE_ALLOCATE_ALLOCATOR (c)\n \t\t    = OMP_CLAUSE_ALLOCATE_ALLOCATOR (clauses);\n+\t\t  OMP_CLAUSE_ALLOCATE_ALIGN (c)\n+\t\t    = OMP_CLAUSE_ALLOCATE_ALIGN (clauses);\n \t\t  OMP_CLAUSE_CHAIN (c) = cclauses[s];\n \t\t  cclauses[s] = c;\n \t\t  has_dup_allocate = true;"}, {"sha": "fa29d2c15fc0080d6d3ca50254982717f7bfb27b", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 147, "deletions": 14, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=059b819e3c94aae3dd0be55bd512ee6ee4e28798", "patch": "@@ -15305,14 +15305,23 @@ c_parser_omp_clause_aligned (c_parser *parser, tree list)\n \n /* OpenMP 5.0:\n    allocate ( variable-list )\n-   allocate ( expression : variable-list ) */\n+   allocate ( expression : variable-list )\n+\n+   OpenMP 5.1:\n+   allocate ( allocator-modifier : variable-list )\n+   allocate ( allocator-modifier , allocator-modifier : variable-list )\n+\n+   allocator-modifier:\n+   allocator ( expression )\n+   align ( expression )  */\n \n static tree\n c_parser_omp_clause_allocate (c_parser *parser, tree list)\n {\n   location_t clause_loc = c_parser_peek_token (parser)->location;\n   tree nl, c;\n   tree allocator = NULL_TREE;\n+  tree align = NULL_TREE;\n \n   matching_parens parens;\n   if (!parens.require_open (parser))\n@@ -15323,24 +15332,145 @@ c_parser_omp_clause_allocate (c_parser *parser, tree list)\n       || (c_parser_peek_2nd_token (parser)->type != CPP_COMMA\n \t  && c_parser_peek_2nd_token (parser)->type != CPP_CLOSE_PAREN))\n     {\n-      location_t expr_loc = c_parser_peek_token (parser)->location;\n-      c_expr expr = c_parser_expr_no_commas (parser, NULL);\n-      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n-      allocator = expr.value;\n-      allocator = c_fully_fold (allocator, false, NULL);\n-      tree orig_type\n-\t= expr.original_type ? expr.original_type : TREE_TYPE (allocator);\n-      orig_type = TYPE_MAIN_VARIANT (orig_type);\n-      if (!INTEGRAL_TYPE_P (TREE_TYPE (allocator))\n-\t  || TREE_CODE (orig_type) != ENUMERAL_TYPE\n-\t  || TYPE_NAME (orig_type) != get_identifier (\"omp_allocator_handle_t\"))\n+      bool has_modifiers = false;\n+      tree orig_type = NULL_TREE;\n+      if (c_parser_next_token_is (parser, CPP_NAME)\n+\t  && c_parser_peek_2nd_token (parser)->type == CPP_OPEN_PAREN)\n+\t{\n+\t  unsigned int n = 3;\n+\t  const char *p\n+\t    = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+\t  if ((strcmp (p, \"allocator\") == 0 || strcmp (p, \"align\") == 0)\n+\t      && c_parser_check_balanced_raw_token_sequence (parser, &n)\n+\t      && (c_parser_peek_nth_token_raw (parser, n)->type\n+\t\t  == CPP_CLOSE_PAREN))\n+\t    {\n+\t      if (c_parser_peek_nth_token_raw (parser, n + 1)->type\n+\t\t  == CPP_COLON)\n+\t\thas_modifiers = true;\n+\t      else if (c_parser_peek_nth_token_raw (parser, n + 1)->type\n+\t\t       == CPP_COMMA\n+\t\t       && (c_parser_peek_nth_token_raw (parser, n + 2)->type\n+\t\t\t   == CPP_NAME)\n+\t\t       && (c_parser_peek_nth_token_raw (parser, n + 3)->type\n+\t\t\t   == CPP_OPEN_PAREN))\n+\t\t{\n+\t\t  c_token *tok = c_parser_peek_nth_token_raw (parser, n + 2);\n+\t\t  const char *q = IDENTIFIER_POINTER (tok->value);\n+\t\t  n += 4;\n+\t\t  if ((strcmp (q, \"allocator\") == 0\n+\t\t       || strcmp (q, \"align\") == 0)\n+\t\t      && c_parser_check_balanced_raw_token_sequence (parser,\n+\t\t\t\t\t\t\t\t     &n)\n+\t\t      && (c_parser_peek_nth_token_raw (parser, n)->type\n+\t\t\t  == CPP_CLOSE_PAREN)\n+\t\t      && (c_parser_peek_nth_token_raw (parser, n + 1)->type\n+\t\t\t  == CPP_COLON))\n+\t\t    has_modifiers = true;\n+\t\t}\n+\t    }\n+\t  if (has_modifiers)\n+\t    {\n+\t      c_parser_consume_token (parser);\n+\t      matching_parens parens2;;\n+\t      parens2.require_open (parser);\n+\t      location_t expr_loc = c_parser_peek_token (parser)->location;\n+\t      c_expr expr = c_parser_expr_no_commas (parser, NULL);\n+\t      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+\t      if (strcmp (p, \"allocator\") == 0)\n+\t\t{\n+\t\t  allocator = expr.value;\n+\t\t  allocator = c_fully_fold (allocator, false, NULL);\n+\t\t  orig_type = expr.original_type\n+\t\t\t      ? expr.original_type : TREE_TYPE (allocator);\n+\t\t  orig_type = TYPE_MAIN_VARIANT (orig_type);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  align = expr.value;\n+\t\t  align = c_fully_fold (align, false, NULL);\n+\t\t}\n+\t      parens2.skip_until_found_close (parser);\n+\t      if (c_parser_next_token_is (parser, CPP_COMMA))\n+\t\t{\n+\t\t  c_parser_consume_token (parser);\n+\t\t  c_token *tok = c_parser_peek_token (parser);\n+\t\t  const char *q = \"\";\n+\t\t  if (c_parser_next_token_is (parser, CPP_NAME))\n+\t\t    q = IDENTIFIER_POINTER (tok->value);\n+\t\t  if (strcmp (q, \"allocator\") != 0 && strcmp (q, \"align\") != 0)\n+\t\t    {\n+\t\t      c_parser_error (parser, \"expected %<allocator%> or \"\n+\t\t\t\t\t      \"%<align%>\");\n+\t\t      parens.skip_until_found_close (parser);\n+\t\t      return list;\n+\t\t    }\n+\t\t  else if (strcmp (p, q) == 0)\n+\t\t    {\n+\t\t      error_at (tok->location, \"duplicate %qs modifier\", p);\n+\t\t      parens.skip_until_found_close (parser);\n+\t\t      return list;\n+\t\t    }\n+\t\t  c_parser_consume_token (parser);\n+\t\t  if (!parens2.require_open (parser))\n+\t\t    {\n+\t\t      parens.skip_until_found_close (parser);\n+\t\t      return list;\n+\t\t    }\n+\t\t  expr_loc = c_parser_peek_token (parser)->location;\n+\t\t  expr = c_parser_expr_no_commas (parser, NULL);\n+\t\t  expr = convert_lvalue_to_rvalue (expr_loc, expr, false,\n+\t\t\t\t\t\t   true);\n+\t\t  if (strcmp (q, \"allocator\") == 0)\n+\t\t    {\n+\t\t      allocator = expr.value;\n+\t\t      allocator = c_fully_fold (allocator, false, NULL);\n+\t\t      orig_type = expr.original_type\n+\t\t\t\t  ? expr.original_type : TREE_TYPE (allocator);\n+\t\t      orig_type = TYPE_MAIN_VARIANT (orig_type);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      align = expr.value;\n+\t\t      align = c_fully_fold (align, false, NULL);\n+\t\t    }\n+\t\t  parens2.skip_until_found_close (parser);\n+\t\t}\n+\t    }\n+\t}\n+      if (!has_modifiers)\n+\t{\n+\t  location_t expr_loc = c_parser_peek_token (parser)->location;\n+\t  c_expr expr = c_parser_expr_no_commas (parser, NULL);\n+\t  expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+\t  allocator = expr.value;\n+\t  allocator = c_fully_fold (allocator, false, NULL);\n+\t  orig_type = expr.original_type\n+\t\t      ? expr.original_type : TREE_TYPE (allocator);\n+\t  orig_type = TYPE_MAIN_VARIANT (orig_type);\n+\t}\n+      if (allocator\n+\t  && (!INTEGRAL_TYPE_P (TREE_TYPE (allocator))\n+\t      || TREE_CODE (orig_type) != ENUMERAL_TYPE\n+\t      || (TYPE_NAME (orig_type)\n+\t\t  != get_identifier (\"omp_allocator_handle_t\"))))\n         {\n           error_at (clause_loc, \"%<allocate%> clause allocator expression \"\n \t\t\t\t\"has type %qT rather than \"\n \t\t\t\t\"%<omp_allocator_handle_t%>\",\n \t\t\t\tTREE_TYPE (allocator));\n           allocator = NULL_TREE;\n         }\n+      if (align\n+\t  && (!INTEGRAL_TYPE_P (TREE_TYPE (align))\n+\t      || !tree_fits_uhwi_p (align)\n+\t      || !integer_pow2p (align)))\n+\t{\n+\t  error_at (clause_loc, \"%<allocate%> clause %<align%> modifier \"\n+\t\t\t\t\"argument needs to be positive constant \"\n+\t\t\t\t\"power of two integer expression\");\n+\t  align = NULL_TREE;\n+\t}\n       if (!c_parser_require (parser, CPP_COLON, \"expected %<:%>\"))\n \t{\n \t  parens.skip_until_found_close (parser);\n@@ -15351,9 +15481,12 @@ c_parser_omp_clause_allocate (c_parser *parser, tree list)\n   nl = c_parser_omp_variable_list (parser, clause_loc,\n \t\t\t\t   OMP_CLAUSE_ALLOCATE, list);\n \n-  if (allocator)\n+  if (allocator || align)\n     for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))\n-      OMP_CLAUSE_ALLOCATE_ALLOCATOR (c) = allocator;\n+      {\n+\tOMP_CLAUSE_ALLOCATE_ALLOCATOR (c) = allocator;\n+\tOMP_CLAUSE_ALLOCATE_ALIGN (c) = align;\n+      }\n \n   parens.skip_until_found_close (parser);\n   return nl;"}, {"sha": "26d925c15c5db095f045e3fc9e6d6666fd5ff825", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 65, "deletions": 6, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=059b819e3c94aae3dd0be55bd512ee6ee4e28798", "patch": "@@ -38337,13 +38337,21 @@ cp_parser_omp_clause_aligned (cp_parser *parser, tree list)\n \n /* OpenMP 5.0:\n    allocate ( variable-list )\n-   allocate ( expression : variable-list )  */\n+   allocate ( expression : variable-list )\n+\n+   OpenMP 5.1:\n+   allocate ( allocator-modifier : variable-list )\n+   allocate ( allocator-modifier , allocator-modifier : variable-list )\n+\n+   allocator-modifier:\n+   allocator ( expression )\n+   align ( expression )  */\n \n static tree\n cp_parser_omp_clause_allocate (cp_parser *parser, tree list)\n {\n-  tree nlist, c, allocator = NULL_TREE;\n-  bool colon;\n+  tree nlist, c, allocator = NULL_TREE, align = NULL_TREE;\n+  bool colon, has_modifiers = false;\n \n   matching_parens parens;\n   if (!parens.require_open (parser))\n@@ -38352,26 +38360,77 @@ cp_parser_omp_clause_allocate (cp_parser *parser, tree list)\n   cp_parser_parse_tentatively (parser);\n   bool saved_colon_corrects_to_scope_p = parser->colon_corrects_to_scope_p;\n   parser->colon_corrects_to_scope_p = false;\n-  allocator = cp_parser_assignment_expression (parser);\n+  for (int mod = 0; mod < 2; mod++)\n+    if (cp_lexer_next_token_is (parser->lexer, CPP_NAME)\n+\t&& cp_lexer_nth_token_is (parser->lexer, 2, CPP_OPEN_PAREN))\n+      {\n+\ttree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+\tconst char *p = IDENTIFIER_POINTER (id);\n+\tif (strcmp (p, \"allocator\") != 0 && strcmp (p, \"align\") != 0)\n+\t  break;\n+\tcp_lexer_consume_token (parser->lexer);\n+\tmatching_parens parens2;\n+\tif (!parens2.require_open (parser))\n+\t  break;\n+\tif (strcmp (p, \"allocator\") == 0)\n+\t  {\n+\t    if (allocator != NULL_TREE)\n+\t      break;\n+\t    allocator = cp_parser_assignment_expression (parser);\n+\t  }\n+\telse\n+\t  {\n+\t    if (align != NULL_TREE)\n+\t      break;\n+\t    align = cp_parser_assignment_expression (parser);\n+\t  }\n+\tif (!parens2.require_close (parser))\n+\t  break;\n+\tif (cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n+\t  {\n+\t    has_modifiers = true;\n+\t    break;\n+\t  }\n+\tif (mod != 0 || cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA))\n+\t  break;\n+\tcp_lexer_consume_token (parser->lexer);\n+      }\n+    else\n+      break;\n+  if (!has_modifiers)\n+    {\n+      cp_parser_abort_tentative_parse (parser);\n+      align = NULL_TREE;\n+      allocator = NULL_TREE;\n+      cp_parser_parse_tentatively (parser);\n+      allocator = cp_parser_assignment_expression (parser);\n+    }\n   parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;\n   if (cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n     {\n       cp_parser_parse_definitely (parser);\n       cp_lexer_consume_token (parser->lexer);\n       if (allocator == error_mark_node)\n \tallocator = NULL_TREE;\n+      if (align == error_mark_node)\n+\talign = NULL_TREE;\n     }\n   else\n     {\n       cp_parser_abort_tentative_parse (parser);\n       allocator = NULL_TREE;\n+      align = NULL_TREE;\n     }\n \n   nlist = cp_parser_omp_var_list_no_open (parser, OMP_CLAUSE_ALLOCATE, list,\n \t\t\t\t\t  &colon);\n \n-  for (c = nlist; c != list; c = OMP_CLAUSE_CHAIN (c))\n-    OMP_CLAUSE_ALLOCATE_ALLOCATOR (c) = allocator;\n+  if (allocator || align)\n+    for (c = nlist; c != list; c = OMP_CLAUSE_CHAIN (c))\n+      {\n+\tOMP_CLAUSE_ALLOCATE_ALLOCATOR (c) = allocator;\n+\tOMP_CLAUSE_ALLOCATE_ALIGN (c) = align;\n+      }\n \n   return nlist;\n }"}, {"sha": "28ba32f416c300fd1cdb94b0b75b92af8f9140ca", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=059b819e3c94aae3dd0be55bd512ee6ee4e28798", "patch": "@@ -17489,13 +17489,23 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,\n \t  break;\n \tcase OMP_CLAUSE_GANG:\n \tcase OMP_CLAUSE_ALIGNED:\n+\t  OMP_CLAUSE_DECL (nc)\n+\t    = tsubst_omp_clause_decl (OMP_CLAUSE_DECL (oc), args, complain,\n+\t\t\t\t      in_decl, NULL);\n+\t  OMP_CLAUSE_OPERAND (nc, 1)\n+\t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 1), args, complain,\n+\t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n+\t  break;\n \tcase OMP_CLAUSE_ALLOCATE:\n \t  OMP_CLAUSE_DECL (nc)\n \t    = tsubst_omp_clause_decl (OMP_CLAUSE_DECL (oc), args, complain,\n \t\t\t\t      in_decl, NULL);\n \t  OMP_CLAUSE_OPERAND (nc, 1)\n \t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 1), args, complain,\n \t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n+\t  OMP_CLAUSE_OPERAND (nc, 2)\n+\t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 2), args, complain,\n+\t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n \t  break;\n \tcase OMP_CLAUSE_LINEAR:\n \t  OMP_CLAUSE_DECL (nc)"}, {"sha": "0d8e5fde83403aac9395d2fbcae1e0de9e69cd83", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=059b819e3c94aae3dd0be55bd512ee6ee4e28798", "patch": "@@ -7527,7 +7527,44 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      bitmap_set_bit (&aligned_head, DECL_UID (t));\n \t      allocate_seen = true;\n \t    }\n-\t  tree allocator;\n+\t  tree allocator, align;\n+\t  align = OMP_CLAUSE_ALLOCATE_ALIGN (c);\n+\t  if (error_operand_p (align))\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  if (align)\n+\t    {\n+\t      if (!type_dependent_expression_p (align)\n+\t\t  && !INTEGRAL_TYPE_P (TREE_TYPE (align)))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%<allocate%> clause %<align%> modifier \"\n+\t\t\t    \"argument needs to be positive constant \"\n+\t\t\t    \"power of two integer expression\");\n+\t\t  remove = true;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  align = mark_rvalue_use (align);\n+\t\t  if (!processing_template_decl)\n+\t\t    {\n+\t\t      align = maybe_constant_value (align);\n+\t\t      if (TREE_CODE (align) != INTEGER_CST\n+\t\t\t  || !tree_fits_uhwi_p (align)\n+\t\t\t  || !integer_pow2p (align))\n+\t\t\t{\n+\t\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t    \"%<allocate%> clause %<align%> modifier \"\n+\t\t\t\t    \"argument needs to be positive constant \"\n+\t\t\t\t    \"power of two integer expression\");\n+\t\t\t  remove = true;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      OMP_CLAUSE_ALLOCATE_ALIGN (c) = align;\n+\t    }\n \t  allocator = OMP_CLAUSE_ALLOCATE_ALLOCATOR (c);\n \t  if (error_operand_p (allocator))\n \t    {\n@@ -7552,6 +7589,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t\"type %qT rather than %<omp_allocator_handle_t%>\",\n \t\t\tTREE_TYPE (allocator));\n \t      remove = true;\n+\t      break;\n \t    }\n \t  else\n \t    {"}, {"sha": "26c5c0261e93c6657f81d1f8664523b246fa3663", "filename": "gcc/omp-low.c", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=059b819e3c94aae3dd0be55bd512ee6ee4e28798", "patch": "@@ -1161,14 +1161,17 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n     if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_ALLOCATE\n \t&& (OMP_CLAUSE_ALLOCATE_ALLOCATOR (c) == NULL_TREE\n \t    /* omp_default_mem_alloc is 1 */\n-\t    || !integer_onep (OMP_CLAUSE_ALLOCATE_ALLOCATOR (c))))\n+\t    || !integer_onep (OMP_CLAUSE_ALLOCATE_ALLOCATOR (c))\n+\t    || OMP_CLAUSE_ALLOCATE_ALIGN (c) != NULL_TREE))\n       {\n \tif (ctx->allocate_map == NULL)\n \t  ctx->allocate_map = new hash_map<tree, tree>;\n-\tctx->allocate_map->put (OMP_CLAUSE_DECL (c),\n-\t\t\t\tOMP_CLAUSE_ALLOCATE_ALLOCATOR (c)\n-\t\t\t\t? OMP_CLAUSE_ALLOCATE_ALLOCATOR (c)\n-\t\t\t\t: integer_zero_node);\n+\ttree val = integer_zero_node;\n+\tif (OMP_CLAUSE_ALLOCATE_ALLOCATOR (c))\n+\t  val = OMP_CLAUSE_ALLOCATE_ALLOCATOR (c);\n+\tif (OMP_CLAUSE_ALLOCATE_ALIGN (c))\n+\t  val = build_tree_list (val, OMP_CLAUSE_ALLOCATE_ALIGN (c));\n+\tctx->allocate_map->put (OMP_CLAUSE_DECL (c), val);\n       }\n \n   for (c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n@@ -4725,6 +4728,12 @@ lower_private_allocate (tree var, tree new_var, tree &allocator,\n       return false;\n     }\n \n+  unsigned HOST_WIDE_INT ialign = 0;\n+  if (TREE_CODE (allocator) == TREE_LIST)\n+    {\n+      ialign = tree_to_uhwi (TREE_VALUE (allocator));\n+      allocator = TREE_PURPOSE (allocator);\n+    }\n   if (TREE_CODE (allocator) != INTEGER_CST)\n     allocator = build_outer_var_ref (allocator, ctx);\n   allocator = fold_convert (pointer_sized_int_node, allocator);\n@@ -4739,21 +4748,21 @@ lower_private_allocate (tree var, tree new_var, tree &allocator,\n   if (TYPE_P (new_var))\n     {\n       ptr_type = build_pointer_type (new_var);\n-      align = build_int_cst (size_type_node, TYPE_ALIGN_UNIT (new_var));\n+      ialign = MAX (ialign, TYPE_ALIGN_UNIT (new_var));\n     }\n   else if (is_ref)\n     {\n       ptr_type = build_pointer_type (TREE_TYPE (TREE_TYPE (new_var)));\n-      align = build_int_cst (size_type_node,\n-\t\t\t     TYPE_ALIGN_UNIT (TREE_TYPE (ptr_type)));\n+      ialign = MAX (ialign, TYPE_ALIGN_UNIT (TREE_TYPE (ptr_type)));\n     }\n   else\n     {\n       ptr_type = build_pointer_type (TREE_TYPE (new_var));\n-      align = build_int_cst (size_type_node, DECL_ALIGN_UNIT (new_var));\n+      ialign = MAX (ialign, DECL_ALIGN_UNIT (new_var));\n       if (sz == NULL_TREE)\n \tsz = fold_convert (size_type_node, DECL_SIZE_UNIT (new_var));\n     }\n+  align = build_int_cst (size_type_node, ialign);\n   if (TREE_CODE (sz) != INTEGER_CST)\n     {\n       tree szvar = create_tmp_var (size_type_node);\n@@ -5707,6 +5716,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t    if (tree *allocatep = ctx->allocate_map->get (var))\n \t\t      {\n \t\t\tallocator = *allocatep;\n+\t\t\tif (TREE_CODE (allocator) == TREE_LIST)\n+\t\t\t  allocator = TREE_PURPOSE (allocator);\n \t\t\tif (TREE_CODE (allocator) != INTEGER_CST)\n \t\t\t  allocator = build_outer_var_ref (allocator, ctx);\n \t\t\tallocator = fold_convert (pointer_sized_int_node,\n@@ -6025,6 +6036,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\tif (tree *allocatep = ctx->allocate_map->get (var))\n \t\t\t  {\n \t\t\t    allocator = *allocatep;\n+\t\t\t    if (TREE_CODE (allocator) == TREE_LIST)\n+\t\t\t      allocator = TREE_PURPOSE (allocator);\n \t\t\t    if (TREE_CODE (allocator) != INTEGER_CST)\n \t\t\t      allocator = build_outer_var_ref (allocator, ctx);\n \t\t\t    allocator = fold_convert (pointer_sized_int_node,\n@@ -12070,6 +12083,12 @@ create_task_copyfn (gomp_task *task_stmt, omp_context *ctx)\n \t      if (tree *allocatorp = ctx->allocate_map->get (decl))\n \t\t{\n \t\t  tree allocator = *allocatorp;\n+\t\t  HOST_WIDE_INT ialign = 0;\n+\t\t  if (TREE_CODE (allocator) == TREE_LIST)\n+\t\t    {\n+\t\t      ialign = tree_to_uhwi (TREE_VALUE (allocator));\n+\t\t      allocator = TREE_PURPOSE (allocator);\n+\t\t    }\n \t\t  if (TREE_CODE (allocator) != INTEGER_CST)\n \t\t    {\n \t\t      n = splay_tree_lookup (ctx->sfield_map,\n@@ -12083,7 +12102,8 @@ create_task_copyfn (gomp_task *task_stmt, omp_context *ctx)\n \t\t  allocator = fold_convert (pointer_sized_int_node, allocator);\n \t\t  tree a = builtin_decl_explicit (BUILT_IN_GOMP_ALLOC);\n \t\t  tree align = build_int_cst (size_type_node,\n-\t\t\t\t\t      DECL_ALIGN_UNIT (decl));\n+\t\t\t\t\t      MAX (ialign,\n+\t\t\t\t\t\t   DECL_ALIGN_UNIT (decl)));\n \t\t  tree sz = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (dst)));\n \t\t  tree ptr = build_call_expr_loc (loc, a, 3, align, sz,\n \t\t\t\t\t\t  allocator);"}, {"sha": "059fd72282107c40e88fbcbb98f807ae5a9e5fc7", "filename": "gcc/testsuite/c-c++-common/gomp/allocate-6.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fallocate-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fallocate-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fallocate-6.c?ref=059b819e3c94aae3dd0be55bd512ee6ee4e28798", "patch": "@@ -0,0 +1,84 @@\n+typedef enum omp_allocator_handle_t\n+#if __cplusplus >= 201103L\n+: __UINTPTR_TYPE__\n+#endif\n+{\n+  omp_null_allocator = 0,\n+  omp_default_mem_alloc = 1,\n+  omp_large_cap_mem_alloc = 2,\n+  omp_const_mem_alloc = 3,\n+  omp_high_bw_mem_alloc = 4,\n+  omp_low_lat_mem_alloc = 5,\n+  omp_cgroup_mem_alloc = 6,\n+  omp_pteam_mem_alloc = 7,\n+  omp_thread_mem_alloc = 8,\n+  __omp_allocator_handle_t_max__ = __UINTPTR_MAX__\n+} omp_allocator_handle_t;\n+\n+int bar (int, int *, int);\n+omp_allocator_handle_t baz (void);\n+\n+void\n+foo (int x, int z)\n+{\n+  int y[16] = { 0 }, r = 0, i;\n+  omp_allocator_handle_t h = baz ();\n+  #pragma omp parallel allocate (align (sizeof (int)) : x) allocate (allocator (omp_default_mem_alloc) : y) \\\n+\t      allocate (align (8), allocator ((omp_allocator_handle_t) omp_default_mem_alloc):z) firstprivate (x, y, z)\n+  bar (x, y, z);\n+  #pragma omp task private (x) firstprivate (z) allocate (allocator (omp_low_lat_mem_alloc) :x,z)\n+  bar (0, &x, z);\n+  #pragma omp taskwait\n+  #pragma omp target teams distribute parallel for private (x) firstprivate (y) \\\n+\t      allocate (allocator ((omp_allocator_handle_t)(omp_default_mem_alloc + 0)), align (16) : z) \\\n+\t      allocate (allocator (omp_default_mem_alloc) : x, y) allocate (align (32), allocator (omp_low_lat_mem_alloc): r) \\\n+\t      lastprivate (z) reduction(+:r)\n+  for (i = 0; i < 64; i++)\n+    {\n+      z = bar (0, &x, 0);\n+      r += bar (1, y, 0);\n+    }\n+  #pragma omp single private (x) allocate (allocator (h):x)\n+  ;\n+  #pragma omp single allocate (align (2 * sizeof (int)), allocator (*&h) : x) private (x)\n+  ;\n+  #pragma omp parallel shared (r, x, z)\n+  #pragma omp single firstprivate (r) allocate (align (4) : x, r, z) private (x, z)\n+  ;\n+  #pragma omp for allocate (align (2 * 2 * 2) : x) private (x)\n+  for (i = 0; i < 64; i++)\n+    x = 1;\n+  #pragma omp sections private (x) allocate (allocator (omp_low_lat_mem_alloc), align (8): x)\n+  {\n+    x = 1;\n+    #pragma omp section\n+    x = 2;\n+    #pragma omp section\n+    x = 3;\n+  }\n+  #pragma omp taskgroup task_reduction(+:r) allocate (allocator (omp_default_mem_alloc), align (__alignof (r)) : r)\n+  #pragma omp task in_reduction(+:r) allocate (align (2 * sizeof (r)), allocator (omp_default_mem_alloc) : r)\n+  r += bar (r, &r, 0);\n+  #pragma omp teams private (x) firstprivate (y) allocate (allocator (h), align (8) : x, y)\n+  bar (x, y, 0);\n+  #pragma omp taskloop lastprivate (x) reduction (+:r) allocate (align (16), allocator (h) : x, r)\n+  for (i = 0; i < 16; i++)\n+    {\n+      r += bar (0, &r, 0);\n+      x = i;\n+    }\n+  #pragma omp taskgroup task_reduction(+:r) allocate (allocator (omp_default_mem_alloc), align (64) : r)\n+  #pragma omp taskloop firstprivate (x) in_reduction (+:r) \\\n+\t\t       allocate (allocator (omp_default_mem_alloc), align (128) : x, r)\n+  for (i = 0; i < 16; i++)\n+    r += bar (x, &r, 0);\n+  #pragma omp taskwait\n+}\n+\n+void\n+qux (const omp_allocator_handle_t h)\n+{\n+  int x = 0;\n+  #pragma omp parallel firstprivate (x) allocate (align (16), allocator (h): x)\n+  x = 1;\n+}"}, {"sha": "d125d92d9ba8eaaddffd1c7f5e8f0b46cdb27a57", "filename": "gcc/testsuite/c-c++-common/gomp/allocate-7.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fallocate-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fallocate-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fallocate-7.c?ref=059b819e3c94aae3dd0be55bd512ee6ee4e28798", "patch": "@@ -0,0 +1,41 @@\n+typedef enum omp_allocator_handle_t\n+#if __cplusplus >= 201103L\n+: __UINTPTR_TYPE__\n+#endif\n+{\n+  omp_null_allocator = 0,\n+  omp_default_mem_alloc = 1,\n+  omp_large_cap_mem_alloc = 2,\n+  omp_const_mem_alloc = 3,\n+  omp_high_bw_mem_alloc = 4,\n+  omp_low_lat_mem_alloc = 5,\n+  omp_cgroup_mem_alloc = 6,\n+  omp_pteam_mem_alloc = 7,\n+  omp_thread_mem_alloc = 8,\n+  __omp_allocator_handle_t_max__ = __UINTPTR_MAX__\n+} omp_allocator_handle_t;\n+\n+int bar (int *);\n+omp_allocator_handle_t baz (void);\n+\n+void\n+foo (int x, int z)\n+{\n+  int i;\n+  #pragma omp parallel private (x) allocate (allocator (0.0) : x)\t/* { dg-error \"'allocate' clause allocator expression has type 'double' rather than 'omp_allocator_handle_t'\" } */\n+  bar (&x);\n+  #pragma omp parallel private (x) allocate (allocator (0) : x)\t/* { dg-error \"'allocate' clause allocator expression has type 'int' rather than 'omp_allocator_handle_t'\" } */\n+  bar (&x);\n+  #pragma omp parallel private (x) allocate (align (z) : x)\t/* { dg-error \"'allocate' clause 'align' modifier argument needs to be positive constant power of two integer expression\" } */\n+  bar (&x);\n+  #pragma omp parallel private (x) allocate (align (16.0) : x)\t/* { dg-error \"'allocate' clause 'align' modifier argument needs to be positive constant power of two integer expression\" } */\n+  bar (&x);\n+  #pragma omp parallel private (x) allocate (align (14) : x)\t/* { dg-error \"'allocate' clause 'align' modifier argument needs to be positive constant power of two integer expression\" } */\n+  bar (&x);\n+  #pragma omp parallel private (x) allocate (align (0) : x)\t/* { dg-error \"'allocate' clause 'align' modifier argument needs to be positive constant power of two integer expression\" } */\n+  bar (&x);\n+  #pragma omp parallel private (x) allocate (align (16), align (16) : x)\t/* { dg-error \"expected|duplicate|declared|specified\" } */\n+  bar (&x);\t\t\t\t\t\t\t\t\t/* { dg-warning \"more than once\" \"\" { target c++ } .-1 } */\n+  #pragma omp parallel private (x) allocate (allocator (omp_default_mem_alloc), allocator (omp_default_mem_alloc) : x)\t/* { dg-error \"expected|duplicate|declared|specified\" } */\n+  bar (&x);\t\t\t\t\t\t\t\t\t/* { dg-warning \"more than once\" \"\" { target c++ } .-1 } */\n+}"}, {"sha": "dd5e5f0fed53a5be84cf37e6bc1d611de1e77a84", "filename": "gcc/testsuite/g++.dg/gomp/allocate-4.C", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fallocate-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fallocate-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fallocate-4.C?ref=059b819e3c94aae3dd0be55bd512ee6ee4e28798", "patch": "@@ -0,0 +1,108 @@\n+// { dg-do compile }\n+// { dg-additional-options \"-std=c++11\" }\n+\n+typedef enum omp_allocator_handle_t\n+#if __cplusplus >= 201103L\n+: __UINTPTR_TYPE__\n+#endif\n+{\n+  omp_null_allocator = 0,\n+  omp_default_mem_alloc = 1,\n+  omp_large_cap_mem_alloc = 2,\n+  omp_const_mem_alloc = 3,\n+  omp_high_bw_mem_alloc = 4,\n+  omp_low_lat_mem_alloc = 5,\n+  omp_cgroup_mem_alloc = 6,\n+  omp_pteam_mem_alloc = 7,\n+  omp_thread_mem_alloc = 8,\n+  __omp_allocator_handle_t_max__ = __UINTPTR_MAX__\n+} omp_allocator_handle_t;\n+\n+namespace N1\n+{\n+  using ::omp_allocator_handle_t;\n+  void\n+  foo (const omp_allocator_handle_t h)\n+  {\n+    int x = 0;\n+    #pragma omp parallel allocate (allocator (h): x) private (x)\n+    x = 1;\n+  }\n+}\n+\n+namespace N2\n+{\n+  typedef enum omp_allocator_handle_t { my = 0 } omp_allocator_handle_t;\n+  void\n+  foo (omp_allocator_handle_t h)\n+  {\n+    int x = 0;\n+    #pragma omp parallel allocate (allocator (h): x) private (x) // { dg-error \"'allocate' clause allocator expression has type 'N2::omp_allocator_handle_t' rather than 'omp_allocator_handle_t'\" }\n+    x = 1;\n+  }\n+}\n+\n+struct S\n+{\n+  void foo ()\n+  {\n+    #pragma omp parallel allocate (allocator(omp_default_mem_alloc):s) firstprivate (s)\n+    s++;\n+  }\n+  int s;\n+};\n+\n+template <typename T>\n+struct U\n+{\n+  int foo ()\n+  {\n+    #pragma omp parallel allocate (allocator(omp_default_mem_alloc):s) firstprivate (s)\n+    s++;\n+    return 1;\n+  }\n+  T s;\n+};\n+\n+template <typename T, int N>\n+int foo (T t)\n+{\n+  int x = 0;\n+  #pragma omp parallel firstprivate (x) allocate (allocator(t), align (N): x)\n+  x = 1;\n+  return 0;\n+}\n+\n+template <typename T>\n+int bar (T t)\n+{\n+  int x = 0;\n+  #pragma omp parallel firstprivate (x) allocate (allocator(t): x)\t// { dg-error \"'allocate' clause allocator expression has type 'int' rather than 'omp_allocator_handle_t'\" }\n+  x = 1;\n+  return 0;\n+}\n+\n+template <typename T, int N>\n+int baz (T t)\n+{\n+  int x = 0;\n+  #pragma omp parallel firstprivate (x) allocate (allocator(t), align (N): x) // { dg-error \"'allocate' clause 'align' modifier argument needs to be positive constant power of two integer expression\" }\n+  x = 1;\n+  return 0;\n+}\n+\n+template <typename T>\n+int qux ()\n+{\n+  int x = 0;\n+  #pragma omp parallel firstprivate (x) allocate (align ((T) 16): x) // { dg-error \"'allocate' clause 'align' modifier argument needs to be positive constant power of two integer expression\" }\n+  x = 1;\n+  return 0;\n+}\n+\n+omp_allocator_handle_t h;\n+int a = foo<omp_allocator_handle_t, 16> (h);\n+int b = bar (0);\n+int c = U<int> ().foo ();\n+int d = baz<omp_allocator_handle_t, 13> (h);\n+int e = qux<long double> ();"}, {"sha": "35e567cbfaf53a51a166f88b2a15885602a8340e", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=059b819e3c94aae3dd0be55bd512ee6ee4e28798", "patch": "@@ -735,10 +735,23 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n       pp_string (pp, \"allocate(\");\n       if (OMP_CLAUSE_ALLOCATE_ALLOCATOR (clause))\n \t{\n+\t  pp_string (pp, \"allocator(\");\n \t  dump_generic_node (pp, OMP_CLAUSE_ALLOCATE_ALLOCATOR (clause),\n \t\t\t     spc, flags, false);\n-\t  pp_colon (pp);\n+\t  pp_right_paren (pp);\n+\t}\n+      if (OMP_CLAUSE_ALLOCATE_ALIGN (clause))\n+\t{\n+\t  if (OMP_CLAUSE_ALLOCATE_ALLOCATOR (clause))\n+\t    pp_comma (pp);\n+\t  pp_string (pp, \"align(\");\n+\t  dump_generic_node (pp, OMP_CLAUSE_ALLOCATE_ALIGN (clause),\n+\t\t\t     spc, flags, false);\n+\t  pp_right_paren (pp);\n \t}\n+      if (OMP_CLAUSE_ALLOCATE_ALLOCATOR (clause)\n+\t  || OMP_CLAUSE_ALLOCATE_ALIGN (clause))\n+\tpp_colon (pp);\n       dump_generic_node (pp, OMP_CLAUSE_DECL (clause),\n \t\t\t spc, flags, false);\n       pp_right_paren (pp);"}, {"sha": "561b9cd56bdce8dd79737fd1ef131e657978e1a3", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=059b819e3c94aae3dd0be55bd512ee6ee4e28798", "patch": "@@ -291,7 +291,7 @@ unsigned const char omp_clause_num_ops[] =\n   3, /* OMP_CLAUSE_LINEAR  */\n   1, /* OMP_CLAUSE_AFFINITY  */\n   2, /* OMP_CLAUSE_ALIGNED  */\n-  2, /* OMP_CLAUSE_ALLOCATE  */\n+  3, /* OMP_CLAUSE_ALLOCATE  */\n   1, /* OMP_CLAUSE_DEPEND  */\n   1, /* OMP_CLAUSE_NONTEMPORAL  */\n   1, /* OMP_CLAUSE_UNIFORM  */"}, {"sha": "7d1257b7a750293de494c0c409a199f63b41f3fa", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059b819e3c94aae3dd0be55bd512ee6ee4e28798/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=059b819e3c94aae3dd0be55bd512ee6ee4e28798", "patch": "@@ -1790,6 +1790,9 @@ class auto_suppress_location_wrappers\n #define OMP_CLAUSE_ALLOCATE_ALLOCATOR(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_ALLOCATE), 1)\n \n+#define OMP_CLAUSE_ALLOCATE_ALIGN(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_ALLOCATE), 2)\n+\n /* True if an ALLOCATE clause was present on a combined or composite\n    construct and the code for splitting the clauses has already performed\n    checking if the listed variable has explicit privatization on the"}, {"sha": "e4cd09ae065c3ce40848fc3edec272fcf85fa7c9", "filename": "libgomp/testsuite/libgomp.c-c++-common/allocate-2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059b819e3c94aae3dd0be55bd512ee6ee4e28798/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fallocate-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059b819e3c94aae3dd0be55bd512ee6ee4e28798/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fallocate-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fallocate-2.c?ref=059b819e3c94aae3dd0be55bd512ee6ee4e28798", "patch": "@@ -0,0 +1,37 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+#include <stdint.h>\n+\n+int zero;\n+\n+omp_allocator_handle_t\n+allocator (omp_allocator_handle_t h)\n+{\n+  if (zero)\n+    return h;\n+  else\n+    abort ();\n+}\n+\n+omp_allocator_handle_t\n+align (int a)\n+{\n+  if (zero)\n+    return omp_default_mem_alloc;\n+  else\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  int x = 1, y = 2;\n+  #pragma omp parallel num_threads(2) firstprivate (x, y) allocate (allocator (omp_default_mem_alloc) : x) allocate (align (16) : y)\n+  {\n+    if (x != 1 || y != 2)\n+      abort ();\n+    if ((((uintptr_t) &y) & 15) != 0)\n+      abort ();\n+  }\n+  return 0;\n+}"}, {"sha": "ce1a045a4079540f0fef75607cecfc5decdff50b", "filename": "libgomp/testsuite/libgomp.c-c++-common/allocate-3.c", "status": "added", "additions": 405, "deletions": 0, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059b819e3c94aae3dd0be55bd512ee6ee4e28798/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fallocate-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059b819e3c94aae3dd0be55bd512ee6ee4e28798/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fallocate-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fallocate-3.c?ref=059b819e3c94aae3dd0be55bd512ee6ee4e28798", "patch": "@@ -0,0 +1,405 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+#include <stdint.h>\n+\n+struct S { int a, b; };\n+\n+void\n+foo (int x, int *p, int *q, int px, omp_allocator_handle_t h, int fl)\n+{\n+  int y = 0, r = 0, i, i1, l, l2[4], l3, n = 8;\n+  int i2, j2, n2 = 9, l4;\n+  int i3, j3, n3 = 10, l5;\n+  int i4, j4, n4 = 11, l6;\n+  int i5;\n+  int v[x], w[x];\n+  int r2[4] = { 0, 0, 0, 0 };\n+  int xo = x;\n+  struct S s = { 27, 29 };\n+  for (i = 0; i < 4; i++)\n+    p[i] = 0;\n+  for (i = 0; i < 3; i++)\n+    q[i] = 0;\n+  for (i = 0; i < x; i++)\n+    w[i] = i;\n+  #pragma omp parallel private (y, v) firstprivate (x) allocate (align (32) : x) allocate (align (128) : y) allocate (v)\n+  {\n+    int *volatile p1 = &x;\n+    int *volatile p2 = &y;\n+    if (x != 42)\n+      abort ();\n+    #pragma omp barrier\n+    *p2 = 1;\n+    p1[0]++;\n+    v[0] = 7;\n+    v[41] = 8;\n+    #pragma omp barrier\n+    if (x != 43 || y != 1)\n+      abort ();\n+    if (v[0] != 7 || v[41] != 8)\n+      abort ();\n+    if ((fl & 2) && (((uintptr_t) p1 | (uintptr_t) p2\n+\t| (uintptr_t) &v[0]) & 63) != 0)\n+      abort ();\n+    if ((((uintptr_t) p1) & 31) != 0)\n+      abort ();\n+    if ((((uintptr_t) p2) & 127) != 0)\n+      abort ();\n+  }\n+  x = xo;\n+  #pragma omp teams\n+  #pragma omp parallel private (y) firstprivate (x, w) allocate (allocator (h), align (32) : x) allocate (align (128), allocator (h):y) allocate(allocator(h):w)\n+  {\n+    int *volatile p1 = &x;\n+    int *volatile p2 = &y;\n+    if (x != 42 || w[17] != 17 || w[41] != 41)\n+      abort ();\n+    #pragma omp barrier\n+    *p2 = 1;\n+    p1[0]++;\n+    w[19]++;\n+    #pragma omp barrier\n+    if (x != 43 || y != 1 || w[19] != 20)\n+      abort ();\n+    if ((fl & 1) && (((uintptr_t) p1 | (uintptr_t) p2\n+\t\t      | (uintptr_t) &w[0]) & 63) != 0)\n+      abort ();\n+    if ((((uintptr_t) p1) & 31) != 0)\n+      abort ();\n+    if ((((uintptr_t) p2) & 127) != 0)\n+      abort ();\n+  }\n+  x = xo;\n+  #pragma omp parallel for private (y) firstprivate (x) allocate (allocator (h), align (32) : x, y, r) allocate (align (128), allocator (h) : l, n) reduction(+: r) lastprivate (l) linear (n: 16)\n+  for (i = 0; i < 64; i++)\n+    {\n+      if (x != 42)\n+\tabort ();\n+      y = 1;\n+      l = i;\n+      n += y + 15;\n+      r += i;\n+      if ((fl & 1) && (((uintptr_t) &x | (uintptr_t) &y | (uintptr_t) &r\n+\t\t\t| (uintptr_t) &l | (uintptr_t) &n) & 63) != 0)\n+\tabort ();\n+      if ((((uintptr_t) &x | (uintptr_t) &y | (uintptr_t) &r) & 31) != 0)\n+\tabort ();\n+      if ((((uintptr_t) &l | (uintptr_t) &n) & 127) != 0)\n+\tabort ();\n+    }\n+  x = xo;\n+  #pragma omp parallel\n+  {\n+    #pragma omp for lastprivate (l2) private (i1) allocate (allocator (h): l2, l3) allocate (allocator (h),align(16): i1) lastprivate (conditional: l3)\n+    for (i1 = 0; i1 < 64; i1++)\n+      {\n+\tl2[0] = i1;\n+\tl2[1] = i1 + 1;\n+\tl2[2] = i1 + 2;\n+\tl2[3] = i1 + 3;\n+\tif (i1 < 37)\n+\t  l3 = i1;\n+\tif ((fl & 1) && (((uintptr_t) &l2[0] | (uintptr_t) &l3 | (uintptr_t) &i1) & 63) != 0)\n+\t  abort ();\n+\tif ((((uintptr_t) &i1) & 15) != 0)\n+\t  abort ();\n+      }\n+    #pragma omp for collapse(2) lastprivate(l4, i2, j2) linear (n2:17) allocate (allocator (h), align (8): n2, l4, i2, j2)\n+    for (i2 = 3; i2 < 5; i2++)\n+      for (j2 = 17; j2 < 22; j2 += 2)\n+\t{\n+\t  n2 += 17;\n+\t  l4 = i2 * 31 + j2;\n+\t  if ((fl & 1) && (((uintptr_t) &l4 | (uintptr_t) &n2\n+\t\t\t    | (uintptr_t) &i2 | (uintptr_t) &j2) & 63) != 0)\n+\t    abort ();\n+\t  if ((((uintptr_t) &l4 | (uintptr_t) &n2 | (uintptr_t) &i2 | (uintptr_t) &j2) & 7) != 0)\n+\t    abort ();\n+\t}\n+    #pragma omp for collapse(2) lastprivate(l5, i3, j3) linear (n3:17) schedule (static, 3) allocate (align (16): n3, l5, i3, j3)\n+    for (i3 = 3; i3 < 5; i3++)\n+      for (j3 = 17; j3 < 23; j3 += 2)\n+\t{\n+\t  n3 += 17;\n+\t  l5 = i3 * 31 + j3;\n+\t  if ((fl & 2) && (((uintptr_t) &l5 | (uintptr_t) &n3\n+\t\t\t    | (uintptr_t) &i3 | (uintptr_t) &j3) & 63) != 0)\n+\t    abort ();\n+\t  if ((((uintptr_t) &l5 | (uintptr_t) &n3 | (uintptr_t) &i3 | (uintptr_t) &j3) & 15) != 0)\n+\t    abort ();\n+\t}\n+    #pragma omp for collapse(2) lastprivate(l6, i4, j4) linear (n4:17) schedule (dynamic) allocate (align (16), allocator (h): n4, l6, i4, j4)\n+    for (i4 = 3; i4 < 5; i4++)\n+      for (j4 = 17; j4 < 22; j4 += 2)\n+\t{\n+\t  n4 += 17;\n+\t  l6 = i4 * 31 + j4;\n+\t  if ((fl & 1) && (((uintptr_t) &l6 | (uintptr_t) &n4\n+\t\t\t    | (uintptr_t) &i4 | (uintptr_t) &j4) & 63) != 0)\n+\t    abort ();\n+\t  if ((((uintptr_t) &l6 | (uintptr_t) &n4 | (uintptr_t) &i4 | (uintptr_t) &j4) & 15) != 0)\n+\t    abort ();\n+\t}\n+    #pragma omp for lastprivate (i5) allocate (align (32): i5)\n+    for (i5 = 1; i5 < 17; i5 += 3)\n+      {\n+\tif ((fl & 2) && (((uintptr_t) &i5) & 63) != 0)\n+\t  abort ();\n+\tif ((((uintptr_t) &i5) & 31) != 0)\n+\t  abort ();\n+      }\n+    #pragma omp for reduction(+:p[2:px], q[:3], r2) allocate(align (16), allocator (h): p, q, r2)\n+    for (i = 0; i < 32; i++)\n+      {\n+\tp[2] += i;\n+\tp[3] += 2 * i;\n+\tq[0] += 3 * i;\n+\tq[2] += 4 * i;\n+\tr2[0] += 5 * i;\n+\tr2[3] += 6 * i;\n+\t/* Can't really rely on alignment of &p[0], the implementation could\n+\t   allocate the whole array or do what GCC does and allocate only part\n+\t   of it.  */\n+\tif ((fl & 1) && (((uintptr_t) &q[0] | (uintptr_t) &r2[0]) & 63) != 0)\n+\t  abort ();\n+\tif ((((uintptr_t) &q[0] | (uintptr_t) &r2[0]) & 15) != 0)\n+\t  abort ();\n+      }\n+    #pragma omp task private(y) firstprivate(x) allocate(align (8) : x, y)\n+    {\n+      int *volatile p1 = &x;\n+      int *volatile p2 = &y;\n+      if (x != 42)\n+\tabort ();\n+      p1[0]++;\n+      p2[0] = 21;\n+      if (x != 43 || y != 21)\n+\tabort ();\n+      if ((fl & 2) && (((uintptr_t) p1 | (uintptr_t) p2) & 63) != 0)\n+\tabort ();\n+      if ((((uintptr_t) p1 | (uintptr_t) p2) & 7) != 0)\n+\tabort ();\n+    }\n+    #pragma omp task private(y) firstprivate(x) allocate(allocator (h),align(32): x, y)\n+    {\n+      int *volatile p1 = &x;\n+      int *volatile p2 = &y;\n+      if (x != 42)\n+\tabort ();\n+      p1[0]++;\n+      p2[0] = 21;\n+      if (x != 43 || y != 21)\n+\tabort ();\n+      if ((fl & 1) && (((uintptr_t) p1 | (uintptr_t) p2) & 63) != 0)\n+\tabort ();\n+      if ((((uintptr_t) p1 | (uintptr_t) p2) & 31) != 0)\n+\tabort ();\n+    }\n+    #pragma omp task private(y) firstprivate(s) allocate(align(16): s, y)\n+    {\n+      int *volatile p1 = &s.a;\n+      int *volatile p2 = &s.b;\n+      int *volatile p3 = &y;\n+      if (s.a != 27 || s.b != 29)\n+\tabort ();\n+      p1[0]++;\n+      p2[0]++;\n+      p3[0] = 21;\n+      if (s.a != 28 || s.b != 30 || y != 21)\n+\tabort ();\n+      if ((fl & 2) && (((uintptr_t) p1 | (uintptr_t) p3) & 63) != 0)\n+\tabort ();\n+      if ((((uintptr_t) p1 | (uintptr_t) p3) & 15) != 0)\n+\tabort ();\n+    }\n+    #pragma omp task private(y) firstprivate(s) allocate(allocator (h): s, y)\n+    {\n+      int *volatile p1 = &s.a;\n+      int *volatile p2 = &s.b;\n+      int *volatile p3 = &y;\n+      if (s.a != 27 || s.b != 29)\n+\tabort ();\n+      p1[0]++;\n+      p2[0]++;\n+      p3[0] = 21;\n+      if (s.a != 28 || s.b != 30 || y != 21)\n+\tabort ();\n+      if ((fl & 1) && (((uintptr_t) p1 | (uintptr_t) p3) & 63) != 0)\n+\tabort ();\n+    }\n+  }\n+  if (r != 64 * 63 / 2 || l != 63 || n != 8 + 16 * 64)\n+    abort ();\n+  if (l2[0] != 63 || l2[1] != 63 + 1 || l2[2] != 63 + 2 || l2[3] != 63 + 3 || l3 != 36)\n+    abort ();\n+  if (i2 != 5 || j2 != 23 || n2 != 9 + 6 * 17 || l4 != 4 * 31 + 21)\n+    abort ();\n+  if (i3 != 5 || j3 != 23 || n3 != 10 + 6 * 17 || l5 != 4 * 31 + 21)\n+    abort ();\n+  if (i4 != 5 || j4 != 23 || n4 != 11 + 6 * 17 || l6 != 4 * 31 + 21)\n+    abort ();\n+  if (i5 != 19)\n+    abort ();\n+  if (p[2] != (32 * 31) / 2 || p[3] != 2 * (32 * 31) / 2\n+      || q[0] != 3 * (32 * 31) / 2 || q[2] != 4 * (32 * 31) / 2\n+      || r2[0] != 5 * (32 * 31) / 2 || r2[3] != 6 * (32 * 31) / 2)\n+    abort ();\n+}\n+\n+void\n+bar (int x, omp_allocator_handle_t h)\n+{\n+  int y = 0, r = 0, i, i1, l, l2[4], l3, n = 8;\n+  int i2, j2, n2 = 9, l4;\n+  int i3, j3, n3 = 10, l5;\n+  int i4, j4, n4 = 11, l6;\n+  int i5;\n+  struct S s = { 27, 29 };\n+  int xo = x;\n+  #pragma omp parallel private (y) firstprivate (x) allocate (x, y)\n+  {\n+    if (x != 42)\n+      abort ();\n+    #pragma omp barrier\n+    y = 1;\n+    x++;\n+    #pragma omp barrier\n+    if (x != 43 || y != 1)\n+      abort ();\n+  }\n+  x = xo;\n+  #pragma omp teams\n+  #pragma omp parallel private (y) firstprivate (x) allocate (allocator (h): x, y)\n+  {\n+    if (x != 42)\n+      abort ();\n+    #pragma omp barrier\n+    y = 1;\n+    x++;\n+    #pragma omp barrier\n+    if (x != 43 || y != 1)\n+      abort ();\n+  }\n+  x = xo;\n+  #pragma omp parallel for private (y) firstprivate (x) allocate (allocator (h): x, y, r, l, n) reduction(+: r) lastprivate (l) linear (n: 16)\n+  for (i = 0; i < 64; i++)\n+    {\n+      if (x != 42)\n+\tabort ();\n+      y = 1;\n+      l = i;\n+      n += y + 15;\n+      r += i;\n+    }\n+  x = xo;\n+  #pragma omp parallel\n+  {\n+    #pragma omp for lastprivate (l2) private (i1) allocate (allocator (h): l2, l3, i1) lastprivate (conditional: l3)\n+    for (i1 = 0; i1 < 64; i1++)\n+      {\n+\tl2[0] = i1;\n+\tl2[1] = i1 + 1;\n+\tl2[2] = i1 + 2;\n+\tl2[3] = i1 + 3;\n+\tif (i1 < 37)\n+\t  l3 = i1;\n+      }\n+    #pragma omp for collapse(2) lastprivate(l4, i2, j2) linear (n2:17) allocate (allocator (h): n2, l4, i2, j2)\n+    for (i2 = 3; i2 < 5; i2++)\n+      for (j2 = 17; j2 < 22; j2 += 2)\n+\t{\n+\t  n2 += 17;\n+\t  l4 = i2 * 31 + j2;\n+\t}\n+    #pragma omp for collapse(2) lastprivate(l5, i3, j3) linear (n3:17) schedule (static, 3) allocate (n3, l5, i3, j3)\n+    for (i3 = 3; i3 < 5; i3++)\n+      for (j3 = 17; j3 < 23; j3 += 2)\n+\t{\n+\t  n3 += 17;\n+\t  l5 = i3 * 31 + j3;\n+\t}\n+    #pragma omp for collapse(2) lastprivate(l6, i4, j4) linear (n4:17) schedule (dynamic) allocate (allocator (h): n4, l6, i4, j4)\n+    for (i4 = 3; i4 < 5; i4++)\n+      for (j4 = 17; j4 < 22; j4 += 2)\n+\t{\n+\t  n4 += 17;\n+\t  l6 = i4 * 31 + j4;\n+\t}\n+    #pragma omp for lastprivate (i5) allocate (i5)\n+    for (i5 = 1; i5 < 17; i5 += 3)\n+      ;\n+    #pragma omp task private(y) firstprivate(x) allocate(x, y)\n+    {\n+      if (x != 42)\n+\tabort ();\n+      x++;\n+      y = 21;\n+      if (x != 43 || y != 21)\n+\tabort ();\n+    }\n+    #pragma omp task private(y) firstprivate(x) allocate(allocator (h): x, y)\n+    {\n+      if (x != 42)\n+\tabort ();\n+      x++;\n+      y = 21;\n+      if (x != 43 || y != 21)\n+\tabort ();\n+    }\n+    #pragma omp task private(y) firstprivate(s) allocate(s, y)\n+    {\n+      if (s.a != 27 || s.b != 29)\n+\tabort ();\n+      s.a++;\n+      s.b++;\n+      y = 21;\n+      if (s.a != 28 || s.b != 30 || y != 21)\n+\tabort ();\n+    }\n+    #pragma omp task private(y) firstprivate(s) allocate(allocator (h), align (16): s, y)\n+    {\n+      if (s.a != 27 || s.b != 29)\n+\tabort ();\n+      s.a++;\n+      s.b++;\n+      y = 21;\n+      if (s.a != 28 || s.b != 30 || y != 21)\n+\tabort ();\n+    }\n+  }\n+  if (r != 64 * 63 / 2 || l != 63 || n != 8 + 16 * 64)\n+    abort ();\n+  if (l2[0] != 63 || l2[1] != 63 + 1 || l2[2] != 63 + 2 || l2[3] != 63 + 3 || l3 != 36)\n+    abort ();\n+  if (i2 != 5 || j2 != 23 || n2 != 9 + 6 * 17 || l4 != 4 * 31 + 21)\n+    abort ();\n+  if (i3 != 5 || j3 != 23 || n3 != 10 + 6 * 17 || l5 != 4 * 31 + 21)\n+    abort ();\n+  if (i4 != 5 || j4 != 23 || n4 != 11 + 6 * 17 || l6 != 4 * 31 + 21)\n+    abort ();\n+  if (i5 != 19)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  omp_alloctrait_t traits[3]\n+    = { { omp_atk_alignment, 64 },\n+\t{ omp_atk_fallback, omp_atv_null_fb } };\n+  omp_allocator_handle_t a\n+    = omp_init_allocator (omp_default_mem_space, 2, traits);\n+  int p[4], q[3];\n+  if (a == omp_null_allocator)\n+    abort ();\n+  omp_set_default_allocator (omp_default_mem_alloc);\n+  foo (42, p, q, 2, omp_null_allocator, 0);\n+  foo (42, p, q, 2, omp_default_mem_alloc, 0);\n+  foo (42, p, q, 2, a, 1);\n+  omp_set_default_allocator (a);\n+  foo (42, p, q, 2, omp_null_allocator, 3);\n+  foo (42, p, q, 2, omp_default_mem_alloc, 2);\n+  bar (42, a);\n+  omp_destroy_allocator (a);\n+  return 0;\n+}"}]}