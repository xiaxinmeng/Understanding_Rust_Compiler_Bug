{"sha": "38899e29e5f39c4589ac0bd2b4545b3caa8cff20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg4OTllMjllNWYzOWM0NTg5YWMwYmQyYjQ1NDViM2NhYThjZmYyMA==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@redhat.com", "date": "2004-05-04T01:16:47Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-05-04T01:16:47Z"}, "message": "s390.h (CONDITIONAL_REGISTER_USAGE): Move body...\n\n2004-05-03  Eric Christopher  <echristo@redhat.com>\n\n\t* config/s390/s390.h (CONDITIONAL_REGISTER_USAGE): Move body...\n\t* config/s390/s390.c (s390_conditional_register_usage): ...here.\n\t* config/s390/s390-protos.h: Prototype.\n\nFrom-SVN: r81465", "tree": {"sha": "7163d01ea811cb277f2fccdfaba69ea52a0b37fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7163d01ea811cb277f2fccdfaba69ea52a0b37fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38899e29e5f39c4589ac0bd2b4545b3caa8cff20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38899e29e5f39c4589ac0bd2b4545b3caa8cff20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38899e29e5f39c4589ac0bd2b4545b3caa8cff20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38899e29e5f39c4589ac0bd2b4545b3caa8cff20/comments", "author": {"login": "echristo", "id": 327308, "node_id": "MDQ6VXNlcjMyNzMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/327308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/echristo", "html_url": "https://github.com/echristo", "followers_url": "https://api.github.com/users/echristo/followers", "following_url": "https://api.github.com/users/echristo/following{/other_user}", "gists_url": "https://api.github.com/users/echristo/gists{/gist_id}", "starred_url": "https://api.github.com/users/echristo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/echristo/subscriptions", "organizations_url": "https://api.github.com/users/echristo/orgs", "repos_url": "https://api.github.com/users/echristo/repos", "events_url": "https://api.github.com/users/echristo/events{/privacy}", "received_events_url": "https://api.github.com/users/echristo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3ccd700ffffab3d55e40bf678d71036a91483d97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ccd700ffffab3d55e40bf678d71036a91483d97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ccd700ffffab3d55e40bf678d71036a91483d97"}], "stats": {"total": 188, "additions": 100, "deletions": 88}, "files": [{"sha": "c9cc79b5aa5e6aa89dbd4d6174715f2161be8ec1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38899e29e5f39c4589ac0bd2b4545b3caa8cff20/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38899e29e5f39c4589ac0bd2b4545b3caa8cff20/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38899e29e5f39c4589ac0bd2b4545b3caa8cff20", "patch": "@@ -1,3 +1,9 @@\n+2004-05-03  Eric Christopher  <echristo@redhat.com>\n+\n+\t* config/s390/s390.h (CONDITIONAL_REGISTER_USAGE): Move body...\n+\t* config/s390/s390.c (s390_conditional_register_usage): ...here.\n+\t* config/s390/s390-protos.h: Prototype.\n+\n 2004-05-03  Joe Buck <jbuck@welsh-buck.org>\n \n \t* cppfiles.c (pchf_adder): Eliminate use of |= in d->have_once_only"}, {"sha": "07295ec9369ffd267492399262dc0e872c7bfe7b", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38899e29e5f39c4589ac0bd2b4545b3caa8cff20/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38899e29e5f39c4589ac0bd2b4545b3caa8cff20/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=38899e29e5f39c4589ac0bd2b4545b3caa8cff20", "patch": "@@ -28,6 +28,7 @@ extern void s390_load_got (int);\n extern void s390_emit_prologue (void);\n extern void s390_emit_epilogue (bool);\n extern void s390_function_profiler (FILE *, int);\n+extern void s390_conditional_register_usage (void);\n \n #ifdef RTX_CODE\n extern int s390_extra_constraint_str (rtx, int, const char *);"}, {"sha": "e155f60aae748ea700b31d3cec57e6f3ad928e78", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 92, "deletions": 62, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38899e29e5f39c4589ac0bd2b4545b3caa8cff20/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38899e29e5f39c4589ac0bd2b4545b3caa8cff20/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=38899e29e5f39c4589ac0bd2b4545b3caa8cff20", "patch": "@@ -768,7 +768,7 @@ s390_branch_condition_mnemonic (rtx code, int inv)\n \n /* Return the part of op which has a value different from def.\n    The size of the part is determined by mode.\n-   Use this function only if you already know that op really \n+   Use this function only if you already know that op really\n    contains such a part.  */\n \n unsigned HOST_WIDE_INT\n@@ -779,18 +779,18 @@ s390_extract_part (rtx op, enum machine_mode mode, int def)\n   int part_bits = GET_MODE_BITSIZE (mode);\n   unsigned HOST_WIDE_INT part_mask = (1 << part_bits) - 1;\n   int i;\n-  \n+\n   for (i = 0; i < max_parts; i++)\n     {\n       if (i == 0)\n \tvalue = (unsigned HOST_WIDE_INT) INTVAL (op);\n       else\n \tvalue >>= part_bits;\n-      \n+\n       if ((value & part_mask) != (def & part_mask))\n \treturn value & part_mask;\n     }\n-  \n+\n   abort ();\n }\n \n@@ -799,8 +799,8 @@ s390_extract_part (rtx op, enum machine_mode mode, int def)\n    part. Otherwise, return -1.  */\n \n int\n-s390_single_part (rtx op, \n-\t\t  enum machine_mode mode, \n+s390_single_part (rtx op,\n+\t\t  enum machine_mode mode,\n \t\t  enum machine_mode part_mode,\n \t\t  int def)\n {\n@@ -811,14 +811,14 @@ s390_single_part (rtx op,\n \n   if (GET_CODE (op) != CONST_INT)\n     return -1;\n-  \n+\n   for (i = 0; i < n_parts; i++)\n     {\n       if (i == 0)\n \tvalue = (unsigned HOST_WIDE_INT) INTVAL (op);\n       else\n \tvalue >>= GET_MODE_BITSIZE (part_mode);\n-      \n+\n       if ((value & part_mask) != (def & part_mask))\n \t{\n \t  if (part != -1)\n@@ -1123,10 +1123,10 @@ general_s_operand (register rtx op, enum machine_mode mode,\n \t  return 0;\n \tif (addr.indx)\n \t  return 0;\n-\t/* Do not allow literal pool references unless ALLOW_IMMEDIATE \n-\t   is true.  This prevents compares between two literal pool \n+\t/* Do not allow literal pool references unless ALLOW_IMMEDIATE\n+\t   is true.  This prevents compares between two literal pool\n \t   entries from being accepted.  */\n-\tif (!allow_immediate \n+\tif (!allow_immediate\n \t    && addr.base && REGNO (addr.base) == BASE_REGISTER)\n \t  return 0;\n \treturn 1;\n@@ -1347,8 +1347,8 @@ s390_const_ok_for_constraint_p (HOST_WIDE_INT value,\n       return value >= -32768 && value < 32768;\n \n     case 'L':\n-      return (TARGET_LONG_DISPLACEMENT ? \n-\t      (value >= -524288 && value <= 524287) \n+      return (TARGET_LONG_DISPLACEMENT ?\n+\t      (value >= -524288 && value <= 524287)\n \t      : (value >= 0 && value <= 4095));\n     case 'M':\n       return value == 2147483647;\n@@ -1362,7 +1362,7 @@ s390_const_ok_for_constraint_p (HOST_WIDE_INT value,\n \tcase 'Q': part_mode = QImode; break;\n \tdefault:  return 0;\n \t}\n-      \n+\n       switch (str[3])\n \t{\n \tcase 'H': mode = HImode; break;\n@@ -2626,15 +2626,15 @@ static void\n s390_emit_tls_call_insn (rtx result_reg, rtx tls_call)\n {\n   rtx insn;\n-  \n+\n   if (!flag_pic)\n     abort ();\n \n   if (!s390_tls_symbol)\n     s390_tls_symbol = gen_rtx_SYMBOL_REF (Pmode, \"__tls_get_offset\");\n \n-  insn = s390_emit_call (s390_tls_symbol, tls_call, result_reg, \n-\t\t\t gen_rtx_REG (Pmode, RETURN_REGNUM)); \n+  insn = s390_emit_call (s390_tls_symbol, tls_call, result_reg,\n+\t\t\t gen_rtx_REG (Pmode, RETURN_REGNUM));\n \n   use_reg (&CALL_INSN_FUNCTION_USAGE (insn), result_reg);\n   CONST_OR_PURE_CALL_P (insn) = 1;\n@@ -3007,7 +3007,7 @@ s390_expand_movstr (rtx dst, rtx src, rtx len)\n \n       expand_end_loop ();\n \n-      emit_insn (gen_movstr_short (dst, src, \n+      emit_insn (gen_movstr_short (dst, src,\n \t\t\t\t   convert_to_mode (Pmode, count, 1)));\n       emit_label (end_label);\n     }\n@@ -3177,7 +3177,7 @@ s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n \n       expand_end_loop ();\n \n-      emit_insn (gen_cmpmem_short (op0, op1, \n+      emit_insn (gen_cmpmem_short (op0, op1,\n \t\t\t\t   convert_to_mode (Pmode, count, 1)));\n       emit_label (end_label);\n \n@@ -3318,7 +3318,7 @@ get_some_local_dynamic_name_1 (rtx *px, void *data ATTRIBUTE_UNUSED)\n   return 0;\n }\n \n-/* Output machine-dependent UNSPECs occurring in address constant X \n+/* Output machine-dependent UNSPECs occurring in address constant X\n    in assembler syntax to stdio stream FILE.  Returns true if the\n    constant X could be recognized, false otherwise.  */\n \n@@ -3536,11 +3536,11 @@ print_operand (FILE *file, rtx x, int code)\n       else if (code == 'h')\n         fprintf (file, HOST_WIDE_INT_PRINT_DEC, ((INTVAL (x) & 0xffff) ^ 0x8000) - 0x8000);\n       else if (code == 'i')\n-\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, \n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC,\n \t\t s390_extract_part (x, HImode, 0));\n       else if (code == 'j')\n-\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, \n-\t\t s390_extract_part (x, HImode, -1));\t\n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC,\n+\t\t s390_extract_part (x, HImode, -1));\n       else\n         fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (x));\n       break;\n@@ -4282,7 +4282,7 @@ s390_dump_pool (struct constant_pool *pool, bool remote_label)\n \tinsn = emit_label_after (c->label, insn);\n \tINSN_ADDRESSES_NEW (insn, -1);\n \n-\tvalue = gen_rtx_UNSPEC_VOLATILE (constant_modes[i], \n+\tvalue = gen_rtx_UNSPEC_VOLATILE (constant_modes[i],\n \t\t\t\t\t gen_rtvec (1, value),\n \t\t\t\t\t UNSPECV_POOL_ENTRY);\n \tinsn = emit_insn_after (value, insn);\n@@ -4430,8 +4430,8 @@ s390_mainpool_finish (struct constant_pool *pool, rtx base_reg)\n       insn = emit_insn_after (insn, pool->pool_insn);\n       INSN_ADDRESSES_NEW (insn, -1);\n       remove_insn (pool->pool_insn);\n-     \n-      insn = get_last_insn (); \n+\n+      insn = get_last_insn ();\n       pool->pool_insn = emit_insn_after (gen_pool (const0_rtx), insn);\n       INSN_ADDRESSES_NEW (pool->pool_insn, -1);\n \n@@ -5131,7 +5131,7 @@ s390_reorg (void)\n   /* Install the main literal pool and the associated base\n      register load insns.\n \n-     In addition, there are two problematic situations we need \n+     In addition, there are two problematic situations we need\n      to correct:\n \n      - the literal pool might be > 4096 bytes in size, so that\n@@ -5686,7 +5686,7 @@ s390_emit_prologue (void)\n \t algorithms located at the branch target.\n \n \t This must use register 1.  */\n-      s390_emit_call (GEN_INT (0xfe0), NULL_RTX, NULL_RTX, \n+      s390_emit_call (GEN_INT (0xfe0), NULL_RTX, NULL_RTX,\n \t\t      gen_rtx_REG (Pmode, 1));\n \n       /* Emit a blockage here so that all code\n@@ -5718,7 +5718,7 @@ s390_emit_epilogue (bool sibcall)\n          lies between the profiling mechanisms.  */\n       emit_insn (gen_blockage ());\n \n-      s390_emit_call (GEN_INT (0xfe6), NULL_RTX, NULL_RTX, \n+      s390_emit_call (GEN_INT (0xfe6), NULL_RTX, NULL_RTX,\n \t\t      gen_rtx_REG (Pmode, 1));\n     }\n \n@@ -5759,7 +5759,7 @@ s390_emit_epilogue (bool sibcall)\n \t      area_bottom = 16*UNITS_PER_WORD + 8*(i-16);\n \t    if (area_top < 16*UNITS_PER_WORD + 8*(i-16) + 8)\n \t      area_top = 16*UNITS_PER_WORD + 8*(i-16) + 8;\n-\t  } \n+\t  }\n     }\n \n   /* Check whether we can access the register save area.\n@@ -5811,7 +5811,7 @@ s390_emit_epilogue (bool sibcall)\n     {\n       for (i = 18; i < 20; i++)\n \tif (regs_ever_live[i] && !global_regs[i])\n-\t  restore_fpr (frame_pointer, \n+\t  restore_fpr (frame_pointer,\n \t\t       offset + 16*UNITS_PER_WORD + 8*(i-16), i);\n     }\n \n@@ -5855,7 +5855,7 @@ s390_emit_epilogue (bool sibcall)\n \t{\n \t  /* Fetch return address from stack before load multiple,\n \t     this will do good for scheduling.  */\n-\t  \n+\n \t  if (cfun->machine->save_return_addr_p\n \t      || (cfun->machine->first_restore_gpr < BASE_REGISTER\n \t\t  && cfun->machine->last_save_gpr > RETURN_REGNUM))\n@@ -5864,7 +5864,7 @@ s390_emit_epilogue (bool sibcall)\n \t      if (!return_regnum)\n \t\treturn_regnum = 4;\n \t      return_reg = gen_rtx_REG (Pmode, return_regnum);\n-\t      \n+\n \t      addr = plus_constant (frame_pointer,\n \t\t\t\t    offset + RETURN_REGNUM * UNITS_PER_WORD);\n \t      addr = gen_rtx_MEM (Pmode, addr);\n@@ -5889,9 +5889,9 @@ s390_emit_epilogue (bool sibcall)\n     {\n \n       /* Return to caller.  */\n-      \n+\n       p = rtvec_alloc (2);\n-      \n+\n       RTVEC_ELT (p, 0) = gen_rtx_RETURN (VOIDmode);\n       RTVEC_ELT (p, 1) = gen_rtx_USE (VOIDmode, return_reg);\n       emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, p));\n@@ -5979,13 +5979,13 @@ s390_function_arg_integer (enum machine_mode mode, tree type)\n \n   /* We accept small integral (and similar) types.  */\n   if (INTEGRAL_TYPE_P (type)\n-      || POINTER_TYPE_P (type) \n+      || POINTER_TYPE_P (type)\n       || TREE_CODE (type) == OFFSET_TYPE\n       || (TARGET_SOFT_FLOAT && TREE_CODE (type) == REAL_TYPE))\n     return true;\n \n   /* We also accept structs of size 1, 2, 4, 8 that are not\n-     passed in floating-point registers.  */  \n+     passed in floating-point registers.  */\n   if (AGGREGATE_TYPE_P (type)\n       && exact_log2 (size) >= 0\n       && !s390_function_arg_float (mode, type))\n@@ -6111,7 +6111,7 @@ s390_return_in_memory (tree type, tree fundecl ATTRIBUTE_UNUSED)\n {\n   /* We accept small integral (and similar) types.  */\n   if (INTEGRAL_TYPE_P (type)\n-      || POINTER_TYPE_P (type) \n+      || POINTER_TYPE_P (type)\n       || TREE_CODE (type) == OFFSET_TYPE\n       || TREE_CODE (type) == REAL_TYPE)\n     return int_size_in_bytes (type) > 8;\n@@ -6142,7 +6142,7 @@ s390_function_value (tree type, enum machine_mode mode)\n       mode = promote_mode (type, TYPE_MODE (type), &unsignedp, 1);\n     }\n \n-  if (GET_MODE_CLASS (mode) != MODE_INT \n+  if (GET_MODE_CLASS (mode) != MODE_INT\n       && GET_MODE_CLASS (mode) != MODE_FLOAT)\n     abort ();\n   if (GET_MODE_SIZE (mode) > 8)\n@@ -7042,7 +7042,7 @@ s390_call_saved_register_used (tree argument_list)\n \n       if (! (type = TREE_TYPE (parameter)))\n \tabort();\n-      \n+\n       if (! (mode = TYPE_MODE (TREE_TYPE (parameter))))\n \tabort();\n \n@@ -7051,15 +7051,15 @@ s390_call_saved_register_used (tree argument_list)\n  \t  mode = Pmode;\n  \t  type = build_pointer_type (type);\n  \t}\n-      \n+\n        parm_rtx = s390_function_arg (&cum, mode, type, 0);\n \n        s390_function_arg_advance (&cum, mode, type, 0);\n- \n+\n        if (parm_rtx && REG_P (parm_rtx))\n \t {\n \t   for (reg = 0;\n-\t\treg < HARD_REGNO_NREGS (REGNO (parm_rtx), GET_MODE (parm_rtx)); \n+\t\treg < HARD_REGNO_NREGS (REGNO (parm_rtx), GET_MODE (parm_rtx));\n \t\treg++)\n \t     if (! call_used_regs[reg + REGNO (parm_rtx)])\n \t       return true;\n@@ -7068,35 +7068,35 @@ s390_call_saved_register_used (tree argument_list)\n   return false;\n }\n \n-/* Return true if the given call expression can be \n-   turned into a sibling call.  \n+/* Return true if the given call expression can be\n+   turned into a sibling call.\n    DECL holds the declaration of the function to be called whereas\n    EXP is the call expression itself.  */\n-   \n+\n static bool\n s390_function_ok_for_sibcall (tree decl, tree exp)\n {\n   /* The TPF epilogue uses register 1.  */\n   if (TARGET_TPF)\n     return false;\n \n-  /* The 31 bit PLT code uses register 12 (GOT pointer - caller saved) \n+  /* The 31 bit PLT code uses register 12 (GOT pointer - caller saved)\n      which would have to be restored before the sibcall.  */\n   if (!TARGET_64BIT && flag_pic && decl && TREE_PUBLIC (decl))\n     return false;\n \n   /* Register 6 on s390 is available as an argument register but unfortunately\n      \"caller saved\". This makes functions needing this register for arguments\n-     not suitable for sibcalls.  */ \n+     not suitable for sibcalls.  */\n   if (TREE_OPERAND (exp, 1)\n       && s390_call_saved_register_used (TREE_OPERAND (exp, 1)))\n       return false;\n \n   return true;\n }\n \n-/* This function is used by the call expanders of the machine description. \n-   It emits the call insn itself together with the necessary operations \n+/* This function is used by the call expanders of the machine description.\n+   It emits the call insn itself together with the necessary operations\n    to adjust the target address and returns the emitted insn.\n    ADDR_LOCATION is the target address rtx\n    TLS_CALL the location of the thread-local symbol\n@@ -7106,7 +7106,7 @@ s390_function_ok_for_sibcall (tree decl, tree exp)\n                to be a sibling call.  */\n \n rtx\n-s390_emit_call (rtx addr_location, rtx tls_call, rtx result_reg, \n+s390_emit_call (rtx addr_location, rtx tls_call, rtx result_reg,\n \t\trtx retaddr_reg)\n {\n   bool plt_call = false;\n@@ -7122,13 +7122,13 @@ s390_emit_call (rtx addr_location, rtx tls_call, rtx result_reg,\n          replace the symbol itself with the PLT stub.  */\n       if (flag_pic && !SYMBOL_REF_LOCAL_P (addr_location))\n         {\n-\t  addr_location = gen_rtx_UNSPEC (Pmode, \n-\t\t\t\t\t  gen_rtvec (1, addr_location), \n+\t  addr_location = gen_rtx_UNSPEC (Pmode,\n+\t\t\t\t\t  gen_rtvec (1, addr_location),\n \t\t\t\t\t  UNSPEC_PLT);\n \t  addr_location = gen_rtx_CONST (Pmode, addr_location);\n \t  plt_call = true;\n         }\n-      \n+\n       /* Unless we can use the bras(l) insn, force the\n          routine address into a register.  */\n       if (!TARGET_SMALL_EXEC && !TARGET_CPU_ZARCH)\n@@ -7138,10 +7138,10 @@ s390_emit_call (rtx addr_location, rtx tls_call, rtx result_reg,\n \t  else\n \t    addr_location = force_reg (Pmode, addr_location);\n \t}\n-    } \n+    }\n \n   /* If it is already an indirect call or the code above moved the\n-     SYMBOL_REF to somewhere else make sure the address can be found in \n+     SYMBOL_REF to somewhere else make sure the address can be found in\n      register 1.  */\n   if (retaddr_reg == NULL_RTX\n       && GET_CODE (addr_location) != SYMBOL_REF\n@@ -7150,19 +7150,19 @@ s390_emit_call (rtx addr_location, rtx tls_call, rtx result_reg,\n       emit_move_insn (gen_rtx_REG (Pmode, SIBCALL_REGNUM), addr_location);\n       addr_location = gen_rtx_REG (Pmode, SIBCALL_REGNUM);\n     }\n-  \n+\n   addr_location = gen_rtx_MEM (QImode, addr_location);\n   call = gen_rtx_CALL (VOIDmode, addr_location, const0_rtx);\n \n   if (result_reg != NULL_RTX)\n     call = gen_rtx_SET (VOIDmode, result_reg, call);\n-    \n+\n   if (retaddr_reg != NULL_RTX)\n     {\n       clobber = gen_rtx_CLOBBER (VOIDmode, retaddr_reg);\n \n       if (tls_call != NULL_RTX)\n-\tvec = gen_rtvec (3, call, clobber, \n+\tvec = gen_rtvec (3, call, clobber,\n \t\t\t gen_rtx_USE (VOIDmode, tls_call));\n       else\n \tvec = gen_rtvec (2, call, clobber);\n@@ -7171,18 +7171,48 @@ s390_emit_call (rtx addr_location, rtx tls_call, rtx result_reg,\n     }\n \n   insn = emit_call_insn (call);\n- \n+\n   /* 31-bit PLT stubs and tls calls use the GOT register implicitly.  */\n   if ((!TARGET_64BIT && plt_call) || tls_call != NULL_RTX)\n     {\n-      /* s390_function_ok_for_sibcall should \n+      /* s390_function_ok_for_sibcall should\n \t have denied sibcalls in this case.  */\n       if (retaddr_reg == NULL_RTX)\n \tabort ();\n-      \n+\n       use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n     }\n   return insn;\n }\n \n+/* Implement CONDITIONAL_REGISTER_USAGE.  */\n+\n+void\n+s390_conditional_register_usage (void)\n+{\n+  int i;\n+\n+  if (flag_pic)\n+    {\n+      fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\n+      call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\n+    }\n+  if (TARGET_CPU_ZARCH)\n+    {\n+      fixed_regs[RETURN_REGNUM] = 0;\n+      call_used_regs[RETURN_REGNUM] = 0;\n+    }\n+  if (TARGET_64BIT)\n+    {\n+      for (i = 24; i < 32; i++)\n+\tcall_used_regs[i] = call_really_used_regs[i] = 0;\n+    }\n+  else\n+    {\n+      for (i = 18; i < 20; i++)\n+\tcall_used_regs[i] = call_really_used_regs[i] = 0;\n+    }\n+}\n+\n+\n #include \"gt-s390.h\""}, {"sha": "9c35632d8a53e5ee055573ec3160cddcc6cfdbf9", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38899e29e5f39c4589ac0bd2b4545b3caa8cff20/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38899e29e5f39c4589ac0bd2b4545b3caa8cff20/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=38899e29e5f39c4589ac0bd2b4545b3caa8cff20", "patch": "@@ -351,32 +351,7 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n   1, 1, 1, 1, \t\t\t\t\t\\\n   1, 1, 1 }\n \n-#define CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\\\n-    int i;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-    if (flag_pic)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tfixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n-\tcall_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    if (TARGET_CPU_ZARCH)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tfixed_regs[RETURN_REGNUM] = 0;\t\t\t\t\\\n-\tcall_used_regs[RETURN_REGNUM] = 0;\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    if (TARGET_64BIT)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-        for (i = 24; i < 32; i++)\t\t\t\t\\\n-\t    call_used_regs[i] = call_really_used_regs[i] = 0;\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-        for (i = 18; i < 20; i++)\t\t\t\t\\\n-\t    call_used_regs[i] = call_really_used_regs[i] = 0;\t\\\n-      }\t\t\t\t\t\t\t\t\\\n- } while (0)\n+#define CONDITIONAL_REGISTER_USAGE s390_conditional_register_usage ()\n \n /* Preferred register allocation order.  */\n #define REG_ALLOC_ORDER                                         \\"}]}