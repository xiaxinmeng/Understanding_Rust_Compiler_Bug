{"sha": "9e42b1920b40e5f1f2dd5443f48d28b38dd32af6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU0MmIxOTIwYjQwZTVmMWYyZGQ1NDQzZjQ4ZDI4YjM4ZGQzMmFmNg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2019-08-13T08:07:56Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-08-13T08:07:56Z"}, "message": "[Ada] Add conformance check on actual subp. in instance of child unit\n\nThis patch properly diagnoses a conformance error between a formal\nsubprogram and the corresponding actual, when the instance is that of a\nchild unit that is instantiated as a compilation unit. The error is\nnormally suppressed on an instantiation nested within another generic,\ngiven that analysis of the enclosing generic will have performed the\nconformance check on the nested instance already.  In the case of a\nchild unit, its instantiation requires an explicit check if it is a\ncompilation unit, because it has not been analyzed in the context of the\nparent generic.\n\nCompiling test.adb must yield:\n\n  container-list.ads:3:01: instantiation error at new_container_g-list_g.ads:12\n  container-list.ads:3:01: not mode conformant with declaration at types.ads:5\n  container-list.ads:3:01: mode of \"Self\" does not match\n\n----\nwith New_Container_G.List_G;\npragma Elaborate_All (New_Container_G.List_G);\npackage Container.List is new Container.List_G (Init => Types.Init_Object);\nwith Types;\nwith Erreur;\nwith New_Container_G;\n\npragma Elaborate_All (New_Container_G);\n\npackage Container is new New_Container_G (\n  Element_T      => Types.Integer_T,\n  Pos_Range_T    => Types.Integer_Idx_T,\n  Container_Name => Erreur.None);\npackage Erreur is\n   type Container_Name_T is (None, Everything);\nend;\n----\npackage body New_Container_G.List_G is\n\n  function Get_Element_At_Pos\n   (Self : access List_T;\n    Pos  : in     Index_Range_T)\n    return Element_Ptr is\n  begin\n    if not Self.T_Status (Pos) then\n      Erreur.Treat_Container_Error\n       (Error_Name     => Erreur.Element_Not_Valid,\n        Container_Name => Container_Name,\n        Procedure_Name => Erreur.Get_Element_Ptr_At_Pos,\n        Context        => Erreur.Null_Context_C);\n    end if;\n    return Pos;\n\n  end Get_Element_At_Pos;\n\n  function Get_Element_At_Pos\n   (Self : in List_T;\n    Pos  : in Index_Range_T)\n    return Element_T is\n  begin\n    if not Self.T_Status (Pos) then\n      Erreur.Treat_Container_Error\n       (Error_Name     => Erreur.Element_Not_Valid,\n        Container_Name => Container_Name,\n        Procedure_Name => Erreur.Get_Element_At_Pos,\n        Context        => Erreur.Null_Context_C);\n    end if;\n    return Self.Data (Pos);\n  end Get_Element_At_Pos;\n\n  procedure Add_New\n   (Self : in out List_T;\n    Pos  :    out Pos_Range_T) is\n\n    Free_Found : Boolean := False;\n  begin\n    if Self.First_Free = Rbc_Constants.Null_Pos then\n      Pos := Rbc_Constants.Null_Pos;\n    else\n      Self.Size                       := Self.Size + 1;\n      Self.T_Status (Self.First_Free) := True;\n      Pos                             := Self.First_Free;\n      Init (Self.Data (Pos));\n      if Self.First_Relevant not in\n         Rbc_Constants.Null_Pos + 1 .. Self.First_Free\n      then\n        Self.First_Relevant := Self.First_Free;\n      end if;\n\n      while not (Free_Found or Self.First_Free = Rbc_Constants.Null_Pos) loop\n        if Self.First_Free = Pos_Range_T'Last then\n          Self.First_Free := Rbc_Constants.Null_Pos;\n        else\n          Self.First_Free := Self.First_Free + 1;\n          if not Self.T_Status (Self.First_Free) then\n            Free_Found := True;\n          end if;\n        end if;\n      end loop;\n    end if;\n  end Add_New;\n\n  procedure Add_New_At_Pos\n   (Self : in out List_T;\n    Pos  : in out Index_Range_T) is\n\n    Free_Found : Boolean := False;\n  begin\n    if Self.T_Status (Pos) then\n      Erreur.Treat_Container_Error\n       (Error_Name     => Erreur.Element_Not_Valid,\n        Container_Name => Container_Name,\n        Procedure_Name => Erreur.Add_New_At_Pos,\n        Context        => Erreur.Null_Context_C);\n    else\n      Self.Size           := Self.Size + 1;\n      Self.T_Status (Pos) := True;\n      Init (Self.Data (Pos));\n      if Self.First_Relevant = Rbc_Constants.Null_Pos\n        or Pos < Self.First_Relevant\n      then\n        Self.First_Relevant := Pos;\n      end if;\n      if Self.First_Free = Pos\n      then\n        -- Look for a new First_Free\n        while not (Free_Found or Self.First_Free = Rbc_Constants.Null_Pos) loop\n          if Self.First_Free = Pos_Range_T'Last then\n            Self.First_Free := Rbc_Constants.Null_Pos;\n          else\n            Self.First_Free := Self.First_Free + 1;\n            if not Self.T_Status (Self.First_Free) then\n              Free_Found := True;\n            end if;\n          end if;\n        end loop;\n      end if;\n      -------------------------------------------------------------------------\n    end if;\n  end Add_New_At_Pos;\n\n  procedure Clear (Self : out List_T) is\n  begin\n    Self.T_Status       := (others => False);\n    Self.First_Free     := Init_First_Free;\n    Self.First_Relevant := Rbc_Constants.Null_Pos;\n    Self.Size           := Empty;\n  end Clear;\n\n  procedure Remove_Element_At_Pos\n   (Self : in out List_T;\n    Pos  : in     Index_Range_T) is\n\n    Relevant_Found : Boolean := False;\n  begin\n    -- REMOVE ITEM IF VALID ---------------------------------------------\n    if not Self.T_Status (Pos) then\n      Erreur.Treat_Container_Error\n       (Error_Name     => Erreur.Element_Not_Valid,\n        Container_Name => Container_Name,\n        Procedure_Name => Erreur.Remove_Element_At_Pos,\n        Context        => Erreur.Null_Context_C);\n    end if;\n\n    Self.Size := Self.Size - 1;\n\n    Self.T_Status (Pos) := False;\n    if Self.First_Free not in Rbc_Constants.Null_Pos + 1 .. Pos then\n      Self.First_Free := Pos;\n    end if;\n\n    -- UPDATE FIRST_RELEVANT IF NECESSARY -----------------------------------\n    if Self.First_Relevant = Pos then\n      while\n        not (Relevant_Found or Self.First_Relevant = Rbc_Constants.Null_Pos)\n      loop\n        if Self.First_Relevant = Pos_Range_T'Last then\n          Self.First_Relevant := Rbc_Constants.Null_Pos;\n        else\n          Self.First_Relevant := Self.First_Relevant + 1;\n          if Self.T_Status (Self.First_Relevant) then\n            Relevant_Found := True;\n          end if;\n        end if;\n      end loop;\n    end if;\n    -------------------------------------------------------------------------\n  end Remove_Element_At_Pos;\n\n  procedure Next\n   (It   : in out Iterator_T;\n    Self : in     List_T) is\n\n    Relevant_Found : Boolean := False;\n  begin\n    if It = Rbc_Constants.Null_Pos then\n      Erreur.Treat_Container_Error\n       (Error_Name     => Erreur.Iterator_Not_Valid,\n        Container_Name => Container_Name,\n        Procedure_Name => Erreur.Next,\n        Context        => Erreur.Null_Context_C);\n    end if;\n    while not (Relevant_Found or It = Rbc_Constants.Null_Pos) loop\n      if It = Pos_Range_T'Last then\n        It := Rbc_Constants.Null_Pos;\n      else\n        It := It + 1;\n        if Self.T_Status (It) then\n          Relevant_Found := True;\n        end if;\n      end if;\n    end loop;\n  end Next;\n\n  function New_Iterator\n   (Self : in List_T)\n    return Iterator_T is\n  begin\n    return Self.First_Relevant;\n  end New_Iterator;\n\n  function Get\n   (It   : in     Iterator_T;\n    Self : in     List_T)\n    return Element_Ptr is\n  begin\n    if It = Rbc_Constants.Null_Pos or else not Self.T_Status (It) then\n      Erreur.Treat_Container_Error\n       (Error_Name     => Erreur.Iterator_Not_Valid,\n        Container_Name => Container_Name,\n        Procedure_Name => Erreur.Get_Ptr,\n        Context        => Erreur.Null_Context_C);\n    end if;\n    return It;\n  end Get;\n\n  function Get\n   (It   : in Iterator_T;\n    Self : in List_T)\n    return Element_T is\n  begin\n    if It = Rbc_Constants.Null_Pos or else not Self.T_Status (It) then\n      Erreur.Treat_Container_Error\n       (Error_Name     => Erreur.Iterator_Not_Valid,\n        Container_Name => Container_Name,\n        Procedure_Name => Erreur.Get,\n        Context        => Erreur.Null_Context_C);\n    end if;\n    return Self.Data (It);\n  end Get;\n\n  function Getstatus\n   (Self : in List_T;\n    Pos  : in Index_Range_T)\n    return Boolean is\n  begin\n    return Self.T_Status (Pos);\n  end Getstatus;\n\n  function Init_First_Free return Pos_Range_T is\n    First_Free_Value : Pos_Range_T;\n  begin\n    if Full = Rbc_Constants.Null_Pos then\n      -- size is 0\n      First_Free_Value := Rbc_Constants.Null_Pos;\n    else\n      -- first free cell index is 1\n      First_Free_Value := Index_Range_T'First;\n    end if;\n    return First_Free_Value;\n  end Init_First_Free;\n\nend New_Container_G.List_G;\n\nwith Rbc_Constants;\n\ngeneric\n\n  with procedure Init (Self : out Element_T);\n\npackage New_Container_G.List_G is\n\n  type List_T is new Container_T with private;\n\n  function Get_Element_At_Pos\n   (Self : access List_T;\n    Pos  : in     Index_Range_T)\n    return Element_Ptr;\n\n  function Get_Element_At_Pos\n   (Self : in List_T;\n    Pos  : in Index_Range_T)\n    return Element_T;\n\n  procedure Add_New\n   (Self : in out List_T;\n    Pos  :    out Pos_Range_T);\n\n  procedure Add_New_At_Pos\n   (Self : in out List_T;\n    Pos  : in out Index_Range_T);\n\n  procedure Clear (Self : out List_T);\n\n  procedure Remove_Element_At_Pos\n   (Self : in out List_T;\n    Pos  : in     Index_Range_T);\n\n  procedure Next\n   (It   : in out Iterator_T;\n    Self : in     List_T);\n\n  function New_Iterator\n   (Self : in List_T)\n    return Iterator_T;\n\n  function Get\n   (It   : in     Iterator_T;\n    Self : in     List_T)\n    return Element_Ptr;\n\n  function Get\n   (It   : in Iterator_T;\n    Self : in List_T)\n    return Element_T;\n\n  function Getstatus\n   (Self : in List_T;\n    Pos  : in Index_Range_T)\n    return Boolean;\n\nprivate\n\n  function Init_First_Free return Pos_Range_T;\n\n  type Status_Array_T is array (Index_Range_T) of Boolean;\n\n  type List_T is new Container_T with\n    record\n      T_Status       : Status_Array_T := (others => False);\n      First_Free     : Pos_Range_T    := Init_First_Free;\n      First_Relevant : Pos_Range_T    := Rbc_Constants.Null_Pos;\n    end record;\n\nend New_Container_G.List_G;\n\nwith Types_Alstom; use Types_Alstom;\nwith Rbc_Constants;\n\npackage body New_Container_G is\n\n  function Done\n   (It   : in Iterator_T;\n    Self : in Container_T)\n    return Boolean is\n    pragma Unreferenced (Self);\n    Report : Boolean;\n  begin\n    if It = Rbc_Constants.Null_Pos then\n      Report := True;\n    else\n      Report := False;\n    end if;\n    return Report;\n  end Done;\n\n  procedure Execute (Self      : in out Container_T'class;\n                     This_Proc : in Proc_Access_T) is\n  begin\n    for I in Self.Data'First .. Self.Size loop\n      This_Proc (Self.Data (I));\n    end loop;\n  end Execute;\n\n  procedure Execute (Self      : in out Container_T'class;\n                     This_Proc : in Proc_Idx_Access_T) is\n  begin\n    for I in Self.Data'First .. Self.Size loop\n      This_Proc (Self.Data (I), I);\n    end loop;\n  end Execute;\n\n  function Selected_Subset\n   (Self : in Container_T'Class;\n    Ref  : in Reference_T)\n    return Element_Set_T is\n    Set     : Element_Set_T := (others => Rbc_Constants.Null_Pos);\n    Current : Pos_Range_T   := 0;\n\n  begin\n    for I in Self.Data'Range loop\n      if Getstatus (Self, I) and then Is_Selected\n                                           (Elem => Self.Data (I),\n                                            Ref  => Ref)\n      then\n        Current       := Current + 1;\n        Set (Current) := I;\n      end if;\n    end loop;\n    return Set;\n  end Selected_Subset;\n\n  function Selected_Element\n   (Self : in Container_T'Class;\n    Ref  : in Reference_T)\n    return Element_Ptr is\n  begin\n    for I in Self.Data'Range loop\n      if Getstatus (Self, I) and then Is_Selected\n                                           (Elem => Self.Data (I),\n                                            Ref  => Ref)\n      then\n        return I;\n      end if;\n    end loop;\n    return Rbc_Constants.Null_Pos;\n  end Selected_Element;\n\n  function Getsize\n   (Self : in Container_T)\n    return Pos_Range_T is\n  begin\n    return Self.Size;\n  end Getsize;\n\nend New_Container_G;\n\nwith Types;\nwith Erreur;\n\ngeneric\n\n  -- Type of element to be stored\n  type Element_T is private;\n  type Pos_Range_T is range <>;\n  Container_Name : in Erreur.Container_Name_T;\n\npackage New_Container_G is\n  pragma Unreferenced (Container_Name);\n\n  subtype Element_Acc_T is Pos_Range_T;\n\n  subtype Element_Ptr is Element_Acc_T;   -- for compatibility\n\n  subtype Iterator_T is Pos_Range_T;\n\n  subtype Index_Range_T is Pos_Range_T range 1 .. Pos_Range_T'Last;\n\n  type Element_Set_T is array (Index_Range_T) of Element_Ptr;\n\n  Full  : constant Pos_Range_T := Pos_Range_T'Last;\n  Empty : constant Pos_Range_T := Pos_Range_T'First;\n  type Element_Array_T is array (Index_Range_T) of Element_T;\n  type Container_T is abstract tagged\n    record\n      Data : Element_Array_T;\n      Size : Pos_Range_T := Empty;\n    end record;\n\n  function Get\n   (It   : in Iterator_T;\n    Self : in Container_T)\n    return Element_Ptr is abstract;\n\n  function Get\n   (It   : in Iterator_T;\n    Self : in Container_T)\n    return Element_T is abstract;\n\n  procedure Next\n   (It   : in out Iterator_T;\n    Self : in Container_T) is abstract;\n\n  function Done\n   (It   : in Iterator_T;\n    Self : in Container_T)\n    return Boolean;\n\n  type Proc_Access_T is access procedure (Elem  : in out Element_T);\n  type Proc_Idx_Access_T is access procedure (Elem  : in out Element_T;\n                                              Idx   : in Index_Range_T);\n  procedure Execute (Self      : in out Container_T'class;\n                     This_Proc : in Proc_Access_T);\n  procedure Execute (Self      : in out Container_T'class;\n                     This_Proc : in Proc_Idx_Access_T);\n\n  function Getstatus\n   (Self : in Container_T;\n    Pos  : in Index_Range_T)\n    return Boolean is abstract;\n\n  generic\n    -- Type of the parameter of the is_selected () function.\n    type Reference_T is private;\n    with function Is_Selected\n     (Elem : in Element_T;\n      Ref  : in Reference_T)\n      return Boolean;\n  function Selected_Subset\n   (Self : in Container_T'Class;\n    Ref  : in Reference_T)\n    return Element_Set_T;\n\n  generic\n    -- Type of the parameter of the is_selected () function.\n    type Reference_T is private;\n    with function Is_Selected\n     (Elem : in Element_T;\n      Ref  : in Reference_T)\n      return Boolean;\n  function Selected_Element\n   (Self : in Container_T'Class;\n    Ref  : in Reference_T)\n    return Element_Ptr;\n\n  function Getsize\n   (Self : in Container_T)\n    return Pos_Range_T;\n\nend New_Container_G;\n----\npackage Rbc_Constants is\n  Null_Pos      : constant := 0;\n  Irrelevant_Id : constant String := \"                \";\n  Nmax_Mc_Bits  : constant := 32;\nend Rbc_Constants;\nwith Ada.Text_IO;\nwith Types;\nwith Container.List;\n\nprocedure Test is\n\n  List : Container.List.List_T;\n  Pos  : Types.Integer_Idx_T;\nbegin\n  Container.List.Add_New (Self => List,\n                          Pos  => Pos);\n\n  Ada.Text_IO.Put_Line (\"no exception raised\");\nend Test;\npackage Types is\n  type Integer_T     is range -1000 .. 1000;\n  type Integer_Idx_T is range     0 .. 100;\n\n  procedure Init_Object (Elem : in Integer_T);\n\nend Types;\n\n2019-08-13  Ed Schonberg  <schonberg@adacore.com>\n\ngcc/ada/\n\n\t* sem_ch8.adb (Analyze_Subprogram_Renaming): Do no suppress mode\n\tconformance checks on child unit instance that is a compilation\n\tunit.\n\nFrom-SVN: r274350", "tree": {"sha": "da8bebdc5b20dcf781900ce6695fdbde43be5d13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da8bebdc5b20dcf781900ce6695fdbde43be5d13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e42b1920b40e5f1f2dd5443f48d28b38dd32af6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e42b1920b40e5f1f2dd5443f48d28b38dd32af6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e42b1920b40e5f1f2dd5443f48d28b38dd32af6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e42b1920b40e5f1f2dd5443f48d28b38dd32af6/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "93bfc8c003e7367f0f873b566833a12c092b2755", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93bfc8c003e7367f0f873b566833a12c092b2755", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93bfc8c003e7367f0f873b566833a12c092b2755"}], "stats": {"total": 17, "additions": 16, "deletions": 1}, "files": [{"sha": "bd3450fffd1133ec8867c2f70010d80c0cf99634", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e42b1920b40e5f1f2dd5443f48d28b38dd32af6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e42b1920b40e5f1f2dd5443f48d28b38dd32af6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9e42b1920b40e5f1f2dd5443f48d28b38dd32af6", "patch": "@@ -1,3 +1,9 @@\n+2019-08-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch8.adb (Analyze_Subprogram_Renaming): Do no suppress mode\n+\tconformance checks on child unit instance that is a compilation\n+\tunit.\n+\n 2019-08-13  Gary Dismukes  <dismukes@adacore.com>\n \n \t* exp_dbug.adb (Fully_Qualify_Name): Add full name qualification"}, {"sha": "38c3980278da9eb204e2008873e1f50e2c434615", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e42b1920b40e5f1f2dd5443f48d28b38dd32af6/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e42b1920b40e5f1f2dd5443f48d28b38dd32af6/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=9e42b1920b40e5f1f2dd5443f48d28b38dd32af6", "patch": "@@ -3368,7 +3368,16 @@ package body Sem_Ch8 is\n \n             if CW_Actual then\n                null;\n-            elsif not Is_Actual or else No (Enclosing_Instance) then\n+\n+            --  No need for a redundant error message if this is a nested\n+            --  instance, unless the current instantiation (of a child unit)\n+            --  is a compilation unit, which is not analyzed when the parent\n+            --  generic is analyzed.\n+\n+            elsif not Is_Actual\n+               or else No (Enclosing_Instance)\n+               or else Is_Compilation_Unit (Current_Scope)\n+            then\n                Check_Mode_Conformant (New_S, Old_S);\n             end if;\n "}]}