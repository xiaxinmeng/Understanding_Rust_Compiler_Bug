{"sha": "f5dc9da0a97734ab68a4af34875640ed1ca0c7d1", "node_id": "C_kwDOANBUbNoAKGY1ZGM5ZGEwYTk3NzM0YWI2OGE0YWYzNDg3NTY0MGVkMWNhMGM3ZDE", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-09-06T06:20:54Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-09-06T11:48:05Z"}, "message": "Handle > INF and < INF correctly in range-op-float.cc\n\nThe gfortran.dg/minlocval*.f90 tests are generating conditionals past\nthe infinities.  For example:\n\n\tif (x <= +Inf)\n\t  foo (x);\n\telse\n\t  bar (x);\n\nIt seems to me that the only possible value for x on the false side is\neither NAN or undefined (for !HONOR_NANS).\n\ngcc/ChangeLog:\n\n\t* range-op-float.cc (build_le): Handle NANs and going past infinity.\n\t(build_lt): Same.\n\t(build_ge): Same.\n\t(build_gt): Same.\n\t(foperator_lt::op1_range): Avoid adjustments to range if build_*\n\treturned false.\n\t(foperator_lt::op2_range): Same.\n\t(foperator_le::op1_range): Same.\n\t(foperator_le::op2_range): Same.\n\t(foperator_gt::op1_range): Same.\n\t(foperator_gt::op2_range): Same.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/vrp-float-inf-1.c: New test.", "tree": {"sha": "0a12434812602043f5a5c46af92ca82357d9a609", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a12434812602043f5a5c46af92ca82357d9a609"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5dc9da0a97734ab68a4af34875640ed1ca0c7d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5dc9da0a97734ab68a4af34875640ed1ca0c7d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5dc9da0a97734ab68a4af34875640ed1ca0c7d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5dc9da0a97734ab68a4af34875640ed1ca0c7d1/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12f0783111067b68673284665a886cdd0c8f55c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f0783111067b68673284665a886cdd0c8f55c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12f0783111067b68673284665a886cdd0c8f55c3"}], "stats": {"total": 114, "additions": 90, "deletions": 24}, "files": [{"sha": "5fbbaa1fb36f4a32bae88e92115a4e4f62bfbb38", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 75, "deletions": 24, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5dc9da0a97734ab68a4af34875640ed1ca0c7d1/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5dc9da0a97734ab68a4af34875640ed1ca0c7d1/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=f5dc9da0a97734ab68a4af34875640ed1ca0c7d1", "patch": "@@ -224,36 +224,79 @@ frange_drop_ninf (frange &r, tree type)\n \n // (X <= VAL) produces the range of [-INF, VAL].\n \n-static void\n+static bool\n build_le (frange &r, tree type, const REAL_VALUE_TYPE &val)\n {\n+  if (real_isnan (&val))\n+    {\n+      r.set_undefined ();\n+      return false;\n+    }\n   r.set (type, dconstninf, val);\n+  return true;\n }\n \n // (X < VAL) produces the range of [-INF, VAL).\n \n-static void\n+static bool\n build_lt (frange &r, tree type, const REAL_VALUE_TYPE &val)\n {\n+  if (real_isnan (&val))\n+    {\n+      r.set_undefined ();\n+      return false;\n+    }\n+  // < -INF is outside the range.\n+  if (real_isinf (&val, 1))\n+    {\n+      if (HONOR_NANS (type))\n+\tfrange_set_nan (r, type);\n+      else\n+\tr.set_undefined ();\n+      return false;\n+    }\n   // Hijack LE because we only support closed intervals.\n   build_le (r, type, val);\n+  return true;\n }\n \n // (X >= VAL) produces the range of [VAL, +INF].\n \n-static void\n+static bool\n build_ge (frange &r, tree type, const REAL_VALUE_TYPE &val)\n {\n+  if (real_isnan (&val))\n+    {\n+      r.set_undefined ();\n+      return false;\n+    }\n   r.set (type, val, dconstinf);\n+  return true;\n }\n \n // (X > VAL) produces the range of (VAL, +INF].\n \n-static void\n+static bool\n build_gt (frange &r, tree type, const REAL_VALUE_TYPE &val)\n {\n+  if (real_isnan (&val))\n+    {\n+      r.set_undefined ();\n+      return false;\n+    }\n+  // > +INF is outside the range.\n+  if (real_isinf (&val, 0))\n+    {\n+      if (HONOR_NANS (type))\n+\tfrange_set_nan (r, type);\n+      else\n+\tr.set_undefined ();\n+      return false;\n+    }\n+\n   // Hijack GE because we only support closed intervals.\n   build_ge (r, type, val);\n+  return true;\n }\n \n \n@@ -520,10 +563,12 @@ foperator_lt::op1_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      build_lt (r, type, op2.upper_bound ());\n-      r.set_nan (fp_prop::NO);\n-      // x < y implies x is not +INF.\n-      frange_drop_inf (r, type);\n+      if (build_lt (r, type, op2.upper_bound ()))\n+\t{\n+\t  r.set_nan (fp_prop::NO);\n+\t  // x < y implies x is not +INF.\n+\t  frange_drop_inf (r, type);\n+\t}\n       break;\n \n     case BRS_FALSE:\n@@ -546,10 +591,12 @@ foperator_lt::op2_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      build_gt (r, type, op1.lower_bound ());\n-      r.set_nan (fp_prop::NO);\n-      // x < y implies y is not -INF.\n-      frange_drop_ninf (r, type);\n+      if (build_gt (r, type, op1.lower_bound ()))\n+\t{\n+\t  r.set_nan (fp_prop::NO);\n+\t  // x < y implies y is not -INF.\n+\t  frange_drop_ninf (r, type);\n+\t}\n       break;\n \n     case BRS_FALSE:\n@@ -618,8 +665,8 @@ foperator_le::op1_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      build_le (r, type, op2.upper_bound ());\n-      r.set_nan (fp_prop::NO);\n+      if (build_le (r, type, op2.upper_bound ()))\n+\tr.set_nan (fp_prop::NO);\n       break;\n \n     case BRS_FALSE:\n@@ -642,8 +689,8 @@ foperator_le::op2_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      build_ge (r, type, op1.lower_bound ());\n-      r.set_nan (fp_prop::NO);\n+      if (build_ge (r, type, op1.lower_bound ()))\n+\tr.set_nan (fp_prop::NO);\n       break;\n \n     case BRS_FALSE:\n@@ -712,10 +759,12 @@ foperator_gt::op1_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      build_gt (r, type, op2.lower_bound ());\n-      r.set_nan (fp_prop::NO);\n-      // x > y implies x is not -INF.\n-      frange_drop_ninf (r, type);\n+      if (build_gt (r, type, op2.lower_bound ()))\n+\t{\n+\t  r.set_nan (fp_prop::NO);\n+\t  // x > y implies x is not -INF.\n+\t  frange_drop_ninf (r, type);\n+\t}\n       break;\n \n     case BRS_FALSE:\n@@ -738,10 +787,12 @@ foperator_gt::op2_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      build_lt (r, type, op1.upper_bound ());\n-      r.set_nan (fp_prop::NO);\n-      // x > y implies y is not +INF.\n-      frange_drop_inf (r, type);\n+      if (build_lt (r, type, op1.upper_bound ()))\n+\t{\n+\t  r.set_nan (fp_prop::NO);\n+\t  // x > y implies y is not +INF.\n+\t  frange_drop_inf (r, type);\n+\t}\n       break;\n \n     case BRS_FALSE:"}, {"sha": "1d21cce41e63b6179a6980aebd2afa10bf98b5b6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp-float-inf-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5dc9da0a97734ab68a4af34875640ed1ca0c7d1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-inf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5dc9da0a97734ab68a4af34875640ed1ca0c7d1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-inf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-inf-1.c?ref=f5dc9da0a97734ab68a4af34875640ed1ca0c7d1", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fdump-tree-evrp-details\" }\n+\n+void foo ();\n+void bar (double);\n+\n+void funky(double f, double g)\n+{\n+  if (f <= __builtin_inf ())\n+    foo ();\n+  else\n+    bar (f);\n+}\n+\n+// { dg-final { scan-tree-dump-not \" Inf,  Inf\" \"evrp\" } }"}]}