{"sha": "d82797420c2238e31a7a25fe6db6bd05cd37224d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgyNzk3NDIwYzIyMzhlMzFhN2EyNWZlNmRiNmJkMDVjZDM3MjI0ZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-03-26T17:46:31Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-03-26T19:08:42Z"}, "message": "c++: imported templates and alias-template changes [PR 99283]\n\nDuring development of modules, I had difficulty deciding whether the\nmodule flags of a template should live on the decl_template_result,\nthe template_decl, or both.  I chose the latter, and require them to\nbe consistent.  This and a few other defects show how hard that\nconsistency is.  Hence this patch move to holding the flags on the\ntemplate-decl-result decl.  That's the entity various bits of the\nparser have at the appropriate time.   Once needs STRIP_TEMPLATE in a\nbunch of places, which this patch adds.  Also a check that we never\ngive a TEMPLATE_DECL to the module flag accessors.\n\nThis left a problem with how I was handling template aliases.  These\nwere in two parts -- separating the TEMPLATE_DECL from the TYPE_DECL.\nThat seemed somewhat funky, but development showed it necessary.  Of\ncourse, that causes problems if the TEMPLATE_DECL cannot contain 'am\nimported' information.  Investigating now shows that we do not need to\ntreat them separately.  By reverting a bit of template instantiation\nmachinery that caused the problem, we're back on course.  I think what\nhas happened is that between then and now, other typedef fixes have\ncorrected the underlying problem this separation was working around.\nIt allows a bunch of cleanup in the decl streamer, as we no longer\nhave to handle a null TEMPLATE_DECL_RESULT.\n\n\tPR c++/99283\n\tgcc/cp/\n\t* cp-tree.h (DECL_MODULE_CHECK): Ban TEMPLATE_DECL.\n\t(SET_TYPE_TEMPLATE_INFO): Restore Alias template setting.\n\t* decl.c (duplicate_decls): Remove template_decl module flag\n\tpropagation.\n\t* module.cc (merge_kind_name): Add alias tmpl spec as a thing.\n\t(dumper::impl::nested_name): Adjust for template-decl module flag\n\tchange.\n\t(trees_in::assert_definition): Likewise.\n\t(trees_in::install_entity): Likewise.\n\t(trees_out::decl_value): Likewise.  Remove alias template\n\tseparation of template and type_decl.\n\t(trees_in::decl_value): Likewise.\n\t(trees_out::key_mergeable): Likewise,\n\t(trees_in::key_mergeable): Likewise.\n\t(trees_out::decl_node): Adjust for template-decl module flag\n\tchange.\n\t(depset::hash::make_dependency): Likewise.\n\t(get_originating_module, module_may_redeclare): Likewise.\n\t(set_instantiating_module, set_defining_module): Likewise.\n\t* name-lookup.c (name_lookup::search_adl): Likewise.\n\t(do_pushdecl): Likewise.\n\t* pt.c (build_template_decl): Likewise.\n\t(lookup_template_class_1): Remove special alias_template handling\n\tof DECL_TI_TEMPLATE.\n\t(tsubst_template_decl): Likewise.\n\tgcc/testsuite/\n\t* g++.dg/modules/pr99283-2_a.H: New.\n\t* g++.dg/modules/pr99283-2_b.H: New.\n\t* g++.dg/modules/pr99283-2_c.H: New.\n\t* g++.dg/modules/pr99283-3_a.H: New.\n\t* g++.dg/modules/pr99283-3_b.H: New.\n\t* g++.dg/modules/pr99283-4.H: New.\n\t* g++.dg/modules/tpl-alias-1_a.H: Adjust scans.\n\t* g++.dg/modules/tpl-alias-1_b.C: Adjust scans.", "tree": {"sha": "d96ced1ff9c322b7dbf153cd00c78eeca03884ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d96ced1ff9c322b7dbf153cd00c78eeca03884ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d82797420c2238e31a7a25fe6db6bd05cd37224d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d82797420c2238e31a7a25fe6db6bd05cd37224d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d82797420c2238e31a7a25fe6db6bd05cd37224d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d82797420c2238e31a7a25fe6db6bd05cd37224d/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c314741a539244a947b94ac045611746c0f072e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c314741a539244a947b94ac045611746c0f072e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c314741a539244a947b94ac045611746c0f072e0"}], "stats": {"total": 504, "additions": 259, "deletions": 245}, "files": [{"sha": "9535910fd4ea2621f667aabebc40a399e861c659", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d82797420c2238e31a7a25fe6db6bd05cd37224d", "patch": "@@ -1661,9 +1661,11 @@ check_constraint_info (tree t)\n #define CONSTRAINED_PARM_PROTOTYPE(NODE) \\\n   DECL_INITIAL (TYPE_DECL_CHECK (NODE))\n \n-/* Module defines.  */\n-// Too many _DECLS: FUNCTION,VAR,TYPE,TEMPLATE,CONCEPT or NAMESPACE\n-#define DECL_MODULE_CHECK(NODE) (NODE)\n+/* Module flags on FUNCTION,VAR,TYPE,CONCEPT or NAMESPACE\n+   A TEMPLATE_DECL holds them on the DECL_TEMPLATE_RESULT object --\n+   it's just not practical to keep them consistent.  */\n+#define DECL_MODULE_CHECK(NODE)\t\t\t\t\t\t\\\n+  TREE_NOT_CHECK (NODE, TEMPLATE_DECL)\n \n /* In the purview of a module (including header unit).  */\n #define DECL_MODULE_PURVIEW_P(N) \\\n@@ -3626,9 +3628,10 @@ struct GTY(()) lang_decl {\n /* Set the template information for a non-alias n ENUMERAL_, RECORD_,\n    or UNION_TYPE to VAL.  ALIAS's are dealt with separately.  */\n #define SET_TYPE_TEMPLATE_INFO(NODE, VAL)\t\t\t\t\\\n-  (gcc_checking_assert (TREE_CODE (NODE) == ENUMERAL_TYPE\t\t\\\n-\t\t\t|| (CLASS_TYPE_P (NODE) && !TYPE_ALIAS_P (NODE))), \\\n-   (TYPE_LANG_SLOT_1 (NODE) = (VAL)))\t\t\t\t\t\\\n+  (TREE_CODE (NODE) == ENUMERAL_TYPE\t\t\\\n+   || (CLASS_TYPE_P (NODE) && !TYPE_ALIAS_P (NODE))\t\t\t\\\n+   ? (TYPE_LANG_SLOT_1 (NODE) = (VAL))\t\t\t\t\t\\\n+   : (DECL_TEMPLATE_INFO (TYPE_NAME (NODE)) = (VAL)))\t\t\t\\\n \n #define TI_TEMPLATE(NODE) \\\n   ((struct tree_template_info*)TEMPLATE_INFO_CHECK (NODE))->tmpl"}, {"sha": "6789aa859cc8858ed1db3667023c9ffc5a5f8406", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d82797420c2238e31a7a25fe6db6bd05cd37224d", "patch": "@@ -2275,10 +2275,6 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)\n \t    }\n \t}\n \n-      DECL_MODULE_IMPORT_P (olddecl)\n-\t= DECL_MODULE_IMPORT_P (old_result)\n-\t= DECL_MODULE_IMPORT_P (newdecl);\n-\n       return olddecl;\n     }\n \n@@ -2931,19 +2927,6 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)\n \t}\n     }\n \n-  if (DECL_LANG_SPECIFIC (olddecl) && DECL_TEMPLATE_INFO (olddecl))\n-    {\n-      /* Repropagate the module information to the template.  */\n-      tree tmpl = DECL_TI_TEMPLATE (olddecl);\n-\n-      if (DECL_TEMPLATE_RESULT (tmpl) == olddecl)\n-\t{\n-\t  DECL_MODULE_PURVIEW_P (tmpl) = DECL_MODULE_PURVIEW_P (olddecl);\n-\t  gcc_checking_assert (!DECL_MODULE_IMPORT_P (olddecl));\n-\t  DECL_MODULE_IMPORT_P (tmpl) = false;\n-\t}\n-    }\n-\n   if (VAR_OR_FUNCTION_DECL_P (newdecl))\n     {\n       if (DECL_EXTERNAL (olddecl)"}, {"sha": "8a1cfbdfdcb4b6ccc4e6cae9047499c0d230ddb1", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 113, "deletions": 171, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=d82797420c2238e31a7a25fe6db6bd05cd37224d", "patch": "@@ -2797,7 +2797,7 @@ static char const *const merge_kind_name[MK_hwm] =\n     NULL, NULL,\n \n     \"decl spec\", \"decl tmpl spec\",\t/* 20,21 decl (template).  */\n-    \"alias spec\", NULL,\t\t\t/* 22,23 alias. */\n+    \"alias spec\", \"alias tmpl spec\",\t/* 22,23 alias (template). */\n     NULL, NULL, NULL, NULL,\n     NULL, NULL, NULL, NULL,\n   };\n@@ -4144,10 +4144,17 @@ dumper::impl::nested_name (tree t)\n       if (ti && TREE_CODE (TI_TEMPLATE (ti)) == TEMPLATE_DECL\n \t  && (DECL_TEMPLATE_RESULT (TI_TEMPLATE (ti)) == t))\n \tt = TI_TEMPLATE (ti);\n+      tree not_tmpl = t;\n       if (TREE_CODE (t) == TEMPLATE_DECL)\n-\tfputs (\"template \", stream);\n+\t{\n+\t  fputs (\"template \", stream);\n+\t  not_tmpl = DECL_TEMPLATE_RESULT (t);\n+\t}\n \n-      if (DECL_LANG_SPECIFIC (t) && DECL_MODULE_IMPORT_P (t))\n+      if (not_tmpl\n+\t  && DECL_P (not_tmpl)\n+\t  && DECL_LANG_SPECIFIC (not_tmpl)\n+\t  && DECL_MODULE_IMPORT_P (not_tmpl))\n \t{\n \t  /* We need to be careful here, so as to not explode on\n \t     inconsistent data -- we're probably debugging, because\n@@ -4484,9 +4491,9 @@ trees_in::assert_definition (tree decl ATTRIBUTE_UNUSED,\n     gcc_assert (!is_duplicate (decl)\n \t\t? !slot\n \t\t: (slot\n-\t\t   || !DECL_LANG_SPECIFIC (decl)\n-\t\t   || !DECL_MODULE_PURVIEW_P (decl)\n-\t\t   || (!DECL_MODULE_IMPORT_P (decl)\n+\t\t   || !DECL_LANG_SPECIFIC (STRIP_TEMPLATE (decl))\n+\t\t   || !DECL_MODULE_PURVIEW_P (STRIP_TEMPLATE (decl))\n+\t\t   || (!DECL_MODULE_IMPORT_P (STRIP_TEMPLATE (decl))\n \t\t       && header_module_p ())));\n \n   if (TREE_CODE (decl) == TEMPLATE_DECL)\n@@ -7445,11 +7452,12 @@ trees_in::install_entity (tree decl)\n   (*entity_ary)[ident] = decl;\n \n   /* And into the entity map, if it's not already there.  */\n-  if (!DECL_LANG_SPECIFIC (decl)\n-      || !DECL_MODULE_ENTITY_P (decl))\n+  tree not_tmpl = STRIP_TEMPLATE (decl);\n+  if (!DECL_LANG_SPECIFIC (not_tmpl)\n+      || !DECL_MODULE_ENTITY_P (not_tmpl))\n     {\n-      retrofit_lang_decl (decl);\n-      DECL_MODULE_ENTITY_P (decl) = true;\n+      retrofit_lang_decl (not_tmpl);\n+      DECL_MODULE_ENTITY_P (not_tmpl) = true;\n \n       /* Insert into the entity hash (it cannot already be there).  */\n       bool existed;\n@@ -7510,12 +7518,11 @@ trees_out::decl_value (tree decl, depset *dep)\n \t      tree o = get_originating_module_decl (decl);\n \t      bool is_mod = false;\n \n-\t      if (dep && dep->is_alias_tmpl_inst ())\n-\t\t/* Alias template instantiations are templatey, but\n-\t\t   found by name.  */\n-\t\tis_mod = false;\n-\t      else if (DECL_LANG_SPECIFIC (o) && DECL_MODULE_PURVIEW_P (o))\n+\t      tree not_tmpl = STRIP_TEMPLATE (o);\n+\t      if (DECL_LANG_SPECIFIC (not_tmpl)\n+\t\t  && DECL_MODULE_PURVIEW_P (not_tmpl))\n \t\tis_mod = true;\n+\n \t      b (is_mod);\n \t    }\n \t  b (dep && dep->has_defn ());\n@@ -7533,34 +7540,26 @@ trees_out::decl_value (tree decl, depset *dep)\n   int inner_tag = 0;\n   if (TREE_CODE (decl) == TEMPLATE_DECL)\n     {\n-      if (dep && dep->is_alias_tmpl_inst ())\n-\tinner = NULL_TREE;\n-      else\n-\t{\n-\t  inner = DECL_TEMPLATE_RESULT (decl);\n-\t  inner_tag = insert (inner, WK_value);\n-\t}\n+      inner = DECL_TEMPLATE_RESULT (decl);\n+      inner_tag = insert (inner, WK_value);\n \n       if (streaming_p ())\n \t{\n-\t  int code = inner ? TREE_CODE (inner) : 0;\n+\t  int code = TREE_CODE (inner);\n \t  u (code);\n-\t  if (inner)\n-\t    {\n-\t      start (inner, true);\n-\t      tree_node_bools (inner);\n-\t      dump (dumper::TREE)\n-\t\t&& dump (\"Writing %s:%d %C:%N%S\", merge_kind_name[mk], inner_tag,\n-\t\t\t TREE_CODE (inner), inner, inner);\n-\t    }\n+\t  start (inner, true);\n+\t  tree_node_bools (inner);\n+\t  dump (dumper::TREE)\n+\t    && dump (\"Writing %s:%d %C:%N%S\", merge_kind_name[mk], inner_tag,\n+\t\t     TREE_CODE (inner), inner, inner);\n \t}\n     }\n \n   tree type = NULL_TREE;\n   int type_tag = 0;\n   tree stub_decl = NULL_TREE;\n   int stub_tag = 0;\n-  if (inner && TREE_CODE (inner) == TYPE_DECL)\n+  if (TREE_CODE (inner) == TYPE_DECL)\n     {\n       type = TREE_TYPE (inner);\n       bool has_type = (type == TYPE_MAIN_VARIANT (type)\n@@ -7612,7 +7611,7 @@ trees_out::decl_value (tree decl, depset *dep)\n   unsigned tpl_levels = 0;\n   if (decl != inner)\n     tpl_header (decl, &tpl_levels);\n-  if (inner && TREE_CODE (inner) == FUNCTION_DECL)\n+  if (TREE_CODE (inner) == FUNCTION_DECL)\n     fn_parms_init (inner);\n \n   /* Now write out the merging information, and then really\n@@ -7624,7 +7623,7 @@ trees_out::decl_value (tree decl, depset *dep)\n       && dump (\"Wrote:%d's %s merge key %C:%N\", tag,\n \t       merge_kind_name[mk], TREE_CODE (decl), decl);\n \n-  if (inner && TREE_CODE (inner) == FUNCTION_DECL)\n+  if (TREE_CODE (inner) == FUNCTION_DECL)\n     fn_parms_fini (inner);\n \n   if (!is_key_order ())\n@@ -7636,18 +7635,6 @@ trees_out::decl_value (tree decl, depset *dep)\n \ttree_node_vals (inner);\n       tpl_parms_fini (decl, tpl_levels);\n     }\n-  else if (!inner)\n-    {\n-      /* A template alias instantiation.  */\n-      inner = DECL_TEMPLATE_RESULT (decl);\n-      if (!is_key_order ())\n-\ttree_node (inner);\n-      if (streaming_p ())\n-\tdump (dumper::TREE)\n-\t  && dump (\"Wrote(%d) alias template %C:%N\",\n-\t\t   get_tag (inner), TREE_CODE (inner), inner);\n-      inner = NULL_TREE;\n-    }\n \n   if (type && !is_key_order ())\n     {\n@@ -7693,8 +7680,7 @@ trees_out::decl_value (tree decl, depset *dep)\n       install_entity (decl, dep);\n     }\n \n-  if (inner\n-      && VAR_OR_FUNCTION_DECL_P (inner)\n+  if (VAR_OR_FUNCTION_DECL_P (inner)\n       && DECL_LANG_SPECIFIC (inner)\n       && DECL_MODULE_ATTACHMENTS_P (inner)\n       && !is_key_order ())\n@@ -7715,7 +7701,7 @@ trees_out::decl_value (tree decl, depset *dep)\n     }\n \n   bool is_typedef = false;\n-  if (!type && inner && TREE_CODE (inner) == TYPE_DECL)\n+  if (!type && TREE_CODE (inner) == TYPE_DECL)\n     {\n       tree t = TREE_TYPE (inner);\n       unsigned tdef_flags = 0;\n@@ -7766,10 +7752,9 @@ trees_out::decl_value (tree decl, depset *dep)\n     dump (dumper::TREE) && dump (\"Written decl:%d %C:%N\", tag,\n \t\t\t\t TREE_CODE (decl), decl);\n \n-  if (!inner || NAMESPACE_SCOPE_P (inner))\n-    gcc_checking_assert (!inner\n-\t\t\t || !dep == (VAR_OR_FUNCTION_DECL_P (inner)\n-\t\t\t\t     && DECL_LOCAL_DECL_P (inner)));\n+  if (NAMESPACE_SCOPE_P (inner))\n+    gcc_checking_assert (!dep == (VAR_OR_FUNCTION_DECL_P (inner)\n+\t\t\t\t  && DECL_LOCAL_DECL_P (inner)));\n   else if ((TREE_CODE (inner) == TYPE_DECL\n \t    && !is_typedef\n \t    && TYPE_NAME (TREE_TYPE (inner)) == inner)\n@@ -7828,31 +7813,23 @@ trees_in::decl_value ()\n   if (decl && TREE_CODE (decl) == TEMPLATE_DECL)\n     {\n       int code = u ();\n-      if (!code)\n-\t{\n-\t  inner = NULL_TREE;\n-\t  DECL_TEMPLATE_RESULT (decl) = error_mark_node;\n-\t}\n+      inner = start (code);\n+      if (inner && tree_node_bools (inner))\n+\tDECL_TEMPLATE_RESULT (decl) = inner;\n       else\n-\t{\n-\t  inner = start (code);\n-\t  if (inner && tree_node_bools (inner))\n-\t    DECL_TEMPLATE_RESULT (decl) = inner;\n-\t  else\n-\t    decl = NULL_TREE;\n+\tdecl = NULL_TREE;\n \n-\t  inner_tag = insert (inner);\n-\t  if (decl)\n-\t    dump (dumper::TREE)\n-\t      && dump (\"Reading:%d %C\", inner_tag, TREE_CODE (inner));\n-\t}\n+      inner_tag = insert (inner);\n+      if (decl)\n+\tdump (dumper::TREE)\n+\t  && dump (\"Reading:%d %C\", inner_tag, TREE_CODE (inner));\n     }\n \n   tree type = NULL_TREE;\n   int type_tag = 0;\n   tree stub_decl = NULL_TREE;\n   int stub_tag = 0;\n-  if (decl && inner && TREE_CODE (inner) == TYPE_DECL)\n+  if (decl && TREE_CODE (inner) == TYPE_DECL)\n     {\n       if (unsigned type_code = u ())\n \t{\n@@ -7917,7 +7894,7 @@ trees_in::decl_value ()\n   if (decl != inner)\n     if (!tpl_header (decl, &tpl_levels))\n       goto bail;\n-  if (inner && TREE_CODE (inner) == FUNCTION_DECL)\n+  if (TREE_CODE (inner) == FUNCTION_DECL)\n     parm_tag = fn_parms_init (inner);\n \n   tree existing = key_mergeable (tag, mk, decl, inner, type, container, is_mod);\n@@ -7972,15 +7949,6 @@ trees_in::decl_value ()\n       if (!tpl_parms_fini (decl, tpl_levels))\n \tgoto bail;\n     }\n-  else if (!inner)\n-    {\n-      inner = tree_node ();\n-      DECL_TEMPLATE_RESULT (decl) = inner;\n-      TREE_TYPE (decl) = TREE_TYPE (inner);\n-      dump (dumper::TREE)\n-\t&& dump (\"Read alias template %C:%N\", TREE_CODE (inner), inner);\n-      inner = NULL_TREE;\n-    }\n \n   if (type && (!tree_node_vals (type)\n \t       || (stub_decl && !tree_node_vals (stub_decl))))\n@@ -8009,8 +7977,7 @@ trees_in::decl_value ()\n   bool installed = install_entity (existing);\n   bool is_new = existing == decl;\n \n-  if (inner\n-      && VAR_OR_FUNCTION_DECL_P (inner)\n+  if (VAR_OR_FUNCTION_DECL_P (inner)\n       && DECL_LANG_SPECIFIC (inner)\n       && DECL_MODULE_ATTACHMENTS_P (inner))\n     {\n@@ -8039,7 +8006,7 @@ trees_in::decl_value ()\n   /* Regular typedefs will have a NULL TREE_TYPE at this point.  */\n   unsigned tdef_flags = 0;\n   bool is_typedef = false;\n-  if (!type && inner && TREE_CODE (inner) == TYPE_DECL)\n+  if (!type && TREE_CODE (inner) == TYPE_DECL)\n     {\n       tdef_flags = u ();\n       if (tdef_flags & 1)\n@@ -8056,15 +8023,9 @@ trees_in::decl_value ()\n \n       if (installed)\n \t{\n-\t  /* Mark the entity as imported and add it to the entity\n-\t     array and map.  */\n-\t  retrofit_lang_decl (decl);\n-\t  DECL_MODULE_IMPORT_P (decl) = true;\n-\t  if (inner_tag)\n-\t    {\n-\t      retrofit_lang_decl (inner);\n-\t      DECL_MODULE_IMPORT_P (inner) = true;\n-\t    }\n+\t  /* Mark the entity as imported.  */\n+\t  retrofit_lang_decl (inner);\n+\t  DECL_MODULE_IMPORT_P (inner) = true;\n \t}\n \n       if (spec.spec)\n@@ -8158,7 +8119,7 @@ trees_in::decl_value ()\n       if (!is_matching_decl (existing, decl, is_typedef))\n \tunmatched_duplicate (existing);\n \n-      if (inner && TREE_CODE (inner) == FUNCTION_DECL)\n+      if (TREE_CODE (inner) == FUNCTION_DECL)\n \t{\n \t  tree e_inner = STRIP_TEMPLATE (existing);\n \t  for (auto parm = DECL_ARGUMENTS (inner);\n@@ -8211,8 +8172,7 @@ trees_in::decl_value ()\n \t}\n     }\n \n-  if (inner\n-      && !NAMESPACE_SCOPE_P (inner)\n+  if (!NAMESPACE_SCOPE_P (inner)\n       && ((TREE_CODE (inner) == TYPE_DECL\n \t   && !is_typedef\n \t   && TYPE_NAME (TREE_TYPE (inner)) == inner)\n@@ -8550,7 +8510,8 @@ trees_out::decl_node (tree decl, walk_kind ref)\n   else if (TREE_CODE (ctx) != FUNCTION_DECL\n \t   || TREE_CODE (decl) == TEMPLATE_DECL\n \t   || (dep_hash->sneakoscope && DECL_IMPLICIT_TYPEDEF_P (decl))\n-\t   || (DECL_LANG_SPECIFIC (decl) && DECL_MODULE_IMPORT_P (decl)))\n+\t   || (DECL_LANG_SPECIFIC (decl)\n+\t       && DECL_MODULE_IMPORT_P (decl)))\n     {\n       auto kind = (TREE_CODE (decl) == NAMESPACE_DECL\n \t\t   && !DECL_NAMESPACE_ALIAS (decl)\n@@ -8607,6 +8568,7 @@ trees_out::decl_node (tree decl, walk_kind ref)\n       else\n \t{\n \t  tree o = get_originating_module_decl (decl);\n+\t  o = STRIP_TEMPLATE (o);\n \t  kind = (DECL_LANG_SPECIFIC (o) && DECL_MODULE_PURVIEW_P (o)\n \t\t  ? \"purview\" : \"GMF\");\n \t}\n@@ -10371,7 +10333,7 @@ trees_out::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n \t\tgcc_checking_assert\n \t\t  (match_mergeable_specialization (false, entry)\n \t\t   == TREE_TYPE (existing));\n-\t      else if (mk & MK_tmpl_tmpl_mask)\n+\t      if (mk & MK_tmpl_tmpl_mask)\n \t\texisting = DECL_TI_TEMPLATE (existing);\n \t    }\n \t  else\n@@ -10401,7 +10363,7 @@ trees_out::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n \t  if (IDENTIFIER_CONV_OP_P (name))\n \t    name = conv_op_identifier;\n \n-\t  if (inner && TREE_CODE (inner) == FUNCTION_DECL)\n+\t  if (TREE_CODE (inner) == FUNCTION_DECL)\n \t    {\n \t      /* Functions are distinguished by parameter types.  */\n \t      tree fn_type = TREE_TYPE (inner);\n@@ -10737,7 +10699,7 @@ trees_in::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n \tkey.ret = tree_node ();\n       else if (mk == MK_partial\n \t       || ((mk == MK_named || mk == MK_friend_spec)\n-\t\t   && inner && TREE_CODE (inner) == FUNCTION_DECL))\n+\t\t   && TREE_CODE (inner) == FUNCTION_DECL))\n \t{\n \t  key.ret = tree_node ();\n \t  tree arg, *arg_ptr = &key.args;\n@@ -10760,11 +10722,8 @@ trees_in::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n \t  DECL_NAME (decl) = name;\n \t  DECL_CONTEXT (decl) = FROB_CONTEXT (container);\n \t}\n-      if (inner)\n-\t{\n-\t  DECL_NAME (inner) = DECL_NAME (decl);\n-\t  DECL_CONTEXT (inner) = DECL_CONTEXT (decl);\n-\t}\n+      DECL_NAME (inner) = DECL_NAME (decl);\n+      DECL_CONTEXT (inner) = DECL_CONTEXT (decl);\n \n       if (mk == MK_partial)\n \t{\n@@ -12383,20 +12342,9 @@ depset::hash::make_dependency (tree decl, entity_kind ek)\n     gcc_checking_assert (TREE_CODE (decl) == OVERLOAD);\n \n   if (TREE_CODE (decl) == TEMPLATE_DECL)\n-    {\n-      /* The template should have copied these from its result decl.  */\n-      tree res = DECL_TEMPLATE_RESULT (decl);\n-\n-      gcc_checking_assert (DECL_MODULE_EXPORT_P (decl)\n-\t\t\t   == DECL_MODULE_EXPORT_P (res));\n-      if (DECL_LANG_SPECIFIC (res))\n-\t{\n-\t  gcc_checking_assert (DECL_MODULE_PURVIEW_P (decl)\n-\t\t\t       == DECL_MODULE_PURVIEW_P (res));\n-\t  gcc_checking_assert ((DECL_MODULE_IMPORT_P (decl)\n-\t\t\t\t== DECL_MODULE_IMPORT_P (res)));\n-\t}\n-    }\n+    /* The template should have copied these from its result decl.  */\n+    gcc_checking_assert (DECL_MODULE_EXPORT_P (decl)\n+\t\t\t == DECL_MODULE_EXPORT_P (DECL_TEMPLATE_RESULT (decl)));\n \n   depset **slot = entity_slot (decl, true);\n   depset *dep = *slot;\n@@ -12444,11 +12392,6 @@ depset::hash::make_dependency (tree decl, entity_kind ek)\n \n \t      *slot = redirect;\n \n-\t      if (DECL_LANG_SPECIFIC (decl))\n-\t\t{\n-\t\t  DECL_MODULE_IMPORT_P (partial) = DECL_MODULE_IMPORT_P (decl);\n-\t\t  DECL_MODULE_PURVIEW_P (partial) = DECL_MODULE_PURVIEW_P (decl);\n-\t\t}\n \t      depset *tmpl_dep = make_dependency (partial, EK_PARTIAL);\n \t      gcc_checking_assert (tmpl_dep->get_entity_kind () == EK_PARTIAL);\n \n@@ -12478,46 +12421,48 @@ depset::hash::make_dependency (tree decl, entity_kind ek)\n \t\t\t\t   && !(*eslot)->deps.length ());\n \t}\n \n-      if (ek != EK_USING\n-\t  && DECL_LANG_SPECIFIC (decl)\n-\t  && DECL_MODULE_IMPORT_P (decl))\n+      if (ek != EK_USING)\n \t{\n-\t  /* Store the module number and index in cluster/section, so\n-\t     we don't have to look them up again.  */\n-\t  unsigned index = import_entity_index (decl);\n-\t  module_state *from = import_entity_module (index);\n-\t  /* Remap will be zero for imports from partitions, which we\n-\t     want to treat as-if declared in this TU.  */\n-\t  if (from->remap)\n+\t  tree not_tmpl = STRIP_TEMPLATE (decl);\n+\n+\t  if (DECL_LANG_SPECIFIC (not_tmpl)\n+\t      && DECL_MODULE_IMPORT_P (not_tmpl))\n \t    {\n-\t      dep->cluster = index - from->entity_lwm;\n-\t      dep->section = from->remap;\n-\t      dep->set_flag_bit<DB_IMPORTED_BIT> ();\n+\t      /* Store the module number and index in cluster/section,\n+\t\t so we don't have to look them up again.  */\n+\t      unsigned index = import_entity_index (decl);\n+\t      module_state *from = import_entity_module (index);\n+\t      /* Remap will be zero for imports from partitions, which\n+\t\t we want to treat as-if declared in this TU.  */\n+\t      if (from->remap)\n+\t\t{\n+\t\t  dep->cluster = index - from->entity_lwm;\n+\t\t  dep->section = from->remap;\n+\t\t  dep->set_flag_bit<DB_IMPORTED_BIT> ();\n+\t\t}\n \t    }\n-\t}\n \n-      if (ek == EK_DECL\n-\t  && !dep->is_import ()\n-\t  && TREE_CODE (CP_DECL_CONTEXT (decl)) == NAMESPACE_DECL\n-\t  && !(TREE_CODE (decl) == TEMPLATE_DECL\n-\t       && DECL_UNINSTANTIATED_TEMPLATE_FRIEND_P (decl)))\n-\t{\n-\t  tree ctx = CP_DECL_CONTEXT (decl);\n-\t  tree not_tmpl = STRIP_TEMPLATE (decl);\n-\n-\t  if (!TREE_PUBLIC (ctx))\n-\t    /* Member of internal namespace.  */\n-\t    dep->set_flag_bit<DB_IS_INTERNAL_BIT> ();\n-\t  else if (VAR_OR_FUNCTION_DECL_P (not_tmpl)\n-\t\t   && DECL_THIS_STATIC (not_tmpl))\n+\t  if (ek == EK_DECL\n+\t      && !dep->is_import ()\n+\t      && TREE_CODE (CP_DECL_CONTEXT (decl)) == NAMESPACE_DECL\n+\t      && !(TREE_CODE (decl) == TEMPLATE_DECL\n+\t\t   && DECL_UNINSTANTIATED_TEMPLATE_FRIEND_P (decl)))\n \t    {\n-\t      /* An internal decl.  This is ok in a GM entity.  */\n-\t      if (!(header_module_p ()\n-\t\t    || !DECL_LANG_SPECIFIC (not_tmpl)\n-\t\t    || !DECL_MODULE_PURVIEW_P (not_tmpl)))\n+\t      tree ctx = CP_DECL_CONTEXT (decl);\n+\n+\t      if (!TREE_PUBLIC (ctx))\n+\t\t/* Member of internal namespace.  */\n \t\tdep->set_flag_bit<DB_IS_INTERNAL_BIT> ();\n+\t      else if (VAR_OR_FUNCTION_DECL_P (not_tmpl)\n+\t\t       && DECL_THIS_STATIC (not_tmpl))\n+\t\t{\n+\t\t  /* An internal decl.  This is ok in a GM entity.  */\n+\t\t  if (!(header_module_p ()\n+\t\t\t|| !DECL_LANG_SPECIFIC (not_tmpl)\n+\t\t\t|| !DECL_MODULE_PURVIEW_P (not_tmpl)))\n+\t\t    dep->set_flag_bit<DB_IS_INTERNAL_BIT> ();\n+\t\t}\n \t    }\n-\n \t}\n \n       if (!dep->is_import ())\n@@ -18394,15 +18339,16 @@ int\n get_originating_module (tree decl, bool for_mangle)\n {\n   tree owner = get_originating_module_decl (decl);\n+  tree not_tmpl = STRIP_TEMPLATE (owner);\n \n-  if (!DECL_LANG_SPECIFIC (owner))\n+  if (!DECL_LANG_SPECIFIC (not_tmpl))\n     return for_mangle ? -1 : 0;\n \n   if (for_mangle\n-      && (DECL_MODULE_EXPORT_P (owner) || !DECL_MODULE_PURVIEW_P (owner)))\n+      && (DECL_MODULE_EXPORT_P (owner) || !DECL_MODULE_PURVIEW_P (not_tmpl)))\n     return -1;\n \n-  if (!DECL_MODULE_IMPORT_P (owner))\n+  if (!DECL_MODULE_IMPORT_P (not_tmpl))\n     return 0;\n \n   return get_importing_module (owner);\n@@ -18426,7 +18372,8 @@ module_may_redeclare (tree decl)\n {\n   module_state *me = (*modules)[0];\n   module_state *them = me;\n-  if (DECL_LANG_SPECIFIC (decl) && DECL_MODULE_IMPORT_P (decl))\n+  tree not_tmpl = STRIP_TEMPLATE (decl);\n+  if (DECL_LANG_SPECIFIC (not_tmpl) && DECL_MODULE_IMPORT_P (not_tmpl))\n     {\n       /* We can be given the TEMPLATE_RESULT.  We want the\n \t TEMPLATE_DECL.  */\n@@ -18468,15 +18415,15 @@ module_may_redeclare (tree decl)\n     }\n \n   if (me == them)\n-    return ((DECL_LANG_SPECIFIC (decl) && DECL_MODULE_PURVIEW_P (decl))\n+    return ((DECL_LANG_SPECIFIC (not_tmpl) && DECL_MODULE_PURVIEW_P (not_tmpl))\n \t    == module_purview_p ());\n \n   if (!me->name)\n     me = me->parent;\n \n   /* We can't have found a GMF entity from a named module.  */\n-  gcc_checking_assert (DECL_LANG_SPECIFIC (decl)\n-\t\t       && DECL_MODULE_PURVIEW_P (decl));\n+  gcc_checking_assert (DECL_LANG_SPECIFIC (not_tmpl)\n+\t\t       && DECL_MODULE_PURVIEW_P (not_tmpl));\n \n   return me && get_primary (them) == get_primary (me);\n }\n@@ -18500,20 +18447,16 @@ set_instantiating_module (tree decl)\n   if (!modules_p ())\n     return;\n \n+  decl = STRIP_TEMPLATE (decl);\n+\n   if (!DECL_LANG_SPECIFIC (decl) && module_purview_p ())\n     retrofit_lang_decl (decl);\n+\n   if (DECL_LANG_SPECIFIC (decl))\n     {\n       DECL_MODULE_PURVIEW_P (decl) = module_purview_p ();\n       /* If this was imported, we'll still be in the entity_hash.  */\n       DECL_MODULE_IMPORT_P (decl) = false;\n-      if (TREE_CODE (decl) == TEMPLATE_DECL)\n-\t{\n-\t  tree res = DECL_TEMPLATE_RESULT (decl);\n-\t  retrofit_lang_decl (res);\n-\t  DECL_MODULE_PURVIEW_P (res) = DECL_MODULE_PURVIEW_P (decl);\n-\t  DECL_MODULE_IMPORT_P (res) = false;\n-\t}\n     }\n }\n \n@@ -18547,7 +18490,6 @@ set_defining_module (tree decl)\n \t\t  gcc_checking_assert (!use_tpl);\n \t\t  /* Get to the TEMPLATE_DECL.  */\n \t\t  decl = TI_TEMPLATE (ti);\n-\t\t  gcc_checking_assert (!DECL_MODULE_IMPORT_P (decl));\n \t\t}\n \n \t      /* Record it on the class_members list.  */"}, {"sha": "3bce3d597dcf9ec9dc3a3d494555ad06b56b6214", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=d82797420c2238e31a7a25fe6db6bd05cd37224d", "patch": "@@ -1666,8 +1666,9 @@ name_lookup::search_adl (tree fns, vec<tree, va_gc> *args)\n \t\tcontinue;\n \n \t      tree origin = get_originating_module_decl (TYPE_NAME (scope));\n-\t      if (!DECL_LANG_SPECIFIC (origin)\n-\t\t  || !DECL_MODULE_IMPORT_P (origin))\n+\t      tree not_tmpl = STRIP_TEMPLATE (origin);\n+\t      if (!DECL_LANG_SPECIFIC (not_tmpl)\n+\t\t  || !DECL_MODULE_IMPORT_P (not_tmpl))\n \t\t/* Not imported.  */\n \t\tcontinue;\n \n@@ -3680,6 +3681,7 @@ do_pushdecl (tree decl, bool hiding)\n \tif (iter.using_p ())\n \t  ; /* Ignore using decls here.  */\n \telse if (iter.hidden_p ()\n+\t\t && TREE_CODE (*iter) == FUNCTION_DECL\n \t\t && DECL_LANG_SPECIFIC (*iter)\n \t\t && DECL_MODULE_IMPORT_P (*iter))\n \t  ; /* An undeclared builtin imported from elsewhere.  */"}, {"sha": "a056ecefd1dfdff805e3f31312b99ad4099909ea", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 11, "deletions": 42, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d82797420c2238e31a7a25fe6db6bd05cd37224d", "patch": "@@ -4930,16 +4930,8 @@ build_template_decl (tree decl, tree parms, bool member_template_p)\n   DECL_SOURCE_LOCATION (tmpl) = DECL_SOURCE_LOCATION (decl);\n   DECL_MEMBER_TEMPLATE_P (tmpl) = member_template_p;\n \n-  if (modules_p ())\n-    {\n-      /* Propagate module information from the decl.  */\n-      DECL_MODULE_EXPORT_P (tmpl) = DECL_MODULE_EXPORT_P (decl);\n-      if (DECL_LANG_SPECIFIC (decl))\n-\t{\n-\t  DECL_MODULE_PURVIEW_P (tmpl) = DECL_MODULE_PURVIEW_P (decl);\n-\t  gcc_checking_assert (!DECL_MODULE_IMPORT_P (decl));\n-\t}\n-    }\n+  /* Propagate module information from the decl.  */\n+  DECL_MODULE_EXPORT_P (tmpl) = DECL_MODULE_EXPORT_P (decl);\n \n   return tmpl;\n }\n@@ -10167,25 +10159,7 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n \t}\n \n       /* Build template info for the new specialization.  */\n-      if (TYPE_ALIAS_P (t))\n-\t{\n-\t  /* This is constructed during instantiation of the alias\n-\t     decl.  But for member templates of template classes, that\n-\t     is not correct as we need to refer to the partially\n-\t     instantiated template, not the most general template.\n-\t     The incorrect knowledge will not have escaped this\n-\t     instantiation process, so we're good just updating the\n-\t     template_info we made then.  */\n-\t  tree ti = DECL_TEMPLATE_INFO (TYPE_NAME (t));\n-\t  gcc_checking_assert (template_args_equal (TI_ARGS (ti), arglist));\n-\t  if (TI_TEMPLATE (ti) != found)\n-\t    {\n-\t      gcc_checking_assert (DECL_TI_TEMPLATE (found) == TI_TEMPLATE (ti));\n-\t      TI_TEMPLATE (ti) = found;\n-\t    }\n-\t}\n-      else\n-\tSET_TYPE_TEMPLATE_INFO (t, build_template_info (found, arglist));\n+      SET_TYPE_TEMPLATE_INFO (t, build_template_info (found, arglist));\n \n       elt.spec = t;\n       slot = type_specializations->find_slot_with_hash (&elt, hash, INSERT);\n@@ -14297,8 +14271,7 @@ tsubst_template_decl (tree t, tree args, tsubst_flags_t complain,\n     }\n   else\n     {\n-      if (TREE_CODE (decl) != TYPE_DECL || !TYPE_DECL_ALIAS_P (decl))\n-\tDECL_TI_TEMPLATE (inner) = r;\n+      DECL_TI_TEMPLATE (inner) = r;\n       DECL_TI_ARGS (r) = DECL_TI_ARGS (inner);\n     }\n \n@@ -14311,17 +14284,13 @@ tsubst_template_decl (tree t, tree args, tsubst_flags_t complain,\n       /* Propagate module information from the decl.  */\n       DECL_MODULE_EXPORT_P (r) = DECL_MODULE_EXPORT_P (inner);\n       if (DECL_LANG_SPECIFIC (inner))\n-\t{\n-\t  DECL_MODULE_PURVIEW_P (r) = DECL_MODULE_PURVIEW_P (inner);\n-\t  /* If this is a constrained template, the above tsubst of\n-\t     inner can find the unconstrained template, which may have\n-\t     come from an import.  This is ok, because we don't\n-\t     register this instantiation (see below).  */\n-\t  gcc_checking_assert (!DECL_MODULE_IMPORT_P (inner)\n-\t\t\t       || (TEMPLATE_PARMS_CONSTRAINTS\n-\t\t\t\t   (DECL_TEMPLATE_PARMS (t))));\n-\t  DECL_MODULE_IMPORT_P (r) = false;\n-\t}\n+\t/* If this is a constrained template, the above tsubst of\n+\t   inner can find the unconstrained template, which may have\n+\t   come from an import.  This is ok, because we don't\n+\t   register this instantiation (see below).  */\n+\tgcc_checking_assert (!DECL_MODULE_IMPORT_P (inner)\n+\t\t\t     || (TEMPLATE_PARMS_CONSTRAINTS\n+\t\t\t\t (DECL_TEMPLATE_PARMS (t))));\n     }\n \n   DECL_TEMPLATE_INSTANTIATIONS (r) = NULL_TREE;"}, {"sha": "c5faf1d62053812b2f5c4c8d877c92557e2ddd91", "filename": "gcc/testsuite/g++.dg/modules/pr99283-2_a.H", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99283-2_a.H", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99283-2_a.H", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99283-2_a.H?ref=d82797420c2238e31a7a25fe6db6bd05cd37224d", "patch": "@@ -0,0 +1,12 @@\n+// PR 99283 part 2 ICE on definition with qualified-name\n+// { dg-additional-options -fmodule-header }\n+// { dg-module-cmi {} }\n+\n+inline namespace __cxx11 {\n+\n+template<typename _CharT>\n+class collate;\n+\n+}\n+       \n+"}, {"sha": "a1b7d603ff712e9fb92e47df6ecbad90082a02d3", "filename": "gcc/testsuite/g++.dg/modules/pr99283-2_b.H", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99283-2_b.H", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99283-2_b.H", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99283-2_b.H?ref=d82797420c2238e31a7a25fe6db6bd05cd37224d", "patch": "@@ -0,0 +1,22 @@\n+// { dg-additional-options -fmodule-header }\n+// { dg-module-cmi {} }\n+import  \"pr99283-2_a.H\";\n+\n+inline namespace __cxx11 {\n+template<typename _CharT>\n+class collate\n+{\n+};\n+}\n+\n+template<typename _CharT>\n+void Check ()\n+{\n+  typedef collate<char> __collate_type;\n+}\n+\n+\n+\n+\n+\n+"}, {"sha": "82639282f073150620186552a76ab4c72c03a0a2", "filename": "gcc/testsuite/g++.dg/modules/pr99283-2_c.H", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99283-2_c.H", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99283-2_c.H", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99283-2_c.H?ref=d82797420c2238e31a7a25fe6db6bd05cd37224d", "patch": "@@ -0,0 +1,20 @@\n+// { dg-additional-options -fmodule-header }\n+// { dg-module-cmi {} }\n+import  \"pr99283-2_a.H\";\n+\n+template<typename _CharT>\n+class __cxx11::collate\n+{\n+};\n+\n+template<typename _CharT>\n+void Check ()\n+{\n+  typedef collate<char> __collate_type;\n+}\n+\n+\n+\n+\n+\n+"}, {"sha": "5926b9d2672648501f958dbf071ff29bbfa25425", "filename": "gcc/testsuite/g++.dg/modules/pr99283-3_a.H", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99283-3_a.H", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99283-3_a.H", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99283-3_a.H?ref=d82797420c2238e31a7a25fe6db6bd05cd37224d", "patch": "@@ -0,0 +1,31 @@\n+// PR 99283 part 2 ICE on definition with qualified-name\n+// { dg-additional-options -fmodule-header }\n+// { dg-module-cmi {} }\n+\n+template<bool, typename _Tp>\n+struct enable_if;\n+\n+template<typename _Tp>\n+struct enable_if<true, _Tp>\n+{ typedef _Tp type; };\n+\n+template<typename _CharT>\n+class basic_string;\n+\n+typedef basic_string<char> string;\n+\n+template<typename _CharT>\n+class basic_string\n+{\n+private:\n+  template<typename _Tp>\n+  using _If_sv = typename enable_if<true, int>::type;\n+\n+public:\n+  const _CharT *c_str() const noexcept;\n+};\n+\n+inline void stoi(const string& __str)\n+{\n+  __str.c_str ();\n+}"}, {"sha": "cb14de613e358dc6543efa312aa0048c6a10a0d6", "filename": "gcc/testsuite/g++.dg/modules/pr99283-3_b.H", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99283-3_b.H", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99283-3_b.H", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99283-3_b.H?ref=d82797420c2238e31a7a25fe6db6bd05cd37224d", "patch": "@@ -0,0 +1,9 @@\n+// { dg-additional-options {-fmodule-header -fno-module-lazy} }\n+// { dg-module-cmi {} }\n+\n+template<typename _CharT>\n+class basic_string;\n+\n+typedef basic_string<char> string;\n+\n+import  \"pr99283-3_a.H\";"}, {"sha": "d15ccc440b7e8bfe312dc701112bc2a0460fb54b", "filename": "gcc/testsuite/g++.dg/modules/pr99283-4.H", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99283-4.H", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99283-4.H", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99283-4.H?ref=d82797420c2238e31a7a25fe6db6bd05cd37224d", "patch": "@@ -0,0 +1,20 @@\n+// PR 99283 part 3, ICE with template alias as default template parm\n+// of member template\n+// { dg-additional-options -fmodule-header }\n+// { dg-module-cmi {} }\n+\n+template<typename _Traits>\n+struct _Insert\n+{\n+  using size_type = int;\n+  \n+  template<typename _Pair>\n+  using _IFconsp = bool;\n+\n+  template<typename _Pair, typename = _IFconsp<_Pair>>\n+  int insert (_Pair&& __v);\n+};\n+\n+void Foo (typename _Insert<int>::size_type);\n+\n+"}, {"sha": "37002ee9ae1b7a43a64e6371d38b264de312c98a", "filename": "gcc/testsuite/g++.dg/modules/tpl-alias-1_a.H", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-alias-1_a.H", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-alias-1_a.H", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-alias-1_a.H?ref=d82797420c2238e31a7a25fe6db6bd05cd37224d", "patch": "@@ -3,7 +3,7 @@\n \n #include \"tpl-alias-1.h\"\n \n-// { dg-final { scan-lang-dump {Writing named:-[0-9]* template_decl:'::allocator_traits<::allocator<long int>>::template rebind_alloc<_Up>'} module } }\n-// { dg-final { scan-lang-dump {Writing decl spec:-[0-9]* type_decl:'::allocator_traits<::allocator<long int>>::rebind_alloc<_Up>'} module } }\n-// { dg-final { scan-lang-dump {Writing:-[0-9]*'s decl spec merge key \\(specialization\\) type_decl:'::allocator_traits<::allocator<long int>>::rebind_alloc<_Up>'} module } }\n-// { dg-final { scan-lang-dump {Wrote\\(-[0-9]*\\) alias template type_decl:'::allocator_traits<::allocator<long int>>::rebind_alloc<_Up>'} module } }\n+// { dg-final { scan-lang-dump {Writing decl tmpl spec:-[0-9]* template_decl:'::allocator_traits<::allocator<long int>>::template rebind_alloc<_Up>'} module } }\n+// { dg-final { scan-lang-dump {Writing decl tmpl spec:-[0-9]* type_decl:'::allocator_traits<::allocator<long int>>::template rebind_alloc<_Up>'} module } }\n+\n+// { dg-final { scan-lang-dump {Writing:-[0-9]*'s alias spec merge key \\(specialization\\) type_decl:'::allocator_traits<::allocator<long int>>::rebind_alloc<long int>'} module } }"}, {"sha": "cc9499f54fce2b6cdecb799913f070afaa974782", "filename": "gcc/testsuite/g++.dg/modules/tpl-alias-1_b.C", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-alias-1_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82797420c2238e31a7a25fe6db6bd05cd37224d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-alias-1_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-alias-1_b.C?ref=d82797420c2238e31a7a25fe6db6bd05cd37224d", "patch": "@@ -3,7 +3,8 @@\n #include \"tpl-alias-1.h\"\n import \"tpl-alias-1_a.H\";\n \n-// { dg-final { scan-lang-dump {Read:-[0-9]*'s named merge key \\(matched\\) template_decl:'::allocator_traits<::allocator<long int>>::template rebind_alloc'} module } }\n-// { dg-final { scan-lang-dump {Read:-[0-9]*'s decl spec merge key \\(matched\\) type_decl:'::allocator_traits<::allocator<_Tp>>::rebind_alloc'} module } }\n-// { dg-final { scan-lang-dump {Read alias template type_decl:'::allocator_traits<::allocator<long int>>::rebind_alloc<_Up>'} module } }\n+// { dg-final { scan-lang-dump {Deduping '::allocator_traits<::allocator<_Tp>>::template rebind_alloc'} module } }\n+// { dg-final { scan-lang-dump {Deduping '::allocator_traits<::allocator<long int>>::template rebind_alloc<_Up>'} module } }\n+// { dg-final { scan-lang-dump {Deduping '::allocator_traits<::allocator<long int>>::rebind_alloc<long int>'} module } }\n+\n // { dg-final { scan-lang-dump-not {merge key \\(new\\)} module } }"}]}