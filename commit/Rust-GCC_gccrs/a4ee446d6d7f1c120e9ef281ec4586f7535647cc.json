{"sha": "a4ee446d6d7f1c120e9ef281ec4586f7535647cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRlZTQ0NmQ2ZDdmMWMxMjBlOWVmMjgxZWM0NTg2Zjc1MzU2NDdjYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-06-27T07:03:50Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-06-27T07:03:50Z"}, "message": "re PR tree-optimization/57233 (Vector lowering of LROTATE_EXPR pessimizes code)\n\n\tPR tree-optimization/57233\n\tPR tree-optimization/61299\n\t* tree-vect-generic.c (get_compute_type, count_type_subparts): New\n\tfunctions.\n\t(expand_vector_operations_1): Use them.  If {L,R}ROTATE_EXPR\n\twould be lowered to scalar shifts, check if corresponding\n\tshifts and vector BIT_IOR_EXPR are supported and don't lower\n\tor lower just to narrower vector type in that case.\n\t* expmed.c (expand_shift_1): Fix up handling of vector\n\tshifts and rotates.\n\n\t* gcc.dg/pr57233.c: New test.\n\t* gcc.target/i386/pr57233.c: New test.\n\t* gcc.target/i386/sse2-pr57233.c: New test.\n\t* gcc.target/i386/avx-pr57233.c: New test.\n\t* gcc.target/i386/avx2-pr57233.c: New test.\n\t* gcc.target/i386/avx512f-pr57233.c: New test.\n\t* gcc.target/i386/xop-pr57233.c: New test.\n\nFrom-SVN: r212063", "tree": {"sha": "95f86e468f89c90def7089d63fb1c45c8a0f789e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95f86e468f89c90def7089d63fb1c45c8a0f789e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4ee446d6d7f1c120e9ef281ec4586f7535647cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4ee446d6d7f1c120e9ef281ec4586f7535647cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4ee446d6d7f1c120e9ef281ec4586f7535647cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9698b078c86c21aa6a2a2fb4e5bc198f6f1df24c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9698b078c86c21aa6a2a2fb4e5bc198f6f1df24c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9698b078c86c21aa6a2a2fb4e5bc198f6f1df24c"}], "stats": {"total": 471, "additions": 427, "deletions": 44}, "files": [{"sha": "42e6908fb63c7de09f8dcfb8db3152cb5f8ba609", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a4ee446d6d7f1c120e9ef281ec4586f7535647cc", "patch": "@@ -1,3 +1,16 @@\n+2014-06-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/57233\n+\tPR tree-optimization/61299\n+\t* tree-vect-generic.c (get_compute_type, count_type_subparts): New\n+\tfunctions.\n+\t(expand_vector_operations_1): Use them.  If {L,R}ROTATE_EXPR\n+\twould be lowered to scalar shifts, check if corresponding\n+\tshifts and vector BIT_IOR_EXPR are supported and don't lower\n+\tor lower just to narrower vector type in that case.\n+\t* expmed.c (expand_shift_1): Fix up handling of vector\n+\tshifts and rotates.\n+\n 2014-06-26  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/61586"}, {"sha": "861626ed9220c92d1ad5cebd23d9bce2be07b7a4", "filename": "gcc/expmed.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=a4ee446d6d7f1c120e9ef281ec4586f7535647cc", "patch": "@@ -2128,9 +2128,12 @@ expand_shift_1 (enum tree_code code, enum machine_mode mode, rtx shifted,\n   optab lrotate_optab = rotl_optab;\n   optab rrotate_optab = rotr_optab;\n   enum machine_mode op1_mode;\n+  enum machine_mode scalar_mode = mode;\n   int attempt;\n   bool speed = optimize_insn_for_speed_p ();\n \n+  if (VECTOR_MODE_P (mode))\n+    scalar_mode = GET_MODE_INNER (mode);\n   op1 = amount;\n   op1_mode = GET_MODE (op1);\n \n@@ -2153,9 +2156,9 @@ expand_shift_1 (enum tree_code code, enum machine_mode mode, rtx shifted,\n     {\n       if (CONST_INT_P (op1)\n \t  && ((unsigned HOST_WIDE_INT) INTVAL (op1) >=\n-\t      (unsigned HOST_WIDE_INT) GET_MODE_BITSIZE (mode)))\n+\t      (unsigned HOST_WIDE_INT) GET_MODE_BITSIZE (scalar_mode)))\n \top1 = GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (op1)\n-\t\t       % GET_MODE_BITSIZE (mode));\n+\t\t       % GET_MODE_BITSIZE (scalar_mode));\n       else if (GET_CODE (op1) == SUBREG\n \t       && subreg_lowpart_p (op1)\n \t       && SCALAR_INT_MODE_P (GET_MODE (SUBREG_REG (op1)))\n@@ -2169,10 +2172,10 @@ expand_shift_1 (enum tree_code code, enum machine_mode mode, rtx shifted,\n      amount instead.  */\n   if (rotate\n       && CONST_INT_P (op1)\n-      && IN_RANGE (INTVAL (op1), GET_MODE_BITSIZE (mode) / 2 + left,\n-\t\t   GET_MODE_BITSIZE (mode) - 1))\n+      && IN_RANGE (INTVAL (op1), GET_MODE_BITSIZE (scalar_mode) / 2 + left,\n+\t\t   GET_MODE_BITSIZE (scalar_mode) - 1))\n     {\n-      op1 = GEN_INT (GET_MODE_BITSIZE (mode) - INTVAL (op1));\n+      op1 = GEN_INT (GET_MODE_BITSIZE (scalar_mode) - INTVAL (op1));\n       left = !left;\n       code = left ? LROTATE_EXPR : RROTATE_EXPR;\n     }\n@@ -2185,7 +2188,7 @@ expand_shift_1 (enum tree_code code, enum machine_mode mode, rtx shifted,\n   if (code == LSHIFT_EXPR\n       && CONST_INT_P (op1)\n       && INTVAL (op1) > 0\n-      && INTVAL (op1) < GET_MODE_PRECISION (mode)\n+      && INTVAL (op1) < GET_MODE_PRECISION (scalar_mode)\n       && INTVAL (op1) < MAX_BITS_PER_WORD\n       && (shift_cost (speed, mode, INTVAL (op1))\n \t  > INTVAL (op1) * add_cost (speed, mode))\n@@ -2240,14 +2243,14 @@ expand_shift_1 (enum tree_code code, enum machine_mode mode, rtx shifted,\n \t      if (op1 == const0_rtx)\n \t\treturn shifted;\n \t      else if (CONST_INT_P (op1))\n-\t\tother_amount = GEN_INT (GET_MODE_BITSIZE (mode)\n+\t\tother_amount = GEN_INT (GET_MODE_BITSIZE (scalar_mode)\n \t\t\t\t\t- INTVAL (op1));\n \t      else\n \t\t{\n \t\t  other_amount\n \t\t    = simplify_gen_unary (NEG, GET_MODE (op1),\n \t\t\t\t\t  op1, GET_MODE (op1));\n-\t\t  HOST_WIDE_INT mask = GET_MODE_PRECISION (mode) - 1;\n+\t\t  HOST_WIDE_INT mask = GET_MODE_PRECISION (scalar_mode) - 1;\n \t\t  other_amount\n \t\t    = simplify_gen_binary (AND, GET_MODE (op1), other_amount,\n \t\t\t\t\t   gen_int_mode (mask, GET_MODE (op1)));"}, {"sha": "fdaf19ca5f650cad4fc8db5382452c6f9690aa95", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a4ee446d6d7f1c120e9ef281ec4586f7535647cc", "patch": "@@ -1,3 +1,15 @@\n+2014-06-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/57233\n+\tPR tree-optimization/61299\n+\t* gcc.dg/pr57233.c: New test.\n+\t* gcc.target/i386/pr57233.c: New test.\n+\t* gcc.target/i386/sse2-pr57233.c: New test.\n+\t* gcc.target/i386/avx-pr57233.c: New test.\n+\t* gcc.target/i386/avx2-pr57233.c: New test.\n+\t* gcc.target/i386/avx512f-pr57233.c: New test.\n+\t* gcc.target/i386/xop-pr57233.c: New test.\n+\n 2014-06-27  Sebastian Huber  <sebastian.huber@embedded-brains.de>\n \n \t* gcc.dg/typeof-2.c: New testcase."}, {"sha": "58c05348b85df88b879b56726af36ae8538fc3a7", "filename": "gcc/testsuite/gcc.dg/pr57233.c", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2Ftestsuite%2Fgcc.dg%2Fpr57233.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2Ftestsuite%2Fgcc.dg%2Fpr57233.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr57233.c?ref=a4ee446d6d7f1c120e9ef281ec4586f7535647cc", "patch": "@@ -0,0 +1,171 @@\n+/* PR tree-optimization/57233 */\n+/* { dg-do run { target { ilp32 || lp64 } } } */\n+/* { dg-options \"-O2\" } */\n+\n+typedef unsigned V4 __attribute__((vector_size(4 * sizeof (int))));\n+typedef unsigned V8 __attribute__((vector_size(8 * sizeof (int))));\n+typedef unsigned V16 __attribute__((vector_size(16 * sizeof (int))));\n+V4 a, b, g;\n+V8 c, d, h;\n+V16 e, f, j;\n+\n+__attribute__((noinline)) void\n+f1 (void)\n+{\n+  a = (a << 2) | (a >> 30);\n+}\n+\n+__attribute__((noinline)) void\n+f2 (void)\n+{\n+  a = (a << 30) | (a >> 2);\n+}\n+\n+__attribute__((noinline)) void\n+f3 (void)\n+{\n+  a = (a << b) | (a >> (32 - b));\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f4 (int x)\n+{\n+  a = (a << x) | (a >> (32 - x));\n+}\n+\n+__attribute__((noinline)) void\n+f5 (void)\n+{\n+  c = (c << 2) | (c >> 30);\n+}\n+\n+__attribute__((noinline)) void\n+f6 (void)\n+{\n+  c = (c << 30) | (c >> 2);\n+}\n+\n+__attribute__((noinline)) void\n+f7 (void)\n+{\n+  c = (c << d) | (c >> (32 - d));\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f8 (int x)\n+{\n+  c = (c << x) | (c >> (32 - x));\n+}\n+\n+__attribute__((noinline)) void\n+f9 (void)\n+{\n+  e = (e << 2) | (e >> 30);\n+}\n+\n+__attribute__((noinline)) void\n+f10 (void)\n+{\n+  e = (e << 30) | (e >> 2);\n+}\n+\n+__attribute__((noinline)) void\n+f11 (void)\n+{\n+  e = (e << f) | (e >> (32 - f));\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f12 (int x)\n+{\n+  e = (e << x) | (e >> (32 - x));\n+}\n+\n+unsigned\n+r (void)\n+{\n+  static unsigned x = 0xdeadbeefU;\n+  static unsigned y = 0x12347654U;\n+  static unsigned z = 0x1a2b3c4dU;\n+  static unsigned w = 0x87654321U;\n+  unsigned t = x ^ (x << 11);\n+  x = y;\n+  y = z;\n+  z = w;\n+  w = w ^ (w >> 19) ^ t ^ (t >> 8);\n+  return w;\n+}\n+\n+void\n+init (unsigned int *p, int count, int mod)\n+{\n+  int i;\n+  for (i = 0; i < count; i++)\n+    {\n+      unsigned int v = r ();\n+      if (mod)\n+\tv = (v % 31) + 1;\n+      p[i] = v;\n+    }\n+}\n+\n+void\n+check (unsigned int *p, unsigned int *q, int count, unsigned int *s, int ss)\n+{\n+  int i;\n+  for (i = 0; i < count; i++)\n+    {\n+      if (s)\n+\tss = s[i];\n+      if (p[i] != ((q[i] << ss) | (q[i] >> (32 - ss))))\n+\t__builtin_abort ();\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  init ((unsigned int *) &a, 4, 0);\n+  init ((unsigned int *) &b, 4, 1);\n+  init ((unsigned int *) &c, 8, 0);\n+  init ((unsigned int *) &d, 8, 1);\n+  init ((unsigned int *) &e, 16, 0);\n+  init ((unsigned int *) &f, 16, 1);\n+  g = a;\n+  h = c;\n+  j = e;\n+  f1 ();\n+  f5 ();\n+  f9 ();\n+  check ((unsigned int *) &a, (unsigned int *) &g, 4, 0, 2);\n+  check ((unsigned int *) &c, (unsigned int *) &h, 8, 0, 2);\n+  check ((unsigned int *) &e, (unsigned int *) &j, 16, 0, 2);\n+  g = a;\n+  h = c;\n+  j = e;\n+  f2 ();\n+  f6 ();\n+  f10 ();\n+  check ((unsigned int *) &a, (unsigned int *) &g, 4, 0, 30);\n+  check ((unsigned int *) &c, (unsigned int *) &h, 8, 0, 30);\n+  check ((unsigned int *) &e, (unsigned int *) &j, 16, 0, 30);\n+  g = a;\n+  h = c;\n+  j = e;\n+  f3 ();\n+  f7 ();\n+  f11 ();\n+  check ((unsigned int *) &a, (unsigned int *) &g, 4, (unsigned int *) &b, 0);\n+  check ((unsigned int *) &c, (unsigned int *) &h, 8, (unsigned int *) &d, 0);\n+  check ((unsigned int *) &e, (unsigned int *) &j, 16, (unsigned int *) &f, 0);\n+  g = a;\n+  h = c;\n+  j = e;\n+  f4 (5);\n+  f8 (5);\n+  f12 (5);\n+  check ((unsigned int *) &a, (unsigned int *) &g, 4, 0, 5);\n+  check ((unsigned int *) &c, (unsigned int *) &h, 8, 0, 5);\n+  check ((unsigned int *) &e, (unsigned int *) &j, 16, 0, 5);\n+  return 0;\n+}"}, {"sha": "ffc71d908a8fe146c77ffec1101d30892e4aa040", "filename": "gcc/testsuite/gcc.target/i386/avx-pr57233.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-pr57233.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-pr57233.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-pr57233.c?ref=a4ee446d6d7f1c120e9ef281ec4586f7535647cc", "patch": "@@ -0,0 +1,16 @@\n+/* PR tree-optimization/57233 */\n+/* { dg-do run { target avx } } */\n+/* { dg-options \"-O2 -mavx\" } */\n+\n+#include \"avx-check.h\"\n+\n+static void\n+avx_test (void)\n+{\n+  do_main ();\n+}\n+\n+#undef main\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/pr57233.c\""}, {"sha": "3fb2608ab1878c3b55b5af0a33e8bbed79937d02", "filename": "gcc/testsuite/gcc.target/i386/avx2-pr57233.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-pr57233.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-pr57233.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-pr57233.c?ref=a4ee446d6d7f1c120e9ef281ec4586f7535647cc", "patch": "@@ -0,0 +1,16 @@\n+/* PR tree-optimization/57233 */\n+/* { dg-do run { target avx2 } } */\n+/* { dg-options \"-O2 -mavx2\" } */\n+\n+#include \"avx2-check.h\"\n+\n+static void\n+avx2_test (void)\n+{\n+  do_main ();\n+}\n+\n+#undef main\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/pr57233.c\""}, {"sha": "2f1c23a15546115153871340ae031f2ad34221e3", "filename": "gcc/testsuite/gcc.target/i386/avx512f-pr57233.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-pr57233.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-pr57233.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-pr57233.c?ref=a4ee446d6d7f1c120e9ef281ec4586f7535647cc", "patch": "@@ -0,0 +1,16 @@\n+/* PR tree-optimization/57233 */\n+/* { dg-do run { target avx512f } } */\n+/* { dg-options \"-O2 -mavx512f\" } */\n+\n+#include \"avx512f-check.h\"\n+\n+static void\n+avx512f_test (void)\n+{\n+  do_main ();\n+}\n+\n+#undef main\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/pr57233.c\""}, {"sha": "34182fa7dc4623bced36493e1d6f2118e0892e49", "filename": "gcc/testsuite/gcc.target/i386/pr57233.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr57233.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr57233.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr57233.c?ref=a4ee446d6d7f1c120e9ef281ec4586f7535647cc", "patch": "@@ -0,0 +1,15 @@\n+/* PR tree-optimization/57233 */\n+/* { dg-do compile { target avx } } */\n+/* { dg-options \"-O2 -mavx -mno-xop\" } */\n+\n+typedef unsigned V4 __attribute__((vector_size(4 * sizeof (int))));\n+V4 a;\n+\n+__attribute__((noinline)) void\n+foo (void)\n+{\n+  a = (a << 2) | (a >> 30);\n+}\n+\n+/* { dg-final { scan-assembler \"vpsrld\\[^\\n\\r]*30\" } } */\n+/* { dg-final { scan-assembler \"vpslld\\[^\\n\\r]*2\" } } */"}, {"sha": "8a3bb2fc5e3b3210805263de222c7c111f99a4d4", "filename": "gcc/testsuite/gcc.target/i386/sse2-pr57233.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-pr57233.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-pr57233.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-pr57233.c?ref=a4ee446d6d7f1c120e9ef281ec4586f7535647cc", "patch": "@@ -0,0 +1,16 @@\n+/* PR tree-optimization/57233 */\n+/* { dg-do run { target sse2 } } */\n+/* { dg-options \"-O2 -msse2\" } */\n+\n+#include \"sse2-check.h\"\n+\n+static void\n+sse2_test (void)\n+{\n+  do_main ();\n+}\n+\n+#undef main\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/pr57233.c\""}, {"sha": "6129dc2174452d16aec4debf2da8dfacae5192a6", "filename": "gcc/testsuite/gcc.target/i386/xop-pr57233.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-pr57233.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-pr57233.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-pr57233.c?ref=a4ee446d6d7f1c120e9ef281ec4586f7535647cc", "patch": "@@ -0,0 +1,16 @@\n+/* PR tree-optimization/57233 */\n+/* { dg-do run { target xop } } */\n+/* { dg-options \"-O2 -mxop\" } */\n+\n+#include \"xop-check.h\"\n+\n+static void\n+xop_test (void)\n+{\n+  do_main ();\n+}\n+\n+#undef main\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/pr57233.c\""}, {"sha": "888b09baf87041bd42d1e6fe02ca1b88f1286b6b", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 125, "deletions": 36, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4ee446d6d7f1c120e9ef281ec4586f7535647cc/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=a4ee446d6d7f1c120e9ef281ec4586f7535647cc", "patch": "@@ -1334,15 +1334,67 @@ lower_vec_perm (gimple_stmt_iterator *gsi)\n   update_stmt (gsi_stmt (*gsi));\n }\n \n+/* Return type in which CODE operation with optab OP can be\n+   computed.  */\n+\n+static tree\n+get_compute_type (enum tree_code code, optab op, tree type)\n+{\n+  /* For very wide vectors, try using a smaller vector mode.  */\n+  tree compute_type = type;\n+  if (op\n+      && (!VECTOR_MODE_P (TYPE_MODE (type))\n+\t  || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing))\n+    {\n+      tree vector_compute_type\n+\t= type_for_widest_vector_mode (TREE_TYPE (type), op);\n+      if (vector_compute_type != NULL_TREE\n+\t  && (TYPE_VECTOR_SUBPARTS (vector_compute_type)\n+\t      < TYPE_VECTOR_SUBPARTS (compute_type))\n+\t  && (optab_handler (op, TYPE_MODE (vector_compute_type))\n+\t      != CODE_FOR_nothing))\n+\tcompute_type = vector_compute_type;\n+    }\n+\n+  /* If we are breaking a BLKmode vector into smaller pieces,\n+     type_for_widest_vector_mode has already looked into the optab,\n+     so skip these checks.  */\n+  if (compute_type == type)\n+    {\n+      enum machine_mode compute_mode = TYPE_MODE (compute_type);\n+      if (VECTOR_MODE_P (compute_mode))\n+\t{\n+\t  if (op && optab_handler (op, compute_mode) != CODE_FOR_nothing)\n+\t    return compute_type;\n+\t  if (code == MULT_HIGHPART_EXPR\n+\t      && can_mult_highpart_p (compute_mode,\n+\t\t\t\t      TYPE_UNSIGNED (compute_type)))\n+\t    return compute_type;\n+\t}\n+      /* There is no operation in hardware, so fall back to scalars.  */\n+      compute_type = TREE_TYPE (type);\n+    }\n+\n+  return compute_type;\n+}\n+\n+/* Helper function of expand_vector_operations_1.  Return number of\n+   vector elements for vector types or 1 for other types.  */\n+\n+static inline int\n+count_type_subparts (tree type)\n+{\n+  return VECTOR_TYPE_P (type) ? TYPE_VECTOR_SUBPARTS (type) : 1;\n+}\n+\n /* Process one statement.  If we identify a vector operation, expand it.  */\n \n static void\n expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n {\n   gimple stmt = gsi_stmt (*gsi);\n-  tree lhs, rhs1, rhs2 = NULL, type, compute_type;\n+  tree lhs, rhs1, rhs2 = NULL, type, compute_type = NULL_TREE;\n   enum tree_code code;\n-  enum machine_mode compute_mode;\n   optab op = unknown_optab;\n   enum gimple_rhs_class rhs_class;\n   tree new_rhs;\n@@ -1455,11 +1507,76 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n \t{\n           op = optab_for_tree_code (code, type, optab_scalar);\n \n+\t  compute_type = get_compute_type (code, op, type);\n+\t  if (compute_type == type)\n+\t    return;\n \t  /* The rtl expander will expand vector/scalar as vector/vector\n-\t     if necessary.  Don't bother converting the stmt here.  */\n-\t  if (optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing\n-\t      && optab_handler (opv, TYPE_MODE (type)) != CODE_FOR_nothing)\n+\t     if necessary.  Pick one with wider vector type.  */\n+\t  tree compute_vtype = get_compute_type (code, opv, type);\n+\t  if (count_type_subparts (compute_vtype)\n+\t      > count_type_subparts (compute_type))\n+\t    {\n+\t      compute_type = compute_vtype;\n+\t      op = opv;\n+\t    }\n+\t}\n+\n+      if (code == LROTATE_EXPR || code == RROTATE_EXPR)\n+\t{\n+\t  if (compute_type == NULL_TREE)\n+\t    compute_type = get_compute_type (code, op, type);\n+\t  if (compute_type == type)\n \t    return;\n+\t  /* Before splitting vector rotates into scalar rotates,\n+\t     see if we can't use vector shifts and BIT_IOR_EXPR\n+\t     instead.  For vector by vector rotates we'd also\n+\t     need to check BIT_AND_EXPR and NEGATE_EXPR, punt there\n+\t     for now, fold doesn't seem to create such rotates anyway.  */\n+\t  if (compute_type == TREE_TYPE (type)\n+\t      && !VECTOR_INTEGER_TYPE_P (TREE_TYPE (rhs2)))\n+\t    {\n+\t      optab oplv = vashl_optab, opl = ashl_optab;\n+\t      optab oprv = vlshr_optab, opr = lshr_optab, opo = ior_optab;\n+\t      tree compute_lvtype = get_compute_type (LSHIFT_EXPR, oplv, type);\n+\t      tree compute_rvtype = get_compute_type (RSHIFT_EXPR, oprv, type);\n+\t      tree compute_otype = get_compute_type (BIT_IOR_EXPR, opo, type);\n+\t      tree compute_ltype = get_compute_type (LSHIFT_EXPR, opl, type);\n+\t      tree compute_rtype = get_compute_type (RSHIFT_EXPR, opr, type);\n+\t      /* The rtl expander will expand vector/scalar as vector/vector\n+\t\t if necessary.  Pick one with wider vector type.  */\n+\t      if (count_type_subparts (compute_lvtype)\n+\t\t  > count_type_subparts (compute_ltype))\n+\t\t{\n+\t\t  compute_ltype = compute_lvtype;\n+\t\t  opl = oplv;\n+\t\t}\n+\t      if (count_type_subparts (compute_rvtype)\n+\t\t  > count_type_subparts (compute_rtype))\n+\t\t{\n+\t\t  compute_rtype = compute_rvtype;\n+\t\t  opr = oprv;\n+\t\t}\n+\t      /* Pick the narrowest type from LSHIFT_EXPR, RSHIFT_EXPR and\n+\t\t BIT_IOR_EXPR.  */\n+\t      compute_type = compute_ltype;\n+\t      if (count_type_subparts (compute_type)\n+\t\t  > count_type_subparts (compute_rtype))\n+\t\tcompute_type = compute_rtype;\n+\t      if (count_type_subparts (compute_type)\n+\t\t  > count_type_subparts (compute_otype))\n+\t\tcompute_type = compute_otype;\n+\t      /* Verify all 3 operations can be performed in that type.  */\n+\t      if (compute_type != TREE_TYPE (type))\n+\t\t{\n+\t\t  if (optab_handler (opl, TYPE_MODE (compute_type))\n+\t\t      == CODE_FOR_nothing\n+\t\t      || optab_handler (opr, TYPE_MODE (compute_type))\n+\t\t\t == CODE_FOR_nothing\n+\t\t      || optab_handler (opo, TYPE_MODE (compute_type))\n+\t\t\t == CODE_FOR_nothing)\n+\t\t    compute_type = TREE_TYPE (type);\n+\t\t}\n+\t    }\n \t}\n     }\n   else\n@@ -1473,38 +1590,10 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n       && INTEGRAL_TYPE_P (TREE_TYPE (type)))\n     op = optab_for_tree_code (MINUS_EXPR, type, optab_default);\n \n-  /* For very wide vectors, try using a smaller vector mode.  */\n-  compute_type = type;\n-  if (!VECTOR_MODE_P (TYPE_MODE (type)) && op)\n-    {\n-      tree vector_compute_type\n-        = type_for_widest_vector_mode (TREE_TYPE (type), op);\n-      if (vector_compute_type != NULL_TREE\n-\t  && (TYPE_VECTOR_SUBPARTS (vector_compute_type)\n-\t      < TYPE_VECTOR_SUBPARTS (compute_type))\n-\t  && (optab_handler (op, TYPE_MODE (vector_compute_type))\n-\t      != CODE_FOR_nothing))\n-\tcompute_type = vector_compute_type;\n-    }\n-\n-  /* If we are breaking a BLKmode vector into smaller pieces,\n-     type_for_widest_vector_mode has already looked into the optab,\n-     so skip these checks.  */\n+  if (compute_type == NULL_TREE)\n+    compute_type = get_compute_type (code, op, type);\n   if (compute_type == type)\n-    {\n-      compute_mode = TYPE_MODE (compute_type);\n-      if (VECTOR_MODE_P (compute_mode))\n-\t{\n-          if (op && optab_handler (op, compute_mode) != CODE_FOR_nothing)\n-\t    return;\n-\t  if (code == MULT_HIGHPART_EXPR\n-\t      && can_mult_highpart_p (compute_mode,\n-\t\t\t\t      TYPE_UNSIGNED (compute_type)))\n-\t    return;\n-\t}\n-      /* There is no operation in hardware, so fall back to scalars.  */\n-      compute_type = TREE_TYPE (type);\n-    }\n+    return;\n \n   gcc_assert (code != VEC_LSHIFT_EXPR && code != VEC_RSHIFT_EXPR);\n   new_rhs = expand_vector_operation (gsi, type, compute_type, stmt, code);"}]}