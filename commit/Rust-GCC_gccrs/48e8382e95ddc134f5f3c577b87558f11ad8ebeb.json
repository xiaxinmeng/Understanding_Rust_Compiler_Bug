{"sha": "48e8382e95ddc134f5f3c577b87558f11ad8ebeb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhlODM4MmU5NWRkYzEzNGY1ZjNjNTc3Yjg3NTU4ZjExYWQ4ZWJlYg==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-02-04T20:54:36Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-02-04T20:54:36Z"}, "message": "re PR rtl-optimization/37889 (SEGV, conditional execution proactively executed the false arm.)\n\n2009-02-04  Paolo Bonzini  <bonzini@gnu.org>\n\t    Hans-Peter Nilsson  <hp@axis.com>\n\n\tPR rtl-optimization/37889\n\t* rtlanal.c (rtx_addr_can_trap_p_1): Add offset and size arguments.\n\tMove offset handling from PLUS to before the switch.  Use new\n\targuments when considering SYMBOL_REFs too.\n\t(rtx_addr_can_trap_p): Pass dummy offset and size.\n\t(enum may_trap_p_flags): Remove.\n\t(may_trap_p_1): Pass size from MEM_SIZE.\n\n\tPR rtl-optimization/38921\n\t* loop-invariant.c (find_invariant_insn): Use may_trap_or_fault_p.\n\t* rtl.h (may_trap_after_code_motion_p): Delete prototype.\n\t* rtlanal.c (may_trap_after_code_motion_p): Delete.\n\t(may_trap_p, may_trap_or_fault_p): Pass 0/1 as flags.\n\n\nCo-Authored-By: Hans-Peter Nilsson <hp@axis.com>\n\nFrom-SVN: r143939", "tree": {"sha": "18492e6dd523a8d915f6d21a6db7b043ec15a9dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18492e6dd523a8d915f6d21a6db7b043ec15a9dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48e8382e95ddc134f5f3c577b87558f11ad8ebeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48e8382e95ddc134f5f3c577b87558f11ad8ebeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48e8382e95ddc134f5f3c577b87558f11ad8ebeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48e8382e95ddc134f5f3c577b87558f11ad8ebeb/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "69349ea551c84f1a40c8cb51342ea8075eece875", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69349ea551c84f1a40c8cb51342ea8075eece875", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69349ea551c84f1a40c8cb51342ea8075eece875"}], "stats": {"total": 174, "additions": 109, "deletions": 65}, "files": [{"sha": "f388c1cf56cb17a5afc078d62de3a17bba8b2ae2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e8382e95ddc134f5f3c577b87558f11ad8ebeb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e8382e95ddc134f5f3c577b87558f11ad8ebeb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48e8382e95ddc134f5f3c577b87558f11ad8ebeb", "patch": "@@ -1,3 +1,20 @@\n+2009-02-04  Paolo Bonzini  <bonzini@gnu.org>\n+\t    Hans-Peter Nilsson  <hp@axis.com>\n+\n+\tPR rtl-optimization/37889\n+\t* rtlanal.c (rtx_addr_can_trap_p_1): Add offset and size arguments.\n+\tMove offset handling from PLUS to before the switch.  Use new\n+\targuments when considering SYMBOL_REFs too.\n+\t(rtx_addr_can_trap_p): Pass dummy offset and size.\n+\t(enum may_trap_p_flags): Remove.\n+\t(may_trap_p_1): Pass size from MEM_SIZE.\n+\n+\tPR rtl-optimization/38921\n+\t* loop-invariant.c (find_invariant_insn): Use may_trap_or_fault_p.\n+\t* rtl.h (may_trap_after_code_motion_p): Delete prototype.\n+\t* rtlanal.c (may_trap_after_code_motion_p): Delete.\n+\t(may_trap_p, may_trap_or_fault_p): Pass 0/1 as flags.\n+\n 2009-02-04  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tAVX Programming Reference (January, 2009)"}, {"sha": "8b8345fe5fd208851c499d79e1ecaa4476021d93", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e8382e95ddc134f5f3c577b87558f11ad8ebeb/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e8382e95ddc134f5f3c577b87558f11ad8ebeb/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=48e8382e95ddc134f5f3c577b87558f11ad8ebeb", "patch": "@@ -824,7 +824,7 @@ find_invariant_insn (rtx insn, bool always_reached, bool always_executed)\n     return;\n \n   /* We cannot make trapping insn executed, unless it was executed before.  */\n-  if (may_trap_after_code_motion_p (PATTERN (insn)) && !always_reached)\n+  if (may_trap_or_fault_p (PATTERN (insn)) && !always_reached)\n     return;\n \n   depends_on = BITMAP_ALLOC (NULL);"}, {"sha": "eaedb009e85e7256d6473e0ff37d329f04866241", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e8382e95ddc134f5f3c577b87558f11ad8ebeb/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e8382e95ddc134f5f3c577b87558f11ad8ebeb/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=48e8382e95ddc134f5f3c577b87558f11ad8ebeb", "patch": "@@ -1767,7 +1767,6 @@ extern int volatile_refs_p (const_rtx);\n extern int volatile_insn_p (const_rtx);\n extern int may_trap_p_1 (const_rtx, unsigned);\n extern int may_trap_p (const_rtx);\n-extern int may_trap_after_code_motion_p (const_rtx);\n extern int may_trap_or_fault_p (const_rtx);\n extern int inequality_comparisons_p (const_rtx);\n extern rtx replace_rtx (rtx, rtx, rtx);"}, {"sha": "cc7775ffd638f553ef1528adddef93941520fe0e", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 91, "deletions": 63, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e8382e95ddc134f5f3c577b87558f11ad8ebeb/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e8382e95ddc134f5f3c577b87558f11ad8ebeb/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=48e8382e95ddc134f5f3c577b87558f11ad8ebeb", "patch": "@@ -263,14 +263,68 @@ rtx_varies_p (const_rtx x, bool for_alias)\n    alignment machines.  */\n \n static int\n-rtx_addr_can_trap_p_1 (const_rtx x, enum machine_mode mode, bool unaligned_mems)\n+rtx_addr_can_trap_p_1 (const_rtx x, HOST_WIDE_INT offset, HOST_WIDE_INT size,\n+\t\t       enum machine_mode mode, bool unaligned_mems)\n {\n   enum rtx_code code = GET_CODE (x);\n \n+  if (STRICT_ALIGNMENT\n+      && unaligned_mems\n+      && GET_MODE_SIZE (mode) != 0)\n+    {\n+      HOST_WIDE_INT actual_offset = offset;\n+#ifdef SPARC_STACK_BOUNDARY_HACK\n+      /* ??? The SPARC port may claim a STACK_BOUNDARY higher than\n+\t     the real alignment of %sp.  However, when it does this, the\n+\t     alignment of %sp+STACK_POINTER_OFFSET is STACK_BOUNDARY.  */\n+      if (SPARC_STACK_BOUNDARY_HACK\n+\t  && (x == stack_pointer_rtx || x == hard_frame_pointer_rtx))\n+\tactual_offset -= STACK_POINTER_OFFSET;\n+#endif\n+\n+      return actual_offset % GET_MODE_SIZE (mode) != 0;\n+    }\n+\n   switch (code)\n     {\n     case SYMBOL_REF:\n-      return SYMBOL_REF_WEAK (x);\n+      if (SYMBOL_REF_WEAK (x))\n+\treturn 1;\n+      if (!CONSTANT_POOL_ADDRESS_P (x))\n+\t{\n+\t  tree decl;\n+\t  HOST_WIDE_INT decl_size;\n+\n+\t  if (offset < 0)\n+\t    return 1;\n+\t  if (size == 0)\n+\t    size = GET_MODE_SIZE (mode);\n+\t  if (size == 0)\n+\t    return offset != 0;\n+\n+\t  /* If the size of the access or of the symbol is unknown,\n+\t     assume the worst.  */\n+\t  decl = SYMBOL_REF_DECL (x);\n+\n+\t  /* Else check that the access is in bounds.  TODO: restructure\n+\t     expr_size/lhd_expr_size/int_expr_size and just use the latter.  */\n+\t  if (!decl)\n+\t    decl_size = -1;\n+\t  else if (DECL_P (decl) && DECL_SIZE_UNIT (decl))\n+\t    decl_size = (host_integerp (DECL_SIZE_UNIT (decl), 0)\n+\t\t\t ? tree_low_cst (DECL_SIZE_UNIT (decl), 0)\n+\t\t\t : -1);\n+\t  else if (TREE_CODE (decl) == STRING_CST)\n+\t    decl_size = TREE_STRING_LENGTH (decl);\n+\t  else if (TYPE_SIZE_UNIT (TREE_TYPE (decl)))\n+\t    decl_size = int_size_in_bytes (TREE_TYPE (decl));\n+\t  else\n+\t    decl_size = -1;\n+\n+\t  return (decl_size <= 0 ? offset != 0 : offset + size > decl_size);\n+        }\n+\n+      return 0;\n \n     case LABEL_REF:\n       return 0;\n@@ -289,54 +343,37 @@ rtx_addr_can_trap_p_1 (const_rtx x, enum machine_mode mode, bool unaligned_mems)\n       return 1;\n \n     case CONST:\n-      return rtx_addr_can_trap_p_1 (XEXP (x, 0), mode, unaligned_mems);\n+      return rtx_addr_can_trap_p_1 (XEXP (x, 0), offset, size,\n+\t\t\t\t    mode, unaligned_mems);\n \n     case PLUS:\n       /* An address is assumed not to trap if:\n-\t - it is an address that can't trap plus a constant integer,\n+         - it is the pic register plus a constant.  */\n+      if (XEXP (x, 0) == pic_offset_table_rtx && CONSTANT_P (XEXP (x, 1)))\n+\treturn 0;\n+\n+      /* - or it is an address that can't trap plus a constant integer,\n \t   with the proper remainder modulo the mode size if we are\n \t   considering unaligned memory references.  */\n-      if (!rtx_addr_can_trap_p_1 (XEXP (x, 0), mode, unaligned_mems)\n-\t  && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t{\n-\t  HOST_WIDE_INT offset;\n-\n-\t  if (!STRICT_ALIGNMENT\n-\t      || !unaligned_mems\n-\t      || GET_MODE_SIZE (mode) == 0)\n-\t    return 0;\n-\n-\t  offset = INTVAL (XEXP (x, 1));\n-\n-#ifdef SPARC_STACK_BOUNDARY_HACK\n-\t  /* ??? The SPARC port may claim a STACK_BOUNDARY higher than\n-\t     the real alignment of %sp.  However, when it does this, the\n-\t     alignment of %sp+STACK_POINTER_OFFSET is STACK_BOUNDARY.  */\n-\t  if (SPARC_STACK_BOUNDARY_HACK\n-\t      && (XEXP (x, 0) == stack_pointer_rtx\n-\t\t  || XEXP (x, 0) == hard_frame_pointer_rtx))\n-\t    offset -= STACK_POINTER_OFFSET;\n-#endif\n-\n-\t  return offset % GET_MODE_SIZE (mode) != 0;\n-\t}\n-\n-      /* - or it is the pic register plus a constant.  */\n-      if (XEXP (x, 0) == pic_offset_table_rtx && CONSTANT_P (XEXP (x, 1)))\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && !rtx_addr_can_trap_p_1 (XEXP (x, 0), offset + INTVAL (XEXP (x, 1)),\n+\t\t\t\t     size, mode, unaligned_mems))\n \treturn 0;\n \n       return 1;\n \n     case LO_SUM:\n     case PRE_MODIFY:\n-      return rtx_addr_can_trap_p_1 (XEXP (x, 1), mode, unaligned_mems);\n+      return rtx_addr_can_trap_p_1 (XEXP (x, 1), offset, size,\n+\t\t\t\t    mode, unaligned_mems);\n \n     case PRE_DEC:\n     case PRE_INC:\n     case POST_DEC:\n     case POST_INC:\n     case POST_MODIFY:\n-      return rtx_addr_can_trap_p_1 (XEXP (x, 0), mode, unaligned_mems);\n+      return rtx_addr_can_trap_p_1 (XEXP (x, 0), offset, size,\n+\t\t\t\t    mode, unaligned_mems);\n \n     default:\n       break;\n@@ -351,7 +388,7 @@ rtx_addr_can_trap_p_1 (const_rtx x, enum machine_mode mode, bool unaligned_mems)\n int\n rtx_addr_can_trap_p (const_rtx x)\n {\n-  return rtx_addr_can_trap_p_1 (x, VOIDmode, false);\n+  return rtx_addr_can_trap_p_1 (x, 0, 0, VOIDmode, false);\n }\n \n /* Return true if X is an address that is known to not be zero.  */\n@@ -2170,25 +2207,22 @@ side_effects_p (const_rtx x)\n   return 0;\n }\n \f\n-enum may_trap_p_flags\n-{\n-  MTP_UNALIGNED_MEMS = 1,\n-  MTP_AFTER_MOVE = 2\n-};\n /* Return nonzero if evaluating rtx X might cause a trap.\n-   (FLAGS & MTP_UNALIGNED_MEMS) controls whether nonzero is returned for\n-   unaligned memory accesses on strict alignment machines.  If\n-   (FLAGS & AFTER_MOVE) is true, returns nonzero even in case the expression\n-   cannot trap at its current location, but it might become trapping if moved\n-   elsewhere.  */\n+   FLAGS controls how to consider MEMs.  A nonzero means the context\n+   of the access may have changed from the original, such that the\n+   address may have become invalid.  */\n \n int\n may_trap_p_1 (const_rtx x, unsigned flags)\n {\n   int i;\n   enum rtx_code code;\n   const char *fmt;\n-  bool unaligned_mems = (flags & MTP_UNALIGNED_MEMS) != 0;\n+\n+  /* We make no distinction currently, but this function is part of\n+     the internal target-hooks ABI so we keep the parameter as\n+     \"unsigned flags\".  */\n+  bool code_changed = flags != 0;\n \n   if (x == 0)\n     return 0;\n@@ -2223,14 +2257,17 @@ may_trap_p_1 (const_rtx x, unsigned flags)\n       /* Memory ref can trap unless it's a static var or a stack slot.  */\n     case MEM:\n       if (/* MEM_NOTRAP_P only relates to the actual position of the memory\n-\t     reference; moving it out of condition might cause its address\n-\t     become invalid.  */\n-\t  !(flags & MTP_AFTER_MOVE)\n-\t  && MEM_NOTRAP_P (x)\n-\t  && (!STRICT_ALIGNMENT || !unaligned_mems))\n-\treturn 0;\n-      return\n-\trtx_addr_can_trap_p_1 (XEXP (x, 0), GET_MODE (x), unaligned_mems);\n+\t     reference; moving it out of context such as when moving code\n+\t     when optimizing, might cause its address to become invalid.  */\n+\t  code_changed\n+\t  || !MEM_NOTRAP_P (x))\n+\t{\n+\t  HOST_WIDE_INT size = MEM_SIZE (x) ? INTVAL (MEM_SIZE (x)) : 0;\n+\t  return rtx_addr_can_trap_p_1 (XEXP (x, 0), 0, size,\n+\t\t\t\t\tGET_MODE (x), code_changed);\n+\t}\n+\n+      return 0;\n \n       /* Division by a non-constant might trap.  */\n     case DIV:\n@@ -2328,15 +2365,6 @@ may_trap_p (const_rtx x)\n   return may_trap_p_1 (x, 0);\n }\n \n-/* Return nonzero if evaluating rtx X might cause a trap, when the expression\n-   is moved from its current location by some optimization.  */\n-\n-int\n-may_trap_after_code_motion_p (const_rtx x)\n-{\n-  return may_trap_p_1 (x, MTP_AFTER_MOVE);\n-}\n-\n /* Same as above, but additionally return nonzero if evaluating rtx X might\n    cause a fault.  We define a fault for the purpose of this function as a\n    erroneous execution condition that cannot be encountered during the normal\n@@ -2380,7 +2408,7 @@ may_trap_after_code_motion_p (const_rtx x)\n int\n may_trap_or_fault_p (const_rtx x)\n {\n-  return may_trap_p_1 (x, MTP_UNALIGNED_MEMS);\n+  return may_trap_p_1 (x, 1);\n }\n \f\n /* Return nonzero if X contains a comparison that is not either EQ or NE,"}]}