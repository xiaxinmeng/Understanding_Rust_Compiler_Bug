{"sha": "60c5236ed15a2461aa9f7a12a6db329a2ff03528", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBjNTIzNmVkMTVhMjQ2MWFhOWY3YTEyYTZkYjMyOWEyZmYwMzUyOA==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2011-03-09T18:30:11Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2011-03-09T18:30:11Z"}, "message": "[multiple changes]\n\n2011-03-09  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* testsuite/util/testsuite_rvalref.h: Minor tweaks.\n\n2011-03-09  Jonathan Wakely  <redi@gcc.gnu.org>\n\t    Chris Jefferson  <chris@bubblescope.net>\n\t    Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* testsuite/util/testsuite_rvalref.h (rvalstruct_compare_by_value):\n\tNew.\n\t* testsuite/25_algorithms/sort_heap/check_compare_by_value.cc:\n\tLikewise.\n\t* testsuite/25_algorithms/partial_sort/check_compare_by_value:\n\tLikewise.\n\t* testsuite/25_algorithms/stable_sort/check_compare_by_value.cc:\n\tLikewise.\n\t* testsuite/25_algorithms/sort/check_compare_by_value: Likewise.\n\n2011-03-09  Chris Jefferson  <chris@bubblescope.net>\n\n\tPR libstdc++/48038\n\t* include/bits/stl_algo.h (__merge_backward): Rename to\n\t__move_merge_backward and change to always move rather than copy.\n\t(__move_merge): New function similar to std::merge except values\n\tare moved instead of copied.\n\t(__merge_adaptive, __merge_sort_loop): Change from using std::merge\n\tand __merge_backward to __move_merge and __move_merge_backward.\n\nFrom-SVN: r170827", "tree": {"sha": "495b5d52a3e445f1c4f2f20a48bddbe219fc335c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/495b5d52a3e445f1c4f2f20a48bddbe219fc335c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60c5236ed15a2461aa9f7a12a6db329a2ff03528", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60c5236ed15a2461aa9f7a12a6db329a2ff03528", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60c5236ed15a2461aa9f7a12a6db329a2ff03528", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60c5236ed15a2461aa9f7a12a6db329a2ff03528/comments", "author": null, "committer": null, "parents": [{"sha": "3a8face47ee8bb94a50a98a0cfb5c5fd6292e58c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a8face47ee8bb94a50a98a0cfb5c5fd6292e58c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a8face47ee8bb94a50a98a0cfb5c5fd6292e58c"}], "stats": {"total": 665, "additions": 573, "deletions": 92}, "files": [{"sha": "6c3f1d34cda58cd698ea2664758b19a5e346e183", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c5236ed15a2461aa9f7a12a6db329a2ff03528/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c5236ed15a2461aa9f7a12a6db329a2ff03528/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=60c5236ed15a2461aa9f7a12a6db329a2ff03528", "patch": "@@ -1,10 +1,38 @@\n+2011-03-09  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* testsuite/util/testsuite_rvalref.h: Minor tweaks.\n+\n+2011-03-09  Jonathan Wakely  <redi@gcc.gnu.org>\n+\t    Chris Jefferson  <chris@bubblescope.net>\n+\t    Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* testsuite/util/testsuite_rvalref.h (rvalstruct_compare_by_value):\n+\tNew.\n+\t* testsuite/25_algorithms/sort_heap/check_compare_by_value.cc:\n+\tLikewise.\n+\t* testsuite/25_algorithms/partial_sort/check_compare_by_value:\n+\tLikewise.\n+\t* testsuite/25_algorithms/stable_sort/check_compare_by_value.cc:\n+\tLikewise.\n+\t* testsuite/25_algorithms/sort/check_compare_by_value: Likewise.\n+\n+2011-03-09  Chris Jefferson  <chris@bubblescope.net>\n+\n+\tPR libstdc++/48038\n+\t* include/bits/stl_algo.h (__merge_backward): Rename to\n+\t__move_merge_backward and change to always move rather than copy.\n+\t(__move_merge): New function similar to std::merge except values\n+\tare moved instead of copied.\n+\t(__merge_adaptive, __merge_sort_loop): Change from using std::merge\n+\tand __merge_backward to __move_merge and __move_merge_backward.\n+\n 2011-03-07  Jason Merrill  <jason@redhat.com>\n \n \t* testsuite/20_util/ratio/cons/cons_overflow_neg.cc: Adjust\n \texpected errors.\n \n 2011-03-07  Benjamin Kosnik  <bkoz@redhat.com>\n-            Matthias Klose  <doko@ubuntu.com>\n+\t    Matthias Klose  <doko@ubuntu.com>\n \t    Jonathan Wakely  <redi@gcc.gnu.org>\n \n \tPR libstdc++/47145"}, {"sha": "5fc561e25e91e0a1990518dde9f1f706c7fe2cd8", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "modified", "additions": 96, "deletions": 69, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c5236ed15a2461aa9f7a12a6db329a2ff03528/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c5236ed15a2461aa9f7a12a6db329a2ff03528/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=60c5236ed15a2461aa9f7a12a6db329a2ff03528", "patch": "@@ -2720,32 +2720,32 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,\n \t   typename _BidirectionalIterator3>\n     _BidirectionalIterator3\n-    __merge_backward(_BidirectionalIterator1 __first1,\n-\t\t     _BidirectionalIterator1 __last1,\n-\t\t     _BidirectionalIterator2 __first2,\n-\t\t     _BidirectionalIterator2 __last2,\n-\t\t     _BidirectionalIterator3 __result)\n+    __move_merge_backward(_BidirectionalIterator1 __first1,\n+\t\t\t  _BidirectionalIterator1 __last1,\n+\t\t\t  _BidirectionalIterator2 __first2,\n+\t\t\t  _BidirectionalIterator2 __last2,\n+\t\t\t  _BidirectionalIterator3 __result)\n     {\n       if (__first1 == __last1)\n-\treturn std::copy_backward(__first2, __last2, __result);\n+\treturn _GLIBCXX_MOVE_BACKWARD3(__first2, __last2, __result);\n       if (__first2 == __last2)\n-\treturn std::copy_backward(__first1, __last1, __result);\n+\treturn _GLIBCXX_MOVE_BACKWARD3(__first1, __last1, __result);\n       --__last1;\n       --__last2;\n       while (true)\n \t{\n \t  if (*__last2 < *__last1)\n \t    {\n-\t      *--__result = *__last1;\n+\t      *--__result = _GLIBCXX_MOVE(*__last1);\n \t      if (__first1 == __last1)\n-\t\treturn std::copy_backward(__first2, ++__last2, __result);\n+\t\treturn _GLIBCXX_MOVE_BACKWARD3(__first2, ++__last2, __result);\n \t      --__last1;\n \t    }\n \t  else\n \t    {\n-\t      *--__result = *__last2;\n+\t      *--__result = _GLIBCXX_MOVE(*__last2);\n \t      if (__first2 == __last2)\n-\t\treturn std::copy_backward(__first1, ++__last1, __result);\n+\t\treturn _GLIBCXX_MOVE_BACKWARD3(__first1, ++__last1, __result);\n \t      --__last2;\n \t    }\n \t}\n@@ -2755,38 +2755,93 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,\n \t   typename _BidirectionalIterator3, typename _Compare>\n     _BidirectionalIterator3\n-    __merge_backward(_BidirectionalIterator1 __first1,\n-\t\t     _BidirectionalIterator1 __last1,\n-\t\t     _BidirectionalIterator2 __first2,\n-\t\t     _BidirectionalIterator2 __last2,\n-\t\t     _BidirectionalIterator3 __result,\n-\t\t     _Compare __comp)\n+    __move_merge_backward(_BidirectionalIterator1 __first1,\n+\t\t\t  _BidirectionalIterator1 __last1,\n+\t\t\t  _BidirectionalIterator2 __first2,\n+\t\t\t  _BidirectionalIterator2 __last2,\n+\t\t\t  _BidirectionalIterator3 __result,\n+\t\t\t  _Compare __comp)\n     {\n       if (__first1 == __last1)\n-\treturn std::copy_backward(__first2, __last2, __result);\n+\treturn _GLIBCXX_MOVE_BACKWARD3(__first2, __last2, __result);\n       if (__first2 == __last2)\n-\treturn std::copy_backward(__first1, __last1, __result);\n+\treturn _GLIBCXX_MOVE_BACKWARD3(__first1, __last1, __result);\n       --__last1;\n       --__last2;\n       while (true)\n \t{\n \t  if (__comp(*__last2, *__last1))\n \t    {\n-\t      *--__result = *__last1;\n+\t      *--__result = _GLIBCXX_MOVE(*__last1);\n \t      if (__first1 == __last1)\n-\t\treturn std::copy_backward(__first2, ++__last2, __result);\n+\t\treturn _GLIBCXX_MOVE_BACKWARD3(__first2, ++__last2, __result);\n \t      --__last1;\n \t    }\n \t  else\n \t    {\n-\t      *--__result = *__last2;\n+\t      *--__result = _GLIBCXX_MOVE(*__last2);\n \t      if (__first2 == __last2)\n-\t\treturn std::copy_backward(__first1, ++__last1, __result);\n+\t\treturn _GLIBCXX_MOVE_BACKWARD3(__first1, ++__last1, __result);\n \t      --__last2;\n \t    }\n \t}\n     }\n \n+  /// This is a helper function for the merge routines.\n+  template<typename _InputIterator1, typename _InputIterator2,\n+\t   typename _OutputIterator>\n+    _OutputIterator\n+    __move_merge(_InputIterator1 __first1, _InputIterator1 __last1,\n+\t\t _InputIterator2 __first2, _InputIterator2 __last2,\n+\t\t _OutputIterator __result)\n+    {\n+      while (__first1 != __last1 && __first2 != __last2)\n+\t{\n+\t  if (*__first2 < *__first1)\n+\t    {\n+\t      *__result = _GLIBCXX_MOVE(*__first2);\n+\t      ++__first2;\n+\t    }\n+\t  else\n+\t    {\n+\t      *__result = _GLIBCXX_MOVE(*__first1);\n+\t      ++__first1;\n+\t    }\n+\t  ++__result;\n+\t}\n+      return _GLIBCXX_MOVE3(__first2, __last2,\n+\t\t\t    _GLIBCXX_MOVE3(__first1, __last1,\n+\t\t\t\t\t   __result));\n+    }\n+\n+  /// This is a helper function for the merge routines.\n+  template<typename _InputIterator1, typename _InputIterator2,\n+\t   typename _OutputIterator, typename _Compare>\n+    _OutputIterator\n+    __move_merge(_InputIterator1 __first1, _InputIterator1 __last1,\n+\t\t _InputIterator2 __first2, _InputIterator2 __last2,\n+\t\t _OutputIterator __result, _Compare __comp)\n+    {\n+      while (__first1 != __last1 && __first2 != __last2)\n+\t{\n+\t  if (__comp(*__first2, *__first1))\n+\t    {\n+\t      *__result = _GLIBCXX_MOVE(*__first2);\n+\t      ++__first2;\n+\t    }\n+\t  else\n+\t    {\n+\t      *__result = _GLIBCXX_MOVE(*__first1);\n+\t      ++__first1;\n+\t    }\n+\t  ++__result;\n+\t}\n+      return _GLIBCXX_MOVE3(__first2, __last2,\n+\t\t\t    _GLIBCXX_MOVE3(__first1, __last1,\n+\t\t\t\t\t   __result));\n+    }\n+\n+\n   /// This is a helper function for the merge routines.\n   template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,\n \t   typename _Distance>\n@@ -2832,20 +2887,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (__len1 <= __len2 && __len1 <= __buffer_size)\n \t{\n \t  _Pointer __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);\n-\t  _GLIBCXX_STD_A::merge(_GLIBCXX_MAKE_MOVE_ITERATOR(__buffer),\n-\t\t\t\t_GLIBCXX_MAKE_MOVE_ITERATOR(__buffer_end),\n-\t\t\t\t_GLIBCXX_MAKE_MOVE_ITERATOR(__middle),\n-\t\t\t\t_GLIBCXX_MAKE_MOVE_ITERATOR(__last),\n-\t\t\t\t__first);\n+\t  std::__move_merge(__buffer, __buffer_end, __middle, __last, __first);\n \t}\n       else if (__len2 <= __buffer_size)\n \t{\n \t  _Pointer __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);\n-\t  std::__merge_backward(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),\n-\t\t\t\t_GLIBCXX_MAKE_MOVE_ITERATOR(__middle),\n-\t\t\t\t_GLIBCXX_MAKE_MOVE_ITERATOR(__buffer),\n-\t\t\t\t_GLIBCXX_MAKE_MOVE_ITERATOR(__buffer_end),\n-\t\t\t\t__last);\n+\t  std::__move_merge_backward(__first, __middle, __buffer,\n+\t\t\t\t    __buffer_end, __last);\n \t}\n       else\n \t{\n@@ -2895,20 +2943,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (__len1 <= __len2 && __len1 <= __buffer_size)\n \t{\n \t  _Pointer __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);\n-\t  _GLIBCXX_STD_A::merge(_GLIBCXX_MAKE_MOVE_ITERATOR(__buffer),\n-\t\t\t\t_GLIBCXX_MAKE_MOVE_ITERATOR(__buffer_end),\n-\t\t\t\t_GLIBCXX_MAKE_MOVE_ITERATOR(__middle),\n-\t\t\t\t_GLIBCXX_MAKE_MOVE_ITERATOR(__last),\n-\t\t\t\t__first, __comp);\n+\t  std::__move_merge(__buffer, __buffer_end, __middle, __last,\n+\t\t\t    __first, __comp);\n \t}\n       else if (__len2 <= __buffer_size)\n \t{\n \t  _Pointer __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);\n-\t  std::__merge_backward(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),\n-\t\t\t\t_GLIBCXX_MAKE_MOVE_ITERATOR(__middle),\n-\t\t\t\t_GLIBCXX_MAKE_MOVE_ITERATOR(__buffer),\n-\t\t\t\t_GLIBCXX_MAKE_MOVE_ITERATOR(__buffer_end),\n-\t\t\t\t__last,__comp);\n+\t  std::__move_merge_backward(__first, __middle, __buffer, __buffer_end,\n+\t\t\t\t     __last, __comp);\n \t}\n       else\n \t{\n@@ -3157,23 +3199,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       while (__last - __first >= __two_step)\n \t{\n-\t  __result = _GLIBCXX_STD_A::merge(\n-\t\t\t_GLIBCXX_MAKE_MOVE_ITERATOR(__first),\n-\t\t\t_GLIBCXX_MAKE_MOVE_ITERATOR(__first + __step_size),\n-\t\t\t_GLIBCXX_MAKE_MOVE_ITERATOR(__first + __step_size),\n-\t\t\t_GLIBCXX_MAKE_MOVE_ITERATOR(__first + __two_step),\n-\t\t\t__result);\n+\t  __result = std::__move_merge(__first, __first + __step_size,\n+\t\t\t\t       __first + __step_size,\n+\t\t\t\t       __first + __two_step, __result);\n \t  __first += __two_step;\n \t}\n \n       __step_size = std::min(_Distance(__last - __first), __step_size);\n-      _GLIBCXX_STD_A::merge(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),\n-\t\t\t    _GLIBCXX_MAKE_MOVE_ITERATOR(__first +\n-\t\t\t\t\t\t\t__step_size),\n-\t\t\t    _GLIBCXX_MAKE_MOVE_ITERATOR(__first +\n-\t\t\t\t\t\t\t__step_size),\n-\t\t\t    _GLIBCXX_MAKE_MOVE_ITERATOR(__last),\n-\t\t\t    __result);\n+      std::__move_merge(__first, __first + __step_size,\n+\t\t\t__first + __step_size, __last, __result);\n     }\n \n   template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,\n@@ -3188,23 +3222,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       while (__last - __first >= __two_step)\n \t{\n-\t  __result = _GLIBCXX_STD_A::merge(\n-\t\t\t_GLIBCXX_MAKE_MOVE_ITERATOR(__first),\n-\t\t\t_GLIBCXX_MAKE_MOVE_ITERATOR(__first + __step_size),\n-\t\t\t_GLIBCXX_MAKE_MOVE_ITERATOR(__first + __step_size),\n-\t\t\t_GLIBCXX_MAKE_MOVE_ITERATOR(__first + __two_step),\n-\t\t\t__result, __comp);\n+\t  __result = std::__move_merge(__first, __first + __step_size,\n+\t\t\t\t       __first + __step_size,\n+\t\t\t\t       __first + __two_step,\n+\t\t\t\t       __result, __comp);\n \t  __first += __two_step;\n \t}\n       __step_size = std::min(_Distance(__last - __first), __step_size);\n \n-      _GLIBCXX_STD_A::merge(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),\n-\t\t\t    _GLIBCXX_MAKE_MOVE_ITERATOR(__first +\n-\t\t\t\t\t\t\t__step_size),\n-\t\t\t    _GLIBCXX_MAKE_MOVE_ITERATOR(__first +\n-\t\t\t\t\t\t\t__step_size),\n-\t\t\t    _GLIBCXX_MAKE_MOVE_ITERATOR(__last),\n-\t\t\t    __result, __comp);\n+      std::__move_merge(__first,__first + __step_size,\n+\t\t\t__first + __step_size, __last, __result, __comp);\n     }\n \n   template<typename _RandomAccessIterator, typename _Distance>"}, {"sha": "e6bb20f6b25c139c8394d103ff77dc8c90e28eb9", "filename": "libstdc++-v3/testsuite/25_algorithms/partial_sort/check_compare_by_value.cc", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c5236ed15a2461aa9f7a12a6db329a2ff03528/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpartial_sort%2Fcheck_compare_by_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c5236ed15a2461aa9f7a12a6db329a2ff03528/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpartial_sort%2Fcheck_compare_by_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpartial_sort%2Fcheck_compare_by_value.cc?ref=60c5236ed15a2461aa9f7a12a6db329a2ff03528", "patch": "@@ -0,0 +1,93 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 25.3.1.3 [lib.partial.sort]\n+\n+#undef _GLIBCXX_CONCEPT_CHECKS\n+\n+// XXX FIXME:  parallel-mode should deal correctly with moveable-only types\n+// per C++0x, at minimum smoothly fall back to serial.\n+#undef _GLIBCXX_PARALLEL\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+#include <testsuite_rvalref.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::random_access_iterator_wrapper;\n+\n+typedef __gnu_test::rvalstruct_compare_by_value V;\n+typedef test_container<V, random_access_iterator_wrapper> Container;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  V s1[] = { 10, 20, 1, 11, 2, 12, 3, 13, 4, 14, 5, 15, 6, 16, 7, \n+\t     17, 8, 18, 9, 19 };\n+  const int N = sizeof(s1) / sizeof(V);\n+  Container con(s1, s1 + N);\n+  std::partial_sort(con.begin(), con.begin() + 10, con.end());\n+  VERIFY( s1[0].ok );\n+  for(int i = 1; i < 10; ++i)\n+    VERIFY( s1[i].val > s1[i - 1].val && s1[i].ok );\n+  for(int i = 10; i < N; ++i)\n+    VERIFY( s1[i].val > s1[9].val && s1[i].ok );\n+\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  V s1[] = { 10, 20, 1, 11, 2, 12, 3, 13, 4, 14, 5, 15, 6, 16, 7, \n+\t     17, 8, 18, 9, 19 };\n+  const int N = sizeof(s1) / sizeof(V);\n+  Container con(s1, s1 + N);\n+  std::partial_sort(con.begin(), con.begin() + 10, con.end(),\n+\t\t    __gnu_test::order);\n+  VERIFY( s1[0].ok );\n+  for(int i = 1; i < 10; ++i)\n+    VERIFY( s1[i].val > s1[i - 1].val && s1[i].ok );\n+  for(int i = 10; i < N; ++i)\n+    VERIFY( s1[i].val > s1[9].val && s1[i].ok );\n+}\n+\n+void\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  V vvs[] = { 2, 0 };\n+  std::partial_sort(vvs, vvs + 2, vvs + 2);\n+  VERIFY( vvs[0].ok && vvs[0].val == 0 );\n+  VERIFY( vvs[1].ok && vvs[1].val == 2 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "ac3e2f7d4ef4d9b44cd59bbf78f7888f62f4f2cf", "filename": "libstdc++-v3/testsuite/25_algorithms/sort/check_compare_by_value.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c5236ed15a2461aa9f7a12a6db329a2ff03528/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsort%2Fcheck_compare_by_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c5236ed15a2461aa9f7a12a6db329a2ff03528/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsort%2Fcheck_compare_by_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsort%2Fcheck_compare_by_value.cc?ref=60c5236ed15a2461aa9f7a12a6db329a2ff03528", "patch": "@@ -0,0 +1,86 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 25.3.1 algorithms, sort\n+\n+#undef _GLIBCXX_CONCEPT_CHECKS\n+\n+// XXX FIXME:  parallel-mode should deal correctly with moveable-only types\n+// per C++0x, at minimum smoothly fall back to serial.\n+#undef _GLIBCXX_PARALLEL\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+#include <testsuite_rvalref.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::random_access_iterator_wrapper;\n+\n+typedef __gnu_test::rvalstruct_compare_by_value V;\n+typedef test_container<V, random_access_iterator_wrapper> Container;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  V s1[] = { 10, 20, 1, 11, 2, 12, 3, 13, 4, 14, 5, 15, 6, 16, 7, \n+\t     17, 8, 18, 9, 19 };\n+  const int N = sizeof(s1) / sizeof(V);\n+  Container con(s1, s1 + N);\n+  std::sort(con.begin(), con.end());\n+  VERIFY( s1[0].ok );\n+  for(int i = 1; i < N; ++i)\n+    VERIFY( s1[i].val > s1[i - 1].val && s1[i].ok );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  V s1[] = { 10, 20, 1, 11, 2, 12, 3, 13, 4, 14, 5, 15, 6, 16, 7, \n+\t     17, 8, 18, 9, 19 };\n+  const int N = sizeof(s1) / sizeof(V);\n+  Container con(s1, s1 + N);\n+  std::sort(con.begin(), con.end(), __gnu_test::order);\n+  VERIFY( s1[0].ok );\n+  for(int i = 1; i < N; ++i)\n+    VERIFY( s1[i].val > s1[i - 1].val && s1[i].ok );\n+}\n+\n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  V vvs[] = { 2, 0 };\n+  std::sort(vvs, vvs + 2);\n+  VERIFY( vvs[0].ok && vvs[0].val == 0 );\n+  VERIFY( vvs[1].ok && vvs[1].val == 2 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "32cff8fd8548fa5af03b229c41b2ced06373ca72", "filename": "libstdc++-v3/testsuite/25_algorithms/sort_heap/check_compare_by_value.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c5236ed15a2461aa9f7a12a6db329a2ff03528/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsort_heap%2Fcheck_compare_by_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c5236ed15a2461aa9f7a12a6db329a2ff03528/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsort_heap%2Fcheck_compare_by_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsort_heap%2Fcheck_compare_by_value.cc?ref=60c5236ed15a2461aa9f7a12a6db329a2ff03528", "patch": "@@ -0,0 +1,88 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#undef _GLIBCXX_CONCEPT_CHECKS\n+\n+// XXX FIXME:  parallel-mode should deal correctly with moveable-only types\n+// per C++0x, at minimum smoothly fall back to serial.\n+#undef _GLIBCXX_PARALLEL\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+#include <testsuite_rvalref.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::random_access_iterator_wrapper;\n+\n+typedef __gnu_test::rvalstruct_compare_by_value V;\n+typedef test_container<V, random_access_iterator_wrapper> Container;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  V s1[] = { 10, 20, 1, 11, 2, 12, 3, 13, 4, 14, 5, 15, 6, 16, 7, \n+\t     17, 8, 18, 9, 19 };\n+  const int N = sizeof(s1) / sizeof(V);\n+  Container con(s1, s1 + N);\n+  std::make_heap(con.begin(), con.end());\n+  std::sort_heap(con.begin(), con.end());\n+  VERIFY( s1[0].ok );\n+  for(int i = 1; i < N; ++i)\n+    VERIFY( s1[i].val > s1[i - 1].val && s1[i].ok );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  V s1[] = { 10, 20, 1, 11, 2, 12, 3, 13, 4, 14, 5, 15, 6, 16, 7, \n+\t     17, 8, 18, 9, 19 };\n+  const int N = sizeof(s1) / sizeof(V);\n+  Container con(s1, s1 + N);\n+  std::make_heap(con.begin(), con.end(), __gnu_test::order);\n+  std::sort_heap(con.begin(), con.end(), __gnu_test::order);\n+  VERIFY( s1[0].ok );\n+  for(int i = 1; i < N; ++i)\n+    VERIFY( s1[i].val > s1[i - 1].val && s1[i].ok );\n+}\n+\n+void\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  V vvs[] = { 2, 0 };\n+  std::make_heap(vvs, vvs + 2);\n+  std::sort_heap(vvs, vvs + 2);\n+  VERIFY( vvs[0].ok && vvs[0].val == 0 );\n+  VERIFY( vvs[1].ok && vvs[1].val == 2 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "817468c1685566a02a82e90664bcd0d72247be1c", "filename": "libstdc++-v3/testsuite/25_algorithms/stable_sort/check_compare_by_value.cc", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c5236ed15a2461aa9f7a12a6db329a2ff03528/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fstable_sort%2Fcheck_compare_by_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c5236ed15a2461aa9f7a12a6db329a2ff03528/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fstable_sort%2Fcheck_compare_by_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fstable_sort%2Fcheck_compare_by_value.cc?ref=60c5236ed15a2461aa9f7a12a6db329a2ff03528", "patch": "@@ -0,0 +1,90 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 25.3.1.2 [lib.stable.sort]\n+\n+#undef _GLIBCXX_CONCEPT_CHECKS\n+\n+// XXX FIXME:  parallel-mode should deal correctly with moveable-only types\n+// per C++0x, at minimum smoothly fall back to serial.\n+#undef _GLIBCXX_PARALLEL\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+#include <testsuite_rvalref.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::random_access_iterator_wrapper;\n+\n+typedef __gnu_test::rvalstruct_compare_by_value V;\n+typedef test_container<V, random_access_iterator_wrapper> Container;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  V s1[] = { 10, 20, 1, 11, 2, 12, 3, 13, 4, 14, 5, 15, 6, 16, 7, \n+\t     17, 8, 18, 9, 19 };\n+  const int N = sizeof(s1) / sizeof(V);\n+  Container con(s1, s1 + N);\n+  std::stable_sort(con.begin(), con.end());\n+  VERIFY( s1[0].ok );\n+  for(int i = 1; i < N; ++i)\n+  {\n+    VERIFY( s1[i].val > s1[i - 1].val);\n+    VERIFY( s1[i].ok );\n+  }\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  V s1[] = { 10, 20, 1, 11, 2, 12, 3, 13, 4, 14, 5, 15, 6, 16, 7, \n+\t     17, 8, 18, 9, 19 };\n+  const int N = sizeof(s1) / sizeof(V);\n+  Container con(s1, s1 + N);\n+  std::stable_sort(con.begin(), con.end(), __gnu_test::order);\n+  VERIFY( s1[0].ok );\n+  for(int i = 1; i < N; ++i)\n+    VERIFY( s1[i].val > s1[i - 1].val && s1[i].ok );\n+}\n+\n+void\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  V vvs[] = { 2, 0 };\n+  std::stable_sort(vvs, vvs + 2);\n+  VERIFY( vvs[0].ok && vvs[0].val == 0 );\n+  VERIFY( vvs[1].ok && vvs[1].val == 2 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "8e37bbdb0978a8d91159e77acb988e5b0a93f832", "filename": "libstdc++-v3/testsuite/util/testsuite_rvalref.h", "status": "modified", "additions": 91, "deletions": 22, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60c5236ed15a2461aa9f7a12a6db329a2ff03528/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_rvalref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60c5236ed15a2461aa9f7a12a6db329a2ff03528/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_rvalref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_rvalref.h?ref=60c5236ed15a2461aa9f7a12a6db329a2ff03528", "patch": "@@ -24,10 +24,10 @@\n #define _GLIBCXX_TESTSUITE_RVALREF_H 1\n \n #include <testsuite_hooks.h>\n+#include <bits/functional_hash.h>\n \n namespace __gnu_test\n {\n-\n   // This class is designed to test libstdc++'s template-based rvalue\n   // reference support. It should fail at compile-time if there is an\n   // attempt to copy it.\n@@ -53,8 +53,9 @@ namespace __gnu_test\n     rvalstruct(const rvalstruct&) = delete;\n \n     rvalstruct(rvalstruct&& in)\n-    { \n-      VERIFY(in.valid == true);\n+    {\n+      bool test __attribute__((unused)) = true;\n+      VERIFY( in.valid == true );\n       val = in.val;\n       in.valid = false;\n       valid = true;\n@@ -65,8 +66,9 @@ namespace __gnu_test\n \n     rvalstruct&\n     operator=(rvalstruct&& in)\n-    { \n-      VERIFY(in.valid == true);\n+    {\n+      bool test __attribute__((unused)) = true;\n+      VERIFY( in.valid == true );\n       val = in.val;\n       in.valid = false;\n       valid = true;\n@@ -84,8 +86,9 @@ namespace __gnu_test\n \n   void\n   swap(rvalstruct& lhs, rvalstruct& rhs)\n-  {  \n-    VERIFY(lhs.valid && rhs.valid);\n+  {\n+    bool test __attribute__((unused)) = true;\n+    VERIFY( lhs.valid && rhs.valid );\n     int temp = lhs.val;\n     lhs.val = rhs.val;\n     rhs.val = temp;\n@@ -108,14 +111,16 @@ namespace __gnu_test\n     { }\n \n     copycounter(const copycounter& in) : val(in.val), valid(true)\n-    { \n-      VERIFY(in.valid == true);\n+    {\n+      bool test __attribute__((unused)) = true;\n+      VERIFY( in.valid == true );\n       ++copycount;\n     }\n \n     copycounter(copycounter&& in)\n-    { \n-      VERIFY(in.valid == true);\n+    {\n+      bool test __attribute__((unused)) = true;\n+      VERIFY( in.valid == true );\n       val = in.val;\n       in.valid = false;\n       valid = true;\n@@ -131,8 +136,9 @@ namespace __gnu_test\n \n     bool\n     operator=(const copycounter& in) \n-    { \n-      VERIFY(in.valid == true);\n+    {\n+      bool test __attribute__((unused)) = true;\n+      VERIFY( in.valid == true );\n       ++copycount;\n       val = in.val;\n       valid = true;\n@@ -141,7 +147,8 @@ namespace __gnu_test\n \n     copycounter&\n     operator=(copycounter&& in)\n-    { \n+    {\n+      bool test __attribute__((unused)) = true;\n       VERIFY(in.valid == true);\n       val = in.val;\n       in.valid = false;\n@@ -165,22 +172,85 @@ namespace __gnu_test\n \n   inline void\n   swap(copycounter& lhs, copycounter& rhs)\n-  {  \n-    VERIFY(lhs.valid && rhs.valid);\n+  {\n+    bool test __attribute__((unused)) = true;\n+    VERIFY( lhs.valid && rhs.valid );\n     int temp = lhs.val;\n     lhs.val = rhs.val;\n     rhs.val = temp;\n   }\n-  \n-} // namespace __gnu_test\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  // In the occasion of libstdc++/48038.\n+  struct rvalstruct_compare_by_value\n+  {\n+    int val;\n+    bool ok;\n \n-#include <bits/functional_hash.h>\n+    rvalstruct_compare_by_value(int v)\n+    : val(v), ok(true) { }\n+\n+    rvalstruct_compare_by_value(const rvalstruct_compare_by_value& rh)\n+    : val(rh.val), ok(rh.ok)\n+    {\n+      bool test __attribute__((unused)) = true;\n+      VERIFY(rh.ok);\n+    }\n+\n+    rvalstruct_compare_by_value&\n+    operator=(const rvalstruct_compare_by_value& rh)\n+    {\n+      bool test __attribute__((unused)) = true;\n+      VERIFY( rh.ok );\n+      val = rh.val;\n+      ok = rh.ok;\n+      return *this;\n+    }\n+\n+    rvalstruct_compare_by_value(rvalstruct_compare_by_value&& rh)\n+    : val(rh.val), ok(rh.ok)\n+    {\n+      bool test __attribute__((unused)) = true;\n+      VERIFY( rh.ok );\n+      rh.ok = false;\n+    }\n+\n+    rvalstruct_compare_by_value&\n+    operator=(rvalstruct_compare_by_value&& rh)\n+    {\n+      bool test __attribute__((unused)) = true;\n+      VERIFY( rh.ok );\n+      val = rh.val;\n+      ok = rh.ok;\n+      rh.ok = false;\n+      return *this;\n+    }\n+  };\n+\n+  inline bool\n+  operator<(rvalstruct_compare_by_value lh,\n+\t    rvalstruct_compare_by_value rh)\n+  {\n+    bool test __attribute__((unused)) = true;\n+    VERIFY( rh.ok );\n+    VERIFY( lh.ok );\n+    return lh.val < rh.val;\n+  }\n+\n+  inline bool\n+  order(rvalstruct_compare_by_value lh,\n+\trvalstruct_compare_by_value rh)\n+  {\n+    bool test __attribute__((unused)) = true;\n+    VERIFY( rh.ok );\n+    VERIFY( lh.ok );\n+    return lh.val < rh.val;\n+  }\n+\n+} // namespace __gnu_test\n \n namespace std\n {\n-  /// std::hash specialization for type_index.\n+  /// std::hash specialization for __gnu_test::rvalstruct.\n   template<>\n     struct hash<__gnu_test::rvalstruct>\n     {\n@@ -192,6 +262,5 @@ namespace std\n       { return __rvs.val; }\n     };\n }\n-#endif\n \n #endif // _GLIBCXX_TESTSUITE_TR1_H"}]}