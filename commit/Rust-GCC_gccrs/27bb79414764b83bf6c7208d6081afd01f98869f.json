{"sha": "27bb79414764b83bf6c7208d6081afd01f98869f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdiYjc5NDE0NzY0YjgzYmY2YzcyMDhkNjA4MWFmZDAxZjk4ODY5Zg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-13T09:59:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-13T09:59:17Z"}, "message": "[multiple changes]\n\n2017-01-13  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_util.adb (Add_Inherited_Tagged_DIC):\n\tPass the object parameters of both the parent and the derived\n\ttype DIC procedure to the reference replacement circuitry.\n\t(Find_DIC_Type): Modify the circuitry to present the partial\n\tview of a private type in case the private type defines its own\n\tDIC pragma.\n\t(Replace_Object_And_Primitive_References): Add two\n\toptional formal parameters.  Update the comment on usage. Update\n\tthe replacement of references to object parameters.\n\n2017-01-13  Gary Dismukes  <dismukes@adacore.com>\n\n\t* einfo.adb, sem_ch6.adb, atree.adb: Minor reformatting and typo fix.\n\n2017-01-13  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_res.adb (Resolve_Actuals): Apply Scalar_Range_Check to\n\tan out parameter that is a type conversion, independently of th\n\trange check that may apply to the expression of the conversion,\n\tfor use in GNATProve.\n\n2017-01-13  Yannick Moy  <moy@adacore.com>\n\n\t* gnat1drv.adb (Gnat1drv): Move the implicit with for System in\n\tGNATprove_Mode here to Frontend.\n\t* frontend.adb (Frontend): Move the implicit with for System\n\tin GNATprove_Mode here as it ismore correct this way; the old\n\tplace only worked by chance, since there were no overloaded names.\n\t* rtsfind.ads (RE_Id, RE_Unit_Table): Add RE_Tasking_State.\n\t* sem_attr.adb (Analyze_Attribute): In GNATprove_Mode, for the\n\tfour attributes identified in SRM 9(18), add an implicit with\n\tto Ada.Task_Identification.\n\t* sem_ch8.adb (Analyze_Subprogram_Renaming.Build_Class_Wide_Wrapper):\n\tDeal specially with the wrapper introduced for AI05-0071 in GNATprove\n\tmode.\n\t* checks.adb (Apply_Discriminant_Check,\n\tApply_Selected_Length_Checks, Apply_Selected_Range_Checks):\n\tIn GNATprove mode, we do not apply the checks, but we still\n\tanalyze the expression to possibly issue errors on SPARK\n\tcode when a run-time error can be detected at compile time.\n\t(Selected_Length_Checks, Selected_Range_Checks): Perform analysis\n\tin GNATprove mode.\n\nFrom-SVN: r244398", "tree": {"sha": "7d4352ec7e46dfe25c1751dc25b35754a8af9335", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d4352ec7e46dfe25c1751dc25b35754a8af9335"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27bb79414764b83bf6c7208d6081afd01f98869f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27bb79414764b83bf6c7208d6081afd01f98869f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27bb79414764b83bf6c7208d6081afd01f98869f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27bb79414764b83bf6c7208d6081afd01f98869f/comments", "author": null, "committer": null, "parents": [{"sha": "9574e75fb0e65d9948437fee16ba9942bc6bce06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9574e75fb0e65d9948437fee16ba9942bc6bce06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9574e75fb0e65d9948437fee16ba9942bc6bce06"}], "stats": {"total": 386, "additions": 293, "deletions": 93}, "files": [{"sha": "f9d3a5030357a55ff1e9ba44b3919b94ea9c1148", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=27bb79414764b83bf6c7208d6081afd01f98869f", "patch": "@@ -1,3 +1,48 @@\n+2017-01-13  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_util.adb (Add_Inherited_Tagged_DIC):\n+\tPass the object parameters of both the parent and the derived\n+\ttype DIC procedure to the reference replacement circuitry.\n+\t(Find_DIC_Type): Modify the circuitry to present the partial\n+\tview of a private type in case the private type defines its own\n+\tDIC pragma.\n+\t(Replace_Object_And_Primitive_References): Add two\n+\toptional formal parameters.  Update the comment on usage. Update\n+\tthe replacement of references to object parameters.\n+\n+2017-01-13  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* einfo.adb, sem_ch6.adb, atree.adb: Minor reformatting and typo fix.\n+\n+2017-01-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Actuals): Apply Scalar_Range_Check to\n+\tan out parameter that is a type conversion, independently of th\n+\trange check that may apply to the expression of the conversion,\n+\tfor use in GNATProve.\n+\n+2017-01-13  Yannick Moy  <moy@adacore.com>\n+\n+\t* gnat1drv.adb (Gnat1drv): Move the implicit with for System in\n+\tGNATprove_Mode here to Frontend.\n+\t* frontend.adb (Frontend): Move the implicit with for System\n+\tin GNATprove_Mode here as it ismore correct this way; the old\n+\tplace only worked by chance, since there were no overloaded names.\n+\t* rtsfind.ads (RE_Id, RE_Unit_Table): Add RE_Tasking_State.\n+\t* sem_attr.adb (Analyze_Attribute): In GNATprove_Mode, for the\n+\tfour attributes identified in SRM 9(18), add an implicit with\n+\tto Ada.Task_Identification.\n+\t* sem_ch8.adb (Analyze_Subprogram_Renaming.Build_Class_Wide_Wrapper):\n+\tDeal specially with the wrapper introduced for AI05-0071 in GNATprove\n+\tmode.\n+\t* checks.adb (Apply_Discriminant_Check,\n+\tApply_Selected_Length_Checks, Apply_Selected_Range_Checks):\n+\tIn GNATprove mode, we do not apply the checks, but we still\n+\tanalyze the expression to possibly issue errors on SPARK\n+\tcode when a run-time error can be detected at compile time.\n+\t(Selected_Length_Checks, Selected_Range_Checks): Perform analysis\n+\tin GNATprove mode.\n+\n 2017-01-13  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* expander.adb (Expand): Add a warning about using return"}, {"sha": "2e56371600b70db17b8331450147be174181ec16", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=27bb79414764b83bf6c7208d6081afd01f98869f", "patch": "@@ -556,7 +556,7 @@ package body Atree is\n    --  information for the newly-allocated node is copied from it.\n \n    procedure Fix_Parents (Ref_Node, Fix_Node : Node_Id);\n-   --  Fixup parent pointers for the syntactic children of Fix_Node after a\n+   --  Fix up parent pointers for the syntactic children of Fix_Node after a\n    --  copy, setting them to Fix_Node when they pointed to Ref_Node.\n \n    procedure Mark_New_Ghost_Node (N : Node_Or_Entity_Id);\n@@ -1430,7 +1430,7 @@ package body Atree is\n \n    procedure Fix_Parents (Ref_Node, Fix_Node : Node_Id) is\n       procedure Fix_Parent (Field : Union_Id);\n-      --  Fixup one parent pointer. Field is checked to see if it points to\n+      --  Fix up one parent pointer. Field is checked to see if it points to\n       --  a node, list, or element list that has a parent that points to\n       --  Ref_Node. If so, the parent is reset to point to Fix_Node.\n "}, {"sha": "6689cb56f074979296c35b7961a60a0b9b95e0b0", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 53, "deletions": 13, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=27bb79414764b83bf6c7208d6081afd01f98869f", "patch": "@@ -1447,13 +1447,17 @@ package body Checks is\n          T_Typ := Typ;\n       end if;\n \n-      --  Nothing to do if discriminant checks are suppressed or else no code\n-      --  is to be generated\n-\n-      if not Expander_Active\n-        or else Discriminant_Checks_Suppressed (T_Typ)\n-      then\n-         return;\n+      --  Only apply checks when generating code and discriminant checks are\n+      --  not suppressed. In GNATprove mode, we do not apply the checks, but we\n+      --  still analyze the expression to possibly issue errors on SPARK code\n+      --  when a run-time error can be detected at compile time.\n+\n+      if not GNATprove_Mode then\n+         if not Expander_Active\n+           or else Discriminant_Checks_Suppressed (T_Typ)\n+         then\n+            return;\n+         end if;\n       end if;\n \n       --  No discriminant checks necessary for an access when expression is\n@@ -1690,6 +1694,12 @@ package body Checks is\n          end;\n       end if;\n \n+      --  In GNATprove mode, we do not apply the checks\n+\n+      if GNATprove_Mode then\n+         return;\n+      end if;\n+\n       --  Here we need a discriminant check. First build the expression\n       --  for the comparisons of the discriminants:\n \n@@ -3075,16 +3085,25 @@ package body Checks is\n           or else (not Length_Checks_Suppressed (Target_Typ));\n \n    begin\n+      --  Only apply checks when generating code. In GNATprove mode, we do\n+      --  not apply the checks, but we still call Selected_Length_Checks to\n+      --  possibly issue errors on SPARK code when a run-time error can be\n+      --  detected at compile time.\n+\n       --  Note: this means that we lose some useful warnings if the expander\n-      --  is not active, and we also lose these warnings in SPARK mode ???\n+      --  is not active.\n \n-      if not Expander_Active then\n+      if not Expander_Active and not GNATprove_Mode then\n          return;\n       end if;\n \n       R_Result :=\n         Selected_Length_Checks (Ck_Node, Target_Typ, Source_Typ, Empty);\n \n+      if GNATprove_Mode then\n+         return;\n+      end if;\n+\n       for J in 1 .. 2 loop\n          R_Cno := R_Result (J);\n          exit when No (R_Cno);\n@@ -3186,13 +3205,24 @@ package body Checks is\n       R_Result : Check_Result;\n \n    begin\n-      if not Expander_Active or not Checks_On then\n-         return;\n+      --  Only apply checks when generating code. In GNATprove mode, we do not\n+      --  apply the checks, but we still call Selected_Range_Checks to possibly\n+      --  issue errors on SPARK code when a run-time error can be detected at\n+      --  compile time.\n+\n+      if not GNATprove_Mode then\n+         if not Expander_Active or not Checks_On then\n+            return;\n+         end if;\n       end if;\n \n       R_Result :=\n         Selected_Range_Checks (Ck_Node, Target_Typ, Source_Typ, Empty);\n \n+      if GNATprove_Mode then\n+         return;\n+      end if;\n+\n       for J in 1 .. 2 loop\n          R_Cno := R_Result (J);\n          exit when No (R_Cno);\n@@ -9052,7 +9082,12 @@ package body Checks is\n    --  Start of processing for Selected_Length_Checks\n \n    begin\n-      if not Expander_Active then\n+      --  Checks will be applied only when generating code. In GNATprove mode,\n+      --  we do not apply the checks, but we still call Selected_Length_Checks\n+      --  to possibly issue errors on SPARK code when a run-time error can be\n+      --  detected at compile time.\n+\n+      if not Expander_Active and not GNATprove_Mode then\n          return Ret_Result;\n       end if;\n \n@@ -9602,7 +9637,12 @@ package body Checks is\n    --  Start of processing for Selected_Range_Checks\n \n    begin\n-      if not Expander_Active then\n+      --  Checks will be applied only when generating code. In GNATprove mode,\n+      --  we do not apply the checks, but we still call Selected_Range_Checks\n+      --  to possibly issue errors on SPARK code when a run-time error can be\n+      --  detected at compile time.\n+\n+      if not Expander_Active and not GNATprove_Mode then\n          return Ret_Result;\n       end if;\n "}, {"sha": "f007c2a4e3d08733db7272b9850fae34f57e567c", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=27bb79414764b83bf6c7208d6081afd01f98869f", "patch": "@@ -2093,7 +2093,7 @@ package body Einfo is\n \n    function Is_Checked_Ghost_Entity (Id : E) return B is\n    begin\n-      --  Allow this attribute to appear on non-analyzed entities\n+      --  Allow this attribute to appear on unanalyzed entities\n \n       pragma Assert (Nkind (Id) in N_Entity\n         or else Ekind (Id) = E_Void);\n@@ -2283,7 +2283,7 @@ package body Einfo is\n \n    function Is_Ignored_Ghost_Entity (Id : E) return B is\n    begin\n-      --  Allow this attribute to appear on non-analyzed entities\n+      --  Allow this attribute to appear on unanalyzed entities\n \n       pragma Assert (Nkind (Id) in N_Entity\n         or else Ekind (Id) = E_Void);\n@@ -5167,7 +5167,7 @@ package body Einfo is\n \n    procedure Set_Is_Checked_Ghost_Entity (Id : E; V : B := True) is\n    begin\n-      --  Allow this attribute to appear on non-analyzed entities\n+      --  Allow this attribute to appear on unanalyzed entities\n \n       pragma Assert (Nkind (Id) in N_Entity\n         or else Ekind (Id) = E_Void);\n@@ -5372,7 +5372,7 @@ package body Einfo is\n \n    procedure Set_Is_Ignored_Ghost_Entity (Id : E; V : B := True) is\n    begin\n-      --  Allow this attribute to appear on non-analyzed entities\n+      --  Allow this attribute to appear on unanalyzed entities\n \n       pragma Assert (Nkind (Id) in N_Entity\n         or else Ekind (Id) = E_Void);"}, {"sha": "ea71e38fe0b43f8acb584dce1b32710f5adbece5", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 45, "deletions": 37, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=27bb79414764b83bf6c7208d6081afd01f98869f", "patch": "@@ -1237,14 +1237,17 @@ package body Exp_Util is\n       procedure Replace_Object_And_Primitive_References\n         (Expr      : Node_Id;\n          Par_Typ   : Entity_Id;\n-         Deriv_Typ : Entity_Id);\n+         Deriv_Typ : Entity_Id;\n+         Par_Obj   : Entity_Id := Empty;\n+         Deriv_Obj : Entity_Id := Empty);\n       --  Expr denotes an arbitrary expression. Par_Typ is a parent type in a\n-      --  type hierarchy. Deriv_Typ is a type derived from Par_Typ. Perform the\n-      --  following substitutions:\n+      --  type hierarchy. Deriv_Typ is a type derived from Par_Typ. Par_Obj is\n+      --  the formal parameter which emulates the current instance of Par_Typ.\n+      --  Deriv_Obj is the formal parameter which emulates the current instance\n+      --  of Deriv_Typ. Perform the following substitutions:\n       --\n-      --    * Replace a reference to the _object parameter of the parent type's\n-      --      DIC procedure with a reference to the _object parameter of the\n-      --      derived type's DIC procedure.\n+      --    * Replace a reference to Par_Obj with a reference to Deriv_Obj if\n+      --      applicable.\n       --\n       --    * Replace a call to an overridden parent primitive with a call to\n       --      the overriding derived type primitive.\n@@ -1340,11 +1343,13 @@ package body Exp_Util is\n          Deriv_Typ : Entity_Id;\n          Stmts     : in out List_Id)\n       is\n-         DIC_Args : constant List_Id :=\n-                      Pragma_Argument_Associations (DIC_Prag);\n-         DIC_Arg  : constant Node_Id := First (DIC_Args);\n-         DIC_Expr : constant Node_Id := Expression_Copy (DIC_Arg);\n-         Typ_Decl : constant Node_Id := Declaration_Node (Deriv_Typ);\n+         Deriv_Decl : constant Node_Id   := Declaration_Node (Deriv_Typ);\n+         Deriv_Proc : constant Entity_Id := DIC_Procedure (Deriv_Typ);\n+         DIC_Args   : constant List_Id   :=\n+                        Pragma_Argument_Associations (DIC_Prag);\n+         DIC_Arg    : constant Node_Id   := First (DIC_Args);\n+         DIC_Expr   : constant Node_Id   := Expression_Copy (DIC_Arg);\n+         Par_Proc   : constant Entity_Id := DIC_Procedure (Par_Typ);\n \n          Expr : Node_Id;\n \n@@ -1373,15 +1378,19 @@ package body Exp_Util is\n          --  handled by the overriding/inheritance mechanism and do not require\n          --  an extra replacement pass.\n \n+         pragma Assert (Present (Deriv_Proc) and then Present (Par_Proc));\n+\n          Replace_Object_And_Primitive_References\n            (Expr      => Expr,\n             Par_Typ   => Par_Typ,\n-            Deriv_Typ => Deriv_Typ);\n+            Deriv_Typ => Deriv_Typ,\n+            Par_Obj   => First_Formal (Par_Proc),\n+            Deriv_Obj => First_Formal (Deriv_Proc));\n \n          --  Preanalyze the DIC expression to detect errors and at the same\n          --  time capture the visibility of the proper package part.\n \n-         Set_Parent (Expr, Typ_Decl);\n+         Set_Parent (Expr, Deriv_Decl);\n          Preanalyze_Assert_Expression (Expr, Any_Boolean);\n \n          --  Once the DIC assertion expression is fully processed, add a check\n@@ -1514,14 +1523,10 @@ package body Exp_Util is\n       procedure Replace_Object_And_Primitive_References\n         (Expr      : Node_Id;\n          Par_Typ   : Entity_Id;\n-         Deriv_Typ : Entity_Id)\n+         Deriv_Typ : Entity_Id;\n+         Par_Obj   : Entity_Id := Empty;\n+         Deriv_Obj : Entity_Id := Empty)\n       is\n-         Deriv_Obj : Entity_Id;\n-         --  The _object parameter of the derived type's DIC procedure\n-\n-         Par_Obj : Entity_Id;\n-         --  The _object parameter of the parent type's DIC procedure\n-\n          function Replace_Ref (Ref : Node_Id) return Traverse_Result;\n          --  Substitute a reference to an entity with a reference to the\n          --  corresponding entity stored in in table Primitives_Mapping.\n@@ -1556,7 +1561,10 @@ package body Exp_Util is\n                --  The reference mentions the _object parameter of the parent\n                --  type's DIC procedure.\n \n-               elsif Ref_Id = Par_Obj then\n+               elsif Present (Par_Obj)\n+                 and then Present (Deriv_Obj)\n+                 and then Ref_Id = Par_Obj\n+               then\n                   New_Ref := New_Occurrence_Of (Deriv_Obj, Loc);\n \n                   --  The reference to _object acts as an actual parameter in a\n@@ -1624,19 +1632,9 @@ package body Exp_Util is\n \n          procedure Replace_Refs is new Traverse_Proc (Replace_Ref);\n \n-         --  Local variables\n-\n-         Deriv_Proc : constant Entity_Id := DIC_Procedure (Deriv_Typ);\n-         Par_Proc   : constant Entity_Id := DIC_Procedure (Par_Typ);\n-\n       --  Start of processing for Replace_Object_And_Primitive_References\n \n       begin\n-         pragma Assert (Present (Deriv_Proc) and then Present (Par_Proc));\n-\n-         Deriv_Obj := First_Entity (Deriv_Proc);\n-         Par_Obj   := First_Entity (Par_Proc);\n-\n          --  Map each primitive operation of the parent type to the proper\n          --  primitive of the derived type.\n \n@@ -3908,7 +3906,15 @@ package body Exp_Util is\n \n    function Find_DIC_Type (Typ : Entity_Id) return Entity_Id is\n       Curr_Typ : Entity_Id;\n-      DIC_Typ  : Entity_Id;\n+      --  The current type being examined in the parent hierarchy traversal\n+\n+      DIC_Typ : Entity_Id;\n+      --  The type which carries the DIC pragma. This variable denotes the\n+      --  partial view when private types are involved.\n+\n+      Par_Typ : Entity_Id;\n+      --  The parent type of the current type. This variable denotes the full\n+      --  view when private types are involved.\n \n    begin\n       --  The input type defines its own DIC pragma, therefore it is the owner\n@@ -3933,19 +3939,21 @@ package body Exp_Util is\n             --  Look at the full view of a private type because the type may\n             --  have a hidden parent introduced in the full view.\n \n-            if Is_Private_Type (DIC_Typ)\n-              and then Present (Full_View (DIC_Typ))\n+            Par_Typ := DIC_Typ;\n+\n+            if Is_Private_Type (Par_Typ)\n+              and then Present (Full_View (Par_Typ))\n             then\n-               DIC_Typ := Full_View (DIC_Typ);\n+               Par_Typ := Full_View (Par_Typ);\n             end if;\n \n             --  Stop the climb once the nearest parent type which defines a DIC\n             --  pragma of its own is encountered or when the root of the parent\n             --  chain is reached.\n \n-            exit when Has_Own_DIC (DIC_Typ) or else Curr_Typ = DIC_Typ;\n+            exit when Has_Own_DIC (DIC_Typ) or else Curr_Typ = Par_Typ;\n \n-            Curr_Typ := DIC_Typ;\n+            Curr_Typ := Par_Typ;\n          end loop;\n       end if;\n "}, {"sha": "c71c78e40c46c9b952aa9dbea90afb489bd983ee", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=27bb79414764b83bf6c7208d6081afd01f98869f", "patch": "@@ -460,6 +460,19 @@ begin\n       end if;\n    end if;\n \n+   --  In GNATprove mode, force loading of a few RTE units.\n+\n+   if GNATprove_Mode then\n+      declare\n+         Unused_E : Entity_Id;\n+      begin\n+         --  Ensure that System.Interrupt_Priority is available to\n+         --  GNATprove for the generation of VCs related to ceiling\n+         --  priority.\n+         Unused_E := RTE (RE_Interrupt_Priority);\n+      end;\n+   end if;\n+\n    --  Qualify all entity names in inner packages, package bodies, etc.\n \n    Exp_Dbug.Qualify_All_Entity_Names;"}, {"sha": "a2e6e897b7492f4c7e770c6032f115e1a75a2749", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=27bb79414764b83bf6c7208d6081afd01f98869f", "patch": "@@ -1071,19 +1071,6 @@ begin\n       Original_Operating_Mode := Operating_Mode;\n       Frontend;\n \n-      --  In GNATprove mode, force loading of System unit to ensure that\n-      --  System.Interrupt_Priority is available to GNATprove for the\n-      --  generation of VCs related to ceiling priority.\n-\n-      if GNATprove_Mode then\n-         declare\n-            Unused_E : constant Entity_Id :=\n-                         Rtsfind.RTE (Rtsfind.RE_Interrupt_Priority);\n-         begin\n-            null;\n-         end;\n-      end if;\n-\n       --  Exit with errors if the main source could not be parsed\n \n       if Sinput.Main_Source_File = No_Source_File then"}, {"sha": "f3dfd3191a00a13953f2696a7afdc9db561d8e54", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=27bb79414764b83bf6c7208d6081afd01f98869f", "patch": "@@ -704,6 +704,7 @@ package Rtsfind is\n      RE_Abort_Task,                      -- Ada.Task_Identification\n      RE_Current_Task,                    -- Ada.Task_Identification\n      RO_AT_Task_Id,                      -- Ada.Task_Identification\n+     RE_Tasking_State,                   -- Ada.Task_Identification\n \n      RE_Decimal_IO,                      -- Ada.Text_IO\n      RE_Fixed_IO,                        -- Ada.Text_IO\n@@ -1936,6 +1937,7 @@ package Rtsfind is\n      RE_Abort_Task                       => Ada_Task_Identification,\n      RE_Current_Task                     => Ada_Task_Identification,\n      RO_AT_Task_Id                       => Ada_Task_Identification,\n+     RE_Tasking_State                    => Ada_Task_Identification,\n \n      RE_Decimal_IO                       => Ada_Text_IO,\n      RE_Fixed_IO                         => Ada_Text_IO,"}, {"sha": "9adbe7a2e5550ac15be5d89897bf922627797fbc", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=27bb79414764b83bf6c7208d6081afd01f98869f", "patch": "@@ -7109,6 +7109,27 @@ package body Sem_Attr is\n \n       end case;\n \n+      --  In SPARK some attribute references depend on Tasking_State, so we\n+      --  need to make sure we load this so that gnat2why has the entity\n+      --  available. See SPARK RM 9(18) for the relevant rule.\n+\n+      if GNATprove_Mode then\n+         declare\n+            Unused : Entity_Id;\n+         begin\n+            case Attr_Id is\n+               when Attribute_Callable   |\n+                    Attribute_Caller     |\n+                    Attribute_Count      |\n+                    Attribute_Terminated =>\n+                  Unused := RTE (RE_Tasking_State);\n+\n+               when others =>\n+                  null;\n+            end case;\n+         end;\n+      end if;\n+\n    --  All errors raise Bad_Attribute, so that we get out before any further\n    --  damage occurs when an error is detected (for example, if we check for\n    --  one attribute expression, and the check succeeds, we want to be able"}, {"sha": "d092134d73d23d992e93e006badbff2337417e1c", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=27bb79414764b83bf6c7208d6081afd01f98869f", "patch": "@@ -8408,7 +8408,7 @@ package body Sem_Ch6 is\n    --  Start of processing for Fully_Conformant_Expressions\n \n    begin\n-      --  Non-conformant if paren count does not match. Note: if some idiot\n+      --  Nonconformant if paren count does not match. Note: if some idiot\n       --  complains that we don't do this right for more than 3 levels of\n       --  parentheses, they will be treated with the respect they deserve.\n \n@@ -8423,14 +8423,14 @@ package body Sem_Ch6 is\n             return Entity (E1) = Entity (E2)\n \n               --  One may be a discriminant that has been replaced by\n-              --  the correspondding discriminal\n+              --  the corresponding discriminal.\n \n               or else (Chars (Entity (E1)) = Chars (Entity (E2))\n                         and then Ekind (Entity (E1)) = E_Discriminant\n                         and then Ekind (Entity (E2)) = E_In_Parameter)\n \n-             --  AI12-050 : the loop variables of quantified expressions\n-             --  match if the have the same identifier, even though they\n+             --  AI12-050 : The loop variables of quantified expressions\n+             --  match if they have the same identifier, even though they\n              --  are different entities.\n \n               or else (Chars (Entity (E1)) = Chars (Entity (E2))"}, {"sha": "1ba4962839674d51ee934ec69872e9a1e1ac787e", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 89, "deletions": 17, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=27bb79414764b83bf6c7208d6081afd01f98869f", "patch": "@@ -1934,6 +1934,14 @@ package body Sem_Ch8 is\n       is\n          Loc : constant Source_Ptr := Sloc (N);\n \n+         function Build_Expr_Fun_Call\n+           (Subp_Id : Entity_Id;\n+            Params  : List_Id) return Node_Id;\n+         --  Create a dispatching call to invoke function Subp_Id with actuals\n+         --  built from the parameter specifications of list Params. Return\n+         --  directly the call, so that it can be used inside an expression\n+         --  function. This is a specificity of the GNATprove mode.\n+\n          function Build_Call\n            (Subp_Id : Entity_Id;\n             Params  : List_Id) return Node_Id;\n@@ -2004,6 +2012,38 @@ package body Sem_Ch8 is\n             end if;\n          end Build_Call;\n \n+         -------------------------\n+         -- Build_Expr_Fun_Call --\n+         -------------------------\n+\n+         function Build_Expr_Fun_Call\n+           (Subp_Id : Entity_Id;\n+            Params  : List_Id) return Node_Id\n+         is\n+            Actuals  : constant List_Id := New_List;\n+            Call_Ref : constant Node_Id := New_Occurrence_Of (Subp_Id, Loc);\n+            Formal   : Node_Id;\n+\n+         begin\n+            --  Build the actual parameters of the call\n+\n+            Formal := First (Params);\n+            while Present (Formal) loop\n+               Append_To (Actuals,\n+                 Make_Identifier (Loc, Chars (Defining_Identifier (Formal))));\n+               Next (Formal);\n+            end loop;\n+\n+            --  Generate:\n+            --    Subp_Id (Actuals);\n+\n+            pragma Assert (Ekind_In (Subp_Id, E_Function, E_Operator));\n+\n+            return Make_Function_Call (Loc,\n+              Name                   => Call_Ref,\n+              Parameter_Associations => Actuals);\n+         end Build_Expr_Fun_Call;\n+\n          ----------------\n          -- Build_Spec --\n          ----------------\n@@ -2199,6 +2239,7 @@ package body Sem_Ch8 is\n          Formal    : Node_Id;\n          Prim_Op   : Entity_Id;\n          Spec_Decl : Node_Id;\n+         New_Spec  : Node_Id;\n \n       --  Start of processing for Build_Class_Wide_Wrapper\n \n@@ -2334,31 +2375,62 @@ package body Sem_Ch8 is\n          --  Step 3: Create the declaration and the body of the wrapper, insert\n          --  all the pieces into the tree.\n \n-         Spec_Decl :=\n-           Make_Subprogram_Declaration (Loc,\n-             Specification => Build_Spec (Ren_Id));\n-         Insert_Before_And_Analyze (N, Spec_Decl);\n+         --  In GNATprove mode, create a function wrapper in the form of an\n+         --  expression function, so that an implicit postcondition relating\n+         --  the result of calling the wrapper function and the result of the\n+         --  dispatching call to the wrapped function is known during proof.\n+\n+         if GNATprove_Mode\n+           and then Ekind_In (Ren_Id, E_Function, E_Operator)\n+         then\n+            New_Spec := Build_Spec (Ren_Id);\n+            Body_Decl :=\n+              Make_Expression_Function (Loc,\n+                Specification => New_Spec,\n+                Expression    => Build_Expr_Fun_Call\n+                  (Subp_Id => Prim_Op,\n+                   Params  => Parameter_Specifications (New_Spec)));\n+\n+            Wrap_Id := Defining_Entity (Body_Decl);\n+\n+         --  Otherwise, create separate spec and body for the subprogram\n+\n+         else\n+            Spec_Decl :=\n+              Make_Subprogram_Declaration (Loc,\n+                Specification => Build_Spec (Ren_Id));\n+            Insert_Before_And_Analyze (N, Spec_Decl);\n+\n+            Wrap_Id := Defining_Entity (Spec_Decl);\n+\n+            Body_Decl :=\n+              Make_Subprogram_Body (Loc,\n+                Specification              => Build_Spec (Ren_Id),\n+                Declarations               => New_List,\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements => New_List (\n+                      Build_Call\n+                        (Subp_Id => Prim_Op,\n+                         Params  =>\n+                           Parameter_Specifications\n+                             (Specification (Spec_Decl))))));\n+\n+            Set_Corresponding_Body (Spec_Decl, Defining_Entity (Body_Decl));\n+         end if;\n \n          --  If the operator carries an Eliminated pragma, indicate that the\n          --  wrapper is also to be eliminated, to prevent spurious error when\n          --  using gnatelim on programs that include box-initialization of\n          --  equality operators.\n \n-         Wrap_Id := Defining_Entity (Spec_Decl);\n          Set_Is_Eliminated (Wrap_Id, Is_Eliminated (Prim_Op));\n \n-         Body_Decl :=\n-           Make_Subprogram_Body (Loc,\n-             Specification              => Build_Spec (Ren_Id),\n-             Declarations               => New_List,\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => New_List (\n-                   Build_Call\n-                     (Subp_Id => Prim_Op,\n-                      Params  =>\n-                        Parameter_Specifications\n-                          (Specification (Spec_Decl))))));\n+         --  In GNATprove mode, insert the body in the tree for analysis\n+\n+         if GNATprove_Mode then\n+            Insert_Before_And_Analyze (N, Body_Decl);\n+         end if;\n \n          --  The generated body does not freeze and must be analyzed when the\n          --  class-wide wrapper is frozen. The body is only needed if expansion"}, {"sha": "235a535c7f95e6d4c68c7352eb2c9c6b1ded9787", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27bb79414764b83bf6c7208d6081afd01f98869f/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=27bb79414764b83bf6c7208d6081afd01f98869f", "patch": "@@ -4328,24 +4328,36 @@ package body Sem_Res is\n \n             if Ekind_In (F, E_Out_Parameter, E_In_Out_Parameter) then\n \n-               --  If there is a type conversion, to make sure the return value\n+               --  If there is a type conversion, make sure the return value\n                --  meets the constraints of the variable before the conversion.\n \n                if Nkind (A) = N_Type_Conversion then\n                   if Is_Scalar_Type (A_Typ) then\n                      Apply_Scalar_Range_Check\n                        (Expression (A), Etype (Expression (A)), A_Typ);\n+\n+                     --  In addition, the returned value of the parameter\n+                     --  must satisfy the bounds of the object type (see\n+                     --  comment below).\n+\n+                     Apply_Scalar_Range_Check (A, A_Typ, F_Typ);\n+\n                   else\n                      Apply_Range_Check\n                        (Expression (A), Etype (Expression (A)), A_Typ);\n                   end if;\n \n-               --  If no conversion apply scalar range checks and length checks\n-               --  base on the subtype of the actual (NOT that of the formal).\n+               --  If no conversion, apply scalar range checks and length check\n+               --  based on the subtype of the actual (NOT that of the formal).\n+               --  This indicates that the check takes place on return from the\n+               --  call. During expansion the required constraint checks are\n+               --  inserted. In GNATprove mode, in the absence of expansion,\n+               --  the flag indicates that the returned value is valid.\n \n                else\n                   if Is_Scalar_Type (F_Typ) then\n                      Apply_Scalar_Range_Check (A, A_Typ, F_Typ);\n+\n                   elsif Is_Array_Type (F_Typ)\n                     and then Ekind (F) = E_Out_Parameter\n                   then"}]}