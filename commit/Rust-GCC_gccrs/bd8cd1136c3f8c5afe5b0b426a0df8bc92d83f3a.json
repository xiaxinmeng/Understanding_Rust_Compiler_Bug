{"sha": "bd8cd1136c3f8c5afe5b0b426a0df8bc92d83f3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ4Y2QxMTM2YzNmOGM1YWZlNWIwYjQyNmEwZGY4YmM5MmQ4M2YzYQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2017-10-09T18:44:41Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2017-10-09T18:44:41Z"}, "message": "<forgot to do svn add on the amo.h file>\n\n[gcc]\n2017-10-09  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/amo.h: New include file to provide ISA 3.0 atomic\n\tmemory operation instruction support.\n\t* config.gcc (powerpc*-*-*): Include amo.h as an extra header.\n\t(rs6000-ibm-aix[789]*): Likewise.\n\t* doc/extend.texi (PowerPC Atomic Memory Operation Functions):\n\tDocument new functions.\n\n[gcc/testsuite]\n2017-10-09  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/amo1.c: New test.\n\t* gcc.target/powerpc/amo2.c: Likewise.\n\nFrom-SVN: r253556", "tree": {"sha": "beac032e6cd2a2f57ed01b656a6b981f652c423e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/beac032e6cd2a2f57ed01b656a6b981f652c423e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd8cd1136c3f8c5afe5b0b426a0df8bc92d83f3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd8cd1136c3f8c5afe5b0b426a0df8bc92d83f3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd8cd1136c3f8c5afe5b0b426a0df8bc92d83f3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd8cd1136c3f8c5afe5b0b426a0df8bc92d83f3a/comments", "author": null, "committer": null, "parents": [{"sha": "3395b656c912467a5aa5284998f7a991f7fa8aee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3395b656c912467a5aa5284998f7a991f7fa8aee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3395b656c912467a5aa5284998f7a991f7fa8aee"}], "stats": {"total": 152, "additions": 152, "deletions": 0}, "files": [{"sha": "d77bf649fcb8ea97a26d7ea388c936c79c2c5301", "filename": "gcc/config/rs6000/amo.h", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8cd1136c3f8c5afe5b0b426a0df8bc92d83f3a/gcc%2Fconfig%2Frs6000%2Famo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8cd1136c3f8c5afe5b0b426a0df8bc92d83f3a/gcc%2Fconfig%2Frs6000%2Famo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Famo.h?ref=bd8cd1136c3f8c5afe5b0b426a0df8bc92d83f3a", "patch": "@@ -0,0 +1,152 @@\n+ /* Power ISA 3.0 atomic memory operation include file.\n+    Copyright (C) 2017 Free Software Foundation, Inc.\n+    Contributed by Michael Meissner <meissner@linux.vnet.ibm.com>.\n+\n+    This file is part of GCC.\n+\n+    GCC is free software; you can redistribute it and/or modify it\n+    under the terms of the GNU General Public License as published\n+    by the Free Software Foundation; either version 3, or (at your\n+    option) any later version.\n+\n+    GCC is distributed in the hope that it will be useful, but WITHOUT\n+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+    License for more details.\n+\n+    Under Section 7 of GPL version 3, you are granted additional\n+    permissions described in the GCC Runtime Library Exception, version\n+    3.1, as published by the Free Software Foundation.\n+\n+    You should have received a copy of the GNU General Public License and\n+    a copy of the GCC Runtime Library Exception along with this program;\n+    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+    <http://www.gnu.org/licenses/>.  */\n+\n+ #ifndef _AMO_H\n+ #define _AMO_H\n+\n+ #if !defined(_ARCH_PWR9) || !defined(_ARCH_PPC64)\n+ #error \"The atomic memory operations require Power 64-bit ISA 3.0\"\n+\n+ #else\n+ #include <stdint.h>\n+\n+ /* Enumeration of the LWAT/LDAT sub-opcodes.  */\n+ enum _AMO_LD {\n+   _AMO_LD_ADD\t\t= 0x00,\t\t/* Fetch and Add.  */\n+   _AMO_LD_XOR\t\t= 0x01,\t\t/* Fetch and Xor.  */\n+   _AMO_LD_IOR\t\t= 0x02,\t\t/* Fetch and Ior.  */\n+   _AMO_LD_AND\t\t= 0x03,\t\t/* Fetch and And.  */\n+   _AMO_LD_UMAX\t\t= 0x04,\t\t/* Fetch and Unsigned Maximum.  */\n+   _AMO_LD_SMAX\t\t= 0x05,\t\t/* Fetch and Signed Maximum.  */\n+   _AMO_LD_UMIN\t\t= 0x06,\t\t/* Fetch and Unsigned Minimum.  */\n+   _AMO_LD_SMIN\t\t= 0x07,\t\t/* Fetch and Signed Minimum.  */\n+   _AMO_LD_SWAP\t\t= 0x08,\t\t/* Swap.  */\n+   _AMO_LD_CS_NE\t\t= 0x10,\t\t/* Compare and Swap Not Equal.  */\n+   _AMO_LD_INC_BOUNDED\t= 0x18,\t\t/* Fetch and Increment Bounded.  */\n+   _AMO_LD_INC_EQUAL\t= 0x19,\t\t/* Fetch and Increment Equal.  */\n+   _AMO_LD_DEC_BOUNDED\t= 0x1A\t\t/* Fetch and Decrement Bounded.  */\n+ };\n+\n+ /* Implementation of the simple LWAT/LDAT operations that take one register and\n+    modify one word or double-word of memory and return the value that was\n+    previously in the memory location.\n+\n+    The LWAT/LDAT opcode requires the address to be a single register, and that\n+    points to a suitably aligned memory location.  Asm volatile is used to\n+    prevent the optimizer from moving the operation.  */\n+\n+ #define _AMO_LD_SIMPLE(NAME, TYPE, OPCODE, FC)\t\t\t\t\\\n+ static __inline__ TYPE\t\t\t\t\t\t\t\\\n+ NAME (TYPE *_PTR, TYPE _VALUE)\t\t\t\t\t\t\\\n+ {\t\t\t\t\t\t\t\t\t\\\n+   unsigned __int128 _TMP;\t\t\t\t\t\t\\\n+   TYPE _RET;\t\t\t\t\t\t\t\t\\\n+   __asm__ volatile (\"mr %L1,%3\\n\"\t\t\t\t\t\\\n+ \t\t    \"\\t\" OPCODE \" %1,%P0,%4\\n\"\t\t\t\t\\\n+ \t\t    \"\\tmr %2,%1\\n\"\t\t\t\t\t\\\n+ \t\t    : \"+Q\" (_PTR[0]), \"=&r\" (_TMP), \"=r\" (_RET)\t\t\\\n+ \t\t    : \"r\" (_VALUE), \"n\" (FC));\t\t\t\t\\\n+   return _RET;\t\t\t\t\t\t\t\t\\\n+ }\n+\n+ _AMO_LD_SIMPLE (amo_lwat_add,   uint32_t, \"lwat\", _AMO_LD_ADD)\n+ _AMO_LD_SIMPLE (amo_lwat_xor,   uint32_t, \"lwat\", _AMO_LD_XOR)\n+ _AMO_LD_SIMPLE (amo_lwat_ior,   uint32_t, \"lwat\", _AMO_LD_IOR)\n+ _AMO_LD_SIMPLE (amo_lwat_and,   uint32_t, \"lwat\", _AMO_LD_AND)\n+ _AMO_LD_SIMPLE (amo_lwat_umax,  uint32_t, \"lwat\", _AMO_LD_UMAX)\n+ _AMO_LD_SIMPLE (amo_lwat_umin,  uint32_t, \"lwat\", _AMO_LD_UMIN)\n+ _AMO_LD_SIMPLE (amo_lwat_swap,  uint32_t, \"lwat\", _AMO_LD_SWAP)\n+\n+ _AMO_LD_SIMPLE (amo_lwat_sadd,  int32_t,  \"lwat\", _AMO_LD_ADD)\n+ _AMO_LD_SIMPLE (amo_lwat_smax,  int32_t,  \"lwat\", _AMO_LD_SMAX)\n+ _AMO_LD_SIMPLE (amo_lwat_smin,  int32_t,  \"lwat\", _AMO_LD_SMIN)\n+ _AMO_LD_SIMPLE (amo_lwat_sswap, int32_t,  \"lwat\", _AMO_LD_SWAP)\n+\n+ _AMO_LD_SIMPLE (amo_ldat_add,   uint64_t, \"ldat\", _AMO_LD_ADD)\n+ _AMO_LD_SIMPLE (amo_ldat_xor,   uint64_t, \"ldat\", _AMO_LD_XOR)\n+ _AMO_LD_SIMPLE (amo_ldat_ior,   uint64_t, \"ldat\", _AMO_LD_IOR)\n+ _AMO_LD_SIMPLE (amo_ldat_and,   uint64_t, \"ldat\", _AMO_LD_AND)\n+ _AMO_LD_SIMPLE (amo_ldat_umax,  uint64_t, \"ldat\", _AMO_LD_UMAX)\n+ _AMO_LD_SIMPLE (amo_ldat_umin,  uint64_t, \"ldat\", _AMO_LD_UMIN)\n+ _AMO_LD_SIMPLE (amo_ldat_swap,  uint64_t, \"ldat\", _AMO_LD_SWAP)\n+\n+ _AMO_LD_SIMPLE (amo_ldat_sadd,  int64_t,  \"ldat\", _AMO_LD_ADD)\n+ _AMO_LD_SIMPLE (amo_ldat_smax,  int64_t,  \"ldat\", _AMO_LD_SMAX)\n+ _AMO_LD_SIMPLE (amo_ldat_smin,  int64_t,  \"ldat\", _AMO_LD_SMIN)\n+ _AMO_LD_SIMPLE (amo_ldat_sswap, int64_t,  \"ldat\", _AMO_LD_SWAP)\n+\n+ /* Enumeration of the STWAT/STDAT sub-opcodes.  */\n+ enum _AMO_ST {\n+   _AMO_ST_ADD\t\t= 0x00,\t\t/* Store Add.  */\n+   _AMO_ST_XOR\t\t= 0x01,\t\t/* Store Xor.  */\n+   _AMO_ST_IOR\t\t= 0x02,\t\t/* Store Ior.  */\n+   _AMO_ST_AND\t\t= 0x03,\t\t/* Store And.  */\n+   _AMO_ST_UMAX\t\t= 0x04,\t\t/* Store Unsigned Maximum.  */\n+   _AMO_ST_SMAX\t\t= 0x05,\t\t/* Store Signed Maximum.  */\n+   _AMO_ST_UMIN\t\t= 0x06,\t\t/* Store Unsigned Minimum.  */\n+   _AMO_ST_SMIN\t\t= 0x07,\t\t/* Store Signed Minimum.  */\n+   _AMO_ST_TWIN\t\t= 0x18\t\t/* Store Twin.  */\n+ };\n+\n+ /* Implementation of the simple STWAT/STDAT operations that take one register\n+    and modify one word or double-word of memory.  No value is returned.\n+\n+    The STWAT/STDAT opcode requires the address to be a single register, and\n+    that points to a suitably aligned memory location.  Asm volatile is used to\n+    prevent the optimizer from moving the operation.  */\n+\n+ #define _AMO_ST_SIMPLE(NAME, TYPE, OPCODE, FC)\t\t\t\t\\\n+ static __inline__ void\t\t\t\t\t\t\t\\\n+ NAME (TYPE *_PTR, TYPE _VALUE)\t\t\t\t\t\t\\\n+ {\t\t\t\t\t\t\t\t\t\\\n+   __asm__ volatile (OPCODE \" %1,%P0,%2\"\t\t\t\t\t\\\n+ \t\t    : \"+Q\" (_PTR[0])\t\t\t\t\t\\\n+ \t\t    : \"r\" (_VALUE), \"n\" (FC));\t\t\t\t\\\n+   return;\t\t\t\t\t\t\t\t\\\n+ }\n+\n+ _AMO_ST_SIMPLE (amo_stwat_add,  uint32_t, \"stwat\", _AMO_ST_ADD)\n+ _AMO_ST_SIMPLE (amo_stwat_xor,  uint32_t, \"stwat\", _AMO_ST_XOR)\n+ _AMO_ST_SIMPLE (amo_stwat_ior,  uint32_t, \"stwat\", _AMO_ST_IOR)\n+ _AMO_ST_SIMPLE (amo_stwat_and,  uint32_t, \"stwat\", _AMO_ST_AND)\n+ _AMO_ST_SIMPLE (amo_stwat_umax, uint32_t, \"stwat\", _AMO_ST_UMAX)\n+ _AMO_ST_SIMPLE (amo_stwat_umin, uint32_t, \"stwat\", _AMO_ST_UMIN)\n+\n+ _AMO_ST_SIMPLE (amo_stwat_sadd, int32_t,  \"stwat\", _AMO_ST_ADD)\n+ _AMO_ST_SIMPLE (amo_stwat_smax, int32_t,  \"stwat\", _AMO_ST_SMAX)\n+ _AMO_ST_SIMPLE (amo_stwat_smin, int32_t,  \"stwat\", _AMO_ST_SMIN)\n+\n+ _AMO_ST_SIMPLE (amo_stdat_add,  uint64_t, \"stdat\", _AMO_ST_ADD)\n+ _AMO_ST_SIMPLE (amo_stdat_xor,  uint64_t, \"stdat\", _AMO_ST_XOR)\n+ _AMO_ST_SIMPLE (amo_stdat_ior,  uint64_t, \"stdat\", _AMO_ST_IOR)\n+ _AMO_ST_SIMPLE (amo_stdat_and,  uint64_t, \"stdat\", _AMO_ST_AND)\n+ _AMO_ST_SIMPLE (amo_stdat_umax, uint64_t, \"stdat\", _AMO_ST_UMAX)\n+ _AMO_ST_SIMPLE (amo_stdat_umin, uint64_t, \"stdat\", _AMO_ST_UMIN)\n+\n+ _AMO_ST_SIMPLE (amo_stdat_sadd, int64_t,  \"stdat\", _AMO_ST_ADD)\n+ _AMO_ST_SIMPLE (amo_stdat_smax, int64_t,  \"stdat\", _AMO_ST_SMAX)\n+ _AMO_ST_SIMPLE (amo_stdat_smin, int64_t,  \"stdat\", _AMO_ST_SMIN)\n+ #endif\t/* _ARCH_PWR9 && _ARCH_PPC64.  */\n+ #endif\t/* _POWERPC_AMO_H.  */"}]}