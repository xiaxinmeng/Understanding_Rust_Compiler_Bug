{"sha": "07127a0a3b7a73f24105b80dd63c12d38fe84bf1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDcxMjdhMGEzYjdhNzNmMjQxMDViODBkZDYzYzEyZDM4ZmU4NGJmMQ==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2006-03-09T03:09:37Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2006-03-09T03:09:37Z"}, "message": "addsub.md (addqi3): Disparage a0/a1.\n\n* config/m32c/addsub.md (addqi3): Disparage a0/a1.\n(addpsi3): Expand to include memory operands.  Remove\nreload-specific splits.\n* config/m32c/bitops.md (bset_qi, bset_hi, bclr_qi): New.\n(andqi3_16, andhi3_16, iorqi3_16, iorhi3_16): New.\n(andqi3_24, andhi3_24, iorqi3_24, iorhi3_24): New.\n(andqi3, andhi3, iorqi3, iorhi3): Convert to expanders.\n(shift1_qi, shift1_hi, insv): New.\n* config/m32c/cond.md (cbranchqi4, cbranchhi4): Remove.\n(cbranch<mode>4, stzx_16, stzx_24_<mode>, stzx_reversed,\ncmp<mode>, b<code>, s<code>, s<code>_24, movqicc, movhicc,\ncond_to_int): New.\n* config/m32c/m32c-protos.h: Update as needed.\n* config/m32c/m32c.c (m32c_reg_class_from_constraint): Don't\ndefault the Rcr, Rcl, Raw, and Ral constraints.  Add Ra0 and Ra1.\nFail for unrecognized R* constraints.\n(m32c_cannot_change_mode_class): Be more picky about pseudos.\n(m32c_const_ok_for_constraint_p): Add Imb, Imw, and I00.\n(m32c_extra_constraint_p2): Allow (mem (plus (plus fb int) int)).\nAdd Sp constraint.\n(m32c_init_libfuncs): New.\n(m32c_legitimate_address_p): Add debug wrapper.\n(m32c_rtx_costs): New.\n(m32c_address_cost): New.\n(conversions): Add 'B' prefix.\n(m32c_print_operand): 'h' and 'H' pick lower and upper halves of\noperands, or word regnames for QI operands.  'B' prints bit\nposition.\n(m32c_expand_setmemhi): New.\n(m32c_expand_movmemhi): New.\n(m32c_expand_movstr): New.\n(m32c_expand_cmpstr): New.\n(m32c_prepare_shift): Shift counts are limited to 16 bits at a time.\n(m32c_expand_neg_mulpsi3): Handle non-ints.\n(m32c_cmp_flg_0): New.\n(m32c_expand_movcc): New.\n(m32c_expand_insv): New.\n(m32c_scc_pattern): New.\n* config/m32c/m32c.h (reg classes): Add AO_REGS and A1_REGS.  Take\na0/a1 out of SIregs.\n(STORE_FLAG_VALUE): New.\n* config/m32c/m32c.md: Add unspecs for string moves.  Define various mode and\ncode macros.\n(no_insn): New.\n* config/m32c/mov.md: Make constraints more liberal.\n(zero_extendqihi2): Optimize r0/r1 case.\n* config/m32c/muldiv.md (mulpsi3): Check for intvals.\n* config/m32c/predicates.md (m32c_any_operand): New.\n(m32c_nonimmediate_operand): New.\n(m32c_hl_operand): New.\n(m32c_r3_operand): New.\n(ap_operand): New.\n(ma_operand): New.\n(memsym_operand): New.\n(memimmed_operand): New.\n(a_qi_operand): New.\n(m32c_eqne_operator): New.\n(m32c_1bit8_operand): New.\n(m32c_1bit16_operand): New.\n(m32c_1mask8_operand): New.\n(m32c_1mask16_operand): New.\n* config/m32c/blkmov.md: New file.\n* config/m32c/t-m32c (MD_FILES): Add blkmov.\n\nFrom-SVN: r111859", "tree": {"sha": "2fb717e64143d3839431bdeadd6264727cee4056", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fb717e64143d3839431bdeadd6264727cee4056"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07127a0a3b7a73f24105b80dd63c12d38fe84bf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07127a0a3b7a73f24105b80dd63c12d38fe84bf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07127a0a3b7a73f24105b80dd63c12d38fe84bf1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/comments", "author": null, "committer": null, "parents": [{"sha": "8b3a0b7198e6c49c34316b421fb0c76d3d86e55a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b3a0b7198e6c49c34316b421fb0c76d3d86e55a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b3a0b7198e6c49c34316b421fb0c76d3d86e55a"}], "stats": {"total": 1608, "additions": 1436, "deletions": 172}, "files": [{"sha": "047033cce57925a25159e6c03942fdf8279f1860", "filename": "gcc/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07127a0a3b7a73f24105b80dd63c12d38fe84bf1", "patch": "@@ -1,3 +1,69 @@\n+2006-03-08  DJ Delorie  <dj@redhat.com>\n+\n+\t* config/m32c/addsub.md (addqi3): Disparage a0/a1.\n+\t(addpsi3): Expand to include memory operands.  Remove\n+\treload-specific splits.\n+\t* config/m32c/bitops.md (bset_qi, bset_hi, bclr_qi): New.\n+\t(andqi3_16, andhi3_16, iorqi3_16, iorhi3_16): New.\n+\t(andqi3_24, andhi3_24, iorqi3_24, iorhi3_24): New.\n+\t(andqi3, andhi3, iorqi3, iorhi3): Convert to expanders.\n+\t(shift1_qi, shift1_hi, insv): New.\n+\t* config/m32c/cond.md (cbranchqi4, cbranchhi4): Remove.\n+\t(cbranch<mode>4, stzx_16, stzx_24_<mode>, stzx_reversed,\n+\tcmp<mode>, b<code>, s<code>, s<code>_24, movqicc, movhicc,\n+\tcond_to_int): New.\n+\t* config/m32c/m32c-protos.h: Update as needed.\n+\t* config/m32c/m32c.c (m32c_reg_class_from_constraint): Don't\n+\tdefault the Rcr, Rcl, Raw, and Ral constraints.  Add Ra0 and Ra1.\n+\tFail for unrecognized R* constraints.\n+\t(m32c_cannot_change_mode_class): Be more picky about pseudos.\n+\t(m32c_const_ok_for_constraint_p): Add Imb, Imw, and I00.\n+\t(m32c_extra_constraint_p2): Allow (mem (plus (plus fb int) int)).\n+\tAdd Sp constraint.\n+\t(m32c_init_libfuncs): New.\n+\t(m32c_legitimate_address_p): Add debug wrapper.\n+\t(m32c_rtx_costs): New.\n+\t(m32c_address_cost): New.\n+\t(conversions): Add 'B' prefix.\n+\t(m32c_print_operand): 'h' and 'H' pick lower and upper halves of\n+\toperands, or word regnames for QI operands.  'B' prints bit\n+\tposition.\n+\t(m32c_expand_setmemhi): New.\n+\t(m32c_expand_movmemhi): New.\n+\t(m32c_expand_movstr): New.\n+\t(m32c_expand_cmpstr): New.\n+\t(m32c_prepare_shift): Shift counts are limited to 16 bits at a time.\n+\t(m32c_expand_neg_mulpsi3): Handle non-ints.\n+\t(m32c_cmp_flg_0): New.\n+\t(m32c_expand_movcc): New.\n+\t(m32c_expand_insv): New.\n+\t(m32c_scc_pattern): New.\n+\t* config/m32c/m32c.h (reg classes): Add AO_REGS and A1_REGS.  Take\n+\ta0/a1 out of SIregs.\n+\t(STORE_FLAG_VALUE): New.\n+\t* config/m32c/m32c.md: Add unspecs for string moves.  Define various mode and\n+\tcode macros.\n+\t(no_insn): New.\n+\t* config/m32c/mov.md: Make constraints more liberal.\n+\t(zero_extendqihi2): Optimize r0/r1 case.\n+\t* config/m32c/muldiv.md (mulpsi3): Check for intvals.\n+\t* config/m32c/predicates.md (m32c_any_operand): New.\n+\t(m32c_nonimmediate_operand): New.\n+\t(m32c_hl_operand): New.\n+\t(m32c_r3_operand): New.\n+\t(ap_operand): New.\n+\t(ma_operand): New.\n+\t(memsym_operand): New.\n+\t(memimmed_operand): New.\n+\t(a_qi_operand): New.\n+\t(m32c_eqne_operator): New.\n+\t(m32c_1bit8_operand): New.\n+\t(m32c_1bit16_operand): New.\n+\t(m32c_1mask8_operand): New.\n+\t(m32c_1mask16_operand): New.\n+\t* config/m32c/blkmov.md: New file.\n+\t* config/m32c/t-m32c (MD_FILES): Add blkmov.\n+\n 2006-03-08  Andreas Tobler  <a.tobler@schweiz.ch>\n \n \t* dwarf2out.c (expand_builtin_dwarf_sp_column): Make dwarf_regnum"}, {"sha": "6ac31dd1209a6e8c5e9d27e8119afe7d385a7f54", "filename": "gcc/config/m32c/addsub.md", "status": "modified", "additions": 15, "deletions": 41, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Faddsub.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Faddsub.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Faddsub.md?ref=07127a0a3b7a73f24105b80dd63c12d38fe84bf1", "patch": "@@ -24,22 +24,22 @@\n \n (define_insn \"addqi3\"\n   [(set (match_operand:QI 0 \"mra_or_sp_operand\"\n-\t\t  \"=SdRhl,SdRhl,??Rmm,??Rmm, Raa,Raa,SdRhl,??Rmm\")\n+\t\t  \"=SdRhl,SdRhl,??Rmm,??Rmm, *Raa,*Raa,SdRhl,??Rmm\")\n \t(plus:QI (match_operand:QI 1 \"mra_operand\"\n \t\t  \"%0,0,0,0, 0,0,0,0\")\n \t\t (match_operand:QI 2 \"mrai_operand\"\n-\t\t  \"iSdRhl,?Rmm,iSdRhl,?Rmm, iSdRhl,?Rmm,Raa,Raa\")))]\n+\t\t  \"iSdRhl,?Rmm,iSdRhl,?Rmm, iSdRhl,?Rmm,*Raa,*Raa\")))]\n   \"\"\n   \"add.b\\t%2,%0\"\n   [(set_attr \"flags\" \"oszc\")]\n   )\n \n (define_insn \"addhi3\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\"\n+  [(set (match_operand:HI 0 \"m32c_nonimmediate_operand\"\n \t \t  \"=SdRhi,SdRhi,??Rmm,??Rmm, SdRhi,??Rmm, Rhi, Raw, Raw, !Rsp\")\n-\t(plus:HI (match_operand:HI 1 \"general_operand\"\n+\t(plus:HI (match_operand:HI 1 \"m32c_any_operand\"\n \t\t  \"%0,0,0,0, 0,0, Raw, Rfb, Rfb, 0\")\n-\t\t (match_operand:HI 2 \"general_operand\"\n+\t\t (match_operand:HI 2 \"m32c_any_operand\"\n \t\t  \"IU2sSdRhi,?Rmm,IU2sSdRhi,?Rmm, IM2,IM2, IS2IU2, I00, IS1, i\")))]\n   \"\"\n   \"@\n@@ -57,45 +57,19 @@\n   )\n \n (define_insn \"addpsi3\"\n-  [(set (match_operand:PSI 0 \"nonimmediate_operand\" \"=SdRpi,SdRpi,Rsp*Rmm, Rpi,Rpi,Rhi,&Rhi\")\n-\t(plus:PSI (match_operand:PSI 1 \"nonimmediate_operand\" \"0,0,0, Raa,Rad,!Rcl,Rhi\")\n-\t\t  (match_operand:PSI 2 \"general_operand\" \"iSdRpi,?Rmm,i, i,IS2,i,!Rcl\")))]\n+  [(set (match_operand:PSI 0 \"m32c_nonimmediate_operand\" \"=Rpi,Raa,SdRpi,SdRpi,Rsp*Rmm, Rpi,Rpi\")\n+\t(plus:PSI (match_operand:PSI 1 \"m32c_nonimmediate_operand\" \"0,0,0,0,0, Raa,Rad\")\n+\t\t  (match_operand:PSI 2 \"m32c_any_operand\" \"Is3,IS1,iSdRpi,?Rmm,i, i,IS2\")))]\n   \"TARGET_A24\"\n   \"@\n-   add.%&\\t%2,%0\n-   add.%&\\t%2,%0\n-   add.%&\\t%2,%0\n+   add.l:q\\t%2,%0\n+   addx\\t%2,%0\n+   add.l\\t%2,%0\n+   add.l\\t%2,%0\n+   add.l\\t%2,%0\n    mova\\t%d2[%1],%0\n-   mova\\t%D2[%1],%0\n-   #\n-   #\"\n-  [(set_attr \"flags\" \"oszc,oszc,oszc,*,*,oszc,oszc\")]\n-  )\n-\n-; This is needed for reloading large frames.\n-(define_split\n-  [(set (match_operand:PSI 0 \"ra_operand\" \"\")\n-\t(plus:PSI (match_operand:PSI 1 \"cr_operand\" \"\")\n-\t\t (match_operand:PSI 2 \"immediate_operand\" \"\")))]\n-  \"\"\n-  [(set (match_dup 0) (match_dup 1))\n-   (set (match_dup 0)\n-\t(plus:PSI (match_dup 0)\n-\t\t (match_dup 2)))]\n-  \"\"\n-  )\n-\n-; This is needed for reloading large frames.\n-(define_split\n-  [(set (match_operand:PSI 0 \"ra_operand\" \"\")\n-\t(plus:PSI (match_operand:PSI 1 \"ra_operand\" \"\")\n-\t\t (match_operand:PSI 2 \"cr_operand\" \"\")))]\n-  \"\"\n-  [(set (match_dup 0) (match_dup 2))\n-   (set (match_dup 0)\n-\t(plus:PSI (match_dup 0)\n-\t\t (match_dup 1)))]\n-  \"\"\n+   mova\\t%D2[%1],%0\"\n+  [(set_attr \"flags\" \"oszc,oszc,oszc,oszc,oszc,*,*\")]\n   )\n \n (define_insn \"subqi3\""}, {"sha": "e7823b92c72341d3e522147d7796f457e40df6ef", "filename": "gcc/config/m32c/bitops.md", "status": "modified", "additions": 266, "deletions": 24, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Fbitops.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Fbitops.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fbitops.md?ref=07127a0a3b7a73f24105b80dd63c12d38fe84bf1", "patch": "@@ -22,40 +22,247 @@\n \n ;; Bit-wise operations (and, ior, xor, shift)\n \n-(define_insn \"andqi3\"\n-  [(set (match_operand:QI 0 \"mra_operand\" \"=RhlSd,RhlSd,??Rmm,??Rmm\")\n-\t(and:QI (match_operand:QI 1 \"mra_operand\" \"%0,0,0,0\")\n-\t\t(match_operand:QI 2 \"mrai_operand\" \"iRhlSd,?Rmm,iRhlSd,?Rmm\")))]\n+; On the R8C and M16C, \"address\" for bit instructions is usually (but\n+; not always!) the *bit* address, not the *byte* address.  This\n+; confuses gcc, so we avoid cases where gcc would produce the wrong\n+; code.  We're left with absolute addresses and registers, and the odd\n+; case of shifting a bit by a variable.\n+\n+; On the M32C, \"address\" for bit instructions is a regular address,\n+; and the bit number is stored in a separate field.  Thus, we can let\n+; gcc do more interesting things.  However, the M32C cannot set all\n+; the bits in a 16 bit register, which the R8C/M16C can do.\n+\n+; However, it all means that we end up with two sets of patterns, one\n+; for each chip.\n+\n+;;----------------------------------------------------------------------\n+\n+;; First off, all the ways we can set one bit, other than plain IOR.\n+\n+(define_insn \"bset_qi\"\n+  [(set (match_operand:QI 0 \"memsym_operand\" \"+Si\")\n+\t(ior:QI (subreg:QI (ashift:HI (const_int 1)\n+\t\t\t\t      (subreg:QI (match_operand:HI 1 \"a_qi_operand\" \"Raa\") 0)) 0)\n+\t\t(match_operand:QI 2 \"\" \"0\")))]\n+  \"TARGET_A16\"\n+  \"bset\\t%0[%1]\"\n+  [(set_attr \"flags\" \"sz\")]\n+  )  \n+\n+(define_insn \"bset_hi\"\n+  [(set (zero_extract:HI (match_operand:QI 0 \"memsym_operand\" \"+Si\")\n+\t\t\t (const_int 1)\n+\t\t\t (zero_extend:HI (subreg:QI (match_operand:HI 1 \"a_qi_operand\" \"Raa\") 0)))\n+\t(const_int 1))]\n+  \"TARGET_A16\"\n+  \"bset\\t%0[%1]\"\n+  [(set_attr \"flags\" \"sz\")]\n+  )  \n+\n+;;----------------------------------------------------------------------\n+\n+;; Now all the ways we can clear one bit, other than plain AND.\n+\n+; This is odd because the shift patterns use QI counts, but we can't\n+; easily put QI in $aN without causing problems elsewhere.\n+(define_insn \"bclr_qi\"\n+  [(set (zero_extract:HI (match_operand:QI 0 \"memsym_operand\" \"+Si\")\n+\t\t\t (const_int 1)\n+\t\t\t (zero_extend:HI (subreg:QI (match_operand:HI 1 \"a_qi_operand\" \"Raa\") 0)))\n+\t(const_int 0))]\n+  \"TARGET_A16\"\n+  \"bclr\\t%0[%1]\"\n+  [(set_attr \"flags\" \"sz\")]\n+  )  \n+\n+\n+;;----------------------------------------------------------------------\n+\n+;; Now the generic patterns.\n+\n+(define_insn \"andqi3_16\"\n+  [(set (match_operand:QI 0 \"mra_operand\" \"=Sp,Rqi,RhlSd,RhlSd,??Rmm,??Rmm\")\n+\t(and:QI (match_operand:QI 1 \"mra_operand\" \"%0,0,0,0,0,0\")\n+\t\t(match_operand 2 \"mrai_operand\" \"Imb,Imb,iRhlSd,?Rmm,iRhlSd,?Rmm\")))]\n+  \"TARGET_A16\"\n+  \"@\n+   bclr\\t%B2,%0\n+   bclr\\t%B2,%h0\n+   and.b\\t%x2,%0\n+   and.b\\t%x2,%0\n+   and.b\\t%x2,%0\n+   and.b\\t%x2,%0\"\n+  [(set_attr \"flags\" \"n,n,sz,sz,sz,sz\")]\n+  )\n+\n+(define_insn \"andhi3_16\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=Sp,Sp,Rhi,RhiSd,??Rmm,RhiSd,??Rmm\")\n+\t(and:HI (match_operand:HI 1 \"mra_operand\" \"%0,0,0,0,0,0,0\")\n+\t\t(match_operand:HI 2 \"mrai_operand\" \"Imb,Imw,Imw,iRhiSd,?Rmm,?Rmm,iRhiSd\")))]\n+  \"TARGET_A16\"\n+  \"@\n+   \n+   bclr\\t%B2,%0\n+   bclr\\t%B2-8,1+%0\n+   bclr\\t%B2,%0\n+   and.w\\t%X2,%0\n+   and.w\\t%X2,%0\n+   and.w\\t%X2,%0\n+   and.w\\t%X2,%0\"\n+  [(set_attr \"flags\" \"n,n,n,sz,sz,sz,sz\")]\n+  )\n+\n+\n+\n+(define_insn \"iorqi3_16\"\n+  [(set (match_operand:QI 0 \"mra_operand\" \"=Sp,Rqi,RqiSd,??Rmm,RqiSd,??Rmm\")\n+\t(ior:QI (match_operand:QI 1 \"mra_operand\" \"%0,0,0,0,0,0\")\n+\t\t(match_operand:QI 2 \"mrai_operand\" \"Ilb,Ilb,iRhlSd,iRhlSd,?Rmm,?Rmm\")))]\n+  \"TARGET_A16\"\n+  \"@\n+   bset\\t%B2,%0\n+   bset\\t%B2,%h0\n+   or.b\\t%x2,%0\n+   or.b\\t%x2,%0\n+   or.b\\t%x2,%0\n+   or.b\\t%x2,%0\"\n+  [(set_attr \"flags\" \"n,n,sz,sz,sz,sz\")]\n+  )\n+\n+(define_insn \"iorhi3_16\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=Sp,Sp,Rhi,RhiSd,RhiSd,??Rmm,??Rmm\")\n+\t(ior:HI (match_operand:HI 1 \"mra_operand\" \"%0,0,0,0,0,0,0\")\n+\t\t(match_operand:HI 2 \"mrai_operand\" \"Imb,Imw,Ilw,iRhiSd,?Rmm,iRhiSd,?Rmm\")))]\n+  \"TARGET_A16\"\n+  \"@\n+   bset %B2,%0\n+   bset\\t%B2-8,1+%0\n+   bset\\t%B2,%0\n+   or.w\\t%X2,%0\n+   or.w\\t%X2,%0\n+   or.w\\t%X2,%0\n+   or.w\\t%X2,%0\"\n+  [(set_attr \"flags\" \"n,n,n,sz,sz,sz,sz\")]\n+  )\n+\n+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+\n+(define_insn \"andqi3_24\"\n+  [(set (match_operand:QI 0 \"mra_operand\" \"=Sd,Rqi,RhlSd,RhlSd,??Rmm,??Rmm\")\n+\t(and:QI (match_operand:QI 1 \"mra_operand\" \"%0,0,0,0,0,0\")\n+\t\t(match_operand 2 \"mrai_operand\" \"Imb,Imb,iRhlSd,?Rmm,iRhlSd,?Rmm\")))]\n+  \"TARGET_A24\"\n+  \"@\n+   bclr\\t%B2,%0\n+   bclr\\t%B2,%0\n+   and.b\\t%x2,%0\n+   and.b\\t%x2,%0\n+   and.b\\t%x2,%0\n+   and.b\\t%x2,%0\"\n+  [(set_attr \"flags\" \"n,n,sz,sz,sz,sz\")]\n+  )\n+\n+(define_insn \"andhi3_24\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=Sd,Sd,Rqi,Rqi,RhiSd,??Rmm,RhiSd,??Rmm\")\n+\t(and:HI (match_operand:HI 1 \"mra_operand\" \"%0,0,0,0,0,0,0,0\")\n+\t\t(match_operand:HI 2 \"mrai_operand\" \"Imb,Imw,Imb,Imw,iRhiSd,?Rmm,?Rmm,iRhiSd\")))]\n+  \"TARGET_A24\"\n+  \"@\n+   bclr\\t%B2,%0\n+   bclr\\t%B2-8,1+%0\n+   bclr\\t%B2,%h0\n+   bclr\\t%B2-8,%H0\n+   and.w\\t%X2,%0\n+   and.w\\t%X2,%0\n+   and.w\\t%X2,%0\n+   and.w\\t%X2,%0\"\n+  [(set_attr \"flags\" \"n,n,n,n,sz,sz,sz,sz\")]\n+  )\n+\n+\n+\n+(define_insn \"iorqi3_24\"\n+  [(set (match_operand:QI 0 \"mra_operand\" \"=Sd,Rqi,RqiSd,??Rmm,RqiSd,??Rmm\")\n+\t(ior:QI (match_operand:QI 1 \"mra_operand\" \"%0,0,0,0,0,0\")\n+\t\t(match_operand:QI 2 \"mrai_operand\" \"Ilb,Ilb,iRhlSd,iRhlSd,?Rmm,?Rmm\")))]\n+  \"TARGET_A24\"\n+  \"@\n+   bset\\t%B2,%0\n+   bset\\t%B2,%0\n+   or.b\\t%x2,%0\n+   or.b\\t%x2,%0\n+   or.b\\t%x2,%0\n+   or.b\\t%x2,%0\"\n+  [(set_attr \"flags\" \"n,n,sz,sz,sz,sz\")]\n+  )\n+\n+(define_insn \"iorhi3_24\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=Sd,Sd,Rqi,Rqi,RhiSd,RhiSd,??Rmm,??Rmm\")\n+\t(ior:HI (match_operand:HI 1 \"mra_operand\" \"%0,0,0,0,0,0,0,0\")\n+\t\t(match_operand:HI 2 \"mrai_operand\" \"Ilb,Ilw,Ilb,Ilw,iRhiSd,?Rmm,iRhiSd,?Rmm\")))]\n+  \"TARGET_A24\"\n+  \"@\n+   bset\\t%B2,%0\n+   bset\\t%B2-8,1+%0\n+   bset\\t%B2,%h0\n+   bset\\t%B2-8,%H0\n+   or.w\\t%X2,%0\n+   or.w\\t%X2,%0\n+   or.w\\t%X2,%0\n+   or.w\\t%X2,%0\"\n+  [(set_attr \"flags\" \"n,n,n,n,sz,sz,sz,sz\")]\n+  )\n+\n+\n+; ----------------------------------------------------------------------\n+\n+(define_expand \"andqi3\"\n+  [(set (match_operand:QI 0 \"mra_operand\" \"\")\n+\t(and:QI (match_operand:QI 1 \"mra_operand\" \"\")\n+\t\t(match_operand:QI 2 \"mrai_operand\" \"\")))]\n   \"\"\n-  \"and.b\\t%x2,%0\"\n-  [(set_attr \"flags\" \"sz,sz,sz,sz\")]\n+  \"if (TARGET_A16)\n+     emit_insn (gen_andqi3_16 (operands[0], operands[1], operands[2]));\n+   else\n+     emit_insn (gen_andqi3_24 (operands[0], operands[1], operands[2]));\n+   DONE;\"\n   )\n \n-(define_insn \"andhi3\"\n-  [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd,??Rmm,RhiSd,??Rmm\")\n-\t(and:HI (match_operand:HI 1 \"mra_operand\" \"%0,0,0,0\")\n-\t\t(match_operand:HI 2 \"mrai_operand\" \"iRhiSd,?Rmm,?Rmm,iRhiSd\")))]\n+(define_expand \"andhi3\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"\")\n+\t(and:HI (match_operand:HI 1 \"mra_operand\" \"\")\n+\t\t(match_operand:HI 2 \"mrai_operand\" \"\")))]\n   \"\"\n-  \"and.w\\t%X2,%0\"\n-  [(set_attr \"flags\" \"sz,sz,sz,sz\")]\n+  \"if (TARGET_A16)\n+     emit_insn (gen_andhi3_16 (operands[0], operands[1], operands[2]));\n+   else\n+     emit_insn (gen_andhi3_24 (operands[0], operands[1], operands[2]));\n+   DONE;\"\n   )\n \n-(define_insn \"iorqi3\"\n-  [(set (match_operand:QI 0 \"mra_operand\" \"=RqiSd,??Rmm,RqiSd,??Rmm\")\n-\t(ior:QI (match_operand:QI 1 \"mra_operand\" \"%0,0,0,0\")\n-\t\t(match_operand:QI 2 \"mrai_operand\" \"iRhlSd,iRhlSd,?Rmm,?Rmm\")))]\n+(define_expand \"iorqi3\"\n+  [(set (match_operand:QI 0 \"mra_operand\" \"\")\n+\t(ior:QI (match_operand:QI 1 \"mra_operand\" \"\")\n+\t\t(match_operand:QI 2 \"mrai_operand\" \"\")))]\n   \"\"\n-  \"or.b\\t%x2,%0\"\n-  [(set_attr \"flags\" \"sz,sz,sz,sz\")]\n+  \"if (TARGET_A16)\n+     emit_insn (gen_iorqi3_16 (operands[0], operands[1], operands[2]));\n+   else\n+     emit_insn (gen_iorqi3_24 (operands[0], operands[1], operands[2]));\n+   DONE;\"\n   )\n \n-(define_insn \"iorhi3\"\n-  [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd,RhiSd,??Rmm,??Rmm\")\n-\t(ior:HI (match_operand:HI 1 \"mra_operand\" \"%0,0,0,0\")\n-\t\t(match_operand:HI 2 \"mrai_operand\" \"iRhiSd,?Rmm,iRhiSd,?Rmm\")))]\n+(define_expand \"iorhi3\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"\")\n+\t(ior:HI (match_operand:HI 1 \"mra_operand\" \"\")\n+\t\t(match_operand:HI 2 \"mrai_operand\" \"\")))]\n   \"\"\n-  \"or.w\\t%X2,%0\"\n-  [(set_attr \"flags\" \"sz,sz,sz,sz\")]\n+  \"if (TARGET_A16)\n+     emit_insn (gen_iorhi3_16 (operands[0], operands[1], operands[2]));\n+   else\n+     emit_insn (gen_iorhi3_24 (operands[0], operands[1], operands[2]));\n+   DONE;\"\n   )\n \n (define_insn \"xorqi3\"\n@@ -91,3 +298,38 @@\n   \"not.w\\t%0\"\n   [(set_attr \"flags\" \"sz,sz\")]\n   )\n+\n+; Optimizations using bit opcodes\n+\n+; We need this because combine only looks at three insns at a time,\n+; and the bclr_qi pattern uses four - mov, shift, not, and.  GCC\n+; should never expand this pattern, because it only shifts a constant\n+; by a constant, so gcc should do that itself.\n+(define_insn \"shift1_qi\"\n+  [(set (match_operand:QI 0 \"mra_operand\" \"=Rqi\")\n+\t(ashift:QI (const_int 1)\n+\t\t   (match_operand 1 \"const_int_operand\" \"In4\")))]\n+  \"\"\n+  \"mov.b\\t#1,%0\\n\\tshl.b\\t%1,%0\"\n+  )\n+(define_insn \"shift1_hi\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=Rhi\")\n+\t(ashift:HI (const_int 1)\n+\t\t   (match_operand 1 \"const_int_operand\" \"In4\")))]\n+  \"\"\n+  \"mov.w\\t#1,%0\\n\\tshl.w\\t%1,%0\"\n+  )\n+\n+; Generic insert-bit expander, needed so that we can use the bit\n+; opcodes for volatile bitfields.\n+\n+(define_expand \"insv\"\n+  [(set (zero_extract:HI (match_operand:HI 0 \"mra_operand\" \"\")\n+\t\t\t (match_operand 1 \"const_int_operand\" \"\")\n+\t\t\t (match_operand 2 \"const_int_operand\" \"\"))\n+\t(match_operand:HI 3 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"if (m32c_expand_insv (operands))\n+     FAIL;\n+   DONE;\"\n+  )"}, {"sha": "44083e4793c209f533bc203c24926f94b561296b", "filename": "gcc/config/m32c/blkmov.md", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Fblkmov.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Fblkmov.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fblkmov.md?ref=07127a0a3b7a73f24105b80dd63c12d38fe84bf1", "patch": "@@ -0,0 +1,243 @@\n+;; Machine Descriptions for R8C/M16C/M32C\n+;; Copyright (C) 2006\n+;; Free Software Foundation, Inc.\n+;; Contributed by Red Hat.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 2, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+;; 02110-1301, USA.\n+\n+;; various block move instructions\n+\n+;; R8C:\n+;;  SMOVB - while (r3--) { *a1-- = *r1ha0--; } - memcpy\n+;;  SMOVF - while (r3--) { *a1++ = *r1ha0++; } - memcpy\n+;;  SSTR  - while (r3--) { *a1++ = [r0l,r0]; } - memset\n+\n+;; M32CM:\n+;;  SCMPU - while (*a0 && *a0 != *a1) { a0++; a1++; } - strcmp\n+;;  SIN   - while (r3--) { *a1++ = *a0; }\n+;;  SMOVB - while (r3--) { *a1-- = *a0--; } - memcpy\n+;;  SMOVF - while (r3--) { *a1++ = *a0++; } - memcpy\n+;;  SMOVU - while (*a1++ = *a0++) ; - strcpy\n+;;  SOUT  - while (r3--) { *a1 = *a0++; }\n+;;  SSTR  - while (r3--) { *a1++ = [r0l,r0]; } - memset\n+\n+\n+\n+;; 0 = destination (mem:BLK ...)\n+;; 1 = source (mem:BLK ...)\n+;; 2 = count\n+;; 3 = alignment\n+(define_expand \"movmemhi\"\n+  [(match_operand 0 \"ap_operand\" \"\")\n+   (match_operand 1 \"ap_operand\" \"\")\n+   (match_operand 2 \"m32c_r3_operand\" \"\")\n+   (match_operand 3 \"\" \"\")\n+   ]\n+  \"\"\n+  \"if (m32c_expand_movmemhi(operands)) DONE; FAIL;\"\n+  )\n+\n+;; We can't use mode macros for these because M16C uses r1h to extend\n+;; the source address, for copying data from ROM to RAM.  We don't yet\n+;; support that, but we need to zero our r1h, so the patterns differ.\n+\n+;; 0 = dest (out)\n+;; 1 = src (out)\n+;; 2 = count (out)\n+;; 3 = dest (in)\n+;; 4 = src (in)\n+;; 5 = count (in)\n+(define_insn \"movmemhi_bhi_op\"\n+  [(set (mem:QI (match_operand:HI 3 \"ap_operand\" \"0\"))\n+\t(mem:QI (match_operand:HI 4 \"ap_operand\" \"1\")))\n+   (set (match_operand:HI 2 \"m32c_r3_operand\" \"=R3w\")\n+\t(const_int 0))\n+   (set (match_operand:HI 0 \"ap_operand\" \"=Ra1\")\n+\t(plus:HI (match_dup 3)\n+\t\t  (zero_extend:HI (match_operand:HI 5 \"m32c_r3_operand\" \"2\"))))\n+   (set (match_operand:HI 1 \"ap_operand\" \"=Ra0\")\n+\t(plus:HI (match_dup 4)\n+\t\t  (zero_extend:HI (match_dup 5))))\n+   (use (reg:HI R1_REGNO))]\n+  \"TARGET_A16\"\n+  \"mov.b:q\\t#0,r1h\\n\\tsmovf.b\\t; %0[0..%2-1]=r1h%1[]\"\n+  )\n+(define_insn \"movmemhi_bpsi_op\"\n+  [(set (mem:QI (match_operand:PSI 3 \"ap_operand\" \"0\"))\n+\t(mem:QI (match_operand:PSI 4 \"ap_operand\" \"1\")))\n+   (set (match_operand:HI 2 \"m32c_r3_operand\" \"=R3w\")\n+\t(const_int 0))\n+   (set (match_operand:PSI 0 \"ap_operand\" \"=Ra1\")\n+\t(plus:PSI (match_dup 3)\n+\t\t  (zero_extend:PSI (match_operand:HI 5 \"m32c_r3_operand\" \"2\"))))\n+   (set (match_operand:PSI 1 \"ap_operand\" \"=Ra0\")\n+\t(plus:PSI (match_dup 4)\n+\t\t  (zero_extend:PSI (match_dup 5))))]\n+  \"TARGET_A24\"\n+  \"smovf.b\\t; %0[0..%2-1]=%1[]\"\n+  )\n+(define_insn \"movmemhi_whi_op\"\n+  [(set (mem:HI (match_operand:HI 3 \"ap_operand\" \"0\"))\n+\t(mem:HI (match_operand:HI 4 \"ap_operand\" \"1\")))\n+   (set (match_operand:HI 2 \"m32c_r3_operand\" \"=R3w\")\n+\t(const_int 0))\n+   (set (match_operand:HI 0 \"ap_operand\" \"=Ra1\")\n+\t(plus:HI (match_dup 3)\n+\t\t  (zero_extend:HI (match_operand:HI 5 \"m32c_r3_operand\" \"2\"))))\n+   (set (match_operand:HI 1 \"ap_operand\" \"=Ra0\")\n+\t(plus:HI (match_dup 4)\n+\t\t  (zero_extend:HI (match_dup 5))))\n+   (use (reg:HI R1_REGNO))]\n+  \"TARGET_A16\"\n+  \"mov.b:q\\t#0,r1h\\n\\tsmovf.w\\t; %0[0..%2-1]=r1h%1[]\"\n+  )\n+(define_insn \"movmemhi_wpsi_op\"\n+  [(set (mem:HI (match_operand:PSI 3 \"ap_operand\" \"0\"))\n+\t(mem:HI (match_operand:PSI 4 \"ap_operand\" \"1\")))\n+   (set (match_operand:HI 2 \"m32c_r3_operand\" \"=R3w\")\n+\t(const_int 0))\n+   (set (match_operand:PSI 0 \"ap_operand\" \"=Ra1\")\n+\t(plus:PSI (match_dup 3)\n+\t\t  (zero_extend:PSI (match_operand:HI 5 \"m32c_r3_operand\" \"2\"))))\n+   (set (match_operand:PSI 1 \"ap_operand\" \"=Ra0\")\n+\t(plus:PSI (match_dup 4)\n+\t\t  (zero_extend:PSI (match_dup 5))))]\n+  \"TARGET_A24\"\n+  \"smovf.w\\t; %0[0..%2-1]=%1[]\"\n+  )\n+\n+\n+\n+;; 0 = destination (mem:BLK ...)\n+;; 1 = number of bytes\n+;; 2 = value to store\n+;; 3 = alignment\n+(define_expand \"setmemhi\"\n+  [(match_operand 0 \"ap_operand\" \"\")\n+   (match_operand 1 \"m32c_r3_operand\" \"\")\n+   (match_operand 2 \"m32c_r0_operand\" \"\")\n+   (match_operand 3 \"\" \"\")\n+   ]\n+  \"TARGET_A24\"\n+  \"if (m32c_expand_setmemhi(operands)) DONE; FAIL;\"\n+  )\n+\n+;; 0 = address (out)\n+;; 1 = count (out)\n+;; 2 = value (in)\n+;; 3 = address (in)\n+;; 4 = count (in)\n+(define_insn \"setmemhi_b<mode>_op\"\n+  [(set (mem:QI (match_operand:HPSI 3 \"ap_operand\" \"0\"))\n+\t(match_operand:QI 2 \"m32c_r0_operand\" \"R0w\"))\n+   (set (match_operand:HI 1 \"m32c_r3_operand\" \"=R3w\")\n+\t(const_int 0))\n+   (set (match_operand:HPSI 0 \"ap_operand\" \"=Ra1\")\n+\t(plus:HPSI (match_dup 3)\n+\t\t  (zero_extend:HPSI (match_operand:HI 4 \"m32c_r3_operand\" \"1\"))))]\n+  \"TARGET_A24\"\n+  \"sstr.b\\t; %0[0..%1-1]=%2\"\n+  )\n+\n+(define_insn \"setmemhi_w<mode>_op\"\n+  [(set (mem:HI (match_operand:HPSI 3 \"ap_operand\" \"0\"))\n+\t(match_operand:HI 2 \"m32c_r0_operand\" \"R0w\"))\n+   (set (match_operand:HI 1 \"m32c_r3_operand\" \"=R3w\")\n+\t(const_int 0))\n+   (set (match_operand:HPSI 0 \"ap_operand\" \"=Ra1\")\n+\t(plus:HPSI (match_dup 3)\n+\t\t  (zero_extend:HPSI (match_operand:HI 4 \"m32c_r3_operand\" \"1\"))))]\n+  \"TARGET_A24\"\n+  \"sstr.w\\t; %0[0..%1-1]=%2\"\n+  )\n+\n+\n+;; SCMPU sets the flags according to the result of the string\n+;; comparison.  GCC wants the result to be a signed value reflecting\n+;; the result, which it then compares to zero.  Hopefully we can\n+;; optimize that later (see peephole in cond.md).  Meanwhile, the\n+;; strcmp builtin is expanded to a SCMPU followed by a flags-to-int\n+;; pattern in cond.md.\n+\n+;; 0 = result:HI\n+;; 1 = destination (mem:BLK ...)\n+;; 2 = source (mem:BLK ...)\n+;; 3 = alignment\n+\n+(define_expand \"cmpstrsi\"\n+  [(match_operand:HI 0 \"\" \"\")\n+   (match_operand 1 \"ap_operand\" \"\")\n+   (match_operand 2 \"ap_operand\" \"\")\n+   (match_operand 3 \"\" \"\")\n+   ]\n+  \"TARGET_A24\"\n+  \"if (m32c_expand_cmpstr(operands)) DONE; FAIL;\"\n+  )\n+\n+;; 0 = string1\n+;; 1 = string2\n+\n+(define_insn \"cmpstrhi_op\"\n+  [(set (reg:CC FLG_REGNO)\n+\t(compare:CC (mem:BLK (match_operand:PSI 0 \"ap_operand\" \"Ra0\"))\n+\t\t    (mem:BLK (match_operand:PSI 1 \"ap_operand\" \"Ra1\"))))\n+   (clobber (match_operand:PSI 2 \"ap_operand\" \"=0\"))\n+   (clobber (match_operand:PSI 3 \"ap_operand\" \"=1\"))]\n+  \"TARGET_A24\"\n+  \"scmpu.b\\t; flags := strcmp(*%0,*%1)\"\n+  [(set_attr \"flags\" \"oszc\")]\n+  )\n+\n+\n+\n+;; Note that SMOVU leaves the address registers pointing *after*\n+;; the NUL at the end of the string.  This is not what gcc expects; it\n+;; expects the address registers to point *at* the NUL.  The expander\n+;; must emit a suitable add insn.\n+\n+;; 0 = target: set to &NUL in dest\n+;; 1 = destination (mem:BLK ...)\n+;; 2 = source (mem:BLK ...)\n+\n+(define_expand \"movstr\"\n+  [(match_operand 0 \"\" \"\")\n+   (match_operand 1 \"ap_operand\" \"\")\n+   (match_operand 2 \"ap_operand\" \"\")\n+   ]\n+  \"TARGET_A24\"\n+  \"if (m32c_expand_movstr(operands)) DONE; FAIL;\"\n+  )\n+\n+;; 0 = dest (out)\n+;; 1 = src (out) (clobbered)\n+;; 2 = dest (in)\n+;; 3 = src (in)\n+(define_insn \"movstr_op\"\n+  [(set (mem:BLK (match_operand:PSI 2 \"ap_operand\" \"0\"))\n+\t(mem:BLK (match_operand:PSI 3 \"ap_operand\" \"1\")))\n+   (set (match_operand:PSI 0 \"ap_operand\" \"=Ra1\")\n+\t(plus:PSI (match_dup 2)\n+\t\t  (unspec:PSI [(const_int 0)] UNS_SMOVU)))\n+   (set (match_operand:PSI 1 \"ap_operand\" \"=Ra0\")\n+\t(plus:PSI (match_dup 3)\n+\t\t  (unspec:PSI [(const_int 0)] UNS_SMOVU)))]\n+  \"TARGET_A24\"\n+  \"smovu.b\\t; while (*%2++ := *%3++) != 0\"\n+  [(set_attr \"flags\" \"*\")]\n+  )\n+  "}, {"sha": "ad8a5d655cbbfe8af95307449489a0e29ea37aa7", "filename": "gcc/config/m32c/cond.md", "status": "modified", "additions": 138, "deletions": 27, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Fcond.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Fcond.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fcond.md?ref=07127a0a3b7a73f24105b80dd63c12d38fe84bf1", "patch": "@@ -32,41 +32,152 @@\n ; right flags already.  For example, a mov followed by a \"cmp *,0\" is\n ; redundant; the move already set the Z flag.\n \n-(define_insn \"cbranchqi4\"\n+(define_insn_and_split \"cbranch<mode>4\"\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"m32c_cmp_operator\"\n-\t\t\t      [(match_operand:QI 1 \"mrai_operand\" \"RqiSd,RqiSd,?Rmm,?Rmm\")\n-\t\t\t       (match_operand:QI 2 \"mrai_operand\" \"iRqiSd,?Rmm,iRqiSd,?Rmm\")])\n+\t\t\t      [(match_operand:QHPSI 1 \"mra_operand\" \"RraSd\")\n+\t\t\t       (match_operand:QHPSI 2 \"mrai_operand\" \"iRraSd\")])\n               (label_ref (match_operand 3 \"\" \"\"))\n \t      (pc)))]\n   \"\"\n-  \"cmp.b\\t%2,%1\\n\\tj%C0\\t1f\\n\\tjmp.a\\t%l3\\n1:\"\n-;  \"cmp.b\\t%2,%1\\n\\tj%c0\\t%l3\"\n-  [(set_attr \"flags\" \"oszc,oszc,oszc,oszc\")]\n+  \"#\"\n+  \"\"\n+  [(set (reg:CC FLG_REGNO)\n+\t(compare (match_dup 1)\n+\t\t (match_dup 2)))\n+   (set (pc) (if_then_else (match_dup 4)\n+\t\t\t   (label_ref (match_dup 3))\n+\t\t\t   (pc)))]\n+  \"operands[4] = m32c_cmp_flg_0 (operands[0]);\"\n   )\n \n-(define_insn \"cbranchhi4\"\n-  [(set (pc) (if_then_else\n-\t      (match_operator 0 \"m32c_cmp_operator\"\n-\t\t\t      [(match_operand:HI 1 \"mrai_operand\" \"Rhi,?Sd,Rhi,?Sd,?Rmm,?Rmm\")\n-\t\t\t       (match_operand:HI 2 \"mrai_operand\" \"iRhiSd,iRhiSd,?Rmm,?Rmm,iRhiSd,?Rmm\")])\n-              (label_ref (match_operand 3 \"\" \"\"))\n-\t      (pc)))]\n+(define_insn \"stzx_16\"\n+  [(set (match_operand:QI 0 \"mrai_operand\" \"=R0w,R0w,R0w\")\n+\t(if_then_else:QI (eq (reg:CC FLG_REGNO) (const_int 0))\n+\t\t\t (match_operand:QI 1 \"const_int_operand\" \"i,i,0\")\n+\t\t\t (match_operand:QI 2 \"const_int_operand\" \"i,0,i\")))]\n+  \"TARGET_A16\"\n+  \"@\n+   stzx\\t%1,%2,%0\n+   stz\\t%1,%0\n+   stnz\\t%2,%0\")\n+\n+(define_insn \"stzx_24_<mode>\"\n+  [(set (match_operand:QHI 0 \"mrai_operand\" \"=RraSd,RraSd,RraSd\")\n+\t(if_then_else:QHI (eq (reg:CC FLG_REGNO) (const_int 0))\n+\t\t\t (match_operand:QHI 1 \"const_int_operand\" \"i,i,0\")\n+\t\t\t (match_operand:QHI 2 \"const_int_operand\" \"i,0,i\")))]\n+  \"TARGET_A24\"\n+  \"@\n+   stzx.<bwl>\\t%1,%2,%0\n+   stz.<bwl>\\t%1,%0\n+   stnz.<bwl>\\t%2,%0\")\n+\n+(define_insn_and_split \"stzx_reversed\"\n+  [(set (match_operand 0 \"m32c_r0_operand\" \"\")\n+\t(if_then_else (ne (reg:CC FLG_REGNO) (const_int 0))\n+\t\t\t (match_operand 1 \"const_int_operand\" \"\")\n+\t\t\t (match_operand 2 \"const_int_operand\" \"\")))]\n+  \"TARGET_A24 || GET_MODE (operands[0]) == QImode\"\n+  \"#\"\n+  \"\"\n+  [(set (match_dup 0)\n+\t(if_then_else (eq (reg:CC FLG_REGNO) (const_int 0))\n+\t\t      (match_dup 2)\n+\t\t      (match_dup 1)))]\n   \"\"\n-  \"cmp.w\\t%2,%1\\n\\tj%C0\\t1f\\n\\tjmp.a\\t%l3\\n1:\"\n-;  \"cmp.w\\t%2,%1\\n\\tj%c0\\t%l3\"\n-  [(set_attr \"flags\" \"oszc,oszc,oszc,oszc,oszc,oszc\")]\n   )\n \n-(define_insn \"cbranchpsi4\"\n-  [(set (pc) (if_then_else\n-\t      (match_operator 0 \"m32c_cmp_operator\"\n-\t\t\t      [(match_operand:PSI 1 \"mrai_operand\" \"RsiSd,RsiSd,?Rmm,?Rmm\")\n-\t\t\t       (match_operand:PSI 2 \"mrai_operand\" \"iRsiSd,?Rmm,iRsiSd,?Rmm\")])\n-              (label_ref (match_operand 3 \"\" \"\"))\n-\t      (pc)))]\n+\n+(define_insn \"cmp<mode>\"\n+  [(set (reg:CC FLG_REGNO)\n+\t(compare (match_operand:QHPSI 0 \"mra_operand\" \"RraSd\")\n+\t\t (match_operand:QHPSI 1 \"mrai_operand\" \"RraSdi\")))]\n+  \"\"\n+  \"cmp.<bwl>\\t%1,%0\")\n+\n+(define_insn \"b<code>\"\n+  [(set (pc)\n+        (if_then_else (any_cond (reg:CC FLG_REGNO)\n+\t\t\t\t(const_int 0))\n+                      (label_ref (match_operand 0 \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"j<code>\\t%l0\"\n+)\n+\n+;; m32c_conditional_register_usage changes the setcc_gen_code array to\n+;; point to the _24 variants if needed.\n+\n+(define_insn \"s<code>\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=Rqi\")\n+\t(any_cond:QI (reg:CC FLG_REGNO) (const_int 0)))]\n+  \"TARGET_A16\"\n+  \"* return m32c_scc_pattern(operands, <CODE>);\")\n+\n+(define_insn \"s<code>_24\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd\")\n+\t(any_cond:HI (reg:CC FLG_REGNO) (const_int 0)))]\n   \"TARGET_A24\"\n-  \"cmp.l\\t%2,%1\\n\\tj%C0\\t1f\\n\\tjmp.a\\t%l3\\n1:\"\n-;  \"cmp.l\\t%2,%1\\n\\tj%c0\\t%l3\"\n-  [(set_attr \"flags\" \"oszc,oszc,oszc,oszc\")]\n-  )\n+  \"sc<code>\\t%0\")\n+\n+(define_expand \"movqicc\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (if_then_else:QI (match_operand 1 \"m32c_eqne_operator\" \"\")\n+                         (match_operand:QI 2 \"const_int_operand\" \"\")\n+                         (match_operand:QI 3 \"const_int_operand\" \"\")))]\n+  \"\"\n+  \"if (m32c_expand_movcc(operands))\n+     FAIL;\n+   DONE;\"\n+)\n+\n+(define_expand \"movhicc\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"\")\n+        (if_then_else:HI (match_operand 1 \"m32c_eqne_operator\" \"\")\n+                         (match_operand:HI 2 \"const_int_operand\" \"\")\n+                         (match_operand:HI 3 \"const_int_operand\" \"\")))]\n+  \"TARGET_A24\"\n+  \"if (m32c_expand_movcc(operands))\n+     FAIL;\n+   DONE;\"\n+)\n+\n+\n+;; CMP opcodes subtract two values, set the flags, and discard the\n+;; value.  This pattern recovers the sign of the discarded value based\n+;; on the flags.  Operand 0 is set to -1, 0, or 1.  This is used for\n+;; the cmpstr pattern.  For optimal code, this should be removed if\n+;; followed by a suitable CMP insn, as SCMPU sets the flags correctly\n+;; already (see the peephole following).  This pattern is 7 bytes and\n+;; 5 cycles.  If you don't need specific values, a 5/4 pattern can be\n+;; made with SCGT and BMLT to set the appropriate bits.\n+\n+(define_insn \"cond_to_int\"\n+  [(set (match_operand:HI 0 \"mra_qi_operand\" \"=Rqi\")\n+\t(if_then_else:HI (lt (reg:CC FLG_REGNO) (const_int 0))\n+\t\t\t (const_int -1)\n+\t\t\t (if_then_else:HI (eq (reg:CC FLG_REGNO) (const_int 0))\n+\t\t\t\t\t  (const_int 0)\n+\t\t\t\t\t  (const_int -1))))]\n+  \"TARGET_A24\"\n+  \"sceq\\t%0\\n\\tbmgt\\t1,%h0\\n\\tdec.w\\t%0\"\n+  [(set_attr \"flags\" \"sz\")]\n+  )  \n+\n+;; A cond_to_int followed by a compare against zero is essentially a no-op.\n+\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"mra_qi_operand\" \"\")\n+\t(if_then_else:HI (lt (reg:CC FLG_REGNO) (const_int 0))\n+\t\t\t (const_int -1)\n+\t\t\t (if_then_else:HI (eq (reg:CC FLG_REGNO) (const_int 0))\n+\t\t\t\t\t  (const_int 0)\n+\t\t\t\t\t  (const_int -1))))\n+   (set (reg:CC FLG_REGNO)\n+\t(compare (match_operand:HI 1 \"mra_qi_operand\" \"\")\n+\t\t (const_int 0)))\n+   ]\n+  \"rtx_equal_p(operands[0], operands[1])\"\n+  [(const_int 1)]\n+  \"\")"}, {"sha": "eb977961bd91a7a0fe64f9851365b2bc888a14ba", "filename": "gcc/config/m32c/m32c-protos.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h?ref=07127a0a3b7a73f24105b80dd63c12d38fe84bf1", "patch": "@@ -58,8 +58,16 @@ rtx  m32c_function_value (tree, tree);\n \n int  m32c_cannot_change_mode_class (MM, MM, int);\n int  m32c_class_max_nregs (int, MM);\n+rtx  m32c_cmp_flg_0 (rtx);\n rtx  m32c_eh_return_stackadj_rtx (void);\n void m32c_emit_eh_epilogue (rtx);\n+int  m32c_expand_cmpstr (rtx *);\n+int  m32c_expand_insv (rtx *);\n+int  m32c_expand_movcc (rtx *);\n+int  m32c_expand_movmemhi (rtx *);\n+int  m32c_expand_movstr (rtx *);\n+void m32c_expand_neg_mulpsi3 (rtx *);\n+int  m32c_expand_setmemhi (rtx *);\n int  m32c_extra_constraint_p (rtx, char, const char *);\n int  m32c_extra_constraint_p2 (rtx, char, const char *);\n int  m32c_hard_regno_nregs (int, MM);\n@@ -86,6 +94,7 @@ int  m32c_reg_ok_for_base_p (rtx, int);\n int  m32c_register_move_cost (MM, int, int);\n MM   m32c_regno_reg_class (int);\n rtx  m32c_return_addr_rtx (int);\n+const char *m32c_scc_pattern (rtx *, RTX_CODE);\n int  m32c_secondary_reload_class (int, MM, rtx);\n int  m32c_split_move (rtx *, MM, int);\n int  m32c_split_psi_p (rtx *);"}, {"sha": "75fc3bc376346c767a002cad2dd76815d9406b6d", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 540, "deletions": 21, "changes": 561, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=07127a0a3b7a73f24105b80dd63c12d38fe84bf1", "patch": "@@ -412,7 +412,7 @@ m32c_override_options (void)\n \terror (\"invalid target memregs value '%d'\", target_memregs);\n     }\n   else\n-    target_memregs = \"16\";\n+    target_memregs = 16;\n }\n \n /* Defining data structures for per-function information */\n@@ -490,7 +490,6 @@ static struct\n void\n m32c_conditional_register_usage (void)\n {\n-  int memregs;\n   int i;\n \n   if (0 <= target_memregs && target_memregs <= 16)\n@@ -564,8 +563,10 @@ m32c_modes_tieable_p (enum machine_mode m1, enum machine_mode m2)\n   if (GET_MODE_SIZE (m1) == GET_MODE_SIZE (m2))\n     return 1;\n \n+#if 0\n   if (m1 == QImode || m2 == QImode)\n     return 0;\n+#endif\n \n   return 1;\n }\n@@ -615,10 +616,10 @@ m32c_reg_class_from_constraint (char c ATTRIBUTE_UNUSED, const char *s)\n     return FB_REGS;\n   if (memcmp (s, \"Rsb\", 3) == 0)\n     return SB_REGS;\n-  if (memcmp (s, \"Rcr\", 3) == 0 && TARGET_A16)\n-    return CR_REGS;\n-  if (memcmp (s, \"Rcl\", 3) == 0 && TARGET_A24)\n-    return CR_REGS;\n+  if (memcmp (s, \"Rcr\", 3) == 0)\n+    return TARGET_A16 ? CR_REGS : NO_REGS;\n+  if (memcmp (s, \"Rcl\", 3) == 0)\n+    return TARGET_A24 ? CR_REGS : NO_REGS;\n   if (memcmp (s, \"R0w\", 3) == 0)\n     return R0_REGS;\n   if (memcmp (s, \"R1w\", 3) == 0)\n@@ -637,12 +638,16 @@ m32c_reg_class_from_constraint (char c ATTRIBUTE_UNUSED, const char *s)\n     return HL_REGS;\n   if (memcmp (s, \"R23\", 3) == 0)\n     return R23_REGS;\n+  if (memcmp (s, \"Ra0\", 3) == 0)\n+    return A0_REGS;\n+  if (memcmp (s, \"Ra1\", 3) == 0)\n+    return A1_REGS;\n   if (memcmp (s, \"Raa\", 3) == 0)\n     return A_REGS;\n-  if (memcmp (s, \"Raw\", 3) == 0 && TARGET_A16)\n-    return A_REGS;\n-  if (memcmp (s, \"Ral\", 3) == 0 && TARGET_A24)\n-    return A_REGS;\n+  if (memcmp (s, \"Raw\", 3) == 0)\n+    return TARGET_A16 ? A_REGS : NO_REGS;\n+  if (memcmp (s, \"Ral\", 3) == 0)\n+    return TARGET_A24 ? A_REGS : NO_REGS;\n   if (memcmp (s, \"Rqi\", 3) == 0)\n     return QI_REGS;\n   if (memcmp (s, \"Rad\", 3) == 0)\n@@ -677,6 +682,12 @@ m32c_reg_class_from_constraint (char c ATTRIBUTE_UNUSED, const char *s)\n   if (memcmp (s, \"Rpa\", 3) == 0)\n     return NO_REGS;\n \n+  if (*s == 'R')\n+    {\n+      fprintf(stderr, \"unrecognized R constraint: %.3s\\n\", s);\n+      gcc_unreachable();\n+    }\n+\n   return NO_REGS;\n }\n \n@@ -914,11 +925,25 @@ m32c_const_ok_for_constraint_p (HOST_WIDE_INT value,\n       int b = exact_log2 (value);\n       return (b >= 1 && b <= 8);\n     }\n+  if (memcmp (str, \"Imb\", 3) == 0)\n+    {\n+      int b = exact_log2 ((value ^ 0xff) & 0xff);\n+      return (b >= 1 && b <= 8);\n+    }\n   if (memcmp (str, \"Ilw\", 3) == 0)\n     {\n       int b = exact_log2 (value);\n       return (b >= 1 && b <= 16);\n     }\n+  if (memcmp (str, \"Imw\", 3) == 0)\n+    {\n+      int b = exact_log2 ((value ^ 0xffff) & 0xffff);\n+      return (b >= 1 && b <= 16);\n+    }\n+  if (memcmp (str, \"I00\", 3) == 0)\n+    {\n+      return (value == 0);\n+    }\n   return 0;\n }\n \n@@ -937,6 +962,12 @@ m32c_extra_constraint_p2 (rtx value, char c ATTRIBUTE_UNUSED, const char *str)\n \treturn 1;\n       if (RTX_IS (\"ms\") || RTX_IS (\"m+si\"))\n \treturn 1;\n+      if (RTX_IS (\"m++rii\"))\n+\t{\n+\t  if (REGNO (patternr[3]) == FB_REGNO\n+\t      && INTVAL (patternr[4]) == 0)\n+\t    return 1;\n+\t}\n       if (RTX_IS (\"mr\"))\n \tr = patternr[1];\n       else if (RTX_IS (\"m+ri\") || RTX_IS (\"m+rs\") || RTX_IS (\"m+r+si\"))\n@@ -980,6 +1011,12 @@ m32c_extra_constraint_p2 (rtx value, char c ATTRIBUTE_UNUSED, const char *str)\n \t       && (IS_REG (patternr[1], SB_REGNO)))\n \t      || (RTX_IS (\"m+ri\") && (IS_REG (patternr[2], SB_REGNO))));\n     }\n+  else if (memcmp (str, \"Sp\", 2) == 0)\n+    {\n+      /* Absolute addresses 0..0x1fff used for bit addressing (I/O ports) */\n+      return (RTX_IS (\"mi\")\n+\t      && !(INTVAL (patternr[1]) & ~0x1fff));\n+    }\n   else if (memcmp (str, \"S1\", 2) == 0)\n     {\n       return r1h_operand (value, QImode);\n@@ -1683,6 +1720,32 @@ m32c_initialize_trampoline (rtx tramp, rtx function, rtx chainval)\n #undef A0\n }\n \n+/* Implicit Calls to Library Routines */\n+\n+#undef TARGET_INIT_LIBFUNCS\n+#define TARGET_INIT_LIBFUNCS m32c_init_libfuncs\n+static void\n+m32c_init_libfuncs (void)\n+{\n+  if (TARGET_A24)\n+    {\n+      /* We do this because the M32C has an HImode operand, but the\n+\t M16C has an 8 bit operand.  Since gcc looks at the match data\n+\t and not the expanded rtl, we have to reset the array so that\n+\t the right modes are found. */\n+      setcc_gen_code[EQ] = CODE_FOR_seq_24;\n+      setcc_gen_code[NE] = CODE_FOR_sne_24;\n+      setcc_gen_code[GT] = CODE_FOR_sgt_24;\n+      setcc_gen_code[GE] = CODE_FOR_sge_24;\n+      setcc_gen_code[LT] = CODE_FOR_slt_24;\n+      setcc_gen_code[LE] = CODE_FOR_sle_24;\n+      setcc_gen_code[GTU] = CODE_FOR_sgtu_24;\n+      setcc_gen_code[GEU] = CODE_FOR_sgeu_24;\n+      setcc_gen_code[LTU] = CODE_FOR_sltu_24;\n+      setcc_gen_code[LEU] = CODE_FOR_sleu_24;\n+    }\n+}\n+\n /* Addressing Modes */\n \n /* Used by GO_IF_LEGITIMATE_ADDRESS.  The r8c/m32c family supports a\n@@ -2030,6 +2093,107 @@ m32c_memory_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n   return COSTS_N_INSNS (10);\n }\n \n+/* Here we try to describe when we use multiple opcodes for one RTX so\n+   that gcc knows when to use them.  */\n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS m32c_rtx_costs\n+static bool\n+m32c_rtx_costs (rtx x, int code, int outer_code, int *total)\n+{\n+  switch (code)\n+    {\n+    case REG:\n+      if (REGNO (x) >= MEM0_REGNO && REGNO (x) <= MEM7_REGNO)\n+\t*total += COSTS_N_INSNS (500);\n+      else\n+\t*total += COSTS_N_INSNS (1);\n+      return true;\n+\n+    case ASHIFT:\n+    case LSHIFTRT:\n+    case ASHIFTRT:\n+      if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n+\t{\n+\t  /* mov.b r1l, r1h */\n+\t  *total +=  COSTS_N_INSNS (1);\n+\t  return true;\n+\t}\n+      if (INTVAL (XEXP (x, 1)) > 8\n+\t  || INTVAL (XEXP (x, 1)) < -8)\n+\t{\n+\t  /* mov.b #N, r1l */\n+\t  /* mov.b r1l, r1h */\n+\t  *total +=  COSTS_N_INSNS (2);\n+\t  return true;\n+\t}\n+      return true;\n+\n+    case LE:\n+    case LEU:\n+    case LT:\n+    case LTU:\n+    case GT:\n+    case GTU:\n+    case GE:\n+    case GEU:\n+    case NE:\n+    case EQ:\n+      if (outer_code == SET)\n+\t{\n+\t  *total += COSTS_N_INSNS (2);\n+\t  return true;\n+\t}\n+      break;\n+\n+    case ZERO_EXTRACT:\n+      {\n+\trtx dest = XEXP (x, 0);\n+\trtx addr = XEXP (dest, 0);\n+\tswitch (GET_CODE (addr))\n+\t  {\n+\t  case CONST_INT:\n+\t    *total += COSTS_N_INSNS (1);\n+\t    break;\n+\t  case SYMBOL_REF:\n+\t    *total += COSTS_N_INSNS (3);\n+\t    break;\n+\t  default:\n+\t    *total += COSTS_N_INSNS (2);\n+\t    break;\n+\t  }\n+\treturn true;\n+      }\n+      break;\n+\n+    default:\n+      /* Reasonable default.  */\n+      if (TARGET_A16 && GET_MODE(x) == SImode)\n+\t*total += COSTS_N_INSNS (2);\n+      break;\n+    }\n+  return false;\n+}\n+\n+#undef TARGET_ADDRESS_COST\n+#define TARGET_ADDRESS_COST m32c_address_cost\n+static int\n+m32c_address_cost (rtx addr)\n+{\n+  /*  fprintf(stderr, \"\\naddress_cost\\n\");\n+      debug_rtx(addr);*/\n+  switch (GET_CODE (addr))\n+    {\n+    case CONST_INT:\n+      return COSTS_N_INSNS(1);\n+    case SYMBOL_REF:\n+      return COSTS_N_INSNS(3);\n+    case REG:\n+      return COSTS_N_INSNS(2);\n+    default:\n+      return 0;\n+    }\n+}\n+\n /* Defining the Output Assembler Language */\n \n /* The Overall Framework of an Assembler File */\n@@ -2111,6 +2275,7 @@ const conversions[] = {\n   { 'X', \"i\", \"#0\" },\n   { 'm', \"i\", \"#0\" },\n   { 'b', \"i\", \"#0\" },\n+  { 'B', \"i\", \"0\" },\n   { 'p', \"i\", \"0\" },\n \n   { 0, 0, 0 }\n@@ -2253,6 +2418,39 @@ m32c_print_operand (FILE * file, rtx x, int code)\n       x = m32c_subreg (HImode, x, SImode, 2);\n       code = 0;\n     }\n+  if (code == 'h' && GET_MODE (x) == HImode)\n+    {\n+      x = m32c_subreg (QImode, x, HImode, 0);\n+      code = 0;\n+    }\n+  if (code == 'H' && GET_MODE (x) == HImode)\n+    {\n+      /* We can't actually represent this as an rtx.  Do it here.  */\n+      if (GET_CODE (x) == REG)\n+\t{\n+\t  switch (REGNO (x))\n+\t    {\n+\t    case R0_REGNO:\n+\t      fputs (\"r0h\", file);\n+\t      return;\n+\t    case R1_REGNO:\n+\t      fputs (\"r1h\", file);\n+\t      return;\n+\t    default:\n+\t      gcc_unreachable();\n+\t    }\n+\t}\n+      /* This should be a MEM.  */\n+      x = m32c_subreg (QImode, x, HImode, 1);\n+      code = 0;\n+    }\n+  /* This is for BMcond, which always wants word register names.  */\n+  if (code == 'h' && GET_MODE (x) == QImode)\n+    {\n+      if (GET_CODE (x) == REG)\n+\tx = gen_rtx_REG (HImode, REGNO (x));\n+      code = 0;\n+    }\n   /* 'x' and 'X' need to be ignored for non-immediates.  */\n   if ((code == 'x' || code == 'X') && GET_CODE (x) != CONST_INT)\n     code = 0;\n@@ -2284,8 +2482,17 @@ m32c_print_operand (FILE * file, rtx x, int code)\n \t\t  switch (code)\n \t\t    {\n \t\t    case 'b':\n-\t\t      /* Bit position.  */\n-\t\t      fprintf (file, \"%d\", (int) exact_log2 (INTVAL (r)));\n+\t\t    case 'B':\n+\t\t      {\n+\t\t\tint v = INTVAL (r);\n+\t\t\tint i = (int) exact_log2 (v);\n+\t\t\tif (i == -1)\n+\t\t\t  i = (int) exact_log2 ((v ^ 0xffff) & 0xffff);\n+\t\t\tif (i == -1)\n+\t\t\t  i = (int) exact_log2 ((v ^ 0xff) & 0xff);\n+\t\t\t/* Bit position.  */\n+\t\t\tfprintf (file, \"%d\", i);\n+\t\t      }\n \t\t      break;\n \t\t    case 'x':\n \t\t      /* Unsigned byte.  */\n@@ -2838,6 +3045,184 @@ m32c_split_move (rtx * operands, enum machine_mode mode, int split_all)\n   return rv;\n }\n \n+/* The m32c has a number of opcodes that act like memcpy, strcmp, and\n+   the like.  For the R8C they expect one of the addresses to be in\n+   R1L:An so we need to arrange for that.  Otherwise, it's just a\n+   matter of picking out the operands we want and emitting the right\n+   pattern for them.  All these expanders, which correspond to\n+   patterns in blkmov.md, must return nonzero if they expand the insn,\n+   or zero if they should FAIL.  */\n+\n+/* This is a memset() opcode.  All operands are implied, so we need to\n+   arrange for them to be in the right registers.  The opcode wants\n+   addresses, not [mem] syntax.  $0 is the destination (MEM:BLK), $1\n+   the count (HI), and $2 the value (QI).  */\n+int\n+m32c_expand_setmemhi(rtx *operands)\n+{\n+  rtx desta, count, val;\n+  rtx desto, counto;\n+\n+  desta = XEXP (operands[0], 0);\n+  count = operands[1];\n+  val = operands[2];\n+\n+  desto = gen_reg_rtx (Pmode);\n+  counto = gen_reg_rtx (HImode);\n+\n+  if (GET_CODE (desta) != REG\n+      || REGNO (desta) < FIRST_PSEUDO_REGISTER)\n+    desta = copy_to_mode_reg (Pmode, desta);\n+\n+  /* This looks like an arbitrary restriction, but this is by far the\n+     most common case.  For counts 8..14 this actually results in\n+     smaller code with no speed penalty because the half-sized\n+     constant can be loaded with a shorter opcode.  */\n+  if (GET_CODE (count) == CONST_INT\n+      && GET_CODE (val) == CONST_INT\n+      && ! (INTVAL (count) & 1)\n+      && (INTVAL (count) > 1)\n+      && (INTVAL (val) <= 7 && INTVAL (val) >= -8))\n+    {\n+      unsigned v = INTVAL (val) & 0xff;\n+      v = v | (v << 8);\n+      count = copy_to_mode_reg (HImode, GEN_INT (INTVAL (count) / 2));\n+      val = copy_to_mode_reg (HImode, GEN_INT (v));\n+      if (TARGET_A16)\n+\temit_insn (gen_setmemhi_whi_op (desto, counto, val, desta, count));\n+      else\n+\temit_insn (gen_setmemhi_wpsi_op (desto, counto, val, desta, count));\n+      return 1;\n+    }\n+\n+  /* This is the generalized memset() case.  */\n+  if (GET_CODE (val) != REG\n+      || REGNO (val) < FIRST_PSEUDO_REGISTER)\n+    val = copy_to_mode_reg (QImode, val);\n+\n+  if (GET_CODE (count) != REG\n+      || REGNO (count) < FIRST_PSEUDO_REGISTER)\n+    count = copy_to_mode_reg (HImode, count);\n+\n+  if (TARGET_A16)\n+    emit_insn (gen_setmemhi_bhi_op (desto, counto, val, desta, count));\n+  else\n+    emit_insn (gen_setmemhi_bpsi_op (desto, counto, val, desta, count));\n+\n+  return 1;\n+}\n+\n+/* This is a memcpy() opcode.  All operands are implied, so we need to\n+   arrange for them to be in the right registers.  The opcode wants\n+   addresses, not [mem] syntax.  $0 is the destination (MEM:BLK), $1\n+   is the source (MEM:BLK), and $2 the count (HI).  */\n+int\n+m32c_expand_movmemhi(rtx *operands)\n+{\n+  rtx desta, srca, count;\n+  rtx desto, srco, counto;\n+\n+  desta = XEXP (operands[0], 0);\n+  srca = XEXP (operands[1], 0);\n+  count = operands[2];\n+\n+  desto = gen_reg_rtx (Pmode);\n+  srco = gen_reg_rtx (Pmode);\n+  counto = gen_reg_rtx (HImode);\n+\n+  if (GET_CODE (desta) != REG\n+      || REGNO (desta) < FIRST_PSEUDO_REGISTER)\n+    desta = copy_to_mode_reg (Pmode, desta);\n+\n+  if (GET_CODE (srca) != REG\n+      || REGNO (srca) < FIRST_PSEUDO_REGISTER)\n+    srca = copy_to_mode_reg (Pmode, srca);\n+\n+  /* Similar to setmem, but we don't need to check the value.  */\n+  if (GET_CODE (count) == CONST_INT\n+      && ! (INTVAL (count) & 1)\n+      && (INTVAL (count) > 1))\n+    {\n+      count = copy_to_mode_reg (HImode, GEN_INT (INTVAL (count) / 2));\n+      if (TARGET_A16)\n+\temit_insn (gen_movmemhi_whi_op (desto, srco, counto, desta, srca, count));\n+      else\n+\temit_insn (gen_movmemhi_wpsi_op (desto, srco, counto, desta, srca, count));\n+      return 1;\n+    }\n+\n+  /* This is the generalized memset() case.  */\n+  if (GET_CODE (count) != REG\n+      || REGNO (count) < FIRST_PSEUDO_REGISTER)\n+    count = copy_to_mode_reg (HImode, count);\n+\n+  if (TARGET_A16)\n+    emit_insn (gen_movmemhi_bhi_op (desto, srco, counto, desta, srca, count));\n+  else\n+    emit_insn (gen_movmemhi_bpsi_op (desto, srco, counto, desta, srca, count));\n+\n+  return 1;\n+}\n+\n+/* This is a stpcpy() opcode.  $0 is the destination (MEM:BLK) after\n+   the copy, which should point to the NUL at the end of the string,\n+   $1 is the destination (MEM:BLK), and $2 is the source (MEM:BLK).\n+   Since our opcode leaves the destination pointing *after* the NUL,\n+   we must emit an adjustment.  */\n+int\n+m32c_expand_movstr(rtx *operands)\n+{\n+  rtx desta, srca;\n+  rtx desto, srco;\n+\n+  desta = XEXP (operands[1], 0);\n+  srca = XEXP (operands[2], 0);\n+\n+  desto = gen_reg_rtx (Pmode);\n+  srco = gen_reg_rtx (Pmode);\n+\n+  if (GET_CODE (desta) != REG\n+      || REGNO (desta) < FIRST_PSEUDO_REGISTER)\n+    desta = copy_to_mode_reg (Pmode, desta);\n+\n+  if (GET_CODE (srca) != REG\n+      || REGNO (srca) < FIRST_PSEUDO_REGISTER)\n+    srca = copy_to_mode_reg (Pmode, srca);\n+\n+  emit_insn (gen_movstr_op (desto, srco, desta, srca));\n+  /* desto ends up being a1, which allows this type of add through MOVA.  */\n+  emit_insn (gen_addpsi3 (operands[0], desto, GEN_INT (-1)));\n+\n+  return 1;\n+}\n+\n+/* This is a strcmp() opcode.  $0 is the destination (HI) which holds\n+   <=>0 depending on the comparison, $1 is one string (MEM:BLK), and\n+   $2 is the other (MEM:BLK).  We must do the comparison, and then\n+   convert the flags to a signed integer result.  */\n+int\n+m32c_expand_cmpstr(rtx *operands)\n+{\n+  rtx src1a, src2a;\n+\n+  src1a = XEXP (operands[1], 0);\n+  src2a = XEXP (operands[2], 0);\n+\n+  if (GET_CODE (src1a) != REG\n+      || REGNO (src1a) < FIRST_PSEUDO_REGISTER)\n+    src1a = copy_to_mode_reg (Pmode, src1a);\n+\n+  if (GET_CODE (src2a) != REG\n+      || REGNO (src2a) < FIRST_PSEUDO_REGISTER)\n+    src2a = copy_to_mode_reg (Pmode, src2a);\n+\n+  emit_insn (gen_cmpstrhi_op (src1a, src2a, src1a, src2a));\n+  emit_insn (gen_cond_to_int (operands[0]));\n+\n+  return 1;\n+}\n+\n+\n typedef rtx (*shift_gen_func)(rtx, rtx, rtx);\n \n static shift_gen_func\n@@ -2857,11 +3242,14 @@ shift_gen_func_for (int mode, int code)\n   GFF(SImode,  ASHIFTRT, TARGET_A16 ? gen_ashrsi3_16 : gen_ashrsi3_24);\n   GFF(SImode,  LSHIFTRT, TARGET_A16 ? gen_lshrsi3_16 : gen_lshrsi3_24);\n #undef GFF\n+  gcc_unreachable ();\n }\n \n /* The m32c only has one shift, but it takes a signed count.  GCC\n    doesn't want this, so we fake it by negating any shift count when\n-   we're pretending to shift the other way.  */\n+   we're pretending to shift the other way.  Also, the shift count is\n+   limited to -8..8.  It's slightly better to use two shifts for 9..15\n+   than to load the count into r1h, so we do that too.  */\n int\n m32c_prepare_shift (rtx * operands, int scale, int shift_code)\n {\n@@ -2971,23 +3359,154 @@ m32c_expand_neg_mulpsi3 (rtx * operands)\n {\n   /* operands: a = b * i */\n   rtx temp1; /* b as SI */\n-  rtx temp2; /* -b as SI */\n-  rtx temp3; /* -b as PSI */\n-  rtx scale;\n+  rtx scale /* i as SI */;\n+  rtx temp2; /* a*b as SI */\n \n   temp1 = gen_reg_rtx (SImode);\n   temp2 = gen_reg_rtx (SImode);\n-  temp3 = gen_reg_rtx (PSImode);\n-  scale = GEN_INT (- INTVAL (operands[2]));\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    {\n+      scale = gen_reg_rtx (SImode);\n+      emit_insn (gen_zero_extendpsisi2 (scale, operands[2]));\n+    }\n+  else\n+    scale = copy_to_mode_reg (SImode, operands[2]);\n \n   emit_insn (gen_zero_extendpsisi2 (temp1, operands[1]));\n-  emit_insn (gen_negsi2 (temp2, temp1));\n-  emit_insn (gen_truncsipsi2 (temp3, temp2));\n-  emit_insn (gen_mulpsi3 (operands[0], temp3, scale));\n+  temp2 = expand_simple_binop (SImode, MULT, temp1, scale, temp2, 1, OPTAB_LIB);\n+  emit_insn (gen_truncsipsi2 (operands[0], temp2));\n }\n \n /* Pattern Output Functions */\n \n+/* Returns a (OP (reg:CC FLG_REGNO) (const_int 0)) from some other\n+   match_operand rtx's OP.  */\n+rtx\n+m32c_cmp_flg_0 (rtx cmp)\n+{\n+  return gen_rtx_fmt_ee (GET_CODE (cmp),\n+\t\t\t GET_MODE (cmp),\n+\t\t\t gen_rtx_REG (CCmode, FLG_REGNO),\n+\t\t\t GEN_INT (0));\n+}\n+\n+int\n+m32c_expand_movcc (rtx *operands)\n+{\n+  rtx rel = operands[1];\n+  if (GET_CODE (rel) != EQ && GET_CODE (rel) != NE)\n+    return 1;\n+  if (GET_CODE (operands[2]) != CONST_INT\n+      || GET_CODE (operands[3]) != CONST_INT)\n+    return 1;\n+  emit_insn (gen_cmpqi(XEXP (rel, 0), XEXP (rel, 1)));\n+  if (GET_CODE (rel) == NE)\n+    {\n+      rtx tmp = operands[2];\n+      operands[2] = operands[3];\n+      operands[3] = tmp;\n+    }\n+  if (TARGET_A16)\n+    emit_insn (gen_stzx_16 (operands[0], operands[2], operands[3]));\n+  else if (GET_MODE (operands[0]) == QImode)\n+    emit_insn (gen_stzx_24_qi (operands[0], operands[2], operands[3]));\n+  else\n+    emit_insn (gen_stzx_24_hi (operands[0], operands[2], operands[3]));\n+  return 0;\n+}\n+\n+/* Used for the \"insv\" pattern.  Return nonzero to fail, else done.  */\n+int\n+m32c_expand_insv (rtx *operands)\n+{\n+  rtx op0, src0, p;\n+  int mask;\n+\n+  if (INTVAL (operands[1]) != 1)\n+    return 1;\n+\n+  mask = 1 << INTVAL (operands[2]);\n+\n+  op0 = operands[0];\n+  if (GET_CODE (op0) == SUBREG\n+      && SUBREG_BYTE (op0) == 0)\n+    {\n+      rtx sub = SUBREG_REG (op0);\n+      if (GET_MODE (sub) == HImode || GET_MODE (sub) == QImode)\n+\top0 = sub;\n+    }\n+\n+  if (no_new_pseudos\n+      || (GET_CODE (op0) == MEM && MEM_VOLATILE_P (op0)))\n+    src0 = op0;\n+  else\n+    {\n+      src0 = gen_reg_rtx (GET_MODE (op0));\n+      emit_move_insn (src0, op0);\n+    }\n+\n+  if (GET_MODE (op0) == HImode\n+      && INTVAL (operands[2]) >= 8\n+      && GET_MODE (op0) == MEM)\n+    {\n+      /* We are little endian.  */\n+      rtx new_mem = gen_rtx_MEM (QImode, plus_constant (XEXP (op0, 0), 1));\n+      MEM_COPY_ATTRIBUTES (new_mem, op0);\n+      mask >>= 8;\n+    }\n+\n+  if (INTVAL (operands[3]))\n+    {\n+      if (GET_MODE (op0) == HImode)\n+\tmask ^= 0xffff;\n+      else\n+\tmask ^= 0xff;\n+    }\n+  if (GET_MODE (op0) == HImode)\n+    {\n+      if (mask & 0x8000)\n+\tmask -= 0x10000;\n+    }\n+  else\n+    {\n+      if (mask & 0x80)\n+\tmask -= 0x100;\n+    }\n+\n+  switch (  (INTVAL (operands[3]) ? 4 : 0)\n+\t  + ((GET_MODE (op0) == HImode) ? 2 : 0)\n+\t  + (TARGET_A24 ? 1 : 0))\n+    {\n+    case 0: p = gen_andqi3_16 (op0, src0, GEN_INT (mask)); break;\n+    case 1: p = gen_andqi3_24 (op0, src0, GEN_INT (mask)); break;\n+    case 2: p = gen_andhi3_16 (op0, src0, GEN_INT (mask)); break;\n+    case 3: p = gen_andhi3_24 (op0, src0, GEN_INT (mask)); break;\n+    case 4: p = gen_iorqi3_16 (op0, src0, GEN_INT (mask)); break;\n+    case 5: p = gen_iorqi3_24 (op0, src0, GEN_INT (mask)); break;\n+    case 6: p = gen_iorhi3_16 (op0, src0, GEN_INT (mask)); break;\n+    case 7: p = gen_iorhi3_24 (op0, src0, GEN_INT (mask)); break;\n+    }\n+\n+  emit_insn (p);\n+  return 0;\n+}\n+\n+const char *\n+m32c_scc_pattern(rtx *operands, RTX_CODE code)\n+{\n+  static char buf[30];\n+  if (GET_CODE (operands[0]) == REG\n+      && REGNO (operands[0]) == R0_REGNO)\n+    {\n+      if (code == EQ)\n+\treturn \"stzx\\t#1,#0,r0l\";\n+      if (code == NE)\n+\treturn \"stzx\\t#0,#1,r0l\";\n+    }\n+  sprintf(buf, \"bm%s\\t0,%%h0\\n\\tand.b\\t#1,%%0\", GET_RTX_NAME (code));\n+  return buf;\n+}\n+\n /* Returns TRUE if the current function is a leaf, and thus we can\n    determine which registers an interrupt function really needs to\n    save.  The logic below is mostly about finding the insn sequence"}, {"sha": "3ac81a1ae26c19ca83d588051aa6ab90f5dead5c", "filename": "gcc/config/m32c/m32c.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Fm32c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Fm32c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.h?ref=07127a0a3b7a73f24105b80dd63c12d38fe84bf1", "patch": "@@ -261,10 +261,12 @@ machine_function;\n   { 0x0000000a }, /* R23 - r2 r3 */\\\n   { 0x0000000f }, /* R03 - r0r2 r1r3 */\\\n   { 0x0000000f }, /* DI  - r0r2r1r3 + mems */\\\n+  { 0x00000010 }, /* A0  - a0 */\\\n+  { 0x00000020 }, /* A1  - a1 */\\\n   { 0x00000030 }, /* A   - a0 a1 */\\\n   { 0x000000f0 }, /* AD  - a0 a1 sb fp */\\\n   { 0x000001f0 }, /* PS  - a0 a1 sb fp sp */\\\n-  { 0x0000003f }, /* SI  - r0r2 r1r3 a0a1 */\\\n+  { 0x0000000f }, /* SI  - r0r2 r1r3 a0a1 */\\\n   { 0x0000003f }, /* HI  - r0 r1 r2 r3 a0 a1 */\\\n   { 0x0000003f }, /* RA  - r0..r3 a0 a1 */\\\n   { 0x0000007f }, /* GENERAL */\\\n@@ -297,6 +299,8 @@ enum reg_class\n   R23_REGS,\n   R03_REGS,\n   DI_REGS,\n+  A0_REGS,\n+  A1_REGS,\n   A_REGS,\n   AD_REGS,\n   PS_REGS,\n@@ -335,6 +339,8 @@ enum reg_class\n \"R23_REGS\", \\\n \"R03_REGS\", \\\n \"DI_REGS\", \\\n+\"A0_REGS\", \\\n+\"A1_REGS\", \\\n \"A_REGS\", \\\n \"AD_REGS\", \\\n \"PS_REGS\", \\\n@@ -656,6 +662,8 @@ typedef struct m32c_cumulative_args\n #define MOVE_MAX 4\n #define TRULY_NOOP_TRUNCATION(op,ip) 1\n \n+#define STORE_FLAG_VALUE 1\n+\n /* 16 or 24 bit pointers */\n #define Pmode (TARGET_A16 ? HImode : PSImode)\n #define FUNCTION_MODE QImode"}, {"sha": "f1930d4fdf341d5e044e0ea32964c31a11607dac", "filename": "gcc/config/m32c/m32c.md", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Fm32c.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Fm32c.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.md?ref=07127a0a3b7a73f24105b80dd63c12d38fe84bf1", "patch": "@@ -44,14 +44,35 @@\n    (UNS_EH_EPILOGUE 3)\n    (UNS_PUSHM 4)\n    (UNS_POPM 5)\n+   (UNS_SMOVF 6)\n+   (UNS_SSTR 7)\n+   (UNS_SCMPU 8)\n+   (UNS_SMOVU 9)\n    ])\n \n+;; n = no change, x = clobbered.  The first 16 values are chosen such\n+;; that the enum has one bit set for each flag.\n+(define_attr \"flags\" \"x,c,z,zc,s,sc,sz,szc,o,oc,oz,ozc,os,osc,osz,oszc,n\" (const_string \"n\"))\n+(define_asm_attributes [(set_attr \"flags\" \"x\")])\n+\n+(define_mode_macro QHI [QI HI])\n+(define_mode_macro HPSI [(HI \"TARGET_A16\") (PSI \"TARGET_A24\")])\n+(define_mode_macro QHPSI [QI HI (PSI \"TARGET_A24\")])\n+(define_mode_macro QHSI [QI HI (SI \"TARGET_A24\")])\n+(define_mode_attr bwl [(QI \"b\") (HI \"w\") (PSI \"l\") (SI \"l\")])\n+\n+(define_code_macro any_cond [eq ne gt ge lt le gtu geu ltu leu])\n+(define_code_macro eqne_cond [eq ne])\n+(define_code_macro gl_cond [gt ge lt le gtu geu ltu leu])\n+\n+\n+\n (define_insn \"nop\"\n   [(const_int 0)]\n   \"\"\n   \"nop\")\n \n-;; n = no change, x = clobbered.  The first 16 values are chosen such\n-;; that the enum has one bit set for each flag.\n-(define_attr \"flags\" \"x,c,z,zc,s,sc,sz,szc,o,oc,oz,ozc,os,osc,osz,oszc,n\" (const_string \"n\"))\n-(define_asm_attributes [(set_attr \"flags\" \"x\")])\n+(define_insn \"no_insn\"\n+  [(const_int 1)]\n+  \"\"\n+  \"\")"}, {"sha": "1a6878d0e7c9d38337d79bff2e750c8b35474d5b", "filename": "gcc/config/m32c/mov.md", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Fmov.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Fmov.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fmov.md?ref=07127a0a3b7a73f24105b80dd63c12d38fe84bf1", "patch": "@@ -32,9 +32,9 @@\n ;; Match push/pop before mov.b for passing char as arg,\n ;; e.g. stdlib/efgcvt.c.\n (define_insn \"movqi_op\"\n-  [(set (match_operand:QI 0 \"mra_qi_operand\"\n+  [(set (match_operand:QI 0 \"m32c_nonimmediate_operand\"\n \t\t\t  \"=Rqi*Rmm, <,          RqiSd*Rmm, SdSs,    Rqi*Rmm, Sd\")\n-\t(match_operand:QI 1 \"mrai_qi_operand\"\n+\t(match_operand:QI 1 \"m32c_any_operand\"\n \t\t\t  \"iRqi*Rmm, iRqiSd*Rmm, >,         Rqi*Rmm, SdSs,    i\"))]\n   \"m32c_mov_ok (operands, QImode)\"\n   \"@\n@@ -48,17 +48,17 @@\n   )\n \n (define_expand \"movqi\"\n-  [(set (match_operand:QI 0 \"mra_qi_operand\" \"=RqiSd*Rmm\")\n-\t(match_operand:QI 1 \"mrai_qi_operand\" \"iRqiSd*Rmm\"))]\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=RqiSd*Rmm\")\n+\t(match_operand:QI 1 \"general_operand\" \"iRqiSd*Rmm\"))]\n   \"\"\n   \"if (m32c_prepare_move (operands, QImode)) DONE;\"\n   )\n \n \n (define_insn \"movhi_op\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\"\n+  [(set (match_operand:HI 0 \"m32c_nonimmediate_operand\"\n \t\t\t  \"=Rhi*Rmm,     Sd, SdSs,   *Rcr, RhiSd*Rmm, <, RhiSd*Rmm, <, *Rcr\")\n-\t(match_operand:HI 1 \"general_operand\"\n+\t(match_operand:HI 1 \"m32c_any_operand\"\n \t\t\t  \"iRhi*RmmSdSs, i, Rhi*Rmm, RhiSd*Rmm, *Rcr, iRhiSd*Rmm, >, *Rcr, >\"))]\n   \"m32c_mov_ok (operands, HImode)\"\n   \"@\n@@ -75,18 +75,18 @@\n   )\n \n (define_expand \"movhi\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=RhiSd*Rmm\")\n-\t(match_operand:HI 1 \"general_operand\" \"iRhiSd*Rmm\"))]\n+  [(set (match_operand:HI 0 \"m32c_nonimmediate_operand\" \"=RhiSd*Rmm\")\n+\t(match_operand:HI 1 \"m32c_any_operand\" \"iRhiSd*Rmm\"))]\n   \"\"\n   \"if (m32c_prepare_move (operands, HImode)) DONE;\"\n   )\n \n \n (define_insn \"movpsi_op\"\n-  [(set (match_operand:PSI 0 \"nonimmediate_operand\"\n-\t\t\t   \"=Raa, SdRmmRpi,  Rcl,  RpiSd*Rmm, <,       <, Rcl, Rsi*Rmm\")\n-\t(match_operand:PSI 1 \"general_operand\"\n-\t\t\t   \"sIU3, iSdRmmRpi, iRpiSd*Rmm, Rcl, Rsi*Rmm, Rcl, >, >\"))]\n+  [(set (match_operand:PSI 0 \"m32c_nonimmediate_operand\"\n+\t\t\t   \"=Raa, SdRmmRpi,  Rcl,  RpiSd*Rmm, <,       <, Rcl, RpiRaa*Rmm\")\n+\t(match_operand:PSI 1 \"m32c_any_operand\"\n+\t\t\t   \"sIU3, iSdRmmRpi, iRpiSd*Rmm, Rcl, Rpi*Rmm, Rcl, >, >\"))]\n   \"TARGET_A24 && m32c_mov_ok (operands, PSImode)\"\n   \"@\n    mov.l:s\\t%1,%0\n@@ -104,9 +104,6 @@\n ;; The intention here is to combine the add with the move to create an\n ;; indexed move.  GCC doesn't always figure this out itself.\n \n-(define_mode_macro QHSI [QI HI SI])\n-(define_mode_macro HPSI [(HI \"TARGET_A16\") (PSI \"TARGET_A24\")])\n-\n (define_peephole2\n   [(set (match_operand:HPSI 0 \"register_operand\" \"\")\n \t(plus:HPSI (match_operand:HPSI 1 \"register_operand\" \"\")\n@@ -128,7 +125,7 @@\n \t(plus:HPSI (match_operand:HPSI 1 \"register_operand\" \"\")\n \t\t   (match_operand:HPSI 2 \"immediate_operand\" \"\")))\n    (set (mem:QHSI (match_operand:HPSI 4 \"register_operand\" \"\"))\n-\t(match_operand:QHSI 3 \"general_operand\" \"\"))]\n+\t(match_operand:QHSI 3 \"m32c_any_operand\" \"\"))]\n   \"REGNO (operands[0]) == REGNO (operands[1])\n    && REGNO (operands[0]) == REGNO (operands[4])\n    && dead_or_set_p (peep2_next_insn (1), operands[4])\n@@ -141,8 +138,8 @@\n \n ; Some PSI moves must be split.\n (define_split\n-  [(set (match_operand:PSI 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:PSI 1 \"general_operand\" \"\"))]\n+  [(set (match_operand:PSI 0 \"m32c_nonimmediate_operand\" \"\")\n+\t(match_operand:PSI 1 \"m32c_any_operand\" \"\"))]\n   \"reload_completed && m32c_split_psi_p (operands)\"\n   [(set (match_dup 2)\n \t(match_dup 3))\n@@ -152,25 +149,25 @@\n   )\n \n (define_expand \"movpsi\"\n-  [(set (match_operand:PSI 0 \"mras_operand\" \"\")\n-\t(match_operand:PSI 1 \"mrasi_operand\" \"\"))]\n+  [(set (match_operand:PSI 0 \"m32c_nonimmediate_operand\" \"\")\n+\t(match_operand:PSI 1 \"m32c_any_operand\" \"\"))]\n   \"\"\n   \"if (m32c_prepare_move (operands, PSImode)) DONE;\"\n   )\n \n \n \n (define_expand \"movsi\"\n-  [(set (match_operand:SI 0 \"mras_operand\" \"=RsiSd*Rmm\")\n-\t(match_operand:SI 1 \"mrasi_operand\" \"iRsiSd*Rmm\"))]\n+  [(set (match_operand:SI 0 \"m32c_nonimmediate_operand\" \"=RsiSd*Rmm\")\n+\t(match_operand:SI 1 \"m32c_any_operand\" \"iRsiSd*Rmm\"))]\n   \"\"\n   \"if (m32c_split_move (operands, SImode, 0)) DONE;\"\n   )\n \n ; All SI moves are split if TARGET_A16\n (define_insn_and_split \"movsi_splittable\"\n-  [(set (match_operand:SI 0 \"mras_operand\" \"=Rsi<*Rmm,RsiSd*Rmm,Ss\")\n-\t(match_operand:SI 1 \"mrasi_operand\" \"iRsiSd*Rmm,iRsi>*Rmm,Rsi*Rmm\"))]\n+  [(set (match_operand:SI 0 \"m32c_nonimmediate_operand\" \"=Rsi<*Rmm,RsiSd*Rmm,Ss\")\n+\t(match_operand:SI 1 \"m32c_any_operand\" \"iRsiSd*Rmm,iRsi>*Rmm,Rsi*Rmm\"))]\n   \"TARGET_A16\"\n   \"#\"\n   \"TARGET_A16 && reload_completed\"\n@@ -182,14 +179,14 @@\n ; don't match.\n (define_insn \"push_a01_l\"\n   [(set (mem:SI (pre_dec:PSI (reg:PSI SP_REGNO)))\n-\t(match_operand 0 \"a_operand\" \"\"))]\n+\t(match_operand 0 \"a_operand\" \"Raa\"))]\n   \"\"\n   \"push.l\\t%0\"\n   )\n \n (define_insn \"movsi_24\"\n-  [(set (match_operand:SI 0 \"mras_operand\"  \"=Rsi*Rmm,   Sd,       RsiSd*Rmm,     <\")\n-\t(match_operand:SI 1 \"mrasi_operand\" \"iRsiSd*Rmm, iRsi*Rmm, >, iRsiRaaSd*Rmm\"))]\n+  [(set (match_operand:SI 0 \"m32c_nonimmediate_operand\"  \"=Rsi*Rmm,   Sd,       RsiSd*Rmm,     <\")\n+\t(match_operand:SI 1 \"m32c_any_operand\" \"iRsiSd*Rmm, iRsi*Rmm, >, iRsiRaaSd*Rmm\"))]\n   \"TARGET_A24\"\n   \"@\n    mov.l\\t%1,%0\n@@ -199,15 +196,15 @@\n   )\n \n (define_expand \"movdi\"\n-  [(set (match_operand:DI 0 \"mras_operand\" \"=RdiSd*Rmm\")\n-\t(match_operand:DI 1 \"mrasi_operand\" \"iRdiSd*Rmm\"))]\n+  [(set (match_operand:DI 0 \"m32c_nonimmediate_operand\" \"=RdiSd*Rmm\")\n+\t(match_operand:DI 1 \"m32c_any_operand\" \"iRdiSd*Rmm\"))]\n   \"\"\n   \"if (m32c_split_move (operands, DImode, 0)) DONE;\"\n   )\n \n (define_insn_and_split \"movdi_splittable\"\n-  [(set (match_operand:DI 0 \"mras_operand\" \"=Rdi<*Rmm,RdiSd*Rmm\")\n-\t(match_operand:DI 1 \"mrasi_operand\" \"iRdiSd*Rmm,iRdi>*Rmm\"))]\n+  [(set (match_operand:DI 0 \"m32c_nonimmediate_operand\" \"=Rdi<*Rmm,RdiSd*Rmm\")\n+\t(match_operand:DI 1 \"m32c_any_operand\" \"iRdiSd*Rmm,iRdi>*Rmm\"))]\n   \"\"\n   \"#\"\n   \"reload_completed\"\n@@ -305,15 +302,15 @@\n \n ;; Rhl used here as an HI-mode Rxl\n (define_insn \"extendqihi2\"\n-[(set (match_operand:HI 0 \"mra_operand\" \"=RhlSd*Rmm\")\n+[(set (match_operand:HI 0 \"m32c_nonimmediate_operand\" \"=RhlSd*Rmm\")\n \t(sign_extend:HI (match_operand:QI 1 \"mra_operand\" \"0\")))]\n   \"\"\n   \"exts.b\\t%1\"\n   [(set_attr \"flags\" \"sz\")]\n   )\n \n (define_insn \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"r0123_operand\" \"=R03\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=R03\")\n \t(sign_extend:SI (match_operand:HI 1 \"r0123_operand\" \"0\")))]\n   \"\"\n   \"*\n@@ -337,28 +334,30 @@\n   )\n \n (define_insn \"zero_extendhipsi2\"\n-  [(set (match_operand:PSI 0 \"nonimmediate_operand\" \"=Raa\")\n-\t(truncate:PSI (zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"Rhi\"))))]\n+  [(set (match_operand:PSI 0 \"register_operand\" \"=Raa\")\n+\t(truncate:PSI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"R03\"))))]\n   \"\"\n   \"mov.w\\t%1,%0\"\n   )\n \n (define_insn \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=RsiSd\")\n+  [(set (match_operand:SI 0 \"m32c_nonimmediate_operand\" \"=RsiSd\")\n \t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")))]\n   \"\"\n   \"mov.w\\t#0,%H0\"\n   )\n \n (define_insn \"zero_extendqihi2\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=RsiRaaSd*Rmm\")\n-\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")))]\n+  [(set (match_operand:HI 0 \"m32c_nonimmediate_operand\" \"=Rhl,RhiSd*Rmm\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0\")))]\n   \"\"\n-  \"and.w\\t#255,%0\"\n+  \"@\n+   mov.b\\t#0,%H0\n+   and.w\\t#255,%0\"\n   )\n \n (define_insn \"truncsipsi2_16\"\n-  [(set (match_operand:PSI 0 \"nonimmediate_operand\" \"=RsiRadSd*Rmm,Raa,Rcr,RsiSd*Rmm\")\n+  [(set (match_operand:PSI 0 \"m32c_nonimmediate_operand\" \"=RsiRadSd*Rmm,Raa,Rcr,RsiSd*Rmm\")\n \t(truncate:PSI (match_operand:SI 1 \"nonimmediate_operand\" \"0,RsiSd*Rmm,RsiSd*Rmm,Rcr\")))]\n   \"TARGET_A16\"\n   \"@\n@@ -369,15 +368,15 @@\n   )\n \n (define_insn \"trunchiqi2\"\n-  [(set (match_operand:QI 0 \"mra_qi_operand\" \"=RqiRmmSd\")\n+  [(set (match_operand:QI 0 \"m32c_nonimmediate_operand\" \"=RqiRmmSd\")\n \t(truncate:QI (match_operand:HI 1 \"mra_qi_operand\" \"0\")))]\n   \"\"\n   \"; no-op trunc hi %1 to qi %0\"\n   )\n \n (define_insn \"truncsipsi2_24\"\n-  [(set (match_operand:PSI 0              \"nonimmediate_operand\" \"=RsiSd*Rmm,Raa,!Rcl,RsiSd*Rmm\")\n-\t(truncate:PSI (match_operand:SI 1 \"nonimmediate_operand\" \"0,RsiSd*Rmm,RsiSd*Rmm,!Rcl\")))]\n+  [(set (match_operand:PSI 0              \"m32c_nonimmediate_operand\" \"=RsiSd*Rmm,Raa,!Rcl,RsiSd*Rmm\")\n+\t(truncate:PSI (match_operand:SI 1 \"m32c_nonimmediate_operand\" \"0,RsiSd*Rmm,RsiSd*Rmm,!Rcl\")))]\n   \"TARGET_A24\"\n   \"@\n    ; no-op trunc si %1 to psi %0\n@@ -387,8 +386,8 @@\n   )\n \n (define_expand \"truncsipsi2\"\n-  [(set (match_operand:PSI 0 \"nonimmediate_operand\" \"=RsiRadSd*Rmm,Raa,Rcr,RsiSd*Rmm\")\n-\t(truncate:PSI (match_operand:SI 1 \"nonimmediate_operand\" \"0,RsiSd*Rmm,RsiSd*Rmm,Rcr\")))]\n+  [(set (match_operand:PSI 0 \"m32c_nonimmediate_operand\" \"=RsiRadSd*Rmm,Raa,Rcr,RsiSd*Rmm\")\n+\t(truncate:PSI (match_operand:SI 1 \"m32c_nonimmediate_operand\" \"0,RsiSd*Rmm,RsiSd*Rmm,Rcr\")))]\n   \"\"\n   \"\"\n   )"}, {"sha": "038ca8a126837ce373ca0a71ef81264bbd84bbba", "filename": "gcc/config/m32c/muldiv.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Fmuldiv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Fmuldiv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fmuldiv.md?ref=07127a0a3b7a73f24105b80dd63c12d38fe84bf1", "patch": "@@ -143,7 +143,8 @@\n \t(mult:PSI (match_operand:PSI 1 \"mra_operand\" \"%0\")\n \t\t  (match_operand 2 \"m32c_psi_scale\" \"Ilb\")))]\n   \"TARGET_A24\"\n-  \"if (INTVAL(operands[2]) < 0)\n+  \"if (GET_CODE (operands[2]) != CONST_INT\n+       || INTVAL(operands[2]) < 0)\n      {\n        m32c_expand_neg_mulpsi3 (operands);\n        DONE;"}, {"sha": "5b9549c6f7b9ebf0c4b60dc3378caad09ee75ea0", "filename": "gcc/config/m32c/predicates.md", "status": "modified", "additions": 78, "deletions": 7, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fpredicates.md?ref=07127a0a3b7a73f24105b80dd63c12d38fe84bf1", "patch": "@@ -22,6 +22,19 @@\n \n ;; Predicates\n \n+; TRUE for any valid operand.  We do this because general_operand\n+; refuses to match volatile memory refs.\n+\n+(define_predicate \"m32c_any_operand\"\n+  (ior (match_operand 0 \"general_operand\")\n+       (match_operand 1 \"memory_operand\")))\n+\n+; Likewise for nonimmediate_operand.\n+\n+(define_predicate \"m32c_nonimmediate_operand\"\n+  (ior (match_operand 0 \"nonimmediate_operand\")\n+       (match_operand 1 \"memory_operand\")))\n+\n ; TRUE if the operand is a pseudo-register.\n (define_predicate \"m32c_pseudo\"\n   (ior (and (match_code \"reg\")\n@@ -63,12 +76,25 @@\n        (and (match_code \"reg\")\n \t    (match_test \"REGNO(op) == R1_REGNO\"))))\n \n+; TRUE for HL_CLASS (r0 or r1)\n+(define_predicate \"m32c_hl_operand\"\n+  (ior (match_operand 0 \"m32c_pseudo\" \"\")\n+       (and (match_code \"reg\")\n+\t    (match_test \"REGNO(op) == R0_REGNO || REGNO(op) == R1_REGNO\"))))\n+\n+\n ; TRUE for r2\n (define_predicate \"m32c_r2_operand\"\n   (ior (match_operand 0 \"m32c_pseudo\" \"\")\n        (and (match_code \"reg\")\n \t    (match_test \"REGNO(op) == R2_REGNO\"))))\n \n+; TRUE for r3\n+(define_predicate \"m32c_r3_operand\"\n+  (ior (match_operand 0 \"m32c_pseudo\" \"\")\n+       (and (match_code \"reg\")\n+\t    (match_test \"REGNO(op) == R3_REGNO\"))))\n+\n ; TRUE for any general operand except r2.\n (define_predicate \"m32c_notr2_operand\"\n   (and (match_operand 0 \"general_operand\")\n@@ -89,9 +115,14 @@\n \n ; TRUE for $a0 or $a1.\n (define_predicate \"a_operand\"\n-  (match_code \"reg\")\n-  \"return (REGNO (op) == A0_REGNO\n-           || REGNO (op) == A1_REGNO);\")\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == A0_REGNO || REGNO (op) == A1_REGNO\")))\n+\n+; TRUE for $a0 or $a1 or a pseudo\n+(define_predicate \"ap_operand\"\n+  (ior (match_operand 0 \"m32c_pseudo\" \"\")\n+       (and (match_code \"reg\")\n+\t    (match_test \"REGNO (op) == A0_REGNO || REGNO (op) == A1_REGNO\"))))\n \n ; TRUE for r0 through r3, or a0 or a1.\n (define_predicate \"ra_operand\"\n@@ -112,7 +143,7 @@\n \n ; TRUE for memory, r0..r3, a0..a1, or immediates.\n (define_predicate \"mrai_operand\"\n-  (and (and (match_operand 0 \"general_operand\" \"\")\n+  (and (and (match_operand 0 \"m32c_any_operand\" \"\")\n \t    (not (match_operand 1 \"cr_operand\" \"\")))\n        (not (match_operand 2 \"m32c_wide_subreg\" \"\"))))\n \n@@ -126,7 +157,22 @@\n   (and (match_operand 0 \"mra_operand\" \"\")\n        (not (match_operand 1 \"a_operand\" \"\"))))\n \n-; TRUE for r1h.  This complicated since r1h isn't a register GCC\n+; TRUE for a0..a1 or memory.\n+(define_predicate \"ma_operand\"\n+  (ior (match_operand 0 \"a_operand\" \"\")\n+       (match_operand 1 \"memory_operand\" \"\")))\n+\n+; TRUE for memory operands that are not indexed\n+(define_predicate \"memsym_operand\"\n+  (and (match_operand 0 \"memory_operand\" \"\")\n+       (match_test \"m32c_extra_constraint_p (op, 'S', \\\"Si\\\")\")))\n+\n+; TRUE for memory operands with small integer addresses\n+(define_predicate \"memimmed_operand\"\n+  (and (match_operand 0 \"memory_operand\" \"\")\n+       (match_test \"m32c_extra_constraint_p (op, 'S', \\\"Sp\\\")\")))\n+\n+; TRUE for r1h.  This is complicated since r1h isn't a register GCC\n ; normally knows about.\n (define_predicate \"r1h_operand\"\n   (match_code \"zero_extract\")\n@@ -175,19 +221,26 @@\n \n ; These two are only for movqi - no subreg limit\n (define_predicate \"mra_qi_operand\"\n-  (and (and (match_operand 0 \"nonimmediate_operand\" \"\")\n+  (and (and (match_operand 0 \"m32c_nonimmediate_operand\" \"\")\n \t    (not (match_operand 1 \"cr_operand\" \"\")))\n        (not (match_operand 1 \"m32c_r2r3a_operand\" \"\"))))\n \n (define_predicate \"mrai_qi_operand\"\n-  (and (and (match_operand 0 \"general_operand\" \"\")\n+  (and (and (match_operand 0 \"m32c_any_operand\" \"\")\n \t    (not (match_operand 1 \"cr_operand\" \"\")))\n        (not (match_operand 1 \"m32c_r2r3a_operand\" \"\"))))\n \n+(define_predicate \"a_qi_operand\"\n+  (ior (match_operand 0 \"m32c_pseudo\" \"\")\n+       (match_operand 1 \"a_operand\" \"\")))\n+\n ; TRUE for comparisons we support.\n (define_predicate \"m32c_cmp_operator\"\n   (match_code \"eq,ne,gt,gtu,lt,ltu,ge,geu,le,leu\"))\n \n+(define_predicate \"m32c_eqne_operator\"\n+  (match_code \"eq,ne\"))\n+\n ; TRUE for mem0\n (define_predicate \"m32c_mem0_operand\"\n   (ior (match_operand 0 \"m32c_pseudo\" \"\")\n@@ -204,3 +257,21 @@\n (define_predicate \"m32c_psi_scale\"\n   (and (match_operand 0 \"const_int_operand\")\n        (match_test \"m32c_const_ok_for_constraint_p(INTVAL(op), 'I', \\\"Ilb\\\")\")))\n+\n+; TRUE for one bit set (bit) or clear (mask) out of N bits.\n+\n+(define_predicate \"m32c_1bit8_operand\"\n+  (and (match_operand 0 \"const_int_operand\")\n+       (match_test \"m32c_const_ok_for_constraint_p(INTVAL(op), 'I', \\\"Ilb\\\")\")))\n+\n+(define_predicate \"m32c_1bit16_operand\"\n+  (and (match_operand 0 \"const_int_operand\")\n+       (match_test \"m32c_const_ok_for_constraint_p(INTVAL(op), 'I', \\\"Ilw\\\")\")))\n+\n+(define_predicate \"m32c_1mask8_operand\"\n+  (and (match_operand 0 \"const_int_operand\")\n+       (match_test \"m32c_const_ok_for_constraint_p(INTVAL(op), 'I', \\\"Imb\\\")\")))\n+\n+(define_predicate \"m32c_1mask16_operand\"\n+  (and (match_operand 0 \"const_int_operand\")\n+       (match_test \"m32c_const_ok_for_constraint_p(INTVAL(op), 'I', \\\"Imw\\\")\")))"}, {"sha": "eb5882d925294f2fce01844ac73269e55a754c48", "filename": "gcc/config/m32c/t-m32c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Ft-m32c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07127a0a3b7a73f24105b80dd63c12d38fe84bf1/gcc%2Fconfig%2Fm32c%2Ft-m32c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Ft-m32c?ref=07127a0a3b7a73f24105b80dd63c12d38fe84bf1", "patch": "@@ -48,7 +48,7 @@ dp-bit.c: $(srcdir)/config/fp-bit.c\n \n md_file = md\n \n-MD_FILES = m32c predicates addsub bitops cond jump minmax mov muldiv prologue shift\n+MD_FILES = m32c predicates addsub bitops blkmov cond jump minmax mov muldiv prologue shift\n \n # Doing it this way lets the gen* programs report the right line numbers.\n "}]}