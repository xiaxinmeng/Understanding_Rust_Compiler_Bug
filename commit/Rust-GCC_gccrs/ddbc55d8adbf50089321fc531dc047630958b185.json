{"sha": "ddbc55d8adbf50089321fc531dc047630958b185", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRiYzU1ZDhhZGJmNTAwODkzMjFmYzUzMWRjMDQ3NjMwOTU4YjE4NQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-12T08:03:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-12T08:03:06Z"}, "message": "[multiple changes]\n\n2015-05-12  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_util.adb (Is_Variable): Allow X'Deref(Y) as a variable.\n\n2015-05-12  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch8.adb (Find_Expanded_Name): Handle properly a fully\n\tqualified name for an instance of a generic grand-child unit in\n\tthe body its parent.\n\n2015-05-12  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_unst.adb (Upref_Name): New subprogram.\n\t(Unnest_Subprogram): Use Upref_Name.\n\t(Unnest_Subprogram): Use new Deref attribute.\n\t* exp_unst.ads: Doc updates.\n\n2015-05-12  Thomas Quinot  <quinot@adacore.com>\n\n\t* adaint.c: Enable Large File Support in adaint so that __gnat_readdir\n\tcan access files on filesystems mounted from servers that use large\n\tNFS file handles.\n\nFrom-SVN: r223035", "tree": {"sha": "7c79da8645ba8467b8f917ffc998a1734e1c1b6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c79da8645ba8467b8f917ffc998a1734e1c1b6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddbc55d8adbf50089321fc531dc047630958b185", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddbc55d8adbf50089321fc531dc047630958b185", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddbc55d8adbf50089321fc531dc047630958b185", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddbc55d8adbf50089321fc531dc047630958b185/comments", "author": null, "committer": null, "parents": [{"sha": "3a857fd0d35c740596ee0a0c2a575ef10cd473c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a857fd0d35c740596ee0a0c2a575ef10cd473c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a857fd0d35c740596ee0a0c2a575ef10cd473c9"}], "stats": {"total": 157, "additions": 105, "deletions": 52}, "files": [{"sha": "c711823259efb2306bf3b1f1385da6977d2e6923", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbc55d8adbf50089321fc531dc047630958b185/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbc55d8adbf50089321fc531dc047630958b185/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ddbc55d8adbf50089321fc531dc047630958b185", "patch": "@@ -1,3 +1,26 @@\n+2015-05-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_util.adb (Is_Variable): Allow X'Deref(Y) as a variable.\n+\n+2015-05-12  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch8.adb (Find_Expanded_Name): Handle properly a fully\n+\tqualified name for an instance of a generic grand-child unit in\n+\tthe body its parent.\n+\n+2015-05-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_unst.adb (Upref_Name): New subprogram.\n+\t(Unnest_Subprogram): Use Upref_Name.\n+\t(Unnest_Subprogram): Use new Deref attribute.\n+\t* exp_unst.ads: Doc updates.\n+\n+2015-05-12  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* adaint.c: Enable Large File Support in adaint so that __gnat_readdir\n+\tcan access files on filesystems mounted from servers that use large\n+\tNFS file handles.\n+\n 2015-05-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils.c (gnat_write_global_declarations): Use type_decl"}, {"sha": "73eb8140103b275710d4c4b6b2fec97c0f4c7830", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbc55d8adbf50089321fc531dc047630958b185/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbc55d8adbf50089321fc531dc047630958b185/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=ddbc55d8adbf50089321fc531dc047630958b185", "patch": "@@ -38,6 +38,12 @@\n #define _REENTRANT\n #define _THREAD_SAFE\n \n+/* Use 64 bit Large File API */\n+#ifndef _LARGEFILE_SOURCE\n+#define _LARGEFILE_SOURCE\n+#endif\n+#define _FILE_OFFSET_BITS 64\n+\n #ifdef __vxworks\n \n /* No need to redefine exit here.  */"}, {"sha": "eed99ffc8df368e66c533b1c3fa32a857a59f39e", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 40, "deletions": 31, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbc55d8adbf50089321fc531dc047630958b185/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbc55d8adbf50089321fc531dc047630958b185/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=ddbc55d8adbf50089321fc531dc047630958b185", "patch": "@@ -26,7 +26,6 @@\n with Atree;    use Atree;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n-with Exp_Util; use Exp_Util;\n with Lib;      use Lib;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n@@ -358,6 +357,14 @@ package body Exp_Unst is\n       function Subp_Index (Sub : Entity_Id) return SI_Type;\n       --  Given the entity for a subprogram, return corresponding Subps index\n \n+      function Upref_Name (Ent : Entity_Id) return Name_Id;\n+      --  This function returns the name to be used in the activation record to\n+      --  reference the variable uplevel. Normally this is just a copy of the\n+      --  Chars field of the entity. The exception is when the scope of Ent\n+      --  is a declare block, in which case we append the entity number to\n+      --  make sure that no confusion occurs between use of the same name\n+      --  in different declare blocks.\n+\n       ----------------\n       -- Actual_Ref --\n       ----------------\n@@ -445,6 +452,23 @@ package body Exp_Unst is\n          return SI_Type (UI_To_Int (Subps_Index (Sub)));\n       end Subp_Index;\n \n+      ----------------\n+      -- Upref_Name --\n+      ----------------\n+\n+      function Upref_Name (Ent : Entity_Id) return Name_Id is\n+      begin\n+         if Ekind (Scope (Ent)) /= E_Block then\n+            return Chars (Ent);\n+\n+         else\n+            Get_Name_String (Chars (Ent));\n+            Add_Str_To_Name_Buffer (\"__\");\n+            Add_Nat_To_Name_Buffer (Nat (Ent));\n+            return Name_Enter;\n+         end if;\n+      end Upref_Name;\n+\n    --  Start of processing for Unnest_Subprogram\n \n    begin\n@@ -913,7 +937,7 @@ package body Exp_Unst is\n                      for J in 1 .. Num_Uplevel_Entities loop\n                         Comp :=\n                           Make_Defining_Identifier (Loc,\n-                            Chars => Chars (Uplevel_Entities (J)));\n+                            Chars => Upref_Name (Uplevel_Entities (J)));\n \n                         Set_Activation_Record_Component\n                           (Uplevel_Entities (J), Comp);\n@@ -1029,7 +1053,7 @@ package body Exp_Unst is\n                            end if;\n \n                            --  Build and insert the assignment:\n-                           --    ARECn.nam := nam\n+                           --    ARECn.nam := nam'Address\n \n                            Asn :=\n                              Make_Assignment_Statement (Loc,\n@@ -1038,7 +1062,9 @@ package body Exp_Unst is\n                                    Prefix        =>\n                                      New_Occurrence_Of (STJ.ARECn, Loc),\n                                    Selector_Name =>\n-                                     Make_Identifier (Loc, Chars (Ent))),\n+                                     New_Occurrence_Of\n+                                       (Activation_Record_Component (Ent),\n+                                        Loc)),\n \n                                Expression =>\n                                  Make_Attribute_Reference (Loc,\n@@ -1124,11 +1150,6 @@ package body Exp_Unst is\n                         STJR : Subp_Entry renames Subps.Table (RSX);\n                         --  Subp_Entry for enclosing subprogram for ref\n \n-                        Tnn : constant Entity_Id :=\n-                                Make_Temporary\n-                                  (Loc, 'T', Related_Node => Ref);\n-                        --  Local pointer type for reference\n-\n                         Pfx  : Node_Id;\n                         Comp : Entity_Id;\n                         SI   : SI_Type;\n@@ -1141,28 +1162,15 @@ package body Exp_Unst is\n \n                         Push_Scope (STJR.Ent);\n \n-                        --  First insert declaration for pointer type\n-\n-                        --    type Tnn is access all typ;\n-\n-                        Insert_Action (Node (Elmt),\n-                          Make_Full_Type_Declaration (Loc,\n-                            Defining_Identifier => Tnn,\n-                            Type_Definition     =>\n-                              Make_Access_To_Object_Definition (Loc,\n-                                All_Present        => True,\n-                                Subtype_Indication =>\n-                                  New_Occurrence_Of (Typ, Loc))));\n-\n                         --  Now we need to rewrite the reference. We have a\n                         --  reference is from level STJE.Lev to level STJ.Lev.\n                         --  The general form of the rewritten reference for\n                         --  entity X is:\n \n-                        --    Tnn!(ARECaF.ARECbU.ARECcU.ARECdU....ARECm.X).all\n+                        --   Typ'Deref (ARECaF.ARECbU.ARECcU.ARECdU....ARECm.X)\n \n                         --  where a,b,c,d .. m =\n-                        --         STJR.Lev - 1,  STJ.Lev - 2, .. STJ.Lev\n+                        --    STJR.Lev - 1,  STJ.Lev - 2, .. STJ.Lev\n \n                         pragma Assert (STJR.Lev > STJ.Lev);\n \n@@ -1206,13 +1214,14 @@ package body Exp_Unst is\n                         --  Do the replacement\n \n                         Rewrite (Ref,\n-                          Make_Explicit_Dereference (Loc,\n-                            Prefix =>\n-                              Unchecked_Convert_To (Tnn,\n-                                Make_Selected_Component (Loc,\n-                                  Prefix        => Pfx,\n-                                  Selector_Name =>\n-                                    New_Occurrence_Of (Comp, Loc)))));\n+                          Make_Attribute_Reference (Loc,\n+                            Prefix         => New_Occurrence_Of (Typ, Loc),\n+                            Attribute_Name => Name_Deref,\n+                            Expressions    => New_List (\n+                              Make_Selected_Component (Loc,\n+                                Prefix        => Pfx,\n+                                Selector_Name =>\n+                                  New_Occurrence_Of (Comp, Loc)))));\n \n                         --  Analyze and resolve the new expression. We do not\n                         --  need to establish the relevant scope stack entries"}, {"sha": "39930860f637849abad3cc593d08222056c5abb7", "filename": "gcc/ada/exp_unst.ads", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbc55d8adbf50089321fc531dc047630958b185/gcc%2Fada%2Fexp_unst.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbc55d8adbf50089321fc531dc047630958b185/gcc%2Fada%2Fexp_unst.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.ads?ref=ddbc55d8adbf50089321fc531dc047630958b185", "patch": "@@ -187,15 +187,18 @@ package Exp_Unst is\n    --   outer level of nesting. As we will see later, deeper levels of nesting\n    --   will use AREC2, AREC3, ...\n \n+   --   Note: normally the field names in the activation record match the\n+   --   name of the entity. An exception is when the entity is declared in\n+   --   a declare block, in which case we append the entity number, to avoid\n+   --   clashes between the same name declared in different declare blocks.\n+\n    --   For all subprograms nested immediately within the corresponding scope,\n    --   a parameter AREC1F is passed, and all calls to these routines have\n    --   AREC1P added as an additional formal.\n \n    --   Now within the nested procedures, any reference to an uplevel entity\n-   --   xxx is replaced by Tnn!(AREC1.xxx).all (where ! represents a call\n-   --   to unchecked conversion to convert the address to the access type\n-   --   and Tnn is a locally declared type that is \"access all t\", where t\n-   --   is the type of the reference).\n+   --   xxx is replaced by typ'Deref(AREC1.xxx) where typ is the type of the\n+   --   reference.\n \n    --   Note: the reason that we use Address as the component type in the\n    --   declaration of AREC1T is that we may create this type before we see\n@@ -233,11 +236,8 @@ package Exp_Unst is\n    --\n    --          procedure inner (bb : integer; AREC1F : AREC1PT) is\n    --          begin\n-   --             type Tnn1 is access all Integer;\n-   --             type Tnn2 is access all Integer;\n-   --             type Tnn3 is access all Integer;\n-   --             Tnn1!(AREC1F.x).all :=\n-   --               Tnn2!(AREC1F.rv).all + y + b + Tnn3!(AREC1F.b).all;\n+   --             Integer'Deref(AREC1F.x) :=\n+   --               Integer'Deref(AREC1F.rv) + y + b + Integer_Deref(AREC1F.b);\n    --          end;\n    --\n    --       begin\n@@ -388,8 +388,7 @@ package Exp_Unst is\n    --\n    --          function inner (b : integer; AREC1F : AREC1PT) return boolean is\n    --          begin\n-   --             type Tnn is access all Integer\n-   --             return b in x .. Tnn!(AREC1F.dynam_LAST).all\n+   --             return b in x .. Integer'Deref(AREC1F.dynam_LAST)\n    --               and then darecv.b in 42 .. 73;\n    --          end inner;\n    --\n@@ -440,23 +439,20 @@ package Exp_Unst is\n    --           type AREC2PT is access all AREC2T;\n    --           AREC2P : constant AREC2PT := AREC2'Access;\n    --\n-   --           type Tnn1 is access all Integer;\n-   --           v2 : integer := Tnn1!(AREC1F.v1).all {+} 1;\n+   --           v2 : integer := Integer'Deref (AREC1F.v1) {+} 1;\n    --           AREC2.v2 := v2'Address;\n    --\n    --           function inner2\n    --              (z : integer; AREC2F : AREC2PT) return integer\n    --           is\n    --           begin\n-   --              type Tnn1 is access all Integer;\n-   --              type Tnn2 is access all Integer;\n    --              return integer(z {+}\n-   --                             Tnn1!(AREC2F.AREC1U.v1).all {+}\n-   --                             Tnn2!(AREC2F.v2).all);\n+   --                             Integer'Deref (AREC2F.AREC1U.v1) {+}\n+   --                             Integer'Deref (AREC2F.v2).all);\n    --           end inner2;\n    --        begin\n-   --           type Tnn is access all Integer;\n-   --           return integer(y {+} inner2 (Tnn!(AREC1F.v1).all, AREC2P));\n+   --           return integer(y {+}\n+   --                            inner2 (Integer'Deref (AREC1F.v1), AREC2P));\n    --        end inner1;\n    --     begin\n    --        return inner1 (x, AREC1P);"}, {"sha": "921b781ea20be8a62a26217ad9df12ad5e07815f", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbc55d8adbf50089321fc531dc047630958b185/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbc55d8adbf50089321fc531dc047630958b185/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=ddbc55d8adbf50089321fc531dc047630958b185", "patch": "@@ -5791,8 +5791,19 @@ package body Sem_Ch8 is\n             end if;\n \n             if Is_New_Candidate then\n+\n+               --  If entity is a child unit, either it is a visible child of\n+               --  the prefix, or we are in the body of a generic prefix, as\n+               --  will happen when a child unit is instantiated in the body\n+               --  of a generic parent. This is because the instance body does\n+               --  not restore the full compilation context, given that all\n+               --  non-local references have been captured.\n+\n                if Is_Child_Unit (Id) or else P_Name = Standard_Standard then\n-                  exit when Is_Visible_Lib_Unit (Id);\n+                  exit when Is_Visible_Lib_Unit (Id)\n+                    or else (Is_Child_Unit (Id)\n+                              and then In_Open_Scopes (Scope (Id))\n+                              and then In_Instance_Body);\n                else\n                   exit when not Is_Hidden (Id);\n                end if;"}, {"sha": "94e1d6248fef15f71fdb98061349f6459fbd6833", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbc55d8adbf50089321fc531dc047630958b185/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbc55d8adbf50089321fc531dc047630958b185/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=ddbc55d8adbf50089321fc531dc047630958b185", "patch": "@@ -12771,6 +12771,14 @@ package body Sem_Util is\n    --  Start of processing for Is_Variable\n \n    begin\n+      --  Special check, allow x'Deref(expr) as a variable\n+\n+      if Nkind (N) = N_Attribute_Reference\n+        and then Attribute_Name (N) = Name_Deref\n+      then\n+         return True;\n+      end if;\n+\n       --  Check if we perform the test on the original node since this may be a\n       --  test of syntactic categories which must not be disturbed by whatever\n       --  rewriting might have occurred. For example, an aggregate, which is\n@@ -16855,7 +16863,7 @@ package body Sem_Util is\n         and then Has_Foreign_Convention (E)\n       then\n \n-         --  A convention pragma in an instance may apply to the subtype\n+         --  A pragma Convention in an instance may apply to the subtype\n          --  created for a formal, in which case we have already verified\n          --  that conventions of actual and formal match and there is nothing\n          --  to flag on the subtype."}]}