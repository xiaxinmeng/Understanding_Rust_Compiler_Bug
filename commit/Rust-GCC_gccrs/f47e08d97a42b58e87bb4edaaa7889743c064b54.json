{"sha": "f47e08d97a42b58e87bb4edaaa7889743c064b54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ3ZTA4ZDk3YTQyYjU4ZTg3YmI0ZWRhYWE3ODg5NzQzYzA2NGI1NA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-02-16T10:01:51Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-02-16T10:01:51Z"}, "message": "alias.c (memrefs_conflict_p): Distinguish must-alias from don't know.\n\n2010-02-16  Richard Guenther  <rguenther@suse.de>\n\n\t* alias.c (memrefs_conflict_p): Distinguish must-alias from\n\tdon't know.\n\t(true_dependence): If memrefs_conflict_p computes must-alias\n\ttrust it.  Move TBAA check after offset-based disambiguation.\n\t(canon_true_dependence): Likewise.\n\nFrom-SVN: r156797", "tree": {"sha": "0832d31463edaca75ce0c6fd27a925217d7df290", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0832d31463edaca75ce0c6fd27a925217d7df290"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f47e08d97a42b58e87bb4edaaa7889743c064b54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f47e08d97a42b58e87bb4edaaa7889743c064b54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f47e08d97a42b58e87bb4edaaa7889743c064b54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f47e08d97a42b58e87bb4edaaa7889743c064b54/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7bc19392e5caab29d0607163a021286c5ed4a859", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bc19392e5caab29d0607163a021286c5ed4a859", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bc19392e5caab29d0607163a021286c5ed4a859"}], "stats": {"total": 81, "additions": 51, "deletions": 30}, "files": [{"sha": "83879235ca0bc0e60124c5920f4b9e2e95752a2f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47e08d97a42b58e87bb4edaaa7889743c064b54/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47e08d97a42b58e87bb4edaaa7889743c064b54/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f47e08d97a42b58e87bb4edaaa7889743c064b54", "patch": "@@ -1,3 +1,11 @@\n+2010-02-16  Richard Guenther  <rguenther@suse.de>\n+\n+\t* alias.c (memrefs_conflict_p): Distinguish must-alias from\n+\tdon't know.\n+\t(true_dependence): If memrefs_conflict_p computes must-alias\n+\ttrust it.  Move TBAA check after offset-based disambiguation.\n+\t(canon_true_dependence): Likewise.\n+\n 2010-02-16  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* params.def (PARAM_MAX_VARTRACK_SIZE): New."}, {"sha": "71a34a292651ad0de570d8c16c06c9a4c674439c", "filename": "gcc/alias.c", "status": "modified", "additions": 43, "deletions": 30, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47e08d97a42b58e87bb4edaaa7889743c064b54/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47e08d97a42b58e87bb4edaaa7889743c064b54/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=f47e08d97a42b58e87bb4edaaa7889743c064b54", "patch": "@@ -1759,8 +1759,12 @@ addr_side_effect_eval (rtx addr, int size, int n_refs)\n   return addr;\n }\n \n-/* Return nonzero if X and Y (memory addresses) could reference the\n-   same location in memory.  C is an offset accumulator.  When\n+/* Return one if X and Y (memory addresses) reference the\n+   same location in memory or if the references overlap.\n+   Return zero if they do not overlap, else return\n+   minus one in which case they still might reference the same location.\n+\n+   C is an offset accumulator.  When\n    C is nonzero, we are testing aliases between X and Y + C.\n    XSIZE is the size in bytes of the X reference,\n    similarly YSIZE is the size in bytes for Y.\n@@ -1775,7 +1779,11 @@ addr_side_effect_eval (rtx addr, int size, int n_refs)\n    align memory references, as is done on the Alpha.\n \n    Nice to notice that varying addresses cannot conflict with fp if no\n-   local variables had their addresses taken, but that's too hard now.  */\n+   local variables had their addresses taken, but that's too hard now.\n+\n+   ???  Contrary to the tree alias oracle this does not return\n+   one for X + non-constant and Y + non-constant when X and Y are equal.\n+   If that is fixed the TBAA hack for union type-punning can be removed.  */\n \n static int\n memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n@@ -1841,7 +1849,7 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n \t  else if (CONST_INT_P (y1))\n \t    return memrefs_conflict_p (xsize, x, ysize, y0, c + INTVAL (y1));\n \n-\t  return 1;\n+\t  return -1;\n \t}\n       else if (CONST_INT_P (x1))\n \treturn memrefs_conflict_p (xsize, x0, ysize, y, c - INTVAL (x1));\n@@ -1856,7 +1864,7 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n       if (CONST_INT_P (y1))\n \treturn memrefs_conflict_p (xsize, x, ysize, y0, c + INTVAL (y1));\n       else\n-\treturn 1;\n+\treturn -1;\n     }\n \n   if (GET_CODE (x) == GET_CODE (y))\n@@ -1871,7 +1879,7 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n \t  rtx x1 = canon_rtx (XEXP (x, 1));\n \t  rtx y1 = canon_rtx (XEXP (y, 1));\n \t  if (! rtx_equal_for_memref_p (x1, y1))\n-\t    return 1;\n+\t    return -1;\n \t  x0 = canon_rtx (XEXP (x, 0));\n \t  y0 = canon_rtx (XEXP (y, 0));\n \t  if (rtx_equal_for_memref_p (x0, y0))\n@@ -1880,7 +1888,7 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n \n \t  /* Can't properly adjust our sizes.  */\n \t  if (!CONST_INT_P (x1))\n-\t    return 1;\n+\t    return -1;\n \t  xsize /= INTVAL (x1);\n \t  ysize /= INTVAL (x1);\n \t  c /= INTVAL (x1);\n@@ -1939,9 +1947,10 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n \t\t|| (rtx_equal_for_memref_p (x, y)\n \t\t    && ((c >= 0 && xsize > c) || (c < 0 && ysize+c > 0))));\n \n-      return 1;\n+      return -1;\n     }\n-  return 1;\n+\n+  return -1;\n }\n \n /* Functions to compute memory dependencies.\n@@ -2294,6 +2303,7 @@ true_dependence (const_rtx mem, enum machine_mode mem_mode, const_rtx x,\n {\n   rtx x_addr, mem_addr;\n   rtx base;\n+  int ret;\n \n   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n     return 1;\n@@ -2308,18 +2318,12 @@ true_dependence (const_rtx mem, enum machine_mode mem_mode, const_rtx x,\n       || MEM_ALIAS_SET (mem) == ALIAS_SET_MEMORY_BARRIER)\n     return 1;\n \n-  if (DIFFERENT_ALIAS_SETS_P (x, mem))\n-    return 0;\n-\n   /* Read-only memory is by definition never modified, and therefore can't\n      conflict with anything.  We don't expect to find read-only set on MEM,\n      but stupid user tricks can produce them, so don't die.  */\n   if (MEM_READONLY_P (x))\n     return 0;\n \n-  if (nonoverlapping_memrefs_p (mem, x))\n-    return 0;\n-\n   /* If we have MEMs refering to different address spaces (which can\n      potentially overlap), we cannot easily tell from the addresses\n      whether the references overlap.  */\n@@ -2344,8 +2348,14 @@ true_dependence (const_rtx mem, enum machine_mode mem_mode, const_rtx x,\n   x_addr = canon_rtx (x_addr);\n   mem_addr = canon_rtx (mem_addr);\n \n-  if (! memrefs_conflict_p (GET_MODE_SIZE (mem_mode), mem_addr,\n-\t\t\t    SIZE_FOR_MODE (x), x_addr, 0))\n+  if ((ret = memrefs_conflict_p (GET_MODE_SIZE (mem_mode), mem_addr,\n+\t\t\t\t SIZE_FOR_MODE (x), x_addr, 0)) != -1)\n+    return ret;\n+\n+  if (DIFFERENT_ALIAS_SETS_P (x, mem))\n+    return 0;\n+\n+  if (nonoverlapping_memrefs_p (mem, x))\n     return 0;\n \n   if (aliases_everything_p (x))\n@@ -2378,6 +2388,8 @@ int\n canon_true_dependence (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n \t\t       const_rtx x, rtx x_addr, bool (*varies) (const_rtx, bool))\n {\n+  int ret;\n+\n   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n     return 1;\n \n@@ -2391,18 +2403,12 @@ canon_true_dependence (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n       || MEM_ALIAS_SET (mem) == ALIAS_SET_MEMORY_BARRIER)\n     return 1;\n \n-  if (DIFFERENT_ALIAS_SETS_P (x, mem))\n-    return 0;\n-\n   /* Read-only memory is by definition never modified, and therefore can't\n      conflict with anything.  We don't expect to find read-only set on MEM,\n      but stupid user tricks can produce them, so don't die.  */\n   if (MEM_READONLY_P (x))\n     return 0;\n \n-  if (nonoverlapping_memrefs_p (x, mem))\n-    return 0;\n-\n   /* If we have MEMs refering to different address spaces (which can\n      potentially overlap), we cannot easily tell from the addresses\n      whether the references overlap.  */\n@@ -2416,8 +2422,14 @@ canon_true_dependence (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n     return 0;\n \n   x_addr = canon_rtx (x_addr);\n-  if (! memrefs_conflict_p (GET_MODE_SIZE (mem_mode), mem_addr,\n-\t\t\t    SIZE_FOR_MODE (x), x_addr, 0))\n+  if ((ret = memrefs_conflict_p (GET_MODE_SIZE (mem_mode), mem_addr,\n+\t\t\t\t SIZE_FOR_MODE (x), x_addr, 0)) != -1)\n+    return ret;\n+\n+  if (DIFFERENT_ALIAS_SETS_P (x, mem))\n+    return 0;\n+\n+  if (nonoverlapping_memrefs_p (x, mem))\n     return 0;\n \n   if (aliases_everything_p (x))\n@@ -2448,6 +2460,7 @@ write_dependence_p (const_rtx mem, const_rtx x, int writep)\n   rtx x_addr, mem_addr;\n   const_rtx fixed_scalar;\n   rtx base;\n+  int ret;\n \n   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n     return 1;\n@@ -2466,9 +2479,6 @@ write_dependence_p (const_rtx mem, const_rtx x, int writep)\n   if (!writep && MEM_READONLY_P (mem))\n     return 0;\n \n-  if (nonoverlapping_memrefs_p (x, mem))\n-    return 0;\n-\n   /* If we have MEMs refering to different address spaces (which can\n      potentially overlap), we cannot easily tell from the addresses\n      whether the references overlap.  */\n@@ -2494,8 +2504,11 @@ write_dependence_p (const_rtx mem, const_rtx x, int writep)\n   x_addr = canon_rtx (x_addr);\n   mem_addr = canon_rtx (mem_addr);\n \n-  if (!memrefs_conflict_p (SIZE_FOR_MODE (mem), mem_addr,\n-\t\t\t   SIZE_FOR_MODE (x), x_addr, 0))\n+  if ((ret = memrefs_conflict_p (SIZE_FOR_MODE (mem), mem_addr,\n+\t\t\t\t SIZE_FOR_MODE (x), x_addr, 0)) != -1)\n+    return ret;\n+\n+  if (nonoverlapping_memrefs_p (x, mem))\n     return 0;\n \n   fixed_scalar"}]}