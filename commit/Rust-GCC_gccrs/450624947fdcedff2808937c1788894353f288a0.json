{"sha": "450624947fdcedff2808937c1788894353f288a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDUwNjI0OTQ3ZmRjZWRmZjI4MDg5MzdjMTc4ODg5NDM1M2YyODhhMA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-07-13T04:52:22Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-07-13T04:52:22Z"}, "message": "* tradcif.c: Remove.\n\nFrom-SVN: r35007", "tree": {"sha": "8e560e9a9f2f70137b2b32df1d0c46f616a503b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e560e9a9f2f70137b2b32df1d0c46f616a503b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/450624947fdcedff2808937c1788894353f288a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/450624947fdcedff2808937c1788894353f288a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/450624947fdcedff2808937c1788894353f288a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/450624947fdcedff2808937c1788894353f288a0/comments", "author": null, "committer": null, "parents": [{"sha": "c334349bda917012f51f629988006f9c72b7288a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c334349bda917012f51f629988006f9c72b7288a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c334349bda917012f51f629988006f9c72b7288a"}], "stats": {"total": 1545, "additions": 2, "deletions": 1543}, "files": [{"sha": "1cb16340243ddec3ed7abd4cd1a03e7631056be9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/450624947fdcedff2808937c1788894353f288a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/450624947fdcedff2808937c1788894353f288a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=450624947fdcedff2808937c1788894353f288a0", "patch": "@@ -7,6 +7,8 @@\n \t* tradcpp.c: Don't include signal.h.  Don't catch SIGPIPE.\n \tDelete pipe_closed.\n \n+\t* tradcif.c: Remove.\n+\n 2000-07-12  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* final.c (profile_function): Do not emit profile counters in"}, {"sha": "36d2fce44229761786903d73daa2ea415186ee24", "filename": "gcc/tradcif.c", "status": "removed", "additions": 0, "deletions": 1543, "changes": 1543, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c334349bda917012f51f629988006f9c72b7288a/gcc%2Ftradcif.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c334349bda917012f51f629988006f9c72b7288a/gcc%2Ftradcif.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftradcif.c?ref=c334349bda917012f51f629988006f9c72b7288a", "patch": "@@ -1,1543 +0,0 @@\n-\n-/*  A Bison parser, made from tradcif.y\n-    by GNU Bison version 1.28  */\n-\n-#define YYBISON 1  /* Identify Bison output.  */\n-\n-#define\tINT\t257\n-#define\tCHAR\t258\n-#define\tNAME\t259\n-#define\tERROR\t260\n-#define\tOR\t261\n-#define\tAND\t262\n-#define\tEQUAL\t263\n-#define\tNOTEQUAL\t264\n-#define\tLEQ\t265\n-#define\tGEQ\t266\n-#define\tLSH\t267\n-#define\tRSH\t268\n-#define\tUNARY\t269\n-\n-#line 26 \"tradcif.y\"\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include <setjmp.h>\n-\n-  int yylex PARAMS ((void));\n-  void yyerror PARAMS ((const char *msgid));\n-  extern void error   PARAMS ((const char *msgid, ...));\n-  extern void warning PARAMS ((const char *msgid, ...));\n-  extern struct hashnode *lookup PARAMS ((const unsigned char *, int, int));\n-\n-  int parse_number PARAMS ((int));\n-  int parse_escape PARAMS ((char **));\n-  int parse_c_expression PARAMS ((char *));\n-\n-  int expression_value;\n-  static jmp_buf parse_return_error;\n-\n-  /* some external tables of character types */\n-  extern unsigned char is_idstart[], is_idchar[];\n-\n-#ifndef CHAR_TYPE_SIZE\n-#define CHAR_TYPE_SIZE BITS_PER_UNIT\n-#endif\n-\n-#line 52 \"tradcif.y\"\n-typedef union {\n-  struct constant {long value; int unsignedp;} integer;\n-  int voidval;\n-  char *sval;\n-} YYSTYPE;\n-#include <stdio.h>\n-\n-#ifndef __cplusplus\n-#ifndef __STDC__\n-#define const\n-#endif\n-#endif\n-\n-\n-\n-#define\tYYFINAL\t\t61\n-#define\tYYFLAG\t\t-32768\n-#define\tYYNTBASE\t33\n-\n-#define YYTRANSLATE(x) ((unsigned)(x) <= 269 ? yytranslate[x] : 36)\n-\n-static const char yytranslate[] = {     0,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,    29,     2,     2,     2,    27,    14,     2,    31,\n-    32,    25,    23,     9,    24,     2,    26,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     8,     2,    17,\n-     2,    18,     7,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,    13,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,    12,     2,    30,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,\n-    10,    11,    15,    16,    19,    20,    21,    22,    28\n-};\n-\n-#if YYDEBUG != 0\n-static const short yyprhs[] = {     0,\n-     0,     2,     4,     8,    11,    14,    17,    20,    24,    28,\n-    32,    36,    40,    44,    48,    52,    56,    60,    64,    68,\n-    72,    76,    80,    84,    88,    92,    96,   102,   104,   106\n-};\n-\n-static const short yyrhs[] = {    34,\n-     0,    35,     0,    34,     9,    35,     0,    24,    35,     0,\n-    29,    35,     0,    23,    35,     0,    30,    35,     0,    31,\n-    34,    32,     0,    35,    25,    35,     0,    35,    26,    35,\n-     0,    35,    27,    35,     0,    35,    23,    35,     0,    35,\n-    24,    35,     0,    35,    21,    35,     0,    35,    22,    35,\n-     0,    35,    15,    35,     0,    35,    16,    35,     0,    35,\n-    19,    35,     0,    35,    20,    35,     0,    35,    17,    35,\n-     0,    35,    18,    35,     0,    35,    14,    35,     0,    35,\n-    13,    35,     0,    35,    12,    35,     0,    35,    11,    35,\n-     0,    35,    10,    35,     0,    35,     7,    35,     8,    35,\n-     0,     3,     0,     4,     0,     5,     0\n-};\n-\n-#endif\n-\n-#if YYDEBUG != 0\n-static const short yyrline[] = { 0,\n-    81,    86,    87,    92,    95,    98,   100,   103,   108,   114,\n-   125,   136,   139,   142,   148,   154,   157,   160,   167,   174,\n-   181,   188,   191,   194,   197,   200,   203,   206,   208,   210\n-};\n-#endif\n-\n-\n-#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)\n-\n-static const char * const yytname[] = {   \"$\",\"error\",\"$undefined.\",\"INT\",\"CHAR\",\n-\"NAME\",\"ERROR\",\"'?'\",\"':'\",\"','\",\"OR\",\"AND\",\"'|'\",\"'^'\",\"'&'\",\"EQUAL\",\"NOTEQUAL\",\n-\"'<'\",\"'>'\",\"LEQ\",\"GEQ\",\"LSH\",\"RSH\",\"'+'\",\"'-'\",\"'*'\",\"'/'\",\"'%'\",\"UNARY\",\"'!'\",\n-\"'~'\",\"'('\",\"')'\",\"start\",\"exp1\",\"exp\", NULL\n-};\n-#endif\n-\n-static const short yyr1[] = {     0,\n-    33,    34,    34,    35,    35,    35,    35,    35,    35,    35,\n-    35,    35,    35,    35,    35,    35,    35,    35,    35,    35,\n-    35,    35,    35,    35,    35,    35,    35,    35,    35,    35\n-};\n-\n-static const short yyr2[] = {     0,\n-     1,     1,     3,     2,     2,     2,     2,     3,     3,     3,\n-     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,\n-     3,     3,     3,     3,     3,     3,     5,     1,     1,     1\n-};\n-\n-static const short yydefact[] = {     0,\n-    28,    29,    30,     0,     0,     0,     0,     0,     1,     2,\n-     6,     4,     5,     7,     0,     0,     0,     0,     0,     0,\n-     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n-     0,     0,     0,     0,     0,     8,     3,     0,    26,    25,\n-    24,    23,    22,    16,    17,    20,    21,    18,    19,    14,\n-    15,    12,    13,     9,    10,    11,     0,    27,     0,     0,\n-     0\n-};\n-\n-static const short yydefgoto[] = {    59,\n-     9,    10\n-};\n-\n-static const short yypact[] = {    31,\n--32768,-32768,-32768,    31,    31,    31,    31,    31,     1,    77,\n--32768,-32768,-32768,-32768,     0,    31,    31,    31,    31,    31,\n-    31,    31,    31,    31,    31,    31,    31,    31,    31,    31,\n-    31,    31,    31,    31,    31,-32768,    77,    56,    94,    25,\n-   109,   123,   136,   147,   147,   154,   154,   154,   154,   -19,\n-   -19,    32,    32,-32768,-32768,-32768,    31,    77,    11,    33,\n--32768\n-};\n-\n-static const short yypgoto[] = {-32768,\n-    48,    -4\n-};\n-\n-\n-#define\tYYLAST\t\t181\n-\n-\n-static const short yytable[] = {    11,\n-    12,    13,    14,    31,    32,    33,    34,    35,    16,    16,\n-    60,    37,    38,    39,    40,    41,    42,    43,    44,    45,\n-    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,\n-    56,    36,    61,     1,     2,     3,    20,    21,    22,    23,\n-    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,\n-    34,    35,    58,     4,     5,    15,    33,    34,    35,     6,\n-     7,     8,    17,    57,     0,    18,    19,    20,    21,    22,\n-    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,\n-    33,    34,    35,    17,     0,     0,    18,    19,    20,    21,\n-    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,\n-    32,    33,    34,    35,    19,    20,    21,    22,    23,    24,\n-    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,\n-    35,    21,    22,    23,    24,    25,    26,    27,    28,    29,\n-    30,    31,    32,    33,    34,    35,    22,    23,    24,    25,\n-    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,\n-    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,\n-    33,    34,    35,    25,    26,    27,    28,    29,    30,    31,\n-    32,    33,    34,    35,    29,    30,    31,    32,    33,    34,\n-    35\n-};\n-\n-static const short yycheck[] = {     4,\n-     5,     6,     7,    23,    24,    25,    26,    27,     9,     9,\n-     0,    16,    17,    18,    19,    20,    21,    22,    23,    24,\n-    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,\n-    35,    32,     0,     3,     4,     5,    12,    13,    14,    15,\n-    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,\n-    26,    27,    57,    23,    24,     8,    25,    26,    27,    29,\n-    30,    31,     7,     8,    -1,    10,    11,    12,    13,    14,\n-    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,\n-    25,    26,    27,     7,    -1,    -1,    10,    11,    12,    13,\n-    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,\n-    24,    25,    26,    27,    11,    12,    13,    14,    15,    16,\n-    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,\n-    27,    13,    14,    15,    16,    17,    18,    19,    20,    21,\n-    22,    23,    24,    25,    26,    27,    14,    15,    16,    17,\n-    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,\n-    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,\n-    25,    26,    27,    17,    18,    19,    20,    21,    22,    23,\n-    24,    25,    26,    27,    21,    22,    23,    24,    25,    26,\n-    27\n-};\n-/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/share/misc/bison.simple\"\n-/* This file comes from bison-1.28.  */\n-\n-/* Skeleton output parser for bison,\n-   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 2, or (at your option)\n-   any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program; if not, write to the Free Software\n-   Foundation, Inc., 59 Temple Place - Suite 330,\n-   Boston, MA 02111-1307, USA.  */\n-\n-/* As a special exception, when this file is copied by Bison into a\n-   Bison output file, you may use that output file without restriction.\n-   This special exception was added by the Free Software Foundation\n-   in version 1.24 of Bison.  */\n-\n-/* This is the parser code that is written into each bison parser\n-  when the %semantic_parser declaration is not specified in the grammar.\n-  It was written by Richard Stallman by simplifying the hairy parser\n-  used when %semantic_parser is specified.  */\n-\n-#ifndef YYSTACK_USE_ALLOCA\n-#ifdef alloca\n-#define YYSTACK_USE_ALLOCA\n-#else /* alloca not defined */\n-#ifdef __GNUC__\n-#define YYSTACK_USE_ALLOCA\n-#define alloca __builtin_alloca\n-#else /* not GNU C.  */\n-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))\n-#define YYSTACK_USE_ALLOCA\n-#include <alloca.h>\n-#else /* not sparc */\n-/* We think this test detects Watcom and Microsoft C.  */\n-/* This used to test MSDOS, but that is a bad idea\n-   since that symbol is in the user namespace.  */\n-#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)\n-#if 0 /* No need for malloc.h, which pollutes the namespace;\n-\t instead, just don't use alloca.  */\n-#include <malloc.h>\n-#endif\n-#else /* not MSDOS, or __TURBOC__ */\n-#if defined(_AIX)\n-/* I don't know what this was needed for, but it pollutes the namespace.\n-   So I turned it off.   rms, 2 May 1997.  */\n-/* #include <malloc.h>  */\n- #pragma alloca\n-#define YYSTACK_USE_ALLOCA\n-#else /* not MSDOS, or __TURBOC__, or _AIX */\n-#if 0\n-#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,\n-\t\t and on HPUX 10.  Eventually we can turn this on.  */\n-#define YYSTACK_USE_ALLOCA\n-#define alloca __builtin_alloca\n-#endif /* __hpux */\n-#endif\n-#endif /* not _AIX */\n-#endif /* not MSDOS, or __TURBOC__ */\n-#endif /* not sparc */\n-#endif /* not GNU C */\n-#endif /* alloca not defined */\n-#endif /* YYSTACK_USE_ALLOCA not defined */\n-\n-#ifdef YYSTACK_USE_ALLOCA\n-#define YYSTACK_ALLOC alloca\n-#else\n-#define YYSTACK_ALLOC malloc\n-#endif\n-\n-/* Note: there must be only one dollar sign in this file.\n-   It is replaced by the list of actions, each action\n-   as one case of the switch.  */\n-\n-#define yyerrok\t\t(yyerrstatus = 0)\n-#define yyclearin\t(yychar = YYEMPTY)\n-#define YYEMPTY\t\t-2\n-#define YYEOF\t\t0\n-#define YYACCEPT\tgoto yyacceptlab\n-#define YYABORT \tgoto yyabortlab\n-#define YYERROR\t\tgoto yyerrlab1\n-/* Like YYERROR except do call yyerror.\n-   This remains here temporarily to ease the\n-   transition to the new meaning of YYERROR, for GCC.\n-   Once GCC version 2 has supplanted version 1, this can go.  */\n-#define YYFAIL\t\tgoto yyerrlab\n-#define YYRECOVERING()  (!!yyerrstatus)\n-#define YYBACKUP(token, value) \\\n-do\t\t\t\t\t\t\t\t\\\n-  if (yychar == YYEMPTY && yylen == 1)\t\t\t\t\\\n-    { yychar = (token), yylval = (value);\t\t\t\\\n-      yychar1 = YYTRANSLATE (yychar);\t\t\t\t\\\n-      YYPOPSTACK;\t\t\t\t\t\t\\\n-      goto yybackup;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    { yyerror (\"syntax error: cannot back up\"); YYERROR; }\t\\\n-while (0)\n-\n-#define YYTERROR\t1\n-#define YYERRCODE\t256\n-\n-#ifndef YYPURE\n-#define YYLEX\t\tyylex()\n-#endif\n-\n-#ifdef YYPURE\n-#ifdef YYLSP_NEEDED\n-#ifdef YYLEX_PARAM\n-#define YYLEX\t\tyylex(&yylval, &yylloc, YYLEX_PARAM)\n-#else\n-#define YYLEX\t\tyylex(&yylval, &yylloc)\n-#endif\n-#else /* not YYLSP_NEEDED */\n-#ifdef YYLEX_PARAM\n-#define YYLEX\t\tyylex(&yylval, YYLEX_PARAM)\n-#else\n-#define YYLEX\t\tyylex(&yylval)\n-#endif\n-#endif /* not YYLSP_NEEDED */\n-#endif\n-\n-/* If nonreentrant, generate the variables here */\n-\n-#ifndef YYPURE\n-\n-int\tyychar;\t\t\t/*  the lookahead symbol\t\t*/\n-YYSTYPE\tyylval;\t\t\t/*  the semantic value of the\t\t*/\n-\t\t\t\t/*  lookahead symbol\t\t\t*/\n-\n-#ifdef YYLSP_NEEDED\n-YYLTYPE yylloc;\t\t\t/*  location data for the lookahead\t*/\n-\t\t\t\t/*  symbol\t\t\t\t*/\n-#endif\n-\n-int yynerrs;\t\t\t/*  number of parse errors so far       */\n-#endif  /* not YYPURE */\n-\n-#if YYDEBUG != 0\n-int yydebug;\t\t\t/*  nonzero means print parse trace\t*/\n-/* Since this is uninitialized, it does not stop multiple parsers\n-   from coexisting.  */\n-#endif\n-\n-/*  YYINITDEPTH indicates the initial size of the parser's stacks\t*/\n-\n-#ifndef\tYYINITDEPTH\n-#define YYINITDEPTH 200\n-#endif\n-\n-/*  YYMAXDEPTH is the maximum size the stacks can grow to\n-    (effective only if the built-in stack extension method is used).  */\n-\n-#if YYMAXDEPTH == 0\n-#undef YYMAXDEPTH\n-#endif\n-\n-#ifndef YYMAXDEPTH\n-#define YYMAXDEPTH 10000\n-#endif\n-\f\n-/* Define __yy_memcpy.  Note that the size argument\n-   should be passed with type unsigned int, because that is what the non-GCC\n-   definitions require.  With GCC, __builtin_memcpy takes an arg\n-   of type size_t, but it can handle unsigned int.  */\n-\n-#if __GNUC__ > 1\t\t/* GNU C and GNU C++ define this.  */\n-#define __yy_memcpy(TO,FROM,COUNT)\t__builtin_memcpy(TO,FROM,COUNT)\n-#else\t\t\t\t/* not GNU C or C++ */\n-#ifndef __cplusplus\n-\n-/* This is the most reliable way to avoid incompatibilities\n-   in available built-in functions on various systems.  */\n-static void\n-__yy_memcpy (to, from, count)\n-     char *to;\n-     char *from;\n-     unsigned int count;\n-{\n-  register char *f = from;\n-  register char *t = to;\n-  register int i = count;\n-\n-  while (i-- > 0)\n-    *t++ = *f++;\n-}\n-\n-#else /* __cplusplus */\n-\n-/* This is the most reliable way to avoid incompatibilities\n-   in available built-in functions on various systems.  */\n-static void\n-__yy_memcpy (char *to, char *from, unsigned int count)\n-{\n-  register char *t = to;\n-  register char *f = from;\n-  register int i = count;\n-\n-  while (i-- > 0)\n-    *t++ = *f++;\n-}\n-\n-#endif\n-#endif\n-\f\n-#line 217 \"/usr/share/misc/bison.simple\"\n-\n-/* The user can define YYPARSE_PARAM as the name of an argument to be passed\n-   into yyparse.  The argument should have type void *.\n-   It should actually point to an object.\n-   Grammar actions can access the variable by casting it\n-   to the proper pointer type.  */\n-\n-#ifdef YYPARSE_PARAM\n-#ifdef __cplusplus\n-#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM\n-#define YYPARSE_PARAM_DECL\n-#else /* not __cplusplus */\n-#define YYPARSE_PARAM_ARG YYPARSE_PARAM\n-#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;\n-#endif /* not __cplusplus */\n-#else /* not YYPARSE_PARAM */\n-#define YYPARSE_PARAM_ARG\n-#define YYPARSE_PARAM_DECL\n-#endif /* not YYPARSE_PARAM */\n-\n-/* Prevent warning if -Wstrict-prototypes.  */\n-#ifdef __GNUC__\n-#ifdef YYPARSE_PARAM\n-int yyparse (void *);\n-#else\n-int yyparse (void);\n-#endif\n-#endif\n-\n-int\n-yyparse(YYPARSE_PARAM_ARG)\n-     YYPARSE_PARAM_DECL\n-{\n-  register int yystate;\n-  register int yyn;\n-  register short *yyssp;\n-  register YYSTYPE *yyvsp;\n-  int yyerrstatus;\t/*  number of tokens to shift before error messages enabled */\n-  int yychar1 = 0;\t\t/*  lookahead token as an internal (translated) token number */\n-\n-  short\tyyssa[YYINITDEPTH];\t/*  the state stack\t\t\t*/\n-  YYSTYPE yyvsa[YYINITDEPTH];\t/*  the semantic value stack\t\t*/\n-\n-  short *yyss = yyssa;\t\t/*  refer to the stacks thru separate pointers */\n-  YYSTYPE *yyvs = yyvsa;\t/*  to allow yyoverflow to reallocate them elsewhere */\n-\n-#ifdef YYLSP_NEEDED\n-  YYLTYPE yylsa[YYINITDEPTH];\t/*  the location stack\t\t\t*/\n-  YYLTYPE *yyls = yylsa;\n-  YYLTYPE *yylsp;\n-\n-#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)\n-#else\n-#define YYPOPSTACK   (yyvsp--, yyssp--)\n-#endif\n-\n-  int yystacksize = YYINITDEPTH;\n-  int yyfree_stacks = 0;\n-\n-#ifdef YYPURE\n-  int yychar;\n-  YYSTYPE yylval;\n-  int yynerrs;\n-#ifdef YYLSP_NEEDED\n-  YYLTYPE yylloc;\n-#endif\n-#endif\n-\n-  YYSTYPE yyval;\t\t/*  the variable used to return\t\t*/\n-\t\t\t\t/*  semantic values from the action\t*/\n-\t\t\t\t/*  routines\t\t\t\t*/\n-\n-  int yylen;\n-\n-#if YYDEBUG != 0\n-  if (yydebug)\n-    fprintf(stderr, \"Starting parse\\n\");\n-#endif\n-\n-  yystate = 0;\n-  yyerrstatus = 0;\n-  yynerrs = 0;\n-  yychar = YYEMPTY;\t\t/* Cause a token to be read.  */\n-\n-  /* Initialize stack pointers.\n-     Waste one element of value and location stack\n-     so that they stay on the same level as the state stack.\n-     The wasted elements are never initialized.  */\n-\n-  yyssp = yyss - 1;\n-  yyvsp = yyvs;\n-#ifdef YYLSP_NEEDED\n-  yylsp = yyls;\n-#endif\n-\n-/* Push a new state, which is found in  yystate  .  */\n-/* In all cases, when you get here, the value and location stacks\n-   have just been pushed. so pushing a state here evens the stacks.  */\n-yynewstate:\n-\n-  *++yyssp = yystate;\n-\n-  if (yyssp >= yyss + yystacksize - 1)\n-    {\n-      /* Give user a chance to reallocate the stack */\n-      /* Use copies of these so that the &'s don't force the real ones into memory. */\n-      YYSTYPE *yyvs1 = yyvs;\n-      short *yyss1 = yyss;\n-#ifdef YYLSP_NEEDED\n-      YYLTYPE *yyls1 = yyls;\n-#endif\n-\n-      /* Get the current used size of the three stacks, in elements.  */\n-      int size = yyssp - yyss + 1;\n-\n-#ifdef yyoverflow\n-      /* Each stack pointer address is followed by the size of\n-\t the data in use in that stack, in bytes.  */\n-#ifdef YYLSP_NEEDED\n-      /* This used to be a conditional around just the two extra args,\n-\t but that might be undefined if yyoverflow is a macro.  */\n-      yyoverflow(\"parser stack overflow\",\n-\t\t &yyss1, size * sizeof (*yyssp),\n-\t\t &yyvs1, size * sizeof (*yyvsp),\n-\t\t &yyls1, size * sizeof (*yylsp),\n-\t\t &yystacksize);\n-#else\n-      yyoverflow(\"parser stack overflow\",\n-\t\t &yyss1, size * sizeof (*yyssp),\n-\t\t &yyvs1, size * sizeof (*yyvsp),\n-\t\t &yystacksize);\n-#endif\n-\n-      yyss = yyss1; yyvs = yyvs1;\n-#ifdef YYLSP_NEEDED\n-      yyls = yyls1;\n-#endif\n-#else /* no yyoverflow */\n-      /* Extend the stack our own way.  */\n-      if (yystacksize >= YYMAXDEPTH)\n-\t{\n-\t  yyerror(\"parser stack overflow\");\n-\t  if (yyfree_stacks)\n-\t    {\n-\t      free (yyss);\n-\t      free (yyvs);\n-#ifdef YYLSP_NEEDED\n-\t      free (yyls);\n-#endif\n-\t    }\n-\t  return 2;\n-\t}\n-      yystacksize *= 2;\n-      if (yystacksize > YYMAXDEPTH)\n-\tyystacksize = YYMAXDEPTH;\n-#ifndef YYSTACK_USE_ALLOCA\n-      yyfree_stacks = 1;\n-#endif\n-      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));\n-      __yy_memcpy ((char *)yyss, (char *)yyss1,\n-\t\t   size * (unsigned int) sizeof (*yyssp));\n-      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));\n-      __yy_memcpy ((char *)yyvs, (char *)yyvs1,\n-\t\t   size * (unsigned int) sizeof (*yyvsp));\n-#ifdef YYLSP_NEEDED\n-      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));\n-      __yy_memcpy ((char *)yyls, (char *)yyls1,\n-\t\t   size * (unsigned int) sizeof (*yylsp));\n-#endif\n-#endif /* no yyoverflow */\n-\n-      yyssp = yyss + size - 1;\n-      yyvsp = yyvs + size - 1;\n-#ifdef YYLSP_NEEDED\n-      yylsp = yyls + size - 1;\n-#endif\n-\n-#if YYDEBUG != 0\n-      if (yydebug)\n-\tfprintf(stderr, \"Stack size increased to %d\\n\", yystacksize);\n-#endif\n-\n-      if (yyssp >= yyss + yystacksize - 1)\n-\tYYABORT;\n-    }\n-\n-#if YYDEBUG != 0\n-  if (yydebug)\n-    fprintf(stderr, \"Entering state %d\\n\", yystate);\n-#endif\n-\n-  goto yybackup;\n- yybackup:\n-\n-/* Do appropriate processing given the current state.  */\n-/* Read a lookahead token if we need one and don't already have one.  */\n-/* yyresume: */\n-\n-  /* First try to decide what to do without reference to lookahead token.  */\n-\n-  yyn = yypact[yystate];\n-  if (yyn == YYFLAG)\n-    goto yydefault;\n-\n-  /* Not known => get a lookahead token if don't already have one.  */\n-\n-  /* yychar is either YYEMPTY or YYEOF\n-     or a valid token in external form.  */\n-\n-  if (yychar == YYEMPTY)\n-    {\n-#if YYDEBUG != 0\n-      if (yydebug)\n-\tfprintf(stderr, \"Reading a token: \");\n-#endif\n-      yychar = YYLEX;\n-    }\n-\n-  /* Convert token to internal form (in yychar1) for indexing tables with */\n-\n-  if (yychar <= 0)\t\t/* This means end of input. */\n-    {\n-      yychar1 = 0;\n-      yychar = YYEOF;\t\t/* Don't call YYLEX any more */\n-\n-#if YYDEBUG != 0\n-      if (yydebug)\n-\tfprintf(stderr, \"Now at end of input.\\n\");\n-#endif\n-    }\n-  else\n-    {\n-      yychar1 = YYTRANSLATE(yychar);\n-\n-#if YYDEBUG != 0\n-      if (yydebug)\n-\t{\n-\t  fprintf (stderr, \"Next token is %d (%s\", yychar, yytname[yychar1]);\n-\t  /* Give the individual parser a way to print the precise meaning\n-\t     of a token, for further debugging info.  */\n-#ifdef YYPRINT\n-\t  YYPRINT (stderr, yychar, yylval);\n-#endif\n-\t  fprintf (stderr, \")\\n\");\n-\t}\n-#endif\n-    }\n-\n-  yyn += yychar1;\n-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)\n-    goto yydefault;\n-\n-  yyn = yytable[yyn];\n-\n-  /* yyn is what to do for this token type in this state.\n-     Negative => reduce, -yyn is rule number.\n-     Positive => shift, yyn is new state.\n-       New state is final state => don't bother to shift,\n-       just return success.\n-     0, or most negative number => error.  */\n-\n-  if (yyn < 0)\n-    {\n-      if (yyn == YYFLAG)\n-\tgoto yyerrlab;\n-      yyn = -yyn;\n-      goto yyreduce;\n-    }\n-  else if (yyn == 0)\n-    goto yyerrlab;\n-\n-  if (yyn == YYFINAL)\n-    YYACCEPT;\n-\n-  /* Shift the lookahead token.  */\n-\n-#if YYDEBUG != 0\n-  if (yydebug)\n-    fprintf(stderr, \"Shifting token %d (%s), \", yychar, yytname[yychar1]);\n-#endif\n-\n-  /* Discard the token being shifted unless it is eof.  */\n-  if (yychar != YYEOF)\n-    yychar = YYEMPTY;\n-\n-  *++yyvsp = yylval;\n-#ifdef YYLSP_NEEDED\n-  *++yylsp = yylloc;\n-#endif\n-\n-  /* count tokens shifted since error; after three, turn off error status.  */\n-  if (yyerrstatus) yyerrstatus--;\n-\n-  yystate = yyn;\n-  goto yynewstate;\n-\n-/* Do the default action for the current state.  */\n-yydefault:\n-\n-  yyn = yydefact[yystate];\n-  if (yyn == 0)\n-    goto yyerrlab;\n-\n-/* Do a reduction.  yyn is the number of a rule to reduce with.  */\n-yyreduce:\n-  yylen = yyr2[yyn];\n-  if (yylen > 0)\n-    yyval = yyvsp[1-yylen]; /* implement default value of the action */\n-\n-#if YYDEBUG != 0\n-  if (yydebug)\n-    {\n-      int i;\n-\n-      fprintf (stderr, \"Reducing via rule %d (line %d), \",\n-\t       yyn, yyrline[yyn]);\n-\n-      /* Print the symbols being reduced, and their result.  */\n-      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)\n-\tfprintf (stderr, \"%s \", yytname[yyrhs[i]]);\n-      fprintf (stderr, \" -> %s\\n\", yytname[yyr1[yyn]]);\n-    }\n-#endif\n-\n-\n-  switch (yyn) {\n-\n-case 1:\n-#line 82 \"tradcif.y\"\n-{ expression_value = yyvsp[0].integer.value; ;\n-    break;}\n-case 3:\n-#line 88 \"tradcif.y\"\n-{ yyval.integer = yyvsp[0].integer; ;\n-    break;}\n-case 4:\n-#line 93 \"tradcif.y\"\n-{ yyval.integer.value = - yyvsp[0].integer.value;\n-\t\t\t  yyval.integer.unsignedp = yyvsp[0].integer.unsignedp; ;\n-    break;}\n-case 5:\n-#line 96 \"tradcif.y\"\n-{ yyval.integer.value = ! yyvsp[0].integer.value;\n-\t\t\t  yyval.integer.unsignedp = 0; ;\n-    break;}\n-case 6:\n-#line 99 \"tradcif.y\"\n-{ yyval.integer = yyvsp[0].integer; ;\n-    break;}\n-case 7:\n-#line 101 \"tradcif.y\"\n-{ yyval.integer.value = ~ yyvsp[0].integer.value;\n-\t\t\t  yyval.integer.unsignedp = yyvsp[0].integer.unsignedp; ;\n-    break;}\n-case 8:\n-#line 104 \"tradcif.y\"\n-{ yyval.integer = yyvsp[-1].integer; ;\n-    break;}\n-case 9:\n-#line 109 \"tradcif.y\"\n-{ yyval.integer.unsignedp = yyvsp[-2].integer.unsignedp || yyvsp[0].integer.unsignedp;\n-\t\t\t  if (yyval.integer.unsignedp)\n-\t\t\t    yyval.integer.value = (unsigned) yyvsp[-2].integer.value * yyvsp[0].integer.value;\n-\t\t\t  else\n-\t\t\t    yyval.integer.value = yyvsp[-2].integer.value * yyvsp[0].integer.value; ;\n-    break;}\n-case 10:\n-#line 115 \"tradcif.y\"\n-{ if (yyvsp[0].integer.value == 0)\n-\t\t\t    {\n-\t\t\t      error (\"division by zero in #if\");\n-\t\t\t      yyvsp[0].integer.value = 1;\n-\t\t\t    }\n-\t\t\t  yyval.integer.unsignedp = yyvsp[-2].integer.unsignedp || yyvsp[0].integer.unsignedp;\n-\t\t\t  if (yyval.integer.unsignedp)\n-\t\t\t    yyval.integer.value = (unsigned) yyvsp[-2].integer.value / yyvsp[0].integer.value;\n-\t\t\t  else\n-\t\t\t    yyval.integer.value = yyvsp[-2].integer.value / yyvsp[0].integer.value; ;\n-    break;}\n-case 11:\n-#line 126 \"tradcif.y\"\n-{ if (yyvsp[0].integer.value == 0)\n-\t\t\t    {\n-\t\t\t      error (\"division by zero in #if\");\n-\t\t\t      yyvsp[0].integer.value = 1;\n-\t\t\t    }\n-\t\t\t  yyval.integer.unsignedp = yyvsp[-2].integer.unsignedp || yyvsp[0].integer.unsignedp;\n-\t\t\t  if (yyval.integer.unsignedp)\n-\t\t\t    yyval.integer.value = (unsigned) yyvsp[-2].integer.value % yyvsp[0].integer.value;\n-\t\t\t  else\n-\t\t\t    yyval.integer.value = yyvsp[-2].integer.value % yyvsp[0].integer.value; ;\n-    break;}\n-case 12:\n-#line 137 \"tradcif.y\"\n-{ yyval.integer.value = yyvsp[-2].integer.value + yyvsp[0].integer.value;\n-\t\t\t  yyval.integer.unsignedp = yyvsp[-2].integer.unsignedp || yyvsp[0].integer.unsignedp; ;\n-    break;}\n-case 13:\n-#line 140 \"tradcif.y\"\n-{ yyval.integer.value = yyvsp[-2].integer.value - yyvsp[0].integer.value;\n-\t\t\t  yyval.integer.unsignedp = yyvsp[-2].integer.unsignedp || yyvsp[0].integer.unsignedp; ;\n-    break;}\n-case 14:\n-#line 143 \"tradcif.y\"\n-{ yyval.integer.unsignedp = yyvsp[-2].integer.unsignedp;\n-\t\t\t  if (yyval.integer.unsignedp)\n-\t\t\t    yyval.integer.value = (unsigned) yyvsp[-2].integer.value << yyvsp[0].integer.value;\n-\t\t\t  else\n-\t\t\t    yyval.integer.value = yyvsp[-2].integer.value << yyvsp[0].integer.value; ;\n-    break;}\n-case 15:\n-#line 149 \"tradcif.y\"\n-{ yyval.integer.unsignedp = yyvsp[-2].integer.unsignedp;\n-\t\t\t  if (yyval.integer.unsignedp)\n-\t\t\t    yyval.integer.value = (unsigned) yyvsp[-2].integer.value >> yyvsp[0].integer.value;\n-\t\t\t  else\n-\t\t\t    yyval.integer.value = yyvsp[-2].integer.value >> yyvsp[0].integer.value; ;\n-    break;}\n-case 16:\n-#line 155 \"tradcif.y\"\n-{ yyval.integer.value = (yyvsp[-2].integer.value == yyvsp[0].integer.value);\n-\t\t\t  yyval.integer.unsignedp = 0; ;\n-    break;}\n-case 17:\n-#line 158 \"tradcif.y\"\n-{ yyval.integer.value = (yyvsp[-2].integer.value != yyvsp[0].integer.value);\n-\t\t\t  yyval.integer.unsignedp = 0; ;\n-    break;}\n-case 18:\n-#line 161 \"tradcif.y\"\n-{ yyval.integer.unsignedp = 0;\n-\t\t\t  if (yyvsp[-2].integer.unsignedp || yyvsp[0].integer.unsignedp)\n-\t\t\t    yyval.integer.value =\n-\t\t\t      (unsigned) yyvsp[-2].integer.value <= (unsigned) yyvsp[0].integer.value;\n-\t\t\t  else\n-\t\t\t    yyval.integer.value = yyvsp[-2].integer.value <= yyvsp[0].integer.value; ;\n-    break;}\n-case 19:\n-#line 168 \"tradcif.y\"\n-{ yyval.integer.unsignedp = 0;\n-\t\t\t  if (yyvsp[-2].integer.unsignedp || yyvsp[0].integer.unsignedp)\n-\t\t\t    yyval.integer.value =\n-\t\t\t      (unsigned) yyvsp[-2].integer.value >= (unsigned) yyvsp[0].integer.value;\n-\t\t\t  else\n-\t\t\t    yyval.integer.value = yyvsp[-2].integer.value >= yyvsp[0].integer.value; ;\n-    break;}\n-case 20:\n-#line 175 \"tradcif.y\"\n-{ yyval.integer.unsignedp = 0;\n-\t\t\t  if (yyvsp[-2].integer.unsignedp || yyvsp[0].integer.unsignedp)\n-\t\t\t    yyval.integer.value =\n-\t\t\t      (unsigned) yyvsp[-2].integer.value < (unsigned) yyvsp[0].integer.value;\n-\t\t\t  else\n-\t\t\t    yyval.integer.value = yyvsp[-2].integer.value < yyvsp[0].integer.value; ;\n-    break;}\n-case 21:\n-#line 182 \"tradcif.y\"\n-{ yyval.integer.unsignedp = 0;\n-\t\t\t  if (yyvsp[-2].integer.unsignedp || yyvsp[0].integer.unsignedp)\n-\t\t\t    yyval.integer.value =\n-\t\t\t      (unsigned) yyvsp[-2].integer.value > (unsigned) yyvsp[0].integer.value;\n-\t\t\t  else\n-\t\t\t    yyval.integer.value = yyvsp[-2].integer.value > yyvsp[0].integer.value; ;\n-    break;}\n-case 22:\n-#line 189 \"tradcif.y\"\n-{ yyval.integer.value = yyvsp[-2].integer.value & yyvsp[0].integer.value;\n-\t\t\t  yyval.integer.unsignedp = yyvsp[-2].integer.unsignedp || yyvsp[0].integer.unsignedp; ;\n-    break;}\n-case 23:\n-#line 192 \"tradcif.y\"\n-{ yyval.integer.value = yyvsp[-2].integer.value ^ yyvsp[0].integer.value;\n-\t\t\t  yyval.integer.unsignedp = yyvsp[-2].integer.unsignedp || yyvsp[0].integer.unsignedp; ;\n-    break;}\n-case 24:\n-#line 195 \"tradcif.y\"\n-{ yyval.integer.value = yyvsp[-2].integer.value | yyvsp[0].integer.value;\n-\t\t\t  yyval.integer.unsignedp = yyvsp[-2].integer.unsignedp || yyvsp[0].integer.unsignedp; ;\n-    break;}\n-case 25:\n-#line 198 \"tradcif.y\"\n-{ yyval.integer.value = (yyvsp[-2].integer.value && yyvsp[0].integer.value);\n-\t\t\t  yyval.integer.unsignedp = 0; ;\n-    break;}\n-case 26:\n-#line 201 \"tradcif.y\"\n-{ yyval.integer.value = (yyvsp[-2].integer.value || yyvsp[0].integer.value);\n-\t\t\t  yyval.integer.unsignedp = 0; ;\n-    break;}\n-case 27:\n-#line 204 \"tradcif.y\"\n-{ yyval.integer.value = yyvsp[-4].integer.value ? yyvsp[-2].integer.value : yyvsp[0].integer.value;\n-\t\t\t  yyval.integer.unsignedp = yyvsp[-2].integer.unsignedp || yyvsp[0].integer.unsignedp; ;\n-    break;}\n-case 28:\n-#line 207 \"tradcif.y\"\n-{ yyval.integer = yylval.integer; ;\n-    break;}\n-case 29:\n-#line 209 \"tradcif.y\"\n-{ yyval.integer = yylval.integer; ;\n-    break;}\n-case 30:\n-#line 211 \"tradcif.y\"\n-{ yyval.integer.value = 0;\n-\t\t\t  yyval.integer.unsignedp = 0; ;\n-    break;}\n-}\n-   /* the action file gets copied in in place of this dollarsign */\n-#line 543 \"/usr/share/misc/bison.simple\"\n-\f\n-  yyvsp -= yylen;\n-  yyssp -= yylen;\n-#ifdef YYLSP_NEEDED\n-  yylsp -= yylen;\n-#endif\n-\n-#if YYDEBUG != 0\n-  if (yydebug)\n-    {\n-      short *ssp1 = yyss - 1;\n-      fprintf (stderr, \"state stack now\");\n-      while (ssp1 != yyssp)\n-\tfprintf (stderr, \" %d\", *++ssp1);\n-      fprintf (stderr, \"\\n\");\n-    }\n-#endif\n-\n-  *++yyvsp = yyval;\n-\n-#ifdef YYLSP_NEEDED\n-  yylsp++;\n-  if (yylen == 0)\n-    {\n-      yylsp->first_line = yylloc.first_line;\n-      yylsp->first_column = yylloc.first_column;\n-      yylsp->last_line = (yylsp-1)->last_line;\n-      yylsp->last_column = (yylsp-1)->last_column;\n-      yylsp->text = 0;\n-    }\n-  else\n-    {\n-      yylsp->last_line = (yylsp+yylen-1)->last_line;\n-      yylsp->last_column = (yylsp+yylen-1)->last_column;\n-    }\n-#endif\n-\n-  /* Now \"shift\" the result of the reduction.\n-     Determine what state that goes to,\n-     based on the state we popped back to\n-     and the rule number reduced by.  */\n-\n-  yyn = yyr1[yyn];\n-\n-  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;\n-  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n-    yystate = yytable[yystate];\n-  else\n-    yystate = yydefgoto[yyn - YYNTBASE];\n-\n-  goto yynewstate;\n-\n-yyerrlab:   /* here on detecting error */\n-\n-  if (! yyerrstatus)\n-    /* If not already recovering from an error, report this error.  */\n-    {\n-      ++yynerrs;\n-\n-#ifdef YYERROR_VERBOSE\n-      yyn = yypact[yystate];\n-\n-      if (yyn > YYFLAG && yyn < YYLAST)\n-\t{\n-\t  int size = 0;\n-\t  char *msg;\n-\t  int x, count;\n-\n-\t  count = 0;\n-\t  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */\n-\t  for (x = (yyn < 0 ? -yyn : 0);\n-\t       x < (sizeof(yytname) / sizeof(char *)); x++)\n-\t    if (yycheck[x + yyn] == x)\n-\t      size += strlen(yytname[x]) + 15, count++;\n-\t  msg = (char *) malloc(size + 15);\n-\t  if (msg != 0)\n-\t    {\n-\t      strcpy(msg, \"parse error\");\n-\n-\t      if (count < 5)\n-\t\t{\n-\t\t  count = 0;\n-\t\t  for (x = (yyn < 0 ? -yyn : 0);\n-\t\t       x < (sizeof(yytname) / sizeof(char *)); x++)\n-\t\t    if (yycheck[x + yyn] == x)\n-\t\t      {\n-\t\t\tstrcat(msg, count == 0 ? \", expecting `\" : \" or `\");\n-\t\t\tstrcat(msg, yytname[x]);\n-\t\t\tstrcat(msg, \"'\");\n-\t\t\tcount++;\n-\t\t      }\n-\t\t}\n-\t      yyerror(msg);\n-\t      free(msg);\n-\t    }\n-\t  else\n-\t    yyerror (\"parse error; also virtual memory exceeded\");\n-\t}\n-      else\n-#endif /* YYERROR_VERBOSE */\n-\tyyerror(\"parse error\");\n-    }\n-\n-  goto yyerrlab1;\n-yyerrlab1:   /* here on error raised explicitly by an action */\n-\n-  if (yyerrstatus == 3)\n-    {\n-      /* if just tried and failed to reuse lookahead token after an error, discard it.  */\n-\n-      /* return failure if at end of input */\n-      if (yychar == YYEOF)\n-\tYYABORT;\n-\n-#if YYDEBUG != 0\n-      if (yydebug)\n-\tfprintf(stderr, \"Discarding token %d (%s).\\n\", yychar, yytname[yychar1]);\n-#endif\n-\n-      yychar = YYEMPTY;\n-    }\n-\n-  /* Else will try to reuse lookahead token\n-     after shifting the error token.  */\n-\n-  yyerrstatus = 3;\t\t/* Each real token shifted decrements this */\n-\n-  goto yyerrhandle;\n-\n-yyerrdefault:  /* current state does not do anything special for the error token. */\n-\n-#if 0\n-  /* This is wrong; only states that explicitly want error tokens\n-     should shift them.  */\n-  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/\n-  if (yyn) goto yydefault;\n-#endif\n-\n-yyerrpop:   /* pop the current state because it cannot handle the error token */\n-\n-  if (yyssp == yyss) YYABORT;\n-  yyvsp--;\n-  yystate = *--yyssp;\n-#ifdef YYLSP_NEEDED\n-  yylsp--;\n-#endif\n-\n-#if YYDEBUG != 0\n-  if (yydebug)\n-    {\n-      short *ssp1 = yyss - 1;\n-      fprintf (stderr, \"Error: state stack now\");\n-      while (ssp1 != yyssp)\n-\tfprintf (stderr, \" %d\", *++ssp1);\n-      fprintf (stderr, \"\\n\");\n-    }\n-#endif\n-\n-yyerrhandle:\n-\n-  yyn = yypact[yystate];\n-  if (yyn == YYFLAG)\n-    goto yyerrdefault;\n-\n-  yyn += YYTERROR;\n-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)\n-    goto yyerrdefault;\n-\n-  yyn = yytable[yyn];\n-  if (yyn < 0)\n-    {\n-      if (yyn == YYFLAG)\n-\tgoto yyerrpop;\n-      yyn = -yyn;\n-      goto yyreduce;\n-    }\n-  else if (yyn == 0)\n-    goto yyerrpop;\n-\n-  if (yyn == YYFINAL)\n-    YYACCEPT;\n-\n-#if YYDEBUG != 0\n-  if (yydebug)\n-    fprintf(stderr, \"Shifting error token, \");\n-#endif\n-\n-  *++yyvsp = yylval;\n-#ifdef YYLSP_NEEDED\n-  *++yylsp = yylloc;\n-#endif\n-\n-  yystate = yyn;\n-  goto yynewstate;\n-\n- yyacceptlab:\n-  /* YYACCEPT comes here.  */\n-  if (yyfree_stacks)\n-    {\n-      free (yyss);\n-      free (yyvs);\n-#ifdef YYLSP_NEEDED\n-      free (yyls);\n-#endif\n-    }\n-  return 0;\n-\n- yyabortlab:\n-  /* YYABORT comes here.  */\n-  if (yyfree_stacks)\n-    {\n-      free (yyss);\n-      free (yyvs);\n-#ifdef YYLSP_NEEDED\n-      free (yyls);\n-#endif\n-    }\n-  return 1;\n-}\n-#line 214 \"tradcif.y\"\n-\n-\f\n-/* During parsing of a C expression, the pointer to the next character\n-   is in this variable.  */\n-\n-static char *lexptr;\n-\n-/* Take care of parsing a number (anything that starts with a digit).\n-   Set yylval and return the token type; update lexptr.\n-   LEN is the number of characters in it.  */\n-\n-/* maybe needs to actually deal with floating point numbers */\n-\n-int\n-parse_number (olen)\n-     int olen;\n-{\n-  register char *p = lexptr;\n-  register long n = 0;\n-  register int c;\n-  register int base = 10;\n-  register int len = olen;\n-\n-  for (c = 0; c < len; c++)\n-    if (p[c] == '.') {\n-      /* It's a float since it contains a point.  */\n-      yyerror (\"floating point numbers not allowed in #if expressions\");\n-      return ERROR;\n-    }\n-\n-  yylval.integer.unsignedp = 0;\n-\n-  if (len >= 3 && (!strncmp (p, \"0x\", 2) || !strncmp (p, \"0X\", 2))) {\n-    p += 2;\n-    base = 16;\n-    len -= 2;\n-  }\n-  else if (*p == '0')\n-    base = 8;\n-\n-  while (len > 0) {\n-    c = *p++;\n-    len--;\n-    if (c >= 'A' && c <= 'Z') c += 'a' - 'A';\n-\n-    if (c >= '0' && c <= '9') {\n-      n *= base;\n-      n += c - '0';\n-    } else if (base == 16 && c >= 'a' && c <= 'f') {\n-      n *= base;\n-      n += c - 'a' + 10;\n-    } else {\n-      /* `l' means long, and `u' means unsigned.  */\n-      while (1) {\n-\tif (c == 'l' || c == 'L')\n-\t  ;\n-\telse if (c == 'u' || c == 'U')\n-\t  yylval.integer.unsignedp = 1;\n-\telse\n-\t  break;\n-\n-\tif (len == 0)\n-\t  break;\n-\tc = *p++;\n-\tlen--;\n-      }\n-      /* Don't look for any more digits after the suffixes.  */\n-      break;\n-    }\n-  }\n-\n-  if (len != 0) {\n-    yyerror (\"Invalid number in #if expression\");\n-    return ERROR;\n-  }\n-\n-  /* If too big to be signed, consider it unsigned.  */\n-  if (n < 0)\n-    yylval.integer.unsignedp = 1;\n-\n-  lexptr = p;\n-  yylval.integer.value = n;\n-  return INT;\n-}\n-\n-struct token {\n-  const char *operator;\n-  int token;\n-};\n-\n-#ifndef NULL\n-#define NULL 0\n-#endif\n-\n-static struct token tokentab2[] = {\n-  {\"&&\", AND},\n-  {\"||\", OR},\n-  {\"<<\", LSH},\n-  {\">>\", RSH},\n-  {\"==\", EQUAL},\n-  {\"!=\", NOTEQUAL},\n-  {\"<=\", LEQ},\n-  {\">=\", GEQ},\n-  {NULL, ERROR}\n-};\n-\n-/* Read one token, getting characters through lexptr.  */\n-\n-int\n-yylex ()\n-{\n-  register int c;\n-  register int namelen;\n-  register char *tokstart;\n-  register struct token *toktab;\n-\n- retry:\n-\n-  tokstart = lexptr;\n-  c = *tokstart;\n-  /* See if it is a special token of length 2.  */\n-  for (toktab = tokentab2; toktab->operator != NULL; toktab++)\n-    if (c == *toktab->operator && tokstart[1] == toktab->operator[1]) {\n-      lexptr += 2;\n-      return toktab->token;\n-    }\n-\n-  switch (c) {\n-  case 0:\n-    return 0;\n-    \n-  case ' ':\n-  case '\\t':\n-  case '\\r':\n-  case '\\n':\n-    lexptr++;\n-    goto retry;\n-    \n-  case '\\'':\n-    lexptr++;\n-    c = *lexptr++;\n-    if (c == '\\\\')\n-      c = parse_escape (&lexptr);\n-\n-    /* Sign-extend the constant if chars are signed on target machine.  */\n-    {\n-      if (lookup ((const unsigned char *)\"__CHAR_UNSIGNED__\",\n-\t\t   sizeof (\"__CHAR_UNSIGNED__\")-1, -1)\n-\t  || ((c >> (CHAR_TYPE_SIZE - 1)) & 1) == 0)\n-\tyylval.integer.value = c & ((1 << CHAR_TYPE_SIZE) - 1);\n-      else\n-\tyylval.integer.value = c | ~((1 << CHAR_TYPE_SIZE) - 1);\n-    }\n-\n-    yylval.integer.unsignedp = 0;\n-    c = *lexptr++;\n-    if (c != '\\'') {\n-      yyerror (\"Invalid character constant in #if\");\n-      return ERROR;\n-    }\n-    \n-    return CHAR;\n-\n-    /* some of these chars are invalid in constant expressions;\n-       maybe do something about them later */\n-  case '/':\n-  case '+':\n-  case '-':\n-  case '*':\n-  case '%':\n-  case '|':\n-  case '&':\n-  case '^':\n-  case '~':\n-  case '!':\n-  case '@':\n-  case '<':\n-  case '>':\n-  case '(':\n-  case ')':\n-  case '[':\n-  case ']':\n-  case '.':\n-  case '?':\n-  case ':':\n-  case '=':\n-  case '{':\n-  case '}':\n-  case ',':\n-    lexptr++;\n-    return c;\n-    \n-  case '\"':\n-    yyerror (\"double quoted strings not allowed in #if expressions\");\n-    return ERROR;\n-  }\n-  if (c >= '0' && c <= '9') {\n-    /* It's a number */\n-    for (namelen = 0;\n-\t c = tokstart[namelen], is_idchar[c] || c == '.'; \n-\t namelen++)\n-      ;\n-    return parse_number (namelen);\n-  }\n-  \n-  if (!is_idstart[c]) {\n-    yyerror (\"Invalid token in expression\");\n-    return ERROR;\n-  }\n-  \n-  /* It is a name.  See how long it is.  */\n-  \n-  for (namelen = 0;\n-       is_idchar[(int)(unsigned char)tokstart[namelen]];\n-       namelen++)\n-    ;\n-  \n-  lexptr += namelen;\n-  return NAME;\n-}\n-\n-\n-/* Parse a C escape sequence.  STRING_PTR points to a variable\n-   containing a pointer to the string to parse.  That pointer\n-   is updated past the characters we use.  The value of the\n-   escape sequence is returned.\n-\n-   A negative value means the sequence \\ newline was seen,\n-   which is supposed to be equivalent to nothing at all.\n-\n-   If \\ is followed by a null character, we return a negative\n-   value and leave the string pointer pointing at the null character.\n-\n-   If \\ is followed by 000, we return 0 and leave the string pointer\n-   after the zeros.  A value of 0 does not mean end of string.  */\n-\n-int\n-parse_escape (string_ptr)\n-     char **string_ptr;\n-{\n-  register int c = *(*string_ptr)++;\n-  switch (c)\n-    {\n-    case 'a':\n-      return TARGET_BELL;\n-    case 'b':\n-      return TARGET_BS;\n-    case 'e':\n-      return 033;\n-    case 'f':\n-      return TARGET_FF;\n-    case 'n':\n-      return TARGET_NEWLINE;\n-    case 'r':\n-      return TARGET_CR;\n-    case 't':\n-      return TARGET_TAB;\n-    case 'v':\n-      return TARGET_VT;\n-    case '\\n':\n-      return -2;\n-    case 0:\n-      (*string_ptr)--;\n-      return 0;\n-    case '^':\n-      c = *(*string_ptr)++;\n-      if (c == '\\\\')\n-\tc = parse_escape (string_ptr);\n-      if (c == '?')\n-\treturn 0177;\n-      return (c & 0200) | (c & 037);\n-      \n-    case '0':\n-    case '1':\n-    case '2':\n-    case '3':\n-    case '4':\n-    case '5':\n-    case '6':\n-    case '7':\n-      {\n-\tregister int i = c - '0';\n-\tregister int count = 0;\n-\twhile (++count < 3)\n-\t  {\n-\t    c = *(*string_ptr)++;\n-\t    if (c >= '0' && c <= '7')\n-\t      i = (i << 3) + c - '0';\n-\t    else\n-\t      {\n-\t\t(*string_ptr)--;\n-\t\tbreak;\n-\t      }\n-\t  }\n-\tif ((i & ~((1 << CHAR_TYPE_SIZE) - 1)) != 0)\n-\t  {\n-\t    i &= (1 << CHAR_TYPE_SIZE) - 1;\n-\t    warning (\"octal character constant does not fit in a byte\");\n-\t  }\n-\treturn i;\n-      }\n-    case 'x':\n-      {\n-\tregister int i = 0;\n-\tfor (;;)\n-\t  {\n-\t    c = *(*string_ptr)++;\n-\t    if (c >= '0' && c <= '9')\n-\t      i = (i << 4) + c - '0';\n-\t    else if (c >= 'a' && c <= 'f')\n-\t      i = (i << 4) + c - 'a' + 10;\n-\t    else if (c >= 'A' && c <= 'F')\n-\t      i = (i << 4) + c - 'A' + 10;\n-\t    else\n-\t      {\n-\t\t(*string_ptr)--;\n-\t\tbreak;\n-\t      }\n-\t  }\n-\tif ((i & ~((1 << BITS_PER_UNIT) - 1)) != 0)\n-\t  {\n-\t    i &= (1 << BITS_PER_UNIT) - 1;\n-\t    warning (\"hex character constant does not fit in a byte\");\n-\t  }\n-\treturn i;\n-      }\n-    default:\n-      return c;\n-    }\n-}\n-\n-void\n-yyerror (s)\n-     const char *s;\n-{\n-  error (s);\n-  longjmp (parse_return_error, 1);\n-}\n-\f\n-/* This page contains the entry point to this file.  */\n-\n-/* Parse STRING as an expression, and complain if this fails\n-   to use up all of the contents of STRING.  */\n-/* We do not support C comments.  They should be removed before\n-   this function is called.  */\n-\n-int\n-parse_c_expression (string)\n-     char *string;\n-{\n-  lexptr = string;\n-  \n-  if (lexptr == 0 || *lexptr == 0) {\n-    error (\"empty #if expression\");\n-    return 0;\t\t\t/* don't include the #if group */\n-  }\n-\n-  /* if there is some sort of scanning error, just return 0 and assume\n-     the parsing routine has printed an error message somewhere.\n-     there is surely a better thing to do than this.     */\n-  if (setjmp (parse_return_error))\n-    return 0;\n-\n-  if (yyparse ())\n-    return 0;\t\t\t/* actually this is never reached\n-\t\t\t\t   the way things stand. */\n-  if (*lexptr)\n-    error (\"Junk after end of expression.\");\n-\n-  return expression_value;\t/* set by yyparse () */\n-}"}]}