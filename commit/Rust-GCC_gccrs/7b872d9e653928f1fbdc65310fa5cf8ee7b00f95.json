{"sha": "7b872d9e653928f1fbdc65310fa5cf8ee7b00f95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I4NzJkOWU2NTM5MjhmMWZiZGM2NTMxMGZhNWNmOGVlN2IwMGY5NQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2012-06-03T22:10:19Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2012-06-03T22:10:19Z"}, "message": "ipa-prop.h (ipa_get_jf_known_type_offset): New function.\n\n2012-06-03  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.h (ipa_get_jf_known_type_offset): New function.\n\t(ipa_get_jf_known_type_base_type): Likewise.\n\t(ipa_get_jf_known_type_component_type): Likewise.\n\t(ipa_get_jf_constant): Likewise.\n\t(ipa_get_jf_pass_through_formal_id): Likewise.\n\t(ipa_get_jf_pass_through_operation): Likewise.\n\t(ipa_get_jf_ancestor_offset): Likewise.\n\t(ipa_get_jf_ancestor_type): Likewise.\n\t(ipa_get_jf_ancestor_formal_id): Likewise.\n\t(ipa_get_jf_member_ptr_pfn): Likewise.\n\t* ipa-prop.c (ipa_set_jf_known_type): New function.\n\t(ipa_set_jf_constant): Likewise.\n\t(ipa_set_jf_simple_pass_through): Likewise.\n\t(ipa_set_jf_arith_pass_through): Likewise.\n\t(ipa_set_ancestor_jf): Likewise.\n\t(fill_member_ptr_cst_jump_function): Moved up and renamed to\n\tipa_set_jf_member_ptr_cst.\n\t(detect_type_change_1): Use the new jump function creation functions.\n\t(compute_complex_assign_jump_func): Likewise.\n\t(compute_complex_ancestor_jump_func): Likewise.\n\t(compute_known_type_jump_func): Likewise.\n\t(compute_scalar_jump_functions): Likewise.\n\t(compute_pass_through_member_ptrs): Likewise.\n\t(determine_cst_member_ptr): Likewise.\n\t(combine_known_type_and_ancestor_jfs): Likewise.\n\t(try_make_edge_direct_simple_call): Likewise.\n\t(try_make_edge_direct_virtual_call): Likewise.\n\t(update_indirect_edges_after_inlining): Likewise.\n\t* ipa-cp.c (ipa_get_jf_pass_through_result): Use jump function\n\taccess functions.  Incorporat NOP_EXPR and BINFO handling from its\n\tcallers.\n\t(ipa_get_jf_ancestor_result): Likewise.  Incorporate handling BINFOs\n\twhich was in its callers.\n\t(ipa_value_from_jfunc): Use jump function access functions.  Some\n\tfunctionality moved to functions above.\n\t(propagate_vals_accross_ancestor): Likewise.\n\t(propagate_vals_accross_pass_through): Use jump function access\n\tfunctions.\n\t(propagate_accross_jump_function): Likewise.\n\t* ipa-inline-analysis.c (remap_edge_change_prob): Use jump function\n\taccess functions.\n\t(inline_merge_summary): Likewise.\n\nFrom-SVN: r188156", "tree": {"sha": "f93c114daf03955a690d8f6f80c567c720ca9874", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f93c114daf03955a690d8f6f80c567c720ca9874"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b872d9e653928f1fbdc65310fa5cf8ee7b00f95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b872d9e653928f1fbdc65310fa5cf8ee7b00f95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b872d9e653928f1fbdc65310fa5cf8ee7b00f95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b872d9e653928f1fbdc65310fa5cf8ee7b00f95/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7ac6a832c3122846bcd0aa81af47f0e62519da92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ac6a832c3122846bcd0aa81af47f0e62519da92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ac6a832c3122846bcd0aa81af47f0e62519da92"}], "stats": {"total": 395, "additions": 276, "deletions": 119}, "files": [{"sha": "deb546de2f56c0ab5036dfb4ad087cac048f092a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b872d9e653928f1fbdc65310fa5cf8ee7b00f95/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b872d9e653928f1fbdc65310fa5cf8ee7b00f95/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b872d9e653928f1fbdc65310fa5cf8ee7b00f95", "patch": "@@ -1,3 +1,48 @@\n+2012-06-03  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.h (ipa_get_jf_known_type_offset): New function.\n+\t(ipa_get_jf_known_type_base_type): Likewise.\n+\t(ipa_get_jf_known_type_component_type): Likewise.\n+\t(ipa_get_jf_constant): Likewise.\n+\t(ipa_get_jf_pass_through_formal_id): Likewise.\n+\t(ipa_get_jf_pass_through_operation): Likewise.\n+\t(ipa_get_jf_ancestor_offset): Likewise.\n+\t(ipa_get_jf_ancestor_type): Likewise.\n+\t(ipa_get_jf_ancestor_formal_id): Likewise.\n+\t(ipa_get_jf_member_ptr_pfn): Likewise.\n+\t* ipa-prop.c (ipa_set_jf_known_type): New function.\n+\t(ipa_set_jf_constant): Likewise.\n+\t(ipa_set_jf_simple_pass_through): Likewise.\n+\t(ipa_set_jf_arith_pass_through): Likewise.\n+\t(ipa_set_ancestor_jf): Likewise.\n+\t(fill_member_ptr_cst_jump_function): Moved up and renamed to\n+\tipa_set_jf_member_ptr_cst.\n+\t(detect_type_change_1): Use the new jump function creation functions.\n+\t(compute_complex_assign_jump_func): Likewise.\n+\t(compute_complex_ancestor_jump_func): Likewise.\n+\t(compute_known_type_jump_func): Likewise.\n+\t(compute_scalar_jump_functions): Likewise.\n+\t(compute_pass_through_member_ptrs): Likewise.\n+\t(determine_cst_member_ptr): Likewise.\n+\t(combine_known_type_and_ancestor_jfs): Likewise.\n+\t(try_make_edge_direct_simple_call): Likewise.\n+\t(try_make_edge_direct_virtual_call): Likewise.\n+\t(update_indirect_edges_after_inlining): Likewise.\n+\t* ipa-cp.c (ipa_get_jf_pass_through_result): Use jump function\n+\taccess functions.  Incorporat NOP_EXPR and BINFO handling from its\n+\tcallers.\n+\t(ipa_get_jf_ancestor_result): Likewise.  Incorporate handling BINFOs\n+\twhich was in its callers.\n+\t(ipa_value_from_jfunc): Use jump function access functions.  Some\n+\tfunctionality moved to functions above.\n+\t(propagate_vals_accross_ancestor): Likewise.\n+\t(propagate_vals_accross_pass_through): Use jump function access\n+\tfunctions.\n+\t(propagate_accross_jump_function): Likewise.\n+\t* ipa-inline-analysis.c (remap_edge_change_prob): Use jump function\n+\taccess functions.\n+\t(inline_merge_summary): Likewise.\n+\n 2012-06-03  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* config/pa/pa.h (MAX_PCREL17F_OFFSET): Define."}, {"sha": "3f3ab36119e04259d6555f63d5ac5732b44b898c", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 29, "deletions": 42, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b872d9e653928f1fbdc65310fa5cf8ee7b00f95/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b872d9e653928f1fbdc65310fa5cf8ee7b00f95/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=7b872d9e653928f1fbdc65310fa5cf8ee7b00f95", "patch": "@@ -638,17 +638,19 @@ ipa_get_jf_pass_through_result (struct ipa_jump_func *jfunc, tree input)\n {\n   tree restype, res;\n \n-  gcc_checking_assert (is_gimple_ip_invariant (input));\n-  if (jfunc->value.pass_through.operation == NOP_EXPR)\n+  if (ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n     return input;\n+  else if (TREE_CODE (input) == TREE_BINFO)\n+    return NULL_TREE;\n \n-  if (TREE_CODE_CLASS (jfunc->value.pass_through.operation)\n+  gcc_checking_assert (is_gimple_ip_invariant (input));\n+  if (TREE_CODE_CLASS (ipa_get_jf_pass_through_operation (jfunc))\n       == tcc_comparison)\n     restype = boolean_type_node;\n   else\n     restype = TREE_TYPE (input);\n-  res = fold_binary (jfunc->value.pass_through.operation, restype,\n-\t\t     input, jfunc->value.pass_through.operand);\n+  res = fold_binary (ipa_get_jf_pass_through_operation (jfunc), restype,\n+\t\t     input, ipa_get_jf_pass_through_operand (jfunc));\n \n   if (res && !is_gimple_ip_invariant (res))\n     return NULL_TREE;\n@@ -662,12 +664,16 @@ ipa_get_jf_pass_through_result (struct ipa_jump_func *jfunc, tree input)\n static tree\n ipa_get_jf_ancestor_result (struct ipa_jump_func *jfunc, tree input)\n {\n-  if (TREE_CODE (input) == ADDR_EXPR)\n+  if (TREE_CODE (input) == TREE_BINFO)\n+    return get_binfo_at_offset (input,\n+\t\t\t\tipa_get_jf_ancestor_offset (jfunc),\n+\t\t\t\tipa_get_jf_ancestor_type (jfunc));\n+  else if (TREE_CODE (input) == ADDR_EXPR)\n     {\n       tree t = TREE_OPERAND (input, 0);\n       t = build_ref_for_offset (EXPR_LOCATION (t), t,\n-\t\t\t\tjfunc->value.ancestor.offset,\n-\t\t\t\tjfunc->value.ancestor.type, NULL, false);\n+\t\t\t\tipa_get_jf_ancestor_offset (jfunc),\n+\t\t\t\tipa_get_jf_ancestor_type (jfunc), NULL, false);\n       return build_fold_addr_expr (t);\n     }\n   else\n@@ -680,12 +686,12 @@ ipa_get_jf_ancestor_result (struct ipa_jump_func *jfunc, tree input)\n static tree\n ipa_value_from_known_type_jfunc (struct ipa_jump_func *jfunc)\n {\n-  tree base_binfo = TYPE_BINFO (jfunc->value.known_type.base_type);\n+  tree base_binfo = TYPE_BINFO (ipa_get_jf_known_type_base_type (jfunc));\n   if (!base_binfo)\n     return NULL_TREE;\n   return get_binfo_at_offset (base_binfo,\n-\t\t\t      jfunc->value.known_type.offset,\n-\t\t\t      jfunc->value.known_type.component_type);\n+\t\t\t      ipa_get_jf_known_type_offset (jfunc),\n+\t\t\t      ipa_get_jf_known_type_component_type (jfunc));\n }\n \n /* Determine whether JFUNC evaluates to a known value (that is either a\n@@ -697,7 +703,7 @@ tree\n ipa_value_from_jfunc (struct ipa_node_params *info, struct ipa_jump_func *jfunc)\n {\n   if (jfunc->type == IPA_JF_CONST)\n-    return jfunc->value.constant;\n+    return ipa_get_jf_constant (jfunc);\n   else if (jfunc->type == IPA_JF_KNOWN_TYPE)\n     return ipa_value_from_known_type_jfunc (jfunc);\n   else if (jfunc->type == IPA_JF_PASS_THROUGH\n@@ -707,9 +713,9 @@ ipa_value_from_jfunc (struct ipa_node_params *info, struct ipa_jump_func *jfunc)\n       int idx;\n \n       if (jfunc->type == IPA_JF_PASS_THROUGH)\n-\tidx = jfunc->value.pass_through.formal_id;\n+\tidx = ipa_get_jf_pass_through_formal_id (jfunc);\n       else\n-\tidx = jfunc->value.ancestor.formal_id;\n+\tidx = ipa_get_jf_ancestor_formal_id (jfunc);\n \n       if (info->ipcp_orig_node)\n \tinput = VEC_index (tree, info->known_vals, idx);\n@@ -732,22 +738,9 @@ ipa_value_from_jfunc (struct ipa_node_params *info, struct ipa_jump_func *jfunc)\n \treturn NULL_TREE;\n \n       if (jfunc->type == IPA_JF_PASS_THROUGH)\n-\t{\n-\t  if (jfunc->value.pass_through.operation == NOP_EXPR)\n-\t    return input;\n-\t  else if (TREE_CODE (input) == TREE_BINFO)\n-\t    return NULL_TREE;\n-\t  else\n-\t    return ipa_get_jf_pass_through_result (jfunc, input);\n-\t}\n+\treturn ipa_get_jf_pass_through_result (jfunc, input);\n       else\n-\t{\n-\t  if (TREE_CODE (input) == TREE_BINFO)\n-\t    return get_binfo_at_offset (input, jfunc->value.ancestor.offset,\n-\t\t\t\t\tjfunc->value.ancestor.type);\n-\t  else\n-\t    return ipa_get_jf_ancestor_result (jfunc, input);\n-\t}\n+\treturn ipa_get_jf_ancestor_result (jfunc, input);\n     }\n   else\n     return NULL_TREE;\n@@ -907,13 +900,13 @@ propagate_vals_accross_pass_through (struct cgraph_edge *cs,\n   struct ipcp_value *src_val;\n   bool ret = false;\n \n-  if (jfunc->value.pass_through.operation == NOP_EXPR)\n+  if (ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n     for (src_val = src_lat->values; src_val; src_val = src_val->next)\n       ret |= add_value_to_lattice (dest_lat, src_val->value, cs,\n \t\t\t\t   src_val, src_idx);\n   /* Do not create new values when propagating within an SCC because if there\n-     arithmetic functions with circular dependencies, there is infinite number\n-     of them and we would just make lattices bottom.  */\n+     are arithmetic functions with circular dependencies, there is infinite\n+     number of them and we would just make lattices bottom.  */\n   else if (edge_within_scc (cs))\n     ret = set_lattice_contains_variable (dest_lat);\n   else\n@@ -956,13 +949,7 @@ propagate_vals_accross_ancestor (struct cgraph_edge *cs,\n \n   for (src_val = src_lat->values; src_val; src_val = src_val->next)\n     {\n-      tree t = src_val->value;\n-\n-      if (TREE_CODE (t) == TREE_BINFO)\n-\tt = get_binfo_at_offset (t, jfunc->value.ancestor.offset,\n-\t\t\t\t jfunc->value.ancestor.type);\n-      else\n-\tt = ipa_get_jf_ancestor_result (jfunc, t);\n+      tree t = ipa_get_jf_ancestor_result (jfunc, src_val->value);\n \n       if (t)\n \tret |= add_value_to_lattice (dest_lat, t, cs, src_val, src_idx);\n@@ -996,7 +983,7 @@ propagate_accross_jump_function (struct cgraph_edge *cs,\n \t    return set_lattice_contains_variable (dest_lat);\n \t}\n       else\n-\tval = jfunc->value.constant;\n+\tval = ipa_get_jf_constant (jfunc);\n       return add_value_to_lattice (dest_lat, val, cs, NULL, 0);\n     }\n   else if (jfunc->type == IPA_JF_PASS_THROUGH\n@@ -1008,9 +995,9 @@ propagate_accross_jump_function (struct cgraph_edge *cs,\n       bool ret;\n \n       if (jfunc->type == IPA_JF_PASS_THROUGH)\n-\tsrc_idx = jfunc->value.pass_through.formal_id;\n+\tsrc_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n       else\n-\tsrc_idx = jfunc->value.ancestor.formal_id;\n+\tsrc_idx = ipa_get_jf_ancestor_formal_id (jfunc);\n \n       src_lat = ipa_get_lattice (caller_info, src_idx);\n       if (src_lat->bottom)"}, {"sha": "a38d2608cbd9e1a880a055ecfc5f49d4e57b509a", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b872d9e653928f1fbdc65310fa5cf8ee7b00f95/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b872d9e653928f1fbdc65310fa5cf8ee7b00f95/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=7b872d9e653928f1fbdc65310fa5cf8ee7b00f95", "patch": "@@ -2514,16 +2514,16 @@ remap_edge_change_prob (struct cgraph_edge *inlined_edge,\n \t{\n \t  struct ipa_jump_func *jfunc = ipa_get_ith_jump_func (args, i);\n \t  if (jfunc->type == IPA_JF_PASS_THROUGH\n-\t      && (jfunc->value.pass_through.formal_id\n+\t      && (ipa_get_jf_pass_through_formal_id (jfunc)\n \t\t  < (int) VEC_length (inline_param_summary_t,\n-\t\t\t\t      inlined_es->param)))\n+\t\t\t\t\t\t   inlined_es->param)))\n \t    {\n+\t      int jf_formal_id = ipa_get_jf_pass_through_formal_id (jfunc);\n \t      int prob1 = VEC_index (inline_param_summary_t,\n \t\t\t\t     es->param, i)->change_prob;\n \t      int prob2 = VEC_index\n \t\t\t     (inline_param_summary_t,\n-\t\t\t     inlined_es->param,\n-\t\t\t     jfunc->value.pass_through.formal_id)->change_prob;\n+\t\t\t     inlined_es->param, jf_formal_id)->change_prob;\n \t      int prob = ((prob1 * prob2 + REG_BR_PROB_BASE / 2)\n \t\t\t  / REG_BR_PROB_BASE);\n \n@@ -2649,8 +2649,8 @@ inline_merge_summary (struct cgraph_edge *edge)\n \t  int map = -1;\n \t  /* TODO: handle non-NOPs when merging.  */\n \t  if (jfunc->type == IPA_JF_PASS_THROUGH\n-\t      && jfunc->value.pass_through.operation == NOP_EXPR)\n-\t    map = jfunc->value.pass_through.formal_id;\n+\t      && ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n+\t    map = ipa_get_jf_pass_through_formal_id (jfunc);\n \t  VEC_replace (int, operand_map, i, map);\n \t  gcc_assert (map < ipa_get_param_count (IPA_NODE_REF (to)));\n \t}"}, {"sha": "ae35191e0f61679341571cf50f5a997426523d8c", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 93, "deletions": 70, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b872d9e653928f1fbdc65310fa5cf8ee7b00f95/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b872d9e653928f1fbdc65310fa5cf8ee7b00f95/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=7b872d9e653928f1fbdc65310fa5cf8ee7b00f95", "patch": "@@ -266,6 +266,73 @@ ipa_print_all_jump_functions (FILE *f)\n     }\n }\n \n+/* Set JFUNC to be a known type jump function.  */\n+\n+static void\n+ipa_set_jf_known_type (struct ipa_jump_func *jfunc, HOST_WIDE_INT offset,\n+\t\t       tree base_type, tree component_type)\n+{\n+  jfunc->type = IPA_JF_KNOWN_TYPE;\n+  jfunc->value.known_type.offset = offset,\n+  jfunc->value.known_type.base_type = base_type;\n+  jfunc->value.known_type.component_type = component_type;\n+}\n+\n+/* Set JFUNC to be a constant jmp function.  */\n+\n+static void\n+ipa_set_jf_constant (struct ipa_jump_func *jfunc, tree constant)\n+{\n+  jfunc->type = IPA_JF_CONST;\n+  jfunc->value.constant = constant;\n+}\n+\n+/* Set JFUNC to be a simple pass-through jump function.  */\n+static void\n+ipa_set_jf_simple_pass_through (struct ipa_jump_func *jfunc, int formal_id)\n+{\n+  jfunc->type = IPA_JF_PASS_THROUGH;\n+  jfunc->value.pass_through.operand = NULL_TREE;\n+  jfunc->value.pass_through.formal_id = formal_id;\n+  jfunc->value.pass_through.operation = NOP_EXPR;\n+}\n+\n+/* Set JFUNC to be an arithmetic pass through jump function.  */\n+\n+static void\n+ipa_set_jf_arith_pass_through (struct ipa_jump_func *jfunc, int formal_id,\n+\t\t\t       tree operand, enum tree_code operation)\n+{\n+  jfunc->type = IPA_JF_PASS_THROUGH;\n+  jfunc->value.pass_through.operand = operand;\n+  jfunc->value.pass_through.formal_id = formal_id;\n+  jfunc->value.pass_through.operation = operation;\n+}\n+\n+/* Set JFUNC to be an ancestor jump function.  */\n+\n+static void\n+ipa_set_ancestor_jf (struct ipa_jump_func *jfunc, HOST_WIDE_INT offset,\n+\t\t     tree type, int formal_id)\n+{\n+  jfunc->type = IPA_JF_ANCESTOR;\n+  jfunc->value.ancestor.formal_id = formal_id;\n+  jfunc->value.ancestor.offset = offset;\n+  jfunc->value.ancestor.type = type;\n+}\n+\n+/* Simple function filling in a member pointer constant jump function (with PFN\n+   and DELTA as the constant value) into JFUNC.  */\n+\n+static void\n+ipa_set_jf_member_ptr_cst (struct ipa_jump_func *jfunc,\n+\t\t\t   tree pfn, tree delta)\n+{\n+  jfunc->type = IPA_JF_CONST_MEMBER_PTR;\n+  jfunc->value.member_cst.pfn = pfn;\n+  jfunc->value.member_cst.delta = delta;\n+}\n+\n /* Structure to be passed in between detect_type_change and\n    check_stmt_for_type_change.  */\n \n@@ -464,11 +531,7 @@ detect_type_change_1 (tree arg, tree base, tree comp_type, gimple call,\n       || offset != 0)\n     jfunc->type = IPA_JF_UNKNOWN;\n   else\n-    {\n-      jfunc->type = IPA_JF_KNOWN_TYPE;\n-      jfunc->value.known_type.base_type = tci.known_current_type;\n-      jfunc->value.known_type.component_type = comp_type;\n-    }\n+    ipa_set_jf_known_type (jfunc, 0, tci.known_current_type, comp_type);\n \n   return true;\n }\n@@ -666,18 +729,12 @@ compute_complex_assign_jump_func (struct ipa_node_params *info,\n \t\t\t\t\t\t TREE_TYPE (op1))))\n \t    return;\n \n-\t  jfunc->type = IPA_JF_PASS_THROUGH;\n-\t  jfunc->value.pass_through.formal_id = index;\n-\t  jfunc->value.pass_through.operation = gimple_assign_rhs_code (stmt);\n-\t  jfunc->value.pass_through.operand = op2;\n+\t  ipa_set_jf_arith_pass_through (jfunc, index, op2,\n+\t\t\t\t\t gimple_assign_rhs_code (stmt));\n \t}\n       else if (gimple_assign_single_p (stmt)\n \t       && !detect_type_change_ssa (tc_ssa, call, jfunc))\n-\t{\n-\t  jfunc->type = IPA_JF_PASS_THROUGH;\n-\t  jfunc->value.pass_through.formal_id = index;\n-\t  jfunc->value.pass_through.operation = NOP_EXPR;\n-\t}\n+\tipa_set_jf_simple_pass_through (jfunc, index);\n       return;\n     }\n \n@@ -703,12 +760,7 @@ compute_complex_assign_jump_func (struct ipa_node_params *info,\n   index = ipa_get_param_decl_index (info, SSA_NAME_VAR (ssa));\n   if (index >= 0\n       && !detect_type_change (op1, base, call, jfunc, offset))\n-    {\n-      jfunc->type = IPA_JF_ANCESTOR;\n-      jfunc->value.ancestor.formal_id = index;\n-      jfunc->value.ancestor.offset = offset;\n-      jfunc->value.ancestor.type = TREE_TYPE (op1);\n-    }\n+    ipa_set_ancestor_jf (jfunc, offset, TREE_TYPE (op1), index);\n }\n \n /* Extract the base, offset and MEM_REF expression from a statement ASSIGN if\n@@ -832,12 +884,7 @@ compute_complex_ancestor_jump_func (struct ipa_node_params *info,\n     }\n \n   if (!detect_type_change (obj, expr, call, jfunc, offset))\n-    {\n-      jfunc->type = IPA_JF_ANCESTOR;\n-      jfunc->value.ancestor.formal_id = index;\n-      jfunc->value.ancestor.offset = offset;\n-      jfunc->value.ancestor.type = TREE_TYPE (obj);\n-    }\n+    ipa_set_ancestor_jf (jfunc, offset, TREE_TYPE (obj), index);\n }\n \n /* Given OP which is passed as an actual argument to a called function,\n@@ -869,10 +916,7 @@ compute_known_type_jump_func (tree op, struct ipa_jump_func *jfunc,\n       || !TYPE_BINFO (TREE_TYPE (base)))\n     return;\n \n-  jfunc->type = IPA_JF_KNOWN_TYPE;\n-  jfunc->value.known_type.base_type = TREE_TYPE (base);\n-  jfunc->value.known_type.offset = offset;\n-  jfunc->value.known_type.component_type = TREE_TYPE (op);\n+  ipa_set_jf_known_type (jfunc, offset, TREE_TYPE (base), TREE_TYPE (op));\n }\n \n \n@@ -898,10 +942,7 @@ compute_scalar_jump_functions (struct ipa_node_params *info,\n       arg = gimple_call_arg (call, num);\n \n       if (is_gimple_ip_invariant (arg))\n-\t{\n-\t  jfunc->type = IPA_JF_CONST;\n-\t  jfunc->value.constant = arg;\n-\t}\n+\tipa_set_jf_constant (jfunc, arg);\n       else if (TREE_CODE (arg) == SSA_NAME)\n \t{\n \t  if (SSA_NAME_IS_DEFAULT_DEF (arg))\n@@ -910,11 +951,7 @@ compute_scalar_jump_functions (struct ipa_node_params *info,\n \n \t      if (index >= 0\n \t\t  && !detect_type_change_ssa (arg, call, jfunc))\n-\t\t{\n-\t\t  jfunc->type = IPA_JF_PASS_THROUGH;\n-\t\t  jfunc->value.pass_through.formal_id = index;\n-\t\t  jfunc->value.pass_through.operation = NOP_EXPR;\n-\t\t}\n+\t\tipa_set_jf_simple_pass_through (jfunc, index);\n \t    }\n \t  else\n \t    {\n@@ -997,9 +1034,7 @@ compute_pass_through_member_ptrs (struct ipa_node_params *info,\n \t\t{\n \t\t  struct ipa_jump_func *jfunc = ipa_get_ith_jump_func (args,\n \t\t\t\t\t\t\t\t       num);\n-\t\t  jfunc->type = IPA_JF_PASS_THROUGH;\n-\t\t  jfunc->value.pass_through.formal_id = index;\n-\t\t  jfunc->value.pass_through.operation = NOP_EXPR;\n+\t\t  ipa_set_jf_simple_pass_through (jfunc, index);\n \t\t}\n \t      else\n \t\tundecided_members = true;\n@@ -1012,18 +1047,6 @@ compute_pass_through_member_ptrs (struct ipa_node_params *info,\n   return undecided_members;\n }\n \n-/* Simple function filling in a member pointer constant jump function (with PFN\n-   and DELTA as the constant value) into JFUNC.  */\n-\n-static void\n-fill_member_ptr_cst_jump_function (struct ipa_jump_func *jfunc,\n-\t\t\t\t   tree pfn, tree delta)\n-{\n-  jfunc->type = IPA_JF_CONST_MEMBER_PTR;\n-  jfunc->value.member_cst.pfn = pfn;\n-  jfunc->value.member_cst.delta = delta;\n-}\n-\n /* If RHS is an SSA_NAME and it is defined by a simple copy assign statement,\n    return the rhs of its defining statement.  */\n \n@@ -1091,7 +1114,7 @@ determine_cst_member_ptr (gimple call, tree arg, tree method_field,\n \t      method = TREE_OPERAND (rhs, 0);\n \t      if (delta)\n \t\t{\n-\t\t  fill_member_ptr_cst_jump_function (jfunc, rhs, delta);\n+\t\t  ipa_set_jf_member_ptr_cst (jfunc, rhs, delta);\n \t\t  return;\n \t\t}\n \t    }\n@@ -1107,7 +1130,7 @@ determine_cst_member_ptr (gimple call, tree arg, tree method_field,\n \t      delta = rhs;\n \t      if (method)\n \t\t{\n-\t\t  fill_member_ptr_cst_jump_function (jfunc, rhs, delta);\n+\t\t  ipa_set_jf_member_ptr_cst (jfunc, rhs, delta);\n \t\t  return;\n \t\t}\n \t    }\n@@ -1681,13 +1704,13 @@ combine_known_type_and_ancestor_jfs (struct ipa_jump_func *src,\n   HOST_WIDE_INT combined_offset;\n   tree combined_type;\n \n-  combined_offset = src->value.known_type.offset + dst->value.ancestor.offset;\n-  combined_type = dst->value.ancestor.type;\n+  combined_offset = ipa_get_jf_known_type_offset (src)\n+    + ipa_get_jf_ancestor_offset (dst);\n+  combined_type = ipa_get_jf_ancestor_type (dst);\n \n-  dst->type = IPA_JF_KNOWN_TYPE;\n-  dst->value.known_type.base_type = src->value.known_type.base_type;\n-  dst->value.known_type.offset = combined_offset;\n-  dst->value.known_type.component_type = combined_type;\n+  ipa_set_jf_known_type (dst, combined_offset,\n+\t\t\t ipa_get_jf_known_type_base_type (src),\n+\t\t\t combined_type);\n }\n \n /* Update the jump functions associated with call graph edge E when the call\n@@ -1804,9 +1827,9 @@ try_make_edge_direct_simple_call (struct cgraph_edge *ie,\n   tree target;\n \n   if (jfunc->type == IPA_JF_CONST)\n-    target = jfunc->value.constant;\n+    target = ipa_get_jf_constant (jfunc);\n   else if (jfunc->type == IPA_JF_CONST_MEMBER_PTR)\n-    target = jfunc->value.member_cst.pfn;\n+    target = ipa_get_jf_member_ptr_pfn (jfunc);\n   else\n     return NULL;\n \n@@ -1827,9 +1850,9 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n   if (jfunc->type != IPA_JF_KNOWN_TYPE)\n     return NULL;\n \n-  binfo = TYPE_BINFO (jfunc->value.known_type.base_type);\n+  binfo = TYPE_BINFO (ipa_get_jf_known_type_base_type (jfunc));\n   gcc_checking_assert (binfo);\n-  binfo = get_binfo_at_offset (binfo, jfunc->value.known_type.offset\n+  binfo = get_binfo_at_offset (binfo, ipa_get_jf_known_type_offset (jfunc)\n \t\t\t       + ie->indirect_info->anc_offset,\n \t\t\t       ie->indirect_info->otr_type);\n   if (binfo)\n@@ -1881,12 +1904,12 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \n       jfunc = ipa_get_ith_jump_func (top, ici->param_index);\n       if (jfunc->type == IPA_JF_PASS_THROUGH\n-\t  && jfunc->value.pass_through.operation == NOP_EXPR)\n-\tici->param_index = jfunc->value.pass_through.formal_id;\n+\t  && ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n+\tici->param_index = ipa_get_jf_pass_through_formal_id (jfunc);\n       else if (jfunc->type == IPA_JF_ANCESTOR)\n \t{\n- \t  ici->param_index = jfunc->value.ancestor.formal_id;\n- \t  ici->anc_offset += jfunc->value.ancestor.offset;\n+ \t  ici->param_index = ipa_get_jf_ancestor_formal_id (jfunc);\n+ \t  ici->anc_offset += ipa_get_jf_ancestor_offset (jfunc);\n \t}\n       else\n \t/* Either we can find a destination for this edge now or never. */"}, {"sha": "7faa3e1eec0ea5f00d7ee5e1a7f9f9ba8ef60e49", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 103, "deletions": 1, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b872d9e653928f1fbdc65310fa5cf8ee7b00f95/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b872d9e653928f1fbdc65310fa5cf8ee7b00f95/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=7b872d9e653928f1fbdc65310fa5cf8ee7b00f95", "patch": "@@ -113,7 +113,7 @@ struct GTY(()) ipa_ancestor_jf_data\n {\n   /* Offset of the field representing the ancestor.  */\n   HOST_WIDE_INT offset;\n-  /* TYpe of the result.  */\n+  /* Type of the result.  */\n   tree type;\n   /* Number of the caller's formal parameter being passed.  */\n   int formal_id;\n@@ -149,6 +149,108 @@ typedef struct GTY (()) ipa_jump_func\n DEF_VEC_O (ipa_jump_func_t);\n DEF_VEC_ALLOC_O (ipa_jump_func_t, gc);\n \n+/* Return the offset of the component that is decribed by a known type jump\n+   function JFUNC.  */\n+\n+static inline HOST_WIDE_INT\n+ipa_get_jf_known_type_offset (struct ipa_jump_func *jfunc)\n+{\n+  gcc_checking_assert (jfunc->type == IPA_JF_KNOWN_TYPE);\n+  return jfunc->value.known_type.offset;\n+}\n+\n+/* Return the base type of a known type jump function JFUNC.  */\n+\n+static inline tree\n+ipa_get_jf_known_type_base_type (struct ipa_jump_func *jfunc)\n+{\n+  gcc_checking_assert (jfunc->type == IPA_JF_KNOWN_TYPE);\n+  return jfunc->value.known_type.base_type;\n+}\n+\n+/* Return the component type of a known type jump function JFUNC.  */\n+\n+static inline tree\n+ipa_get_jf_known_type_component_type (struct ipa_jump_func *jfunc)\n+{\n+  gcc_checking_assert (jfunc->type == IPA_JF_KNOWN_TYPE);\n+  return jfunc->value.known_type.component_type;\n+}\n+\n+/* Return the constant stored in a constant jump functin JFUNC.  */\n+\n+static inline tree\n+ipa_get_jf_constant (struct ipa_jump_func *jfunc)\n+{\n+  gcc_checking_assert (jfunc->type == IPA_JF_CONST);\n+  return jfunc->value.constant;\n+}\n+\n+/* Return the operand of a pass through jmp function JFUNC.  */\n+\n+static inline tree\n+ipa_get_jf_pass_through_operand (struct ipa_jump_func *jfunc)\n+{\n+  gcc_checking_assert (jfunc->type == IPA_JF_PASS_THROUGH);\n+  return jfunc->value.pass_through.operand;\n+}\n+\n+/* Return the number of the caller's formal parameter that a pass through jump\n+   function JFUNC refers to.  */\n+\n+static inline int\n+ipa_get_jf_pass_through_formal_id (struct ipa_jump_func *jfunc)\n+{\n+  gcc_checking_assert (jfunc->type == IPA_JF_PASS_THROUGH);\n+  return jfunc->value.pass_through.formal_id;\n+}\n+\n+/* Return operation of a pass through jump function JFUNC.  */\n+\n+static inline enum tree_code\n+ipa_get_jf_pass_through_operation (struct ipa_jump_func *jfunc)\n+{\n+  gcc_checking_assert (jfunc->type == IPA_JF_PASS_THROUGH);\n+  return jfunc->value.pass_through.operation;\n+}\n+\n+/* Return the offset of an ancestor jump function JFUNC.  */\n+\n+static inline HOST_WIDE_INT\n+ipa_get_jf_ancestor_offset (struct ipa_jump_func *jfunc)\n+{\n+  gcc_checking_assert (jfunc->type == IPA_JF_ANCESTOR);\n+  return jfunc->value.ancestor.offset;\n+}\n+\n+/* Return the result type of an ancestor jump function JFUNC.  */\n+\n+static inline tree\n+ipa_get_jf_ancestor_type (struct ipa_jump_func *jfunc)\n+{\n+  gcc_checking_assert (jfunc->type == IPA_JF_ANCESTOR);\n+  return jfunc->value.ancestor.type;\n+}\n+\n+/* Return the number of the caller's formal parameter that an ancestor jump\n+   function JFUNC refers to.  */\n+\n+static inline int\n+ipa_get_jf_ancestor_formal_id (struct ipa_jump_func *jfunc)\n+{\n+  gcc_checking_assert (jfunc->type == IPA_JF_ANCESTOR);\n+  return jfunc->value.ancestor.formal_id;\n+}\n+\n+/* Return the pfn part of a member pointer constant jump function JFUNC.  */\n+\n+static inline tree\n+ipa_get_jf_member_ptr_pfn (struct ipa_jump_func *jfunc)\n+{\n+  gcc_checking_assert (jfunc->type == IPA_JF_CONST_MEMBER_PTR);\n+  return jfunc->value.member_cst.pfn;\n+}\n+\n /* Summary describing a single formal parameter.  */\n \n struct ipa_param_descriptor"}]}