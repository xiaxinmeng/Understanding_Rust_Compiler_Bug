{"sha": "40ac4f73faa256e049279c1611d47a685ff7f370", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBhYzRmNzNmYWEyNTZlMDQ5Mjc5YzE2MTFkNDdhNjg1ZmY3ZjM3MA==", "commit": {"author": {"name": "Christian Borntraeger", "email": "borntraeger@de.ibm.com", "date": "2010-04-08T15:07:57Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2010-04-08T15:07:57Z"}, "message": "Implement target hook for loop unrolling\n\n2010-04-08  Christian Borntraeger  <borntraeger@de.ibm.com>\n            Wolfgang Gellerich  <gellerich@de.ibm.com>\n\n        Implement target hook for loop unrolling\n        * target.h (loop_unroll_adjust): Add a new target hook function.\n        * target-def.h (TARGET_LOOP_UNROLL_ADJUST): Likewise.\n        * doc/tm.texi (TARGET_LOOP_UNROLL_ADJUST): Document it.\n        * config/s390/s390.c (TARGET_LOOP_UNROLL_ADJUST): Define it.\n        (s390_loop_unroll_adjust): Implement the new target hook for s390.\n        * loop-unroll.c (decide_unroll_runtime_iterations): Call loop unroll target hook\n        (decide_unroll_stupid): Likewise.\n\n\nCo-Authored-By: Wolfgang Gellerich <gellerich@de.ibm.com>\n\nFrom-SVN: r158132", "tree": {"sha": "0ebeefa37492fc33063a9f55bc090391a092d0fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ebeefa37492fc33063a9f55bc090391a092d0fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40ac4f73faa256e049279c1611d47a685ff7f370", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40ac4f73faa256e049279c1611d47a685ff7f370", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40ac4f73faa256e049279c1611d47a685ff7f370", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40ac4f73faa256e049279c1611d47a685ff7f370/comments", "author": {"login": "borntraeger", "id": 3006059, "node_id": "MDQ6VXNlcjMwMDYwNTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3006059?v=4", "gravatar_id": "", "url": "https://api.github.com/users/borntraeger", "html_url": "https://github.com/borntraeger", "followers_url": "https://api.github.com/users/borntraeger/followers", "following_url": "https://api.github.com/users/borntraeger/following{/other_user}", "gists_url": "https://api.github.com/users/borntraeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/borntraeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/borntraeger/subscriptions", "organizations_url": "https://api.github.com/users/borntraeger/orgs", "repos_url": "https://api.github.com/users/borntraeger/repos", "events_url": "https://api.github.com/users/borntraeger/events{/privacy}", "received_events_url": "https://api.github.com/users/borntraeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "07c60ef701e0fe0c65f0186bd521ee83b6c24c3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07c60ef701e0fe0c65f0186bd521ee83b6c24c3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07c60ef701e0fe0c65f0186bd521ee83b6c24c3c"}], "stats": {"total": 96, "additions": 96, "deletions": 0}, "files": [{"sha": "ecf1f2697ea6f9afb1826a27b6c9582f1c42de5e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40ac4f73faa256e049279c1611d47a685ff7f370/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40ac4f73faa256e049279c1611d47a685ff7f370/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40ac4f73faa256e049279c1611d47a685ff7f370", "patch": "@@ -1,3 +1,15 @@\n+2010-04-08  Christian Borntraeger  <borntraeger@de.ibm.com>\n+            Wolfgang Gellerich  <gellerich@de.ibm.com>\n+\n+        Implement target hook for loop unrolling\n+        * target.h (loop_unroll_adjust): Add a new target hook function.\n+        * target-def.h (TARGET_LOOP_UNROLL_ADJUST): Likewise.\n+        * doc/tm.texi (TARGET_LOOP_UNROLL_ADJUST): Document it.\n+        * config/s390/s390.c (TARGET_LOOP_UNROLL_ADJUST): Define it.\n+        (s390_loop_unroll_adjust): Implement the new target hook for s390.\n+        * loop-unroll.c (decide_unroll_runtime_iterations): Call loop unroll target hook\n+        (decide_unroll_stupid): Likewise.\n+\n 2010-04-08  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR target/43643"}, {"sha": "fea70fb3e3b6dfc8c450ca40084c416192ce71b6", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40ac4f73faa256e049279c1611d47a685ff7f370/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40ac4f73faa256e049279c1611d47a685ff7f370/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=40ac4f73faa256e049279c1611d47a685ff7f370", "patch": "@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple.h\"\n #include \"df.h\"\n #include \"params.h\"\n+#include \"cfgloop.h\"\n \n \n /* Define the specific costs for a given cpu.  */\n@@ -10245,6 +10246,62 @@ s390_sched_init (FILE *file ATTRIBUTE_UNUSED,\n   last_scheduled_insn = NULL_RTX;\n }\n \n+/* This function checks the whole of insn X for memory references. The\n+   function always returns zero because the framework it is called\n+   from would stop recursively analyzing the insn upon a return value\n+   other than zero. The real result of this function is updating\n+   counter variable MEM_COUNT.  */\n+static int\n+check_dpu (rtx *x, unsigned *mem_count)\n+{\n+  if (*x != NULL_RTX && MEM_P (*x))\n+    (*mem_count)++;\n+  return 0;\n+}\n+\n+/* This target hook implementation for TARGET_LOOP_UNROLL_ADJUST calculates\n+   a new number struct loop *loop should be unrolled if tuned for the z10\n+   cpu. The loop is analyzed for memory accesses by calling check_dpu for\n+   each rtx of the loop. Depending on the loop_depth and the amount of\n+   memory accesses a new number <=nunroll is returned to improve the\n+   behaviour of the hardware prefetch unit.  */\n+static unsigned\n+s390_loop_unroll_adjust (unsigned nunroll, struct loop *loop)\n+{\n+  basic_block *bbs;\n+  rtx insn;\n+  unsigned i;\n+  unsigned mem_count = 0;\n+\n+  /* Only z10 needs special handling.  */\n+  if (s390_tune != PROCESSOR_2097_Z10)\n+    return nunroll;\n+\n+  /* Count the number of memory references within the loop body.  */\n+  bbs = get_loop_body (loop);\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      for (insn = BB_HEAD (bbs[i]); insn != BB_END (bbs[i]); insn = NEXT_INSN (insn))\n+\tif (INSN_P (insn) && INSN_CODE (insn) != -1)\n+            for_each_rtx (&insn, (rtx_function) check_dpu, &mem_count);\n+    }\n+  free (bbs);\n+\n+  /* Prevent division by zero, and we do not need to adjust nunroll in this case.  */\n+  if (mem_count == 0)\n+    return nunroll;\n+\n+  switch (loop_depth(loop))\n+    {\n+    case 1:\n+      return MIN (nunroll, 28 / mem_count);\n+    case 2:\n+      return MIN (nunroll, 22 / mem_count);\n+    default:\n+      return MIN (nunroll, 16 / mem_count);\n+    }\n+}\n+\n /* Initialize GCC target structure.  */\n \n #undef  TARGET_ASM_ALIGNED_HI_OP\n@@ -10373,6 +10430,9 @@ s390_sched_init (FILE *file ATTRIBUTE_UNUSED,\n #undef TARGET_CAN_ELIMINATE\n #define TARGET_CAN_ELIMINATE s390_can_eliminate\n \n+#undef TARGET_LOOP_UNROLL_ADJUST\n+#define TARGET_LOOP_UNROLL_ADJUST s390_loop_unroll_adjust\n+\n #undef TARGET_ASM_TRAMPOLINE_TEMPLATE\n #define TARGET_ASM_TRAMPOLINE_TEMPLATE s390_asm_trampoline_template\n #undef TARGET_TRAMPOLINE_INIT"}, {"sha": "222117d8207bc032d59ddda3bee6a2700f4a3ed3", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40ac4f73faa256e049279c1611d47a685ff7f370/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40ac4f73faa256e049279c1611d47a685ff7f370/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=40ac4f73faa256e049279c1611d47a685ff7f370", "patch": "@@ -10881,6 +10881,15 @@ This target hook is required only when the target has several different\n modes and they have different conditional execution capability, such as ARM.\n @end deftypefn\n \n+@deftypefn {Target Hook} unsigned TARGET_LOOP_UNROLL_ADJUST (unsigned @var{nunroll}, struct loop *@var{loop})\n+This target hook returns a new value for the number of times @var{loop}\n+should be unrolled. The parameter @var{nunroll} is the number of times\n+the loop is to be unrolled. The parameter @var{loop} is a pointer to\n+the loop, which is going to be checked for unrolling. This target hook\n+is required only when the target has special constraints like maximum\n+number of memory accesses.\n+@end deftypefn\n+\n @defmac POWI_MAX_MULTS\n If defined, this macro is interpreted as a signed integer C expression\n that specifies the maximum number of floating point multiplications"}, {"sha": "8ea449d6bb772d60c74065a97c6a9903f7924429", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40ac4f73faa256e049279c1611d47a685ff7f370/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40ac4f73faa256e049279c1611d47a685ff7f370/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=40ac4f73faa256e049279c1611d47a685ff7f370", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"hashtab.h\"\n #include \"recog.h\"\n+#include \"target.h\"\n \n /* This pass performs loop unrolling and peeling.  We only perform these\n    optimizations on innermost loops (with single exception) because\n@@ -826,6 +827,9 @@ decide_unroll_runtime_iterations (struct loop *loop, int flags)\n   if (nunroll > (unsigned) PARAM_VALUE (PARAM_MAX_UNROLL_TIMES))\n     nunroll = PARAM_VALUE (PARAM_MAX_UNROLL_TIMES);\n \n+  if (targetm.loop_unroll_adjust)\n+    nunroll = targetm.loop_unroll_adjust (nunroll, loop);\n+\n   /* Skip big loops.  */\n   if (nunroll <= 1)\n     {\n@@ -1366,6 +1370,9 @@ decide_unroll_stupid (struct loop *loop, int flags)\n   if (nunroll > (unsigned) PARAM_VALUE (PARAM_MAX_UNROLL_TIMES))\n     nunroll = PARAM_VALUE (PARAM_MAX_UNROLL_TIMES);\n \n+  if (targetm.loop_unroll_adjust)\n+    nunroll = targetm.loop_unroll_adjust (nunroll, loop);\n+\n   /* Skip big loops.  */\n   if (nunroll <= 1)\n     {"}, {"sha": "d0566650cf78090685c89f9e05efd36267fb4692", "filename": "gcc/target-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40ac4f73faa256e049279c1611d47a685ff7f370/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40ac4f73faa256e049279c1611d47a685ff7f370/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=40ac4f73faa256e049279c1611d47a685ff7f370", "patch": "@@ -545,6 +545,7 @@\n   default_branch_target_register_class\n #define TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED hook_bool_bool_false\n #define TARGET_HAVE_CONDITIONAL_EXECUTION default_have_conditional_execution\n+#define TARGET_LOOP_UNROLL_ADJUST NULL\n #define TARGET_CANNOT_FORCE_CONST_MEM hook_bool_rtx_false\n #define TARGET_CANNOT_COPY_INSN_P NULL\n #define TARGET_COMMUTATIVE_P hook_bool_const_rtx_commutative_p\n@@ -947,6 +948,7 @@\n   TARGET_BRANCH_TARGET_REGISTER_CLASS,\t\t\\\n   TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED,\t\\\n   TARGET_HAVE_CONDITIONAL_EXECUTION,\t\t\\\n+  TARGET_LOOP_UNROLL_ADJUST,\t\t\t\\\n   TARGET_CANNOT_FORCE_CONST_MEM,\t\t\\\n   TARGET_CANNOT_COPY_INSN_P,\t\t\t\\\n   TARGET_COMMUTATIVE_P,\t\t\t\t\\"}, {"sha": "e4e82a3dcbd797c837155078d10617edf37ab407", "filename": "gcc/target.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40ac4f73faa256e049279c1611d47a685ff7f370/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40ac4f73faa256e049279c1611d47a685ff7f370/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=40ac4f73faa256e049279c1611d47a685ff7f370", "patch": "@@ -97,6 +97,9 @@ struct _dep;\n /* This is defined in ddg.h .  */\n struct ddg;\n \n+/* This is defined in cfgloop.h .  */\n+struct loop;\n+\n /* Assembler instructions for creating various kinds of integer object.  */\n \n struct asm_int_op\n@@ -637,6 +640,9 @@ struct gcc_target\n   /* Return true if the target supports conditional execution.  */\n   bool (* have_conditional_execution) (void);\n \n+  /* Return a new value for loop unroll size.  */\n+  unsigned (* loop_unroll_adjust) (unsigned nunroll, struct loop *loop);\n+\n   /* True if the constant X cannot be placed in the constant pool.  */\n   bool (* cannot_force_const_mem) (rtx);\n "}]}