{"sha": "4d3b7be281e73ecdaa233598db1a8390422b7770", "node_id": "C_kwDOANBUbNoAKDRkM2I3YmUyODFlNzNlY2RhYTIzMzU5OGRiMWE4MzkwNDIyYjc3NzA", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-02-16T23:12:55Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-02-16T23:12:55Z"}, "message": "analyzer: respect some conditions from bit masks [PR108806]\n\nPR analyzer/108806 reports false +ves seen from -fanalyzer on code like this\nin qemu-7.2.0's hw/intc/omap_intc.c:\n\n  [...snip...]\n  struct omap_intr_handler_bank_s* bank = NULL;\n  if ((offset & 0xf80) == 0x80) {\n    [...set \"bank\" to non-NULL...]\n  }\n  switch (offset) {\n    [...snip various cases that don't deref \"bank\"...]\n    case 0x80:\n      return bank->inputs;\n    case 0x84:\n      return bank->mask;\n    [...etc...]\n   }\n\nwhere the analyzer falsely complains about execution paths in which\n\"(offset & 0xf80) == 0x80\" was false (leaving \"bank\" as NULL), but then\nin which \"switch (offset)\" goes to a case for which\n\"(offset & 0xf80) == 0x80\" is true and dereferences NULL \"bank\", i.e.\npaths in which \"(offset & 0xf80) == 0x80\" is both true *and* false.\n\nThis patch adds enough logic to constraint_manager for -fanalyzer to\nreject such execution paths as impossible, fixing the false +ves.\n\nIntegration testing shows this eliminates 20 probable false positives:\n\nComparison: 9.08% -> 9.34% GOOD: 66 BAD: 661 -> 641 (-20)\n\nwhere the affected warnings/projects are:\n\n  -Wanalyzer-null-dereference: 0.00% GOOD: 0 BAD: 279 -> 269 (-10)\n        qemu-7.2.0: 175 -> 165 (-10)\n\n  -Wanalyzer-use-of-uninitialized-value: 0.00% GOOD: 0 BAD: 153 -> 143 (-10)\n     coreutils-9.1:  18 ->  14 (-4)\n        qemu-7.2.0:  54 ->  48 (-6)\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/108806\n\t* constraint-manager.cc (bounded_range::dump_to_pp): Use\n\tbounded_range::singleton_p.\n\t(constraint_manager::add_bounded_ranges): Handle singleton ranges\n\tby adding an EQ_EXPR constraint.\n\t(constraint_manager::impossible_derived_conditions_p): New.\n\t(constraint_manager::eval_condition): Reject EQ_EXPR when it would\n\timply impossible derived conditions.\n\t(selftest::test_bits): New.\n\t(selftest::run_constraint_manager_tests): Run it.\n\t* constraint-manager.h (bounded_range::singleton_p): New.\n\t(constraint_manager::impossible_derived_conditions_p): New decl.\n\t* region-model.cc (region_model::get_rvalue_1): Handle\n\tBIT_AND_EXPR, BIT_IOR_EXPR, and BIT_XOR_EXPR.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/108806\n\t* gcc.dg/analyzer/null-deref-pr108806-qemu.c: New test.\n\t* gcc.dg/analyzer/pr103217.c: Add -Wno-analyzer-too-complex.\n\t* gcc.dg/analyzer/switch.c (test_bitmask_1): New.\n\t(test_bitmask_2): New.\n\t* gcc.dg/analyzer/uninit-pr108806-qemu.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "eb03567b1a6b8f1e3bb42304615b6f043dd97ed1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb03567b1a6b8f1e3bb42304615b6f043dd97ed1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d3b7be281e73ecdaa233598db1a8390422b7770", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d3b7be281e73ecdaa233598db1a8390422b7770", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d3b7be281e73ecdaa233598db1a8390422b7770", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d3b7be281e73ecdaa233598db1a8390422b7770/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c381327dd6c2d9996702b2a341b91cf48942a8ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c381327dd6c2d9996702b2a341b91cf48942a8ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c381327dd6c2d9996702b2a341b91cf48942a8ae"}], "stats": {"total": 467, "additions": 466, "deletions": 1}, "files": [{"sha": "2c9c435527ea6ddcf0d9539e86ce441540851665", "filename": "gcc/analyzer/constraint-manager.cc", "status": "modified", "additions": 165, "deletions": 1, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3b7be281e73ecdaa233598db1a8390422b7770/gcc%2Fanalyzer%2Fconstraint-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3b7be281e73ecdaa233598db1a8390422b7770/gcc%2Fanalyzer%2Fconstraint-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.cc?ref=4d3b7be281e73ecdaa233598db1a8390422b7770", "patch": "@@ -421,7 +421,7 @@ dump_cst (pretty_printer *pp, tree cst, bool show_types)\n void\n bounded_range::dump_to_pp (pretty_printer *pp, bool show_types) const\n {\n-  if (tree_int_cst_equal (m_lower, m_upper))\n+  if (singleton_p ())\n     dump_cst (pp, m_lower, show_types);\n   else\n     {\n@@ -2118,6 +2118,17 @@ bool\n constraint_manager::add_bounded_ranges (const svalue *sval,\n \t\t\t\t\tconst bounded_ranges *ranges)\n {\n+  /* If RANGES is just a singleton, convert this to adding the constraint:\n+     \"SVAL == {the singleton}\".  */\n+  if (ranges->get_count () == 1\n+      && ranges->get_range (0).singleton_p ())\n+    {\n+      tree range_cst = ranges->get_range (0).m_lower;\n+      const svalue *range_sval\n+\t= m_mgr->get_or_create_constant_svalue (range_cst);\n+      return add_constraint (sval, EQ_EXPR, range_sval);\n+    }\n+\n   sval = sval->unwrap_any_unmergeable ();\n \n   /* Nothing can be known about unknown/poisoned values.  */\n@@ -2466,6 +2477,66 @@ constraint_manager::eval_condition (equiv_class_id lhs_ec,\n   return tristate::unknown ();\n }\n \n+/* Return true iff \"LHS == RHS\" is known to be impossible due to\n+   derived conditions.\n+\n+   Look for an EC containing an EC_VAL of the form (LHS OP CST).\n+   If found, see if (LHS OP CST) == EC_VAL is false.\n+   If so, we know this condition is false.\n+\n+   For example, if we already know that\n+     (X & CST_MASK) == Y\n+   and we're evaluating X == Z, we can test to see if\n+     (Z & CST_MASK) == EC_VAL\n+   and thus if:\n+     (Z & CST_MASK) == Y\n+   and reject this if we know that's false.  */\n+\n+bool\n+constraint_manager::impossible_derived_conditions_p (const svalue *lhs,\n+\t\t\t\t\t\t     const svalue *rhs) const\n+{\n+  int i;\n+  equiv_class *ec;\n+  FOR_EACH_VEC_ELT (m_equiv_classes, i, ec)\n+    {\n+      for (const svalue *ec_sval : ec->m_vars)\n+\tswitch (ec_sval->get_kind ())\n+\t  {\n+\t  default:\n+\t    break;\n+\t  case SK_BINOP:\n+\t    {\n+\t      const binop_svalue *iter_binop\n+\t\t= as_a <const binop_svalue *> (ec_sval);\n+\t      if (lhs == iter_binop->get_arg0 ()\n+\t\t  && iter_binop->get_type ())\n+\t\tif (iter_binop->get_arg1 ()->get_kind () == SK_CONSTANT)\n+\t\t  {\n+\t\t    /* Try evalating EC_SVAL with LHS\n+\t\t       as the value of EC_SVAL's lhs, and see if it's\n+\t\t       consistent with existing knowledge.  */\n+\t\t    const svalue *subst_bin_op\n+\t\t      = m_mgr->get_or_create_binop\n+\t\t      (iter_binop->get_type (),\n+\t\t       iter_binop->get_op (),\n+\t\t       rhs,\n+\t\t       iter_binop->get_arg1 ());\n+\t\t    tristate t = eval_condition (subst_bin_op,\n+\t\t\t\t\t\t EQ_EXPR,\n+\t\t\t\t\t\t ec_sval);\n+\t\t    if (t.is_false ())\n+\t\t      return true; /* Impossible.  */\n+\t\t  }\n+\t    }\n+\t    break;\n+\t  }\n+    }\n+  /* Not known to be impossible.  */\n+  return false;\n+}\n+\n+\n /* Evaluate the condition LHS OP RHS, without modifying this\n    constraint_manager (avoiding the creation of equiv_class instances).  */\n \n@@ -2516,6 +2587,10 @@ constraint_manager::eval_condition (const svalue *lhs,\n \treturn result_for_ecs;\n     }\n \n+  if (op == EQ_EXPR\n+      && impossible_derived_conditions_p (lhs, rhs))\n+    return false;\n+\n   /* If at least one is not in an EC, we have no constraints\n      comparing LHS and RHS yet.\n      They might still be comparable if one (or both) is a constant.\n@@ -4435,6 +4510,94 @@ test_bounded_ranges ()\n \t     mgr.get_or_create_point (ch1));\n }\n \n+/* Verify that we can handle sufficiently simple bitmasking operations.  */\n+\n+static void\n+test_bits (void)\n+{\n+  region_model_manager mgr;\n+\n+  tree int_0 = build_int_cst (integer_type_node, 0);\n+  tree int_0x80 = build_int_cst (integer_type_node, 0x80);\n+  tree int_0xff = build_int_cst (integer_type_node, 0xff);\n+  tree x = build_global_decl (\"x\", integer_type_node);\n+\n+  tree x_bit_and_0x80 = build2 (BIT_AND_EXPR, integer_type_node, x, int_0x80);\n+  tree x_bit_and_0xff = build2 (BIT_AND_EXPR, integer_type_node, x, int_0xff);\n+\n+  /* \"x & 0x80 == 0x80\".  */\n+  {\n+    region_model model (&mgr);\n+    ADD_SAT_CONSTRAINT (model, x_bit_and_0x80, EQ_EXPR, int_0x80);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, int_0);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, int_0x80);\n+  }\n+\n+  /* \"x & 0x80 != 0x80\".  */\n+  {\n+    region_model model (&mgr);\n+    ADD_SAT_CONSTRAINT (model, x_bit_and_0x80, NE_EXPR, int_0x80);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, int_0);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, int_0x80);\n+  }\n+\n+  /* \"x & 0x80 == 0\".  */\n+  {\n+    region_model model (&mgr);\n+\n+    ADD_SAT_CONSTRAINT (model, x_bit_and_0x80, EQ_EXPR, int_0);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, int_0);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, int_0x80);\n+  }\n+\n+  /* \"x & 0x80 != 0\".  */\n+  {\n+    region_model model (&mgr);\n+    ADD_SAT_CONSTRAINT (model, x_bit_and_0x80, NE_EXPR, int_0);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, int_0);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, int_0x80);\n+  }\n+\n+  /* More that one bit in the mask.  */\n+\n+  /* \"x & 0xff == 0x80\".  */\n+  {\n+    region_model model (&mgr);\n+    ADD_SAT_CONSTRAINT (model, x_bit_and_0xff, EQ_EXPR, int_0x80);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, int_0);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, int_0x80);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, int_0xff);\n+  }\n+\n+  /* \"x & 0xff != 0x80\".  */\n+  {\n+    region_model model (&mgr);\n+    ADD_SAT_CONSTRAINT (model, x_bit_and_0xff, NE_EXPR, int_0x80);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, int_0);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, int_0x80);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, int_0xff);\n+  }\n+\n+  /* \"x & 0xff == 0\".  */\n+  {\n+    region_model model (&mgr);\n+\n+    ADD_SAT_CONSTRAINT (model, x_bit_and_0xff, EQ_EXPR, int_0);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, int_0);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, int_0x80);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, int_0xff);\n+  }\n+\n+  /* \"x & 0xff != 0\".  */\n+  {\n+    region_model model (&mgr);\n+    ADD_SAT_CONSTRAINT (model, x_bit_and_0xff, NE_EXPR, int_0);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, int_0);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, int_0x80);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, int_0xff);\n+  }\n+}\n+\n /* Run the selftests in this file, temporarily overriding\n    flag_analyzer_transitivity with TRANSITIVITY.  */\n \n@@ -4458,6 +4621,7 @@ run_constraint_manager_tests (bool transitivity)\n   test_purging ();\n   test_bounded_range ();\n   test_bounded_ranges ();\n+  test_bits ();\n \n   flag_analyzer_transitivity = saved_flag_analyzer_transitivity;\n }"}, {"sha": "3afbc7f848e9f4f3acd7919cc11b2e4a34970ed7", "filename": "gcc/analyzer/constraint-manager.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3b7be281e73ecdaa233598db1a8390422b7770/gcc%2Fanalyzer%2Fconstraint-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3b7be281e73ecdaa233598db1a8390422b7770/gcc%2Fanalyzer%2Fconstraint-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.h?ref=4d3b7be281e73ecdaa233598db1a8390422b7770", "patch": "@@ -100,6 +100,11 @@ struct bounded_range\n \n   static int cmp (const bounded_range &a, const bounded_range &b);\n \n+  bool singleton_p () const\n+  {\n+    return tree_int_cst_equal (m_lower, m_upper);\n+  }\n+\n   tree m_lower;\n   tree m_upper;\n \n@@ -498,6 +503,8 @@ class constraint_manager\n   void add_constraint_internal (equiv_class_id lhs_id,\n \t\t\t\tenum constraint_op c_op,\n \t\t\t\tequiv_class_id rhs_id);\n+  bool impossible_derived_conditions_p (const svalue *lhs,\n+\t\t\t\t\tconst svalue *rhs) const;\n \n   region_model_manager *m_mgr;\n };"}, {"sha": "e3de74bbf45baf39469ee53be32facaf74b13b55", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3b7be281e73ecdaa233598db1a8390422b7770/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3b7be281e73ecdaa233598db1a8390422b7770/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=4d3b7be281e73ecdaa233598db1a8390422b7770", "patch": "@@ -2253,6 +2253,9 @@ region_model::get_rvalue_1 (path_var pv, region_model_context *ctxt) const\n     /* Binary ops.  */\n     case PLUS_EXPR:\n     case MULT_EXPR:\n+    case BIT_AND_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n \t{\n \t  tree expr = pv.m_tree;\n \t  tree arg0 = TREE_OPERAND (expr, 0);"}, {"sha": "3ab72c053af74223284164bd969be0f3579f8f9d", "filename": "gcc/testsuite/gcc.dg/analyzer/null-deref-pr108806-qemu.c", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3b7be281e73ecdaa233598db1a8390422b7770/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fnull-deref-pr108806-qemu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3b7be281e73ecdaa233598db1a8390422b7770/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fnull-deref-pr108806-qemu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fnull-deref-pr108806-qemu.c?ref=4d3b7be281e73ecdaa233598db1a8390422b7770", "patch": "@@ -0,0 +1,105 @@\n+/* Reduced from qemu-7.2.0's hw/intc/omap_intc.c */\n+\n+#define NULL ((void*)0)\n+\n+typedef unsigned char __uint8_t;\n+typedef unsigned int __uint32_t;\n+typedef unsigned long int __uint64_t;\n+typedef __uint8_t uint8_t;\n+typedef __uint32_t uint32_t;\n+typedef __uint64_t uint64_t;\n+typedef uint64_t hwaddr;\n+typedef struct omap_intr_handler_s omap_intr_handler;\n+\n+struct omap_intr_handler_bank_s\n+{\n+  uint32_t irqs;\n+  uint32_t inputs;\n+  uint32_t mask;\n+  uint32_t fiq;\n+  uint32_t sens_edge;\n+  uint32_t swi;\n+  unsigned char priority[32];\n+};\n+\n+struct omap_intr_handler_s\n+{\n+  /* [...snip...] */\n+  unsigned char nbanks;\n+  /* [...snip...] */\n+  int sir_intr[2];\n+  int autoidle;\n+  uint32_t mask;\n+  struct omap_intr_handler_bank_s bank[3];\n+};\n+\n+uint64_t\n+omap2_inth_read(struct omap_intr_handler_s* s, int offset)\n+{\n+  int bank_no, line_no;\n+  struct omap_intr_handler_bank_s* bank = NULL;\n+\n+  if ((offset & 0xf80) == 0x80) {\n+    bank_no = (offset & 0x60) >> 5;\n+    if (bank_no < s->nbanks) {\n+      offset &= ~0x60;\n+      bank = &s->bank[bank_no];\n+    } else {\n+      return 0;\n+    }\n+  }\n+\n+  switch (offset) {\n+    case 0x10:\n+      return (s->autoidle >> 2) & 1;\n+\n+    case 0x14:\n+      return 1;\n+\n+    case 0x40:\n+      return s->sir_intr[0];\n+\n+    case 0x44:\n+      return s->sir_intr[1];\n+\n+    case 0x48:\n+      return (!s->mask) << 2;\n+\n+    case 0x4c:\n+      return 0;\n+\n+    case 0x50:\n+      return s->autoidle & 3;\n+\n+    case 0x80:\n+      return bank->inputs; /* { dg-bogus \"dereference of NULL 'bank'\" \"PR analyzer/108806\" } */\n+\n+    case 0x84:\n+      return bank->mask; /* { dg-bogus \"dereference of NULL 'bank'\" \"PR analyzer/108806\" } */\n+\n+    case 0x88:\n+    case 0x8c:\n+      return 0;\n+\n+    case 0x90:\n+      return bank->swi; /* { dg-bogus \"dereference of NULL 'bank'\" \"PR analyzer/108806\" } */\n+\n+    case 0x94:\n+      return 0;\n+\n+    case 0x98:\n+      return bank->irqs & ~bank->mask & ~bank->fiq; /* { dg-bogus \"dereference of NULL 'bank'\" \"PR analyzer/108806\" } */\n+\n+    case 0x9c:\n+      return bank->irqs & ~bank->mask & bank->fiq; /* { dg-bogus \"dereference of NULL 'bank'\" \"PR analyzer/108806\" } */\n+\n+    case 0x100 ... 0x300:\n+      bank_no = (offset - 0x100) >> 7;\n+      if (bank_no > s->nbanks)\n+        break;\n+      bank = &s->bank[bank_no];\n+      line_no = (offset & 0x7f) >> 2;\n+      return (bank->priority[line_no] << 2) | ((bank->fiq >> line_no) & 1);\n+  }\n+  return 0;\n+}"}, {"sha": "08889acb2c912ecba216451c43c0dfe3a28cbfab", "filename": "gcc/testsuite/gcc.dg/analyzer/pr103217.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3b7be281e73ecdaa233598db1a8390422b7770/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr103217.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3b7be281e73ecdaa233598db1a8390422b7770/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr103217.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr103217.c?ref=4d3b7be281e73ecdaa233598db1a8390422b7770", "patch": "@@ -1,3 +1,5 @@\n+/* { dg-additional-options \"-Wno-analyzer-too-complex\" } */\n+\n extern char *strdup (const char *__s)\n   __attribute__ ((__nothrow__ , __leaf__, __malloc__, __nonnull__ (1)));\n "}, {"sha": "5f42e7f21db986e357ff4f8b1aad0478c6be1461", "filename": "gcc/testsuite/gcc.dg/analyzer/switch.c", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3b7be281e73ecdaa233598db1a8390422b7770/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3b7be281e73ecdaa233598db1a8390422b7770/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fswitch.c?ref=4d3b7be281e73ecdaa233598db1a8390422b7770", "patch": "@@ -161,3 +161,79 @@ int test_7 ()\n \t}\n \treturn 0;\n }\n+\n+int test_bitmask_1 (int x)\n+{\n+  int flag = 0;\n+  if (x & 0x80)\n+    flag = 1;\n+\n+  switch (x)\n+    {\n+    case 0:\n+      if (flag)\n+\t__analyzer_dump_path ();  /* { dg-bogus \"path\" } */\n+      else\n+\t__analyzer_dump_path ();  /* { dg-message \"path\" } */\n+      break;\n+\n+    case 0x80:\n+      if (flag)\n+\t__analyzer_dump_path ();  /* { dg-message \"path\" } */\n+      else\n+\t__analyzer_dump_path ();  /* { dg-bogus \"path\" } */\n+      break;\n+\n+    case 0x81:\n+      if (flag)\n+\t__analyzer_dump_path ();  /* { dg-message \"path\" } */\n+      else\n+\t__analyzer_dump_path ();  /* { dg-bogus \"path\" } */\n+      break;\n+    }\n+}\n+\n+int test_bitmask_2 (int x)\n+{\n+  int flag = 0;\n+  if ((x & 0xf80) == 0x80)\n+    flag = 1;\n+\n+  switch (x)\n+    {\n+    case 0:\n+      if (flag)\n+\t__analyzer_dump_path ();  /* { dg-bogus \"path\" } */\n+      else\n+\t__analyzer_dump_path ();  /* { dg-message \"path\" } */\n+      break;\n+\n+    case 0x80:\n+      if (flag)\n+\t__analyzer_dump_path ();  /* { dg-message \"path\" } */\n+      else\n+\t__analyzer_dump_path ();  /* { dg-bogus \"path\" } */\n+      break;\n+\n+    case 0x81:\n+      if (flag)\n+\t__analyzer_dump_path ();  /* { dg-message \"path\" } */\n+      else\n+\t__analyzer_dump_path ();  /* { dg-bogus \"path\" } */\n+      break;\n+\n+    case 0x180:\n+      if (flag)\n+\t__analyzer_dump_path ();  /* { dg-bogus \"path\" } */\n+      else\n+\t__analyzer_dump_path ();  /* { dg-message \"path\" } */\n+      break;\n+\n+    case 0xf80:\n+      if (flag)\n+\t__analyzer_dump_path ();  /* { dg-bogus \"path\" } */\n+      else\n+\t__analyzer_dump_path ();  /* { dg-message \"path\" } */\n+      break;\n+    }\n+}"}, {"sha": "34fe802f4952d34847359b10db6292e99f18b34b", "filename": "gcc/testsuite/gcc.dg/analyzer/uninit-pr108806-qemu.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3b7be281e73ecdaa233598db1a8390422b7770/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-pr108806-qemu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3b7be281e73ecdaa233598db1a8390422b7770/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-pr108806-qemu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-pr108806-qemu.c?ref=4d3b7be281e73ecdaa233598db1a8390422b7770", "patch": "@@ -0,0 +1,108 @@\n+/* Reduced from qemu-7.2.0's hw/intc/omap_intc.c as per\n+   null-deref-pr108806.c, but with the:\n+     struct omap_intr_handler_bank_s* bank = NULL;\n+   converted to:\n+     struct omap_intr_handler_bank_s* bank;\n+ */\n+\n+typedef unsigned char __uint8_t;\n+typedef unsigned int __uint32_t;\n+typedef unsigned long int __uint64_t;\n+typedef __uint8_t uint8_t;\n+typedef __uint32_t uint32_t;\n+typedef __uint64_t uint64_t;\n+typedef uint64_t hwaddr;\n+typedef struct omap_intr_handler_s omap_intr_handler;\n+\n+struct omap_intr_handler_bank_s\n+{\n+  uint32_t irqs;\n+  uint32_t inputs;\n+  uint32_t mask;\n+  uint32_t fiq;\n+  uint32_t sens_edge;\n+  uint32_t swi;\n+  unsigned char priority[32];\n+};\n+\n+struct omap_intr_handler_s\n+{\n+  /* [...snip...] */\n+  unsigned char nbanks;\n+  /* [...snip...] */\n+  int sir_intr[2];\n+  int autoidle;\n+  uint32_t mask;\n+  struct omap_intr_handler_bank_s bank[3];\n+};\n+\n+uint64_t\n+omap2_inth_read(struct omap_intr_handler_s* s, int offset)\n+{\n+  int bank_no, line_no;\n+  struct omap_intr_handler_bank_s* bank;\n+\n+  if ((offset & 0xf80) == 0x80) {\n+    bank_no = (offset & 0x60) >> 5;\n+    if (bank_no < s->nbanks) {\n+      offset &= ~0x60;\n+      bank = &s->bank[bank_no];\n+    } else {\n+      return 0;\n+    }\n+  }\n+\n+  switch (offset) {\n+    case 0x10:\n+      return (s->autoidle >> 2) & 1;\n+\n+    case 0x14:\n+      return 1;\n+\n+    case 0x40:\n+      return s->sir_intr[0];\n+\n+    case 0x44:\n+      return s->sir_intr[1];\n+\n+    case 0x48:\n+      return (!s->mask) << 2;\n+\n+    case 0x4c:\n+      return 0;\n+\n+    case 0x50:\n+      return s->autoidle & 3;\n+\n+    case 0x80:\n+      return bank->inputs; /* { dg-bogus \"use of uninitialized value 'bank'\" \"PR analyzer/108806\" } */\n+\n+    case 0x84:\n+      return bank->mask; /* { dg-bogus \"use of uninitialized value 'bank'\" \"PR analyzer/108806\" } */\n+\n+    case 0x88:\n+    case 0x8c:\n+      return 0;\n+\n+    case 0x90:\n+      return bank->swi; /* { dg-bogus \"use of uninitialized value 'bank'\" \"PR analyzer/108806\" } */\n+\n+    case 0x94:\n+      return 0;\n+\n+    case 0x98:\n+      return bank->irqs & ~bank->mask & ~bank->fiq; /* { dg-bogus \"use of uninitialized value 'bank'\" \"PR analyzer/108806\" } */\n+\n+    case 0x9c:\n+      return bank->irqs & ~bank->mask & bank->fiq; /* { dg-bogus \"use of uninitialized value 'bank'\" \"PR analyzer/108806\" } */\n+\n+    case 0x100 ... 0x300:\n+      bank_no = (offset - 0x100) >> 7;\n+      if (bank_no > s->nbanks)\n+        break;\n+      bank = &s->bank[bank_no];\n+      line_no = (offset & 0x7f) >> 2;\n+      return (bank->priority[line_no] << 2) | ((bank->fiq >> line_no) & 1);\n+  }\n+  return 0;\n+}"}]}