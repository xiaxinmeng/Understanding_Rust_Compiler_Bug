{"sha": "429268fc04441a4a6e31bc9e3c303a8f355f7c43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI5MjY4ZmMwNDQ0MWE0YTZlMzFiYzllM2MzMDNhOGYzNTVmN2M0Mw==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2005-08-21T06:38:27Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2005-08-21T06:38:27Z"}, "message": "tree-vect-transform.c (get_initial_def_for_reduction): Set need_epilog_adjust back to false for MIN/MAX case.\n\n        * tree-vect-transform.c (get_initial_def_for_reduction): Set\n        need_epilog_adjust back to false for MIN/MAX case. Set *scalar_def to\n        NULL if need_epilog_adjust is false.\n        (vect_create_epilog_for_reduction): Variable adjust_in_epilog removed.\n        Case 3 always peels first itration, not just for PLUS case, and no need\n        to use scalar_initial_def here. Create an epilog adjustment only if\n        scalar_initial_def is not NULL.\n\n        (vectorizable_reduction): Remove assert.\n\nFrom-SVN: r103314", "tree": {"sha": "9ef2d640818ab5af249622f39482a2b1d04efbf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ef2d640818ab5af249622f39482a2b1d04efbf1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/429268fc04441a4a6e31bc9e3c303a8f355f7c43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/429268fc04441a4a6e31bc9e3c303a8f355f7c43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/429268fc04441a4a6e31bc9e3c303a8f355f7c43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/429268fc04441a4a6e31bc9e3c303a8f355f7c43/comments", "author": null, "committer": null, "parents": [{"sha": "b0b0f2b89574b6cfad59e4597463c83efc23d60e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0b0f2b89574b6cfad59e4597463c83efc23d60e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0b0f2b89574b6cfad59e4597463c83efc23d60e"}], "stats": {"total": 75, "additions": 33, "deletions": 42}, "files": [{"sha": "29c53163ef6e89ab926a20845aa992ade84699d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429268fc04441a4a6e31bc9e3c303a8f355f7c43/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429268fc04441a4a6e31bc9e3c303a8f355f7c43/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=429268fc04441a4a6e31bc9e3c303a8f355f7c43", "patch": "@@ -1,3 +1,15 @@\n+2005-08-21  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* tree-vect-transform.c (get_initial_def_for_reduction): Set\n+\tneed_epilog_adjust back to false for MIN/MAX case. Set *scalar_def to\n+\tNULL if need_epilog_adjust is false.\n+\t(vect_create_epilog_for_reduction): Variable adjust_in_epilog removed.\n+\tCase 3 always peels first itration, not just for PLUS case, and no need\n+\tto use scalar_initial_def here. Create an epilog adjustment only if\n+\tscalar_initial_def is not NULL.\n+\n+\t(vectorizable_reduction): Remove assert. \n+\n 2005-08-20  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/23485"}, {"sha": "7c247b1cd246a6f816bc175c5dc20cea099422ea", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 21, "deletions": 42, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429268fc04441a4a6e31bc9e3c303a8f355f7c43/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429268fc04441a4a6e31bc9e3c303a8f355f7c43/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=429268fc04441a4a6e31bc9e3c303a8f355f7c43", "patch": "@@ -751,7 +751,7 @@ get_initial_def_for_reduction (tree stmt, tree init_val, tree *scalar_def)\n   case MAX_EXPR:\n     def = init_val;\n     nelements = nunits;\n-    need_epilog_adjust = true;\n+    need_epilog_adjust = false;\n     break;\n \n   default:\n@@ -775,13 +775,9 @@ get_initial_def_for_reduction (tree stmt, tree init_val, tree *scalar_def)\n     vec = build_constructor_from_list (vectype, t);\n     \n   if (!need_epilog_adjust)\n-    {\n-      if (INTEGRAL_TYPE_P (type))\n-\tinit_val = build_int_cst (type, 0);\n-      else\n-\tinit_val = build_real (type, dconst0);\n-    }\n-  *scalar_def = init_val;\n+    *scalar_def = NULL_TREE;\n+  else\n+    *scalar_def = init_val;\n \n   return vect_init_vector (stmt, vec);\n }\n@@ -862,7 +858,6 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n   bool extract_scalar_result;\n-  bool adjust_in_epilog;\n   \n   /*** 1. Create the reduction def-use cycle  ***/\n   \n@@ -921,7 +916,6 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n       bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n \n       extract_scalar_result = true;\n-      adjust_in_epilog = true;\n     }\n   else\n     {\n@@ -997,13 +991,15 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n \t    }\n \n \t  extract_scalar_result = true;\n-\t  adjust_in_epilog = true;\n \t}\n       else\n         {\n+\t  tree rhs;\n+\n \t  /*** Case 3:\n-\t     Create:  s = init; \n-\t     for (offset=0; offset<vector_size; offset+=element_size;)\n+\t     Create:  \n+\t     s = extract_field <v_out2, 0>\n+\t     for (offset=element_size; offset<vector_size; offset+=element_size;)\n \t       {\n \t         Create:  s' = extract_field <v_out2, offset>\n \t         Create:  s = op <s, s'>\n@@ -1015,33 +1011,19 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n \t  vec_temp = PHI_RESULT (new_phi);\n \t  vec_size_in_bits = tree_low_cst (TYPE_SIZE (vectype), 1);\n \n-\t  /* first iteration is peeled out when possible to minimize\n-\t     the number of operations we generate:  */\n-\t  if (code == PLUS_EXPR \n-\t     && (integer_zerop (scalar_initial_def) \n-\t\t || real_zerop (scalar_initial_def)))\n-\t    {\n-\t      tree rhs = build3 (BIT_FIELD_REF, scalar_type, vec_temp, bitsize,\n-\t\t\t\t bitsize_zero_node);\n+\t  rhs = build3 (BIT_FIELD_REF, scalar_type, vec_temp, bitsize,\n+\t\t\t bitsize_zero_node);\n \n-\t      BIT_FIELD_REF_UNSIGNED (rhs) = TYPE_UNSIGNED (scalar_type);\n-\t      epilog_stmt = build2 (MODIFY_EXPR, scalar_type, new_scalar_dest, \n-\t\t\t\t    rhs);\n-              new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n-              TREE_OPERAND (epilog_stmt, 0) = new_temp;\n-              bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n-              if (vect_print_dump_info (REPORT_DETAILS))\n-                print_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n+\t  BIT_FIELD_REF_UNSIGNED (rhs) = TYPE_UNSIGNED (scalar_type);\n+\t  epilog_stmt = build2 (MODIFY_EXPR, scalar_type, new_scalar_dest, \n+\t\t\t        rhs);\n+\t  new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n+\t  TREE_OPERAND (epilog_stmt, 0) = new_temp;\n+\t  bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    print_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n \t      \n-\t      bit_offset = element_bitsize;\n-\t    }\n-\t  else\n-\t    {\n-\t      new_temp = scalar_initial_def;\n-\t      bit_offset = 0;\n-\t    }\n-\n-\t  for (;\n+\t  for (bit_offset = element_bitsize;\n \t       bit_offset < vec_size_in_bits;\n \t       bit_offset += element_bitsize)\n \t    { \n@@ -1069,7 +1051,6 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n \t    }\n \n \t  extract_scalar_result = false;\n-\t  adjust_in_epilog = false;\n \t}\n     }\n \n@@ -1110,7 +1091,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n \t Create: \n \t s_out = scalar_expr <s_out, scalar_initial_def>  */\n   \n-  if (adjust_in_epilog)\n+  if (scalar_initial_def)\n     {\n       epilog_stmt = build2 (MODIFY_EXPR, scalar_type, new_scalar_dest,\n                       build2 (code, scalar_type, new_temp, scalar_initial_def));\n@@ -1291,8 +1272,6 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   /* Prepare the operand that is defined inside the loop body  */\n   loop_vec_def = vect_get_vec_def_for_operand (op0, stmt, NULL);\n-  gcc_assert (VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (loop_vec_def))));\n-\n \n   /* Create the vectorized operation that computes the partial results  */\n   *vec_stmt = build2 (MODIFY_EXPR, vectype, vec_dest,"}]}