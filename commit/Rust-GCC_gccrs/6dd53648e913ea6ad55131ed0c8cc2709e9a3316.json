{"sha": "6dd53648e913ea6ad55131ed0c8cc2709e9a3316", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRkNTM2NDhlOTEzZWE2YWQ1NTEzMWVkMGM4Y2MyNzA5ZTlhMzMxNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-08-26T00:24:37Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-08-26T00:24:37Z"}, "message": "target-def.h (TARGET_SCALAR_MODE_SUPPORTED_P): New.\n\n        * target-def.h (TARGET_SCALAR_MODE_SUPPORTED_P): New.\n        * target.h (struct gcc_target): Add scalar_mode_supported_p.\n        * targhooks.c (default_scalar_mode_supported_p): New.\n        * targhooks.h (default_scalar_mode_supported_p): Declare.\n        * doc/tm.texi (TARGET_SCALAR_MODE_SUPPORTED_P): Document.\n\n        * c-common.c (handle_mode_attribute): Query scalar_mode_supported_p\n        before attempting to create types.  Tidy.\n        * expr.c (vector_mode_valid_p): Use scalar_mode_supported_p.\n\n        * config/alpha/alpha.c (alpha_scalar_mode_supported_p): New.\n        (TARGET_SCALAR_MODE_SUPPORTED_P): New.\n\nFrom-SVN: r86593", "tree": {"sha": "16040afedbe7456a6d5be99edc239c4efcbd88c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16040afedbe7456a6d5be99edc239c4efcbd88c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dd53648e913ea6ad55131ed0c8cc2709e9a3316", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dd53648e913ea6ad55131ed0c8cc2709e9a3316", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dd53648e913ea6ad55131ed0c8cc2709e9a3316", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dd53648e913ea6ad55131ed0c8cc2709e9a3316/comments", "author": null, "committer": null, "parents": [{"sha": "9950712b1dd1615314417b98f8a26cfe5c6b2f32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9950712b1dd1615314417b98f8a26cfe5c6b2f32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9950712b1dd1615314417b98f8a26cfe5c6b2f32"}], "stats": {"total": 210, "additions": 174, "deletions": 36}, "files": [{"sha": "43d00b5fd3913b205913ebd5f1bcffbed256e5ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd53648e913ea6ad55131ed0c8cc2709e9a3316/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd53648e913ea6ad55131ed0c8cc2709e9a3316/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6dd53648e913ea6ad55131ed0c8cc2709e9a3316", "patch": "@@ -1,3 +1,18 @@\n+2004-08-25  Richard Henderson  <rth@redhat.com>\n+\n+\t* target-def.h (TARGET_SCALAR_MODE_SUPPORTED_P): New.\n+\t* target.h (struct gcc_target): Add scalar_mode_supported_p.\n+\t* targhooks.c (default_scalar_mode_supported_p): New.\n+\t* targhooks.h (default_scalar_mode_supported_p): Declare.\n+\t* doc/tm.texi (TARGET_SCALAR_MODE_SUPPORTED_P): Document.\n+\n+\t* c-common.c (handle_mode_attribute): Query scalar_mode_supported_p\n+\tbefore attempting to create types.  Tidy.\n+\t* expr.c (vector_mode_valid_p): Use scalar_mode_supported_p.\n+\n+\t* config/alpha/alpha.c (alpha_scalar_mode_supported_p): New.\n+\t(TARGET_SCALAR_MODE_SUPPORTED_P): New.\n+\n 2004-08-25  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/freebsd.h (SUBTARGET_OVERRIDE_OPTIONS): Don't"}, {"sha": "7e691660ac463d3895d130ca1810529dd450874f", "filename": "gcc/c-common.c", "status": "modified", "additions": 46, "deletions": 30, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd53648e913ea6ad55131ed0c8cc2709e9a3316/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd53648e913ea6ad55131ed0c8cc2709e9a3316/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=6dd53648e913ea6ad55131ed0c8cc2709e9a3316", "patch": "@@ -4267,7 +4267,7 @@ handle_mode_attribute (tree *node, tree name, tree args,\n       int len = strlen (p);\n       enum machine_mode mode = VOIDmode;\n       tree typefm;\n-      tree ptr_type;\n+      bool valid_mode;\n \n       if (len > 4 && p[0] == '_' && p[1] == '_'\n \t  && p[len - 1] == '_' && p[len - 2] == '_')\n@@ -4294,51 +4294,67 @@ handle_mode_attribute (tree *node, tree name, tree args,\n \n       if (mode == VOIDmode)\n \t{\n-\t  error (\"unknown machine mode `%s'\", p);\n+\t  error (\"unknown machine mode %<%s%>\", p);\n \t  return NULL_TREE;\n \t}\n \n-      if (VECTOR_MODE_P (mode))\n+      valid_mode = false;\n+      switch (GET_MODE_CLASS (mode))\n \t{\n+\tcase MODE_INT:\n+\tcase MODE_PARTIAL_INT:\n+\tcase MODE_FLOAT:\n+\t  valid_mode = targetm.scalar_mode_supported_p (mode);\n+\t  break;\n+\n+\tcase MODE_COMPLEX_INT:\n+\tcase MODE_COMPLEX_FLOAT:\n+\t  valid_mode = targetm.scalar_mode_supported_p (GET_MODE_INNER (mode));\n+\t  break;\n+\n+\tcase MODE_VECTOR_INT:\n+\tcase MODE_VECTOR_FLOAT:\n \t  warning (\"specifying vector types with __attribute__ ((mode)) \"\n \t\t   \"is deprecated\");\n \t  warning (\"use __attribute__ ((vector_size)) instead\");\n-\t}\n+\t  valid_mode = vector_mode_valid_p (mode);\n+\t  break;\n \n-      typefm = lang_hooks.types.type_for_mode (mode, TYPE_UNSIGNED (type));\n-      if (typefm == NULL_TREE)\n-\terror (\"no data type for mode `%s'\", p);\n+\tdefault:\n+\t  break;\n+\t}\n+      if (!valid_mode)\n+\t{\n+\t  error (\"unable to emulate %<%s%>\", p);\n+\t  return NULL_TREE;\n+\t}\n \n-      else if ((TREE_CODE (type) == POINTER_TYPE\n-\t\t|| TREE_CODE (type) == REFERENCE_TYPE)\n-\t       && !targetm.valid_pointer_mode (mode))\n-\terror (\"invalid pointer mode `%s'\", p);\n-      else\n+      if (POINTER_TYPE_P (type))\n \t{\n-\t  /* If this is a vector, make sure we either have hardware\n-\t     support, or we can emulate it.  */\n-\t  if (VECTOR_MODE_P (mode) && !vector_mode_valid_p (mode))\n+\t  tree (*fn)(tree, enum machine_mode, bool);\n+\n+\t  if (!targetm.valid_pointer_mode (mode))\n \t    {\n-\t      error (\"unable to emulate '%s'\", GET_MODE_NAME (mode));\n+\t      error (\"invalid pointer mode %<%s%>\", p);\n \t      return NULL_TREE;\n \t    }\n \n-\t  if (TREE_CODE (type) == POINTER_TYPE)\n-\t    {\n-\t      ptr_type = build_pointer_type_for_mode (TREE_TYPE (type),\n-\t\t\t\t\t\t      mode, false);\n-\t      *node = ptr_type;\n-\t    }\n-\t  else if (TREE_CODE (type) == REFERENCE_TYPE)\n-\t    {\n-\t      ptr_type = build_reference_type_for_mode (TREE_TYPE (type),\n-\t\t\t\t\t\t\tmode, false);\n-\t      *node = ptr_type;\n-\t    }\n+          if (TREE_CODE (type) == POINTER_TYPE)\n+\t    fn = build_pointer_type_for_mode;\n \t  else\n-\t    *node = typefm;\n-\t  /* No need to layout the type here.  The caller should do this.  */\n+\t    fn = build_reference_type_for_mode;\n+\t  typefm = fn (TREE_TYPE (type), mode, false);\n \t}\n+      else\n+        typefm = lang_hooks.types.type_for_mode (mode, TYPE_UNSIGNED (type));\n+      if (typefm == NULL_TREE)\n+\t{\n+\t  error (\"no data type for mode %<%s%>\", p);\n+\t  return NULL_TREE;\n+\t}\n+      *node = typefm;\n+\n+      /* No need to layout the type here.  The caller should do this.  */\n     }\n \n   return NULL_TREE;"}, {"sha": "c6d93446a840acad106a2bf8c14a502a09b6fe98", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd53648e913ea6ad55131ed0c8cc2709e9a3316/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd53648e913ea6ad55131ed0c8cc2709e9a3316/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=6dd53648e913ea6ad55131ed0c8cc2709e9a3316", "patch": "@@ -670,14 +670,45 @@ alpha_extra_constraint (rtx value, int c)\n     }\n }\n \n-/* Implements target hook vector_mode_supported_p.  */\n+/* The scalar modes supported differs from the default check-what-c-supports\n+   version in that sometimes TFmode is available even when long double\n+   indicates only DFmode.  On unicosmk, we have the situation that HImode\n+   doesn't map to any C type, but of course we still support that.  */\n+\n+static bool\n+alpha_scalar_mode_supported_p (enum machine_mode mode)\n+{\n+  switch (mode)\n+    {\n+    case QImode:\n+    case HImode:\n+    case SImode:\n+    case DImode:\n+    case TImode: /* via optabs.c */\n+      return true;\n+\n+    case SFmode:\n+    case DFmode:\n+      return true;\n+\n+    case TFmode:\n+      return TARGET_HAS_XFLOATING_LIBS;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Alpha implements a couple of integer vector mode operations when\n+   TARGET_MAX is enabled.  */\n+\n static bool\n alpha_vector_mode_supported_p (enum machine_mode mode)\n {\n   if (TARGET_MAX\n-      && ((mode == V8QImode)\n-\t  || (mode == V4HImode)\n-\t  || (mode == V2SImode)))\n+      && (mode == V8QImode\n+\t  || mode == V4HImode\n+\t  || mode == V2SImode))\n     return true;\n \n   return false;\n@@ -9362,6 +9393,9 @@ alpha_init_libfuncs (void)\n #define TARGET_SPLIT_COMPLEX_ARG alpha_split_complex_arg\n #undef TARGET_GIMPLIFY_VA_ARG_EXPR\n #define TARGET_GIMPLIFY_VA_ARG_EXPR alpha_gimplify_va_arg\n+\n+#undef TARGET_SCALAR_MODE_SUPPORTED_P\n+#define TARGET_SCALAR_MODE_SUPPORTED_P alpha_scalar_mode_supported_p\n #undef TARGET_VECTOR_MODE_SUPPORTED_P\n #define TARGET_VECTOR_MODE_SUPPORTED_P alpha_vector_mode_supported_p\n "}, {"sha": "b15cb53dec67e896eaafb5aea211209f5b86c8b4", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd53648e913ea6ad55131ed0c8cc2709e9a3316/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd53648e913ea6ad55131ed0c8cc2709e9a3316/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=6dd53648e913ea6ad55131ed0c8cc2709e9a3316", "patch": "@@ -3878,6 +3878,18 @@ arguments to @code{va_arg}; the latter two are as in\n @code{gimplify.c:gimplify_expr}.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_SCALAR_MODE_SUPPORTED_P (enum machine_mode @var{mode})\n+Define this to return nonzero if the port is prepared to handle\n+insns involving scalar mode @var{mode}.  For a scalar mode to be\n+considered supported, all the basic arithmetic and comparisons\n+must work.\n+\n+The default version of this hook returns true for any mode\n+required to handle the basic C types (as defined by the port).\n+Included here are the double-word arithmetic supported by the\n+code in @file{optabs.c}.\n+@end deftypefn\n+\n @deftypefn {Target Hook} bool TARGET_VECTOR_MODE_SUPPORTED_P (enum machine_mode @var{mode})\n Define this to return nonzero if the port is prepared to handle\n insns involving vector mode @var{mode}.  At the very least, it"}, {"sha": "6811abedd803a71e6d16d875a7b650cb2850eaf4", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd53648e913ea6ad55131ed0c8cc2709e9a3316/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd53648e913ea6ad55131ed0c8cc2709e9a3316/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6dd53648e913ea6ad55131ed0c8cc2709e9a3316", "patch": "@@ -8799,7 +8799,7 @@ vector_mode_valid_p (enum machine_mode mode)\n \n   /* If we have support for the inner mode, we can safely emulate it.\n      We may not have V2DI, but me can emulate with a pair of DIs.  */\n-  return mov_optab->handlers[innermode].insn_code != CODE_FOR_nothing;\n+  return targetm.scalar_mode_supported_p (innermode);\n }\n \n /* Return a CONST_VECTOR rtx for a VECTOR_CST tree.  */"}, {"sha": "156ebef7c7bcede756f1c382a732913344c277ed", "filename": "gcc/target-def.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd53648e913ea6ad55131ed0c8cc2709e9a3316/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd53648e913ea6ad55131ed0c8cc2709e9a3316/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=6dd53648e913ea6ad55131ed0c8cc2709e9a3316", "patch": "@@ -305,6 +305,10 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_VALID_POINTER_MODE default_valid_pointer_mode\n #endif\n \n+#ifndef TARGET_SCALAR_MODE_SUPPORTED_P\n+#define TARGET_SCALAR_MODE_SUPPORTED_P default_scalar_mode_supported_p\n+#endif\n+\n #ifndef TARGET_VECTOR_MODE_SUPPORTED_P\n #define TARGET_VECTOR_MODE_SUPPORTED_P hook_bool_mode_false\n #endif\n@@ -475,6 +479,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n   TARGET_ENCODE_SECTION_INFO,\t\t\t\\\n   TARGET_STRIP_NAME_ENCODING,\t\t\t\\\n   TARGET_VALID_POINTER_MODE,                    \\\n+  TARGET_SCALAR_MODE_SUPPORTED_P,\t\t\\\n   TARGET_VECTOR_MODE_SUPPORTED_P,               \\\n   TARGET_VECTOR_OPAQUE_P,\t\t\t\\\n   TARGET_RTX_COSTS,\t\t\t\t\\"}, {"sha": "27e4086129e86661aa1e6e5ec7ab4c9e41654f19", "filename": "gcc/target.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd53648e913ea6ad55131ed0c8cc2709e9a3316/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd53648e913ea6ad55131ed0c8cc2709e9a3316/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=6dd53648e913ea6ad55131ed0c8cc2709e9a3316", "patch": "@@ -381,7 +381,14 @@ struct gcc_target\n   /* True if MODE is valid for a pointer in __attribute__((mode(\"MODE\"))).  */\n   bool (* valid_pointer_mode) (enum machine_mode mode);\n \n-  /* True if MODE is valid for a vector.  */\n+  /* True if MODE is valid for the target.  By \"valid\", we mean able to\n+     be manipulated in non-trivial ways.  In particular, this means all\n+     the arithmetic is supported.  */\n+  bool (* scalar_mode_supported_p) (enum machine_mode mode);\n+\n+  /* Similarly for vector modes.  \"Supported\" here is less strict.  At\n+     least some operations are supported; need to check optabs or builtins\n+     for further details.  */\n   bool (* vector_mode_supported_p) (enum machine_mode mode);\n \n   /* True if a vector is opaque.  */"}, {"sha": "6aa2e07117bda7dd563d340a984b31f67c620fa6", "filename": "gcc/targhooks.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd53648e913ea6ad55131ed0c8cc2709e9a3316/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd53648e913ea6ad55131ed0c8cc2709e9a3316/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=6dd53648e913ea6ad55131ed0c8cc2709e9a3316", "patch": "@@ -62,6 +62,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tm_p.h\"\n #include \"target-def.h\"\n \n+\n void\n default_external_libcall (rtx fun ATTRIBUTE_UNUSED)\n {\n@@ -207,3 +208,49 @@ default_unwind_emit (FILE * stream ATTRIBUTE_UNUSED,\n   /* Should never happen.  */\n   abort ();\n }\n+\n+/* True if MODE is valid for the target.  By \"valid\", we mean able to\n+   be manipulated in non-trivial ways.  In particular, this means all\n+   the arithmetic is supported.\n+\n+   By default we guess this means that any C type is supported.  If\n+   we can't map the mode back to a type that would be available in C,\n+   then reject it.  Special case, here, is the double-word arithmetic\n+   supported by optabs.c.  */\n+\n+bool\n+default_scalar_mode_supported_p (enum machine_mode mode)\n+{\n+  int precision = GET_MODE_PRECISION (mode);\n+\n+  switch (GET_MODE_CLASS (mode))\n+    {\n+    case MODE_PARTIAL_INT:\n+    case MODE_INT:\n+      if (precision == CHAR_TYPE_SIZE)\n+\treturn true;\n+      if (precision == SHORT_TYPE_SIZE)\n+\treturn true;\n+      if (precision == INT_TYPE_SIZE)\n+\treturn true;\n+      if (precision == LONG_TYPE_SIZE)\n+\treturn true;\n+      if (precision == LONG_LONG_TYPE_SIZE)\n+\treturn true;\n+      if (precision == 2 * BITS_PER_WORD)\n+\treturn true;\n+      return false;\n+\n+    case MODE_FLOAT:\n+      if (precision == FLOAT_TYPE_SIZE)\n+\treturn true;\n+      if (precision == DOUBLE_TYPE_SIZE)\n+\treturn true;\n+      if (precision == LONG_DOUBLE_TYPE_SIZE)\n+\treturn true;\n+      return false;\n+\n+    default:\n+      abort ();\n+    }\n+}"}, {"sha": "b91e51dec847e026531803a2428cf6b7cef04b16", "filename": "gcc/targhooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd53648e913ea6ad55131ed0c8cc2709e9a3316/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd53648e913ea6ad55131ed0c8cc2709e9a3316/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=6dd53648e913ea6ad55131ed0c8cc2709e9a3316", "patch": "@@ -43,3 +43,5 @@ extern bool hook_pass_by_reference_must_pass_in_stack\n   (CUMULATIVE_ARGS *, enum machine_mode mode, tree, bool);\n \n extern void default_unwind_emit (FILE *, rtx);\n+\n+extern bool default_scalar_mode_supported_p (enum machine_mode);"}]}